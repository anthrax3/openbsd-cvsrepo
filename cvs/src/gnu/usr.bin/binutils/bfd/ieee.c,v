head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.50
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.52
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.11.02.20.45.10;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.22;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.30;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.18;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.33.16;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.01.08;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.45.46;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.57;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.57;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.05.58;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.38.13;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.12.46;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.19.50;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.46;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.26.19;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.18;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.30;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD back-end for ieee-695 objects.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   Written by Steve Chamberlain of Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#define KEEPMINUSPCININST 0

/* IEEE 695 format is a stream of records, which we parse using a simple one-
   token (which is one byte in this lexicon) lookahead recursive decent
   parser.  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "ieee.h"
#include "libieee.h"
#include "safe-ctype.h"

struct output_buffer_struct
{
  unsigned char *ptrp;
  int buffer;
};

static bfd_boolean ieee_write_byte
  PARAMS ((bfd *, int));
static bfd_boolean ieee_write_2bytes
  PARAMS ((bfd *, int));
static bfd_boolean ieee_write_int
  PARAMS ((bfd *, bfd_vma));
static bfd_boolean ieee_write_id
  PARAMS ((bfd *, const char *));
static unsigned short read_2bytes
  PARAMS ((common_header_type *));
static void bfd_get_string
  PARAMS ((common_header_type *, char *, size_t));
static char *read_id
  PARAMS ((common_header_type *));
static bfd_boolean ieee_write_expression
  PARAMS ((bfd *, bfd_vma, asymbol *, bfd_boolean, unsigned int));
static void ieee_write_int5
  PARAMS ((bfd_byte *, bfd_vma));
static bfd_boolean ieee_write_int5_out
  PARAMS ((bfd *, bfd_vma));
static bfd_boolean parse_int
  PARAMS ((common_header_type *, bfd_vma *));
static int parse_i
  PARAMS ((common_header_type *, bfd_boolean *));
static bfd_vma must_parse_int
  PARAMS ((common_header_type *));
static void parse_expression
  PARAMS ((ieee_data_type *, bfd_vma *, ieee_symbol_index_type *,
	   bfd_boolean *, unsigned int *, asection **));
static file_ptr ieee_part_after
  PARAMS ((ieee_data_type *, file_ptr));
static ieee_symbol_type *get_symbol
  PARAMS ((bfd *, ieee_data_type *, ieee_symbol_type *, unsigned int *,
	   ieee_symbol_type ***, unsigned int *, int));
static bfd_boolean ieee_slurp_external_symbols
  PARAMS ((bfd *));
static bfd_boolean ieee_slurp_symbol_table
  PARAMS ((bfd *));
static long ieee_get_symtab_upper_bound
  PARAMS ((bfd *));
static long ieee_canonicalize_symtab
  PARAMS ((bfd *, asymbol **));
static asection *get_section_entry
  PARAMS ((bfd *, ieee_data_type *i, unsigned int));
static void ieee_slurp_sections
  PARAMS ((bfd *));
static bfd_boolean ieee_slurp_debug
  PARAMS ((bfd *));
const bfd_target *ieee_archive_p
  PARAMS ((bfd *));
const bfd_target *ieee_object_p
  PARAMS ((bfd *));
static void ieee_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
static void ieee_print_symbol
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
static bfd_boolean do_one
  PARAMS ((ieee_data_type *, ieee_per_section_type *, unsigned char *,
	   asection *, int));
static bfd_boolean ieee_slurp_section_data
  PARAMS ((bfd *));
static bfd_boolean ieee_new_section_hook
  PARAMS ((bfd *, asection *));
static long ieee_get_reloc_upper_bound
  PARAMS ((bfd *, sec_ptr));
static bfd_boolean ieee_get_section_contents
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
static long ieee_canonicalize_reloc
  PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));
static int comp
  PARAMS ((const PTR, const PTR));
static bfd_boolean ieee_write_section_part
  PARAMS ((bfd *));
static bfd_boolean do_with_relocs
  PARAMS ((bfd *, asection *));
static bfd_boolean do_as_repeat
  PARAMS ((bfd *, asection *));
static bfd_boolean do_without_relocs
  PARAMS ((bfd *, asection *));
static bfd_boolean ieee_mkobject
  PARAMS ((bfd *));
static void fill
  PARAMS ((void));
static void flush
  PARAMS ((void));
static void write_int
  PARAMS ((int));
static void copy_id
  PARAMS ((void));
static void copy_expression
  PARAMS ((void));
static void fill_int
  PARAMS ((struct output_buffer_struct *));
static void drop_int
  PARAMS ((struct output_buffer_struct *));
static void copy_int
  PARAMS ((void));
static void f1_record
  PARAMS ((void));
static void f0_record
  PARAMS ((void));
static void copy_till_end
  PARAMS ((void));
static void f2_record
  PARAMS ((void));
static void f8_record
  PARAMS ((void));
static void e2_record
  PARAMS ((void));
static void block
  PARAMS ((void));
static void relocate_debug
  PARAMS ((bfd *, bfd *));
static bfd_boolean ieee_write_debug_part
  PARAMS ((bfd *));
static bfd_boolean ieee_write_data_part
  PARAMS ((bfd *));
static bfd_boolean init_for_output
  PARAMS ((bfd *));
static bfd_boolean ieee_set_section_contents
  PARAMS ((bfd *, sec_ptr, const PTR, file_ptr, bfd_size_type));
static bfd_boolean ieee_write_external_part
  PARAMS ((bfd *));
static bfd_boolean ieee_write_me_part
  PARAMS ((bfd *));
static bfd_boolean ieee_write_processor
  PARAMS ((bfd *));
static bfd_boolean ieee_write_object_contents
  PARAMS ((bfd *));
static asymbol *ieee_make_empty_symbol
  PARAMS ((bfd *));
static bfd *ieee_openr_next_archived_file
  PARAMS ((bfd *, bfd *));
static bfd_boolean ieee_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
static int ieee_generic_stat_arch_elt
  PARAMS ((bfd *, struct stat *));
static int ieee_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));

/* Functions for writing to ieee files in the strange way that the
   standard requires. */

static bfd_boolean
ieee_write_byte (abfd, barg)
     bfd *abfd;
     int barg;
{
  bfd_byte byte;

  byte = barg;
  if (bfd_bwrite ((PTR) &byte, (bfd_size_type) 1, abfd) != 1)
    return FALSE;
  return TRUE;
}

static bfd_boolean
ieee_write_2bytes (abfd, bytes)
     bfd *abfd;
     int bytes;
{
  bfd_byte buffer[2];

  buffer[0] = bytes >> 8;
  buffer[1] = bytes & 0xff;
  if (bfd_bwrite ((PTR) buffer, (bfd_size_type) 2, abfd) != 2)
    return FALSE;
  return TRUE;
}

static bfd_boolean
ieee_write_int (abfd, value)
     bfd *abfd;
     bfd_vma value;
{
  if (value <= 127)
    {
      if (! ieee_write_byte (abfd, (bfd_byte) value))
	return FALSE;
    }
  else
    {
      unsigned int length;

      /* How many significant bytes ?  */
      /* FIXME FOR LONGER INTS.  */
      if (value & 0xff000000)
	length = 4;
      else if (value & 0x00ff0000)
	length = 3;
      else if (value & 0x0000ff00)
	length = 2;
      else
	length = 1;

      if (! ieee_write_byte (abfd,
			     (bfd_byte) ((int) ieee_number_repeat_start_enum
					 + length)))
	return FALSE;
      switch (length)
	{
	case 4:
	  if (! ieee_write_byte (abfd, (bfd_byte) (value >> 24)))
	    return FALSE;
	  /* Fall through.  */
	case 3:
	  if (! ieee_write_byte (abfd, (bfd_byte) (value >> 16)))
	    return FALSE;
	  /* Fall through.  */
	case 2:
	  if (! ieee_write_byte (abfd, (bfd_byte) (value >> 8)))
	    return FALSE;
	  /* Fall through.  */
	case 1:
	  if (! ieee_write_byte (abfd, (bfd_byte) (value)))
	    return FALSE;
	}
    }

  return TRUE;
}

static bfd_boolean
ieee_write_id (abfd, id)
     bfd *abfd;
     const char *id;
{
  size_t length = strlen (id);

  if (length <= 127)
    {
      if (! ieee_write_byte (abfd, (bfd_byte) length))
	return FALSE;
    }
  else if (length < 255)
    {
      if (! ieee_write_byte (abfd, ieee_extension_length_1_enum)
	  || ! ieee_write_byte (abfd, (bfd_byte) length))
	return FALSE;
    }
  else if (length < 65535)
    {
      if (! ieee_write_byte (abfd, ieee_extension_length_2_enum)
	  || ! ieee_write_2bytes (abfd, (int) length))
	return FALSE;
    }
  else
    {
      (*_bfd_error_handler)
	(_("%s: string too long (%d chars, max 65535)"),
	 bfd_get_filename (abfd), length);
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  if (bfd_bwrite ((PTR) id, (bfd_size_type) length, abfd) != length)
    return FALSE;
  return TRUE;
}

/* Functions for reading from ieee files in the strange way that the
   standard requires.  */

#define this_byte(ieee) *((ieee)->input_p)
#define next_byte(ieee) ((ieee)->input_p++)
#define this_byte_and_next(ieee) (*((ieee)->input_p++))

static unsigned short
read_2bytes (ieee)
     common_header_type *ieee;
{
  unsigned char c1 = this_byte_and_next (ieee);
  unsigned char c2 = this_byte_and_next (ieee);

  return (c1 << 8) | c2;
}

static void
bfd_get_string (ieee, string, length)
     common_header_type *ieee;
     char *string;
     size_t length;
{
  size_t i;

  for (i = 0; i < length; i++)
    string[i] = this_byte_and_next (ieee);
}

static char *
read_id (ieee)
     common_header_type *ieee;
{
  size_t length;
  char *string;

  length = this_byte_and_next (ieee);
  if (length <= 0x7f)
    {
      /* Simple string of length 0 to 127.  */
    }
  else if (length == 0xde)
    {
      /* Length is next byte, allowing 0..255.  */
      length = this_byte_and_next (ieee);
    }
  else if (length == 0xdf)
    {
      /* Length is next two bytes, allowing 0..65535.  */
      length = this_byte_and_next (ieee);
      length = (length * 256) + this_byte_and_next (ieee);
    }

  /* Buy memory and read string.  */
  string = bfd_alloc (ieee->abfd, (bfd_size_type) length + 1);
  if (!string)
    return NULL;
  bfd_get_string (ieee, string, length);
  string[length] = 0;
  return string;
}

static bfd_boolean
ieee_write_expression (abfd, value, symbol, pcrel, index)
     bfd *abfd;
     bfd_vma value;
     asymbol *symbol;
     bfd_boolean pcrel;
     unsigned int index;
{
  unsigned int term_count = 0;

  if (value != 0)
    {
      if (! ieee_write_int (abfd, value))
	return FALSE;
      term_count++;
    }

  /* Badly formatted binaries can have a missing symbol,
     so test here to prevent a seg fault.  */
  if (symbol != NULL)
    {
      if (bfd_is_com_section (symbol->section)
	  || bfd_is_und_section (symbol->section))
	{
	  /* Def of a common symbol.  */
	  if (! ieee_write_byte (abfd, ieee_variable_X_enum)
	      || ! ieee_write_int (abfd, symbol->value))
	    return FALSE;
	  term_count ++;
	}
      else if (! bfd_is_abs_section (symbol->section))
	{
	  /* Ref to defined symbol -  */

	  if (symbol->flags & BSF_GLOBAL)
	    {
	      if (! ieee_write_byte (abfd, ieee_variable_I_enum)
		  || ! ieee_write_int (abfd, symbol->value))
		return FALSE;
	      term_count++;
	    }
	  else if (symbol->flags & (BSF_LOCAL | BSF_SECTION_SYM))
	    {
	      /* This is a reference to a defined local symbol.  We can
		 easily do a local as a section+offset.  */
	      if (! ieee_write_byte (abfd, ieee_variable_R_enum)
		  || ! ieee_write_byte (abfd,
					(bfd_byte) (symbol->section->index
						    + IEEE_SECTION_NUMBER_BASE)))
		return FALSE;

	      term_count++;
	      if (symbol->value != 0)
		{
		  if (! ieee_write_int (abfd, symbol->value))
		    return FALSE;
		  term_count++;
		}
	    }
	  else
	    {
	      (*_bfd_error_handler)
		(_("%s: unrecognized symbol `%s' flags 0x%x"),
		 bfd_get_filename (abfd), bfd_asymbol_name (symbol),
		 symbol->flags);
	      bfd_set_error (bfd_error_invalid_operation);
	      return FALSE;
	    }
	}
    }

  if (pcrel)
    {
      /* Subtract the pc from here by asking for PC of this section.  */
      if (! ieee_write_byte (abfd, ieee_variable_P_enum)
	  || ! ieee_write_byte (abfd,
				(bfd_byte) (index + IEEE_SECTION_NUMBER_BASE))
	  || ! ieee_write_byte (abfd, ieee_function_minus_enum))
	return FALSE;
    }

  /* Handle the degenerate case of a 0 address.  */
  if (term_count == 0)
    if (! ieee_write_int (abfd, (bfd_vma) 0))
      return FALSE;

  while (term_count > 1)
    {
      if (! ieee_write_byte (abfd, ieee_function_plus_enum))
	return FALSE;
      term_count--;
    }

  return TRUE;
}

/* Writes any integer into the buffer supplied and always takes 5 bytes.  */

static void
ieee_write_int5 (buffer, value)
     bfd_byte *buffer;
     bfd_vma value;
{
  buffer[0] = (bfd_byte) ieee_number_repeat_4_enum;
  buffer[1] = (value >> 24) & 0xff;
  buffer[2] = (value >> 16) & 0xff;
  buffer[3] = (value >> 8) & 0xff;
  buffer[4] = (value >> 0) & 0xff;
}

static bfd_boolean
ieee_write_int5_out (abfd, value)
     bfd *abfd;
     bfd_vma value;
{
  bfd_byte b[5];

  ieee_write_int5 (b, value);
  if (bfd_bwrite ((PTR) b, (bfd_size_type) 5, abfd) != 5)
    return FALSE;
  return TRUE;
}

static bfd_boolean
parse_int (ieee, value_ptr)
     common_header_type *ieee;
     bfd_vma *value_ptr;
{
  int value = this_byte (ieee);
  int result;

  if (value >= 0 && value <= 127)
    {
      *value_ptr = value;
      next_byte (ieee);
      return TRUE;
    }
  else if (value >= 0x80 && value <= 0x88)
    {
      unsigned int count = value & 0xf;

      result = 0;
      next_byte (ieee);
      while (count)
	{
	  result = (result << 8) | this_byte_and_next (ieee);
	  count--;
	}
      *value_ptr = result;
      return TRUE;
    }
  return FALSE;
}

static int
parse_i (ieee, ok)
     common_header_type *ieee;
     bfd_boolean *ok;
{
  bfd_vma x;
  *ok = parse_int (ieee, &x);
  return x;
}

static bfd_vma
must_parse_int (ieee)
     common_header_type *ieee;
{
  bfd_vma result;
  BFD_ASSERT (parse_int (ieee, &result));
  return result;
}

typedef struct
{
  bfd_vma value;
  asection *section;
  ieee_symbol_index_type symbol;
} ieee_value_type;


#if KEEPMINUSPCININST

#define SRC_MASK(arg) arg
#define PCREL_OFFSET FALSE

#else

#define SRC_MASK(arg) 0
#define PCREL_OFFSET TRUE

#endif

static reloc_howto_type abs32_howto =
  HOWTO (1,
	 0,
	 2,
	 32,
	 FALSE,
	 0,
	 complain_overflow_bitfield,
	 0,
	 "abs32",
	 TRUE,
	 0xffffffff,
	 0xffffffff,
	 FALSE);

static reloc_howto_type abs16_howto =
  HOWTO (1,
	 0,
	 1,
	 16,
	 FALSE,
	 0,
	 complain_overflow_bitfield,
	 0,
	 "abs16",
	 TRUE,
	 0x0000ffff,
	 0x0000ffff,
	 FALSE);

static reloc_howto_type abs8_howto =
  HOWTO (1,
	 0,
	 0,
	 8,
	 FALSE,
	 0,
	 complain_overflow_bitfield,
	 0,
	 "abs8",
	 TRUE,
	 0x000000ff,
	 0x000000ff,
	 FALSE);

static reloc_howto_type rel32_howto =
  HOWTO (1,
	 0,
	 2,
	 32,
	 TRUE,
	 0,
	 complain_overflow_signed,
	 0,
	 "rel32",
	 TRUE,
	 SRC_MASK (0xffffffff),
	 0xffffffff,
	 PCREL_OFFSET);

static reloc_howto_type rel16_howto =
  HOWTO (1,
	 0,
	 1,
	 16,
	 TRUE,
	 0,
	 complain_overflow_signed,
	 0,
	 "rel16",
	 TRUE,
	 SRC_MASK (0x0000ffff),
	 0x0000ffff,
	 PCREL_OFFSET);

static reloc_howto_type rel8_howto =
  HOWTO (1,
	 0,
	 0,
	 8,
	 TRUE,
	 0,
	 complain_overflow_signed,
	 0,
	 "rel8",
	 TRUE,
	 SRC_MASK (0x000000ff),
	 0x000000ff,
	 PCREL_OFFSET);

static ieee_symbol_index_type NOSYMBOL = {0, 0};

static void
parse_expression (ieee, value, symbol, pcrel, extra, section)
     ieee_data_type *ieee;
     bfd_vma *value;
     ieee_symbol_index_type *symbol;
     bfd_boolean *pcrel;
     unsigned int *extra;
     asection **section;

{
#define POS sp[1]
#define TOS sp[0]
#define NOS sp[-1]
#define INC sp++;
#define DEC sp--;

  bfd_boolean loop = TRUE;
  ieee_value_type stack[10];

  /* The stack pointer always points to the next unused location.  */
#define PUSH(x,y,z) TOS.symbol=x;TOS.section=y;TOS.value=z;INC;
#define POP(x,y,z) DEC;x=TOS.symbol;y=TOS.section;z=TOS.value;
  ieee_value_type *sp = stack;
  asection *dummy;

  while (loop && ieee->h.input_p < ieee->h.last_byte)
    {
      switch (this_byte (&(ieee->h)))
	{
	case ieee_variable_P_enum:
	  /* P variable, current program counter for section n.  */
	  {
	    int section_n;

	    next_byte (&(ieee->h));
	    *pcrel = TRUE;
	    section_n = must_parse_int (&(ieee->h));
	    PUSH (NOSYMBOL, bfd_abs_section_ptr, 0);
	    break;
	  }
	case ieee_variable_L_enum:
	  /* L variable  address of section N.  */
	  next_byte (&(ieee->h));
	  PUSH (NOSYMBOL, ieee->section_table[must_parse_int (&(ieee->h))], 0);
	  break;
	case ieee_variable_R_enum:
	  /* R variable, logical address of section module.  */
	  /* FIXME, this should be different to L.  */
	  next_byte (&(ieee->h));
	  PUSH (NOSYMBOL, ieee->section_table[must_parse_int (&(ieee->h))], 0);
	  break;
	case ieee_variable_S_enum:
	  /* S variable, size in MAUS of section module.  */
	  next_byte (&(ieee->h));
	  PUSH (NOSYMBOL,
		0,
		ieee->section_table[must_parse_int (&(ieee->h))]->_raw_size);
	  break;
	case ieee_variable_I_enum:
	  /* Push the address of variable n.  */
	  {
	    ieee_symbol_index_type sy;
	    next_byte (&(ieee->h));
	    sy.index = (int) must_parse_int (&(ieee->h));
	    sy.letter = 'I';

	    PUSH (sy, bfd_abs_section_ptr, 0);
	  }
	  break;
	case ieee_variable_X_enum:
	  /* Push the address of external variable n.  */
	  {
	    ieee_symbol_index_type sy;
	    next_byte (&(ieee->h));
	    sy.index = (int) (must_parse_int (&(ieee->h)));
	    sy.letter = 'X';

	    PUSH (sy, bfd_und_section_ptr, 0);
	  }
	  break;
	case ieee_function_minus_enum:
	  {
	    bfd_vma value1, value2;
	    asection *section1, *section_dummy;
	    ieee_symbol_index_type sy;
	    next_byte (&(ieee->h));

	    POP (sy, section1, value1);
	    POP (sy, section_dummy, value2);
	    PUSH (sy, section1 ? section1 : section_dummy, value2 - value1);
	  }
	  break;
	case ieee_function_plus_enum:
	  {
	    bfd_vma value1, value2;
	    asection *section1;
	    asection *section2;
	    ieee_symbol_index_type sy1;
	    ieee_symbol_index_type sy2;
	    next_byte (&(ieee->h));

	    POP (sy1, section1, value1);
	    POP (sy2, section2, value2);
	    PUSH (sy1.letter ? sy1 : sy2,
		  bfd_is_abs_section (section1) ? section2 : section1,
		  value1 + value2);
	  }
	  break;
	default:
	  {
	    bfd_vma va;
	    BFD_ASSERT (this_byte (&(ieee->h)) < (int) ieee_variable_A_enum
		    || this_byte (&(ieee->h)) > (int) ieee_variable_Z_enum);
	    if (parse_int (&(ieee->h), &va))
	      {
		PUSH (NOSYMBOL, bfd_abs_section_ptr, va);
	      }
	    else
	      {
		/* Thats all that we can understand.  */
		loop = FALSE;
	      }
	  }
	}
    }

  /* As far as I can see there is a bug in the Microtec IEEE output
     which I'm using to scan, whereby the comma operator is omitted
     sometimes in an expression, giving expressions with too many
     terms.  We can tell if that's the case by ensuring that
     sp == stack here.  If not, then we've pushed something too far,
     so we keep adding.  */
  while (sp != stack + 1)
    {
      asection *section1;
      ieee_symbol_index_type sy1;
      POP (sy1, section1, *extra);
    }

  POP (*symbol, dummy, *value);
  if (section)
    *section = dummy;
}


#define ieee_seek(ieee, offset) \
  do								\
    {								\
      ieee->h.input_p = ieee->h.first_byte + offset;		\
      ieee->h.last_byte = (ieee->h.first_byte			\
			   + ieee_part_after (ieee, offset));	\
    }								\
  while (0)

#define ieee_pos(ieee) \
  (ieee->h.input_p - ieee->h.first_byte)

/* Find the first part of the ieee file after HERE.  */

static file_ptr
ieee_part_after (ieee, here)
     ieee_data_type *ieee;
     file_ptr here;
{
  int part;
  file_ptr after = ieee->w.r.me_record;

  /* File parts can come in any order, except that module end is
     guaranteed to be last (and the header first).  */
  for (part = 0; part < N_W_VARIABLES; part++)
    if (ieee->w.offset[part] > here && after > ieee->w.offset[part])
      after = ieee->w.offset[part];

  return after;
}

static unsigned int last_index;
static char last_type;		/* Is the index for an X or a D.  */

static ieee_symbol_type *
get_symbol (abfd, ieee, last_symbol, symbol_count, pptr, max_index, this_type)
     bfd *abfd ATTRIBUTE_UNUSED;
     ieee_data_type *ieee;
     ieee_symbol_type *last_symbol;
     unsigned int *symbol_count;
     ieee_symbol_type ***pptr;
     unsigned int *max_index;
     int this_type;
{
  /* Need a new symbol.  */
  unsigned int new_index = must_parse_int (&(ieee->h));

  if (new_index != last_index || this_type != last_type)
    {
      ieee_symbol_type *new_symbol;
      bfd_size_type amt = sizeof (ieee_symbol_type);

      new_symbol = (ieee_symbol_type *) bfd_alloc (ieee->h.abfd, amt);
      if (!new_symbol)
	return NULL;

      new_symbol->index = new_index;
      last_index = new_index;
      (*symbol_count)++;
      **pptr = new_symbol;
      *pptr = &new_symbol->next;
      if (new_index > *max_index)
	*max_index = new_index;

      last_type = this_type;
      new_symbol->symbol.section = bfd_abs_section_ptr;
      return new_symbol;
    }
  return last_symbol;
}

static bfd_boolean
ieee_slurp_external_symbols (abfd)
     bfd *abfd;
{
  ieee_data_type *ieee = IEEE_DATA (abfd);
  file_ptr offset = ieee->w.r.external_part;

  ieee_symbol_type **prev_symbols_ptr = &ieee->external_symbols;
  ieee_symbol_type **prev_reference_ptr = &ieee->external_reference;
  ieee_symbol_type *symbol = (ieee_symbol_type *) NULL;
  unsigned int symbol_count = 0;
  bfd_boolean loop = TRUE;
  last_index = 0xffffff;
  ieee->symbol_table_full = TRUE;

  ieee_seek (ieee, offset);

  while (loop)
    {
      switch (this_byte (&(ieee->h)))
	{
	case ieee_nn_record:
	  next_byte (&(ieee->h));

	  symbol = get_symbol (abfd, ieee, symbol, &symbol_count,
			       &prev_symbols_ptr,
			       &ieee->external_symbol_max_index, 'I');
	  if (symbol == NULL)
	    return FALSE;

	  symbol->symbol.the_bfd = abfd;
	  symbol->symbol.name = read_id (&(ieee->h));
	  symbol->symbol.udata.p = (PTR) NULL;
	  symbol->symbol.flags = BSF_NO_FLAGS;
	  break;
	case ieee_external_symbol_enum:
	  next_byte (&(ieee->h));

	  symbol = get_symbol (abfd, ieee, symbol, &symbol_count,
			       &prev_symbols_ptr,
			       &ieee->external_symbol_max_index, 'D');
	  if (symbol == NULL)
	    return FALSE;

	  BFD_ASSERT (symbol->index >= ieee->external_symbol_min_index);

	  symbol->symbol.the_bfd = abfd;
	  symbol->symbol.name = read_id (&(ieee->h));
	  symbol->symbol.udata.p = (PTR) NULL;
	  symbol->symbol.flags = BSF_NO_FLAGS;
	  break;
	case ieee_attribute_record_enum >> 8:
	  {
	    unsigned int symbol_name_index;
	    unsigned int symbol_type_index;
	    unsigned int symbol_attribute_def;
	    bfd_vma value;
	    switch (read_2bytes (&ieee->h))
	      {
	      case ieee_attribute_record_enum:
		symbol_name_index = must_parse_int (&(ieee->h));
		symbol_type_index = must_parse_int (&(ieee->h));
		symbol_attribute_def = must_parse_int (&(ieee->h));
		switch (symbol_attribute_def)
		  {
		  case 8:
		  case 19:
		    parse_int (&ieee->h, &value);
		    break;
		  default:
		    (*_bfd_error_handler)
		      (_("%s: unimplemented ATI record %u for symbol %u"),
		       bfd_archive_filename (abfd), symbol_attribute_def,
		       symbol_name_index);
		    bfd_set_error (bfd_error_bad_value);
		    return FALSE;
		    break;
		  }
		break;
	      case ieee_external_reference_info_record_enum:
		/* Skip over ATX record.  */
		parse_int (&(ieee->h), &value);
		parse_int (&(ieee->h), &value);
		parse_int (&(ieee->h), &value);
		parse_int (&(ieee->h), &value);
		break;
	      case ieee_atn_record_enum:
		/* We may get call optimization information here,
		   which we just ignore.  The format is
		   {$F1}${CE}{index}{$00}{$3F}{$3F}{#_of_ASNs}.  */
		parse_int (&ieee->h, &value);
		parse_int (&ieee->h, &value);
		parse_int (&ieee->h, &value);
		if (value != 0x3f)
		  {
		    (*_bfd_error_handler)
		      (_("%s: unexpected ATN type %d in external part"),
			 bfd_archive_filename (abfd), (int) value);
		    bfd_set_error (bfd_error_bad_value);
		    return FALSE;
		  }
		parse_int (&ieee->h, &value);
		parse_int (&ieee->h, &value);
		while (value > 0)
		  {
		    bfd_vma val1;

		    --value;

		    switch (read_2bytes (&ieee->h))
		      {
		      case ieee_asn_record_enum:
			parse_int (&ieee->h, &val1);
			parse_int (&ieee->h, &val1);
			break;

		      default:
			(*_bfd_error_handler)
			  (_("%s: unexpected type after ATN"),
			     bfd_archive_filename (abfd));
			bfd_set_error (bfd_error_bad_value);
			return FALSE;
		      }
		  }
	      }
	  }
	  break;
	case ieee_value_record_enum >> 8:
	  {
	    unsigned int symbol_name_index;
	    ieee_symbol_index_type symbol_ignore;
	    bfd_boolean pcrel_ignore;
	    unsigned int extra;
	    next_byte (&(ieee->h));
	    next_byte (&(ieee->h));

	    symbol_name_index = must_parse_int (&(ieee->h));
	    parse_expression (ieee,
			      &symbol->symbol.value,
			      &symbol_ignore,
			      &pcrel_ignore,
			      &extra,
			      &symbol->symbol.section);

	    /* Fully linked IEEE-695 files tend to give every symbol
               an absolute value.  Try to convert that back into a
               section relative value.  FIXME: This won't always to
               the right thing.  */
	    if (bfd_is_abs_section (symbol->symbol.section)
		&& (abfd->flags & HAS_RELOC) == 0)
	      {
		bfd_vma val;
		asection *s;

		val = symbol->symbol.value;
		for (s = abfd->sections; s != NULL; s = s->next)
		  {
		    if (val >= s->vma && val < s->vma + s->_raw_size)
		      {
			symbol->symbol.section = s;
			symbol->symbol.value -= s->vma;
			break;
		      }
		  }
	      }

	    symbol->symbol.flags = BSF_GLOBAL | BSF_EXPORT;

	  }
	  break;
	case ieee_weak_external_reference_enum:
	  {
	    bfd_vma size;
	    bfd_vma value;
	    next_byte (&(ieee->h));
	    /* Throw away the external reference index.  */
	    (void) must_parse_int (&(ieee->h));
	    /* Fetch the default size if not resolved.  */
	    size = must_parse_int (&(ieee->h));
	    /* Fetch the default value if available.  */
	    if (! parse_int (&(ieee->h), &value))
	      {
		value = 0;
	      }
	    /* This turns into a common.  */
	    symbol->symbol.section = bfd_com_section_ptr;
	    symbol->symbol.value = size;
	  }
	  break;

	case ieee_external_reference_enum:
	  next_byte (&(ieee->h));

	  symbol = get_symbol (abfd, ieee, symbol, &symbol_count,
			       &prev_reference_ptr,
			       &ieee->external_reference_max_index, 'X');
	  if (symbol == NULL)
	    return FALSE;

	  symbol->symbol.the_bfd = abfd;
	  symbol->symbol.name = read_id (&(ieee->h));
	  symbol->symbol.udata.p = (PTR) NULL;
	  symbol->symbol.section = bfd_und_section_ptr;
	  symbol->symbol.value = (bfd_vma) 0;
	  symbol->symbol.flags = 0;

	  BFD_ASSERT (symbol->index >= ieee->external_reference_min_index);
	  break;

	default:
	  loop = FALSE;
	}
    }

  if (ieee->external_symbol_max_index != 0)
    {
      ieee->external_symbol_count =
	ieee->external_symbol_max_index -
	ieee->external_symbol_min_index + 1;
    }
  else
    {
      ieee->external_symbol_count = 0;
    }

  if (ieee->external_reference_max_index != 0)
    {
      ieee->external_reference_count =
	ieee->external_reference_max_index -
	ieee->external_reference_min_index + 1;
    }
  else
    {
      ieee->external_reference_count = 0;
    }

  abfd->symcount =
    ieee->external_reference_count + ieee->external_symbol_count;

  if (symbol_count != abfd->symcount)
    {
      /* There are gaps in the table -- */
      ieee->symbol_table_full = FALSE;
    }

  *prev_symbols_ptr = (ieee_symbol_type *) NULL;
  *prev_reference_ptr = (ieee_symbol_type *) NULL;

  return TRUE;
}

static bfd_boolean
ieee_slurp_symbol_table (abfd)
     bfd *abfd;
{
  if (! IEEE_DATA (abfd)->read_symbols)
    {
      if (! ieee_slurp_external_symbols (abfd))
	return FALSE;
      IEEE_DATA (abfd)->read_symbols = TRUE;
    }
  return TRUE;
}

static long
ieee_get_symtab_upper_bound (abfd)
     bfd *abfd;
{
  if (! ieee_slurp_symbol_table (abfd))
    return -1;

  return (abfd->symcount != 0) ?
    (abfd->symcount + 1) * (sizeof (ieee_symbol_type *)) : 0;
}

/* Move from our internal lists to the canon table, and insert in
   symbol index order.  */

extern const bfd_target ieee_vec;

static long
ieee_canonicalize_symtab (abfd, location)
     bfd *abfd;
     asymbol **location;
{
  ieee_symbol_type *symp;
  static bfd dummy_bfd;
  static asymbol empty_symbol =
  {
    &dummy_bfd,
    " ieee empty",
    (symvalue) 0,
    BSF_DEBUGGING,
    bfd_abs_section_ptr
#ifdef __STDC__
    /* K&R compilers can't initialise unions.  */
    , { 0 }
#endif
  };

  if (abfd->symcount)
    {
      ieee_data_type *ieee = IEEE_DATA (abfd);
      dummy_bfd.xvec = &ieee_vec;
      if (! ieee_slurp_symbol_table (abfd))
	return -1;

      if (! ieee->symbol_table_full)
	{
	  /* Arrgh - there are gaps in the table, run through and fill them
	     up with pointers to a null place.  */
	  unsigned int i;

	  for (i = 0; i < abfd->symcount; i++)
	    location[i] = &empty_symbol;
	}

      ieee->external_symbol_base_offset = -ieee->external_symbol_min_index;
      for (symp = IEEE_DATA (abfd)->external_symbols;
	   symp != (ieee_symbol_type *) NULL;
	   symp = symp->next)
	/* Place into table at correct index locations.  */
	location[symp->index + ieee->external_symbol_base_offset] = &symp->symbol;

      /* The external refs are indexed in a bit.  */
      ieee->external_reference_base_offset =
	-ieee->external_reference_min_index + ieee->external_symbol_count;

      for (symp = IEEE_DATA (abfd)->external_reference;
	   symp != (ieee_symbol_type *) NULL;
	   symp = symp->next)
	location[symp->index + ieee->external_reference_base_offset] =
	  &symp->symbol;
    }

  if (abfd->symcount)
    location[abfd->symcount] = (asymbol *) NULL;

  return abfd->symcount;
}

static asection *
get_section_entry (abfd, ieee, index)
     bfd *abfd;
     ieee_data_type *ieee;
     unsigned int index;
{
  if (index >= ieee->section_table_size)
    {
      unsigned int c, i;
      asection **n;
      bfd_size_type amt;

      c = ieee->section_table_size;
      if (c == 0)
	c = 20;
      while (c <= index)
	c *= 2;

      amt = c;
      amt *= sizeof (asection *);
      n = (asection **) bfd_realloc (ieee->section_table, amt);
      if (n == NULL)
	return NULL;

      for (i = ieee->section_table_size; i < c; i++)
	n[i] = NULL;

      ieee->section_table = n;
      ieee->section_table_size = c;
    }

  if (ieee->section_table[index] == (asection *) NULL)
    {
      char *tmp = bfd_alloc (abfd, (bfd_size_type) 11);
      asection *section;

      if (!tmp)
	return NULL;
      sprintf (tmp, " fsec%4d", index);
      section = bfd_make_section (abfd, tmp);
      ieee->section_table[index] = section;
      section->flags = SEC_NO_FLAGS;
      section->target_index = index;
      ieee->section_table[index] = section;
    }
  return ieee->section_table[index];
}

static void
ieee_slurp_sections (abfd)
     bfd *abfd;
{
  ieee_data_type *ieee = IEEE_DATA (abfd);
  file_ptr offset = ieee->w.r.section_part;
  char *name;

  if (offset != 0)
    {
      bfd_byte section_type[3];
      ieee_seek (ieee, offset);
      while (TRUE)
	{
	  switch (this_byte (&(ieee->h)))
	    {
	    case ieee_section_type_enum:
	      {
		asection *section;
		unsigned int section_index;
		next_byte (&(ieee->h));
		section_index = must_parse_int (&(ieee->h));

		section = get_section_entry (abfd, ieee, section_index);

		section_type[0] = this_byte_and_next (&(ieee->h));

		/* Set minimal section attributes. Attributes are
		   extended later, based on section contents.  */
		switch (section_type[0])
		  {
		  case 0xC1:
		    /* Normal attributes for absolute sections.  */
		    section_type[1] = this_byte (&(ieee->h));
		    section->flags = SEC_ALLOC;
		    switch (section_type[1])
		      {
		      case 0xD3:	/* AS Absolute section attributes.  */
			next_byte (&(ieee->h));
			section_type[2] = this_byte (&(ieee->h));
			switch (section_type[2])
			  {
			  case 0xD0:
			    /* Normal code.  */
			    next_byte (&(ieee->h));
			    section->flags |= SEC_CODE;
			    break;
			  case 0xC4:
			    /* Normal data.  */
			    next_byte (&(ieee->h));
			    section->flags |= SEC_DATA;
			    break;
			  case 0xD2:
			    next_byte (&(ieee->h));
			    /* Normal rom data.  */
			    section->flags |= SEC_ROM | SEC_DATA;
			    break;
			  default:
			    break;
			  }
		      }
		    break;
		  case 0xC3:	/* Named relocatable sections (type C).  */
		    section_type[1] = this_byte (&(ieee->h));
		    section->flags = SEC_ALLOC;
		    switch (section_type[1])
		      {
		      case 0xD0:	/* Normal code (CP).  */
			next_byte (&(ieee->h));
			section->flags |= SEC_CODE;
			break;
		      case 0xC4:	/* Normal data (CD).  */
			next_byte (&(ieee->h));
			section->flags |= SEC_DATA;
			break;
		      case 0xD2:	/* Normal rom data (CR).  */
			next_byte (&(ieee->h));
			section->flags |= SEC_ROM | SEC_DATA;
			break;
		      default:
			break;
		      }
		  }

		/* Read section name, use it if non empty.  */
		name = read_id (&ieee->h);
		if (name[0])
		  section->name = name;

		/* Skip these fields, which we don't care about.  */
		{
		  bfd_vma parent, brother, context;
		  parse_int (&(ieee->h), &parent);
		  parse_int (&(ieee->h), &brother);
		  parse_int (&(ieee->h), &context);
		}
	      }
	      break;
	    case ieee_section_alignment_enum:
	      {
		unsigned int section_index;
		bfd_vma value;
		asection *section;
		next_byte (&(ieee->h));
		section_index = must_parse_int (&ieee->h);
		section = get_section_entry (abfd, ieee, section_index);
		if (section_index > ieee->section_count)
		  {
		    ieee->section_count = section_index;
		  }
		section->alignment_power =
		  bfd_log2 (must_parse_int (&ieee->h));
		(void) parse_int (&(ieee->h), &value);
	      }
	      break;
	    case ieee_e2_first_byte_enum:
	      {
		asection *section;
		ieee_record_enum_type t;

		t = (ieee_record_enum_type) (read_2bytes (&(ieee->h)));
		switch (t)
		  {
		  case ieee_section_size_enum:
		    section = ieee->section_table[must_parse_int (&(ieee->h))];
		    section->_raw_size = must_parse_int (&(ieee->h));
		    break;
		  case ieee_physical_region_size_enum:
		    section = ieee->section_table[must_parse_int (&(ieee->h))];
		    section->_raw_size = must_parse_int (&(ieee->h));
		    break;
		  case ieee_region_base_address_enum:
		    section = ieee->section_table[must_parse_int (&(ieee->h))];
		    section->vma = must_parse_int (&(ieee->h));
		    section->lma = section->vma;
		    break;
		  case ieee_mau_size_enum:
		    must_parse_int (&(ieee->h));
		    must_parse_int (&(ieee->h));
		    break;
		  case ieee_m_value_enum:
		    must_parse_int (&(ieee->h));
		    must_parse_int (&(ieee->h));
		    break;
		  case ieee_section_base_address_enum:
		    section = ieee->section_table[must_parse_int (&(ieee->h))];
		    section->vma = must_parse_int (&(ieee->h));
		    section->lma = section->vma;
		    break;
		  case ieee_section_offset_enum:
		    (void) must_parse_int (&(ieee->h));
		    (void) must_parse_int (&(ieee->h));
		    break;
		  default:
		    return;
		  }
	      }
	      break;
	    default:
	      return;
	    }
	}
    }
}

/* Make a section for the debugging information, if any.  We don't try
   to interpret the debugging information; we just point the section
   at the area in the file so that program which understand can dig it
   out.  */

static bfd_boolean
ieee_slurp_debug (abfd)
     bfd *abfd;
{
  ieee_data_type *ieee = IEEE_DATA (abfd);
  asection *sec;
  file_ptr debug_end;

  if (ieee->w.r.debug_information_part == 0)
    return TRUE;

  sec = bfd_make_section (abfd, ".debug");
  if (sec == NULL)
    return FALSE;
  sec->flags |= SEC_DEBUGGING | SEC_HAS_CONTENTS;
  sec->filepos = ieee->w.r.debug_information_part;

  debug_end = ieee_part_after (ieee, ieee->w.r.debug_information_part);
  sec->_raw_size = debug_end - ieee->w.r.debug_information_part;

  return TRUE;
}

/* Archive stuff.  */

const bfd_target *
ieee_archive_p (abfd)
     bfd *abfd;
{
  char *library;
  unsigned int i;
  unsigned char buffer[512];
  file_ptr buffer_offset = 0;
  ieee_ar_data_type *save = abfd->tdata.ieee_ar_data;
  ieee_ar_data_type *ieee;
  bfd_size_type alc_elts;
  ieee_ar_obstack_type *elts = NULL;
  bfd_size_type amt = sizeof (ieee_ar_data_type);

  abfd->tdata.ieee_ar_data = (ieee_ar_data_type *) bfd_alloc (abfd, amt);
  if (!abfd->tdata.ieee_ar_data)
    goto error_ret_restore;
  ieee = IEEE_AR_DATA (abfd);

  /* Ignore the return value here.  It doesn't matter if we don't read
     the entire buffer.  We might have a very small ieee file.  */
  bfd_bread ((PTR) buffer, (bfd_size_type) sizeof (buffer), abfd);

  ieee->h.first_byte = buffer;
  ieee->h.input_p = buffer;

  ieee->h.abfd = abfd;

  if (this_byte (&(ieee->h)) != Module_Beginning)
    goto got_wrong_format_error;

  next_byte (&(ieee->h));
  library = read_id (&(ieee->h));
  if (strcmp (library, "LIBRARY") != 0)
    goto got_wrong_format_error;

  /* Throw away the filename.  */
  read_id (&(ieee->h));

  ieee->element_count = 0;
  ieee->element_index = 0;

  next_byte (&(ieee->h));	/* Drop the ad part.  */
  must_parse_int (&(ieee->h));	/* And the two dummy numbers.  */
  must_parse_int (&(ieee->h));

  alc_elts = 10;
  elts = (ieee_ar_obstack_type *) bfd_malloc (alc_elts * sizeof *elts);
  if (elts == NULL)
    goto error_return;

  /* Read the index of the BB table.  */
  while (1)
    {
      int rec;
      ieee_ar_obstack_type *t;

      rec = read_2bytes (&(ieee->h));
      if (rec != (int) ieee_assign_value_to_variable_enum)
	break;

      if (ieee->element_count >= alc_elts)
	{
	  ieee_ar_obstack_type *n;

	  alc_elts *= 2;
	  n = ((ieee_ar_obstack_type *)
	       bfd_realloc (elts, alc_elts * sizeof *elts));
	  if (n == NULL)
	    goto error_return;
	  elts = n;
	}

      t = &elts[ieee->element_count];
      ieee->element_count++;

      must_parse_int (&(ieee->h));
      t->file_offset = must_parse_int (&(ieee->h));
      t->abfd = (bfd *) NULL;

      /* Make sure that we don't go over the end of the buffer.  */
      if ((size_t) ieee_pos (IEEE_DATA (abfd)) > sizeof (buffer) / 2)
	{
	  /* Past half way, reseek and reprime.  */
	  buffer_offset += ieee_pos (IEEE_DATA (abfd));
	  if (bfd_seek (abfd, buffer_offset, SEEK_SET) != 0)
	    goto error_return;

	  /* Again ignore return value of bfd_bread.  */
	  bfd_bread ((PTR) buffer, (bfd_size_type) sizeof (buffer), abfd);
	  ieee->h.first_byte = buffer;
	  ieee->h.input_p = buffer;
	}
    }

  amt = ieee->element_count;
  amt *= sizeof *ieee->elements;
  ieee->elements = (ieee_ar_obstack_type *) bfd_alloc (abfd, amt);
  if (ieee->elements == NULL)
    goto error_return;

  memcpy (ieee->elements, elts, (size_t) amt);
  free (elts);
  elts = NULL;

  /* Now scan the area again, and replace BB offsets with file offsets.  */
  for (i = 2; i < ieee->element_count; i++)
    {
      if (bfd_seek (abfd, ieee->elements[i].file_offset, SEEK_SET) != 0)
	goto error_return;

      /* Again ignore return value of bfd_bread.  */
      bfd_bread ((PTR) buffer, (bfd_size_type) sizeof (buffer), abfd);
      ieee->h.first_byte = buffer;
      ieee->h.input_p = buffer;

      next_byte (&(ieee->h));		/* Drop F8.  */
      next_byte (&(ieee->h));		/* Drop 14.  */
      must_parse_int (&(ieee->h));	/* Drop size of block.  */

      if (must_parse_int (&(ieee->h)) != 0)
	/* This object has been deleted.  */
	ieee->elements[i].file_offset = 0;
      else
	ieee->elements[i].file_offset = must_parse_int (&(ieee->h));
    }

  /*  abfd->has_armap = ;*/

  return abfd->xvec;

 got_wrong_format_error:
  bfd_set_error (bfd_error_wrong_format);
 error_return:
  if (elts != NULL)
    free (elts);
  bfd_release (abfd, ieee);
 error_ret_restore:
  abfd->tdata.ieee_ar_data = save;

  return NULL;
}

const bfd_target *
ieee_object_p (abfd)
     bfd *abfd;
{
  char *processor;
  unsigned int part;
  ieee_data_type *ieee;
  unsigned char buffer[300];
  ieee_data_type *save = IEEE_DATA (abfd);
  bfd_size_type amt;

  abfd->tdata.ieee_data = 0;
  ieee_mkobject (abfd);

  ieee = IEEE_DATA (abfd);
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    goto fail;
  /* Read the first few bytes in to see if it makes sense.  Ignore
     bfd_bread return value;  The file might be very small.  */
  bfd_bread ((PTR) buffer, (bfd_size_type) sizeof (buffer), abfd);

  ieee->h.input_p = buffer;
  if (this_byte_and_next (&(ieee->h)) != Module_Beginning)
    goto got_wrong_format;

  ieee->read_symbols = FALSE;
  ieee->read_data = FALSE;
  ieee->section_count = 0;
  ieee->external_symbol_max_index = 0;
  ieee->external_symbol_min_index = IEEE_PUBLIC_BASE;
  ieee->external_reference_min_index = IEEE_REFERENCE_BASE;
  ieee->external_reference_max_index = 0;
  ieee->h.abfd = abfd;
  ieee->section_table = NULL;
  ieee->section_table_size = 0;

  processor = ieee->mb.processor = read_id (&(ieee->h));
  if (strcmp (processor, "LIBRARY") == 0)
    goto got_wrong_format;
  ieee->mb.module_name = read_id (&(ieee->h));
  if (abfd->filename == (const char *) NULL)
    abfd->filename = ieee->mb.module_name;

  /* Determine the architecture and machine type of the object file.  */
  {
    const bfd_arch_info_type *arch;
    char family[10];

    /* IEEE does not specify the format of the processor identification
       string, so the compiler is free to put in it whatever it wants.
       We try here to recognize different processors belonging to the
       m68k family.  Code for other processors can be added here.  */
    if ((processor[0] == '6') && (processor[1] == '8'))
      {
	if (processor[2] == '3')	    /* 683xx integrated processors */
	  {
	    switch (processor[3])
	      {
	      case '0':			    /* 68302, 68306, 68307 */
	      case '2':			    /* 68322, 68328 */
	      case '5':			    /* 68356 */
		strcpy (family, "68000");   /* MC68000-based controllers */
		break;

	      case '3':			    /* 68330, 68331, 68332, 68333,
					       68334, 68335, 68336, 68338 */
	      case '6':			    /* 68360 */
	      case '7':			    /* 68376 */
		strcpy (family, "68332");   /* CPU32 and CPU32+ */
		break;

	      case '4':
		if (processor[4] == '9')    /* 68349 */
		  strcpy (family, "68030"); /* CPU030 */
		else		            /* 68340, 68341 */
		  strcpy (family, "68332"); /* CPU32 and CPU32+ */
		break;

	      default:			    /* Does not exist yet */
		strcpy (family, "68332");   /* Guess it will be CPU32 */
	      }
	  }
	else if (TOUPPER (processor[3]) == 'F')  /* 68F333 */
	  strcpy (family, "68332");	           /* CPU32 */
	else if ((TOUPPER (processor[3]) == 'C') /* Embedded controllers.  */
		 && ((TOUPPER (processor[2]) == 'E')
		     || (TOUPPER (processor[2]) == 'H')
		     || (TOUPPER (processor[2]) == 'L')))
	  {
	    strcpy (family, "68");
	    strncat (family, processor + 4, 7);
	    family[9] = '\0';
	  }
	else				 /* "Regular" processors.  */
	  {
	    strncpy (family, processor, 9);
	    family[9] = '\0';
	  }
      }
    else if ((strncmp (processor, "cpu32", 5) == 0) /* CPU32 and CPU32+ */
	     || (strncmp (processor, "CPU32", 5) == 0))
      strcpy (family, "68332");
    else
      {
	strncpy (family, processor, 9);
	family[9] = '\0';
      }

    arch = bfd_scan_arch (family);
    if (arch == 0)
      goto got_wrong_format;
    abfd->arch_info = arch;
  }

  if (this_byte (&(ieee->h)) != (int) ieee_address_descriptor_enum)
    goto fail;

  next_byte (&(ieee->h));

  if (! parse_int (&(ieee->h), &ieee->ad.number_of_bits_mau))
    goto fail;

  if (! parse_int (&(ieee->h), &ieee->ad.number_of_maus_in_address))
    goto fail;

  /* If there is a byte order info, take it.  */
  if (this_byte (&(ieee->h)) == (int) ieee_variable_L_enum
      || this_byte (&(ieee->h)) == (int) ieee_variable_M_enum)
    next_byte (&(ieee->h));

  for (part = 0; part < N_W_VARIABLES; part++)
    {
      bfd_boolean ok;

      if (read_2bytes (&(ieee->h)) != (int) ieee_assign_value_to_variable_enum)
	goto fail;

      if (this_byte_and_next (&(ieee->h)) != part)
	goto fail;

      ieee->w.offset[part] = parse_i (&(ieee->h), &ok);
      if (! ok)
	goto fail;
    }

  if (ieee->w.r.external_part != 0)
    abfd->flags = HAS_SYMS;

  /* By now we know that this is a real IEEE file, we're going to read
     the whole thing into memory so that we can run up and down it
     quickly.  We can work out how big the file is from the trailer
     record.  */

  amt = ieee->w.r.me_record + 1;
  IEEE_DATA (abfd)->h.first_byte =
    (unsigned char *) bfd_alloc (ieee->h.abfd, amt);
  if (!IEEE_DATA (abfd)->h.first_byte)
    goto fail;
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    goto fail;
  /* FIXME: Check return value.  I'm not sure whether it needs to read
     the entire buffer or not.  */
  bfd_bread ((PTR) (IEEE_DATA (abfd)->h.first_byte),
	    (bfd_size_type) ieee->w.r.me_record + 1, abfd);

  ieee_slurp_sections (abfd);

  if (! ieee_slurp_debug (abfd))
    goto fail;

  /* Parse section data to activate file and section flags implied by
     section contents. */
  if (! ieee_slurp_section_data (abfd))
    goto fail;

  return abfd->xvec;
got_wrong_format:
  bfd_set_error (bfd_error_wrong_format);
fail:
  bfd_release (abfd, ieee);
  abfd->tdata.ieee_data = save;
  return (const bfd_target *) NULL;
}

static void
ieee_get_symbol_info (ignore_abfd, symbol, ret)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *symbol;
     symbol_info *ret;
{
  bfd_symbol_info (symbol, ret);
  if (symbol->name[0] == ' ')
    ret->name = "* empty table entry ";
  if (!symbol->section)
    ret->type = (symbol->flags & BSF_LOCAL) ? 'a' : 'A';
}

static void
ieee_print_symbol (abfd, afile, symbol, how)
     bfd *abfd;
     PTR afile;
     asymbol *symbol;
     bfd_print_symbol_type how;
{
  FILE *file = (FILE *) afile;

  switch (how)
    {
    case bfd_print_symbol_name:
      fprintf (file, "%s", symbol->name);
      break;
    case bfd_print_symbol_more:
#if 0
      fprintf (file, "%4x %2x", aout_symbol (symbol)->desc & 0xffff,
	       aout_symbol (symbol)->other & 0xff);
#endif
      BFD_FAIL ();
      break;
    case bfd_print_symbol_all:
      {
	const char *section_name =
	  (symbol->section == (asection *) NULL
	   ? "*abs"
	   : symbol->section->name);

	if (symbol->name[0] == ' ')
	  {
	    fprintf (file, "* empty table entry ");
	  }
	else
	  {
	    bfd_print_symbol_vandf (abfd, (PTR) file, symbol);

	    fprintf (file, " %-5s %04x %02x %s",
		     section_name,
		     (unsigned) ieee_symbol (symbol)->index,
		     (unsigned) 0,
		     symbol->name);
	  }
      }
      break;
    }
}

static bfd_boolean
do_one (ieee, current_map, location_ptr, s, iterations)
     ieee_data_type *ieee;
     ieee_per_section_type *current_map;
     unsigned char *location_ptr;
     asection *s;
     int iterations;
{
  switch (this_byte (&(ieee->h)))
    {
    case ieee_load_constant_bytes_enum:
      {
	unsigned int number_of_maus;
	unsigned int i;

	next_byte (&(ieee->h));
	number_of_maus = must_parse_int (&(ieee->h));

	for (i = 0; i < number_of_maus; i++)
	  {
	    location_ptr[current_map->pc++] = this_byte (&(ieee->h));
	    next_byte (&(ieee->h));
	  }
      }
      break;

    case ieee_load_with_relocation_enum:
      {
	bfd_boolean loop = TRUE;

	next_byte (&(ieee->h));
	while (loop)
	  {
	    switch (this_byte (&(ieee->h)))
	      {
	      case ieee_variable_R_enum:

	      case ieee_function_signed_open_b_enum:
	      case ieee_function_unsigned_open_b_enum:
	      case ieee_function_either_open_b_enum:
		{
		  unsigned int extra = 4;
		  bfd_boolean pcrel = FALSE;
		  asection *section;
		  ieee_reloc_type *r;
		  bfd_size_type amt = sizeof (ieee_reloc_type);

		  r = (ieee_reloc_type *) bfd_alloc (ieee->h.abfd, amt);
		  if (!r)
		    return FALSE;

		  *(current_map->reloc_tail_ptr) = r;
		  current_map->reloc_tail_ptr = &r->next;
		  r->next = (ieee_reloc_type *) NULL;
		  next_byte (&(ieee->h));
/*			    abort();*/
		  r->relent.sym_ptr_ptr = 0;
		  parse_expression (ieee,
				    &r->relent.addend,
				    &r->symbol,
				    &pcrel, &extra, &section);
		  r->relent.address = current_map->pc;
		  s->flags |= SEC_RELOC;
		  s->owner->flags |= HAS_RELOC;
		  s->reloc_count++;
		  if (r->relent.sym_ptr_ptr == NULL && section != NULL)
		    r->relent.sym_ptr_ptr = section->symbol_ptr_ptr;

		  if (this_byte (&(ieee->h)) == (int) ieee_comma)
		    {
		      next_byte (&(ieee->h));
		      /* Fetch number of bytes to pad.  */
		      extra = must_parse_int (&(ieee->h));
		    };

		  switch (this_byte (&(ieee->h)))
		    {
		    case ieee_function_signed_close_b_enum:
		      next_byte (&(ieee->h));
		      break;
		    case ieee_function_unsigned_close_b_enum:
		      next_byte (&(ieee->h));
		      break;
		    case ieee_function_either_close_b_enum:
		      next_byte (&(ieee->h));
		      break;
		    default:
		      break;
		    }
		  /* Build a relocation entry for this type.  */
		  /* If pc rel then stick -ve pc into instruction
		     and take out of reloc ..

		     I've changed this. It's all too complicated. I
		     keep 0 in the instruction now.  */

		  switch (extra)
		    {
		    case 0:
		    case 4:

		      if (pcrel)
			{
#if KEEPMINUSPCININST
			  bfd_put_32 (ieee->h.abfd, -current_map->pc,
				      location_ptr + current_map->pc);
			  r->relent.howto = &rel32_howto;
			  r->relent.addend -= current_map->pc;
#else
			  bfd_put_32 (ieee->h.abfd, (bfd_vma) 0, location_ptr +
				      current_map->pc);
			  r->relent.howto = &rel32_howto;
#endif
			}
		      else
			{
			  bfd_put_32 (ieee->h.abfd, (bfd_vma) 0,
				      location_ptr + current_map->pc);
			  r->relent.howto = &abs32_howto;
			}
		      current_map->pc += 4;
		      break;
		    case 2:
		      if (pcrel)
			{
#if KEEPMINUSPCININST
			  bfd_put_16 (ieee->h.abfd, (bfd_vma) -current_map->pc,
				      location_ptr + current_map->pc);
			  r->relent.addend -= current_map->pc;
			  r->relent.howto = &rel16_howto;
#else

			  bfd_put_16 (ieee->h.abfd, (bfd_vma) 0,
				      location_ptr + current_map->pc);
			  r->relent.howto = &rel16_howto;
#endif
			}

		      else
			{
			  bfd_put_16 (ieee->h.abfd, (bfd_vma) 0,
				      location_ptr + current_map->pc);
			  r->relent.howto = &abs16_howto;
			}
		      current_map->pc += 2;
		      break;
		    case 1:
		      if (pcrel)
			{
#if KEEPMINUSPCININST
			  bfd_put_8 (ieee->h.abfd, (int) (-current_map->pc), location_ptr + current_map->pc);
			  r->relent.addend -= current_map->pc;
			  r->relent.howto = &rel8_howto;
#else
			  bfd_put_8 (ieee->h.abfd, 0, location_ptr + current_map->pc);
			  r->relent.howto = &rel8_howto;
#endif
			}
		      else
			{
			  bfd_put_8 (ieee->h.abfd, 0, location_ptr + current_map->pc);
			  r->relent.howto = &abs8_howto;
			}
		      current_map->pc += 1;
		      break;

		    default:
		      BFD_FAIL ();
		      return FALSE;
		    }
		}
		break;
	      default:
		{
		  bfd_vma this_size;
		  if (parse_int (&(ieee->h), &this_size))
		    {
		      unsigned int i;
		      for (i = 0; i < this_size; i++)
			{
			  location_ptr[current_map->pc++] = this_byte (&(ieee->h));
			  next_byte (&(ieee->h));
			}
		    }
		  else
		    {
		      loop = FALSE;
		    }
		}
	      }

	    /* Prevent more than the first load-item of an LR record
	       from being repeated (MRI convention). */
	    if (iterations != 1)
	      loop = FALSE;
	  }
      }
    }
  return TRUE;
}

/* Read in all the section data and relocation stuff too.  */

static bfd_boolean
ieee_slurp_section_data (abfd)
     bfd *abfd;
{
  bfd_byte *location_ptr = (bfd_byte *) NULL;
  ieee_data_type *ieee = IEEE_DATA (abfd);
  unsigned int section_number;

  ieee_per_section_type *current_map = (ieee_per_section_type *) NULL;
  asection *s;
  /* Seek to the start of the data area.  */
  if (ieee->read_data)
    return TRUE;
  ieee->read_data = TRUE;
  ieee_seek (ieee, ieee->w.r.data_part);

  /* Allocate enough space for all the section contents.  */
  for (s = abfd->sections; s != (asection *) NULL; s = s->next)
    {
      ieee_per_section_type *per = ieee_per_section (s);
      if ((s->flags & SEC_DEBUGGING) != 0)
	continue;
      per->data = (bfd_byte *) bfd_alloc (ieee->h.abfd, s->_raw_size);
      if (!per->data)
	return FALSE;
      per->reloc_tail_ptr =
	(ieee_reloc_type **) & (s->relocation);
    }

  while (TRUE)
    {
      switch (this_byte (&(ieee->h)))
	{
	  /* IF we see anything strange then quit.  */
	default:
	  return TRUE;

	case ieee_set_current_section_enum:
	  next_byte (&(ieee->h));
	  section_number = must_parse_int (&(ieee->h));
	  s = ieee->section_table[section_number];
	  s->flags |= SEC_LOAD | SEC_HAS_CONTENTS;
	  current_map = ieee_per_section (s);
	  location_ptr = current_map->data - s->vma;
	  /* The document I have says that Microtec's compilers reset
	     this after a sec section, even though the standard says not
	     to, SO...  */
	  current_map->pc = s->vma;
	  break;

	case ieee_e2_first_byte_enum:
	  next_byte (&(ieee->h));
	  switch (this_byte (&(ieee->h)))
	    {
	    case ieee_set_current_pc_enum & 0xff:
	      {
		bfd_vma value;
		ieee_symbol_index_type symbol;
		unsigned int extra;
		bfd_boolean pcrel;

		next_byte (&(ieee->h));
		must_parse_int (&(ieee->h));	/* Throw away section #.  */
		parse_expression (ieee, &value,
				  &symbol,
				  &pcrel, &extra,
				  0);
		current_map->pc = value;
		BFD_ASSERT ((unsigned) (value - s->vma) <= s->_raw_size);
	      }
	      break;

	    case ieee_value_starting_address_enum & 0xff:
	      next_byte (&(ieee->h));
	      if (this_byte (&(ieee->h)) == ieee_function_either_open_b_enum)
		next_byte (&(ieee->h));
	      abfd->start_address = must_parse_int (&(ieee->h));
	      /* We've got to the end of the data now -  */
	      return TRUE;
	    default:
	      BFD_FAIL ();
	      return FALSE;
	    }
	  break;
	case ieee_repeat_data_enum:
	  {
	    /* Repeat the following LD or LR n times - we do this by
	       remembering the stream pointer before running it and
	       resetting it and running it n times. We special case
	       the repetition of a repeat_data/load_constant.  */
	    unsigned int iterations;
	    unsigned char *start;

	    next_byte (&(ieee->h));
	    iterations = must_parse_int (&(ieee->h));
	    start = ieee->h.input_p;
	    if (start[0] == (int) ieee_load_constant_bytes_enum
		&& start[1] == 1)
	      {
		while (iterations != 0)
		  {
		    location_ptr[current_map->pc++] = start[2];
		    iterations--;
		  }
		next_byte (&(ieee->h));
		next_byte (&(ieee->h));
		next_byte (&(ieee->h));
	      }
	    else
	      {
		while (iterations != 0)
		  {
		    ieee->h.input_p = start;
		    if (!do_one (ieee, current_map, location_ptr, s,
				 (int) iterations))
		      return FALSE;
		    iterations--;
		  }
	      }
	  }
	  break;
	case ieee_load_constant_bytes_enum:
	case ieee_load_with_relocation_enum:
	  if (!do_one (ieee, current_map, location_ptr, s, 1))
	    return FALSE;
	}
    }
}

static bfd_boolean
ieee_new_section_hook (abfd, newsect)
     bfd *abfd;
     asection *newsect;
{
  newsect->used_by_bfd
    = (PTR) bfd_alloc (abfd, (bfd_size_type) sizeof (ieee_per_section_type));
  if (!newsect->used_by_bfd)
    return FALSE;
  ieee_per_section (newsect)->data = (bfd_byte *) NULL;
  ieee_per_section (newsect)->section = newsect;
  return TRUE;
}

static long
ieee_get_reloc_upper_bound (abfd, asect)
     bfd *abfd;
     sec_ptr asect;
{
  if ((asect->flags & SEC_DEBUGGING) != 0)
    return 0;
  if (! ieee_slurp_section_data (abfd))
    return -1;
  return (asect->reloc_count + 1) * sizeof (arelent *);
}

static bfd_boolean
ieee_get_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     PTR location;
     file_ptr offset;
     bfd_size_type count;
{
  ieee_per_section_type *p = ieee_per_section (section);
  if ((section->flags & SEC_DEBUGGING) != 0)
    return _bfd_generic_get_section_contents (abfd, section, location,
					      offset, count);
  ieee_slurp_section_data (abfd);
  (void) memcpy ((PTR) location, (PTR) (p->data + offset), (unsigned) count);
  return TRUE;
}

static long
ieee_canonicalize_reloc (abfd, section, relptr, symbols)
     bfd *abfd;
     sec_ptr section;
     arelent **relptr;
     asymbol **symbols;
{
  ieee_reloc_type *src = (ieee_reloc_type *) (section->relocation);
  ieee_data_type *ieee = IEEE_DATA (abfd);

  if ((section->flags & SEC_DEBUGGING) != 0)
    return 0;

  while (src != (ieee_reloc_type *) NULL)
    {
      /* Work out which symbol to attach it this reloc to.  */
      switch (src->symbol.letter)
	{
	case 'I':
	  src->relent.sym_ptr_ptr =
	    symbols + src->symbol.index + ieee->external_symbol_base_offset;
	  break;
	case 'X':
	  src->relent.sym_ptr_ptr =
	    symbols + src->symbol.index + ieee->external_reference_base_offset;
	  break;
	case 0:
	  if (src->relent.sym_ptr_ptr != NULL)
	    src->relent.sym_ptr_ptr =
	      src->relent.sym_ptr_ptr[0]->section->symbol_ptr_ptr;
	  break;
	default:

	  BFD_FAIL ();
	}
      *relptr++ = &src->relent;
      src = src->next;
    }
  *relptr = (arelent *) NULL;
  return section->reloc_count;
}

static int
comp (ap, bp)
     const PTR ap;
     const PTR bp;
{
  arelent *a = *((arelent **) ap);
  arelent *b = *((arelent **) bp);
  return a->address - b->address;
}

/* Write the section headers.  */

static bfd_boolean
ieee_write_section_part (abfd)
     bfd *abfd;
{
  ieee_data_type *ieee = IEEE_DATA (abfd);
  asection *s;
  ieee->w.r.section_part = bfd_tell (abfd);
  for (s = abfd->sections; s != (asection *) NULL; s = s->next)
    {
      if (! bfd_is_abs_section (s)
	  && (s->flags & SEC_DEBUGGING) == 0)
	{
	  if (! ieee_write_byte (abfd, ieee_section_type_enum)
	      || ! ieee_write_byte (abfd,
				    (bfd_byte) (s->index
						+ IEEE_SECTION_NUMBER_BASE)))
	    return FALSE;

	  if (abfd->flags & EXEC_P)
	    {
	      /* This image is executable, so output absolute sections.  */
	      if (! ieee_write_byte (abfd, ieee_variable_A_enum)
		  || ! ieee_write_byte (abfd, ieee_variable_S_enum))
		return FALSE;
	    }
	  else
	    {
	      if (! ieee_write_byte (abfd, ieee_variable_C_enum))
		return FALSE;
	    }

	  switch (s->flags & (SEC_CODE | SEC_DATA | SEC_ROM))
	    {
	    case SEC_CODE | SEC_LOAD:
	    case SEC_CODE:
	      if (! ieee_write_byte (abfd, ieee_variable_P_enum))
		return FALSE;
	      break;
	    case SEC_DATA:
	    default:
	      if (! ieee_write_byte (abfd, ieee_variable_D_enum))
		return FALSE;
	      break;
	    case SEC_ROM:
	    case SEC_ROM | SEC_DATA:
	    case SEC_ROM | SEC_LOAD:
	    case SEC_ROM | SEC_DATA | SEC_LOAD:
	      if (! ieee_write_byte (abfd, ieee_variable_R_enum))
		return FALSE;
	    }


	  if (! ieee_write_id (abfd, s->name))
	    return FALSE;
#if 0
	  ieee_write_int (abfd, 0);	/* Parent */
	  ieee_write_int (abfd, 0);	/* Brother */
	  ieee_write_int (abfd, 0);	/* Context */
#endif
	  /* Alignment.  */
	  if (! ieee_write_byte (abfd, ieee_section_alignment_enum)
	      || ! ieee_write_byte (abfd,
				    (bfd_byte) (s->index
						+ IEEE_SECTION_NUMBER_BASE))
	      || ! ieee_write_int (abfd, (bfd_vma) 1 << s->alignment_power))
	    return FALSE;

	  /* Size.  */
	  if (! ieee_write_2bytes (abfd, ieee_section_size_enum)
	      || ! ieee_write_byte (abfd,
				    (bfd_byte) (s->index
						+ IEEE_SECTION_NUMBER_BASE))
	      || ! ieee_write_int (abfd, s->_raw_size))
	    return FALSE;
	  if (abfd->flags & EXEC_P)
	    {
	      /* Relocateable sections don't have asl records.  */
	      /* Vma.  */
	      if (! ieee_write_2bytes (abfd, ieee_section_base_address_enum)
		  || ! ieee_write_byte (abfd,
					((bfd_byte)
					 (s->index
					  + IEEE_SECTION_NUMBER_BASE)))
		  || ! ieee_write_int (abfd, s->lma))
		return FALSE;
	    }
	}
    }

  return TRUE;
}


static bfd_boolean
do_with_relocs (abfd, s)
     bfd *abfd;
     asection *s;
{
  unsigned int number_of_maus_in_address =
    bfd_arch_bits_per_address (abfd) / bfd_arch_bits_per_byte (abfd);
  unsigned int relocs_to_go = s->reloc_count;
  bfd_byte *stream = ieee_per_section (s)->data;
  arelent **p = s->orelocation;
  bfd_size_type current_byte_index = 0;

  qsort (s->orelocation,
	 relocs_to_go,
	 sizeof (arelent **),
	 comp);

  /* Output the section preheader.  */
  if (! ieee_write_byte (abfd, ieee_set_current_section_enum)
      || ! ieee_write_byte (abfd,
			    (bfd_byte) (s->index + IEEE_SECTION_NUMBER_BASE))
      || ! ieee_write_2bytes (abfd, ieee_set_current_pc_enum)
      || ! ieee_write_byte (abfd,
			    (bfd_byte) (s->index + IEEE_SECTION_NUMBER_BASE)))
    return FALSE;

  if ((abfd->flags & EXEC_P) != 0 && relocs_to_go == 0)
    {
      if (! ieee_write_int (abfd, s->lma))
	return FALSE;
    }
  else
    {
      if (! ieee_write_expression (abfd, (bfd_vma) 0, s->symbol, 0, 0))
	return FALSE;
    }

  if (relocs_to_go == 0)
    {
      /* If there aren't any relocations then output the load constant
	 byte opcode rather than the load with relocation opcode.  */
      while (current_byte_index < s->_raw_size)
	{
	  bfd_size_type run;
	  unsigned int MAXRUN = 127;

	  run = MAXRUN;
	  if (run > s->_raw_size - current_byte_index)
	    run = s->_raw_size - current_byte_index;

	  if (run != 0)
	    {
	      if (! ieee_write_byte (abfd, ieee_load_constant_bytes_enum))
		return FALSE;
	      /* Output a stream of bytes.  */
	      if (! ieee_write_int (abfd, run))
		return FALSE;
	      if (bfd_bwrite ((PTR) (stream + current_byte_index), run, abfd)
		  != run)
		return FALSE;
	      current_byte_index += run;
	    }
	}
    }
  else
    {
      if (! ieee_write_byte (abfd, ieee_load_with_relocation_enum))
	return FALSE;

      /* Output the data stream as the longest sequence of bytes
	 possible, allowing for the a reasonable packet size and
	 relocation stuffs.  */

      if ((PTR) stream == (PTR) NULL)
	{
	  /* Outputting a section without data, fill it up.  */
	  stream = (unsigned char *) bfd_zalloc (abfd, s->_raw_size);
	  if (!stream)
	    return FALSE;
	}
      while (current_byte_index < s->_raw_size)
	{
	  bfd_size_type run;
	  unsigned int MAXRUN = 127;

	  if (relocs_to_go)
	    {
	      run = (*p)->address - current_byte_index;
	      if (run > MAXRUN)
		run = MAXRUN;
	    }
	  else
	    run = MAXRUN;

	  if (run > s->_raw_size - current_byte_index)
	    run = s->_raw_size - current_byte_index;

	  if (run != 0)
	    {
	      /* Output a stream of bytes.  */
	      if (! ieee_write_int (abfd, run))
		return FALSE;
	      if (bfd_bwrite ((PTR) (stream + current_byte_index), run, abfd)
		  != run)
		return FALSE;
	      current_byte_index += run;
	    }

	  /* Output any relocations here.  */
	  if (relocs_to_go && (*p) && (*p)->address == current_byte_index)
	    {
	      while (relocs_to_go
		     && (*p) && (*p)->address == current_byte_index)
		{
		  arelent *r = *p;
		  bfd_signed_vma ov;
#if 0
		  if (r->howto->pc_relative)
		    r->addend += current_byte_index;
#endif
		  switch (r->howto->size)
		    {
		    case 2:

		      ov = bfd_get_signed_32 (abfd,
					      stream + current_byte_index);
		      current_byte_index += 4;
		      break;
		    case 1:
		      ov = bfd_get_signed_16 (abfd,
					      stream + current_byte_index);
		      current_byte_index += 2;
		      break;
		    case 0:
		      ov = bfd_get_signed_8 (abfd,
					     stream + current_byte_index);
		      current_byte_index++;
		      break;
		    default:
		      ov = 0;
		      BFD_FAIL ();
		      return FALSE;
		    }

		  ov &= r->howto->src_mask;

		  if (r->howto->pc_relative
		      && ! r->howto->pcrel_offset)
		    ov += r->address;

		  if (! ieee_write_byte (abfd,
					 ieee_function_either_open_b_enum))
		    return FALSE;

/*		  abort();*/

		  if (r->sym_ptr_ptr != (asymbol **) NULL)
		    {
		      if (! ieee_write_expression (abfd, r->addend + ov,
						   *(r->sym_ptr_ptr),
						   r->howto->pc_relative,
						   (unsigned) s->index))
			return FALSE;
		    }
		  else
		    {
		      if (! ieee_write_expression (abfd, r->addend + ov,
						   (asymbol *) NULL,
						   r->howto->pc_relative,
						   (unsigned) s->index))
			return FALSE;
		    }

		  if (number_of_maus_in_address
		      != bfd_get_reloc_size (r->howto))
		    {
		      bfd_vma rsize = bfd_get_reloc_size (r->howto);
		      if (! ieee_write_int (abfd, rsize))
			return FALSE;
		    }
		  if (! ieee_write_byte (abfd,
					 ieee_function_either_close_b_enum))
		    return FALSE;

		  relocs_to_go--;
		  p++;
		}

	    }
	}
    }

  return TRUE;
}

/* If there are no relocations in the output section then we can be
   clever about how we write.  We block items up into a max of 127
   bytes.  */

static bfd_boolean
do_as_repeat (abfd, s)
     bfd *abfd;
     asection *s;
{
  if (s->_raw_size)
    {
      if (! ieee_write_byte (abfd, ieee_set_current_section_enum)
	  || ! ieee_write_byte (abfd,
				(bfd_byte) (s->index
					    + IEEE_SECTION_NUMBER_BASE))
	  || ! ieee_write_byte (abfd, ieee_set_current_pc_enum >> 8)
	  || ! ieee_write_byte (abfd, ieee_set_current_pc_enum & 0xff)
	  || ! ieee_write_byte (abfd,
				(bfd_byte) (s->index
					    + IEEE_SECTION_NUMBER_BASE)))
	return FALSE;

      if ((abfd->flags & EXEC_P) != 0)
	{
	  if (! ieee_write_int (abfd, s->lma))
	    return FALSE;
	}
      else
	{
	  if (! ieee_write_expression (abfd, (bfd_vma) 0, s->symbol, 0, 0))
	    return FALSE;
	}

      if (! ieee_write_byte (abfd, ieee_repeat_data_enum)
	  || ! ieee_write_int (abfd, s->_raw_size)
	  || ! ieee_write_byte (abfd, ieee_load_constant_bytes_enum)
	  || ! ieee_write_byte (abfd, 1)
	  || ! ieee_write_byte (abfd, 0))
	return FALSE;
    }

  return TRUE;
}

static bfd_boolean
do_without_relocs (abfd, s)
     bfd *abfd;
     asection *s;
{
  bfd_byte *stream = ieee_per_section (s)->data;

  if (stream == 0 || ((s->flags & SEC_LOAD) == 0))
    {
      if (! do_as_repeat (abfd, s))
	return FALSE;
    }
  else
    {
      unsigned int i;

      for (i = 0; i < s->_raw_size; i++)
	{
	  if (stream[i] != 0)
	    {
	      if (! do_with_relocs (abfd, s))
		return FALSE;
	      return TRUE;
	    }
	}
      if (! do_as_repeat (abfd, s))
	return FALSE;
    }

  return TRUE;
}


static unsigned char *output_ptr_start;
static unsigned char *output_ptr;
static unsigned char *output_ptr_end;
static unsigned char *input_ptr_start;
static unsigned char *input_ptr;
static unsigned char *input_ptr_end;
static bfd *input_bfd;
static bfd *output_bfd;
static int output_buffer;

static bfd_boolean
ieee_mkobject (abfd)
     bfd *abfd;
{
  bfd_size_type amt;

  output_ptr_start = NULL;
  output_ptr = NULL;
  output_ptr_end = NULL;
  input_ptr_start = NULL;
  input_ptr = NULL;
  input_ptr_end = NULL;
  input_bfd = NULL;
  output_bfd = NULL;
  output_buffer = 0;
  amt = sizeof (ieee_data_type);
  abfd->tdata.ieee_data = (ieee_data_type *) bfd_zalloc (abfd, amt);
  return abfd->tdata.ieee_data != NULL;
}

static void
fill ()
{
  bfd_size_type amt = input_ptr_end - input_ptr_start;
  /* FIXME: Check return value.  I'm not sure whether it needs to read
     the entire buffer or not.  */
  bfd_bread ((PTR) input_ptr_start, amt, input_bfd);
  input_ptr = input_ptr_start;
}

static void
flush ()
{
  bfd_size_type amt = output_ptr - output_ptr_start;

  if (bfd_bwrite ((PTR) (output_ptr_start), amt, output_bfd) != amt)
    abort ();
  output_ptr = output_ptr_start;
  output_buffer++;
}

#define THIS() ( *input_ptr )
#define NEXT() { input_ptr++; if (input_ptr == input_ptr_end) fill(); }
#define OUT(x) { *output_ptr++ = (x); if(output_ptr == output_ptr_end)  flush(); }

static void
write_int (value)
     int value;
{
  if (value >= 0 && value <= 127)
    {
      OUT (value);
    }
  else
    {
      unsigned int length;
      /* How many significant bytes ?  */
      /* FIXME FOR LONGER INTS.  */
      if (value & 0xff000000)
	length = 4;
      else if (value & 0x00ff0000)
	length = 3;
      else if (value & 0x0000ff00)
	length = 2;
      else
	length = 1;

      OUT ((int) ieee_number_repeat_start_enum + length);
      switch (length)
	{
	case 4:
	  OUT (value >> 24);
	case 3:
	  OUT (value >> 16);
	case 2:
	  OUT (value >> 8);
	case 1:
	  OUT (value);
	}
    }
}

static void
copy_id ()
{
  int length = THIS ();
  char ch;

  OUT (length);
  NEXT ();
  while (length--)
    {
      ch = THIS ();
      OUT (ch);
      NEXT ();
    }
}

#define VAR(x) ((x | 0x80))
static void
copy_expression ()
{
  int stack[10];
  int *tos = stack;
  int value;

  while (1)
    {
      switch (THIS ())
	{
	case 0x84:
	  NEXT ();
	  value = THIS ();
	  NEXT ();
	  value = (value << 8) | THIS ();
	  NEXT ();
	  value = (value << 8) | THIS ();
	  NEXT ();
	  value = (value << 8) | THIS ();
	  NEXT ();
	  *tos++ = value;
	  break;
	case 0x83:
	  NEXT ();
	  value = THIS ();
	  NEXT ();
	  value = (value << 8) | THIS ();
	  NEXT ();
	  value = (value << 8) | THIS ();
	  NEXT ();
	  *tos++ = value;
	  break;
	case 0x82:
	  NEXT ();
	  value = THIS ();
	  NEXT ();
	  value = (value << 8) | THIS ();
	  NEXT ();
	  *tos++ = value;
	  break;
	case 0x81:
	  NEXT ();
	  value = THIS ();
	  NEXT ();
	  *tos++ = value;
	  break;
	case 0x80:
	  NEXT ();
	  *tos++ = 0;
	  break;
	default:
	  if (THIS () > 0x84)
	    {
	      /* Not a number, just bug out with the answer.  */
	      write_int (*(--tos));
	      return;
	    }
	  *tos++ = THIS ();
	  NEXT ();
	  break;
	case 0xa5:
	  /* PLUS anything.  */
	  value = *(--tos);
	  value += *(--tos);
	  *tos++ = value;
	  NEXT ();
	  break;
	case VAR ('R'):
	  {
	    int section_number;
	    ieee_data_type *ieee;
	    asection *s;

	    NEXT ();
	    section_number = THIS ();

	    NEXT ();
	    ieee = IEEE_DATA (input_bfd);
	    s = ieee->section_table[section_number];
	    value = 0;
	    if (s->output_section)
	      value = s->output_section->lma;
	    value += s->output_offset;
	    *tos++ = value;
	  }
	  break;
	case 0x90:
	  {
	    NEXT ();
	    write_int (*(--tos));
	    OUT (0x90);
	    return;
	  }
	}
    }
}

/* Drop the int in the buffer, and copy a null into the gap, which we
   will overwrite later */

static void
fill_int (buf)
     struct output_buffer_struct *buf;
{
  if (buf->buffer == output_buffer)
    {
      /* Still a chance to output the size.  */
      int value = output_ptr - buf->ptrp + 3;
      buf->ptrp[0] = value >> 24;
      buf->ptrp[1] = value >> 16;
      buf->ptrp[2] = value >> 8;
      buf->ptrp[3] = value >> 0;
    }
}

static void
drop_int (buf)
     struct output_buffer_struct *buf;
{
  int type = THIS ();
  int ch;

  if (type <= 0x84)
    {
      NEXT ();
      switch (type)
	{
	case 0x84:
	  ch = THIS ();
	  NEXT ();
	case 0x83:
	  ch = THIS ();
	  NEXT ();
	case 0x82:
	  ch = THIS ();
	  NEXT ();
	case 0x81:
	  ch = THIS ();
	  NEXT ();
	case 0x80:
	  break;
	}
    }
  OUT (0x84);
  buf->ptrp = output_ptr;
  buf->buffer = output_buffer;
  OUT (0);
  OUT (0);
  OUT (0);
  OUT (0);
}

static void
copy_int ()
{
  int type = THIS ();
  int ch;
  if (type <= 0x84)
    {
      OUT (type);
      NEXT ();
      switch (type)
	{
	case 0x84:
	  ch = THIS ();
	  NEXT ();
	  OUT (ch);
	case 0x83:
	  ch = THIS ();
	  NEXT ();
	  OUT (ch);
	case 0x82:
	  ch = THIS ();
	  NEXT ();
	  OUT (ch);
	case 0x81:
	  ch = THIS ();
	  NEXT ();
	  OUT (ch);
	case 0x80:
	  break;
	}
    }
}

#define ID copy_id()
#define INT copy_int()
#define EXP copy_expression()
#define INTn(q) copy_int()
#define EXPn(q) copy_expression()

static void
f1_record ()
{
  int ch;

  /* ATN record.  */
  NEXT ();
  ch = THIS ();
  switch (ch)
    {
    default:
      OUT (0xf1);
      OUT (ch);
      break;
    case 0xc9:
      NEXT ();
      OUT (0xf1);
      OUT (0xc9);
      INT;
      INT;
      ch = THIS ();
      switch (ch)
	{
	case 0x16:
	  NEXT ();
	  break;
	case 0x01:
	  NEXT ();
	  break;
	case 0x00:
	  NEXT ();
	  INT;
	  break;
	case 0x03:
	  NEXT ();
	  INT;
	  break;
	case 0x13:
	  EXPn (instruction address);
	  break;
	default:
	  break;
	}
      break;
    case 0xd8:
      /* EXternal ref.  */
      NEXT ();
      OUT (0xf1);
      OUT (0xd8);
      EXP;
      EXP;
      EXP;
      EXP;
      break;
    case 0xce:
      NEXT ();
      OUT (0xf1);
      OUT (0xce);
      INT;
      INT;
      ch = THIS ();
      INT;
      switch (ch)
	{
	case 0x01:
	  INT;
	  INT;
	  break;
	case 0x02:
	  INT;
	  break;
	case 0x04:
	  EXPn (external function);
	  break;
	case 0x05:
	  break;
	case 0x07:
	  INTn (line number);
	  INT;
	case 0x08:
	  break;
	case 0x0a:
	  INTn (locked register);
	  INT;
	  break;
	case 0x3f:
	  copy_till_end ();
	  break;
	case 0x3e:
	  copy_till_end ();
	  break;
	case 0x40:
	  copy_till_end ();
	  break;
	case 0x41:
	  ID;
	  break;
	}
    }
}

static void
f0_record ()
{
  /* Attribute record.  */
  NEXT ();
  OUT (0xf0);
  INTn (Symbol name);
  ID;
}

static void
copy_till_end ()
{
  int ch = THIS ();

  while (1)
    {
      while (ch <= 0x80)
	{
	  OUT (ch);
	  NEXT ();
	  ch = THIS ();
	}
      switch (ch)
	{
	case 0x84:
	  OUT (THIS ());
	  NEXT ();
	case 0x83:
	  OUT (THIS ());
	  NEXT ();
	case 0x82:
	  OUT (THIS ());
	  NEXT ();
	case 0x81:
	  OUT (THIS ());
	  NEXT ();
	  OUT (THIS ());
	  NEXT ();

	  ch = THIS ();
	  break;
	default:
	  return;
	}
    }

}

static void
f2_record ()
{
  NEXT ();
  OUT (0xf2);
  INT;
  NEXT ();
  OUT (0xce);
  INT;
  copy_till_end ();
}


static void
f8_record ()
{
  int ch;
  NEXT ();
  ch = THIS ();
  switch (ch)
    {
    case 0x01:
    case 0x02:
    case 0x03:
      /* Unique typedefs for module.  */
      /* GLobal typedefs.   */
      /* High level module scope beginning.  */
      {
	struct output_buffer_struct ob;

	NEXT ();
	OUT (0xf8);
	OUT (ch);
	drop_int (&ob);
	ID;

	block ();

	NEXT ();
	fill_int (&ob);
	OUT (0xf9);
      }
      break;
    case 0x04:
      /* Global function.  */
      {
	struct output_buffer_struct ob;

	NEXT ();
	OUT (0xf8);
	OUT (0x04);
	drop_int (&ob);
	ID;
	INTn (stack size);
	INTn (ret val);
	EXPn (offset);

	block ();

	NEXT ();
	OUT (0xf9);
	EXPn (size of block);
	fill_int (&ob);
      }
      break;

    case 0x05:
      /* File name for source line numbers.  */
      {
	struct output_buffer_struct ob;

	NEXT ();
	OUT (0xf8);
	OUT (0x05);
	drop_int (&ob);
	ID;
	INTn (year);
	INTn (month);
	INTn (day);
	INTn (hour);
	INTn (monute);
	INTn (second);
	block ();
	NEXT ();
	OUT (0xf9);
	fill_int (&ob);
      }
      break;

    case 0x06:
      /* Local function.  */
      {
	struct output_buffer_struct ob;

	NEXT ();
	OUT (0xf8);
	OUT (0x06);
	drop_int (&ob);
	ID;
	INTn (stack size);
	INTn (type return);
	EXPn (offset);
	block ();
	NEXT ();
	OUT (0xf9);
	EXPn (size);
	fill_int (&ob);
      }
      break;

    case 0x0a:
      /* Assembler module scope beginning -  */
      {
	struct output_buffer_struct ob;

	NEXT ();
	OUT (0xf8);
	OUT (0x0a);
	drop_int (&ob);
	ID;
	ID;
	INT;
	ID;
	INT;
	INT;
	INT;
	INT;
	INT;
	INT;

	block ();

	NEXT ();
	OUT (0xf9);
	fill_int (&ob);
      }
      break;
    case 0x0b:
      {
	struct output_buffer_struct ob;

	NEXT ();
	OUT (0xf8);
	OUT (0x0b);
	drop_int (&ob);
	ID;
	INT;
	INTn (section index);
	EXPn (offset);
	INTn (stuff);

	block ();

	OUT (0xf9);
	NEXT ();
	EXPn (Size in Maus);
	fill_int (&ob);
      }
      break;
    }
}

static void
e2_record ()
{
  OUT (0xe2);
  NEXT ();
  OUT (0xce);
  NEXT ();
  INT;
  EXP;
}

static void
block ()
{
  int ch;

  while (1)
    {
      ch = THIS ();
      switch (ch)
	{
	case 0xe1:
	case 0xe5:
	  return;
	case 0xf9:
	  return;
	case 0xf0:
	  f0_record ();
	  break;
	case 0xf1:
	  f1_record ();
	  break;
	case 0xf2:
	  f2_record ();
	  break;
	case 0xf8:
	  f8_record ();
	  break;
	case 0xe2:
	  e2_record ();
	  break;

	}
    }
}


/* Moves all the debug information from the source bfd to the output
   bfd, and relocates any expressions it finds.  */

static void
relocate_debug (output, input)
     bfd *output ATTRIBUTE_UNUSED;
     bfd *input;
{
#define IBS 400
#define OBS 400
  unsigned char input_buffer[IBS];

  input_ptr_start = input_ptr = input_buffer;
  input_ptr_end = input_buffer + IBS;
  input_bfd = input;
  /* FIXME: Check return value.  I'm not sure whether it needs to read
     the entire buffer or not.  */
  bfd_bread ((PTR) input_ptr_start, (bfd_size_type) IBS, input);
  block ();
}

/* Gather together all the debug information from each input BFD into
   one place, relocating it and emitting it as we go.  */

static bfd_boolean
ieee_write_debug_part (abfd)
     bfd *abfd;
{
  ieee_data_type *ieee = IEEE_DATA (abfd);
  bfd_chain_type *chain = ieee->chain_root;
  unsigned char obuff[OBS];
  bfd_boolean some_debug = FALSE;
  file_ptr here = bfd_tell (abfd);

  output_ptr_start = output_ptr = obuff;
  output_ptr_end = obuff + OBS;
  output_ptr = obuff;
  output_bfd = abfd;

  if (chain == (bfd_chain_type *) NULL)
    {
      asection *s;

      for (s = abfd->sections; s != NULL; s = s->next)
	if ((s->flags & SEC_DEBUGGING) != 0)
	  break;
      if (s == NULL)
	{
	  ieee->w.r.debug_information_part = 0;
	  return TRUE;
	}

      ieee->w.r.debug_information_part = here;
      if (bfd_bwrite (s->contents, s->_raw_size, abfd) != s->_raw_size)
	return FALSE;
    }
  else
    {
      while (chain != (bfd_chain_type *) NULL)
	{
	  bfd *entry = chain->this;
	  ieee_data_type *entry_ieee = IEEE_DATA (entry);

	  if (entry_ieee->w.r.debug_information_part)
	    {
	      if (bfd_seek (entry, entry_ieee->w.r.debug_information_part,
			    SEEK_SET) != 0)
		return FALSE;
	      relocate_debug (abfd, entry);
	    }

	  chain = chain->next;
	}

      if (some_debug)
	ieee->w.r.debug_information_part = here;
      else
	ieee->w.r.debug_information_part = 0;

      flush ();
    }

  return TRUE;
}

/* Write the data in an ieee way.  */

static bfd_boolean
ieee_write_data_part (abfd)
     bfd *abfd;
{
  asection *s;

  ieee_data_type *ieee = IEEE_DATA (abfd);
  ieee->w.r.data_part = bfd_tell (abfd);

  for (s = abfd->sections; s != (asection *) NULL; s = s->next)
    {
      /* Skip sections that have no loadable contents (.bss,
         debugging, etc.)  */
      if ((s->flags & SEC_LOAD) == 0)
	continue;

      /* Sort the reloc records so we can insert them in the correct
	 places */
      if (s->reloc_count != 0)
	{
	  if (! do_with_relocs (abfd, s))
	    return FALSE;
	}
      else
	{
	  if (! do_without_relocs (abfd, s))
	    return FALSE;
	}
    }

  return TRUE;
}


static bfd_boolean
init_for_output (abfd)
     bfd *abfd;
{
  asection *s;

  for (s = abfd->sections; s != (asection *) NULL; s = s->next)
    {
      if ((s->flags & SEC_DEBUGGING) != 0)
	continue;
      if (s->_raw_size != 0)
	{
	  bfd_size_type size = s->_raw_size;
	  ieee_per_section (s)->data = (bfd_byte *) (bfd_alloc (abfd, size));
	  if (!ieee_per_section (s)->data)
	    return FALSE;
	}
    }
  return TRUE;
}

/* Exec and core file sections.  */

/* Set section contents is complicated with IEEE since the format is
   not a byte image, but a record stream.  */

static bfd_boolean
ieee_set_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     const PTR location;
     file_ptr offset;
     bfd_size_type count;
{
  if ((section->flags & SEC_DEBUGGING) != 0)
    {
      if (section->contents == NULL)
	{
	  bfd_size_type size = section->_raw_size;
	  section->contents = (unsigned char *) bfd_alloc (abfd, size);
	  if (section->contents == NULL)
	    return FALSE;
	}
      /* bfd_set_section_contents has already checked that everything
         is within range.  */
      memcpy (section->contents + offset, location, (size_t) count);
      return TRUE;
    }

  if (ieee_per_section (section)->data == (bfd_byte *) NULL)
    {
      if (!init_for_output (abfd))
	return FALSE;
    }
  memcpy ((PTR) (ieee_per_section (section)->data + offset),
	  (PTR) location,
	  (unsigned int) count);
  return TRUE;
}

/* Write the external symbols of a file.  IEEE considers two sorts of
   external symbols, public, and referenced.  It uses to internal
   forms to index them as well.  When we write them out we turn their
   symbol values into indexes from the right base.  */

static bfd_boolean
ieee_write_external_part (abfd)
     bfd *abfd;
{
  asymbol **q;
  ieee_data_type *ieee = IEEE_DATA (abfd);
  unsigned int reference_index = IEEE_REFERENCE_BASE;
  unsigned int public_index = IEEE_PUBLIC_BASE + 2;
  file_ptr here = bfd_tell (abfd);
  bfd_boolean hadone = FALSE;

  if (abfd->outsymbols != (asymbol **) NULL)
    {

      for (q = abfd->outsymbols; *q != (asymbol *) NULL; q++)
	{
	  asymbol *p = *q;

	  if (bfd_is_und_section (p->section))
	    {
	      /* This must be a symbol reference.  */
	      if (! ieee_write_byte (abfd, ieee_external_reference_enum)
		  || ! ieee_write_int (abfd, (bfd_vma) reference_index)
		  || ! ieee_write_id (abfd, p->name))
		return FALSE;
	      p->value = reference_index;
	      reference_index++;
	      hadone = TRUE;
	    }
	  else if (bfd_is_com_section (p->section))
	    {
	      /* This is a weak reference.  */
	      if (! ieee_write_byte (abfd, ieee_external_reference_enum)
		  || ! ieee_write_int (abfd, (bfd_vma) reference_index)
		  || ! ieee_write_id (abfd, p->name)
		  || ! ieee_write_byte (abfd,
					ieee_weak_external_reference_enum)
		  || ! ieee_write_int (abfd, (bfd_vma) reference_index)
		  || ! ieee_write_int (abfd, p->value))
		return FALSE;
	      p->value = reference_index;
	      reference_index++;
	      hadone = TRUE;
	    }
	  else if (p->flags & BSF_GLOBAL)
	    {
	      /* This must be a symbol definition.  */
	      if (! ieee_write_byte (abfd, ieee_external_symbol_enum)
		  || ! ieee_write_int (abfd, (bfd_vma) public_index)
		  || ! ieee_write_id (abfd, p->name)
		  || ! ieee_write_2bytes (abfd, ieee_attribute_record_enum)
		  || ! ieee_write_int (abfd, (bfd_vma) public_index)
		  || ! ieee_write_byte (abfd, 15) /* instruction address */
		  || ! ieee_write_byte (abfd, 19) /* static symbol */
		  || ! ieee_write_byte (abfd, 1)) /* one of them */
		return FALSE;

	      /* Write out the value.  */
	      if (! ieee_write_2bytes (abfd, ieee_value_record_enum)
		  || ! ieee_write_int (abfd, (bfd_vma) public_index))
		return FALSE;
	      if (! bfd_is_abs_section (p->section))
		{
		  if (abfd->flags & EXEC_P)
		    {
		      /* If fully linked, then output all symbols
			 relocated.  */
		      if (! (ieee_write_int
			     (abfd,
			      (p->value
			       + p->section->output_offset
			       + p->section->output_section->vma))))
			return FALSE;
		    }
		  else
		    {
		      if (! (ieee_write_expression
			     (abfd,
			      p->value + p->section->output_offset,
			      p->section->output_section->symbol,
			      FALSE, 0)))
			return FALSE;
		    }
		}
	      else
		{
		  if (! ieee_write_expression (abfd,
					       p->value,
					       bfd_abs_section_ptr->symbol,
					       FALSE, 0))
		    return FALSE;
		}
	      p->value = public_index;
	      public_index++;
	      hadone = TRUE;
	    }
	  else
	    {
	      /* This can happen - when there are gaps in the symbols read
	         from an input ieee file.  */
	    }
	}
    }
  if (hadone)
    ieee->w.r.external_part = here;

  return TRUE;
}


static const unsigned char exten[] =
{
  0xf0, 0x20, 0x00,
  0xf1, 0xce, 0x20, 0x00, 37, 3, 3,	/* Set version 3 rev 3.  */
  0xf1, 0xce, 0x20, 0x00, 39, 2,	/* Keep symbol in  original case.  */
  0xf1, 0xce, 0x20, 0x00, 38		/* Set object type relocatable to x.  */
};

static const unsigned char envi[] =
{
  0xf0, 0x21, 0x00,

/*    0xf1, 0xce, 0x21, 00, 50, 0x82, 0x07, 0xc7, 0x09, 0x11, 0x11,
    0x19, 0x2c,
*/
  0xf1, 0xce, 0x21, 00, 52, 0x00,	/* exec ok */

  0xf1, 0xce, 0x21, 0, 53, 0x03,/* host unix */
/*    0xf1, 0xce, 0x21, 0, 54, 2,1,1	tool & version # */
};

static bfd_boolean
ieee_write_me_part (abfd)
     bfd *abfd;
{
  ieee_data_type *ieee = IEEE_DATA (abfd);
  ieee->w.r.trailer_part = bfd_tell (abfd);
  if (abfd->start_address)
    {
      if (! ieee_write_2bytes (abfd, ieee_value_starting_address_enum)
	  || ! ieee_write_byte (abfd, ieee_function_either_open_b_enum)
	  || ! ieee_write_int (abfd, abfd->start_address)
	  || ! ieee_write_byte (abfd, ieee_function_either_close_b_enum))
	return FALSE;
    }
  ieee->w.r.me_record = bfd_tell (abfd);
  if (! ieee_write_byte (abfd, ieee_module_end_enum))
    return FALSE;
  return TRUE;
}

/* Write out the IEEE processor ID.  */

static bfd_boolean
ieee_write_processor (abfd)
     bfd *abfd;
{
  const bfd_arch_info_type *arch;

  arch = bfd_get_arch_info (abfd);
  switch (arch->arch)
    {
    default:
      if (! ieee_write_id (abfd, bfd_printable_name (abfd)))
	return FALSE;
      break;

    case bfd_arch_a29k:
      if (! ieee_write_id (abfd, "29000"))
	return FALSE;
      break;

    case bfd_arch_h8300:
      if (! ieee_write_id (abfd, "H8/300"))
	return FALSE;
      break;

    case bfd_arch_h8500:
      if (! ieee_write_id (abfd, "H8/500"))
	return FALSE;
      break;

    case bfd_arch_i960:
      switch (arch->mach)
	{
	default:
	case bfd_mach_i960_core:
	case bfd_mach_i960_ka_sa:
	  if (! ieee_write_id (abfd, "80960KA"))
	    return FALSE;
	  break;

	case bfd_mach_i960_kb_sb:
	  if (! ieee_write_id (abfd, "80960KB"))
	    return FALSE;
	  break;

	case bfd_mach_i960_ca:
	  if (! ieee_write_id (abfd, "80960CA"))
	    return FALSE;
	  break;

	case bfd_mach_i960_mc:
	case bfd_mach_i960_xa:
	  if (! ieee_write_id (abfd, "80960MC"))
	    return FALSE;
	  break;
	}
      break;

    case bfd_arch_m68k:
      {
	const char *id;

	switch (arch->mach)
	  {
	  default:		id = "68020"; break;
	  case bfd_mach_m68000: id = "68000"; break;
	  case bfd_mach_m68008: id = "68008"; break;
	  case bfd_mach_m68010: id = "68010"; break;
	  case bfd_mach_m68020: id = "68020"; break;
	  case bfd_mach_m68030: id = "68030"; break;
	  case bfd_mach_m68040: id = "68040"; break;
	  case bfd_mach_m68060: id = "68060"; break;
	  case bfd_mach_cpu32:  id = "cpu32"; break;
	  case bfd_mach_mcf5200:id = "5200";  break;
	  case bfd_mach_mcf5206e:id = "5206e"; break;
	  case bfd_mach_mcf5307:id = "5307";  break;
	  case bfd_mach_mcf5407:id = "5407";  break;
	  case bfd_mach_mcf528x:id = "5282";  break;
	  }

	if (! ieee_write_id (abfd, id))
	  return FALSE;
      }
      break;
    }

  return TRUE;
}

static bfd_boolean
ieee_write_object_contents (abfd)
     bfd *abfd;
{
  ieee_data_type *ieee = IEEE_DATA (abfd);
  unsigned int i;
  file_ptr old;

  /* Fast forward over the header area.  */
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    return FALSE;

  if (! ieee_write_byte (abfd, ieee_module_beginning_enum)
      || ! ieee_write_processor (abfd)
      || ! ieee_write_id (abfd, abfd->filename))
    return FALSE;

  /* Fast forward over the variable bits.  */
  if (! ieee_write_byte (abfd, ieee_address_descriptor_enum))
    return FALSE;

  /* Bits per MAU.  */
  if (! ieee_write_byte (abfd, (bfd_byte) (bfd_arch_bits_per_byte (abfd))))
    return FALSE;
  /* MAU's per address.  */
  if (! ieee_write_byte (abfd,
			 (bfd_byte) (bfd_arch_bits_per_address (abfd)
				     / bfd_arch_bits_per_byte (abfd))))
    return FALSE;

  old = bfd_tell (abfd);
  if (bfd_seek (abfd, (file_ptr) (8 * N_W_VARIABLES), SEEK_CUR) != 0)
    return FALSE;

  ieee->w.r.extension_record = bfd_tell (abfd);
  if (bfd_bwrite ((char *) exten, (bfd_size_type) sizeof (exten), abfd)
      != sizeof (exten))
    return FALSE;
  if (abfd->flags & EXEC_P)
    {
      if (! ieee_write_byte (abfd, 0x1)) /* Absolute */
	return FALSE;
    }
  else
    {
      if (! ieee_write_byte (abfd, 0x2)) /* Relocateable */
	return FALSE;
    }

  ieee->w.r.environmental_record = bfd_tell (abfd);
  if (bfd_bwrite ((char *) envi, (bfd_size_type) sizeof (envi), abfd)
      != sizeof (envi))
    return FALSE;

  /* The HP emulator database requires a timestamp in the file.  */
  {
    time_t now;
    const struct tm *t;

    time (&now);
    t = (struct tm *) localtime (&now);
    if (! ieee_write_2bytes (abfd, (int) ieee_atn_record_enum)
	|| ! ieee_write_byte (abfd, 0x21)
	|| ! ieee_write_byte (abfd, 0)
	|| ! ieee_write_byte (abfd, 50)
	|| ! ieee_write_int (abfd, (bfd_vma) (t->tm_year + 1900))
	|| ! ieee_write_int (abfd, (bfd_vma) (t->tm_mon + 1))
	|| ! ieee_write_int (abfd, (bfd_vma) t->tm_mday)
	|| ! ieee_write_int (abfd, (bfd_vma) t->tm_hour)
	|| ! ieee_write_int (abfd, (bfd_vma) t->tm_min)
	|| ! ieee_write_int (abfd, (bfd_vma) t->tm_sec))
      return FALSE;
  }

  output_bfd = abfd;

  flush ();

  if (! ieee_write_section_part (abfd))
    return FALSE;
  /* First write the symbols.  This changes their values into table
    indeces so we cant use it after this point.  */
  if (! ieee_write_external_part (abfd))
    return FALSE;

  /* Write any debugs we have been told about.  */
  if (! ieee_write_debug_part (abfd))
    return FALSE;

  /* Can only write the data once the symbols have been written, since
     the data contains relocation information which points to the
     symbols.  */
  if (! ieee_write_data_part (abfd))
    return FALSE;

  /* At the end we put the end!  */
  if (! ieee_write_me_part (abfd))
    return FALSE;

  /* Generate the header.  */
  if (bfd_seek (abfd, old, SEEK_SET) != 0)
    return FALSE;

  for (i = 0; i < N_W_VARIABLES; i++)
    {
      if (! ieee_write_2bytes (abfd, ieee_assign_value_to_variable_enum)
	  || ! ieee_write_byte (abfd, (bfd_byte) i)
	  || ! ieee_write_int5_out (abfd, (bfd_vma) ieee->w.offset[i]))
	return FALSE;
    }

  return TRUE;
}

/* Native-level interface to symbols. */

/* We read the symbols into a buffer, which is discarded when this
   function exits.  We read the strings into a buffer large enough to
   hold them all plus all the cached symbol entries.  */

static asymbol *
ieee_make_empty_symbol (abfd)
     bfd *abfd;
{
  bfd_size_type amt = sizeof (ieee_symbol_type);
  ieee_symbol_type *new = (ieee_symbol_type *) bfd_zalloc (abfd, amt);

  if (!new)
    return NULL;
  new->symbol.the_bfd = abfd;
  return &new->symbol;
}

static bfd *
ieee_openr_next_archived_file (arch, prev)
     bfd *arch;
     bfd *prev;
{
  ieee_ar_data_type *ar = IEEE_AR_DATA (arch);

  /* Take the next one from the arch state, or reset.  */
  if (prev == (bfd *) NULL)
    /* Reset the index - the first two entries are bogus.  */
    ar->element_index = 2;

  while (TRUE)
    {
      ieee_ar_obstack_type *p = ar->elements + ar->element_index;

      ar->element_index++;
      if (ar->element_index <= ar->element_count)
	{
	  if (p->file_offset != (file_ptr) 0)
	    {
	      if (p->abfd == (bfd *) NULL)
		{
		  p->abfd = _bfd_create_empty_archive_element_shell (arch);
		  p->abfd->origin = p->file_offset;
		}
	      return p->abfd;
	    }
	}
      else
	{
	  bfd_set_error (bfd_error_no_more_archived_files);
	  return (bfd *) NULL;
	}
    }
}

static bfd_boolean
ieee_find_nearest_line (abfd, section, symbols, offset, filename_ptr,
			functionname_ptr, line_ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
     asymbol **symbols ATTRIBUTE_UNUSED;
     bfd_vma offset ATTRIBUTE_UNUSED;
     const char **filename_ptr ATTRIBUTE_UNUSED;
     const char **functionname_ptr ATTRIBUTE_UNUSED;
     unsigned int *line_ptr ATTRIBUTE_UNUSED;
{
  return FALSE;
}

static int
ieee_generic_stat_arch_elt (abfd, buf)
     bfd *abfd;
     struct stat *buf;
{
  ieee_ar_data_type *ar = (ieee_ar_data_type *) NULL;
  ieee_data_type *ieee;

  if (abfd->my_archive != NULL)
    ar = abfd->my_archive->tdata.ieee_ar_data;
  if (ar == (ieee_ar_data_type *) NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  if (IEEE_DATA (abfd) == NULL)
    {
      if (ieee_object_p (abfd) == NULL)
	{
	  bfd_set_error (bfd_error_wrong_format);
	  return -1;
	}
    }

  ieee = IEEE_DATA (abfd);

  buf->st_size = ieee->w.r.me_record + 1;
  buf->st_mode = 0644;
  return 0;
}

static int
ieee_sizeof_headers (abfd, x)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_boolean x ATTRIBUTE_UNUSED;
{
  return 0;
}


/* The debug info routines are never used.  */
#if 0

static void
ieee_bfd_debug_info_start (abfd)
     bfd *abfd;
{

}

static void
ieee_bfd_debug_info_end (abfd)
     bfd *abfd;
{

}


/* Add this section to the list of sections we have debug info for, to
   be ready to output it at close time.  */
static void
ieee_bfd_debug_info_accumulate (abfd, section)
     bfd *abfd;
     asection *section;
{
  ieee_data_type *ieee = IEEE_DATA (section->owner);
  ieee_data_type *output_ieee = IEEE_DATA (abfd);

  /* Can only accumulate data from other ieee bfds.  */
  if (section->owner->xvec != abfd->xvec)
    return;
  /* Only bother once per bfd.  */
  if (ieee->done_debug)
    return;
  ieee->done_debug = TRUE;

  /* Don't bother if there is no debug info.  */
  if (ieee->w.r.debug_information_part == 0)
    return;

  /* Add to chain.  */
  {
    bfd_size_type amt = sizeof (bfd_chain_type);
    bfd_chain_type *n = (bfd_chain_type *) bfd_alloc (abfd, amt);

    if (!n)
      abort ();		/* FIXME */
    n->this = section->owner;
    n->next = (bfd_chain_type *) NULL;

    if (output_ieee->chain_head)
      output_ieee->chain_head->next = n;
    else
      output_ieee->chain_root = n;

    output_ieee->chain_head = n;
  }
}

#endif

#define	ieee_close_and_cleanup _bfd_generic_close_and_cleanup
#define ieee_bfd_free_cached_info _bfd_generic_bfd_free_cached_info

#define ieee_slurp_armap bfd_true
#define ieee_slurp_extended_name_table bfd_true
#define ieee_construct_extended_name_table \
  ((bfd_boolean (*) \
    PARAMS ((bfd *, char **, bfd_size_type *, const char **))) \
   bfd_true)
#define ieee_truncate_arname bfd_dont_truncate_arname
#define ieee_write_armap \
  ((bfd_boolean (*) \
    PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int))) \
   bfd_true)
#define ieee_read_ar_hdr bfd_nullvoidptr
#define ieee_update_armap_timestamp bfd_true
#define ieee_get_elt_at_index _bfd_generic_get_elt_at_index

#define ieee_bfd_is_local_label_name bfd_generic_is_local_label_name
#define ieee_get_lineno _bfd_nosymbols_get_lineno
#define ieee_bfd_make_debug_symbol _bfd_nosymbols_bfd_make_debug_symbol
#define ieee_read_minisymbols _bfd_generic_read_minisymbols
#define ieee_minisymbol_to_symbol _bfd_generic_minisymbol_to_symbol

#define ieee_bfd_reloc_type_lookup _bfd_norelocs_bfd_reloc_type_lookup

#define ieee_set_arch_mach _bfd_generic_set_arch_mach

#define ieee_get_section_contents_in_window \
  _bfd_generic_get_section_contents_in_window
#define ieee_bfd_get_relocated_section_contents \
  bfd_generic_get_relocated_section_contents
#define ieee_bfd_relax_section bfd_generic_relax_section
#define ieee_bfd_gc_sections bfd_generic_gc_sections
#define ieee_bfd_merge_sections bfd_generic_merge_sections
#define ieee_bfd_discard_group bfd_generic_discard_group
#define ieee_bfd_link_hash_table_create _bfd_generic_link_hash_table_create
#define ieee_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
#define ieee_bfd_link_add_symbols _bfd_generic_link_add_symbols
#define ieee_bfd_link_just_syms _bfd_generic_link_just_syms
#define ieee_bfd_final_link _bfd_generic_final_link
#define ieee_bfd_link_split_section  _bfd_generic_link_split_section

const bfd_target ieee_vec =
{
  "ieee",			/* name */
  bfd_target_ieee_flavour,
  BFD_ENDIAN_UNKNOWN,		/* target byte order */
  BFD_ENDIAN_UNKNOWN,		/* target headers byte order */
  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
  (SEC_CODE | SEC_DATA | SEC_ROM | SEC_HAS_CONTENTS
   | SEC_ALLOC | SEC_LOAD | SEC_RELOC),	/* section flags */
  '_',				/* leading underscore */
  ' ',				/* ar_pad_char */
  16,				/* ar_max_namelen */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */

  {_bfd_dummy_target,
   ieee_object_p,		/* bfd_check_format */
   ieee_archive_p,
   _bfd_dummy_target,
  },
  {
    bfd_false,
    ieee_mkobject,
    _bfd_generic_mkarchive,
    bfd_false
  },
  {
    bfd_false,
    ieee_write_object_contents,
    _bfd_write_archive_contents,
    bfd_false,
  },

  /* ieee_close_and_cleanup, ieee_bfd_free_cached_info, ieee_new_section_hook,
     ieee_get_section_contents, ieee_get_section_contents_in_window  */
  BFD_JUMP_TABLE_GENERIC (ieee),

  BFD_JUMP_TABLE_COPY (_bfd_generic),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),

  /* ieee_slurp_armap, ieee_slurp_extended_name_table,
     ieee_construct_extended_name_table, ieee_truncate_arname,
     ieee_write_armap, ieee_read_ar_hdr, ieee_openr_next_archived_file,
     ieee_get_elt_at_index, ieee_generic_stat_arch_elt,
     ieee_update_armap_timestamp  */
  BFD_JUMP_TABLE_ARCHIVE (ieee),

  /* ieee_get_symtab_upper_bound, ieee_canonicalize_symtab,
     ieee_make_empty_symbol, ieee_print_symbol, ieee_get_symbol_info,
     ieee_bfd_is_local_label_name, ieee_get_lineno,
     ieee_find_nearest_line, ieee_bfd_make_debug_symbol,
     ieee_read_minisymbols, ieee_minisymbol_to_symbol */
  BFD_JUMP_TABLE_SYMBOLS (ieee),

  /* ieee_get_reloc_upper_bound, ieee_canonicalize_reloc,
     ieee_bfd_reloc_type_lookup  */
  BFD_JUMP_TABLE_RELOCS (ieee),

  /* ieee_set_arch_mach, ieee_set_section_contents  */
  BFD_JUMP_TABLE_WRITE (ieee),

  /* ieee_sizeof_headers, ieee_bfd_get_relocated_section_contents,
     ieee_bfd_relax_section, ieee_bfd_link_hash_table_create,
     _bfd_generic_link_hash_table_free,
     ieee_bfd_link_add_symbols, ieee_bfd_final_link,
     ieee_bfd_link_split_section, ieee_bfd_gc_sections,
     ieee_bfd_merge_sections  */
  BFD_JUMP_TABLE_LINK (ieee),

  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  NULL,

  (PTR) 0
};
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d83 1
a83 1
static long ieee_get_symtab
d163 1
a163 1
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
d1046 1
a1046 1
	    /* Fetch the defautlt value if available.  */
d1148 1
a1148 1
ieee_get_symtab (abfd, location)
d1642 1
a1642 1
    /* IEEE does not specify the format of the processor identificaton
d3443 1
a3443 1
     PTR location;
d3593 1
a3593 1
  0xf1, 0xce, 0x20, 0x00, 38		/* Set object type relocateable to x.  */
d3707 1
d4101 5
a4105 4
  /* ieee_get_symtab_upper_bound, ieee_get_symtab, ieee_make_empty_symbol,
     ieee_print_symbol, ieee_get_symbol_info, ieee_bfd_is_local_label_name,
     ieee_get_lineno, ieee_find_nearest_line, ieee_bfd_make_debug_symbol,
     ieee_read_minisymbols, ieee_minisymbol_to_symbol  */
@


1.6
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2000, 2001
d8 1
a8 1
This file is part of BFD, the Binary File Descriptor library.
d10 13
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d35 1
d37 5
a41 1
#include <ctype.h>
d43 140
a182 20
static boolean ieee_write_byte PARAMS ((bfd *, int));
static boolean ieee_write_2bytes PARAMS ((bfd *, int));
static boolean ieee_write_int PARAMS ((bfd *, bfd_vma));
static boolean ieee_write_id PARAMS ((bfd *, const char *));
static boolean ieee_write_expression
  PARAMS ((bfd *, bfd_vma, asymbol *, boolean, unsigned int));
static void ieee_write_int5 PARAMS ((bfd_byte *, bfd_vma));
static boolean ieee_write_int5_out PARAMS ((bfd *, bfd_vma));
static boolean ieee_write_section_part PARAMS ((bfd *));
static boolean do_with_relocs PARAMS ((bfd *, asection *));
static boolean do_as_repeat PARAMS ((bfd *, asection *));
static boolean do_without_relocs PARAMS ((bfd *, asection *));
static boolean ieee_write_external_part PARAMS ((bfd *));
static boolean ieee_write_data_part PARAMS ((bfd *));
static boolean ieee_write_debug_part PARAMS ((bfd *));
static boolean ieee_write_me_part PARAMS ((bfd *));
static boolean ieee_write_processor PARAMS ((bfd *));

static boolean ieee_slurp_debug PARAMS ((bfd *));
static boolean ieee_slurp_section_data PARAMS ((bfd *));
d187 1
a187 1
static boolean
d195 3
a197 3
  if (bfd_write ((PTR) &byte, 1, 1, abfd) != 1)
    return false;
  return true;
d200 1
a200 1
static boolean
d209 3
a211 3
  if (bfd_write ((PTR) buffer, 1, 2, abfd) != 2)
    return false;
  return true;
d214 1
a214 1
static boolean
d222 1
a222 1
	return false;
d228 2
a229 2
      /* How many significant bytes ? */
      /* FIXME FOR LONGER INTS */
d242 1
a242 1
	return false;
d247 1
a247 1
	    return false;
d251 1
a251 1
	    return false;
d255 1
a255 1
	    return false;
d259 1
a259 1
	    return false;
d263 1
a263 1
  return true;
d266 1
a266 1
static boolean
d276 1
a276 1
	return false;
d282 1
a282 1
	return false;
d288 1
a288 1
	return false;
d296 1
a296 1
      return false;
d299 3
a301 3
  if (bfd_write ((PTR) id, 1, length, abfd) != length)
    return false;
  return true;
d304 2
a305 4
/***************************************************************************
Functions for reading from ieee files in the strange way that the
standard requires:
*/
d317 1
d328 1
d330 1
a330 3
    {
      string[i] = this_byte_and_next (ieee);
    }
d339 1
d343 1
a343 1
      /* Simple string of length 0 to 127 */
d347 1
a347 1
      /* Length is next byte, allowing 0..255 */
d352 1
a352 1
      /* Length is next two bytes, allowing 0..65535 */
d356 3
a358 2
  /* Buy memory and read string */
  string = bfd_alloc (ieee->abfd, length + 1);
d366 1
a366 1
static boolean
d371 1
a371 1
     boolean pcrel;
d379 1
a379 1
	return false;
d383 3
a385 2
  if (bfd_is_com_section (symbol->section)
      || bfd_is_und_section (symbol->section))
d387 2
a388 11
      /* Def of a common symbol */
      if (! ieee_write_byte (abfd, ieee_variable_X_enum)
	  || ! ieee_write_int (abfd, symbol->value))
	return false;
      term_count++;
    }
  else if (! bfd_is_abs_section (symbol->section))
    {
      /* Ref to defined symbol - */

      if (symbol->flags & BSF_GLOBAL)
d390 2
a391 1
	  if (! ieee_write_byte (abfd, ieee_variable_I_enum)
d393 2
a394 2
	    return false;
	  term_count++;
d396 1
a396 1
      else if (symbol->flags & (BSF_LOCAL | BSF_SECTION_SYM))
d398 10
a407 9
	  /* This is a reference to a defined local symbol.  We can
	     easily do a local as a section+offset.  */
	  if (! ieee_write_byte (abfd, ieee_variable_R_enum)
	      || ! ieee_write_byte (abfd,
				    (bfd_byte) (symbol->section->index
						+ IEEE_SECTION_NUMBER_BASE)))
	    return false;
	  term_count++;
	  if (symbol->value != 0)
d409 8
a416 2
	      if (! ieee_write_int (abfd, symbol->value))
		return false;
d418 15
a434 9
      else
	{
	  (*_bfd_error_handler)
	    (_("%s: unrecognized symbol `%s' flags 0x%x"),
	     bfd_get_filename (abfd), bfd_asymbol_name (symbol),
	     symbol->flags);
	  bfd_set_error (bfd_error_invalid_operation);
	  return false;
	}
d439 1
a439 1
      /* subtract the pc from here by asking for PC of this section*/
d444 1
a444 1
	return false;
d449 2
a450 4
    {
      if (! ieee_write_int (abfd, 0))
	return false;
    }
d455 1
a455 1
	return false;
d459 1
a459 1
  return true;
d462 1
a462 1
/*****************************************************************************/
a463 3
/*
writes any integer into the buffer supplied and always takes 5 bytes
*/
d476 1
a476 1
static boolean
d484 3
a486 3
  if (bfd_write ((PTR) b, 1, 5, abfd) != 5)
    return false;
  return true;
d489 1
a489 1
static boolean
d496 1
d501 1
a501 1
      return true;
d506 1
d515 1
a515 1
      return true;
d517 1
a517 1
  return false;
d523 1
a523 1
     boolean *ok;
d535 1
a535 1
  BFD_ASSERT (parse_int (ieee, &result) == true);
d550 1
a550 1
#define PCREL_OFFSET false
d555 1
a555 1
#define PCREL_OFFSET true
d564 1
a564 1
	 false,
d569 1
a569 1
	 true,
d572 1
a572 1
	 false);
d579 1
a579 1
	 false,
d584 1
a584 1
	 true,
d587 1
a587 1
	 false);
d594 1
a594 1
	 false,
d599 1
a599 1
	 true,
d602 1
a602 1
	 false);
d609 1
a609 1
	 true,
d614 1
a614 1
	 true,
d624 1
a624 1
	 true,
d629 1
a629 1
	 true,
d639 1
a639 1
	 true,
d644 1
a644 1
	 true,
d656 1
a656 1
     boolean *pcrel;
d667 1
a667 1
  boolean loop = true;
d670 1
a670 1
  /* The stack pointer always points to the next unused location */
d674 1
d676 1
a676 1
  while (loop)
d681 1
a681 1
	  /* P variable, current program counter for section n */
d684 1
d686 1
a686 1
	    *pcrel = true;
d692 1
a692 1
	  /* L variable  address of section N */
d697 2
a698 2
	  /* R variable, logical address of section module */
	  /* FIXME, this should be different to L */
d703 1
a703 1
	  /* S variable, size in MAUS of section module */
d710 1
a710 1
	  /* Push the address of variable n */
d721 1
a721 1
	  /* Push the address of external variable n */
d770 2
a771 24
		/*
		  Thats all that we can understand. As far as I can see
		  there is a bug in the Microtec IEEE output which I'm
		  using to scan, whereby the comma operator is omitted
		  sometimes in an expression, giving expressions with too
		  many terms. We can tell if that's the case by ensuring
		  that sp == stack here. If not, then we've pushed
		  something too far, so we keep adding.  */

		while (sp != stack + 1)
		  {
		    asection *section1;
		    ieee_symbol_index_type sy1;
		    POP (sy1, section1, *extra);
		  }
		{
		  asection *dummy;

		  POP (*symbol, dummy, *value);
		  if (section)
		    *section = dummy;
		}

		loop = false;
d776 17
d796 27
a822 2
#define ieee_seek(abfd, offset) \
  IEEE_DATA(abfd)->h.input_p = IEEE_DATA(abfd)->h.first_byte + offset
d824 2
a825 2
#define ieee_pos(abfd) \
  (IEEE_DATA(abfd)->h.input_p - IEEE_DATA(abfd)->h.first_byte)
d828 1
a828 1
static char last_type;		/* is the index for an X or a D */
d831 1
a831 8
get_symbol (abfd,
	    ieee,
	    last_symbol,
	    symbol_count,
	    pptr,
	    max_index,
	    this_type
)
d838 1
a838 2
     char this_type
      ;
d840 1
a840 1
  /* Need a new symbol */
d842 1
d845 4
a848 2
      ieee_symbol_type *new_symbol = (ieee_symbol_type *) bfd_alloc (ieee->h.abfd,
						 sizeof (ieee_symbol_type));
d858 2
a859 3
	{
	  *max_index = new_index;
	}
d867 1
a867 1
static boolean
d878 1
a878 1
  boolean loop = true;
d880 1
a880 1
  ieee->symbol_table_full = true;
d882 1
a882 1
  ieee_seek (abfd, offset);
d895 1
a895 1
	    return false;
d909 1
a909 1
	    return false;
d924 1
a924 1
	    switch (read_2bytes (ieee))
d938 2
a939 2
		      (_("%s: unimplemented ATI record  %u for symbol %u"),
		       bfd_get_filename (abfd), symbol_attribute_def,
d942 1
a942 1
		    return false;
d947 1
a947 1
		/* Skip over ATX record. */
d956 1
a956 1
		   {$F1}${CE}{index}{$00}{$3F}{$3F}{#_of_ASNs} */
d964 1
a964 1
			 bfd_get_filename (abfd), (int) value);
d966 1
a966 1
		    return false;
d976 1
a976 1
		    switch (read_2bytes (ieee))
d986 1
a986 1
			     bfd_get_filename (abfd));
d988 1
a988 1
			return false;
d998 1
a998 1
	    boolean pcrel_ignore;
d1042 1
a1042 1
	    /* Throw away the external reference index */
d1044 1
a1044 1
	    /* Fetch the default size if not resolved */
d1046 2
a1047 2
	    /* Fetch the defautlt value if available */
	    if (parse_int (&(ieee->h), &value) == false)
d1051 1
a1051 1
	    /* This turns into a common */
d1064 1
a1064 1
	    return false;
d1077 1
a1077 1
	  loop = false;
d1109 1
a1109 1
      ieee->symbol_table_full = false;
d1115 1
a1115 1
  return true;
d1118 1
a1118 1
static boolean
d1122 1
a1122 1
  if (IEEE_DATA (abfd)->read_symbols == false)
d1125 2
a1126 2
	return false;
      IEEE_DATA (abfd)->read_symbols = true;
d1128 1
a1128 1
  return true;
d1131 1
a1131 1
long
d1142 2
a1143 4
/*
Move from our internal lists to the canon table, and insert in
symbol index order
*/
d1147 1
a1147 1
long
d1174 1
a1174 1
      if (ieee->symbol_table_full == false)
d1176 2
a1177 2
	  /* Arrgh - there are gaps in the table, run through and fill them */
	  /* up with pointers to a null place */
d1179 1
d1181 1
a1181 3
	    {
	      location[i] = &empty_symbol;
	    }
d1188 2
a1189 4
	{
	  /* Place into table at correct index locations */
	  location[symp->index + ieee->external_symbol_base_offset] = &symp->symbol;
	}
d1191 1
a1191 1
      /* The external refs are indexed in a bit */
d1198 3
a1200 3
	{
	  location[symp->index + ieee->external_reference_base_offset] =
	    &symp->symbol;
a1201 2
	}
    }
d1203 2
a1204 3
    {
      location[abfd->symcount] = (asymbol *) NULL;
    }
d1218 1
d1226 3
a1228 2
      n = ((asection **)
	   bfd_realloc (ieee->section_table, c * sizeof (asection *)));
d1241 1
a1241 1
      char *tmp = bfd_alloc (abfd, 11);
a1261 1
  asection *section = (asection *) NULL;
d1267 2
a1268 2
      ieee_seek (abfd, offset);
      while (true)
d1274 1
d1284 1
a1284 2
		   extended later, based on section contents. */

d1288 1
a1288 1
		    /* Normal attributes for absolute sections	*/
d1293 1
a1293 1
		      case 0xD3:	/* AS Absolute section attributes */
d1299 1
a1299 1
			    /* Normal code */
d1304 1
a1304 1
			    /* Normal data */
d1310 1
a1310 1
			    /* Normal rom data */
d1318 1
a1318 1
		  case 0xC3:	/* Named relocatable sections (type C) */
d1323 1
a1323 1
		      case 0xD0:	/* Normal code (CP) */
d1327 1
a1327 1
		      case 0xC4:	/* Normal data (CD) */
d1331 1
a1331 1
		      case 0xD2:	/* Normal rom data (CR) */
d1340 1
a1340 1
		/* Read section name, use it if non empty. */
d1345 1
a1345 1
		/* Skip these fields, which we don't care about */
d1373 2
a1374 1
		ieee_record_enum_type t = (ieee_record_enum_type) (read_2bytes (&(ieee->h)));
d1376 1
d1426 1
a1426 1
static boolean
d1435 1
a1435 1
    return true;
d1439 1
a1439 1
    return false;
d1443 1
a1443 5
  debug_end = ieee->w.r.data_part;
  if (debug_end == 0)
    debug_end = ieee->w.r.trailer_part;
  if (debug_end == 0)
    debug_end = ieee->w.r.me_record;
d1446 1
a1446 1
  return true;
d1449 1
a1449 3
/***********************************************************************
*  archive stuff
*/
d1461 1
a1461 1
  unsigned int alc_elts;
d1463 1
d1465 1
a1465 2
  abfd->tdata.ieee_ar_data =
    (ieee_ar_data_type *) bfd_alloc (abfd, sizeof (ieee_ar_data_type));
d1467 1
a1467 1
    goto error_return;
d1470 3
a1472 3
  /* FIXME: Check return value.  I'm not sure whether it needs to read
     the entire buffer or not.  */
  bfd_read ((PTR) buffer, 1, sizeof (buffer), abfd);
d1532 1
a1532 1
      if ((size_t) ieee_pos (abfd) > sizeof (buffer) / 2)
d1535 1
a1535 1
	  buffer_offset += ieee_pos (abfd);
d1539 2
a1540 3
	  /* FIXME: Check return value.  I'm not sure whether it needs
	     to read the entire buffer or not.  */
	  bfd_read ((PTR) buffer, 1, sizeof (buffer), abfd);
d1546 3
a1548 3
  ieee->elements = ((ieee_ar_obstack_type *)
		    bfd_alloc (abfd,
			       ieee->element_count * sizeof *ieee->elements));
d1552 1
a1552 2
  memcpy (ieee->elements, elts,
	  ieee->element_count * sizeof *ieee->elements);
d1562 2
a1563 3
      /* FIXME: Check return value.  I'm not sure whether it needs to
	 read the entire buffer or not.  */
      bfd_read ((PTR) buffer, 1, sizeof (buffer), abfd);
d1570 1
a1570 1
      
a1582 2
  bfd_release (abfd, ieee);
  abfd->tdata.ieee_ar_data = save;
a1583 1

d1587 3
a1593 8
static boolean
ieee_mkobject (abfd)
     bfd *abfd;
{
  abfd->tdata.ieee_data = (ieee_data_type *) bfd_zalloc (abfd, sizeof (ieee_data_type));
  return abfd->tdata.ieee_data ? true : false;
}

d1603 1
d1611 3
a1613 4
  /* Read the first few bytes in to see if it makes sense */
  /* FIXME: Check return value.  I'm not sure whether it needs to read
     the entire buffer or not.  */
  bfd_read ((PTR) buffer, 1, sizeof (buffer), abfd);
d1619 2
a1620 2
  ieee->read_symbols = false;
  ieee->read_data = false;
d1634 4
a1637 6
  if (abfd->filename == (CONST char *) NULL)
    {
      abfd->filename = ieee->mb.module_name;
    }
  /* Determine the architecture and machine type of the object file.
     */
d1676 6
a1681 6
	else if (toupper (processor[3]) == 'F')   /* 68F333 */
	  strcpy (family, "68332");	          /* CPU32 */
	else if ((toupper (processor[3]) == 'C')  /* Embedded controllers */
		 && ((toupper (processor[2]) == 'E')
		     || (toupper (processor[2]) == 'H')
		     || (toupper (processor[2]) == 'L')))
d1687 1
a1687 1
	else				 /* "Regular" processors */
d1709 2
a1710 3
    {
      goto fail;
    }
d1713 5
a1717 8
  if (parse_int (&(ieee->h), &ieee->ad.number_of_bits_mau) == false)
    {
      goto fail;
    }
  if (parse_int (&(ieee->h), &ieee->ad.number_of_maus_in_address) == false)
    {
      goto fail;
    }
d1719 3
a1721 3
  /* If there is a byte order info, take it */
  if (this_byte (&(ieee->h)) == (int) ieee_variable_L_enum ||
      this_byte (&(ieee->h)) == (int) ieee_variable_M_enum)
d1726 2
a1727 1
      boolean ok;
d1729 2
a1730 3
	{
	  goto fail;
	}
d1732 1
a1732 3
	{
	  goto fail;
	}
d1735 2
a1736 5
      if (ok == false)
	{
	  goto fail;
	}

d1745 1
a1745 1
     record */
d1747 1
d1749 1
a1749 1
    (unsigned char *) bfd_alloc (ieee->h.abfd, ieee->w.r.me_record + 1);
d1756 2
a1757 2
  bfd_read ((PTR) (IEEE_DATA (abfd)->h.first_byte), 1,
	    ieee->w.r.me_record + 1, abfd);
a1765 1

d1768 1
a1768 1
    
d1773 1
a1773 1
  (void) bfd_release (abfd, ieee);
d1778 1
a1778 1
void
d1791 3
a1793 3
void
ieee_print_symbol (ignore_abfd, afile, symbol, how)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d1818 1
d1825 1
a1825 1
	    bfd_print_symbol_vandf ((PTR) file, symbol);
d1838 1
a1838 1
static boolean
d1852 1
d1866 2
a1867 1
	boolean loop = true;
d1880 1
a1880 1
		  boolean pcrel = false;
d1882 4
a1885 3
		  ieee_reloc_type *r =
		  (ieee_reloc_type *) bfd_alloc (ieee->h.abfd,
						 sizeof (ieee_reloc_type));
d1887 1
a1887 1
		    return false;
d1909 1
a1909 1
		      /* Fetch number of bytes to pad */
d1927 1
a1927 1
		  /* Build a relocation entry for this type */
d1939 1
a1939 1
		      if (pcrel == true)
d1942 2
a1943 2
			  bfd_put_32 (ieee->h.abfd, -current_map->pc, location_ptr +
				      current_map->pc);
d1945 1
a1945 2
			  r->relent.addend -=
			    current_map->pc;
d1947 1
a1947 1
			  bfd_put_32 (ieee->h.abfd, 0, location_ptr +
d1954 2
a1955 2
			  bfd_put_32 (ieee->h.abfd, 0, location_ptr +
				      current_map->pc);
d1961 1
a1961 1
		      if (pcrel == true)
d1964 2
a1965 1
			  bfd_put_16 (ieee->h.abfd, (int) (-current_map->pc), location_ptr + current_map->pc);
d1970 2
a1971 1
			  bfd_put_16 (ieee->h.abfd, 0, location_ptr + current_map->pc);
d1978 2
a1979 1
			  bfd_put_16 (ieee->h.abfd, 0, location_ptr + current_map->pc);
d1985 1
a1985 1
		      if (pcrel == true)
d2006 1
a2006 1
		      return false;
d2013 1
a2013 1
		  if (parse_int (&(ieee->h), &this_size) == true)
d2024 1
a2024 1
		      loop = false;
d2032 1
a2032 1
	      loop = false;
d2036 1
a2036 1
  return true;
d2039 3
a2041 2
/* Read in all the section data and relocation stuff too */
static boolean
d2051 5
a2055 7
  /* Seek to the start of the data area */
  if (ieee->read_data == true)
    return true;
  ieee->read_data = true;
  ieee_seek (abfd, ieee->w.r.data_part);

  /* Allocate enough space for all the section contents */
d2057 1
d2060 1
a2060 1
      ieee_per_section_type *per = (ieee_per_section_type *) s->used_by_bfd;
d2065 1
a2065 2
	return false;
      /*SUPPRESS 68*/
d2070 1
a2070 1
  while (true)
d2074 1
a2074 1
	  /* IF we see anything strange then quit */
d2076 1
a2076 1
	  return true;
d2083 1
a2083 1
	  current_map = (ieee_per_section_type *) s->used_by_bfd;
d2085 3
a2087 3
	  /* The document I have says that Microtec's compilers reset */
	  /* this after a sec section, even though the standard says not */
	  /* to. SO .. */
d2100 2
a2101 1
		boolean pcrel;
d2103 1
a2103 1
		must_parse_int (&(ieee->h));	/* Thow away section #*/
d2118 2
a2119 2
	      /* We've got to the end of the data now - */
	      return true;
d2122 1
a2122 1
	      return false;
d2128 3
a2130 5
		 remembering the stream pointer before running it and
		 resetting it and running it n times. We special case
		 the repetition of a repeat_data/load_constant
		 */

d2133 1
d2137 2
a2138 2
	    if (start[0] == (int) ieee_load_constant_bytes_enum &&
		start[1] == 1)
d2155 2
a2156 2
				 iterations))
		      return false;
d2164 2
a2165 4
	  {
	    if (!do_one (ieee, current_map, location_ptr, s, 1))
	      return false;
	  }
d2170 1
a2170 1
boolean
d2175 2
a2176 2
  newsect->used_by_bfd = (PTR)
    bfd_alloc (abfd, sizeof (ieee_per_section_type));
d2178 1
a2178 1
    return false;
d2181 1
a2181 1
  return true;
d2184 1
a2184 1
long
d2196 1
a2196 1
static boolean
d2204 1
a2204 1
  ieee_per_section_type *p = (ieee_per_section_type *) section->used_by_bfd;
d2210 1
a2210 1
  return true;
d2213 1
a2213 1
long
a2219 1
/*  ieee_per_section_type *p = (ieee_per_section_type *) section->used_by_bfd;*/
d2228 1
a2228 1
      /* Work out which symbol to attach it this reloc to */
d2257 2
a2258 2
     CONST PTR ap;
     CONST PTR bp;
d2267 1
a2267 1
static boolean
d2283 1
a2283 1
	    return false;
d2287 1
a2287 1
	      /* This image is executable, so output absolute sections */
d2290 1
a2290 1
		return false;
d2295 1
a2295 1
		return false;
d2303 1
a2303 1
		return false;
d2308 1
a2308 1
		return false;
d2315 1
a2315 1
		return false;
d2320 1
a2320 1
	    return false;
d2326 1
a2326 1
	  /* Alignment */
d2331 2
a2332 2
	      || ! ieee_write_int (abfd, 1 << s->alignment_power))
	    return false;
d2334 1
a2334 1
	  /* Size */
d2340 1
a2340 1
	    return false;
d2343 2
a2344 2
	      /* Relocateable sections don't have asl records */
	      /* Vma */
d2351 1
a2351 1
		return false;
d2356 1
a2356 1
  return true;
d2360 1
a2360 1
static boolean
d2377 1
a2377 1
  /* Output the section preheader */
d2384 2
a2385 1
    return false;
d2389 1
a2389 1
	return false;
d2393 2
a2394 2
      if (! ieee_write_expression (abfd, 0, s->symbol, 0, 0))
	return false;
d2400 1
a2400 2
	 byte opcode rather than the load with relocation opcode */

d2405 1
d2408 1
a2408 3
	    {
	      run = s->_raw_size - current_byte_index;
	    }
d2413 2
a2414 2
		return false;
	      /* Output a stream of bytes */
d2416 2
a2417 5
		return false;
	      if (bfd_write ((PTR) (stream + current_byte_index),
			     1,
			     run,
			     abfd)
d2419 1
a2419 1
		return false;
d2427 1
a2427 1
	return false;
d2435 2
a2436 2
	  /* Outputting a section without data, fill it up */
	  stream = (unsigned char *) (bfd_alloc (abfd, s->_raw_size));
d2438 1
a2438 2
	    return false;
	  memset ((PTR) stream, 0, (size_t) s->_raw_size);
d2444 1
d2452 2
a2453 3
	    {
	      run = MAXRUN;
	    }
d2455 1
a2455 3
	    {
	      run = s->_raw_size - current_byte_index;
	    }
d2459 1
a2459 1
	      /* Output a stream of bytes */
d2461 2
a2462 5
		return false;
	      if (bfd_write ((PTR) (stream + current_byte_index),
			     1,
			     run,
			     abfd)
d2464 1
a2464 1
		return false;
d2467 2
a2468 1
	  /* Output any relocations here */
a2475 1

d2478 1
a2478 3
		    {
		      r->addend += current_byte_index;
		    }
a2479 1

d2501 1
a2501 1
		      return false;
d2512 1
a2512 1
		    return false;
d2521 2
a2522 2
						   s->index))
			return false;
d2529 2
a2530 2
						   s->index))
			return false;
d2536 3
a2538 3
		      if (! ieee_write_int (abfd,
					    bfd_get_reloc_size (r->howto)))
			return false;
d2542 1
a2542 1
		    return false;
d2552 1
a2552 1
  return true;
d2559 1
a2559 1
static boolean
d2574 15
a2588 3
					    + IEEE_SECTION_NUMBER_BASE))
	  || ! ieee_write_int (abfd, s->lma)
	  || ! ieee_write_byte (abfd, ieee_repeat_data_enum)
d2593 1
a2593 1
	return false;
d2596 1
a2596 1
  return true;
d2599 1
a2599 1
static boolean
d2609 1
a2609 1
	return false;
d2614 1
d2620 2
a2621 2
		return false;
	      return true;
d2625 1
a2625 1
	return false;
d2628 1
a2628 1
  return true;
d2642 20
d2665 1
d2668 1
a2668 1
  bfd_read ((PTR) input_ptr_start, 1, input_ptr_end - input_ptr_start, input_bfd);
d2671 1
d2675 3
a2677 3
  if (bfd_write ((PTR) (output_ptr_start), 1, output_ptr - output_ptr_start,
		 output_bfd)
      != (bfd_size_type) (output_ptr - output_ptr_start))
d2698 2
a2699 2
      /* How many significant bytes ? */
      /* FIXME FOR LONGER INTS */
d2701 1
a2701 3
	{
	  length = 4;
	}
d2703 1
a2703 3
	{
	  length = 3;
	}
d2705 1
a2705 3
	{
	  length = 2;
	}
a2720 1

d2729 1
d2746 2
a2747 1
  int value = 0;
d2795 1
a2795 1
	      /* Not a number, just bug out with the answer */
a2800 1
	  value = 0;
d2803 5
a2807 7
	  /* PLUS anything */
	  {
	    int value = *(--tos);
	    value += *(--tos);
	    *tos++ = value;
	    NEXT ();
	  }
d2814 1
d2821 1
d2823 1
a2823 7
	      {
		value = s->output_section->lma;
	      }
	    else
	      {
		value = 0;
	      }
a2825 1
	    value = 0;
a2833 1

a2836 1

a2841 6
struct output_buffer_struct
{
  unsigned char *ptrp;
  int buffer;
};

d2848 1
a2848 1
      /* Still a chance to output the size */
d2863 1
a2929 1
static void copy_till_end ();
d2937 2
a2938 1
  /* ATN record */
d2978 1
a2978 1
      /* EXternal ref */
a3031 1

d3037 1
a3037 1
  /* Attribute record */
d3048 1
a3095 1
static void block ();
d3107 3
a3109 3
      /* Unique typedefs for module */
      /* GLobal typedefs  */
      /* High level module scope beginning */
d3112 1
d3127 1
a3127 1
      /* Global function */
d3130 1
d3150 1
a3150 1
      /* File name for source line numbers */
d3153 1
d3173 1
a3173 1
      /* Local function */
d3176 1
d3194 1
a3194 1
      /* Assembler module scope beginning -*/
d3223 1
d3260 1
d3292 2
a3293 5

/* relocate_debug,
   moves all the debug information from the source bfd to the output
   bfd, and relocates any expressions it finds
*/
d3309 1
a3309 1
  bfd_read ((PTR) input_ptr_start, 1, IBS, input);
d3316 1
a3316 1
static boolean
d3322 2
a3323 2
  unsigned char output_buffer[OBS];
  boolean some_debug = false;
d3326 3
a3328 3
  output_ptr_start = output_ptr = output_buffer;
  output_ptr_end = output_buffer + OBS;
  output_ptr = output_buffer;
d3341 1
a3341 1
	  return true;
d3345 2
a3346 2
      if (bfd_write (s->contents, 1, s->_raw_size, abfd) != s->_raw_size)
	return false;
d3354 1
d3358 2
a3359 3
			    SEEK_SET)
		  != 0)
		return false;
d3365 1
d3367 1
a3367 3
	{
	  ieee->w.r.debug_information_part = here;
	}
d3369 1
a3369 3
	{
	  ieee->w.r.debug_information_part = 0;
	}
d3374 1
a3374 1
  return true;
d3379 1
a3379 1
static boolean
d3384 1
d3387 1
d3400 1
a3400 1
	    return false;
d3405 1
a3405 1
	    return false;
d3409 1
a3409 1
  return true;
d3413 1
a3413 1
static boolean
d3418 1
d3425 2
a3426 1
	  ieee_per_section (s)->data = (bfd_byte *) (bfd_alloc (abfd, s->_raw_size));
d3428 1
a3428 1
	    return false;
d3431 1
a3431 1
  return true;
d3434 4
a3437 1
/** exec and core file sections */
d3439 1
a3439 4
/* set section contents is complicated with IEEE since the format is
* not a byte image, but a record stream.
*/
boolean
d3451 2
a3452 2
	  section->contents = ((unsigned char *)
			       bfd_alloc (abfd, section->_raw_size));
d3454 1
a3454 1
	    return false;
d3458 2
a3459 2
      memcpy (section->contents + offset, location, count);
      return true;
d3465 1
a3465 1
	return false;
d3470 1
a3470 1
  return true;
d3478 1
a3478 1
static boolean
a3483 1

d3487 2
a3488 1
  boolean hadone = false;
d3495 1
d3498 1
a3498 1
	      /* This must be a symbol reference .. */
d3500 1
a3500 1
		  || ! ieee_write_int (abfd, reference_index)
d3502 1
a3502 1
		return false;
d3505 1
a3505 1
	      hadone = true;
d3509 1
a3509 1
	      /* This is a weak reference */
d3511 1
a3511 1
		  || ! ieee_write_int (abfd, reference_index)
d3515 1
a3515 1
		  || ! ieee_write_int (abfd, reference_index)
d3517 1
a3517 1
		return false;
d3520 1
a3520 1
	      hadone = true;
d3524 1
a3524 2
	      /* This must be a symbol definition */

d3526 1
a3526 1
		  || ! ieee_write_int (abfd, public_index)
d3529 1
a3529 1
		  || ! ieee_write_int (abfd, public_index)
d3533 1
a3533 1
		return false;
d3535 1
a3535 1
	      /* Write out the value */
d3537 2
a3538 2
		  || ! ieee_write_int (abfd, public_index))
		return false;
d3544 1
a3544 1
			 relocated */
d3550 1
a3550 1
			return false;
d3558 2
a3559 2
			      false, 0)))
			return false;
d3567 2
a3568 2
					       false, 0))
		    return false;
d3572 1
a3572 1
	      hadone = true;
d3576 2
a3577 2
	      /* This can happen - when there are gaps in the symbols read */
	      /* from an input ieee file */
d3584 1
a3584 1
  return true;
d3588 1
a3588 1
static CONST unsigned char exten[] =
d3591 3
a3593 3
  0xf1, 0xce, 0x20, 0x00, 37, 3, 3,	/* Set version 3 rev 3   	*/
  0xf1, 0xce, 0x20, 0x00, 39, 2,/* keep symbol in  original case */
  0xf1, 0xce, 0x20, 0x00, 38	/* set object type relocateable to x */
d3596 1
a3596 1
static CONST unsigned char envi[] =
d3609 1
a3609 1
static boolean
d3621 1
a3621 1
	return false;
d3625 2
a3626 2
    return false;
  return true;
d3631 1
a3631 1
static boolean
d3642 1
a3642 1
	return false;
d3647 1
a3647 1
	return false;
d3652 1
a3652 1
	return false;
d3657 1
a3657 1
	return false;
d3667 1
a3667 1
	    return false;
d3672 1
a3672 1
	    return false;
d3677 1
a3677 1
	    return false;
d3683 1
a3683 1
	    return false;
d3710 1
a3710 1
	  return false;
d3715 1
a3715 1
  return true;
d3718 1
a3718 1
boolean
d3726 1
a3726 1
  /* Fast forward over the header area */
d3728 1
a3728 1
    return false;
d3733 1
a3733 1
    return false;
d3735 1
a3735 1
  /* Fast forward over the variable bits */
d3737 1
a3737 1
    return false;
d3739 1
a3739 1
  /* Bits per MAU */
d3741 2
a3742 2
    return false;
  /* MAU's per address */
d3746 1
a3746 1
    return false;
d3750 1
a3750 1
    return false;
d3753 3
a3755 2
  if (bfd_write ((char *) exten, 1, sizeof (exten), abfd) != sizeof (exten))
    return false;
d3759 1
a3759 1
	return false;
d3764 1
a3764 1
	return false;
d3768 3
a3770 2
  if (bfd_write ((char *) envi, 1, sizeof (envi), abfd) != sizeof (envi))
    return false;
d3783 7
a3789 7
	|| ! ieee_write_int (abfd, t->tm_year + 1900)
	|| ! ieee_write_int (abfd, t->tm_mon + 1)
	|| ! ieee_write_int (abfd, t->tm_mday)
	|| ! ieee_write_int (abfd, t->tm_hour)
	|| ! ieee_write_int (abfd, t->tm_min)
	|| ! ieee_write_int (abfd, t->tm_sec))
      return false;
d3797 1
a3797 1
    return false;
d3801 1
a3801 6
    return false;

  /*  ieee_write_byte(abfd, ieee_record_seperator_enum);*/

  /*  ieee_write_byte(abfd, ieee_record_seperator_enum);*/

d3805 1
a3805 1
    return false;
d3811 1
a3811 1
    return false;
d3815 1
a3815 1
    return false;
d3817 1
a3817 1
  /* Generate the header */
d3819 1
a3819 1
    return false;
d3825 2
a3826 2
	  || ! ieee_write_int5_out (abfd, ieee->w.offset[i]))
	return false;
d3829 1
a3829 1
  return true;
d3836 1
a3836 1
   hold them all plus all the cached symbol entries. */
d3838 1
a3838 1
asymbol *
d3842 3
a3844 2
  ieee_symbol_type *new =
    (ieee_symbol_type *) bfd_zalloc (abfd, sizeof (ieee_symbol_type));
d3857 2
a3858 1
  /* take the next one from the arch state, or reset */
d3860 4
a3863 5
    {
      /* Reset the index - the first two entries are bogus*/
      ar->element_index = 2;
    }
  while (true)
d3866 1
a3884 1

d3888 3
a3890 8
static boolean
ieee_find_nearest_line (abfd,
			section,
			symbols,
			offset,
			filename_ptr,
			functionname_ptr,
			line_ptr)
d3899 1
a3899 1
  return false;
d3937 1
a3937 1
     boolean x ATTRIBUTE_UNUSED;
d3962 1
a3962 2
   be ready to output it at close time
   */
d3970 2
a3971 1
  /* can only accumulate data from other ieee bfds */
d3974 2
a3975 2
  /* Only bother once per bfd */
  if (ieee->done_debug == true)
d3977 1
a3977 1
  ieee->done_debug = true;
d3979 1
a3979 1
  /* Don't bother if there is no debug info */
d3983 4
a3987 3
  /* Add to chain */
  {
    bfd_chain_type *n = (bfd_chain_type *) bfd_alloc (abfd, sizeof (bfd_chain_type));
d3994 1
a3994 3
      {
	output_ieee->chain_head->next = n;
      }
d3996 1
a3996 2
      {
	output_ieee->chain_root = n;
a3997 1
      }
d4010 2
a4011 1
  ((boolean (*) PARAMS ((bfd *, char **, bfd_size_type *, const char **))) \
d4015 1
a4015 1
  ((boolean (*) \
d4038 2
d4041 1
d4043 1
a4046 1
/*SUPPRESS 460 */
d4086 2
d4089 1
d4092 6
d4099 5
d4105 3
d4109 2
d4112 7
d4120 1
d4124 1
a4124 1
  
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d1347 1
a1347 4
    {
      abfd->tdata.ieee_ar_data = save;
      goto got_wrong_format_error;
    }
d1352 3
a1354 6
    {
      bfd_release (abfd, ieee);
      abfd->tdata.ieee_ar_data = save;
      goto got_wrong_format_error;
    }
  /* Throw away the filename */
d1360 2
a1361 2
  next_byte (&(ieee->h));	/* Drop the ad part */
  must_parse_int (&(ieee->h));	/* And the two dummy numbers */
d1369 1
a1369 1
  /* Read the index of the BB table */
d1398 1
a1398 2
      /* Make sure that we don't go over the end of the buffer */

d1401 1
a1401 1
	  /* Past half way, reseek and reprime */
d1405 1
d1419 1
d1425 1
a1425 3
  /* Now scan the area again, and replace BB offsets with file */
  /* offsets */

d1430 1
d1437 4
a1440 3
      next_byte (&(ieee->h));	/* Drop F8 */
      next_byte (&(ieee->h));	/* Drop 14 */
      must_parse_int (&(ieee->h));	/* Drop size of block */
d1442 2
a1443 4
	{
	  /* This object has been deleted */
	  ieee->elements[i].file_offset = 0;
	}
d1445 1
a1445 3
	{
	  ieee->elements[i].file_offset = must_parse_int (&(ieee->h));
	}
d1453 2
d1456 1
d1460 1
d3196 2
a3197 5
/*
  During linking, we we told about the bfds which made up our
  contents, we have a list of them. They will still be open, so go to
  the debug info in each, and copy it out, relocating it as we go.
*/
d3585 4
d3728 1
a3728 1
    (ieee_symbol_type *) bfd_zmalloc (sizeof (ieee_symbol_type));
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 3
a4 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d35 2
d167 1
a167 1
	("%s: string too long (%d chars, max 65535)",
d297 1
a297 1
	    ("%s: unrecognized symbol `%s' flags 0x%x",
d688 1
a688 1
     bfd *abfd;
d793 1
a793 1
		      ("%s: unimplemented ATI record  %u for symbol %u",
d808 38
d866 22
d1012 11
a1022 2
  /* the_bfd, name, value, attr, section */
  {&dummy_bfd, " ieee empty", (symvalue) 0, BSF_DEBUGGING, bfd_abs_section_ptr};
d1292 1
d1302 7
a1308 1
  sec->_raw_size = ieee->w.r.data_part - ieee->w.r.debug_information_part;
a1321 1
  boolean loop;
d1327 5
a1331 1
  abfd->tdata.ieee_ar_data = (ieee_ar_data_type *) bfd_alloc (abfd, sizeof (ieee_ar_data_type));
d1333 1
a1333 1
    return NULL;
d1348 1
a1348 1
      return (const bfd_target *) NULL;
d1357 1
a1357 1
      return (const bfd_target *) NULL;
d1369 5
a1373 1
  loop = true;
d1375 1
a1375 1
  while (loop)
d1377 39
a1415 25
      ieee_ar_obstack_type t;
      int rec = read_2bytes (&(ieee->h));
      if (rec == (int) ieee_assign_value_to_variable_enum)
	{
	  must_parse_int (&(ieee->h));
	  t.file_offset = must_parse_int (&(ieee->h));
	  t.abfd = (bfd *) NULL;
	  ieee->element_count++;

	  bfd_alloc_grow (abfd, (PTR) &t, sizeof t);

	  /* Make sure that we don't go over the end of the buffer */

	  if ((size_t) ieee_pos (abfd) > sizeof (buffer) / 2)
	    {
	      /* Past half way, reseek and reprime */
	      buffer_offset += ieee_pos (abfd);
	      if (bfd_seek (abfd, buffer_offset, SEEK_SET) != 0)
		return NULL;
	      /* FIXME: Check return value.  I'm not sure whether it
		 needs to read the entire buffer or not.  */
	      bfd_read ((PTR) buffer, 1, sizeof (buffer), abfd);
	      ieee->h.first_byte = buffer;
	      ieee->h.input_p = buffer;
	    }
a1416 2
      else
	loop = false;
d1419 9
a1427 3
  ieee->elements = (ieee_ar_obstack_type *) bfd_alloc_finish (abfd);
  if (!ieee->elements)
    return (const bfd_target *) NULL;
d1435 1
a1435 1
	return NULL;
d1456 2
a1457 1
/*  abfd->has_armap = ;*/
d1459 7
d1523 64
a1586 1
    const bfd_arch_info_type *arch = bfd_scan_arch (processor);
d1673 1
a1673 1
     bfd *ignore_abfd;
d1686 1
a1686 1
     bfd *ignore_abfd;
d1792 2
a1793 4
		  if (r->relent.sym_ptr_ptr == 0)
		    {
		      r->relent.sym_ptr_ptr = section->symbol_ptr_ptr;
		    }
d2001 4
d2131 3
a2133 2
	  src->relent.sym_ptr_ptr =
	    src->relent.sym_ptr_ptr[0]->section->symbol_ptr_ptr;
d3184 1
a3184 1
     bfd *output;
d3579 14
a3592 1
	char ab[20];
d3594 1
a3594 2
	sprintf (ab, "%lu", arch->mach);
	if (! ieee_write_id (abfd, ab))
d3783 7
a3789 7
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     char **filename_ptr;
     char **functionname_ptr;
     int *line_ptr;
d3799 1
a3799 1
  ieee_ar_data_type *ar = abfd->my_archive->tdata.ieee_ar_data;
d3802 2
d3828 2
a3829 2
     bfd *abfd;
     boolean x;
d3916 1
a3916 1
#define ieee_bfd_is_local_label bfd_generic_is_local_label
d3931 1
d3987 2
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2062 1
a2062 1
		  || ! ieee_write_int (abfd, s->vma))
d2099 1
a2099 1
      if (! ieee_write_int (abfd, s->vma))
d2300 1
a2300 1
	  || ! ieee_write_int (abfd, s->vma)
d2520 1
a2520 1
		value = s->output_section->vma;
a3204 1
	  hadone = true;
d3214 1
d3229 1
d3282 1
d3755 1
a3755 1
  0,				/* leading underscore */
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d1004 23
a1065 2
		/* Fixme to be nice about a silly number of sections */
		BFD_ASSERT (section_index < NSECTIONS);
d1396 2
a1397 1
  memset ((PTR) ieee->section_table, 0, sizeof (ieee->section_table));
d3161 2
a3162 1
	  section->contents = bfd_alloc (abfd, section->_raw_size);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94 Free Software Foundation, Inc.
d32 21
a52 3
#include "obstack.h"
#define obstack_chunk_alloc malloc
#define obstack_chunk_free free
d57 2
a58 2
static void
ieee_write_byte (abfd, byte)
d60 1
a60 1
     bfd_byte byte;
d62 1
a62 3
  if (bfd_write ((PTR) & byte, 1, 1, abfd) != 1)
    abort ();
}
d64 4
a67 10
static void
ieee_write_twobyte (abfd, twobyte)
     bfd *abfd;
     int twobyte;
{
  bfd_byte b[2];
  b[1] = twobyte & 0xff;
  b[0] = twobyte >> 8;
  if (bfd_write ((PTR) & b[0], 1, 2, abfd) != 2)
    abort ();
d70 1
a70 1
static void
d76 1
a78 1

d80 2
a81 1
    abort ();
d84 1
a84 1
static void
d89 1
a89 1
  if (((unsigned) value) <= 127)
d91 2
a92 1
      ieee_write_byte (abfd, (bfd_byte) value);
d97 1
d101 1
a101 3
	{
	  length = 4;
	}
d103 1
a103 3
	{
	  length = 3;
	}
d105 1
a105 3
	{
	  length = 2;
	}
d109 4
a112 2
      ieee_write_byte (abfd,
		 (bfd_byte) ((int) ieee_number_repeat_start_enum + length));
d116 3
a118 1
	  ieee_write_byte (abfd, (bfd_byte) (value >> 24));
d120 3
a122 1
	  ieee_write_byte (abfd, (bfd_byte) (value >> 16));
d124 3
a126 1
	  ieee_write_byte (abfd, (bfd_byte) (value >> 8));
d128 2
a129 1
	  ieee_write_byte (abfd, (bfd_byte) (value));
d132 2
d136 1
a136 1
static void
d139 1
a139 1
     CONST char *id;
d142 1
d145 2
a146 1
      ieee_write_byte (abfd, (bfd_byte) length);
d150 3
a152 2
      ieee_write_byte (abfd, ieee_extension_length_1_enum);
      ieee_write_byte (abfd, (bfd_byte) length);
d156 3
a158 3
      ieee_write_byte (abfd, ieee_extension_length_2_enum);
      ieee_write_byte (abfd, (bfd_byte) (length >> 8));
      ieee_write_byte (abfd, (bfd_byte) (length & 0xff));
d162 5
a166 1
      BFD_FAIL ();
d168 1
d170 2
a171 1
    abort ();
a173 1

d230 1
a230 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d236 1
a236 1
static void
d248 2
a249 1
      ieee_write_int (abfd, value);
d257 3
a259 2
      ieee_write_byte (abfd, ieee_variable_X_enum);
      ieee_write_int (abfd, symbol->value);
a265 4
      ieee_write_byte (abfd, ieee_variable_R_enum);
      ieee_write_byte (abfd,
	    (bfd_byte) (symbol->section->index + IEEE_SECTION_NUMBER_BASE));
      term_count++;
d268 3
a270 2
	  ieee_write_byte (abfd, ieee_variable_I_enum);
	  ieee_write_int (abfd, symbol->value);
d275 7
a281 6
	  /* This is a reference to a defined local symbol,
	 We can easily do a local as a section+offset */
	  ieee_write_byte (abfd, ieee_variable_R_enum);	/* or L */
	  ieee_write_byte (abfd,
	    (bfd_byte) (symbol->section->index + IEEE_SECTION_NUMBER_BASE));
	  ieee_write_int (abfd, symbol->value);
d283 6
d292 6
a297 1
	  BFD_FAIL ();
d304 5
a308 3
      ieee_write_byte (abfd, ieee_variable_P_enum);
      ieee_write_byte (abfd, (bfd_byte) (index + IEEE_SECTION_NUMBER_BASE));
      ieee_write_byte (abfd, ieee_function_minus_enum);
d311 2
a312 1
  if (term_count == 1)
d314 2
a315 1
      ieee_write_byte (abfd, 0);
d317 2
a318 1
  else
d320 3
a322 5
      while (term_count > 1)
	{
	  ieee_write_byte (abfd, ieee_function_plus_enum);
	  term_count--;
	}
d324 2
a327 1

d345 1
a345 1
static void
d351 1
d354 2
a355 1
    abort ();
d414 9
a422 23
static
reloc_howto_type abs32_howto
= HOWTO (1, 0, 2, 32, false, 0, complain_overflow_bitfield, 0, "abs32", true, 0xffffffff, 0xffffffff, false);
static
reloc_howto_type abs16_howto
= HOWTO (1, 0, 1, 16, false, 0, complain_overflow_bitfield, 0, "abs16", true, 0x0000ffff, 0x0000ffff, false);

static
reloc_howto_type abs8_howto
= HOWTO (1, 0, 0, 8, false, 0, complain_overflow_bitfield, 0, "abs8", true, 0x000000ff, 0x000000ff, false);

static
reloc_howto_type rel32_howto
= HOWTO (1, 0, 2, 32, true, 0, complain_overflow_signed, 0, "rel32", true, 0xffffffff,
	 0xffffffff, false);

static
reloc_howto_type rel16_howto
= HOWTO (1, 0, 1, 16, true, 0, complain_overflow_signed, 0, "rel16", true, 0x0000ffff, 0x0000ffff, false);

static
reloc_howto_type rel8_howto
= HOWTO (1, 0, 0, 8, true, 0, complain_overflow_signed, 0, "rel8", true, 0x000000ff, 0x000000ff, false);
d424 1
d426 89
a514 2
static ieee_symbol_index_type NOSYMBOL =
{0, 0};
d516 1
d553 1
a553 3
	    PUSH (NOSYMBOL, bfd_abs_section_ptr,
		  TOS.value = ieee->section_table[section_n]->vma +
		  ieee_per_section (ieee->section_table[section_n])->pc);
d575 10
d605 1
a605 1
	    PUSH (sy, section1 ? section1 : section_dummy, value1 - value2);
d700 1
a700 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return NULL;
	}
d712 1
d744 1
a744 1
			       &ieee->external_symbol_max_index, 'D');
d775 1
a775 6
	    next_byte (&(ieee->h));	/* Skip prefix */
	    next_byte (&(ieee->h));
	    symbol_name_index = must_parse_int (&(ieee->h));
	    symbol_type_index = must_parse_int (&(ieee->h));
	    symbol_attribute_def = must_parse_int (&(ieee->h));
	    switch (symbol_attribute_def)
d777 23
a799 5
	      case 63:
		/* Module misc; followed by two fields which describe the
	       current module block. The first fired is the type id
	       number, the second is the number of asn records
	       associated with the directive */
a801 3
		break;

	      default:
d1010 1
a1010 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return NULL;
	}
d1049 4
d1058 1
a1058 1
		    section->flags = SEC_LOAD | SEC_ALLOC | SEC_HAS_CONTENTS;
d1069 1
a1069 1
			    section->flags |= SEC_LOAD | SEC_CODE;
d1072 1
d1074 1
a1074 2
			    section->flags |= SEC_LOAD | SEC_DATA;
			    /* Normal data */
d1079 1
a1079 1
			    section->flags |= SEC_LOAD | SEC_ROM | SEC_DATA;
d1088 1
a1088 1
		    section->flags = SEC_LOAD | SEC_ALLOC | SEC_HAS_CONTENTS;
d1093 1
a1093 1
			section->flags |= SEC_LOAD | SEC_CODE;
d1097 1
a1097 1
			section->flags |= SEC_LOAD | SEC_DATA;
d1101 1
a1101 1
			section->flags |= SEC_LOAD | SEC_ROM | SEC_DATA;
d1156 1
d1169 1
d1186 25
a1211 1

a1221 1

a1223 1
  struct obstack ob;
d1229 1
a1229 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
a1256 8
  /* This must be an IEEE archive, so we'll buy some space to do
     things */

  if (!obstack_begin (&ob, 128))
    {
      bfd_set_error (bfd_error_no_memory);
      return (const bfd_target *) NULL;
    }
d1278 1
a1278 1
	  obstack_grow (&ob, (PTR) & t, sizeof (t));
d1299 1
a1299 1
  ieee->elements = (ieee_ar_obstack_type *) obstack_finish (&ob);
d1301 1
a1301 4
    {
      bfd_set_error (bfd_error_no_memory);
      return (const bfd_target *) NULL;
    }
a1432 5
  abfd->flags = HAS_SYMS;
/* By now we know that this is a real IEEE file, we're going to read
   the whole thing into memory so that we can run up and down it
   quickly. We can work out how big the file is from the trailer
   record */
d1434 10
a1443 2
  IEEE_DATA (abfd)->h.first_byte = (unsigned char *) bfd_alloc (ieee->h.abfd, ieee->w.r.me_record
								+ 50);
d1445 1
a1445 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto fail;
    }
d1450 2
a1451 1
  bfd_read ((PTR) (IEEE_DATA (abfd)->h.first_byte), 1, ieee->w.r.me_record + 50, abfd);
d1454 10
d1509 4
a1512 2
	CONST char *section_name = symbol->section == (asection *) NULL ?
	(CONST char *) "*abs" : symbol->section->name;
d1524 1
a1524 3
		     (unsigned) 0,	/*
					   aout_symbol(symbol)->desc & 0xffff,
					   aout_symbol(symbol)->other  & 0xff,*/
d1533 1
a1533 1
do_one (ieee, current_map, location_ptr, s)
d1538 1
d1578 1
a1578 4
		    {
		      bfd_set_error (bfd_error_no_memory);
		      return false;
		    }
d1591 2
d1622 1
a1622 1
			       and take out of reloc ..
d1624 2
a1625 4
			       I've changed this. It's all too
			       complicated. I keep 0 in the
			       instruction  now.
			       */
d1697 1
a1697 1
		      break;
d1719 5
d1752 2
d1756 1
a1756 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d1774 1
d1809 1
a1809 1
	      return true;
d1842 2
a1843 1
		    if (!do_one (ieee, current_map, location_ptr, s))
d1853 1
a1853 1
	    if (!do_one (ieee, current_map, location_ptr, s))
d1868 1
a1868 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d1879 2
d1895 3
d1914 3
d1922 4
d1955 1
a1955 3
/*
Write the section headers
*/
d1957 1
a1957 1
static void
d1966 2
a1967 1
      if (! bfd_is_abs_section (s))
d1969 5
a1973 2
	  ieee_write_byte (abfd, ieee_section_type_enum);
	  ieee_write_byte (abfd, (bfd_byte) (s->index + IEEE_SECTION_NUMBER_BASE));
d1978 3
a1980 2
	      ieee_write_byte (abfd, ieee_variable_A_enum);
	      ieee_write_byte (abfd, ieee_variable_S_enum);
d1984 2
a1985 1
	      ieee_write_byte (abfd, ieee_variable_C_enum);
d1992 2
a1993 1
	      ieee_write_byte (abfd, ieee_variable_P_enum);
d1997 2
a1998 1
	      ieee_write_byte (abfd, ieee_variable_D_enum);
d2004 2
a2005 2

	      ieee_write_byte (abfd, ieee_variable_R_enum);
d2009 2
a2010 1
	  ieee_write_id (abfd, s->name);
d2017 6
a2022 3
	  ieee_write_byte (abfd, ieee_section_alignment_enum);
	  ieee_write_byte (abfd, (bfd_byte) (s->index + IEEE_SECTION_NUMBER_BASE));
	  ieee_write_int (abfd, 1 << s->alignment_power);
d2025 6
a2030 3
	  ieee_write_2bytes (abfd, ieee_section_size_enum);
	  ieee_write_byte (abfd, (bfd_byte) (s->index + IEEE_SECTION_NUMBER_BASE));
	  ieee_write_int (abfd, s->_raw_size);
d2035 7
a2041 4
	      ieee_write_2bytes (abfd, ieee_section_base_address_enum);
	      ieee_write_byte (abfd,
			  (bfd_byte) (s->index + IEEE_SECTION_NUMBER_BASE));
	      ieee_write_int (abfd, s->vma);
d2044 1
d2046 1
a2046 1
    }
d2055 2
a2057 1

a2059 1

d2068 17
a2084 6
  ieee_write_byte (abfd, ieee_set_current_section_enum);
  ieee_write_byte (abfd, (bfd_byte) (s->index + IEEE_SECTION_NUMBER_BASE));

  ieee_write_twobyte (abfd, ieee_set_current_pc_enum);
  ieee_write_byte (abfd, (bfd_byte) (s->index + IEEE_SECTION_NUMBER_BASE));
  ieee_write_expression (abfd, 0, s->symbol, 0, 0);
d2088 2
a2089 2
      /* If there arn't any relocations then output the load constant byte
	   opcode rather than the load with relocation opcode */
d2094 1
a2094 1
	  unsigned int MAXRUN = 32;
d2103 2
a2104 1
	      ieee_write_byte (abfd, ieee_load_constant_bytes_enum);
d2106 2
a2107 1
	      ieee_write_int (abfd, run);
d2120 2
a2121 2
      ieee_write_byte (abfd, ieee_load_with_relocation_enum);

d2124 2
a2125 2
	   possible, allowing for the a reasonable packet size and
	   relocation stuffs */
d2132 1
a2132 4
	    {
	      bfd_set_error (bfd_error_no_memory);
	      return false;
	    }
d2138 1
a2138 1
	  unsigned int MAXRUN = 32;
d2142 2
d2157 2
a2158 1
	      ieee_write_int (abfd, run);
d2170 2
a2171 1
	      while (relocs_to_go && (*p) && (*p)->address == current_byte_index)
a2172 1

d2174 1
a2174 1
		  bfd_vma ov;
d2187 2
a2188 2
		      ov = bfd_get_32 (abfd,
				       stream + current_byte_index);
d2192 2
a2193 2
		      ov = bfd_get_16 (abfd,
				       stream + current_byte_index);
d2197 2
a2198 2
		      ov = bfd_get_8 (abfd,
				      stream + current_byte_index);
d2204 1
d2206 12
a2217 2
		  ieee_write_byte (abfd, ieee_function_either_open_b_enum);
/*	      abort();*/
d2221 5
a2225 3
		      ieee_write_expression (abfd, r->addend + ov,
					     *(r->sym_ptr_ptr),
					   r->howto->pc_relative, s->index);
d2229 5
a2233 3
		      ieee_write_expression (abfd, r->addend + ov,
					     (asymbol *) NULL,
					   r->howto->pc_relative, s->index);
d2236 2
a2237 1
		  if (1 || r->howto->size != 2)
d2239 3
a2241 2
		      ieee_write_byte (abfd, ieee_comma);
		      ieee_write_int (abfd, 1 << r->howto->size);
d2243 3
a2245 2
		  ieee_write_byte (abfd,
				   ieee_function_either_close_b_enum);
d2254 1
d2258 3
a2260 3
/* If there are no relocations in the output section then we can
be clever about how we write. We block items up into a max of 127
bytes */
d2262 1
a2262 1
static void
d2269 16
a2284 12
      ieee_write_byte (abfd, ieee_set_current_section_enum);
      ieee_write_byte (abfd, (bfd_byte) (s->index + IEEE_SECTION_NUMBER_BASE));
      ieee_write_byte (abfd, ieee_set_current_pc_enum >> 8);
      ieee_write_byte (abfd, ieee_set_current_pc_enum & 0xff);
      ieee_write_byte (abfd, (bfd_byte) (s->index + IEEE_SECTION_NUMBER_BASE));
      ieee_write_int (abfd, s->vma);

      ieee_write_byte (abfd, ieee_repeat_data_enum);
      ieee_write_int (abfd, s->_raw_size);
      ieee_write_byte (abfd, ieee_load_constant_bytes_enum);
      ieee_write_byte (abfd, 1);
      ieee_write_byte (abfd, 0);
d2286 2
d2290 1
a2290 1
static void
d2299 2
a2300 1
      do_as_repeat (abfd, s);
d2309 3
a2311 2
	      do_with_relocs (abfd, s);
	      return;
d2314 2
a2315 1
      do_as_repeat (abfd, s);
d2318 1
d3005 1
a3005 1
static void
d3022 1
a3022 7
#if 0
      /* There is no debug info, so we'll fake some up */
      CONST static char fake[] =
      {
	0xf8, 0xa, 0, 5, 't', 't', 't', 't', 't', 0, 2, 3,
	'1', '.', '1', 0x82, 1991 >> 8, 1991 & 0xff, 9, 20, 11, 07, 50};
      ieee->w.r.debug_information_part = 0;
d3024 8
d3033 3
a3035 34
      here;


      /*    bfd_write(fake, 1, sizeof(fake), abfd);*/
      /* Now write a header for each section */
      {
	int i = 0;
	asection *s = abfd->sections;
	while (s)
	  {
	    if (s != abfd->abs_section)
	      {

		ieee_write_byte (abfd, 0xf8);
		ieee_write_byte (abfd, 0x0b);
		ieee_write_byte (abfd, 0);
		ieee_write_byte (abfd, 0);
		ieee_write_byte (abfd, 1);
		ieee_write_byte (abfd, i + IEEE_SECTION_NUMBER_BASE);
		ieee_write_expression (abfd, 0, s->symbol, 0, 0, 0);
		ieee_write_byte (abfd, 0);
		ieee_write_byte (abfd, 0xf9);
		ieee_write_expression (abfd, s->size,
				       bfd_abs_section_ptr->symbol, 0, 0, 0);
		i++;
	      }

	    s = s->next;

	  }
	/* Close the scope */
	ieee_write_byte (abfd, 0xf9);
      }
#endif
d3048 1
a3048 1
		abort ();
d3062 2
a3064 1
  flush ();
d3066 1
d3069 3
a3071 2
/* write the data in an ieee way */
static void
d3080 5
d3086 1
a3086 1
	   places */
d3089 2
a3090 1
	  do_with_relocs (abfd, s);
d3094 2
a3095 1
	  do_without_relocs (abfd, s);
d3098 2
d3110 2
d3116 1
a3116 4
	    {
	      bfd_set_error (bfd_error_no_memory);
	      return false;
	    }
d3135 14
d3160 6
a3165 7
/*
write the external symbols of a file, IEEE considers two sorts of
external symbols, public, and referenced. It uses to internal forms
to index them as well. When we write them out we turn their symbol
values into indexes from the right base.
*/
static void
d3186 4
a3189 3
	      ieee_write_byte (abfd, ieee_external_reference_enum);
	      ieee_write_int (abfd, reference_index);
	      ieee_write_id (abfd, p->name);
d3196 8
a3203 7
	      ieee_write_byte (abfd, ieee_external_reference_enum);
	      ieee_write_int (abfd, reference_index);
	      ieee_write_id (abfd, p->name);
	      ieee_write_byte (abfd, ieee_weak_external_reference_enum);
	      ieee_write_int (abfd, reference_index);
	      ieee_write_int (abfd, p->value);
	      ieee_write_int (abfd, BFD_FORT_COMM_DEFAULT_VALUE);
d3211 9
a3219 11

	      ieee_write_byte (abfd, ieee_external_symbol_enum);
	      ieee_write_int (abfd, public_index);
	      ieee_write_id (abfd, p->name);

	      ieee_write_twobyte (abfd, ieee_attribute_record_enum);
	      ieee_write_int (abfd, public_index);
	      ieee_write_byte (abfd, 15);	/* instruction address */
	      ieee_write_byte (abfd, 19);	/* static symbol */
	      ieee_write_byte (abfd, 1);	/* one of them */

d3222 3
a3224 2
	      ieee_write_2bytes (abfd, ieee_value_record_enum);
	      ieee_write_int (abfd, public_index);
d3230 7
a3236 4
		   relocated */
		      ieee_write_int (abfd,
				      p->value + p->section->output_offset + p->section->output_section->vma);

d3240 6
a3245 4
		      ieee_write_expression (abfd,
				       p->value + p->section->output_offset,
					  p->section->output_section->symbol
					     ,false, 0);
d3250 5
a3254 4
		  ieee_write_expression (abfd,
					 p->value,
					 bfd_abs_section_ptr->symbol,
					 false, 0);
d3269 1
d3294 1
a3294 2
static
void
d3302 5
a3306 5
      ieee->w.r.me_record = bfd_tell (abfd);
      ieee_write_2bytes (abfd, ieee_value_starting_address_enum);
      ieee_write_byte (abfd, ieee_function_either_open_b_enum);
      ieee_write_int (abfd, abfd->start_address);
      ieee_write_byte (abfd, ieee_function_either_close_b_enum);
d3308 16
a3323 1
  else
d3325 57
a3381 1
      ieee->w.r.me_record = bfd_tell (abfd);
a3382 1
  ieee_write_byte (abfd, ieee_module_end_enum);
d3384 1
d3394 1
a3397 1
  ieee_write_byte (abfd, ieee_module_beginning_enum);
d3399 4
a3402 2
  ieee_write_id (abfd, bfd_printable_name (abfd));
  ieee_write_id (abfd, abfd->filename);
d3405 2
a3406 1
  ieee_write_byte (abfd, ieee_address_descriptor_enum);
d3409 2
a3410 1
  ieee_write_byte (abfd, (bfd_byte) (bfd_arch_bits_per_byte (abfd)));
d3412 4
a3415 2
  ieee_write_byte (abfd,
		   (bfd_byte) (bfd_arch_bits_per_address (abfd) / bfd_arch_bits_per_byte (abfd)));
d3425 4
a3428 1
    ieee_write_byte (abfd, 0x1);/* Absolute */
d3430 4
a3433 1
    ieee_write_byte (abfd, 0x2);/* Relocateable */
d3438 21
d3460 1
d3463 7
a3469 6
  ieee_write_section_part (abfd);
  /*
    First write the symbols, this changes their values into table
    indeces so we cant use it after this point
    */
  ieee_write_external_part (abfd);
d3472 1
a3473 1
  /*  ieee_write_byte(abfd, ieee_record_seperator_enum);*/
d3475 3
d3479 5
a3483 17
  /*
    Write any debugs we have been told about
    */
  ieee_write_debug_part (abfd);

  /*
    Can only write the data once the symbols have been written since
    the data contains relocation information which points to the
    symbols
    */
  ieee_write_data_part (abfd);


  /*
    At the end we put the end !
    */
  ieee_write_me_part (abfd);
d3485 3
d3495 4
a3498 3
      ieee_write_2bytes (abfd, ieee_assign_value_to_variable_enum);
      ieee_write_byte (abfd, (bfd_byte) i);
      ieee_write_int5_out (abfd, ieee->w.offset[i]);
d3500 1
a3503 2


d3507 2
a3508 2
function exits.  We read the strings into a buffer large enough to
hold them all plus all the cached symbol entries. */
a3513 1

d3515 1
a3515 1
  (ieee_symbol_type *) bfd_zmalloc (sizeof (ieee_symbol_type));
d3517 1
a3517 4
    {
      bfd_set_error (bfd_error_no_error);
      return NULL;
    }
d3584 2
d3591 2
a3592 1
  else
d3594 5
a3598 3
      buf->st_size = 0x1;
      buf->st_mode = 0666;
      return !ieee_object_p (abfd);
d3600 6
d3662 1
a3662 4
      {
	bfd_set_error (bfd_error_no_memory);
	abort ();		/* FIXME */
      }
d3696 1
d3723 2
a3724 2
  true,				/* target byte order */
  true,				/* target headers byte order */
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d32 3
a34 21

static boolean ieee_write_byte PARAMS ((bfd *, int));
static boolean ieee_write_2bytes PARAMS ((bfd *, int));
static boolean ieee_write_int PARAMS ((bfd *, bfd_vma));
static boolean ieee_write_id PARAMS ((bfd *, const char *));
static boolean ieee_write_expression
  PARAMS ((bfd *, bfd_vma, asymbol *, boolean, unsigned int));
static void ieee_write_int5 PARAMS ((bfd_byte *, bfd_vma));
static boolean ieee_write_int5_out PARAMS ((bfd *, bfd_vma));
static boolean ieee_write_section_part PARAMS ((bfd *));
static boolean do_with_relocs PARAMS ((bfd *, asection *));
static boolean do_as_repeat PARAMS ((bfd *, asection *));
static boolean do_without_relocs PARAMS ((bfd *, asection *));
static boolean ieee_write_external_part PARAMS ((bfd *));
static boolean ieee_write_data_part PARAMS ((bfd *));
static boolean ieee_write_debug_part PARAMS ((bfd *));
static boolean ieee_write_me_part PARAMS ((bfd *));
static boolean ieee_write_processor PARAMS ((bfd *));

static boolean ieee_slurp_debug PARAMS ((bfd *));
static boolean ieee_slurp_section_data PARAMS ((bfd *));
d39 2
a40 2
static boolean
ieee_write_byte (abfd, barg)
d42 1
a42 1
     int barg;
d44 3
a46 1
  bfd_byte byte;
d48 10
a57 4
  byte = barg;
  if (bfd_write ((PTR) &byte, 1, 1, abfd) != 1)
    return false;
  return true;
d60 1
a60 1
static boolean
a65 1

d68 1
d70 1
a70 2
    return false;
  return true;
d73 1
a73 1
static boolean
d78 1
a78 1
  if (value <= 127)
d80 1
a80 2
      if (! ieee_write_byte (abfd, (bfd_byte) value))
	return false;
a84 1

d88 3
a90 1
	length = 4;
d92 3
a94 1
	length = 3;
d96 3
a98 1
	length = 2;
d102 2
a103 4
      if (! ieee_write_byte (abfd,
			     (bfd_byte) ((int) ieee_number_repeat_start_enum
					 + length)))
	return false;
d107 1
a107 3
	  if (! ieee_write_byte (abfd, (bfd_byte) (value >> 24)))
	    return false;
	  /* Fall through.  */
d109 1
a109 3
	  if (! ieee_write_byte (abfd, (bfd_byte) (value >> 16)))
	    return false;
	  /* Fall through.  */
d111 1
a111 3
	  if (! ieee_write_byte (abfd, (bfd_byte) (value >> 8)))
	    return false;
	  /* Fall through.  */
d113 1
a113 2
	  if (! ieee_write_byte (abfd, (bfd_byte) (value)))
	    return false;
a115 2

  return true;
d118 1
a118 1
static boolean
d121 1
a121 1
     const char *id;
a123 1

d126 1
a126 2
      if (! ieee_write_byte (abfd, (bfd_byte) length))
	return false;
d130 2
a131 3
      if (! ieee_write_byte (abfd, ieee_extension_length_1_enum)
	  || ! ieee_write_byte (abfd, (bfd_byte) length))
	return false;
d135 3
a137 3
      if (! ieee_write_byte (abfd, ieee_extension_length_2_enum)
	  || ! ieee_write_2bytes (abfd, (int) length))
	return false;
d141 1
a141 5
      (*_bfd_error_handler)
	("%s: string too long (%d chars, max 65535)",
	 bfd_get_filename (abfd), length);
      bfd_set_error (bfd_error_invalid_operation);
      return false;
a142 1

d144 1
a144 2
    return false;
  return true;
d147 1
d204 4
a207 1
    return NULL;
d213 1
a213 1
static boolean
d225 1
a225 2
      if (! ieee_write_int (abfd, value))
	return false;
d233 2
a234 3
      if (! ieee_write_byte (abfd, ieee_variable_X_enum)
	  || ! ieee_write_int (abfd, symbol->value))
	return false;
d241 4
d247 2
a248 3
	  if (! ieee_write_byte (abfd, ieee_variable_I_enum)
	      || ! ieee_write_int (abfd, symbol->value))
	    return false;
d253 6
a258 7
	  /* This is a reference to a defined local symbol.  We can
	     easily do a local as a section+offset.  */
	  if (! ieee_write_byte (abfd, ieee_variable_R_enum)
	      || ! ieee_write_byte (abfd,
				    (bfd_byte) (symbol->section->index
						+ IEEE_SECTION_NUMBER_BASE)))
	    return false;
a259 6
	  if (symbol->value != 0)
	    {
	      if (! ieee_write_int (abfd, symbol->value))
		return false;
	      term_count++;
	    }
d263 1
a263 6
	  (*_bfd_error_handler)
	    ("%s: unrecognized symbol `%s' flags 0x%x",
	     bfd_get_filename (abfd), bfd_asymbol_name (symbol),
	     symbol->flags);
	  bfd_set_error (bfd_error_invalid_operation);
	  return false;
d270 3
a272 5
      if (! ieee_write_byte (abfd, ieee_variable_P_enum)
	  || ! ieee_write_byte (abfd,
				(bfd_byte) (index + IEEE_SECTION_NUMBER_BASE))
	  || ! ieee_write_byte (abfd, ieee_function_minus_enum))
	return false;
d275 1
a275 2
  /* Handle the degenerate case of a 0 address.  */
  if (term_count == 0)
d277 1
a277 2
      if (! ieee_write_int (abfd, 0))
	return false;
d279 1
a279 2

  while (term_count > 1)
d281 5
a285 3
      if (! ieee_write_byte (abfd, ieee_function_plus_enum))
	return false;
      term_count--;
a286 2

  return true;
d289 1
d307 1
a307 1
static boolean
a312 1

d315 1
a315 2
    return false;
  return true;
d374 23
a396 9
#if KEEPMINUSPCININST

#define SRC_MASK(arg) arg
#define PCREL_OFFSET false

#else

#define SRC_MASK(arg) 0
#define PCREL_OFFSET true
a397 1
#endif
d399 2
a400 89
static reloc_howto_type abs32_howto =
  HOWTO (1,
	 0,
	 2,
	 32,
	 false,
	 0,
	 complain_overflow_bitfield,
	 0,
	 "abs32",
	 true,
	 0xffffffff,
	 0xffffffff,
	 false);

static reloc_howto_type abs16_howto =
  HOWTO (1,
	 0,
	 1,
	 16,
	 false,
	 0,
	 complain_overflow_bitfield,
	 0,
	 "abs16",
	 true,
	 0x0000ffff,
	 0x0000ffff,
	 false);

static reloc_howto_type abs8_howto =
  HOWTO (1,
	 0,
	 0,
	 8,
	 false,
	 0,
	 complain_overflow_bitfield,
	 0,
	 "abs8",
	 true,
	 0x000000ff,
	 0x000000ff,
	 false);

static reloc_howto_type rel32_howto =
  HOWTO (1,
	 0,
	 2,
	 32,
	 true,
	 0,
	 complain_overflow_signed,
	 0,
	 "rel32",
	 true,
	 SRC_MASK (0xffffffff),
	 0xffffffff,
	 PCREL_OFFSET);

static reloc_howto_type rel16_howto =
  HOWTO (1,
	 0,
	 1,
	 16,
	 true,
	 0,
	 complain_overflow_signed,
	 0,
	 "rel16",
	 true,
	 SRC_MASK (0x0000ffff),
	 0x0000ffff,
	 PCREL_OFFSET);

static reloc_howto_type rel8_howto =
  HOWTO (1,
	 0,
	 0,
	 8,
	 true,
	 0,
	 complain_overflow_signed,
	 0,
	 "rel8",
	 true,
	 SRC_MASK (0x000000ff),
	 0x000000ff,
	 PCREL_OFFSET);
a401 1
static ieee_symbol_index_type NOSYMBOL = {0, 0};
d438 3
a440 1
	    PUSH (NOSYMBOL, bfd_abs_section_ptr, 0);
a461 10
	  /* Push the address of variable n */
	  {
	    ieee_symbol_index_type sy;
	    next_byte (&(ieee->h));
	    sy.index = (int) must_parse_int (&(ieee->h));
	    sy.letter = 'I';

	    PUSH (sy, bfd_abs_section_ptr, 0);
	  }
	  break;
d482 1
a482 1
	    PUSH (sy, section1 ? section1 : section_dummy, value2 - value1);
d577 4
a580 1
	return NULL;
a591 1
      new_symbol->symbol.section = bfd_abs_section_ptr;
d623 1
a623 1
			       &ieee->external_symbol_max_index, 'I');
d654 6
a659 1
	    switch (read_2bytes (ieee))
d661 5
a665 23
	      case ieee_attribute_record_enum:
		symbol_name_index = must_parse_int (&(ieee->h));
		symbol_type_index = must_parse_int (&(ieee->h));
		symbol_attribute_def = must_parse_int (&(ieee->h));
		switch (symbol_attribute_def)
		  {
		  case 8:
		  case 19:
		    parse_int (&ieee->h, &value);
		    break;
		  default:
		    (*_bfd_error_handler)
		      ("%s: unimplemented ATI record  %u for symbol %u",
		       bfd_get_filename (abfd), symbol_attribute_def,
		       symbol_name_index);
		    bfd_set_error (bfd_error_bad_value);
		    return false;
		    break;
		  }
		break;
	      case ieee_external_reference_info_record_enum:
		/* Skip over ATX record. */
		parse_int (&(ieee->h), &value);
d668 3
d879 4
a882 1
	return NULL;
a920 4

		/* Set minimal section attributes. Attributes are
		   extended later, based on section contents. */

d926 1
a926 1
		    section->flags = SEC_ALLOC;
d937 1
a937 1
			    section->flags |= SEC_CODE;
d940 2
a942 2
			    next_byte (&(ieee->h));
			    section->flags |= SEC_DATA;
d947 1
a947 1
			    section->flags |= SEC_ROM | SEC_DATA;
d956 1
a956 1
		    section->flags = SEC_ALLOC;
d961 1
a961 1
			section->flags |= SEC_CODE;
d965 1
a965 1
			section->flags |= SEC_DATA;
d969 1
a969 1
			section->flags |= SEC_ROM | SEC_DATA;
a1023 1
		    section->lma = section->vma;
a1035 1
		    section->lma = section->vma;
d1052 1
a1053 25
/* Make a section for the debugging information, if any.  We don't try
   to interpret the debugging information; we just point the section
   at the area in the file so that program which understand can dig it
   out.  */

static boolean
ieee_slurp_debug (abfd)
     bfd *abfd;
{
  ieee_data_type *ieee = IEEE_DATA (abfd);
  asection *sec;

  if (ieee->w.r.debug_information_part == 0)
    return true;

  sec = bfd_make_section (abfd, ".debug");
  if (sec == NULL)
    return false;
  sec->flags |= SEC_DEBUGGING | SEC_HAS_CONTENTS;
  sec->filepos = ieee->w.r.debug_information_part;
  sec->_raw_size = ieee->w.r.data_part - ieee->w.r.debug_information_part;

  return true;
}

d1064 1
d1067 1
d1073 4
a1076 1
    return NULL;
d1104 8
d1133 1
a1133 1
	  bfd_alloc_grow (abfd, (PTR) &t, sizeof t);
d1154 1
a1154 1
  ieee->elements = (ieee_ar_obstack_type *) bfd_alloc_finish (abfd);
d1156 4
a1159 1
    return (const bfd_target *) NULL;
d1291 5
d1297 2
a1298 10
  if (ieee->w.r.external_part != 0)
    abfd->flags = HAS_SYMS;

  /* By now we know that this is a real IEEE file, we're going to read
     the whole thing into memory so that we can run up and down it
     quickly.  We can work out how big the file is from the trailer
     record */

  IEEE_DATA (abfd)->h.first_byte =
    (unsigned char *) bfd_alloc (ieee->h.abfd, ieee->w.r.me_record + 1);
d1300 4
a1303 1
    goto fail;
d1308 1
a1308 2
  bfd_read ((PTR) (IEEE_DATA (abfd)->h.first_byte), 1,
	    ieee->w.r.me_record + 1, abfd);
a1310 10

  if (! ieee_slurp_debug (abfd))
    goto fail;

  /* Parse section data to activate file and section flags implied by
     section contents. */

  if (! ieee_slurp_section_data (abfd))
    goto fail;
    
d1356 2
a1357 4
	const char *section_name =
	  (symbol->section == (asection *) NULL
	   ? "*abs"
	   : symbol->section->name);
d1369 3
a1371 1
		     (unsigned) 0,
d1380 1
a1380 1
do_one (ieee, current_map, location_ptr, s, iterations)
a1384 1
     int iterations;
d1424 4
a1427 1
		    return false;
a1439 2
		  s->flags |= SEC_RELOC;
		  s->owner->flags |= HAS_RELOC;
d1469 1
a1469 1
		     and take out of reloc ..
d1471 4
a1474 2
		     I've changed this. It's all too complicated. I
		     keep 0 in the instruction now.  */
d1546 1
a1546 1
		      return false;
a1567 5

	    /* Prevent more than the first load-item of an LR record
	       from being repeated (MRI convention). */
	    if (iterations != 1)
	      loop = false;
a1595 2
      if ((s->flags & SEC_DEBUGGING) != 0)
	continue;
d1598 4
a1601 1
	return false;
a1618 1
	  s->flags |= SEC_LOAD | SEC_HAS_CONTENTS;
d1653 1
a1653 1
	      return false;
d1686 1
a1686 2
		    if (!do_one (ieee, current_map, location_ptr, s,
				 iterations))
d1696 1
a1696 1
	    if (!do_one (ieee, current_map, location_ptr, s, 1))
d1711 4
a1714 1
    return false;
a1724 2
  if ((asect->flags & SEC_DEBUGGING) != 0)
    return 0;
a1738 3
  if ((section->flags & SEC_DEBUGGING) != 0)
    return _bfd_generic_get_section_contents (abfd, section, location,
					      offset, count);
a1754 3
  if ((section->flags & SEC_DEBUGGING) != 0)
    return 0;

a1759 4
	case 'I':
	  src->relent.sym_ptr_ptr =
	    symbols + src->symbol.index + ieee->external_symbol_base_offset;
	  break;
d1789 3
a1791 1
/* Write the section headers.  */
d1793 1
a1793 1
static boolean
d1802 1
a1802 2
      if (! bfd_is_abs_section (s)
	  && (s->flags & SEC_DEBUGGING) == 0)
d1804 2
a1805 5
	  if (! ieee_write_byte (abfd, ieee_section_type_enum)
	      || ! ieee_write_byte (abfd,
				    (bfd_byte) (s->index
						+ IEEE_SECTION_NUMBER_BASE)))
	    return false;
d1810 2
a1811 3
	      if (! ieee_write_byte (abfd, ieee_variable_A_enum)
		  || ! ieee_write_byte (abfd, ieee_variable_S_enum))
		return false;
d1815 1
a1815 2
	      if (! ieee_write_byte (abfd, ieee_variable_C_enum))
		return false;
d1822 1
a1822 2
	      if (! ieee_write_byte (abfd, ieee_variable_P_enum))
		return false;
d1826 1
a1826 2
	      if (! ieee_write_byte (abfd, ieee_variable_D_enum))
		return false;
d1832 2
a1833 2
	      if (! ieee_write_byte (abfd, ieee_variable_R_enum))
		return false;
d1837 1
a1837 2
	  if (! ieee_write_id (abfd, s->name))
	    return false;
d1844 3
a1846 6
	  if (! ieee_write_byte (abfd, ieee_section_alignment_enum)
	      || ! ieee_write_byte (abfd,
				    (bfd_byte) (s->index
						+ IEEE_SECTION_NUMBER_BASE))
	      || ! ieee_write_int (abfd, 1 << s->alignment_power))
	    return false;
d1849 3
a1851 6
	  if (! ieee_write_2bytes (abfd, ieee_section_size_enum)
	      || ! ieee_write_byte (abfd,
				    (bfd_byte) (s->index
						+ IEEE_SECTION_NUMBER_BASE))
	      || ! ieee_write_int (abfd, s->_raw_size))
	    return false;
d1856 4
a1859 7
	      if (! ieee_write_2bytes (abfd, ieee_section_base_address_enum)
		  || ! ieee_write_byte (abfd,
					((bfd_byte)
					 (s->index
					  + IEEE_SECTION_NUMBER_BASE)))
		  || ! ieee_write_int (abfd, s->vma))
		return false;
d1862 1
a1863 2

  return true;
a1871 2
  unsigned int number_of_maus_in_address =
    bfd_arch_bits_per_address (abfd) / bfd_arch_bits_per_byte (abfd);
d1873 1
d1876 1
d1885 6
a1890 17
  if (! ieee_write_byte (abfd, ieee_set_current_section_enum)
      || ! ieee_write_byte (abfd,
			    (bfd_byte) (s->index + IEEE_SECTION_NUMBER_BASE))
      || ! ieee_write_2bytes (abfd, ieee_set_current_pc_enum)
      || ! ieee_write_byte (abfd,
			    (bfd_byte) (s->index + IEEE_SECTION_NUMBER_BASE)))
    return false;
  if ((abfd->flags & EXEC_P) != 0 && relocs_to_go == 0)
    {
      if (! ieee_write_int (abfd, s->vma))
	return false;
    }
  else
    {
      if (! ieee_write_expression (abfd, 0, s->symbol, 0, 0))
	return false;
    }
d1894 2
a1895 2
      /* If there aren't any relocations then output the load constant
	 byte opcode rather than the load with relocation opcode */
d1900 1
a1900 1
	  unsigned int MAXRUN = 127;
d1909 1
a1909 2
	      if (! ieee_write_byte (abfd, ieee_load_constant_bytes_enum))
		return false;
d1911 1
a1911 2
	      if (! ieee_write_int (abfd, run))
		return false;
d1924 2
a1925 2
      if (! ieee_write_byte (abfd, ieee_load_with_relocation_enum))
	return false;
d1928 2
a1929 2
	 possible, allowing for the a reasonable packet size and
	 relocation stuffs.  */
d1936 4
a1939 1
	    return false;
d1945 1
a1945 1
	  unsigned int MAXRUN = 127;
a1948 2
	      if (run > MAXRUN)
		run = MAXRUN;
d1962 1
a1962 2
	      if (! ieee_write_int (abfd, run))
		return false;
d1974 1
a1974 2
	      while (relocs_to_go
		     && (*p) && (*p)->address == current_byte_index)
d1976 1
d1978 1
a1978 1
		  bfd_signed_vma ov;
d1991 2
a1992 2
		      ov = bfd_get_signed_32 (abfd,
					      stream + current_byte_index);
d1996 2
a1997 2
		      ov = bfd_get_signed_16 (abfd,
					      stream + current_byte_index);
d2001 2
a2002 2
		      ov = bfd_get_signed_8 (abfd,
					     stream + current_byte_index);
a2007 1
		      return false;
d2009 2
a2010 12

		  ov &= r->howto->src_mask;

		  if (r->howto->pc_relative
		      && ! r->howto->pcrel_offset)
		    ov += r->address;

		  if (! ieee_write_byte (abfd,
					 ieee_function_either_open_b_enum))
		    return false;

/*		  abort();*/
d2014 3
a2016 5
		      if (! ieee_write_expression (abfd, r->addend + ov,
						   *(r->sym_ptr_ptr),
						   r->howto->pc_relative,
						   s->index))
			return false;
d2020 3
a2022 5
		      if (! ieee_write_expression (abfd, r->addend + ov,
						   (asymbol *) NULL,
						   r->howto->pc_relative,
						   s->index))
			return false;
d2025 1
a2025 2
		  if (number_of_maus_in_address
		      != bfd_get_reloc_size (r->howto))
d2027 2
a2028 3
		      if (! ieee_write_int (abfd,
					    bfd_get_reloc_size (r->howto)))
			return false;
d2030 2
a2031 3
		  if (! ieee_write_byte (abfd,
					 ieee_function_either_close_b_enum))
		    return false;
a2039 1

d2043 3
a2045 3
/* If there are no relocations in the output section then we can be
   clever about how we write.  We block items up into a max of 127
   bytes.  */
d2047 1
a2047 1
static boolean
d2054 12
a2065 16
      if (! ieee_write_byte (abfd, ieee_set_current_section_enum)
	  || ! ieee_write_byte (abfd,
				(bfd_byte) (s->index
					    + IEEE_SECTION_NUMBER_BASE))
	  || ! ieee_write_byte (abfd, ieee_set_current_pc_enum >> 8)
	  || ! ieee_write_byte (abfd, ieee_set_current_pc_enum & 0xff)
	  || ! ieee_write_byte (abfd,
				(bfd_byte) (s->index
					    + IEEE_SECTION_NUMBER_BASE))
	  || ! ieee_write_int (abfd, s->vma)
	  || ! ieee_write_byte (abfd, ieee_repeat_data_enum)
	  || ! ieee_write_int (abfd, s->_raw_size)
	  || ! ieee_write_byte (abfd, ieee_load_constant_bytes_enum)
	  || ! ieee_write_byte (abfd, 1)
	  || ! ieee_write_byte (abfd, 0))
	return false;
a2066 2

  return true;
d2069 1
a2069 1
static boolean
d2078 1
a2078 2
      if (! do_as_repeat (abfd, s))
	return false;
d2087 2
a2088 3
	      if (! do_with_relocs (abfd, s))
		return false;
	      return true;
d2091 1
a2091 2
      if (! do_as_repeat (abfd, s))
	return false;
a2093 1
  return true;
d2780 1
a2780 1
static boolean
d2797 21
a2817 1
      asection *s;
d2819 15
a2833 8
      for (s = abfd->sections; s != NULL; s = s->next)
	if ((s->flags & SEC_DEBUGGING) != 0)
	  break;
      if (s == NULL)
	{
	  ieee->w.r.debug_information_part = 0;
	  return true;
	}
d2835 5
a2839 3
      ieee->w.r.debug_information_part = here;
      if (bfd_write (s->contents, 1, s->_raw_size, abfd) != s->_raw_size)
	return false;
d2852 1
a2852 1
		return false;
a2865 2

      flush ();
d2867 1
a2868 1
  return true;
d2871 2
a2872 3
/* Write the data in an ieee way.  */

static boolean
a2880 5
      /* Skip sections that have no loadable contents (.bss,
         debugging, etc.)  */
      if ((s->flags & SEC_LOAD) == 0)
	continue;

d2882 1
a2882 1
	 places */
d2885 1
a2885 2
	  if (! do_with_relocs (abfd, s))
	    return false;
d2889 1
a2889 2
	  if (! do_without_relocs (abfd, s))
	    return false;
a2891 2

  return true;
a2901 2
      if ((s->flags & SEC_DEBUGGING) != 0)
	continue;
d2906 4
a2909 1
	    return false;
a2927 14
  if ((section->flags & SEC_DEBUGGING) != 0)
    {
      if (section->contents == NULL)
	{
	  section->contents = bfd_alloc (abfd, section->_raw_size);
	  if (section->contents == NULL)
	    return false;
	}
      /* bfd_set_section_contents has already checked that everything
         is within range.  */
      memcpy (section->contents + offset, location, count);
      return true;
    }

d2939 7
a2945 6
/* Write the external symbols of a file.  IEEE considers two sorts of
   external symbols, public, and referenced.  It uses to internal
   forms to index them as well.  When we write them out we turn their
   symbol values into indexes from the right base.  */

static boolean
d2966 3
a2968 4
	      if (! ieee_write_byte (abfd, ieee_external_reference_enum)
		  || ! ieee_write_int (abfd, reference_index)
		  || ! ieee_write_id (abfd, p->name))
		return false;
d2975 7
a2981 8
	      if (! ieee_write_byte (abfd, ieee_external_reference_enum)
		  || ! ieee_write_int (abfd, reference_index)
		  || ! ieee_write_id (abfd, p->name)
		  || ! ieee_write_byte (abfd,
					ieee_weak_external_reference_enum)
		  || ! ieee_write_int (abfd, reference_index)
		  || ! ieee_write_int (abfd, p->value))
		return false;
d2989 11
a2999 9
	      if (! ieee_write_byte (abfd, ieee_external_symbol_enum)
		  || ! ieee_write_int (abfd, public_index)
		  || ! ieee_write_id (abfd, p->name)
		  || ! ieee_write_2bytes (abfd, ieee_attribute_record_enum)
		  || ! ieee_write_int (abfd, public_index)
		  || ! ieee_write_byte (abfd, 15) /* instruction address */
		  || ! ieee_write_byte (abfd, 19) /* static symbol */
		  || ! ieee_write_byte (abfd, 1)) /* one of them */
		return false;
d3002 2
a3003 3
	      if (! ieee_write_2bytes (abfd, ieee_value_record_enum)
		  || ! ieee_write_int (abfd, public_index))
		return false;
d3009 4
a3012 7
			 relocated */
		      if (! (ieee_write_int
			     (abfd,
			      (p->value
			       + p->section->output_offset
			       + p->section->output_section->vma))))
			return false;
d3016 4
a3019 6
		      if (! (ieee_write_expression
			     (abfd,
			      p->value + p->section->output_offset,
			      p->section->output_section->symbol,
			      false, 0)))
			return false;
d3024 4
a3027 5
		  if (! ieee_write_expression (abfd,
					       p->value,
					       bfd_abs_section_ptr->symbol,
					       false, 0))
		    return false;
a3041 1
  return true;
d3066 2
a3067 1
static boolean
d3075 5
a3079 5
      if (! ieee_write_2bytes (abfd, ieee_value_starting_address_enum)
	  || ! ieee_write_byte (abfd, ieee_function_either_open_b_enum)
	  || ! ieee_write_int (abfd, abfd->start_address)
	  || ! ieee_write_byte (abfd, ieee_function_either_close_b_enum))
	return false;
d3081 1
a3081 16
  ieee->w.r.me_record = bfd_tell (abfd);
  if (! ieee_write_byte (abfd, ieee_module_end_enum))
    return false;
  return true;
}

/* Write out the IEEE processor ID.  */

static boolean
ieee_write_processor (abfd)
     bfd *abfd;
{
  const bfd_arch_info_type *arch;

  arch = bfd_get_arch_info (abfd);
  switch (arch->arch)
d3083 1
a3083 57
    default:
      if (! ieee_write_id (abfd, bfd_printable_name (abfd)))
	return false;
      break;

    case bfd_arch_a29k:
      if (! ieee_write_id (abfd, "29000"))
	return false;
      break;

    case bfd_arch_h8300:
      if (! ieee_write_id (abfd, "H8/300"))
	return false;
      break;

    case bfd_arch_h8500:
      if (! ieee_write_id (abfd, "H8/500"))
	return false;
      break;

    case bfd_arch_i960:
      switch (arch->mach)
	{
	default:
	case bfd_mach_i960_core:
	case bfd_mach_i960_ka_sa:
	  if (! ieee_write_id (abfd, "80960KA"))
	    return false;
	  break;

	case bfd_mach_i960_kb_sb:
	  if (! ieee_write_id (abfd, "80960KB"))
	    return false;
	  break;

	case bfd_mach_i960_ca:
	  if (! ieee_write_id (abfd, "80960CA"))
	    return false;
	  break;

	case bfd_mach_i960_mc:
	case bfd_mach_i960_xa:
	  if (! ieee_write_id (abfd, "80960MC"))
	    return false;
	  break;
	}
      break;

    case bfd_arch_m68k:
      {
	char ab[20];

	sprintf (ab, "%lu", arch->mach);
	if (! ieee_write_id (abfd, ab))
	  return false;
      }
      break;
d3085 1
a3086 1
  return true;
a3095 1

d3099 1
d3101 2
a3102 4
  if (! ieee_write_byte (abfd, ieee_module_beginning_enum)
      || ! ieee_write_processor (abfd)
      || ! ieee_write_id (abfd, abfd->filename))
    return false;
d3105 1
a3105 2
  if (! ieee_write_byte (abfd, ieee_address_descriptor_enum))
    return false;
d3108 1
a3108 2
  if (! ieee_write_byte (abfd, (bfd_byte) (bfd_arch_bits_per_byte (abfd))))
    return false;
d3110 2
a3111 4
  if (! ieee_write_byte (abfd,
			 (bfd_byte) (bfd_arch_bits_per_address (abfd)
				     / bfd_arch_bits_per_byte (abfd))))
    return false;
d3121 1
a3121 4
    {
      if (! ieee_write_byte (abfd, 0x1)) /* Absolute */
	return false;
    }
d3123 1
a3123 4
    {
      if (! ieee_write_byte (abfd, 0x2)) /* Relocateable */
	return false;
    }
a3127 21

  /* The HP emulator database requires a timestamp in the file.  */
  {
    time_t now;
    const struct tm *t;

    time (&now);
    t = (struct tm *) localtime (&now);
    if (! ieee_write_2bytes (abfd, (int) ieee_atn_record_enum)
	|| ! ieee_write_byte (abfd, 0x21)
	|| ! ieee_write_byte (abfd, 0)
	|| ! ieee_write_byte (abfd, 50)
	|| ! ieee_write_int (abfd, t->tm_year + 1900)
	|| ! ieee_write_int (abfd, t->tm_mon + 1)
	|| ! ieee_write_int (abfd, t->tm_mday)
	|| ! ieee_write_int (abfd, t->tm_hour)
	|| ! ieee_write_int (abfd, t->tm_min)
	|| ! ieee_write_int (abfd, t->tm_sec))
      return false;
  }

a3128 1

d3131 7
a3137 6
  if (! ieee_write_section_part (abfd))
    return false;
  /* First write the symbols.  This changes their values into table
    indeces so we cant use it after this point.  */
  if (! ieee_write_external_part (abfd))
    return false;
a3138 1
  /*  ieee_write_byte(abfd, ieee_record_seperator_enum);*/
d3143 17
a3159 9
  /* Write any debugs we have been told about.  */
  if (! ieee_write_debug_part (abfd))
    return false;

  /* Can only write the data once the symbols have been written, since
     the data contains relocation information which points to the
     symbols.  */
  if (! ieee_write_data_part (abfd))
    return false;
a3160 3
  /* At the end we put the end!  */
  if (! ieee_write_me_part (abfd))
    return false;
d3168 3
a3170 4
      if (! ieee_write_2bytes (abfd, ieee_assign_value_to_variable_enum)
	  || ! ieee_write_byte (abfd, (bfd_byte) i)
	  || ! ieee_write_int5_out (abfd, ieee->w.offset[i]))
	return false;
a3171 1

d3175 2
d3180 2
a3181 2
   function exits.  We read the strings into a buffer large enough to
   hold them all plus all the cached symbol entries. */
d3187 1
d3189 1
a3189 1
    (ieee_symbol_type *) bfd_zmalloc (sizeof (ieee_symbol_type));
d3191 4
a3194 1
    return NULL;
a3260 2
  ieee_data_type *ieee;

d3266 1
a3266 2

  if (IEEE_DATA (abfd) == NULL)
d3268 3
a3270 5
      if (ieee_object_p (abfd) == NULL)
	{
	  bfd_set_error (bfd_error_wrong_format);
	  return -1;
	}
a3271 6

  ieee = IEEE_DATA (abfd);

  buf->st_size = ieee->w.r.me_record + 1;
  buf->st_mode = 0644;
  return 0;
d3328 4
a3331 1
      abort ();		/* FIXME */
a3364 1
#define ieee_get_elt_at_index _bfd_generic_get_elt_at_index
d3391 2
a3392 2
  BFD_ENDIAN_UNKNOWN,		/* target byte order */
  BFD_ENDIAN_UNKNOWN,		/* target headers byte order */
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a1003 23
  if (index >= ieee->section_table_size)
    {
      unsigned int c, i;
      asection **n;

      c = ieee->section_table_size;
      if (c == 0)
	c = 20;
      while (c <= index)
	c *= 2;

      n = ((asection **)
	   bfd_realloc (ieee->section_table, c * sizeof (asection *)));
      if (n == NULL)
	return NULL;

      for (i = ieee->section_table_size; i < c; i++)
	n[i] = NULL;

      ieee->section_table = n;
      ieee->section_table_size = c;
    }

d1043 2
d1375 1
a1375 2
  ieee->section_table = NULL;
  ieee->section_table_size = 0;
d3139 1
a3139 2
	  section->contents = ((unsigned char *)
			       bfd_alloc (abfd, section->_raw_size));
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d2062 1
a2062 1
		  || ! ieee_write_int (abfd, s->lma))
d2099 1
a2099 1
      if (! ieee_write_int (abfd, s->lma))
d2300 1
a2300 1
	  || ! ieee_write_int (abfd, s->lma)
d2520 1
a2520 1
		value = s->output_section->lma;
d3205 1
a3214 1
	      hadone = true;
a3228 1
	      hadone = true;
a3280 1
	      hadone = true;
d3753 1
a3753 1
  '_',				/* leading underscore */
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 3
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 1997
   Free Software Foundation, Inc.

d1242 1
d1248 1
a1248 5
  unsigned int alc_elts;
  ieee_ar_obstack_type *elts = NULL;

  abfd->tdata.ieee_ar_data =
    (ieee_ar_data_type *) bfd_alloc (abfd, sizeof (ieee_ar_data_type));
d1250 1
a1250 1
    goto error_return;
d1265 1
a1265 1
      goto error_return;
d1274 1
a1274 1
      goto error_return;
d1286 1
a1286 5
  alc_elts = 10;
  elts = (ieee_ar_obstack_type *) bfd_malloc (alc_elts * sizeof *elts);
  if (elts == NULL)
    goto error_return;

d1288 1
a1288 1
  while (1)
d1290 25
a1314 39
      int rec;
      ieee_ar_obstack_type *t;

      rec = read_2bytes (&(ieee->h));
      if (rec != (int) ieee_assign_value_to_variable_enum)
	break;

      if (ieee->element_count >= alc_elts)
	{
	  ieee_ar_obstack_type *n;

	  alc_elts *= 2;
	  n = ((ieee_ar_obstack_type *)
	       bfd_realloc (elts, alc_elts * sizeof *elts));
	  if (n == NULL)
	    goto error_return;
	  elts = n;
	}

      t = &elts[ieee->element_count];
      ieee->element_count++;

      must_parse_int (&(ieee->h));
      t->file_offset = must_parse_int (&(ieee->h));
      t->abfd = (bfd *) NULL;

      /* Make sure that we don't go over the end of the buffer */

      if ((size_t) ieee_pos (abfd) > sizeof (buffer) / 2)
	{
	  /* Past half way, reseek and reprime */
	  buffer_offset += ieee_pos (abfd);
	  if (bfd_seek (abfd, buffer_offset, SEEK_SET) != 0)
	    goto error_return;
	  /* FIXME: Check return value.  I'm not sure whether it needs
	     to read the entire buffer or not.  */
	  bfd_read ((PTR) buffer, 1, sizeof (buffer), abfd);
	  ieee->h.first_byte = buffer;
	  ieee->h.input_p = buffer;
d1316 2
d1320 3
a1322 9
  ieee->elements = ((ieee_ar_obstack_type *)
		    bfd_alloc (abfd,
			       ieee->element_count * sizeof *ieee->elements));
  if (ieee->elements == NULL)
    goto error_return;
  memcpy (ieee->elements, elts,
	  ieee->element_count * sizeof *ieee->elements);
  free (elts);
  elts = NULL;
d1330 1
a1330 1
	goto error_return;
d1351 1
a1351 2
  /*  abfd->has_armap = ;*/

a1352 5

 error_return:
  if (elts != NULL)
    free (elts);
  return NULL;
a1826 4
	      next_byte (&(ieee->h));
	      if (this_byte (&(ieee->h)) == ieee_function_either_open_b_enum)
		next_byte (&(ieee->h));
	      abfd->start_address = must_parse_int (&(ieee->h));
d3723 1
a3723 1
#define ieee_bfd_is_local_label_name bfd_generic_is_local_label_name
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
a34 2
#include <ctype.h>

d165 1
a165 1
	(_("%s: string too long (%d chars, max 65535)"),
d295 1
a295 1
	    (_("%s: unrecognized symbol `%s' flags 0x%x"),
d686 1
a686 1
     bfd *abfd ATTRIBUTE_UNUSED;
d791 1
a791 1
		      (_("%s: unimplemented ATI record  %u for symbol %u"),
a805 38
	      case ieee_atn_record_enum:
		/* We may get call optimization information here,
		   which we just ignore.  The format is
		   {$F1}${CE}{index}{$00}{$3F}{$3F}{#_of_ASNs} */
		parse_int (&ieee->h, &value);
		parse_int (&ieee->h, &value);
		parse_int (&ieee->h, &value);
		if (value != 0x3f)
		  {
		    (*_bfd_error_handler)
		      (_("%s: unexpected ATN type %d in external part"),
			 bfd_get_filename (abfd), (int) value);
		    bfd_set_error (bfd_error_bad_value);
		    return false;
		  }
		parse_int (&ieee->h, &value);
		parse_int (&ieee->h, &value);
		while (value > 0)
		  {
		    bfd_vma val1;

		    --value;

		    switch (read_2bytes (ieee))
		      {
		      case ieee_asn_record_enum:
			parse_int (&ieee->h, &val1);
			parse_int (&ieee->h, &val1);
			break;

		      default:
			(*_bfd_error_handler)
			  (_("%s: unexpected type after ATN"),
			     bfd_get_filename (abfd));
			bfd_set_error (bfd_error_bad_value);
			return false;
		      }
		  }
a825 22
	    /* Fully linked IEEE-695 files tend to give every symbol
               an absolute value.  Try to convert that back into a
               section relative value.  FIXME: This won't always to
               the right thing.  */
	    if (bfd_is_abs_section (symbol->symbol.section)
		&& (abfd->flags & HAS_RELOC) == 0)
	      {
		bfd_vma val;
		asection *s;

		val = symbol->symbol.value;
		for (s = abfd->sections; s != NULL; s = s->next)
		  {
		    if (val >= s->vma && val < s->vma + s->_raw_size)
		      {
			symbol->symbol.section = s;
			symbol->symbol.value -= s->vma;
			break;
		      }
		  }
	      }

d950 2
a951 11
  {
    &dummy_bfd,
    " ieee empty",
    (symvalue) 0,
    BSF_DEBUGGING,
    bfd_abs_section_ptr
#ifdef __STDC__
    /* K&R compilers can't initialise unions.  */
    , { 0 }
#endif
  };
a1220 1
  file_ptr debug_end;
d1230 1
a1230 7

  debug_end = ieee->w.r.data_part;
  if (debug_end == 0)
    debug_end = ieee->w.r.trailer_part;
  if (debug_end == 0)
    debug_end = ieee->w.r.me_record;
  sec->_raw_size = debug_end - ieee->w.r.debug_information_part;
d1270 1
a1270 1
      goto got_wrong_format_error;
d1279 1
a1279 1
      goto got_wrong_format_error;
a1381 2
 got_wrong_format_error:
  bfd_set_error (bfd_error_wrong_format);
d1443 1
a1443 64
    const bfd_arch_info_type *arch;
    char family[10];

    /* IEEE does not specify the format of the processor identificaton
       string, so the compiler is free to put in it whatever it wants.
       We try here to recognize different processors belonging to the
       m68k family.  Code for other processors can be added here.  */
    if ((processor[0] == '6') && (processor[1] == '8'))
      {
	if (processor[2] == '3')	    /* 683xx integrated processors */
	  {
	    switch (processor[3])
	      {
	      case '0':			    /* 68302, 68306, 68307 */
	      case '2':			    /* 68322, 68328 */
	      case '5':			    /* 68356 */
		strcpy (family, "68000");   /* MC68000-based controllers */
		break;

	      case '3':			    /* 68330, 68331, 68332, 68333,
					       68334, 68335, 68336, 68338 */
	      case '6':			    /* 68360 */
	      case '7':			    /* 68376 */
		strcpy (family, "68332");   /* CPU32 and CPU32+ */
		break;

	      case '4':
		if (processor[4] == '9')    /* 68349 */
		  strcpy (family, "68030"); /* CPU030 */
		else		            /* 68340, 68341 */
		  strcpy (family, "68332"); /* CPU32 and CPU32+ */
		break;

	      default:			    /* Does not exist yet */
		strcpy (family, "68332");   /* Guess it will be CPU32 */
	      }
	  }
	else if (toupper (processor[3]) == 'F')   /* 68F333 */
	  strcpy (family, "68332");	          /* CPU32 */
	else if ((toupper (processor[3]) == 'C')  /* Embedded controllers */
		 && ((toupper (processor[2]) == 'E')
		     || (toupper (processor[2]) == 'H')
		     || (toupper (processor[2]) == 'L')))
	  {
	    strcpy (family, "68");
	    strncat (family, processor + 4, 7);
	    family[9] = '\0';
	  }
	else				 /* "Regular" processors */
	  {
	    strncpy (family, processor, 9);
	    family[9] = '\0';
	  }
      }
    else if ((strncmp (processor, "cpu32", 5) == 0) /* CPU32 and CPU32+ */
	     || (strncmp (processor, "CPU32", 5) == 0))
      strcpy (family, "68332");
    else
      {
	strncpy (family, processor, 9);
	family[9] = '\0';
      }

    arch = bfd_scan_arch (family);
d1530 1
a1530 1
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d1543 1
a1543 1
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d1649 4
a1652 2
		  if (r->relent.sym_ptr_ptr == NULL && section != NULL)
		    r->relent.sym_ptr_ptr = section->symbol_ptr_ptr;
d1990 2
a1991 3
	  if (src->relent.sym_ptr_ptr != NULL)
	    src->relent.sym_ptr_ptr =
	      src->relent.sym_ptr_ptr[0]->section->symbol_ptr_ptr;
d3042 1
a3042 1
     bfd *output ATTRIBUTE_UNUSED;
d3437 1
a3437 1
	const char *id;
d3439 2
a3440 14
	switch (arch->mach)
	  {
	  default:		id = "68020"; break;
	  case bfd_mach_m68000: id = "68000"; break;
	  case bfd_mach_m68008: id = "68008"; break;
	  case bfd_mach_m68010: id = "68010"; break;
	  case bfd_mach_m68020: id = "68020"; break;
	  case bfd_mach_m68030: id = "68030"; break;
	  case bfd_mach_m68040: id = "68040"; break;
	  case bfd_mach_m68060: id = "68060"; break;
	  case bfd_mach_cpu32:  id = "cpu32"; break;
	  }

	if (! ieee_write_id (abfd, id))
d3629 7
a3635 7
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
     asymbol **symbols ATTRIBUTE_UNUSED;
     bfd_vma offset ATTRIBUTE_UNUSED;
     const char **filename_ptr ATTRIBUTE_UNUSED;
     const char **functionname_ptr ATTRIBUTE_UNUSED;
     unsigned int *line_ptr ATTRIBUTE_UNUSED;
d3645 1
a3645 1
  ieee_ar_data_type *ar = (ieee_ar_data_type *) NULL;
a3647 2
  if (abfd->my_archive != NULL)
    ar = abfd->my_archive->tdata.ieee_ar_data;
d3672 2
a3673 2
     bfd *abfd ATTRIBUTE_UNUSED;
     boolean x ATTRIBUTE_UNUSED;
a3774 1
#define ieee_bfd_gc_sections bfd_generic_gc_sections
a3829 2
  NULL,
  
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
d1346 4
a1349 1
    goto got_wrong_format_error;
d1354 6
a1359 3
    goto got_wrong_format_error;

  /* Throw away the filename.  */
d1365 2
a1366 2
  next_byte (&(ieee->h));	/* Drop the ad part.  */
  must_parse_int (&(ieee->h));	/* And the two dummy numbers.  */
d1374 1
a1374 1
  /* Read the index of the BB table.  */
d1403 2
a1404 1
      /* Make sure that we don't go over the end of the buffer.  */
d1407 1
a1407 1
	  /* Past half way, reseek and reprime.  */
a1410 1

a1423 1

d1429 3
a1431 1
  /* Now scan the area again, and replace BB offsets with file offsets.  */
a1435 1

d1442 3
a1444 4
      next_byte (&(ieee->h));		/* Drop F8.  */
      next_byte (&(ieee->h));		/* Drop 14.  */
      must_parse_int (&(ieee->h));	/* Drop size of block.  */
      
d1446 4
a1449 2
	/* This object has been deleted.  */
	ieee->elements[i].file_offset = 0;
d1451 3
a1453 1
	ieee->elements[i].file_offset = must_parse_int (&(ieee->h));
a1460 2
  bfd_release (abfd, ieee);
  abfd->tdata.ieee_ar_data = save;
a1461 1

a1464 1

d3200 5
a3204 2
/* Gather together all the debug information from each input BFD into
   one place, relocating it and emitting it as we go.  */
a3591 4
	  case bfd_mach_mcf5200:id = "5200";  break;
	  case bfd_mach_mcf5206e:id = "5206e"; break;
	  case bfd_mach_mcf5307:id = "5307";  break;
	  case bfd_mach_mcf5407:id = "5407";  break;
d3731 1
a3731 1
    (ieee_symbol_type *) bfd_zalloc (abfd, sizeof (ieee_symbol_type));
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d8 1
a8 1
   This file is part of BFD, the Binary File Descriptor library.
d10 13
a22 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a34 1
#include "safe-ctype.h"
d36 19
a54 5
struct output_buffer_struct
{
  unsigned char *ptrp;
  int buffer;
};
d56 2
a57 140
static bfd_boolean ieee_write_byte
  PARAMS ((bfd *, int));
static bfd_boolean ieee_write_2bytes
  PARAMS ((bfd *, int));
static bfd_boolean ieee_write_int
  PARAMS ((bfd *, bfd_vma));
static bfd_boolean ieee_write_id
  PARAMS ((bfd *, const char *));
static unsigned short read_2bytes
  PARAMS ((common_header_type *));
static void bfd_get_string
  PARAMS ((common_header_type *, char *, size_t));
static char *read_id
  PARAMS ((common_header_type *));
static bfd_boolean ieee_write_expression
  PARAMS ((bfd *, bfd_vma, asymbol *, bfd_boolean, unsigned int));
static void ieee_write_int5
  PARAMS ((bfd_byte *, bfd_vma));
static bfd_boolean ieee_write_int5_out
  PARAMS ((bfd *, bfd_vma));
static bfd_boolean parse_int
  PARAMS ((common_header_type *, bfd_vma *));
static int parse_i
  PARAMS ((common_header_type *, bfd_boolean *));
static bfd_vma must_parse_int
  PARAMS ((common_header_type *));
static void parse_expression
  PARAMS ((ieee_data_type *, bfd_vma *, ieee_symbol_index_type *,
	   bfd_boolean *, unsigned int *, asection **));
static file_ptr ieee_part_after
  PARAMS ((ieee_data_type *, file_ptr));
static ieee_symbol_type *get_symbol
  PARAMS ((bfd *, ieee_data_type *, ieee_symbol_type *, unsigned int *,
	   ieee_symbol_type ***, unsigned int *, int));
static bfd_boolean ieee_slurp_external_symbols
  PARAMS ((bfd *));
static bfd_boolean ieee_slurp_symbol_table
  PARAMS ((bfd *));
static long ieee_get_symtab_upper_bound
  PARAMS ((bfd *));
static long ieee_get_symtab
  PARAMS ((bfd *, asymbol **));
static asection *get_section_entry
  PARAMS ((bfd *, ieee_data_type *i, unsigned int));
static void ieee_slurp_sections
  PARAMS ((bfd *));
static bfd_boolean ieee_slurp_debug
  PARAMS ((bfd *));
const bfd_target *ieee_archive_p
  PARAMS ((bfd *));
const bfd_target *ieee_object_p
  PARAMS ((bfd *));
static void ieee_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
static void ieee_print_symbol
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
static bfd_boolean do_one
  PARAMS ((ieee_data_type *, ieee_per_section_type *, unsigned char *,
	   asection *, int));
static bfd_boolean ieee_slurp_section_data
  PARAMS ((bfd *));
static bfd_boolean ieee_new_section_hook
  PARAMS ((bfd *, asection *));
static long ieee_get_reloc_upper_bound
  PARAMS ((bfd *, sec_ptr));
static bfd_boolean ieee_get_section_contents
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
static long ieee_canonicalize_reloc
  PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));
static int comp
  PARAMS ((const PTR, const PTR));
static bfd_boolean ieee_write_section_part
  PARAMS ((bfd *));
static bfd_boolean do_with_relocs
  PARAMS ((bfd *, asection *));
static bfd_boolean do_as_repeat
  PARAMS ((bfd *, asection *));
static bfd_boolean do_without_relocs
  PARAMS ((bfd *, asection *));
static bfd_boolean ieee_mkobject
  PARAMS ((bfd *));
static void fill
  PARAMS ((void));
static void flush
  PARAMS ((void));
static void write_int
  PARAMS ((int));
static void copy_id
  PARAMS ((void));
static void copy_expression
  PARAMS ((void));
static void fill_int
  PARAMS ((struct output_buffer_struct *));
static void drop_int
  PARAMS ((struct output_buffer_struct *));
static void copy_int
  PARAMS ((void));
static void f1_record
  PARAMS ((void));
static void f0_record
  PARAMS ((void));
static void copy_till_end
  PARAMS ((void));
static void f2_record
  PARAMS ((void));
static void f8_record
  PARAMS ((void));
static void e2_record
  PARAMS ((void));
static void block
  PARAMS ((void));
static void relocate_debug
  PARAMS ((bfd *, bfd *));
static bfd_boolean ieee_write_debug_part
  PARAMS ((bfd *));
static bfd_boolean ieee_write_data_part
  PARAMS ((bfd *));
static bfd_boolean init_for_output
  PARAMS ((bfd *));
static bfd_boolean ieee_set_section_contents
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
static bfd_boolean ieee_write_external_part
  PARAMS ((bfd *));
static bfd_boolean ieee_write_me_part
  PARAMS ((bfd *));
static bfd_boolean ieee_write_processor
  PARAMS ((bfd *));
static bfd_boolean ieee_write_object_contents
  PARAMS ((bfd *));
static asymbol *ieee_make_empty_symbol
  PARAMS ((bfd *));
static bfd *ieee_openr_next_archived_file
  PARAMS ((bfd *, bfd *));
static bfd_boolean ieee_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
static int ieee_generic_stat_arch_elt
  PARAMS ((bfd *, struct stat *));
static int ieee_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
d62 1
a62 1
static bfd_boolean
d70 3
a72 3
  if (bfd_bwrite ((PTR) &byte, (bfd_size_type) 1, abfd) != 1)
    return FALSE;
  return TRUE;
d75 1
a75 1
static bfd_boolean
d84 3
a86 3
  if (bfd_bwrite ((PTR) buffer, (bfd_size_type) 2, abfd) != 2)
    return FALSE;
  return TRUE;
d89 1
a89 1
static bfd_boolean
d97 1
a97 1
	return FALSE;
d103 2
a104 2
      /* How many significant bytes ?  */
      /* FIXME FOR LONGER INTS.  */
d117 1
a117 1
	return FALSE;
d122 1
a122 1
	    return FALSE;
d126 1
a126 1
	    return FALSE;
d130 1
a130 1
	    return FALSE;
d134 1
a134 1
	    return FALSE;
d138 1
a138 1
  return TRUE;
d141 1
a141 1
static bfd_boolean
d151 1
a151 1
	return FALSE;
d157 1
a157 1
	return FALSE;
d163 1
a163 1
	return FALSE;
d171 1
a171 1
      return FALSE;
d174 3
a176 3
  if (bfd_bwrite ((PTR) id, (bfd_size_type) length, abfd) != length)
    return FALSE;
  return TRUE;
d179 4
a182 2
/* Functions for reading from ieee files in the strange way that the
   standard requires.  */
a193 1

a203 1

d205 3
a207 1
    string[i] = this_byte_and_next (ieee);
a215 1

d219 1
a219 1
      /* Simple string of length 0 to 127.  */
d223 1
a223 1
      /* Length is next byte, allowing 0..255.  */
d228 1
a228 1
      /* Length is next two bytes, allowing 0..65535.  */
d232 2
a233 3

  /* Buy memory and read string.  */
  string = bfd_alloc (ieee->abfd, (bfd_size_type) length + 1);
d241 1
a241 1
static bfd_boolean
d246 1
a246 1
     bfd_boolean pcrel;
d254 1
a254 1
	return FALSE;
d258 2
a259 3
  /* Badly formatted binaries can have a missing symbol,
     so test here to prevent a seg fault.  */
  if (symbol != NULL)
d261 11
a271 2
      if (bfd_is_com_section (symbol->section)
	  || bfd_is_und_section (symbol->section))
d273 1
a273 2
	  /* Def of a common symbol.  */
	  if (! ieee_write_byte (abfd, ieee_variable_X_enum)
d275 2
a276 2
	    return FALSE;
	  term_count ++;
d278 1
a278 1
      else if (! bfd_is_abs_section (symbol->section))
d280 9
a288 3
	  /* Ref to defined symbol -  */

	  if (symbol->flags & BSF_GLOBAL)
d290 2
a291 3
	      if (! ieee_write_byte (abfd, ieee_variable_I_enum)
		  || ! ieee_write_int (abfd, symbol->value))
		return FALSE;
d294 9
a302 27
	  else if (symbol->flags & (BSF_LOCAL | BSF_SECTION_SYM))
	    {
	      /* This is a reference to a defined local symbol.  We can
		 easily do a local as a section+offset.  */
	      if (! ieee_write_byte (abfd, ieee_variable_R_enum)
		  || ! ieee_write_byte (abfd,
					(bfd_byte) (symbol->section->index
						    + IEEE_SECTION_NUMBER_BASE)))
		return FALSE;

	      term_count++;
	      if (symbol->value != 0)
		{
		  if (! ieee_write_int (abfd, symbol->value))
		    return FALSE;
		  term_count++;
		}
	    }
	  else
	    {
	      (*_bfd_error_handler)
		(_("%s: unrecognized symbol `%s' flags 0x%x"),
		 bfd_get_filename (abfd), bfd_asymbol_name (symbol),
		 symbol->flags);
	      bfd_set_error (bfd_error_invalid_operation);
	      return FALSE;
	    }
d308 1
a308 1
      /* Subtract the pc from here by asking for PC of this section.  */
d313 1
a313 1
	return FALSE;
d318 4
a321 2
    if (! ieee_write_int (abfd, (bfd_vma) 0))
      return FALSE;
d326 1
a326 1
	return FALSE;
d330 1
a330 1
  return TRUE;
d333 1
a333 1
/* Writes any integer into the buffer supplied and always takes 5 bytes.  */
d335 3
d350 1
a350 1
static bfd_boolean
d358 3
a360 3
  if (bfd_bwrite ((PTR) b, (bfd_size_type) 5, abfd) != 5)
    return FALSE;
  return TRUE;
d363 1
a363 1
static bfd_boolean
a369 1

d374 1
a374 1
      return TRUE;
a378 1

d387 1
a387 1
      return TRUE;
d389 1
a389 1
  return FALSE;
d395 1
a395 1
     bfd_boolean *ok;
d407 1
a407 1
  BFD_ASSERT (parse_int (ieee, &result));
d422 1
a422 1
#define PCREL_OFFSET FALSE
d427 1
a427 1
#define PCREL_OFFSET TRUE
d436 1
a436 1
	 FALSE,
d441 1
a441 1
	 TRUE,
d444 1
a444 1
	 FALSE);
d451 1
a451 1
	 FALSE,
d456 1
a456 1
	 TRUE,
d459 1
a459 1
	 FALSE);
d466 1
a466 1
	 FALSE,
d471 1
a471 1
	 TRUE,
d474 1
a474 1
	 FALSE);
d481 1
a481 1
	 TRUE,
d486 1
a486 1
	 TRUE,
d496 1
a496 1
	 TRUE,
d501 1
a501 1
	 TRUE,
d511 1
a511 1
	 TRUE,
d516 1
a516 1
	 TRUE,
d528 1
a528 1
     bfd_boolean *pcrel;
d539 1
a539 1
  bfd_boolean loop = TRUE;
d542 1
a542 1
  /* The stack pointer always points to the next unused location.  */
a545 1
  asection *dummy;
d547 1
a547 1
  while (loop && ieee->h.input_p < ieee->h.last_byte)
d552 1
a552 1
	  /* P variable, current program counter for section n.  */
a554 1

d556 1
a556 1
	    *pcrel = TRUE;
d562 1
a562 1
	  /* L variable  address of section N.  */
d567 2
a568 2
	  /* R variable, logical address of section module.  */
	  /* FIXME, this should be different to L.  */
d573 1
a573 1
	  /* S variable, size in MAUS of section module.  */
d580 1
a580 1
	  /* Push the address of variable n.  */
d591 1
a591 1
	  /* Push the address of external variable n.  */
d640 24
a663 2
		/* Thats all that we can understand.  */
		loop = FALSE;
a667 17

  /* As far as I can see there is a bug in the Microtec IEEE output
     which I'm using to scan, whereby the comma operator is omitted
     sometimes in an expression, giving expressions with too many
     terms.  We can tell if that's the case by ensuring that
     sp == stack here.  If not, then we've pushed something too far,
     so we keep adding.  */
  while (sp != stack + 1)
    {
      asection *section1;
      ieee_symbol_index_type sy1;
      POP (sy1, section1, *extra);
    }

  POP (*symbol, dummy, *value);
  if (section)
    *section = dummy;
d671 2
a672 27
#define ieee_seek(ieee, offset) \
  do								\
    {								\
      ieee->h.input_p = ieee->h.first_byte + offset;		\
      ieee->h.last_byte = (ieee->h.first_byte			\
			   + ieee_part_after (ieee, offset));	\
    }								\
  while (0)

#define ieee_pos(ieee) \
  (ieee->h.input_p - ieee->h.first_byte)

/* Find the first part of the ieee file after HERE.  */

static file_ptr
ieee_part_after (ieee, here)
     ieee_data_type *ieee;
     file_ptr here;
{
  int part;
  file_ptr after = ieee->w.r.me_record;

  /* File parts can come in any order, except that module end is
     guaranteed to be last (and the header first).  */
  for (part = 0; part < N_W_VARIABLES; part++)
    if (ieee->w.offset[part] > here && after > ieee->w.offset[part])
      after = ieee->w.offset[part];
d674 2
a675 2
  return after;
}
d678 1
a678 1
static char last_type;		/* Is the index for an X or a D.  */
d681 8
a688 1
get_symbol (abfd, ieee, last_symbol, symbol_count, pptr, max_index, this_type)
d695 2
a696 1
     int this_type;
d698 1
a698 1
  /* Need a new symbol.  */
a699 1

d702 2
a703 4
      ieee_symbol_type *new_symbol;
      bfd_size_type amt = sizeof (ieee_symbol_type);

      new_symbol = (ieee_symbol_type *) bfd_alloc (ieee->h.abfd, amt);
d713 3
a715 2
	*max_index = new_index;

d723 1
a723 1
static bfd_boolean
d734 1
a734 1
  bfd_boolean loop = TRUE;
d736 1
a736 1
  ieee->symbol_table_full = TRUE;
d738 1
a738 1
  ieee_seek (ieee, offset);
d751 1
a751 1
	    return FALSE;
d765 1
a765 1
	    return FALSE;
d780 1
a780 1
	    switch (read_2bytes (&ieee->h))
d794 2
a795 2
		      (_("%s: unimplemented ATI record %u for symbol %u"),
		       bfd_archive_filename (abfd), symbol_attribute_def,
d798 1
a798 1
		    return FALSE;
d803 1
a803 1
		/* Skip over ATX record.  */
d812 1
a812 1
		   {$F1}${CE}{index}{$00}{$3F}{$3F}{#_of_ASNs}.  */
d820 1
a820 1
			 bfd_archive_filename (abfd), (int) value);
d822 1
a822 1
		    return FALSE;
d832 1
a832 1
		    switch (read_2bytes (&ieee->h))
d842 1
a842 1
			     bfd_archive_filename (abfd));
d844 1
a844 1
			return FALSE;
d854 1
a854 1
	    bfd_boolean pcrel_ignore;
d898 1
a898 1
	    /* Throw away the external reference index.  */
d900 1
a900 1
	    /* Fetch the default size if not resolved.  */
d902 2
a903 2
	    /* Fetch the defautlt value if available.  */
	    if (! parse_int (&(ieee->h), &value))
d907 1
a907 1
	    /* This turns into a common.  */
d920 1
a920 1
	    return FALSE;
d933 1
a933 1
	  loop = FALSE;
d965 1
a965 1
      ieee->symbol_table_full = FALSE;
d971 1
a971 1
  return TRUE;
d974 1
a974 1
static bfd_boolean
d978 1
a978 1
  if (! IEEE_DATA (abfd)->read_symbols)
d981 2
a982 2
	return FALSE;
      IEEE_DATA (abfd)->read_symbols = TRUE;
d984 1
a984 1
  return TRUE;
d987 1
a987 1
static long
d998 4
a1001 2
/* Move from our internal lists to the canon table, and insert in
   symbol index order.  */
d1005 1
a1005 1
static long
d1032 1
a1032 1
      if (! ieee->symbol_table_full)
d1034 2
a1035 2
	  /* Arrgh - there are gaps in the table, run through and fill them
	     up with pointers to a null place.  */
a1036 1

d1038 3
a1040 1
	    location[i] = &empty_symbol;
d1047 4
a1050 2
	/* Place into table at correct index locations.  */
	location[symp->index + ieee->external_symbol_base_offset] = &symp->symbol;
d1052 1
a1052 1
      /* The external refs are indexed in a bit.  */
d1059 5
a1063 2
	location[symp->index + ieee->external_reference_base_offset] =
	  &symp->symbol;
a1064 1

d1066 3
a1068 2
    location[abfd->symcount] = (asymbol *) NULL;

a1081 1
      bfd_size_type amt;
d1089 2
a1090 3
      amt = c;
      amt *= sizeof (asection *);
      n = (asection **) bfd_realloc (ieee->section_table, amt);
d1103 1
a1103 1
      char *tmp = bfd_alloc (abfd, (bfd_size_type) 11);
d1124 1
d1130 2
a1131 2
      ieee_seek (ieee, offset);
      while (TRUE)
a1136 1
		asection *section;
d1146 2
a1147 1
		   extended later, based on section contents.  */
d1151 1
a1151 1
		    /* Normal attributes for absolute sections.  */
d1156 1
a1156 1
		      case 0xD3:	/* AS Absolute section attributes.  */
d1162 1
a1162 1
			    /* Normal code.  */
d1167 1
a1167 1
			    /* Normal data.  */
d1173 1
a1173 1
			    /* Normal rom data.  */
d1181 1
a1181 1
		  case 0xC3:	/* Named relocatable sections (type C).  */
d1186 1
a1186 1
		      case 0xD0:	/* Normal code (CP).  */
d1190 1
a1190 1
		      case 0xC4:	/* Normal data (CD).  */
d1194 1
a1194 1
		      case 0xD2:	/* Normal rom data (CR).  */
d1203 1
a1203 1
		/* Read section name, use it if non empty.  */
d1208 1
a1208 1
		/* Skip these fields, which we don't care about.  */
d1236 1
a1236 2
		asection *section;
		ieee_record_enum_type t;
a1237 1
		t = (ieee_record_enum_type) (read_2bytes (&(ieee->h)));
d1287 1
a1287 1
static bfd_boolean
d1296 1
a1296 1
    return TRUE;
d1300 1
a1300 1
    return FALSE;
d1304 5
a1308 1
  debug_end = ieee_part_after (ieee, ieee->w.r.debug_information_part);
d1311 1
a1311 1
  return TRUE;
d1314 3
a1316 1
/* Archive stuff.  */
d1328 1
a1328 1
  bfd_size_type alc_elts;
a1329 1
  bfd_size_type amt = sizeof (ieee_ar_data_type);
d1331 2
a1332 1
  abfd->tdata.ieee_ar_data = (ieee_ar_data_type *) bfd_alloc (abfd, amt);
d1334 1
a1334 1
    goto error_ret_restore;
d1337 3
a1339 3
  /* Ignore the return value here.  It doesn't matter if we don't read
     the entire buffer.  We might have a very small ieee file.  */
  bfd_bread ((PTR) buffer, (bfd_size_type) sizeof (buffer), abfd);
d1399 1
a1399 1
      if ((size_t) ieee_pos (IEEE_DATA (abfd)) > sizeof (buffer) / 2)
d1402 1
a1402 1
	  buffer_offset += ieee_pos (IEEE_DATA (abfd));
d1406 3
a1408 2
	  /* Again ignore return value of bfd_bread.  */
	  bfd_bread ((PTR) buffer, (bfd_size_type) sizeof (buffer), abfd);
d1414 3
a1416 3
  amt = ieee->element_count;
  amt *= sizeof *ieee->elements;
  ieee->elements = (ieee_ar_obstack_type *) bfd_alloc (abfd, amt);
d1420 2
a1421 1
  memcpy (ieee->elements, elts, (size_t) amt);
d1431 3
a1433 2
      /* Again ignore return value of bfd_bread.  */
      bfd_bread ((PTR) buffer, (bfd_size_type) sizeof (buffer), abfd);
d1440 1
a1440 1

d1453 2
d1456 1
a1459 3
  bfd_release (abfd, ieee);
 error_ret_restore:
  abfd->tdata.ieee_ar_data = save;
d1464 8
a1480 1
  bfd_size_type amt;
d1488 4
a1491 3
  /* Read the first few bytes in to see if it makes sense.  Ignore
     bfd_bread return value;  The file might be very small.  */
  bfd_bread ((PTR) buffer, (bfd_size_type) sizeof (buffer), abfd);
d1497 2
a1498 2
  ieee->read_symbols = FALSE;
  ieee->read_data = FALSE;
d1512 6
a1517 4
  if (abfd->filename == (const char *) NULL)
    abfd->filename = ieee->mb.module_name;

  /* Determine the architecture and machine type of the object file.  */
d1556 6
a1561 6
	else if (TOUPPER (processor[3]) == 'F')  /* 68F333 */
	  strcpy (family, "68332");	           /* CPU32 */
	else if ((TOUPPER (processor[3]) == 'C') /* Embedded controllers.  */
		 && ((TOUPPER (processor[2]) == 'E')
		     || (TOUPPER (processor[2]) == 'H')
		     || (TOUPPER (processor[2]) == 'L')))
d1567 1
a1567 1
	else				 /* "Regular" processors.  */
d1589 3
a1591 2
    goto fail;

d1594 8
a1601 5
  if (! parse_int (&(ieee->h), &ieee->ad.number_of_bits_mau))
    goto fail;

  if (! parse_int (&(ieee->h), &ieee->ad.number_of_maus_in_address))
    goto fail;
d1603 3
a1605 3
  /* If there is a byte order info, take it.  */
  if (this_byte (&(ieee->h)) == (int) ieee_variable_L_enum
      || this_byte (&(ieee->h)) == (int) ieee_variable_M_enum)
d1610 1
a1610 2
      bfd_boolean ok;

d1612 3
a1614 2
	goto fail;

d1616 3
a1618 1
	goto fail;
d1621 5
a1625 2
      if (! ok)
	goto fail;
d1634 1
a1634 1
     record.  */
a1635 1
  amt = ieee->w.r.me_record + 1;
d1637 1
a1637 1
    (unsigned char *) bfd_alloc (ieee->h.abfd, amt);
d1644 2
a1645 2
  bfd_bread ((PTR) (IEEE_DATA (abfd)->h.first_byte),
	    (bfd_size_type) ieee->w.r.me_record + 1, abfd);
d1654 1
d1657 1
a1657 1

d1662 1
a1662 1
  bfd_release (abfd, ieee);
d1667 1
a1667 1
static void
d1680 3
a1682 3
static void
ieee_print_symbol (abfd, afile, symbol, how)
     bfd *abfd;
a1706 1

d1713 1
a1713 1
	    bfd_print_symbol_vandf (abfd, (PTR) file, symbol);
d1726 1
a1726 1
static bfd_boolean
a1739 1

d1753 1
a1753 2
	bfd_boolean loop = TRUE;

d1766 1
a1766 1
		  bfd_boolean pcrel = FALSE;
d1768 3
a1770 4
		  ieee_reloc_type *r;
		  bfd_size_type amt = sizeof (ieee_reloc_type);

		  r = (ieee_reloc_type *) bfd_alloc (ieee->h.abfd, amt);
d1772 1
a1772 1
		    return FALSE;
d1794 1
a1794 1
		      /* Fetch number of bytes to pad.  */
d1812 1
a1812 1
		  /* Build a relocation entry for this type.  */
d1824 1
a1824 1
		      if (pcrel)
d1827 2
a1828 2
			  bfd_put_32 (ieee->h.abfd, -current_map->pc,
				      location_ptr + current_map->pc);
d1830 2
a1831 1
			  r->relent.addend -= current_map->pc;
d1833 1
a1833 1
			  bfd_put_32 (ieee->h.abfd, (bfd_vma) 0, location_ptr +
d1840 2
a1841 2
			  bfd_put_32 (ieee->h.abfd, (bfd_vma) 0,
				      location_ptr + current_map->pc);
d1847 1
a1847 1
		      if (pcrel)
d1850 1
a1850 2
			  bfd_put_16 (ieee->h.abfd, (bfd_vma) -current_map->pc,
				      location_ptr + current_map->pc);
d1855 1
a1855 2
			  bfd_put_16 (ieee->h.abfd, (bfd_vma) 0,
				      location_ptr + current_map->pc);
d1862 1
a1862 2
			  bfd_put_16 (ieee->h.abfd, (bfd_vma) 0,
				      location_ptr + current_map->pc);
d1868 1
a1868 1
		      if (pcrel)
d1889 1
a1889 1
		      return FALSE;
d1896 1
a1896 1
		  if (parse_int (&(ieee->h), &this_size))
d1907 1
a1907 1
		      loop = FALSE;
d1915 1
a1915 1
	      loop = FALSE;
d1919 1
a1919 1
  return TRUE;
d1922 2
a1923 3
/* Read in all the section data and relocation stuff too.  */

static bfd_boolean
d1933 7
a1939 5
  /* Seek to the start of the data area.  */
  if (ieee->read_data)
    return TRUE;
  ieee->read_data = TRUE;
  ieee_seek (ieee, ieee->w.r.data_part);
a1940 1
  /* Allocate enough space for all the section contents.  */
d1943 1
a1943 1
      ieee_per_section_type *per = ieee_per_section (s);
d1948 2
a1949 1
	return FALSE;
d1954 1
a1954 1
  while (TRUE)
d1958 1
a1958 1
	  /* IF we see anything strange then quit.  */
d1960 1
a1960 1
	  return TRUE;
d1967 1
a1967 1
	  current_map = ieee_per_section (s);
d1969 3
a1971 3
	  /* The document I have says that Microtec's compilers reset
	     this after a sec section, even though the standard says not
	     to, SO...  */
d1984 1
a1984 2
		bfd_boolean pcrel;

d1986 1
a1986 1
		must_parse_int (&(ieee->h));	/* Throw away section #.  */
d2001 2
a2002 2
	      /* We've got to the end of the data now -  */
	      return TRUE;
d2005 1
a2005 1
	      return FALSE;
d2011 5
a2015 3
	       remembering the stream pointer before running it and
	       resetting it and running it n times. We special case
	       the repetition of a repeat_data/load_constant.  */
a2017 1

d2021 2
a2022 2
	    if (start[0] == (int) ieee_load_constant_bytes_enum
		&& start[1] == 1)
d2039 2
a2040 2
				 (int) iterations))
		      return FALSE;
d2048 4
a2051 2
	  if (!do_one (ieee, current_map, location_ptr, s, 1))
	    return FALSE;
d2056 1
a2056 1
static bfd_boolean
d2061 2
a2062 2
  newsect->used_by_bfd
    = (PTR) bfd_alloc (abfd, (bfd_size_type) sizeof (ieee_per_section_type));
d2064 1
a2064 1
    return FALSE;
d2067 1
a2067 1
  return TRUE;
d2070 1
a2070 1
static long
d2082 1
a2082 1
static bfd_boolean
d2090 1
a2090 1
  ieee_per_section_type *p = ieee_per_section (section);
d2096 1
a2096 1
  return TRUE;
d2099 1
a2099 1
static long
d2106 1
d2115 1
a2115 1
      /* Work out which symbol to attach it this reloc to.  */
d2144 2
a2145 2
     const PTR ap;
     const PTR bp;
d2154 1
a2154 1
static bfd_boolean
d2170 1
a2170 1
	    return FALSE;
d2174 1
a2174 1
	      /* This image is executable, so output absolute sections.  */
d2177 1
a2177 1
		return FALSE;
d2182 1
a2182 1
		return FALSE;
d2190 1
a2190 1
		return FALSE;
d2195 1
a2195 1
		return FALSE;
d2202 1
a2202 1
		return FALSE;
d2207 1
a2207 1
	    return FALSE;
d2213 1
a2213 1
	  /* Alignment.  */
d2218 2
a2219 2
	      || ! ieee_write_int (abfd, (bfd_vma) 1 << s->alignment_power))
	    return FALSE;
d2221 1
a2221 1
	  /* Size.  */
d2227 1
a2227 1
	    return FALSE;
d2230 2
a2231 2
	      /* Relocateable sections don't have asl records.  */
	      /* Vma.  */
d2238 1
a2238 1
		return FALSE;
d2243 1
a2243 1
  return TRUE;
d2247 1
a2247 1
static bfd_boolean
d2264 1
a2264 1
  /* Output the section preheader.  */
d2271 1
a2271 2
    return FALSE;

d2275 1
a2275 1
	return FALSE;
d2279 2
a2280 2
      if (! ieee_write_expression (abfd, (bfd_vma) 0, s->symbol, 0, 0))
	return FALSE;
d2286 2
a2287 1
	 byte opcode rather than the load with relocation opcode.  */
a2291 1

d2294 3
a2296 1
	    run = s->_raw_size - current_byte_index;
d2301 2
a2302 2
		return FALSE;
	      /* Output a stream of bytes.  */
d2304 5
a2308 2
		return FALSE;
	      if (bfd_bwrite ((PTR) (stream + current_byte_index), run, abfd)
d2310 1
a2310 1
		return FALSE;
d2318 1
a2318 1
	return FALSE;
d2326 2
a2327 2
	  /* Outputting a section without data, fill it up.  */
	  stream = (unsigned char *) bfd_zalloc (abfd, s->_raw_size);
d2329 2
a2330 1
	    return FALSE;
a2335 1

d2343 3
a2345 2
	    run = MAXRUN;

d2347 3
a2349 1
	    run = s->_raw_size - current_byte_index;
d2353 1
a2353 1
	      /* Output a stream of bytes.  */
d2355 5
a2359 2
		return FALSE;
	      if (bfd_bwrite ((PTR) (stream + current_byte_index), run, abfd)
d2361 1
a2361 1
		return FALSE;
d2364 1
a2364 2

	  /* Output any relocations here.  */
d2372 1
d2375 3
a2377 1
		    r->addend += current_byte_index;
d2379 1
d2401 1
a2401 1
		      return FALSE;
d2412 1
a2412 1
		    return FALSE;
d2421 2
a2422 2
						   (unsigned) s->index))
			return FALSE;
d2429 2
a2430 2
						   (unsigned) s->index))
			return FALSE;
d2436 3
a2438 3
		      bfd_vma rsize = bfd_get_reloc_size (r->howto);
		      if (! ieee_write_int (abfd, rsize))
			return FALSE;
d2442 1
a2442 1
		    return FALSE;
d2452 1
a2452 1
  return TRUE;
d2459 1
a2459 1
static bfd_boolean
d2474 3
a2476 15
					    + IEEE_SECTION_NUMBER_BASE)))
	return FALSE;

      if ((abfd->flags & EXEC_P) != 0)
	{
	  if (! ieee_write_int (abfd, s->lma))
	    return FALSE;
	}
      else
	{
	  if (! ieee_write_expression (abfd, (bfd_vma) 0, s->symbol, 0, 0))
	    return FALSE;
	}

      if (! ieee_write_byte (abfd, ieee_repeat_data_enum)
d2481 1
a2481 1
	return FALSE;
d2484 1
a2484 1
  return TRUE;
d2487 1
a2487 1
static bfd_boolean
d2497 1
a2497 1
	return FALSE;
a2501 1

d2507 2
a2508 2
		return FALSE;
	      return TRUE;
d2512 1
a2512 1
	return FALSE;
d2515 1
a2515 1
  return TRUE;
a2528 20
static bfd_boolean
ieee_mkobject (abfd)
     bfd *abfd;
{
  bfd_size_type amt;

  output_ptr_start = NULL;
  output_ptr = NULL;
  output_ptr_end = NULL;
  input_ptr_start = NULL;
  input_ptr = NULL;
  input_ptr_end = NULL;
  input_bfd = NULL;
  output_bfd = NULL;
  output_buffer = 0;
  amt = sizeof (ieee_data_type);
  abfd->tdata.ieee_data = (ieee_data_type *) bfd_zalloc (abfd, amt);
  return abfd->tdata.ieee_data != NULL;
}

a2531 1
  bfd_size_type amt = input_ptr_end - input_ptr_start;
d2534 1
a2534 1
  bfd_bread ((PTR) input_ptr_start, amt, input_bfd);
a2536 1

d2540 3
a2542 3
  bfd_size_type amt = output_ptr - output_ptr_start;

  if (bfd_bwrite ((PTR) (output_ptr_start), amt, output_bfd) != amt)
d2563 2
a2564 2
      /* How many significant bytes ?  */
      /* FIXME FOR LONGER INTS.  */
d2566 3
a2568 1
	length = 4;
d2570 3
a2572 1
	length = 3;
d2574 3
a2576 1
	length = 2;
d2592 1
a2600 1

d2617 1
a2617 2
  int value;

d2665 1
a2665 1
	      /* Not a number, just bug out with the answer.  */
d2671 1
d2674 7
a2680 5
	  /* PLUS anything.  */
	  value = *(--tos);
	  value += *(--tos);
	  *tos++ = value;
	  NEXT ();
a2686 1

a2692 1
	    value = 0;
d2694 7
a2700 1
	      value = s->output_section->lma;
d2703 1
d2712 1
d2716 1
d2722 6
d2734 1
a2734 1
      /* Still a chance to output the size.  */
a2748 1

d2815 1
d2823 1
a2823 2

  /* ATN record.  */
d2863 1
a2863 1
      /* EXternal ref.  */
d2917 1
d2923 1
a2923 1
  /* Attribute record.  */
a2933 1

d2981 1
d2993 3
a2995 3
      /* Unique typedefs for module.  */
      /* GLobal typedefs.   */
      /* High level module scope beginning.  */
a2997 1

d3012 1
a3012 1
      /* Global function.  */
a3014 1

d3034 1
a3034 1
      /* File name for source line numbers.  */
a3036 1

d3056 1
a3056 1
      /* Local function.  */
a3058 1

d3076 1
a3076 1
      /* Assembler module scope beginning -  */
a3104 1

a3140 1

d3172 5
a3176 2
/* Moves all the debug information from the source bfd to the output
   bfd, and relocates any expressions it finds.  */
d3192 1
a3192 1
  bfd_bread ((PTR) input_ptr_start, (bfd_size_type) IBS, input);
d3199 1
a3199 1
static bfd_boolean
d3205 2
a3206 2
  unsigned char obuff[OBS];
  bfd_boolean some_debug = FALSE;
d3209 3
a3211 3
  output_ptr_start = output_ptr = obuff;
  output_ptr_end = obuff + OBS;
  output_ptr = obuff;
d3224 1
a3224 1
	  return TRUE;
d3228 2
a3229 2
      if (bfd_bwrite (s->contents, s->_raw_size, abfd) != s->_raw_size)
	return FALSE;
a3236 1

d3240 3
a3242 2
			    SEEK_SET) != 0)
		return FALSE;
a3247 1

d3249 3
a3251 1
	ieee->w.r.debug_information_part = here;
d3253 3
a3255 1
	ieee->w.r.debug_information_part = 0;
d3260 1
a3260 1
  return TRUE;
d3265 1
a3265 1
static bfd_boolean
a3269 1

a3271 1

d3284 1
a3284 1
	    return FALSE;
d3289 1
a3289 1
	    return FALSE;
d3293 1
a3293 1
  return TRUE;
d3297 1
a3297 1
static bfd_boolean
a3301 1

d3308 1
a3308 2
	  bfd_size_type size = s->_raw_size;
	  ieee_per_section (s)->data = (bfd_byte *) (bfd_alloc (abfd, size));
d3310 1
a3310 1
	    return FALSE;
d3313 1
a3313 1
  return TRUE;
d3316 1
a3316 1
/* Exec and core file sections.  */
d3318 4
a3321 4
/* Set section contents is complicated with IEEE since the format is
   not a byte image, but a record stream.  */

static bfd_boolean
d3333 2
a3334 2
	  bfd_size_type size = section->_raw_size;
	  section->contents = (unsigned char *) bfd_alloc (abfd, size);
d3336 1
a3336 1
	    return FALSE;
d3340 2
a3341 2
      memcpy (section->contents + offset, location, (size_t) count);
      return TRUE;
d3347 1
a3347 1
	return FALSE;
d3352 1
a3352 1
  return TRUE;
d3360 1
a3360 1
static bfd_boolean
d3366 1
d3370 1
a3370 2
  bfd_boolean hadone = FALSE;

a3376 1

d3379 1
a3379 1
	      /* This must be a symbol reference.  */
d3381 1
a3381 1
		  || ! ieee_write_int (abfd, (bfd_vma) reference_index)
d3383 1
a3383 1
		return FALSE;
d3386 1
a3386 1
	      hadone = TRUE;
d3390 1
a3390 1
	      /* This is a weak reference.  */
d3392 1
a3392 1
		  || ! ieee_write_int (abfd, (bfd_vma) reference_index)
d3396 1
a3396 1
		  || ! ieee_write_int (abfd, (bfd_vma) reference_index)
d3398 1
a3398 1
		return FALSE;
d3401 1
a3401 1
	      hadone = TRUE;
d3405 2
a3406 1
	      /* This must be a symbol definition.  */
d3408 1
a3408 1
		  || ! ieee_write_int (abfd, (bfd_vma) public_index)
d3411 1
a3411 1
		  || ! ieee_write_int (abfd, (bfd_vma) public_index)
d3415 1
a3415 1
		return FALSE;
d3417 1
a3417 1
	      /* Write out the value.  */
d3419 2
a3420 2
		  || ! ieee_write_int (abfd, (bfd_vma) public_index))
		return FALSE;
d3426 1
a3426 1
			 relocated.  */
d3432 1
a3432 1
			return FALSE;
d3440 2
a3441 2
			      FALSE, 0)))
			return FALSE;
d3449 2
a3450 2
					       FALSE, 0))
		    return FALSE;
d3454 1
a3454 1
	      hadone = TRUE;
d3458 2
a3459 2
	      /* This can happen - when there are gaps in the symbols read
	         from an input ieee file.  */
d3466 1
a3466 1
  return TRUE;
d3470 1
a3470 1
static const unsigned char exten[] =
d3473 3
a3475 3
  0xf1, 0xce, 0x20, 0x00, 37, 3, 3,	/* Set version 3 rev 3.  */
  0xf1, 0xce, 0x20, 0x00, 39, 2,	/* Keep symbol in  original case.  */
  0xf1, 0xce, 0x20, 0x00, 38		/* Set object type relocateable to x.  */
d3478 1
a3478 1
static const unsigned char envi[] =
d3491 1
a3491 1
static bfd_boolean
d3503 1
a3503 1
	return FALSE;
d3507 2
a3508 2
    return FALSE;
  return TRUE;
d3513 1
a3513 1
static bfd_boolean
d3524 1
a3524 1
	return FALSE;
d3529 1
a3529 1
	return FALSE;
d3534 1
a3534 1
	return FALSE;
d3539 1
a3539 1
	return FALSE;
d3549 1
a3549 1
	    return FALSE;
d3554 1
a3554 1
	    return FALSE;
d3559 1
a3559 1
	    return FALSE;
d3565 1
a3565 1
	    return FALSE;
d3592 1
a3592 1
	  return FALSE;
d3597 1
a3597 1
  return TRUE;
d3600 1
a3600 1
static bfd_boolean
d3608 1
a3608 1
  /* Fast forward over the header area.  */
d3610 1
a3610 1
    return FALSE;
d3615 1
a3615 1
    return FALSE;
d3617 1
a3617 1
  /* Fast forward over the variable bits.  */
d3619 1
a3619 1
    return FALSE;
d3621 1
a3621 1
  /* Bits per MAU.  */
d3623 2
a3624 2
    return FALSE;
  /* MAU's per address.  */
d3628 1
a3628 1
    return FALSE;
d3632 1
a3632 1
    return FALSE;
d3635 2
a3636 3
  if (bfd_bwrite ((char *) exten, (bfd_size_type) sizeof (exten), abfd)
      != sizeof (exten))
    return FALSE;
d3640 1
a3640 1
	return FALSE;
d3645 1
a3645 1
	return FALSE;
d3649 2
a3650 3
  if (bfd_bwrite ((char *) envi, (bfd_size_type) sizeof (envi), abfd)
      != sizeof (envi))
    return FALSE;
d3663 7
a3669 7
	|| ! ieee_write_int (abfd, (bfd_vma) (t->tm_year + 1900))
	|| ! ieee_write_int (abfd, (bfd_vma) (t->tm_mon + 1))
	|| ! ieee_write_int (abfd, (bfd_vma) t->tm_mday)
	|| ! ieee_write_int (abfd, (bfd_vma) t->tm_hour)
	|| ! ieee_write_int (abfd, (bfd_vma) t->tm_min)
	|| ! ieee_write_int (abfd, (bfd_vma) t->tm_sec))
      return FALSE;
d3677 1
a3677 1
    return FALSE;
d3681 6
a3686 1
    return FALSE;
d3690 1
a3690 1
    return FALSE;
d3696 1
a3696 1
    return FALSE;
d3700 1
a3700 1
    return FALSE;
d3702 1
a3702 1
  /* Generate the header.  */
d3704 1
a3704 1
    return FALSE;
d3710 2
a3711 2
	  || ! ieee_write_int5_out (abfd, (bfd_vma) ieee->w.offset[i]))
	return FALSE;
d3714 1
a3714 1
  return TRUE;
d3721 1
a3721 1
   hold them all plus all the cached symbol entries.  */
d3723 1
a3723 1
static asymbol *
d3727 2
a3728 3
  bfd_size_type amt = sizeof (ieee_symbol_type);
  ieee_symbol_type *new = (ieee_symbol_type *) bfd_zalloc (abfd, amt);

d3741 1
a3741 2

  /* Take the next one from the arch state, or reset.  */
d3743 5
a3747 4
    /* Reset the index - the first two entries are bogus.  */
    ar->element_index = 2;

  while (TRUE)
a3749 1

d3768 1
d3772 8
a3779 3
static bfd_boolean
ieee_find_nearest_line (abfd, section, symbols, offset, filename_ptr,
			functionname_ptr, line_ptr)
d3788 1
a3788 1
  return FALSE;
d3826 1
a3826 1
     bfd_boolean x ATTRIBUTE_UNUSED;
d3851 2
a3852 1
   be ready to output it at close time.  */
d3860 1
a3860 2

  /* Can only accumulate data from other ieee bfds.  */
d3863 2
a3864 2
  /* Only bother once per bfd.  */
  if (ieee->done_debug)
d3866 1
a3866 1
  ieee->done_debug = TRUE;
d3868 1
a3868 1
  /* Don't bother if there is no debug info.  */
d3872 2
a3873 1
  /* Add to chain.  */
d3875 1
a3875 3
    bfd_size_type amt = sizeof (bfd_chain_type);
    bfd_chain_type *n = (bfd_chain_type *) bfd_alloc (abfd, amt);

d3882 3
a3884 1
      output_ieee->chain_head->next = n;
d3886 2
a3887 1
      output_ieee->chain_root = n;
d3889 1
d3902 1
a3902 2
  ((bfd_boolean (*) \
    PARAMS ((bfd *, char **, bfd_size_type *, const char **))) \
d3906 1
a3906 1
  ((bfd_boolean (*) \
a3928 2
#define ieee_bfd_merge_sections bfd_generic_merge_sections
#define ieee_bfd_discard_group bfd_generic_discard_group
a3929 1
#define ieee_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
a3930 1
#define ieee_bfd_link_just_syms _bfd_generic_link_just_syms
d3934 1
a3973 2
  /* ieee_close_and_cleanup, ieee_bfd_free_cached_info, ieee_new_section_hook,
     ieee_get_section_contents, ieee_get_section_contents_in_window  */
a3974 1

a3976 6

  /* ieee_slurp_armap, ieee_slurp_extended_name_table,
     ieee_construct_extended_name_table, ieee_truncate_arname,
     ieee_write_armap, ieee_read_ar_hdr, ieee_openr_next_archived_file,
     ieee_get_elt_at_index, ieee_generic_stat_arch_elt,
     ieee_update_armap_timestamp  */
a3977 5

  /* ieee_get_symtab_upper_bound, ieee_get_symtab, ieee_make_empty_symbol,
     ieee_print_symbol, ieee_get_symbol_info, ieee_bfd_is_local_label_name,
     ieee_get_lineno, ieee_find_nearest_line, ieee_bfd_make_debug_symbol,
     ieee_read_minisymbols, ieee_minisymbol_to_symbol  */
a3978 3

  /* ieee_get_reloc_upper_bound, ieee_canonicalize_reloc,
     ieee_bfd_reloc_type_lookup  */
a3979 2

  /* ieee_set_arch_mach, ieee_set_section_contents  */
a3980 7

  /* ieee_sizeof_headers, ieee_bfd_get_relocated_section_contents,
     ieee_bfd_relax_section, ieee_bfd_link_hash_table_create,
     _bfd_generic_link_hash_table_free,
     ieee_bfd_link_add_symbols, ieee_bfd_final_link,
     ieee_bfd_link_split_section, ieee_bfd_gc_sections,
     ieee_bfd_merge_sections  */
a3981 1

d3985 1
a3985 1

@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d83 1
a83 1
static long ieee_canonicalize_symtab
d163 1
a163 1
  PARAMS ((bfd *, sec_ptr, const PTR, file_ptr, bfd_size_type));
d1046 1
a1046 1
	    /* Fetch the default value if available.  */
d1148 1
a1148 1
ieee_canonicalize_symtab (abfd, location)
d1642 1
a1642 1
    /* IEEE does not specify the format of the processor identification
d3443 1
a3443 1
     const PTR location;
d3593 1
a3593 1
  0xf1, 0xce, 0x20, 0x00, 38		/* Set object type relocatable to x.  */
a3706 1
	  case bfd_mach_mcf528x:id = "5282";  break;
d4100 4
a4103 5
  /* ieee_get_symtab_upper_bound, ieee_canonicalize_symtab,
     ieee_make_empty_symbol, ieee_print_symbol, ieee_get_symbol_info,
     ieee_bfd_is_local_label_name, ieee_get_lineno,
     ieee_find_nearest_line, ieee_bfd_make_debug_symbol,
     ieee_read_minisymbols, ieee_minisymbol_to_symbol */
@


