head	1.7;
access;
symbols
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.52
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.11;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.23;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.31;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.21;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.01.29;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.46.38;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.06;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.06;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.06.18;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.38.33;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.20.24;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.45.53;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.27.07;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.19;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.32;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* opncls.c -- open and close a BFD.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000,
   2001, 2002, 2003
   Free Software Foundation, Inc.

   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "objalloc.h"
#include "libbfd.h"
#include "libiberty.h"

#ifndef S_IXUSR
#define S_IXUSR 0100	/* Execute by owner.  */
#endif
#ifndef S_IXGRP
#define S_IXGRP 0010	/* Execute by group.  */
#endif
#ifndef S_IXOTH
#define S_IXOTH 0001	/* Execute by others.  */
#endif

/* Counter used to initialize the bfd identifier.  */

static unsigned int _bfd_id_counter = 0;

/* fdopen is a loser -- we should use stdio exclusively.  Unfortunately
   if we do that we can't use fcntl.  */

/* Return a new BFD.  All BFD's are allocated through this routine.  */

bfd *
_bfd_new_bfd (void)
{
  bfd *nbfd;

  nbfd = bfd_zmalloc (sizeof (bfd));
  if (nbfd == NULL)
    return NULL;

  nbfd->id = _bfd_id_counter++;

  nbfd->memory = objalloc_create ();
  if (nbfd->memory == NULL)
    {
      bfd_set_error (bfd_error_no_memory);
      free (nbfd);
      return NULL;
    }

  nbfd->arch_info = &bfd_default_arch_struct;

  nbfd->direction = no_direction;
  nbfd->iostream = NULL;
  nbfd->where = 0;
  if (!bfd_hash_table_init_n (& nbfd->section_htab, bfd_section_hash_newfunc,
			      251))
    {
      free (nbfd);
      return NULL;
    }
  nbfd->sections = NULL;
  nbfd->section_tail = &nbfd->sections;
  nbfd->format = bfd_unknown;
  nbfd->my_archive = NULL;
  nbfd->origin = 0;
  nbfd->opened_once = FALSE;
  nbfd->output_has_begun = FALSE;
  nbfd->section_count = 0;
  nbfd->usrdata = NULL;
  nbfd->cacheable = FALSE;
  nbfd->flags = BFD_NO_FLAGS;
  nbfd->mtime_set = FALSE;

  return nbfd;
}

/* Allocate a new BFD as a member of archive OBFD.  */

bfd *
_bfd_new_bfd_contained_in (bfd *obfd)
{
  bfd *nbfd;

  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    return NULL;
  nbfd->xvec = obfd->xvec;
  nbfd->my_archive = obfd;
  nbfd->direction = read_direction;
  nbfd->target_defaulted = obfd->target_defaulted;
  return nbfd;
}

/* Delete a BFD.  */

void
_bfd_delete_bfd (bfd *abfd)
{
  bfd_hash_table_free (&abfd->section_htab);
  objalloc_free ((struct objalloc *) abfd->memory);
  free (abfd);
}

/*
SECTION
	Opening and closing BFDs

*/

/*
FUNCTION
	bfd_openr

SYNOPSIS
	bfd *bfd_openr (const char *filename, const char *target);

DESCRIPTION
	Open the file @@var{filename} (using <<fopen>>) with the target
	@@var{target}.  Return a pointer to the created BFD.

	Calls <<bfd_find_target>>, so @@var{target} is interpreted as by
	that function.

	If <<NULL>> is returned then an error has occured.   Possible errors
	are <<bfd_error_no_memory>>, <<bfd_error_invalid_target>> or
	<<system_call>> error.
*/

bfd *
bfd_openr (const char *filename, const char *target)
{
  bfd *nbfd;
  const bfd_target *target_vec;

  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    return NULL;

  target_vec = bfd_find_target (target, nbfd);
  if (target_vec == NULL)
    {
      _bfd_delete_bfd (nbfd);
      return NULL;
    }

  nbfd->filename = filename;
  nbfd->direction = read_direction;

  if (bfd_open_file (nbfd) == NULL)
    {
      /* File didn't exist, or some such.  */
      bfd_set_error (bfd_error_system_call);
      _bfd_delete_bfd (nbfd);
      return NULL;
    }

  return nbfd;
}

/* Don't try to `optimize' this function:

   o - We lock using stack space so that interrupting the locking
       won't cause a storage leak.
   o - We open the file stream last, since we don't want to have to
       close it if anything goes wrong.  Closing the stream means closing
       the file descriptor too, even though we didn't open it.  */
/*
FUNCTION
	bfd_fdopenr

SYNOPSIS
	bfd *bfd_fdopenr (const char *filename, const char *target, int fd);

DESCRIPTION
	<<bfd_fdopenr>> is to <<bfd_fopenr>> much like <<fdopen>> is to
	<<fopen>>.  It opens a BFD on a file already described by the
	@@var{fd} supplied.

	When the file is later <<bfd_close>>d, the file descriptor will
	be closed.  If the caller desires that this file descriptor be
	cached by BFD (opened as needed, closed as needed to free
	descriptors for other opens), with the supplied @@var{fd} used as
	an initial file descriptor (but subject to closure at any time),
	call bfd_set_cacheable(bfd, 1) on the returned BFD.  The default
	is to assume no caching; the file descriptor will remain open
	until <<bfd_close>>, and will not be affected by BFD operations
	on other files.

	Possible errors are <<bfd_error_no_memory>>,
	<<bfd_error_invalid_target>> and <<bfd_error_system_call>>.
*/

bfd *
bfd_fdopenr (const char *filename, const char *target, int fd)
{
  bfd *nbfd;
  const bfd_target *target_vec;
  int fdflags;

  bfd_set_error (bfd_error_system_call);
#if ! defined(HAVE_FCNTL) || ! defined(F_GETFL)
  fdflags = O_RDWR;			/* Assume full access.  */
#else
  fdflags = fcntl (fd, F_GETFL, NULL);
#endif
  if (fdflags == -1)
    return NULL;

  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    return NULL;

  target_vec = bfd_find_target (target, nbfd);
  if (target_vec == NULL)
    {
      _bfd_delete_bfd (nbfd);
      return NULL;
    }

#ifndef HAVE_FDOPEN
  nbfd->iostream = fopen (filename, FOPEN_RB);
#else
  /* (O_ACCMODE) parens are to avoid Ultrix header file bug.  */
  switch (fdflags & (O_ACCMODE))
    {
    case O_RDONLY: nbfd->iostream = fdopen (fd, FOPEN_RB);   break;
    case O_WRONLY: nbfd->iostream = fdopen (fd, FOPEN_RUB);  break;
    case O_RDWR:   nbfd->iostream = fdopen (fd, FOPEN_RUB);  break;
    default: abort ();
    }
#endif

  if (nbfd->iostream == NULL)
    {
      _bfd_delete_bfd (nbfd);
      return NULL;
    }

  /* OK, put everything where it belongs.  */
  nbfd->filename = filename;

  /* As a special case we allow a FD open for read/write to
     be written through, although doing so requires that we end
     the previous clause with a preposition.  */
  /* (O_ACCMODE) parens are to avoid Ultrix header file bug.  */
  switch (fdflags & (O_ACCMODE))
    {
    case O_RDONLY: nbfd->direction = read_direction; break;
    case O_WRONLY: nbfd->direction = write_direction; break;
    case O_RDWR: nbfd->direction = both_direction; break;
    default: abort ();
    }

  if (! bfd_cache_init (nbfd))
    {
      _bfd_delete_bfd (nbfd);
      return NULL;
    }
  nbfd->opened_once = TRUE;

  return nbfd;
}

/*
FUNCTION
	bfd_openstreamr

SYNOPSIS
	bfd *bfd_openstreamr (const char *, const char *, void *);

DESCRIPTION

	Open a BFD for read access on an existing stdio stream.  When
	the BFD is passed to <<bfd_close>>, the stream will be closed.
*/

bfd *
bfd_openstreamr (const char *filename, const char *target, void *streamarg)
{
  FILE *stream = streamarg;
  bfd *nbfd;
  const bfd_target *target_vec;

  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    return NULL;

  target_vec = bfd_find_target (target, nbfd);
  if (target_vec == NULL)
    {
      _bfd_delete_bfd (nbfd);
      return NULL;
    }

  nbfd->iostream = stream;
  nbfd->filename = filename;
  nbfd->direction = read_direction;

  if (! bfd_cache_init (nbfd))
    {
      _bfd_delete_bfd (nbfd);
      return NULL;
    }

  return nbfd;
}

/* bfd_openw -- open for writing.
   Returns a pointer to a freshly-allocated BFD on success, or NULL.

   See comment by bfd_fdopenr before you try to modify this function.  */

/*
FUNCTION
	bfd_openw

SYNOPSIS
	bfd *bfd_openw (const char *filename, const char *target);

DESCRIPTION
	Create a BFD, associated with file @@var{filename}, using the
	file format @@var{target}, and return a pointer to it.

	Possible errors are <<bfd_error_system_call>>, <<bfd_error_no_memory>>,
	<<bfd_error_invalid_target>>.
*/

bfd *
bfd_openw (const char *filename, const char *target)
{
  bfd *nbfd;
  const bfd_target *target_vec;

  /* nbfd has to point to head of malloc'ed block so that bfd_close may
     reclaim it correctly.  */
  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    return NULL;

  target_vec = bfd_find_target (target, nbfd);
  if (target_vec == NULL)
    {
      _bfd_delete_bfd (nbfd);
      return NULL;
    }

  nbfd->filename = filename;
  nbfd->direction = write_direction;

  if (bfd_open_file (nbfd) == NULL)
    {
      /* File not writeable, etc.  */
      bfd_set_error (bfd_error_system_call);
      _bfd_delete_bfd (nbfd);
      return NULL;
  }

  return nbfd;
}

/*

FUNCTION
	bfd_close

SYNOPSIS
	bfd_boolean bfd_close (bfd *abfd);

DESCRIPTION

	Close a BFD. If the BFD was open for writing, then pending
	operations are completed and the file written out and closed.
	If the created file is executable, then <<chmod>> is called
	to mark it as such.

	All memory attached to the BFD is released.

	The file descriptor associated with the BFD is closed (even
	if it was passed in to BFD by <<bfd_fdopenr>>).

RETURNS
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.
*/


bfd_boolean
bfd_close (bfd *abfd)
{
  bfd_boolean ret;

  if (bfd_write_p (abfd))
    {
      if (! BFD_SEND_FMT (abfd, _bfd_write_contents, (abfd)))
	return FALSE;
    }

  if (! BFD_SEND (abfd, _close_and_cleanup, (abfd)))
    return FALSE;

  ret = bfd_cache_close (abfd);

  /* If the file was open for writing and is now executable,
     make it so.  */
  if (ret
      && abfd->direction == write_direction
      && abfd->flags & EXEC_P)
    {
      struct stat buf;

      if (stat (abfd->filename, &buf) == 0)
	{
	  unsigned int mask = umask (0);

	  umask (mask);
	  chmod (abfd->filename,
		 (0777
		  & (buf.st_mode | ((S_IXUSR | S_IXGRP | S_IXOTH) &~ mask))));
	}
    }

  _bfd_delete_bfd (abfd);

  return ret;
}

/*
FUNCTION
	bfd_close_all_done

SYNOPSIS
	bfd_boolean bfd_close_all_done (bfd *);

DESCRIPTION
	Close a BFD.  Differs from <<bfd_close>> since it does not
	complete any pending operations.  This routine would be used
	if the application had just used BFD for swapping and didn't
	want to use any of the writing code.

	If the created file is executable, then <<chmod>> is called
	to mark it as such.

	All memory attached to the BFD is released.

RETURNS
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.
*/

bfd_boolean
bfd_close_all_done (bfd *abfd)
{
  bfd_boolean ret;

  ret = bfd_cache_close (abfd);

  /* If the file was open for writing and is now executable,
     make it so.  */
  if (ret
      && abfd->direction == write_direction
      && abfd->flags & EXEC_P)
    {
      struct stat buf;

      if (stat (abfd->filename, &buf) == 0)
	{
	  unsigned int mask = umask (0);

	  umask (mask);
	  chmod (abfd->filename,
		 (0777
		  & (buf.st_mode | ((S_IXUSR | S_IXGRP | S_IXOTH) &~ mask))));
	}
    }

  _bfd_delete_bfd (abfd);

  return ret;
}

/*
FUNCTION
	bfd_create

SYNOPSIS
	bfd *bfd_create (const char *filename, bfd *templ);

DESCRIPTION
	Create a new BFD in the manner of <<bfd_openw>>, but without
	opening a file. The new BFD takes the target from the target
	used by @@var{template}. The format is always set to <<bfd_object>>.
*/

bfd *
bfd_create (const char *filename, bfd *templ)
{
  bfd *nbfd;

  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    return NULL;
  nbfd->filename = filename;
  if (templ)
    nbfd->xvec = templ->xvec;
  nbfd->direction = no_direction;
  bfd_set_format (nbfd, bfd_object);

  return nbfd;
}

/*
FUNCTION
	bfd_make_writable

SYNOPSIS
	bfd_boolean bfd_make_writable (bfd *abfd);

DESCRIPTION
	Takes a BFD as created by <<bfd_create>> and converts it
	into one like as returned by <<bfd_openw>>.  It does this
	by converting the BFD to BFD_IN_MEMORY.  It's assumed that
	you will call <<bfd_make_readable>> on this bfd later.

RETURNS
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.
*/

bfd_boolean
bfd_make_writable (bfd *abfd)
{
  struct bfd_in_memory *bim;

  if (abfd->direction != no_direction)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  bim = bfd_malloc (sizeof (struct bfd_in_memory));
  abfd->iostream = bim;
  /* bfd_bwrite will grow these as needed.  */
  bim->size = 0;
  bim->buffer = 0;

  abfd->flags |= BFD_IN_MEMORY;
  abfd->direction = write_direction;
  abfd->where = 0;

  return TRUE;
}

/*
FUNCTION
	bfd_make_readable

SYNOPSIS
	bfd_boolean bfd_make_readable (bfd *abfd);

DESCRIPTION
	Takes a BFD as created by <<bfd_create>> and
	<<bfd_make_writable>> and converts it into one like as
	returned by <<bfd_openr>>.  It does this by writing the
	contents out to the memory buffer, then reversing the
	direction.

RETURNS
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.  */

bfd_boolean
bfd_make_readable (bfd *abfd)
{
  if (abfd->direction != write_direction || !(abfd->flags & BFD_IN_MEMORY))
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  if (! BFD_SEND_FMT (abfd, _bfd_write_contents, (abfd)))
    return FALSE;

  if (! BFD_SEND (abfd, _close_and_cleanup, (abfd)))
    return FALSE;


  abfd->arch_info = &bfd_default_arch_struct;

  abfd->where = 0;
  abfd->format = bfd_unknown;
  abfd->my_archive = NULL;
  abfd->origin = 0;
  abfd->opened_once = FALSE;
  abfd->output_has_begun = FALSE;
  abfd->section_count = 0;
  abfd->usrdata = NULL;
  abfd->cacheable = FALSE;
  abfd->flags = BFD_IN_MEMORY;
  abfd->mtime_set = FALSE;

  abfd->target_defaulted = TRUE;
  abfd->direction = read_direction;
  abfd->sections = 0;
  abfd->symcount = 0;
  abfd->outsymbols = 0;
  abfd->tdata.any = 0;

  bfd_section_list_clear (abfd);
  bfd_check_format (abfd, bfd_object);

  return TRUE;
}

/*
INTERNAL_FUNCTION
	bfd_alloc

SYNOPSIS
	void *bfd_alloc (bfd *abfd, size_t wanted);

DESCRIPTION
	Allocate a block of @@var{wanted} bytes of memory attached to
	<<abfd>> and return a pointer to it.
*/


void *
bfd_alloc (bfd *abfd, bfd_size_type size)
{
  void *ret;

  if (size != (unsigned long) size)
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

  ret = objalloc_alloc (abfd->memory, (unsigned long) size);
  if (ret == NULL)
    bfd_set_error (bfd_error_no_memory);
  return ret;
}

void *
bfd_zalloc (bfd *abfd, bfd_size_type size)
{
  void *res;

  res = bfd_alloc (abfd, size);
  if (res)
    memset (res, 0, (size_t) size);
  return res;
}

/* Free a block allocated for a BFD.
   Note:  Also frees all more recently allocated blocks!  */

void
bfd_release (bfd *abfd, void *block)
{
  objalloc_free_block ((struct objalloc *) abfd->memory, block);
}


/* 
   GNU Extension: separate debug-info files 
   
   The idea here is that a special section called .gnu_debuglink might be
   embedded in a binary file, which indicates that some *other* file
   contains the real debugging information. This special section contains a
   filename and CRC32 checksum, which we read and resolve to another file,
   if it exists.

   This facilitates "optional" provision of debugging information, without
   having to provide two complete copies of every binary object (with and
   without debug symbols).
*/

#define GNU_DEBUGLINK	".gnu_debuglink"
/*
FUNCTION
	bfd_calc_gnu_debuglink_crc32

SYNOPSIS
	unsigned long bfd_calc_gnu_debuglink_crc32
	  (unsigned long crc, const unsigned char *buf, bfd_size_type len);

DESCRIPTION
	Computes a CRC value as used in the .gnu_debuglink section.
	Advances the previously computed @@var{crc} value by computing
	and adding in the crc32 for @@var{len} bytes of @@var{buf}.

RETURNS
	Return the updated CRC32 value.
*/     

unsigned long
bfd_calc_gnu_debuglink_crc32 (unsigned long crc,
			      const unsigned char *buf,
			      bfd_size_type len)
{
  static const unsigned long crc32_table[256] =
    {
      0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
      0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
      0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
      0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
      0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
      0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
      0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
      0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
      0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
      0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
      0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
      0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
      0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
      0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
      0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
      0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
      0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
      0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
      0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
      0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
      0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
      0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
      0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
      0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
      0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
      0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
      0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
      0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
      0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
      0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
      0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
      0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
      0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
      0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
      0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
      0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
      0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
      0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
      0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
      0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
      0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
      0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
      0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
      0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
      0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
      0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
      0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
      0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
      0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
      0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
      0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
      0x2d02ef8d
    };
  const unsigned char *end;

  crc = ~crc & 0xffffffff;
  for (end = buf + len; buf < end; ++ buf)
    crc = crc32_table[(crc ^ *buf) & 0xff] ^ (crc >> 8);
  return ~crc & 0xffffffff;;
}


/*
INTERNAL_FUNCTION
	get_debug_link_info

SYNOPSIS
	char *get_debug_link_info (bfd *abfd, unsigned long *crc32_out);

DESCRIPTION
	fetch the filename and CRC32 value for any separate debuginfo
	associated with @@var{abfd}. Return NULL if no such info found,
	otherwise return filename and update @@var{crc32_out}.
*/

static char *
get_debug_link_info (bfd *abfd, unsigned long *crc32_out)
{
  asection * sect;
  bfd_size_type debuglink_size;
  unsigned long crc32;
  char * contents;
  int crc_offset;
  bfd_boolean ret;

  BFD_ASSERT (abfd);
  BFD_ASSERT (crc32_out);

  sect = bfd_get_section_by_name (abfd, GNU_DEBUGLINK);

  if (sect == NULL)
    return NULL;

  debuglink_size = bfd_section_size (abfd, sect);  

  contents = malloc (debuglink_size);
  if (contents == NULL)
    return NULL;

  ret = bfd_get_section_contents (abfd, sect, contents, 0, debuglink_size);
  if (! ret)
    {
      free (contents);
      return NULL;
    }

  /* Crc value is stored after the filename, aligned up to 4 bytes.  */
  crc_offset = strlen (contents) + 1;
  crc_offset = (crc_offset + 3) & ~3;

  crc32 = bfd_get_32 (abfd, contents + crc_offset);

  *crc32_out = crc32;
  return contents;
}

/*
INTERNAL_FUNCTION
	separate_debug_file_exists

SYNOPSIS
	bfd_boolean separate_debug_file_exists
	  (char *name, unsigned long crc32);

DESCRIPTION
	Checks to see if @@var{name} is a file and if its contents
	match @@var{crc32}.
*/

static bfd_boolean
separate_debug_file_exists (const char *name, const unsigned long crc)
{
  static char buffer [8 * 1024];
  unsigned long file_crc = 0;
  int fd;
  bfd_size_type count;

  BFD_ASSERT (name);

  fd = open (name, O_RDONLY);
  if (fd < 0)
    return FALSE;

  while ((count = read (fd, buffer, sizeof (buffer))) > 0)
    file_crc = bfd_calc_gnu_debuglink_crc32 (file_crc, buffer, count);

  close (fd);

  return crc == file_crc;
}


/*
INTERNAL_FUNCTION
	find_separate_debug_file

SYNOPSIS
	char *find_separate_debug_file (bfd *abfd);

DESCRIPTION
	Searches @@var{abfd} for a reference to separate debugging
	information, scans various locations in the filesystem, including
	the file tree rooted at @@var{debug_file_directory}, and returns a
	filename of such debugging information if the file is found and has
	matching CRC32.  Returns NULL if no reference to debugging file
	exists, or file cannot be found.
*/

static char *
find_separate_debug_file (bfd *abfd, const char *debug_file_directory)
{
  char *basename;
  char *dir;
  char *debugfile;
  unsigned long crc32;
  int i;

  BFD_ASSERT (abfd);
  if (debug_file_directory == NULL)
    debug_file_directory = ".";

  /* BFD may have been opened from a stream.  */
  if (! abfd->filename)
    return NULL;

  basename = get_debug_link_info (abfd, & crc32);
  if (basename == NULL)
    return NULL;

  if (strlen (basename) < 1)
    {
      free (basename);
      return NULL;
    }

  dir = strdup (abfd->filename);
  if (dir == NULL)
    {
      free (basename);
      return NULL;
    }
  BFD_ASSERT (strlen (dir) != 0);
  
  /* Strip off filename part.  */
  for (i = strlen (dir) - 1; i >= 0; i--)
    if (IS_DIR_SEPARATOR (dir[i]))
      break;

  dir[i + 1] = '\0';
  BFD_ASSERT (dir[i] == '/' || dir[0] == '\0')

  debugfile = malloc (strlen (debug_file_directory) + 1
		      + strlen (dir)
		      + strlen (".debug/")
		      + strlen (basename) 
		      + 1);
  if (debugfile == NULL)
    {
      free (basename);
      free (dir);
      return NULL;
    }

  /* First try in the same directory as the original file:  */
  strcpy (debugfile, dir);
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      free (basename);
      free (dir);
      return debugfile;
    }

  /* Then try in a subdirectory called .debug.  */
  strcpy (debugfile, dir);
  strcat (debugfile, ".debug/");
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      free (basename);
      free (dir);
      return debugfile;
    }

  /* Then try in the global debugfile directory.  */
  strcpy (debugfile, debug_file_directory);
  i = strlen (debug_file_directory) - 1;
  if (i > 0
      && debug_file_directory[i] != '/'
      && dir[0] != '/')
    strcat (debugfile, "/");
  strcat (debugfile, dir);
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      free (basename);
      free (dir);
      return debugfile;
    }

  free (debugfile);
  free (basename);
  free (dir);
  return NULL;
}


/*
FUNCTION
	bfd_follow_gnu_debuglink

SYNOPSIS
	char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);

DESCRIPTION

	Takes a BFD and searches it for a .gnu_debuglink section.  If this
	section is found, it examines the section for the name and checksum
	of a '.debug' file containing auxiliary debugging information.  It
	then searches the filesystem for this .debug file in some standard
	locations, including the directory tree rooted at @@var{dir}, and if
	found returns the full filename.

	If @@var{dir} is NULL, it will search a default path configured into
	libbfd at build time.  [XXX this feature is not currently
	implemented].

RETURNS
	<<NULL>> on any errors or failure to locate the .debug file,
	otherwise a pointer to a heap-allocated string containing the
	filename.  The caller is responsible for freeing this string.
*/

char *
bfd_follow_gnu_debuglink (bfd *abfd, const char *dir)
{
#if 0 /* Disabled until DEBUGDIR can be defined by configure.in.  */
  if (dir == NULL)
    dir = DEBUGDIR;
#endif
  return find_separate_debug_file (abfd, dir);
}

/*
FUNCTION
	bfd_create_gnu_debuglink_section

SYNOPSIS
	struct bfd_section *bfd_create_gnu_debuglink_section
	  (bfd *abfd, const char *filename);

DESCRIPTION

	Takes a @@var{BFD} and adds a .gnu_debuglink section to it.  The section is sized
	to be big enough to contain a link to the specified @@var{filename}.

RETURNS
	A pointer to the new section is returned if all is ok.  Otherwise <<NULL>> is
	returned and bfd_error is set.  
*/

asection *
bfd_create_gnu_debuglink_section (bfd *abfd, const char *filename)
{
  asection *sect;
  bfd_size_type debuglink_size;

  if (abfd == NULL || filename == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return NULL;
    }

  /* Strip off any path components in filename.  */
  filename = lbasename (filename);
  
  sect = bfd_get_section_by_name (abfd, GNU_DEBUGLINK);
  if (sect)
    {
      /* Section already exists.  */
      bfd_set_error (bfd_error_invalid_operation);
      return NULL;
    }

  sect = bfd_make_section (abfd, GNU_DEBUGLINK);
  if (sect == NULL)
    return NULL;

  if (! bfd_set_section_flags (abfd, sect,
			       SEC_HAS_CONTENTS | SEC_READONLY | SEC_DEBUGGING))
    /* XXX Should we delete the section from the bfd ?  */
    return NULL;

  
  debuglink_size = strlen (filename) + 1;
  debuglink_size += 3;
  debuglink_size &= ~3;
  debuglink_size += 4;

  if (! bfd_set_section_size (abfd, sect, debuglink_size))
    /* XXX Should we delete the section from the bfd ?  */
    return NULL;
  
  return sect;
}


/*
FUNCTION
	bfd_fill_in_gnu_debuglink_section

SYNOPSIS
	bfd_boolean bfd_fill_in_gnu_debuglink_section
	  (bfd *abfd, struct bfd_section *sect, const char *filename);

DESCRIPTION

	Takes a @@var{BFD} and containing a .gnu_debuglink section @@var{SECT}
	and fills in the contents of the section to contain a link to the
	specified @@var{filename}.  The filename should be relative to the
	current directory.

RETURNS
	<<TRUE>> is returned if all is ok.  Otherwise <<FALSE>> is returned
	and bfd_error is set.  
*/

bfd_boolean
bfd_fill_in_gnu_debuglink_section (bfd *abfd,
				   struct bfd_section *sect,
				   const char *filename)
{
  bfd_size_type debuglink_size;
  unsigned long crc32;
  char * contents;
  bfd_size_type crc_offset;
  FILE * handle;
  static char buffer[8 * 1024];
  size_t count;

  if (abfd == NULL || sect == NULL || filename == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  /* Make sure that we can read the file.
     XXX - Should we attempt to locate the debug info file using the same
     algorithm as gdb ?  At the moment, since we are creating the
     .gnu_debuglink section, we insist upon the user providing us with a
     correct-for-section-creation-time path, but this need not conform to
     the gdb location algorithm.  */
  handle = fopen (filename, FOPEN_RB);
  if (handle == NULL)
    {
      bfd_set_error (bfd_error_system_call);
      return FALSE;
    }

  crc32 = 0;
  while ((count = fread (buffer, 1, sizeof buffer, handle)) > 0)
    crc32 = bfd_calc_gnu_debuglink_crc32 (crc32, buffer, count);
  fclose (handle);

  /* Strip off any path components in filename,
     now that we no longer need them.  */
  filename = lbasename (filename);
  
  debuglink_size = strlen (filename) + 1;
  debuglink_size += 3;
  debuglink_size &= ~3;
  debuglink_size += 4;

  contents = malloc (debuglink_size);
  if (contents == NULL)
    {
      /* XXX Should we delete the section from the bfd ?  */
      bfd_set_error (bfd_error_no_memory);
      return FALSE;
    }

  strcpy (contents, filename);
  crc_offset = debuglink_size - 4;

  bfd_put_32 (abfd, crc32, contents + crc_offset);

  if (! bfd_set_section_contents (abfd, sect, contents, 0, debuglink_size))
    {
      /* XXX Should we delete the section from the bfd ?  */
      free (contents);
      return FALSE;
    }

  return TRUE;
}
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d50 1
a50 1
_bfd_new_bfd ()
d54 1
a54 1
  nbfd = (bfd *) bfd_zmalloc ((bfd_size_type) sizeof (bfd));
d60 1
a60 1
  nbfd->memory = (PTR) objalloc_create ();
d73 1
a73 2
  if (!bfd_hash_table_init_n (&nbfd->section_htab,
			      bfd_section_hash_newfunc,
d79 1
a79 1
  nbfd->sections = (asection *) NULL;
d82 1
a82 1
  nbfd->my_archive = (bfd *) NULL;
d87 1
a87 1
  nbfd->usrdata = (PTR) NULL;
d98 1
a98 2
_bfd_new_bfd_contained_in (obfd)
     bfd *obfd;
d115 1
a115 2
_bfd_delete_bfd (abfd)
     bfd *abfd;
d133 1
a133 1
	bfd *bfd_openr(const char *filename, const char *target);
d148 1
a148 3
bfd_openr (filename, target)
     const char *filename;
     const char *target;
d190 1
a190 1
	bfd *bfd_fdopenr(const char *filename, const char *target, int fd);
d203 1
a203 1
	is to assume no cacheing; the file descriptor will remain open
d212 1
a212 4
bfd_fdopenr (filename, target, fd)
     const char *filename;
     const char *target;
     int fd;
d239 1
a239 1
  nbfd->iostream = (PTR) fopen (filename, FOPEN_RB);
d244 3
a246 3
    case O_RDONLY: nbfd->iostream = (PTR) fdopen (fd, FOPEN_RB);   break;
    case O_WRONLY: nbfd->iostream = (PTR) fdopen (fd, FOPEN_RUB);  break;
    case O_RDWR:   nbfd->iostream = (PTR) fdopen (fd, FOPEN_RUB);  break;
d287 1
a287 1
	bfd *bfd_openstreamr(const char *, const char *, PTR);
d296 1
a296 4
bfd_openstreamr (filename, target, streamarg)
     const char *filename;
     const char *target;
     PTR streamarg;
d298 1
a298 1
  FILE *stream = (FILE *) streamarg;
d313 1
a313 1
  nbfd->iostream = (PTR) stream;
d336 1
a336 1
	bfd *bfd_openw(const char *filename, const char *target);
d347 1
a347 3
bfd_openw (filename, target)
     const char *filename;
     const char *target;
d405 1
a405 2
bfd_close (abfd)
     bfd *abfd;
d467 1
a467 2
bfd_close_all_done (abfd)
     bfd *abfd;
d502 1
a502 1
	bfd *bfd_create(const char *filename, bfd *templ);
d511 1
a511 3
bfd_create (filename, templ)
     const char *filename;
     bfd *templ;
d545 1
a545 2
bfd_make_writable(abfd)
     bfd *abfd;
d555 2
a556 3
  bim = ((struct bfd_in_memory *)
	 bfd_malloc ((bfd_size_type) sizeof (struct bfd_in_memory)));
  abfd->iostream = (PTR) bim;
d586 1
a586 2
bfd_make_readable(abfd)
     bfd *abfd;
d605 1
a605 1
  abfd->my_archive = (bfd *) NULL;
d610 1
a610 1
  abfd->usrdata = (PTR) NULL;
d633 1
a633 1
	PTR bfd_alloc (bfd *abfd, size_t wanted);
d641 2
a642 4
PTR
bfd_alloc (abfd, size)
     bfd *abfd;
     bfd_size_type size;
d644 1
a644 1
  PTR ret;
d658 2
a659 4
PTR
bfd_zalloc (abfd, size)
     bfd *abfd;
     bfd_size_type size;
d661 1
a661 1
  PTR res;
d673 1
a673 3
bfd_release (abfd, block)
     bfd *abfd;
     PTR block;
d693 1
a693 5
static unsigned long  calc_crc32                  PARAMS ((unsigned long, const unsigned char *, size_t));
static char *         get_debug_link_info         PARAMS ((bfd *, unsigned long *));
static bfd_boolean    separate_debug_file_exists  PARAMS ((const char *, const unsigned long));
static char *         find_separate_debug_file    PARAMS ((bfd *, const char *));

d695 2
a696 2
INTERNAL_FUNCTION
	calc_crc32
d699 2
a700 1
	unsigned long calc_crc32 (unsigned long crc, const unsigned char *buf, size_t len);
d703 6
a708 2
	Advance the CRC32 given by @@var{crc} through @@var{len}
	bytes of @@var{buf}. Return the updated CRC32 value.
d711 4
a714 5
static unsigned long
calc_crc32 (crc, buf, len)
     unsigned long crc;
     const unsigned char *buf;
     size_t len;
d785 1
a785 1
	char *get_debug_link_info (bfd *abfd, unsigned long *crc32_out)
d794 1
a794 3
get_debug_link_info (abfd, crc32_out)
     bfd *abfd;
     unsigned long *crc32_out;
d806 1
a806 1
  sect = bfd_get_section_by_name (abfd, ".gnu_debuglink");
d813 5
a817 3
  contents = xmalloc (debuglink_size);
  ret = bfd_get_section_contents (abfd, sect, contents,
				  (file_ptr)0, debuglink_size);
d828 1
a828 1
  crc32 = bfd_get_32 (abfd, (bfd_byte *) (contents + crc_offset));
d839 2
a840 1
	bfd_boolean separate_debug_file_exists (char * name, unsigned long crc32)
d848 1
a848 3
separate_debug_file_exists (name, crc)
     const char *name;
     const unsigned long crc;
d853 1
a853 1
  int count;
d862 1
a862 1
    file_crc = calc_crc32 (file_crc, buffer, count);
d875 1
a875 1
	char * find_separate_debug_file (bfd *abfd)
d887 1
a887 3
find_separate_debug_file (abfd, debug_file_directory)
     bfd *abfd;
     const char *debug_file_directory;
a903 1

d906 1
d913 6
a918 1
  dir = xstrdup (abfd->filename);
d925 1
a925 1
  
d929 11
a939 5
  debugfile = xmalloc (strlen (debug_file_directory) + 1
		       + strlen (dir)
		       + strlen (".debug/")
		       + strlen (basename) 
		       + 1);
d993 1
a993 1
	char * bfd_follow_gnu_debuglink(bfd *abfd, const char *dir);
d998 3
a1000 3
	section is found, examines the section for the name and checksum of
	a '.debug' file containing auxiliary debugging
	information. Searches filesystem for .debug file in some standard
d1002 5
a1006 2
	found returns the full filename. If @@var{dir} is NULL, will search
	default path configured into libbfd at build time.
d1011 1
a1011 1
	filename. The caller is responsible for freeing this string.
d1015 1
a1015 3
bfd_follow_gnu_debuglink (abfd, dir)
     bfd *abfd;
     const char * dir;
d1017 1
a1017 1
#if 0 /* Disabled until DEBUGDIR can be defined by configure.in  */
d1022 153
@


1.5
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2001
d8 1
a8 1
This file is part of BFD, the Binary File Descriptor library.
d10 13
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d28 1
d40 4
a46 3
/* FIXME: This is no longer used.  */
long _bfd_chunksize = -1;

d54 1
a54 1
  nbfd = (bfd *) bfd_zmalloc (sizeof (bfd));
d58 2
d64 1
d73 7
d81 1
d84 3
a86 3
  nbfd->origin = 0;				
  nbfd->opened_once = false;
  nbfd->output_has_begun = false;
d89 1
a89 1
  nbfd->cacheable = false;
d91 1
a91 1
  nbfd->mtime_set = false;
d105 2
d114 11
d136 1
a136 1
        bfd *bfd_openr(CONST char *filename, CONST char *target);
d146 2
a147 1
	are <<bfd_error_no_memory>>, <<bfd_error_invalid_target>> or <<system_call>> error.
d152 2
a153 2
     CONST char *filename;
     CONST char *target;
d165 1
a165 3
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
      bfd_set_error (bfd_error_invalid_target);
d174 1
a174 1
      /* File didn't exist, or some such */
d176 1
a176 2
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
d189 1
a189 2
       the file descriptor too, even though we didn't open it.
 */
d192 1
a192 1
         bfd_fdopenr
d195 1
a195 1
         bfd *bfd_fdopenr(CONST char *filename, CONST char *target, int fd);
d198 13
a210 5
         <<bfd_fdopenr>> is to <<bfd_fopenr>> much like <<fdopen>> is to <<fopen>>.
	 It opens a BFD on a file already described by the @@var{fd}
	 supplied.

	 When the file is later <<bfd_close>>d, the file descriptor will be closed.
d212 2
a213 10
	 If the caller desires that this file descriptor be cached by BFD
	 (opened as needed, closed as needed to free descriptors for
	 other opens), with the supplied @@var{fd} used as an initial
	 file descriptor (but subject to closure at any time), call
	 bfd_set_cacheable(bfd, 1) on the returned BFD.  The default is to
	 assume no cacheing; the file descriptor will remain open until
	 <<bfd_close>>, and will not be affected by BFD operations on other
	 files.

         Possible errors are <<bfd_error_no_memory>>, <<bfd_error_invalid_target>> and <<bfd_error_system_call>>.
d218 2
a219 2
     CONST char *filename;
     CONST char *target;
d228 1
a228 1
  fdflags = O_RDWR;			/* Assume full access */
d232 2
a233 1
  if (fdflags == -1) return NULL;
d242 1
a242 3
      bfd_set_error (bfd_error_invalid_target);
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
d249 1
a249 1
  /* (O_ACCMODE) parens are to avoid Ultrix header file bug */
d261 1
a261 2
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
d265 1
a265 2
  /* OK, put everything where it belongs */

d271 1
a271 1
  /* (O_ACCMODE) parens are to avoid Ultrix header file bug */
d282 1
a282 2
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
d285 1
a285 1
  nbfd->opened_once = true;
d320 1
a320 3
      bfd_set_error (bfd_error_invalid_target);
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
d327 1
a327 1
				
d330 1
a330 2
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
d337 2
a338 2
/** bfd_openw -- open for writing.
  Returns a pointer to a freshly-allocated BFD on success, or NULL.
d340 1
a340 1
  See comment by bfd_fdopenr before you try to modify this function. */
d347 1
a347 1
	bfd *bfd_openw(CONST char *filename, CONST char *target);
d359 2
a360 2
     CONST char *filename;
     CONST char *target;
a364 2
  bfd_set_error (bfd_error_system_call);

d366 1
a366 2
     reclaim it correctly. */

d374 1
a374 2
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
d383 3
a385 3
      bfd_set_error (bfd_error_system_call);	/* File not writeable, etc */
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
d398 1
a398 1
	boolean bfd_close(bfd *abfd);
d402 4
a405 4
	Close a BFD. If the BFD was open for writing,
	then pending operations are completed and the file written out
	and closed. If the created file is executable, then
	<<chmod>> is called to mark it as such.
d413 1
a413 1
	<<true>> is returned if all is ok, otherwise <<false>>.
d417 1
a417 1
boolean
d421 1
a421 1
  boolean ret;
d423 1
a423 1
  if (!bfd_read_p (abfd))
d426 1
a426 1
	return false;
d430 1
a430 1
    return false;
d435 1
a435 1
     make it so */
d444 2
a445 1
 	  int mask = umask (0);
d453 1
a453 2
  objalloc_free ((struct objalloc *) abfd->memory);
  free (abfd);
d463 1
a463 1
	boolean bfd_close_all_done(bfd *);
d466 4
a469 4
	Close a BFD.  Differs from <<bfd_close>>
	since it does not complete any pending operations.  This
	routine would be used if the application had just used BFD for
	swapping and didn't want to use any of the writing code.
d477 1
a477 2
	<<true>> is returned if all is ok, otherwise <<false>>.

d480 1
a480 1
boolean
d484 1
a484 1
  boolean ret;
d489 1
a489 1
     make it so */
d498 2
a499 1
	  int mask = umask (0);
d507 1
a507 2
  objalloc_free ((struct objalloc *) abfd->memory);
  free (abfd);
d517 1
a517 1
	bfd *bfd_create(CONST char *filename, bfd *templ);
d520 3
a522 5
	Create a new BFD in the manner of
	<<bfd_openw>>, but without opening a file. The new BFD
	takes the target from the target used by @@var{template}. The
	format is always set to <<bfd_object>>.

d527 1
a527 1
     CONST char *filename;
d540 1
d549 1
a549 1
	boolean bfd_make_writable(bfd *abfd);
d558 1
a558 1
	<<true>> is returned if all is ok, otherwise <<false>>.
d561 1
a561 1
boolean
d570 1
a570 1
      return false;
d573 2
a574 1
  bim = (struct bfd_in_memory *) bfd_malloc (sizeof (struct bfd_in_memory));
d576 1
a576 1
  /* bfd_write will grow these as needed */
d584 1
a584 1
  return true;
d592 1
a592 1
	boolean bfd_make_readable(bfd *abfd);
d602 1
a602 1
	<<true>> is returned if all is ok, otherwise <<false>>.  */
d604 1
a604 1
boolean
d611 1
a611 1
      return false;
d615 1
a615 1
    return false;
d618 1
a618 1
    return false;
a623 1
  abfd->sections = (asection *) NULL;
d626 3
a628 3
  abfd->origin = 0;				
  abfd->opened_once = false;
  abfd->output_has_begun = false;
d631 1
a631 1
  abfd->cacheable = false;
d633 1
a633 1
  abfd->mtime_set = false;
d635 1
a635 1
  abfd->target_defaulted = true;
d642 2
a643 1
  bfd_check_format(abfd, bfd_object);
d645 1
a645 1
  return true;
d664 1
a664 1
     size_t size;
d668 6
d683 1
a683 1
     size_t size;
d689 1
a689 1
    memset (res, 0, size);
d693 2
a694 1
/* Free a block allocated for a BFD.  */
d702 337
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 1997
d252 1
a252 1
  switch (fdflags & O_ACCMODE)
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2 3
a4 1
   Copyright (C) 1990 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d25 1
a26 1
#include "obstack.h"
d41 1
a41 8

#define obstack_chunk_alloc malloc
#define obstack_chunk_free free

#ifndef HAVE_GETPAGESIZE
#define getpagesize()	2048
#endif

d51 3
a53 14
  nbfd = (bfd *)bfd_zmalloc (sizeof (bfd));
  if (!nbfd)
    return 0;

  if (_bfd_chunksize <= 0)
    {
      _bfd_chunksize = getpagesize ();
      if (_bfd_chunksize <= 0)
	_bfd_chunksize = 2048;
      /* Leave some slush space, since many malloc implementations
	 prepend a header, and may wind up wasting another page
	 because of it.  */
      _bfd_chunksize -= 32;
    }
d55 2
a56 1
  if (!obstack_begin(&nbfd->memory, _bfd_chunksize))
d59 1
a59 1
      return 0;
d67 1
a67 1
  nbfd->sections = (asection *)NULL;
d69 1
a69 1
  nbfd->my_archive = (bfd *)NULL;
d74 1
a74 1
  nbfd->usrdata = (PTR)NULL;
d90 1
a90 1
  nbfd = _bfd_new_bfd();
d130 1
a130 1
  nbfd = _bfd_new_bfd();
d135 7
a141 4
  if (target_vec == NULL) {
    bfd_set_error (bfd_error_invalid_target);
    return NULL;
  }
d146 9
a154 5
  if (bfd_open_file (nbfd) == NULL) {
    bfd_set_error (bfd_error_system_call);	/* File didn't exist, or some such */
    bfd_release(nbfd,0);
    return NULL;
  }
a157 1

d210 1
a210 2
  nbfd = _bfd_new_bfd();

d215 10
a224 6
  if (target_vec == NULL) {
    bfd_set_error (bfd_error_invalid_target);
    return NULL;
  }
#if defined(VMS) || defined(__GO32__)
  nbfd->iostream = (PTR)fopen(filename, FOPEN_RB);
d227 7
a233 6
  switch (fdflags & (O_ACCMODE)) {
  case O_RDONLY: nbfd->iostream = (PTR) fdopen (fd, FOPEN_RB);   break;
  case O_WRONLY: nbfd->iostream = (PTR) fdopen (fd, FOPEN_RUB);  break;
  case O_RDWR:   nbfd->iostream = (PTR) fdopen (fd, FOPEN_RUB);  break;
  default: abort ();
  }
d235 7
a241 4
  if (nbfd->iostream == NULL) {
    (void) obstack_free (&nbfd->memory, (PTR)0);
    return NULL;
  }
d251 8
a258 7
  switch (fdflags & (O_ACCMODE)) {
  case O_RDONLY: nbfd->direction = read_direction; break;
  case O_WRONLY: nbfd->direction = write_direction; break;
  case O_RDWR: nbfd->direction = both_direction; break;
  default: abort ();
  }
				
d260 5
a264 1
    return NULL;
d275 1
a275 1
	bfd *bfd_openstreamr();
d284 1
a284 1
bfd_openstreamr (filename, target, stream)
d287 1
a287 1
     FILE *stream;
d289 1
d301 2
d311 5
a315 1
    return NULL;
d353 1
a353 1
  nbfd = _bfd_new_bfd();
d358 6
a363 1
  if (target_vec == NULL) return NULL;
d368 6
a373 4
  if (bfd_open_file (nbfd) == NULL) {
    bfd_set_error (bfd_error_system_call);	/* File not writeable, etc */
    (void) obstack_free (&nbfd->memory, (PTR)0);
    return NULL;
d375 1
d394 1
a394 1
	All memory attached to the BFD's obstacks is released.
d439 2
a440 2
  (void) obstack_free (&abfd->memory, (PTR)0);
  (void) free (abfd);
d461 1
a461 1
	All memory attached to the BFD's obstacks is released.
d489 1
a489 1
		 (0x777
a492 4
  (void) obstack_free (&abfd->memory, (PTR)0);
  (void) free(abfd);
  return ret;
}
d494 2
d497 1
a497 23
/*
FUNCTION	
	bfd_alloc_size

SYNOPSIS
	bfd_size_type bfd_alloc_size(bfd *abfd);

DESCRIPTION
        Return the number of bytes in the obstacks connected to @@var{abfd}.

*/

bfd_size_type
bfd_alloc_size (abfd)
     bfd *abfd;
{
  struct _obstack_chunk *chunk = abfd->memory.chunk;
  size_t size = 0;
  while (chunk) {
    size += chunk->limit - &(chunk->contents[0]);
    chunk = chunk->prev;
  }
  return size;
a499 2


d520 5
a524 3
  bfd *nbfd = _bfd_new_bfd();
  if (nbfd == (bfd *)NULL)
    return (bfd *)NULL;
d526 1
a526 1
  if(templ) {
a527 1
  }
d529 1
a529 1
  bfd_set_format(nbfd, bfd_object);
d534 2
a535 2
INTERNAL_FUNCTION
	bfd_alloc_by_size_t
d538 1
a538 1
	PTR bfd_alloc_by_size_t(bfd *abfd, size_t wanted);
d541 7
a547 2
	Allocate a block of @@var{wanted} bytes of memory in the obstack
	attatched to <<abfd>> and return a pointer to it.
d550 2
a551 3

PTR
bfd_alloc_by_size_t (abfd, size)
a552 1
     size_t size;
d554 17
a570 1
  PTR ret;
d572 1
a572 4
  ret = obstack_alloc (&(abfd->memory), size);
  if (ret == NULL)
    bfd_set_error (bfd_error_no_memory);
  return ret;
d575 19
a593 2
void
bfd_alloc_grow (abfd, ptr, size)
a594 2
     PTR ptr;
     size_t size;
d596 38
a633 1
  (void) obstack_grow(&(abfd->memory), ptr, size);
d636 13
d650 1
a650 1
bfd_alloc_finish (abfd)
d652 1
d656 1
a656 1
  ret = obstack_finish (&(abfd->memory));
d663 1
a663 1
bfd_alloc (abfd, size)
d667 6
a672 1
  return bfd_alloc_by_size_t(abfd, (size_t)size);
d675 4
a678 2
PTR
bfd_zalloc (abfd, size)
d680 1
a680 1
     size_t size;
d682 1
a682 5
  PTR res;
  res = bfd_alloc(abfd, size);
  if (res)
    memset(res, 0, (size_t)size);
  return res;
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d91 1
a91 1
  nbfd->flags = NO_FLAGS;
d229 1
a229 1
#if defined(VMS) || defined(__GO32__) || defined (WINGDB)
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1990 91, 92, 93, 94, 1995 Free Software Foundation, Inc.
d58 1
a58 4
    {
      bfd_set_error (bfd_error_no_memory);
      return 0;
    }
d146 1
a146 2
  if (nbfd == NULL) {
    bfd_set_error (bfd_error_no_memory);
a147 1
  }
d221 1
a221 2
  if (nbfd == NULL) {
    bfd_set_error (bfd_error_no_memory);
a222 1
  }
d230 1
a230 1
  nbfd->iostream = (char *)fopen(filename, FOPEN_RB);
d234 3
a236 3
  case O_RDONLY: nbfd->iostream = (char *) fdopen (fd, FOPEN_RB);   break;
  case O_WRONLY: nbfd->iostream = (char *) fdopen (fd, FOPEN_RUB);  break;
  case O_RDWR:   nbfd->iostream = (char *) fdopen (fd, FOPEN_RUB);  break;
d262 1
d291 1
a291 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d300 1
a300 1
  nbfd->iostream = (char *) stream;
d344 1
a344 2
  if (nbfd == NULL) {
    bfd_set_error (bfd_error_no_memory);
a345 1
  }
d529 1
a529 2
  if (nbfd == (bfd *)NULL) {
    bfd_set_error (bfd_error_no_memory);
a530 1
  }
d558 6
a563 1
  return obstack_alloc(&(abfd->memory), size);
d579 6
a584 1
  return obstack_finish(&(abfd->memory));
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright (C) 1990 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d58 4
a61 1
    return 0;
d149 2
a150 1
  if (nbfd == NULL)
d152 1
d226 2
a227 1
  if (nbfd == NULL)
d229 1
d237 1
a237 1
  nbfd->iostream = (PTR)fopen(filename, FOPEN_RB);
d241 3
a243 3
  case O_RDONLY: nbfd->iostream = (PTR) fdopen (fd, FOPEN_RB);   break;
  case O_WRONLY: nbfd->iostream = (PTR) fdopen (fd, FOPEN_RUB);  break;
  case O_RDWR:   nbfd->iostream = (PTR) fdopen (fd, FOPEN_RUB);  break;
a268 1
  nbfd->opened_once = true;
d297 4
a300 1
    return NULL;
d309 1
a309 1
  nbfd->iostream = (PTR) stream;
d353 2
a354 1
  if (nbfd == NULL)
d356 1
d540 2
a541 1
  if (nbfd == (bfd *)NULL)
d543 1
d571 1
a571 6
  PTR ret;

  ret = obstack_alloc (&(abfd->memory), size);
  if (ret == NULL)
    bfd_set_error (bfd_error_no_memory);
  return ret;
d587 1
a587 6
  PTR ret;

  ret = obstack_finish (&(abfd->memory));
  if (ret == NULL)
    bfd_set_error (bfd_error_no_memory);
  return ret;
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d91 1
a91 1
  nbfd->flags = BFD_NO_FLAGS;
d229 1
a229 1
#if defined(VMS) || defined(__GO32__)
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 3
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 1997
   Free Software Foundation, Inc.

a22 1
#include "objalloc.h"
d24 1
d39 8
a46 1
/* FIXME: This is no longer used.  */
d56 14
a69 3
  nbfd = (bfd *) bfd_zmalloc (sizeof (bfd));
  if (nbfd == NULL)
    return NULL;
d71 1
a71 2
  nbfd->memory = (PTR) objalloc_create ();
  if (nbfd->memory == NULL)
d74 1
a74 1
      return NULL;
d82 1
a82 1
  nbfd->sections = (asection *) NULL;
d84 1
a84 1
  nbfd->my_archive = (bfd *) NULL;
d89 1
a89 1
  nbfd->usrdata = (PTR) NULL;
d105 1
a105 1
  nbfd = _bfd_new_bfd ();
d145 1
a145 1
  nbfd = _bfd_new_bfd ();
d150 4
a153 7
  if (target_vec == NULL)
    {
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
      bfd_set_error (bfd_error_invalid_target);
      return NULL;
    }
d158 5
a162 9
  if (bfd_open_file (nbfd) == NULL)
    {
      /* File didn't exist, or some such */
      bfd_set_error (bfd_error_system_call);
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
      return NULL;
    }

d166 1
d219 2
a220 1
  nbfd = _bfd_new_bfd ();
d225 4
a228 8
  if (target_vec == NULL)
    {
      bfd_set_error (bfd_error_invalid_target);
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
      return NULL;
    }

d240 4
a243 7

  if (nbfd->iostream == NULL)
    {
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
      return NULL;
    }
d253 7
a259 8
  switch (fdflags & O_ACCMODE)
    {
    case O_RDONLY: nbfd->direction = read_direction; break;
    case O_WRONLY: nbfd->direction = write_direction; break;
    case O_RDWR: nbfd->direction = both_direction; break;
    default: abort ();
    }

d261 1
a261 5
    {
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
      return NULL;
    }
d272 1
a272 1
	bfd *bfd_openstreamr(const char *, const char *, PTR);
d281 1
a281 1
bfd_openstreamr (filename, target, streamarg)
d284 1
a284 1
     PTR streamarg;
a285 1
  FILE *stream = (FILE *) streamarg;
a296 2
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
d305 1
a305 5
    {
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
      return NULL;
    }
d343 1
a343 1
  nbfd = _bfd_new_bfd ();
d348 1
a348 6
  if (target_vec == NULL)
    {
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
      return NULL;
    }
d353 4
a356 6
  if (bfd_open_file (nbfd) == NULL)
    {
      bfd_set_error (bfd_error_system_call);	/* File not writeable, etc */
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
      return NULL;
a357 1

d376 1
a376 1
	All memory attached to the BFD is released.
d421 2
a422 2
  objalloc_free ((struct objalloc *) abfd->memory);
  free (abfd);
d443 1
a443 1
	All memory attached to the BFD is released.
d475 9
d485 5
a489 2
  objalloc_free ((struct objalloc *) abfd->memory);
  free (abfd);
d491 13
a503 1
  return ret;
d506 2
d528 3
a530 5
  bfd *nbfd;

  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    return NULL;
d532 1
a532 1
  if (templ)
d534 1
d536 1
a536 1
  bfd_set_format (nbfd, bfd_object);
d542 1
a542 1
	bfd_alloc
d545 1
a545 1
	PTR bfd_alloc (bfd *abfd, size_t wanted);
d548 2
a549 2
	Allocate a block of @@var{wanted} bytes of memory attached to
	<<abfd>> and return a pointer to it.
d554 1
a554 1
bfd_alloc (abfd, size)
d560 1
a560 1
  ret = objalloc_alloc (abfd->memory, (unsigned long) size);
d566 9
d576 1
a576 1
bfd_zalloc (abfd, size)
a577 1
     size_t size;
d579 1
a579 1
  PTR res;
d581 4
a584 4
  res = bfd_alloc (abfd, size);
  if (res)
    memset (res, 0, size);
  return res;
d587 7
a593 1
/* Free a block allocated for a BFD.  */
d595 2
a596 2
void
bfd_release (abfd, block)
d598 1
a598 1
     PTR block;
d600 5
a604 1
  objalloc_free_block ((struct objalloc *) abfd->memory, block);
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d223 2
a224 2
#ifndef HAVE_FDOPEN
  nbfd->iostream = (PTR) fopen (filename, FOPEN_RB);
d227 6
a232 7
  switch (fdflags & (O_ACCMODE))
    {
    case O_RDONLY: nbfd->iostream = (PTR) fdopen (fd, FOPEN_RB);   break;
    case O_WRONLY: nbfd->iostream = (PTR) fdopen (fd, FOPEN_RUB);  break;
    case O_RDWR:   nbfd->iostream = (PTR) fdopen (fd, FOPEN_RUB);  break;
    default: abort ();
    }
d488 1
a488 1
		 (0777
a529 103
}

/*
FUNCTION
	bfd_make_writable

SYNOPSIS
	boolean bfd_make_writable(bfd *abfd);

DESCRIPTION
	Takes a BFD as created by <<bfd_create>> and converts it
	into one like as returned by <<bfd_openw>>.  It does this
	by converting the BFD to BFD_IN_MEMORY.  It's assumed that
	you will call <<bfd_make_readable>> on this bfd later.

RETURNS
	<<true>> is returned if all is ok, otherwise <<false>>.
*/

boolean
bfd_make_writable(abfd)
     bfd *abfd;
{
  struct bfd_in_memory *bim;

  if (abfd->direction != no_direction)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return false;
    }

  bim = (struct bfd_in_memory *) bfd_malloc (sizeof (struct bfd_in_memory));
  abfd->iostream = (PTR) bim;
  /* bfd_write will grow these as needed */
  bim->size = 0;
  bim->buffer = 0;

  abfd->flags |= BFD_IN_MEMORY;
  abfd->direction = write_direction;
  abfd->where = 0;

  return true;
}

/*
FUNCTION
	bfd_make_readable

SYNOPSIS
	boolean bfd_make_readable(bfd *abfd);

DESCRIPTION
	Takes a BFD as created by <<bfd_create>> and
	<<bfd_make_writable>> and converts it into one like as
	returned by <<bfd_openr>>.  It does this by writing the
	contents out to the memory buffer, then reversing the
	direction.

RETURNS
	<<true>> is returned if all is ok, otherwise <<false>>.  */

boolean
bfd_make_readable(abfd)
     bfd *abfd;
{
  if (abfd->direction != write_direction || !(abfd->flags & BFD_IN_MEMORY))
    {
      bfd_set_error (bfd_error_invalid_operation);
      return false;
    }

  if (! BFD_SEND_FMT (abfd, _bfd_write_contents, (abfd)))
    return false;

  if (! BFD_SEND (abfd, _close_and_cleanup, (abfd)))
    return false;


  abfd->arch_info = &bfd_default_arch_struct;

  abfd->where = 0;
  abfd->sections = (asection *) NULL;
  abfd->format = bfd_unknown;
  abfd->my_archive = (bfd *) NULL;
  abfd->origin = 0;				
  abfd->opened_once = false;
  abfd->output_has_begun = false;
  abfd->section_count = 0;
  abfd->usrdata = (PTR) NULL;
  abfd->cacheable = false;
  abfd->flags = BFD_IN_MEMORY;
  abfd->mtime_set = false;

  abfd->target_defaulted = true;
  abfd->direction = read_direction;
  abfd->sections = 0;
  abfd->symcount = 0;
  abfd->outsymbols = 0;
  abfd->tdata.any = 0;

  bfd_check_format(abfd, bfd_object);

  return true;
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000,
   2001
d251 1
a251 1
  switch (fdflags & (O_ACCMODE))
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2001, 2002, 2003
d8 1
a8 1
   This file is part of BFD, the Binary File Descriptor library.
d10 13
a22 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a27 1
#include "libiberty.h"
a38 4
/* Counter used to initialize the bfd identifier.  */

static unsigned int _bfd_id_counter = 0;

d42 3
d52 1
a52 1
  nbfd = (bfd *) bfd_zmalloc ((bfd_size_type) sizeof (bfd));
a55 2
  nbfd->id = _bfd_id_counter++;

a59 1
      free (nbfd);
a67 7
  if (!bfd_hash_table_init_n (&nbfd->section_htab,
			      bfd_section_hash_newfunc,
			      251))
    {
      free (nbfd);
      return NULL;
    }
a68 1
  nbfd->section_tail = &nbfd->sections;
d71 3
a73 3
  nbfd->origin = 0;
  nbfd->opened_once = FALSE;
  nbfd->output_has_begun = FALSE;
d76 1
a76 1
  nbfd->cacheable = FALSE;
d78 1
a78 1
  nbfd->mtime_set = FALSE;
a91 2
  if (nbfd == NULL)
    return NULL;
a98 11
/* Delete a BFD.  */

void
_bfd_delete_bfd (abfd)
     bfd *abfd;
{
  bfd_hash_table_free (&abfd->section_htab);
  objalloc_free ((struct objalloc *) abfd->memory);
  free (abfd);
}

d110 1
a110 1
	bfd *bfd_openr(const char *filename, const char *target);
d120 1
a120 2
	are <<bfd_error_no_memory>>, <<bfd_error_invalid_target>> or
	<<system_call>> error.
d125 2
a126 2
     const char *filename;
     const char *target;
d138 3
a140 1
      _bfd_delete_bfd (nbfd);
d149 1
a149 1
      /* File didn't exist, or some such.  */
d151 2
a152 1
      _bfd_delete_bfd (nbfd);
d165 2
a166 1
       the file descriptor too, even though we didn't open it.  */
d169 1
a169 1
	bfd_fdopenr
d172 1
a172 1
	bfd *bfd_fdopenr(const char *filename, const char *target, int fd);
d175 5
a179 13
	<<bfd_fdopenr>> is to <<bfd_fopenr>> much like <<fdopen>> is to
	<<fopen>>.  It opens a BFD on a file already described by the
	@@var{fd} supplied.

	When the file is later <<bfd_close>>d, the file descriptor will
	be closed.  If the caller desires that this file descriptor be
	cached by BFD (opened as needed, closed as needed to free
	descriptors for other opens), with the supplied @@var{fd} used as
	an initial file descriptor (but subject to closure at any time),
	call bfd_set_cacheable(bfd, 1) on the returned BFD.  The default
	is to assume no cacheing; the file descriptor will remain open
	until <<bfd_close>>, and will not be affected by BFD operations
	on other files.
d181 10
a190 2
	Possible errors are <<bfd_error_no_memory>>,
	<<bfd_error_invalid_target>> and <<bfd_error_system_call>>.
d195 2
a196 2
     const char *filename;
     const char *target;
d205 1
a205 1
  fdflags = O_RDWR;			/* Assume full access.  */
d209 1
a209 2
  if (fdflags == -1)
    return NULL;
d218 3
a220 1
      _bfd_delete_bfd (nbfd);
d227 1
a227 1
  /* (O_ACCMODE) parens are to avoid Ultrix header file bug.  */
d239 2
a240 1
      _bfd_delete_bfd (nbfd);
d244 2
a245 1
  /* OK, put everything where it belongs.  */
d251 1
a251 1
  /* (O_ACCMODE) parens are to avoid Ultrix header file bug.  */
d262 2
a263 1
      _bfd_delete_bfd (nbfd);
d266 1
a266 1
  nbfd->opened_once = TRUE;
d301 3
a303 1
      _bfd_delete_bfd (nbfd);
d310 1
a310 1

d313 2
a314 1
      _bfd_delete_bfd (nbfd);
d321 2
a322 2
/* bfd_openw -- open for writing.
   Returns a pointer to a freshly-allocated BFD on success, or NULL.
d324 1
a324 1
   See comment by bfd_fdopenr before you try to modify this function.  */
d331 1
a331 1
	bfd *bfd_openw(const char *filename, const char *target);
d343 2
a344 2
     const char *filename;
     const char *target;
d349 2
d352 2
a353 1
     reclaim it correctly.  */
d361 2
a362 1
      _bfd_delete_bfd (nbfd);
d371 3
a373 3
      /* File not writeable, etc.  */
      bfd_set_error (bfd_error_system_call);
      _bfd_delete_bfd (nbfd);
d386 1
a386 1
	bfd_boolean bfd_close (bfd *abfd);
d390 4
a393 4
	Close a BFD. If the BFD was open for writing, then pending
	operations are completed and the file written out and closed.
	If the created file is executable, then <<chmod>> is called
	to mark it as such.
d401 1
a401 1
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.
d405 1
a405 1
bfd_boolean
d409 1
a409 1
  bfd_boolean ret;
d411 1
a411 1
  if (bfd_write_p (abfd))
d414 1
a414 1
	return FALSE;
d418 1
a418 1
    return FALSE;
d423 1
a423 1
     make it so.  */
d432 1
a432 2
	  unsigned int mask = umask (0);

d440 2
a441 1
  _bfd_delete_bfd (abfd);
d451 1
a451 1
	bfd_boolean bfd_close_all_done (bfd *);
d454 4
a457 4
	Close a BFD.  Differs from <<bfd_close>> since it does not
	complete any pending operations.  This routine would be used
	if the application had just used BFD for swapping and didn't
	want to use any of the writing code.
d465 2
a466 1
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.
d469 1
a469 1
bfd_boolean
d473 1
a473 1
  bfd_boolean ret;
d478 1
a478 1
     make it so.  */
d487 1
a487 2
	  unsigned int mask = umask (0);

d495 2
a496 1
  _bfd_delete_bfd (abfd);
d506 1
a506 1
	bfd *bfd_create(const char *filename, bfd *templ);
d509 5
a513 3
	Create a new BFD in the manner of <<bfd_openw>>, but without
	opening a file. The new BFD takes the target from the target
	used by @@var{template}. The format is always set to <<bfd_object>>.
d518 1
a518 1
     const char *filename;
a530 1

d539 1
a539 1
	bfd_boolean bfd_make_writable (bfd *abfd);
d548 1
a548 1
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.
d551 1
a551 1
bfd_boolean
d560 1
a560 1
      return FALSE;
d563 1
a563 2
  bim = ((struct bfd_in_memory *)
	 bfd_malloc ((bfd_size_type) sizeof (struct bfd_in_memory)));
d565 1
a565 1
  /* bfd_bwrite will grow these as needed.  */
d573 1
a573 1
  return TRUE;
d581 1
a581 1
	bfd_boolean bfd_make_readable (bfd *abfd);
d591 1
a591 1
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.  */
d593 1
a593 1
bfd_boolean
d600 1
a600 1
      return FALSE;
d604 1
a604 1
    return FALSE;
d607 1
a607 1
    return FALSE;
d613 1
d616 3
a618 3
  abfd->origin = 0;
  abfd->opened_once = FALSE;
  abfd->output_has_begun = FALSE;
d621 1
a621 1
  abfd->cacheable = FALSE;
d623 1
a623 1
  abfd->mtime_set = FALSE;
d625 1
a625 1
  abfd->target_defaulted = TRUE;
d632 1
a632 2
  bfd_section_list_clear (abfd);
  bfd_check_format (abfd, bfd_object);
d634 1
a634 1
  return TRUE;
d653 1
a653 1
     bfd_size_type size;
a656 6
  if (size != (unsigned long) size)
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

d666 1
a666 1
     bfd_size_type size;
d672 1
a672 1
    memset (res, 0, (size_t) size);
d676 1
a676 2
/* Free a block allocated for a BFD.
   Note:  Also frees all more recently allocated blocks!  */
a683 337
}


/* 
   GNU Extension: separate debug-info files 
   
   The idea here is that a special section called .gnu_debuglink might be
   embedded in a binary file, which indicates that some *other* file
   contains the real debugging information. This special section contains a
   filename and CRC32 checksum, which we read and resolve to another file,
   if it exists.

   This facilitates "optional" provision of debugging information, without
   having to provide two complete copies of every binary object (with and
   without debug symbols).
*/

static unsigned long  calc_crc32                  PARAMS ((unsigned long, const unsigned char *, size_t));
static char *         get_debug_link_info         PARAMS ((bfd *, unsigned long *));
static bfd_boolean    separate_debug_file_exists  PARAMS ((const char *, const unsigned long));
static char *         find_separate_debug_file    PARAMS ((bfd *, const char *));

/*
INTERNAL_FUNCTION
	calc_crc32

SYNOPSIS
	unsigned long calc_crc32 (unsigned long crc, const unsigned char *buf, size_t len);

DESCRIPTION
	Advance the CRC32 given by @@var{crc} through @@var{len}
	bytes of @@var{buf}. Return the updated CRC32 value.
*/     

static unsigned long
calc_crc32 (crc, buf, len)
     unsigned long crc;
     const unsigned char *buf;
     size_t len;
{
  static const unsigned long crc32_table[256] =
    {
      0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
      0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
      0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
      0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
      0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
      0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
      0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
      0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
      0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
      0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
      0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
      0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
      0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
      0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
      0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
      0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
      0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
      0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
      0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
      0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
      0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
      0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
      0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
      0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
      0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
      0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
      0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
      0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
      0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
      0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
      0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
      0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
      0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
      0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
      0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
      0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
      0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
      0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
      0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
      0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
      0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
      0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
      0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
      0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
      0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
      0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
      0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
      0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
      0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
      0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
      0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
      0x2d02ef8d
    };
  const unsigned char *end;

  crc = ~crc & 0xffffffff;
  for (end = buf + len; buf < end; ++ buf)
    crc = crc32_table[(crc ^ *buf) & 0xff] ^ (crc >> 8);
  return ~crc & 0xffffffff;;
}


/*
INTERNAL_FUNCTION
	get_debug_link_info

SYNOPSIS
	char *get_debug_link_info (bfd *abfd, unsigned long *crc32_out)

DESCRIPTION
	fetch the filename and CRC32 value for any separate debuginfo
	associated with @@var{abfd}. Return NULL if no such info found,
	otherwise return filename and update @@var{crc32_out}.
*/

static char *
get_debug_link_info (abfd, crc32_out)
     bfd *abfd;
     unsigned long *crc32_out;
{
  asection * sect;
  bfd_size_type debuglink_size;
  unsigned long crc32;
  char * contents;
  int crc_offset;
  bfd_boolean ret;

  BFD_ASSERT (abfd);
  BFD_ASSERT (crc32_out);

  sect = bfd_get_section_by_name (abfd, ".gnu_debuglink");

  if (sect == NULL)
    return NULL;

  debuglink_size = bfd_section_size (abfd, sect);  

  contents = xmalloc (debuglink_size);
  ret = bfd_get_section_contents (abfd, sect, contents,
				  (file_ptr)0, debuglink_size);
  if (! ret)
    {
      free (contents);
      return NULL;
    }

  /* Crc value is stored after the filename, aligned up to 4 bytes.  */
  crc_offset = strlen (contents) + 1;
  crc_offset = (crc_offset + 3) & ~3;

  crc32 = bfd_get_32 (abfd, (bfd_byte *) (contents + crc_offset));

  *crc32_out = crc32;
  return contents;
}

/*
INTERNAL_FUNCTION
	separate_debug_file_exists

SYNOPSIS
	bfd_boolean separate_debug_file_exists (char * name, unsigned long crc32)

DESCRIPTION
	Checks to see if @@var{name} is a file and if its contents
	match @@var{crc32}.
*/

static bfd_boolean
separate_debug_file_exists (name, crc)
     const char *name;
     const unsigned long crc;
{
  static char buffer [8 * 1024];
  unsigned long file_crc = 0;
  int fd;
  int count;

  BFD_ASSERT (name);

  fd = open (name, O_RDONLY);
  if (fd < 0)
    return FALSE;

  while ((count = read (fd, buffer, sizeof (buffer))) > 0)
    file_crc = calc_crc32 (file_crc, buffer, count);

  close (fd);

  return crc == file_crc;
}


/*
INTERNAL_FUNCTION
	find_separate_debug_file

SYNOPSIS
	char * find_separate_debug_file (bfd *abfd)

DESCRIPTION
	Searches @@var{abfd} for a reference to separate debugging
	information, scans various locations in the filesystem, including
	the file tree rooted at @@var{debug_file_directory}, and returns a
	filename of such debugging information if the file is found and has
	matching CRC32.  Returns NULL if no reference to debugging file
	exists, or file cannot be found.
*/

static char *
find_separate_debug_file (abfd, debug_file_directory)
     bfd *abfd;
     const char *debug_file_directory;
{
  char *basename;
  char *dir;
  char *debugfile;
  unsigned long crc32;
  int i;

  BFD_ASSERT (abfd);
  if (debug_file_directory == NULL)
    debug_file_directory = ".";

  /* BFD may have been opened from a stream.  */
  if (! abfd->filename)
    return NULL;

  basename = get_debug_link_info (abfd, & crc32);

  if (basename == NULL)
    return NULL;
  if (strlen (basename) < 1)
    {
      free (basename);
      return NULL;
    }

  dir = xstrdup (abfd->filename);
  BFD_ASSERT (strlen (dir) != 0);
  
  /* Strip off filename part.  */
  for (i = strlen (dir) - 1; i >= 0; i--)
    if (IS_DIR_SEPARATOR (dir[i]))
      break;
  
  dir[i + 1] = '\0';
  BFD_ASSERT (dir[i] == '/' || dir[0] == '\0')

  debugfile = xmalloc (strlen (debug_file_directory) + 1
		       + strlen (dir)
		       + strlen (".debug/")
		       + strlen (basename) 
		       + 1);

  /* First try in the same directory as the original file:  */
  strcpy (debugfile, dir);
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      free (basename);
      free (dir);
      return debugfile;
    }

  /* Then try in a subdirectory called .debug.  */
  strcpy (debugfile, dir);
  strcat (debugfile, ".debug/");
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      free (basename);
      free (dir);
      return debugfile;
    }

  /* Then try in the global debugfile directory.  */
  strcpy (debugfile, debug_file_directory);
  i = strlen (debug_file_directory) - 1;
  if (i > 0
      && debug_file_directory[i] != '/'
      && dir[0] != '/')
    strcat (debugfile, "/");
  strcat (debugfile, dir);
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      free (basename);
      free (dir);
      return debugfile;
    }

  free (debugfile);
  free (basename);
  free (dir);
  return NULL;
}


/*
FUNCTION
	bfd_follow_gnu_debuglink

SYNOPSIS
	char * bfd_follow_gnu_debuglink(bfd *abfd, const char *dir);

DESCRIPTION

	Takes a BFD and searches it for a .gnu_debuglink section.  If this
	section is found, examines the section for the name and checksum of
	a '.debug' file containing auxiliary debugging
	information. Searches filesystem for .debug file in some standard
	locations, including the directory tree rooted at @@var{dir}, and if
	found returns the full filename. If @@var{dir} is NULL, will search
	default path configured into libbfd at build time.

RETURNS
	<<NULL>> on any errors or failure to locate the .debug file,
	otherwise a pointer to a heap-allocated string containing the
	filename. The caller is responsible for freeing this string.
*/

char *
bfd_follow_gnu_debuglink (abfd, dir)
     bfd *abfd;
     const char * dir;
{
#if 0 /* Disabled until DEBUGDIR can be defined by configure.in  */
  if (dir == NULL)
    dir = DEBUGDIR;
#endif
  return find_separate_debug_file (abfd, dir);
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d50 1
a50 1
_bfd_new_bfd (void)
d54 1
a54 1
  nbfd = bfd_zmalloc (sizeof (bfd));
d60 1
a60 1
  nbfd->memory = objalloc_create ();
d73 2
a74 1
  if (!bfd_hash_table_init_n (& nbfd->section_htab, bfd_section_hash_newfunc,
d80 1
a80 1
  nbfd->sections = NULL;
d83 1
a83 1
  nbfd->my_archive = NULL;
d88 1
a88 1
  nbfd->usrdata = NULL;
d99 2
a100 1
_bfd_new_bfd_contained_in (bfd *obfd)
d117 2
a118 1
_bfd_delete_bfd (bfd *abfd)
d136 1
a136 1
	bfd *bfd_openr (const char *filename, const char *target);
d151 3
a153 1
bfd_openr (const char *filename, const char *target)
d195 1
a195 1
	bfd *bfd_fdopenr (const char *filename, const char *target, int fd);
d208 1
a208 1
	is to assume no caching; the file descriptor will remain open
d217 4
a220 1
bfd_fdopenr (const char *filename, const char *target, int fd)
d247 1
a247 1
  nbfd->iostream = fopen (filename, FOPEN_RB);
d252 3
a254 3
    case O_RDONLY: nbfd->iostream = fdopen (fd, FOPEN_RB);   break;
    case O_WRONLY: nbfd->iostream = fdopen (fd, FOPEN_RUB);  break;
    case O_RDWR:   nbfd->iostream = fdopen (fd, FOPEN_RUB);  break;
d295 1
a295 1
	bfd *bfd_openstreamr (const char *, const char *, void *);
d304 4
a307 1
bfd_openstreamr (const char *filename, const char *target, void *streamarg)
d309 1
a309 1
  FILE *stream = streamarg;
d324 1
a324 1
  nbfd->iostream = stream;
d347 1
a347 1
	bfd *bfd_openw (const char *filename, const char *target);
d358 3
a360 1
bfd_openw (const char *filename, const char *target)
d418 2
a419 1
bfd_close (bfd *abfd)
d481 2
a482 1
bfd_close_all_done (bfd *abfd)
d517 1
a517 1
	bfd *bfd_create (const char *filename, bfd *templ);
d526 3
a528 1
bfd_create (const char *filename, bfd *templ)
d562 2
a563 1
bfd_make_writable (bfd *abfd)
d573 3
a575 2
  bim = bfd_malloc (sizeof (struct bfd_in_memory));
  abfd->iostream = bim;
d605 2
a606 1
bfd_make_readable (bfd *abfd)
d625 1
a625 1
  abfd->my_archive = NULL;
d630 1
a630 1
  abfd->usrdata = NULL;
d653 1
a653 1
	void *bfd_alloc (bfd *abfd, size_t wanted);
d661 4
a664 2
void *
bfd_alloc (bfd *abfd, bfd_size_type size)
d666 1
a666 1
  void *ret;
d680 4
a683 2
void *
bfd_zalloc (bfd *abfd, bfd_size_type size)
d685 1
a685 1
  void *res;
d697 3
a699 1
bfd_release (bfd *abfd, void *block)
d719 5
a723 1
#define GNU_DEBUGLINK	".gnu_debuglink"
d725 2
a726 2
FUNCTION
	bfd_calc_gnu_debuglink_crc32
d729 1
a729 2
	unsigned long bfd_calc_gnu_debuglink_crc32
	  (unsigned long crc, const unsigned char *buf, bfd_size_type len);
d732 2
a733 6
	Computes a CRC value as used in the .gnu_debuglink section.
	Advances the previously computed @@var{crc} value by computing
	and adding in the crc32 for @@var{len} bytes of @@var{buf}.

RETURNS
	Return the updated CRC32 value.
d736 5
a740 4
unsigned long
bfd_calc_gnu_debuglink_crc32 (unsigned long crc,
			      const unsigned char *buf,
			      bfd_size_type len)
d811 1
a811 1
	char *get_debug_link_info (bfd *abfd, unsigned long *crc32_out);
d820 3
a822 1
get_debug_link_info (bfd *abfd, unsigned long *crc32_out)
d834 1
a834 1
  sect = bfd_get_section_by_name (abfd, GNU_DEBUGLINK);
d841 3
a843 5
  contents = malloc (debuglink_size);
  if (contents == NULL)
    return NULL;

  ret = bfd_get_section_contents (abfd, sect, contents, 0, debuglink_size);
d854 1
a854 1
  crc32 = bfd_get_32 (abfd, contents + crc_offset);
d865 1
a865 2
	bfd_boolean separate_debug_file_exists
	  (char *name, unsigned long crc32);
d873 3
a875 1
separate_debug_file_exists (const char *name, const unsigned long crc)
d880 1
a880 1
  bfd_size_type count;
d889 1
a889 1
    file_crc = bfd_calc_gnu_debuglink_crc32 (file_crc, buffer, count);
d902 1
a902 1
	char *find_separate_debug_file (bfd *abfd);
d914 3
a916 1
find_separate_debug_file (bfd *abfd, const char *debug_file_directory)
d933 1
a935 1

d942 1
a942 6
  dir = strdup (abfd->filename);
  if (dir == NULL)
    {
      free (basename);
      return NULL;
    }
d949 1
a949 1

d953 5
a957 11
  debugfile = malloc (strlen (debug_file_directory) + 1
		      + strlen (dir)
		      + strlen (".debug/")
		      + strlen (basename) 
		      + 1);
  if (debugfile == NULL)
    {
      free (basename);
      free (dir);
      return NULL;
    }
d1011 1
a1011 1
	char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);
d1016 3
a1018 3
	section is found, it examines the section for the name and checksum
	of a '.debug' file containing auxiliary debugging information.  It
	then searches the filesystem for this .debug file in some standard
d1020 2
a1021 5
	found returns the full filename.

	If @@var{dir} is NULL, it will search a default path configured into
	libbfd at build time.  [XXX this feature is not currently
	implemented].
d1026 1
a1026 1
	filename.  The caller is responsible for freeing this string.
d1030 3
a1032 1
bfd_follow_gnu_debuglink (bfd *abfd, const char *dir)
d1034 1
a1034 1
#if 0 /* Disabled until DEBUGDIR can be defined by configure.in.  */
a1038 153
}

/*
FUNCTION
	bfd_create_gnu_debuglink_section

SYNOPSIS
	struct bfd_section *bfd_create_gnu_debuglink_section
	  (bfd *abfd, const char *filename);

DESCRIPTION

	Takes a @@var{BFD} and adds a .gnu_debuglink section to it.  The section is sized
	to be big enough to contain a link to the specified @@var{filename}.

RETURNS
	A pointer to the new section is returned if all is ok.  Otherwise <<NULL>> is
	returned and bfd_error is set.  
*/

asection *
bfd_create_gnu_debuglink_section (bfd *abfd, const char *filename)
{
  asection *sect;
  bfd_size_type debuglink_size;

  if (abfd == NULL || filename == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return NULL;
    }

  /* Strip off any path components in filename.  */
  filename = lbasename (filename);
  
  sect = bfd_get_section_by_name (abfd, GNU_DEBUGLINK);
  if (sect)
    {
      /* Section already exists.  */
      bfd_set_error (bfd_error_invalid_operation);
      return NULL;
    }

  sect = bfd_make_section (abfd, GNU_DEBUGLINK);
  if (sect == NULL)
    return NULL;

  if (! bfd_set_section_flags (abfd, sect,
			       SEC_HAS_CONTENTS | SEC_READONLY | SEC_DEBUGGING))
    /* XXX Should we delete the section from the bfd ?  */
    return NULL;

  
  debuglink_size = strlen (filename) + 1;
  debuglink_size += 3;
  debuglink_size &= ~3;
  debuglink_size += 4;

  if (! bfd_set_section_size (abfd, sect, debuglink_size))
    /* XXX Should we delete the section from the bfd ?  */
    return NULL;
  
  return sect;
}


/*
FUNCTION
	bfd_fill_in_gnu_debuglink_section

SYNOPSIS
	bfd_boolean bfd_fill_in_gnu_debuglink_section
	  (bfd *abfd, struct bfd_section *sect, const char *filename);

DESCRIPTION

	Takes a @@var{BFD} and containing a .gnu_debuglink section @@var{SECT}
	and fills in the contents of the section to contain a link to the
	specified @@var{filename}.  The filename should be relative to the
	current directory.

RETURNS
	<<TRUE>> is returned if all is ok.  Otherwise <<FALSE>> is returned
	and bfd_error is set.  
*/

bfd_boolean
bfd_fill_in_gnu_debuglink_section (bfd *abfd,
				   struct bfd_section *sect,
				   const char *filename)
{
  bfd_size_type debuglink_size;
  unsigned long crc32;
  char * contents;
  bfd_size_type crc_offset;
  FILE * handle;
  static char buffer[8 * 1024];
  size_t count;

  if (abfd == NULL || sect == NULL || filename == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  /* Make sure that we can read the file.
     XXX - Should we attempt to locate the debug info file using the same
     algorithm as gdb ?  At the moment, since we are creating the
     .gnu_debuglink section, we insist upon the user providing us with a
     correct-for-section-creation-time path, but this need not conform to
     the gdb location algorithm.  */
  handle = fopen (filename, FOPEN_RB);
  if (handle == NULL)
    {
      bfd_set_error (bfd_error_system_call);
      return FALSE;
    }

  crc32 = 0;
  while ((count = fread (buffer, 1, sizeof buffer, handle)) > 0)
    crc32 = bfd_calc_gnu_debuglink_crc32 (crc32, buffer, count);
  fclose (handle);

  /* Strip off any path components in filename,
     now that we no longer need them.  */
  filename = lbasename (filename);
  
  debuglink_size = strlen (filename) + 1;
  debuglink_size += 3;
  debuglink_size &= ~3;
  debuglink_size += 4;

  contents = malloc (debuglink_size);
  if (contents == NULL)
    {
      /* XXX Should we delete the section from the bfd ?  */
      bfd_set_error (bfd_error_no_memory);
      return FALSE;
    }

  strcpy (contents, filename);
  crc_offset = debuglink_size - 4;

  bfd_put_32 (abfd, crc32, contents + crc_offset);

  if (! bfd_set_section_contents (abfd, sect, contents, 0, debuglink_size))
    {
      /* XXX Should we delete the section from the bfd ?  */
      free (contents);
      return FALSE;
    }

  return TRUE;
@


