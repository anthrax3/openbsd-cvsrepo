head	1.6;
access;
symbols
	OPENBSD_6_0:1.6.0.48
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.44
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.46
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.38
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.42
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.40
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BINUTILS_2_15:1.1.1.6
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.5
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.4
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.3
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.11.02.20.45.09;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.17.21.54.22;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.30;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.17;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.45.25;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.51;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.51;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.05.48;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.09.12.14.45.44;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.05.13.13.26.00;	author fgsch;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.05.17.20.42.17;	author drahn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.11.02.20.22.29;	author miod;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* Generic BFD support for file formats.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/*
SECTION
	File formats

	A format is a BFD concept of high level file contents type. The
	formats supported by BFD are:

	o <<bfd_object>>

	The BFD may contain data, symbols, relocations and debug info.

	o <<bfd_archive>>

	The BFD contains other BFDs and an optional index.

	o <<bfd_core>>

	The BFD contains the result of an executable core dump.

*/

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"

/* IMPORT from targets.c.  */
extern const size_t _bfd_target_vector_entries;

/*
FUNCTION
	bfd_check_format

SYNOPSIS
	bfd_boolean bfd_check_format (bfd *abfd, bfd_format format);

DESCRIPTION
	Verify if the file attached to the BFD @@var{abfd} is compatible
	with the format @@var{format} (i.e., one of <<bfd_object>>,
	<<bfd_archive>> or <<bfd_core>>).

	If the BFD has been set to a specific target before the
	call, only the named target and format combination is
	checked. If the target has not been set, or has been set to
	<<default>>, then all the known target backends is
	interrogated to determine a match.  If the default target
	matches, it is used.  If not, exactly one target must recognize
	the file, or an error results.

	The function returns <<TRUE>> on success, otherwise <<FALSE>>
	with one of the following error codes:

	o <<bfd_error_invalid_operation>> -
	if <<format>> is not one of <<bfd_object>>, <<bfd_archive>> or
	<<bfd_core>>.

	o <<bfd_error_system_call>> -
	if an error occured during a read - even some file mismatches
	can cause bfd_error_system_calls.

	o <<file_not_recognised>> -
	none of the backends recognised the file format.

	o <<bfd_error_file_ambiguously_recognized>> -
	more than one backend recognised the file format.
*/

bfd_boolean
bfd_check_format (bfd *abfd, bfd_format format)
{
  return bfd_check_format_matches (abfd, format, NULL);
}

/*
FUNCTION
	bfd_check_format_matches

SYNOPSIS
	bfd_boolean bfd_check_format_matches
	  (bfd *abfd, bfd_format format, char ***matching);

DESCRIPTION
	Like <<bfd_check_format>>, except when it returns FALSE with
	<<bfd_errno>> set to <<bfd_error_file_ambiguously_recognized>>.  In that
	case, if @@var{matching} is not NULL, it will be filled in with
	a NULL-terminated list of the names of the formats that matched,
	allocated with <<malloc>>.
	Then the user may choose a format and try again.

	When done with the list that @@var{matching} points to, the caller
	should free it.
*/

bfd_boolean
bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
{
  extern const bfd_target binary_vec;
  const bfd_target * const *target;
  const bfd_target **matching_vector = NULL;
  const bfd_target *save_targ, *right_targ, *ar_right_targ;
  int match_count;
  int ar_match_index;

  if (!bfd_read_p (abfd)
      || (unsigned int) abfd->format >= (unsigned int) bfd_type_end)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  if (abfd->format != bfd_unknown)
    return abfd->format == format;

  /* Since the target type was defaulted, check them
     all in the hope that one will be uniquely recognized.  */
  save_targ = abfd->xvec;
  match_count = 0;
  ar_match_index = _bfd_target_vector_entries;

  if (matching)
    {
      bfd_size_type amt;

      *matching = NULL;
      amt = sizeof (*matching_vector) * 2 * _bfd_target_vector_entries;
      matching_vector = bfd_malloc (amt);
      if (!matching_vector)
	return FALSE;
    }

  right_targ = 0;
  ar_right_targ = 0;

  /* Presume the answer is yes.  */
  abfd->format = format;

  /* If the target type was explicitly specified, just check that target.  */
  if (!abfd->target_defaulted)
    {
      if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)	/* rewind! */
	{
	  if (matching)
	    free (matching_vector);
	  return FALSE;
	}

      right_targ = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));

      if (right_targ)
	{
	  abfd->xvec = right_targ;	/* Set the target as returned.  */

	  if (matching)
	    free (matching_vector);

	  return TRUE;			/* File position has moved, BTW.  */
	}

      /* For a long time the code has dropped through to check all
	 targets if the specified target was wrong.  I don't know why,
	 and I'm reluctant to change it.  However, in the case of an
	 archive, it can cause problems.  If the specified target does
	 not permit archives (e.g., the binary target), then we should
	 not allow some other target to recognize it as an archive, but
	 should instead allow the specified target to recognize it as an
	 object.  When I first made this change, it broke the PE target,
	 because the specified pei-i386 target did not recognize the
	 actual pe-i386 archive.  Since there may be other problems of
	 this sort, I changed this test to check only for the binary
	 target.  */
      if (format == bfd_archive && save_targ == &binary_vec)
	{
	  abfd->xvec = save_targ;
	  abfd->format = bfd_unknown;

	  if (matching)
	    free (matching_vector);

	  bfd_set_error (bfd_error_file_not_recognized);

	  return FALSE;
	}
    }

  for (target = bfd_target_vector; *target != NULL; target++)
    {
      const bfd_target *temp;
      bfd_error_type err;

      if (*target == &binary_vec)
	continue;

      abfd->xvec = *target;	/* Change BFD's target temporarily.  */

      if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
	{
	  if (matching)
	    free (matching_vector);
	  return FALSE;
	}

      /* If _bfd_check_format neglects to set bfd_error, assume
	 bfd_error_wrong_format.  We didn't used to even pay any
	 attention to bfd_error, so I suspect that some
	 _bfd_check_format might have this problem.  */
      bfd_set_error (bfd_error_wrong_format);

      temp = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));

      if (temp)
	{
	  /* This format checks out as ok!  */
	  right_targ = temp;

	  /* If this is the default target, accept it, even if other
	     targets might match.  People who want those other targets
	     have to set the GNUTARGET variable.  */
	  if (temp == bfd_default_vector[0])
	    {
	      match_count = 1;
	      break;
	    }

	  if (matching)
	    matching_vector[match_count] = temp;

	  match_count++;

#ifdef GNU960
	  /* Big- and little-endian b.out archives look the same, but it
	     doesn't matter: there is no difference in their headers, and
	     member file byte orders will (I hope) be handled appropriately
	     by bfd.  Ditto for big and little coff archives.  And the 4
	     coff/b.out object formats are unambiguous.  So accept the
	     first match we find.  */
	  break;
#endif
	}
      else if ((err = bfd_get_error ()) == bfd_error_wrong_object_format
	       || err == bfd_error_file_ambiguously_recognized)
	{
	  /* An archive with objects of the wrong type, or an
	     ambiguous match.  We want this target to match if we get
	     no better matches.  */
	  if (ar_right_targ != bfd_default_vector[0])
	    ar_right_targ = *target;
	  if (matching)
	    matching_vector[ar_match_index] = *target;
	  ar_match_index++;
	}
      else if (err != bfd_error_wrong_format)
	{
	  abfd->xvec = save_targ;
	  abfd->format = bfd_unknown;

	  if (matching)
	    free (matching_vector);

	  return FALSE;
	}
    }

  if (match_count == 0)
    {
      /* Try partial matches.  */
      right_targ = ar_right_targ;

      if (right_targ == bfd_default_vector[0])
	{
	  match_count = 1;
	}
      else
	{
	  match_count = ar_match_index - _bfd_target_vector_entries;

	  if (matching && match_count > 1)
	    memcpy (matching_vector,
		    matching_vector + _bfd_target_vector_entries,
		    sizeof (*matching_vector) * match_count);
	}
    }

  if (match_count > 1
      && bfd_associated_vector != NULL
      && matching)
    {
      const bfd_target * const *assoc = bfd_associated_vector;

      while ((right_targ = *assoc++) != NULL)
	{
	  int i = match_count;

	  while (--i >= 0)
	    if (matching_vector[i] == right_targ)
	      break;

	  if (i >= 0)
	    {
	      match_count = 1;
	      break;
	    }
	}
    }

  if (match_count == 1)
    {
      abfd->xvec = right_targ;		/* Change BFD's target permanently.  */

      if (matching)
	free (matching_vector);

      return TRUE;			/* File position has moved, BTW.  */
    }

  abfd->xvec = save_targ;		/* Restore original target type.  */
  abfd->format = bfd_unknown;		/* Restore original format.  */

  if (match_count == 0)
    {
      bfd_set_error (bfd_error_file_not_recognized);

      if (matching)
	free (matching_vector);
    }
  else
    {
      bfd_set_error (bfd_error_file_ambiguously_recognized);

      if (matching)
	{
	  *matching = (char **) matching_vector;
	  matching_vector[match_count] = NULL;
	  /* Return target names.  This is a little nasty.  Maybe we
	     should do another bfd_malloc?  */
	  while (--match_count >= 0)
	    {
	      const char *name = matching_vector[match_count]->name;
	      *(const char **) &matching_vector[match_count] = name;
	    }
	}
    }

  return FALSE;
}

/*
FUNCTION
	bfd_set_format

SYNOPSIS
	bfd_boolean bfd_set_format (bfd *abfd, bfd_format format);

DESCRIPTION
	This function sets the file format of the BFD @@var{abfd} to the
	format @@var{format}. If the target set in the BFD does not
	support the format requested, the format is invalid, or the BFD
	is not open for writing, then an error occurs.
*/

bfd_boolean
bfd_set_format (bfd *abfd, bfd_format format)
{
  if (bfd_read_p (abfd)
      || (unsigned int) abfd->format >= (unsigned int) bfd_type_end)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  if (abfd->format != bfd_unknown)
    return abfd->format == format;

  /* Presume the answer is yes.  */
  abfd->format = format;

  if (!BFD_SEND_FMT (abfd, _bfd_set_format, (abfd)))
    {
      abfd->format = bfd_unknown;
      return FALSE;
    }

  return TRUE;
}

/*
FUNCTION
	bfd_format_string

SYNOPSIS
	const char *bfd_format_string (bfd_format format);

DESCRIPTION
	Return a pointer to a const string
	<<invalid>>, <<object>>, <<archive>>, <<core>>, or <<unknown>>,
	depending upon the value of @@var{format}.
*/

const char *
bfd_format_string (bfd_format format)
{
  if (((int) format < (int) bfd_unknown)
      || ((int) format >= (int) bfd_type_end))
    return "invalid";

  switch (format)
    {
    case bfd_object:
      return "object";		/* Linker/assembler/compiler output.  */
    case bfd_archive:
      return "archive";		/* Object archive file.  */
    case bfd_core:
      return "core";		/* Core dump.  */
    default:
      return "unknown";
    }
}
@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d89 1
a89 3
bfd_check_format (abfd, format)
     bfd *abfd;
     bfd_format format;
d99 2
a100 2
	bfd_boolean bfd_check_format_matches (bfd *abfd, bfd_format format,
					      char ***matching);
d115 1
a115 4
bfd_check_format_matches (abfd, format, matching)
     bfd *abfd;
     bfd_format format;
     char ***matching;
d146 1
a146 1
      matching_vector = (const bfd_target **) bfd_malloc (amt);
d163 1
a163 1
	    free ((PTR) matching_vector);
d174 1
a174 1
	    free ((PTR) matching_vector);
d197 1
a197 1
	    free ((PTR) matching_vector);
d218 1
a218 1
	    free ((PTR) matching_vector);
d277 1
a277 1
	    free ((PTR) matching_vector);
d330 1
a330 1
	free ((PTR) matching_vector);
d343 1
a343 1
	free ((PTR) matching_vector);
d381 1
a381 3
bfd_set_format (abfd, format)
     bfd *abfd;
     bfd_format format;
d419 1
a419 2
bfd_format_string (format)
     bfd_format format;
d421 2
a422 2
  if (((int)format <(int) bfd_unknown)
      || ((int)format >=(int) bfd_type_end))
d428 1
a428 1
      return "object";		/* Linker/assember/compiler output.  */
@


1.4
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000, 2001
d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d55 1
a55 1
	boolean bfd_check_format(bfd *abfd, bfd_format format);
d70 1
a70 1
	The function returns <<true>> on success, otherwise <<false>>
d88 1
a88 1
boolean
d101 2
a102 1
	boolean bfd_check_format_matches(bfd *abfd, bfd_format format, char ***matching);
d105 1
a105 1
	Like <<bfd_check_format>>, except when it returns false with
d116 1
a116 1
boolean
d123 3
a125 2
  const bfd_target * const *target, *save_targ, *right_targ;
  char **matching_vector = NULL;
d127 1
d129 2
a130 3
  if (!bfd_read_p (abfd) ||
      ((int)(abfd->format) < (int)bfd_unknown) ||
      ((int)(abfd->format) >= (int)bfd_type_end))
d133 1
a133 1
      return false;
d137 1
a137 1
    return (abfd->format == format)? true: false;
d143 1
d147 5
a151 3
      matching_vector =
	(char **) bfd_malloc (sizeof (char *) *
			      (_bfd_target_vector_entries + 1));
d153 1
a153 3
	return false;
      matching_vector[0] = NULL;
      *matching = matching_vector;
d157 1
d165 6
a170 2
      if (bfd_seek (abfd, (file_ptr)0, SEEK_SET) != 0)	/* rewind! */
	return false;
d179 1
a179 1
	    free (matching_vector);
d181 1
a181 1
	  return true;			/* File position has moved, BTW.  */
d202 1
a202 1
	    free (matching_vector);
d206 1
a206 1
	  return false;
d213 1
d218 1
a218 1
      abfd->xvec = *target;	/* Change BFD's target temporarily */
d220 6
a225 2
      if (bfd_seek (abfd, (file_ptr)0, SEEK_SET) != 0)
	return false;
d236 2
a237 1
	{		/* This format checks out as ok!  */
a239 8
	  if (matching)
	    {
	      matching_vector[match_count] = temp->name;
	      matching_vector[match_count + 1] = NULL;
	    }

	  match_count++;

a244 5
	      if (matching)
		{
		  matching_vector[0] = temp->name;
		  matching_vector[1] = NULL;
		}
d248 6
d264 13
a276 1
      else if (bfd_get_error () != bfd_error_wrong_format)
d281 11
a291 3
	  if (matching && bfd_get_error ()
	      != bfd_error_file_ambiguously_recognized)
	    free (matching_vector);
d293 34
a326 1
	  return false;
d335 1
a335 1
	free (matching_vector);
d337 1
a337 1
      return true;			/* File position has moved, BTW.  */
d348 1
a348 1
	free (matching_vector);
d351 16
a366 1
    bfd_set_error (bfd_error_file_ambiguously_recognized);
d368 1
a368 1
  return false;
d376 1
a376 1
	boolean bfd_set_format(bfd *abfd, bfd_format format);
d385 1
a385 1
boolean
d390 2
a391 3
  if (bfd_read_p (abfd) ||
      ((int)abfd->format < (int)bfd_unknown) ||
      ((int)abfd->format >= (int)bfd_type_end))
d394 1
a394 1
      return false;
d398 1
a398 1
    return (abfd->format == format) ? true : false;
d406 1
a406 1
      return false;
d409 1
a409 1
  return true;
d417 1
a417 1
	CONST char *bfd_format_string(bfd_format format);
d425 1
a425 1
CONST char *
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 1999 Free Software Foundation, Inc.
d27 1
a27 1
	formats supported by BFD are: 
a40 1

d71 1
a71 1
	with one of the following error codes:  
d112 1
a112 1
	should free it.  
d128 5
a132 4
      ((int)(abfd->format) >= (int)bfd_type_end)) {
    bfd_set_error (bfd_error_invalid_operation);
    return false;
  }
d137 1
a137 2

  /* Since the target type was defaulted, check them 
a138 1

d141 1
d152 1
d155 1
a155 2

  /* presume the answer is yes */
d159 4
d164 1
a164 10
  if (!abfd->target_defaulted) {
    if (bfd_seek (abfd, (file_ptr)0, SEEK_SET) != 0)	/* rewind! */
      return false;
    right_targ = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));
    if (right_targ) {
      abfd->xvec = right_targ;		/* Set the target as returned */
      if (matching)
	free (matching_vector);
      return true;			/* File position has moved, BTW */
    }
d166 3
a168 23
    /* For a long time the code has dropped through to check all
       targets if the specified target was wrong.  I don't know why,
       and I'm reluctant to change it.  However, in the case of an
       archive, it can cause problems.  If the specified target does
       not permit archives (e.g., the binary target), then we should
       not allow some other target to recognize it as an archive, but
       should instead allow the specified target to recognize it as an
       object.  When I first made this change, it broke the PE target,
       because the specified pei-i386 target did not recognize the
       actual pe-i386 archive.  Since there may be other problems of
       this sort, I changed this test to check only for the binary
       target.  */

    if (format == bfd_archive && save_targ == &binary_vec)
      {
	abfd->xvec = save_targ;
	abfd->format = bfd_unknown;
	if (matching)
	  free (matching_vector);
	bfd_set_error (bfd_error_file_not_recognized);
	return false;
      }
  }
d170 2
a171 2
  for (target = bfd_target_vector; *target != NULL; target++) {
    const bfd_target *temp;
d173 2
a174 2
    if (*target == &binary_vec)
      continue;
d176 13
a188 11
    abfd->xvec = *target;	/* Change BFD's target temporarily */
    if (bfd_seek (abfd, (file_ptr)0, SEEK_SET) != 0)
      return false;
    /* If _bfd_check_format neglects to set bfd_error, assume bfd_error_wrong_format.
       We didn't used to even pay any attention to bfd_error, so I suspect
       that some _bfd_check_format might have this problem.  */
    bfd_set_error (bfd_error_wrong_format);
    temp = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));
    if (temp) {				/* This format checks out as ok! */
      right_targ = temp;
      if (matching)
d190 9
a198 2
	  matching_vector[match_count] = temp->name;
	  matching_vector[match_count + 1] = NULL;
d200 26
a225 6
      match_count++;
      /* If this is the default target, accept it, even if other targets
	 might match.  People who want those other targets have to set 
	 the GNUTARGET variable.  */
      if (temp == bfd_default_vector[0])
	{
d228 2
a229 2
	      matching_vector[0] = temp->name;
	      matching_vector[1] = NULL;
d231 23
a253 1
	  match_count = 1;
d255 12
d268 7
a274 13
#ifdef GNU960
      /* Big- and little-endian b.out archives look the same, but it doesn't
       * matter: there is no difference in their headers, and member file byte
       * orders will (I hope) be handled appropriately by bfd.  Ditto for big
       * and little coff archives.  And the 4 coff/b.out object formats are
       * unambiguous.  So accept the first match we find.
       */
      break;
#endif
    } else if (bfd_get_error () != bfd_error_wrong_format) {
      abfd->xvec = save_targ;
      abfd->format = bfd_unknown;
      if (matching && bfd_get_error () != bfd_error_file_ambiguously_recognized)
d276 2
a277 1
      return false;
a278 1
  }
d280 2
a281 6
  if (match_count == 1) {
    abfd->xvec = right_targ;		/* Change BFD's target permanently */
    if (matching)
      free (matching_vector);
    return true;			/* File position has moved, BTW */
  }
a282 2
  abfd->xvec = save_targ;		/* Restore original target type */
  abfd->format = bfd_unknown;		/* Restore original format */
d286 1
d292 1
a307 1

a314 1

d317 5
a321 4
      ((int)abfd->format >= (int)bfd_type_end)) {
    bfd_set_error (bfd_error_invalid_operation);
    return false;
  }
d324 1
a324 1
    return (abfd->format == format) ? true:false;
d326 1
a326 1
  /* presume the answer is yes */
d329 5
a333 4
  if (!BFD_SEND_FMT (abfd, _bfd_set_format, (abfd))) {
    abfd->format = bfd_unknown;
    return false;
  }
a337 1

d355 2
a356 2
  if (((int)format <(int) bfd_unknown) 
      || ((int)format >=(int) bfd_type_end)) 
d358 12
a369 11
  
  switch (format) {
  case bfd_object:
    return "object";		/* linker/assember/compiler output */
  case bfd_archive: 
    return "archive";		/* object archive file */
  case bfd_core: 
    return "core";		/* core dump */
  default: 
    return "unknown";
  }
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94 Free Software Foundation, Inc.
d121 1
d170 23
a195 1
    extern const bfd_target binary_vec;
@


1.1
log
@Initial revision
@
text
@d144 2
a145 2
	(char **) malloc (sizeof (char *) *
			  (_bfd_target_vector_entries + 1));
d147 1
a147 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d144 2
a145 2
	(char **) bfd_malloc (sizeof (char *) *
			      (_bfd_target_vector_entries + 1));
d147 4
a150 1
	return false;
@


1.1.1.3
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 1999 Free Software Foundation, Inc.
a120 1
  extern const bfd_target binary_vec;
a168 23

    /* For a long time the code has dropped through to check all
       targets if the specified target was wrong.  I don't know why,
       and I'm reluctant to change it.  However, in the case of an
       archive, it can cause problems.  If the specified target does
       not permit archives (e.g., the binary target), then we should
       not allow some other target to recognize it as an archive, but
       should instead allow the specified target to recognize it as an
       object.  When I first made this change, it broke the PE target,
       because the specified pei-i386 target did not recognize the
       actual pe-i386 archive.  Since there may be other problems of
       this sort, I changed this test to check only for the binary
       target.  */

    if (format == bfd_archive && save_targ == &binary_vec)
      {
	abfd->xvec = save_targ;
	abfd->format = bfd_unknown;
	if (matching)
	  free (matching_vector);
	bfd_set_error (bfd_error_file_not_recognized);
	return false;
      }
d172 1
@


1.1.1.4
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000, 2001
   Free Software Foundation, Inc.
d26 1
a26 1
	formats supported by BFD are:
d40 1
d71 1
a71 1
	with one of the following error codes:
d112 1
a112 1
	should free it.
d128 4
a131 5
      ((int)(abfd->format) >= (int)bfd_type_end))
    {
      bfd_set_error (bfd_error_invalid_operation);
      return false;
    }
d136 2
a137 1
  /* Since the target type was defaulted, check them
d139 1
a141 1

d152 1
a153 1
  right_targ = 0;
d155 1
a155 1
  /* Presume the answer is yes.  */
a158 4
  if (!abfd->target_defaulted)
    {
      if (bfd_seek (abfd, (file_ptr)0, SEEK_SET) != 0)	/* rewind! */
	return false;
d160 10
a169 1
      right_targ = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));
d171 23
a193 3
      if (right_targ)
	{
	  abfd->xvec = right_targ;	/* Set the target as returned.  */
d195 2
a196 2
	  if (matching)
	    free (matching_vector);
d198 2
a199 2
	  return true;			/* File position has moved, BTW.  */
	}
d201 11
a211 13
      /* For a long time the code has dropped through to check all
	 targets if the specified target was wrong.  I don't know why,
	 and I'm reluctant to change it.  However, in the case of an
	 archive, it can cause problems.  If the specified target does
	 not permit archives (e.g., the binary target), then we should
	 not allow some other target to recognize it as an archive, but
	 should instead allow the specified target to recognize it as an
	 object.  When I first made this change, it broke the PE target,
	 because the specified pei-i386 target did not recognize the
	 actual pe-i386 archive.  Since there may be other problems of
	 this sort, I changed this test to check only for the binary
	 target.  */
      if (format == bfd_archive && save_targ == &binary_vec)
d213 2
a214 9
	  abfd->xvec = save_targ;
	  abfd->format = bfd_unknown;

	  if (matching)
	    free (matching_vector);

	  bfd_set_error (bfd_error_file_not_recognized);

	  return false;
d216 6
a221 26
    }

  for (target = bfd_target_vector; *target != NULL; target++)
    {
      const bfd_target *temp;

      if (*target == &binary_vec)
	continue;

      abfd->xvec = *target;	/* Change BFD's target temporarily */

      if (bfd_seek (abfd, (file_ptr)0, SEEK_SET) != 0)
	return false;

      /* If _bfd_check_format neglects to set bfd_error, assume
	 bfd_error_wrong_format.  We didn't used to even pay any
	 attention to bfd_error, so I suspect that some
	 _bfd_check_format might have this problem.  */
      bfd_set_error (bfd_error_wrong_format);

      temp = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));

      if (temp)
	{		/* This format checks out as ok!  */
	  right_targ = temp;

d224 2
a225 18
	      matching_vector[match_count] = temp->name;
	      matching_vector[match_count + 1] = NULL;
	    }

	  match_count++;

	  /* If this is the default target, accept it, even if other
	     targets might match.  People who want those other targets
	     have to set the GNUTARGET variable.  */
	  if (temp == bfd_default_vector[0])
	    {
	      if (matching)
		{
		  matching_vector[0] = temp->name;
		  matching_vector[1] = NULL;
		}
	      match_count = 1;
	      break;
d227 3
d231 7
a237 7
	  /* Big- and little-endian b.out archives look the same, but it
	     doesn't matter: there is no difference in their headers, and
	     member file byte orders will (I hope) be handled appropriately
	     by bfd.  Ditto for big and little coff archives.  And the 4
	     coff/b.out object formats are unambiguous.  So accept the
	     first match we find.  */
	  break;
d239 4
a242 19
	}
      else if (bfd_get_error () != bfd_error_wrong_format)
	{
	  abfd->xvec = save_targ;
	  abfd->format = bfd_unknown;

	  if (matching && bfd_get_error ()
	      != bfd_error_file_ambiguously_recognized)
	    free (matching_vector);

	  return false;
	}
    }

  if (match_count == 1)
    {
      abfd->xvec = right_targ;		/* Change BFD's target permanently.  */

      if (matching)
d244 1
a244 2

      return true;			/* File position has moved, BTW.  */
d246 1
d248 6
a253 2
  abfd->xvec = save_targ;		/* Restore original target type.  */
  abfd->format = bfd_unknown;		/* Restore original format.  */
d255 2
a259 1

a264 1

d280 1
d288 1
d291 4
a294 5
      ((int)abfd->format >= (int)bfd_type_end))
    {
      bfd_set_error (bfd_error_invalid_operation);
      return false;
    }
d297 1
a297 1
    return (abfd->format == format) ? true : false;
d299 1
a299 1
  /* Presume the answer is yes.  */
d302 4
a305 5
  if (!BFD_SEND_FMT (abfd, _bfd_set_format, (abfd)))
    {
      abfd->format = bfd_unknown;
      return false;
    }
d310 1
d328 2
a329 2
  if (((int)format <(int) bfd_unknown)
      || ((int)format >=(int) bfd_type_end))
d331 11
a341 12

  switch (format)
    {
    case bfd_object:
      return "object";		/* Linker/assember/compiler output.  */
    case bfd_archive:
      return "archive";		/* Object archive file.  */
    case bfd_core:
      return "core";		/* Core dump.  */
    default:
      return "unknown";
    }
@


1.1.1.5
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d55 1
a55 1
	bfd_boolean bfd_check_format (bfd *abfd, bfd_format format);
d70 1
a70 1
	The function returns <<TRUE>> on success, otherwise <<FALSE>>
d88 1
a88 1
bfd_boolean
d101 1
a101 2
	bfd_boolean bfd_check_format_matches (bfd *abfd, bfd_format format,
					      char ***matching);
d104 1
a104 1
	Like <<bfd_check_format>>, except when it returns FALSE with
d115 1
a115 1
bfd_boolean
d122 2
a123 3
  const bfd_target * const *target;
  const bfd_target **matching_vector = NULL;
  const bfd_target *save_targ, *right_targ, *ar_right_targ;
a124 1
  int ar_match_index;
d126 3
a128 2
  if (!bfd_read_p (abfd)
      || (unsigned int) abfd->format >= (unsigned int) bfd_type_end)
d131 1
a131 1
      return FALSE;
d135 1
a135 1
    return abfd->format == format;
a140 1
  ar_match_index = _bfd_target_vector_entries;
d144 3
a146 5
      bfd_size_type amt;

      *matching = NULL;
      amt = sizeof (*matching_vector) * 2 * _bfd_target_vector_entries;
      matching_vector = (const bfd_target **) bfd_malloc (amt);
d148 3
a150 1
	return FALSE;
a153 1
  ar_right_targ = 0;
d161 2
a162 6
      if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)	/* rewind! */
	{
	  if (matching)
	    free ((PTR) matching_vector);
	  return FALSE;
	}
d171 1
a171 1
	    free ((PTR) matching_vector);
d173 1
a173 1
	  return TRUE;			/* File position has moved, BTW.  */
d194 1
a194 1
	    free ((PTR) matching_vector);
d198 1
a198 1
	  return FALSE;
a204 1
      bfd_error_type err;
d209 1
a209 1
      abfd->xvec = *target;	/* Change BFD's target temporarily.  */
d211 2
a212 6
      if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
	{
	  if (matching)
	    free ((PTR) matching_vector);
	  return FALSE;
	}
d223 1
a223 2
	{
	  /* This format checks out as ok!  */
d226 8
d239 5
a246 6

	  if (matching)
	    matching_vector[match_count] = temp;

	  match_count++;

d257 1
a257 13
      else if ((err = bfd_get_error ()) == bfd_error_wrong_object_format
	       || err == bfd_error_file_ambiguously_recognized)
	{
	  /* An archive with objects of the wrong type, or an
	     ambiguous match.  We want this target to match if we get
	     no better matches.  */
	  if (ar_right_targ != bfd_default_vector[0])
	    ar_right_targ = *target;
	  if (matching)
	    matching_vector[ar_match_index] = *target;
	  ar_match_index++;
	}
      else if (err != bfd_error_wrong_format)
d262 3
a264 11
	  if (matching)
	    free ((PTR) matching_vector);

	  return FALSE;
	}
    }

  if (match_count == 0)
    {
      /* Try partial matches.  */
      right_targ = ar_right_targ;
d266 1
a266 34
      if (right_targ == bfd_default_vector[0])
	{
	  match_count = 1;
	}
      else
	{
	  match_count = ar_match_index - _bfd_target_vector_entries;

	  if (matching && match_count > 1)
	    memcpy (matching_vector,
		    matching_vector + _bfd_target_vector_entries,
		    sizeof (*matching_vector) * match_count);
	}
    }

  if (match_count > 1
      && bfd_associated_vector != NULL
      && matching)
    {
      const bfd_target * const *assoc = bfd_associated_vector;

      while ((right_targ = *assoc++) != NULL)
	{
	  int i = match_count;

	  while (--i >= 0)
	    if (matching_vector[i] == right_targ)
	      break;

	  if (i >= 0)
	    {
	      match_count = 1;
	      break;
	    }
d275 1
a275 1
	free ((PTR) matching_vector);
d277 1
a277 1
      return TRUE;			/* File position has moved, BTW.  */
d288 1
a288 1
	free ((PTR) matching_vector);
d291 1
a291 16
    {
      bfd_set_error (bfd_error_file_ambiguously_recognized);

      if (matching)
	{
	  *matching = (char **) matching_vector;
	  matching_vector[match_count] = NULL;
	  /* Return target names.  This is a little nasty.  Maybe we
	     should do another bfd_malloc?  */
	  while (--match_count >= 0)
	    {
	      const char *name = matching_vector[match_count]->name;
	      *(const char **) &matching_vector[match_count] = name;
	    }
	}
    }
d293 1
a293 1
  return FALSE;
d301 1
a301 1
	bfd_boolean bfd_set_format (bfd *abfd, bfd_format format);
d310 1
a310 1
bfd_boolean
d315 3
a317 2
  if (bfd_read_p (abfd)
      || (unsigned int) abfd->format >= (unsigned int) bfd_type_end)
d320 1
a320 1
      return FALSE;
d324 1
a324 1
    return abfd->format == format;
d332 1
a332 1
      return FALSE;
d335 1
a335 1
  return TRUE;
d343 1
a343 1
	const char *bfd_format_string (bfd_format format);
d351 1
a351 1
const char *
@


1.1.1.6
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d89 3
a91 1
bfd_check_format (bfd *abfd, bfd_format format)
d101 2
a102 2
	bfd_boolean bfd_check_format_matches
	  (bfd *abfd, bfd_format format, char ***matching);
d117 4
a120 1
bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
d151 1
a151 1
      matching_vector = bfd_malloc (amt);
d168 1
a168 1
	    free (matching_vector);
d179 1
a179 1
	    free (matching_vector);
d202 1
a202 1
	    free (matching_vector);
d223 1
a223 1
	    free (matching_vector);
d282 1
a282 1
	    free (matching_vector);
d335 1
a335 1
	free (matching_vector);
d348 1
a348 1
	free (matching_vector);
d386 3
a388 1
bfd_set_format (bfd *abfd, bfd_format format)
d426 2
a427 1
bfd_format_string (bfd_format format)
d429 2
a430 2
  if (((int) format < (int) bfd_unknown)
      || ((int) format >= (int) bfd_type_end))
d436 1
a436 1
      return "object";		/* Linker/assembler/compiler output.  */
@


