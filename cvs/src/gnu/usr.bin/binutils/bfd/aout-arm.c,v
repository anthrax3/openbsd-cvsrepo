head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.50
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.52
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.14
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.02;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.19;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.28;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.04;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.11.23.03.32.36;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.42.47;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.20;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.20;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.04.41;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.11.19.14.11.55;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.17.30;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.45.20;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.19.33;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.09;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.11;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD back-end for raw ARM a.out binaries.
   Copyright 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
   Contributed by Richard Earnshaw (rwe@@pegasus.esprit.ec.org)

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"

/* Avoid multiple definitions from aoutx if supporting standard a.out
   as well as our own.  */
/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
#define NAME(x,y) CONCAT3 (aoutarm,_32_,y)

#define N_TXTADDR(x)						\
  ((N_MAGIC (x) == NMAGIC)					\
   ? (bfd_vma) 0x8000						\
   : ((N_MAGIC (x) != ZMAGIC)					\
      ? (bfd_vma) 0						\
      : ((N_SHARED_LIB (x))					\
	 ? ((x).a_entry & ~(bfd_vma) (TARGET_PAGE_SIZE - 1))	\
	 : (bfd_vma) TEXT_START_ADDR)))

#define TEXT_START_ADDR 0x8000
#define TARGET_PAGE_SIZE 0x8000
#define SEGMENT_SIZE TARGET_PAGE_SIZE
#define DEFAULT_ARCH bfd_arch_arm

#define MY(OP) CONCAT2 (aoutarm_,OP)
#define N_BADMAG(x) ((((x).a_info & ~007200) != ZMAGIC) && \
                     (((x).a_info & ~006000) != OMAGIC) && \
                     ((x).a_info != NMAGIC))
#define N_MAGIC(x) ((x).a_info & ~07200)

#define MY_bfd_reloc_type_lookup aoutarm_bfd_reloc_type_lookup

#include "libaout.h"
#include "aout/aout64.h"

static bfd_boolean MY(write_object_contents)
  PARAMS ((bfd *));
static bfd_reloc_status_type MY(fix_pcrel_26_done)
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type MY(fix_pcrel_26)
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static void MY(swap_std_reloc_in)
  PARAMS ((bfd *, struct reloc_std_external *, arelent *, asymbol **,
	   bfd_size_type));
reloc_howto_type *MY(bfd_reloc_type_lookup)
  PARAMS ((bfd *, bfd_reloc_code_real_type));
reloc_howto_type * MY(reloc_howto)
  PARAMS ((bfd *, struct reloc_std_external *, int *, int *, int *));
void MY(put_reloc)
  PARAMS ((bfd *, int, int, bfd_vma, reloc_howto_type *,
	   struct reloc_std_external *));
void MY(relocatable_reloc)
  PARAMS ((reloc_howto_type *, bfd *, struct reloc_std_external *, bfd_vma *,
	   bfd_vma));
void MY(swap_std_reloc_out)
  PARAMS ((bfd *, arelent *, struct reloc_std_external *));

reloc_howto_type MY(howto_table)[] =
  {
    /* Type rs size bsz pcrel bitpos ovrf sf name part_inpl
       readmask setmask pcdone.  */
    HOWTO (0, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, 0, "8", TRUE,
	   0x000000ff, 0x000000ff, FALSE),
    HOWTO (1, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, 0, "16", TRUE,
	   0x0000ffff, 0x0000ffff, FALSE),
    HOWTO (2, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, 0, "32", TRUE,
	   0xffffffff, 0xffffffff, FALSE),
    HOWTO (3, 2, 2, 26, TRUE, 0, complain_overflow_signed, MY(fix_pcrel_26),
	   "ARM26", TRUE, 0x00ffffff, 0x00ffffff, TRUE),
    HOWTO (4, 0, 0, 8, TRUE, 0, complain_overflow_signed, 0, "DISP8", TRUE,
	   0x000000ff, 0x000000ff, TRUE),
    HOWTO (5, 0, 1, 16, TRUE, 0, complain_overflow_signed, 0, "DISP16", TRUE,
	   0x0000ffff, 0x0000ffff, TRUE),
    HOWTO (6, 0, 2, 32, TRUE, 0, complain_overflow_signed, 0, "DISP32", TRUE,
	   0xffffffff, 0xffffffff, TRUE),
    HOWTO (7, 2, 2, 26, FALSE, 0, complain_overflow_signed,
	   MY(fix_pcrel_26_done), "ARM26D", TRUE, 0x0, 0x0,
	   FALSE),
    EMPTY_HOWTO (-1),
    HOWTO (9, 0, -1, 16, FALSE, 0, complain_overflow_bitfield, 0, "NEG16", TRUE,
	   0x0000ffff, 0x0000ffff, FALSE),
    HOWTO (10, 0, -2, 32, FALSE, 0, complain_overflow_bitfield, 0, "NEG32", TRUE,
	   0xffffffff, 0xffffffff, FALSE)
  };

#define RELOC_ARM_BITS_NEG_BIG      ((unsigned int) 0x08)
#define RELOC_ARM_BITS_NEG_LITTLE   ((unsigned int) 0x10)

reloc_howto_type *
MY(reloc_howto) (abfd, rel, r_index, r_extern, r_pcrel)
     bfd *abfd;
     struct reloc_std_external *rel;
     int *r_index;
     int *r_extern;
     int *r_pcrel;
{
  unsigned int r_length;
  unsigned int r_pcrel_done;
  unsigned int r_neg;
  int index;

  *r_pcrel = 0;
  if (bfd_header_big_endian (abfd))
    {
      *r_index     =  ((rel->r_index[0] << 16)
		       | (rel->r_index[1] << 8)
		       | rel->r_index[2]);
      *r_extern    = (0 != (rel->r_type[0] & RELOC_STD_BITS_EXTERN_BIG));
      r_pcrel_done = (0 != (rel->r_type[0] & RELOC_STD_BITS_PCREL_BIG));
      r_neg 	   = (0 != (rel->r_type[0] & RELOC_ARM_BITS_NEG_BIG));
      r_length     = ((rel->r_type[0] & RELOC_STD_BITS_LENGTH_BIG)
		      >> RELOC_STD_BITS_LENGTH_SH_BIG);
    }
  else
    {
      *r_index     = ((rel->r_index[2] << 16)
		      | (rel->r_index[1] << 8)
		      | rel->r_index[0]);
      *r_extern    = (0 != (rel->r_type[0] & RELOC_STD_BITS_EXTERN_LITTLE));
      r_pcrel_done = (0 != (rel->r_type[0] & RELOC_STD_BITS_PCREL_LITTLE));
      r_neg 	   = (0 != (rel->r_type[0] & RELOC_ARM_BITS_NEG_LITTLE));
      r_length     = ((rel->r_type[0] & RELOC_STD_BITS_LENGTH_LITTLE)
		      >> RELOC_STD_BITS_LENGTH_SH_LITTLE);
    }
  index = r_length + 4 * r_pcrel_done + 8 * r_neg;
  if (index == 3)
    *r_pcrel = 1;

  return MY(howto_table) + index;
}

#define MY_reloc_howto(BFD, REL, IN, EX, PC) \
	MY(reloc_howto) (BFD, REL, &IN, &EX, &PC)

void
MY(put_reloc) (abfd, r_extern, r_index, value, howto, reloc)
     bfd *abfd;
     int r_extern;
     int r_index;
     bfd_vma value;
     reloc_howto_type *howto;
     struct reloc_std_external *reloc;
{
  unsigned int r_length;
  int r_pcrel;
  int r_neg;

  PUT_WORD (abfd, value, reloc->r_address);
  /* Size as a power of two.  */
  r_length = howto->size;

  /* Special case for branch relocations.  */
  if (howto->type == 3 || howto->type == 7)
    r_length = 3;

  r_pcrel  = howto->type & 4; 	/* PC Relative done?  */
  r_neg = howto->type & 8;	/* Negative relocation.  */

  if (bfd_header_big_endian (abfd))
    {
      reloc->r_index[0] = r_index >> 16;
      reloc->r_index[1] = r_index >> 8;
      reloc->r_index[2] = r_index;
      reloc->r_type[0] =
	((r_extern ?     RELOC_STD_BITS_EXTERN_BIG : 0)
	 | (r_pcrel ?    RELOC_STD_BITS_PCREL_BIG : 0)
	 | (r_neg ?	 RELOC_ARM_BITS_NEG_BIG : 0)
	 | (r_length <<  RELOC_STD_BITS_LENGTH_SH_BIG));
    }
  else
    {
      reloc->r_index[2] = r_index >> 16;
      reloc->r_index[1] = r_index >> 8;
      reloc->r_index[0] = r_index;
      reloc->r_type[0] =
	((r_extern ?     RELOC_STD_BITS_EXTERN_LITTLE : 0)
	 | (r_pcrel ?    RELOC_STD_BITS_PCREL_LITTLE : 0)
	 | (r_neg ?	 RELOC_ARM_BITS_NEG_LITTLE : 0)
	 | (r_length <<  RELOC_STD_BITS_LENGTH_SH_LITTLE));
    }
}

#define MY_put_reloc(BFD, EXT, IDX, VAL, HOWTO, RELOC) \
  MY(put_reloc) (BFD, EXT, IDX, VAL, HOWTO, RELOC)

void
MY(relocatable_reloc) (howto, abfd, reloc, amount, r_addr)
     reloc_howto_type *howto;
     bfd *abfd;
     struct reloc_std_external *reloc;
     bfd_vma *amount;
     bfd_vma r_addr;
{
  if (howto->type == 3)
    {
      if (reloc->r_type[0]
	  & (bfd_header_big_endian (abfd)
	     ? RELOC_STD_BITS_EXTERN_BIG : RELOC_STD_BITS_EXTERN_LITTLE))
	{
	  /* The reloc is still external, so don't modify anything.  */
	  *amount = 0;
	}
      else
	{
	  *amount -= r_addr;
	  /* Change the r_pcrel value -- on the ARM, this bit is set once the
	     relocation is done.  */
	  if (bfd_header_big_endian (abfd))
	    reloc->r_type[0] |= RELOC_STD_BITS_PCREL_BIG;
	  else
	    reloc->r_type[0] |= RELOC_STD_BITS_PCREL_LITTLE;
	}
    }
  else if (howto->type == 7)
    *amount = 0;
}

#define MY_relocatable_reloc(HOW, BFD, REL, AMOUNT, ADDR) \
  MY(relocatable_reloc) (HOW, BFD, REL, &(AMOUNT), ADDR)

static bfd_reloc_status_type
MY(fix_pcrel_26_done) (abfd, reloc_entry, symbol, data, input_section,
		       output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     char **error_message ATTRIBUTE_UNUSED;
{
  /* This is dead simple at present.  */
  return bfd_reloc_ok;
}

static bfd_reloc_status_type
MY(fix_pcrel_26) (abfd, reloc_entry, symbol, data, input_section,
		  output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  bfd_vma relocation;
  bfd_size_type addr = reloc_entry->address;
  bfd_vma target = bfd_get_32 (abfd, (bfd_byte *) data + addr);
  bfd_reloc_status_type flag = bfd_reloc_ok;

  /* If this is an undefined symbol, return error.  */
  if (symbol->section == &bfd_und_section
      && (symbol->flags & BSF_WEAK) == 0)
    return output_bfd ? bfd_reloc_ok : bfd_reloc_undefined;

  /* If the sections are different, and we are doing a partial relocation,
     just ignore it for now.  */
  if (symbol->section->name != input_section->name
      && output_bfd != (bfd *)NULL)
    return bfd_reloc_ok;

  relocation = (target & 0x00ffffff) << 2;
  relocation = (relocation ^ 0x02000000) - 0x02000000; /* Sign extend.  */
  relocation += symbol->value;
  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;
  relocation -= input_section->output_section->vma;
  relocation -= input_section->output_offset;
  relocation -= addr;
  if (relocation & 3)
    return bfd_reloc_overflow;

  /* Check for overflow.  */
  if (relocation & 0x02000000)
    {
      if ((relocation & ~ (bfd_vma) 0x03ffffff) != ~ (bfd_vma) 0x03ffffff)
	flag = bfd_reloc_overflow;
    }
  else if (relocation & ~ (bfd_vma) 0x03ffffff)
    flag = bfd_reloc_overflow;

  target &= ~ (bfd_vma) 0x00ffffff;
  target |= (relocation >> 2) & 0x00ffffff;
  bfd_put_32 (abfd, target, (bfd_byte *) data + addr);

  /* Now the ARM magic... Change the reloc type so that it is marked as done.
     Strictly this is only necessary if we are doing a partial relocation.  */
  reloc_entry->howto = &MY(howto_table)[7];

  return flag;
}

reloc_howto_type *
MY(bfd_reloc_type_lookup) (abfd,code)
     bfd *abfd;
     bfd_reloc_code_real_type code;
{
#define ASTD(i,j)       case i: return &MY(howto_table)[j]
  if (code == BFD_RELOC_CTOR)
    switch (bfd_get_arch_info (abfd)->bits_per_address)
      {
      case 32:
        code = BFD_RELOC_32;
        break;
      default:
	return (const struct reloc_howto_struct *) 0;
      }

  switch (code)
    {
      ASTD (BFD_RELOC_16, 1);
      ASTD (BFD_RELOC_32, 2);
      ASTD (BFD_RELOC_ARM_PCREL_BRANCH, 3);
      ASTD (BFD_RELOC_8_PCREL, 4);
      ASTD (BFD_RELOC_16_PCREL, 5);
      ASTD (BFD_RELOC_32_PCREL, 6);
    default:
      return (const struct reloc_howto_struct *) 0;
    }
}

#define MY_swap_std_reloc_in MY(swap_std_reloc_in)
#define MY_swap_std_reloc_out MY(swap_std_reloc_out)
#define MY_get_section_contents _bfd_generic_get_section_contents
/* #define MY_bfd_link_hash_table_create _bfd_generic_link_hash_table_create */
/* #define MY_bfd_link_add_symbols _bfd_generic_link_add_symbols */
/* #define MY_bfd_final_link _bfd_generic_final_link */

#include "aoutx.h"

static void
MY_swap_std_reloc_in (abfd, bytes, cache_ptr, symbols, symcount)
     bfd *abfd;
     struct reloc_std_external *bytes;
     arelent *cache_ptr;
     asymbol **symbols;
     bfd_size_type symcount ATTRIBUTE_UNUSED;
{
  int r_index;
  int r_extern;
  int r_pcrel;
  struct aoutdata *su = &(abfd->tdata.aout_data->a);

  cache_ptr->address = H_GET_32 (abfd, bytes->r_address);

  cache_ptr->howto = MY_reloc_howto (abfd, bytes, r_index, r_extern, r_pcrel);

  MOVE_ADDRESS (0);
}

void
MY_swap_std_reloc_out (abfd, g, natptr)
     bfd *abfd;
     arelent *g;
     struct reloc_std_external *natptr;
{
  int r_index;
  asymbol *sym = *(g->sym_ptr_ptr);
  int r_extern;
  int r_length;
  int r_pcrel;
  int r_neg = 0;	/* Negative relocs use the BASEREL bit.  */
  asection *output_section = sym->section->output_section;

  PUT_WORD(abfd, g->address, natptr->r_address);

  r_length = g->howto->size ;   /* Size as a power of two */
  if (r_length < 0)
    {
      r_length = -r_length;
      r_neg = 1;
    }

  r_pcrel  = (int) g->howto->pc_relative; /* Relative to PC? */

  /* For RISC iX, in pc-relative relocs the r_pcrel bit means that the
     relocation has been done already (Only for the 26-bit one I think)???!!!
     */

  if (g->howto->type == 3)
    {
      r_length = 3;
      r_pcrel = 0;
    }
  else if (g->howto->type == 7)
    {
      r_length = 3;
      r_pcrel = 1;
    }

#if 0
  /* For a standard reloc, the addend is in the object file.  */
  r_addend = g->addend + (*(g->sym_ptr_ptr))->section->output_section->vma;
#endif

  /* name was clobbered by aout_write_syms to be symbol index */

  /* If this relocation is relative to a symbol then set the
     r_index to the symbols index, and the r_extern bit.

     Absolute symbols can come in in two ways, either as an offset
     from the abs section, or as a symbol which has an abs value.
     check for that here
     */

  if (bfd_is_com_section (output_section)
      || output_section == &bfd_abs_section
      || output_section == &bfd_und_section)
    {
      if (bfd_abs_section.symbol == sym)
	{
	  /* Whoops, looked like an abs symbol, but is really an offset
	     from the abs section.  */
	  r_index = 0;
	  r_extern = 0;
	}
      else
	{
	  /* Fill in symbol.  */
	  r_extern = 1;
	  r_index = (*(g->sym_ptr_ptr))->KEEPIT;
	}
    }
  else
    {
      /* Just an ordinary section.  */
      r_extern = 0;
      r_index  = output_section->target_index;
    }

  /* Now the fun stuff.  */
  if (bfd_header_big_endian (abfd))
    {
      natptr->r_index[0] = r_index >> 16;
      natptr->r_index[1] = r_index >> 8;
      natptr->r_index[2] = r_index;
      natptr->r_type[0] =
	(  (r_extern ?   RELOC_STD_BITS_EXTERN_BIG: 0)
	 | (r_pcrel  ?   RELOC_STD_BITS_PCREL_BIG: 0)
	 | (r_neg    ?   RELOC_ARM_BITS_NEG_BIG: 0)
	 | (r_length <<  RELOC_STD_BITS_LENGTH_SH_BIG));
    }
  else
    {
      natptr->r_index[2] = r_index >> 16;
      natptr->r_index[1] = r_index >> 8;
      natptr->r_index[0] = r_index;
      natptr->r_type[0] =
	(  (r_extern ?   RELOC_STD_BITS_EXTERN_LITTLE: 0)
	 | (r_pcrel  ?   RELOC_STD_BITS_PCREL_LITTLE: 0)
	 | (r_neg    ?   RELOC_ARM_BITS_NEG_LITTLE: 0)
	 | (r_length <<  RELOC_STD_BITS_LENGTH_SH_LITTLE));
    }
}

#define MY_BFD_TARGET

#include "aout-target.h"

extern const bfd_target aout_arm_big_vec;

const bfd_target aout_arm_little_vec =
  {
    "a.out-arm-little",           /* name */
    bfd_target_aout_flavour,
    BFD_ENDIAN_LITTLE,            /* target byte order (little) */
    BFD_ENDIAN_LITTLE,            /* target headers byte order (little) */
    (HAS_RELOC | EXEC_P |         /* object flags */
     HAS_LINENO | HAS_DEBUG |
     HAS_SYMS | HAS_LOCALS | DYNAMIC | WP_TEXT | D_PAGED),
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
    MY_symbol_leading_char,
    AR_PAD_CHAR,                  /* ar_pad_char */
    15,                           /* ar_max_namelen */
    bfd_getl64, bfd_getl_signed_64, bfd_putl64,
    bfd_getl32, bfd_getl_signed_32, bfd_putl32,
    bfd_getl16, bfd_getl_signed_16, bfd_putl16,	/* data */
    bfd_getl64, bfd_getl_signed_64, bfd_putl64,
    bfd_getl32, bfd_getl_signed_32, bfd_putl32,
    bfd_getl16, bfd_getl_signed_16, bfd_putl16,	/* hdrs */
    {_bfd_dummy_target, MY_object_p,		/* bfd_check_format */
     bfd_generic_archive_p, MY_core_file_p},
    {bfd_false, MY_mkobject,			/* bfd_set_format */
     _bfd_generic_mkarchive, bfd_false},
    {bfd_false, MY_write_object_contents,	/* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

    BFD_JUMP_TABLE_GENERIC (MY),
    BFD_JUMP_TABLE_COPY (MY),
    BFD_JUMP_TABLE_CORE (MY),
    BFD_JUMP_TABLE_ARCHIVE (MY),
    BFD_JUMP_TABLE_SYMBOLS (MY),
    BFD_JUMP_TABLE_RELOCS (MY),
    BFD_JUMP_TABLE_WRITE (MY),
    BFD_JUMP_TABLE_LINK (MY),
    BFD_JUMP_TABLE_DYNAMIC (MY),

    & aout_arm_big_vec,

    (PTR) MY_backend_data,
  };

const bfd_target aout_arm_big_vec =
  {
    "a.out-arm-big",              /* name */
    bfd_target_aout_flavour,
    BFD_ENDIAN_BIG,               /* target byte order (big) */
    BFD_ENDIAN_BIG,               /* target headers byte order (big) */
    (HAS_RELOC | EXEC_P |         /* object flags */
     HAS_LINENO | HAS_DEBUG |
     HAS_SYMS | HAS_LOCALS | DYNAMIC | WP_TEXT | D_PAGED),
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
    MY_symbol_leading_char,
    AR_PAD_CHAR,                  		/* ar_pad_char */
    15,                           		/* ar_max_namelen */
    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
    bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
    bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */
    {_bfd_dummy_target, MY_object_p,		/* bfd_check_format */
     bfd_generic_archive_p, MY_core_file_p},
    {bfd_false, MY_mkobject,			/* bfd_set_format */
     _bfd_generic_mkarchive, bfd_false},
    {bfd_false, MY_write_object_contents,	/* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

    BFD_JUMP_TABLE_GENERIC (MY),
    BFD_JUMP_TABLE_COPY (MY),
    BFD_JUMP_TABLE_CORE (MY),
    BFD_JUMP_TABLE_ARCHIVE (MY),
    BFD_JUMP_TABLE_SYMBOLS (MY),
    BFD_JUMP_TABLE_RELOCS (MY),
    BFD_JUMP_TABLE_WRITE (MY),
    BFD_JUMP_TABLE_LINK (MY),
    BFD_JUMP_TABLE_DYNAMIC (MY),

    & aout_arm_little_vec,

    (PTR) MY_backend_data,
  };
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d25 1
a25 1
/* Avoid multiple defininitions from aoutx if supporting standarad a.out
@


1.5
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 1999, 2000
d22 18
a39 5
#define N_TXTADDR(x) \
  ((N_MAGIC(x) == NMAGIC) ? 0x8000 : \
   (N_MAGIC(x) != ZMAGIC) ? 0 : \
   (N_SHARED_LIB(x)) ? ((x).a_entry & ~(TARGET_PAGE_SIZE - 1)) : \
   TEXT_START_ADDR)
d46 1
a46 1
#define MY(OP) CAT(aoutarm_,OP)
a51 12
#include "bfd.h"
#include "sysdep.h"

#define MYARM(OP) CAT(aoutarm_,OP)
reloc_howto_type 	*MYARM(bfd_reloc_type_lookup)
				PARAMS((bfd *, bfd_reloc_code_real_type));
static boolean 		MYARM(write_object_contents)	PARAMS((bfd *));

/* Avoid multiple defininitions from aoutx if supporting standarad a.out
   as well as our own.  */
#define NAME(x,y) CAT3(aoutarm,_32_,y)

d57 22
a78 13
static bfd_reloc_status_type
MY(fix_pcrel_26_done)	PARAMS ((bfd *, arelent *, asymbol *, PTR,
				 asection *, bfd *, char **));

static bfd_reloc_status_type
MY(fix_pcrel_26)	 PARAMS ((bfd *, arelent *, asymbol *, PTR,
				  asection *, bfd *, char **));
static void MY(swap_std_reloc_in) PARAMS ((bfd *, struct reloc_std_external *,
					   arelent *, asymbol **,
					   bfd_size_type));
void MY(swap_std_reloc_out) PARAMS ((bfd *, arelent *,
				     struct reloc_std_external *));

d80 26
a105 26
{
  /* type rs size bsz pcrel bitpos ovrf sf name part_inpl readmask setmask
     pcdone */
  HOWTO (0, 0, 0, 8, false, 0, complain_overflow_bitfield, 0, "8", true,
	 0x000000ff, 0x000000ff, false),
  HOWTO (1, 0, 1, 16, false, 0, complain_overflow_bitfield, 0, "16", true,
	 0x0000ffff, 0x0000ffff, false),
  HOWTO (2, 0, 2, 32, false, 0, complain_overflow_bitfield, 0, "32", true,
	 0xffffffff, 0xffffffff, false),
  HOWTO (3, 2, 2, 26, true, 0, complain_overflow_signed, MY(fix_pcrel_26),
	 "ARM26", true, 0x00ffffff, 0x00ffffff, true),
  HOWTO (4, 0, 0, 8, true, 0, complain_overflow_signed, 0, "DISP8", true,
	 0x000000ff, 0x000000ff, true),
  HOWTO (5, 0, 1, 16, true, 0, complain_overflow_signed, 0, "DISP16", true,
	 0x0000ffff, 0x0000ffff, true),
  HOWTO (6, 0, 2, 32, true, 0, complain_overflow_signed, 0, "DISP32", true,
	 0xffffffff, 0xffffffff, true),
  HOWTO (7, 2, 2, 26, false, 0, complain_overflow_signed,
	 MY(fix_pcrel_26_done), "ARM26D", true, 0x0, 0x0,
	 false),
  EMPTY_HOWTO (-1),
  HOWTO (9, 0, -1, 16, false, 0, complain_overflow_bitfield, 0, "NEG16", true,
	 0x0000ffff, 0x0000ffff, false),
  HOWTO (10, 0, -2, 32, false, 0, complain_overflow_bitfield, 0, "NEG32", true,
	 0xffffffff, 0xffffffff, false)
};
d161 1
a161 1
     long value;
d170 2
a171 1
  r_length = howto->size ;	/* Size as a power of two */
d177 3
a179 2
  r_pcrel  = howto->type & 4; 	/* PC Relative done? */
  r_neg = howto->type & 8;	/* Negative relocation */
d270 1
a270 1
  long target = bfd_get_32 (abfd, (bfd_byte *) data + addr);
d273 1
a273 1
  /* If this is an undefined symbol, return error */
d285 1
a285 1
  relocation = (relocation ^ 0x02000000) - 0x02000000; /* Sign extend */
d296 1
a296 1
  /* Check for overflow */
d302 1
a302 1
  else if (relocation & ~0x03ffffff)
d305 1
a305 1
  target &= ~0x00ffffff;
d328 2
a329 1
      default: return (CONST struct reloc_howto_struct *) 0;
d340 2
a341 1
    default: return (CONST struct reloc_howto_struct *) 0;
d367 1
a367 1
  cache_ptr->address = bfd_h_get_32 (abfd, bytes->r_address);
d436 1
a436 1
	     from the abs section */
d442 1
a442 1
	  /* Fill in symbol */
d449 1
a449 1
      /* Just an ordinary section */
d454 1
a454 1
  /* now the fun stuff */
d486 34
a519 34
{
  "a.out-arm-little",           /* name */
  bfd_target_aout_flavour,
  BFD_ENDIAN_LITTLE,            /* target byte order (little) */
  BFD_ENDIAN_LITTLE,            /* target headers byte order (little) */
  (HAS_RELOC | EXEC_P |         /* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | DYNAMIC | WP_TEXT | D_PAGED),
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
  MY_symbol_leading_char,
  AR_PAD_CHAR,                  /* ar_pad_char */
  15,                           /* ar_max_namelen */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */
    {_bfd_dummy_target, MY_object_p, /* bfd_check_format */
       bfd_generic_archive_p, MY_core_file_p},
    {bfd_false, MY_mkobject,    /* bfd_set_format */
       _bfd_generic_mkarchive, bfd_false},
    {bfd_false, MY_write_object_contents, /* bfd_write_contents */
       _bfd_write_archive_contents, bfd_false},

     BFD_JUMP_TABLE_GENERIC (MY),
     BFD_JUMP_TABLE_COPY (MY),
     BFD_JUMP_TABLE_CORE (MY),
     BFD_JUMP_TABLE_ARCHIVE (MY),
     BFD_JUMP_TABLE_SYMBOLS (MY),
     BFD_JUMP_TABLE_RELOCS (MY),
     BFD_JUMP_TABLE_WRITE (MY),
     BFD_JUMP_TABLE_LINK (MY),
     BFD_JUMP_TABLE_DYNAMIC (MY),
d521 1
a521 1
  & aout_arm_big_vec,
d523 2
a524 2
  (PTR) MY_backend_data,
};
d527 34
a560 34
{
  "a.out-arm-big",           /* name */
  bfd_target_aout_flavour,
  BFD_ENDIAN_BIG,               /* target byte order (big) */
  BFD_ENDIAN_BIG,               /* target headers byte order (big) */
  (HAS_RELOC | EXEC_P |         /* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | DYNAMIC | WP_TEXT | D_PAGED),
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
  MY_symbol_leading_char,
  AR_PAD_CHAR,                  /* ar_pad_char */
  15,                           /* ar_max_namelen */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */
    {_bfd_dummy_target, MY_object_p, /* bfd_check_format */
       bfd_generic_archive_p, MY_core_file_p},
    {bfd_false, MY_mkobject,    /* bfd_set_format */
       _bfd_generic_mkarchive, bfd_false},
    {bfd_false, MY_write_object_contents, /* bfd_write_contents */
       _bfd_write_archive_contents, bfd_false},

     BFD_JUMP_TABLE_GENERIC (MY),
     BFD_JUMP_TABLE_COPY (MY),
     BFD_JUMP_TABLE_CORE (MY),
     BFD_JUMP_TABLE_ARCHIVE (MY),
     BFD_JUMP_TABLE_SYMBOLS (MY),
     BFD_JUMP_TABLE_RELOCS (MY),
     BFD_JUMP_TABLE_WRITE (MY),
     BFD_JUMP_TABLE_LINK (MY),
     BFD_JUMP_TABLE_DYNAMIC (MY),
d562 1
a562 1
  & aout_arm_little_vec,
d564 2
a565 2
  (PTR) MY_backend_data,
};
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1994, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
d5 1
a5 1
   
a21 1

d47 1
a47 1
/* Avoid multiple defininitions from aoutx if supporting standarad a.out 
d66 1
a66 1
void MY(swap_std_reloc_out) PARAMS ((bfd *, arelent *, 
d101 1
a101 1
MY(reloc_howto)(abfd, rel, r_index, r_extern, r_pcrel)
d142 1
a142 1
 
d147 1
a147 1
MY(put_reloc)(abfd, r_extern, r_index, value, howto, reloc)
d162 1
a162 1
  /* Special case for branch relocations. */
d191 1
a191 1
 
d193 1
a193 1
  MY(put_reloc)(BFD, EXT, IDX, VAL, HOWTO, RELOC)
d196 1
a196 1
MY(relocatable_reloc)(howto, abfd, reloc, amount, r_addr)
d205 1
a205 1
      if (reloc->r_type[0] 
d209 1
a209 1
	  /* The reloc is still external, so don't modify anything. */
d228 1
a228 1
  MY(relocatable_reloc)(HOW, BFD, REL, &(AMOUNT), ADDR)
d260 1
a260 1
  
d300 1
a300 1
  
d305 1
a305 1
MY(bfd_reloc_type_lookup)(abfd,code)
d395 1
a395 1
    { 
a398 1
  
d508 1
a508 1
  
d549 1
a549 1
  
@


1.3
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1995 Free Software Foundation, Inc.
d90 1
a90 1
  {-1},
d233 7
a239 7
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d254 1
a254 1
     char **error_message;
d287 1
a287 1
      if ((relocation & ~0x03ffffff) != ~0x03ffffff)
d346 1
a346 1
     bfd_size_type symcount;
a349 1
  unsigned int r_length;
d470 2
d481 1
a481 1
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
d508 2
d522 1
a522 1
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
d549 2
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@a40 1
#include "assert.h"
@


1.1
log
@Initial revision
@
text
@d115 1
a115 1
  if (abfd->xvec->header_byteorder_big_p)
d169 1
a169 1
  if (abfd->xvec->header_byteorder_big_p)
d207 1
a207 1
	  & (abfd->xvec->header_byteorder_big_p
d218 1
a218 1
	  if (abfd->xvec->header_byteorder_big_p)
d433 1
a433 1
	  r_index =  stoi((*(g->sym_ptr_ptr))->flags);
d444 1
a444 1
  if (abfd->xvec->header_byteorder_big_p != false)
d476 2
a477 2
  false,                        /* target byte order (little) */
  false,                        /* target headers byte order (little) */
d515 2
a516 2
  true,                         /* target byte order (big) */
  true,                         /* target headers byte order (big) */
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d115 1
a115 1
  if (bfd_header_big_endian (abfd))
d169 1
a169 1
  if (bfd_header_big_endian (abfd))
d207 1
a207 1
	  & (bfd_header_big_endian (abfd)
d218 1
a218 1
	  if (bfd_header_big_endian (abfd))
d433 1
a433 1
	  r_index = (*(g->sym_ptr_ptr))->KEEPIT;
d444 1
a444 1
  if (bfd_header_big_endian (abfd))
d476 2
a477 2
  BFD_ENDIAN_LITTLE,            /* target byte order (little) */
  BFD_ENDIAN_LITTLE,            /* target headers byte order (little) */
d515 2
a516 2
  BFD_ENDIAN_BIG,               /* target byte order (big) */
  BFD_ENDIAN_BIG,               /* target headers byte order (big) */
@


1.1.1.3
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d41 1
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1995, 1996, 1997 Free Software Foundation, Inc.
d350 1
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
d90 1
a90 1
  EMPTY_HOWTO (-1),
d233 7
a239 7
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     char **error_message ATTRIBUTE_UNUSED;
d254 1
a254 1
     char **error_message ATTRIBUTE_UNUSED;
d287 1
a287 1
      if ((relocation & ~ (bfd_vma) 0x03ffffff) != ~ (bfd_vma) 0x03ffffff)
d346 1
a346 1
     bfd_size_type symcount ATTRIBUTE_UNUSED;
a469 2
extern const bfd_target aout_arm_big_vec;

d479 1
a479 1
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
a505 2
  & aout_arm_big_vec,
  
d518 1
a518 1
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
a544 2
  & aout_arm_little_vec,
  
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.
d4 1
a4 1

d21 1
d47 1
a47 1
/* Avoid multiple defininitions from aoutx if supporting standarad a.out
d66 1
a66 1
void MY(swap_std_reloc_out) PARAMS ((bfd *, arelent *,
d101 1
a101 1
MY(reloc_howto) (abfd, rel, r_index, r_extern, r_pcrel)
d142 1
a142 1

d147 1
a147 1
MY(put_reloc) (abfd, r_extern, r_index, value, howto, reloc)
d162 1
a162 1
  /* Special case for branch relocations.  */
d191 1
a191 1

d193 1
a193 1
  MY(put_reloc) (BFD, EXT, IDX, VAL, HOWTO, RELOC)
d196 1
a196 1
MY(relocatable_reloc) (howto, abfd, reloc, amount, r_addr)
d205 1
a205 1
      if (reloc->r_type[0]
d209 1
a209 1
	  /* The reloc is still external, so don't modify anything.  */
d228 1
a228 1
  MY(relocatable_reloc) (HOW, BFD, REL, &(AMOUNT), ADDR)
d260 1
a260 1

d300 1
a300 1

d305 1
a305 1
MY(bfd_reloc_type_lookup) (abfd,code)
d395 1
a395 1
    {
d399 1
d509 1
a509 1

d550 1
a550 1

@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002
d22 5
a26 18
#include "bfd.h"
#include "sysdep.h"

/* Avoid multiple defininitions from aoutx if supporting standarad a.out
   as well as our own.  */
/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
#define NAME(x,y) CONCAT3 (aoutarm,_32_,y)

#define N_TXTADDR(x)						\
  ((N_MAGIC (x) == NMAGIC)					\
   ? (bfd_vma) 0x8000						\
   : ((N_MAGIC (x) != ZMAGIC)					\
      ? (bfd_vma) 0						\
      : ((N_SHARED_LIB (x))					\
	 ? ((x).a_entry & ~(bfd_vma) (TARGET_PAGE_SIZE - 1))	\
	 : (bfd_vma) TEXT_START_ADDR)))
d33 1
a33 1
#define MY(OP) CONCAT2 (aoutarm_,OP)
d39 12
d56 13
a68 22
static bfd_boolean MY(write_object_contents)
  PARAMS ((bfd *));
static bfd_reloc_status_type MY(fix_pcrel_26_done)
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type MY(fix_pcrel_26)
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static void MY(swap_std_reloc_in)
  PARAMS ((bfd *, struct reloc_std_external *, arelent *, asymbol **,
	   bfd_size_type));
reloc_howto_type *MY(bfd_reloc_type_lookup)
  PARAMS ((bfd *, bfd_reloc_code_real_type));
reloc_howto_type * MY(reloc_howto)
  PARAMS ((bfd *, struct reloc_std_external *, int *, int *, int *));
void MY(put_reloc)
  PARAMS ((bfd *, int, int, bfd_vma, reloc_howto_type *,
	   struct reloc_std_external *));
void MY(relocatable_reloc)
  PARAMS ((reloc_howto_type *, bfd *, struct reloc_std_external *, bfd_vma *,
	   bfd_vma));
void MY(swap_std_reloc_out)
  PARAMS ((bfd *, arelent *, struct reloc_std_external *));

d70 26
a95 26
  {
    /* Type rs size bsz pcrel bitpos ovrf sf name part_inpl
       readmask setmask pcdone.  */
    HOWTO (0, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, 0, "8", TRUE,
	   0x000000ff, 0x000000ff, FALSE),
    HOWTO (1, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, 0, "16", TRUE,
	   0x0000ffff, 0x0000ffff, FALSE),
    HOWTO (2, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, 0, "32", TRUE,
	   0xffffffff, 0xffffffff, FALSE),
    HOWTO (3, 2, 2, 26, TRUE, 0, complain_overflow_signed, MY(fix_pcrel_26),
	   "ARM26", TRUE, 0x00ffffff, 0x00ffffff, TRUE),
    HOWTO (4, 0, 0, 8, TRUE, 0, complain_overflow_signed, 0, "DISP8", TRUE,
	   0x000000ff, 0x000000ff, TRUE),
    HOWTO (5, 0, 1, 16, TRUE, 0, complain_overflow_signed, 0, "DISP16", TRUE,
	   0x0000ffff, 0x0000ffff, TRUE),
    HOWTO (6, 0, 2, 32, TRUE, 0, complain_overflow_signed, 0, "DISP32", TRUE,
	   0xffffffff, 0xffffffff, TRUE),
    HOWTO (7, 2, 2, 26, FALSE, 0, complain_overflow_signed,
	   MY(fix_pcrel_26_done), "ARM26D", TRUE, 0x0, 0x0,
	   FALSE),
    EMPTY_HOWTO (-1),
    HOWTO (9, 0, -1, 16, FALSE, 0, complain_overflow_bitfield, 0, "NEG16", TRUE,
	   0x0000ffff, 0x0000ffff, FALSE),
    HOWTO (10, 0, -2, 32, FALSE, 0, complain_overflow_bitfield, 0, "NEG32", TRUE,
	   0xffffffff, 0xffffffff, FALSE)
  };
d151 1
a151 1
     bfd_vma value;
d160 1
a160 2
  /* Size as a power of two.  */
  r_length = howto->size;
d166 2
a167 3
  r_pcrel  = howto->type & 4; 	/* PC Relative done?  */
  r_neg = howto->type & 8;	/* Negative relocation.  */

d258 1
a258 1
  bfd_vma target = bfd_get_32 (abfd, (bfd_byte *) data + addr);
d261 1
a261 1
  /* If this is an undefined symbol, return error.  */
d273 1
a273 1
  relocation = (relocation ^ 0x02000000) - 0x02000000; /* Sign extend.  */
d284 1
a284 1
  /* Check for overflow.  */
d290 1
a290 1
  else if (relocation & ~ (bfd_vma) 0x03ffffff)
d293 1
a293 1
  target &= ~ (bfd_vma) 0x00ffffff;
d316 1
a316 2
      default:
	return (const struct reloc_howto_struct *) 0;
d327 1
a327 2
    default:
      return (const struct reloc_howto_struct *) 0;
d353 1
a353 1
  cache_ptr->address = H_GET_32 (abfd, bytes->r_address);
d422 1
a422 1
	     from the abs section.  */
d428 1
a428 1
	  /* Fill in symbol.  */
d435 1
a435 1
      /* Just an ordinary section.  */
d440 1
a440 1
  /* Now the fun stuff.  */
d472 34
a505 34
  {
    "a.out-arm-little",           /* name */
    bfd_target_aout_flavour,
    BFD_ENDIAN_LITTLE,            /* target byte order (little) */
    BFD_ENDIAN_LITTLE,            /* target headers byte order (little) */
    (HAS_RELOC | EXEC_P |         /* object flags */
     HAS_LINENO | HAS_DEBUG |
     HAS_SYMS | HAS_LOCALS | DYNAMIC | WP_TEXT | D_PAGED),
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
    MY_symbol_leading_char,
    AR_PAD_CHAR,                  /* ar_pad_char */
    15,                           /* ar_max_namelen */
    bfd_getl64, bfd_getl_signed_64, bfd_putl64,
    bfd_getl32, bfd_getl_signed_32, bfd_putl32,
    bfd_getl16, bfd_getl_signed_16, bfd_putl16,	/* data */
    bfd_getl64, bfd_getl_signed_64, bfd_putl64,
    bfd_getl32, bfd_getl_signed_32, bfd_putl32,
    bfd_getl16, bfd_getl_signed_16, bfd_putl16,	/* hdrs */
    {_bfd_dummy_target, MY_object_p,		/* bfd_check_format */
     bfd_generic_archive_p, MY_core_file_p},
    {bfd_false, MY_mkobject,			/* bfd_set_format */
     _bfd_generic_mkarchive, bfd_false},
    {bfd_false, MY_write_object_contents,	/* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

    BFD_JUMP_TABLE_GENERIC (MY),
    BFD_JUMP_TABLE_COPY (MY),
    BFD_JUMP_TABLE_CORE (MY),
    BFD_JUMP_TABLE_ARCHIVE (MY),
    BFD_JUMP_TABLE_SYMBOLS (MY),
    BFD_JUMP_TABLE_RELOCS (MY),
    BFD_JUMP_TABLE_WRITE (MY),
    BFD_JUMP_TABLE_LINK (MY),
    BFD_JUMP_TABLE_DYNAMIC (MY),
d507 1
a507 1
    & aout_arm_big_vec,
d509 2
a510 2
    (PTR) MY_backend_data,
  };
d513 34
a546 34
  {
    "a.out-arm-big",              /* name */
    bfd_target_aout_flavour,
    BFD_ENDIAN_BIG,               /* target byte order (big) */
    BFD_ENDIAN_BIG,               /* target headers byte order (big) */
    (HAS_RELOC | EXEC_P |         /* object flags */
     HAS_LINENO | HAS_DEBUG |
     HAS_SYMS | HAS_LOCALS | DYNAMIC | WP_TEXT | D_PAGED),
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
    MY_symbol_leading_char,
    AR_PAD_CHAR,                  		/* ar_pad_char */
    15,                           		/* ar_max_namelen */
    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
    bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
    bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */
    {_bfd_dummy_target, MY_object_p,		/* bfd_check_format */
     bfd_generic_archive_p, MY_core_file_p},
    {bfd_false, MY_mkobject,			/* bfd_set_format */
     _bfd_generic_mkarchive, bfd_false},
    {bfd_false, MY_write_object_contents,	/* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

    BFD_JUMP_TABLE_GENERIC (MY),
    BFD_JUMP_TABLE_COPY (MY),
    BFD_JUMP_TABLE_CORE (MY),
    BFD_JUMP_TABLE_ARCHIVE (MY),
    BFD_JUMP_TABLE_SYMBOLS (MY),
    BFD_JUMP_TABLE_RELOCS (MY),
    BFD_JUMP_TABLE_WRITE (MY),
    BFD_JUMP_TABLE_LINK (MY),
    BFD_JUMP_TABLE_DYNAMIC (MY),
d548 1
a548 1
    & aout_arm_little_vec,
d550 2
a551 2
    (PTR) MY_backend_data,
  };
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d25 1
a25 1
/* Avoid multiple definitions from aoutx if supporting standard a.out
@


