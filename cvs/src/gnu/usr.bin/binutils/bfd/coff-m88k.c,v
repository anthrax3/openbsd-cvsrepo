head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.50
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.48
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.44
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.46
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.38
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.42
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.40
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.11.02.20.45.04;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.17.21.54.20;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.29;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.07;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.43.37;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.31;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.31;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.05.02;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.18.08;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.45.27;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.20.55;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.11;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.22.14;	author miod;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD back-end for Motorola 88000 COFF "Binary Compatibility Standard" files.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000,
   2001, 2002, 2003
   Free Software Foundation, Inc.
   Written by Cygnus Support.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#define M88 1		/* Customize various include files */
#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "coff/m88k.h"
#include "coff/internal.h"
#include "libcoff.h"

static bfd_boolean m88k_is_local_label_name PARAMS ((bfd *, const char *));
static bfd_reloc_status_type m88k_special_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static void rtype2howto PARAMS ((arelent *, struct internal_reloc *));
static void reloc_processing
  PARAMS ((arelent *, struct internal_reloc *, asymbol **, bfd *, asection *));

#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (3)

#define GET_SCNHDR_NRELOC H_GET_32
#define GET_SCNHDR_NLNNO  H_GET_32

/* On coff-m88k, local labels start with '@@'.  */

#define coff_bfd_is_local_label_name m88k_is_local_label_name

static bfd_boolean
m88k_is_local_label_name (abfd, name)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name;
{
  return name[0] == '@@';
}

static bfd_reloc_status_type
m88k_special_reloc (abfd, reloc_entry, symbol, data,
		    input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  reloc_howto_type *howto = reloc_entry->howto;

  switch (howto->type)
    {
    case R_HVRT16:
    case R_LVRT16:
      if (output_bfd != (bfd *) NULL)
	{
	  /* This is a partial relocation, and we want to apply the
	     relocation to the reloc entry rather than the raw data.
	     Modify the reloc inplace to reflect what we now know.  */

	  reloc_entry->address += input_section->output_offset;
	}
      else
	{
	  bfd_vma output_base = 0;
	  bfd_vma addr = reloc_entry->address;
	  bfd_vma x = bfd_get_16 (abfd, (bfd_byte *) data + addr);
	  asection *reloc_target_output_section;
	  long relocation = 0;

	  /* Work out which section the relocation is targeted at and the
	     initial relocation command value.  */

	  /* Get symbol value.  (Common symbols are special.)  */
	  if (bfd_is_com_section (symbol->section))
	    relocation = 0;
	  else
	    relocation = symbol->value;

	  reloc_target_output_section = symbol->section->output_section;

	  /* Convert input-section-relative symbol value to absolute.  */
	  if (output_bfd)
	    output_base = 0;
	  else
	    output_base = reloc_target_output_section->vma;

	  relocation += output_base + symbol->section->output_offset;

	  /* Add in supplied addend.  */
	  relocation += ((reloc_entry->addend << howto->bitsize) + x);

	  reloc_entry->addend = 0;

	  relocation >>= (bfd_vma) howto->rightshift;

	  /* Shift everything up to where it's going to be used */

	  relocation <<= (bfd_vma) howto->bitpos;

	  if (relocation)
	    bfd_put_16 (abfd, (bfd_vma) relocation,
			(unsigned char *) data + addr);
	}

      /* If we are not producing relocatable output, return an error if
	 the symbol is not defined.  */
      if (bfd_is_und_section (symbol->section) && output_bfd == (bfd *) NULL)
	return bfd_reloc_undefined;

      return bfd_reloc_ok;

    default:
      if (output_bfd != (bfd *) NULL)
	{
	  /* This is a partial relocation, and we want to apply the
	     relocation to the reloc entry rather than the raw data.
	     Modify the reloc inplace to reflect what we now know.  */

	  reloc_entry->address += input_section->output_offset;
	  return bfd_reloc_ok;
	}
      break;
    }

  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  return bfd_reloc_ok;
}

static reloc_howto_type howto_table[] =
{
  HOWTO (R_PCR16L,			/* type */
	 02,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 TRUE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_signed,	/* complain_on_overflow */
	 m88k_special_reloc,		/* special_function */
	 "PCR16L",			/* name */
	 FALSE,				/* partial_inplace */
	 0x0000ffff,			/* src_mask */
	 0x0000ffff,			/* dst_mask */
	 TRUE),				/* pcrel_offset */

  HOWTO (R_PCR26L,			/* type */
	 02,				/* rightshift */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 26,				/* bitsize */
	 TRUE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_signed,	/* complain_on_overflow */
	 m88k_special_reloc,		/* special_function */
	 "PCR26L",			/* name */
	 FALSE,				/* partial_inplace */
	 0x03ffffff,			/* src_mask */
	 0x03ffffff,			/* dst_mask */
	 TRUE),				/* pcrel_offset */

  HOWTO (R_VRT16,			/* type */
	 00,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 m88k_special_reloc,		/* special_function */
	 "VRT16",			/* name */
	 FALSE,				/* partial_inplace */
	 0x0000ffff,			/* src_mask */
	 0x0000ffff,			/* dst_mask */
	 TRUE),				/* pcrel_offset */

  HOWTO (R_HVRT16,			/* type */
	 16,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 m88k_special_reloc,		/* special_function */
	 "HVRT16",			/* name */
	 FALSE,				/* partial_inplace */
	 0x0000ffff,			/* src_mask */
	 0x0000ffff,			/* dst_mask */
	 TRUE),				/* pcrel_offset */

  HOWTO (R_LVRT16,			/* type */
	 00,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 m88k_special_reloc,		/* special_function */
	 "LVRT16",			/* name */
	 FALSE,				/* partial_inplace */
	 0x0000ffff,			/* src_mask */
	 0x0000ffff,			/* dst_mask */
	 TRUE),				/* pcrel_offset */

  HOWTO (R_VRT32,			/* type */
	 00,				/* rightshift */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 32,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 m88k_special_reloc,		/* special_function */
	 "VRT32",			/* name */
	 FALSE,				/* partial_inplace */
	 0xffffffff,			/* src_mask */
	 0xffffffff,			/* dst_mask */
	 TRUE),				/* pcrel_offset */
};

/* Code to turn an external r_type into a pointer to an entry in the
   above howto table.  */
static void
rtype2howto (cache_ptr, dst)
     arelent *cache_ptr;
     struct internal_reloc *dst;
{
  if (dst->r_type >= R_PCR16L && dst->r_type <= R_VRT32)
    {
      cache_ptr->howto = howto_table + dst->r_type - R_PCR16L;
    }
  else
    {
      BFD_ASSERT (0);
    }
}

#define RTYPE2HOWTO(cache_ptr, dst) rtype2howto (cache_ptr, dst)

/* Code to swap in the reloc offset */
#define SWAP_IN_RELOC_OFFSET  H_GET_16
#define SWAP_OUT_RELOC_OFFSET H_PUT_16

#define RELOC_PROCESSING(relent,reloc,symbols,abfd,section)	\
  reloc_processing(relent, reloc, symbols, abfd, section)

static void
reloc_processing (relent, reloc, symbols, abfd, section)
     arelent *relent;
     struct internal_reloc *reloc;
     asymbol **symbols;
     bfd *abfd;
     asection *section;
{
  relent->address = reloc->r_vaddr;
  rtype2howto (relent, reloc);

  if (((int) reloc->r_symndx) > 0)
    {
      relent->sym_ptr_ptr = symbols + obj_convert (abfd)[reloc->r_symndx];
    }
  else
    {
      relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
    }

  relent->addend = reloc->r_offset;
  relent->address -= section->vma;
}

#define BADMAG(x) MC88BADMAG(x)
#include "coffcode.h"

#undef coff_write_armap

CREATE_BIG_COFF_TARGET_VEC (m88kbcs_vec, "coff-m88kbcs", 0, 0, '_', NULL, COFF_SWAP_TABLE)
@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d1 1
a1 1
/* BFD back-end for Motorola 88000 COFF "Binary Compatability Standard" files.
d3 1
a3 1
   2001, 2002
d88 1
a88 1
	  /* Work out which section the relocation is targetted at and the
d123 1
a123 1
      /* If we are not producing relocateable output, return an error if
d291 1
a291 1
CREATE_BIG_COFF_TARGET_VEC (m88kbcs_vec, "coff-m88kbcs", 0, 0, '_', NULL)
@


1.4
log
@resolve conflicts.
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000
d31 1
a31 1
static boolean m88k_is_local_label_name PARAMS ((bfd *, const char *));
d40 2
a41 2
#define GET_SCNHDR_NRELOC bfd_h_get_32
#define GET_SCNHDR_NLNNO bfd_h_get_32
d47 1
a47 1
static boolean
d119 2
a120 1
	      bfd_put_16 (abfd, relocation, (unsigned char *) data + addr);
d155 1
a155 1
	 true,				/* pc_relative */
d160 1
a160 1
	 false,				/* partial_inplace */
d163 1
a163 1
	 true),				/* pcrel_offset */
d169 1
a169 1
	 true,				/* pc_relative */
d174 1
a174 1
	 false,				/* partial_inplace */
d177 1
a177 1
	 true),				/* pcrel_offset */
d183 1
a183 1
	 false,				/* pc_relative */
d188 1
a188 1
	 false,				/* partial_inplace */
d191 1
a191 1
	 true),				/* pcrel_offset */
d197 1
a197 1
	 false,				/* pc_relative */
d202 1
a202 1
	 false,				/* partial_inplace */
d205 1
a205 1
	 true),				/* pcrel_offset */
d211 1
a211 1
	 false,				/* pc_relative */
d216 1
a216 1
	 false,				/* partial_inplace */
d219 1
a219 1
	 true),				/* pcrel_offset */
d225 1
a225 1
	 false,				/* pc_relative */
d230 1
a230 1
	 false,				/* partial_inplace */
d233 1
a233 1
	 true),				/* pcrel_offset */
d256 2
a257 2
#define SWAP_IN_RELOC_OFFSET  bfd_h_get_16
#define SWAP_OUT_RELOC_OFFSET bfd_h_put_16
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 97, 98, 1999
d54 1
a54 1
static bfd_reloc_status_type 
d147 1
a147 1
static reloc_howto_type howto_table[] = 
a252 1

a255 1

@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.
a25 1
#include "obstack.h"
d30 1
d39 15
d63 1
a63 1
     char **error_message;
d121 5
a126 1
      break;
d291 1
a291 41
const bfd_target m88kbcs_vec =
{
  "coff-m88kbcs",		/* name */
  bfd_target_coff_flavour,
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT),

  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
  '_',				/* leading underscore */
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */

    {_bfd_dummy_target, coff_object_p, /* bfd_check_format */
       bfd_generic_archive_p, _bfd_dummy_target},
    {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format */
       bfd_false},
    {bfd_false, coff_write_object_contents, /* bfd_write_contents */
       _bfd_write_archive_contents, bfd_false},

     BFD_JUMP_TABLE_GENERIC (coff),
     BFD_JUMP_TABLE_COPY (coff),
     BFD_JUMP_TABLE_CORE (_bfd_nocore),
     BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
     BFD_JUMP_TABLE_SYMBOLS (coff),
     BFD_JUMP_TABLE_RELOCS (coff),
     BFD_JUMP_TABLE_WRITE (coff),
     BFD_JUMP_TABLE_LINK (coff),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  COFF_SWAP_TABLE,
};
@


1.1
log
@Initial revision
@
text
@d30 2
d33 2
a37 18
#undef HOWTO_PREPARE
/* Provided the symbol, returns the value reffed */
#define HOWTO_PREPARE(relocation, symbol) 	\
  {						\
  if (symbol != (asymbol *)NULL) {		\
    if (bfd_is_com_section (symbol->section)) { \
      relocation = 0;				\
    }						\
    else {					\
      relocation = symbol->value;		\
    }						\
  }						\
  if (symbol->section != (asection *)NULL) {	\
    relocation += symbol->section->output_section->vma +	\
      symbol->section->output_offset;		\
  }						\
}			

d39 2
a40 2
howto_hvrt16 (abfd, reloc_entry, symbol_in, data,
	      ignore_input_section, ignore_bfd, error_message)
d43 1
a43 1
     asymbol *symbol_in;
d45 2
a46 2
     asection *ignore_input_section;
     bfd *ignore_bfd;
d49 1
a49 3
  long relocation = 0;
  bfd_vma addr = reloc_entry->address;
  long x = bfd_get_16(abfd, (bfd_byte *)data + addr);
d51 69
a119 1
  HOWTO_PREPARE(relocation, symbol_in);
d121 2
a122 1
  x = (x + relocation + reloc_entry->addend) >> 16;
a123 1
  bfd_put_16(abfd, x, (bfd_byte *)data + addr);
a126 2


d129 83
a211 6
  HOWTO(R_PCR16L,02,1,16,true, 0,complain_overflow_signed, 0, "PCR16L",false,0x0000ffff,0x0000ffff,true),
  HOWTO(R_PCR26L,02,2,26,true, 0,complain_overflow_signed, 0, "PCR26L",false,0x03ffffff,0x03ffffff,true),
  HOWTO(R_VRT16, 00,1,16,false,0,complain_overflow_bitfield, 0, "VRT16", false,0x0000ffff,0x0000ffff,true),
  HOWTO(R_HVRT16,16,1,16,false,0,complain_overflow_dont,howto_hvrt16,"HVRT16",false,0x0000ffff,0x0000ffff,true),
  HOWTO(R_LVRT16,00,1,16,false,0,complain_overflow_dont, 0, "LVRT16",false,0x0000ffff,0x0000ffff,true),
  HOWTO(R_VRT32, 00,2,32,false,0,complain_overflow_bitfield, 0, "VRT32", false,0xffffffff,0xffffffff,true),
a213 6

/* Code to swap in the reloc offset */
#define SWAP_IN_RELOC_OFFSET  bfd_h_get_16
#define SWAP_OUT_RELOC_OFFSET bfd_h_put_16


a223 1
      cache_ptr->addend += dst->r_offset << 16;
d233 33
d275 2
a276 2
  true,				/* data byte order is big */
  true,				/* header byte order is big */
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@a29 2
static bfd_reloc_status_type m88k_special_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
a30 2
static void reloc_processing
  PARAMS ((arelent *, struct internal_reloc *, asymbol **, bfd *, asection *));
d34 18
d53 2
a54 2
m88k_special_reloc (abfd, reloc_entry, symbol, data,
		    input_section, output_bfd, error_message)
d57 1
a57 1
     asymbol *symbol;
d59 2
a60 2
     asection *input_section;
     bfd *output_bfd;
d63 3
a65 1
  reloc_howto_type *howto = reloc_entry->howto;
d67 1
a67 69
  switch (howto->type)
    {
    case R_HVRT16:
    case R_LVRT16:
      if (output_bfd != (bfd *) NULL)
	{
	  /* This is a partial relocation, and we want to apply the
	     relocation to the reloc entry rather than the raw data.
	     Modify the reloc inplace to reflect what we now know.  */

	  reloc_entry->address += input_section->output_offset;
	}
      else
	{
	  bfd_vma output_base = 0;
	  bfd_vma addr = reloc_entry->address;
	  bfd_vma x = bfd_get_16 (abfd, (bfd_byte *) data + addr);
	  asection *reloc_target_output_section;
	  long relocation = 0;

	  /* Work out which section the relocation is targetted at and the
	     initial relocation command value.  */

	  /* Get symbol value.  (Common symbols are special.)  */
	  if (bfd_is_com_section (symbol->section))
	    relocation = 0;
	  else
	    relocation = symbol->value;

	  reloc_target_output_section = symbol->section->output_section;

	  /* Convert input-section-relative symbol value to absolute.  */
	  if (output_bfd)
	    output_base = 0;
	  else
	    output_base = reloc_target_output_section->vma;

	  relocation += output_base + symbol->section->output_offset;

	  /* Add in supplied addend.  */
	  relocation += ((reloc_entry->addend << howto->bitsize) + x);

	  reloc_entry->addend = 0;

	  relocation >>= (bfd_vma) howto->rightshift;

	  /* Shift everything up to where it's going to be used */

	  relocation <<= (bfd_vma) howto->bitpos;

	  if (relocation)
	      bfd_put_16 (abfd, relocation, (unsigned char *) data + addr);
	}

      return bfd_reloc_ok;
      break;

    default:
      if (output_bfd != (bfd *) NULL)
	{
	  /* This is a partial relocation, and we want to apply the
	     relocation to the reloc entry rather than the raw data.
	     Modify the reloc inplace to reflect what we now know.  */

	  reloc_entry->address += input_section->output_offset;
	  return bfd_reloc_ok;
	}
      break;
    }
d69 1
a69 2
  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;
d71 1
d75 2
d79 6
a84 83
  HOWTO (R_PCR16L,			/* type */
	 02,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 true,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_signed,	/* complain_on_overflow */
	 m88k_special_reloc,		/* special_function */
	 "PCR16L",			/* name */
	 false,				/* partial_inplace */
	 0x0000ffff,			/* src_mask */
	 0x0000ffff,			/* dst_mask */
	 true),				/* pcrel_offset */

  HOWTO (R_PCR26L,			/* type */
	 02,				/* rightshift */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 26,				/* bitsize */
	 true,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_signed,	/* complain_on_overflow */
	 m88k_special_reloc,		/* special_function */
	 "PCR26L",			/* name */
	 false,				/* partial_inplace */
	 0x03ffffff,			/* src_mask */
	 0x03ffffff,			/* dst_mask */
	 true),				/* pcrel_offset */

  HOWTO (R_VRT16,			/* type */
	 00,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 false,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 m88k_special_reloc,		/* special_function */
	 "VRT16",			/* name */
	 false,				/* partial_inplace */
	 0x0000ffff,			/* src_mask */
	 0x0000ffff,			/* dst_mask */
	 true),				/* pcrel_offset */

  HOWTO (R_HVRT16,			/* type */
	 16,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 false,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 m88k_special_reloc,		/* special_function */
	 "HVRT16",			/* name */
	 false,				/* partial_inplace */
	 0x0000ffff,			/* src_mask */
	 0x0000ffff,			/* dst_mask */
	 true),				/* pcrel_offset */

  HOWTO (R_LVRT16,			/* type */
	 00,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 false,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 m88k_special_reloc,		/* special_function */
	 "LVRT16",			/* name */
	 false,				/* partial_inplace */
	 0x0000ffff,			/* src_mask */
	 0x0000ffff,			/* dst_mask */
	 true),				/* pcrel_offset */

  HOWTO (R_VRT32,			/* type */
	 00,				/* rightshift */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 32,				/* bitsize */
	 false,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 m88k_special_reloc,		/* special_function */
	 "VRT32",			/* name */
	 false,				/* partial_inplace */
	 0xffffffff,			/* src_mask */
	 0xffffffff,			/* dst_mask */
	 true),				/* pcrel_offset */
d87 6
d103 1
a112 33

/* Code to swap in the reloc offset */
#define SWAP_IN_RELOC_OFFSET  bfd_h_get_16
#define SWAP_OUT_RELOC_OFFSET bfd_h_put_16


#define RELOC_PROCESSING(relent,reloc,symbols,abfd,section)	\
  reloc_processing(relent, reloc, symbols, abfd, section)

static void
reloc_processing (relent, reloc, symbols, abfd, section)
     arelent *relent;
     struct internal_reloc *reloc;
     asymbol **symbols;
     bfd *abfd;
     asection *section;
{
  relent->address = reloc->r_vaddr;
  rtype2howto (relent, reloc);

  if (((int) reloc->r_symndx) > 0)
    {
      relent->sym_ptr_ptr = symbols + obj_convert (abfd)[reloc->r_symndx];
    }
  else
    {
      relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
    }

  relent->addend = reloc->r_offset;
  relent->address -= section->vma;
}

d122 2
a123 2
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */
@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 1997 Free Software Foundation, Inc.
d25 1
a29 1
static boolean m88k_is_local_label_name PARAMS ((bfd *, const char *));
a36 12

/* On coff-m88k, local labels start with '@@'.  */

#define coff_bfd_is_local_label_name m88k_is_local_label_name

static boolean
m88k_is_local_label_name (abfd, name)
     bfd *abfd;
     const char *name;
{
  return name[0] == '@@';
}
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 97, 98, 1999
   Free Software Foundation, Inc.
a37 3
#define GET_SCNHDR_NRELOC bfd_h_get_32
#define GET_SCNHDR_NLNNO bfd_h_get_32

d44 1
a44 1
     bfd *abfd ATTRIBUTE_UNUSED;
d59 1
a59 1
     char **error_message ATTRIBUTE_UNUSED;
a116 5
      /* If we are not producing relocateable output, return an error if
	 the symbol is not defined.  */
      if (bfd_is_und_section (symbol->section) && output_bfd == (bfd *) NULL)
	return bfd_reloc_undefined;

d118 1
d283 41
a323 1
CREATE_BIG_COFF_TARGET_VEC (m88kbcs_vec, "coff-m88kbcs", 0, 0, '_', NULL)
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000
d54 1
a54 1
static bfd_reloc_status_type
d147 1
a147 1
static reloc_howto_type howto_table[] =
d253 1
d257 1
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000,
   2001, 2002
d30 1
a30 1
static bfd_boolean m88k_is_local_label_name PARAMS ((bfd *, const char *));
d39 2
a40 2
#define GET_SCNHDR_NRELOC H_GET_32
#define GET_SCNHDR_NLNNO  H_GET_32
d46 1
a46 1
static bfd_boolean
d118 1
a118 2
	    bfd_put_16 (abfd, (bfd_vma) relocation,
			(unsigned char *) data + addr);
d153 1
a153 1
	 TRUE,				/* pc_relative */
d158 1
a158 1
	 FALSE,				/* partial_inplace */
d161 1
a161 1
	 TRUE),				/* pcrel_offset */
d167 1
a167 1
	 TRUE,				/* pc_relative */
d172 1
a172 1
	 FALSE,				/* partial_inplace */
d175 1
a175 1
	 TRUE),				/* pcrel_offset */
d181 1
a181 1
	 FALSE,				/* pc_relative */
d186 1
a186 1
	 FALSE,				/* partial_inplace */
d189 1
a189 1
	 TRUE),				/* pcrel_offset */
d195 1
a195 1
	 FALSE,				/* pc_relative */
d200 1
a200 1
	 FALSE,				/* partial_inplace */
d203 1
a203 1
	 TRUE),				/* pcrel_offset */
d209 1
a209 1
	 FALSE,				/* pc_relative */
d214 1
a214 1
	 FALSE,				/* partial_inplace */
d217 1
a217 1
	 TRUE),				/* pcrel_offset */
d223 1
a223 1
	 FALSE,				/* pc_relative */
d228 1
a228 1
	 FALSE,				/* partial_inplace */
d231 1
a231 1
	 TRUE),				/* pcrel_offset */
d254 2
a255 2
#define SWAP_IN_RELOC_OFFSET  H_GET_16
#define SWAP_OUT_RELOC_OFFSET H_PUT_16
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d1 1
a1 1
/* BFD back-end for Motorola 88000 COFF "Binary Compatibility Standard" files.
d3 1
a3 1
   2001, 2002, 2003
d88 1
a88 1
	  /* Work out which section the relocation is targeted at and the
d123 1
a123 1
      /* If we are not producing relocatable output, return an error if
d291 1
a291 1
CREATE_BIG_COFF_TARGET_VEC (m88kbcs_vec, "coff-m88kbcs", 0, 0, '_', NULL, COFF_SWAP_TABLE)
@


