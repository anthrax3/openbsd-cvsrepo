head	1.7;
access;
symbols
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.52
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.04;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.20;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.29;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.08;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.18.59.42;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.43.44;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.32;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.32;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.05.04;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.37.11;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.18.11;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.45.28;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.21.09;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.11;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.15;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD back-end for PowerPC Microsoft Portable Executable files.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   Original version pieced together by Kim Knuttila (krk@@cygnus.com)

   There is nothing new under the sun. This file draws a lot on other
   coff files, in particular, those for the rs/6000, alpha, mips, and
   intel backends, and the PE work for the arm.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* Current State:
   - objdump works
   - relocs generated by gas
   - ld will link files, but they do not run.
   - dlltool will not produce correct output in some .reloc cases, and will
     not produce the right glue code for dll function calls.  */

#include "bfd.h"
#include "sysdep.h"

#include "libbfd.h"

#include "coff/powerpc.h"
#include "coff/internal.h"

#include "coff/pe.h"

#ifdef BADMAG
#undef BADMAG
#endif

#define BADMAG(x) PPCBADMAG(x)

#include "libcoff.h"

/* This file is compiled more than once, but we only compile the
   final_link routine once.  */
extern bfd_boolean ppc_bfd_coff_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
extern void dump_toc PARAMS ((PTR));

/* The toc is a set of bfd_vma fields. We use the fact that valid
   addresses are even (i.e. the bit representing "1" is off) to allow
   us to encode a little extra information in the field
   - Unallocated addresses are initialized to 1.
   - Allocated addresses are even numbers.
   The first time we actually write a reference to the toc in the bfd,
   we want to record that fact in a fixup file (if it is asked for), so
   we keep track of whether or not an address has been written by marking
   the low order bit with a "1" upon writing.  */

#define SET_UNALLOCATED(x)  ((x) = 1)
#define IS_UNALLOCATED(x)   ((x) == 1)

#define IS_WRITTEN(x)       ((x) & 1)
#define MARK_AS_WRITTEN(x)  ((x) |= 1)
#define MAKE_ADDR_AGAIN(x)  ((x) &= ~1)

/* Turn on this check if you suspect something amiss in the hash tables.  */
#ifdef DEBUG_HASH

/* Need a 7 char string for an eye catcher.  */
#define EYE "krkjunk"

#define HASH_CHECK_DCL char eye_catcher[8];
#define HASH_CHECK_INIT(ret)      strcpy(ret->eye_catcher, EYE)
#define HASH_CHECK(addr) \
 if (strcmp(addr->eye_catcher, EYE) != 0) \
  { \
    fprintf (stderr,\
    _("File %s, line %d, Hash check failure, bad eye %8s\n"), \
    __FILE__, __LINE__, addr->eye_catcher); \
    abort (); \
 }

#else

#define HASH_CHECK_DCL
#define HASH_CHECK_INIT(ret)
#define HASH_CHECK(addr)

#endif

/* In order not to add an int to every hash table item for every coff
   linker, we define our own hash table, derived from the coff one.  */

/* PE linker hash table entries.  */

struct ppc_coff_link_hash_entry
{
  struct coff_link_hash_entry root; /* First entry, as required.  */

  /* As we wonder around the relocs, we'll keep the assigned toc_offset
     here.  */
  bfd_vma toc_offset;               /* Our addition, as required.  */
  int symbol_is_glue;
  unsigned long int glue_insn;

  HASH_CHECK_DCL
};

/* PE linker hash table.  */

struct ppc_coff_link_hash_table
{
  struct coff_link_hash_table root; /* First entry, as required.  */
};

static struct bfd_hash_entry *ppc_coff_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
	   const char *));
static bfd_boolean ppc_coff_link_hash_table_init
  PARAMS ((struct ppc_coff_link_hash_table *, bfd *,
	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
				       struct bfd_hash_table *,
				       const char *)));
static struct bfd_link_hash_table *ppc_coff_link_hash_table_create
  PARAMS ((bfd *));
static bfd_boolean coff_ppc_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   struct internal_reloc *, struct internal_syment *, asection **));
static reloc_howto_type *coff_ppc_rtype_to_howto
  PARAMS ((bfd *, asection *, struct internal_reloc *,
	   struct coff_link_hash_entry *, struct internal_syment *,
	   bfd_vma *));

/* Routine to create an entry in the link hash table.  */

static struct bfd_hash_entry *
ppc_coff_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
{
  struct ppc_coff_link_hash_entry *ret =
    (struct ppc_coff_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct ppc_coff_link_hash_entry *) NULL)
    ret = (struct ppc_coff_link_hash_entry *)
      bfd_hash_allocate (table,
			 sizeof (struct ppc_coff_link_hash_entry));

  if (ret == (struct ppc_coff_link_hash_entry *) NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct ppc_coff_link_hash_entry *)
	 _bfd_coff_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				      table, string));

  if (ret)
    {
      /* Initialize the local fields.  */
      SET_UNALLOCATED (ret->toc_offset);
      ret->symbol_is_glue = 0;
      ret->glue_insn = 0;

      HASH_CHECK_INIT (ret);
    }

  return (struct bfd_hash_entry *) ret;
}

/* Initialize a PE linker hash table.  */

static bfd_boolean
ppc_coff_link_hash_table_init (table, abfd, newfunc)
     struct ppc_coff_link_hash_table *table;
     bfd *abfd;
     struct bfd_hash_entry *(*newfunc) PARAMS ((struct bfd_hash_entry *,
						struct bfd_hash_table *,
						const char *));
{
  return _bfd_coff_link_hash_table_init (&table->root, abfd, newfunc);
}

/* Create a PE linker hash table.  */

static struct bfd_link_hash_table *
ppc_coff_link_hash_table_create (abfd)
     bfd *abfd;
{
  struct ppc_coff_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct ppc_coff_link_hash_table);

  ret = (struct ppc_coff_link_hash_table *) bfd_malloc (amt);
  if (ret == NULL)
    return NULL;
  if (! ppc_coff_link_hash_table_init (ret, abfd,
					ppc_coff_link_hash_newfunc))
    {
      free (ret);
      return (struct bfd_link_hash_table *) NULL;
    }
  return &ret->root.root;
}

/* Now, tailor coffcode.h to use our hash stuff.  */

#define coff_bfd_link_hash_table_create ppc_coff_link_hash_table_create

/* The nt loader points the toc register to &toc + 32768, in order to
   use the complete range of a 16-bit displacement. We have to adjust
   for this when we fix up loads displaced off the toc reg.  */
#define TOC_LOAD_ADJUSTMENT (-32768)
#define TOC_SECTION_NAME ".private.toc"

/* The main body of code is in coffcode.h.  */

#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (3)

/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
   from smaller values.  Start with zero, widen, *then* decrement.  */
#define MINUS_ONE	(((bfd_vma)0) - 1)

/* These should definitely go in a header file somewhere...  */

/* NOP */
#define IMAGE_REL_PPC_ABSOLUTE          0x0000

/* 64-bit address */
#define IMAGE_REL_PPC_ADDR64            0x0001

/* 32-bit address */
#define IMAGE_REL_PPC_ADDR32            0x0002

/* 26-bit address, shifted left 2 (branch absolute) */
#define IMAGE_REL_PPC_ADDR24            0x0003

/* 16-bit address */
#define IMAGE_REL_PPC_ADDR16            0x0004

/* 16-bit address, shifted left 2 (load doubleword) */
#define IMAGE_REL_PPC_ADDR14            0x0005

/* 26-bit PC-relative offset, shifted left 2 (branch relative) */
#define IMAGE_REL_PPC_REL24             0x0006

/* 16-bit PC-relative offset, shifted left 2 (br cond relative) */
#define IMAGE_REL_PPC_REL14             0x0007

/* 16-bit offset from TOC base */
#define IMAGE_REL_PPC_TOCREL16          0x0008

/* 16-bit offset from TOC base, shifted left 2 (load doubleword) */
#define IMAGE_REL_PPC_TOCREL14          0x0009

/* 32-bit addr w/o image base */
#define IMAGE_REL_PPC_ADDR32NB          0x000A

/* va of containing section (as in an image sectionhdr) */
#define IMAGE_REL_PPC_SECREL            0x000B

/* sectionheader number */
#define IMAGE_REL_PPC_SECTION           0x000C

/* substitute TOC restore instruction iff symbol is glue code */
#define IMAGE_REL_PPC_IFGLUE            0x000D

/* symbol is glue code; virtual address is TOC restore instruction */
#define IMAGE_REL_PPC_IMGLUE            0x000E

/* va of containing section (limited to 16 bits) */
#define IMAGE_REL_PPC_SECREL16          0x000F

/* Stuff to handle immediate data when the number of bits in the
   data is greater than the number of bits in the immediate field
   We need to do (usually) 32 bit arithmetic on 16 bit chunks.  */
#define IMAGE_REL_PPC_REFHI             0x0010
#define IMAGE_REL_PPC_REFLO             0x0011
#define IMAGE_REL_PPC_PAIR              0x0012

/* This is essentially the same as tocrel16, with TOCDEFN assumed.  */
#define IMAGE_REL_PPC_TOCREL16_DEFN     0x0013

/* Flag bits in IMAGE_RELOCATION.TYPE.  */

/* Subtract reloc value rather than adding it.  */
#define IMAGE_REL_PPC_NEG               0x0100

/* Fix branch prediction bit to predict branch taken.  */
#define IMAGE_REL_PPC_BRTAKEN           0x0200

/* Fix branch prediction bit to predict branch not taken.  */
#define IMAGE_REL_PPC_BRNTAKEN          0x0400

/* TOC slot defined in file (or, data in toc).  */
#define IMAGE_REL_PPC_TOCDEFN           0x0800

/* Masks to isolate above values in IMAGE_RELOCATION.Type.  */
#define IMAGE_REL_PPC_TYPEMASK          0x00FF
#define IMAGE_REL_PPC_FLAGMASK          0x0F00

#define EXTRACT_TYPE(x)                 ((x) & IMAGE_REL_PPC_TYPEMASK)
#define EXTRACT_FLAGS(x) ((x) & IMAGE_REL_PPC_FLAGMASK)
#define EXTRACT_JUNK(x)  \
           ((x) & ~(IMAGE_REL_PPC_TYPEMASK | IMAGE_REL_PPC_FLAGMASK))

/* Static helper functions to make relocation work.  */
/* (Work In Progress) */

static bfd_reloc_status_type ppc_refhi_reloc PARAMS ((bfd *abfd,
						      arelent *reloc,
						      asymbol *symbol,
						      PTR data,
						      asection *section,
						      bfd *output_bfd,
						      char **error));
#if 0
static bfd_reloc_status_type ppc_reflo_reloc PARAMS ((bfd *abfd,
						      arelent *reloc,
						      asymbol *symbol,
						      PTR data,
						      asection *section,
						      bfd *output_bfd,
						      char **error));
#endif
static bfd_reloc_status_type ppc_pair_reloc PARAMS ((bfd *abfd,
						     arelent *reloc,
						     asymbol *symbol,
						     PTR data,
						     asection *section,
						     bfd *output_bfd,
						     char **error));

static bfd_reloc_status_type ppc_toc16_reloc PARAMS ((bfd *abfd,
						      arelent *reloc,
						      asymbol *symbol,
						      PTR data,
						      asection *section,
						      bfd *output_bfd,
						      char **error));

#if 0
static bfd_reloc_status_type ppc_addr32nb_reloc PARAMS ((bfd *abfd,
							 arelent *reloc,
							 asymbol *symbol,
							 PTR data,
							 asection *section,
							 bfd *output_bfd,
							 char **error));
#endif
static bfd_reloc_status_type ppc_section_reloc PARAMS ((bfd *abfd,
							arelent *reloc,
							asymbol *symbol,
							PTR data,
							asection *section,
							bfd *output_bfd,
							char **error));

static bfd_reloc_status_type ppc_secrel_reloc PARAMS ((bfd *abfd,
						       arelent *reloc,
						       asymbol *symbol,
						       PTR data,
						       asection *section,
						       bfd *output_bfd,
						       char **error));

static bfd_reloc_status_type ppc_imglue_reloc PARAMS ((bfd *abfd,
						       arelent *reloc,
						       asymbol *symbol,
						       PTR data,
						       asection *section,
						       bfd *output_bfd,
						       char **error));

static bfd_boolean in_reloc_p PARAMS((bfd *abfd, reloc_howto_type *howto));

/* FIXME: It'll take a while to get through all of these. I only need a few to
   get us started, so those I'll make sure work. Those marked FIXME are either
   completely unverified or have a specific unknown marked in the comment.  */

/* Relocation entries for Windows/NT on PowerPC.                             

   From the document "" we find the following listed as used relocs:

     ABSOLUTE       : The noop
     ADDR[64|32|16] : fields that hold addresses in data fields or the
                      16 bit displacement field on a load/store.
     ADDR[24|14]    : fields that hold addresses in branch and cond
                      branches. These represent [26|16] bit addresses.
                      The low order 2 bits are preserved.
     REL[24|14]     : branches relative to the Instruction Address
                      register. These represent [26|16] bit addresses,
                      as before. The instruction field will be zero, and
                      the address of the SYM will be inserted at link time.
     TOCREL16       : 16 bit displacement field referring to a slot in
                      toc.
     TOCREL14       : 16 bit displacement field, similar to REL14 or ADDR14.
     ADDR32NB       : 32 bit address relative to the virtual origin.
                      (On the alpha, this is always a linker generated thunk)
                      (i.e. 32bit addr relative to the image base)
     SECREL         : The value is relative to the start of the section
                      containing the symbol.
     SECTION        : access to the header containing the item. Supports the
                      codeview debugger.

   In particular, note that the document does not indicate that the
   relocations listed in the header file are used.  */


static reloc_howto_type ppc_coff_howto_table[] =
{
  /* IMAGE_REL_PPC_ABSOLUTE 0x0000   NOP */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_ABSOLUTE, /* type */
	 0,	                 /* rightshift */
	 0,	                 /* size (0 = byte, 1 = short, 2 = long) */
	 0,	                 /* bitsize */
	 FALSE,	                 /* pc_relative */
	 0,	                 /* bitpos */
	 complain_overflow_dont, /* dont complain_on_overflow */
	 0,		         /* special_function */
	 "ABSOLUTE",             /* name */
	 FALSE,	                 /* partial_inplace */
	 0x00,	 	         /* src_mask */
	 0x00,        		 /* dst_mask */
	 FALSE),                 /* pcrel_offset */

  /* IMAGE_REL_PPC_ADDR64 0x0001  64-bit address */
  /* Unused: */
  HOWTO(IMAGE_REL_PPC_ADDR64,    /* type */
	0,	                 /* rightshift */
	3,	                 /* size (0 = byte, 1 = short, 2 = long) */
	64,	                 /* bitsize */
	FALSE,	                 /* pc_relative */
	0,	                 /* bitpos */
	complain_overflow_bitfield, 	 /* complain_on_overflow */
	0,		         /* special_function */
	"ADDR64",               /* name */
	TRUE,	                 /* partial_inplace */
	MINUS_ONE,	 	 /* src_mask */
	MINUS_ONE,        	 /* dst_mask */
	FALSE),                 /* pcrel_offset */

  /* IMAGE_REL_PPC_ADDR32 0x0002  32-bit address */
  /* Used: */
  HOWTO (IMAGE_REL_PPC_ADDR32,	/* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "ADDR32",              /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_ADDR24 0x0003  26-bit address, shifted left 2 (branch absolute) */
  /* the LI field is in bit 6 through bit 29 is 24 bits, + 2 for the shift */
  /* Of course, That's the IBM approved bit numbering, which is not what */
  /* anyone else uses.... The li field is in bit 2 thru 25 */
  /* Used: */
  HOWTO (IMAGE_REL_PPC_ADDR24,  /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "ADDR24",              /* name */
	 TRUE,	                /* partial_inplace */
	 0x07fffffc,	        /* src_mask */
	 0x07fffffc,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_ADDR16 0x0004  16-bit address */
  /* Used: */
  HOWTO (IMAGE_REL_PPC_ADDR16,  /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "ADDR16",              /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_ADDR14 0x0005 */
  /*  16-bit address, shifted left 2 (load doubleword) */
  /* FIXME: the mask is likely wrong, and the bit position may be as well */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_ADDR14,  /* type */
	 1,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "ADDR16",              /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_REL24 0x0006 */
  /*   26-bit PC-relative offset, shifted left 2 (branch relative) */
  /* Used: */
  HOWTO (IMAGE_REL_PPC_REL24,   /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 TRUE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "REL24",               /* name */
	 TRUE,	                /* partial_inplace */
	 0x3fffffc,	        /* src_mask */
	 0x3fffffc,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_REL14 0x0007 */
  /*   16-bit PC-relative offset, shifted left 2 (br cond relative) */
  /* FIXME: the mask is likely wrong, and the bit position may be as well */
  /* FIXME: how does it know how far to shift? */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_ADDR14,  /* type */
	 1,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "ADDR16",              /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 TRUE),                 /* pcrel_offset */

  /* IMAGE_REL_PPC_TOCREL16 0x0008 */
  /*   16-bit offset from TOC base */
  /* Used: */
  HOWTO (IMAGE_REL_PPC_TOCREL16,/* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_toc16_reloc,       /* special_function */
	 "TOCREL16",            /* name */
	 FALSE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_TOCREL14 0x0009 */
  /*   16-bit offset from TOC base, shifted left 2 (load doubleword) */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_TOCREL14,/* type */
	 1,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "TOCREL14",            /* name */
	 FALSE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_ADDR32NB 0x000A */
  /*   32-bit addr w/ image base */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_ADDR32NB,/* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,                     /* special_function */
	 "ADDR32NB",            /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 FALSE),                 /* pcrel_offset */

  /* IMAGE_REL_PPC_SECREL 0x000B */
  /*   va of containing section (as in an image sectionhdr) */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_SECREL,/* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_secrel_reloc,      /* special_function */
	 "SECREL",              /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 TRUE),                 /* pcrel_offset */

  /* IMAGE_REL_PPC_SECTION 0x000C */
  /*   sectionheader number */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_SECTION,/* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_section_reloc,     /* special_function */
	 "SECTION",             /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 TRUE),                 /* pcrel_offset */

  /* IMAGE_REL_PPC_IFGLUE 0x000D */
  /*   substitute TOC restore instruction iff symbol is glue code */
  /* Used: */
  HOWTO (IMAGE_REL_PPC_IFGLUE,/* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "IFGLUE",              /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_IMGLUE 0x000E */
  /*   symbol is glue code; virtual address is TOC restore instruction */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_IMGLUE,/* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_imglue_reloc,      /* special_function */
	 "IMGLUE",              /* name */
	 FALSE,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 FALSE),                 /* pcrel_offset */

  /* IMAGE_REL_PPC_SECREL16 0x000F */
  /*   va of containing section (limited to 16 bits) */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_SECREL16,/* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "SECREL16",            /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 TRUE),                 /* pcrel_offset */

  /* IMAGE_REL_PPC_REFHI             0x0010 */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_REFHI,   /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_refhi_reloc,	/* special_function */
	 "REFHI",               /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 FALSE),                 /* pcrel_offset */

  /* IMAGE_REL_PPC_REFLO             0x0011 */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_REFLO,   /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_refhi_reloc,	/* special_function */
	 "REFLO",               /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_PAIR              0x0012 */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_PAIR,    /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_pair_reloc,        /* special_function */
	 "PAIR",                /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_TOCREL16_DEFN 0x0013 */
  /*   16-bit offset from TOC base, without causing a definition */
  /* Used: */
  HOWTO ( (IMAGE_REL_PPC_TOCREL16 | IMAGE_REL_PPC_TOCDEFN), /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,                     /* special_function */
	 "TOCREL16, TOCDEFN",   /* name */
	 FALSE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

};

/* Some really cheezy macros that can be turned on to test stderr :-)  */

#ifdef DEBUG_RELOC
#define UN_IMPL(x)                                           \
{                                                            \
   static int i;                                             \
   if (i == 0)                                               \
     {                                                       \
       i = 1;                                                \
       fprintf (stderr,_("Unimplemented Relocation -- %s\n"),x); \
     }                                                       \
}

#define DUMP_RELOC(n,r)                              \
{                                                    \
   fprintf (stderr,"%s sym %d, addr %d, addend %d\n", \
	   n, (*(r->sym_ptr_ptr))->name,             \
	   r->address, r->addend);                   \
}

/* Given a reloc name, n, and a pointer to an internal_reloc,
   dump out interesting information on the contents

#define n_name		_n._n_name
#define n_zeroes	_n._n_n._n_zeroes
#define n_offset	_n._n_n._n_offset  */

#define DUMP_RELOC2(n,r)                     		\
{                                            		\
   fprintf (stderr,"%s sym %d, r_vaddr %d %s\n", 	\
	   n, r->r_symndx, r->r_vaddr,			\
	   (((r->r_type) & IMAGE_REL_PPC_TOCDEFN) == 0) \
	   ?" ":" TOCDEFN"  );      			\
}

#else
#define UN_IMPL(x)
#define DUMP_RELOC(n,r)
#define DUMP_RELOC2(n,r)
#endif

/* TOC construction and management routines.  */

/* This file is compiled twice, and these variables are defined in one
   of the compilations.  FIXME: This is confusing and weird.  Also,
   BFD should not use global variables.  */
extern bfd *    bfd_of_toc_owner;
extern long int global_toc_size;
extern long int import_table_size;
extern long int first_thunk_address;
extern long int thunk_size;

enum toc_type
{
  default_toc,
  toc_32,
  toc_64
};

enum ref_category
{
  priv,
  pub,
  tocdata
};

struct list_ele
{
  struct list_ele *next;
  bfd_vma addr;
  enum ref_category cat;
  int offset;
  const char *name;
};

extern struct list_ele *head;
extern struct list_ele *tail;

static void record_toc
  PARAMS ((asection *, bfd_signed_vma, enum ref_category, const char *));

static void
record_toc (toc_section, our_toc_offset, cat, name)
     asection *toc_section;
     bfd_signed_vma our_toc_offset;
     enum ref_category cat;
     const char *name;
{
  /* Add this entry to our toc addr-offset-name list.  */
  bfd_size_type amt = sizeof (struct list_ele);
  struct list_ele *t = (struct list_ele *) bfd_malloc (amt);

  if (t == NULL)
    abort ();
  t->next = 0;
  t->offset = our_toc_offset;
  t->name = name;
  t->cat = cat;
  t->addr = toc_section->output_offset + our_toc_offset;

  if (head == 0)
    {
      head = t;
      tail = t;
    }
  else
    {
      tail->next = t;
      tail = t;
    }
}

#ifdef COFF_IMAGE_WITH_PE

static bfd_boolean ppc_record_toc_entry
  PARAMS ((bfd *, struct bfd_link_info *, asection *, int, enum toc_type));
static void ppc_mark_symbol_as_glue
  PARAMS ((bfd *, int, struct internal_reloc *));

/* Record a toc offset against a symbol.  */
static bfd_boolean
ppc_record_toc_entry(abfd, info, sec, sym, toc_kind)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     int sym;
     enum toc_type toc_kind ATTRIBUTE_UNUSED;
{
  struct ppc_coff_link_hash_entry *h;
  const char *name;

  int *local_syms;

  h = 0;

  h = (struct ppc_coff_link_hash_entry *) (obj_coff_sym_hashes (abfd)[sym]);
  if (h != 0)
    {
      HASH_CHECK(h);
    }

  if (h == 0)
    {
      local_syms = obj_coff_local_toc_table(abfd);

      if (local_syms == 0)
	{
	  unsigned int i;
	  bfd_size_type amt;

	  /* allocate a table */
	  amt = (bfd_size_type) obj_raw_syment_count (abfd) * sizeof (int);
	  local_syms = (int *) bfd_zalloc (abfd, amt);
	  if (local_syms == 0)
	    return FALSE;
	  obj_coff_local_toc_table (abfd) = local_syms;

	  for (i = 0; i < obj_raw_syment_count (abfd); ++i)
	    {
	      SET_UNALLOCATED (local_syms[i]);
	    }
	}

      if (IS_UNALLOCATED(local_syms[sym]))
	{
	  local_syms[sym] = global_toc_size;
	  global_toc_size += 4;

	  /* The size must fit in a 16-bit displacement.  */
	  if (global_toc_size > 65535)
	    {
	      (*_bfd_error_handler) (_("TOC overflow"));
	      bfd_set_error (bfd_error_file_too_big);
	      return FALSE;
	    }
	}
    }
  else
    {
      name = h->root.root.root.string;

      /* Check to see if there's a toc slot allocated. If not, do it
	 here. It will be used in relocate_section.  */
      if (IS_UNALLOCATED(h->toc_offset))
	{
	  h->toc_offset = global_toc_size;
	  global_toc_size += 4;

	  /* The size must fit in a 16-bit displacement.  */
	  if (global_toc_size >= 65535)
	    {
	      (*_bfd_error_handler) (_("TOC overflow"));
	      bfd_set_error (bfd_error_file_too_big);
	      return FALSE;
	    }
	}
    }

  return TRUE;
}

/* Record a toc offset against a symbol.  */
static void
ppc_mark_symbol_as_glue(abfd, sym, rel)
     bfd *abfd;
     int sym;
     struct internal_reloc *rel;
{
  struct ppc_coff_link_hash_entry *h;

  h = (struct ppc_coff_link_hash_entry *) (obj_coff_sym_hashes (abfd)[sym]);

  HASH_CHECK(h);

  h->symbol_is_glue = 1;
  h->glue_insn = bfd_get_32 (abfd, (bfd_byte *) &rel->r_vaddr);

  return;
}

#endif /* COFF_IMAGE_WITH_PE */

/* Return TRUE if this relocation should
   appear in the output .reloc section.  */

static bfd_boolean in_reloc_p(abfd, howto)
     bfd * abfd ATTRIBUTE_UNUSED;
     reloc_howto_type *howto;
{
  return
    (! howto->pc_relative)
      && (howto->type != IMAGE_REL_PPC_ADDR32NB)
      && (howto->type != IMAGE_REL_PPC_TOCREL16)
      && (howto->type != IMAGE_REL_PPC_IMGLUE)
      && (howto->type != IMAGE_REL_PPC_IFGLUE)
      && (howto->type != IMAGE_REL_PPC_SECREL)
      && (howto->type != IMAGE_REL_PPC_SECTION)
      && (howto->type != IMAGE_REL_PPC_SECREL16)
      && (howto->type != IMAGE_REL_PPC_REFHI)
      && (howto->type != IMAGE_REL_PPC_REFLO)
      && (howto->type != IMAGE_REL_PPC_PAIR)
      && (howto->type != IMAGE_REL_PPC_TOCREL16_DEFN) ;
}

#if 0

/* This function is in charge of performing all the ppc PE relocations
   Don't yet know if we want to do this this particular way ... (krk).  */
/* FIXME: (it is not yet enabled).  */

static bfd_reloc_status_type
pe_ppc_reloc (abfd, reloc_entry, symbol_in, data, input_section, output_bfd,
	      error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol_in;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  /* The consth relocation comes in two parts, we have to remember
     the state between calls, in these variables.  */
  static bfd_boolean part1_consth_active = FALSE;
  static unsigned long part1_consth_value;

  unsigned long sym_value;
  unsigned short r_type;
  unsigned long addr = reloc_entry->address ; /*+ input_section->vma*/

  r_type = reloc_entry->howto->type;

  if (output_bfd)
    {
      /* Partial linking - do nothing.  */
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (symbol_in != NULL
      && bfd_is_und_section (symbol_in->section))
    {
      /* Keep the state machine happy in case we're called again.  */
      if (r_type == IMAGE_REL_PPC_REFHI)
	{
	  part1_consth_active = TRUE;
	  part1_consth_value  = 0;
	}
      return(bfd_reloc_undefined);
    }

  if ((part1_consth_active) && (r_type != IMAGE_REL_PPC_PAIR))
    {
      part1_consth_active = FALSE;
      *error_message = (char *) _("Missing PAIR");
      return(bfd_reloc_dangerous);
    }

  sym_value = get_symbol_value(symbol_in);

  return(bfd_reloc_ok);
}

#endif /* 0 */

/* The reloc processing routine for the optimized COFF linker.  */

static bfd_boolean
coff_ppc_relocate_section (output_bfd, info, input_bfd, input_section,
			   contents, relocs, syms, sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     struct internal_reloc *relocs;
     struct internal_syment *syms;
     asection **sections;
{
  struct internal_reloc *rel;
  struct internal_reloc *relend;
  bfd_boolean hihalf;
  bfd_vma hihalf_val;
  asection *toc_section = 0;
  bfd_vma relocation;
  reloc_howto_type *howto = 0;

  /* If we are performing a relocatable link, we don't need to do a
     thing.  The caller will take care of adjusting the reloc
     addresses and symbol indices.  */
  if (info->relocatable)
    return TRUE;

  hihalf = FALSE;
  hihalf_val = 0;

  rel = relocs;
  relend = rel + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      long symndx;
      struct ppc_coff_link_hash_entry *h;
      struct internal_syment *sym;
      bfd_vma val;

      asection *sec;
      bfd_reloc_status_type rstat;
      bfd_byte *loc;

      unsigned short r_type  = EXTRACT_TYPE (rel->r_type);
      unsigned short r_flags = EXTRACT_FLAGS(rel->r_type);

      symndx = rel->r_symndx;
      loc = contents + rel->r_vaddr - input_section->vma;

      /* FIXME: check bounds on r_type */
      howto = ppc_coff_howto_table + r_type;

      if (symndx == -1)
	{
	  h = NULL;
	  sym = NULL;
	}
      else
	{
	  h = (struct ppc_coff_link_hash_entry *)
	    (obj_coff_sym_hashes (input_bfd)[symndx]);
	  if (h != 0)
	    {
	      HASH_CHECK(h);
	    }

	  sym = syms + symndx;
	}

      if (r_type == IMAGE_REL_PPC_IMGLUE && h == 0)
	{
	  /* An IMGLUE reloc must have a name. Something is very wrong.  */
	  abort ();
	}

      sec = NULL;
      val = 0;

      /* FIXME: PAIR unsupported in the following code.  */
      if (h == NULL)
	{
	  if (symndx == -1)
	    sec = bfd_abs_section_ptr;
	  else
	    {
	      sec = sections[symndx];
	      val = (sec->output_section->vma
		     + sec->output_offset
		     + sym->n_value);
	      if (! obj_pe (output_bfd))
		val -= sec->vma;
	    }
	}
      else
	{
	  HASH_CHECK(h);

	  if (h->root.root.type == bfd_link_hash_defined
	      || h->root.root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.root.u.def.section;
	      val = (h->root.root.u.def.value
		     + sec->output_section->vma
		     + sec->output_offset);
	    }
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.root.string, input_bfd, input_section,
		      rel->r_vaddr - input_section->vma, TRUE)))
		return FALSE;
	    }
	}

      rstat = bfd_reloc_ok;

      /* Each case must do its own relocation, setting rstat appropriately.  */
      switch (r_type)
	{
	default:
	  (*_bfd_error_handler)
	    (_("%s: unsupported relocation type 0x%02x"),
	     bfd_archive_filename (input_bfd), r_type);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	case IMAGE_REL_PPC_TOCREL16:
	  {
	    bfd_signed_vma our_toc_offset;
	    int fixit;

	    DUMP_RELOC2(howto->name, rel);

	    if (toc_section == 0)
	      {
		toc_section = bfd_get_section_by_name (bfd_of_toc_owner,
						       TOC_SECTION_NAME);

		if ( toc_section == NULL )
		  {
		    /* There is no toc section. Something is very wrong.  */
		    abort ();
		  }
	      }

	    /* Amazing bit tricks present. As we may have seen earlier, we
	       use the 1 bit to tell us whether or not a toc offset has been
	       allocated. Now that they've all been allocated, we will use
	       the 1 bit to tell us if we've written this particular toc
	       entry out.  */
	    fixit = FALSE;
	    if (h == 0)
	      {
		/* It is a file local symbol.  */
		int *local_toc_table;
		const char *name;

		sym = syms + symndx;
		name = sym->_n._n_name;

		local_toc_table = obj_coff_local_toc_table(input_bfd);
		our_toc_offset = local_toc_table[symndx];

		if (IS_WRITTEN(our_toc_offset))
		  {
		    /* If it has been written out, it is marked with the
		       1 bit. Fix up our offset, but do not write it out
		       again.  */
		    MAKE_ADDR_AGAIN(our_toc_offset);
		  }
		else
		  {
		    /* Write out the toc entry.  */
		    record_toc (toc_section, our_toc_offset, priv,
				strdup (name));

		    bfd_put_32 (output_bfd, val,
			       toc_section->contents + our_toc_offset);

		    MARK_AS_WRITTEN(local_toc_table[symndx]);
		    fixit = TRUE;
		  }
	      }
	    else
	      {
		const char *name = h->root.root.root.string;
		our_toc_offset = h->toc_offset;

		if ((r_flags & IMAGE_REL_PPC_TOCDEFN)
		    == IMAGE_REL_PPC_TOCDEFN )
		  {
		    /* This is unbelievable cheese. Some knowledgable asm
		       hacker has decided to use r2 as a base for loading
		       a value. He/She does this by setting the tocdefn bit,
		       and not supplying a toc definition. The behaviour is
		       then to use the difference between the value of the
		       symbol and the actual location of the toc as the toc
		       index.

		       In fact, what is usually happening is, because the
		       Import Address Table is mapped immediately following
		       the toc, some trippy library code trying for speed on
		       dll linkage, takes advantage of that and considers
		       the IAT to be part of the toc, thus saving a load.  */

		    our_toc_offset = val - (toc_section->output_section->vma
					    + toc_section->output_offset);

		    /* The size must still fit in a 16-bit displacement.  */
		    if ((bfd_vma) our_toc_offset >= 65535)
		      {
			(*_bfd_error_handler)
			  (_("%s: Relocation for %s of %lx exceeds Toc size limit"),
			   bfd_archive_filename (input_bfd), name,
			   (unsigned long) our_toc_offset);
			bfd_set_error (bfd_error_bad_value);
			return FALSE;
		      }

		    record_toc (toc_section, our_toc_offset, pub,
				strdup (name));
		  }
		else if (IS_WRITTEN (our_toc_offset))
		  {
		    /* If it has been written out, it is marked with the
		       1 bit. Fix up our offset, but do not write it out
		       again.  */
		    MAKE_ADDR_AGAIN(our_toc_offset);
		  }
		else
		  {
		    record_toc(toc_section, our_toc_offset, pub,
			       strdup (name));

		    /* Write out the toc entry.  */
		    bfd_put_32 (output_bfd, val,
			       toc_section->contents + our_toc_offset);

		    MARK_AS_WRITTEN(h->toc_offset);
		    /* The tricky part is that this is the address that
		       needs a .reloc entry for it.  */
		    fixit = TRUE;
		  }
	      }

	    if (fixit && info->base_file)
	      {
		/* So if this is non pcrelative, and is referenced
		   to a section or a common symbol, then it needs a reloc.  */

		/* Relocation to a symbol in a section which
		   isn't absolute - we output the address here
		   to a file.  */
		bfd_vma addr = (toc_section->output_section->vma
				+ toc_section->output_offset + our_toc_offset);

		if (coff_data (output_bfd)->pe)
		  addr -= pe_data(output_bfd)->pe_opthdr.ImageBase;

		fwrite (&addr, 1,4, (FILE *) info->base_file);
	      }

	    /* FIXME: this test is conservative.  */
	    if ((r_flags & IMAGE_REL_PPC_TOCDEFN) != IMAGE_REL_PPC_TOCDEFN
		&& (bfd_vma) our_toc_offset > toc_section->_raw_size)
	      {
		(*_bfd_error_handler)
		  (_("%s: Relocation exceeds allocated TOC (%lx)"),
		   bfd_archive_filename (input_bfd),
		   (unsigned long) toc_section->_raw_size);
		bfd_set_error (bfd_error_bad_value);
		return FALSE;
	      }

	    /* Now we know the relocation for this toc reference.  */
	    relocation =  our_toc_offset + TOC_LOAD_ADJUSTMENT;
	    rstat = _bfd_relocate_contents (howto, input_bfd, relocation, loc);
	  }
	  break;
	case IMAGE_REL_PPC_IFGLUE:
	  {
	    /* To solve this, we need to know whether or not the symbol
	       appearing on the call instruction is a glue function or not.
	       A glue function must announce itself via a IMGLUE reloc, and 
	       the reloc contains the required toc restore instruction.  */
	    bfd_vma x;
	    const char *my_name;
	    
	    DUMP_RELOC2 (howto->name, rel);

	    if (h != 0)
	      {
		my_name = h->root.root.root.string;
		if (h->symbol_is_glue == 1)
		  {
		    x = bfd_get_32 (input_bfd, loc);
		    bfd_put_32 (input_bfd, (bfd_vma) h->glue_insn, loc);
		  }
	      }
	  }
	  break;
	case IMAGE_REL_PPC_SECREL:
	  /* Unimplemented: codeview debugging information.  */
	  /* For fast access to the header of the section
	     containing the item.  */
	  break;
	case IMAGE_REL_PPC_SECTION:
	  /* Unimplemented: codeview debugging information.  */
	  /* Is used to indicate that the value should be relative
	     to the beginning of the section that contains the
	     symbol.  */
	  break;
	case IMAGE_REL_PPC_ABSOLUTE:
	  {
	    const char *my_name;

	    if (h == 0)
	      my_name = (syms+symndx)->_n._n_name;
	    else
	      my_name = h->root.root.root.string;

	    fprintf (stderr,
		    _("Warning: unsupported reloc %s <file %s, section %s>\n"),
		    howto->name,
		    bfd_archive_filename(input_bfd),
		    input_section->name);

	    fprintf (stderr,"sym %ld (%s), r_vaddr %ld (%lx)\n",
		    rel->r_symndx, my_name, (long) rel->r_vaddr,
		    (unsigned long) rel->r_vaddr);
	  }
	  break;
	case IMAGE_REL_PPC_IMGLUE:
	  {
	    /* There is nothing to do now. This reloc was noted in the first
	       pass over the relocs, and the glue instruction extracted.  */
	    const char *my_name;

	    if (h->symbol_is_glue == 1)
	      break;
	    my_name = h->root.root.root.string;

	    (*_bfd_error_handler)
	      (_("%s: Out of order IMGLUE reloc for %s"),
	       bfd_archive_filename (input_bfd), my_name);
	    bfd_set_error (bfd_error_bad_value);
	    return FALSE;
	  }

	case IMAGE_REL_PPC_ADDR32NB:
	  {
	    const char *name = 0;

	    DUMP_RELOC2 (howto->name, rel);

	    if (strncmp(".idata$2",input_section->name,8) == 0 && first_thunk_address == 0)
	      {
		/* Set magic values.  */
		int idata5offset;
		struct coff_link_hash_entry *myh;

		myh = coff_link_hash_lookup (coff_hash_table (info),
					     "__idata5_magic__",
					     FALSE, FALSE, TRUE);
		first_thunk_address = myh->root.u.def.value +
		  sec->output_section->vma +
		    sec->output_offset -
		      pe_data(output_bfd)->pe_opthdr.ImageBase;

		idata5offset = myh->root.u.def.value;
		myh = coff_link_hash_lookup (coff_hash_table (info),
					     "__idata6_magic__",
					     FALSE, FALSE, TRUE);

		thunk_size = myh->root.u.def.value - idata5offset;
		myh = coff_link_hash_lookup (coff_hash_table (info),
					     "__idata4_magic__",
					     FALSE, FALSE, TRUE);
		import_table_size = myh->root.u.def.value;
	      }

	    if (h == 0)
	      {
		/* It is a file local symbol.  */
		sym = syms + symndx;
		name = sym->_n._n_name;
	      }
	    else
	      {
		char *target = 0;

		name = h->root.root.root.string;
		if (strcmp (".idata$2", name) == 0)
		  target = "__idata2_magic__";
		else if (strcmp (".idata$4", name) == 0)
		  target = "__idata4_magic__";
		else if (strcmp (".idata$5", name) == 0)
		  target = "__idata5_magic__";

		if (target != 0)
		  {
		    struct coff_link_hash_entry *myh;

		    myh = coff_link_hash_lookup (coff_hash_table (info),
						 target,
						 FALSE, FALSE, TRUE);
		    if (myh == 0)
		      {
			/* Missing magic cookies. Something is very wrong.  */
			abort ();
		      }

		    val = myh->root.u.def.value +
		      sec->output_section->vma + sec->output_offset;
		    if (first_thunk_address == 0)
		      {
			int idata5offset;
			myh = coff_link_hash_lookup (coff_hash_table (info),
						     "__idata5_magic__",
						     FALSE, FALSE, TRUE);
			first_thunk_address = myh->root.u.def.value +
			  sec->output_section->vma +
			    sec->output_offset -
			      pe_data(output_bfd)->pe_opthdr.ImageBase;

			idata5offset = myh->root.u.def.value;
			myh = coff_link_hash_lookup (coff_hash_table (info),
						     "__idata6_magic__",
						     FALSE, FALSE, TRUE);

			thunk_size = myh->root.u.def.value - idata5offset;
			myh = coff_link_hash_lookup (coff_hash_table (info),
						     "__idata4_magic__",
						     FALSE, FALSE, TRUE);
			import_table_size = myh->root.u.def.value;
		      }
		  }
	      }

	    rstat = _bfd_relocate_contents (howto,
					    input_bfd,
					    val -
					    pe_data (output_bfd)->pe_opthdr.ImageBase,
					    loc);
	  }
	  break;

	case IMAGE_REL_PPC_REL24:
	  DUMP_RELOC2(howto->name, rel);
	  val -= (input_section->output_section->vma
		  + input_section->output_offset);

	  rstat = _bfd_relocate_contents (howto,
					  input_bfd,
					  val,
					  loc);
	  break;
	case IMAGE_REL_PPC_ADDR16:
	case IMAGE_REL_PPC_ADDR24:
	case IMAGE_REL_PPC_ADDR32:
	  DUMP_RELOC2(howto->name, rel);
	  rstat = _bfd_relocate_contents (howto,
					  input_bfd,
					  val,
					  loc);
	  break;
	}

      if (info->base_file)
	{
	  /* So if this is non pcrelative, and is referenced
	     to a section or a common symbol, then it needs a reloc.  */
	  if (sym && pe_data(output_bfd)->in_reloc_p (output_bfd, howto))
	    {
	      /* Relocation to a symbol in a section which
		 isn't absolute - we output the address here
		 to a file.  */
	      bfd_vma addr = rel->r_vaddr
		- input_section->vma
		+ input_section->output_offset
		  + input_section->output_section->vma;

	      if (coff_data (output_bfd)->pe)
		addr -= pe_data (output_bfd)->pe_opthdr.ImageBase;

	      fwrite (&addr, 1,4, (FILE *) info->base_file);
	    }
	}

      switch (rstat)
	{
	default:
	  abort ();
	case bfd_reloc_ok:
	  break;
	case bfd_reloc_overflow:
	  {
	    const char *name;
	    char buf[SYMNMLEN + 1];

	    if (symndx == -1)
	      name = "*ABS*";
	    else if (h != NULL)
	      name = h->root.root.root.string;
	    else if (sym == NULL)
	      name = "*unknown*";
	    else if (sym->_n._n_n._n_zeroes == 0
		     && sym->_n._n_n._n_offset != 0)
	      name = obj_coff_strings (input_bfd) + sym->_n._n_n._n_offset;
	    else
	      {
		strncpy (buf, sym->_n._n_name, SYMNMLEN);
		buf[SYMNMLEN] = '\0';
		name = buf;
	      }

	    if (! ((*info->callbacks->reloc_overflow)
		   (info, name, howto->name,
		    (bfd_vma) 0, input_bfd,
		    input_section, rel->r_vaddr - input_section->vma)))
	      return FALSE;
	  }
	}
    }

  return TRUE;
}

#ifdef COFF_IMAGE_WITH_PE

/* FIXME: BFD should not use global variables.  This file is compiled
   twice, and these variables are shared.  This is confusing and
   weird.  */

long int global_toc_size = 4;

bfd* bfd_of_toc_owner = 0;

long int import_table_size;
long int first_thunk_address;
long int thunk_size;

struct list_ele *head;
struct list_ele *tail;

static char *
h1 = N_("\n\t\t\tTOC MAPPING\n\n");
static char *
h2 = N_(" TOC    disassembly  Comments       Name\n");
static char *
h3 = N_(" Offset  spelling                   (if present)\n");

void
dump_toc (vfile)
     PTR vfile;
{
  FILE *file = (FILE *) vfile;
  struct list_ele *t;

  fprintf (file, _(h1));
  fprintf (file, _(h2));
  fprintf (file, _(h3));

  for (t = head; t != 0; t=t->next)
    {
      const char *cat = "";

      if (t->cat == priv)
	cat = _("private       ");
      else if (t->cat == pub)
	cat = _("public        ");
      else if (t->cat == tocdata)
	cat = _("data-in-toc   ");

      if (t->offset > global_toc_size)
	{
	  if (t->offset <= global_toc_size + thunk_size)
	    cat = _("IAT reference ");
	  else
	    {
	      fprintf (file,
		      _("**** global_toc_size %ld(%lx), thunk_size %ld(%lx)\n"),
		       global_toc_size, global_toc_size,
		       thunk_size, thunk_size);
	      cat = _("Out of bounds!");
	    }
	}

      fprintf (file,
	      " %04lx    (%d)", (unsigned long) t->offset, t->offset - 32768);
      fprintf (file,
	      "    %s %s\n",
	      cat, t->name);

    }

  fprintf (file, "\n");
}

bfd_boolean
ppc_allocate_toc_section (info)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
{
  asection *s;
  bfd_byte *foo;
  bfd_size_type amt;
  static char test_char = '1';

  if ( global_toc_size == 0 ) /* FIXME: does this get me in trouble?  */
    return TRUE;

  if (bfd_of_toc_owner == 0)
    /* No toc owner? Something is very wrong.  */
    abort ();

  s = bfd_get_section_by_name ( bfd_of_toc_owner , TOC_SECTION_NAME);
  if (s == NULL)
    /* No toc section? Something is very wrong.  */
    abort ();

  amt = global_toc_size;
  foo = (bfd_byte *) bfd_alloc (bfd_of_toc_owner, amt);
  memset(foo, test_char, (size_t) global_toc_size);

  s->_raw_size = s->_cooked_size = global_toc_size;
  s->contents = foo;

  return TRUE;
}

bfd_boolean
ppc_process_before_allocation (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  asection *sec;
  struct internal_reloc *i, *rel;

  /* Here we have a bfd that is to be included on the link. We have a hook
     to do reloc rummaging, before section sizes are nailed down.  */
  _bfd_coff_get_external_symbols (abfd);

  /* Rummage around all the relocs and map the toc.  */
  sec = abfd->sections;

  if (sec == 0)
    return TRUE;

  for (; sec != 0; sec = sec->next)
    {
      if (sec->reloc_count == 0)
	continue;

      /* load the relocs */
      /* FIXME: there may be a storage leak here */
      i=_bfd_coff_read_internal_relocs(abfd,sec,1,0,0,0);

      if (i == 0)
	abort ();

      for (rel = i; rel < i + sec->reloc_count; ++rel)
	{
	  unsigned short r_type  = EXTRACT_TYPE  (rel->r_type);
	  unsigned short r_flags = EXTRACT_FLAGS (rel->r_type);
	  bfd_boolean ok = TRUE;

	  DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, rel);

	  switch(r_type)
	    {
	    case IMAGE_REL_PPC_TOCREL16:
	      /* If TOCDEFN is on, ignore as someone else has allocated the
		 toc entry.  */
	      if ((r_flags & IMAGE_REL_PPC_TOCDEFN) != IMAGE_REL_PPC_TOCDEFN)
		ok = ppc_record_toc_entry(abfd, info, sec,
					  rel->r_symndx, default_toc);
	      if (!ok)
		return FALSE;
	      break;
	    case IMAGE_REL_PPC_IMGLUE:
	      ppc_mark_symbol_as_glue (abfd, rel->r_symndx, rel);
	      break;
	    default:
	      break;
	    }
	}
    }

  return TRUE;
}

#endif

static bfd_reloc_status_type
ppc_refhi_reloc (abfd, reloc_entry, symbol, data,
		 input_section, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  UN_IMPL("REFHI");
  DUMP_RELOC("REFHI",reloc_entry);

  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  return bfd_reloc_undefined;
}

#if 0

static bfd_reloc_status_type
ppc_reflo_reloc (abfd, reloc_entry, symbol, data,
		 input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  UN_IMPL("REFLO");
  DUMP_RELOC("REFLO",reloc_entry);

  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  return bfd_reloc_undefined;
}

#endif

static bfd_reloc_status_type
ppc_pair_reloc (abfd, reloc_entry, symbol, data,
		input_section, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  UN_IMPL("PAIR");
  DUMP_RELOC("PAIR",reloc_entry);

  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  return bfd_reloc_undefined;
}

static bfd_reloc_status_type
ppc_toc16_reloc (abfd, reloc_entry, symbol, data,
		 input_section, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  UN_IMPL ("TOCREL16");
  DUMP_RELOC ("TOCREL16",reloc_entry);

  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  return bfd_reloc_ok;
}

#if 0

/* ADDR32NB : 32 bit address relative to the virtual origin.
              (On the alpha, this is always a linker generated thunk)
              (i.e. 32bit addr relative to the image base).  */

static bfd_reloc_status_type
ppc_addr32nb_reloc (abfd, reloc_entry, symbol, data,
		    input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  UN_IMPL("ADDR32NB");
  DUMP_RELOC("ADDR32NB",reloc_entry);

  return bfd_reloc_ok;
}

#endif

static bfd_reloc_status_type
ppc_secrel_reloc (abfd, reloc_entry, symbol, data,
		  input_section, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  UN_IMPL("SECREL");
  DUMP_RELOC("SECREL",reloc_entry);

  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  return bfd_reloc_ok;
}

static bfd_reloc_status_type
ppc_section_reloc (abfd, reloc_entry, symbol, data,
		   input_section, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  UN_IMPL("SECTION");
  DUMP_RELOC("SECTION",reloc_entry);

  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  return bfd_reloc_ok;
}

static bfd_reloc_status_type
ppc_imglue_reloc (abfd, reloc_entry, symbol, data,
		  input_section, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  UN_IMPL("IMGLUE");
  DUMP_RELOC("IMGLUE",reloc_entry);

  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  return bfd_reloc_ok;
}

#define MAX_RELOC_INDEX  \
      (sizeof (ppc_coff_howto_table) / sizeof (ppc_coff_howto_table[0]) - 1)

/* FIXME: There is a possibility that when we read in a reloc from a file,
          that there are some bits encoded in the upper portion of the
	  type field. Not yet implemented.  */
static void ppc_coff_rtype2howto PARAMS ((arelent *, struct internal_reloc *));

static void
ppc_coff_rtype2howto (relent, internal)
     arelent *relent;
     struct internal_reloc *internal;
{
  /* We can encode one of three things in the type field, aside from the
     type:
     1. IMAGE_REL_PPC_NEG - indicates the value field is a subtraction
        value, rather than an addition value
     2. IMAGE_REL_PPC_BRTAKEN, IMAGE_REL_PPC_BRNTAKEN - indicates that
        the branch is expected to be taken or not.
     3. IMAGE_REL_PPC_TOCDEFN - toc slot definition in the file
     For now, we just strip this stuff to find the type, and ignore it other
     than that.  */
  reloc_howto_type *howto;
  unsigned short r_type  = EXTRACT_TYPE (internal->r_type);
  unsigned short r_flags = EXTRACT_FLAGS(internal->r_type);
  unsigned short junk    = EXTRACT_JUNK (internal->r_type);

  /* The masking process only slices off the bottom byte for r_type.  */
  if ( r_type > MAX_RELOC_INDEX )
    abort ();

  /* Check for absolute crap.  */
  if (junk != 0)
    abort ();

  switch(r_type)
    {
    case IMAGE_REL_PPC_ADDR16:
    case IMAGE_REL_PPC_REL24:
    case IMAGE_REL_PPC_ADDR24:
    case IMAGE_REL_PPC_ADDR32:
    case IMAGE_REL_PPC_IFGLUE:
    case IMAGE_REL_PPC_ADDR32NB:
    case IMAGE_REL_PPC_SECTION:
    case IMAGE_REL_PPC_SECREL:
      DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, internal);
      howto = ppc_coff_howto_table + r_type;
      break;
    case IMAGE_REL_PPC_IMGLUE:
      DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, internal);
      howto = ppc_coff_howto_table + r_type;
      break;
    case IMAGE_REL_PPC_TOCREL16:
      DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, internal);
      if (r_flags & IMAGE_REL_PPC_TOCDEFN)
	howto = ppc_coff_howto_table + IMAGE_REL_PPC_TOCREL16_DEFN;
      else
	howto = ppc_coff_howto_table + IMAGE_REL_PPC_TOCREL16;
      break;
    default:
      fprintf (stderr,
	      _("Warning: Unsupported reloc %s [%d] used -- it may not work.\n"),
	      ppc_coff_howto_table[r_type].name,
	      r_type);
      howto = ppc_coff_howto_table + r_type;
      break;
    }

  relent->howto = howto;
}

static reloc_howto_type *
coff_ppc_rtype_to_howto (abfd, sec, rel, h, sym, addendp)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     struct internal_reloc *rel;
     struct coff_link_hash_entry *h ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     bfd_vma *addendp;
{
  reloc_howto_type *howto;

  /* We can encode one of three things in the type field, aside from the
     type:
     1. IMAGE_REL_PPC_NEG - indicates the value field is a subtraction
        value, rather than an addition value
     2. IMAGE_REL_PPC_BRTAKEN, IMAGE_REL_PPC_BRNTAKEN - indicates that
        the branch is expected to be taken or not.
     3. IMAGE_REL_PPC_TOCDEFN - toc slot definition in the file
     For now, we just strip this stuff to find the type, and ignore it other
     than that.  */

  unsigned short r_type  = EXTRACT_TYPE  (rel->r_type);
  unsigned short r_flags = EXTRACT_FLAGS (rel->r_type);
  unsigned short junk    = EXTRACT_JUNK  (rel->r_type);

  /* The masking process only slices off the bottom byte for r_type.  */
  if (r_type > MAX_RELOC_INDEX)
    abort ();

  /* Check for absolute crap.  */
  if (junk != 0)
    abort ();

  switch(r_type)
    {
    case IMAGE_REL_PPC_ADDR32NB:
      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, rel);
      *addendp -= pe_data(sec->output_section->owner)->pe_opthdr.ImageBase;
      howto = ppc_coff_howto_table + r_type;
      break;
    case IMAGE_REL_PPC_TOCREL16:
      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, rel);
      if (r_flags & IMAGE_REL_PPC_TOCDEFN)
	howto = ppc_coff_howto_table + IMAGE_REL_PPC_TOCREL16_DEFN;
      else
	howto = ppc_coff_howto_table + IMAGE_REL_PPC_TOCREL16;
      break;
    case IMAGE_REL_PPC_ADDR16:
    case IMAGE_REL_PPC_REL24:
    case IMAGE_REL_PPC_ADDR24:
    case IMAGE_REL_PPC_ADDR32:
    case IMAGE_REL_PPC_IFGLUE:
    case IMAGE_REL_PPC_SECTION:
    case IMAGE_REL_PPC_SECREL:
      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, rel);
      howto = ppc_coff_howto_table + r_type;
      break;
    case IMAGE_REL_PPC_IMGLUE:
      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, rel);
      howto = ppc_coff_howto_table + r_type;
      break;
    default:
      fprintf (stderr,
	      _("Warning: Unsupported reloc %s [%d] used -- it may not work.\n"),
	      ppc_coff_howto_table[r_type].name,
	      r_type);
      howto = ppc_coff_howto_table + r_type;
      break;
    }

  return howto;
}

/* A cheesy little macro to make the code a little more readable.  */
#define HOW2MAP(bfd_rtype,ppc_rtype)  \
 case bfd_rtype: return &ppc_coff_howto_table[ppc_rtype]

static reloc_howto_type *ppc_coff_reloc_type_lookup
PARAMS ((bfd *, bfd_reloc_code_real_type));

static reloc_howto_type *
ppc_coff_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
{
  switch (code)
    {
      HOW2MAP(BFD_RELOC_32_GOTOFF,    IMAGE_REL_PPC_IMGLUE);
      HOW2MAP(BFD_RELOC_16_GOT_PCREL, IMAGE_REL_PPC_IFGLUE);
      HOW2MAP(BFD_RELOC_16,           IMAGE_REL_PPC_ADDR16);
      HOW2MAP(BFD_RELOC_PPC_B26,      IMAGE_REL_PPC_REL24);
      HOW2MAP(BFD_RELOC_PPC_BA26,     IMAGE_REL_PPC_ADDR24);
      HOW2MAP(BFD_RELOC_PPC_TOC16,    IMAGE_REL_PPC_TOCREL16);
      HOW2MAP(BFD_RELOC_16_GOTOFF,    IMAGE_REL_PPC_TOCREL16_DEFN);
      HOW2MAP(BFD_RELOC_32,           IMAGE_REL_PPC_ADDR32);
      HOW2MAP(BFD_RELOC_RVA,          IMAGE_REL_PPC_ADDR32NB);
    default:
      return NULL;
    }
}

#undef HOW2MAP

/* Tailor coffcode.h -- macro heaven.  */

#define RTYPE2HOWTO(cache_ptr, dst)  ppc_coff_rtype2howto (cache_ptr, dst)

/* We use the special COFF backend linker, with our own special touch.  */

#define coff_bfd_reloc_type_lookup   ppc_coff_reloc_type_lookup
#define coff_rtype_to_howto          coff_ppc_rtype_to_howto
#define coff_relocate_section        coff_ppc_relocate_section
#define coff_bfd_final_link          ppc_bfd_coff_final_link

#ifndef COFF_IMAGE_WITH_PE
/* FIXME: This no longer works.  */
#if 0
#define coff_swap_sym_in_hook        ppc_coff_swap_sym_in_hook
#endif
#endif

#define SELECT_RELOC(internal, howto) {internal.r_type=howto->type;}

#define COFF_PAGE_SIZE                       0x1000

/* FIXME: This controls some code that used to be in peicode.h and is
   now in peigen.c.  It will not control the code in peigen.c.  If
   anybody wants to get this working, you will need to fix that.  */
#define POWERPC_LE_PE

#define COFF_SECTION_ALIGNMENT_ENTRIES \
{ COFF_SECTION_NAME_EXACT_MATCH (".idata$2"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 0 }, \
{ COFF_SECTION_NAME_EXACT_MATCH (".idata$3"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 0 }, \
{ COFF_SECTION_NAME_EXACT_MATCH (".idata$4"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 2 }, \
{ COFF_SECTION_NAME_EXACT_MATCH (".idata$5"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 2 }, \
{ COFF_SECTION_NAME_EXACT_MATCH (".idata$6"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 1 }, \
{ COFF_SECTION_NAME_EXACT_MATCH (".reloc"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 1 }

#include "coffcode.h"

#ifndef COFF_IMAGE_WITH_PE
/* FIXME: This no longer works.  */
#if 0
/* FIXME:
   What we're trying to do here is allocate a toc section (early), and attach
   it to the last bfd to be processed. This avoids the problem of having a toc
   written out before all files have been processed. This code allocates
   a toc section for every file, and records the last one seen. There are
   at least two problems with this approach:
   1. We allocate whole bunches of toc sections that are ignored, but at
      at least we will not allocate a toc if no .toc is present.
   2. It's not clear to me that being the last bfd read necessarily means
      that you are the last bfd closed.
   3. Doing it on a "swap in" hook depends on when the "swap in" is called,
      and how often, etc. It's not clear to me that there isn't a hole here.  */
static void ppc_coff_swap_sym_in_hook PARAMS ((bfd *, PTR, PTR));

static void
ppc_coff_swap_sym_in_hook (abfd, ext1, in1)
     bfd            *abfd;
     PTR ext1 ATTRIBUTE_UNUSED;
     PTR in1;
{
  struct internal_syment * in = (struct internal_syment *)in1;

  if (bfd_of_toc_owner != 0) /* We already have a toc, so go home.  */
    return;

  if (strcmp (in->_n._n_name, ".toc") == 0)
    {
      flagword flags;
      register asection *s;

      s = bfd_get_section_by_name (abfd, TOC_SECTION_NAME);
      if (s != NULL)
	return;

      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY ;

      s = bfd_make_section (abfd, TOC_SECTION_NAME);

      if (s == NULL
	  || !bfd_set_section_flags (abfd, s, flags)
	  || !bfd_set_section_alignment (abfd, s, 2))
	/* FIXME: set appropriate bfd error.  */
	abort ();

      /* Save the bfd for later allocation.  */
      bfd_of_toc_owner = abfd;
    }

  return;
}
#endif
#endif

#ifndef COFF_IMAGE_WITH_PE

static bfd_boolean ppc_do_last PARAMS ((bfd *));
static bfd *ppc_get_last PARAMS ((void));

static bfd_boolean
ppc_do_last (abfd)
     bfd *abfd;
{
  if (abfd == bfd_of_toc_owner)
    return TRUE;
  else
    return FALSE;
}

static bfd *
ppc_get_last()
{
  return bfd_of_toc_owner;
}

/* This piece of machinery exists only to guarantee that the bfd that holds
   the toc section is written last.

   This does depend on bfd_make_section attaching a new section to the
   end of the section list for the bfd.

   This is otherwise intended to be functionally the same as
   cofflink.c:_bfd_coff_final_link(). It is specifically different only
   where the POWERPC_LE_PE macro modifies the code. It is left in as a
   precise form of comment. krk@@cygnus.com  */

/* Do the final link step.  */

bfd_boolean
ppc_bfd_coff_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  bfd_size_type symesz;
  struct coff_final_link_info finfo;
  bfd_boolean debug_merge_allocated;
  asection *o;
  struct bfd_link_order *p;
  bfd_size_type max_sym_count;
  bfd_size_type max_lineno_count;
  bfd_size_type max_reloc_count;
  bfd_size_type max_output_reloc_count;
  bfd_size_type max_contents_size;
  file_ptr rel_filepos;
  unsigned int relsz;
  file_ptr line_filepos;
  unsigned int linesz;
  bfd *sub;
  bfd_byte *external_relocs = NULL;
  char strbuf[STRING_SIZE_SIZE];
  bfd_size_type amt;

  symesz = bfd_coff_symesz (abfd);

  finfo.info = info;
  finfo.output_bfd = abfd;
  finfo.strtab = NULL;
  finfo.section_info = NULL;
  finfo.last_file_index = -1;
  finfo.last_bf_index = -1;
  finfo.internal_syms = NULL;
  finfo.sec_ptrs = NULL;
  finfo.sym_indices = NULL;
  finfo.outsyms = NULL;
  finfo.linenos = NULL;
  finfo.contents = NULL;
  finfo.external_relocs = NULL;
  finfo.internal_relocs = NULL;
  debug_merge_allocated = FALSE;

  coff_data (abfd)->link_info = info;

  finfo.strtab = _bfd_stringtab_init ();
  if (finfo.strtab == NULL)
    goto error_return;

  if (! coff_debug_merge_hash_table_init (&finfo.debug_merge))
    goto error_return;
  debug_merge_allocated = TRUE;

  /* Compute the file positions for all the sections.  */
  if (! abfd->output_has_begun)
    {
      if (! bfd_coff_compute_section_file_positions (abfd))
	return FALSE;
    }

  /* Count the line numbers and relocation entries required for the
     output file.  Set the file positions for the relocs.  */
  rel_filepos = obj_relocbase (abfd);
  relsz = bfd_coff_relsz (abfd);
  max_contents_size = 0;
  max_lineno_count = 0;
  max_reloc_count = 0;

  for (o = abfd->sections; o != NULL; o = o->next)
    {
      o->reloc_count = 0;
      o->lineno_count = 0;

      for (p = o->link_order_head; p != NULL; p = p->next)
	{
	  if (p->type == bfd_indirect_link_order)
	    {
	      asection *sec;

	      sec = p->u.indirect.section;

	      /* Mark all sections which are to be included in the
		 link.  This will normally be every section.  We need
		 to do this so that we can identify any sections which
		 the linker has decided to not include.  */
	      sec->linker_mark = TRUE;

	      if (info->strip == strip_none
		  || info->strip == strip_some)
		o->lineno_count += sec->lineno_count;

	      if (info->relocatable)
		o->reloc_count += sec->reloc_count;

	      if (sec->_raw_size > max_contents_size)
		max_contents_size = sec->_raw_size;
	      if (sec->lineno_count > max_lineno_count)
		max_lineno_count = sec->lineno_count;
	      if (sec->reloc_count > max_reloc_count)
		max_reloc_count = sec->reloc_count;
	    }
	  else if (info->relocatable
		   && (p->type == bfd_section_reloc_link_order
		       || p->type == bfd_symbol_reloc_link_order))
	    ++o->reloc_count;
	}
      if (o->reloc_count == 0)
	o->rel_filepos = 0;
      else
	{
	  o->flags |= SEC_RELOC;
	  o->rel_filepos = rel_filepos;
	  rel_filepos += o->reloc_count * relsz;
	}
    }

  /* If doing a relocatable link, allocate space for the pointers we
     need to keep.  */
  if (info->relocatable)
    {
      unsigned int i;

      /* We use section_count + 1, rather than section_count, because
         the target_index fields are 1 based.  */
      amt = abfd->section_count + 1;
      amt *= sizeof (struct coff_link_section_info);
      finfo.section_info = (struct coff_link_section_info *) bfd_malloc (amt);

      if (finfo.section_info == NULL)
	goto error_return;

      for (i = 0; i <= abfd->section_count; i++)
	{
	  finfo.section_info[i].relocs = NULL;
	  finfo.section_info[i].rel_hashes = NULL;
	}
    }

  /* We now know the size of the relocs, so we can determine the file
     positions of the line numbers.  */
  line_filepos = rel_filepos;
  linesz = bfd_coff_linesz (abfd);
  max_output_reloc_count = 0;

  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if (o->lineno_count == 0)
	o->line_filepos = 0;
      else
	{
	  o->line_filepos = line_filepos;
	  line_filepos += o->lineno_count * linesz;
	}

      if (o->reloc_count != 0)
	{
	  /* We don't know the indices of global symbols until we have
             written out all the local symbols.  For each section in
             the output file, we keep an array of pointers to hash
             table entries.  Each entry in the array corresponds to a
             reloc.  When we find a reloc against a global symbol, we
             set the corresponding entry in this array so that we can
             fix up the symbol index after we have written out all the
             local symbols.

	     Because of this problem, we also keep the relocs in
	     memory until the end of the link.  This wastes memory,
	     but only when doing a relocatable link, which is not the
	     common case.  */
	  BFD_ASSERT (info->relocatable);
	  amt = o->reloc_count;
	  amt *= sizeof (struct internal_reloc);
	  finfo.section_info[o->target_index].relocs =
	    (struct internal_reloc *) bfd_malloc (amt);
	  amt = o->reloc_count;
	  amt *= sizeof (struct coff_link_hash_entry *);
	  finfo.section_info[o->target_index].rel_hashes =
	    (struct coff_link_hash_entry **) bfd_malloc (amt);
	  if (finfo.section_info[o->target_index].relocs == NULL
	      || finfo.section_info[o->target_index].rel_hashes == NULL)
	    goto error_return;

	  if (o->reloc_count > max_output_reloc_count)
	    max_output_reloc_count = o->reloc_count;
	}

      /* Reset the reloc and lineno counts, so that we can use them to
	 count the number of entries we have output so far.  */
      o->reloc_count = 0;
      o->lineno_count = 0;
    }

  obj_sym_filepos (abfd) = line_filepos;

  /* Figure out the largest number of symbols in an input BFD.  Take
     the opportunity to clear the output_has_begun fields of all the
     input BFD's.  */
  max_sym_count = 0;
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      bfd_size_type sz;

      sub->output_has_begun = FALSE;
      sz = obj_raw_syment_count (sub);
      if (sz > max_sym_count)
	max_sym_count = sz;
    }

  /* Allocate some buffers used while linking.  */
  amt = max_sym_count * sizeof (struct internal_syment);
  finfo.internal_syms = (struct internal_syment *) bfd_malloc (amt);
  amt = max_sym_count * sizeof (asection *);
  finfo.sec_ptrs = (asection **) bfd_malloc (amt);
  amt = max_sym_count * sizeof (long);
  finfo.sym_indices = (long *) bfd_malloc (amt);
  amt = (max_sym_count + 1) * symesz;
  finfo.outsyms = (bfd_byte *) bfd_malloc (amt);
  amt = max_lineno_count * bfd_coff_linesz (abfd);
  finfo.linenos = (bfd_byte *) bfd_malloc (amt);
  finfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
  finfo.external_relocs = (bfd_byte *) bfd_malloc (max_reloc_count * relsz);
  if (! info->relocatable)
    {
      amt = max_reloc_count * sizeof (struct internal_reloc);
      finfo.internal_relocs = (struct internal_reloc *) bfd_malloc (amt);
    }
  if ((finfo.internal_syms == NULL && max_sym_count > 0)
      || (finfo.sec_ptrs == NULL && max_sym_count > 0)
      || (finfo.sym_indices == NULL && max_sym_count > 0)
      || finfo.outsyms == NULL
      || (finfo.linenos == NULL && max_lineno_count > 0)
      || (finfo.contents == NULL && max_contents_size > 0)
      || (finfo.external_relocs == NULL && max_reloc_count > 0)
      || (! info->relocatable
	  && finfo.internal_relocs == NULL
	  && max_reloc_count > 0))
    goto error_return;

  /* We now know the position of everything in the file, except that
     we don't know the size of the symbol table and therefore we don't
     know where the string table starts.  We just build the string
     table in memory as we go along.  We process all the relocations
     for a single input file at once.  */
  obj_raw_syment_count (abfd) = 0;

  if (coff_backend_info (abfd)->_bfd_coff_start_final_link)
    {
      if (! bfd_coff_start_final_link (abfd, info))
	goto error_return;
    }

  for (o = abfd->sections; o != NULL; o = o->next)
    {
      for (p = o->link_order_head; p != NULL; p = p->next)
	{
	  if (p->type == bfd_indirect_link_order
	      && (bfd_get_flavour (p->u.indirect.section->owner)
		  == bfd_target_coff_flavour))
	    {
	      sub = p->u.indirect.section->owner;
#ifdef POWERPC_LE_PE
	      if (! sub->output_has_begun && !ppc_do_last(sub))
#else
	      if (! sub->output_has_begun)
#endif
		{
		  if (! _bfd_coff_link_input_bfd (&finfo, sub))
		    goto error_return;
		  sub->output_has_begun = TRUE;
		}
	    }
	  else if (p->type == bfd_section_reloc_link_order
		   || p->type == bfd_symbol_reloc_link_order)
	    {
	      if (! _bfd_coff_reloc_link_order (abfd, &finfo, o, p))
		goto error_return;
	    }
	  else
	    {
	      if (! _bfd_default_link_order (abfd, info, o, p))
		goto error_return;
	    }
	}
    }

#ifdef POWERPC_LE_PE
  {
    bfd* last_one = ppc_get_last();
    if (last_one)
      {
	if (! _bfd_coff_link_input_bfd (&finfo, last_one))
	  goto error_return;
      }
    last_one->output_has_begun = TRUE;
  }
#endif

  /* Free up the buffers used by _bfd_coff_link_input_bfd.  */
  coff_debug_merge_hash_table_free (&finfo.debug_merge);
  debug_merge_allocated = FALSE;

  if (finfo.internal_syms != NULL)
    {
      free (finfo.internal_syms);
      finfo.internal_syms = NULL;
    }
  if (finfo.sec_ptrs != NULL)
    {
      free (finfo.sec_ptrs);
      finfo.sec_ptrs = NULL;
    }
  if (finfo.sym_indices != NULL)
    {
      free (finfo.sym_indices);
      finfo.sym_indices = NULL;
    }
  if (finfo.linenos != NULL)
    {
      free (finfo.linenos);
      finfo.linenos = NULL;
    }
  if (finfo.contents != NULL)
    {
      free (finfo.contents);
      finfo.contents = NULL;
    }
  if (finfo.external_relocs != NULL)
    {
      free (finfo.external_relocs);
      finfo.external_relocs = NULL;
    }
  if (finfo.internal_relocs != NULL)
    {
      free (finfo.internal_relocs);
      finfo.internal_relocs = NULL;
    }

  /* The value of the last C_FILE symbol is supposed to be the symbol
     index of the first external symbol.  Write it out again if
     necessary.  */
  if (finfo.last_file_index != -1
      && (unsigned int) finfo.last_file.n_value != obj_raw_syment_count (abfd))
    {
      file_ptr pos;

      finfo.last_file.n_value = obj_raw_syment_count (abfd);
      bfd_coff_swap_sym_out (abfd, (PTR) &finfo.last_file,
			     (PTR) finfo.outsyms);
      pos = obj_sym_filepos (abfd) + finfo.last_file_index * symesz;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (finfo.outsyms, symesz, abfd) != symesz)
	return FALSE;
    }

  /* Write out the global symbols.  */
  finfo.failed = FALSE;
  coff_link_hash_traverse (coff_hash_table (info), _bfd_coff_write_global_sym,
			   (PTR) &finfo);
  if (finfo.failed)
    goto error_return;

  /* The outsyms buffer is used by _bfd_coff_write_global_sym.  */
  if (finfo.outsyms != NULL)
    {
      free (finfo.outsyms);
      finfo.outsyms = NULL;
    }

  if (info->relocatable)
    {
      /* Now that we have written out all the global symbols, we know
	 the symbol indices to use for relocs against them, and we can
	 finally write out the relocs.  */
      amt = max_output_reloc_count * relsz;
      external_relocs = (bfd_byte *) bfd_malloc (amt);
      if (external_relocs == NULL)
	goto error_return;

      for (o = abfd->sections; o != NULL; o = o->next)
	{
	  struct internal_reloc *irel;
	  struct internal_reloc *irelend;
	  struct coff_link_hash_entry **rel_hash;
	  bfd_byte *erel;

	  if (o->reloc_count == 0)
	    continue;

	  irel = finfo.section_info[o->target_index].relocs;
	  irelend = irel + o->reloc_count;
	  rel_hash = finfo.section_info[o->target_index].rel_hashes;
	  erel = external_relocs;
	  for (; irel < irelend; irel++, rel_hash++, erel += relsz)
	    {
	      if (*rel_hash != NULL)
		{
		  BFD_ASSERT ((*rel_hash)->indx >= 0);
		  irel->r_symndx = (*rel_hash)->indx;
		}
	      bfd_coff_swap_reloc_out (abfd, (PTR) irel, (PTR) erel);
	    }

	  amt = relsz * o->reloc_count;
	  if (bfd_seek (abfd, o->rel_filepos, SEEK_SET) != 0
	      || bfd_bwrite ((PTR) external_relocs, amt, abfd) != amt)
	    goto error_return;
	}

      free (external_relocs);
      external_relocs = NULL;
    }

  /* Free up the section information.  */
  if (finfo.section_info != NULL)
    {
      unsigned int i;

      for (i = 0; i < abfd->section_count; i++)
	{
	  if (finfo.section_info[i].relocs != NULL)
	    free (finfo.section_info[i].relocs);
	  if (finfo.section_info[i].rel_hashes != NULL)
	    free (finfo.section_info[i].rel_hashes);
	}
      free (finfo.section_info);
      finfo.section_info = NULL;
    }

  /* If we have optimized stabs strings, output them.  */
  if (coff_hash_table (info)->stab_info != NULL)
    {
      if (! _bfd_write_stab_strings (abfd, &coff_hash_table (info)->stab_info))
	return FALSE;
    }

  /* Write out the string table.  */
  if (obj_raw_syment_count (abfd) != 0)
    {
      file_ptr pos;

      pos = obj_sym_filepos (abfd) + obj_raw_syment_count (abfd) * symesz;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0)
	return FALSE;

#if STRING_SIZE_SIZE == 4
      H_PUT_32 (abfd,
		_bfd_stringtab_size (finfo.strtab) + STRING_SIZE_SIZE,
		strbuf);
#else
 #error Change H_PUT_32 above
#endif

      if (bfd_bwrite (strbuf, (bfd_size_type) STRING_SIZE_SIZE, abfd)
	  != STRING_SIZE_SIZE)
	return FALSE;

      if (! _bfd_stringtab_emit (abfd, finfo.strtab))
	return FALSE;
    }

  _bfd_stringtab_free (finfo.strtab);

  /* Setting bfd_get_symcount to 0 will cause write_object_contents to
     not try to write out the symbols.  */
  bfd_get_symcount (abfd) = 0;

  return TRUE;

 error_return:
  if (debug_merge_allocated)
    coff_debug_merge_hash_table_free (&finfo.debug_merge);
  if (finfo.strtab != NULL)
    _bfd_stringtab_free (finfo.strtab);
  if (finfo.section_info != NULL)
    {
      unsigned int i;

      for (i = 0; i < abfd->section_count; i++)
	{
	  if (finfo.section_info[i].relocs != NULL)
	    free (finfo.section_info[i].relocs);
	  if (finfo.section_info[i].rel_hashes != NULL)
	    free (finfo.section_info[i].rel_hashes);
	}
      free (finfo.section_info);
    }
  if (finfo.internal_syms != NULL)
    free (finfo.internal_syms);
  if (finfo.sec_ptrs != NULL)
    free (finfo.sec_ptrs);
  if (finfo.sym_indices != NULL)
    free (finfo.sym_indices);
  if (finfo.outsyms != NULL)
    free (finfo.outsyms);
  if (finfo.linenos != NULL)
    free (finfo.linenos);
  if (finfo.contents != NULL)
    free (finfo.contents);
  if (finfo.external_relocs != NULL)
    free (finfo.external_relocs);
  if (finfo.internal_relocs != NULL)
    free (finfo.internal_relocs);
  if (external_relocs != NULL)
    free (external_relocs);
  return FALSE;
}
#endif

/* Forward declaration for use by alternative_target field.  */
#ifdef TARGET_BIG_SYM
extern const bfd_target TARGET_BIG_SYM;
#endif

/* The transfer vectors that lead the outside world to all of the above.  */

#ifdef TARGET_LITTLE_SYM
const bfd_target TARGET_LITTLE_SYM =
{
  TARGET_LITTLE_NAME,		/* name or coff-arm-little */
  bfd_target_coff_flavour,
  BFD_ENDIAN_LITTLE,		/* data byte order is little */
  BFD_ENDIAN_LITTLE,		/* header byte order is little */

  (HAS_RELOC | EXEC_P |		/* FIXME: object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),

#ifndef COFF_WITH_PE
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
#else
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC /* section flags */
   | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),
#endif

  0,				/* leading char */
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen??? FIXMEmgo */

  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,
  bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */

  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,
  bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */

  {_bfd_dummy_target, coff_object_p, 	/* bfd_check_format */
     bfd_generic_archive_p, /* _bfd_dummy_target */ coff_object_p },
  {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format */
     bfd_false},
  {bfd_false, coff_write_object_contents,	/* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

  BFD_JUMP_TABLE_GENERIC (coff),
  BFD_JUMP_TABLE_COPY (coff),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
  BFD_JUMP_TABLE_SYMBOLS (coff),
  BFD_JUMP_TABLE_RELOCS (coff),
  BFD_JUMP_TABLE_WRITE (coff),
  BFD_JUMP_TABLE_LINK (coff),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  /* Alternative_target.  */
#ifdef TARGET_BIG_SYM
  & TARGET_BIG_SYM,
#else
  NULL,
#endif

  COFF_SWAP_TABLE
};
#endif

#ifdef TARGET_BIG_SYM
const bfd_target TARGET_BIG_SYM =
{
  TARGET_BIG_NAME,
  bfd_target_coff_flavour,
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */

  (HAS_RELOC | EXEC_P |		/* FIXME: object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),

#ifndef COFF_WITH_PE
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
#else
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC /* section flags */
   | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),
#endif

  0,				/* leading char */
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen??? FIXMEmgo */

  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */

  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */

  {_bfd_dummy_target, coff_object_p, 	/* bfd_check_format */
     bfd_generic_archive_p, /* _bfd_dummy_target */ coff_object_p },
  {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format */
     bfd_false},
  {bfd_false, coff_write_object_contents,	/* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

  BFD_JUMP_TABLE_GENERIC (coff),
  BFD_JUMP_TABLE_COPY (coff),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
  BFD_JUMP_TABLE_SYMBOLS (coff),
  BFD_JUMP_TABLE_RELOCS (coff),
  BFD_JUMP_TABLE_WRITE (coff),
  BFD_JUMP_TABLE_LINK (coff),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  /* Alternative_target.  */
#ifdef TARGET_LITTLE_SYM
  & TARGET_LITTLE_SYM,
#else
  NULL,
#endif

  COFF_SWAP_TABLE
};

#endif
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d932 1
a932 1
	  /* The size must fit in a 16bit displacment.  */
d952 1
a952 1
	  /* The size must fit in a 16bit displacment.  */
d1091 1
a1091 1
  /* If we are performing a relocateable link, we don't need to do a
d1094 1
a1094 1
  if (info->relocateable)
d1277 1
a1277 1
		    /* The size must still fit in a 16bit displacment.  */
d1934 1
a1934 1
/* FIXME: There is a possiblity that when we read in a reloc from a file,
d2328 1
a2328 1
	      if (info->relocateable)
d2338 1
a2338 1
	  else if (info->relocateable
d2353 1
a2353 1
  /* If doing a relocateable link, allocate space for the pointers we
d2355 1
a2355 1
  if (info->relocateable)
d2404 1
a2404 1
	     but only when doing a relocateable link, which is not the
d2406 1
a2406 1
	  BFD_ASSERT (info->relocateable);
d2458 1
a2458 1
  if (! info->relocateable)
d2470 1
a2470 1
      || (! info->relocateable
d2605 1
a2605 1
  if (info->relocateable)
@


1.5
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2000, 2001
d12 1
a12 1
This file is part of BFD, the Binary File Descriptor library.
d14 14
a27 14
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */
d34 1
a34 2
     not produce the right glue code for dll function calls.
*/
d56 1
a56 1
extern boolean ppc_bfd_coff_final_link
d60 9
a68 9
/* The toc is a set of bfd_vma fields. We use the fact that valid         */
/* addresses are even (i.e. the bit representing "1" is off) to allow     */
/* us to encode a little extra information in the field                   */
/* - Unallocated addresses are intialized to 1.                           */
/* - Allocated addresses are even numbers.                                */
/* The first time we actually write a reference to the toc in the bfd,    */
/* we want to record that fact in a fixup file (if it is asked for), so   */
/* we keep track of whether or not an address has been written by marking */
/* the low order bit with a "1" upon writing                              */
d77 1
a77 1
/* Turn on this check if you suspect something amiss in the hash tables */
d80 1
a80 1
/* Need a 7 char string for an eye catcher */
d103 1
a103 1
   linker, we define our own hash table, derived from the coff one */
d109 1
a109 1
  struct coff_link_hash_entry root; /* First entry, as required  */
d112 2
a113 2
     here */
  bfd_vma toc_offset;               /* Our addition, as required */
d124 1
a124 1
  struct coff_link_hash_table root; /* First entry, as required */
d130 1
a130 1
static boolean ppc_coff_link_hash_table_init
d137 1
a137 1
static boolean coff_ppc_relocate_section
d174 1
a174 1
      SET_UNALLOCATED(ret->toc_offset);
d178 1
a178 1
      HASH_CHECK_INIT(ret);
d186 1
a186 1
static boolean
d204 1
d206 1
a206 2
  ret = ((struct ppc_coff_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct ppc_coff_link_hash_table)));
d212 1
a212 1
      bfd_release (abfd, ret);
d218 1
a218 1
/* Now, tailor coffcode.h to use our hash stuff */
d222 3
a224 3
/* The nt loader points the toc register to &toc + 32768, in order to */
/* use the complete range of a 16-bit displacement. We have to adjust */
/* for this when we fix up loads displaced off the toc reg.           */
d236 1
a236 1
/* these should definitely go in a header file somewhere...  */
d286 3
a288 3
/* stuff to handle immediate data when the number of bits in the */
/* data is greater than the number of bits in the immediate field */
/* We need to do (usually) 32 bit arithmetic on 16 bit chunks */
d293 1
a293 1
/* This is essentially the same as tocrel16, with TOCDEFN assumed */
d296 1
a296 1
/*  Flag bits in IMAGE_RELOCATION.TYPE */
d298 1
a298 1
/* subtract reloc value rather than adding it */
d301 1
a301 1
/* fix branch prediction bit to predict branch taken */
d304 1
a304 1
/* fix branch prediction bit to predict branch not taken */
d307 1
a307 1
/* toc slot defined in file (or, data in toc) */
d310 1
a310 1
/* masks to isolate above values in IMAGE_RELOCATION.Type */
d319 1
a319 1
/* static helper functions to make relocation work */
d387 1
a387 1
static boolean in_reloc_p PARAMS((bfd *abfd, reloc_howto_type *howto));
d391 29
a419 1
   completely unverified or have a specific unknown marked in the comment */
a420 33
/*---------------------------------------------------------------------------*/
/*                                                                           */
/* Relocation entries for Windows/NT on PowerPC.                             */
/*                                                                           */
/* From the document "" we find the following listed as used relocs:         */
/*                                                                           */
/*   ABSOLUTE       : The noop                                               */
/*   ADDR[64|32|16] : fields that hold addresses in data fields or the       */
/*                    16 bit displacement field on a load/store.             */
/*   ADDR[24|14]    : fields that hold addresses in branch and cond          */
/*                    branches. These represent [26|16] bit addresses.       */
/*                    The low order 2 bits are preserved.                    */
/*   REL[24|14]     : branches relative to the Instruction Address           */
/*                    register. These represent [26|16] bit addresses,       */
/*                    as before. The instruction field will be zero, and     */
/*                    the address of the SYM will be inserted at link time.  */
/*   TOCREL16       : 16 bit displacement field referring to a slot in       */
/*                    toc.                                                   */
/*   TOCREL14       : 16 bit displacement field, similar to REL14 or ADDR14.  */
/*   ADDR32NB       : 32 bit address relative to the virtual origin.         */
/*                    (On the alpha, this is always a linker generated thunk)*/
/*                    (i.e. 32bit addr relative to the image base)           */
/*   SECREL         : The value is relative to the start of the section      */
/*                    containing the symbol.                                 */
/*   SECTION        : access to the header containing the item. Supports the */
/*                    codeview debugger.                                     */
/*                                                                           */
/* In particular, note that the document does not indicate that the          */
/* relocations listed in the header file are used.                           */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
d430 1
a430 1
	 false,	                 /* pc_relative */
d435 1
a435 1
	 false,	                 /* partial_inplace */
d438 1
a438 1
	 false),                 /* pcrel_offset */
d446 1
a446 1
	false,	                 /* pc_relative */
d451 1
a451 1
	true,	                 /* partial_inplace */
d454 1
a454 1
	false),                 /* pcrel_offset */
d462 1
a462 1
	 false,	                /* pc_relative */
d467 1
a467 1
	 true,	                /* partial_inplace */
d470 1
a470 1
	 false),                /* pcrel_offset */
d481 1
a481 1
	 false,	                /* pc_relative */
d486 1
a486 1
	 true,	                /* partial_inplace */
d489 1
a489 1
	 false),                /* pcrel_offset */
d497 1
a497 1
	 false,	                /* pc_relative */
d502 1
a502 1
	 true,	                /* partial_inplace */
d505 1
a505 1
	 false),                /* pcrel_offset */
d515 1
a515 1
	 false,	                /* pc_relative */
d520 1
a520 1
	 true,	                /* partial_inplace */
d523 1
a523 1
	 false),                /* pcrel_offset */
d532 1
a532 1
	 true,	                /* pc_relative */
d537 1
a537 1
	 true,	                /* partial_inplace */
d540 1
a540 1
	 false),                /* pcrel_offset */
d551 1
a551 1
	 false,	                /* pc_relative */
d556 1
a556 1
	 true,	                /* partial_inplace */
d559 1
a559 1
	 true),                 /* pcrel_offset */
d568 1
a568 1
	 false,	                /* pc_relative */
d573 1
a573 1
	 false,	                /* partial_inplace */
d576 1
a576 1
	 false),                /* pcrel_offset */
d585 1
a585 1
	 false,	                /* pc_relative */
d590 1
a590 1
	 false,	                /* partial_inplace */
d593 1
a593 1
	 false),                /* pcrel_offset */
d602 1
a602 1
	 false,	                /* pc_relative */
d607 1
a607 1
	 true,	                /* partial_inplace */
d610 1
a610 1
	 false),                 /* pcrel_offset */
d619 1
a619 1
	 false,	                /* pc_relative */
d624 1
a624 1
	 true,	                /* partial_inplace */
d627 1
a627 1
	 true),                 /* pcrel_offset */
d636 1
a636 1
	 false,	                /* pc_relative */
d641 1
a641 1
	 true,	                /* partial_inplace */
d644 1
a644 1
	 true),                 /* pcrel_offset */
d653 1
a653 1
	 false,	                /* pc_relative */
d658 1
a658 1
	 true,	                /* partial_inplace */
d661 1
a661 1
	 false),                /* pcrel_offset */
d670 1
a670 1
	 false,	                /* pc_relative */
d675 1
a675 1
	 false,	                /* partial_inplace */
d678 1
a678 1
	 false),                 /* pcrel_offset */
d687 1
a687 1
	 false,	                /* pc_relative */
d692 1
a692 1
	 true,	                /* partial_inplace */
d695 1
a695 1
	 true),                 /* pcrel_offset */
d703 1
a703 1
	 false,	                /* pc_relative */
d708 1
a708 1
	 true,	                /* partial_inplace */
d711 1
a711 1
	 false),                 /* pcrel_offset */
d719 1
a719 1
	 false,	                /* pc_relative */
d724 1
a724 1
	 true,	                /* partial_inplace */
d727 1
a727 1
	 false),                /* pcrel_offset */
d735 1
a735 1
	 false,	                /* pc_relative */
d740 1
a740 1
	 true,	                /* partial_inplace */
d743 1
a743 1
	 false),                /* pcrel_offset */
d752 1
a752 1
	 false,	                /* pc_relative */
d757 1
a757 1
	 false,	                /* partial_inplace */
d760 1
a760 1
	 false),                /* pcrel_offset */
d764 1
a764 1
/* Some really cheezy macros that can be turned on to test stderr :-) */
d789 1
a789 3
#define n_offset	_n._n_n._n_offset

*/
d791 4
a794 4
#define DUMP_RELOC2(n,r)                     \
{                                            \
   fprintf (stderr,"%s sym %d, r_vaddr %d %s\n", \
	   n, r->r_symndx, r->r_vaddr,\
d796 1
a796 1
	   ?" ":" TOCDEFN"  );      \
d805 1
a805 1
/* toc construction and management routines */
d810 1
a810 1
extern bfd* bfd_of_toc_owner;
a811 1

d827 1
a827 1
  data
d843 1
a843 1
  PARAMS ((asection *, int, enum ref_category, const char *));
d848 1
a848 1
     int our_toc_offset;
d852 4
a855 3
  /* add this entry to our toc addr-offset-name list */
  struct list_ele *t;
  t = (struct list_ele *) bfd_malloc (sizeof (struct list_ele));
d878 1
a878 1
static boolean ppc_record_toc_entry
d883 2
a884 2
/* record a toc offset against a symbol */
static boolean
d908 1
d912 2
d915 2
a916 3
	  local_syms =
	    (int *) bfd_zalloc (abfd,
				obj_raw_syment_count(abfd) * sizeof (int));
d918 4
a921 3
	    return false;
	  obj_coff_local_toc_table(abfd) = local_syms;
	  for (i = 0; i < obj_raw_syment_count(abfd); ++i)
d923 1
a923 1
	      SET_UNALLOCATED(local_syms[i]);
d932 1
a932 1
	  /* The size must fit in a 16bit displacment */
d937 1
a937 1
	      return false;
d945 2
a946 2
      /* check to see if there's a toc slot allocated. If not, do it
	 here. It will be used in relocate_section */
d952 1
a952 1
	  /* The size must fit in a 16bit displacment */
d957 1
a957 1
	      return false;
d962 1
a962 1
  return true;
d965 1
a965 1
/* record a toc offset against a symbol */
d986 1
a986 1
/* Return true if this relocation should
d989 1
a989 1
static boolean in_reloc_p(abfd, howto)
d1010 3
a1012 3
/* this function is in charge of performing all the ppc PE relocations */
/* Don't yet know if we want to do this this particular way ... (krk)  */
/* FIXME: (it is not yet enabled) */
d1025 3
a1027 3
  /* the consth relocation comes in two parts, we have to remember
     the state between calls, in these variables */
  static boolean part1_consth_active = false;
d1038 1
a1038 1
      /* Partial linking - do nothing */
d1046 1
a1046 1
      /* Keep the state machine happy in case we're called again */
d1049 1
a1049 1
	  part1_consth_active = true;
d1057 1
a1057 1
      part1_consth_active = false;
d1071 1
a1071 1
static boolean
d1085 1
a1085 1
  boolean hihalf;
d1095 1
a1095 1
    return true;
d1097 1
a1097 1
  hihalf = false;
d1148 1
a1148 1
      /* FIXME: PAIR unsupported in the following code */
d1179 2
a1180 2
		      rel->r_vaddr - input_section->vma, true)))
		return false;
d1186 1
a1186 1
      /* Each case must do its own relocation, setting rstat appropriately */
d1192 1
a1192 1
	     bfd_get_filename (input_bfd), r_type);
d1194 1
a1194 1
	  return false;
d1197 1
a1197 1
	    bfd_vma our_toc_offset;
d1214 6
a1219 8
	    /*
	     *  Amazing bit tricks present. As we may have seen earlier, we
	     *  use the 1 bit to tell us whether or not a toc offset has been
	     *  allocated. Now that they've all been allocated, we will use
	     *  the 1 bit to tell us if we've written this particular toc
	     *  entry out.
	     */
	    fixit = false;
d1221 2
a1222 1
	      { /* it is a file local symbol */
d1234 1
a1234 1
		    /* if it has been written out, it is marked with the
d1236 1
a1236 2
		       again.
		     */
d1241 3
a1243 5
		    /* write out the toc entry */
		    record_toc(toc_section,
			       our_toc_offset,
			       priv,
			       strdup(name));
d1245 1
a1245 2
		    bfd_put_32 (output_bfd,
			       val,
d1249 1
a1249 1
		    fixit = true;
d1272 1
a1272 2
		       the IAT to be part of the toc, thus saving a load.
		    */
d1274 2
a1275 3
		    our_toc_offset = val -
		      (toc_section->output_section->vma +
		       toc_section->output_offset);
d1277 2
a1278 2
		    /* The size must still fit in a 16bit displacment */
		    if (our_toc_offset >= 65535)
d1281 3
a1283 2
			  (_("%s: Relocation for %s of %x exceeds Toc size limit"),
			   bfd_get_filename (input_bfd), name, our_toc_offset);
d1285 1
a1285 1
			return false;
d1288 2
a1289 1
		    record_toc(toc_section, our_toc_offset, pub, strdup(name));
d1291 1
a1291 1
		else if (IS_WRITTEN(our_toc_offset))
d1293 1
a1293 1
		    /* if it has been written out, it is marked with the
d1295 1
a1295 2
		       again.
		     */
d1300 2
a1301 1
		    record_toc(toc_section, our_toc_offset, pub, strdup(name));
d1303 2
a1304 3
		    /* write out the toc entry */
		    bfd_put_32 (output_bfd,
			       val,
d1308 3
a1310 3
		    /* The tricky part is that this is the address that */
		    /* needs a .reloc entry for it */
		    fixit = true;
d1317 1
a1317 1
		   to a section or a common symbol, then it needs a reloc */
d1319 1
a1319 1
		/* relocation to a symbol in a section which
d1321 3
a1323 1
		   to a file */
d1325 1
a1325 4
		bfd_vma addr =  toc_section->output_section->vma
		  + toc_section->output_offset + our_toc_offset;

		if (coff_data(output_bfd)->pe)
d1331 3
a1333 3
	    /* FIXME: this test is conservative */
	    if ( (r_flags & IMAGE_REL_PPC_TOCDEFN) != IMAGE_REL_PPC_TOCDEFN &&
		our_toc_offset > toc_section->_raw_size)
d1336 3
a1338 3
		  (_("%s: Relocation exceeds allocated TOC (%x)"),
		   bfd_get_filename (input_bfd),
		   toc_section->_raw_size);
d1340 1
a1340 1
		return false;
d1343 1
a1343 1
	    /* Now we know the relocation for this toc reference */
d1345 1
a1345 4
	    rstat = _bfd_relocate_contents (howto,
					    input_bfd,
					    relocation,
					    loc);
d1350 4
a1353 5
	    /* To solve this, we need to know whether or not the symbol */
	    /* appearing on the call instruction is a glue function or not.  */
	    /* A glue function must announce itself via a IMGLUE reloc, and */
	    /* the reloc contains the required toc restore instruction */

d1356 2
a1357 1
	    DUMP_RELOC2(howto->name, rel);
d1365 1
a1365 1
		    bfd_put_32 (input_bfd, h->glue_insn, loc);
d1371 1
a1371 1
	  /* Unimplemented: codeview debugging information */
d1376 1
a1376 1
	  /* Unimplemented: codeview debugging information */
d1379 1
a1379 1
	     symbol */
d1384 1
d1386 1
a1386 1
		my_name = (syms+symndx)->_n._n_name;
d1388 1
a1388 3
	      {
		my_name = h->root.root.root.string;
	      }
d1393 1
a1393 1
		    bfd_get_filename(input_bfd),
d1404 1
a1404 1
	       pass over the relocs, and the glue instruction extracted */
d1406 1
d1413 1
a1413 1
	       bfd_get_filename (input_bfd), my_name);
d1415 1
a1415 1
	    return false;
a1419 1
	    struct coff_link_hash_entry *myh = 0;
d1421 2
a1422 1
	    DUMP_RELOC2(howto->name, rel);
d1426 1
a1426 1
		/* set magic values */
d1428 2
a1429 1
		struct coff_link_hash_entry *myh = 0;
d1432 1
a1432 1
					     false, false, true);
d1441 1
a1441 1
					     false, false, true);
d1446 1
a1446 1
					     false, false, true);
d1451 2
a1452 1
	      { /* it is a file local symbol */
d1461 1
a1461 1
		if (strcmp(".idata$2", name) == 0)
d1463 1
a1463 1
		else if (strcmp(".idata$4", name) == 0)
d1465 1
a1465 1
		else if (strcmp(".idata$5", name) == 0)
d1470 1
a1470 1
		    myh = 0;
d1474 1
a1474 1
						 false, false, true);
d1488 1
a1488 1
						     false, false, true);
d1497 1
a1497 1
						     false, false, true);
d1502 1
a1502 1
						     false, false, true);
d1509 4
a1512 4
		      	      input_bfd,
			      val -
			      pe_data(output_bfd)->pe_opthdr.ImageBase,
			      loc);
d1537 1
a1537 1
      if ( info->base_file )
d1540 2
a1541 2
	     to a section or a common symbol, then it needs a reloc */
	  if (sym && pe_data(output_bfd)->in_reloc_p(output_bfd, howto))
d1543 1
a1543 1
	      /* relocation to a symbol in a section which
d1545 1
a1545 1
		 to a file */
d1551 3
a1553 4
	      if (coff_data(output_bfd)->pe)
		{
		  addr -= pe_data(output_bfd)->pe_opthdr.ImageBase;
		}
d1589 1
a1589 3
	      {
		return false;
	      }
a1591 1

d1594 1
a1594 1
  return true;
d1640 1
a1640 1
      else if (t->cat == data)
d1651 2
a1652 1
		      global_toc_size, global_toc_size, thunk_size, thunk_size);
d1668 1
a1668 1
boolean
d1674 1
d1677 2
a1678 2
  if ( global_toc_size == 0 ) /* FIXME: does this get me in trouble? */
    return true;
d1681 2
a1682 4
    {
      /* No toc owner? Something is very wrong.  */
      abort ();
    }
d1686 2
a1687 4
    {
      /* No toc section? Something is very wrong.  */
      abort ();
    }
d1689 3
a1691 2
  foo = (bfd_byte *) bfd_alloc(bfd_of_toc_owner, global_toc_size);
  memset(foo, test_char, global_toc_size);
d1696 1
a1696 1
  return true;
d1699 1
a1699 1
boolean
d1707 1
a1707 1
  /* here we have a bfd that is to be included on the link. We have a hook
d1709 1
d1711 1
a1711 3
  _bfd_coff_get_external_symbols(abfd);

  /* rummage around all the relocs and map the toc */
d1715 1
a1715 3
    {
      return true;
    }
d1718 3
a1720 3
  {
    if (sec->reloc_count == 0)
      continue;
d1722 3
a1724 3
    /* load the relocs */
    /* FIXME: there may be a storage leak here */
    i=_bfd_coff_read_internal_relocs(abfd,sec,1,0,0,0);
d1726 2
a1727 2
    if (i == 0)
      abort ();
d1729 5
a1733 5
    for (rel=i;rel<i+sec->reloc_count;++rel)
      {
	unsigned short r_type  = EXTRACT_TYPE (rel->r_type);
	unsigned short r_flags = EXTRACT_FLAGS(rel->r_type);
	boolean ok = true;
d1735 1
a1735 1
	DUMP_RELOC2(ppc_coff_howto_table[r_type].name, rel);
d1737 19
a1755 19
	switch(r_type)
	  {
	  case IMAGE_REL_PPC_TOCREL16:
	    /* if TOCDEFN is on, ignore as someone else has allocated the
	       toc entry */
	    if ( (r_flags & IMAGE_REL_PPC_TOCDEFN) != IMAGE_REL_PPC_TOCDEFN )
	      ok = ppc_record_toc_entry(abfd, info, sec,
					rel->r_symndx, default_toc);
	    if (!ok)
	      return false;
	    break;
	  case IMAGE_REL_PPC_IMGLUE:
	    ppc_mark_symbol_as_glue(abfd, rel->r_symndx, rel);
	    break;
	  default:
	    break;
	  }
      }
  }
d1757 1
a1757 1
  return true;
d1763 2
a1764 7
ppc_refhi_reloc (abfd,
		 reloc_entry,
		 symbol,
		 data,
		 input_section,
		 output_bfd,
		 error_message)
d1785 2
a1786 7
ppc_reflo_reloc (abfd,
		 reloc_entry,
		 symbol,
		 data,
		 input_section,
		 output_bfd,
		 error_message)
d1807 2
a1808 7
ppc_pair_reloc (abfd,
		reloc_entry,
		symbol,
		data,
		input_section,
		output_bfd,
		error_message)
d1827 2
a1828 7
ppc_toc16_reloc (abfd,
		 reloc_entry,
		 symbol,
		 data,
		 input_section,
		 output_bfd,
		 error_message)
d1837 2
a1838 2
  UN_IMPL("TOCREL16");
  DUMP_RELOC("TOCREL16",reloc_entry);
d1841 1
a1841 3
    {
      return bfd_reloc_continue;
    }
d1848 3
a1850 5
/* ADDR32NB : 32 bit address relative to the virtual origin.         */
/*            (On the alpha, this is always a linker generated thunk)*/
/*            (i.e. 32bit addr relative to the image base)           */
/*                                                                   */
/*                                                                   */
d1853 2
a1854 7
ppc_addr32nb_reloc (abfd,
		    reloc_entry,
		    symbol,
		    data,
		    input_section,
		    output_bfd,
		    error_message)
d1872 2
a1873 7
ppc_secrel_reloc (abfd,
		  reloc_entry,
		  symbol,
		  data,
		  input_section,
		  output_bfd,
		  error_message)
d1892 2
a1893 7
ppc_section_reloc (abfd,
		   reloc_entry,
		   symbol,
		   data,
		   input_section,
		   output_bfd,
		   error_message)
d1912 2
a1913 7
ppc_imglue_reloc (abfd,
		  reloc_entry,
		  symbol,
		  data,
		  input_section,
		  output_bfd,
		  error_message)
d1936 2
a1937 4
	  type field. Not yet implemented.
*/
static void ppc_coff_rtype2howto PARAMS ((arelent *relent,
					  struct internal_reloc *internal));
a1943 1

d1952 1
a1952 2
     than that.
  */
d1958 1
a1958 1
  /* the masking process only slices off the bottom byte for r_type.  */
d1962 2
a1963 2
  /* check for absolute crap */
  if ( junk != 0 )
d1976 1
a1976 1
      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, internal);
d1980 1
a1980 1
      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, internal);
d1984 1
a1984 1
      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, internal);
a1999 1

d2021 1
a2021 2
     than that.
  */
d2023 3
a2025 3
  unsigned short r_type  = EXTRACT_TYPE (rel->r_type);
  unsigned short r_flags = EXTRACT_FLAGS(rel->r_type);
  unsigned short junk    = EXTRACT_JUNK (rel->r_type);
d2027 2
a2028 2
  /* the masking process only slices off the bottom byte for r_type.  */
  if ( r_type > MAX_RELOC_INDEX )
d2031 2
a2032 2
  /* check for absolute crap */
  if ( junk != 0 )
d2075 1
a2075 1
/* a cheesy little macro to make the code a little more readable */
a2100 1
  /*NOTREACHED*/
a2108 4
#ifndef COFF_IMAGE_WITH_PE
static void ppc_coff_swap_sym_in_hook PARAMS ((bfd *, PTR, PTR));
#endif

d2118 1
d2121 1
d2149 2
d2162 2
a2163 2
      and how often, etc. It's not clear to me that there isn't a hole here.
*/
d2171 1
a2171 1
  struct internal_syment      *in = (struct internal_syment *)in1;
d2173 1
a2173 1
  if (bfd_of_toc_owner != 0) /* we already have a toc, so go home */
d2176 1
a2176 1
  if (strcmp(in->_n._n_name, ".toc") == 0)
d2181 1
a2181 1
      s = bfd_get_section_by_name ( abfd , TOC_SECTION_NAME);
d2183 1
a2183 3
	{
	  return;
	}
d2192 2
a2193 4
	{
	  /* FIXME: set appropriate bfd error */
	  abort ();
	}
d2195 1
a2195 1
      /* save the bfd for later allocation */
d2202 1
d2206 1
a2206 1
static boolean ppc_do_last PARAMS ((bfd *));
d2209 1
a2209 1
static boolean
d2214 1
a2214 1
    return true;
d2216 1
a2216 1
    return false;
d2225 1
a2225 1
/* this piece of machinery exists only to guarantee that the bfd that holds
d2234 1
a2234 2
   precise form of comment. krk@@cygnus.com
*/
d2238 1
a2238 1
boolean
d2245 1
a2245 1
  boolean debug_merge_allocated;
d2248 5
a2252 5
  size_t max_sym_count;
  size_t max_lineno_count;
  size_t max_reloc_count;
  size_t max_output_reloc_count;
  size_t max_contents_size;
d2260 1
d2278 1
a2278 1
  debug_merge_allocated = false;
d2288 1
a2288 1
  debug_merge_allocated = true;
d2294 1
a2294 1
	return false;
d2309 1
a2311 1

d2322 1
a2322 1
	      sec->linker_mark = true;
d2361 4
a2364 4
      finfo.section_info =
	((struct coff_link_section_info *)
	 bfd_malloc ((abfd->section_count + 1)
		     * sizeof (struct coff_link_section_info)));
d2367 1
d2380 1
d2407 2
d2410 3
a2412 2
	    ((struct internal_reloc *)
	     bfd_malloc (o->reloc_count * sizeof (struct internal_reloc)));
d2414 1
a2414 3
	    ((struct coff_link_hash_entry **)
	     bfd_malloc (o->reloc_count
		     * sizeof (struct coff_link_hash_entry *)));
d2437 1
a2437 1
      size_t sz;
d2439 1
a2439 1
      sub->output_has_begun = false;
d2446 10
a2455 10
  finfo.internal_syms = ((struct internal_syment *)
			 bfd_malloc (max_sym_count
				     * sizeof (struct internal_syment)));
  finfo.sec_ptrs = (asection **) bfd_malloc (max_sym_count
					     * sizeof (asection *));
  finfo.sym_indices = (long *) bfd_malloc (max_sym_count * sizeof (long));
  finfo.outsyms = ((bfd_byte *)
		   bfd_malloc ((size_t) ((max_sym_count + 1) * symesz)));
  finfo.linenos = (bfd_byte *) bfd_malloc (max_lineno_count
				       * bfd_coff_linesz (abfd));
d2459 4
a2462 3
    finfo.internal_relocs = ((struct internal_reloc *)
			     bfd_malloc (max_reloc_count
					 * sizeof (struct internal_reloc)));
d2505 1
a2505 1
		  sub->output_has_begun = true;
d2530 1
a2530 1
    last_one->output_has_begun = true;
a2534 1

d2536 1
a2536 1
  debug_merge_allocated = false;
d2580 2
d2585 4
a2588 6
      if (bfd_seek (abfd,
		    (obj_sym_filepos (abfd)
		     + finfo.last_file_index * symesz),
		    SEEK_SET) != 0
	  || bfd_write (finfo.outsyms, symesz, 1, abfd) != symesz)
	return false;
d2592 1
a2592 1
  finfo.failed = false;
d2610 2
a2611 2
      external_relocs = ((bfd_byte *)
			 bfd_malloc (max_output_reloc_count * relsz));
d2639 1
d2641 1
a2641 2
	      || bfd_write ((PTR) external_relocs, relsz, o->reloc_count,
			    abfd) != relsz * o->reloc_count)
d2669 1
a2669 1
	return false;
d2675 5
a2679 5
      if (bfd_seek (abfd,
		    (obj_sym_filepos (abfd)
		     + obj_raw_syment_count (abfd) * symesz),
		    SEEK_SET) != 0)
	return false;
d2682 3
a2684 3
      bfd_h_put_32 (abfd,
		    _bfd_stringtab_size (finfo.strtab) + STRING_SIZE_SIZE,
		    (bfd_byte *) strbuf);
d2686 1
a2686 1
 #error Change bfd_h_put_32
d2689 3
a2691 2
      if (bfd_write (strbuf, 1, STRING_SIZE_SIZE, abfd) != STRING_SIZE_SIZE)
	return false;
d2694 1
a2694 1
	return false;
d2703 1
a2703 1
  return true;
d2741 1
a2741 1
  return false;
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d9 1
a9 1
   coff files, in particular, those for the rs/6000, alpha, mips, and 
d33 1
a33 1
   - dlltool will not produce correct output in some .reloc cases, and will 
a36 1

a77 1

d89 1
a89 1
    fprintf(stderr,\
d92 1
a92 1
    abort(); \
a94 1

d106 1
a106 1
/* PE linker hash table entries. */
a120 1

d154 1
a154 1
  struct ppc_coff_link_hash_entry *ret = 
d161 1
a161 1
      bfd_hash_allocate (table, 
d169 1
a169 1
	 _bfd_coff_link_hash_newfunc ((struct bfd_hash_entry *) ret, 
a221 1

d237 1
a237 1
/* these should definitely go in a header file somewhere... */
a318 1

a345 1

a387 2


a388 1

d412 1
a412 1
/*   TOCREL14       : 16 bit displacement field, similar to REL14 or ADDR14. */
d432 6
a437 6
  HOWTO (IMAGE_REL_PPC_ABSOLUTE, /* type */                                 
	 0,	                 /* rightshift */                           
	 0,	                 /* size (0 = byte, 1 = short, 2 = long) */ 
	 0,	                 /* bitsize */                   
	 false,	                 /* pc_relative */                          
	 0,	                 /* bitpos */                               
d439 1
a439 1
	 0,		         /* special_function */                     
d441 3
a443 3
	 false,	                 /* partial_inplace */                      
	 0x00,	 	         /* src_mask */                             
	 0x00,        		 /* dst_mask */                             
d445 1
a445 1
  
d448 6
a453 6
  HOWTO(IMAGE_REL_PPC_ADDR64,    /* type */                                 
	0,	                 /* rightshift */                           
	3,	                 /* size (0 = byte, 1 = short, 2 = long) */ 
	64,	                 /* bitsize */                   
	false,	                 /* pc_relative */                          
	0,	                 /* bitpos */                               
d455 1
a455 1
	0,		         /* special_function */                     
d457 1
a457 1
	true,	                 /* partial_inplace */                      
d465 5
a469 5
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d471 1
a471 1
	 0,		        /* special_function */                     
d473 3
a475 3
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
d477 1
a477 1
  
d481 1
a481 1
  /* anyone else uses.... The li field is in bit 2 thru 25 */ 
d484 2
a485 2
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
d487 2
a488 2
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d490 1
a490 1
	 0,		        /* special_function */                     
d492 3
a494 3
	 true,	                /* partial_inplace */                      
	 0x07fffffc,	        /* src_mask */                             
	 0x07fffffc,        	/* dst_mask */                             
d496 1
a496 1
  
d499 6
a504 6
  HOWTO (IMAGE_REL_PPC_ADDR16,  /* type */             
	 0,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d506 1
a506 1
	 0,		        /* special_function */                     
d508 3
a510 3
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d512 1
a512 1
  
d517 6
a522 6
  HOWTO (IMAGE_REL_PPC_ADDR14,  /* type */             
	 1,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d524 1
a524 1
	 0,		        /* special_function */                     
d526 3
a528 3
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d530 1
a530 1
  
d535 5
a539 5
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 26,	                /* bitsize */                   
	 true,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d541 1
a541 1
	 0,		        /* special_function */                     
d543 3
a545 3
	 true,	                /* partial_inplace */                      
	 0x3fffffc,	        /* src_mask */                             
	 0x3fffffc,        	/* dst_mask */                             
d547 1
a547 1
  
d553 6
a558 6
  HOWTO (IMAGE_REL_PPC_ADDR14,  /* type */             
	 1,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d560 1
a560 1
	 0,		        /* special_function */                     
d562 3
a564 3
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d566 1
a566 1
  
d570 6
a575 6
  HOWTO (IMAGE_REL_PPC_TOCREL16,/* type */             
	 0,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d577 1
a577 1
	 ppc_toc16_reloc,       /* special_function */                     
d579 3
a581 3
	 false,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d583 1
a583 1
  
d587 6
a592 6
  HOWTO (IMAGE_REL_PPC_TOCREL14,/* type */             
	 1,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d594 1
a594 1
	 0,		        /* special_function */                     
d596 3
a598 3
	 false,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d600 1
a600 1
  
d604 6
a609 6
  HOWTO (IMAGE_REL_PPC_ADDR32NB,/* type */             
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d611 1
a611 1
	 0,                     /* special_function */                     
d613 3
a615 3
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d617 1
a617 1
  
d621 6
a626 6
  HOWTO (IMAGE_REL_PPC_SECREL,/* type */             
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d628 1
a628 1
	 ppc_secrel_reloc,      /* special_function */                     
d630 3
a632 3
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d638 6
a643 6
  HOWTO (IMAGE_REL_PPC_SECTION,/* type */             
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d645 1
a645 1
	 ppc_section_reloc,     /* special_function */                     
d647 3
a649 3
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d655 6
a660 6
  HOWTO (IMAGE_REL_PPC_IFGLUE,/* type */             
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d662 1
a662 1
	 0,		        /* special_function */                     
d664 3
a666 3
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d672 6
a677 6
  HOWTO (IMAGE_REL_PPC_IMGLUE,/* type */             
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d679 1
a679 1
	 ppc_imglue_reloc,      /* special_function */                     
d681 3
a683 3
	 false,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d689 6
a694 6
  HOWTO (IMAGE_REL_PPC_SECREL16,/* type */             
	 0,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d696 1
a696 1
	 0,		        /* special_function */                     
d698 3
a700 3
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d705 6
a710 6
  HOWTO (IMAGE_REL_PPC_REFHI,   /* type */             
	 0,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d712 1
a712 1
	 ppc_refhi_reloc,	/* special_function */                     
d714 3
a716 3
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d721 6
a726 6
  HOWTO (IMAGE_REL_PPC_REFLO,   /* type */             
	 0,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d728 1
a728 1
	 ppc_refhi_reloc,	/* special_function */                     
d730 3
a732 3
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d737 6
a742 6
  HOWTO (IMAGE_REL_PPC_PAIR,    /* type */             
	 0,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d744 1
a744 1
	 ppc_pair_reloc,        /* special_function */                     
d746 3
a748 3
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d754 6
a759 6
  HOWTO ( (IMAGE_REL_PPC_TOCREL16 | IMAGE_REL_PPC_TOCDEFN), /* type */ 
	 0,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d761 1
a761 1
	 0,                     /* special_function */                     
d763 3
a765 3
	 false,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
a768 2


a769 1

d779 1
a779 1
       fprintf(stderr,_("Unimplemented Relocation -- %s\n"),x); \
d785 1
a785 1
   fprintf(stderr,"%s sym %d, addr %d, addend %d\n", \
d790 2
a791 2
/* Given a reloc name, n, and a pointer to an internal_reloc, 
   dump out interesting information on the contents 
d801 1
a801 1
   fprintf(stderr,"%s sym %d, r_vaddr %d %s\n", \
a811 2


d913 2
a914 2
  if (h == 0) 
    { 
d920 3
a922 3
	  local_syms = 
	    (int *) bfd_zalloc (abfd, 
				obj_raw_syment_count(abfd) * sizeof(int));
d932 1
a932 1
      if (IS_UNALLOCATED(local_syms[sym])) 
a990 1

d992 1
a992 1
   appear in the output .reloc section. */
d998 2
a999 2
  return 
    (! howto->pc_relative) 
d1003 1
a1003 1
      && (howto->type != IMAGE_REL_PPC_IFGLUE) 
d1011 1
a1011 1
}     
d1038 1
a1038 1
	
d1041 1
a1041 1
  if (output_bfd) 
d1045 1
a1045 1
      return bfd_reloc_ok; 
d1052 1
a1052 1
      if (r_type == IMAGE_REL_PPC_REFHI) 
d1059 2
a1060 2
  
  if ((part1_consth_active) && (r_type != IMAGE_REL_PPC_PAIR)) 
d1067 1
d1069 1
a1069 3
  sym_value = get_symbol_value(symbol_in);
  
  return(bfd_reloc_ok);	
d1095 1
a1095 1
  
d1101 1
a1101 1
  
d1120 1
a1120 1
  
d1134 1
a1134 1
	  h = (struct ppc_coff_link_hash_entry *) 
d1136 1
a1136 1
	  if (h != 0) 
d1146 2
a1147 2
	  /* An IMGLUE reloc must have a name. Something is very wrong. */
	  abort();
d1190 1
a1190 1
      
d1207 1
a1207 1
	    if (toc_section == 0) 
d1209 1
a1209 1
		toc_section = bfd_get_section_by_name (bfd_of_toc_owner, 
d1212 1
a1212 1
		if ( toc_section == NULL ) 
d1214 2
a1215 2
		    /* There is no toc section. Something is very wrong. */
		    abort();
d1219 1
a1219 1
	    /* 
d1240 1
a1240 1
		    /* if it has been written out, it is marked with the 
d1249 3
a1251 3
		    record_toc(toc_section, 
			       our_toc_offset, 
			       priv, 
d1254 1
a1254 1
		    bfd_put_32(output_bfd,
d1267 1
a1267 1
		if ((r_flags & IMAGE_REL_PPC_TOCDEFN) 
d1270 7
a1276 7
		    /* This is unbelievable cheese. Some knowledgable asm 
		       hacker has decided to use r2 as a base for loading 
		       a value. He/She does this by setting the tocdefn bit, 
		       and not supplying a toc definition. The behaviour is 
		       then to use the difference between the value of the 
		       symbol and the actual location of the toc as the toc 
		       index. 
d1281 1
a1281 1
		       dll linkage, takes advantage of that and considers 
d1285 2
a1286 2
		    our_toc_offset = val - 
		      (toc_section->output_section->vma + 
d1293 1
a1293 1
			  (_("%s: Relocation for %s of %x exceeds Toc size limit"), 
d1303 1
a1303 1
		    /* if it has been written out, it is marked with the 
d1314 1
a1314 1
		    bfd_put_32(output_bfd,
d1325 1
a1325 1
	    if (fixit && info->base_file) 
d1331 1
a1331 1
		   isn't absolute - we output the address here 
d1336 1
a1336 1
		    
a1342 1

d1348 1
a1348 1
		  (_("%s: Relocation exceeds allocated TOC (%x)"), 
d1358 2
a1359 2
					    input_bfd, 
					    relocation, 
d1366 1
a1366 1
	    /* appearing on the call instruction is a glue function or not. */
d1369 1
a1369 1
	  
d1377 1
a1377 1
		if (h->symbol_is_glue == 1) 
d1379 2
a1380 2
		    x = bfd_get_32(input_bfd, loc);
		    bfd_put_32(input_bfd, h->glue_insn, loc);
d1387 2
a1388 2
	  /* For fast access to the header of the section 
	     containing the item. */
d1406 2
a1407 2
	    fprintf(stderr, 
		    _("Warning: unsupported reloc %s <file %s, section %s>\n"), 
d1412 1
a1412 1
	    fprintf(stderr,"sym %ld (%s), r_vaddr %ld (%lx)\n", 
d1414 1
a1414 1
		    (unsigned long) rel->r_vaddr);  
d1422 1
a1422 1
	    if (h->symbol_is_glue == 1) 
d1427 1
a1427 1
	      (_("%s: Out of order IMGLUE reloc for %s"), 
d1447 3
a1449 3
		first_thunk_address = myh->root.u.def.value + 
		  sec->output_section->vma + 
		    sec->output_offset - 
d1451 1
a1451 1
		
d1456 1
a1456 1
		
d1488 1
a1488 1
		    if (myh == 0) 
d1490 2
a1491 2
			/* Missing magic cookies. Something is very wrong. */
			abort();
d1493 2
a1494 2
		    
		    val = myh->root.u.def.value + 
d1502 3
a1504 3
			first_thunk_address = myh->root.u.def.value + 
			  sec->output_section->vma + 
			    sec->output_offset - 
d1506 1
a1506 1
			
d1511 1
a1511 1
			
d1522 2
a1523 2
		      	      input_bfd, 
			      val - 
d1535 2
a1536 2
					  input_bfd, 
					  val, 
d1544 2
a1545 2
					  input_bfd, 
					  val, 
d1557 1
a1557 1
		 isn't absolute - we output the address here 
d1559 3
a1561 3
	      bfd_vma addr = rel->r_vaddr 
		- input_section->vma 
		+ input_section->output_offset 
d1600 1
a1600 1
		   (info, name, howto->name, 
d1609 1
a1609 1
    }     
d1645 3
a1647 3
  fprintf(file, _(h1));
  fprintf(file, _(h2));
  fprintf(file, _(h3));
d1649 1
a1649 1
  for(t = head; t != 0; t=t->next)
d1666 1
a1666 1
	      fprintf(file,
d1673 1
a1673 1
      fprintf(file,
d1675 1
a1675 1
      fprintf(file,
d1681 1
a1681 1
  fprintf(file, "\n");
d1685 1
a1685 1
ppc_allocate_toc_section (info) 
d1697 2
a1698 2
      /* No toc owner? Something is very wrong. */
      abort();
d1702 1
a1702 1
  if (s == NULL) 
d1704 2
a1705 2
      /* No toc section? Something is very wrong. */
      abort();
d1726 1
a1726 1
     to do reloc rummaging, before section sizes are nailed down. */
d1740 1
a1740 1
    if (sec->reloc_count == 0) 
d1746 1
a1746 1
    
d1748 1
a1748 1
      abort();
d1750 1
a1750 1
    for (rel=i;rel<i+sec->reloc_count;++rel) 
d1758 1
a1758 1
	switch(r_type) 
d1764 1
a1764 1
	      ok = ppc_record_toc_entry(abfd, info, sec, 
a1782 1

a1860 1

a1994 1

a1995 1

d1997 1
a1997 2
      (sizeof(ppc_coff_howto_table) / sizeof(ppc_coff_howto_table[0]) - 1)

d2000 1
a2000 1
          that there are some bits encoded in the upper portion of the 
d2010 1
a2010 1
{  
d2027 3
a2029 3
  /* the masking process only slices off the bottom byte for r_type. */
  if ( r_type > MAX_RELOC_INDEX ) 
    abort();
d2033 1
a2033 1
    abort();
d2035 1
a2035 1
  switch(r_type) 
d2060 1
a2060 1
      fprintf(stderr, 
d2064 1
a2064 1
      howto = ppc_coff_howto_table + r_type;      
d2067 1
a2067 1
  
d2069 1
a2069 1
  
d2098 4
a2101 4
  /* the masking process only slices off the bottom byte for r_type. */
  if ( r_type > MAX_RELOC_INDEX ) 
    abort();
  
d2104 3
a2106 3
    abort();
    
  switch(r_type) 
d2135 1
a2135 1
      fprintf(stderr, 
d2142 1
a2142 1
  
a2145 1

d2169 1
a2169 1
    default: 
a2175 1

d2177 1
a2177 1
/* Tailor coffcode.h -- macro heaven. */
d2190 1
a2190 1
#define coff_bfd_final_link          ppc_bfd_coff_final_link 
a2220 1

a2221 1

d2224 1
a2224 1
   What we're trying to do here is allocate a toc section (early), and attach 
d2254 1
a2254 1
      if (s != NULL) 
d2268 1
a2268 1
	  abort();
d2301 1
a2301 1
   the toc section is written last. 
d2304 1
a2304 1
   end of the section list for the bfd. 
d2306 3
a2308 3
   This is otherwise intended to be functionally the same as 
   cofflink.c:_bfd_coff_final_link(). It is specifically different only 
   where the POWERPC_LE_PE macro modifies the code. It is left in as a 
a2311 1

a2815 1

d2821 1
a2821 1
/* The transfer vectors that lead the outside world to all of the above. */
d2834 1
a2834 1
  
d2853 1
a2853 1
  
d2860 1
a2860 1
  
d2877 1
a2877 1
  
d2886 1
a2886 1
  bfd_target_coff_flavour,	
a2929 1

d2936 1
a2936 1
  
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d25 2
a26 1
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
a40 1
#include "obstack.h"
d55 6
d91 1
a91 1
    "File %s, line %d, Hash check failure, bad eye %8s\n", \
d134 14
d791 1
a791 1
       fprintf(stderr,"Unimplemented Relocation -- %s\n",x); \
d828 4
d865 3
d869 1
a869 1
record_toc(toc_section, our_toc_offset, cat, name)
d900 5
d909 2
a910 2
     struct bfd_link_info *info;
     asection *sec;
d912 1
a912 1
     enum toc_type toc_kind;
d932 1
a932 1
	  int i;
d954 1
a954 1
	      (*_bfd_error_handler) ("TOC overflow");
d974 1
a974 1
	      (*_bfd_error_handler) ("TOC overflow");
d1010 1
a1010 1
     bfd * abfd;
d1078 1
a1078 1
      *error_message = (char *) "Missing PAIR";
d1179 3
a1181 2
		     + sym->n_value
		     - sec->vma);
d1200 1
a1200 1
		      rel->r_vaddr - input_section->vma)))
d1212 1
a1212 1
	    ("%s: unsupported relocation type 0x%02x",
d1309 1
a1309 1
			  ("%s: Relocation for %s of %x exceeds Toc size limit", 
d1365 1
a1365 1
		  ("%s: Relocation exceeds allocated TOC (%x)", 
d1424 1
a1424 1
		    "Warning: unsupported reloc %s <file %s, section %s>\n", 
d1444 1
a1444 1
	      ("%s: Out of order IMGLUE reloc for %s", 
d1631 1
d1633 3
a1635 1
#ifdef COFF_IMAGE_WITH_PE
d1649 1
a1649 1
h1 = "\n\t\t\tTOC MAPPING\n\n";
d1651 1
a1651 1
h2 = " TOC    disassembly  Comments       Name\n";
d1653 1
a1653 1
h3 = " Offset  spelling                   (if present)\n";
d1656 2
a1657 2
dump_toc(vfile)
     void *vfile;
d1659 1
a1659 1
  FILE *file = vfile;
d1662 3
a1664 3
  fprintf(file, h1);
  fprintf(file, h2);
  fprintf(file, h3);
d1668 1
a1668 1
      char *cat;
d1671 1
a1671 1
	cat = "private       ";
d1673 1
a1673 1
	cat = "public        ";
d1675 1
a1675 1
	cat = "data-in-toc   ";
d1680 1
a1680 1
	    cat = "IAT reference ";
d1684 1
a1684 1
		      "**** global_toc_size %ld(%lx), thunk_size %ld(%lx)\n",
d1686 1
a1686 1
	      cat = "Out of bounds!";
d1703 1
a1703 1
     struct bfd_link_info *info;
d1809 5
a1813 5
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
d1815 1
a1815 1
     char **error_message;
d1863 5
a1867 5
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
d1869 1
a1869 1
     char **error_message;
d1889 5
a1893 5
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
d1895 1
a1895 1
     char **error_message;
d1948 5
a1952 5
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
d1954 1
a1954 1
     char **error_message;
d1973 5
a1977 5
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
d1979 1
a1979 1
     char **error_message;
d1998 5
a2002 5
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
d2004 1
a2004 1
     char **error_message;
d2083 1
a2083 1
	      "Warning: Unsupported reloc %s [%d] used -- it may not work.\n",
d2096 1
a2096 1
     bfd *abfd;
d2099 2
a2100 2
     struct coff_link_hash_entry *h;
     struct internal_syment *sym;
d2158 1
a2158 1
	      "Warning: Unsupported reloc %s [%d] used -- it may not work.\n",
d2178 1
a2178 1
     bfd *abfd;
d2206 1
a2206 2
static void
ppc_coff_swap_sym_in_hook ();
d2217 1
d2225 3
d2230 14
d2266 1
a2266 1
     PTR ext1;
d2305 1
a2305 2
boolean
ppc_bfd_coff_final_link ();
d2307 2
a2308 1
#ifndef COFF_IMAGE_WITH_PE
d2311 1
a2311 1
ppc_do_last(abfd)
a2336 1
#define POWERPC_LE_PE
d2394 4
a2397 1
    bfd_coff_compute_section_file_positions (abfd);
a2621 1
    extern bfd* ppc_get_last();
d2844 5
d2852 1
a2852 2
const bfd_target
TARGET_LITTLE_SYM =
d2898 7
d2906 1
a2906 1
  COFF_SWAP_TABLE,
d2911 1
a2911 2
const bfd_target
TARGET_BIG_SYM =
d2958 9
a2966 1
  COFF_SWAP_TABLE,
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d71 27
d112 2
a113 1
  char eye_catcher[8];
a115 11
/* Need a 7 char string for an eye catcher */
#define EYE "krkjunk"

#define CHECK_EYE(addr) \
 if (strcmp(addr, EYE) != 0) \
  { \
    fprintf(stderr,\
    "File %s, line %d, Hash check failure, bad eye %8s\n", \
    __FILE__, __LINE__, addr); \
    abort(); \
 }
d160 2
a161 1
      strcpy(ret->eye_catcher, EYE);
d207 2
a208 2
/* use the complete range of a 16-bit displacement (I guess). We have */
/* to adjust for this when we fix up loads displaced off the toc reg. */
d873 1
a873 1
static int
a881 1
  int ret_val;
d891 1
a891 1
      CHECK_EYE(h->eye_catcher);
a915 1
	  ret_val = global_toc_size;
d919 1
a919 1
	  if (global_toc_size >= 65535)
d921 3
a923 3
	      fprintf(stderr,
		      "Exceeded toc size of 65535\n");
	      abort();
a924 15

#ifdef TOC_DEBUG
	  fprintf(stderr,
		  "Setting toc_offset for local sym %d to %d\n",
		  sym, ret_val);
#endif
	}
      else
	{
	  ret_val = local_syms[sym];
#ifdef TOC_DEBUG
	  fprintf(stderr,
		  "toc_offset already set for local sym %d to %d\n",
		  sym, ret_val);
#endif
a935 1
	  ret_val = global_toc_size;
d941 3
a943 3
	      fprintf(stderr,
		      "Exceeded toc size of 65535\n");
	      abort();
a944 15

#ifdef TOC_DEBUG
	  fprintf(stderr,
		  "Setting toc_offset for sym %d (%s) [h=%p] to %d\n",
		  sym, name, h, ret_val);
#endif
	}
      else
	{
	  ret_val = h->toc_offset;
#ifdef TOC_DEBUG
	  fprintf(stderr,
		  "toc_offset already set for sym %d (%s) [h=%p] to %d\n",
		  sym, name, h, ret_val);
#endif
d948 1
a948 1
  return ret_val;
a950 118
#endif /* COFF_IMAGE_WITH_PE */

#if 0

/* FIXME: record a toc offset against a data-in-toc symbol */
/* Now, there is currenly some confusion on what this means. In some 
   compilers one sees the moral equivalent of:
      .tocd
      define some data
      .text
      refer to the data with a [tocv] qualifier
   In general, one sees something to indicate that a tocd has been
   seen, and that would trigger the allocation of data in toc. The IBM
   docs seem to suggest that anything with the TOCDEFN qualifier should
   never trigger storage allocation. However, in the kernel32.lib that 
   we've been using for our test bed, there are a couple of variables
   referenced that fail that test.

   So it can't work that way.
*/
static int
ppc_record_data_in_toc_entry(abfd, info, sec, sym, toc_kind)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     int sym;
     enum toc_type toc_kind;
{
  struct ppc_coff_link_hash_entry *h = 0;
  int ret_val;
  const char *name;

  int *local_syms;

  h = (struct ppc_coff_link_hash_entry *) (obj_coff_sym_hashes (abfd)[sym]);

  if (h == 0) 
    { 
      local_syms = obj_coff_local_toc_table(abfd);
      if (local_syms == 0)
	{
	  int i;
	  /* allocate a table */
	  local_syms = 
	    (int *) bfd_zalloc (abfd, 
				obj_raw_syment_count(abfd) * sizeof(int));
	  if (local_syms == 0)
	    return false;
	  obj_coff_local_toc_table(abfd) = local_syms;
	  for (i = 0; i < obj_raw_syment_count(abfd); ++i)
	    {
	      SET_UNALLOCATED(local_syms[i]);
	    }
	}

      if (IS_UNALLOCATED(local_syms[sym])) 
	{
	  local_syms[sym] = global_toc_size;
	  ret_val = global_toc_size;
	  global_toc_size += 4;
#ifdef TOC_DEBUG
	  fprintf(stderr,
		  "Setting data_in_toc_offset for local sym %d to %d\n",
		  sym, ret_val);
#endif
	}
      else
	{
	  ret_val = local_syms[sym];
#ifdef TOC_DEBUG
	  fprintf(stderr,
		  "data_in_toc_offset already set for local sym %d to %d\n",
		  sym, ret_val);
#endif
	}
    }
  else
    {
      CHECK_EYE(h->eye_catcher);

      name = h->root.root.root.string;

      /* check to see if there's a toc slot allocated. If not, do it
	 here. It will be used in relocate_section */
      if (IS_UNALLOCATED(h->toc_offset))
	{
#if 0
	  h->toc_offset = global_toc_size;
#endif
	  ret_val = global_toc_size;
	  /* We're allocating a chunk of the toc, as opposed to a slot */
	  /* FIXME: alignment? */
	  
	  global_toc_size += 4;
#ifdef TOC_DEBUG
	  fprintf(stderr,
		  "Setting data_in_toc_offset for sym %d (%s) [h=%p] to %d\n",
		  sym, name, h, ret_val);
#endif
	}
      else
	{
	  ret_val = h->toc_offset;
#ifdef TOC_DEBUG
	  fprintf(stderr,
		  "data_in_toc_offset already set for sym %d (%s) [h=%p] to %d\n",
		  sym, name, h, ret_val);
#endif
	}
    }

  return ret_val;
}

#endif /* 0 */

#ifdef COFF_IMAGE_WITH_PE

d962 1
a962 1
  CHECK_EYE(h->eye_catcher);
a971 26
#if 0

/* Provided the symbol, returns the value reffed */
static long get_symbol_value PARAMS ((asymbol *));

static long
get_symbol_value (symbol)       
     asymbol *symbol;
{                                             
  long relocation = 0;

  if (bfd_is_com_section (symbol->section))
    {
      relocation = 0;                           
    }
  else 
    {                                      
      relocation = symbol->value +
	symbol->section->output_section->vma +
	  symbol->section->output_offset;
    }                                           

  return(relocation);
}

#endif /* 0 */
a1020 2
  fprintf(stderr, "pe_ppc_reloc (%s)\n", TARGET_LITTLE_NAME);

a1078 9
#ifdef DEBUG_RELOC
  fprintf(stderr, 
	  "pe_ppc_relocate_section (%s) for %s in bfd %s\n", 
	  TARGET_LITTLE_NAME,
	  input_section->name,
	  input_bfd->filename);
  
#endif  

a1103 17
#ifdef DEBUG_RELOC
      /* now examine flags */
      if (r_flags != 0) 
	{
	  fprintf (stderr, "Reloc with flags found!");
	  if ( r_flags & IMAGE_REL_PPC_NEG ) 
	    fprintf (stderr, " NEG");
	  if ( r_flags & IMAGE_REL_PPC_BRTAKEN )
	    fprintf (stderr, " BRTAKEN");
	  if ( r_flags & IMAGE_REL_PPC_BRNTAKEN )
	    fprintf (stderr, " BRNTAKEN");
	  if ( r_flags & IMAGE_REL_PPC_TOCDEFN )
	    fprintf (stderr, " TOCDEFN");
	  fprintf(stderr, "\n");
	}
#endif

d1121 1
a1121 1
	      CHECK_EYE(h->eye_catcher);
d1127 6
d1152 1
a1152 1
	  CHECK_EYE(h->eye_catcher);
a1163 2
fprintf(stderr,
	"missing %s\n",h->root.root.root.string);
d1177 3
a1179 3
	  fprintf( stderr, 
		  "ERROR: during reloc processing -- unsupported reloc %s\n", 
		  howto->name);
a1180 1
	  abort();
a1192 7
#ifdef TOC_DEBUG

		fprintf(stderr,
			"BFD of toc owner %p (%s), section addr of %s %p\n",
			 bfd_of_toc_owner, bfd_of_toc_owner->filename, 
			TOC_SECTION_NAME, toc_section);
#endif
d1196 1
a1196 1
		    fprintf(stderr, "No Toc section!\n");
a1226 6
#ifdef TOC_DEBUG

		    fprintf(stderr,
			    "Not writing out toc_offset of %d for %s\n", 
			    our_toc_offset, name);
#endif
d1231 4
a1234 11
		    record_toc(toc_section, our_toc_offset, priv, strdup(name));
#ifdef TOC_DEBUG
		    fprintf(stderr,
			    "Writing out toc_offset "
			    "toc_section (%p,%p)+%d val %d for %s\n", 
			    toc_section,
			    toc_section->contents,
			    our_toc_offset, 
			    val,
			    name);
#endif
a1250 5
#if 0
		  /* This is wrong. If tocdefn is on, we must unconditionally
		     assume the following path */
		    && IS_UNALLOCATED(our_toc_offset))
#endif
a1265 5
#ifdef DEBUG_RELOC
		    fprintf(stderr,
			    "TOCDEFN is on, (%s) (%p) our_toc_offset = %x\n", 
			    name, h, our_toc_offset);
#endif
a1270 5
#ifdef DEBUG_RELOC
		    fprintf(stderr,
			    "               our_toc_offset set to %x\n", our_toc_offset);
#endif

d1274 5
a1278 3
			fprintf(stderr,
				"TOCDEFN Relocation exceeded displacement of 65535\n");
			abort();
a1289 5
#ifdef TOC_DEBUG
		    fprintf(stderr,
			    "Not writing out toc_offset of %d for %s\n", 
			    our_toc_offset, name);
#endif
a1294 12
#ifdef TOC_DEBUG
		    /* write out the toc entry */
		    fprintf(stderr,
			    "Writing out toc_offset "
			    "toc_section (%p,%p)+%d val %d for %s\n", 
			    toc_section,
			    toc_section->contents,
			    our_toc_offset, 
			    val,
			    name);
#endif

a1321 4
#ifdef DEBUG_RELOC
		fprintf(stderr,
			"  Toc Section .reloc candidate addr = %x\n", addr);
#endif
d1330 6
a1335 3
		fprintf(stderr,
			"reloc offset is bigger than the toc size!\n");
		abort();
a1407 6
	    fprintf(stderr, 
		    "Warning: previously missed IMGLUE reloc %s <file %s, section %s>\n", 
		    howto->name,
		    bfd_get_filename(input_bfd),
		    input_section->name);
	    break;
d1409 5
a1414 1
	  break;
a1444 6
#ifdef DEBUG_RELOC
		fprintf(stderr,
			"first computation triggered fta %x, ts %d(%x), its %d(%x)\n",
			first_thunk_address, thunk_size, thunk_size, import_table_size,
			import_table_size);
#endif
d1473 1
a1473 1
			fprintf(stderr, "Missing idata magic cookies, this cannot work anyway...\n");
a1499 7
#ifdef DEBUG_RELOC

			fprintf(stderr,
				"second computation triggered fta %x, ts %d(%x), its %d(%x)\n",
				first_thunk_address, thunk_size, thunk_size, import_table_size,
				import_table_size);
#endif
a1548 3
#ifdef DEBUG_RELOC
		  bfd_vma before_addr = addr;
#endif
a1549 4
#ifdef DEBUG_RELOC
		  fprintf(stderr,
			  " adjusted down from %x to %x", before_addr, addr);
#endif
a1550 4
#ifdef DEBUG_RELOC
	      fprintf(stderr, "\n");
#endif

a1580 8
#if 0
	    else
	      {
		name = _bfd_coff_internal_syment_name (input_bfd, sym, buf);
		if (name == NULL)
		  return false;
	      }
#endif
a1586 8
#ifdef DEBUG_RELOC
		fprintf(stderr, 
			"pe_ppc_relocate_section (%s) for %s in bfd %s RETURNING TRUE\n", 
			TARGET_LITTLE_NAME,
			input_section->name,
			input_bfd->filename);
  
#endif  
a1593 9
#ifdef DEBUG_RELOC
  fprintf(stderr, 
	  "pe_ppc_relocate_section (%s) for %s in bfd %s RETURNING TRUE\n", 
	  TARGET_LITTLE_NAME,
	  input_section->name,
	  input_bfd->filename);
  
#endif  

d1677 1
a1677 2
      fprintf(stderr,
	      "There is no bfd that owns the toc section!\n");
d1684 1
a1684 1
      fprintf(stderr, "No Toc section!\n");
a1704 6
#ifdef DEBUG_RELOC
  fprintf(stderr, 
	  "ppc_process_before_allocation: BFD %s\n", 
	  bfd_get_filename(abfd));
#endif

a1719 9
    int toc_offset;

#ifdef DEBUG_RELOC
    fprintf(stderr, 
	    "  section %s reloc count %d\n", 
	    sec->name, 
	    sec->reloc_count);
#endif

d1734 1
a1735 17
#ifdef DEBUG_RELOC
	/* now examine flags */
	if (r_flags != 0) 
	  {
	    fprintf (stderr, "Reloc with flags found!");
	    if ( r_flags & IMAGE_REL_PPC_NEG ) 
	      fprintf (stderr, " NEG");
	    if ( r_flags & IMAGE_REL_PPC_BRTAKEN )
	      fprintf (stderr, " BRTAKEN");
	    if ( r_flags & IMAGE_REL_PPC_BRNTAKEN )
	      fprintf (stderr, " BRNTAKEN");
	    if ( r_flags & IMAGE_REL_PPC_TOCDEFN )
		fprintf (stderr, " TOCDEFN");
	    fprintf(stderr, "\n");
	  }
#endif
	
d1741 2
a1742 14
#if 0
	    /* FIXME:
	       This remains unimplemented for now, as it currently adds
	       un-necessary elements to the toc. All we need to do today
	       is not do anything if TOCDEFN is on.
	    */
	    if ( r_flags & IMAGE_REL_PPC_TOCDEFN )
	      toc_offset = ppc_record_data_in_toc_entry(abfd, info, sec, 
							rel->r_symndx, 
							default_toc);
	    else
	      toc_offset = ppc_record_toc_entry(abfd, info, sec, 
						rel->r_symndx, default_toc);
#endif
d1744 4
a1747 2
	      toc_offset = ppc_record_toc_entry(abfd, info, sec, 
						rel->r_symndx, default_toc);
d2014 1
a2014 6
    {
      fprintf(stderr, 
	      "ppc_coff_rtype2howto: reloc index %d out of range [%d, %ld]\n",
	      internal->r_type, 0, (long) MAX_RELOC_INDEX);
      abort();
    }
d2018 1
a2018 23
    {
      fprintf(stderr, 
	      "ppc_coff_rtype2howto: reloc index %d contains junk %d\n",
	      internal->r_type, junk);
      abort();
    }

#ifdef DEBUG_RELOC
  /* now examine flags */
  if (r_flags != 0) 
    {
      fprintf (stderr, "Reloc with flags found!");
      if ( r_flags & IMAGE_REL_PPC_NEG ) 
	fprintf (stderr, " NEG");
      if ( r_flags & IMAGE_REL_PPC_BRTAKEN )
	fprintf (stderr, " BRTAKEN");
      if ( r_flags & IMAGE_REL_PPC_BRNTAKEN )
	fprintf (stderr, " BRNTAKEN");
      if ( r_flags & IMAGE_REL_PPC_TOCDEFN )
	fprintf (stderr, " TOCDEFN");
      fprintf(stderr, "\n");
    }
#endif
d2085 1
a2085 6
    {
      fprintf(stderr, 
	      "coff_ppc_rtype_to_howto: index %d out of range [%d, %ld]\n",
	      r_type, 0, (long) MAX_RELOC_INDEX);
      abort();
    }
d2089 2
a2090 24
    {
      fprintf(stderr, 
	      "coff_ppc_rtype_to_howto: reloc index %d contains junk %d\n",
	      rel->r_type, junk);
      abort();
    }
  
#ifdef DEBUG_RELOC
  /* now examine flags */
  if (r_flags != 0) 
    {
      fprintf (stderr, "Reloc with flags found!");
      if ( r_flags & IMAGE_REL_PPC_NEG ) 
	fprintf (stderr, " NEG");
      if ( r_flags & IMAGE_REL_PPC_BRTAKEN )
	fprintf (stderr, " BRTAKEN");
      if ( r_flags & IMAGE_REL_PPC_BRNTAKEN )
	fprintf (stderr, " BRNTAKEN");
      if ( r_flags & IMAGE_REL_PPC_TOCDEFN )
	fprintf (stderr, " TOCDEFN");
      fprintf(stderr, "\n");
    }
#endif
  
a2143 6
  
#ifdef DEBUG_RELOC
  fprintf(stderr, "ppc_coff_reloc_type_lookup for %s\n",
	  bfd_get_reloc_code_name(code));
#endif

a2232 6
#ifdef TOC_DEBUG
      fprintf(stderr,
	      "ppc_coff_swap_sym_in_hook: about to create the %s section\n",
	      TOC_SECTION_NAME);
#endif

d2239 1
a2239 2
	  fprintf(stderr,
		  "toc section allocation failed!\n");
d2802 1
a2802 1
   HAS_SYMS | HAS_LOCALS | WP_TEXT),
d2855 1
a2855 1
   HAS_SYMS | HAS_LOCALS | WP_TEXT),
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.
d37 1
d54 17
d140 1
a140 1
      ret->toc_offset = 1;
d173 1
a173 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d259 2
d296 1
d304 1
d322 1
d330 1
a330 1

d719 19
a737 1
	 false)                 /* pcrel_offset */
d774 4
a777 2
   fprintf(stderr,"%s sym %d, r_vaddr %d\n", \
	   n, r->r_symndx, r->r_vaddr);      \
d803 7
d814 1
d823 1
a823 1
record_toc(toc_section, our_toc_offset, name)
d826 1
d831 3
a833 1
  t = malloc(sizeof(struct list_ele));
d837 1
d852 2
a862 6
  bfd_byte *t;
  bfd_byte *old_contents;
  asection *s;
  int element_size;
  int data;
  int offset;
a863 1
  struct coff_symbol_struct *target;
d888 3
d892 1
a892 2
	      bfd_set_error (bfd_error_no_memory);
	      return false;
a893 3
	  obj_coff_local_toc_table(abfd) = local_syms;
	  for (i = 0; i < obj_raw_syment_count(abfd); ++i)
	    local_syms[i] = 1;
d896 1
a896 1
      if (local_syms[sym] == 1) 
d901 9
d932 1
a932 1
      if (h->toc_offset == 1)
d937 9
d966 118
d1103 1
d1105 2
d1130 2
d1141 1
d1143 9
a1151 1
      && (howto->type != IMAGE_REL_PPC_IMGLUE);
d1154 2
a1175 1
  unsigned long insn;
a1176 1
  unsigned long unsigned_value;
a1177 2
  long signed_value;
  
a1178 1
  bfd_byte  *hit_data =addr + (bfd_byte *)(data);
d1216 2
d1242 1
a1242 1
	  "pe_ppc_relocate_section (%s) for %s \n", 
d1244 2
a1245 1
	  input_section->name);
a1272 1
      unsigned short junk    = EXTRACT_JUNK (rel->r_type);
d1345 2
d1380 3
a1382 2
			"BFD of toc owner %p, section addr of %s %p\n",
			 bfd_of_toc_owner, TOC_SECTION_NAME, toc_section);
a1391 11
#if 0
	    if ( r_flags & IMAGE_REL_PPC_TOCDEFN )
	      {
		/* Somehow, we are to assume that the toc has already been
		   done for this one, and the offset is the value of
		   the symbol? */
		fprintf(stderr,
			"Symbol value %d\n", val);
	      }
#endif

d1411 1
a1411 1
		if ((our_toc_offset & 1) != 0)
d1417 1
a1417 1
		    our_toc_offset &= ~1;
d1421 2
a1422 1
			    "Not writing out toc_offset of %d for %s\n", our_toc_offset, name);
d1428 1
a1428 1
		    record_toc(toc_section, our_toc_offset, strdup(name));
d1431 2
a1432 1
			    "Writing out toc_offset toc_section (%p,%p)+%d val %d for %s\n", 
d1444 1
a1444 1
		    local_toc_table[symndx] |= 1;
d1453 48
a1500 1
		if ((our_toc_offset & 1) != 0)
d1506 1
a1506 1
		    our_toc_offset &= ~1;
d1509 2
a1510 1
			    "Not writing out toc_offset of %d for %s\n", our_toc_offset, name);
d1515 1
a1515 1
		    record_toc(toc_section, our_toc_offset, strdup(name));
d1520 2
a1521 1
			    "Writing out toc_offset toc_section (%p,%p)+%d val %d for %s\n", 
d1534 1
a1534 1
		    h->toc_offset |= 1;
a1552 3
		fprintf(stderr,
			"  Toc Section reloc candidate\n");
		    
d1555 5
d1565 2
a1566 1
	    if (our_toc_offset > toc_section->_raw_size)
d1630 3
a1632 2
	    fprintf(stderr,"sym %d (%s), r_vaddr %d (%x)\n", 
		    rel->r_symndx, my_name, rel->r_vaddr, rel->r_vaddr);  
d1658 32
a1705 13
		else
		  abort();

		myh = 0;

		myh = coff_link_hash_lookup (coff_hash_table (info),
					     target,
					     false, false, true);
		if (myh == 0) 
		  {
		    fprintf(stderr, "Missing idata magic cookies, this cannot work anyway...\n");
		    abort();
		  }
d1707 1
a1707 3
		val = myh->root.u.def.value + 
		  sec->output_section->vma + sec->output_offset;
		if (first_thunk_address == 0)
d1709 1
a1709 8
		    int idata5offset;
		    myh = coff_link_hash_lookup (coff_hash_table (info),
						 "__idata5_magic__",
						 false, false, true);
		    first_thunk_address = myh->root.u.def.value + 
		      sec->output_section->vma + 
		      sec->output_offset - 
			pe_data(output_bfd)->pe_opthdr.ImageBase;
a1710 1
		    idata5offset = myh->root.u.def.value;
d1712 1
a1712 1
						 "__idata6_magic__",
d1714 30
d1745 6
a1750 5
		    thunk_size = myh->root.u.def.value - idata5offset;
		    myh = coff_link_hash_lookup (coff_hash_table (info),
						 "__idata4_magic__",
						 false, false, true);
		    import_table_size = myh->root.u.def.value;
d1762 10
a1772 1
	case IMAGE_REL_PPC_REL24:
d1799 3
d1803 1
d1805 2
a1806 1
			  " adjusted down to %d", addr);
d1808 1
d1810 1
d1855 11
a1865 1
	      return false;
d1871 9
d1883 1
d1886 1
a1886 1
long int global_toc_size = 0;
d1897 7
d1911 3
a1913 2
  fprintf(file, 
	  " Offset Offset   Name if present\n");
d1917 22
d1940 5
a1944 2
	      " %2x  %04lx    %s\n",
	      t->offset - 32768, t->offset, t->name);
d1946 2
a1957 6
#ifdef DEBUG_TOC
  fprintf(stderr,
	  "ppc_allocate_toc_section: allocating %s section of size %d\n",
	  TOC_SECTION_NAME, global_toc_size);
#endif

d1975 1
a1975 1
  foo = bfd_alloc(bfd_of_toc_owner, global_toc_size);
d1992 1
a1992 1
#if 0
d2014 1
a2035 1
	unsigned short junk    = EXTRACT_JUNK (rel->r_type);
d2059 17
a2075 2
	    toc_offset = ppc_record_toc_entry(abfd, info, sec, 
					      rel->r_symndx, default_toc);
d2085 2
d2117 2
d2144 2
d2199 2
d2229 2
d2335 1
a2335 1

d2344 2
a2345 2
	      "ppc_coff_rtype2howto: reloc index %d out of range [%d, %d]\n",
	      internal->r_type, 0, MAX_RELOC_INDEX);
a2379 1
    case IMAGE_REL_PPC_TOCREL16:
d2386 1
d2390 8
d2404 1
d2408 1
a2408 1
  relent->howto = ppc_coff_howto_table + r_type;
a2437 3
fprintf(stderr,
	"coff_ppc_rtype_to_howto\n");

d2442 2
a2443 2
	      "coff_ppc_rtype_to_howto: index %d out of range [%d, %d]\n",
	      r_type, 0, MAX_RELOC_INDEX);
d2478 8
a2489 1
    case IMAGE_REL_PPC_TOCREL16:
d2495 1
d2499 1
d2506 1
a2509 1
  howto = ppc_coff_howto_table + r_type;
d2531 1
a2531 1
  
d2534 1
d2540 1
a2543 2
      fprintf(stderr,
	      "\treturning NULL\n");
d2546 1
a2546 2
  
  return NULL;
d2566 1
d2583 14
a2602 1
  SYMENT *ext = (SYMENT *)ext1;
a2604 1
#if 0
a2606 1
#endif
a2611 1
      char *foo;
d2646 536
d3192 2
a3193 2
  false,			/* data byte order is little */
  false,			/* header byte order is little */
d3199 1
d3201 5
d3245 2
a3246 2
  true,				/* data byte order is big */
  true,				/* header byte order is big */
d3252 1
d3254 5
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a36 1

a52 17
/* The toc is a set of bfd_vma fields. We use the fact that valid         */
/* addresses are even (i.e. the bit representing "1" is off) to allow     */
/* us to encode a little extra information in the field                   */
/* - Unallocated addresses are intialized to 1.                           */
/* - Allocated addresses are even numbers.                                */
/* The first time we actually write a reference to the toc in the bfd,    */
/* we want to record that fact in a fixup file (if it is asked for), so   */
/* we keep track of whether or not an address has been written by marking */
/* the low order bit with a "1" upon writing                              */

#define SET_UNALLOCATED(x)  ((x) = 1)
#define IS_UNALLOCATED(x)   ((x) == 1)

#define IS_WRITTEN(x)       ((x) & 1)
#define MARK_AS_WRITTEN(x)  ((x) |= 1)
#define MAKE_ADDR_AGAIN(x)  ((x) &= ~1)

d122 1
a122 1
      SET_UNALLOCATED(ret->toc_offset);
d155 4
a158 1
    return NULL;
a243 2
/* This is essentially the same as tocrel16, with TOCDEFN assumed */
#define IMAGE_REL_PPC_TOCREL16_DEFN     0x0013
a278 1
#if 0
a285 1
#endif
a302 1
#if 0
d310 1
a310 1
#endif
d699 1
a699 19
	 false),                /* pcrel_offset */

  /* IMAGE_REL_PPC_TOCREL16_DEFN 0x0013 */
  /*   16-bit offset from TOC base, without causing a definition */
  /* Used: */
  HOWTO ( (IMAGE_REL_PPC_TOCREL16 | IMAGE_REL_PPC_TOCDEFN), /* type */ 
	 0,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_dont, /* complain_on_overflow */
	 0,                     /* special_function */                     
	 "TOCREL16, TOCDEFN",   /* name */
	 false,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
	 false),                /* pcrel_offset */

d736 2
a737 4
   fprintf(stderr,"%s sym %d, r_vaddr %d %s\n", \
	   n, r->r_symndx, r->r_vaddr,\
	   (((r->r_type) & IMAGE_REL_PPC_TOCDEFN) == 0) \
	   ?" ":" TOCDEFN"  );      \
a762 7
enum ref_category
{
  priv,
  pub,
  data
};

a766 1
  enum ref_category cat;
d775 1
a775 1
record_toc(toc_section, our_toc_offset, cat, name)
a777 1
     enum ref_category cat;
d782 1
a782 3
  t = (struct list_ele *) bfd_malloc (sizeof (struct list_ele));
  if (t == NULL)
    abort ();
a785 1
  t->cat = cat;
a799 2
#ifdef COFF_IMAGE_WITH_PE

d809 6
d816 1
d841 4
a844 1
	    return false;
d847 1
a847 3
	    {
	      SET_UNALLOCATED(local_syms[i]);
	    }
d850 1
a850 1
      if (IS_UNALLOCATED(local_syms[sym])) 
a854 9

	  /* The size must fit in a 16bit displacment */
	  if (global_toc_size >= 65535)
	    {
	      fprintf(stderr,
		      "Exceeded toc size of 65535\n");
	      abort();
	    }

d877 1
a877 1
      if (IS_UNALLOCATED(h->toc_offset))
a881 9

	  /* The size must fit in a 16bit displacment */
	  if (global_toc_size >= 65535)
	    {
	      fprintf(stderr,
		      "Exceeded toc size of 65535\n");
	      abort();
	    }

a901 118
#endif /* COFF_IMAGE_WITH_PE */

#if 0

/* FIXME: record a toc offset against a data-in-toc symbol */
/* Now, there is currenly some confusion on what this means. In some 
   compilers one sees the moral equivalent of:
      .tocd
      define some data
      .text
      refer to the data with a [tocv] qualifier
   In general, one sees something to indicate that a tocd has been
   seen, and that would trigger the allocation of data in toc. The IBM
   docs seem to suggest that anything with the TOCDEFN qualifier should
   never trigger storage allocation. However, in the kernel32.lib that 
   we've been using for our test bed, there are a couple of variables
   referenced that fail that test.

   So it can't work that way.
*/
static int
ppc_record_data_in_toc_entry(abfd, info, sec, sym, toc_kind)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     int sym;
     enum toc_type toc_kind;
{
  struct ppc_coff_link_hash_entry *h = 0;
  int ret_val;
  const char *name;

  int *local_syms;

  h = (struct ppc_coff_link_hash_entry *) (obj_coff_sym_hashes (abfd)[sym]);

  if (h == 0) 
    { 
      local_syms = obj_coff_local_toc_table(abfd);
      if (local_syms == 0)
	{
	  int i;
	  /* allocate a table */
	  local_syms = 
	    (int *) bfd_zalloc (abfd, 
				obj_raw_syment_count(abfd) * sizeof(int));
	  if (local_syms == 0)
	    return false;
	  obj_coff_local_toc_table(abfd) = local_syms;
	  for (i = 0; i < obj_raw_syment_count(abfd); ++i)
	    {
	      SET_UNALLOCATED(local_syms[i]);
	    }
	}

      if (IS_UNALLOCATED(local_syms[sym])) 
	{
	  local_syms[sym] = global_toc_size;
	  ret_val = global_toc_size;
	  global_toc_size += 4;
#ifdef TOC_DEBUG
	  fprintf(stderr,
		  "Setting data_in_toc_offset for local sym %d to %d\n",
		  sym, ret_val);
#endif
	}
      else
	{
	  ret_val = local_syms[sym];
#ifdef TOC_DEBUG
	  fprintf(stderr,
		  "data_in_toc_offset already set for local sym %d to %d\n",
		  sym, ret_val);
#endif
	}
    }
  else
    {
      CHECK_EYE(h->eye_catcher);

      name = h->root.root.root.string;

      /* check to see if there's a toc slot allocated. If not, do it
	 here. It will be used in relocate_section */
      if (IS_UNALLOCATED(h->toc_offset))
	{
#if 0
	  h->toc_offset = global_toc_size;
#endif
	  ret_val = global_toc_size;
	  /* We're allocating a chunk of the toc, as opposed to a slot */
	  /* FIXME: alignment? */
	  
	  global_toc_size += 4;
#ifdef TOC_DEBUG
	  fprintf(stderr,
		  "Setting data_in_toc_offset for sym %d (%s) [h=%p] to %d\n",
		  sym, name, h, ret_val);
#endif
	}
      else
	{
	  ret_val = h->toc_offset;
#ifdef TOC_DEBUG
	  fprintf(stderr,
		  "data_in_toc_offset already set for sym %d (%s) [h=%p] to %d\n",
		  sym, name, h, ret_val);
#endif
	}
    }

  return ret_val;
}

#endif /* 0 */

#ifdef COFF_IMAGE_WITH_PE

a920 1
#endif /* COFF_IMAGE_WITH_PE */
a921 2
#if 0

a944 2
#endif /* 0 */

a953 1
      && (howto->type != IMAGE_REL_PPC_ADDR32NB)
d955 1
a955 9
      && (howto->type != IMAGE_REL_PPC_IMGLUE)
      && (howto->type != IMAGE_REL_PPC_IFGLUE) 
      && (howto->type != IMAGE_REL_PPC_SECREL)
      && (howto->type != IMAGE_REL_PPC_SECTION)
      && (howto->type != IMAGE_REL_PPC_SECREL16)
      && (howto->type != IMAGE_REL_PPC_REFHI)
      && (howto->type != IMAGE_REL_PPC_REFLO)
      && (howto->type != IMAGE_REL_PPC_PAIR)
      && (howto->type != IMAGE_REL_PPC_TOCREL16_DEFN) ;
a957 2
#if 0

d978 1
d980 1
d982 2
d985 1
a1022 2
#endif /* 0 */

d1047 1
a1047 1
	  "pe_ppc_relocate_section (%s) for %s in bfd %s\n", 
d1049 1
a1049 2
	  input_section->name,
	  input_bfd->filename);
d1077 1
a1149 2
fprintf(stderr,
	"missing %s\n",h->root.root.root.string);
d1183 2
a1184 3
			"BFD of toc owner %p (%s), section addr of %s %p\n",
			 bfd_of_toc_owner, bfd_of_toc_owner->filename, 
			TOC_SECTION_NAME, toc_section);
d1194 11
d1224 1
a1224 1
		if (IS_WRITTEN(our_toc_offset))
d1230 1
a1230 1
		    MAKE_ADDR_AGAIN(our_toc_offset);
d1234 1
a1234 2
			    "Not writing out toc_offset of %d for %s\n", 
			    our_toc_offset, name);
d1240 1
a1240 1
		    record_toc(toc_section, our_toc_offset, priv, strdup(name));
d1243 1
a1243 2
			    "Writing out toc_offset "
			    "toc_section (%p,%p)+%d val %d for %s\n", 
d1255 1
a1255 1
		    MARK_AS_WRITTEN(local_toc_table[symndx]);
d1264 1
a1264 48
		if ((r_flags & IMAGE_REL_PPC_TOCDEFN) 
		    == IMAGE_REL_PPC_TOCDEFN )
#if 0
		  /* This is wrong. If tocdefn is on, we must unconditionally
		     assume the following path */
		    && IS_UNALLOCATED(our_toc_offset))
#endif
		  {
		    /* This is unbelievable cheese. Some knowledgable asm 
		       hacker has decided to use r2 as a base for loading 
		       a value. He/She does this by setting the tocdefn bit, 
		       and not supplying a toc definition. The behaviour is 
		       then to use the difference between the value of the 
		       symbol and the actual location of the toc as the toc 
		       index. 

		       In fact, what is usually happening is, because the
		       Import Address Table is mapped immediately following
		       the toc, some trippy library code trying for speed on
		       dll linkage, takes advantage of that and considers 
		       the IAT to be part of the toc, thus saving a load.
		    */
#ifdef DEBUG_RELOC
		    fprintf(stderr,
			    "TOCDEFN is on, (%s) (%p) our_toc_offset = %x\n", 
			    name, h, our_toc_offset);
#endif

		    our_toc_offset = val - 
		      (toc_section->output_section->vma + 
		       toc_section->output_offset);

#ifdef DEBUG_RELOC
		    fprintf(stderr,
			    "               our_toc_offset set to %x\n", our_toc_offset);
#endif

		    /* The size must still fit in a 16bit displacment */
		    if (our_toc_offset >= 65535)
		      {
			fprintf(stderr,
				"TOCDEFN Relocation exceeded displacement of 65535\n");
			abort();
		      }

		    record_toc(toc_section, our_toc_offset, pub, strdup(name));
		  }
		else if (IS_WRITTEN(our_toc_offset))
d1270 1
a1270 1
		    MAKE_ADDR_AGAIN(our_toc_offset);
d1273 1
a1273 2
			    "Not writing out toc_offset of %d for %s\n", 
			    our_toc_offset, name);
d1278 1
a1278 1
		    record_toc(toc_section, our_toc_offset, pub, strdup(name));
d1283 1
a1283 2
			    "Writing out toc_offset "
			    "toc_section (%p,%p)+%d val %d for %s\n", 
d1296 1
a1296 1
		    MARK_AS_WRITTEN(h->toc_offset);
d1315 3
a1319 5

#ifdef DEBUG_RELOC
		fprintf(stderr,
			"  Toc Section .reloc candidate addr = %x\n", addr);
#endif
d1325 1
a1325 2
	    if ( (r_flags & IMAGE_REL_PPC_TOCDEFN) != IMAGE_REL_PPC_TOCDEFN &&
		our_toc_offset > toc_section->_raw_size)
d1389 2
a1390 3
	    fprintf(stderr,"sym %ld (%s), r_vaddr %ld (%lx)\n", 
		    rel->r_symndx, my_name, (long) rel->r_vaddr,
		    (unsigned long) rel->r_vaddr);  
a1415 32

	    if (strncmp(".idata$2",input_section->name,8) == 0 && first_thunk_address == 0)
	      {
		/* set magic values */
		int idata5offset;
		struct coff_link_hash_entry *myh = 0;
		myh = coff_link_hash_lookup (coff_hash_table (info),
					     "__idata5_magic__",
					     false, false, true);
		first_thunk_address = myh->root.u.def.value + 
		  sec->output_section->vma + 
		    sec->output_offset - 
		      pe_data(output_bfd)->pe_opthdr.ImageBase;
		
		idata5offset = myh->root.u.def.value;
		myh = coff_link_hash_lookup (coff_hash_table (info),
					     "__idata6_magic__",
					     false, false, true);
		
		thunk_size = myh->root.u.def.value - idata5offset;
		myh = coff_link_hash_lookup (coff_hash_table (info),
					     "__idata4_magic__",
					     false, false, true);
		import_table_size = myh->root.u.def.value;
#ifdef DEBUG_RELOC
		fprintf(stderr,
			"first computation triggered fta %x, ts %d(%x), its %d(%x)\n",
			first_thunk_address, thunk_size, thunk_size, import_table_size,
			import_table_size);
#endif
	      }

d1432 13
d1446 3
a1448 1
		if (target != 0)
d1450 8
a1457 1
		    myh = 0;
d1459 1
d1461 1
a1461 1
						 target,
a1462 30
		    if (myh == 0) 
		      {
			fprintf(stderr, "Missing idata magic cookies, this cannot work anyway...\n");
			abort();
		      }
		    
		    val = myh->root.u.def.value + 
		      sec->output_section->vma + sec->output_offset;
		    if (first_thunk_address == 0)
		      {
			int idata5offset;
			myh = coff_link_hash_lookup (coff_hash_table (info),
						     "__idata5_magic__",
						     false, false, true);
			first_thunk_address = myh->root.u.def.value + 
			  sec->output_section->vma + 
			    sec->output_offset - 
			      pe_data(output_bfd)->pe_opthdr.ImageBase;
			
			idata5offset = myh->root.u.def.value;
			myh = coff_link_hash_lookup (coff_hash_table (info),
						     "__idata6_magic__",
						     false, false, true);
			
			thunk_size = myh->root.u.def.value - idata5offset;
			myh = coff_link_hash_lookup (coff_hash_table (info),
						     "__idata4_magic__",
						     false, false, true);
			import_table_size = myh->root.u.def.value;
#ifdef DEBUG_RELOC
d1464 5
a1468 6
			fprintf(stderr,
				"second computation triggered fta %x, ts %d(%x), its %d(%x)\n",
				first_thunk_address, thunk_size, thunk_size, import_table_size,
				import_table_size);
#endif
		      }
d1480 1
a1481 10
	  DUMP_RELOC2(howto->name, rel);
	  val -= (input_section->output_section->vma
		  + input_section->output_offset);

	  rstat = _bfd_relocate_contents (howto,
					  input_bfd, 
					  val, 
					  loc);
	  break;
	case IMAGE_REL_PPC_ADDR16:
a1507 3
#ifdef DEBUG_RELOC
		  bfd_vma before_addr = addr;
#endif
a1508 1
#ifdef DEBUG_RELOC
d1510 1
a1510 2
			  " adjusted down from %x to %x", before_addr, addr);
#endif
a1511 1
#ifdef DEBUG_RELOC
a1512 1
#endif
d1557 1
a1557 11
	      {
#ifdef DEBUG_RELOC
		fprintf(stderr, 
			"pe_ppc_relocate_section (%s) for %s in bfd %s RETURNING TRUE\n", 
			TARGET_LITTLE_NAME,
			input_section->name,
			input_bfd->filename);
  
#endif  
		return false;
	      }
a1562 9
#ifdef DEBUG_RELOC
  fprintf(stderr, 
	  "pe_ppc_relocate_section (%s) for %s in bfd %s RETURNING TRUE\n", 
	  TARGET_LITTLE_NAME,
	  input_section->name,
	  input_bfd->filename);
  
#endif  

a1565 1

d1568 1
a1568 1
long int global_toc_size = 4;
a1578 7
static char *
h1 = "\n\t\t\tTOC MAPPING\n\n";
static char *
h2 = " TOC    disassembly  Comments       Name\n";
static char *
h3 = " Offset  spelling                   (if present)\n";

d1586 2
a1587 3
  fprintf(file, h1);
  fprintf(file, h2);
  fprintf(file, h3);
a1590 22
      char *cat;

      if (t->cat == priv)
	cat = "private       ";
      else if (t->cat == pub)
	cat = "public        ";
      else if (t->cat == data)
	cat = "data-in-toc   ";

      if (t->offset > global_toc_size)
	{
	  if (t->offset <= global_toc_size + thunk_size)
	    cat = "IAT reference ";
	  else
	    {
	      fprintf(file,
		      "**** global_toc_size %ld(%lx), thunk_size %ld(%lx)\n",
		      global_toc_size, global_toc_size, thunk_size, thunk_size);
	      cat = "Out of bounds!";
	    }
	}

d1592 2
a1593 5
	      " %04lx    (%d)", (unsigned long) t->offset, t->offset - 32768);
      fprintf(file,
	      "    %s %s\n",
	      cat, t->name);

a1594 2

  fprintf(file, "\n");
d1605 6
d1628 1
a1628 1
  foo = (bfd_byte *) bfd_alloc(bfd_of_toc_owner, global_toc_size);
d1645 1
a1645 1
#ifdef DEBUG_RELOC
a1666 1

d1688 1
d1712 2
a1713 17
#if 0
	    /* FIXME:
	       This remains unimplemented for now, as it currently adds
	       un-necessary elements to the toc. All we need to do today
	       is not do anything if TOCDEFN is on.
	    */
	    if ( r_flags & IMAGE_REL_PPC_TOCDEFN )
	      toc_offset = ppc_record_data_in_toc_entry(abfd, info, sec, 
							rel->r_symndx, 
							default_toc);
	    else
	      toc_offset = ppc_record_toc_entry(abfd, info, sec, 
						rel->r_symndx, default_toc);
#endif
	    if ( (r_flags & IMAGE_REL_PPC_TOCDEFN) != IMAGE_REL_PPC_TOCDEFN )
	      toc_offset = ppc_record_toc_entry(abfd, info, sec, 
						rel->r_symndx, default_toc);
a1722 2

  return true;
a1752 2
#if 0

a1777 2
#endif

a1830 2
#if 0

a1858 2
#endif

d1963 1
a1963 1
  reloc_howto_type *howto;
d1972 2
a1973 2
	      "ppc_coff_rtype2howto: reloc index %d out of range [%d, %ld]\n",
	      internal->r_type, 0, (long) MAX_RELOC_INDEX);
d2008 1
a2014 1
      howto = ppc_coff_howto_table + r_type;
a2017 8
      howto = ppc_coff_howto_table + r_type;
      break;
    case IMAGE_REL_PPC_TOCREL16:
      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, internal);
      if (r_flags & IMAGE_REL_PPC_TOCDEFN)
	howto = ppc_coff_howto_table + IMAGE_REL_PPC_TOCREL16_DEFN;
      else
	howto = ppc_coff_howto_table + IMAGE_REL_PPC_TOCREL16;
a2023 1
      howto = ppc_coff_howto_table + r_type;      
d2027 1
a2027 1
  relent->howto = howto;
d2057 3
d2064 2
a2065 2
	      "coff_ppc_rtype_to_howto: index %d out of range [%d, %ld]\n",
	      r_type, 0, (long) MAX_RELOC_INDEX);
a2099 8
      howto = ppc_coff_howto_table + r_type;
      break;
    case IMAGE_REL_PPC_TOCREL16:
      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, rel);
      if (r_flags & IMAGE_REL_PPC_TOCDEFN)
	howto = ppc_coff_howto_table + IMAGE_REL_PPC_TOCREL16_DEFN;
      else
	howto = ppc_coff_howto_table + IMAGE_REL_PPC_TOCREL16;
d2104 1
a2109 1
      howto = ppc_coff_howto_table + r_type;
a2112 1
      howto = ppc_coff_howto_table + r_type;
a2118 1
      howto = ppc_coff_howto_table + r_type;
d2122 1
d2144 1
a2144 1

a2146 1
      HOW2MAP(BFD_RELOC_32_GOTOFF,    IMAGE_REL_PPC_IMGLUE);
a2151 1
      HOW2MAP(BFD_RELOC_16_GOTOFF,    IMAGE_REL_PPC_TOCREL16_DEFN);
d2155 2
d2159 2
a2160 1
  /*NOTREACHED*/
a2179 1
#define coff_bfd_final_link          ppc_bfd_coff_final_link 
a2195 14
/* FIXME:
   What we're trying to do here is allocate a toc section (early), and attach 
   it to the last bfd to be processed. This avoids the problem of having a toc
   written out before all files have been processed. This code allocates
   a toc section for every file, and records the last one seen. There are
   at least two problems with this approach:
   1. We allocate whole bunches of toc sections that are ignored, but at
      at least we will not allocate a toc if no .toc is present.
   2. It's not clear to me that being the last bfd read necessarily means
      that you are the last bfd closed.
   3. Doing it on a "swap in" hook depends on when the "swap in" is called,
      and how often, etc. It's not clear to me that there isn't a hole here.
*/

d2202 1
d2205 1
d2208 1
d2214 1
a2248 536
boolean
ppc_bfd_coff_final_link ();

#ifndef COFF_IMAGE_WITH_PE

static boolean
ppc_do_last(abfd)
     bfd *abfd;
{
  if (abfd == bfd_of_toc_owner)
    return true;
  else
    return false;
}

static bfd *
ppc_get_last()
{
  return bfd_of_toc_owner;
}

/* this piece of machinery exists only to guarantee that the bfd that holds
   the toc section is written last. 

   This does depend on bfd_make_section attaching a new section to the
   end of the section list for the bfd. 

   This is otherwise intended to be functionally the same as 
   cofflink.c:_bfd_coff_final_link(). It is specifically different only 
   where the POWERPC_LE_PE macro modifies the code. It is left in as a 
   precise form of comment. krk@@cygnus.com
*/
#define POWERPC_LE_PE


/* Do the final link step.  */

boolean
ppc_bfd_coff_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  bfd_size_type symesz;
  struct coff_final_link_info finfo;
  boolean debug_merge_allocated;
  asection *o;
  struct bfd_link_order *p;
  size_t max_sym_count;
  size_t max_lineno_count;
  size_t max_reloc_count;
  size_t max_output_reloc_count;
  size_t max_contents_size;
  file_ptr rel_filepos;
  unsigned int relsz;
  file_ptr line_filepos;
  unsigned int linesz;
  bfd *sub;
  bfd_byte *external_relocs = NULL;
  char strbuf[STRING_SIZE_SIZE];

  symesz = bfd_coff_symesz (abfd);

  finfo.info = info;
  finfo.output_bfd = abfd;
  finfo.strtab = NULL;
  finfo.section_info = NULL;
  finfo.last_file_index = -1;
  finfo.last_bf_index = -1;
  finfo.internal_syms = NULL;
  finfo.sec_ptrs = NULL;
  finfo.sym_indices = NULL;
  finfo.outsyms = NULL;
  finfo.linenos = NULL;
  finfo.contents = NULL;
  finfo.external_relocs = NULL;
  finfo.internal_relocs = NULL;
  debug_merge_allocated = false;

  coff_data (abfd)->link_info = info;

  finfo.strtab = _bfd_stringtab_init ();
  if (finfo.strtab == NULL)
    goto error_return;

  if (! coff_debug_merge_hash_table_init (&finfo.debug_merge))
    goto error_return;
  debug_merge_allocated = true;

  /* Compute the file positions for all the sections.  */
  if (! abfd->output_has_begun)
    bfd_coff_compute_section_file_positions (abfd);

  /* Count the line numbers and relocation entries required for the
     output file.  Set the file positions for the relocs.  */
  rel_filepos = obj_relocbase (abfd);
  relsz = bfd_coff_relsz (abfd);
  max_contents_size = 0;
  max_lineno_count = 0;
  max_reloc_count = 0;

  for (o = abfd->sections; o != NULL; o = o->next)
    {
      o->reloc_count = 0;
      o->lineno_count = 0;
      for (p = o->link_order_head; p != NULL; p = p->next)
	{

	  if (p->type == bfd_indirect_link_order)
	    {
	      asection *sec;

	      sec = p->u.indirect.section;

	      /* Mark all sections which are to be included in the
		 link.  This will normally be every section.  We need
		 to do this so that we can identify any sections which
		 the linker has decided to not include.  */
	      sec->linker_mark = true;

	      if (info->strip == strip_none
		  || info->strip == strip_some)
		o->lineno_count += sec->lineno_count;

	      if (info->relocateable)
		o->reloc_count += sec->reloc_count;

	      if (sec->_raw_size > max_contents_size)
		max_contents_size = sec->_raw_size;
	      if (sec->lineno_count > max_lineno_count)
		max_lineno_count = sec->lineno_count;
	      if (sec->reloc_count > max_reloc_count)
		max_reloc_count = sec->reloc_count;
	    }
	  else if (info->relocateable
		   && (p->type == bfd_section_reloc_link_order
		       || p->type == bfd_symbol_reloc_link_order))
	    ++o->reloc_count;
	}
      if (o->reloc_count == 0)
	o->rel_filepos = 0;
      else
	{
	  o->flags |= SEC_RELOC;
	  o->rel_filepos = rel_filepos;
	  rel_filepos += o->reloc_count * relsz;
	}
    }

  /* If doing a relocateable link, allocate space for the pointers we
     need to keep.  */
  if (info->relocateable)
    {
      unsigned int i;

      /* We use section_count + 1, rather than section_count, because
         the target_index fields are 1 based.  */
      finfo.section_info =
	((struct coff_link_section_info *)
	 bfd_malloc ((abfd->section_count + 1)
		     * sizeof (struct coff_link_section_info)));
      if (finfo.section_info == NULL)
	goto error_return;
      for (i = 0; i <= abfd->section_count; i++)
	{
	  finfo.section_info[i].relocs = NULL;
	  finfo.section_info[i].rel_hashes = NULL;
	}
    }

  /* We now know the size of the relocs, so we can determine the file
     positions of the line numbers.  */
  line_filepos = rel_filepos;
  linesz = bfd_coff_linesz (abfd);
  max_output_reloc_count = 0;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if (o->lineno_count == 0)
	o->line_filepos = 0;
      else
	{
	  o->line_filepos = line_filepos;
	  line_filepos += o->lineno_count * linesz;
	}

      if (o->reloc_count != 0)
	{
	  /* We don't know the indices of global symbols until we have
             written out all the local symbols.  For each section in
             the output file, we keep an array of pointers to hash
             table entries.  Each entry in the array corresponds to a
             reloc.  When we find a reloc against a global symbol, we
             set the corresponding entry in this array so that we can
             fix up the symbol index after we have written out all the
             local symbols.

	     Because of this problem, we also keep the relocs in
	     memory until the end of the link.  This wastes memory,
	     but only when doing a relocateable link, which is not the
	     common case.  */
	  BFD_ASSERT (info->relocateable);
	  finfo.section_info[o->target_index].relocs =
	    ((struct internal_reloc *)
	     bfd_malloc (o->reloc_count * sizeof (struct internal_reloc)));
	  finfo.section_info[o->target_index].rel_hashes =
	    ((struct coff_link_hash_entry **)
	     bfd_malloc (o->reloc_count
		     * sizeof (struct coff_link_hash_entry *)));
	  if (finfo.section_info[o->target_index].relocs == NULL
	      || finfo.section_info[o->target_index].rel_hashes == NULL)
	    goto error_return;

	  if (o->reloc_count > max_output_reloc_count)
	    max_output_reloc_count = o->reloc_count;
	}

      /* Reset the reloc and lineno counts, so that we can use them to
	 count the number of entries we have output so far.  */
      o->reloc_count = 0;
      o->lineno_count = 0;
    }

  obj_sym_filepos (abfd) = line_filepos;

  /* Figure out the largest number of symbols in an input BFD.  Take
     the opportunity to clear the output_has_begun fields of all the
     input BFD's.  */
  max_sym_count = 0;
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      size_t sz;

      sub->output_has_begun = false;
      sz = obj_raw_syment_count (sub);
      if (sz > max_sym_count)
	max_sym_count = sz;
    }

  /* Allocate some buffers used while linking.  */
  finfo.internal_syms = ((struct internal_syment *)
			 bfd_malloc (max_sym_count
				     * sizeof (struct internal_syment)));
  finfo.sec_ptrs = (asection **) bfd_malloc (max_sym_count
					     * sizeof (asection *));
  finfo.sym_indices = (long *) bfd_malloc (max_sym_count * sizeof (long));
  finfo.outsyms = ((bfd_byte *)
		   bfd_malloc ((size_t) ((max_sym_count + 1) * symesz)));
  finfo.linenos = (bfd_byte *) bfd_malloc (max_lineno_count
				       * bfd_coff_linesz (abfd));
  finfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
  finfo.external_relocs = (bfd_byte *) bfd_malloc (max_reloc_count * relsz);
  if (! info->relocateable)
    finfo.internal_relocs = ((struct internal_reloc *)
			     bfd_malloc (max_reloc_count
					 * sizeof (struct internal_reloc)));
  if ((finfo.internal_syms == NULL && max_sym_count > 0)
      || (finfo.sec_ptrs == NULL && max_sym_count > 0)
      || (finfo.sym_indices == NULL && max_sym_count > 0)
      || finfo.outsyms == NULL
      || (finfo.linenos == NULL && max_lineno_count > 0)
      || (finfo.contents == NULL && max_contents_size > 0)
      || (finfo.external_relocs == NULL && max_reloc_count > 0)
      || (! info->relocateable
	  && finfo.internal_relocs == NULL
	  && max_reloc_count > 0))
    goto error_return;

  /* We now know the position of everything in the file, except that
     we don't know the size of the symbol table and therefore we don't
     know where the string table starts.  We just build the string
     table in memory as we go along.  We process all the relocations
     for a single input file at once.  */
  obj_raw_syment_count (abfd) = 0;

  if (coff_backend_info (abfd)->_bfd_coff_start_final_link)
    {
      if (! bfd_coff_start_final_link (abfd, info))
	goto error_return;
    }

  for (o = abfd->sections; o != NULL; o = o->next)
    {
      for (p = o->link_order_head; p != NULL; p = p->next)
	{
	  if (p->type == bfd_indirect_link_order
	      && (bfd_get_flavour (p->u.indirect.section->owner)
		  == bfd_target_coff_flavour))
	    {
	      sub = p->u.indirect.section->owner;
#ifdef POWERPC_LE_PE
	      if (! sub->output_has_begun && !ppc_do_last(sub))
#else
	      if (! sub->output_has_begun)
#endif
		{
		  if (! _bfd_coff_link_input_bfd (&finfo, sub))
		    goto error_return;
		  sub->output_has_begun = true;
		}
	    }
	  else if (p->type == bfd_section_reloc_link_order
		   || p->type == bfd_symbol_reloc_link_order)
	    {
	      if (! _bfd_coff_reloc_link_order (abfd, &finfo, o, p))
		goto error_return;
	    }
	  else
	    {
	      if (! _bfd_default_link_order (abfd, info, o, p))
		goto error_return;
	    }
	}
    }

#ifdef POWERPC_LE_PE
  {
    extern bfd* ppc_get_last();
    bfd* last_one = ppc_get_last();
    if (last_one)
      {
	if (! _bfd_coff_link_input_bfd (&finfo, last_one))
	  goto error_return;
      }
    last_one->output_has_begun = true;
  }
#endif

  /* Free up the buffers used by _bfd_coff_link_input_bfd.  */

  coff_debug_merge_hash_table_free (&finfo.debug_merge);
  debug_merge_allocated = false;

  if (finfo.internal_syms != NULL)
    {
      free (finfo.internal_syms);
      finfo.internal_syms = NULL;
    }
  if (finfo.sec_ptrs != NULL)
    {
      free (finfo.sec_ptrs);
      finfo.sec_ptrs = NULL;
    }
  if (finfo.sym_indices != NULL)
    {
      free (finfo.sym_indices);
      finfo.sym_indices = NULL;
    }
  if (finfo.linenos != NULL)
    {
      free (finfo.linenos);
      finfo.linenos = NULL;
    }
  if (finfo.contents != NULL)
    {
      free (finfo.contents);
      finfo.contents = NULL;
    }
  if (finfo.external_relocs != NULL)
    {
      free (finfo.external_relocs);
      finfo.external_relocs = NULL;
    }
  if (finfo.internal_relocs != NULL)
    {
      free (finfo.internal_relocs);
      finfo.internal_relocs = NULL;
    }

  /* The value of the last C_FILE symbol is supposed to be the symbol
     index of the first external symbol.  Write it out again if
     necessary.  */
  if (finfo.last_file_index != -1
      && (unsigned int) finfo.last_file.n_value != obj_raw_syment_count (abfd))
    {
      finfo.last_file.n_value = obj_raw_syment_count (abfd);
      bfd_coff_swap_sym_out (abfd, (PTR) &finfo.last_file,
			     (PTR) finfo.outsyms);
      if (bfd_seek (abfd,
		    (obj_sym_filepos (abfd)
		     + finfo.last_file_index * symesz),
		    SEEK_SET) != 0
	  || bfd_write (finfo.outsyms, symesz, 1, abfd) != symesz)
	return false;
    }

  /* Write out the global symbols.  */
  finfo.failed = false;
  coff_link_hash_traverse (coff_hash_table (info), _bfd_coff_write_global_sym,
			   (PTR) &finfo);
  if (finfo.failed)
    goto error_return;

  /* The outsyms buffer is used by _bfd_coff_write_global_sym.  */
  if (finfo.outsyms != NULL)
    {
      free (finfo.outsyms);
      finfo.outsyms = NULL;
    }

  if (info->relocateable)
    {
      /* Now that we have written out all the global symbols, we know
	 the symbol indices to use for relocs against them, and we can
	 finally write out the relocs.  */
      external_relocs = ((bfd_byte *)
			 bfd_malloc (max_output_reloc_count * relsz));
      if (external_relocs == NULL)
	goto error_return;

      for (o = abfd->sections; o != NULL; o = o->next)
	{
	  struct internal_reloc *irel;
	  struct internal_reloc *irelend;
	  struct coff_link_hash_entry **rel_hash;
	  bfd_byte *erel;

	  if (o->reloc_count == 0)
	    continue;

	  irel = finfo.section_info[o->target_index].relocs;
	  irelend = irel + o->reloc_count;
	  rel_hash = finfo.section_info[o->target_index].rel_hashes;
	  erel = external_relocs;
	  for (; irel < irelend; irel++, rel_hash++, erel += relsz)
	    {
	      if (*rel_hash != NULL)
		{
		  BFD_ASSERT ((*rel_hash)->indx >= 0);
		  irel->r_symndx = (*rel_hash)->indx;
		}
	      bfd_coff_swap_reloc_out (abfd, (PTR) irel, (PTR) erel);
	    }

	  if (bfd_seek (abfd, o->rel_filepos, SEEK_SET) != 0
	      || bfd_write ((PTR) external_relocs, relsz, o->reloc_count,
			    abfd) != relsz * o->reloc_count)
	    goto error_return;
	}

      free (external_relocs);
      external_relocs = NULL;
    }

  /* Free up the section information.  */
  if (finfo.section_info != NULL)
    {
      unsigned int i;

      for (i = 0; i < abfd->section_count; i++)
	{
	  if (finfo.section_info[i].relocs != NULL)
	    free (finfo.section_info[i].relocs);
	  if (finfo.section_info[i].rel_hashes != NULL)
	    free (finfo.section_info[i].rel_hashes);
	}
      free (finfo.section_info);
      finfo.section_info = NULL;
    }

  /* If we have optimized stabs strings, output them.  */
  if (coff_hash_table (info)->stab_info != NULL)
    {
      if (! _bfd_write_stab_strings (abfd, &coff_hash_table (info)->stab_info))
	return false;
    }

  /* Write out the string table.  */
  if (obj_raw_syment_count (abfd) != 0)
    {
      if (bfd_seek (abfd,
		    (obj_sym_filepos (abfd)
		     + obj_raw_syment_count (abfd) * symesz),
		    SEEK_SET) != 0)
	return false;

#if STRING_SIZE_SIZE == 4
      bfd_h_put_32 (abfd,
		    _bfd_stringtab_size (finfo.strtab) + STRING_SIZE_SIZE,
		    (bfd_byte *) strbuf);
#else
 #error Change bfd_h_put_32
#endif

      if (bfd_write (strbuf, 1, STRING_SIZE_SIZE, abfd) != STRING_SIZE_SIZE)
	return false;

      if (! _bfd_stringtab_emit (abfd, finfo.strtab))
	return false;
    }

  _bfd_stringtab_free (finfo.strtab);

  /* Setting bfd_get_symcount to 0 will cause write_object_contents to
     not try to write out the symbols.  */
  bfd_get_symcount (abfd) = 0;

  return true;

 error_return:
  if (debug_merge_allocated)
    coff_debug_merge_hash_table_free (&finfo.debug_merge);
  if (finfo.strtab != NULL)
    _bfd_stringtab_free (finfo.strtab);
  if (finfo.section_info != NULL)
    {
      unsigned int i;

      for (i = 0; i < abfd->section_count; i++)
	{
	  if (finfo.section_info[i].relocs != NULL)
	    free (finfo.section_info[i].relocs);
	  if (finfo.section_info[i].rel_hashes != NULL)
	    free (finfo.section_info[i].rel_hashes);
	}
      free (finfo.section_info);
    }
  if (finfo.internal_syms != NULL)
    free (finfo.internal_syms);
  if (finfo.sec_ptrs != NULL)
    free (finfo.sec_ptrs);
  if (finfo.sym_indices != NULL)
    free (finfo.sym_indices);
  if (finfo.outsyms != NULL)
    free (finfo.outsyms);
  if (finfo.linenos != NULL)
    free (finfo.linenos);
  if (finfo.contents != NULL)
    free (finfo.contents);
  if (finfo.external_relocs != NULL)
    free (finfo.external_relocs);
  if (finfo.internal_relocs != NULL)
    free (finfo.internal_relocs);
  if (external_relocs != NULL)
    free (external_relocs);
  return false;
}
#endif
d2259 2
a2260 2
  BFD_ENDIAN_LITTLE,		/* data byte order is little */
  BFD_ENDIAN_LITTLE,		/* header byte order is little */
a2265 1
#ifndef COFF_WITH_PE
a2266 5
#else
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC /* section flags */
   | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),
#endif

d2306 2
a2307 2
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */
a2312 1
#ifndef COFF_WITH_PE
a2313 5
#else
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC /* section flags */
   | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),
#endif

@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a70 27

/* Turn on this check if you suspect something amiss in the hash tables */
#ifdef DEBUG_HASH

/* Need a 7 char string for an eye catcher */
#define EYE "krkjunk"

#define HASH_CHECK_DCL char eye_catcher[8];
#define HASH_CHECK_INIT(ret)      strcpy(ret->eye_catcher, EYE)
#define HASH_CHECK(addr) \
 if (strcmp(addr->eye_catcher, EYE) != 0) \
  { \
    fprintf(stderr,\
    "File %s, line %d, Hash check failure, bad eye %8s\n", \
    __FILE__, __LINE__, addr->eye_catcher); \
    abort(); \
 }


#else

#define HASH_CHECK_DCL
#define HASH_CHECK_INIT(ret)
#define HASH_CHECK(addr)

#endif

d85 1
a85 2

  HASH_CHECK_DCL
d88 11
d143 1
a143 2

      HASH_CHECK_INIT(ret);
d189 2
a190 2
/* use the complete range of a 16-bit displacement. We have to adjust */
/* for this when we fix up loads displaced off the toc reg.           */
d855 1
a855 1
static boolean
d864 1
d874 1
a874 1
      HASH_CHECK(h);
d899 1
d903 1
a903 1
	  if (global_toc_size > 65535)
d905 3
a907 3
	      (*_bfd_error_handler) ("TOC overflow");
	      bfd_set_error (bfd_error_file_too_big);
	      return false;
d909 15
d935 1
d941 3
a943 3
	      (*_bfd_error_handler) ("TOC overflow");
	      bfd_set_error (bfd_error_file_too_big);
	      return false;
d945 15
d963 115
a1077 1
  return true;
d1080 4
d1095 1
a1095 1
  HASH_CHECK(h);
d1105 26
d1180 2
d1240 9
d1274 17
d1308 1
a1308 1
	      HASH_CHECK(h);
a1313 6
      if (r_type == IMAGE_REL_PPC_IMGLUE && h == 0)
	{
	  /* An IMGLUE reloc must have a name. Something is very wrong. */
	  abort();
	}

d1333 1
a1333 1
	  HASH_CHECK(h);
d1345 2
d1360 3
a1362 3
	  (*_bfd_error_handler)
	    ("%s: unsupported relocation type 0x%02x",
	     bfd_get_filename (input_bfd), r_type);
d1364 1
d1377 7
d1387 1
a1387 1
		    /* There is no toc section. Something is very wrong. */
d1418 6
d1428 11
a1438 4
		    record_toc(toc_section, 
			       our_toc_offset, 
			       priv, 
			       strdup(name));
d1455 5
d1475 5
d1485 5
d1493 3
a1495 5
			(*_bfd_error_handler)
			  ("%s: Relocation for %s of %x exceeds Toc size limit", 
			   bfd_get_filename (input_bfd), name, our_toc_offset);
			bfd_set_error (bfd_error_bad_value);
			return false;
d1507 5
d1517 12
d1556 4
d1568 3
a1570 6
		(*_bfd_error_handler)
		  ("%s: Relocation exceeds allocated TOC (%x)", 
		   bfd_get_filename (input_bfd),
		   toc_section->_raw_size);
		bfd_set_error (bfd_error_bad_value);
		return false;
d1643 6
a1649 5
	    (*_bfd_error_handler)
	      ("%s: Out of order IMGLUE reloc for %s", 
	       bfd_get_filename (input_bfd), my_name);
	    bfd_set_error (bfd_error_bad_value);
	    return false;
d1651 1
d1682 6
d1716 1
a1716 1
			/* Missing magic cookies. Something is very wrong. */
d1743 7
d1799 3
d1803 4
d1808 4
d1842 8
d1856 8
d1871 9
d1963 2
a1964 1
      /* No toc owner? Something is very wrong. */
d1971 1
a1971 1
      /* No toc section? Something is very wrong. */
d1992 6
d2013 9
a2035 1
	boolean ok = true;
d2037 17
d2059 14
a2072 2
	    /* if TOCDEFN is on, ignore as someone else has allocated the
	       toc entry */
d2074 2
a2075 4
	      ok = ppc_record_toc_entry(abfd, info, sec, 
					rel->r_symndx, default_toc);
	    if (!ok)
	      return false;
d2342 6
a2347 1
    abort();
d2351 23
a2373 1
    abort();
d2440 6
a2445 1
    abort();
d2449 24
a2472 2
    abort();
    
d2526 6
d2621 6
d2633 2
a2634 1
	  /* FIXME: set appropriate bfd error */
d3197 1
a3197 1
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
d3250 1
a3250 1
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d39 1
a53 6
/* This file is compiled more than once, but we only compile the
   final_link routine once.  */
extern boolean ppc_bfd_coff_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
extern void dump_toc PARAMS ((PTR));

a126 14
static boolean ppc_coff_link_hash_table_init
  PARAMS ((struct ppc_coff_link_hash_table *, bfd *,
	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
				       struct bfd_hash_table *,
				       const char *)));
static struct bfd_link_hash_table *ppc_coff_link_hash_table_create
  PARAMS ((bfd *));
static boolean coff_ppc_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   struct internal_reloc *, struct internal_syment *, asection **));
static reloc_howto_type *coff_ppc_rtype_to_howto
  PARAMS ((bfd *, asection *, struct internal_reloc *,
	   struct coff_link_hash_entry *, struct internal_syment *,
	   bfd_vma *));
a806 4

/* This file is compiled twice, and these variables are defined in one
   of the compilations.  FIXME: This is confusing and weird.  Also,
   BFD should not use global variables.  */
a839 3
static void record_toc
  PARAMS ((asection *, int, enum ref_category, const char *));

d841 1
a841 1
record_toc (toc_section, our_toc_offset, cat, name)
a871 5
static boolean ppc_record_toc_entry
  PARAMS ((bfd *, struct bfd_link_info *, asection *, int, enum toc_type));
static void ppc_mark_symbol_as_glue
  PARAMS ((bfd *, int, struct internal_reloc *));

d1597 1
a1599 4
/* FIXME: BFD should not use global variables.  This file is compiled
   twice, and these variables are shared.  This is confusing and
   weird.  */

d1619 2
a1620 2
dump_toc (vfile)
     PTR vfile;
d2169 2
a2170 1
static void ppc_coff_swap_sym_in_hook PARAMS ((bfd *, PTR, PTR));
d2251 3
a2255 3
static boolean ppc_do_last PARAMS ((bfd *));
static bfd *ppc_get_last PARAMS ((void));

d2257 1
a2257 1
ppc_do_last (abfd)
d2341 1
a2341 4
    {
      if (! bfd_coff_compute_section_file_positions (abfd))
	return false;
    }
d2566 1
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
   Free Software Foundation, Inc.
d24 1
a24 2
Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */
d89 1
a89 1
    _("File %s, line %d, Hash check failure, bad eye %8s\n"), \
d789 1
a789 1
       fprintf(stderr,_("Unimplemented Relocation -- %s\n"),x); \
d907 2
a908 2
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
d910 1
a910 1
     enum toc_type toc_kind ATTRIBUTE_UNUSED;
d930 1
a930 1
	  unsigned int i;
d952 1
a952 1
	      (*_bfd_error_handler) (_("TOC overflow"));
d972 1
a972 1
	      (*_bfd_error_handler) (_("TOC overflow"));
d1008 1
a1008 1
     bfd * abfd ATTRIBUTE_UNUSED;
d1076 1
a1076 1
      *error_message = (char *) _("Missing PAIR");
d1177 2
a1178 3
		     + sym->n_value);
	      if (! obj_pe (output_bfd))
		val -= sec->vma;
d1197 1
a1197 1
		      rel->r_vaddr - input_section->vma, true)))
d1209 1
a1209 1
	    (_("%s: unsupported relocation type 0x%02x"),
d1306 1
a1306 1
			  (_("%s: Relocation for %s of %x exceeds Toc size limit"), 
d1362 1
a1362 1
		  (_("%s: Relocation exceeds allocated TOC (%x)"), 
d1421 1
a1421 1
		    _("Warning: unsupported reloc %s <file %s, section %s>\n"), 
d1441 1
a1441 1
	      (_("%s: Out of order IMGLUE reloc for %s"), 
d1646 1
a1646 1
h1 = N_("\n\t\t\tTOC MAPPING\n\n");
d1648 1
a1648 1
h2 = N_(" TOC    disassembly  Comments       Name\n");
d1650 1
a1650 1
h3 = N_(" Offset  spelling                   (if present)\n");
d1656 1
a1656 1
  FILE *file = (FILE *) vfile;
d1659 3
a1661 3
  fprintf(file, _(h1));
  fprintf(file, _(h2));
  fprintf(file, _(h3));
d1665 1
a1665 1
      const char *cat = "";
d1668 1
a1668 1
	cat = _("private       ");
d1670 1
a1670 1
	cat = _("public        ");
d1672 1
a1672 1
	cat = _("data-in-toc   ");
d1677 1
a1677 1
	    cat = _("IAT reference ");
d1681 1
a1681 1
		      _("**** global_toc_size %ld(%lx), thunk_size %ld(%lx)\n"),
d1683 1
a1683 1
	      cat = _("Out of bounds!");
d1700 1
a1700 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d1806 5
a1810 5
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
d1812 1
a1812 1
     char **error_message ATTRIBUTE_UNUSED;
d1860 5
a1864 5
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
d1866 1
a1866 1
     char **error_message ATTRIBUTE_UNUSED;
d1886 5
a1890 5
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
d1892 1
a1892 1
     char **error_message ATTRIBUTE_UNUSED;
d1945 5
a1949 5
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
d1951 1
a1951 1
     char **error_message ATTRIBUTE_UNUSED;
d1970 5
a1974 5
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
d1976 1
a1976 1
     char **error_message ATTRIBUTE_UNUSED;
d1995 5
a1999 5
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
d2001 1
a2001 1
     char **error_message ATTRIBUTE_UNUSED;
d2080 1
a2080 1
	      _("Warning: Unsupported reloc %s [%d] used -- it may not work.\n"),
d2093 1
a2093 1
     bfd *abfd ATTRIBUTE_UNUSED;
d2096 2
a2097 2
     struct coff_link_hash_entry *h ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
d2155 1
a2155 1
	      _("Warning: Unsupported reloc %s [%d] used -- it may not work.\n"),
d2175 1
a2175 1
     bfd *abfd ATTRIBUTE_UNUSED;
a2213 1
/* FIXME: This no longer works.  */
a2220 3
/* FIXME: This controls some code that used to be in peicode.h and is
   now in peigen.c.  It will not control the code in peigen.c.  If
   anybody wants to get this working, you will need to fix that.  */
a2222 14
#define COFF_SECTION_ALIGNMENT_ENTRIES \
{ COFF_SECTION_NAME_EXACT_MATCH (".idata$2"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 0 }, \
{ COFF_SECTION_NAME_EXACT_MATCH (".idata$3"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 0 }, \
{ COFF_SECTION_NAME_EXACT_MATCH (".idata$4"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 2 }, \
{ COFF_SECTION_NAME_EXACT_MATCH (".idata$5"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 2 }, \
{ COFF_SECTION_NAME_EXACT_MATCH (".idata$6"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 1 }, \
{ COFF_SECTION_NAME_EXACT_MATCH (".reloc"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 1 }

d2245 1
a2245 1
     PTR ext1 ATTRIBUTE_UNUSED;
d2316 1
a2823 5
/* Forward declaration for use by alternative_target field.  */
#ifdef TARGET_BIG_SYM
extern const bfd_target TARGET_BIG_SYM;
#endif

d2827 2
a2828 1
const bfd_target TARGET_LITTLE_SYM =
a2873 7

  /* Alternative_target.  */
#ifdef TARGET_BIG_SYM
  & TARGET_BIG_SYM,
#else
  NULL,
#endif
d2875 1
a2875 1
  COFF_SWAP_TABLE
d2880 2
a2881 1
const bfd_target TARGET_BIG_SYM =
d2928 1
a2928 9

  /* Alternative_target.  */
#ifdef TARGET_LITTLE_SYM
  & TARGET_LITTLE_SYM,
#else
  NULL,
#endif
  
  COFF_SWAP_TABLE
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
d8 1
a8 1
   coff files, in particular, those for the rs/6000, alpha, mips, and
d32 1
a32 1
   - dlltool will not produce correct output in some .reloc cases, and will
d36 1
d78 1
d90 1
a90 1
    fprintf (stderr,\
d93 1
a93 1
    abort (); \
d96 1
d108 1
a108 1
/* PE linker hash table entries.  */
d123 1
d157 1
a157 1
  struct ppc_coff_link_hash_entry *ret =
d164 1
a164 1
      bfd_hash_allocate (table,
d172 1
a172 1
	 _bfd_coff_link_hash_newfunc ((struct bfd_hash_entry *) ret,
d225 1
d241 1
a241 1
/* these should definitely go in a header file somewhere...  */
d323 1
d351 1
d394 2
d397 1
d421 1
a421 1
/*   TOCREL14       : 16 bit displacement field, similar to REL14 or ADDR14.  */
d441 6
a446 6
  HOWTO (IMAGE_REL_PPC_ABSOLUTE, /* type */
	 0,	                 /* rightshift */
	 0,	                 /* size (0 = byte, 1 = short, 2 = long) */
	 0,	                 /* bitsize */
	 false,	                 /* pc_relative */
	 0,	                 /* bitpos */
d448 1
a448 1
	 0,		         /* special_function */
d450 3
a452 3
	 false,	                 /* partial_inplace */
	 0x00,	 	         /* src_mask */
	 0x00,        		 /* dst_mask */
d454 1
a454 1

d457 6
a462 6
  HOWTO(IMAGE_REL_PPC_ADDR64,    /* type */
	0,	                 /* rightshift */
	3,	                 /* size (0 = byte, 1 = short, 2 = long) */
	64,	                 /* bitsize */
	false,	                 /* pc_relative */
	0,	                 /* bitpos */
d464 1
a464 1
	0,		         /* special_function */
d466 1
a466 1
	true,	                 /* partial_inplace */
d474 5
a478 5
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d480 1
a480 1
	 0,		        /* special_function */
d482 3
a484 3
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
d486 1
a486 1

d490 1
a490 1
  /* anyone else uses.... The li field is in bit 2 thru 25 */
d493 2
a494 2
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
d496 2
a497 2
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d499 1
a499 1
	 0,		        /* special_function */
d501 3
a503 3
	 true,	                /* partial_inplace */
	 0x07fffffc,	        /* src_mask */
	 0x07fffffc,        	/* dst_mask */
d505 1
a505 1

d508 6
a513 6
  HOWTO (IMAGE_REL_PPC_ADDR16,  /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d515 1
a515 1
	 0,		        /* special_function */
d517 3
a519 3
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d521 1
a521 1

d526 6
a531 6
  HOWTO (IMAGE_REL_PPC_ADDR14,  /* type */
	 1,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d533 1
a533 1
	 0,		        /* special_function */
d535 3
a537 3
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d539 1
a539 1

d544 5
a548 5
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 true,	                /* pc_relative */
	 0,	                /* bitpos */
d550 1
a550 1
	 0,		        /* special_function */
d552 3
a554 3
	 true,	                /* partial_inplace */
	 0x3fffffc,	        /* src_mask */
	 0x3fffffc,        	/* dst_mask */
d556 1
a556 1

d562 6
a567 6
  HOWTO (IMAGE_REL_PPC_ADDR14,  /* type */
	 1,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d569 1
a569 1
	 0,		        /* special_function */
d571 3
a573 3
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d575 1
a575 1

d579 6
a584 6
  HOWTO (IMAGE_REL_PPC_TOCREL16,/* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d586 1
a586 1
	 ppc_toc16_reloc,       /* special_function */
d588 3
a590 3
	 false,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d592 1
a592 1

d596 6
a601 6
  HOWTO (IMAGE_REL_PPC_TOCREL14,/* type */
	 1,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d603 1
a603 1
	 0,		        /* special_function */
d605 3
a607 3
	 false,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d609 1
a609 1

d613 6
a618 6
  HOWTO (IMAGE_REL_PPC_ADDR32NB,/* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d620 1
a620 1
	 0,                     /* special_function */
d622 3
a624 3
	 true,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
d626 1
a626 1

d630 6
a635 6
  HOWTO (IMAGE_REL_PPC_SECREL,/* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d637 1
a637 1
	 ppc_secrel_reloc,      /* special_function */
d639 3
a641 3
	 true,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
d647 6
a652 6
  HOWTO (IMAGE_REL_PPC_SECTION,/* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d654 1
a654 1
	 ppc_section_reloc,     /* special_function */
d656 3
a658 3
	 true,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
d664 6
a669 6
  HOWTO (IMAGE_REL_PPC_IFGLUE,/* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d671 1
a671 1
	 0,		        /* special_function */
d673 3
a675 3
	 true,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
d681 6
a686 6
  HOWTO (IMAGE_REL_PPC_IMGLUE,/* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d688 1
a688 1
	 ppc_imglue_reloc,      /* special_function */
d690 3
a692 3
	 false,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
d698 6
a703 6
  HOWTO (IMAGE_REL_PPC_SECREL16,/* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d705 1
a705 1
	 0,		        /* special_function */
d707 3
a709 3
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d714 6
a719 6
  HOWTO (IMAGE_REL_PPC_REFHI,   /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d721 1
a721 1
	 ppc_refhi_reloc,	/* special_function */
d723 3
a725 3
	 true,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
d730 6
a735 6
  HOWTO (IMAGE_REL_PPC_REFLO,   /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d737 1
a737 1
	 ppc_refhi_reloc,	/* special_function */
d739 3
a741 3
	 true,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
d746 6
a751 6
  HOWTO (IMAGE_REL_PPC_PAIR,    /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d753 1
a753 1
	 ppc_pair_reloc,        /* special_function */
d755 3
a757 3
	 true,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
d763 6
a768 6
  HOWTO ( (IMAGE_REL_PPC_TOCREL16 | IMAGE_REL_PPC_TOCDEFN), /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d770 1
a770 1
	 0,                     /* special_function */
d772 3
a774 3
	 false,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d778 2
d781 1
d791 1
a791 1
       fprintf (stderr,_("Unimplemented Relocation -- %s\n"),x); \
d797 1
a797 1
   fprintf (stderr,"%s sym %d, addr %d, addend %d\n", \
d802 2
a803 2
/* Given a reloc name, n, and a pointer to an internal_reloc,
   dump out interesting information on the contents
d813 1
a813 1
   fprintf (stderr,"%s sym %d, r_vaddr %d %s\n", \
d824 2
d927 2
a928 2
  if (h == 0)
    {
d934 3
a936 3
	  local_syms =
	    (int *) bfd_zalloc (abfd,
				obj_raw_syment_count(abfd) * sizeof (int));
d946 1
a946 1
      if (IS_UNALLOCATED(local_syms[sym]))
d1005 1
d1007 1
a1007 1
   appear in the output .reloc section.  */
d1013 2
a1014 2
  return
    (! howto->pc_relative)
d1018 1
a1018 1
      && (howto->type != IMAGE_REL_PPC_IFGLUE)
d1026 1
a1026 1
}
d1053 1
a1053 1

d1056 1
a1056 1
  if (output_bfd)
d1060 1
a1060 1
      return bfd_reloc_ok;
d1067 1
a1067 1
      if (r_type == IMAGE_REL_PPC_REFHI)
d1074 2
a1075 2

  if ((part1_consth_active) && (r_type != IMAGE_REL_PPC_PAIR))
d1082 1
d1084 2
a1085 2

  return(bfd_reloc_ok);
d1111 1
a1111 1

d1117 1
a1117 1

d1136 1
a1136 1

d1150 1
a1150 1
	  h = (struct ppc_coff_link_hash_entry *)
d1152 1
a1152 1
	  if (h != 0)
d1162 2
a1163 2
	  /* An IMGLUE reloc must have a name. Something is very wrong.  */
	  abort ();
d1206 1
a1206 1

d1223 1
a1223 1
	    if (toc_section == 0)
d1225 1
a1225 1
		toc_section = bfd_get_section_by_name (bfd_of_toc_owner,
d1228 1
a1228 1
		if ( toc_section == NULL )
d1230 2
a1231 2
		    /* There is no toc section. Something is very wrong.  */
		    abort ();
d1235 1
a1235 1
	    /*
d1256 1
a1256 1
		    /* if it has been written out, it is marked with the
d1265 3
a1267 3
		    record_toc(toc_section,
			       our_toc_offset,
			       priv,
d1270 1
a1270 1
		    bfd_put_32 (output_bfd,
d1283 1
a1283 1
		if ((r_flags & IMAGE_REL_PPC_TOCDEFN)
d1286 7
a1292 7
		    /* This is unbelievable cheese. Some knowledgable asm
		       hacker has decided to use r2 as a base for loading
		       a value. He/She does this by setting the tocdefn bit,
		       and not supplying a toc definition. The behaviour is
		       then to use the difference between the value of the
		       symbol and the actual location of the toc as the toc
		       index.
d1297 1
a1297 1
		       dll linkage, takes advantage of that and considers
d1301 2
a1302 2
		    our_toc_offset = val -
		      (toc_section->output_section->vma +
d1309 1
a1309 1
			  (_("%s: Relocation for %s of %x exceeds Toc size limit"),
d1319 1
a1319 1
		    /* if it has been written out, it is marked with the
d1330 1
a1330 1
		    bfd_put_32 (output_bfd,
d1341 1
a1341 1
	    if (fixit && info->base_file)
d1347 1
a1347 1
		   isn't absolute - we output the address here
d1352 1
a1352 1

d1359 1
d1365 1
a1365 1
		  (_("%s: Relocation exceeds allocated TOC (%x)"),
d1375 2
a1376 2
					    input_bfd,
					    relocation,
d1383 1
a1383 1
	    /* appearing on the call instruction is a glue function or not.  */
d1386 1
a1386 1

d1394 1
a1394 1
		if (h->symbol_is_glue == 1)
d1396 2
a1397 2
		    x = bfd_get_32 (input_bfd, loc);
		    bfd_put_32 (input_bfd, h->glue_insn, loc);
d1404 2
a1405 2
	  /* For fast access to the header of the section
	     containing the item.  */
d1423 2
a1424 2
	    fprintf (stderr,
		    _("Warning: unsupported reloc %s <file %s, section %s>\n"),
d1429 1
a1429 1
	    fprintf (stderr,"sym %ld (%s), r_vaddr %ld (%lx)\n",
d1431 1
a1431 1
		    (unsigned long) rel->r_vaddr);
d1439 1
a1439 1
	    if (h->symbol_is_glue == 1)
d1444 1
a1444 1
	      (_("%s: Out of order IMGLUE reloc for %s"),
d1464 3
a1466 3
		first_thunk_address = myh->root.u.def.value +
		  sec->output_section->vma +
		    sec->output_offset -
d1468 1
a1468 1

d1473 1
a1473 1

d1505 1
a1505 1
		    if (myh == 0)
d1507 2
a1508 2
			/* Missing magic cookies. Something is very wrong.  */
			abort ();
d1510 2
a1511 2

		    val = myh->root.u.def.value +
d1519 3
a1521 3
			first_thunk_address = myh->root.u.def.value +
			  sec->output_section->vma +
			    sec->output_offset -
d1523 1
a1523 1

d1528 1
a1528 1

d1539 2
a1540 2
		      	      input_bfd,
			      val -
d1552 2
a1553 2
					  input_bfd,
					  val,
d1561 2
a1562 2
					  input_bfd,
					  val,
d1574 1
a1574 1
		 isn't absolute - we output the address here
d1576 3
a1578 3
	      bfd_vma addr = rel->r_vaddr
		- input_section->vma
		+ input_section->output_offset
d1617 1
a1617 1
		   (info, name, howto->name,
d1626 1
a1626 1
    }
d1662 3
a1664 3
  fprintf (file, _(h1));
  fprintf (file, _(h2));
  fprintf (file, _(h3));
d1666 1
a1666 1
  for (t = head; t != 0; t=t->next)
d1683 1
a1683 1
	      fprintf (file,
d1690 1
a1690 1
      fprintf (file,
d1692 1
a1692 1
      fprintf (file,
d1698 1
a1698 1
  fprintf (file, "\n");
d1702 1
a1702 1
ppc_allocate_toc_section (info)
d1714 2
a1715 2
      /* No toc owner? Something is very wrong.  */
      abort ();
d1719 1
a1719 1
  if (s == NULL)
d1721 2
a1722 2
      /* No toc section? Something is very wrong.  */
      abort ();
d1743 1
a1743 1
     to do reloc rummaging, before section sizes are nailed down.  */
d1757 1
a1757 1
    if (sec->reloc_count == 0)
d1763 1
a1763 1

d1765 1
a1765 1
      abort ();
d1767 1
a1767 1
    for (rel=i;rel<i+sec->reloc_count;++rel)
d1775 1
a1775 1
	switch(r_type)
d1781 1
a1781 1
	      ok = ppc_record_toc_entry(abfd, info, sec,
d1800 1
d1879 1
d2014 1
d2016 1
d2018 2
a2019 1
      (sizeof (ppc_coff_howto_table) / sizeof (ppc_coff_howto_table[0]) - 1)
d2022 1
a2022 1
          that there are some bits encoded in the upper portion of the
d2032 1
a2032 1
{
d2049 3
a2051 3
  /* the masking process only slices off the bottom byte for r_type.  */
  if ( r_type > MAX_RELOC_INDEX )
    abort ();
d2055 1
a2055 1
    abort ();
d2057 1
a2057 1
  switch(r_type)
d2082 1
a2082 1
      fprintf (stderr,
d2086 1
a2086 1
      howto = ppc_coff_howto_table + r_type;
d2089 1
a2089 1

d2091 1
a2091 1

d2120 4
a2123 4
  /* the masking process only slices off the bottom byte for r_type.  */
  if ( r_type > MAX_RELOC_INDEX )
    abort ();

d2126 3
a2128 3
    abort ();

  switch(r_type)
d2157 1
a2157 1
      fprintf (stderr,
d2164 1
a2164 1

d2168 1
d2192 1
a2192 1
    default:
d2199 1
d2201 1
a2201 1
/* Tailor coffcode.h -- macro heaven.  */
d2214 1
a2214 1
#define coff_bfd_final_link          ppc_bfd_coff_final_link
d2245 1
d2247 1
d2250 1
a2250 1
   What we're trying to do here is allocate a toc section (early), and attach
d2280 1
a2280 1
      if (s != NULL)
d2294 1
a2294 1
	  abort ();
d2327 1
a2327 1
   the toc section is written last.
d2330 1
a2330 1
   end of the section list for the bfd.
d2332 3
a2334 3
   This is otherwise intended to be functionally the same as
   cofflink.c:_bfd_coff_final_link(). It is specifically different only
   where the POWERPC_LE_PE macro modifies the code. It is left in as a
d2338 1
d2843 1
d2849 1
a2849 1
/* The transfer vectors that lead the outside world to all of the above.  */
d2862 1
a2862 1

d2881 1
a2881 1

d2888 1
a2888 1

d2905 1
a2905 1

d2914 1
a2914 1
  bfd_target_coff_flavour,
d2958 1
d2965 1
a2965 1

@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d12 1
a12 1
   This file is part of BFD, the Binary File Descriptor library.
d14 14
a27 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d34 2
a35 1
     not produce the right glue code for dll function calls.  */
d57 1
a57 1
extern bfd_boolean ppc_bfd_coff_final_link
d61 9
a69 9
/* The toc is a set of bfd_vma fields. We use the fact that valid
   addresses are even (i.e. the bit representing "1" is off) to allow
   us to encode a little extra information in the field
   - Unallocated addresses are initialized to 1.
   - Allocated addresses are even numbers.
   The first time we actually write a reference to the toc in the bfd,
   we want to record that fact in a fixup file (if it is asked for), so
   we keep track of whether or not an address has been written by marking
   the low order bit with a "1" upon writing.  */
d78 1
a78 1
/* Turn on this check if you suspect something amiss in the hash tables.  */
d81 1
a81 1
/* Need a 7 char string for an eye catcher.  */
d104 1
a104 1
   linker, we define our own hash table, derived from the coff one.  */
d110 1
a110 1
  struct coff_link_hash_entry root; /* First entry, as required.  */
d113 2
a114 2
     here.  */
  bfd_vma toc_offset;               /* Our addition, as required.  */
d125 1
a125 1
  struct coff_link_hash_table root; /* First entry, as required.  */
d131 1
a131 1
static bfd_boolean ppc_coff_link_hash_table_init
d138 1
a138 1
static bfd_boolean coff_ppc_relocate_section
d175 1
a175 1
      SET_UNALLOCATED (ret->toc_offset);
d179 1
a179 1
      HASH_CHECK_INIT (ret);
d187 1
a187 1
static bfd_boolean
a204 1
  bfd_size_type amt = sizeof (struct ppc_coff_link_hash_table);
d206 2
a207 1
  ret = (struct ppc_coff_link_hash_table *) bfd_malloc (amt);
d213 1
a213 1
      free (ret);
d219 1
a219 1
/* Now, tailor coffcode.h to use our hash stuff.  */
d223 3
a225 3
/* The nt loader points the toc register to &toc + 32768, in order to
   use the complete range of a 16-bit displacement. We have to adjust
   for this when we fix up loads displaced off the toc reg.  */
d237 1
a237 1
/* These should definitely go in a header file somewhere...  */
d287 3
a289 3
/* Stuff to handle immediate data when the number of bits in the
   data is greater than the number of bits in the immediate field
   We need to do (usually) 32 bit arithmetic on 16 bit chunks.  */
d294 1
a294 1
/* This is essentially the same as tocrel16, with TOCDEFN assumed.  */
d297 1
a297 1
/* Flag bits in IMAGE_RELOCATION.TYPE.  */
d299 1
a299 1
/* Subtract reloc value rather than adding it.  */
d302 1
a302 1
/* Fix branch prediction bit to predict branch taken.  */
d305 1
a305 1
/* Fix branch prediction bit to predict branch not taken.  */
d308 1
a308 1
/* TOC slot defined in file (or, data in toc).  */
d311 1
a311 1
/* Masks to isolate above values in IMAGE_RELOCATION.Type.  */
d320 1
a320 1
/* Static helper functions to make relocation work.  */
d388 1
a388 1
static bfd_boolean in_reloc_p PARAMS((bfd *abfd, reloc_howto_type *howto));
d392 1
a392 29
   completely unverified or have a specific unknown marked in the comment.  */

/* Relocation entries for Windows/NT on PowerPC.                             

   From the document "" we find the following listed as used relocs:

     ABSOLUTE       : The noop
     ADDR[64|32|16] : fields that hold addresses in data fields or the
                      16 bit displacement field on a load/store.
     ADDR[24|14]    : fields that hold addresses in branch and cond
                      branches. These represent [26|16] bit addresses.
                      The low order 2 bits are preserved.
     REL[24|14]     : branches relative to the Instruction Address
                      register. These represent [26|16] bit addresses,
                      as before. The instruction field will be zero, and
                      the address of the SYM will be inserted at link time.
     TOCREL16       : 16 bit displacement field referring to a slot in
                      toc.
     TOCREL14       : 16 bit displacement field, similar to REL14 or ADDR14.
     ADDR32NB       : 32 bit address relative to the virtual origin.
                      (On the alpha, this is always a linker generated thunk)
                      (i.e. 32bit addr relative to the image base)
     SECREL         : The value is relative to the start of the section
                      containing the symbol.
     SECTION        : access to the header containing the item. Supports the
                      codeview debugger.

   In particular, note that the document does not indicate that the
   relocations listed in the header file are used.  */
d394 33
d436 1
a436 1
	 FALSE,	                 /* pc_relative */
d441 1
a441 1
	 FALSE,	                 /* partial_inplace */
d444 1
a444 1
	 FALSE),                 /* pcrel_offset */
d452 1
a452 1
	FALSE,	                 /* pc_relative */
d457 1
a457 1
	TRUE,	                 /* partial_inplace */
d460 1
a460 1
	FALSE),                 /* pcrel_offset */
d468 1
a468 1
	 FALSE,	                /* pc_relative */
d473 1
a473 1
	 TRUE,	                /* partial_inplace */
d476 1
a476 1
	 FALSE),                /* pcrel_offset */
d487 1
a487 1
	 FALSE,	                /* pc_relative */
d492 1
a492 1
	 TRUE,	                /* partial_inplace */
d495 1
a495 1
	 FALSE),                /* pcrel_offset */
d503 1
a503 1
	 FALSE,	                /* pc_relative */
d508 1
a508 1
	 TRUE,	                /* partial_inplace */
d511 1
a511 1
	 FALSE),                /* pcrel_offset */
d521 1
a521 1
	 FALSE,	                /* pc_relative */
d526 1
a526 1
	 TRUE,	                /* partial_inplace */
d529 1
a529 1
	 FALSE),                /* pcrel_offset */
d538 1
a538 1
	 TRUE,	                /* pc_relative */
d543 1
a543 1
	 TRUE,	                /* partial_inplace */
d546 1
a546 1
	 FALSE),                /* pcrel_offset */
d557 1
a557 1
	 FALSE,	                /* pc_relative */
d562 1
a562 1
	 TRUE,	                /* partial_inplace */
d565 1
a565 1
	 TRUE),                 /* pcrel_offset */
d574 1
a574 1
	 FALSE,	                /* pc_relative */
d579 1
a579 1
	 FALSE,	                /* partial_inplace */
d582 1
a582 1
	 FALSE),                /* pcrel_offset */
d591 1
a591 1
	 FALSE,	                /* pc_relative */
d596 1
a596 1
	 FALSE,	                /* partial_inplace */
d599 1
a599 1
	 FALSE),                /* pcrel_offset */
d608 1
a608 1
	 FALSE,	                /* pc_relative */
d613 1
a613 1
	 TRUE,	                /* partial_inplace */
d616 1
a616 1
	 FALSE),                 /* pcrel_offset */
d625 1
a625 1
	 FALSE,	                /* pc_relative */
d630 1
a630 1
	 TRUE,	                /* partial_inplace */
d633 1
a633 1
	 TRUE),                 /* pcrel_offset */
d642 1
a642 1
	 FALSE,	                /* pc_relative */
d647 1
a647 1
	 TRUE,	                /* partial_inplace */
d650 1
a650 1
	 TRUE),                 /* pcrel_offset */
d659 1
a659 1
	 FALSE,	                /* pc_relative */
d664 1
a664 1
	 TRUE,	                /* partial_inplace */
d667 1
a667 1
	 FALSE),                /* pcrel_offset */
d676 1
a676 1
	 FALSE,	                /* pc_relative */
d681 1
a681 1
	 FALSE,	                /* partial_inplace */
d684 1
a684 1
	 FALSE),                 /* pcrel_offset */
d693 1
a693 1
	 FALSE,	                /* pc_relative */
d698 1
a698 1
	 TRUE,	                /* partial_inplace */
d701 1
a701 1
	 TRUE),                 /* pcrel_offset */
d709 1
a709 1
	 FALSE,	                /* pc_relative */
d714 1
a714 1
	 TRUE,	                /* partial_inplace */
d717 1
a717 1
	 FALSE),                 /* pcrel_offset */
d725 1
a725 1
	 FALSE,	                /* pc_relative */
d730 1
a730 1
	 TRUE,	                /* partial_inplace */
d733 1
a733 1
	 FALSE),                /* pcrel_offset */
d741 1
a741 1
	 FALSE,	                /* pc_relative */
d746 1
a746 1
	 TRUE,	                /* partial_inplace */
d749 1
a749 1
	 FALSE),                /* pcrel_offset */
d758 1
a758 1
	 FALSE,	                /* pc_relative */
d763 1
a763 1
	 FALSE,	                /* partial_inplace */
d766 1
a766 1
	 FALSE),                /* pcrel_offset */
d770 1
a770 1
/* Some really cheezy macros that can be turned on to test stderr :-)  */
d795 3
a797 1
#define n_offset	_n._n_n._n_offset  */
d799 4
a802 4
#define DUMP_RELOC2(n,r)                     		\
{                                            		\
   fprintf (stderr,"%s sym %d, r_vaddr %d %s\n", 	\
	   n, r->r_symndx, r->r_vaddr,			\
d804 1
a804 1
	   ?" ":" TOCDEFN"  );      			\
d813 1
a813 1
/* TOC construction and management routines.  */
d818 1
a818 1
extern bfd *    bfd_of_toc_owner;
d820 1
d836 1
a836 1
  tocdata
d852 1
a852 1
  PARAMS ((asection *, bfd_signed_vma, enum ref_category, const char *));
d857 1
a857 1
     bfd_signed_vma our_toc_offset;
d861 3
a863 4
  /* Add this entry to our toc addr-offset-name list.  */
  bfd_size_type amt = sizeof (struct list_ele);
  struct list_ele *t = (struct list_ele *) bfd_malloc (amt);

d886 1
a886 1
static bfd_boolean ppc_record_toc_entry
d891 2
a892 2
/* Record a toc offset against a symbol.  */
static bfd_boolean
a915 1

a918 2
	  bfd_size_type amt;

d920 3
a922 2
	  amt = (bfd_size_type) obj_raw_syment_count (abfd) * sizeof (int);
	  local_syms = (int *) bfd_zalloc (abfd, amt);
d924 3
a926 4
	    return FALSE;
	  obj_coff_local_toc_table (abfd) = local_syms;

	  for (i = 0; i < obj_raw_syment_count (abfd); ++i)
d928 1
a928 1
	      SET_UNALLOCATED (local_syms[i]);
d937 1
a937 1
	  /* The size must fit in a 16bit displacment.  */
d942 1
a942 1
	      return FALSE;
d950 2
a951 2
      /* Check to see if there's a toc slot allocated. If not, do it
	 here. It will be used in relocate_section.  */
d957 1
a957 1
	  /* The size must fit in a 16bit displacment.  */
d962 1
a962 1
	      return FALSE;
d967 1
a967 1
  return TRUE;
d970 1
a970 1
/* Record a toc offset against a symbol.  */
d991 1
a991 1
/* Return TRUE if this relocation should
d994 1
a994 1
static bfd_boolean in_reloc_p(abfd, howto)
d1015 3
a1017 3
/* This function is in charge of performing all the ppc PE relocations
   Don't yet know if we want to do this this particular way ... (krk).  */
/* FIXME: (it is not yet enabled).  */
d1030 3
a1032 3
  /* The consth relocation comes in two parts, we have to remember
     the state between calls, in these variables.  */
  static bfd_boolean part1_consth_active = FALSE;
d1043 1
a1043 1
      /* Partial linking - do nothing.  */
d1051 1
a1051 1
      /* Keep the state machine happy in case we're called again.  */
d1054 1
a1054 1
	  part1_consth_active = TRUE;
d1062 1
a1062 1
      part1_consth_active = FALSE;
d1076 1
a1076 1
static bfd_boolean
d1090 1
a1090 1
  bfd_boolean hihalf;
d1100 1
a1100 1
    return TRUE;
d1102 1
a1102 1
  hihalf = FALSE;
d1153 1
a1153 1
      /* FIXME: PAIR unsupported in the following code.  */
d1184 2
a1185 2
		      rel->r_vaddr - input_section->vma, TRUE)))
		return FALSE;
d1191 1
a1191 1
      /* Each case must do its own relocation, setting rstat appropriately.  */
d1197 1
a1197 1
	     bfd_archive_filename (input_bfd), r_type);
d1199 1
a1199 1
	  return FALSE;
d1202 1
a1202 1
	    bfd_signed_vma our_toc_offset;
d1219 8
a1226 6
	    /* Amazing bit tricks present. As we may have seen earlier, we
	       use the 1 bit to tell us whether or not a toc offset has been
	       allocated. Now that they've all been allocated, we will use
	       the 1 bit to tell us if we've written this particular toc
	       entry out.  */
	    fixit = FALSE;
d1228 1
a1228 2
	      {
		/* It is a file local symbol.  */
d1240 1
a1240 1
		    /* If it has been written out, it is marked with the
d1242 2
a1243 1
		       again.  */
d1248 5
a1252 3
		    /* Write out the toc entry.  */
		    record_toc (toc_section, our_toc_offset, priv,
				strdup (name));
d1254 2
a1255 1
		    bfd_put_32 (output_bfd, val,
d1259 1
a1259 1
		    fixit = TRUE;
d1282 2
a1283 1
		       the IAT to be part of the toc, thus saving a load.  */
d1285 3
a1287 2
		    our_toc_offset = val - (toc_section->output_section->vma
					    + toc_section->output_offset);
d1289 2
a1290 2
		    /* The size must still fit in a 16bit displacment.  */
		    if ((bfd_vma) our_toc_offset >= 65535)
d1293 2
a1294 3
			  (_("%s: Relocation for %s of %lx exceeds Toc size limit"),
			   bfd_archive_filename (input_bfd), name,
			   (unsigned long) our_toc_offset);
d1296 1
a1296 1
			return FALSE;
d1299 1
a1299 2
		    record_toc (toc_section, our_toc_offset, pub,
				strdup (name));
d1301 1
a1301 1
		else if (IS_WRITTEN (our_toc_offset))
d1303 1
a1303 1
		    /* If it has been written out, it is marked with the
d1305 2
a1306 1
		       again.  */
d1311 1
a1311 2
		    record_toc(toc_section, our_toc_offset, pub,
			       strdup (name));
d1313 3
a1315 2
		    /* Write out the toc entry.  */
		    bfd_put_32 (output_bfd, val,
d1319 3
a1321 3
		    /* The tricky part is that this is the address that
		       needs a .reloc entry for it.  */
		    fixit = TRUE;
d1328 1
a1328 1
		   to a section or a common symbol, then it needs a reloc.  */
d1330 1
a1330 1
		/* Relocation to a symbol in a section which
d1332 1
a1332 3
		   to a file.  */
		bfd_vma addr = (toc_section->output_section->vma
				+ toc_section->output_offset + our_toc_offset);
d1334 4
a1337 1
		if (coff_data (output_bfd)->pe)
d1343 3
a1345 3
	    /* FIXME: this test is conservative.  */
	    if ((r_flags & IMAGE_REL_PPC_TOCDEFN) != IMAGE_REL_PPC_TOCDEFN
		&& (bfd_vma) our_toc_offset > toc_section->_raw_size)
d1348 3
a1350 3
		  (_("%s: Relocation exceeds allocated TOC (%lx)"),
		   bfd_archive_filename (input_bfd),
		   (unsigned long) toc_section->_raw_size);
d1352 1
a1352 1
		return FALSE;
d1355 1
a1355 1
	    /* Now we know the relocation for this toc reference.  */
d1357 4
a1360 1
	    rstat = _bfd_relocate_contents (howto, input_bfd, relocation, loc);
d1365 5
a1369 4
	    /* To solve this, we need to know whether or not the symbol
	       appearing on the call instruction is a glue function or not.
	       A glue function must announce itself via a IMGLUE reloc, and 
	       the reloc contains the required toc restore instruction.  */
d1372 1
a1372 2
	    
	    DUMP_RELOC2 (howto->name, rel);
d1380 1
a1380 1
		    bfd_put_32 (input_bfd, (bfd_vma) h->glue_insn, loc);
d1386 1
a1386 1
	  /* Unimplemented: codeview debugging information.  */
d1391 1
a1391 1
	  /* Unimplemented: codeview debugging information.  */
d1394 1
a1394 1
	     symbol.  */
a1398 1

d1400 1
a1400 1
	      my_name = (syms+symndx)->_n._n_name;
d1402 3
a1404 1
	      my_name = h->root.root.root.string;
d1409 1
a1409 1
		    bfd_archive_filename(input_bfd),
d1420 1
a1420 1
	       pass over the relocs, and the glue instruction extracted.  */
a1421 1

d1428 1
a1428 1
	       bfd_archive_filename (input_bfd), my_name);
d1430 1
a1430 1
	    return FALSE;
d1435 1
d1437 1
a1437 2

	    DUMP_RELOC2 (howto->name, rel);
d1441 1
a1441 1
		/* Set magic values.  */
d1443 1
a1443 2
		struct coff_link_hash_entry *myh;

d1446 1
a1446 1
					     FALSE, FALSE, TRUE);
d1455 1
a1455 1
					     FALSE, FALSE, TRUE);
d1460 1
a1460 1
					     FALSE, FALSE, TRUE);
d1465 1
a1465 2
	      {
		/* It is a file local symbol.  */
d1474 1
a1474 1
		if (strcmp (".idata$2", name) == 0)
d1476 1
a1476 1
		else if (strcmp (".idata$4", name) == 0)
d1478 1
a1478 1
		else if (strcmp (".idata$5", name) == 0)
d1483 1
a1483 1
		    struct coff_link_hash_entry *myh;
d1487 1
a1487 1
						 FALSE, FALSE, TRUE);
d1501 1
a1501 1
						     FALSE, FALSE, TRUE);
d1510 1
a1510 1
						     FALSE, FALSE, TRUE);
d1515 1
a1515 1
						     FALSE, FALSE, TRUE);
d1522 4
a1525 4
					    input_bfd,
					    val -
					    pe_data (output_bfd)->pe_opthdr.ImageBase,
					    loc);
d1550 1
a1550 1
      if (info->base_file)
d1553 2
a1554 2
	     to a section or a common symbol, then it needs a reloc.  */
	  if (sym && pe_data(output_bfd)->in_reloc_p (output_bfd, howto))
d1556 1
a1556 1
	      /* Relocation to a symbol in a section which
d1558 1
a1558 1
		 to a file.  */
d1564 4
a1567 3
	      if (coff_data (output_bfd)->pe)
		addr -= pe_data (output_bfd)->pe_opthdr.ImageBase;

d1603 3
a1605 1
	      return FALSE;
d1608 1
d1611 1
a1611 1
  return TRUE;
d1657 1
a1657 1
      else if (t->cat == tocdata)
d1668 1
a1668 2
		       global_toc_size, global_toc_size,
		       thunk_size, thunk_size);
d1684 1
a1684 1
bfd_boolean
a1689 1
  bfd_size_type amt;
d1692 2
a1693 2
  if ( global_toc_size == 0 ) /* FIXME: does this get me in trouble?  */
    return TRUE;
d1696 4
a1699 2
    /* No toc owner? Something is very wrong.  */
    abort ();
d1703 4
a1706 2
    /* No toc section? Something is very wrong.  */
    abort ();
d1708 2
a1709 3
  amt = global_toc_size;
  foo = (bfd_byte *) bfd_alloc (bfd_of_toc_owner, amt);
  memset(foo, test_char, (size_t) global_toc_size);
d1714 1
a1714 1
  return TRUE;
d1717 1
a1717 1
bfd_boolean
d1725 1
a1725 1
  /* Here we have a bfd that is to be included on the link. We have a hook
a1726 1
  _bfd_coff_get_external_symbols (abfd);
d1728 3
a1730 1
  /* Rummage around all the relocs and map the toc.  */
d1734 3
a1736 1
    return TRUE;
d1739 3
a1741 3
    {
      if (sec->reloc_count == 0)
	continue;
d1743 3
a1745 3
      /* load the relocs */
      /* FIXME: there may be a storage leak here */
      i=_bfd_coff_read_internal_relocs(abfd,sec,1,0,0,0);
d1747 2
a1748 2
      if (i == 0)
	abort ();
d1750 5
a1754 5
      for (rel = i; rel < i + sec->reloc_count; ++rel)
	{
	  unsigned short r_type  = EXTRACT_TYPE  (rel->r_type);
	  unsigned short r_flags = EXTRACT_FLAGS (rel->r_type);
	  bfd_boolean ok = TRUE;
d1756 1
a1756 1
	  DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, rel);
d1758 19
a1776 19
	  switch(r_type)
	    {
	    case IMAGE_REL_PPC_TOCREL16:
	      /* If TOCDEFN is on, ignore as someone else has allocated the
		 toc entry.  */
	      if ((r_flags & IMAGE_REL_PPC_TOCDEFN) != IMAGE_REL_PPC_TOCDEFN)
		ok = ppc_record_toc_entry(abfd, info, sec,
					  rel->r_symndx, default_toc);
	      if (!ok)
		return FALSE;
	      break;
	    case IMAGE_REL_PPC_IMGLUE:
	      ppc_mark_symbol_as_glue (abfd, rel->r_symndx, rel);
	      break;
	    default:
	      break;
	    }
	}
    }
d1778 1
a1778 1
  return TRUE;
d1784 7
a1790 2
ppc_refhi_reloc (abfd, reloc_entry, symbol, data,
		 input_section, output_bfd, error_message)
d1811 7
a1817 2
ppc_reflo_reloc (abfd, reloc_entry, symbol, data,
		 input_section, output_bfd, error_message)
d1838 7
a1844 2
ppc_pair_reloc (abfd, reloc_entry, symbol, data,
		input_section, output_bfd, error_message)
d1863 7
a1869 2
ppc_toc16_reloc (abfd, reloc_entry, symbol, data,
		 input_section, output_bfd, error_message)
d1878 2
a1879 2
  UN_IMPL ("TOCREL16");
  DUMP_RELOC ("TOCREL16",reloc_entry);
d1882 3
a1884 1
    return bfd_reloc_continue;
d1891 5
a1895 3
/* ADDR32NB : 32 bit address relative to the virtual origin.
              (On the alpha, this is always a linker generated thunk)
              (i.e. 32bit addr relative to the image base).  */
d1898 7
a1904 2
ppc_addr32nb_reloc (abfd, reloc_entry, symbol, data,
		    input_section, output_bfd, error_message)
d1922 7
a1928 2
ppc_secrel_reloc (abfd, reloc_entry, symbol, data,
		  input_section, output_bfd, error_message)
d1947 7
a1953 2
ppc_section_reloc (abfd, reloc_entry, symbol, data,
		   input_section, output_bfd, error_message)
d1972 7
a1978 2
ppc_imglue_reloc (abfd, reloc_entry, symbol, data,
		  input_section, output_bfd, error_message)
d2001 4
a2004 2
	  type field. Not yet implemented.  */
static void ppc_coff_rtype2howto PARAMS ((arelent *, struct internal_reloc *));
d2011 1
d2020 2
a2021 1
     than that.  */
d2027 1
a2027 1
  /* The masking process only slices off the bottom byte for r_type.  */
d2031 2
a2032 2
  /* Check for absolute crap.  */
  if (junk != 0)
d2045 1
a2045 1
      DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, internal);
d2049 1
a2049 1
      DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, internal);
d2053 1
a2053 1
      DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, internal);
d2069 1
d2091 2
a2092 1
     than that.  */
d2094 3
a2096 3
  unsigned short r_type  = EXTRACT_TYPE  (rel->r_type);
  unsigned short r_flags = EXTRACT_FLAGS (rel->r_type);
  unsigned short junk    = EXTRACT_JUNK  (rel->r_type);
d2098 2
a2099 2
  /* The masking process only slices off the bottom byte for r_type.  */
  if (r_type > MAX_RELOC_INDEX)
d2102 2
a2103 2
  /* Check for absolute crap.  */
  if (junk != 0)
d2146 1
a2146 1
/* A cheesy little macro to make the code a little more readable.  */
d2172 1
d2181 4
a2193 1
#if 0
a2195 1
#endif
a2222 2
/* FIXME: This no longer works.  */
#if 0
d2234 2
a2235 2
      and how often, etc. It's not clear to me that there isn't a hole here.  */
static void ppc_coff_swap_sym_in_hook PARAMS ((bfd *, PTR, PTR));
d2243 1
a2243 1
  struct internal_syment * in = (struct internal_syment *)in1;
d2245 1
a2245 1
  if (bfd_of_toc_owner != 0) /* We already have a toc, so go home.  */
d2248 1
a2248 1
  if (strcmp (in->_n._n_name, ".toc") == 0)
d2253 1
a2253 1
      s = bfd_get_section_by_name (abfd, TOC_SECTION_NAME);
d2255 3
a2257 1
	return;
d2266 4
a2269 2
	/* FIXME: set appropriate bfd error.  */
	abort ();
d2271 1
a2271 1
      /* Save the bfd for later allocation.  */
a2277 1
#endif
d2281 1
a2281 1
static bfd_boolean ppc_do_last PARAMS ((bfd *));
d2284 1
a2284 1
static bfd_boolean
d2289 1
a2289 1
    return TRUE;
d2291 1
a2291 1
    return FALSE;
d2300 1
a2300 1
/* This piece of machinery exists only to guarantee that the bfd that holds
d2309 2
a2310 1
   precise form of comment. krk@@cygnus.com  */
d2314 1
a2314 1
bfd_boolean
d2321 1
a2321 1
  bfd_boolean debug_merge_allocated;
d2324 5
a2328 5
  bfd_size_type max_sym_count;
  bfd_size_type max_lineno_count;
  bfd_size_type max_reloc_count;
  bfd_size_type max_output_reloc_count;
  bfd_size_type max_contents_size;
a2335 1
  bfd_size_type amt;
d2353 1
a2353 1
  debug_merge_allocated = FALSE;
d2363 1
a2363 1
  debug_merge_allocated = TRUE;
d2369 1
a2369 1
	return FALSE;
a2383 1

d2386 1
d2397 1
a2397 1
	      sec->linker_mark = TRUE;
d2436 4
a2439 4
      amt = abfd->section_count + 1;
      amt *= sizeof (struct coff_link_section_info);
      finfo.section_info = (struct coff_link_section_info *) bfd_malloc (amt);

a2441 1

a2453 1

a2479 2
	  amt = o->reloc_count;
	  amt *= sizeof (struct internal_reloc);
d2481 2
a2482 3
	    (struct internal_reloc *) bfd_malloc (amt);
	  amt = o->reloc_count;
	  amt *= sizeof (struct coff_link_hash_entry *);
d2484 3
a2486 1
	    (struct coff_link_hash_entry **) bfd_malloc (amt);
d2509 1
a2509 1
      bfd_size_type sz;
d2511 1
a2511 1
      sub->output_has_begun = FALSE;
d2518 10
a2527 10
  amt = max_sym_count * sizeof (struct internal_syment);
  finfo.internal_syms = (struct internal_syment *) bfd_malloc (amt);
  amt = max_sym_count * sizeof (asection *);
  finfo.sec_ptrs = (asection **) bfd_malloc (amt);
  amt = max_sym_count * sizeof (long);
  finfo.sym_indices = (long *) bfd_malloc (amt);
  amt = (max_sym_count + 1) * symesz;
  finfo.outsyms = (bfd_byte *) bfd_malloc (amt);
  amt = max_lineno_count * bfd_coff_linesz (abfd);
  finfo.linenos = (bfd_byte *) bfd_malloc (amt);
d2531 3
a2533 4
    {
      amt = max_reloc_count * sizeof (struct internal_reloc);
      finfo.internal_relocs = (struct internal_reloc *) bfd_malloc (amt);
    }
d2576 1
a2576 1
		  sub->output_has_begun = TRUE;
d2601 1
a2601 1
    last_one->output_has_begun = TRUE;
d2606 1
d2608 1
a2608 1
  debug_merge_allocated = FALSE;
a2651 2
      file_ptr pos;

d2655 6
a2660 4
      pos = obj_sym_filepos (abfd) + finfo.last_file_index * symesz;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (finfo.outsyms, symesz, abfd) != symesz)
	return FALSE;
d2664 1
a2664 1
  finfo.failed = FALSE;
d2682 2
a2683 2
      amt = max_output_reloc_count * relsz;
      external_relocs = (bfd_byte *) bfd_malloc (amt);
a2710 1
	  amt = relsz * o->reloc_count;
d2712 2
a2713 1
	      || bfd_bwrite ((PTR) external_relocs, amt, abfd) != amt)
d2741 1
a2741 1
	return FALSE;
d2747 5
a2751 5
      file_ptr pos;

      pos = obj_sym_filepos (abfd) + obj_raw_syment_count (abfd) * symesz;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0)
	return FALSE;
d2754 3
a2756 3
      H_PUT_32 (abfd,
		_bfd_stringtab_size (finfo.strtab) + STRING_SIZE_SIZE,
		strbuf);
d2758 1
a2758 1
 #error Change H_PUT_32 above
d2761 2
a2762 3
      if (bfd_bwrite (strbuf, (bfd_size_type) STRING_SIZE_SIZE, abfd)
	  != STRING_SIZE_SIZE)
	return FALSE;
d2765 1
a2765 1
	return FALSE;
d2774 1
a2774 1
  return TRUE;
d2812 1
a2812 1
  return FALSE;
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d932 1
a932 1
	  /* The size must fit in a 16-bit displacement.  */
d952 1
a952 1
	  /* The size must fit in a 16-bit displacement.  */
d1091 1
a1091 1
  /* If we are performing a relocatable link, we don't need to do a
d1094 1
a1094 1
  if (info->relocatable)
d1277 1
a1277 1
		    /* The size must still fit in a 16-bit displacement.  */
d1934 1
a1934 1
/* FIXME: There is a possibility that when we read in a reloc from a file,
d2328 1
a2328 1
	      if (info->relocatable)
d2338 1
a2338 1
	  else if (info->relocatable
d2353 1
a2353 1
  /* If doing a relocatable link, allocate space for the pointers we
d2355 1
a2355 1
  if (info->relocatable)
d2404 1
a2404 1
	     but only when doing a relocatable link, which is not the
d2406 1
a2406 1
	  BFD_ASSERT (info->relocatable);
d2458 1
a2458 1
  if (! info->relocatable)
d2470 1
a2470 1
      || (! info->relocatable
d2605 1
a2605 1
  if (info->relocatable)
@


