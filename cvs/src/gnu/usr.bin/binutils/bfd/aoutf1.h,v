head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.50
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.52
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.11.02.20.45.02;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.19;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.28;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.04;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.32.37;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.18.59.09;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.42.52;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.22;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.22;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.04.44;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.36.45;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.11.56;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.17.35;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.21;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.19.42;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.09;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.12;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* A.out "format 1" file handling code for BFD.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000,
   2001, 2002, 2003
   Free Software Foundation, Inc.
   Written by Cygnus Support.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"

#include "aout/sun4.h"
#include "libaout.h"		/* BFD a.out internal data structures */

#include "aout/aout64.h"
#include "aout/stab_gnu.h"
#include "aout/ar.h"

/* This is needed to reject a NewsOS file, e.g. in
   gdb/testsuite/gdb.t10/crossload.exp. <kingdon@@cygnus.com>
   I needed to add M_UNKNOWN to recognize a 68000 object, so this will
   probably no longer reject a NewsOS object.  <ian@@cygnus.com>.  */
#ifndef MACHTYPE_OK
#define MACHTYPE_OK(mtype) \
  (((mtype) == M_SPARC && bfd_lookup_arch (bfd_arch_sparc, 0) != NULL) \
   || (((mtype) == M_UNKNOWN || (mtype) == M_68010 || (mtype) == M_68020) \
       && bfd_lookup_arch (bfd_arch_m68k, 0) != NULL))
#endif

/*
The file @@code{aoutf1.h} contains the code for BFD's
a.out back end. Control over the generated back end is given by these
two preprocessor names:
@@table @@code
@@item ARCH_SIZE
This value should be either 32 or 64, depending upon the size of an
int in the target format. It changes the sizes of the structs which
perform the memory/disk mapping of structures.

The 64 bit backend may only be used if the host compiler supports 64
ints (eg long long with gcc), by defining the name @@code{BFD_HOST_64_BIT} in @@code{bfd.h}.
With this name defined, @@emph{all} bfd operations are performed with 64bit
arithmetic, not just those to a 64bit target.

@@item TARGETNAME
The name put into the target vector.
@@item
@@end table

*/

/*SUPPRESS558*/
/*SUPPRESS529*/

#if ARCH_SIZE == 64
#define sunos_set_arch_mach sunos_64_set_arch_mach
#define sunos_write_object_contents aout_64_sunos4_write_object_contents
#else
#define sunos_set_arch_mach sunos_32_set_arch_mach
#define sunos_write_object_contents aout_32_sunos4_write_object_contents
#endif

static bfd_boolean sunos_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));
static void sunos_set_arch_mach
  PARAMS ((bfd *, enum machine_type));
static void choose_reloc_size
  PARAMS ((bfd *));
static bfd_boolean sunos_write_object_contents
  PARAMS ((bfd *));
static const bfd_target *sunos4_core_file_p
  PARAMS ((bfd *));
static char *sunos4_core_file_failing_command
  PARAMS ((bfd *));
static int sunos4_core_file_failing_signal
  PARAMS ((bfd *));
static bfd_boolean sunos4_core_file_matches_executable_p
  PARAMS ((bfd *, bfd *));
static bfd_boolean sunos4_set_sizes
  PARAMS ((bfd *));

/* Merge backend data into the output file.
   This is necessary on sparclet-aout where we want the resultant machine
   number to be M_SPARCLET if any input file is M_SPARCLET.  */

#define MY_bfd_merge_private_bfd_data sunos_merge_private_bfd_data

static bfd_boolean
sunos_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd, *obfd;
{
  if (bfd_get_flavour (ibfd) != bfd_target_aout_flavour
      || bfd_get_flavour (obfd) != bfd_target_aout_flavour)
    return TRUE;

  if (bfd_get_arch (obfd) == bfd_arch_sparc)
    {
      if (bfd_get_mach (obfd) < bfd_get_mach (ibfd))
	bfd_set_arch_mach (obfd, bfd_arch_sparc, bfd_get_mach (ibfd));
    }

  return TRUE;
}

/* This is either sunos_32_set_arch_mach or sunos_64_set_arch_mach,
   depending upon ARCH_SIZE.  */

static void
sunos_set_arch_mach (abfd, machtype)
     bfd *abfd;
     enum machine_type machtype;
{
  /* Determine the architecture and machine type of the object file.  */
  enum bfd_architecture arch;
  unsigned long machine;
  switch (machtype)
    {

    case M_UNKNOWN:
      /* Some Sun3s make magic numbers without cpu types in them, so
	 we'll default to the 68000.  */
      arch = bfd_arch_m68k;
      machine = bfd_mach_m68000;
      break;

    case M_68010:
    case M_HP200:
      arch = bfd_arch_m68k;
      machine = bfd_mach_m68010;
      break;

    case M_68020:
    case M_HP300:
      arch = bfd_arch_m68k;
      machine = bfd_mach_m68020;
      break;

    case M_SPARC:
      arch = bfd_arch_sparc;
      machine = 0;
      break;

    case M_SPARCLET:
      arch = bfd_arch_sparc;
      machine = bfd_mach_sparc_sparclet;
      break;

    case M_SPARCLITE_LE:
      arch = bfd_arch_sparc;
      machine = bfd_mach_sparc_sparclite_le;
      break;

    case M_386:
    case M_386_DYNIX:
      arch = bfd_arch_i386;
      machine = 0;
      break;

    case M_29K:
      arch = bfd_arch_a29k;
      machine = 0;
      break;

    case M_HPUX:
      arch = bfd_arch_m68k;
      machine = 0;
      break;

    default:
      arch = bfd_arch_obscure;
      machine = 0;
      break;
    }
  bfd_set_arch_mach (abfd, arch, machine);
}

#define SET_ARCH_MACH(ABFD, EXEC) \
  NAME(sunos,set_arch_mach) (ABFD, N_MACHTYPE (EXEC)); \
  choose_reloc_size(ABFD);

/* Determine the size of a relocation entry, based on the architecture */
static void
choose_reloc_size (abfd)
     bfd *abfd;
{
  switch (bfd_get_arch (abfd))
    {
    case bfd_arch_sparc:
    case bfd_arch_a29k:
      obj_reloc_entry_size (abfd) = RELOC_EXT_SIZE;
      break;
    default:
      obj_reloc_entry_size (abfd) = RELOC_STD_SIZE;
      break;
    }
}

/* Write an object file in SunOS format.  Section contents have
   already been written.  We write the file header, symbols, and
   relocation.  The real name of this function is either
   aout_64_sunos4_write_object_contents or
   aout_32_sunos4_write_object_contents, depending upon ARCH_SIZE.  */

static bfd_boolean
sunos_write_object_contents (abfd)
     bfd *abfd;
{
  struct external_exec exec_bytes;
  struct internal_exec *execp = exec_hdr (abfd);

  /* Magic number, maestro, please!  */
  switch (bfd_get_arch (abfd))
    {
    case bfd_arch_m68k:
      switch (bfd_get_mach (abfd))
	{
	case bfd_mach_m68000:
	  N_SET_MACHTYPE (*execp, M_UNKNOWN);
	  break;
	case bfd_mach_m68010:
	  N_SET_MACHTYPE (*execp, M_68010);
	  break;
	default:
	case bfd_mach_m68020:
	  N_SET_MACHTYPE (*execp, M_68020);
	  break;
	}
      break;
    case bfd_arch_sparc:
      switch (bfd_get_mach (abfd))
	{
	case bfd_mach_sparc_sparclet:
	  N_SET_MACHTYPE (*execp, M_SPARCLET);
	  break;
	case bfd_mach_sparc_sparclite_le:
	  N_SET_MACHTYPE (*execp, M_SPARCLITE_LE);
	  break;
	default:
	  N_SET_MACHTYPE (*execp, M_SPARC);
	  break;
	}
      break;
    case bfd_arch_i386:
      N_SET_MACHTYPE (*execp, M_386);
      break;
    case bfd_arch_a29k:
      N_SET_MACHTYPE (*execp, M_29K);
      break;
    default:
      N_SET_MACHTYPE (*execp, M_UNKNOWN);
    }

  choose_reloc_size (abfd);

  N_SET_FLAGS (*execp, aout_backend_info (abfd)->exec_hdr_flags);

  N_SET_DYNAMIC (*execp, (long)(bfd_get_file_flags (abfd) & DYNAMIC));

  WRITE_HEADERS (abfd, execp);

  return TRUE;
}

/* core files */

#define CORE_MAGIC 0x080456
#define CORE_NAMELEN 16

/* The core structure is taken from the Sun documentation.
  Unfortunately, they don't document the FPA structure, or at least I
  can't find it easily.  Fortunately the core header contains its own
  length.  So this shouldn't cause problems, except for c_ucode, which
  so far we don't use but is easy to find with a little arithmetic.  */

/* But the reg structure can be gotten from the SPARC processor handbook.
  This really should be in a GNU include file though so that gdb can use
  the same info.  */
struct regs
{
  int r_psr;
  int r_pc;
  int r_npc;
  int r_y;
  int r_g1;
  int r_g2;
  int r_g3;
  int r_g4;
  int r_g5;
  int r_g6;
  int r_g7;
  int r_o0;
  int r_o1;
  int r_o2;
  int r_o3;
  int r_o4;
  int r_o5;
  int r_o6;
  int r_o7;
};

/* Taken from Sun documentation: */

/* FIXME:  It's worse than we expect.  This struct contains TWO substructs
  neither of whose size we know, WITH STUFF IN BETWEEN THEM!  We can't
  even portably access the stuff in between!  */

struct external_sparc_core
  {
    int c_magic;		/* Corefile magic number */
    int c_len;			/* Sizeof (struct core) */
#define	SPARC_CORE_LEN	432
    int c_regs[19];		/* General purpose registers -- MACHDEP SIZE */
    struct external_exec c_aouthdr;	/* A.out header */
    int c_signo;		/* Killing signal, if any */
    int c_tsize;		/* Text size (bytes) */
    int c_dsize;		/* Data size (bytes) */
    int c_ssize;		/* Stack size (bytes) */
    char c_cmdname[CORE_NAMELEN + 1];	/* Command name */
    double fp_stuff[1];		/* external FPU state (size unknown by us) */
    /* The type "double" is critical here, for alignment.
    SunOS declares a struct here, but the struct's alignment
      is double since it contains doubles.  */
    int c_ucode;		/* Exception no. from u_code */
    /* (this member is not accessible by name since we don't
    portably know the size of fp_stuff.) */
  };

/* Core files generated by the BCP (the part of Solaris which allows
   it to run SunOS4 a.out files).  */
struct external_solaris_bcp_core
  {
    int c_magic;		/* Corefile magic number */
    int c_len;			/* Sizeof (struct core) */
#define	SOLARIS_BCP_CORE_LEN	456
    int c_regs[19];		/* General purpose registers -- MACHDEP SIZE */
    int c_exdata_vp;		/* exdata structure */
    int c_exdata_tsize;
    int c_exdata_dsize;
    int c_exdata_bsize;
    int c_exdata_lsize;
    int c_exdata_nshlibs;
    short c_exdata_mach;
    short c_exdata_mag;
    int c_exdata_toffset;
    int c_exdata_doffset;
    int c_exdata_loffset;
    int c_exdata_txtorg;
    int c_exdata_datorg;
    int c_exdata_entloc;
    int c_signo;		/* Killing signal, if any */
    int c_tsize;		/* Text size (bytes) */
    int c_dsize;		/* Data size (bytes) */
    int c_ssize;		/* Stack size (bytes) */
    char c_cmdname[CORE_NAMELEN + 1];	/* Command name */
    double fp_stuff[1];		/* external FPU state (size unknown by us) */
    /* The type "double" is critical here, for alignment.
    SunOS declares a struct here, but the struct's alignment
      is double since it contains doubles.  */
    int c_ucode;		/* Exception no. from u_code */
    /* (this member is not accessible by name since we don't
    portably know the size of fp_stuff.) */
  };

struct external_sun3_core
  {
    int c_magic;		/* Corefile magic number */
    int c_len;			/* Sizeof (struct core) */
#define	SUN3_CORE_LEN	826	/* As of SunOS 4.1.1 */
    int c_regs[18];		/* General purpose registers -- MACHDEP SIZE */
    struct external_exec c_aouthdr;	/* A.out header */
    int c_signo;		/* Killing signal, if any */
    int c_tsize;		/* Text size (bytes) */
    int c_dsize;		/* Data size (bytes) */
    int c_ssize;		/* Stack size (bytes) */
    char c_cmdname[CORE_NAMELEN + 1];	/* Command name */
    double fp_stuff[1];		/* external FPU state (size unknown by us) */
    /* The type "double" is critical here, for alignment.
    SunOS declares a struct here, but the struct's alignment
      is double since it contains doubles.  */
    int c_ucode;		/* Exception no. from u_code */
    /* (this member is not accessible by name since we don't
    portably know the size of fp_stuff.) */
  };

struct internal_sunos_core
  {
    int c_magic;		/* Corefile magic number */
    int c_len;			/* Sizeof (struct core) */
    long c_regs_pos;		/* file offset of General purpose registers */
    int c_regs_size;		/* size of General purpose registers */
    struct internal_exec c_aouthdr;	/* A.out header */
    int c_signo;		/* Killing signal, if any */
    int c_tsize;		/* Text size (bytes) */
    int c_dsize;		/* Data size (bytes) */
    bfd_vma c_data_addr;	/* Data start (address) */
    int c_ssize;		/* Stack size (bytes) */
    bfd_vma c_stacktop;		/* Stack top (address) */
    char c_cmdname[CORE_NAMELEN + 1];	/* Command name */
    long fp_stuff_pos;		/* file offset of external FPU state (regs) */
    int fp_stuff_size;		/* Size of it */
    int c_ucode;		/* Exception no. from u_code */
  };

static void swapcore_sun3
  PARAMS ((bfd *, char *, struct internal_sunos_core *));
static void swapcore_sparc
  PARAMS ((bfd *, char *, struct internal_sunos_core *));
static void swapcore_solaris_bcp
  PARAMS ((bfd *, char *, struct internal_sunos_core *));

/* byte-swap in the Sun-3 core structure */
static void
swapcore_sun3 (abfd, ext, intcore)
     bfd *abfd;
     char *ext;
     struct internal_sunos_core *intcore;
{
  struct external_sun3_core *extcore = (struct external_sun3_core *) ext;

  intcore->c_magic = H_GET_32 (abfd, &extcore->c_magic);
  intcore->c_len = H_GET_32 (abfd, &extcore->c_len);
  intcore->c_regs_pos = (long) (((struct external_sun3_core *) 0)->c_regs);
  intcore->c_regs_size = sizeof (extcore->c_regs);
#if ARCH_SIZE == 64
  aout_64_swap_exec_header_in
#else
  aout_32_swap_exec_header_in
#endif
    (abfd, &extcore->c_aouthdr, &intcore->c_aouthdr);
  intcore->c_signo = H_GET_32 (abfd, &extcore->c_signo);
  intcore->c_tsize = H_GET_32 (abfd, &extcore->c_tsize);
  intcore->c_dsize = H_GET_32 (abfd, &extcore->c_dsize);
  intcore->c_data_addr = N_DATADDR (intcore->c_aouthdr);
  intcore->c_ssize = H_GET_32 (abfd, &extcore->c_ssize);
  memcpy (intcore->c_cmdname, extcore->c_cmdname, sizeof (intcore->c_cmdname));
  intcore->fp_stuff_pos = (long) (((struct external_sun3_core *) 0)->fp_stuff);
  /* FP stuff takes up whole rest of struct, except c_ucode.  */
  intcore->fp_stuff_size = intcore->c_len - (sizeof extcore->c_ucode) -
    (file_ptr) (((struct external_sun3_core *) 0)->fp_stuff);
  /* Ucode is the last thing in the struct -- just before the end */
  intcore->c_ucode = H_GET_32 (abfd,
			       (intcore->c_len
				- sizeof (extcore->c_ucode)
				+ (unsigned char *) extcore));
  intcore->c_stacktop = 0x0E000000;	/* By experimentation */
}

/* byte-swap in the Sparc core structure */
static void
swapcore_sparc (abfd, ext, intcore)
     bfd *abfd;
     char *ext;
     struct internal_sunos_core *intcore;
{
  struct external_sparc_core *extcore = (struct external_sparc_core *) ext;

  intcore->c_magic = H_GET_32 (abfd, &extcore->c_magic);
  intcore->c_len = H_GET_32 (abfd, &extcore->c_len);
  intcore->c_regs_pos = (long) (((struct external_sparc_core *) 0)->c_regs);
  intcore->c_regs_size = sizeof (extcore->c_regs);
#if ARCH_SIZE == 64
  aout_64_swap_exec_header_in
#else
  aout_32_swap_exec_header_in
#endif
    (abfd, &extcore->c_aouthdr, &intcore->c_aouthdr);
  intcore->c_signo = H_GET_32 (abfd, &extcore->c_signo);
  intcore->c_tsize = H_GET_32 (abfd, &extcore->c_tsize);
  intcore->c_dsize = H_GET_32 (abfd, &extcore->c_dsize);
  intcore->c_data_addr = N_DATADDR (intcore->c_aouthdr);
  intcore->c_ssize = H_GET_32 (abfd, &extcore->c_ssize);
  memcpy (intcore->c_cmdname, extcore->c_cmdname, sizeof (intcore->c_cmdname));
  intcore->fp_stuff_pos = (long) (((struct external_sparc_core *) 0)->fp_stuff);
  /* FP stuff takes up whole rest of struct, except c_ucode.  */
  intcore->fp_stuff_size = intcore->c_len - (sizeof extcore->c_ucode) -
    (file_ptr) (((struct external_sparc_core *) 0)->fp_stuff);
  /* Ucode is the last thing in the struct -- just before the end */
  intcore->c_ucode = H_GET_32 (abfd,
			       (intcore->c_len
				- sizeof (extcore->c_ucode)
				+ (unsigned char *) extcore));

  /* Supposedly the user stack grows downward from the bottom of kernel memory.
     Presuming that this remains true, this definition will work.  */
  /* Now sun has provided us with another challenge.  The value is different
     for sparc2 and sparc10 (both running SunOS 4.1.3).  We pick one or
     the other based on the current value of the stack pointer.  This
     loses (a) if the stack pointer has been clobbered, or (b) if the stack
     is larger than 128 megabytes.

     It's times like these you're glad they're switching to ELF.

     Note that using include files or nlist on /vmunix would be wrong,
     because we want the value for this core file, no matter what kind of
     machine we were compiled on or are running on.  */
#define SPARC_USRSTACK_SPARC2 ((bfd_vma)0xf8000000)
#define SPARC_USRSTACK_SPARC10 ((bfd_vma)0xf0000000)
  {
    bfd_vma sp = H_GET_32 (abfd, &((struct regs *) &extcore->c_regs[0])->r_o6);
    if (sp < SPARC_USRSTACK_SPARC10)
      intcore->c_stacktop = SPARC_USRSTACK_SPARC10;
    else
      intcore->c_stacktop = SPARC_USRSTACK_SPARC2;
  }
}

/* byte-swap in the Solaris BCP core structure */
static void
swapcore_solaris_bcp (abfd, ext, intcore)
     bfd *abfd;
     char *ext;
     struct internal_sunos_core *intcore;
{
  struct external_solaris_bcp_core *extcore =
    (struct external_solaris_bcp_core *) ext;

  intcore->c_magic = H_GET_32 (abfd, &extcore->c_magic);
  intcore->c_len = H_GET_32 (abfd, &extcore->c_len);
  intcore->c_regs_pos = (long) (((struct external_solaris_bcp_core *) 0)->c_regs);
  intcore->c_regs_size = sizeof (extcore->c_regs);

  /* The Solaris BCP exdata structure does not contain an a_syms field,
     so we are unable to synthesize an internal exec header.
     Luckily we are able to figure out the start address of the data section,
     which is the only thing needed from the internal exec header,
     from the exdata structure.

     As of Solaris 2.3, BCP core files for statically linked executables
     are buggy. The exdata structure is not properly filled in, and
     the data section is written from address zero instead of the data
     start address.  */
  memset ((PTR) &intcore->c_aouthdr, 0, sizeof (struct internal_exec));
  intcore->c_data_addr = H_GET_32 (abfd, &extcore->c_exdata_datorg);
  intcore->c_signo = H_GET_32 (abfd, &extcore->c_signo);
  intcore->c_tsize = H_GET_32 (abfd, &extcore->c_tsize);
  intcore->c_dsize = H_GET_32 (abfd, &extcore->c_dsize);
  intcore->c_ssize = H_GET_32 (abfd, &extcore->c_ssize);
  memcpy (intcore->c_cmdname, extcore->c_cmdname, sizeof (intcore->c_cmdname));
  intcore->fp_stuff_pos =
    (long) (((struct external_solaris_bcp_core *) 0)->fp_stuff);
  /* FP stuff takes up whole rest of struct, except c_ucode.  */
  intcore->fp_stuff_size = intcore->c_len - (sizeof extcore->c_ucode) -
    (file_ptr) (((struct external_solaris_bcp_core *) 0)->fp_stuff);
  /* Ucode is the last thing in the struct -- just before the end */
  intcore->c_ucode = H_GET_32 (abfd,
			       (intcore->c_len
				- sizeof (extcore->c_ucode)
				+ (unsigned char *) extcore));

  /* Supposedly the user stack grows downward from the bottom of kernel memory.
     Presuming that this remains true, this definition will work.  */
  /* Now sun has provided us with another challenge.  The value is different
     for sparc2 and sparc10 (both running SunOS 4.1.3).  We pick one or
     the other based on the current value of the stack pointer.  This
     loses (a) if the stack pointer has been clobbered, or (b) if the stack
     is larger than 128 megabytes.

     It's times like these you're glad they're switching to ELF.

     Note that using include files or nlist on /vmunix would be wrong,
     because we want the value for this core file, no matter what kind of
     machine we were compiled on or are running on.  */
#define SPARC_USRSTACK_SPARC2 ((bfd_vma)0xf8000000)
#define SPARC_USRSTACK_SPARC10 ((bfd_vma)0xf0000000)
  {
    bfd_vma sp = H_GET_32 (abfd, &((struct regs *) &extcore->c_regs[0])->r_o6);
    if (sp < SPARC_USRSTACK_SPARC10)
      intcore->c_stacktop = SPARC_USRSTACK_SPARC10;
    else
      intcore->c_stacktop = SPARC_USRSTACK_SPARC2;
  }
}

/* need this cast because ptr is really void * */
#define core_hdr(bfd) ((bfd)->tdata.sun_core_data)
#define core_datasec(bfd) (core_hdr(bfd)->data_section)
#define core_stacksec(bfd) (core_hdr(bfd)->stack_section)
#define core_regsec(bfd) (core_hdr(bfd)->reg_section)
#define core_reg2sec(bfd) (core_hdr(bfd)->reg2_section)

/* These are stored in the bfd's tdata */
struct sun_core_struct
{
  struct internal_sunos_core *hdr;	/* core file header */
  asection *data_section;
  asection *stack_section;
  asection *reg_section;
  asection *reg2_section;
};

static const bfd_target *
sunos4_core_file_p (abfd)
     bfd *abfd;
{
  unsigned char longbuf[4];	/* Raw bytes of various header fields */
  bfd_size_type core_size, amt;
  unsigned long core_mag;
  struct internal_sunos_core *core;
  char *extcore;
  struct mergem
    {
      struct sun_core_struct suncoredata;
      struct internal_sunos_core internal_sunos_core;
      char external_core[1];
    } *mergem;

  if (bfd_bread ((PTR) longbuf, (bfd_size_type) sizeof (longbuf), abfd)
      != sizeof (longbuf))
    return 0;
  core_mag = H_GET_32 (abfd, longbuf);

  if (core_mag != CORE_MAGIC)
    return 0;

  /* SunOS core headers can vary in length; second word is size; */
  if (bfd_bread ((PTR) longbuf, (bfd_size_type) sizeof (longbuf), abfd)
      != sizeof (longbuf))
    return 0;
  core_size = H_GET_32 (abfd, longbuf);
  /* Sanity check */
  if (core_size > 20000)
    return 0;

  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    return 0;

  amt = core_size + sizeof (struct mergem);
  mergem = (struct mergem *) bfd_zalloc (abfd, amt);
  if (mergem == NULL)
    return 0;

  extcore = mergem->external_core;

  if ((bfd_bread ((PTR) extcore, core_size, abfd)) != core_size)
    {
    loser:
      bfd_release (abfd, (char *) mergem);
      abfd->tdata.any = NULL;
      bfd_section_list_clear (abfd);
      return 0;
    }

  /* Validate that it's a core file we know how to handle, due to sun
     botching the positioning of registers and other fields in a machine
     dependent way.  */
  core = &mergem->internal_sunos_core;
  switch (core_size)
    {
    case SPARC_CORE_LEN:
      swapcore_sparc (abfd, extcore, core);
      break;
    case SUN3_CORE_LEN:
      swapcore_sun3 (abfd, extcore, core);
      break;
    case SOLARIS_BCP_CORE_LEN:
      swapcore_solaris_bcp (abfd, extcore, core);
      break;
    default:
      bfd_set_error (bfd_error_system_call);	/* FIXME */
      goto loser;
    }

  abfd->tdata.sun_core_data = &mergem->suncoredata;
  abfd->tdata.sun_core_data->hdr = core;

  /* Create the sections.  */
  core_stacksec (abfd) = bfd_make_section_anyway (abfd, ".stack");
  if (core_stacksec (abfd) == NULL)
    /* bfd_release frees everything allocated after it's arg.  */
    goto loser;

  core_datasec (abfd) = bfd_make_section_anyway (abfd, ".data");
  if (core_datasec (abfd) == NULL)
    goto loser;

  core_regsec (abfd) = bfd_make_section_anyway (abfd, ".reg");
  if (core_regsec (abfd) == NULL)
    goto loser;

  core_reg2sec (abfd) = bfd_make_section_anyway (abfd, ".reg2");
  if (core_reg2sec (abfd) == NULL)
    goto loser;

  core_stacksec (abfd)->flags = SEC_ALLOC + SEC_LOAD + SEC_HAS_CONTENTS;
  core_datasec (abfd)->flags = SEC_ALLOC + SEC_LOAD + SEC_HAS_CONTENTS;
  core_regsec (abfd)->flags = SEC_HAS_CONTENTS;
  core_reg2sec (abfd)->flags = SEC_HAS_CONTENTS;

  core_stacksec (abfd)->_raw_size = core->c_ssize;
  core_datasec (abfd)->_raw_size = core->c_dsize;
  core_regsec (abfd)->_raw_size = core->c_regs_size;
  core_reg2sec (abfd)->_raw_size = core->fp_stuff_size;

  core_stacksec (abfd)->vma = (core->c_stacktop - core->c_ssize);
  core_datasec (abfd)->vma = core->c_data_addr;
  core_regsec (abfd)->vma = 0;
  core_reg2sec (abfd)->vma = 0;

  core_stacksec (abfd)->filepos = core->c_len + core->c_dsize;
  core_datasec (abfd)->filepos = core->c_len;
  /* We'll access the regs afresh in the core file, like any section: */
  core_regsec (abfd)->filepos = (file_ptr) core->c_regs_pos;
  core_reg2sec (abfd)->filepos = (file_ptr) core->fp_stuff_pos;

  /* Align to word at least */
  core_stacksec (abfd)->alignment_power = 2;
  core_datasec (abfd)->alignment_power = 2;
  core_regsec (abfd)->alignment_power = 2;
  core_reg2sec (abfd)->alignment_power = 2;

  return abfd->xvec;
}

static char *
sunos4_core_file_failing_command (abfd)
     bfd *abfd;
{
  return core_hdr (abfd)->hdr->c_cmdname;
}

static int
sunos4_core_file_failing_signal (abfd)
     bfd *abfd;
{
  return core_hdr (abfd)->hdr->c_signo;
}

static bfd_boolean
sunos4_core_file_matches_executable_p (core_bfd, exec_bfd)
     bfd *core_bfd;
     bfd *exec_bfd;
{
  if (core_bfd->xvec != exec_bfd->xvec)
    {
      bfd_set_error (bfd_error_system_call);
      return FALSE;
    }

  /* Solaris core files do not include an aouthdr.  */
  if ((core_hdr (core_bfd)->hdr)->c_len == SOLARIS_BCP_CORE_LEN)
    return TRUE;

  return (memcmp ((char *) &((core_hdr (core_bfd)->hdr)->c_aouthdr),
		  (char *) exec_hdr (exec_bfd),
		  sizeof (struct internal_exec)) == 0);
}

#define MY_set_sizes sunos4_set_sizes
static bfd_boolean
sunos4_set_sizes (abfd)
     bfd *abfd;
{
  switch (bfd_get_arch (abfd))
    {
    default:
      return FALSE;
    case bfd_arch_sparc:
      adata (abfd).page_size = 0x2000;
      adata (abfd).segment_size = 0x2000;
      adata (abfd).exec_bytes_size = EXEC_BYTES_SIZE;
      return TRUE;
    case bfd_arch_m68k:
      adata (abfd).page_size = 0x2000;
      adata (abfd).segment_size = 0x20000;
      adata (abfd).exec_bytes_size = EXEC_BYTES_SIZE;
      return TRUE;
    }
}

/* We default to setting the toolversion field to 1, as is required by
   SunOS.  */
#ifndef MY_exec_hdr_flags
#define MY_exec_hdr_flags 1
#endif

#ifndef MY_entry_is_text_address
#define MY_entry_is_text_address 0
#endif
#ifndef MY_add_dynamic_symbols
#define MY_add_dynamic_symbols 0
#endif
#ifndef MY_add_one_symbol
#define MY_add_one_symbol 0
#endif
#ifndef MY_link_dynamic_object
#define MY_link_dynamic_object 0
#endif
#ifndef MY_write_dynamic_symbol
#define MY_write_dynamic_symbol 0
#endif
#ifndef MY_check_dynamic_reloc
#define MY_check_dynamic_reloc 0
#endif
#ifndef MY_finish_dynamic_link
#define MY_finish_dynamic_link 0
#endif

static const struct aout_backend_data sunos4_aout_backend =
{
  0,				/* zmagic files are not contiguous */
  1,				/* text includes header */
  MY_entry_is_text_address,
  MY_exec_hdr_flags,
  0,				/* default text vma */
  sunos4_set_sizes,
  0,				/* header is counted in zmagic text */
  MY_add_dynamic_symbols,
  MY_add_one_symbol,
  MY_link_dynamic_object,
  MY_write_dynamic_symbol,
  MY_check_dynamic_reloc,
  MY_finish_dynamic_link
};

#define	MY_core_file_failing_command 	sunos4_core_file_failing_command
#define	MY_core_file_failing_signal	sunos4_core_file_failing_signal
#define	MY_core_file_matches_executable_p sunos4_core_file_matches_executable_p

#define MY_bfd_debug_info_start		bfd_void
#define MY_bfd_debug_info_end		bfd_void
#define MY_bfd_debug_info_accumulate	\
		(void (*) PARAMS ((bfd *, struct bfd_section *))) bfd_void
#define MY_core_file_p			sunos4_core_file_p
#define MY_write_object_contents	NAME(aout,sunos4_write_object_contents)
#define MY_backend_data			&sunos4_aout_backend

#ifndef TARGET_IS_LITTLE_ENDIAN_P
#define TARGET_IS_BIG_ENDIAN_P
#endif

#include "aout-target.h"
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2001, 2002
d837 1
a837 1
			(void (*) PARAMS ((bfd *, struct sec *))) bfd_void
@


1.6
log
@resolve conflicts.
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000
d78 18
a95 9
static boolean sunos_merge_private_bfd_data PARAMS ((bfd *, bfd *));
static void sunos_set_arch_mach PARAMS ((bfd *, int));
static void choose_reloc_size PARAMS ((bfd *));
static boolean sunos_write_object_contents PARAMS ((bfd *));
static const bfd_target *sunos4_core_file_p PARAMS ((bfd *));
static char *sunos4_core_file_failing_command PARAMS ((bfd *));
static int sunos4_core_file_failing_signal PARAMS ((bfd *));
static boolean sunos4_core_file_matches_executable_p PARAMS ((bfd *, bfd *));
static boolean sunos4_set_sizes PARAMS ((bfd *));
d103 1
a103 1
static boolean
d109 1
a109 1
    return true;
d117 1
a117 1
  return true;
d126 1
a126 1
     int machtype;
d130 1
a130 1
  long machine;
d219 1
a219 1
static boolean
d272 1
a272 1
  N_SET_DYNAMIC (*execp, bfd_get_file_flags (abfd) & DYNAMIC);
d276 1
a276 1
  return true;
d435 2
a436 2
  intcore->c_magic = bfd_h_get_32 (abfd, (unsigned char *) &extcore->c_magic);
  intcore->c_len = bfd_h_get_32 (abfd, (unsigned char *) &extcore->c_len);
d445 3
a447 3
  intcore->c_signo = bfd_h_get_32 (abfd, (unsigned char *) &extcore->c_signo);
  intcore->c_tsize = bfd_h_get_32 (abfd, (unsigned char *) &extcore->c_tsize);
  intcore->c_dsize = bfd_h_get_32 (abfd, (unsigned char *) &extcore->c_dsize);
d449 1
a449 1
  intcore->c_ssize = bfd_h_get_32 (abfd, (unsigned char *) &extcore->c_ssize);
d456 4
a459 3
  intcore->c_ucode =
    bfd_h_get_32 (abfd,
    intcore->c_len - sizeof (extcore->c_ucode) + (unsigned char *) extcore);
d472 2
a473 2
  intcore->c_magic = bfd_h_get_32 (abfd, (unsigned char *) &extcore->c_magic);
  intcore->c_len = bfd_h_get_32 (abfd, (unsigned char *) &extcore->c_len);
d482 3
a484 3
  intcore->c_signo = bfd_h_get_32 (abfd, (unsigned char *) &extcore->c_signo);
  intcore->c_tsize = bfd_h_get_32 (abfd, (unsigned char *) &extcore->c_tsize);
  intcore->c_dsize = bfd_h_get_32 (abfd, (unsigned char *) &extcore->c_dsize);
d486 1
a486 1
  intcore->c_ssize = bfd_h_get_32 (abfd, (unsigned char *) &extcore->c_ssize);
d493 4
a496 3
  intcore->c_ucode =
    bfd_h_get_32 (abfd,
    intcore->c_len - sizeof (extcore->c_ucode) + (unsigned char *) extcore);
d514 1
a514 2
    bfd_vma sp = bfd_h_get_32
    (abfd, (unsigned char *) &((struct regs *) &extcore->c_regs[0])->r_o6);
d532 2
a533 2
  intcore->c_magic = bfd_h_get_32 (abfd, (unsigned char *) &extcore->c_magic);
  intcore->c_len = bfd_h_get_32 (abfd, (unsigned char *) &extcore->c_len);
d548 5
a552 6
  intcore->c_data_addr =
    bfd_h_get_32 (abfd, (unsigned char *) &extcore->c_exdata_datorg);
  intcore->c_signo = bfd_h_get_32 (abfd, (unsigned char *) &extcore->c_signo);
  intcore->c_tsize = bfd_h_get_32 (abfd, (unsigned char *) &extcore->c_tsize);
  intcore->c_dsize = bfd_h_get_32 (abfd, (unsigned char *) &extcore->c_dsize);
  intcore->c_ssize = bfd_h_get_32 (abfd, (unsigned char *) &extcore->c_ssize);
d560 4
a563 3
  intcore->c_ucode =
    bfd_h_get_32 (abfd,
    intcore->c_len - sizeof (extcore->c_ucode) + (unsigned char *) extcore);
d581 1
a581 2
    bfd_vma sp = bfd_h_get_32
    (abfd, (unsigned char *) &((struct regs *) &extcore->c_regs[0])->r_o6);
d611 1
a611 1
  bfd_size_type core_size;
d620 1
a620 2
    }
   *mergem;
d622 2
a623 2
  if (bfd_read ((PTR) longbuf, 1, sizeof (longbuf), abfd) !=
      sizeof (longbuf))
d625 1
a625 1
  core_mag = bfd_h_get_32 (abfd, longbuf);
d631 2
a632 2
  if (bfd_read ((PTR) longbuf, 1, sizeof (longbuf), abfd) !=
      sizeof (longbuf))
d634 1
a634 1
  core_size = bfd_h_get_32 (abfd, longbuf);
d639 1
a639 1
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) < 0)
d642 2
a643 1
  mergem = (struct mergem *) bfd_zalloc (abfd, core_size + sizeof (struct mergem));
d649 1
a649 1
  if ((bfd_read ((PTR) extcore, 1, core_size, abfd)) != core_size)
d651 1
d653 2
d675 1
a675 2
      bfd_release (abfd, (char *) mergem);
      return 0;
d681 2
a682 3
  /* create the sections.  This is raunchy, but bfd_close wants to reclaim
     them */
  core_stacksec (abfd) = (asection *) bfd_zalloc (abfd, sizeof (asection));
d684 4
a687 6
    {
    loser:
      bfd_release (abfd, (char *) mergem);
      return 0;
    }
  core_datasec (abfd) = (asection *) bfd_zalloc (abfd, sizeof (asection));
d689 3
a691 6
    {
    loser1:
      bfd_release (abfd, core_stacksec (abfd));
      goto loser;
    }
  core_regsec (abfd) = (asection *) bfd_zalloc (abfd, sizeof (asection));
d693 3
a695 6
    {
    loser2:
      bfd_release (abfd, core_datasec (abfd));
      goto loser1;
    }
  core_reg2sec (abfd) = (asection *) bfd_zalloc (abfd, sizeof (asection));
d697 1
a697 9
    {
      bfd_release (abfd, core_regsec (abfd));
      goto loser2;
    }

  core_stacksec (abfd)->name = ".stack";
  core_datasec (abfd)->name = ".data";
  core_regsec (abfd)->name = ".reg";
  core_reg2sec (abfd)->name = ".reg2";
a725 7
  abfd->sections = core_stacksec (abfd);
  core_stacksec (abfd)->next = core_datasec (abfd);
  core_datasec (abfd)->next = core_regsec (abfd);
  core_regsec (abfd)->next = core_reg2sec (abfd);

  abfd->section_count = 4;

d743 1
a743 1
static boolean
d751 1
a751 1
      return false;
d756 1
a756 1
    return true;
d760 1
a760 1
		  sizeof (struct internal_exec)) == 0) ? true : false;
d764 1
a764 1
static boolean
d771 1
a771 1
      return false;
d776 1
a776 1
      return true;
d781 1
a781 1
      return true;
d813 1
a813 1
static CONST struct aout_backend_data sunos4_aout_backend =
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 1998
d36 1
a36 1
   probably no longer reject a NewsOS object.  <ian@@cygnus.com>. */
d126 1
a126 1
	 we'll default to the 68000. */
d183 1
a183 1
  NAME(sunos,set_arch_mach)(ABFD, N_MACHTYPE (EXEC)); \
d278 1
a278 1
  so far we don't use but is easy to find with a little arithmetic. */
d282 1
a282 1
  the same info. */
d442 1
a442 1
  /* FP stuff takes up whole rest of struct, except c_ucode. */
a451 1

d478 1
a478 1
  /* FP stuff takes up whole rest of struct, except c_ucode. */
d546 1
a546 1
  /* FP stuff takes up whole rest of struct, except c_ucode. */
d766 1
a766 1
  /* Solaris core files do not include an aouthdr. */
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1993, 1996 Free Software Foundation, Inc.
d69 18
d110 3
d114 1
a114 6
#if ARCH_SIZE == 64
sunos_64_set_arch_mach
#else
sunos_32_set_arch_mach
#endif
  (abfd, machtype)
d128 1
a128 1
      machine = 68000;
d134 1
a134 1
      machine = 68010;
d140 1
a140 1
      machine = 68020;
d153 5
d203 5
a207 3
/* Write an object file in SunOS format.
  Section contents have already been written.  We write the
  file header, symbols, and relocation.  */
d210 1
a210 6
#if ARCH_SIZE == 64
aout_64_sunos4_write_object_contents
#else
aout_32_sunos4_write_object_contents
#endif
  (abfd)
d222 1
a222 1
	case 68000:
d225 1
a225 1
	case 68010:
d229 1
a229 1
	case 68020:
d240 3
d409 7
d804 3
d830 1
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d68 23
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
d799 1
d801 1
@


1.1
log
@Initial revision
@
text
@d108 5
d193 9
a201 1
      N_SET_MACHTYPE (*execp, M_SPARC);
d584 1
a584 4
    {
      bfd_set_error (bfd_error_no_memory);
      return 0;
    }
a623 1
      bfd_set_error (bfd_error_no_memory);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@a107 5
    case M_SPARCLET:
      arch = bfd_arch_sparc;
      machine = bfd_mach_sparc_sparclet;
      break;

d188 1
a188 9
      switch (bfd_get_mach (abfd))
	{
	case bfd_mach_sparc_sparclet:
	  N_SET_MACHTYPE (*execp, M_SPARCLET);
	  break;
	default:
	  N_SET_MACHTYPE (*execp, M_SPARC);
	  break;
	}
d571 4
a574 1
    return 0;
d614 1
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1996 Free Software Foundation, Inc.
a798 1
#ifndef TARGET_IS_LITTLE_ENDIAN_P
a799 1
#endif
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a67 23
/* Merge backend data into the output file.
   This is necessary on sparclet-aout where we want the resultant machine
   number to be M_SPARCLET if any input file is M_SPARCLET.  */

#define MY_bfd_merge_private_bfd_data sunos_merge_private_bfd_data

static boolean
sunos_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd, *obfd;
{
  if (bfd_get_flavour (ibfd) != bfd_target_aout_flavour
      || bfd_get_flavour (obfd) != bfd_target_aout_flavour)
    return true;

  if (bfd_get_arch (obfd) == bfd_arch_sparc)
    {
      if (bfd_get_mach (obfd) < bfd_get_mach (ibfd))
	bfd_set_arch_mach (obfd, bfd_arch_sparc, bfd_get_mach (ibfd));
    }

  return true;
}

@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
a67 18
#if ARCH_SIZE == 64
#define sunos_set_arch_mach sunos_64_set_arch_mach
#define sunos_write_object_contents aout_64_sunos4_write_object_contents
#else
#define sunos_set_arch_mach sunos_32_set_arch_mach
#define sunos_write_object_contents aout_32_sunos4_write_object_contents
#endif

static boolean sunos_merge_private_bfd_data PARAMS ((bfd *, bfd *));
static void sunos_set_arch_mach PARAMS ((bfd *, int));
static void choose_reloc_size PARAMS ((bfd *));
static boolean sunos_write_object_contents PARAMS ((bfd *));
static const bfd_target *sunos4_core_file_p PARAMS ((bfd *));
static char *sunos4_core_file_failing_command PARAMS ((bfd *));
static int sunos4_core_file_failing_signal PARAMS ((bfd *));
static boolean sunos4_core_file_matches_executable_p PARAMS ((bfd *, bfd *));
static boolean sunos4_set_sizes PARAMS ((bfd *));

a90 3
/* This is either sunos_32_set_arch_mach or sunos_64_set_arch_mach,
   depending upon ARCH_SIZE.  */

d92 6
a97 1
sunos_set_arch_mach (abfd, machtype)
d181 3
a183 5
/* Write an object file in SunOS format.  Section contents have
   already been written.  We write the file header, symbols, and
   relocation.  The real name of this function is either
   aout_64_sunos4_write_object_contents or
   aout_32_sunos4_write_object_contents, depending upon ARCH_SIZE.  */
d186 6
a191 1
sunos_write_object_contents (abfd)
a386 7
static void swapcore_sun3
  PARAMS ((bfd *, char *, struct internal_sunos_core *));
static void swapcore_sparc
  PARAMS ((bfd *, char *, struct internal_sunos_core *));
static void swapcore_solaris_bcp
  PARAMS ((bfd *, char *, struct internal_sunos_core *));

a774 3
#ifndef MY_entry_is_text_address
#define MY_entry_is_text_address 0
#endif
a797 1
  MY_entry_is_text_address,
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 1998
   Free Software Foundation, Inc.
d127 1
a127 1
      machine = bfd_mach_m68000;
d133 1
a133 1
      machine = bfd_mach_m68010;
d139 1
a139 1
      machine = bfd_mach_m68020;
a151 5
    case M_SPARCLITE_LE:
      arch = bfd_arch_sparc;
      machine = bfd_mach_sparc_sparclite_le;
      break;

d216 1
a216 1
	case bfd_mach_m68000:
d219 1
a219 1
	case bfd_mach_m68010:
d223 1
a223 1
	case bfd_mach_m68020:
a232 3
	  break;
	case bfd_mach_sparc_sparclite_le:
	  N_SET_MACHTYPE (*execp, M_SPARCLITE_LE);
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000
d36 1
a36 1
   probably no longer reject a NewsOS object.  <ian@@cygnus.com>.  */
d126 1
a126 1
	 we'll default to the 68000.  */
d183 1
a183 1
  NAME(sunos,set_arch_mach) (ABFD, N_MACHTYPE (EXEC)); \
d278 1
a278 1
  so far we don't use but is easy to find with a little arithmetic.  */
d282 1
a282 1
  the same info.  */
d442 1
a442 1
  /* FP stuff takes up whole rest of struct, except c_ucode.  */
d452 1
d479 1
a479 1
  /* FP stuff takes up whole rest of struct, except c_ucode.  */
d547 1
a547 1
  /* FP stuff takes up whole rest of struct, except c_ucode.  */
d767 1
a767 1
  /* Solaris core files do not include an aouthdr.  */
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000,
   2001, 2002
d77 9
a85 18
static bfd_boolean sunos_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));
static void sunos_set_arch_mach
  PARAMS ((bfd *, enum machine_type));
static void choose_reloc_size
  PARAMS ((bfd *));
static bfd_boolean sunos_write_object_contents
  PARAMS ((bfd *));
static const bfd_target *sunos4_core_file_p
  PARAMS ((bfd *));
static char *sunos4_core_file_failing_command
  PARAMS ((bfd *));
static int sunos4_core_file_failing_signal
  PARAMS ((bfd *));
static bfd_boolean sunos4_core_file_matches_executable_p
  PARAMS ((bfd *, bfd *));
static bfd_boolean sunos4_set_sizes
  PARAMS ((bfd *));
d93 1
a93 1
static bfd_boolean
d99 1
a99 1
    return TRUE;
d107 1
a107 1
  return TRUE;
d116 1
a116 1
     enum machine_type machtype;
d120 1
a120 1
  unsigned long machine;
d209 1
a209 1
static bfd_boolean
d262 1
a262 1
  N_SET_DYNAMIC (*execp, (long)(bfd_get_file_flags (abfd) & DYNAMIC));
d266 1
a266 1
  return TRUE;
d425 2
a426 2
  intcore->c_magic = H_GET_32 (abfd, &extcore->c_magic);
  intcore->c_len = H_GET_32 (abfd, &extcore->c_len);
d435 3
a437 3
  intcore->c_signo = H_GET_32 (abfd, &extcore->c_signo);
  intcore->c_tsize = H_GET_32 (abfd, &extcore->c_tsize);
  intcore->c_dsize = H_GET_32 (abfd, &extcore->c_dsize);
d439 1
a439 1
  intcore->c_ssize = H_GET_32 (abfd, &extcore->c_ssize);
d446 3
a448 4
  intcore->c_ucode = H_GET_32 (abfd,
			       (intcore->c_len
				- sizeof (extcore->c_ucode)
				+ (unsigned char *) extcore));
d461 2
a462 2
  intcore->c_magic = H_GET_32 (abfd, &extcore->c_magic);
  intcore->c_len = H_GET_32 (abfd, &extcore->c_len);
d471 3
a473 3
  intcore->c_signo = H_GET_32 (abfd, &extcore->c_signo);
  intcore->c_tsize = H_GET_32 (abfd, &extcore->c_tsize);
  intcore->c_dsize = H_GET_32 (abfd, &extcore->c_dsize);
d475 1
a475 1
  intcore->c_ssize = H_GET_32 (abfd, &extcore->c_ssize);
d482 3
a484 4
  intcore->c_ucode = H_GET_32 (abfd,
			       (intcore->c_len
				- sizeof (extcore->c_ucode)
				+ (unsigned char *) extcore));
d502 2
a503 1
    bfd_vma sp = H_GET_32 (abfd, &((struct regs *) &extcore->c_regs[0])->r_o6);
d521 2
a522 2
  intcore->c_magic = H_GET_32 (abfd, &extcore->c_magic);
  intcore->c_len = H_GET_32 (abfd, &extcore->c_len);
d537 6
a542 5
  intcore->c_data_addr = H_GET_32 (abfd, &extcore->c_exdata_datorg);
  intcore->c_signo = H_GET_32 (abfd, &extcore->c_signo);
  intcore->c_tsize = H_GET_32 (abfd, &extcore->c_tsize);
  intcore->c_dsize = H_GET_32 (abfd, &extcore->c_dsize);
  intcore->c_ssize = H_GET_32 (abfd, &extcore->c_ssize);
d550 3
a552 4
  intcore->c_ucode = H_GET_32 (abfd,
			       (intcore->c_len
				- sizeof (extcore->c_ucode)
				+ (unsigned char *) extcore));
d570 2
a571 1
    bfd_vma sp = H_GET_32 (abfd, &((struct regs *) &extcore->c_regs[0])->r_o6);
d601 1
a601 1
  bfd_size_type core_size, amt;
d610 2
a611 1
    } *mergem;
d613 2
a614 2
  if (bfd_bread ((PTR) longbuf, (bfd_size_type) sizeof (longbuf), abfd)
      != sizeof (longbuf))
d616 1
a616 1
  core_mag = H_GET_32 (abfd, longbuf);
d622 2
a623 2
  if (bfd_bread ((PTR) longbuf, (bfd_size_type) sizeof (longbuf), abfd)
      != sizeof (longbuf))
d625 1
a625 1
  core_size = H_GET_32 (abfd, longbuf);
d630 1
a630 1
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
d633 1
a633 2
  amt = core_size + sizeof (struct mergem);
  mergem = (struct mergem *) bfd_zalloc (abfd, amt);
d639 1
a639 1
  if ((bfd_bread ((PTR) extcore, core_size, abfd)) != core_size)
a640 1
    loser:
a641 2
      abfd->tdata.any = NULL;
      bfd_section_list_clear (abfd);
d662 2
a663 1
      goto loser;
d669 3
a671 2
  /* Create the sections.  */
  core_stacksec (abfd) = bfd_make_section_anyway (abfd, ".stack");
d673 6
a678 4
    /* bfd_release frees everything allocated after it's arg.  */
    goto loser;

  core_datasec (abfd) = bfd_make_section_anyway (abfd, ".data");
d680 6
a685 3
    goto loser;

  core_regsec (abfd) = bfd_make_section_anyway (abfd, ".reg");
d687 11
a697 1
    goto loser;
d699 4
a702 3
  core_reg2sec (abfd) = bfd_make_section_anyway (abfd, ".reg2");
  if (core_reg2sec (abfd) == NULL)
    goto loser;
d731 7
d755 1
a755 1
static bfd_boolean
d763 1
a763 1
      return FALSE;
d768 1
a768 1
    return TRUE;
d772 1
a772 1
		  sizeof (struct internal_exec)) == 0);
d776 1
a776 1
static bfd_boolean
d783 1
a783 1
      return FALSE;
d788 1
a788 1
      return TRUE;
d793 1
a793 1
      return TRUE;
d825 1
a825 1
static const struct aout_backend_data sunos4_aout_backend =
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2001, 2002, 2003
d837 1
a837 1
		(void (*) PARAMS ((bfd *, struct bfd_section *))) bfd_void
@


