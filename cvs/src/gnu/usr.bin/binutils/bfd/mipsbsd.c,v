head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.48
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.44
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.46
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.38
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.42
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.40
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.11.02.20.45.11;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.17.21.54.23;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.30;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.20;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.46.16;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.01;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.01;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.06.09;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.20.12;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.45.50;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.26.49;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.19;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.22.31;	author miod;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD backend for MIPS BSD (a.out) binaries.
   Copyright 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Written by Ralph Campbell.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* #define ENTRY_CAN_BE_ZERO */
#define N_HEADER_IN_TEXT(x) 1
#define N_SHARED_LIB(x) 0
#define N_TXTADDR(x) \
    (N_MAGIC(x) != ZMAGIC ? (x).a_entry :	/* object file or NMAGIC */\
	    TEXT_START_ADDR + EXEC_BYTES_SIZE	/* no padding */\
    )
#define N_DATADDR(x) (N_TXTADDR(x)+N_TXTSIZE(x))
#define TEXT_START_ADDR 4096
#define TARGET_PAGE_SIZE 4096
#define SEGMENT_SIZE TARGET_PAGE_SIZE
#define DEFAULT_ARCH bfd_arch_mips
#define MACHTYPE_OK(mtype) ((mtype) == M_UNKNOWN \
			    || (mtype) == M_MIPS1 || (mtype) == M_MIPS2)
#define MY_symbol_leading_char '\0'

/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
#define MY(OP) CONCAT2 (mipsbsd_,OP)

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "libaout.h"

#define SET_ARCH_MACH(ABFD, EXEC) \
  MY(set_arch_mach) (ABFD, N_MACHTYPE (EXEC)); \
  MY(choose_reloc_size) (ABFD);
static void MY(set_arch_mach) PARAMS ((bfd *abfd, unsigned long machtype));
static void MY(choose_reloc_size) PARAMS ((bfd *abfd));

#define MY_write_object_contents MY(write_object_contents)
static bfd_boolean MY(write_object_contents) PARAMS ((bfd *abfd));

/* We can't use MY(x) here because it leads to a recursive call to CONCAT2
   when expanded inside JUMP_TABLE.  */
#define MY_bfd_reloc_type_lookup mipsbsd_reloc_howto_type_lookup
#define MY_canonicalize_reloc mipsbsd_canonicalize_reloc

#define MY_bfd_link_hash_table_create _bfd_generic_link_hash_table_create
#define MY_bfd_link_add_symbols _bfd_generic_link_add_symbols
#define MY_final_link_callback unused
#define MY_bfd_final_link _bfd_generic_final_link

#define MY_backend_data &MY(backend_data)
#define MY_BFD_TARGET

#include "aout-target.h"

static bfd_reloc_status_type mips_fix_jmp_addr
  PARAMS ((bfd *, arelent *, struct bfd_symbol *, PTR, asection *,
	   bfd *, char **));
static reloc_howto_type *MY(reloc_howto_type_lookup)
  PARAMS ((bfd *, bfd_reloc_code_real_type));

long MY(canonicalize_reloc) PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));

static void
MY(set_arch_mach) (abfd, machtype)
     bfd *abfd;
     unsigned long machtype;
{
  enum bfd_architecture arch;
  unsigned int machine;

  /* Determine the architecture and machine type of the object file.  */
  switch (machtype)
    {
    case M_MIPS1:
      arch = bfd_arch_mips;
      machine = bfd_mach_mips3000;
      break;

    case M_MIPS2:
      arch = bfd_arch_mips;
      machine = bfd_mach_mips4000;
      break;

    default:
      arch = bfd_arch_obscure;
      machine = 0;
      break;
    }

  bfd_set_arch_mach (abfd, arch, machine);
}

/* Determine the size of a relocation entry, based on the architecture */
static void
MY (choose_reloc_size) (abfd)
     bfd *abfd;
{
  switch (bfd_get_arch (abfd))
    {
    case bfd_arch_sparc:
    case bfd_arch_a29k:
    case bfd_arch_mips:
      obj_reloc_entry_size (abfd) = RELOC_EXT_SIZE;
      break;
    default:
      obj_reloc_entry_size (abfd) = RELOC_STD_SIZE;
      break;
    }
}

/* Write an object file in BSD a.out format.
  Section contents have already been written.  We write the
  file header, symbols, and relocation.  */

static bfd_boolean
MY (write_object_contents) (abfd)
     bfd *abfd;
{
  struct external_exec exec_bytes;
  struct internal_exec *execp = exec_hdr (abfd);

  /* Magic number, maestro, please!  */
  switch (bfd_get_arch (abfd))
    {
    case bfd_arch_m68k:
      switch (bfd_get_mach (abfd))
	{
	case bfd_mach_m68010:
	  N_SET_MACHTYPE (*execp, M_68010);
	  break;
	default:
	case bfd_mach_m68020:
	  N_SET_MACHTYPE (*execp, M_68020);
	  break;
	}
      break;
    case bfd_arch_sparc:
      N_SET_MACHTYPE (*execp, M_SPARC);
      break;
    case bfd_arch_i386:
      N_SET_MACHTYPE (*execp, M_386);
      break;
    case bfd_arch_a29k:
      N_SET_MACHTYPE (*execp, M_29K);
      break;
    case bfd_arch_mips:
      switch (bfd_get_mach (abfd))
	{
	case bfd_mach_mips4000:
	case bfd_mach_mips6000:
	  N_SET_MACHTYPE (*execp, M_MIPS2);
	  break;
	default:
	  N_SET_MACHTYPE (*execp, M_MIPS1);
	  break;
	}
      break;
    default:
      N_SET_MACHTYPE (*execp, M_UNKNOWN);
    }

  MY (choose_reloc_size) (abfd);

  WRITE_HEADERS (abfd, execp);

  return TRUE;
}

/* MIPS relocation types.  */
#define MIPS_RELOC_32		0
#define MIPS_RELOC_JMP		1
#define MIPS_RELOC_WDISP16	2
#define MIPS_RELOC_HI16		3
#define MIPS_RELOC_HI16_S	4
#define MIPS_RELOC_LO16		5

/* This is only called when performing a BFD_RELOC_MIPS_JMP relocation.
   The jump destination address is formed from the upper 4 bits of the
   "current" program counter concatenated with the jump instruction's
   26 bit field and two trailing zeros.
   If the destination address is not in the same segment as the "current"
   program counter, then we need to signal an error.  */

static bfd_reloc_status_type
mips_fix_jmp_addr (abfd, reloc_entry, symbol, data, input_section, output_bfd,
		   error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     struct bfd_symbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  bfd_vma relocation, pc;

  /* If this is a partial relocation, just continue.  */
  if (output_bfd != (bfd *)NULL)
    return bfd_reloc_continue;

  /* If this is an undefined symbol, return error */
  if (bfd_is_und_section (symbol->section)
      && (symbol->flags & BSF_WEAK) == 0)
    return bfd_reloc_undefined;

  /* Work out which section the relocation is targeted at and the
     initial relocation command value.  */
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;

  pc = input_section->output_section->vma + input_section->output_offset +
    reloc_entry->address + 4;

  if ((relocation & 0xF0000000) != (pc & 0xF0000000))
    return bfd_reloc_overflow;

  return bfd_reloc_continue;
}

/* This is only called when performing a BFD_RELOC_HI16_S relocation.
   We need to see if bit 15 is set in the result. If it is, we add
   0x10000 and continue normally. This will compensate for the sign extension
   when the low bits are added at run time.  */

static bfd_reloc_status_type
mips_fix_hi16_s PARAMS ((bfd *, arelent *, asymbol *, PTR,
			 asection *, bfd *, char **));

static bfd_reloc_status_type
mips_fix_hi16_s (abfd, reloc_entry, symbol, data, input_section,
		 output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  bfd_vma relocation;

  /* If this is a partial relocation, just continue.  */
  if (output_bfd != (bfd *)NULL)
    return bfd_reloc_continue;

  /* If this is an undefined symbol, return error.  */
  if (bfd_is_und_section (symbol->section)
      && (symbol->flags & BSF_WEAK) == 0)
    return bfd_reloc_undefined;

  /* Work out which section the relocation is targeted at and the
     initial relocation command value.  */
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;

  if (relocation & 0x8000)
    reloc_entry->addend += 0x10000;

  return bfd_reloc_continue;
}

static reloc_howto_type mips_howto_table_ext[] = {
  {MIPS_RELOC_32,      0, 2, 32, FALSE, 0,  complain_overflow_bitfield, 0,
	"32",       FALSE, 0, 0xffffffff, FALSE},
  {MIPS_RELOC_JMP,     2, 2, 26, FALSE, 0, complain_overflow_dont,
	mips_fix_jmp_addr,
	"MIPS_JMP", FALSE, 0, 0x03ffffff, FALSE},
  {MIPS_RELOC_WDISP16, 2, 2, 16, TRUE,  0, complain_overflow_signed, 0,
	"WDISP16",  FALSE, 0, 0x0000ffff, FALSE},
  {MIPS_RELOC_HI16,   16, 2, 16, FALSE, 0, complain_overflow_bitfield, 0,
	"HI16",     FALSE, 0, 0x0000ffff, FALSE},
  {MIPS_RELOC_HI16_S, 16, 2, 16, FALSE, 0, complain_overflow_bitfield,
        mips_fix_hi16_s,
        "HI16_S",   FALSE, 0, 0x0000ffff, FALSE},
  {MIPS_RELOC_LO16,    0, 2, 16, FALSE, 0, complain_overflow_dont, 0,
	"LO16",     FALSE, 0, 0x0000ffff, FALSE},
};

static reloc_howto_type *
MY(reloc_howto_type_lookup) (abfd, code)
     bfd *abfd;
     bfd_reloc_code_real_type code;
{

  if (bfd_get_arch (abfd) != bfd_arch_mips)
    return 0;

  switch (code)
    {
    case BFD_RELOC_CTOR:
    case BFD_RELOC_32:
      return (&mips_howto_table_ext[MIPS_RELOC_32]);
    case BFD_RELOC_MIPS_JMP:
      return (&mips_howto_table_ext[MIPS_RELOC_JMP]);
    case BFD_RELOC_16_PCREL_S2:
      return (&mips_howto_table_ext[MIPS_RELOC_WDISP16]);
    case BFD_RELOC_HI16:
      return (&mips_howto_table_ext[MIPS_RELOC_HI16]);
    case BFD_RELOC_HI16_S:
      return (&mips_howto_table_ext[MIPS_RELOC_HI16_S]);
    case BFD_RELOC_LO16:
      return (&mips_howto_table_ext[MIPS_RELOC_LO16]);
    default:
      return 0;
    }
}

/* This is just like the standard aoutx.h version but we need to do our
   own mapping of external reloc type values to howto entries.  */
long
MY(canonicalize_reloc) (abfd, section, relptr, symbols)
      bfd *abfd;
      sec_ptr section;
      arelent **relptr;
      asymbol **symbols;
{
  arelent *tblptr = section->relocation;
  unsigned int count, c;
  extern reloc_howto_type NAME(aout,ext_howto_table)[];

  /* If we have already read in the relocation table, return the values.  */
  if (section->flags & SEC_CONSTRUCTOR)
    {
      arelent_chain *chain = section->constructor_chain;

      for (count = 0; count < section->reloc_count; count++)
	{
	  *relptr++ = &chain->relent;
	  chain = chain->next;
	}
      *relptr = 0;
      return section->reloc_count;
    }

  if (tblptr && section->reloc_count)
    {
      for (count = 0; count++ < section->reloc_count;)
	*relptr++ = tblptr++;
      *relptr = 0;
      return section->reloc_count;
    }

  if (!NAME(aout,slurp_reloc_table) (abfd, section, symbols))
    return -1;
  tblptr = section->relocation;

  /* fix up howto entries.  */
  for (count = 0; count++ < section->reloc_count;)
    {
      c = tblptr->howto - NAME(aout,ext_howto_table);
      tblptr->howto = &mips_howto_table_ext[c];

      *relptr++ = tblptr++;
    }
  *relptr = 0;
  return section->reloc_count;
}

static const struct aout_backend_data MY(backend_data) = {
  0,				/* zmagic contiguous */
  1,				/* text incl header */
  0,				/* entry is text address */
  0,				/* exec_hdr_flags */
  TARGET_PAGE_SIZE,			/* text vma */
  MY_set_sizes,
  0,				/* text size includes exec header */
  0,				/* add_dynamic_symbols */
  0,				/* add_one_symbol */
  0,				/* link_dynamic_object */
  0,				/* write_dynamic_symbol */
  0,				/* check_dynamic_reloc */
  0				/* finish_dynamic_link */
};

extern const bfd_target aout_mips_big_vec;

const bfd_target aout_mips_little_vec =
  {
    "a.out-mips-little",		/* name */
    bfd_target_aout_flavour,
    BFD_ENDIAN_LITTLE,		/* target byte order (little) */
    BFD_ENDIAN_LITTLE,		/* target headers byte order (little) */
    (HAS_RELOC | EXEC_P |		/* object flags */
     HAS_LINENO | HAS_DEBUG |
     HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
    MY_symbol_leading_char,
    ' ',				/* ar_pad_char */
    15,				/* ar_max_namelen */
    bfd_getl64, bfd_getl_signed_64, bfd_putl64,
    bfd_getl32, bfd_getl_signed_32, bfd_putl32,
    bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
    bfd_getl64, bfd_getl_signed_64, bfd_putl64,
    bfd_getl32, bfd_getl_signed_32, bfd_putl32,
    bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */
    {_bfd_dummy_target, MY_object_p, /* bfd_check_format */
     bfd_generic_archive_p, MY_core_file_p},
    {bfd_false, MY_mkobject,	/* bfd_set_format */
     _bfd_generic_mkarchive, bfd_false},
    {bfd_false, MY_write_object_contents, /* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

    BFD_JUMP_TABLE_GENERIC (MY),
    BFD_JUMP_TABLE_COPY (MY),
    BFD_JUMP_TABLE_CORE (MY),
    BFD_JUMP_TABLE_ARCHIVE (MY),
    BFD_JUMP_TABLE_SYMBOLS (MY),
    BFD_JUMP_TABLE_RELOCS (MY),
    BFD_JUMP_TABLE_WRITE (MY),
    BFD_JUMP_TABLE_LINK (MY),
    BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

    & aout_mips_big_vec,

    (PTR) MY_backend_data
  };

const bfd_target aout_mips_big_vec =
  {
    "a.out-mips-big",		/* name */
    bfd_target_aout_flavour,
    BFD_ENDIAN_BIG,		/* target byte order (big) */
    BFD_ENDIAN_BIG,		/* target headers byte order (big) */
    (HAS_RELOC | EXEC_P |		/* object flags */
     HAS_LINENO | HAS_DEBUG |
     HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
    MY_symbol_leading_char,
    ' ',				/* ar_pad_char */
    15,				/* ar_max_namelen */
    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
    bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */
    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
    bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */
    {_bfd_dummy_target, MY_object_p, /* bfd_check_format */
     bfd_generic_archive_p, MY_core_file_p},
    {bfd_false, MY_mkobject,	/* bfd_set_format */
     _bfd_generic_mkarchive, bfd_false},
    {bfd_false, MY_write_object_contents, /* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

    BFD_JUMP_TABLE_GENERIC (MY),
    BFD_JUMP_TABLE_COPY (MY),
    BFD_JUMP_TABLE_CORE (MY),
    BFD_JUMP_TABLE_ARCHIVE (MY),
    BFD_JUMP_TABLE_SYMBOLS (MY),
    BFD_JUMP_TABLE_RELOCS (MY),
    BFD_JUMP_TABLE_WRITE (MY),
    BFD_JUMP_TABLE_LINK (MY),
    BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

    & aout_mips_little_vec,

    (PTR) MY_backend_data
  };
@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d73 1
a73 1
  PARAMS ((bfd *, arelent *, struct symbol_cache_entry *, PTR, asection *,
d206 1
a206 1
     struct symbol_cache_entry *symbol;
d223 1
a223 1
  /* Work out which section the relocation is targetted at and the
d274 1
a274 1
  /* Work out which section the relocation is targetted at and the
@


1.4
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1998, 1999, 2000
a21 1
#define BYTES_IN_WORD 4
d38 4
a41 1
#define MY(OP) CAT(mipsbsd_,OP)
d51 1
a51 1
static void MY(set_arch_mach) PARAMS ((bfd *abfd, int machtype));
d55 1
a55 1
static boolean MY(write_object_contents) PARAMS ((bfd *abfd));
d57 1
a57 1
/* We can't use MY(x) here because it leads to a recursive call to CAT
d72 8
d83 1
a83 1
     int machtype;
d86 1
a86 1
  long machine;
d89 6
a94 1
  switch (machtype) {
d96 12
a107 16
  case M_MIPS1:
    arch = bfd_arch_mips;
    machine = 3000;
    break;

  case M_MIPS2:
    arch = bfd_arch_mips;
    machine = 4000;
    break;

  default:
    arch = bfd_arch_obscure;
    machine = 0;
    break;
  }
  bfd_set_arch_mach(abfd, arch, machine);
d112 1
a112 1
MY(choose_reloc_size) (abfd)
d115 11
a125 10
  switch (bfd_get_arch(abfd)) {
  case bfd_arch_sparc:
  case bfd_arch_a29k:
  case bfd_arch_mips:
    obj_reloc_entry_size (abfd) = RELOC_EXT_SIZE;
    break;
  default:
    obj_reloc_entry_size (abfd) = RELOC_STD_SIZE;
    break;
  }
d132 2
a133 2
static boolean
MY(write_object_contents) (abfd)
d140 16
a155 5
  switch (bfd_get_arch(abfd)) {
  case bfd_arch_m68k:
    switch (bfd_get_mach(abfd)) {
    case bfd_mach_m68010:
      N_SET_MACHTYPE(*execp, M_68010);
d157 5
a161 3
    default:
    case bfd_mach_m68020:
      N_SET_MACHTYPE(*execp, M_68020);
d163 11
a173 16
    }
    break;
  case bfd_arch_sparc:
    N_SET_MACHTYPE(*execp, M_SPARC);
    break;
  case bfd_arch_i386:
    N_SET_MACHTYPE(*execp, M_386);
    break;
  case bfd_arch_a29k:
    N_SET_MACHTYPE(*execp, M_29K);
    break;
  case bfd_arch_mips:
    switch (bfd_get_mach(abfd)) {
    case 4000:
    case 6000:
      N_SET_MACHTYPE(*execp, M_MIPS2);
d176 1
a176 2
      N_SET_MACHTYPE(*execp, M_MIPS1);
      break;
a177 4
    break;
  default:
    N_SET_MACHTYPE(*execp, M_UNKNOWN);
  }
d179 1
a179 1
  MY(choose_reloc_size) (abfd);
d181 1
a181 1
  WRITE_HEADERS(abfd, execp);
d183 1
a183 1
  return true;
d186 1
a186 3
/*
 * MIPS relocation types.
 */
d194 7
a200 8
/*
 * This is only called when performing a BFD_RELOC_MIPS_JMP relocation.
 * The jump destination address is formed from the upper 4 bits of the
 * "current" program counter concatenated with the jump instruction's
 * 26 bit field and two trailing zeros.
 * If the destination address is not in the same segment as the "current"
 * program counter, then we need to signal an error.
 */
d202 2
a203 1
mips_fix_jmp_addr (abfd,reloc_entry,symbol,data,input_section,output_bfd)
d210 1
d223 2
a224 4
  /*
   * Work out which section the relocation is targetted at and the
   * initial relocation command value.
   */
d243 5
a247 6
/*
 * This is only called when performing a BFD_RELOC_HI16_S relocation.
 * We need to see if bit 15 is set in the result. If it is, we add
 * 0x10000 and continue normally. This will compensate for the sign extension
 * when the low bits are added at run time.
 */
d269 1
a269 1
  /* If this is an undefined symbol, return error */
d274 2
a275 4
  /*
   * Work out which section the relocation is targetted at and the
   * initial relocation command value.
   */
d292 3
a294 3
  {MIPS_RELOC_32,      0, 2, 32, false, 0,  complain_overflow_bitfield, 0,
	"32",       false, 0, 0xffffffff, false},
  {MIPS_RELOC_JMP,     2, 2, 26, false, 0, complain_overflow_dont,
d296 6
a301 6
	"MIPS_JMP", false, 0, 0x03ffffff, false},
  {MIPS_RELOC_WDISP16, 2, 2, 16, true,  0, complain_overflow_signed, 0,
	"WDISP16",  false, 0, 0x0000ffff, false},
  {MIPS_RELOC_HI16,   16, 2, 16, false, 0, complain_overflow_bitfield, 0,
	"HI16",     false, 0, 0x0000ffff, false},
  {MIPS_RELOC_HI16_S, 16, 2, 16, false, 0, complain_overflow_bitfield,
d303 3
a305 3
        "HI16_S",   false, 0, 0x0000ffff, false},
  {MIPS_RELOC_LO16,    0, 2, 16, false, 0, complain_overflow_dont, 0,
	"LO16",     false, 0, 0x0000ffff, false},
d337 2
a338 4
/*
 * This is just like the standard aoutx.h version but we need to do our
 * own mapping of external reloc type values to howto entries.
 */
d351 3
a353 2
  if (section->flags & SEC_CONSTRUCTOR) {
    arelent_chain *chain = section->constructor_chain;
d355 15
a369 3
    for (count = 0; count < section->reloc_count; count++) {
      *relptr++ = &chain->relent;
      chain = chain->next;
a370 9
    *relptr = 0;
    return section->reloc_count;
  }
  if (tblptr && section->reloc_count) {
    for (count = 0; count++ < section->reloc_count;)
      *relptr++ = tblptr++;
    *relptr = 0;
    return section->reloc_count;
  }
d376 1
a376 1
  /* fix up howto entries */
d388 1
a388 1
static CONST struct aout_backend_data MY(backend_data) = {
d407 18
a424 18
{
  "a.out-mips-little",		/* name */
  bfd_target_aout_flavour,
  BFD_ENDIAN_LITTLE,		/* target byte order (little) */
  BFD_ENDIAN_LITTLE,		/* target headers byte order (little) */
  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
  MY_symbol_leading_char,
  ' ',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */
d426 1
a426 1
       bfd_generic_archive_p, MY_core_file_p},
d428 1
a428 1
       _bfd_generic_mkarchive, bfd_false},
d430 1
a430 1
       _bfd_write_archive_contents, bfd_false},
d432 9
a440 9
     BFD_JUMP_TABLE_GENERIC (MY),
     BFD_JUMP_TABLE_COPY (MY),
     BFD_JUMP_TABLE_CORE (MY),
     BFD_JUMP_TABLE_ARCHIVE (MY),
     BFD_JUMP_TABLE_SYMBOLS (MY),
     BFD_JUMP_TABLE_RELOCS (MY),
     BFD_JUMP_TABLE_WRITE (MY),
     BFD_JUMP_TABLE_LINK (MY),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
d442 1
a442 1
  & aout_mips_big_vec,
d444 2
a445 2
  (PTR) MY_backend_data
};
d448 18
a465 18
{
  "a.out-mips-big",		/* name */
  bfd_target_aout_flavour,
  BFD_ENDIAN_BIG,		/* target byte order (big) */
  BFD_ENDIAN_BIG,		/* target headers byte order (big) */
  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
  MY_symbol_leading_char,
  ' ',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */
d467 1
a467 1
       bfd_generic_archive_p, MY_core_file_p},
d469 1
a469 1
       _bfd_generic_mkarchive, bfd_false},
d471 1
a471 1
       _bfd_write_archive_contents, bfd_false},
d473 9
a481 9
     BFD_JUMP_TABLE_GENERIC (MY),
     BFD_JUMP_TABLE_COPY (MY),
     BFD_JUMP_TABLE_CORE (MY),
     BFD_JUMP_TABLE_ARCHIVE (MY),
     BFD_JUMP_TABLE_SYMBOLS (MY),
     BFD_JUMP_TABLE_RELOCS (MY),
     BFD_JUMP_TABLE_WRITE (MY),
     BFD_JUMP_TABLE_LINK (MY),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
d483 1
a483 1
  & aout_mips_little_vec,
d485 2
a486 2
  (PTR) MY_backend_data
};
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1993, 94, 95, 97, 98, 1999 Free Software Foundation, Inc.
d47 2
a48 2
  MY(set_arch_mach)(ABFD, N_MACHTYPE (EXEC)); \
  MY(choose_reloc_size)(ABFD);
d78 1
a78 1
  /* Determine the architecture and machine type of the object file. */
d96 1
a96 1
  bfd_set_arch_mach(abfd, arch, machine);  
d164 1
a164 1
  MY(choose_reloc_size)(abfd);
d199 2
a200 2
 
  /* If this is a partial relocation, just continue. */
d209 1
a209 1
  /* 
d253 2
a254 2
 
  /* If this is a partial relocation, just continue. */
d263 1
a263 1
  /* 
d333 1
a333 1
MY(canonicalize_reloc)(abfd, section, relptr, symbols)
d343 1
a343 1
  /* If we have already read in the relocation table, return the values. */
d355 1
a355 1
    for (count = 0; count++ < section->reloc_count;) 
d361 1
a361 1
  if (!NAME(aout,slurp_reloc_table)(abfd, section, symbols))
d366 1
a366 1
  for (count = 0; count++ < section->reloc_count;) 
d432 1
a432 1
  
d473 1
a473 1
  
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 1
a2 1
   Copyright (C) 1993, 1994, 1995 Free Software Foundation, Inc.
d48 1
a48 1
void MY(set_arch_mach) PARAMS ((bfd *abfd, int machtype));
d69 1
a69 1
void
d130 1
a130 1
    case 68010:
d134 1
a134 1
    case 68020:
d190 1
a190 1
     bfd *abfd;
d193 1
a193 1
     PTR data;
d243 1
a243 1
     bfd *abfd;
d246 2
a247 2
     PTR data;
     asection *input_section;
d249 1
a249 1
     char **error_message;
d379 1
d392 2
d403 1
a403 1
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
d430 3
a432 1
  (PTR) MY_backend_data,
d444 1
a444 1
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
d471 3
a473 1
  (PTR) MY_backend_data,
@


1.1
log
@Initial revision
@
text
@d395 2
a396 2
  false,			/* target byte order (little) */
  false,			/* target headers byte order (little) */
d434 2
a435 2
  true,				/* target byte order (big) */
  true,				/* target headers byte order (big) */
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d395 2
a396 2
  BFD_ENDIAN_LITTLE,		/* target byte order (little) */
  BFD_ENDIAN_LITTLE,		/* target headers byte order (little) */
d434 2
a435 2
  BFD_ENDIAN_BIG,		/* target byte order (big) */
  BFD_ENDIAN_BIG,		/* target headers byte order (big) */
@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1993, 1994, 1995, 1997 Free Software Foundation, Inc.
a378 1
  0,				/* entry is text address */
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 97, 98, 1999 Free Software Foundation, Inc.
d48 1
a48 1
static void MY(set_arch_mach) PARAMS ((bfd *abfd, int machtype));
d69 1
a69 1
static void
d130 1
a130 1
    case bfd_mach_m68010:
d134 1
a134 1
    case bfd_mach_m68020:
d190 1
a190 1
     bfd *abfd ATTRIBUTE_UNUSED;
d193 1
a193 1
     PTR data ATTRIBUTE_UNUSED;
d243 1
a243 1
     bfd *abfd ATTRIBUTE_UNUSED;
d246 2
a247 2
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
d249 1
a249 1
     char **error_message ATTRIBUTE_UNUSED;
a391 2
extern const bfd_target aout_mips_big_vec;

d401 1
a401 1
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
d428 1
a428 3
  & aout_mips_big_vec,
  
  (PTR) MY_backend_data
d440 1
a440 1
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
d467 1
a467 3
  & aout_mips_little_vec,
  
  (PTR) MY_backend_data
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1993, 1994, 1995, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.
d46 2
a47 2
  MY(set_arch_mach) (ABFD, N_MACHTYPE (EXEC)); \
  MY(choose_reloc_size) (ABFD);
d77 1
a77 1
  /* Determine the architecture and machine type of the object file.  */
d95 1
a95 1
  bfd_set_arch_mach(abfd, arch, machine);
d163 1
a163 1
  MY(choose_reloc_size) (abfd);
d198 2
a199 2

  /* If this is a partial relocation, just continue.  */
d208 1
a208 1
  /*
d252 2
a253 2

  /* If this is a partial relocation, just continue.  */
d262 1
a262 1
  /*
d332 1
a332 1
MY(canonicalize_reloc) (abfd, section, relptr, symbols)
d342 1
a342 1
  /* If we have already read in the relocation table, return the values.  */
d354 1
a354 1
    for (count = 0; count++ < section->reloc_count;)
d360 1
a360 1
  if (!NAME(aout,slurp_reloc_table) (abfd, section, symbols))
d365 1
a365 1
  for (count = 0; count++ < section->reloc_count;)
d431 1
a431 1

d472 1
a472 1

@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d22 1
d39 1
a39 4
/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
#define MY(OP) CONCAT2 (mipsbsd_,OP)
d49 1
a49 1
static void MY(set_arch_mach) PARAMS ((bfd *abfd, unsigned long machtype));
d53 1
a53 1
static bfd_boolean MY(write_object_contents) PARAMS ((bfd *abfd));
d55 1
a55 1
/* We can't use MY(x) here because it leads to a recursive call to CONCAT2
a69 8
static bfd_reloc_status_type mips_fix_jmp_addr
  PARAMS ((bfd *, arelent *, struct symbol_cache_entry *, PTR, asection *,
	   bfd *, char **));
static reloc_howto_type *MY(reloc_howto_type_lookup)
  PARAMS ((bfd *, bfd_reloc_code_real_type));

long MY(canonicalize_reloc) PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));

d73 1
a73 1
     unsigned long machtype;
d76 1
a76 1
  unsigned int machine;
d79 1
a79 6
  switch (machtype)
    {
    case M_MIPS1:
      arch = bfd_arch_mips;
      machine = bfd_mach_mips3000;
      break;
d81 16
a96 12
    case M_MIPS2:
      arch = bfd_arch_mips;
      machine = bfd_mach_mips4000;
      break;

    default:
      arch = bfd_arch_obscure;
      machine = 0;
      break;
    }

  bfd_set_arch_mach (abfd, arch, machine);
d101 1
a101 1
MY (choose_reloc_size) (abfd)
d104 10
a113 11
  switch (bfd_get_arch (abfd))
    {
    case bfd_arch_sparc:
    case bfd_arch_a29k:
    case bfd_arch_mips:
      obj_reloc_entry_size (abfd) = RELOC_EXT_SIZE;
      break;
    default:
      obj_reloc_entry_size (abfd) = RELOC_STD_SIZE;
      break;
    }
d120 2
a121 2
static bfd_boolean
MY (write_object_contents) (abfd)
d128 5
a132 13
  switch (bfd_get_arch (abfd))
    {
    case bfd_arch_m68k:
      switch (bfd_get_mach (abfd))
	{
	case bfd_mach_m68010:
	  N_SET_MACHTYPE (*execp, M_68010);
	  break;
	default:
	case bfd_mach_m68020:
	  N_SET_MACHTYPE (*execp, M_68020);
	  break;
	}
d134 3
a136 2
    case bfd_arch_sparc:
      N_SET_MACHTYPE (*execp, M_SPARC);
d138 16
a153 2
    case bfd_arch_i386:
      N_SET_MACHTYPE (*execp, M_386);
d155 2
a156 14
    case bfd_arch_a29k:
      N_SET_MACHTYPE (*execp, M_29K);
      break;
    case bfd_arch_mips:
      switch (bfd_get_mach (abfd))
	{
	case bfd_mach_mips4000:
	case bfd_mach_mips6000:
	  N_SET_MACHTYPE (*execp, M_MIPS2);
	  break;
	default:
	  N_SET_MACHTYPE (*execp, M_MIPS1);
	  break;
	}
a157 2
    default:
      N_SET_MACHTYPE (*execp, M_UNKNOWN);
d159 4
d164 1
a164 1
  MY (choose_reloc_size) (abfd);
d166 1
a166 1
  WRITE_HEADERS (abfd, execp);
d168 1
a168 1
  return TRUE;
d171 3
a173 1
/* MIPS relocation types.  */
d181 8
a188 7
/* This is only called when performing a BFD_RELOC_MIPS_JMP relocation.
   The jump destination address is formed from the upper 4 bits of the
   "current" program counter concatenated with the jump instruction's
   26 bit field and two trailing zeros.
   If the destination address is not in the same segment as the "current"
   program counter, then we need to signal an error.  */

d190 1
a190 2
mips_fix_jmp_addr (abfd, reloc_entry, symbol, data, input_section, output_bfd,
		   error_message)
a196 1
     char **error_message ATTRIBUTE_UNUSED;
d209 4
a212 2
  /* Work out which section the relocation is targetted at and the
     initial relocation command value.  */
d231 6
a236 5
/* This is only called when performing a BFD_RELOC_HI16_S relocation.
   We need to see if bit 15 is set in the result. If it is, we add
   0x10000 and continue normally. This will compensate for the sign extension
   when the low bits are added at run time.  */

d258 1
a258 1
  /* If this is an undefined symbol, return error.  */
d263 4
a266 2
  /* Work out which section the relocation is targetted at and the
     initial relocation command value.  */
d283 3
a285 3
  {MIPS_RELOC_32,      0, 2, 32, FALSE, 0,  complain_overflow_bitfield, 0,
	"32",       FALSE, 0, 0xffffffff, FALSE},
  {MIPS_RELOC_JMP,     2, 2, 26, FALSE, 0, complain_overflow_dont,
d287 6
a292 6
	"MIPS_JMP", FALSE, 0, 0x03ffffff, FALSE},
  {MIPS_RELOC_WDISP16, 2, 2, 16, TRUE,  0, complain_overflow_signed, 0,
	"WDISP16",  FALSE, 0, 0x0000ffff, FALSE},
  {MIPS_RELOC_HI16,   16, 2, 16, FALSE, 0, complain_overflow_bitfield, 0,
	"HI16",     FALSE, 0, 0x0000ffff, FALSE},
  {MIPS_RELOC_HI16_S, 16, 2, 16, FALSE, 0, complain_overflow_bitfield,
d294 3
a296 3
        "HI16_S",   FALSE, 0, 0x0000ffff, FALSE},
  {MIPS_RELOC_LO16,    0, 2, 16, FALSE, 0, complain_overflow_dont, 0,
	"LO16",     FALSE, 0, 0x0000ffff, FALSE},
d328 4
a331 2
/* This is just like the standard aoutx.h version but we need to do our
   own mapping of external reloc type values to howto entries.  */
d344 2
a345 3
  if (section->flags & SEC_CONSTRUCTOR)
    {
      arelent_chain *chain = section->constructor_chain;
d347 3
a349 15
      for (count = 0; count < section->reloc_count; count++)
	{
	  *relptr++ = &chain->relent;
	  chain = chain->next;
	}
      *relptr = 0;
      return section->reloc_count;
    }

  if (tblptr && section->reloc_count)
    {
      for (count = 0; count++ < section->reloc_count;)
	*relptr++ = tblptr++;
      *relptr = 0;
      return section->reloc_count;
d351 9
d365 1
a365 1
  /* fix up howto entries.  */
d377 1
a377 1
static const struct aout_backend_data MY(backend_data) = {
d396 18
a413 18
  {
    "a.out-mips-little",		/* name */
    bfd_target_aout_flavour,
    BFD_ENDIAN_LITTLE,		/* target byte order (little) */
    BFD_ENDIAN_LITTLE,		/* target headers byte order (little) */
    (HAS_RELOC | EXEC_P |		/* object flags */
     HAS_LINENO | HAS_DEBUG |
     HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
    MY_symbol_leading_char,
    ' ',				/* ar_pad_char */
    15,				/* ar_max_namelen */
    bfd_getl64, bfd_getl_signed_64, bfd_putl64,
    bfd_getl32, bfd_getl_signed_32, bfd_putl32,
    bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
    bfd_getl64, bfd_getl_signed_64, bfd_putl64,
    bfd_getl32, bfd_getl_signed_32, bfd_putl32,
    bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */
d415 1
a415 1
     bfd_generic_archive_p, MY_core_file_p},
d417 1
a417 1
     _bfd_generic_mkarchive, bfd_false},
d419 1
a419 1
     _bfd_write_archive_contents, bfd_false},
d421 9
a429 9
    BFD_JUMP_TABLE_GENERIC (MY),
    BFD_JUMP_TABLE_COPY (MY),
    BFD_JUMP_TABLE_CORE (MY),
    BFD_JUMP_TABLE_ARCHIVE (MY),
    BFD_JUMP_TABLE_SYMBOLS (MY),
    BFD_JUMP_TABLE_RELOCS (MY),
    BFD_JUMP_TABLE_WRITE (MY),
    BFD_JUMP_TABLE_LINK (MY),
    BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
d431 1
a431 1
    & aout_mips_big_vec,
d433 2
a434 2
    (PTR) MY_backend_data
  };
d437 18
a454 18
  {
    "a.out-mips-big",		/* name */
    bfd_target_aout_flavour,
    BFD_ENDIAN_BIG,		/* target byte order (big) */
    BFD_ENDIAN_BIG,		/* target headers byte order (big) */
    (HAS_RELOC | EXEC_P |		/* object flags */
     HAS_LINENO | HAS_DEBUG |
     HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
    MY_symbol_leading_char,
    ' ',				/* ar_pad_char */
    15,				/* ar_max_namelen */
    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
    bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */
    bfd_getb64, bfd_getb_signed_64, bfd_putb64,
    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
    bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */
d456 1
a456 1
     bfd_generic_archive_p, MY_core_file_p},
d458 1
a458 1
     _bfd_generic_mkarchive, bfd_false},
d460 1
a460 1
     _bfd_write_archive_contents, bfd_false},
d462 9
a470 9
    BFD_JUMP_TABLE_GENERIC (MY),
    BFD_JUMP_TABLE_COPY (MY),
    BFD_JUMP_TABLE_CORE (MY),
    BFD_JUMP_TABLE_ARCHIVE (MY),
    BFD_JUMP_TABLE_SYMBOLS (MY),
    BFD_JUMP_TABLE_RELOCS (MY),
    BFD_JUMP_TABLE_WRITE (MY),
    BFD_JUMP_TABLE_LINK (MY),
    BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
d472 1
a472 1
    & aout_mips_little_vec,
d474 2
a475 2
    (PTR) MY_backend_data
  };
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d73 1
a73 1
  PARAMS ((bfd *, arelent *, struct bfd_symbol *, PTR, asection *,
d206 1
a206 1
     struct bfd_symbol *symbol;
d223 1
a223 1
  /* Work out which section the relocation is targeted at and the
d274 1
a274 1
  /* Work out which section the relocation is targeted at and the
@


