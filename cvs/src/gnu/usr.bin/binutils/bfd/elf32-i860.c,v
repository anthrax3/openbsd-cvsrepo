head	1.5;
access;
symbols
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.52
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.48
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.44
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.46
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.38
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.42
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.40
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.36
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.34
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.32
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.30
	OPENBSD_5_0:1.5.0.28
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.26
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.24
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.20
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.22
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.18
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.16
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.5
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.2
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.11.02.20.45.07;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.17.21.54.21;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.29;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.19.11.13;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.47;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.47;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.45.38;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.23.46;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.14;	author drahn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.11.02.20.22.22;	author miod;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* Intel i860 specific support for 32-bit ELF.
   Copyright 1993, 1995, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.

   Full i860 support contributed by Jason Eckhardt <jle@@cygnus.com>.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/i860.h"

/* special_function for R_860_PC26 relocation.  */
static bfd_reloc_status_type
i860_howto_pc26_reloc (bfd *abfd ATTRIBUTE_UNUSED,
                       arelent *reloc_entry,
                       asymbol *symbol,
                       void *data ATTRIBUTE_UNUSED,
                       asection *input_section,
                       bfd *output_bfd,
                       char **error_message ATTRIBUTE_UNUSED)
{
  bfd_vma insn;
  bfd_vma relocation;
  bfd_byte *addr;

  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* Used elf32-mips.c as an example.  */
  if (bfd_is_und_section (symbol->section)
      && output_bfd == (bfd *) NULL)
    return bfd_reloc_undefined;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  /* Adjust for PC-relative relocation.  */
  relocation -= (input_section->output_section->vma
                 + input_section->output_offset
                 + reloc_entry->address
                 + 4);

  /* Check for target out of range.  */
  if ((bfd_signed_vma)relocation > (0x3ffffff << 2)
      || (bfd_signed_vma)relocation < (-0x4000000 << 2))
    return bfd_reloc_outofrange;

  addr = (bfd_byte *) data + reloc_entry->address;
  insn = bfd_get_32 (abfd, addr);

  relocation >>= reloc_entry->howto->rightshift;
  insn = (insn & ~reloc_entry->howto->dst_mask)
         | (relocation & reloc_entry->howto->dst_mask);

  bfd_put_32 (abfd, (bfd_vma) insn, addr);

  return bfd_reloc_ok;
}

/* special_function for R_860_PC16 relocation.  */
static bfd_reloc_status_type
i860_howto_pc16_reloc (bfd *abfd,
                       arelent *reloc_entry,
                       asymbol *symbol,
                       void *data,
                       asection *input_section,
                       bfd *output_bfd,
                       char **error_message ATTRIBUTE_UNUSED)
{
  bfd_vma insn;
  bfd_vma relocation;
  bfd_byte *addr;

  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* Used elf32-mips.c as an example.  */
  if (bfd_is_und_section (symbol->section)
      && output_bfd == (bfd *) NULL)
    return bfd_reloc_undefined;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  /* Adjust for PC-relative relocation.  */
  relocation -= (input_section->output_section->vma
                 + input_section->output_offset
                 + reloc_entry->address
                 + 4);

  /* Check for target out of range.  */
  if ((bfd_signed_vma)relocation > (0x7fff << 2)
      || (bfd_signed_vma)relocation < (-0x8000 << 2))
    return bfd_reloc_outofrange;

  addr = (bfd_byte *) data + reloc_entry->address;
  insn = bfd_get_32 (abfd, addr);

  relocation >>= reloc_entry->howto->rightshift;
  relocation = (((relocation & 0xf800) << 5) | (relocation & 0x7ff))
               & reloc_entry->howto->dst_mask;
  insn = (insn & ~reloc_entry->howto->dst_mask) | relocation;

  bfd_put_32 (abfd, (bfd_vma) insn, addr);

  return bfd_reloc_ok;
}

/* special_function for R_860_HIGHADJ relocation.  */
static bfd_reloc_status_type
i860_howto_highadj_reloc (bfd *abfd,
                          arelent *reloc_entry,
                          asymbol *symbol,
                          void *data,
                          asection *input_section,
                          bfd *output_bfd,
                          char **error_message ATTRIBUTE_UNUSED)
{
  bfd_vma insn;
  bfd_vma relocation;
  bfd_byte *addr;

  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* Used elf32-mips.c as an example.  */
  if (bfd_is_und_section (symbol->section)
      && output_bfd == (bfd *) NULL)
    return bfd_reloc_undefined;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;
  relocation += 0x8000;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  addr = (bfd_byte *) data + reloc_entry->address;
  insn = bfd_get_32 (abfd, addr);

  relocation = ((relocation >> 16) & 0xffff);

  insn = (insn & 0xffff0000) | relocation;

  bfd_put_32 (abfd, (bfd_vma) insn, addr);

  return bfd_reloc_ok;
}

/* special_function for R_860_SPLITn relocations.  */
static bfd_reloc_status_type
i860_howto_splitn_reloc (bfd *abfd,
                         arelent *reloc_entry,
                         asymbol *symbol,
                         void *data,
                         asection *input_section,
                         bfd *output_bfd,
                         char **error_message ATTRIBUTE_UNUSED)
{
  bfd_vma insn;
  bfd_vma relocation;
  bfd_byte *addr;

  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* Used elf32-mips.c as an example.  */
  if (bfd_is_und_section (symbol->section)
      && output_bfd == (bfd *) NULL)
    return bfd_reloc_undefined;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  addr = (bfd_byte *) data + reloc_entry->address;
  insn = bfd_get_32 (abfd, addr);

  relocation = (((relocation & 0xf800) << 5) | (relocation & 0x7ff))
               & reloc_entry->howto->dst_mask;
  insn = (insn & ~reloc_entry->howto->dst_mask) | relocation;

  bfd_put_32 (abfd, (bfd_vma) insn, addr);

  return bfd_reloc_ok;
}

/* This howto table is preliminary.  */
static reloc_howto_type elf32_i860_howto_table [] =
{
  /* This relocation does nothing.  */
  HOWTO (R_860_NONE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 32-bit absolute relocation.  */
  HOWTO (R_860_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_32",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_860_COPY,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_COPY",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_860_GLOB_DAT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_GLOB_DAT",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_860_JUMP_SLOT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_JUMP_SLOT",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_860_RELATIVE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_RELATIVE",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 26-bit PC-relative relocation.  */
  HOWTO (R_860_PC26,	        /* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 i860_howto_pc26_reloc,	/* special_function */
	 "R_860_PC26",		/* name */
	 FALSE,			/* partial_inplace */
	 0x3ffffff,		/* src_mask */
	 0x3ffffff,		/* dst_mask */
	 TRUE),		        /* pcrel_offset */

  HOWTO (R_860_PLT26,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_PLT26",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),		        /* pcrel_offset */

  /* A 16-bit PC-relative relocation.  */
  HOWTO (R_860_PC16,	        /* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 i860_howto_pc16_reloc,	/* special_function */
	 "R_860_PC16",		/* name */
	 FALSE,			/* partial_inplace */
	 0x1f07ff,		/* src_mask */
	 0x1f07ff,		/* dst_mask */
	 TRUE),		        /* pcrel_offset */

  HOWTO (R_860_LOW0,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOW0",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  HOWTO (R_860_SPLIT0,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 i860_howto_splitn_reloc, /* special_function */
	 "R_860_SPLIT0",	/* name */
	 FALSE,			/* partial_inplace */
	 0x1f07ff,		/* src_mask */
	 0x1f07ff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  HOWTO (R_860_LOW1,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOW1",		/* name */
	 FALSE,			/* partial_inplace */
	 0xfffe,		/* src_mask */
	 0xfffe,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  HOWTO (R_860_SPLIT1,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 i860_howto_splitn_reloc, /* special_function */
	 "R_860_SPLIT1",	/* name */
	 FALSE,			/* partial_inplace */
	 0x1f07fe,		/* src_mask */
	 0x1f07fe,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  HOWTO (R_860_LOW2,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOW2",		/* name */
	 FALSE,			/* partial_inplace */
	 0xfffc,		/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  HOWTO (R_860_SPLIT2,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 i860_howto_splitn_reloc, /* special_function */
	 "R_860_SPLIT2",	/* name */
	 FALSE,			/* partial_inplace */
	 0x1f07fc,		/* src_mask */
	 0x1f07fc,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  HOWTO (R_860_LOW3,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOW3",		/* name */
	 FALSE,			/* partial_inplace */
	 0xfff8,		/* src_mask */
	 0xfff8,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  HOWTO (R_860_LOGOT0,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOGOT0",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),		        /* pcrel_offset */

  HOWTO (R_860_SPGOT0,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_SPGOT0",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),		        /* pcrel_offset */

  HOWTO (R_860_LOGOT1,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOGOT1",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),		        /* pcrel_offset */

  HOWTO (R_860_SPGOT1,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_SPGOT1",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),		        /* pcrel_offset */

  HOWTO (R_860_LOGOTOFF0,        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOGOTOFF0",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  HOWTO (R_860_SPGOTOFF0,        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_SPGOTOFF0",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  HOWTO (R_860_LOGOTOFF1,        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOGOTOFF1",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  HOWTO (R_860_SPGOTOFF1,       /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_SPGOTOFF1",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  HOWTO (R_860_LOGOTOFF2,        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOGOTOFF2",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  HOWTO (R_860_LOGOTOFF3,        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOGOTOFF3",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  HOWTO (R_860_LOPC,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOPC",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),		        /* pcrel_offset */

  HOWTO (R_860_HIGHADJ,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 i860_howto_highadj_reloc, /* special_function */
	 "R_860_HIGHADJ",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  HOWTO (R_860_HAGOT,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_HAGOT",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),		        /* pcrel_offset */

  HOWTO (R_860_HAGOTOFF,        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_HAGOTOFF",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  HOWTO (R_860_HAPC,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_HAPC",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),		        /* pcrel_offset */

  HOWTO (R_860_HIGH,	        /* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_HIGH",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  HOWTO (R_860_HIGOT,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_HIGOT",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),		        /* pcrel_offset */

  HOWTO (R_860_HIGOTOFF,        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_HIGOTOFF",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */
};

static unsigned char elf_code_to_howto_index[R_860_max + 1];

static reloc_howto_type *
lookup_howto (unsigned int rtype)
{
  static int initialized = 0;
  int i;
  int howto_tbl_size = (int) (sizeof (elf32_i860_howto_table)
			/ sizeof (elf32_i860_howto_table[0]));

  if (! initialized)
    {
      initialized = 1;
      memset (elf_code_to_howto_index, 0xff,
	      sizeof (elf_code_to_howto_index));
      for (i = 0; i < howto_tbl_size; i++)
        elf_code_to_howto_index[elf32_i860_howto_table[i].type] = i;
    }

  BFD_ASSERT (rtype <= R_860_max);
  i = elf_code_to_howto_index[rtype];
  if (i >= howto_tbl_size)
    return 0;
  return elf32_i860_howto_table + i;
}

/* Given a BFD reloc, return the matching HOWTO structure.  */
static reloc_howto_type *
elf32_i860_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			      bfd_reloc_code_real_type code)
{
  unsigned int rtype;

  switch (code)
    {
    case BFD_RELOC_NONE:
      rtype = R_860_NONE;
      break;
    case BFD_RELOC_32:
      rtype = R_860_32;
      break;
    case BFD_RELOC_860_COPY:
      rtype = R_860_COPY;
      break;
    case BFD_RELOC_860_GLOB_DAT:
      rtype = R_860_GLOB_DAT;
      break;
    case BFD_RELOC_860_JUMP_SLOT:
      rtype = R_860_JUMP_SLOT;
      break;
    case BFD_RELOC_860_RELATIVE:
      rtype = R_860_RELATIVE;
      break;
    case BFD_RELOC_860_PC26:
      rtype = R_860_PC26;
      break;
    case BFD_RELOC_860_PLT26:
      rtype = R_860_PLT26;
      break;
    case BFD_RELOC_860_PC16:
      rtype = R_860_PC16;
      break;
    case BFD_RELOC_860_LOW0:
      rtype = R_860_LOW0;
      break;
    case BFD_RELOC_860_SPLIT0:
      rtype = R_860_SPLIT0;
      break;
    case BFD_RELOC_860_LOW1:
      rtype = R_860_LOW1;
      break;
    case BFD_RELOC_860_SPLIT1:
      rtype = R_860_SPLIT1;
      break;
    case BFD_RELOC_860_LOW2:
      rtype = R_860_LOW2;
      break;
    case BFD_RELOC_860_SPLIT2:
      rtype = R_860_SPLIT2;
      break;
    case BFD_RELOC_860_LOW3:
      rtype = R_860_LOW3;
      break;
    case BFD_RELOC_860_LOGOT0:
      rtype = R_860_LOGOT0;
      break;
    case BFD_RELOC_860_SPGOT0:
      rtype = R_860_SPGOT0;
      break;
    case BFD_RELOC_860_LOGOT1:
      rtype = R_860_LOGOT1;
      break;
    case BFD_RELOC_860_SPGOT1:
      rtype = R_860_SPGOT1;
      break;
    case BFD_RELOC_860_LOGOTOFF0:
      rtype = R_860_LOGOTOFF0;
      break;
    case BFD_RELOC_860_SPGOTOFF0:
      rtype = R_860_SPGOTOFF0;
      break;
    case BFD_RELOC_860_LOGOTOFF1:
      rtype = R_860_LOGOTOFF1;
      break;
    case BFD_RELOC_860_SPGOTOFF1:
      rtype = R_860_SPGOTOFF1;
      break;
    case BFD_RELOC_860_LOGOTOFF2:
      rtype = R_860_LOGOTOFF2;
      break;
    case BFD_RELOC_860_LOGOTOFF3:
      rtype = R_860_LOGOTOFF3;
      break;
    case BFD_RELOC_860_LOPC:
      rtype = R_860_LOPC;
      break;
    case BFD_RELOC_860_HIGHADJ:
      rtype = R_860_HIGHADJ;
      break;
    case BFD_RELOC_860_HAGOT:
      rtype = R_860_HAGOT;
      break;
    case BFD_RELOC_860_HAGOTOFF:
      rtype = R_860_HAGOTOFF;
      break;
    case BFD_RELOC_860_HAPC:
      rtype = R_860_HAPC;
      break;
    case BFD_RELOC_860_HIGH:
      rtype = R_860_HIGH;
      break;
    case BFD_RELOC_860_HIGOT:
      rtype = R_860_HIGOT;
      break;
    case BFD_RELOC_860_HIGOTOFF:
      rtype = R_860_HIGOTOFF;
      break;
    default:
      rtype = 0;
      break;
    }
  return lookup_howto (rtype);
}

/* Given a ELF reloc, return the matching HOWTO structure.  */
static void
elf32_i860_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
			       arelent *bfd_reloc,
			       Elf_Internal_Rela *elf_reloc)
{
  bfd_reloc->howto
    = lookup_howto ((unsigned) ELF32_R_TYPE (elf_reloc->r_info));
}

/* Specialized relocation handler for R_860_SPLITn.  These relocations
   involves a 16-bit field that is split into two contiguous parts.  */
static bfd_reloc_status_type
elf32_i860_relocate_splitn (bfd *input_bfd,
			    Elf_Internal_Rela *rello,
			    bfd_byte *contents,
			    bfd_vma value)
{
  bfd_vma insn;
  reloc_howto_type *howto;
  howto = lookup_howto ((unsigned) ELF32_R_TYPE (rello->r_info));
  insn = bfd_get_32 (input_bfd, contents + rello->r_offset);

  /* Relocate.  */
  value += rello->r_addend;

  /* Separate the fields and insert.  */
  value = (((value & 0xf800) << 5) | (value & 0x7ff)) & howto->dst_mask;
  insn = (insn & ~howto->dst_mask) | value;

  bfd_put_32 (input_bfd, insn, contents + rello->r_offset);
  return bfd_reloc_ok;
}

/* Specialized relocation handler for R_860_PC16.  This relocation
   involves a 16-bit, PC-relative field that is split into two contiguous
   parts.  */
static bfd_reloc_status_type
elf32_i860_relocate_pc16 (bfd *input_bfd,
			  asection *input_section,
			  Elf_Internal_Rela *rello,
			  bfd_byte *contents,
			  bfd_vma value)
{
  bfd_vma insn;
  reloc_howto_type *howto;
  howto = lookup_howto ((unsigned) ELF32_R_TYPE (rello->r_info));
  insn = bfd_get_32 (input_bfd, contents + rello->r_offset);

  /* Adjust for PC-relative relocation.  */
  value -= (input_section->output_section->vma
	    + input_section->output_offset);
  value -= rello->r_offset;

  /* Relocate.  */
  value += rello->r_addend;

  /* Adjust the value by 4, then separate the fields and insert.  */
  value = (value - 4) >> howto->rightshift;
  value = (((value & 0xf800) << 5) | (value & 0x7ff)) & howto->dst_mask;
  insn = (insn & ~howto->dst_mask) | value;

  bfd_put_32 (input_bfd, insn, contents + rello->r_offset);
  return bfd_reloc_ok;

}

/* Specialized relocation handler for R_860_PC26.  This relocation
   involves a 26-bit, PC-relative field which must be adjusted by 4.  */
static bfd_reloc_status_type
elf32_i860_relocate_pc26 (bfd *input_bfd,
			  asection *input_section,
			  Elf_Internal_Rela *rello,
			  bfd_byte *contents,
			  bfd_vma value)
{
  bfd_vma insn;
  reloc_howto_type *howto;
  howto = lookup_howto ((unsigned) ELF32_R_TYPE (rello->r_info));
  insn = bfd_get_32 (input_bfd, contents + rello->r_offset);

  /* Adjust for PC-relative relocation.  */
  value -= (input_section->output_section->vma
	    + input_section->output_offset);
  value -= rello->r_offset;

  /* Relocate.  */
  value += rello->r_addend;

  /* Adjust value by 4 and insert the field.  */
  value = ((value - 4) >> howto->rightshift) & howto->dst_mask;
  insn = (insn & ~howto->dst_mask) | value;

  bfd_put_32 (input_bfd, insn, contents + rello->r_offset);
  return bfd_reloc_ok;

}

/* Specialized relocation handler for R_860_HIGHADJ.  */
static bfd_reloc_status_type
elf32_i860_relocate_highadj (bfd *input_bfd,
			     Elf_Internal_Rela *rel,
			     bfd_byte *contents,
			     bfd_vma value)
{
  bfd_vma insn;

  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);

  value += rel->r_addend;
  value += 0x8000; 
  value = ((value >> 16) & 0xffff);

  insn = (insn & 0xffff0000) | value;

  bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
  return bfd_reloc_ok;
}

/* Perform a single relocation.  By default we use the standard BFD
   routines. However, we handle some specially.  */
static bfd_reloc_status_type
i860_final_link_relocate (reloc_howto_type *howto,
			  bfd *input_bfd,
			  asection *input_section,
			  bfd_byte *contents,
			  Elf_Internal_Rela *rel,
			  bfd_vma relocation)
{
  return _bfd_final_link_relocate (howto, input_bfd, input_section,
				   contents, rel->r_offset, relocation,
				   rel->r_addend);
}

/* Relocate an i860 ELF section.

   This is boiler-plate code copied from fr30.

   The RELOCATE_SECTION function is called by the new ELF backend linker
   to handle the relocations for a section.

   The relocs are always passed as Rela structures; if the section
   actually uses Rel structures, the r_addend field will always be
   zero.

   This function is responsible for adjusting the section contents as
   necessary, and (if using Rela relocs and generating a relocatable
   output file) adjusting the reloc addend as necessary.

   This function does not have to worry about setting the reloc
   address or the reloc symbol index.

   LOCAL_SYMS is a pointer to the swapped in local symbols.

   LOCAL_SECTIONS is an array giving the section in the input file
   corresponding to the st_shndx field of each local symbol.

   The global hash table entry for the global symbols can be found
   via elf_sym_hashes (input_bfd).

   When generating relocatable output, this function must handle
   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
   going to be the section symbol corresponding to the output
   section, which means that the addend must be adjusted
   accordingly.  */
static bfd_boolean
elf32_i860_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
			     struct bfd_link_info *info,
			     bfd *input_bfd,
			     asection *input_section,
			     bfd_byte *contents,
			     Elf_Internal_Rela *relocs,
			     Elf_Internal_Sym *local_syms,
			     asection **local_sections)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;

  if (info->relocatable)
    return TRUE;

  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  relend     = relocs + input_section->reloc_count;

  for (rel = relocs; rel < relend; rel ++)
    {
      reloc_howto_type *           howto;
      unsigned long                r_symndx;
      Elf_Internal_Sym *           sym;
      asection *                   sec;
      struct elf_link_hash_entry * h;
      bfd_vma                      relocation;
      bfd_reloc_status_type        r;
      const char *                 name = NULL;
      int                          r_type;

      r_type = ELF32_R_TYPE (rel->r_info);

#if 0
      if (   r_type == R_860_GNU_VTINHERIT
	  || r_type == R_860_GNU_VTENTRY)
	continue;
#endif

      r_symndx = ELF32_R_SYM (rel->r_info);

      howto = lookup_howto ((unsigned) ELF32_R_TYPE (rel->r_info));
      h     = NULL;
      sym   = NULL;
      sec   = NULL;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections [r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);

	  name = bfd_elf_string_from_elf_section
	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
	}
      else
	{
	  bfd_boolean unresolved_reloc, warned;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
	}

      switch (r_type)
	{
	default:
	  r = i860_final_link_relocate (howto, input_bfd, input_section,
					contents, rel, relocation);
	  break;

	case R_860_HIGHADJ:
	  r = elf32_i860_relocate_highadj (input_bfd, rel, contents,
					   relocation);
	  break;

	case R_860_PC16:
	  r = elf32_i860_relocate_pc16 (input_bfd, input_section, rel,
					contents, relocation);
	  break;

	case R_860_PC26:
	  r = elf32_i860_relocate_pc26 (input_bfd, input_section, rel,
					contents, relocation);
	  break;

	case R_860_SPLIT0:
	case R_860_SPLIT1:
	case R_860_SPLIT2:
	  r = elf32_i860_relocate_splitn (input_bfd, rel, contents,
					  relocation);
	  break;

	/* We do not yet handle GOT/PLT/Dynamic relocations.  */
	case R_860_COPY:
	case R_860_GLOB_DAT:
	case R_860_JUMP_SLOT:
	case R_860_RELATIVE:
	case R_860_PLT26:
	case R_860_LOGOT0:
	case R_860_SPGOT0:
	case R_860_LOGOT1:
	case R_860_SPGOT1:
	case R_860_LOGOTOFF0:
	case R_860_SPGOTOFF0:
	case R_860_LOGOTOFF1:
	case R_860_SPGOTOFF1:
	case R_860_LOGOTOFF2:
	case R_860_LOGOTOFF3:
	case R_860_LOPC:
	case R_860_HAGOT:
	case R_860_HAGOTOFF:
	case R_860_HAPC:
	case R_860_HIGOT:
	case R_860_HIGOTOFF:
	  r = bfd_reloc_notsupported;
	  break;
	}

      if (r != bfd_reloc_ok)
	{
	  const char * msg = (const char *) NULL;

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      r = info->callbacks->reloc_overflow
		(info, name, howto->name, (bfd_vma) 0,
		 input_bfd, input_section, rel->r_offset);
	      break;

	    case bfd_reloc_undefined:
	      r = info->callbacks->undefined_symbol
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
	      break;

	    case bfd_reloc_outofrange:
	      msg = _("internal error: out of range error");
	      break;

	    case bfd_reloc_notsupported:
	      msg = _("internal error: unsupported relocation error");
	      break;

	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous relocation");
	      break;

	    default:
	      msg = _("internal error: unknown error");
	      break;
	    }

	  if (msg)
	    r = info->callbacks->warning
	      (info, msg, name, input_bfd, input_section, rel->r_offset);

	  if (! r)
	    return FALSE;
	}
    }

  return TRUE;
}

/* Return whether a symbol name implies a local label.  SVR4/860 compilers
   generate labels of the form ".ep.function_name" to denote the end of a
   function prolog. These should be local.
   ??? Do any other SVR4 compilers have this convention? If so, this should
   be added to the generic routine.  */
static bfd_boolean
elf32_i860_is_local_label_name (bfd *abfd, const char *name)
{
  if (name[0] == '.' && name[1] == 'e' && name[2] == 'p' && name[3] == '.')
    return TRUE;

  return _bfd_elf_is_local_label_name (abfd, name);
}

#define TARGET_BIG_SYM		bfd_elf32_i860_vec
#define TARGET_BIG_NAME		"elf32-i860"
#define TARGET_LITTLE_SYM	bfd_elf32_i860_little_vec
#define TARGET_LITTLE_NAME	"elf32-i860-little"
#define ELF_ARCH		bfd_arch_i860
#define ELF_MACHINE_CODE	EM_860
#define ELF_MAXPAGESIZE		4096

#define elf_backend_rela_normal			1
#define elf_info_to_howto_rel                   NULL
#define elf_info_to_howto			elf32_i860_info_to_howto_rela
#define elf_backend_relocate_section		elf32_i860_relocate_section
#define bfd_elf32_bfd_reloc_type_lookup		elf32_i860_reloc_type_lookup
#define bfd_elf32_bfd_is_local_label_name	elf32_i860_is_local_label_name

#include "elf32-target.h"
@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 1
a2 1
   Copyright 1993, 1995, 1999, 2000, 2001, 2002
d29 13
a41 3
/* Prototypes.  */
static reloc_howto_type *lookup_howto
  PARAMS ((unsigned int));
d43 43
a85 2
static reloc_howto_type *elf32_i860_reloc_type_lookup
  PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
d87 1
a87 2
static void elf32_i860_info_to_howto_rela
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d89 89
a177 2
static bfd_reloc_status_type elf32_i860_relocate_splitn
  PARAMS ((bfd *,  Elf_Internal_Rela *, bfd_byte *, bfd_vma));
d179 4
a182 2
static bfd_reloc_status_type elf32_i860_relocate_pc16
  PARAMS ((bfd *,  asection *, Elf_Internal_Rela *, bfd_byte *, bfd_vma));
d184 4
a187 2
static bfd_reloc_status_type elf32_i860_relocate_pc26
  PARAMS ((bfd *,  asection *, Elf_Internal_Rela *, bfd_byte *, bfd_vma));
d189 4
a192 2
static bfd_reloc_status_type elf32_i860_relocate_highadj
  PARAMS ((bfd *,  Elf_Internal_Rela *, bfd_byte *, bfd_vma));
d194 2
a195 3
static bfd_boolean elf32_i860_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
d197 2
a198 3
static bfd_reloc_status_type i860_final_link_relocate
  PARAMS ((reloc_howto_type *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, bfd_vma));
d200 60
a259 2
static bfd_boolean elf32_i860_is_local_label_name
  PARAMS ((bfd *, const char *));
d358 1
a358 1
	 bfd_elf_generic_reloc,	/* special_function */
d387 1
a387 1
	 bfd_elf_generic_reloc,	/* special_function */
d415 1
a415 1
	 bfd_elf_generic_reloc,	/* special_function */
d443 1
a443 1
	 bfd_elf_generic_reloc,	/* special_function */
d471 1
a471 1
	 bfd_elf_generic_reloc,	/* special_function */
d653 1
a653 1
	 bfd_elf_generic_reloc,	/* special_function */
d748 1
a748 2
lookup_howto (rtype)
     unsigned int rtype;
d773 2
a774 3
elf32_i860_reloc_type_lookup (abfd, code)
     bfd * abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d891 3
a893 4
elf32_i860_info_to_howto_rela (abfd, bfd_reloc, elf_reloc)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *bfd_reloc;
     Elf_Internal_Rela *elf_reloc;
d902 4
a905 5
elf32_i860_relocate_splitn (input_bfd, rello, contents, value)
     bfd *input_bfd;
     Elf_Internal_Rela *rello;
     bfd_byte *contents;
     bfd_vma value;
d916 1
a916 1
  value = (((value & 0xf8) << 5) | (value & 0x7ff)) & howto->dst_mask;
d927 5
a931 6
elf32_i860_relocate_pc16 (input_bfd, input_section, rello, contents, value)
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *rello;
     bfd_byte *contents;
     bfd_vma value;
d946 3
a948 2
  /* Separate the fields and insert.  */
  value = (((value & 0xf8) << 5) | (value & 0x7ff)) & howto->dst_mask;
d959 5
a963 6
elf32_i860_relocate_pc26 (input_bfd, input_section, rello, contents, value)
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *rello;
     bfd_byte *contents;
     bfd_vma value;
d989 4
a992 5
elf32_i860_relocate_highadj (input_bfd, rel, contents, value)
     bfd *input_bfd;
     Elf_Internal_Rela *rel;
     bfd_byte *contents;
     bfd_vma value;
a997 1
  value += ((rel->r_addend & 0x8000) << 1);
d999 1
d1011 6
a1016 7
i860_final_link_relocate (howto, input_bfd, input_section, contents, rel, relocation)
     reloc_howto_type *  howto;
     bfd *               input_bfd;
     asection *          input_section;
     bfd_byte *          contents;
     Elf_Internal_Rela * rel;
     bfd_vma             relocation;
d1035 1
a1035 1
   necessary, and (if using Rela relocs and generating a relocateable
d1049 1
a1049 1
   When generating relocateable output, this function must handle
d1055 8
a1062 10
elf32_i860_relocate_section (output_bfd, info, input_bfd, input_section,
			     contents, relocs, local_syms, local_sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d1069 1
a1069 1
  if (info->relocateable)
d1107 1
a1107 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
d1115 1
a1115 1
	  h = sym_hashes [r_symndx - symtab_hdr->sh_info];
d1117 4
a1120 26
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  name = h->root.root.string;

	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sec->output_section->vma
			    + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    {
	      relocation = 0;
	    }
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
	      relocation = 0;
	    }
d1230 1
a1230 3
elf32_i860_is_local_label_name (abfd, name)
     bfd *abfd;
     const char *name;
@


1.3
log
@resolve conflicts.
@
text
@d2 2
a3 1
   Copyright 1993, 1995, 1999, 2000, 2001 Free Software Foundation, Inc.
d37 1
a37 1
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rela *));
d51 1
a51 1
static boolean elf32_i860_relocate_section
d59 1
a59 1
static boolean elf32_i860_is_local_label_name
d70 1
a70 1
	 false,			/* pc_relative */
d75 1
a75 1
	 false,			/* partial_inplace */
d78 1
a78 1
	 false),		/* pcrel_offset */
d85 1
a85 1
	 false,			/* pc_relative */
d90 1
a90 1
	 false,			/* partial_inplace */
d93 1
a93 1
	 false),		/* pcrel_offset */
d99 1
a99 1
	 false,			/* pc_relative */
d104 1
a104 1
	 true,			/* partial_inplace */
d107 1
a107 1
	 false),		/* pcrel_offset */
d113 1
a113 1
	 false,			/* pc_relative */
d118 1
a118 1
	 true,			/* partial_inplace */
d121 1
a121 1
	 false),		/* pcrel_offset */
d127 1
a127 1
	 false,			/* pc_relative */
d132 1
a132 1
	 true,			/* partial_inplace */
d135 1
a135 1
	 false),		/* pcrel_offset */
d141 1
a141 1
	 false,			/* pc_relative */
d146 1
a146 1
	 true,			/* partial_inplace */
d149 1
a149 1
	 false),		/* pcrel_offset */
d156 1
a156 1
	 true,			/* pc_relative */
d161 1
a161 1
	 false,			/* partial_inplace */
d164 1
a164 1
	 true),		        /* pcrel_offset */
d170 1
a170 1
	 true,			/* pc_relative */
d175 1
a175 1
	 true,			/* partial_inplace */
d178 1
a178 1
	 true),		        /* pcrel_offset */
d185 1
a185 1
	 true,			/* pc_relative */
d190 1
a190 1
	 false,			/* partial_inplace */
d193 1
a193 1
	 true),		        /* pcrel_offset */
d199 1
a199 1
	 false,			/* pc_relative */
d204 1
a204 1
	 false,			/* partial_inplace */
d207 1
a207 1
	 false),	        /* pcrel_offset */
d213 1
a213 1
	 false,			/* pc_relative */
d218 1
a218 1
	 false,			/* partial_inplace */
d221 1
a221 1
	 false),	        /* pcrel_offset */
d227 1
a227 1
	 false,			/* pc_relative */
d232 1
a232 1
	 false,			/* partial_inplace */
d235 1
a235 1
	 false),	        /* pcrel_offset */
d241 1
a241 1
	 false,			/* pc_relative */
d246 1
a246 1
	 false,			/* partial_inplace */
d249 1
a249 1
	 false),	        /* pcrel_offset */
d255 1
a255 1
	 false,			/* pc_relative */
d260 1
a260 1
	 false,			/* partial_inplace */
d263 1
a263 1
	 false),	        /* pcrel_offset */
d269 1
a269 1
	 false,			/* pc_relative */
d274 1
a274 1
	 false,			/* partial_inplace */
d277 1
a277 1
	 false),	        /* pcrel_offset */
d283 1
a283 1
	 false,			/* pc_relative */
d288 1
a288 1
	 false,			/* partial_inplace */
d291 1
a291 1
	 false),	        /* pcrel_offset */
d297 1
a297 1
	 false,			/* pc_relative */
d302 1
a302 1
	 false,			/* partial_inplace */
d305 1
a305 1
	 true),		        /* pcrel_offset */
d311 1
a311 1
	 false,			/* pc_relative */
d316 1
a316 1
	 false,			/* partial_inplace */
d319 1
a319 1
	 true),		        /* pcrel_offset */
d325 1
a325 1
	 false,			/* pc_relative */
d330 1
a330 1
	 false,			/* partial_inplace */
d333 1
a333 1
	 true),		        /* pcrel_offset */
d339 1
a339 1
	 false,			/* pc_relative */
d344 1
a344 1
	 false,			/* partial_inplace */
d347 1
a347 1
	 true),		        /* pcrel_offset */
d353 1
a353 1
	 false,			/* pc_relative */
d358 1
a358 1
	 true,			/* partial_inplace */
d361 1
a361 1
	 false),	        /* pcrel_offset */
d367 1
a367 1
	 false,			/* pc_relative */
d372 1
a372 1
	 true,			/* partial_inplace */
d375 1
a375 1
	 false),	        /* pcrel_offset */
d381 1
a381 1
	 false,			/* pc_relative */
d386 1
a386 1
	 true,			/* partial_inplace */
d389 1
a389 1
	 false),	        /* pcrel_offset */
d395 1
a395 1
	 false,			/* pc_relative */
d400 1
a400 1
	 true,			/* partial_inplace */
d403 1
a403 1
	 false),	        /* pcrel_offset */
d409 1
a409 1
	 false,			/* pc_relative */
d414 1
a414 1
	 true,			/* partial_inplace */
d417 1
a417 1
	 false),	        /* pcrel_offset */
d423 1
a423 1
	 false,			/* pc_relative */
d428 1
a428 1
	 true,			/* partial_inplace */
d431 1
a431 1
	 false),	        /* pcrel_offset */
d437 1
a437 1
	 true,			/* pc_relative */
d442 1
a442 1
	 false,			/* partial_inplace */
d445 1
a445 1
	 true),		        /* pcrel_offset */
d451 1
a451 1
	 false,			/* pc_relative */
d456 1
a456 1
	 false,			/* partial_inplace */
d459 1
a459 1
	 false),	        /* pcrel_offset */
d465 1
a465 1
	 false,			/* pc_relative */
d470 1
a470 1
	 false,			/* partial_inplace */
d473 1
a473 1
	 true),		        /* pcrel_offset */
d479 1
a479 1
	 false,			/* pc_relative */
d484 1
a484 1
	 true,			/* partial_inplace */
d487 1
a487 1
	 false),	        /* pcrel_offset */
d493 1
a493 1
	 true,			/* pc_relative */
d498 1
a498 1
	 false,			/* partial_inplace */
d501 1
a501 1
	 true),		        /* pcrel_offset */
d507 1
a507 1
	 false,			/* pc_relative */
d512 1
a512 1
	 false,			/* partial_inplace */
d515 1
a515 1
	 false),	        /* pcrel_offset */
d521 1
a521 1
	 false,			/* pc_relative */
d526 1
a526 1
	 false,			/* partial_inplace */
d529 1
a529 1
	 true),		        /* pcrel_offset */
d535 1
a535 1
	 false,			/* pc_relative */
d540 1
a540 1
	 true,			/* partial_inplace */
d543 1
a543 1
	 false),	        /* pcrel_offset */
d697 1
a697 1
     Elf64_Internal_Rela *elf_reloc;
d699 2
a700 1
  bfd_reloc->howto = lookup_howto (ELF32_R_TYPE (elf_reloc->r_info));
d714 1
a714 1
  howto  = lookup_howto (ELF32_R_TYPE (rello->r_info));
d741 1
a741 1
  howto  = lookup_howto (ELF32_R_TYPE (rello->r_info));
d773 1
a773 1
  howto  = lookup_howto (ELF32_R_TYPE (rello->r_info));
a833 3
   There is some attempt to make this function usable for many architectures,
   both USE_REL and USE_RELA ['twould be nice if such a critter existed],
   if only to serve as a learning tool.
d862 1
a862 1
static boolean
d865 8
a872 8
     bfd *                   output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *  info;
     bfd *                   input_bfd;
     asection *              input_section;
     bfd_byte *              contents;
     Elf_Internal_Rela *     relocs;
     Elf_Internal_Sym *      local_syms;
     asection **             local_sections;
d874 7
a880 4
  Elf_Internal_Shdr *           symtab_hdr;
  struct elf_link_hash_entry ** sym_hashes;
  Elf_Internal_Rela *           rel;
  Elf_Internal_Rela *           relend;
d908 4
a911 25
      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
             anything, unless the reloc is against a section symbol,
             in which case we have to adjust according to where the
             section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;

	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections [r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.  */
      howto  = lookup_howto (ELF32_R_TYPE (rel->r_info));
      h      = NULL;
      sym    = NULL;
      sec    = NULL;
d917 1
a917 3
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
d949 2
a950 2
		      input_section, rel->r_offset, true)))
		return false;
d1024 1
a1024 1
		(info, name, input_bfd, input_section, rel->r_offset, true);
d1049 1
a1049 1
	    return false;
d1053 1
a1053 1
  return true;
d1061 1
a1061 1
static boolean
d1067 1
a1067 1
    return true;
d1080 1
@


1.2
log
@Help stupid cvs fixing basic conflicts.
@
text
@d1 4
a4 2
/* Intel 860 specific support for 32-bit ELF
   Copyright 1993 Free Software Foundation, Inc.
d26 1063
d1090 10
a1099 2
#define bfd_elf32_bfd_reloc_type_lookup	bfd_default_reloc_type_lookup
#define elf_info_to_howto		_bfd_elf_no_info_to_howto
d1101 5
a1105 5
#define TARGET_BIG_SYM	 bfd_elf32_i860_vec
#define TARGET_BIG_NAME  "elf32-i860"
#define ELF_ARCH	 bfd_arch_i860
#define ELF_MACHINE_CODE EM_860
#define ELF_MAXPAGESIZE  1 /* FIXME: This number is wrong,  It should be the page size in bytes.  */
@


1.1
log
@Initial revision
@
text
@d28 3
a30 3
#define TARGET_BIG_SYM	bfd_elf32_i860_vec
#define TARGET_BIG_NAME "elf32-i860"
#define ELF_ARCH	bfd_arch_i860
d32 1
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d28 3
a30 3
#define TARGET_BIG_SYM	 bfd_elf32_i860_vec
#define TARGET_BIG_NAME  "elf32-i860"
#define ELF_ARCH	 bfd_arch_i860
a31 1
#define ELF_MAXPAGESIZE  1 /* FIXME: This number is wrong,  It should be the page size in bytes.  */
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d1 2
a2 4
/* Intel i860 specific support for 32-bit ELF.
   Copyright 1993, 1995, 1999, 2000, 2001 Free Software Foundation, Inc.

   Full i860 support contributed by Jason Eckhardt <jle@@cygnus.com>.
a23 1063
#include "elf/i860.h"

/* Prototypes.  */
static reloc_howto_type *lookup_howto
  PARAMS ((unsigned int));

static reloc_howto_type *elf32_i860_reloc_type_lookup
  PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));

static void elf32_i860_info_to_howto_rela
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rela *));

static bfd_reloc_status_type elf32_i860_relocate_splitn
  PARAMS ((bfd *,  Elf_Internal_Rela *, bfd_byte *, bfd_vma));

static bfd_reloc_status_type elf32_i860_relocate_pc16
  PARAMS ((bfd *,  asection *, Elf_Internal_Rela *, bfd_byte *, bfd_vma));

static bfd_reloc_status_type elf32_i860_relocate_pc26
  PARAMS ((bfd *,  asection *, Elf_Internal_Rela *, bfd_byte *, bfd_vma));

static bfd_reloc_status_type elf32_i860_relocate_highadj
  PARAMS ((bfd *,  Elf_Internal_Rela *, bfd_byte *, bfd_vma));

static boolean elf32_i860_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));

static bfd_reloc_status_type i860_final_link_relocate
  PARAMS ((reloc_howto_type *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, bfd_vma));

static boolean elf32_i860_is_local_label_name
  PARAMS ((bfd *, const char *));

/* This howto table is preliminary.  */
static reloc_howto_type elf32_i860_howto_table [] =
{
  /* This relocation does nothing.  */
  HOWTO (R_860_NONE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_NONE",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

  /* A 32-bit absolute relocation.  */
  HOWTO (R_860_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_32",		/* name */
	 false,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_860_COPY,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_COPY",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_860_GLOB_DAT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_GLOB_DAT",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_860_JUMP_SLOT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_JUMP_SLOT",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_860_RELATIVE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_RELATIVE",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* A 26-bit PC-relative relocation.  */
  HOWTO (R_860_PC26,	        /* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_PC26",		/* name */
	 false,			/* partial_inplace */
	 0x3ffffff,		/* src_mask */
	 0x3ffffff,		/* dst_mask */
	 true),		        /* pcrel_offset */

  HOWTO (R_860_PLT26,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_PLT26",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 true),		        /* pcrel_offset */

  /* A 16-bit PC-relative relocation.  */
  HOWTO (R_860_PC16,	        /* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_PC16",		/* name */
	 false,			/* partial_inplace */
	 0x1f07ff,		/* src_mask */
	 0x1f07ff,		/* dst_mask */
	 true),		        /* pcrel_offset */

  HOWTO (R_860_LOW0,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOW0",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),	        /* pcrel_offset */

  HOWTO (R_860_SPLIT0,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_SPLIT0",	/* name */
	 false,			/* partial_inplace */
	 0x1f07ff,		/* src_mask */
	 0x1f07ff,		/* dst_mask */
	 false),	        /* pcrel_offset */

  HOWTO (R_860_LOW1,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOW1",		/* name */
	 false,			/* partial_inplace */
	 0xfffe,		/* src_mask */
	 0xfffe,		/* dst_mask */
	 false),	        /* pcrel_offset */

  HOWTO (R_860_SPLIT1,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_SPLIT1",	/* name */
	 false,			/* partial_inplace */
	 0x1f07fe,		/* src_mask */
	 0x1f07fe,		/* dst_mask */
	 false),	        /* pcrel_offset */

  HOWTO (R_860_LOW2,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOW2",		/* name */
	 false,			/* partial_inplace */
	 0xfffc,		/* src_mask */
	 0xfffc,		/* dst_mask */
	 false),	        /* pcrel_offset */

  HOWTO (R_860_SPLIT2,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_SPLIT2",	/* name */
	 false,			/* partial_inplace */
	 0x1f07fc,		/* src_mask */
	 0x1f07fc,		/* dst_mask */
	 false),	        /* pcrel_offset */

  HOWTO (R_860_LOW3,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOW3",		/* name */
	 false,			/* partial_inplace */
	 0xfff8,		/* src_mask */
	 0xfff8,		/* dst_mask */
	 false),	        /* pcrel_offset */

  HOWTO (R_860_LOGOT0,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOGOT0",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 true),		        /* pcrel_offset */

  HOWTO (R_860_SPGOT0,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_SPGOT0",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 true),		        /* pcrel_offset */

  HOWTO (R_860_LOGOT1,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOGOT1",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 true),		        /* pcrel_offset */

  HOWTO (R_860_SPGOT1,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_SPGOT1",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 true),		        /* pcrel_offset */

  HOWTO (R_860_LOGOTOFF0,        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOGOTOFF0",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),	        /* pcrel_offset */

  HOWTO (R_860_SPGOTOFF0,        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_SPGOTOFF0",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),	        /* pcrel_offset */

  HOWTO (R_860_LOGOTOFF1,        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOGOTOFF1",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),	        /* pcrel_offset */

  HOWTO (R_860_SPGOTOFF1,       /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_SPGOTOFF1",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),	        /* pcrel_offset */

  HOWTO (R_860_LOGOTOFF2,        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOGOTOFF2",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),	        /* pcrel_offset */

  HOWTO (R_860_LOGOTOFF3,        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOGOTOFF3",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),	        /* pcrel_offset */

  HOWTO (R_860_LOPC,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_LOPC",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 true),		        /* pcrel_offset */

  HOWTO (R_860_HIGHADJ,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_HIGHADJ",	/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),	        /* pcrel_offset */

  HOWTO (R_860_HAGOT,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_HAGOT",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 true),		        /* pcrel_offset */

  HOWTO (R_860_HAGOTOFF,        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_HAGOTOFF",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),	        /* pcrel_offset */

  HOWTO (R_860_HAPC,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_HAPC",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 true),		        /* pcrel_offset */

  HOWTO (R_860_HIGH,	        /* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_HIGH",		/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),	        /* pcrel_offset */

  HOWTO (R_860_HIGOT,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_HIGOT",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 true),		        /* pcrel_offset */

  HOWTO (R_860_HIGOTOFF,        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_860_HIGOTOFF",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),	        /* pcrel_offset */
};

static unsigned char elf_code_to_howto_index[R_860_max + 1];

static reloc_howto_type *
lookup_howto (rtype)
     unsigned int rtype;
{
  static int initialized = 0;
  int i;
  int howto_tbl_size = (int) (sizeof (elf32_i860_howto_table)
			/ sizeof (elf32_i860_howto_table[0]));

  if (! initialized)
    {
      initialized = 1;
      memset (elf_code_to_howto_index, 0xff,
	      sizeof (elf_code_to_howto_index));
      for (i = 0; i < howto_tbl_size; i++)
        elf_code_to_howto_index[elf32_i860_howto_table[i].type] = i;
    }

  BFD_ASSERT (rtype <= R_860_max);
  i = elf_code_to_howto_index[rtype];
  if (i >= howto_tbl_size)
    return 0;
  return elf32_i860_howto_table + i;
}

/* Given a BFD reloc, return the matching HOWTO structure.  */
static reloc_howto_type *
elf32_i860_reloc_type_lookup (abfd, code)
     bfd * abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
{
  unsigned int rtype;

  switch (code)
    {
    case BFD_RELOC_NONE:
      rtype = R_860_NONE;
      break;
    case BFD_RELOC_32:
      rtype = R_860_32;
      break;
    case BFD_RELOC_860_COPY:
      rtype = R_860_COPY;
      break;
    case BFD_RELOC_860_GLOB_DAT:
      rtype = R_860_GLOB_DAT;
      break;
    case BFD_RELOC_860_JUMP_SLOT:
      rtype = R_860_JUMP_SLOT;
      break;
    case BFD_RELOC_860_RELATIVE:
      rtype = R_860_RELATIVE;
      break;
    case BFD_RELOC_860_PC26:
      rtype = R_860_PC26;
      break;
    case BFD_RELOC_860_PLT26:
      rtype = R_860_PLT26;
      break;
    case BFD_RELOC_860_PC16:
      rtype = R_860_PC16;
      break;
    case BFD_RELOC_860_LOW0:
      rtype = R_860_LOW0;
      break;
    case BFD_RELOC_860_SPLIT0:
      rtype = R_860_SPLIT0;
      break;
    case BFD_RELOC_860_LOW1:
      rtype = R_860_LOW1;
      break;
    case BFD_RELOC_860_SPLIT1:
      rtype = R_860_SPLIT1;
      break;
    case BFD_RELOC_860_LOW2:
      rtype = R_860_LOW2;
      break;
    case BFD_RELOC_860_SPLIT2:
      rtype = R_860_SPLIT2;
      break;
    case BFD_RELOC_860_LOW3:
      rtype = R_860_LOW3;
      break;
    case BFD_RELOC_860_LOGOT0:
      rtype = R_860_LOGOT0;
      break;
    case BFD_RELOC_860_SPGOT0:
      rtype = R_860_SPGOT0;
      break;
    case BFD_RELOC_860_LOGOT1:
      rtype = R_860_LOGOT1;
      break;
    case BFD_RELOC_860_SPGOT1:
      rtype = R_860_SPGOT1;
      break;
    case BFD_RELOC_860_LOGOTOFF0:
      rtype = R_860_LOGOTOFF0;
      break;
    case BFD_RELOC_860_SPGOTOFF0:
      rtype = R_860_SPGOTOFF0;
      break;
    case BFD_RELOC_860_LOGOTOFF1:
      rtype = R_860_LOGOTOFF1;
      break;
    case BFD_RELOC_860_SPGOTOFF1:
      rtype = R_860_SPGOTOFF1;
      break;
    case BFD_RELOC_860_LOGOTOFF2:
      rtype = R_860_LOGOTOFF2;
      break;
    case BFD_RELOC_860_LOGOTOFF3:
      rtype = R_860_LOGOTOFF3;
      break;
    case BFD_RELOC_860_LOPC:
      rtype = R_860_LOPC;
      break;
    case BFD_RELOC_860_HIGHADJ:
      rtype = R_860_HIGHADJ;
      break;
    case BFD_RELOC_860_HAGOT:
      rtype = R_860_HAGOT;
      break;
    case BFD_RELOC_860_HAGOTOFF:
      rtype = R_860_HAGOTOFF;
      break;
    case BFD_RELOC_860_HAPC:
      rtype = R_860_HAPC;
      break;
    case BFD_RELOC_860_HIGH:
      rtype = R_860_HIGH;
      break;
    case BFD_RELOC_860_HIGOT:
      rtype = R_860_HIGOT;
      break;
    case BFD_RELOC_860_HIGOTOFF:
      rtype = R_860_HIGOTOFF;
      break;
    default:
      rtype = 0;
      break;
    }
  return lookup_howto (rtype);
}

/* Given a ELF reloc, return the matching HOWTO structure.  */
static void
elf32_i860_info_to_howto_rela (abfd, bfd_reloc, elf_reloc)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *bfd_reloc;
     Elf64_Internal_Rela *elf_reloc;
{
  bfd_reloc->howto = lookup_howto (ELF32_R_TYPE (elf_reloc->r_info));
}

/* Specialized relocation handler for R_860_SPLITn.  These relocations
   involves a 16-bit field that is split into two contiguous parts.  */
static bfd_reloc_status_type
elf32_i860_relocate_splitn (input_bfd, rello, contents, value)
     bfd *input_bfd;
     Elf_Internal_Rela *rello;
     bfd_byte *contents;
     bfd_vma value;
{
  bfd_vma insn;
  reloc_howto_type *howto;
  howto  = lookup_howto (ELF32_R_TYPE (rello->r_info));
  insn = bfd_get_32 (input_bfd, contents + rello->r_offset);

  /* Relocate.  */
  value += rello->r_addend;

  /* Separate the fields and insert.  */
  value = (((value & 0xf8) << 5) | (value & 0x7ff)) & howto->dst_mask;
  insn = (insn & ~howto->dst_mask) | value;

  bfd_put_32 (input_bfd, insn, contents + rello->r_offset);
  return bfd_reloc_ok;
}

/* Specialized relocation handler for R_860_PC16.  This relocation
   involves a 16-bit, PC-relative field that is split into two contiguous
   parts.  */
static bfd_reloc_status_type
elf32_i860_relocate_pc16 (input_bfd, input_section, rello, contents, value)
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *rello;
     bfd_byte *contents;
     bfd_vma value;
{
  bfd_vma insn;
  reloc_howto_type *howto;
  howto  = lookup_howto (ELF32_R_TYPE (rello->r_info));
  insn = bfd_get_32 (input_bfd, contents + rello->r_offset);

  /* Adjust for PC-relative relocation.  */
  value -= (input_section->output_section->vma
	    + input_section->output_offset);
  value -= rello->r_offset;

  /* Relocate.  */
  value += rello->r_addend;

  /* Separate the fields and insert.  */
  value = (((value & 0xf8) << 5) | (value & 0x7ff)) & howto->dst_mask;
  insn = (insn & ~howto->dst_mask) | value;

  bfd_put_32 (input_bfd, insn, contents + rello->r_offset);
  return bfd_reloc_ok;

}

/* Specialized relocation handler for R_860_PC26.  This relocation
   involves a 26-bit, PC-relative field which must be adjusted by 4.  */
static bfd_reloc_status_type
elf32_i860_relocate_pc26 (input_bfd, input_section, rello, contents, value)
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *rello;
     bfd_byte *contents;
     bfd_vma value;
{
  bfd_vma insn;
  reloc_howto_type *howto;
  howto  = lookup_howto (ELF32_R_TYPE (rello->r_info));
  insn = bfd_get_32 (input_bfd, contents + rello->r_offset);

  /* Adjust for PC-relative relocation.  */
  value -= (input_section->output_section->vma
	    + input_section->output_offset);
  value -= rello->r_offset;

  /* Relocate.  */
  value += rello->r_addend;

  /* Adjust value by 4 and insert the field.  */
  value = ((value - 4) >> howto->rightshift) & howto->dst_mask;
  insn = (insn & ~howto->dst_mask) | value;

  bfd_put_32 (input_bfd, insn, contents + rello->r_offset);
  return bfd_reloc_ok;

}

/* Specialized relocation handler for R_860_HIGHADJ.  */
static bfd_reloc_status_type
elf32_i860_relocate_highadj (input_bfd, rel, contents, value)
     bfd *input_bfd;
     Elf_Internal_Rela *rel;
     bfd_byte *contents;
     bfd_vma value;
{
  bfd_vma insn;

  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);

  value += ((rel->r_addend & 0x8000) << 1);
  value += rel->r_addend;
  value = ((value >> 16) & 0xffff);

  insn = (insn & 0xffff0000) | value;

  bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
  return bfd_reloc_ok;
}

/* Perform a single relocation.  By default we use the standard BFD
   routines. However, we handle some specially.  */
static bfd_reloc_status_type
i860_final_link_relocate (howto, input_bfd, input_section, contents, rel, relocation)
     reloc_howto_type *  howto;
     bfd *               input_bfd;
     asection *          input_section;
     bfd_byte *          contents;
     Elf_Internal_Rela * rel;
     bfd_vma             relocation;
{
  return _bfd_final_link_relocate (howto, input_bfd, input_section,
				   contents, rel->r_offset, relocation,
				   rel->r_addend);
}

/* Relocate an i860 ELF section.

   This is boiler-plate code copied from fr30.
   There is some attempt to make this function usable for many architectures,
   both USE_REL and USE_RELA ['twould be nice if such a critter existed],
   if only to serve as a learning tool.

   The RELOCATE_SECTION function is called by the new ELF backend linker
   to handle the relocations for a section.

   The relocs are always passed as Rela structures; if the section
   actually uses Rel structures, the r_addend field will always be
   zero.

   This function is responsible for adjusting the section contents as
   necessary, and (if using Rela relocs and generating a relocateable
   output file) adjusting the reloc addend as necessary.

   This function does not have to worry about setting the reloc
   address or the reloc symbol index.

   LOCAL_SYMS is a pointer to the swapped in local symbols.

   LOCAL_SECTIONS is an array giving the section in the input file
   corresponding to the st_shndx field of each local symbol.

   The global hash table entry for the global symbols can be found
   via elf_sym_hashes (input_bfd).

   When generating relocateable output, this function must handle
   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
   going to be the section symbol corresponding to the output
   section, which means that the addend must be adjusted
   accordingly.  */
static boolean
elf32_i860_relocate_section (output_bfd, info, input_bfd, input_section,
			     contents, relocs, local_syms, local_sections)
     bfd *                   output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *  info;
     bfd *                   input_bfd;
     asection *              input_section;
     bfd_byte *              contents;
     Elf_Internal_Rela *     relocs;
     Elf_Internal_Sym *      local_syms;
     asection **             local_sections;
{
  Elf_Internal_Shdr *           symtab_hdr;
  struct elf_link_hash_entry ** sym_hashes;
  Elf_Internal_Rela *           rel;
  Elf_Internal_Rela *           relend;

  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  relend     = relocs + input_section->reloc_count;

  for (rel = relocs; rel < relend; rel ++)
    {
      reloc_howto_type *           howto;
      unsigned long                r_symndx;
      Elf_Internal_Sym *           sym;
      asection *                   sec;
      struct elf_link_hash_entry * h;
      bfd_vma                      relocation;
      bfd_reloc_status_type        r;
      const char *                 name = NULL;
      int                          r_type;

      r_type = ELF32_R_TYPE (rel->r_info);

#if 0
      if (   r_type == R_860_GNU_VTINHERIT
	  || r_type == R_860_GNU_VTENTRY)
	continue;
#endif

      r_symndx = ELF32_R_SYM (rel->r_info);

      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
             anything, unless the reloc is against a section symbol,
             in which case we have to adjust according to where the
             section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;

	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections [r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.  */
      howto  = lookup_howto (ELF32_R_TYPE (rel->r_info));
      h      = NULL;
      sym    = NULL;
      sec    = NULL;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections [r_symndx];
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);

	  name = bfd_elf_string_from_elf_section
	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
	}
      else
	{
	  h = sym_hashes [r_symndx - symtab_hdr->sh_info];

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  name = h->root.root.string;

	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sec->output_section->vma
			    + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    {
	      relocation = 0;
	    }
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset, true)))
		return false;
	      relocation = 0;
	    }
	}

      switch (r_type)
	{
	default:
	  r = i860_final_link_relocate (howto, input_bfd, input_section,
					contents, rel, relocation);
	  break;

	case R_860_HIGHADJ:
	  r = elf32_i860_relocate_highadj (input_bfd, rel, contents,
					   relocation);
	  break;

	case R_860_PC16:
	  r = elf32_i860_relocate_pc16 (input_bfd, input_section, rel,
					contents, relocation);
	  break;

	case R_860_PC26:
	  r = elf32_i860_relocate_pc26 (input_bfd, input_section, rel,
					contents, relocation);
	  break;

	case R_860_SPLIT0:
	case R_860_SPLIT1:
	case R_860_SPLIT2:
	  r = elf32_i860_relocate_splitn (input_bfd, rel, contents,
					  relocation);
	  break;

	/* We do not yet handle GOT/PLT/Dynamic relocations.  */
	case R_860_COPY:
	case R_860_GLOB_DAT:
	case R_860_JUMP_SLOT:
	case R_860_RELATIVE:
	case R_860_PLT26:
	case R_860_LOGOT0:
	case R_860_SPGOT0:
	case R_860_LOGOT1:
	case R_860_SPGOT1:
	case R_860_LOGOTOFF0:
	case R_860_SPGOTOFF0:
	case R_860_LOGOTOFF1:
	case R_860_SPGOTOFF1:
	case R_860_LOGOTOFF2:
	case R_860_LOGOTOFF3:
	case R_860_LOPC:
	case R_860_HAGOT:
	case R_860_HAGOTOFF:
	case R_860_HAPC:
	case R_860_HIGOT:
	case R_860_HIGOTOFF:
	  r = bfd_reloc_notsupported;
	  break;
	}

      if (r != bfd_reloc_ok)
	{
	  const char * msg = (const char *) NULL;

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      r = info->callbacks->reloc_overflow
		(info, name, howto->name, (bfd_vma) 0,
		 input_bfd, input_section, rel->r_offset);
	      break;

	    case bfd_reloc_undefined:
	      r = info->callbacks->undefined_symbol
		(info, name, input_bfd, input_section, rel->r_offset, true);
	      break;

	    case bfd_reloc_outofrange:
	      msg = _("internal error: out of range error");
	      break;

	    case bfd_reloc_notsupported:
	      msg = _("internal error: unsupported relocation error");
	      break;

	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous relocation");
	      break;

	    default:
	      msg = _("internal error: unknown error");
	      break;
	    }

	  if (msg)
	    r = info->callbacks->warning
	      (info, msg, name, input_bfd, input_section, rel->r_offset);

	  if (! r)
	    return false;
	}
    }

  return true;
}

/* Return whether a symbol name implies a local label.  SVR4/860 compilers
   generate labels of the form ".ep.function_name" to denote the end of a
   function prolog. These should be local.
   ??? Do any other SVR4 compilers have this convention? If so, this should
   be added to the generic routine.  */
static boolean
elf32_i860_is_local_label_name (abfd, name)
     bfd *abfd;
     const char *name;
{
  if (name[0] == '.' && name[1] == 'e' && name[2] == 'p' && name[3] == '.')
    return true;
d25 2
a26 10
  return _bfd_elf_is_local_label_name (abfd, name);
}

#define TARGET_BIG_SYM		bfd_elf32_i860_vec
#define TARGET_BIG_NAME		"elf32-i860"
#define TARGET_LITTLE_SYM	bfd_elf32_i860_little_vec
#define TARGET_LITTLE_NAME	"elf32-i860-little"
#define ELF_ARCH		bfd_arch_i860
#define ELF_MACHINE_CODE	EM_860
#define ELF_MAXPAGESIZE		4096
d28 5
a32 5
#define elf_info_to_howto_rel                   NULL
#define elf_info_to_howto			elf32_i860_info_to_howto_rela
#define elf_backend_relocate_section		elf32_i860_relocate_section
#define bfd_elf32_bfd_reloc_type_lookup		elf32_i860_reloc_type_lookup
#define bfd_elf32_bfd_is_local_label_name	elf32_i860_is_local_label_name
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 2
   Copyright 1993, 1995, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
d36 1
a36 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d50 1
a50 1
static bfd_boolean elf32_i860_relocate_section
d58 1
a58 1
static bfd_boolean elf32_i860_is_local_label_name
d69 1
a69 1
	 FALSE,			/* pc_relative */
d74 1
a74 1
	 FALSE,			/* partial_inplace */
d77 1
a77 1
	 FALSE),		/* pcrel_offset */
d84 1
a84 1
	 FALSE,			/* pc_relative */
d89 1
a89 1
	 FALSE,			/* partial_inplace */
d92 1
a92 1
	 FALSE),		/* pcrel_offset */
d98 1
a98 1
	 FALSE,			/* pc_relative */
d103 1
a103 1
	 TRUE,			/* partial_inplace */
d106 1
a106 1
	 FALSE),		/* pcrel_offset */
d112 1
a112 1
	 FALSE,			/* pc_relative */
d117 1
a117 1
	 TRUE,			/* partial_inplace */
d120 1
a120 1
	 FALSE),		/* pcrel_offset */
d126 1
a126 1
	 FALSE,			/* pc_relative */
d131 1
a131 1
	 TRUE,			/* partial_inplace */
d134 1
a134 1
	 FALSE),		/* pcrel_offset */
d140 1
a140 1
	 FALSE,			/* pc_relative */
d145 1
a145 1
	 TRUE,			/* partial_inplace */
d148 1
a148 1
	 FALSE),		/* pcrel_offset */
d155 1
a155 1
	 TRUE,			/* pc_relative */
d160 1
a160 1
	 FALSE,			/* partial_inplace */
d163 1
a163 1
	 TRUE),		        /* pcrel_offset */
d169 1
a169 1
	 TRUE,			/* pc_relative */
d174 1
a174 1
	 TRUE,			/* partial_inplace */
d177 1
a177 1
	 TRUE),		        /* pcrel_offset */
d184 1
a184 1
	 TRUE,			/* pc_relative */
d189 1
a189 1
	 FALSE,			/* partial_inplace */
d192 1
a192 1
	 TRUE),		        /* pcrel_offset */
d198 1
a198 1
	 FALSE,			/* pc_relative */
d203 1
a203 1
	 FALSE,			/* partial_inplace */
d206 1
a206 1
	 FALSE),	        /* pcrel_offset */
d212 1
a212 1
	 FALSE,			/* pc_relative */
d217 1
a217 1
	 FALSE,			/* partial_inplace */
d220 1
a220 1
	 FALSE),	        /* pcrel_offset */
d226 1
a226 1
	 FALSE,			/* pc_relative */
d231 1
a231 1
	 FALSE,			/* partial_inplace */
d234 1
a234 1
	 FALSE),	        /* pcrel_offset */
d240 1
a240 1
	 FALSE,			/* pc_relative */
d245 1
a245 1
	 FALSE,			/* partial_inplace */
d248 1
a248 1
	 FALSE),	        /* pcrel_offset */
d254 1
a254 1
	 FALSE,			/* pc_relative */
d259 1
a259 1
	 FALSE,			/* partial_inplace */
d262 1
a262 1
	 FALSE),	        /* pcrel_offset */
d268 1
a268 1
	 FALSE,			/* pc_relative */
d273 1
a273 1
	 FALSE,			/* partial_inplace */
d276 1
a276 1
	 FALSE),	        /* pcrel_offset */
d282 1
a282 1
	 FALSE,			/* pc_relative */
d287 1
a287 1
	 FALSE,			/* partial_inplace */
d290 1
a290 1
	 FALSE),	        /* pcrel_offset */
d296 1
a296 1
	 FALSE,			/* pc_relative */
d301 1
a301 1
	 FALSE,			/* partial_inplace */
d304 1
a304 1
	 TRUE),		        /* pcrel_offset */
d310 1
a310 1
	 FALSE,			/* pc_relative */
d315 1
a315 1
	 FALSE,			/* partial_inplace */
d318 1
a318 1
	 TRUE),		        /* pcrel_offset */
d324 1
a324 1
	 FALSE,			/* pc_relative */
d329 1
a329 1
	 FALSE,			/* partial_inplace */
d332 1
a332 1
	 TRUE),		        /* pcrel_offset */
d338 1
a338 1
	 FALSE,			/* pc_relative */
d343 1
a343 1
	 FALSE,			/* partial_inplace */
d346 1
a346 1
	 TRUE),		        /* pcrel_offset */
d352 1
a352 1
	 FALSE,			/* pc_relative */
d357 1
a357 1
	 TRUE,			/* partial_inplace */
d360 1
a360 1
	 FALSE),	        /* pcrel_offset */
d366 1
a366 1
	 FALSE,			/* pc_relative */
d371 1
a371 1
	 TRUE,			/* partial_inplace */
d374 1
a374 1
	 FALSE),	        /* pcrel_offset */
d380 1
a380 1
	 FALSE,			/* pc_relative */
d385 1
a385 1
	 TRUE,			/* partial_inplace */
d388 1
a388 1
	 FALSE),	        /* pcrel_offset */
d394 1
a394 1
	 FALSE,			/* pc_relative */
d399 1
a399 1
	 TRUE,			/* partial_inplace */
d402 1
a402 1
	 FALSE),	        /* pcrel_offset */
d408 1
a408 1
	 FALSE,			/* pc_relative */
d413 1
a413 1
	 TRUE,			/* partial_inplace */
d416 1
a416 1
	 FALSE),	        /* pcrel_offset */
d422 1
a422 1
	 FALSE,			/* pc_relative */
d427 1
a427 1
	 TRUE,			/* partial_inplace */
d430 1
a430 1
	 FALSE),	        /* pcrel_offset */
d436 1
a436 1
	 TRUE,			/* pc_relative */
d441 1
a441 1
	 FALSE,			/* partial_inplace */
d444 1
a444 1
	 TRUE),		        /* pcrel_offset */
d450 1
a450 1
	 FALSE,			/* pc_relative */
d455 1
a455 1
	 FALSE,			/* partial_inplace */
d458 1
a458 1
	 FALSE),	        /* pcrel_offset */
d464 1
a464 1
	 FALSE,			/* pc_relative */
d469 1
a469 1
	 FALSE,			/* partial_inplace */
d472 1
a472 1
	 TRUE),		        /* pcrel_offset */
d478 1
a478 1
	 FALSE,			/* pc_relative */
d483 1
a483 1
	 TRUE,			/* partial_inplace */
d486 1
a486 1
	 FALSE),	        /* pcrel_offset */
d492 1
a492 1
	 TRUE,			/* pc_relative */
d497 1
a497 1
	 FALSE,			/* partial_inplace */
d500 1
a500 1
	 TRUE),		        /* pcrel_offset */
d506 1
a506 1
	 FALSE,			/* pc_relative */
d511 1
a511 1
	 FALSE,			/* partial_inplace */
d514 1
a514 1
	 FALSE),	        /* pcrel_offset */
d520 1
a520 1
	 FALSE,			/* pc_relative */
d525 1
a525 1
	 FALSE,			/* partial_inplace */
d528 1
a528 1
	 TRUE),		        /* pcrel_offset */
d534 1
a534 1
	 FALSE,			/* pc_relative */
d539 1
a539 1
	 TRUE,			/* partial_inplace */
d542 1
a542 1
	 FALSE),	        /* pcrel_offset */
d696 1
a696 1
     Elf_Internal_Rela *elf_reloc;
d698 1
a698 2
  bfd_reloc->howto
    = lookup_howto ((unsigned) ELF32_R_TYPE (elf_reloc->r_info));
d712 1
a712 1
  howto = lookup_howto ((unsigned) ELF32_R_TYPE (rello->r_info));
d739 1
a739 1
  howto = lookup_howto ((unsigned) ELF32_R_TYPE (rello->r_info));
d771 1
a771 1
  howto = lookup_howto ((unsigned) ELF32_R_TYPE (rello->r_info));
d832 3
d863 1
a863 1
static bfd_boolean
d866 8
a873 8
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d875 4
a878 7
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;

  if (info->relocateable)
    return TRUE;
d906 25
a930 4
      howto = lookup_howto ((unsigned) ELF32_R_TYPE (rel->r_info));
      h     = NULL;
      sym   = NULL;
      sec   = NULL;
d936 3
a938 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
d970 2
a971 2
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
d1045 1
a1045 1
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
d1070 1
a1070 1
	    return FALSE;
d1074 1
a1074 1
  return TRUE;
d1082 1
a1082 1
static bfd_boolean
d1088 1
a1088 1
    return TRUE;
a1100 1
#define elf_backend_rela_normal			1
@


1.1.1.5
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1993, 1995, 1999, 2000, 2001, 2002, 2003, 2004
d29 3
a31 13
/* special_function for R_860_PC26 relocation.  */
static bfd_reloc_status_type
i860_howto_pc26_reloc (bfd *abfd ATTRIBUTE_UNUSED,
                       arelent *reloc_entry,
                       asymbol *symbol,
                       void *data ATTRIBUTE_UNUSED,
                       asection *input_section,
                       bfd *output_bfd,
                       char **error_message ATTRIBUTE_UNUSED)
{
  bfd_vma insn;
  bfd_vma relocation;
  bfd_byte *addr;
d33 2
a34 43
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* Used elf32-mips.c as an example.  */
  if (bfd_is_und_section (symbol->section)
      && output_bfd == (bfd *) NULL)
    return bfd_reloc_undefined;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  /* Adjust for PC-relative relocation.  */
  relocation -= (input_section->output_section->vma
                 + input_section->output_offset
                 + reloc_entry->address
                 + 4);

  /* Check for target out of range.  */
  if ((bfd_signed_vma)relocation > (0x3ffffff << 2)
      || (bfd_signed_vma)relocation < (-0x4000000 << 2))
    return bfd_reloc_outofrange;

  addr = (bfd_byte *) data + reloc_entry->address;
  insn = bfd_get_32 (abfd, addr);

  relocation >>= reloc_entry->howto->rightshift;
  insn = (insn & ~reloc_entry->howto->dst_mask)
         | (relocation & reloc_entry->howto->dst_mask);
d36 2
a37 1
  bfd_put_32 (abfd, (bfd_vma) insn, addr);
d39 2
a40 89
  return bfd_reloc_ok;
}

/* special_function for R_860_PC16 relocation.  */
static bfd_reloc_status_type
i860_howto_pc16_reloc (bfd *abfd,
                       arelent *reloc_entry,
                       asymbol *symbol,
                       void *data,
                       asection *input_section,
                       bfd *output_bfd,
                       char **error_message ATTRIBUTE_UNUSED)
{
  bfd_vma insn;
  bfd_vma relocation;
  bfd_byte *addr;

  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* Used elf32-mips.c as an example.  */
  if (bfd_is_und_section (symbol->section)
      && output_bfd == (bfd *) NULL)
    return bfd_reloc_undefined;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  /* Adjust for PC-relative relocation.  */
  relocation -= (input_section->output_section->vma
                 + input_section->output_offset
                 + reloc_entry->address
                 + 4);

  /* Check for target out of range.  */
  if ((bfd_signed_vma)relocation > (0x7fff << 2)
      || (bfd_signed_vma)relocation < (-0x8000 << 2))
    return bfd_reloc_outofrange;

  addr = (bfd_byte *) data + reloc_entry->address;
  insn = bfd_get_32 (abfd, addr);

  relocation >>= reloc_entry->howto->rightshift;
  relocation = (((relocation & 0xf800) << 5) | (relocation & 0x7ff))
               & reloc_entry->howto->dst_mask;
  insn = (insn & ~reloc_entry->howto->dst_mask) | relocation;

  bfd_put_32 (abfd, (bfd_vma) insn, addr);

  return bfd_reloc_ok;
}

/* special_function for R_860_HIGHADJ relocation.  */
static bfd_reloc_status_type
i860_howto_highadj_reloc (bfd *abfd,
                          arelent *reloc_entry,
                          asymbol *symbol,
                          void *data,
                          asection *input_section,
                          bfd *output_bfd,
                          char **error_message ATTRIBUTE_UNUSED)
{
  bfd_vma insn;
  bfd_vma relocation;
  bfd_byte *addr;

  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }
d42 2
a43 4
  /* Used elf32-mips.c as an example.  */
  if (bfd_is_und_section (symbol->section)
      && output_bfd == (bfd *) NULL)
    return bfd_reloc_undefined;
d45 2
a46 4
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;
d48 2
a49 4
  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;
  relocation += 0x8000;
d51 3
a53 2
  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;
d55 3
a57 2
  addr = (bfd_byte *) data + reloc_entry->address;
  insn = bfd_get_32 (abfd, addr);
d59 2
a60 60
  relocation = ((relocation >> 16) & 0xffff);

  insn = (insn & 0xffff0000) | relocation;

  bfd_put_32 (abfd, (bfd_vma) insn, addr);

  return bfd_reloc_ok;
}

/* special_function for R_860_SPLITn relocations.  */
static bfd_reloc_status_type
i860_howto_splitn_reloc (bfd *abfd,
                         arelent *reloc_entry,
                         asymbol *symbol,
                         void *data,
                         asection *input_section,
                         bfd *output_bfd,
                         char **error_message ATTRIBUTE_UNUSED)
{
  bfd_vma insn;
  bfd_vma relocation;
  bfd_byte *addr;

  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* Used elf32-mips.c as an example.  */
  if (bfd_is_und_section (symbol->section)
      && output_bfd == (bfd *) NULL)
    return bfd_reloc_undefined;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  addr = (bfd_byte *) data + reloc_entry->address;
  insn = bfd_get_32 (abfd, addr);

  relocation = (((relocation & 0xf800) << 5) | (relocation & 0x7ff))
               & reloc_entry->howto->dst_mask;
  insn = (insn & ~reloc_entry->howto->dst_mask) | relocation;

  bfd_put_32 (abfd, (bfd_vma) insn, addr);

  return bfd_reloc_ok;
}
d159 1
a159 1
	 i860_howto_pc26_reloc,	/* special_function */
d188 1
a188 1
	 i860_howto_pc16_reloc,	/* special_function */
d216 1
a216 1
	 i860_howto_splitn_reloc, /* special_function */
d244 1
a244 1
	 i860_howto_splitn_reloc, /* special_function */
d272 1
a272 1
	 i860_howto_splitn_reloc, /* special_function */
d454 1
a454 1
	 i860_howto_highadj_reloc, /* special_function */
d549 2
a550 1
lookup_howto (unsigned int rtype)
d575 3
a577 2
elf32_i860_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			      bfd_reloc_code_real_type code)
d694 4
a697 3
elf32_i860_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
			       arelent *bfd_reloc,
			       Elf_Internal_Rela *elf_reloc)
d706 5
a710 4
elf32_i860_relocate_splitn (bfd *input_bfd,
			    Elf_Internal_Rela *rello,
			    bfd_byte *contents,
			    bfd_vma value)
d721 1
a721 1
  value = (((value & 0xf800) << 5) | (value & 0x7ff)) & howto->dst_mask;
d732 6
a737 5
elf32_i860_relocate_pc16 (bfd *input_bfd,
			  asection *input_section,
			  Elf_Internal_Rela *rello,
			  bfd_byte *contents,
			  bfd_vma value)
d752 2
a753 3
  /* Adjust the value by 4, then separate the fields and insert.  */
  value = (value - 4) >> howto->rightshift;
  value = (((value & 0xf800) << 5) | (value & 0x7ff)) & howto->dst_mask;
d764 6
a769 5
elf32_i860_relocate_pc26 (bfd *input_bfd,
			  asection *input_section,
			  Elf_Internal_Rela *rello,
			  bfd_byte *contents,
			  bfd_vma value)
d795 5
a799 4
elf32_i860_relocate_highadj (bfd *input_bfd,
			     Elf_Internal_Rela *rel,
			     bfd_byte *contents,
			     bfd_vma value)
d805 1
a806 1
  value += 0x8000; 
d818 7
a824 6
i860_final_link_relocate (reloc_howto_type *howto,
			  bfd *input_bfd,
			  asection *input_section,
			  bfd_byte *contents,
			  Elf_Internal_Rela *rel,
			  bfd_vma relocation)
d843 1
a843 1
   necessary, and (if using Rela relocs and generating a relocatable
d857 1
a857 1
   When generating relocatable output, this function must handle
d863 10
a872 8
elf32_i860_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
			     struct bfd_link_info *info,
			     bfd *input_bfd,
			     asection *input_section,
			     bfd_byte *contents,
			     Elf_Internal_Rela *relocs,
			     Elf_Internal_Sym *local_syms,
			     asection **local_sections)
d879 1
a879 1
  if (info->relocatable)
d917 1
a917 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d925 1
a925 1
	  bfd_boolean unresolved_reloc, warned;
d927 26
a952 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
d1062 3
a1064 1
elf32_i860_is_local_label_name (bfd *abfd, const char *name)
@


