head	1.14;
access;
symbols
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.12
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.8
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.4
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.8
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.11.0.32
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.30
	OPENBSD_5_0:1.11.0.28
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.26
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.24
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.20
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.22
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.18
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.16
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.14
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.12
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.10
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.8
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.8.0.8
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.6
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.7.0.8
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.6
	OPENBSD_3_0_BASE:1.7
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.6.0.8
	OPENBSD_2_7_BASE:1.6
	new-binutils:1.6.0.6
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2014.08.09.22.39.08;	author guenther;	state Exp;
branches;
next	1.13;
commitid	K0yx0NOsonkBKAIA;

1.13
date	2013.04.19.23.20.53;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2013.01.01.00.02.00;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.27.10.37.55;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.02.20.45.03;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.17.21.54.20;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.13.17.07.28;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.12.19.11.05;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	99.02.09.04.01.35;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	96.11.23.03.32.42;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.10.31.00.30.50;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.18.59.24;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.43.08;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.24;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.24;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.04.49;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.36.55;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.12.01;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.17.45;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.22;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.20.13;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.10;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.13;	author miod;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Regenerate to pick up time_t changes
@
text
@/* DO NOT EDIT!  -*- buffer-read-only: t -*-  This file is automatically 
   generated from "bfd-in.h", "init.c", "opncls.c", "libbfd.c", 
   "bfdio.c", "bfdwin.c", "section.c", "archures.c", "reloc.c", 
   "syms.c", "bfd.c", "archive.c", "corefile.c", "targets.c", "format.c", 
   "linker.c" and "simple.c".
   Run "make headers" in your build bfd/ to regenerate.  */

/* Main header file for the bfd library -- portable access to object files.

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.

   Contributed by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifndef __BFD_H_SEEN__
#define __BFD_H_SEEN__

#ifdef __cplusplus
extern "C" {
#endif

#include "ansidecl.h"
#include "symcat.h"
#include <time.h>	/* time_t */
#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
#ifndef SABER
/* This hack is to avoid a problem with some strict ANSI C preprocessors.
   The problem is, "32_" is not a valid preprocessing token, and we don't
   want extra underscores (e.g., "nlm_32_").  The XCONCAT2 macro will
   cause the inner CONCAT2 macros to be evaluated first, producing
   still-valid pp-tokens.  Then the final concatenation can be done.  */
#undef CONCAT4
#define CONCAT4(a,b,c,d) XCONCAT2(CONCAT2(a,b),CONCAT2(c,d))
#endif
#endif

/* The word size used by BFD on the host.  This may be 64 with a 32
   bit target if the host is 64 bit, or if other 64 bit targets have
   been selected with --enable-targets, or if --enable-64-bit-bfd.  */
#define BFD_ARCH_SIZE @@wordsize@@

/* The word size of the default bfd target.  */
#define BFD_DEFAULT_TARGET_SIZE @@bfd_default_target_size@@

#define BFD_HOST_64BIT_LONG @@BFD_HOST_64BIT_LONG@@
#define BFD_HOST_LONG_LONG @@BFD_HOST_LONG_LONG@@
#if @@BFD_HOST_64_BIT_DEFINED@@
#define BFD_HOST_64_BIT @@BFD_HOST_64_BIT@@
#define BFD_HOST_U_64_BIT @@BFD_HOST_U_64_BIT@@
typedef BFD_HOST_64_BIT bfd_int64_t;
typedef BFD_HOST_U_64_BIT bfd_uint64_t;
#endif

#if BFD_ARCH_SIZE >= 64
#define BFD64
#endif

#ifndef INLINE
#if __GNUC__ >= 2
#define INLINE __inline__
#else
#define INLINE
#endif
#endif

/* Forward declaration.  */
typedef struct bfd bfd;

/* Boolean type used in bfd.  Too many systems define their own
   versions of "boolean" for us to safely typedef a "boolean" of
   our own.  Using an enum for "bfd_boolean" has its own set of
   problems, with strange looking casts required to avoid warnings
   on some older compilers.  Thus we just use an int.

   General rule: Functions which are bfd_boolean return TRUE on
   success and FALSE on failure (unless they're a predicate).  */

typedef int bfd_boolean;
#undef FALSE
#undef TRUE
#define FALSE 0
#define TRUE 1

#if 0
/* Poison.  */
#undef false
#undef true
#define false dont_use_false_in_bfd
#define true dont_use_true_in_bfd
#endif

#ifdef BFD64

#ifndef BFD_HOST_64_BIT
 #error No 64 bit integer type available
#endif /* ! defined (BFD_HOST_64_BIT) */

typedef BFD_HOST_U_64_BIT bfd_vma;
typedef BFD_HOST_64_BIT bfd_signed_vma;
typedef BFD_HOST_U_64_BIT bfd_size_type;
typedef BFD_HOST_U_64_BIT symvalue;

#ifndef fprintf_vma
#if BFD_HOST_64BIT_LONG
#define sprintf_vma(s,x) sprintf (s, "%016lx", x)
#define fprintf_vma(f,x) fprintf (f, "%016lx", x)
#else
#define _bfd_int64_low(x) ((unsigned long) (((x) & 0xffffffff)))
#define _bfd_int64_high(x) ((unsigned long) (((x) >> 32) & 0xffffffff))
#define fprintf_vma(s,x) \
  fprintf ((s), "%08lx%08lx", _bfd_int64_high (x), _bfd_int64_low (x))
#define sprintf_vma(s,x) \
  sprintf ((s), "%08lx%08lx", _bfd_int64_high (x), _bfd_int64_low (x))
#endif
#endif

#else /* not BFD64  */

/* Represent a target address.  Also used as a generic unsigned type
   which is guaranteed to be big enough to hold any arithmetic types
   we need to deal with.  */
typedef unsigned long bfd_vma;

/* A generic signed type which is guaranteed to be big enough to hold any
   arithmetic types we need to deal with.  Can be assumed to be compatible
   with bfd_vma in the same way that signed and unsigned ints are compatible
   (as parameters, in assignment, etc).  */
typedef long bfd_signed_vma;

typedef unsigned long symvalue;
typedef unsigned long bfd_size_type;

/* Print a bfd_vma x on stream s.  */
#define fprintf_vma(s,x) fprintf (s, "%08lx", x)
#define sprintf_vma(s,x) sprintf (s, "%08lx", x)

#endif /* not BFD64  */

#ifndef BFD_HOST_64_BIT
/* Fall back on a 32 bit type.  The idea is to make these types always
   available for function return types, but in the case that
   BFD_HOST_64_BIT is undefined such a function should abort or
   otherwise signal an error.  */
typedef bfd_signed_vma bfd_int64_t;
typedef bfd_vma bfd_uint64_t;
#endif

/* An offset into a file.  BFD always uses the largest possible offset
   based on the build time availability of fseek, fseeko, or fseeko64.  */
typedef @@bfd_file_ptr@@ file_ptr;
typedef unsigned @@bfd_file_ptr@@ ufile_ptr;

extern void bfd_sprintf_vma (bfd *, char *, bfd_vma);
extern void bfd_fprintf_vma (bfd *, void *, bfd_vma);

#define printf_vma(x) fprintf_vma(stdout,x)
#define bfd_printf_vma(abfd,x) bfd_fprintf_vma (abfd,stdout,x)

typedef unsigned int flagword;	/* 32 bits of flags */
typedef unsigned char bfd_byte;

/* File formats.  */

typedef enum bfd_format
{
  bfd_unknown = 0,	/* File format is unknown.  */
  bfd_object,		/* Linker/assembler/compiler output.  */
  bfd_archive,		/* Object archive file.  */
  bfd_core,		/* Core dump.  */
  bfd_type_end		/* Marks the end; don't use it!  */
}
bfd_format;

/* Values that may appear in the flags field of a BFD.  These also
   appear in the object_flags field of the bfd_target structure, where
   they indicate the set of flags used by that backend (not all flags
   are meaningful for all object file formats) (FIXME: at the moment,
   the object_flags values have mostly just been copied from backend
   to another, and are not necessarily correct).  */

/* No flags.  */
#define BFD_NO_FLAGS   	0x00

/* BFD contains relocation entries.  */
#define HAS_RELOC   	0x01

/* BFD is directly executable.  */
#define EXEC_P      	0x02

/* BFD has line number information (basically used for F_LNNO in a
   COFF header).  */
#define HAS_LINENO  	0x04

/* BFD has debugging information.  */
#define HAS_DEBUG   	0x08

/* BFD has symbols.  */
#define HAS_SYMS    	0x10

/* BFD has local symbols (basically used for F_LSYMS in a COFF
   header).  */
#define HAS_LOCALS  	0x20

/* BFD is a dynamic object.  */
#define DYNAMIC     	0x40

/* Text section is write protected (if D_PAGED is not set, this is
   like an a.out NMAGIC file) (the linker sets this by default, but
   clears it for -r or -N).  */
#define WP_TEXT     	0x80

/* BFD is dynamically paged (this is like an a.out ZMAGIC file) (the
   linker sets this by default, but clears it for -r or -n or -N).  */
#define D_PAGED     	0x100

/* BFD is relaxable (this means that bfd_relax_section may be able to
   do something) (sometimes bfd_relax_section can do something even if
   this is not set).  */
#define BFD_IS_RELAXABLE 0x200

/* This may be set before writing out a BFD to request using a
   traditional format.  For example, this is used to request that when
   writing out an a.out object the symbols not be hashed to eliminate
   duplicates.  */
#define BFD_TRADITIONAL_FORMAT 0x400

/* This flag indicates that the BFD contents are actually cached in
   memory.  If this is set, iostream points to a bfd_in_memory struct.  */
#define BFD_IN_MEMORY 0x800

/* The sections in this BFD specify a memory page.  */
#define HAS_LOAD_PAGE 0x1000

/* Symbols and relocation.  */

/* A count of carsyms (canonical archive symbols).  */
typedef unsigned long symindex;

/* How to perform a relocation.  */
typedef const struct reloc_howto_struct reloc_howto_type;

#define BFD_NO_MORE_SYMBOLS ((symindex) ~0)

/* General purpose part of a symbol X;
   target specific parts are in libcoff.h, libaout.h, etc.  */

#define bfd_get_section(x) ((x)->section)
#define bfd_get_output_section(x) ((x)->section->output_section)
#define bfd_set_section(x,y) ((x)->section) = (y)
#define bfd_asymbol_base(x) ((x)->section->vma)
#define bfd_asymbol_value(x) (bfd_asymbol_base(x) + (x)->value)
#define bfd_asymbol_name(x) ((x)->name)
/*Perhaps future: #define bfd_asymbol_bfd(x) ((x)->section->owner)*/
#define bfd_asymbol_bfd(x) ((x)->the_bfd)
#define bfd_asymbol_flavour(x) (bfd_asymbol_bfd(x)->xvec->flavour)

/* A canonical archive symbol.  */
/* This is a type pun with struct ranlib on purpose!  */
typedef struct carsym
{
  char *name;
  file_ptr file_offset;	/* Look here to find the file.  */
}
carsym;			/* To make these you call a carsymogen.  */

/* Used in generating armaps (archive tables of contents).
   Perhaps just a forward definition would do?  */
struct orl 			/* Output ranlib.  */
{
  char **name;		/* Symbol name.  */
  union
  {
    file_ptr pos;
    bfd *abfd;
  } u;			/* bfd* or file position.  */
  int namidx;		/* Index into string table.  */
};

/* Linenumber stuff.  */
typedef struct lineno_cache_entry
{
  unsigned int line_number;	/* Linenumber from start of function.  */
  union
  {
    struct bfd_symbol *sym;	/* Function name.  */
    bfd_vma offset;	    		/* Offset into section.  */
  } u;
}
alent;

/* Object and core file sections.  */

#define	align_power(addr, align)	\
  (((addr) + ((bfd_vma) 1 << (align)) - 1) & ((bfd_vma) -1 << (align)))

typedef struct bfd_section *sec_ptr;

#define bfd_get_section_name(bfd, ptr) ((ptr)->name + 0)
#define bfd_get_section_vma(bfd, ptr) ((ptr)->vma + 0)
#define bfd_get_section_lma(bfd, ptr) ((ptr)->lma + 0)
#define bfd_get_section_alignment(bfd, ptr) ((ptr)->alignment_power + 0)
#define bfd_section_name(bfd, ptr) ((ptr)->name)
#define bfd_section_size(bfd, ptr) ((ptr)->_raw_size)
#define bfd_get_section_size(ptr) ((ptr)->_raw_size)
#define bfd_section_vma(bfd, ptr) ((ptr)->vma)
#define bfd_section_lma(bfd, ptr) ((ptr)->lma)
#define bfd_section_alignment(bfd, ptr) ((ptr)->alignment_power)
#define bfd_get_section_flags(bfd, ptr) ((ptr)->flags + 0)
#define bfd_get_section_userdata(bfd, ptr) ((ptr)->userdata)

#define bfd_is_com_section(ptr) (((ptr)->flags & SEC_IS_COMMON) != 0)

#define bfd_set_section_vma(bfd, ptr, val) (((ptr)->vma = (ptr)->lma = (val)), ((ptr)->user_set_vma = TRUE), TRUE)
#define bfd_set_section_alignment(bfd, ptr, val) (((ptr)->alignment_power = (val)),TRUE)
#define bfd_set_section_userdata(bfd, ptr, val) (((ptr)->userdata = (val)),TRUE)

typedef struct stat stat_type;

typedef enum bfd_print_symbol
{
  bfd_print_symbol_name,
  bfd_print_symbol_more,
  bfd_print_symbol_all
} bfd_print_symbol_type;

/* Information about a symbol that nm needs.  */

typedef struct _symbol_info
{
  symvalue value;
  char type;
  const char *name;            /* Symbol name.  */
  unsigned char stab_type;     /* Stab type.  */
  char stab_other;             /* Stab other.  */
  short stab_desc;             /* Stab desc.  */
  const char *stab_name;       /* String for stab type.  */
} symbol_info;

/* Get the name of a stabs type code.  */

extern const char *bfd_get_stab_name (int);

/* Hash table routines.  There is no way to free up a hash table.  */

/* An element in the hash table.  Most uses will actually use a larger
   structure, and an instance of this will be the first field.  */

struct bfd_hash_entry
{
  /* Next entry for this hash code.  */
  struct bfd_hash_entry *next;
  /* String being hashed.  */
  const char *string;
  /* Hash code.  This is the full hash code, not the index into the
     table.  */
  unsigned long hash;
};

/* A hash table.  */

struct bfd_hash_table
{
  /* The hash array.  */
  struct bfd_hash_entry **table;
  /* The number of slots in the hash table.  */
  unsigned int size;
  /* A function used to create new elements in the hash table.  The
     first entry is itself a pointer to an element.  When this
     function is first invoked, this pointer will be NULL.  However,
     having the pointer permits a hierarchy of method functions to be
     built each of which calls the function in the superclass.  Thus
     each function should be written to allocate a new block of memory
     only if the argument is NULL.  */
  struct bfd_hash_entry *(*newfunc)
    (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
   /* An objalloc for this hash table.  This is a struct objalloc *,
     but we use void * to avoid requiring the inclusion of objalloc.h.  */
  void *memory;
};

/* Initialize a hash table.  */
extern bfd_boolean bfd_hash_table_init
  (struct bfd_hash_table *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
			       struct bfd_hash_table *,
			       const char *));

/* Initialize a hash table specifying a size.  */
extern bfd_boolean bfd_hash_table_init_n
  (struct bfd_hash_table *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
			       struct bfd_hash_table *,
			       const char *),
   unsigned int size);

/* Free up a hash table.  */
extern void bfd_hash_table_free
  (struct bfd_hash_table *);

/* Look up a string in a hash table.  If CREATE is TRUE, a new entry
   will be created for this string if one does not already exist.  The
   COPY argument must be TRUE if this routine should copy the string
   into newly allocated memory when adding an entry.  */
extern struct bfd_hash_entry *bfd_hash_lookup
  (struct bfd_hash_table *, const char *, bfd_boolean create,
   bfd_boolean copy);

/* Replace an entry in a hash table.  */
extern void bfd_hash_replace
  (struct bfd_hash_table *, struct bfd_hash_entry *old,
   struct bfd_hash_entry *nw);

/* Base method for creating a hash table entry.  */
extern struct bfd_hash_entry *bfd_hash_newfunc
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);

/* Grab some space for a hash table entry.  */
extern void *bfd_hash_allocate
  (struct bfd_hash_table *, unsigned int);

/* Traverse a hash table in a random order, calling a function on each
   element.  If the function returns FALSE, the traversal stops.  The
   INFO argument is passed to the function.  */
extern void bfd_hash_traverse
  (struct bfd_hash_table *,
   bfd_boolean (*) (struct bfd_hash_entry *, void *),
   void *info);

#define COFF_SWAP_TABLE (void *) &bfd_coff_std_swap_table

/* User program access to BFD facilities.  */

/* Direct I/O routines, for programs which know more about the object
   file than BFD does.  Use higher level routines if possible.  */

extern bfd_size_type bfd_bread (void *, bfd_size_type, bfd *);
extern bfd_size_type bfd_bwrite (const void *, bfd_size_type, bfd *);
extern int bfd_seek (bfd *, file_ptr, int);
extern file_ptr bfd_tell (bfd *);
extern int bfd_flush (bfd *);
extern int bfd_stat (bfd *, struct stat *);

/* Deprecated old routines.  */
#if __GNUC__
#define bfd_read(BUF, ELTSIZE, NITEMS, ABFD)				\
  (warn_deprecated ("bfd_read", __FILE__, __LINE__, __FUNCTION__),	\
   bfd_bread ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
#define bfd_write(BUF, ELTSIZE, NITEMS, ABFD)				\
  (warn_deprecated ("bfd_write", __FILE__, __LINE__, __FUNCTION__),	\
   bfd_bwrite ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
#else
#define bfd_read(BUF, ELTSIZE, NITEMS, ABFD)				\
  (warn_deprecated ("bfd_read", (const char *) 0, 0, (const char *) 0), \
   bfd_bread ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
#define bfd_write(BUF, ELTSIZE, NITEMS, ABFD)				\
  (warn_deprecated ("bfd_write", (const char *) 0, 0, (const char *) 0),\
   bfd_bwrite ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
#endif
extern void warn_deprecated (const char *, const char *, int, const char *);

/* Cast from const char * to char * so that caller can assign to
   a char * without a warning.  */
#define bfd_get_filename(abfd) ((char *) (abfd)->filename)
#define bfd_get_cacheable(abfd) ((abfd)->cacheable)
#define bfd_get_format(abfd) ((abfd)->format)
#define bfd_get_target(abfd) ((abfd)->xvec->name)
#define bfd_get_flavour(abfd) ((abfd)->xvec->flavour)
#define bfd_family_coff(abfd) \
  (bfd_get_flavour (abfd) == bfd_target_coff_flavour || \
   bfd_get_flavour (abfd) == bfd_target_xcoff_flavour)
#define bfd_big_endian(abfd) ((abfd)->xvec->byteorder == BFD_ENDIAN_BIG)
#define bfd_little_endian(abfd) ((abfd)->xvec->byteorder == BFD_ENDIAN_LITTLE)
#define bfd_header_big_endian(abfd) \
  ((abfd)->xvec->header_byteorder == BFD_ENDIAN_BIG)
#define bfd_header_little_endian(abfd) \
  ((abfd)->xvec->header_byteorder == BFD_ENDIAN_LITTLE)
#define bfd_get_file_flags(abfd) ((abfd)->flags)
#define bfd_applicable_file_flags(abfd) ((abfd)->xvec->object_flags)
#define bfd_applicable_section_flags(abfd) ((abfd)->xvec->section_flags)
#define bfd_my_archive(abfd) ((abfd)->my_archive)
#define bfd_has_map(abfd) ((abfd)->has_armap)

#define bfd_valid_reloc_types(abfd) ((abfd)->xvec->valid_reloc_types)
#define bfd_usrdata(abfd) ((abfd)->usrdata)

#define bfd_get_start_address(abfd) ((abfd)->start_address)
#define bfd_get_symcount(abfd) ((abfd)->symcount)
#define bfd_get_outsymbols(abfd) ((abfd)->outsymbols)
#define bfd_count_sections(abfd) ((abfd)->section_count)

#define bfd_get_dynamic_symcount(abfd) ((abfd)->dynsymcount)

#define bfd_get_symbol_leading_char(abfd) ((abfd)->xvec->symbol_leading_char)

#define bfd_set_cacheable(abfd,bool) (((abfd)->cacheable = bool), TRUE)

extern bfd_boolean bfd_cache_close
  (bfd *abfd);
/* NB: This declaration should match the autogenerated one in libbfd.h.  */

extern bfd_boolean bfd_cache_close_all (void);

extern bfd_boolean bfd_record_phdr
  (bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
   bfd_boolean, bfd_boolean, unsigned int, struct bfd_section **);

/* Byte swapping routines.  */

bfd_uint64_t bfd_getb64 (const void *);
bfd_uint64_t bfd_getl64 (const void *);
bfd_int64_t bfd_getb_signed_64 (const void *);
bfd_int64_t bfd_getl_signed_64 (const void *);
bfd_vma bfd_getb32 (const void *);
bfd_vma bfd_getl32 (const void *);
bfd_signed_vma bfd_getb_signed_32 (const void *);
bfd_signed_vma bfd_getl_signed_32 (const void *);
bfd_vma bfd_getb16 (const void *);
bfd_vma bfd_getl16 (const void *);
bfd_signed_vma bfd_getb_signed_16 (const void *);
bfd_signed_vma bfd_getl_signed_16 (const void *);
void bfd_putb64 (bfd_uint64_t, void *);
void bfd_putl64 (bfd_uint64_t, void *);
void bfd_putb32 (bfd_vma, void *);
void bfd_putl32 (bfd_vma, void *);
void bfd_putb16 (bfd_vma, void *);
void bfd_putl16 (bfd_vma, void *);

/* Byte swapping routines which take size and endiannes as arguments.  */

bfd_uint64_t bfd_get_bits (const void *, int, bfd_boolean);
void bfd_put_bits (bfd_uint64_t, void *, int, bfd_boolean);

/* Externally visible ECOFF routines.  */

#if defined(__STDC__) || defined(ALMOST_STDC)
struct ecoff_debug_info;
struct ecoff_debug_swap;
struct ecoff_extr;
struct bfd_symbol;
struct bfd_link_info;
struct bfd_link_hash_entry;
struct bfd_elf_version_tree;
#endif
extern bfd_vma bfd_ecoff_get_gp_value
  (bfd * abfd);
extern bfd_boolean bfd_ecoff_set_gp_value
  (bfd *abfd, bfd_vma gp_value);
extern bfd_boolean bfd_ecoff_set_regmasks
  (bfd *abfd, unsigned long gprmask, unsigned long fprmask,
   unsigned long *cprmask);
extern void *bfd_ecoff_debug_init
  (bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
extern void bfd_ecoff_debug_free
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
extern bfd_boolean bfd_ecoff_debug_accumulate
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
   struct ecoff_debug_info *input_debug,
   const struct ecoff_debug_swap *input_swap, struct bfd_link_info *);
extern bfd_boolean bfd_ecoff_debug_accumulate_other
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
   struct bfd_link_info *);
extern bfd_boolean bfd_ecoff_debug_externals
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, bfd_boolean relocatable,
   bfd_boolean (*get_extr) (struct bfd_symbol *, struct ecoff_extr *),
   void (*set_index) (struct bfd_symbol *, bfd_size_type));
extern bfd_boolean bfd_ecoff_debug_one_external
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, const char *name,
   struct ecoff_extr *esym);
extern bfd_size_type bfd_ecoff_debug_size
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap);
extern bfd_boolean bfd_ecoff_write_debug
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, file_ptr where);
extern bfd_boolean bfd_ecoff_write_accumulated_debug
  (void *handle, bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap,
   struct bfd_link_info *info, file_ptr where);
extern bfd_boolean bfd_mips_ecoff_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);

/* Externally visible ELF routines.  */

struct bfd_link_needed_list
{
  struct bfd_link_needed_list *next;
  bfd *by;
  const char *name;
};

enum dynamic_lib_link_class {
  DYN_NORMAL = 0,
  DYN_AS_NEEDED = 1,
  DYN_DT_NEEDED = 2
};

extern bfd_boolean bfd_elf_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *, bfd_boolean);
extern struct bfd_link_needed_list *bfd_elf_get_needed_list
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_elf_get_bfd_needed_list
  (bfd *, struct bfd_link_needed_list **);
extern bfd_boolean bfd_elf_size_dynamic_sections
  (bfd *, const char *, const char *, const char *, const char * const *,
   struct bfd_link_info *, struct bfd_section **, struct bfd_elf_version_tree *);
extern void bfd_elf_set_dt_needed_name
  (bfd *, const char *);
extern const char *bfd_elf_get_dt_soname
  (bfd *);
extern void bfd_elf_set_dyn_lib_class
  (bfd *, int);
extern struct bfd_link_needed_list *bfd_elf_get_runpath_list
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_elf_discard_info
  (bfd *, struct bfd_link_info *);

/* Return an upper bound on the number of bytes required to store a
   copy of ABFD's program header table entries.  Return -1 if an error
   occurs; bfd_get_error will return an appropriate code.  */
extern long bfd_get_elf_phdr_upper_bound
  (bfd *abfd);

/* Copy ABFD's program header table entries to *PHDRS.  The entries
   will be stored as an array of Elf_Internal_Phdr structures, as
   defined in include/elf/internal.h.  To find out how large the
   buffer needs to be, call bfd_get_elf_phdr_upper_bound.

   Return the number of program header table entries read, or -1 if an
   error occurs; bfd_get_error will return an appropriate code.  */
extern int bfd_get_elf_phdrs
  (bfd *abfd, void *phdrs);

/* Create a new BFD as if by bfd_openr.  Rather than opening a file,
   reconstruct an ELF file by reading the segments out of remote memory
   based on the ELF file header at EHDR_VMA and the ELF program headers it
   points to.  If not null, *LOADBASEP is filled in with the difference
   between the VMAs from which the segments were read, and the VMAs the
   file headers (and hence BFD's idea of each section's VMA) put them at.

   The function TARGET_READ_MEMORY is called to copy LEN bytes from the
   remote memory at target address VMA into the local buffer at MYADDR; it
   should return zero on success or an `errno' code on failure.  TEMPL must
   be a BFD for an ELF target with the word size and byte order found in
   the remote memory.  */
extern bfd *bfd_elf_bfd_from_remote_memory
  (bfd *templ, bfd_vma ehdr_vma, bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma vma, char *myaddr, int len));

/* Return the arch_size field of an elf bfd, or -1 if not elf.  */
extern int bfd_get_arch_size
  (bfd *);

/* Return TRUE if address "naturally" sign extends, or -1 if not elf.  */
extern int bfd_get_sign_extend_vma
  (bfd *);

extern struct bfd_section *_bfd_elf_tls_setup
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_m68k_elf32_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);
extern bfd_boolean bfd_mips_elf32_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);

/* SunOS shared library support routines for the linker.  */

extern struct bfd_link_needed_list *bfd_sunos_get_needed_list
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_sunos_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_sunos_size_dynamic_sections
  (bfd *, struct bfd_link_info *, struct bfd_section **, struct bfd_section **, struct bfd_section **);

/* Linux shared library support routines for the linker.  */

extern bfd_boolean bfd_i386linux_size_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_m68klinux_size_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_sparclinux_size_dynamic_sections
  (bfd *, struct bfd_link_info *);

/* mmap hacks */

struct _bfd_window_internal;
typedef struct _bfd_window_internal bfd_window_internal;

typedef struct _bfd_window
{
  /* What the user asked for.  */
  void *data;
  bfd_size_type size;
  /* The actual window used by BFD.  Small user-requested read-only
     regions sharing a page may share a single window into the object
     file.  Read-write versions shouldn't until I've fixed things to
     keep track of which portions have been claimed by the
     application; don't want to give the same region back when the
     application wants two writable copies!  */
  struct _bfd_window_internal *i;
}
bfd_window;

extern void bfd_init_window
  (bfd_window *);
extern void bfd_free_window
  (bfd_window *);
extern bfd_boolean bfd_get_file_window
  (bfd *, file_ptr, bfd_size_type, bfd_window *, bfd_boolean);

/* XCOFF support routines for the linker.  */

extern bfd_boolean bfd_xcoff_link_record_set
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_size_type);
extern bfd_boolean bfd_xcoff_import_symbol
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_vma,
   const char *, const char *, const char *, unsigned int);
extern bfd_boolean bfd_xcoff_export_symbol
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *);
extern bfd_boolean bfd_xcoff_link_count_reloc
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_xcoff_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_xcoff_size_dynamic_sections
  (bfd *, struct bfd_link_info *, const char *, const char *,
   unsigned long, unsigned long, unsigned long, bfd_boolean,
   int, bfd_boolean, bfd_boolean, struct bfd_section **, bfd_boolean);
extern bfd_boolean bfd_xcoff_link_generate_rtinit
  (bfd *, const char *, const char *, bfd_boolean);

/* XCOFF support routines for ar.  */
extern bfd_boolean bfd_xcoff_ar_archive_set_magic
  (bfd *, char *);

/* Externally visible COFF routines.  */

#if defined(__STDC__) || defined(ALMOST_STDC)
struct internal_syment;
union internal_auxent;
#endif

extern bfd_boolean bfd_coff_get_syment
  (bfd *, struct bfd_symbol *, struct internal_syment *);

extern bfd_boolean bfd_coff_get_auxent
  (bfd *, struct bfd_symbol *, int, union internal_auxent *);

extern bfd_boolean bfd_coff_set_symbol_class
  (bfd *, struct bfd_symbol *, unsigned int);

extern bfd_boolean bfd_m68k_coff_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);

/* ARM Interworking support.  Called from linker.  */
extern bfd_boolean bfd_arm_allocate_interworking_sections
  (struct bfd_link_info *);

extern bfd_boolean bfd_arm_process_before_allocation
  (bfd *, struct bfd_link_info *, int);

extern bfd_boolean bfd_arm_get_bfd_for_interworking
  (bfd *, struct bfd_link_info *);

/* PE ARM Interworking support.  Called from linker.  */
extern bfd_boolean bfd_arm_pe_allocate_interworking_sections
  (struct bfd_link_info *);

extern bfd_boolean bfd_arm_pe_process_before_allocation
  (bfd *, struct bfd_link_info *, int);

extern bfd_boolean bfd_arm_pe_get_bfd_for_interworking
  (bfd *, struct bfd_link_info *);

/* ELF ARM Interworking support.  Called from linker.  */
extern bfd_boolean bfd_elf32_arm_allocate_interworking_sections
  (struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_process_before_allocation
  (bfd *, struct bfd_link_info *, int);

extern bfd_boolean bfd_elf32_arm_get_bfd_for_interworking
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_add_glue_sections_to_bfd
  (bfd *, struct bfd_link_info *);

/* ARM Note section processing.  */
extern bfd_boolean bfd_arm_merge_machines
  (bfd *, bfd *);

extern bfd_boolean bfd_arm_update_notes
  (bfd *, const char *);

extern unsigned int bfd_arm_get_mach_from_notes
  (bfd *, const char *);

/* TI COFF load page support.  */
extern void bfd_ticoff_set_section_load_page
  (struct bfd_section *, int);

extern int bfd_ticoff_get_section_load_page
  (struct bfd_section *);

/* H8/300 functions.  */
extern bfd_vma bfd_h8300_pad_address
  (bfd *, bfd_vma);

/* IA64 Itanium code generation.  Called from linker.  */
extern void bfd_elf32_ia64_after_parse
  (int);

extern void bfd_elf64_ia64_after_parse
  (int);

/* Extracted from init.c.  */
void bfd_init (void);

/* Extracted from opncls.c.  */
bfd *bfd_openr (const char *filename, const char *target);

bfd *bfd_fdopenr (const char *filename, const char *target, int fd);

bfd *bfd_openstreamr (const char *, const char *, void *);

bfd *bfd_openw (const char *filename, const char *target);

bfd_boolean bfd_close (bfd *abfd);

bfd_boolean bfd_close_all_done (bfd *);

bfd *bfd_create (const char *filename, bfd *templ);

bfd_boolean bfd_make_writable (bfd *abfd);

bfd_boolean bfd_make_readable (bfd *abfd);

unsigned long bfd_calc_gnu_debuglink_crc32
   (unsigned long crc, const unsigned char *buf, bfd_size_type len);

char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);

struct bfd_section *bfd_create_gnu_debuglink_section
   (bfd *abfd, const char *filename);

bfd_boolean bfd_fill_in_gnu_debuglink_section
   (bfd *abfd, struct bfd_section *sect, const char *filename);

/* Extracted from libbfd.c.  */

/* Byte swapping macros for user section data.  */

#define bfd_put_8(abfd, val, ptr) \
  ((void) (*((unsigned char *) (ptr)) = (val) & 0xff))
#define bfd_put_signed_8 \
  bfd_put_8
#define bfd_get_8(abfd, ptr) \
  (*(unsigned char *) (ptr) & 0xff)
#define bfd_get_signed_8(abfd, ptr) \
  (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)

#define bfd_put_16(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx16, ((val),(ptr)))
#define bfd_put_signed_16 \
  bfd_put_16
#define bfd_get_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx16, (ptr))
#define bfd_get_signed_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_16, (ptr))

#define bfd_put_32(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx32, ((val),(ptr)))
#define bfd_put_signed_32 \
  bfd_put_32
#define bfd_get_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx32, (ptr))
#define bfd_get_signed_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_32, (ptr))

#define bfd_put_64(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx64, ((val), (ptr)))
#define bfd_put_signed_64 \
  bfd_put_64
#define bfd_get_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx64, (ptr))
#define bfd_get_signed_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_64, (ptr))

#define bfd_get(bits, abfd, ptr)                       \
  ((bits) == 8 ? (bfd_vma) bfd_get_8 (abfd, ptr)       \
   : (bits) == 16 ? bfd_get_16 (abfd, ptr)             \
   : (bits) == 32 ? bfd_get_32 (abfd, ptr)             \
   : (bits) == 64 ? bfd_get_64 (abfd, ptr)             \
   : (abort (), (bfd_vma) - 1))

#define bfd_put(bits, abfd, val, ptr)                  \
  ((bits) == 8 ? bfd_put_8  (abfd, val, ptr)           \
   : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)                \
   : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)                \
   : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)                \
   : (abort (), (void) 0))


/* Byte swapping macros for file header data.  */

#define bfd_h_put_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_put_signed_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_get_8(abfd, ptr) \
  bfd_get_8 (abfd, ptr)
#define bfd_h_get_signed_8(abfd, ptr) \
  bfd_get_signed_8 (abfd, ptr)

#define bfd_h_put_16(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx16, (val, ptr))
#define bfd_h_put_signed_16 \
  bfd_h_put_16
#define bfd_h_get_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx16, (ptr))
#define bfd_h_get_signed_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr))

#define bfd_h_put_32(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx32, (val, ptr))
#define bfd_h_put_signed_32 \
  bfd_h_put_32
#define bfd_h_get_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx32, (ptr))
#define bfd_h_get_signed_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr))

#define bfd_h_put_64(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx64, (val, ptr))
#define bfd_h_put_signed_64 \
  bfd_h_put_64
#define bfd_h_get_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx64, (ptr))
#define bfd_h_get_signed_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr))

/* Aliases for the above, which should eventually go away.  */

#define H_PUT_64  bfd_h_put_64
#define H_PUT_32  bfd_h_put_32
#define H_PUT_16  bfd_h_put_16
#define H_PUT_8   bfd_h_put_8
#define H_PUT_S64 bfd_h_put_signed_64
#define H_PUT_S32 bfd_h_put_signed_32
#define H_PUT_S16 bfd_h_put_signed_16
#define H_PUT_S8  bfd_h_put_signed_8
#define H_GET_64  bfd_h_get_64
#define H_GET_32  bfd_h_get_32
#define H_GET_16  bfd_h_get_16
#define H_GET_8   bfd_h_get_8
#define H_GET_S64 bfd_h_get_signed_64
#define H_GET_S32 bfd_h_get_signed_32
#define H_GET_S16 bfd_h_get_signed_16
#define H_GET_S8  bfd_h_get_signed_8


/* Extracted from bfdio.c.  */
time_t bfd_get_mtime (bfd *abfd);

long bfd_get_size (bfd *abfd);

/* Extracted from bfdwin.c.  */
/* Extracted from section.c.  */
/* This structure is used for a comdat section, as in PE.  A comdat
   section is associated with a particular symbol.  When the linker
   sees a comdat section, it keeps only one of the sections with a
   given name and associated with a given symbol.  */

struct bfd_comdat_info
{
  /* The name of the symbol associated with a comdat section.  */
  const char *name;

  /* The local symbol table index of the symbol associated with a
     comdat section.  This is only meaningful to the object file format
     specific code; it is not an index into the list returned by
     bfd_canonicalize_symtab.  */
  long symbol;
};

typedef struct bfd_section
{
  /* The name of the section; the name isn't a copy, the pointer is
     the same as that passed to bfd_make_section.  */
  const char *name;

  /* A unique sequence number.  */
  int id;

  /* Which section in the bfd; 0..n-1 as sections are created in a bfd.  */
  int index;

  /* The next section in the list belonging to the BFD, or NULL.  */
  struct bfd_section *next;

  /* The field flags contains attributes of the section. Some
     flags are read in from the object file, and some are
     synthesized from other information.  */
  flagword flags;

#define SEC_NO_FLAGS   0x000

  /* Tells the OS to allocate space for this section when loading.
     This is clear for a section containing debug information only.  */
#define SEC_ALLOC      0x001

  /* Tells the OS to load the section from the file when loading.
     This is clear for a .bss section.  */
#define SEC_LOAD       0x002

  /* The section contains data still to be relocated, so there is
     some relocation information too.  */
#define SEC_RELOC      0x004

  /* ELF reserves 4 processor specific bits and 8 operating system
     specific bits in sh_flags; at present we can get away with just
     one in communicating between the assembler and BFD, but this
     isn't a good long-term solution.  */
#define SEC_ARCH_BIT_0 0x008

  /* A signal to the OS that the section contains read only data.  */
#define SEC_READONLY   0x010

  /* The section contains code only.  */
#define SEC_CODE       0x020

  /* The section contains data only.  */
#define SEC_DATA       0x040

  /* The section will reside in ROM.  */
#define SEC_ROM        0x080

  /* The section contains constructor information. This section
     type is used by the linker to create lists of constructors and
     destructors used by <<g++>>. When a back end sees a symbol
     which should be used in a constructor list, it creates a new
     section for the type of name (e.g., <<__CTOR_LIST__>>), attaches
     the symbol to it, and builds a relocation. To build the lists
     of constructors, all the linker has to do is catenate all the
     sections called <<__CTOR_LIST__>> and relocate the data
     contained within - exactly the operations it would peform on
     standard data.  */
#define SEC_CONSTRUCTOR 0x100

  /* The section has contents - a data section could be
     <<SEC_ALLOC>> | <<SEC_HAS_CONTENTS>>; a debug section could be
     <<SEC_HAS_CONTENTS>>  */
#define SEC_HAS_CONTENTS 0x200

  /* An instruction to the linker to not output the section
     even if it has information which would normally be written.  */
#define SEC_NEVER_LOAD 0x400

  /* The section is a COFF shared library section.  This flag is
     only for the linker.  If this type of section appears in
     the input file, the linker must copy it to the output file
     without changing the vma or size.  FIXME: Although this
     was originally intended to be general, it really is COFF
     specific (and the flag was renamed to indicate this).  It
     might be cleaner to have some more general mechanism to
     allow the back end to control what the linker does with
     sections.  */
#define SEC_COFF_SHARED_LIBRARY 0x800

  /* The section contains thread local data.  */
#define SEC_THREAD_LOCAL 0x1000

  /* The section has GOT references.  This flag is only for the
     linker, and is currently only used by the elf32-hppa back end.
     It will be set if global offset table references were detected
     in this section, which indicate to the linker that the section
     contains PIC code, and must be handled specially when doing a
     static link.  */
#define SEC_HAS_GOT_REF 0x4000

  /* The section contains common symbols (symbols may be defined
     multiple times, the value of a symbol is the amount of
     space it requires, and the largest symbol value is the one
     used).  Most targets have exactly one of these (which we
     translate to bfd_com_section_ptr), but ECOFF has two.  */
#define SEC_IS_COMMON 0x8000

  /* The section contains only debugging information.  For
     example, this is set for ELF .debug and .stab sections.
     strip tests this flag to see if a section can be
     discarded.  */
#define SEC_DEBUGGING 0x10000

  /* The contents of this section are held in memory pointed to
     by the contents field.  This is checked by bfd_get_section_contents,
     and the data is retrieved from memory if appropriate.  */
#define SEC_IN_MEMORY 0x20000

  /* The contents of this section are to be excluded by the
     linker for executable and shared objects unless those
     objects are to be further relocated.  */
#define SEC_EXCLUDE 0x40000

  /* The contents of this section are to be sorted based on the sum of
     the symbol and addend values specified by the associated relocation
     entries.  Entries without associated relocation entries will be
     appended to the end of the section in an unspecified order.  */
#define SEC_SORT_ENTRIES 0x80000

  /* When linking, duplicate sections of the same name should be
     discarded, rather than being combined into a single section as
     is usually done.  This is similar to how common symbols are
     handled.  See SEC_LINK_DUPLICATES below.  */
#define SEC_LINK_ONCE 0x100000

  /* If SEC_LINK_ONCE is set, this bitfield describes how the linker
     should handle duplicate sections.  */
#define SEC_LINK_DUPLICATES 0x600000

  /* This value for SEC_LINK_DUPLICATES means that duplicate
     sections with the same name should simply be discarded.  */
#define SEC_LINK_DUPLICATES_DISCARD 0x0

  /* This value for SEC_LINK_DUPLICATES means that the linker
     should warn if there are any duplicate sections, although
     it should still only link one copy.  */
#define SEC_LINK_DUPLICATES_ONE_ONLY 0x200000

  /* This value for SEC_LINK_DUPLICATES means that the linker
     should warn if any duplicate sections are a different size.  */
#define SEC_LINK_DUPLICATES_SAME_SIZE 0x400000

  /* This value for SEC_LINK_DUPLICATES means that the linker
     should warn if any duplicate sections contain different
     contents.  */
#define SEC_LINK_DUPLICATES_SAME_CONTENTS 0x600000

  /* This section was created by the linker as part of dynamic
     relocation or other arcane processing.  It is skipped when
     going through the first-pass output, trusting that someone
     else up the line will take care of it later.  */
#define SEC_LINKER_CREATED 0x800000

  /* This section should not be subject to garbage collection.  */
#define SEC_KEEP 0x1000000

  /* This section contains "short" data, and should be placed
     "near" the GP.  */
#define SEC_SMALL_DATA 0x2000000

  /* This section contains data which may be shared with other
     executables or shared objects.  */
#define SEC_SHARED 0x4000000

  /* When a section with this flag is being linked, then if the size of
     the input section is less than a page, it should not cross a page
     boundary.  If the size of the input section is one page or more, it
     should be aligned on a page boundary.  */
#define SEC_BLOCK 0x8000000

  /* Conditionally link this section; do not link if there are no
     references found to any symbol in the section.  */
#define SEC_CLINK 0x10000000

  /* Attempt to merge identical entities in the section.
     Entity size is given in the entsize field.  */
#define SEC_MERGE 0x20000000

  /* If given with SEC_MERGE, entities to merge are zero terminated
     strings where entsize specifies character size instead of fixed
     size entries.  */
#define SEC_STRINGS 0x40000000

  /* This section contains data about section groups.  */
#define SEC_GROUP 0x80000000

  /*  End of section flags.  */

  /* Some internal packed boolean fields.  */

  /* See the vma field.  */
  unsigned int user_set_vma : 1;

  /* Whether relocations have been processed.  */
  unsigned int reloc_done : 1;

  /* A mark flag used by some of the linker backends.  */
  unsigned int linker_mark : 1;

  /* Another mark flag used by some of the linker backends.  Set for
     output sections that have an input section.  */
  unsigned int linker_has_input : 1;

  /* A mark flag used by some linker backends for garbage collection.  */
  unsigned int gc_mark : 1;

  /* The following flags are used by the ELF linker. */

  /* Mark sections which have been allocated to segments.  */
  unsigned int segment_mark : 1;

  /* Type of sec_info information.  */
  unsigned int sec_info_type:3;
#define ELF_INFO_TYPE_NONE      0
#define ELF_INFO_TYPE_STABS     1
#define ELF_INFO_TYPE_MERGE     2
#define ELF_INFO_TYPE_EH_FRAME  3
#define ELF_INFO_TYPE_JUST_SYMS 4

  /* Nonzero if this section uses RELA relocations, rather than REL.  */
  unsigned int use_rela_p:1;

  /* Bits used by various backends.  */
  unsigned int has_tls_reloc:1;

  /* Nonzero if this section needs the relax finalize pass.  */
  unsigned int need_finalize_relax:1;

  /* Nonzero if this section has a gp reloc.  */
  unsigned int has_gp_reloc:1;

  /* Unused bits.  */
  unsigned int flag13:1;
  unsigned int flag14:1;
  unsigned int flag15:1;
  unsigned int flag16:4;
  unsigned int flag20:4;
  unsigned int flag24:8;

  /* End of internal packed boolean fields.  */

  /*  The virtual memory address of the section - where it will be
      at run time.  The symbols are relocated against this.  The
      user_set_vma flag is maintained by bfd; if it's not set, the
      backend can assign addresses (for example, in <<a.out>>, where
      the default address for <<.data>> is dependent on the specific
      target and various flags).  */
  bfd_vma vma;

  /*  The load address of the section - where it would be in a
      rom image; really only used for writing section header
      information.  */
  bfd_vma lma;

  /* The size of the section in octets, as it will be output.
     Contains a value even if the section has no contents (e.g., the
     size of <<.bss>>).  This will be filled in after relocation.  */
  bfd_size_type _cooked_size;

  /* The original size on disk of the section, in octets.  Normally this
     value is the same as the size, but if some relaxing has
     been done, then this value will be bigger.  */
  bfd_size_type _raw_size;

  /* If this section is going to be output, then this value is the
     offset in *bytes* into the output section of the first byte in the
     input section (byte ==> smallest addressable unit on the
     target).  In most cases, if this was going to start at the
     100th octet (8-bit quantity) in the output section, this value
     would be 100.  However, if the target byte size is 16 bits
     (bfd_octets_per_byte is "2"), this value would be 50.  */
  bfd_vma output_offset;

  /* The output section through which to map on output.  */
  struct bfd_section *output_section;

  /* The alignment requirement of the section, as an exponent of 2 -
     e.g., 3 aligns to 2^3 (or 8).  */
  unsigned int alignment_power;

  /* If an input section, a pointer to a vector of relocation
     records for the data in this section.  */
  struct reloc_cache_entry *relocation;

  /* If an output section, a pointer to a vector of pointers to
     relocation records for the data in this section.  */
  struct reloc_cache_entry **orelocation;

  /* The number of relocation records in one of the above.  */
  unsigned reloc_count;

  /* Information below is back end specific - and not always used
     or updated.  */

  /* File position of section data.  */
  file_ptr filepos;

  /* File position of relocation info.  */
  file_ptr rel_filepos;

  /* File position of line data.  */
  file_ptr line_filepos;

  /* Pointer to data for applications.  */
  void *userdata;

  /* If the SEC_IN_MEMORY flag is set, this points to the actual
     contents.  */
  unsigned char *contents;

  /* Attached line number information.  */
  alent *lineno;

  /* Number of line number records.  */
  unsigned int lineno_count;

  /* Entity size for merging purposes.  */
  unsigned int entsize;

  /* Optional information about a COMDAT entry; NULL if not COMDAT.  */
  struct bfd_comdat_info *comdat;

  /* Points to the kept section if this section is a link-once section,
     and is discarded.  */
  struct bfd_section *kept_section;

  /* When a section is being output, this value changes as more
     linenumbers are written out.  */
  file_ptr moving_line_filepos;

  /* What the section number is in the target world.  */
  int target_index;

  void *used_by_bfd;

  /* If this is a constructor section then here is a list of the
     relocations created to relocate items within it.  */
  struct relent_chain *constructor_chain;

  /* The BFD which owns the section.  */
  bfd *owner;

  /* A symbol which points at this section only.  */
  struct bfd_symbol *symbol;
  struct bfd_symbol **symbol_ptr_ptr;

  struct bfd_link_order *link_order_head;
  struct bfd_link_order *link_order_tail;
} asection;

/* These sections are global, and are managed by BFD.  The application
   and target back end are not permitted to change the values in
   these sections.  New code should use the section_ptr macros rather
   than referring directly to the const sections.  The const sections
   may eventually vanish.  */
#define BFD_ABS_SECTION_NAME "*ABS*"
#define BFD_UND_SECTION_NAME "*UND*"
#define BFD_COM_SECTION_NAME "*COM*"
#define BFD_IND_SECTION_NAME "*IND*"

/* The absolute section.  */
extern asection bfd_abs_section;
#define bfd_abs_section_ptr ((asection *) &bfd_abs_section)
#define bfd_is_abs_section(sec) ((sec) == bfd_abs_section_ptr)
/* Pointer to the undefined section.  */
extern asection bfd_und_section;
#define bfd_und_section_ptr ((asection *) &bfd_und_section)
#define bfd_is_und_section(sec) ((sec) == bfd_und_section_ptr)
/* Pointer to the common section.  */
extern asection bfd_com_section;
#define bfd_com_section_ptr ((asection *) &bfd_com_section)
/* Pointer to the indirect section.  */
extern asection bfd_ind_section;
#define bfd_ind_section_ptr ((asection *) &bfd_ind_section)
#define bfd_is_ind_section(sec) ((sec) == bfd_ind_section_ptr)

#define bfd_is_const_section(SEC)              \
 (   ((SEC) == bfd_abs_section_ptr)            \
  || ((SEC) == bfd_und_section_ptr)            \
  || ((SEC) == bfd_com_section_ptr)            \
  || ((SEC) == bfd_ind_section_ptr))

extern const struct bfd_symbol * const bfd_abs_symbol;
extern const struct bfd_symbol * const bfd_com_symbol;
extern const struct bfd_symbol * const bfd_und_symbol;
extern const struct bfd_symbol * const bfd_ind_symbol;
#define bfd_get_section_size_before_reloc(section) \
     ((section)->_raw_size)
#define bfd_get_section_size_after_reloc(section) \
     ((section)->reloc_done ? (section)->_cooked_size \
                            : (abort (), (bfd_size_type) 1))

/* Macros to handle insertion and deletion of a bfd's sections.  These
   only handle the list pointers, ie. do not adjust section_count,
   target_index etc.  */
#define bfd_section_list_remove(ABFD, PS) \
  do                                                   \
    {                                                  \
      asection **_ps = PS;                             \
      asection *_s = *_ps;                             \
      *_ps = _s->next;                                 \
      if (_s->next == NULL)                            \
        (ABFD)->section_tail = _ps;                    \
    }                                                  \
  while (0)
#define bfd_section_list_insert(ABFD, PS, S) \
  do                                                   \
    {                                                  \
      asection **_ps = PS;                             \
      asection *_s = S;                                \
      _s->next = *_ps;                                 \
      *_ps = _s;                                       \
      if (_s->next == NULL)                            \
        (ABFD)->section_tail = &_s->next;              \
    }                                                  \
  while (0)

void bfd_section_list_clear (bfd *);

asection *bfd_get_section_by_name (bfd *abfd, const char *name);

char *bfd_get_unique_section_name
   (bfd *abfd, const char *templat, int *count);

asection *bfd_make_section_old_way (bfd *abfd, const char *name);

asection *bfd_make_section_anyway (bfd *abfd, const char *name);

asection *bfd_make_section (bfd *, const char *name);

bfd_boolean bfd_set_section_flags
   (bfd *abfd, asection *sec, flagword flags);

void bfd_map_over_sections
   (bfd *abfd,
    void (*func) (bfd *abfd, asection *sect, void *obj),
    void *obj);

bfd_boolean bfd_set_section_size
   (bfd *abfd, asection *sec, bfd_size_type val);

bfd_boolean bfd_set_section_contents
   (bfd *abfd, asection *section, const void *data,
    file_ptr offset, bfd_size_type count);

bfd_boolean bfd_get_section_contents
   (bfd *abfd, asection *section, void *location, file_ptr offset,
    bfd_size_type count);

bfd_boolean bfd_copy_private_section_data
   (bfd *ibfd, asection *isec, bfd *obfd, asection *osec);

#define bfd_copy_private_section_data(ibfd, isection, obfd, osection) \
     BFD_SEND (obfd, _bfd_copy_private_section_data, \
               (ibfd, isection, obfd, osection))
void _bfd_strip_section_from_output
   (struct bfd_link_info *info, asection *section);

bfd_boolean bfd_generic_discard_group (bfd *abfd, asection *group);

/* Extracted from archures.c.  */
enum bfd_architecture
{
  bfd_arch_unknown,   /* File arch not known.  */
  bfd_arch_obscure,   /* Arch known, not one of these.  */
  bfd_arch_m68k,      /* Motorola 68xxx */
#define bfd_mach_m68000 1
#define bfd_mach_m68008 2
#define bfd_mach_m68010 3
#define bfd_mach_m68020 4
#define bfd_mach_m68030 5
#define bfd_mach_m68040 6
#define bfd_mach_m68060 7
#define bfd_mach_cpu32  8
#define bfd_mach_mcf5200  9
#define bfd_mach_mcf5206e 10
#define bfd_mach_mcf5307  11
#define bfd_mach_mcf5407  12
#define bfd_mach_mcf528x  13
  bfd_arch_vax,       /* DEC Vax */
  bfd_arch_i960,      /* Intel 960 */
    /* The order of the following is important.
       lower number indicates a machine type that
       only accepts a subset of the instructions
       available to machines with higher numbers.
       The exception is the "ca", which is
       incompatible with all other machines except
       "core".  */

#define bfd_mach_i960_core      1
#define bfd_mach_i960_ka_sa     2
#define bfd_mach_i960_kb_sb     3
#define bfd_mach_i960_mc        4
#define bfd_mach_i960_xa        5
#define bfd_mach_i960_ca        6
#define bfd_mach_i960_jx        7
#define bfd_mach_i960_hx        8

  bfd_arch_or32,      /* OpenRISC 32 */

  bfd_arch_a29k,      /* AMD 29000 */
  bfd_arch_sparc,     /* SPARC */
#define bfd_mach_sparc                 1
/* The difference between v8plus and v9 is that v9 is a true 64 bit env.  */
#define bfd_mach_sparc_sparclet        2
#define bfd_mach_sparc_sparclite       3
#define bfd_mach_sparc_v8plus          4
#define bfd_mach_sparc_v8plusa         5 /* with ultrasparc add'ns.  */
#define bfd_mach_sparc_sparclite_le    6
#define bfd_mach_sparc_v9              7
#define bfd_mach_sparc_v9a             8 /* with ultrasparc add'ns.  */
#define bfd_mach_sparc_v8plusb         9 /* with cheetah add'ns.  */
#define bfd_mach_sparc_v9b             10 /* with cheetah add'ns.  */
/* Nonzero if MACH has the v9 instruction set.  */
#define bfd_mach_sparc_v9_p(mach) \
  ((mach) >= bfd_mach_sparc_v8plus && (mach) <= bfd_mach_sparc_v9b \
   && (mach) != bfd_mach_sparc_sparclite_le)
  bfd_arch_mips,      /* MIPS Rxxxx */
#define bfd_mach_mips3000              3000
#define bfd_mach_mips3900              3900
#define bfd_mach_mips4000              4000
#define bfd_mach_mips4010              4010
#define bfd_mach_mips4100              4100
#define bfd_mach_mips4111              4111
#define bfd_mach_mips4120              4120
#define bfd_mach_mips4300              4300
#define bfd_mach_mips4400              4400
#define bfd_mach_mips4600              4600
#define bfd_mach_mips4650              4650
#define bfd_mach_mips5000              5000
#define bfd_mach_mips5400              5400
#define bfd_mach_mips5500              5500
#define bfd_mach_mips6000              6000
#define bfd_mach_mips7000              7000
#define bfd_mach_mips8000              8000
#define bfd_mach_mips10000             10000
#define bfd_mach_mips12000             12000
#define bfd_mach_mips16                16
#define bfd_mach_mips5                 5
#define bfd_mach_mips_sb1              12310201 /* octal 'SB', 01 */
#define bfd_mach_mipsisa32             32
#define bfd_mach_mipsisa32r2           33
#define bfd_mach_mipsisa64             64
#define bfd_mach_mipsisa64r2           65
  bfd_arch_i386,      /* Intel 386 */
#define bfd_mach_i386_i386 1
#define bfd_mach_i386_i8086 2
#define bfd_mach_i386_i386_intel_syntax 3
#define bfd_mach_x86_64 64
#define bfd_mach_x86_64_intel_syntax 65
  bfd_arch_we32k,     /* AT&T WE32xxx */
  bfd_arch_tahoe,     /* CCI/Harris Tahoe */
  bfd_arch_i860,      /* Intel 860 */
  bfd_arch_i370,      /* IBM 360/370 Mainframes */
  bfd_arch_romp,      /* IBM ROMP PC/RT */
  bfd_arch_alliant,   /* Alliant */
  bfd_arch_convex,    /* Convex */
  bfd_arch_m88k,      /* Motorola 88xxx */
  bfd_arch_m98k,      /* Motorola 98xxx */
  bfd_arch_pyramid,   /* Pyramid Technology */
  bfd_arch_h8300,     /* Renesas H8/300 (formerly Hitachi H8/300) */
#define bfd_mach_h8300    1
#define bfd_mach_h8300h   2
#define bfd_mach_h8300s   3
#define bfd_mach_h8300hn  4
#define bfd_mach_h8300sn  5
#define bfd_mach_h8300sx  6
#define bfd_mach_h8300sxn 7
  bfd_arch_pdp11,     /* DEC PDP-11 */
  bfd_arch_powerpc,   /* PowerPC */
#define bfd_mach_ppc           32
#define bfd_mach_ppc64         64
#define bfd_mach_ppc_403       403
#define bfd_mach_ppc_403gc     4030
#define bfd_mach_ppc_505       505
#define bfd_mach_ppc_601       601
#define bfd_mach_ppc_602       602
#define bfd_mach_ppc_603       603
#define bfd_mach_ppc_ec603e    6031
#define bfd_mach_ppc_604       604
#define bfd_mach_ppc_620       620
#define bfd_mach_ppc_630       630
#define bfd_mach_ppc_750       750
#define bfd_mach_ppc_860       860
#define bfd_mach_ppc_a35       35
#define bfd_mach_ppc_rs64ii    642
#define bfd_mach_ppc_rs64iii   643
#define bfd_mach_ppc_7400      7400
#define bfd_mach_ppc_e500      500
  bfd_arch_rs6000,    /* IBM RS/6000 */
#define bfd_mach_rs6k          6000
#define bfd_mach_rs6k_rs1      6001
#define bfd_mach_rs6k_rsc      6003
#define bfd_mach_rs6k_rs2      6002
  bfd_arch_hppa,      /* HP PA RISC */
#define bfd_mach_hppa10        10
#define bfd_mach_hppa11        11
#define bfd_mach_hppa20        20
#define bfd_mach_hppa20w       25
  bfd_arch_d10v,      /* Mitsubishi D10V */
#define bfd_mach_d10v          1
#define bfd_mach_d10v_ts2      2
#define bfd_mach_d10v_ts3      3
  bfd_arch_d30v,      /* Mitsubishi D30V */
  bfd_arch_dlx,       /* DLX */
  bfd_arch_m68hc11,   /* Motorola 68HC11 */
  bfd_arch_m68hc12,   /* Motorola 68HC12 */
#define bfd_mach_m6812_default 0
#define bfd_mach_m6812         1
#define bfd_mach_m6812s        2
  bfd_arch_z8k,       /* Zilog Z8000 */
#define bfd_mach_z8001         1
#define bfd_mach_z8002         2
  bfd_arch_h8500,     /* Renesas H8/500 (formerly Hitachi H8/500) */
  bfd_arch_sh,        /* Renesas / SuperH SH (formerly Hitachi SH) */
#define bfd_mach_sh            1
#define bfd_mach_sh2        0x20
#define bfd_mach_sh_dsp     0x2d
#define bfd_mach_sh2e       0x2e
#define bfd_mach_sh3        0x30
#define bfd_mach_sh3_dsp    0x3d
#define bfd_mach_sh3e       0x3e
#define bfd_mach_sh4        0x40
#define bfd_mach_sh4_nofpu  0x41
#define bfd_mach_sh4a       0x4a
#define bfd_mach_sh4a_nofpu 0x4b
#define bfd_mach_sh4al_dsp  0x4d
#define bfd_mach_sh5        0x50
  bfd_arch_alpha,     /* Dec Alpha */
#define bfd_mach_alpha_ev4  0x10
#define bfd_mach_alpha_ev5  0x20
#define bfd_mach_alpha_ev6  0x30
  bfd_arch_arm,       /* Advanced Risc Machines ARM.  */
#define bfd_mach_arm_unknown   0
#define bfd_mach_arm_2         1
#define bfd_mach_arm_2a        2
#define bfd_mach_arm_3         3
#define bfd_mach_arm_3M        4
#define bfd_mach_arm_4         5
#define bfd_mach_arm_4T        6
#define bfd_mach_arm_5         7
#define bfd_mach_arm_5T        8
#define bfd_mach_arm_5TE       9
#define bfd_mach_arm_XScale    10
#define bfd_mach_arm_ep9312    11
#define bfd_mach_arm_iWMMXt    12
  bfd_arch_ns32k,     /* National Semiconductors ns32000 */
  bfd_arch_w65,       /* WDC 65816 */
  bfd_arch_tic30,     /* Texas Instruments TMS320C30 */
  bfd_arch_tic4x,     /* Texas Instruments TMS320C3X/4X */
#define bfd_mach_tic3x         30
#define bfd_mach_tic4x         40
  bfd_arch_tic54x,    /* Texas Instruments TMS320C54X */
  bfd_arch_tic80,     /* TI TMS320c80 (MVP) */
  bfd_arch_v850,      /* NEC V850 */
#define bfd_mach_v850          1
#define bfd_mach_v850e         'E'
#define bfd_mach_v850e1        '1'
  bfd_arch_arc,       /* ARC Cores */
#define bfd_mach_arc_5         5
#define bfd_mach_arc_6         6
#define bfd_mach_arc_7         7
#define bfd_mach_arc_8         8
  bfd_arch_m32r,      /* Renesas M32R (formerly Mitsubishi M32R/D) */
#define bfd_mach_m32r          1 /* For backwards compatibility.  */
#define bfd_mach_m32rx         'x'
#define bfd_mach_m32r2         '2'
  bfd_arch_mn10200,   /* Matsushita MN10200 */
  bfd_arch_mn10300,   /* Matsushita MN10300 */
#define bfd_mach_mn10300               300
#define bfd_mach_am33          330
#define bfd_mach_am33_2        332
  bfd_arch_fr30,
#define bfd_mach_fr30          0x46523330
  bfd_arch_frv,
#define bfd_mach_frv           1
#define bfd_mach_frvsimple     2
#define bfd_mach_fr300         300
#define bfd_mach_fr400         400
#define bfd_mach_frvtomcat     499     /* fr500 prototype */
#define bfd_mach_fr500         500
#define bfd_mach_fr550         550
  bfd_arch_mcore,
  bfd_arch_ia64,      /* HP/Intel ia64 */
#define bfd_mach_ia64_elf64    64
#define bfd_mach_ia64_elf32    32
  bfd_arch_ip2k,      /* Ubicom IP2K microcontrollers. */
#define bfd_mach_ip2022        1
#define bfd_mach_ip2022ext     2
 bfd_arch_iq2000,     /* Vitesse IQ2000.  */
#define bfd_mach_iq2000        1
#define bfd_mach_iq10          2
  bfd_arch_pj,
  bfd_arch_avr,       /* Atmel AVR microcontrollers.  */
#define bfd_mach_avr1          1
#define bfd_mach_avr2          2
#define bfd_mach_avr3          3
#define bfd_mach_avr4          4
#define bfd_mach_avr5          5
  bfd_arch_cris,      /* Axis CRIS */
  bfd_arch_s390,      /* IBM s390 */
#define bfd_mach_s390_31       31
#define bfd_mach_s390_64       64
  bfd_arch_openrisc,  /* OpenRISC */
  bfd_arch_mmix,      /* Donald Knuth's educational processor.  */
  bfd_arch_xstormy16,
#define bfd_mach_xstormy16     1
  bfd_arch_msp430,    /* Texas Instruments MSP430 architecture.  */
#define bfd_mach_msp11          11
#define bfd_mach_msp110         110
#define bfd_mach_msp12          12
#define bfd_mach_msp13          13
#define bfd_mach_msp14          14
#define bfd_mach_msp15          15
#define bfd_mach_msp16          16  
#define bfd_mach_msp31          31
#define bfd_mach_msp32          32
#define bfd_mach_msp33          33
#define bfd_mach_msp41          41
#define bfd_mach_msp42          42
#define bfd_mach_msp43          43
#define bfd_mach_msp44          44
  bfd_arch_xtensa,    /* Tensilica's Xtensa cores.  */
#define bfd_mach_xtensa        1
  bfd_arch_last
  };

typedef struct bfd_arch_info
{
  int bits_per_word;
  int bits_per_address;
  int bits_per_byte;
  enum bfd_architecture arch;
  unsigned long mach;
  const char *arch_name;
  const char *printable_name;
  unsigned int section_align_power;
  /* TRUE if this is the default machine for the architecture.
     The default arch should be the first entry for an arch so that
     all the entries for that arch can be accessed via <<next>>.  */
  bfd_boolean the_default;
  const struct bfd_arch_info * (*compatible)
    (const struct bfd_arch_info *a, const struct bfd_arch_info *b);

  bfd_boolean (*scan) (const struct bfd_arch_info *, const char *);

  const struct bfd_arch_info *next;
}
bfd_arch_info_type;

const char *bfd_printable_name (bfd *abfd);

const bfd_arch_info_type *bfd_scan_arch (const char *string);

const char **bfd_arch_list (void);

const bfd_arch_info_type *bfd_arch_get_compatible
   (const bfd *abfd, const bfd *bbfd, bfd_boolean accept_unknowns);

void bfd_set_arch_info (bfd *abfd, const bfd_arch_info_type *arg);

enum bfd_architecture bfd_get_arch (bfd *abfd);

unsigned long bfd_get_mach (bfd *abfd);

unsigned int bfd_arch_bits_per_byte (bfd *abfd);

unsigned int bfd_arch_bits_per_address (bfd *abfd);

const bfd_arch_info_type *bfd_get_arch_info (bfd *abfd);

const bfd_arch_info_type *bfd_lookup_arch
   (enum bfd_architecture arch, unsigned long machine);

const char *bfd_printable_arch_mach
   (enum bfd_architecture arch, unsigned long machine);

unsigned int bfd_octets_per_byte (bfd *abfd);

unsigned int bfd_arch_mach_octets_per_byte
   (enum bfd_architecture arch, unsigned long machine);

/* Extracted from reloc.c.  */
typedef enum bfd_reloc_status
{
  /* No errors detected.  */
  bfd_reloc_ok,

  /* The relocation was performed, but there was an overflow.  */
  bfd_reloc_overflow,

  /* The address to relocate was not within the section supplied.  */
  bfd_reloc_outofrange,

  /* Used by special functions.  */
  bfd_reloc_continue,

  /* Unsupported relocation size requested.  */
  bfd_reloc_notsupported,

  /* Unused.  */
  bfd_reloc_other,

  /* The symbol to relocate against was undefined.  */
  bfd_reloc_undefined,

  /* The relocation was performed, but may not be ok - presently
     generated only when linking i960 coff files with i960 b.out
     symbols.  If this type is returned, the error_message argument
     to bfd_perform_relocation will be set.  */
  bfd_reloc_dangerous
 }
 bfd_reloc_status_type;


typedef struct reloc_cache_entry
{
  /* A pointer into the canonical table of pointers.  */
  struct bfd_symbol **sym_ptr_ptr;

  /* offset in section.  */
  bfd_size_type address;

  /* addend for relocation value.  */
  bfd_vma addend;

  /* Pointer to how to perform the required relocation.  */
  reloc_howto_type *howto;

}
arelent;

enum complain_overflow
{
  /* Do not complain on overflow.  */
  complain_overflow_dont,

  /* Complain if the bitfield overflows, whether it is considered
     as signed or unsigned.  */
  complain_overflow_bitfield,

  /* Complain if the value overflows when considered as signed
     number.  */
  complain_overflow_signed,

  /* Complain if the value overflows when considered as an
     unsigned number.  */
  complain_overflow_unsigned
};

struct reloc_howto_struct
{
  /*  The type field has mainly a documentary use - the back end can
      do what it wants with it, though normally the back end's
      external idea of what a reloc number is stored
      in this field.  For example, a PC relative word relocation
      in a coff environment has the type 023 - because that's
      what the outside world calls a R_PCRWORD reloc.  */
  unsigned int type;

  /*  The value the final relocation is shifted right by.  This drops
      unwanted data from the relocation.  */
  unsigned int rightshift;

  /*  The size of the item to be relocated.  This is *not* a
      power-of-two measure.  To get the number of bytes operated
      on by a type of relocation, use bfd_get_reloc_size.  */
  int size;

  /*  The number of bits in the item to be relocated.  This is used
      when doing overflow checking.  */
  unsigned int bitsize;

  /*  Notes that the relocation is relative to the location in the
      data section of the addend.  The relocation function will
      subtract from the relocation value the address of the location
      being relocated.  */
  bfd_boolean pc_relative;

  /*  The bit position of the reloc value in the destination.
      The relocated value is left shifted by this amount.  */
  unsigned int bitpos;

  /* What type of overflow error should be checked for when
     relocating.  */
  enum complain_overflow complain_on_overflow;

  /* If this field is non null, then the supplied function is
     called rather than the normal function.  This allows really
     strange relocation methods to be accommodated (e.g., i960 callj
     instructions).  */
  bfd_reloc_status_type (*special_function)
    (bfd *, arelent *, struct bfd_symbol *, void *, asection *,
     bfd *, char **);

  /* The textual name of the relocation type.  */
  char *name;

  /* Some formats record a relocation addend in the section contents
     rather than with the relocation.  For ELF formats this is the
     distinction between USE_REL and USE_RELA (though the code checks
     for USE_REL == 1/0).  The value of this field is TRUE if the
     addend is recorded with the section contents; when performing a
     partial link (ld -r) the section contents (the data) will be
     modified.  The value of this field is FALSE if addends are
     recorded with the relocation (in arelent.addend); when performing
     a partial link the relocation will be modified.
     All relocations for all ELF USE_RELA targets should set this field
     to FALSE (values of TRUE should be looked on with suspicion).
     However, the converse is not true: not all relocations of all ELF
     USE_REL targets set this field to TRUE.  Why this is so is peculiar
     to each particular target.  For relocs that aren't used in partial
     links (e.g. GOT stuff) it doesn't matter what this is set to.  */
  bfd_boolean partial_inplace;

  /* src_mask selects the part of the instruction (or data) to be used
     in the relocation sum.  If the target relocations don't have an
     addend in the reloc, eg. ELF USE_REL, src_mask will normally equal
     dst_mask to extract the addend from the section contents.  If
     relocations do have an addend in the reloc, eg. ELF USE_RELA, this
     field should be zero.  Non-zero values for ELF USE_RELA targets are
     bogus as in those cases the value in the dst_mask part of the
     section contents should be treated as garbage.  */
  bfd_vma src_mask;

  /* dst_mask selects which parts of the instruction (or data) are
     replaced with a relocated value.  */
  bfd_vma dst_mask;

  /* When some formats create PC relative instructions, they leave
     the value of the pc of the place being relocated in the offset
     slot of the instruction, so that a PC relative relocation can
     be made just by adding in an ordinary offset (e.g., sun3 a.out).
     Some formats leave the displacement part of an instruction
     empty (e.g., m88k bcs); this flag signals the fact.  */
  bfd_boolean pcrel_offset;
};

#define HOWTO(C, R, S, B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC) \
  { (unsigned) C, R, S, B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC }
#define NEWHOWTO(FUNCTION, NAME, SIZE, REL, IN) \
  HOWTO (0, 0, SIZE, 0, REL, 0, complain_overflow_dont, FUNCTION, \
         NAME, FALSE, 0, 0, IN)

#define EMPTY_HOWTO(C) \
  HOWTO ((C), 0, 0, 0, FALSE, 0, complain_overflow_dont, NULL, \
         NULL, FALSE, 0, 0, FALSE)

#define HOWTO_PREPARE(relocation, symbol)               \
  {                                                     \
    if (symbol != NULL)                                 \
      {                                                 \
        if (bfd_is_com_section (symbol->section))       \
          {                                             \
            relocation = 0;                             \
          }                                             \
        else                                            \
          {                                             \
            relocation = symbol->value;                 \
          }                                             \
      }                                                 \
  }

unsigned int bfd_get_reloc_size (reloc_howto_type *);

typedef struct relent_chain
{
  arelent relent;
  struct relent_chain *next;
}
arelent_chain;

bfd_reloc_status_type bfd_check_overflow
   (enum complain_overflow how,
    unsigned int bitsize,
    unsigned int rightshift,
    unsigned int addrsize,
    bfd_vma relocation);

bfd_reloc_status_type bfd_perform_relocation
   (bfd *abfd,
    arelent *reloc_entry,
    void *data,
    asection *input_section,
    bfd *output_bfd,
    char **error_message);

bfd_reloc_status_type bfd_install_relocation
   (bfd *abfd,
    arelent *reloc_entry,
    void *data, bfd_vma data_start,
    asection *input_section,
    char **error_message);

enum bfd_reloc_code_real {
  _dummy_first_bfd_reloc_code_real,


/* Basic absolute relocations of N bits.  */
  BFD_RELOC_64,
  BFD_RELOC_32,
  BFD_RELOC_26,
  BFD_RELOC_24,
  BFD_RELOC_16,
  BFD_RELOC_14,
  BFD_RELOC_8,

/* PC-relative relocations.  Sometimes these are relative to the address
of the relocation itself; sometimes they are relative to the start of
the section containing the relocation.  It depends on the specific target.

The 24-bit relocation is used in some Intel 960 configurations.  */
  BFD_RELOC_64_PCREL,
  BFD_RELOC_32_PCREL,
  BFD_RELOC_24_PCREL,
  BFD_RELOC_16_PCREL,
  BFD_RELOC_12_PCREL,
  BFD_RELOC_8_PCREL,

/* For ELF.  */
  BFD_RELOC_32_GOT_PCREL,
  BFD_RELOC_16_GOT_PCREL,
  BFD_RELOC_8_GOT_PCREL,
  BFD_RELOC_32_GOTOFF,
  BFD_RELOC_16_GOTOFF,
  BFD_RELOC_LO16_GOTOFF,
  BFD_RELOC_HI16_GOTOFF,
  BFD_RELOC_HI16_S_GOTOFF,
  BFD_RELOC_8_GOTOFF,
  BFD_RELOC_64_PLT_PCREL,
  BFD_RELOC_32_PLT_PCREL,
  BFD_RELOC_24_PLT_PCREL,
  BFD_RELOC_16_PLT_PCREL,
  BFD_RELOC_8_PLT_PCREL,
  BFD_RELOC_64_PLTOFF,
  BFD_RELOC_32_PLTOFF,
  BFD_RELOC_16_PLTOFF,
  BFD_RELOC_LO16_PLTOFF,
  BFD_RELOC_HI16_PLTOFF,
  BFD_RELOC_HI16_S_PLTOFF,
  BFD_RELOC_8_PLTOFF,

/* Relocations used by 68K ELF.  */
  BFD_RELOC_68K_GLOB_DAT,
  BFD_RELOC_68K_JMP_SLOT,
  BFD_RELOC_68K_RELATIVE,

/* Linkage-table relative.  */
  BFD_RELOC_32_BASEREL,
  BFD_RELOC_16_BASEREL,
  BFD_RELOC_LO16_BASEREL,
  BFD_RELOC_HI16_BASEREL,
  BFD_RELOC_HI16_S_BASEREL,
  BFD_RELOC_8_BASEREL,
  BFD_RELOC_RVA,

/* Absolute 8-bit relocation, but used to form an address like 0xFFnn.  */
  BFD_RELOC_8_FFnn,

/* These PC-relative relocations are stored as word displacements --
i.e., byte displacements shifted right two bits.  The 30-bit word
displacement (<<32_PCREL_S2>> -- 32 bits, shifted 2) is used on the
SPARC.  (SPARC tools generally refer to this as <<WDISP30>>.)  The
signed 16-bit displacement is used on the MIPS, and the 23-bit
displacement is used on the Alpha.  */
  BFD_RELOC_32_PCREL_S2,
  BFD_RELOC_16_PCREL_S2,
  BFD_RELOC_23_PCREL_S2,
  BFD_RELOC_18_PCREL_S2,
  BFD_RELOC_28_PCREL_S2,

/* High 22 bits and low 10 bits of 32-bit value, placed into lower bits of
the target word.  These are used on the SPARC.  */
  BFD_RELOC_HI22,
  BFD_RELOC_LO10,

/* For systems that allocate a Global Pointer register, these are
displacements off that register.  These relocation types are
handled specially, because the value the register will have is
decided relatively late.  */
  BFD_RELOC_GPREL16,
  BFD_RELOC_GPREL32,

/* Reloc types used for i960/b.out.  */
  BFD_RELOC_I960_CALLJ,

/* SPARC ELF relocations.  There is probably some overlap with other
relocation types already defined.  */
  BFD_RELOC_NONE,
  BFD_RELOC_SPARC_WDISP22,
  BFD_RELOC_SPARC22,
  BFD_RELOC_SPARC13,
  BFD_RELOC_SPARC_GOT10,
  BFD_RELOC_SPARC_GOT13,
  BFD_RELOC_SPARC_GOT22,
  BFD_RELOC_SPARC_PC10,
  BFD_RELOC_SPARC_PC22,
  BFD_RELOC_SPARC_WPLT30,
  BFD_RELOC_SPARC_COPY,
  BFD_RELOC_SPARC_GLOB_DAT,
  BFD_RELOC_SPARC_JMP_SLOT,
  BFD_RELOC_SPARC_RELATIVE,
  BFD_RELOC_SPARC_UA16,
  BFD_RELOC_SPARC_UA32,
  BFD_RELOC_SPARC_UA64,

/* I think these are specific to SPARC a.out (e.g., Sun 4).  */
  BFD_RELOC_SPARC_BASE13,
  BFD_RELOC_SPARC_BASE22,

/* SPARC64 relocations  */
#define BFD_RELOC_SPARC_64 BFD_RELOC_64
  BFD_RELOC_SPARC_10,
  BFD_RELOC_SPARC_11,
  BFD_RELOC_SPARC_OLO10,
  BFD_RELOC_SPARC_HH22,
  BFD_RELOC_SPARC_HM10,
  BFD_RELOC_SPARC_LM22,
  BFD_RELOC_SPARC_PC_HH22,
  BFD_RELOC_SPARC_PC_HM10,
  BFD_RELOC_SPARC_PC_LM22,
  BFD_RELOC_SPARC_WDISP16,
  BFD_RELOC_SPARC_WDISP19,
  BFD_RELOC_SPARC_7,
  BFD_RELOC_SPARC_6,
  BFD_RELOC_SPARC_5,
#define BFD_RELOC_SPARC_DISP64 BFD_RELOC_64_PCREL
  BFD_RELOC_SPARC_PLT32,
  BFD_RELOC_SPARC_PLT64,
  BFD_RELOC_SPARC_HIX22,
  BFD_RELOC_SPARC_LOX10,
  BFD_RELOC_SPARC_H44,
  BFD_RELOC_SPARC_M44,
  BFD_RELOC_SPARC_L44,
  BFD_RELOC_SPARC_REGISTER,

/* SPARC little endian relocation  */
  BFD_RELOC_SPARC_REV32,

/* SPARC TLS relocations  */
  BFD_RELOC_SPARC_TLS_GD_HI22,
  BFD_RELOC_SPARC_TLS_GD_LO10,
  BFD_RELOC_SPARC_TLS_GD_ADD,
  BFD_RELOC_SPARC_TLS_GD_CALL,
  BFD_RELOC_SPARC_TLS_LDM_HI22,
  BFD_RELOC_SPARC_TLS_LDM_LO10,
  BFD_RELOC_SPARC_TLS_LDM_ADD,
  BFD_RELOC_SPARC_TLS_LDM_CALL,
  BFD_RELOC_SPARC_TLS_LDO_HIX22,
  BFD_RELOC_SPARC_TLS_LDO_LOX10,
  BFD_RELOC_SPARC_TLS_LDO_ADD,
  BFD_RELOC_SPARC_TLS_IE_HI22,
  BFD_RELOC_SPARC_TLS_IE_LO10,
  BFD_RELOC_SPARC_TLS_IE_LD,
  BFD_RELOC_SPARC_TLS_IE_LDX,
  BFD_RELOC_SPARC_TLS_IE_ADD,
  BFD_RELOC_SPARC_TLS_LE_HIX22,
  BFD_RELOC_SPARC_TLS_LE_LOX10,
  BFD_RELOC_SPARC_TLS_DTPMOD32,
  BFD_RELOC_SPARC_TLS_DTPMOD64,
  BFD_RELOC_SPARC_TLS_DTPOFF32,
  BFD_RELOC_SPARC_TLS_DTPOFF64,
  BFD_RELOC_SPARC_TLS_TPOFF32,
  BFD_RELOC_SPARC_TLS_TPOFF64,

/* Alpha ECOFF and ELF relocations.  Some of these treat the symbol or
"addend" in some special way.
For GPDISP_HI16 ("gpdisp") relocations, the symbol is ignored when
writing; when reading, it will be the absolute section symbol.  The
addend is the displacement in bytes of the "lda" instruction from
the "ldah" instruction (which is at the address of this reloc).  */
  BFD_RELOC_ALPHA_GPDISP_HI16,

/* For GPDISP_LO16 ("ignore") relocations, the symbol is handled as
with GPDISP_HI16 relocs.  The addend is ignored when writing the
relocations out, and is filled in with the file's GP value on
reading, for convenience.  */
  BFD_RELOC_ALPHA_GPDISP_LO16,

/* The ELF GPDISP relocation is exactly the same as the GPDISP_HI16
relocation except that there is no accompanying GPDISP_LO16
relocation.  */
  BFD_RELOC_ALPHA_GPDISP,

/* The Alpha LITERAL/LITUSE relocs are produced by a symbol reference;
the assembler turns it into a LDQ instruction to load the address of
the symbol, and then fills in a register in the real instruction.

The LITERAL reloc, at the LDQ instruction, refers to the .lita
section symbol.  The addend is ignored when writing, but is filled
in with the file's GP value on reading, for convenience, as with the
GPDISP_LO16 reloc.

The ELF_LITERAL reloc is somewhere between 16_GOTOFF and GPDISP_LO16.
It should refer to the symbol to be referenced, as with 16_GOTOFF,
but it generates output not based on the position within the .got
section, but relative to the GP value chosen for the file during the
final link stage.

The LITUSE reloc, on the instruction using the loaded address, gives
information to the linker that it might be able to use to optimize
away some literal section references.  The symbol is ignored (read
as the absolute section symbol), and the "addend" indicates the type
of instruction using the register:
1 - "memory" fmt insn
2 - byte-manipulation (byte offset reg)
3 - jsr (target of branch)  */
  BFD_RELOC_ALPHA_LITERAL,
  BFD_RELOC_ALPHA_ELF_LITERAL,
  BFD_RELOC_ALPHA_LITUSE,

/* The HINT relocation indicates a value that should be filled into the
"hint" field of a jmp/jsr/ret instruction, for possible branch-
prediction logic which may be provided on some processors.  */
  BFD_RELOC_ALPHA_HINT,

/* The LINKAGE relocation outputs a linkage pair in the object file,
which is filled by the linker.  */
  BFD_RELOC_ALPHA_LINKAGE,

/* The CODEADDR relocation outputs a STO_CA in the object file,
which is filled by the linker.  */
  BFD_RELOC_ALPHA_CODEADDR,

/* The GPREL_HI/LO relocations together form a 32-bit offset from the
GP register.  */
  BFD_RELOC_ALPHA_GPREL_HI16,
  BFD_RELOC_ALPHA_GPREL_LO16,

/* Like BFD_RELOC_23_PCREL_S2, except that the source and target must
share a common GP, and the target address is adjusted for
STO_ALPHA_STD_GPLOAD.  */
  BFD_RELOC_ALPHA_BRSGP,

/* Alpha thread-local storage relocations.  */
  BFD_RELOC_ALPHA_TLSGD,
  BFD_RELOC_ALPHA_TLSLDM,
  BFD_RELOC_ALPHA_DTPMOD64,
  BFD_RELOC_ALPHA_GOTDTPREL16,
  BFD_RELOC_ALPHA_DTPREL64,
  BFD_RELOC_ALPHA_DTPREL_HI16,
  BFD_RELOC_ALPHA_DTPREL_LO16,
  BFD_RELOC_ALPHA_DTPREL16,
  BFD_RELOC_ALPHA_GOTTPREL16,
  BFD_RELOC_ALPHA_TPREL64,
  BFD_RELOC_ALPHA_TPREL_HI16,
  BFD_RELOC_ALPHA_TPREL_LO16,
  BFD_RELOC_ALPHA_TPREL16,

/* Bits 27..2 of the relocation address shifted right 2 bits;
simple reloc otherwise.  */
  BFD_RELOC_MIPS_JMP,

/* The MIPS16 jump instruction.  */
  BFD_RELOC_MIPS16_JMP,

/* MIPS16 GP relative reloc.  */
  BFD_RELOC_MIPS16_GPREL,

/* High 16 bits of 32-bit value; simple reloc.  */
  BFD_RELOC_HI16,

/* High 16 bits of 32-bit value but the low 16 bits will be sign
extended and added to form the final result.  If the low 16
bits form a negative number, we need to add one to the high value
to compensate for the borrow when the low bits are added.  */
  BFD_RELOC_HI16_S,

/* Low 16 bits.  */
  BFD_RELOC_LO16,

/* Like BFD_RELOC_HI16_S, but PC relative.  */
  BFD_RELOC_PCREL_HI16_S,

/* Like BFD_RELOC_LO16, but PC relative.  */
  BFD_RELOC_PCREL_LO16,

/* Relocation against a MIPS literal section.  */
  BFD_RELOC_MIPS_LITERAL,

/* MIPS ELF relocations.  */
  BFD_RELOC_MIPS_GOT16,
  BFD_RELOC_MIPS_CALL16,
  BFD_RELOC_MIPS_GOT_HI16,
  BFD_RELOC_MIPS_GOT_LO16,
  BFD_RELOC_MIPS_CALL_HI16,
  BFD_RELOC_MIPS_CALL_LO16,
  BFD_RELOC_MIPS_SUB,
  BFD_RELOC_MIPS_GOT_PAGE,
  BFD_RELOC_MIPS_GOT_OFST,
  BFD_RELOC_MIPS_GOT_DISP,
  BFD_RELOC_MIPS_SHIFT5,
  BFD_RELOC_MIPS_SHIFT6,
  BFD_RELOC_MIPS_INSERT_A,
  BFD_RELOC_MIPS_INSERT_B,
  BFD_RELOC_MIPS_DELETE,
  BFD_RELOC_MIPS_HIGHEST,
  BFD_RELOC_MIPS_HIGHER,
  BFD_RELOC_MIPS_SCN_DISP,
  BFD_RELOC_MIPS_REL16,
  BFD_RELOC_MIPS_RELGOT,
  BFD_RELOC_MIPS_JALR,


/* Fujitsu Frv Relocations.  */
  BFD_RELOC_FRV_LABEL16,
  BFD_RELOC_FRV_LABEL24,
  BFD_RELOC_FRV_LO16,
  BFD_RELOC_FRV_HI16,
  BFD_RELOC_FRV_GPREL12,
  BFD_RELOC_FRV_GPRELU12,
  BFD_RELOC_FRV_GPREL32,
  BFD_RELOC_FRV_GPRELHI,
  BFD_RELOC_FRV_GPRELLO,
  BFD_RELOC_FRV_GOT12,
  BFD_RELOC_FRV_GOTHI,
  BFD_RELOC_FRV_GOTLO,
  BFD_RELOC_FRV_FUNCDESC,
  BFD_RELOC_FRV_FUNCDESC_GOT12,
  BFD_RELOC_FRV_FUNCDESC_GOTHI,
  BFD_RELOC_FRV_FUNCDESC_GOTLO,
  BFD_RELOC_FRV_FUNCDESC_VALUE,
  BFD_RELOC_FRV_FUNCDESC_GOTOFF12,
  BFD_RELOC_FRV_FUNCDESC_GOTOFFHI,
  BFD_RELOC_FRV_FUNCDESC_GOTOFFLO,
  BFD_RELOC_FRV_GOTOFF12,
  BFD_RELOC_FRV_GOTOFFHI,
  BFD_RELOC_FRV_GOTOFFLO,


/* This is a 24bit GOT-relative reloc for the mn10300.  */
  BFD_RELOC_MN10300_GOTOFF24,

/* This is a 32bit GOT-relative reloc for the mn10300, offset by two bytes
in the instruction.  */
  BFD_RELOC_MN10300_GOT32,

/* This is a 24bit GOT-relative reloc for the mn10300, offset by two bytes
in the instruction.  */
  BFD_RELOC_MN10300_GOT24,

/* This is a 16bit GOT-relative reloc for the mn10300, offset by two bytes
in the instruction.  */
  BFD_RELOC_MN10300_GOT16,

/* Copy symbol at runtime.  */
  BFD_RELOC_MN10300_COPY,

/* Create GOT entry.  */
  BFD_RELOC_MN10300_GLOB_DAT,

/* Create PLT entry.  */
  BFD_RELOC_MN10300_JMP_SLOT,

/* Adjust by program base.  */
  BFD_RELOC_MN10300_RELATIVE,


/* i386/elf relocations  */
  BFD_RELOC_386_GOT32,
  BFD_RELOC_386_PLT32,
  BFD_RELOC_386_COPY,
  BFD_RELOC_386_GLOB_DAT,
  BFD_RELOC_386_JUMP_SLOT,
  BFD_RELOC_386_RELATIVE,
  BFD_RELOC_386_GOTOFF,
  BFD_RELOC_386_GOTPC,
  BFD_RELOC_386_TLS_TPOFF,
  BFD_RELOC_386_TLS_IE,
  BFD_RELOC_386_TLS_GOTIE,
  BFD_RELOC_386_TLS_LE,
  BFD_RELOC_386_TLS_GD,
  BFD_RELOC_386_TLS_LDM,
  BFD_RELOC_386_TLS_LDO_32,
  BFD_RELOC_386_TLS_IE_32,
  BFD_RELOC_386_TLS_LE_32,
  BFD_RELOC_386_TLS_DTPMOD32,
  BFD_RELOC_386_TLS_DTPOFF32,
  BFD_RELOC_386_TLS_TPOFF32,

/* x86-64/elf relocations  */
  BFD_RELOC_X86_64_GOT32,
  BFD_RELOC_X86_64_PLT32,
  BFD_RELOC_X86_64_COPY,
  BFD_RELOC_X86_64_GLOB_DAT,
  BFD_RELOC_X86_64_JUMP_SLOT,
  BFD_RELOC_X86_64_RELATIVE,
  BFD_RELOC_X86_64_GOTPCREL,
  BFD_RELOC_X86_64_32S,
  BFD_RELOC_X86_64_DTPMOD64,
  BFD_RELOC_X86_64_DTPOFF64,
  BFD_RELOC_X86_64_TPOFF64,
  BFD_RELOC_X86_64_TLSGD,
  BFD_RELOC_X86_64_TLSLD,
  BFD_RELOC_X86_64_DTPOFF32,
  BFD_RELOC_X86_64_GOTTPOFF,
  BFD_RELOC_X86_64_TPOFF32,

/* ns32k relocations  */
  BFD_RELOC_NS32K_IMM_8,
  BFD_RELOC_NS32K_IMM_16,
  BFD_RELOC_NS32K_IMM_32,
  BFD_RELOC_NS32K_IMM_8_PCREL,
  BFD_RELOC_NS32K_IMM_16_PCREL,
  BFD_RELOC_NS32K_IMM_32_PCREL,
  BFD_RELOC_NS32K_DISP_8,
  BFD_RELOC_NS32K_DISP_16,
  BFD_RELOC_NS32K_DISP_32,
  BFD_RELOC_NS32K_DISP_8_PCREL,
  BFD_RELOC_NS32K_DISP_16_PCREL,
  BFD_RELOC_NS32K_DISP_32_PCREL,

/* PDP11 relocations  */
  BFD_RELOC_PDP11_DISP_8_PCREL,
  BFD_RELOC_PDP11_DISP_6_PCREL,

/* Picojava relocs.  Not all of these appear in object files.  */
  BFD_RELOC_PJ_CODE_HI16,
  BFD_RELOC_PJ_CODE_LO16,
  BFD_RELOC_PJ_CODE_DIR16,
  BFD_RELOC_PJ_CODE_DIR32,
  BFD_RELOC_PJ_CODE_REL16,
  BFD_RELOC_PJ_CODE_REL32,

/* Power(rs6000) and PowerPC relocations.  */
  BFD_RELOC_PPC_B26,
  BFD_RELOC_PPC_BA26,
  BFD_RELOC_PPC_TOC16,
  BFD_RELOC_PPC_B16,
  BFD_RELOC_PPC_B16_BRTAKEN,
  BFD_RELOC_PPC_B16_BRNTAKEN,
  BFD_RELOC_PPC_BA16,
  BFD_RELOC_PPC_BA16_BRTAKEN,
  BFD_RELOC_PPC_BA16_BRNTAKEN,
  BFD_RELOC_PPC_COPY,
  BFD_RELOC_PPC_GLOB_DAT,
  BFD_RELOC_PPC_JMP_SLOT,
  BFD_RELOC_PPC_RELATIVE,
  BFD_RELOC_PPC_LOCAL24PC,
  BFD_RELOC_PPC_EMB_NADDR32,
  BFD_RELOC_PPC_EMB_NADDR16,
  BFD_RELOC_PPC_EMB_NADDR16_LO,
  BFD_RELOC_PPC_EMB_NADDR16_HI,
  BFD_RELOC_PPC_EMB_NADDR16_HA,
  BFD_RELOC_PPC_EMB_SDAI16,
  BFD_RELOC_PPC_EMB_SDA2I16,
  BFD_RELOC_PPC_EMB_SDA2REL,
  BFD_RELOC_PPC_EMB_SDA21,
  BFD_RELOC_PPC_EMB_MRKREF,
  BFD_RELOC_PPC_EMB_RELSEC16,
  BFD_RELOC_PPC_EMB_RELST_LO,
  BFD_RELOC_PPC_EMB_RELST_HI,
  BFD_RELOC_PPC_EMB_RELST_HA,
  BFD_RELOC_PPC_EMB_BIT_FLD,
  BFD_RELOC_PPC_EMB_RELSDA,
  BFD_RELOC_PPC64_HIGHER,
  BFD_RELOC_PPC64_HIGHER_S,
  BFD_RELOC_PPC64_HIGHEST,
  BFD_RELOC_PPC64_HIGHEST_S,
  BFD_RELOC_PPC64_TOC16_LO,
  BFD_RELOC_PPC64_TOC16_HI,
  BFD_RELOC_PPC64_TOC16_HA,
  BFD_RELOC_PPC64_TOC,
  BFD_RELOC_PPC64_PLTGOT16,
  BFD_RELOC_PPC64_PLTGOT16_LO,
  BFD_RELOC_PPC64_PLTGOT16_HI,
  BFD_RELOC_PPC64_PLTGOT16_HA,
  BFD_RELOC_PPC64_ADDR16_DS,
  BFD_RELOC_PPC64_ADDR16_LO_DS,
  BFD_RELOC_PPC64_GOT16_DS,
  BFD_RELOC_PPC64_GOT16_LO_DS,
  BFD_RELOC_PPC64_PLT16_LO_DS,
  BFD_RELOC_PPC64_SECTOFF_DS,
  BFD_RELOC_PPC64_SECTOFF_LO_DS,
  BFD_RELOC_PPC64_TOC16_DS,
  BFD_RELOC_PPC64_TOC16_LO_DS,
  BFD_RELOC_PPC64_PLTGOT16_DS,
  BFD_RELOC_PPC64_PLTGOT16_LO_DS,

/* PowerPC and PowerPC64 thread-local storage relocations.  */
  BFD_RELOC_PPC_TLS,
  BFD_RELOC_PPC_DTPMOD,
  BFD_RELOC_PPC_TPREL16,
  BFD_RELOC_PPC_TPREL16_LO,
  BFD_RELOC_PPC_TPREL16_HI,
  BFD_RELOC_PPC_TPREL16_HA,
  BFD_RELOC_PPC_TPREL,
  BFD_RELOC_PPC_DTPREL16,
  BFD_RELOC_PPC_DTPREL16_LO,
  BFD_RELOC_PPC_DTPREL16_HI,
  BFD_RELOC_PPC_DTPREL16_HA,
  BFD_RELOC_PPC_DTPREL,
  BFD_RELOC_PPC_GOT_TLSGD16,
  BFD_RELOC_PPC_GOT_TLSGD16_LO,
  BFD_RELOC_PPC_GOT_TLSGD16_HI,
  BFD_RELOC_PPC_GOT_TLSGD16_HA,
  BFD_RELOC_PPC_GOT_TLSLD16,
  BFD_RELOC_PPC_GOT_TLSLD16_LO,
  BFD_RELOC_PPC_GOT_TLSLD16_HI,
  BFD_RELOC_PPC_GOT_TLSLD16_HA,
  BFD_RELOC_PPC_GOT_TPREL16,
  BFD_RELOC_PPC_GOT_TPREL16_LO,
  BFD_RELOC_PPC_GOT_TPREL16_HI,
  BFD_RELOC_PPC_GOT_TPREL16_HA,
  BFD_RELOC_PPC_GOT_DTPREL16,
  BFD_RELOC_PPC_GOT_DTPREL16_LO,
  BFD_RELOC_PPC_GOT_DTPREL16_HI,
  BFD_RELOC_PPC_GOT_DTPREL16_HA,
  BFD_RELOC_PPC64_TPREL16_DS,
  BFD_RELOC_PPC64_TPREL16_LO_DS,
  BFD_RELOC_PPC64_TPREL16_HIGHER,
  BFD_RELOC_PPC64_TPREL16_HIGHERA,
  BFD_RELOC_PPC64_TPREL16_HIGHEST,
  BFD_RELOC_PPC64_TPREL16_HIGHESTA,
  BFD_RELOC_PPC64_DTPREL16_DS,
  BFD_RELOC_PPC64_DTPREL16_LO_DS,
  BFD_RELOC_PPC64_DTPREL16_HIGHER,
  BFD_RELOC_PPC64_DTPREL16_HIGHERA,
  BFD_RELOC_PPC64_DTPREL16_HIGHEST,
  BFD_RELOC_PPC64_DTPREL16_HIGHESTA,

/* IBM 370/390 relocations  */
  BFD_RELOC_I370_D12,

/* The type of reloc used to build a constructor table - at the moment
probably a 32 bit wide absolute relocation, but the target can choose.
It generally does map to one of the other relocation types.  */
  BFD_RELOC_CTOR,

/* ARM 26 bit pc-relative branch.  The lowest two bits must be zero and are
not stored in the instruction.  */
  BFD_RELOC_ARM_PCREL_BRANCH,

/* ARM 26 bit pc-relative branch.  The lowest bit must be zero and is
not stored in the instruction.  The 2nd lowest bit comes from a 1 bit
field in the instruction.  */
  BFD_RELOC_ARM_PCREL_BLX,

/* Thumb 22 bit pc-relative branch.  The lowest bit must be zero and is
not stored in the instruction.  The 2nd lowest bit comes from a 1 bit
field in the instruction.  */
  BFD_RELOC_THUMB_PCREL_BLX,

/* These relocs are only used within the ARM assembler.  They are not
(at present) written to any object files.  */
  BFD_RELOC_ARM_IMMEDIATE,
  BFD_RELOC_ARM_ADRL_IMMEDIATE,
  BFD_RELOC_ARM_OFFSET_IMM,
  BFD_RELOC_ARM_SHIFT_IMM,
  BFD_RELOC_ARM_SWI,
  BFD_RELOC_ARM_MULTI,
  BFD_RELOC_ARM_CP_OFF_IMM,
  BFD_RELOC_ARM_CP_OFF_IMM_S2,
  BFD_RELOC_ARM_ADR_IMM,
  BFD_RELOC_ARM_LDR_IMM,
  BFD_RELOC_ARM_LITERAL,
  BFD_RELOC_ARM_IN_POOL,
  BFD_RELOC_ARM_OFFSET_IMM8,
  BFD_RELOC_ARM_HWLITERAL,
  BFD_RELOC_ARM_THUMB_ADD,
  BFD_RELOC_ARM_THUMB_IMM,
  BFD_RELOC_ARM_THUMB_SHIFT,
  BFD_RELOC_ARM_THUMB_OFFSET,
  BFD_RELOC_ARM_GOT12,
  BFD_RELOC_ARM_GOT32,
  BFD_RELOC_ARM_JUMP_SLOT,
  BFD_RELOC_ARM_COPY,
  BFD_RELOC_ARM_GLOB_DAT,
  BFD_RELOC_ARM_PLT32,
  BFD_RELOC_ARM_RELATIVE,
  BFD_RELOC_ARM_GOTOFF,
  BFD_RELOC_ARM_GOTPC,

/* Renesas / SuperH SH relocs.  Not all of these appear in object files.  */
  BFD_RELOC_SH_PCDISP8BY2,
  BFD_RELOC_SH_PCDISP12BY2,
  BFD_RELOC_SH_IMM4,
  BFD_RELOC_SH_IMM4BY2,
  BFD_RELOC_SH_IMM4BY4,
  BFD_RELOC_SH_IMM8,
  BFD_RELOC_SH_IMM8BY2,
  BFD_RELOC_SH_IMM8BY4,
  BFD_RELOC_SH_PCRELIMM8BY2,
  BFD_RELOC_SH_PCRELIMM8BY4,
  BFD_RELOC_SH_SWITCH16,
  BFD_RELOC_SH_SWITCH32,
  BFD_RELOC_SH_USES,
  BFD_RELOC_SH_COUNT,
  BFD_RELOC_SH_ALIGN,
  BFD_RELOC_SH_CODE,
  BFD_RELOC_SH_DATA,
  BFD_RELOC_SH_LABEL,
  BFD_RELOC_SH_LOOP_START,
  BFD_RELOC_SH_LOOP_END,
  BFD_RELOC_SH_COPY,
  BFD_RELOC_SH_GLOB_DAT,
  BFD_RELOC_SH_JMP_SLOT,
  BFD_RELOC_SH_RELATIVE,
  BFD_RELOC_SH_GOTPC,
  BFD_RELOC_SH_GOT_LOW16,
  BFD_RELOC_SH_GOT_MEDLOW16,
  BFD_RELOC_SH_GOT_MEDHI16,
  BFD_RELOC_SH_GOT_HI16,
  BFD_RELOC_SH_GOTPLT_LOW16,
  BFD_RELOC_SH_GOTPLT_MEDLOW16,
  BFD_RELOC_SH_GOTPLT_MEDHI16,
  BFD_RELOC_SH_GOTPLT_HI16,
  BFD_RELOC_SH_PLT_LOW16,
  BFD_RELOC_SH_PLT_MEDLOW16,
  BFD_RELOC_SH_PLT_MEDHI16,
  BFD_RELOC_SH_PLT_HI16,
  BFD_RELOC_SH_GOTOFF_LOW16,
  BFD_RELOC_SH_GOTOFF_MEDLOW16,
  BFD_RELOC_SH_GOTOFF_MEDHI16,
  BFD_RELOC_SH_GOTOFF_HI16,
  BFD_RELOC_SH_GOTPC_LOW16,
  BFD_RELOC_SH_GOTPC_MEDLOW16,
  BFD_RELOC_SH_GOTPC_MEDHI16,
  BFD_RELOC_SH_GOTPC_HI16,
  BFD_RELOC_SH_COPY64,
  BFD_RELOC_SH_GLOB_DAT64,
  BFD_RELOC_SH_JMP_SLOT64,
  BFD_RELOC_SH_RELATIVE64,
  BFD_RELOC_SH_GOT10BY4,
  BFD_RELOC_SH_GOT10BY8,
  BFD_RELOC_SH_GOTPLT10BY4,
  BFD_RELOC_SH_GOTPLT10BY8,
  BFD_RELOC_SH_GOTPLT32,
  BFD_RELOC_SH_SHMEDIA_CODE,
  BFD_RELOC_SH_IMMU5,
  BFD_RELOC_SH_IMMS6,
  BFD_RELOC_SH_IMMS6BY32,
  BFD_RELOC_SH_IMMU6,
  BFD_RELOC_SH_IMMS10,
  BFD_RELOC_SH_IMMS10BY2,
  BFD_RELOC_SH_IMMS10BY4,
  BFD_RELOC_SH_IMMS10BY8,
  BFD_RELOC_SH_IMMS16,
  BFD_RELOC_SH_IMMU16,
  BFD_RELOC_SH_IMM_LOW16,
  BFD_RELOC_SH_IMM_LOW16_PCREL,
  BFD_RELOC_SH_IMM_MEDLOW16,
  BFD_RELOC_SH_IMM_MEDLOW16_PCREL,
  BFD_RELOC_SH_IMM_MEDHI16,
  BFD_RELOC_SH_IMM_MEDHI16_PCREL,
  BFD_RELOC_SH_IMM_HI16,
  BFD_RELOC_SH_IMM_HI16_PCREL,
  BFD_RELOC_SH_PT_16,
  BFD_RELOC_SH_TLS_GD_32,
  BFD_RELOC_SH_TLS_LD_32,
  BFD_RELOC_SH_TLS_LDO_32,
  BFD_RELOC_SH_TLS_IE_32,
  BFD_RELOC_SH_TLS_LE_32,
  BFD_RELOC_SH_TLS_DTPMOD32,
  BFD_RELOC_SH_TLS_DTPOFF32,
  BFD_RELOC_SH_TLS_TPOFF32,

/* Thumb 23-, 12- and 9-bit pc-relative branches.  The lowest bit must
be zero and is not stored in the instruction.  */
  BFD_RELOC_THUMB_PCREL_BRANCH9,
  BFD_RELOC_THUMB_PCREL_BRANCH12,
  BFD_RELOC_THUMB_PCREL_BRANCH23,

/* ARC Cores relocs.
ARC 22 bit pc-relative branch.  The lowest two bits must be zero and are
not stored in the instruction.  The high 20 bits are installed in bits 26
through 7 of the instruction.  */
  BFD_RELOC_ARC_B22_PCREL,

/* ARC 26 bit absolute branch.  The lowest two bits must be zero and are not
stored in the instruction.  The high 24 bits are installed in bits 23
through 0.  */
  BFD_RELOC_ARC_B26,

/* Mitsubishi D10V relocs.
This is a 10-bit reloc with the right 2 bits
assumed to be 0.  */
  BFD_RELOC_D10V_10_PCREL_R,

/* Mitsubishi D10V relocs.
This is a 10-bit reloc with the right 2 bits
assumed to be 0.  This is the same as the previous reloc
except it is in the left container, i.e.,
shifted left 15 bits.  */
  BFD_RELOC_D10V_10_PCREL_L,

/* This is an 18-bit reloc with the right 2 bits
assumed to be 0.  */
  BFD_RELOC_D10V_18,

/* This is an 18-bit reloc with the right 2 bits
assumed to be 0.  */
  BFD_RELOC_D10V_18_PCREL,

/* Mitsubishi D30V relocs.
This is a 6-bit absolute reloc.  */
  BFD_RELOC_D30V_6,

/* This is a 6-bit pc-relative reloc with
the right 3 bits assumed to be 0.  */
  BFD_RELOC_D30V_9_PCREL,

/* This is a 6-bit pc-relative reloc with
the right 3 bits assumed to be 0. Same
as the previous reloc but on the right side
of the container.  */
  BFD_RELOC_D30V_9_PCREL_R,

/* This is a 12-bit absolute reloc with the
right 3 bitsassumed to be 0.  */
  BFD_RELOC_D30V_15,

/* This is a 12-bit pc-relative reloc with
the right 3 bits assumed to be 0.  */
  BFD_RELOC_D30V_15_PCREL,

/* This is a 12-bit pc-relative reloc with
the right 3 bits assumed to be 0. Same
as the previous reloc but on the right side
of the container.  */
  BFD_RELOC_D30V_15_PCREL_R,

/* This is an 18-bit absolute reloc with
the right 3 bits assumed to be 0.  */
  BFD_RELOC_D30V_21,

/* This is an 18-bit pc-relative reloc with
the right 3 bits assumed to be 0.  */
  BFD_RELOC_D30V_21_PCREL,

/* This is an 18-bit pc-relative reloc with
the right 3 bits assumed to be 0. Same
as the previous reloc but on the right side
of the container.  */
  BFD_RELOC_D30V_21_PCREL_R,

/* This is a 32-bit absolute reloc.  */
  BFD_RELOC_D30V_32,

/* This is a 32-bit pc-relative reloc.  */
  BFD_RELOC_D30V_32_PCREL,

/* DLX relocs  */
  BFD_RELOC_DLX_HI16_S,

/* DLX relocs  */
  BFD_RELOC_DLX_LO16,

/* DLX relocs  */
  BFD_RELOC_DLX_JMP26,

/* Renesas M32R (formerly Mitsubishi M32R) relocs.
This is a 24 bit absolute address.  */
  BFD_RELOC_M32R_24,

/* This is a 10-bit pc-relative reloc with the right 2 bits assumed to be 0.  */
  BFD_RELOC_M32R_10_PCREL,

/* This is an 18-bit reloc with the right 2 bits assumed to be 0.  */
  BFD_RELOC_M32R_18_PCREL,

/* This is a 26-bit reloc with the right 2 bits assumed to be 0.  */
  BFD_RELOC_M32R_26_PCREL,

/* This is a 16-bit reloc containing the high 16 bits of an address
used when the lower 16 bits are treated as unsigned.  */
  BFD_RELOC_M32R_HI16_ULO,

/* This is a 16-bit reloc containing the high 16 bits of an address
used when the lower 16 bits are treated as signed.  */
  BFD_RELOC_M32R_HI16_SLO,

/* This is a 16-bit reloc containing the lower 16 bits of an address.  */
  BFD_RELOC_M32R_LO16,

/* This is a 16-bit reloc containing the small data area offset for use in
add3, load, and store instructions.  */
  BFD_RELOC_M32R_SDA16,

/* For PIC.  */
  BFD_RELOC_M32R_GOT24,
  BFD_RELOC_M32R_26_PLTREL,
  BFD_RELOC_M32R_COPY,
  BFD_RELOC_M32R_GLOB_DAT,
  BFD_RELOC_M32R_JMP_SLOT,
  BFD_RELOC_M32R_RELATIVE,
  BFD_RELOC_M32R_GOTOFF,
  BFD_RELOC_M32R_GOTPC24,
  BFD_RELOC_M32R_GOT16_HI_ULO,
  BFD_RELOC_M32R_GOT16_HI_SLO,
  BFD_RELOC_M32R_GOT16_LO,
  BFD_RELOC_M32R_GOTPC_HI_ULO,
  BFD_RELOC_M32R_GOTPC_HI_SLO,
  BFD_RELOC_M32R_GOTPC_LO,

/* This is a 9-bit reloc  */
  BFD_RELOC_V850_9_PCREL,

/* This is a 22-bit reloc  */
  BFD_RELOC_V850_22_PCREL,

/* This is a 16 bit offset from the short data area pointer.  */
  BFD_RELOC_V850_SDA_16_16_OFFSET,

/* This is a 16 bit offset (of which only 15 bits are used) from the
short data area pointer.  */
  BFD_RELOC_V850_SDA_15_16_OFFSET,

/* This is a 16 bit offset from the zero data area pointer.  */
  BFD_RELOC_V850_ZDA_16_16_OFFSET,

/* This is a 16 bit offset (of which only 15 bits are used) from the
zero data area pointer.  */
  BFD_RELOC_V850_ZDA_15_16_OFFSET,

/* This is an 8 bit offset (of which only 6 bits are used) from the
tiny data area pointer.  */
  BFD_RELOC_V850_TDA_6_8_OFFSET,

/* This is an 8bit offset (of which only 7 bits are used) from the tiny
data area pointer.  */
  BFD_RELOC_V850_TDA_7_8_OFFSET,

/* This is a 7 bit offset from the tiny data area pointer.  */
  BFD_RELOC_V850_TDA_7_7_OFFSET,

/* This is a 16 bit offset from the tiny data area pointer.  */
  BFD_RELOC_V850_TDA_16_16_OFFSET,

/* This is a 5 bit offset (of which only 4 bits are used) from the tiny
data area pointer.  */
  BFD_RELOC_V850_TDA_4_5_OFFSET,

/* This is a 4 bit offset from the tiny data area pointer.  */
  BFD_RELOC_V850_TDA_4_4_OFFSET,

/* This is a 16 bit offset from the short data area pointer, with the
bits placed non-contiguously in the instruction.  */
  BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET,

/* This is a 16 bit offset from the zero data area pointer, with the
bits placed non-contiguously in the instruction.  */
  BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET,

/* This is a 6 bit offset from the call table base pointer.  */
  BFD_RELOC_V850_CALLT_6_7_OFFSET,

/* This is a 16 bit offset from the call table base pointer.  */
  BFD_RELOC_V850_CALLT_16_16_OFFSET,

/* Used for relaxing indirect function calls.  */
  BFD_RELOC_V850_LONGCALL,

/* Used for relaxing indirect jumps.  */
  BFD_RELOC_V850_LONGJUMP,

/* Used to maintain alignment whilst relaxing.  */
  BFD_RELOC_V850_ALIGN,

/* This is a 32bit pcrel reloc for the mn10300, offset by two bytes in the
instruction.  */
  BFD_RELOC_MN10300_32_PCREL,

/* This is a 16bit pcrel reloc for the mn10300, offset by two bytes in the
instruction.  */
  BFD_RELOC_MN10300_16_PCREL,

/* This is a 8bit DP reloc for the tms320c30, where the most
significant 8 bits of a 24 bit word are placed into the least
significant 8 bits of the opcode.  */
  BFD_RELOC_TIC30_LDP,

/* This is a 7bit reloc for the tms320c54x, where the least
significant 7 bits of a 16 bit word are placed into the least
significant 7 bits of the opcode.  */
  BFD_RELOC_TIC54X_PARTLS7,

/* This is a 9bit DP reloc for the tms320c54x, where the most
significant 9 bits of a 16 bit word are placed into the least
significant 9 bits of the opcode.  */
  BFD_RELOC_TIC54X_PARTMS9,

/* This is an extended address 23-bit reloc for the tms320c54x.  */
  BFD_RELOC_TIC54X_23,

/* This is a 16-bit reloc for the tms320c54x, where the least
significant 16 bits of a 23-bit extended address are placed into
the opcode.  */
  BFD_RELOC_TIC54X_16_OF_23,

/* This is a reloc for the tms320c54x, where the most
significant 7 bits of a 23-bit extended address are placed into
the opcode.  */
  BFD_RELOC_TIC54X_MS7_OF_23,

/* This is a 48 bit reloc for the FR30 that stores 32 bits.  */
  BFD_RELOC_FR30_48,

/* This is a 32 bit reloc for the FR30 that stores 20 bits split up into
two sections.  */
  BFD_RELOC_FR30_20,

/* This is a 16 bit reloc for the FR30 that stores a 6 bit word offset in
4 bits.  */
  BFD_RELOC_FR30_6_IN_4,

/* This is a 16 bit reloc for the FR30 that stores an 8 bit byte offset
into 8 bits.  */
  BFD_RELOC_FR30_8_IN_8,

/* This is a 16 bit reloc for the FR30 that stores a 9 bit short offset
into 8 bits.  */
  BFD_RELOC_FR30_9_IN_8,

/* This is a 16 bit reloc for the FR30 that stores a 10 bit word offset
into 8 bits.  */
  BFD_RELOC_FR30_10_IN_8,

/* This is a 16 bit reloc for the FR30 that stores a 9 bit pc relative
short offset into 8 bits.  */
  BFD_RELOC_FR30_9_PCREL,

/* This is a 16 bit reloc for the FR30 that stores a 12 bit pc relative
short offset into 11 bits.  */
  BFD_RELOC_FR30_12_PCREL,

/* Motorola Mcore relocations.  */
  BFD_RELOC_MCORE_PCREL_IMM8BY4,
  BFD_RELOC_MCORE_PCREL_IMM11BY2,
  BFD_RELOC_MCORE_PCREL_IMM4BY2,
  BFD_RELOC_MCORE_PCREL_32,
  BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2,
  BFD_RELOC_MCORE_RVA,

/* These are relocations for the GETA instruction.  */
  BFD_RELOC_MMIX_GETA,
  BFD_RELOC_MMIX_GETA_1,
  BFD_RELOC_MMIX_GETA_2,
  BFD_RELOC_MMIX_GETA_3,

/* These are relocations for a conditional branch instruction.  */
  BFD_RELOC_MMIX_CBRANCH,
  BFD_RELOC_MMIX_CBRANCH_J,
  BFD_RELOC_MMIX_CBRANCH_1,
  BFD_RELOC_MMIX_CBRANCH_2,
  BFD_RELOC_MMIX_CBRANCH_3,

/* These are relocations for the PUSHJ instruction.  */
  BFD_RELOC_MMIX_PUSHJ,
  BFD_RELOC_MMIX_PUSHJ_1,
  BFD_RELOC_MMIX_PUSHJ_2,
  BFD_RELOC_MMIX_PUSHJ_3,
  BFD_RELOC_MMIX_PUSHJ_STUBBABLE,

/* These are relocations for the JMP instruction.  */
  BFD_RELOC_MMIX_JMP,
  BFD_RELOC_MMIX_JMP_1,
  BFD_RELOC_MMIX_JMP_2,
  BFD_RELOC_MMIX_JMP_3,

/* This is a relocation for a relative address as in a GETA instruction or
a branch.  */
  BFD_RELOC_MMIX_ADDR19,

/* This is a relocation for a relative address as in a JMP instruction.  */
  BFD_RELOC_MMIX_ADDR27,

/* This is a relocation for an instruction field that may be a general
register or a value 0..255.  */
  BFD_RELOC_MMIX_REG_OR_BYTE,

/* This is a relocation for an instruction field that may be a general
register.  */
  BFD_RELOC_MMIX_REG,

/* This is a relocation for two instruction fields holding a register and
an offset, the equivalent of the relocation.  */
  BFD_RELOC_MMIX_BASE_PLUS_OFFSET,

/* This relocation is an assertion that the expression is not allocated as
a global register.  It does not modify contents.  */
  BFD_RELOC_MMIX_LOCAL,

/* This is a 16 bit reloc for the AVR that stores 8 bit pc relative
short offset into 7 bits.  */
  BFD_RELOC_AVR_7_PCREL,

/* This is a 16 bit reloc for the AVR that stores 13 bit pc relative
short offset into 12 bits.  */
  BFD_RELOC_AVR_13_PCREL,

/* This is a 16 bit reloc for the AVR that stores 17 bit value (usually
program memory address) into 16 bits.  */
  BFD_RELOC_AVR_16_PM,

/* This is a 16 bit reloc for the AVR that stores 8 bit value (usually
data memory address) into 8 bit immediate value of LDI insn.  */
  BFD_RELOC_AVR_LO8_LDI,

/* This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
of data memory address) into 8 bit immediate value of LDI insn.  */
  BFD_RELOC_AVR_HI8_LDI,

/* This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
of program memory address) into 8 bit immediate value of LDI insn.  */
  BFD_RELOC_AVR_HH8_LDI,

/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
(usually data memory address) into 8 bit immediate value of SUBI insn.  */
  BFD_RELOC_AVR_LO8_LDI_NEG,

/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
(high 8 bit of data memory address) into 8 bit immediate value of
SUBI insn.  */
  BFD_RELOC_AVR_HI8_LDI_NEG,

/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
(most high 8 bit of program memory address) into 8 bit immediate value
of LDI or SUBI insn.  */
  BFD_RELOC_AVR_HH8_LDI_NEG,

/* This is a 16 bit reloc for the AVR that stores 8 bit value (usually
command address) into 8 bit immediate value of LDI insn.  */
  BFD_RELOC_AVR_LO8_LDI_PM,

/* This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
of command address) into 8 bit immediate value of LDI insn.  */
  BFD_RELOC_AVR_HI8_LDI_PM,

/* This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
of command address) into 8 bit immediate value of LDI insn.  */
  BFD_RELOC_AVR_HH8_LDI_PM,

/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
(usually command address) into 8 bit immediate value of SUBI insn.  */
  BFD_RELOC_AVR_LO8_LDI_PM_NEG,

/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
(high 8 bit of 16 bit command address) into 8 bit immediate value
of SUBI insn.  */
  BFD_RELOC_AVR_HI8_LDI_PM_NEG,

/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
(high 6 bit of 22 bit command address) into 8 bit immediate
value of SUBI insn.  */
  BFD_RELOC_AVR_HH8_LDI_PM_NEG,

/* This is a 32 bit reloc for the AVR that stores 23 bit value
into 22 bits.  */
  BFD_RELOC_AVR_CALL,

/* Direct 12 bit.  */
  BFD_RELOC_390_12,

/* 12 bit GOT offset.  */
  BFD_RELOC_390_GOT12,

/* 32 bit PC relative PLT address.  */
  BFD_RELOC_390_PLT32,

/* Copy symbol at runtime.  */
  BFD_RELOC_390_COPY,

/* Create GOT entry.  */
  BFD_RELOC_390_GLOB_DAT,

/* Create PLT entry.  */
  BFD_RELOC_390_JMP_SLOT,

/* Adjust by program base.  */
  BFD_RELOC_390_RELATIVE,

/* 32 bit PC relative offset to GOT.  */
  BFD_RELOC_390_GOTPC,

/* 16 bit GOT offset.  */
  BFD_RELOC_390_GOT16,

/* PC relative 16 bit shifted by 1.  */
  BFD_RELOC_390_PC16DBL,

/* 16 bit PC rel. PLT shifted by 1.  */
  BFD_RELOC_390_PLT16DBL,

/* PC relative 32 bit shifted by 1.  */
  BFD_RELOC_390_PC32DBL,

/* 32 bit PC rel. PLT shifted by 1.  */
  BFD_RELOC_390_PLT32DBL,

/* 32 bit PC rel. GOT shifted by 1.  */
  BFD_RELOC_390_GOTPCDBL,

/* 64 bit GOT offset.  */
  BFD_RELOC_390_GOT64,

/* 64 bit PC relative PLT address.  */
  BFD_RELOC_390_PLT64,

/* 32 bit rel. offset to GOT entry.  */
  BFD_RELOC_390_GOTENT,

/* 64 bit offset to GOT.  */
  BFD_RELOC_390_GOTOFF64,

/* 12-bit offset to symbol-entry within GOT, with PLT handling.  */
  BFD_RELOC_390_GOTPLT12,

/* 16-bit offset to symbol-entry within GOT, with PLT handling.  */
  BFD_RELOC_390_GOTPLT16,

/* 32-bit offset to symbol-entry within GOT, with PLT handling.  */
  BFD_RELOC_390_GOTPLT32,

/* 64-bit offset to symbol-entry within GOT, with PLT handling.  */
  BFD_RELOC_390_GOTPLT64,

/* 32-bit rel. offset to symbol-entry within GOT, with PLT handling.  */
  BFD_RELOC_390_GOTPLTENT,

/* 16-bit rel. offset from the GOT to a PLT entry.  */
  BFD_RELOC_390_PLTOFF16,

/* 32-bit rel. offset from the GOT to a PLT entry.  */
  BFD_RELOC_390_PLTOFF32,

/* 64-bit rel. offset from the GOT to a PLT entry.  */
  BFD_RELOC_390_PLTOFF64,

/* s390 tls relocations.  */
  BFD_RELOC_390_TLS_LOAD,
  BFD_RELOC_390_TLS_GDCALL,
  BFD_RELOC_390_TLS_LDCALL,
  BFD_RELOC_390_TLS_GD32,
  BFD_RELOC_390_TLS_GD64,
  BFD_RELOC_390_TLS_GOTIE12,
  BFD_RELOC_390_TLS_GOTIE32,
  BFD_RELOC_390_TLS_GOTIE64,
  BFD_RELOC_390_TLS_LDM32,
  BFD_RELOC_390_TLS_LDM64,
  BFD_RELOC_390_TLS_IE32,
  BFD_RELOC_390_TLS_IE64,
  BFD_RELOC_390_TLS_IEENT,
  BFD_RELOC_390_TLS_LE32,
  BFD_RELOC_390_TLS_LE64,
  BFD_RELOC_390_TLS_LDO32,
  BFD_RELOC_390_TLS_LDO64,
  BFD_RELOC_390_TLS_DTPMOD,
  BFD_RELOC_390_TLS_DTPOFF,
  BFD_RELOC_390_TLS_TPOFF,

/* Long displacement extension.  */
  BFD_RELOC_390_20,
  BFD_RELOC_390_GOT20,
  BFD_RELOC_390_GOTPLT20,
  BFD_RELOC_390_TLS_GOTIE20,

/* Scenix IP2K - 9-bit register number / data address  */
  BFD_RELOC_IP2K_FR9,

/* Scenix IP2K - 4-bit register/data bank number  */
  BFD_RELOC_IP2K_BANK,

/* Scenix IP2K - low 13 bits of instruction word address  */
  BFD_RELOC_IP2K_ADDR16CJP,

/* Scenix IP2K - high 3 bits of instruction word address  */
  BFD_RELOC_IP2K_PAGE3,

/* Scenix IP2K - ext/low/high 8 bits of data address  */
  BFD_RELOC_IP2K_LO8DATA,
  BFD_RELOC_IP2K_HI8DATA,
  BFD_RELOC_IP2K_EX8DATA,

/* Scenix IP2K - low/high 8 bits of instruction word address  */
  BFD_RELOC_IP2K_LO8INSN,
  BFD_RELOC_IP2K_HI8INSN,

/* Scenix IP2K - even/odd PC modifier to modify snb pcl.0  */
  BFD_RELOC_IP2K_PC_SKIP,

/* Scenix IP2K - 16 bit word address in text section.  */
  BFD_RELOC_IP2K_TEXT,

/* Scenix IP2K - 7-bit sp or dp offset  */
  BFD_RELOC_IP2K_FR_OFFSET,

/* Scenix VPE4K coprocessor - data/insn-space addressing  */
  BFD_RELOC_VPE4KMATH_DATA,
  BFD_RELOC_VPE4KMATH_INSN,

/* These two relocations are used by the linker to determine which of
the entries in a C++ virtual function table are actually used.  When
the --gc-sections option is given, the linker will zero out the entries
that are not used, so that the code for those functions need not be
included in the output.

VTABLE_INHERIT is a zero-space relocation used to describe to the
linker the inheritance tree of a C++ virtual function table.  The
relocation's symbol should be the parent class' vtable, and the
relocation should be located at the child vtable.

VTABLE_ENTRY is a zero-space relocation that describes the use of a
virtual function table entry.  The reloc's symbol should refer to the
table of the class mentioned in the code.  Off of that base, an offset
describes the entry that is being used.  For Rela hosts, this offset
is stored in the reloc's addend.  For Rel hosts, we are forced to put
this offset in the reloc's section offset.  */
  BFD_RELOC_VTABLE_INHERIT,
  BFD_RELOC_VTABLE_ENTRY,

/* Intel IA64 Relocations.  */
  BFD_RELOC_IA64_IMM14,
  BFD_RELOC_IA64_IMM22,
  BFD_RELOC_IA64_IMM64,
  BFD_RELOC_IA64_DIR32MSB,
  BFD_RELOC_IA64_DIR32LSB,
  BFD_RELOC_IA64_DIR64MSB,
  BFD_RELOC_IA64_DIR64LSB,
  BFD_RELOC_IA64_GPREL22,
  BFD_RELOC_IA64_GPREL64I,
  BFD_RELOC_IA64_GPREL32MSB,
  BFD_RELOC_IA64_GPREL32LSB,
  BFD_RELOC_IA64_GPREL64MSB,
  BFD_RELOC_IA64_GPREL64LSB,
  BFD_RELOC_IA64_LTOFF22,
  BFD_RELOC_IA64_LTOFF64I,
  BFD_RELOC_IA64_PLTOFF22,
  BFD_RELOC_IA64_PLTOFF64I,
  BFD_RELOC_IA64_PLTOFF64MSB,
  BFD_RELOC_IA64_PLTOFF64LSB,
  BFD_RELOC_IA64_FPTR64I,
  BFD_RELOC_IA64_FPTR32MSB,
  BFD_RELOC_IA64_FPTR32LSB,
  BFD_RELOC_IA64_FPTR64MSB,
  BFD_RELOC_IA64_FPTR64LSB,
  BFD_RELOC_IA64_PCREL21B,
  BFD_RELOC_IA64_PCREL21BI,
  BFD_RELOC_IA64_PCREL21M,
  BFD_RELOC_IA64_PCREL21F,
  BFD_RELOC_IA64_PCREL22,
  BFD_RELOC_IA64_PCREL60B,
  BFD_RELOC_IA64_PCREL64I,
  BFD_RELOC_IA64_PCREL32MSB,
  BFD_RELOC_IA64_PCREL32LSB,
  BFD_RELOC_IA64_PCREL64MSB,
  BFD_RELOC_IA64_PCREL64LSB,
  BFD_RELOC_IA64_LTOFF_FPTR22,
  BFD_RELOC_IA64_LTOFF_FPTR64I,
  BFD_RELOC_IA64_LTOFF_FPTR32MSB,
  BFD_RELOC_IA64_LTOFF_FPTR32LSB,
  BFD_RELOC_IA64_LTOFF_FPTR64MSB,
  BFD_RELOC_IA64_LTOFF_FPTR64LSB,
  BFD_RELOC_IA64_SEGREL32MSB,
  BFD_RELOC_IA64_SEGREL32LSB,
  BFD_RELOC_IA64_SEGREL64MSB,
  BFD_RELOC_IA64_SEGREL64LSB,
  BFD_RELOC_IA64_SECREL32MSB,
  BFD_RELOC_IA64_SECREL32LSB,
  BFD_RELOC_IA64_SECREL64MSB,
  BFD_RELOC_IA64_SECREL64LSB,
  BFD_RELOC_IA64_REL32MSB,
  BFD_RELOC_IA64_REL32LSB,
  BFD_RELOC_IA64_REL64MSB,
  BFD_RELOC_IA64_REL64LSB,
  BFD_RELOC_IA64_LTV32MSB,
  BFD_RELOC_IA64_LTV32LSB,
  BFD_RELOC_IA64_LTV64MSB,
  BFD_RELOC_IA64_LTV64LSB,
  BFD_RELOC_IA64_IPLTMSB,
  BFD_RELOC_IA64_IPLTLSB,
  BFD_RELOC_IA64_COPY,
  BFD_RELOC_IA64_LTOFF22X,
  BFD_RELOC_IA64_LDXMOV,
  BFD_RELOC_IA64_TPREL14,
  BFD_RELOC_IA64_TPREL22,
  BFD_RELOC_IA64_TPREL64I,
  BFD_RELOC_IA64_TPREL64MSB,
  BFD_RELOC_IA64_TPREL64LSB,
  BFD_RELOC_IA64_LTOFF_TPREL22,
  BFD_RELOC_IA64_DTPMOD64MSB,
  BFD_RELOC_IA64_DTPMOD64LSB,
  BFD_RELOC_IA64_LTOFF_DTPMOD22,
  BFD_RELOC_IA64_DTPREL14,
  BFD_RELOC_IA64_DTPREL22,
  BFD_RELOC_IA64_DTPREL64I,
  BFD_RELOC_IA64_DTPREL32MSB,
  BFD_RELOC_IA64_DTPREL32LSB,
  BFD_RELOC_IA64_DTPREL64MSB,
  BFD_RELOC_IA64_DTPREL64LSB,
  BFD_RELOC_IA64_LTOFF_DTPREL22,

/* Motorola 68HC11 reloc.
This is the 8 bit high part of an absolute address.  */
  BFD_RELOC_M68HC11_HI8,

/* Motorola 68HC11 reloc.
This is the 8 bit low part of an absolute address.  */
  BFD_RELOC_M68HC11_LO8,

/* Motorola 68HC11 reloc.
This is the 3 bit of a value.  */
  BFD_RELOC_M68HC11_3B,

/* Motorola 68HC11 reloc.
This reloc marks the beginning of a jump/call instruction.
It is used for linker relaxation to correctly identify beginning
of instruction and change some branches to use PC-relative
addressing mode.  */
  BFD_RELOC_M68HC11_RL_JUMP,

/* Motorola 68HC11 reloc.
This reloc marks a group of several instructions that gcc generates
and for which the linker relaxation pass can modify and/or remove
some of them.  */
  BFD_RELOC_M68HC11_RL_GROUP,

/* Motorola 68HC11 reloc.
This is the 16-bit lower part of an address.  It is used for 'call'
instruction to specify the symbol address without any special
transformation (due to memory bank window).  */
  BFD_RELOC_M68HC11_LO16,

/* Motorola 68HC11 reloc.
This is a 8-bit reloc that specifies the page number of an address.
It is used by 'call' instruction to specify the page number of
the symbol.  */
  BFD_RELOC_M68HC11_PAGE,

/* Motorola 68HC11 reloc.
This is a 24-bit reloc that represents the address with a 16-bit
value and a 8-bit page number.  The symbol address is transformed
to follow the 16K memory bank of 68HC12 (seen as mapped in the window).  */
  BFD_RELOC_M68HC11_24,

/* Motorola 68HC12 reloc.
This is the 5 bits of a value.  */
  BFD_RELOC_M68HC12_5B,

/* These relocs are only used within the CRIS assembler.  They are not
(at present) written to any object files.  */
  BFD_RELOC_CRIS_BDISP8,
  BFD_RELOC_CRIS_UNSIGNED_5,
  BFD_RELOC_CRIS_SIGNED_6,
  BFD_RELOC_CRIS_UNSIGNED_6,
  BFD_RELOC_CRIS_UNSIGNED_4,

/* Relocs used in ELF shared libraries for CRIS.  */
  BFD_RELOC_CRIS_COPY,
  BFD_RELOC_CRIS_GLOB_DAT,
  BFD_RELOC_CRIS_JUMP_SLOT,
  BFD_RELOC_CRIS_RELATIVE,

/* 32-bit offset to symbol-entry within GOT.  */
  BFD_RELOC_CRIS_32_GOT,

/* 16-bit offset to symbol-entry within GOT.  */
  BFD_RELOC_CRIS_16_GOT,

/* 32-bit offset to symbol-entry within GOT, with PLT handling.  */
  BFD_RELOC_CRIS_32_GOTPLT,

/* 16-bit offset to symbol-entry within GOT, with PLT handling.  */
  BFD_RELOC_CRIS_16_GOTPLT,

/* 32-bit offset to symbol, relative to GOT.  */
  BFD_RELOC_CRIS_32_GOTREL,

/* 32-bit offset to symbol with PLT entry, relative to GOT.  */
  BFD_RELOC_CRIS_32_PLT_GOTREL,

/* 32-bit offset to symbol with PLT entry, relative to this relocation.  */
  BFD_RELOC_CRIS_32_PLT_PCREL,

/* Intel i860 Relocations.  */
  BFD_RELOC_860_COPY,
  BFD_RELOC_860_GLOB_DAT,
  BFD_RELOC_860_JUMP_SLOT,
  BFD_RELOC_860_RELATIVE,
  BFD_RELOC_860_PC26,
  BFD_RELOC_860_PLT26,
  BFD_RELOC_860_PC16,
  BFD_RELOC_860_LOW0,
  BFD_RELOC_860_SPLIT0,
  BFD_RELOC_860_LOW1,
  BFD_RELOC_860_SPLIT1,
  BFD_RELOC_860_LOW2,
  BFD_RELOC_860_SPLIT2,
  BFD_RELOC_860_LOW3,
  BFD_RELOC_860_LOGOT0,
  BFD_RELOC_860_SPGOT0,
  BFD_RELOC_860_LOGOT1,
  BFD_RELOC_860_SPGOT1,
  BFD_RELOC_860_LOGOTOFF0,
  BFD_RELOC_860_SPGOTOFF0,
  BFD_RELOC_860_LOGOTOFF1,
  BFD_RELOC_860_SPGOTOFF1,
  BFD_RELOC_860_LOGOTOFF2,
  BFD_RELOC_860_LOGOTOFF3,
  BFD_RELOC_860_LOPC,
  BFD_RELOC_860_HIGHADJ,
  BFD_RELOC_860_HAGOT,
  BFD_RELOC_860_HAGOTOFF,
  BFD_RELOC_860_HAPC,
  BFD_RELOC_860_HIGH,
  BFD_RELOC_860_HIGOT,
  BFD_RELOC_860_HIGOTOFF,

/* OpenRISC Relocations.  */
  BFD_RELOC_OPENRISC_ABS_26,
  BFD_RELOC_OPENRISC_REL_26,

/* H8 elf Relocations.  */
  BFD_RELOC_H8_DIR16A8,
  BFD_RELOC_H8_DIR16R8,
  BFD_RELOC_H8_DIR24A8,
  BFD_RELOC_H8_DIR24R8,
  BFD_RELOC_H8_DIR32A16,

/* Sony Xstormy16 Relocations.  */
  BFD_RELOC_XSTORMY16_REL_12,
  BFD_RELOC_XSTORMY16_12,
  BFD_RELOC_XSTORMY16_24,
  BFD_RELOC_XSTORMY16_FPTR16,

/* Relocations used by VAX ELF.  */
  BFD_RELOC_VAX_GLOB_DAT,
  BFD_RELOC_VAX_JMP_SLOT,
  BFD_RELOC_VAX_RELATIVE,

/* msp430 specific relocation codes  */
  BFD_RELOC_MSP430_10_PCREL,
  BFD_RELOC_MSP430_16_PCREL,
  BFD_RELOC_MSP430_16,
  BFD_RELOC_MSP430_16_PCREL_BYTE,
  BFD_RELOC_MSP430_16_BYTE,

/* IQ2000 Relocations.  */
  BFD_RELOC_IQ2000_OFFSET_16,
  BFD_RELOC_IQ2000_OFFSET_21,
  BFD_RELOC_IQ2000_UHI16,

/* Special Xtensa relocation used only by PLT entries in ELF shared
objects to indicate that the runtime linker should set the value
to one of its own internal functions or data structures.  */
  BFD_RELOC_XTENSA_RTLD,

/* Xtensa relocations for ELF shared objects.  */
  BFD_RELOC_XTENSA_GLOB_DAT,
  BFD_RELOC_XTENSA_JMP_SLOT,
  BFD_RELOC_XTENSA_RELATIVE,

/* Xtensa relocation used in ELF object files for symbols that may require
PLT entries.  Otherwise, this is just a generic 32-bit relocation.  */
  BFD_RELOC_XTENSA_PLT,

/* Generic Xtensa relocations.  Only the operand number is encoded
in the relocation.  The details are determined by extracting the
instruction opcode.  */
  BFD_RELOC_XTENSA_OP0,
  BFD_RELOC_XTENSA_OP1,
  BFD_RELOC_XTENSA_OP2,

/* Xtensa relocation to mark that the assembler expanded the 
instructions from an original target.  The expansion size is
encoded in the reloc size.  */
  BFD_RELOC_XTENSA_ASM_EXPAND,

/* Xtensa relocation to mark that the linker should simplify 
assembler-expanded instructions.  This is commonly used 
internally by the linker after analysis of a 
BFD_RELOC_XTENSA_ASM_EXPAND.  */
  BFD_RELOC_XTENSA_ASM_SIMPLIFY,
  BFD_RELOC_UNUSED };
typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
reloc_howto_type *bfd_reloc_type_lookup
   (bfd *abfd, bfd_reloc_code_real_type code);

const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);

/* Extracted from syms.c.  */

typedef struct bfd_symbol
{
  /* A pointer to the BFD which owns the symbol. This information
     is necessary so that a back end can work out what additional
     information (invisible to the application writer) is carried
     with the symbol.

     This field is *almost* redundant, since you can use section->owner
     instead, except that some symbols point to the global sections
     bfd_{abs,com,und}_section.  This could be fixed by making
     these globals be per-bfd (or per-target-flavor).  FIXME.  */
  struct bfd *the_bfd; /* Use bfd_asymbol_bfd(sym) to access this field.  */

  /* The text of the symbol. The name is left alone, and not copied; the
     application may not alter it.  */
  const char *name;

  /* The value of the symbol.  This really should be a union of a
     numeric value with a pointer, since some flags indicate that
     a pointer to another symbol is stored here.  */
  symvalue value;

  /* Attributes of a symbol.  */
#define BSF_NO_FLAGS    0x00

  /* The symbol has local scope; <<static>> in <<C>>. The value
     is the offset into the section of the data.  */
#define BSF_LOCAL      0x01

  /* The symbol has global scope; initialized data in <<C>>. The
     value is the offset into the section of the data.  */
#define BSF_GLOBAL     0x02

  /* The symbol has global scope and is exported. The value is
     the offset into the section of the data.  */
#define BSF_EXPORT     BSF_GLOBAL /* No real difference.  */

  /* A normal C symbol would be one of:
     <<BSF_LOCAL>>, <<BSF_FORT_COMM>>,  <<BSF_UNDEFINED>> or
     <<BSF_GLOBAL>>.  */

  /* The symbol is a debugging record. The value has an arbitrary
     meaning, unless BSF_DEBUGGING_RELOC is also set.  */
#define BSF_DEBUGGING  0x08

  /* The symbol denotes a function entry point.  Used in ELF,
     perhaps others someday.  */
#define BSF_FUNCTION    0x10

  /* Used by the linker.  */
#define BSF_KEEP        0x20
#define BSF_KEEP_G      0x40

  /* A weak global symbol, overridable without warnings by
     a regular global symbol of the same name.  */
#define BSF_WEAK        0x80

  /* This symbol was created to point to a section, e.g. ELF's
     STT_SECTION symbols.  */
#define BSF_SECTION_SYM 0x100

  /* The symbol used to be a common symbol, but now it is
     allocated.  */
#define BSF_OLD_COMMON  0x200

  /* The default value for common data.  */
#define BFD_FORT_COMM_DEFAULT_VALUE 0

  /* In some files the type of a symbol sometimes alters its
     location in an output file - ie in coff a <<ISFCN>> symbol
     which is also <<C_EXT>> symbol appears where it was
     declared and not at the end of a section.  This bit is set
     by the target BFD part to convey this information.  */
#define BSF_NOT_AT_END    0x400

  /* Signal that the symbol is the label of constructor section.  */
#define BSF_CONSTRUCTOR   0x800

  /* Signal that the symbol is a warning symbol.  The name is a
     warning.  The name of the next symbol is the one to warn about;
     if a reference is made to a symbol with the same name as the next
     symbol, a warning is issued by the linker.  */
#define BSF_WARNING       0x1000

  /* Signal that the symbol is indirect.  This symbol is an indirect
     pointer to the symbol with the same name as the next symbol.  */
#define BSF_INDIRECT      0x2000

  /* BSF_FILE marks symbols that contain a file name.  This is used
     for ELF STT_FILE symbols.  */
#define BSF_FILE          0x4000

  /* Symbol is from dynamic linking information.  */
#define BSF_DYNAMIC       0x8000

  /* The symbol denotes a data object.  Used in ELF, and perhaps
     others someday.  */
#define BSF_OBJECT        0x10000

  /* This symbol is a debugging symbol.  The value is the offset
     into the section of the data.  BSF_DEBUGGING should be set
     as well.  */
#define BSF_DEBUGGING_RELOC 0x20000

  /* This symbol is thread local.  Used in ELF.  */
#define BSF_THREAD_LOCAL  0x40000

  flagword flags;

  /* A pointer to the section to which this symbol is
     relative.  This will always be non NULL, there are special
     sections for undefined and absolute symbols.  */
  struct bfd_section *section;

  /* Back end special data.  */
  union
    {
      void *p;
      bfd_vma i;
    }
  udata;
}
asymbol;

#define bfd_get_symtab_upper_bound(abfd) \
     BFD_SEND (abfd, _bfd_get_symtab_upper_bound, (abfd))

bfd_boolean bfd_is_local_label (bfd *abfd, asymbol *sym);

bfd_boolean bfd_is_local_label_name (bfd *abfd, const char *name);

#define bfd_is_local_label_name(abfd, name) \
  BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name))

#define bfd_canonicalize_symtab(abfd, location) \
  BFD_SEND (abfd, _bfd_canonicalize_symtab, (abfd, location))

bfd_boolean bfd_set_symtab
   (bfd *abfd, asymbol **location, unsigned int count);

void bfd_print_symbol_vandf (bfd *abfd, void *file, asymbol *symbol);

#define bfd_make_empty_symbol(abfd) \
  BFD_SEND (abfd, _bfd_make_empty_symbol, (abfd))

asymbol *_bfd_generic_make_empty_symbol (bfd *);

#define bfd_make_debug_symbol(abfd,ptr,size) \
  BFD_SEND (abfd, _bfd_make_debug_symbol, (abfd, ptr, size))

int bfd_decode_symclass (asymbol *symbol);

bfd_boolean bfd_is_undefined_symclass (int symclass);

void bfd_symbol_info (asymbol *symbol, symbol_info *ret);

bfd_boolean bfd_copy_private_symbol_data
   (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);

#define bfd_copy_private_symbol_data(ibfd, isymbol, obfd, osymbol) \
  BFD_SEND (obfd, _bfd_copy_private_symbol_data, \
            (ibfd, isymbol, obfd, osymbol))

/* Extracted from bfd.c.  */
struct bfd
{
  /* A unique identifier of the BFD  */
  unsigned int id;

  /* The filename the application opened the BFD with.  */
  const char *filename;

  /* A pointer to the target jump table.  */
  const struct bfd_target *xvec;

  /* To avoid dragging too many header files into every file that
     includes `<<bfd.h>>', IOSTREAM has been declared as a "void *".
     Its correct type, to which it's cast when used, is "FILE *". The
     iostream is the result of an fopen on the filename.  However, if
     the BFD_IN_MEMORY flag is set, then iostream is actually a pointer
     to a bfd_in_memory struct.  */
  void *iostream;

  /* Is the file descriptor being cached?  That is, can it be closed as
     needed, and re-opened when accessed later?  */
  bfd_boolean cacheable;

  /* Marks whether there was a default target specified when the
     BFD was opened. This is used to select which matching algorithm
     to use to choose the back end.  */
  bfd_boolean target_defaulted;

  /* The caching routines use these to maintain a
     least-recently-used list of BFDs.  */
  struct bfd *lru_prev, *lru_next;

  /* When a file is closed by the caching routines, BFD retains
     state information on the file here...  */
  ufile_ptr where;

  /* ... and here: (``once'' means at least once).  */
  bfd_boolean opened_once;

  /* Set if we have a locally maintained mtime value, rather than
     getting it from the file each time.  */
  bfd_boolean mtime_set;

  /* File modified time, if mtime_set is TRUE.  */
  time_t mtime;

  /* Reserved for an unimplemented file locking extension.  */
  int ifd;

  /* The format which belongs to the BFD. (object, core, etc.)  */
  bfd_format format;

  /* The direction with which the BFD was opened.  */
  enum bfd_direction
    {
      no_direction = 0,
      read_direction = 1,
      write_direction = 2,
      both_direction = 3
    }
  direction;

  /* Format_specific flags.  */
  flagword flags;

  /* Currently my_archive is tested before adding origin to
     anything. I believe that this can become always an add of
     origin, with origin set to 0 for non archive files.  */
  ufile_ptr origin;

  /* Remember when output has begun, to stop strange things
     from happening.  */
  bfd_boolean output_has_begun;

  /* A hash table for section names.  */
  struct bfd_hash_table section_htab;

  /* Pointer to linked list of sections.  */
  struct bfd_section *sections;

  /* The place where we add to the section list.  */
  struct bfd_section **section_tail;

  /* The number of sections.  */
  unsigned int section_count;

  /* Stuff only useful for object files:
     The start address.  */
  bfd_vma start_address;

  /* Used for input and output.  */
  unsigned int symcount;

  /* Symbol table for output BFD (with symcount entries).  */
  struct bfd_symbol  **outsymbols;

  /* Used for slurped dynamic symbol tables.  */
  unsigned int dynsymcount;

  /* Pointer to structure which contains architecture information.  */
  const struct bfd_arch_info *arch_info;

  /* Stuff only useful for archives.  */
  void *arelt_data;
  struct bfd *my_archive;      /* The containing archive BFD.  */
  struct bfd *next;            /* The next BFD in the archive.  */
  struct bfd *archive_head;    /* The first BFD in the archive.  */
  bfd_boolean has_armap;

  /* A chain of BFD structures involved in a link.  */
  struct bfd *link_next;

  /* A field used by _bfd_generic_link_add_archive_symbols.  This will
     be used only for archive elements.  */
  int archive_pass;

  /* Used by the back end to hold private data.  */
  union
    {
      struct aout_data_struct *aout_data;
      struct artdata *aout_ar_data;
      struct _oasys_data *oasys_obj_data;
      struct _oasys_ar_data *oasys_ar_data;
      struct coff_tdata *coff_obj_data;
      struct pe_tdata *pe_obj_data;
      struct xcoff_tdata *xcoff_obj_data;
      struct ecoff_tdata *ecoff_obj_data;
      struct ieee_data_struct *ieee_data;
      struct ieee_ar_data_struct *ieee_ar_data;
      struct srec_data_struct *srec_data;
      struct ihex_data_struct *ihex_data;
      struct tekhex_data_struct *tekhex_data;
      struct elf_obj_tdata *elf_obj_data;
      struct nlm_obj_tdata *nlm_obj_data;
      struct bout_data_struct *bout_data;
      struct mmo_data_struct *mmo_data;
      struct sun_core_struct *sun_core_data;
      struct sco5_core_struct *sco5_core_data;
      struct trad_core_struct *trad_core_data;
      struct som_data_struct *som_data;
      struct hpux_core_struct *hpux_core_data;
      struct hppabsd_core_struct *hppabsd_core_data;
      struct sgi_core_struct *sgi_core_data;
      struct lynx_core_struct *lynx_core_data;
      struct osf_core_struct *osf_core_data;
      struct cisco_core_struct *cisco_core_data;
      struct versados_data_struct *versados_data;
      struct netbsd_core_struct *netbsd_core_data;
      struct mach_o_data_struct *mach_o_data;
      struct mach_o_fat_data_struct *mach_o_fat_data;
      struct bfd_pef_data_struct *pef_data;
      struct bfd_pef_xlib_data_struct *pef_xlib_data;
      struct bfd_sym_data_struct *sym_data;
      void *any;
    }
  tdata;

  /* Used by the application to hold private data.  */
  void *usrdata;

  /* Where all the allocated stuff under this BFD goes.  This is a
     struct objalloc *, but we use void * to avoid requiring the inclusion
     of objalloc.h.  */
  void *memory;
};

typedef enum bfd_error
{
  bfd_error_no_error = 0,
  bfd_error_system_call,
  bfd_error_invalid_target,
  bfd_error_wrong_format,
  bfd_error_wrong_object_format,
  bfd_error_invalid_operation,
  bfd_error_no_memory,
  bfd_error_no_symbols,
  bfd_error_no_armap,
  bfd_error_no_more_archived_files,
  bfd_error_malformed_archive,
  bfd_error_file_not_recognized,
  bfd_error_file_ambiguously_recognized,
  bfd_error_no_contents,
  bfd_error_nonrepresentable_section,
  bfd_error_no_debug_section,
  bfd_error_bad_value,
  bfd_error_file_truncated,
  bfd_error_file_too_big,
  bfd_error_invalid_error_code
}
bfd_error_type;

bfd_error_type bfd_get_error (void);

void bfd_set_error (bfd_error_type error_tag);

const char *bfd_errmsg (bfd_error_type error_tag);

void bfd_perror (const char *message);

typedef void (*bfd_error_handler_type) (const char *, ...);

bfd_error_handler_type bfd_set_error_handler (bfd_error_handler_type);

void bfd_set_error_program_name (const char *);

bfd_error_handler_type bfd_get_error_handler (void);

const char *bfd_archive_filename (bfd *);

long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);

long bfd_canonicalize_reloc
   (bfd *abfd, asection *sec, arelent **loc, asymbol **syms);

void bfd_set_reloc
   (bfd *abfd, asection *sec, arelent **rel, unsigned int count);

bfd_boolean bfd_set_file_flags (bfd *abfd, flagword flags);

int bfd_get_arch_size (bfd *abfd);

int bfd_get_sign_extend_vma (bfd *abfd);

bfd_boolean bfd_set_start_address (bfd *abfd, bfd_vma vma);

unsigned int bfd_get_gp_size (bfd *abfd);

void bfd_set_gp_size (bfd *abfd, unsigned int i);

bfd_vma bfd_scan_vma (const char *string, const char **end, int base);

bfd_boolean bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);

#define bfd_copy_private_bfd_data(ibfd, obfd) \
     BFD_SEND (obfd, _bfd_copy_private_bfd_data, \
               (ibfd, obfd))
bfd_boolean bfd_merge_private_bfd_data (bfd *ibfd, bfd *obfd);

#define bfd_merge_private_bfd_data(ibfd, obfd) \
     BFD_SEND (obfd, _bfd_merge_private_bfd_data, \
               (ibfd, obfd))
bfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);

#define bfd_set_private_flags(abfd, flags) \
     BFD_SEND (abfd, _bfd_set_private_flags, (abfd, flags))
#define bfd_sizeof_headers(abfd, reloc) \
       BFD_SEND (abfd, _bfd_sizeof_headers, (abfd, reloc))

#define bfd_find_nearest_line(abfd, sec, syms, off, file, func, line) \
       BFD_SEND (abfd, _bfd_find_nearest_line, \
                 (abfd, sec, syms, off, file, func, line))

#define bfd_debug_info_start(abfd) \
       BFD_SEND (abfd, _bfd_debug_info_start, (abfd))

#define bfd_debug_info_end(abfd) \
       BFD_SEND (abfd, _bfd_debug_info_end, (abfd))

#define bfd_debug_info_accumulate(abfd, section) \
       BFD_SEND (abfd, _bfd_debug_info_accumulate, (abfd, section))

#define bfd_stat_arch_elt(abfd, stat) \
       BFD_SEND (abfd, _bfd_stat_arch_elt,(abfd, stat))

#define bfd_update_armap_timestamp(abfd) \
       BFD_SEND (abfd, _bfd_update_armap_timestamp, (abfd))

#define bfd_set_arch_mach(abfd, arch, mach)\
       BFD_SEND ( abfd, _bfd_set_arch_mach, (abfd, arch, mach))

#define bfd_relax_section(abfd, section, link_info, again) \
       BFD_SEND (abfd, _bfd_relax_section, (abfd, section, link_info, again))

#define bfd_gc_sections(abfd, link_info) \
       BFD_SEND (abfd, _bfd_gc_sections, (abfd, link_info))

#define bfd_merge_sections(abfd, link_info) \
       BFD_SEND (abfd, _bfd_merge_sections, (abfd, link_info))

#define bfd_discard_group(abfd, sec) \
       BFD_SEND (abfd, _bfd_discard_group, (abfd, sec))

#define bfd_link_hash_table_create(abfd) \
       BFD_SEND (abfd, _bfd_link_hash_table_create, (abfd))

#define bfd_link_hash_table_free(abfd, hash) \
       BFD_SEND (abfd, _bfd_link_hash_table_free, (hash))

#define bfd_link_add_symbols(abfd, info) \
       BFD_SEND (abfd, _bfd_link_add_symbols, (abfd, info))

#define bfd_link_just_syms(sec, info) \
       BFD_SEND (abfd, _bfd_link_just_syms, (sec, info))

#define bfd_final_link(abfd, info) \
       BFD_SEND (abfd, _bfd_final_link, (abfd, info))

#define bfd_free_cached_info(abfd) \
       BFD_SEND (abfd, _bfd_free_cached_info, (abfd))

#define bfd_get_dynamic_symtab_upper_bound(abfd) \
       BFD_SEND (abfd, _bfd_get_dynamic_symtab_upper_bound, (abfd))

#define bfd_print_private_bfd_data(abfd, file)\
       BFD_SEND (abfd, _bfd_print_private_bfd_data, (abfd, file))

#define bfd_canonicalize_dynamic_symtab(abfd, asymbols) \
       BFD_SEND (abfd, _bfd_canonicalize_dynamic_symtab, (abfd, asymbols))

#define bfd_get_dynamic_reloc_upper_bound(abfd) \
       BFD_SEND (abfd, _bfd_get_dynamic_reloc_upper_bound, (abfd))

#define bfd_canonicalize_dynamic_reloc(abfd, arels, asyms) \
       BFD_SEND (abfd, _bfd_canonicalize_dynamic_reloc, (abfd, arels, asyms))

extern bfd_byte *bfd_get_relocated_section_contents
  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
   bfd_boolean, asymbol **);

bfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);

struct bfd_preserve
{
  void *marker;
  void *tdata;
  flagword flags;
  const struct bfd_arch_info *arch_info;
  struct bfd_section *sections;
  struct bfd_section **section_tail;
  unsigned int section_count;
  struct bfd_hash_table section_htab;
};

bfd_boolean bfd_preserve_save (bfd *, struct bfd_preserve *);

void bfd_preserve_restore (bfd *, struct bfd_preserve *);

void bfd_preserve_finish (bfd *, struct bfd_preserve *);

/* Extracted from archive.c.  */
symindex bfd_get_next_mapent
   (bfd *abfd, symindex previous, carsym **sym);

bfd_boolean bfd_set_archive_head (bfd *output, bfd *new_head);

bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);

/* Extracted from corefile.c.  */
const char *bfd_core_file_failing_command (bfd *abfd);

int bfd_core_file_failing_signal (bfd *abfd);

bfd_boolean core_file_matches_executable_p
   (bfd *core_bfd, bfd *exec_bfd);

/* Extracted from targets.c.  */
#define BFD_SEND(bfd, message, arglist) \
  ((*((bfd)->xvec->message)) arglist)

#ifdef DEBUG_BFD_SEND
#undef BFD_SEND
#define BFD_SEND(bfd, message, arglist) \
  (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
    ((*((bfd)->xvec->message)) arglist) : \
    (bfd_assert (__FILE__,__LINE__), NULL))
#endif
#define BFD_SEND_FMT(bfd, message, arglist) \
  (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)

#ifdef DEBUG_BFD_SEND
#undef BFD_SEND_FMT
#define BFD_SEND_FMT(bfd, message, arglist) \
  (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
   (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist) : \
   (bfd_assert (__FILE__,__LINE__), NULL))
#endif

enum bfd_flavour
{
  bfd_target_unknown_flavour,
  bfd_target_aout_flavour,
  bfd_target_coff_flavour,
  bfd_target_ecoff_flavour,
  bfd_target_xcoff_flavour,
  bfd_target_elf_flavour,
  bfd_target_ieee_flavour,
  bfd_target_nlm_flavour,
  bfd_target_oasys_flavour,
  bfd_target_tekhex_flavour,
  bfd_target_srec_flavour,
  bfd_target_ihex_flavour,
  bfd_target_som_flavour,
  bfd_target_os9k_flavour,
  bfd_target_versados_flavour,
  bfd_target_msdos_flavour,
  bfd_target_ovax_flavour,
  bfd_target_evax_flavour,
  bfd_target_mmo_flavour,
  bfd_target_mach_o_flavour,
  bfd_target_pef_flavour,
  bfd_target_pef_xlib_flavour,
  bfd_target_sym_flavour
};

enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };

/* Forward declaration.  */
typedef struct bfd_link_info _bfd_link_info;

typedef struct bfd_target
{
  /* Identifies the kind of target, e.g., SunOS4, Ultrix, etc.  */
  char *name;

 /* The "flavour" of a back end is a general indication about
    the contents of a file.  */
  enum bfd_flavour flavour;

  /* The order of bytes within the data area of a file.  */
  enum bfd_endian byteorder;

 /* The order of bytes within the header parts of a file.  */
  enum bfd_endian header_byteorder;

  /* A mask of all the flags which an executable may have set -
     from the set <<BFD_NO_FLAGS>>, <<HAS_RELOC>>, ...<<D_PAGED>>.  */
  flagword object_flags;

 /* A mask of all the flags which a section may have set - from
    the set <<SEC_NO_FLAGS>>, <<SEC_ALLOC>>, ...<<SET_NEVER_LOAD>>.  */
  flagword section_flags;

 /* The character normally found at the front of a symbol.
    (if any), perhaps `_'.  */
  char symbol_leading_char;

 /* The pad character for file names within an archive header.  */
  char ar_pad_char;

  /* The maximum number of characters in an archive header.  */
  unsigned short ar_max_namelen;

  /* Entries for byte swapping for data. These are different from the
     other entry points, since they don't take a BFD asthe first argument.
     Certain other handlers could do the same.  */
  bfd_uint64_t   (*bfd_getx64) (const void *);
  bfd_int64_t    (*bfd_getx_signed_64) (const void *);
  void           (*bfd_putx64) (bfd_uint64_t, void *);
  bfd_vma        (*bfd_getx32) (const void *);
  bfd_signed_vma (*bfd_getx_signed_32) (const void *);
  void           (*bfd_putx32) (bfd_vma, void *);
  bfd_vma        (*bfd_getx16) (const void *);
  bfd_signed_vma (*bfd_getx_signed_16) (const void *);
  void           (*bfd_putx16) (bfd_vma, void *);

  /* Byte swapping for the headers.  */
  bfd_uint64_t   (*bfd_h_getx64) (const void *);
  bfd_int64_t    (*bfd_h_getx_signed_64) (const void *);
  void           (*bfd_h_putx64) (bfd_uint64_t, void *);
  bfd_vma        (*bfd_h_getx32) (const void *);
  bfd_signed_vma (*bfd_h_getx_signed_32) (const void *);
  void           (*bfd_h_putx32) (bfd_vma, void *);
  bfd_vma        (*bfd_h_getx16) (const void *);
  bfd_signed_vma (*bfd_h_getx_signed_16) (const void *);
  void           (*bfd_h_putx16) (bfd_vma, void *);

  /* Format dependent routines: these are vectors of entry points
     within the target vector structure, one for each format to check.  */

  /* Check the format of a file being read.  Return a <<bfd_target *>> or zero.  */
  const struct bfd_target *(*_bfd_check_format[bfd_type_end]) (bfd *);

  /* Set the format of a file being written.  */
  bfd_boolean (*_bfd_set_format[bfd_type_end]) (bfd *);

  /* Write cached information into a file being written, at <<bfd_close>>.  */
  bfd_boolean (*_bfd_write_contents[bfd_type_end]) (bfd *);


  /* Generic entry points.  */
#define BFD_JUMP_TABLE_GENERIC(NAME) \
  NAME##_close_and_cleanup, \
  NAME##_bfd_free_cached_info, \
  NAME##_new_section_hook, \
  NAME##_get_section_contents, \
  NAME##_get_section_contents_in_window

  /* Called when the BFD is being closed to do any necessary cleanup.  */
  bfd_boolean (*_close_and_cleanup) (bfd *);
  /* Ask the BFD to free all cached information.  */
  bfd_boolean (*_bfd_free_cached_info) (bfd *);
  /* Called when a new section is created.  */
  bfd_boolean (*_new_section_hook) (bfd *, sec_ptr);
  /* Read the contents of a section.  */
  bfd_boolean (*_bfd_get_section_contents)
    (bfd *, sec_ptr, void *, file_ptr, bfd_size_type);
  bfd_boolean (*_bfd_get_section_contents_in_window)
    (bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type);

  /* Entry points to copy private data.  */
#define BFD_JUMP_TABLE_COPY(NAME) \
  NAME##_bfd_copy_private_bfd_data, \
  NAME##_bfd_merge_private_bfd_data, \
  NAME##_bfd_copy_private_section_data, \
  NAME##_bfd_copy_private_symbol_data, \
  NAME##_bfd_set_private_flags, \
  NAME##_bfd_print_private_bfd_data

  /* Called to copy BFD general private data from one object file
     to another.  */
  bfd_boolean (*_bfd_copy_private_bfd_data) (bfd *, bfd *);
  /* Called to merge BFD general private data from one object file
     to a common output file when linking.  */
  bfd_boolean (*_bfd_merge_private_bfd_data) (bfd *, bfd *);
  /* Called to copy BFD private section data from one object file
     to another.  */
  bfd_boolean (*_bfd_copy_private_section_data)
    (bfd *, sec_ptr, bfd *, sec_ptr);
  /* Called to copy BFD private symbol data from one symbol
     to another.  */
  bfd_boolean (*_bfd_copy_private_symbol_data)
    (bfd *, asymbol *, bfd *, asymbol *);
  /* Called to set private backend flags.  */
  bfd_boolean (*_bfd_set_private_flags) (bfd *, flagword);

  /* Called to print private BFD data.  */
  bfd_boolean (*_bfd_print_private_bfd_data) (bfd *, void *);

  /* Core file entry points.  */
#define BFD_JUMP_TABLE_CORE(NAME) \
  NAME##_core_file_failing_command, \
  NAME##_core_file_failing_signal, \
  NAME##_core_file_matches_executable_p

  char *      (*_core_file_failing_command) (bfd *);
  int         (*_core_file_failing_signal) (bfd *);
  bfd_boolean (*_core_file_matches_executable_p) (bfd *, bfd *);

  /* Archive entry points.  */
#define BFD_JUMP_TABLE_ARCHIVE(NAME) \
  NAME##_slurp_armap, \
  NAME##_slurp_extended_name_table, \
  NAME##_construct_extended_name_table, \
  NAME##_truncate_arname, \
  NAME##_write_armap, \
  NAME##_read_ar_hdr, \
  NAME##_openr_next_archived_file, \
  NAME##_get_elt_at_index, \
  NAME##_generic_stat_arch_elt, \
  NAME##_update_armap_timestamp

  bfd_boolean (*_bfd_slurp_armap) (bfd *);
  bfd_boolean (*_bfd_slurp_extended_name_table) (bfd *);
  bfd_boolean (*_bfd_construct_extended_name_table)
    (bfd *, char **, bfd_size_type *, const char **);
  void        (*_bfd_truncate_arname) (bfd *, const char *, char *);
  bfd_boolean (*write_armap)
    (bfd *, unsigned int, struct orl *, unsigned int, int);
  void *      (*_bfd_read_ar_hdr_fn) (bfd *);
  bfd *       (*openr_next_archived_file) (bfd *, bfd *);
#define bfd_get_elt_at_index(b,i) BFD_SEND (b, _bfd_get_elt_at_index, (b,i))
  bfd *       (*_bfd_get_elt_at_index) (bfd *, symindex);
  int         (*_bfd_stat_arch_elt) (bfd *, struct stat *);
  bfd_boolean (*_bfd_update_armap_timestamp) (bfd *);

  /* Entry points used for symbols.  */
#define BFD_JUMP_TABLE_SYMBOLS(NAME) \
  NAME##_get_symtab_upper_bound, \
  NAME##_canonicalize_symtab, \
  NAME##_make_empty_symbol, \
  NAME##_print_symbol, \
  NAME##_get_symbol_info, \
  NAME##_bfd_is_local_label_name, \
  NAME##_get_lineno, \
  NAME##_find_nearest_line, \
  NAME##_bfd_make_debug_symbol, \
  NAME##_read_minisymbols, \
  NAME##_minisymbol_to_symbol

  long        (*_bfd_get_symtab_upper_bound) (bfd *);
  long        (*_bfd_canonicalize_symtab)
    (bfd *, struct bfd_symbol **);
  struct bfd_symbol *
              (*_bfd_make_empty_symbol) (bfd *);
  void        (*_bfd_print_symbol)
    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type);
#define bfd_print_symbol(b,p,s,e) BFD_SEND (b, _bfd_print_symbol, (b,p,s,e))
  void        (*_bfd_get_symbol_info)
    (bfd *, struct bfd_symbol *, symbol_info *);
#define bfd_get_symbol_info(b,p,e) BFD_SEND (b, _bfd_get_symbol_info, (b,p,e))
  bfd_boolean (*_bfd_is_local_label_name) (bfd *, const char *);

  alent *     (*_get_lineno) (bfd *, struct bfd_symbol *);
  bfd_boolean (*_bfd_find_nearest_line)
    (bfd *, struct bfd_section *, struct bfd_symbol **, bfd_vma,
     const char **, const char **, unsigned int *);
 /* Back-door to allow format-aware applications to create debug symbols
    while using BFD for everything else.  Currently used by the assembler
    when creating COFF files.  */
  asymbol *   (*_bfd_make_debug_symbol)
    (bfd *, void *, unsigned long size);
#define bfd_read_minisymbols(b, d, m, s) \
  BFD_SEND (b, _read_minisymbols, (b, d, m, s))
  long        (*_read_minisymbols)
    (bfd *, bfd_boolean, void **, unsigned int *);
#define bfd_minisymbol_to_symbol(b, d, m, f) \
  BFD_SEND (b, _minisymbol_to_symbol, (b, d, m, f))
  asymbol *   (*_minisymbol_to_symbol)
    (bfd *, bfd_boolean, const void *, asymbol *);

  /* Routines for relocs.  */
#define BFD_JUMP_TABLE_RELOCS(NAME) \
  NAME##_get_reloc_upper_bound, \
  NAME##_canonicalize_reloc, \
  NAME##_bfd_reloc_type_lookup

  long        (*_get_reloc_upper_bound) (bfd *, sec_ptr);
  long        (*_bfd_canonicalize_reloc)
    (bfd *, sec_ptr, arelent **, struct bfd_symbol **);
  /* See documentation on reloc types.  */
  reloc_howto_type *
              (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);

  /* Routines used when writing an object file.  */
#define BFD_JUMP_TABLE_WRITE(NAME) \
  NAME##_set_arch_mach, \
  NAME##_set_section_contents

  bfd_boolean (*_bfd_set_arch_mach)
    (bfd *, enum bfd_architecture, unsigned long);
  bfd_boolean (*_bfd_set_section_contents)
    (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);

  /* Routines used by the linker.  */
#define BFD_JUMP_TABLE_LINK(NAME) \
  NAME##_sizeof_headers, \
  NAME##_bfd_get_relocated_section_contents, \
  NAME##_bfd_relax_section, \
  NAME##_bfd_link_hash_table_create, \
  NAME##_bfd_link_hash_table_free, \
  NAME##_bfd_link_add_symbols, \
  NAME##_bfd_link_just_syms, \
  NAME##_bfd_final_link, \
  NAME##_bfd_link_split_section, \
  NAME##_bfd_gc_sections, \
  NAME##_bfd_merge_sections, \
  NAME##_bfd_discard_group

  int         (*_bfd_sizeof_headers) (bfd *, bfd_boolean);
  bfd_byte *  (*_bfd_get_relocated_section_contents)
    (bfd *, struct bfd_link_info *, struct bfd_link_order *,
     bfd_byte *, bfd_boolean, struct bfd_symbol **);

  bfd_boolean (*_bfd_relax_section)
    (bfd *, struct bfd_section *, struct bfd_link_info *, bfd_boolean *);

  /* Create a hash table for the linker.  Different backends store
     different information in this table.  */
  struct bfd_link_hash_table *
              (*_bfd_link_hash_table_create) (bfd *);

  /* Release the memory associated with the linker hash table.  */
  void        (*_bfd_link_hash_table_free) (struct bfd_link_hash_table *);

  /* Add symbols from this object file into the hash table.  */
  bfd_boolean (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);

  /* Indicate that we are only retrieving symbol values from this section.  */
  void        (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);

  /* Do a link based on the link_order structures attached to each
     section of the BFD.  */
  bfd_boolean (*_bfd_final_link) (bfd *, struct bfd_link_info *);

  /* Should this section be split up into smaller pieces during linking.  */
  bfd_boolean (*_bfd_link_split_section) (bfd *, struct bfd_section *);

  /* Remove sections that are not referenced from the output.  */
  bfd_boolean (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);

  /* Attempt to merge SEC_MERGE sections.  */
  bfd_boolean (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);

  /* Discard members of a group.  */
  bfd_boolean (*_bfd_discard_group) (bfd *, struct bfd_section *);

  /* Routines to handle dynamic symbols and relocs.  */
#define BFD_JUMP_TABLE_DYNAMIC(NAME) \
  NAME##_get_dynamic_symtab_upper_bound, \
  NAME##_canonicalize_dynamic_symtab, \
  NAME##_get_dynamic_reloc_upper_bound, \
  NAME##_canonicalize_dynamic_reloc

  /* Get the amount of memory required to hold the dynamic symbols.  */
  long        (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);
  /* Read in the dynamic symbols.  */
  long        (*_bfd_canonicalize_dynamic_symtab)
    (bfd *, struct bfd_symbol **);
  /* Get the amount of memory required to hold the dynamic relocs.  */
  long        (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);
  /* Read in the dynamic relocs.  */
  long        (*_bfd_canonicalize_dynamic_reloc)
    (bfd *, arelent **, struct bfd_symbol **);

  /* Opposite endian version of this target.  */
  const struct bfd_target * alternative_target;

  /* Data for use by back-end routines, which isn't
     generic enough to belong in this structure.  */
  const void *backend_data;

} bfd_target;

bfd_boolean bfd_set_default_target (const char *name);

const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);

const char ** bfd_target_list (void);

const bfd_target *bfd_search_for_target
   (int (*search_func) (const bfd_target *, void *),
    void *);

/* Extracted from format.c.  */
bfd_boolean bfd_check_format (bfd *abfd, bfd_format format);

bfd_boolean bfd_check_format_matches
   (bfd *abfd, bfd_format format, char ***matching);

bfd_boolean bfd_set_format (bfd *abfd, bfd_format format);

const char *bfd_format_string (bfd_format format);

/* Extracted from linker.c.  */
bfd_boolean bfd_link_split_section (bfd *abfd, asection *sec);

#define bfd_link_split_section(abfd, sec) \
       BFD_SEND (abfd, _bfd_link_split_section, (abfd, sec))

/* Extracted from simple.c.  */
bfd_byte *bfd_simple_get_relocated_section_contents
   (bfd *abfd, asection *sec, bfd_byte *outbuf, asymbol **symbol_table);

#ifdef __cplusplus
}
#endif
#endif
@


1.13
log
@Use time_t instead of long for archive timestamps, and print them as long long;
prodding deraadt@@
@
text
@d3669 4
a3672 5
     includes `<<bfd.h>>', IOSTREAM has been declared as a "char *",
     and MTIME as a "long".  Their correct types, to which they
     are cast when used, are "FILE *" and "time_t".    The iostream
     is the result of an fopen on the filename.  However, if the
     BFD_IN_MEMORY flag is set, then iostream is actually a pointer
d3701 1
a3701 1
  long mtime;
@


1.12
log
@m88k ELF toolchain, supporting static binaries only so far.

Assembler supports a register prefix of `#' when configured for SVR4, and `%'
when configured for OpenBSD. Pseudo-ops do not need a leading dot, except
when configured for OpenBSD, allowing the `set' instruction to be recognized
correctly.

Based upon various unfinished or unreliable works, including smurph@@'s early
work in 2003, my own attempts in 2004 and 2005, and Michael Kato's binutils
2.15 diff from 2005. Support for register prefixes, as well as fixing an
evil off-by-one in resolving 16-bit pc-relative relocations in ld (which would
only affect kernel .S files branching to global symbols), came as part of the
2012 work.

Not enabled yet (needs Makefile.bsd-wrapper, bfd/config.bfd and
gdb/configure.tgt updates to completely enable) so as not to disturb the
existing a.out toolchain builds; will hopefully be enabled very soon.
@
text
@d40 1
d983 1
a983 1
long bfd_get_mtime (bfd *abfd);
@


1.11
log
@Some post bintuils-2.15 changes for gdb-6.3.
@
text
@d2078 2
@


1.10
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d318 2
a319 1
#define bfd_section_size(bfd, ptr) (bfd_get_section_size_before_reloc(ptr))
d515 2
@


1.9
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d11 1
a11 1
   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d61 1
d65 2
a106 20
/* Support for different sizes of target format ints and addresses.
   If the type `long' is at least 64 bits, BFD_HOST_64BIT_LONG will be
   set to 1 above.  Otherwise, if gcc is being used, this code will
   use gcc's "long long" type.  Otherwise, BFD_HOST_64_BIT must be
   defined above.  */

#ifndef BFD_HOST_64_BIT
# if BFD_HOST_64BIT_LONG
#  define BFD_HOST_64_BIT long
#  define BFD_HOST_U_64_BIT unsigned long
# else
#  ifdef __GNUC__
#   if __GNUC__ >= 2
#    define BFD_HOST_64_BIT long long
#    define BFD_HOST_U_64_BIT unsigned long long
#   endif /* __GNUC__ >= 2 */
#  endif /* ! defined (__GNUC__) */
# endif /* ! BFD_HOST_64BIT_LONG */
#endif /* ! defined (BFD_HOST_64_BIT) */

d154 16
a169 15
/* A pointer to a position in a file.  */
/* FIXME:  This should be using off_t from <sys/types.h>.
   For now, try to avoid breaking stuff by not including <sys/types.h> here.
   This will break on systems with 64-bit file offsets (e.g. 4.4BSD).
   Probably the best long-term answer is to avoid using file_ptr AND off_t
   in this header file, and to handle this in the BFD implementation
   rather than in its interface.  */
/* typedef off_t	file_ptr; */
typedef bfd_signed_vma file_ptr;
typedef bfd_vma ufile_ptr;

extern void bfd_sprintf_vma
  PARAMS ((bfd *, char *, bfd_vma));
extern void bfd_fprintf_vma
  PARAMS ((bfd *, PTR, bfd_vma));
d182 1
a182 1
  bfd_object,		/* Linker/assember/compiler output.  */
d300 1
a300 1
    struct symbol_cache_entry *sym;	/* Function name.  */
d311 1
a311 1
typedef struct sec *sec_ptr;
d355 1
a355 2
extern const char *bfd_get_stab_name
  PARAMS ((int));
d389 1
a389 1
    PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d391 2
a392 2
     but we use PTR to avoid requiring the inclusion of objalloc.h.  */
  PTR memory;
d397 4
a400 4
  PARAMS ((struct bfd_hash_table *,
	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
				       struct bfd_hash_table *,
				       const char *)));
d404 5
a408 5
  PARAMS ((struct bfd_hash_table *,
	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
				       struct bfd_hash_table *,
				       const char *),
	   unsigned int size));
d412 1
a412 1
  PARAMS ((struct bfd_hash_table *));
d419 2
a420 2
  PARAMS ((struct bfd_hash_table *, const char *, bfd_boolean create,
	   bfd_boolean copy));
d424 2
a425 2
  PARAMS ((struct bfd_hash_table *, struct bfd_hash_entry *old,
	   struct bfd_hash_entry *nw));
d429 1
a429 2
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
	   const char *));
d432 2
a433 2
extern PTR bfd_hash_allocate
  PARAMS ((struct bfd_hash_table *, unsigned int));
d439 3
a441 3
  PARAMS ((struct bfd_hash_table *,
	   bfd_boolean (*) (struct bfd_hash_entry *, PTR),
	   PTR info));
d443 1
a443 1
#define COFF_SWAP_TABLE (PTR) &bfd_coff_std_swap_table
d450 6
a455 12
extern bfd_size_type bfd_bread
  PARAMS ((PTR, bfd_size_type, bfd *));
extern bfd_size_type bfd_bwrite
  PARAMS ((const PTR, bfd_size_type, bfd *));
extern int bfd_seek
  PARAMS ((bfd *, file_ptr, int));
extern ufile_ptr bfd_tell
  PARAMS ((bfd *));
extern int bfd_flush
  PARAMS ((bfd *));
extern int bfd_stat
  PARAMS ((bfd *, struct stat *));
d473 1
a473 2
extern void warn_deprecated
  PARAMS ((const char *, const char *, int, const char *));
d512 1
a512 1
  PARAMS ((bfd *abfd));
d516 2
a517 2
  PARAMS ((bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
	   bfd_boolean, bfd_boolean, unsigned int, struct sec **));
d521 18
a538 36
bfd_vma bfd_getb64
  PARAMS ((const unsigned char *));
bfd_vma bfd_getl64
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getb_signed_64
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getl_signed_64
  PARAMS ((const unsigned char *));
bfd_vma bfd_getb32
  PARAMS ((const unsigned char *));
bfd_vma bfd_getl32
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getb_signed_32
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getl_signed_32
  PARAMS ((const unsigned char *));
bfd_vma bfd_getb16
  PARAMS ((const unsigned char *));
bfd_vma bfd_getl16
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getb_signed_16
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getl_signed_16
  PARAMS ((const unsigned char *));
void bfd_putb64
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putl64
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putb32
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putl32
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putb16
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putl16
  PARAMS ((bfd_vma, unsigned char *));
d542 2
a543 4
bfd_vma bfd_get_bits
  PARAMS ((bfd_byte *, int, bfd_boolean));
void bfd_put_bits
  PARAMS ((bfd_vma, bfd_byte *, int, bfd_boolean));
d551 1
a551 1
struct symbol_cache_entry;
d557 1
a557 1
  PARAMS ((bfd * abfd));
d559 1
a559 1
  PARAMS ((bfd *abfd, bfd_vma gp_value));
d561 5
a565 6
  PARAMS ((bfd *abfd, unsigned long gprmask, unsigned long fprmask,
	   unsigned long *cprmask));
extern PTR bfd_ecoff_debug_init
  PARAMS ((bfd *output_bfd, struct ecoff_debug_info *output_debug,
	   const struct ecoff_debug_swap *output_swap,
	   struct bfd_link_info *));
d567 2
a568 3
  PARAMS ((PTR handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
	   const struct ecoff_debug_swap *output_swap,
	   struct bfd_link_info *));
d570 4
a573 5
  PARAMS ((PTR handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
	   const struct ecoff_debug_swap *output_swap,
	   bfd *input_bfd, struct ecoff_debug_info *input_debug,
	   const struct ecoff_debug_swap *input_swap,
	   struct bfd_link_info *));
d575 3
a577 3
  PARAMS ((PTR handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
	   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
	   struct bfd_link_info *));
d579 4
a582 7
  PARAMS ((bfd *abfd, struct ecoff_debug_info *debug,
	   const struct ecoff_debug_swap *swap,
	   bfd_boolean relocateable,
	   bfd_boolean (*get_extr) (struct symbol_cache_entry *,
				    struct ecoff_extr *),
	   void (*set_index) (struct symbol_cache_entry *,
			      bfd_size_type)));
d584 3
a586 3
  PARAMS ((bfd *abfd, struct ecoff_debug_info *debug,
	   const struct ecoff_debug_swap *swap,
	   const char *name, struct ecoff_extr *esym));
d588 2
a589 2
  PARAMS ((bfd *abfd, struct ecoff_debug_info *debug,
	   const struct ecoff_debug_swap *swap));
d591 2
a592 2
  PARAMS ((bfd *abfd, struct ecoff_debug_info *debug,
	   const struct ecoff_debug_swap *swap, file_ptr where));
d594 3
a596 3
  PARAMS ((PTR handle, bfd *abfd, struct ecoff_debug_info *debug,
	   const struct ecoff_debug_swap *swap,
	   struct bfd_link_info *info, file_ptr where));
d598 1
a598 2
  PARAMS ((bfd *, struct bfd_link_info *, struct sec *, struct sec *,
	   char **));
d609 8
a616 4
extern bfd_boolean bfd_elf32_record_link_assignment
  PARAMS ((bfd *, struct bfd_link_info *, const char *, bfd_boolean));
extern bfd_boolean bfd_elf64_record_link_assignment
  PARAMS ((bfd *, struct bfd_link_info *, const char *, bfd_boolean));
d618 1
a618 1
  PARAMS ((bfd *, struct bfd_link_info *));
d620 4
a623 9
  PARAMS ((bfd *, struct bfd_link_needed_list **));
extern bfd_boolean bfd_elf32_size_dynamic_sections
  PARAMS ((bfd *, const char *, const char *, const char *,
	   const char * const *, struct bfd_link_info *, struct sec **,
	   struct bfd_elf_version_tree *));
extern bfd_boolean bfd_elf64_size_dynamic_sections
  PARAMS ((bfd *, const char *, const char *, const char *,
	   const char * const *, struct bfd_link_info *, struct sec **,
	   struct bfd_elf_version_tree *));
d625 1
a625 3
  PARAMS ((bfd *, const char *));
extern void bfd_elf_set_dt_needed_soname
  PARAMS ((bfd *, const char *));
d627 3
a629 1
  PARAMS ((bfd *));
d631 3
a633 5
  PARAMS ((bfd *, struct bfd_link_info *));
extern bfd_boolean bfd_elf32_discard_info
  PARAMS ((bfd *, struct bfd_link_info *));
extern bfd_boolean bfd_elf64_discard_info
  PARAMS ((bfd *, struct bfd_link_info *));
d639 1
a639 1
  PARAMS ((bfd *abfd));
d649 17
a665 1
  PARAMS ((bfd *abfd, void *phdrs));
d669 1
a669 1
  PARAMS ((bfd *));
d673 4
a676 1
  PARAMS ((bfd *));
d679 1
a679 2
  PARAMS ((bfd *, struct bfd_link_info *, struct sec *, struct sec *,
	   char **));
d681 1
a681 2
  PARAMS ((bfd *, struct bfd_link_info *, struct sec *, struct sec *,
	   char **));
d686 1
a686 1
  PARAMS ((bfd *, struct bfd_link_info *));
d688 1
a688 1
  PARAMS ((bfd *, struct bfd_link_info *, const char *));
d690 1
a690 2
  PARAMS ((bfd *, struct bfd_link_info *, struct sec **, struct sec **,
	   struct sec **));
d695 1
a695 1
  PARAMS ((bfd *, struct bfd_link_info *));
d697 1
a697 1
  PARAMS ((bfd *, struct bfd_link_info *));
d699 1
a699 1
  PARAMS ((bfd *, struct bfd_link_info *));
d709 1
a709 1
  PTR data;
d722 1
a722 1
  PARAMS ((bfd_window *));
d724 1
a724 1
  PARAMS ((bfd_window *));
d726 1
a726 1
  PARAMS ((bfd *, file_ptr, bfd_size_type, bfd_window *, bfd_boolean));
d731 1
a731 2
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *,
	   bfd_size_type));
d733 2
a734 2
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *,
	   bfd_vma, const char *, const char *, const char *, unsigned int));
d736 1
a736 1
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *));
d738 1
a738 1
  PARAMS ((bfd *, struct bfd_link_info *, const char *));
d740 1
a740 1
  PARAMS ((bfd *, struct bfd_link_info *, const char *));
d742 3
a744 3
  PARAMS ((bfd *, struct bfd_link_info *, const char *, const char *,
	   unsigned long, unsigned long, unsigned long, bfd_boolean,
	   int, bfd_boolean, bfd_boolean, struct sec **, bfd_boolean));
d746 1
a746 1
  PARAMS ((bfd *, const char *, const char *, bfd_boolean));
d750 1
a750 1
  PARAMS ((bfd *, char *));
d760 1
a760 1
  PARAMS ((bfd *, struct symbol_cache_entry *, struct internal_syment *));
d763 1
a763 1
  PARAMS ((bfd *, struct symbol_cache_entry *, int, union internal_auxent *));
d766 1
a766 1
  PARAMS ((bfd *, struct symbol_cache_entry *, unsigned int));
d769 1
a769 2
  PARAMS ((bfd *, struct bfd_link_info *, struct sec *, struct sec *,
	   char **));
d773 1
a773 1
  PARAMS ((struct bfd_link_info *));
d776 1
a776 1
  PARAMS ((bfd *, struct bfd_link_info *, int));
d779 1
a779 1
  PARAMS ((bfd *, struct bfd_link_info *));
d783 1
a783 1
  PARAMS ((struct bfd_link_info *));
d786 1
a786 1
  PARAMS ((bfd *, struct bfd_link_info *, int));
d789 1
a789 1
  PARAMS ((bfd *, struct bfd_link_info *));
d793 1
a793 1
  PARAMS ((struct bfd_link_info *));
d796 1
a796 1
  PARAMS ((bfd *, struct bfd_link_info *, int));
d799 1
a799 1
  PARAMS ((bfd *, struct bfd_link_info *));
d802 1
a802 1
  PARAMS ((bfd *, struct bfd_link_info *));
d806 1
a806 1
  PARAMS ((bfd *, bfd *));
d809 1
a809 1
  PARAMS ((bfd *, const char *));
d812 1
a812 1
  PARAMS ((bfd *, const char *));
d816 1
a816 1
  PARAMS ((struct sec *, int));
d819 12
a830 1
  PARAMS ((struct sec *));
d833 1
a833 2
void
bfd_init PARAMS ((void));
d836 1
a836 2
bfd *
bfd_openr PARAMS ((const char *filename, const char *target));
d838 1
a838 2
bfd *
bfd_fdopenr PARAMS ((const char *filename, const char *target, int fd));
d840 1
a840 2
bfd *
bfd_openstreamr PARAMS ((const char *, const char *, PTR));
d842 1
a842 2
bfd *
bfd_openw PARAMS ((const char *filename, const char *target));
d844 1
a844 2
bfd_boolean
bfd_close PARAMS ((bfd *abfd));
d846 1
a846 2
bfd_boolean
bfd_close_all_done PARAMS ((bfd *));
d848 1
a848 2
bfd *
bfd_create PARAMS ((const char *filename, bfd *templ));
d850 1
a850 2
bfd_boolean
bfd_make_writable PARAMS ((bfd *abfd));
d852 1
a852 2
bfd_boolean
bfd_make_readable PARAMS ((bfd *abfd));
d854 10
a863 2
char *
bfd_follow_gnu_debuglink PARAMS ((bfd *abfd, const char *dir));
d870 1
a870 1
                ((void) (*((unsigned char *) (ptr)) = (unsigned char) (val)))
d872 1
a872 1
               bfd_put_8
d874 1
a874 1
                (*(unsigned char *) (ptr) & 0xff)
d876 1
a876 1
               (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)
d879 1
a879 1
                BFD_SEND(abfd, bfd_putx16, ((val),(ptr)))
d881 1
a881 1
                bfd_put_16
d883 1
a883 1
                BFD_SEND(abfd, bfd_getx16, (ptr))
d885 1
a885 1
                BFD_SEND (abfd, bfd_getx_signed_16, (ptr))
d888 1
a888 1
                BFD_SEND(abfd, bfd_putx32, ((val),(ptr)))
d890 1
a890 1
                bfd_put_32
d892 1
a892 1
                BFD_SEND(abfd, bfd_getx32, (ptr))
d894 1
a894 1
                BFD_SEND(abfd, bfd_getx_signed_32, (ptr))
d897 1
a897 1
                BFD_SEND(abfd, bfd_putx64, ((val), (ptr)))
d899 1
a899 1
                bfd_put_64
d901 1
a901 1
                BFD_SEND(abfd, bfd_getx64, (ptr))
d903 1
a903 1
                BFD_SEND(abfd, bfd_getx_signed_64, (ptr))
d905 13
a917 13
#define bfd_get(bits, abfd, ptr)                               \
                ( (bits) ==  8 ? (bfd_vma) bfd_get_8 (abfd, ptr)       \
                : (bits) == 16 ? bfd_get_16 (abfd, ptr)        \
                : (bits) == 32 ? bfd_get_32 (abfd, ptr)        \
                : (bits) == 64 ? bfd_get_64 (abfd, ptr)        \
                : (abort (), (bfd_vma) - 1))

#define bfd_put(bits, abfd, val, ptr)                          \
                ( (bits) ==  8 ? bfd_put_8  (abfd, val, ptr)   \
                : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)   \
                : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)   \
                : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)   \
                : (abort (), (void) 0))
d958 1
a958 5
/* Refinements on the above, which should eventually go away.  Save
   cluttering the source with (bfd_vma) and (bfd_byte *) casts.  */

#define H_PUT_64(abfd, val, where) \
  bfd_h_put_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))
d960 16
a975 40
#define H_PUT_32(abfd, val, where) \
  bfd_h_put_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_16(abfd, val, where) \
  bfd_h_put_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_8 bfd_h_put_8

#define H_PUT_S64(abfd, val, where) \
  bfd_h_put_signed_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S32(abfd, val, where) \
  bfd_h_put_signed_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S16(abfd, val, where) \
  bfd_h_put_signed_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S8 bfd_h_put_signed_8

#define H_GET_64(abfd, where) \
  bfd_h_get_64 ((abfd), (bfd_byte *) (where))

#define H_GET_32(abfd, where) \
  bfd_h_get_32 ((abfd), (bfd_byte *) (where))

#define H_GET_16(abfd, where) \
  bfd_h_get_16 ((abfd), (bfd_byte *) (where))

#define H_GET_8 bfd_h_get_8

#define H_GET_S64(abfd, where) \
  bfd_h_get_signed_64 ((abfd), (bfd_byte *) (where))

#define H_GET_S32(abfd, where) \
  bfd_h_get_signed_32 ((abfd), (bfd_byte *) (where))

#define H_GET_S16(abfd, where) \
  bfd_h_get_signed_16 ((abfd), (bfd_byte *) (where))

#define H_GET_S8 bfd_h_get_signed_8
d979 1
a979 2
long
bfd_get_mtime PARAMS ((bfd *abfd));
d981 1
a981 2
long
bfd_get_size PARAMS ((bfd *abfd));
d1002 1
a1002 1
typedef struct sec
d1015 1
a1015 1
  struct sec *next;
d1235 4
a1238 2
  /* Usused bits.  */
  unsigned int flag12:1;
d1281 1
a1281 1
  struct sec *output_section;
d1311 1
a1311 1
  PTR userdata;
d1329 4
d1340 1
a1340 1
  PTR used_by_bfd;
d1350 2
a1351 2
  struct symbol_cache_entry *symbol;
  struct symbol_cache_entry **symbol_ptr_ptr;
d1368 1
a1368 1
extern const asection bfd_abs_section;
d1372 1
a1372 1
extern const asection bfd_und_section;
d1376 1
a1376 1
extern const asection bfd_com_section;
d1379 1
a1379 1
extern const asection bfd_ind_section;
d1389 4
a1392 4
extern const struct symbol_cache_entry * const bfd_abs_symbol;
extern const struct symbol_cache_entry * const bfd_com_symbol;
extern const struct symbol_cache_entry * const bfd_und_symbol;
extern const struct symbol_cache_entry * const bfd_ind_symbol;
d1394 1
a1394 2
     ((section)->reloc_done ? (abort (), (bfd_size_type) 1) \
                            : (section)->_raw_size)
d1424 3
a1426 2
void
bfd_section_list_clear PARAMS ((bfd *));
d1428 2
a1429 2
asection *
bfd_get_section_by_name PARAMS ((bfd *abfd, const char *name));
d1431 27
a1457 40
char *
bfd_get_unique_section_name PARAMS ((bfd *abfd,
    const char *templat,
    int *count));

asection *
bfd_make_section_old_way PARAMS ((bfd *abfd, const char *name));

asection *
bfd_make_section_anyway PARAMS ((bfd *abfd, const char *name));

asection *
bfd_make_section PARAMS ((bfd *, const char *name));

bfd_boolean
bfd_set_section_flags PARAMS ((bfd *abfd, asection *sec, flagword flags));

void
bfd_map_over_sections PARAMS ((bfd *abfd,
    void (*func) (bfd *abfd,
    asection *sect,
    PTR obj),
    PTR obj));

bfd_boolean
bfd_set_section_size PARAMS ((bfd *abfd, asection *sec, bfd_size_type val));

bfd_boolean
bfd_set_section_contents PARAMS ((bfd *abfd, asection *section,
    PTR data, file_ptr offset,
    bfd_size_type count));

bfd_boolean
bfd_get_section_contents PARAMS ((bfd *abfd, asection *section,
    PTR location, file_ptr offset,
    bfd_size_type count));

bfd_boolean
bfd_copy_private_section_data PARAMS ((bfd *ibfd, asection *isec,
    bfd *obfd, asection *osec));
d1462 2
a1463 2
void
_bfd_strip_section_from_output PARAMS ((struct bfd_link_info *info, asection *section));
d1465 1
a1465 2
bfd_boolean
bfd_generic_discard_group PARAMS ((bfd *abfd, asection *group));
d1485 1
d1540 1
d1550 1
d1573 2
d1602 4
d1630 4
d1664 1
d1673 1
d1678 1
d1688 1
d1715 1
a1716 1
#define bfd_mach_msp11          11
d1720 2
a1721 1
#define bfd_mach_msp41          41
d1725 2
a1728 2
#define bfd_mach_msp15          15
#define bfd_mach_msp16          16  
d1749 1
a1749 2
       PARAMS ((const struct bfd_arch_info *a,
                const struct bfd_arch_info *b));
d1751 1
a1751 1
  bfd_boolean (*scan) PARAMS ((const struct bfd_arch_info *, const char *));
d1757 1
a1757 2
const char *
bfd_printable_name PARAMS ((bfd *abfd));
d1759 1
a1759 2
const bfd_arch_info_type *
bfd_scan_arch PARAMS ((const char *string));
d1761 1
a1761 2
const char **
bfd_arch_list PARAMS ((void));
d1763 2
a1764 5
const bfd_arch_info_type *
bfd_arch_get_compatible PARAMS ((
    const bfd *abfd,
    const bfd *bbfd,
    bfd_boolean accept_unknowns));
d1766 1
a1766 2
void
bfd_set_arch_info PARAMS ((bfd *abfd, const bfd_arch_info_type *arg));
d1768 1
a1768 2
enum bfd_architecture
bfd_get_arch PARAMS ((bfd *abfd));
d1770 1
a1770 2
unsigned long
bfd_get_mach PARAMS ((bfd *abfd));
d1772 1
a1772 2
unsigned int
bfd_arch_bits_per_byte PARAMS ((bfd *abfd));
d1774 1
a1774 2
unsigned int
bfd_arch_bits_per_address PARAMS ((bfd *abfd));
d1776 1
a1776 2
const bfd_arch_info_type *
bfd_get_arch_info PARAMS ((bfd *abfd));
d1778 2
a1779 4
const bfd_arch_info_type *
bfd_lookup_arch PARAMS ((enum bfd_architecture
    arch,
    unsigned long machine));
d1781 2
a1782 2
const char *
bfd_printable_arch_mach PARAMS ((enum bfd_architecture arch, unsigned long machine));
d1784 1
a1784 2
unsigned int
bfd_octets_per_byte PARAMS ((bfd *abfd));
d1786 2
a1787 3
unsigned int
bfd_arch_mach_octets_per_byte PARAMS ((enum bfd_architecture arch,
    unsigned long machine));
d1825 1
a1825 1
  struct symbol_cache_entry **sym_ptr_ptr;
d1896 1
a1896 1
     strange relocation methods to be accomodated (e.g., i960 callj
d1899 2
a1900 2
    PARAMS ((bfd *, arelent *, struct symbol_cache_entry *, PTR, asection *,
             bfd *, char **));
d1957 1
a1957 1
    if (symbol != (asymbol *) NULL)                     \
d1970 1
a1970 2
unsigned int
bfd_get_reloc_size PARAMS ((reloc_howto_type *));
d1979 2
a1980 2
bfd_reloc_status_type
bfd_check_overflow PARAMS ((enum complain_overflow how,
d1984 1
a1984 1
    bfd_vma relocation));
d1986 2
a1987 2
bfd_reloc_status_type
bfd_perform_relocation PARAMS ((bfd *abfd,
d1989 1
a1989 1
    PTR data,
d1992 1
a1992 1
    char **error_message));
d1994 2
a1995 2
bfd_reloc_status_type
bfd_install_relocation PARAMS ((bfd *abfd,
d1997 1
a1997 1
    PTR data, bfd_vma data_start,
d1999 1
a1999 1
    char **error_message));
d2308 1
d2319 42
d2529 1
a2529 1
/* The type of reloc used to build a contructor table - at the moment
d2784 16
d2842 1
a2842 1
bits placed non-contigously in the instruction.  */
d2846 1
a2846 1
bits placed non-contigously in the instruction.  */
d2957 1
d3156 6
d3203 1
a3203 1
linker the inheritence tree of a C++ virtual function table.  The
d3312 1
a3312 1
of instruction and change some branchs to use PC-relative
d3340 4
d3480 2
a3481 2
reloc_howto_type *
bfd_reloc_type_lookup PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
d3483 1
a3483 2
const char *
bfd_get_reloc_code_name PARAMS ((bfd_reloc_code_real_type code));
d3487 1
a3487 1
typedef struct symbol_cache_entry
d3528 1
a3528 1
  /* The symbol is a debugging record. The value has an arbitary
d3599 1
a3599 1
  struct sec *section;
d3604 1
a3604 1
      PTR p;
d3614 1
a3614 2
bfd_boolean
bfd_is_local_label PARAMS ((bfd *abfd, asymbol *sym));
d3616 1
a3616 2
bfd_boolean
bfd_is_local_label_name PARAMS ((bfd *abfd, const char *name));
d3619 1
a3619 1
     BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name))
d3622 1
a3622 2
     BFD_SEND (abfd, _bfd_canonicalize_symtab,\
                  (abfd, location))
d3624 2
a3625 2
bfd_boolean
bfd_set_symtab PARAMS ((bfd *abfd, asymbol **location, unsigned int count));
d3627 1
a3627 2
void
bfd_print_symbol_vandf PARAMS ((bfd *abfd, PTR file, asymbol *symbol));
d3630 1
a3630 1
     BFD_SEND (abfd, _bfd_make_empty_symbol, (abfd))
d3632 1
a3632 2
asymbol *
_bfd_generic_make_empty_symbol PARAMS ((bfd *));
d3635 1
a3635 1
        BFD_SEND (abfd, _bfd_make_debug_symbol, (abfd, ptr, size))
d3637 1
a3637 2
int
bfd_decode_symclass PARAMS ((asymbol *symbol));
d3639 1
a3639 2
bfd_boolean
bfd_is_undefined_symclass PARAMS ((int symclass));
d3641 1
a3641 2
void
bfd_symbol_info PARAMS ((asymbol *symbol, symbol_info *ret));
d3643 2
a3644 2
bfd_boolean
bfd_copy_private_symbol_data PARAMS ((bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym));
d3647 2
a3648 2
     BFD_SEND (obfd, _bfd_copy_private_symbol_data, \
               (ibfd, isymbol, obfd, osymbol))
d3669 1
a3669 1
  PTR iostream;
d3730 1
a3730 1
  struct sec *sections;
d3733 1
a3733 1
  struct sec **section_tail;
d3746 1
a3746 1
  struct symbol_cache_entry  **outsymbols;
d3755 1
a3755 1
  PTR arelt_data;
d3805 1
a3805 1
      PTR any;
d3810 1
a3810 1
  PTR usrdata;
d3813 3
a3815 3
     struct objalloc *, but we use PTR to avoid requiring the inclusion of
     objalloc.h.  */
  PTR memory;
d3843 1
a3843 2
bfd_error_type
bfd_get_error PARAMS ((void));
d3845 1
a3845 2
void
bfd_set_error PARAMS ((bfd_error_type error_tag));
d3847 1
a3847 2
const char *
bfd_errmsg PARAMS ((bfd_error_type error_tag));
d3849 1
a3849 2
void
bfd_perror PARAMS ((const char *message));
d3851 1
a3851 1
typedef void (*bfd_error_handler_type) PARAMS ((const char *, ...));
d3853 1
a3853 2
bfd_error_handler_type
bfd_set_error_handler PARAMS ((bfd_error_handler_type));
d3855 1
a3855 2
void
bfd_set_error_program_name PARAMS ((const char *));
d3857 1
a3857 2
bfd_error_handler_type
bfd_get_error_handler PARAMS ((void));
d3859 1
a3859 2
const char *
bfd_archive_filename PARAMS ((bfd *));
d3861 1
a3861 2
long
bfd_get_reloc_upper_bound PARAMS ((bfd *abfd, asection *sect));
d3863 2
a3864 5
long
bfd_canonicalize_reloc PARAMS ((bfd *abfd,
    asection *sec,
    arelent **loc,
    asymbol **syms));
d3866 2
a3867 2
void
bfd_set_reloc PARAMS ((bfd *abfd, asection *sec, arelent **rel, unsigned int count));
d3869 1
a3869 2
bfd_boolean
bfd_set_file_flags PARAMS ((bfd *abfd, flagword flags));
d3871 1
a3871 2
int
bfd_get_arch_size PARAMS ((bfd *abfd));
d3873 1
a3873 2
int
bfd_get_sign_extend_vma PARAMS ((bfd *abfd));
d3875 1
a3875 2
bfd_boolean
bfd_set_start_address PARAMS ((bfd *abfd, bfd_vma vma));
d3877 1
a3877 2
unsigned int
bfd_get_gp_size PARAMS ((bfd *abfd));
d3879 1
a3879 2
void
bfd_set_gp_size PARAMS ((bfd *abfd, unsigned int i));
d3881 1
a3881 2
bfd_vma
bfd_scan_vma PARAMS ((const char *string, const char **end, int base));
d3883 1
a3883 2
bfd_boolean
bfd_copy_private_bfd_data PARAMS ((bfd *ibfd, bfd *obfd));
d3888 1
a3888 2
bfd_boolean
bfd_merge_private_bfd_data PARAMS ((bfd *ibfd, bfd *obfd));
d3893 1
a3893 2
bfd_boolean
bfd_set_private_flags PARAMS ((bfd *abfd, flagword flags));
d3968 2
a3969 3
       PARAMS ((bfd *, struct bfd_link_info *,
                 struct bfd_link_order *, bfd_byte *,
                 bfd_boolean, asymbol **));
d3971 1
a3971 2
bfd_boolean
bfd_alt_mach_code PARAMS ((bfd *abfd, int alternative));
d3975 2
a3976 2
  PTR marker;
  PTR tdata;
d3979 2
a3980 2
  struct sec *sections;
  struct sec **section_tail;
d3985 1
a3985 2
bfd_boolean
bfd_preserve_save PARAMS ((bfd *, struct bfd_preserve *));
d3987 1
a3987 2
void
bfd_preserve_restore PARAMS ((bfd *, struct bfd_preserve *));
d3989 1
a3989 2
void
bfd_preserve_finish PARAMS ((bfd *, struct bfd_preserve *));
d3992 2
a3993 2
symindex
bfd_get_next_mapent PARAMS ((bfd *abfd, symindex previous, carsym **sym));
d3995 1
a3995 2
bfd_boolean
bfd_set_archive_head PARAMS ((bfd *output, bfd *new_head));
d3997 1
a3997 2
bfd *
bfd_openr_next_archived_file PARAMS ((bfd *archive, bfd *previous));
d4000 1
a4000 2
const char *
bfd_core_file_failing_command PARAMS ((bfd *abfd));
d4002 1
a4002 2
int
bfd_core_file_failing_signal PARAMS ((bfd *abfd));
d4004 2
a4005 2
bfd_boolean
core_file_matches_executable_p PARAMS ((bfd *core_bfd, bfd *exec_bfd));
d4009 1
a4009 1
               ((*((bfd)->xvec->message)) arglist)
d4019 1
a4019 1
            (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)
d4097 9
a4105 9
  bfd_vma        (*bfd_getx64) PARAMS ((const bfd_byte *));
  bfd_signed_vma (*bfd_getx_signed_64) PARAMS ((const bfd_byte *));
  void           (*bfd_putx64) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_getx32) PARAMS ((const bfd_byte *));
  bfd_signed_vma (*bfd_getx_signed_32) PARAMS ((const bfd_byte *));
  void           (*bfd_putx32) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_getx16) PARAMS ((const bfd_byte *));
  bfd_signed_vma (*bfd_getx_signed_16) PARAMS ((const bfd_byte *));
  void           (*bfd_putx16) PARAMS ((bfd_vma, bfd_byte *));
d4108 9
a4116 9
  bfd_vma        (*bfd_h_getx64) PARAMS ((const bfd_byte *));
  bfd_signed_vma (*bfd_h_getx_signed_64) PARAMS ((const bfd_byte *));
  void           (*bfd_h_putx64) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_h_getx32) PARAMS ((const bfd_byte *));
  bfd_signed_vma (*bfd_h_getx_signed_32) PARAMS ((const bfd_byte *));
  void           (*bfd_h_putx32) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_h_getx16) PARAMS ((const bfd_byte *));
  bfd_signed_vma (*bfd_h_getx_signed_16) PARAMS ((const bfd_byte *));
  void           (*bfd_h_putx16) PARAMS ((bfd_vma, bfd_byte *));
d4122 1
a4122 1
  const struct bfd_target *(*_bfd_check_format[bfd_type_end]) PARAMS ((bfd *));
d4125 1
a4125 1
  bfd_boolean (*_bfd_set_format[bfd_type_end]) PARAMS ((bfd *));
d4128 1
a4128 1
  bfd_boolean (*_bfd_write_contents[bfd_type_end]) PARAMS ((bfd *));
d4133 5
a4137 5
CONCAT2 (NAME,_close_and_cleanup), \
CONCAT2 (NAME,_bfd_free_cached_info), \
CONCAT2 (NAME,_new_section_hook), \
CONCAT2 (NAME,_get_section_contents), \
CONCAT2 (NAME,_get_section_contents_in_window)
d4140 1
a4140 1
  bfd_boolean (*_close_and_cleanup) PARAMS ((bfd *));
d4142 1
a4142 1
  bfd_boolean (*_bfd_free_cached_info) PARAMS ((bfd *));
d4144 1
a4144 1
  bfd_boolean (*_new_section_hook) PARAMS ((bfd *, sec_ptr));
d4147 1
a4147 1
    PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
d4149 1
a4149 1
    PARAMS ((bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type));
d4153 7
a4159 6
CONCAT2 (NAME,_bfd_copy_private_bfd_data), \
CONCAT2 (NAME,_bfd_merge_private_bfd_data), \
CONCAT2 (NAME,_bfd_copy_private_section_data), \
CONCAT2 (NAME,_bfd_copy_private_symbol_data), \
CONCAT2 (NAME,_bfd_set_private_flags), \
CONCAT2 (NAME,_bfd_print_private_bfd_data) \
d4162 1
a4162 1
  bfd_boolean (*_bfd_copy_private_bfd_data) PARAMS ((bfd *, bfd *));
d4165 1
a4165 1
  bfd_boolean (*_bfd_merge_private_bfd_data) PARAMS ((bfd *, bfd *));
d4169 1
a4169 1
    PARAMS ((bfd *, sec_ptr, bfd *, sec_ptr));
d4173 1
a4173 1
    PARAMS ((bfd *, asymbol *, bfd *, asymbol *));
d4175 1
a4175 1
  bfd_boolean (*_bfd_set_private_flags) PARAMS ((bfd *, flagword));
d4178 1
a4178 1
  bfd_boolean (*_bfd_print_private_bfd_data) PARAMS ((bfd *, PTR));
d4182 7
a4188 6
CONCAT2 (NAME,_core_file_failing_command), \
CONCAT2 (NAME,_core_file_failing_signal), \
CONCAT2 (NAME,_core_file_matches_executable_p)
  char *      (*_core_file_failing_command) PARAMS ((bfd *));
  int         (*_core_file_failing_signal) PARAMS ((bfd *));
  bfd_boolean (*_core_file_matches_executable_p) PARAMS ((bfd *, bfd *));
d4192 13
a4204 12
CONCAT2 (NAME,_slurp_armap), \
CONCAT2 (NAME,_slurp_extended_name_table), \
CONCAT2 (NAME,_construct_extended_name_table), \
CONCAT2 (NAME,_truncate_arname), \
CONCAT2 (NAME,_write_armap), \
CONCAT2 (NAME,_read_ar_hdr), \
CONCAT2 (NAME,_openr_next_archived_file), \
CONCAT2 (NAME,_get_elt_at_index), \
CONCAT2 (NAME,_generic_stat_arch_elt), \
CONCAT2 (NAME,_update_armap_timestamp)
  bfd_boolean (*_bfd_slurp_armap) PARAMS ((bfd *));
  bfd_boolean (*_bfd_slurp_extended_name_table) PARAMS ((bfd *));
d4206 2
a4207 2
    PARAMS ((bfd *, char **, bfd_size_type *, const char **));
  void        (*_bfd_truncate_arname) PARAMS ((bfd *, const char *, char *));
d4209 7
a4215 7
    PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
  PTR         (*_bfd_read_ar_hdr_fn) PARAMS ((bfd *));
  bfd *       (*openr_next_archived_file) PARAMS ((bfd *, bfd *));
#define bfd_get_elt_at_index(b,i) BFD_SEND(b, _bfd_get_elt_at_index, (b,i))
  bfd *       (*_bfd_get_elt_at_index) PARAMS ((bfd *, symindex));
  int         (*_bfd_stat_arch_elt) PARAMS ((bfd *, struct stat *));
  bfd_boolean (*_bfd_update_armap_timestamp) PARAMS ((bfd *));
d4219 17
a4235 16
CONCAT2 (NAME,_get_symtab_upper_bound), \
CONCAT2 (NAME,_get_symtab), \
CONCAT2 (NAME,_make_empty_symbol), \
CONCAT2 (NAME,_print_symbol), \
CONCAT2 (NAME,_get_symbol_info), \
CONCAT2 (NAME,_bfd_is_local_label_name), \
CONCAT2 (NAME,_get_lineno), \
CONCAT2 (NAME,_find_nearest_line), \
CONCAT2 (NAME,_bfd_make_debug_symbol), \
CONCAT2 (NAME,_read_minisymbols), \
CONCAT2 (NAME,_minisymbol_to_symbol)
  long        (*_bfd_get_symtab_upper_bound) PARAMS ((bfd *));
  long        (*_bfd_canonicalize_symtab) PARAMS ((bfd *,
                                                struct symbol_cache_entry **));
  struct symbol_cache_entry *
              (*_bfd_make_empty_symbol) PARAMS ((bfd *));
d4237 2
a4238 2
    PARAMS ((bfd *, PTR, struct symbol_cache_entry *, bfd_print_symbol_type));
#define bfd_print_symbol(b,p,s,e) BFD_SEND(b, _bfd_print_symbol, (b,p,s,e))
d4240 3
a4242 3
    PARAMS ((bfd *, struct symbol_cache_entry *, symbol_info *));
#define bfd_get_symbol_info(b,p,e) BFD_SEND(b, _bfd_get_symbol_info, (b,p,e))
  bfd_boolean (*_bfd_is_local_label_name) PARAMS ((bfd *, const char *));
d4244 1
a4244 1
  alent *     (*_get_lineno) PARAMS ((bfd *, struct symbol_cache_entry *));
d4246 2
a4247 2
    PARAMS ((bfd *, struct sec *, struct symbol_cache_entry **, bfd_vma,
             const char **, const char **, unsigned int *));
d4252 1
a4252 1
    PARAMS ((bfd *, void *, unsigned long size));
d4256 1
a4256 1
    PARAMS ((bfd *, bfd_boolean, PTR *, unsigned int *));
d4260 1
a4260 1
    PARAMS ((bfd *, bfd_boolean, const PTR, asymbol *));
d4264 5
a4268 4
CONCAT2 (NAME,_get_reloc_upper_bound), \
CONCAT2 (NAME,_canonicalize_reloc), \
CONCAT2 (NAME,_bfd_reloc_type_lookup)
  long        (*_get_reloc_upper_bound) PARAMS ((bfd *, sec_ptr));
d4270 1
a4270 1
    PARAMS ((bfd *, sec_ptr, arelent **, struct symbol_cache_entry **));
d4273 1
a4273 1
              (*reloc_type_lookup) PARAMS ((bfd *, bfd_reloc_code_real_type));
d4277 3
a4279 2
CONCAT2 (NAME,_set_arch_mach), \
CONCAT2 (NAME,_set_section_contents)
d4281 1
a4281 1
    PARAMS ((bfd *, enum bfd_architecture, unsigned long));
d4283 1
a4283 1
    PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
d4287 14
a4300 13
CONCAT2 (NAME,_sizeof_headers), \
CONCAT2 (NAME,_bfd_get_relocated_section_contents), \
CONCAT2 (NAME,_bfd_relax_section), \
CONCAT2 (NAME,_bfd_link_hash_table_create), \
CONCAT2 (NAME,_bfd_link_hash_table_free), \
CONCAT2 (NAME,_bfd_link_add_symbols), \
CONCAT2 (NAME,_bfd_link_just_syms), \
CONCAT2 (NAME,_bfd_final_link), \
CONCAT2 (NAME,_bfd_link_split_section), \
CONCAT2 (NAME,_bfd_gc_sections), \
CONCAT2 (NAME,_bfd_merge_sections), \
CONCAT2 (NAME,_bfd_discard_group)
  int         (*_bfd_sizeof_headers) PARAMS ((bfd *, bfd_boolean));
d4302 2
a4303 2
    PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *,
             bfd_byte *, bfd_boolean, struct symbol_cache_entry **));
d4306 1
a4306 1
    PARAMS ((bfd *, struct sec *, struct bfd_link_info *, bfd_boolean *));
d4311 1
a4311 1
              (*_bfd_link_hash_table_create) PARAMS ((bfd *));
d4314 1
a4314 2
  void        (*_bfd_link_hash_table_free)
    PARAMS ((struct bfd_link_hash_table *));
d4317 1
a4317 2
  bfd_boolean (*_bfd_link_add_symbols)
    PARAMS ((bfd *, struct bfd_link_info *));
d4320 1
a4320 2
  void        (*_bfd_link_just_syms)
    PARAMS ((asection *, struct bfd_link_info *));
d4324 1
a4324 1
  bfd_boolean (*_bfd_final_link) PARAMS ((bfd *, struct bfd_link_info *));
d4327 1
a4327 1
  bfd_boolean (*_bfd_link_split_section) PARAMS ((bfd *, struct sec *));
d4330 1
a4330 1
  bfd_boolean (*_bfd_gc_sections) PARAMS ((bfd *, struct bfd_link_info *));
d4333 1
a4333 1
  bfd_boolean (*_bfd_merge_sections) PARAMS ((bfd *, struct bfd_link_info *));
d4336 1
a4336 1
  bfd_boolean (*_bfd_discard_group) PARAMS ((bfd *, struct sec *));
d4340 5
a4344 4
CONCAT2 (NAME,_get_dynamic_symtab_upper_bound), \
CONCAT2 (NAME,_canonicalize_dynamic_symtab), \
CONCAT2 (NAME,_get_dynamic_reloc_upper_bound), \
CONCAT2 (NAME,_canonicalize_dynamic_reloc)
d4346 1
a4346 1
  long        (*_bfd_get_dynamic_symtab_upper_bound) PARAMS ((bfd *));
d4349 1
a4349 1
    PARAMS ((bfd *, struct symbol_cache_entry **));
d4351 1
a4351 1
  long        (*_bfd_get_dynamic_reloc_upper_bound) PARAMS ((bfd *));
d4354 1
a4354 1
    PARAMS ((bfd *, arelent **, struct symbol_cache_entry **));
d4361 1
a4361 1
  PTR backend_data;
d4365 1
a4365 2
bfd_boolean
bfd_set_default_target PARAMS ((const char *name));
d4367 1
a4367 2
const bfd_target *
bfd_find_target PARAMS ((const char *target_name, bfd *abfd));
d4369 1
a4369 2
const char **
bfd_target_list PARAMS ((void));
d4371 3
a4373 4
const bfd_target *
bfd_search_for_target PARAMS ((int (* search_func)
       (const bfd_target *, void *),
    void *));
d4376 1
a4376 2
bfd_boolean
bfd_check_format PARAMS ((bfd *abfd, bfd_format format));
d4378 2
a4379 3
bfd_boolean
bfd_check_format_matches PARAMS ((bfd *abfd, bfd_format format,
    char ***matching));
d4381 1
a4381 2
bfd_boolean
bfd_set_format PARAMS ((bfd *abfd, bfd_format format));
d4383 1
a4383 2
const char *
bfd_format_string PARAMS ((bfd_format format));
d4386 1
a4386 2
bfd_boolean
bfd_link_split_section PARAMS ((bfd *abfd, asection *sec));
d4392 2
a4393 2
bfd_byte *
bfd_simple_get_relocated_section_contents PARAMS ((bfd *abfd, asection *sec, bfd_byte *outbuf, asymbol **symbol_table));
@


1.8
log
@resolve conflicts.
@
text
@d1 7
d9 4
a12 3
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
   Free Software Foundation, Inc.
d15 15
a29 38
** NOTE: bfd.h and bfd-in2.h are GENERATED files.  Don't change them;
** instead, change bfd-in.h or the other BFD source files processed to
** generate these files.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* bfd.h -- The only header file required by users of the bfd library

The bfd.h file is generated from bfd-in.h and various .c files; if you
change it, your changes will probably be lost.

All the prototypes and definitions following the comment "THE FOLLOWING
IS EXTRACTED FROM THE SOURCE" are extracted from the source files for
BFD.  If you change it, someone oneday will extract it from the source
again, and your changes will be lost.  To save yourself from this bind,
change the definitions in the source in the bfd directory.  Type "make
docs" and then "make headers" in that directory, and magically this file
will change to reflect your changes.

If you don't have the tools to perform the extraction, then you are
safe from someone on your system trampling over your header files.
You should still maintain the equivalence between the source and this
file though; every change you make to the .c file should be reflected
here.  */
d39 12
d52 3
a54 2
/* These two lines get substitutions done by commands in Makefile.in.  */
#define BFD_VERSION  "@@VERSION@@"
d56 4
d78 2
a79 2
/* forward declaration */
typedef struct _bfd bfd;
d81 21
a101 28
/* To squelch erroneous compiler warnings ("illegal pointer
   combination") from the SVR3 compiler, we would like to typedef
   boolean to int (it doesn't like functions which return boolean.
   Making sure they are never implicitly declared to return int
   doesn't seem to help).  But this file is not configured based on
   the host.  */
/* General rules: functions which are boolean return true on success
   and false on failure (unless they're a predicate).   -- bfd.doc */
/* I'm sure this is going to break something and someone is going to
   force me to change it.  */
/* typedef enum boolean {false, true} boolean; */
/* Yup, SVR4 has a "typedef enum boolean" in <sys/types.h>  -fnf */
/* It gets worse if the host also defines a true/false enum... -sts */
/* And even worse if your compiler has built-in boolean types... -law */
#if defined (__GNUG__) && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 6))
#define TRUE_FALSE_ALREADY_DEFINED
#endif
#ifdef MPW
/* Pre-emptive strike - get the file with the enum.  */
#include <Types.h>
#define TRUE_FALSE_ALREADY_DEFINED
#endif /* MPW */
#ifndef TRUE_FALSE_ALREADY_DEFINED
typedef enum bfd_boolean {false, true} boolean;
#define BFD_TRUE_FALSE
#else
/* Use enum names that will appear nowhere else.  */
typedef enum bfd_boolean {bfd_fffalse, bfd_tttrue} boolean;
a103 10
/* A pointer to a position in a file.  */
/* FIXME:  This should be using off_t from <sys/types.h>.
   For now, try to avoid breaking stuff by not including <sys/types.h> here.
   This will break on systems with 64-bit file offsets (e.g. 4.4BSD).
   Probably the best long-term answer is to avoid using file_ptr AND off_t
   in this header file, and to handle this in the BFD implementation
   rather than in its interface.  */
/* typedef off_t	file_ptr; */
typedef long int file_ptr;

d171 16
d188 1
d193 1
a193 1
/** File formats */
d195 9
a203 7
typedef enum bfd_format {
	      bfd_unknown = 0,	/* file format is unknown */
	      bfd_object,	/* linker/assember/compiler output */
	      bfd_archive,	/* object archive file */
	      bfd_core,		/* core dump */
	      bfd_type_end}	/* marks the end; don't use it! */
         bfd_format;
d261 3
d265 1
a265 1
/* symbols and relocation */
d289 3
a291 2
/* This is a type pun with struct ranlib on purpose! */
typedef struct carsym {
d293 3
a295 2
  file_ptr file_offset;		/* look here to find the file */
} carsym;			/* to make these you call a carsymogen */
d298 10
a307 5
   Perhaps just a forward definition would do? */
struct orl {			/* output ranlib */
  char **name;			/* symbol name */
  file_ptr pos;			/* bfd* or file position */
  int namidx;			/* index into string table */
d310 8
a317 6
/* Linenumber stuff */
typedef struct lineno_cache_entry {
  unsigned int line_number;	/* Linenumber from start of function*/
  union {
    struct symbol_cache_entry *sym; /* Function name */
    unsigned long offset;	/* Offset into section */
d319 2
a320 1
} alent;
d322 1
a322 1
/* object and core file sections */
d325 1
a325 1
	( ((addr) + ((1<<(align))-1)) & (-1 << (align)))
d331 1
d343 3
a345 3
#define bfd_set_section_vma(bfd, ptr, val) (((ptr)->vma = (ptr)->lma= (val)), ((ptr)->user_set_vma = (boolean)true), true)
#define bfd_set_section_alignment(bfd, ptr, val) (((ptr)->alignment_power = (val)),true)
#define bfd_set_section_userdata(bfd, ptr, val) (((ptr)->userdata = (val)),true)
d362 1
a362 1
  CONST char *name;            /* Symbol name.  */
d366 1
a366 1
  CONST char *stab_name;       /* String for stab type.  */
d371 2
a372 1
extern const char *bfd_get_stab_name PARAMS ((int));
d405 2
a406 3
  struct bfd_hash_entry *(*newfunc) PARAMS ((struct bfd_hash_entry *,
					     struct bfd_hash_table *,
					     const char *));
d413 1
a413 1
extern boolean bfd_hash_table_init
d420 1
a420 1
extern boolean bfd_hash_table_init_n
d428 2
a429 1
extern void bfd_hash_table_free PARAMS ((struct bfd_hash_table *));
d431 1
a431 1
/* Look up a string in a hash table.  If CREATE is true, a new entry
d433 1
a433 1
   COPY argument must be true if this routine should copy the string
d436 2
a437 2
  PARAMS ((struct bfd_hash_table *, const char *, boolean create,
	   boolean copy));
d450 2
a451 2
extern PTR bfd_hash_allocate PARAMS ((struct bfd_hash_table *,
				      unsigned int));
d454 1
a454 1
   element.  If the function returns false, the traversal stops.  The
d456 4
a459 29
extern void bfd_hash_traverse PARAMS ((struct bfd_hash_table *,
				       boolean (*) (struct bfd_hash_entry *,
						    PTR),
				       PTR info));

/* Semi-portable string concatenation in cpp.
   The CAT4 hack is to avoid a problem with some strict ANSI C preprocessors.
   The problem is, "32_" is not a valid preprocessing token, and we don't
   want extra underscores (e.g., "nlm_32_").  The XCAT2 macro will cause the
   inner CAT macros to be evaluated first, producing still-valid pp-tokens.
   Then the final concatenation can be done.  (Sigh.)  */
#ifndef CAT
#ifdef SABER
#define CAT(a,b)	a##b
#define CAT3(a,b,c)	a##b##c
#define CAT4(a,b,c,d)	a##b##c##d
#else
#if defined(__STDC__) || defined(ALMOST_STDC)
#define CAT(a,b) a##b
#define CAT3(a,b,c) a##b##c
#define XCAT2(a,b)	CAT(a,b)
#define CAT4(a,b,c,d)	XCAT2(CAT(a,b),CAT(c,d))
#else
#define CAT(a,b) a/**/b
#define CAT3(a,b,c) a/**/b/**/c
#define CAT4(a,b,c,d)	a/**/b/**/c/**/d
#endif
#endif
#endif
d462 2
a463 2

/* User program access to BFD facilities */
d468 31
a498 8
extern bfd_size_type bfd_read
  PARAMS ((PTR, bfd_size_type size, bfd_size_type nitems, bfd *abfd));
extern bfd_size_type bfd_write
  PARAMS ((const PTR, bfd_size_type size, bfd_size_type nitems, bfd *abfd));
extern int bfd_seek PARAMS ((bfd *abfd, file_ptr fp, int direction));
extern long bfd_tell PARAMS ((bfd *abfd));
extern int bfd_flush PARAMS ((bfd *abfd));
extern int bfd_stat PARAMS ((bfd *abfd, struct stat *));
d530 2
d534 1
a534 1
#define bfd_set_cacheable(abfd,bool) (((abfd)->cacheable = (boolean) (bool)), true)
d536 7
a542 3
extern boolean bfd_record_phdr
  PARAMS ((bfd *, unsigned long, boolean, flagword, boolean, bfd_vma,
	   boolean, boolean, unsigned int, struct sec **));
d546 36
a581 18
bfd_vma		bfd_getb64	   PARAMS ((const unsigned char *));
bfd_vma 	bfd_getl64	   PARAMS ((const unsigned char *));
bfd_signed_vma	bfd_getb_signed_64 PARAMS ((const unsigned char *));
bfd_signed_vma	bfd_getl_signed_64 PARAMS ((const unsigned char *));
bfd_vma		bfd_getb32	   PARAMS ((const unsigned char *));
bfd_vma		bfd_getl32	   PARAMS ((const unsigned char *));
bfd_signed_vma	bfd_getb_signed_32 PARAMS ((const unsigned char *));
bfd_signed_vma	bfd_getl_signed_32 PARAMS ((const unsigned char *));
bfd_vma		bfd_getb16	   PARAMS ((const unsigned char *));
bfd_vma		bfd_getl16	   PARAMS ((const unsigned char *));
bfd_signed_vma	bfd_getb_signed_16 PARAMS ((const unsigned char *));
bfd_signed_vma	bfd_getl_signed_16 PARAMS ((const unsigned char *));
void		bfd_putb64	   PARAMS ((bfd_vma, unsigned char *));
void		bfd_putl64	   PARAMS ((bfd_vma, unsigned char *));
void		bfd_putb32	   PARAMS ((bfd_vma, unsigned char *));
void		bfd_putl32	   PARAMS ((bfd_vma, unsigned char *));
void		bfd_putb16	   PARAMS ((bfd_vma, unsigned char *));
void		bfd_putl16	   PARAMS ((bfd_vma, unsigned char *));
d585 4
a588 2
bfd_vma         bfd_get_bits       PARAMS ((bfd_byte *, int, boolean));
void            bfd_put_bits       PARAMS ((bfd_vma, bfd_byte *, int, boolean));
d601 5
a605 3
extern bfd_vma bfd_ecoff_get_gp_value PARAMS ((bfd * abfd));
extern boolean bfd_ecoff_set_gp_value PARAMS ((bfd *abfd, bfd_vma gp_value));
extern boolean bfd_ecoff_set_regmasks
d616 1
a616 1
extern boolean bfd_ecoff_debug_accumulate
d622 1
a622 1
extern boolean bfd_ecoff_debug_accumulate_other
d626 1
a626 1
extern boolean bfd_ecoff_debug_externals
d629 3
a631 3
	   boolean relocateable,
	   boolean (*get_extr) (struct symbol_cache_entry *,
				struct ecoff_extr *),
d634 1
a634 1
extern boolean bfd_ecoff_debug_one_external
d641 1
a641 1
extern boolean bfd_ecoff_write_debug
d644 1
a644 1
extern boolean bfd_ecoff_write_accumulated_debug
d648 1
a648 1
extern boolean bfd_mips_ecoff_create_embedded_relocs
d661 4
a664 4
extern boolean bfd_elf32_record_link_assignment
  PARAMS ((bfd *, struct bfd_link_info *, const char *, boolean));
extern boolean bfd_elf64_record_link_assignment
  PARAMS ((bfd *, struct bfd_link_info *, const char *, boolean));
d667 1
a667 1
extern boolean bfd_elf_get_bfd_needed_list
d669 2
a670 2
extern boolean bfd_elf32_size_dynamic_sections
  PARAMS ((bfd *, const char *, const char *, boolean, const char *,
d673 2
a674 2
extern boolean bfd_elf64_size_dynamic_sections
  PARAMS ((bfd *, const char *, const char *, boolean, const char *,
d677 6
a682 3
extern void bfd_elf_set_dt_needed_name PARAMS ((bfd *, const char *));
extern void bfd_elf_set_dt_needed_soname PARAMS ((bfd *, const char *));
extern const char *bfd_elf_get_dt_soname PARAMS ((bfd *));
d685 4
d693 2
a694 1
extern long bfd_get_elf_phdr_upper_bound PARAMS ((bfd *abfd));
d703 2
a704 1
extern int bfd_get_elf_phdrs PARAMS ((bfd *abfd, void *phdrs));
d707 2
a708 1
extern int bfd_get_arch_size PARAMS ((bfd *));
d710 3
a712 2
/* Return true if address "naturally" sign extends, or -1 if not elf.  */
extern int bfd_get_sign_extend_vma PARAMS ((bfd *));
d714 4
a717 1
extern boolean bfd_m68k_elf32_create_embedded_relocs
d725 1
a725 1
extern boolean bfd_sunos_record_link_assignment
d727 1
a727 1
extern boolean bfd_sunos_size_dynamic_sections
d733 1
a733 1
extern boolean bfd_i386linux_size_dynamic_sections
d735 1
a735 1
extern boolean bfd_m68klinux_size_dynamic_sections
d737 1
a737 1
extern boolean bfd_sparclinux_size_dynamic_sections
d745 2
a746 1
typedef struct _bfd_window {
d757 2
a758 1
} bfd_window;
d760 6
a765 4
extern void bfd_init_window PARAMS ((bfd_window *));
extern void bfd_free_window PARAMS ((bfd_window *));
extern boolean bfd_get_file_window
  PARAMS ((bfd *, file_ptr, bfd_size_type, bfd_window *, boolean));
d769 1
a769 1
extern boolean bfd_xcoff_link_record_set
d772 1
a772 4
extern boolean bfd_xcoff_import_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *,
	   bfd_vma, const char *, const char *, const char *));
extern boolean bfd_xcoff_export_symbol
d774 4
a777 2
	   boolean));
extern boolean bfd_xcoff_link_count_reloc
d779 1
a779 1
extern boolean bfd_xcoff_record_link_assignment
d781 1
a781 1
extern boolean bfd_xcoff_size_dynamic_sections
d783 8
a790 2
	   unsigned long, unsigned long, unsigned long, boolean,
	   int, boolean, boolean, struct sec **));
d799 1
a799 1
extern boolean bfd_coff_get_syment
d802 1
a802 1
extern boolean bfd_coff_get_auxent
d805 1
a805 1
extern boolean bfd_coff_set_symbol_class
d808 1
a808 1
extern boolean bfd_m68k_coff_create_embedded_relocs
d813 1
a813 1
extern boolean bfd_arm_allocate_interworking_sections
d816 1
a816 1
extern boolean bfd_arm_process_before_allocation
d819 1
a819 1
extern boolean bfd_arm_get_bfd_for_interworking
d823 1
a823 1
extern boolean bfd_arm_pe_allocate_interworking_sections
d826 1
a826 1
extern boolean bfd_arm_pe_process_before_allocation
d829 1
a829 1
extern boolean bfd_arm_pe_get_bfd_for_interworking
d833 1
a833 1
extern boolean bfd_elf32_arm_allocate_interworking_sections
d836 1
a836 1
extern boolean bfd_elf32_arm_process_before_allocation
d839 4
a842 1
extern boolean bfd_elf32_arm_get_bfd_for_interworking
d845 10
d862 1
a862 1
/* And more from the source.  */
d866 1
d868 1
a868 1
bfd_openr PARAMS ((CONST char *filename, CONST char *target));
d871 1
a871 1
bfd_fdopenr PARAMS ((CONST char *filename, CONST char *target, int fd));
d877 1
a877 1
bfd_openw PARAMS ((CONST char *filename, CONST char *target));
d879 1
a879 1
boolean
d882 1
a882 1
boolean
d886 1
a886 1
bfd_create PARAMS ((CONST char *filename, bfd *templ));
d888 1
a888 1
boolean
d891 1
a891 1
boolean
d894 4
d906 1
a906 1
                (*(unsigned char *) (ptr))
d908 1
a908 1
               ((*(unsigned char *) (ptr) ^ 0x80) - 0x80)
d938 1
a938 1
                ((bits) == 8 ? bfd_get_8 (abfd, ptr)           \
d945 1
a945 1
                ((bits) == 8 ? bfd_put_8 (abfd, val, ptr)      \
d955 1
a955 1
               bfd_put_8 (abfd, val, ptr)
d957 1
a957 1
               bfd_put_8 (abfd, val, ptr)
d959 1
a959 1
               bfd_get_8 (abfd, ptr)
d961 1
a961 1
               bfd_get_signed_8 (abfd, ptr)
d964 1
a964 1
                BFD_SEND(abfd, bfd_h_putx16,(val,ptr))
d966 1
a966 1
                bfd_h_put_16
d968 1
a968 1
                BFD_SEND(abfd, bfd_h_getx16,(ptr))
d970 1
a970 1
                BFD_SEND(abfd, bfd_h_getx_signed_16, (ptr))
d973 1
a973 1
                BFD_SEND(abfd, bfd_h_putx32,(val,ptr))
d975 1
a975 1
                bfd_h_put_32
d977 1
a977 1
                BFD_SEND(abfd, bfd_h_getx32,(ptr))
d979 1
a979 1
                BFD_SEND(abfd, bfd_h_getx_signed_32, (ptr))
d982 1
a982 1
                BFD_SEND(abfd, bfd_h_putx64,(val, ptr))
d984 1
a984 1
                bfd_h_put_64
d986 1
a986 1
                BFD_SEND(abfd, bfd_h_getx64,(ptr))
d988 26
a1013 1
                BFD_SEND(abfd, bfd_h_getx_signed_64, (ptr))
d1015 32
a1067 1

a1070 1

d1073 1
a1073 2
  /* Which section is it; 0..nth.  */

a1076 1

a1081 1

d1098 5
a1102 3
#if 0   /* Obsolete ? */
#define SEC_BALIGN     0x008
#endif
a1127 6
  /* The section is a constructor, and should be placed at the
     end of the text, data, or bss section(?).  */
#define SEC_CONSTRUCTOR_TEXT 0x1100
#define SEC_CONSTRUCTOR_DATA 0x2100
#define SEC_CONSTRUCTOR_BSS  0x3100

d1148 3
d1182 4
a1185 3
  /* The contents of this section are to be sorted by the
     based on the address specified in the associated symbol
     table.  */
d1243 12
d1269 1
a1269 1
     output sections that have a input section.  */
d1275 3
a1277 1
  /* Used by the ELF code to mark sections which have been allocated to segments.  */
d1280 26
a1313 1

d1318 1
a1318 2
      information. */

a1323 1

a1328 1

a1337 1

a1340 1

a1344 1

a1348 1

a1352 1

d1355 1
a1355 2
  /* The number of relocation records in one of the above  */

a1361 1

a1364 1

a1367 1

a1370 1

a1377 1

d1381 1
d1383 2
a1384 1
  unsigned int lineno_count;
a1386 1

a1388 4
  /* Points to the kept section if this section is a link-once section,
     and is discarded.  */
  struct sec *kept_section;

a1390 1

a1393 1

a1399 1

a1402 1

d1405 1
a1405 1
  /* A symbol which points at this section only */
d1411 1
a1411 1
} asection ;
d1423 1
a1423 1
/* the absolute section */
d1427 1
a1427 1
/* Pointer to the undefined section */
d1431 1
a1431 1
/* Pointer to the common section */
d1434 1
a1434 1
/* Pointer to the indirect section */
d1439 6
d1455 29
d1501 1
a1501 1
boolean
d1511 1
a1511 1
boolean
d1514 3
a1516 5
boolean
bfd_set_section_contents PARAMS ((bfd *abfd,
    asection *section,
    PTR data,
    file_ptr offset,
d1519 4
a1522 3
boolean
bfd_get_section_contents PARAMS ((bfd *abfd, asection *section, PTR location,
    file_ptr offset, bfd_size_type count));
d1524 3
a1526 2
boolean
bfd_copy_private_section_data PARAMS ((bfd *ibfd, asection *isec, bfd *obfd, asection *osec));
d1534 4
d1540 2
a1541 2
  bfd_arch_unknown,   /* File arch not known */
  bfd_arch_obscure,   /* Arch known, not one of these */
d1563 1
a1563 1
       "core". */
d1574 2
d1583 1
a1583 1
#define bfd_mach_sparc_v8plusa         5 /* with ultrasparc add'ns */
d1586 3
a1588 3
#define bfd_mach_sparc_v9a             8 /* with ultrasparc add'ns */
#define bfd_mach_sparc_v8plusb         9 /* with cheetah add'ns */
#define bfd_mach_sparc_v9b             10 /* with cheetah add'ns */
d1600 1
d1606 2
a1612 2
#define bfd_mach_mips32                32
#define bfd_mach_mips32_4k             3204113 /* 32, 04, octal 'K' */
a1613 1
#define bfd_mach_mips64                64
d1615 3
d1619 5
a1623 5
#define bfd_mach_i386_i386 0
#define bfd_mach_i386_i8086 1
#define bfd_mach_i386_i386_intel_syntax 2
#define bfd_mach_x86_64 3
#define bfd_mach_x86_64_intel_syntax 4
d1632 1
d1634 7
a1640 4
  bfd_arch_h8300,     /* Hitachi H8/300 */
#define bfd_mach_h8300   1
#define bfd_mach_h8300h  2
#define bfd_mach_h8300s  3
d1642 2
a1643 1
#define bfd_mach_ppc           0
d1660 1
d1662 1
a1662 1
#define bfd_mach_rs6k          0
d1668 1
a1668 1
#define bfd_mach_d10v          0
d1672 1
d1675 3
d1681 3
a1683 3
  bfd_arch_h8500,     /* Hitachi H8/500 */
  bfd_arch_sh,        /* Hitachi SH */
#define bfd_mach_sh            0
d1686 1
d1691 1
d1696 2
a1697 1
  bfd_arch_arm,       /* Advanced Risc Machines ARM */
d1708 2
d1713 3
d1719 1
a1719 1
#define bfd_mach_v850          0
a1720 1
#define bfd_mach_v850ea        'A'
d1722 6
a1727 6
#define bfd_mach_arc_5         0
#define bfd_mach_arc_6         1
#define bfd_mach_arc_7         2
#define bfd_mach_arc_8         3
  bfd_arch_m32r,      /* Mitsubishi M32R/D */
#define bfd_mach_m32r          0 /* backwards compatibility */
d1735 7
d1744 8
a1751 2
#define bfd_mach_ia64_elf64    0
#define bfd_mach_ia64_elf32    1
d1753 1
a1753 1
  bfd_arch_avr,       /* Atmel AVR microcontrollers */
d1760 23
d1796 4
a1799 2
  /* True if this is the default machine for the architecture.  */
  boolean the_default;
d1804 1
a1804 1
  boolean (*scan) PARAMS ((const struct bfd_arch_info *, const char *));
d1807 3
a1809 1
} bfd_arch_info_type;
d1822 2
a1823 1
    const bfd *bbfd));
d1858 1
d1861 1
a1861 1
       /* No errors detected */
d1864 1
a1864 1
       /* The relocation was performed, but there was an overflow. */
d1867 1
a1867 1
       /* The address to relocate was not within the section supplied. */
d1870 1
a1870 1
       /* Used by special functions */
d1873 1
a1873 1
       /* Unsupported relocation size requested. */
d1876 1
a1876 1
       /* Unused */
d1879 1
a1879 1
       /* The symbol to relocate against was undefined. */
d1882 4
a1885 4
       /* The relocation was performed, but may not be ok - presently
          generated only when linking i960 coff files with i960 b.out
          symbols.  If this type is returned, the error_message argument
          to bfd_perform_relocation will be set.  */
d1893 1
a1893 1
       /* A pointer into the canonical table of pointers  */
d1896 1
a1896 1
       /* offset in section */
d1899 1
a1899 1
       /* addend for relocation value */
d1902 1
a1902 1
       /* Pointer to how to perform the required relocation */
d1905 3
a1907 1
} arelent;
d1910 1
a1910 1
       /* Do not complain on overflow. */
d1913 2
a1914 2
       /* Complain if the bitfield overflows, whether it is considered
          as signed or unsigned. */
d1917 2
a1918 2
       /* Complain if the value overflows when considered as signed
          number. */
d1921 2
a1922 2
       /* Complain if the value overflows when considered as an
          unsigned number. */
d1928 6
a1933 6
       /*  The type field has mainly a documentary use - the back end can
           do what it wants with it, though normally the back end's
           external idea of what a reloc number is stored
           in this field. For example, a PC relative word relocation
           in a coff environment has the type 023 - because that's
           what the outside world calls a R_PCRWORD reloc. */
d1936 2
a1937 2
       /*  The value the final relocation is shifted right by. This drops
           unwanted data from the relocation.  */
d1940 3
a1942 3
       /*  The size of the item to be relocated.  This is *not* a
           power-of-two measure.  To get the number of bytes operated
           on by a type of relocation, use bfd_get_reloc_size.  */
d1945 2
a1946 2
       /*  The number of bits in the item to be relocated.  This is used
           when doing overflow checking.  */
d1949 5
a1953 5
       /*  Notes that the relocation is relative to the location in the
           data section of the addend. The relocation function will
           subtract from the relocation value the address of the location
           being relocated. */
  boolean pc_relative;
d1955 2
a1956 2
       /*  The bit position of the reloc value in the destination.
           The relocated value is left shifted by this amount. */
d1959 2
a1960 2
       /* What type of overflow error should be checked for when
          relocating. */
d1963 4
a1966 4
       /* If this field is non null, then the supplied function is
          called rather than the normal function. This allows really
          strange relocation methods to be accomodated (e.g., i960 callj
          instructions). */
d1968 2
a1969 7
                                   PARAMS ((bfd *abfd,
                                            arelent *reloc_entry,
                                            struct symbol_cache_entry *symbol,
                                            PTR data,
                                            asection *input_section,
                                            bfd *output_bfd,
                                            char **error_message));
d1971 1
a1971 1
       /* The textual name of the relocation type. */
d1974 25
a1998 24
       /* Some formats record a relocation addend in the section contents
          rather than with the relocation.  For ELF formats this is the
          distinction between USE_REL and USE_RELA (though the code checks
          for USE_REL == 1/0).  The value of this field is TRUE if the
          addend is recorded with the section contents; when performing a
          partial link (ld -r) the section contents (the data) will be
          modified.  The value of this field is FALSE if addends are
          recorded with the relocation (in arelent.addend); when performing
          a partial link the relocation will be modified.
          All relocations for all ELF USE_RELA targets should set this field
          to FALSE (values of TRUE should be looked on with suspicion).
          However, the converse is not true: not all relocations of all ELF
          USE_REL targets set this field to TRUE.  Why this is so is peculiar
          to each particular target.  For relocs that aren't used in partial
          links (e.g. GOT stuff) it doesn't matter what this is set to.  */
  boolean partial_inplace;

       /* The src_mask selects which parts of the read in data
          are to be used in the relocation sum.  E.g., if this was an 8 bit
          byte of data which we read and relocated, this would be
          0x000000ff. When we have relocs which have an addend, such as
          sun4 extended relocs, the value in the offset part of a
          relocating field is garbage so we never use it. In this case
          the mask would be 0x00000000. */
d2001 2
a2002 4
       /* The dst_mask selects which parts of the instruction are replaced
          into the instruction. In most cases src_mask == dst_mask,
          except in the above special case, where dst_mask would be
          0x000000ff, and src_mask would be 0x00000000.   */
d2005 8
a2012 7
       /* When some formats create PC relative instructions, they leave
          the value of the pc of the place being relocated in the offset
          slot of the instruction, so that a PC relative relocation can
          be made just by adding in an ordinary offset (e.g., sun3 a.out).
          Some formats leave the displacement part of an instruction
          empty (e.g., m88k bcs); this flag signals the fact.*/
  boolean pcrel_offset;
d2014 5
a2018 4
};
#define HOWTO(C, R,S,B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC) \
  {(unsigned)C,R,S,B, P, BI, O,SF,NAME,INPLACE,MASKSRC,MASKDST,PC}
#define NEWHOWTO( FUNCTION, NAME,SIZE,REL,IN) HOWTO(0,0,SIZE,0,REL,0,complain_overflow_dont,FUNCTION, NAME,false,0,0,IN)
d2021 17
a2037 1
  HOWTO((C),0,0,0,false,0,complain_overflow_dont,NULL,NULL,false,0,0,false)
a2038 11
#define HOWTO_PREPARE(relocation, symbol)      \
  {                                            \
  if (symbol != (asymbol *)NULL) {             \
    if (bfd_is_com_section (symbol->section)) { \
      relocation = 0;                          \
    }                                          \
    else {                                     \
      relocation = symbol->value;              \
    }                                          \
  }                                            \
}
d2042 2
a2043 1
typedef struct relent_chain {
d2045 4
a2048 2
  struct   relent_chain *next;
} arelent_chain;
d2075 1
a2075 1
/* Basic absolute relocations of N bits. */
d2088 1
a2088 1
The 24-bit relocation is used in some Intel 960 configurations. */
d2096 1
a2096 1
/* For ELF. */
d2106 1
d2111 1
d2119 1
a2119 1
/* Relocations used by 68K ELF. */
d2124 1
a2124 1
/* Linkage-table relative. */
d2133 1
a2133 1
/* Absolute 8-bit relocation, but used to form an address like 0xFFnn. */
d2141 1
a2141 1
displacement is used on the Alpha. */
d2147 1
a2147 1
the target word.  These are used on the SPARC. */
d2154 1
a2154 1
decided relatively late. */
d2158 1
a2158 1
/* Reloc types used for i960/b.out. */
d2162 1
a2162 1
relocation types already defined. */
d2181 1
a2181 1
/* I think these are specific to SPARC a.out (e.g., Sun 4). */
d2185 1
a2185 1
/* SPARC64 relocations */
d2202 1
d2211 1
a2211 1
/* SPARC little endian relocation */
d2214 26
d2245 1
a2245 1
the "ldah" instruction (which is at the address of this reloc). */
d2251 1
a2251 1
reading, for convenience. */
d2256 1
a2256 1
relocation. */
d2281 1
a2281 3
3 - jsr (target of branch)

The GNU linker currently doesn't do any of this optimizing. */
a2285 11
/* The BFD_RELOC_ALPHA_USER_* relocations are used by the assembler to
process the explicit !<reloc>!sequence relocations, and are mapped
into the normal relocations at the end of processing. */
  BFD_RELOC_ALPHA_USER_LITERAL,
  BFD_RELOC_ALPHA_USER_LITUSE_BASE,
  BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF,
  BFD_RELOC_ALPHA_USER_LITUSE_JSR,
  BFD_RELOC_ALPHA_USER_GPDISP,
  BFD_RELOC_ALPHA_USER_GPRELHIGH,
  BFD_RELOC_ALPHA_USER_GPRELLOW,

d2288 1
a2288 1
prediction logic which may be provided on some processors. */
d2292 1
a2292 1
which is filled by the linker. */
d2296 1
a2296 1
which is filled by the linker. */
d2299 25
d2325 1
a2325 1
simple reloc otherwise. */
d2328 1
a2328 1
/* The MIPS16 jump instruction. */
d2331 1
a2331 1
/* MIPS16 GP relative reloc. */
d2334 1
a2334 1
/* High 16 bits of 32-bit value; simple reloc. */
d2340 1
a2340 1
to compensate for the borrow when the low bits are added. */
d2343 1
a2343 1
/* Low 16 bits. */
d2346 1
a2346 1
/* Like BFD_RELOC_HI16_S, but PC relative. */
d2349 1
a2349 1
/* Like BFD_RELOC_LO16, but PC relative. */
d2352 1
a2352 4
/* Relocation relative to the global pointer. */
#define BFD_RELOC_MIPS_GPREL BFD_RELOC_GPREL16

/* Relocation against a MIPS literal section. */
d2355 1
a2355 1
/* MIPS ELF relocations. */
a2357 1
#define BFD_RELOC_MIPS_GPREL32 BFD_RELOC_GPREL32
d2378 11
d2390 1
a2390 1
/* i386/elf relocations */
d2399 12
d2412 1
a2412 1
/* x86-64/elf relocations */
d2421 8
d2430 1
a2430 1
/* ns32k relocations */
d2444 5
a2448 1
/* Picojava relocs.  Not all of these appear in object files. */
d2456 1
a2456 1
/* Power(rs6000) and PowerPC relocations. */
d2487 65
d2553 1
a2553 1
/* IBM 370/390 relocations */
d2558 1
a2558 1
It generally does map to one of the other relocation types. */
d2562 1
a2562 1
not stored in the instruction. */
d2567 1
a2567 1
field in the instruction. */
d2572 1
a2572 1
field in the instruction. */
d2576 1
a2576 1
(at present) written to any object files. */
d2584 1
d2605 1
a2605 1
/* Hitachi SH relocs.  Not all of these appear in object files. */
d2631 57
d2690 1
a2690 1
be zero and is not stored in the instruction. */
d2698 1
a2698 1
through 7 of the instruction. */
d2703 1
a2703 1
through 0. */
d2708 1
a2708 1
assumed to be 0. */
d2715 1
a2715 1
shifted left 15 bits. */
d2719 1
a2719 1
assumed to be 0. */
d2723 1
a2723 1
assumed to be 0. */
d2727 1
a2727 1
This is a 6-bit absolute reloc. */
d2731 1
a2731 1
the right 3 bits assumed to be 0. */
d2737 1
a2737 1
of the container. */
d2741 1
a2741 1
right 3 bitsassumed to be 0. */
d2745 1
a2745 1
the right 3 bits assumed to be 0. */
d2751 1
a2751 1
of the container. */
d2755 1
a2755 1
the right 3 bits assumed to be 0. */
d2759 1
a2759 1
the right 3 bits assumed to be 0. */
d2765 1
a2765 1
of the container. */
d2768 1
a2768 1
/* This is a 32-bit absolute reloc. */
d2771 1
a2771 1
/* This is a 32-bit pc-relative reloc. */
d2774 11
a2784 2
/* Mitsubishi M32R relocs.
This is a 24 bit absolute address. */
d2787 1
a2787 1
/* This is a 10-bit pc-relative reloc with the right 2 bits assumed to be 0. */
d2790 1
a2790 1
/* This is an 18-bit reloc with the right 2 bits assumed to be 0. */
d2793 1
a2793 1
/* This is a 26-bit reloc with the right 2 bits assumed to be 0. */
d2797 1
a2797 1
used when the lower 16 bits are treated as unsigned. */
d2801 1
a2801 1
used when the lower 16 bits are treated as signed. */
d2804 1
a2804 1
/* This is a 16-bit reloc containing the lower 16 bits of an address. */
d2808 1
a2808 1
add3, load, and store instructions. */
d2811 1
a2811 1
/* This is a 9-bit reloc */
d2814 1
a2814 1
/* This is a 22-bit reloc */
d2817 1
a2817 1
/* This is a 16 bit offset from the short data area pointer. */
d2821 1
a2821 1
short data area pointer. */
d2824 1
a2824 1
/* This is a 16 bit offset from the zero data area pointer. */
d2828 1
a2828 1
zero data area pointer. */
d2832 1
a2832 1
tiny data area pointer. */
d2836 1
a2836 1
data area pointer. */
d2839 1
a2839 1
/* This is a 7 bit offset from the tiny data area pointer. */
d2842 1
a2842 1
/* This is a 16 bit offset from the tiny data area pointer. */
d2846 1
a2846 1
data area pointer. */
d2849 1
a2849 1
/* This is a 4 bit offset from the tiny data area pointer. */
d2853 1
a2853 1
bits placed non-contigously in the instruction. */
d2857 1
a2857 1
bits placed non-contigously in the instruction. */
d2860 1
a2860 1
/* This is a 6 bit offset from the call table base pointer. */
d2863 1
a2863 1
/* This is a 16 bit offset from the call table base pointer. */
d2866 8
d2876 1
a2876 1
instruction. */
d2880 1
a2880 1
instruction. */
d2885 1
a2885 1
significant 8 bits of the opcode. */
d2890 1
a2890 1
significant 7 bits of the opcode. */
d2895 1
a2895 1
significant 9 bits of the opcode. */
d2898 1
a2898 1
/* This is an extended address 23-bit reloc for the tms320c54x. */
d2903 1
a2903 1
the opcode. */
d2908 1
a2908 1
the opcode. */
d2911 1
a2911 1
/* This is a 48 bit reloc for the FR30 that stores 32 bits. */
d2915 1
a2915 1
two sections. */
d2919 1
a2919 1
4 bits. */
d2923 1
a2923 1
into 8 bits. */
d2927 1
a2927 1
into 8 bits. */
d2931 1
a2931 1
into 8 bits. */
d2935 1
a2935 1
short offset into 8 bits. */
d2939 1
a2939 1
short offset into 11 bits. */
d2942 1
a2942 1
/* Motorola Mcore relocations. */
d2950 48
d2999 1
a2999 1
short offset into 7 bits. */
d3003 1
a3003 1
short offset into 12 bits. */
d3007 1
a3007 1
program memory address) into 16 bits. */
d3011 1
a3011 1
data memory address) into 8 bit immediate value of LDI insn. */
d3015 1
a3015 1
of data memory address) into 8 bit immediate value of LDI insn. */
d3019 1
a3019 1
of program memory address) into 8 bit immediate value of LDI insn. */
d3023 1
a3023 1
(usually data memory address) into 8 bit immediate value of SUBI insn. */
d3028 1
a3028 1
SUBI insn. */
d3033 1
a3033 1
of LDI or SUBI insn. */
d3037 1
a3037 1
command address) into 8 bit immediate value of LDI insn. */
d3041 1
a3041 1
of command address) into 8 bit immediate value of LDI insn. */
d3045 1
a3045 1
of command address) into 8 bit immediate value of LDI insn. */
d3049 1
a3049 1
(usually command address) into 8 bit immediate value of SUBI insn. */
d3054 1
a3054 1
of SUBI insn. */
d3059 1
a3059 1
value of SUBI insn. */
d3063 1
a3063 1
into 22 bits. */
d3066 134
d3216 1
a3216 1
this offset in the reloc's section offset. */
d3220 1
a3220 1
/* Intel IA64 Relocations. */
d3258 2
d3281 3
d3285 1
d3288 12
a3299 3
  BFD_RELOC_IA64_LTOFF_TP22,
  BFD_RELOC_IA64_LTOFF22X,
  BFD_RELOC_IA64_LDXMOV,
d3302 1
a3302 1
This is the 8 bits high part of an absolute address. */
d3306 1
a3306 1
This is the 8 bits low part of an absolute address. */
d3310 1
a3310 1
This is the 3 bits of a value. */
d3313 31
d3345 1
a3345 1
(at present) written to any object files. */
d3352 28
a3379 1
/* Intel i860 Relocations. */
d3412 66
d3486 1
d3490 18
a3507 19
       /* A pointer to the BFD which owns the symbol. This information
          is necessary so that a back end can work out what additional
          information (invisible to the application writer) is carried
          with the symbol.

          This field is *almost* redundant, since you can use section->owner
          instead, except that some symbols point to the global sections
          bfd_{abs,com,und}_section.  This could be fixed by making
          these globals be per-bfd (or per-target-flavor).  FIXME. */

  struct _bfd *the_bfd; /* Use bfd_asymbol_bfd(sym) to access this field. */

       /* The text of the symbol. The name is left alone, and not copied; the
          application may not alter it. */
  CONST char *name;

       /* The value of the symbol.  This really should be a union of a
          numeric value with a pointer, since some flags indicate that
          a pointer to another symbol is stored here.  */
d3510 1
a3510 2
       /* Attributes of a symbol: */

d3513 2
a3514 2
       /* The symbol has local scope; <<static>> in <<C>>. The value
          is the offset into the section of the data. */
d3517 2
a3518 2
       /* The symbol has global scope; initialized data in <<C>>. The
          value is the offset into the section of the data. */
d3521 7
a3527 7
       /* The symbol has global scope and is exported. The value is
          the offset into the section of the data. */
#define BSF_EXPORT     BSF_GLOBAL /* no real difference */

       /* A normal C symbol would be one of:
          <<BSF_LOCAL>>, <<BSF_FORT_COMM>>,  <<BSF_UNDEFINED>> or
          <<BSF_GLOBAL>> */
d3529 2
a3530 2
       /* The symbol is a debugging record. The value has an arbitary
          meaning, unless BSF_DEBUGGING_RELOC is also set.  */
d3533 2
a3534 2
       /* The symbol denotes a function entry point.  Used in ELF,
          perhaps others someday.  */
d3537 1
a3537 1
       /* Used by the linker. */
d3541 2
a3542 2
       /* A weak global symbol, overridable without warnings by
          a regular global symbol of the same name.  */
d3545 2
a3546 2
       /* This symbol was created to point to a section, e.g. ELF's
          STT_SECTION symbols.  */
d3549 2
a3550 2
       /* The symbol used to be a common symbol, but now it is
          allocated. */
d3553 1
a3553 1
       /* The default value for common data. */
d3556 5
a3560 6
       /* In some files the type of a symbol sometimes alters its
          location in an output file - ie in coff a <<ISFCN>> symbol
          which is also <<C_EXT>> symbol appears where it was
          declared and not at the end of a section.  This bit is set
          by the target BFD part to convey this information. */

d3563 1
a3563 1
       /* Signal that the symbol is the label of constructor section. */
d3566 4
a3569 4
       /* Signal that the symbol is a warning symbol.  The name is a
          warning.  The name of the next symbol is the one to warn about;
          if a reference is made to a symbol with the same name as the next
          symbol, a warning is issued by the linker. */
d3572 2
a3573 2
       /* Signal that the symbol is indirect.  This symbol is an indirect
          pointer to the symbol with the same name as the next symbol. */
d3576 2
a3577 2
       /* BSF_FILE marks symbols that contain a file name.  This is used
          for ELF STT_FILE symbols.  */
d3580 1
a3580 1
       /* Symbol is from dynamic linking information.  */
d3583 2
a3584 2
       /* The symbol denotes a data object.  Used in ELF, and perhaps
          others someday.  */
d3587 3
a3589 3
       /* This symbol is a debugging symbol.  The value is the offset
          into the section of the data.  BSF_DEBUGGING should be set
          as well.  */
d3592 3
d3597 3
a3599 3
       /* A pointer to the section to which this symbol is
          relative.  This will always be non NULL, there are special
          sections for undefined and absolute symbols.  */
d3602 1
a3602 1
       /* Back end special data.  */
d3607 4
a3610 1
    } udata;
a3611 1
} asymbol;
d3614 2
a3615 1
boolean
d3618 1
a3618 1
boolean
d3623 1
d3627 2
a3628 1
boolean
d3632 1
a3632 1
bfd_print_symbol_vandf PARAMS ((PTR file, asymbol *symbol));
d3636 4
d3642 1
d3646 1
a3646 1
boolean
d3652 1
a3652 1
boolean
d3658 3
a3660 1
struct _bfd
d3662 2
a3663 2
    /* The filename the application opened the BFD with.  */
    CONST char *filename;
d3665 2
a3666 2
    /* A pointer to the target jump table.             */
    const struct bfd_target *xvec;
d3668 2
a3669 8
    /* To avoid dragging too many header files into every file that
       includes `<<bfd.h>>', IOSTREAM has been declared as a "char
       *", and MTIME as a "long".  Their correct types, to which they
       are cast when used, are "FILE *" and "time_t".    The iostream
       is the result of an fopen on the filename.  However, if the
       BFD_IN_MEMORY flag is set, then iostream is actually a pointer
       to a bfd_in_memory struct.  */
    PTR iostream;
d3671 35
a3705 2
    /* Is the file descriptor being cached?  That is, can it be closed as
       needed, and re-opened when accessed later?  */
d3707 2
a3708 1
    boolean cacheable;
d3710 2
a3711 3
    /* Marks whether there was a default target specified when the
       BFD was opened. This is used to select which matching algorithm
       to use to choose the back end. */
d3713 9
a3721 1
    boolean target_defaulted;
d3723 2
a3724 2
    /* The caching routines use these to maintain a
       least-recently-used list of BFDs */
d3726 4
a3729 1
    struct _bfd *lru_prev, *lru_next;
d3731 3
a3733 2
    /* When a file is closed by the caching routines, BFD retains
       state information on the file here: */
d3735 2
a3736 1
    file_ptr where;
d3738 2
a3739 1
    /* and here: (``once'' means at least once) */
d3741 2
a3742 1
    boolean opened_once;
d3744 2
a3745 2
    /* Set if we have a locally maintained mtime value, rather than
       getting it from the file each time: */
d3747 3
a3749 1
    boolean mtime_set;
d3751 2
a3752 1
    /* File modified time, if mtime_set is true: */
d3754 2
a3755 1
    long mtime;
d3757 2
a3758 1
    /* Reserved for an unimplemented file locking extension.*/
d3760 2
a3761 1
    int ifd;
d3763 6
a3768 1
    /* The format which belongs to the BFD. (object, core, etc.) */
d3770 2
a3771 1
    bfd_format format;
d3773 3
a3775 1
    /* The direction the BFD was opened with*/
d3777 3
a3779 56
    enum bfd_direction {no_direction = 0,
                        read_direction = 1,
                        write_direction = 2,
                        both_direction = 3} direction;

    /* Format_specific flags*/

    flagword flags;

    /* Currently my_archive is tested before adding origin to
       anything. I believe that this can become always an add of
       origin, with origin set to 0 for non archive files.   */

    file_ptr origin;

    /* Remember when output has begun, to stop strange things
       from happening. */
    boolean output_has_begun;

    /* Pointer to linked list of sections*/
    struct sec  *sections;

    /* The number of sections */
    unsigned int section_count;

    /* Stuff only useful for object files:
       The start address. */
    bfd_vma start_address;

    /* Used for input and output*/
    unsigned int symcount;

    /* Symbol table for output BFD (with symcount entries) */
    struct symbol_cache_entry  **outsymbols;

    /* Pointer to structure which contains architecture information*/
    const struct bfd_arch_info *arch_info;

    /* Stuff only useful for archives:*/
    PTR arelt_data;
    struct _bfd *my_archive;     /* The containing archive BFD.  */
    struct _bfd *next;           /* The next BFD in the archive.  */
    struct _bfd *archive_head;   /* The first BFD in the archive.  */
    boolean has_armap;

    /* A chain of BFD structures involved in a link.  */
    struct _bfd *link_next;

    /* A field used by _bfd_generic_link_add_archive_symbols.  This will
       be used only for archive elements.  */
    int archive_pass;

    /* Used by the back end to hold private data. */

    union
      {
d3796 1
d3809 5
d3815 2
a3816 1
      } tdata;
d3818 2
a3819 2
    /* Used by the application to hold private data*/
    PTR usrdata;
d3824 1
a3824 1
    PTR memory;
d3833 1
d3849 2
a3850 1
} bfd_error_type;
d3858 1
a3858 1
CONST char *
d3862 1
a3862 1
bfd_perror PARAMS ((CONST char *message));
d3875 3
d3888 1
a3888 3
bfd_set_reloc PARAMS ((bfd *abfd, asection *sec, arelent **rel, unsigned int count)
    
    );
d3890 1
a3890 1
boolean
d3899 1
a3899 1
boolean
d3902 1
a3902 7
long
bfd_get_mtime PARAMS ((bfd *abfd));

long
bfd_get_size PARAMS ((bfd *abfd));

int
d3906 1
a3906 1
bfd_set_gp_size PARAMS ((bfd *abfd, int i));
d3909 1
a3909 1
bfd_scan_vma PARAMS ((CONST char *string, CONST char **end, int base));
d3911 1
a3911 1
boolean
d3917 1
a3917 1
boolean
d3923 1
a3923 1
boolean
d3927 1
a3927 2
     BFD_SEND (abfd, _bfd_set_private_flags, \
               (abfd, flags))
d3929 1
a3929 1
     BFD_SEND (abfd, _bfd_sizeof_headers, (abfd, reloc))
d3932 2
a3933 1
     BFD_SEND (abfd, _bfd_find_nearest_line,  (abfd, sec, syms, off, file, func, line))
a3934 1
       /* Do these three do anything useful at all, for any back end?  */
d3936 1
a3936 1
        BFD_SEND (abfd, _bfd_debug_info_start, (abfd))
d3939 1
a3939 1
        BFD_SEND (abfd, _bfd_debug_info_end, (abfd))
d3942 1
a3942 2
        BFD_SEND (abfd, _bfd_debug_info_accumulate, (abfd, section))

d3945 1
a3945 1
        BFD_SEND (abfd, _bfd_stat_arch_elt,(abfd, stat))
d3948 1
a3948 1
        BFD_SEND (abfd, _bfd_update_armap_timestamp, (abfd))
d3951 1
a3951 1
        BFD_SEND ( abfd, _bfd_set_arch_mach, (abfd, arch, mach))
d3959 6
d3968 3
d3974 3
d4001 16
a4016 1
                 boolean, asymbol **));
d4018 10
d4031 1
a4031 1
boolean
d4037 2
a4038 1
CONST char *
d4044 1
a4044 1
boolean
d4047 1
d4068 3
a4070 1
enum bfd_flavour {
d4088 6
a4093 1
  bfd_target_evax_flavour
d4103 1
d4105 3
d4109 2
d4112 2
d4115 3
d4119 3
d4123 3
d4127 2
d4130 2
d4133 5
a4137 1
  bfd_vma      (*bfd_getx64) PARAMS ((const bfd_byte *));
d4139 2
a4140 2
  void         (*bfd_putx64) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma      (*bfd_getx32) PARAMS ((const bfd_byte *));
d4142 2
a4143 2
  void         (*bfd_putx32) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma      (*bfd_getx16) PARAMS ((const bfd_byte *));
d4145 4
a4148 2
  void         (*bfd_putx16) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma      (*bfd_h_getx64) PARAMS ((const bfd_byte *));
d4150 2
a4151 2
  void         (*bfd_h_putx64) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma      (*bfd_h_getx32) PARAMS ((const bfd_byte *));
d4153 2
a4154 2
  void         (*bfd_h_putx32) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma      (*bfd_h_getx16) PARAMS ((const bfd_byte *));
d4156 6
a4161 1
  void         (*bfd_h_putx16) PARAMS ((bfd_vma, bfd_byte *));
d4163 7
a4169 2
  boolean             (*_bfd_set_format[bfd_type_end]) PARAMS ((bfd *));
  boolean             (*_bfd_write_contents[bfd_type_end]) PARAMS ((bfd *));
d4172 6
a4177 6
#define BFD_JUMP_TABLE_GENERIC(NAME)\
CAT(NAME,_close_and_cleanup),\
CAT(NAME,_bfd_free_cached_info),\
CAT(NAME,_new_section_hook),\
CAT(NAME,_get_section_contents),\
CAT(NAME,_get_section_contents_in_window)
d4180 1
a4180 1
  boolean       (*_close_and_cleanup) PARAMS ((bfd *));
d4182 1
a4182 1
  boolean (*_bfd_free_cached_info) PARAMS ((bfd *));
d4184 1
a4184 1
  boolean       (*_new_section_hook) PARAMS ((bfd *, sec_ptr));
d4186 4
a4189 5
  boolean       (*_bfd_get_section_contents) PARAMS ((bfd *, sec_ptr, PTR,
                                            file_ptr, bfd_size_type));
  boolean       (*_bfd_get_section_contents_in_window)
                          PARAMS ((bfd *, sec_ptr, bfd_window *,
                                   file_ptr, bfd_size_type));
d4192 7
a4198 7
#define BFD_JUMP_TABLE_COPY(NAME)\
CAT(NAME,_bfd_copy_private_bfd_data),\
CAT(NAME,_bfd_merge_private_bfd_data),\
CAT(NAME,_bfd_copy_private_section_data),\
CAT(NAME,_bfd_copy_private_symbol_data),\
CAT(NAME,_bfd_set_private_flags),\
CAT(NAME,_bfd_print_private_bfd_data)\
d4201 1
a4201 1
  boolean       (*_bfd_copy_private_bfd_data) PARAMS ((bfd *, bfd *));
d4204 1
a4204 1
  boolean       (*_bfd_merge_private_bfd_data) PARAMS ((bfd *, bfd *));
d4207 2
a4208 2
  boolean       (*_bfd_copy_private_section_data) PARAMS ((bfd *, sec_ptr,
                                                       bfd *, sec_ptr));
d4211 4
a4214 4
  boolean       (*_bfd_copy_private_symbol_data) PARAMS ((bfd *, asymbol *,
                                                          bfd *, asymbol *));
  /* Called to set private backend flags */
  boolean       (*_bfd_set_private_flags) PARAMS ((bfd *, flagword));
d4216 2
a4217 2
  /* Called to print private BFD data */
  boolean       (*_bfd_print_private_bfd_data) PARAMS ((bfd *, PTR));
d4220 7
a4226 7
#define BFD_JUMP_TABLE_CORE(NAME)\
CAT(NAME,_core_file_failing_command),\
CAT(NAME,_core_file_failing_signal),\
CAT(NAME,_core_file_matches_executable_p)
  char *   (*_core_file_failing_command) PARAMS ((bfd *));
  int      (*_core_file_failing_signal) PARAMS ((bfd *));
  boolean  (*_core_file_matches_executable_p) PARAMS ((bfd *, bfd *));
d4229 20
a4248 23
#define BFD_JUMP_TABLE_ARCHIVE(NAME)\
CAT(NAME,_slurp_armap),\
CAT(NAME,_slurp_extended_name_table),\
CAT(NAME,_construct_extended_name_table),\
CAT(NAME,_truncate_arname),\
CAT(NAME,_write_armap),\
CAT(NAME,_read_ar_hdr),\
CAT(NAME,_openr_next_archived_file),\
CAT(NAME,_get_elt_at_index),\
CAT(NAME,_generic_stat_arch_elt),\
CAT(NAME,_update_armap_timestamp)
  boolean  (*_bfd_slurp_armap) PARAMS ((bfd *));
  boolean  (*_bfd_slurp_extended_name_table) PARAMS ((bfd *));
  boolean  (*_bfd_construct_extended_name_table)
             PARAMS ((bfd *, char **, bfd_size_type *, const char **));
  void     (*_bfd_truncate_arname) PARAMS ((bfd *, CONST char *, char *));
  boolean  (*write_armap) PARAMS ((bfd *arch,
                              unsigned int elength,
                              struct orl *map,
                              unsigned int orl_count,
                              int stridx));
  PTR (*_bfd_read_ar_hdr_fn) PARAMS ((bfd *));
  bfd *    (*openr_next_archived_file) PARAMS ((bfd *arch, bfd *prev));
d4250 3
a4252 3
  bfd *    (*_bfd_get_elt_at_index) PARAMS ((bfd *, symindex));
  int      (*_bfd_stat_arch_elt) PARAMS ((bfd *, struct stat *));
  boolean  (*_bfd_update_armap_timestamp) PARAMS ((bfd *));
d4255 19
a4273 20
#define BFD_JUMP_TABLE_SYMBOLS(NAME)\
CAT(NAME,_get_symtab_upper_bound),\
CAT(NAME,_get_symtab),\
CAT(NAME,_make_empty_symbol),\
CAT(NAME,_print_symbol),\
CAT(NAME,_get_symbol_info),\
CAT(NAME,_bfd_is_local_label_name),\
CAT(NAME,_get_lineno),\
CAT(NAME,_find_nearest_line),\
CAT(NAME,_bfd_make_debug_symbol),\
CAT(NAME,_read_minisymbols),\
CAT(NAME,_minisymbol_to_symbol)
  long  (*_bfd_get_symtab_upper_bound) PARAMS ((bfd *));
  long  (*_bfd_canonicalize_symtab) PARAMS ((bfd *,
                                             struct symbol_cache_entry **));
  struct symbol_cache_entry  *
                (*_bfd_make_empty_symbol) PARAMS ((bfd *));
  void          (*_bfd_print_symbol) PARAMS ((bfd *, PTR,
                                      struct symbol_cache_entry *,
                                      bfd_print_symbol_type));
d4275 2
a4276 3
  void          (*_bfd_get_symbol_info) PARAMS ((bfd *,
                                      struct symbol_cache_entry *,
                                      symbol_info *));
d4278 1
a4278 1
  boolean       (*_bfd_is_local_label_name) PARAMS ((bfd *, const char *));
d4280 4
a4283 5
  alent *    (*_get_lineno) PARAMS ((bfd *, struct symbol_cache_entry *));
  boolean    (*_bfd_find_nearest_line) PARAMS ((bfd *abfd,
                    struct sec *section, struct symbol_cache_entry **symbols,
                    bfd_vma offset, CONST char **file, CONST char **func,
                    unsigned int *line));
d4287 2
a4288 4
  asymbol *  (*_bfd_make_debug_symbol) PARAMS ((
       bfd *abfd,
       void *ptr,
       unsigned long size));
d4291 2
a4292 2
  long  (*_read_minisymbols) PARAMS ((bfd *, boolean, PTR *,
                                      unsigned int *));
d4295 2
a4296 2
  asymbol *(*_minisymbol_to_symbol) PARAMS ((bfd *, boolean, const PTR,
                                             asymbol *));
d4299 7
a4305 7
#define BFD_JUMP_TABLE_RELOCS(NAME)\
CAT(NAME,_get_reloc_upper_bound),\
CAT(NAME,_canonicalize_reloc),\
CAT(NAME,_bfd_reloc_type_lookup)
  long  (*_get_reloc_upper_bound) PARAMS ((bfd *, sec_ptr));
  long  (*_bfd_canonicalize_reloc) PARAMS ((bfd *, sec_ptr, arelent **,
                                            struct symbol_cache_entry **));
d4308 1
a4308 2
       (*reloc_type_lookup) PARAMS ((bfd *abfd,
                                     bfd_reloc_code_real_type code));
d4311 7
a4317 7
#define BFD_JUMP_TABLE_WRITE(NAME)\
CAT(NAME,_set_arch_mach),\
CAT(NAME,_set_section_contents)
  boolean    (*_bfd_set_arch_mach) PARAMS ((bfd *, enum bfd_architecture,
                    unsigned long));
  boolean       (*_bfd_set_section_contents) PARAMS ((bfd *, sec_ptr, PTR,
                                            file_ptr, bfd_size_type));
d4320 17
a4336 14
#define BFD_JUMP_TABLE_LINK(NAME)\
CAT(NAME,_sizeof_headers),\
CAT(NAME,_bfd_get_relocated_section_contents),\
CAT(NAME,_bfd_relax_section),\
CAT(NAME,_bfd_link_hash_table_create),\
CAT(NAME,_bfd_link_add_symbols),\
CAT(NAME,_bfd_final_link),\
CAT(NAME,_bfd_link_split_section),\
CAT(NAME,_bfd_gc_sections)
  int        (*_bfd_sizeof_headers) PARAMS ((bfd *, boolean));
  bfd_byte * (*_bfd_get_relocated_section_contents) PARAMS ((bfd *,
                    struct bfd_link_info *, struct bfd_link_order *,
                    bfd_byte *data, boolean relocateable,
                    struct symbol_cache_entry **));
d4338 2
a4339 2
  boolean    (*_bfd_relax_section) PARAMS ((bfd *, struct sec *,
                    struct bfd_link_info *, boolean *again));
d4343 6
a4348 1
  struct bfd_link_hash_table *(*_bfd_link_hash_table_create) PARAMS ((bfd *));
d4351 6
a4356 1
  boolean (*_bfd_link_add_symbols) PARAMS ((bfd *, struct bfd_link_info *));
d4360 1
a4360 1
  boolean (*_bfd_final_link) PARAMS ((bfd *, struct bfd_link_info *));
d4363 1
a4363 1
  boolean (*_bfd_link_split_section) PARAMS ((bfd *, struct sec *));
d4366 7
a4372 1
  boolean (*_bfd_gc_sections) PARAMS ((bfd *, struct bfd_link_info *));
d4375 7
a4381 7
#define BFD_JUMP_TABLE_DYNAMIC(NAME)\
CAT(NAME,_get_dynamic_symtab_upper_bound),\
CAT(NAME,_canonicalize_dynamic_symtab),\
CAT(NAME,_get_dynamic_reloc_upper_bound),\
CAT(NAME,_canonicalize_dynamic_reloc)
  /* Get the amount of memory required to hold the dynamic symbols. */
  long  (*_bfd_get_dynamic_symtab_upper_bound) PARAMS ((bfd *));
d4383 1
a4383 1
  long  (*_bfd_canonicalize_dynamic_symtab)
d4386 1
a4386 1
  long  (*_bfd_get_dynamic_reloc_upper_bound) PARAMS ((bfd *));
d4388 1
a4388 1
  long  (*_bfd_canonicalize_dynamic_reloc)
d4391 2
a4392 2
 /* Opposite endian version of this target.  */
 const struct bfd_target * alternative_target;
d4394 3
a4396 1
 PTR backend_data;
d4399 2
a4400 1
boolean
d4404 1
a4404 1
bfd_find_target PARAMS ((CONST char *target_name, bfd *abfd));
d4410 3
a4412 1
bfd_search_for_target PARAMS ((int (* search_func) (const bfd_target *, void *), void *));
d4414 2
a4415 1
boolean
d4418 3
a4420 2
boolean
bfd_check_format_matches PARAMS ((bfd *abfd, bfd_format format, char ***matching));
d4422 1
a4422 1
boolean
d4425 1
a4425 1
CONST char *
d4427 11
@


1.7
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d27 1
a27 1
/* bfd.h -- The only header file required by users of the bfd library 
d88 1
a88 1
   force me to change it. */
d97 1
a97 1
/* Pre-emptive strike - get the file with the enum. */
d113 1
a113 1
   Probably the best long-term answer is to avoid using file_ptr AND off_t 
d181 2
a182 2
#define fprintf_vma(s,x) fprintf(s, "%08lx", x)
#define sprintf_vma(s,x) sprintf(s, "%08lx", x)
a287 1
  
d291 1
a291 1
  char **name;			/* symbol name */ 
a295 1

d298 1
a298 1
  unsigned int line_number;	/* Linenumber from start of function*/  
d329 1
a329 1
typedef struct stat stat_type; 
d332 1
a332 1
{ 
d337 1
a337 1
    
d346 1
a346 1
  char stab_other;             /* Stab other. */
a482 1

d490 3
d515 1
a515 1
#define bfd_set_cacheable(abfd,bool) (((abfd)->cacheable = (boolean)(bool)), true)
d541 5
d633 1
d635 2
d652 10
d740 4
d774 7
d782 1
a782 1
void 
d797 1
a797 1
boolean 
d800 1
a800 1
boolean 
d806 1
a806 1
boolean 
d809 1
a809 1
boolean 
d813 1
a813 1
 /* Byte swapping macros for user section data.  */
d816 1
a816 1
                ((void) (*((unsigned char *)(ptr)) = (unsigned char)(val)))
d820 1
a820 1
                (*(unsigned char *)(ptr))
d822 1
a822 1
               ((*(unsigned char *)(ptr) ^ 0x80) - 0x80)
d866 1
a866 1
 /* Byte swapping macros for file header data.  */
d904 4
a907 4
  /* This structure is used for a comdat section, as in PE.  A comdat
    section is associated with a particular symbol.  When the linker
    sees a comdat section, it keeps only one of the sections with a
    given name and associated with a given symbol. */
d911 1
a911 1
   /* The name of the symbol associated with a comdat section.  */
d914 1
a914 1
   /* The local symbol table index of the symbol associated with a
a918 4

   /* If this section is being discarded, the linker uses this field
     to point to the input section which is being kept.  */
  struct sec *sec;
d923 2
a924 2
         /* The name of the section; the name isn't a copy, the pointer is
        the same as that passed to bfd_make_section. */
d926 5
a930 1
    CONST char *name;
d932 1
a932 1
         /* Which section is it; 0..nth.      */
d934 1
a934 1
   int index;
d936 1
a936 1
         /* The next section in the list belonging to the BFD, or NULL. */
d938 1
a938 1
    struct sec *next;
d940 3
a942 3
         /* The field flags contains attributes of the section. Some
           flags are read in from the object file, and some are
           synthesized from other information.  */
d944 1
a944 1
    flagword flags;
d948 2
a949 3
         /* Tells the OS to allocate space for this section when loading.
           This is clear for a section containing debug information
           only. */
d952 2
a953 2
         /* Tells the OS to load the section from the file when loading.
           This is clear for a .bss section. */
d956 2
a957 2
         /* The section contains data still to be relocated, so there is
           some relocation information too. */
d960 1
a960 1
#if 0    /* Obsolete ? */
d964 1
a964 2
         /* A signal to the OS that the section contains read only
          data. */
d967 1
a967 1
         /* The section contains code only. */
d970 1
a970 1
         /* The section contains data only. */
d973 1
a973 1
         /* The section will reside in ROM. */
d976 10
a985 10
         /* The section contains constructor information. This section
           type is used by the linker to create lists of constructors and
           destructors used by <<g++>>. When a back end sees a symbol
           which should be used in a constructor list, it creates a new
           section for the type of name (e.g., <<__CTOR_LIST__>>), attaches
           the symbol to it, and builds a relocation. To build the lists
           of constructors, all the linker has to do is catenate all the
           sections called <<__CTOR_LIST__>> and relocate the data
           contained within - exactly the operations it would peform on
           standard data. */
d988 2
a989 2
         /* The section is a constructor, and should be placed at the
          end of the text, data, or bss section(?). */
d994 3
a996 3
         /* The section has contents - a data section could be
           <<SEC_ALLOC>> | <<SEC_HAS_CONTENTS>>; a debug section could be
           <<SEC_HAS_CONTENTS>> */
d999 2
a1000 2
         /* An instruction to the linker to not output the section
           even if it has information which would normally be written. */
d1003 9
a1011 9
         /* The section is a COFF shared library section.  This flag is
           only for the linker.  If this type of section appears in
           the input file, the linker must copy it to the output file
           without changing the vma or size.  FIXME: Although this
           was originally intended to be general, it really is COFF
           specific (and the flag was renamed to indicate this).  It
           might be cleaner to have some more general mechanism to
           allow the back end to control what the linker does with
           sections. */
d1014 13
a1026 5
         /* The section contains common symbols (symbols may be defined
           multiple times, the value of a symbol is the amount of
           space it requires, and the largest symbol value is the one
           used).  Most targets have exactly one of these (which we
           translate to bfd_com_section_ptr), but ECOFF has two. */
d1029 4
a1032 4
         /* The section contains only debugging information.  For
           example, this is set for ELF .debug and .stab sections.
           strip tests this flag to see if a section can be
           discarded. */
d1035 3
a1037 4
         /* The contents of this section are held in memory pointed to
           by the contents field.  This is checked by
           bfd_get_section_contents, and the data is retrieved from
           memory if appropriate.  */
d1040 3
a1042 3
         /* The contents of this section are to be excluded by the
           linker for executable and shared objects unless those
           objects are to be further relocated.  */
d1045 3
a1047 3
        /* The contents of this section are to be sorted by the
          based on the address specified in the associated symbol
          table.  */
d1050 4
a1053 4
        /* When linking, duplicate sections of the same name should be
          discarded, rather than being combined into a single section as
          is usually done.  This is similar to how common symbols are
          handled.  See SEC_LINK_DUPLICATES below.  */
d1056 2
a1057 2
        /* If SEC_LINK_ONCE is set, this bitfield describes how the linker
          should handle duplicate sections.  */
d1060 2
a1061 2
        /* This value for SEC_LINK_DUPLICATES means that duplicate
          sections with the same name should simply be discarded. */
d1064 3
a1066 3
        /* This value for SEC_LINK_DUPLICATES means that the linker
          should warn if there are any duplicate sections, although
          it should still only link one copy.  */
d1069 2
a1070 2
        /* This value for SEC_LINK_DUPLICATES means that the linker
          should warn if any duplicate sections are a different size.  */
d1073 3
a1075 3
        /* This value for SEC_LINK_DUPLICATES means that the linker
          should warn if any duplicate sections contain different
          contents.  */
d1078 4
a1081 4
        /* This section was created by the linker as part of dynamic
          relocation or other arcane processing.  It is skipped when
          going through the first-pass output, trusting that someone
          else up the line will take care of it later.  */
d1084 1
a1084 1
        /* This section should not be subject to garbage collection.  */
d1087 2
a1088 2
        /* This section contains "short" data, and should be placed
          "near" the GP.  */
d1091 2
a1092 2
        /* This section contains data which may be shared with other
          executables or shared objects.  */
d1095 5
a1099 1
        /*  End of section flags.  */
d1101 3
a1103 1
        /* Some internal packed boolean fields.  */
d1105 1
a1105 2
        /* See the vma field.  */
       unsigned int user_set_vma : 1;
d1107 1
a1107 2
        /* Whether relocations have been processed.  */
       unsigned int reloc_done : 1;
d1109 2
a1110 2
        /* A mark flag used by some of the linker backends.  */
       unsigned int linker_mark : 1;
d1112 2
a1113 2
        /* A mark flag used by some linker backends for garbage collection.  */
       unsigned int gc_mark : 1;
d1115 2
a1116 1
        /* End of internal packed boolean fields.  */
d1118 3
a1120 6
        /*  The virtual memory address of the section - where it will be
           at run time.  The symbols are relocated against this.  The
           user_set_vma flag is maintained by bfd; if it's not set, the
           backend can assign addresses (for example, in <<a.out>>, where
           the default address for <<.data>> is dependent on the specific
           target and various flags).  */
d1122 2
a1123 1
   bfd_vma vma;
d1125 2
a1126 3
        /*  The load address of the section - where it would be in a
           rom image; really only used for writing section header
           information. */
d1128 1
a1128 1
   bfd_vma lma;
d1130 6
a1135 3
         /* The size of the section in octets, as it will be output.
           Contains a value even if the section has no contents (e.g., the
           size of <<.bss>>).  This will be filled in after relocation.  */
d1137 1
a1137 1
   bfd_size_type _cooked_size;
d1139 3
a1141 3
         /* The original size on disk of the section, in octets.  Normally this
           value is the same as the size, but if some relaxing has
           been done, then this value will be bigger.  */
d1143 1
a1143 1
   bfd_size_type _raw_size;
d1145 3
a1147 7
         /* If this section is going to be output, then this value is the
           offset in *bytes* into the output section of the first byte in the
           input section (byte ==> smallest addressable unit on the
           target).  In most cases, if this was going to start at the
           100th octet (8-bit quantity) in the output section, this value
           would be 100.  However, if the target byte size is 16 bits
           (bfd_octets_per_byte is "2"), this value would be 50. */
d1149 1
a1149 1
   bfd_vma output_offset;
d1151 3
a1153 1
         /* The output section through which to map on output. */
d1155 1
a1155 1
   struct sec *output_section;
d1157 7
a1163 2
         /* The alignment requirement of the section, as an exponent of 2 -
           e.g., 3 aligns to 2^3 (or 8). */
d1165 1
a1165 1
   unsigned int alignment_power;
d1167 1
a1167 2
         /* If an input section, a pointer to a vector of relocation
           records for the data in this section. */
d1169 1
a1169 1
   struct reloc_cache_entry *relocation;
d1171 2
a1172 2
         /* If an output section, a pointer to a vector of pointers to
           relocation records for the data in this section. */
d1174 1
a1174 1
   struct reloc_cache_entry **orelocation;
d1176 2
a1177 1
         /* The number of relocation records in one of the above  */
d1179 1
a1179 1
   unsigned reloc_count;
d1181 2
a1182 2
         /* Information below is back end specific - and not always used
           or updated.  */
d1184 1
a1184 1
         /* File position of section data    */
d1186 1
a1186 1
   file_ptr filepos;
d1188 1
a1188 1
         /* File position of relocation info */
d1190 2
a1191 1
   file_ptr rel_filepos;
d1193 1
a1193 1
         /* File position of line data       */
d1195 1
a1195 1
   file_ptr line_filepos;
d1197 1
a1197 1
         /* Pointer to data for applications */
d1199 1
a1199 1
   PTR userdata;
d1201 1
a1201 3
         /* If the SEC_IN_MEMORY flag is set, this points to the actual
           contents.  */
   unsigned char *contents;
d1203 1
a1203 1
         /* Attached line number information */
d1205 1
a1205 1
   alent *lineno;
d1207 1
a1207 1
         /* Number of line number records   */
d1209 3
a1211 1
   unsigned int lineno_count;
d1213 1
a1213 1
         /* Optional information about a COMDAT entry; NULL if not COMDAT */
d1215 1
a1215 1
   struct bfd_comdat_info *comdat;
d1217 1
a1217 2
         /* When a section is being output, this value changes as more
           linenumbers are written out */
d1219 1
a1219 1
   file_ptr moving_line_filepos;
d1221 1
a1221 1
         /* What the section number is in the target world  */
d1223 1
a1223 1
   int target_index;
d1225 3
a1227 1
   PTR used_by_bfd;
d1229 2
a1230 2
         /* If this is a constructor section then here is a list of the
           relocations created to relocate items within it. */
d1232 1
a1232 1
   struct relent_chain *constructor_chain;
d1234 1
a1234 1
         /* The BFD which owns the section. */
d1236 1
a1236 1
   bfd *owner;
d1238 1
a1238 3
         /* A symbol which points at this section only */
   struct symbol_cache_entry *symbol;
   struct symbol_cache_entry **symbol_ptr_ptr;
d1240 15
a1254 2
   struct bfd_link_order *link_order_head;
   struct bfd_link_order *link_order_tail;
d1257 5
a1261 5
     /* These sections are global, and are managed by BFD.  The application
       and target back end are not permitted to change the values in
       these sections.  New code should use the section_ptr macros rather
       than referring directly to the const sections.  The const sections
       may eventually vanish.  */
d1267 1
a1267 1
     /* the absolute section */
d1271 1
a1271 1
     /* Pointer to the undefined section */
d1275 1
a1275 1
     /* Pointer to the common section */
d1278 1
a1278 1
     /* Pointer to the indirect section */
d1294 6
a1299 1
bfd_get_section_by_name PARAMS ((bfd *abfd, CONST char *name));
d1302 1
a1302 1
bfd_make_section_old_way PARAMS ((bfd *abfd, CONST char *name));
d1305 1
a1305 1
bfd_make_section_anyway PARAMS ((bfd *abfd, CONST char *name));
d1308 1
a1308 1
bfd_make_section PARAMS ((bfd *, CONST char *name));
d1310 1
a1310 1
boolean 
d1313 1
a1313 1
void 
d1315 1
a1315 1
    void (*func)(bfd *abfd,
d1320 1
a1320 1
boolean 
d1323 2
a1324 3
boolean 
bfd_set_section_contents
 PARAMS ((bfd *abfd,
d1330 2
a1331 3
boolean 
bfd_get_section_contents
 PARAMS ((bfd *abfd, asection *section, PTR location,
d1334 1
a1334 1
boolean 
d1340 2
a1341 3
void 
_bfd_strip_section_from_output
 PARAMS ((struct bfd_link_info *info, asection *section));
d1343 1
a1343 1
enum bfd_architecture 
d1345 3
a1347 3
  bfd_arch_unknown,    /* File arch not known */
  bfd_arch_obscure,    /* Arch known, not one of these */
  bfd_arch_m68k,       /* Motorola 68xxx */
d1356 8
a1363 4
  bfd_arch_vax,        /* DEC Vax */   
  bfd_arch_i960,       /* Intel 960 */
     /* The order of the following is important.
       lower number indicates a machine type that 
d1367 1
a1367 1
       incompatible with all other machines except 
d1379 2
a1380 2
  bfd_arch_a29k,       /* AMD 29000 */
  bfd_arch_sparc,      /* SPARC */
d1382 1
a1382 1
 /* The difference between v8plus and v9 is that v9 is a true 64 bit env.  */
d1386 1
a1386 1
#define bfd_mach_sparc_v8plusa         5  /* with ultrasparc add'ns */
d1389 4
a1392 2
#define bfd_mach_sparc_v9a             8  /* with ultrasparc add'ns */
 /* Nonzero if MACH has the v9 instruction set.  */
d1394 3
a1396 2
  ((mach) >= bfd_mach_sparc_v8plus && (mach) <= bfd_mach_sparc_v9a)
  bfd_arch_mips,       /* MIPS Rxxxx */
d1411 1
d1413 6
a1418 1
  bfd_arch_i386,       /* Intel 386 */
d1422 12
a1433 10
  bfd_arch_we32k,      /* AT&T WE32xxx */
  bfd_arch_tahoe,      /* CCI/Harris Tahoe */
  bfd_arch_i860,       /* Intel 860 */
  bfd_arch_i370,       /* IBM 360/370 Mainframes */
  bfd_arch_romp,       /* IBM ROMP PC/RT */
  bfd_arch_alliant,    /* Alliant */
  bfd_arch_convex,     /* Convex */
  bfd_arch_m88k,       /* Motorola 88xxx */
  bfd_arch_pyramid,    /* Pyramid Technology */
  bfd_arch_h8300,      /* Hitachi H8/300 */
d1437 25
a1461 4
  bfd_arch_powerpc,    /* PowerPC */
  bfd_arch_rs6000,     /* IBM RS/6000 */
  bfd_arch_hppa,       /* HP PA RISC */
  bfd_arch_d10v,       /* Mitsubishi D10V */
d1465 4
a1468 2
  bfd_arch_d30v,       /* Mitsubishi D30V */
  bfd_arch_z8k,        /* Zilog Z8000 */
d1471 2
a1472 2
  bfd_arch_h8500,      /* Hitachi H8/500 */
  bfd_arch_sh,         /* Hitachi SH */
d1480 1
a1480 1
  bfd_arch_alpha,      /* Dec Alpha */
d1484 1
a1484 1
  bfd_arch_arm,        /* Advanced Risc Machines ARM */
d1493 8
a1500 5
  bfd_arch_ns32k,      /* National Semiconductors ns32000 */
  bfd_arch_w65,        /* WDC 65816 */
  bfd_arch_tic30,      /* Texas Instruments TMS320C30 */
  bfd_arch_tic80,      /* TI TMS320c80 (MVP) */
  bfd_arch_v850,       /* NEC V850 */
d1504 7
a1510 4
  bfd_arch_arc,        /* Argonaut RISC Core */
#define bfd_mach_arc_base 0
  bfd_arch_m32r,       /* Mitsubishi M32R/D */
#define bfd_mach_m32r          0  /* backwards compatibility */
d1512 2
a1513 2
  bfd_arch_mn10200,    /* Matsushita MN10200 */
  bfd_arch_mn10300,    /* Matsushita MN10300 */
d1519 3
d1523 1
a1523 1
  bfd_arch_avr,        /* Atmel AVR microcontrollers */
d1528 2
d1533 1
a1533 1
typedef struct bfd_arch_info 
d1543 2
a1544 2
  /* true if this is the default machine for the architecture */
  boolean the_default; 
d1567 1
a1567 1
void 
d1570 1
a1570 1
enum bfd_architecture 
d1573 1
a1573 1
unsigned long 
d1576 1
a1576 1
unsigned int 
d1579 1
a1579 1
unsigned int 
d1582 1
a1582 1
const bfd_arch_info_type * 
d1586 1
a1586 2
bfd_lookup_arch
 PARAMS ((enum bfd_architecture
d1591 1
a1591 2
bfd_printable_arch_mach
 PARAMS ((enum bfd_architecture arch, unsigned long machine));
d1593 1
a1593 1
unsigned int 
d1596 1
a1596 1
unsigned int 
d1602 1
a1602 1
        /* No errors detected */
d1605 1
a1605 1
        /* The relocation was performed, but there was an overflow. */
d1608 1
a1608 1
        /* The address to relocate was not within the section supplied. */
d1611 1
a1611 1
        /* Used by special functions */
d1614 1
a1614 1
        /* Unsupported relocation size requested. */
d1617 1
a1617 1
        /* Unused */
d1620 1
a1620 1
        /* The symbol to relocate against was undefined. */
d1623 1
a1623 1
        /* The relocation was performed, but may not be ok - presently
d1634 1
a1634 1
        /* A pointer into the canonical table of pointers  */
d1637 1
a1637 1
        /* offset in section */
d1640 1
a1640 1
        /* addend for relocation value */
d1643 1
a1643 1
        /* Pointer to how to perform the required relocation */
d1649 1
a1649 1
        /* Do not complain on overflow. */
d1652 1
a1652 1
        /* Complain if the bitfield overflows, whether it is considered
d1656 1
a1656 1
        /* Complain if the value overflows when considered as signed
d1660 1
a1660 1
        /* Complain if the value overflows when considered as an
d1667 1
a1667 1
        /*  The type field has mainly a documentary use - the back end can
d1675 1
a1675 1
        /*  The value the final relocation is shifted right by. This drops
d1679 1
a1679 1
        /*  The size of the item to be relocated.  This is *not* a
d1684 1
a1684 1
        /*  The number of bits in the item to be relocated.  This is used
d1688 1
a1688 1
        /*  Notes that the relocation is relative to the location in the
d1694 1
a1694 1
        /*  The bit position of the reloc value in the destination.
d1698 1
a1698 1
        /* What type of overflow error should be checked for when
d1702 1
a1702 1
        /* If this field is non null, then the supplied function is
d1715 1
a1715 1
        /* The textual name of the relocation type. */
d1718 1
a1718 1
        /* Some formats record a relocation addend in the section contents
d1735 1
a1735 1
        /* The src_mask selects which parts of the read in data
d1744 1
a1744 1
        /* The dst_mask selects which parts of the instruction are replaced
d1750 1
a1750 1
        /* When some formats create PC relative instructions, they leave
d1777 2
a1778 2
unsigned int 
bfd_get_reloc_size  PARAMS ((reloc_howto_type *));
d1785 1
a1785 3

bfd_check_overflow
 PARAMS ((enum complain_overflow how,
d1792 1
a1792 3

bfd_perform_relocation
 PARAMS ((bfd *abfd,
d1800 1
a1800 3

bfd_install_relocation
 PARAMS ((bfd *abfd,
d1910 1
d1912 1
d2064 11
d2087 10
d2163 10
d2221 7
d2235 1
a2235 1
/* Argonaut RISC Core (ARC) relocs.
d2411 23
d2560 120
d2683 1
a2683 2

bfd_reloc_type_lookup  PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
d2686 1
a2686 1
bfd_get_reloc_code_name  PARAMS ((bfd_reloc_code_real_type code));
d2691 1
a2691 1
        /* A pointer to the BFD which owns the symbol. This information
d2701 1
a2701 1
  struct _bfd *the_bfd;  /* Use bfd_asymbol_bfd(sym) to access this field. */
d2703 1
a2703 1
        /* The text of the symbol. The name is left alone, and not copied; the
d2707 1
a2707 1
        /* The value of the symbol.  This really should be a union of a
d2712 1
a2712 1
        /* Attributes of a symbol: */
d2716 1
a2716 1
        /* The symbol has local scope; <<static>> in <<C>>. The value
d2720 1
a2720 1
        /* The symbol has global scope; initialized data in <<C>>. The
d2724 1
a2724 1
        /* The symbol has global scope and is exported. The value is
d2726 1
a2726 1
#define BSF_EXPORT     BSF_GLOBAL  /* no real difference */
d2728 1
a2728 1
        /* A normal C symbol would be one of:
d2732 1
a2732 1
        /* The symbol is a debugging record. The value has an arbitary
d2736 1
a2736 1
        /* The symbol denotes a function entry point.  Used in ELF,
d2740 1
a2740 1
        /* Used by the linker. */
d2744 1
a2744 1
        /* A weak global symbol, overridable without warnings by
d2748 1
a2748 1
        /* This symbol was created to point to a section, e.g. ELF's
d2752 1
a2752 1
        /* The symbol used to be a common symbol, but now it is
d2756 1
a2756 1
        /* The default value for common data. */
d2759 1
a2759 1
        /* In some files the type of a symbol sometimes alters its
d2767 1
a2767 1
        /* Signal that the symbol is the label of constructor section. */
d2770 1
a2770 1
        /* Signal that the symbol is a warning symbol.  The name is a
d2776 1
a2776 1
        /* Signal that the symbol is indirect.  This symbol is an indirect
d2780 1
a2780 1
        /* BSF_FILE marks symbols that contain a file name.  This is used
d2784 1
a2784 1
        /* Symbol is from dynamic linking information.  */
d2787 1
a2787 1
        /* The symbol denotes a data object.  Used in ELF, and perhaps
d2791 1
a2791 1
        /* This symbol is a debugging symbol.  The value is the offset
d2798 1
a2798 1
        /* A pointer to the section to which this symbol is
d2803 1
a2803 1
        /* Back end special data.  */
d2813 1
a2813 1
boolean 
d2816 1
a2816 1
boolean 
d2824 2
a2825 2
boolean 
bfd_set_symtab  PARAMS ((bfd *abfd, asymbol **location, unsigned int count));
d2827 1
a2827 1
void 
d2834 1
a2834 1
int 
d2837 2
a2838 2
boolean 
bfd_is_undefined_symclass  PARAMS ((int symclass));
d2840 1
a2840 1
void 
d2843 1
a2843 1
boolean 
d2849 1
a2849 1
struct _bfd 
d2851 2
a2852 2
     /* The filename the application opened the BFD with.  */
    CONST char *filename;                
d2854 1
a2854 1
     /* A pointer to the target jump table.             */
d2857 1
a2857 1
     /* To avoid dragging too many header files into every file that
d2866 1
a2866 1
     /* Is the file descriptor being cached?  That is, can it be closed as
d2871 1
a2871 1
     /* Marks whether there was a default target specified when the
d2877 1
a2877 1
     /* The caching routines use these to maintain a
d2882 1
a2882 1
     /* When a file is closed by the caching routines, BFD retains
d2885 1
a2885 1
    file_ptr where;              
d2887 1
a2887 1
     /* and here: (``once'' means at least once) */
d2891 1
a2891 1
     /* Set if we have a locally maintained mtime value, rather than
d2896 1
a2896 1
     /* File modified time, if mtime_set is true: */
d2898 1
a2898 1
    long mtime;          
d2900 1
a2900 1
     /* Reserved for an unimplemented file locking extension.*/
d2904 1
a2904 1
     /* The format which belongs to the BFD. (object, core, etc.) */
d2908 1
a2908 1
     /* The direction the BFD was opened with*/
d2915 1
a2915 1
     /* Format_specific flags*/
d2917 1
a2917 1
    flagword flags;              
d2919 1
a2919 1
     /* Currently my_archive is tested before adding origin to
d2923 1
a2923 1
    file_ptr origin;             
d2925 1
a2925 1
     /* Remember when output has begun, to stop strange things
d2929 1
a2929 1
     /* Pointer to linked list of sections*/
d2932 1
a2932 1
     /* The number of sections */
d2935 1
a2935 1
     /* Stuff only useful for object files: 
d2939 1
a2939 1
     /* Used for input and output*/
d2942 2
a2943 2
     /* Symbol table for output BFD (with symcount entries) */
    struct symbol_cache_entry  **outsymbols;             
d2945 1
a2945 1
     /* Pointer to structure which contains architecture information*/
d2948 6
a2953 6
     /* Stuff only useful for archives:*/
    PTR arelt_data;              
    struct _bfd *my_archive;      /* The containing archive BFD.  */
    struct _bfd *next;            /* The next BFD in the archive.  */
    struct _bfd *archive_head;    /* The first BFD in the archive.  */
    boolean has_armap;           
d2955 1
a2955 1
     /* A chain of BFD structures involved in a link.  */
d2958 1
a2958 1
     /* A field used by _bfd_generic_link_add_archive_symbols.  This will
d2962 1
a2962 1
     /* Used by the back end to hold private data. */
d2964 1
a2964 1
    union 
d2996 2
a2997 2
  
     /* Used by the application to hold private data*/
d3000 1
a3000 1
   /* Where all the allocated stuff under this BFD goes.  This is a
d3029 2
a3030 2
bfd_error_type 
bfd_get_error  PARAMS ((void));
d3032 2
a3033 2
void 
bfd_set_error  PARAMS ((bfd_error_type error_tag));
d3036 1
a3036 1
bfd_errmsg  PARAMS ((bfd_error_type error_tag));
d3038 2
a3039 2
void 
bfd_perror  PARAMS ((CONST char *message));
d3043 2
a3044 2
bfd_error_handler_type 
bfd_set_error_handler  PARAMS ((bfd_error_handler_type));
d3046 2
a3047 2
void 
bfd_set_error_program_name  PARAMS ((const char *));
d3049 2
a3050 2
bfd_error_handler_type 
bfd_get_error_handler  PARAMS ((void));
d3052 1
a3052 1
long 
d3055 2
a3056 3
long 
bfd_canonicalize_reloc
 PARAMS ((bfd *abfd,
d3061 2
a3062 3
void 
bfd_set_reloc
 PARAMS ((bfd *abfd, asection *sec, arelent **rel, unsigned int count)
d3066 1
a3066 1
boolean 
d3069 7
a3075 1
boolean 
d3078 1
a3078 1
long 
d3081 1
a3081 1
long 
d3084 1
a3084 1
int 
d3087 1
a3087 1
void 
d3090 1
a3090 1
bfd_vma 
d3093 1
a3093 1
boolean 
d3099 1
a3099 1
boolean 
d3105 1
a3105 1
boolean 
d3117 1
a3117 1
        /* Do these three do anything useful at all, for any back end?  */
d3175 1
a3175 1
symindex 
d3178 1
a3178 1
boolean 
d3187 1
a3187 1
int 
d3190 2
a3191 3
boolean 
core_file_matches_executable_p
 PARAMS ((bfd *core_bfd, bfd *exec_bfd));
d3204 1
a3204 1
            (((bfd)->xvec->message[(int)((bfd)->format)]) arglist)
d3210 1
a3210 1
   (((bfd)->xvec->message[(int)((bfd)->format)]) arglist) : \
d3218 1
d3236 1
a3236 1
 /* Forward declaration.  */
d3245 1
a3245 1
  flagword object_flags;       
d3248 1
a3248 1
  char ar_pad_char;            
d3272 1
a3272 1
   /* Generic entry points.  */
d3280 1
a3280 1
   /* Called when the BFD is being closed to do any necessary cleanup.  */
d3282 1
a3282 1
   /* Ask the BFD to free all cached information.  */
d3284 1
a3284 1
   /* Called when a new section is created.  */
d3286 2
a3287 2
   /* Read the contents of a section.  */
  boolean       (*_bfd_get_section_contents) PARAMS ((bfd *, sec_ptr, PTR, 
d3293 1
a3293 1
   /* Entry points to copy private data.  */
d3301 1
a3301 1
   /* Called to copy BFD general private data from one object file
d3304 1
a3304 1
   /* Called to merge BFD general private data from one object file
d3307 1
a3307 1
   /* Called to copy BFD private section data from one object file
d3311 1
a3311 1
   /* Called to copy BFD private symbol data from one symbol 
d3315 1
a3315 1
   /* Called to set private backend flags */
d3318 1
a3318 1
   /* Called to print private BFD data */
d3321 1
a3321 1
   /* Core file entry points.  */
d3330 1
a3330 1
   /* Archive entry points.  */
d3347 1
a3347 1
  boolean  (*write_armap) PARAMS ((bfd *arch, 
d3350 1
a3350 1
                              unsigned int orl_count, 
d3359 1
a3359 1
   /* Entry points used for symbols.  */
d3392 1
a3392 1
  /* Back-door to allow format-aware applications to create debug symbols
d3408 1
a3408 1
   /* Routines for relocs.  */
d3416 1
a3416 1
   /* See documentation on reloc types.  */
d3421 1
a3421 1
   /* Routines used when writing an object file.  */
d3430 1
a3430 1
   /* Routines used by the linker.  */
d3449 1
a3449 1
   /* Create a hash table for the linker.  Different backends store
d3453 1
a3453 1
   /* Add symbols from this object file into the hash table.  */
d3456 1
a3456 1
   /* Do a link based on the link_order structures attached to each
d3460 1
a3460 1
   /* Should this section be split up into smaller pieces during linking.  */
d3463 1
a3463 1
   /* Remove sections that are not referenced from the output.  */
d3466 1
a3466 1
   /* Routines to handle dynamic symbols and relocs.  */
d3472 1
a3472 1
   /* Get the amount of memory required to hold the dynamic symbols. */
d3474 1
a3474 1
   /* Read in the dynamic symbols.  */
d3477 1
a3477 1
   /* Get the amount of memory required to hold the dynamic relocs.  */
d3479 1
a3479 1
   /* Read in the dynamic relocs.  */
d3483 1
a3483 1
  /* Opposite endian version of this target.  */  
d3485 1
a3485 1
 
d3487 1
a3487 1
 
d3489 2
a3490 2
boolean 
bfd_set_default_target  PARAMS ((const char *name));
d3498 2
a3499 2
const bfd_target * 
bfd_search_for_target  PARAMS ((int (* search_func)(const bfd_target *, void *), void *));
d3501 1
a3501 1
boolean 
d3504 1
a3504 1
boolean 
d3507 1
a3507 1
boolean 
@


1.6
log
@Adding support for Motorola mvme88k
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a52 1
#include "obstack.h"
d92 1
a92 1
#if defined (__GNUG__) && (__GNUC_MINOR__ > 5)
d124 14
a140 8
#if BFD_HOST_64BIT_LONG
#define BFD_HOST_64_BIT long
#define BFD_HOST_U_64_BIT unsigned long
#else
#ifdef __GNUC__
#define BFD_HOST_64_BIT long long
#define BFD_HOST_U_64_BIT unsigned long long
#else /* ! defined (__GNUC__) */
a141 2
#endif /* ! defined (__GNUC__) */
#endif /* ! BFD_HOST_64BIT_LONG */
d182 1
d184 1
d319 1
d390 3
a392 2
  /* An obstack for this hash table.  */
  struct obstack memory;
d550 1
d616 2
d619 3
a621 2
  PARAMS ((bfd *, const char *, const char *, boolean,
	   struct bfd_link_info *, struct sec **));
d623 3
a625 2
  PARAMS ((bfd *, const char *, const char *, boolean,
	   struct bfd_link_info *, struct sec **));
d629 14
d659 2
d714 1
d718 33
d762 1
a762 1
bfd_openstreamr PARAMS (());
a772 3
bfd_size_type 
bfd_alloc_size PARAMS ((bfd *abfd));

d776 6
d786 1
a786 1
                (*((unsigned char *)(ptr)) = (unsigned char)(val))
d788 1
a788 1
		bfd_put_8
d792 1
a792 1
		((*(unsigned char *)(ptr) ^ 0x80) - 0x80)
d797 1
a797 1
		 bfd_put_16
d801 1
a801 1
         	 BFD_SEND (abfd, bfd_getx_signed_16, (ptr))
d806 1
a806 1
		 bfd_put_32
d810 1
a810 1
		 BFD_SEND(abfd, bfd_getx_signed_32, (ptr))
d815 1
a815 1
		 bfd_put_64
d819 15
a833 1
		 BFD_SEND(abfd, bfd_getx_signed_64, (ptr))
d839 1
a839 1
		bfd_put_8 (abfd, val, ptr)
d841 1
a841 1
		bfd_put_8 (abfd, val, ptr)
d843 1
a843 1
		bfd_get_8 (abfd, ptr)
d845 1
a845 1
		bfd_get_signed_8 (abfd, ptr)
d850 1
a850 1
		 bfd_h_put_16
d854 1
a854 1
		 BFD_SEND(abfd, bfd_h_getx_signed_16, (ptr))
d859 1
a859 1
		 bfd_h_put_32
d863 1
a863 1
		 BFD_SEND(abfd, bfd_h_getx_signed_32, (ptr))
d868 1
a868 1
		 bfd_h_put_64
d872 22
a893 1
		 BFD_SEND(abfd, bfd_h_getx_signed_64, (ptr))
d960 1
a960 1
         /* The section is a constuctor, and should be placed at the
d990 1
a990 1
	    translate to bfd_com_section_ptr), but ECOFF has two. */
d1006 2
a1007 2
	    linker for executable and shared objects unless those
	    objects are to be further relocated.  */
d1010 3
a1012 3
	 /* The contents of this section are to be sorted by the
	   based on the address specified in the associated symbol
	   table.  */
d1015 4
a1018 4
	 /* When linking, duplicate sections of the same name should be
	   discarded, rather than being combined into a single section as
	   is usually done.  This is similar to how common symbols are
	   handled.  See SEC_LINK_DUPLICATES below.  */
d1021 2
a1022 2
	 /* If SEC_LINK_ONCE is set, this bitfield describes how the linker
	   should handle duplicate sections.  */
d1025 2
a1026 2
	 /* This value for SEC_LINK_DUPLICATES means that duplicate
	   sections with the same name should simply be discarded. */
d1029 3
a1031 3
	 /* This value for SEC_LINK_DUPLICATES means that the linker
	   should warn if there are any duplicate sections, although
	   it should still only link one copy.  */
d1034 2
a1035 2
	 /* This value for SEC_LINK_DUPLICATES means that the linker
	   should warn if any duplicate sections are a different size.  */
d1038 3
a1040 3
	 /* This value for SEC_LINK_DUPLICATES means that the linker
	   should warn if any duplicate sections contain different
	   contents.  */
d1043 8
a1050 1
	 /*  End of section flags.  */
d1052 3
a1054 1
	 /* Some internal packed boolean fields.  */
d1056 3
a1058 2
	 /* See the vma field.  */
	unsigned int user_set_vma : 1;
d1060 1
a1060 2
	 /* Whether relocations have been processed.  */
	unsigned int reloc_done : 1;
d1062 1
a1062 2
	 /* A mark flag used by some of the linker backends.  */
	unsigned int linker_mark : 1;
d1064 13
a1076 1
	 /* End of internal packed boolean fields.  */
d1080 4
a1083 4
	    user_set_vma flag is maintained by bfd; if it's not set, the
	    backend can assign addresses (for example, in <<a.out>>, where
	    the default address for <<.data>> is dependent on the specific
	    target and various flags).  */
d1089 1
a1089 1
	    information. */
d1093 3
a1095 3
         /* The size of the section in bytes, as it will be output.
           contains a value even if the section has no contents (e.g., the
           size of <<.bss>>). This will be filled in after relocation */
d1099 3
a1101 3
         /* The original size on disk of the section, in bytes.  Normally this
	    value is the same as the size, but if some relaxing has
	    been done, then this value will be bigger.  */
d1106 6
a1111 3
           offset into the output section of the first byte in the input
           section. E.g., if this was going to start at the 100th byte in
           the output section, this value would be 100. */
d1169 4
d1193 1
a1193 1
	  /* A symbol which points at this section only */
d1203 1
a1203 1
	these sections.  New code should use the section_ptr macros rather
d1232 2
a1233 1
     (section->reloc_done ? (abort(),1): (section)->_raw_size)
d1235 2
a1236 1
     ((section->reloc_done) ? (section)->_cooked_size: (abort(),1))
d1280 5
a1284 1
		(ibfd, isection, obfd, osection))
d1290 8
d1314 1
a1314 1
#define bfd_mach_i960_jx	 7
d1319 1
a1319 1
#define bfd_mach_sparc			1
d1321 7
a1327 6
#define bfd_mach_sparc_sparclet	2
#define bfd_mach_sparc_sparclite	3
#define bfd_mach_sparc_v8plus		4
#define bfd_mach_sparc_v8plusa		5  /* with ultrasparc add'ns */
#define bfd_mach_sparc_v9		6
#define bfd_mach_sparc_v9a		7  /* with ultrasparc add'ns */
d1332 15
d1350 1
d1354 1
d1367 5
d1373 2
a1374 2
#define bfd_mach_z8001		1
#define bfd_mach_z8002		2
d1377 7
d1385 3
d1389 8
d1399 11
d1412 11
d1437 1
a1437 1
  boolean the_default;	
d1439 2
a1440 2
	PARAMS ((const struct bfd_arch_info *a,
	         const struct bfd_arch_info *b));
d1452 3
d1488 7
d1544 1
a1544 1
	 /* Do not complain on overflow. */
d1547 2
a1548 2
	 /* Complain if the bitfield overflows, whether it is considered
	   as signed or unsigned. */
d1551 2
a1552 2
	 /* Complain if the value overflows when considered as signed
	   number. */
d1555 2
a1556 2
	 /* Complain if the value overflows when considered as an
	   unsigned number. */
d1562 1
a1562 1
        /*  The type field has mainly a documetary use - the back end can
d1574 3
a1576 3
	 /*  The size of the item to be relocated.  This is *not* a
	    power-of-two measure.  To get the number of bytes operated
	    on by a type of relocation, use bfd_get_reloc_size.  */
d1580 1
a1580 1
	    when doing overflow checking.  */
d1589 2
a1590 2
	 /*  The bit position of the reloc value in the destination.
	    The relocated value is left shifted by this amount. */
d1593 2
a1594 2
	 /* What type of overflow error should be checked for when
	   relocating. */
d1602 2
a1603 2
				    PARAMS ((bfd *abfd,
					     arelent *reloc_entry,
d1613 15
a1627 2
        /* When performing a partial link, some formats must modify the
          relocations rather than the data - this flag signals this.*/
d1632 1
a1632 1
          bit of data which we read and relocated, this would be
d1658 3
d1672 1
a1672 1
int 
d1681 9
d1715 1
d1817 1
a1817 1
/* Some relocations we're using for SPARC V9 -- subject to change. */
a1829 1
  BFD_RELOC_SPARC_GLOB_JMP,
d1833 11
a1872 3
The LITERALSLEAZY reloc is a hack to allow larger offsets (4x) than
LITERAL.

a1889 1
  BFD_RELOC_ALPHA_LITERALSLEAZY,
d1893 11
d1913 4
d1921 6
d1959 5
d1989 8
d2029 3
d2044 1
d2060 9
d2090 308
a2397 11
  BFD_RELOC_88K_32,
  BFD_RELOC_88K_LO16,
  BFD_RELOC_88K_HI16,
  BFD_RELOC_88K_IW16,
  BFD_RELOC_88K_16_PCREL,
  BFD_RELOC_88K_26_PCREL,
  BFD_RELOC_88K_GLOB_DAT,
  BFD_RELOC_88K_JMP_SLOT,
  BFD_RELOC_88K_RELATIVE,


d2410 9
a2418 9
	 /* A pointer to the BFD which owns the symbol. This information
	   is necessary so that a back end can work out what additional
   	   information (invisible to the application writer) is carried
	   with the symbol.

	   This field is *almost* redundant, since you can use section->owner
	   instead, except that some symbols point to the global sections
	   bfd_{abs,com,und}_section.  This could be fixed by making
	   these globals be per-bfd (or per-target-flavor).  FIXME. */
d2422 2
a2423 2
	 /* The text of the symbol. The name is left alone, and not copied; the
	   application may not alter it. */
d2426 1
a2426 1
	 /* The value of the symbol.  This really should be a union of a
d2431 1
a2431 1
	 /* Attributes of a symbol: */
d2435 19
a2453 19
	 /* The symbol has local scope; <<static>> in <<C>>. The value
 	   is the offset into the section of the data. */
#define BSF_LOCAL	0x01

	 /* The symbol has global scope; initialized data in <<C>>. The
	   value is the offset into the section of the data. */
#define BSF_GLOBAL	0x02

	 /* The symbol has global scope and is exported. The value is
	   the offset into the section of the data. */
#define BSF_EXPORT	BSF_GLOBAL  /* no real difference */

	 /* A normal C symbol would be one of:
	   <<BSF_LOCAL>>, <<BSF_FORT_COMM>>,  <<BSF_UNDEFINED>> or
	   <<BSF_GLOBAL>> */

	 /* The symbol is a debugging record. The value has an arbitary
	   meaning. */
#define BSF_DEBUGGING	0x08
d2455 2
a2456 2
	 /* The symbol denotes a function entry point.  Used in ELF,
	   perhaps others someday.  */
d2459 1
a2459 1
	 /* Used by the linker. */
d2463 2
a2464 2
	 /* A weak global symbol, overridable without warnings by
	   a regular global symbol of the same name.  */
d2468 1
a2468 1
	   STT_SECTION symbols.  */
d2471 2
a2472 2
	 /* The symbol used to be a common symbol, but now it is
	   allocated. */
d2475 1
a2475 1
	 /* The default value for common data. */
d2478 5
a2482 5
	 /* In some files the type of a symbol sometimes alters its
	   location in an output file - ie in coff a <<ISFCN>> symbol
	   which is also <<C_EXT>> symbol appears where it was
	   declared and not at the end of a section.  This bit is set
  	   by the target BFD part to convey this information. */
d2486 1
a2486 1
	 /* Signal that the symbol is the label of constructor section. */
d2489 4
a2492 4
	 /* Signal that the symbol is a warning symbol.  The name is a
	   warning.  The name of the next symbol is the one to warn about;
	   if a reference is made to a symbol with the same name as the next
	   symbol, a warning is issued by the linker. */
d2495 2
a2496 2
	 /* Signal that the symbol is indirect.  This symbol is an indirect
	   pointer to the symbol with the same name as the next symbol. */
d2499 2
a2500 2
	 /* BSF_FILE marks symbols that contain a file name.  This is used
	   for ELF STT_FILE symbols.  */
d2503 2
a2504 2
	 /* Symbol is from dynamic linking information.  */
#define BSF_DYNAMIC	   0x8000
d2508 6
a2513 1
#define BSF_OBJECT	   0x10000
d2517 2
a2518 2
	 /* A pointer to the section to which this symbol is
	   relative.  This will always be non NULL, there are special
d2522 1
a2522 1
	 /* Back end special data.  */
d2535 5
a2539 2
#define bfd_is_local_label(abfd, sym) \
     BFD_SEND (abfd, _bfd_is_local_label,(abfd, sym))
d2556 3
d2567 1
a2567 1
		(ibfd, isymbol, obfd, osymbol))
d2702 1
d2719 4
a2722 2
     /* Where all the allocated stuff under this BFD goes */
    struct obstack memory;
d2768 3
d2779 1
a2779 1
    asymbol	**syms));
d2813 1
a2813 1
		(ibfd, obfd))
d2819 1
a2819 1
		(ibfd, obfd))
d2825 1
a2825 1
		(abfd, flags))
d2855 3
d2859 1
a2859 1
	BFD_SEND (abfd, _bfd_link_hash_table_create, (abfd))
d2862 1
a2862 1
	BFD_SEND (abfd, _bfd_link_add_symbols, (abfd, info))
d2865 1
a2865 1
	BFD_SEND (abfd, _bfd_final_link, (abfd, info))
d2871 1
a2871 1
	BFD_SEND (abfd, _bfd_get_dynamic_symtab_upper_bound, (abfd))
d2874 1
a2874 1
	BFD_SEND (abfd, _bfd_print_private_bfd_data, (abfd, file))
d2877 1
a2877 1
	BFD_SEND (abfd, _bfd_canonicalize_dynamic_symtab, (abfd, asymbols))
d2880 1
a2880 1
	BFD_SEND (abfd, _bfd_get_dynamic_reloc_upper_bound, (abfd))
d2883 1
a2883 1
	BFD_SEND (abfd, _bfd_canonicalize_dynamic_reloc, (abfd, arels, asyms))
d2886 3
a2888 3
	PARAMS ((bfd *, struct bfd_link_info *,
		  struct bfd_link_order *, bfd_byte *,
		  boolean, asymbol **));
d2945 1
d3018 1
a3018 1
  boolean	 (*_bfd_copy_private_bfd_data) PARAMS ((bfd *, bfd *));
d3021 1
a3021 1
  boolean	 (*_bfd_merge_private_bfd_data) PARAMS ((bfd *, bfd *));
d3029 1
a3029 1
							   bfd *, asymbol *));
d3031 1
a3031 1
  boolean	 (*_bfd_set_private_flags) PARAMS ((bfd *, flagword));
d3081 1
a3081 1
CAT(NAME,_bfd_is_local_label),\
d3100 1
a3100 1
  boolean	 (*_bfd_is_local_label) PARAMS ((bfd *, asymbol *));
d3153 2
a3154 1
CAT(NAME,_bfd_link_split_section)
d3178 4
a3181 1
  /* Routines to handle dynamic symbols and relocs.  */
d3198 3
d3202 1
d3204 3
d3212 3
@


1.5
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d1796 9
a1804 1

@


1.4
log
@Alpha support based on Chris Demetriou's <cgd@@cs.cmu.edu> work
@
text
@d1149 1
a1149 1
     BFD_SEND (ibfd, _bfd_copy_private_section_data, \
d1216 2
d1622 9
d1643 1
d1798 1
d1956 1
a1956 1
     BFD_SEND (ibfd, _bfd_copy_private_symbol_data, \
d2196 1
a2196 1
     BFD_SEND (ibfd, _bfd_copy_private_bfd_data, \
d2202 1
a2202 1
     BFD_SEND (ibfd, _bfd_merge_private_bfd_data, \
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d1631 1
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d56 1
a56 1
#define BFD_ARCH_SIZE @@WORDSIZE@@
d58 4
d121 2
a122 2
   use gcc's "long long" type.  Otherwise, the compilation will fail
   if 64-bit targets are requested.  */
d129 1
d133 1
d140 1
a140 1
typedef unsigned BFD_HOST_64_BIT bfd_vma;
d142 2
a143 2
typedef unsigned BFD_HOST_64_BIT bfd_size_type;
typedef unsigned BFD_HOST_64_BIT symvalue;
d202 1
a202 1
#define NO_FLAGS    	0x00
d1190 2
d1203 1
d1592 2
a1593 2
/* Alpha ECOFF relocations.  Some of these treat the symbol or "addend"
in some special way.
d1606 5
d1638 4
d1756 29
d2311 2
a2312 1
  bfd_target_msdos_flavour
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
d128 3
a130 1
#endif /* defined (__GNUC__) */
d240 4
d333 4
a336 3
  char stab_other;             /* Unused. */
  short stab_desc;             /* Info for N_TYPE.  */
  CONST char *stab_name;
d338 4
d478 6
d502 4
d608 1
d622 3
a624 1
extern boolean bfd_linux_size_dynamic_sections
d668 13
a680 1
	   int, boolean, struct sec **));
d879 1
a879 1
         /* The section is a common section (symbols may be defined
d898 38
d938 13
a958 1
   boolean user_set_vma;
a1058 1
   boolean reloc_done;
d1166 2
d1171 11
a1181 2
#define bfd_mach_sparc		1
#define bfd_mach_sparc64	2
d1579 3
a1581 1
  BFD_RELOC_SPARC_LO7,
d1656 4
d1700 16
d1846 4
d1909 4
a1912 2
       is the result of an fopen on the filename. */
    char *iostream;
d2025 1
d2040 1
a2216 3
bfd_get_elt_at_index PARAMS ((bfd *archive, int index));

bfd *
d2260 1
d2267 2
d2276 2
a2277 2
  boolean byteorder_big_p;
  boolean header_byteorder_big_p;
d2372 1
d2387 2
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d128 1
a128 3
#else /* ! defined (__GNUC__) */
 #error No 64 bit integer type available
#endif /* ! defined (__GNUC__) */
a237 4

/* This flag indicates that the BFD contents are actually cached in
   memory.  If this is set, iostream points to a bfd_in_memory struct.  */
#define BFD_IN_MEMORY 0x800
d327 3
a329 4
  unsigned char stab_type;     /* Stab type.  */
  char stab_other;             /* Stab other. */
  short stab_desc;             /* Stab desc.  */
  CONST char *stab_name;       /* String for stab type.  */
a330 4

/* Get the name of a stabs type code.  */

extern const char *bfd_get_stab_name PARAMS ((int));
a466 6
#define bfd_big_endian(abfd) ((abfd)->xvec->byteorder == BFD_ENDIAN_BIG)
#define bfd_little_endian(abfd) ((abfd)->xvec->byteorder == BFD_ENDIAN_LITTLE)
#define bfd_header_big_endian(abfd) \
  ((abfd)->xvec->header_byteorder == BFD_ENDIAN_BIG)
#define bfd_header_little_endian(abfd) \
  ((abfd)->xvec->header_byteorder == BFD_ENDIAN_LITTLE)
a484 4
extern boolean bfd_record_phdr
  PARAMS ((bfd *, unsigned long, boolean, flagword, boolean, bfd_vma,
	   boolean, boolean, unsigned int, struct sec **));

a586 1
extern const char *bfd_elf_get_dt_soname PARAMS ((bfd *));
d600 1
a600 3
extern boolean bfd_i386linux_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
extern boolean bfd_m68klinux_size_dynamic_sections
d644 1
a644 13
	   int, boolean, boolean, struct sec **));

/* Externally visible COFF routines.  */

#if defined(__STDC__) || defined(ALMOST_STDC)
struct internal_syment;
union internal_auxent;
#endif

extern boolean bfd_coff_get_syment
  PARAMS ((bfd *, struct symbol_cache_entry *, struct internal_syment *));
extern boolean bfd_coff_get_auxent
  PARAMS ((bfd *, struct symbol_cache_entry *, int, union internal_auxent *));
d843 1
a843 1
         /* The section contains common symbols (symbols may be defined
a861 38
         /* The contents of this section are to be excluded by the
	    linker for executable and shared objects unless those
	    objects are to be further relocated.  */
#define SEC_EXCLUDE 0x40000

	 /* The contents of this section are to be sorted by the
	   based on the address specified in the associated symbol
	   table.  */
#define SEC_SORT_ENTRIES 0x80000

	 /* When linking, duplicate sections of the same name should be
	   discarded, rather than being combined into a single section as
	   is usually done.  This is similar to how common symbols are
	   handled.  See SEC_LINK_DUPLICATES below.  */
#define SEC_LINK_ONCE 0x100000

	 /* If SEC_LINK_ONCE is set, this bitfield describes how the linker
	   should handle duplicate sections.  */
#define SEC_LINK_DUPLICATES 0x600000

	 /* This value for SEC_LINK_DUPLICATES means that duplicate
	   sections with the same name should simply be discarded. */
#define SEC_LINK_DUPLICATES_DISCARD 0x0

	 /* This value for SEC_LINK_DUPLICATES means that the linker
	   should warn if there are any duplicate sections, although
	   it should still only link one copy.  */
#define SEC_LINK_DUPLICATES_ONE_ONLY 0x200000

	 /* This value for SEC_LINK_DUPLICATES means that the linker
	   should warn if any duplicate sections are a different size.  */
#define SEC_LINK_DUPLICATES_SAME_SIZE 0x400000

	 /* This value for SEC_LINK_DUPLICATES means that the linker
	   should warn if any duplicate sections contain different
	   contents.  */
#define SEC_LINK_DUPLICATES_SAME_CONTENTS 0x600000

a863 13
	 /* Some internal packed boolean fields.  */

	 /* See the vma field.  */
	unsigned int user_set_vma : 1;

	 /* Whether relocations have been processed.  */
	unsigned int reloc_done : 1;

	 /* A mark flag used by some of the linker backends.  */
	unsigned int linker_mark : 1;

	 /* End of internal packed boolean fields.  */

d872 1
d973 1
a1080 2
#define bfd_mach_i960_jx	 7
#define bfd_mach_i960_hx        8
d1084 2
a1085 11
#define bfd_mach_sparc			1
 /* The difference between v8plus and v9 is that v9 is a true 64 bit env.  */
#define bfd_mach_sparc_sparclet	2
#define bfd_mach_sparc_sparclite	3
#define bfd_mach_sparc_v8plus		4
#define bfd_mach_sparc_v8plusa		5  /* with ultrasparc add'ns */
#define bfd_mach_sparc_v9		6
#define bfd_mach_sparc_v9a		7  /* with ultrasparc add'ns */
 /* Nonzero if MACH has the v9 instruction set.  */
#define bfd_mach_sparc_v9_p(mach) \
  ((mach) >= bfd_mach_sparc_v8plus && (mach) <= bfd_mach_sparc_v9a)
d1483 1
a1483 3
  BFD_RELOC_SPARC_7,
  BFD_RELOC_SPARC_6,
  BFD_RELOC_SPARC_5,
a1557 4
  BFD_RELOC_MIPS_GOT_HI16,
  BFD_RELOC_MIPS_GOT_LO16,
  BFD_RELOC_MIPS_CALL_HI16,
  BFD_RELOC_MIPS_CALL_LO16,
a1597 16
  BFD_RELOC_PPC_EMB_NADDR32,
  BFD_RELOC_PPC_EMB_NADDR16,
  BFD_RELOC_PPC_EMB_NADDR16_LO,
  BFD_RELOC_PPC_EMB_NADDR16_HI,
  BFD_RELOC_PPC_EMB_NADDR16_HA,
  BFD_RELOC_PPC_EMB_SDAI16,
  BFD_RELOC_PPC_EMB_SDA2I16,
  BFD_RELOC_PPC_EMB_SDA2REL,
  BFD_RELOC_PPC_EMB_SDA21,
  BFD_RELOC_PPC_EMB_MRKREF,
  BFD_RELOC_PPC_EMB_RELSEC16,
  BFD_RELOC_PPC_EMB_RELST_LO,
  BFD_RELOC_PPC_EMB_RELST_HI,
  BFD_RELOC_PPC_EMB_RELST_HA,
  BFD_RELOC_PPC_EMB_BIT_FLD,
  BFD_RELOC_PPC_EMB_RELSDA,
a1727 4
        /* The symbol denotes a data object.  Used in ELF, and perhaps
          others someday.  */
#define BSF_OBJECT	   0x10000

d1787 2
a1788 4
       is the result of an fopen on the filename.  However, if the
       BFD_IN_MEMORY flag is set, then iostream is actually a pointer
       to a bfd_in_memory struct.  */
    PTR iostream;
a1900 1
      struct ihex_data_struct *ihex_data;
a1914 1
      struct netbsd_core_struct *netbsd_core_data;
d2091 3
a2136 1
  bfd_target_ihex_flavour,
a2142 2
enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };

d2150 2
a2151 2
  enum bfd_endian byteorder;
  enum bfd_endian header_byteorder;
a2245 1
CAT(NAME,_get_elt_at_index),\
a2259 2
#define bfd_get_elt_at_index(b,i) BFD_SEND(b, _bfd_get_elt_at_index, (b,i))
  bfd *    (*_bfd_get_elt_at_index) PARAMS ((bfd *, symindex));
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d56 1
a56 1
#define BFD_ARCH_SIZE @@wordsize@@
a57 4
#if @@BFD_HOST_64_BIT_DEFINED@@
#define BFD_HOST_64_BIT @@BFD_HOST_64_BIT@@
#define BFD_HOST_U_64_BIT @@BFD_HOST_U_64_BIT@@
#endif
d117 2
a118 2
   use gcc's "long long" type.  Otherwise, BFD_HOST_64_BIT must be
   defined above.  */
a124 1
#define BFD_HOST_U_64_BIT unsigned long
a127 1
#define BFD_HOST_U_64_BIT unsigned long long
d134 1
a134 1
typedef BFD_HOST_U_64_BIT bfd_vma;
d136 2
a137 2
typedef BFD_HOST_U_64_BIT bfd_size_type;
typedef BFD_HOST_U_64_BIT symvalue;
d196 1
a196 1
#define BFD_NO_FLAGS   	0x00
a1183 2
#define bfd_mach_i386_i386 0
#define bfd_mach_i386_i8086 1
a1194 1
#define bfd_mach_h8300s  3
d1583 2
a1584 2
/* Alpha ECOFF and ELF relocations.  Some of these treat the symbol or
"addend" in some special way.
a1596 5
/* The ELF GPDISP relocation is exactly the same as the GPDISP_HI16
relocation except that there is no accompanying GPDISP_LO16
relocation. */
  BFD_RELOC_ALPHA_GPDISP,

a1623 4
/* The LINKAGE relocation outputs a linkage pair in the object file,
which is filled by the linker. */
  BFD_RELOC_ALPHA_LINKAGE,

a1737 29
  BFD_RELOC_ARM_OFFSET_IMM8,
  BFD_RELOC_ARM_HWLITERAL,
  BFD_RELOC_ARM_THUMB_ADD,
  BFD_RELOC_ARM_THUMB_IMM,
  BFD_RELOC_ARM_THUMB_SHIFT,
  BFD_RELOC_ARM_THUMB_OFFSET,

/* Hitachi SH relocs.  Not all of these appear in object files. */
  BFD_RELOC_SH_PCDISP8BY2,
  BFD_RELOC_SH_PCDISP12BY2,
  BFD_RELOC_SH_IMM4,
  BFD_RELOC_SH_IMM4BY2,
  BFD_RELOC_SH_IMM4BY4,
  BFD_RELOC_SH_IMM8,
  BFD_RELOC_SH_IMM8BY2,
  BFD_RELOC_SH_IMM8BY4,
  BFD_RELOC_SH_PCRELIMM8BY2,
  BFD_RELOC_SH_PCRELIMM8BY4,
  BFD_RELOC_SH_SWITCH16,
  BFD_RELOC_SH_SWITCH32,
  BFD_RELOC_SH_USES,
  BFD_RELOC_SH_COUNT,
  BFD_RELOC_SH_ALIGN,
  BFD_RELOC_SH_CODE,
  BFD_RELOC_SH_DATA,
  BFD_RELOC_SH_LABEL,



d2264 1
a2264 2
  bfd_target_msdos_flavour,
  bfd_target_evax_flavour
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d1149 1
a1149 1
     BFD_SEND (obfd, _bfd_copy_private_section_data, \
a1215 2
  bfd_arch_mn10200,    /* Matsushita MN10200 */
  bfd_arch_mn10300,    /* Matsushita MN10300 */
a1619 6
The ELF_LITERAL reloc is somewhere between 16_GOTOFF and GPDISP_LO16.
It should refer to the symbol to be referenced, as with 16_GOTOFF,
but it generates output not based on the position within the .got
section, but relative to the GP value chosen for the file during the
final link stage.

a1630 1
  BFD_RELOC_ALPHA_ELF_LITERAL,
a1784 1

d1942 1
a1942 1
     BFD_SEND (obfd, _bfd_copy_private_symbol_data, \
d2182 1
a2182 1
     BFD_SEND (obfd, _bfd_copy_private_bfd_data, \
d2188 1
a2188 1
     BFD_SEND (obfd, _bfd_merge_private_bfd_data, \
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d52 1
d383 2
a384 3
   /* An objalloc for this hash table.  This is a struct objalloc *,
     but we use PTR to avoid requiring the inclusion of objalloc.h.  */
  PTR memory;
a541 1
struct bfd_elf_version_tree;
d608 2
a609 3
  PARAMS ((bfd *, const char *, const char *, boolean, const char *,
	   const char * const *, struct bfd_link_info *, struct sec **,
	   struct bfd_elf_version_tree *));
d611 2
a612 3
  PARAMS ((bfd *, const char *, const char *, boolean, const char *,
	   const char * const *, struct bfd_link_info *, struct sec **,
	   struct bfd_elf_version_tree *));
a631 2
extern boolean bfd_sparclinux_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
d699 1
a699 1
bfd_openstreamr PARAMS ((const char *, const char *, PTR));
d710 3
a941 6
	 /* This section was created by the linker as part of dynamic
	   relocation or other arcane processing.  It is skipped when
	   going through the first-pass output, trusting that someone
	   else up the line will take care of it later.  */
#define SEC_LINKER_CREATED 0x800000

a1206 1
  bfd_arch_d10v,       /* Mitsubishi D10V */
a1215 1
  bfd_arch_m32r,       /* Mitsubishi M32R/D */
d1347 1
a1347 1
        /*  The type field has mainly a documentary use - the back end can
a1474 1
  BFD_RELOC_24,
a1650 4
/* The CODEADDR relocation outputs a STO_CA in the object file,
which is filled by the linker. */
  BFD_RELOC_ALPHA_CODEADDR,

a1654 6
/* The MIPS16 jump instruction. */
  BFD_RELOC_MIPS16_JMP,

/* MIPS16 GP relative reloc. */
  BFD_RELOC_MIPS16_GPREL,

a1792 25
/* Mitsubishi D10V relocs.
This is a 10-bit reloc with the right 2 bits
assumed to be 0. */
  BFD_RELOC_D10V_10_PCREL_R,

/* Mitsubishi D10V relocs.
This is a 10-bit reloc with the right 2 bits
assumed to be 0.  This is the same as the previous reloc
except it is in the left container, i.e.,
shifted left 15 bits. */
  BFD_RELOC_D10V_10_PCREL_L,

/* This is an 18-bit reloc with the right 2 bits
assumed to be 0. */
  BFD_RELOC_D10V_18,

/* This is an 18-bit reloc with the right 2 bits
assumed to be 0. */
  BFD_RELOC_D10V_18_PCREL,



/* Mitsubishi M32R relocs.
This is a 24 bit absolute address. */
  BFD_RELOC_M32R_24,
a1793 2
/* This is a 10-bit pc-relative reloc with the right 2 bits assumed to be 0. */
  BFD_RELOC_M32R_10_PCREL,
a1794 29
/* This is an 18-bit reloc with the right 2 bits assumed to be 0. */
  BFD_RELOC_M32R_18_PCREL,

/* This is a 26-bit reloc with the right 2 bits assumed to be 0. */
  BFD_RELOC_M32R_26_PCREL,

/* This is a 16-bit reloc containing the high 16 bits of an address
used when the lower 16 bits are treated as unsigned. */
  BFD_RELOC_M32R_HI16_ULO,

/* This is a 16-bit reloc containing the high 16 bits of an address
used when the lower 16 bits are treated as signed. */
  BFD_RELOC_M32R_HI16_SLO,

/* This is a 16-bit reloc containing the lower 16 bits of an address. */
  BFD_RELOC_M32R_LO16,

/* This is a 16-bit reloc containing the small data area offset for use in
add3, load, and store instructions. */
  BFD_RELOC_M32R_SDA16,


/* This is a 32bit pcrel reloc for the mn10300, offset by two bytes in the
instruction. */
  BFD_RELOC_MN10300_32_PCREL,

/* This is a 16bit pcrel reloc for the mn10300, offset by two bytes in the
instruction. */
  BFD_RELOC_MN10300_16_PCREL,
d1927 2
a1928 5
boolean 
bfd_is_local_label_name PARAMS ((bfd *abfd, const char *name));

#define bfd_is_local_label_name(abfd, name) \
     BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name))
d2104 2
a2105 4
   /* Where all the allocated stuff under this BFD goes.  This is a
     struct objalloc *, but we use PTR to avoid requiring the inclusion of
     objalloc.h.  */
    PTR memory;
d2457 1
a2457 1
CAT(NAME,_bfd_is_local_label_name),\
d2476 1
a2476 1
  boolean	 (*_bfd_is_local_label_name) PARAMS ((bfd *, const char *));
a2571 3
boolean 
bfd_set_default_target  PARAMS ((const char *name));

@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
d91 1
a91 1
#if defined (__GNUG__) && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 6))
a122 14
#ifndef BFD_HOST_64_BIT
# if BFD_HOST_64BIT_LONG
#  define BFD_HOST_64_BIT long
#  define BFD_HOST_U_64_BIT unsigned long
# else
#  ifdef __GNUC__
#   if __GNUC__ >= 2
#    define BFD_HOST_64_BIT long long
#    define BFD_HOST_U_64_BIT unsigned long long
#   endif /* __GNUC__ >= 2 */
#  endif /* ! defined (__GNUC__) */
# endif /* ! BFD_HOST_64BIT_LONG */
#endif /* ! defined (BFD_HOST_64_BIT) */

d126 8
d135 2
a176 1

a177 1

a311 1
#define bfd_section_lma(bfd, ptr) ((ptr)->lma)
a607 2
extern boolean bfd_elf_get_bfd_needed_list
  PARAMS ((bfd *, struct bfd_link_needed_list **));
a618 14
/* Return an upper bound on the number of bytes required to store a
   copy of ABFD's program header table entries.  Return -1 if an error
   occurs; bfd_get_error will return an appropriate code.  */
extern long bfd_get_elf_phdr_upper_bound PARAMS ((bfd *abfd));

/* Copy ABFD's program header table entries to *PHDRS.  The entries
   will be stored as an array of Elf_Internal_Phdr structures, as
   defined in include/elf/internal.h.  To find out how large the
   buffer needs to be, call bfd_get_elf_phdr_upper_bound.

   Return the number of program header table entries read, or -1 if an
   error occurs; bfd_get_error will return an appropriate code.  */
extern int bfd_get_elf_phdrs PARAMS ((bfd *abfd, void *phdrs));

a689 1

a692 33
extern boolean bfd_coff_set_symbol_class
  PARAMS ((bfd *, struct symbol_cache_entry *, unsigned int));

/* ARM Interworking support.  Called from linker.  */
extern boolean bfd_arm_allocate_interworking_sections
  PARAMS ((struct bfd_link_info *));

extern boolean bfd_arm_process_before_allocation
  PARAMS ((bfd *, struct bfd_link_info *, int));

extern boolean bfd_arm_get_bfd_for_interworking
  PARAMS ((bfd *, struct bfd_link_info *));

/* PE ARM Interworking support.  Called from linker.  */
extern boolean bfd_arm_pe_allocate_interworking_sections
  PARAMS ((struct bfd_link_info *));

extern boolean bfd_arm_pe_process_before_allocation
  PARAMS ((bfd *, struct bfd_link_info *, int));

extern boolean bfd_arm_pe_get_bfd_for_interworking
  PARAMS ((bfd *, struct bfd_link_info *));

/* ELF ARM Interworking support.  Called from linker.  */
extern boolean bfd_elf32_arm_allocate_interworking_sections
  PARAMS ((struct bfd_link_info *));

extern boolean bfd_elf32_arm_process_before_allocation
  PARAMS ((bfd *, struct bfd_link_info *, int));

extern boolean bfd_elf32_arm_get_bfd_for_interworking
  PARAMS ((bfd *, struct bfd_link_info *));

a717 6
boolean 
bfd_make_writable PARAMS ((bfd *abfd));

boolean 
bfd_make_readable PARAMS ((bfd *abfd));

d722 1
a722 1
                ((void) (*((unsigned char *)(ptr)) = (unsigned char)(val)))
d724 1
a724 1
               bfd_put_8
d728 1
a728 1
               ((*(unsigned char *)(ptr) ^ 0x80) - 0x80)
d733 1
a733 1
                bfd_put_16
d737 1
a737 1
                BFD_SEND (abfd, bfd_getx_signed_16, (ptr))
d742 1
a742 1
                bfd_put_32
d746 1
a746 1
                BFD_SEND(abfd, bfd_getx_signed_32, (ptr))
d751 1
a751 1
                bfd_put_64
d755 1
a755 15
                BFD_SEND(abfd, bfd_getx_signed_64, (ptr))

#define bfd_get(bits, abfd, ptr)                               \
                ((bits) == 8 ? bfd_get_8 (abfd, ptr)           \
                : (bits) == 16 ? bfd_get_16 (abfd, ptr)        \
                : (bits) == 32 ? bfd_get_32 (abfd, ptr)        \
                : (bits) == 64 ? bfd_get_64 (abfd, ptr)        \
                : (abort (), (bfd_vma) - 1))

#define bfd_put(bits, abfd, val, ptr)                          \
                ((bits) == 8 ? bfd_put_8 (abfd, val, ptr)      \
                : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)   \
                : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)   \
                : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)   \
                : (abort (), (void) 0))
d761 1
a761 1
               bfd_put_8 (abfd, val, ptr)
d763 1
a763 1
               bfd_put_8 (abfd, val, ptr)
d765 1
a765 1
               bfd_get_8 (abfd, ptr)
d767 1
a767 1
               bfd_get_signed_8 (abfd, ptr)
d772 1
a772 1
                bfd_h_put_16
d776 1
a776 1
                BFD_SEND(abfd, bfd_h_getx_signed_16, (ptr))
d781 1
a781 1
                bfd_h_put_32
d785 1
a785 1
                BFD_SEND(abfd, bfd_h_getx_signed_32, (ptr))
d790 1
a790 1
                bfd_h_put_64
d794 1
a794 22
                BFD_SEND(abfd, bfd_h_getx_signed_64, (ptr))

  /* This structure is used for a comdat section, as in PE.  A comdat
    section is associated with a particular symbol.  When the linker
    sees a comdat section, it keeps only one of the sections with a
    given name and associated with a given symbol. */

struct bfd_comdat_info
{
   /* The name of the symbol associated with a comdat section.  */
  const char *name;

   /* The local symbol table index of the symbol associated with a
     comdat section.  This is only meaningful to the object file format
     specific code; it is not an index into the list returned by
     bfd_canonicalize_symtab.  */
  long symbol;

   /* If this section is being discarded, the linker uses this field
     to point to the input section which is being kept.  */
  struct sec *sec;
};
d861 1
a861 1
         /* The section is a constructor, and should be placed at the
d891 1
a891 1
           translate to bfd_com_section_ptr), but ECOFF has two. */
d907 2
a908 2
           linker for executable and shared objects unless those
           objects are to be further relocated.  */
d911 3
a913 3
        /* The contents of this section are to be sorted by the
          based on the address specified in the associated symbol
          table.  */
d916 4
a919 4
        /* When linking, duplicate sections of the same name should be
          discarded, rather than being combined into a single section as
          is usually done.  This is similar to how common symbols are
          handled.  See SEC_LINK_DUPLICATES below.  */
d922 2
a923 2
        /* If SEC_LINK_ONCE is set, this bitfield describes how the linker
          should handle duplicate sections.  */
d926 2
a927 2
        /* This value for SEC_LINK_DUPLICATES means that duplicate
          sections with the same name should simply be discarded. */
d930 3
a932 3
        /* This value for SEC_LINK_DUPLICATES means that the linker
          should warn if there are any duplicate sections, although
          it should still only link one copy.  */
d935 2
a936 2
        /* This value for SEC_LINK_DUPLICATES means that the linker
          should warn if any duplicate sections are a different size.  */
d939 3
a941 3
        /* This value for SEC_LINK_DUPLICATES means that the linker
          should warn if any duplicate sections contain different
          contents.  */
d944 4
a947 4
        /* This section was created by the linker as part of dynamic
          relocation or other arcane processing.  It is skipped when
          going through the first-pass output, trusting that someone
          else up the line will take care of it later.  */
d950 1
a950 2
        /* This section should not be subject to garbage collection.  */
#define SEC_KEEP 0x1000000
d952 1
a952 3
        /* This section contains "short" data, and should be placed
          "near" the GP.  */
#define SEC_SMALL_DATA 0x2000000
d954 2
a955 3
        /* This section contains data which may be shared with other
          executables or shared objects.  */
#define SEC_SHARED 0x4000000
d957 2
a958 1
        /*  End of section flags.  */
d960 2
a961 1
        /* Some internal packed boolean fields.  */
d963 1
a963 13
        /* See the vma field.  */
       unsigned int user_set_vma : 1;

        /* Whether relocations have been processed.  */
       unsigned int reloc_done : 1;

        /* A mark flag used by some of the linker backends.  */
       unsigned int linker_mark : 1;

        /* A mark flag used by some linker backends for garbage collection.  */
       unsigned int gc_mark : 1;

        /* End of internal packed boolean fields.  */
d967 4
a970 4
           user_set_vma flag is maintained by bfd; if it's not set, the
           backend can assign addresses (for example, in <<a.out>>, where
           the default address for <<.data>> is dependent on the specific
           target and various flags).  */
d976 1
a976 1
           information. */
d980 3
a982 3
         /* The size of the section in octets, as it will be output.
           Contains a value even if the section has no contents (e.g., the
           size of <<.bss>>).  This will be filled in after relocation.  */
d986 3
a988 3
         /* The original size on disk of the section, in octets.  Normally this
           value is the same as the size, but if some relaxing has
           been done, then this value will be bigger.  */
d993 3
a995 6
           offset in *bytes* into the output section of the first byte in the
           input section (byte ==> smallest addressable unit on the
           target).  In most cases, if this was going to start at the
           100th octet (8-bit quantity) in the output section, this value
           would be 100.  However, if the target byte size is 16 bits
           (bfd_octets_per_byte is "2"), this value would be 50. */
a1052 4
         /* Optional information about a COMDAT entry; NULL if not COMDAT */

   struct bfd_comdat_info *comdat;

d1073 1
a1073 1
         /* A symbol which points at this section only */
d1083 1
a1083 1
       these sections.  New code should use the section_ptr macros rather
d1112 1
a1112 2
     ((section)->reloc_done ? (abort (), (bfd_size_type) 1) \
                            : (section)->_raw_size)
d1114 1
a1114 2
     ((section)->reloc_done ? (section)->_cooked_size \
                            : (abort (), (bfd_size_type) 1))
d1158 1
a1158 5
               (ibfd, isection, obfd, osection))
void 
_bfd_strip_section_from_output
 PARAMS ((struct bfd_link_info *info, asection *section));

a1163 8
#define bfd_mach_m68000 1
#define bfd_mach_m68008 2
#define bfd_mach_m68010 3
#define bfd_mach_m68020 4
#define bfd_mach_m68030 5
#define bfd_mach_m68040 6
#define bfd_mach_m68060 7
#define bfd_mach_cpu32  8
d1180 1
a1180 1
#define bfd_mach_i960_jx        7
d1185 1
a1185 1
#define bfd_mach_sparc                 1
d1187 6
a1192 7
#define bfd_mach_sparc_sparclet        2
#define bfd_mach_sparc_sparclite       3
#define bfd_mach_sparc_v8plus          4
#define bfd_mach_sparc_v8plusa         5  /* with ultrasparc add'ns */
#define bfd_mach_sparc_sparclite_le    6
#define bfd_mach_sparc_v9              7
#define bfd_mach_sparc_v9a             8  /* with ultrasparc add'ns */
a1196 15
#define bfd_mach_mips3000              3000
#define bfd_mach_mips3900              3900
#define bfd_mach_mips4000              4000
#define bfd_mach_mips4010              4010
#define bfd_mach_mips4100              4100
#define bfd_mach_mips4111              4111
#define bfd_mach_mips4300              4300
#define bfd_mach_mips4400              4400
#define bfd_mach_mips4600              4600
#define bfd_mach_mips4650              4650
#define bfd_mach_mips5000              5000
#define bfd_mach_mips6000              6000
#define bfd_mach_mips8000              8000
#define bfd_mach_mips10000             10000
#define bfd_mach_mips16                16
a1199 1
#define bfd_mach_i386_i386_intel_syntax 2
a1202 1
  bfd_arch_i370,       /* IBM 360/370 Mainframes */
a1215 4
#define bfd_mach_d10v          0
#define bfd_mach_d10v_ts2      2
#define bfd_mach_d10v_ts3      3
  bfd_arch_d30v,       /* Mitsubishi D30V */
d1217 2
a1218 2
#define bfd_mach_z8001         1
#define bfd_mach_z8002         2
a1220 7
#define bfd_mach_sh            0
#define bfd_mach_sh2        0x20
#define bfd_mach_sh_dsp     0x2d
#define bfd_mach_sh3        0x30
#define bfd_mach_sh3_dsp    0x3d
#define bfd_mach_sh3e       0x3e
#define bfd_mach_sh4        0x40
a1221 3
#define bfd_mach_alpha_ev4  0x10
#define bfd_mach_alpha_ev5  0x20
#define bfd_mach_alpha_ev6  0x30
a1222 8
#define bfd_mach_arm_2         1
#define bfd_mach_arm_2a        2
#define bfd_mach_arm_3         3
#define bfd_mach_arm_3M        4
#define bfd_mach_arm_4         5
#define bfd_mach_arm_4T        6
#define bfd_mach_arm_5         7
#define bfd_mach_arm_5T        8
a1224 8
  bfd_arch_tic30,      /* Texas Instruments TMS320C30 */
  bfd_arch_tic80,      /* TI TMS320c80 (MVP) */
  bfd_arch_v850,       /* NEC V850 */
#define bfd_mach_v850          0
#define bfd_mach_v850e         'E'
#define bfd_mach_v850ea        'A'
  bfd_arch_arc,        /* Argonaut RISC Core */
#define bfd_mach_arc_base 0
a1225 2
#define bfd_mach_m32r          0  /* backwards compatibility */
#define bfd_mach_m32rx         'x'
a1227 11
#define bfd_mach_mn10300               300
#define bfd_mach_am33          330
  bfd_arch_fr30,
#define bfd_mach_fr30          0x46523330
  bfd_arch_mcore,
  bfd_arch_pj,
  bfd_arch_avr,        /* Atmel AVR microcontrollers */
#define bfd_mach_avr1          1
#define bfd_mach_avr2          2
#define bfd_mach_avr3          3
#define bfd_mach_avr4          4
d1242 1
a1242 1
  boolean the_default; 
d1244 2
a1245 2
       PARAMS ((const struct bfd_arch_info *a,
                const struct bfd_arch_info *b));
a1256 3
const char **
bfd_arch_list PARAMS ((void));

a1289 7
unsigned int 
bfd_octets_per_byte PARAMS ((bfd *abfd));

unsigned int 
bfd_arch_mach_octets_per_byte PARAMS ((enum bfd_architecture arch,
    unsigned long machine));

d1339 1
a1339 1
        /* Do not complain on overflow. */
d1342 2
a1343 2
        /* Complain if the bitfield overflows, whether it is considered
          as signed or unsigned. */
d1346 2
a1347 2
        /* Complain if the value overflows when considered as signed
          number. */
d1350 2
a1351 2
        /* Complain if the value overflows when considered as an
          unsigned number. */
d1369 3
a1371 3
        /*  The size of the item to be relocated.  This is *not* a
           power-of-two measure.  To get the number of bytes operated
           on by a type of relocation, use bfd_get_reloc_size.  */
d1375 1
a1375 1
           when doing overflow checking.  */
d1384 2
a1385 2
        /*  The bit position of the reloc value in the destination.
           The relocated value is left shifted by this amount. */
d1388 2
a1389 2
        /* What type of overflow error should be checked for when
          relocating. */
d1397 2
a1398 2
                                   PARAMS ((bfd *abfd,
                                            arelent *reloc_entry,
d1408 2
a1409 15
        /* Some formats record a relocation addend in the section contents
          rather than with the relocation.  For ELF formats this is the
          distinction between USE_REL and USE_RELA (though the code checks
          for USE_REL == 1/0).  The value of this field is TRUE if the
          addend is recorded with the section contents; when performing a
          partial link (ld -r) the section contents (the data) will be
          modified.  The value of this field is FALSE if addends are
          recorded with the relocation (in arelent.addend); when performing
          a partial link the relocation will be modified.
          All relocations for all ELF USE_RELA targets should set this field
          to FALSE (values of TRUE should be looked on with suspicion).
          However, the converse is not true: not all relocations of all ELF
          USE_REL targets set this field to TRUE.  Why this is so is peculiar
          to each particular target.  For relocs that aren't used in partial
          links (e.g. GOT stuff) it doesn't matter what this is set to.  */
d1414 1
a1414 1
          byte of data which we read and relocated, this would be
a1439 3
#define EMPTY_HOWTO(C) \
  HOWTO((C),0,0,0,false,0,complain_overflow_dont,NULL,NULL,false,0,0,false)

d1451 1
a1451 1
unsigned int 
a1459 9
bfd_check_overflow
 PARAMS ((enum complain_overflow how,
    unsigned int bitsize,
    unsigned int rightshift,
    unsigned int addrsize,
    bfd_vma relocation));

bfd_reloc_status_type

d1587 1
a1587 1
/* SPARC64 relocations */
d1600 1
a1603 11
#define BFD_RELOC_SPARC_DISP64 BFD_RELOC_64_PCREL
  BFD_RELOC_SPARC_PLT64,
  BFD_RELOC_SPARC_HIX22,
  BFD_RELOC_SPARC_LOX10,
  BFD_RELOC_SPARC_H44,
  BFD_RELOC_SPARC_M44,
  BFD_RELOC_SPARC_L44,
  BFD_RELOC_SPARC_REGISTER,

/* SPARC little endian relocation */
  BFD_RELOC_SPARC_REV32,
a1652 11
/* The BFD_RELOC_ALPHA_USER_* relocations are used by the assembler to
process the explicit !<reloc>!sequence relocations, and are mapped
into the normal relocations at the end of processing. */
  BFD_RELOC_ALPHA_USER_LITERAL,
  BFD_RELOC_ALPHA_USER_LITUSE_BASE,
  BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF,
  BFD_RELOC_ALPHA_USER_LITUSE_JSR,
  BFD_RELOC_ALPHA_USER_GPDISP,
  BFD_RELOC_ALPHA_USER_GPRELHIGH,
  BFD_RELOC_ALPHA_USER_GPRELLOW,

a1707 5
  BFD_RELOC_MIPS_SUB,
  BFD_RELOC_MIPS_GOT_PAGE,
  BFD_RELOC_MIPS_GOT_OFST,
  BFD_RELOC_MIPS_GOT_DISP,

a1732 8
/* Picojava relocs.  Not all of these appear in object files. */
  BFD_RELOC_PJ_CODE_HI16,
  BFD_RELOC_PJ_CODE_LO16,
  BFD_RELOC_PJ_CODE_DIR16,
  BFD_RELOC_PJ_CODE_DIR32,
  BFD_RELOC_PJ_CODE_REL16,
  BFD_RELOC_PJ_CODE_REL32,

a1764 3
/* IBM 370/390 relocations */
  BFD_RELOC_I370_D12,

a1776 1
  BFD_RELOC_ARM_ADRL_IMMEDIATE,
a1791 9
  BFD_RELOC_ARM_GOT12,
  BFD_RELOC_ARM_GOT32,
  BFD_RELOC_ARM_JUMP_SLOT,
  BFD_RELOC_ARM_COPY,
  BFD_RELOC_ARM_GLOB_DAT,
  BFD_RELOC_ARM_PLT32,
  BFD_RELOC_ARM_RELATIVE,
  BFD_RELOC_ARM_GOTOFF,
  BFD_RELOC_ARM_GOTPC,
a1812 16
/* Thumb 23-, 12- and 9-bit pc-relative branches.  The lowest bit must
be zero and is not stored in the instruction. */
  BFD_RELOC_THUMB_PCREL_BRANCH9,
  BFD_RELOC_THUMB_PCREL_BRANCH12,
  BFD_RELOC_THUMB_PCREL_BRANCH23,

/* Argonaut RISC Core (ARC) relocs.
ARC 22 bit pc-relative branch.  The lowest two bits must be zero and are
not stored in the instruction.  The high 20 bits are installed in bits 26
through 7 of the instruction. */
  BFD_RELOC_ARC_B22_PCREL,

/* ARC 26 bit absolute branch.  The lowest two bits must be zero and are not
stored in the instruction.  The high 24 bits are installed in bits 23
through 0. */
  BFD_RELOC_ARC_B26,
a1833 41
/* Mitsubishi D30V relocs.
This is a 6-bit absolute reloc. */
  BFD_RELOC_D30V_6,

/* This is a 6-bit pc-relative reloc with
the right 3 bits assumed to be 0. */
  BFD_RELOC_D30V_9_PCREL,

/* This is a 6-bit pc-relative reloc with
the right 3 bits assumed to be 0. Same
as the previous reloc but on the right side
of the container. */
  BFD_RELOC_D30V_9_PCREL_R,

/* This is a 12-bit absolute reloc with the
right 3 bitsassumed to be 0. */
  BFD_RELOC_D30V_15,

/* This is a 12-bit pc-relative reloc with
the right 3 bits assumed to be 0. */
  BFD_RELOC_D30V_15_PCREL,

/* This is a 12-bit pc-relative reloc with
the right 3 bits assumed to be 0. Same
as the previous reloc but on the right side
of the container. */
  BFD_RELOC_D30V_15_PCREL_R,

/* This is an 18-bit absolute reloc with
the right 3 bits assumed to be 0. */
  BFD_RELOC_D30V_21,

/* This is an 18-bit pc-relative reloc with
the right 3 bits assumed to be 0. */
  BFD_RELOC_D30V_21_PCREL,

/* This is an 18-bit pc-relative reloc with
the right 3 bits assumed to be 0. Same
as the previous reloc but on the right side
of the container. */
  BFD_RELOC_D30V_21_PCREL_R,
a1834 5
/* This is a 32-bit absolute reloc. */
  BFD_RELOC_D30V_32,

/* This is a 32-bit pc-relative reloc. */
  BFD_RELOC_D30V_32_PCREL,
a1863 55
/* This is a 9-bit reloc */
  BFD_RELOC_V850_9_PCREL,

/* This is a 22-bit reloc */
  BFD_RELOC_V850_22_PCREL,

/* This is a 16 bit offset from the short data area pointer. */
  BFD_RELOC_V850_SDA_16_16_OFFSET,

/* This is a 16 bit offset (of which only 15 bits are used) from the
short data area pointer. */
  BFD_RELOC_V850_SDA_15_16_OFFSET,

/* This is a 16 bit offset from the zero data area pointer. */
  BFD_RELOC_V850_ZDA_16_16_OFFSET,

/* This is a 16 bit offset (of which only 15 bits are used) from the
zero data area pointer. */
  BFD_RELOC_V850_ZDA_15_16_OFFSET,

/* This is an 8 bit offset (of which only 6 bits are used) from the
tiny data area pointer. */
  BFD_RELOC_V850_TDA_6_8_OFFSET,

/* This is an 8bit offset (of which only 7 bits are used) from the tiny
data area pointer. */
  BFD_RELOC_V850_TDA_7_8_OFFSET,

/* This is a 7 bit offset from the tiny data area pointer. */
  BFD_RELOC_V850_TDA_7_7_OFFSET,

/* This is a 16 bit offset from the tiny data area pointer. */
  BFD_RELOC_V850_TDA_16_16_OFFSET,

/* This is a 5 bit offset (of which only 4 bits are used) from the tiny
data area pointer. */
  BFD_RELOC_V850_TDA_4_5_OFFSET,

/* This is a 4 bit offset from the tiny data area pointer. */
  BFD_RELOC_V850_TDA_4_4_OFFSET,

/* This is a 16 bit offset from the short data area pointer, with the
bits placed non-contigously in the instruction. */
  BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET,

/* This is a 16 bit offset from the zero data area pointer, with the
bits placed non-contigously in the instruction. */
  BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET,

/* This is a 6 bit offset from the call table base pointer. */
  BFD_RELOC_V850_CALLT_6_7_OFFSET,

/* This is a 16 bit offset from the call table base pointer. */
  BFD_RELOC_V850_CALLT_16_16_OFFSET,

a1871 132

/* This is a 8bit DP reloc for the tms320c30, where the most
significant 8 bits of a 24 bit word are placed into the least
significant 8 bits of the opcode. */
  BFD_RELOC_TIC30_LDP,

/* This is a 48 bit reloc for the FR30 that stores 32 bits. */
  BFD_RELOC_FR30_48,

/* This is a 32 bit reloc for the FR30 that stores 20 bits split up into
two sections. */
  BFD_RELOC_FR30_20,

/* This is a 16 bit reloc for the FR30 that stores a 6 bit word offset in
4 bits. */
  BFD_RELOC_FR30_6_IN_4,

/* This is a 16 bit reloc for the FR30 that stores an 8 bit byte offset
into 8 bits. */
  BFD_RELOC_FR30_8_IN_8,

/* This is a 16 bit reloc for the FR30 that stores a 9 bit short offset
into 8 bits. */
  BFD_RELOC_FR30_9_IN_8,

/* This is a 16 bit reloc for the FR30 that stores a 10 bit word offset
into 8 bits. */
  BFD_RELOC_FR30_10_IN_8,

/* This is a 16 bit reloc for the FR30 that stores a 9 bit pc relative
short offset into 8 bits. */
  BFD_RELOC_FR30_9_PCREL,

/* This is a 16 bit reloc for the FR30 that stores a 12 bit pc relative
short offset into 11 bits. */
  BFD_RELOC_FR30_12_PCREL,

/* Motorola Mcore relocations. */
  BFD_RELOC_MCORE_PCREL_IMM8BY4,
  BFD_RELOC_MCORE_PCREL_IMM11BY2,
  BFD_RELOC_MCORE_PCREL_IMM4BY2,
  BFD_RELOC_MCORE_PCREL_32,
  BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2,
  BFD_RELOC_MCORE_RVA,

/* This is a 16 bit reloc for the AVR that stores 8 bit pc relative
short offset into 7 bits. */
  BFD_RELOC_AVR_7_PCREL,

/* This is a 16 bit reloc for the AVR that stores 13 bit pc relative
short offset into 12 bits. */
  BFD_RELOC_AVR_13_PCREL,

/* This is a 16 bit reloc for the AVR that stores 17 bit value (usually
program memory address) into 16 bits. */
  BFD_RELOC_AVR_16_PM,

/* This is a 16 bit reloc for the AVR that stores 8 bit value (usually
data memory address) into 8 bit immediate value of LDI insn. */
  BFD_RELOC_AVR_LO8_LDI,

/* This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
of data memory address) into 8 bit immediate value of LDI insn. */
  BFD_RELOC_AVR_HI8_LDI,

/* This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
of program memory address) into 8 bit immediate value of LDI insn. */
  BFD_RELOC_AVR_HH8_LDI,

/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
(usually data memory address) into 8 bit immediate value of SUBI insn. */
  BFD_RELOC_AVR_LO8_LDI_NEG,

/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
(high 8 bit of data memory address) into 8 bit immediate value of
SUBI insn. */
  BFD_RELOC_AVR_HI8_LDI_NEG,

/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
(most high 8 bit of program memory address) into 8 bit immediate value
of LDI or SUBI insn. */
  BFD_RELOC_AVR_HH8_LDI_NEG,

/* This is a 16 bit reloc for the AVR that stores 8 bit value (usually
command address) into 8 bit immediate value of LDI insn. */
  BFD_RELOC_AVR_LO8_LDI_PM,

/* This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
of command address) into 8 bit immediate value of LDI insn. */
  BFD_RELOC_AVR_HI8_LDI_PM,

/* This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
of command address) into 8 bit immediate value of LDI insn. */
  BFD_RELOC_AVR_HH8_LDI_PM,

/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
(usually command address) into 8 bit immediate value of SUBI insn. */
  BFD_RELOC_AVR_LO8_LDI_PM_NEG,

/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
(high 8 bit of 16 bit command address) into 8 bit immediate value
of SUBI insn. */
  BFD_RELOC_AVR_HI8_LDI_PM_NEG,

/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
(high 6 bit of 22 bit command address) into 8 bit immediate
value of SUBI insn. */
  BFD_RELOC_AVR_HH8_LDI_PM_NEG,

/* This is a 32 bit reloc for the AVR that stores 23 bit value
into 22 bits. */
  BFD_RELOC_AVR_CALL,

/* These two relocations are used by the linker to determine which of
the entries in a C++ virtual function table are actually used.  When
the --gc-sections option is given, the linker will zero out the entries
that are not used, so that the code for those functions need not be
included in the output.

VTABLE_INHERIT is a zero-space relocation used to describe to the
linker the inheritence tree of a C++ virtual function table.  The
relocation's symbol should be the parent class' vtable, and the
relocation should be located at the child vtable.

VTABLE_ENTRY is a zero-space relocation that describes the use of a
virtual function table entry.  The reloc's symbol should refer to the
table of the class mentioned in the code.  Off of that base, an offset
describes the entry that is being used.  For Rela hosts, this offset
is stored in the reloc's addend.  For Rel hosts, we are forced to put
this offset in the reloc's section offset. */
  BFD_RELOC_VTABLE_INHERIT,
  BFD_RELOC_VTABLE_ENTRY,
d1884 9
a1892 9
        /* A pointer to the BFD which owns the symbol. This information
          is necessary so that a back end can work out what additional
          information (invisible to the application writer) is carried
          with the symbol.

          This field is *almost* redundant, since you can use section->owner
          instead, except that some symbols point to the global sections
          bfd_{abs,com,und}_section.  This could be fixed by making
          these globals be per-bfd (or per-target-flavor).  FIXME. */
d1896 2
a1897 2
        /* The text of the symbol. The name is left alone, and not copied; the
          application may not alter it. */
d1900 1
a1900 1
        /* The value of the symbol.  This really should be a union of a
d1905 1
a1905 1
        /* Attributes of a symbol: */
d1909 19
a1927 19
        /* The symbol has local scope; <<static>> in <<C>>. The value
          is the offset into the section of the data. */
#define BSF_LOCAL      0x01

        /* The symbol has global scope; initialized data in <<C>>. The
          value is the offset into the section of the data. */
#define BSF_GLOBAL     0x02

        /* The symbol has global scope and is exported. The value is
          the offset into the section of the data. */
#define BSF_EXPORT     BSF_GLOBAL  /* no real difference */

        /* A normal C symbol would be one of:
          <<BSF_LOCAL>>, <<BSF_FORT_COMM>>,  <<BSF_UNDEFINED>> or
          <<BSF_GLOBAL>> */

        /* The symbol is a debugging record. The value has an arbitary
          meaning, unless BSF_DEBUGGING_RELOC is also set.  */
#define BSF_DEBUGGING  0x08
d1929 2
a1930 2
        /* The symbol denotes a function entry point.  Used in ELF,
          perhaps others someday.  */
d1933 1
a1933 1
        /* Used by the linker. */
d1937 2
a1938 2
        /* A weak global symbol, overridable without warnings by
          a regular global symbol of the same name.  */
d1942 1
a1942 1
          STT_SECTION symbols.  */
d1945 2
a1946 2
        /* The symbol used to be a common symbol, but now it is
          allocated. */
d1949 1
a1949 1
        /* The default value for common data. */
d1952 5
a1956 5
        /* In some files the type of a symbol sometimes alters its
          location in an output file - ie in coff a <<ISFCN>> symbol
          which is also <<C_EXT>> symbol appears where it was
          declared and not at the end of a section.  This bit is set
          by the target BFD part to convey this information. */
d1960 1
a1960 1
        /* Signal that the symbol is the label of constructor section. */
d1963 4
a1966 4
        /* Signal that the symbol is a warning symbol.  The name is a
          warning.  The name of the next symbol is the one to warn about;
          if a reference is made to a symbol with the same name as the next
          symbol, a warning is issued by the linker. */
d1969 2
a1970 2
        /* Signal that the symbol is indirect.  This symbol is an indirect
          pointer to the symbol with the same name as the next symbol. */
d1973 2
a1974 2
        /* BSF_FILE marks symbols that contain a file name.  This is used
          for ELF STT_FILE symbols.  */
d1977 2
a1978 2
        /* Symbol is from dynamic linking information.  */
#define BSF_DYNAMIC       0x8000
d1982 1
a1982 6
#define BSF_OBJECT        0x10000

        /* This symbol is a debugging symbol.  The value is the offset
          into the section of the data.  BSF_DEBUGGING should be set
          as well.  */
#define BSF_DEBUGGING_RELOC 0x20000
d1986 2
a1987 2
        /* A pointer to the section to which this symbol is
          relative.  This will always be non NULL, there are special
d1991 1
a1991 1
        /* Back end special data.  */
a2024 3
boolean 
bfd_is_undefined_symclass  PARAMS ((int symclass));

d2033 1
a2033 1
               (ibfd, isymbol, obfd, osymbol))
a2167 1
      struct sco5_core_struct *sco5_core_data;
a2232 3
bfd_error_handler_type 
bfd_get_error_handler  PARAMS ((void));

d2241 1
a2241 1
    asymbol **syms));
d2275 1
a2275 1
               (ibfd, obfd))
d2281 1
a2281 1
               (ibfd, obfd))
d2287 1
a2287 1
               (abfd, flags))
a2316 3
#define bfd_gc_sections(abfd, link_info) \
       BFD_SEND (abfd, _bfd_gc_sections, (abfd, link_info))

d2318 1
a2318 1
       BFD_SEND (abfd, _bfd_link_hash_table_create, (abfd))
d2321 1
a2321 1
       BFD_SEND (abfd, _bfd_link_add_symbols, (abfd, info))
d2324 1
a2324 1
       BFD_SEND (abfd, _bfd_final_link, (abfd, info))
d2330 1
a2330 1
       BFD_SEND (abfd, _bfd_get_dynamic_symtab_upper_bound, (abfd))
d2333 1
a2333 1
       BFD_SEND (abfd, _bfd_print_private_bfd_data, (abfd, file))
d2336 1
a2336 1
       BFD_SEND (abfd, _bfd_canonicalize_dynamic_symtab, (abfd, asymbols))
d2339 1
a2339 1
       BFD_SEND (abfd, _bfd_get_dynamic_reloc_upper_bound, (abfd))
d2342 1
a2342 1
       BFD_SEND (abfd, _bfd_canonicalize_dynamic_reloc, (abfd, arels, asyms))
d2345 3
a2347 3
       PARAMS ((bfd *, struct bfd_link_info *,
                 struct bfd_link_order *, bfd_byte *,
                 boolean, asymbol **));
a2403 1
  bfd_target_ovax_flavour,
d2476 1
a2476 1
  boolean       (*_bfd_copy_private_bfd_data) PARAMS ((bfd *, bfd *));
d2479 1
a2479 1
  boolean       (*_bfd_merge_private_bfd_data) PARAMS ((bfd *, bfd *));
d2487 1
a2487 1
                                                          bfd *, asymbol *));
d2489 1
a2489 1
  boolean       (*_bfd_set_private_flags) PARAMS ((bfd *, flagword));
d2558 1
a2558 1
  boolean       (*_bfd_is_local_label_name) PARAMS ((bfd *, const char *));
d2611 1
a2611 2
CAT(NAME,_bfd_link_split_section),\
CAT(NAME,_bfd_gc_sections)
d2635 1
a2635 4
   /* Remove sections that are not referenced from the output.  */
  boolean (*_bfd_gc_sections) PARAMS ((bfd *, struct bfd_link_info *));

   /* Routines to handle dynamic symbols and relocs.  */
a2651 3
  /* Opposite endian version of this target.  */  
 const struct bfd_target * alternative_target;
 
a2652 1
 
a2661 3

const bfd_target * 
bfd_search_for_target  PARAMS ((int (* search_func)(const bfd_target *, void *), void *));
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
d26 1
a26 1
/* bfd.h -- The only header file required by users of the bfd library
d87 1
a87 1
   force me to change it.  */
d96 1
a96 1
/* Pre-emptive strike - get the file with the enum.  */
d112 1
a112 1
   Probably the best long-term answer is to avoid using file_ptr AND off_t
d180 2
a181 2
#define fprintf_vma(s,x) fprintf (s, "%08lx", x)
#define sprintf_vma(s,x) sprintf (s, "%08lx", x)
d287 1
d291 1
a291 1
  char **name;			/* symbol name */
d296 1
d299 1
a299 1
  unsigned int line_number;	/* Linenumber from start of function*/
d330 1
a330 1
typedef struct stat stat_type;
d333 1
a333 1
{
d338 1
a338 1

d347 1
a347 1
  char stab_other;             /* Stab other.  */
d484 1
a491 3
#define bfd_family_coff(abfd) \
  (bfd_get_flavour (abfd) == bfd_target_coff_flavour || \
   bfd_get_flavour (abfd) == bfd_target_xcoff_flavour)
d514 1
a514 1
#define bfd_set_cacheable(abfd,bool) (((abfd)->cacheable = (boolean) (bool)), true)
a539 5

/* Byte swapping routines which take size and endiannes as arguments.  */

bfd_vma         bfd_get_bits       PARAMS ((bfd_byte *, int, boolean));
void            bfd_put_bits       PARAMS ((bfd_vma, bfd_byte *, int, boolean));
a626 1
extern void bfd_elf_set_dt_needed_soname PARAMS ((bfd *, const char *));
a627 2
extern struct bfd_link_needed_list *bfd_elf_get_runpath_list
  PARAMS ((bfd *, struct bfd_link_info *));
a642 10
/* Return the arch_size field of an elf bfd, or -1 if not elf.  */
extern int bfd_get_arch_size PARAMS ((bfd *));

/* Return true if address "naturally" sign extends, or -1 if not elf.  */
extern int bfd_get_sign_extend_vma PARAMS ((bfd *));

extern boolean bfd_m68k_elf32_create_embedded_relocs
  PARAMS ((bfd *, struct bfd_link_info *, struct sec *, struct sec *,
	   char **));

a720 4
extern boolean bfd_m68k_coff_create_embedded_relocs
  PARAMS ((bfd *, struct bfd_link_info *, struct sec *, struct sec *,
	   char **));

a750 7
/* TI COFF load page support.  */
extern void bfd_ticoff_set_section_load_page
  PARAMS ((struct sec *, int));

extern int bfd_ticoff_get_section_load_page
  PARAMS ((struct sec *));

d752 1
a752 1
void
d767 1
a767 1
boolean
d770 1
a770 1
boolean
d776 1
a776 1
boolean
d779 1
a779 1
boolean
d783 1
a783 1
/* Byte swapping macros for user section data.  */
d786 1
a786 1
                ((void) (*((unsigned char *) (ptr)) = (unsigned char) (val)))
d790 1
a790 1
                (*(unsigned char *) (ptr))
d792 1
a792 1
               ((*(unsigned char *) (ptr) ^ 0x80) - 0x80)
d836 1
a836 1
/* Byte swapping macros for file header data.  */
d874 4
a877 4
/* This structure is used for a comdat section, as in PE.  A comdat
   section is associated with a particular symbol.  When the linker
   sees a comdat section, it keeps only one of the sections with a
   given name and associated with a given symbol.  */
d881 1
a881 1
  /* The name of the symbol associated with a comdat section.  */
d884 1
a884 1
  /* The local symbol table index of the symbol associated with a
d889 4
d897 2
a898 2
  /* The name of the section; the name isn't a copy, the pointer is
     the same as that passed to bfd_make_section.  */
d900 1
a900 1
  const char *name;
d902 1
a902 1
  /* A unique sequence number.  */
d904 1
a904 1
  int id;
d906 1
a906 1
  /* Which section is it; 0..nth.  */
d908 1
a908 1
  int index;
d910 3
a912 1
  /* The next section in the list belonging to the BFD, or NULL.  */
d914 1
a914 7
  struct sec *next;

  /* The field flags contains attributes of the section. Some
     flags are read in from the object file, and some are
     synthesized from other information.  */

  flagword flags;
d918 3
a920 2
  /* Tells the OS to allocate space for this section when loading.
     This is clear for a section containing debug information only.  */
d923 2
a924 2
  /* Tells the OS to load the section from the file when loading.
     This is clear for a .bss section.  */
d927 2
a928 2
  /* The section contains data still to be relocated, so there is
     some relocation information too.  */
d931 1
a931 1
#if 0   /* Obsolete ? */
d935 2
a936 1
  /* A signal to the OS that the section contains read only data.  */
d939 1
a939 1
  /* The section contains code only.  */
d942 1
a942 1
  /* The section contains data only.  */
d945 1
a945 1
  /* The section will reside in ROM.  */
d948 10
a957 10
  /* The section contains constructor information. This section
     type is used by the linker to create lists of constructors and
     destructors used by <<g++>>. When a back end sees a symbol
     which should be used in a constructor list, it creates a new
     section for the type of name (e.g., <<__CTOR_LIST__>>), attaches
     the symbol to it, and builds a relocation. To build the lists
     of constructors, all the linker has to do is catenate all the
     sections called <<__CTOR_LIST__>> and relocate the data
     contained within - exactly the operations it would peform on
     standard data.  */
d960 2
a961 2
  /* The section is a constructor, and should be placed at the
     end of the text, data, or bss section(?).  */
d966 3
a968 3
  /* The section has contents - a data section could be
     <<SEC_ALLOC>> | <<SEC_HAS_CONTENTS>>; a debug section could be
     <<SEC_HAS_CONTENTS>>  */
d971 2
a972 2
  /* An instruction to the linker to not output the section
     even if it has information which would normally be written.  */
d975 9
a983 9
  /* The section is a COFF shared library section.  This flag is
     only for the linker.  If this type of section appears in
     the input file, the linker must copy it to the output file
     without changing the vma or size.  FIXME: Although this
     was originally intended to be general, it really is COFF
     specific (and the flag was renamed to indicate this).  It
     might be cleaner to have some more general mechanism to
     allow the back end to control what the linker does with
     sections.  */
d986 5
a990 13
  /* The section has GOT references.  This flag is only for the
     linker, and is currently only used by the elf32-hppa back end.
     It will be set if global offset table references were detected
     in this section, which indicate to the linker that the section
     contains PIC code, and must be handled specially when doing a
     static link.  */
#define SEC_HAS_GOT_REF 0x4000

  /* The section contains common symbols (symbols may be defined
     multiple times, the value of a symbol is the amount of
     space it requires, and the largest symbol value is the one
     used).  Most targets have exactly one of these (which we
     translate to bfd_com_section_ptr), but ECOFF has two.  */
d993 4
a996 4
  /* The section contains only debugging information.  For
     example, this is set for ELF .debug and .stab sections.
     strip tests this flag to see if a section can be
     discarded.  */
d999 4
a1002 3
  /* The contents of this section are held in memory pointed to
     by the contents field.  This is checked by bfd_get_section_contents,
     and the data is retrieved from memory if appropriate.  */
d1005 3
a1007 3
  /* The contents of this section are to be excluded by the
     linker for executable and shared objects unless those
     objects are to be further relocated.  */
d1010 3
a1012 3
  /* The contents of this section are to be sorted by the
     based on the address specified in the associated symbol
     table.  */
d1015 4
a1018 4
  /* When linking, duplicate sections of the same name should be
     discarded, rather than being combined into a single section as
     is usually done.  This is similar to how common symbols are
     handled.  See SEC_LINK_DUPLICATES below.  */
d1021 2
a1022 2
  /* If SEC_LINK_ONCE is set, this bitfield describes how the linker
     should handle duplicate sections.  */
d1025 2
a1026 2
  /* This value for SEC_LINK_DUPLICATES means that duplicate
     sections with the same name should simply be discarded.  */
d1029 3
a1031 3
  /* This value for SEC_LINK_DUPLICATES means that the linker
     should warn if there are any duplicate sections, although
     it should still only link one copy.  */
d1034 2
a1035 2
  /* This value for SEC_LINK_DUPLICATES means that the linker
     should warn if any duplicate sections are a different size.  */
d1038 3
a1040 3
  /* This value for SEC_LINK_DUPLICATES means that the linker
     should warn if any duplicate sections contain different
     contents.  */
d1043 4
a1046 4
  /* This section was created by the linker as part of dynamic
     relocation or other arcane processing.  It is skipped when
     going through the first-pass output, trusting that someone
     else up the line will take care of it later.  */
d1049 1
a1049 1
  /* This section should not be subject to garbage collection.  */
d1052 2
a1053 2
  /* This section contains "short" data, and should be placed
     "near" the GP.  */
d1056 2
a1057 2
  /* This section contains data which may be shared with other
     executables or shared objects.  */
d1060 1
a1060 5
  /* When a section with this flag is being linked, then if the size of
     the input section is less than a page, it should not cross a page
     boundary.  If the size of the input section is one page or more, it
     should be aligned on a page boundary.  */
#define SEC_BLOCK 0x8000000
d1062 1
a1062 3
  /* Conditionally link this section; do not link if there are no
     references found to any symbol in the section.  */
#define SEC_CLINK 0x10000000
d1064 2
a1065 1
  /*  End of section flags.  */
d1067 2
a1068 1
  /* Some internal packed boolean fields.  */
d1070 2
a1071 2
  /* See the vma field.  */
  unsigned int user_set_vma : 1;
d1073 2
a1074 2
  /* Whether relocations have been processed.  */
  unsigned int reloc_done : 1;
d1076 1
a1076 2
  /* A mark flag used by some of the linker backends.  */
  unsigned int linker_mark : 1;
d1078 6
a1083 3
  /* Another mark flag used by some of the linker backends.  Set for
     output sections that have a input section.  */
  unsigned int linker_has_input : 1;
d1085 1
a1085 2
  /* A mark flag used by some linker backends for garbage collection.  */
  unsigned int gc_mark : 1;
d1087 3
a1089 2
  /* Used by the ELF code to mark sections which have been allocated to segments.  */
  unsigned int segment_mark : 1;
d1091 1
a1091 1
  /* End of internal packed boolean fields.  */
d1093 3
a1095 6
  /*  The virtual memory address of the section - where it will be
      at run time.  The symbols are relocated against this.  The
      user_set_vma flag is maintained by bfd; if it's not set, the
      backend can assign addresses (for example, in <<a.out>>, where
      the default address for <<.data>> is dependent on the specific
      target and various flags).  */
d1097 1
a1097 1
  bfd_vma vma;
d1099 3
a1101 3
  /*  The load address of the section - where it would be in a
      rom image; really only used for writing section header
      information. */
d1103 1
a1103 1
  bfd_vma lma;
d1105 7
a1111 3
  /* The size of the section in octets, as it will be output.
     Contains a value even if the section has no contents (e.g., the
     size of <<.bss>>).  This will be filled in after relocation.  */
d1113 1
a1113 1
  bfd_size_type _cooked_size;
d1115 1
a1115 3
  /* The original size on disk of the section, in octets.  Normally this
     value is the same as the size, but if some relaxing has
     been done, then this value will be bigger.  */
d1117 1
a1117 1
  bfd_size_type _raw_size;
d1119 2
a1120 7
  /* If this section is going to be output, then this value is the
     offset in *bytes* into the output section of the first byte in the
     input section (byte ==> smallest addressable unit on the
     target).  In most cases, if this was going to start at the
     100th octet (8-bit quantity) in the output section, this value
     would be 100.  However, if the target byte size is 16 bits
     (bfd_octets_per_byte is "2"), this value would be 50.  */
d1122 1
a1122 1
  bfd_vma output_offset;
d1124 2
a1125 1
  /* The output section through which to map on output.  */
d1127 1
a1127 1
  struct sec *output_section;
d1129 2
a1130 2
  /* The alignment requirement of the section, as an exponent of 2 -
     e.g., 3 aligns to 2^3 (or 8).  */
d1132 1
a1132 1
  unsigned int alignment_power;
d1134 1
a1134 2
  /* If an input section, a pointer to a vector of relocation
     records for the data in this section.  */
d1136 1
a1136 1
  struct reloc_cache_entry *relocation;
d1138 2
a1139 2
  /* If an output section, a pointer to a vector of pointers to
     relocation records for the data in this section.  */
d1141 1
a1141 1
  struct reloc_cache_entry **orelocation;
d1143 1
a1143 1
  /* The number of relocation records in one of the above  */
d1145 1
a1145 1
  unsigned reloc_count;
d1147 1
a1147 2
  /* Information below is back end specific - and not always used
     or updated.  */
d1149 1
a1149 1
  /* File position of section data.  */
d1151 1
a1151 1
  file_ptr filepos;
d1153 1
a1153 1
  /* File position of relocation info.  */
d1155 1
a1155 1
  file_ptr rel_filepos;
d1157 3
a1159 1
  /* File position of line data.  */
d1161 1
a1161 1
  file_ptr line_filepos;
d1163 1
a1163 1
  /* Pointer to data for applications.  */
d1165 1
a1165 1
  PTR userdata;
d1167 1
a1167 3
  /* If the SEC_IN_MEMORY flag is set, this points to the actual
     contents.  */
  unsigned char *contents;
d1169 1
a1169 1
  /* Attached line number information.  */
d1171 1
a1171 1
  alent *lineno;
d1173 2
a1174 1
  /* Number of line number records.  */
d1176 1
a1176 1
  unsigned int lineno_count;
d1178 1
a1178 1
  /* Optional information about a COMDAT entry; NULL if not COMDAT.  */
d1180 1
a1180 1
  struct bfd_comdat_info *comdat;
d1182 1
a1182 3
  /* Points to the kept section if this section is a link-once section,
     and is discarded.  */
  struct sec *kept_section;
d1184 2
a1185 2
  /* When a section is being output, this value changes as more
     linenumbers are written out.  */
d1187 1
a1187 1
  file_ptr moving_line_filepos;
d1189 1
a1189 1
  /* What the section number is in the target world.  */
d1191 1
a1191 1
  int target_index;
d1193 3
a1195 1
  PTR used_by_bfd;
d1197 2
a1198 15
  /* If this is a constructor section then here is a list of the
     relocations created to relocate items within it.  */

  struct relent_chain *constructor_chain;

  /* The BFD which owns the section.  */

  bfd *owner;

  /* A symbol which points at this section only */
  struct symbol_cache_entry *symbol;
  struct symbol_cache_entry **symbol_ptr_ptr;

  struct bfd_link_order *link_order_head;
  struct bfd_link_order *link_order_tail;
d1201 5
a1205 5
/* These sections are global, and are managed by BFD.  The application
   and target back end are not permitted to change the values in
   these sections.  New code should use the section_ptr macros rather
   than referring directly to the const sections.  The const sections
   may eventually vanish.  */
d1211 1
a1211 1
/* the absolute section */
d1215 1
a1215 1
/* Pointer to the undefined section */
d1219 1
a1219 1
/* Pointer to the common section */
d1222 1
a1222 1
/* Pointer to the indirect section */
d1238 1
a1238 6
bfd_get_section_by_name PARAMS ((bfd *abfd, const char *name));

char *
bfd_get_unique_section_name PARAMS ((bfd *abfd,
    const char *templat,
    int *count));
d1241 1
a1241 1
bfd_make_section_old_way PARAMS ((bfd *abfd, const char *name));
d1244 1
a1244 1
bfd_make_section_anyway PARAMS ((bfd *abfd, const char *name));
d1247 1
a1247 1
bfd_make_section PARAMS ((bfd *, const char *name));
d1249 1
a1249 1
boolean
d1252 1
a1252 1
void
d1254 1
a1254 1
    void (*func) (bfd *abfd,
d1259 1
a1259 1
boolean
d1262 3
a1264 2
boolean
bfd_set_section_contents PARAMS ((bfd *abfd,
d1270 3
a1272 2
boolean
bfd_get_section_contents PARAMS ((bfd *abfd, asection *section, PTR location,
d1275 1
a1275 1
boolean
d1281 3
a1283 2
void
_bfd_strip_section_from_output PARAMS ((struct bfd_link_info *info, asection *section));
d1285 1
a1285 1
enum bfd_architecture
d1287 3
a1289 3
  bfd_arch_unknown,   /* File arch not known */
  bfd_arch_obscure,   /* Arch known, not one of these */
  bfd_arch_m68k,      /* Motorola 68xxx */
d1298 4
a1301 8
#define bfd_mach_mcf5200  9
#define bfd_mach_mcf5206e 10
#define bfd_mach_mcf5307  11
#define bfd_mach_mcf5407  12
  bfd_arch_vax,       /* DEC Vax */
  bfd_arch_i960,      /* Intel 960 */
    /* The order of the following is important.
       lower number indicates a machine type that
d1305 1
a1305 1
       incompatible with all other machines except
d1317 2
a1318 2
  bfd_arch_a29k,      /* AMD 29000 */
  bfd_arch_sparc,     /* SPARC */
d1320 1
a1320 1
/* The difference between v8plus and v9 is that v9 is a true 64 bit env.  */
d1324 1
a1324 1
#define bfd_mach_sparc_v8plusa         5 /* with ultrasparc add'ns */
d1327 2
a1328 4
#define bfd_mach_sparc_v9a             8 /* with ultrasparc add'ns */
#define bfd_mach_sparc_v8plusb         9 /* with cheetah add'ns */
#define bfd_mach_sparc_v9b             10 /* with cheetah add'ns */
/* Nonzero if MACH has the v9 instruction set.  */
d1330 2
a1331 3
  ((mach) >= bfd_mach_sparc_v8plus && (mach) <= bfd_mach_sparc_v9b \
   && (mach) != bfd_mach_sparc_sparclite_le)
  bfd_arch_mips,      /* MIPS Rxxxx */
a1345 1
#define bfd_mach_mips12000             12000
d1347 1
a1347 6
#define bfd_mach_mips32                32
#define bfd_mach_mips32_4k             3204113 /* 32, 04, octal 'K' */
#define bfd_mach_mips5                 5
#define bfd_mach_mips64                64
#define bfd_mach_mips_sb1              12310201 /* octal 'SB', 01 */
  bfd_arch_i386,      /* Intel 386 */
d1351 10
a1360 12
#define bfd_mach_x86_64 3
#define bfd_mach_x86_64_intel_syntax 4
  bfd_arch_we32k,     /* AT&T WE32xxx */
  bfd_arch_tahoe,     /* CCI/Harris Tahoe */
  bfd_arch_i860,      /* Intel 860 */
  bfd_arch_i370,      /* IBM 360/370 Mainframes */
  bfd_arch_romp,      /* IBM ROMP PC/RT */
  bfd_arch_alliant,   /* Alliant */
  bfd_arch_convex,    /* Convex */
  bfd_arch_m88k,      /* Motorola 88xxx */
  bfd_arch_pyramid,   /* Pyramid Technology */
  bfd_arch_h8300,     /* Hitachi H8/300 */
d1364 4
a1367 25
  bfd_arch_powerpc,   /* PowerPC */
#define bfd_mach_ppc           0
#define bfd_mach_ppc_403       403
#define bfd_mach_ppc_403gc     4030
#define bfd_mach_ppc_505       505
#define bfd_mach_ppc_601       601
#define bfd_mach_ppc_602       602
#define bfd_mach_ppc_603       603
#define bfd_mach_ppc_ec603e    6031
#define bfd_mach_ppc_604       604
#define bfd_mach_ppc_620       620
#define bfd_mach_ppc_630       630
#define bfd_mach_ppc_750       750
#define bfd_mach_ppc_860       860
#define bfd_mach_ppc_a35       35
#define bfd_mach_ppc_rs64ii    642
#define bfd_mach_ppc_rs64iii   643
#define bfd_mach_ppc_7400      7400
  bfd_arch_rs6000,    /* IBM RS/6000 */
#define bfd_mach_rs6k          0
#define bfd_mach_rs6k_rs1      6001
#define bfd_mach_rs6k_rsc      6003
#define bfd_mach_rs6k_rs2      6002
  bfd_arch_hppa,      /* HP PA RISC */
  bfd_arch_d10v,      /* Mitsubishi D10V */
d1371 2
a1372 4
  bfd_arch_d30v,      /* Mitsubishi D30V */
  bfd_arch_m68hc11,   /* Motorola 68HC11 */
  bfd_arch_m68hc12,   /* Motorola 68HC12 */
  bfd_arch_z8k,       /* Zilog Z8000 */
d1375 2
a1376 2
  bfd_arch_h8500,     /* Hitachi H8/500 */
  bfd_arch_sh,        /* Hitachi SH */
d1384 1
a1384 1
  bfd_arch_alpha,     /* Dec Alpha */
d1388 1
a1388 1
  bfd_arch_arm,       /* Advanced Risc Machines ARM */
d1397 5
a1401 8
#define bfd_mach_arm_5TE       9
#define bfd_mach_arm_XScale    10
  bfd_arch_ns32k,     /* National Semiconductors ns32000 */
  bfd_arch_w65,       /* WDC 65816 */
  bfd_arch_tic30,     /* Texas Instruments TMS320C30 */
  bfd_arch_tic54x,    /* Texas Instruments TMS320C54X */
  bfd_arch_tic80,     /* TI TMS320c80 (MVP) */
  bfd_arch_v850,      /* NEC V850 */
d1405 4
a1408 7
  bfd_arch_arc,       /* ARC Cores */
#define bfd_mach_arc_5         0
#define bfd_mach_arc_6         1
#define bfd_mach_arc_7         2
#define bfd_mach_arc_8         3
  bfd_arch_m32r,      /* Mitsubishi M32R/D */
#define bfd_mach_m32r          0 /* backwards compatibility */
d1410 2
a1411 2
  bfd_arch_mn10200,   /* Matsushita MN10200 */
  bfd_arch_mn10300,   /* Matsushita MN10300 */
a1416 3
  bfd_arch_ia64,      /* HP/Intel ia64 */
#define bfd_mach_ia64_elf64    0
#define bfd_mach_ia64_elf32    1
d1418 1
a1418 1
  bfd_arch_avr,       /* Atmel AVR microcontrollers */
a1422 2
#define bfd_mach_avr5          5
  bfd_arch_cris,      /* Axis CRIS */
d1426 1
a1426 1
typedef struct bfd_arch_info
d1436 2
a1437 2
  /* True if this is the default machine for the architecture.  */
  boolean the_default;
d1460 1
a1460 1
void
d1463 1
a1463 1
enum bfd_architecture
d1466 1
a1466 1
unsigned long
d1469 1
a1469 1
unsigned int
d1472 1
a1472 1
unsigned int
d1475 1
a1475 1
const bfd_arch_info_type *
d1479 2
a1480 1
bfd_lookup_arch PARAMS ((enum bfd_architecture
d1485 2
a1486 1
bfd_printable_arch_mach PARAMS ((enum bfd_architecture arch, unsigned long machine));
d1488 1
a1488 1
unsigned int
d1491 1
a1491 1
unsigned int
d1497 1
a1497 1
       /* No errors detected */
d1500 1
a1500 1
       /* The relocation was performed, but there was an overflow. */
d1503 1
a1503 1
       /* The address to relocate was not within the section supplied. */
d1506 1
a1506 1
       /* Used by special functions */
d1509 1
a1509 1
       /* Unsupported relocation size requested. */
d1512 1
a1512 1
       /* Unused */
d1515 1
a1515 1
       /* The symbol to relocate against was undefined. */
d1518 1
a1518 1
       /* The relocation was performed, but may not be ok - presently
d1529 1
a1529 1
       /* A pointer into the canonical table of pointers  */
d1532 1
a1532 1
       /* offset in section */
d1535 1
a1535 1
       /* addend for relocation value */
d1538 1
a1538 1
       /* Pointer to how to perform the required relocation */
d1544 1
a1544 1
       /* Do not complain on overflow. */
d1547 1
a1547 1
       /* Complain if the bitfield overflows, whether it is considered
d1551 1
a1551 1
       /* Complain if the value overflows when considered as signed
d1555 1
a1555 1
       /* Complain if the value overflows when considered as an
d1562 1
a1562 1
       /*  The type field has mainly a documentary use - the back end can
d1570 1
a1570 1
       /*  The value the final relocation is shifted right by. This drops
d1574 1
a1574 1
       /*  The size of the item to be relocated.  This is *not* a
d1579 1
a1579 1
       /*  The number of bits in the item to be relocated.  This is used
d1583 1
a1583 1
       /*  Notes that the relocation is relative to the location in the
d1589 1
a1589 1
       /*  The bit position of the reloc value in the destination.
d1593 1
a1593 1
       /* What type of overflow error should be checked for when
d1597 1
a1597 1
       /* If this field is non null, then the supplied function is
d1610 1
a1610 1
       /* The textual name of the relocation type. */
d1613 1
a1613 1
       /* Some formats record a relocation addend in the section contents
d1630 1
a1630 1
       /* The src_mask selects which parts of the read in data
d1639 1
a1639 1
       /* The dst_mask selects which parts of the instruction are replaced
d1645 1
a1645 1
       /* When some formats create PC relative instructions, they leave
d1672 2
a1673 2
unsigned int
bfd_get_reloc_size PARAMS ((reloc_howto_type *));
d1680 3
a1682 1
bfd_check_overflow PARAMS ((enum complain_overflow how,
d1689 3
a1691 1
bfd_perform_relocation PARAMS ((bfd *abfd,
d1699 3
a1701 1
bfd_install_relocation PARAMS ((bfd *abfd,
a1810 1
  BFD_RELOC_SPARC_UA16,
a1811 1
  BFD_RELOC_SPARC_UA64,
a1962 11
  BFD_RELOC_MIPS_SHIFT5,
  BFD_RELOC_MIPS_SHIFT6,
  BFD_RELOC_MIPS_INSERT_A,
  BFD_RELOC_MIPS_INSERT_B,
  BFD_RELOC_MIPS_DELETE,
  BFD_RELOC_MIPS_HIGHEST,
  BFD_RELOC_MIPS_HIGHER,
  BFD_RELOC_MIPS_SCN_DISP,
  BFD_RELOC_MIPS_REL16,
  BFD_RELOC_MIPS_RELGOT,
  BFD_RELOC_MIPS_JALR,
a1974 10
/* x86-64/elf relocations */
  BFD_RELOC_X86_64_GOT32,
  BFD_RELOC_X86_64_PLT32,
  BFD_RELOC_X86_64_COPY,
  BFD_RELOC_X86_64_GLOB_DAT,
  BFD_RELOC_X86_64_JUMP_SLOT,
  BFD_RELOC_X86_64_RELATIVE,
  BFD_RELOC_X86_64_GOTPCREL,
  BFD_RELOC_X86_64_32S,

a2040 10
/* ARM 26 bit pc-relative branch.  The lowest bit must be zero and is
not stored in the instruction.  The 2nd lowest bit comes from a 1 bit
field in the instruction. */
  BFD_RELOC_ARM_PCREL_BLX,

/* Thumb 22 bit pc-relative branch.  The lowest bit must be zero and is
not stored in the instruction.  The 2nd lowest bit comes from a 1 bit
field in the instruction. */
  BFD_RELOC_THUMB_PCREL_BLX,

a2088 7
  BFD_RELOC_SH_LOOP_START,
  BFD_RELOC_SH_LOOP_END,
  BFD_RELOC_SH_COPY,
  BFD_RELOC_SH_GLOB_DAT,
  BFD_RELOC_SH_JMP_SLOT,
  BFD_RELOC_SH_RELATIVE,
  BFD_RELOC_SH_GOTPC,
d2096 1
a2096 1
/* ARC Cores relocs.
a2271 23
/* This is a 7bit reloc for the tms320c54x, where the least
significant 7 bits of a 16 bit word are placed into the least
significant 7 bits of the opcode. */
  BFD_RELOC_TIC54X_PARTLS7,

/* This is a 9bit DP reloc for the tms320c54x, where the most
significant 9 bits of a 16 bit word are placed into the least
significant 9 bits of the opcode. */
  BFD_RELOC_TIC54X_PARTMS9,

/* This is an extended address 23-bit reloc for the tms320c54x. */
  BFD_RELOC_TIC54X_23,

/* This is a 16-bit reloc for the tms320c54x, where the least
significant 16 bits of a 23-bit extended address are placed into
the opcode. */
  BFD_RELOC_TIC54X_16_OF_23,

/* This is a reloc for the tms320c54x, where the most
significant 7 bits of a 23-bit extended address are placed into
the opcode. */
  BFD_RELOC_TIC54X_MS7_OF_23,

a2397 120

/* Intel IA64 Relocations. */
  BFD_RELOC_IA64_IMM14,
  BFD_RELOC_IA64_IMM22,
  BFD_RELOC_IA64_IMM64,
  BFD_RELOC_IA64_DIR32MSB,
  BFD_RELOC_IA64_DIR32LSB,
  BFD_RELOC_IA64_DIR64MSB,
  BFD_RELOC_IA64_DIR64LSB,
  BFD_RELOC_IA64_GPREL22,
  BFD_RELOC_IA64_GPREL64I,
  BFD_RELOC_IA64_GPREL32MSB,
  BFD_RELOC_IA64_GPREL32LSB,
  BFD_RELOC_IA64_GPREL64MSB,
  BFD_RELOC_IA64_GPREL64LSB,
  BFD_RELOC_IA64_LTOFF22,
  BFD_RELOC_IA64_LTOFF64I,
  BFD_RELOC_IA64_PLTOFF22,
  BFD_RELOC_IA64_PLTOFF64I,
  BFD_RELOC_IA64_PLTOFF64MSB,
  BFD_RELOC_IA64_PLTOFF64LSB,
  BFD_RELOC_IA64_FPTR64I,
  BFD_RELOC_IA64_FPTR32MSB,
  BFD_RELOC_IA64_FPTR32LSB,
  BFD_RELOC_IA64_FPTR64MSB,
  BFD_RELOC_IA64_FPTR64LSB,
  BFD_RELOC_IA64_PCREL21B,
  BFD_RELOC_IA64_PCREL21BI,
  BFD_RELOC_IA64_PCREL21M,
  BFD_RELOC_IA64_PCREL21F,
  BFD_RELOC_IA64_PCREL22,
  BFD_RELOC_IA64_PCREL60B,
  BFD_RELOC_IA64_PCREL64I,
  BFD_RELOC_IA64_PCREL32MSB,
  BFD_RELOC_IA64_PCREL32LSB,
  BFD_RELOC_IA64_PCREL64MSB,
  BFD_RELOC_IA64_PCREL64LSB,
  BFD_RELOC_IA64_LTOFF_FPTR22,
  BFD_RELOC_IA64_LTOFF_FPTR64I,
  BFD_RELOC_IA64_LTOFF_FPTR64MSB,
  BFD_RELOC_IA64_LTOFF_FPTR64LSB,
  BFD_RELOC_IA64_SEGREL32MSB,
  BFD_RELOC_IA64_SEGREL32LSB,
  BFD_RELOC_IA64_SEGREL64MSB,
  BFD_RELOC_IA64_SEGREL64LSB,
  BFD_RELOC_IA64_SECREL32MSB,
  BFD_RELOC_IA64_SECREL32LSB,
  BFD_RELOC_IA64_SECREL64MSB,
  BFD_RELOC_IA64_SECREL64LSB,
  BFD_RELOC_IA64_REL32MSB,
  BFD_RELOC_IA64_REL32LSB,
  BFD_RELOC_IA64_REL64MSB,
  BFD_RELOC_IA64_REL64LSB,
  BFD_RELOC_IA64_LTV32MSB,
  BFD_RELOC_IA64_LTV32LSB,
  BFD_RELOC_IA64_LTV64MSB,
  BFD_RELOC_IA64_LTV64LSB,
  BFD_RELOC_IA64_IPLTMSB,
  BFD_RELOC_IA64_IPLTLSB,
  BFD_RELOC_IA64_COPY,
  BFD_RELOC_IA64_TPREL22,
  BFD_RELOC_IA64_TPREL64MSB,
  BFD_RELOC_IA64_TPREL64LSB,
  BFD_RELOC_IA64_LTOFF_TP22,
  BFD_RELOC_IA64_LTOFF22X,
  BFD_RELOC_IA64_LDXMOV,

/* Motorola 68HC11 reloc.
This is the 8 bits high part of an absolute address. */
  BFD_RELOC_M68HC11_HI8,

/* Motorola 68HC11 reloc.
This is the 8 bits low part of an absolute address. */
  BFD_RELOC_M68HC11_LO8,

/* Motorola 68HC11 reloc.
This is the 3 bits of a value. */
  BFD_RELOC_M68HC11_3B,

/* These relocs are only used within the CRIS assembler.  They are not
(at present) written to any object files. */
  BFD_RELOC_CRIS_BDISP8,
  BFD_RELOC_CRIS_UNSIGNED_5,
  BFD_RELOC_CRIS_SIGNED_6,
  BFD_RELOC_CRIS_UNSIGNED_6,
  BFD_RELOC_CRIS_UNSIGNED_4,

/* Intel i860 Relocations. */
  BFD_RELOC_860_COPY,
  BFD_RELOC_860_GLOB_DAT,
  BFD_RELOC_860_JUMP_SLOT,
  BFD_RELOC_860_RELATIVE,
  BFD_RELOC_860_PC26,
  BFD_RELOC_860_PLT26,
  BFD_RELOC_860_PC16,
  BFD_RELOC_860_LOW0,
  BFD_RELOC_860_SPLIT0,
  BFD_RELOC_860_LOW1,
  BFD_RELOC_860_SPLIT1,
  BFD_RELOC_860_LOW2,
  BFD_RELOC_860_SPLIT2,
  BFD_RELOC_860_LOW3,
  BFD_RELOC_860_LOGOT0,
  BFD_RELOC_860_SPGOT0,
  BFD_RELOC_860_LOGOT1,
  BFD_RELOC_860_SPGOT1,
  BFD_RELOC_860_LOGOTOFF0,
  BFD_RELOC_860_SPGOTOFF0,
  BFD_RELOC_860_LOGOTOFF1,
  BFD_RELOC_860_SPGOTOFF1,
  BFD_RELOC_860_LOGOTOFF2,
  BFD_RELOC_860_LOGOTOFF3,
  BFD_RELOC_860_LOPC,
  BFD_RELOC_860_HIGHADJ,
  BFD_RELOC_860_HAGOT,
  BFD_RELOC_860_HAGOTOFF,
  BFD_RELOC_860_HAPC,
  BFD_RELOC_860_HIGH,
  BFD_RELOC_860_HIGOT,
  BFD_RELOC_860_HIGOTOFF,
d2401 2
a2402 1
bfd_reloc_type_lookup PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
d2405 1
a2405 1
bfd_get_reloc_code_name PARAMS ((bfd_reloc_code_real_type code));
d2410 1
a2410 1
       /* A pointer to the BFD which owns the symbol. This information
d2420 1
a2420 1
  struct _bfd *the_bfd; /* Use bfd_asymbol_bfd(sym) to access this field. */
d2422 1
a2422 1
       /* The text of the symbol. The name is left alone, and not copied; the
d2426 1
a2426 1
       /* The value of the symbol.  This really should be a union of a
d2431 1
a2431 1
       /* Attributes of a symbol: */
d2435 1
a2435 1
       /* The symbol has local scope; <<static>> in <<C>>. The value
d2439 1
a2439 1
       /* The symbol has global scope; initialized data in <<C>>. The
d2443 1
a2443 1
       /* The symbol has global scope and is exported. The value is
d2445 1
a2445 1
#define BSF_EXPORT     BSF_GLOBAL /* no real difference */
d2447 1
a2447 1
       /* A normal C symbol would be one of:
d2451 1
a2451 1
       /* The symbol is a debugging record. The value has an arbitary
d2455 1
a2455 1
       /* The symbol denotes a function entry point.  Used in ELF,
d2459 1
a2459 1
       /* Used by the linker. */
d2463 1
a2463 1
       /* A weak global symbol, overridable without warnings by
d2467 1
a2467 1
       /* This symbol was created to point to a section, e.g. ELF's
d2471 1
a2471 1
       /* The symbol used to be a common symbol, but now it is
d2475 1
a2475 1
       /* The default value for common data. */
d2478 1
a2478 1
       /* In some files the type of a symbol sometimes alters its
d2486 1
a2486 1
       /* Signal that the symbol is the label of constructor section. */
d2489 1
a2489 1
       /* Signal that the symbol is a warning symbol.  The name is a
d2495 1
a2495 1
       /* Signal that the symbol is indirect.  This symbol is an indirect
d2499 1
a2499 1
       /* BSF_FILE marks symbols that contain a file name.  This is used
d2503 1
a2503 1
       /* Symbol is from dynamic linking information.  */
d2506 1
a2506 1
       /* The symbol denotes a data object.  Used in ELF, and perhaps
d2510 1
a2510 1
       /* This symbol is a debugging symbol.  The value is the offset
d2517 1
a2517 1
       /* A pointer to the section to which this symbol is
d2522 1
a2522 1
       /* Back end special data.  */
d2532 1
a2532 1
boolean
d2535 1
a2535 1
boolean
d2543 2
a2544 2
boolean
bfd_set_symtab PARAMS ((bfd *abfd, asymbol **location, unsigned int count));
d2546 1
a2546 1
void
d2553 1
a2553 1
int
d2556 2
a2557 2
boolean
bfd_is_undefined_symclass PARAMS ((int symclass));
d2559 1
a2559 1
void
d2562 1
a2562 1
boolean
d2568 1
a2568 1
struct _bfd
d2570 2
a2571 2
    /* The filename the application opened the BFD with.  */
    CONST char *filename;
d2573 1
a2573 1
    /* A pointer to the target jump table.             */
d2576 1
a2576 1
    /* To avoid dragging too many header files into every file that
d2585 1
a2585 1
    /* Is the file descriptor being cached?  That is, can it be closed as
d2590 1
a2590 1
    /* Marks whether there was a default target specified when the
d2596 1
a2596 1
    /* The caching routines use these to maintain a
d2601 1
a2601 1
    /* When a file is closed by the caching routines, BFD retains
d2604 1
a2604 1
    file_ptr where;
d2606 1
a2606 1
    /* and here: (``once'' means at least once) */
d2610 1
a2610 1
    /* Set if we have a locally maintained mtime value, rather than
d2615 1
a2615 1
    /* File modified time, if mtime_set is true: */
d2617 1
a2617 1
    long mtime;
d2619 1
a2619 1
    /* Reserved for an unimplemented file locking extension.*/
d2623 1
a2623 1
    /* The format which belongs to the BFD. (object, core, etc.) */
d2627 1
a2627 1
    /* The direction the BFD was opened with*/
d2634 1
a2634 1
    /* Format_specific flags*/
d2636 1
a2636 1
    flagword flags;
d2638 1
a2638 1
    /* Currently my_archive is tested before adding origin to
d2642 1
a2642 1
    file_ptr origin;
d2644 1
a2644 1
    /* Remember when output has begun, to stop strange things
d2648 1
a2648 1
    /* Pointer to linked list of sections*/
d2651 1
a2651 1
    /* The number of sections */
d2654 1
a2654 1
    /* Stuff only useful for object files:
d2658 1
a2658 1
    /* Used for input and output*/
d2661 2
a2662 2
    /* Symbol table for output BFD (with symcount entries) */
    struct symbol_cache_entry  **outsymbols;
d2664 1
a2664 1
    /* Pointer to structure which contains architecture information*/
d2667 6
a2672 6
    /* Stuff only useful for archives:*/
    PTR arelt_data;
    struct _bfd *my_archive;     /* The containing archive BFD.  */
    struct _bfd *next;           /* The next BFD in the archive.  */
    struct _bfd *archive_head;   /* The first BFD in the archive.  */
    boolean has_armap;
d2674 1
a2674 1
    /* A chain of BFD structures involved in a link.  */
d2677 1
a2677 1
    /* A field used by _bfd_generic_link_add_archive_symbols.  This will
d2681 1
a2681 1
    /* Used by the back end to hold private data. */
d2683 1
a2683 1
    union
d2715 2
a2716 2

    /* Used by the application to hold private data*/
d2719 1
a2719 1
  /* Where all the allocated stuff under this BFD goes.  This is a
d2748 2
a2749 2
bfd_error_type
bfd_get_error PARAMS ((void));
d2751 2
a2752 2
void
bfd_set_error PARAMS ((bfd_error_type error_tag));
d2755 1
a2755 1
bfd_errmsg PARAMS ((bfd_error_type error_tag));
d2757 2
a2758 2
void
bfd_perror PARAMS ((CONST char *message));
d2762 2
a2763 2
bfd_error_handler_type
bfd_set_error_handler PARAMS ((bfd_error_handler_type));
d2765 2
a2766 2
void
bfd_set_error_program_name PARAMS ((const char *));
d2768 2
a2769 2
bfd_error_handler_type
bfd_get_error_handler PARAMS ((void));
d2771 1
a2771 1
long
d2774 3
a2776 2
long
bfd_canonicalize_reloc PARAMS ((bfd *abfd,
d2781 3
a2783 2
void
bfd_set_reloc PARAMS ((bfd *abfd, asection *sec, arelent **rel, unsigned int count)
d2787 1
a2787 1
boolean
d2790 1
a2790 7
int
bfd_get_arch_size PARAMS ((bfd *abfd));

int
bfd_get_sign_extend_vma PARAMS ((bfd *abfd));

boolean
d2793 1
a2793 1
long
d2796 1
a2796 1
long
d2799 1
a2799 1
int
d2802 1
a2802 1
void
d2805 1
a2805 1
bfd_vma
d2808 1
a2808 1
boolean
d2814 1
a2814 1
boolean
d2820 1
a2820 1
boolean
d2832 1
a2832 1
       /* Do these three do anything useful at all, for any back end?  */
d2890 1
a2890 1
symindex
d2893 1
a2893 1
boolean
d2902 1
a2902 1
int
d2905 3
a2907 2
boolean
core_file_matches_executable_p PARAMS ((bfd *core_bfd, bfd *exec_bfd));
d2920 1
a2920 1
            (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)
d2926 1
a2926 1
   (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist) : \
a2933 1
  bfd_target_xcoff_flavour,
d2951 1
a2951 1
/* Forward declaration.  */
d2960 1
a2960 1
  flagword object_flags;
d2963 1
a2963 1
  char ar_pad_char;
d2987 1
a2987 1
  /* Generic entry points.  */
d2995 1
a2995 1
  /* Called when the BFD is being closed to do any necessary cleanup.  */
d2997 1
a2997 1
  /* Ask the BFD to free all cached information.  */
d2999 1
a2999 1
  /* Called when a new section is created.  */
d3001 2
a3002 2
  /* Read the contents of a section.  */
  boolean       (*_bfd_get_section_contents) PARAMS ((bfd *, sec_ptr, PTR,
d3008 1
a3008 1
  /* Entry points to copy private data.  */
d3016 1
a3016 1
  /* Called to copy BFD general private data from one object file
d3019 1
a3019 1
  /* Called to merge BFD general private data from one object file
d3022 1
a3022 1
  /* Called to copy BFD private section data from one object file
d3026 1
a3026 1
  /* Called to copy BFD private symbol data from one symbol
d3030 1
a3030 1
  /* Called to set private backend flags */
d3033 1
a3033 1
  /* Called to print private BFD data */
d3036 1
a3036 1
  /* Core file entry points.  */
d3045 1
a3045 1
  /* Archive entry points.  */
d3062 1
a3062 1
  boolean  (*write_armap) PARAMS ((bfd *arch,
d3065 1
a3065 1
                              unsigned int orl_count,
d3074 1
a3074 1
  /* Entry points used for symbols.  */
d3107 1
a3107 1
 /* Back-door to allow format-aware applications to create debug symbols
d3123 1
a3123 1
  /* Routines for relocs.  */
d3131 1
a3131 1
  /* See documentation on reloc types.  */
d3136 1
a3136 1
  /* Routines used when writing an object file.  */
d3145 1
a3145 1
  /* Routines used by the linker.  */
d3164 1
a3164 1
  /* Create a hash table for the linker.  Different backends store
d3168 1
a3168 1
  /* Add symbols from this object file into the hash table.  */
d3171 1
a3171 1
  /* Do a link based on the link_order structures attached to each
d3175 1
a3175 1
  /* Should this section be split up into smaller pieces during linking.  */
d3178 1
a3178 1
  /* Remove sections that are not referenced from the output.  */
d3181 1
a3181 1
  /* Routines to handle dynamic symbols and relocs.  */
d3187 1
a3187 1
  /* Get the amount of memory required to hold the dynamic symbols. */
d3189 1
a3189 1
  /* Read in the dynamic symbols.  */
d3192 1
a3192 1
  /* Get the amount of memory required to hold the dynamic relocs.  */
d3194 1
a3194 1
  /* Read in the dynamic relocs.  */
d3198 1
a3198 1
 /* Opposite endian version of this target.  */
d3200 1
a3200 1

d3202 1
a3202 1

d3204 2
a3205 2
boolean
bfd_set_default_target PARAMS ((const char *name));
d3213 2
a3214 2
const bfd_target *
bfd_search_for_target PARAMS ((int (* search_func) (const bfd_target *, void *), void *));
d3216 1
a3216 1
boolean
d3219 1
a3219 1
boolean
d3222 1
a3222 1
boolean
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@a0 7
/* DO NOT EDIT!  -*- buffer-read-only: t -*-  This file is automatically 
   generated from "bfd-in.h", "init.c", "opncls.c", "libbfd.c", 
   "bfdio.c", "bfdwin.c", "section.c", "archures.c", "reloc.c", 
   "syms.c", "bfd.c", "archive.c", "corefile.c", "targets.c", "format.c", 
   "linker.c" and "simple.c".
   Run "make headers" in your build bfd/ to regenerate.  */

d2 3
a4 4

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.

d7 38
a44 15
   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a53 12
#include "symcat.h"
#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
#ifndef SABER
/* This hack is to avoid a problem with some strict ANSI C preprocessors.
   The problem is, "32_" is not a valid preprocessing token, and we don't
   want extra underscores (e.g., "nlm_32_").  The XCONCAT2 macro will
   cause the inner CONCAT2 macros to be evaluated first, producing
   still-valid pp-tokens.  Then the final concatenation can be done.  */
#undef CONCAT4
#define CONCAT4(a,b,c,d) XCONCAT2(CONCAT2(a,b),CONCAT2(c,d))
#endif
#endif
d55 2
a56 3
/* The word size used by BFD on the host.  This may be 64 with a 32
   bit target if the host is 64 bit, or if other 64 bit targets have
   been selected with --enable-targets, or if --enable-64-bit-bfd.  */
a57 4

/* The word size of the default bfd target.  */
#define BFD_DEFAULT_TARGET_SIZE @@bfd_default_target_size@@

d76 2
a77 2
/* Forward declaration.  */
typedef struct bfd bfd;
d79 28
a106 21
/* Boolean type used in bfd.  Too many systems define their own
   versions of "boolean" for us to safely typedef a "boolean" of
   our own.  Using an enum for "bfd_boolean" has its own set of
   problems, with strange looking casts required to avoid warnings
   on some older compilers.  Thus we just use an int.

   General rule: Functions which are bfd_boolean return TRUE on
   success and FALSE on failure (unless they're a predicate).  */

typedef int bfd_boolean;
#undef FALSE
#undef TRUE
#define FALSE 0
#define TRUE 1

#if 0
/* Poison.  */
#undef false
#undef true
#define false dont_use_false_in_bfd
#define true dont_use_true_in_bfd
d109 10
a185 16
/* A pointer to a position in a file.  */
/* FIXME:  This should be using off_t from <sys/types.h>.
   For now, try to avoid breaking stuff by not including <sys/types.h> here.
   This will break on systems with 64-bit file offsets (e.g. 4.4BSD).
   Probably the best long-term answer is to avoid using file_ptr AND off_t
   in this header file, and to handle this in the BFD implementation
   rather than in its interface.  */
/* typedef off_t	file_ptr; */
typedef bfd_signed_vma file_ptr;
typedef bfd_vma ufile_ptr;

extern void bfd_sprintf_vma
  PARAMS ((bfd *, char *, bfd_vma));
extern void bfd_fprintf_vma
  PARAMS ((bfd *, PTR, bfd_vma));

a186 1
#define bfd_printf_vma(abfd,x) bfd_fprintf_vma (abfd,stdout,x)
d191 1
a191 1
/* File formats.  */
d193 7
a199 9
typedef enum bfd_format
{
  bfd_unknown = 0,	/* File format is unknown.  */
  bfd_object,		/* Linker/assember/compiler output.  */
  bfd_archive,		/* Object archive file.  */
  bfd_core,		/* Core dump.  */
  bfd_type_end		/* Marks the end; don't use it!  */
}
bfd_format;
a256 3

/* The sections in this BFD specify a memory page.  */
#define HAS_LOAD_PAGE 0x1000
d258 1
a258 1
/* Symbols and relocation.  */
d282 2
a283 3
/* This is a type pun with struct ranlib on purpose!  */
typedef struct carsym
{
d285 2
a286 3
  file_ptr file_offset;	/* Look here to find the file.  */
}
carsym;			/* To make these you call a carsymogen.  */
d289 5
a293 10
   Perhaps just a forward definition would do?  */
struct orl 			/* Output ranlib.  */
{
  char **name;		/* Symbol name.  */
  union
  {
    file_ptr pos;
    bfd *abfd;
  } u;			/* bfd* or file position.  */
  int namidx;		/* Index into string table.  */
d296 6
a301 8
/* Linenumber stuff.  */
typedef struct lineno_cache_entry
{
  unsigned int line_number;	/* Linenumber from start of function.  */
  union
  {
    struct symbol_cache_entry *sym;	/* Function name.  */
    bfd_vma offset;	    		/* Offset into section.  */
d303 1
a303 2
}
alent;
d305 1
a305 1
/* Object and core file sections.  */
d308 1
a308 1
  (((addr) + ((bfd_vma) 1 << (align)) - 1) & ((bfd_vma) -1 << (align)))
a313 1
#define bfd_get_section_lma(bfd, ptr) ((ptr)->lma + 0)
d325 3
a327 3
#define bfd_set_section_vma(bfd, ptr, val) (((ptr)->vma = (ptr)->lma = (val)), ((ptr)->user_set_vma = TRUE), TRUE)
#define bfd_set_section_alignment(bfd, ptr, val) (((ptr)->alignment_power = (val)),TRUE)
#define bfd_set_section_userdata(bfd, ptr, val) (((ptr)->userdata = (val)),TRUE)
d344 1
a344 1
  const char *name;            /* Symbol name.  */
d348 1
a348 1
  const char *stab_name;       /* String for stab type.  */
d353 1
a353 2
extern const char *bfd_get_stab_name
  PARAMS ((int));
d386 3
a388 2
  struct bfd_hash_entry *(*newfunc)
    PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d395 1
a395 1
extern bfd_boolean bfd_hash_table_init
d402 1
a402 1
extern bfd_boolean bfd_hash_table_init_n
d410 1
a410 2
extern void bfd_hash_table_free
  PARAMS ((struct bfd_hash_table *));
d412 1
a412 1
/* Look up a string in a hash table.  If CREATE is TRUE, a new entry
d414 1
a414 1
   COPY argument must be TRUE if this routine should copy the string
d417 2
a418 2
  PARAMS ((struct bfd_hash_table *, const char *, bfd_boolean create,
	   bfd_boolean copy));
d431 2
a432 2
extern PTR bfd_hash_allocate
  PARAMS ((struct bfd_hash_table *, unsigned int));
d435 1
a435 1
   element.  If the function returns FALSE, the traversal stops.  The
d437 29
a465 4
extern void bfd_hash_traverse
  PARAMS ((struct bfd_hash_table *,
	   bfd_boolean (*) (struct bfd_hash_entry *, PTR),
	   PTR info));
d468 2
a469 2

/* User program access to BFD facilities.  */
d474 8
a481 31
extern bfd_size_type bfd_bread
  PARAMS ((PTR, bfd_size_type, bfd *));
extern bfd_size_type bfd_bwrite
  PARAMS ((const PTR, bfd_size_type, bfd *));
extern int bfd_seek
  PARAMS ((bfd *, file_ptr, int));
extern ufile_ptr bfd_tell
  PARAMS ((bfd *));
extern int bfd_flush
  PARAMS ((bfd *));
extern int bfd_stat
  PARAMS ((bfd *, struct stat *));

/* Deprecated old routines.  */
#if __GNUC__
#define bfd_read(BUF, ELTSIZE, NITEMS, ABFD)				\
  (warn_deprecated ("bfd_read", __FILE__, __LINE__, __FUNCTION__),	\
   bfd_bread ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
#define bfd_write(BUF, ELTSIZE, NITEMS, ABFD)				\
  (warn_deprecated ("bfd_write", __FILE__, __LINE__, __FUNCTION__),	\
   bfd_bwrite ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
#else
#define bfd_read(BUF, ELTSIZE, NITEMS, ABFD)				\
  (warn_deprecated ("bfd_read", (const char *) 0, 0, (const char *) 0), \
   bfd_bread ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
#define bfd_write(BUF, ELTSIZE, NITEMS, ABFD)				\
  (warn_deprecated ("bfd_write", (const char *) 0, 0, (const char *) 0),\
   bfd_bwrite ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
#endif
extern void warn_deprecated
  PARAMS ((const char *, const char *, int, const char *));
a512 2
#define bfd_get_dynamic_symcount(abfd) ((abfd)->dynsymcount)

d515 1
a515 1
#define bfd_set_cacheable(abfd,bool) (((abfd)->cacheable = bool), TRUE)
d517 3
a519 7
extern bfd_boolean bfd_cache_close
  PARAMS ((bfd *abfd));
/* NB: This declaration should match the autogenerated one in libbfd.h.  */

extern bfd_boolean bfd_record_phdr
  PARAMS ((bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
	   bfd_boolean, bfd_boolean, unsigned int, struct sec **));
d523 18
a540 36
bfd_vma bfd_getb64
  PARAMS ((const unsigned char *));
bfd_vma bfd_getl64
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getb_signed_64
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getl_signed_64
  PARAMS ((const unsigned char *));
bfd_vma bfd_getb32
  PARAMS ((const unsigned char *));
bfd_vma bfd_getl32
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getb_signed_32
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getl_signed_32
  PARAMS ((const unsigned char *));
bfd_vma bfd_getb16
  PARAMS ((const unsigned char *));
bfd_vma bfd_getl16
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getb_signed_16
  PARAMS ((const unsigned char *));
bfd_signed_vma bfd_getl_signed_16
  PARAMS ((const unsigned char *));
void bfd_putb64
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putl64
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putb32
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putl32
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putb16
  PARAMS ((bfd_vma, unsigned char *));
void bfd_putl16
  PARAMS ((bfd_vma, unsigned char *));
d544 2
a545 4
bfd_vma bfd_get_bits
  PARAMS ((bfd_byte *, int, bfd_boolean));
void bfd_put_bits
  PARAMS ((bfd_vma, bfd_byte *, int, bfd_boolean));
d558 3
a560 5
extern bfd_vma bfd_ecoff_get_gp_value
  PARAMS ((bfd * abfd));
extern bfd_boolean bfd_ecoff_set_gp_value
  PARAMS ((bfd *abfd, bfd_vma gp_value));
extern bfd_boolean bfd_ecoff_set_regmasks
d571 1
a571 1
extern bfd_boolean bfd_ecoff_debug_accumulate
d577 1
a577 1
extern bfd_boolean bfd_ecoff_debug_accumulate_other
d581 1
a581 1
extern bfd_boolean bfd_ecoff_debug_externals
d584 3
a586 3
	   bfd_boolean relocateable,
	   bfd_boolean (*get_extr) (struct symbol_cache_entry *,
				    struct ecoff_extr *),
d589 1
a589 1
extern bfd_boolean bfd_ecoff_debug_one_external
d596 1
a596 1
extern bfd_boolean bfd_ecoff_write_debug
d599 1
a599 1
extern bfd_boolean bfd_ecoff_write_accumulated_debug
d603 1
a603 1
extern bfd_boolean bfd_mips_ecoff_create_embedded_relocs
d616 4
a619 4
extern bfd_boolean bfd_elf32_record_link_assignment
  PARAMS ((bfd *, struct bfd_link_info *, const char *, bfd_boolean));
extern bfd_boolean bfd_elf64_record_link_assignment
  PARAMS ((bfd *, struct bfd_link_info *, const char *, bfd_boolean));
d622 1
a622 1
extern bfd_boolean bfd_elf_get_bfd_needed_list
d624 2
a625 2
extern bfd_boolean bfd_elf32_size_dynamic_sections
  PARAMS ((bfd *, const char *, const char *, const char *,
d628 2
a629 2
extern bfd_boolean bfd_elf64_size_dynamic_sections
  PARAMS ((bfd *, const char *, const char *, const char *,
d632 3
a634 6
extern void bfd_elf_set_dt_needed_name
  PARAMS ((bfd *, const char *));
extern void bfd_elf_set_dt_needed_soname
  PARAMS ((bfd *, const char *));
extern const char *bfd_elf_get_dt_soname
  PARAMS ((bfd *));
a636 4
extern bfd_boolean bfd_elf32_discard_info
  PARAMS ((bfd *, struct bfd_link_info *));
extern bfd_boolean bfd_elf64_discard_info
  PARAMS ((bfd *, struct bfd_link_info *));
d641 1
a641 2
extern long bfd_get_elf_phdr_upper_bound
  PARAMS ((bfd *abfd));
d650 1
a650 2
extern int bfd_get_elf_phdrs
  PARAMS ((bfd *abfd, void *phdrs));
d653 1
a653 2
extern int bfd_get_arch_size
  PARAMS ((bfd *));
d655 2
a656 3
/* Return TRUE if address "naturally" sign extends, or -1 if not elf.  */
extern int bfd_get_sign_extend_vma
  PARAMS ((bfd *));
d658 1
a658 4
extern bfd_boolean bfd_m68k_elf32_create_embedded_relocs
  PARAMS ((bfd *, struct bfd_link_info *, struct sec *, struct sec *,
	   char **));
extern bfd_boolean bfd_mips_elf32_create_embedded_relocs
d666 1
a666 1
extern bfd_boolean bfd_sunos_record_link_assignment
d668 1
a668 1
extern bfd_boolean bfd_sunos_size_dynamic_sections
d674 1
a674 1
extern bfd_boolean bfd_i386linux_size_dynamic_sections
d676 1
a676 1
extern bfd_boolean bfd_m68klinux_size_dynamic_sections
d678 1
a678 1
extern bfd_boolean bfd_sparclinux_size_dynamic_sections
d686 1
a686 2
typedef struct _bfd_window
{
d697 1
a697 2
}
bfd_window;
d699 4
a702 6
extern void bfd_init_window
  PARAMS ((bfd_window *));
extern void bfd_free_window
  PARAMS ((bfd_window *));
extern bfd_boolean bfd_get_file_window
  PARAMS ((bfd *, file_ptr, bfd_size_type, bfd_window *, bfd_boolean));
d706 1
a706 1
extern bfd_boolean bfd_xcoff_link_record_set
d709 4
a712 1
extern bfd_boolean bfd_xcoff_import_symbol
d714 2
a715 4
	   bfd_vma, const char *, const char *, const char *, unsigned int));
extern bfd_boolean bfd_xcoff_export_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *));
extern bfd_boolean bfd_xcoff_link_count_reloc
d717 1
a717 1
extern bfd_boolean bfd_xcoff_record_link_assignment
d719 1
a719 1
extern bfd_boolean bfd_xcoff_size_dynamic_sections
d721 2
a722 8
	   unsigned long, unsigned long, unsigned long, bfd_boolean,
	   int, bfd_boolean, bfd_boolean, struct sec **, bfd_boolean));
extern bfd_boolean bfd_xcoff_link_generate_rtinit
  PARAMS ((bfd *, const char *, const char *, bfd_boolean));

/* XCOFF support routines for ar.  */
extern bfd_boolean bfd_xcoff_ar_archive_set_magic
  PARAMS ((bfd *, char *));
d731 1
a731 1
extern bfd_boolean bfd_coff_get_syment
d734 1
a734 1
extern bfd_boolean bfd_coff_get_auxent
d737 1
a737 1
extern bfd_boolean bfd_coff_set_symbol_class
d740 1
a740 1
extern bfd_boolean bfd_m68k_coff_create_embedded_relocs
d745 1
a745 1
extern bfd_boolean bfd_arm_allocate_interworking_sections
d748 1
a748 1
extern bfd_boolean bfd_arm_process_before_allocation
d751 1
a751 1
extern bfd_boolean bfd_arm_get_bfd_for_interworking
d755 1
a755 1
extern bfd_boolean bfd_arm_pe_allocate_interworking_sections
d758 1
a758 1
extern bfd_boolean bfd_arm_pe_process_before_allocation
d761 1
a761 1
extern bfd_boolean bfd_arm_pe_get_bfd_for_interworking
d765 1
a765 1
extern bfd_boolean bfd_elf32_arm_allocate_interworking_sections
d768 1
a768 1
extern bfd_boolean bfd_elf32_arm_process_before_allocation
d771 1
a771 4
extern bfd_boolean bfd_elf32_arm_get_bfd_for_interworking
  PARAMS ((bfd *, struct bfd_link_info *));

extern bfd_boolean bfd_elf32_arm_add_glue_sections_to_bfd
a773 10
/* ARM Note section processing.  */
extern bfd_boolean bfd_arm_merge_machines
  PARAMS ((bfd *, bfd *));

extern bfd_boolean bfd_arm_update_notes
  PARAMS ((bfd *, const char *));

extern unsigned int bfd_arm_get_mach_from_notes
  PARAMS ((bfd *, const char *));

d781 1
a781 1
/* Extracted from init.c.  */
a784 1
/* Extracted from opncls.c.  */
d786 1
a786 1
bfd_openr PARAMS ((const char *filename, const char *target));
d789 1
a789 1
bfd_fdopenr PARAMS ((const char *filename, const char *target, int fd));
d795 1
a795 1
bfd_openw PARAMS ((const char *filename, const char *target));
d797 1
a797 1
bfd_boolean
d800 1
a800 1
bfd_boolean
d804 1
a804 1
bfd_create PARAMS ((const char *filename, bfd *templ));
d806 1
a806 1
bfd_boolean
d809 1
a809 1
bfd_boolean
a811 4
char *
bfd_follow_gnu_debuglink PARAMS ((bfd *abfd, const char *dir));

/* Extracted from libbfd.c.  */
d820 1
a820 1
                (*(unsigned char *) (ptr) & 0xff)
d822 1
a822 1
               (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)
d852 1
a852 1
                ( (bits) ==  8 ? (bfd_vma) bfd_get_8 (abfd, ptr)       \
d859 1
a859 1
                ( (bits) ==  8 ? bfd_put_8  (abfd, val, ptr)   \
d869 1
a869 1
  bfd_put_8 (abfd, val, ptr)
d871 1
a871 1
  bfd_put_8 (abfd, val, ptr)
d873 1
a873 1
  bfd_get_8 (abfd, ptr)
d875 1
a875 1
  bfd_get_signed_8 (abfd, ptr)
d878 1
a878 1
  BFD_SEND (abfd, bfd_h_putx16, (val, ptr))
d880 1
a880 1
  bfd_h_put_16
d882 1
a882 1
  BFD_SEND (abfd, bfd_h_getx16, (ptr))
d884 1
a884 1
  BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr))
d887 1
a887 1
  BFD_SEND (abfd, bfd_h_putx32, (val, ptr))
d889 1
a889 1
  bfd_h_put_32
d891 1
a891 1
  BFD_SEND (abfd, bfd_h_getx32, (ptr))
d893 1
a893 1
  BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr))
d896 1
a896 1
  BFD_SEND (abfd, bfd_h_putx64, (val, ptr))
d898 1
a898 1
  bfd_h_put_64
d900 1
a900 1
  BFD_SEND (abfd, bfd_h_getx64, (ptr))
d902 1
a902 26
  BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr))

/* Refinements on the above, which should eventually go away.  Save
   cluttering the source with (bfd_vma) and (bfd_byte *) casts.  */

#define H_PUT_64(abfd, val, where) \
  bfd_h_put_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_32(abfd, val, where) \
  bfd_h_put_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_16(abfd, val, where) \
  bfd_h_put_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_8 bfd_h_put_8

#define H_PUT_S64(abfd, val, where) \
  bfd_h_put_signed_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S32(abfd, val, where) \
  bfd_h_put_signed_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S16(abfd, val, where) \
  bfd_h_put_signed_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S8 bfd_h_put_signed_8
a903 32
#define H_GET_64(abfd, where) \
  bfd_h_get_64 ((abfd), (bfd_byte *) (where))

#define H_GET_32(abfd, where) \
  bfd_h_get_32 ((abfd), (bfd_byte *) (where))

#define H_GET_16(abfd, where) \
  bfd_h_get_16 ((abfd), (bfd_byte *) (where))

#define H_GET_8 bfd_h_get_8

#define H_GET_S64(abfd, where) \
  bfd_h_get_signed_64 ((abfd), (bfd_byte *) (where))

#define H_GET_S32(abfd, where) \
  bfd_h_get_signed_32 ((abfd), (bfd_byte *) (where))

#define H_GET_S16(abfd, where) \
  bfd_h_get_signed_16 ((abfd), (bfd_byte *) (where))

#define H_GET_S8 bfd_h_get_signed_8


/* Extracted from bfdio.c.  */
long
bfd_get_mtime PARAMS ((bfd *abfd));

long
bfd_get_size PARAMS ((bfd *abfd));

/* Extracted from bfdwin.c.  */
/* Extracted from section.c.  */
d925 1
d929 1
d932 2
a933 1
  /* Which section in the bfd; 0..n-1 as sections are created in a bfd.  */
d937 1
d943 1
d960 3
a962 5
  /* ELF reserves 4 processor specific bits and 8 operating system
     specific bits in sh_flags; at present we can get away with just
     one in communicating between the assembler and BFD, but this
     isn't a good long-term solution.  */
#define SEC_ARCH_BIT_0 0x008
d988 6
a1013 3
  /* The section contains thread local data.  */
#define SEC_THREAD_LOCAL 0x1000

d1045 3
a1047 4
  /* The contents of this section are to be sorted based on the sum of
     the symbol and addend values specified by the associated relocation
     entries.  Entries without associated relocation entries will be
     appended to the end of the section in an unspecified order.  */
a1104 12
  /* Attempt to merge identical entities in the section.
     Entity size is given in the entsize field.  */
#define SEC_MERGE 0x20000000

  /* If given with SEC_MERGE, entities to merge are zero terminated
     strings where entsize specifies character size instead of fixed
     size entries.  */
#define SEC_STRINGS 0x40000000

  /* This section contains data about section groups.  */
#define SEC_GROUP 0x80000000

d1119 1
a1119 1
     output sections that have an input section.  */
d1125 1
a1125 3
  /* The following flags are used by the ELF linker. */

  /* Mark sections which have been allocated to segments.  */
a1127 26
  /* Type of sec_info information.  */
  unsigned int sec_info_type:3;
#define ELF_INFO_TYPE_NONE      0
#define ELF_INFO_TYPE_STABS     1
#define ELF_INFO_TYPE_MERGE     2
#define ELF_INFO_TYPE_EH_FRAME  3
#define ELF_INFO_TYPE_JUST_SYMS 4

  /* Nonzero if this section uses RELA relocations, rather than REL.  */
  unsigned int use_rela_p:1;

  /* Bits used by various backends.  */
  unsigned int has_tls_reloc:1;

  /* Nonzero if this section needs the relax finalize pass.  */
  unsigned int need_finalize_relax:1;

  /* Usused bits.  */
  unsigned int flag12:1;
  unsigned int flag13:1;
  unsigned int flag14:1;
  unsigned int flag15:1;
  unsigned int flag16:4;
  unsigned int flag20:4;
  unsigned int flag24:8;

d1136 1
d1141 2
a1142 1
      information.  */
d1148 1
d1154 1
d1164 1
d1168 1
d1173 1
d1178 1
d1183 1
d1186 2
a1187 1
  /* The number of relocation records in one of the above.  */
d1194 1
d1198 1
d1202 1
d1206 1
d1214 1
d1218 1
d1221 1
a1221 2
  /* Entity size for merging purposes.  */
  unsigned int entsize;
a1222 1
  /* Optional information about a COMDAT entry; NULL if not COMDAT.  */
d1225 4
d1231 1
d1235 1
d1242 1
d1246 1
d1249 1
a1249 1
  /* A symbol which points at this section only.  */
d1255 1
a1255 1
} asection;
d1267 1
a1267 1
/* The absolute section.  */
d1271 1
a1271 1
/* Pointer to the undefined section.  */
d1275 1
a1275 1
/* Pointer to the common section.  */
d1278 1
a1278 1
/* Pointer to the indirect section.  */
a1282 6
#define bfd_is_const_section(SEC)              \
 (   ((SEC) == bfd_abs_section_ptr)            \
  || ((SEC) == bfd_und_section_ptr)            \
  || ((SEC) == bfd_com_section_ptr)            \
  || ((SEC) == bfd_ind_section_ptr))

a1292 29

/* Macros to handle insertion and deletion of a bfd's sections.  These
   only handle the list pointers, ie. do not adjust section_count,
   target_index etc.  */
#define bfd_section_list_remove(ABFD, PS) \
  do                                                   \
    {                                                  \
      asection **_ps = PS;                             \
      asection *_s = *_ps;                             \
      *_ps = _s->next;                                 \
      if (_s->next == NULL)                            \
        (ABFD)->section_tail = _ps;                    \
    }                                                  \
  while (0)
#define bfd_section_list_insert(ABFD, PS, S) \
  do                                                   \
    {                                                  \
      asection **_ps = PS;                             \
      asection *_s = S;                                \
      _s->next = *_ps;                                 \
      *_ps = _s;                                       \
      if (_s->next == NULL)                            \
        (ABFD)->section_tail = &_s->next;              \
    }                                                  \
  while (0)

void
bfd_section_list_clear PARAMS ((bfd *));

d1310 1
a1310 1
bfd_boolean
d1320 1
a1320 1
bfd_boolean
d1323 5
a1327 3
bfd_boolean
bfd_set_section_contents PARAMS ((bfd *abfd, asection *section,
    PTR data, file_ptr offset,
d1330 3
a1332 4
bfd_boolean
bfd_get_section_contents PARAMS ((bfd *abfd, asection *section,
    PTR location, file_ptr offset,
    bfd_size_type count));
d1334 2
a1335 3
bfd_boolean
bfd_copy_private_section_data PARAMS ((bfd *ibfd, asection *isec,
    bfd *obfd, asection *osec));
a1342 4
bfd_boolean
bfd_generic_discard_group PARAMS ((bfd *abfd, asection *group));

/* Extracted from archures.c.  */
d1345 2
a1346 2
  bfd_arch_unknown,   /* File arch not known.  */
  bfd_arch_obscure,   /* Arch known, not one of these.  */
d1368 1
a1368 1
       "core".  */
a1378 2
  bfd_arch_or32,      /* OpenRISC 32 */

d1386 1
a1386 1
#define bfd_mach_sparc_v8plusa         5 /* with ultrasparc add'ns.  */
d1389 3
a1391 3
#define bfd_mach_sparc_v9a             8 /* with ultrasparc add'ns.  */
#define bfd_mach_sparc_v8plusb         9 /* with cheetah add'ns.  */
#define bfd_mach_sparc_v9b             10 /* with cheetah add'ns.  */
a1402 1
#define bfd_mach_mips4120              4120
a1407 2
#define bfd_mach_mips5400              5400
#define bfd_mach_mips5500              5500
d1413 2
d1416 1
a1417 3
#define bfd_mach_mipsisa32             32
#define bfd_mach_mipsisa32r2           33
#define bfd_mach_mipsisa64             64
d1419 5
a1423 5
#define bfd_mach_i386_i386 1
#define bfd_mach_i386_i8086 2
#define bfd_mach_i386_i386_intel_syntax 3
#define bfd_mach_x86_64 64
#define bfd_mach_x86_64_intel_syntax 65
a1431 1
  bfd_arch_m98k,      /* Motorola 98xxx */
d1433 4
a1436 7
  bfd_arch_h8300,     /* Renesas H8/300 (formerly Hitachi H8/300) */
#define bfd_mach_h8300    1
#define bfd_mach_h8300h   2
#define bfd_mach_h8300s   3
#define bfd_mach_h8300hn  4
#define bfd_mach_h8300sn  5
  bfd_arch_pdp11,     /* DEC PDP-11 */
d1438 1
a1438 2
#define bfd_mach_ppc           32
#define bfd_mach_ppc64         64
a1454 1
#define bfd_mach_ppc_e500      500
d1456 1
a1456 1
#define bfd_mach_rs6k          6000
d1462 1
a1462 1
#define bfd_mach_d10v          1
a1465 1
  bfd_arch_dlx,       /* DLX */
a1467 3
#define bfd_mach_m6812_default 0
#define bfd_mach_m6812         1
#define bfd_mach_m6812s        2
d1471 3
a1473 3
  bfd_arch_h8500,     /* Renesas H8/500 (formerly Hitachi H8/500) */
  bfd_arch_sh,        /* Renesas / SuperH SH (formerly Hitachi SH) */
#define bfd_mach_sh            1
a1475 1
#define bfd_mach_sh2e       0x2e
a1479 1
#define bfd_mach_sh5        0x50
d1484 1
a1484 2
  bfd_arch_arm,       /* Advanced Risc Machines ARM.  */
#define bfd_mach_arm_unknown   0
a1494 2
#define bfd_mach_arm_ep9312    11
#define bfd_mach_arm_iWMMXt    12
a1497 3
  bfd_arch_tic4x,     /* Texas Instruments TMS320C3X/4X */
#define bfd_mach_tic3x         30
#define bfd_mach_tic4x         40
d1501 1
a1501 1
#define bfd_mach_v850          1
d1503 1
d1505 6
a1510 6
#define bfd_mach_arc_5         5
#define bfd_mach_arc_6         6
#define bfd_mach_arc_7         7
#define bfd_mach_arc_8         8
  bfd_arch_m32r,      /* Renesas M32R (formerly Mitsubishi M32R/D) */
#define bfd_mach_m32r          1 /* For backwards compatibility.  */
a1517 7
  bfd_arch_frv,
#define bfd_mach_frv           1
#define bfd_mach_frvsimple     2
#define bfd_mach_fr300         300
#define bfd_mach_fr400         400
#define bfd_mach_frvtomcat     499     /* fr500 prototype */
#define bfd_mach_fr500         500
d1520 2
a1521 8
#define bfd_mach_ia64_elf64    64
#define bfd_mach_ia64_elf32    32
  bfd_arch_ip2k,      /* Ubicom IP2K microcontrollers. */
#define bfd_mach_ip2022        1
#define bfd_mach_ip2022ext     2
 bfd_arch_iq2000,     /* Vitesse IQ2000.  */
#define bfd_mach_iq2000        1
#define bfd_mach_iq10          2
d1523 1
a1523 1
  bfd_arch_avr,       /* Atmel AVR microcontrollers.  */
a1529 23
  bfd_arch_s390,      /* IBM s390 */
#define bfd_mach_s390_31       31
#define bfd_mach_s390_64       64
  bfd_arch_openrisc,  /* OpenRISC */
  bfd_arch_mmix,      /* Donald Knuth's educational processor.  */
  bfd_arch_xstormy16,
#define bfd_mach_xstormy16     1
  bfd_arch_msp430,    /* Texas Instruments MSP430 architecture.  */
#define bfd_mach_msp110         110
#define bfd_mach_msp11          11
#define bfd_mach_msp12          12
#define bfd_mach_msp13          13
#define bfd_mach_msp14          14
#define bfd_mach_msp41          41
#define bfd_mach_msp31          31
#define bfd_mach_msp32          32
#define bfd_mach_msp33          33
#define bfd_mach_msp43          43
#define bfd_mach_msp44          44
#define bfd_mach_msp15          15
#define bfd_mach_msp16          16  
  bfd_arch_xtensa,    /* Tensilica's Xtensa cores.  */
#define bfd_mach_xtensa        1
d1543 2
a1544 4
  /* TRUE if this is the default machine for the architecture.
     The default arch should be the first entry for an arch so that
     all the entries for that arch can be accessed via <<next>>.  */
  bfd_boolean the_default;
d1549 1
a1549 1
  bfd_boolean (*scan) PARAMS ((const struct bfd_arch_info *, const char *));
d1552 1
a1552 3
}
bfd_arch_info_type;

d1565 1
a1565 2
    const bfd *bbfd,
    bfd_boolean accept_unknowns));
a1599 1
/* Extracted from reloc.c.  */
d1602 1
a1602 1
  /* No errors detected.  */
d1605 1
a1605 1
  /* The relocation was performed, but there was an overflow.  */
d1608 1
a1608 1
  /* The address to relocate was not within the section supplied.  */
d1611 1
a1611 1
  /* Used by special functions.  */
d1614 1
a1614 1
  /* Unsupported relocation size requested.  */
d1617 1
a1617 1
  /* Unused.  */
d1620 1
a1620 1
  /* The symbol to relocate against was undefined.  */
d1623 4
a1626 4
  /* The relocation was performed, but may not be ok - presently
     generated only when linking i960 coff files with i960 b.out
     symbols.  If this type is returned, the error_message argument
     to bfd_perform_relocation will be set.  */
d1634 1
a1634 1
  /* A pointer into the canonical table of pointers.  */
d1637 1
a1637 1
  /* offset in section.  */
d1640 1
a1640 1
  /* addend for relocation value.  */
d1643 1
a1643 1
  /* Pointer to how to perform the required relocation.  */
d1646 1
a1646 3
}
arelent;

d1649 1
a1649 1
  /* Do not complain on overflow.  */
d1652 2
a1653 2
  /* Complain if the bitfield overflows, whether it is considered
     as signed or unsigned.  */
d1656 2
a1657 2
  /* Complain if the value overflows when considered as signed
     number.  */
d1660 2
a1661 2
  /* Complain if the value overflows when considered as an
     unsigned number.  */
d1667 6
a1672 6
  /*  The type field has mainly a documentary use - the back end can
      do what it wants with it, though normally the back end's
      external idea of what a reloc number is stored
      in this field.  For example, a PC relative word relocation
      in a coff environment has the type 023 - because that's
      what the outside world calls a R_PCRWORD reloc.  */
d1675 2
a1676 2
  /*  The value the final relocation is shifted right by.  This drops
      unwanted data from the relocation.  */
d1679 3
a1681 3
  /*  The size of the item to be relocated.  This is *not* a
      power-of-two measure.  To get the number of bytes operated
      on by a type of relocation, use bfd_get_reloc_size.  */
d1684 2
a1685 2
  /*  The number of bits in the item to be relocated.  This is used
      when doing overflow checking.  */
d1688 5
a1692 5
  /*  Notes that the relocation is relative to the location in the
      data section of the addend.  The relocation function will
      subtract from the relocation value the address of the location
      being relocated.  */
  bfd_boolean pc_relative;
d1694 2
a1695 2
  /*  The bit position of the reloc value in the destination.
      The relocated value is left shifted by this amount.  */
d1698 2
a1699 2
  /* What type of overflow error should be checked for when
     relocating.  */
d1702 4
a1705 4
  /* If this field is non null, then the supplied function is
     called rather than the normal function.  This allows really
     strange relocation methods to be accomodated (e.g., i960 callj
     instructions).  */
d1707 7
a1713 2
    PARAMS ((bfd *, arelent *, struct symbol_cache_entry *, PTR, asection *,
             bfd *, char **));
d1715 1
a1715 1
  /* The textual name of the relocation type.  */
d1718 24
a1741 25
  /* Some formats record a relocation addend in the section contents
     rather than with the relocation.  For ELF formats this is the
     distinction between USE_REL and USE_RELA (though the code checks
     for USE_REL == 1/0).  The value of this field is TRUE if the
     addend is recorded with the section contents; when performing a
     partial link (ld -r) the section contents (the data) will be
     modified.  The value of this field is FALSE if addends are
     recorded with the relocation (in arelent.addend); when performing
     a partial link the relocation will be modified.
     All relocations for all ELF USE_RELA targets should set this field
     to FALSE (values of TRUE should be looked on with suspicion).
     However, the converse is not true: not all relocations of all ELF
     USE_REL targets set this field to TRUE.  Why this is so is peculiar
     to each particular target.  For relocs that aren't used in partial
     links (e.g. GOT stuff) it doesn't matter what this is set to.  */
  bfd_boolean partial_inplace;

  /* src_mask selects the part of the instruction (or data) to be used
     in the relocation sum.  If the target relocations don't have an
     addend in the reloc, eg. ELF USE_REL, src_mask will normally equal
     dst_mask to extract the addend from the section contents.  If
     relocations do have an addend in the reloc, eg. ELF USE_RELA, this
     field should be zero.  Non-zero values for ELF USE_RELA targets are
     bogus as in those cases the value in the dst_mask part of the
     section contents should be treated as garbage.  */
d1744 4
a1747 2
  /* dst_mask selects which parts of the instruction (or data) are
     replaced with a relocated value.  */
d1750 8
a1757 7
  /* When some formats create PC relative instructions, they leave
     the value of the pc of the place being relocated in the offset
     slot of the instruction, so that a PC relative relocation can
     be made just by adding in an ordinary offset (e.g., sun3 a.out).
     Some formats leave the displacement part of an instruction
     empty (e.g., m88k bcs); this flag signals the fact.  */
  bfd_boolean pcrel_offset;
d1759 3
a1761 6

#define HOWTO(C, R, S, B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC) \
  { (unsigned) C, R, S, B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC }
#define NEWHOWTO(FUNCTION, NAME, SIZE, REL, IN) \
  HOWTO (0, 0, SIZE, 0, REL, 0, complain_overflow_dont, FUNCTION, \
         NAME, FALSE, 0, 0, IN)
d1764 1
a1764 17
  HOWTO ((C), 0, 0, 0, FALSE, 0, complain_overflow_dont, NULL, \
         NULL, FALSE, 0, 0, FALSE)

#define HOWTO_PREPARE(relocation, symbol)               \
  {                                                     \
    if (symbol != (asymbol *) NULL)                     \
      {                                                 \
        if (bfd_is_com_section (symbol->section))       \
          {                                             \
            relocation = 0;                             \
          }                                             \
        else                                            \
          {                                             \
            relocation = symbol->value;                 \
          }                                             \
      }                                                 \
  }
d1766 11
d1780 1
a1780 2
typedef struct relent_chain
{
d1782 2
a1783 4
  struct relent_chain *next;
}
arelent_chain;

d1810 1
a1810 1
/* Basic absolute relocations of N bits.  */
d1823 1
a1823 1
The 24-bit relocation is used in some Intel 960 configurations.  */
d1831 1
a1831 1
/* For ELF.  */
a1840 1
  BFD_RELOC_64_PLT_PCREL,
a1844 1
  BFD_RELOC_64_PLTOFF,
d1852 1
a1852 1
/* Relocations used by 68K ELF.  */
d1857 1
a1857 1
/* Linkage-table relative.  */
d1866 1
a1866 1
/* Absolute 8-bit relocation, but used to form an address like 0xFFnn.  */
d1874 1
a1874 1
displacement is used on the Alpha.  */
d1880 1
a1880 1
the target word.  These are used on the SPARC.  */
d1887 1
a1887 1
decided relatively late.  */
d1891 1
a1891 1
/* Reloc types used for i960/b.out.  */
d1895 1
a1895 1
relocation types already defined.  */
d1914 1
a1914 1
/* I think these are specific to SPARC a.out (e.g., Sun 4).  */
d1918 1
a1918 1
/* SPARC64 relocations  */
a1934 1
  BFD_RELOC_SPARC_PLT32,
d1943 1
a1943 1
/* SPARC little endian relocation  */
a1945 26
/* SPARC TLS relocations  */
  BFD_RELOC_SPARC_TLS_GD_HI22,
  BFD_RELOC_SPARC_TLS_GD_LO10,
  BFD_RELOC_SPARC_TLS_GD_ADD,
  BFD_RELOC_SPARC_TLS_GD_CALL,
  BFD_RELOC_SPARC_TLS_LDM_HI22,
  BFD_RELOC_SPARC_TLS_LDM_LO10,
  BFD_RELOC_SPARC_TLS_LDM_ADD,
  BFD_RELOC_SPARC_TLS_LDM_CALL,
  BFD_RELOC_SPARC_TLS_LDO_HIX22,
  BFD_RELOC_SPARC_TLS_LDO_LOX10,
  BFD_RELOC_SPARC_TLS_LDO_ADD,
  BFD_RELOC_SPARC_TLS_IE_HI22,
  BFD_RELOC_SPARC_TLS_IE_LO10,
  BFD_RELOC_SPARC_TLS_IE_LD,
  BFD_RELOC_SPARC_TLS_IE_LDX,
  BFD_RELOC_SPARC_TLS_IE_ADD,
  BFD_RELOC_SPARC_TLS_LE_HIX22,
  BFD_RELOC_SPARC_TLS_LE_LOX10,
  BFD_RELOC_SPARC_TLS_DTPMOD32,
  BFD_RELOC_SPARC_TLS_DTPMOD64,
  BFD_RELOC_SPARC_TLS_DTPOFF32,
  BFD_RELOC_SPARC_TLS_DTPOFF64,
  BFD_RELOC_SPARC_TLS_TPOFF32,
  BFD_RELOC_SPARC_TLS_TPOFF64,

d1951 1
a1951 1
the "ldah" instruction (which is at the address of this reloc).  */
d1957 1
a1957 1
reading, for convenience.  */
d1962 1
a1962 1
relocation.  */
d1987 3
a1989 1
3 - jsr (target of branch)  */
d1994 11
d2007 1
a2007 1
prediction logic which may be provided on some processors.  */
d2011 1
a2011 1
which is filled by the linker.  */
d2015 1
a2015 1
which is filled by the linker.  */
a2017 25
/* The GPREL_HI/LO relocations together form a 32-bit offset from the
GP register.  */
  BFD_RELOC_ALPHA_GPREL_HI16,
  BFD_RELOC_ALPHA_GPREL_LO16,

/* Like BFD_RELOC_23_PCREL_S2, except that the source and target must
share a common GP, and the target address is adjusted for
STO_ALPHA_STD_GPLOAD.  */
  BFD_RELOC_ALPHA_BRSGP,

/* Alpha thread-local storage relocations.  */
  BFD_RELOC_ALPHA_TLSGD,
  BFD_RELOC_ALPHA_TLSLDM,
  BFD_RELOC_ALPHA_DTPMOD64,
  BFD_RELOC_ALPHA_GOTDTPREL16,
  BFD_RELOC_ALPHA_DTPREL64,
  BFD_RELOC_ALPHA_DTPREL_HI16,
  BFD_RELOC_ALPHA_DTPREL_LO16,
  BFD_RELOC_ALPHA_DTPREL16,
  BFD_RELOC_ALPHA_GOTTPREL16,
  BFD_RELOC_ALPHA_TPREL64,
  BFD_RELOC_ALPHA_TPREL_HI16,
  BFD_RELOC_ALPHA_TPREL_LO16,
  BFD_RELOC_ALPHA_TPREL16,

d2019 1
a2019 1
simple reloc otherwise.  */
d2022 1
a2022 1
/* The MIPS16 jump instruction.  */
d2025 1
a2025 1
/* MIPS16 GP relative reloc.  */
d2028 1
a2028 1
/* High 16 bits of 32-bit value; simple reloc.  */
d2034 1
a2034 1
to compensate for the borrow when the low bits are added.  */
d2037 1
a2037 1
/* Low 16 bits.  */
d2040 1
a2040 1
/* Like BFD_RELOC_HI16_S, but PC relative.  */
d2043 1
a2043 1
/* Like BFD_RELOC_LO16, but PC relative.  */
d2046 4
a2049 1
/* Relocation against a MIPS literal section.  */
d2052 1
a2052 1
/* MIPS ELF relocations.  */
d2055 1
a2075 11
/* Fujitsu Frv Relocations.  */
  BFD_RELOC_FRV_LABEL16,
  BFD_RELOC_FRV_LABEL24,
  BFD_RELOC_FRV_LO16,
  BFD_RELOC_FRV_HI16,
  BFD_RELOC_FRV_GPREL12,
  BFD_RELOC_FRV_GPRELU12,
  BFD_RELOC_FRV_GPREL32,
  BFD_RELOC_FRV_GPRELHI,
  BFD_RELOC_FRV_GPRELLO,

d2077 1
a2077 1
/* i386/elf relocations  */
a2085 12
  BFD_RELOC_386_TLS_TPOFF,
  BFD_RELOC_386_TLS_IE,
  BFD_RELOC_386_TLS_GOTIE,
  BFD_RELOC_386_TLS_LE,
  BFD_RELOC_386_TLS_GD,
  BFD_RELOC_386_TLS_LDM,
  BFD_RELOC_386_TLS_LDO_32,
  BFD_RELOC_386_TLS_IE_32,
  BFD_RELOC_386_TLS_LE_32,
  BFD_RELOC_386_TLS_DTPMOD32,
  BFD_RELOC_386_TLS_DTPOFF32,
  BFD_RELOC_386_TLS_TPOFF32,
d2087 1
a2087 1
/* x86-64/elf relocations  */
a2095 8
  BFD_RELOC_X86_64_DTPMOD64,
  BFD_RELOC_X86_64_DTPOFF64,
  BFD_RELOC_X86_64_TPOFF64,
  BFD_RELOC_X86_64_TLSGD,
  BFD_RELOC_X86_64_TLSLD,
  BFD_RELOC_X86_64_DTPOFF32,
  BFD_RELOC_X86_64_GOTTPOFF,
  BFD_RELOC_X86_64_TPOFF32,
d2097 1
a2097 1
/* ns32k relocations  */
d2111 1
a2111 5
/* PDP11 relocations  */
  BFD_RELOC_PDP11_DISP_8_PCREL,
  BFD_RELOC_PDP11_DISP_6_PCREL,

/* Picojava relocs.  Not all of these appear in object files.  */
d2119 1
a2119 1
/* Power(rs6000) and PowerPC relocations.  */
a2149 65
  BFD_RELOC_PPC64_HIGHER,
  BFD_RELOC_PPC64_HIGHER_S,
  BFD_RELOC_PPC64_HIGHEST,
  BFD_RELOC_PPC64_HIGHEST_S,
  BFD_RELOC_PPC64_TOC16_LO,
  BFD_RELOC_PPC64_TOC16_HI,
  BFD_RELOC_PPC64_TOC16_HA,
  BFD_RELOC_PPC64_TOC,
  BFD_RELOC_PPC64_PLTGOT16,
  BFD_RELOC_PPC64_PLTGOT16_LO,
  BFD_RELOC_PPC64_PLTGOT16_HI,
  BFD_RELOC_PPC64_PLTGOT16_HA,
  BFD_RELOC_PPC64_ADDR16_DS,
  BFD_RELOC_PPC64_ADDR16_LO_DS,
  BFD_RELOC_PPC64_GOT16_DS,
  BFD_RELOC_PPC64_GOT16_LO_DS,
  BFD_RELOC_PPC64_PLT16_LO_DS,
  BFD_RELOC_PPC64_SECTOFF_DS,
  BFD_RELOC_PPC64_SECTOFF_LO_DS,
  BFD_RELOC_PPC64_TOC16_DS,
  BFD_RELOC_PPC64_TOC16_LO_DS,
  BFD_RELOC_PPC64_PLTGOT16_DS,
  BFD_RELOC_PPC64_PLTGOT16_LO_DS,

/* PowerPC and PowerPC64 thread-local storage relocations.  */
  BFD_RELOC_PPC_TLS,
  BFD_RELOC_PPC_DTPMOD,
  BFD_RELOC_PPC_TPREL16,
  BFD_RELOC_PPC_TPREL16_LO,
  BFD_RELOC_PPC_TPREL16_HI,
  BFD_RELOC_PPC_TPREL16_HA,
  BFD_RELOC_PPC_TPREL,
  BFD_RELOC_PPC_DTPREL16,
  BFD_RELOC_PPC_DTPREL16_LO,
  BFD_RELOC_PPC_DTPREL16_HI,
  BFD_RELOC_PPC_DTPREL16_HA,
  BFD_RELOC_PPC_DTPREL,
  BFD_RELOC_PPC_GOT_TLSGD16,
  BFD_RELOC_PPC_GOT_TLSGD16_LO,
  BFD_RELOC_PPC_GOT_TLSGD16_HI,
  BFD_RELOC_PPC_GOT_TLSGD16_HA,
  BFD_RELOC_PPC_GOT_TLSLD16,
  BFD_RELOC_PPC_GOT_TLSLD16_LO,
  BFD_RELOC_PPC_GOT_TLSLD16_HI,
  BFD_RELOC_PPC_GOT_TLSLD16_HA,
  BFD_RELOC_PPC_GOT_TPREL16,
  BFD_RELOC_PPC_GOT_TPREL16_LO,
  BFD_RELOC_PPC_GOT_TPREL16_HI,
  BFD_RELOC_PPC_GOT_TPREL16_HA,
  BFD_RELOC_PPC_GOT_DTPREL16,
  BFD_RELOC_PPC_GOT_DTPREL16_LO,
  BFD_RELOC_PPC_GOT_DTPREL16_HI,
  BFD_RELOC_PPC_GOT_DTPREL16_HA,
  BFD_RELOC_PPC64_TPREL16_DS,
  BFD_RELOC_PPC64_TPREL16_LO_DS,
  BFD_RELOC_PPC64_TPREL16_HIGHER,
  BFD_RELOC_PPC64_TPREL16_HIGHERA,
  BFD_RELOC_PPC64_TPREL16_HIGHEST,
  BFD_RELOC_PPC64_TPREL16_HIGHESTA,
  BFD_RELOC_PPC64_DTPREL16_DS,
  BFD_RELOC_PPC64_DTPREL16_LO_DS,
  BFD_RELOC_PPC64_DTPREL16_HIGHER,
  BFD_RELOC_PPC64_DTPREL16_HIGHERA,
  BFD_RELOC_PPC64_DTPREL16_HIGHEST,
  BFD_RELOC_PPC64_DTPREL16_HIGHESTA,
d2151 1
a2151 1
/* IBM 370/390 relocations  */
d2156 1
a2156 1
It generally does map to one of the other relocation types.  */
d2160 1
a2160 1
not stored in the instruction.  */
d2165 1
a2165 1
field in the instruction.  */
d2170 1
a2170 1
field in the instruction.  */
d2174 1
a2174 1
(at present) written to any object files.  */
a2181 1
  BFD_RELOC_ARM_CP_OFF_IMM_S2,
d2202 1
a2202 1
/* Renesas / SuperH SH relocs.  Not all of these appear in object files.  */
a2227 57
  BFD_RELOC_SH_GOT_LOW16,
  BFD_RELOC_SH_GOT_MEDLOW16,
  BFD_RELOC_SH_GOT_MEDHI16,
  BFD_RELOC_SH_GOT_HI16,
  BFD_RELOC_SH_GOTPLT_LOW16,
  BFD_RELOC_SH_GOTPLT_MEDLOW16,
  BFD_RELOC_SH_GOTPLT_MEDHI16,
  BFD_RELOC_SH_GOTPLT_HI16,
  BFD_RELOC_SH_PLT_LOW16,
  BFD_RELOC_SH_PLT_MEDLOW16,
  BFD_RELOC_SH_PLT_MEDHI16,
  BFD_RELOC_SH_PLT_HI16,
  BFD_RELOC_SH_GOTOFF_LOW16,
  BFD_RELOC_SH_GOTOFF_MEDLOW16,
  BFD_RELOC_SH_GOTOFF_MEDHI16,
  BFD_RELOC_SH_GOTOFF_HI16,
  BFD_RELOC_SH_GOTPC_LOW16,
  BFD_RELOC_SH_GOTPC_MEDLOW16,
  BFD_RELOC_SH_GOTPC_MEDHI16,
  BFD_RELOC_SH_GOTPC_HI16,
  BFD_RELOC_SH_COPY64,
  BFD_RELOC_SH_GLOB_DAT64,
  BFD_RELOC_SH_JMP_SLOT64,
  BFD_RELOC_SH_RELATIVE64,
  BFD_RELOC_SH_GOT10BY4,
  BFD_RELOC_SH_GOT10BY8,
  BFD_RELOC_SH_GOTPLT10BY4,
  BFD_RELOC_SH_GOTPLT10BY8,
  BFD_RELOC_SH_GOTPLT32,
  BFD_RELOC_SH_SHMEDIA_CODE,
  BFD_RELOC_SH_IMMU5,
  BFD_RELOC_SH_IMMS6,
  BFD_RELOC_SH_IMMS6BY32,
  BFD_RELOC_SH_IMMU6,
  BFD_RELOC_SH_IMMS10,
  BFD_RELOC_SH_IMMS10BY2,
  BFD_RELOC_SH_IMMS10BY4,
  BFD_RELOC_SH_IMMS10BY8,
  BFD_RELOC_SH_IMMS16,
  BFD_RELOC_SH_IMMU16,
  BFD_RELOC_SH_IMM_LOW16,
  BFD_RELOC_SH_IMM_LOW16_PCREL,
  BFD_RELOC_SH_IMM_MEDLOW16,
  BFD_RELOC_SH_IMM_MEDLOW16_PCREL,
  BFD_RELOC_SH_IMM_MEDHI16,
  BFD_RELOC_SH_IMM_MEDHI16_PCREL,
  BFD_RELOC_SH_IMM_HI16,
  BFD_RELOC_SH_IMM_HI16_PCREL,
  BFD_RELOC_SH_PT_16,
  BFD_RELOC_SH_TLS_GD_32,
  BFD_RELOC_SH_TLS_LD_32,
  BFD_RELOC_SH_TLS_LDO_32,
  BFD_RELOC_SH_TLS_IE_32,
  BFD_RELOC_SH_TLS_LE_32,
  BFD_RELOC_SH_TLS_DTPMOD32,
  BFD_RELOC_SH_TLS_DTPOFF32,
  BFD_RELOC_SH_TLS_TPOFF32,
d2230 1
a2230 1
be zero and is not stored in the instruction.  */
d2238 1
a2238 1
through 7 of the instruction.  */
d2243 1
a2243 1
through 0.  */
d2248 1
a2248 1
assumed to be 0.  */
d2255 1
a2255 1
shifted left 15 bits.  */
d2259 1
a2259 1
assumed to be 0.  */
d2263 1
a2263 1
assumed to be 0.  */
d2267 1
a2267 1
This is a 6-bit absolute reloc.  */
d2271 1
a2271 1
the right 3 bits assumed to be 0.  */
d2277 1
a2277 1
of the container.  */
d2281 1
a2281 1
right 3 bitsassumed to be 0.  */
d2285 1
a2285 1
the right 3 bits assumed to be 0.  */
d2291 1
a2291 1
of the container.  */
d2295 1
a2295 1
the right 3 bits assumed to be 0.  */
d2299 1
a2299 1
the right 3 bits assumed to be 0.  */
d2305 1
a2305 1
of the container.  */
d2308 1
a2308 1
/* This is a 32-bit absolute reloc.  */
d2311 1
a2311 1
/* This is a 32-bit pc-relative reloc.  */
d2314 2
a2315 11
/* DLX relocs  */
  BFD_RELOC_DLX_HI16_S,

/* DLX relocs  */
  BFD_RELOC_DLX_LO16,

/* DLX relocs  */
  BFD_RELOC_DLX_JMP26,

/* Renesas M32R (formerly Mitsubishi M32R) relocs.
This is a 24 bit absolute address.  */
d2318 1
a2318 1
/* This is a 10-bit pc-relative reloc with the right 2 bits assumed to be 0.  */
d2321 1
a2321 1
/* This is an 18-bit reloc with the right 2 bits assumed to be 0.  */
d2324 1
a2324 1
/* This is a 26-bit reloc with the right 2 bits assumed to be 0.  */
d2328 1
a2328 1
used when the lower 16 bits are treated as unsigned.  */
d2332 1
a2332 1
used when the lower 16 bits are treated as signed.  */
d2335 1
a2335 1
/* This is a 16-bit reloc containing the lower 16 bits of an address.  */
d2339 1
a2339 1
add3, load, and store instructions.  */
d2342 1
a2342 1
/* This is a 9-bit reloc  */
d2345 1
a2345 1
/* This is a 22-bit reloc  */
d2348 1
a2348 1
/* This is a 16 bit offset from the short data area pointer.  */
d2352 1
a2352 1
short data area pointer.  */
d2355 1
a2355 1
/* This is a 16 bit offset from the zero data area pointer.  */
d2359 1
a2359 1
zero data area pointer.  */
d2363 1
a2363 1
tiny data area pointer.  */
d2367 1
a2367 1
data area pointer.  */
d2370 1
a2370 1
/* This is a 7 bit offset from the tiny data area pointer.  */
d2373 1
a2373 1
/* This is a 16 bit offset from the tiny data area pointer.  */
d2377 1
a2377 1
data area pointer.  */
d2380 1
a2380 1
/* This is a 4 bit offset from the tiny data area pointer.  */
d2384 1
a2384 1
bits placed non-contigously in the instruction.  */
d2388 1
a2388 1
bits placed non-contigously in the instruction.  */
d2391 1
a2391 1
/* This is a 6 bit offset from the call table base pointer.  */
d2394 1
a2394 1
/* This is a 16 bit offset from the call table base pointer.  */
a2396 8
/* Used for relaxing indirect function calls.  */
  BFD_RELOC_V850_LONGCALL,

/* Used for relaxing indirect jumps.  */
  BFD_RELOC_V850_LONGJUMP,

/* Used to maintain alignment whilst relaxing.  */
  BFD_RELOC_V850_ALIGN,
d2399 1
a2399 1
instruction.  */
d2403 1
a2403 1
instruction.  */
d2408 1
a2408 1
significant 8 bits of the opcode.  */
d2413 1
a2413 1
significant 7 bits of the opcode.  */
d2418 1
a2418 1
significant 9 bits of the opcode.  */
d2421 1
a2421 1
/* This is an extended address 23-bit reloc for the tms320c54x.  */
d2426 1
a2426 1
the opcode.  */
d2431 1
a2431 1
the opcode.  */
d2434 1
a2434 1
/* This is a 48 bit reloc for the FR30 that stores 32 bits.  */
d2438 1
a2438 1
two sections.  */
d2442 1
a2442 1
4 bits.  */
d2446 1
a2446 1
into 8 bits.  */
d2450 1
a2450 1
into 8 bits.  */
d2454 1
a2454 1
into 8 bits.  */
d2458 1
a2458 1
short offset into 8 bits.  */
d2462 1
a2462 1
short offset into 11 bits.  */
d2465 1
a2465 1
/* Motorola Mcore relocations.  */
a2472 48
/* These are relocations for the GETA instruction.  */
  BFD_RELOC_MMIX_GETA,
  BFD_RELOC_MMIX_GETA_1,
  BFD_RELOC_MMIX_GETA_2,
  BFD_RELOC_MMIX_GETA_3,

/* These are relocations for a conditional branch instruction.  */
  BFD_RELOC_MMIX_CBRANCH,
  BFD_RELOC_MMIX_CBRANCH_J,
  BFD_RELOC_MMIX_CBRANCH_1,
  BFD_RELOC_MMIX_CBRANCH_2,
  BFD_RELOC_MMIX_CBRANCH_3,

/* These are relocations for the PUSHJ instruction.  */
  BFD_RELOC_MMIX_PUSHJ,
  BFD_RELOC_MMIX_PUSHJ_1,
  BFD_RELOC_MMIX_PUSHJ_2,
  BFD_RELOC_MMIX_PUSHJ_3,

/* These are relocations for the JMP instruction.  */
  BFD_RELOC_MMIX_JMP,
  BFD_RELOC_MMIX_JMP_1,
  BFD_RELOC_MMIX_JMP_2,
  BFD_RELOC_MMIX_JMP_3,

/* This is a relocation for a relative address as in a GETA instruction or
a branch.  */
  BFD_RELOC_MMIX_ADDR19,

/* This is a relocation for a relative address as in a JMP instruction.  */
  BFD_RELOC_MMIX_ADDR27,

/* This is a relocation for an instruction field that may be a general
register or a value 0..255.  */
  BFD_RELOC_MMIX_REG_OR_BYTE,

/* This is a relocation for an instruction field that may be a general
register.  */
  BFD_RELOC_MMIX_REG,

/* This is a relocation for two instruction fields holding a register and
an offset, the equivalent of the relocation.  */
  BFD_RELOC_MMIX_BASE_PLUS_OFFSET,

/* This relocation is an assertion that the expression is not allocated as
a global register.  It does not modify contents.  */
  BFD_RELOC_MMIX_LOCAL,

d2474 1
a2474 1
short offset into 7 bits.  */
d2478 1
a2478 1
short offset into 12 bits.  */
d2482 1
a2482 1
program memory address) into 16 bits.  */
d2486 1
a2486 1
data memory address) into 8 bit immediate value of LDI insn.  */
d2490 1
a2490 1
of data memory address) into 8 bit immediate value of LDI insn.  */
d2494 1
a2494 1
of program memory address) into 8 bit immediate value of LDI insn.  */
d2498 1
a2498 1
(usually data memory address) into 8 bit immediate value of SUBI insn.  */
d2503 1
a2503 1
SUBI insn.  */
d2508 1
a2508 1
of LDI or SUBI insn.  */
d2512 1
a2512 1
command address) into 8 bit immediate value of LDI insn.  */
d2516 1
a2516 1
of command address) into 8 bit immediate value of LDI insn.  */
d2520 1
a2520 1
of command address) into 8 bit immediate value of LDI insn.  */
d2524 1
a2524 1
(usually command address) into 8 bit immediate value of SUBI insn.  */
d2529 1
a2529 1
of SUBI insn.  */
d2534 1
a2534 1
value of SUBI insn.  */
d2538 1
a2538 1
into 22 bits.  */
a2540 134
/* Direct 12 bit.  */
  BFD_RELOC_390_12,

/* 12 bit GOT offset.  */
  BFD_RELOC_390_GOT12,

/* 32 bit PC relative PLT address.  */
  BFD_RELOC_390_PLT32,

/* Copy symbol at runtime.  */
  BFD_RELOC_390_COPY,

/* Create GOT entry.  */
  BFD_RELOC_390_GLOB_DAT,

/* Create PLT entry.  */
  BFD_RELOC_390_JMP_SLOT,

/* Adjust by program base.  */
  BFD_RELOC_390_RELATIVE,

/* 32 bit PC relative offset to GOT.  */
  BFD_RELOC_390_GOTPC,

/* 16 bit GOT offset.  */
  BFD_RELOC_390_GOT16,

/* PC relative 16 bit shifted by 1.  */
  BFD_RELOC_390_PC16DBL,

/* 16 bit PC rel. PLT shifted by 1.  */
  BFD_RELOC_390_PLT16DBL,

/* PC relative 32 bit shifted by 1.  */
  BFD_RELOC_390_PC32DBL,

/* 32 bit PC rel. PLT shifted by 1.  */
  BFD_RELOC_390_PLT32DBL,

/* 32 bit PC rel. GOT shifted by 1.  */
  BFD_RELOC_390_GOTPCDBL,

/* 64 bit GOT offset.  */
  BFD_RELOC_390_GOT64,

/* 64 bit PC relative PLT address.  */
  BFD_RELOC_390_PLT64,

/* 32 bit rel. offset to GOT entry.  */
  BFD_RELOC_390_GOTENT,

/* 64 bit offset to GOT.  */
  BFD_RELOC_390_GOTOFF64,

/* 12-bit offset to symbol-entry within GOT, with PLT handling.  */
  BFD_RELOC_390_GOTPLT12,

/* 16-bit offset to symbol-entry within GOT, with PLT handling.  */
  BFD_RELOC_390_GOTPLT16,

/* 32-bit offset to symbol-entry within GOT, with PLT handling.  */
  BFD_RELOC_390_GOTPLT32,

/* 64-bit offset to symbol-entry within GOT, with PLT handling.  */
  BFD_RELOC_390_GOTPLT64,

/* 32-bit rel. offset to symbol-entry within GOT, with PLT handling.  */
  BFD_RELOC_390_GOTPLTENT,

/* 16-bit rel. offset from the GOT to a PLT entry.  */
  BFD_RELOC_390_PLTOFF16,

/* 32-bit rel. offset from the GOT to a PLT entry.  */
  BFD_RELOC_390_PLTOFF32,

/* 64-bit rel. offset from the GOT to a PLT entry.  */
  BFD_RELOC_390_PLTOFF64,

/* s390 tls relocations.  */
  BFD_RELOC_390_TLS_LOAD,
  BFD_RELOC_390_TLS_GDCALL,
  BFD_RELOC_390_TLS_LDCALL,
  BFD_RELOC_390_TLS_GD32,
  BFD_RELOC_390_TLS_GD64,
  BFD_RELOC_390_TLS_GOTIE12,
  BFD_RELOC_390_TLS_GOTIE32,
  BFD_RELOC_390_TLS_GOTIE64,
  BFD_RELOC_390_TLS_LDM32,
  BFD_RELOC_390_TLS_LDM64,
  BFD_RELOC_390_TLS_IE32,
  BFD_RELOC_390_TLS_IE64,
  BFD_RELOC_390_TLS_IEENT,
  BFD_RELOC_390_TLS_LE32,
  BFD_RELOC_390_TLS_LE64,
  BFD_RELOC_390_TLS_LDO32,
  BFD_RELOC_390_TLS_LDO64,
  BFD_RELOC_390_TLS_DTPMOD,
  BFD_RELOC_390_TLS_DTPOFF,
  BFD_RELOC_390_TLS_TPOFF,

/* Scenix IP2K - 9-bit register number / data address  */
  BFD_RELOC_IP2K_FR9,

/* Scenix IP2K - 4-bit register/data bank number  */
  BFD_RELOC_IP2K_BANK,

/* Scenix IP2K - low 13 bits of instruction word address  */
  BFD_RELOC_IP2K_ADDR16CJP,

/* Scenix IP2K - high 3 bits of instruction word address  */
  BFD_RELOC_IP2K_PAGE3,

/* Scenix IP2K - ext/low/high 8 bits of data address  */
  BFD_RELOC_IP2K_LO8DATA,
  BFD_RELOC_IP2K_HI8DATA,
  BFD_RELOC_IP2K_EX8DATA,

/* Scenix IP2K - low/high 8 bits of instruction word address  */
  BFD_RELOC_IP2K_LO8INSN,
  BFD_RELOC_IP2K_HI8INSN,

/* Scenix IP2K - even/odd PC modifier to modify snb pcl.0  */
  BFD_RELOC_IP2K_PC_SKIP,

/* Scenix IP2K - 16 bit word address in text section.  */
  BFD_RELOC_IP2K_TEXT,

/* Scenix IP2K - 7-bit sp or dp offset  */
  BFD_RELOC_IP2K_FR_OFFSET,

/* Scenix VPE4K coprocessor - data/insn-space addressing  */
  BFD_RELOC_VPE4KMATH_DATA,
  BFD_RELOC_VPE4KMATH_INSN,

d2557 1
a2557 1
this offset in the reloc's section offset.  */
d2561 1
a2561 1
/* Intel IA64 Relocations.  */
a2598 2
  BFD_RELOC_IA64_LTOFF_FPTR32MSB,
  BFD_RELOC_IA64_LTOFF_FPTR32LSB,
a2619 3
  BFD_RELOC_IA64_LTOFF22X,
  BFD_RELOC_IA64_LDXMOV,
  BFD_RELOC_IA64_TPREL14,
a2620 1
  BFD_RELOC_IA64_TPREL64I,
d2623 3
a2625 12
  BFD_RELOC_IA64_LTOFF_TPREL22,
  BFD_RELOC_IA64_DTPMOD64MSB,
  BFD_RELOC_IA64_DTPMOD64LSB,
  BFD_RELOC_IA64_LTOFF_DTPMOD22,
  BFD_RELOC_IA64_DTPREL14,
  BFD_RELOC_IA64_DTPREL22,
  BFD_RELOC_IA64_DTPREL64I,
  BFD_RELOC_IA64_DTPREL32MSB,
  BFD_RELOC_IA64_DTPREL32LSB,
  BFD_RELOC_IA64_DTPREL64MSB,
  BFD_RELOC_IA64_DTPREL64LSB,
  BFD_RELOC_IA64_LTOFF_DTPREL22,
d2628 1
a2628 1
This is the 8 bit high part of an absolute address.  */
d2632 1
a2632 1
This is the 8 bit low part of an absolute address.  */
d2636 1
a2636 1
This is the 3 bit of a value.  */
a2638 31
/* Motorola 68HC11 reloc.
This reloc marks the beginning of a jump/call instruction.
It is used for linker relaxation to correctly identify beginning
of instruction and change some branchs to use PC-relative
addressing mode.  */
  BFD_RELOC_M68HC11_RL_JUMP,

/* Motorola 68HC11 reloc.
This reloc marks a group of several instructions that gcc generates
and for which the linker relaxation pass can modify and/or remove
some of them.  */
  BFD_RELOC_M68HC11_RL_GROUP,

/* Motorola 68HC11 reloc.
This is the 16-bit lower part of an address.  It is used for 'call'
instruction to specify the symbol address without any special
transformation (due to memory bank window).  */
  BFD_RELOC_M68HC11_LO16,

/* Motorola 68HC11 reloc.
This is a 8-bit reloc that specifies the page number of an address.
It is used by 'call' instruction to specify the page number of
the symbol.  */
  BFD_RELOC_M68HC11_PAGE,

/* Motorola 68HC11 reloc.
This is a 24-bit reloc that represents the address with a 16-bit
value and a 8-bit page number.  The symbol address is transformed
to follow the 16K memory bank of 68HC12 (seen as mapped in the window).  */
  BFD_RELOC_M68HC11_24,

d2640 1
a2640 1
(at present) written to any object files.  */
d2647 1
a2647 28
/* Relocs used in ELF shared libraries for CRIS.  */
  BFD_RELOC_CRIS_COPY,
  BFD_RELOC_CRIS_GLOB_DAT,
  BFD_RELOC_CRIS_JUMP_SLOT,
  BFD_RELOC_CRIS_RELATIVE,

/* 32-bit offset to symbol-entry within GOT.  */
  BFD_RELOC_CRIS_32_GOT,

/* 16-bit offset to symbol-entry within GOT.  */
  BFD_RELOC_CRIS_16_GOT,

/* 32-bit offset to symbol-entry within GOT, with PLT handling.  */
  BFD_RELOC_CRIS_32_GOTPLT,

/* 16-bit offset to symbol-entry within GOT, with PLT handling.  */
  BFD_RELOC_CRIS_16_GOTPLT,

/* 32-bit offset to symbol, relative to GOT.  */
  BFD_RELOC_CRIS_32_GOTREL,

/* 32-bit offset to symbol with PLT entry, relative to GOT.  */
  BFD_RELOC_CRIS_32_PLT_GOTREL,

/* 32-bit offset to symbol with PLT entry, relative to this relocation.  */
  BFD_RELOC_CRIS_32_PLT_PCREL,

/* Intel i860 Relocations.  */
a2679 66

/* OpenRISC Relocations.  */
  BFD_RELOC_OPENRISC_ABS_26,
  BFD_RELOC_OPENRISC_REL_26,

/* H8 elf Relocations.  */
  BFD_RELOC_H8_DIR16A8,
  BFD_RELOC_H8_DIR16R8,
  BFD_RELOC_H8_DIR24A8,
  BFD_RELOC_H8_DIR24R8,
  BFD_RELOC_H8_DIR32A16,

/* Sony Xstormy16 Relocations.  */
  BFD_RELOC_XSTORMY16_REL_12,
  BFD_RELOC_XSTORMY16_12,
  BFD_RELOC_XSTORMY16_24,
  BFD_RELOC_XSTORMY16_FPTR16,

/* Relocations used by VAX ELF.  */
  BFD_RELOC_VAX_GLOB_DAT,
  BFD_RELOC_VAX_JMP_SLOT,
  BFD_RELOC_VAX_RELATIVE,

/* msp430 specific relocation codes  */
  BFD_RELOC_MSP430_10_PCREL,
  BFD_RELOC_MSP430_16_PCREL,
  BFD_RELOC_MSP430_16,
  BFD_RELOC_MSP430_16_PCREL_BYTE,
  BFD_RELOC_MSP430_16_BYTE,

/* IQ2000 Relocations.  */
  BFD_RELOC_IQ2000_OFFSET_16,
  BFD_RELOC_IQ2000_OFFSET_21,
  BFD_RELOC_IQ2000_UHI16,

/* Special Xtensa relocation used only by PLT entries in ELF shared
objects to indicate that the runtime linker should set the value
to one of its own internal functions or data structures.  */
  BFD_RELOC_XTENSA_RTLD,

/* Xtensa relocations for ELF shared objects.  */
  BFD_RELOC_XTENSA_GLOB_DAT,
  BFD_RELOC_XTENSA_JMP_SLOT,
  BFD_RELOC_XTENSA_RELATIVE,

/* Xtensa relocation used in ELF object files for symbols that may require
PLT entries.  Otherwise, this is just a generic 32-bit relocation.  */
  BFD_RELOC_XTENSA_PLT,

/* Generic Xtensa relocations.  Only the operand number is encoded
in the relocation.  The details are determined by extracting the
instruction opcode.  */
  BFD_RELOC_XTENSA_OP0,
  BFD_RELOC_XTENSA_OP1,
  BFD_RELOC_XTENSA_OP2,

/* Xtensa relocation to mark that the assembler expanded the 
instructions from an original target.  The expansion size is
encoded in the reloc size.  */
  BFD_RELOC_XTENSA_ASM_EXPAND,

/* Xtensa relocation to mark that the linker should simplify 
assembler-expanded instructions.  This is commonly used 
internally by the linker after analysis of a 
BFD_RELOC_XTENSA_ASM_EXPAND.  */
  BFD_RELOC_XTENSA_ASM_SIMPLIFY,
a2687 1
/* Extracted from syms.c.  */
d2691 20
a2710 10
  /* A pointer to the BFD which owns the symbol. This information
     is necessary so that a back end can work out what additional
     information (invisible to the application writer) is carried
     with the symbol.

     This field is *almost* redundant, since you can use section->owner
     instead, except that some symbols point to the global sections
     bfd_{abs,com,und}_section.  This could be fixed by making
     these globals be per-bfd (or per-target-flavor).  FIXME.  */
  struct bfd *the_bfd; /* Use bfd_asymbol_bfd(sym) to access this field.  */
d2712 1
a2712 8
  /* The text of the symbol. The name is left alone, and not copied; the
     application may not alter it.  */
  const char *name;

  /* The value of the symbol.  This really should be a union of a
     numeric value with a pointer, since some flags indicate that
     a pointer to another symbol is stored here.  */
  symvalue value;
a2713 1
  /* Attributes of a symbol.  */
d2716 2
a2717 2
  /* The symbol has local scope; <<static>> in <<C>>. The value
     is the offset into the section of the data.  */
d2720 2
a2721 2
  /* The symbol has global scope; initialized data in <<C>>. The
     value is the offset into the section of the data.  */
d2724 7
a2730 7
  /* The symbol has global scope and is exported. The value is
     the offset into the section of the data.  */
#define BSF_EXPORT     BSF_GLOBAL /* No real difference.  */

  /* A normal C symbol would be one of:
     <<BSF_LOCAL>>, <<BSF_FORT_COMM>>,  <<BSF_UNDEFINED>> or
     <<BSF_GLOBAL>>.  */
d2732 2
a2733 2
  /* The symbol is a debugging record. The value has an arbitary
     meaning, unless BSF_DEBUGGING_RELOC is also set.  */
d2736 2
a2737 2
  /* The symbol denotes a function entry point.  Used in ELF,
     perhaps others someday.  */
d2740 1
a2740 1
  /* Used by the linker.  */
d2744 2
a2745 2
  /* A weak global symbol, overridable without warnings by
     a regular global symbol of the same name.  */
d2748 2
a2749 2
  /* This symbol was created to point to a section, e.g. ELF's
     STT_SECTION symbols.  */
d2752 2
a2753 2
  /* The symbol used to be a common symbol, but now it is
     allocated.  */
d2756 1
a2756 1
  /* The default value for common data.  */
d2759 6
a2764 5
  /* In some files the type of a symbol sometimes alters its
     location in an output file - ie in coff a <<ISFCN>> symbol
     which is also <<C_EXT>> symbol appears where it was
     declared and not at the end of a section.  This bit is set
     by the target BFD part to convey this information.  */
d2767 1
a2767 1
  /* Signal that the symbol is the label of constructor section.  */
d2770 4
a2773 4
  /* Signal that the symbol is a warning symbol.  The name is a
     warning.  The name of the next symbol is the one to warn about;
     if a reference is made to a symbol with the same name as the next
     symbol, a warning is issued by the linker.  */
d2776 2
a2777 2
  /* Signal that the symbol is indirect.  This symbol is an indirect
     pointer to the symbol with the same name as the next symbol.  */
d2780 2
a2781 2
  /* BSF_FILE marks symbols that contain a file name.  This is used
     for ELF STT_FILE symbols.  */
d2784 1
a2784 1
  /* Symbol is from dynamic linking information.  */
d2787 2
a2788 2
  /* The symbol denotes a data object.  Used in ELF, and perhaps
     others someday.  */
d2791 3
a2793 3
  /* This symbol is a debugging symbol.  The value is the offset
     into the section of the data.  BSF_DEBUGGING should be set
     as well.  */
a2795 3
  /* This symbol is thread local.  Used in ELF.  */
#define BSF_THREAD_LOCAL  0x40000

d2798 3
a2800 3
  /* A pointer to the section to which this symbol is
     relative.  This will always be non NULL, there are special
     sections for undefined and absolute symbols.  */
d2803 1
a2803 1
  /* Back end special data.  */
d2808 1
a2808 4
    }
  udata;
}
asymbol;
d2810 1
d2813 1
a2813 2

bfd_boolean
d2816 1
a2816 1
bfd_boolean
a2820 1

d2824 1
a2824 2

bfd_boolean
d2828 1
a2828 1
bfd_print_symbol_vandf PARAMS ((bfd *abfd, PTR file, asymbol *symbol));
a2831 4

asymbol *
_bfd_generic_make_empty_symbol PARAMS ((bfd *));

a2833 1

d2837 1
a2837 1
bfd_boolean
d2843 1
a2843 1
bfd_boolean
d2849 27
d2877 22
a2898 5
/* Extracted from bfd.c.  */
struct bfd
{
  /* A unique identifier of the BFD  */
  unsigned int id;
d2900 1
a2900 2
  /* The filename the application opened the BFD with.  */
  const char *filename;
d2902 1
a2902 2
  /* A pointer to the target jump table.  */
  const struct bfd_target *xvec;
d2904 1
a2904 35
  /* To avoid dragging too many header files into every file that
     includes `<<bfd.h>>', IOSTREAM has been declared as a "char *",
     and MTIME as a "long".  Their correct types, to which they
     are cast when used, are "FILE *" and "time_t".    The iostream
     is the result of an fopen on the filename.  However, if the
     BFD_IN_MEMORY flag is set, then iostream is actually a pointer
     to a bfd_in_memory struct.  */
  PTR iostream;

  /* Is the file descriptor being cached?  That is, can it be closed as
     needed, and re-opened when accessed later?  */
  bfd_boolean cacheable;

  /* Marks whether there was a default target specified when the
     BFD was opened. This is used to select which matching algorithm
     to use to choose the back end.  */
  bfd_boolean target_defaulted;

  /* The caching routines use these to maintain a
     least-recently-used list of BFDs.  */
  struct bfd *lru_prev, *lru_next;

  /* When a file is closed by the caching routines, BFD retains
     state information on the file here...  */
  ufile_ptr where;

  /* ... and here: (``once'' means at least once).  */
  bfd_boolean opened_once;

  /* Set if we have a locally maintained mtime value, rather than
     getting it from the file each time.  */
  bfd_boolean mtime_set;

  /* File modified time, if mtime_set is TRUE.  */
  long mtime;
d2906 1
a2906 2
  /* Reserved for an unimplemented file locking extension.  */
  int ifd;
d2908 1
a2908 2
  /* The format which belongs to the BFD. (object, core, etc.)  */
  bfd_format format;
d2910 4
a2913 9
  /* The direction with which the BFD was opened.  */
  enum bfd_direction
    {
      no_direction = 0,
      read_direction = 1,
      write_direction = 2,
      both_direction = 3
    }
  direction;
d2915 1
a2915 2
  /* Format_specific flags.  */
  flagword flags;
d2917 1
a2917 4
  /* Currently my_archive is tested before adding origin to
     anything. I believe that this can become always an add of
     origin, with origin set to 0 for non archive files.  */
  ufile_ptr origin;
d2919 3
a2921 3
  /* Remember when output has begun, to stop strange things
     from happening.  */
  bfd_boolean output_has_begun;
d2923 1
a2923 2
  /* A hash table for section names.  */
  struct bfd_hash_table section_htab;
d2925 3
a2927 2
  /* Pointer to linked list of sections.  */
  struct sec *sections;
d2929 2
a2930 2
  /* The place where we add to the section list.  */
  struct sec **section_tail;
d2932 2
a2933 2
  /* The number of sections.  */
  unsigned int section_count;
d2935 3
a2937 3
  /* Stuff only useful for object files:
     The start address.  */
  bfd_vma start_address;
d2939 2
a2940 2
  /* Used for input and output.  */
  unsigned int symcount;
d2942 2
a2943 2
  /* Symbol table for output BFD (with symcount entries).  */
  struct symbol_cache_entry  **outsymbols;
d2945 2
a2946 2
  /* Used for slurped dynamic symbol tables.  */
  unsigned int dynsymcount;
d2948 6
a2953 2
  /* Pointer to structure which contains architecture information.  */
  const struct bfd_arch_info *arch_info;
d2955 2
a2956 6
  /* Stuff only useful for archives.  */
  PTR arelt_data;
  struct bfd *my_archive;      /* The containing archive BFD.  */
  struct bfd *next;            /* The next BFD in the archive.  */
  struct bfd *archive_head;    /* The first BFD in the archive.  */
  bfd_boolean has_armap;
d2958 3
a2960 2
  /* A chain of BFD structures involved in a link.  */
  struct bfd *link_next;
d2962 1
a2962 3
  /* A field used by _bfd_generic_link_add_archive_symbols.  This will
     be used only for archive elements.  */
  int archive_pass;
d2964 2
a2965 3
  /* Used by the back end to hold private data.  */
  union
    {
a2981 1
      struct mmo_data_struct *mmo_data;
a2993 5
      struct mach_o_data_struct *mach_o_data;
      struct mach_o_fat_data_struct *mach_o_fat_data;
      struct bfd_pef_data_struct *pef_data;
      struct bfd_pef_xlib_data_struct *pef_xlib_data;
      struct bfd_sym_data_struct *sym_data;
d2995 1
a2995 2
    }
  tdata;
d2997 2
a2998 2
  /* Used by the application to hold private data.  */
  PTR usrdata;
d3003 1
a3003 1
  PTR memory;
a3011 1
  bfd_error_wrong_object_format,
d3027 1
a3027 2
}
bfd_error_type;
d3035 1
a3035 1
const char *
d3039 1
a3039 1
bfd_perror PARAMS ((const char *message));
a3051 3
const char *
bfd_archive_filename PARAMS ((bfd *));

d3062 3
a3064 1
bfd_set_reloc PARAMS ((bfd *abfd, asection *sec, arelent **rel, unsigned int count));
d3066 1
a3066 1
bfd_boolean
d3075 1
a3075 1
bfd_boolean
d3078 7
a3084 1
unsigned int
d3088 1
a3088 1
bfd_set_gp_size PARAMS ((bfd *abfd, unsigned int i));
d3091 1
a3091 1
bfd_scan_vma PARAMS ((const char *string, const char **end, int base));
d3093 1
a3093 1
bfd_boolean
d3099 1
a3099 1
bfd_boolean
d3105 1
a3105 1
bfd_boolean
d3109 2
a3110 1
     BFD_SEND (abfd, _bfd_set_private_flags, (abfd, flags))
d3112 1
a3112 1
       BFD_SEND (abfd, _bfd_sizeof_headers, (abfd, reloc))
d3115 1
a3115 2
       BFD_SEND (abfd, _bfd_find_nearest_line, \
                 (abfd, sec, syms, off, file, func, line))
d3117 1
d3119 1
a3119 1
       BFD_SEND (abfd, _bfd_debug_info_start, (abfd))
d3122 1
a3122 1
       BFD_SEND (abfd, _bfd_debug_info_end, (abfd))
d3125 2
a3126 1
       BFD_SEND (abfd, _bfd_debug_info_accumulate, (abfd, section))
d3129 1
a3129 1
       BFD_SEND (abfd, _bfd_stat_arch_elt,(abfd, stat))
d3132 1
a3132 1
       BFD_SEND (abfd, _bfd_update_armap_timestamp, (abfd))
d3135 1
a3135 1
       BFD_SEND ( abfd, _bfd_set_arch_mach, (abfd, arch, mach))
a3142 6
#define bfd_merge_sections(abfd, link_info) \
       BFD_SEND (abfd, _bfd_merge_sections, (abfd, link_info))

#define bfd_discard_group(abfd, sec) \
       BFD_SEND (abfd, _bfd_discard_group, (abfd, sec))

a3145 3
#define bfd_link_hash_table_free(abfd, hash) \
       BFD_SEND (abfd, _bfd_link_hash_table_free, (hash))

a3148 3
#define bfd_link_just_syms(sec, info) \
       BFD_SEND (abfd, _bfd_link_just_syms, (sec, info))

d3173 1
a3173 16
                 bfd_boolean, asymbol **));

bfd_boolean
bfd_alt_mach_code PARAMS ((bfd *abfd, int alternative));

struct bfd_preserve
{
  PTR marker;
  PTR tdata;
  flagword flags;
  const struct bfd_arch_info *arch_info;
  struct sec *sections;
  struct sec **section_tail;
  unsigned int section_count;
  struct bfd_hash_table section_htab;
};
a3174 10
bfd_boolean
bfd_preserve_save PARAMS ((bfd *, struct bfd_preserve *));

void
bfd_preserve_restore PARAMS ((bfd *, struct bfd_preserve *));

void
bfd_preserve_finish PARAMS ((bfd *, struct bfd_preserve *));

/* Extracted from archive.c.  */
d3178 1
a3178 1
bfd_boolean
d3184 1
a3184 2
/* Extracted from corefile.c.  */
const char *
d3190 1
a3190 1
bfd_boolean
a3192 1
/* Extracted from targets.c.  */
d3213 1
a3213 3

enum bfd_flavour
{
d3231 1
a3231 6
  bfd_target_evax_flavour,
  bfd_target_mmo_flavour,
  bfd_target_mach_o_flavour,
  bfd_target_pef_flavour,
  bfd_target_pef_xlib_flavour,
  bfd_target_sym_flavour
a3240 1
  /* Identifies the kind of target, e.g., SunOS4, Ultrix, etc.  */
a3241 3

 /* The "flavour" of a back end is a general indication about
    the contents of a file.  */
a3242 2

  /* The order of bytes within the data area of a file.  */
a3243 2

 /* The order of bytes within the header parts of a file.  */
a3244 3

  /* A mask of all the flags which an executable may have set -
     from the set <<BFD_NO_FLAGS>>, <<HAS_RELOC>>, ...<<D_PAGED>>.  */
a3245 3

 /* A mask of all the flags which a section may have set - from
    the set <<SEC_NO_FLAGS>>, <<SEC_ALLOC>>, ...<<SET_NEVER_LOAD>>.  */
a3246 3

 /* The character normally found at the front of a symbol.
    (if any), perhaps `_'.  */
a3247 2

 /* The pad character for file names within an archive header.  */
a3248 2

  /* The maximum number of characters in an archive header.  */
d3250 1
a3250 5

  /* Entries for byte swapping for data. These are different from the
     other entry points, since they don't take a BFD asthe first argument.
     Certain other handlers could do the same.  */
  bfd_vma        (*bfd_getx64) PARAMS ((const bfd_byte *));
d3252 2
a3253 2
  void           (*bfd_putx64) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_getx32) PARAMS ((const bfd_byte *));
d3255 2
a3256 2
  void           (*bfd_putx32) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_getx16) PARAMS ((const bfd_byte *));
d3258 2
a3259 4
  void           (*bfd_putx16) PARAMS ((bfd_vma, bfd_byte *));

  /* Byte swapping for the headers.  */
  bfd_vma        (*bfd_h_getx64) PARAMS ((const bfd_byte *));
d3261 2
a3262 2
  void           (*bfd_h_putx64) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_h_getx32) PARAMS ((const bfd_byte *));
d3264 2
a3265 2
  void           (*bfd_h_putx32) PARAMS ((bfd_vma, bfd_byte *));
  bfd_vma        (*bfd_h_getx16) PARAMS ((const bfd_byte *));
d3267 1
a3267 6
  void           (*bfd_h_putx16) PARAMS ((bfd_vma, bfd_byte *));

  /* Format dependent routines: these are vectors of entry points
     within the target vector structure, one for each format to check.  */

  /* Check the format of a file being read.  Return a <<bfd_target *>> or zero.  */
d3269 2
a3270 7

  /* Set the format of a file being written.  */
  bfd_boolean (*_bfd_set_format[bfd_type_end]) PARAMS ((bfd *));

  /* Write cached information into a file being written, at <<bfd_close>>.  */
  bfd_boolean (*_bfd_write_contents[bfd_type_end]) PARAMS ((bfd *));

d3273 6
a3278 6
#define BFD_JUMP_TABLE_GENERIC(NAME) \
CONCAT2 (NAME,_close_and_cleanup), \
CONCAT2 (NAME,_bfd_free_cached_info), \
CONCAT2 (NAME,_new_section_hook), \
CONCAT2 (NAME,_get_section_contents), \
CONCAT2 (NAME,_get_section_contents_in_window)
d3281 1
a3281 1
  bfd_boolean (*_close_and_cleanup) PARAMS ((bfd *));
d3283 1
a3283 1
  bfd_boolean (*_bfd_free_cached_info) PARAMS ((bfd *));
d3285 1
a3285 1
  bfd_boolean (*_new_section_hook) PARAMS ((bfd *, sec_ptr));
d3287 5
a3291 4
  bfd_boolean (*_bfd_get_section_contents)
    PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
  bfd_boolean (*_bfd_get_section_contents_in_window)
    PARAMS ((bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type));
d3294 7
a3300 7
#define BFD_JUMP_TABLE_COPY(NAME) \
CONCAT2 (NAME,_bfd_copy_private_bfd_data), \
CONCAT2 (NAME,_bfd_merge_private_bfd_data), \
CONCAT2 (NAME,_bfd_copy_private_section_data), \
CONCAT2 (NAME,_bfd_copy_private_symbol_data), \
CONCAT2 (NAME,_bfd_set_private_flags), \
CONCAT2 (NAME,_bfd_print_private_bfd_data) \
d3303 1
a3303 1
  bfd_boolean (*_bfd_copy_private_bfd_data) PARAMS ((bfd *, bfd *));
d3306 1
a3306 1
  bfd_boolean (*_bfd_merge_private_bfd_data) PARAMS ((bfd *, bfd *));
d3309 2
a3310 2
  bfd_boolean (*_bfd_copy_private_section_data)
    PARAMS ((bfd *, sec_ptr, bfd *, sec_ptr));
d3313 4
a3316 4
  bfd_boolean (*_bfd_copy_private_symbol_data)
    PARAMS ((bfd *, asymbol *, bfd *, asymbol *));
  /* Called to set private backend flags.  */
  bfd_boolean (*_bfd_set_private_flags) PARAMS ((bfd *, flagword));
d3318 2
a3319 2
  /* Called to print private BFD data.  */
  bfd_boolean (*_bfd_print_private_bfd_data) PARAMS ((bfd *, PTR));
d3322 7
a3328 7
#define BFD_JUMP_TABLE_CORE(NAME) \
CONCAT2 (NAME,_core_file_failing_command), \
CONCAT2 (NAME,_core_file_failing_signal), \
CONCAT2 (NAME,_core_file_matches_executable_p)
  char *      (*_core_file_failing_command) PARAMS ((bfd *));
  int         (*_core_file_failing_signal) PARAMS ((bfd *));
  bfd_boolean (*_core_file_matches_executable_p) PARAMS ((bfd *, bfd *));
d3331 23
a3353 20
#define BFD_JUMP_TABLE_ARCHIVE(NAME) \
CONCAT2 (NAME,_slurp_armap), \
CONCAT2 (NAME,_slurp_extended_name_table), \
CONCAT2 (NAME,_construct_extended_name_table), \
CONCAT2 (NAME,_truncate_arname), \
CONCAT2 (NAME,_write_armap), \
CONCAT2 (NAME,_read_ar_hdr), \
CONCAT2 (NAME,_openr_next_archived_file), \
CONCAT2 (NAME,_get_elt_at_index), \
CONCAT2 (NAME,_generic_stat_arch_elt), \
CONCAT2 (NAME,_update_armap_timestamp)
  bfd_boolean (*_bfd_slurp_armap) PARAMS ((bfd *));
  bfd_boolean (*_bfd_slurp_extended_name_table) PARAMS ((bfd *));
  bfd_boolean (*_bfd_construct_extended_name_table)
    PARAMS ((bfd *, char **, bfd_size_type *, const char **));
  void        (*_bfd_truncate_arname) PARAMS ((bfd *, const char *, char *));
  bfd_boolean (*write_armap)
    PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
  PTR         (*_bfd_read_ar_hdr_fn) PARAMS ((bfd *));
  bfd *       (*openr_next_archived_file) PARAMS ((bfd *, bfd *));
d3355 3
a3357 3
  bfd *       (*_bfd_get_elt_at_index) PARAMS ((bfd *, symindex));
  int         (*_bfd_stat_arch_elt) PARAMS ((bfd *, struct stat *));
  bfd_boolean (*_bfd_update_armap_timestamp) PARAMS ((bfd *));
d3360 20
a3379 19
#define BFD_JUMP_TABLE_SYMBOLS(NAME) \
CONCAT2 (NAME,_get_symtab_upper_bound), \
CONCAT2 (NAME,_get_symtab), \
CONCAT2 (NAME,_make_empty_symbol), \
CONCAT2 (NAME,_print_symbol), \
CONCAT2 (NAME,_get_symbol_info), \
CONCAT2 (NAME,_bfd_is_local_label_name), \
CONCAT2 (NAME,_get_lineno), \
CONCAT2 (NAME,_find_nearest_line), \
CONCAT2 (NAME,_bfd_make_debug_symbol), \
CONCAT2 (NAME,_read_minisymbols), \
CONCAT2 (NAME,_minisymbol_to_symbol)
  long        (*_bfd_get_symtab_upper_bound) PARAMS ((bfd *));
  long        (*_bfd_canonicalize_symtab) PARAMS ((bfd *,
                                                struct symbol_cache_entry **));
  struct symbol_cache_entry *
              (*_bfd_make_empty_symbol) PARAMS ((bfd *));
  void        (*_bfd_print_symbol)
    PARAMS ((bfd *, PTR, struct symbol_cache_entry *, bfd_print_symbol_type));
d3381 3
a3383 2
  void        (*_bfd_get_symbol_info)
    PARAMS ((bfd *, struct symbol_cache_entry *, symbol_info *));
d3385 1
a3385 1
  bfd_boolean (*_bfd_is_local_label_name) PARAMS ((bfd *, const char *));
d3387 5
a3391 4
  alent *     (*_get_lineno) PARAMS ((bfd *, struct symbol_cache_entry *));
  bfd_boolean (*_bfd_find_nearest_line)
    PARAMS ((bfd *, struct sec *, struct symbol_cache_entry **, bfd_vma,
             const char **, const char **, unsigned int *));
d3395 4
a3398 2
  asymbol *   (*_bfd_make_debug_symbol)
    PARAMS ((bfd *, void *, unsigned long size));
d3401 2
a3402 2
  long        (*_read_minisymbols)
    PARAMS ((bfd *, bfd_boolean, PTR *, unsigned int *));
d3405 2
a3406 2
  asymbol *   (*_minisymbol_to_symbol)
    PARAMS ((bfd *, bfd_boolean, const PTR, asymbol *));
d3409 7
a3415 7
#define BFD_JUMP_TABLE_RELOCS(NAME) \
CONCAT2 (NAME,_get_reloc_upper_bound), \
CONCAT2 (NAME,_canonicalize_reloc), \
CONCAT2 (NAME,_bfd_reloc_type_lookup)
  long        (*_get_reloc_upper_bound) PARAMS ((bfd *, sec_ptr));
  long        (*_bfd_canonicalize_reloc)
    PARAMS ((bfd *, sec_ptr, arelent **, struct symbol_cache_entry **));
d3418 2
a3419 1
              (*reloc_type_lookup) PARAMS ((bfd *, bfd_reloc_code_real_type));
d3422 7
a3428 7
#define BFD_JUMP_TABLE_WRITE(NAME) \
CONCAT2 (NAME,_set_arch_mach), \
CONCAT2 (NAME,_set_section_contents)
  bfd_boolean (*_bfd_set_arch_mach)
    PARAMS ((bfd *, enum bfd_architecture, unsigned long));
  bfd_boolean (*_bfd_set_section_contents)
    PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
d3431 14
a3444 17
#define BFD_JUMP_TABLE_LINK(NAME) \
CONCAT2 (NAME,_sizeof_headers), \
CONCAT2 (NAME,_bfd_get_relocated_section_contents), \
CONCAT2 (NAME,_bfd_relax_section), \
CONCAT2 (NAME,_bfd_link_hash_table_create), \
CONCAT2 (NAME,_bfd_link_hash_table_free), \
CONCAT2 (NAME,_bfd_link_add_symbols), \
CONCAT2 (NAME,_bfd_link_just_syms), \
CONCAT2 (NAME,_bfd_final_link), \
CONCAT2 (NAME,_bfd_link_split_section), \
CONCAT2 (NAME,_bfd_gc_sections), \
CONCAT2 (NAME,_bfd_merge_sections), \
CONCAT2 (NAME,_bfd_discard_group)
  int         (*_bfd_sizeof_headers) PARAMS ((bfd *, bfd_boolean));
  bfd_byte *  (*_bfd_get_relocated_section_contents)
    PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *,
             bfd_byte *, bfd_boolean, struct symbol_cache_entry **));
d3446 2
a3447 2
  bfd_boolean (*_bfd_relax_section)
    PARAMS ((bfd *, struct sec *, struct bfd_link_info *, bfd_boolean *));
d3451 1
a3451 6
  struct bfd_link_hash_table *
              (*_bfd_link_hash_table_create) PARAMS ((bfd *));

  /* Release the memory associated with the linker hash table.  */
  void        (*_bfd_link_hash_table_free)
    PARAMS ((struct bfd_link_hash_table *));
d3454 1
a3454 6
  bfd_boolean (*_bfd_link_add_symbols)
    PARAMS ((bfd *, struct bfd_link_info *));

  /* Indicate that we are only retrieving symbol values from this section.  */
  void        (*_bfd_link_just_syms)
    PARAMS ((asection *, struct bfd_link_info *));
d3458 1
a3458 1
  bfd_boolean (*_bfd_final_link) PARAMS ((bfd *, struct bfd_link_info *));
d3461 1
a3461 1
  bfd_boolean (*_bfd_link_split_section) PARAMS ((bfd *, struct sec *));
d3464 1
a3464 7
  bfd_boolean (*_bfd_gc_sections) PARAMS ((bfd *, struct bfd_link_info *));

  /* Attempt to merge SEC_MERGE sections.  */
  bfd_boolean (*_bfd_merge_sections) PARAMS ((bfd *, struct bfd_link_info *));

  /* Discard members of a group.  */
  bfd_boolean (*_bfd_discard_group) PARAMS ((bfd *, struct sec *));
d3467 7
a3473 7
#define BFD_JUMP_TABLE_DYNAMIC(NAME) \
CONCAT2 (NAME,_get_dynamic_symtab_upper_bound), \
CONCAT2 (NAME,_canonicalize_dynamic_symtab), \
CONCAT2 (NAME,_get_dynamic_reloc_upper_bound), \
CONCAT2 (NAME,_canonicalize_dynamic_reloc)
  /* Get the amount of memory required to hold the dynamic symbols.  */
  long        (*_bfd_get_dynamic_symtab_upper_bound) PARAMS ((bfd *));
d3475 1
a3475 1
  long        (*_bfd_canonicalize_dynamic_symtab)
d3478 1
a3478 1
  long        (*_bfd_get_dynamic_reloc_upper_bound) PARAMS ((bfd *));
d3480 1
a3480 1
  long        (*_bfd_canonicalize_dynamic_reloc)
d3483 2
a3484 2
  /* Opposite endian version of this target.  */
  const struct bfd_target * alternative_target;
d3486 1
a3486 3
  /* Data for use by back-end routines, which isn't
     generic enough to belong in this structure.  */
  PTR backend_data;
d3489 1
a3489 2

bfd_boolean
d3493 1
a3493 1
bfd_find_target PARAMS ((const char *target_name, bfd *abfd));
d3499 1
a3499 3
bfd_search_for_target PARAMS ((int (* search_func)
       (const bfd_target *, void *),
    void *));
d3501 1
a3501 2
/* Extracted from format.c.  */
bfd_boolean
d3504 2
a3505 3
bfd_boolean
bfd_check_format_matches PARAMS ((bfd *abfd, bfd_format format,
    char ***matching));
d3507 1
a3507 1
bfd_boolean
d3510 1
a3510 1
const char *
a3511 11

/* Extracted from linker.c.  */
bfd_boolean
bfd_link_split_section PARAMS ((bfd *abfd, asection *sec));

#define bfd_link_split_section(abfd, sec) \
       BFD_SEND (abfd, _bfd_link_split_section, (abfd, sec))

/* Extracted from simple.c.  */
bfd_byte *
bfd_simple_get_relocated_section_contents PARAMS ((bfd *abfd, asection *sec, bfd_byte *outbuf, asymbol **symbol_table));
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d11 1
a11 1
   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
a60 1
#define BFD_HOST_LONG_LONG @@BFD_HOST_LONG_LONG@@
a63 2
typedef BFD_HOST_64_BIT bfd_int64_t;
typedef BFD_HOST_U_64_BIT bfd_uint64_t;
d104 20
d171 15
a185 16
#ifndef BFD_HOST_64_BIT
/* Fall back on a 32 bit type.  The idea is to make these types always
   available for function return types, but in the case that
   BFD_HOST_64_BIT is undefined such a function should abort or
   otherwise signal an error.  */
typedef bfd_signed_vma bfd_int64_t;
typedef bfd_vma bfd_uint64_t;
#endif

/* An offset into a file.  BFD always uses the largest possible offset
   based on the build time availability of fseek, fseeko, or fseeko64.  */
typedef @@bfd_file_ptr@@ file_ptr;
typedef unsigned @@bfd_file_ptr@@ ufile_ptr;

extern void bfd_sprintf_vma (bfd *, char *, bfd_vma);
extern void bfd_fprintf_vma (bfd *, void *, bfd_vma);
d198 1
a198 1
  bfd_object,		/* Linker/assembler/compiler output.  */
d316 1
a316 1
    struct bfd_symbol *sym;	/* Function name.  */
d327 1
a327 1
typedef struct bfd_section *sec_ptr;
d371 2
a372 1
extern const char *bfd_get_stab_name (int);
d406 1
a406 1
    (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
d408 2
a409 2
     but we use void * to avoid requiring the inclusion of objalloc.h.  */
  void *memory;
d414 4
a417 4
  (struct bfd_hash_table *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
			       struct bfd_hash_table *,
			       const char *));
d421 5
a425 5
  (struct bfd_hash_table *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
			       struct bfd_hash_table *,
			       const char *),
   unsigned int size);
d429 1
a429 1
  (struct bfd_hash_table *);
d436 2
a437 2
  (struct bfd_hash_table *, const char *, bfd_boolean create,
   bfd_boolean copy);
d441 2
a442 2
  (struct bfd_hash_table *, struct bfd_hash_entry *old,
   struct bfd_hash_entry *nw);
d446 2
a447 1
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
d450 2
a451 2
extern void *bfd_hash_allocate
  (struct bfd_hash_table *, unsigned int);
d457 3
a459 3
  (struct bfd_hash_table *,
   bfd_boolean (*) (struct bfd_hash_entry *, void *),
   void *info);
d461 1
a461 1
#define COFF_SWAP_TABLE (void *) &bfd_coff_std_swap_table
d468 12
a479 6
extern bfd_size_type bfd_bread (void *, bfd_size_type, bfd *);
extern bfd_size_type bfd_bwrite (const void *, bfd_size_type, bfd *);
extern int bfd_seek (bfd *, file_ptr, int);
extern file_ptr bfd_tell (bfd *);
extern int bfd_flush (bfd *);
extern int bfd_stat (bfd *, struct stat *);
d497 2
a498 1
extern void warn_deprecated (const char *, const char *, int, const char *);
d537 1
a537 1
  (bfd *abfd);
d541 2
a542 2
  (bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
   bfd_boolean, bfd_boolean, unsigned int, struct bfd_section **);
d546 36
a581 18
bfd_uint64_t bfd_getb64 (const void *);
bfd_uint64_t bfd_getl64 (const void *);
bfd_int64_t bfd_getb_signed_64 (const void *);
bfd_int64_t bfd_getl_signed_64 (const void *);
bfd_vma bfd_getb32 (const void *);
bfd_vma bfd_getl32 (const void *);
bfd_signed_vma bfd_getb_signed_32 (const void *);
bfd_signed_vma bfd_getl_signed_32 (const void *);
bfd_vma bfd_getb16 (const void *);
bfd_vma bfd_getl16 (const void *);
bfd_signed_vma bfd_getb_signed_16 (const void *);
bfd_signed_vma bfd_getl_signed_16 (const void *);
void bfd_putb64 (bfd_uint64_t, void *);
void bfd_putl64 (bfd_uint64_t, void *);
void bfd_putb32 (bfd_vma, void *);
void bfd_putl32 (bfd_vma, void *);
void bfd_putb16 (bfd_vma, void *);
void bfd_putl16 (bfd_vma, void *);
d585 4
a588 2
bfd_uint64_t bfd_get_bits (const void *, int, bfd_boolean);
void bfd_put_bits (bfd_uint64_t, void *, int, bfd_boolean);
d596 1
a596 1
struct bfd_symbol;
d602 1
a602 1
  (bfd * abfd);
d604 1
a604 1
  (bfd *abfd, bfd_vma gp_value);
d606 6
a611 5
  (bfd *abfd, unsigned long gprmask, unsigned long fprmask,
   unsigned long *cprmask);
extern void *bfd_ecoff_debug_init
  (bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
d613 3
a615 2
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
d617 5
a621 4
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
   struct ecoff_debug_info *input_debug,
   const struct ecoff_debug_swap *input_swap, struct bfd_link_info *);
d623 3
a625 3
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
   struct bfd_link_info *);
d627 7
a633 4
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, bfd_boolean relocatable,
   bfd_boolean (*get_extr) (struct bfd_symbol *, struct ecoff_extr *),
   void (*set_index) (struct bfd_symbol *, bfd_size_type));
d635 3
a637 3
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, const char *name,
   struct ecoff_extr *esym);
d639 2
a640 2
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap);
d642 2
a643 2
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, file_ptr where);
d645 3
a647 3
  (void *handle, bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap,
   struct bfd_link_info *info, file_ptr where);
d649 2
a650 1
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);
d661 4
a664 8
enum dynamic_lib_link_class {
  DYN_NORMAL = 0,
  DYN_AS_NEEDED = 1,
  DYN_DT_NEEDED = 2
};

extern bfd_boolean bfd_elf_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *, bfd_boolean);
d666 1
a666 1
  (bfd *, struct bfd_link_info *);
d668 9
a676 4
  (bfd *, struct bfd_link_needed_list **);
extern bfd_boolean bfd_elf_size_dynamic_sections
  (bfd *, const char *, const char *, const char *, const char * const *,
   struct bfd_link_info *, struct bfd_section **, struct bfd_elf_version_tree *);
d678 3
a680 1
  (bfd *, const char *);
d682 1
a682 3
  (bfd *);
extern void bfd_elf_set_dyn_lib_class
  (bfd *, int);
d684 5
a688 3
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_elf_discard_info
  (bfd *, struct bfd_link_info *);
d694 1
a694 1
  (bfd *abfd);
d704 1
a704 17
  (bfd *abfd, void *phdrs);

/* Create a new BFD as if by bfd_openr.  Rather than opening a file,
   reconstruct an ELF file by reading the segments out of remote memory
   based on the ELF file header at EHDR_VMA and the ELF program headers it
   points to.  If not null, *LOADBASEP is filled in with the difference
   between the VMAs from which the segments were read, and the VMAs the
   file headers (and hence BFD's idea of each section's VMA) put them at.

   The function TARGET_READ_MEMORY is called to copy LEN bytes from the
   remote memory at target address VMA into the local buffer at MYADDR; it
   should return zero on success or an `errno' code on failure.  TEMPL must
   be a BFD for an ELF target with the word size and byte order found in
   the remote memory.  */
extern bfd *bfd_elf_bfd_from_remote_memory
  (bfd *templ, bfd_vma ehdr_vma, bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma vma, char *myaddr, int len));
d708 1
a708 1
  (bfd *);
d712 1
a712 4
  (bfd *);

extern struct bfd_section *_bfd_elf_tls_setup
  (bfd *, struct bfd_link_info *);
d715 2
a716 1
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);
d718 2
a719 1
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);
d724 1
a724 1
  (bfd *, struct bfd_link_info *);
d726 1
a726 1
  (bfd *, struct bfd_link_info *, const char *);
d728 2
a729 1
  (bfd *, struct bfd_link_info *, struct bfd_section **, struct bfd_section **, struct bfd_section **);
d734 1
a734 1
  (bfd *, struct bfd_link_info *);
d736 1
a736 1
  (bfd *, struct bfd_link_info *);
d738 1
a738 1
  (bfd *, struct bfd_link_info *);
d748 1
a748 1
  void *data;
d761 1
a761 1
  (bfd_window *);
d763 1
a763 1
  (bfd_window *);
d765 1
a765 1
  (bfd *, file_ptr, bfd_size_type, bfd_window *, bfd_boolean);
d770 2
a771 1
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_size_type);
d773 2
a774 2
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_vma,
   const char *, const char *, const char *, unsigned int);
d776 1
a776 1
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *);
d778 1
a778 1
  (bfd *, struct bfd_link_info *, const char *);
d780 1
a780 1
  (bfd *, struct bfd_link_info *, const char *);
d782 3
a784 3
  (bfd *, struct bfd_link_info *, const char *, const char *,
   unsigned long, unsigned long, unsigned long, bfd_boolean,
   int, bfd_boolean, bfd_boolean, struct bfd_section **, bfd_boolean);
d786 1
a786 1
  (bfd *, const char *, const char *, bfd_boolean);
d790 1
a790 1
  (bfd *, char *);
d800 1
a800 1
  (bfd *, struct bfd_symbol *, struct internal_syment *);
d803 1
a803 1
  (bfd *, struct bfd_symbol *, int, union internal_auxent *);
d806 1
a806 1
  (bfd *, struct bfd_symbol *, unsigned int);
d809 2
a810 1
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);
d814 1
a814 1
  (struct bfd_link_info *);
d817 1
a817 1
  (bfd *, struct bfd_link_info *, int);
d820 1
a820 1
  (bfd *, struct bfd_link_info *);
d824 1
a824 1
  (struct bfd_link_info *);
d827 1
a827 1
  (bfd *, struct bfd_link_info *, int);
d830 1
a830 1
  (bfd *, struct bfd_link_info *);
d834 1
a834 1
  (struct bfd_link_info *);
d837 1
a837 1
  (bfd *, struct bfd_link_info *, int);
d840 1
a840 1
  (bfd *, struct bfd_link_info *);
d843 1
a843 1
  (bfd *, struct bfd_link_info *);
d847 1
a847 1
  (bfd *, bfd *);
d850 1
a850 1
  (bfd *, const char *);
d853 1
a853 1
  (bfd *, const char *);
d857 1
a857 1
  (struct bfd_section *, int);
d860 1
a860 12
  (struct bfd_section *);

/* H8/300 functions.  */
extern bfd_vma bfd_h8300_pad_address
  (bfd *, bfd_vma);

/* IA64 Itanium code generation.  Called from linker.  */
extern void bfd_elf32_ia64_after_parse
  (int);

extern void bfd_elf64_ia64_after_parse
  (int);
d863 2
a864 1
void bfd_init (void);
d867 2
a868 1
bfd *bfd_openr (const char *filename, const char *target);
d870 2
a871 1
bfd *bfd_fdopenr (const char *filename, const char *target, int fd);
d873 2
a874 1
bfd *bfd_openstreamr (const char *, const char *, void *);
d876 2
a877 1
bfd *bfd_openw (const char *filename, const char *target);
d879 2
a880 1
bfd_boolean bfd_close (bfd *abfd);
d882 2
a883 1
bfd_boolean bfd_close_all_done (bfd *);
d885 2
a886 1
bfd *bfd_create (const char *filename, bfd *templ);
d888 2
a889 1
bfd_boolean bfd_make_writable (bfd *abfd);
d891 2
a892 1
bfd_boolean bfd_make_readable (bfd *abfd);
d894 2
a895 10
unsigned long bfd_calc_gnu_debuglink_crc32
   (unsigned long crc, const unsigned char *buf, bfd_size_type len);

char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);

struct bfd_section *bfd_create_gnu_debuglink_section
   (bfd *abfd, const char *filename);

bfd_boolean bfd_fill_in_gnu_debuglink_section
   (bfd *abfd, struct bfd_section *sect, const char *filename);
d902 1
a902 1
  ((void) (*((unsigned char *) (ptr)) = (val) & 0xff))
d904 1
a904 1
  bfd_put_8
d906 1
a906 1
  (*(unsigned char *) (ptr) & 0xff)
d908 1
a908 1
  (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)
d911 1
a911 1
  BFD_SEND (abfd, bfd_putx16, ((val),(ptr)))
d913 1
a913 1
  bfd_put_16
d915 1
a915 1
  BFD_SEND (abfd, bfd_getx16, (ptr))
d917 1
a917 1
  BFD_SEND (abfd, bfd_getx_signed_16, (ptr))
d920 1
a920 1
  BFD_SEND (abfd, bfd_putx32, ((val),(ptr)))
d922 1
a922 1
  bfd_put_32
d924 1
a924 1
  BFD_SEND (abfd, bfd_getx32, (ptr))
d926 1
a926 1
  BFD_SEND (abfd, bfd_getx_signed_32, (ptr))
d929 1
a929 1
  BFD_SEND (abfd, bfd_putx64, ((val), (ptr)))
d931 1
a931 1
  bfd_put_64
d933 1
a933 1
  BFD_SEND (abfd, bfd_getx64, (ptr))
d935 1
a935 1
  BFD_SEND (abfd, bfd_getx_signed_64, (ptr))
d937 13
a949 13
#define bfd_get(bits, abfd, ptr)                       \
  ((bits) == 8 ? (bfd_vma) bfd_get_8 (abfd, ptr)       \
   : (bits) == 16 ? bfd_get_16 (abfd, ptr)             \
   : (bits) == 32 ? bfd_get_32 (abfd, ptr)             \
   : (bits) == 64 ? bfd_get_64 (abfd, ptr)             \
   : (abort (), (bfd_vma) - 1))

#define bfd_put(bits, abfd, val, ptr)                  \
  ((bits) == 8 ? bfd_put_8  (abfd, val, ptr)           \
   : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)                \
   : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)                \
   : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)                \
   : (abort (), (void) 0))
d990 5
a994 1
/* Aliases for the above, which should eventually go away.  */
d996 40
a1035 16
#define H_PUT_64  bfd_h_put_64
#define H_PUT_32  bfd_h_put_32
#define H_PUT_16  bfd_h_put_16
#define H_PUT_8   bfd_h_put_8
#define H_PUT_S64 bfd_h_put_signed_64
#define H_PUT_S32 bfd_h_put_signed_32
#define H_PUT_S16 bfd_h_put_signed_16
#define H_PUT_S8  bfd_h_put_signed_8
#define H_GET_64  bfd_h_get_64
#define H_GET_32  bfd_h_get_32
#define H_GET_16  bfd_h_get_16
#define H_GET_8   bfd_h_get_8
#define H_GET_S64 bfd_h_get_signed_64
#define H_GET_S32 bfd_h_get_signed_32
#define H_GET_S16 bfd_h_get_signed_16
#define H_GET_S8  bfd_h_get_signed_8
d1039 2
a1040 1
long bfd_get_mtime (bfd *abfd);
d1042 2
a1043 1
long bfd_get_size (bfd *abfd);
d1064 1
a1064 1
typedef struct bfd_section
d1077 1
a1077 1
  struct bfd_section *next;
d1297 2
a1298 4
  /* Nonzero if this section has a gp reloc.  */
  unsigned int has_gp_reloc:1;

  /* Unused bits.  */
d1341 1
a1341 1
  struct bfd_section *output_section;
d1371 1
a1371 1
  void *userdata;
a1388 4
  /* Points to the kept section if this section is a link-once section,
     and is discarded.  */
  struct bfd_section *kept_section;

d1396 1
a1396 1
  void *used_by_bfd;
d1406 2
a1407 2
  struct bfd_symbol *symbol;
  struct bfd_symbol **symbol_ptr_ptr;
d1424 1
a1424 1
extern asection bfd_abs_section;
d1428 1
a1428 1
extern asection bfd_und_section;
d1432 1
a1432 1
extern asection bfd_com_section;
d1435 1
a1435 1
extern asection bfd_ind_section;
d1445 4
a1448 4
extern const struct bfd_symbol * const bfd_abs_symbol;
extern const struct bfd_symbol * const bfd_com_symbol;
extern const struct bfd_symbol * const bfd_und_symbol;
extern const struct bfd_symbol * const bfd_ind_symbol;
d1450 2
a1451 1
     ((section)->_raw_size)
d1481 2
a1482 3
void bfd_section_list_clear (bfd *);

asection *bfd_get_section_by_name (bfd *abfd, const char *name);
d1484 2
a1485 2
char *bfd_get_unique_section_name
   (bfd *abfd, const char *templat, int *count);
d1487 40
a1526 27
asection *bfd_make_section_old_way (bfd *abfd, const char *name);

asection *bfd_make_section_anyway (bfd *abfd, const char *name);

asection *bfd_make_section (bfd *, const char *name);

bfd_boolean bfd_set_section_flags
   (bfd *abfd, asection *sec, flagword flags);

void bfd_map_over_sections
   (bfd *abfd,
    void (*func) (bfd *abfd, asection *sect, void *obj),
    void *obj);

bfd_boolean bfd_set_section_size
   (bfd *abfd, asection *sec, bfd_size_type val);

bfd_boolean bfd_set_section_contents
   (bfd *abfd, asection *section, const void *data,
    file_ptr offset, bfd_size_type count);

bfd_boolean bfd_get_section_contents
   (bfd *abfd, asection *section, void *location, file_ptr offset,
    bfd_size_type count);

bfd_boolean bfd_copy_private_section_data
   (bfd *ibfd, asection *isec, bfd *obfd, asection *osec);
d1531 2
a1532 2
void _bfd_strip_section_from_output
   (struct bfd_link_info *info, asection *section);
d1534 2
a1535 1
bfd_boolean bfd_generic_discard_group (bfd *abfd, asection *group);
a1554 1
#define bfd_mach_mcf528x  13
a1608 1
#define bfd_mach_mips7000              7000
a1617 1
#define bfd_mach_mipsisa64r2           65
a1639 2
#define bfd_mach_h8300sx  6
#define bfd_mach_h8300sxn 7
a1666 4
#define bfd_mach_hppa10        10
#define bfd_mach_hppa11        11
#define bfd_mach_hppa20        20
#define bfd_mach_hppa20w       25
a1690 4
#define bfd_mach_sh4_nofpu  0x41
#define bfd_mach_sh4a       0x4a
#define bfd_mach_sh4a_nofpu 0x4b
#define bfd_mach_sh4al_dsp  0x4d
a1720 1
#define bfd_mach_v850e1        '1'
a1728 1
#define bfd_mach_m32r2         '2'
a1732 1
#define bfd_mach_am33_2        332
a1741 1
#define bfd_mach_fr550         550
d1768 1
a1769 1
#define bfd_mach_msp110         110
d1773 1
a1773 2
#define bfd_mach_msp15          15
#define bfd_mach_msp16          16  
a1776 2
#define bfd_mach_msp41          41
#define bfd_mach_msp42          42
d1779 2
d1801 2
a1802 1
    (const struct bfd_arch_info *a, const struct bfd_arch_info *b);
d1804 1
a1804 1
  bfd_boolean (*scan) (const struct bfd_arch_info *, const char *);
d1810 2
a1811 1
const char *bfd_printable_name (bfd *abfd);
d1813 2
a1814 1
const bfd_arch_info_type *bfd_scan_arch (const char *string);
d1816 2
a1817 1
const char **bfd_arch_list (void);
d1819 5
a1823 2
const bfd_arch_info_type *bfd_arch_get_compatible
   (const bfd *abfd, const bfd *bbfd, bfd_boolean accept_unknowns);
d1825 2
a1826 1
void bfd_set_arch_info (bfd *abfd, const bfd_arch_info_type *arg);
d1828 2
a1829 1
enum bfd_architecture bfd_get_arch (bfd *abfd);
d1831 2
a1832 1
unsigned long bfd_get_mach (bfd *abfd);
d1834 2
a1835 1
unsigned int bfd_arch_bits_per_byte (bfd *abfd);
d1837 2
a1838 1
unsigned int bfd_arch_bits_per_address (bfd *abfd);
d1840 2
a1841 1
const bfd_arch_info_type *bfd_get_arch_info (bfd *abfd);
d1843 4
a1846 2
const bfd_arch_info_type *bfd_lookup_arch
   (enum bfd_architecture arch, unsigned long machine);
d1848 2
a1849 2
const char *bfd_printable_arch_mach
   (enum bfd_architecture arch, unsigned long machine);
d1851 2
a1852 1
unsigned int bfd_octets_per_byte (bfd *abfd);
d1854 3
a1856 2
unsigned int bfd_arch_mach_octets_per_byte
   (enum bfd_architecture arch, unsigned long machine);
d1894 1
a1894 1
  struct bfd_symbol **sym_ptr_ptr;
d1965 1
a1965 1
     strange relocation methods to be accommodated (e.g., i960 callj
d1968 2
a1969 2
    (bfd *, arelent *, struct bfd_symbol *, void *, asection *,
     bfd *, char **);
d2026 1
a2026 1
    if (symbol != NULL)                                 \
d2039 2
a2040 1
unsigned int bfd_get_reloc_size (reloc_howto_type *);
d2049 2
a2050 2
bfd_reloc_status_type bfd_check_overflow
   (enum complain_overflow how,
d2054 1
a2054 1
    bfd_vma relocation);
d2056 2
a2057 2
bfd_reloc_status_type bfd_perform_relocation
   (bfd *abfd,
d2059 1
a2059 1
    void *data,
d2062 1
a2062 1
    char **error_message);
d2064 2
a2065 2
bfd_reloc_status_type bfd_install_relocation
   (bfd *abfd,
d2067 1
a2067 1
    void *data, bfd_vma data_start,
d2069 1
a2069 1
    char **error_message);
a2377 1

a2387 42
  BFD_RELOC_FRV_GOT12,
  BFD_RELOC_FRV_GOTHI,
  BFD_RELOC_FRV_GOTLO,
  BFD_RELOC_FRV_FUNCDESC,
  BFD_RELOC_FRV_FUNCDESC_GOT12,
  BFD_RELOC_FRV_FUNCDESC_GOTHI,
  BFD_RELOC_FRV_FUNCDESC_GOTLO,
  BFD_RELOC_FRV_FUNCDESC_VALUE,
  BFD_RELOC_FRV_FUNCDESC_GOTOFF12,
  BFD_RELOC_FRV_FUNCDESC_GOTOFFHI,
  BFD_RELOC_FRV_FUNCDESC_GOTOFFLO,
  BFD_RELOC_FRV_GOTOFF12,
  BFD_RELOC_FRV_GOTOFFHI,
  BFD_RELOC_FRV_GOTOFFLO,


/* This is a 24bit GOT-relative reloc for the mn10300.  */
  BFD_RELOC_MN10300_GOTOFF24,

/* This is a 32bit GOT-relative reloc for the mn10300, offset by two bytes
in the instruction.  */
  BFD_RELOC_MN10300_GOT32,

/* This is a 24bit GOT-relative reloc for the mn10300, offset by two bytes
in the instruction.  */
  BFD_RELOC_MN10300_GOT24,

/* This is a 16bit GOT-relative reloc for the mn10300, offset by two bytes
in the instruction.  */
  BFD_RELOC_MN10300_GOT16,

/* Copy symbol at runtime.  */
  BFD_RELOC_MN10300_COPY,

/* Create GOT entry.  */
  BFD_RELOC_MN10300_GLOB_DAT,

/* Create PLT entry.  */
  BFD_RELOC_MN10300_JMP_SLOT,

/* Adjust by program base.  */
  BFD_RELOC_MN10300_RELATIVE,
d2556 1
a2556 1
/* The type of reloc used to build a constructor table - at the moment
a2810 16
/* For PIC.  */
  BFD_RELOC_M32R_GOT24,
  BFD_RELOC_M32R_26_PLTREL,
  BFD_RELOC_M32R_COPY,
  BFD_RELOC_M32R_GLOB_DAT,
  BFD_RELOC_M32R_JMP_SLOT,
  BFD_RELOC_M32R_RELATIVE,
  BFD_RELOC_M32R_GOTOFF,
  BFD_RELOC_M32R_GOTPC24,
  BFD_RELOC_M32R_GOT16_HI_ULO,
  BFD_RELOC_M32R_GOT16_HI_SLO,
  BFD_RELOC_M32R_GOT16_LO,
  BFD_RELOC_M32R_GOTPC_HI_ULO,
  BFD_RELOC_M32R_GOTPC_HI_SLO,
  BFD_RELOC_M32R_GOTPC_LO,

d2853 1
a2853 1
bits placed non-contiguously in the instruction.  */
d2857 1
a2857 1
bits placed non-contiguously in the instruction.  */
a2967 1
  BFD_RELOC_MMIX_PUSHJ_STUBBABLE,
a3165 6
/* Long displacement extension.  */
  BFD_RELOC_390_20,
  BFD_RELOC_390_GOT20,
  BFD_RELOC_390_GOTPLT20,
  BFD_RELOC_390_TLS_GOTIE20,

d3207 1
a3207 1
linker the inheritance tree of a C++ virtual function table.  The
d3316 1
a3316 1
of instruction and change some branches to use PC-relative
a3343 4
/* Motorola 68HC12 reloc.
This is the 5 bits of a value.  */
  BFD_RELOC_M68HC12_5B,

d3480 2
a3481 2
reloc_howto_type *bfd_reloc_type_lookup
   (bfd *abfd, bfd_reloc_code_real_type code);
d3483 2
a3484 1
const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);
d3488 1
a3488 1
typedef struct bfd_symbol
d3529 1
a3529 1
  /* The symbol is a debugging record. The value has an arbitrary
d3600 1
a3600 1
  struct bfd_section *section;
d3605 1
a3605 1
      void *p;
d3615 2
a3616 1
bfd_boolean bfd_is_local_label (bfd *abfd, asymbol *sym);
d3618 2
a3619 1
bfd_boolean bfd_is_local_label_name (bfd *abfd, const char *name);
d3622 1
a3622 1
  BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name))
d3625 2
a3626 1
  BFD_SEND (abfd, _bfd_canonicalize_symtab, (abfd, location))
d3628 2
a3629 2
bfd_boolean bfd_set_symtab
   (bfd *abfd, asymbol **location, unsigned int count);
d3631 2
a3632 1
void bfd_print_symbol_vandf (bfd *abfd, void *file, asymbol *symbol);
d3635 1
a3635 1
  BFD_SEND (abfd, _bfd_make_empty_symbol, (abfd))
d3637 2
a3638 1
asymbol *_bfd_generic_make_empty_symbol (bfd *);
d3641 1
a3641 1
  BFD_SEND (abfd, _bfd_make_debug_symbol, (abfd, ptr, size))
d3643 2
a3644 1
int bfd_decode_symclass (asymbol *symbol);
d3646 2
a3647 1
bfd_boolean bfd_is_undefined_symclass (int symclass);
d3649 2
a3650 1
void bfd_symbol_info (asymbol *symbol, symbol_info *ret);
d3652 2
a3653 2
bfd_boolean bfd_copy_private_symbol_data
   (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
d3656 2
a3657 2
  BFD_SEND (obfd, _bfd_copy_private_symbol_data, \
            (ibfd, isymbol, obfd, osymbol))
d3678 1
a3678 1
  void *iostream;
d3739 1
a3739 1
  struct bfd_section *sections;
d3742 1
a3742 1
  struct bfd_section **section_tail;
d3755 1
a3755 1
  struct bfd_symbol  **outsymbols;
d3764 1
a3764 1
  void *arelt_data;
d3814 1
a3814 1
      void *any;
d3819 1
a3819 1
  void *usrdata;
d3822 3
a3824 3
     struct objalloc *, but we use void * to avoid requiring the inclusion
     of objalloc.h.  */
  void *memory;
d3852 2
a3853 1
bfd_error_type bfd_get_error (void);
d3855 2
a3856 1
void bfd_set_error (bfd_error_type error_tag);
d3858 2
a3859 1
const char *bfd_errmsg (bfd_error_type error_tag);
d3861 2
a3862 1
void bfd_perror (const char *message);
d3864 1
a3864 1
typedef void (*bfd_error_handler_type) (const char *, ...);
d3866 2
a3867 1
bfd_error_handler_type bfd_set_error_handler (bfd_error_handler_type);
d3869 2
a3870 1
void bfd_set_error_program_name (const char *);
d3872 2
a3873 1
bfd_error_handler_type bfd_get_error_handler (void);
d3875 2
a3876 1
const char *bfd_archive_filename (bfd *);
d3878 2
a3879 1
long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);
d3881 5
a3885 2
long bfd_canonicalize_reloc
   (bfd *abfd, asection *sec, arelent **loc, asymbol **syms);
d3887 2
a3888 2
void bfd_set_reloc
   (bfd *abfd, asection *sec, arelent **rel, unsigned int count);
d3890 2
a3891 1
bfd_boolean bfd_set_file_flags (bfd *abfd, flagword flags);
d3893 2
a3894 1
int bfd_get_arch_size (bfd *abfd);
d3896 2
a3897 1
int bfd_get_sign_extend_vma (bfd *abfd);
d3899 2
a3900 1
bfd_boolean bfd_set_start_address (bfd *abfd, bfd_vma vma);
d3902 2
a3903 1
unsigned int bfd_get_gp_size (bfd *abfd);
d3905 2
a3906 1
void bfd_set_gp_size (bfd *abfd, unsigned int i);
d3908 2
a3909 1
bfd_vma bfd_scan_vma (const char *string, const char **end, int base);
d3911 2
a3912 1
bfd_boolean bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);
d3917 2
a3918 1
bfd_boolean bfd_merge_private_bfd_data (bfd *ibfd, bfd *obfd);
d3923 2
a3924 1
bfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);
d3999 3
a4001 2
  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
   bfd_boolean, asymbol **);
d4003 2
a4004 1
bfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);
d4008 2
a4009 2
  void *marker;
  void *tdata;
d4012 2
a4013 2
  struct bfd_section *sections;
  struct bfd_section **section_tail;
d4018 2
a4019 1
bfd_boolean bfd_preserve_save (bfd *, struct bfd_preserve *);
d4021 2
a4022 1
void bfd_preserve_restore (bfd *, struct bfd_preserve *);
d4024 2
a4025 1
void bfd_preserve_finish (bfd *, struct bfd_preserve *);
d4028 2
a4029 2
symindex bfd_get_next_mapent
   (bfd *abfd, symindex previous, carsym **sym);
d4031 2
a4032 1
bfd_boolean bfd_set_archive_head (bfd *output, bfd *new_head);
d4034 2
a4035 1
bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);
d4038 2
a4039 1
const char *bfd_core_file_failing_command (bfd *abfd);
d4041 2
a4042 1
int bfd_core_file_failing_signal (bfd *abfd);
d4044 2
a4045 2
bfd_boolean core_file_matches_executable_p
   (bfd *core_bfd, bfd *exec_bfd);
d4049 1
a4049 1
  ((*((bfd)->xvec->message)) arglist)
d4059 1
a4059 1
  (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)
d4137 9
a4145 9
  bfd_uint64_t   (*bfd_getx64) (const void *);
  bfd_int64_t    (*bfd_getx_signed_64) (const void *);
  void           (*bfd_putx64) (bfd_uint64_t, void *);
  bfd_vma        (*bfd_getx32) (const void *);
  bfd_signed_vma (*bfd_getx_signed_32) (const void *);
  void           (*bfd_putx32) (bfd_vma, void *);
  bfd_vma        (*bfd_getx16) (const void *);
  bfd_signed_vma (*bfd_getx_signed_16) (const void *);
  void           (*bfd_putx16) (bfd_vma, void *);
d4148 9
a4156 9
  bfd_uint64_t   (*bfd_h_getx64) (const void *);
  bfd_int64_t    (*bfd_h_getx_signed_64) (const void *);
  void           (*bfd_h_putx64) (bfd_uint64_t, void *);
  bfd_vma        (*bfd_h_getx32) (const void *);
  bfd_signed_vma (*bfd_h_getx_signed_32) (const void *);
  void           (*bfd_h_putx32) (bfd_vma, void *);
  bfd_vma        (*bfd_h_getx16) (const void *);
  bfd_signed_vma (*bfd_h_getx_signed_16) (const void *);
  void           (*bfd_h_putx16) (bfd_vma, void *);
d4162 1
a4162 1
  const struct bfd_target *(*_bfd_check_format[bfd_type_end]) (bfd *);
d4165 1
a4165 1
  bfd_boolean (*_bfd_set_format[bfd_type_end]) (bfd *);
d4168 1
a4168 1
  bfd_boolean (*_bfd_write_contents[bfd_type_end]) (bfd *);
d4173 5
a4177 5
  NAME##_close_and_cleanup, \
  NAME##_bfd_free_cached_info, \
  NAME##_new_section_hook, \
  NAME##_get_section_contents, \
  NAME##_get_section_contents_in_window
d4180 1
a4180 1
  bfd_boolean (*_close_and_cleanup) (bfd *);
d4182 1
a4182 1
  bfd_boolean (*_bfd_free_cached_info) (bfd *);
d4184 1
a4184 1
  bfd_boolean (*_new_section_hook) (bfd *, sec_ptr);
d4187 1
a4187 1
    (bfd *, sec_ptr, void *, file_ptr, bfd_size_type);
d4189 1
a4189 1
    (bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type);
d4193 6
a4198 7
  NAME##_bfd_copy_private_bfd_data, \
  NAME##_bfd_merge_private_bfd_data, \
  NAME##_bfd_copy_private_section_data, \
  NAME##_bfd_copy_private_symbol_data, \
  NAME##_bfd_set_private_flags, \
  NAME##_bfd_print_private_bfd_data

d4201 1
a4201 1
  bfd_boolean (*_bfd_copy_private_bfd_data) (bfd *, bfd *);
d4204 1
a4204 1
  bfd_boolean (*_bfd_merge_private_bfd_data) (bfd *, bfd *);
d4208 1
a4208 1
    (bfd *, sec_ptr, bfd *, sec_ptr);
d4212 1
a4212 1
    (bfd *, asymbol *, bfd *, asymbol *);
d4214 1
a4214 1
  bfd_boolean (*_bfd_set_private_flags) (bfd *, flagword);
d4217 1
a4217 1
  bfd_boolean (*_bfd_print_private_bfd_data) (bfd *, void *);
d4221 6
a4226 7
  NAME##_core_file_failing_command, \
  NAME##_core_file_failing_signal, \
  NAME##_core_file_matches_executable_p

  char *      (*_core_file_failing_command) (bfd *);
  int         (*_core_file_failing_signal) (bfd *);
  bfd_boolean (*_core_file_matches_executable_p) (bfd *, bfd *);
d4230 12
a4241 13
  NAME##_slurp_armap, \
  NAME##_slurp_extended_name_table, \
  NAME##_construct_extended_name_table, \
  NAME##_truncate_arname, \
  NAME##_write_armap, \
  NAME##_read_ar_hdr, \
  NAME##_openr_next_archived_file, \
  NAME##_get_elt_at_index, \
  NAME##_generic_stat_arch_elt, \
  NAME##_update_armap_timestamp

  bfd_boolean (*_bfd_slurp_armap) (bfd *);
  bfd_boolean (*_bfd_slurp_extended_name_table) (bfd *);
d4243 2
a4244 2
    (bfd *, char **, bfd_size_type *, const char **);
  void        (*_bfd_truncate_arname) (bfd *, const char *, char *);
d4246 7
a4252 7
    (bfd *, unsigned int, struct orl *, unsigned int, int);
  void *      (*_bfd_read_ar_hdr_fn) (bfd *);
  bfd *       (*openr_next_archived_file) (bfd *, bfd *);
#define bfd_get_elt_at_index(b,i) BFD_SEND (b, _bfd_get_elt_at_index, (b,i))
  bfd *       (*_bfd_get_elt_at_index) (bfd *, symindex);
  int         (*_bfd_stat_arch_elt) (bfd *, struct stat *);
  bfd_boolean (*_bfd_update_armap_timestamp) (bfd *);
d4256 16
a4271 17
  NAME##_get_symtab_upper_bound, \
  NAME##_canonicalize_symtab, \
  NAME##_make_empty_symbol, \
  NAME##_print_symbol, \
  NAME##_get_symbol_info, \
  NAME##_bfd_is_local_label_name, \
  NAME##_get_lineno, \
  NAME##_find_nearest_line, \
  NAME##_bfd_make_debug_symbol, \
  NAME##_read_minisymbols, \
  NAME##_minisymbol_to_symbol

  long        (*_bfd_get_symtab_upper_bound) (bfd *);
  long        (*_bfd_canonicalize_symtab)
    (bfd *, struct bfd_symbol **);
  struct bfd_symbol *
              (*_bfd_make_empty_symbol) (bfd *);
d4273 2
a4274 2
    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type);
#define bfd_print_symbol(b,p,s,e) BFD_SEND (b, _bfd_print_symbol, (b,p,s,e))
d4276 3
a4278 3
    (bfd *, struct bfd_symbol *, symbol_info *);
#define bfd_get_symbol_info(b,p,e) BFD_SEND (b, _bfd_get_symbol_info, (b,p,e))
  bfd_boolean (*_bfd_is_local_label_name) (bfd *, const char *);
d4280 1
a4280 1
  alent *     (*_get_lineno) (bfd *, struct bfd_symbol *);
d4282 2
a4283 2
    (bfd *, struct bfd_section *, struct bfd_symbol **, bfd_vma,
     const char **, const char **, unsigned int *);
d4288 1
a4288 1
    (bfd *, void *, unsigned long size);
d4292 1
a4292 1
    (bfd *, bfd_boolean, void **, unsigned int *);
d4296 1
a4296 1
    (bfd *, bfd_boolean, const void *, asymbol *);
d4300 4
a4303 5
  NAME##_get_reloc_upper_bound, \
  NAME##_canonicalize_reloc, \
  NAME##_bfd_reloc_type_lookup

  long        (*_get_reloc_upper_bound) (bfd *, sec_ptr);
d4305 1
a4305 1
    (bfd *, sec_ptr, arelent **, struct bfd_symbol **);
d4308 1
a4308 1
              (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);
d4312 2
a4313 3
  NAME##_set_arch_mach, \
  NAME##_set_section_contents

d4315 1
a4315 1
    (bfd *, enum bfd_architecture, unsigned long);
d4317 1
a4317 1
    (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
d4321 13
a4333 14
  NAME##_sizeof_headers, \
  NAME##_bfd_get_relocated_section_contents, \
  NAME##_bfd_relax_section, \
  NAME##_bfd_link_hash_table_create, \
  NAME##_bfd_link_hash_table_free, \
  NAME##_bfd_link_add_symbols, \
  NAME##_bfd_link_just_syms, \
  NAME##_bfd_final_link, \
  NAME##_bfd_link_split_section, \
  NAME##_bfd_gc_sections, \
  NAME##_bfd_merge_sections, \
  NAME##_bfd_discard_group

  int         (*_bfd_sizeof_headers) (bfd *, bfd_boolean);
d4335 2
a4336 2
    (bfd *, struct bfd_link_info *, struct bfd_link_order *,
     bfd_byte *, bfd_boolean, struct bfd_symbol **);
d4339 1
a4339 1
    (bfd *, struct bfd_section *, struct bfd_link_info *, bfd_boolean *);
d4344 1
a4344 1
              (*_bfd_link_hash_table_create) (bfd *);
d4347 2
a4348 1
  void        (*_bfd_link_hash_table_free) (struct bfd_link_hash_table *);
d4351 2
a4352 1
  bfd_boolean (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);
d4355 2
a4356 1
  void        (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);
d4360 1
a4360 1
  bfd_boolean (*_bfd_final_link) (bfd *, struct bfd_link_info *);
d4363 1
a4363 1
  bfd_boolean (*_bfd_link_split_section) (bfd *, struct bfd_section *);
d4366 1
a4366 1
  bfd_boolean (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);
d4369 1
a4369 1
  bfd_boolean (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);
d4372 1
a4372 1
  bfd_boolean (*_bfd_discard_group) (bfd *, struct bfd_section *);
d4376 4
a4379 5
  NAME##_get_dynamic_symtab_upper_bound, \
  NAME##_canonicalize_dynamic_symtab, \
  NAME##_get_dynamic_reloc_upper_bound, \
  NAME##_canonicalize_dynamic_reloc

d4381 1
a4381 1
  long        (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);
d4384 1
a4384 1
    (bfd *, struct bfd_symbol **);
d4386 1
a4386 1
  long        (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);
d4389 1
a4389 1
    (bfd *, arelent **, struct bfd_symbol **);
d4396 1
a4396 1
  const void *backend_data;
d4400 2
a4401 1
bfd_boolean bfd_set_default_target (const char *name);
d4403 2
a4404 1
const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);
d4406 2
a4407 1
const char ** bfd_target_list (void);
d4409 4
a4412 3
const bfd_target *bfd_search_for_target
   (int (*search_func) (const bfd_target *, void *),
    void *);
d4415 2
a4416 1
bfd_boolean bfd_check_format (bfd *abfd, bfd_format format);
d4418 3
a4420 2
bfd_boolean bfd_check_format_matches
   (bfd *abfd, bfd_format format, char ***matching);
d4422 2
a4423 1
bfd_boolean bfd_set_format (bfd *abfd, bfd_format format);
d4425 2
a4426 1
const char *bfd_format_string (bfd_format format);
d4429 2
a4430 1
bfd_boolean bfd_link_split_section (bfd *abfd, asection *sec);
d4436 2
a4437 2
bfd_byte *bfd_simple_get_relocated_section_contents
   (bfd *abfd, asection *sec, bfd_byte *outbuf, asymbol **symbol_table);
@


