head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.18
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.16
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.12
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.14
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.6
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.10
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.8
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.4
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.9.0.32
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.30
	OPENBSD_5_0:1.9.0.28
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.26
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.24
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.20
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.22
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.18
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.16
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.14
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.12
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.6.0.8
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.5.0.16
	OPENBSD_2_7_BASE:1.5
	new-binutils:1.5.0.14
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2013.01.01.00.02.00;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.02.20.45.12;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.17.21.54.23;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.13.17.07.31;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.12.19.11.22;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	96.11.23.03.33.25;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.10.31.00.31.05;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.01.39;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.46.54;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.09;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.09;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.06.24;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.38.40;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.12.55;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.20.32;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.54;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.27.26;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.19;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.33;	author miod;	state Exp;
branches;
next	;


desc
@@


1.10
log
@m88k ELF toolchain, supporting static binaries only so far.

Assembler supports a register prefix of `#' when configured for SVR4, and `%'
when configured for OpenBSD. Pseudo-ops do not need a leading dot, except
when configured for OpenBSD, allowing the `set' instruction to be recognized
correctly.

Based upon various unfinished or unreliable works, including smurph@@'s early
work in 2003, my own attempts in 2004 and 2005, and Michael Kato's binutils
2.15 diff from 2005. Support for register prefixes, as well as fixing an
evil off-by-one in resolving 16-bit pc-relative relocations in ld (which would
only affect kernel .S files branching to global symbols), came as part of the
2012 work.

Not enabled yet (needs Makefile.bsd-wrapper, bfd/config.bfd and
gdb/configure.tgt updates to completely enable) so as not to disturb the
existing a.out toolchain builds; will hopefully be enabled very soon.
@
text
@/* BFD support for handling relocation entries.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/*
SECTION
	Relocations

	BFD maintains relocations in much the same way it maintains
	symbols: they are left alone until required, then read in
	en-masse and translated into an internal form.  A common
	routine <<bfd_perform_relocation>> acts upon the
	canonical form to do the fixup.

	Relocations are maintained on a per section basis,
	while symbols are maintained on a per BFD basis.

	All that a back end has to do to fit the BFD interface is to create
	a <<struct reloc_cache_entry>> for each relocation
	in a particular section, and fill in the right bits of the structures.

@@menu
@@* typedef arelent::
@@* howto manager::
@@end menu

*/

/* DO compile in the reloc_code name table from libbfd.h.  */
#define _BFD_MAKE_TABLE_bfd_reloc_code_real

#include "bfd.h"
#include "sysdep.h"
#include "bfdlink.h"
#include "libbfd.h"
/*
DOCDD
INODE
	typedef arelent, howto manager, Relocations, Relocations

SUBSECTION
	typedef arelent

	This is the structure of a relocation entry:

CODE_FRAGMENT
.
.typedef enum bfd_reloc_status
.{
.  {* No errors detected.  *}
.  bfd_reloc_ok,
.
.  {* The relocation was performed, but there was an overflow.  *}
.  bfd_reloc_overflow,
.
.  {* The address to relocate was not within the section supplied.  *}
.  bfd_reloc_outofrange,
.
.  {* Used by special functions.  *}
.  bfd_reloc_continue,
.
.  {* Unsupported relocation size requested.  *}
.  bfd_reloc_notsupported,
.
.  {* Unused.  *}
.  bfd_reloc_other,
.
.  {* The symbol to relocate against was undefined.  *}
.  bfd_reloc_undefined,
.
.  {* The relocation was performed, but may not be ok - presently
.     generated only when linking i960 coff files with i960 b.out
.     symbols.  If this type is returned, the error_message argument
.     to bfd_perform_relocation will be set.  *}
.  bfd_reloc_dangerous
. }
. bfd_reloc_status_type;
.
.
.typedef struct reloc_cache_entry
.{
.  {* A pointer into the canonical table of pointers.  *}
.  struct bfd_symbol **sym_ptr_ptr;
.
.  {* offset in section.  *}
.  bfd_size_type address;
.
.  {* addend for relocation value.  *}
.  bfd_vma addend;
.
.  {* Pointer to how to perform the required relocation.  *}
.  reloc_howto_type *howto;
.
.}
.arelent;
.
*/

/*
DESCRIPTION

        Here is a description of each of the fields within an <<arelent>>:

        o <<sym_ptr_ptr>>

        The symbol table pointer points to a pointer to the symbol
        associated with the relocation request.  It is the pointer
        into the table returned by the back end's
        <<canonicalize_symtab>> action. @@xref{Symbols}. The symbol is
        referenced through a pointer to a pointer so that tools like
        the linker can fix up all the symbols of the same name by
        modifying only one pointer. The relocation routine looks in
        the symbol and uses the base of the section the symbol is
        attached to and the value of the symbol as the initial
        relocation offset. If the symbol pointer is zero, then the
        section provided is looked up.

        o <<address>>

        The <<address>> field gives the offset in bytes from the base of
        the section data which owns the relocation record to the first
        byte of relocatable information. The actual data relocated
        will be relative to this point; for example, a relocation
        type which modifies the bottom two bytes of a four byte word
        would not touch the first byte pointed to in a big endian
        world.

	o <<addend>>

	The <<addend>> is a value provided by the back end to be added (!)
	to the relocation offset. Its interpretation is dependent upon
	the howto. For example, on the 68k the code:

|        char foo[];
|        main()
|                {
|                return foo[0x12345678];
|                }

        Could be compiled into:

|        linkw fp,#-4
|        moveb @@@@#12345678,d0
|        extbl d0
|        unlk fp
|        rts

        This could create a reloc pointing to <<foo>>, but leave the
        offset in the data, something like:

|RELOCATION RECORDS FOR [.text]:
|offset   type      value
|00000006 32        _foo
|
|00000000 4e56 fffc          ; linkw fp,#-4
|00000004 1039 1234 5678     ; moveb @@@@#12345678,d0
|0000000a 49c0               ; extbl d0
|0000000c 4e5e               ; unlk fp
|0000000e 4e75               ; rts

        Using coff and an 88k, some instructions don't have enough
        space in them to represent the full address range, and
        pointers have to be loaded in two parts. So you'd get something like:

|        or.u     r13,r0,hi16(_foo+0x12345678)
|        ld.b     r2,r13,lo16(_foo+0x12345678)
|        jmp      r1

        This should create two relocs, both pointing to <<_foo>>, and with
        0x12340000 in their addend field. The data would consist of:

|RELOCATION RECORDS FOR [.text]:
|offset   type      value
|00000002 HVRT16    _foo+0x12340000
|00000006 LVRT16    _foo+0x12340000
|
|00000000 5da05678           ; or.u r13,r0,0x5678
|00000004 1c4d5678           ; ld.b r2,r13,0x5678
|00000008 f400c001           ; jmp r1

        The relocation routine digs out the value from the data, adds
        it to the addend to get the original offset, and then adds the
        value of <<_foo>>. Note that all 32 bits have to be kept around
        somewhere, to cope with carry from bit 15 to bit 16.

        One further example is the sparc and the a.out format. The
        sparc has a similar problem to the 88k, in that some
        instructions don't have room for an entire offset, but on the
        sparc the parts are created in odd sized lumps. The designers of
        the a.out format chose to not use the data within the section
        for storing part of the offset; all the offset is kept within
        the reloc. Anything in the data should be ignored.

|        save %sp,-112,%sp
|        sethi %hi(_foo+0x12345678),%g2
|        ldsb [%g2+%lo(_foo+0x12345678)],%i0
|        ret
|        restore

        Both relocs contain a pointer to <<foo>>, and the offsets
        contain junk.

|RELOCATION RECORDS FOR [.text]:
|offset   type      value
|00000004 HI22      _foo+0x12345678
|00000008 LO10      _foo+0x12345678
|
|00000000 9de3bf90     ; save %sp,-112,%sp
|00000004 05000000     ; sethi %hi(_foo+0),%g2
|00000008 f048a000     ; ldsb [%g2+%lo(_foo+0)],%i0
|0000000c 81c7e008     ; ret
|00000010 81e80000     ; restore

        o <<howto>>

        The <<howto>> field can be imagined as a
        relocation instruction. It is a pointer to a structure which
        contains information on what to do with all of the other
        information in the reloc record and data section. A back end
        would normally have a relocation instruction set and turn
        relocations into pointers to the correct structure on input -
        but it would be possible to create each howto field on demand.

*/

/*
SUBSUBSECTION
	<<enum complain_overflow>>

	Indicates what sort of overflow checking should be done when
	performing a relocation.

CODE_FRAGMENT
.
.enum complain_overflow
.{
.  {* Do not complain on overflow.  *}
.  complain_overflow_dont,
.
.  {* Complain if the bitfield overflows, whether it is considered
.     as signed or unsigned.  *}
.  complain_overflow_bitfield,
.
.  {* Complain if the value overflows when considered as signed
.     number.  *}
.  complain_overflow_signed,
.
.  {* Complain if the value overflows when considered as an
.     unsigned number.  *}
.  complain_overflow_unsigned
.};

*/

/*
SUBSUBSECTION
        <<reloc_howto_type>>

        The <<reloc_howto_type>> is a structure which contains all the
        information that libbfd needs to know to tie up a back end's data.

CODE_FRAGMENT
.struct bfd_symbol;		{* Forward declaration.  *}
.
.struct reloc_howto_struct
.{
.  {*  The type field has mainly a documentary use - the back end can
.      do what it wants with it, though normally the back end's
.      external idea of what a reloc number is stored
.      in this field.  For example, a PC relative word relocation
.      in a coff environment has the type 023 - because that's
.      what the outside world calls a R_PCRWORD reloc.  *}
.  unsigned int type;
.
.  {*  The value the final relocation is shifted right by.  This drops
.      unwanted data from the relocation.  *}
.  unsigned int rightshift;
.
.  {*  The size of the item to be relocated.  This is *not* a
.      power-of-two measure.  To get the number of bytes operated
.      on by a type of relocation, use bfd_get_reloc_size.  *}
.  int size;
.
.  {*  The number of bits in the item to be relocated.  This is used
.      when doing overflow checking.  *}
.  unsigned int bitsize;
.
.  {*  Notes that the relocation is relative to the location in the
.      data section of the addend.  The relocation function will
.      subtract from the relocation value the address of the location
.      being relocated.  *}
.  bfd_boolean pc_relative;
.
.  {*  The bit position of the reloc value in the destination.
.      The relocated value is left shifted by this amount.  *}
.  unsigned int bitpos;
.
.  {* What type of overflow error should be checked for when
.     relocating.  *}
.  enum complain_overflow complain_on_overflow;
.
.  {* If this field is non null, then the supplied function is
.     called rather than the normal function.  This allows really
.     strange relocation methods to be accommodated (e.g., i960 callj
.     instructions).  *}
.  bfd_reloc_status_type (*special_function)
.    (bfd *, arelent *, struct bfd_symbol *, void *, asection *,
.     bfd *, char **);
.
.  {* The textual name of the relocation type.  *}
.  char *name;
.
.  {* Some formats record a relocation addend in the section contents
.     rather than with the relocation.  For ELF formats this is the
.     distinction between USE_REL and USE_RELA (though the code checks
.     for USE_REL == 1/0).  The value of this field is TRUE if the
.     addend is recorded with the section contents; when performing a
.     partial link (ld -r) the section contents (the data) will be
.     modified.  The value of this field is FALSE if addends are
.     recorded with the relocation (in arelent.addend); when performing
.     a partial link the relocation will be modified.
.     All relocations for all ELF USE_RELA targets should set this field
.     to FALSE (values of TRUE should be looked on with suspicion).
.     However, the converse is not true: not all relocations of all ELF
.     USE_REL targets set this field to TRUE.  Why this is so is peculiar
.     to each particular target.  For relocs that aren't used in partial
.     links (e.g. GOT stuff) it doesn't matter what this is set to.  *}
.  bfd_boolean partial_inplace;
.
.  {* src_mask selects the part of the instruction (or data) to be used
.     in the relocation sum.  If the target relocations don't have an
.     addend in the reloc, eg. ELF USE_REL, src_mask will normally equal
.     dst_mask to extract the addend from the section contents.  If
.     relocations do have an addend in the reloc, eg. ELF USE_RELA, this
.     field should be zero.  Non-zero values for ELF USE_RELA targets are
.     bogus as in those cases the value in the dst_mask part of the
.     section contents should be treated as garbage.  *}
.  bfd_vma src_mask;
.
.  {* dst_mask selects which parts of the instruction (or data) are
.     replaced with a relocated value.  *}
.  bfd_vma dst_mask;
.
.  {* When some formats create PC relative instructions, they leave
.     the value of the pc of the place being relocated in the offset
.     slot of the instruction, so that a PC relative relocation can
.     be made just by adding in an ordinary offset (e.g., sun3 a.out).
.     Some formats leave the displacement part of an instruction
.     empty (e.g., m88k bcs); this flag signals the fact.  *}
.  bfd_boolean pcrel_offset;
.};
.
*/

/*
FUNCTION
	The HOWTO Macro

DESCRIPTION
	The HOWTO define is horrible and will go away.

.#define HOWTO(C, R, S, B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC) \
.  { (unsigned) C, R, S, B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC }

DESCRIPTION
	And will be replaced with the totally magic way. But for the
	moment, we are compatible, so do it this way.

.#define NEWHOWTO(FUNCTION, NAME, SIZE, REL, IN) \
.  HOWTO (0, 0, SIZE, 0, REL, 0, complain_overflow_dont, FUNCTION, \
.         NAME, FALSE, 0, 0, IN)
.

DESCRIPTION
	This is used to fill in an empty howto entry in an array.

.#define EMPTY_HOWTO(C) \
.  HOWTO ((C), 0, 0, 0, FALSE, 0, complain_overflow_dont, NULL, \
.         NULL, FALSE, 0, 0, FALSE)
.

DESCRIPTION
	Helper routine to turn a symbol into a relocation value.

.#define HOWTO_PREPARE(relocation, symbol)               \
.  {                                                     \
.    if (symbol != NULL)                                 \
.      {                                                 \
.        if (bfd_is_com_section (symbol->section))       \
.          {                                             \
.            relocation = 0;                             \
.          }                                             \
.        else                                            \
.          {                                             \
.            relocation = symbol->value;                 \
.          }                                             \
.      }                                                 \
.  }
.
*/

/*
FUNCTION
	bfd_get_reloc_size

SYNOPSIS
	unsigned int bfd_get_reloc_size (reloc_howto_type *);

DESCRIPTION
	For a reloc_howto_type that operates on a fixed number of bytes,
	this returns the number of bytes operated on.
 */

unsigned int
bfd_get_reloc_size (reloc_howto_type *howto)
{
  switch (howto->size)
    {
    case 0: return 1;
    case 1: return 2;
    case 2: return 4;
    case 3: return 0;
    case 4: return 8;
    case 8: return 16;
    case -2: return 4;
    default: abort ();
    }
}

/*
TYPEDEF
	arelent_chain

DESCRIPTION

	How relocs are tied together in an <<asection>>:

.typedef struct relent_chain
.{
.  arelent relent;
.  struct relent_chain *next;
.}
.arelent_chain;
.
*/

/* N_ONES produces N one bits, without overflowing machine arithmetic.  */
#define N_ONES(n) (((((bfd_vma) 1 << ((n) - 1)) - 1) << 1) | 1)

/*
FUNCTION
	bfd_check_overflow

SYNOPSIS
	bfd_reloc_status_type bfd_check_overflow
	  (enum complain_overflow how,
	   unsigned int bitsize,
	   unsigned int rightshift,
	   unsigned int addrsize,
	   bfd_vma relocation);

DESCRIPTION
	Perform overflow checking on @@var{relocation} which has
	@@var{bitsize} significant bits and will be shifted right by
	@@var{rightshift} bits, on a machine with addresses containing
	@@var{addrsize} significant bits.  The result is either of
	@@code{bfd_reloc_ok} or @@code{bfd_reloc_overflow}.

*/

bfd_reloc_status_type
bfd_check_overflow (enum complain_overflow how,
		    unsigned int bitsize,
		    unsigned int rightshift,
		    unsigned int addrsize,
		    bfd_vma relocation)
{
  bfd_vma fieldmask, addrmask, signmask, ss, a;
  bfd_reloc_status_type flag = bfd_reloc_ok;

  a = relocation;

  /* Note: BITSIZE should always be <= ADDRSIZE, but in case it's not,
     we'll be permissive: extra bits in the field mask will
     automatically extend the address mask for purposes of the
     overflow check.  */
  fieldmask = N_ONES (bitsize);
  addrmask = N_ONES (addrsize) | fieldmask;

  switch (how)
    {
    case complain_overflow_dont:
      break;

    case complain_overflow_signed:
      /* If any sign bits are set, all sign bits must be set.  That
         is, A must be a valid negative address after shifting.  */
      a = (a & addrmask) >> rightshift;
      signmask = ~ (fieldmask >> 1);
      ss = a & signmask;
      if (ss != 0 && ss != ((addrmask >> rightshift) & signmask))
	flag = bfd_reloc_overflow;
      break;

    case complain_overflow_unsigned:
      /* We have an overflow if the address does not fit in the field.  */
      a = (a & addrmask) >> rightshift;
      if ((a & ~ fieldmask) != 0)
	flag = bfd_reloc_overflow;
      break;

    case complain_overflow_bitfield:
      /* Bitfields are sometimes signed, sometimes unsigned.  We
	 explicitly allow an address wrap too, which means a bitfield
	 of n bits is allowed to store -2**n to 2**n-1.  Thus overflow
	 if the value has some, but not all, bits set outside the
	 field.  */
      a >>= rightshift;
      ss = a & ~ fieldmask;
      if (ss != 0 && ss != (((bfd_vma) -1 >> rightshift) & ~ fieldmask))
	flag = bfd_reloc_overflow;
      break;

    default:
      abort ();
    }

  return flag;
}

/*
FUNCTION
	bfd_perform_relocation

SYNOPSIS
	bfd_reloc_status_type bfd_perform_relocation
          (bfd *abfd,
           arelent *reloc_entry,
           void *data,
           asection *input_section,
           bfd *output_bfd,
	   char **error_message);

DESCRIPTION
	If @@var{output_bfd} is supplied to this function, the
	generated image will be relocatable; the relocations are
	copied to the output file after they have been changed to
	reflect the new state of the world. There are two ways of
	reflecting the results of partial linkage in an output file:
	by modifying the output data in place, and by modifying the
	relocation record.  Some native formats (e.g., basic a.out and
	basic coff) have no way of specifying an addend in the
	relocation type, so the addend has to go in the output data.
	This is no big deal since in these formats the output data
	slot will always be big enough for the addend. Complex reloc
	types with addends were invented to solve just this problem.
	The @@var{error_message} argument is set to an error message if
	this return @@code{bfd_reloc_dangerous}.

*/

bfd_reloc_status_type
bfd_perform_relocation (bfd *abfd,
			arelent *reloc_entry,
			void *data,
			asection *input_section,
			bfd *output_bfd,
			char **error_message)
{
  bfd_vma relocation;
  bfd_reloc_status_type flag = bfd_reloc_ok;
  bfd_size_type octets = reloc_entry->address * bfd_octets_per_byte (abfd);
  bfd_vma output_base = 0;
  reloc_howto_type *howto = reloc_entry->howto;
  asection *reloc_target_output_section;
  asymbol *symbol;

  symbol = *(reloc_entry->sym_ptr_ptr);
  if (bfd_is_abs_section (symbol->section)
      && output_bfd != NULL)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* If we are not producing relocatable output, return an error if
     the symbol is not defined.  An undefined weak symbol is
     considered to have a value of zero (SVR4 ABI, p. 4-27).  */
  if (bfd_is_und_section (symbol->section)
      && (symbol->flags & BSF_WEAK) == 0
      && output_bfd == NULL)
    flag = bfd_reloc_undefined;

  /* If there is a function supplied to handle this relocation type,
     call it.  It'll return `bfd_reloc_continue' if further processing
     can be done.  */
  if (howto->special_function)
    {
      bfd_reloc_status_type cont;
      cont = howto->special_function (abfd, reloc_entry, symbol, data,
				      input_section, output_bfd,
				      error_message);
      if (cont != bfd_reloc_continue)
	return cont;
    }

  /* Is the address of the relocation really within the section?  */
  if (reloc_entry->address > (input_section->_cooked_size
			      / bfd_octets_per_byte (abfd)))
    return bfd_reloc_outofrange;

  /* Work out which section the relocation is targeted at and the
     initial relocation command value.  */

  /* Get symbol value.  (Common symbols are special.)  */
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  reloc_target_output_section = symbol->section->output_section;

  /* Convert input-section-relative symbol value to absolute.  */
  if ((output_bfd && ! howto->partial_inplace)
      || reloc_target_output_section == NULL)
    output_base = 0;
  else
    output_base = reloc_target_output_section->vma;

  relocation += output_base + symbol->section->output_offset;

  /* Add in supplied addend.  */
  relocation += reloc_entry->addend;

  /* Here the variable relocation holds the final address of the
     symbol we are relocating against, plus any addend.  */

  if (howto->pc_relative)
    {
      /* This is a PC relative relocation.  We want to set RELOCATION
	 to the distance between the address of the symbol and the
	 location.  RELOCATION is already the address of the symbol.

	 We start by subtracting the address of the section containing
	 the location.

	 If pcrel_offset is set, we must further subtract the position
	 of the location within the section.  Some targets arrange for
	 the addend to be the negative of the position of the location
	 within the section; for example, i386-aout does this.  For
	 i386-aout, pcrel_offset is FALSE.  Some other targets do not
	 include the position of the location; for example, m88kbcs,
	 or ELF.  For those targets, pcrel_offset is TRUE.

	 If we are producing relocatable output, then we must ensure
	 that this reloc will be correctly computed when the final
	 relocation is done.  If pcrel_offset is FALSE we want to wind
	 up with the negative of the location within the section,
	 which means we must adjust the existing addend by the change
	 in the location within the section.  If pcrel_offset is TRUE
	 we do not want to adjust the existing addend at all.

	 FIXME: This seems logical to me, but for the case of
	 producing relocatable output it is not what the code
	 actually does.  I don't want to change it, because it seems
	 far too likely that something will break.  */

      relocation -=
	input_section->output_section->vma + input_section->output_offset;

      if (howto->pcrel_offset)
	relocation -= reloc_entry->address;
    }

  if (output_bfd != NULL)
    {
      if (! howto->partial_inplace)
	{
	  /* This is a partial relocation, and we want to apply the relocation
	     to the reloc entry rather than the raw data. Modify the reloc
	     inplace to reflect what we now know.  */
	  reloc_entry->addend = relocation;
	  reloc_entry->address += input_section->output_offset;
	  return flag;
	}
      else
	{
	  /* This is a partial relocation, but inplace, so modify the
	     reloc record a bit.

	     If we've relocated with a symbol with a section, change
	     into a ref to the section belonging to the symbol.  */

	  reloc_entry->address += input_section->output_offset;

	  /* WTF?? */
	  if (abfd->xvec->flavour == bfd_target_coff_flavour
	      && strcmp (abfd->xvec->name, "coff-Intel-little") != 0
	      && strcmp (abfd->xvec->name, "coff-Intel-big") != 0)
	    {
#if 1
	      /* For m68k-coff, the addend was being subtracted twice during
		 relocation with -r.  Removing the line below this comment
		 fixes that problem; see PR 2953.

However, Ian wrote the following, regarding removing the line below,
which explains why it is still enabled:  --djm

If you put a patch like that into BFD you need to check all the COFF
linkers.  I am fairly certain that patch will break coff-i386 (e.g.,
SCO); see coff_i386_reloc in coff-i386.c where I worked around the
problem in a different way.  There may very well be a reason that the
code works as it does.

Hmmm.  The first obvious point is that bfd_perform_relocation should
not have any tests that depend upon the flavour.  It's seem like
entirely the wrong place for such a thing.  The second obvious point
is that the current code ignores the reloc addend when producing
relocatable output for COFF.  That's peculiar.  In fact, I really
have no idea what the point of the line you want to remove is.

A typical COFF reloc subtracts the old value of the symbol and adds in
the new value to the location in the object file (if it's a pc
relative reloc it adds the difference between the symbol value and the
location).  When relocating we need to preserve that property.

BFD handles this by setting the addend to the negative of the old
value of the symbol.  Unfortunately it handles common symbols in a
non-standard way (it doesn't subtract the old value) but that's a
different story (we can't change it without losing backward
compatibility with old object files) (coff-i386 does subtract the old
value, to be compatible with existing coff-i386 targets, like SCO).

So everything works fine when not producing relocatable output.  When
we are producing relocatable output, logically we should do exactly
what we do when not producing relocatable output.  Therefore, your
patch is correct.  In fact, it should probably always just set
reloc_entry->addend to 0 for all cases, since it is, in fact, going to
add the value into the object file.  This won't hurt the COFF code,
which doesn't use the addend; I'm not sure what it will do to other
formats (the thing to check for would be whether any formats both use
the addend and set partial_inplace).

When I wanted to make coff-i386 produce relocatable output, I ran
into the problem that you are running into: I wanted to remove that
line.  Rather than risk it, I made the coff-i386 relocs use a special
function; it's coff_i386_reloc in coff-i386.c.  The function
specifically adds the addend field into the object file, knowing that
bfd_perform_relocation is not going to.  If you remove that line, then
coff-i386.c will wind up adding the addend field in twice.  It's
trivial to fix; it just needs to be done.

The problem with removing the line is just that it may break some
working code.  With BFD it's hard to be sure of anything.  The right
way to deal with this is simply to build and test at least all the
supported COFF targets.  It should be straightforward if time and disk
space consuming.  For each target:
    1) build the linker
    2) generate some executable, and link it using -r (I would
       probably use paranoia.o and link against newlib/libc.a, which
       for all the supported targets would be available in
       /usr/cygnus/progressive/H-host/target/lib/libc.a).
    3) make the change to reloc.c
    4) rebuild the linker
    5) repeat step 2
    6) if the resulting object files are the same, you have at least
       made it no worse
    7) if they are different you have to figure out which version is
       right
*/
	      relocation -= reloc_entry->addend;
#endif
	      reloc_entry->addend = 0;
	    }
	  else
	    {
	      reloc_entry->addend = relocation;
	    }
	}
    }
  else
    {
      reloc_entry->addend = 0;
    }

  /* FIXME: This overflow checking is incomplete, because the value
     might have overflowed before we get here.  For a correct check we
     need to compute the value in a size larger than bitsize, but we
     can't reasonably do that for a reloc the same size as a host
     machine word.
     FIXME: We should also do overflow checking on the result after
     adding in the value contained in the object file.  */
  if (howto->complain_on_overflow != complain_overflow_dont
      && flag == bfd_reloc_ok)
    flag = bfd_check_overflow (howto->complain_on_overflow,
			       howto->bitsize,
			       howto->rightshift,
			       bfd_arch_bits_per_address (abfd),
			       relocation);

  /* Either we are relocating all the way, or we don't want to apply
     the relocation to the reloc entry (probably because there isn't
     any room in the output format to describe addends to relocs).  */

  /* The cast to bfd_vma avoids a bug in the Alpha OSF/1 C compiler
     (OSF version 1.3, compiler version 3.11).  It miscompiles the
     following program:

     struct str
     {
       unsigned int i0;
     } s = { 0 };

     int
     main ()
     {
       unsigned long x;

       x = 0x100000000;
       x <<= (unsigned long) s.i0;
       if (x == 0)
	 printf ("failed\n");
       else
	 printf ("succeeded (%lx)\n", x);
     }
     */

  relocation >>= (bfd_vma) howto->rightshift;

  /* Shift everything up to where it's going to be used.  */
  relocation <<= (bfd_vma) howto->bitpos;

  /* Wait for the day when all have the mask in them.  */

  /* What we do:
     i instruction to be left alone
     o offset within instruction
     r relocation offset to apply
     S src mask
     D dst mask
     N ~dst mask
     A part 1
     B part 2
     R result

     Do this:
     ((  i i i i i o o o o o  from bfd_get<size>
     and           S S S S S) to get the size offset we want
     +   r r r r r r r r r r) to get the final value to place
     and           D D D D D  to chop to right size
     -----------------------
     =             A A A A A
     And this:
     (   i i i i i o o o o o  from bfd_get<size>
     and N N N N N          ) get instruction
     -----------------------
     =   B B B B B

     And then:
     (   B B B B B
     or            A A A A A)
     -----------------------
     =   R R R R R R R R R R  put into bfd_put<size>
     */

#define DOIT(x) \
  x = ( (x & ~howto->dst_mask) | (((x & howto->src_mask) +  relocation) & howto->dst_mask))

  switch (howto->size)
    {
    case 0:
      {
	char x = bfd_get_8 (abfd, (char *) data + octets);
	DOIT (x);
	bfd_put_8 (abfd, x, (unsigned char *) data + octets);
      }
      break;

    case 1:
      {
	short x = bfd_get_16 (abfd, (bfd_byte *) data + octets);
	DOIT (x);
	bfd_put_16 (abfd, (bfd_vma) x, (unsigned char *) data + octets);
      }
      break;
    case 2:
      {
	long x = bfd_get_32 (abfd, (bfd_byte *) data + octets);
	DOIT (x);
	bfd_put_32 (abfd, (bfd_vma) x, (bfd_byte *) data + octets);
      }
      break;
    case -2:
      {
	long x = bfd_get_32 (abfd, (bfd_byte *) data + octets);
	relocation = -relocation;
	DOIT (x);
	bfd_put_32 (abfd, (bfd_vma) x, (bfd_byte *) data + octets);
      }
      break;

    case -1:
      {
	long x = bfd_get_16 (abfd, (bfd_byte *) data + octets);
	relocation = -relocation;
	DOIT (x);
	bfd_put_16 (abfd, (bfd_vma) x, (bfd_byte *) data + octets);
      }
      break;

    case 3:
      /* Do nothing */
      break;

    case 4:
#ifdef BFD64
      {
	bfd_vma x = bfd_get_64 (abfd, (bfd_byte *) data + octets);
	DOIT (x);
	bfd_put_64 (abfd, x, (bfd_byte *) data + octets);
      }
#else
      abort ();
#endif
      break;
    default:
      return bfd_reloc_other;
    }

  return flag;
}

/*
FUNCTION
	bfd_install_relocation

SYNOPSIS
	bfd_reloc_status_type bfd_install_relocation
          (bfd *abfd,
           arelent *reloc_entry,
           void *data, bfd_vma data_start,
           asection *input_section,
	   char **error_message);

DESCRIPTION
	This looks remarkably like <<bfd_perform_relocation>>, except it
	does not expect that the section contents have been filled in.
	I.e., it's suitable for use when creating, rather than applying
	a relocation.

	For now, this function should be considered reserved for the
	assembler.
*/

bfd_reloc_status_type
bfd_install_relocation (bfd *abfd,
			arelent *reloc_entry,
			void *data_start,
			bfd_vma data_start_offset,
			asection *input_section,
			char **error_message)
{
  bfd_vma relocation;
  bfd_reloc_status_type flag = bfd_reloc_ok;
  bfd_size_type octets = reloc_entry->address * bfd_octets_per_byte (abfd);
  bfd_vma output_base = 0;
  reloc_howto_type *howto = reloc_entry->howto;
  asection *reloc_target_output_section;
  asymbol *symbol;
  bfd_byte *data;

  symbol = *(reloc_entry->sym_ptr_ptr);
  if (bfd_is_abs_section (symbol->section))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* If there is a function supplied to handle this relocation type,
     call it.  It'll return `bfd_reloc_continue' if further processing
     can be done.  */
  if (howto->special_function)
    {
      bfd_reloc_status_type cont;

      /* XXX - The special_function calls haven't been fixed up to deal
	 with creating new relocations and section contents.  */
      cont = howto->special_function (abfd, reloc_entry, symbol,
				      /* XXX - Non-portable! */
				      ((bfd_byte *) data_start
				       - data_start_offset),
				      input_section, abfd, error_message);
      if (cont != bfd_reloc_continue)
	return cont;
    }

  /* Is the address of the relocation really within the section?  */
  if (reloc_entry->address > (input_section->_cooked_size
			      / bfd_octets_per_byte (abfd)))
    return bfd_reloc_outofrange;

  /* Work out which section the relocation is targeted at and the
     initial relocation command value.  */

  /* Get symbol value.  (Common symbols are special.)  */
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  reloc_target_output_section = symbol->section->output_section;

  /* Convert input-section-relative symbol value to absolute.  */
  if (! howto->partial_inplace)
    output_base = 0;
  else
    output_base = reloc_target_output_section->vma;

  relocation += output_base + symbol->section->output_offset;

  /* Add in supplied addend.  */
  relocation += reloc_entry->addend;

  /* Here the variable relocation holds the final address of the
     symbol we are relocating against, plus any addend.  */

  if (howto->pc_relative)
    {
      /* This is a PC relative relocation.  We want to set RELOCATION
	 to the distance between the address of the symbol and the
	 location.  RELOCATION is already the address of the symbol.

	 We start by subtracting the address of the section containing
	 the location.

	 If pcrel_offset is set, we must further subtract the position
	 of the location within the section.  Some targets arrange for
	 the addend to be the negative of the position of the location
	 within the section; for example, i386-aout does this.  For
	 i386-aout, pcrel_offset is FALSE.  Some other targets do not
	 include the position of the location; for example, m88kbcs,
	 or ELF.  For those targets, pcrel_offset is TRUE.

	 If we are producing relocatable output, then we must ensure
	 that this reloc will be correctly computed when the final
	 relocation is done.  If pcrel_offset is FALSE we want to wind
	 up with the negative of the location within the section,
	 which means we must adjust the existing addend by the change
	 in the location within the section.  If pcrel_offset is TRUE
	 we do not want to adjust the existing addend at all.

	 FIXME: This seems logical to me, but for the case of
	 producing relocatable output it is not what the code
	 actually does.  I don't want to change it, because it seems
	 far too likely that something will break.  */

      relocation -=
	input_section->output_section->vma + input_section->output_offset;

      if (howto->pcrel_offset && howto->partial_inplace)
	relocation -= reloc_entry->address;
    }

  if (! howto->partial_inplace)
    {
      /* This is a partial relocation, and we want to apply the relocation
	 to the reloc entry rather than the raw data. Modify the reloc
	 inplace to reflect what we now know.  */
      reloc_entry->addend = relocation;
      reloc_entry->address += input_section->output_offset;
      return flag;
    }
  else
    {
      /* This is a partial relocation, but inplace, so modify the
	 reloc record a bit.

	 If we've relocated with a symbol with a section, change
	 into a ref to the section belonging to the symbol.  */
      reloc_entry->address += input_section->output_offset;

      /* WTF?? */
      if (abfd->xvec->flavour == bfd_target_coff_flavour
	  && strcmp (abfd->xvec->name, "coff-Intel-little") != 0
	  && strcmp (abfd->xvec->name, "coff-Intel-big") != 0)
	{
#if 1
/* For m68k-coff, the addend was being subtracted twice during
   relocation with -r.  Removing the line below this comment
   fixes that problem; see PR 2953.

However, Ian wrote the following, regarding removing the line below,
which explains why it is still enabled:  --djm

If you put a patch like that into BFD you need to check all the COFF
linkers.  I am fairly certain that patch will break coff-i386 (e.g.,
SCO); see coff_i386_reloc in coff-i386.c where I worked around the
problem in a different way.  There may very well be a reason that the
code works as it does.

Hmmm.  The first obvious point is that bfd_install_relocation should
not have any tests that depend upon the flavour.  It's seem like
entirely the wrong place for such a thing.  The second obvious point
is that the current code ignores the reloc addend when producing
relocatable output for COFF.  That's peculiar.  In fact, I really
have no idea what the point of the line you want to remove is.

A typical COFF reloc subtracts the old value of the symbol and adds in
the new value to the location in the object file (if it's a pc
relative reloc it adds the difference between the symbol value and the
location).  When relocating we need to preserve that property.

BFD handles this by setting the addend to the negative of the old
value of the symbol.  Unfortunately it handles common symbols in a
non-standard way (it doesn't subtract the old value) but that's a
different story (we can't change it without losing backward
compatibility with old object files) (coff-i386 does subtract the old
value, to be compatible with existing coff-i386 targets, like SCO).

So everything works fine when not producing relocatable output.  When
we are producing relocatable output, logically we should do exactly
what we do when not producing relocatable output.  Therefore, your
patch is correct.  In fact, it should probably always just set
reloc_entry->addend to 0 for all cases, since it is, in fact, going to
add the value into the object file.  This won't hurt the COFF code,
which doesn't use the addend; I'm not sure what it will do to other
formats (the thing to check for would be whether any formats both use
the addend and set partial_inplace).

When I wanted to make coff-i386 produce relocatable output, I ran
into the problem that you are running into: I wanted to remove that
line.  Rather than risk it, I made the coff-i386 relocs use a special
function; it's coff_i386_reloc in coff-i386.c.  The function
specifically adds the addend field into the object file, knowing that
bfd_install_relocation is not going to.  If you remove that line, then
coff-i386.c will wind up adding the addend field in twice.  It's
trivial to fix; it just needs to be done.

The problem with removing the line is just that it may break some
working code.  With BFD it's hard to be sure of anything.  The right
way to deal with this is simply to build and test at least all the
supported COFF targets.  It should be straightforward if time and disk
space consuming.  For each target:
    1) build the linker
    2) generate some executable, and link it using -r (I would
       probably use paranoia.o and link against newlib/libc.a, which
       for all the supported targets would be available in
       /usr/cygnus/progressive/H-host/target/lib/libc.a).
    3) make the change to reloc.c
    4) rebuild the linker
    5) repeat step 2
    6) if the resulting object files are the same, you have at least
       made it no worse
    7) if they are different you have to figure out which version is
       right.  */
	  relocation -= reloc_entry->addend;
#endif
	  reloc_entry->addend = 0;
	}
      else
	{
	  reloc_entry->addend = relocation;
	}
    }

  /* FIXME: This overflow checking is incomplete, because the value
     might have overflowed before we get here.  For a correct check we
     need to compute the value in a size larger than bitsize, but we
     can't reasonably do that for a reloc the same size as a host
     machine word.
     FIXME: We should also do overflow checking on the result after
     adding in the value contained in the object file.  */
  if (howto->complain_on_overflow != complain_overflow_dont)
    flag = bfd_check_overflow (howto->complain_on_overflow,
			       howto->bitsize,
			       howto->rightshift,
			       bfd_arch_bits_per_address (abfd),
			       relocation);

  /* Either we are relocating all the way, or we don't want to apply
     the relocation to the reloc entry (probably because there isn't
     any room in the output format to describe addends to relocs).  */

  /* The cast to bfd_vma avoids a bug in the Alpha OSF/1 C compiler
     (OSF version 1.3, compiler version 3.11).  It miscompiles the
     following program:

     struct str
     {
       unsigned int i0;
     } s = { 0 };

     int
     main ()
     {
       unsigned long x;

       x = 0x100000000;
       x <<= (unsigned long) s.i0;
       if (x == 0)
	 printf ("failed\n");
       else
	 printf ("succeeded (%lx)\n", x);
     }
     */

  relocation >>= (bfd_vma) howto->rightshift;

  /* Shift everything up to where it's going to be used.  */
  relocation <<= (bfd_vma) howto->bitpos;

  /* Wait for the day when all have the mask in them.  */

  /* What we do:
     i instruction to be left alone
     o offset within instruction
     r relocation offset to apply
     S src mask
     D dst mask
     N ~dst mask
     A part 1
     B part 2
     R result

     Do this:
     ((  i i i i i o o o o o  from bfd_get<size>
     and           S S S S S) to get the size offset we want
     +   r r r r r r r r r r) to get the final value to place
     and           D D D D D  to chop to right size
     -----------------------
     =             A A A A A
     And this:
     (   i i i i i o o o o o  from bfd_get<size>
     and N N N N N          ) get instruction
     -----------------------
     =   B B B B B

     And then:
     (   B B B B B
     or            A A A A A)
     -----------------------
     =   R R R R R R R R R R  put into bfd_put<size>
     */

#define DOIT(x) \
  x = ( (x & ~howto->dst_mask) | (((x & howto->src_mask) +  relocation) & howto->dst_mask))

  data = (bfd_byte *) data_start + (octets - data_start_offset);

  switch (howto->size)
    {
    case 0:
      {
	char x = bfd_get_8 (abfd, data);
	DOIT (x);
	bfd_put_8 (abfd, x, data);
      }
      break;

    case 1:
      {
	short x = bfd_get_16 (abfd, data);
	DOIT (x);
	bfd_put_16 (abfd, (bfd_vma) x, data);
      }
      break;
    case 2:
      {
	long x = bfd_get_32 (abfd, data);
	DOIT (x);
	bfd_put_32 (abfd, (bfd_vma) x, data);
      }
      break;
    case -2:
      {
	long x = bfd_get_32 (abfd, data);
	relocation = -relocation;
	DOIT (x);
	bfd_put_32 (abfd, (bfd_vma) x, data);
      }
      break;

    case 3:
      /* Do nothing */
      break;

    case 4:
      {
	bfd_vma x = bfd_get_64 (abfd, data);
	DOIT (x);
	bfd_put_64 (abfd, x, data);
      }
      break;
    default:
      return bfd_reloc_other;
    }

  return flag;
}

/* This relocation routine is used by some of the backend linkers.
   They do not construct asymbol or arelent structures, so there is no
   reason for them to use bfd_perform_relocation.  Also,
   bfd_perform_relocation is so hacked up it is easier to write a new
   function than to try to deal with it.

   This routine does a final relocation.  Whether it is useful for a
   relocatable link depends upon how the object format defines
   relocations.

   FIXME: This routine ignores any special_function in the HOWTO,
   since the existing special_function values have been written for
   bfd_perform_relocation.

   HOWTO is the reloc howto information.
   INPUT_BFD is the BFD which the reloc applies to.
   INPUT_SECTION is the section which the reloc applies to.
   CONTENTS is the contents of the section.
   ADDRESS is the address of the reloc within INPUT_SECTION.
   VALUE is the value of the symbol the reloc refers to.
   ADDEND is the addend of the reloc.  */

bfd_reloc_status_type
_bfd_final_link_relocate (reloc_howto_type *howto,
			  bfd *input_bfd,
			  asection *input_section,
			  bfd_byte *contents,
			  bfd_vma address,
			  bfd_vma value,
			  bfd_vma addend)
{
  bfd_vma relocation;

  /* Sanity check the address.  */
  if (address > input_section->_raw_size)
    return bfd_reloc_outofrange;

  /* This function assumes that we are dealing with a basic relocation
     against a symbol.  We want to compute the value of the symbol to
     relocate to.  This is just VALUE, the value of the symbol, plus
     ADDEND, any addend associated with the reloc.  */
  relocation = value + addend;

  /* If the relocation is PC relative, we want to set RELOCATION to
     the distance between the symbol (currently in RELOCATION) and the
     location we are relocating.  Some targets (e.g., i386-aout)
     arrange for the contents of the section to be the negative of the
     offset of the location within the section; for such targets
     pcrel_offset is FALSE.  Other targets (e.g., m88kbcs or ELF)
     simply leave the contents of the section as zero; for such
     targets pcrel_offset is TRUE.  If pcrel_offset is FALSE we do not
     need to subtract out the offset of the location within the
     section (which is just ADDRESS).  */
  if (howto->pc_relative)
    {
      relocation -= (input_section->output_section->vma
		     + input_section->output_offset);
      if (howto->pcrel_offset)
	relocation -= address;
    }

  return _bfd_relocate_contents (howto, input_bfd, relocation,
				 contents + address);
}

/* Relocate a given location using a given value and howto.  */

bfd_reloc_status_type
_bfd_relocate_contents (reloc_howto_type *howto,
			bfd *input_bfd,
			bfd_vma relocation,
			bfd_byte *location)
{
  int size;
  bfd_vma x = 0;
  bfd_reloc_status_type flag;
  unsigned int rightshift = howto->rightshift;
  unsigned int bitpos = howto->bitpos;

  /* If the size is negative, negate RELOCATION.  This isn't very
     general.  */
  if (howto->size < 0)
    relocation = -relocation;

  /* Get the value we are going to relocate.  */
  size = bfd_get_reloc_size (howto);
  switch (size)
    {
    default:
    case 0:
      abort ();
    case 1:
      x = bfd_get_8 (input_bfd, location);
      break;
    case 2:
      x = bfd_get_16 (input_bfd, location);
      break;
    case 4:
      x = bfd_get_32 (input_bfd, location);
      break;
    case 8:
#ifdef BFD64
      x = bfd_get_64 (input_bfd, location);
#else
      abort ();
#endif
      break;
    }

  /* Check for overflow.  FIXME: We may drop bits during the addition
     which we don't check for.  We must either check at every single
     operation, which would be tedious, or we must do the computations
     in a type larger than bfd_vma, which would be inefficient.  */
  flag = bfd_reloc_ok;
  if (howto->complain_on_overflow != complain_overflow_dont)
    {
      bfd_vma addrmask, fieldmask, signmask, ss;
      bfd_vma a, b, sum;

      /* Get the values to be added together.  For signed and unsigned
         relocations, we assume that all values should be truncated to
         the size of an address.  For bitfields, all the bits matter.
         See also bfd_check_overflow.  */
      fieldmask = N_ONES (howto->bitsize);
      addrmask = N_ONES (bfd_arch_bits_per_address (input_bfd)) | fieldmask;
      a = relocation;
      b = x & howto->src_mask;

      switch (howto->complain_on_overflow)
	{
	case complain_overflow_signed:
	  a = (a & addrmask) >> rightshift;

	  /* If any sign bits are set, all sign bits must be set.
	     That is, A must be a valid negative address after
	     shifting.  */
	  signmask = ~ (fieldmask >> 1);
	  ss = a & signmask;
	  if (ss != 0 && ss != ((addrmask >> rightshift) & signmask))
	    flag = bfd_reloc_overflow;

	  /* We only need this next bit of code if the sign bit of B
             is below the sign bit of A.  This would only happen if
             SRC_MASK had fewer bits than BITSIZE.  Note that if
             SRC_MASK has more bits than BITSIZE, we can get into
             trouble; we would need to verify that B is in range, as
             we do for A above.  */
	  signmask = ((~ howto->src_mask) >> 1) & howto->src_mask;

	  /* Set all the bits above the sign bit.  */
	  b = (b ^ signmask) - signmask;

	  b = (b & addrmask) >> bitpos;

	  /* Now we can do the addition.  */
	  sum = a + b;

	  /* See if the result has the correct sign.  Bits above the
             sign bit are junk now; ignore them.  If the sum is
             positive, make sure we did not have all negative inputs;
             if the sum is negative, make sure we did not have all
             positive inputs.  The test below looks only at the sign
             bits, and it really just
	         SIGN (A) == SIGN (B) && SIGN (A) != SIGN (SUM)
	     */
	  signmask = (fieldmask >> 1) + 1;
	  if (((~ (a ^ b)) & (a ^ sum)) & signmask)
	    flag = bfd_reloc_overflow;

	  break;

	case complain_overflow_unsigned:
	  /* Checking for an unsigned overflow is relatively easy:
             trim the addresses and add, and trim the result as well.
             Overflow is normally indicated when the result does not
             fit in the field.  However, we also need to consider the
             case when, e.g., fieldmask is 0x7fffffff or smaller, an
             input is 0x80000000, and bfd_vma is only 32 bits; then we
             will get sum == 0, but there is an overflow, since the
             inputs did not fit in the field.  Instead of doing a
             separate test, we can check for this by or-ing in the
             operands when testing for the sum overflowing its final
             field.  */
	  a = (a & addrmask) >> rightshift;
	  b = (b & addrmask) >> bitpos;
	  sum = (a + b) & addrmask;
	  if ((a | b | sum) & ~ fieldmask)
	    flag = bfd_reloc_overflow;

	  break;

	case complain_overflow_bitfield:
	  /* Much like the signed check, but for a field one bit
	     wider, and no trimming inputs with addrmask.  We allow a
	     bitfield to represent numbers in the range -2**n to
	     2**n-1, where n is the number of bits in the field.
	     Note that when bfd_vma is 32 bits, a 32-bit reloc can't
	     overflow, which is exactly what we want.  */
	  a >>= rightshift;

	  signmask = ~ fieldmask;
	  ss = a & signmask;
	  if (ss != 0 && ss != (((bfd_vma) -1 >> rightshift) & signmask))
	    flag = bfd_reloc_overflow;

	  signmask = ((~ howto->src_mask) >> 1) & howto->src_mask;
	  b = (b ^ signmask) - signmask;

	  b >>= bitpos;

	  sum = a + b;

	  /* We mask with addrmask here to explicitly allow an address
	     wrap-around.  The Linux kernel relies on it, and it is
	     the only way to write assembler code which can run when
	     loaded at a location 0x80000000 away from the location at
	     which it is linked.  */
	  signmask = fieldmask + 1;
	  if (((~ (a ^ b)) & (a ^ sum)) & signmask & addrmask)
	    flag = bfd_reloc_overflow;

	  break;

	default:
	  abort ();
	}
    }

  /* Put RELOCATION in the right bits.  */
  relocation >>= (bfd_vma) rightshift;
  relocation <<= (bfd_vma) bitpos;

  /* Add RELOCATION to the right bits of X.  */
  x = ((x & ~howto->dst_mask)
       | (((x & howto->src_mask) + relocation) & howto->dst_mask));

  /* Put the relocated value back in the object file.  */
  switch (size)
    {
    default:
    case 0:
      abort ();
    case 1:
      bfd_put_8 (input_bfd, x, location);
      break;
    case 2:
      bfd_put_16 (input_bfd, x, location);
      break;
    case 4:
      bfd_put_32 (input_bfd, x, location);
      break;
    case 8:
#ifdef BFD64
      bfd_put_64 (input_bfd, x, location);
#else
      abort ();
#endif
      break;
    }

  return flag;
}

/*
DOCDD
INODE
	howto manager,  , typedef arelent, Relocations

SECTION
	The howto manager

	When an application wants to create a relocation, but doesn't
	know what the target machine might call it, it can find out by
	using this bit of code.

*/

/*
TYPEDEF
	bfd_reloc_code_type

DESCRIPTION
	The insides of a reloc code.  The idea is that, eventually, there
	will be one enumerator for every type of relocation we ever do.
	Pass one of these values to <<bfd_reloc_type_lookup>>, and it'll
	return a howto pointer.

	This does mean that the application must determine the correct
	enumerator value; you can't get a howto pointer from a random set
	of attributes.

SENUM
   bfd_reloc_code_real

ENUM
  BFD_RELOC_64
ENUMX
  BFD_RELOC_32
ENUMX
  BFD_RELOC_26
ENUMX
  BFD_RELOC_24
ENUMX
  BFD_RELOC_16
ENUMX
  BFD_RELOC_14
ENUMX
  BFD_RELOC_8
ENUMDOC
  Basic absolute relocations of N bits.

ENUM
  BFD_RELOC_64_PCREL
ENUMX
  BFD_RELOC_32_PCREL
ENUMX
  BFD_RELOC_24_PCREL
ENUMX
  BFD_RELOC_16_PCREL
ENUMX
  BFD_RELOC_12_PCREL
ENUMX
  BFD_RELOC_8_PCREL
ENUMDOC
  PC-relative relocations.  Sometimes these are relative to the address
of the relocation itself; sometimes they are relative to the start of
the section containing the relocation.  It depends on the specific target.

The 24-bit relocation is used in some Intel 960 configurations.

ENUM
  BFD_RELOC_32_GOT_PCREL
ENUMX
  BFD_RELOC_16_GOT_PCREL
ENUMX
  BFD_RELOC_8_GOT_PCREL
ENUMX
  BFD_RELOC_32_GOTOFF
ENUMX
  BFD_RELOC_16_GOTOFF
ENUMX
  BFD_RELOC_LO16_GOTOFF
ENUMX
  BFD_RELOC_HI16_GOTOFF
ENUMX
  BFD_RELOC_HI16_S_GOTOFF
ENUMX
  BFD_RELOC_8_GOTOFF
ENUMX
  BFD_RELOC_64_PLT_PCREL
ENUMX
  BFD_RELOC_32_PLT_PCREL
ENUMX
  BFD_RELOC_24_PLT_PCREL
ENUMX
  BFD_RELOC_16_PLT_PCREL
ENUMX
  BFD_RELOC_8_PLT_PCREL
ENUMX
  BFD_RELOC_64_PLTOFF
ENUMX
  BFD_RELOC_32_PLTOFF
ENUMX
  BFD_RELOC_16_PLTOFF
ENUMX
  BFD_RELOC_LO16_PLTOFF
ENUMX
  BFD_RELOC_HI16_PLTOFF
ENUMX
  BFD_RELOC_HI16_S_PLTOFF
ENUMX
  BFD_RELOC_8_PLTOFF
ENUMDOC
  For ELF.

ENUM
  BFD_RELOC_68K_GLOB_DAT
ENUMX
  BFD_RELOC_68K_JMP_SLOT
ENUMX
  BFD_RELOC_68K_RELATIVE
ENUMDOC
  Relocations used by 68K ELF.

ENUM
  BFD_RELOC_32_BASEREL
ENUMX
  BFD_RELOC_16_BASEREL
ENUMX
  BFD_RELOC_LO16_BASEREL
ENUMX
  BFD_RELOC_HI16_BASEREL
ENUMX
  BFD_RELOC_HI16_S_BASEREL
ENUMX
  BFD_RELOC_8_BASEREL
ENUMX
  BFD_RELOC_RVA
ENUMDOC
  Linkage-table relative.

ENUM
  BFD_RELOC_8_FFnn
ENUMDOC
  Absolute 8-bit relocation, but used to form an address like 0xFFnn.

ENUM
  BFD_RELOC_32_PCREL_S2
ENUMX
  BFD_RELOC_16_PCREL_S2
ENUMX
  BFD_RELOC_23_PCREL_S2
ENUMX
  BFD_RELOC_18_PCREL_S2
ENUMX
  BFD_RELOC_28_PCREL_S2
ENUMDOC
  These PC-relative relocations are stored as word displacements --
i.e., byte displacements shifted right two bits.  The 30-bit word
displacement (<<32_PCREL_S2>> -- 32 bits, shifted 2) is used on the
SPARC.  (SPARC tools generally refer to this as <<WDISP30>>.)  The
signed 16-bit displacement is used on the MIPS, and the 23-bit
displacement is used on the Alpha.

ENUM
  BFD_RELOC_HI22
ENUMX
  BFD_RELOC_LO10
ENUMDOC
  High 22 bits and low 10 bits of 32-bit value, placed into lower bits of
the target word.  These are used on the SPARC.

ENUM
  BFD_RELOC_GPREL16
ENUMX
  BFD_RELOC_GPREL32
ENUMDOC
  For systems that allocate a Global Pointer register, these are
displacements off that register.  These relocation types are
handled specially, because the value the register will have is
decided relatively late.

ENUM
  BFD_RELOC_I960_CALLJ
ENUMDOC
  Reloc types used for i960/b.out.

ENUM
  BFD_RELOC_NONE
ENUMX
  BFD_RELOC_SPARC_WDISP22
ENUMX
  BFD_RELOC_SPARC22
ENUMX
  BFD_RELOC_SPARC13
ENUMX
  BFD_RELOC_SPARC_GOT10
ENUMX
  BFD_RELOC_SPARC_GOT13
ENUMX
  BFD_RELOC_SPARC_GOT22
ENUMX
  BFD_RELOC_SPARC_PC10
ENUMX
  BFD_RELOC_SPARC_PC22
ENUMX
  BFD_RELOC_SPARC_WPLT30
ENUMX
  BFD_RELOC_SPARC_COPY
ENUMX
  BFD_RELOC_SPARC_GLOB_DAT
ENUMX
  BFD_RELOC_SPARC_JMP_SLOT
ENUMX
  BFD_RELOC_SPARC_RELATIVE
ENUMX
  BFD_RELOC_SPARC_UA16
ENUMX
  BFD_RELOC_SPARC_UA32
ENUMX
  BFD_RELOC_SPARC_UA64
ENUMDOC
  SPARC ELF relocations.  There is probably some overlap with other
  relocation types already defined.

ENUM
  BFD_RELOC_SPARC_BASE13
ENUMX
  BFD_RELOC_SPARC_BASE22
ENUMDOC
  I think these are specific to SPARC a.out (e.g., Sun 4).

ENUMEQ
  BFD_RELOC_SPARC_64
  BFD_RELOC_64
ENUMX
  BFD_RELOC_SPARC_10
ENUMX
  BFD_RELOC_SPARC_11
ENUMX
  BFD_RELOC_SPARC_OLO10
ENUMX
  BFD_RELOC_SPARC_HH22
ENUMX
  BFD_RELOC_SPARC_HM10
ENUMX
  BFD_RELOC_SPARC_LM22
ENUMX
  BFD_RELOC_SPARC_PC_HH22
ENUMX
  BFD_RELOC_SPARC_PC_HM10
ENUMX
  BFD_RELOC_SPARC_PC_LM22
ENUMX
  BFD_RELOC_SPARC_WDISP16
ENUMX
  BFD_RELOC_SPARC_WDISP19
ENUMX
  BFD_RELOC_SPARC_7
ENUMX
  BFD_RELOC_SPARC_6
ENUMX
  BFD_RELOC_SPARC_5
ENUMEQX
  BFD_RELOC_SPARC_DISP64
  BFD_RELOC_64_PCREL
ENUMX
  BFD_RELOC_SPARC_PLT32
ENUMX
  BFD_RELOC_SPARC_PLT64
ENUMX
  BFD_RELOC_SPARC_HIX22
ENUMX
  BFD_RELOC_SPARC_LOX10
ENUMX
  BFD_RELOC_SPARC_H44
ENUMX
  BFD_RELOC_SPARC_M44
ENUMX
  BFD_RELOC_SPARC_L44
ENUMX
  BFD_RELOC_SPARC_REGISTER
ENUMDOC
  SPARC64 relocations

ENUM
  BFD_RELOC_SPARC_REV32
ENUMDOC
  SPARC little endian relocation
ENUM
  BFD_RELOC_SPARC_TLS_GD_HI22
ENUMX
  BFD_RELOC_SPARC_TLS_GD_LO10
ENUMX
  BFD_RELOC_SPARC_TLS_GD_ADD
ENUMX
  BFD_RELOC_SPARC_TLS_GD_CALL
ENUMX
  BFD_RELOC_SPARC_TLS_LDM_HI22
ENUMX
  BFD_RELOC_SPARC_TLS_LDM_LO10
ENUMX
  BFD_RELOC_SPARC_TLS_LDM_ADD
ENUMX
  BFD_RELOC_SPARC_TLS_LDM_CALL
ENUMX
  BFD_RELOC_SPARC_TLS_LDO_HIX22
ENUMX
  BFD_RELOC_SPARC_TLS_LDO_LOX10
ENUMX
  BFD_RELOC_SPARC_TLS_LDO_ADD
ENUMX
  BFD_RELOC_SPARC_TLS_IE_HI22
ENUMX
  BFD_RELOC_SPARC_TLS_IE_LO10
ENUMX
  BFD_RELOC_SPARC_TLS_IE_LD
ENUMX
  BFD_RELOC_SPARC_TLS_IE_LDX
ENUMX
  BFD_RELOC_SPARC_TLS_IE_ADD
ENUMX
  BFD_RELOC_SPARC_TLS_LE_HIX22
ENUMX
  BFD_RELOC_SPARC_TLS_LE_LOX10
ENUMX
  BFD_RELOC_SPARC_TLS_DTPMOD32
ENUMX
  BFD_RELOC_SPARC_TLS_DTPMOD64
ENUMX
  BFD_RELOC_SPARC_TLS_DTPOFF32
ENUMX
  BFD_RELOC_SPARC_TLS_DTPOFF64
ENUMX
  BFD_RELOC_SPARC_TLS_TPOFF32
ENUMX
  BFD_RELOC_SPARC_TLS_TPOFF64
ENUMDOC
  SPARC TLS relocations

ENUM
  BFD_RELOC_ALPHA_GPDISP_HI16
ENUMDOC
  Alpha ECOFF and ELF relocations.  Some of these treat the symbol or
     "addend" in some special way.
  For GPDISP_HI16 ("gpdisp") relocations, the symbol is ignored when
     writing; when reading, it will be the absolute section symbol.  The
     addend is the displacement in bytes of the "lda" instruction from
     the "ldah" instruction (which is at the address of this reloc).
ENUM
  BFD_RELOC_ALPHA_GPDISP_LO16
ENUMDOC
  For GPDISP_LO16 ("ignore") relocations, the symbol is handled as
     with GPDISP_HI16 relocs.  The addend is ignored when writing the
     relocations out, and is filled in with the file's GP value on
     reading, for convenience.

ENUM
  BFD_RELOC_ALPHA_GPDISP
ENUMDOC
  The ELF GPDISP relocation is exactly the same as the GPDISP_HI16
     relocation except that there is no accompanying GPDISP_LO16
     relocation.

ENUM
  BFD_RELOC_ALPHA_LITERAL
ENUMX
  BFD_RELOC_ALPHA_ELF_LITERAL
ENUMX
  BFD_RELOC_ALPHA_LITUSE
ENUMDOC
  The Alpha LITERAL/LITUSE relocs are produced by a symbol reference;
     the assembler turns it into a LDQ instruction to load the address of
     the symbol, and then fills in a register in the real instruction.

     The LITERAL reloc, at the LDQ instruction, refers to the .lita
     section symbol.  The addend is ignored when writing, but is filled
     in with the file's GP value on reading, for convenience, as with the
     GPDISP_LO16 reloc.

     The ELF_LITERAL reloc is somewhere between 16_GOTOFF and GPDISP_LO16.
     It should refer to the symbol to be referenced, as with 16_GOTOFF,
     but it generates output not based on the position within the .got
     section, but relative to the GP value chosen for the file during the
     final link stage.

     The LITUSE reloc, on the instruction using the loaded address, gives
     information to the linker that it might be able to use to optimize
     away some literal section references.  The symbol is ignored (read
     as the absolute section symbol), and the "addend" indicates the type
     of instruction using the register:
              1 - "memory" fmt insn
              2 - byte-manipulation (byte offset reg)
              3 - jsr (target of branch)

ENUM
  BFD_RELOC_ALPHA_HINT
ENUMDOC
  The HINT relocation indicates a value that should be filled into the
     "hint" field of a jmp/jsr/ret instruction, for possible branch-
     prediction logic which may be provided on some processors.

ENUM
  BFD_RELOC_ALPHA_LINKAGE
ENUMDOC
  The LINKAGE relocation outputs a linkage pair in the object file,
     which is filled by the linker.

ENUM
  BFD_RELOC_ALPHA_CODEADDR
ENUMDOC
  The CODEADDR relocation outputs a STO_CA in the object file,
     which is filled by the linker.

ENUM
  BFD_RELOC_ALPHA_GPREL_HI16
ENUMX
  BFD_RELOC_ALPHA_GPREL_LO16
ENUMDOC
  The GPREL_HI/LO relocations together form a 32-bit offset from the
     GP register.

ENUM
  BFD_RELOC_ALPHA_BRSGP
ENUMDOC
  Like BFD_RELOC_23_PCREL_S2, except that the source and target must
  share a common GP, and the target address is adjusted for
  STO_ALPHA_STD_GPLOAD.

ENUM
  BFD_RELOC_ALPHA_TLSGD
ENUMX
  BFD_RELOC_ALPHA_TLSLDM
ENUMX
  BFD_RELOC_ALPHA_DTPMOD64
ENUMX
  BFD_RELOC_ALPHA_GOTDTPREL16
ENUMX
  BFD_RELOC_ALPHA_DTPREL64
ENUMX
  BFD_RELOC_ALPHA_DTPREL_HI16
ENUMX
  BFD_RELOC_ALPHA_DTPREL_LO16
ENUMX
  BFD_RELOC_ALPHA_DTPREL16
ENUMX
  BFD_RELOC_ALPHA_GOTTPREL16
ENUMX
  BFD_RELOC_ALPHA_TPREL64
ENUMX
  BFD_RELOC_ALPHA_TPREL_HI16
ENUMX
  BFD_RELOC_ALPHA_TPREL_LO16
ENUMX
  BFD_RELOC_ALPHA_TPREL16
ENUMDOC
  Alpha thread-local storage relocations.

ENUM
  BFD_RELOC_MIPS_JMP
ENUMDOC
  Bits 27..2 of the relocation address shifted right 2 bits;
     simple reloc otherwise.

ENUM
  BFD_RELOC_MIPS16_JMP
ENUMDOC
  The MIPS16 jump instruction.

ENUM
  BFD_RELOC_MIPS16_GPREL
ENUMDOC
  MIPS16 GP relative reloc.

ENUM
  BFD_RELOC_HI16
ENUMDOC
  High 16 bits of 32-bit value; simple reloc.
ENUM
  BFD_RELOC_HI16_S
ENUMDOC
  High 16 bits of 32-bit value but the low 16 bits will be sign
     extended and added to form the final result.  If the low 16
     bits form a negative number, we need to add one to the high value
     to compensate for the borrow when the low bits are added.
ENUM
  BFD_RELOC_LO16
ENUMDOC
  Low 16 bits.
ENUM
  BFD_RELOC_PCREL_HI16_S
ENUMDOC
  Like BFD_RELOC_HI16_S, but PC relative.
ENUM
  BFD_RELOC_PCREL_LO16
ENUMDOC
  Like BFD_RELOC_LO16, but PC relative.

ENUM
  BFD_RELOC_MIPS_LITERAL
ENUMDOC
  Relocation against a MIPS literal section.

ENUM
  BFD_RELOC_MIPS_GOT16
ENUMX
  BFD_RELOC_MIPS_CALL16
ENUMX
  BFD_RELOC_MIPS_GOT_HI16
ENUMX
  BFD_RELOC_MIPS_GOT_LO16
ENUMX
  BFD_RELOC_MIPS_CALL_HI16
ENUMX
  BFD_RELOC_MIPS_CALL_LO16
ENUMX
  BFD_RELOC_MIPS_SUB
ENUMX
  BFD_RELOC_MIPS_GOT_PAGE
ENUMX
  BFD_RELOC_MIPS_GOT_OFST
ENUMX
  BFD_RELOC_MIPS_GOT_DISP
ENUMX
  BFD_RELOC_MIPS_SHIFT5
ENUMX
  BFD_RELOC_MIPS_SHIFT6
ENUMX
  BFD_RELOC_MIPS_INSERT_A
ENUMX
  BFD_RELOC_MIPS_INSERT_B
ENUMX
  BFD_RELOC_MIPS_DELETE
ENUMX
  BFD_RELOC_MIPS_HIGHEST
ENUMX
  BFD_RELOC_MIPS_HIGHER
ENUMX
  BFD_RELOC_MIPS_SCN_DISP
ENUMX
  BFD_RELOC_MIPS_REL16
ENUMX
  BFD_RELOC_MIPS_RELGOT
ENUMX
  BFD_RELOC_MIPS_JALR
ENUMDOC
  MIPS ELF relocations.
COMMENT

ENUM
  BFD_RELOC_FRV_LABEL16
ENUMX
  BFD_RELOC_FRV_LABEL24
ENUMX
  BFD_RELOC_FRV_LO16
ENUMX
  BFD_RELOC_FRV_HI16
ENUMX
  BFD_RELOC_FRV_GPREL12
ENUMX
  BFD_RELOC_FRV_GPRELU12
ENUMX
  BFD_RELOC_FRV_GPREL32
ENUMX
  BFD_RELOC_FRV_GPRELHI
ENUMX
  BFD_RELOC_FRV_GPRELLO
ENUMX
  BFD_RELOC_FRV_GOT12
ENUMX
  BFD_RELOC_FRV_GOTHI
ENUMX
  BFD_RELOC_FRV_GOTLO
ENUMX
  BFD_RELOC_FRV_FUNCDESC
ENUMX
  BFD_RELOC_FRV_FUNCDESC_GOT12
ENUMX
  BFD_RELOC_FRV_FUNCDESC_GOTHI
ENUMX
  BFD_RELOC_FRV_FUNCDESC_GOTLO
ENUMX
  BFD_RELOC_FRV_FUNCDESC_VALUE
ENUMX
  BFD_RELOC_FRV_FUNCDESC_GOTOFF12
ENUMX
  BFD_RELOC_FRV_FUNCDESC_GOTOFFHI
ENUMX
  BFD_RELOC_FRV_FUNCDESC_GOTOFFLO
ENUMX
  BFD_RELOC_FRV_GOTOFF12
ENUMX
  BFD_RELOC_FRV_GOTOFFHI
ENUMX
  BFD_RELOC_FRV_GOTOFFLO
ENUMDOC
  Fujitsu Frv Relocations.
COMMENT

ENUM
  BFD_RELOC_MN10300_GOTOFF24
ENUMDOC
  This is a 24bit GOT-relative reloc for the mn10300.
ENUM
  BFD_RELOC_MN10300_GOT32
ENUMDOC
  This is a 32bit GOT-relative reloc for the mn10300, offset by two bytes
  in the instruction.
ENUM
  BFD_RELOC_MN10300_GOT24
ENUMDOC
  This is a 24bit GOT-relative reloc for the mn10300, offset by two bytes
  in the instruction.
ENUM
  BFD_RELOC_MN10300_GOT16
ENUMDOC
  This is a 16bit GOT-relative reloc for the mn10300, offset by two bytes
  in the instruction.
ENUM
  BFD_RELOC_MN10300_COPY
ENUMDOC
  Copy symbol at runtime.
ENUM
  BFD_RELOC_MN10300_GLOB_DAT
ENUMDOC
  Create GOT entry.
ENUM
  BFD_RELOC_MN10300_JMP_SLOT
ENUMDOC
  Create PLT entry.
ENUM
  BFD_RELOC_MN10300_RELATIVE
ENUMDOC
  Adjust by program base.
COMMENT

ENUM
  BFD_RELOC_386_GOT32
ENUMX
  BFD_RELOC_386_PLT32
ENUMX
  BFD_RELOC_386_COPY
ENUMX
  BFD_RELOC_386_GLOB_DAT
ENUMX
  BFD_RELOC_386_JUMP_SLOT
ENUMX
  BFD_RELOC_386_RELATIVE
ENUMX
  BFD_RELOC_386_GOTOFF
ENUMX
  BFD_RELOC_386_GOTPC
ENUMX
  BFD_RELOC_386_TLS_TPOFF
ENUMX
  BFD_RELOC_386_TLS_IE
ENUMX
  BFD_RELOC_386_TLS_GOTIE
ENUMX
  BFD_RELOC_386_TLS_LE
ENUMX
  BFD_RELOC_386_TLS_GD
ENUMX
  BFD_RELOC_386_TLS_LDM
ENUMX
  BFD_RELOC_386_TLS_LDO_32
ENUMX
  BFD_RELOC_386_TLS_IE_32
ENUMX
  BFD_RELOC_386_TLS_LE_32
ENUMX
  BFD_RELOC_386_TLS_DTPMOD32
ENUMX
  BFD_RELOC_386_TLS_DTPOFF32
ENUMX
  BFD_RELOC_386_TLS_TPOFF32
ENUMDOC
  i386/elf relocations

ENUM
  BFD_RELOC_X86_64_GOT32
ENUMX
  BFD_RELOC_X86_64_PLT32
ENUMX
  BFD_RELOC_X86_64_COPY
ENUMX
  BFD_RELOC_X86_64_GLOB_DAT
ENUMX
  BFD_RELOC_X86_64_JUMP_SLOT
ENUMX
  BFD_RELOC_X86_64_RELATIVE
ENUMX
  BFD_RELOC_X86_64_GOTPCREL
ENUMX
  BFD_RELOC_X86_64_32S
ENUMX
  BFD_RELOC_X86_64_DTPMOD64
ENUMX
  BFD_RELOC_X86_64_DTPOFF64
ENUMX
  BFD_RELOC_X86_64_TPOFF64
ENUMX
  BFD_RELOC_X86_64_TLSGD
ENUMX
  BFD_RELOC_X86_64_TLSLD
ENUMX
  BFD_RELOC_X86_64_DTPOFF32
ENUMX
  BFD_RELOC_X86_64_GOTTPOFF
ENUMX
  BFD_RELOC_X86_64_TPOFF32
ENUMDOC
  x86-64/elf relocations

ENUM
  BFD_RELOC_NS32K_IMM_8
ENUMX
  BFD_RELOC_NS32K_IMM_16
ENUMX
  BFD_RELOC_NS32K_IMM_32
ENUMX
  BFD_RELOC_NS32K_IMM_8_PCREL
ENUMX
  BFD_RELOC_NS32K_IMM_16_PCREL
ENUMX
  BFD_RELOC_NS32K_IMM_32_PCREL
ENUMX
  BFD_RELOC_NS32K_DISP_8
ENUMX
  BFD_RELOC_NS32K_DISP_16
ENUMX
  BFD_RELOC_NS32K_DISP_32
ENUMX
  BFD_RELOC_NS32K_DISP_8_PCREL
ENUMX
  BFD_RELOC_NS32K_DISP_16_PCREL
ENUMX
  BFD_RELOC_NS32K_DISP_32_PCREL
ENUMDOC
  ns32k relocations

ENUM
  BFD_RELOC_PDP11_DISP_8_PCREL
ENUMX
  BFD_RELOC_PDP11_DISP_6_PCREL
ENUMDOC
  PDP11 relocations

ENUM
  BFD_RELOC_PJ_CODE_HI16
ENUMX
  BFD_RELOC_PJ_CODE_LO16
ENUMX
  BFD_RELOC_PJ_CODE_DIR16
ENUMX
  BFD_RELOC_PJ_CODE_DIR32
ENUMX
  BFD_RELOC_PJ_CODE_REL16
ENUMX
  BFD_RELOC_PJ_CODE_REL32
ENUMDOC
  Picojava relocs.  Not all of these appear in object files.

ENUM
  BFD_RELOC_PPC_B26
ENUMX
  BFD_RELOC_PPC_BA26
ENUMX
  BFD_RELOC_PPC_TOC16
ENUMX
  BFD_RELOC_PPC_B16
ENUMX
  BFD_RELOC_PPC_B16_BRTAKEN
ENUMX
  BFD_RELOC_PPC_B16_BRNTAKEN
ENUMX
  BFD_RELOC_PPC_BA16
ENUMX
  BFD_RELOC_PPC_BA16_BRTAKEN
ENUMX
  BFD_RELOC_PPC_BA16_BRNTAKEN
ENUMX
  BFD_RELOC_PPC_COPY
ENUMX
  BFD_RELOC_PPC_GLOB_DAT
ENUMX
  BFD_RELOC_PPC_JMP_SLOT
ENUMX
  BFD_RELOC_PPC_RELATIVE
ENUMX
  BFD_RELOC_PPC_LOCAL24PC
ENUMX
  BFD_RELOC_PPC_EMB_NADDR32
ENUMX
  BFD_RELOC_PPC_EMB_NADDR16
ENUMX
  BFD_RELOC_PPC_EMB_NADDR16_LO
ENUMX
  BFD_RELOC_PPC_EMB_NADDR16_HI
ENUMX
  BFD_RELOC_PPC_EMB_NADDR16_HA
ENUMX
  BFD_RELOC_PPC_EMB_SDAI16
ENUMX
  BFD_RELOC_PPC_EMB_SDA2I16
ENUMX
  BFD_RELOC_PPC_EMB_SDA2REL
ENUMX
  BFD_RELOC_PPC_EMB_SDA21
ENUMX
  BFD_RELOC_PPC_EMB_MRKREF
ENUMX
  BFD_RELOC_PPC_EMB_RELSEC16
ENUMX
  BFD_RELOC_PPC_EMB_RELST_LO
ENUMX
  BFD_RELOC_PPC_EMB_RELST_HI
ENUMX
  BFD_RELOC_PPC_EMB_RELST_HA
ENUMX
  BFD_RELOC_PPC_EMB_BIT_FLD
ENUMX
  BFD_RELOC_PPC_EMB_RELSDA
ENUMX
  BFD_RELOC_PPC64_HIGHER
ENUMX
  BFD_RELOC_PPC64_HIGHER_S
ENUMX
  BFD_RELOC_PPC64_HIGHEST
ENUMX
  BFD_RELOC_PPC64_HIGHEST_S
ENUMX
  BFD_RELOC_PPC64_TOC16_LO
ENUMX
  BFD_RELOC_PPC64_TOC16_HI
ENUMX
  BFD_RELOC_PPC64_TOC16_HA
ENUMX
  BFD_RELOC_PPC64_TOC
ENUMX
  BFD_RELOC_PPC64_PLTGOT16
ENUMX
  BFD_RELOC_PPC64_PLTGOT16_LO
ENUMX
  BFD_RELOC_PPC64_PLTGOT16_HI
ENUMX
  BFD_RELOC_PPC64_PLTGOT16_HA
ENUMX
  BFD_RELOC_PPC64_ADDR16_DS
ENUMX
  BFD_RELOC_PPC64_ADDR16_LO_DS
ENUMX
  BFD_RELOC_PPC64_GOT16_DS
ENUMX
  BFD_RELOC_PPC64_GOT16_LO_DS
ENUMX
  BFD_RELOC_PPC64_PLT16_LO_DS
ENUMX
  BFD_RELOC_PPC64_SECTOFF_DS
ENUMX
  BFD_RELOC_PPC64_SECTOFF_LO_DS
ENUMX
  BFD_RELOC_PPC64_TOC16_DS
ENUMX
  BFD_RELOC_PPC64_TOC16_LO_DS
ENUMX
  BFD_RELOC_PPC64_PLTGOT16_DS
ENUMX
  BFD_RELOC_PPC64_PLTGOT16_LO_DS
ENUMDOC
  Power(rs6000) and PowerPC relocations.

ENUM
  BFD_RELOC_PPC_TLS
ENUMX
  BFD_RELOC_PPC_DTPMOD
ENUMX
  BFD_RELOC_PPC_TPREL16
ENUMX
  BFD_RELOC_PPC_TPREL16_LO
ENUMX
  BFD_RELOC_PPC_TPREL16_HI
ENUMX
  BFD_RELOC_PPC_TPREL16_HA
ENUMX
  BFD_RELOC_PPC_TPREL
ENUMX
  BFD_RELOC_PPC_DTPREL16
ENUMX
  BFD_RELOC_PPC_DTPREL16_LO
ENUMX
  BFD_RELOC_PPC_DTPREL16_HI
ENUMX
  BFD_RELOC_PPC_DTPREL16_HA
ENUMX
  BFD_RELOC_PPC_DTPREL
ENUMX
  BFD_RELOC_PPC_GOT_TLSGD16
ENUMX
  BFD_RELOC_PPC_GOT_TLSGD16_LO
ENUMX
  BFD_RELOC_PPC_GOT_TLSGD16_HI
ENUMX
  BFD_RELOC_PPC_GOT_TLSGD16_HA
ENUMX
  BFD_RELOC_PPC_GOT_TLSLD16
ENUMX
  BFD_RELOC_PPC_GOT_TLSLD16_LO
ENUMX
  BFD_RELOC_PPC_GOT_TLSLD16_HI
ENUMX
  BFD_RELOC_PPC_GOT_TLSLD16_HA
ENUMX
  BFD_RELOC_PPC_GOT_TPREL16
ENUMX
  BFD_RELOC_PPC_GOT_TPREL16_LO
ENUMX
  BFD_RELOC_PPC_GOT_TPREL16_HI
ENUMX
  BFD_RELOC_PPC_GOT_TPREL16_HA
ENUMX
  BFD_RELOC_PPC_GOT_DTPREL16
ENUMX
  BFD_RELOC_PPC_GOT_DTPREL16_LO
ENUMX
  BFD_RELOC_PPC_GOT_DTPREL16_HI
ENUMX
  BFD_RELOC_PPC_GOT_DTPREL16_HA
ENUMX
  BFD_RELOC_PPC64_TPREL16_DS
ENUMX
  BFD_RELOC_PPC64_TPREL16_LO_DS
ENUMX
  BFD_RELOC_PPC64_TPREL16_HIGHER
ENUMX
  BFD_RELOC_PPC64_TPREL16_HIGHERA
ENUMX
  BFD_RELOC_PPC64_TPREL16_HIGHEST
ENUMX
  BFD_RELOC_PPC64_TPREL16_HIGHESTA
ENUMX
  BFD_RELOC_PPC64_DTPREL16_DS
ENUMX
  BFD_RELOC_PPC64_DTPREL16_LO_DS
ENUMX
  BFD_RELOC_PPC64_DTPREL16_HIGHER
ENUMX
  BFD_RELOC_PPC64_DTPREL16_HIGHERA
ENUMX
  BFD_RELOC_PPC64_DTPREL16_HIGHEST
ENUMX
  BFD_RELOC_PPC64_DTPREL16_HIGHESTA
ENUMDOC
  PowerPC and PowerPC64 thread-local storage relocations.

ENUM
  BFD_RELOC_I370_D12
ENUMDOC
  IBM 370/390 relocations

ENUM
  BFD_RELOC_CTOR
ENUMDOC
  The type of reloc used to build a constructor table - at the moment
  probably a 32 bit wide absolute relocation, but the target can choose.
  It generally does map to one of the other relocation types.

ENUM
  BFD_RELOC_ARM_PCREL_BRANCH
ENUMDOC
  ARM 26 bit pc-relative branch.  The lowest two bits must be zero and are
  not stored in the instruction.
ENUM
  BFD_RELOC_ARM_PCREL_BLX
ENUMDOC
  ARM 26 bit pc-relative branch.  The lowest bit must be zero and is
  not stored in the instruction.  The 2nd lowest bit comes from a 1 bit
  field in the instruction.
ENUM
  BFD_RELOC_THUMB_PCREL_BLX
ENUMDOC
  Thumb 22 bit pc-relative branch.  The lowest bit must be zero and is
  not stored in the instruction.  The 2nd lowest bit comes from a 1 bit
  field in the instruction.
ENUM
  BFD_RELOC_ARM_IMMEDIATE
ENUMX
  BFD_RELOC_ARM_ADRL_IMMEDIATE
ENUMX
  BFD_RELOC_ARM_OFFSET_IMM
ENUMX
  BFD_RELOC_ARM_SHIFT_IMM
ENUMX
  BFD_RELOC_ARM_SWI
ENUMX
  BFD_RELOC_ARM_MULTI
ENUMX
  BFD_RELOC_ARM_CP_OFF_IMM
ENUMX
  BFD_RELOC_ARM_CP_OFF_IMM_S2
ENUMX
  BFD_RELOC_ARM_ADR_IMM
ENUMX
  BFD_RELOC_ARM_LDR_IMM
ENUMX
  BFD_RELOC_ARM_LITERAL
ENUMX
  BFD_RELOC_ARM_IN_POOL
ENUMX
  BFD_RELOC_ARM_OFFSET_IMM8
ENUMX
  BFD_RELOC_ARM_HWLITERAL
ENUMX
  BFD_RELOC_ARM_THUMB_ADD
ENUMX
  BFD_RELOC_ARM_THUMB_IMM
ENUMX
  BFD_RELOC_ARM_THUMB_SHIFT
ENUMX
  BFD_RELOC_ARM_THUMB_OFFSET
ENUMX
  BFD_RELOC_ARM_GOT12
ENUMX
  BFD_RELOC_ARM_GOT32
ENUMX
  BFD_RELOC_ARM_JUMP_SLOT
ENUMX
  BFD_RELOC_ARM_COPY
ENUMX
  BFD_RELOC_ARM_GLOB_DAT
ENUMX
  BFD_RELOC_ARM_PLT32
ENUMX
  BFD_RELOC_ARM_RELATIVE
ENUMX
  BFD_RELOC_ARM_GOTOFF
ENUMX
  BFD_RELOC_ARM_GOTPC
ENUMDOC
  These relocs are only used within the ARM assembler.  They are not
  (at present) written to any object files.

ENUM
  BFD_RELOC_SH_PCDISP8BY2
ENUMX
  BFD_RELOC_SH_PCDISP12BY2
ENUMX
  BFD_RELOC_SH_IMM4
ENUMX
  BFD_RELOC_SH_IMM4BY2
ENUMX
  BFD_RELOC_SH_IMM4BY4
ENUMX
  BFD_RELOC_SH_IMM8
ENUMX
  BFD_RELOC_SH_IMM8BY2
ENUMX
  BFD_RELOC_SH_IMM8BY4
ENUMX
  BFD_RELOC_SH_PCRELIMM8BY2
ENUMX
  BFD_RELOC_SH_PCRELIMM8BY4
ENUMX
  BFD_RELOC_SH_SWITCH16
ENUMX
  BFD_RELOC_SH_SWITCH32
ENUMX
  BFD_RELOC_SH_USES
ENUMX
  BFD_RELOC_SH_COUNT
ENUMX
  BFD_RELOC_SH_ALIGN
ENUMX
  BFD_RELOC_SH_CODE
ENUMX
  BFD_RELOC_SH_DATA
ENUMX
  BFD_RELOC_SH_LABEL
ENUMX
  BFD_RELOC_SH_LOOP_START
ENUMX
  BFD_RELOC_SH_LOOP_END
ENUMX
  BFD_RELOC_SH_COPY
ENUMX
  BFD_RELOC_SH_GLOB_DAT
ENUMX
  BFD_RELOC_SH_JMP_SLOT
ENUMX
  BFD_RELOC_SH_RELATIVE
ENUMX
  BFD_RELOC_SH_GOTPC
ENUMX
  BFD_RELOC_SH_GOT_LOW16
ENUMX
  BFD_RELOC_SH_GOT_MEDLOW16
ENUMX
  BFD_RELOC_SH_GOT_MEDHI16
ENUMX
  BFD_RELOC_SH_GOT_HI16
ENUMX
  BFD_RELOC_SH_GOTPLT_LOW16
ENUMX
  BFD_RELOC_SH_GOTPLT_MEDLOW16
ENUMX
  BFD_RELOC_SH_GOTPLT_MEDHI16
ENUMX
  BFD_RELOC_SH_GOTPLT_HI16
ENUMX
  BFD_RELOC_SH_PLT_LOW16
ENUMX
  BFD_RELOC_SH_PLT_MEDLOW16
ENUMX
  BFD_RELOC_SH_PLT_MEDHI16
ENUMX
  BFD_RELOC_SH_PLT_HI16
ENUMX
  BFD_RELOC_SH_GOTOFF_LOW16
ENUMX
  BFD_RELOC_SH_GOTOFF_MEDLOW16
ENUMX
  BFD_RELOC_SH_GOTOFF_MEDHI16
ENUMX
  BFD_RELOC_SH_GOTOFF_HI16
ENUMX
  BFD_RELOC_SH_GOTPC_LOW16
ENUMX
  BFD_RELOC_SH_GOTPC_MEDLOW16
ENUMX
  BFD_RELOC_SH_GOTPC_MEDHI16
ENUMX
  BFD_RELOC_SH_GOTPC_HI16
ENUMX
  BFD_RELOC_SH_COPY64
ENUMX
  BFD_RELOC_SH_GLOB_DAT64
ENUMX
  BFD_RELOC_SH_JMP_SLOT64
ENUMX
  BFD_RELOC_SH_RELATIVE64
ENUMX
  BFD_RELOC_SH_GOT10BY4
ENUMX
  BFD_RELOC_SH_GOT10BY8
ENUMX
  BFD_RELOC_SH_GOTPLT10BY4
ENUMX
  BFD_RELOC_SH_GOTPLT10BY8
ENUMX
  BFD_RELOC_SH_GOTPLT32
ENUMX
  BFD_RELOC_SH_SHMEDIA_CODE
ENUMX
  BFD_RELOC_SH_IMMU5
ENUMX
  BFD_RELOC_SH_IMMS6
ENUMX
  BFD_RELOC_SH_IMMS6BY32
ENUMX
  BFD_RELOC_SH_IMMU6
ENUMX
  BFD_RELOC_SH_IMMS10
ENUMX
  BFD_RELOC_SH_IMMS10BY2
ENUMX
  BFD_RELOC_SH_IMMS10BY4
ENUMX
  BFD_RELOC_SH_IMMS10BY8
ENUMX
  BFD_RELOC_SH_IMMS16
ENUMX
  BFD_RELOC_SH_IMMU16
ENUMX
  BFD_RELOC_SH_IMM_LOW16
ENUMX
  BFD_RELOC_SH_IMM_LOW16_PCREL
ENUMX
  BFD_RELOC_SH_IMM_MEDLOW16
ENUMX
  BFD_RELOC_SH_IMM_MEDLOW16_PCREL
ENUMX
  BFD_RELOC_SH_IMM_MEDHI16
ENUMX
  BFD_RELOC_SH_IMM_MEDHI16_PCREL
ENUMX
  BFD_RELOC_SH_IMM_HI16
ENUMX
  BFD_RELOC_SH_IMM_HI16_PCREL
ENUMX
  BFD_RELOC_SH_PT_16
ENUMX
  BFD_RELOC_SH_TLS_GD_32
ENUMX
  BFD_RELOC_SH_TLS_LD_32
ENUMX
  BFD_RELOC_SH_TLS_LDO_32
ENUMX
  BFD_RELOC_SH_TLS_IE_32
ENUMX
  BFD_RELOC_SH_TLS_LE_32
ENUMX
  BFD_RELOC_SH_TLS_DTPMOD32
ENUMX
  BFD_RELOC_SH_TLS_DTPOFF32
ENUMX
  BFD_RELOC_SH_TLS_TPOFF32
ENUMDOC
  Renesas / SuperH SH relocs.  Not all of these appear in object files.

ENUM
  BFD_RELOC_THUMB_PCREL_BRANCH9
ENUMX
  BFD_RELOC_THUMB_PCREL_BRANCH12
ENUMX
  BFD_RELOC_THUMB_PCREL_BRANCH23
ENUMDOC
  Thumb 23-, 12- and 9-bit pc-relative branches.  The lowest bit must
  be zero and is not stored in the instruction.

ENUM
  BFD_RELOC_ARC_B22_PCREL
ENUMDOC
  ARC Cores relocs.
  ARC 22 bit pc-relative branch.  The lowest two bits must be zero and are
  not stored in the instruction.  The high 20 bits are installed in bits 26
  through 7 of the instruction.
ENUM
  BFD_RELOC_ARC_B26
ENUMDOC
  ARC 26 bit absolute branch.  The lowest two bits must be zero and are not
  stored in the instruction.  The high 24 bits are installed in bits 23
  through 0.

ENUM
  BFD_RELOC_D10V_10_PCREL_R
ENUMDOC
  Mitsubishi D10V relocs.
  This is a 10-bit reloc with the right 2 bits
  assumed to be 0.
ENUM
  BFD_RELOC_D10V_10_PCREL_L
ENUMDOC
  Mitsubishi D10V relocs.
  This is a 10-bit reloc with the right 2 bits
  assumed to be 0.  This is the same as the previous reloc
  except it is in the left container, i.e.,
  shifted left 15 bits.
ENUM
  BFD_RELOC_D10V_18
ENUMDOC
  This is an 18-bit reloc with the right 2 bits
  assumed to be 0.
ENUM
  BFD_RELOC_D10V_18_PCREL
ENUMDOC
  This is an 18-bit reloc with the right 2 bits
  assumed to be 0.

ENUM
  BFD_RELOC_D30V_6
ENUMDOC
  Mitsubishi D30V relocs.
  This is a 6-bit absolute reloc.
ENUM
  BFD_RELOC_D30V_9_PCREL
ENUMDOC
  This is a 6-bit pc-relative reloc with
  the right 3 bits assumed to be 0.
ENUM
  BFD_RELOC_D30V_9_PCREL_R
ENUMDOC
  This is a 6-bit pc-relative reloc with
  the right 3 bits assumed to be 0. Same
  as the previous reloc but on the right side
  of the container.
ENUM
  BFD_RELOC_D30V_15
ENUMDOC
  This is a 12-bit absolute reloc with the
  right 3 bitsassumed to be 0.
ENUM
  BFD_RELOC_D30V_15_PCREL
ENUMDOC
  This is a 12-bit pc-relative reloc with
  the right 3 bits assumed to be 0.
ENUM
  BFD_RELOC_D30V_15_PCREL_R
ENUMDOC
  This is a 12-bit pc-relative reloc with
  the right 3 bits assumed to be 0. Same
  as the previous reloc but on the right side
  of the container.
ENUM
  BFD_RELOC_D30V_21
ENUMDOC
  This is an 18-bit absolute reloc with
  the right 3 bits assumed to be 0.
ENUM
  BFD_RELOC_D30V_21_PCREL
ENUMDOC
  This is an 18-bit pc-relative reloc with
  the right 3 bits assumed to be 0.
ENUM
  BFD_RELOC_D30V_21_PCREL_R
ENUMDOC
  This is an 18-bit pc-relative reloc with
  the right 3 bits assumed to be 0. Same
  as the previous reloc but on the right side
  of the container.
ENUM
  BFD_RELOC_D30V_32
ENUMDOC
  This is a 32-bit absolute reloc.
ENUM
  BFD_RELOC_D30V_32_PCREL
ENUMDOC
  This is a 32-bit pc-relative reloc.

ENUM
  BFD_RELOC_DLX_HI16_S
ENUMDOC
  DLX relocs
ENUM
  BFD_RELOC_DLX_LO16
ENUMDOC
  DLX relocs
ENUM
  BFD_RELOC_DLX_JMP26
ENUMDOC
  DLX relocs

ENUM
  BFD_RELOC_M32R_24
ENUMDOC
  Renesas M32R (formerly Mitsubishi M32R) relocs.
  This is a 24 bit absolute address.
ENUM
  BFD_RELOC_M32R_10_PCREL
ENUMDOC
  This is a 10-bit pc-relative reloc with the right 2 bits assumed to be 0.
ENUM
  BFD_RELOC_M32R_18_PCREL
ENUMDOC
  This is an 18-bit reloc with the right 2 bits assumed to be 0.
ENUM
  BFD_RELOC_M32R_26_PCREL
ENUMDOC
  This is a 26-bit reloc with the right 2 bits assumed to be 0.
ENUM
  BFD_RELOC_M32R_HI16_ULO
ENUMDOC
  This is a 16-bit reloc containing the high 16 bits of an address
  used when the lower 16 bits are treated as unsigned.
ENUM
  BFD_RELOC_M32R_HI16_SLO
ENUMDOC
  This is a 16-bit reloc containing the high 16 bits of an address
  used when the lower 16 bits are treated as signed.
ENUM
  BFD_RELOC_M32R_LO16
ENUMDOC
  This is a 16-bit reloc containing the lower 16 bits of an address.
ENUM
  BFD_RELOC_M32R_SDA16
ENUMDOC
  This is a 16-bit reloc containing the small data area offset for use in
  add3, load, and store instructions.
ENUM
  BFD_RELOC_M32R_GOT24
ENUMX
  BFD_RELOC_M32R_26_PLTREL
ENUMX
  BFD_RELOC_M32R_COPY
ENUMX
  BFD_RELOC_M32R_GLOB_DAT
ENUMX
  BFD_RELOC_M32R_JMP_SLOT
ENUMX
  BFD_RELOC_M32R_RELATIVE
ENUMX
  BFD_RELOC_M32R_GOTOFF
ENUMX
  BFD_RELOC_M32R_GOTPC24
ENUMX
  BFD_RELOC_M32R_GOT16_HI_ULO
ENUMX
  BFD_RELOC_M32R_GOT16_HI_SLO
ENUMX
  BFD_RELOC_M32R_GOT16_LO
ENUMX
  BFD_RELOC_M32R_GOTPC_HI_ULO
ENUMX
  BFD_RELOC_M32R_GOTPC_HI_SLO
ENUMX
  BFD_RELOC_M32R_GOTPC_LO
ENUMDOC
  For PIC.


ENUM
  BFD_RELOC_V850_9_PCREL
ENUMDOC
  This is a 9-bit reloc
ENUM
  BFD_RELOC_V850_22_PCREL
ENUMDOC
  This is a 22-bit reloc

ENUM
  BFD_RELOC_V850_SDA_16_16_OFFSET
ENUMDOC
  This is a 16 bit offset from the short data area pointer.
ENUM
  BFD_RELOC_V850_SDA_15_16_OFFSET
ENUMDOC
  This is a 16 bit offset (of which only 15 bits are used) from the
  short data area pointer.
ENUM
  BFD_RELOC_V850_ZDA_16_16_OFFSET
ENUMDOC
  This is a 16 bit offset from the zero data area pointer.
ENUM
  BFD_RELOC_V850_ZDA_15_16_OFFSET
ENUMDOC
  This is a 16 bit offset (of which only 15 bits are used) from the
  zero data area pointer.
ENUM
  BFD_RELOC_V850_TDA_6_8_OFFSET
ENUMDOC
  This is an 8 bit offset (of which only 6 bits are used) from the
  tiny data area pointer.
ENUM
  BFD_RELOC_V850_TDA_7_8_OFFSET
ENUMDOC
  This is an 8bit offset (of which only 7 bits are used) from the tiny
  data area pointer.
ENUM
  BFD_RELOC_V850_TDA_7_7_OFFSET
ENUMDOC
  This is a 7 bit offset from the tiny data area pointer.
ENUM
  BFD_RELOC_V850_TDA_16_16_OFFSET
ENUMDOC
  This is a 16 bit offset from the tiny data area pointer.
COMMENT
ENUM
  BFD_RELOC_V850_TDA_4_5_OFFSET
ENUMDOC
  This is a 5 bit offset (of which only 4 bits are used) from the tiny
  data area pointer.
ENUM
  BFD_RELOC_V850_TDA_4_4_OFFSET
ENUMDOC
  This is a 4 bit offset from the tiny data area pointer.
ENUM
  BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET
ENUMDOC
  This is a 16 bit offset from the short data area pointer, with the
  bits placed non-contiguously in the instruction.
ENUM
  BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET
ENUMDOC
  This is a 16 bit offset from the zero data area pointer, with the
  bits placed non-contiguously in the instruction.
ENUM
  BFD_RELOC_V850_CALLT_6_7_OFFSET
ENUMDOC
  This is a 6 bit offset from the call table base pointer.
ENUM
  BFD_RELOC_V850_CALLT_16_16_OFFSET
ENUMDOC
  This is a 16 bit offset from the call table base pointer.
ENUM
  BFD_RELOC_V850_LONGCALL
ENUMDOC
  Used for relaxing indirect function calls.
ENUM
  BFD_RELOC_V850_LONGJUMP
ENUMDOC
  Used for relaxing indirect jumps.
ENUM
  BFD_RELOC_V850_ALIGN
ENUMDOC
  Used to maintain alignment whilst relaxing.
ENUM
  BFD_RELOC_MN10300_32_PCREL
ENUMDOC
  This is a 32bit pcrel reloc for the mn10300, offset by two bytes in the
  instruction.
ENUM
  BFD_RELOC_MN10300_16_PCREL
ENUMDOC
  This is a 16bit pcrel reloc for the mn10300, offset by two bytes in the
  instruction.

ENUM
  BFD_RELOC_TIC30_LDP
ENUMDOC
  This is a 8bit DP reloc for the tms320c30, where the most
  significant 8 bits of a 24 bit word are placed into the least
  significant 8 bits of the opcode.

ENUM
  BFD_RELOC_TIC54X_PARTLS7
ENUMDOC
  This is a 7bit reloc for the tms320c54x, where the least
  significant 7 bits of a 16 bit word are placed into the least
  significant 7 bits of the opcode.

ENUM
  BFD_RELOC_TIC54X_PARTMS9
ENUMDOC
  This is a 9bit DP reloc for the tms320c54x, where the most
  significant 9 bits of a 16 bit word are placed into the least
  significant 9 bits of the opcode.

ENUM
  BFD_RELOC_TIC54X_23
ENUMDOC
  This is an extended address 23-bit reloc for the tms320c54x.

ENUM
  BFD_RELOC_TIC54X_16_OF_23
ENUMDOC
  This is a 16-bit reloc for the tms320c54x, where the least
  significant 16 bits of a 23-bit extended address are placed into
  the opcode.

ENUM
  BFD_RELOC_TIC54X_MS7_OF_23
ENUMDOC
  This is a reloc for the tms320c54x, where the most
  significant 7 bits of a 23-bit extended address are placed into
  the opcode.

ENUM
  BFD_RELOC_FR30_48
ENUMDOC
  This is a 48 bit reloc for the FR30 that stores 32 bits.
ENUM
  BFD_RELOC_FR30_20
ENUMDOC
  This is a 32 bit reloc for the FR30 that stores 20 bits split up into
  two sections.
ENUM
  BFD_RELOC_FR30_6_IN_4
ENUMDOC
  This is a 16 bit reloc for the FR30 that stores a 6 bit word offset in
  4 bits.
ENUM
  BFD_RELOC_FR30_8_IN_8
ENUMDOC
  This is a 16 bit reloc for the FR30 that stores an 8 bit byte offset
  into 8 bits.
ENUM
  BFD_RELOC_FR30_9_IN_8
ENUMDOC
  This is a 16 bit reloc for the FR30 that stores a 9 bit short offset
  into 8 bits.
ENUM
  BFD_RELOC_FR30_10_IN_8
ENUMDOC
  This is a 16 bit reloc for the FR30 that stores a 10 bit word offset
  into 8 bits.
ENUM
  BFD_RELOC_FR30_9_PCREL
ENUMDOC
  This is a 16 bit reloc for the FR30 that stores a 9 bit pc relative
  short offset into 8 bits.
ENUM
  BFD_RELOC_FR30_12_PCREL
ENUMDOC
  This is a 16 bit reloc for the FR30 that stores a 12 bit pc relative
  short offset into 11 bits.

ENUM
  BFD_RELOC_MCORE_PCREL_IMM8BY4
ENUMX
  BFD_RELOC_MCORE_PCREL_IMM11BY2
ENUMX
  BFD_RELOC_MCORE_PCREL_IMM4BY2
ENUMX
  BFD_RELOC_MCORE_PCREL_32
ENUMX
  BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2
ENUMX
  BFD_RELOC_MCORE_RVA
ENUMDOC
  Motorola Mcore relocations.

ENUM
  BFD_RELOC_MMIX_GETA
ENUMX
  BFD_RELOC_MMIX_GETA_1
ENUMX
  BFD_RELOC_MMIX_GETA_2
ENUMX
  BFD_RELOC_MMIX_GETA_3
ENUMDOC
  These are relocations for the GETA instruction.
ENUM
  BFD_RELOC_MMIX_CBRANCH
ENUMX
  BFD_RELOC_MMIX_CBRANCH_J
ENUMX
  BFD_RELOC_MMIX_CBRANCH_1
ENUMX
  BFD_RELOC_MMIX_CBRANCH_2
ENUMX
  BFD_RELOC_MMIX_CBRANCH_3
ENUMDOC
  These are relocations for a conditional branch instruction.
ENUM
  BFD_RELOC_MMIX_PUSHJ
ENUMX
  BFD_RELOC_MMIX_PUSHJ_1
ENUMX
  BFD_RELOC_MMIX_PUSHJ_2
ENUMX
  BFD_RELOC_MMIX_PUSHJ_3
ENUMX
  BFD_RELOC_MMIX_PUSHJ_STUBBABLE
ENUMDOC
  These are relocations for the PUSHJ instruction.
ENUM
  BFD_RELOC_MMIX_JMP
ENUMX
  BFD_RELOC_MMIX_JMP_1
ENUMX
  BFD_RELOC_MMIX_JMP_2
ENUMX
  BFD_RELOC_MMIX_JMP_3
ENUMDOC
  These are relocations for the JMP instruction.
ENUM
  BFD_RELOC_MMIX_ADDR19
ENUMDOC
  This is a relocation for a relative address as in a GETA instruction or
  a branch.
ENUM
  BFD_RELOC_MMIX_ADDR27
ENUMDOC
  This is a relocation for a relative address as in a JMP instruction.
ENUM
  BFD_RELOC_MMIX_REG_OR_BYTE
ENUMDOC
  This is a relocation for an instruction field that may be a general
  register or a value 0..255.
ENUM
  BFD_RELOC_MMIX_REG
ENUMDOC
  This is a relocation for an instruction field that may be a general
  register.
ENUM
  BFD_RELOC_MMIX_BASE_PLUS_OFFSET
ENUMDOC
  This is a relocation for two instruction fields holding a register and
  an offset, the equivalent of the relocation.
ENUM
  BFD_RELOC_MMIX_LOCAL
ENUMDOC
  This relocation is an assertion that the expression is not allocated as
  a global register.  It does not modify contents.

ENUM
  BFD_RELOC_AVR_7_PCREL
ENUMDOC
  This is a 16 bit reloc for the AVR that stores 8 bit pc relative
  short offset into 7 bits.
ENUM
  BFD_RELOC_AVR_13_PCREL
ENUMDOC
  This is a 16 bit reloc for the AVR that stores 13 bit pc relative
  short offset into 12 bits.
ENUM
  BFD_RELOC_AVR_16_PM
ENUMDOC
  This is a 16 bit reloc for the AVR that stores 17 bit value (usually
  program memory address) into 16 bits.
ENUM
  BFD_RELOC_AVR_LO8_LDI
ENUMDOC
  This is a 16 bit reloc for the AVR that stores 8 bit value (usually
  data memory address) into 8 bit immediate value of LDI insn.
ENUM
  BFD_RELOC_AVR_HI8_LDI
ENUMDOC
  This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
  of data memory address) into 8 bit immediate value of LDI insn.
ENUM
  BFD_RELOC_AVR_HH8_LDI
ENUMDOC
  This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
  of program memory address) into 8 bit immediate value of LDI insn.
ENUM
  BFD_RELOC_AVR_LO8_LDI_NEG
ENUMDOC
  This is a 16 bit reloc for the AVR that stores negated 8 bit value
  (usually data memory address) into 8 bit immediate value of SUBI insn.
ENUM
  BFD_RELOC_AVR_HI8_LDI_NEG
ENUMDOC
  This is a 16 bit reloc for the AVR that stores negated 8 bit value
  (high 8 bit of data memory address) into 8 bit immediate value of
  SUBI insn.
ENUM
  BFD_RELOC_AVR_HH8_LDI_NEG
ENUMDOC
  This is a 16 bit reloc for the AVR that stores negated 8 bit value
  (most high 8 bit of program memory address) into 8 bit immediate value
  of LDI or SUBI insn.
ENUM
  BFD_RELOC_AVR_LO8_LDI_PM
ENUMDOC
  This is a 16 bit reloc for the AVR that stores 8 bit value (usually
  command address) into 8 bit immediate value of LDI insn.
ENUM
  BFD_RELOC_AVR_HI8_LDI_PM
ENUMDOC
  This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
  of command address) into 8 bit immediate value of LDI insn.
ENUM
  BFD_RELOC_AVR_HH8_LDI_PM
ENUMDOC
  This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
  of command address) into 8 bit immediate value of LDI insn.
ENUM
  BFD_RELOC_AVR_LO8_LDI_PM_NEG
ENUMDOC
  This is a 16 bit reloc for the AVR that stores negated 8 bit value
  (usually command address) into 8 bit immediate value of SUBI insn.
ENUM
  BFD_RELOC_AVR_HI8_LDI_PM_NEG
ENUMDOC
  This is a 16 bit reloc for the AVR that stores negated 8 bit value
  (high 8 bit of 16 bit command address) into 8 bit immediate value
  of SUBI insn.
ENUM
  BFD_RELOC_AVR_HH8_LDI_PM_NEG
ENUMDOC
  This is a 16 bit reloc for the AVR that stores negated 8 bit value
  (high 6 bit of 22 bit command address) into 8 bit immediate
  value of SUBI insn.
ENUM
  BFD_RELOC_AVR_CALL
ENUMDOC
  This is a 32 bit reloc for the AVR that stores 23 bit value
  into 22 bits.

ENUM
  BFD_RELOC_390_12
ENUMDOC
   Direct 12 bit.
ENUM
  BFD_RELOC_390_GOT12
ENUMDOC
  12 bit GOT offset.
ENUM
  BFD_RELOC_390_PLT32
ENUMDOC
  32 bit PC relative PLT address.
ENUM
  BFD_RELOC_390_COPY
ENUMDOC
  Copy symbol at runtime.
ENUM
  BFD_RELOC_390_GLOB_DAT
ENUMDOC
  Create GOT entry.
ENUM
  BFD_RELOC_390_JMP_SLOT
ENUMDOC
  Create PLT entry.
ENUM
  BFD_RELOC_390_RELATIVE
ENUMDOC
  Adjust by program base.
ENUM
  BFD_RELOC_390_GOTPC
ENUMDOC
  32 bit PC relative offset to GOT.
ENUM
  BFD_RELOC_390_GOT16
ENUMDOC
  16 bit GOT offset.
ENUM
  BFD_RELOC_390_PC16DBL
ENUMDOC
  PC relative 16 bit shifted by 1.
ENUM
  BFD_RELOC_390_PLT16DBL
ENUMDOC
  16 bit PC rel. PLT shifted by 1.
ENUM
  BFD_RELOC_390_PC32DBL
ENUMDOC
  PC relative 32 bit shifted by 1.
ENUM
  BFD_RELOC_390_PLT32DBL
ENUMDOC
  32 bit PC rel. PLT shifted by 1.
ENUM
  BFD_RELOC_390_GOTPCDBL
ENUMDOC
  32 bit PC rel. GOT shifted by 1.
ENUM
  BFD_RELOC_390_GOT64
ENUMDOC
  64 bit GOT offset.
ENUM
  BFD_RELOC_390_PLT64
ENUMDOC
  64 bit PC relative PLT address.
ENUM
  BFD_RELOC_390_GOTENT
ENUMDOC
  32 bit rel. offset to GOT entry.
ENUM
  BFD_RELOC_390_GOTOFF64
ENUMDOC
  64 bit offset to GOT.
ENUM
  BFD_RELOC_390_GOTPLT12
ENUMDOC
  12-bit offset to symbol-entry within GOT, with PLT handling.
ENUM
  BFD_RELOC_390_GOTPLT16
ENUMDOC
  16-bit offset to symbol-entry within GOT, with PLT handling.
ENUM
  BFD_RELOC_390_GOTPLT32
ENUMDOC
  32-bit offset to symbol-entry within GOT, with PLT handling.
ENUM
  BFD_RELOC_390_GOTPLT64
ENUMDOC
  64-bit offset to symbol-entry within GOT, with PLT handling.
ENUM
  BFD_RELOC_390_GOTPLTENT
ENUMDOC
  32-bit rel. offset to symbol-entry within GOT, with PLT handling.
ENUM
  BFD_RELOC_390_PLTOFF16
ENUMDOC
  16-bit rel. offset from the GOT to a PLT entry.
ENUM
  BFD_RELOC_390_PLTOFF32
ENUMDOC
  32-bit rel. offset from the GOT to a PLT entry.
ENUM
  BFD_RELOC_390_PLTOFF64
ENUMDOC
  64-bit rel. offset from the GOT to a PLT entry.

ENUM
  BFD_RELOC_390_TLS_LOAD
ENUMX
  BFD_RELOC_390_TLS_GDCALL
ENUMX
  BFD_RELOC_390_TLS_LDCALL
ENUMX
  BFD_RELOC_390_TLS_GD32
ENUMX
  BFD_RELOC_390_TLS_GD64
ENUMX
  BFD_RELOC_390_TLS_GOTIE12
ENUMX
  BFD_RELOC_390_TLS_GOTIE32
ENUMX
  BFD_RELOC_390_TLS_GOTIE64
ENUMX
  BFD_RELOC_390_TLS_LDM32
ENUMX
  BFD_RELOC_390_TLS_LDM64
ENUMX
  BFD_RELOC_390_TLS_IE32
ENUMX
  BFD_RELOC_390_TLS_IE64
ENUMX
  BFD_RELOC_390_TLS_IEENT
ENUMX
  BFD_RELOC_390_TLS_LE32
ENUMX
  BFD_RELOC_390_TLS_LE64
ENUMX
  BFD_RELOC_390_TLS_LDO32
ENUMX
  BFD_RELOC_390_TLS_LDO64
ENUMX
  BFD_RELOC_390_TLS_DTPMOD
ENUMX
  BFD_RELOC_390_TLS_DTPOFF
ENUMX
  BFD_RELOC_390_TLS_TPOFF
ENUMDOC
  s390 tls relocations.

ENUM
  BFD_RELOC_390_20
ENUMX
  BFD_RELOC_390_GOT20
ENUMX
  BFD_RELOC_390_GOTPLT20
ENUMX
  BFD_RELOC_390_TLS_GOTIE20
ENUMDOC
  Long displacement extension.

ENUM
  BFD_RELOC_IP2K_FR9
ENUMDOC
  Scenix IP2K - 9-bit register number / data address
ENUM
  BFD_RELOC_IP2K_BANK
ENUMDOC
  Scenix IP2K - 4-bit register/data bank number
ENUM
  BFD_RELOC_IP2K_ADDR16CJP
ENUMDOC
  Scenix IP2K - low 13 bits of instruction word address
ENUM
  BFD_RELOC_IP2K_PAGE3
ENUMDOC
  Scenix IP2K - high 3 bits of instruction word address
ENUM
  BFD_RELOC_IP2K_LO8DATA
ENUMX
  BFD_RELOC_IP2K_HI8DATA
ENUMX
  BFD_RELOC_IP2K_EX8DATA
ENUMDOC
  Scenix IP2K - ext/low/high 8 bits of data address
ENUM
  BFD_RELOC_IP2K_LO8INSN
ENUMX
  BFD_RELOC_IP2K_HI8INSN
ENUMDOC
  Scenix IP2K - low/high 8 bits of instruction word address
ENUM
  BFD_RELOC_IP2K_PC_SKIP
ENUMDOC
  Scenix IP2K - even/odd PC modifier to modify snb pcl.0
ENUM
  BFD_RELOC_IP2K_TEXT
ENUMDOC
  Scenix IP2K - 16 bit word address in text section.
ENUM
  BFD_RELOC_IP2K_FR_OFFSET
ENUMDOC
  Scenix IP2K - 7-bit sp or dp offset
ENUM
  BFD_RELOC_VPE4KMATH_DATA
ENUMX
  BFD_RELOC_VPE4KMATH_INSN
ENUMDOC
  Scenix VPE4K coprocessor - data/insn-space addressing

ENUM
  BFD_RELOC_VTABLE_INHERIT
ENUMX
  BFD_RELOC_VTABLE_ENTRY
ENUMDOC
  These two relocations are used by the linker to determine which of
  the entries in a C++ virtual function table are actually used.  When
  the --gc-sections option is given, the linker will zero out the entries
  that are not used, so that the code for those functions need not be
  included in the output.

  VTABLE_INHERIT is a zero-space relocation used to describe to the
  linker the inheritance tree of a C++ virtual function table.  The
  relocation's symbol should be the parent class' vtable, and the
  relocation should be located at the child vtable.

  VTABLE_ENTRY is a zero-space relocation that describes the use of a
  virtual function table entry.  The reloc's symbol should refer to the
  table of the class mentioned in the code.  Off of that base, an offset
  describes the entry that is being used.  For Rela hosts, this offset
  is stored in the reloc's addend.  For Rel hosts, we are forced to put
  this offset in the reloc's section offset.

ENUM
  BFD_RELOC_IA64_IMM14
ENUMX
  BFD_RELOC_IA64_IMM22
ENUMX
  BFD_RELOC_IA64_IMM64
ENUMX
  BFD_RELOC_IA64_DIR32MSB
ENUMX
  BFD_RELOC_IA64_DIR32LSB
ENUMX
  BFD_RELOC_IA64_DIR64MSB
ENUMX
  BFD_RELOC_IA64_DIR64LSB
ENUMX
  BFD_RELOC_IA64_GPREL22
ENUMX
  BFD_RELOC_IA64_GPREL64I
ENUMX
  BFD_RELOC_IA64_GPREL32MSB
ENUMX
  BFD_RELOC_IA64_GPREL32LSB
ENUMX
  BFD_RELOC_IA64_GPREL64MSB
ENUMX
  BFD_RELOC_IA64_GPREL64LSB
ENUMX
  BFD_RELOC_IA64_LTOFF22
ENUMX
  BFD_RELOC_IA64_LTOFF64I
ENUMX
  BFD_RELOC_IA64_PLTOFF22
ENUMX
  BFD_RELOC_IA64_PLTOFF64I
ENUMX
  BFD_RELOC_IA64_PLTOFF64MSB
ENUMX
  BFD_RELOC_IA64_PLTOFF64LSB
ENUMX
  BFD_RELOC_IA64_FPTR64I
ENUMX
  BFD_RELOC_IA64_FPTR32MSB
ENUMX
  BFD_RELOC_IA64_FPTR32LSB
ENUMX
  BFD_RELOC_IA64_FPTR64MSB
ENUMX
  BFD_RELOC_IA64_FPTR64LSB
ENUMX
  BFD_RELOC_IA64_PCREL21B
ENUMX
  BFD_RELOC_IA64_PCREL21BI
ENUMX
  BFD_RELOC_IA64_PCREL21M
ENUMX
  BFD_RELOC_IA64_PCREL21F
ENUMX
  BFD_RELOC_IA64_PCREL22
ENUMX
  BFD_RELOC_IA64_PCREL60B
ENUMX
  BFD_RELOC_IA64_PCREL64I
ENUMX
  BFD_RELOC_IA64_PCREL32MSB
ENUMX
  BFD_RELOC_IA64_PCREL32LSB
ENUMX
  BFD_RELOC_IA64_PCREL64MSB
ENUMX
  BFD_RELOC_IA64_PCREL64LSB
ENUMX
  BFD_RELOC_IA64_LTOFF_FPTR22
ENUMX
  BFD_RELOC_IA64_LTOFF_FPTR64I
ENUMX
  BFD_RELOC_IA64_LTOFF_FPTR32MSB
ENUMX
  BFD_RELOC_IA64_LTOFF_FPTR32LSB
ENUMX
  BFD_RELOC_IA64_LTOFF_FPTR64MSB
ENUMX
  BFD_RELOC_IA64_LTOFF_FPTR64LSB
ENUMX
  BFD_RELOC_IA64_SEGREL32MSB
ENUMX
  BFD_RELOC_IA64_SEGREL32LSB
ENUMX
  BFD_RELOC_IA64_SEGREL64MSB
ENUMX
  BFD_RELOC_IA64_SEGREL64LSB
ENUMX
  BFD_RELOC_IA64_SECREL32MSB
ENUMX
  BFD_RELOC_IA64_SECREL32LSB
ENUMX
  BFD_RELOC_IA64_SECREL64MSB
ENUMX
  BFD_RELOC_IA64_SECREL64LSB
ENUMX
  BFD_RELOC_IA64_REL32MSB
ENUMX
  BFD_RELOC_IA64_REL32LSB
ENUMX
  BFD_RELOC_IA64_REL64MSB
ENUMX
  BFD_RELOC_IA64_REL64LSB
ENUMX
  BFD_RELOC_IA64_LTV32MSB
ENUMX
  BFD_RELOC_IA64_LTV32LSB
ENUMX
  BFD_RELOC_IA64_LTV64MSB
ENUMX
  BFD_RELOC_IA64_LTV64LSB
ENUMX
  BFD_RELOC_IA64_IPLTMSB
ENUMX
  BFD_RELOC_IA64_IPLTLSB
ENUMX
  BFD_RELOC_IA64_COPY
ENUMX
  BFD_RELOC_IA64_LTOFF22X
ENUMX
  BFD_RELOC_IA64_LDXMOV
ENUMX
  BFD_RELOC_IA64_TPREL14
ENUMX
  BFD_RELOC_IA64_TPREL22
ENUMX
  BFD_RELOC_IA64_TPREL64I
ENUMX
  BFD_RELOC_IA64_TPREL64MSB
ENUMX
  BFD_RELOC_IA64_TPREL64LSB
ENUMX
  BFD_RELOC_IA64_LTOFF_TPREL22
ENUMX
  BFD_RELOC_IA64_DTPMOD64MSB
ENUMX
  BFD_RELOC_IA64_DTPMOD64LSB
ENUMX
  BFD_RELOC_IA64_LTOFF_DTPMOD22
ENUMX
  BFD_RELOC_IA64_DTPREL14
ENUMX
  BFD_RELOC_IA64_DTPREL22
ENUMX
  BFD_RELOC_IA64_DTPREL64I
ENUMX
  BFD_RELOC_IA64_DTPREL32MSB
ENUMX
  BFD_RELOC_IA64_DTPREL32LSB
ENUMX
  BFD_RELOC_IA64_DTPREL64MSB
ENUMX
  BFD_RELOC_IA64_DTPREL64LSB
ENUMX
  BFD_RELOC_IA64_LTOFF_DTPREL22
ENUMDOC
  Intel IA64 Relocations.

ENUM
  BFD_RELOC_M68HC11_HI8
ENUMDOC
  Motorola 68HC11 reloc.
  This is the 8 bit high part of an absolute address.
ENUM
  BFD_RELOC_M68HC11_LO8
ENUMDOC
  Motorola 68HC11 reloc.
  This is the 8 bit low part of an absolute address.
ENUM
  BFD_RELOC_M68HC11_3B
ENUMDOC
  Motorola 68HC11 reloc.
  This is the 3 bit of a value.
ENUM
  BFD_RELOC_M68HC11_RL_JUMP
ENUMDOC
  Motorola 68HC11 reloc.
  This reloc marks the beginning of a jump/call instruction.
  It is used for linker relaxation to correctly identify beginning
  of instruction and change some branches to use PC-relative
  addressing mode.
ENUM
  BFD_RELOC_M68HC11_RL_GROUP
ENUMDOC
  Motorola 68HC11 reloc.
  This reloc marks a group of several instructions that gcc generates
  and for which the linker relaxation pass can modify and/or remove
  some of them.
ENUM
  BFD_RELOC_M68HC11_LO16
ENUMDOC
  Motorola 68HC11 reloc.
  This is the 16-bit lower part of an address.  It is used for 'call'
  instruction to specify the symbol address without any special
  transformation (due to memory bank window).
ENUM
  BFD_RELOC_M68HC11_PAGE
ENUMDOC
  Motorola 68HC11 reloc.
  This is a 8-bit reloc that specifies the page number of an address.
  It is used by 'call' instruction to specify the page number of
  the symbol.
ENUM
  BFD_RELOC_M68HC11_24
ENUMDOC
  Motorola 68HC11 reloc.
  This is a 24-bit reloc that represents the address with a 16-bit
  value and a 8-bit page number.  The symbol address is transformed
  to follow the 16K memory bank of 68HC12 (seen as mapped in the window).
ENUM
  BFD_RELOC_M68HC12_5B
ENUMDOC
  Motorola 68HC12 reloc.
  This is the 5 bits of a value.

ENUM
  BFD_RELOC_CRIS_BDISP8
ENUMX
  BFD_RELOC_CRIS_UNSIGNED_5
ENUMX
  BFD_RELOC_CRIS_SIGNED_6
ENUMX
  BFD_RELOC_CRIS_UNSIGNED_6
ENUMX
  BFD_RELOC_CRIS_UNSIGNED_4
ENUMDOC
  These relocs are only used within the CRIS assembler.  They are not
  (at present) written to any object files.
ENUM
  BFD_RELOC_CRIS_COPY
ENUMX
  BFD_RELOC_CRIS_GLOB_DAT
ENUMX
  BFD_RELOC_CRIS_JUMP_SLOT
ENUMX
  BFD_RELOC_CRIS_RELATIVE
ENUMDOC
  Relocs used in ELF shared libraries for CRIS.
ENUM
  BFD_RELOC_CRIS_32_GOT
ENUMDOC
  32-bit offset to symbol-entry within GOT.
ENUM
  BFD_RELOC_CRIS_16_GOT
ENUMDOC
  16-bit offset to symbol-entry within GOT.
ENUM
  BFD_RELOC_CRIS_32_GOTPLT
ENUMDOC
  32-bit offset to symbol-entry within GOT, with PLT handling.
ENUM
  BFD_RELOC_CRIS_16_GOTPLT
ENUMDOC
  16-bit offset to symbol-entry within GOT, with PLT handling.
ENUM
  BFD_RELOC_CRIS_32_GOTREL
ENUMDOC
  32-bit offset to symbol, relative to GOT.
ENUM
  BFD_RELOC_CRIS_32_PLT_GOTREL
ENUMDOC
  32-bit offset to symbol with PLT entry, relative to GOT.
ENUM
  BFD_RELOC_CRIS_32_PLT_PCREL
ENUMDOC
  32-bit offset to symbol with PLT entry, relative to this relocation.

ENUM
  BFD_RELOC_860_COPY
ENUMX
  BFD_RELOC_860_GLOB_DAT
ENUMX
  BFD_RELOC_860_JUMP_SLOT
ENUMX
  BFD_RELOC_860_RELATIVE
ENUMX
  BFD_RELOC_860_PC26
ENUMX
  BFD_RELOC_860_PLT26
ENUMX
  BFD_RELOC_860_PC16
ENUMX
  BFD_RELOC_860_LOW0
ENUMX
  BFD_RELOC_860_SPLIT0
ENUMX
  BFD_RELOC_860_LOW1
ENUMX
  BFD_RELOC_860_SPLIT1
ENUMX
  BFD_RELOC_860_LOW2
ENUMX
  BFD_RELOC_860_SPLIT2
ENUMX
  BFD_RELOC_860_LOW3
ENUMX
  BFD_RELOC_860_LOGOT0
ENUMX
  BFD_RELOC_860_SPGOT0
ENUMX
  BFD_RELOC_860_LOGOT1
ENUMX
  BFD_RELOC_860_SPGOT1
ENUMX
  BFD_RELOC_860_LOGOTOFF0
ENUMX
  BFD_RELOC_860_SPGOTOFF0
ENUMX
  BFD_RELOC_860_LOGOTOFF1
ENUMX
  BFD_RELOC_860_SPGOTOFF1
ENUMX
  BFD_RELOC_860_LOGOTOFF2
ENUMX
  BFD_RELOC_860_LOGOTOFF3
ENUMX
  BFD_RELOC_860_LOPC
ENUMX
  BFD_RELOC_860_HIGHADJ
ENUMX
  BFD_RELOC_860_HAGOT
ENUMX
  BFD_RELOC_860_HAGOTOFF
ENUMX
  BFD_RELOC_860_HAPC
ENUMX
  BFD_RELOC_860_HIGH
ENUMX
  BFD_RELOC_860_HIGOT
ENUMX
  BFD_RELOC_860_HIGOTOFF
ENUMDOC
  Intel i860 Relocations.

ENUM
  BFD_RELOC_OPENRISC_ABS_26
ENUMX
  BFD_RELOC_OPENRISC_REL_26
ENUMDOC
  OpenRISC Relocations.

ENUM
  BFD_RELOC_H8_DIR16A8
ENUMX
  BFD_RELOC_H8_DIR16R8
ENUMX
  BFD_RELOC_H8_DIR24A8
ENUMX
  BFD_RELOC_H8_DIR24R8
ENUMX
  BFD_RELOC_H8_DIR32A16
ENUMDOC
  H8 elf Relocations.

ENUM
  BFD_RELOC_XSTORMY16_REL_12
ENUMX
  BFD_RELOC_XSTORMY16_12
ENUMX
  BFD_RELOC_XSTORMY16_24
ENUMX
  BFD_RELOC_XSTORMY16_FPTR16
ENUMDOC
  Sony Xstormy16 Relocations.

ENUM
  BFD_RELOC_VAX_GLOB_DAT
ENUMX
  BFD_RELOC_VAX_JMP_SLOT
ENUMX
  BFD_RELOC_VAX_RELATIVE
ENUMDOC
  Relocations used by VAX ELF.
  
ENUM
  BFD_RELOC_MSP430_10_PCREL
ENUMX
  BFD_RELOC_MSP430_16_PCREL
ENUMX
  BFD_RELOC_MSP430_16
ENUMX
  BFD_RELOC_MSP430_16_PCREL_BYTE
ENUMX
  BFD_RELOC_MSP430_16_BYTE
ENUMDOC
  msp430 specific relocation codes

ENUM
  BFD_RELOC_IQ2000_OFFSET_16
ENUMX
  BFD_RELOC_IQ2000_OFFSET_21
ENUMX
  BFD_RELOC_IQ2000_UHI16
ENUMDOC
  IQ2000 Relocations.

ENUM
  BFD_RELOC_XTENSA_RTLD
ENUMDOC
  Special Xtensa relocation used only by PLT entries in ELF shared
  objects to indicate that the runtime linker should set the value
  to one of its own internal functions or data structures.
ENUM
  BFD_RELOC_XTENSA_GLOB_DAT
ENUMX
  BFD_RELOC_XTENSA_JMP_SLOT
ENUMX
  BFD_RELOC_XTENSA_RELATIVE
ENUMDOC
  Xtensa relocations for ELF shared objects.
ENUM
  BFD_RELOC_XTENSA_PLT
ENUMDOC
  Xtensa relocation used in ELF object files for symbols that may require
  PLT entries.  Otherwise, this is just a generic 32-bit relocation.
ENUM
  BFD_RELOC_XTENSA_OP0
ENUMX
  BFD_RELOC_XTENSA_OP1
ENUMX
  BFD_RELOC_XTENSA_OP2
ENUMDOC
  Generic Xtensa relocations.  Only the operand number is encoded
  in the relocation.  The details are determined by extracting the
  instruction opcode.
ENUM
  BFD_RELOC_XTENSA_ASM_EXPAND
ENUMDOC
  Xtensa relocation to mark that the assembler expanded the 
  instructions from an original target.  The expansion size is
  encoded in the reloc size.
ENUM
  BFD_RELOC_XTENSA_ASM_SIMPLIFY
ENUMDOC
  Xtensa relocation to mark that the linker should simplify 
  assembler-expanded instructions.  This is commonly used 
  internally by the linker after analysis of a 
  BFD_RELOC_XTENSA_ASM_EXPAND.

ENDSENUM
  BFD_RELOC_UNUSED
CODE_FRAGMENT
.
.typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
*/

/*
FUNCTION
	bfd_reloc_type_lookup

SYNOPSIS
	reloc_howto_type *bfd_reloc_type_lookup
	  (bfd *abfd, bfd_reloc_code_real_type code);

DESCRIPTION
	Return a pointer to a howto structure which, when
	invoked, will perform the relocation @@var{code} on data from the
	architecture noted.

*/

reloc_howto_type *
bfd_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code)
{
  return BFD_SEND (abfd, reloc_type_lookup, (abfd, code));
}

static reloc_howto_type bfd_howto_32 =
HOWTO (0, 00, 2, 32, FALSE, 0, complain_overflow_bitfield, 0, "VRT32", FALSE, 0xffffffff, 0xffffffff, TRUE);

/*
INTERNAL_FUNCTION
	bfd_default_reloc_type_lookup

SYNOPSIS
	reloc_howto_type *bfd_default_reloc_type_lookup
	  (bfd *abfd, bfd_reloc_code_real_type  code);

DESCRIPTION
	Provides a default relocation lookup routine for any architecture.

*/

reloc_howto_type *
bfd_default_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code)
{
  switch (code)
    {
    case BFD_RELOC_CTOR:
      /* The type of reloc used in a ctor, which will be as wide as the
	 address - so either a 64, 32, or 16 bitter.  */
      switch (bfd_get_arch_info (abfd)->bits_per_address)
	{
	case 64:
	  BFD_FAIL ();
	case 32:
	  return &bfd_howto_32;
	case 16:
	  BFD_FAIL ();
	default:
	  BFD_FAIL ();
	}
    default:
      BFD_FAIL ();
    }
  return NULL;
}

/*
FUNCTION
	bfd_get_reloc_code_name

SYNOPSIS
	const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);

DESCRIPTION
	Provides a printable name for the supplied relocation code.
	Useful mainly for printing error messages.
*/

const char *
bfd_get_reloc_code_name (bfd_reloc_code_real_type code)
{
  if (code > BFD_RELOC_UNUSED)
    return 0;
  return bfd_reloc_code_real_names[code];
}

/*
INTERNAL_FUNCTION
	bfd_generic_relax_section

SYNOPSIS
	bfd_boolean bfd_generic_relax_section
	  (bfd *abfd,
	   asection *section,
	   struct bfd_link_info *,
	   bfd_boolean *);

DESCRIPTION
	Provides default handling for relaxing for back ends which
	don't do relaxing -- i.e., does nothing except make sure that the
	final size of the section is set.
*/

bfd_boolean
bfd_generic_relax_section (bfd *abfd ATTRIBUTE_UNUSED,
			   asection *section ATTRIBUTE_UNUSED,
			   struct bfd_link_info *link_info ATTRIBUTE_UNUSED,
			   bfd_boolean *again)
{
  /* We're not relaxing the section, so just copy the size info if it's
     zero.  Someone else, like bfd_merge_sections, might have set it, so
     don't overwrite a non-zero value.  */
  if (section->_cooked_size == 0)
    section->_cooked_size = section->_raw_size;
  *again = FALSE;
  return TRUE;
}

/*
INTERNAL_FUNCTION
	bfd_generic_gc_sections

SYNOPSIS
	bfd_boolean bfd_generic_gc_sections
	  (bfd *, struct bfd_link_info *);

DESCRIPTION
	Provides default handling for relaxing for back ends which
	don't do section gc -- i.e., does nothing.
*/

bfd_boolean
bfd_generic_gc_sections (bfd *abfd ATTRIBUTE_UNUSED,
			 struct bfd_link_info *link_info ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/*
INTERNAL_FUNCTION
	bfd_generic_merge_sections

SYNOPSIS
	bfd_boolean bfd_generic_merge_sections
	  (bfd *, struct bfd_link_info *);

DESCRIPTION
	Provides default handling for SEC_MERGE section merging for back ends
	which don't have SEC_MERGE support -- i.e., does nothing.
*/

bfd_boolean
bfd_generic_merge_sections (bfd *abfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *link_info ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/*
INTERNAL_FUNCTION
	bfd_generic_get_relocated_section_contents

SYNOPSIS
	bfd_byte *bfd_generic_get_relocated_section_contents
	  (bfd *abfd,
	   struct bfd_link_info *link_info,
	   struct bfd_link_order *link_order,
	   bfd_byte *data,
	   bfd_boolean relocatable,
	   asymbol **symbols);

DESCRIPTION
	Provides default handling of relocation effort for back ends
	which can't be bothered to do it efficiently.

*/

bfd_byte *
bfd_generic_get_relocated_section_contents (bfd *abfd,
					    struct bfd_link_info *link_info,
					    struct bfd_link_order *link_order,
					    bfd_byte *data,
					    bfd_boolean relocatable,
					    asymbol **symbols)
{
  /* Get enough memory to hold the stuff.  */
  bfd *input_bfd = link_order->u.indirect.section->owner;
  asection *input_section = link_order->u.indirect.section;

  long reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
  arelent **reloc_vector = NULL;
  long reloc_count;

  if (reloc_size < 0)
    goto error_return;

  reloc_vector = bfd_malloc (reloc_size);
  if (reloc_vector == NULL && reloc_size != 0)
    goto error_return;

  /* Read in the section.  */
  if (!bfd_get_section_contents (input_bfd,
				 input_section,
				 data,
				 0,
				 input_section->_raw_size))
    goto error_return;

  /* Don't set input_section->_cooked_size here.  The caller has set
     _cooked_size or called bfd_relax_section, which sets _cooked_size.
     Despite using this generic relocation function, some targets perform
     target-specific relaxation or string merging, which happens before
     this function is called.  We do not want to clobber the _cooked_size
     they computed.  */

  input_section->reloc_done = TRUE;

  reloc_count = bfd_canonicalize_reloc (input_bfd,
					input_section,
					reloc_vector,
					symbols);
  if (reloc_count < 0)
    goto error_return;

  if (reloc_count > 0)
    {
      arelent **parent;
      for (parent = reloc_vector; *parent != NULL; parent++)
	{
	  char *error_message = NULL;
	  bfd_reloc_status_type r =
	    bfd_perform_relocation (input_bfd,
				    *parent,
				    data,
				    input_section,
				    relocatable ? abfd : NULL,
				    &error_message);

	  if (relocatable)
	    {
	      asection *os = input_section->output_section;

	      /* A partial link, so keep the relocs.  */
	      os->orelocation[os->reloc_count] = *parent;
	      os->reloc_count++;
	    }

	  if (r != bfd_reloc_ok)
	    {
	      switch (r)
		{
		case bfd_reloc_undefined:
		  if (!((*link_info->callbacks->undefined_symbol)
			(link_info, bfd_asymbol_name (*(*parent)->sym_ptr_ptr),
			 input_bfd, input_section, (*parent)->address,
			 TRUE)))
		    goto error_return;
		  break;
		case bfd_reloc_dangerous:
		  BFD_ASSERT (error_message != NULL);
		  if (!((*link_info->callbacks->reloc_dangerous)
			(link_info, error_message, input_bfd, input_section,
			 (*parent)->address)))
		    goto error_return;
		  break;
		case bfd_reloc_overflow:
		  if (!((*link_info->callbacks->reloc_overflow)
			(link_info, bfd_asymbol_name (*(*parent)->sym_ptr_ptr),
			 (*parent)->howto->name, (*parent)->addend,
			 input_bfd, input_section, (*parent)->address)))
		    goto error_return;
		  break;
		case bfd_reloc_outofrange:
		default:
		  abort ();
		  break;
		}

	    }
	}
    }
  if (reloc_vector != NULL)
    free (reloc_vector);
  return data;

error_return:
  if (reloc_vector != NULL)
    free (reloc_vector);
  return NULL;
}
@


1.9
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d1731 4
@


1.8
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d101 1
a101 1
.  struct symbol_cache_entry **sym_ptr_ptr;
d125 10
a134 9
        associated with the relocation request.  It is
        the pointer into the table returned by the back end's
        <<get_symtab>> action. @@xref{Symbols}. The symbol is referenced
        through a pointer to a pointer so that tools like the linker
        can fix up all the symbols of the same name by modifying only
        one pointer. The relocation routine looks in the symbol and
        uses the base of the section the symbol is attached to and the
        value of the symbol as the initial relocation offset. If the
        symbol pointer is zero, then the section provided is looked up.
d281 1
a281 1
.struct symbol_cache_entry;		{* Forward declaration.  *}
d322 1
a322 1
.     strange relocation methods to be accomodated (e.g., i960 callj
d325 2
a326 2
.    PARAMS ((bfd *, arelent *, struct symbol_cache_entry *, PTR, asection *,
.             bfd *, char **));
d405 1
a405 1
.    if (symbol != (asymbol *) NULL)                     \
d433 1
a433 2
bfd_get_reloc_size (howto)
     reloc_howto_type *howto;
d473 6
a478 7
	bfd_reloc_status_type
		bfd_check_overflow
			(enum complain_overflow how,
			 unsigned int bitsize,
			 unsigned int rightshift,
			 unsigned int addrsize,
			 bfd_vma relocation);
d490 5
a494 6
bfd_check_overflow (how, bitsize, rightshift, addrsize, relocation)
     enum complain_overflow how;
     unsigned int bitsize;
     unsigned int rightshift;
     unsigned int addrsize;
     bfd_vma relocation;
d554 7
a560 8
	bfd_reloc_status_type
                bfd_perform_relocation
                        (bfd *abfd,
                         arelent *reloc_entry,
                         PTR data,
                         asection *input_section,
                         bfd *output_bfd,
			 char **error_message);
d581 6
a586 8
bfd_perform_relocation (abfd, reloc_entry, data, input_section, output_bfd,
			error_message)
     bfd *abfd;
     arelent *reloc_entry;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d598 1
a598 1
      && output_bfd != (bfd *) NULL)
d604 1
a604 1
  /* If we are not producing relocateable output, return an error if
d609 1
a609 1
      && output_bfd == (bfd *) NULL)
d630 1
a630 1
  /* Work out which section the relocation is targetted at and the
d673 1
a673 1
	 If we are producing relocateable output, then we must ensure
d682 1
a682 1
	 producing relocateable output it is not what the code
d693 1
a693 1
  if (output_bfd != (bfd *) NULL)
d737 1
a737 1
relocateable output for COFF.  That's peculiar.  In fact, I really
d752 3
a754 3
So everything works fine when not producing relocateable output.  When
we are producing relocateable output, logically we should do exactly
what we do when not producing relocateable output.  Therefore, your
d762 1
a762 1
When I wanted to make coff-i386 produce relocateable output, I ran
d956 6
a961 7
	bfd_reloc_status_type
                bfd_install_relocation
                        (bfd *abfd,
                         arelent *reloc_entry,
                         PTR data, bfd_vma data_start,
                         asection *input_section,
			 char **error_message);
d974 6
a979 8
bfd_install_relocation (abfd, reloc_entry, data_start, data_start_offset,
			input_section, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     PTR data_start;
     bfd_vma data_start_offset;
     asection *input_section;
     char **error_message;
d1020 1
a1020 1
  /* Work out which section the relocation is targetted at and the
d1062 1
a1062 1
	 If we are producing relocateable output, then we must ensure
d1071 1
a1071 1
	 producing relocateable output it is not what the code
d1123 1
a1123 1
relocateable output for COFF.  That's peculiar.  In fact, I really
d1138 3
a1140 3
So everything works fine when not producing relocateable output.  When
we are producing relocateable output, logically we should do exactly
what we do when not producing relocateable output.  Therefore, your
d1148 1
a1148 1
When I wanted to make coff-i386 produce relocateable output, I ran
d1272 1
a1272 1
	char x = bfd_get_8 (abfd, (char *) data);
d1274 1
a1274 1
	bfd_put_8 (abfd, x, (unsigned char *) data);
d1280 1
a1280 1
	short x = bfd_get_16 (abfd, (bfd_byte *) data);
d1282 1
a1282 1
	bfd_put_16 (abfd, (bfd_vma) x, (unsigned char *) data);
d1287 1
a1287 1
	long x = bfd_get_32 (abfd, (bfd_byte *) data);
d1289 1
a1289 1
	bfd_put_32 (abfd, (bfd_vma) x, (bfd_byte *) data);
d1294 1
a1294 1
	long x = bfd_get_32 (abfd, (bfd_byte *) data);
d1297 1
a1297 1
	bfd_put_32 (abfd, (bfd_vma) x, (bfd_byte *) data);
d1307 1
a1307 1
	bfd_vma x = bfd_get_64 (abfd, (bfd_byte *) data);
d1309 1
a1309 1
	bfd_put_64 (abfd, x, (bfd_byte *) data);
d1326 1
a1326 1
   relocateable link depends upon how the object format defines
d1342 7
a1348 9
_bfd_final_link_relocate (howto, input_bfd, input_section, contents, address,
			  value, addend)
     reloc_howto_type *howto;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     bfd_vma address;
     bfd_vma value;
     bfd_vma addend;
d1387 4
a1390 5
_bfd_relocate_contents (howto, input_bfd, relocation, location)
     reloc_howto_type *howto;
     bfd *input_bfd;
     bfd_vma relocation;
     bfd_byte *location;
d2120 2
d2123 1
d2142 28
d2173 34
a2206 1
COMMENT
d2208 1
a2208 2
  MIPS ELF relocations.

d2538 1
a2538 1
  The type of reloc used to build a contructor table - at the moment
d2942 31
d3033 1
a3033 1
  bits placed non-contigously in the instruction.
d3038 1
a3038 1
  bits placed non-contigously in the instruction.
d3195 2
d3473 11
d3544 1
a3544 1
  linker the inheritence tree of a C++ virtual function table.  The
d3737 1
a3737 1
  of instruction and change some branchs to use PC-relative
d3767 5
d4009 2
a4010 2
	reloc_howto_type *
	bfd_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code);
d4020 1
a4020 3
bfd_reloc_type_lookup (abfd, code)
     bfd *abfd;
     bfd_reloc_code_real_type code;
d4034 1
a4034 1
	(bfd *abfd, bfd_reloc_code_real_type  code);
d4042 1
a4042 3
bfd_default_reloc_type_lookup (abfd, code)
     bfd *abfd;
     bfd_reloc_code_real_type code;
d4063 1
a4063 1
  return (reloc_howto_type *) NULL;
d4079 1
a4079 2
bfd_get_reloc_code_name (code)
     bfd_reloc_code_real_type code;
d4081 1
a4081 1
  if ((int) code > (int) BFD_RELOC_UNUSED)
d4083 1
a4083 1
  return bfd_reloc_code_real_names[(int)code];
d4092 4
a4095 4
	 (bfd *abfd,
	  asection *section,
	  struct bfd_link_info *,
	  bfd_boolean *);
d4099 2
a4100 1
	don't do relaxing -- i.e., does nothing.
d4104 4
a4107 5
bfd_generic_relax_section (abfd, section, link_info, again)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
     struct bfd_link_info *link_info ATTRIBUTE_UNUSED;
     bfd_boolean *again;
d4109 5
d4124 1
a4124 1
	 (bfd *, struct bfd_link_info *);
d4132 2
a4133 3
bfd_generic_gc_sections (abfd, link_info)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *link_info ATTRIBUTE_UNUSED;
d4144 1
a4144 1
	 (bfd *, struct bfd_link_info *);
d4152 2
a4153 3
bfd_generic_merge_sections (abfd, link_info)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *link_info ATTRIBUTE_UNUSED;
d4163 7
a4169 7
	bfd_byte *
	   bfd_generic_get_relocated_section_contents (bfd *abfd,
	     struct bfd_link_info *link_info,
	     struct bfd_link_order *link_order,
	     bfd_byte *data,
	     bfd_boolean relocateable,
	     asymbol **symbols);
d4178 6
a4183 8
bfd_generic_get_relocated_section_contents (abfd, link_info, link_order, data,
					    relocateable, symbols)
     bfd *abfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     bfd_byte *data;
     bfd_boolean relocateable;
     asymbol **symbols;
d4196 1
a4196 1
  reloc_vector = (arelent **) bfd_malloc ((bfd_size_type) reloc_size);
d4203 2
a4204 2
				 (PTR) data,
				 (bfd_vma) 0,
d4208 7
a4214 2
  /* We're not relaxing the section, so just copy the size info.  */
  input_section->_cooked_size = input_section->_raw_size;
d4227 1
a4227 2
      for (parent = reloc_vector; *parent != (arelent *) NULL;
	   parent++)
d4229 1
a4229 1
	  char *error_message = (char *) NULL;
d4233 1
a4233 1
				    (PTR) data,
d4235 1
a4235 1
				    relocateable ? abfd : (bfd *) NULL,
d4238 1
a4238 1
	  if (relocateable)
d4259 1
a4259 1
		  BFD_ASSERT (error_message != (char *) NULL);
@


1.7
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2000, 2001
d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d68 1
a68 1
.       {* No errors detected *}
d71 1
a71 1
.       {* The relocation was performed, but there was an overflow. *}
d74 1
a74 1
.       {* The address to relocate was not within the section supplied. *}
d77 1
a77 1
.       {* Used by special functions *}
d80 1
a80 1
.       {* Unsupported relocation size requested. *}
d83 1
a83 1
.       {* Unused *}
d86 1
a86 1
.       {* The symbol to relocate against was undefined. *}
d89 4
a92 4
.       {* The relocation was performed, but may not be ok - presently
.          generated only when linking i960 coff files with i960 b.out
.          symbols.  If this type is returned, the error_message argument
.          to bfd_perform_relocation will be set.  *}
d100 1
a100 1
.       {* A pointer into the canonical table of pointers  *}
d103 1
a103 1
.       {* offset in section *}
d106 1
a106 1
.       {* addend for relocation value *}
d109 1
a109 1
.       {* Pointer to how to perform the required relocation *}
d112 3
a114 2
.} arelent;

d254 1
a254 1
.	{* Do not complain on overflow. *}
d257 2
a258 2
.	{* Complain if the bitfield overflows, whether it is considered
.	   as signed or unsigned. *}
d261 2
a262 2
.	{* Complain if the value overflows when considered as signed
.	   number. *}
d265 2
a266 2
.	{* Complain if the value overflows when considered as an
.	   unsigned number. *}
d280 1
a280 1
.struct symbol_cache_entry;		{* Forward declaration *}
d284 6
a289 6
.       {*  The type field has mainly a documentary use - the back end can
.           do what it wants with it, though normally the back end's
.           external idea of what a reloc number is stored
.           in this field. For example, a PC relative word relocation
.           in a coff environment has the type 023 - because that's
.           what the outside world calls a R_PCRWORD reloc. *}
d292 2
a293 2
.       {*  The value the final relocation is shifted right by. This drops
.           unwanted data from the relocation.  *}
d296 3
a298 3
.	{*  The size of the item to be relocated.  This is *not* a
.	    power-of-two measure.  To get the number of bytes operated
.	    on by a type of relocation, use bfd_get_reloc_size.  *}
d301 2
a302 2
.       {*  The number of bits in the item to be relocated.  This is used
.	    when doing overflow checking.  *}
d305 5
a309 5
.       {*  Notes that the relocation is relative to the location in the
.           data section of the addend. The relocation function will
.           subtract from the relocation value the address of the location
.           being relocated. *}
.  boolean pc_relative;
d311 2
a312 2
.	{*  The bit position of the reloc value in the destination.
.	    The relocated value is left shifted by this amount. *}
d315 2
a316 2
.	{* What type of overflow error should be checked for when
.	   relocating. *}
d319 4
a322 4
.       {* If this field is non null, then the supplied function is
.          called rather than the normal function. This allows really
.          strange relocation methods to be accomodated (e.g., i960 callj
.          instructions). *}
d324 2
a325 7
.				    PARAMS ((bfd *abfd,
.					     arelent *reloc_entry,
.                                            struct symbol_cache_entry *symbol,
.                                            PTR data,
.                                            asection *input_section,
.                                            bfd *output_bfd,
.                                            char **error_message));
d327 1
a327 1
.       {* The textual name of the relocation type. *}
d330 25
a354 24
.       {* Some formats record a relocation addend in the section contents
.          rather than with the relocation.  For ELF formats this is the
.          distinction between USE_REL and USE_RELA (though the code checks
.          for USE_REL == 1/0).  The value of this field is TRUE if the
.          addend is recorded with the section contents; when performing a
.          partial link (ld -r) the section contents (the data) will be
.          modified.  The value of this field is FALSE if addends are
.          recorded with the relocation (in arelent.addend); when performing
.          a partial link the relocation will be modified.
.          All relocations for all ELF USE_RELA targets should set this field
.          to FALSE (values of TRUE should be looked on with suspicion).
.          However, the converse is not true: not all relocations of all ELF
.          USE_REL targets set this field to TRUE.  Why this is so is peculiar
.          to each particular target.  For relocs that aren't used in partial
.          links (e.g. GOT stuff) it doesn't matter what this is set to.  *}
.  boolean partial_inplace;
.
.       {* The src_mask selects which parts of the read in data
.          are to be used in the relocation sum.  E.g., if this was an 8 bit
.          byte of data which we read and relocated, this would be
.          0x000000ff. When we have relocs which have an addend, such as
.          sun4 extended relocs, the value in the offset part of a
.          relocating field is garbage so we never use it. In this case
.          the mask would be 0x00000000. *}
d357 2
a358 4
.       {* The dst_mask selects which parts of the instruction are replaced
.          into the instruction. In most cases src_mask == dst_mask,
.          except in the above special case, where dst_mask would be
.          0x000000ff, and src_mask would be 0x00000000.   *}
d361 8
a368 7
.       {* When some formats create PC relative instructions, they leave
.          the value of the pc of the place being relocated in the offset
.          slot of the instruction, so that a PC relative relocation can
.          be made just by adding in an ordinary offset (e.g., sun3 a.out).
.          Some formats leave the displacement part of an instruction
.          empty (e.g., m88k bcs); this flag signals the fact.*}
.  boolean pcrel_offset;
a369 2
.};

d379 2
a380 2
.#define HOWTO(C, R,S,B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC) \
.  {(unsigned)C,R,S,B, P, BI, O,SF,NAME,INPLACE,MASKSRC,MASKDST,PC}
d386 3
a388 1
.#define NEWHOWTO( FUNCTION, NAME,SIZE,REL,IN) HOWTO(0,0,SIZE,0,REL,0,complain_overflow_dont,FUNCTION, NAME,false,0,0,IN)
d395 2
a396 1
.  HOWTO((C),0,0,0,false,0,complain_overflow_dont,NULL,NULL,false,0,0,false)
d402 15
a416 12
.#define HOWTO_PREPARE(relocation, symbol)      \
.  {                                            \
.  if (symbol != (asymbol *)NULL) {             \
.    if (bfd_is_com_section (symbol->section)) { \
.      relocation = 0;                          \
.    }                                          \
.    else {                                     \
.      relocation = symbol->value;              \
.    }                                          \
.  }                                            \
.}

d456 2
a457 1
.typedef struct relent_chain {
d459 4
a462 3
.  struct   relent_chain *next;
.} arelent_chain;

d631 2
a632 2
  if (reloc_entry->address > input_section->_cooked_size /
      bfd_octets_per_byte (abfd))
d647 2
a648 1
  if (output_bfd && howto->partial_inplace == false)
d661 1
a661 1
  if (howto->pc_relative == true)
d674 1
a674 1
	 i386-aout, pcrel_offset is false.  Some other targets do not
d676 1
a676 1
	 or ELF.  For those targets, pcrel_offset is true.
d680 1
a680 1
	 relocation is done.  If pcrel_offset is false we want to wind
d683 1
a683 1
	 in the location within the section.  If pcrel_offset is true
d694 1
a694 1
      if (howto->pcrel_offset == true)
d700 1
a700 1
      if (howto->partial_inplace == false)
d824 3
a826 5
  /*
    Either we are relocating all the way, or we don't want to apply
    the relocation to the reloc entry (probably because there isn't
    any room in the output format to describe addends to relocs)
    */
d853 1
a853 2
  /* Shift everything up to where it's going to be used */

d856 1
a856 1
  /* Wait for the day when all have the mask in them */
d906 1
a906 1
	bfd_put_16 (abfd, x, (unsigned char *) data + octets);
d913 1
a913 1
	bfd_put_32 (abfd, x, (bfd_byte *) data + octets);
d921 1
a921 1
	bfd_put_32 (abfd, x, (bfd_byte *) data + octets);
d930 1
a930 1
	bfd_put_16 (abfd, x, (bfd_byte *) data + octets);
a976 1

d1024 2
a1025 1
  if (reloc_entry->address > input_section->_cooked_size)
d1040 1
a1040 1
  if (howto->partial_inplace == false)
d1053 1
a1053 1
  if (howto->pc_relative == true)
d1066 1
a1066 1
	 i386-aout, pcrel_offset is false.  Some other targets do not
d1068 1
a1068 1
	 or ELF.  For those targets, pcrel_offset is true.
d1072 1
a1072 1
	 relocation is done.  If pcrel_offset is false we want to wind
d1075 1
a1075 1
	 in the location within the section.  If pcrel_offset is true
d1086 1
a1086 1
      if (howto->pcrel_offset == true && howto->partial_inplace == true)
d1090 1
a1090 1
  if (howto->partial_inplace == false)
a1105 1

d1181 1
a1181 2
       right
*/
d1206 3
a1208 5
  /*
    Either we are relocating all the way, or we don't want to apply
    the relocation to the reloc entry (probably because there isn't
    any room in the output format to describe addends to relocs)
    */
d1235 1
a1235 2
  /* Shift everything up to where it's going to be used */

d1238 1
a1238 1
  /* Wait for the day when all have the mask in them */
d1290 1
a1290 1
	bfd_put_16 (abfd, x, (unsigned char *) data);
d1297 1
a1297 1
	bfd_put_32 (abfd, x, (bfd_byte *) data);
d1305 1
a1305 1
	bfd_put_32 (abfd, x, (bfd_byte *) data);
d1377 1
a1377 1
     pcrel_offset is false.  Other targets (e.g., m88kbcs or ELF)
d1379 1
a1379 1
     targets pcrel_offset is true.  If pcrel_offset is false we do not
d1679 2
d1689 2
d1853 2
d1875 50
a1980 21
     The GNU linker currently doesn't do any of this optimizing.

ENUM
  BFD_RELOC_ALPHA_USER_LITERAL
ENUMX
  BFD_RELOC_ALPHA_USER_LITUSE_BASE
ENUMX
  BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF
ENUMX
  BFD_RELOC_ALPHA_USER_LITUSE_JSR
ENUMX
  BFD_RELOC_ALPHA_USER_GPDISP
ENUMX
  BFD_RELOC_ALPHA_USER_GPRELHIGH
ENUMX
  BFD_RELOC_ALPHA_USER_GPRELLOW
ENUMDOC
  The BFD_RELOC_ALPHA_USER_* relocations are used by the assembler to
     process the explicit !<reloc>!sequence relocations, and are mapped
     into the normal relocations at the end of processing.

d2001 44
a2083 6
ENUMEQ
  BFD_RELOC_MIPS_GPREL
  BFD_RELOC_GPREL16
ENUMDOC
  Relocation relative to the global pointer.

a2092 3
ENUMEQX
  BFD_RELOC_MIPS_GPREL32
  BFD_RELOC_GPREL32
d2132 22
d2175 24
d2218 16
d2265 7
d2346 46
d2396 83
d2522 2
d2615 114
d2730 1
a2730 1
  Hitachi SH relocs.  Not all of these appear in object files.
d2842 13
d2857 1
a2857 1
  Mitsubishi M32R relocs.
d2964 12
a2975 2
COMMENT

d3083 72
d3240 197
d3534 4
d3580 6
d3588 2
d3594 11
a3604 1
  BFD_RELOC_IA64_LTOFF_TP22
d3606 9
a3614 1
  BFD_RELOC_IA64_LTOFF22X
d3616 1
a3616 1
  BFD_RELOC_IA64_LDXMOV
d3624 1
a3624 1
  This is the 8 bits high part of an absolute address.
d3629 1
a3629 1
  This is the 8 bits low part of an absolute address.
d3634 37
a3670 1
  This is the 3 bits of a value.
d3685 38
d3791 105
d3927 1
a3927 1
HOWTO (0, 00, 2, 32, false, 0, complain_overflow_bitfield, 0, "VRT32", false, 0xffffffff, 0xffffffff, true);
d3985 1
a3985 1
  if (code > BFD_RELOC_UNUSED)
d3995 1
a3995 1
	boolean bfd_generic_relax_section
d3999 1
a3999 1
	  boolean *);
d4006 1
a4006 2
/*ARGSUSED*/
boolean
d4011 1
a4011 1
     boolean *again;
d4013 2
a4014 2
  *again = false;
  return true;
d4022 1
a4022 1
	boolean bfd_generic_gc_sections
d4030 1
a4030 2
/*ARGSUSED*/
boolean
d4035 22
a4056 1
  return true;
d4069 1
a4069 1
	     boolean relocateable,
d4085 1
a4085 1
     boolean relocateable;
d4088 1
a4088 1
  /* Get enough memory to hold the stuff */
d4099 1
a4099 1
  reloc_vector = (arelent **) bfd_malloc ((size_t) reloc_size);
d4103 1
a4103 1
  /* read in the section */
d4107 1
a4107 1
				 0,
d4111 1
a4111 1
  /* We're not relaxing the section, so just copy the size info */
d4113 1
a4113 1
  input_section->reloc_done = true;
d4141 1
a4141 1
	      /* A partial link, so keep the relocs */
d4154 1
a4154 1
			 true)))
@


1.6
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
a149 1

a163 1

a166 1

a176 1

a180 1

a184 1

a187 1

a196 1

a218 1

a229 1

a384 1

a391 1

a580 1

a641 1

a717 2
	      && strcmp (abfd->xvec->name, "aixcoff-rs6000") != 0
	      && strcmp (abfd->xvec->name, "xcoff-powermac") != 0
a979 1

a1110 2
	  && strcmp (abfd->xvec->name, "aixcoff-rs6000") != 0
	  && strcmp (abfd->xvec->name, "xcoff-powermac") != 0
a1768 1

d1803 2
d1806 2
d2044 22
d2092 19
d2233 12
d2336 14
d2366 1
a2366 1
  Argonaut RISC Core (ARC) relocs.
d2593 33
d2694 1
a2694 1
  program memory address) into 16 bits.  
d2788 228
a3022 1

a3037 1

a3048 1

a3058 1

@


1.5
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d28 1
a28 1
	en-mass and translated into an internal form.  A common
d292 1
a292 1
.       {*  The type field has mainly a documetary use - the back end can
d343 15
a357 2
.       {* When performing a partial link, some formats must modify the
.          relocations rather than the data - this flag signals this.*}
d362 1
a362 1
.          bit of data which we read and relocated, this would be
d405 8
d435 1
a435 1
	int bfd_get_reloc_size (reloc_howto_type *);
d442 1
a442 1
int
d474 37
d512 47
d605 1
a605 1
  bfd_size_type addr = reloc_entry->address;
d641 2
a642 1
  if (reloc_entry->address > input_section->_cooked_size)
d830 5
a834 69
    {
      bfd_vma check;

      /* Get the value that will be used for the relocation, but
	 starting at bit position zero.  */
      check = relocation >> howto->rightshift;
      switch (howto->complain_on_overflow)
	{
	case complain_overflow_signed:
	  {
	    /* Assumes two's complement.  */
	    bfd_signed_vma reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;
	    bfd_signed_vma reloc_signed_min = ~reloc_signed_max;

	    /* The above right shift is incorrect for a signed value.
	       Fix it up by forcing on the upper bits.  */
	    if (howto->rightshift > 0
		&& (bfd_signed_vma) relocation < 0)
	      check |= ((bfd_vma) - 1
			& ~((bfd_vma) - 1
			    >> howto->rightshift));
	    if ((bfd_signed_vma) check > reloc_signed_max
		|| (bfd_signed_vma) check < reloc_signed_min)
	      flag = bfd_reloc_overflow;
	  }
	  break;
	case complain_overflow_unsigned:
	  {
	    /* Assumes two's complement.  This expression avoids
	       overflow if howto->bitsize is the number of bits in
	       bfd_vma.  */
	    bfd_vma reloc_unsigned_max =
	    (((1 << (howto->bitsize - 1)) - 1) << 1) | 1;

	    if ((bfd_vma) check > reloc_unsigned_max)
	      flag = bfd_reloc_overflow;
	  }
	  break;
	case complain_overflow_bitfield:
	  {
	    /* Assumes two's complement.  This expression avoids
	       overflow if howto->bitsize is the number of bits in
	       bfd_vma.  */
	    bfd_vma reloc_bits = (((1 << (howto->bitsize - 1)) - 1) << 1) | 1;

	    if (((bfd_vma) check & ~reloc_bits) != 0
		&& ((bfd_vma) check & ~reloc_bits) != (-1 & ~reloc_bits))
	      {
		/* The above right shift is incorrect for a signed
		   value.  See if turning on the upper bits fixes the
		   overflow.  */
		if (howto->rightshift > 0
		    && (bfd_signed_vma) relocation < 0)
		  {
		    check |= ((bfd_vma) - 1
			      & ~((bfd_vma) - 1
				  >> howto->rightshift));
		    if (((bfd_vma) check & ~reloc_bits) != (-1 & ~reloc_bits))
		      flag = bfd_reloc_overflow;
		  }
		else
		  flag = bfd_reloc_overflow;
	      }
	  }
	  break;
	default:
	  abort ();
	}
    }
d885 3
a887 3
     i i i i i o o o o o        from bfd_get<size>
     and           S S S S S    to get the size offset we want
     +   r r r r r r r r r r  to get the final value to place
d890 1
a890 1
     A A A A A
d892 2
a893 2
     ...   i i i i i o o o o o  from bfd_get<size>
     and   N N N N N            get instruction
d895 1
a895 1
     ...   B B B B B
d898 2
a899 2
     B B B B B
     or              A A A A A
d901 1
a901 1
     R R R R R R R R R R        put into bfd_put<size>
d911 1
a911 1
	char x = bfd_get_8 (abfd, (char *) data + addr);
d913 1
a913 1
	bfd_put_8 (abfd, x, (unsigned char *) data + addr);
d919 1
a919 1
	short x = bfd_get_16 (abfd, (bfd_byte *) data + addr);
d921 1
a921 1
	bfd_put_16 (abfd, x, (unsigned char *) data + addr);
d926 1
a926 1
	long x = bfd_get_32 (abfd, (bfd_byte *) data + addr);
d928 1
a928 1
	bfd_put_32 (abfd, x, (bfd_byte *) data + addr);
d933 1
a933 1
	long x = bfd_get_32 (abfd, (bfd_byte *) data + addr);
d936 1
a936 1
	bfd_put_32 (abfd, x, (bfd_byte *) data + addr);
d942 1
a942 1
	long x = bfd_get_16 (abfd, (bfd_byte *) data + addr);
d945 1
a945 1
	bfd_put_16 (abfd, x, (bfd_byte *) data + addr);
d956 1
a956 1
	bfd_vma x = bfd_get_64 (abfd, (bfd_byte *) data + addr);
d958 1
a958 1
	bfd_put_64 (abfd, x, (bfd_byte *) data + addr);
d1008 1
a1008 1
  bfd_size_type addr = reloc_entry->address;
d1028 1
a1052 1

a1216 1

d1220 5
a1224 69
    {
      bfd_vma check;

      /* Get the value that will be used for the relocation, but
	 starting at bit position zero.  */
      check = relocation >> howto->rightshift;
      switch (howto->complain_on_overflow)
	{
	case complain_overflow_signed:
	  {
	    /* Assumes two's complement.  */
	    bfd_signed_vma reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;
	    bfd_signed_vma reloc_signed_min = ~reloc_signed_max;

	    /* The above right shift is incorrect for a signed value.
	       Fix it up by forcing on the upper bits.  */
	    if (howto->rightshift > 0
		&& (bfd_signed_vma) relocation < 0)
	      check |= ((bfd_vma) - 1
			& ~((bfd_vma) - 1
			    >> howto->rightshift));
	    if ((bfd_signed_vma) check > reloc_signed_max
		|| (bfd_signed_vma) check < reloc_signed_min)
	      flag = bfd_reloc_overflow;
	  }
	  break;
	case complain_overflow_unsigned:
	  {
	    /* Assumes two's complement.  This expression avoids
	       overflow if howto->bitsize is the number of bits in
	       bfd_vma.  */
	    bfd_vma reloc_unsigned_max =
	    (((1 << (howto->bitsize - 1)) - 1) << 1) | 1;

	    if ((bfd_vma) check > reloc_unsigned_max)
	      flag = bfd_reloc_overflow;
	  }
	  break;
	case complain_overflow_bitfield:
	  {
	    /* Assumes two's complement.  This expression avoids
	       overflow if howto->bitsize is the number of bits in
	       bfd_vma.  */
	    bfd_vma reloc_bits = (((1 << (howto->bitsize - 1)) - 1) << 1) | 1;

	    if (((bfd_vma) check & ~reloc_bits) != 0
		&& ((bfd_vma) check & ~reloc_bits) != (-1 & ~reloc_bits))
	      {
		/* The above right shift is incorrect for a signed
		   value.  See if turning on the upper bits fixes the
		   overflow.  */
		if (howto->rightshift > 0
		    && (bfd_signed_vma) relocation < 0)
		  {
		    check |= ((bfd_vma) - 1
			      & ~((bfd_vma) - 1
				  >> howto->rightshift));
		    if (((bfd_vma) check & ~reloc_bits) != (-1 & ~reloc_bits))
		      flag = bfd_reloc_overflow;
		  }
		else
		  flag = bfd_reloc_overflow;
	      }
	  }
	  break;
	default:
	  abort ();
	}
    }
d1275 3
a1277 3
     i i i i i o o o o o        from bfd_get<size>
     and           S S S S S    to get the size offset we want
     +   r r r r r r r r r r  to get the final value to place
d1280 1
a1280 1
     A A A A A
d1282 2
a1283 2
     ...   i i i i i o o o o o  from bfd_get<size>
     and   N N N N N            get instruction
d1285 1
a1285 1
     ...   B B B B B
d1288 2
a1289 2
     B B B B B
     or              A A A A A
d1291 1
a1291 1
     R R R R R R R R R R        put into bfd_put<size>
d1297 1
a1297 1
  data = (bfd_byte *) data_start + (addr - data_start_offset);
d1356 3
a1358 2
   This routine does a final relocation.  It should not be used when
   generating relocateable output.
d1427 4
a1430 2
  bfd_vma x;
  boolean overflow;
d1466 1
a1466 1
  overflow = false;
d1469 2
a1470 4
      bfd_vma check;
      bfd_signed_vma signed_check;
      bfd_vma add;
      bfd_signed_vma signed_add;
d1472 8
a1479 9
      if (howto->rightshift == 0)
	{
	  check = relocation;
	  signed_check = (bfd_signed_vma) relocation;
	}
      else
	{
	  /* Drop unwanted bits from the value we are relocating to.  */
	  check = relocation >> howto->rightshift;
d1481 1
a1481 28
	  /* If this is a signed value, the rightshift just dropped
	     leading 1 bits (assuming twos complement).  */
	  if ((bfd_signed_vma) relocation >= 0)
	    signed_check = check;
	  else
	    signed_check = (check
			    | ((bfd_vma) - 1
			       & ~((bfd_vma) - 1 >> howto->rightshift)));
	}

      /* Get the value from the object file.  */
      add = x & howto->src_mask;

      /* Get the value from the object file with an appropriate sign.
	 The expression involving howto->src_mask isolates the upper
	 bit of src_mask.  If that bit is set in the value we are
	 adding, it is negative, and we subtract out that number times
	 two.  If src_mask includes the highest possible bit, then we
	 can not get the upper bit, but that does not matter since
	 signed_add needs no adjustment to become negative in that
	 case.  */
      signed_add = add;
      if ((add & (((~howto->src_mask) >> 1) & howto->src_mask)) != 0)
	signed_add -= (((~howto->src_mask) >> 1) & howto->src_mask) << 1;

      /* Add the value from the object file, shifted so that it is a
	 straight number.  */
      if (howto->bitpos == 0)
d1483 2
a1484 6
	  check += add;
	  signed_check += signed_add;
	}
      else
	{
	  check += add >> howto->bitpos;
d1486 35
a1520 10
	  /* For the signed case we use ADD, rather than SIGNED_ADD,
	     to avoid warnings from SVR4 cc.  This is OK since we
	     explictly handle the sign bits.  */
	  if (signed_add >= 0)
	    signed_check += add >> howto->bitpos;
	  else
	    signed_check += ((add >> howto->bitpos)
			     | ((bfd_vma) - 1
				& ~((bfd_vma) - 1 >> howto->bitpos)));
	}
a1521 12
      switch (howto->complain_on_overflow)
	{
	case complain_overflow_signed:
	  {
	    /* Assumes two's complement.  */
	    bfd_signed_vma reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;
	    bfd_signed_vma reloc_signed_min = ~reloc_signed_max;

	    if (signed_check > reloc_signed_max
		|| signed_check < reloc_signed_min)
	      overflow = true;
	  }
d1523 1
d1525 17
a1541 10
	  {
	    /* Assumes two's complement.  This expression avoids
	       overflow if howto->bitsize is the number of bits in
	       bfd_vma.  */
	    bfd_vma reloc_unsigned_max =
	    (((1 << (howto->bitsize - 1)) - 1) << 1) | 1;

	    if (check > reloc_unsigned_max)
	      overflow = true;
	  }
d1543 1
d1545 29
a1573 11
	  {
	    /* Assumes two's complement.  This expression avoids
	       overflow if howto->bitsize is the number of bits in
	       bfd_vma.  */
	    bfd_vma reloc_bits = (((1 << (howto->bitsize - 1)) - 1) << 1) | 1;

	    if ((check & ~reloc_bits) != 0
		&& (((bfd_vma) signed_check & ~reloc_bits)
		    != (-1 & ~reloc_bits)))
	      overflow = true;
	  }
d1575 1
d1582 2
a1583 2
  relocation >>= (bfd_vma) howto->rightshift;
  relocation <<= (bfd_vma) howto->bitpos;
d1613 1
a1613 1
  return overflow ? bfd_reloc_overflow : bfd_reloc_ok;
d1654 2
a1859 2
  BFD_RELOC_SPARC_GLOB_JMP
ENUMX
d1865 22
d1888 1
a1888 1
  Some relocations we're using for SPARC V9 -- subject to change.
a1916 2
  BFD_RELOC_ALPHA_LITERALSLEAZY
ENUMX
a1929 3
     The LITERALSLEAZY reloc is a hack to allow larger offsets (4x) than
     LITERAL.

d1948 19
d1980 6
d1992 10
d2051 9
d2063 2
d2112 15
d2190 5
d2209 2
d2240 18
d2301 219
d2522 168
a2689 1
COMMENT
d2691 4
a2694 1
COMMENT
d2696 6
a2701 1
COMMENT
d2820 3
a2822 3
     bfd *abfd;
     asection *section;
     struct bfd_link_info *link_info;
d2831 22
d2945 2
a2946 1
			 input_bfd, input_section, (*parent)->address)))
@


1.4
log
@Alpha support based on Chris Demetriou's <cgd@@cs.cmu.edu> work
@
text
@d141 1
a141 1
	
d875 5
a879 6
      if (relocation)
	{
	  short x = bfd_get_16 (abfd, (bfd_byte *) data + addr);
	  DOIT (x);
	  bfd_put_16 (abfd, x, (unsigned char *) data + addr);
	}
d882 5
a886 6
      if (relocation)
	{
	  long x = bfd_get_32 (abfd, (bfd_byte *) data + addr);
	  DOIT (x);
	  bfd_put_32 (abfd, x, (bfd_byte *) data + addr);
	}
d912 5
a916 6
      if (relocation)
	{
	  bfd_vma x = bfd_get_64 (abfd, (bfd_byte *) data + addr);
	  DOIT (x);
	  bfd_put_64 (abfd, x, (bfd_byte *) data + addr);
	}
d1076 1
a1076 1
	 
d1079 1
a1079 1
      
d1081 1
a1081 1
      
d1093 1
a1093 1
	     
d1096 1
a1096 1
	     
d1332 5
a1336 6
      if (relocation)
	{
	  short x = bfd_get_16 (abfd, (bfd_byte *) data);
	  DOIT (x);
	  bfd_put_16 (abfd, x, (unsigned char *) data);
	}
d1339 5
a1343 6
      if (relocation)
	{
	  long x = bfd_get_32 (abfd, (bfd_byte *) data);
	  DOIT (x);
	  bfd_put_32 (abfd, x, (bfd_byte *) data);
	}
d1359 5
a1363 6
      if (relocation)
	{
	  bfd_vma x = bfd_get_64 (abfd, (bfd_byte *) data);
	  DOIT (x);
	  bfd_put_64 (abfd, x, (bfd_byte *) data);
	}
d1909 2
d1922 9
d2209 2
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d1913 2
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 1995 Free Software Foundation, Inc.
d431 1
d625 1
d1088 1
d1889 2
a1890 2
  Alpha ECOFF relocations.  Some of these treat the symbol or "addend"
     in some special way.
d1904 7
d1943 6
d2148 12
d2164 39
d2204 5
@


1.1
log
@Initial revision
@
text
@d1410 1
a1410 1
  if (address > input_section->_cooked_size)
d1875 5
a1879 1
  BFD_RELOC_SPARC_LO7
d1980 8
d2065 32
d2303 1
a2303 1
  reloc_vector = (arelent **) malloc ((size_t) reloc_size);
d2305 1
a2305 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d1410 1
a1410 1
  if (address > input_section->_raw_size)
d1875 1
a1875 5
  BFD_RELOC_SPARC_7
ENUMX
  BFD_RELOC_SPARC_6
ENUMX
  BFD_RELOC_SPARC_5
a1975 8
ENUMX
  BFD_RELOC_MIPS_GOT_HI16
ENUMX
  BFD_RELOC_MIPS_GOT_LO16
ENUMX
  BFD_RELOC_MIPS_CALL_HI16
ENUMX
  BFD_RELOC_MIPS_CALL_LO16
a2052 32
ENUMX
  BFD_RELOC_PPC_EMB_NADDR32
ENUMX
  BFD_RELOC_PPC_EMB_NADDR16
ENUMX
  BFD_RELOC_PPC_EMB_NADDR16_LO
ENUMX
  BFD_RELOC_PPC_EMB_NADDR16_HI
ENUMX
  BFD_RELOC_PPC_EMB_NADDR16_HA
ENUMX
  BFD_RELOC_PPC_EMB_SDAI16
ENUMX
  BFD_RELOC_PPC_EMB_SDA2I16
ENUMX
  BFD_RELOC_PPC_EMB_SDA2REL
ENUMX
  BFD_RELOC_PPC_EMB_SDA21
ENUMX
  BFD_RELOC_PPC_EMB_MRKREF
ENUMX
  BFD_RELOC_PPC_EMB_RELSEC16
ENUMX
  BFD_RELOC_PPC_EMB_RELST_LO
ENUMX
  BFD_RELOC_PPC_EMB_RELST_HI
ENUMX
  BFD_RELOC_PPC_EMB_RELST_HA
ENUMX
  BFD_RELOC_PPC_EMB_BIT_FLD
ENUMX
  BFD_RELOC_PPC_EMB_RELSDA
d2259 1
a2259 1
  reloc_vector = (arelent **) bfd_malloc ((size_t) reloc_size);
d2261 4
a2264 1
    goto error_return;
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a430 1
    case 8: return 16;
a623 1
	      && strcmp (abfd->xvec->name, "xcoff-powermac") != 0
a1085 1
	  && strcmp (abfd->xvec->name, "xcoff-powermac") != 0
d1886 2
a1887 2
  Alpha ECOFF and ELF relocations.  Some of these treat the symbol or
     "addend" in some special way.
a1900 7
  BFD_RELOC_ALPHA_GPDISP
ENUMDOC
  The ELF GPDISP relocation is exactly the same as the GPDISP_HI16
     relocation except that there is no accompanying GPDISP_LO16
     relocation.

ENUM
a1932 6
  BFD_RELOC_ALPHA_LINKAGE
ENUMDOC
  The LINKAGE relocation outputs a linkage pair in the object file,
     which is filled by the linker.

ENUM
a2131 12
ENUMX
  BFD_RELOC_ARM_OFFSET_IMM8
ENUMX
  BFD_RELOC_ARM_HWLITERAL
ENUMX
  BFD_RELOC_ARM_THUMB_ADD
ENUMX
  BFD_RELOC_ARM_THUMB_IMM
ENUMX
  BFD_RELOC_ARM_THUMB_SHIFT
ENUMX
  BFD_RELOC_ARM_THUMB_OFFSET
a2135 39
ENUM
  BFD_RELOC_SH_PCDISP8BY2
ENUMX
  BFD_RELOC_SH_PCDISP12BY2
ENUMX
  BFD_RELOC_SH_IMM4
ENUMX
  BFD_RELOC_SH_IMM4BY2
ENUMX
  BFD_RELOC_SH_IMM4BY4
ENUMX
  BFD_RELOC_SH_IMM8
ENUMX
  BFD_RELOC_SH_IMM8BY2
ENUMX
  BFD_RELOC_SH_IMM8BY4
ENUMX
  BFD_RELOC_SH_PCRELIMM8BY2
ENUMX
  BFD_RELOC_SH_PCRELIMM8BY4
ENUMX
  BFD_RELOC_SH_SWITCH16
ENUMX
  BFD_RELOC_SH_SWITCH32
ENUMX
  BFD_RELOC_SH_USES
ENUMX
  BFD_RELOC_SH_COUNT
ENUMX
  BFD_RELOC_SH_ALIGN
ENUMX
  BFD_RELOC_SH_CODE
ENUMX
  BFD_RELOC_SH_DATA
ENUMX
  BFD_RELOC_SH_LABEL
ENUMDOC
  Hitachi SH relocs.  Not all of these appear in object files.

a2136 5

COMMENT

COMMENT

@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d141 1
a141 1

d875 6
a880 5
      {
	short x = bfd_get_16 (abfd, (bfd_byte *) data + addr);
	DOIT (x);
	bfd_put_16 (abfd, x, (unsigned char *) data + addr);
      }
d883 6
a888 5
      {
	long x = bfd_get_32 (abfd, (bfd_byte *) data + addr);
	DOIT (x);
	bfd_put_32 (abfd, x, (bfd_byte *) data + addr);
      }
d914 6
a919 5
      {
	bfd_vma x = bfd_get_64 (abfd, (bfd_byte *) data + addr);
	DOIT (x);
	bfd_put_64 (abfd, x, (bfd_byte *) data + addr);
      }
d1079 1
a1079 1

d1082 1
a1082 1

d1084 1
a1084 1

d1096 1
a1096 1

d1099 1
a1099 1

d1335 6
a1340 5
      {
	short x = bfd_get_16 (abfd, (bfd_byte *) data);
	DOIT (x);
	bfd_put_16 (abfd, x, (unsigned char *) data);
      }
d1343 6
a1348 5
      {
	long x = bfd_get_32 (abfd, (bfd_byte *) data);
	DOIT (x);
	bfd_put_32 (abfd, x, (bfd_byte *) data);
      }
d1364 6
a1369 5
      {
	bfd_vma x = bfd_get_64 (abfd, (bfd_byte *) data);
	DOIT (x);
	bfd_put_64 (abfd, x, (bfd_byte *) data);
      }
a1912 2
  BFD_RELOC_ALPHA_ELF_LITERAL
ENUMX
a1923 6
     The ELF_LITERAL reloc is somewhere between 16_GOTOFF and GPDISP_LO16.
     It should refer to the symbol to be referenced, as with 16_GOTOFF,
     but it generates output not based on the position within the .got
     section, but relative to the GP value chosen for the file during the
     final link stage.

a2201 2

COMMENT
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 2
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 1997
   Free Software Foundation, Inc.
d291 1
a291 1
.       {*  The type field has mainly a documentary use - the back end can
a1665 2
  BFD_RELOC_24
ENUMX
a1950 6
  BFD_RELOC_ALPHA_CODEADDR
ENUMDOC
  The CODEADDR relocation outputs a STO_CA in the object file,
     which is filled by the linker.

ENUM
a1956 10
  BFD_RELOC_MIPS16_JMP
ENUMDOC
  The MIPS16 jump instruction.

ENUM
  BFD_RELOC_MIPS16_GPREL
ENUMDOC
  MIPS16 GP relative reloc.

ENUM
a2207 25
ENUM
  BFD_RELOC_D10V_10_PCREL_R
ENUMDOC
  Mitsubishi D10V relocs.
  This is a 10-bit reloc with the right 2 bits
  assumed to be 0.
ENUM
  BFD_RELOC_D10V_10_PCREL_L
ENUMDOC
  Mitsubishi D10V relocs.
  This is a 10-bit reloc with the right 2 bits
  assumed to be 0.  This is the same as the previous reloc
  except it is in the left container, i.e.,
  shifted left 15 bits.
ENUM
  BFD_RELOC_D10V_18
ENUMDOC
  This is an 18-bit reloc with the right 2 bits
  assumed to be 0.
ENUM
  BFD_RELOC_D10V_18_PCREL
ENUMDOC
  This is an 18-bit reloc with the right 2 bits
  assumed to be 0.
COMMENT
a2210 37
ENUM
  BFD_RELOC_M32R_24
ENUMDOC
  Mitsubishi M32R relocs.
  This is a 24 bit absolute address.
ENUM
  BFD_RELOC_M32R_10_PCREL
ENUMDOC
  This is a 10-bit pc-relative reloc with the right 2 bits assumed to be 0.
ENUM
  BFD_RELOC_M32R_18_PCREL
ENUMDOC
  This is an 18-bit reloc with the right 2 bits assumed to be 0.
ENUM
  BFD_RELOC_M32R_26_PCREL
ENUMDOC
  This is a 26-bit reloc with the right 2 bits assumed to be 0.
ENUM
  BFD_RELOC_M32R_HI16_ULO
ENUMDOC
  This is a 16-bit reloc containing the high 16 bits of an address
  used when the lower 16 bits are treated as unsigned.
ENUM
  BFD_RELOC_M32R_HI16_SLO
ENUMDOC
  This is a 16-bit reloc containing the high 16 bits of an address
  used when the lower 16 bits are treated as signed.
ENUM
  BFD_RELOC_M32R_LO16
ENUMDOC
  This is a 16-bit reloc containing the lower 16 bits of an address.
ENUM
  BFD_RELOC_M32R_SDA16
ENUMDOC
  This is a 16-bit reloc containing the small data area offset for use in
  add3, load, and store instructions.

a2212 10
ENUM
  BFD_RELOC_MN10300_32_PCREL
ENUMDOC
  This is a 32bit pcrel reloc for the mn10300, offset by two bytes in the
  instruction.
ENUM
  BFD_RELOC_MN10300_16_PCREL
ENUMDOC
  This is a 16bit pcrel reloc for the mn10300, offset by two bytes in the
  instruction.
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d28 1
a28 1
	en-masse and translated into an internal form.  A common
d343 2
a344 15
.       {* Some formats record a relocation addend in the section contents
.          rather than with the relocation.  For ELF formats this is the
.          distinction between USE_REL and USE_RELA (though the code checks
.          for USE_REL == 1/0).  The value of this field is TRUE if the
.          addend is recorded with the section contents; when performing a
.          partial link (ld -r) the section contents (the data) will be
.          modified.  The value of this field is FALSE if addends are
.          recorded with the relocation (in arelent.addend); when performing
.          a partial link the relocation will be modified.
.          All relocations for all ELF USE_RELA targets should set this field
.          to FALSE (values of TRUE should be looked on with suspicion).
.          However, the converse is not true: not all relocations of all ELF
.          USE_REL targets set this field to TRUE.  Why this is so is peculiar
.          to each particular target.  For relocs that aren't used in partial
.          links (e.g. GOT stuff) it doesn't matter what this is set to.  *}
d349 1
a349 1
.          byte of data which we read and relocated, this would be
a391 8

DESCRIPTION
	This is used to fill in an empty howto entry in an array.

.#define EMPTY_HOWTO(C) \
.  HOWTO((C),0,0,0,false,0,complain_overflow_dont,NULL,NULL,false,0,0,false)
.

d414 1
a414 1
	unsigned int bfd_get_reloc_size (reloc_howto_type *);
d421 1
a421 1
unsigned int
a452 2
/* N_ONES produces N one bits, without overflowing machine arithmetic.  */
#define N_ONES(n) (((((bfd_vma) 1 << ((n) - 1)) - 1) << 1) | 1)
a453 82
/*
FUNCTION
	bfd_check_overflow

SYNOPSIS
	bfd_reloc_status_type
		bfd_check_overflow
			(enum complain_overflow how,
			 unsigned int bitsize,
			 unsigned int rightshift,
			 unsigned int addrsize,
			 bfd_vma relocation);

DESCRIPTION
	Perform overflow checking on @@var{relocation} which has
	@@var{bitsize} significant bits and will be shifted right by
	@@var{rightshift} bits, on a machine with addresses containing
	@@var{addrsize} significant bits.  The result is either of
	@@code{bfd_reloc_ok} or @@code{bfd_reloc_overflow}.

*/

bfd_reloc_status_type
bfd_check_overflow (how, bitsize, rightshift, addrsize, relocation)
     enum complain_overflow how;
     unsigned int bitsize;
     unsigned int rightshift;
     unsigned int addrsize;
     bfd_vma relocation;
{
  bfd_vma fieldmask, addrmask, signmask, ss, a;
  bfd_reloc_status_type flag = bfd_reloc_ok;

  a = relocation;

  /* Note: BITSIZE should always be <= ADDRSIZE, but in case it's not,
     we'll be permissive: extra bits in the field mask will
     automatically extend the address mask for purposes of the
     overflow check.  */
  fieldmask = N_ONES (bitsize);
  addrmask = N_ONES (addrsize) | fieldmask;

  switch (how)
    {
    case complain_overflow_dont:
      break;

    case complain_overflow_signed:
      /* If any sign bits are set, all sign bits must be set.  That
         is, A must be a valid negative address after shifting.  */
      a = (a & addrmask) >> rightshift;
      signmask = ~ (fieldmask >> 1);
      ss = a & signmask;
      if (ss != 0 && ss != ((addrmask >> rightshift) & signmask))
	flag = bfd_reloc_overflow;
      break;

    case complain_overflow_unsigned:
      /* We have an overflow if the address does not fit in the field.  */
      a = (a & addrmask) >> rightshift;
      if ((a & ~ fieldmask) != 0)
	flag = bfd_reloc_overflow;
      break;

    case complain_overflow_bitfield:
      /* Bitfields are sometimes signed, sometimes unsigned.  We
	 explicitly allow an address wrap too, which means a bitfield
	 of n bits is allowed to store -2**n to 2**n-1.  Thus overflow
	 if the value has some, but not all, bits set outside the
	 field.  */
      a >>= rightshift;
      ss = a & ~ fieldmask;
      if (ss != 0 && ss != (((bfd_vma) -1 >> rightshift) & ~ fieldmask))
	flag = bfd_reloc_overflow;
      break;

    default:
      abort ();
    }

  return flag;
}
d500 1
a500 1
  bfd_size_type octets = reloc_entry->address * bfd_octets_per_byte (abfd);
d536 1
a536 2
  if (reloc_entry->address > input_section->_cooked_size /
      bfd_octets_per_byte (abfd))
d724 69
a792 5
    flag = bfd_check_overflow (howto->complain_on_overflow,
			       howto->bitsize,
			       howto->rightshift,
			       bfd_arch_bits_per_address (abfd),
			       relocation);
d843 3
a845 3
     ((  i i i i i o o o o o  from bfd_get<size>
     and           S S S S S) to get the size offset we want
     +   r r r r r r r r r r) to get the final value to place
d848 1
a848 1
     =             A A A A A
d850 2
a851 2
     (   i i i i i o o o o o  from bfd_get<size>
     and N N N N N          ) get instruction
d853 1
a853 1
     =   B B B B B
d856 2
a857 2
     (   B B B B B
     or            A A A A A)
d859 1
a859 1
     =   R R R R R R R R R R  put into bfd_put<size>
d869 1
a869 1
	char x = bfd_get_8 (abfd, (char *) data + octets);
d871 1
a871 1
	bfd_put_8 (abfd, x, (unsigned char *) data + octets);
d877 1
a877 1
	short x = bfd_get_16 (abfd, (bfd_byte *) data + octets);
d879 1
a879 1
	bfd_put_16 (abfd, x, (unsigned char *) data + octets);
d884 1
a884 1
	long x = bfd_get_32 (abfd, (bfd_byte *) data + octets);
d886 1
a886 1
	bfd_put_32 (abfd, x, (bfd_byte *) data + octets);
d891 1
a891 1
	long x = bfd_get_32 (abfd, (bfd_byte *) data + octets);
d894 1
a894 1
	bfd_put_32 (abfd, x, (bfd_byte *) data + octets);
d900 1
a900 1
	long x = bfd_get_16 (abfd, (bfd_byte *) data + octets);
d903 1
a903 1
	bfd_put_16 (abfd, x, (bfd_byte *) data + octets);
d914 1
a914 1
	bfd_vma x = bfd_get_64 (abfd, (bfd_byte *) data + octets);
d916 1
a916 1
	bfd_put_64 (abfd, x, (bfd_byte *) data + octets);
d966 1
a966 1
  bfd_size_type octets = reloc_entry->address * bfd_octets_per_byte (abfd);
a985 1

d1010 1
d1175 1
d1179 69
a1247 5
    flag = bfd_check_overflow (howto->complain_on_overflow,
			       howto->bitsize,
			       howto->rightshift,
			       bfd_arch_bits_per_address (abfd),
			       relocation);
d1298 3
a1300 3
     ((  i i i i i o o o o o  from bfd_get<size>
     and           S S S S S) to get the size offset we want
     +   r r r r r r r r r r) to get the final value to place
d1303 1
a1303 1
     =             A A A A A
d1305 2
a1306 2
     (   i i i i i o o o o o  from bfd_get<size>
     and N N N N N          ) get instruction
d1308 1
a1308 1
     =   B B B B B
d1311 2
a1312 2
     (   B B B B B
     or            A A A A A)
d1314 1
a1314 1
     =   R R R R R R R R R R  put into bfd_put<size>
d1320 1
a1320 1
  data = (bfd_byte *) data_start + (octets - data_start_offset);
d1379 2
a1380 3
   This routine does a final relocation.  Whether it is useful for a
   relocateable link depends upon how the object format defines
   relocations.
d1449 2
a1450 4
  bfd_vma x = 0;
  bfd_reloc_status_type flag;
  unsigned int rightshift = howto->rightshift;
  unsigned int bitpos = howto->bitpos;
d1486 1
a1486 1
  flag = bfd_reloc_ok;
d1489 50
a1538 2
      bfd_vma addrmask, fieldmask, signmask, ss;
      bfd_vma a, b, sum;
d1540 10
a1549 8
      /* Get the values to be added together.  For signed and unsigned
         relocations, we assume that all values should be truncated to
         the size of an address.  For bitfields, all the bits matter.
         See also bfd_check_overflow.  */
      fieldmask = N_ONES (howto->bitsize);
      addrmask = N_ONES (bfd_arch_bits_per_address (input_bfd)) | fieldmask;
      a = relocation;
      b = x & howto->src_mask;
d1554 9
a1562 38
	  a = (a & addrmask) >> rightshift;

	  /* If any sign bits are set, all sign bits must be set.
	     That is, A must be a valid negative address after
	     shifting.  */
	  signmask = ~ (fieldmask >> 1);
	  ss = a & signmask;
	  if (ss != 0 && ss != ((addrmask >> rightshift) & signmask))
	    flag = bfd_reloc_overflow;

	  /* We only need this next bit of code if the sign bit of B
             is below the sign bit of A.  This would only happen if
             SRC_MASK had fewer bits than BITSIZE.  Note that if
             SRC_MASK has more bits than BITSIZE, we can get into
             trouble; we would need to verify that B is in range, as
             we do for A above.  */
	  signmask = ((~ howto->src_mask) >> 1) & howto->src_mask;

	  /* Set all the bits above the sign bit.  */
	  b = (b ^ signmask) - signmask;

	  b = (b & addrmask) >> bitpos;

	  /* Now we can do the addition.  */
	  sum = a + b;

	  /* See if the result has the correct sign.  Bits above the
             sign bit are junk now; ignore them.  If the sum is
             positive, make sure we did not have all negative inputs;
             if the sum is negative, make sure we did not have all
             positive inputs.  The test below looks only at the sign
             bits, and it really just
	         SIGN (A) == SIGN (B) && SIGN (A) != SIGN (SUM)
	     */
	  signmask = (fieldmask >> 1) + 1;
	  if (((~ (a ^ b)) & (a ^ sum)) & signmask)
	    flag = bfd_reloc_overflow;

a1563 1

d1565 10
a1574 17
	  /* Checking for an unsigned overflow is relatively easy:
             trim the addresses and add, and trim the result as well.
             Overflow is normally indicated when the result does not
             fit in the field.  However, we also need to consider the
             case when, e.g., fieldmask is 0x7fffffff or smaller, an
             input is 0x80000000, and bfd_vma is only 32 bits; then we
             will get sum == 0, but there is an overflow, since the
             inputs did not fit in the field.  Instead of doing a
             separate test, we can check for this by or-ing in the
             operands when testing for the sum overflowing its final
             field.  */
	  a = (a & addrmask) >> rightshift;
	  b = (b & addrmask) >> bitpos;
	  sum = (a + b) & addrmask;
	  if ((a | b | sum) & ~ fieldmask)
	    flag = bfd_reloc_overflow;

a1575 1

d1577 11
a1587 29
	  /* Much like the signed check, but for a field one bit
	     wider, and no trimming inputs with addrmask.  We allow a
	     bitfield to represent numbers in the range -2**n to
	     2**n-1, where n is the number of bits in the field.
	     Note that when bfd_vma is 32 bits, a 32-bit reloc can't
	     overflow, which is exactly what we want.  */
	  a >>= rightshift;

	  signmask = ~ fieldmask;
	  ss = a & signmask;
	  if (ss != 0 && ss != (((bfd_vma) -1 >> rightshift) & signmask))
	    flag = bfd_reloc_overflow;

	  signmask = ((~ howto->src_mask) >> 1) & howto->src_mask;
	  b = (b ^ signmask) - signmask;

	  b >>= bitpos;

	  sum = a + b;

	  /* We mask with addrmask here to explicitly allow an address
	     wrap-around.  The Linux kernel relies on it, and it is
	     the only way to write assembler code which can run when
	     loaded at a location 0x80000000 away from the location at
	     which it is linked.  */
	  signmask = fieldmask + 1;
	  if (((~ (a ^ b)) & (a ^ sum)) & signmask & addrmask)
	    flag = bfd_reloc_overflow;

a1588 1

d1595 2
a1596 2
  relocation >>= (bfd_vma) rightshift;
  relocation <<= (bfd_vma) bitpos;
d1626 1
a1626 1
  return flag;
d1873 2
a1879 17
ENUMEQX
  BFD_RELOC_SPARC_DISP64
  BFD_RELOC_64_PCREL
ENUMX
  BFD_RELOC_SPARC_PLT64
ENUMX
  BFD_RELOC_SPARC_HIX22
ENUMX
  BFD_RELOC_SPARC_LOX10
ENUMX
  BFD_RELOC_SPARC_H44
ENUMX
  BFD_RELOC_SPARC_M44
ENUMX
  BFD_RELOC_SPARC_L44
ENUMX
  BFD_RELOC_SPARC_REGISTER
d1881 1
a1881 6
  SPARC64 relocations

ENUM
  BFD_RELOC_SPARC_REV32
ENUMDOC
  SPARC little endian relocation
a1940 19
  BFD_RELOC_ALPHA_USER_LITERAL
ENUMX
  BFD_RELOC_ALPHA_USER_LITUSE_BASE
ENUMX
  BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF
ENUMX
  BFD_RELOC_ALPHA_USER_LITUSE_JSR
ENUMX
  BFD_RELOC_ALPHA_USER_GPDISP
ENUMX
  BFD_RELOC_ALPHA_USER_GPRELHIGH
ENUMX
  BFD_RELOC_ALPHA_USER_GPRELLOW
ENUMDOC
  The BFD_RELOC_ALPHA_USER_* relocations are used by the assembler to
     process the explicit !<reloc>!sequence relocations, and are mapped
     into the normal relocations at the end of processing.

ENUM
a2024 9
ENUMX
  BFD_RELOC_MIPS_SUB
ENUMX
  BFD_RELOC_MIPS_GOT_PAGE
ENUMX
  BFD_RELOC_MIPS_GOT_OFST
ENUMX
  BFD_RELOC_MIPS_GOT_DISP
COMMENT
a2027 2
COMMENT

a2074 15
  BFD_RELOC_PJ_CODE_HI16
ENUMX
  BFD_RELOC_PJ_CODE_LO16
ENUMX
  BFD_RELOC_PJ_CODE_DIR16
ENUMX
  BFD_RELOC_PJ_CODE_DIR32
ENUMX
  BFD_RELOC_PJ_CODE_REL16
ENUMX
  BFD_RELOC_PJ_CODE_REL32
ENUMDOC
  Picojava relocs.  Not all of these appear in object files.

ENUM
a2137 5
  BFD_RELOC_I370_D12
ENUMDOC
  IBM 370/390 relocations

ENUM
a2151 2
  BFD_RELOC_ARM_ADRL_IMMEDIATE
ENUMX
a2180 18
ENUMX
  BFD_RELOC_ARM_GOT12
ENUMX
  BFD_RELOC_ARM_GOT32
ENUMX
  BFD_RELOC_ARM_JUMP_SLOT
ENUMX
  BFD_RELOC_ARM_COPY
ENUMX
  BFD_RELOC_ARM_GLOB_DAT
ENUMX
  BFD_RELOC_ARM_PLT32
ENUMX
  BFD_RELOC_ARM_RELATIVE
ENUMX
  BFD_RELOC_ARM_GOTOFF
ENUMX
  BFD_RELOC_ARM_GOTPC
d2224 1
a2224 23
ENUM
  BFD_RELOC_THUMB_PCREL_BRANCH9
ENUMX
  BFD_RELOC_THUMB_PCREL_BRANCH12
ENUMX
  BFD_RELOC_THUMB_PCREL_BRANCH23
ENUMDOC
  Thumb 23-, 12- and 9-bit pc-relative branches.  The lowest bit must
  be zero and is not stored in the instruction.

ENUM
  BFD_RELOC_ARC_B22_PCREL
ENUMDOC
  Argonaut RISC Core (ARC) relocs.
  ARC 22 bit pc-relative branch.  The lowest two bits must be zero and are
  not stored in the instruction.  The high 20 bits are installed in bits 26
  through 7 of the instruction.
ENUM
  BFD_RELOC_ARC_B26
ENUMDOC
  ARC 26 bit absolute branch.  The lowest two bits must be zero and are not
  stored in the instruction.  The high 24 bits are installed in bits 23
  through 0.
d2226 1
d2251 1
d2253 1
a2253 59
ENUM
  BFD_RELOC_D30V_6
ENUMDOC
  Mitsubishi D30V relocs.
  This is a 6-bit absolute reloc.
ENUM
  BFD_RELOC_D30V_9_PCREL
ENUMDOC
  This is a 6-bit pc-relative reloc with
  the right 3 bits assumed to be 0.
ENUM
  BFD_RELOC_D30V_9_PCREL_R
ENUMDOC
  This is a 6-bit pc-relative reloc with
  the right 3 bits assumed to be 0. Same
  as the previous reloc but on the right side
  of the container.
ENUM
  BFD_RELOC_D30V_15
ENUMDOC
  This is a 12-bit absolute reloc with the
  right 3 bitsassumed to be 0.
ENUM
  BFD_RELOC_D30V_15_PCREL
ENUMDOC
  This is a 12-bit pc-relative reloc with
  the right 3 bits assumed to be 0.
ENUM
  BFD_RELOC_D30V_15_PCREL_R
ENUMDOC
  This is a 12-bit pc-relative reloc with
  the right 3 bits assumed to be 0. Same
  as the previous reloc but on the right side
  of the container.
ENUM
  BFD_RELOC_D30V_21
ENUMDOC
  This is an 18-bit absolute reloc with
  the right 3 bits assumed to be 0.
ENUM
  BFD_RELOC_D30V_21_PCREL
ENUMDOC
  This is an 18-bit pc-relative reloc with
  the right 3 bits assumed to be 0.
ENUM
  BFD_RELOC_D30V_21_PCREL_R
ENUMDOC
  This is an 18-bit pc-relative reloc with
  the right 3 bits assumed to be 0. Same
  as the previous reloc but on the right side
  of the container.
ENUM
  BFD_RELOC_D30V_32
ENUMDOC
  This is a 32-bit absolute reloc.
ENUM
  BFD_RELOC_D30V_32_PCREL
ENUMDOC
  This is a 32-bit pc-relative reloc.
a2291 73
ENUM
  BFD_RELOC_V850_9_PCREL
ENUMDOC
  This is a 9-bit reloc
ENUM
  BFD_RELOC_V850_22_PCREL
ENUMDOC
  This is a 22-bit reloc

ENUM
  BFD_RELOC_V850_SDA_16_16_OFFSET
ENUMDOC
  This is a 16 bit offset from the short data area pointer.
ENUM
  BFD_RELOC_V850_SDA_15_16_OFFSET
ENUMDOC
  This is a 16 bit offset (of which only 15 bits are used) from the
  short data area pointer.
ENUM
  BFD_RELOC_V850_ZDA_16_16_OFFSET
ENUMDOC
  This is a 16 bit offset from the zero data area pointer.
ENUM
  BFD_RELOC_V850_ZDA_15_16_OFFSET
ENUMDOC
  This is a 16 bit offset (of which only 15 bits are used) from the
  zero data area pointer.
ENUM
  BFD_RELOC_V850_TDA_6_8_OFFSET
ENUMDOC
  This is an 8 bit offset (of which only 6 bits are used) from the
  tiny data area pointer.
ENUM
  BFD_RELOC_V850_TDA_7_8_OFFSET
ENUMDOC
  This is an 8bit offset (of which only 7 bits are used) from the tiny
  data area pointer.
ENUM
  BFD_RELOC_V850_TDA_7_7_OFFSET
ENUMDOC
  This is a 7 bit offset from the tiny data area pointer.
ENUM
  BFD_RELOC_V850_TDA_16_16_OFFSET
ENUMDOC
  This is a 16 bit offset from the tiny data area pointer.
COMMENT
ENUM
  BFD_RELOC_V850_TDA_4_5_OFFSET
ENUMDOC
  This is a 5 bit offset (of which only 4 bits are used) from the tiny
  data area pointer.
ENUM
  BFD_RELOC_V850_TDA_4_4_OFFSET
ENUMDOC
  This is a 4 bit offset from the tiny data area pointer.
ENUM
  BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET
ENUMDOC
  This is a 16 bit offset from the short data area pointer, with the
  bits placed non-contigously in the instruction.
ENUM
  BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET
ENUMDOC
  This is a 16 bit offset from the zero data area pointer, with the
  bits placed non-contigously in the instruction.
ENUM
  BFD_RELOC_V850_CALLT_6_7_OFFSET
ENUMDOC
  This is a 6 bit offset from the call table base pointer.
ENUM
  BFD_RELOC_V850_CALLT_16_16_OFFSET
ENUMDOC
  This is a 16 bit offset from the call table base pointer.
a2303 171

ENUM
  BFD_RELOC_TIC30_LDP
ENUMDOC
  This is a 8bit DP reloc for the tms320c30, where the most
  significant 8 bits of a 24 bit word are placed into the least
  significant 8 bits of the opcode.

ENUM
  BFD_RELOC_FR30_48
ENUMDOC
  This is a 48 bit reloc for the FR30 that stores 32 bits.
ENUM
  BFD_RELOC_FR30_20
ENUMDOC
  This is a 32 bit reloc for the FR30 that stores 20 bits split up into
  two sections.
ENUM
  BFD_RELOC_FR30_6_IN_4
ENUMDOC
  This is a 16 bit reloc for the FR30 that stores a 6 bit word offset in
  4 bits.
ENUM
  BFD_RELOC_FR30_8_IN_8
ENUMDOC
  This is a 16 bit reloc for the FR30 that stores an 8 bit byte offset
  into 8 bits.
ENUM
  BFD_RELOC_FR30_9_IN_8
ENUMDOC
  This is a 16 bit reloc for the FR30 that stores a 9 bit short offset
  into 8 bits.
ENUM
  BFD_RELOC_FR30_10_IN_8
ENUMDOC
  This is a 16 bit reloc for the FR30 that stores a 10 bit word offset
  into 8 bits.
ENUM
  BFD_RELOC_FR30_9_PCREL
ENUMDOC
  This is a 16 bit reloc for the FR30 that stores a 9 bit pc relative
  short offset into 8 bits.
ENUM
  BFD_RELOC_FR30_12_PCREL
ENUMDOC
  This is a 16 bit reloc for the FR30 that stores a 12 bit pc relative
  short offset into 11 bits.

ENUM
  BFD_RELOC_MCORE_PCREL_IMM8BY4
ENUMX
  BFD_RELOC_MCORE_PCREL_IMM11BY2
ENUMX
  BFD_RELOC_MCORE_PCREL_IMM4BY2
ENUMX
  BFD_RELOC_MCORE_PCREL_32
ENUMX
  BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2
ENUMX
  BFD_RELOC_MCORE_RVA
ENUMDOC
  Motorola Mcore relocations.

ENUM
  BFD_RELOC_AVR_7_PCREL
ENUMDOC
  This is a 16 bit reloc for the AVR that stores 8 bit pc relative
  short offset into 7 bits.
ENUM
  BFD_RELOC_AVR_13_PCREL
ENUMDOC
  This is a 16 bit reloc for the AVR that stores 13 bit pc relative
  short offset into 12 bits.
ENUM
  BFD_RELOC_AVR_16_PM
ENUMDOC
  This is a 16 bit reloc for the AVR that stores 17 bit value (usually
  program memory address) into 16 bits.  
ENUM
  BFD_RELOC_AVR_LO8_LDI
ENUMDOC
  This is a 16 bit reloc for the AVR that stores 8 bit value (usually
  data memory address) into 8 bit immediate value of LDI insn.
ENUM
  BFD_RELOC_AVR_HI8_LDI
ENUMDOC
  This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
  of data memory address) into 8 bit immediate value of LDI insn.
ENUM
  BFD_RELOC_AVR_HH8_LDI
ENUMDOC
  This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
  of program memory address) into 8 bit immediate value of LDI insn.
ENUM
  BFD_RELOC_AVR_LO8_LDI_NEG
ENUMDOC
  This is a 16 bit reloc for the AVR that stores negated 8 bit value
  (usually data memory address) into 8 bit immediate value of SUBI insn.
ENUM
  BFD_RELOC_AVR_HI8_LDI_NEG
ENUMDOC
  This is a 16 bit reloc for the AVR that stores negated 8 bit value
  (high 8 bit of data memory address) into 8 bit immediate value of
  SUBI insn.
ENUM
  BFD_RELOC_AVR_HH8_LDI_NEG
ENUMDOC
  This is a 16 bit reloc for the AVR that stores negated 8 bit value
  (most high 8 bit of program memory address) into 8 bit immediate value
  of LDI or SUBI insn.
ENUM
  BFD_RELOC_AVR_LO8_LDI_PM
ENUMDOC
  This is a 16 bit reloc for the AVR that stores 8 bit value (usually
  command address) into 8 bit immediate value of LDI insn.
ENUM
  BFD_RELOC_AVR_HI8_LDI_PM
ENUMDOC
  This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
  of command address) into 8 bit immediate value of LDI insn.
ENUM
  BFD_RELOC_AVR_HH8_LDI_PM
ENUMDOC
  This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
  of command address) into 8 bit immediate value of LDI insn.
ENUM
  BFD_RELOC_AVR_LO8_LDI_PM_NEG
ENUMDOC
  This is a 16 bit reloc for the AVR that stores negated 8 bit value
  (usually command address) into 8 bit immediate value of SUBI insn.
ENUM
  BFD_RELOC_AVR_HI8_LDI_PM_NEG
ENUMDOC
  This is a 16 bit reloc for the AVR that stores negated 8 bit value
  (high 8 bit of 16 bit command address) into 8 bit immediate value
  of SUBI insn.
ENUM
  BFD_RELOC_AVR_HH8_LDI_PM_NEG
ENUMDOC
  This is a 16 bit reloc for the AVR that stores negated 8 bit value
  (high 6 bit of 22 bit command address) into 8 bit immediate
  value of SUBI insn.
ENUM
  BFD_RELOC_AVR_CALL
ENUMDOC
  This is a 32 bit reloc for the AVR that stores 23 bit value
  into 22 bits.

ENUM
  BFD_RELOC_VTABLE_INHERIT
ENUMX
  BFD_RELOC_VTABLE_ENTRY
ENUMDOC
  These two relocations are used by the linker to determine which of
  the entries in a C++ virtual function table are actually used.  When
  the --gc-sections option is given, the linker will zero out the entries
  that are not used, so that the code for those functions need not be
  included in the output.

  VTABLE_INHERIT is a zero-space relocation used to describe to the
  linker the inheritence tree of a C++ virtual function table.  The
  relocation's symbol should be the parent class' vtable, and the
  relocation should be located at the child vtable.

  VTABLE_ENTRY is a zero-space relocation that describes the use of a
  virtual function table entry.  The reloc's symbol should refer to the
  table of the class mentioned in the code.  Off of that base, an offset
  describes the entry that is being used.  For Rela hosts, this offset
  is stored in the reloc's addend.  For Rel hosts, we are forced to put
  this offset in the reloc's section offset.

d2421 3
a2423 3
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
     struct bfd_link_info *link_info ATTRIBUTE_UNUSED;
a2431 22
	bfd_generic_gc_sections

SYNOPSIS
	boolean bfd_generic_gc_sections
	 (bfd *, struct bfd_link_info *);

DESCRIPTION
	Provides default handling for relaxing for back ends which
	don't do section gc -- i.e., does nothing.
*/

/*ARGSUSED*/
boolean
bfd_generic_gc_sections (abfd, link_info)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *link_info ATTRIBUTE_UNUSED;
{
  return true;
}

/*
INTERNAL_FUNCTION
d2524 1
a2524 2
			 input_bfd, input_section, (*parent)->address,
			 true)))
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
d149 1
d164 1
d168 1
d179 1
d184 1
d189 1
d193 1
d203 1
d226 1
d238 1
d394 1
d402 1
d592 1
d654 1
d731 2
d995 1
d1127 2
d1787 1
a1821 2
  BFD_RELOC_SPARC_UA16
ENUMX
a1822 2
ENUMX
  BFD_RELOC_SPARC_UA64
a2058 22
ENUMX
  BFD_RELOC_MIPS_SHIFT5
ENUMX
  BFD_RELOC_MIPS_SHIFT6
ENUMX
  BFD_RELOC_MIPS_INSERT_A
ENUMX
  BFD_RELOC_MIPS_INSERT_B
ENUMX
  BFD_RELOC_MIPS_DELETE
ENUMX
  BFD_RELOC_MIPS_HIGHEST
ENUMX
  BFD_RELOC_MIPS_HIGHER
ENUMX
  BFD_RELOC_MIPS_SCN_DISP
ENUMX
  BFD_RELOC_MIPS_REL16
ENUMX
  BFD_RELOC_MIPS_RELGOT
ENUMX
  BFD_RELOC_MIPS_JALR
a2084 19
  BFD_RELOC_X86_64_GOT32
ENUMX
  BFD_RELOC_X86_64_PLT32
ENUMX
  BFD_RELOC_X86_64_COPY
ENUMX
  BFD_RELOC_X86_64_GLOB_DAT
ENUMX
  BFD_RELOC_X86_64_JUMP_SLOT
ENUMX
  BFD_RELOC_X86_64_RELATIVE
ENUMX
  BFD_RELOC_X86_64_GOTPCREL
ENUMX
  BFD_RELOC_X86_64_32S
ENUMDOC
  x86-64/elf relocations

ENUM
a2206 12
  BFD_RELOC_ARM_PCREL_BLX
ENUMDOC
  ARM 26 bit pc-relative branch.  The lowest bit must be zero and is
  not stored in the instruction.  The 2nd lowest bit comes from a 1 bit
  field in the instruction.
ENUM
  BFD_RELOC_THUMB_PCREL_BLX
ENUMDOC
  Thumb 22 bit pc-relative branch.  The lowest bit must be zero and is
  not stored in the instruction.  The 2nd lowest bit comes from a 1 bit
  field in the instruction.
ENUM
a2297 14
ENUMX
  BFD_RELOC_SH_LOOP_START
ENUMX
  BFD_RELOC_SH_LOOP_END
ENUMX
  BFD_RELOC_SH_COPY
ENUMX
  BFD_RELOC_SH_GLOB_DAT
ENUMX
  BFD_RELOC_SH_JMP_SLOT
ENUMX
  BFD_RELOC_SH_RELATIVE
ENUMX
  BFD_RELOC_SH_GOTPC
d2314 1
a2314 1
  ARC Cores relocs.
a2540 33
  BFD_RELOC_TIC54X_PARTLS7
ENUMDOC
  This is a 7bit reloc for the tms320c54x, where the least
  significant 7 bits of a 16 bit word are placed into the least
  significant 7 bits of the opcode.

ENUM
  BFD_RELOC_TIC54X_PARTMS9
ENUMDOC
  This is a 9bit DP reloc for the tms320c54x, where the most
  significant 9 bits of a 16 bit word are placed into the least
  significant 9 bits of the opcode.

ENUM
  BFD_RELOC_TIC54X_23
ENUMDOC
  This is an extended address 23-bit reloc for the tms320c54x.

ENUM
  BFD_RELOC_TIC54X_16_OF_23
ENUMDOC
  This is a 16-bit reloc for the tms320c54x, where the least
  significant 16 bits of a 23-bit extended address are placed into
  the opcode.

ENUM
  BFD_RELOC_TIC54X_MS7_OF_23
ENUMDOC
  This is a reloc for the tms320c54x, where the most
  significant 7 bits of a 23-bit extended address are placed into
  the opcode.

ENUM
d2609 1
a2609 1
  program memory address) into 16 bits.
a2702 228
ENUM
  BFD_RELOC_IA64_IMM14
ENUMX
  BFD_RELOC_IA64_IMM22
ENUMX
  BFD_RELOC_IA64_IMM64
ENUMX
  BFD_RELOC_IA64_DIR32MSB
ENUMX
  BFD_RELOC_IA64_DIR32LSB
ENUMX
  BFD_RELOC_IA64_DIR64MSB
ENUMX
  BFD_RELOC_IA64_DIR64LSB
ENUMX
  BFD_RELOC_IA64_GPREL22
ENUMX
  BFD_RELOC_IA64_GPREL64I
ENUMX
  BFD_RELOC_IA64_GPREL32MSB
ENUMX
  BFD_RELOC_IA64_GPREL32LSB
ENUMX
  BFD_RELOC_IA64_GPREL64MSB
ENUMX
  BFD_RELOC_IA64_GPREL64LSB
ENUMX
  BFD_RELOC_IA64_LTOFF22
ENUMX
  BFD_RELOC_IA64_LTOFF64I
ENUMX
  BFD_RELOC_IA64_PLTOFF22
ENUMX
  BFD_RELOC_IA64_PLTOFF64I
ENUMX
  BFD_RELOC_IA64_PLTOFF64MSB
ENUMX
  BFD_RELOC_IA64_PLTOFF64LSB
ENUMX
  BFD_RELOC_IA64_FPTR64I
ENUMX
  BFD_RELOC_IA64_FPTR32MSB
ENUMX
  BFD_RELOC_IA64_FPTR32LSB
ENUMX
  BFD_RELOC_IA64_FPTR64MSB
ENUMX
  BFD_RELOC_IA64_FPTR64LSB
ENUMX
  BFD_RELOC_IA64_PCREL21B
ENUMX
  BFD_RELOC_IA64_PCREL21BI
ENUMX
  BFD_RELOC_IA64_PCREL21M
ENUMX
  BFD_RELOC_IA64_PCREL21F
ENUMX
  BFD_RELOC_IA64_PCREL22
ENUMX
  BFD_RELOC_IA64_PCREL60B
ENUMX
  BFD_RELOC_IA64_PCREL64I
ENUMX
  BFD_RELOC_IA64_PCREL32MSB
ENUMX
  BFD_RELOC_IA64_PCREL32LSB
ENUMX
  BFD_RELOC_IA64_PCREL64MSB
ENUMX
  BFD_RELOC_IA64_PCREL64LSB
ENUMX
  BFD_RELOC_IA64_LTOFF_FPTR22
ENUMX
  BFD_RELOC_IA64_LTOFF_FPTR64I
ENUMX
  BFD_RELOC_IA64_LTOFF_FPTR64MSB
ENUMX
  BFD_RELOC_IA64_LTOFF_FPTR64LSB
ENUMX
  BFD_RELOC_IA64_SEGREL32MSB
ENUMX
  BFD_RELOC_IA64_SEGREL32LSB
ENUMX
  BFD_RELOC_IA64_SEGREL64MSB
ENUMX
  BFD_RELOC_IA64_SEGREL64LSB
ENUMX
  BFD_RELOC_IA64_SECREL32MSB
ENUMX
  BFD_RELOC_IA64_SECREL32LSB
ENUMX
  BFD_RELOC_IA64_SECREL64MSB
ENUMX
  BFD_RELOC_IA64_SECREL64LSB
ENUMX
  BFD_RELOC_IA64_REL32MSB
ENUMX
  BFD_RELOC_IA64_REL32LSB
ENUMX
  BFD_RELOC_IA64_REL64MSB
ENUMX
  BFD_RELOC_IA64_REL64LSB
ENUMX
  BFD_RELOC_IA64_LTV32MSB
ENUMX
  BFD_RELOC_IA64_LTV32LSB
ENUMX
  BFD_RELOC_IA64_LTV64MSB
ENUMX
  BFD_RELOC_IA64_LTV64LSB
ENUMX
  BFD_RELOC_IA64_IPLTMSB
ENUMX
  BFD_RELOC_IA64_IPLTLSB
ENUMX
  BFD_RELOC_IA64_COPY
ENUMX
  BFD_RELOC_IA64_TPREL22
ENUMX
  BFD_RELOC_IA64_TPREL64MSB
ENUMX
  BFD_RELOC_IA64_TPREL64LSB
ENUMX
  BFD_RELOC_IA64_LTOFF_TP22
ENUMX
  BFD_RELOC_IA64_LTOFF22X
ENUMX
  BFD_RELOC_IA64_LDXMOV
ENUMDOC
  Intel IA64 Relocations.

ENUM
  BFD_RELOC_M68HC11_HI8
ENUMDOC
  Motorola 68HC11 reloc.
  This is the 8 bits high part of an absolute address.
ENUM
  BFD_RELOC_M68HC11_LO8
ENUMDOC
  Motorola 68HC11 reloc.
  This is the 8 bits low part of an absolute address.
ENUM
  BFD_RELOC_M68HC11_3B
ENUMDOC
  Motorola 68HC11 reloc.
  This is the 3 bits of a value.

ENUM
  BFD_RELOC_CRIS_BDISP8
ENUMX
  BFD_RELOC_CRIS_UNSIGNED_5
ENUMX
  BFD_RELOC_CRIS_SIGNED_6
ENUMX
  BFD_RELOC_CRIS_UNSIGNED_6
ENUMX
  BFD_RELOC_CRIS_UNSIGNED_4
ENUMDOC
  These relocs are only used within the CRIS assembler.  They are not
  (at present) written to any object files.

ENUM
  BFD_RELOC_860_COPY
ENUMX
  BFD_RELOC_860_GLOB_DAT
ENUMX
  BFD_RELOC_860_JUMP_SLOT
ENUMX
  BFD_RELOC_860_RELATIVE
ENUMX
  BFD_RELOC_860_PC26
ENUMX
  BFD_RELOC_860_PLT26
ENUMX
  BFD_RELOC_860_PC16
ENUMX
  BFD_RELOC_860_LOW0
ENUMX
  BFD_RELOC_860_SPLIT0
ENUMX
  BFD_RELOC_860_LOW1
ENUMX
  BFD_RELOC_860_SPLIT1
ENUMX
  BFD_RELOC_860_LOW2
ENUMX
  BFD_RELOC_860_SPLIT2
ENUMX
  BFD_RELOC_860_LOW3
ENUMX
  BFD_RELOC_860_LOGOT0
ENUMX
  BFD_RELOC_860_SPGOT0
ENUMX
  BFD_RELOC_860_LOGOT1
ENUMX
  BFD_RELOC_860_SPGOT1
ENUMX
  BFD_RELOC_860_LOGOTOFF0
ENUMX
  BFD_RELOC_860_SPGOTOFF0
ENUMX
  BFD_RELOC_860_LOGOTOFF1
ENUMX
  BFD_RELOC_860_SPGOTOFF1
ENUMX
  BFD_RELOC_860_LOGOTOFF2
ENUMX
  BFD_RELOC_860_LOGOTOFF3
ENUMX
  BFD_RELOC_860_LOPC
ENUMX
  BFD_RELOC_860_HIGHADJ
ENUMX
  BFD_RELOC_860_HAGOT
ENUMX
  BFD_RELOC_860_HAGOTOFF
ENUMX
  BFD_RELOC_860_HAPC
ENUMX
  BFD_RELOC_860_HIGH
ENUMX
  BFD_RELOC_860_HIGOT
ENUMX
  BFD_RELOC_860_HIGOTOFF
ENUMDOC
  Intel i860 Relocations.

d2710 1
d2726 1
d2738 1
d2749 1
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d68 1
a68 1
.  {* No errors detected.  *}
d71 1
a71 1
.  {* The relocation was performed, but there was an overflow.  *}
d74 1
a74 1
.  {* The address to relocate was not within the section supplied.  *}
d77 1
a77 1
.  {* Used by special functions.  *}
d80 1
a80 1
.  {* Unsupported relocation size requested.  *}
d83 1
a83 1
.  {* Unused.  *}
d86 1
a86 1
.  {* The symbol to relocate against was undefined.  *}
d89 4
a92 4
.  {* The relocation was performed, but may not be ok - presently
.     generated only when linking i960 coff files with i960 b.out
.     symbols.  If this type is returned, the error_message argument
.     to bfd_perform_relocation will be set.  *}
d100 1
a100 1
.  {* A pointer into the canonical table of pointers.  *}
d103 1
a103 1
.  {* offset in section.  *}
d106 1
a106 1
.  {* addend for relocation value.  *}
d109 1
a109 1
.  {* Pointer to how to perform the required relocation.  *}
d112 2
a113 3
.}
.arelent;
.
d253 1
a253 1
.  {* Do not complain on overflow.  *}
d256 2
a257 2
.  {* Complain if the bitfield overflows, whether it is considered
.     as signed or unsigned.  *}
d260 2
a261 2
.  {* Complain if the value overflows when considered as signed
.     number.  *}
d264 2
a265 2
.  {* Complain if the value overflows when considered as an
.     unsigned number.  *}
d279 1
a279 1
.struct symbol_cache_entry;		{* Forward declaration.  *}
d283 6
a288 6
.  {*  The type field has mainly a documentary use - the back end can
.      do what it wants with it, though normally the back end's
.      external idea of what a reloc number is stored
.      in this field.  For example, a PC relative word relocation
.      in a coff environment has the type 023 - because that's
.      what the outside world calls a R_PCRWORD reloc.  *}
d291 2
a292 2
.  {*  The value the final relocation is shifted right by.  This drops
.      unwanted data from the relocation.  *}
d295 3
a297 3
.  {*  The size of the item to be relocated.  This is *not* a
.      power-of-two measure.  To get the number of bytes operated
.      on by a type of relocation, use bfd_get_reloc_size.  *}
d300 2
a301 2
.  {*  The number of bits in the item to be relocated.  This is used
.      when doing overflow checking.  *}
d304 5
a308 5
.  {*  Notes that the relocation is relative to the location in the
.      data section of the addend.  The relocation function will
.      subtract from the relocation value the address of the location
.      being relocated.  *}
.  bfd_boolean pc_relative;
d310 2
a311 2
.  {*  The bit position of the reloc value in the destination.
.      The relocated value is left shifted by this amount.  *}
d314 2
a315 2
.  {* What type of overflow error should be checked for when
.     relocating.  *}
d318 4
a321 4
.  {* If this field is non null, then the supplied function is
.     called rather than the normal function.  This allows really
.     strange relocation methods to be accomodated (e.g., i960 callj
.     instructions).  *}
d323 7
a329 2
.    PARAMS ((bfd *, arelent *, struct symbol_cache_entry *, PTR, asection *,
.             bfd *, char **));
d331 1
a331 1
.  {* The textual name of the relocation type.  *}
d334 24
a357 25
.  {* Some formats record a relocation addend in the section contents
.     rather than with the relocation.  For ELF formats this is the
.     distinction between USE_REL and USE_RELA (though the code checks
.     for USE_REL == 1/0).  The value of this field is TRUE if the
.     addend is recorded with the section contents; when performing a
.     partial link (ld -r) the section contents (the data) will be
.     modified.  The value of this field is FALSE if addends are
.     recorded with the relocation (in arelent.addend); when performing
.     a partial link the relocation will be modified.
.     All relocations for all ELF USE_RELA targets should set this field
.     to FALSE (values of TRUE should be looked on with suspicion).
.     However, the converse is not true: not all relocations of all ELF
.     USE_REL targets set this field to TRUE.  Why this is so is peculiar
.     to each particular target.  For relocs that aren't used in partial
.     links (e.g. GOT stuff) it doesn't matter what this is set to.  *}
.  bfd_boolean partial_inplace;
.
.  {* src_mask selects the part of the instruction (or data) to be used
.     in the relocation sum.  If the target relocations don't have an
.     addend in the reloc, eg. ELF USE_REL, src_mask will normally equal
.     dst_mask to extract the addend from the section contents.  If
.     relocations do have an addend in the reloc, eg. ELF USE_RELA, this
.     field should be zero.  Non-zero values for ELF USE_RELA targets are
.     bogus as in those cases the value in the dst_mask part of the
.     section contents should be treated as garbage.  *}
d360 4
a363 2
.  {* dst_mask selects which parts of the instruction (or data) are
.     replaced with a relocated value.  *}
d366 8
a373 7
.  {* When some formats create PC relative instructions, they leave
.     the value of the pc of the place being relocated in the offset
.     slot of the instruction, so that a PC relative relocation can
.     be made just by adding in an ordinary offset (e.g., sun3 a.out).
.     Some formats leave the displacement part of an instruction
.     empty (e.g., m88k bcs); this flag signals the fact.  *}
.  bfd_boolean pcrel_offset;
d375 1
a375 1
.
d385 2
a386 2
.#define HOWTO(C, R, S, B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC) \
.  { (unsigned) C, R, S, B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC }
d392 1
a392 3
.#define NEWHOWTO(FUNCTION, NAME, SIZE, REL, IN) \
.  HOWTO (0, 0, SIZE, 0, REL, 0, complain_overflow_dont, FUNCTION, \
.         NAME, FALSE, 0, 0, IN)
d399 1
a399 2
.  HOWTO ((C), 0, 0, 0, FALSE, 0, complain_overflow_dont, NULL, \
.         NULL, FALSE, 0, 0, FALSE)
d405 12
a416 15
.#define HOWTO_PREPARE(relocation, symbol)               \
.  {                                                     \
.    if (symbol != (asymbol *) NULL)                     \
.      {                                                 \
.        if (bfd_is_com_section (symbol->section))       \
.          {                                             \
.            relocation = 0;                             \
.          }                                             \
.        else                                            \
.          {                                             \
.            relocation = symbol->value;                 \
.          }                                             \
.      }                                                 \
.  }
.
d456 1
a456 2
.typedef struct relent_chain
.{
d458 3
a460 4
.  struct relent_chain *next;
.}
.arelent_chain;
.
d629 2
a630 2
  if (reloc_entry->address > (input_section->_cooked_size
			      / bfd_octets_per_byte (abfd)))
d645 1
a645 2
  if ((output_bfd && ! howto->partial_inplace)
      || reloc_target_output_section == NULL)
d658 1
a658 1
  if (howto->pc_relative)
d671 1
a671 1
	 i386-aout, pcrel_offset is FALSE.  Some other targets do not
d673 1
a673 1
	 or ELF.  For those targets, pcrel_offset is TRUE.
d677 1
a677 1
	 relocation is done.  If pcrel_offset is FALSE we want to wind
d680 1
a680 1
	 in the location within the section.  If pcrel_offset is TRUE
d691 1
a691 1
      if (howto->pcrel_offset)
d697 1
a697 1
      if (! howto->partial_inplace)
d821 5
a825 3
  /* Either we are relocating all the way, or we don't want to apply
     the relocation to the reloc entry (probably because there isn't
     any room in the output format to describe addends to relocs).  */
d852 2
a853 1
  /* Shift everything up to where it's going to be used.  */
d856 1
a856 1
  /* Wait for the day when all have the mask in them.  */
d906 1
a906 1
	bfd_put_16 (abfd, (bfd_vma) x, (unsigned char *) data + octets);
d913 1
a913 1
	bfd_put_32 (abfd, (bfd_vma) x, (bfd_byte *) data + octets);
d921 1
a921 1
	bfd_put_32 (abfd, (bfd_vma) x, (bfd_byte *) data + octets);
d930 1
a930 1
	bfd_put_16 (abfd, (bfd_vma) x, (bfd_byte *) data + octets);
d977 1
d1025 1
a1025 2
  if (reloc_entry->address > (input_section->_cooked_size
			      / bfd_octets_per_byte (abfd)))
d1040 1
a1040 1
  if (! howto->partial_inplace)
d1053 1
a1053 1
  if (howto->pc_relative)
d1066 1
a1066 1
	 i386-aout, pcrel_offset is FALSE.  Some other targets do not
d1068 1
a1068 1
	 or ELF.  For those targets, pcrel_offset is TRUE.
d1072 1
a1072 1
	 relocation is done.  If pcrel_offset is FALSE we want to wind
d1075 1
a1075 1
	 in the location within the section.  If pcrel_offset is TRUE
d1086 1
a1086 1
      if (howto->pcrel_offset && howto->partial_inplace)
d1090 1
a1090 1
  if (! howto->partial_inplace)
d1106 1
d1182 2
a1183 1
       right.  */
d1208 5
a1212 3
  /* Either we are relocating all the way, or we don't want to apply
     the relocation to the reloc entry (probably because there isn't
     any room in the output format to describe addends to relocs).  */
d1239 2
a1240 1
  /* Shift everything up to where it's going to be used.  */
d1243 1
a1243 1
  /* Wait for the day when all have the mask in them.  */
d1295 1
a1295 1
	bfd_put_16 (abfd, (bfd_vma) x, (unsigned char *) data);
d1302 1
a1302 1
	bfd_put_32 (abfd, (bfd_vma) x, (bfd_byte *) data);
d1310 1
a1310 1
	bfd_put_32 (abfd, (bfd_vma) x, (bfd_byte *) data);
d1382 1
a1382 1
     pcrel_offset is FALSE.  Other targets (e.g., m88kbcs or ELF)
d1384 1
a1384 1
     targets pcrel_offset is TRUE.  If pcrel_offset is FALSE we do not
a1683 2
  BFD_RELOC_64_PLT_PCREL
ENUMX
a1691 2
  BFD_RELOC_64_PLTOFF
ENUMX
a1853 2
  BFD_RELOC_SPARC_PLT32
ENUMX
a1873 50
ENUM
  BFD_RELOC_SPARC_TLS_GD_HI22
ENUMX
  BFD_RELOC_SPARC_TLS_GD_LO10
ENUMX
  BFD_RELOC_SPARC_TLS_GD_ADD
ENUMX
  BFD_RELOC_SPARC_TLS_GD_CALL
ENUMX
  BFD_RELOC_SPARC_TLS_LDM_HI22
ENUMX
  BFD_RELOC_SPARC_TLS_LDM_LO10
ENUMX
  BFD_RELOC_SPARC_TLS_LDM_ADD
ENUMX
  BFD_RELOC_SPARC_TLS_LDM_CALL
ENUMX
  BFD_RELOC_SPARC_TLS_LDO_HIX22
ENUMX
  BFD_RELOC_SPARC_TLS_LDO_LOX10
ENUMX
  BFD_RELOC_SPARC_TLS_LDO_ADD
ENUMX
  BFD_RELOC_SPARC_TLS_IE_HI22
ENUMX
  BFD_RELOC_SPARC_TLS_IE_LO10
ENUMX
  BFD_RELOC_SPARC_TLS_IE_LD
ENUMX
  BFD_RELOC_SPARC_TLS_IE_LDX
ENUMX
  BFD_RELOC_SPARC_TLS_IE_ADD
ENUMX
  BFD_RELOC_SPARC_TLS_LE_HIX22
ENUMX
  BFD_RELOC_SPARC_TLS_LE_LOX10
ENUMX
  BFD_RELOC_SPARC_TLS_DTPMOD32
ENUMX
  BFD_RELOC_SPARC_TLS_DTPMOD64
ENUMX
  BFD_RELOC_SPARC_TLS_DTPOFF32
ENUMX
  BFD_RELOC_SPARC_TLS_DTPOFF64
ENUMX
  BFD_RELOC_SPARC_TLS_TPOFF32
ENUMX
  BFD_RELOC_SPARC_TLS_TPOFF64
ENUMDOC
  SPARC TLS relocations
d1930 21
a1970 44
  BFD_RELOC_ALPHA_GPREL_HI16
ENUMX
  BFD_RELOC_ALPHA_GPREL_LO16
ENUMDOC
  The GPREL_HI/LO relocations together form a 32-bit offset from the
     GP register.

ENUM
  BFD_RELOC_ALPHA_BRSGP
ENUMDOC
  Like BFD_RELOC_23_PCREL_S2, except that the source and target must
  share a common GP, and the target address is adjusted for
  STO_ALPHA_STD_GPLOAD.

ENUM
  BFD_RELOC_ALPHA_TLSGD
ENUMX
  BFD_RELOC_ALPHA_TLSLDM
ENUMX
  BFD_RELOC_ALPHA_DTPMOD64
ENUMX
  BFD_RELOC_ALPHA_GOTDTPREL16
ENUMX
  BFD_RELOC_ALPHA_DTPREL64
ENUMX
  BFD_RELOC_ALPHA_DTPREL_HI16
ENUMX
  BFD_RELOC_ALPHA_DTPREL_LO16
ENUMX
  BFD_RELOC_ALPHA_DTPREL16
ENUMX
  BFD_RELOC_ALPHA_GOTTPREL16
ENUMX
  BFD_RELOC_ALPHA_TPREL64
ENUMX
  BFD_RELOC_ALPHA_TPREL_HI16
ENUMX
  BFD_RELOC_ALPHA_TPREL_LO16
ENUMX
  BFD_RELOC_ALPHA_TPREL16
ENUMDOC
  Alpha thread-local storage relocations.

ENUM
d2010 6
d2025 3
a2066 22
ENUM
  BFD_RELOC_FRV_LABEL16
ENUMX
  BFD_RELOC_FRV_LABEL24
ENUMX
  BFD_RELOC_FRV_LO16
ENUMX
  BFD_RELOC_FRV_HI16
ENUMX
  BFD_RELOC_FRV_GPREL12
ENUMX
  BFD_RELOC_FRV_GPRELU12
ENUMX
  BFD_RELOC_FRV_GPREL32
ENUMX
  BFD_RELOC_FRV_GPRELHI
ENUMX
  BFD_RELOC_FRV_GPRELLO
ENUMDOC
  Fujitsu Frv Relocations.
COMMENT
COMMENT
a2087 24
ENUMX
  BFD_RELOC_386_TLS_TPOFF
ENUMX
  BFD_RELOC_386_TLS_IE
ENUMX
  BFD_RELOC_386_TLS_GOTIE
ENUMX
  BFD_RELOC_386_TLS_LE
ENUMX
  BFD_RELOC_386_TLS_GD
ENUMX
  BFD_RELOC_386_TLS_LDM
ENUMX
  BFD_RELOC_386_TLS_LDO_32
ENUMX
  BFD_RELOC_386_TLS_IE_32
ENUMX
  BFD_RELOC_386_TLS_LE_32
ENUMX
  BFD_RELOC_386_TLS_DTPMOD32
ENUMX
  BFD_RELOC_386_TLS_DTPOFF32
ENUMX
  BFD_RELOC_386_TLS_TPOFF32
a2106 16
ENUMX
  BFD_RELOC_X86_64_DTPMOD64
ENUMX
  BFD_RELOC_X86_64_DTPOFF64
ENUMX
  BFD_RELOC_X86_64_TPOFF64
ENUMX
  BFD_RELOC_X86_64_TLSGD
ENUMX
  BFD_RELOC_X86_64_TLSLD
ENUMX
  BFD_RELOC_X86_64_DTPOFF32
ENUMX
  BFD_RELOC_X86_64_GOTTPOFF
ENUMX
  BFD_RELOC_X86_64_TPOFF32
a2137 7
  BFD_RELOC_PDP11_DISP_8_PCREL
ENUMX
  BFD_RELOC_PDP11_DISP_6_PCREL
ENUMDOC
  PDP11 relocations

ENUM
a2211 46
ENUMX
  BFD_RELOC_PPC64_HIGHER
ENUMX
  BFD_RELOC_PPC64_HIGHER_S
ENUMX
  BFD_RELOC_PPC64_HIGHEST
ENUMX
  BFD_RELOC_PPC64_HIGHEST_S
ENUMX
  BFD_RELOC_PPC64_TOC16_LO
ENUMX
  BFD_RELOC_PPC64_TOC16_HI
ENUMX
  BFD_RELOC_PPC64_TOC16_HA
ENUMX
  BFD_RELOC_PPC64_TOC
ENUMX
  BFD_RELOC_PPC64_PLTGOT16
ENUMX
  BFD_RELOC_PPC64_PLTGOT16_LO
ENUMX
  BFD_RELOC_PPC64_PLTGOT16_HI
ENUMX
  BFD_RELOC_PPC64_PLTGOT16_HA
ENUMX
  BFD_RELOC_PPC64_ADDR16_DS
ENUMX
  BFD_RELOC_PPC64_ADDR16_LO_DS
ENUMX
  BFD_RELOC_PPC64_GOT16_DS
ENUMX
  BFD_RELOC_PPC64_GOT16_LO_DS
ENUMX
  BFD_RELOC_PPC64_PLT16_LO_DS
ENUMX
  BFD_RELOC_PPC64_SECTOFF_DS
ENUMX
  BFD_RELOC_PPC64_SECTOFF_LO_DS
ENUMX
  BFD_RELOC_PPC64_TOC16_DS
ENUMX
  BFD_RELOC_PPC64_TOC16_LO_DS
ENUMX
  BFD_RELOC_PPC64_PLTGOT16_DS
ENUMX
  BFD_RELOC_PPC64_PLTGOT16_LO_DS
a2215 83
  BFD_RELOC_PPC_TLS
ENUMX
  BFD_RELOC_PPC_DTPMOD
ENUMX
  BFD_RELOC_PPC_TPREL16
ENUMX
  BFD_RELOC_PPC_TPREL16_LO
ENUMX
  BFD_RELOC_PPC_TPREL16_HI
ENUMX
  BFD_RELOC_PPC_TPREL16_HA
ENUMX
  BFD_RELOC_PPC_TPREL
ENUMX
  BFD_RELOC_PPC_DTPREL16
ENUMX
  BFD_RELOC_PPC_DTPREL16_LO
ENUMX
  BFD_RELOC_PPC_DTPREL16_HI
ENUMX
  BFD_RELOC_PPC_DTPREL16_HA
ENUMX
  BFD_RELOC_PPC_DTPREL
ENUMX
  BFD_RELOC_PPC_GOT_TLSGD16
ENUMX
  BFD_RELOC_PPC_GOT_TLSGD16_LO
ENUMX
  BFD_RELOC_PPC_GOT_TLSGD16_HI
ENUMX
  BFD_RELOC_PPC_GOT_TLSGD16_HA
ENUMX
  BFD_RELOC_PPC_GOT_TLSLD16
ENUMX
  BFD_RELOC_PPC_GOT_TLSLD16_LO
ENUMX
  BFD_RELOC_PPC_GOT_TLSLD16_HI
ENUMX
  BFD_RELOC_PPC_GOT_TLSLD16_HA
ENUMX
  BFD_RELOC_PPC_GOT_TPREL16
ENUMX
  BFD_RELOC_PPC_GOT_TPREL16_LO
ENUMX
  BFD_RELOC_PPC_GOT_TPREL16_HI
ENUMX
  BFD_RELOC_PPC_GOT_TPREL16_HA
ENUMX
  BFD_RELOC_PPC_GOT_DTPREL16
ENUMX
  BFD_RELOC_PPC_GOT_DTPREL16_LO
ENUMX
  BFD_RELOC_PPC_GOT_DTPREL16_HI
ENUMX
  BFD_RELOC_PPC_GOT_DTPREL16_HA
ENUMX
  BFD_RELOC_PPC64_TPREL16_DS
ENUMX
  BFD_RELOC_PPC64_TPREL16_LO_DS
ENUMX
  BFD_RELOC_PPC64_TPREL16_HIGHER
ENUMX
  BFD_RELOC_PPC64_TPREL16_HIGHERA
ENUMX
  BFD_RELOC_PPC64_TPREL16_HIGHEST
ENUMX
  BFD_RELOC_PPC64_TPREL16_HIGHESTA
ENUMX
  BFD_RELOC_PPC64_DTPREL16_DS
ENUMX
  BFD_RELOC_PPC64_DTPREL16_LO_DS
ENUMX
  BFD_RELOC_PPC64_DTPREL16_HIGHER
ENUMX
  BFD_RELOC_PPC64_DTPREL16_HIGHERA
ENUMX
  BFD_RELOC_PPC64_DTPREL16_HIGHEST
ENUMX
  BFD_RELOC_PPC64_DTPREL16_HIGHESTA
ENUMDOC
  PowerPC and PowerPC64 thread-local storage relocations.

ENUM
a2258 2
  BFD_RELOC_ARM_CP_OFF_IMM_S2
ENUMX
a2349 114
ENUMX
  BFD_RELOC_SH_GOT_LOW16
ENUMX
  BFD_RELOC_SH_GOT_MEDLOW16
ENUMX
  BFD_RELOC_SH_GOT_MEDHI16
ENUMX
  BFD_RELOC_SH_GOT_HI16
ENUMX
  BFD_RELOC_SH_GOTPLT_LOW16
ENUMX
  BFD_RELOC_SH_GOTPLT_MEDLOW16
ENUMX
  BFD_RELOC_SH_GOTPLT_MEDHI16
ENUMX
  BFD_RELOC_SH_GOTPLT_HI16
ENUMX
  BFD_RELOC_SH_PLT_LOW16
ENUMX
  BFD_RELOC_SH_PLT_MEDLOW16
ENUMX
  BFD_RELOC_SH_PLT_MEDHI16
ENUMX
  BFD_RELOC_SH_PLT_HI16
ENUMX
  BFD_RELOC_SH_GOTOFF_LOW16
ENUMX
  BFD_RELOC_SH_GOTOFF_MEDLOW16
ENUMX
  BFD_RELOC_SH_GOTOFF_MEDHI16
ENUMX
  BFD_RELOC_SH_GOTOFF_HI16
ENUMX
  BFD_RELOC_SH_GOTPC_LOW16
ENUMX
  BFD_RELOC_SH_GOTPC_MEDLOW16
ENUMX
  BFD_RELOC_SH_GOTPC_MEDHI16
ENUMX
  BFD_RELOC_SH_GOTPC_HI16
ENUMX
  BFD_RELOC_SH_COPY64
ENUMX
  BFD_RELOC_SH_GLOB_DAT64
ENUMX
  BFD_RELOC_SH_JMP_SLOT64
ENUMX
  BFD_RELOC_SH_RELATIVE64
ENUMX
  BFD_RELOC_SH_GOT10BY4
ENUMX
  BFD_RELOC_SH_GOT10BY8
ENUMX
  BFD_RELOC_SH_GOTPLT10BY4
ENUMX
  BFD_RELOC_SH_GOTPLT10BY8
ENUMX
  BFD_RELOC_SH_GOTPLT32
ENUMX
  BFD_RELOC_SH_SHMEDIA_CODE
ENUMX
  BFD_RELOC_SH_IMMU5
ENUMX
  BFD_RELOC_SH_IMMS6
ENUMX
  BFD_RELOC_SH_IMMS6BY32
ENUMX
  BFD_RELOC_SH_IMMU6
ENUMX
  BFD_RELOC_SH_IMMS10
ENUMX
  BFD_RELOC_SH_IMMS10BY2
ENUMX
  BFD_RELOC_SH_IMMS10BY4
ENUMX
  BFD_RELOC_SH_IMMS10BY8
ENUMX
  BFD_RELOC_SH_IMMS16
ENUMX
  BFD_RELOC_SH_IMMU16
ENUMX
  BFD_RELOC_SH_IMM_LOW16
ENUMX
  BFD_RELOC_SH_IMM_LOW16_PCREL
ENUMX
  BFD_RELOC_SH_IMM_MEDLOW16
ENUMX
  BFD_RELOC_SH_IMM_MEDLOW16_PCREL
ENUMX
  BFD_RELOC_SH_IMM_MEDHI16
ENUMX
  BFD_RELOC_SH_IMM_MEDHI16_PCREL
ENUMX
  BFD_RELOC_SH_IMM_HI16
ENUMX
  BFD_RELOC_SH_IMM_HI16_PCREL
ENUMX
  BFD_RELOC_SH_PT_16
ENUMX
  BFD_RELOC_SH_TLS_GD_32
ENUMX
  BFD_RELOC_SH_TLS_LD_32
ENUMX
  BFD_RELOC_SH_TLS_LDO_32
ENUMX
  BFD_RELOC_SH_TLS_IE_32
ENUMX
  BFD_RELOC_SH_TLS_LE_32
ENUMX
  BFD_RELOC_SH_TLS_DTPMOD32
ENUMX
  BFD_RELOC_SH_TLS_DTPOFF32
ENUMX
  BFD_RELOC_SH_TLS_TPOFF32
d2351 1
a2351 1
  Renesas / SuperH SH relocs.  Not all of these appear in object files.
a2462 13
  BFD_RELOC_DLX_HI16_S
ENUMDOC
  DLX relocs
ENUM
  BFD_RELOC_DLX_LO16
ENUMDOC
  DLX relocs
ENUM
  BFD_RELOC_DLX_JMP26
ENUMDOC
  DLX relocs

ENUM
d2465 1
a2465 1
  Renesas M32R (formerly Mitsubishi M32R) relocs.
d2572 2
a2573 12
ENUM
  BFD_RELOC_V850_LONGCALL
ENUMDOC
  Used for relaxing indirect function calls.
ENUM
  BFD_RELOC_V850_LONGJUMP
ENUMDOC
  Used for relaxing indirect jumps.
ENUM
  BFD_RELOC_V850_ALIGN
ENUMDOC
  Used to maintain alignment whilst relaxing.
a2680 72
  BFD_RELOC_MMIX_GETA
ENUMX
  BFD_RELOC_MMIX_GETA_1
ENUMX
  BFD_RELOC_MMIX_GETA_2
ENUMX
  BFD_RELOC_MMIX_GETA_3
ENUMDOC
  These are relocations for the GETA instruction.
ENUM
  BFD_RELOC_MMIX_CBRANCH
ENUMX
  BFD_RELOC_MMIX_CBRANCH_J
ENUMX
  BFD_RELOC_MMIX_CBRANCH_1
ENUMX
  BFD_RELOC_MMIX_CBRANCH_2
ENUMX
  BFD_RELOC_MMIX_CBRANCH_3
ENUMDOC
  These are relocations for a conditional branch instruction.
ENUM
  BFD_RELOC_MMIX_PUSHJ
ENUMX
  BFD_RELOC_MMIX_PUSHJ_1
ENUMX
  BFD_RELOC_MMIX_PUSHJ_2
ENUMX
  BFD_RELOC_MMIX_PUSHJ_3
ENUMDOC
  These are relocations for the PUSHJ instruction.
ENUM
  BFD_RELOC_MMIX_JMP
ENUMX
  BFD_RELOC_MMIX_JMP_1
ENUMX
  BFD_RELOC_MMIX_JMP_2
ENUMX
  BFD_RELOC_MMIX_JMP_3
ENUMDOC
  These are relocations for the JMP instruction.
ENUM
  BFD_RELOC_MMIX_ADDR19
ENUMDOC
  This is a relocation for a relative address as in a GETA instruction or
  a branch.
ENUM
  BFD_RELOC_MMIX_ADDR27
ENUMDOC
  This is a relocation for a relative address as in a JMP instruction.
ENUM
  BFD_RELOC_MMIX_REG_OR_BYTE
ENUMDOC
  This is a relocation for an instruction field that may be a general
  register or a value 0..255.
ENUM
  BFD_RELOC_MMIX_REG
ENUMDOC
  This is a relocation for an instruction field that may be a general
  register.
ENUM
  BFD_RELOC_MMIX_BASE_PLUS_OFFSET
ENUMDOC
  This is a relocation for two instruction fields holding a register and
  an offset, the equivalent of the relocation.
ENUM
  BFD_RELOC_MMIX_LOCAL
ENUMDOC
  This relocation is an assertion that the expression is not allocated as
  a global register.  It does not modify contents.

ENUM
a2765 197
  BFD_RELOC_390_12
ENUMDOC
   Direct 12 bit.
ENUM
  BFD_RELOC_390_GOT12
ENUMDOC
  12 bit GOT offset.
ENUM
  BFD_RELOC_390_PLT32
ENUMDOC
  32 bit PC relative PLT address.
ENUM
  BFD_RELOC_390_COPY
ENUMDOC
  Copy symbol at runtime.
ENUM
  BFD_RELOC_390_GLOB_DAT
ENUMDOC
  Create GOT entry.
ENUM
  BFD_RELOC_390_JMP_SLOT
ENUMDOC
  Create PLT entry.
ENUM
  BFD_RELOC_390_RELATIVE
ENUMDOC
  Adjust by program base.
ENUM
  BFD_RELOC_390_GOTPC
ENUMDOC
  32 bit PC relative offset to GOT.
ENUM
  BFD_RELOC_390_GOT16
ENUMDOC
  16 bit GOT offset.
ENUM
  BFD_RELOC_390_PC16DBL
ENUMDOC
  PC relative 16 bit shifted by 1.
ENUM
  BFD_RELOC_390_PLT16DBL
ENUMDOC
  16 bit PC rel. PLT shifted by 1.
ENUM
  BFD_RELOC_390_PC32DBL
ENUMDOC
  PC relative 32 bit shifted by 1.
ENUM
  BFD_RELOC_390_PLT32DBL
ENUMDOC
  32 bit PC rel. PLT shifted by 1.
ENUM
  BFD_RELOC_390_GOTPCDBL
ENUMDOC
  32 bit PC rel. GOT shifted by 1.
ENUM
  BFD_RELOC_390_GOT64
ENUMDOC
  64 bit GOT offset.
ENUM
  BFD_RELOC_390_PLT64
ENUMDOC
  64 bit PC relative PLT address.
ENUM
  BFD_RELOC_390_GOTENT
ENUMDOC
  32 bit rel. offset to GOT entry.
ENUM
  BFD_RELOC_390_GOTOFF64
ENUMDOC
  64 bit offset to GOT.
ENUM
  BFD_RELOC_390_GOTPLT12
ENUMDOC
  12-bit offset to symbol-entry within GOT, with PLT handling.
ENUM
  BFD_RELOC_390_GOTPLT16
ENUMDOC
  16-bit offset to symbol-entry within GOT, with PLT handling.
ENUM
  BFD_RELOC_390_GOTPLT32
ENUMDOC
  32-bit offset to symbol-entry within GOT, with PLT handling.
ENUM
  BFD_RELOC_390_GOTPLT64
ENUMDOC
  64-bit offset to symbol-entry within GOT, with PLT handling.
ENUM
  BFD_RELOC_390_GOTPLTENT
ENUMDOC
  32-bit rel. offset to symbol-entry within GOT, with PLT handling.
ENUM
  BFD_RELOC_390_PLTOFF16
ENUMDOC
  16-bit rel. offset from the GOT to a PLT entry.
ENUM
  BFD_RELOC_390_PLTOFF32
ENUMDOC
  32-bit rel. offset from the GOT to a PLT entry.
ENUM
  BFD_RELOC_390_PLTOFF64
ENUMDOC
  64-bit rel. offset from the GOT to a PLT entry.

ENUM
  BFD_RELOC_390_TLS_LOAD
ENUMX
  BFD_RELOC_390_TLS_GDCALL
ENUMX
  BFD_RELOC_390_TLS_LDCALL
ENUMX
  BFD_RELOC_390_TLS_GD32
ENUMX
  BFD_RELOC_390_TLS_GD64
ENUMX
  BFD_RELOC_390_TLS_GOTIE12
ENUMX
  BFD_RELOC_390_TLS_GOTIE32
ENUMX
  BFD_RELOC_390_TLS_GOTIE64
ENUMX
  BFD_RELOC_390_TLS_LDM32
ENUMX
  BFD_RELOC_390_TLS_LDM64
ENUMX
  BFD_RELOC_390_TLS_IE32
ENUMX
  BFD_RELOC_390_TLS_IE64
ENUMX
  BFD_RELOC_390_TLS_IEENT
ENUMX
  BFD_RELOC_390_TLS_LE32
ENUMX
  BFD_RELOC_390_TLS_LE64
ENUMX
  BFD_RELOC_390_TLS_LDO32
ENUMX
  BFD_RELOC_390_TLS_LDO64
ENUMX
  BFD_RELOC_390_TLS_DTPMOD
ENUMX
  BFD_RELOC_390_TLS_DTPOFF
ENUMX
  BFD_RELOC_390_TLS_TPOFF
ENUMDOC
  s390 tls relocations.

ENUM
  BFD_RELOC_IP2K_FR9
ENUMDOC
  Scenix IP2K - 9-bit register number / data address
ENUM
  BFD_RELOC_IP2K_BANK
ENUMDOC
  Scenix IP2K - 4-bit register/data bank number
ENUM
  BFD_RELOC_IP2K_ADDR16CJP
ENUMDOC
  Scenix IP2K - low 13 bits of instruction word address
ENUM
  BFD_RELOC_IP2K_PAGE3
ENUMDOC
  Scenix IP2K - high 3 bits of instruction word address
ENUM
  BFD_RELOC_IP2K_LO8DATA
ENUMX
  BFD_RELOC_IP2K_HI8DATA
ENUMX
  BFD_RELOC_IP2K_EX8DATA
ENUMDOC
  Scenix IP2K - ext/low/high 8 bits of data address
ENUM
  BFD_RELOC_IP2K_LO8INSN
ENUMX
  BFD_RELOC_IP2K_HI8INSN
ENUMDOC
  Scenix IP2K - low/high 8 bits of instruction word address
ENUM
  BFD_RELOC_IP2K_PC_SKIP
ENUMDOC
  Scenix IP2K - even/odd PC modifier to modify snb pcl.0
ENUM
  BFD_RELOC_IP2K_TEXT
ENUMDOC
  Scenix IP2K - 16 bit word address in text section.
ENUM
  BFD_RELOC_IP2K_FR_OFFSET
ENUMDOC
  Scenix IP2K - 7-bit sp or dp offset
ENUM
  BFD_RELOC_VPE4KMATH_DATA
ENUMX
  BFD_RELOC_VPE4KMATH_INSN
ENUMDOC
  Scenix VPE4K coprocessor - data/insn-space addressing

ENUM
a2862 4
  BFD_RELOC_IA64_LTOFF_FPTR32MSB
ENUMX
  BFD_RELOC_IA64_LTOFF_FPTR32LSB
ENUMX
a2904 6
  BFD_RELOC_IA64_LTOFF22X
ENUMX
  BFD_RELOC_IA64_LDXMOV
ENUMX
  BFD_RELOC_IA64_TPREL14
ENUMX
a2906 2
  BFD_RELOC_IA64_TPREL64I
ENUMX
d2911 1
a2911 1
  BFD_RELOC_IA64_LTOFF_TPREL22
d2913 1
a2913 1
  BFD_RELOC_IA64_DTPMOD64MSB
d2915 1
a2915 19
  BFD_RELOC_IA64_DTPMOD64LSB
ENUMX
  BFD_RELOC_IA64_LTOFF_DTPMOD22
ENUMX
  BFD_RELOC_IA64_DTPREL14
ENUMX
  BFD_RELOC_IA64_DTPREL22
ENUMX
  BFD_RELOC_IA64_DTPREL64I
ENUMX
  BFD_RELOC_IA64_DTPREL32MSB
ENUMX
  BFD_RELOC_IA64_DTPREL32LSB
ENUMX
  BFD_RELOC_IA64_DTPREL64MSB
ENUMX
  BFD_RELOC_IA64_DTPREL64LSB
ENUMX
  BFD_RELOC_IA64_LTOFF_DTPREL22
d2923 1
a2923 1
  This is the 8 bit high part of an absolute address.
d2928 1
a2928 1
  This is the 8 bit low part of an absolute address.
d2933 1
a2933 37
  This is the 3 bit of a value.
ENUM
  BFD_RELOC_M68HC11_RL_JUMP
ENUMDOC
  Motorola 68HC11 reloc.
  This reloc marks the beginning of a jump/call instruction.
  It is used for linker relaxation to correctly identify beginning
  of instruction and change some branchs to use PC-relative
  addressing mode.
ENUM
  BFD_RELOC_M68HC11_RL_GROUP
ENUMDOC
  Motorola 68HC11 reloc.
  This reloc marks a group of several instructions that gcc generates
  and for which the linker relaxation pass can modify and/or remove
  some of them.
ENUM
  BFD_RELOC_M68HC11_LO16
ENUMDOC
  Motorola 68HC11 reloc.
  This is the 16-bit lower part of an address.  It is used for 'call'
  instruction to specify the symbol address without any special
  transformation (due to memory bank window).
ENUM
  BFD_RELOC_M68HC11_PAGE
ENUMDOC
  Motorola 68HC11 reloc.
  This is a 8-bit reloc that specifies the page number of an address.
  It is used by 'call' instruction to specify the page number of
  the symbol.
ENUM
  BFD_RELOC_M68HC11_24
ENUMDOC
  Motorola 68HC11 reloc.
  This is a 24-bit reloc that represents the address with a 16-bit
  value and a 8-bit page number.  The symbol address is transformed
  to follow the 16K memory bank of 68HC12 (seen as mapped in the window).
a2947 38
ENUM
  BFD_RELOC_CRIS_COPY
ENUMX
  BFD_RELOC_CRIS_GLOB_DAT
ENUMX
  BFD_RELOC_CRIS_JUMP_SLOT
ENUMX
  BFD_RELOC_CRIS_RELATIVE
ENUMDOC
  Relocs used in ELF shared libraries for CRIS.
ENUM
  BFD_RELOC_CRIS_32_GOT
ENUMDOC
  32-bit offset to symbol-entry within GOT.
ENUM
  BFD_RELOC_CRIS_16_GOT
ENUMDOC
  16-bit offset to symbol-entry within GOT.
ENUM
  BFD_RELOC_CRIS_32_GOTPLT
ENUMDOC
  32-bit offset to symbol-entry within GOT, with PLT handling.
ENUM
  BFD_RELOC_CRIS_16_GOTPLT
ENUMDOC
  16-bit offset to symbol-entry within GOT, with PLT handling.
ENUM
  BFD_RELOC_CRIS_32_GOTREL
ENUMDOC
  32-bit offset to symbol, relative to GOT.
ENUM
  BFD_RELOC_CRIS_32_PLT_GOTREL
ENUMDOC
  32-bit offset to symbol with PLT entry, relative to GOT.
ENUM
  BFD_RELOC_CRIS_32_PLT_PCREL
ENUMDOC
  32-bit offset to symbol with PLT entry, relative to this relocation.
a3015 105
ENUM
  BFD_RELOC_OPENRISC_ABS_26
ENUMX
  BFD_RELOC_OPENRISC_REL_26
ENUMDOC
  OpenRISC Relocations.

ENUM
  BFD_RELOC_H8_DIR16A8
ENUMX
  BFD_RELOC_H8_DIR16R8
ENUMX
  BFD_RELOC_H8_DIR24A8
ENUMX
  BFD_RELOC_H8_DIR24R8
ENUMX
  BFD_RELOC_H8_DIR32A16
ENUMDOC
  H8 elf Relocations.

ENUM
  BFD_RELOC_XSTORMY16_REL_12
ENUMX
  BFD_RELOC_XSTORMY16_12
ENUMX
  BFD_RELOC_XSTORMY16_24
ENUMX
  BFD_RELOC_XSTORMY16_FPTR16
ENUMDOC
  Sony Xstormy16 Relocations.

ENUM
  BFD_RELOC_VAX_GLOB_DAT
ENUMX
  BFD_RELOC_VAX_JMP_SLOT
ENUMX
  BFD_RELOC_VAX_RELATIVE
ENUMDOC
  Relocations used by VAX ELF.
  
ENUM
  BFD_RELOC_MSP430_10_PCREL
ENUMX
  BFD_RELOC_MSP430_16_PCREL
ENUMX
  BFD_RELOC_MSP430_16
ENUMX
  BFD_RELOC_MSP430_16_PCREL_BYTE
ENUMX
  BFD_RELOC_MSP430_16_BYTE
ENUMDOC
  msp430 specific relocation codes

ENUM
  BFD_RELOC_IQ2000_OFFSET_16
ENUMX
  BFD_RELOC_IQ2000_OFFSET_21
ENUMX
  BFD_RELOC_IQ2000_UHI16
ENUMDOC
  IQ2000 Relocations.

ENUM
  BFD_RELOC_XTENSA_RTLD
ENUMDOC
  Special Xtensa relocation used only by PLT entries in ELF shared
  objects to indicate that the runtime linker should set the value
  to one of its own internal functions or data structures.
ENUM
  BFD_RELOC_XTENSA_GLOB_DAT
ENUMX
  BFD_RELOC_XTENSA_JMP_SLOT
ENUMX
  BFD_RELOC_XTENSA_RELATIVE
ENUMDOC
  Xtensa relocations for ELF shared objects.
ENUM
  BFD_RELOC_XTENSA_PLT
ENUMDOC
  Xtensa relocation used in ELF object files for symbols that may require
  PLT entries.  Otherwise, this is just a generic 32-bit relocation.
ENUM
  BFD_RELOC_XTENSA_OP0
ENUMX
  BFD_RELOC_XTENSA_OP1
ENUMX
  BFD_RELOC_XTENSA_OP2
ENUMDOC
  Generic Xtensa relocations.  Only the operand number is encoded
  in the relocation.  The details are determined by extracting the
  instruction opcode.
ENUM
  BFD_RELOC_XTENSA_ASM_EXPAND
ENUMDOC
  Xtensa relocation to mark that the assembler expanded the 
  instructions from an original target.  The expansion size is
  encoded in the reloc size.
ENUM
  BFD_RELOC_XTENSA_ASM_SIMPLIFY
ENUMDOC
  Xtensa relocation to mark that the linker should simplify 
  assembler-expanded instructions.  This is commonly used 
  internally by the linker after analysis of a 
  BFD_RELOC_XTENSA_ASM_EXPAND.

d3047 1
a3047 1
HOWTO (0, 00, 2, 32, FALSE, 0, complain_overflow_bitfield, 0, "VRT32", FALSE, 0xffffffff, 0xffffffff, TRUE);
d3105 1
a3105 1
  if ((int) code > (int) BFD_RELOC_UNUSED)
d3115 1
a3115 1
	bfd_boolean bfd_generic_relax_section
d3119 1
a3119 1
	  bfd_boolean *);
d3126 2
a3127 1
bfd_boolean
d3132 1
a3132 1
     bfd_boolean *again;
d3134 2
a3135 2
  *again = FALSE;
  return TRUE;
d3143 1
a3143 1
	bfd_boolean bfd_generic_gc_sections
d3151 2
a3152 1
bfd_boolean
d3157 1
a3157 22
  return TRUE;
}

/*
INTERNAL_FUNCTION
	bfd_generic_merge_sections

SYNOPSIS
	bfd_boolean bfd_generic_merge_sections
	 (bfd *, struct bfd_link_info *);

DESCRIPTION
	Provides default handling for SEC_MERGE section merging for back ends
	which don't have SEC_MERGE support -- i.e., does nothing.
*/

bfd_boolean
bfd_generic_merge_sections (abfd, link_info)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *link_info ATTRIBUTE_UNUSED;
{
  return TRUE;
d3170 1
a3170 1
	     bfd_boolean relocateable,
d3186 1
a3186 1
     bfd_boolean relocateable;
d3189 1
a3189 1
  /* Get enough memory to hold the stuff.  */
d3200 1
a3200 1
  reloc_vector = (arelent **) bfd_malloc ((bfd_size_type) reloc_size);
d3204 1
a3204 1
  /* Read in the section.  */
d3208 1
a3208 1
				 (bfd_vma) 0,
d3212 1
a3212 1
  /* We're not relaxing the section, so just copy the size info.  */
d3214 1
a3214 1
  input_section->reloc_done = TRUE;
d3242 1
a3242 1
	      /* A partial link, so keep the relocs.  */
d3255 1
a3255 1
			 TRUE)))
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
d101 1
a101 1
.  struct bfd_symbol **sym_ptr_ptr;
d125 9
a133 10
        associated with the relocation request.  It is the pointer
        into the table returned by the back end's
        <<canonicalize_symtab>> action. @@xref{Symbols}. The symbol is
        referenced through a pointer to a pointer so that tools like
        the linker can fix up all the symbols of the same name by
        modifying only one pointer. The relocation routine looks in
        the symbol and uses the base of the section the symbol is
        attached to and the value of the symbol as the initial
        relocation offset. If the symbol pointer is zero, then the
        section provided is looked up.
d280 1
a280 1
.struct bfd_symbol;		{* Forward declaration.  *}
d321 1
a321 1
.     strange relocation methods to be accommodated (e.g., i960 callj
d324 2
a325 2
.    (bfd *, arelent *, struct bfd_symbol *, void *, asection *,
.     bfd *, char **);
d404 1
a404 1
.    if (symbol != NULL)                                 \
d432 2
a433 1
bfd_get_reloc_size (reloc_howto_type *howto)
d473 7
a479 6
	bfd_reloc_status_type bfd_check_overflow
	  (enum complain_overflow how,
	   unsigned int bitsize,
	   unsigned int rightshift,
	   unsigned int addrsize,
	   bfd_vma relocation);
d491 6
a496 5
bfd_check_overflow (enum complain_overflow how,
		    unsigned int bitsize,
		    unsigned int rightshift,
		    unsigned int addrsize,
		    bfd_vma relocation)
d556 8
a563 7
	bfd_reloc_status_type bfd_perform_relocation
          (bfd *abfd,
           arelent *reloc_entry,
           void *data,
           asection *input_section,
           bfd *output_bfd,
	   char **error_message);
d584 8
a591 6
bfd_perform_relocation (bfd *abfd,
			arelent *reloc_entry,
			void *data,
			asection *input_section,
			bfd *output_bfd,
			char **error_message)
d603 1
a603 1
      && output_bfd != NULL)
d609 1
a609 1
  /* If we are not producing relocatable output, return an error if
d614 1
a614 1
      && output_bfd == NULL)
d635 1
a635 1
  /* Work out which section the relocation is targeted at and the
d678 1
a678 1
	 If we are producing relocatable output, then we must ensure
d687 1
a687 1
	 producing relocatable output it is not what the code
d698 1
a698 1
  if (output_bfd != NULL)
d742 1
a742 1
relocatable output for COFF.  That's peculiar.  In fact, I really
d757 3
a759 3
So everything works fine when not producing relocatable output.  When
we are producing relocatable output, logically we should do exactly
what we do when not producing relocatable output.  Therefore, your
d767 1
a767 1
When I wanted to make coff-i386 produce relocatable output, I ran
d961 7
a967 6
	bfd_reloc_status_type bfd_install_relocation
          (bfd *abfd,
           arelent *reloc_entry,
           void *data, bfd_vma data_start,
           asection *input_section,
	   char **error_message);
d980 8
a987 6
bfd_install_relocation (bfd *abfd,
			arelent *reloc_entry,
			void *data_start,
			bfd_vma data_start_offset,
			asection *input_section,
			char **error_message)
d1028 1
a1028 1
  /* Work out which section the relocation is targeted at and the
d1070 1
a1070 1
	 If we are producing relocatable output, then we must ensure
d1079 1
a1079 1
	 producing relocatable output it is not what the code
d1131 1
a1131 1
relocatable output for COFF.  That's peculiar.  In fact, I really
d1146 3
a1148 3
So everything works fine when not producing relocatable output.  When
we are producing relocatable output, logically we should do exactly
what we do when not producing relocatable output.  Therefore, your
d1156 1
a1156 1
When I wanted to make coff-i386 produce relocatable output, I ran
d1280 1
a1280 1
	char x = bfd_get_8 (abfd, data);
d1282 1
a1282 1
	bfd_put_8 (abfd, x, data);
d1288 1
a1288 1
	short x = bfd_get_16 (abfd, data);
d1290 1
a1290 1
	bfd_put_16 (abfd, (bfd_vma) x, data);
d1295 1
a1295 1
	long x = bfd_get_32 (abfd, data);
d1297 1
a1297 1
	bfd_put_32 (abfd, (bfd_vma) x, data);
d1302 1
a1302 1
	long x = bfd_get_32 (abfd, data);
d1305 1
a1305 1
	bfd_put_32 (abfd, (bfd_vma) x, data);
d1315 1
a1315 1
	bfd_vma x = bfd_get_64 (abfd, data);
d1317 1
a1317 1
	bfd_put_64 (abfd, x, data);
d1334 1
a1334 1
   relocatable link depends upon how the object format defines
d1350 9
a1358 7
_bfd_final_link_relocate (reloc_howto_type *howto,
			  bfd *input_bfd,
			  asection *input_section,
			  bfd_byte *contents,
			  bfd_vma address,
			  bfd_vma value,
			  bfd_vma addend)
d1397 5
a1401 4
_bfd_relocate_contents (reloc_howto_type *howto,
			bfd *input_bfd,
			bfd_vma relocation,
			bfd_byte *location)
a2130 2
ENUMDOC
  MIPS ELF relocations.
a2131 1

a2149 28
ENUMX
  BFD_RELOC_FRV_GOT12
ENUMX
  BFD_RELOC_FRV_GOTHI
ENUMX
  BFD_RELOC_FRV_GOTLO
ENUMX
  BFD_RELOC_FRV_FUNCDESC
ENUMX
  BFD_RELOC_FRV_FUNCDESC_GOT12
ENUMX
  BFD_RELOC_FRV_FUNCDESC_GOTHI
ENUMX
  BFD_RELOC_FRV_FUNCDESC_GOTLO
ENUMX
  BFD_RELOC_FRV_FUNCDESC_VALUE
ENUMX
  BFD_RELOC_FRV_FUNCDESC_GOTOFF12
ENUMX
  BFD_RELOC_FRV_FUNCDESC_GOTOFFHI
ENUMX
  BFD_RELOC_FRV_FUNCDESC_GOTOFFLO
ENUMX
  BFD_RELOC_FRV_GOTOFF12
ENUMX
  BFD_RELOC_FRV_GOTOFFHI
ENUMX
  BFD_RELOC_FRV_GOTOFFLO
d2153 3
a2156 35
ENUM
  BFD_RELOC_MN10300_GOTOFF24
ENUMDOC
  This is a 24bit GOT-relative reloc for the mn10300.
ENUM
  BFD_RELOC_MN10300_GOT32
ENUMDOC
  This is a 32bit GOT-relative reloc for the mn10300, offset by two bytes
  in the instruction.
ENUM
  BFD_RELOC_MN10300_GOT24
ENUMDOC
  This is a 24bit GOT-relative reloc for the mn10300, offset by two bytes
  in the instruction.
ENUM
  BFD_RELOC_MN10300_GOT16
ENUMDOC
  This is a 16bit GOT-relative reloc for the mn10300, offset by two bytes
  in the instruction.
ENUM
  BFD_RELOC_MN10300_COPY
ENUMDOC
  Copy symbol at runtime.
ENUM
  BFD_RELOC_MN10300_GLOB_DAT
ENUMDOC
  Create GOT entry.
ENUM
  BFD_RELOC_MN10300_JMP_SLOT
ENUMDOC
  Create PLT entry.
ENUM
  BFD_RELOC_MN10300_RELATIVE
ENUMDOC
  Adjust by program base.
d2486 1
a2486 1
  The type of reloc used to build a constructor table - at the moment
a2889 31
ENUM
  BFD_RELOC_M32R_GOT24
ENUMX
  BFD_RELOC_M32R_26_PLTREL
ENUMX
  BFD_RELOC_M32R_COPY
ENUMX
  BFD_RELOC_M32R_GLOB_DAT
ENUMX
  BFD_RELOC_M32R_JMP_SLOT
ENUMX
  BFD_RELOC_M32R_RELATIVE
ENUMX
  BFD_RELOC_M32R_GOTOFF
ENUMX
  BFD_RELOC_M32R_GOTPC24
ENUMX
  BFD_RELOC_M32R_GOT16_HI_ULO
ENUMX
  BFD_RELOC_M32R_GOT16_HI_SLO
ENUMX
  BFD_RELOC_M32R_GOT16_LO
ENUMX
  BFD_RELOC_M32R_GOTPC_HI_ULO
ENUMX
  BFD_RELOC_M32R_GOTPC_HI_SLO
ENUMX
  BFD_RELOC_M32R_GOTPC_LO
ENUMDOC
  For PIC.

d2950 1
a2950 1
  bits placed non-contiguously in the instruction.
d2955 1
a2955 1
  bits placed non-contiguously in the instruction.
a3111 2
ENUMX
  BFD_RELOC_MMIX_PUSHJ_STUBBABLE
a3387 11
  BFD_RELOC_390_20
ENUMX
  BFD_RELOC_390_GOT20
ENUMX
  BFD_RELOC_390_GOTPLT20
ENUMX
  BFD_RELOC_390_TLS_GOTIE20
ENUMDOC
  Long displacement extension.

ENUM
d3448 1
a3448 1
  linker the inheritance tree of a C++ virtual function table.  The
d3641 1
a3641 1
  of instruction and change some branches to use PC-relative
a3670 5
ENUM
  BFD_RELOC_M68HC12_5B
ENUMDOC
  Motorola 68HC12 reloc.
  This is the 5 bits of a value.
d3908 2
a3909 2
	reloc_howto_type *bfd_reloc_type_lookup
	  (bfd *abfd, bfd_reloc_code_real_type code);
d3919 3
a3921 1
bfd_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code)
d3935 1
a3935 1
	  (bfd *abfd, bfd_reloc_code_real_type  code);
d3943 3
a3945 1
bfd_default_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code)
d3966 1
a3966 1
  return NULL;
d3982 2
a3983 1
bfd_get_reloc_code_name (bfd_reloc_code_real_type code)
d3985 1
a3985 1
  if (code > BFD_RELOC_UNUSED)
d3987 1
a3987 1
  return bfd_reloc_code_real_names[code];
d3996 4
a3999 4
	  (bfd *abfd,
	   asection *section,
	   struct bfd_link_info *,
	   bfd_boolean *);
d4003 1
a4003 2
	don't do relaxing -- i.e., does nothing except make sure that the
	final size of the section is set.
d4007 5
a4011 4
bfd_generic_relax_section (bfd *abfd ATTRIBUTE_UNUSED,
			   asection *section ATTRIBUTE_UNUSED,
			   struct bfd_link_info *link_info ATTRIBUTE_UNUSED,
			   bfd_boolean *again)
a4012 5
  /* We're not relaxing the section, so just copy the size info if it's
     zero.  Someone else, like bfd_merge_sections, might have set it, so
     don't overwrite a non-zero value.  */
  if (section->_cooked_size == 0)
    section->_cooked_size = section->_raw_size;
d4023 1
a4023 1
	  (bfd *, struct bfd_link_info *);
d4031 3
a4033 2
bfd_generic_gc_sections (bfd *abfd ATTRIBUTE_UNUSED,
			 struct bfd_link_info *link_info ATTRIBUTE_UNUSED)
d4044 1
a4044 1
	  (bfd *, struct bfd_link_info *);
d4052 3
a4054 2
bfd_generic_merge_sections (bfd *abfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *link_info ATTRIBUTE_UNUSED)
d4064 7
a4070 7
	bfd_byte *bfd_generic_get_relocated_section_contents
	  (bfd *abfd,
	   struct bfd_link_info *link_info,
	   struct bfd_link_order *link_order,
	   bfd_byte *data,
	   bfd_boolean relocatable,
	   asymbol **symbols);
d4079 8
a4086 6
bfd_generic_get_relocated_section_contents (bfd *abfd,
					    struct bfd_link_info *link_info,
					    struct bfd_link_order *link_order,
					    bfd_byte *data,
					    bfd_boolean relocatable,
					    asymbol **symbols)
d4099 1
a4099 1
  reloc_vector = bfd_malloc (reloc_size);
d4106 2
a4107 2
				 data,
				 0,
d4111 2
a4112 7
  /* Don't set input_section->_cooked_size here.  The caller has set
     _cooked_size or called bfd_relax_section, which sets _cooked_size.
     Despite using this generic relocation function, some targets perform
     target-specific relaxation or string merging, which happens before
     this function is called.  We do not want to clobber the _cooked_size
     they computed.  */

d4125 2
a4126 1
      for (parent = reloc_vector; *parent != NULL; parent++)
d4128 1
a4128 1
	  char *error_message = NULL;
d4132 1
a4132 1
				    data,
d4134 1
a4134 1
				    relocatable ? abfd : NULL,
d4137 1
a4137 1
	  if (relocatable)
d4158 1
a4158 1
		  BFD_ASSERT (error_message != NULL);
@


