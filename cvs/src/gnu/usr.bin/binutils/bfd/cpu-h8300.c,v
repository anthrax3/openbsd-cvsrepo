head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.50
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.48
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.44
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.46
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.38
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.42
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.40
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.36
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.34
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.32
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.30
	OPENBSD_5_0:1.5.0.28
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.26
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.24
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.20
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.22
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.18
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.16
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.5
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.2.0.26
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.24
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.2.0.22
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.20
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.2
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.11.02.20.45.05;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.17.21.54.21;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.29;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	96.09.04.19.00.13;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.39;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.39;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.09.04.17.37.31;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.22.16;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.13;	author drahn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.11.02.20.22.18;	author miod;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD library support routines for the Renesas H8/300 architecture.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Hacked by Steve Chamberlain of Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"

static bfd_boolean
h8300_scan (const struct bfd_arch_info *info, const char *string)
{
  if (*string != 'h' && *string != 'H')
    return FALSE;

  string++;
  if (*string != '8')
    return FALSE;

  string++;
  if (*string == '/')
    string++;

  if (*string != '3')
    return FALSE;
  string++;
  if (*string != '0')
    return FALSE;
  string++;
  if (*string != '0')
    return FALSE;
  string++;
  if (*string == '-')
    string++;

  /* In ELF linker scripts, we typically express the architecture/machine
     as architecture:machine.

     So if we've matched so far and encounter a colon, try to match the
     string following the colon.  */
  if (*string == ':')
    {
      string++;
      return h8300_scan (info, string);
    }

  if (*string == 'h' || *string == 'H')
    {
      string++;
      if (*string == 'n' || *string == 'N')
	return (info->mach == bfd_mach_h8300hn);

      return (info->mach == bfd_mach_h8300h);
    }
  else if (*string == 's' || *string == 'S')
    {
      string++;
      if (*string == 'n' || *string == 'N')
	return (info->mach == bfd_mach_h8300sn);

      if (*string == 'x' || *string == 'X')
	{
	  string++;
	  if (*string == 'n' || *string == 'N')
	    return (info->mach == bfd_mach_h8300sxn);

	  return (info->mach == bfd_mach_h8300sx);
	}
      
      return (info->mach == bfd_mach_h8300s);
    }
  else
    return info->mach == bfd_mach_h8300;
}

/* This routine is provided two arch_infos and works out the machine
   which would be compatible with both and returns a pointer to its
   info structure.  */

static const bfd_arch_info_type *
compatible (const bfd_arch_info_type *in, const bfd_arch_info_type *out)
{
  /* It's really not a good idea to mix and match modes.  */
  if (in->arch != out->arch || in->mach != out->mach)
    return 0;
  else
    return in;
}

static const bfd_arch_info_type h8300sxn_info_struct =
{
  32,				/* 32 bits in a word */
  16,				/* 16 bits in an address */
  8,				/* 8 bits in a byte */
  bfd_arch_h8300,
  bfd_mach_h8300sxn,
  "h8300sxn",			/* arch_name  */
  "h8300sxn",			/* printable name */
  1,
  FALSE,			/* the default machine */
  compatible,
  h8300_scan,
  0
};

static const bfd_arch_info_type h8300sx_info_struct =
{
  32,				/* 32 bits in a word */
  32,				/* 32 bits in an address */
  8,				/* 8 bits in a byte */
  bfd_arch_h8300,
  bfd_mach_h8300sx,
  "h8300sx",			/* arch_name  */
  "h8300sx",			/* printable name */
  1,
  FALSE,			/* the default machine */
  compatible,
  h8300_scan,
  &h8300sxn_info_struct
};

static const bfd_arch_info_type h8300sn_info_struct =
{
  32,				/* 32 bits in a word.  */
  16,				/* 16 bits in an address.  */
  8,				/* 8 bits in a byte.  */
  bfd_arch_h8300,
  bfd_mach_h8300sn,
  "h8300sn",			/* Architecture name.  */
  "h8300sn",			/* Printable name.  */
  1,
  FALSE,			/* The default machine.  */
  compatible,
  h8300_scan,
  &h8300sx_info_struct
};

static const bfd_arch_info_type h8300hn_info_struct =
{
  32,				/* 32 bits in a word.  */
  16,				/* 16 bits in an address.  */
  8,				/* 8 bits in a byte.  */
  bfd_arch_h8300,
  bfd_mach_h8300hn,
  "h8300hn",			/* Architecture name.  */
  "h8300hn",			/* Printable name.  */
  1,
  FALSE,			/* The default machine.  */
  compatible,
  h8300_scan,
  &h8300sn_info_struct
};

static const bfd_arch_info_type h8300s_info_struct =
{
  32,				/* 32 bits in a word.  */
  32,				/* 32 bits in an address.  */
  8,				/* 8 bits in a byte.  */
  bfd_arch_h8300,
  bfd_mach_h8300s,
  "h8300s",			/* Architecture name.  */
  "h8300s",			/* Printable name.  */
  1,
  FALSE,			/* The default machine.  */
  compatible,
  h8300_scan,
  & h8300hn_info_struct
};

static const bfd_arch_info_type h8300h_info_struct =
{
  32,				/* 32 bits in a word.  */
  32,				/* 32 bits in an address.  */
  8,				/* 8 bits in a byte.  */
  bfd_arch_h8300,
  bfd_mach_h8300h,
  "h8300h",			/* Architecture name.  */
  "h8300h",			/* Printable name.  */
  1,
  FALSE,			/* The default machine.  */
  compatible,
  h8300_scan,
  &h8300s_info_struct
};

const bfd_arch_info_type bfd_h8300_arch =
{
  16,				/* 16 bits in a word.  */
  16,				/* 16 bits in an address.  */
  8,				/* 8 bits in a byte.  */
  bfd_arch_h8300,
  bfd_mach_h8300,
  "h8300",			/* Architecture name.  */
  "h8300",			/* Printable name.  */
  1,
  TRUE,				/* The default machine.  */
  compatible,
  h8300_scan,
  &h8300h_info_struct
};

/* Pad the given address to 32 bits, converting 16-bit and 24-bit
   addresses into the values they would have had on a h8s target.  */

bfd_vma
bfd_h8300_pad_address (bfd *abfd, bfd_vma address)
{
  /* Cope with bfd_vma's larger than 32 bits.  */
  address &= 0xffffffffu;

  switch (bfd_get_mach (abfd))
    {
    case bfd_mach_h8300:
    case bfd_mach_h8300hn:
    case bfd_mach_h8300sn:
    case bfd_mach_h8300sxn:
      /* Sign extend a 16-bit address.  */
      if (address >= 0x8000)
	return address | 0xffff0000u;
      return address;

    case bfd_mach_h8300h:
      /* Sign extend a 24-bit address.  */
      if (address >= 0x800000)
	return address | 0xff000000u;
      return address;

    case bfd_mach_h8300s:
    case bfd_mach_h8300sx:
      return address;

    default:
      abort ();
    }
}
@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@a25 5
static bfd_boolean h8300_scan
  PARAMS ((const struct bfd_arch_info *, const char *));
static const bfd_arch_info_type * compatible
  PARAMS ((const bfd_arch_info_type *, const bfd_arch_info_type *));

d27 1
a27 3
h8300_scan (info, string)
     const struct bfd_arch_info *info;
     const char *string;
d77 9
d97 1
a97 3
compatible (in, out)
     const bfd_arch_info_type *in;
     const bfd_arch_info_type *out;
d106 32
d141 1
a141 1
  32,				/* 32 bits in an address.  */
d151 1
a151 1
  0
a153 1

d157 1
a157 1
  32,				/* 32 bits in an address.  */
d217 35
@


1.3
log
@resolve conflicts.
@
text
@d1 2
a2 2
/* BFD library support routines for the Hitachi H8/300 architecture.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 2000
d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d26 4
a29 1
int bfd_default_scan_num_mach ();
d31 1
a31 1
static boolean
d37 1
a37 1
    return false;
d41 1
a41 1
    return false;
d48 1
a48 1
    return false;
d51 1
a51 1
    return false;
d54 1
a54 1
    return false;
d58 12
d72 4
d80 4
d87 1
a87 3
    {
      return info->mach == bfd_mach_h8300;
    }
d100 1
a100 1
  if (in->mach != out->mach)
d106 34
a139 1
static const bfd_arch_info_type h8300_info_struct =
d141 3
a143 3
  16,				/* 16 bits in a word */
  16,				/* 16 bits in an address */
  8,				/* 8 bits in a byte */
d145 3
a147 3
  bfd_mach_h8300,
  "h8300",			/* arch_name  */
  "h8300",			/* printable name */
d149 1
a149 1
  true,				/* the default machine */
d152 1
a152 4
#if 0
  local_bfd_reloc_type_lookup,
#endif
  0,
d157 3
a159 3
  32,				/* 32 bits in a word */
  32,				/* 32 bits in an address */
  8,				/* 8 bits in a byte */
d162 2
a163 2
  "h8300h",			/* arch_name  */
  "h8300h",			/* printable name */
d165 1
a165 1
  false,			/* the default machine */
d168 1
a168 4
#if 0
  local_bfd_reloc_type_lookup,
#endif
  &h8300_info_struct,
d173 3
a175 3
  32,				/* 32 bits in a word */
  32,				/* 32 bits in an address */
  8,				/* 8 bits in a byte */
d177 3
a179 3
  bfd_mach_h8300s,
  "h8300s",			/* arch_name  */
  "h8300s",			/* printable name */
d181 1
a181 1
  false,			/* the default machine */
d184 1
a184 4
#if 0
  local_bfd_reloc_type_lookup,
#endif
  &h8300h_info_struct,
@


1.2
log
@Merge the Cygnus 960904 sources
@
text
@d2 2
a3 1
   Copyright (C) 1990, 91, 92, 93, 94, 1995 Free Software Foundation, Inc.
d69 3
a71 4

/* This routine is provided two arch_infos and works out the 
   machine which would be compatible with both and returns a pointer
   to its info structure */
d75 2
a76 2
     const bfd_arch_info_type * in;
     const bfd_arch_info_type * out;
d98 3
a100 1
/*    local_bfd_reloc_type_lookup, */
d117 3
a119 1
/*    local_bfd_reloc_type_lookup, */
d136 3
a138 1
/*    local_bfd_reloc_type_lookup, */
@


1.1
log
@Initial revision
@
text
@a24 128
#if 0 /* not used currently */
/*
Relocations for the H8

*/
static bfd_reloc_status_type
howto16_callback (abfd, reloc_entry, symbol_in, data,
		  ignore_input_section, ignore_bfd)
     bfd * abfd;
     arelent * reloc_entry;
     struct symbol_cache_entry *symbol_in;
     PTR data;
     asection * ignore_input_section;
     bfd * ignore_bfd;
{
  long relocation = 0;
  bfd_vma addr = reloc_entry->address;
  long x = bfd_get_16 (abfd, (bfd_byte *) data + addr);

  HOWTO_PREPARE (relocation, symbol_in);

  x = (x + relocation + reloc_entry->addend);

  bfd_put_16 (abfd, x, (bfd_byte *) data + addr);
  return bfd_reloc_ok;
}


static bfd_reloc_status_type
howto8_callback (abfd, reloc_entry, symbol_in, data,
		 ignore_input_section, ignore_bfd)
     bfd * abfd;
     arelent * reloc_entry;
     struct symbol_cache_entry *symbol_in;
     PTR data;
     asection * ignore_input_section;
     bfd * ignore_bfd;
{
  long relocation = 0;
  bfd_vma addr = reloc_entry->address;
  long x = bfd_get_8 (abfd, (bfd_byte *) data + addr);

  HOWTO_PREPARE (relocation, symbol_in);

  x = (x + relocation + reloc_entry->addend);

  bfd_put_8 (abfd, x, (bfd_byte *) data + addr);
  return bfd_reloc_ok;
}


static bfd_reloc_status_type
howto8_FFnn_callback (abfd, reloc_entry, symbol_in, data,
		      ignore_input_section, ignore_bfd)
     bfd * abfd;
     arelent * reloc_entry;
     struct symbol_cache_entry *symbol_in;
     PTR data;
     asection * ignore_input_section;
     bfd * ignore_bfd;
{
  long relocation = 0;
  bfd_vma addr = reloc_entry->address;

  long x = bfd_get_8 (abfd, (bfd_byte *) data + addr);
  abort ();
  HOWTO_PREPARE (relocation, symbol_in);

  x = (x + relocation + reloc_entry->addend);

  bfd_put_8 (abfd, x, (bfd_byte *) data + addr);
  return bfd_reloc_ok;
}

static bfd_reloc_status_type
howto8_pcrel_callback (abfd, reloc_entry, symbol_in, data,
		       ignore_input_section, ignore_bfd)
     bfd * abfd;
     arelent * reloc_entry;
     struct symbol_cache_entry *symbol_in;
     PTR data;
     asection * ignore_input_section;
     bfd * ignore_bfd;
{
  long relocation = 0;
  bfd_vma addr = reloc_entry->address;
  long x = bfd_get_8 (abfd, (bfd_byte *) data + addr);
  abort ();
  HOWTO_PREPARE (relocation, symbol_in);

  x = (x + relocation + reloc_entry->addend);

  bfd_put_8 (abfd, x, (bfd_byte *) data + addr);
  return bfd_reloc_ok;
}

static reloc_howto_type howto_16
= NEWHOWTO (howto16_callback, "abs16", 1, false, false);
static reloc_howto_type howto_8
= NEWHOWTO (howto8_callback, "abs8", 0, false, false);

static reloc_howto_type howto_8_FFnn
= NEWHOWTO (howto8_FFnn_callback, "ff00+abs8", 0, false, false);

static reloc_howto_type howto_8_pcrel
= NEWHOWTO (howto8_pcrel_callback, "pcrel8", 0, false, true);

static reloc_howto_type *
local_bfd_reloc_type_lookup (arch, code)
     const struct bfd_arch_info *arch;
     bfd_reloc_code_real_type code;
{
    switch (code)
      {
      case BFD_RELOC_16:
	return &howto_16;
      case BFD_RELOC_8_FFnn:
	return &howto_8_FFnn;
      case BFD_RELOC_8:
	return &howto_8;
      case BFD_RELOC_8_PCREL:
	return &howto_8_pcrel;
      default:
	return (reloc_howto_type *) NULL;
      }
  }
#endif

d58 4
d78 2
a79 3
  /* If the output is non-H and the input is -H, that's bad */
  if (in->mach == bfd_mach_h8300h &&
      out->mach == bfd_mach_h8300)
d81 1
a81 3

  /* If either is an -H, the answer is -H */
  if (in->mach == bfd_mach_h8300h)
a82 1
  return out;
d102 1
a102 2

const bfd_arch_info_type bfd_h8300_arch =
d117 17
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d25 128
a185 4
  else if (*string == 's' || *string == 'S')
    {
      return (info->mach == bfd_mach_h8300s);
    }
d202 3
a204 2
  /* It's really not a good idea to mix and match modes.  */
  if (in->mach != out->mach)
d206 3
a208 1
  else
d210 1
d230 2
a231 1
static const bfd_arch_info_type h8300h_info_struct =
a245 17
};

const bfd_arch_info_type bfd_h8300_arch =
{
  32,				/* 32 bits in a word */
  32,				/* 32 bits in an address */
  8,				/* 8 bits in a byte */
  bfd_arch_h8300,
  bfd_mach_h8300s,
  "h8300s",			/* arch_name  */
  "h8300s",			/* printable name */
  1,
  false,			/* the default machine */
  compatible,
  h8300_scan,
/*    local_bfd_reloc_type_lookup, */
  &h8300h_info_struct,
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 2000
   Free Software Foundation, Inc.
d68 4
a71 3
/* This routine is provided two arch_infos and works out the machine
   which would be compatible with both and returns a pointer to its
   info structure.  */
d75 2
a76 2
     const bfd_arch_info_type *in;
     const bfd_arch_info_type *out;
d98 1
a98 3
#if 0
  local_bfd_reloc_type_lookup,
#endif
d115 1
a115 3
#if 0
  local_bfd_reloc_type_lookup,
#endif
d132 1
a132 3
#if 0
  local_bfd_reloc_type_lookup,
#endif
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d1 2
a2 2
/* BFD library support routines for the Renesas H8/300 architecture.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d26 1
a26 4
static bfd_boolean h8300_scan
  PARAMS ((const struct bfd_arch_info *, const char *));
static const bfd_arch_info_type * compatible
  PARAMS ((const bfd_arch_info_type *, const bfd_arch_info_type *));
d28 1
a28 1
static bfd_boolean
d34 1
a34 1
    return FALSE;
d38 1
a38 1
    return FALSE;
d45 1
a45 1
    return FALSE;
d48 1
a48 1
    return FALSE;
d51 1
a51 1
    return FALSE;
a54 12

  /* In ELF linker scripts, we typically express the architecture/machine
     as architecture:machine.

     So if we've matched so far and encounter a colon, try to match the
     string following the colon.  */
  if (*string == ':')
    {
      string++;
      return h8300_scan (info, string);
    }

a56 4
      string++;
      if (*string == 'n' || *string == 'N')
	return (info->mach == bfd_mach_h8300hn);

a60 4
      string++;
      if (*string == 'n' || *string == 'N')
	return (info->mach == bfd_mach_h8300sn);

d64 3
a66 1
    return info->mach == bfd_mach_h8300;
d79 1
a79 1
  if (in->arch != out->arch || in->mach != out->mach)
d85 1
a85 1
static const bfd_arch_info_type h8300sn_info_struct =
d87 3
a89 3
  32,				/* 32 bits in a word.  */
  32,				/* 32 bits in an address.  */
  8,				/* 8 bits in a byte.  */
d91 3
a93 36
  bfd_mach_h8300sn,
  "h8300sn",			/* Architecture name.  */
  "h8300sn",			/* Printable name.  */
  1,
  FALSE,			/* The default machine.  */
  compatible,
  h8300_scan,
  0
};


static const bfd_arch_info_type h8300hn_info_struct =
{
  32,				/* 32 bits in a word.  */
  32,				/* 32 bits in an address.  */
  8,				/* 8 bits in a byte.  */
  bfd_arch_h8300,
  bfd_mach_h8300hn,
  "h8300hn",			/* Architecture name.  */
  "h8300hn",			/* Printable name.  */
  1,
  FALSE,			/* The default machine.  */
  compatible,
  h8300_scan,
  &h8300sn_info_struct
};

static const bfd_arch_info_type h8300s_info_struct =
{
  32,				/* 32 bits in a word.  */
  32,				/* 32 bits in an address.  */
  8,				/* 8 bits in a byte.  */
  bfd_arch_h8300,
  bfd_mach_h8300s,
  "h8300s",			/* Architecture name.  */
  "h8300s",			/* Printable name.  */
d95 1
a95 1
  FALSE,			/* The default machine.  */
d98 4
a101 1
  & h8300hn_info_struct
d106 3
a108 3
  32,				/* 32 bits in a word.  */
  32,				/* 32 bits in an address.  */
  8,				/* 8 bits in a byte.  */
d111 2
a112 2
  "h8300h",			/* Architecture name.  */
  "h8300h",			/* Printable name.  */
d114 1
a114 1
  FALSE,			/* The default machine.  */
d117 4
a120 1
  &h8300s_info_struct
d125 3
a127 3
  16,				/* 16 bits in a word.  */
  16,				/* 16 bits in an address.  */
  8,				/* 8 bits in a byte.  */
d129 3
a131 3
  bfd_mach_h8300,
  "h8300",			/* Architecture name.  */
  "h8300",			/* Printable name.  */
d133 1
a133 1
  TRUE,				/* The default machine.  */
d136 4
a139 1
  &h8300h_info_struct
@


1.1.1.5
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d26 5
d32 3
a34 1
h8300_scan (const struct bfd_arch_info *info, const char *string)
a83 9
      if (*string == 'x' || *string == 'X')
	{
	  string++;
	  if (*string == 'n' || *string == 'N')
	    return (info->mach == bfd_mach_h8300sxn);

	  return (info->mach == bfd_mach_h8300sx);
	}
      
d95 3
a97 1
compatible (const bfd_arch_info_type *in, const bfd_arch_info_type *out)
a105 32
static const bfd_arch_info_type h8300sxn_info_struct =
{
  32,				/* 32 bits in a word */
  16,				/* 16 bits in an address */
  8,				/* 8 bits in a byte */
  bfd_arch_h8300,
  bfd_mach_h8300sxn,
  "h8300sxn",			/* arch_name  */
  "h8300sxn",			/* printable name */
  1,
  FALSE,			/* the default machine */
  compatible,
  h8300_scan,
  0
};

static const bfd_arch_info_type h8300sx_info_struct =
{
  32,				/* 32 bits in a word */
  32,				/* 32 bits in an address */
  8,				/* 8 bits in a byte */
  bfd_arch_h8300,
  bfd_mach_h8300sx,
  "h8300sx",			/* arch_name  */
  "h8300sx",			/* printable name */
  1,
  FALSE,			/* the default machine */
  compatible,
  h8300_scan,
  &h8300sxn_info_struct
};

d109 1
a109 1
  16,				/* 16 bits in an address.  */
d119 1
a119 1
  &h8300sx_info_struct
d122 1
d126 1
a126 1
  16,				/* 16 bits in an address.  */
a185 35

/* Pad the given address to 32 bits, converting 16-bit and 24-bit
   addresses into the values they would have had on a h8s target.  */

bfd_vma
bfd_h8300_pad_address (bfd *abfd, bfd_vma address)
{
  /* Cope with bfd_vma's larger than 32 bits.  */
  address &= 0xffffffffu;

  switch (bfd_get_mach (abfd))
    {
    case bfd_mach_h8300:
    case bfd_mach_h8300hn:
    case bfd_mach_h8300sn:
    case bfd_mach_h8300sxn:
      /* Sign extend a 16-bit address.  */
      if (address >= 0x8000)
	return address | 0xffff0000u;
      return address;

    case bfd_mach_h8300h:
      /* Sign extend a 24-bit address.  */
      if (address >= 0x800000)
	return address | 0xff000000u;
      return address;

    case bfd_mach_h8300s:
    case bfd_mach_h8300sx:
      return address;

    default:
      abort ();
    }
}
@


