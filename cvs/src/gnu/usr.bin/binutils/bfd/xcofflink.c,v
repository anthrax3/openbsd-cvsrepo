head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.11.02.20.45.13;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.24;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.31;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.24;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.33.36;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.02.04;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.47.29;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.15;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.15;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.06.38;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.38.57;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.13.07;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.20.54;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.59;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.28.41;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.21;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.35;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* POWER/PowerPC XCOFF linker support.
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Written by Ian Lance Taylor <ian@@cygnus.com>, Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "coff/internal.h"
#include "coff/xcoff.h"
#include "libcoff.h"
#include "libxcoff.h"

/* This file holds the XCOFF linker code.  */

#define STRING_SIZE_SIZE (4)

/* We reuse the SEC_ROM flag as a mark flag for garbage collection.
   This flag will only be used on input sections.  */

#define SEC_MARK (SEC_ROM)

/* The list of import files.  */

struct xcoff_import_file
{
  /* The next entry in the list.  */
  struct xcoff_import_file *next;
  /* The path.  */
  const char *path;
  /* The file name.  */
  const char *file;
  /* The member name.  */
  const char *member;
};

/* Information we keep for each section in the output file during the
   final link phase.  */

struct xcoff_link_section_info
{
  /* The relocs to be output.  */
  struct internal_reloc *relocs;
  /* For each reloc against a global symbol whose index was not known
     when the reloc was handled, the global hash table entry.  */
  struct xcoff_link_hash_entry **rel_hashes;
  /* If there is a TOC relative reloc against a global symbol, and the
     index of the TOC symbol is not known when the reloc was handled,
     an entry is added to this linked list.  This is not an array,
     like rel_hashes, because this case is quite uncommon.  */
  struct xcoff_toc_rel_hash {
    struct xcoff_toc_rel_hash *next;
    struct xcoff_link_hash_entry *h;
    struct internal_reloc *rel;
  } *toc_rel_hashes;
};

/* Information that we pass around while doing the final link step.  */

struct xcoff_final_link_info
{
  /* General link information.  */
  struct bfd_link_info *info;
  /* Output BFD.  */
  bfd *output_bfd;
  /* Hash table for long symbol names.  */
  struct bfd_strtab_hash *strtab;
  /* Array of information kept for each output section, indexed by the
     target_index field.  */
  struct xcoff_link_section_info *section_info;
  /* Symbol index of last C_FILE symbol (-1 if none).  */
  long last_file_index;
  /* Contents of last C_FILE symbol.  */
  struct internal_syment last_file;
  /* Symbol index of TOC symbol.  */
  long toc_symindx;
  /* Start of .loader symbols.  */
  bfd_byte *ldsym;
  /* Next .loader reloc to swap out.  */
  bfd_byte *ldrel;
  /* File position of start of line numbers.  */
  file_ptr line_filepos;
  /* Buffer large enough to hold swapped symbols of any input file.  */
  struct internal_syment *internal_syms;
  /* Buffer large enough to hold output indices of symbols of any
     input file.  */
  long *sym_indices;
  /* Buffer large enough to hold output symbols for any input file.  */
  bfd_byte *outsyms;
  /* Buffer large enough to hold external line numbers for any input
     section.  */
  bfd_byte *linenos;
  /* Buffer large enough to hold any input section.  */
  bfd_byte *contents;
  /* Buffer large enough to hold external relocs of any input section.  */
  bfd_byte *external_relocs;
};

static struct bfd_hash_entry *xcoff_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static bfd_boolean xcoff_get_section_contents PARAMS ((bfd *, asection *));
static struct internal_reloc *xcoff_read_internal_relocs
  PARAMS ((bfd *, asection *, bfd_boolean, bfd_byte *, bfd_boolean,
	   struct internal_reloc *));
static bfd_boolean xcoff_link_add_object_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean xcoff_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean xcoff_link_check_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean xcoff_link_check_dynamic_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
static bfd_size_type xcoff_find_reloc
  PARAMS ((struct internal_reloc *, bfd_size_type, bfd_vma));
static bfd_boolean xcoff_link_add_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean xcoff_link_add_dynamic_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean xcoff_mark_symbol
  PARAMS ((struct bfd_link_info *, struct xcoff_link_hash_entry *));
static bfd_boolean xcoff_mark PARAMS ((struct bfd_link_info *, asection *));
static void xcoff_sweep PARAMS ((struct bfd_link_info *));
static bfd_boolean xcoff_build_ldsyms
  PARAMS ((struct xcoff_link_hash_entry *, PTR));
static bfd_boolean xcoff_link_input_bfd
  PARAMS ((struct xcoff_final_link_info *, bfd *));
static bfd_boolean xcoff_write_global_symbol
  PARAMS ((struct xcoff_link_hash_entry *, PTR));
static bfd_boolean xcoff_reloc_link_order
  PARAMS ((bfd *, struct xcoff_final_link_info *, asection *,
	   struct bfd_link_order *));
static int xcoff_sort_relocs PARAMS ((const PTR, const PTR));


/* Routines to read XCOFF dynamic information.  This don't really
   belong here, but we already have the ldsym manipulation routines
   here.  */

/* Read the contents of a section.  */

static bfd_boolean
xcoff_get_section_contents (abfd, sec)
     bfd *abfd;
     asection *sec;
{

  if (coff_section_data (abfd, sec) == NULL)
    {
      bfd_size_type amt = sizeof (struct coff_section_tdata);
      sec->used_by_bfd = bfd_zalloc (abfd, amt);
      if (sec->used_by_bfd == NULL)
	return FALSE;
    }

  if (coff_section_data (abfd, sec)->contents == NULL)
    {
      coff_section_data (abfd, sec)->contents = ((bfd_byte *)
						 bfd_malloc (sec->_raw_size));
      if (coff_section_data (abfd, sec)->contents == NULL)
	return FALSE;

      if (! bfd_get_section_contents (abfd, sec,
				      coff_section_data (abfd, sec)->contents,
				      (file_ptr) 0, sec->_raw_size))
	return FALSE;
    }

  return TRUE;
}

/* Get the size required to hold the dynamic symbols.  */

long
_bfd_xcoff_get_dynamic_symtab_upper_bound (abfd)
     bfd *abfd;
{
  asection *lsec;
  bfd_byte *contents;
  struct internal_ldhdr ldhdr;

  if ((abfd->flags & DYNAMIC) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  lsec = bfd_get_section_by_name (abfd, ".loader");
  if (lsec == NULL)
    {
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

  if (! xcoff_get_section_contents (abfd, lsec))
    return -1;
  contents = coff_section_data (abfd, lsec)->contents;

  bfd_xcoff_swap_ldhdr_in (abfd, (PTR) contents, &ldhdr);

  return (ldhdr.l_nsyms + 1) * sizeof (asymbol *);
}

/* Get the dynamic symbols.  */

long
_bfd_xcoff_canonicalize_dynamic_symtab (abfd, psyms)
     bfd *abfd;
     asymbol **psyms;
{
  asection *lsec;
  bfd_byte *contents;
  struct internal_ldhdr ldhdr;
  const char *strings;
  bfd_byte *elsym, *elsymend;
  coff_symbol_type *symbuf;

  if ((abfd->flags & DYNAMIC) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  lsec = bfd_get_section_by_name (abfd, ".loader");
  if (lsec == NULL)
    {
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

  if (! xcoff_get_section_contents (abfd, lsec))
    return -1;
  contents = coff_section_data (abfd, lsec)->contents;

  coff_section_data (abfd, lsec)->keep_contents = TRUE;

  bfd_xcoff_swap_ldhdr_in (abfd, contents, &ldhdr);

  strings = (char *) contents + ldhdr.l_stoff;

  symbuf = ((coff_symbol_type *)
	    bfd_zalloc (abfd, ldhdr.l_nsyms * sizeof (coff_symbol_type)));
  if (symbuf == NULL)
    return -1;

  elsym = contents + bfd_xcoff_loader_symbol_offset(abfd, &ldhdr);

  elsymend = elsym + ldhdr.l_nsyms * bfd_xcoff_ldsymsz(abfd);
  for (; elsym < elsymend; elsym += bfd_xcoff_ldsymsz(abfd), symbuf++, psyms++)
    {
      struct internal_ldsym ldsym;

      bfd_xcoff_swap_ldsym_in (abfd, elsym, &ldsym);

      symbuf->symbol.the_bfd = abfd;

      if (ldsym._l._l_l._l_zeroes == 0)
	symbuf->symbol.name = strings + ldsym._l._l_l._l_offset;
      else
	{
	  char *c;

	  c = bfd_alloc (abfd, (bfd_size_type) SYMNMLEN + 1);
	  if (c == NULL)
	    return -1;
	  memcpy (c, ldsym._l._l_name, SYMNMLEN);
	  c[SYMNMLEN] = '\0';
	  symbuf->symbol.name = c;
	}

      if (ldsym.l_smclas == XMC_XO)
	symbuf->symbol.section = bfd_abs_section_ptr;
      else
	symbuf->symbol.section = coff_section_from_bfd_index (abfd,
							      ldsym.l_scnum);
      symbuf->symbol.value = ldsym.l_value - symbuf->symbol.section->vma;

      symbuf->symbol.flags = BSF_NO_FLAGS;
      if ((ldsym.l_smtype & L_EXPORT) != 0)
	symbuf->symbol.flags |= BSF_GLOBAL;

      /* FIXME: We have no way to record the other information stored
	 with the loader symbol.  */

      *psyms = (asymbol *) symbuf;
    }

  *psyms = NULL;

  return ldhdr.l_nsyms;
}

/* Get the size required to hold the dynamic relocs.  */

long
_bfd_xcoff_get_dynamic_reloc_upper_bound (abfd)
     bfd *abfd;
{
  asection *lsec;
  bfd_byte *contents;
  struct internal_ldhdr ldhdr;

  if ((abfd->flags & DYNAMIC) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  lsec = bfd_get_section_by_name (abfd, ".loader");
  if (lsec == NULL)
    {
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

  if (! xcoff_get_section_contents (abfd, lsec))
    return -1;
  contents = coff_section_data (abfd, lsec)->contents;

  bfd_xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) contents, &ldhdr);

  return (ldhdr.l_nreloc + 1) * sizeof (arelent *);
}

/* Get the dynamic relocs.  */

long
_bfd_xcoff_canonicalize_dynamic_reloc (abfd, prelocs, syms)
     bfd *abfd;
     arelent **prelocs;
     asymbol **syms;
{
  asection *lsec;
  bfd_byte *contents;
  struct internal_ldhdr ldhdr;
  arelent *relbuf;
  bfd_byte *elrel, *elrelend;

  if ((abfd->flags & DYNAMIC) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  lsec = bfd_get_section_by_name (abfd, ".loader");
  if (lsec == NULL)
    {
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

  if (! xcoff_get_section_contents (abfd, lsec))
    return -1;
  contents = coff_section_data (abfd, lsec)->contents;

  bfd_xcoff_swap_ldhdr_in (abfd, contents, &ldhdr);

  relbuf = (arelent *) bfd_alloc (abfd, ldhdr.l_nreloc * sizeof (arelent));
  if (relbuf == NULL)
    return -1;

  elrel = contents + bfd_xcoff_loader_reloc_offset(abfd, &ldhdr);

  elrelend = elrel + ldhdr.l_nreloc * bfd_xcoff_ldrelsz(abfd);
  for (; elrel < elrelend; elrel += bfd_xcoff_ldrelsz(abfd), relbuf++,
	 prelocs++)
    {
      struct internal_ldrel ldrel;

      bfd_xcoff_swap_ldrel_in (abfd, elrel, &ldrel);

      if (ldrel.l_symndx >= 3)
	relbuf->sym_ptr_ptr = syms + (ldrel.l_symndx - 3);
      else
	{
	  const char *name;
	  asection *sec;

	  switch (ldrel.l_symndx)
	    {
	    case 0:
	      name = ".text";
	      break;
	    case 1:
	      name = ".data";
	      break;
	    case 2:
	      name = ".bss";
	      break;
	    default:
	      abort ();
	      break;
	    }

	  sec = bfd_get_section_by_name (abfd, name);
	  if (sec == NULL)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      return -1;
	    }

	  relbuf->sym_ptr_ptr = sec->symbol_ptr_ptr;
	}

      relbuf->address = ldrel.l_vaddr;
      relbuf->addend = 0;

      /* Most dynamic relocs have the same type.  FIXME: This is only
	 correct if ldrel.l_rtype == 0.  In other cases, we should use
	 a different howto.  */
      relbuf->howto = bfd_xcoff_dynamic_reloc_howto(abfd);

      /* FIXME: We have no way to record the l_rsecnm field.  */

      *prelocs = relbuf;
    }

  *prelocs = NULL;

  return ldhdr.l_nreloc;
}

/* Routine to create an entry in an XCOFF link hash table.  */

static struct bfd_hash_entry *
xcoff_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
{
  struct xcoff_link_hash_entry *ret = (struct xcoff_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct xcoff_link_hash_entry *) NULL)
    ret = ((struct xcoff_link_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct xcoff_link_hash_entry)));
  if (ret == (struct xcoff_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct xcoff_link_hash_entry *)
	 _bfd_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				 table, string));
  if (ret != NULL)
    {
      /* Set local fields.  */
      ret->indx = -1;
      ret->toc_section = NULL;
      ret->u.toc_indx = -1;
      ret->descriptor = NULL;
      ret->ldsym = NULL;
      ret->ldindx = -1;
      ret->flags = 0;
      ret->smclas = XMC_UA;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Create a XCOFF link hash table.  */

struct bfd_link_hash_table *
_bfd_xcoff_bfd_link_hash_table_create (abfd)
     bfd *abfd;
{
  struct xcoff_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct xcoff_link_hash_table);

  ret = (struct xcoff_link_hash_table *) bfd_malloc (amt);
  if (ret == (struct xcoff_link_hash_table *) NULL)
    return (struct bfd_link_hash_table *) NULL;
  if (! _bfd_link_hash_table_init (&ret->root, abfd, xcoff_link_hash_newfunc))
    {
      free (ret);
      return (struct bfd_link_hash_table *) NULL;
    }

  ret->debug_strtab = _bfd_xcoff_stringtab_init ();
  ret->debug_section = NULL;
  ret->loader_section = NULL;
  ret->ldrel_count = 0;
  memset (&ret->ldhdr, 0, sizeof (struct internal_ldhdr));
  ret->linkage_section = NULL;
  ret->toc_section = NULL;
  ret->descriptor_section = NULL;
  ret->imports = NULL;
  ret->file_align = 0;
  ret->textro = FALSE;
  ret->gc = FALSE;
  memset (ret->special_sections, 0, sizeof ret->special_sections);

  /* The linker will always generate a full a.out header.  We need to
     record that fact now, before the sizeof_headers routine could be
     called.  */
  xcoff_data (abfd)->full_aouthdr = TRUE;

  return &ret->root;
}

/* Free a XCOFF link hash table.  */

void
_bfd_xcoff_bfd_link_hash_table_free (hash)
     struct bfd_link_hash_table *hash;
{
  struct xcoff_link_hash_table *ret = (struct xcoff_link_hash_table *) hash;

  _bfd_stringtab_free (ret->debug_strtab);
  bfd_hash_table_free (&ret->root.table);
  free (ret);
}

/* Read internal relocs for an XCOFF csect.  This is a wrapper around
   _bfd_coff_read_internal_relocs which tries to take advantage of any
   relocs which may have been cached for the enclosing section.  */

static struct internal_reloc *
xcoff_read_internal_relocs (abfd, sec, cache, external_relocs,
			    require_internal, internal_relocs)
     bfd *abfd;
     asection *sec;
     bfd_boolean cache;
     bfd_byte *external_relocs;
     bfd_boolean require_internal;
     struct internal_reloc *internal_relocs;
{

  if (coff_section_data (abfd, sec) != NULL
      && coff_section_data (abfd, sec)->relocs == NULL
      && xcoff_section_data (abfd, sec) != NULL)
    {
      asection *enclosing;

      enclosing = xcoff_section_data (abfd, sec)->enclosing;

      if (enclosing != NULL
	  && (coff_section_data (abfd, enclosing) == NULL
	      || coff_section_data (abfd, enclosing)->relocs == NULL)
	  && cache
	  && enclosing->reloc_count > 0)
	{
	  if (_bfd_coff_read_internal_relocs (abfd, enclosing, TRUE,
					      external_relocs, FALSE,
					      (struct internal_reloc *) NULL)
	      == NULL)
	    return NULL;
	}

      if (enclosing != NULL
	  && coff_section_data (abfd, enclosing) != NULL
	  && coff_section_data (abfd, enclosing)->relocs != NULL)
	{
	  size_t off;

	  off = ((sec->rel_filepos - enclosing->rel_filepos)
		 / bfd_coff_relsz (abfd));

	  if (! require_internal)
	    return coff_section_data (abfd, enclosing)->relocs + off;
	  memcpy (internal_relocs,
		  coff_section_data (abfd, enclosing)->relocs + off,
		  sec->reloc_count * sizeof (struct internal_reloc));
	  return internal_relocs;
	}
    }

  return _bfd_coff_read_internal_relocs (abfd, sec, cache, external_relocs,
					 require_internal, internal_relocs);
}

/* Given an XCOFF BFD, add symbols to the global hash table as
   appropriate.  */

bfd_boolean
_bfd_xcoff_bfd_link_add_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{

  switch (bfd_get_format (abfd))
    {
    case bfd_object:
      return xcoff_link_add_object_symbols (abfd, info);

    case bfd_archive:
      /* If the archive has a map, do the usual search.  We then need
	 to check the archive for dynamic objects, because they may not
	 appear in the archive map even though they should, perhaps, be
	 included.  If the archive has no map, we just consider each object
	 file in turn, since that apparently is what the AIX native linker
	 does.  */
      if (bfd_has_map (abfd))
	{
	  if (! (_bfd_generic_link_add_archive_symbols
		 (abfd, info, xcoff_link_check_archive_element)))
	    return FALSE;
	}

      {
	bfd *member;

	member = bfd_openr_next_archived_file (abfd, (bfd *) NULL);
	while (member != NULL)
	  {
	    if (bfd_check_format (member, bfd_object)
		&& (info->hash->creator == member->xvec)
		&& (! bfd_has_map (abfd) || (member->flags & DYNAMIC) != 0))
	      {
		bfd_boolean needed;

		if (! xcoff_link_check_archive_element (member, info,
							&needed))
		  return FALSE;
		if (needed)
		  member->archive_pass = -1;
	      }
	    member = bfd_openr_next_archived_file (abfd, member);
	  }
      }

      return TRUE;

    default:
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }
}

/* Add symbols from an XCOFF object file.  */

static bfd_boolean
xcoff_link_add_object_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{

  if (! _bfd_coff_get_external_symbols (abfd))
    return FALSE;
  if (! xcoff_link_add_symbols (abfd, info))
    return FALSE;
  if (! info->keep_memory)
    {
      if (! _bfd_coff_free_symbols (abfd))
	return FALSE;
    }
  return TRUE;
}

/* Check a single archive element to see if we need to include it in
   the link.  *PNEEDED is set according to whether this element is
   needed in the link or not.  This is called via
   _bfd_generic_link_add_archive_symbols.  */

static bfd_boolean
xcoff_link_check_archive_element (abfd, info, pneeded)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean *pneeded;
{

  if (! _bfd_coff_get_external_symbols (abfd))
    return FALSE;

  if (! xcoff_link_check_ar_symbols (abfd, info, pneeded))
    return FALSE;

  if (*pneeded)
    {
      if (! xcoff_link_add_symbols (abfd, info))
	return FALSE;
    }

  if (! info->keep_memory || ! *pneeded)
    {
      if (! _bfd_coff_free_symbols (abfd))
	return FALSE;
    }

  return TRUE;
}

/* Look through the symbols to see if this object file should be
   included in the link.  */

static bfd_boolean
xcoff_link_check_ar_symbols (abfd, info, pneeded)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean *pneeded;
{
  bfd_size_type symesz;
  bfd_byte *esym;
  bfd_byte *esym_end;

  *pneeded = FALSE;

  if ((abfd->flags & DYNAMIC) != 0
      && ! info->static_link
      && info->hash->creator == abfd->xvec)
    return xcoff_link_check_dynamic_ar_symbols (abfd, info, pneeded);

  symesz = bfd_coff_symesz (abfd);
  esym = (bfd_byte *) obj_coff_external_syms (abfd);
  esym_end = esym + obj_raw_syment_count (abfd) * symesz;
  while (esym < esym_end)
    {
      struct internal_syment sym;

      bfd_coff_swap_sym_in (abfd, (PTR) esym, (PTR) &sym);

      if (sym.n_sclass == C_EXT && sym.n_scnum != N_UNDEF)
	{
	  const char *name;
	  char buf[SYMNMLEN + 1];
	  struct bfd_link_hash_entry *h;

	  /* This symbol is externally visible, and is defined by this
	     object file.  */

	  name = _bfd_coff_internal_syment_name (abfd, &sym, buf);

	  if (name == NULL)
	    return FALSE;
	  h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);

	  /* We are only interested in symbols that are currently
	     undefined.  If a symbol is currently known to be common,
	     XCOFF linkers do not bring in an object file which
	     defines it.  We also don't bring in symbols to satisfy
	     undefined references in shared objects.  */
	  if (h != (struct bfd_link_hash_entry *) NULL
	      && h->type == bfd_link_hash_undefined
 	      && (info->hash->creator != abfd->xvec
		  || (((struct xcoff_link_hash_entry *) h)->flags
		      & XCOFF_DEF_DYNAMIC) == 0))
	    {
	      if (! (*info->callbacks->add_archive_element) (info, abfd, name))
		return FALSE;
	      *pneeded = TRUE;
	      return TRUE;
	    }
	}

      esym += (sym.n_numaux + 1) * symesz;
    }

  /* We do not need this object file.  */
  return TRUE;
}

/* Look through the loader symbols to see if this dynamic object
   should be included in the link.  The native linker uses the loader
   symbols, not the normal symbol table, so we do too.  */

static bfd_boolean
xcoff_link_check_dynamic_ar_symbols (abfd, info, pneeded)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean *pneeded;
{
  asection *lsec;
  bfd_byte *contents;
  struct internal_ldhdr ldhdr;
  const char *strings;
  bfd_byte *elsym, *elsymend;

  *pneeded = FALSE;

  lsec = bfd_get_section_by_name (abfd, ".loader");
  if (lsec == NULL)
    {
      /* There are no symbols, so don't try to include it.  */
      return TRUE;
    }

  if (! xcoff_get_section_contents (abfd, lsec))
    return FALSE;
  contents = coff_section_data (abfd, lsec)->contents;

  bfd_xcoff_swap_ldhdr_in (abfd, contents, &ldhdr);

  strings = (char *) contents + ldhdr.l_stoff;

  elsym = contents + bfd_xcoff_loader_symbol_offset(abfd, &ldhdr);

  elsymend = elsym + ldhdr.l_nsyms * bfd_xcoff_ldsymsz(abfd);
  for (; elsym < elsymend; elsym += bfd_xcoff_ldsymsz(abfd))
    {
      struct internal_ldsym ldsym;
      char nambuf[SYMNMLEN + 1];
      const char *name;
      struct bfd_link_hash_entry *h;

      bfd_xcoff_swap_ldsym_in (abfd, elsym, &ldsym);

      /* We are only interested in exported symbols.  */
      if ((ldsym.l_smtype & L_EXPORT) == 0)
	continue;

      if (ldsym._l._l_l._l_zeroes == 0)
	name = strings + ldsym._l._l_l._l_offset;
      else
	{
	  memcpy (nambuf, ldsym._l._l_name, SYMNMLEN);
	  nambuf[SYMNMLEN] = '\0';
	  name = nambuf;
	}

      h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);

      /* We are only interested in symbols that are currently
	 undefined.  At this point we know that we are using an XCOFF
	 hash table.  */
      if (h != NULL
	  && h->type == bfd_link_hash_undefined
	  && (((struct xcoff_link_hash_entry *) h)->flags
	      & XCOFF_DEF_DYNAMIC) == 0)
	{
	  if (! (*info->callbacks->add_archive_element) (info, abfd, name))
	    return FALSE;
	  *pneeded = TRUE;
	  return TRUE;
	}
    }

  /* We do not need this shared object.  */

  if (contents != NULL && ! coff_section_data (abfd, lsec)->keep_contents)
    {
      free (coff_section_data (abfd, lsec)->contents);
      coff_section_data (abfd, lsec)->contents = NULL;
    }

  return TRUE;
}

/* Returns the index of reloc in RELOCS with the least address greater
   than or equal to ADDRESS.  The relocs are sorted by address.  */

static bfd_size_type
xcoff_find_reloc (relocs, count, address)
     struct internal_reloc *relocs;
     bfd_size_type count;
     bfd_vma address;
{
  bfd_size_type min, max, this;

  if (count < 2)
    {
      if (count == 1 && relocs[0].r_vaddr < address)
	return 1;
      else
	return 0;
    }

  min = 0;
  max = count;

  /* Do a binary search over (min,max].  */
  while (min + 1 < max)
    {
      bfd_vma raddr;

      this = (max + min) / 2;
      raddr = relocs[this].r_vaddr;
      if (raddr > address)
	max = this;
      else if (raddr < address)
	min = this;
      else
	{
	  min = this;
	  break;
	}
    }

  if (relocs[min].r_vaddr < address)
    return min + 1;

  while (min > 0
	 && relocs[min - 1].r_vaddr == address)
    --min;

  return min;
}


/* xcoff_link_create_extra_sections

   Takes care of creating the .loader, .gl, .ds, .debug and sections.  */

static bfd_boolean
xcoff_link_create_extra_sections(bfd * abfd, struct bfd_link_info *info)
{

  bfd_boolean return_value = FALSE;

  if (info->hash->creator == abfd->xvec)
    {

      /* We need to build a .loader section, so we do it here.  This
	 won't work if we're producing an XCOFF output file with no
	 XCOFF input files.  FIXME.  */

      if (xcoff_hash_table (info)->loader_section == NULL)
	{
	  asection *lsec;

	  lsec = bfd_make_section_anyway (abfd, ".loader");
	  if (lsec == NULL)
	    {
	      goto end_return;
	    }
	  xcoff_hash_table (info)->loader_section = lsec;
	  lsec->flags |= SEC_HAS_CONTENTS | SEC_IN_MEMORY;
	}

      /* Likewise for the linkage section.  */
      if (xcoff_hash_table (info)->linkage_section == NULL)
	{
	  asection *lsec;

	  lsec = bfd_make_section_anyway (abfd, ".gl");
	  if (lsec == NULL)
	    {
	      goto end_return;
	    }

	  xcoff_hash_table (info)->linkage_section = lsec;
	  lsec->flags |= (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			  | SEC_IN_MEMORY);
	  lsec->alignment_power = 2;
	}

      /* Likewise for the TOC section.  */
      if (xcoff_hash_table (info)->toc_section == NULL)
	{
	  asection *tsec;

	  tsec = bfd_make_section_anyway (abfd, ".tc");
	  if (tsec == NULL)
	    {
	      goto end_return;
	    }

	  xcoff_hash_table (info)->toc_section = tsec;
	  tsec->flags |= (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			  | SEC_IN_MEMORY);
	  tsec->alignment_power = 2;
	}

      /* Likewise for the descriptor section.  */
      if (xcoff_hash_table (info)->descriptor_section == NULL)
	{
	  asection *dsec;

	  dsec = bfd_make_section_anyway (abfd, ".ds");
	  if (dsec == NULL)
	    {
	      goto end_return;
	    }

	  xcoff_hash_table (info)->descriptor_section = dsec;
	  dsec->flags |= (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			  | SEC_IN_MEMORY);
	  dsec->alignment_power = 2;
	}

      /* Likewise for the .debug section.  */
      if (xcoff_hash_table (info)->debug_section == NULL
	  && info->strip != strip_all)
	{
	  asection *dsec;

	  dsec = bfd_make_section_anyway (abfd, ".debug");
	  if (dsec == NULL)
	    {
	      goto end_return;
	    }
	  xcoff_hash_table (info)->debug_section = dsec;
	  dsec->flags |= SEC_HAS_CONTENTS | SEC_IN_MEMORY;
	}
    }

  return_value = TRUE;

 end_return:

  return return_value;
}

/* Add all the symbols from an object file to the hash table.

   XCOFF is a weird format.  A normal XCOFF .o files will have three
   COFF sections--.text, .data, and .bss--but each COFF section will
   contain many csects.  These csects are described in the symbol
   table.  From the linker's point of view, each csect must be
   considered a section in its own right.  For example, a TOC entry is
   handled as a small XMC_TC csect.  The linker must be able to merge
   different TOC entries together, which means that it must be able to
   extract the XMC_TC csects from the .data section of the input .o
   file.

   From the point of view of our linker, this is, of course, a hideous
   nightmare.  We cope by actually creating sections for each csect,
   and discarding the original sections.  We then have to handle the
   relocation entries carefully, since the only way to tell which
   csect they belong to is to examine the address.  */

static bfd_boolean
xcoff_link_add_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  unsigned int n_tmask;
  unsigned int n_btshft;
  bfd_boolean default_copy;
  bfd_size_type symcount;
  struct xcoff_link_hash_entry **sym_hash;
  asection **csect_cache;
  bfd_size_type linesz;
  asection *o;
  asection *last_real;
  bfd_boolean keep_syms;
  asection *csect;
  unsigned int csect_index;
  asection *first_csect;
  bfd_size_type symesz;
  bfd_byte *esym;
  bfd_byte *esym_end;
  struct reloc_info_struct
  {
    struct internal_reloc *relocs;
    asection **csects;
    bfd_byte *linenos;
  } *reloc_info = NULL;
  bfd_size_type amt;

  keep_syms = obj_coff_keep_syms (abfd);

  if ((abfd->flags & DYNAMIC) != 0
      && ! info->static_link)
    {
      if (! xcoff_link_add_dynamic_symbols (abfd, info))
	return FALSE;
    }

  /* create the loader, toc, gl, ds and debug sections, if needed */
  if (! xcoff_link_create_extra_sections (abfd, info))
    goto error_return;

  if ((abfd->flags & DYNAMIC) != 0
      && ! info->static_link)
    return TRUE;

  n_tmask = coff_data (abfd)->local_n_tmask;
  n_btshft = coff_data (abfd)->local_n_btshft;

  /* Define macros so that ISFCN, et. al., macros work correctly.  */
#define N_TMASK n_tmask
#define N_BTSHFT n_btshft

  if (info->keep_memory)
    default_copy = FALSE;
  else
    default_copy = TRUE;

  symcount = obj_raw_syment_count (abfd);

  /* We keep a list of the linker hash table entries that correspond
     to each external symbol.  */
  amt = symcount * sizeof (struct xcoff_link_hash_entry *);
  sym_hash = (struct xcoff_link_hash_entry **) bfd_zalloc (abfd, amt);
  if (sym_hash == NULL && symcount != 0)
    goto error_return;
  coff_data (abfd)->sym_hashes = (struct coff_link_hash_entry **) sym_hash;

  /* Because of the weird stuff we are doing with XCOFF csects, we can
     not easily determine which section a symbol is in, so we store
     the information in the tdata for the input file.  */
  amt = symcount * sizeof (asection *);
  csect_cache = (asection **) bfd_zalloc (abfd, amt);
  if (csect_cache == NULL && symcount != 0)
    goto error_return;
  xcoff_data (abfd)->csects = csect_cache;

  /* While splitting sections into csects, we need to assign the
     relocs correctly.  The relocs and the csects must both be in
     order by VMA within a given section, so we handle this by
     scanning along the relocs as we process the csects.  We index
     into reloc_info using the section target_index.  */
  amt = abfd->section_count + 1;
  amt *= sizeof (struct reloc_info_struct);
  reloc_info = (struct reloc_info_struct *) bfd_zmalloc (amt);
  if (reloc_info == NULL)
    goto error_return;

  /* Read in the relocs and line numbers for each section.  */
  linesz = bfd_coff_linesz (abfd);
  last_real = NULL;
  for (o = abfd->sections; o != NULL; o = o->next)
    {

      last_real = o;
      if ((o->flags & SEC_RELOC) != 0)
	{

	  reloc_info[o->target_index].relocs =
	    xcoff_read_internal_relocs (abfd, o, TRUE, (bfd_byte *) NULL,
					FALSE, (struct internal_reloc *) NULL);
	  amt = o->reloc_count;
	  amt *= sizeof (asection *);
	  reloc_info[o->target_index].csects = (asection **) bfd_zmalloc (amt);
	  if (reloc_info[o->target_index].csects == NULL)
	    goto error_return;
	}

      if ((info->strip == strip_none || info->strip == strip_some)
	  && o->lineno_count > 0)
	{

	  bfd_byte *linenos;

	  amt = linesz * o->lineno_count;
	  linenos = (bfd_byte *) bfd_malloc (amt);
	  if (linenos == NULL)
	    goto error_return;
	  reloc_info[o->target_index].linenos = linenos;
	  if (bfd_seek (abfd, o->line_filepos, SEEK_SET) != 0
	      || bfd_bread (linenos, amt, abfd) != amt)
	    goto error_return;

	}
    }

  /* Don't let the linker relocation routines discard the symbols.  */
  obj_coff_keep_syms (abfd) = TRUE;

  csect = NULL;
  csect_index = 0;
  first_csect = NULL;

  symesz = bfd_coff_symesz (abfd);
  BFD_ASSERT (symesz == bfd_coff_auxesz (abfd));
  esym = (bfd_byte *) obj_coff_external_syms (abfd);
  esym_end = esym + symcount * symesz;

  while (esym < esym_end)
    {
      struct internal_syment sym;
      union internal_auxent aux;
      const char *name;
      char buf[SYMNMLEN + 1];
      int smtyp;
      flagword flags;
      asection *section;
      bfd_vma value;
      struct xcoff_link_hash_entry *set_toc;

      bfd_coff_swap_sym_in (abfd, (PTR) esym, (PTR) &sym);

      /* In this pass we are only interested in symbols with csect
	 information.  */
      if (sym.n_sclass != C_EXT && sym.n_sclass != C_HIDEXT)
	{

	  /* Set csect_cache,
	     Normally csect is a .pr, .rw  etc. created in the loop
	     If C_FILE or first time, handle special

	     Advance esym, sym_hash, csect_hash ptr's
	     Keep track of the last_symndx for the current file.  */
	  if (sym.n_sclass == C_FILE && csect != NULL)
	    {
	      xcoff_section_data (abfd, csect)->last_symndx =
		((esym
		  - (bfd_byte *) obj_coff_external_syms (abfd))
		 / symesz);
	      csect = NULL;
	    }

	  if (csect != NULL)
	    *csect_cache = csect;
	  else if (first_csect == NULL || sym.n_sclass == C_FILE)
	    *csect_cache = coff_section_from_bfd_index (abfd, sym.n_scnum);
	  else
	    *csect_cache = NULL;
	  esym += (sym.n_numaux + 1) * symesz;
	  sym_hash += sym.n_numaux + 1;
	  csect_cache += sym.n_numaux + 1;

	  continue;
	}

      name = _bfd_coff_internal_syment_name (abfd, &sym, buf);

      if (name == NULL)
	goto error_return;

      /* If this symbol has line number information attached to it,
	 and we're not stripping it, count the number of entries and
	 add them to the count for this csect.  In the final link pass
	 we are going to attach line number information by symbol,
	 rather than by section, in order to more easily handle
	 garbage collection.  */
      if ((info->strip == strip_none || info->strip == strip_some)
	  && sym.n_numaux > 1
	  && csect != NULL
	  && ISFCN (sym.n_type))
	{

	  union internal_auxent auxlin;

	  bfd_coff_swap_aux_in (abfd, (PTR) (esym + symesz),
				sym.n_type, sym.n_sclass,
				0, sym.n_numaux, (PTR) &auxlin);

	  if (auxlin.x_sym.x_fcnary.x_fcn.x_lnnoptr != 0)
	    {
	      asection *enclosing;
	      bfd_signed_vma linoff;

	      enclosing = xcoff_section_data (abfd, csect)->enclosing;
	      if (enclosing == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%s: `%s' has line numbers but no enclosing section"),
		     bfd_archive_filename (abfd), name);
		  bfd_set_error (bfd_error_bad_value);
		  goto error_return;
		}
	      linoff = (auxlin.x_sym.x_fcnary.x_fcn.x_lnnoptr
			- enclosing->line_filepos);
	      /* explicit cast to bfd_signed_vma for compiler */
	      if (linoff < (bfd_signed_vma) (enclosing->lineno_count * linesz))
		{
		  struct internal_lineno lin;
		  bfd_byte *linpstart;

		  linpstart = (reloc_info[enclosing->target_index].linenos
			       + linoff);
		  bfd_coff_swap_lineno_in (abfd, (PTR) linpstart, (PTR) &lin);
		  if (lin.l_lnno == 0
		      && ((bfd_size_type) lin.l_addr.l_symndx
			  == ((esym
			       - (bfd_byte *) obj_coff_external_syms (abfd))
			      / symesz)))
		    {
		      bfd_byte *linpend, *linp;

		      linpend = (reloc_info[enclosing->target_index].linenos
				 + enclosing->lineno_count * linesz);
		      for (linp = linpstart + linesz;
			   linp < linpend;
			   linp += linesz)
			{
			  bfd_coff_swap_lineno_in (abfd, (PTR) linp,
						   (PTR) &lin);
			  if (lin.l_lnno == 0)
			    break;
			}
		      csect->lineno_count += (linp - linpstart) / linesz;
		      /* The setting of line_filepos will only be
			 useful if all the line number entries for a
			 csect are contiguous; this only matters for
			 error reporting.  */
		      if (csect->line_filepos == 0)
			csect->line_filepos =
			  auxlin.x_sym.x_fcnary.x_fcn.x_lnnoptr;
		    }
		}
	    }
	}

      /* Pick up the csect auxiliary information.  */

      if (sym.n_numaux == 0)
	{
	  (*_bfd_error_handler)
	    (_("%s: class %d symbol `%s' has no aux entries"),
	     bfd_archive_filename (abfd), sym.n_sclass, name);
	  bfd_set_error (bfd_error_bad_value);
	  goto error_return;
	}

      bfd_coff_swap_aux_in (abfd,
			    (PTR) (esym + symesz * sym.n_numaux),
			    sym.n_type, sym.n_sclass,
			    sym.n_numaux - 1, sym.n_numaux,
			    (PTR) &aux);

      smtyp = SMTYP_SMTYP (aux.x_csect.x_smtyp);

      flags = BSF_GLOBAL;
      section = NULL;
      value = 0;
      set_toc = NULL;

      switch (smtyp)
	{
	default:
	  (*_bfd_error_handler)
	    (_("%s: symbol `%s' has unrecognized csect type %d"),
	     bfd_archive_filename (abfd), name, smtyp);
	  bfd_set_error (bfd_error_bad_value);
	  goto error_return;

	case XTY_ER:
	  /* This is an external reference.  */
	  if (sym.n_sclass == C_HIDEXT
	      || sym.n_scnum != N_UNDEF
	      || aux.x_csect.x_scnlen.l != 0)
	    {
	      (*_bfd_error_handler)
		(_("%s: bad XTY_ER symbol `%s': class %d scnum %d scnlen %d"),
		 bfd_archive_filename (abfd), name, sym.n_sclass, sym.n_scnum,
		 aux.x_csect.x_scnlen.l);
	      bfd_set_error (bfd_error_bad_value);
	      goto error_return;
	    }

	  /* An XMC_XO external reference is actually a reference to
	     an absolute location.  */
	  if (aux.x_csect.x_smclas != XMC_XO)
	    section = bfd_und_section_ptr;
	  else
	    {
	      section = bfd_abs_section_ptr;
	      value = sym.n_value;
	    }
	  break;

	case XTY_SD:
	  /* This is a csect definition.  */
	  if (csect != NULL)
	    {
	      xcoff_section_data (abfd, csect)->last_symndx =
		((esym - (bfd_byte *) obj_coff_external_syms (abfd)) / symesz);
	    }

	  csect = NULL;
	  csect_index = -(unsigned) 1;

	  /* When we see a TOC anchor, we record the TOC value.  */
	  if (aux.x_csect.x_smclas == XMC_TC0)
	    {
	      if (sym.n_sclass != C_HIDEXT
		  || aux.x_csect.x_scnlen.l != 0)
		{
		  (*_bfd_error_handler)
		    (_("%s: XMC_TC0 symbol `%s' is class %d scnlen %d"),
		     bfd_archive_filename (abfd), name, sym.n_sclass,
		     aux.x_csect.x_scnlen.l);
		  bfd_set_error (bfd_error_bad_value);
		  goto error_return;
		}
	      xcoff_data (abfd)->toc = sym.n_value;
	    }

	  /* We must merge TOC entries for the same symbol.  We can
	     merge two TOC entries if they are both C_HIDEXT, they
	     both have the same name, they are both 4 or 8 bytes long, and
	     they both have a relocation table entry for an external
	     symbol with the same name.  Unfortunately, this means
	     that we must look through the relocations.  Ick.

	     Logic for 32 bit vs 64 bit.
	     32 bit has a csect length of 4 for TOC
	     64 bit has a csect length of 8 for TOC

	     The conditions to get past the if-check are not that bad.
	     They are what is used to create the TOC csects in the first
	     place.  */
	  if (aux.x_csect.x_smclas == XMC_TC
	      && sym.n_sclass == C_HIDEXT
	      && info->hash->creator == abfd->xvec
	      && ((bfd_xcoff_is_xcoff32 (abfd)
		   && aux.x_csect.x_scnlen.l == 4)
		  || (bfd_xcoff_is_xcoff64 (abfd)
		      && aux.x_csect.x_scnlen.l == 8)))
	    {
	      asection *enclosing;
	      struct internal_reloc *relocs;
	      bfd_size_type relindx;
	      struct internal_reloc *rel;

	      enclosing = coff_section_from_bfd_index (abfd, sym.n_scnum);
	      if (enclosing == NULL)
		goto error_return;

	      relocs = reloc_info[enclosing->target_index].relocs;
	      amt = enclosing->reloc_count;
	      relindx = xcoff_find_reloc (relocs, amt, sym.n_value);
	      rel = relocs + relindx;

	      /* 32 bit R_POS r_size is 31
		 64 bit R_POS r_size is 63  */
	      if (relindx < enclosing->reloc_count
		  && rel->r_vaddr == (bfd_vma) sym.n_value
		  && rel->r_type == R_POS
		  && ((bfd_xcoff_is_xcoff32 (abfd)
		       && rel->r_size == 31)
		      || (bfd_xcoff_is_xcoff64 (abfd)
			  && rel->r_size == 63)))
		{
		  bfd_byte *erelsym;

		  struct internal_syment relsym;

		  erelsym = ((bfd_byte *) obj_coff_external_syms (abfd)
			     + rel->r_symndx * symesz);
		  bfd_coff_swap_sym_in (abfd, (PTR) erelsym, (PTR) &relsym);
		  if (relsym.n_sclass == C_EXT)
		    {
		      const char *relname;
		      char relbuf[SYMNMLEN + 1];
		      bfd_boolean copy;
		      struct xcoff_link_hash_entry *h;

		      /* At this point we know that the TOC entry is
			 for an externally visible symbol.  */

		      relname = _bfd_coff_internal_syment_name (abfd, &relsym,
								relbuf);
		      if (relname == NULL)
			goto error_return;

		      /* We only merge TOC entries if the TC name is
			 the same as the symbol name.  This handles
			 the normal case, but not common cases like
			 SYM.P4 which gcc generates to store SYM + 4
			 in the TOC.  FIXME.  */

		      if (strcmp (name, relname) == 0)
			{
			  copy = (! info->keep_memory
				  || relsym._n._n_n._n_zeroes != 0
				  || relsym._n._n_n._n_offset == 0);
			  h = xcoff_link_hash_lookup (xcoff_hash_table (info),
						      relname, TRUE, copy,
						      FALSE);
			  if (h == NULL)
			    goto error_return;

			  /* At this point h->root.type could be
			     bfd_link_hash_new.  That should be OK,
			     since we know for sure that we will come
			     across this symbol as we step through the
			     file.  */

			  /* We store h in *sym_hash for the
			     convenience of the relocate_section
			     function.  */
			  *sym_hash = h;

			  if (h->toc_section != NULL)
			    {
			      asection **rel_csects;

			      /* We already have a TOC entry for this
				 symbol, so we can just ignore this
				 one.  */
			      rel_csects =
				reloc_info[enclosing->target_index].csects;
			      rel_csects[relindx] = bfd_und_section_ptr;
			      break;
			    }

			  /* We are about to create a TOC entry for
			     this symbol.  */
			  set_toc = h;
			} /* merge toc reloc */
		    } /* c_ext */
		} /* reloc */
	    } /* merge toc */

	  {

	    asection *enclosing;

	    /* We need to create a new section.  We get the name from
	       the csect storage mapping class, so that the linker can
	       accumulate similar csects together.  */

	    csect = bfd_xcoff_create_csect_from_smclas(abfd, &aux, name);
	    if (NULL == csect)
	      {
		goto error_return;
	      }

	    /* The enclosing section is the main section : .data, .text
	       or .bss that the csect is coming from.  */
	    enclosing = coff_section_from_bfd_index (abfd, sym.n_scnum);
	    if (enclosing == NULL)
	      goto error_return;

	    if (! bfd_is_abs_section (enclosing)
		&& ((bfd_vma) sym.n_value < enclosing->vma
		    || ((bfd_vma) sym.n_value + aux.x_csect.x_scnlen.l
			> enclosing->vma + enclosing->_raw_size)))
	      {
		(*_bfd_error_handler)
		  (_("%s: csect `%s' not in enclosing section"),
		   bfd_archive_filename (abfd), name);
		bfd_set_error (bfd_error_bad_value);
		goto error_return;
	      }
	    csect->vma = sym.n_value;
	    csect->filepos = (enclosing->filepos
			      + sym.n_value
			      - enclosing->vma);
	    csect->_raw_size = aux.x_csect.x_scnlen.l;
	    csect->flags |= SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS;
	    csect->alignment_power = SMTYP_ALIGN (aux.x_csect.x_smtyp);

	    /* Record the enclosing section in the tdata for this new
	       section.  */
	    amt = sizeof (struct coff_section_tdata);
	    csect->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
	    if (csect->used_by_bfd == NULL)
	      goto error_return;
	    amt = sizeof (struct xcoff_section_tdata);
	    coff_section_data (abfd, csect)->tdata = bfd_zalloc (abfd, amt);
	    if (coff_section_data (abfd, csect)->tdata == NULL)
	      goto error_return;
	    xcoff_section_data (abfd, csect)->enclosing = enclosing;
	    xcoff_section_data (abfd, csect)->lineno_count =
	      enclosing->lineno_count;

	    if (enclosing->owner == abfd)
	      {
		struct internal_reloc *relocs;
		bfd_size_type relindx;
		struct internal_reloc *rel;
		asection **rel_csect;

		relocs = reloc_info[enclosing->target_index].relocs;
		amt = enclosing->reloc_count;
		relindx = xcoff_find_reloc (relocs, amt, csect->vma);

		rel = relocs + relindx;
		rel_csect = (reloc_info[enclosing->target_index].csects
			     + relindx);

		csect->rel_filepos = (enclosing->rel_filepos
				      + relindx * bfd_coff_relsz (abfd));
		while (relindx < enclosing->reloc_count
		       && *rel_csect == NULL
		       && rel->r_vaddr < csect->vma + csect->_raw_size)
		  {

		    *rel_csect = csect;
		    csect->flags |= SEC_RELOC;
		    ++csect->reloc_count;
		    ++relindx;
		    ++rel;
		    ++rel_csect;
		  }
	      }

	    /* There are a number of other fields and section flags
	       which we do not bother to set.  */

	    csect_index = ((esym
			    - (bfd_byte *) obj_coff_external_syms (abfd))
			   / symesz);

	    xcoff_section_data (abfd, csect)->first_symndx = csect_index;

	    if (first_csect == NULL)
	      first_csect = csect;

	    /* If this symbol is C_EXT, we treat it as starting at the
	       beginning of the newly created section.  */
	    if (sym.n_sclass == C_EXT)
	      {
		section = csect;
		value = 0;
	      }

	    /* If this is a TOC section for a symbol, record it.  */
	    if (set_toc != NULL)
	      set_toc->toc_section = csect;
	  }
	  break;

	case XTY_LD:
	  /* This is a label definition.  The x_scnlen field is the
	     symbol index of the csect.  Usually the XTY_LD symbol will
	     follow its appropriate XTY_SD symbol.  The .set pseudo op can
	     cause the XTY_LD to not follow the XTY_SD symbol. */
	  {
	    bfd_boolean bad;

	    bad = FALSE;
	    if (aux.x_csect.x_scnlen.l < 0
		|| (aux.x_csect.x_scnlen.l
		    >= esym - (bfd_byte *) obj_coff_external_syms (abfd)))
	      bad = TRUE;
	    if (! bad)
	      {
		section = xcoff_data (abfd)->csects[aux.x_csect.x_scnlen.l];
		if (section == NULL
		    || (section->flags & SEC_HAS_CONTENTS) == 0)
		  bad = TRUE;
	      }
	    if (bad)
	      {
		(*_bfd_error_handler)
		  (_("%s: misplaced XTY_LD `%s'"),
		   bfd_archive_filename (abfd), name);
		bfd_set_error (bfd_error_bad_value);
		goto error_return;
	      }
 	    csect = section;
	    value = sym.n_value - csect->vma;
	  }
	  break;

	case XTY_CM:
	  /* This is an unitialized csect.  We could base the name on
	     the storage mapping class, but we don't bother except for
	     an XMC_TD symbol.  If this csect is externally visible,
	     it is a common symbol.  We put XMC_TD symbols in sections
	     named .tocbss, and rely on the linker script to put that
	     in the TOC area.  */

	  if (csect != NULL)
	    {
	      xcoff_section_data (abfd, csect)->last_symndx =
		((esym
		  - (bfd_byte *) obj_coff_external_syms (abfd))
		 / symesz);
	    }

	  if (aux.x_csect.x_smclas == XMC_TD)
	    {
	      /* The linker script puts the .td section in the data
		 section after the .tc section.  */
	      csect = bfd_make_section_anyway (abfd, ".td");

	    }
	  else
	    {
	      csect = bfd_make_section_anyway (abfd, ".bss");
	    }
	  if (csect == NULL)
	    goto error_return;
	  csect->vma = sym.n_value;
	  csect->_raw_size = aux.x_csect.x_scnlen.l;
	  csect->flags |= SEC_ALLOC;
	  csect->alignment_power = SMTYP_ALIGN (aux.x_csect.x_smtyp);
	  /* There are a number of other fields and section flags
	     which we do not bother to set.  */

	  csect_index = ((esym
			  - (bfd_byte *) obj_coff_external_syms (abfd))
			 / symesz);

	  amt = sizeof (struct coff_section_tdata);
	  csect->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
	  if (csect->used_by_bfd == NULL)
	    goto error_return;
	  amt = sizeof (struct xcoff_section_tdata);
	  coff_section_data (abfd, csect)->tdata = bfd_zalloc (abfd, amt);
	  if (coff_section_data (abfd, csect)->tdata == NULL)
	    goto error_return;
	  xcoff_section_data (abfd, csect)->first_symndx = csect_index;

	  if (first_csect == NULL)
	    first_csect = csect;

	  if (sym.n_sclass == C_EXT)
	    {
	      csect->flags |= SEC_IS_COMMON;
	      csect->_raw_size = 0;
	      section = csect;
	      value = aux.x_csect.x_scnlen.l;
	    }

	  break;
	}

      /* Check for magic symbol names.  */
      if ((smtyp == XTY_SD || smtyp == XTY_CM)
	  && aux.x_csect.x_smclas != XMC_TC
	  && aux.x_csect.x_smclas != XMC_TD)
	{

	  int i = -1;

	  if (name[0] == '_')
	    {
	      if (strcmp (name, "_text") == 0)
		i = XCOFF_SPECIAL_SECTION_TEXT;
	      else if (strcmp (name, "_etext") == 0)
		i = XCOFF_SPECIAL_SECTION_ETEXT;
	      else if (strcmp (name, "_data") == 0)
		i = XCOFF_SPECIAL_SECTION_DATA;
	      else if (strcmp (name, "_edata") == 0)
		i = XCOFF_SPECIAL_SECTION_EDATA;
	      else if (strcmp (name, "_end") == 0)
		i = XCOFF_SPECIAL_SECTION_END;
	    }
	  else if (name[0] == 'e' && strcmp (name, "end") == 0)
	    {
	      i = XCOFF_SPECIAL_SECTION_END2;
	    }

	  if (i != -1)
	    {
	      xcoff_hash_table (info)->special_sections[i] = csect;
	    }
	}

      /* Now we have enough information to add the symbol to the
	 linker hash table.  */

      if (sym.n_sclass == C_EXT)
	{
	  bfd_boolean copy;

	  BFD_ASSERT (section != NULL);

	  /* We must copy the name into memory if we got it from the
	     syment itself, rather than the string table.  */
	  copy = default_copy;
	  if (sym._n._n_n._n_zeroes != 0
	      || sym._n._n_n._n_offset == 0)
	    copy = TRUE;

	  /* The AIX linker appears to only detect multiple symbol
	     definitions when there is a reference to the symbol.  If
	     a symbol is defined multiple times, and the only
	     references are from the same object file, the AIX linker
	     appears to permit it.  It does not merge the different
	     definitions, but handles them independently.  On the
	     other hand, if there is a reference, the linker reports
	     an error.

	     This matters because the AIX <net/net_globals.h> header
	     file actually defines an initialized array, so we have to
	     actually permit that to work.

	     Just to make matters even more confusing, the AIX linker
	     appears to permit multiple symbol definitions whenever
	     the second definition is in an archive rather than an
	     object file.  This may be a consequence of the manner in
	     which it handles archives: I think it may load the entire
	     archive in as separate csects, and then let garbage
	     collection discard symbols.

	     We also have to handle the case of statically linking a
	     shared object, which will cause symbol redefinitions,
	     although this is an easier case to detect.  */

 	  if (info->hash->creator == abfd->xvec)
	    {
	      if (! bfd_is_und_section (section))
		{
		  *sym_hash = xcoff_link_hash_lookup (xcoff_hash_table (info),
						      name, TRUE, copy, FALSE);
		}
	      else
		{
		  /* Make a copy of the symbol name to prevent problems with
		     merging symbols.  */
		  *sym_hash = ((struct xcoff_link_hash_entry *)
			       bfd_wrapped_link_hash_lookup (abfd, info, name,
							     TRUE, TRUE,
							     FALSE));
		}
	      if (*sym_hash == NULL)
		goto error_return;
	      if (((*sym_hash)->root.type == bfd_link_hash_defined
		   || (*sym_hash)->root.type == bfd_link_hash_defweak)
		  && ! bfd_is_und_section (section)
		  && ! bfd_is_com_section (section))
		{
		  /* This is a second definition of a defined symbol.  */
		  if ((abfd->flags & DYNAMIC) != 0
		      && ((*sym_hash)->smclas != XMC_GL
			  || aux.x_csect.x_smclas == XMC_GL
			  || ((*sym_hash)->root.u.def.section->owner->flags
			      & DYNAMIC) == 0))
		    {
		      /* The new symbol is from a shared library, and
			 either the existing symbol is not global
			 linkage code or this symbol is global linkage
			 code.  If the existing symbol is global
			 linkage code and the new symbol is not, then
			 we want to use the new symbol.  */
		      section = bfd_und_section_ptr;
		      value = 0;
		    }
		  else if (((*sym_hash)->root.u.def.section->owner->flags
			    & DYNAMIC) != 0)
		    {
		      /* The existing symbol is from a shared library.
			 Replace it.  */
		      (*sym_hash)->root.type = bfd_link_hash_undefined;
		      (*sym_hash)->root.u.undef.abfd =
			(*sym_hash)->root.u.def.section->owner;
		    }
		  else if (abfd->my_archive != NULL)
		    {
		      /* This is a redefinition in an object contained
			 in an archive.  Just ignore it.  See the
			 comment above.  */
		      section = bfd_und_section_ptr;
		      value = 0;
		    }
		  else if ((*sym_hash)->root.und_next != NULL
			   || info->hash->undefs_tail == &(*sym_hash)->root)
		    {
		      /* This symbol has been referenced.  In this
			 case, we just continue and permit the
			 multiple definition error.  See the comment
			 above about the behaviour of the AIX linker.  */
		    }
		  else if ((*sym_hash)->smclas == aux.x_csect.x_smclas)
		    {
		      /* The symbols are both csects of the same
			 class.  There is at least a chance that this
			 is a semi-legitimate redefinition.  */
		      section = bfd_und_section_ptr;
		      value = 0;
		      (*sym_hash)->flags |= XCOFF_MULTIPLY_DEFINED;
		    }
		}
	      else if (((*sym_hash)->flags & XCOFF_MULTIPLY_DEFINED) != 0
		       && ((*sym_hash)->root.type == bfd_link_hash_defined
			   || (*sym_hash)->root.type == bfd_link_hash_defweak)
		       && (bfd_is_und_section (section)
			   || bfd_is_com_section (section)))
		{
		  /* This is a reference to a multiply defined symbol.
		     Report the error now.  See the comment above
		     about the behaviour of the AIX linker.  We could
		     also do this with warning symbols, but I'm not
		     sure the XCOFF linker is wholly prepared to
		     handle them, and that would only be a warning,
		     not an error.  */
		  if (! ((*info->callbacks->multiple_definition)
			 (info, (*sym_hash)->root.root.string,
			  (bfd *) NULL, (asection *) NULL, (bfd_vma) 0,
			  (*sym_hash)->root.u.def.section->owner,
			  (*sym_hash)->root.u.def.section,
			  (*sym_hash)->root.u.def.value)))
		    goto error_return;
		  /* Try not to give this error too many times.  */
		  (*sym_hash)->flags &= ~XCOFF_MULTIPLY_DEFINED;
		}
	    }

	  /* _bfd_generic_link_add_one_symbol may call the linker to
	     generate an error message, and the linker may try to read
	     the symbol table to give a good error.  Right now, the
	     line numbers are in an inconsistent state, since they are
	     counted both in the real sections and in the new csects.
	     We need to leave the count in the real sections so that
	     the linker can report the line number of the error
	     correctly, so temporarily clobber the link to the csects
	     so that the linker will not try to read the line numbers
	     a second time from the csects.  */
	  BFD_ASSERT (last_real->next == first_csect);
	  last_real->next = NULL;
	  if (! (_bfd_generic_link_add_one_symbol
		 (info, abfd, name, flags, section, value,
		  (const char *) NULL, copy, TRUE,
		  (struct bfd_link_hash_entry **) sym_hash)))
	    goto error_return;
	  last_real->next = first_csect;

	  if (smtyp == XTY_CM)
	    {
	      if ((*sym_hash)->root.type != bfd_link_hash_common
		  || (*sym_hash)->root.u.c.p->section != csect)
		{
		  /* We don't need the common csect we just created.  */
		  csect->_raw_size = 0;
		}
	      else
		{
		  (*sym_hash)->root.u.c.p->alignment_power
		    = csect->alignment_power;
		}
	    }

 	  if (info->hash->creator == abfd->xvec)
	    {
	      int flag;

	      if (smtyp == XTY_ER || smtyp == XTY_CM)
		flag = XCOFF_REF_REGULAR;
	      else
		flag = XCOFF_DEF_REGULAR;
	      (*sym_hash)->flags |= flag;

	      if ((*sym_hash)->smclas == XMC_UA
		  || flag == XCOFF_DEF_REGULAR)
		(*sym_hash)->smclas = aux.x_csect.x_smclas;
	    }
	}

      *csect_cache = csect;

      esym += (sym.n_numaux + 1) * symesz;
      sym_hash += sym.n_numaux + 1;
      csect_cache += sym.n_numaux + 1;
    }

  BFD_ASSERT (last_real == NULL || last_real->next == first_csect);

  /* Make sure that we have seen all the relocs.  */
  for (o = abfd->sections; o != first_csect; o = o->next)
    {
      /* Reset the section size and the line number count, since the
	 data is now attached to the csects.  Don't reset the size of
	 the .debug section, since we need to read it below in
	 bfd_xcoff_size_dynamic_sections.  */
      if (strcmp (bfd_get_section_name (abfd, o), ".debug") != 0)
	o->_raw_size = 0;
      o->lineno_count = 0;

      if ((o->flags & SEC_RELOC) != 0)
	{
	  bfd_size_type i;
	  struct internal_reloc *rel;
	  asection **rel_csect;

	  rel = reloc_info[o->target_index].relocs;
	  rel_csect = reloc_info[o->target_index].csects;

	  for (i = 0; i < o->reloc_count; i++, rel++, rel_csect++)
	    {

	      if (*rel_csect == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%s: reloc %s:%d not in csect"),
		     bfd_archive_filename (abfd), o->name, i);
		  bfd_set_error (bfd_error_bad_value);
		  goto error_return;
		}

	      /* We identify all symbols which are called, so that we
		 can create glue code for calls to functions imported
		 from dynamic objects.  */
 	      if (info->hash->creator == abfd->xvec
		  && *rel_csect != bfd_und_section_ptr
		  && (rel->r_type == R_BR
		      || rel->r_type == R_RBR)
		  && obj_xcoff_sym_hashes (abfd)[rel->r_symndx] != NULL)
		{
		  struct xcoff_link_hash_entry *h;

		  h = obj_xcoff_sym_hashes (abfd)[rel->r_symndx];
		  h->flags |= XCOFF_CALLED;
		  /* If the symbol name starts with a period, it is
		     the code of a function.  If the symbol is
		     currently undefined, then add an undefined symbol
		     for the function descriptor.  This should do no
		     harm, because any regular object that defines the
		     function should also define the function
		     descriptor.  It helps, because it means that we
		     will identify the function descriptor with a
		     dynamic object if a dynamic object defines it.  */
		  if (h->root.root.string[0] == '.'
		      && h->descriptor == NULL)
		    {
		      struct xcoff_link_hash_entry *hds;
		      struct bfd_link_hash_entry *bh;

		      hds = xcoff_link_hash_lookup (xcoff_hash_table (info),
						    h->root.root.string + 1,
						    TRUE, FALSE, TRUE);
		      if (hds == NULL)
			goto error_return;
		      if (hds->root.type == bfd_link_hash_new)
			{
			  bh = &hds->root;
			  if (! (_bfd_generic_link_add_one_symbol
				 (info, abfd, hds->root.root.string,
				  (flagword) 0, bfd_und_section_ptr,
				  (bfd_vma) 0, (const char *) NULL, FALSE,
				  TRUE, &bh)))
			    goto error_return;
			  hds = (struct xcoff_link_hash_entry *) bh;
			}
		      hds->flags |= XCOFF_DESCRIPTOR;
		      BFD_ASSERT ((hds->flags & XCOFF_CALLED) == 0
				  && (h->flags & XCOFF_DESCRIPTOR) == 0);
		      hds->descriptor = h;
		      h->descriptor = hds;
		    }
		}
	    }

	  free (reloc_info[o->target_index].csects);
	  reloc_info[o->target_index].csects = NULL;

	  /* Reset SEC_RELOC and the reloc_count, since the reloc
	     information is now attached to the csects.  */
	  o->flags &=~ SEC_RELOC;
	  o->reloc_count = 0;

	  /* If we are not keeping memory, free the reloc information.  */
	  if (! info->keep_memory
	      && coff_section_data (abfd, o) != NULL
	      && coff_section_data (abfd, o)->relocs != NULL
	      && ! coff_section_data (abfd, o)->keep_relocs)
	    {
	      free (coff_section_data (abfd, o)->relocs);
	      coff_section_data (abfd, o)->relocs = NULL;
	    }
	}

      /* Free up the line numbers.  FIXME: We could cache these
	 somewhere for the final link, to avoid reading them again.  */
      if (reloc_info[o->target_index].linenos != NULL)
	{
	  free (reloc_info[o->target_index].linenos);
	  reloc_info[o->target_index].linenos = NULL;
	}
    }

  free (reloc_info);

  obj_coff_keep_syms (abfd) = keep_syms;

  return TRUE;

 error_return:
  if (reloc_info != NULL)
    {
      for (o = abfd->sections; o != NULL; o = o->next)
	{
	  if (reloc_info[o->target_index].csects != NULL)
	    free (reloc_info[o->target_index].csects);
	  if (reloc_info[o->target_index].linenos != NULL)
	    free (reloc_info[o->target_index].linenos);
	}
      free (reloc_info);
    }
  obj_coff_keep_syms (abfd) = keep_syms;
  return FALSE;
}

#undef N_TMASK
#undef N_BTSHFT

/* This function is used to add symbols from a dynamic object to the
   global symbol table.  */

static bfd_boolean
xcoff_link_add_dynamic_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  asection *lsec;
  bfd_byte *contents;
  struct internal_ldhdr ldhdr;
  const char *strings;
  bfd_byte *elsym, *elsymend;
  struct xcoff_import_file *n;
  const char *bname;
  const char *mname;
  const char *s;
  unsigned int c;
  struct xcoff_import_file **pp;

  /* We can only handle a dynamic object if we are generating an XCOFF
     output file.  */
   if (info->hash->creator != abfd->xvec)
    {
      (*_bfd_error_handler)
	(_("%s: XCOFF shared object when not producing XCOFF output"),
	 bfd_get_filename (abfd));
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  /* The symbols we use from a dynamic object are not the symbols in
     the normal symbol table, but, rather, the symbols in the export
     table.  If there is a global symbol in a dynamic object which is
     not in the export table, the loader will not be able to find it,
     so we don't want to find it either.  Also, on AIX 4.1.3, shr.o in
     libc.a has symbols in the export table which are not in the
     symbol table.  */

  /* Read in the .loader section.  FIXME: We should really use the
     o_snloader field in the a.out header, rather than grabbing the
     section by name.  */
  lsec = bfd_get_section_by_name (abfd, ".loader");
  if (lsec == NULL)
    {
      (*_bfd_error_handler)
	(_("%s: dynamic object with no .loader section"),
	 bfd_get_filename (abfd));
      bfd_set_error (bfd_error_no_symbols);
      return FALSE;
    }


  if (! xcoff_get_section_contents (abfd, lsec))
    return FALSE;
  contents = coff_section_data (abfd, lsec)->contents;

  /* Remove the sections from this object, so that they do not get
     included in the link.  */
  bfd_section_list_clear (abfd);

  bfd_xcoff_swap_ldhdr_in (abfd, contents, &ldhdr);

  strings = (char *) contents + ldhdr.l_stoff;

  elsym = contents + bfd_xcoff_loader_symbol_offset(abfd, &ldhdr);

  elsymend = elsym + ldhdr.l_nsyms * bfd_xcoff_ldsymsz(abfd);

  for (; elsym < elsymend; elsym += bfd_xcoff_ldsymsz(abfd))
    {
      struct internal_ldsym ldsym;
      char nambuf[SYMNMLEN + 1];
      const char *name;
      struct xcoff_link_hash_entry *h;

      bfd_xcoff_swap_ldsym_in (abfd, elsym, &ldsym);

      /* We are only interested in exported symbols.  */
      if ((ldsym.l_smtype & L_EXPORT) == 0)
	continue;

      if (ldsym._l._l_l._l_zeroes == 0)
	name = strings + ldsym._l._l_l._l_offset;
      else
	{
	  memcpy (nambuf, ldsym._l._l_name, SYMNMLEN);
	  nambuf[SYMNMLEN] = '\0';
	  name = nambuf;
	}

      /* Normally we could not call xcoff_link_hash_lookup in an add
	 symbols routine, since we might not be using an XCOFF hash
	 table.  However, we verified above that we are using an XCOFF
	 hash table.  */

      h = xcoff_link_hash_lookup (xcoff_hash_table (info), name, TRUE,
				  TRUE, TRUE);
      if (h == NULL)
	return FALSE;

      h->flags |= XCOFF_DEF_DYNAMIC;

      /* If the symbol is undefined, and the BFD it was found in is
	 not a dynamic object, change the BFD to this dynamic object,
	 so that we can get the correct import file ID.  */
      if ((h->root.type == bfd_link_hash_undefined
	   || h->root.type == bfd_link_hash_undefweak)
	  && (h->root.u.undef.abfd == NULL
	      || (h->root.u.undef.abfd->flags & DYNAMIC) == 0))
	h->root.u.undef.abfd = abfd;

      if (h->root.type == bfd_link_hash_new)
	{
	  h->root.type = bfd_link_hash_undefined;
	  h->root.u.undef.abfd = abfd;
	  /* We do not want to add this to the undefined symbol list.  */
	}

      if (h->smclas == XMC_UA
	  || h->root.type == bfd_link_hash_undefined
	  || h->root.type == bfd_link_hash_undefweak)
	h->smclas = ldsym.l_smclas;

      /* Unless this is an XMC_XO symbol, we don't bother to actually
	 define it, since we don't have a section to put it in anyhow.
	 Instead, the relocation routines handle the DEF_DYNAMIC flag
	 correctly.  */

      if (h->smclas == XMC_XO
	  && (h->root.type == bfd_link_hash_undefined
	      || h->root.type == bfd_link_hash_undefweak))
	{
	  /* This symbol has an absolute value.  */
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.section = bfd_abs_section_ptr;
	  h->root.u.def.value = ldsym.l_value;
	}

      /* If this symbol defines a function descriptor, then it
	 implicitly defines the function code as well.  */
      if (h->smclas == XMC_DS
	  || (h->smclas == XMC_XO && name[0] != '.'))
	h->flags |= XCOFF_DESCRIPTOR;
      if ((h->flags & XCOFF_DESCRIPTOR) != 0)
	{
	  struct xcoff_link_hash_entry *hds;

	  hds = h->descriptor;
	  if (hds == NULL)
	    {
	      char *dsnm;

	      dsnm = bfd_malloc ((bfd_size_type) strlen (name) + 2);
	      if (dsnm == NULL)
		return FALSE;
	      dsnm[0] = '.';
	      strcpy (dsnm + 1, name);
	      hds = xcoff_link_hash_lookup (xcoff_hash_table (info), dsnm,
					    TRUE, TRUE, TRUE);
	      free (dsnm);
	      if (hds == NULL)
		return FALSE;

	      if (hds->root.type == bfd_link_hash_new)
		{
		  hds->root.type = bfd_link_hash_undefined;
		  hds->root.u.undef.abfd = abfd;
		  /* We do not want to add this to the undefined
		     symbol list.  */
		}

	      hds->descriptor = h;
	      h->descriptor = hds;
	    }

	  hds->flags |= XCOFF_DEF_DYNAMIC;
	  if (hds->smclas == XMC_UA)
	    hds->smclas = XMC_PR;

	  /* An absolute symbol appears to actually define code, not a
	     function descriptor.  This is how some math functions are
	     implemented on AIX 4.1.  */
	  if (h->smclas == XMC_XO
	      && (hds->root.type == bfd_link_hash_undefined
		  || hds->root.type == bfd_link_hash_undefweak))
	    {
	      hds->smclas = XMC_XO;
	      hds->root.type = bfd_link_hash_defined;
	      hds->root.u.def.section = bfd_abs_section_ptr;
	      hds->root.u.def.value = ldsym.l_value;
	    }
	}
    }

  if (contents != NULL && ! coff_section_data (abfd, lsec)->keep_contents)
    {
      free (coff_section_data (abfd, lsec)->contents);
      coff_section_data (abfd, lsec)->contents = NULL;
    }

  /* Record this file in the import files.  */

  n = ((struct xcoff_import_file *)
       bfd_alloc (abfd, (bfd_size_type) sizeof (struct xcoff_import_file)));
  if (n == NULL)
    return FALSE;
  n->next = NULL;

  /* For some reason, the path entry in the import file list for a
     shared object appears to always be empty.  The file name is the
     base name.  */
  n->path = "";
  if (abfd->my_archive == NULL)
    {
      bname = bfd_get_filename (abfd);
      mname = "";
    }
  else
    {
      bname = bfd_get_filename (abfd->my_archive);
      mname = bfd_get_filename (abfd);
    }
  s = strrchr (bname, '/');
  if (s != NULL)
    bname = s + 1;
  n->file = bname;
  n->member = mname;

  /* We start c at 1 because the first import file number is reserved
     for LIBPATH.  */
  for (pp = &xcoff_hash_table (info)->imports, c = 1;
       *pp != NULL;
       pp = &(*pp)->next, ++c)
    ;
  *pp = n;

  xcoff_data (abfd)->import_file_id = c;

  return TRUE;
}

/* Routines that are called after all the input files have been
   handled, but before the sections are laid out in memory.  */

/* Mark a symbol as not being garbage, including the section in which
   it is defined.  */

static INLINE bfd_boolean
xcoff_mark_symbol (info, h)
     struct bfd_link_info *info;
     struct xcoff_link_hash_entry *h;
{

  if ((h->flags & XCOFF_MARK) != 0)
    return TRUE;

  h->flags |= XCOFF_MARK;
  if (h->root.type == bfd_link_hash_defined
      || h->root.type == bfd_link_hash_defweak)
    {
      asection *hsec;

      hsec = h->root.u.def.section;
      if (! bfd_is_abs_section (hsec)
	  && (hsec->flags & SEC_MARK) == 0)
	{
	  if (! xcoff_mark (info, hsec))
	    return FALSE;
	}
    }

  if (h->toc_section != NULL
      && (h->toc_section->flags & SEC_MARK) == 0)
    {
      if (! xcoff_mark (info, h->toc_section))
	return FALSE;
    }

  return TRUE;
}

/* The mark phase of garbage collection.  For a given section, mark
   it, and all the sections which define symbols to which it refers.
   Because this function needs to look at the relocs, we also count
   the number of relocs which need to be copied into the .loader
   section.  */

static bfd_boolean
xcoff_mark (info, sec)
     struct bfd_link_info *info;
     asection *sec;
{
  if (bfd_is_abs_section (sec)
      || (sec->flags & SEC_MARK) != 0)
    return TRUE;

  sec->flags |= SEC_MARK;

  if (sec->owner->xvec == info->hash->creator
      && coff_section_data (sec->owner, sec) != NULL
      && xcoff_section_data (sec->owner, sec) != NULL)
    {
      register struct xcoff_link_hash_entry **hp, **hpend;
      struct internal_reloc *rel, *relend;

      /* Mark all the symbols in this section.  */

      hp = (obj_xcoff_sym_hashes (sec->owner)
	    + xcoff_section_data (sec->owner, sec)->first_symndx);
      hpend = (obj_xcoff_sym_hashes (sec->owner)
	       + xcoff_section_data (sec->owner, sec)->last_symndx);
      for (; hp < hpend; hp++)
	{
	  register struct xcoff_link_hash_entry *h;

	  h = *hp;
	  if (h != NULL
	      && (h->flags & XCOFF_MARK) == 0)
	    {
	      if (! xcoff_mark_symbol (info, h))
		return FALSE;
	    }
	}

      /* Look through the section relocs.  */

      if ((sec->flags & SEC_RELOC) != 0
	  && sec->reloc_count > 0)
	{
	  rel = xcoff_read_internal_relocs (sec->owner, sec, TRUE,
					    (bfd_byte *) NULL, FALSE,
					    (struct internal_reloc *) NULL);
	  if (rel == NULL)
	    return FALSE;
	  relend = rel + sec->reloc_count;
	  for (; rel < relend; rel++)
	    {
	      asection *rsec;
	      struct xcoff_link_hash_entry *h;

	      if ((unsigned int) rel->r_symndx
		  > obj_raw_syment_count (sec->owner))
		continue;

	      h = obj_xcoff_sym_hashes (sec->owner)[rel->r_symndx];
	      if (h != NULL
		  && (h->flags & XCOFF_MARK) == 0)
		{
		  if (! xcoff_mark_symbol (info, h))
		    return FALSE;
		}

	      rsec = xcoff_data (sec->owner)->csects[rel->r_symndx];
	      if (rsec != NULL
		  && (rsec->flags & SEC_MARK) == 0)
		{
		  if (! xcoff_mark (info, rsec))
		    return FALSE;
		}

	      /* See if this reloc needs to be copied into the .loader
		 section.  */
	      switch (rel->r_type)
		{
		default:
		  if (h == NULL
		      || h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak
		      || h->root.type == bfd_link_hash_common
		      || ((h->flags & XCOFF_CALLED) != 0
			  && (h->root.type == bfd_link_hash_undefined
			      || h->root.type == bfd_link_hash_undefweak)
			  && h->root.root.string[0] == '.'
			  && h->descriptor != NULL
			  && ((h->descriptor->flags & XCOFF_DEF_DYNAMIC) != 0
			      || ((h->descriptor->flags & XCOFF_IMPORT) != 0
				  && (h->descriptor->flags
				      & XCOFF_DEF_REGULAR) == 0))))
		    break;
		  /* Fall through.  */
		case R_POS:
		case R_NEG:
		case R_RL:
		case R_RLA:
		  ++xcoff_hash_table (info)->ldrel_count;
		  if (h != NULL)
		    h->flags |= XCOFF_LDREL;
		  break;
		case R_TOC:
		case R_GL:
		case R_TCL:
		case R_TRL:
		case R_TRLA:
		  /* We should never need a .loader reloc for a TOC
		     relative reloc.  */
		  break;
		}
	    }

	  if (! info->keep_memory
	      && coff_section_data (sec->owner, sec) != NULL
	      && coff_section_data (sec->owner, sec)->relocs != NULL
	      && ! coff_section_data (sec->owner, sec)->keep_relocs)
	    {
	      free (coff_section_data (sec->owner, sec)->relocs);
	      coff_section_data (sec->owner, sec)->relocs = NULL;
	    }
	}
    }

  return TRUE;
}

/* The sweep phase of garbage collection.  Remove all garbage
   sections.  */

static void
xcoff_sweep (info)
     struct bfd_link_info *info;
{
  bfd *sub;

  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      asection *o;

      for (o = sub->sections; o != NULL; o = o->next)
	{
	  if ((o->flags & SEC_MARK) == 0)
	    {
	      /* Keep all sections from non-XCOFF input files.  Keep
		 special sections.  Keep .debug sections for the
		 moment.  */
	      if (sub->xvec != info->hash->creator
		  || o == xcoff_hash_table (info)->debug_section
		  || o == xcoff_hash_table (info)->loader_section
		  || o == xcoff_hash_table (info)->linkage_section
		  || o == xcoff_hash_table (info)->toc_section
		  || o == xcoff_hash_table (info)->descriptor_section
		  || strcmp (o->name, ".debug") == 0)
		o->flags |= SEC_MARK;
	      else
		{
		  o->_raw_size = 0;
		  o->reloc_count = 0;
		  o->lineno_count = 0;
		}
	    }
	}
    }
}

/* Record the number of elements in a set.  This is used to output the
   correct csect length.  */

bfd_boolean
bfd_xcoff_link_record_set (output_bfd, info, harg, size)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct bfd_link_hash_entry *harg;
     bfd_size_type size;
{
  struct xcoff_link_hash_entry *h = (struct xcoff_link_hash_entry *) harg;
  struct xcoff_link_size_list *n;
  bfd_size_type amt;

  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
    return TRUE;

  /* This will hardly ever be called.  I don't want to burn four bytes
     per global symbol, so instead the size is kept on a linked list
     attached to the hash table.  */

  amt = sizeof (struct xcoff_link_size_list);
  n = (struct xcoff_link_size_list *) bfd_alloc (output_bfd, amt);
  if (n == NULL)
    return FALSE;
  n->next = xcoff_hash_table (info)->size_list;
  n->h = h;
  n->size = size;
  xcoff_hash_table (info)->size_list = n;

  h->flags |= XCOFF_HAS_SIZE;

  return TRUE;
}

/* Import a symbol.  */

bfd_boolean
bfd_xcoff_import_symbol (output_bfd, info, harg, val, imppath, impfile,
			 impmember, syscall_flag)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct bfd_link_hash_entry *harg;
     bfd_vma val;
     const char *imppath;
     const char *impfile;
     const char *impmember;
     unsigned int syscall_flag;
{
  struct xcoff_link_hash_entry *h = (struct xcoff_link_hash_entry *) harg;

  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
    return TRUE;

  /* A symbol name which starts with a period is the code for a
     function.  If the symbol is undefined, then add an undefined
     symbol for the function descriptor, and import that instead.  */
  if (h->root.root.string[0] == '.'
      && h->root.type == bfd_link_hash_undefined
      && val == (bfd_vma) -1)
    {
      struct xcoff_link_hash_entry *hds;

      hds = h->descriptor;
      if (hds == NULL)
	{
	  hds = xcoff_link_hash_lookup (xcoff_hash_table (info),
					h->root.root.string + 1,
					TRUE, FALSE, TRUE);
	  if (hds == NULL)
	    return FALSE;
	  if (hds->root.type == bfd_link_hash_new)
	    {
	      hds->root.type = bfd_link_hash_undefined;
	      hds->root.u.undef.abfd = h->root.u.undef.abfd;
	    }
	  hds->flags |= XCOFF_DESCRIPTOR;
	  BFD_ASSERT ((hds->flags & XCOFF_CALLED) == 0
		      && (h->flags & XCOFF_DESCRIPTOR) == 0);
	  hds->descriptor = h;
	  h->descriptor = hds;
	}

      /* Now, if the descriptor is undefined, import the descriptor
	 rather than the symbol we were told to import.  FIXME: Is
	 this correct in all cases?  */
      if (hds->root.type == bfd_link_hash_undefined)
	h = hds;
    }

  h->flags |= (XCOFF_IMPORT | syscall_flag);

  if (val != (bfd_vma) -1)
    {
      if (h->root.type == bfd_link_hash_defined
	  && (! bfd_is_abs_section (h->root.u.def.section)
	      || h->root.u.def.value != val))
	{
	  if (! ((*info->callbacks->multiple_definition)
		 (info, h->root.root.string, h->root.u.def.section->owner,
		  h->root.u.def.section, h->root.u.def.value,
		  output_bfd, bfd_abs_section_ptr, val)))
	    return FALSE;
	}

      h->root.type = bfd_link_hash_defined;
      h->root.u.def.section = bfd_abs_section_ptr;
      h->root.u.def.value = val;
    }

  /* We overload the ldindx field to hold the l_ifile value for this
     symbol.  */
  BFD_ASSERT (h->ldsym == NULL);
  BFD_ASSERT ((h->flags & XCOFF_BUILT_LDSYM) == 0);
  if (imppath == NULL)
    h->ldindx = -1;
  else
    {
      unsigned int c;
      struct xcoff_import_file **pp;

      /* We start c at 1 because the first entry in the import list is
	 reserved for the library search path.  */
      for (pp = &xcoff_hash_table (info)->imports, c = 1;
	   *pp != NULL;
	   pp = &(*pp)->next, ++c)
	{
	  if (strcmp ((*pp)->path, imppath) == 0
	      && strcmp ((*pp)->file, impfile) == 0
	      && strcmp ((*pp)->member, impmember) == 0)
	    break;
	}

      if (*pp == NULL)
	{
	  struct xcoff_import_file *n;
	  bfd_size_type amt = sizeof (struct xcoff_import_file);

	  n = (struct xcoff_import_file *) bfd_alloc (output_bfd, amt);
	  if (n == NULL)
	    return FALSE;
	  n->next = NULL;
	  n->path = imppath;
	  n->file = impfile;
	  n->member = impmember;
	  *pp = n;
	}

      h->ldindx = c;
    }

  return TRUE;
}

/* Export a symbol.  */

bfd_boolean
bfd_xcoff_export_symbol (output_bfd, info, harg)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct bfd_link_hash_entry *harg;
{
  struct xcoff_link_hash_entry *h = (struct xcoff_link_hash_entry *) harg;

  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
    return TRUE;

  h->flags |= XCOFF_EXPORT;

  /* FIXME: I'm not at all sure what syscall is supposed to mean, so
     I'm just going to ignore it until somebody explains it.  */

  /* See if this is a function descriptor.  It may be one even though
     it is not so marked.  */
  if ((h->flags & XCOFF_DESCRIPTOR) == 0
      && h->root.root.string[0] != '.')
    {
      char *fnname;
      struct xcoff_link_hash_entry *hfn;
      bfd_size_type amt = strlen (h->root.root.string) + 2;

      fnname = (char *) bfd_malloc (amt);
      if (fnname == NULL)
	return FALSE;
      fnname[0] = '.';
      strcpy (fnname + 1, h->root.root.string);
      hfn = xcoff_link_hash_lookup (xcoff_hash_table (info),
				    fnname, FALSE, FALSE, TRUE);
      free (fnname);
      if (hfn != NULL
	  && hfn->smclas == XMC_PR
	  && (hfn->root.type == bfd_link_hash_defined
	      || hfn->root.type == bfd_link_hash_defweak))
	{
	  h->flags |= XCOFF_DESCRIPTOR;
	  h->descriptor = hfn;
	  hfn->descriptor = h;
	}
    }

  /* Make sure we don't garbage collect this symbol.  */
  if (! xcoff_mark_symbol (info, h))
    return FALSE;

  /* If this is a function descriptor, make sure we don't garbage
     collect the associated function code.  We normally don't have to
     worry about this, because the descriptor will be attached to a
     section with relocs, but if we are creating the descriptor
     ourselves those relocs will not be visible to the mark code.  */
  if ((h->flags & XCOFF_DESCRIPTOR) != 0)
    {
      if (! xcoff_mark_symbol (info, h->descriptor))
	return FALSE;
    }

  return TRUE;
}

/* Count a reloc against a symbol.  This is called for relocs
   generated by the linker script, typically for global constructors
   and destructors.  */

bfd_boolean
bfd_xcoff_link_count_reloc (output_bfd, info, name)
     bfd *output_bfd;
     struct bfd_link_info *info;
     const char *name;
{
  struct xcoff_link_hash_entry *h;

  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
    return TRUE;

  h = ((struct xcoff_link_hash_entry *)
       bfd_wrapped_link_hash_lookup (output_bfd, info, name, FALSE, FALSE,
				     FALSE));
  if (h == NULL)
    {
      (*_bfd_error_handler) (_("%s: no such symbol"), name);
      bfd_set_error (bfd_error_no_symbols);
      return FALSE;
    }

  h->flags |= XCOFF_REF_REGULAR | XCOFF_LDREL;
  ++xcoff_hash_table (info)->ldrel_count;

  /* Mark the symbol to avoid garbage collection.  */
  if (! xcoff_mark_symbol (info, h))
    return FALSE;

  return TRUE;
}

/* This function is called for each symbol to which the linker script
   assigns a value.  */

bfd_boolean
bfd_xcoff_record_link_assignment (output_bfd, info, name)
     bfd *output_bfd;
     struct bfd_link_info *info;
     const char *name;
{
  struct xcoff_link_hash_entry *h;

  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
    return TRUE;

  h = xcoff_link_hash_lookup (xcoff_hash_table (info), name, TRUE, TRUE,
			      FALSE);
  if (h == NULL)
    return FALSE;

  h->flags |= XCOFF_DEF_REGULAR;

  return TRUE;
}

/* Build the .loader section.  This is called by the XCOFF linker
   emulation before_allocation routine.  We must set the size of the
   .loader section before the linker lays out the output file.
   LIBPATH is the library path to search for shared objects; this is
   normally built from the -L arguments passed to the linker.  ENTRY
   is the name of the entry point symbol (the -e linker option).
   FILE_ALIGN is the alignment to use for sections within the file
   (the -H linker option).  MAXSTACK is the maximum stack size (the
   -bmaxstack linker option).  MAXDATA is the maximum data size (the
   -bmaxdata linker option).  GC is whether to do garbage collection
   (the -bgc linker option).  MODTYPE is the module type (the
   -bmodtype linker option).  TEXTRO is whether the text section must
   be read only (the -btextro linker option).  EXPORT_DEFINEDS is
   whether all defined symbols should be exported (the -unix linker
   option).  SPECIAL_SECTIONS is set by this routine to csects with
   magic names like _end.  */

bfd_boolean
bfd_xcoff_size_dynamic_sections (output_bfd, info, libpath, entry,
				 file_align, maxstack, maxdata, gc,
				 modtype, textro, export_defineds,
				 special_sections, rtld)
     bfd *output_bfd;
     struct bfd_link_info *info;
     const char *libpath;
     const char *entry;
     unsigned long file_align;
     unsigned long maxstack;
     unsigned long maxdata;
     bfd_boolean gc;
     int modtype;
     bfd_boolean textro;
     bfd_boolean export_defineds;
     asection **special_sections;
     bfd_boolean rtld;
{
  struct xcoff_link_hash_entry *hentry;
  asection *lsec;
  struct xcoff_loader_info ldinfo;
  int i;
  size_t impsize, impcount;
  struct xcoff_import_file *fl;
  struct internal_ldhdr *ldhdr;
  bfd_size_type stoff;
  register char *out;
  asection *sec;
  bfd *sub;
  struct bfd_strtab_hash *debug_strtab;
  bfd_byte *debug_contents = NULL;
  bfd_size_type amt;

  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
    {
      for (i = 0; i < XCOFF_NUMBER_OF_SPECIAL_SECTIONS; i++)
	special_sections[i] = NULL;
      return TRUE;
    }

  ldinfo.failed = FALSE;
  ldinfo.output_bfd = output_bfd;
  ldinfo.info = info;
  ldinfo.export_defineds = export_defineds;
  ldinfo.ldsym_count = 0;
  ldinfo.string_size = 0;
  ldinfo.strings = NULL;
  ldinfo.string_alc = 0;

  xcoff_data (output_bfd)->maxstack = maxstack;
  xcoff_data (output_bfd)->maxdata = maxdata;
  xcoff_data (output_bfd)->modtype = modtype;

  xcoff_hash_table (info)->file_align = file_align;
  xcoff_hash_table (info)->textro = textro;

  hentry = NULL;
  if (entry != NULL)
    {
      hentry = xcoff_link_hash_lookup (xcoff_hash_table (info), entry,
				       FALSE, FALSE, TRUE);
      if (hentry != NULL)
	hentry->flags |= XCOFF_ENTRY;
    }

  /* __rtinit */
  if (info->init_function || info->fini_function || rtld)
    {
      struct xcoff_link_hash_entry *hsym;
      struct internal_ldsym *ldsym;

      hsym = xcoff_link_hash_lookup (xcoff_hash_table (info),
				     "__rtinit", FALSE, FALSE, TRUE);
      if (hsym == NULL)
	{
	  (*_bfd_error_handler)
	    (_("error: undefined symbol __rtinit"));
	  return FALSE;
	}

      xcoff_mark_symbol (info, hsym);
      hsym->flags |= (XCOFF_DEF_REGULAR | XCOFF_RTINIT);

      /* __rtinit initialized */
      amt = sizeof (struct internal_ldsym);
      ldsym = (struct internal_ldsym *) bfd_malloc (amt);

      ldsym->l_value = 0;		/* will be filled in later */
      ldsym->l_scnum = 2;		/* data section */
      ldsym->l_smtype = XTY_SD;		/* csect section definition */
      ldsym->l_smclas = 5;		/* .rw */
      ldsym->l_ifile = 0;		/* special system loader symbol */
      ldsym->l_parm = 0;		/* NA */

      /* Force __rtinit to be the first symbol in the loader symbol table
	 See xcoff_build_ldsyms

	 The first 3 symbol table indices are reserved to indicate the data,
	 text and bss sections.  */
      BFD_ASSERT (0 == ldinfo.ldsym_count);

      hsym->ldindx = 3;
      ldinfo.ldsym_count = 1;
      hsym->ldsym = ldsym;

      if (! bfd_xcoff_put_ldsymbol_name (ldinfo.output_bfd, &ldinfo,
					 hsym->ldsym, hsym->root.root.string))
	return FALSE;

      /* This symbol is written out by xcoff_write_global_symbol
	 Set stuff up so xcoff_write_global_symbol logic works.  */
      hsym->flags |= XCOFF_DEF_REGULAR | XCOFF_MARK;
      hsym->root.type = bfd_link_hash_defined;
      hsym->root.u.def.value = 0;
    }

  /* Garbage collect unused sections.  */
  if (info->relocatable
      || ! gc
      || hentry == NULL
      || (hentry->root.type != bfd_link_hash_defined
	  && hentry->root.type != bfd_link_hash_defweak))
    {
      gc = FALSE;
      xcoff_hash_table (info)->gc = FALSE;

      /* We still need to call xcoff_mark, in order to set ldrel_count
	 correctly.  */
      for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
	{
	  asection *o;

	  for (o = sub->sections; o != NULL; o = o->next)
	    {
	      if ((o->flags & SEC_MARK) == 0)
		{
		  if (! xcoff_mark (info, o))
		    goto error_return;
		}
	    }
	}
    }
  else
    {
      if (! xcoff_mark (info, hentry->root.u.def.section))
	goto error_return;
      xcoff_sweep (info);
      xcoff_hash_table (info)->gc = TRUE;
    }

  /* Return special sections to the caller.  */
  for (i = 0; i < XCOFF_NUMBER_OF_SPECIAL_SECTIONS; i++)
    {
      sec = xcoff_hash_table (info)->special_sections[i];

      if (sec != NULL
	  && gc
	  && (sec->flags & SEC_MARK) == 0)
	{
	  sec = NULL;
	}
      special_sections[i] = sec;
    }

  if (info->input_bfds == NULL)
    {
      /* I'm not sure what to do in this bizarre case.  */
      return TRUE;
    }

  xcoff_link_hash_traverse (xcoff_hash_table (info), xcoff_build_ldsyms,
			    (PTR) &ldinfo);
  if (ldinfo.failed)
    goto error_return;

  /* Work out the size of the import file names.  Each import file ID
     consists of three null terminated strings: the path, the file
     name, and the archive member name.  The first entry in the list
     of names is the path to use to find objects, which the linker has
     passed in as the libpath argument.  For some reason, the path
     entry in the other import file names appears to always be empty.  */
  impsize = strlen (libpath) + 3;
  impcount = 1;
  for (fl = xcoff_hash_table (info)->imports; fl != NULL; fl = fl->next)
    {
      ++impcount;
      impsize += (strlen (fl->path)
		  + strlen (fl->file)
		  + strlen (fl->member)
		  + 3);
    }

  /* Set up the .loader section header.  */
  ldhdr = &xcoff_hash_table (info)->ldhdr;
  ldhdr->l_version = bfd_xcoff_ldhdr_version(output_bfd);
  ldhdr->l_nsyms = ldinfo.ldsym_count;
  ldhdr->l_nreloc = xcoff_hash_table (info)->ldrel_count;
  ldhdr->l_istlen = impsize;
  ldhdr->l_nimpid = impcount;
  ldhdr->l_impoff = (bfd_xcoff_ldhdrsz(output_bfd)
		     + ldhdr->l_nsyms * bfd_xcoff_ldsymsz(output_bfd)
		     + ldhdr->l_nreloc * bfd_xcoff_ldrelsz(output_bfd));
  ldhdr->l_stlen = ldinfo.string_size;
  stoff = ldhdr->l_impoff + impsize;
  if (ldinfo.string_size == 0)
    ldhdr->l_stoff = 0;
  else
    ldhdr->l_stoff = stoff;

  /* 64 bit elements to ldhdr
     The swap out routine for 32 bit will ignore them.
     Nothing fancy, symbols come after the header and relocs come
     after symbols.  */
  ldhdr->l_symoff = bfd_xcoff_ldhdrsz (output_bfd);
  ldhdr->l_rldoff = (bfd_xcoff_ldhdrsz (output_bfd)
		     + ldhdr->l_nsyms * bfd_xcoff_ldsymsz (output_bfd));

  /* We now know the final size of the .loader section.  Allocate
     space for it.  */
  lsec = xcoff_hash_table (info)->loader_section;
  lsec->_raw_size = stoff + ldhdr->l_stlen;
  lsec->contents = (bfd_byte *) bfd_zalloc (output_bfd, lsec->_raw_size);
  if (lsec->contents == NULL)
    goto error_return;

  /* Set up the header.  */
  bfd_xcoff_swap_ldhdr_out (output_bfd, ldhdr, lsec->contents);

  /* Set up the import file names.  */
  out = (char *) lsec->contents + ldhdr->l_impoff;
  strcpy (out, libpath);
  out += strlen (libpath) + 1;
  *out++ = '\0';
  *out++ = '\0';
  for (fl = xcoff_hash_table (info)->imports; fl != NULL; fl = fl->next)
    {
      register const char *s;

      s = fl->path;
      while ((*out++ = *s++) != '\0')
	;
      s = fl->file;
      while ((*out++ = *s++) != '\0')
	;
      s = fl->member;
      while ((*out++ = *s++) != '\0')
	;
    }

  BFD_ASSERT ((bfd_size_type) ((bfd_byte *) out - lsec->contents) == stoff);

  /* Set up the symbol string table.  */
  if (ldinfo.string_size > 0)
    {
      memcpy (out, ldinfo.strings, ldinfo.string_size);
      free (ldinfo.strings);
      ldinfo.strings = NULL;
    }

  /* We can't set up the symbol table or the relocs yet, because we
     don't yet know the final position of the various sections.  The
     .loader symbols are written out when the corresponding normal
     symbols are written out in xcoff_link_input_bfd or
     xcoff_write_global_symbol.  The .loader relocs are written out
     when the corresponding normal relocs are handled in
     xcoff_link_input_bfd.
  */

  /* Allocate space for the magic sections.  */
  sec = xcoff_hash_table (info)->linkage_section;
  if (sec->_raw_size > 0)
    {
      sec->contents = (bfd_byte *) bfd_zalloc (output_bfd, sec->_raw_size);
      if (sec->contents == NULL)
	goto error_return;
    }
  sec = xcoff_hash_table (info)->toc_section;
  if (sec->_raw_size > 0)
    {
      sec->contents = (bfd_byte *) bfd_zalloc (output_bfd, sec->_raw_size);
      if (sec->contents == NULL)
	goto error_return;
    }
  sec = xcoff_hash_table (info)->descriptor_section;
  if (sec->_raw_size > 0)
    {
      sec->contents = (bfd_byte *) bfd_zalloc (output_bfd, sec->_raw_size);
      if (sec->contents == NULL)
	goto error_return;
    }

  /* Now that we've done garbage collection, figure out the contents
     of the .debug section.  */
  debug_strtab = xcoff_hash_table (info)->debug_strtab;

  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      asection *subdeb;
      bfd_size_type symcount;
      unsigned long *debug_index;
      asection **csectpp;
      bfd_byte *esym, *esymend;
      bfd_size_type symesz;

      if (sub->xvec != info->hash->creator)
	continue;
      subdeb = bfd_get_section_by_name (sub, ".debug");
      if (subdeb == NULL || subdeb->_raw_size == 0)
	continue;

      if (info->strip == strip_all
	  || info->strip == strip_debugger
	  || info->discard == discard_all)
	{
	  subdeb->_raw_size = 0;
	  continue;
	}

      if (! _bfd_coff_get_external_symbols (sub))
	goto error_return;

      symcount = obj_raw_syment_count (sub);
      debug_index = ((unsigned long *)
		     bfd_zalloc (sub, symcount * sizeof (unsigned long)));
      if (debug_index == NULL)
	goto error_return;
      xcoff_data (sub)->debug_indices = debug_index;

      /* Grab the contents of the .debug section.  We use malloc and
	 copy the names into the debug stringtab, rather than
	 bfd_alloc, because I expect that, when linking many files
	 together, many of the strings will be the same.  Storing the
	 strings in the hash table should save space in this case.  */
      debug_contents = (bfd_byte *) bfd_malloc (subdeb->_raw_size);
      if (debug_contents == NULL)
	goto error_return;
      if (! bfd_get_section_contents (sub, subdeb, (PTR) debug_contents,
				      (file_ptr) 0, subdeb->_raw_size))
	goto error_return;

      csectpp = xcoff_data (sub)->csects;

      /* Dynamic object do not have csectpp's.  */
      if (NULL != csectpp)
	{
	  symesz = bfd_coff_symesz (sub);
	  esym = (bfd_byte *) obj_coff_external_syms (sub);
	  esymend = esym + symcount * symesz;

	  while (esym < esymend)
	    {
	      struct internal_syment sym;

	      bfd_coff_swap_sym_in (sub, (PTR) esym, (PTR) &sym);

	      *debug_index = (unsigned long) -1;

	      if (sym._n._n_n._n_zeroes == 0
		  && *csectpp != NULL
		  && (! gc
		      || ((*csectpp)->flags & SEC_MARK) != 0
		      || *csectpp == bfd_abs_section_ptr)
		  && bfd_coff_symname_in_debug (sub, &sym))
		{
		  char *name;
		  bfd_size_type indx;

		  name = (char *) debug_contents + sym._n._n_n._n_offset;
		  indx = _bfd_stringtab_add (debug_strtab, name, TRUE, TRUE);
		  if (indx == (bfd_size_type) -1)
		    goto error_return;
		  *debug_index = indx;
		}

	      esym += (sym.n_numaux + 1) * symesz;
	      csectpp += sym.n_numaux + 1;
	      debug_index += sym.n_numaux + 1;
	    }
	}

      free (debug_contents);
      debug_contents = NULL;

      /* Clear the size of subdeb, so that it is not included directly
	 in the output file.  */
      subdeb->_raw_size = 0;

      if (! info->keep_memory)
	{
	  if (! _bfd_coff_free_symbols (sub))
	    goto error_return;
	}
    }

  if (info->strip != strip_all)
    xcoff_hash_table (info)->debug_section->_raw_size =
      _bfd_stringtab_size (debug_strtab);

  return TRUE;

 error_return:
  if (ldinfo.strings != NULL)
    free (ldinfo.strings);
  if (debug_contents != NULL)
    free (debug_contents);
  return FALSE;
}

bfd_boolean
bfd_xcoff_link_generate_rtinit (abfd, init, fini, rtld)
     bfd *abfd;
     const char *init;
     const char *fini;
     bfd_boolean rtld;
{
  struct bfd_in_memory *bim;

  bim = ((struct bfd_in_memory *)
	 bfd_malloc ((bfd_size_type) sizeof (struct bfd_in_memory)));
  if (bim == NULL)
    return FALSE;

  bim->size = 0;
  bim->buffer = 0;

  abfd->link_next = 0;
  abfd->format = bfd_object;
  abfd->iostream = (PTR) bim;
  abfd->flags = BFD_IN_MEMORY;
  abfd->direction = write_direction;
  abfd->where = 0;

  if (! bfd_xcoff_generate_rtinit (abfd, init, fini, rtld))
    return FALSE;

  /* need to reset to unknown or it will not be read back in correctly */
  abfd->format = bfd_unknown;
  abfd->direction = read_direction;
  abfd->where = 0;

  return TRUE;
}


/* Add a symbol to the .loader symbols, if necessary.  */

static bfd_boolean
xcoff_build_ldsyms (h, p)
     struct xcoff_link_hash_entry *h;
     PTR p;
{
  struct xcoff_loader_info *ldinfo = (struct xcoff_loader_info *) p;
  bfd_size_type amt;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct xcoff_link_hash_entry *) h->root.u.i.link;

  /* __rtinit, this symbol has special handling. */
  if (h->flags & XCOFF_RTINIT)
      return TRUE;

  /* If this is a final link, and the symbol was defined as a common
     symbol in a regular object file, and there was no definition in
     any dynamic object, then the linker will have allocated space for
     the symbol in a common section but the XCOFF_DEF_REGULAR flag
     will not have been set.  */
  if (h->root.type == bfd_link_hash_defined
      && (h->flags & XCOFF_DEF_REGULAR) == 0
      && (h->flags & XCOFF_REF_REGULAR) != 0
      && (h->flags & XCOFF_DEF_DYNAMIC) == 0
      && (bfd_is_abs_section (h->root.u.def.section)
	  || (h->root.u.def.section->owner->flags & DYNAMIC) == 0))
    h->flags |= XCOFF_DEF_REGULAR;

  /* If all defined symbols should be exported, mark them now.  We
     don't want to export the actual functions, just the function
     descriptors.  */
  if (ldinfo->export_defineds
      && (h->flags & XCOFF_DEF_REGULAR) != 0
      && h->root.root.string[0] != '.')
    {
      bfd_boolean export;

      /* We don't export a symbol which is being defined by an object
	 included from an archive which contains a shared object.  The
	 rationale is that if an archive contains both an unshared and
	 a shared object, then there must be some reason that the
	 unshared object is unshared, and we don't want to start
	 providing a shared version of it.  In particular, this solves
	 a bug involving the _savefNN set of functions.  gcc will call
	 those functions without providing a slot to restore the TOC,
	 so it is essential that these functions be linked in directly
	 and not from a shared object, which means that a shared
	 object which also happens to link them in must not export
	 them.  This is confusing, but I haven't been able to think of
	 a different approach.  Note that the symbols can, of course,
	 be exported explicitly.  */
      export = TRUE;
      if ((h->root.type == bfd_link_hash_defined
	   || h->root.type == bfd_link_hash_defweak)
	  && h->root.u.def.section->owner != NULL
	  && h->root.u.def.section->owner->my_archive != NULL)
	{
	  bfd *arbfd, *member;

	  arbfd = h->root.u.def.section->owner->my_archive;
	  member = bfd_openr_next_archived_file (arbfd, (bfd *) NULL);
	  while (member != NULL)
	    {
	      if ((member->flags & DYNAMIC) != 0)
		{
		  export = FALSE;
		  break;
		}
	      member = bfd_openr_next_archived_file (arbfd, member);
	    }
	}

      if (export)
	h->flags |= XCOFF_EXPORT;
    }

  /* We don't want to garbage collect symbols which are not defined in
     XCOFF files.  This is a convenient place to mark them.  */
  if (xcoff_hash_table (ldinfo->info)->gc
      && (h->flags & XCOFF_MARK) == 0
      && (h->root.type == bfd_link_hash_defined
	  || h->root.type == bfd_link_hash_defweak)
      && (h->root.u.def.section->owner == NULL
	  || (h->root.u.def.section->owner->xvec
	      != ldinfo->info->hash->creator)))
    h->flags |= XCOFF_MARK;

  /* If this symbol is called and defined in a dynamic object, or it
     is imported, then we need to set up global linkage code for it.
     (Unless we did garbage collection and we didn't need this
     symbol.)  */
  if ((h->flags & XCOFF_CALLED) != 0
      && (h->root.type == bfd_link_hash_undefined
	  || h->root.type == bfd_link_hash_undefweak)
      && h->root.root.string[0] == '.'
      && h->descriptor != NULL
      && ((h->descriptor->flags & XCOFF_DEF_DYNAMIC) != 0
	  || ((h->descriptor->flags & XCOFF_IMPORT) != 0
	      && (h->descriptor->flags & XCOFF_DEF_REGULAR) == 0))
      && (! xcoff_hash_table (ldinfo->info)->gc
	  || (h->flags & XCOFF_MARK) != 0))
    {
      asection *sec;
      struct xcoff_link_hash_entry *hds;

      sec = xcoff_hash_table (ldinfo->info)->linkage_section;
      h->root.type = bfd_link_hash_defined;
      h->root.u.def.section = sec;
      h->root.u.def.value = sec->_raw_size;
      h->smclas = XMC_GL;
      h->flags |= XCOFF_DEF_REGULAR;
      sec->_raw_size += bfd_xcoff_glink_code_size(ldinfo->output_bfd);

      /* The global linkage code requires a TOC entry for the
	 descriptor.  */
      hds = h->descriptor;
      BFD_ASSERT ((hds->root.type == bfd_link_hash_undefined
		   || hds->root.type == bfd_link_hash_undefweak)
		  && (hds->flags & XCOFF_DEF_REGULAR) == 0);
      hds->flags |= XCOFF_MARK;
      if (hds->toc_section == NULL)
	{
	  int byte_size;

	  /* 32 vs 64
	     xcoff32 uses 4 bytes in the toc.
	     xcoff64 uses 8 bytes in the toc.  */
	  if (bfd_xcoff_is_xcoff64 (ldinfo->output_bfd))
	    byte_size = 8;
	  else if (bfd_xcoff_is_xcoff32 (ldinfo->output_bfd))
	    byte_size = 4;
	  else
	    return FALSE;

	  hds->toc_section = xcoff_hash_table (ldinfo->info)->toc_section;
	  hds->u.toc_offset = hds->toc_section->_raw_size;
	  hds->toc_section->_raw_size += byte_size;
	  ++xcoff_hash_table (ldinfo->info)->ldrel_count;
	  ++hds->toc_section->reloc_count;
	  hds->indx = -2;
	  hds->flags |= XCOFF_SET_TOC | XCOFF_LDREL;

	  /* We need to call xcoff_build_ldsyms recursively here,
	     because we may already have passed hds on the traversal.  */
	  xcoff_build_ldsyms (hds, p);
	}
    }

  /* If this symbol is exported, but not defined, we need to try to
     define it.  */
  if ((h->flags & XCOFF_EXPORT) != 0
      && (h->flags & XCOFF_IMPORT) == 0
      && (h->flags & XCOFF_DEF_REGULAR) == 0
      && (h->flags & XCOFF_DEF_DYNAMIC) == 0
      && (h->root.type == bfd_link_hash_undefined
	  || h->root.type == bfd_link_hash_undefweak))
    {
      if ((h->flags & XCOFF_DESCRIPTOR) != 0
	  && (h->descriptor->root.type == bfd_link_hash_defined
	      || h->descriptor->root.type == bfd_link_hash_defweak))
	{
	  asection *sec;

	  /* This is an undefined function descriptor associated with
	     a defined entry point.  We can build up a function
	     descriptor ourselves.  Believe it or not, the AIX linker
	     actually does this, and there are cases where we need to
	     do it as well.  */
	  sec = xcoff_hash_table (ldinfo->info)->descriptor_section;
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.section = sec;
	  h->root.u.def.value = sec->_raw_size;
	  h->smclas = XMC_DS;
	  h->flags |= XCOFF_DEF_REGULAR;

	  /* The size of the function descriptor depends if this is an
	     xcoff32 (12) or xcoff64 (24).  */
	  sec->_raw_size +=
	    bfd_xcoff_function_descriptor_size(ldinfo->output_bfd);

	  /* A function descriptor uses two relocs: one for the
	     associated code, and one for the TOC address.  */
	  xcoff_hash_table (ldinfo->info)->ldrel_count += 2;
	  sec->reloc_count += 2;

	  /* We handle writing out the contents of the descriptor in
	     xcoff_write_global_symbol.  */
	}
      else
	{
	  (*_bfd_error_handler)
	    (_("warning: attempt to export undefined symbol `%s'"),
	     h->root.root.string);
	  h->ldsym = NULL;
	  return TRUE;
	}
    }

  /* If this is still a common symbol, and it wasn't garbage
     collected, we need to actually allocate space for it in the .bss
     section.  */
  if (h->root.type == bfd_link_hash_common
      && (! xcoff_hash_table (ldinfo->info)->gc
	  || (h->flags & XCOFF_MARK) != 0)
      && h->root.u.c.p->section->_raw_size == 0)
    {
      BFD_ASSERT (bfd_is_com_section (h->root.u.c.p->section));
      h->root.u.c.p->section->_raw_size = h->root.u.c.size;
    }

  /* We need to add a symbol to the .loader section if it is mentioned
     in a reloc which we are copying to the .loader section and it was
     not defined or common, or if it is the entry point, or if it is
     being exported.  */

  if (((h->flags & XCOFF_LDREL) == 0
       || h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak
       || h->root.type == bfd_link_hash_common)
      && (h->flags & XCOFF_ENTRY) == 0
      && (h->flags & XCOFF_EXPORT) == 0)
    {
      h->ldsym = NULL;
      return TRUE;
    }

  /* We don't need to add this symbol if we did garbage collection and
     we did not mark this symbol.  */
  if (xcoff_hash_table (ldinfo->info)->gc
      && (h->flags & XCOFF_MARK) == 0)
    {
      h->ldsym = NULL;
      return TRUE;
    }

  /* We may have already processed this symbol due to the recursive
     call above.  */
  if ((h->flags & XCOFF_BUILT_LDSYM) != 0)
    return TRUE;

  /* We need to add this symbol to the .loader symbols.  */

  BFD_ASSERT (h->ldsym == NULL);
  amt = sizeof (struct internal_ldsym);
  h->ldsym = (struct internal_ldsym *) bfd_zalloc (ldinfo->output_bfd, amt);
  if (h->ldsym == NULL)
    {
      ldinfo->failed = TRUE;
      return FALSE;
    }

  if ((h->flags & XCOFF_IMPORT) != 0)
    h->ldsym->l_ifile = h->ldindx;

  /* The first 3 symbol table indices are reserved to indicate the
     data, text and bss sections.  */
  h->ldindx = ldinfo->ldsym_count + 3;

  ++ldinfo->ldsym_count;

  if (! bfd_xcoff_put_ldsymbol_name (ldinfo->output_bfd, ldinfo,
				     h->ldsym, h->root.root.string))
    {
      return FALSE;
    }

  h->flags |= XCOFF_BUILT_LDSYM;

  return TRUE;
}

/* Do the final link step.  */

bfd_boolean
_bfd_xcoff_bfd_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  bfd_size_type symesz;
  struct xcoff_final_link_info finfo;
  asection *o;
  struct bfd_link_order *p;
  bfd_size_type max_contents_size;
  bfd_size_type max_sym_count;
  bfd_size_type max_lineno_count;
  bfd_size_type max_reloc_count;
  bfd_size_type max_output_reloc_count;
  file_ptr rel_filepos;
  unsigned int relsz;
  file_ptr line_filepos;
  unsigned int linesz;
  bfd *sub;
  bfd_byte *external_relocs = NULL;
  char strbuf[STRING_SIZE_SIZE];
  file_ptr pos;
  bfd_size_type amt;

  if (info->shared)
    abfd->flags |= DYNAMIC;

  symesz = bfd_coff_symesz (abfd);

  finfo.info = info;
  finfo.output_bfd = abfd;
  finfo.strtab = NULL;
  finfo.section_info = NULL;
  finfo.last_file_index = -1;
  finfo.toc_symindx = -1;
  finfo.internal_syms = NULL;
  finfo.sym_indices = NULL;
  finfo.outsyms = NULL;
  finfo.linenos = NULL;
  finfo.contents = NULL;
  finfo.external_relocs = NULL;

  finfo.ldsym = (xcoff_hash_table (info)->loader_section->contents
		 + bfd_xcoff_ldhdrsz (abfd));
  finfo.ldrel = (xcoff_hash_table (info)->loader_section->contents
		 + bfd_xcoff_ldhdrsz(abfd)
		 + (xcoff_hash_table (info)->ldhdr.l_nsyms
		    * bfd_xcoff_ldsymsz(abfd)));

  xcoff_data (abfd)->coff.link_info = info;

  finfo.strtab = _bfd_stringtab_init ();
  if (finfo.strtab == NULL)
    goto error_return;

  /* Count the line number and relocation entries required for the
     output file.  Determine a few maximum sizes.  */
  max_contents_size = 0;
  max_lineno_count = 0;
  max_reloc_count = 0;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      o->reloc_count = 0;
      o->lineno_count = 0;
      for (p = o->link_order_head; p != NULL; p = p->next)
	{
	  if (p->type == bfd_indirect_link_order)
	    {
	      asection *sec;

	      sec = p->u.indirect.section;

	      /* Mark all sections which are to be included in the
		 link.  This will normally be every section.  We need
		 to do this so that we can identify any sections which
		 the linker has decided to not include.  */
	      sec->linker_mark = TRUE;

	      if (info->strip == strip_none
		  || info->strip == strip_some)
		o->lineno_count += sec->lineno_count;

	      o->reloc_count += sec->reloc_count;

	      if (sec->_raw_size > max_contents_size)
		max_contents_size = sec->_raw_size;
	      if (sec->lineno_count > max_lineno_count)
		max_lineno_count = sec->lineno_count;
	      if (coff_section_data (sec->owner, sec) != NULL
		  && xcoff_section_data (sec->owner, sec) != NULL
		  && (xcoff_section_data (sec->owner, sec)->lineno_count
		      > max_lineno_count))
		max_lineno_count =
		  xcoff_section_data (sec->owner, sec)->lineno_count;
	      if (sec->reloc_count > max_reloc_count)
		max_reloc_count = sec->reloc_count;
	    }
	  else if (p->type == bfd_section_reloc_link_order
		   || p->type == bfd_symbol_reloc_link_order)
	    ++o->reloc_count;
	}
    }

  /* Compute the file positions for all the sections.  */
  if (abfd->output_has_begun)
    {
      if (xcoff_hash_table (info)->file_align != 0)
	abort ();
    }
  else
    {
      bfd_vma file_align;

      file_align = xcoff_hash_table (info)->file_align;
      if (file_align != 0)
	{
	  bfd_boolean saw_contents;
	  int indx;
	  asection **op;
	  file_ptr sofar;

	  /* Insert .pad sections before every section which has
	     contents and is loaded, if it is preceded by some other
	     section which has contents and is loaded.  */
	  saw_contents = TRUE;
	  for (op = &abfd->sections; *op != NULL; op = &(*op)->next)
	    {
	      if (strcmp ((*op)->name, ".pad") == 0)
		saw_contents = FALSE;
	      else if (((*op)->flags & SEC_HAS_CONTENTS) != 0
		       && ((*op)->flags & SEC_LOAD) != 0)
		{
		  if (! saw_contents)
		    saw_contents = TRUE;
		  else
		    {
		      asection *n, **st;

		      /* Create a pad section and place it before the section
			 that needs padding.  This requires unlinking and
			 relinking the bfd's section list.  */

		      st = abfd->section_tail;
		      n = bfd_make_section_anyway (abfd, ".pad");
		      n->flags = SEC_HAS_CONTENTS;
		      n->alignment_power = 0;

		      BFD_ASSERT (*st == n);
		      bfd_section_list_remove (abfd, st);
		      bfd_section_list_insert (abfd, op, n);

		      op = &n->next;
		      saw_contents = FALSE;
		    }
		}
	    }

	  /* Reset the section indices after inserting the new
	     sections.  */
	  indx = 0;
	  for (o = abfd->sections; o != NULL; o = o->next)
	    {
	      ++indx;
	      o->target_index = indx;
	    }
	  BFD_ASSERT ((unsigned int) indx == abfd->section_count);

	  /* Work out appropriate sizes for the .pad sections to force
	     each section to land on a page boundary.  This bit of
	     code knows what compute_section_file_positions is going
	     to do.  */
	  sofar = bfd_coff_filhsz (abfd);
	  sofar += bfd_coff_aoutsz (abfd);
	  sofar += abfd->section_count * bfd_coff_scnhsz (abfd);
	  for (o = abfd->sections; o != NULL; o = o->next)
	    if ((bfd_xcoff_is_reloc_count_overflow
		 (abfd, (bfd_vma) o->reloc_count))
		|| (bfd_xcoff_is_lineno_count_overflow
		    (abfd, (bfd_vma) o->lineno_count)))
	      /* 64 does not overflow, need to check if 32 does */
	      sofar += bfd_coff_scnhsz (abfd);

	  for (o = abfd->sections; o != NULL; o = o->next)
	    {
	      if (strcmp (o->name, ".pad") == 0)
		{
		  bfd_vma pageoff;

		  BFD_ASSERT (o->_raw_size == 0);
		  pageoff = sofar & (file_align - 1);
		  if (pageoff != 0)
		    {
		      o->_raw_size = file_align - pageoff;
		      sofar += file_align - pageoff;
		      o->flags |= SEC_HAS_CONTENTS;
		    }
		}
	      else
		{
		  if ((o->flags & SEC_HAS_CONTENTS) != 0)
		    sofar += BFD_ALIGN (o->_raw_size,
					1 << o->alignment_power);
		}
	    }
	}

      if (! bfd_coff_compute_section_file_positions (abfd))
	goto error_return;
    }

  /* Allocate space for the pointers we need to keep for the relocs.  */
  {
    unsigned int i;

    /* We use section_count + 1, rather than section_count, because
       the target_index fields are 1 based.  */
    amt = abfd->section_count + 1;
    amt *= sizeof (struct xcoff_link_section_info);
    finfo.section_info = (struct xcoff_link_section_info *) bfd_malloc (amt);
    if (finfo.section_info == NULL)
      goto error_return;
    for (i = 0; i <= abfd->section_count; i++)
      {
	finfo.section_info[i].relocs = NULL;
	finfo.section_info[i].rel_hashes = NULL;
	finfo.section_info[i].toc_rel_hashes = NULL;
      }
  }

  /* Set the file positions for the relocs.  */
  rel_filepos = obj_relocbase (abfd);
  relsz = bfd_coff_relsz (abfd);
  max_output_reloc_count = 0;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if (o->reloc_count == 0)
	o->rel_filepos = 0;
      else
	{
	  /* A stripped file has no relocs.  However, we still
	     allocate the buffers, so that later code doesn't have to
	     worry about whether we are stripping or not.  */
	  if (info->strip == strip_all)
	    o->rel_filepos = 0;
	  else
	    {
	      o->flags |= SEC_RELOC;
	      o->rel_filepos = rel_filepos;
	      rel_filepos += o->reloc_count * relsz;
	    }

	  /* We don't know the indices of global symbols until we have
	     written out all the local symbols.  For each section in
	     the output file, we keep an array of pointers to hash
	     table entries.  Each entry in the array corresponds to a
	     reloc.  When we find a reloc against a global symbol, we
	     set the corresponding entry in this array so that we can
	     fix up the symbol index after we have written out all the
	     local symbols.

	     Because of this problem, we also keep the relocs in
	     memory until the end of the link.  This wastes memory.
	     We could backpatch the file later, I suppose, although it
	     would be slow.  */
	  amt = o->reloc_count;
	  amt *= sizeof (struct internal_reloc);
	  finfo.section_info[o->target_index].relocs =
	    (struct internal_reloc *) bfd_malloc (amt);

	  amt = o->reloc_count;
	  amt *= sizeof (struct xcoff_link_hash_entry *);
	  finfo.section_info[o->target_index].rel_hashes =
	    (struct xcoff_link_hash_entry **) bfd_malloc (amt);

	  if (finfo.section_info[o->target_index].relocs == NULL
	      || finfo.section_info[o->target_index].rel_hashes == NULL)
	    goto error_return;

	  if (o->reloc_count > max_output_reloc_count)
	    max_output_reloc_count = o->reloc_count;
	}
    }

  /* We now know the size of the relocs, so we can determine the file
     positions of the line numbers.  */
  line_filepos = rel_filepos;
  finfo.line_filepos = line_filepos;
  linesz = bfd_coff_linesz (abfd);
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if (o->lineno_count == 0)
	o->line_filepos = 0;
      else
	{
	  o->line_filepos = line_filepos;
	  line_filepos += o->lineno_count * linesz;
	}

      /* Reset the reloc and lineno counts, so that we can use them to
	 count the number of entries we have output so far.  */
      o->reloc_count = 0;
      o->lineno_count = 0;
    }

  obj_sym_filepos (abfd) = line_filepos;

  /* Figure out the largest number of symbols in an input BFD.  Take
     the opportunity to clear the output_has_begun fields of all the
     input BFD's.  We want at least 6 symbols, since that is the
     number which xcoff_write_global_symbol may need.  */
  max_sym_count = 6;
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      bfd_size_type sz;

      sub->output_has_begun = FALSE;
      sz = obj_raw_syment_count (sub);
      if (sz > max_sym_count)
	max_sym_count = sz;
    }

  /* Allocate some buffers used while linking.  */
  amt = max_sym_count * sizeof (struct internal_syment);
  finfo.internal_syms = (struct internal_syment *) bfd_malloc (amt);

  amt = max_sym_count * sizeof (long);
  finfo.sym_indices = (long *) bfd_malloc (amt);

  amt = (max_sym_count + 1) * symesz;
  finfo.outsyms = (bfd_byte *) bfd_malloc (amt);

  amt = max_lineno_count * bfd_coff_linesz (abfd);
  finfo.linenos = (bfd_byte *) bfd_malloc (amt);

  amt = max_contents_size;
  finfo.contents = (bfd_byte *) bfd_malloc (amt);

  amt = max_reloc_count * relsz;
  finfo.external_relocs = (bfd_byte *) bfd_malloc (amt);

  if ((finfo.internal_syms == NULL && max_sym_count > 0)
      || (finfo.sym_indices == NULL && max_sym_count > 0)
      || finfo.outsyms == NULL
      || (finfo.linenos == NULL && max_lineno_count > 0)
      || (finfo.contents == NULL && max_contents_size > 0)
      || (finfo.external_relocs == NULL && max_reloc_count > 0))
    goto error_return;

  obj_raw_syment_count (abfd) = 0;
  xcoff_data (abfd)->toc = (bfd_vma) -1;

  /* We now know the position of everything in the file, except that
     we don't know the size of the symbol table and therefore we don't
     know where the string table starts.  We just build the string
     table in memory as we go along.  We process all the relocations
     for a single input file at once.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      for (p = o->link_order_head; p != NULL; p = p->next)
	{
	  if (p->type == bfd_indirect_link_order
	      && p->u.indirect.section->owner->xvec == abfd->xvec)
	    {
	      sub = p->u.indirect.section->owner;
	      if (! sub->output_has_begun)
		{
		  if (! xcoff_link_input_bfd (&finfo, sub))
		    goto error_return;
		  sub->output_has_begun = TRUE;
		}
	    }
	  else if (p->type == bfd_section_reloc_link_order
		   || p->type == bfd_symbol_reloc_link_order)
	    {
	      if (! xcoff_reloc_link_order (abfd, &finfo, o, p))
		goto error_return;
	    }
	  else
	    {
	      if (! _bfd_default_link_order (abfd, info, o, p))
		goto error_return;
	    }
	}
    }


  /* Free up the buffers used by xcoff_link_input_bfd.  */

  if (finfo.internal_syms != NULL)
    {
      free (finfo.internal_syms);
      finfo.internal_syms = NULL;
    }
  if (finfo.sym_indices != NULL)
    {
      free (finfo.sym_indices);
      finfo.sym_indices = NULL;
    }
  if (finfo.linenos != NULL)
    {
      free (finfo.linenos);
      finfo.linenos = NULL;
    }
  if (finfo.contents != NULL)
    {
      free (finfo.contents);
      finfo.contents = NULL;
    }
  if (finfo.external_relocs != NULL)
    {
      free (finfo.external_relocs);
      finfo.external_relocs = NULL;
    }

  /* The value of the last C_FILE symbol is supposed to be -1.  Write
     it out again.  */
  if (finfo.last_file_index != -1)
    {
      finfo.last_file.n_value = -(bfd_vma) 1;
      bfd_coff_swap_sym_out (abfd, (PTR) &finfo.last_file,
			     (PTR) finfo.outsyms);
      pos = obj_sym_filepos (abfd) + finfo.last_file_index * symesz;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (finfo.outsyms, symesz, abfd) != symesz)
	goto error_return;
    }

  /* Write out all the global symbols which do not come from XCOFF
     input files.  */
  xcoff_link_hash_traverse (xcoff_hash_table (info),
			    xcoff_write_global_symbol,
			    (PTR) &finfo);

  if (finfo.outsyms != NULL)
    {
      free (finfo.outsyms);
      finfo.outsyms = NULL;
    }

  /* Now that we have written out all the global symbols, we know the
     symbol indices to use for relocs against them, and we can finally
     write out the relocs.  */
  amt = max_output_reloc_count * relsz;
  external_relocs = (bfd_byte *) bfd_malloc (amt);
  if (external_relocs == NULL && max_output_reloc_count != 0)
    goto error_return;

  for (o = abfd->sections; o != NULL; o = o->next)
    {
      struct internal_reloc *irel;
      struct internal_reloc *irelend;
      struct xcoff_link_hash_entry **rel_hash;
      struct xcoff_toc_rel_hash *toc_rel_hash;
      bfd_byte *erel;
      bfd_size_type rel_size;

      /* A stripped file has no relocs.  */
      if (info->strip == strip_all)
	{
	  o->reloc_count = 0;
	  continue;
	}

      if (o->reloc_count == 0)
	continue;

      irel = finfo.section_info[o->target_index].relocs;
      irelend = irel + o->reloc_count;
      rel_hash = finfo.section_info[o->target_index].rel_hashes;
      for (; irel < irelend; irel++, rel_hash++, erel += relsz)
	{
	  if (*rel_hash != NULL)
	    {
	      if ((*rel_hash)->indx < 0)
		{
		  if (! ((*info->callbacks->unattached_reloc)
			 (info, (*rel_hash)->root.root.string,
			  (bfd *) NULL, o, irel->r_vaddr)))
		    goto error_return;
		  (*rel_hash)->indx = 0;
		}
	      irel->r_symndx = (*rel_hash)->indx;
	    }
	}

      for (toc_rel_hash = finfo.section_info[o->target_index].toc_rel_hashes;
	   toc_rel_hash != NULL;
	   toc_rel_hash = toc_rel_hash->next)
	{
	  if (toc_rel_hash->h->u.toc_indx < 0)
	    {
	      if (! ((*info->callbacks->unattached_reloc)
		     (info, toc_rel_hash->h->root.root.string,
		      (bfd *) NULL, o, toc_rel_hash->rel->r_vaddr)))
		goto error_return;
	      toc_rel_hash->h->u.toc_indx = 0;
	    }
	  toc_rel_hash->rel->r_symndx = toc_rel_hash->h->u.toc_indx;
	}

      /* XCOFF requires that the relocs be sorted by address.  We tend
	 to produce them in the order in which their containing csects
	 appear in the symbol table, which is not necessarily by
	 address.  So we sort them here.  There may be a better way to
	 do this.  */
      qsort ((PTR) finfo.section_info[o->target_index].relocs,
	     o->reloc_count, sizeof (struct internal_reloc),
	     xcoff_sort_relocs);

      irel = finfo.section_info[o->target_index].relocs;
      irelend = irel + o->reloc_count;
      erel = external_relocs;
      for (; irel < irelend; irel++, rel_hash++, erel += relsz)
	bfd_coff_swap_reloc_out (abfd, (PTR) irel, (PTR) erel);

      rel_size = relsz * o->reloc_count;
      if (bfd_seek (abfd, o->rel_filepos, SEEK_SET) != 0
	  || bfd_bwrite ((PTR) external_relocs, rel_size, abfd) != rel_size)
	goto error_return;
    }

  if (external_relocs != NULL)
    {
      free (external_relocs);
      external_relocs = NULL;
    }

  /* Free up the section information.  */
  if (finfo.section_info != NULL)
    {
      unsigned int i;

      for (i = 0; i < abfd->section_count; i++)
	{
	  if (finfo.section_info[i].relocs != NULL)
	    free (finfo.section_info[i].relocs);
	  if (finfo.section_info[i].rel_hashes != NULL)
	    free (finfo.section_info[i].rel_hashes);
	}
      free (finfo.section_info);
      finfo.section_info = NULL;
    }

  /* Write out the loader section contents.  */
  BFD_ASSERT ((bfd_byte *) finfo.ldrel
	      == (xcoff_hash_table (info)->loader_section->contents
		  + xcoff_hash_table (info)->ldhdr.l_impoff));
  o = xcoff_hash_table (info)->loader_section;
  if (! bfd_set_section_contents (abfd, o->output_section, o->contents,
				  (file_ptr) o->output_offset, o->_raw_size))
    goto error_return;

  /* Write out the magic sections.  */
  o = xcoff_hash_table (info)->linkage_section;
  if (o->_raw_size > 0
      && ! bfd_set_section_contents (abfd, o->output_section, o->contents,
				     (file_ptr) o->output_offset,
				     o->_raw_size))
    goto error_return;
  o = xcoff_hash_table (info)->toc_section;
  if (o->_raw_size > 0
      && ! bfd_set_section_contents (abfd, o->output_section, o->contents,
				     (file_ptr) o->output_offset,
				     o->_raw_size))
    goto error_return;
  o = xcoff_hash_table (info)->descriptor_section;
  if (o->_raw_size > 0
      && ! bfd_set_section_contents (abfd, o->output_section, o->contents,
				     (file_ptr) o->output_offset,
				     o->_raw_size))
    goto error_return;

  /* Write out the string table.  */
  pos = obj_sym_filepos (abfd) + obj_raw_syment_count (abfd) * symesz;
  if (bfd_seek (abfd, pos, SEEK_SET) != 0)
    goto error_return;
  H_PUT_32 (abfd,
	    _bfd_stringtab_size (finfo.strtab) + STRING_SIZE_SIZE,
	    strbuf);
  amt = STRING_SIZE_SIZE;
  if (bfd_bwrite (strbuf, amt, abfd) != amt)
    goto error_return;
  if (! _bfd_stringtab_emit (abfd, finfo.strtab))
    goto error_return;

  _bfd_stringtab_free (finfo.strtab);

  /* Write out the debugging string table.  */
  o = xcoff_hash_table (info)->debug_section;
  if (o != NULL)
    {
      struct bfd_strtab_hash *debug_strtab;

      debug_strtab = xcoff_hash_table (info)->debug_strtab;
      BFD_ASSERT (o->output_section->_raw_size - o->output_offset
		  >= _bfd_stringtab_size (debug_strtab));
      pos = o->output_section->filepos + o->output_offset;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0)
	goto error_return;
      if (! _bfd_stringtab_emit (abfd, debug_strtab))
	goto error_return;
    }

  /* Setting bfd_get_symcount to 0 will cause write_object_contents to
     not try to write out the symbols.  */
  bfd_get_symcount (abfd) = 0;

  return TRUE;

 error_return:
  if (finfo.strtab != NULL)
    _bfd_stringtab_free (finfo.strtab);

  if (finfo.section_info != NULL)
    {
      unsigned int i;

      for (i = 0; i < abfd->section_count; i++)
	{
	  if (finfo.section_info[i].relocs != NULL)
	    free (finfo.section_info[i].relocs);
	  if (finfo.section_info[i].rel_hashes != NULL)
	    free (finfo.section_info[i].rel_hashes);
	}
      free (finfo.section_info);
    }

  if (finfo.internal_syms != NULL)
    free (finfo.internal_syms);
  if (finfo.sym_indices != NULL)
    free (finfo.sym_indices);
  if (finfo.outsyms != NULL)
    free (finfo.outsyms);
  if (finfo.linenos != NULL)
    free (finfo.linenos);
  if (finfo.contents != NULL)
    free (finfo.contents);
  if (finfo.external_relocs != NULL)
    free (finfo.external_relocs);
  if (external_relocs != NULL)
    free (external_relocs);
  return FALSE;
}

/* Link an input file into the linker output file.  This function
   handles all the sections and relocations of the input file at once.  */

static bfd_boolean
xcoff_link_input_bfd (finfo, input_bfd)
     struct xcoff_final_link_info *finfo;
     bfd *input_bfd;
{
  bfd *output_bfd;
  const char *strings;
  bfd_size_type syment_base;
  unsigned int n_tmask;
  unsigned int n_btshft;
  bfd_boolean copy, hash;
  bfd_size_type isymesz;
  bfd_size_type osymesz;
  bfd_size_type linesz;
  bfd_byte *esym;
  bfd_byte *esym_end;
  struct xcoff_link_hash_entry **sym_hash;
  struct internal_syment *isymp;
  asection **csectpp;
  unsigned long *debug_index;
  long *indexp;
  unsigned long output_index;
  bfd_byte *outsym;
  unsigned int incls;
  asection *oline;
  bfd_boolean keep_syms;
  asection *o;

  /* We can just skip DYNAMIC files, unless this is a static link.  */
  if ((input_bfd->flags & DYNAMIC) != 0
      && ! finfo->info->static_link)
    return TRUE;

  /* Move all the symbols to the output file.  */

  output_bfd = finfo->output_bfd;
  strings = NULL;
  syment_base = obj_raw_syment_count (output_bfd);
  isymesz = bfd_coff_symesz (input_bfd);
  osymesz = bfd_coff_symesz (output_bfd);
  linesz = bfd_coff_linesz (input_bfd);
  BFD_ASSERT (linesz == bfd_coff_linesz (output_bfd));

  n_tmask = coff_data (input_bfd)->local_n_tmask;
  n_btshft = coff_data (input_bfd)->local_n_btshft;

  /* Define macros so that ISFCN, et. al., macros work correctly.  */
#define N_TMASK n_tmask
#define N_BTSHFT n_btshft

  copy = FALSE;
  if (! finfo->info->keep_memory)
    copy = TRUE;
  hash = TRUE;
  if ((output_bfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
    hash = FALSE;

  if (! _bfd_coff_get_external_symbols (input_bfd))
    return FALSE;

  esym = (bfd_byte *) obj_coff_external_syms (input_bfd);
  esym_end = esym + obj_raw_syment_count (input_bfd) * isymesz;
  sym_hash = obj_xcoff_sym_hashes (input_bfd);
  csectpp = xcoff_data (input_bfd)->csects;
  debug_index = xcoff_data (input_bfd)->debug_indices;
  isymp = finfo->internal_syms;
  indexp = finfo->sym_indices;
  output_index = syment_base;
  outsym = finfo->outsyms;
  incls = 0;
  oline = NULL;

  while (esym < esym_end)
    {

      struct internal_syment isym;
      union internal_auxent aux;
      int smtyp = 0;
      bfd_boolean skip;
      bfd_boolean require;
      int add;

      bfd_coff_swap_sym_in (input_bfd, (PTR) esym, (PTR) isymp);

      /* If this is a C_EXT or C_HIDEXT symbol, we need the csect
	 information.  */
      if (isymp->n_sclass == C_EXT || isymp->n_sclass == C_HIDEXT)
	{
	  BFD_ASSERT (isymp->n_numaux > 0);
	  bfd_coff_swap_aux_in (input_bfd,
				(PTR) (esym + isymesz * isymp->n_numaux),
				isymp->n_type, isymp->n_sclass,
				isymp->n_numaux - 1, isymp->n_numaux,
				(PTR) &aux);

	  smtyp = SMTYP_SMTYP (aux.x_csect.x_smtyp);
	}

      /* Make a copy of *isymp so that the relocate_section function
	 always sees the original values.  This is more reliable than
	 always recomputing the symbol value even if we are stripping
	 the symbol.  */
      isym = *isymp;

      /* If this symbol is in the .loader section, swap out the
	 .loader symbol information.  If this is an external symbol
	 reference to a defined symbol, though, then wait until we get
	 to the definition.  */
      if (isym.n_sclass == C_EXT
	  && *sym_hash != NULL
	  && (*sym_hash)->ldsym != NULL
	  && (smtyp != XTY_ER
	      || (*sym_hash)->root.type == bfd_link_hash_undefined))
	{
	  struct xcoff_link_hash_entry *h;
	  struct internal_ldsym *ldsym;

	  h = *sym_hash;
	  ldsym = h->ldsym;
	  if (isym.n_scnum > 0)
	    {
	      ldsym->l_scnum = (*csectpp)->output_section->target_index;
	      ldsym->l_value = (isym.n_value
				+ (*csectpp)->output_section->vma
				+ (*csectpp)->output_offset
				- (*csectpp)->vma);
	    }
	  else
	    {
	      ldsym->l_scnum = isym.n_scnum;
	      ldsym->l_value = isym.n_value;
	    }

	  ldsym->l_smtype = smtyp;
	  if (((h->flags & XCOFF_DEF_REGULAR) == 0
	       && (h->flags & XCOFF_DEF_DYNAMIC) != 0)
	      || (h->flags & XCOFF_IMPORT) != 0)
	    ldsym->l_smtype |= L_IMPORT;
	  if (((h->flags & XCOFF_DEF_REGULAR) != 0
	       && (h->flags & XCOFF_DEF_DYNAMIC) != 0)
	      || (h->flags & XCOFF_EXPORT) != 0)
	    ldsym->l_smtype |= L_EXPORT;
	  if ((h->flags & XCOFF_ENTRY) != 0)
	    ldsym->l_smtype |= L_ENTRY;

	  ldsym->l_smclas = aux.x_csect.x_smclas;

	  if (ldsym->l_ifile == (bfd_size_type) -1)
	    ldsym->l_ifile = 0;
	  else if (ldsym->l_ifile == 0)
	    {
	      if ((ldsym->l_smtype & L_IMPORT) == 0)
		ldsym->l_ifile = 0;
	      else
		{
		  bfd *impbfd;

		  if (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak)
		    impbfd = h->root.u.def.section->owner;
		  else if (h->root.type == bfd_link_hash_undefined
			   || h->root.type == bfd_link_hash_undefweak)
		    impbfd = h->root.u.undef.abfd;
		  else
		    impbfd = NULL;

		  if (impbfd == NULL)
		    ldsym->l_ifile = 0;
		  else
		    {
		      BFD_ASSERT (impbfd->xvec == finfo->output_bfd->xvec);
		      ldsym->l_ifile = xcoff_data (impbfd)->import_file_id;
		    }
		}
	    }

	  ldsym->l_parm = 0;

	  BFD_ASSERT (h->ldindx >= 0);
	  bfd_xcoff_swap_ldsym_out (finfo->output_bfd, ldsym,
				    (finfo->ldsym
				     + ((h->ldindx - 3)
					* bfd_xcoff_ldsymsz (finfo->output_bfd))));
	  h->ldsym = NULL;

	  /* Fill in snentry now that we know the target_index.  */
	  if ((h->flags & XCOFF_ENTRY) != 0
	      && (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak))
	    {
	      xcoff_data (output_bfd)->snentry =
		h->root.u.def.section->output_section->target_index;
	    }
	}

      *indexp = -1;

      skip = FALSE;
      require = FALSE;
      add = 1 + isym.n_numaux;

      /* If we are skipping this csect, we want to skip this symbol.  */
      if (*csectpp == NULL)
	skip = TRUE;

      /* If we garbage collected this csect, we want to skip this
	 symbol.  */
      if (! skip
	  && xcoff_hash_table (finfo->info)->gc
	  && ((*csectpp)->flags & SEC_MARK) == 0
	  && *csectpp != bfd_abs_section_ptr)
	skip = TRUE;

      /* An XCOFF linker always skips C_STAT symbols.  */
      if (! skip
	  && isymp->n_sclass == C_STAT)
	skip = TRUE;

      /* We skip all but the first TOC anchor.  */
      if (! skip
	  && isymp->n_sclass == C_HIDEXT
	  && aux.x_csect.x_smclas == XMC_TC0)
	{
	  if (finfo->toc_symindx != -1)
	    skip = TRUE;
	  else
	    {
	      bfd_vma tocval, tocend;
	      bfd *inp;

	      tocval = ((*csectpp)->output_section->vma
			+ (*csectpp)->output_offset
			+ isym.n_value
			- (*csectpp)->vma);

	      /* We want to find out if tocval is a good value to use
		 as the TOC anchor--that is, whether we can access all
		 of the TOC using a 16 bit offset from tocval.  This
		 test assumes that the TOC comes at the end of the
		 output section, as it does in the default linker
		 script.  */
	      tocend = ((*csectpp)->output_section->vma
			+ (*csectpp)->output_section->_raw_size);
	      for (inp = finfo->info->input_bfds;
		   inp != NULL;
		   inp = inp->link_next)
		{

		  for (o = inp->sections; o != NULL; o = o->next)
		    if (strcmp (o->name, ".tocbss") == 0)
		      {
			bfd_vma new_toc_end;
			new_toc_end = (o->output_section->vma
				       + o->output_offset
				       + o->_cooked_size);
			if (new_toc_end > tocend)
			  tocend = new_toc_end;
		      }

		}

	      if (tocval + 0x10000 < tocend)
		{
		  (*_bfd_error_handler)
		    (_("TOC overflow: 0x%lx > 0x10000; try -mminimal-toc when compiling"),
		     (unsigned long) (tocend - tocval));
		  bfd_set_error (bfd_error_file_too_big);
		  return FALSE;
		}

	      if (tocval + 0x8000 < tocend)
		{
		  bfd_vma tocadd;

		  tocadd = tocend - (tocval + 0x8000);
		  tocval += tocadd;
		  isym.n_value += tocadd;
		}

	      finfo->toc_symindx = output_index;
	      xcoff_data (finfo->output_bfd)->toc = tocval;
	      xcoff_data (finfo->output_bfd)->sntoc =
		(*csectpp)->output_section->target_index;
	      require = TRUE;

	    }
	}

      /* If we are stripping all symbols, we want to skip this one.  */
      if (! skip
	  && finfo->info->strip == strip_all)
	skip = TRUE;

      /* We can skip resolved external references.  */
      if (! skip
	  && isym.n_sclass == C_EXT
	  && smtyp == XTY_ER
	  && (*sym_hash)->root.type != bfd_link_hash_undefined)
	skip = TRUE;

      /* We can skip common symbols if they got defined somewhere
	 else.  */
      if (! skip
	  && isym.n_sclass == C_EXT
	  && smtyp == XTY_CM
	  && ((*sym_hash)->root.type != bfd_link_hash_common
	      || (*sym_hash)->root.u.c.p->section != *csectpp)
	  && ((*sym_hash)->root.type != bfd_link_hash_defined
	      || (*sym_hash)->root.u.def.section != *csectpp))
	skip = TRUE;

      /* Skip local symbols if we are discarding them.  */
      if (! skip
	  && finfo->info->discard == discard_all
	  && isym.n_sclass != C_EXT
	  && (isym.n_sclass != C_HIDEXT
	      || smtyp != XTY_SD))
	skip = TRUE;

      /* If we stripping debugging symbols, and this is a debugging
	 symbol, then skip it.  */
      if (! skip
	  && finfo->info->strip == strip_debugger
	  && isym.n_scnum == N_DEBUG)
	skip = TRUE;

      /* If some symbols are stripped based on the name, work out the
	 name and decide whether to skip this symbol.  We don't handle
	 this correctly for symbols whose names are in the .debug
	 section; to get it right we would need a new bfd_strtab_hash
	 function to return the string given the index.  */
      if (! skip
	  && (finfo->info->strip == strip_some
	      || finfo->info->discard == discard_l)
	  && (debug_index == NULL || *debug_index == (unsigned long) -1))
	{
	  const char *name;
	  char buf[SYMNMLEN + 1];

	  name = _bfd_coff_internal_syment_name (input_bfd, &isym, buf);

	  if (name == NULL)
	    return FALSE;

	  if ((finfo->info->strip == strip_some
	       && (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE,
				    FALSE) == NULL))
	      || (finfo->info->discard == discard_l
		  && (isym.n_sclass != C_EXT
		      && (isym.n_sclass != C_HIDEXT
			  || smtyp != XTY_SD))
		  && bfd_is_local_label_name (input_bfd, name)))
	    skip = TRUE;
	}

      /* We can not skip the first TOC anchor.  */
      if (skip
	  && require
	  && finfo->info->strip != strip_all)
	skip = FALSE;

      /* We now know whether we are to skip this symbol or not.  */
      if (! skip)
	{
	  /* Adjust the symbol in order to output it.  */

	  if (isym._n._n_n._n_zeroes == 0
	      && isym._n._n_n._n_offset != 0)
	    {
	      /* This symbol has a long name.  Enter it in the string
		 table we are building.  If *debug_index != -1, the
		 name has already been entered in the .debug section.  */
	      if (debug_index != NULL && *debug_index != (unsigned long) -1)
		isym._n._n_n._n_offset = *debug_index;
	      else
		{
		  const char *name;
		  bfd_size_type indx;

		  name = _bfd_coff_internal_syment_name (input_bfd, &isym,
							 (char *) NULL);

		  if (name == NULL)
		    return FALSE;
		  indx = _bfd_stringtab_add (finfo->strtab, name, hash, copy);
		  if (indx == (bfd_size_type) -1)
		    return FALSE;
		  isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;
		}
	    }

	  if (isym.n_sclass != C_BSTAT
	      && isym.n_sclass != C_ESTAT
	      && isym.n_sclass != C_DECL
	      && isym.n_scnum > 0)
	    {
	      isym.n_scnum = (*csectpp)->output_section->target_index;
	      isym.n_value += ((*csectpp)->output_section->vma
			       + (*csectpp)->output_offset
			       - (*csectpp)->vma);
	    }

	  /* The value of a C_FILE symbol is the symbol index of the
	     next C_FILE symbol.  The value of the last C_FILE symbol
	     is -1.  We try to get this right, below, just before we
	     write the symbols out, but in the general case we may
	     have to write the symbol out twice.  */
	  if (isym.n_sclass == C_FILE)
	    {
	      if (finfo->last_file_index != -1
		  && finfo->last_file.n_value != (bfd_vma) output_index)
		{
		  /* We must correct the value of the last C_FILE entry.  */
		  finfo->last_file.n_value = output_index;
		  if ((bfd_size_type) finfo->last_file_index >= syment_base)
		    {
		      /* The last C_FILE symbol is in this input file.  */
		      bfd_coff_swap_sym_out (output_bfd,
					     (PTR) &finfo->last_file,
					     (PTR) (finfo->outsyms
						    + ((finfo->last_file_index
							- syment_base)
						       * osymesz)));
		    }
		  else
		    {
		      /* We have already written out the last C_FILE
			 symbol.  We need to write it out again.  We
			 borrow *outsym temporarily.  */
		      file_ptr pos;

		      bfd_coff_swap_sym_out (output_bfd,
					     (PTR) &finfo->last_file,
					     (PTR) outsym);

		      pos = obj_sym_filepos (output_bfd);
		      pos += finfo->last_file_index * osymesz;
		      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
			  || (bfd_bwrite (outsym, osymesz, output_bfd)
			      != osymesz))
			return FALSE;
		    }
		}

	      finfo->last_file_index = output_index;
	      finfo->last_file = isym;
	    }

	  /* The value of a C_BINCL or C_EINCL symbol is a file offset
	     into the line numbers.  We update the symbol values when
	     we handle the line numbers.  */
	  if (isym.n_sclass == C_BINCL
	      || isym.n_sclass == C_EINCL)
	    {
	      isym.n_value = finfo->line_filepos;
	      ++incls;
	    }

	  /* Output the symbol.  */

	  bfd_coff_swap_sym_out (output_bfd, (PTR) &isym, (PTR) outsym);

	  *indexp = output_index;

	  if (isym.n_sclass == C_EXT)
	    {
	      long indx;
	      struct xcoff_link_hash_entry *h;

	      indx = ((esym - (bfd_byte *) obj_coff_external_syms (input_bfd))
		      / isymesz);
	      h = obj_xcoff_sym_hashes (input_bfd)[indx];
	      BFD_ASSERT (h != NULL);
	      h->indx = output_index;
	    }

	  /* If this is a symbol in the TOC which we may have merged
	     (class XMC_TC), remember the symbol index of the TOC
	     symbol.  */
	  if (isym.n_sclass == C_HIDEXT
	      && aux.x_csect.x_smclas == XMC_TC
	      && *sym_hash != NULL)
	    {
	      BFD_ASSERT (((*sym_hash)->flags & XCOFF_SET_TOC) == 0);
	      BFD_ASSERT ((*sym_hash)->toc_section != NULL);
	      (*sym_hash)->u.toc_indx = output_index;
	    }

	  output_index += add;
	  outsym += add * osymesz;
	}

      esym += add * isymesz;
      isymp += add;
      csectpp += add;
      sym_hash += add;
      if (debug_index != NULL)
	debug_index += add;
      ++indexp;
      for (--add; add > 0; --add)
	*indexp++ = -1;
    }

  /* Fix up the aux entries and the C_BSTAT symbols.  This must be
     done in a separate pass, because we don't know the correct symbol
     indices until we have already decided which symbols we are going
     to keep.  */

  esym = (bfd_byte *) obj_coff_external_syms (input_bfd);
  esym_end = esym + obj_raw_syment_count (input_bfd) * isymesz;
  isymp = finfo->internal_syms;
  indexp = finfo->sym_indices;
  csectpp = xcoff_data (input_bfd)->csects;
  outsym = finfo->outsyms;
  while (esym < esym_end)
    {
      int add;

      add = 1 + isymp->n_numaux;

      if (*indexp < 0)
	esym += add * isymesz;
      else
	{
	  int i;

	  if (isymp->n_sclass == C_BSTAT)
	    {
	      struct internal_syment isym;

	      bfd_vma indx;

	      /* The value of a C_BSTAT symbol is the symbol table
		 index of the containing csect.  */
	      bfd_coff_swap_sym_in (output_bfd, (PTR) outsym, (PTR) &isym);
	      indx = isym.n_value;
	      if (indx < obj_raw_syment_count (input_bfd))
		{
		  long symindx;

		  symindx = finfo->sym_indices[indx];
		  if (symindx < 0)
		    isym.n_value = 0;
		  else
		    isym.n_value = symindx;
		  bfd_coff_swap_sym_out (output_bfd, (PTR) &isym,
					 (PTR) outsym);
		}
	    }

	  esym += isymesz;
	  outsym += osymesz;

	  for (i = 0; i < isymp->n_numaux && esym < esym_end; i++)
	    {
	      union internal_auxent aux;

	      bfd_coff_swap_aux_in (input_bfd, (PTR) esym, isymp->n_type,
				    isymp->n_sclass, i, isymp->n_numaux,
				    (PTR) &aux);

	      if (isymp->n_sclass == C_FILE)
		{
		  /* This is the file name (or some comment put in by
		     the compiler).  If it is long, we must put it in
		     the string table.  */
		  if (aux.x_file.x_n.x_zeroes == 0
		      && aux.x_file.x_n.x_offset != 0)
		    {
		      const char *filename;
		      bfd_size_type indx;

		      BFD_ASSERT (aux.x_file.x_n.x_offset
				  >= STRING_SIZE_SIZE);
		      if (strings == NULL)
			{
			  strings = _bfd_coff_read_string_table (input_bfd);
			  if (strings == NULL)
			    return FALSE;
			}
		      filename = strings + aux.x_file.x_n.x_offset;
		      indx = _bfd_stringtab_add (finfo->strtab, filename,
						 hash, copy);
		      if (indx == (bfd_size_type) -1)
			return FALSE;
		      aux.x_file.x_n.x_offset = STRING_SIZE_SIZE + indx;
		    }
		}
	      else if ((isymp->n_sclass == C_EXT
			|| isymp->n_sclass == C_HIDEXT)
		       && i + 1 == isymp->n_numaux)
		{

		  /* We don't support type checking.  I don't know if
		     anybody does.  */
		  aux.x_csect.x_parmhash = 0;
		  /* I don't think anybody uses these fields, but we'd
		     better clobber them just in case.  */
		  aux.x_csect.x_stab = 0;
		  aux.x_csect.x_snstab = 0;

		  if (SMTYP_SMTYP (aux.x_csect.x_smtyp) == XTY_LD)
		    {
		      unsigned long indx;

		      indx = aux.x_csect.x_scnlen.l;
		      if (indx < obj_raw_syment_count (input_bfd))
			{
			  long symindx;

			  symindx = finfo->sym_indices[indx];
			  if (symindx < 0)
			    {
			      aux.x_csect.x_scnlen.l = 0;
			    }
			  else
			    {
			      aux.x_csect.x_scnlen.l = symindx;
			    }
			}
		    }
		}
	      else if (isymp->n_sclass != C_STAT || isymp->n_type != T_NULL)
		{
		  unsigned long indx;

		  if (ISFCN (isymp->n_type)
		      || ISTAG (isymp->n_sclass)
		      || isymp->n_sclass == C_BLOCK
		      || isymp->n_sclass == C_FCN)
		    {
		      indx = aux.x_sym.x_fcnary.x_fcn.x_endndx.l;
		      if (indx > 0
			  && indx < obj_raw_syment_count (input_bfd))
			{
			  /* We look forward through the symbol for
			     the index of the next symbol we are going
			     to include.  I don't know if this is
			     entirely right.  */
			  while (finfo->sym_indices[indx] < 0
				 && indx < obj_raw_syment_count (input_bfd))
			    ++indx;
			  if (indx >= obj_raw_syment_count (input_bfd))
			    indx = output_index;
			  else
			    indx = finfo->sym_indices[indx];
			  aux.x_sym.x_fcnary.x_fcn.x_endndx.l = indx;

			}
		    }

		  indx = aux.x_sym.x_tagndx.l;
		  if (indx > 0 && indx < obj_raw_syment_count (input_bfd))
		    {
		      long symindx;

		      symindx = finfo->sym_indices[indx];
		      if (symindx < 0)
			aux.x_sym.x_tagndx.l = 0;
		      else
			aux.x_sym.x_tagndx.l = symindx;
		    }

		}

	      /* Copy over the line numbers, unless we are stripping
		 them.  We do this on a symbol by symbol basis in
		 order to more easily handle garbage collection.  */
	      if ((isymp->n_sclass == C_EXT
		   || isymp->n_sclass == C_HIDEXT)
		  && i == 0
		  && isymp->n_numaux > 1
		  && ISFCN (isymp->n_type)
		  && aux.x_sym.x_fcnary.x_fcn.x_lnnoptr != 0)
		{
		  if (finfo->info->strip != strip_none
		      && finfo->info->strip != strip_some)
		    aux.x_sym.x_fcnary.x_fcn.x_lnnoptr = 0;
		  else
		    {
		      asection *enclosing;
		      unsigned int enc_count;
		      bfd_signed_vma linoff;
		      struct internal_lineno lin;

		      o = *csectpp;
		      enclosing = xcoff_section_data (abfd, o)->enclosing;
		      enc_count = xcoff_section_data (abfd, o)->lineno_count;
		      if (oline != enclosing)
			{
			  file_ptr pos = enclosing->line_filepos;
			  bfd_size_type amt = linesz * enc_count;
			  if (bfd_seek (input_bfd, pos, SEEK_SET) != 0
			      || (bfd_bread (finfo->linenos, amt, input_bfd)
				  != amt))
			    return FALSE;
			  oline = enclosing;
			}

		      linoff = (aux.x_sym.x_fcnary.x_fcn.x_lnnoptr
				- enclosing->line_filepos);

		      bfd_coff_swap_lineno_in (input_bfd,
					       (PTR) (finfo->linenos + linoff),
					       (PTR) &lin);
		      if (lin.l_lnno != 0
			  || ((bfd_size_type) lin.l_addr.l_symndx
			      != ((esym
				   - isymesz
				   - ((bfd_byte *)
				      obj_coff_external_syms (input_bfd)))
				  / isymesz)))
			aux.x_sym.x_fcnary.x_fcn.x_lnnoptr = 0;
		      else
			{
			  bfd_byte *linpend, *linp;
			  bfd_vma offset;
			  bfd_size_type count;

			  lin.l_addr.l_symndx = *indexp;
			  bfd_coff_swap_lineno_out (output_bfd, (PTR) &lin,
						    (PTR) (finfo->linenos
							   + linoff));

			  linpend = (finfo->linenos
				     + enc_count * linesz);
			  offset = (o->output_section->vma
				    + o->output_offset
				    - o->vma);
			  for (linp = finfo->linenos + linoff + linesz;
			       linp < linpend;
			       linp += linesz)
			    {
			      bfd_coff_swap_lineno_in (input_bfd, (PTR) linp,
						       (PTR) &lin);
			      if (lin.l_lnno == 0)
				break;
			      lin.l_addr.l_paddr += offset;
			      bfd_coff_swap_lineno_out (output_bfd,
							(PTR) &lin,
							(PTR) linp);
			    }

			  count = (linp - (finfo->linenos + linoff)) / linesz;

			  aux.x_sym.x_fcnary.x_fcn.x_lnnoptr =
			    (o->output_section->line_filepos
			     + o->output_section->lineno_count * linesz);

			  if (bfd_seek (output_bfd,
					aux.x_sym.x_fcnary.x_fcn.x_lnnoptr,
					SEEK_SET) != 0
			      || (bfd_bwrite (finfo->linenos + linoff,
					     linesz * count, output_bfd)
				  != linesz * count))
			    return FALSE;

			  o->output_section->lineno_count += count;

			  if (incls > 0)
			    {
			      struct internal_syment *iisp, *iispend;
			      long *iindp;
			      bfd_byte *oos;
			      int iiadd;

			      /* Update any C_BINCL or C_EINCL symbols
				 that refer to a line number in the
				 range we just output.  */
			      iisp = finfo->internal_syms;
			      iispend = (iisp
					 + obj_raw_syment_count (input_bfd));
			      iindp = finfo->sym_indices;
			      oos = finfo->outsyms;
			      while (iisp < iispend)
				{
				  if (*iindp >= 0
				      && (iisp->n_sclass == C_BINCL
					  || iisp->n_sclass == C_EINCL)
				      && ((bfd_size_type) iisp->n_value
					  >= (bfd_size_type)(enclosing->line_filepos + linoff))
				      && ((bfd_size_type) iisp->n_value
					  < (enclosing->line_filepos
					     + enc_count * linesz)))
				    {
				      struct internal_syment iis;

				      bfd_coff_swap_sym_in (output_bfd,
							    (PTR) oos,
							    (PTR) &iis);
				      iis.n_value =
					(iisp->n_value
					 - enclosing->line_filepos
					 - linoff
					 + aux.x_sym.x_fcnary.x_fcn.x_lnnoptr);
				      bfd_coff_swap_sym_out (output_bfd,
							     (PTR) &iis,
							     (PTR) oos);
				      --incls;
				    }

				  iiadd = 1 + iisp->n_numaux;
				  if (*iindp >= 0)
				    oos += iiadd * osymesz;
				  iisp += iiadd;
				  iindp += iiadd;
				}
			    }
			}
		    }
		}

	      bfd_coff_swap_aux_out (output_bfd, (PTR) &aux, isymp->n_type,
				     isymp->n_sclass, i, isymp->n_numaux,
				     (PTR) outsym);
	      outsym += osymesz;
	      esym += isymesz;
	    }
	}

      indexp += add;
      isymp += add;
      csectpp += add;
    }

  /* If we swapped out a C_FILE symbol, guess that the next C_FILE
     symbol will be the first symbol in the next input file.  In the
     normal case, this will save us from writing out the C_FILE symbol
     again.  */
  if (finfo->last_file_index != -1
      && (bfd_size_type) finfo->last_file_index >= syment_base)
    {
      finfo->last_file.n_value = output_index;
      bfd_coff_swap_sym_out (output_bfd, (PTR) &finfo->last_file,
			     (PTR) (finfo->outsyms
 				    + ((finfo->last_file_index - syment_base)
 				       * osymesz)));
    }

  /* Write the modified symbols to the output file.  */
  if (outsym > finfo->outsyms)
    {
      file_ptr pos = obj_sym_filepos (output_bfd) + syment_base * osymesz;
      bfd_size_type amt = outsym - finfo->outsyms;
      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (finfo->outsyms, amt, output_bfd) != amt)
	return FALSE;

      BFD_ASSERT ((obj_raw_syment_count (output_bfd)
		   + (outsym - finfo->outsyms) / osymesz)
		  == output_index);

      obj_raw_syment_count (output_bfd) = output_index;
    }

  /* Don't let the linker relocation routines discard the symbols.  */
  keep_syms = obj_coff_keep_syms (input_bfd);
  obj_coff_keep_syms (input_bfd) = TRUE;

  /* Relocate the contents of each section.  */
  for (o = input_bfd->sections; o != NULL; o = o->next)
    {

      bfd_byte *contents;

      if (! o->linker_mark)
	{
	  /* This section was omitted from the link.  */
	  continue;
	}

      if ((o->flags & SEC_HAS_CONTENTS) == 0
	  || o->_raw_size == 0
	  || (o->flags & SEC_IN_MEMORY) != 0)
	continue;

      /* We have set filepos correctly for the sections we created to
	 represent csects, so bfd_get_section_contents should work.  */
      if (coff_section_data (input_bfd, o) != NULL
	  && coff_section_data (input_bfd, o)->contents != NULL)
	contents = coff_section_data (input_bfd, o)->contents;
      else {
	if (! bfd_get_section_contents (input_bfd, o, finfo->contents,
					(file_ptr) 0, o->_raw_size))
	  return FALSE;
	contents = finfo->contents;
      }

      if ((o->flags & SEC_RELOC) != 0)
	{
	  int target_index;
	  struct internal_reloc *internal_relocs;
	  struct internal_reloc *irel;
	  bfd_vma offset;
	  struct internal_reloc *irelend;
	  struct xcoff_link_hash_entry **rel_hash;
	  long r_symndx;

	  /* Read in the relocs.  */
	  target_index = o->output_section->target_index;
	  internal_relocs = (xcoff_read_internal_relocs
			     (input_bfd, o, FALSE, finfo->external_relocs,
			      TRUE,
			      (finfo->section_info[target_index].relocs
			       + o->output_section->reloc_count)));
	  if (internal_relocs == NULL)
	    return FALSE;

	  /* Call processor specific code to relocate the section
	     contents.  */
	  if (! bfd_coff_relocate_section (output_bfd, finfo->info,
					   input_bfd, o,
					   contents,
					   internal_relocs,
					   finfo->internal_syms,
					   xcoff_data (input_bfd)->csects))
	    return FALSE;

	  offset = o->output_section->vma + o->output_offset - o->vma;
	  irel = internal_relocs;
	  irelend = irel + o->reloc_count;
	  rel_hash = (finfo->section_info[target_index].rel_hashes
		      + o->output_section->reloc_count);
	  for (; irel < irelend; irel++, rel_hash++)
	    {
	      struct xcoff_link_hash_entry *h = NULL;
	      struct internal_ldrel ldrel;
	      bfd_boolean quiet;

	      *rel_hash = NULL;

	      /* Adjust the reloc address and symbol index.  */

	      irel->r_vaddr += offset;

	      r_symndx = irel->r_symndx;

	      if (r_symndx == -1)
		h = NULL;
	      else
		h = obj_xcoff_sym_hashes (input_bfd)[r_symndx];

	      if (r_symndx != -1 && finfo->info->strip != strip_all)
		{
		  if (h != NULL
		      && h->smclas != XMC_TD
		      && (irel->r_type == R_TOC
			  || irel->r_type == R_GL
			  || irel->r_type == R_TCL
			  || irel->r_type == R_TRL
			  || irel->r_type == R_TRLA))
		    {
		      /* This is a TOC relative reloc with a symbol
			 attached.  The symbol should be the one which
			 this reloc is for.  We want to make this
			 reloc against the TOC address of the symbol,
			 not the symbol itself.  */
		      BFD_ASSERT (h->toc_section != NULL);
		      BFD_ASSERT ((h->flags & XCOFF_SET_TOC) == 0);
		      if (h->u.toc_indx != -1)
			irel->r_symndx = h->u.toc_indx;
		      else
			{
			  struct xcoff_toc_rel_hash *n;
			  struct xcoff_link_section_info *si;
			  bfd_size_type amt;

			  amt = sizeof (struct xcoff_toc_rel_hash);
			  n = ((struct xcoff_toc_rel_hash *)
			       bfd_alloc (finfo->output_bfd, amt));
			  if (n == NULL)
			    return FALSE;
			  si = finfo->section_info + target_index;
			  n->next = si->toc_rel_hashes;
			  n->h = h;
			  n->rel = irel;
			  si->toc_rel_hashes = n;
			}
		    }
		  else if (h != NULL)
		    {
		      /* This is a global symbol.  */
		      if (h->indx >= 0)
			irel->r_symndx = h->indx;
		      else
			{
			  /* This symbol is being written at the end
			     of the file, and we do not yet know the
			     symbol index.  We save the pointer to the
			     hash table entry in the rel_hash list.
			     We set the indx field to -2 to indicate
			     that this symbol must not be stripped.  */
			  *rel_hash = h;
			  h->indx = -2;
			}
		    }
		  else
		    {
		      long indx;

		      indx = finfo->sym_indices[r_symndx];

		      if (indx == -1)
			{
			  struct internal_syment *is;

			  /* Relocations against a TC0 TOC anchor are
			     automatically transformed to be against
			     the TOC anchor in the output file.  */
			  is = finfo->internal_syms + r_symndx;
			  if (is->n_sclass == C_HIDEXT
			      && is->n_numaux > 0)
			    {
			      PTR auxptr;
			      union internal_auxent aux;

			      auxptr = ((PTR)
					(((bfd_byte *)
					  obj_coff_external_syms (input_bfd))
					 + ((r_symndx + is->n_numaux)
					    * isymesz)));
			      bfd_coff_swap_aux_in (input_bfd, auxptr,
						    is->n_type, is->n_sclass,
						    is->n_numaux - 1,
						    is->n_numaux,
						    (PTR) &aux);
			      if (SMTYP_SMTYP (aux.x_csect.x_smtyp) == XTY_SD
				  && aux.x_csect.x_smclas == XMC_TC0)
				indx = finfo->toc_symindx;
			    }
			}

		      if (indx != -1)
			irel->r_symndx = indx;
		      else
			{

			  struct internal_syment *is;

			  const char *name;
			  char buf[SYMNMLEN + 1];

			  /* This reloc is against a symbol we are
			     stripping.  It would be possible to handle
			     this case, but I don't think it's worth it.  */
			  is = finfo->internal_syms + r_symndx;

			  name = (_bfd_coff_internal_syment_name
				  (input_bfd, is, buf));

			  if (name == NULL)
			    return FALSE;

			  if (! ((*finfo->info->callbacks->unattached_reloc)
				 (finfo->info, name, input_bfd, o,
				  irel->r_vaddr)))
			    return FALSE;
			}
		    }
		}

	      quiet = FALSE;
	      switch (irel->r_type)
		{
		default:
		  if (h == NULL
		      || h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak
		      || h->root.type == bfd_link_hash_common)
		    break;
		  /* Fall through.  */
		case R_POS:
		case R_NEG:
		case R_RL:
		case R_RLA:
		  /* This reloc needs to be copied into the .loader
		     section.  */
		  ldrel.l_vaddr = irel->r_vaddr;
		  if (r_symndx == -1)
		    ldrel.l_symndx = -(bfd_size_type ) 1;
		  else if (h == NULL
			   || (h->root.type == bfd_link_hash_defined
			       || h->root.type == bfd_link_hash_defweak
			       || h->root.type == bfd_link_hash_common))
		    {
		      asection *sec;

		      if (h == NULL)
			sec = xcoff_data (input_bfd)->csects[r_symndx];
		      else if (h->root.type == bfd_link_hash_common)
			sec = h->root.u.c.p->section;
		      else
			sec = h->root.u.def.section;
		      sec = sec->output_section;

		      if (strcmp (sec->name, ".text") == 0)
			ldrel.l_symndx = 0;
		      else if (strcmp (sec->name, ".data") == 0)
			ldrel.l_symndx = 1;
		      else if (strcmp (sec->name, ".bss") == 0)
			ldrel.l_symndx = 2;
		      else
			{
			  (*_bfd_error_handler)
			    (_("%s: loader reloc in unrecognized section `%s'"),
			     bfd_archive_filename (input_bfd),
			     sec->name);
			  bfd_set_error (bfd_error_nonrepresentable_section);
			  return FALSE;
			}
		    }
		  else
		    {
		      if (! finfo->info->relocatable
			  && (h->flags & XCOFF_DEF_DYNAMIC) == 0
			  && (h->flags & XCOFF_IMPORT) == 0)
			{
			  /* We already called the undefined_symbol
			     callback for this relocation, in
			     _bfd_ppc_xcoff_relocate_section.  Don't
			     issue any more warnings.  */
			  quiet = TRUE;
			}
		      if (h->ldindx < 0 && ! quiet)
			{
			  (*_bfd_error_handler)
			    (_("%s: `%s' in loader reloc but not loader sym"),
			     bfd_archive_filename (input_bfd),
			     h->root.root.string);
			  bfd_set_error (bfd_error_bad_value);
			  return FALSE;
			}
		      ldrel.l_symndx = h->ldindx;
		    }
		  ldrel.l_rtype = (irel->r_size << 8) | irel->r_type;
		  ldrel.l_rsecnm = o->output_section->target_index;
		  if (xcoff_hash_table (finfo->info)->textro
		      && strcmp (o->output_section->name, ".text") == 0
		      && ! quiet)
		    {
		      (*_bfd_error_handler)
			(_("%s: loader reloc in read-only section %s"),
			 bfd_archive_filename (input_bfd),
			 bfd_get_section_name (finfo->output_bfd,
					       o->output_section));
		      bfd_set_error (bfd_error_invalid_operation);
		      return FALSE;
		    }
		  bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel,
					    finfo->ldrel);

		  finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);
		  break;

		case R_TOC:
		case R_GL:
		case R_TCL:
		case R_TRL:
		case R_TRLA:
		  /* We should never need a .loader reloc for a TOC
		     relative reloc.  */
		  break;
		}
	    }

	  o->output_section->reloc_count += o->reloc_count;
	}

      /* Write out the modified section contents.  */
      if (! bfd_set_section_contents (output_bfd, o->output_section,
				      contents, (file_ptr) o->output_offset,
				      (o->_cooked_size != 0
				       ? o->_cooked_size
				       : o->_raw_size)))
	return FALSE;
    }

  obj_coff_keep_syms (input_bfd) = keep_syms;

  if (! finfo->info->keep_memory)
    {
      if (! _bfd_coff_free_symbols (input_bfd))
	return FALSE;
    }

  return TRUE;
}

#undef N_TMASK
#undef N_BTSHFT

/* Write out a non-XCOFF global symbol.  */


static bfd_boolean
xcoff_write_global_symbol (h, inf)
     struct xcoff_link_hash_entry *h;
     PTR inf;
{
  struct xcoff_final_link_info *finfo = (struct xcoff_final_link_info *) inf;
  bfd *output_bfd;
  bfd_byte *outsym;
  struct internal_syment isym;
  union internal_auxent aux;
  bfd_boolean result;
  file_ptr pos;
  bfd_size_type amt;

  output_bfd = finfo->output_bfd;
  outsym = finfo->outsyms;

  if (h->root.type == bfd_link_hash_warning)
    {
      h = (struct xcoff_link_hash_entry *) h->root.u.i.link;
      if (h->root.type == bfd_link_hash_new)
	return TRUE;
    }

  /* If this symbol was garbage collected, just skip it.  */
  if (xcoff_hash_table (finfo->info)->gc
      && (h->flags & XCOFF_MARK) == 0)
    return TRUE;

  /* If we need a .loader section entry, write it out.  */
  if (h->ldsym != NULL)
    {
      struct internal_ldsym *ldsym;
      bfd *impbfd;

      ldsym = h->ldsym;

      if (h->root.type == bfd_link_hash_undefined
	  || h->root.type == bfd_link_hash_undefweak)
	{

	  ldsym->l_value = 0;
	  ldsym->l_scnum = N_UNDEF;
	  ldsym->l_smtype = XTY_ER;
	  impbfd = h->root.u.undef.abfd;

	}
      else if (h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	{

	  asection *sec;

	  sec = h->root.u.def.section;
	  ldsym->l_value = (sec->output_section->vma
			    + sec->output_offset
			    + h->root.u.def.value);
	  ldsym->l_scnum = sec->output_section->target_index;
	  ldsym->l_smtype = XTY_SD;
	  impbfd = sec->owner;

	}
      else
	abort ();

      if (((h->flags & XCOFF_DEF_REGULAR) == 0
	   && (h->flags & XCOFF_DEF_DYNAMIC) != 0)
	  || (h->flags & XCOFF_IMPORT) != 0)
	{
	  /* Clear l_smtype
	     Import symbols are defined so the check above will make
	     the l_smtype XTY_SD.  But this is not correct, it should
	     be cleared.  */
	  ldsym->l_smtype |= L_IMPORT;
	}

      if (((h->flags & XCOFF_DEF_REGULAR) != 0
	   && (h->flags & XCOFF_DEF_DYNAMIC) != 0)
	  || (h->flags & XCOFF_EXPORT) != 0)
	{
	  ldsym->l_smtype |= L_EXPORT;
	}

      if ((h->flags & XCOFF_ENTRY) != 0)
	{
	  ldsym->l_smtype |= L_ENTRY;
	}

      if ((h->flags & XCOFF_RTINIT) != 0)
	{
	  ldsym->l_smtype = XTY_SD;
	}

      ldsym->l_smclas = h->smclas;

      if (ldsym->l_smtype & L_IMPORT)
	{
	  if ((h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	      && (h->root.u.def.value != 0))
	    {
	      ldsym->l_smclas = XMC_XO;
	    }
	  else if ((h->flags & (XCOFF_SYSCALL32 | XCOFF_SYSCALL64)) ==
		   (XCOFF_SYSCALL32 | XCOFF_SYSCALL64))
	    {
	      ldsym->l_smclas = XMC_SV3264;
	    }
	  else if (h->flags & XCOFF_SYSCALL32)
	    {
	      ldsym->l_smclas = XMC_SV;
	    }
	  else if (h->flags & XCOFF_SYSCALL64)
	    {
	      ldsym->l_smclas = XMC_SV64;
	    }
	}

      if (ldsym->l_ifile == -(bfd_size_type) 1)
	{
	  ldsym->l_ifile = 0;
	}
      else if (ldsym->l_ifile == 0)
	{
	  if ((ldsym->l_smtype & L_IMPORT) == 0)
	    {
	      ldsym->l_ifile = 0;
	    }
	  else if (impbfd == NULL)
	    {
	      ldsym->l_ifile = 0;
	    }
	  else
	    {
	      BFD_ASSERT (impbfd->xvec == output_bfd->xvec);
	      ldsym->l_ifile = xcoff_data (impbfd)->import_file_id;
	    }
	}

      ldsym->l_parm = 0;

      BFD_ASSERT (h->ldindx >= 0);

      bfd_xcoff_swap_ldsym_out (output_bfd, ldsym,
				(finfo->ldsym +
				 (h->ldindx - 3)
				 * bfd_xcoff_ldsymsz(finfo->output_bfd)));
      h->ldsym = NULL;
    }

  /* If this symbol needs global linkage code, write it out.  */
  if (h->root.type == bfd_link_hash_defined
      && (h->root.u.def.section
	  == xcoff_hash_table (finfo->info)->linkage_section))
    {
      bfd_byte *p;
      bfd_vma tocoff;
      unsigned int i;

      p = h->root.u.def.section->contents + h->root.u.def.value;

      /* The first instruction in the global linkage code loads a
	 specific TOC element.  */
      tocoff = (h->descriptor->toc_section->output_section->vma
		+ h->descriptor->toc_section->output_offset
		- xcoff_data (output_bfd)->toc);

      if ((h->descriptor->flags & XCOFF_SET_TOC) != 0)
	{
	  tocoff += h->descriptor->u.toc_offset;
	}


      /* The first instruction in the glink code needs to be
	 cooked to to hold the correct offset in the toc.  The
	 rest are just output raw.  */
      bfd_put_32 (output_bfd,
		  bfd_xcoff_glink_code(output_bfd, 0) | (tocoff & 0xffff), p);

      /* Start with i == 1 to get past the first instruction done above
	 The /4 is because the glink code is in bytes and we are going
	 4 at a pop.  */
      for (i = 1; i < bfd_xcoff_glink_code_size(output_bfd) / 4; i++)
	{
	  bfd_put_32 (output_bfd,
		      (bfd_vma) bfd_xcoff_glink_code(output_bfd, i),
		      &p[4 * i]);
	}
    }

  /* If we created a TOC entry for this symbol, write out the required
     relocs.  */
  if ((h->flags & XCOFF_SET_TOC) != 0)
    {
      asection *tocsec;
      asection *osec;
      int oindx;
      struct internal_reloc *irel;
      struct internal_ldrel ldrel;
      struct internal_syment irsym;
      union internal_auxent iraux;

      tocsec = h->toc_section;
      osec = tocsec->output_section;
      oindx = osec->target_index;
      irel = finfo->section_info[oindx].relocs + osec->reloc_count;
      irel->r_vaddr = (osec->vma
		       + tocsec->output_offset
		       + h->u.toc_offset);


      if (h->indx >= 0)
	{
	  irel->r_symndx = h->indx;
	}
      else
	{
	  h->indx = -2;
	  irel->r_symndx = obj_raw_syment_count (output_bfd);
	}

      BFD_ASSERT (h->ldindx >= 0);

      /* Initialize the aux union here instead of closer to when it is
	 written out below because the length of the csect depends on
	 whether the output is 32 or 64 bit.  */
      memset (&iraux, 0, sizeof iraux);
      iraux.x_csect.x_smtyp = XTY_SD;
      /* iraux.x_csect.x_scnlen.l = 4 or 8, see below */
      iraux.x_csect.x_smclas = XMC_TC;

      /* 32 bit uses a 32 bit R_POS to do the relocations
	 64 bit uses a 64 bit R_POS to do the relocations

	 Also needs to change the csect size : 4 for 32 bit, 8 for 64 bit

	 Which one is determined by the backend.  */
      if (bfd_xcoff_is_xcoff64 (output_bfd))
	{
	  irel->r_size = 63;
	  iraux.x_csect.x_scnlen.l = 8;
	}
      else if (bfd_xcoff_is_xcoff32 (output_bfd))
	{
	  irel->r_size = 31;
	  iraux.x_csect.x_scnlen.l = 4;
	}
      else
	{
	  return FALSE;
	}
      irel->r_type = R_POS;
      finfo->section_info[oindx].rel_hashes[osec->reloc_count] = NULL;
      ++osec->reloc_count;

      ldrel.l_vaddr = irel->r_vaddr;
      ldrel.l_symndx = h->ldindx;
      ldrel.l_rtype = (irel->r_size << 8) | R_POS;
      ldrel.l_rsecnm = oindx;
      bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
      finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);

      /* We need to emit a symbol to define a csect which holds
	 the reloc.  */
      if (finfo->info->strip != strip_all)
	{

	  result = bfd_xcoff_put_symbol_name (output_bfd, finfo->strtab,
					      &irsym, h->root.root.string);
	  if (!result)
	    return FALSE;

	  irsym.n_value = irel->r_vaddr;
	  irsym.n_scnum = osec->target_index;
	  irsym.n_sclass = C_HIDEXT;
	  irsym.n_type = T_NULL;
	  irsym.n_numaux = 1;

	  bfd_coff_swap_sym_out (output_bfd, (PTR) &irsym, (PTR) outsym);
	  outsym += bfd_coff_symesz (output_bfd);

	  /* note : iraux is initialized above */
	  bfd_coff_swap_aux_out (output_bfd, (PTR) &iraux, T_NULL, C_HIDEXT,
				 0, 1, (PTR) outsym);
	  outsym += bfd_coff_auxesz (output_bfd);

	  if (h->indx >= 0)
	    {
	      /* We aren't going to write out the symbols below, so we
		 need to write them out now.  */
	      pos = obj_sym_filepos (output_bfd);
	      pos += (obj_raw_syment_count (output_bfd)
		      * bfd_coff_symesz (output_bfd));
	      amt = outsym - finfo->outsyms;
	      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
		  || bfd_bwrite (finfo->outsyms, amt, output_bfd) != amt)
		return FALSE;
	      obj_raw_syment_count (output_bfd) +=
		(outsym - finfo->outsyms) / bfd_coff_symesz (output_bfd);

	      outsym = finfo->outsyms;
	    }
	}
    }

  /* If this symbol is a specially defined function descriptor, write
     it out.  The first word is the address of the function code
     itself, the second word is the address of the TOC, and the third
     word is zero.

     32 bit vs 64 bit
     The addresses for the 32 bit will take 4 bytes and the addresses
     for 64 bit will take 8 bytes.  Similar for the relocs.  This type
     of logic was also done above to create a TOC entry in
     xcoff_write_global_symbol.  */
  if ((h->flags & XCOFF_DESCRIPTOR) != 0
      && h->root.type == bfd_link_hash_defined
      && (h->root.u.def.section
	  == xcoff_hash_table (finfo->info)->descriptor_section))
    {
      asection *sec;
      asection *osec;
      int oindx;
      bfd_byte *p;
      struct xcoff_link_hash_entry *hentry;
      asection *esec;
      struct internal_reloc *irel;
      struct internal_ldrel ldrel;
      asection *tsec;
      unsigned int reloc_size, byte_size;

      if (bfd_xcoff_is_xcoff64 (output_bfd))
	{
	  reloc_size = 63;
	  byte_size = 8;
	}
      else if (bfd_xcoff_is_xcoff32 (output_bfd))
	{
	  reloc_size = 31;
	  byte_size = 4;
	}
      else
	{
	  return FALSE;
	}

      sec = h->root.u.def.section;
      osec = sec->output_section;
      oindx = osec->target_index;
      p = sec->contents + h->root.u.def.value;

      hentry = h->descriptor;
      BFD_ASSERT (hentry != NULL
		  && (hentry->root.type == bfd_link_hash_defined
		      || hentry->root.type == bfd_link_hash_defweak));
      esec = hentry->root.u.def.section;

      irel = finfo->section_info[oindx].relocs + osec->reloc_count;
      irel->r_vaddr = (osec->vma
		       + sec->output_offset
		       + h->root.u.def.value);
      irel->r_symndx = esec->output_section->target_index;
      irel->r_type = R_POS;
      irel->r_size = reloc_size;
      finfo->section_info[oindx].rel_hashes[osec->reloc_count] = NULL;
      ++osec->reloc_count;

      ldrel.l_vaddr = irel->r_vaddr;
      if (strcmp (esec->output_section->name, ".text") == 0)
	ldrel.l_symndx = 0;
      else if (strcmp (esec->output_section->name, ".data") == 0)
	ldrel.l_symndx = 1;
      else if (strcmp (esec->output_section->name, ".bss") == 0)
	ldrel.l_symndx = 2;
      else
	{
	  (*_bfd_error_handler)
	    (_("%s: loader reloc in unrecognized section `%s'"),
	     bfd_get_filename (output_bfd),
	     esec->output_section->name);
	  bfd_set_error (bfd_error_nonrepresentable_section);
	  return FALSE;
	}
      ldrel.l_rtype = (reloc_size << 8) | R_POS;
      ldrel.l_rsecnm = oindx;
      bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
      finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);

      /* There are three items to write out,
	 the address of the code
	 the address of the toc anchor
	 the environment pointer.
	 We are ignoring the environment pointer.  So set it to zero.  */
      if (bfd_xcoff_is_xcoff64 (output_bfd))
	{
	  bfd_put_64 (output_bfd,
		      (esec->output_section->vma + esec->output_offset
		       + hentry->root.u.def.value),
		      p);
	  bfd_put_64 (output_bfd, xcoff_data (output_bfd)->toc, p + 8);
	  bfd_put_64 (output_bfd, (bfd_vma) 0, p + 16);
	}
      else
	{
	  /* 32 bit backend
	     This logic was already called above so the error case where
	     the backend is neither has already been checked.  */
	  bfd_put_32 (output_bfd,
		      (esec->output_section->vma + esec->output_offset
		       + hentry->root.u.def.value),
		      p);
	  bfd_put_32 (output_bfd, xcoff_data (output_bfd)->toc, p + 4);
	  bfd_put_32 (output_bfd, (bfd_vma) 0, p + 8);
	}

      tsec = coff_section_from_bfd_index (output_bfd,
					  xcoff_data (output_bfd)->sntoc);

      ++irel;
      irel->r_vaddr = (osec->vma
		       + sec->output_offset
		       + h->root.u.def.value
		       + byte_size);
      irel->r_symndx = tsec->output_section->target_index;
      irel->r_type = R_POS;
      irel->r_size = reloc_size;
      finfo->section_info[oindx].rel_hashes[osec->reloc_count] = NULL;
      ++osec->reloc_count;

      ldrel.l_vaddr = irel->r_vaddr;
      if (strcmp (tsec->output_section->name, ".text") == 0)
	ldrel.l_symndx = 0;
      else if (strcmp (tsec->output_section->name, ".data") == 0)
	ldrel.l_symndx = 1;
      else if (strcmp (tsec->output_section->name, ".bss") == 0)
	ldrel.l_symndx = 2;
      else
	{
	  (*_bfd_error_handler)
	    (_("%s: loader reloc in unrecognized section `%s'"),
	     bfd_get_filename (output_bfd),
	     tsec->output_section->name);
	  bfd_set_error (bfd_error_nonrepresentable_section);
	  return FALSE;
	}
      ldrel.l_rtype = (reloc_size << 8) | R_POS;
      ldrel.l_rsecnm = oindx;
      bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
      finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);
    }

  if (h->indx >= 0 || finfo->info->strip == strip_all)
    {
      BFD_ASSERT (outsym == finfo->outsyms);
      return TRUE;
    }

  if (h->indx != -2
      && (finfo->info->strip == strip_all
	  || (finfo->info->strip == strip_some
	      && bfd_hash_lookup (finfo->info->keep_hash, h->root.root.string,
				  FALSE, FALSE) == NULL)))
    {
      BFD_ASSERT (outsym == finfo->outsyms);
      return TRUE;
    }

  if (h->indx != -2
      && (h->flags & (XCOFF_REF_REGULAR | XCOFF_DEF_REGULAR)) == 0)
    {
      BFD_ASSERT (outsym == finfo->outsyms);
      return TRUE;
    }

  memset (&aux, 0, sizeof aux);

  h->indx = obj_raw_syment_count (output_bfd);

  result = bfd_xcoff_put_symbol_name (output_bfd, finfo->strtab, &isym,
				      h->root.root.string);
  if (!result)
    return FALSE;

  if (h->root.type == bfd_link_hash_undefined
      || h->root.type == bfd_link_hash_undefweak)
    {
      isym.n_value = 0;
      isym.n_scnum = N_UNDEF;
      isym.n_sclass = C_EXT;
      aux.x_csect.x_smtyp = XTY_ER;
    }
  else if ((h->root.type == bfd_link_hash_defined
	    || h->root.type == bfd_link_hash_defweak)
	   && h->smclas == XMC_XO)
    {
      BFD_ASSERT (bfd_is_abs_section (h->root.u.def.section));
      isym.n_value = h->root.u.def.value;
      isym.n_scnum = N_UNDEF;
      isym.n_sclass = C_EXT;
      aux.x_csect.x_smtyp = XTY_ER;
    }
  else if (h->root.type == bfd_link_hash_defined
	   || h->root.type == bfd_link_hash_defweak)
    {
      struct xcoff_link_size_list *l;

      isym.n_value = (h->root.u.def.section->output_section->vma
		      + h->root.u.def.section->output_offset
		      + h->root.u.def.value);
      if (bfd_is_abs_section (h->root.u.def.section->output_section))
	isym.n_scnum = N_ABS;
      else
	isym.n_scnum = h->root.u.def.section->output_section->target_index;
      isym.n_sclass = C_HIDEXT;
      aux.x_csect.x_smtyp = XTY_SD;

      if ((h->flags & XCOFF_HAS_SIZE) != 0)
	{
	  for (l = xcoff_hash_table (finfo->info)->size_list;
	       l != NULL;
	       l = l->next)
	    {
	      if (l->h == h)
		{
		  aux.x_csect.x_scnlen.l = l->size;
		  break;
		}
	    }
	}
    }
  else if (h->root.type == bfd_link_hash_common)
    {
      isym.n_value = (h->root.u.c.p->section->output_section->vma
		      + h->root.u.c.p->section->output_offset);
      isym.n_scnum = h->root.u.c.p->section->output_section->target_index;
      isym.n_sclass = C_EXT;
      aux.x_csect.x_smtyp = XTY_CM;
      aux.x_csect.x_scnlen.l = h->root.u.c.size;
    }
  else
    abort ();

  isym.n_type = T_NULL;
  isym.n_numaux = 1;

  bfd_coff_swap_sym_out (output_bfd, (PTR) &isym, (PTR) outsym);
  outsym += bfd_coff_symesz (output_bfd);

  aux.x_csect.x_smclas = h->smclas;
  bfd_coff_swap_aux_out (output_bfd, (PTR) &aux, T_NULL, isym.n_sclass, 0, 1,
			 (PTR) outsym);
  outsym += bfd_coff_auxesz (output_bfd);

  if ((h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak)
      && h->smclas != XMC_XO)
    {
      /* We just output an SD symbol.  Now output an LD symbol.  */

      h->indx += 2;

      isym.n_sclass = C_EXT;
      bfd_coff_swap_sym_out (output_bfd, (PTR) &isym, (PTR) outsym);
      outsym += bfd_coff_symesz (output_bfd);

      aux.x_csect.x_smtyp = XTY_LD;
      aux.x_csect.x_scnlen.l = obj_raw_syment_count (output_bfd);
      bfd_coff_swap_aux_out (output_bfd, (PTR) &aux, T_NULL, C_EXT, 0, 1,
			     (PTR) outsym);
      outsym += bfd_coff_auxesz (output_bfd);
    }

  pos = obj_sym_filepos (output_bfd);
  pos += obj_raw_syment_count (output_bfd) * bfd_coff_symesz (output_bfd);
  amt = outsym - finfo->outsyms;
  if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
      || bfd_bwrite (finfo->outsyms, amt, output_bfd) != amt)
    return FALSE;
  obj_raw_syment_count (output_bfd) +=
    (outsym - finfo->outsyms) / bfd_coff_symesz (output_bfd);

  return TRUE;
}

/* Handle a link order which is supposed to generate a reloc.  */

static bfd_boolean
xcoff_reloc_link_order (output_bfd, finfo, output_section, link_order)
     bfd *output_bfd;
     struct xcoff_final_link_info *finfo;
     asection *output_section;
     struct bfd_link_order *link_order;
{
  reloc_howto_type *howto;
  struct xcoff_link_hash_entry *h;
  asection *hsec;
  bfd_vma hval;
  bfd_vma addend;
  struct internal_reloc *irel;
  struct xcoff_link_hash_entry **rel_hash_ptr;
  struct internal_ldrel ldrel;

  if (link_order->type == bfd_section_reloc_link_order)
    {
      /* We need to somehow locate a symbol in the right section.  The
	 symbol must either have a value of zero, or we must adjust
	 the addend by the value of the symbol.  FIXME: Write this
	 when we need it.  The old linker couldn't handle this anyhow.  */
      abort ();
    }

  howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);
  if (howto == NULL)
    {
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  h = ((struct xcoff_link_hash_entry *)
       bfd_wrapped_link_hash_lookup (output_bfd, finfo->info,
				     link_order->u.reloc.p->u.name,
				     FALSE, FALSE, TRUE));
  if (h == NULL)
    {
      if (! ((*finfo->info->callbacks->unattached_reloc)
	     (finfo->info, link_order->u.reloc.p->u.name, (bfd *) NULL,
	      (asection *) NULL, (bfd_vma) 0)))
	return FALSE;
      return TRUE;
    }

  if (h->root.type == bfd_link_hash_common)
    {
      hsec = h->root.u.c.p->section;
      hval = 0;
    }
  else if (h->root.type == bfd_link_hash_defined
	   || h->root.type == bfd_link_hash_defweak)
    {
      hsec = h->root.u.def.section;
      hval = h->root.u.def.value;
    }
  else
    {
      hsec = NULL;
      hval = 0;
    }

  addend = link_order->u.reloc.p->addend;
  if (hsec != NULL)
    addend += (hsec->output_section->vma
	       + hsec->output_offset
	       + hval);

  if (addend != 0)
    {
      bfd_size_type size;
      bfd_byte *buf;
      bfd_reloc_status_type rstat;
      bfd_boolean ok;

      size = bfd_get_reloc_size (howto);
      buf = (bfd_byte *) bfd_zmalloc (size);
      if (buf == NULL)
	return FALSE;

      rstat = _bfd_relocate_contents (howto, output_bfd, addend, buf);
      switch (rstat)
	{
	case bfd_reloc_ok:
	  break;
	default:
	case bfd_reloc_outofrange:
	  abort ();
	case bfd_reloc_overflow:
	  if (! ((*finfo->info->callbacks->reloc_overflow)
		 (finfo->info, link_order->u.reloc.p->u.name,
		  howto->name, addend, (bfd *) NULL, (asection *) NULL,
		  (bfd_vma) 0)))
	    {
	      free (buf);
	      return FALSE;
	    }
	  break;
	}
      ok = bfd_set_section_contents (output_bfd, output_section, (PTR) buf,
				     (file_ptr) link_order->offset, size);
      free (buf);
      if (! ok)
	return FALSE;
    }

  /* Store the reloc information in the right place.  It will get
     swapped and written out at the end of the final_link routine.  */

  irel = (finfo->section_info[output_section->target_index].relocs
	  + output_section->reloc_count);
  rel_hash_ptr = (finfo->section_info[output_section->target_index].rel_hashes
		  + output_section->reloc_count);

  memset (irel, 0, sizeof (struct internal_reloc));
  *rel_hash_ptr = NULL;

  irel->r_vaddr = output_section->vma + link_order->offset;

  if (h->indx >= 0)
    irel->r_symndx = h->indx;
  else
    {
      /* Set the index to -2 to force this symbol to get written out.  */
      h->indx = -2;
      *rel_hash_ptr = h;
      irel->r_symndx = 0;
    }

  irel->r_type = howto->type;
  irel->r_size = howto->bitsize - 1;
  if (howto->complain_on_overflow == complain_overflow_signed)
    irel->r_size |= 0x80;

  ++output_section->reloc_count;

  /* Now output the reloc to the .loader section.  */

  ldrel.l_vaddr = irel->r_vaddr;

  if (hsec != NULL)
    {
      const char *secname;

      secname = hsec->output_section->name;

      if (strcmp (secname, ".text") == 0)
	ldrel.l_symndx = 0;
      else if (strcmp (secname, ".data") == 0)
	ldrel.l_symndx = 1;
      else if (strcmp (secname, ".bss") == 0)
	ldrel.l_symndx = 2;
      else
	{
	  (*_bfd_error_handler)
	    (_("%s: loader reloc in unrecognized section `%s'"),
	     bfd_get_filename (output_bfd), secname);
	  bfd_set_error (bfd_error_nonrepresentable_section);
	  return FALSE;
	}
    }
  else
    {
      if (h->ldindx < 0)
	{
	  (*_bfd_error_handler)
	    (_("%s: `%s' in loader reloc but not loader sym"),
	     bfd_get_filename (output_bfd),
	     h->root.root.string);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      ldrel.l_symndx = h->ldindx;
    }

  ldrel.l_rtype = (irel->r_size << 8) | irel->r_type;
  ldrel.l_rsecnm = output_section->target_index;
  bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
  finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);

  return TRUE;
}

/* Sort relocs by VMA.  This is called via qsort.  */

static int
xcoff_sort_relocs (p1, p2)
     const PTR p1;
     const PTR p2;
{
  const struct internal_reloc *r1 = (const struct internal_reloc *) p1;
  const struct internal_reloc *r2 = (const struct internal_reloc *) p2;

  if (r1->r_vaddr > r2->r_vaddr)
    return 1;
  else if (r1->r_vaddr < r2->r_vaddr)
    return -1;
  else
    return 0;
}




@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d1251 1
a1251 1
	      /* explict cast to bfd_signed_vma for compiler */
d1830 1
a1830 1
		  else if ((*sym_hash)->root.next != NULL
d2901 1
a2901 1
      /* __rtinit initalized */
d2935 1
a2935 1
  if (info->relocateable
d5297 1
a5297 1
		      if (! finfo->info->relocateable
@


1.6
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000
d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d27 1
d29 1
a34 52
/* Get the XCOFF hash table entries for a BFD.  */
#define obj_xcoff_sym_hashes(bfd) \
  ((struct xcoff_link_hash_entry **) obj_coff_sym_hashes (bfd))

/* XCOFF relocation types.  These probably belong in a header file
   somewhere.  The relocations are described in the function
   _bfd_ppc_xcoff_relocate_section in this file.  */

#define R_POS   (0x00)
#define R_NEG   (0x01)
#define R_REL   (0x02)
#define R_TOC   (0x03)
#define R_RTB   (0x04)
#define R_GL    (0x05)
#define R_TCL   (0x06)
#define R_BA    (0x08)
#define R_BR    (0x0a)
#define R_RL    (0x0c)
#define R_RLA   (0x0d)
#define R_REF   (0x0f)
#define R_TRL   (0x12)
#define R_TRLA  (0x13)
#define R_RRTBI (0x14)
#define R_RRTBA (0x15)
#define R_CAI   (0x16)
#define R_CREL  (0x17)
#define R_RBA   (0x18)
#define R_RBAC  (0x19)
#define R_RBR   (0x1a)
#define R_RBRC  (0x1b)

/* The first word of global linkage code.  This must be modified by
   filling in the correct TOC offset.  */

#define XCOFF_GLINK_FIRST (0x81820000)	/* lwz r12,0(r2) */

/* The remaining words of global linkage code.  */

static unsigned long xcoff_glink_code[] = {
  0x90410014,	/* stw r2,20(r1) */
  0x800c0000,	/* lwz r0,0(r12) */
  0x804c0004,	/* lwz r2,4(r12) */
  0x7c0903a6,	/* mtctr r0 */
  0x4e800420,	/* bctr */
  0x0,		/* start of traceback table */
  0x000c8000,	/* traceback table */
  0x0		/* traceback table */
};

#define XCOFF_GLINK_SIZE \
  (((sizeof xcoff_glink_code / sizeof xcoff_glink_code[0]) * 4) + 4)

a39 117
/* The ldhdr structure.  This appears at the start of the .loader
   section.  */

struct internal_ldhdr {
  /* The version number: currently always 1.  */
  unsigned long l_version;
  /* The number of symbol table entries.  */
  bfd_size_type l_nsyms;
  /* The number of relocation table entries.  */
  bfd_size_type l_nreloc;
  /* The length of the import file string table.  */
  bfd_size_type l_istlen;
  /* The number of import files.  */
  bfd_size_type l_nimpid;
  /* The offset from the start of the .loader section to the first
     entry in the import file table.  */
  bfd_size_type l_impoff;
  /* The length of the string table.  */
  bfd_size_type l_stlen;
  /* The offset from the start of the .loader section to the first
     entry in the string table.  */
  bfd_size_type l_stoff;
};

struct external_ldhdr {
  bfd_byte l_version[4];
  bfd_byte l_nsyms[4];
  bfd_byte l_nreloc[4];
  bfd_byte l_istlen[4];
  bfd_byte l_nimpid[4];
  bfd_byte l_impoff[4];
  bfd_byte l_stlen[4];
  bfd_byte l_stoff[4];
};

#define LDHDRSZ (8 * 4)

/* The ldsym structure.  This is used to represent a symbol in the
   .loader section.  */

struct internal_ldsym {
  union {
    /* The symbol name if <= SYMNMLEN characters.  */
    char _l_name[SYMNMLEN];
    struct {
      /* Zero if the symbol name is more than SYMNMLEN characters.  */
      long _l_zeroes;
      /* The offset in the string table if the symbol name is more
	 than SYMNMLEN characters.  */
      long _l_offset;
    } _l_l;
  } _l;
  /* The symbol value.  */
  bfd_vma l_value;
  /* The symbol section number.  */
  short l_scnum;
  /* The symbol type and flags.  */
  char l_smtype;
  /* The symbol storage class.  */
  char l_smclas;
  /* The import file ID.  */
  bfd_size_type l_ifile;
  /* Offset to the parameter type check string.  */
  bfd_size_type l_parm;
};

struct external_ldsym {
  union {
    bfd_byte _l_name[SYMNMLEN];
    struct {
      bfd_byte _l_zeroes[4];
      bfd_byte _l_offset[4];
    } _l_l;
  } _l;
  bfd_byte l_value[4];
  bfd_byte l_scnum[2];
  bfd_byte l_smtype[1];
  bfd_byte l_smclas[1];
  bfd_byte l_ifile[4];
  bfd_byte l_parm[4];
};

#define LDSYMSZ (8 + 3 * 4 + 2 + 2)

/* These flags are for the l_smtype field (the lower three bits are an
   XTY_* value).  */

/* Imported symbol.  */
#define L_IMPORT (0x40)
/* Entry point.  */
#define L_ENTRY (0x20)
/* Exported symbol.  */
#define L_EXPORT (0x10)

/* The ldrel structure.  This is used to represent a reloc in the
   .loader section.  */

struct internal_ldrel {
  /* The reloc address.  */
  bfd_vma l_vaddr;
  /* The symbol table index in the .loader section symbol table.  */
  bfd_size_type l_symndx;
  /* The relocation type and size.  */
  short l_rtype;
  /* The section number this relocation applies to.  */
  short l_rsecnm;
};

struct external_ldrel {
  bfd_byte l_vaddr[4];
  bfd_byte l_symndx[4];
  bfd_byte l_rtype[2];
  bfd_byte l_rsecnm[2];
};

#define LDRELSZ (2 * 4 + 2 * 2)

d42 2
a43 1
struct xcoff_import_file {
a53 128
/* An entry in the XCOFF linker hash table.  */

struct xcoff_link_hash_entry {
  struct bfd_link_hash_entry root;

  /* Symbol index in output file.  Set to -1 initially.  Set to -2 if
     there is a reloc against this symbol.  */
  long indx;

  /* If we have created a TOC entry for this symbol, this is the .tc
     section which holds it.  */
  asection *toc_section;

  union {
    /* If we have created a TOC entry (the XCOFF_SET_TOC flag is set),
       this is the offset in toc_section.  */
    bfd_vma toc_offset;
    /* If the TOC entry comes from an input file, this is set to the
       symbol index of the C_HIDEXT XMC_TC or XMC_TD symbol.  */
    long toc_indx;
  } u;

  /* If this symbol is a function entry point which is called, this
     field holds a pointer to the function descriptor.  If this symbol
     is a function descriptor, this field holds a pointer to the
     function entry point.  */
  struct xcoff_link_hash_entry *descriptor;

  /* The .loader symbol table entry, if there is one.  */
  struct internal_ldsym *ldsym;

  /* If XCOFF_BUILT_LDSYM is set, this is the .loader symbol table
     index.  If XCOFF_BUILD_LDSYM is clear, and XCOFF_IMPORT is set,
     this is the l_ifile value.  */
  long ldindx;

  /* Some linker flags.  */
  unsigned short flags;
  /* Symbol is referenced by a regular object.  */
#define XCOFF_REF_REGULAR (01)
  /* Symbol is defined by a regular object.  */
#define XCOFF_DEF_REGULAR (02)
  /* Symbol is defined by a dynamic object.  */
#define XCOFF_DEF_DYNAMIC (04)
  /* Symbol is used in a reloc being copied into the .loader section.  */
#define XCOFF_LDREL (010)
  /* Symbol is the entry point.  */
#define XCOFF_ENTRY (020)
  /* Symbol is called; this is, it appears in a R_BR reloc.  */
#define XCOFF_CALLED (040)
  /* Symbol needs the TOC entry filled in.  */
#define XCOFF_SET_TOC (0100)
  /* Symbol is explicitly imported.  */
#define XCOFF_IMPORT (0200)
  /* Symbol is explicitly exported.  */
#define XCOFF_EXPORT (0400)
  /* Symbol has been processed by xcoff_build_ldsyms.  */
#define XCOFF_BUILT_LDSYM (01000)
  /* Symbol is mentioned by a section which was not garbage collected.  */
#define XCOFF_MARK (02000)
  /* Symbol size is recorded in size_list list from hash table.  */
#define XCOFF_HAS_SIZE (04000)
  /* Symbol is a function descriptor.  */
#define XCOFF_DESCRIPTOR (010000)
  /* Multiple definitions have been for the symbol.  */
#define XCOFF_MULTIPLY_DEFINED (020000)

  /* The storage mapping class.  */
  unsigned char smclas;
};

/* The XCOFF linker hash table.  */

struct xcoff_link_hash_table {
  struct bfd_link_hash_table root;

  /* The .debug string hash table.  We need to compute this while
     reading the input files, so that we know how large the .debug
     section will be before we assign section positions.  */
  struct bfd_strtab_hash *debug_strtab;

  /* The .debug section we will use for the final output.  */
  asection *debug_section;

  /* The .loader section we will use for the final output.  */
  asection *loader_section;

  /* A count of non TOC relative relocs which will need to be
     allocated in the .loader section.  */
  size_t ldrel_count;

  /* The .loader section header.  */
  struct internal_ldhdr ldhdr;

  /* The .gl section we use to hold global linkage code.  */
  asection *linkage_section;

  /* The .tc section we use to hold toc entries we build for global
     linkage code.  */
  asection *toc_section;

  /* The .ds section we use to hold function descriptors which we
     create for exported symbols.  */
  asection *descriptor_section;

  /* The list of import files.  */
  struct xcoff_import_file *imports;

  /* Required alignment of sections within the output file.  */
  unsigned long file_align;

  /* Whether the .text section must be read-only.  */
  boolean textro;

  /* Whether garbage collection was done.  */
  boolean gc;

  /* A linked list of symbols for which we have size information.  */
  struct xcoff_link_size_list {
    struct xcoff_link_size_list *next;
    struct xcoff_link_hash_entry *h;
    bfd_size_type size;
  } *size_list;

  /* Magic sections: _text, _etext, _data, _edata, _end, end.  */
  asection *special_sections[6];
};

d57 2
a58 1
struct xcoff_link_section_info {
d77 2
a78 1
struct xcoff_final_link_info {
d95 1
a95 1
  struct external_ldsym *ldsym;
d97 1
a97 1
  struct external_ldrel *ldrel;
a115 12
static void xcoff_swap_ldhdr_in
  PARAMS ((bfd *, const struct external_ldhdr *, struct internal_ldhdr *));
static void xcoff_swap_ldhdr_out
  PARAMS ((bfd *, const struct internal_ldhdr *, struct external_ldhdr *));
static void xcoff_swap_ldsym_in
  PARAMS ((bfd *, const struct external_ldsym *, struct internal_ldsym *));
static void xcoff_swap_ldsym_out
  PARAMS ((bfd *, const struct internal_ldsym *, struct external_ldsym *));
static void xcoff_swap_ldrel_in
  PARAMS ((bfd *, const struct external_ldrel *, struct internal_ldrel *));
static void xcoff_swap_ldrel_out
  PARAMS ((bfd *, const struct internal_ldrel *, struct external_ldrel *));
d118 1
a118 1
static boolean xcoff_get_section_contents PARAMS ((bfd *, asection *));
d120 1
a120 1
  PARAMS ((bfd *, asection *, boolean, bfd_byte *, boolean,
d122 1
a122 1
static boolean xcoff_link_add_object_symbols
d124 6
a129 6
static boolean xcoff_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, boolean *));
static boolean xcoff_link_check_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, boolean *));
static boolean xcoff_link_check_dynamic_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, boolean *));
d132 3
a134 2
static boolean xcoff_link_add_symbols PARAMS ((bfd *, struct bfd_link_info *));
static boolean xcoff_link_add_dynamic_symbols
d136 1
a136 1
static boolean xcoff_mark_symbol
d138 1
a138 1
static boolean xcoff_mark PARAMS ((struct bfd_link_info *, asection *));
d140 1
a140 1
static boolean xcoff_build_ldsyms
d142 1
a142 1
static boolean xcoff_link_input_bfd
d144 1
a144 1
static boolean xcoff_write_global_symbol
d146 1
a146 1
static boolean xcoff_reloc_link_order
a150 40
/* Routines to swap information in the XCOFF .loader section.  If we
   ever need to write an XCOFF loader, this stuff will need to be
   moved to another file shared by the linker (which XCOFF calls the
   ``binder'') and the loader.  */

/* Swap in the ldhdr structure.  */

static void
xcoff_swap_ldhdr_in (abfd, src, dst)
     bfd *abfd;
     const struct external_ldhdr *src;
     struct internal_ldhdr *dst;
{
  dst->l_version = bfd_get_32 (abfd, src->l_version);
  dst->l_nsyms = bfd_get_32 (abfd, src->l_nsyms);
  dst->l_nreloc = bfd_get_32 (abfd, src->l_nreloc);
  dst->l_istlen = bfd_get_32 (abfd, src->l_istlen);
  dst->l_nimpid = bfd_get_32 (abfd, src->l_nimpid);
  dst->l_impoff = bfd_get_32 (abfd, src->l_impoff);
  dst->l_stlen = bfd_get_32 (abfd, src->l_stlen);
  dst->l_stoff = bfd_get_32 (abfd, src->l_stoff);
}

/* Swap out the ldhdr structure.  */

static void
xcoff_swap_ldhdr_out (abfd, src, dst)
     bfd *abfd;
     const struct internal_ldhdr *src;
     struct external_ldhdr *dst;
{
  bfd_put_32 (abfd, src->l_version, dst->l_version);
  bfd_put_32 (abfd, src->l_nsyms, dst->l_nsyms);
  bfd_put_32 (abfd, src->l_nreloc, dst->l_nreloc);
  bfd_put_32 (abfd, src->l_istlen, dst->l_istlen);
  bfd_put_32 (abfd, src->l_nimpid, dst->l_nimpid);
  bfd_put_32 (abfd, src->l_impoff, dst->l_impoff);
  bfd_put_32 (abfd, src->l_stlen, dst->l_stlen);
  bfd_put_32 (abfd, src->l_stoff, dst->l_stoff);
}
a151 74
/* Swap in the ldsym structure.  */

static void
xcoff_swap_ldsym_in (abfd, src, dst)
     bfd *abfd;
     const struct external_ldsym *src;
     struct internal_ldsym *dst;
{
  if (bfd_get_32 (abfd, src->_l._l_l._l_zeroes) != 0)
    memcpy (dst->_l._l_name, src->_l._l_name, SYMNMLEN);
  else
    {
      dst->_l._l_l._l_zeroes = 0;
      dst->_l._l_l._l_offset = bfd_get_32 (abfd, src->_l._l_l._l_offset);
    }
  dst->l_value = bfd_get_32 (abfd, src->l_value);
  dst->l_scnum = bfd_get_16 (abfd, src->l_scnum);
  dst->l_smtype = bfd_get_8 (abfd, src->l_smtype);
  dst->l_smclas = bfd_get_8 (abfd, src->l_smclas);
  dst->l_ifile = bfd_get_32 (abfd, src->l_ifile);
  dst->l_parm = bfd_get_32 (abfd, src->l_parm);
}

/* Swap out the ldsym structure.  */

static void
xcoff_swap_ldsym_out (abfd, src, dst)
     bfd *abfd;
     const struct internal_ldsym *src;
     struct external_ldsym *dst;
{
  if (src->_l._l_l._l_zeroes != 0)
    memcpy (dst->_l._l_name, src->_l._l_name, SYMNMLEN);
  else
    {
      bfd_put_32 (abfd, 0, dst->_l._l_l._l_zeroes);
      bfd_put_32 (abfd, src->_l._l_l._l_offset, dst->_l._l_l._l_offset);
    }
  bfd_put_32 (abfd, src->l_value, dst->l_value);
  bfd_put_16 (abfd, src->l_scnum, dst->l_scnum);
  bfd_put_8 (abfd, src->l_smtype, dst->l_smtype);
  bfd_put_8 (abfd, src->l_smclas, dst->l_smclas);
  bfd_put_32 (abfd, src->l_ifile, dst->l_ifile);
  bfd_put_32 (abfd, src->l_parm, dst->l_parm);
}

/* Swap in the ldrel structure.  */

static void
xcoff_swap_ldrel_in (abfd, src, dst)
     bfd *abfd;
     const struct external_ldrel *src;
     struct internal_ldrel *dst;
{
  dst->l_vaddr = bfd_get_32 (abfd, src->l_vaddr);
  dst->l_symndx = bfd_get_32 (abfd, src->l_symndx);
  dst->l_rtype = bfd_get_16 (abfd, src->l_rtype);
  dst->l_rsecnm = bfd_get_16 (abfd, src->l_rsecnm);
}

/* Swap out the ldrel structure.  */

static void
xcoff_swap_ldrel_out (abfd, src, dst)
     bfd *abfd;
     const struct internal_ldrel *src;
     struct external_ldrel *dst;
{
  bfd_put_32 (abfd, src->l_vaddr, dst->l_vaddr);
  bfd_put_32 (abfd, src->l_symndx, dst->l_symndx);
  bfd_put_16 (abfd, src->l_rtype, dst->l_rtype);
  bfd_put_16 (abfd, src->l_rsecnm, dst->l_rsecnm);
}

d158 1
a158 1
static boolean
d163 1
d166 2
a167 2
      sec->used_by_bfd = bfd_zalloc (abfd,
				     sizeof (struct coff_section_tdata));
d169 1
a169 1
	return false;
d174 2
a175 2
      coff_section_data (abfd, sec)->contents =
	(bfd_byte *) bfd_malloc (sec->_raw_size);
d177 1
a177 1
	return false;
d182 1
a182 1
	return false;
d185 1
a185 1
  return true;
d215 1
a215 1
  xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) contents, &ldhdr);
d231 1
a231 1
  struct external_ldsym *elsym, *elsymend;
d251 1
a251 1
  coff_section_data (abfd, lsec)->keep_contents = true;
d253 1
a253 1
  xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) contents, &ldhdr);
d262 4
a265 3
  elsym = (struct external_ldsym *) (contents + LDHDRSZ);
  elsymend = elsym + ldhdr.l_nsyms;
  for (; elsym < elsymend; elsym++, symbuf++, psyms++)
d269 1
a269 1
      xcoff_swap_ldsym_in (abfd, elsym, &ldsym);
d277 1
a277 10
	  int i;

	  for (i = 0; i < SYMNMLEN; i++)
	    if (ldsym._l._l_name[i] == '\0')
	      break;
	  if (i < SYMNMLEN)
	    symbuf->symbol.name = (char *) elsym->_l._l_name;
	  else
	    {
	      char *c;
d279 6
a284 7
	      c = bfd_alloc (abfd, SYMNMLEN + 1);
	      if (c == NULL)
		return -1;
	      memcpy (c, ldsym._l._l_name, SYMNMLEN);
	      c[SYMNMLEN] = '\0';
	      symbuf->symbol.name = c;
	    }
d299 1
a299 1
         with the loader symbol.  */
d336 1
a336 1
  xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) contents, &ldhdr);
a340 17
/* The typical dynamic reloc.  */

static reloc_howto_type xcoff_dynamic_reloc =
  HOWTO (0,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_POS",               /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 false);                /* pcrel_offset */

d353 1
a353 1
  struct external_ldrel *elrel, *elrelend;
d372 1
a372 1
  xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) contents, &ldhdr);
d378 5
a382 4
  elrel = ((struct external_ldrel *)
	   (contents + LDHDRSZ + ldhdr.l_nsyms * LDSYMSZ));
  elrelend = elrel + ldhdr.l_nreloc;
  for (; elrel < elrelend; elrel++, relbuf++, prelocs++)
d386 1
a386 1
      xcoff_swap_ldrel_in (abfd, elrel, &ldrel);
d425 3
a427 3
         correct if ldrel.l_rtype == 0.  In other cases, we should use
         a different howto.  */
      relbuf->howto = &xcoff_dynamic_reloc;
d484 1
d486 1
a486 2
  ret = ((struct xcoff_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct xcoff_link_hash_table)));
d491 1
a491 1
      bfd_release (abfd, ret);
d505 2
a506 2
  ret->textro = false;
  ret->gc = false;
d512 1
a512 1
  xcoff_data (abfd)->full_aouthdr = true;
d517 1
a517 1
/* Look up an entry in an XCOFF link hash table.  */
d519 5
a523 4
#define xcoff_link_hash_lookup(table, string, create, copy, follow) \
  ((struct xcoff_link_hash_entry *) \
   bfd_link_hash_lookup (&(table)->root, (string), (create), (copy),\
			 (follow)))
d525 4
a528 12
/* Traverse an XCOFF link hash table.  */

#define xcoff_link_hash_traverse(table, func, info)			\
  (bfd_link_hash_traverse						\
   (&(table)->root,							\
    (boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func),	\
    (info)))

/* Get the XCOFF link hash table from the info structure.  This is
   just a cast.  */

#define xcoff_hash_table(p) ((struct xcoff_link_hash_table *) ((p)->hash))
d539 1
a539 1
     boolean cache;
d541 1
a541 1
     boolean require_internal;
d544 1
d559 2
a560 2
	  if (_bfd_coff_read_internal_relocs (abfd, enclosing, true,
					      external_relocs, false,
d574 1
d591 1
a591 1
boolean
d596 1
d604 5
a608 5
         to check the archive for stripped dynamic objects, because
         they will not appear in the archive map even though they
         should, perhaps, be included.  If the archive has no map, we
         just consider each object file in turn, since that apparently
         is what the AIX native linker does.  */
d613 1
a613 1
	    return false;
d623 2
a624 3
		&& (! bfd_has_map (abfd)
		    || ((member->flags & DYNAMIC) != 0
			&& (member->flags & HAS_SYMS) == 0)))
d626 1
a626 1
		boolean needed;
d628 3
a630 2
		if (! xcoff_link_check_archive_element (member, info, &needed))
		  return false;
d638 1
a638 1
      return true;
d642 1
a642 1
      return false;
d648 1
a648 1
static boolean
d653 1
d655 1
a655 1
    return false;
d657 1
a657 1
    return false;
d661 1
a661 1
	return false;
d663 1
a663 1
  return true;
d671 1
a671 1
static boolean
d675 1
a675 1
     boolean *pneeded;
d677 1
d679 1
a679 1
    return false;
d682 1
a682 1
    return false;
d687 1
a687 1
	return false;
d693 1
a693 1
	return false;
d696 1
a696 1
  return true;
d702 1
a702 1
static boolean
d706 1
a706 1
     boolean *pneeded;
d712 1
a712 1
  *pneeded = false;
d735 1
a735 1
             object file.  */
d738 1
d740 2
a741 2
	    return false;
	  h = bfd_link_hash_lookup (info->hash, name, false, false, true);
d750 1
a750 1
	      && (info->hash->creator != abfd->xvec
d755 3
a757 3
		return false;
	      *pneeded = true;
	      return true;
d765 1
a765 1
  return true;
d772 1
a772 1
static boolean
d776 1
a776 1
     boolean *pneeded;
d779 1
a779 1
  bfd_byte *buf;
d782 1
a782 1
  struct external_ldsym *elsym, *elsymend;
d784 1
a784 1
  *pneeded = false;
d790 1
a790 1
      return true;
d794 4
a797 2
    return false;
  buf = coff_section_data (abfd, lsec)->contents;
d799 1
a799 1
  xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) buf, &ldhdr);
d801 1
a801 1
  strings = (char *) buf + ldhdr.l_stoff;
d803 2
a804 3
  elsym = (struct external_ldsym *) (buf + LDHDRSZ);
  elsymend = elsym + ldhdr.l_nsyms;
  for (; elsym < elsymend; elsym++)
d811 1
a811 1
      xcoff_swap_ldsym_in (abfd, elsym, &ldsym);
d826 1
a826 1
      h = bfd_link_hash_lookup (info->hash, name, false, false, true);
d829 2
a830 2
         undefined.  At this point we know that we are using an XCOFF
         hash table.  */
d837 3
a839 3
	    return false;
	  *pneeded = true;
	  return true;
d845 1
a845 1
  if (buf != NULL && ! coff_section_data (abfd, lsec)->keep_contents)
d851 1
a851 1
  return true;
a903 1
/* Add all the symbols from an object file to the hash table.
d905 1
a905 9
   XCOFF is a weird format.  A normal XCOFF .o files will have three
   COFF sections--.text, .data, and .bss--but each COFF section will
   contain many csects.  These csects are described in the symbol
   table.  From the linker's point of view, each csect must be
   considered a section in its own right.  For example, a TOC entry is
   handled as a small XMC_TC csect.  The linker must be able to merge
   different TOC entries together, which means that it must be able to
   extract the XMC_TC csects from the .data section of the input .o
   file.
d907 1
a907 5
   From the point of view of our linker, this is, of course, a hideous
   nightmare.  We cope by actually creating sections for each csect,
   and discarding the original sections.  We then have to handle the
   relocation entries carefully, since the only way to tell which
   csect they belong to is to examine the address.  */
d909 2
a910 4
static boolean
xcoff_link_add_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
a911 22
  unsigned int n_tmask;
  unsigned int n_btshft;
  boolean default_copy;
  bfd_size_type symcount;
  struct xcoff_link_hash_entry **sym_hash;
  asection **csect_cache;
  bfd_size_type linesz;
  asection *o;
  asection *last_real;
  boolean keep_syms;
  asection *csect;
  unsigned int csect_index;
  asection *first_csect;
  bfd_size_type symesz;
  bfd_byte *esym;
  bfd_byte *esym_end;
  struct reloc_info_struct
    {
      struct internal_reloc *relocs;
      asection **csects;
      bfd_byte *linenos;
    } *reloc_info = NULL;
d913 1
a913 1
  keep_syms = obj_coff_keep_syms (abfd);
d915 1
a915 2
  if ((abfd->flags & DYNAMIC) != 0
      && ! info->static_link)
a916 3
      if (! xcoff_link_add_dynamic_symbols (abfd, info))
	return false;
    }
a917 2
  if (info->hash->creator == abfd->xvec)
    {
d921 1
d928 3
a930 1
	    goto error_return;
d934 1
d942 4
a945 1
	    goto error_return;
d951 1
d959 4
a962 1
	    goto error_return;
d968 1
d976 4
a979 1
	    goto error_return;
d985 1
d994 3
a996 1
	    goto error_return;
d1002 56
d1060 12
a1071 1
    return true;
d1081 1
a1081 1
    default_copy = false;
d1083 1
a1083 1
    default_copy = true;
d1089 2
a1090 4
  sym_hash = ((struct xcoff_link_hash_entry **)
	      bfd_alloc (abfd,
			 (symcount
			  * sizeof (struct xcoff_link_hash_entry *))));
a1093 2
  memset (sym_hash, 0,
	  (size_t) symcount * sizeof (struct xcoff_link_hash_entry *));
d1098 2
a1099 2
  csect_cache = ((asection **)
		 bfd_alloc (abfd, symcount * sizeof (asection *)));
a1102 1
  memset (csect_cache, 0, (size_t) symcount * sizeof (asection *));
d1109 3
a1111 3
  reloc_info = ((struct reloc_info_struct *)
		bfd_malloc ((abfd->section_count + 1)
			    * sizeof (struct reloc_info_struct)));
a1113 2
  memset ((PTR) reloc_info, 0,
	  (abfd->section_count + 1) * sizeof (struct reloc_info_struct));
d1120 1
d1124 1
d1126 5
a1130 4
	    xcoff_read_internal_relocs (abfd, o, true, (bfd_byte *) NULL,
					false, (struct internal_reloc *) NULL);
	  reloc_info[o->target_index].csects =
	    (asection **) bfd_malloc (o->reloc_count * sizeof (asection *));
a1132 2
	  memset (reloc_info[o->target_index].csects, 0,
		  o->reloc_count * sizeof (asection *));
d1138 1
d1141 2
a1142 1
	  linenos = (bfd_byte *) bfd_malloc (o->lineno_count * linesz);
d1147 1
a1147 2
	      || (bfd_read (linenos, linesz, o->lineno_count, abfd)
		  != linesz * o->lineno_count))
d1149 1
d1154 1
a1154 1
  obj_coff_keep_syms (abfd) = true;
d1164 1
d1180 1
a1180 1
         information.  */
d1183 7
d1208 1
d1213 1
d1218 5
a1222 5
         and we're not stripping it, count the number of entries and
         add them to the count for this csect.  In the final link pass
         we are going to attach line number information by symbol,
         rather than by section, in order to more easily handle
         garbage collection.  */
d1228 1
d1234 1
d1238 1
a1238 1
	      bfd_size_type linoff;
d1245 1
a1245 1
		     bfd_get_filename (abfd), name);
d1251 2
a1252 1
	      if (linoff < enclosing->lineno_count * linesz)
d1281 3
a1283 3
                         useful if all the line number entries for a
                         csect are contiguous; this only matters for
                         error reporting.  */
d1298 1
a1298 1
	     bfd_get_filename (abfd), sym.n_sclass, name);
d1321 1
a1321 1
	     bfd_get_filename (abfd), name, smtyp);
d1333 1
a1333 1
		 bfd_get_filename (abfd), name, sym.n_sclass, sym.n_scnum,
d1340 1
a1340 1
             an absolute location.  */
a1351 1

d1355 1
a1355 3
		((esym
		  - (bfd_byte *) obj_coff_external_syms (abfd))
		 / symesz);
d1359 1
a1359 1
	  csect_index = -1;
d1369 1
a1369 1
		     bfd_get_filename (abfd), name, sym.n_sclass,
d1379 1
a1379 1
	     both have the same name, they are both 4 bytes long, and
d1382 9
a1390 1
	     that we must look through the relocations.  Ick.  */
d1393 5
a1397 2
	      && aux.x_csect.x_scnlen.l == 4
	      && info->hash->creator == abfd->xvec)
d1409 2
a1410 2
	      relindx = xcoff_find_reloc (relocs, enclosing->reloc_count,
					  sym.n_value);
d1412 3
d1417 5
a1421 2
		  && rel->r_size == 31
		  && rel->r_type == R_POS)
d1424 1
d1434 1
a1434 1
		      boolean copy;
d1439 1
d1446 5
a1450 4
                         the same as the symbol name.  This handles
                         the normal case, but not common cases like
                         SYM.P4 which gcc generates to store SYM + 4
                         in the TOC.  FIXME.  */
d1457 2
a1458 2
						      relname, true, copy,
						      false);
d1489 4
a1492 4
			}
		    }
		}
	    }
a1493 3
	  /* We need to create a new section.  We get the name from
	     the csect storage mapping class, so that the linker can
	     accumulate similar csects together.  */
d1495 1
a1495 6
	    static const char *csect_name_by_class[] = {
	      ".pr", ".ro", ".db", ".tc", ".ua", ".rw", ".gl", ".xo",
	      ".sv", ".bs", ".ds", ".uc", ".ti", ".tb", NULL, ".tc0",
	      ".td"
	    };
	    const char *csect_name;
d1498 6
a1503 3
	    if ((aux.x_csect.x_smclas >=
		 sizeof csect_name_by_class / sizeof csect_name_by_class[0])
		|| csect_name_by_class[aux.x_csect.x_smclas] == NULL)
a1504 4
		(*_bfd_error_handler)
		  (_("%s: symbol `%s' has unrecognized smclas %d"),
		   bfd_get_filename (abfd), name, aux.x_csect.x_smclas);
		bfd_set_error (bfd_error_bad_value);
d1508 2
a1509 4
	    csect_name = csect_name_by_class[aux.x_csect.x_smclas];
	    csect = bfd_make_section_anyway (abfd, csect_name);
	    if (csect == NULL)
	      goto error_return;
d1513 1
d1521 1
a1521 1
		   bfd_get_filename (abfd), name);
d1535 2
a1536 2
	    csect->used_by_bfd =
	      (PTR) bfd_zalloc (abfd, sizeof (struct coff_section_tdata));
d1539 2
a1540 2
	    coff_section_data (abfd, csect)->tdata =
	      bfd_zalloc (abfd, sizeof (struct xcoff_section_tdata));
d1555 3
a1557 2
		relindx = xcoff_find_reloc (relocs, enclosing->reloc_count,
					    csect->vma);
d1561 1
d1568 1
d1606 3
a1608 3
             symbol index of the csect.  I believe that this must
             always follow the appropriate XTY_SD symbol, so I will
             insist on it.  */
d1610 1
a1610 1
	    boolean bad;
d1612 1
a1612 1
	    bad = false;
d1616 1
a1616 1
	      bad = true;
d1622 1
a1622 1
		  bad = true;
d1628 1
a1628 1
		   bfd_get_filename (abfd), name);
d1632 1
a1632 1

d1639 5
a1643 5
             the storage mapping class, but we don't bother except for
             an XMC_TD symbol.  If this csect is externally visible,
             it is a common symbol.  We put XMC_TD symbols in sections
             named .tocbss, and rely on the linker script to put that
             in the TOC area.  */
d1654 6
a1659 1
	    csect = bfd_make_section_anyway (abfd, ".tocbss");
d1661 3
a1663 1
	    csect = bfd_make_section_anyway (abfd, ".bss");
d1677 2
a1678 2
	  csect->used_by_bfd =
	    (PTR) bfd_zalloc (abfd, sizeof (struct coff_section_tdata));
d1681 2
a1682 2
	  coff_section_data (abfd, csect)->tdata =
	    bfd_zalloc (abfd, sizeof (struct xcoff_section_tdata));
a1705 1
	  int i;
d1707 2
a1708 1
	  i = -1;
d1712 1
a1712 1
		i = 0;
d1714 1
a1714 1
		i = 1;
d1716 1
a1716 1
		i = 2;
d1718 1
a1718 1
		i = 3;
d1720 1
a1720 1
		i = 4;
d1723 3
a1725 1
	    i = 5;
d1728 3
a1730 1
	    xcoff_hash_table (info)->special_sections[i] = csect;
d1734 1
a1734 1
         linker hash table.  */
d1738 1
a1738 1
	  boolean copy;
d1743 1
a1743 1
             syment itself, rather than the string table.  */
d1747 1
a1747 1
	    copy = true;
d1774 1
a1774 1
	  if (info->hash->creator == abfd->xvec)
d1777 4
a1780 2
		*sym_hash = xcoff_link_hash_lookup (xcoff_hash_table (info),
						    name, true, copy, false);
d1782 8
a1789 3
		*sym_hash = ((struct xcoff_link_hash_entry *)
			     bfd_wrapped_link_hash_lookup (abfd, info, name,
							   true, copy, false));
d1805 5
a1809 5
                         either the existing symbol is not global
                         linkage code or this symbol is global linkage
                         code.  If the existing symbol is global
                         linkage code and the new symbol is not, then
                         we want to use the new symbol.  */
d1817 1
a1817 1
                         Replace it.  */
d1825 2
a1826 2
                         in an archive.  Just ignore it.  See the
                         comment above.  */
d1834 3
a1836 3
                         case, we just continue and permit the
                         multiple definition error.  See the comment
                         above about the behaviour of the AIX linker.  */
d1841 2
a1842 2
                         class.  There is at least a chance that this
                         is a semi-legitimate redefinition.  */
d1863 1
a1863 1
			  (bfd *) NULL, (asection *) NULL, 0,
d1887 1
a1887 1
		  (const char *) NULL, copy, true,
d1907 1
a1907 1
	  if (info->hash->creator == abfd->xvec)
d1951 1
d1954 1
d1959 1
a1959 1
		     bfd_get_filename (abfd), o->name, i);
d1967 1
a1967 1
	      if (info->hash->creator == abfd->xvec
d1978 8
a1985 8
                     the code of a function.  If the symbol is
                     currently undefined, then add an undefined symbol
                     for the function descriptor.  This should do no
                     harm, because any regular object that defines the
                     function should also define the function
                     descriptor.  It helps, because it means that we
                     will identify the function descriptor with a
                     dynamic object if a dynamic object defines it.  */
d1990 1
d1994 1
a1994 1
						    true, false, true);
d1999 1
d2003 2
a2004 3
				  (bfd_vma) 0, (const char *) NULL, false,
				  true,
				  (struct bfd_link_hash_entry **) &hds)))
d2006 1
d2022 1
a2022 1
	  o->flags &= ~SEC_RELOC;
d2037 1
a2037 1
         somewhere for the final link, to avoid reading them again.  */
d2049 1
a2049 1
  return true;
d2061 1
a2061 1
    free (reloc_info);
d2064 1
a2064 1
  return false;
d2073 1
a2073 1
static boolean
d2079 1
a2079 1
  bfd_byte *buf;
d2082 1
a2082 1
  struct external_ldsym *elsym, *elsymend;
d2092 1
a2092 1
  if (info->hash->creator != abfd->xvec)
d2098 1
a2098 1
      return false;
d2119 1
a2119 1
      return false;
d2122 1
d2124 2
a2125 2
    return false;
  buf = coff_section_data (abfd, lsec)->contents;
d2129 1
a2129 1
  abfd->sections = NULL;
d2131 1
a2131 1
  xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) buf, &ldhdr);
d2133 5
a2137 1
  strings = (char *) buf + ldhdr.l_stoff;
d2139 1
a2139 4
  elsym = (struct external_ldsym *) (buf + LDHDRSZ);
  elsymend = elsym + ldhdr.l_nsyms;
  BFD_ASSERT (sizeof (struct external_ldsym) == LDSYMSZ);
  for (; elsym < elsymend; elsym++)
d2146 1
a2146 1
      xcoff_swap_ldsym_in (abfd, elsym, &ldsym);
d2166 2
a2167 2
      h = xcoff_link_hash_lookup (xcoff_hash_table (info), name, true,
				  true, true);
d2169 1
a2169 1
	return false;
d2195 3
a2197 3
         define it, since we don't have a section to put it in anyhow.
         Instead, the relocation routines handle the DEF_DYNAMIC flag
         correctly.  */
d2223 1
a2223 1
	      dsnm = bfd_malloc (strlen (name) + 2);
d2225 1
a2225 1
		return false;
d2229 1
a2229 1
					    true, true, true);
d2232 1
a2232 1
		return false;
d2239 1
a2239 1
                     symbol list.  */
d2265 1
a2265 1
  if (buf != NULL && ! coff_section_data (abfd, lsec)->keep_contents)
d2274 1
a2274 1
       bfd_alloc (abfd, sizeof (struct xcoff_import_file)));
d2276 1
a2276 1
    return false;
d2309 1
a2309 1
  return true;
d2318 1
a2318 1
static INLINE boolean
d2323 1
d2325 1
a2325 1
    return true;
d2338 1
a2338 1
	    return false;
d2346 1
a2346 1
	return false;
d2349 1
a2349 1
  return true;
d2358 1
a2358 1
static boolean
d2365 1
a2365 1
    return true;
d2391 1
a2391 1
		return false;
d2400 2
a2401 2
	  rel = xcoff_read_internal_relocs (sec->owner, sec, true,
					    (bfd_byte *) NULL, false,
d2404 1
a2404 1
	    return false;
d2420 1
a2420 1
		    return false;
d2428 1
a2428 1
		    return false;
d2432 1
a2432 1
                 section.  */
d2481 1
a2481 1
  return true;
d2502 2
a2503 2
                 special sections.  Keep .debug sections for the
                 moment.  */
d2526 1
a2526 1
boolean
d2535 1
d2538 1
a2538 1
    return true;
d2544 2
a2545 2
  n = ((struct xcoff_link_size_list *)
       bfd_alloc (output_bfd, sizeof (struct xcoff_link_size_list)));
d2547 1
a2547 1
    return false;
d2555 1
a2555 1
  return true;
d2560 1
a2560 1
boolean
d2562 1
a2562 1
			 impmember)
d2570 1
d2575 1
a2575 1
    return true;
d2591 1
a2591 1
					true, false, true);
d2593 1
a2593 1
	    return false;
d2607 2
a2608 2
         rather than the symbol we were told to import.  FIXME: Is
         this correct in all cases?  */
d2613 1
a2613 1
  h->flags |= XCOFF_IMPORT;
d2625 1
a2625 1
	    return false;
d2645 1
a2645 1
         reserved for the library search path.  */
d2659 1
d2661 1
a2661 2
	  n = ((struct xcoff_import_file *)
	       bfd_alloc (output_bfd, sizeof (struct xcoff_import_file)));
d2663 1
a2663 1
	    return false;
d2674 1
a2674 1
  return true;
d2679 2
a2680 2
boolean
bfd_xcoff_export_symbol (output_bfd, info, harg, syscall)
a2683 1
     boolean syscall ATTRIBUTE_UNUSED;
d2688 1
a2688 1
    return true;
d2702 1
d2704 1
a2704 1
      fnname = (char *) bfd_malloc (strlen (h->root.root.string) + 2);
d2706 1
a2706 1
	return false;
d2710 1
a2710 1
				    fnname, false, false, true);
d2725 1
a2725 1
    return false;
d2735 1
a2735 1
	return false;
d2738 1
a2738 1
  return true;
d2745 1
a2745 1
boolean
d2754 1
a2754 1
    return true;
d2757 2
a2758 2
       bfd_wrapped_link_hash_lookup (output_bfd, info, name, false, false,
				     false));
d2763 1
a2763 1
      return false;
d2771 1
a2771 1
    return false;
d2773 1
a2773 1
  return true;
d2779 1
a2779 1
boolean
d2788 1
a2788 1
    return true;
d2790 2
a2791 2
  h = xcoff_link_hash_lookup (xcoff_hash_table (info), name, true, true,
			      false);
d2793 1
a2793 1
    return false;
d2797 1
a2797 1
  return true;
a2799 22
/* This structure is used to pass information through
   xcoff_link_hash_traverse.  */

struct xcoff_loader_info {
  /* Set if a problem occurred.  */
  boolean failed;
  /* Output BFD.  */
  bfd *output_bfd;
  /* Link information structure.  */
  struct bfd_link_info *info;
  /* Whether all defined symbols should be exported.  */
  boolean export_defineds;
  /* Number of ldsym structures.  */
  size_t ldsym_count;
  /* Size of string table.  */
  size_t string_size;
  /* String table.  */
  bfd_byte *strings;
  /* Allocated size of string table.  */
  size_t string_alc;
};

d2817 1
a2817 1
boolean
d2821 1
a2821 1
				 special_sections)
d2829 1
a2829 1
     boolean gc;
d2831 2
a2832 2
     boolean textro;
     boolean export_defineds;
d2834 1
d2849 1
d2853 1
a2853 1
      for (i = 0; i < 6; i++)
d2855 1
a2855 1
      return true;
d2858 1
a2858 1
  ldinfo.failed = false;
d2874 2
a2875 3
  if (entry == NULL)
    hentry = NULL;
  else
d2878 1
a2878 1
				       false, false, true);
d2883 51
d2941 2
a2942 2
      gc = false;
      xcoff_hash_table (info)->gc = false;
d2945 1
a2945 1
         correctly.  */
d2965 1
a2965 1
      xcoff_hash_table (info)->gc = true;
d2969 1
a2969 1
  for (i = 0; i < 6; i++)
d2971 1
a2971 1
      asection *sec;
a2972 1
      sec = xcoff_hash_table (info)->special_sections[i];
d2976 3
a2978 1
	sec = NULL;
d2985 1
a2985 1
      return true;
d3012 1
a3012 1
  ldhdr->l_version = 1;
d3017 3
a3019 3
  ldhdr->l_impoff = (LDHDRSZ
		     + ldhdr->l_nsyms * LDSYMSZ
		     + ldhdr->l_nreloc * LDRELSZ);
d3027 8
d3044 1
a3044 2
  xcoff_swap_ldhdr_out (output_bfd, ldhdr,
			(struct external_ldhdr *) lsec->contents);
d3083 2
a3084 1
     xcoff_link_input_bfd.  */
d3158 33
a3190 1
      csectpp = xcoff_data (sub)->csects;
d3192 3
a3194 26
      symesz = bfd_coff_symesz (sub);
      esym = (bfd_byte *) obj_coff_external_syms (sub);
      esymend = esym + symcount * symesz;
      while (esym < esymend)
	{
	  struct internal_syment sym;

	  bfd_coff_swap_sym_in (sub, (PTR) esym, (PTR) &sym);

	  *debug_index = (unsigned long) -1;

	  if (sym._n._n_n._n_zeroes == 0
	      && *csectpp != NULL
	      && (! gc
		  || ((*csectpp)->flags & SEC_MARK) != 0
		  || *csectpp == bfd_abs_section_ptr)
	      && bfd_coff_symname_in_debug (sub, &sym))
	    {
	      char *name;
	      bfd_size_type indx;

	      name = (char *) debug_contents + sym._n._n_n._n_offset;
	      indx = _bfd_stringtab_add (debug_strtab, name, true, true);
	      if (indx == (bfd_size_type) -1)
		goto error_return;
	      *debug_index = indx;
a3195 4

	  esym += (sym.n_numaux + 1) * symesz;
	  csectpp += sym.n_numaux + 1;
	  debug_index += sym.n_numaux + 1;
d3216 1
a3216 1
  return true;
d3223 36
a3258 1
  return false;
d3261 1
d3264 1
a3264 1
static boolean
d3270 8
a3277 1
  size_t len;
d3299 1
a3299 1
      boolean export;
d3315 1
a3315 1
      export = true;
d3329 1
a3329 1
		  export = false;
d3375 1
a3375 1
      sec->_raw_size += XCOFF_GLINK_SIZE;
d3378 1
a3378 1
         descriptor.  */
d3386 12
d3400 1
a3400 1
	  hds->toc_section->_raw_size += 4;
d3407 1
a3407 1
             because we may already have passed hds on the traversal.  */
d3428 4
a3431 4
             a defined entry point.  We can build up a function
             descriptor ourselves.  Believe it or not, the AIX linker
             actually does this, and there are cases where we need to
             do it as well.  */
d3438 5
a3442 1
	  sec->_raw_size += 12;
d3445 1
a3445 1
             associated code, and one for the TOC address.  */
d3450 1
a3450 1
             xcoff_write_global_symbol.  */
d3458 1
a3458 1
	  return true;
d3487 1
a3487 1
      return true;
d3496 1
a3496 1
      return true;
d3502 1
a3502 1
    return true;
d3507 2
a3508 3
  h->ldsym = ((struct internal_ldsym *)
	      bfd_zalloc (ldinfo->output_bfd,
			  sizeof (struct internal_ldsym)));
d3511 2
a3512 2
      ldinfo->failed = true;
      return false;
d3519 1
a3519 1
     sections.  */
d3524 2
a3525 4
  len = strlen (h->root.root.string);
  if (len <= SYMNMLEN)
    strncpy (h->ldsym->_l._l_name, h->root.root.string, SYMNMLEN);
  else
d3527 1
a3527 28
      if (ldinfo->string_size + len + 3 > ldinfo->string_alc)
	{
	  size_t newalc;
	  bfd_byte *newstrings;

	  newalc = ldinfo->string_alc * 2;
	  if (newalc == 0)
	    newalc = 32;
	  while (ldinfo->string_size + len + 3 > newalc)
	    newalc *= 2;

	  newstrings = ((bfd_byte *)
			bfd_realloc ((PTR) ldinfo->strings, newalc));
	  if (newstrings == NULL)
	    {
	      ldinfo->failed = true;
	      return false;
	    }
	  ldinfo->string_alc = newalc;
	  ldinfo->strings = newstrings;
	}

      bfd_put_16 (ldinfo->output_bfd, len + 1,
		  ldinfo->strings + ldinfo->string_size);
      strcpy (ldinfo->strings + ldinfo->string_size + 2, h->root.root.string);
      h->ldsym->_l._l_l._l_zeroes = 0;
      h->ldsym->_l._l_l._l_offset = ldinfo->string_size + 2;
      ldinfo->string_size += len + 3;
d3532 1
a3532 1
  return true;
d3537 1
a3537 1
boolean
d3546 5
a3550 5
  size_t max_contents_size;
  size_t max_sym_count;
  size_t max_lineno_count;
  size_t max_reloc_count;
  size_t max_output_reloc_count;
d3558 2
d3579 6
a3584 7
  finfo.ldsym = ((struct external_ldsym *)
		 (xcoff_hash_table (info)->loader_section->contents
		  + LDHDRSZ));
  finfo.ldrel = ((struct external_ldrel *)
		 (xcoff_hash_table (info)->loader_section->contents
		  + LDHDRSZ
		  + xcoff_hash_table (info)->ldhdr.l_nsyms * LDSYMSZ));
d3613 1
a3613 1
	      sec->linker_mark = true;
d3653 1
a3653 1
	  boolean saw_contents;
d3659 3
a3661 3
             contents and is loaded, if it is preceded by some other
             section which has contents and is loaded.  */
	  saw_contents = true;
d3665 1
a3665 1
		saw_contents = false;
d3670 1
a3670 1
		    saw_contents = true;
d3673 1
a3673 1
		      asection *n, *hold;
d3675 5
a3679 2
		      hold = *op;
		      *op = NULL;
a3680 2
		      BFD_ASSERT (*op == n);
		      n->next = hold;
d3683 7
a3689 1
		      saw_contents = false;
d3695 1
a3695 1
             sections.  */
d3705 3
a3707 3
             each section to land on a page boundary.  This bit of
             code knows what compute_section_file_positions is going
             to do.  */
d3712 5
a3716 1
	    if (o->reloc_count >= 0xffff || o->lineno_count >= 0xffff)
d3753 3
a3755 4
    finfo.section_info =
      ((struct xcoff_link_section_info *)
       bfd_malloc ((abfd->section_count + 1)
		   * sizeof (struct xcoff_link_section_info)));
d3777 2
a3778 2
             allocate the buffers, so that later code doesn't have to
             worry about whether we are stripping or not.  */
d3789 7
a3795 7
             written out all the local symbols.  For each section in
             the output file, we keep an array of pointers to hash
             table entries.  Each entry in the array corresponds to a
             reloc.  When we find a reloc against a global symbol, we
             set the corresponding entry in this array so that we can
             fix up the symbol index after we have written out all the
             local symbols.
d3801 2
d3804 4
a3807 2
	    ((struct internal_reloc *)
	     bfd_malloc (o->reloc_count * sizeof (struct internal_reloc)));
d3809 2
a3810 3
	    ((struct xcoff_link_hash_entry **)
	     bfd_malloc (o->reloc_count
			 * sizeof (struct xcoff_link_hash_entry *)));
d3850 1
a3850 1
      size_t sz;
d3852 1
a3852 1
      sub->output_has_begun = false;
d3859 18
a3876 10
  finfo.internal_syms = ((struct internal_syment *)
			 bfd_malloc (max_sym_count
				     * sizeof (struct internal_syment)));
  finfo.sym_indices = (long *) bfd_malloc (max_sym_count * sizeof (long));
  finfo.outsyms = ((bfd_byte *)
		   bfd_malloc ((size_t) ((max_sym_count + 1) * symesz)));
  finfo.linenos = (bfd_byte *) bfd_malloc (max_lineno_count
					   * bfd_coff_linesz (abfd));
  finfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
  finfo.external_relocs = (bfd_byte *) bfd_malloc (max_reloc_count * relsz);
d3905 1
a3905 1
		  sub->output_has_begun = true;
d3922 1
d3955 1
a3955 1
      finfo.last_file.n_value = -1;
d3958 3
a3960 5
      if (bfd_seek (abfd,
		    (obj_sym_filepos (abfd)
		     + finfo.last_file_index * symesz),
		    SEEK_SET) != 0
	  || bfd_write (finfo.outsyms, symesz, 1, abfd) != symesz)
d3979 2
a3980 1
  external_relocs = (bfd_byte *) bfd_malloc (max_output_reloc_count * relsz);
d3991 1
d4038 4
a4041 4
         to produce them in the order in which their containing csects
         appear in the symbol table, which is not necessarily by
         address.  So we sort them here.  There may be a better way to
         do this.  */
d4052 1
d4054 1
a4054 2
	  || bfd_write ((PTR) external_relocs, relsz, o->reloc_count,
			abfd) != relsz * o->reloc_count)
d4085 2
a4086 3
  if (! bfd_set_section_contents (abfd, o->output_section,
				  o->contents, o->output_offset,
				  o->_raw_size))
d4093 2
a4094 1
				     o->output_offset, o->_raw_size))
d4099 2
a4100 1
				     o->output_offset, o->_raw_size))
d4105 2
a4106 1
				     o->output_offset, o->_raw_size))
d4110 2
a4111 4
  if (bfd_seek (abfd,
		(obj_sym_filepos (abfd)
		 + obj_raw_syment_count (abfd) * symesz),
		SEEK_SET) != 0)
d4113 5
a4117 4
  bfd_h_put_32 (abfd,
		_bfd_stringtab_size (finfo.strtab) + STRING_SIZE_SIZE,
		(bfd_byte *) strbuf);
  if (bfd_write (strbuf, 1, STRING_SIZE_SIZE, abfd) != STRING_SIZE_SIZE)
d4133 2
a4134 3
      if (bfd_seek (abfd,
		    o->output_section->filepos + o->output_offset,
		    SEEK_SET) != 0)
d4144 1
a4144 1
  return true;
d4149 1
d4163 1
d4178 1
a4178 1
  return false;
d4184 1
a4184 1
static boolean
d4194 1
a4194 1
  boolean copy, hash;
d4209 1
a4209 1
  boolean keep_syms;
d4215 1
a4215 1
    return true;
d4234 1
a4234 1
  copy = false;
d4236 2
a4237 2
    copy = true;
  hash = true;
d4239 1
a4239 1
    hash = false;
d4242 1
a4242 1
    return false;
d4258 1
d4262 2
a4263 2
      boolean skip;
      boolean require;
d4269 1
a4269 1
         information.  */
d4278 1
d4289 3
a4291 3
         .loader symbol information.  If this is an external symbol
         reference to a defined symbol, though, then wait until we get
         to the definition.  */
d4363 4
a4366 3
	  BFD_ASSERT (LDSYMSZ == sizeof (struct external_ldsym));
	  xcoff_swap_ldsym_out (finfo->output_bfd, ldsym,
				finfo->ldsym + h->ldindx - 3);
d4373 4
a4376 2
	    xcoff_data (output_bfd)->snentry =
	      h->root.u.def.section->output_section->target_index;
d4381 2
a4382 2
      skip = false;
      require = false;
d4387 1
a4387 1
	skip = true;
d4390 1
a4390 1
         symbol.  */
d4395 1
a4395 1
	skip = true;
d4400 1
a4400 1
	skip = true;
d4408 1
a4408 1
	    skip = true;
d4420 5
a4424 5
                 as the TOC anchor--that is, whether we can access all
                 of the TOC using a 16 bit offset from tocval.  This
                 test assumes that the TOC comes at the end of the
                 output section, as it does in the default linker
                 script.  */
a4430 1
		  asection *o;
d4451 1
a4451 1
		  return false;
d4467 2
a4468 1
	      require = true;
d4475 1
a4475 1
	skip = true;
d4482 1
a4482 1
	skip = true;
d4485 1
a4485 1
         else.  */
d4493 1
a4493 1
	skip = true;
d4501 1
a4501 1
	skip = true;
d4504 1
a4504 1
         symbol, then skip it.  */
d4508 1
a4508 1
	skip = true;
d4524 1
d4526 1
a4526 1
	    return false;
d4529 2
a4530 2
	       && (bfd_hash_lookup (finfo->info->keep_hash, name, false,
				    false) == NULL))
d4536 1
a4536 1
	    skip = true;
d4543 1
a4543 1
	skip = false;
d4565 1
d4567 1
a4567 1
		    return false;
d4570 1
a4570 1
		    return false;
d4594 1
a4594 1
		  && finfo->last_file.n_value != (long) output_index)
d4613 2
d4618 5
a4622 5
		      if (bfd_seek (output_bfd,
				    (obj_sym_filepos (output_bfd)
				     + finfo->last_file_index * osymesz),
				    SEEK_SET) != 0
			  || (bfd_write (outsym, osymesz, 1, output_bfd)
d4624 1
a4624 1
			return false;
d4633 2
a4634 2
             into the line numbers.  We update the symbol values when
             we handle the line numbers.  */
d4661 2
a4662 2
             (class XMC_TC), remember the symbol index of the TOC
             symbol.  */
d4713 2
a4714 1
	      unsigned long indx;
d4717 1
a4717 1
                 index of the containing csect.  */
d4762 1
a4762 1
			    return false;
d4768 1
a4768 1
			return false;
d4776 1
d4778 1
a4778 1
                     anybody does.  */
d4781 1
a4781 1
                     better clobber them just in case.  */
d4784 1
d4796 3
a4798 1
			    aux.x_sym.x_tagndx.l = 0;
d4800 3
a4802 1
			    aux.x_sym.x_tagndx.l = symindx;
d4820 3
a4822 3
                             the index of the next symbol we are going
                             to include.  I don't know if this is
                             entirely right.  */
d4831 1
d4846 1
d4866 1
a4866 1
		      bfd_size_type linoff;
d4874 6
a4879 7
			  if (bfd_seek (input_bfd,
					enclosing->line_filepos,
					SEEK_SET) != 0
			      || (bfd_read (finfo->linenos, linesz,
					    enc_count, input_bfd)
				  != linesz * enc_count))
			    return false;
d4936 2
a4937 2
			      || (bfd_write (finfo->linenos + linoff,
					     linesz, count, output_bfd)
d4939 1
a4939 1
			    return false;
d4951 2
a4952 2
                                 that refer to a line number in the
                                 range we just output.  */
d4964 1
a4964 1
					  >= enclosing->line_filepos + linoff)
d5026 5
a5030 7
      if (bfd_seek (output_bfd,
		    obj_sym_filepos (output_bfd) + syment_base * osymesz,
		    SEEK_SET) != 0
	  || (bfd_write (finfo->outsyms, outsym - finfo->outsyms, 1,
			output_bfd)
	      != (bfd_size_type) (outsym - finfo->outsyms)))
	return false;
d5041 1
a5041 1
  obj_coff_keep_syms (input_bfd) = true;
d5046 1
d5061 1
a5061 1
         represent csects, so bfd_get_section_contents should work.  */
d5065 6
a5070 7
      else
	{
	  if (! bfd_get_section_contents (input_bfd, o, finfo->contents,
					  (file_ptr) 0, o->_raw_size))
	    return false;
	  contents = finfo->contents;
	}
d5085 2
a5086 2
			     (input_bfd, o, false, finfo->external_relocs,
			      true,
d5090 1
a5090 1
	    return false;
d5093 1
a5093 1
             contents.  */
d5100 1
a5100 1
	    return false;
d5111 1
a5111 1
	      boolean quiet;
d5137 4
a5140 4
                         attached.  The symbol should be the one which
                         this reloc is for.  We want to make this
                         reloc against the TOC address of the symbol,
                         not the symbol itself.  */
d5149 1
d5151 1
d5153 1
a5153 2
			       bfd_alloc (finfo->output_bfd,
					  sizeof (struct xcoff_toc_rel_hash)));
d5155 1
a5155 1
			    return false;
d5220 1
d5222 1
d5233 1
d5235 1
a5235 1
			    return false;
d5240 1
a5240 1
			    return false;
d5245 1
a5245 1
	      quiet = false;
d5263 1
a5263 1
		    ldrel.l_symndx = -1;
d5289 1
a5289 1
			     bfd_get_filename (input_bfd),
d5292 1
a5292 1
			  return false;
d5305 1
a5305 1
			  quiet = true;
d5311 1
a5311 1
			     bfd_get_filename (input_bfd),
d5314 1
a5314 1
			  return false;
d5326 1
a5326 1
			 bfd_get_filename (input_bfd),
d5330 1
a5330 1
		      return false;
d5332 4
a5335 4
		  xcoff_swap_ldrel_out (output_bfd, &ldrel,
					finfo->ldrel);
		  BFD_ASSERT (sizeof (struct external_ldrel) == LDRELSZ);
		  ++finfo->ldrel;
d5354 1
a5354 1
				      contents, o->output_offset,
d5358 1
a5358 1
	return false;
d5366 1
a5366 1
	return false;
d5369 1
a5369 1
  return true;
d5377 3
a5379 2
static boolean
xcoff_write_global_symbol (h, p)
d5381 1
a5381 1
     PTR p;
d5383 1
a5383 1
  struct xcoff_final_link_info *finfo = (struct xcoff_final_link_info *) p;
d5388 3
d5395 7
d5405 1
a5405 1
    return true;
d5418 1
d5423 1
d5428 1
d5438 1
d5446 8
a5453 1
	ldsym->l_smtype |= L_IMPORT;
d5457 4
a5460 1
	ldsym->l_smtype |= L_EXPORT;
d5462 8
a5469 1
	ldsym->l_smtype |= L_ENTRY;
d5473 27
a5499 2
      if (ldsym->l_ifile == (bfd_size_type) -1)
	ldsym->l_ifile = 0;
d5503 3
a5505 1
	    ldsym->l_ifile = 0;
d5507 3
a5509 1
	    ldsym->l_ifile = 0;
d5520 5
a5524 2
      BFD_ASSERT (LDSYMSZ == sizeof (struct external_ldsym));
      xcoff_swap_ldsym_out (output_bfd, ldsym, finfo->ldsym + h->ldindx - 3);
d5540 1
a5540 1
         specific TOC element.  */
d5544 1
d5546 20
a5565 6
	tocoff += h->descriptor->u.toc_offset;
      bfd_put_32 (output_bfd, XCOFF_GLINK_FIRST | (tocoff & 0xffff), p);
      for (i = 0, p += 4;
	   i < sizeof xcoff_glink_code / sizeof xcoff_glink_code[0];
	   i++, p += 4)
	bfd_put_32 (output_bfd, xcoff_glink_code[i], p);
d5587 2
d5590 3
a5592 1
	irel->r_symndx = h->indx;
d5598 31
a5629 1
      irel->r_size = 31;
a5632 1
      BFD_ASSERT (h->ldindx >= 0);
d5635 1
a5635 1
      ldrel.l_rtype = (31 << 8) | R_POS;
d5637 2
a5638 2
      xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
      ++finfo->ldrel;
d5640 2
a5641 2
      /* We need to emit a symbol to define a csect which holds the
         reloc.  */
a5643 6
	  if (strlen (h->root.root.string) <= SYMNMLEN)
	    strncpy (irsym._n._n_name, h->root.root.string, SYMNMLEN);
	  else
	    {
	      boolean hash;
	      bfd_size_type indx;
d5645 4
a5648 10
	      hash = true;
	      if ((output_bfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
		hash = false;
	      indx = _bfd_stringtab_add (finfo->strtab, h->root.root.string,
					 hash, false);
	      if (indx == (bfd_size_type) -1)
		return false;
	      irsym._n._n_n._n_zeroes = 0;
	      irsym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;
	    }
d5659 1
a5659 5
	  memset (&iraux, 0, sizeof iraux);
	  iraux.x_csect.x_smtyp = XTY_SD;
	  iraux.x_csect.x_scnlen.l = 4;
	  iraux.x_csect.x_smclas = XMC_TC;

d5668 7
a5674 9
	      if (bfd_seek (output_bfd,
			    (obj_sym_filepos (output_bfd)
			     + (obj_raw_syment_count (output_bfd)
				* bfd_coff_symesz (output_bfd))),
			    SEEK_SET) != 0
		  || (bfd_write (finfo->outsyms, outsym - finfo->outsyms, 1,
				 output_bfd)
		      != (bfd_size_type) (outsym - finfo->outsyms)))
		return false;
d5686 7
a5692 1
     word is zero.  */
d5707 16
a5733 5
      bfd_put_32 (output_bfd,
		  (esec->output_section->vma
		   + esec->output_offset
		   + hentry->root.u.def.value),
		  p);
d5741 1
a5741 1
      irel->r_size = 31;
d5759 1
a5759 1
	  return false;
d5761 1
a5761 1
      ldrel.l_rtype = (31 << 8) | R_POS;
d5763 2
a5764 2
      xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
      ++finfo->ldrel;
d5766 26
a5791 1
      bfd_put_32 (output_bfd, xcoff_data (output_bfd)->toc, p + 4);
d5800 1
a5800 1
		       + 4);
d5803 1
a5803 1
      irel->r_size = 31;
d5821 1
a5821 1
	  return false;
d5823 1
a5823 1
      ldrel.l_rtype = (31 << 8) | R_POS;
d5825 2
a5826 2
      xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
      ++finfo->ldrel;
d5832 1
a5832 1
      return true;
d5838 2
a5839 3
	      && (bfd_hash_lookup (finfo->info->keep_hash,
				   h->root.root.string, false, false)
		  == NULL))))
d5842 1
a5842 1
      return true;
d5849 1
a5849 1
      return true;
d5856 4
a5859 17
  if (strlen (h->root.root.string) <= SYMNMLEN)
    strncpy (isym._n._n_name, h->root.root.string, SYMNMLEN);
  else
    {
      boolean hash;
      bfd_size_type indx;

      hash = true;
      if ((output_bfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
	hash = false;
      indx = _bfd_stringtab_add (finfo->strtab, h->root.root.string, hash,
				 false);
      if (indx == (bfd_size_type) -1)
	return false;
      isym._n._n_n._n_zeroes = 0;
      isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;
    }
d5887 4
a5890 1
      isym.n_scnum = h->root.u.def.section->output_section->target_index;
a5926 1

a5944 1

d5950 6
a5955 8
  if (bfd_seek (output_bfd,
		(obj_sym_filepos (output_bfd)
		 + (obj_raw_syment_count (output_bfd)
		    * bfd_coff_symesz (output_bfd))),
		SEEK_SET) != 0
      || (bfd_write (finfo->outsyms, outsym - finfo->outsyms, 1, output_bfd)
	  != (bfd_size_type) (outsym - finfo->outsyms)))
    return false;
d5959 1
a5959 1
  return true;
d5964 1
a5964 1
static boolean
d5983 3
a5985 3
         symbol must either have a value of zero, or we must adjust
         the addend by the value of the symbol.  FIXME: Write this
         when we need it.  The old linker couldn't handle this anyhow.  */
d5993 1
a5993 1
      return false;
d5999 1
a5999 1
				     false, false, true));
d6005 2
a6006 2
	return false;
      return true;
d6037 1
a6037 1
      boolean ok;
d6042 1
a6042 1
	return false;
d6059 1
a6059 1
	      return false;
d6067 1
a6067 1
	return false;
d6122 1
a6122 1
	  return false;
d6134 1
a6134 1
	  return false;
d6141 2
a6142 2
  xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
  ++finfo->ldrel;
d6144 1
a6144 1
  return true;
a6164 317
/* This is the relocation function for the RS/6000/POWER/PowerPC.
   This is currently the only processor which uses XCOFF; I hope that
   will never change.  */

boolean
_bfd_ppc_xcoff_relocate_section (output_bfd, info, input_bfd,
				 input_section, contents, relocs, syms,
				 sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     struct internal_reloc *relocs;
     struct internal_syment *syms;
     asection **sections;
{
  struct internal_reloc *rel;
  struct internal_reloc *relend;

  rel = relocs;
  relend = rel + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      long symndx;
      struct xcoff_link_hash_entry *h;
      struct internal_syment *sym;
      bfd_vma addend;
      bfd_vma val;
      struct reloc_howto_struct howto;
      bfd_reloc_status_type rstat;

      /* Relocation type R_REF is a special relocation type which is
         merely used to prevent garbage collection from occurring for
         the csect including the symbol which it references.  */
      if (rel->r_type == R_REF)
	continue;

      symndx = rel->r_symndx;

      if (symndx == -1)
	{
	  h = NULL;
	  sym = NULL;
	  addend = 0;
	}
      else
	{
	  h = obj_xcoff_sym_hashes (input_bfd)[symndx];
	  sym = syms + symndx;
	  addend = - sym->n_value;
	}

      /* We build the howto information on the fly.  */

      howto.type = rel->r_type;
      howto.rightshift = 0;
      howto.size = 2;
      howto.bitsize = (rel->r_size & 0x1f) + 1;
      howto.pc_relative = false;
      howto.bitpos = 0;
      if ((rel->r_size & 0x80) != 0)
	howto.complain_on_overflow = complain_overflow_signed;
      else
	howto.complain_on_overflow = complain_overflow_bitfield;
      howto.special_function = NULL;
      howto.name = "internal";
      howto.partial_inplace = true;
      if (howto.bitsize == 32)
	howto.src_mask = howto.dst_mask = 0xffffffff;
      else
	{
	  howto.src_mask = howto.dst_mask = (1 << howto.bitsize) - 1;
	  if (howto.bitsize == 16)
	    howto.size = 1;
	}
      howto.pcrel_offset = false;

      val = 0;

      if (h == NULL)
	{
	  asection *sec;

	  if (symndx == -1)
	    {
	      sec = bfd_abs_section_ptr;
	      val = 0;
	    }
	  else
	    {
	      sec = sections[symndx];
	      /* Hack to make sure we use the right TOC anchor value
                 if this reloc is against the TOC anchor.  */
	      if (sec->name[3] == '0'
		  && strcmp (sec->name, ".tc0") == 0)
		val = xcoff_data (output_bfd)->toc;
	      else
		val = (sec->output_section->vma
		       + sec->output_offset
		       + sym->n_value
		       - sec->vma);
	    }
	}
      else
	{
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      asection *sec;

	      sec = h->root.u.def.section;
	      val = (h->root.u.def.value
		     + sec->output_section->vma
		     + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_common)
	    {
	      asection *sec;

	      sec = h->root.u.c.p->section;
	      val = (sec->output_section->vma
		     + sec->output_offset);
	    }
	  else if ((h->flags & XCOFF_DEF_DYNAMIC) != 0
		   || (h->flags & XCOFF_IMPORT) != 0)
	    {
	      /* Every symbol in a shared object is defined somewhere.  */
	      val = 0;
	    }
	  else if (! info->relocateable)
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd, input_section,
		      rel->r_vaddr - input_section->vma, true)))
		return false;

	      /* Don't try to process the reloc.  It can't help, and
                 it may generate another error.  */
	      continue;
	    }
	}

      /* I took the relocation type definitions from two documents:
	 the PowerPC AIX Version 4 Application Binary Interface, First
	 Edition (April 1992), and the PowerOpen ABI, Big-Endian
	 32-Bit Hardware Implementation (June 30, 1994).  Differences
	 between the documents are noted below.  */

      switch (rel->r_type)
	{
	case R_RTB:
	case R_RRTBI:
	case R_RRTBA:
	  /* These relocs are defined by the PowerPC ABI to be
             relative branches which use half of the difference
             between the symbol and the program counter.  I can't
             quite figure out when this is useful.  These relocs are
             not defined by the PowerOpen ABI.  */
	default:
	  (*_bfd_error_handler)
	    (_("%s: unsupported relocation type 0x%02x"),
	     bfd_get_filename (input_bfd), (unsigned int) rel->r_type);
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	case R_POS:
	  /* Simple positive relocation.  */
	  break;
	case R_NEG:
	  /* Simple negative relocation.  */
	  val = - val;
	  break;
	case R_REL:
	  /* Simple PC relative relocation.  */
	  howto.pc_relative = true;
	  break;
	case R_TOC:
	  /* TOC relative relocation.  The value in the instruction in
             the input file is the offset from the input file TOC to
             the desired location.  We want the offset from the final
             TOC to the desired location.  We have:
	         isym = iTOC + in
		 iinsn = in + o
		 osym = oTOC + on
		 oinsn = on + o
	     so we must change insn by on - in.
	     */
	case R_GL:
	  /* Global linkage relocation.  The value of this relocation
             is the address of the entry in the TOC section.  */
	case R_TCL:
	  /* Local object TOC address.  I can't figure out the
             difference between this and case R_GL.  */
	case R_TRL:
	  /* TOC relative relocation.  A TOC relative load instruction
             which may be changed to a load address instruction.
             FIXME: We don't currently implement this optimization.  */
	case R_TRLA:
	  /* TOC relative relocation.  This is a TOC relative load
             address instruction which may be changed to a load
             instruction.  FIXME: I don't know if this is the correct
             implementation.  */
	  if (h != NULL && h->smclas != XMC_TD)
	    {
	      if (h->toc_section == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%s: TOC reloc at 0x%x to symbol `%s' with no TOC entry"),
		     bfd_get_filename (input_bfd), rel->r_vaddr,
		     h->root.root.string);
		  bfd_set_error (bfd_error_bad_value);
		  return false;
		}

	      BFD_ASSERT ((h->flags & XCOFF_SET_TOC) == 0);
	      val = (h->toc_section->output_section->vma
		     + h->toc_section->output_offset);
	    }

	  val = ((val - xcoff_data (output_bfd)->toc)
		 - (sym->n_value - xcoff_data (input_bfd)->toc));
	  addend = 0;
	  break;
	case R_BA:
	  /* Absolute branch.  We don't want to mess with the lower
             two bits of the instruction.  */
	case R_CAI:
	  /* The PowerPC ABI defines this as an absolute call which
             may be modified to become a relative call.  The PowerOpen
             ABI does not define this relocation type.  */
	case R_RBA:
	  /* Absolute branch which may be modified to become a
             relative branch.  */
	case R_RBAC:
	  /* The PowerPC ABI defines this as an absolute branch to a
             fixed address which may be modified to an absolute branch
             to a symbol.  The PowerOpen ABI does not define this
             relocation type.  */
	case R_RBRC:
	  /* The PowerPC ABI defines this as an absolute branch to a
             fixed address which may be modified to a relative branch.
             The PowerOpen ABI does not define this relocation type.  */
	  howto.src_mask &= ~3;
	  howto.dst_mask = howto.src_mask;
	  break;
	case R_BR:
	  /* Relative branch.  We don't want to mess with the lower
             two bits of the instruction.  */
	case R_CREL:
	  /* The PowerPC ABI defines this as a relative call which may
             be modified to become an absolute call.  The PowerOpen
             ABI does not define this relocation type.  */
	case R_RBR:
	  /* A relative branch which may be modified to become an
             absolute branch.  FIXME: We don't implement this,
             although we should for symbols of storage mapping class
             XMC_XO.  */
	  howto.pc_relative = true;
	  howto.src_mask &= ~3;
	  howto.dst_mask = howto.src_mask;
	  break;
	case R_RL:
	  /* The PowerPC AIX ABI describes this as a load which may be
             changed to a load address.  The PowerOpen ABI says this
             is the same as case R_POS.  */
	  break;
	case R_RLA:
	  /* The PowerPC AIX ABI describes this as a load address
             which may be changed to a load.  The PowerOpen ABI says
             this is the same as R_POS.  */
	  break;
	}

      /* If we see an R_BR or R_RBR reloc which is jumping to global
         linkage code, and it is followed by an appropriate cror nop
         instruction, we replace the cror with lwz r2,20(r1).  This
         restores the TOC after the glink code.  Contrariwise, if the
         call is followed by a lwz r2,20(r1), but the call is not
         going to global linkage code, we can replace the load with a
         cror.  */
      if ((rel->r_type == R_BR || rel->r_type == R_RBR)
	  && h != NULL
	  && h->root.type == bfd_link_hash_defined
	  && (rel->r_vaddr - input_section->vma + 8
	      <= input_section->_cooked_size))
	{
	  bfd_byte *pnext;
	  unsigned long next;

	  pnext = contents + (rel->r_vaddr - input_section->vma) + 4;
	  next = bfd_get_32 (input_bfd, pnext);

	  /* The _ptrgl function is magic.  It is used by the AIX
             compiler to call a function through a pointer.  */
	  if (h->smclas == XMC_GL
	      || strcmp (h->root.root.string, "._ptrgl") == 0)
	    {
	      if (next == 0x4def7b82		/* cror 15,15,15 */
		  || next == 0x4ffffb82		/* cror 31,31,31 */
		  || next == 0x60000000)	/* ori r0,r0,0 */
		bfd_put_32 (input_bfd, 0x80410014, pnext); /* lwz r1,20(r1) */
	    }
	  else
	    {
	      if (next == 0x80410014)		/* lwz r1,20(r1) */
		bfd_put_32 (input_bfd, 0x60000000, pnext); /* ori r0,r0,0 */
	    }
	}

      /* A PC relative reloc includes the section address.  */
      if (howto.pc_relative)
	addend += input_section->vma;

      rstat = _bfd_final_link_relocate (&howto, input_bfd, input_section,
					contents,
					rel->r_vaddr - input_section->vma,
					val, addend);
a6165 23
      switch (rstat)
	{
	default:
	  abort ();
	case bfd_reloc_ok:
	  break;
	case bfd_reloc_overflow:
	  {
	    const char *name;
	    char buf[SYMNMLEN + 1];
	    char howto_name[10];

	    if (symndx == -1)
	      name = "*ABS*";
	    else if (h != NULL)
	      name = h->root.root.string;
	    else
	      {
		name = _bfd_coff_internal_syment_name (input_bfd, sym, buf);
		if (name == NULL)
		  return false;
	      }
	    sprintf (howto_name, "0x%02x", rel->r_type);
a6166 7
	    if (! ((*info->callbacks->reloc_overflow)
		   (info, name, howto_name, (bfd_vma) 0, input_bfd,
		    input_section, rel->r_vaddr - input_section->vma)))
	      return false;
	  }
	}
    }
a6167 2
  return true;
}
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
a32 8
/* In order to support linking different object file formats into an
   XCOFF format, we need to be able to determine whether a particular
   bfd_target is an XCOFF vector.  FIXME: We need to rethink this
   whole approach.  */
#define XCOFF_XVECP(xv) \
  (strcmp ((xv)->name, "aixcoff-rs6000") == 0 \
   || strcmp ((xv)->name, "xcoff-powermac") == 0)

d71 1
a71 2
static unsigned long xcoff_glink_code[] =
{
d93 1
a93 2
struct internal_ldhdr
{
d114 1
a114 2
struct external_ldhdr
{
d130 12
a141 15
struct internal_ldsym
{
  union
    {
      /* The symbol name if <= SYMNMLEN characters.  */
      char _l_name[SYMNMLEN];
      struct
	{
	  /* Zero if the symbol name is more than SYMNMLEN characters.  */
	  long _l_zeroes;
	  /* The offset in the string table if the symbol name is more
             than SYMNMLEN characters.  */
	  long _l_offset;
	} _l_l;
    } _l;
d156 8
a163 11
struct external_ldsym
{
  union
    {
      bfd_byte _l_name[SYMNMLEN];
      struct
	{
	  bfd_byte _l_zeroes[4];
	  bfd_byte _l_offset[4];
	} _l_l;
    } _l;
d187 1
a187 2
struct internal_ldrel
{
d198 1
a198 2
struct external_ldrel
{
d209 1
a209 2
struct xcoff_import_file
{
d222 1
a222 2
struct xcoff_link_hash_entry
{
d233 8
a240 9
  union
    {
      /* If we have created a TOC entry (the XCOFF_SET_TOC flag is
	 set), this is the offset in toc_section.  */
      bfd_vma toc_offset;
      /* If the TOC entry comes from an input file, this is set to the
         symbol index of the C_HIDEXT XMC_TC or XMC_TD symbol.  */
      long toc_indx;
    } u;
d293 1
a293 2
struct xcoff_link_hash_table
{
d338 5
a342 6
  struct xcoff_link_size_list
    {
      struct xcoff_link_size_list *next;
      struct xcoff_link_hash_entry *h;
      bfd_size_type size;
    } *size_list;
d351 1
a351 2
struct xcoff_link_section_info
{
d361 5
a365 6
  struct xcoff_toc_rel_hash
    {
      struct xcoff_toc_rel_hash *next;
      struct xcoff_link_hash_entry *h;
      struct internal_reloc *rel;
    } *toc_rel_hashes;
d370 1
a370 2
struct xcoff_final_link_info
{
d769 6
a774 6
  HOWTO (0,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d776 5
a780 5
	 0,		        /* special_function */                     
	 "R_POS",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
d1871 5
a1875 6
	    static const char *csect_name_by_class[] =
	      {
		".pr", ".ro", ".db", ".tc", ".ua", ".rw", ".gl", ".xo",
		".sv", ".bs", ".ds", ".uc", ".ti", ".tb", NULL, ".tc0",
		".td"
	      };
d2265 1
a2265 1
		     = csect->alignment_power;
d2380 1
a2380 1
	  o->flags &=~ SEC_RELOC;
d2891 1
a2891 1
  if (! XCOFF_XVECP (output_bfd->xvec))
d2927 1
a2927 1
  if (! XCOFF_XVECP (output_bfd->xvec))
d3041 1
a3041 1
  if (! XCOFF_XVECP (output_bfd->xvec))
d3106 1
a3106 1
  if (! XCOFF_XVECP (output_bfd->xvec))
d3121 1
a3121 1
  
d3140 1
a3140 1
  if (! XCOFF_XVECP (output_bfd->xvec))
d3156 1
a3156 2
struct xcoff_loader_info
{
d3224 1
a3224 1
  if (! XCOFF_XVECP (output_bfd->xvec))
d4076 1
a4076 1
		     * sizeof (struct xcoff_link_hash_entry *)));
d4662 1
d4668 1
d4674 1
a4674 3
                 script.  FIXME: This doesn't handle .tocbss sections
                 created from XMC_TD common symbols correctly.  */

d4677 18
d6327 1
a6327 1
	{    
d6578 2
a6579 1
		  || next == 0x4ffffb82)	/* cror 31,31,31 */
d6585 1
a6585 1
		bfd_put_32 (input_bfd, 0x4ffffb82, pnext); /* cror 31,31,31 */
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 1
a2 1
   Copyright 1995, 1996 Free Software Foundation, Inc.
d448 1
d465 2
d616 2
a617 1
      coff_section_data (abfd, sec)->contents = bfd_malloc (sec->_raw_size);
d724 1
a724 1
	    symbuf->symbol.name = elsym->_l._l_name;
d1481 2
a1482 1
      if (xcoff_hash_table (info)->debug_section == NULL)
d1661 1
a1661 1
		    ("%s: `%s' has line numbers but no enclosing section",
d1713 1
a1713 1
	    ("%s: class %d symbol `%s' has no aux entries",
d1736 1
a1736 1
	    ("%s: symbol `%s' has unrecognized csect type %d",
d1748 1
a1748 1
		("%s: bad XTY_ER symbol `%s': class %d scnum %d scnlen %d",
d1787 1
a1787 1
		    ("%s: XMC_TC0 symbol `%s' is class %d scnlen %d",
d1911 1
a1911 1
		  ("%s: symbol `%s' has unrecognized smclas %d",
d1930 1
a1930 1
		  ("%s: csect `%s' not in enclosing section",
d1946 1
a1946 2
	      ((struct coff_section_tdata *)
	       bfd_zalloc (abfd, sizeof (struct coff_section_tdata)));
d2034 1
a2034 1
		  ("%s: misplaced XTY_LD `%s'",
d2046 5
a2050 2
             the storage mapping class, but we don't bother.  If this
             csect is externally visible, it is a common symbol.  */
d2060 4
a2063 1
	  csect = bfd_make_section_anyway (abfd, ".bss");
d2078 1
a2078 2
	    ((struct coff_section_tdata *)
	     bfd_zalloc (abfd, sizeof (struct coff_section_tdata)));
d2158 8
d2211 8
d2345 1
a2345 1
		    ("%s: reloc %s:%d not in csect",
d2480 1
a2480 1
	("%s: XCOFF shared object when not producing XCOFF output",
d2501 1
a2501 1
	("%s: dynamic object with no .loader section",
d2716 2
a2717 1
      if ((hsec->flags & SEC_MARK) == 0)
d2745 2
a2746 1
  if ((sec->flags & SEC_MARK) != 0)
d2957 36
d3064 1
a3064 1
     boolean syscall;
d3141 1
a3141 1
      (*_bfd_error_handler) ("%s: no such symbol", name);
d3275 9
a3283 4
  hentry = xcoff_link_hash_lookup (xcoff_hash_table (info), entry,
				   false, false, true);
  if (hentry != NULL)
    hentry->flags |= XCOFF_ENTRY;
d3489 1
a3489 1
	 copy the neams into the debug stringtab, rather than
d3549 3
a3551 2
  xcoff_hash_table (info)->debug_section->_raw_size =
    _bfd_stringtab_size (debug_strtab);
d3582 2
a3583 1
      && (h->root.u.def.section->owner->flags & DYNAMIC) == 0)
d3592 41
a3632 1
    h->flags |= XCOFF_EXPORT;
d3733 1
a3733 1
	    ("warning: attempt to export undefined symbol `%s'",
d4039 2
a4040 1
      bfd_coff_compute_section_file_positions (abfd);
d4073 11
a4083 3
	  o->flags |= SEC_RELOC;
	  o->rel_filepos = rel_filepos;
	  rel_filepos += o->reloc_count * relsz;
d4139 1
a4139 1
     input BFD's.  We want at least 4 symbols, since that is the
d4141 1
a4141 1
  max_sym_count = 4;
d4266 1
a4266 1
  external_relocs = (bfd_byte *) malloc (max_output_reloc_count * relsz);
d4268 1
a4268 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d4278 7
d4700 2
a4701 1
                 script.  */
d4709 1
a4709 1
		    ("TOC overflow: 0x%lx > 0x10000; try -mminimal-toc when compiling",
d4794 1
a4794 2
		  && strncmp (name, finfo->info->lprefix,
			      finfo->info->lprefix_len) == 0))
d5371 6
a5376 1
	      if (r_symndx != -1)
a5377 1
		  h = obj_xcoff_sym_hashes (input_bfd)[r_symndx];
d5534 1
a5534 1
			    ("%s: loader reloc in unrecognized section `%s'",
d5556 1
a5556 1
			    ("%s: `%s' in loader reloc but not loader sym",
d5571 1
a5571 1
			("%s: loader reloc in read-only section %s",
d5635 1
d5744 2
d5773 60
d5890 1
a5890 1
	    ("%s: loader reloc in unrecognized section `%s'",
d5927 1
a5927 1
	    ("%s: loader reloc in unrecognized section `%s'",
d5939 5
a5943 2
  if (h->indx >= 0)
    return true;
d5951 4
a5954 1
    return true;
d5958 4
a5961 3
    return true;

  outsym = finfo->outsyms;
d5993 10
d6053 3
a6055 2
  if (h->root.type == bfd_link_hash_defined
      || h->root.type == bfd_link_hash_defweak)
d6244 1
a6244 1
	    ("%s: loader reloc in unrecognized section `%s'",
d6255 1
a6255 1
	    ("%s: `%s' in loader reloc but not loader sym",
d6424 1
a6424 1
		      rel->r_vaddr - input_section->vma)))
d6451 1
a6451 1
	    ("%s: unsupported relocation type 0x%02x",
d6497 1
a6497 1
		    ("%s: TOC reloc at 0x%x to symbol `%s' with no TOC entry",
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d272 3
a274 1
  /* The .loader symbol table index.  */
d1413 2
a1577 1
  keep_syms = obj_coff_keep_syms (abfd);
d2950 4
a2953 8
  if (h->ldsym == NULL)
    {
      h->ldsym = ((struct internal_ldsym *)
		  bfd_zalloc (output_bfd, sizeof (struct internal_ldsym)));
      if (h->ldsym == NULL)
	return false;
    }

d2955 1
a2955 1
    h->ldsym->l_ifile = (bfd_size_type) -1;
d2988 1
a2988 1
      h->ldsym->l_ifile = c;
d3674 4
a3677 2
  /* h->ldsym will already have been allocated for an explicitly
     imported symbol.  */
d3680 2
a3681 8
      h->ldsym = ((struct internal_ldsym *)
		  bfd_zalloc (ldinfo->output_bfd,
			      sizeof (struct internal_ldsym)));
      if (h->ldsym == NULL)
	{
	  ldinfo->failed = true;
	  return false;
	}
d3684 3
a3860 1
	      (*op)->target_index = indx;
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d259 1
a259 1
         symbo lindex of the C_HIDEXT XMC_TC symbol.  */
d303 2
d1066 1
d1068 13
a1080 5
      /* We need to look through the archive for stripped dynamic
         objects, because they will not appear in the archive map even
         though they should, perhaps, be included.  Also, if the
         linker has no map, we just consider each object file in turn,
         since that apparently is what the AIX native linker does.  */
d1101 1
d1103 1
a1103 7
	if (! bfd_has_map (abfd))
	  return true;

	/* Now do the usual search.  */
	return (_bfd_generic_link_add_archive_symbols
		(abfd, info, xcoff_link_check_archive_element));
      }
d1211 4
a1214 1
	      && h->type == bfd_link_hash_undefined)
d1290 6
a1295 2
         undefined.  */
      if (h != NULL && h->type == bfd_link_hash_undefined)
d1418 1
a1418 4
  /* We need to build a .loader section, so we do it here.  This won't
     work if we're producing an XCOFF output file with no XCOFF input
     files.  FIXME.  */
  if (xcoff_hash_table (info)->loader_section == NULL)
d1420 6
a1425 1
      asection *lsec;
d1427 10
a1436 10
      lsec = bfd_make_section_anyway (abfd, ".loader");
      if (lsec == NULL)
	goto error_return;
      xcoff_hash_table (info)->loader_section = lsec;
      lsec->flags |= SEC_HAS_CONTENTS | SEC_IN_MEMORY;
    }
  /* Likewise for the linkage section.  */
  if (xcoff_hash_table (info)->linkage_section == NULL)
    {
      asection *lsec;
d1438 12
a1449 11
      lsec = bfd_make_section_anyway (abfd, ".gl");
      if (lsec == NULL)
	goto error_return;
      xcoff_hash_table (info)->linkage_section = lsec;
      lsec->flags |= SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY;
      lsec->alignment_power = 2;
    }
  /* Likewise for the TOC section.  */
  if (xcoff_hash_table (info)->toc_section == NULL)
    {
      asection *tsec;
d1451 12
a1462 11
      tsec = bfd_make_section_anyway (abfd, ".tc");
      if (tsec == NULL)
	goto error_return;
      xcoff_hash_table (info)->toc_section = tsec;
      tsec->flags |= SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY;
      tsec->alignment_power = 2;
    }
  /* Likewise for the descriptor section.  */
  if (xcoff_hash_table (info)->descriptor_section == NULL)
    {
      asection *dsec;
d1464 12
a1475 11
      dsec = bfd_make_section_anyway (abfd, ".ds");
      if (dsec == NULL)
	goto error_return;
      xcoff_hash_table (info)->descriptor_section = dsec;
      dsec->flags |= SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY;
      dsec->alignment_power = 2;
    }
  /* Likewise for the .debug section.  */
  if (xcoff_hash_table (info)->debug_section == NULL)
    {
      asection *dsec;
d1477 6
a1482 5
      dsec = bfd_make_section_anyway (abfd, ".debug");
      if (dsec == NULL)
	goto error_return;
      xcoff_hash_table (info)->debug_section = dsec;
      dsec->flags |= SEC_HAS_CONTENTS | SEC_IN_MEMORY;
d2091 2
a2092 1
	  && aux.x_csect.x_smclas != XMC_TC)
d2133 17
a2151 4
	      /* If we are statically linking a shared object, it is
                 OK for symbol redefinitions to occur.  I can't figure
                 out just what the XCOFF linker is doing, but
                 something like this is required for -bnso to work.  */
d2166 6
a2171 1
		  if ((abfd->flags & DYNAMIC) != 0)
d2173 6
d2185 2
d2191 40
d2296 1
a2296 1
      /* Reset the section size and the line numebr count, since the
d2563 55
a2797 1
			      || info->shared
d3505 15
a3519 1
  /* If all defined symbols should be exported, mark them now.  */
d3521 2
a3522 1
      && (h->flags & XCOFF_DEF_REGULAR) != 0)
d3536 4
a3539 4
  /* If this symbol is called and defined in a dynamic object, or not
     defined at all when building a shared object, or imported, then
     we need to set up global linkage code for it.  (Unless we did
     garbage collection and we didn't need this symbol.)  */
a3545 1
	  || ldinfo->info->shared
d3624 1
a3624 1
	    ("attempt to export undefined symbol `%s'",
d3626 2
a3627 3
	  ldinfo->failed = true;
	  bfd_set_error (bfd_error_invalid_operation);
	  return false;
d5241 1
d5254 7
a5260 6
		  if  (h != NULL
		       && (irel->r_type == R_TOC
			   || irel->r_type == R_GL
			   || irel->r_type == R_TCL
			   || irel->r_type == R_TRL
			   || irel->r_type == R_TRLA))
d5367 1
d5419 11
a5429 1
		      if (h->ldindx < 0)
d5443 2
a5444 1
		      && strcmp (o->output_section->name, ".text") == 0)
d6221 4
d6287 1
a6287 10
	  if (h != NULL && h->toc_section == NULL)
	    {
	      (*_bfd_error_handler)
		("%s: TOC reloc at 0x%x to symbol `%s' with no TOC entry",
		 bfd_get_filename (input_bfd), rel->r_vaddr,
		 h->root.root.string);
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }
	  if (h != NULL)
d6289 10
d6303 1
d6376 5
a6380 1
	  if (h->smclas == XMC_GL)
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1995 Free Software Foundation, Inc.
d438 2
d453 2
d560 13
a572 1
/* As it happens, we never need to swap in the ldrel structure.  */
d588 310
d914 1
a914 4
    {
      bfd_set_error (bfd_error_no_memory);
      return (struct bfd_hash_entry *) ret;
    }
d947 1
a947 4
    {
      bfd_set_error (bfd_error_no_memory);
      return (struct bfd_link_hash_table *) NULL;
    }
d1065 34
a1098 2
      return (_bfd_generic_link_add_archive_symbols
	      (abfd, info, xcoff_link_check_archive_element));
d1171 5
d1221 81
d1400 4
a1403 8
    return xcoff_link_add_dynamic_symbols (abfd, info);

  n_tmask = coff_data (abfd)->local_n_tmask;
  n_btshft = coff_data (abfd)->local_n_btshft;

  /* Define macros so that ISFCN, et. al., macros work correctly.  */
#define N_TMASK n_tmask
#define N_BTSHFT n_btshft
d1406 2
a1407 2
     work if we're producing an XCOFF output file with no non dynamic
     XCOFF input files.  FIXME.  */
d1466 11
d1491 1
a1491 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d1502 1
a1502 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d1512 2
a1513 2
		malloc ((abfd->section_count + 1)
			* sizeof (struct reloc_info_struct)));
d1515 1
a1515 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d1531 1
a1531 1
	    (asection **) malloc (o->reloc_count * sizeof (asection *));
d1533 1
a1533 4
	    {
	      bfd_set_error (bfd_error_no_memory);
	      goto error_return;
	    }
d1543 1
a1543 1
	  linenos = (bfd_byte *) malloc (o->lineno_count * linesz);
d1545 1
a1545 4
	    {
	      bfd_set_error (bfd_error_no_memory);
	      goto error_return;
	    }
d1922 1
a1922 4
	      {
		bfd_set_error (bfd_error_no_memory);
		goto error_return;
	      }
d1926 1
a1926 4
	      {
		bfd_set_error (bfd_error_no_memory);
		goto error_return;
	      }
d2049 1
a2049 4
	    {
	      bfd_set_error (bfd_error_no_memory);
	      goto error_return;
	    }
d2053 1
a2053 4
	    {
	      bfd_set_error (bfd_error_no_memory);
	      goto error_return;
	    }
d2119 7
a2125 2
	      *sym_hash = xcoff_link_hash_lookup (xcoff_hash_table (info),
						  name, true, copy, false);
d2350 1
a2350 1
  bfd_byte *buf = NULL;
d2369 1
a2369 1
      goto error_return;
d2390 1
a2390 1
      goto error_return;
d2393 3
a2395 10
  buf = (bfd_byte *) malloc (lsec->_raw_size);
  if (buf == NULL && lsec->_raw_size > 0)
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }

  if (! bfd_get_section_contents (abfd, lsec, (PTR) buf, (file_ptr) 0,
				  lsec->_raw_size))
    goto error_return;
d2430 1
a2430 1
      /* Normally we could not xcoff_link_hash_lookup in an add
d2438 1
a2438 1
	goto error_return;
d2479 1
a2479 1
  if (buf != NULL)
d2481 2
a2482 2
      free (buf);
      buf = NULL;
d2490 1
a2490 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
a2523 5

 error_return:
  if (buf != NULL)
    free (buf);
  return false;
d2657 4
a2660 1
			      || info->shared)))
d2758 1
a2758 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d2812 1
a2812 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d2841 1
a2841 4
	    {
	      bfd_set_error (bfd_error_no_memory);
	      return false;
	    }
d2882 1
a2882 1
      fnname = (char *) malloc (strlen (h->root.root.string) + 2);
d2884 1
a2884 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d2934 3
a2936 2
  h = xcoff_link_hash_lookup (xcoff_hash_table (info), name, false, false,
			      false);
d2989 2
d3006 11
a3016 1
   is the name of the entry point symbol.  */
d3021 2
a3022 1
				 modtype, textro, special_sections)
d3033 1
d3051 5
a3055 1
    return true;
d3060 1
d3076 1
a3076 7
    {
      hentry->flags |= XCOFF_ENTRY;
      if (hentry->root.type == bfd_link_hash_defined
	  || hentry->root.type == bfd_link_hash_defweak)
	xcoff_data (output_bfd)->entry_section =
	  hentry->root.u.def.section->output_section;
    }
d3176 1
a3176 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d3227 1
a3227 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  goto error_return;
	}
d3234 1
a3234 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  goto error_return;
	}
d3241 1
a3241 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  goto error_return;
	}
d3278 1
a3278 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  goto error_return;
	}
d3286 1
a3286 1
      debug_contents = (bfd_byte *) malloc (subdeb->_raw_size);
d3288 1
a3288 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  goto error_return;
	}
d3365 5
d3382 3
a3384 3
     defined at all when building a shared object, then we need to set
     up global linkage code for it.  (Unless we did garbage collection
     and we didn't need this symbol.)  */
d3391 3
a3393 1
	  || ldinfo->info->shared)
a3531 1
	  bfd_set_error (bfd_error_no_memory);
d3558 2
a3559 5
	  if (ldinfo->strings == NULL)
	    newstrings = (bfd_byte *) malloc (newalc);
	  else
	    newstrings = ((bfd_byte *)
			  realloc ((PTR) ldinfo->strings, newalc));
a3562 1
	      bfd_set_error (bfd_error_no_memory);
d3655 6
d3788 4
a3791 3
    finfo.section_info = ((struct xcoff_link_section_info *)
			  malloc ((abfd->section_count + 1)
				  * sizeof (struct xcoff_link_section_info)));
d3793 1
a3793 4
      {
	bfd_set_error (bfd_error_no_memory);
	goto error_return;
      }
d3831 1
a3831 1
	     malloc (o->reloc_count * sizeof (struct internal_reloc)));
d3834 1
a3834 1
	     malloc (o->reloc_count
d3838 1
a3838 4
	    {
	      bfd_set_error (bfd_error_no_memory);
	      goto error_return;
	    }
d3885 3
a3887 3
			 malloc (max_sym_count
				 * sizeof (struct internal_syment)));
  finfo.sym_indices = (long *) malloc (max_sym_count * sizeof (long));
d3889 5
a3893 5
		   malloc ((size_t) ((max_sym_count + 1) * symesz)));
  finfo.linenos = (bfd_byte *) malloc (max_lineno_count
				       * bfd_coff_linesz (abfd));
  finfo.contents = (bfd_byte *) malloc (max_contents_size);
  finfo.external_relocs = (bfd_byte *) malloc (max_reloc_count * relsz);
d3900 1
a3900 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d4375 7
d4416 34
d4451 3
a4453 7
	      xcoff_data (finfo->output_bfd)->toc =
		((*csectpp)->output_section->vma
		 + (*csectpp)->output_offset
		 + isym.n_value
		 - (*csectpp)->vma);
	      xcoff_data (finfo->output_bfd)->toc_section =
		(*csectpp)->output_section;
d4788 2
a4789 1
		      || isymp->n_sclass == C_BLOCK)
d4923 1
d4935 3
a4937 2
				  if ((iisp->n_sclass == C_BINCL
				       || iisp->n_sclass == C_EINCL)
d4960 5
a4964 3
				  iisp += iisp->n_numaux + 1;
				  iindp += iisp->n_numaux + 1;
				  oos += (iisp->n_numaux + 1) * osymesz;
d5025 6
d5125 1
a5125 4
			    {
			      bfd_set_error (bfd_error_no_memory);
			      return false;
			    }
d5436 1
a5436 1
      bfd_put_32 (output_bfd, XCOFF_GLINK_FIRST | tocoff, p);
d5549 2
a5550 1
      tsec = xcoff_data (output_bfd)->toc_section;
d5749 4
a5752 3
  h = xcoff_link_hash_lookup (xcoff_hash_table (finfo->info),
			      link_order->u.reloc.p->u.name,
			      false, false, true);
d5795 1
a5795 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d6010 10
a6019 4
              val = (sec->output_section->vma
		     + sec->output_offset
		     + sym->n_value
		     - sec->vma);
d6048 1
a6048 2
	  else if (! info->relocateable
		   && ! info->shared)
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1995, 1996 Free Software Foundation, Inc.
a437 2
static void xcoff_swap_ldrel_in
  PARAMS ((bfd *, const struct external_ldrel *, struct internal_ldrel *));
a450 2
static boolean xcoff_link_check_dynamic_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, boolean *));
d556 1
a556 13
/* Swap in the ldrel structure.  */

static void
xcoff_swap_ldrel_in (abfd, src, dst)
     bfd *abfd;
     const struct external_ldrel *src;
     struct internal_ldrel *dst;
{
  dst->l_vaddr = bfd_get_32 (abfd, src->l_vaddr);
  dst->l_symndx = bfd_get_32 (abfd, src->l_symndx);
  dst->l_rtype = bfd_get_16 (abfd, src->l_rtype);
  dst->l_rsecnm = bfd_get_16 (abfd, src->l_rsecnm);
}
a571 310
/* Routines to read XCOFF dynamic information.  This don't really
   belong here, but we already have the ldsym manipulation routines
   here.  */

/* Read the contents of a section.  */

static boolean
xcoff_get_section_contents (abfd, sec)
     bfd *abfd;
     asection *sec;
{
  if (coff_section_data (abfd, sec) == NULL)
    {
      sec->used_by_bfd = bfd_zalloc (abfd,
				     sizeof (struct coff_section_tdata));
      if (sec->used_by_bfd == NULL)
	return false;
    }

  if (coff_section_data (abfd, sec)->contents == NULL)
    {
      coff_section_data (abfd, sec)->contents = bfd_malloc (sec->_raw_size);
      if (coff_section_data (abfd, sec)->contents == NULL)
	return false;

      if (! bfd_get_section_contents (abfd, sec,
				      coff_section_data (abfd, sec)->contents,
				      (file_ptr) 0, sec->_raw_size))
	return false;
    }

  return true;
}

/* Get the size required to hold the dynamic symbols.  */

long
_bfd_xcoff_get_dynamic_symtab_upper_bound (abfd)
     bfd *abfd;
{
  asection *lsec;
  bfd_byte *contents;
  struct internal_ldhdr ldhdr;

  if ((abfd->flags & DYNAMIC) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  lsec = bfd_get_section_by_name (abfd, ".loader");
  if (lsec == NULL)
    {
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

  if (! xcoff_get_section_contents (abfd, lsec))
    return -1;
  contents = coff_section_data (abfd, lsec)->contents;

  xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) contents, &ldhdr);

  return (ldhdr.l_nsyms + 1) * sizeof (asymbol *);
}

/* Get the dynamic symbols.  */

long
_bfd_xcoff_canonicalize_dynamic_symtab (abfd, psyms)
     bfd *abfd;
     asymbol **psyms;
{
  asection *lsec;
  bfd_byte *contents;
  struct internal_ldhdr ldhdr;
  const char *strings;
  struct external_ldsym *elsym, *elsymend;
  coff_symbol_type *symbuf;

  if ((abfd->flags & DYNAMIC) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  lsec = bfd_get_section_by_name (abfd, ".loader");
  if (lsec == NULL)
    {
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

  if (! xcoff_get_section_contents (abfd, lsec))
    return -1;
  contents = coff_section_data (abfd, lsec)->contents;

  coff_section_data (abfd, lsec)->keep_contents = true;

  xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) contents, &ldhdr);

  strings = (char *) contents + ldhdr.l_stoff;

  symbuf = ((coff_symbol_type *)
	    bfd_zalloc (abfd, ldhdr.l_nsyms * sizeof (coff_symbol_type)));
  if (symbuf == NULL)
    return -1;

  elsym = (struct external_ldsym *) (contents + LDHDRSZ);
  elsymend = elsym + ldhdr.l_nsyms;
  for (; elsym < elsymend; elsym++, symbuf++, psyms++)
    {
      struct internal_ldsym ldsym;

      xcoff_swap_ldsym_in (abfd, elsym, &ldsym);

      symbuf->symbol.the_bfd = abfd;

      if (ldsym._l._l_l._l_zeroes == 0)
	symbuf->symbol.name = strings + ldsym._l._l_l._l_offset;
      else
	{
	  int i;

	  for (i = 0; i < SYMNMLEN; i++)
	    if (ldsym._l._l_name[i] == '\0')
	      break;
	  if (i < SYMNMLEN)
	    symbuf->symbol.name = elsym->_l._l_name;
	  else
	    {
	      char *c;

	      c = bfd_alloc (abfd, SYMNMLEN + 1);
	      if (c == NULL)
		return -1;
	      memcpy (c, ldsym._l._l_name, SYMNMLEN);
	      c[SYMNMLEN] = '\0';
	      symbuf->symbol.name = c;
	    }
	}

      if (ldsym.l_smclas == XMC_XO)
	symbuf->symbol.section = bfd_abs_section_ptr;
      else
	symbuf->symbol.section = coff_section_from_bfd_index (abfd,
							      ldsym.l_scnum);
      symbuf->symbol.value = ldsym.l_value - symbuf->symbol.section->vma;

      symbuf->symbol.flags = BSF_NO_FLAGS;
      if ((ldsym.l_smtype & L_EXPORT) != 0)
	symbuf->symbol.flags |= BSF_GLOBAL;

      /* FIXME: We have no way to record the other information stored
         with the loader symbol.  */

      *psyms = (asymbol *) symbuf;
    }

  *psyms = NULL;

  return ldhdr.l_nsyms;
}

/* Get the size required to hold the dynamic relocs.  */

long
_bfd_xcoff_get_dynamic_reloc_upper_bound (abfd)
     bfd *abfd;
{
  asection *lsec;
  bfd_byte *contents;
  struct internal_ldhdr ldhdr;

  if ((abfd->flags & DYNAMIC) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  lsec = bfd_get_section_by_name (abfd, ".loader");
  if (lsec == NULL)
    {
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

  if (! xcoff_get_section_contents (abfd, lsec))
    return -1;
  contents = coff_section_data (abfd, lsec)->contents;

  xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) contents, &ldhdr);

  return (ldhdr.l_nreloc + 1) * sizeof (arelent *);
}

/* The typical dynamic reloc.  */

static reloc_howto_type xcoff_dynamic_reloc =
  HOWTO (0,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_POS",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
	 false);                /* pcrel_offset */

/* Get the dynamic relocs.  */

long
_bfd_xcoff_canonicalize_dynamic_reloc (abfd, prelocs, syms)
     bfd *abfd;
     arelent **prelocs;
     asymbol **syms;
{
  asection *lsec;
  bfd_byte *contents;
  struct internal_ldhdr ldhdr;
  arelent *relbuf;
  struct external_ldrel *elrel, *elrelend;

  if ((abfd->flags & DYNAMIC) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  lsec = bfd_get_section_by_name (abfd, ".loader");
  if (lsec == NULL)
    {
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

  if (! xcoff_get_section_contents (abfd, lsec))
    return -1;
  contents = coff_section_data (abfd, lsec)->contents;

  xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) contents, &ldhdr);

  relbuf = (arelent *) bfd_alloc (abfd, ldhdr.l_nreloc * sizeof (arelent));
  if (relbuf == NULL)
    return -1;

  elrel = ((struct external_ldrel *)
	   (contents + LDHDRSZ + ldhdr.l_nsyms * LDSYMSZ));
  elrelend = elrel + ldhdr.l_nreloc;
  for (; elrel < elrelend; elrel++, relbuf++, prelocs++)
    {
      struct internal_ldrel ldrel;

      xcoff_swap_ldrel_in (abfd, elrel, &ldrel);

      if (ldrel.l_symndx >= 3)
	relbuf->sym_ptr_ptr = syms + (ldrel.l_symndx - 3);
      else
	{
	  const char *name;
	  asection *sec;

	  switch (ldrel.l_symndx)
	    {
	    case 0:
	      name = ".text";
	      break;
	    case 1:
	      name = ".data";
	      break;
	    case 2:
	      name = ".bss";
	      break;
	    default:
	      abort ();
	      break;
	    }

	  sec = bfd_get_section_by_name (abfd, name);
	  if (sec == NULL)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      return -1;
	    }

	  relbuf->sym_ptr_ptr = sec->symbol_ptr_ptr;
	}

      relbuf->address = ldrel.l_vaddr;
      relbuf->addend = 0;

      /* Most dynamic relocs have the same type.  FIXME: This is only
         correct if ldrel.l_rtype == 0.  In other cases, we should use
         a different howto.  */
      relbuf->howto = &xcoff_dynamic_reloc;

      /* FIXME: We have no way to record the l_rsecnm field.  */

      *prelocs = relbuf;
    }

  *prelocs = NULL;

  return ldhdr.l_nreloc;
}

d588 4
a591 1
    return (struct bfd_hash_entry *) ret;
d624 4
a627 1
    return (struct bfd_link_hash_table *) NULL;
d745 2
a746 34
      /* We need to look through the archive for stripped dynamic
         objects, because they will not appear in the archive map even
         though they should, perhaps, be included.  Also, if the
         linker has no map, we just consider each object file in turn,
         since that apparently is what the AIX native linker does.  */
      {
	bfd *member;

	member = bfd_openr_next_archived_file (abfd, (bfd *) NULL);
	while (member != NULL)
	  {
	    if (bfd_check_format (member, bfd_object)
		&& (! bfd_has_map (abfd)
		    || ((member->flags & DYNAMIC) != 0
			&& (member->flags & HAS_SYMS) == 0)))
	      {
		boolean needed;

		if (! xcoff_link_check_archive_element (member, info, &needed))
		  return false;
		if (needed)
		  member->archive_pass = -1;
	      }
	    member = bfd_openr_next_archived_file (abfd, member);
	  }

	if (! bfd_has_map (abfd))
	  return true;

	/* Now do the usual search.  */
	return (_bfd_generic_link_add_archive_symbols
		(abfd, info, xcoff_link_check_archive_element));
      }

a818 5
  if ((abfd->flags & DYNAMIC) != 0
      && ! info->static_link
      && info->hash->creator == abfd->xvec)
    return xcoff_link_check_dynamic_ar_symbols (abfd, info, pneeded);

a863 81
/* Look through the loader symbols to see if this dynamic object
   should be included in the link.  The native linker uses the loader
   symbols, not the normal symbol table, so we do too.  */

static boolean
xcoff_link_check_dynamic_ar_symbols (abfd, info, pneeded)
     bfd *abfd;
     struct bfd_link_info *info;
     boolean *pneeded;
{
  asection *lsec;
  bfd_byte *buf;
  struct internal_ldhdr ldhdr;
  const char *strings;
  struct external_ldsym *elsym, *elsymend;

  *pneeded = false;

  lsec = bfd_get_section_by_name (abfd, ".loader");
  if (lsec == NULL)
    {
      /* There are no symbols, so don't try to include it.  */
      return true;
    }

  if (! xcoff_get_section_contents (abfd, lsec))
    return false;
  buf = coff_section_data (abfd, lsec)->contents;

  xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) buf, &ldhdr);

  strings = (char *) buf + ldhdr.l_stoff;

  elsym = (struct external_ldsym *) (buf + LDHDRSZ);
  elsymend = elsym + ldhdr.l_nsyms;
  for (; elsym < elsymend; elsym++)
    {
      struct internal_ldsym ldsym;
      char nambuf[SYMNMLEN + 1];
      const char *name;
      struct bfd_link_hash_entry *h;

      xcoff_swap_ldsym_in (abfd, elsym, &ldsym);

      /* We are only interested in exported symbols.  */
      if ((ldsym.l_smtype & L_EXPORT) == 0)
	continue;

      if (ldsym._l._l_l._l_zeroes == 0)
	name = strings + ldsym._l._l_l._l_offset;
      else
	{
	  memcpy (nambuf, ldsym._l._l_name, SYMNMLEN);
	  nambuf[SYMNMLEN] = '\0';
	  name = nambuf;
	}

      h = bfd_link_hash_lookup (info->hash, name, false, false, true);

      /* We are only interested in symbols that are currently
         undefined.  */
      if (h != NULL && h->type == bfd_link_hash_undefined)
	{
	  if (! (*info->callbacks->add_archive_element) (info, abfd, name))
	    return false;
	  *pneeded = true;
	  return true;
	}
    }

  /* We do not need this shared object.  */

  if (buf != NULL && ! coff_section_data (abfd, lsec)->keep_contents)
    {
      free (coff_section_data (abfd, lsec)->contents);
      coff_section_data (abfd, lsec)->contents = NULL;
    }

  return true;
}

d962 8
a969 4
    {
      if (! xcoff_link_add_dynamic_symbols (abfd, info))
	return false;
    }
d972 2
a973 2
     work if we're producing an XCOFF output file with no XCOFF input
     files.  FIXME.  */
a1031 11
  if ((abfd->flags & DYNAMIC) != 0
      && ! info->static_link)
    return true;

  n_tmask = coff_data (abfd)->local_n_tmask;
  n_btshft = coff_data (abfd)->local_n_btshft;

  /* Define macros so that ISFCN, et. al., macros work correctly.  */
#define N_TMASK n_tmask
#define N_BTSHFT n_btshft

d1046 4
a1049 1
    goto error_return;
d1060 4
a1063 1
    goto error_return;
d1073 2
a1074 2
		bfd_malloc ((abfd->section_count + 1)
			    * sizeof (struct reloc_info_struct)));
d1076 4
a1079 1
    goto error_return;
d1095 1
a1095 1
	    (asection **) bfd_malloc (o->reloc_count * sizeof (asection *));
d1097 4
a1100 1
	    goto error_return;
d1110 1
a1110 1
	  linenos = (bfd_byte *) bfd_malloc (o->lineno_count * linesz);
d1112 4
a1115 1
	    goto error_return;
d1492 4
a1495 1
	      goto error_return;
d1499 4
a1502 1
	      goto error_return;
d1625 4
a1628 1
	    goto error_return;
d1632 4
a1635 1
	    goto error_return;
d1701 2
a1702 7
	      if (! bfd_is_und_section (section))
		*sym_hash = xcoff_link_hash_lookup (xcoff_hash_table (info),
						    name, true, copy, false);
	      else
		*sym_hash = ((struct xcoff_link_hash_entry *)
			     bfd_wrapped_link_hash_lookup (abfd, info, name,
							   true, copy, false));
d1927 1
a1927 1
  bfd_byte *buf;
d1946 1
a1946 1
      return false;
d1967 8
a1974 1
      return false;
d1977 3
a1979 3
  if (! xcoff_get_section_contents (abfd, lsec))
    return false;
  buf = coff_section_data (abfd, lsec)->contents;
d2014 1
a2014 1
      /* Normally we could not call xcoff_link_hash_lookup in an add
d2022 1
a2022 1
	return false;
d2063 1
a2063 1
  if (buf != NULL && ! coff_section_data (abfd, lsec)->keep_contents)
d2065 2
a2066 2
      free (coff_section_data (abfd, lsec)->contents);
      coff_section_data (abfd, lsec)->contents = NULL;
d2074 4
a2077 1
    return false;
d2111 5
d2249 1
a2249 4
			      || info->shared
			      || ((h->descriptor->flags & XCOFF_IMPORT) != 0
				  && (h->descriptor->flags
				      & XCOFF_DEF_REGULAR) == 0))))
d2347 4
a2350 1
    return false;
d2404 4
a2407 1
	return false;
d2436 4
a2439 1
	    return false;
d2480 1
a2480 1
      fnname = (char *) bfd_malloc (strlen (h->root.root.string) + 2);
d2482 4
a2485 1
	return false;
d2535 2
a2536 3
  h = ((struct xcoff_link_hash_entry *)
       bfd_wrapped_link_hash_lookup (output_bfd, info, name, false, false,
				     false));
a2588 2
  /* Whether all defined symbols should be exported.  */
  boolean export_defineds;
d2604 1
a2604 11
   is the name of the entry point symbol (the -e linker option).
   FILE_ALIGN is the alignment to use for sections within the file
   (the -H linker option).  MAXSTACK is the maximum stack size (the
   -bmaxstack linker option).  MAXDATA is the maximum data size (the
   -bmaxdata linker option).  GC is whether to do garbage collection
   (the -bgc linker option).  MODTYPE is the module type (the
   -bmodtype linker option).  TEXTRO is whether the text section must
   be read only (the -btextro linker option).  EXPORT_DEFINEDS is
   whether all defined symbols should be exported (the -unix linker
   option).  SPECIAL_SECTIONS is set by this routine to csects with
   magic names like _end.  */
d2609 1
a2609 2
				 modtype, textro, export_defineds,
				 special_sections)
a2619 1
     boolean export_defineds;
d2637 1
a2637 5
    {
      for (i = 0; i < 6; i++)
	special_sections[i] = NULL;
      return true;
    }
a2641 1
  ldinfo.export_defineds = export_defineds;
d2657 7
a2663 1
    hentry->flags |= XCOFF_ENTRY;
d2763 4
a2766 1
    goto error_return;
d2817 4
a2820 1
	goto error_return;
d2827 4
a2830 1
	goto error_return;
d2837 4
a2840 1
	goto error_return;
d2877 4
a2880 1
	goto error_return;
d2888 1
a2888 1
      debug_contents = (bfd_byte *) bfd_malloc (subdeb->_raw_size);
d2890 4
a2893 1
	goto error_return;
a2969 5
  /* If all defined symbols should be exported, mark them now.  */
  if (ldinfo->export_defineds
      && (h->flags & XCOFF_DEF_REGULAR) != 0)
    h->flags |= XCOFF_EXPORT;

d2982 3
a2984 3
     defined at all when building a shared object, or imported, then
     we need to set up global linkage code for it.  (Unless we did
     garbage collection and we didn't need this symbol.)  */
d2991 1
a2991 3
	  || ldinfo->info->shared
	  || ((h->descriptor->flags & XCOFF_IMPORT) != 0
	      && (h->descriptor->flags & XCOFF_DEF_REGULAR) == 0))
d3130 1
d3157 5
a3161 2
	  newstrings = ((bfd_byte *)
			bfd_realloc ((PTR) ldinfo->strings, newalc));
d3165 1
a3257 6
	      /* Mark all sections which are to be included in the
		 link.  This will normally be every section.  We need
		 to do this so that we can identify any sections which
		 the linker has decided to not include.  */
	      sec->linker_mark = true;

d3385 3
a3387 4
    finfo.section_info =
      ((struct xcoff_link_section_info *)
       bfd_malloc ((abfd->section_count + 1)
		   * sizeof (struct xcoff_link_section_info)));
d3389 4
a3392 1
      goto error_return;
d3430 1
a3430 1
	     bfd_malloc (o->reloc_count * sizeof (struct internal_reloc)));
d3433 1
a3433 1
	     bfd_malloc (o->reloc_count
d3437 4
a3440 1
	    goto error_return;
d3487 3
a3489 3
			 bfd_malloc (max_sym_count
				     * sizeof (struct internal_syment)));
  finfo.sym_indices = (long *) bfd_malloc (max_sym_count * sizeof (long));
d3491 5
a3495 5
		   bfd_malloc ((size_t) ((max_sym_count + 1) * symesz)));
  finfo.linenos = (bfd_byte *) bfd_malloc (max_lineno_count
					   * bfd_coff_linesz (abfd));
  finfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
  finfo.external_relocs = (bfd_byte *) bfd_malloc (max_reloc_count * relsz);
d3502 4
a3505 1
    goto error_return;
a3979 7

	  /* Fill in snentry now that we know the target_index.  */
	  if ((h->flags & XCOFF_ENTRY) != 0
	      && (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak))
	    xcoff_data (output_bfd)->snentry =
	      h->root.u.def.section->output_section->target_index;
a4013 34
	      bfd_vma tocval, tocend;

	      tocval = ((*csectpp)->output_section->vma
			+ (*csectpp)->output_offset
			+ isym.n_value
			- (*csectpp)->vma);
	      /* We want to find out if tocval is a good value to use
                 as the TOC anchor--that is, whether we can access all
                 of the TOC using a 16 bit offset from tocval.  This
                 test assumes that the TOC comes at the end of the
                 output section, as it does in the default linker
                 script.  */

	      tocend = ((*csectpp)->output_section->vma
			+ (*csectpp)->output_section->_raw_size);

	      if (tocval + 0x10000 < tocend)
		{
		  (*_bfd_error_handler)
		    ("TOC overflow: 0x%lx > 0x10000; try -mminimal-toc when compiling",
		     (unsigned long) (tocend - tocval));
		  bfd_set_error (bfd_error_file_too_big);
		  return false;
		}

	      if (tocval + 0x8000 < tocend)
		{
		  bfd_vma tocadd;

		  tocadd = tocend - (tocval + 0x8000);
		  tocval += tocadd;
		  isym.n_value += tocadd;
		}

d4015 7
a4021 3
	      xcoff_data (finfo->output_bfd)->toc = tocval;
	      xcoff_data (finfo->output_bfd)->sntoc =
		(*csectpp)->output_section->target_index;
d4356 1
a4356 2
		      || isymp->n_sclass == C_BLOCK
		      || isymp->n_sclass == C_FCN)
a4489 1
			      int iiadd;
d4501 2
a4502 3
				  if (*iindp >= 0
				      && (iisp->n_sclass == C_BINCL
					  || iisp->n_sclass == C_EINCL)
d4525 3
a4527 5
				  iiadd = 1 + iisp->n_numaux;
				  if (*iindp >= 0)
				    oos += iiadd * osymesz;
				  iisp += iiadd;
				  iindp += iiadd;
a4587 6
      if (! o->linker_mark)
	{
	  /* This section was omitted from the link.  */
	  continue;
	}

d4682 4
a4685 1
			    return false;
d4996 1
a4996 1
      bfd_put_32 (output_bfd, XCOFF_GLINK_FIRST | (tocoff & 0xffff), p);
d5109 1
a5109 2
      tsec = coff_section_from_bfd_index (output_bfd,
					  xcoff_data (output_bfd)->sntoc);
d5308 3
a5310 4
  h = ((struct xcoff_link_hash_entry *)
       bfd_wrapped_link_hash_lookup (output_bfd, finfo->info,
				     link_order->u.reloc.p->u.name,
				     false, false, true));
d5353 4
a5356 1
	return false;
d5571 4
a5574 10
	      /* Hack to make sure we use the right TOC anchor value
                 if this reloc is against the TOC anchor.  */
	      if (sec->name[3] == '0'
		  && strcmp (sec->name, ".tc0") == 0)
		val = xcoff_data (output_bfd)->toc;
	      else
		val = (sec->output_section->vma
		       + sec->output_offset
		       + sym->n_value
		       - sec->vma);
d5603 2
a5604 1
	  else if (! info->relocateable)
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d259 1
a259 1
         symbol index of the C_HIDEXT XMC_TC or XMC_TD symbol.  */
a302 2
  /* Multiple definitions have been for the symbol.  */
#define XCOFF_MULTIPLY_DEFINED (020000)
a1063 1

d1065 5
a1069 13
      /* If the archive has a map, do the usual search.  We then need
         to check the archive for stripped dynamic objects, because
         they will not appear in the archive map even though they
         should, perhaps, be included.  If the archive has no map, we
         just consider each object file in turn, since that apparently
         is what the AIX native linker does.  */
      if (bfd_has_map (abfd))
	{
	  if (! (_bfd_generic_link_add_archive_symbols
		 (abfd, info, xcoff_link_check_archive_element)))
	    return false;
	}

d1090 7
a1098 2
      return true;

d1205 1
a1205 4
	      && h->type == bfd_link_hash_undefined
	      && (info->hash->creator != abfd->xvec
		  || (((struct xcoff_link_hash_entry *) h)->flags
		      & XCOFF_DEF_DYNAMIC) == 0))
d1281 2
a1282 6
         undefined.  At this point we know that we are using an XCOFF
         hash table.  */
      if (h != NULL
	  && h->type == bfd_link_hash_undefined
	  && (((struct xcoff_link_hash_entry *) h)->flags
	      & XCOFF_DEF_DYNAMIC) == 0)
d1405 4
a1408 1
  if (info->hash->creator == abfd->xvec)
d1410 1
a1410 6
      /* We need to build a .loader section, so we do it here.  This
	 won't work if we're producing an XCOFF output file with no
	 XCOFF input files.  FIXME.  */
      if (xcoff_hash_table (info)->loader_section == NULL)
	{
	  asection *lsec;
d1412 10
a1421 10
	  lsec = bfd_make_section_anyway (abfd, ".loader");
	  if (lsec == NULL)
	    goto error_return;
	  xcoff_hash_table (info)->loader_section = lsec;
	  lsec->flags |= SEC_HAS_CONTENTS | SEC_IN_MEMORY;
	}
      /* Likewise for the linkage section.  */
      if (xcoff_hash_table (info)->linkage_section == NULL)
	{
	  asection *lsec;
d1423 11
a1433 12
	  lsec = bfd_make_section_anyway (abfd, ".gl");
	  if (lsec == NULL)
	    goto error_return;
	  xcoff_hash_table (info)->linkage_section = lsec;
	  lsec->flags |= (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			  | SEC_IN_MEMORY);
	  lsec->alignment_power = 2;
	}
      /* Likewise for the TOC section.  */
      if (xcoff_hash_table (info)->toc_section == NULL)
	{
	  asection *tsec;
d1435 11
a1445 12
	  tsec = bfd_make_section_anyway (abfd, ".tc");
	  if (tsec == NULL)
	    goto error_return;
	  xcoff_hash_table (info)->toc_section = tsec;
	  tsec->flags |= (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			  | SEC_IN_MEMORY);
	  tsec->alignment_power = 2;
	}
      /* Likewise for the descriptor section.  */
      if (xcoff_hash_table (info)->descriptor_section == NULL)
	{
	  asection *dsec;
d1447 11
a1457 12
	  dsec = bfd_make_section_anyway (abfd, ".ds");
	  if (dsec == NULL)
	    goto error_return;
	  xcoff_hash_table (info)->descriptor_section = dsec;
	  dsec->flags |= (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			  | SEC_IN_MEMORY);
	  dsec->alignment_power = 2;
	}
      /* Likewise for the .debug section.  */
      if (xcoff_hash_table (info)->debug_section == NULL)
	{
	  asection *dsec;
d1459 5
a1463 6
	  dsec = bfd_make_section_anyway (abfd, ".debug");
	  if (dsec == NULL)
	    goto error_return;
	  xcoff_hash_table (info)->debug_section = dsec;
	  dsec->flags |= SEC_HAS_CONTENTS | SEC_IN_MEMORY;
	}
d2072 1
a2072 2
	  && aux.x_csect.x_smclas != XMC_TC
	  && aux.x_csect.x_smclas != XMC_TD)
a2112 17
	  /* The AIX linker appears to only detect multiple symbol
	     definitions when there is a reference to the symbol.  If
	     a symbol is defined multiple times, and the only
	     references are from the same object file, the AIX linker
	     appears to permit it.  It does not merge the different
	     definitions, but handles them independently.  On the
	     other hand, if there is a reference, the linker reports
	     an error.

	     This matters because the AIX <net/net_globals.h> header
	     file actually defines an initialized array, so we have to
	     actually permit that to work.

	     We also have to handle the case of statically linking a
	     shared object, which will cause symbol redefinitions,
	     although this is an easier case to detect.  */

d2115 4
d2133 1
a2133 6
		  /* This is a second definition of a defined symbol.  */
		  if ((abfd->flags & DYNAMIC) != 0
		      && ((*sym_hash)->smclas != XMC_GL
			  || aux.x_csect.x_smclas == XMC_GL
			  || ((*sym_hash)->root.u.def.section->owner->flags
			      & DYNAMIC) == 0))
a2134 6
		      /* The new symbol is from a shared library, and
                         either the existing symbol is not global
                         linkage code or this symbol is global linkage
                         code.  If the existing symbol is global
                         linkage code and the new symbol is not, then
                         we want to use the new symbol.  */
a2140 2
		      /* The existing symbol is from a shared library.
                         Replace it.  */
a2144 40
		  else if ((*sym_hash)->root.next != NULL
			   || info->hash->undefs_tail == &(*sym_hash)->root)
		    {
		      /* This symbol has been referenced.  In this
                         case, we just continue and permit the
                         multiple definition error.  See the comment
                         above about the behaviour of the AIX linker.  */
		    }
		  else if ((*sym_hash)->smclas == aux.x_csect.x_smclas)
		    {
		      /* The symbols are both csects of the same
                         class.  There is at least a chance that this
                         is a semi-legitimate redefinition.  */
		      section = bfd_und_section_ptr;
		      value = 0;
		      (*sym_hash)->flags |= XCOFF_MULTIPLY_DEFINED;
		    }
		}
	      else if (((*sym_hash)->flags & XCOFF_MULTIPLY_DEFINED) != 0
		       && ((*sym_hash)->root.type == bfd_link_hash_defined
			   || (*sym_hash)->root.type == bfd_link_hash_defweak)
		       && (bfd_is_und_section (section)
			   || bfd_is_com_section (section)))
		{
		  /* This is a reference to a multiply defined symbol.
		     Report the error now.  See the comment above
		     about the behaviour of the AIX linker.  We could
		     also do this with warning symbols, but I'm not
		     sure the XCOFF linker is wholly prepared to
		     handle them, and that would only be a warning,
		     not an error.  */
		  if (! ((*info->callbacks->multiple_definition)
			 (info, (*sym_hash)->root.root.string,
			  (bfd *) NULL, (asection *) NULL, 0,
			  (*sym_hash)->root.u.def.section->owner,
			  (*sym_hash)->root.u.def.section,
			  (*sym_hash)->root.u.def.value)))
		    goto error_return;
		  /* Try not to give this error too many times.  */
		  (*sym_hash)->flags &= ~XCOFF_MULTIPLY_DEFINED;
d2210 1
a2210 1
      /* Reset the section size and the line number count, since the
a2476 55

      /* If this symbol defines a function descriptor, then it
	 implicitly defines the function code as well.  */
      if (h->smclas == XMC_DS
	  || (h->smclas == XMC_XO && name[0] != '.'))
	h->flags |= XCOFF_DESCRIPTOR;
      if ((h->flags & XCOFF_DESCRIPTOR) != 0)
	{
	  struct xcoff_link_hash_entry *hds;

	  hds = h->descriptor;
	  if (hds == NULL)
	    {
	      char *dsnm;

	      dsnm = bfd_malloc (strlen (name) + 2);
	      if (dsnm == NULL)
		return false;
	      dsnm[0] = '.';
	      strcpy (dsnm + 1, name);
	      hds = xcoff_link_hash_lookup (xcoff_hash_table (info), dsnm,
					    true, true, true);
	      free (dsnm);
	      if (hds == NULL)
		return false;

	      if (hds->root.type == bfd_link_hash_new)
		{
		  hds->root.type = bfd_link_hash_undefined;
		  hds->root.u.undef.abfd = abfd;
		  /* We do not want to add this to the undefined
                     symbol list.  */
		}

	      hds->descriptor = h;
	      h->descriptor = hds;
	    }

	  hds->flags |= XCOFF_DEF_DYNAMIC;
	  if (hds->smclas == XMC_UA)
	    hds->smclas = XMC_PR;

	  /* An absolute symbol appears to actually define code, not a
	     function descriptor.  This is how some math functions are
	     implemented on AIX 4.1.  */
	  if (h->smclas == XMC_XO
	      && (hds->root.type == bfd_link_hash_undefined
		  || hds->root.type == bfd_link_hash_undefweak))
	    {
	      hds->smclas = XMC_XO;
	      hds->root.type = bfd_link_hash_defined;
	      hds->root.u.def.section = bfd_abs_section_ptr;
	      hds->root.u.def.value = ldsym.l_value;
	    }
	}
d2657 1
d3365 1
a3365 15
  /* If this is a final link, and the symbol was defined as a common
     symbol in a regular object file, and there was no definition in
     any dynamic object, then the linker will have allocated space for
     the symbol in a common section but the XCOFF_DEF_REGULAR flag
     will not have been set.  */
  if (h->root.type == bfd_link_hash_defined
      && (h->flags & XCOFF_DEF_REGULAR) == 0
      && (h->flags & XCOFF_REF_REGULAR) != 0
      && (h->flags & XCOFF_DEF_DYNAMIC) == 0
      && (h->root.u.def.section->owner->flags & DYNAMIC) == 0)
    h->flags |= XCOFF_DEF_REGULAR;

  /* If all defined symbols should be exported, mark them now.  We
     don't want to export the actual functions, just the function
     descriptors.  */
d3367 1
a3367 2
      && (h->flags & XCOFF_DEF_REGULAR) != 0
      && h->root.root.string[0] != '.')
d3381 4
a3384 4
  /* If this symbol is called and defined in a dynamic object, or it
     is imported, then we need to set up global linkage code for it.
     (Unless we did garbage collection and we didn't need this
     symbol.)  */
d3391 1
d3470 1
a3470 1
	    ("warning: attempt to export undefined symbol `%s'",
d3472 3
a3474 2
	  h->ldsym = NULL;
	  return true;
a5087 1
	      boolean quiet;
d5100 6
a5105 7
		  if (h != NULL
		      && h->smclas != XMC_TD
		      && (irel->r_type == R_TOC
			  || irel->r_type == R_GL
			  || irel->r_type == R_TCL
			  || irel->r_type == R_TRL
			  || irel->r_type == R_TRLA))
a5211 1
	      quiet = false;
d5263 1
a5263 11
		      if (! finfo->info->relocateable
			  && (h->flags & XCOFF_DEF_DYNAMIC) == 0
			  && (h->flags & XCOFF_IMPORT) == 0)
			{
			  /* We already called the undefined_symbol
			     callback for this relocation, in
			     _bfd_ppc_xcoff_relocate_section.  Don't
			     issue any more warnings.  */
			  quiet = true;
			}
		      if (h->ldindx < 0 && ! quiet)
d5277 1
a5277 2
		      && strcmp (o->output_section->name, ".text") == 0
		      && ! quiet)
a6053 4

	      /* Don't try to process the reloc.  It can't help, and
                 it may generate another error.  */
	      continue;
d6116 10
a6125 1
	  if (h != NULL && h->smclas != XMC_TD)
a6126 10
	      if (h->toc_section == NULL)
		{
		  (*_bfd_error_handler)
		    ("%s: TOC reloc at 0x%x to symbol `%s' with no TOC entry",
		     bfd_get_filename (input_bfd), rel->r_vaddr,
		     h->root.root.string);
		  bfd_set_error (bfd_error_bad_value);
		  return false;
		}

a6130 1

d6203 1
a6203 5

	  /* The _ptrgl function is magic.  It is used by the AIX
             compiler to call a function through a pointer.  */
	  if (h->smclas == XMC_GL
	      || strcmp (h->root.root.string, "._ptrgl") == 0)
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d272 1
a272 3
  /* If XCOFF_BUILT_LDSYM is set, this is the .loader symbol table
     index.  If XCOFF_BUILD_LDSYM is clear, and XCOFF_IMPORT is set,
     this is the l_ifile value.  */
a1410 2
  keep_syms = obj_coff_keep_syms (abfd);

d1574 1
d2947 8
a2954 4
  /* We overload the ldindx field to hold the l_ifile value for this
     symbol.  */
  BFD_ASSERT (h->ldsym == NULL);
  BFD_ASSERT ((h->flags & XCOFF_BUILT_LDSYM) == 0);
d2956 1
a2956 1
    h->ldindx = -1;
d2989 1
a2989 1
      h->ldindx = c;
d3675 2
a3676 4
  BFD_ASSERT (h->ldsym == NULL);
  h->ldsym = ((struct internal_ldsym *)
	      bfd_zalloc (ldinfo->output_bfd,
			  sizeof (struct internal_ldsym)));
d3679 8
a3686 2
      ldinfo->failed = true;
      return false;
a3688 3
  if ((h->flags & XCOFF_IMPORT) != 0)
    h->ldsym->l_ifile = h->ldindx;

d3863 1
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997 Free Software Foundation, Inc.
a447 1
static boolean xcoff_get_section_contents PARAMS ((bfd *, asection *));
a463 2
static boolean xcoff_mark_symbol
  PARAMS ((struct bfd_link_info *, struct xcoff_link_hash_entry *));
d3421 1
a3421 1
	 copy the names into the debug stringtab, rather than
d3522 1
a3522 41
    {
      boolean export;

      /* We don't export a symbol which is being defined by an object
	 included from an archive which contains a shared object.  The
	 rationale is that if an archive contains both an unshared and
	 a shared object, then there must be some reason that the
	 unshared object is unshared, and we don't want to start
	 providing a shared version of it.  In particular, this solves
	 a bug involving the _savefNN set of functions.  gcc will call
	 those functions without providing a slot to restore the TOC,
	 so it is essential that these functions be linked in directly
	 and not from a shared object, which means that a shared
	 object which also happens to link them in must not export
	 them.  This is confusing, but I haven't been able to think of
	 a different approach.  Note that the symbols can, of course,
	 be exported explicitly.  */
      export = true;
      if ((h->root.type == bfd_link_hash_defined
	   || h->root.type == bfd_link_hash_defweak)
	  && h->root.u.def.section->owner != NULL
	  && h->root.u.def.section->owner->my_archive != NULL)
	{
	  bfd *arbfd, *member;

	  arbfd = h->root.u.def.section->owner->my_archive;
	  member = bfd_openr_next_archived_file (arbfd, (bfd *) NULL);
	  while (member != NULL)
	    {
	      if ((member->flags & DYNAMIC) != 0)
		{
		  export = false;
		  break;
		}
	      member = bfd_openr_next_archived_file (arbfd, member);
	    }
	}

      if (export)
	h->flags |= XCOFF_EXPORT;
    }
d3929 1
a3929 2
      if (! bfd_coff_compute_section_file_positions (abfd))
	goto error_return;
d4020 1
a4020 1
     input BFD's.  We want at least 6 symbols, since that is the
d4022 1
a4022 1
  max_sym_count = 6;
d4147 1
a4147 1
  external_relocs = (bfd_byte *) bfd_malloc (max_output_reloc_count * relsz);
d4149 4
a4152 1
    goto error_return;
d4670 2
a4671 1
		  && bfd_is_local_label_name (input_bfd, name)))
a5507 1
  outsym = finfo->outsyms;
a5615 2
      struct internal_syment irsym;
      union internal_auxent iraux;
a5642 57

      /* We need to emit a symbol to define a csect which holds the
         reloc.  */
      if (strlen (h->root.root.string) <= SYMNMLEN)
	strncpy (irsym._n._n_name, h->root.root.string, SYMNMLEN);
      else
	{
	  boolean hash;
	  bfd_size_type indx;

	  hash = true;
	  if ((output_bfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
	    hash = false;
	  indx = _bfd_stringtab_add (finfo->strtab, h->root.root.string, hash,
				     false);
	  if (indx == (bfd_size_type) -1)
	    return false;
	  irsym._n._n_n._n_zeroes = 0;
	  irsym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;
	}

      irsym.n_value = irel->r_vaddr;
      irsym.n_scnum = osec->target_index;
      irsym.n_sclass = C_HIDEXT;
      irsym.n_type = T_NULL;
      irsym.n_numaux = 1;

      bfd_coff_swap_sym_out (output_bfd, (PTR) &irsym, (PTR) outsym);
      outsym += bfd_coff_symesz (output_bfd);

      memset (&iraux, 0, sizeof iraux);
      iraux.x_csect.x_smtyp = XTY_SD;
      iraux.x_csect.x_scnlen.l = 4;
      iraux.x_csect.x_smclas = XMC_TC;

      bfd_coff_swap_aux_out (output_bfd, (PTR) &iraux, T_NULL, C_HIDEXT, 0, 1,
			     (PTR) outsym);
      outsym += bfd_coff_auxesz (output_bfd);

      if (h->indx >= 0)
	{
	  /* We aren't going to write out the symbols below, so we
             need to write them out now.  */
	  if (bfd_seek (output_bfd,
			(obj_sym_filepos (output_bfd)
			 + (obj_raw_syment_count (output_bfd)
			    * bfd_coff_symesz (output_bfd))),
			SEEK_SET) != 0
	      || (bfd_write (finfo->outsyms, outsym - finfo->outsyms, 1,
			     output_bfd)
		  != (bfd_size_type) (outsym - finfo->outsyms)))
	    return false;
	  obj_raw_syment_count (output_bfd) +=
	    (outsym - finfo->outsyms) / bfd_coff_symesz (output_bfd);

	  outsym = finfo->outsyms;
	}
d5750 1
a5750 4
    {
      BFD_ASSERT (outsym == finfo->outsyms);
      return true;
    }
d5758 1
a5758 4
    {
      BFD_ASSERT (outsym == finfo->outsyms);
      return true;
    }
d5762 3
a5764 4
    {
      BFD_ASSERT (outsym == finfo->outsyms);
      return true;
    }
a5795 10
  else if ((h->root.type == bfd_link_hash_defined
	    || h->root.type == bfd_link_hash_defweak)
	   && h->smclas == XMC_XO)
    {
      BFD_ASSERT (bfd_is_abs_section (h->root.u.def.section));
      isym.n_value = h->root.u.def.value;
      isym.n_scnum = N_UNDEF;
      isym.n_sclass = C_EXT;
      aux.x_csect.x_smtyp = XTY_ER;
    }
d5846 2
a5847 3
  if ((h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak)
      && h->smclas != XMC_XO)
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d616 1
a616 2
      coff_section_data (abfd, sec)->contents =
	(bfd_byte *) bfd_malloc (sec->_raw_size);
d723 1
a723 1
	    symbuf->symbol.name = (char *) elsym->_l._l_name;
d1480 1
a1480 2
      if (xcoff_hash_table (info)->debug_section == NULL
	  && info->strip != strip_all)
d1659 1
a1659 1
		    (_("%s: `%s' has line numbers but no enclosing section"),
d1711 1
a1711 1
	    (_("%s: class %d symbol `%s' has no aux entries"),
d1734 1
a1734 1
	    (_("%s: symbol `%s' has unrecognized csect type %d"),
d1746 1
a1746 1
		(_("%s: bad XTY_ER symbol `%s': class %d scnum %d scnlen %d"),
d1785 1
a1785 1
		    (_("%s: XMC_TC0 symbol `%s' is class %d scnlen %d"),
d1909 1
a1909 1
		  (_("%s: symbol `%s' has unrecognized smclas %d"),
d1928 1
a1928 1
		  (_("%s: csect `%s' not in enclosing section"),
d1944 2
a1945 1
	      (PTR) bfd_zalloc (abfd, sizeof (struct coff_section_tdata));
d2033 1
a2033 1
		  (_("%s: misplaced XTY_LD `%s'"),
d2045 2
a2046 5
             the storage mapping class, but we don't bother except for
             an XMC_TD symbol.  If this csect is externally visible,
             it is a common symbol.  We put XMC_TD symbols in sections
             named .tocbss, and rely on the linker script to put that
             in the TOC area.  */
d2056 1
a2056 4
	  if (aux.x_csect.x_smclas == XMC_TD)
	    csect = bfd_make_section_anyway (abfd, ".tocbss");
	  else
	    csect = bfd_make_section_anyway (abfd, ".bss");
d2071 2
a2072 1
	    (PTR) bfd_zalloc (abfd, sizeof (struct coff_section_tdata));
a2151 8
	     Just to make matters even more confusing, the AIX linker
	     appears to permit multiple symbol definitions whenever
	     the second definition is in an archive rather than an
	     object file.  This may be a consequence of the manner in
	     which it handles archives: I think it may load the entire
	     archive in as separate csects, and then let garbage
	     collection discard symbols.

a2196 8
		  else if (abfd->my_archive != NULL)
		    {
		      /* This is a redefinition in an object contained
                         in an archive.  Just ignore it.  See the
                         comment above.  */
		      section = bfd_und_section_ptr;
		      value = 0;
		    }
d2323 1
a2323 1
		    (_("%s: reloc %s:%d not in csect"),
d2458 1
a2458 1
	(_("%s: XCOFF shared object when not producing XCOFF output"),
d2479 1
a2479 1
	(_("%s: dynamic object with no .loader section"),
d2694 1
a2694 2
      if (! bfd_is_abs_section (hsec)
	  && (hsec->flags & SEC_MARK) == 0)
d2722 1
a2722 2
  if (bfd_is_abs_section (sec)
      || (sec->flags & SEC_MARK) != 0)
a2932 36
  /* A symbol name which starts with a period is the code for a
     function.  If the symbol is undefined, then add an undefined
     symbol for the function descriptor, and import that instead.  */
  if (h->root.root.string[0] == '.'
      && h->root.type == bfd_link_hash_undefined
      && val == (bfd_vma) -1)
    {
      struct xcoff_link_hash_entry *hds;

      hds = h->descriptor;
      if (hds == NULL)
	{
	  hds = xcoff_link_hash_lookup (xcoff_hash_table (info),
					h->root.root.string + 1,
					true, false, true);
	  if (hds == NULL)
	    return false;
	  if (hds->root.type == bfd_link_hash_new)
	    {
	      hds->root.type = bfd_link_hash_undefined;
	      hds->root.u.undef.abfd = h->root.u.undef.abfd;
	    }
	  hds->flags |= XCOFF_DESCRIPTOR;
	  BFD_ASSERT ((hds->flags & XCOFF_CALLED) == 0
		      && (h->flags & XCOFF_DESCRIPTOR) == 0);
	  hds->descriptor = h;
	  h->descriptor = hds;
	}

      /* Now, if the descriptor is undefined, import the descriptor
         rather than the symbol we were told to import.  FIXME: Is
         this correct in all cases?  */
      if (hds->root.type == bfd_link_hash_undefined)
	h = hds;
    }

d3004 1
a3004 1
     boolean syscall ATTRIBUTE_UNUSED;
d3081 1
a3081 1
      (*_bfd_error_handler) (_("%s: no such symbol"), name);
d3215 4
a3218 9
  if (entry == NULL)
    hentry = NULL;
  else
    {
      hentry = xcoff_link_hash_lookup (xcoff_hash_table (info), entry,
				       false, false, true);
      if (hentry != NULL)
	hentry->flags |= XCOFF_ENTRY;
    }
d3484 2
a3485 3
  if (info->strip != strip_all)
    xcoff_hash_table (info)->debug_section->_raw_size =
      _bfd_stringtab_size (debug_strtab);
d3516 1
a3516 2
      && (bfd_is_abs_section (h->root.u.def.section)
	  || (h->root.u.def.section->owner->flags & DYNAMIC) == 0))
d3666 1
a3666 1
	    (_("warning: attempt to export undefined symbol `%s'"),
d4006 3
a4008 11
	  /* A stripped file has no relocs.  However, we still
             allocate the buffers, so that later code doesn't have to
             worry about whether we are stripping or not.  */
	  if (info->strip == strip_all)
	    o->rel_filepos = 0;
	  else
	    {
	      o->flags |= SEC_RELOC;
	      o->rel_filepos = rel_filepos;
	      rel_filepos += o->reloc_count * relsz;
	    }
a4202 7
      /* A stripped file has no relocs.  */
      if (info->strip == strip_all)
	{
	  o->reloc_count = 0;
	  continue;
	}

d4618 1
a4618 2
                 script.  FIXME: This doesn't handle .tocbss sections
                 created from XMC_TD common symbols correctly.  */
d4626 1
a4626 1
		    (_("TOC overflow: 0x%lx > 0x10000; try -mminimal-toc when compiling"),
d5288 1
a5288 6
	      if (r_symndx == -1)
		h = NULL;
	      else
		h = obj_xcoff_sym_hashes (input_bfd)[r_symndx];

	      if (r_symndx != -1 && finfo->info->strip != strip_all)
d5290 1
d5447 1
a5447 1
			    (_("%s: loader reloc in unrecognized section `%s'"),
d5469 1
a5469 1
			    (_("%s: `%s' in loader reloc but not loader sym"),
d5484 1
a5484 1
			(_("%s: loader reloc in read-only section %s"),
d5689 3
a5691 1
      if (finfo->info->strip != strip_all)
d5693 27
a5719 6
	  if (strlen (h->root.root.string) <= SYMNMLEN)
	    strncpy (irsym._n._n_name, h->root.root.string, SYMNMLEN);
	  else
	    {
	      boolean hash;
	      bfd_size_type indx;
d5721 3
a5723 10
	      hash = true;
	      if ((output_bfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
		hash = false;
	      indx = _bfd_stringtab_add (finfo->strtab, h->root.root.string,
					 hash, false);
	      if (indx == (bfd_size_type) -1)
		return false;
	      irsym._n._n_n._n_zeroes = 0;
	      irsym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;
	    }
d5725 15
a5739 33
	  irsym.n_value = irel->r_vaddr;
	  irsym.n_scnum = osec->target_index;
	  irsym.n_sclass = C_HIDEXT;
	  irsym.n_type = T_NULL;
	  irsym.n_numaux = 1;

	  bfd_coff_swap_sym_out (output_bfd, (PTR) &irsym, (PTR) outsym);
	  outsym += bfd_coff_symesz (output_bfd);

	  memset (&iraux, 0, sizeof iraux);
	  iraux.x_csect.x_smtyp = XTY_SD;
	  iraux.x_csect.x_scnlen.l = 4;
	  iraux.x_csect.x_smclas = XMC_TC;

	  bfd_coff_swap_aux_out (output_bfd, (PTR) &iraux, T_NULL, C_HIDEXT,
				 0, 1, (PTR) outsym);
	  outsym += bfd_coff_auxesz (output_bfd);

	  if (h->indx >= 0)
	    {
	      /* We aren't going to write out the symbols below, so we
		 need to write them out now.  */
	      if (bfd_seek (output_bfd,
			    (obj_sym_filepos (output_bfd)
			     + (obj_raw_syment_count (output_bfd)
				* bfd_coff_symesz (output_bfd))),
			    SEEK_SET) != 0
		  || (bfd_write (finfo->outsyms, outsym - finfo->outsyms, 1,
				 output_bfd)
		      != (bfd_size_type) (outsym - finfo->outsyms)))
		return false;
	      obj_raw_syment_count (output_bfd) +=
		(outsym - finfo->outsyms) / bfd_coff_symesz (output_bfd);
d5741 1
a5741 2
	      outsym = finfo->outsyms;
	    }
d5800 1
a5800 1
	    (_("%s: loader reloc in unrecognized section `%s'"),
d5837 1
a5837 1
	    (_("%s: loader reloc in unrecognized section `%s'"),
d5849 1
a5849 1
  if (h->indx >= 0 || finfo->info->strip == strip_all)
d6154 1
a6154 1
	    (_("%s: loader reloc in unrecognized section `%s'"),
d6165 1
a6165 1
	    (_("%s: `%s' in loader reloc but not loader sym"),
d6334 1
a6334 1
		      rel->r_vaddr - input_section->vma, true)))
d6361 1
a6361 1
	    (_("%s: unsupported relocation type 0x%02x"),
d6407 1
a6407 1
		    (_("%s: TOC reloc at 0x%x to symbol `%s' with no TOC entry"),
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.
d32 8
d78 2
a79 1
static unsigned long xcoff_glink_code[] = {
d101 2
a102 1
struct internal_ldhdr {
d123 2
a124 1
struct external_ldhdr {
d140 15
a154 12
struct internal_ldsym {
  union {
    /* The symbol name if <= SYMNMLEN characters.  */
    char _l_name[SYMNMLEN];
    struct {
      /* Zero if the symbol name is more than SYMNMLEN characters.  */
      long _l_zeroes;
      /* The offset in the string table if the symbol name is more
	 than SYMNMLEN characters.  */
      long _l_offset;
    } _l_l;
  } _l;
d169 11
a179 8
struct external_ldsym {
  union {
    bfd_byte _l_name[SYMNMLEN];
    struct {
      bfd_byte _l_zeroes[4];
      bfd_byte _l_offset[4];
    } _l_l;
  } _l;
d203 2
a204 1
struct internal_ldrel {
d215 2
a216 1
struct external_ldrel {
d227 2
a228 1
struct xcoff_import_file {
d241 2
a242 1
struct xcoff_link_hash_entry {
d253 9
a261 8
  union {
    /* If we have created a TOC entry (the XCOFF_SET_TOC flag is set),
       this is the offset in toc_section.  */
    bfd_vma toc_offset;
    /* If the TOC entry comes from an input file, this is set to the
       symbol index of the C_HIDEXT XMC_TC or XMC_TD symbol.  */
    long toc_indx;
  } u;
d314 2
a315 1
struct xcoff_link_hash_table {
d360 6
a365 5
  struct xcoff_link_size_list {
    struct xcoff_link_size_list *next;
    struct xcoff_link_hash_entry *h;
    bfd_size_type size;
  } *size_list;
d374 2
a375 1
struct xcoff_link_section_info {
d385 6
a390 5
  struct xcoff_toc_rel_hash {
    struct xcoff_toc_rel_hash *next;
    struct xcoff_link_hash_entry *h;
    struct internal_reloc *rel;
  } *toc_rel_hashes;
d395 2
a396 1
struct xcoff_final_link_info {
d795 6
a800 6
  HOWTO (0,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d802 5
a806 5
	 0,		        /* special_function */
	 "R_POS",               /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
d1897 6
a1902 5
	    static const char *csect_name_by_class[] = {
	      ".pr", ".ro", ".db", ".tc", ".ua", ".rw", ".gl", ".xo",
	      ".sv", ".bs", ".ds", ".uc", ".ti", ".tb", NULL, ".tc0",
	      ".td"
	    };
d2292 1
a2292 1
		    = csect->alignment_power;
d2407 1
a2407 1
	  o->flags &= ~SEC_RELOC;
d2918 1
a2918 1
  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
d2954 1
a2954 1
  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
d3068 1
a3068 1
  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
d3133 1
a3133 1
  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
d3148 1
a3148 1

d3167 1
a3167 1
  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
d3183 2
a3184 1
struct xcoff_loader_info {
d3252 1
a3252 1
  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
d4104 1
a4104 1
			 * sizeof (struct xcoff_link_hash_entry *)));
a4689 1
	      bfd *inp;
a4694 1

d4700 3
a4702 1
                 script.  */
a4704 18
	      for (inp = finfo->info->input_bfds;
		   inp != NULL;
		   inp = inp->link_next)
		{
		  asection *o;

		  for (o = inp->sections; o != NULL; o = o->next)
		    if (strcmp (o->name, ".tocbss") == 0)
		      {
			bfd_vma new_toc_end;
			new_toc_end = (o->output_section->vma
				       + o->output_offset
				       + o->_cooked_size);
			if (new_toc_end > tocend)
			  tocend = new_toc_end;
		      }

		}
d6337 1
a6337 1
	{
d6588 1
a6588 2
		  || next == 0x4ffffb82		/* cror 31,31,31 */
		  || next == 0x60000000)	/* ori r0,r0,0 */
d6594 1
a6594 1
		bfd_put_32 (input_bfd, 0x60000000, pnext); /* ori r0,r0,0 */
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a26 1
#include "coff/xcoff.h"
a27 1
#include "libxcoff.h"
d33 52
d90 117
d209 1
a209 2
struct xcoff_import_file
{
d220 128
d351 1
a351 2
struct xcoff_link_section_info
{
d370 1
a370 2
struct xcoff_final_link_info
{
d387 1
a387 1
  bfd_byte *ldsym;
d389 1
a389 1
  bfd_byte *ldrel;
d408 12
d422 1
a422 1
static bfd_boolean xcoff_get_section_contents PARAMS ((bfd *, asection *));
d424 1
a424 1
  PARAMS ((bfd *, asection *, bfd_boolean, bfd_byte *, bfd_boolean,
d426 1
a426 1
static bfd_boolean xcoff_link_add_object_symbols
d428 6
a433 6
static bfd_boolean xcoff_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean xcoff_link_check_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean xcoff_link_check_dynamic_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
d436 2
a437 3
static bfd_boolean xcoff_link_add_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean xcoff_link_add_dynamic_symbols
d439 1
a439 1
static bfd_boolean xcoff_mark_symbol
d441 1
a441 1
static bfd_boolean xcoff_mark PARAMS ((struct bfd_link_info *, asection *));
d443 1
a443 1
static bfd_boolean xcoff_build_ldsyms
d445 1
a445 1
static bfd_boolean xcoff_link_input_bfd
d447 1
a447 1
static bfd_boolean xcoff_write_global_symbol
d449 1
a449 1
static bfd_boolean xcoff_reloc_link_order
d454 102
d557 12
d575 1
a575 1
static bfd_boolean
a579 1

d582 2
a583 2
      bfd_size_type amt = sizeof (struct coff_section_tdata);
      sec->used_by_bfd = bfd_zalloc (abfd, amt);
d585 1
a585 1
	return FALSE;
d590 2
a591 2
      coff_section_data (abfd, sec)->contents = ((bfd_byte *)
						 bfd_malloc (sec->_raw_size));
d593 1
a593 1
	return FALSE;
d598 1
a598 1
	return FALSE;
d601 1
a601 1
  return TRUE;
d631 1
a631 1
  bfd_xcoff_swap_ldhdr_in (abfd, (PTR) contents, &ldhdr);
d647 1
a647 1
  bfd_byte *elsym, *elsymend;
d667 1
a667 1
  coff_section_data (abfd, lsec)->keep_contents = TRUE;
d669 1
a669 1
  bfd_xcoff_swap_ldhdr_in (abfd, contents, &ldhdr);
d678 3
a680 4
  elsym = contents + bfd_xcoff_loader_symbol_offset(abfd, &ldhdr);

  elsymend = elsym + ldhdr.l_nsyms * bfd_xcoff_ldsymsz(abfd);
  for (; elsym < elsymend; elsym += bfd_xcoff_ldsymsz(abfd), symbuf++, psyms++)
d684 1
a684 1
      bfd_xcoff_swap_ldsym_in (abfd, elsym, &ldsym);
d692 10
a701 1
	  char *c;
d703 7
a709 6
	  c = bfd_alloc (abfd, (bfd_size_type) SYMNMLEN + 1);
	  if (c == NULL)
	    return -1;
	  memcpy (c, ldsym._l._l_name, SYMNMLEN);
	  c[SYMNMLEN] = '\0';
	  symbuf->symbol.name = c;
d724 1
a724 1
	 with the loader symbol.  */
d761 1
a761 1
  bfd_xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) contents, &ldhdr);
d766 17
d795 1
a795 1
  bfd_byte *elrel, *elrelend;
d814 1
a814 1
  bfd_xcoff_swap_ldhdr_in (abfd, contents, &ldhdr);
d820 4
a823 5
  elrel = contents + bfd_xcoff_loader_reloc_offset(abfd, &ldhdr);

  elrelend = elrel + ldhdr.l_nreloc * bfd_xcoff_ldrelsz(abfd);
  for (; elrel < elrelend; elrel += bfd_xcoff_ldrelsz(abfd), relbuf++,
	 prelocs++)
d827 1
a827 1
      bfd_xcoff_swap_ldrel_in (abfd, elrel, &ldrel);
d866 3
a868 3
	 correct if ldrel.l_rtype == 0.  In other cases, we should use
	 a different howto.  */
      relbuf->howto = bfd_xcoff_dynamic_reloc_howto(abfd);
a924 1
  bfd_size_type amt = sizeof (struct xcoff_link_hash_table);
d926 2
a927 1
  ret = (struct xcoff_link_hash_table *) bfd_malloc (amt);
d932 1
a932 1
      free (ret);
d946 2
a947 2
  ret->textro = FALSE;
  ret->gc = FALSE;
d953 1
a953 1
  xcoff_data (abfd)->full_aouthdr = TRUE;
d958 1
a958 1
/* Free a XCOFF link hash table.  */
d960 15
a974 5
void
_bfd_xcoff_bfd_link_hash_table_free (hash)
     struct bfd_link_hash_table *hash;
{
  struct xcoff_link_hash_table *ret = (struct xcoff_link_hash_table *) hash;
d976 1
a976 4
  _bfd_stringtab_free (ret->debug_strtab);
  bfd_hash_table_free (&ret->root.table);
  free (ret);
}
d987 1
a987 1
     bfd_boolean cache;
d989 1
a989 1
     bfd_boolean require_internal;
a991 1

d1006 2
a1007 2
	  if (_bfd_coff_read_internal_relocs (abfd, enclosing, TRUE,
					      external_relocs, FALSE,
a1020 1

d1037 1
a1037 1
bfd_boolean
a1041 1

d1049 5
a1053 5
	 to check the archive for dynamic objects, because they may not
	 appear in the archive map even though they should, perhaps, be
	 included.  If the archive has no map, we just consider each object
	 file in turn, since that apparently is what the AIX native linker
	 does.  */
d1058 1
a1058 1
	    return FALSE;
d1068 3
a1070 2
		&& (info->hash->creator == member->xvec)
		&& (! bfd_has_map (abfd) || (member->flags & DYNAMIC) != 0))
d1072 1
a1072 1
		bfd_boolean needed;
d1074 2
a1075 3
		if (! xcoff_link_check_archive_element (member, info,
							&needed))
		  return FALSE;
d1083 1
a1083 1
      return TRUE;
d1087 1
a1087 1
      return FALSE;
d1093 1
a1093 1
static bfd_boolean
a1097 1

d1099 1
a1099 1
    return FALSE;
d1101 1
a1101 1
    return FALSE;
d1105 1
a1105 1
	return FALSE;
d1107 1
a1107 1
  return TRUE;
d1115 1
a1115 1
static bfd_boolean
d1119 1
a1119 1
     bfd_boolean *pneeded;
a1120 1

d1122 1
a1122 1
    return FALSE;
d1125 1
a1125 1
    return FALSE;
d1130 1
a1130 1
	return FALSE;
d1136 1
a1136 1
	return FALSE;
d1139 1
a1139 1
  return TRUE;
d1145 1
a1145 1
static bfd_boolean
d1149 1
a1149 1
     bfd_boolean *pneeded;
d1155 1
a1155 1
  *pneeded = FALSE;
d1178 1
a1178 1
	     object file.  */
a1180 1

d1182 2
a1183 2
	    return FALSE;
	  h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);
d1192 1
a1192 1
 	      && (info->hash->creator != abfd->xvec
d1197 3
a1199 3
		return FALSE;
	      *pneeded = TRUE;
	      return TRUE;
d1207 1
a1207 1
  return TRUE;
d1214 1
a1214 1
static bfd_boolean
d1218 1
a1218 1
     bfd_boolean *pneeded;
d1221 1
a1221 1
  bfd_byte *contents;
d1224 1
a1224 1
  bfd_byte *elsym, *elsymend;
d1226 1
a1226 1
  *pneeded = FALSE;
d1232 1
a1232 1
      return TRUE;
d1236 2
a1237 2
    return FALSE;
  contents = coff_section_data (abfd, lsec)->contents;
d1239 1
a1239 1
  bfd_xcoff_swap_ldhdr_in (abfd, contents, &ldhdr);
d1241 1
a1241 1
  strings = (char *) contents + ldhdr.l_stoff;
d1243 3
a1245 4
  elsym = contents + bfd_xcoff_loader_symbol_offset(abfd, &ldhdr);

  elsymend = elsym + ldhdr.l_nsyms * bfd_xcoff_ldsymsz(abfd);
  for (; elsym < elsymend; elsym += bfd_xcoff_ldsymsz(abfd))
d1252 1
a1252 1
      bfd_xcoff_swap_ldsym_in (abfd, elsym, &ldsym);
d1267 1
a1267 1
      h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);
d1270 2
a1271 2
	 undefined.  At this point we know that we are using an XCOFF
	 hash table.  */
d1278 3
a1280 3
	    return FALSE;
	  *pneeded = TRUE;
	  return TRUE;
d1286 1
a1286 1
  if (contents != NULL && ! coff_section_data (abfd, lsec)->keep_contents)
d1292 1
a1292 1
  return TRUE;
d1345 1
d1347 9
a1355 1
/* xcoff_link_create_extra_sections
d1357 5
a1361 1
   Takes care of creating the .loader, .gl, .ds, .debug and sections.  */
d1363 4
a1366 2
static bfd_boolean
xcoff_link_create_extra_sections(bfd * abfd, struct bfd_link_info *info)
d1368 24
d1393 6
a1398 1
  bfd_boolean return_value = FALSE;
a1401 1

a1404 1

d1411 1
a1411 3
	    {
	      goto end_return;
	    }
a1414 1

d1422 1
a1422 4
	    {
	      goto end_return;
	    }

a1427 1

d1435 1
a1435 4
	    {
	      goto end_return;
	    }

a1440 1

d1448 1
a1448 4
	    {
	      goto end_return;
	    }

a1453 1

d1462 1
a1462 3
	    {
	      goto end_return;
	    }
a1467 67
  return_value = TRUE;

 end_return:

  return return_value;
}

/* Add all the symbols from an object file to the hash table.

   XCOFF is a weird format.  A normal XCOFF .o files will have three
   COFF sections--.text, .data, and .bss--but each COFF section will
   contain many csects.  These csects are described in the symbol
   table.  From the linker's point of view, each csect must be
   considered a section in its own right.  For example, a TOC entry is
   handled as a small XMC_TC csect.  The linker must be able to merge
   different TOC entries together, which means that it must be able to
   extract the XMC_TC csects from the .data section of the input .o
   file.

   From the point of view of our linker, this is, of course, a hideous
   nightmare.  We cope by actually creating sections for each csect,
   and discarding the original sections.  We then have to handle the
   relocation entries carefully, since the only way to tell which
   csect they belong to is to examine the address.  */

static bfd_boolean
xcoff_link_add_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  unsigned int n_tmask;
  unsigned int n_btshft;
  bfd_boolean default_copy;
  bfd_size_type symcount;
  struct xcoff_link_hash_entry **sym_hash;
  asection **csect_cache;
  bfd_size_type linesz;
  asection *o;
  asection *last_real;
  bfd_boolean keep_syms;
  asection *csect;
  unsigned int csect_index;
  asection *first_csect;
  bfd_size_type symesz;
  bfd_byte *esym;
  bfd_byte *esym_end;
  struct reloc_info_struct
  {
    struct internal_reloc *relocs;
    asection **csects;
    bfd_byte *linenos;
  } *reloc_info = NULL;
  bfd_size_type amt;

  keep_syms = obj_coff_keep_syms (abfd);

  if ((abfd->flags & DYNAMIC) != 0
      && ! info->static_link)
    {
      if (! xcoff_link_add_dynamic_symbols (abfd, info))
	return FALSE;
    }

  /* create the loader, toc, gl, ds and debug sections, if needed */
  if (! xcoff_link_create_extra_sections (abfd, info))
    goto error_return;

d1470 1
a1470 1
    return TRUE;
d1480 1
a1480 1
    default_copy = FALSE;
d1482 1
a1482 1
    default_copy = TRUE;
d1488 4
a1491 2
  amt = symcount * sizeof (struct xcoff_link_hash_entry *);
  sym_hash = (struct xcoff_link_hash_entry **) bfd_zalloc (abfd, amt);
d1495 2
d1501 2
a1502 2
  amt = symcount * sizeof (asection *);
  csect_cache = (asection **) bfd_zalloc (abfd, amt);
d1506 1
d1513 3
a1515 3
  amt = abfd->section_count + 1;
  amt *= sizeof (struct reloc_info_struct);
  reloc_info = (struct reloc_info_struct *) bfd_zmalloc (amt);
d1518 2
a1525 1

a1528 1

d1530 4
a1533 5
	    xcoff_read_internal_relocs (abfd, o, TRUE, (bfd_byte *) NULL,
					FALSE, (struct internal_reloc *) NULL);
	  amt = o->reloc_count;
	  amt *= sizeof (asection *);
	  reloc_info[o->target_index].csects = (asection **) bfd_zmalloc (amt);
d1536 2
a1542 1

d1545 1
a1545 2
	  amt = linesz * o->lineno_count;
	  linenos = (bfd_byte *) bfd_malloc (amt);
d1550 2
a1551 1
	      || bfd_bread (linenos, amt, abfd) != amt)
a1552 1

d1557 1
a1557 1
  obj_coff_keep_syms (abfd) = TRUE;
a1566 1

d1582 1
a1582 1
	 information.  */
a1584 7

	  /* Set csect_cache,
	     Normally csect is a .pr, .rw  etc. created in the loop
	     If C_FILE or first time, handle special

	     Advance esym, sym_hash, csect_hash ptr's
	     Keep track of the last_symndx for the current file.  */
a1602 1

a1606 1

d1611 5
a1615 5
	 and we're not stripping it, count the number of entries and
	 add them to the count for this csect.  In the final link pass
	 we are going to attach line number information by symbol,
	 rather than by section, in order to more easily handle
	 garbage collection.  */
a1620 1

a1625 1

d1629 1
a1629 1
	      bfd_signed_vma linoff;
d1636 1
a1636 1
		     bfd_archive_filename (abfd), name);
d1642 1
a1642 2
	      /* explict cast to bfd_signed_vma for compiler */
	      if (linoff < (bfd_signed_vma) (enclosing->lineno_count * linesz))
d1671 3
a1673 3
			 useful if all the line number entries for a
			 csect are contiguous; this only matters for
			 error reporting.  */
d1688 1
a1688 1
	     bfd_archive_filename (abfd), sym.n_sclass, name);
d1711 1
a1711 1
	     bfd_archive_filename (abfd), name, smtyp);
d1723 1
a1723 1
		 bfd_archive_filename (abfd), name, sym.n_sclass, sym.n_scnum,
d1730 1
a1730 1
	     an absolute location.  */
d1742 1
d1746 3
a1748 1
		((esym - (bfd_byte *) obj_coff_external_syms (abfd)) / symesz);
d1752 1
a1752 1
	  csect_index = -(unsigned) 1;
d1762 1
a1762 1
		     bfd_archive_filename (abfd), name, sym.n_sclass,
d1772 1
a1772 1
	     both have the same name, they are both 4 or 8 bytes long, and
d1775 1
a1775 9
	     that we must look through the relocations.  Ick.

	     Logic for 32 bit vs 64 bit.
	     32 bit has a csect length of 4 for TOC
	     64 bit has a csect length of 8 for TOC

	     The conditions to get past the if-check are not that bad.
	     They are what is used to create the TOC csects in the first
	     place.  */
d1778 2
a1779 5
	      && info->hash->creator == abfd->xvec
	      && ((bfd_xcoff_is_xcoff32 (abfd)
		   && aux.x_csect.x_scnlen.l == 4)
		  || (bfd_xcoff_is_xcoff64 (abfd)
		      && aux.x_csect.x_scnlen.l == 8)))
d1791 2
a1792 2
	      amt = enclosing->reloc_count;
	      relindx = xcoff_find_reloc (relocs, amt, sym.n_value);
a1793 3

	      /* 32 bit R_POS r_size is 31
		 64 bit R_POS r_size is 63  */
d1796 2
a1797 5
		  && rel->r_type == R_POS
		  && ((bfd_xcoff_is_xcoff32 (abfd)
		       && rel->r_size == 31)
		      || (bfd_xcoff_is_xcoff64 (abfd)
			  && rel->r_size == 63)))
a1799 1

d1809 1
a1809 1
		      bfd_boolean copy;
a1813 1

d1820 4
a1823 5
			 the same as the symbol name.  This handles
			 the normal case, but not common cases like
			 SYM.P4 which gcc generates to store SYM + 4
			 in the TOC.  FIXME.  */

d1830 2
a1831 2
						      relname, TRUE, copy,
						      FALSE);
d1862 4
a1865 4
			} /* merge toc reloc */
		    } /* c_ext */
		} /* reloc */
	    } /* merge toc */
d1867 3
d1871 6
a1876 1

d1879 3
a1881 6
	    /* We need to create a new section.  We get the name from
	       the csect storage mapping class, so that the linker can
	       accumulate similar csects together.  */

	    csect = bfd_xcoff_create_csect_from_smclas(abfd, &aux, name);
	    if (NULL == csect)
d1883 4
d1890 4
a1893 2
	    /* The enclosing section is the main section : .data, .text
	       or .bss that the csect is coming from.  */
a1896 1

d1904 1
a1904 1
		   bfd_archive_filename (abfd), name);
d1918 2
a1919 2
	    amt = sizeof (struct coff_section_tdata);
	    csect->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
d1922 2
a1923 2
	    amt = sizeof (struct xcoff_section_tdata);
	    coff_section_data (abfd, csect)->tdata = bfd_zalloc (abfd, amt);
d1938 2
a1939 3
		amt = enclosing->reloc_count;
		relindx = xcoff_find_reloc (relocs, amt, csect->vma);

a1942 1

a1948 1

d1986 3
a1988 3
	     symbol index of the csect.  Usually the XTY_LD symbol will
	     follow its appropriate XTY_SD symbol.  The .set pseudo op can
	     cause the XTY_LD to not follow the XTY_SD symbol. */
d1990 1
a1990 1
	    bfd_boolean bad;
d1992 1
a1992 1
	    bad = FALSE;
d1996 1
a1996 1
	      bad = TRUE;
d2002 1
a2002 1
		  bad = TRUE;
d2008 1
a2008 1
		   bfd_archive_filename (abfd), name);
d2012 1
a2012 1
 	    csect = section;
d2019 5
a2023 5
	     the storage mapping class, but we don't bother except for
	     an XMC_TD symbol.  If this csect is externally visible,
	     it is a common symbol.  We put XMC_TD symbols in sections
	     named .tocbss, and rely on the linker script to put that
	     in the TOC area.  */
d2034 1
a2034 6
	    {
	      /* The linker script puts the .td section in the data
		 section after the .tc section.  */
	      csect = bfd_make_section_anyway (abfd, ".td");

	    }
d2036 1
a2036 3
	    {
	      csect = bfd_make_section_anyway (abfd, ".bss");
	    }
d2050 2
a2051 2
	  amt = sizeof (struct coff_section_tdata);
	  csect->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
d2054 2
a2055 2
	  amt = sizeof (struct xcoff_section_tdata);
	  coff_section_data (abfd, csect)->tdata = bfd_zalloc (abfd, amt);
d2079 1
d2081 1
a2081 2
	  int i = -1;

d2085 1
a2085 1
		i = XCOFF_SPECIAL_SECTION_TEXT;
d2087 1
a2087 1
		i = XCOFF_SPECIAL_SECTION_ETEXT;
d2089 1
a2089 1
		i = XCOFF_SPECIAL_SECTION_DATA;
d2091 1
a2091 1
		i = XCOFF_SPECIAL_SECTION_EDATA;
d2093 1
a2093 1
		i = XCOFF_SPECIAL_SECTION_END;
d2096 1
a2096 3
	    {
	      i = XCOFF_SPECIAL_SECTION_END2;
	    }
d2099 1
a2099 3
	    {
	      xcoff_hash_table (info)->special_sections[i] = csect;
	    }
d2103 1
a2103 1
	 linker hash table.  */
d2107 1
a2107 1
	  bfd_boolean copy;
d2112 1
a2112 1
	     syment itself, rather than the string table.  */
d2116 1
a2116 1
	    copy = TRUE;
d2143 1
a2143 1
 	  if (info->hash->creator == abfd->xvec)
d2146 2
a2147 4
		{
		  *sym_hash = xcoff_link_hash_lookup (xcoff_hash_table (info),
						      name, TRUE, copy, FALSE);
		}
d2149 3
a2151 8
		{
		  /* Make a copy of the symbol name to prevent problems with
		     merging symbols.  */
		  *sym_hash = ((struct xcoff_link_hash_entry *)
			       bfd_wrapped_link_hash_lookup (abfd, info, name,
							     TRUE, TRUE,
							     FALSE));
		}
d2167 5
a2171 5
			 either the existing symbol is not global
			 linkage code or this symbol is global linkage
			 code.  If the existing symbol is global
			 linkage code and the new symbol is not, then
			 we want to use the new symbol.  */
d2179 1
a2179 1
			 Replace it.  */
d2187 2
a2188 2
			 in an archive.  Just ignore it.  See the
			 comment above.  */
d2196 3
a2198 3
			 case, we just continue and permit the
			 multiple definition error.  See the comment
			 above about the behaviour of the AIX linker.  */
d2203 2
a2204 2
			 class.  There is at least a chance that this
			 is a semi-legitimate redefinition.  */
d2225 1
a2225 1
			  (bfd *) NULL, (asection *) NULL, (bfd_vma) 0,
d2249 1
a2249 1
		  (const char *) NULL, copy, TRUE,
d2269 1
a2269 1
 	  if (info->hash->creator == abfd->xvec)
a2312 1

a2314 1

d2319 1
a2319 1
		     bfd_archive_filename (abfd), o->name, i);
d2327 1
a2327 1
 	      if (info->hash->creator == abfd->xvec
d2338 8
a2345 8
		     the code of a function.  If the symbol is
		     currently undefined, then add an undefined symbol
		     for the function descriptor.  This should do no
		     harm, because any regular object that defines the
		     function should also define the function
		     descriptor.  It helps, because it means that we
		     will identify the function descriptor with a
		     dynamic object if a dynamic object defines it.  */
a2349 1
		      struct bfd_link_hash_entry *bh;
d2353 1
a2353 1
						    TRUE, FALSE, TRUE);
a2357 1
			  bh = &hds->root;
d2361 3
a2363 2
				  (bfd_vma) 0, (const char *) NULL, FALSE,
				  TRUE, &bh)))
a2364 1
			  hds = (struct xcoff_link_hash_entry *) bh;
d2380 1
a2380 1
	  o->flags &=~ SEC_RELOC;
d2395 1
a2395 1
	 somewhere for the final link, to avoid reading them again.  */
d2407 1
a2407 1
  return TRUE;
d2419 1
a2419 1
      free (reloc_info);
d2422 1
a2422 1
  return FALSE;
d2431 1
a2431 1
static bfd_boolean
d2437 1
a2437 1
  bfd_byte *contents;
d2440 1
a2440 1
  bfd_byte *elsym, *elsymend;
d2450 1
a2450 1
   if (info->hash->creator != abfd->xvec)
d2456 1
a2456 1
      return FALSE;
d2477 1
a2477 1
      return FALSE;
a2479 1

d2481 2
a2482 2
    return FALSE;
  contents = coff_section_data (abfd, lsec)->contents;
d2486 1
a2486 3
  bfd_section_list_clear (abfd);

  bfd_xcoff_swap_ldhdr_in (abfd, contents, &ldhdr);
d2488 1
a2488 3
  strings = (char *) contents + ldhdr.l_stoff;

  elsym = contents + bfd_xcoff_loader_symbol_offset(abfd, &ldhdr);
d2490 1
a2490 1
  elsymend = elsym + ldhdr.l_nsyms * bfd_xcoff_ldsymsz(abfd);
d2492 4
a2495 1
  for (; elsym < elsymend; elsym += bfd_xcoff_ldsymsz(abfd))
d2502 1
a2502 1
      bfd_xcoff_swap_ldsym_in (abfd, elsym, &ldsym);
d2522 2
a2523 2
      h = xcoff_link_hash_lookup (xcoff_hash_table (info), name, TRUE,
				  TRUE, TRUE);
d2525 1
a2525 1
	return FALSE;
d2551 3
a2553 3
	 define it, since we don't have a section to put it in anyhow.
	 Instead, the relocation routines handle the DEF_DYNAMIC flag
	 correctly.  */
d2579 1
a2579 1
	      dsnm = bfd_malloc ((bfd_size_type) strlen (name) + 2);
d2581 1
a2581 1
		return FALSE;
d2585 1
a2585 1
					    TRUE, TRUE, TRUE);
d2588 1
a2588 1
		return FALSE;
d2595 1
a2595 1
		     symbol list.  */
d2621 1
a2621 1
  if (contents != NULL && ! coff_section_data (abfd, lsec)->keep_contents)
d2630 1
a2630 1
       bfd_alloc (abfd, (bfd_size_type) sizeof (struct xcoff_import_file)));
d2632 1
a2632 1
    return FALSE;
d2665 1
a2665 1
  return TRUE;
d2674 1
a2674 1
static INLINE bfd_boolean
a2678 1

d2680 1
a2680 1
    return TRUE;
d2693 1
a2693 1
	    return FALSE;
d2701 1
a2701 1
	return FALSE;
d2704 1
a2704 1
  return TRUE;
d2713 1
a2713 1
static bfd_boolean
d2720 1
a2720 1
    return TRUE;
d2746 1
a2746 1
		return FALSE;
d2755 2
a2756 2
	  rel = xcoff_read_internal_relocs (sec->owner, sec, TRUE,
					    (bfd_byte *) NULL, FALSE,
d2759 1
a2759 1
	    return FALSE;
d2775 1
a2775 1
		    return FALSE;
d2783 1
a2783 1
		    return FALSE;
d2787 1
a2787 1
		 section.  */
d2836 1
a2836 1
  return TRUE;
d2857 2
a2858 2
		 special sections.  Keep .debug sections for the
		 moment.  */
d2881 1
a2881 1
bfd_boolean
a2889 1
  bfd_size_type amt;
d2892 1
a2892 1
    return TRUE;
d2898 2
a2899 2
  amt = sizeof (struct xcoff_link_size_list);
  n = (struct xcoff_link_size_list *) bfd_alloc (output_bfd, amt);
d2901 1
a2901 1
    return FALSE;
d2909 1
a2909 1
  return TRUE;
d2914 1
a2914 1
bfd_boolean
d2916 1
a2916 1
			 impmember, syscall_flag)
a2923 1
     unsigned int syscall_flag;
d2928 1
a2928 1
    return TRUE;
d2944 1
a2944 1
					TRUE, FALSE, TRUE);
d2946 1
a2946 1
	    return FALSE;
d2960 2
a2961 2
	 rather than the symbol we were told to import.  FIXME: Is
	 this correct in all cases?  */
d2966 1
a2966 1
  h->flags |= (XCOFF_IMPORT | syscall_flag);
d2978 1
a2978 1
	    return FALSE;
d2998 1
a2998 1
	 reserved for the library search path.  */
a3011 1
	  bfd_size_type amt = sizeof (struct xcoff_import_file);
d3013 2
a3014 1
	  n = (struct xcoff_import_file *) bfd_alloc (output_bfd, amt);
d3016 1
a3016 1
	    return FALSE;
d3027 1
a3027 1
  return TRUE;
d3032 2
a3033 2
bfd_boolean
bfd_xcoff_export_symbol (output_bfd, info, harg)
d3037 1
d3042 1
a3042 1
    return TRUE;
a3055 1
      bfd_size_type amt = strlen (h->root.root.string) + 2;
d3057 1
a3057 1
      fnname = (char *) bfd_malloc (amt);
d3059 1
a3059 1
	return FALSE;
d3063 1
a3063 1
				    fnname, FALSE, FALSE, TRUE);
d3078 1
a3078 1
    return FALSE;
d3088 1
a3088 1
	return FALSE;
d3091 1
a3091 1
  return TRUE;
d3098 1
a3098 1
bfd_boolean
d3107 1
a3107 1
    return TRUE;
d3110 2
a3111 2
       bfd_wrapped_link_hash_lookup (output_bfd, info, name, FALSE, FALSE,
				     FALSE));
d3116 1
a3116 1
      return FALSE;
d3124 1
a3124 1
    return FALSE;
d3126 1
a3126 1
  return TRUE;
d3132 1
a3132 1
bfd_boolean
d3141 1
a3141 1
    return TRUE;
d3143 2
a3144 2
  h = xcoff_link_hash_lookup (xcoff_hash_table (info), name, TRUE, TRUE,
			      FALSE);
d3146 1
a3146 1
    return FALSE;
d3150 1
a3150 1
  return TRUE;
d3153 22
d3192 1
a3192 1
bfd_boolean
d3196 1
a3196 1
				 special_sections, rtld)
d3204 1
a3204 1
     bfd_boolean gc;
d3206 2
a3207 2
     bfd_boolean textro;
     bfd_boolean export_defineds;
a3208 1
     bfd_boolean rtld;
a3222 1
  bfd_size_type amt;
d3226 1
a3226 1
      for (i = 0; i < XCOFF_NUMBER_OF_SPECIAL_SECTIONS; i++)
d3228 1
a3228 1
      return TRUE;
d3231 1
a3231 1
  ldinfo.failed = FALSE;
d3247 3
a3249 2
  hentry = NULL;
  if (entry != NULL)
d3252 1
a3252 1
				       FALSE, FALSE, TRUE);
a3256 51
  /* __rtinit */
  if (info->init_function || info->fini_function || rtld)
    {
      struct xcoff_link_hash_entry *hsym;
      struct internal_ldsym *ldsym;

      hsym = xcoff_link_hash_lookup (xcoff_hash_table (info),
				     "__rtinit", FALSE, FALSE, TRUE);
      if (hsym == NULL)
	{
	  (*_bfd_error_handler)
	    (_("error: undefined symbol __rtinit"));
	  return FALSE;
	}

      xcoff_mark_symbol (info, hsym);
      hsym->flags |= (XCOFF_DEF_REGULAR | XCOFF_RTINIT);

      /* __rtinit initalized */
      amt = sizeof (struct internal_ldsym);
      ldsym = (struct internal_ldsym *) bfd_malloc (amt);

      ldsym->l_value = 0;		/* will be filled in later */
      ldsym->l_scnum = 2;		/* data section */
      ldsym->l_smtype = XTY_SD;		/* csect section definition */
      ldsym->l_smclas = 5;		/* .rw */
      ldsym->l_ifile = 0;		/* special system loader symbol */
      ldsym->l_parm = 0;		/* NA */

      /* Force __rtinit to be the first symbol in the loader symbol table
	 See xcoff_build_ldsyms

	 The first 3 symbol table indices are reserved to indicate the data,
	 text and bss sections.  */
      BFD_ASSERT (0 == ldinfo.ldsym_count);

      hsym->ldindx = 3;
      ldinfo.ldsym_count = 1;
      hsym->ldsym = ldsym;

      if (! bfd_xcoff_put_ldsymbol_name (ldinfo.output_bfd, &ldinfo,
					 hsym->ldsym, hsym->root.root.string))
	return FALSE;

      /* This symbol is written out by xcoff_write_global_symbol
	 Set stuff up so xcoff_write_global_symbol logic works.  */
      hsym->flags |= XCOFF_DEF_REGULAR | XCOFF_MARK;
      hsym->root.type = bfd_link_hash_defined;
      hsym->root.u.def.value = 0;
    }

d3264 2
a3265 2
      gc = FALSE;
      xcoff_hash_table (info)->gc = FALSE;
d3268 1
a3268 1
	 correctly.  */
d3288 1
a3288 1
      xcoff_hash_table (info)->gc = TRUE;
d3292 1
a3292 1
  for (i = 0; i < XCOFF_NUMBER_OF_SPECIAL_SECTIONS; i++)
d3294 2
a3296 1

d3300 1
a3300 3
	{
	  sec = NULL;
	}
d3307 1
a3307 1
      return TRUE;
d3334 1
a3334 1
  ldhdr->l_version = bfd_xcoff_ldhdr_version(output_bfd);
d3339 3
a3341 3
  ldhdr->l_impoff = (bfd_xcoff_ldhdrsz(output_bfd)
		     + ldhdr->l_nsyms * bfd_xcoff_ldsymsz(output_bfd)
		     + ldhdr->l_nreloc * bfd_xcoff_ldrelsz(output_bfd));
a3348 8
  /* 64 bit elements to ldhdr
     The swap out routine for 32 bit will ignore them.
     Nothing fancy, symbols come after the header and relocs come
     after symbols.  */
  ldhdr->l_symoff = bfd_xcoff_ldhdrsz (output_bfd);
  ldhdr->l_rldoff = (bfd_xcoff_ldhdrsz (output_bfd)
		     + ldhdr->l_nsyms * bfd_xcoff_ldsymsz (output_bfd));

d3358 2
a3359 1
  bfd_xcoff_swap_ldhdr_out (output_bfd, ldhdr, lsec->contents);
d3398 1
a3398 2
     xcoff_link_input_bfd.
  */
d3474 26
a3499 35
      /* Dynamic object do not have csectpp's.  */
      if (NULL != csectpp)
	{
	  symesz = bfd_coff_symesz (sub);
	  esym = (bfd_byte *) obj_coff_external_syms (sub);
	  esymend = esym + symcount * symesz;

	  while (esym < esymend)
	    {
	      struct internal_syment sym;

	      bfd_coff_swap_sym_in (sub, (PTR) esym, (PTR) &sym);

	      *debug_index = (unsigned long) -1;

	      if (sym._n._n_n._n_zeroes == 0
		  && *csectpp != NULL
		  && (! gc
		      || ((*csectpp)->flags & SEC_MARK) != 0
		      || *csectpp == bfd_abs_section_ptr)
		  && bfd_coff_symname_in_debug (sub, &sym))
		{
		  char *name;
		  bfd_size_type indx;

		  name = (char *) debug_contents + sym._n._n_n._n_offset;
		  indx = _bfd_stringtab_add (debug_strtab, name, TRUE, TRUE);
		  if (indx == (bfd_size_type) -1)
		    goto error_return;
		  *debug_index = indx;
		}

	      esym += (sym.n_numaux + 1) * symesz;
	      csectpp += sym.n_numaux + 1;
	      debug_index += sym.n_numaux + 1;
d3501 4
d3525 1
a3525 1
  return TRUE;
d3532 1
a3532 36
  return FALSE;
}

bfd_boolean
bfd_xcoff_link_generate_rtinit (abfd, init, fini, rtld)
     bfd *abfd;
     const char *init;
     const char *fini;
     bfd_boolean rtld;
{
  struct bfd_in_memory *bim;

  bim = ((struct bfd_in_memory *)
	 bfd_malloc ((bfd_size_type) sizeof (struct bfd_in_memory)));
  if (bim == NULL)
    return FALSE;

  bim->size = 0;
  bim->buffer = 0;

  abfd->link_next = 0;
  abfd->format = bfd_object;
  abfd->iostream = (PTR) bim;
  abfd->flags = BFD_IN_MEMORY;
  abfd->direction = write_direction;
  abfd->where = 0;

  if (! bfd_xcoff_generate_rtinit (abfd, init, fini, rtld))
    return FALSE;

  /* need to reset to unknown or it will not be read back in correctly */
  abfd->format = bfd_unknown;
  abfd->direction = read_direction;
  abfd->where = 0;

  return TRUE;
a3534 1

d3537 1
a3537 1
static bfd_boolean
d3543 1
a3543 8
  bfd_size_type amt;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct xcoff_link_hash_entry *) h->root.u.i.link;

  /* __rtinit, this symbol has special handling. */
  if (h->flags & XCOFF_RTINIT)
      return TRUE;
d3565 1
a3565 1
      bfd_boolean export;
d3581 1
a3581 1
      export = TRUE;
d3595 1
a3595 1
		  export = FALSE;
d3641 1
a3641 1
      sec->_raw_size += bfd_xcoff_glink_code_size(ldinfo->output_bfd);
d3644 1
a3644 1
	 descriptor.  */
a3651 12
	  int byte_size;

	  /* 32 vs 64
	     xcoff32 uses 4 bytes in the toc.
	     xcoff64 uses 8 bytes in the toc.  */
	  if (bfd_xcoff_is_xcoff64 (ldinfo->output_bfd))
	    byte_size = 8;
	  else if (bfd_xcoff_is_xcoff32 (ldinfo->output_bfd))
	    byte_size = 4;
	  else
	    return FALSE;

d3654 1
a3654 1
	  hds->toc_section->_raw_size += byte_size;
d3661 1
a3661 1
	     because we may already have passed hds on the traversal.  */
d3682 4
a3685 4
	     a defined entry point.  We can build up a function
	     descriptor ourselves.  Believe it or not, the AIX linker
	     actually does this, and there are cases where we need to
	     do it as well.  */
d3692 1
a3692 5

	  /* The size of the function descriptor depends if this is an
	     xcoff32 (12) or xcoff64 (24).  */
	  sec->_raw_size +=
	    bfd_xcoff_function_descriptor_size(ldinfo->output_bfd);
d3695 1
a3695 1
	     associated code, and one for the TOC address.  */
d3700 1
a3700 1
	     xcoff_write_global_symbol.  */
d3708 1
a3708 1
	  return TRUE;
d3737 1
a3737 1
      return TRUE;
d3746 1
a3746 1
      return TRUE;
d3752 1
a3752 1
    return TRUE;
d3757 3
a3759 2
  amt = sizeof (struct internal_ldsym);
  h->ldsym = (struct internal_ldsym *) bfd_zalloc (ldinfo->output_bfd, amt);
d3762 2
a3763 2
      ldinfo->failed = TRUE;
      return FALSE;
d3770 1
a3770 1
     data, text and bss sections.  */
d3775 4
a3778 2
  if (! bfd_xcoff_put_ldsymbol_name (ldinfo->output_bfd, ldinfo,
				     h->ldsym, h->root.root.string))
d3780 28
a3807 1
      return FALSE;
d3812 1
a3812 1
  return TRUE;
d3817 1
a3817 1
bfd_boolean
d3826 5
a3830 5
  bfd_size_type max_contents_size;
  bfd_size_type max_sym_count;
  bfd_size_type max_lineno_count;
  bfd_size_type max_reloc_count;
  bfd_size_type max_output_reloc_count;
a3837 2
  file_ptr pos;
  bfd_size_type amt;
d3857 7
a3863 6
  finfo.ldsym = (xcoff_hash_table (info)->loader_section->contents
		 + bfd_xcoff_ldhdrsz (abfd));
  finfo.ldrel = (xcoff_hash_table (info)->loader_section->contents
		 + bfd_xcoff_ldhdrsz(abfd)
		 + (xcoff_hash_table (info)->ldhdr.l_nsyms
		    * bfd_xcoff_ldsymsz(abfd)));
d3892 1
a3892 1
	      sec->linker_mark = TRUE;
d3932 1
a3932 1
	  bfd_boolean saw_contents;
d3938 3
a3940 3
	     contents and is loaded, if it is preceded by some other
	     section which has contents and is loaded.  */
	  saw_contents = TRUE;
d3944 1
a3944 1
		saw_contents = FALSE;
d3949 1
a3949 1
		    saw_contents = TRUE;
d3952 1
a3952 1
		      asection *n, **st;
d3954 2
a3955 5
		      /* Create a pad section and place it before the section
			 that needs padding.  This requires unlinking and
			 relinking the bfd's section list.  */

		      st = abfd->section_tail;
d3957 2
d3961 1
a3961 7

		      BFD_ASSERT (*st == n);
		      bfd_section_list_remove (abfd, st);
		      bfd_section_list_insert (abfd, op, n);

		      op = &n->next;
		      saw_contents = FALSE;
d3967 1
a3967 1
	     sections.  */
d3977 3
a3979 3
	     each section to land on a page boundary.  This bit of
	     code knows what compute_section_file_positions is going
	     to do.  */
d3984 1
a3984 5
	    if ((bfd_xcoff_is_reloc_count_overflow
		 (abfd, (bfd_vma) o->reloc_count))
		|| (bfd_xcoff_is_lineno_count_overflow
		    (abfd, (bfd_vma) o->lineno_count)))
	      /* 64 does not overflow, need to check if 32 does */
d4021 4
a4024 3
    amt = abfd->section_count + 1;
    amt *= sizeof (struct xcoff_link_section_info);
    finfo.section_info = (struct xcoff_link_section_info *) bfd_malloc (amt);
d4046 2
a4047 2
	     allocate the buffers, so that later code doesn't have to
	     worry about whether we are stripping or not.  */
d4058 7
a4064 7
	     written out all the local symbols.  For each section in
	     the output file, we keep an array of pointers to hash
	     table entries.  Each entry in the array corresponds to a
	     reloc.  When we find a reloc against a global symbol, we
	     set the corresponding entry in this array so that we can
	     fix up the symbol index after we have written out all the
	     local symbols.
a4069 2
	  amt = o->reloc_count;
	  amt *= sizeof (struct internal_reloc);
d4071 2
a4072 4
	    (struct internal_reloc *) bfd_malloc (amt);

	  amt = o->reloc_count;
	  amt *= sizeof (struct xcoff_link_hash_entry *);
d4074 3
a4076 2
	    (struct xcoff_link_hash_entry **) bfd_malloc (amt);

d4116 1
a4116 1
      bfd_size_type sz;
d4118 1
a4118 1
      sub->output_has_begun = FALSE;
d4125 10
a4134 18
  amt = max_sym_count * sizeof (struct internal_syment);
  finfo.internal_syms = (struct internal_syment *) bfd_malloc (amt);

  amt = max_sym_count * sizeof (long);
  finfo.sym_indices = (long *) bfd_malloc (amt);

  amt = (max_sym_count + 1) * symesz;
  finfo.outsyms = (bfd_byte *) bfd_malloc (amt);

  amt = max_lineno_count * bfd_coff_linesz (abfd);
  finfo.linenos = (bfd_byte *) bfd_malloc (amt);

  amt = max_contents_size;
  finfo.contents = (bfd_byte *) bfd_malloc (amt);

  amt = max_reloc_count * relsz;
  finfo.external_relocs = (bfd_byte *) bfd_malloc (amt);

d4163 1
a4163 1
		  sub->output_has_begun = TRUE;
a4179 1

d4212 1
a4212 1
      finfo.last_file.n_value = -(bfd_vma) 1;
d4215 5
a4219 3
      pos = obj_sym_filepos (abfd) + finfo.last_file_index * symesz;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (finfo.outsyms, symesz, abfd) != symesz)
d4238 1
a4238 2
  amt = max_output_reloc_count * relsz;
  external_relocs = (bfd_byte *) bfd_malloc (amt);
a4248 1
      bfd_size_type rel_size;
d4295 4
a4298 4
	 to produce them in the order in which their containing csects
	 appear in the symbol table, which is not necessarily by
	 address.  So we sort them here.  There may be a better way to
	 do this.  */
a4308 1
      rel_size = relsz * o->reloc_count;
d4310 2
a4311 1
	  || bfd_bwrite ((PTR) external_relocs, rel_size, abfd) != rel_size)
d4342 3
a4344 2
  if (! bfd_set_section_contents (abfd, o->output_section, o->contents,
				  (file_ptr) o->output_offset, o->_raw_size))
d4351 1
a4351 2
				     (file_ptr) o->output_offset,
				     o->_raw_size))
d4356 1
a4356 2
				     (file_ptr) o->output_offset,
				     o->_raw_size))
d4361 1
a4361 2
				     (file_ptr) o->output_offset,
				     o->_raw_size))
d4365 4
a4368 2
  pos = obj_sym_filepos (abfd) + obj_raw_syment_count (abfd) * symesz;
  if (bfd_seek (abfd, pos, SEEK_SET) != 0)
d4370 4
a4373 5
  H_PUT_32 (abfd,
	    _bfd_stringtab_size (finfo.strtab) + STRING_SIZE_SIZE,
	    strbuf);
  amt = STRING_SIZE_SIZE;
  if (bfd_bwrite (strbuf, amt, abfd) != amt)
d4389 3
a4391 2
      pos = o->output_section->filepos + o->output_offset;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0)
d4401 1
a4401 1
  return TRUE;
a4405 1

a4418 1

d4433 1
a4433 1
  return FALSE;
d4439 1
a4439 1
static bfd_boolean
d4449 1
a4449 1
  bfd_boolean copy, hash;
d4464 1
a4464 1
  bfd_boolean keep_syms;
d4470 1
a4470 1
    return TRUE;
d4489 1
a4489 1
  copy = FALSE;
d4491 2
a4492 2
    copy = TRUE;
  hash = TRUE;
d4494 1
a4494 1
    hash = FALSE;
d4497 1
a4497 1
    return FALSE;
a4512 1

d4516 2
a4517 2
      bfd_boolean skip;
      bfd_boolean require;
d4523 1
a4523 1
	 information.  */
a4531 1

d4542 3
a4544 3
	 .loader symbol information.  If this is an external symbol
	 reference to a defined symbol, though, then wait until we get
	 to the definition.  */
d4616 3
a4618 4
	  bfd_xcoff_swap_ldsym_out (finfo->output_bfd, ldsym,
				    (finfo->ldsym
				     + ((h->ldindx - 3)
					* bfd_xcoff_ldsymsz (finfo->output_bfd))));
d4625 2
a4626 4
	    {
	      xcoff_data (output_bfd)->snentry =
		h->root.u.def.section->output_section->target_index;
	    }
d4631 2
a4632 2
      skip = FALSE;
      require = FALSE;
d4637 1
a4637 1
	skip = TRUE;
d4640 1
a4640 1
	 symbol.  */
d4645 1
a4645 1
	skip = TRUE;
d4650 1
a4650 1
	skip = TRUE;
d4658 1
a4658 1
	    skip = TRUE;
d4670 5
a4674 5
		 as the TOC anchor--that is, whether we can access all
		 of the TOC using a 16 bit offset from tocval.  This
		 test assumes that the TOC comes at the end of the
		 output section, as it does in the default linker
		 script.  */
d4681 1
d4702 1
a4702 1
		  return FALSE;
d4718 1
a4718 2
	      require = TRUE;

d4725 1
a4725 1
	skip = TRUE;
d4732 1
a4732 1
	skip = TRUE;
d4735 1
a4735 1
	 else.  */
d4743 1
a4743 1
	skip = TRUE;
d4751 1
a4751 1
	skip = TRUE;
d4754 1
a4754 1
	 symbol, then skip it.  */
d4758 1
a4758 1
	skip = TRUE;
a4773 1

d4775 1
a4775 1
	    return FALSE;
d4778 2
a4779 2
	       && (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE,
				    FALSE) == NULL))
d4785 1
a4785 1
	    skip = TRUE;
d4792 1
a4792 1
	skip = FALSE;
a4813 1

d4815 1
a4815 1
		    return FALSE;
d4818 1
a4818 1
		    return FALSE;
d4842 1
a4842 1
		  && finfo->last_file.n_value != (bfd_vma) output_index)
a4860 2
		      file_ptr pos;

d4864 5
a4868 5

		      pos = obj_sym_filepos (output_bfd);
		      pos += finfo->last_file_index * osymesz;
		      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
			  || (bfd_bwrite (outsym, osymesz, output_bfd)
d4870 1
a4870 1
			return FALSE;
d4879 2
a4880 2
	     into the line numbers.  We update the symbol values when
	     we handle the line numbers.  */
d4907 2
a4908 2
	     (class XMC_TC), remember the symbol index of the TOC
	     symbol.  */
d4959 1
a4959 2

	      bfd_vma indx;
d4962 1
a4962 1
		 index of the containing csect.  */
d5007 1
a5007 1
			    return FALSE;
d5013 1
a5013 1
			return FALSE;
a5020 1

d5022 1
a5022 1
		     anybody does.  */
d5025 1
a5025 1
		     better clobber them just in case.  */
a5027 1

d5039 1
a5039 3
			    {
			      aux.x_csect.x_scnlen.l = 0;
			    }
d5041 1
a5041 3
			    {
			      aux.x_csect.x_scnlen.l = symindx;
			    }
d5059 3
a5061 3
			     the index of the next symbol we are going
			     to include.  I don't know if this is
			     entirely right.  */
a5069 1

a5083 1

d5103 1
a5103 1
		      bfd_signed_vma linoff;
d5111 7
a5117 6
			  file_ptr pos = enclosing->line_filepos;
			  bfd_size_type amt = linesz * enc_count;
			  if (bfd_seek (input_bfd, pos, SEEK_SET) != 0
			      || (bfd_bread (finfo->linenos, amt, input_bfd)
				  != amt))
			    return FALSE;
d5174 2
a5175 2
			      || (bfd_bwrite (finfo->linenos + linoff,
					     linesz * count, output_bfd)
d5177 1
a5177 1
			    return FALSE;
d5189 2
a5190 2
				 that refer to a line number in the
				 range we just output.  */
d5202 1
a5202 1
					  >= (bfd_size_type)(enclosing->line_filepos + linoff))
d5264 7
a5270 5
      file_ptr pos = obj_sym_filepos (output_bfd) + syment_base * osymesz;
      bfd_size_type amt = outsym - finfo->outsyms;
      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (finfo->outsyms, amt, output_bfd) != amt)
	return FALSE;
d5281 1
a5281 1
  obj_coff_keep_syms (input_bfd) = TRUE;
a5285 1

d5300 1
a5300 1
	 represent csects, so bfd_get_section_contents should work.  */
d5304 7
a5310 6
      else {
	if (! bfd_get_section_contents (input_bfd, o, finfo->contents,
					(file_ptr) 0, o->_raw_size))
	  return FALSE;
	contents = finfo->contents;
      }
d5325 2
a5326 2
			     (input_bfd, o, FALSE, finfo->external_relocs,
			      TRUE,
d5330 1
a5330 1
	    return FALSE;
d5333 1
a5333 1
	     contents.  */
d5340 1
a5340 1
	    return FALSE;
d5351 1
a5351 1
	      bfd_boolean quiet;
d5377 4
a5380 4
			 attached.  The symbol should be the one which
			 this reloc is for.  We want to make this
			 reloc against the TOC address of the symbol,
			 not the symbol itself.  */
a5388 1
			  bfd_size_type amt;
a5389 1
			  amt = sizeof (struct xcoff_toc_rel_hash);
d5391 2
a5392 1
			       bfd_alloc (finfo->output_bfd, amt));
d5394 1
a5394 1
			    return FALSE;
a5458 1

a5459 1

a5469 1

d5471 1
a5471 1
			    return FALSE;
d5476 1
a5476 1
			    return FALSE;
d5481 1
a5481 1
	      quiet = FALSE;
d5499 1
a5499 1
		    ldrel.l_symndx = -(bfd_size_type ) 1;
d5525 1
a5525 1
			     bfd_archive_filename (input_bfd),
d5528 1
a5528 1
			  return FALSE;
d5541 1
a5541 1
			  quiet = TRUE;
d5547 1
a5547 1
			     bfd_archive_filename (input_bfd),
d5550 1
a5550 1
			  return FALSE;
d5562 1
a5562 1
			 bfd_archive_filename (input_bfd),
d5566 1
a5566 1
		      return FALSE;
d5568 4
a5571 4
		  bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel,
					    finfo->ldrel);

		  finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);
d5590 1
a5590 1
				      contents, (file_ptr) o->output_offset,
d5594 1
a5594 1
	return FALSE;
d5602 1
a5602 1
	return FALSE;
d5605 1
a5605 1
  return TRUE;
d5613 2
a5614 3

static bfd_boolean
xcoff_write_global_symbol (h, inf)
d5616 1
a5616 1
     PTR inf;
d5618 1
a5618 1
  struct xcoff_final_link_info *finfo = (struct xcoff_final_link_info *) inf;
a5622 3
  bfd_boolean result;
  file_ptr pos;
  bfd_size_type amt;
a5626 7
  if (h->root.type == bfd_link_hash_warning)
    {
      h = (struct xcoff_link_hash_entry *) h->root.u.i.link;
      if (h->root.type == bfd_link_hash_new)
	return TRUE;
    }

d5630 1
a5630 1
    return TRUE;
a5642 1

a5646 1

a5650 1

a5659 1

d5667 1
a5667 8
	{
	  /* Clear l_smtype
	     Import symbols are defined so the check above will make
	     the l_smtype XTY_SD.  But this is not correct, it should
	     be cleared.  */
	  ldsym->l_smtype |= L_IMPORT;
	}

d5671 1
a5671 4
	{
	  ldsym->l_smtype |= L_EXPORT;
	}

d5673 1
a5673 8
	{
	  ldsym->l_smtype |= L_ENTRY;
	}

      if ((h->flags & XCOFF_RTINIT) != 0)
	{
	  ldsym->l_smtype = XTY_SD;
	}
d5677 2
a5678 27
      if (ldsym->l_smtype & L_IMPORT)
	{
	  if ((h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	      && (h->root.u.def.value != 0))
	    {
	      ldsym->l_smclas = XMC_XO;
	    }
	  else if ((h->flags & (XCOFF_SYSCALL32 | XCOFF_SYSCALL64)) ==
		   (XCOFF_SYSCALL32 | XCOFF_SYSCALL64))
	    {
	      ldsym->l_smclas = XMC_SV3264;
	    }
	  else if (h->flags & XCOFF_SYSCALL32)
	    {
	      ldsym->l_smclas = XMC_SV;
	    }
	  else if (h->flags & XCOFF_SYSCALL64)
	    {
	      ldsym->l_smclas = XMC_SV64;
	    }
	}

      if (ldsym->l_ifile == -(bfd_size_type) 1)
	{
	  ldsym->l_ifile = 0;
	}
d5682 1
a5682 3
	    {
	      ldsym->l_ifile = 0;
	    }
d5684 1
a5684 3
	    {
	      ldsym->l_ifile = 0;
	    }
d5695 2
a5696 5

      bfd_xcoff_swap_ldsym_out (output_bfd, ldsym,
				(finfo->ldsym +
				 (h->ldindx - 3)
				 * bfd_xcoff_ldsymsz(finfo->output_bfd)));
d5712 1
a5712 1
	 specific TOC element.  */
a5715 1

d5717 6
a5722 20
	{
	  tocoff += h->descriptor->u.toc_offset;
	}


      /* The first instruction in the glink code needs to be
	 cooked to to hold the correct offset in the toc.  The
	 rest are just output raw.  */
      bfd_put_32 (output_bfd,
		  bfd_xcoff_glink_code(output_bfd, 0) | (tocoff & 0xffff), p);

      /* Start with i == 1 to get past the first instruction done above
	 The /4 is because the glink code is in bytes and we are going
	 4 at a pop.  */
      for (i = 1; i < bfd_xcoff_glink_code_size(output_bfd) / 4; i++)
	{
	  bfd_put_32 (output_bfd,
		      (bfd_vma) bfd_xcoff_glink_code(output_bfd, i),
		      &p[4 * i]);
	}
a5743 2


d5745 1
a5745 3
	{
	  irel->r_symndx = h->indx;
	}
a5750 31

      BFD_ASSERT (h->ldindx >= 0);

      /* Initialize the aux union here instead of closer to when it is
	 written out below because the length of the csect depends on
	 whether the output is 32 or 64 bit.  */
      memset (&iraux, 0, sizeof iraux);
      iraux.x_csect.x_smtyp = XTY_SD;
      /* iraux.x_csect.x_scnlen.l = 4 or 8, see below */
      iraux.x_csect.x_smclas = XMC_TC;

      /* 32 bit uses a 32 bit R_POS to do the relocations
	 64 bit uses a 64 bit R_POS to do the relocations

	 Also needs to change the csect size : 4 for 32 bit, 8 for 64 bit

	 Which one is determined by the backend.  */
      if (bfd_xcoff_is_xcoff64 (output_bfd))
	{
	  irel->r_size = 63;
	  iraux.x_csect.x_scnlen.l = 8;
	}
      else if (bfd_xcoff_is_xcoff32 (output_bfd))
	{
	  irel->r_size = 31;
	  iraux.x_csect.x_scnlen.l = 4;
	}
      else
	{
	  return FALSE;
	}
d5752 1
d5756 1
d5759 1
a5759 1
      ldrel.l_rtype = (irel->r_size << 8) | R_POS;
d5761 2
a5762 2
      bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
      finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);
d5764 2
a5765 2
      /* We need to emit a symbol to define a csect which holds
	 the reloc.  */
d5768 6
d5775 10
a5784 4
	  result = bfd_xcoff_put_symbol_name (output_bfd, finfo->strtab,
					      &irsym, h->root.root.string);
	  if (!result)
	    return FALSE;
d5795 5
a5799 1
	  /* note : iraux is initialized above */
d5808 9
a5816 7
	      pos = obj_sym_filepos (output_bfd);
	      pos += (obj_raw_syment_count (output_bfd)
		      * bfd_coff_symesz (output_bfd));
	      amt = outsym - finfo->outsyms;
	      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
		  || bfd_bwrite (finfo->outsyms, amt, output_bfd) != amt)
		return FALSE;
d5828 1
a5828 7
     word is zero.

     32 bit vs 64 bit
     The addresses for the 32 bit will take 4 bytes and the addresses
     for 64 bit will take 8 bytes.  Similar for the relocs.  This type
     of logic was also done above to create a TOC entry in
     xcoff_write_global_symbol.  */
a5842 16
      unsigned int reloc_size, byte_size;

      if (bfd_xcoff_is_xcoff64 (output_bfd))
	{
	  reloc_size = 63;
	  byte_size = 8;
	}
      else if (bfd_xcoff_is_xcoff32 (output_bfd))
	{
	  reloc_size = 31;
	  byte_size = 4;
	}
      else
	{
	  return FALSE;
	}
d5854 5
d5866 1
a5866 1
      irel->r_size = reloc_size;
d5884 1
a5884 1
	  return FALSE;
d5886 1
a5886 1
      ldrel.l_rtype = (reloc_size << 8) | R_POS;
d5888 2
a5889 2
      bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
      finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);
d5891 1
a5891 26
      /* There are three items to write out,
	 the address of the code
	 the address of the toc anchor
	 the environment pointer.
	 We are ignoring the environment pointer.  So set it to zero.  */
      if (bfd_xcoff_is_xcoff64 (output_bfd))
	{
	  bfd_put_64 (output_bfd,
		      (esec->output_section->vma + esec->output_offset
		       + hentry->root.u.def.value),
		      p);
	  bfd_put_64 (output_bfd, xcoff_data (output_bfd)->toc, p + 8);
	  bfd_put_64 (output_bfd, (bfd_vma) 0, p + 16);
	}
      else
	{
	  /* 32 bit backend
	     This logic was already called above so the error case where
	     the backend is neither has already been checked.  */
	  bfd_put_32 (output_bfd,
		      (esec->output_section->vma + esec->output_offset
		       + hentry->root.u.def.value),
		      p);
	  bfd_put_32 (output_bfd, xcoff_data (output_bfd)->toc, p + 4);
	  bfd_put_32 (output_bfd, (bfd_vma) 0, p + 8);
	}
d5900 1
a5900 1
		       + byte_size);
d5903 1
a5903 1
      irel->r_size = reloc_size;
d5921 1
a5921 1
	  return FALSE;
d5923 1
a5923 1
      ldrel.l_rtype = (reloc_size << 8) | R_POS;
d5925 2
a5926 2
      bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
      finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);
d5932 1
a5932 1
      return TRUE;
d5938 3
a5940 2
	      && bfd_hash_lookup (finfo->info->keep_hash, h->root.root.string,
				  FALSE, FALSE) == NULL)))
d5943 1
a5943 1
      return TRUE;
d5950 1
a5950 1
      return TRUE;
d5957 17
a5973 4
  result = bfd_xcoff_put_symbol_name (output_bfd, finfo->strtab, &isym,
				      h->root.root.string);
  if (!result)
    return FALSE;
d6001 1
a6001 4
      if (bfd_is_abs_section (h->root.u.def.section->output_section))
	isym.n_scnum = N_ABS;
      else
	isym.n_scnum = h->root.u.def.section->output_section->target_index;
d6038 1
d6057 1
d6063 8
a6070 6
  pos = obj_sym_filepos (output_bfd);
  pos += obj_raw_syment_count (output_bfd) * bfd_coff_symesz (output_bfd);
  amt = outsym - finfo->outsyms;
  if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
      || bfd_bwrite (finfo->outsyms, amt, output_bfd) != amt)
    return FALSE;
d6074 1
a6074 1
  return TRUE;
d6079 1
a6079 1
static bfd_boolean
d6098 3
a6100 3
	 symbol must either have a value of zero, or we must adjust
	 the addend by the value of the symbol.  FIXME: Write this
	 when we need it.  The old linker couldn't handle this anyhow.  */
d6108 1
a6108 1
      return FALSE;
d6114 1
a6114 1
				     FALSE, FALSE, TRUE));
d6120 2
a6121 2
	return FALSE;
      return TRUE;
d6152 1
a6152 1
      bfd_boolean ok;
d6157 1
a6157 1
	return FALSE;
d6174 1
a6174 1
	      return FALSE;
d6182 1
a6182 1
	return FALSE;
d6237 1
a6237 1
	  return FALSE;
d6249 1
a6249 1
	  return FALSE;
d6256 2
a6257 2
  bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
  finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);
d6259 1
a6259 1
  return TRUE;
d6280 317
d6598 23
d6622 7
d6630 2
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d1251 1
a1251 1
	      /* explicit cast to bfd_signed_vma for compiler */
d1830 1
a1830 1
		  else if ((*sym_hash)->root.und_next != NULL
d2901 1
a2901 1
      /* __rtinit initialized */
d2935 1
a2935 1
  if (info->relocatable
d5297 1
a5297 1
		      if (! finfo->info->relocatable
@


