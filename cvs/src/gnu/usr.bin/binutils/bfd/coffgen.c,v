head	1.8;
access;
symbols
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.52
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.11.02.20.45.05;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.21;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.29;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.09;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.32.51;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.18.59.54;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.44.05;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.35;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.35;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.05.12;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.37.21;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.12.11;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.18.24;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.30;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.21.46;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.12;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.17;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* Support for the generic parts of COFF, for BFD.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Written by Cygnus Support.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* Most of this hacked by  Steve Chamberlain, sac@@cygnus.com.
   Split out of coffcode.h by Ian Taylor, ian@@cygnus.com.  */

/* This file contains COFF code that is not dependent on any
   particular COFF target.  There is only one version of this file in
   libbfd.a, so no target specific code may be put in here.  Or, to
   put it another way,

   ********** DO NOT PUT TARGET SPECIFIC CODE IN THIS FILE **********

   If you need to add some target specific behaviour, add a new hook
   function to bfd_coff_backend_data.

   Some of these functions are also called by the ECOFF routines.
   Those functions may not use any COFF specific information, such as
   coff_data (abfd).  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "coff/internal.h"
#include "libcoff.h"

static void coff_fix_symbol_name
  PARAMS ((bfd *, asymbol *, combined_entry_type *, bfd_size_type *,
	   asection **, bfd_size_type *));
static bfd_boolean coff_write_symbol
  PARAMS ((bfd *, asymbol *, combined_entry_type *, bfd_vma *,
	   bfd_size_type *, asection **, bfd_size_type *));
static bfd_boolean coff_write_alien_symbol
  PARAMS ((bfd *, asymbol *, bfd_vma *, bfd_size_type *,
	   asection **, bfd_size_type *));
static bfd_boolean coff_write_native_symbol
  PARAMS ((bfd *, coff_symbol_type *, bfd_vma *, bfd_size_type *,
	   asection **, bfd_size_type *));
static void coff_pointerize_aux
  PARAMS ((bfd *, combined_entry_type *, combined_entry_type *,
	   unsigned int, combined_entry_type *));
static bfd_boolean make_a_section_from_file
  PARAMS ((bfd *, struct internal_scnhdr *, unsigned int));
static const bfd_target *coff_real_object_p
  PARAMS ((bfd *, unsigned, struct internal_filehdr *,
	   struct internal_aouthdr *));
static void fixup_symbol_value
  PARAMS ((bfd *, coff_symbol_type *, struct internal_syment *));
static char *build_debug_section
  PARAMS ((bfd *));
static char *copy_name
  PARAMS ((bfd *, char *, size_t));

#define STRING_SIZE_SIZE (4)

/* Take a section header read from a coff file (in HOST byte order),
   and make a BFD "section" out of it.  This is used by ECOFF.  */
static bfd_boolean
make_a_section_from_file (abfd, hdr, target_index)
     bfd *abfd;
     struct internal_scnhdr *hdr;
     unsigned int target_index;
{
  asection *return_section;
  char *name;
  bfd_boolean result = TRUE;
  flagword flags;

  name = NULL;

  /* Handle long section names as in PE.  */
  if (bfd_coff_long_section_names (abfd)
      && hdr->s_name[0] == '/')
    {
      char buf[SCNNMLEN];
      long strindex;
      char *p;
      const char *strings;

      memcpy (buf, hdr->s_name + 1, SCNNMLEN - 1);
      buf[SCNNMLEN - 1] = '\0';
      strindex = strtol (buf, &p, 10);
      if (*p == '\0' && strindex >= 0)
	{
	  strings = _bfd_coff_read_string_table (abfd);
	  if (strings == NULL)
	    return FALSE;
	  /* FIXME: For extra safety, we should make sure that
             strindex does not run us past the end, but right now we
             don't know the length of the string table.  */
	  strings += strindex;
	  name = bfd_alloc (abfd, (bfd_size_type) strlen (strings) + 1);
	  if (name == NULL)
	    return FALSE;
	  strcpy (name, strings);
	}
    }

  if (name == NULL)
    {
      /* Assorted wastage to null-terminate the name, thanks AT&T! */
      name = bfd_alloc (abfd, (bfd_size_type) sizeof (hdr->s_name) + 1);
      if (name == NULL)
	return FALSE;
      strncpy (name, (char *) &hdr->s_name[0], sizeof (hdr->s_name));
      name[sizeof (hdr->s_name)] = 0;
    }

  return_section = bfd_make_section_anyway (abfd, name);
  if (return_section == NULL)
    return FALSE;

  return_section->vma = hdr->s_vaddr;
  return_section->lma = hdr->s_paddr;
  return_section->_raw_size = hdr->s_size;
  return_section->filepos = hdr->s_scnptr;
  return_section->rel_filepos = hdr->s_relptr;
  return_section->reloc_count = hdr->s_nreloc;

  bfd_coff_set_alignment_hook (abfd, return_section, hdr);

  return_section->line_filepos = hdr->s_lnnoptr;

  return_section->lineno_count = hdr->s_nlnno;
  return_section->userdata = NULL;
  return_section->next = (asection *) NULL;
  return_section->target_index = target_index;

  if (! bfd_coff_styp_to_sec_flags_hook (abfd, hdr, name, return_section,
					 & flags))
    result = FALSE;

  return_section->flags = flags;

  /* At least on i386-coff, the line number count for a shared library
     section must be ignored.  */
  if ((return_section->flags & SEC_COFF_SHARED_LIBRARY) != 0)
    return_section->lineno_count = 0;

  if (hdr->s_nreloc != 0)
    return_section->flags |= SEC_RELOC;
  /* FIXME: should this check 'hdr->s_size > 0' */
  if (hdr->s_scnptr != 0)
    return_section->flags |= SEC_HAS_CONTENTS;

  return result;
}

/* Read in a COFF object and make it into a BFD.  This is used by
   ECOFF as well.  */

static const bfd_target *
coff_real_object_p (abfd, nscns, internal_f, internal_a)
     bfd *abfd;
     unsigned nscns;
     struct internal_filehdr *internal_f;
     struct internal_aouthdr *internal_a;
{
  flagword oflags = abfd->flags;
  bfd_vma ostart = bfd_get_start_address (abfd);
  PTR tdata;
  PTR tdata_save;
  bfd_size_type readsize;	/* length of file_info */
  unsigned int scnhsz;
  char *external_sections;

  if (!(internal_f->f_flags & F_RELFLG))
    abfd->flags |= HAS_RELOC;
  if ((internal_f->f_flags & F_EXEC))
    abfd->flags |= EXEC_P;
  if (!(internal_f->f_flags & F_LNNO))
    abfd->flags |= HAS_LINENO;
  if (!(internal_f->f_flags & F_LSYMS))
    abfd->flags |= HAS_LOCALS;

  /* FIXME: How can we set D_PAGED correctly?  */
  if ((internal_f->f_flags & F_EXEC) != 0)
    abfd->flags |= D_PAGED;

  bfd_get_symcount (abfd) = internal_f->f_nsyms;
  if (internal_f->f_nsyms)
    abfd->flags |= HAS_SYMS;

  if (internal_a != (struct internal_aouthdr *) NULL)
    bfd_get_start_address (abfd) = internal_a->entry;
  else
    bfd_get_start_address (abfd) = 0;

  /* Set up the tdata area.  ECOFF uses its own routine, and overrides
     abfd->flags.  */
  tdata_save = abfd->tdata.any;
  tdata = bfd_coff_mkobject_hook (abfd, (PTR) internal_f, (PTR) internal_a);
  if (tdata == NULL)
    goto fail2;

  scnhsz = bfd_coff_scnhsz (abfd);
  readsize = (bfd_size_type) nscns * scnhsz;
  external_sections = (char *) bfd_alloc (abfd, readsize);
  if (!external_sections)
    goto fail;

  if (bfd_bread ((PTR) external_sections, readsize, abfd) != readsize)
    goto fail;

  /* Set the arch/mach *before* swapping in sections; section header swapping
     may depend on arch/mach info.  */
  if (! bfd_coff_set_arch_mach_hook (abfd, (PTR) internal_f))
    goto fail;

  /* Now copy data as required; construct all asections etc.  */
  if (nscns != 0)
    {
      unsigned int i;
      for (i = 0; i < nscns; i++)
	{
	  struct internal_scnhdr tmp;
	  bfd_coff_swap_scnhdr_in (abfd,
				   (PTR) (external_sections + i * scnhsz),
				   (PTR) & tmp);
	  if (! make_a_section_from_file (abfd, &tmp, i + 1))
	    goto fail;
	}
    }

  return abfd->xvec;

 fail:
  bfd_release (abfd, tdata);
 fail2:
  abfd->tdata.any = tdata_save;
  abfd->flags = oflags;
  bfd_get_start_address (abfd) = ostart;
  return (const bfd_target *) NULL;
}

/* Turn a COFF file into a BFD, but fail with bfd_error_wrong_format if it is
   not a COFF file.  This is also used by ECOFF.  */

const bfd_target *
coff_object_p (abfd)
     bfd *abfd;
{
  bfd_size_type filhsz;
  bfd_size_type aoutsz;
  unsigned int nscns;
  PTR filehdr;
  struct internal_filehdr internal_f;
  struct internal_aouthdr internal_a;

  /* figure out how much to read */
  filhsz = bfd_coff_filhsz (abfd);
  aoutsz = bfd_coff_aoutsz (abfd);

  filehdr = bfd_alloc (abfd, filhsz);
  if (filehdr == NULL)
    return NULL;
  if (bfd_bread (filehdr, filhsz, abfd) != filhsz)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      bfd_release (abfd, filehdr);
      return NULL;
    }
  bfd_coff_swap_filehdr_in (abfd, filehdr, &internal_f);
  bfd_release (abfd, filehdr);

  /* The XCOFF format has two sizes for the f_opthdr.  SMALL_AOUTSZ
     (less than aoutsz) used in object files and AOUTSZ (equal to
     aoutsz) in executables.  The bfd_coff_swap_aouthdr_in function
     expects this header to be aoutsz bytes in length, so we use that
     value in the call to bfd_alloc below.  But we must be careful to
     only read in f_opthdr bytes in the call to bfd_bread.  We should
     also attempt to catch corrupt or non-COFF binaries with a strange
     value for f_opthdr.  */
  if (! bfd_coff_bad_format_hook (abfd, &internal_f)
      || internal_f.f_opthdr > aoutsz)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }
  nscns = internal_f.f_nscns;

  if (internal_f.f_opthdr)
    {
      PTR opthdr;

      opthdr = bfd_alloc (abfd, aoutsz);
      if (opthdr == NULL)
	return NULL;
      if (bfd_bread (opthdr, (bfd_size_type) internal_f.f_opthdr, abfd)
	  != internal_f.f_opthdr)
	{
	  bfd_release (abfd, opthdr);
	  return NULL;
	}
      bfd_coff_swap_aouthdr_in (abfd, opthdr, (PTR) &internal_a);
      bfd_release (abfd, opthdr);
    }

  return coff_real_object_p (abfd, nscns, &internal_f,
			     (internal_f.f_opthdr != 0
			      ? &internal_a
			      : (struct internal_aouthdr *) NULL));
}

/* Get the BFD section from a COFF symbol section number.  */

asection *
coff_section_from_bfd_index (abfd, index)
     bfd *abfd;
     int index;
{
  struct bfd_section *answer = abfd->sections;

  if (index == N_ABS)
    return bfd_abs_section_ptr;
  if (index == N_UNDEF)
    return bfd_und_section_ptr;
  if (index == N_DEBUG)
    return bfd_abs_section_ptr;

  while (answer)
    {
      if (answer->target_index == index)
	return answer;
      answer = answer->next;
    }

  /* We should not reach this point, but the SCO 3.2v4 /lib/libc_s.a
     has a bad symbol table in biglitpow.o.  */
  return bfd_und_section_ptr;
}

/* Get the upper bound of a COFF symbol table.  */

long
coff_get_symtab_upper_bound (abfd)
     bfd *abfd;
{
  if (!bfd_coff_slurp_symbol_table (abfd))
    return -1;

  return (bfd_get_symcount (abfd) + 1) * (sizeof (coff_symbol_type *));
}

/* Canonicalize a COFF symbol table.  */

long
coff_canonicalize_symtab (abfd, alocation)
     bfd *abfd;
     asymbol **alocation;
{
  unsigned int counter;
  coff_symbol_type *symbase;
  coff_symbol_type **location = (coff_symbol_type **) alocation;

  if (!bfd_coff_slurp_symbol_table (abfd))
    return -1;

  symbase = obj_symbols (abfd);
  counter = bfd_get_symcount (abfd);
  while (counter-- > 0)
    *location++ = symbase++;

  *location = NULL;

  return bfd_get_symcount (abfd);
}

/* Get the name of a symbol.  The caller must pass in a buffer of size
   >= SYMNMLEN + 1.  */

const char *
_bfd_coff_internal_syment_name (abfd, sym, buf)
     bfd *abfd;
     const struct internal_syment *sym;
     char *buf;
{
  /* FIXME: It's not clear this will work correctly if sizeof
     (_n_zeroes) != 4.  */
  if (sym->_n._n_n._n_zeroes != 0
      || sym->_n._n_n._n_offset == 0)
    {
      memcpy (buf, sym->_n._n_name, SYMNMLEN);
      buf[SYMNMLEN] = '\0';
      return buf;
    }
  else
    {
      const char *strings;

      BFD_ASSERT (sym->_n._n_n._n_offset >= STRING_SIZE_SIZE);
      strings = obj_coff_strings (abfd);
      if (strings == NULL)
	{
	  strings = _bfd_coff_read_string_table (abfd);
	  if (strings == NULL)
	    return NULL;
	}
      return strings + sym->_n._n_n._n_offset;
    }
}

/* Read in and swap the relocs.  This returns a buffer holding the
   relocs for section SEC in file ABFD.  If CACHE is TRUE and
   INTERNAL_RELOCS is NULL, the relocs read in will be saved in case
   the function is called again.  If EXTERNAL_RELOCS is not NULL, it
   is a buffer large enough to hold the unswapped relocs.  If
   INTERNAL_RELOCS is not NULL, it is a buffer large enough to hold
   the swapped relocs.  If REQUIRE_INTERNAL is TRUE, then the return
   value must be INTERNAL_RELOCS.  The function returns NULL on error.  */

struct internal_reloc *
_bfd_coff_read_internal_relocs (abfd, sec, cache, external_relocs,
				require_internal, internal_relocs)
     bfd *abfd;
     asection *sec;
     bfd_boolean cache;
     bfd_byte *external_relocs;
     bfd_boolean require_internal;
     struct internal_reloc *internal_relocs;
{
  bfd_size_type relsz;
  bfd_byte *free_external = NULL;
  struct internal_reloc *free_internal = NULL;
  bfd_byte *erel;
  bfd_byte *erel_end;
  struct internal_reloc *irel;
  bfd_size_type amt;

  if (coff_section_data (abfd, sec) != NULL
      && coff_section_data (abfd, sec)->relocs != NULL)
    {
      if (! require_internal)
	return coff_section_data (abfd, sec)->relocs;
      memcpy (internal_relocs, coff_section_data (abfd, sec)->relocs,
	      sec->reloc_count * sizeof (struct internal_reloc));
      return internal_relocs;
    }

  relsz = bfd_coff_relsz (abfd);

  amt = sec->reloc_count * relsz;
  if (external_relocs == NULL)
    {
      free_external = (bfd_byte *) bfd_malloc (amt);
      if (free_external == NULL && sec->reloc_count > 0)
	goto error_return;
      external_relocs = free_external;
    }

  if (bfd_seek (abfd, sec->rel_filepos, SEEK_SET) != 0
      || bfd_bread (external_relocs, amt, abfd) != amt)
    goto error_return;

  if (internal_relocs == NULL)
    {
      amt = sec->reloc_count;
      amt *= sizeof (struct internal_reloc);
      free_internal = (struct internal_reloc *) bfd_malloc (amt);
      if (free_internal == NULL && sec->reloc_count > 0)
	goto error_return;
      internal_relocs = free_internal;
    }

  /* Swap in the relocs.  */
  erel = external_relocs;
  erel_end = erel + relsz * sec->reloc_count;
  irel = internal_relocs;
  for (; erel < erel_end; erel += relsz, irel++)
    bfd_coff_swap_reloc_in (abfd, (PTR) erel, (PTR) irel);

  if (free_external != NULL)
    {
      free (free_external);
      free_external = NULL;
    }

  if (cache && free_internal != NULL)
    {
      if (coff_section_data (abfd, sec) == NULL)
	{
	  amt = sizeof (struct coff_section_tdata);
	  sec->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
	  if (sec->used_by_bfd == NULL)
	    goto error_return;
	  coff_section_data (abfd, sec)->contents = NULL;
	}
      coff_section_data (abfd, sec)->relocs = free_internal;
    }

  return internal_relocs;

 error_return:
  if (free_external != NULL)
    free (free_external);
  if (free_internal != NULL)
    free (free_internal);
  return NULL;
}

/* Set lineno_count for the output sections of a COFF file.  */

int
coff_count_linenumbers (abfd)
     bfd *abfd;
{
  unsigned int limit = bfd_get_symcount (abfd);
  unsigned int i;
  int total = 0;
  asymbol **p;
  asection *s;

  if (limit == 0)
    {
      /* This may be from the backend linker, in which case the
         lineno_count in the sections is correct.  */
      for (s = abfd->sections; s != NULL; s = s->next)
	total += s->lineno_count;
      return total;
    }

  for (s = abfd->sections; s != NULL; s = s->next)
    BFD_ASSERT (s->lineno_count == 0);

  for (p = abfd->outsymbols, i = 0; i < limit; i++, p++)
    {
      asymbol *q_maybe = *p;

      if (bfd_family_coff (bfd_asymbol_bfd (q_maybe)))
	{
	  coff_symbol_type *q = coffsymbol (q_maybe);

	  /* The AIX 4.1 compiler can sometimes generate line numbers
             attached to debugging symbols.  We try to simply ignore
             those here.  */
	  if (q->lineno != NULL
	      && q->symbol.section->owner != NULL)
	    {
	      /* This symbol has line numbers.  Increment the owning
	         section's linenumber count.  */
	      alent *l = q->lineno;

	      do
		{
		  asection * sec = q->symbol.section->output_section;

		  /* Do not try to update fields in read-only sections.  */
		  if (! bfd_is_const_section (sec))
		    sec->lineno_count ++;

		  ++total;
		  ++l;
		}
	      while (l->line_number != 0);
	    }
	}
    }

  return total;
}

/* Takes a bfd and a symbol, returns a pointer to the coff specific
   area of the symbol if there is one.  */

coff_symbol_type *
coff_symbol_from (ignore_abfd, symbol)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *symbol;
{
  if (!bfd_family_coff (bfd_asymbol_bfd (symbol)))
    return (coff_symbol_type *) NULL;

  if (bfd_asymbol_bfd (symbol)->tdata.coff_obj_data == (coff_data_type *) NULL)
    return (coff_symbol_type *) NULL;

  return (coff_symbol_type *) symbol;
}

static void
fixup_symbol_value (abfd, coff_symbol_ptr, syment)
     bfd *abfd;
     coff_symbol_type *coff_symbol_ptr;
     struct internal_syment *syment;
{

  /* Normalize the symbol flags */
  if (bfd_is_com_section (coff_symbol_ptr->symbol.section))
    {
      /* a common symbol is undefined with a value */
      syment->n_scnum = N_UNDEF;
      syment->n_value = coff_symbol_ptr->symbol.value;
    }
  else if ((coff_symbol_ptr->symbol.flags & BSF_DEBUGGING) != 0
	   && (coff_symbol_ptr->symbol.flags & BSF_DEBUGGING_RELOC) == 0)
    {
      syment->n_value = coff_symbol_ptr->symbol.value;
    }
  else if (bfd_is_und_section (coff_symbol_ptr->symbol.section))
    {
      syment->n_scnum = N_UNDEF;
      syment->n_value = 0;
    }
  /* FIXME: Do we need to handle the absolute section here?  */
  else
    {
      if (coff_symbol_ptr->symbol.section)
	{
	  syment->n_scnum =
	    coff_symbol_ptr->symbol.section->output_section->target_index;

	  syment->n_value = (coff_symbol_ptr->symbol.value
			     + coff_symbol_ptr->symbol.section->output_offset);
	  if (! obj_pe (abfd))
            {
              syment->n_value += (syment->n_sclass == C_STATLAB)
                ? coff_symbol_ptr->symbol.section->output_section->lma
                : coff_symbol_ptr->symbol.section->output_section->vma;
            }
	}
      else
	{
	  BFD_ASSERT (0);
	  /* This can happen, but I don't know why yet (steve@@cygnus.com) */
	  syment->n_scnum = N_ABS;
	  syment->n_value = coff_symbol_ptr->symbol.value;
	}
    }
}

/* Run through all the symbols in the symbol table and work out what
   their indexes into the symbol table will be when output.

   Coff requires that each C_FILE symbol points to the next one in the
   chain, and that the last one points to the first external symbol. We
   do that here too.  */

bfd_boolean
coff_renumber_symbols (bfd_ptr, first_undef)
     bfd *bfd_ptr;
     int *first_undef;
{
  unsigned int symbol_count = bfd_get_symcount (bfd_ptr);
  asymbol **symbol_ptr_ptr = bfd_ptr->outsymbols;
  unsigned int native_index = 0;
  struct internal_syment *last_file = (struct internal_syment *) NULL;
  unsigned int symbol_index;

  /* COFF demands that undefined symbols come after all other symbols.
     Since we don't need to impose this extra knowledge on all our
     client programs, deal with that here.  Sort the symbol table;
     just move the undefined symbols to the end, leaving the rest
     alone.  The O'Reilly book says that defined global symbols come
     at the end before the undefined symbols, so we do that here as
     well.  */
  /* @@@@ Do we have some condition we could test for, so we don't always
     have to do this?  I don't think relocatability is quite right, but
     I'm not certain.  [raeburn:19920508.1711EST]  */
  {
    asymbol **newsyms;
    unsigned int i;
    bfd_size_type amt;

    amt = sizeof (asymbol *) * ((bfd_size_type) symbol_count + 1);
    newsyms = (asymbol **) bfd_alloc (bfd_ptr, amt);
    if (!newsyms)
      return FALSE;
    bfd_ptr->outsymbols = newsyms;
    for (i = 0; i < symbol_count; i++)
      if ((symbol_ptr_ptr[i]->flags & BSF_NOT_AT_END) != 0
	  || (!bfd_is_und_section (symbol_ptr_ptr[i]->section)
	      && !bfd_is_com_section (symbol_ptr_ptr[i]->section)
	      && ((symbol_ptr_ptr[i]->flags & BSF_FUNCTION) != 0
		  || ((symbol_ptr_ptr[i]->flags & (BSF_GLOBAL | BSF_WEAK))
		      == 0))))
	*newsyms++ = symbol_ptr_ptr[i];

    for (i = 0; i < symbol_count; i++)
      if ((symbol_ptr_ptr[i]->flags & BSF_NOT_AT_END) == 0
	  && !bfd_is_und_section (symbol_ptr_ptr[i]->section)
	  && (bfd_is_com_section (symbol_ptr_ptr[i]->section)
	      || ((symbol_ptr_ptr[i]->flags & BSF_FUNCTION) == 0
		  && ((symbol_ptr_ptr[i]->flags & (BSF_GLOBAL | BSF_WEAK))
		      != 0))))
	*newsyms++ = symbol_ptr_ptr[i];

    *first_undef = newsyms - bfd_ptr->outsymbols;

    for (i = 0; i < symbol_count; i++)
      if ((symbol_ptr_ptr[i]->flags & BSF_NOT_AT_END) == 0
	  && bfd_is_und_section (symbol_ptr_ptr[i]->section))
	*newsyms++ = symbol_ptr_ptr[i];
    *newsyms = (asymbol *) NULL;
    symbol_ptr_ptr = bfd_ptr->outsymbols;
  }

  for (symbol_index = 0; symbol_index < symbol_count; symbol_index++)
    {
      coff_symbol_type *coff_symbol_ptr = coff_symbol_from (bfd_ptr, symbol_ptr_ptr[symbol_index]);
      symbol_ptr_ptr[symbol_index]->udata.i = symbol_index;
      if (coff_symbol_ptr && coff_symbol_ptr->native)
	{
	  combined_entry_type *s = coff_symbol_ptr->native;
	  int i;

	  if (s->u.syment.n_sclass == C_FILE)
	    {
	      if (last_file != (struct internal_syment *) NULL)
		last_file->n_value = native_index;
	      last_file = &(s->u.syment);
	    }
	  else
	    {

	      /* Modify the symbol values according to their section and
	         type */

	      fixup_symbol_value (bfd_ptr, coff_symbol_ptr, &(s->u.syment));
	    }
	  for (i = 0; i < s->u.syment.n_numaux + 1; i++)
	    s[i].offset = native_index++;
	}
      else
	{
	  native_index++;
	}
    }
  obj_conv_table_size (bfd_ptr) = native_index;

  return TRUE;
}

/* Run thorough the symbol table again, and fix it so that all
   pointers to entries are changed to the entries' index in the output
   symbol table.  */

void
coff_mangle_symbols (bfd_ptr)
     bfd *bfd_ptr;
{
  unsigned int symbol_count = bfd_get_symcount (bfd_ptr);
  asymbol **symbol_ptr_ptr = bfd_ptr->outsymbols;
  unsigned int symbol_index;

  for (symbol_index = 0; symbol_index < symbol_count; symbol_index++)
    {
      coff_symbol_type *coff_symbol_ptr =
      coff_symbol_from (bfd_ptr, symbol_ptr_ptr[symbol_index]);

      if (coff_symbol_ptr && coff_symbol_ptr->native)
	{
	  int i;
	  combined_entry_type *s = coff_symbol_ptr->native;

	  if (s->fix_value)
	    {
	      /* FIXME: We should use a union here.  */
	      s->u.syment.n_value =
		(bfd_vma)((combined_entry_type *)
			  ((unsigned long) s->u.syment.n_value))->offset;
	      s->fix_value = 0;
	    }
	  if (s->fix_line)
	    {
	      /* The value is the offset into the line number entries
                 for the symbol's section.  On output, the symbol's
                 section should be N_DEBUG.  */
	      s->u.syment.n_value =
		(coff_symbol_ptr->symbol.section->output_section->line_filepos
		 + s->u.syment.n_value * bfd_coff_linesz (bfd_ptr));
	      coff_symbol_ptr->symbol.section =
		coff_section_from_bfd_index (bfd_ptr, N_DEBUG);
	      BFD_ASSERT (coff_symbol_ptr->symbol.flags & BSF_DEBUGGING);
	    }
	  for (i = 0; i < s->u.syment.n_numaux; i++)
	    {
	      combined_entry_type *a = s + i + 1;
	      if (a->fix_tag)
		{
		  a->u.auxent.x_sym.x_tagndx.l =
		    a->u.auxent.x_sym.x_tagndx.p->offset;
		  a->fix_tag = 0;
		}
	      if (a->fix_end)
		{
		  a->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.l =
		    a->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.p->offset;
		  a->fix_end = 0;
		}
	      if (a->fix_scnlen)
		{
		  a->u.auxent.x_csect.x_scnlen.l =
		    a->u.auxent.x_csect.x_scnlen.p->offset;
		  a->fix_scnlen = 0;
		}
	    }
	}
    }
}

static void
coff_fix_symbol_name (abfd, symbol, native, string_size_p,
		      debug_string_section_p, debug_string_size_p)
     bfd *abfd;
     asymbol *symbol;
     combined_entry_type *native;
     bfd_size_type *string_size_p;
     asection **debug_string_section_p;
     bfd_size_type *debug_string_size_p;
{
  unsigned int name_length;
  union internal_auxent *auxent;
  char *name = (char *) (symbol->name);

  if (name == (char *) NULL)
    {
      /* coff symbols always have names, so we'll make one up */
      symbol->name = "strange";
      name = (char *) symbol->name;
    }
  name_length = strlen (name);

  if (native->u.syment.n_sclass == C_FILE
      && native->u.syment.n_numaux > 0)
    {
      unsigned int filnmlen;

      if (bfd_coff_force_symnames_in_strings (abfd))
	{
          native->u.syment._n._n_n._n_offset =
	      (*string_size_p + STRING_SIZE_SIZE);
	  native->u.syment._n._n_n._n_zeroes = 0;
	  *string_size_p += 6;  /* strlen(".file") + 1 */
	}
      else
  	strncpy (native->u.syment._n._n_name, ".file", SYMNMLEN);

      auxent = &(native + 1)->u.auxent;

      filnmlen = bfd_coff_filnmlen (abfd);

      if (bfd_coff_long_filenames (abfd))
	{
	  if (name_length <= filnmlen)
	    {
	      strncpy (auxent->x_file.x_fname, name, filnmlen);
	    }
	  else
	    {
	      auxent->x_file.x_n.x_offset = *string_size_p + STRING_SIZE_SIZE;
	      auxent->x_file.x_n.x_zeroes = 0;
	      *string_size_p += name_length + 1;
	    }
	}
      else
	{
	  strncpy (auxent->x_file.x_fname, name, filnmlen);
	  if (name_length > filnmlen)
	    name[filnmlen] = '\0';
	}
    }
  else
    {
      if (name_length <= SYMNMLEN && !bfd_coff_force_symnames_in_strings (abfd))
	{
	  /* This name will fit into the symbol neatly */
	  strncpy (native->u.syment._n._n_name, symbol->name, SYMNMLEN);
	}
      else if (!bfd_coff_symname_in_debug (abfd, &native->u.syment))
	{
	  native->u.syment._n._n_n._n_offset = (*string_size_p
						+ STRING_SIZE_SIZE);
	  native->u.syment._n._n_n._n_zeroes = 0;
	  *string_size_p += name_length + 1;
	}
      else
	{
	  file_ptr filepos;
	  bfd_byte buf[4];
	  int prefix_len = bfd_coff_debug_string_prefix_length (abfd);

	  /* This name should be written into the .debug section.  For
	     some reason each name is preceded by a two byte length
	     and also followed by a null byte.  FIXME: We assume that
	     the .debug section has already been created, and that it
	     is large enough.  */
	  if (*debug_string_section_p == (asection *) NULL)
	    *debug_string_section_p = bfd_get_section_by_name (abfd, ".debug");
	  filepos = bfd_tell (abfd);
	  if (prefix_len == 4)
	    bfd_put_32 (abfd, (bfd_vma) (name_length + 1), buf);
	  else
	    bfd_put_16 (abfd, (bfd_vma) (name_length + 1), buf);

	  if (!bfd_set_section_contents (abfd,
					 *debug_string_section_p,
					 (PTR) buf,
					 (file_ptr) *debug_string_size_p,
					 (bfd_size_type) prefix_len)
	      || !bfd_set_section_contents (abfd,
					    *debug_string_section_p,
					    (PTR) symbol->name,
					    (file_ptr) (*debug_string_size_p
							+ prefix_len),
					    (bfd_size_type) name_length + 1))
	    abort ();
	  if (bfd_seek (abfd, filepos, SEEK_SET) != 0)
	    abort ();
	  native->u.syment._n._n_n._n_offset =
	      *debug_string_size_p + prefix_len;
	  native->u.syment._n._n_n._n_zeroes = 0;
	  *debug_string_size_p += name_length + 1 + prefix_len;
	}
    }
}

/* We need to keep track of the symbol index so that when we write out
   the relocs we can get the index for a symbol.  This method is a
   hack.  FIXME.  */

#define set_index(symbol, idx)	((symbol)->udata.i = (idx))

/* Write a symbol out to a COFF file.  */

static bfd_boolean
coff_write_symbol (abfd, symbol, native, written, string_size_p,
		   debug_string_section_p, debug_string_size_p)
     bfd *abfd;
     asymbol *symbol;
     combined_entry_type *native;
     bfd_vma *written;
     bfd_size_type *string_size_p;
     asection **debug_string_section_p;
     bfd_size_type *debug_string_size_p;
{
  unsigned int numaux = native->u.syment.n_numaux;
  int type = native->u.syment.n_type;
  int class = native->u.syment.n_sclass;
  PTR buf;
  bfd_size_type symesz;

  if (native->u.syment.n_sclass == C_FILE)
    symbol->flags |= BSF_DEBUGGING;

  if (symbol->flags & BSF_DEBUGGING
      && bfd_is_abs_section (symbol->section))
    {
      native->u.syment.n_scnum = N_DEBUG;
    }
  else if (bfd_is_abs_section (symbol->section))
    {
      native->u.syment.n_scnum = N_ABS;
    }
  else if (bfd_is_und_section (symbol->section))
    {
      native->u.syment.n_scnum = N_UNDEF;
    }
  else
    {
      native->u.syment.n_scnum =
	symbol->section->output_section->target_index;
    }

  coff_fix_symbol_name (abfd, symbol, native, string_size_p,
			debug_string_section_p, debug_string_size_p);

  symesz = bfd_coff_symesz (abfd);
  buf = bfd_alloc (abfd, symesz);
  if (!buf)
    return FALSE;
  bfd_coff_swap_sym_out (abfd, &native->u.syment, buf);
  if (bfd_bwrite (buf, symesz, abfd) != symesz)
    return FALSE;
  bfd_release (abfd, buf);

  if (native->u.syment.n_numaux > 0)
    {
      bfd_size_type auxesz;
      unsigned int j;

      auxesz = bfd_coff_auxesz (abfd);
      buf = bfd_alloc (abfd, auxesz);
      if (!buf)
	return FALSE;
      for (j = 0; j < native->u.syment.n_numaux; j++)
	{
	  bfd_coff_swap_aux_out (abfd,
				 &((native + j + 1)->u.auxent),
				 type,
				 class,
				 (int) j,
				 native->u.syment.n_numaux,
				 buf);
	  if (bfd_bwrite (buf, auxesz, abfd) != auxesz)
	    return FALSE;
	}
      bfd_release (abfd, buf);
    }

  /* Store the index for use when we write out the relocs.  */
  set_index (symbol, *written);

  *written += numaux + 1;
  return TRUE;
}

/* Write out a symbol to a COFF file that does not come from a COFF
   file originally.  This symbol may have been created by the linker,
   or we may be linking a non COFF file to a COFF file.  */

static bfd_boolean
coff_write_alien_symbol (abfd, symbol, written, string_size_p,
			 debug_string_section_p, debug_string_size_p)
     bfd *abfd;
     asymbol *symbol;
     bfd_vma *written;
     bfd_size_type *string_size_p;
     asection **debug_string_section_p;
     bfd_size_type *debug_string_size_p;
{
  combined_entry_type *native;
  combined_entry_type dummy;

  native = &dummy;
  native->u.syment.n_type = T_NULL;
  native->u.syment.n_flags = 0;
  if (bfd_is_und_section (symbol->section))
    {
      native->u.syment.n_scnum = N_UNDEF;
      native->u.syment.n_value = symbol->value;
    }
  else if (bfd_is_com_section (symbol->section))
    {
      native->u.syment.n_scnum = N_UNDEF;
      native->u.syment.n_value = symbol->value;
    }
  else if (symbol->flags & BSF_DEBUGGING)
    {
      /* There isn't much point to writing out a debugging symbol
         unless we are prepared to convert it into COFF debugging
         format.  So, we just ignore them.  We must clobber the symbol
         name to keep it from being put in the string table.  */
      symbol->name = "";
      return TRUE;
    }
  else
    {
      native->u.syment.n_scnum =
	symbol->section->output_section->target_index;
      native->u.syment.n_value = (symbol->value
				  + symbol->section->output_offset);
      if (! obj_pe (abfd))
	native->u.syment.n_value += symbol->section->output_section->vma;

      /* Copy the any flags from the file header into the symbol.
         FIXME: Why?  */
      {
	coff_symbol_type *c = coff_symbol_from (abfd, symbol);
	if (c != (coff_symbol_type *) NULL)
	  native->u.syment.n_flags = bfd_asymbol_bfd (&c->symbol)->flags;
      }
    }

  native->u.syment.n_type = 0;
  if (symbol->flags & BSF_LOCAL)
    native->u.syment.n_sclass = C_STAT;
  else if (symbol->flags & BSF_WEAK)
    native->u.syment.n_sclass = obj_pe (abfd) ? C_NT_WEAK : C_WEAKEXT;
  else
    native->u.syment.n_sclass = C_EXT;
  native->u.syment.n_numaux = 0;

  return coff_write_symbol (abfd, symbol, native, written, string_size_p,
			    debug_string_section_p, debug_string_size_p);
}

/* Write a native symbol to a COFF file.  */

static bfd_boolean
coff_write_native_symbol (abfd, symbol, written, string_size_p,
			  debug_string_section_p, debug_string_size_p)
     bfd *abfd;
     coff_symbol_type *symbol;
     bfd_vma *written;
     bfd_size_type *string_size_p;
     asection **debug_string_section_p;
     bfd_size_type *debug_string_size_p;
{
  combined_entry_type *native = symbol->native;
  alent *lineno = symbol->lineno;

  /* If this symbol has an associated line number, we must store the
     symbol index in the line number field.  We also tag the auxent to
     point to the right place in the lineno table.  */
  if (lineno && !symbol->done_lineno && symbol->symbol.section->owner != NULL)
    {
      unsigned int count = 0;
      lineno[count].u.offset = *written;
      if (native->u.syment.n_numaux)
	{
	  union internal_auxent *a = &((native + 1)->u.auxent);

	  a->x_sym.x_fcnary.x_fcn.x_lnnoptr =
	    symbol->symbol.section->output_section->moving_line_filepos;
	}

      /* Count and relocate all other linenumbers.  */
      count++;
      while (lineno[count].line_number != 0)
	{
#if 0
	  /* 13 april 92. sac
	     I've been told this, but still need proof:
	     > The second bug is also in `bfd/coffcode.h'.  This bug
	     > causes the linker to screw up the pc-relocations for
	     > all the line numbers in COFF code.  This bug isn't only
	     > specific to A29K implementations, but affects all
	     > systems using COFF format binaries.  Note that in COFF
	     > object files, the line number core offsets output by
	     > the assembler are relative to the start of each
	     > procedure, not to the start of the .text section.  This
	     > patch relocates the line numbers relative to the
	     > `native->u.syment.n_value' instead of the section
	     > virtual address.
	     > modular!olson@@cs.arizona.edu (Jon Olson)
	   */
	  lineno[count].u.offset += native->u.syment.n_value;
#else
	  lineno[count].u.offset +=
	    (symbol->symbol.section->output_section->vma
	     + symbol->symbol.section->output_offset);
#endif
	  count++;
	}
      symbol->done_lineno = TRUE;

      if (! bfd_is_const_section (symbol->symbol.section->output_section))
	symbol->symbol.section->output_section->moving_line_filepos +=
	  count * bfd_coff_linesz (abfd);
    }

  return coff_write_symbol (abfd, &(symbol->symbol), native, written,
			    string_size_p, debug_string_section_p,
			    debug_string_size_p);
}

/* Write out the COFF symbols.  */

bfd_boolean
coff_write_symbols (abfd)
     bfd *abfd;
{
  bfd_size_type string_size;
  asection *debug_string_section;
  bfd_size_type debug_string_size;
  unsigned int i;
  unsigned int limit = bfd_get_symcount (abfd);
  bfd_signed_vma written = 0;
  asymbol **p;

  string_size = 0;
  debug_string_section = NULL;
  debug_string_size = 0;

  /* If this target supports long section names, they must be put into
     the string table.  This is supported by PE.  This code must
     handle section names just as they are handled in
     coff_write_object_contents.  */
  if (bfd_coff_long_section_names (abfd))
    {
      asection *o;

      for (o = abfd->sections; o != NULL; o = o->next)
	{
	  size_t len;

	  len = strlen (o->name);
	  if (len > SCNNMLEN)
	    string_size += len + 1;
	}
    }

  /* Seek to the right place */
  if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0)
    return FALSE;

  /* Output all the symbols we have */

  written = 0;
  for (p = abfd->outsymbols, i = 0; i < limit; i++, p++)
    {
      asymbol *symbol = *p;
      coff_symbol_type *c_symbol = coff_symbol_from (abfd, symbol);

      if (c_symbol == (coff_symbol_type *) NULL
	  || c_symbol->native == (combined_entry_type *) NULL)
	{
	  if (!coff_write_alien_symbol (abfd, symbol, &written, &string_size,
					&debug_string_section,
					&debug_string_size))
	    return FALSE;
	}
      else
	{
	  if (!coff_write_native_symbol (abfd, c_symbol, &written,
					 &string_size, &debug_string_section,
					 &debug_string_size))
	    return FALSE;
	}
    }

  obj_raw_syment_count (abfd) = written;

  /* Now write out strings */

  if (string_size != 0)
    {
      unsigned int size = string_size + STRING_SIZE_SIZE;
      bfd_byte buffer[STRING_SIZE_SIZE];

#if STRING_SIZE_SIZE == 4
      H_PUT_32 (abfd, size, buffer);
#else
 #error Change H_PUT_32
#endif
      if (bfd_bwrite ((PTR) buffer, (bfd_size_type) sizeof (buffer), abfd)
	  != sizeof (buffer))
	return FALSE;

      /* Handle long section names.  This code must handle section
	 names just as they are handled in coff_write_object_contents.  */
      if (bfd_coff_long_section_names (abfd))
	{
	  asection *o;

	  for (o = abfd->sections; o != NULL; o = o->next)
	    {
	      size_t len;

	      len = strlen (o->name);
	      if (len > SCNNMLEN)
		{
		  if (bfd_bwrite (o->name, (bfd_size_type) (len + 1), abfd)
		      != len + 1)
		    return FALSE;
		}
	    }
	}

      for (p = abfd->outsymbols, i = 0;
	   i < limit;
	   i++, p++)
	{
	  asymbol *q = *p;
	  size_t name_length = strlen (q->name);
	  coff_symbol_type *c_symbol = coff_symbol_from (abfd, q);
	  size_t maxlen;

	  /* Figure out whether the symbol name should go in the string
	     table.  Symbol names that are short enough are stored
	     directly in the syment structure.  File names permit a
	     different, longer, length in the syment structure.  On
	     XCOFF, some symbol names are stored in the .debug section
	     rather than in the string table.  */

	  if (c_symbol == NULL
	      || c_symbol->native == NULL)
	    {
	      /* This is not a COFF symbol, so it certainly is not a
	         file name, nor does it go in the .debug section.  */
	      maxlen = bfd_coff_force_symnames_in_strings (abfd) ? 0 : SYMNMLEN;
	    }
	  else if (bfd_coff_symname_in_debug (abfd,
					      &c_symbol->native->u.syment))
	    {
	      /* This symbol name is in the XCOFF .debug section.
	         Don't write it into the string table.  */
	      maxlen = name_length;
	    }
	  else if (c_symbol->native->u.syment.n_sclass == C_FILE
		   && c_symbol->native->u.syment.n_numaux > 0)
	    {
	      if (bfd_coff_force_symnames_in_strings (abfd))
		{
		  if (bfd_bwrite (".file", (bfd_size_type) 6, abfd) != 6)
		    return FALSE;
		}
	      maxlen = bfd_coff_filnmlen (abfd);
	    }
	  else
	    maxlen = bfd_coff_force_symnames_in_strings (abfd) ? 0 : SYMNMLEN;

	  if (name_length > maxlen)
	    {
	      if (bfd_bwrite ((PTR) (q->name), (bfd_size_type) name_length + 1,
			     abfd) != name_length + 1)
		return FALSE;
	    }
	}
    }
  else
    {
      /* We would normally not write anything here, but we'll write
         out 4 so that any stupid coff reader which tries to read the
         string table even when there isn't one won't croak.  */
      unsigned int size = STRING_SIZE_SIZE;
      bfd_byte buffer[STRING_SIZE_SIZE];

#if STRING_SIZE_SIZE == 4
      H_PUT_32 (abfd, size, buffer);
#else
 #error Change H_PUT_32
#endif
      if (bfd_bwrite ((PTR) buffer, (bfd_size_type) STRING_SIZE_SIZE, abfd)
	  != STRING_SIZE_SIZE)
	return FALSE;
    }

  /* Make sure the .debug section was created to be the correct size.
     We should create it ourselves on the fly, but we don't because
     BFD won't let us write to any section until we know how large all
     the sections are.  We could still do it by making another pass
     over the symbols.  FIXME.  */
  BFD_ASSERT (debug_string_size == 0
	      || (debug_string_section != (asection *) NULL
		  && (BFD_ALIGN (debug_string_size,
				 1 << debug_string_section->alignment_power)
		      == bfd_section_size (abfd, debug_string_section))));

  return TRUE;
}

bfd_boolean
coff_write_linenumbers (abfd)
     bfd *abfd;
{
  asection *s;
  bfd_size_type linesz;
  PTR buff;

  linesz = bfd_coff_linesz (abfd);
  buff = bfd_alloc (abfd, linesz);
  if (!buff)
    return FALSE;
  for (s = abfd->sections; s != (asection *) NULL; s = s->next)
    {
      if (s->lineno_count)
	{
	  asymbol **q = abfd->outsymbols;
	  if (bfd_seek (abfd, s->line_filepos, SEEK_SET) != 0)
	    return FALSE;
	  /* Find all the linenumbers in this section */
	  while (*q)
	    {
	      asymbol *p = *q;
	      if (p->section->output_section == s)
		{
		  alent *l =
		  BFD_SEND (bfd_asymbol_bfd (p), _get_lineno,
			    (bfd_asymbol_bfd (p), p));
		  if (l)
		    {
		      /* Found a linenumber entry, output */
		      struct internal_lineno out;
		      memset ((PTR) & out, 0, sizeof (out));
		      out.l_lnno = 0;
		      out.l_addr.l_symndx = l->u.offset;
		      bfd_coff_swap_lineno_out (abfd, &out, buff);
		      if (bfd_bwrite (buff, (bfd_size_type) linesz, abfd)
			  != linesz)
			return FALSE;
		      l++;
		      while (l->line_number)
			{
			  out.l_lnno = l->line_number;
			  out.l_addr.l_symndx = l->u.offset;
			  bfd_coff_swap_lineno_out (abfd, &out, buff);
			  if (bfd_bwrite (buff, (bfd_size_type) linesz, abfd)
			      != linesz)
			    return FALSE;
			  l++;
			}
		    }
		}
	      q++;
	    }
	}
    }
  bfd_release (abfd, buff);
  return TRUE;
}

alent *
coff_get_lineno (ignore_abfd, symbol)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *symbol;
{
  return coffsymbol (symbol)->lineno;
}

#if 0

/* This is only called from coff_add_missing_symbols, which has been
   disabled.  */

asymbol *
coff_section_symbol (abfd, name)
     bfd *abfd;
     char *name;
{
  asection *sec = bfd_make_section_old_way (abfd, name);
  asymbol *sym;
  combined_entry_type *csym;

  sym = sec->symbol;
  csym = coff_symbol_from (abfd, sym)->native;
  /* Make sure back-end COFF stuff is there.  */
  if (csym == 0)
    {
      struct foo
	{
	  coff_symbol_type sym;
	  /* @@@@FIXME This shouldn't use a fixed size!!  */
	  combined_entry_type e[10];
	};
      struct foo *f;

      f = (struct foo *) bfd_zalloc (abfd, (bfd_size_type) sizeof (*f));
      if (!f)
	{
	  bfd_set_error (bfd_error_no_error);
	  return NULL;
	}
      coff_symbol_from (abfd, sym)->native = csym = f->e;
    }
  csym[0].u.syment.n_sclass = C_STAT;
  csym[0].u.syment.n_numaux = 1;
/*  SF_SET_STATICS (sym);       @@@@ ??? */
  csym[1].u.auxent.x_scn.x_scnlen = sec->_raw_size;
  csym[1].u.auxent.x_scn.x_nreloc = sec->reloc_count;
  csym[1].u.auxent.x_scn.x_nlinno = sec->lineno_count;

  if (sec->output_section == NULL)
    {
      sec->output_section = sec;
      sec->output_offset = 0;
    }

  return sym;
}

#endif /* 0 */

/* This function transforms the offsets into the symbol table into
   pointers to syments.  */

static void
coff_pointerize_aux (abfd, table_base, symbol, indaux, auxent)
     bfd *abfd;
     combined_entry_type *table_base;
     combined_entry_type *symbol;
     unsigned int indaux;
     combined_entry_type *auxent;
{
  unsigned int type = symbol->u.syment.n_type;
  unsigned int class = symbol->u.syment.n_sclass;

  if (coff_backend_info (abfd)->_bfd_coff_pointerize_aux_hook)
    {
      if ((*coff_backend_info (abfd)->_bfd_coff_pointerize_aux_hook)
	  (abfd, table_base, symbol, indaux, auxent))
	return;
    }

  /* Don't bother if this is a file or a section */
  if (class == C_STAT && type == T_NULL)
    return;
  if (class == C_FILE)
    return;

  /* Otherwise patch up */
#define N_TMASK coff_data (abfd)->local_n_tmask
#define N_BTSHFT coff_data (abfd)->local_n_btshft
  if ((ISFCN (type) || ISTAG (class) || class == C_BLOCK || class == C_FCN)
      && auxent->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.l > 0)
    {
      auxent->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.p =
	table_base + auxent->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.l;
      auxent->fix_end = 1;
    }
  /* A negative tagndx is meaningless, but the SCO 3.2v4 cc can
     generate one, so we must be careful to ignore it.  */
  if (auxent->u.auxent.x_sym.x_tagndx.l > 0)
    {
      auxent->u.auxent.x_sym.x_tagndx.p =
	table_base + auxent->u.auxent.x_sym.x_tagndx.l;
      auxent->fix_tag = 1;
    }
}

/* Allocate space for the ".debug" section, and read it.
   We did not read the debug section until now, because
   we didn't want to go to the trouble until someone needed it.  */

static char *
build_debug_section (abfd)
     bfd *abfd;
{
  char *debug_section;
  file_ptr position;
  bfd_size_type sec_size;

  asection *sect = bfd_get_section_by_name (abfd, ".debug");

  if (!sect)
    {
      bfd_set_error (bfd_error_no_debug_section);
      return NULL;
    }

  sec_size = bfd_get_section_size_before_reloc (sect);
  debug_section = (PTR) bfd_alloc (abfd, sec_size);
  if (debug_section == NULL)
    return NULL;

  /* Seek to the beginning of the `.debug' section and read it.
     Save the current position first; it is needed by our caller.
     Then read debug section and reset the file pointer.  */

  position = bfd_tell (abfd);
  if (bfd_seek (abfd, sect->filepos, SEEK_SET) != 0
      || bfd_bread (debug_section, sec_size, abfd) != sec_size
      || bfd_seek (abfd, position, SEEK_SET) != 0)
    return NULL;
  return debug_section;
}

/* Return a pointer to a malloc'd copy of 'name'.  'name' may not be
   \0-terminated, but will not exceed 'maxlen' characters.  The copy *will*
   be \0-terminated.  */
static char *
copy_name (abfd, name, maxlen)
     bfd *abfd;
     char *name;
     size_t maxlen;
{
  size_t len;
  char *newname;

  for (len = 0; len < maxlen; ++len)
    {
      if (name[len] == '\0')
	{
	  break;
	}
    }

  if ((newname = (PTR) bfd_alloc (abfd, (bfd_size_type) len + 1)) == NULL)
    return (NULL);
  strncpy (newname, name, len);
  newname[len] = '\0';
  return newname;
}

/* Read in the external symbols.  */

bfd_boolean
_bfd_coff_get_external_symbols (abfd)
     bfd *abfd;
{
  bfd_size_type symesz;
  bfd_size_type size;
  PTR syms;

  if (obj_coff_external_syms (abfd) != NULL)
    return TRUE;

  symesz = bfd_coff_symesz (abfd);

  size = obj_raw_syment_count (abfd) * symesz;

  syms = (PTR) bfd_malloc (size);
  if (syms == NULL && size != 0)
    return FALSE;

  if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0
      || bfd_bread (syms, size, abfd) != size)
    {
      if (syms != NULL)
	free (syms);
      return FALSE;
    }

  obj_coff_external_syms (abfd) = syms;

  return TRUE;
}

/* Read in the external strings.  The strings are not loaded until
   they are needed.  This is because we have no simple way of
   detecting a missing string table in an archive.  */

const char *
_bfd_coff_read_string_table (abfd)
     bfd *abfd;
{
  char extstrsize[STRING_SIZE_SIZE];
  bfd_size_type strsize;
  char *strings;
  file_ptr pos;

  if (obj_coff_strings (abfd) != NULL)
    return obj_coff_strings (abfd);

  if (obj_sym_filepos (abfd) == 0)
    {
      bfd_set_error (bfd_error_no_symbols);
      return NULL;
    }

  pos = obj_sym_filepos (abfd);
  pos += obj_raw_syment_count (abfd) * bfd_coff_symesz (abfd);
  if (bfd_seek (abfd, pos, SEEK_SET) != 0)
    return NULL;

  if (bfd_bread (extstrsize, (bfd_size_type) sizeof extstrsize, abfd)
      != sizeof extstrsize)
    {
      if (bfd_get_error () != bfd_error_file_truncated)
	return NULL;

      /* There is no string table.  */
      strsize = STRING_SIZE_SIZE;
    }
  else
    {
#if STRING_SIZE_SIZE == 4
      strsize = H_GET_32 (abfd, extstrsize);
#else
 #error Change H_GET_32
#endif
    }

  if (strsize < STRING_SIZE_SIZE)
    {
      (*_bfd_error_handler)
	(_("%s: bad string table size %lu"), bfd_archive_filename (abfd),
	 (unsigned long) strsize);
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }

  strings = (char *) bfd_malloc (strsize);
  if (strings == NULL)
    return NULL;

  if (bfd_bread (strings + STRING_SIZE_SIZE, strsize - STRING_SIZE_SIZE, abfd)
      != strsize - STRING_SIZE_SIZE)
    {
      free (strings);
      return NULL;
    }

  obj_coff_strings (abfd) = strings;

  return strings;
}

/* Free up the external symbols and strings read from a COFF file.  */

bfd_boolean
_bfd_coff_free_symbols (abfd)
     bfd *abfd;
{
  if (obj_coff_external_syms (abfd) != NULL
      && ! obj_coff_keep_syms (abfd))
    {
      free (obj_coff_external_syms (abfd));
      obj_coff_external_syms (abfd) = NULL;
    }
  if (obj_coff_strings (abfd) != NULL
      && ! obj_coff_keep_strings (abfd))
    {
      free (obj_coff_strings (abfd));
      obj_coff_strings (abfd) = NULL;
    }
  return TRUE;
}

/* Read a symbol table into freshly bfd_allocated memory, swap it, and
   knit the symbol names into a normalized form.  By normalized here I
   mean that all symbols have an n_offset pointer that points to a null-
   terminated string.  */

combined_entry_type *
coff_get_normalized_symtab (abfd)
     bfd *abfd;
{
  combined_entry_type *internal;
  combined_entry_type *internal_ptr;
  combined_entry_type *symbol_ptr;
  combined_entry_type *internal_end;
  size_t symesz;
  char *raw_src;
  char *raw_end;
  const char *string_table = NULL;
  char *debug_section = NULL;
  bfd_size_type size;

  if (obj_raw_syments (abfd) != NULL)
    return obj_raw_syments (abfd);

  size = obj_raw_syment_count (abfd) * sizeof (combined_entry_type);
  internal = (combined_entry_type *) bfd_zalloc (abfd, size);
  if (internal == NULL && size != 0)
    return NULL;
  internal_end = internal + obj_raw_syment_count (abfd);

  if (! _bfd_coff_get_external_symbols (abfd))
    return NULL;

  raw_src = (char *) obj_coff_external_syms (abfd);

  /* mark the end of the symbols */
  symesz = bfd_coff_symesz (abfd);
  raw_end = (char *) raw_src + obj_raw_syment_count (abfd) * symesz;

  /* FIXME SOMEDAY.  A string table size of zero is very weird, but
     probably possible.  If one shows up, it will probably kill us.  */

  /* Swap all the raw entries */
  for (internal_ptr = internal;
       raw_src < raw_end;
       raw_src += symesz, internal_ptr++)
    {

      unsigned int i;
      bfd_coff_swap_sym_in (abfd, (PTR) raw_src,
			    (PTR) & internal_ptr->u.syment);
      symbol_ptr = internal_ptr;

      for (i = 0;
	   i < symbol_ptr->u.syment.n_numaux;
	   i++)
	{
	  internal_ptr++;
	  raw_src += symesz;
	  bfd_coff_swap_aux_in (abfd, (PTR) raw_src,
				symbol_ptr->u.syment.n_type,
				symbol_ptr->u.syment.n_sclass,
				(int) i, symbol_ptr->u.syment.n_numaux,
				&(internal_ptr->u.auxent));
	  coff_pointerize_aux (abfd, internal, symbol_ptr, i,
			       internal_ptr);
	}
    }

  /* Free the raw symbols, but not the strings (if we have them).  */
  obj_coff_keep_strings (abfd) = TRUE;
  if (! _bfd_coff_free_symbols (abfd))
    return NULL;

  for (internal_ptr = internal; internal_ptr < internal_end;
       internal_ptr++)
    {
      if (internal_ptr->u.syment.n_sclass == C_FILE
	  && internal_ptr->u.syment.n_numaux > 0)
	{
	  /* make a file symbol point to the name in the auxent, since
	     the text ".file" is redundant */
	  if ((internal_ptr + 1)->u.auxent.x_file.x_n.x_zeroes == 0)
	    {
	      /* the filename is a long one, point into the string table */
	      if (string_table == NULL)
		{
		  string_table = _bfd_coff_read_string_table (abfd);
		  if (string_table == NULL)
		    return NULL;
		}

	      internal_ptr->u.syment._n._n_n._n_offset =
		((long)
		 (string_table
		  + (internal_ptr + 1)->u.auxent.x_file.x_n.x_offset));
	    }
	  else
	    {
	      /* Ordinary short filename, put into memory anyway.  The
                 Microsoft PE tools sometimes store a filename in
                 multiple AUX entries.  */
	      if (internal_ptr->u.syment.n_numaux > 1
		  && coff_data (abfd)->pe)
		{
		  internal_ptr->u.syment._n._n_n._n_offset =
		    ((long)
		     copy_name (abfd,
				(internal_ptr + 1)->u.auxent.x_file.x_fname,
				internal_ptr->u.syment.n_numaux * symesz));
		}
	      else
		{
		  internal_ptr->u.syment._n._n_n._n_offset =
		    ((long)
		     copy_name (abfd,
				(internal_ptr + 1)->u.auxent.x_file.x_fname,
				(size_t) bfd_coff_filnmlen (abfd)));
		}
	    }
	}
      else
	{
	  if (internal_ptr->u.syment._n._n_n._n_zeroes != 0)
	    {
	      /* This is a "short" name.  Make it long.  */
	      size_t i;
	      char *newstring;

	      /* find the length of this string without walking into memory
	         that isn't ours.  */
	      for (i = 0; i < 8; ++i)
		if (internal_ptr->u.syment._n._n_name[i] == '\0')
		  break;

	      newstring = (PTR) bfd_zalloc (abfd, (bfd_size_type) (i + 1));
	      if (newstring == NULL)
		return (NULL);
	      strncpy (newstring, internal_ptr->u.syment._n._n_name, i);
	      internal_ptr->u.syment._n._n_n._n_offset = (long int) newstring;
	      internal_ptr->u.syment._n._n_n._n_zeroes = 0;
	    }
	  else if (internal_ptr->u.syment._n._n_n._n_offset == 0)
	    internal_ptr->u.syment._n._n_n._n_offset = (long int) "";
	  else if (!bfd_coff_symname_in_debug (abfd, &internal_ptr->u.syment))
	    {
	      /* Long name already.  Point symbol at the string in the
                 table.  */
	      if (string_table == NULL)
		{
		  string_table = _bfd_coff_read_string_table (abfd);
		  if (string_table == NULL)
		    return NULL;
		}
	      internal_ptr->u.syment._n._n_n._n_offset =
		((long int)
		 (string_table
		  + internal_ptr->u.syment._n._n_n._n_offset));
	    }
	  else
	    {
	      /* Long name in debug section.  Very similar.  */
	      if (debug_section == NULL)
		debug_section = build_debug_section (abfd);
	      internal_ptr->u.syment._n._n_n._n_offset = (long int)
		(debug_section + internal_ptr->u.syment._n._n_n._n_offset);
	    }
	}
      internal_ptr += internal_ptr->u.syment.n_numaux;
    }

  obj_raw_syments (abfd) = internal;
  BFD_ASSERT (obj_raw_syment_count (abfd)
	      == (unsigned int) (internal_ptr - internal));

  return (internal);
}				/* coff_get_normalized_symtab() */

long
coff_get_reloc_upper_bound (abfd, asect)
     bfd *abfd;
     sec_ptr asect;
{
  if (bfd_get_format (abfd) != bfd_object)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }
  return (asect->reloc_count + 1) * sizeof (arelent *);
}

asymbol *
coff_make_empty_symbol (abfd)
     bfd *abfd;
{
  bfd_size_type amt = sizeof (coff_symbol_type);
  coff_symbol_type *new = (coff_symbol_type *) bfd_zalloc (abfd, amt);
  if (new == NULL)
    return (NULL);
  new->symbol.section = 0;
  new->native = 0;
  new->lineno = (alent *) NULL;
  new->done_lineno = FALSE;
  new->symbol.the_bfd = abfd;
  return &new->symbol;
}

/* Make a debugging symbol.  */

asymbol *
coff_bfd_make_debug_symbol (abfd, ptr, sz)
     bfd *abfd;
     PTR ptr ATTRIBUTE_UNUSED;
     unsigned long sz ATTRIBUTE_UNUSED;
{
  bfd_size_type amt = sizeof (coff_symbol_type);
  coff_symbol_type *new = (coff_symbol_type *) bfd_alloc (abfd, amt);
  if (new == NULL)
    return (NULL);
  /* @@@@ The 10 is a guess at a plausible maximum number of aux entries
     (but shouldn't be a constant).  */
  amt = sizeof (combined_entry_type) * 10;
  new->native = (combined_entry_type *) bfd_zalloc (abfd, amt);
  if (!new->native)
    return (NULL);
  new->symbol.section = bfd_abs_section_ptr;
  new->symbol.flags = BSF_DEBUGGING;
  new->lineno = (alent *) NULL;
  new->done_lineno = FALSE;
  new->symbol.the_bfd = abfd;
  return &new->symbol;
}

void
coff_get_symbol_info (abfd, symbol, ret)
     bfd *abfd;
     asymbol *symbol;
     symbol_info *ret;
{
  bfd_symbol_info (symbol, ret);
  if (coffsymbol (symbol)->native != NULL
      && coffsymbol (symbol)->native->fix_value)
    {
      ret->value = coffsymbol (symbol)->native->u.syment.n_value -
	(unsigned long) obj_raw_syments (abfd);
    }
}

/* Return the COFF syment for a symbol.  */

bfd_boolean
bfd_coff_get_syment (abfd, symbol, psyment)
     bfd *abfd;
     asymbol *symbol;
     struct internal_syment *psyment;
{
  coff_symbol_type *csym;

  csym = coff_symbol_from (abfd, symbol);
  if (csym == NULL || csym->native == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  *psyment = csym->native->u.syment;

  if (csym->native->fix_value)
    psyment->n_value = psyment->n_value -
      (unsigned long) obj_raw_syments (abfd);

  /* FIXME: We should handle fix_line here.  */

  return TRUE;
}

/* Return the COFF auxent for a symbol.  */

bfd_boolean
bfd_coff_get_auxent (abfd, symbol, indx, pauxent)
     bfd *abfd;
     asymbol *symbol;
     int indx;
     union internal_auxent *pauxent;
{
  coff_symbol_type *csym;
  combined_entry_type *ent;

  csym = coff_symbol_from (abfd, symbol);

  if (csym == NULL
      || csym->native == NULL
      || indx >= csym->native->u.syment.n_numaux)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  ent = csym->native + indx + 1;

  *pauxent = ent->u.auxent;

  if (ent->fix_tag)
    pauxent->x_sym.x_tagndx.l =
      ((combined_entry_type *) pauxent->x_sym.x_tagndx.p
       - obj_raw_syments (abfd));

  if (ent->fix_end)
    pauxent->x_sym.x_fcnary.x_fcn.x_endndx.l =
      ((combined_entry_type *) pauxent->x_sym.x_fcnary.x_fcn.x_endndx.p
       - obj_raw_syments (abfd));

  if (ent->fix_scnlen)
    pauxent->x_csect.x_scnlen.l =
      ((combined_entry_type *) pauxent->x_csect.x_scnlen.p
       - obj_raw_syments (abfd));

  return TRUE;
}

/* Print out information about COFF symbol.  */

void
coff_print_symbol (abfd, filep, symbol, how)
     bfd *abfd;
     PTR filep;
     asymbol *symbol;
     bfd_print_symbol_type how;
{
  FILE *file = (FILE *) filep;

  switch (how)
    {
    case bfd_print_symbol_name:
      fprintf (file, "%s", symbol->name);
      break;

    case bfd_print_symbol_more:
      fprintf (file, "coff %s %s",
	       coffsymbol (symbol)->native ? "n" : "g",
	       coffsymbol (symbol)->lineno ? "l" : " ");
      break;

    case bfd_print_symbol_all:
      if (coffsymbol (symbol)->native)
	{
	  bfd_vma val;
	  unsigned int aux;
	  combined_entry_type *combined = coffsymbol (symbol)->native;
	  combined_entry_type *root = obj_raw_syments (abfd);
	  struct lineno_cache_entry *l = coffsymbol (symbol)->lineno;

	  fprintf (file, "[%3ld]", (long) (combined - root));

	  if (! combined->fix_value)
	    val = (bfd_vma) combined->u.syment.n_value;
	  else
	    val = combined->u.syment.n_value - (unsigned long) root;

#ifndef XCOFF64
	  fprintf (file,
		   "(sec %2d)(fl 0x%02x)(ty %3x)(scl %3d) (nx %d) 0x%08lx %s",
		   combined->u.syment.n_scnum,
		   combined->u.syment.n_flags,
		   combined->u.syment.n_type,
		   combined->u.syment.n_sclass,
		   combined->u.syment.n_numaux,
		   (unsigned long) val,
		   symbol->name);
#else
	  /* Print out the wide, 64 bit, symbol value */
	  fprintf (file,
		   "(sec %2d)(fl 0x%02x)(ty %3x)(scl %3d) (nx %d) 0x%016llx %s",
		   combined->u.syment.n_scnum,
		   combined->u.syment.n_flags,
		   combined->u.syment.n_type,
		   combined->u.syment.n_sclass,
		   combined->u.syment.n_numaux,
		   val,
		   symbol->name);
#endif

	  for (aux = 0; aux < combined->u.syment.n_numaux; aux++)
	    {
	      combined_entry_type *auxp = combined + aux + 1;
	      long tagndx;

	      if (auxp->fix_tag)
		tagndx = auxp->u.auxent.x_sym.x_tagndx.p - root;
	      else
		tagndx = auxp->u.auxent.x_sym.x_tagndx.l;

	      fprintf (file, "\n");

	      if (bfd_coff_print_aux (abfd, file, root, combined, auxp, aux))
		continue;

	      switch (combined->u.syment.n_sclass)
		{
		case C_FILE:
		  fprintf (file, "File ");
		  break;

		case C_STAT:
		  if (combined->u.syment.n_type == T_NULL)
		    /* probably a section symbol? */
		    {
		      fprintf (file, "AUX scnlen 0x%lx nreloc %d nlnno %d",
			       (long) auxp->u.auxent.x_scn.x_scnlen,
			       auxp->u.auxent.x_scn.x_nreloc,
			       auxp->u.auxent.x_scn.x_nlinno);
		      if (auxp->u.auxent.x_scn.x_checksum != 0
			  || auxp->u.auxent.x_scn.x_associated != 0
			  || auxp->u.auxent.x_scn.x_comdat != 0)
			fprintf (file, " checksum 0x%lx assoc %d comdat %d",
				 auxp->u.auxent.x_scn.x_checksum,
				 auxp->u.auxent.x_scn.x_associated,
				 auxp->u.auxent.x_scn.x_comdat);
		      break;
		    }
		    /* else fall through */
		case C_EXT:
		  if (ISFCN (combined->u.syment.n_type))
		    {
		      long next, llnos;

		      if (auxp->fix_end)
			next = (auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.p
			       - root);
		      else
			next = auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.l;
		      llnos = auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_lnnoptr;
		      fprintf (file,
			       "AUX tagndx %ld ttlsiz 0x%lx lnnos %ld next %ld",
			       tagndx, auxp->u.auxent.x_sym.x_misc.x_fsize,
			       llnos, next);
		      break;
		    }
		  /* else fall through */
		default:
		  fprintf (file, "AUX lnno %d size 0x%x tagndx %ld",
			   auxp->u.auxent.x_sym.x_misc.x_lnsz.x_lnno,
			   auxp->u.auxent.x_sym.x_misc.x_lnsz.x_size,
			   tagndx);
		  if (auxp->fix_end)
		    fprintf (file, " endndx %ld",
			     ((long)
			      (auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.p
			       - root)));
		  break;
		}
	    }

	  if (l)
	    {
	      fprintf (file, "\n%s :", l->u.sym->name);
	      l++;
	      while (l->line_number)
		{
		  fprintf (file, "\n%4d : 0x%lx",
			   l->line_number,
			   ((unsigned long)
			    (l->u.offset + symbol->section->vma)));
		  l++;
		}
	    }
	}
      else
	{
	  bfd_print_symbol_vandf (abfd, (PTR) file, symbol);
	  fprintf (file, " %-5s %s %s %s",
		   symbol->section->name,
		   coffsymbol (symbol)->native ? "n" : "g",
		   coffsymbol (symbol)->lineno ? "l" : " ",
		   symbol->name);
	}
    }
}

/* Return whether a symbol name implies a local symbol.  In COFF,
   local symbols generally start with ``.L''.  Most targets use this
   function for the is_local_label_name entry point, but some may
   override it.  */

bfd_boolean
_bfd_coff_is_local_label_name (abfd, name)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name;
{
  return name[0] == '.' && name[1] == 'L';
}

/* Provided a BFD, a section and an offset (in bytes, not octets) into the
   section, calculate and return the name of the source file and the line
   nearest to the wanted location.  */

bfd_boolean
coff_find_nearest_line (abfd, section, symbols, offset, filename_ptr,
			functionname_ptr, line_ptr)
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *line_ptr;
{
  bfd_boolean found;
  unsigned int i;
  unsigned int line_base;
  coff_data_type *cof = coff_data (abfd);
  /* Run through the raw syments if available */
  combined_entry_type *p;
  combined_entry_type *pend;
  alent *l;
  struct coff_section_tdata *sec_data;
  bfd_size_type amt;

  /* Before looking through the symbol table, try to use a .stab
     section to find the information.  */
  if (! _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,
					     &found, filename_ptr,
					     functionname_ptr, line_ptr,
					     &coff_data(abfd)->line_info))
    return FALSE;

  if (found)
    return TRUE;

  /* Also try examining DWARF2 debugging information.  */
  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, 0,
				     &coff_data(abfd)->dwarf2_find_line_info))
    return TRUE;

  *filename_ptr = 0;
  *functionname_ptr = 0;
  *line_ptr = 0;

  /* Don't try and find line numbers in a non coff file */
  if (!bfd_family_coff (abfd))
    return FALSE;

  if (cof == NULL)
    return FALSE;

  /* Find the first C_FILE symbol.  */
  p = cof->raw_syments;
  if (!p)
    return FALSE;

  pend = p + cof->raw_syment_count;
  while (p < pend)
    {
      if (p->u.syment.n_sclass == C_FILE)
	break;
      p += 1 + p->u.syment.n_numaux;
    }

  if (p < pend)
    {
      bfd_vma sec_vma;
      bfd_vma maxdiff;

      /* Look through the C_FILE symbols to find the best one.  */
      sec_vma = bfd_get_section_vma (abfd, section);
      *filename_ptr = (char *) p->u.syment._n._n_n._n_offset;
      maxdiff = (bfd_vma) 0 - (bfd_vma) 1;
      while (1)
	{
	  combined_entry_type *p2;

	  for (p2 = p + 1 + p->u.syment.n_numaux;
	       p2 < pend;
	       p2 += 1 + p2->u.syment.n_numaux)
	    {
	      if (p2->u.syment.n_scnum > 0
		  && (section
		      == coff_section_from_bfd_index (abfd,
						      p2->u.syment.n_scnum)))
		break;
	      if (p2->u.syment.n_sclass == C_FILE)
		{
		  p2 = pend;
		  break;
		}
	    }

	  /* We use <= MAXDIFF here so that if we get a zero length
             file, we actually use the next file entry.  */
	  if (p2 < pend
	      && offset + sec_vma >= (bfd_vma) p2->u.syment.n_value
	      && offset + sec_vma - (bfd_vma) p2->u.syment.n_value <= maxdiff)
	    {
	      *filename_ptr = (char *) p->u.syment._n._n_n._n_offset;
	      maxdiff = offset + sec_vma - p2->u.syment.n_value;
	    }

	  /* Avoid endless loops on erroneous files by ensuring that
	     we always move forward in the file.  */
	  if (p >= cof->raw_syments + p->u.syment.n_value)
	    break;

	  p = cof->raw_syments + p->u.syment.n_value;
	  if (p > pend || p->u.syment.n_sclass != C_FILE)
	    break;
	}
    }

  /* Now wander though the raw linenumbers of the section */
  /* If we have been called on this section before, and the offset we
     want is further down then we can prime the lookup loop.  */
  sec_data = coff_section_data (abfd, section);
  if (sec_data != NULL
      && sec_data->i > 0
      && offset >= sec_data->offset)
    {
      i = sec_data->i;
      *functionname_ptr = sec_data->function;
      line_base = sec_data->line_base;
    }
  else
    {
      i = 0;
      line_base = 0;
    }

  if (section->lineno != NULL)
    {
      bfd_vma last_value = 0;

      l = &section->lineno[i];

      for (; i < section->lineno_count; i++)
	{
	  if (l->line_number == 0)
	    {
	      /* Get the symbol this line number points at */
	      coff_symbol_type *coff = (coff_symbol_type *) (l->u.sym);
	      if (coff->symbol.value > offset)
		break;
	      *functionname_ptr = coff->symbol.name;
	      last_value = coff->symbol.value;
	      if (coff->native)
		{
		  combined_entry_type *s = coff->native;
		  s = s + 1 + s->u.syment.n_numaux;

		  /* In XCOFF a debugging symbol can follow the
		     function symbol.  */
		  if (s->u.syment.n_scnum == N_DEBUG)
		    s = s + 1 + s->u.syment.n_numaux;

		  /* S should now point to the .bf of the function.  */
		  if (s->u.syment.n_numaux)
		    {
		      /* The linenumber is stored in the auxent.  */
		      union internal_auxent *a = &((s + 1)->u.auxent);
		      line_base = a->x_sym.x_misc.x_lnsz.x_lnno;
		      *line_ptr = line_base;
		    }
		}
	    }
	  else
	    {
	      if (l->u.offset > offset)
		break;
	      *line_ptr = l->line_number + line_base - 1;
	    }
	  l++;
	}

      /* If we fell off the end of the loop, then assume that this
	 symbol has no line number info.  Otherwise, symbols with no
	 line number info get reported with the line number of the
	 last line of the last symbol which does have line number
	 info.  We use 0x100 as a slop to account for cases where the
	 last line has executable code.  */
      if (i >= section->lineno_count
	  && last_value != 0
	  && offset - last_value > 0x100)
	{
	  *functionname_ptr = NULL;
	  *line_ptr = 0;
	}
    }

  /* Cache the results for the next call.  */
  if (sec_data == NULL && section->owner == abfd)
    {
      amt = sizeof (struct coff_section_tdata);
      section->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
      sec_data = (struct coff_section_tdata *) section->used_by_bfd;
    }
  if (sec_data != NULL)
    {
      sec_data->offset = offset;
      sec_data->i = i;
      sec_data->function = *functionname_ptr;
      sec_data->line_base = line_base;
    }

  return TRUE;
}

int
coff_sizeof_headers (abfd, reloc)
     bfd *abfd;
     bfd_boolean reloc;
{
  size_t size;

  if (! reloc)
    {
      size = bfd_coff_filhsz (abfd) + bfd_coff_aoutsz (abfd);
    }
  else
    {
      size = bfd_coff_filhsz (abfd);
    }

  size += abfd->section_count * bfd_coff_scnhsz (abfd);
  return size;
}

/* Change the class of a coff symbol held by BFD.  */
bfd_boolean
bfd_coff_set_symbol_class (abfd, symbol, class)
     bfd *         abfd;
     asymbol *     symbol;
     unsigned int  class;
{
  coff_symbol_type * csym;

  csym = coff_symbol_from (abfd, symbol);
  if (csym == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }
  else if (csym->native == NULL)
    {
      /* This is an alien symbol which no native coff backend data.
	 We cheat here by creating a fake native entry for it and
	 then filling in the class.  This code is based on that in
	 coff_write_alien_symbol().  */

      combined_entry_type * native;
      bfd_size_type amt = sizeof (* native);

      native = (combined_entry_type *) bfd_zalloc (abfd, amt);
      if (native == NULL)
	return FALSE;

      native->u.syment.n_type   = T_NULL;
      native->u.syment.n_sclass = class;

      if (bfd_is_und_section (symbol->section))
	{
	  native->u.syment.n_scnum = N_UNDEF;
	  native->u.syment.n_value = symbol->value;
	}
      else if (bfd_is_com_section (symbol->section))
	{
	  native->u.syment.n_scnum = N_UNDEF;
	  native->u.syment.n_value = symbol->value;
	}
      else
	{
	  native->u.syment.n_scnum =
	    symbol->section->output_section->target_index;
	  native->u.syment.n_value = (symbol->value
				      + symbol->section->output_offset);
	  if (! obj_pe (abfd))
	    native->u.syment.n_value += symbol->section->output_section->vma;

	  /* Copy the any flags from the file header into the symbol.
	     FIXME: Why?  */
	  native->u.syment.n_flags = bfd_asymbol_bfd (& csym->symbol)->flags;
	}

      csym->native = native;
    }
  else
    {
      csym->native->u.syment.n_sclass = class;
    }

  return TRUE;
}
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2000, 2001, 2002
d332 1
a332 1
  struct sec *answer = abfd->sections;
d368 1
a368 1
coff_get_symtab (abfd, alocation)
@


1.6
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2000, 2001
d49 2
a50 2
static boolean coff_write_symbol
  PARAMS ((bfd *, asymbol *, combined_entry_type *, unsigned int *,
d52 2
a53 2
static boolean coff_write_alien_symbol
  PARAMS ((bfd *, asymbol *, unsigned int *, bfd_size_type *,
d55 2
a56 2
static boolean coff_write_native_symbol
  PARAMS ((bfd *, coff_symbol_type *, unsigned int *, bfd_size_type *,
d61 1
a61 1
static boolean make_a_section_from_file
d71 1
a71 1
  PARAMS ((bfd *, char *, int));
d77 1
a77 1
static boolean
d85 2
d106 1
a106 1
	    return false;
d111 1
a111 1
	  name = bfd_alloc (abfd, strlen (strings) + 1);
d113 1
a113 1
	    return false;
d121 1
a121 1
      name = bfd_alloc (abfd, sizeof (hdr->s_name) + 1);
d123 1
a123 1
	return false;
d130 1
a130 1
    return false;
d147 6
a152 2
  return_section->flags = bfd_coff_styp_to_sec_flags_hook (abfd, hdr, name,
							   return_section);
d164 2
a165 1
  return true;
d181 2
a182 1
  size_t readsize;		/* length of file_info */
d210 1
d213 1
a213 1
    return 0;
d216 1
a216 1
  readsize = nscns * scnhsz;
d221 1
a221 1
  if (bfd_read ((PTR) external_sections, 1, readsize, abfd) != readsize)
d226 1
a226 1
  if (bfd_coff_set_arch_mach_hook (abfd, (PTR) internal_f) == false)
d229 1
a229 1
  /* Now copy data as required; construct all asections etc */
a243 2
  /*  make_abs_section (abfd); */

d248 2
d262 3
a264 3
  unsigned int filhsz;
  unsigned int aoutsz;
  int nscns;
d275 2
a276 2
    return 0;
  if (bfd_read (filehdr, 1, filhsz, abfd) != filhsz)
d280 2
a281 1
      return 0;
d286 10
a295 1
  if (bfd_coff_bad_format_hook (abfd, &internal_f) == false)
d298 1
a298 1
      return 0;
d308 2
a309 2
	return 0;;
      if (bfd_read (opthdr, 1, internal_f.f_opthdr, abfd)
d312 2
a313 1
	  return 0;
d316 1
d424 1
a424 1
   relocs for section SEC in file ABFD.  If CACHE is true and
d429 1
a429 1
   the swapped relocs.  If REQUIRE_INTERNAL is true, then the return
d437 1
a437 1
     boolean cache;
d439 1
a439 1
     boolean require_internal;
d448 1
d462 1
d465 1
a465 1
      free_external = (bfd_byte *) bfd_malloc (sec->reloc_count * relsz);
d472 1
a472 2
      || (bfd_read (external_relocs, relsz, sec->reloc_count, abfd)
	  != relsz * sec->reloc_count))
d477 3
a479 3
      free_internal = ((struct internal_reloc *)
		       bfd_malloc (sec->reloc_count
				   * sizeof (struct internal_reloc)));
d502 2
a503 3
	  sec->used_by_bfd =
	    (PTR) bfd_zalloc (abfd,
			      sizeof (struct coff_section_tdata));
d563 1
a563 4
	      ++q->symbol.section->output_section->lineno_count;
	      ++total;
	      ++l;
	      while (l->line_number != 0)
d565 6
a571 1
		  ++q->symbol.section->output_section->lineno_count;
d574 1
d657 1
a657 1
boolean
d681 1
d683 2
a684 2
    newsyms = (asymbol **) bfd_alloc (bfd_ptr,
				      sizeof (asymbol *) * (symbol_count + 1));
d686 1
a686 1
      return false;
d749 1
a749 1
  return true;
d778 2
a779 1
		((combined_entry_type *) s->u.syment.n_value)->offset;
d897 1
a897 1
	  long filepos;
d910 1
a910 1
	    bfd_put_32 (abfd, name_length + 1, buf);
d912 1
a912 1
	    bfd_put_16 (abfd, name_length + 1, buf);
d922 2
a923 2
					    ((file_ptr) *debug_string_size_p
					     + prefix_len),
d944 1
a944 1
static boolean
d950 1
a950 1
     unsigned int *written;
d989 1
a989 1
    return false;
d991 2
a992 2
  if (bfd_write (buf, 1, symesz, abfd) != symesz)
    return false;
d1003 1
a1003 1
	return false;
d1010 1
a1010 1
				 j,
d1013 2
a1014 2
	  if (bfd_write (buf, 1, auxesz, abfd) != auxesz)
	    return false;
d1023 1
a1023 1
  return true;
d1030 1
a1030 1
static boolean
d1035 1
a1035 1
     unsigned int *written;
d1063 1
a1063 1
      return true;
d1074 1
a1074 1
      /* Copy the any flags from the the file header into the symbol.
d1098 1
a1098 1
static boolean
d1103 1
a1103 1
     unsigned int *written;
d1154 1
a1154 1
      symbol->done_lineno = true;
d1156 3
a1158 2
      symbol->symbol.section->output_section->moving_line_filepos +=
	count * bfd_coff_linesz (abfd);
d1168 1
a1168 1
boolean
d1177 1
a1177 1
  unsigned int written = 0;
d1204 1
a1204 1
    return false;
d1220 1
a1220 1
	    return false;
d1227 1
a1227 1
	    return false;
d1241 1
a1241 1
      bfd_h_put_32 (abfd, size, buffer);
d1243 1
a1243 1
 #error Change bfd_h_put_32
d1245 3
a1247 2
      if (bfd_write ((PTR) buffer, 1, sizeof (buffer), abfd) != sizeof (buffer))
	return false;
d1262 3
a1264 2
		  if (bfd_write (o->name, 1, len + 1, abfd) != len + 1)
		    return false;
d1303 4
a1306 1
      		bfd_write (".file", 1, 6, abfd);
d1314 3
a1316 3
	      if (bfd_write ((PTR) (q->name), 1, name_length + 1, abfd)
		  != name_length + 1)
		return false;
d1329 1
a1329 1
      bfd_h_put_32 (abfd, size, buffer);
d1331 1
a1331 1
 #error Change bfd_h_put_32
d1333 1
a1333 1
      if (bfd_write ((PTR) buffer, 1, STRING_SIZE_SIZE, abfd)
d1335 1
a1335 1
	return false;
d1349 1
a1349 1
  return true;
d1352 1
a1352 1
boolean
d1363 1
a1363 1
    return false;
d1370 1
a1370 1
	    return false;
d1388 3
a1390 2
		      if (bfd_write (buff, 1, linesz, abfd) != linesz)
			return false;
d1397 3
a1399 2
			  if (bfd_write (buff, 1, linesz, abfd) != linesz)
			    return false;
d1409 1
a1409 1
  return true;
d1446 2
a1447 1
      f = (struct foo *) bfd_alloc (abfd, sizeof (*f));
a1452 1
      memset ((char *) f, 0, sizeof (*f));
d1529 2
a1530 1
  long position;
d1540 2
a1541 2
  debug_section = (PTR) bfd_alloc (abfd,
				   bfd_get_section_size_before_reloc (sect));
d1551 1
a1551 3
      || (bfd_read (debug_section,
		    bfd_get_section_size_before_reloc (sect), 1, abfd)
	  != bfd_get_section_size_before_reloc (sect))
d1564 1
a1564 1
     int maxlen;
d1566 1
a1566 1
  int len;
d1577 1
a1577 1
  if ((newname = (PTR) bfd_alloc (abfd, len + 1)) == NULL)
d1586 1
a1586 1
boolean
d1591 1
a1591 1
  size_t size;
d1595 1
a1595 1
    return true;
d1603 1
a1603 1
    return false;
d1606 1
a1606 1
      || bfd_read (syms, size, 1, abfd) != size)
d1610 1
a1610 1
      return false;
d1615 1
a1615 1
  return true;
d1627 1
a1627 1
  size_t strsize;
d1629 1
d1640 3
a1642 4
  if (bfd_seek (abfd,
		(obj_sym_filepos (abfd)
		 + obj_raw_syment_count (abfd) * bfd_coff_symesz (abfd)),
		SEEK_SET) != 0)
d1645 2
a1646 1
  if (bfd_read (extstrsize, sizeof extstrsize, 1, abfd) != sizeof extstrsize)
d1657 1
a1657 1
      strsize = bfd_h_get_32 (abfd, (bfd_byte *) extstrsize);
d1659 1
a1659 1
 #error Change bfd_h_get_32
d1666 1
a1666 1
	(_("%s: bad string table size %lu"), bfd_get_filename (abfd),
d1676 1
a1676 2
  if (bfd_read (strings + STRING_SIZE_SIZE,
		strsize - STRING_SIZE_SIZE, 1, abfd)
d1690 1
a1690 1
boolean
d1706 1
a1706 1
  return true;
d1722 1
a1722 1
  bfd_size_type symesz;
d1727 1
a1727 1
  unsigned long size;
d1770 1
a1770 1
				i, symbol_ptr->u.syment.n_numaux,
d1778 1
a1778 1
  obj_coff_keep_strings (abfd) = true;
d1825 1
a1825 1
				bfd_coff_filnmlen (abfd)));
d1834 2
a1835 2
	      unsigned long i = 0;
	      char *newstring = NULL;
d1840 2
a1841 6
		{
		  if (internal_ptr->u.syment._n._n_name[i] == '\0')
		    {
		      break;
		    }		/* if end of string */
		}		/* possible lengths of this string.  */
d1843 2
a1844 1
	      if ((newstring = (PTR) bfd_alloc (abfd, ++i)) == NULL)
d1846 1
a1846 2
	      memset (newstring, 0, i);
	      strncpy (newstring, internal_ptr->u.syment._n._n_name, i - 1);
d1903 2
a1904 1
  coff_symbol_type *new = (coff_symbol_type *) bfd_alloc (abfd, sizeof (coff_symbol_type));
a1906 1
  memset (new, 0, sizeof *new);
d1910 1
a1910 1
  new->done_lineno = false;
d1923 2
a1924 1
  coff_symbol_type *new = (coff_symbol_type *) bfd_alloc (abfd, sizeof (coff_symbol_type));
d1929 2
a1930 1
  new->native = (combined_entry_type *) bfd_zalloc (abfd, sizeof (combined_entry_type) * 10);
d1936 1
a1936 1
  new->done_lineno = false;
d1951 2
a1952 5
      combined_entry_type *psym;

      psym = ((combined_entry_type *)
	      coffsymbol (symbol)->native->u.syment.n_value);
      ret->value = (bfd_vma) (psym - obj_raw_syments (abfd));
d1958 1
a1958 1
boolean
d1970 1
a1970 1
      return false;
d1976 2
a1977 2
    psyment->n_value = ((combined_entry_type *) psyment->n_value
			- obj_raw_syments (abfd));
d1981 1
a1981 1
  return true;
d1986 1
a1986 1
boolean
d2003 1
a2003 1
      return false;
d2025 1
a2025 1
  return true;
d2054 1
a2054 1
	  unsigned long val;
d2063 1
a2063 1
	    val = (unsigned long) combined->u.syment.n_value;
d2065 1
a2065 3
	    val = ((unsigned long)
		   ((combined_entry_type *) combined->u.syment.n_value
		    - root));
d2067 1
d2075 11
d2088 1
d2132 8
d2141 3
a2143 9
			       _("AUX tagndx %ld ttlsiz 0x%lx lnnos %ld next %ld"),
			       tagndx,
			       auxp->u.auxent.x_sym.x_misc.x_fsize,
			       auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_lnnoptr,
			       (auxp->fix_end
				? ((long)
				   (auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.p
				    - root))
				: auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.l));
d2177 1
a2177 1
	  bfd_print_symbol_vandf ((PTR) file, symbol);
d2192 1
a2192 1
boolean
d2204 1
a2204 1
boolean
d2211 2
a2212 2
     CONST char **filename_ptr;
     CONST char **functionname_ptr;
d2215 1
a2215 1
  boolean found;
d2224 1
d2232 1
a2232 1
    return false;
d2235 1
a2235 1
    return true;
d2242 1
a2242 1
    return true;
d2250 1
a2250 1
    return false;
d2253 1
a2253 1
    return false;
d2258 1
a2258 1
    return false;
d2309 1
a2309 1
	  if (p - cof->raw_syments >= p->u.syment.n_value)
d2399 2
a2400 3
      section->used_by_bfd =
	((PTR) bfd_zalloc (abfd,
			   sizeof (struct coff_section_tdata)));
d2411 1
a2411 1
  return true;
d2417 1
a2417 1
     boolean reloc;
d2421 1
a2421 1
  if (reloc == false)
d2435 1
a2435 1
boolean
d2447 1
a2447 1
      return false;
d2457 1
d2459 1
a2459 1
      native = (combined_entry_type *) bfd_alloc (abfd, sizeof (* native));
d2461 1
a2461 3
	return false;

      memset (native, 0, sizeof (* native));
d2485 1
a2485 1
	  /* Copy the any flags from the the file header into the symbol.
d2497 1
a2497 1
  return true;
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999, 2000
d64 1
a64 1
  PARAMS ((bfd *, unsigned, struct internal_filehdr *, 
d216 1
a216 1
     may depend on arch/mach info. */
a343 1

d528 1
a528 1
      if (bfd_asymbol_flavour (q_maybe) == bfd_target_coff_flavour)
a560 1
/*ARGSUSED*/
d566 1
a566 1
  if (bfd_asymbol_flavour (symbol) != bfd_target_coff_flavour)
d610 5
a614 2
	    syment->n_value +=
	      coff_symbol_ptr->symbol.section->output_section->vma;
d694 1
a694 1
      symbol_ptr_ptr[symbol_index]->udata.i = symbol_index; 
d821 10
a830 1
      strncpy (native->u.syment._n._n_name, ".file", SYMNMLEN);
d857 1
a857 1
      if (name_length <= SYMNMLEN)
d872 2
a873 1
	  bfd_byte buf[2];
d883 5
a887 1
	  bfd_put_16 (abfd, name_length + 1, buf);
d892 1
a892 1
					 (bfd_size_type) 2)
d897 1
a897 1
					     + 2),
d902 2
a903 1
	  native->u.syment._n._n_n._n_offset = *debug_string_size_p + 2;
d905 1
a905 1
	  *debug_string_size_p += name_length + 3;
d1105 1
a1105 1
	  /* 13 april 92. sac 
d1261 1
a1261 1
	      maxlen = SYMNMLEN;
d1272 5
a1276 1
	    maxlen = bfd_coff_filnmlen (abfd);
d1278 1
a1278 1
	    maxlen = SYMNMLEN;
a1377 1
/*ARGSUSED */
d1488 1
a1488 1
   we didn't want to go to the trouble until someone needed it. */
d1510 1
a1510 1
  /* Seek to the beginning of the `.debug' section and read it. 
a1523 1

d1611 1
a1611 1
    
d1812 1
a1812 1
		}		/* possible lengths of this string. */
a1909 1
/*ARGSUSED */
d2162 1
a2162 1
/*ARGSUSED*/
d2189 1
a2189 1
					     &coff_data (abfd)->line_info))
d2191 1
d2195 7
d2207 1
a2207 1
  if (abfd->xvec->flavour != bfd_target_coff_flavour)
d2414 1
a2414 1
      
d2422 1
a2422 1
      
d2425 1
a2425 1
      
d2444 1
a2444 1
	  
d2449 1
a2449 1
      
d2456 1
a2456 1
  
a2458 1

@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d66 1
a66 1
  PARAMS ((coff_symbol_type *, struct internal_syment *));
a142 2
  return_section->flags = bfd_coff_styp_to_sec_flags_hook (abfd, hdr, name);

d144 2
d214 5
a235 3
  if (bfd_coff_set_arch_mach_hook (abfd, (PTR) internal_f) == false)
    goto fail;

d289 2
a290 1
      if (bfd_read (opthdr, 1, aoutsz, abfd) != aoutsz)
d294 1
a294 1
      bfd_coff_swap_aouthdr_in (abfd, opthdr, (PTR) & internal_a);
a296 5
  /* Seek past the opt hdr stuff */
  if (bfd_seek (abfd, (file_ptr) (internal_f.f_opthdr + filhsz), SEEK_SET)
      != 0)
    return NULL;

d564 1
a564 1
     bfd *ignore_abfd;
d577 2
a578 1
fixup_symbol_value (coff_symbol_ptr, syment)
d590 2
a591 1
  else if (coff_symbol_ptr->symbol.flags & BSF_DEBUGGING)
d600 1
d608 5
a612 4
	  syment->n_value =
	    coff_symbol_ptr->symbol.value +
	    coff_symbol_ptr->symbol.section->output_offset +
	    coff_symbol_ptr->symbol.section->output_section->vma;
d656 2
a657 3
    newsyms = (asymbol **) bfd_alloc_by_size_t (bfd_ptr,
						sizeof (asymbol *)
						* (symbol_count + 1));
d665 3
a667 2
	      && ((symbol_ptr_ptr[i]->flags & (BSF_GLOBAL | BSF_FUNCTION))
		  != BSF_GLOBAL)))
d674 3
a676 2
	      || ((symbol_ptr_ptr[i]->flags & (BSF_GLOBAL | BSF_FUNCTION))
		  == BSF_GLOBAL)))
d710 1
a710 1
	      fixup_symbol_value (coff_symbol_ptr, &(s->u.syment));
d817 2
d822 2
d826 1
a826 1
	  if (name_length <= FILNMLEN)
d828 1
a828 1
	      strncpy (auxent->x_file.x_fname, name, FILNMLEN);
d839 3
a841 5
	  strncpy (auxent->x_file.x_fname, name, FILNMLEN);
	  if (name_length > FILNMLEN)
	    {
	      name[FILNMLEN] = '\0';
	    }
a1026 1
				  + symbol->section->output_section->vma
d1028 2
d1043 2
d1255 1
a1255 1
	    maxlen = FILNMLEN;
d1360 1
a1360 1
     bfd *ignore_abfd;
d1392 1
a1392 1
      f = (struct foo *) bfd_alloc_by_size_t (abfd, sizeof (*f));
d1430 2
a1431 2
  int type = symbol->u.syment.n_type;
  int class = symbol->u.syment.n_sclass;
d1613 1
a1613 1
	("%s: bad string table size %lu", bfd_get_filename (abfd),
d1755 20
a1774 4
	      /* ordinary short filename, put into memory anyway */
	      internal_ptr->u.syment._n._n_n._n_offset = (long)
		copy_name (abfd, (internal_ptr + 1)->u.auxent.x_file.x_fname,
			   FILNMLEN);
d1872 2
a1873 2
     PTR ptr;
     unsigned long sz;
d2071 16
a2087 1

d2128 4
a2131 3
/* Provided a BFD, a section and an offset into the section, calculate
   and return the name of the source file and the line nearest to the
   wanted location.  */
d2133 11
d2189 3
d2202 1
d2206 1
d2229 2
d2232 2
a2233 2
	      && offset >= (bfd_vma) p2->u.syment.n_value
	      && offset - (bfd_vma) p2->u.syment.n_value < maxdiff)
d2236 1
a2236 1
	      maxdiff = offset - p2->u.syment.n_value;
d2270 2
d2283 1
d2306 1
a2306 1
	      if (l->u.offset + bfd_get_section_vma (abfd, section) > offset)
d2312 14
d2366 68
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d59 11
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d90 2
d212 2
a213 1
	  make_a_section_from_file (abfd, &tmp, i + 1);
d1560 6
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 1995 Free Software Foundation, Inc.
d73 28
a100 2
  /* Assorted wastage to null-terminate the name, thanks AT&T! */
  name = bfd_alloc (abfd, sizeof (hdr->s_name) + 1);
d103 6
a108 2
      bfd_set_error (bfd_error_no_memory);
      return false;
a109 2
  strncpy (name, (char *) &hdr->s_name[0], sizeof (hdr->s_name));
  name[sizeof (hdr->s_name)] = 0;
a114 2
  /* s_paddr is presumed to be = to s_vaddr */

d116 1
a116 1
  return_section->lma = return_section->vma;
d195 1
a195 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto fail;
    }
d429 1
a429 1
      free_external = (bfd_byte *) malloc (sec->reloc_count * relsz);
d431 1
a431 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  goto error_return;
	}
d443 2
a444 2
		       malloc (sec->reloc_count
			       * sizeof (struct internal_reloc)));
d446 1
a446 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  goto error_return;
	}
d471 1
a471 4
	    {
	      bfd_set_error (bfd_error_no_memory);
	      goto error_return;
	    }
d643 1
a643 4
      {
	bfd_set_error (bfd_error_no_memory);
	return false;
      }
d648 1
d654 5
a658 5
      if (!bfd_is_und_section (symbol_ptr_ptr[i]->section)
	  && ((symbol_ptr_ptr[i]->flags & (BSF_GLOBAL
					   | BSF_NOT_AT_END
					   | BSF_FUNCTION))
	      == BSF_GLOBAL))
d926 1
a926 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d940 1
a940 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d1117 18
d1180 20
d1287 1
a1287 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d1343 5
d1394 2
d1426 1
a1426 1
  if ((ISFCN (type) || ISTAG (class) || class == C_BLOCK)
d1465 1
a1465 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d1503 1
a1503 4
    {
      bfd_set_error (bfd_error_no_memory);
      return (NULL);
    }
d1526 1
a1526 1
  syms = malloc (size);
d1528 1
a1528 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d1590 1
a1590 1
  strings = malloc (strsize);
d1592 1
a1592 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d1652 1
a1652 1
  internal = (combined_entry_type *) bfd_alloc (abfd, size);
d1654 1
a1654 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
a1677 4
      internal_ptr->fix_value = 0;
      internal_ptr->fix_tag = 0;
      internal_ptr->fix_end = 0;
      internal_ptr->fix_scnlen = 0;
a1685 5

	  internal_ptr->fix_value = 0;
	  internal_ptr->fix_tag = 0;
	  internal_ptr->fix_end = 0;
	  internal_ptr->fix_scnlen = 0;
d1751 1
a1751 4
		{
		  bfd_set_error (bfd_error_no_memory);
		  return (NULL);
		}		/* on error */
d1812 1
a1812 4
    {
      bfd_set_error (bfd_error_no_memory);
      return (NULL);
    }				/* on error */
d1832 3
a1834 5
    {
      bfd_set_error (bfd_error_no_memory);
      return (NULL);
    }				/* on error */
  /* @@@@ This shouldn't be using a constant multiplier.  */
d1837 1
a1837 4
    {
      bfd_set_error (bfd_error_no_memory);
      return (NULL);
    }				/* on error */
d1865 72
d2017 7
d2074 1
a2074 1
coff_find_nearest_line (abfd, section, ignore_symbols, offset, filename_ptr,
d2078 1
a2078 1
     asymbol **ignore_symbols;
d2084 1
d2094 10
d2189 3
a2191 1
  l = &section->lineno[i];
d2193 1
a2193 3
  for (; i < section->lineno_count; i++)
    {
      if (l->line_number == 0)
d2195 1
a2195 6
	  /* Get the symbol this line number points at */
	  coff_symbol_type *coff = (coff_symbol_type *) (l->u.sym);
	  if (coff->symbol.value > offset)
	    break;
	  *functionname_ptr = coff->symbol.name;
	  if (coff->native)
d2197 9
a2205 2
	      combined_entry_type *s = coff->native;
	      s = s + 1 + s->u.syment.n_numaux;
d2207 13
a2219 16
	      /* In XCOFF a debugging symbol can follow the function
	         symbol.  */
	      if (s->u.syment.n_scnum == N_DEBUG)
		s = s + 1 + s->u.syment.n_numaux;

	      /*
	         S should now point to the .bf of the function
	       */
	      if (s->u.syment.n_numaux)
		{
		  /*
		     The linenumber is stored in the auxent
		   */
		  union internal_auxent *a = &((s + 1)->u.auxent);
		  line_base = a->x_sym.x_misc.x_lnsz.x_lnno;
		  *line_ptr = line_base;
d2222 7
a2229 7
      else
	{
	  if (l->u.offset + bfd_get_section_vma (abfd, section) > offset)
	    break;
	  *line_ptr = l->line_number + line_base - 1;
	}
      l++;
d2233 1
a2233 1
  if (sec_data == NULL)
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d73 2
a74 28
  name = NULL;

  /* Handle long section names as in PE.  */
  if (bfd_coff_long_section_names (abfd)
      && hdr->s_name[0] == '/')
    {
      char buf[SCNNMLEN];
      long strindex;
      char *p;
      const char *strings;

      memcpy (buf, hdr->s_name + 1, SCNNMLEN - 1);
      buf[SCNNMLEN - 1] = '\0';
      strindex = strtol (buf, &p, 10);
      if (*p == '\0' && strindex >= 0)
	{
	  strings = _bfd_coff_read_string_table (abfd);
	  /* FIXME: For extra safety, we should make sure that
             strindex does not run us past the end, but right now we
             don't know the length of the string table.  */
	  strings += strindex;
	  name = bfd_alloc (abfd, strlen (strings) + 1);
	  if (name == NULL)
	    return false;
	  strcpy (name, strings);
	}
    }

d77 2
a78 6
      /* Assorted wastage to null-terminate the name, thanks AT&T! */
      name = bfd_alloc (abfd, sizeof (hdr->s_name) + 1);
      if (name == NULL)
	return false;
      strncpy (name, (char *) &hdr->s_name[0], sizeof (hdr->s_name));
      name[sizeof (hdr->s_name)] = 0;
d80 2
d87 2
d90 1
a90 1
  return_section->lma = hdr->s_paddr;
d169 4
a172 1
    goto fail;
d406 1
a406 1
      free_external = (bfd_byte *) bfd_malloc (sec->reloc_count * relsz);
d408 4
a411 1
	goto error_return;
d423 2
a424 2
		       bfd_malloc (sec->reloc_count
				   * sizeof (struct internal_reloc)));
d426 4
a429 1
	goto error_return;
d454 4
a457 1
	    goto error_return;
d629 4
a632 1
      return false;
a636 1
	      && !bfd_is_com_section (symbol_ptr_ptr[i]->section)
d642 5
a646 5
      if ((symbol_ptr_ptr[i]->flags & BSF_NOT_AT_END) == 0
	  && !bfd_is_und_section (symbol_ptr_ptr[i]->section)
	  && (bfd_is_com_section (symbol_ptr_ptr[i]->section)
	      || ((symbol_ptr_ptr[i]->flags & (BSF_GLOBAL | BSF_FUNCTION))
		  == BSF_GLOBAL)))
d914 4
a917 1
    return false;
d931 4
a934 1
	return false;
a1110 18
  /* If this target supports long section names, they must be put into
     the string table.  This is supported by PE.  This code must
     handle section names just as they are handled in
     coff_write_object_contents.  */
  if (bfd_coff_long_section_names (abfd))
    {
      asection *o;

      for (o = abfd->sections; o != NULL; o = o->next)
	{
	  size_t len;

	  len = strlen (o->name);
	  if (len > SCNNMLEN)
	    string_size += len + 1;
	}
    }

a1155 20

      /* Handle long section names.  This code must handle section
	 names just as they are handled in coff_write_object_contents.  */
      if (bfd_coff_long_section_names (abfd))
	{
	  asection *o;

	  for (o = abfd->sections; o != NULL; o = o->next)
	    {
	      size_t len;

	      len = strlen (o->name);
	      if (len > SCNNMLEN)
		{
		  if (bfd_write (o->name, 1, len + 1, abfd) != len + 1)
		    return false;
		}
	    }
	}

d1243 4
a1246 1
    return false;
a1301 5
#if 0

/* This is only called from coff_add_missing_symbols, which has been
   disabled.  */

a1347 2
#endif /* 0 */

d1378 1
a1378 1
  if ((ISFCN (type) || ISTAG (class) || class == C_BLOCK || class == C_FCN)
d1417 4
a1420 1
    return NULL;
d1458 4
a1461 1
    return (NULL);
d1484 1
a1484 1
  syms = (PTR) bfd_malloc (size);
d1486 4
a1489 1
    return false;
d1551 1
a1551 1
  strings = (char *) bfd_malloc (strsize);
d1553 4
a1556 1
    return NULL;
d1616 1
a1616 1
  internal = (combined_entry_type *) bfd_zalloc (abfd, size);
d1618 4
a1621 1
    return NULL;
d1645 4
d1657 5
d1727 4
a1730 1
		return (NULL);
d1791 4
a1794 1
    return (NULL);
d1814 5
a1818 3
    return (NULL);
  /* @@@@ The 10 is a guess at a plausible maximum number of aux entries
     (but shouldn't be a constant).  */
d1821 4
a1824 1
    return (NULL);
a1851 72
/* Return the COFF syment for a symbol.  */

boolean
bfd_coff_get_syment (abfd, symbol, psyment)
     bfd *abfd;
     asymbol *symbol;
     struct internal_syment *psyment;
{
  coff_symbol_type *csym;

  csym = coff_symbol_from (abfd, symbol);
  if (csym == NULL || csym->native == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return false;
    }

  *psyment = csym->native->u.syment;

  if (csym->native->fix_value)
    psyment->n_value = ((combined_entry_type *) psyment->n_value
			- obj_raw_syments (abfd));

  /* FIXME: We should handle fix_line here.  */

  return true;
}

/* Return the COFF auxent for a symbol.  */

boolean
bfd_coff_get_auxent (abfd, symbol, indx, pauxent)
     bfd *abfd;
     asymbol *symbol;
     int indx;
     union internal_auxent *pauxent;
{
  coff_symbol_type *csym;
  combined_entry_type *ent;

  csym = coff_symbol_from (abfd, symbol);

  if (csym == NULL
      || csym->native == NULL
      || indx >= csym->native->u.syment.n_numaux)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return false;
    }

  ent = csym->native + indx + 1;

  *pauxent = ent->u.auxent;

  if (ent->fix_tag)
    pauxent->x_sym.x_tagndx.l =
      ((combined_entry_type *) pauxent->x_sym.x_tagndx.p
       - obj_raw_syments (abfd));

  if (ent->fix_end)
    pauxent->x_sym.x_fcnary.x_fcn.x_endndx.l =
      ((combined_entry_type *) pauxent->x_sym.x_fcnary.x_fcn.x_endndx.p
       - obj_raw_syments (abfd));

  if (ent->fix_scnlen)
    pauxent->x_csect.x_scnlen.l =
      ((combined_entry_type *) pauxent->x_csect.x_scnlen.p
       - obj_raw_syments (abfd));

  return true;
}

a1931 7
		      if (auxp->u.auxent.x_scn.x_checksum != 0
			  || auxp->u.auxent.x_scn.x_associated != 0
			  || auxp->u.auxent.x_scn.x_comdat != 0)
			fprintf (file, " checksum 0x%lx assoc %d comdat %d",
				 auxp->u.auxent.x_scn.x_checksum,
				 auxp->u.auxent.x_scn.x_associated,
				 auxp->u.auxent.x_scn.x_comdat);
d1982 1
a1982 1
coff_find_nearest_line (abfd, section, symbols, offset, filename_ptr,
d1986 1
a1986 1
     asymbol **symbols;
a1991 1
  boolean found;
a2000 10
  /* Before looking through the symbol table, try to use a .stab
     section to find the information.  */
  if (! _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,
					     &found, filename_ptr,
					     functionname_ptr, line_ptr,
					     &coff_data (abfd)->line_info))
    return false;
  if (found)
    return true;

d2086 3
a2088 1
  if (section->lineno != NULL)
d2090 1
a2090 3
      l = &section->lineno[i];

      for (; i < section->lineno_count; i++)
d2092 6
a2097 1
	  if (l->line_number == 0)
d2099 12
a2110 6
	      /* Get the symbol this line number points at */
	      coff_symbol_type *coff = (coff_symbol_type *) (l->u.sym);
	      if (coff->symbol.value > offset)
		break;
	      *functionname_ptr = coff->symbol.name;
	      if (coff->native)
d2112 6
a2117 16
		  combined_entry_type *s = coff->native;
		  s = s + 1 + s->u.syment.n_numaux;

		  /* In XCOFF a debugging symbol can follow the
		     function symbol.  */
		  if (s->u.syment.n_scnum == N_DEBUG)
		    s = s + 1 + s->u.syment.n_numaux;

		  /* S should now point to the .bf of the function.  */
		  if (s->u.syment.n_numaux)
		    {
		      /* The linenumber is stored in the auxent.  */
		      union internal_auxent *a = &((s + 1)->u.auxent);
		      line_base = a->x_sym.x_misc.x_lnsz.x_lnno;
		      *line_ptr = line_base;
		    }
a2119 7
	  else
	    {
	      if (l->u.offset + bfd_get_section_vma (abfd, section) > offset)
		break;
	      *line_ptr = l->line_number + line_base - 1;
	    }
	  l++;
d2121 7
d2131 1
a2131 1
  if (sec_data == NULL && section->owner == abfd)
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a89 2
	  if (strings == NULL)
	    return false;
d210 1
a210 2
	  if (! make_a_section_from_file (abfd, &tmp, i + 1))
	    goto fail;
a1556 6

  if (obj_sym_filepos (abfd) == 0)
    {
      bfd_set_error (bfd_error_no_symbols);
      return NULL;
    }
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a58 11
static boolean make_a_section_from_file
  PARAMS ((bfd *, struct internal_scnhdr *, unsigned int));
static const bfd_target *coff_real_object_p
  PARAMS ((bfd *, unsigned, struct internal_filehdr *, 
	   struct internal_aouthdr *));
static void fixup_symbol_value
  PARAMS ((coff_symbol_type *, struct internal_syment *));
static char *build_debug_section
  PARAMS ((bfd *));
static char *copy_name
  PARAMS ((bfd *, char *, int));
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d653 3
a655 2
    newsyms = (asymbol **) bfd_alloc (bfd_ptr,
				      sizeof (asymbol *) * (symbol_count + 1));
d1383 1
a1383 1
      f = (struct foo *) bfd_alloc (abfd, sizeof (*f));
a2085 13
}

/* Return whether a symbol name implies a local symbol.  In COFF,
   local symbols generally start with ``.L''.  Most targets use this
   function for the is_local_label_name entry point, but some may
   override it.  */

boolean
_bfd_coff_is_local_label_name (abfd, name)
     bfd *abfd;
     const char *name;
{
  return name[0] == '.' && name[1] == 'L';
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999, 2000
   Free Software Foundation, Inc.
d65 1
a65 1
  PARAMS ((bfd *, coff_symbol_type *, struct internal_syment *));
d142 2
a144 2
  return_section->flags = bfd_coff_styp_to_sec_flags_hook (abfd, hdr, name,
							   return_section);
a212 5
  /* Set the arch/mach *before* swapping in sections; section header swapping
     may depend on arch/mach info. */
  if (bfd_coff_set_arch_mach_hook (abfd, (PTR) internal_f) == false)
    goto fail;

d230 3
d286 1
a286 2
      if (bfd_read (opthdr, 1, internal_f.f_opthdr, abfd)
	  != internal_f.f_opthdr)
d290 1
a290 1
      bfd_coff_swap_aouthdr_in (abfd, opthdr, (PTR) &internal_a);
d293 5
d565 1
a565 1
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d578 1
a578 2
fixup_symbol_value (abfd, coff_symbol_ptr, syment)
     bfd *abfd;
d590 1
a590 2
  else if ((coff_symbol_ptr->symbol.flags & BSF_DEBUGGING) != 0
	   && (coff_symbol_ptr->symbol.flags & BSF_DEBUGGING_RELOC) == 0)
a598 1
  /* FIXME: Do we need to handle the absolute section here?  */
d606 4
a609 5
	  syment->n_value = (coff_symbol_ptr->symbol.value
			     + coff_symbol_ptr->symbol.section->output_offset);
	  if (! obj_pe (abfd))
	    syment->n_value +=
	      coff_symbol_ptr->symbol.section->output_section->vma;
d662 2
a663 3
	      && ((symbol_ptr_ptr[i]->flags & BSF_FUNCTION) != 0
		  || ((symbol_ptr_ptr[i]->flags & (BSF_GLOBAL | BSF_WEAK))
		      == 0))))
d670 2
a671 3
	      || ((symbol_ptr_ptr[i]->flags & BSF_FUNCTION) == 0
		  && ((symbol_ptr_ptr[i]->flags & (BSF_GLOBAL | BSF_WEAK))
		      != 0))))
d705 1
a705 1
	      fixup_symbol_value (bfd_ptr, coff_symbol_ptr, &(s->u.syment));
a811 2
      unsigned int filnmlen;

a814 2
      filnmlen = bfd_coff_filnmlen (abfd);

d817 1
a817 1
	  if (name_length <= filnmlen)
d819 1
a819 1
	      strncpy (auxent->x_file.x_fname, name, filnmlen);
d830 5
a834 3
	  strncpy (auxent->x_file.x_fname, name, filnmlen);
	  if (name_length > filnmlen)
	    name[filnmlen] = '\0';
d1020 1
a1021 2
      if (! obj_pe (abfd))
	native->u.syment.n_value += symbol->section->output_section->vma;
a1034 2
  else if (symbol->flags & BSF_WEAK)
    native->u.syment.n_sclass = obj_pe (abfd) ? C_NT_WEAK : C_WEAKEXT;
d1245 1
a1245 1
	    maxlen = bfd_coff_filnmlen (abfd);
d1350 1
a1350 1
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d1420 2
a1421 2
  unsigned int type = symbol->u.syment.n_type;
  unsigned int class = symbol->u.syment.n_sclass;
d1603 1
a1603 1
	(_("%s: bad string table size %lu"), bfd_get_filename (abfd),
d1745 4
a1748 20
	      /* Ordinary short filename, put into memory anyway.  The
                 Microsoft PE tools sometimes store a filename in
                 multiple AUX entries.  */
	      if (internal_ptr->u.syment.n_numaux > 1
		  && coff_data (abfd)->pe)
		{
		  internal_ptr->u.syment._n._n_n._n_offset =
		    ((long)
		     copy_name (abfd,
				(internal_ptr + 1)->u.auxent.x_file.x_fname,
				internal_ptr->u.syment.n_numaux * symesz));
		}
	      else
		{
		  internal_ptr->u.syment._n._n_n._n_offset =
		    ((long)
		     copy_name (abfd,
				(internal_ptr + 1)->u.auxent.x_file.x_fname,
				bfd_coff_filnmlen (abfd)));
		}
d1846 2
a1847 2
     PTR ptr ATTRIBUTE_UNUSED;
     unsigned long sz ATTRIBUTE_UNUSED;
a2044 16
		    /* else fall through */
		case C_EXT:
		  if (ISFCN (combined->u.syment.n_type))
		    {
		      fprintf (file,
			       _("AUX tagndx %ld ttlsiz 0x%lx lnnos %ld next %ld"),
			       tagndx,
			       auxp->u.auxent.x_sym.x_misc.x_fsize,
			       auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_lnnoptr,
			       (auxp->fix_end
				? ((long)
				   (auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.p
				    - root))
				: auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.l));
		      break;
		    }
d2046 1
d2094 1
a2094 1
     bfd *abfd ATTRIBUTE_UNUSED;
d2100 4
a2103 3
/* Provided a BFD, a section and an offset (in bytes, not octets) into the
   section, calculate and return the name of the source file and the line
   nearest to the wanted location.  */
a2148 3
  if (!p)
    return false;

a2158 1
      bfd_vma sec_vma;
a2161 1
      sec_vma = bfd_get_section_vma (abfd, section);
a2183 2
	  /* We use <= MAXDIFF here so that if we get a zero length
             file, we actually use the next file entry.  */
d2185 2
a2186 2
	      && offset + sec_vma >= (bfd_vma) p2->u.syment.n_value
	      && offset + sec_vma - (bfd_vma) p2->u.syment.n_value <= maxdiff)
d2189 1
a2189 1
	      maxdiff = offset + sec_vma - p2->u.syment.n_value;
a2222 2
      bfd_vma last_value = 0;

a2233 1
	      last_value = coff->symbol.value;
d2256 1
a2256 1
	      if (l->u.offset > offset)
a2261 14

      /* If we fell off the end of the loop, then assume that this
	 symbol has no line number info.  Otherwise, symbols with no
	 line number info get reported with the line number of the
	 last line of the last symbol which does have line number
	 info.  We use 0x100 as a slop to account for cases where the
	 last line has executable code.  */
      if (i >= section->lineno_count
	  && last_value != 0
	  && offset - last_value > 0x100)
	{
	  *functionname_ptr = NULL;
	  *line_ptr = 0;
	}
a2301 68

/* Change the class of a coff symbol held by BFD.  */
boolean
bfd_coff_set_symbol_class (abfd, symbol, class)
     bfd *         abfd;
     asymbol *     symbol;
     unsigned int  class;
{
  coff_symbol_type * csym;

  csym = coff_symbol_from (abfd, symbol);
  if (csym == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return false;
    }
  else if (csym->native == NULL)
    {
      /* This is an alien symbol which no native coff backend data.
	 We cheat here by creating a fake native entry for it and
	 then filling in the class.  This code is based on that in
	 coff_write_alien_symbol().  */
      
      combined_entry_type * native;

      native = (combined_entry_type *) bfd_alloc (abfd, sizeof (* native));
      if (native == NULL)
	return false;

      memset (native, 0, sizeof (* native));
      
      native->u.syment.n_type   = T_NULL;
      native->u.syment.n_sclass = class;
      
      if (bfd_is_und_section (symbol->section))
	{
	  native->u.syment.n_scnum = N_UNDEF;
	  native->u.syment.n_value = symbol->value;
	}
      else if (bfd_is_com_section (symbol->section))
	{
	  native->u.syment.n_scnum = N_UNDEF;
	  native->u.syment.n_value = symbol->value;
	}
      else
	{
	  native->u.syment.n_scnum =
	    symbol->section->output_section->target_index;
	  native->u.syment.n_value = (symbol->value
				      + symbol->section->output_offset);
	  if (! obj_pe (abfd))
	    native->u.syment.n_value += symbol->section->output_section->vma;
	  
	  /* Copy the any flags from the the file header into the symbol.
	     FIXME: Why?  */
	  native->u.syment.n_flags = bfd_asymbol_bfd (& csym->symbol)->flags;
	}
      
      csym->native = native;
    }
  else
    {
      csym->native->u.syment.n_sclass = class;
    }
  
  return true;
}

@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
d63 1
a63 1
  PARAMS ((bfd *, unsigned, struct internal_filehdr *,
d215 1
a215 1
     may depend on arch/mach info.  */
d343 1
d528 1
a528 1
      if (bfd_family_coff (bfd_asymbol_bfd (q_maybe)))
d561 1
d567 1
a567 1
  if (!bfd_family_coff (bfd_asymbol_bfd (symbol)))
d611 2
a612 5
            {
              syment->n_value += (syment->n_sclass == C_STATLAB)
                ? coff_symbol_ptr->symbol.section->output_section->lma
                : coff_symbol_ptr->symbol.section->output_section->vma;
            }
d692 1
a692 1
      symbol_ptr_ptr[symbol_index]->udata.i = symbol_index;
d819 1
a819 10
      if (bfd_coff_force_symnames_in_strings (abfd))
	{
          native->u.syment._n._n_n._n_offset =
	      (*string_size_p + STRING_SIZE_SIZE);
	  native->u.syment._n._n_n._n_zeroes = 0;
	  *string_size_p += 6;  /* strlen(".file") + 1 */
	}
      else
  	strncpy (native->u.syment._n._n_name, ".file", SYMNMLEN);

d846 1
a846 1
      if (name_length <= SYMNMLEN && !bfd_coff_force_symnames_in_strings (abfd))
d861 1
a861 2
	  bfd_byte buf[4];
	  int prefix_len = bfd_coff_debug_string_prefix_length (abfd);
d871 1
a871 5
	  if (prefix_len == 4)
	    bfd_put_32 (abfd, name_length + 1, buf);
	  else
	    bfd_put_16 (abfd, name_length + 1, buf);

d876 1
a876 1
					 (bfd_size_type) prefix_len)
d881 1
a881 1
					     + prefix_len),
d886 1
a886 2
	  native->u.syment._n._n_n._n_offset =
	      *debug_string_size_p + prefix_len;
d888 1
a888 1
	  *debug_string_size_p += name_length + 1 + prefix_len;
d1088 1
a1088 1
	  /* 13 april 92. sac
d1244 1
a1244 1
	      maxlen = bfd_coff_force_symnames_in_strings (abfd) ? 0 : SYMNMLEN;
d1255 1
a1255 5
	    {
	      if (bfd_coff_force_symnames_in_strings (abfd))
      		bfd_write (".file", 1, 6, abfd);
	      maxlen = bfd_coff_filnmlen (abfd);
	    }
d1257 1
a1257 1
	    maxlen = bfd_coff_force_symnames_in_strings (abfd) ? 0 : SYMNMLEN;
d1357 1
d1468 1
a1468 1
   we didn't want to go to the trouble until someone needed it.  */
d1490 1
a1490 1
  /* Seek to the beginning of the `.debug' section and read it.
d1504 1
d1592 1
a1592 1

d1793 1
a1793 1
		}		/* possible lengths of this string.  */
d1891 1
d2144 1
a2144 1

d2171 1
a2171 1
					     &coff_data(abfd)->line_info))
a2172 1

a2175 7
  /* Also try examining DWARF2 debugging information.  */
  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, 0,
				     &coff_data(abfd)->dwarf2_find_line_info))
    return true;

d2181 1
a2181 1
  if (!bfd_family_coff (abfd))
d2388 1
a2388 1

d2396 1
a2396 1

d2399 1
a2399 1

d2418 1
a2418 1

d2423 1
a2423 1

d2430 1
a2430 1

d2433 1
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2000, 2001, 2002
d49 2
a50 2
static bfd_boolean coff_write_symbol
  PARAMS ((bfd *, asymbol *, combined_entry_type *, bfd_vma *,
d52 2
a53 2
static bfd_boolean coff_write_alien_symbol
  PARAMS ((bfd *, asymbol *, bfd_vma *, bfd_size_type *,
d55 2
a56 2
static bfd_boolean coff_write_native_symbol
  PARAMS ((bfd *, coff_symbol_type *, bfd_vma *, bfd_size_type *,
d61 1
a61 1
static bfd_boolean make_a_section_from_file
d71 1
a71 1
  PARAMS ((bfd *, char *, size_t));
d77 1
a77 1
static bfd_boolean
a84 2
  bfd_boolean result = TRUE;
  flagword flags;
d104 1
a104 1
	    return FALSE;
d109 1
a109 1
	  name = bfd_alloc (abfd, (bfd_size_type) strlen (strings) + 1);
d111 1
a111 1
	    return FALSE;
d119 1
a119 1
      name = bfd_alloc (abfd, (bfd_size_type) sizeof (hdr->s_name) + 1);
d121 1
a121 1
	return FALSE;
d128 1
a128 1
    return FALSE;
d145 2
a146 6

  if (! bfd_coff_styp_to_sec_flags_hook (abfd, hdr, name, return_section,
					 & flags))
    result = FALSE;

  return_section->flags = flags;
d158 1
a158 2

  return result;
d174 1
a174 2
  PTR tdata_save;
  bfd_size_type readsize;	/* length of file_info */
a201 1
  tdata_save = abfd->tdata.any;
d204 1
a204 1
    goto fail2;
d207 1
a207 1
  readsize = (bfd_size_type) nscns * scnhsz;
d212 1
a212 1
  if (bfd_bread ((PTR) external_sections, readsize, abfd) != readsize)
d217 1
a217 1
  if (! bfd_coff_set_arch_mach_hook (abfd, (PTR) internal_f))
d220 1
a220 1
  /* Now copy data as required; construct all asections etc.  */
d235 2
a240 2
 fail2:
  abfd->tdata.any = tdata_save;
d253 3
a255 3
  bfd_size_type filhsz;
  bfd_size_type aoutsz;
  unsigned int nscns;
d266 2
a267 2
    return NULL;
  if (bfd_bread (filehdr, filhsz, abfd) != filhsz)
d271 1
a271 2
      bfd_release (abfd, filehdr);
      return NULL;
d276 1
a276 10
  /* The XCOFF format has two sizes for the f_opthdr.  SMALL_AOUTSZ
     (less than aoutsz) used in object files and AOUTSZ (equal to
     aoutsz) in executables.  The bfd_coff_swap_aouthdr_in function
     expects this header to be aoutsz bytes in length, so we use that
     value in the call to bfd_alloc below.  But we must be careful to
     only read in f_opthdr bytes in the call to bfd_bread.  We should
     also attempt to catch corrupt or non-COFF binaries with a strange
     value for f_opthdr.  */
  if (! bfd_coff_bad_format_hook (abfd, &internal_f)
      || internal_f.f_opthdr > aoutsz)
d279 1
a279 1
      return NULL;
d289 2
a290 2
	return NULL;
      if (bfd_bread (opthdr, (bfd_size_type) internal_f.f_opthdr, abfd)
d293 1
a293 2
	  bfd_release (abfd, opthdr);
	  return NULL;
a295 1
      bfd_release (abfd, opthdr);
d403 1
a403 1
   relocs for section SEC in file ABFD.  If CACHE is TRUE and
d408 1
a408 1
   the swapped relocs.  If REQUIRE_INTERNAL is TRUE, then the return
d416 1
a416 1
     bfd_boolean cache;
d418 1
a418 1
     bfd_boolean require_internal;
a426 1
  bfd_size_type amt;
a439 1
  amt = sec->reloc_count * relsz;
d442 1
a442 1
      free_external = (bfd_byte *) bfd_malloc (amt);
d449 2
a450 1
      || bfd_bread (external_relocs, amt, abfd) != amt)
d455 3
a457 3
      amt = sec->reloc_count;
      amt *= sizeof (struct internal_reloc);
      free_internal = (struct internal_reloc *) bfd_malloc (amt);
d480 3
a482 2
	  amt = sizeof (struct coff_section_tdata);
	  sec->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
d542 4
a545 1
	      do
a546 6
		  asection * sec = q->symbol.section->output_section;

		  /* Do not try to update fields in read-only sections.  */
		  if (! bfd_is_const_section (sec))
		    sec->lineno_count ++;

d548 1
a550 1
	      while (l->line_number != 0);
d633 1
a633 1
bfd_boolean
a656 1
    bfd_size_type amt;
d658 2
a659 2
    amt = sizeof (asymbol *) * ((bfd_size_type) symbol_count + 1);
    newsyms = (asymbol **) bfd_alloc (bfd_ptr, amt);
d661 1
a661 1
      return FALSE;
d724 1
a724 1
  return TRUE;
d753 1
a753 2
		(bfd_vma)((combined_entry_type *)
			  ((unsigned long) s->u.syment.n_value))->offset;
d871 1
a871 1
	  file_ptr filepos;
d884 1
a884 1
	    bfd_put_32 (abfd, (bfd_vma) (name_length + 1), buf);
d886 1
a886 1
	    bfd_put_16 (abfd, (bfd_vma) (name_length + 1), buf);
d896 2
a897 2
					    (file_ptr) (*debug_string_size_p
							+ prefix_len),
d918 1
a918 1
static bfd_boolean
d924 1
a924 1
     bfd_vma *written;
d963 1
a963 1
    return FALSE;
d965 2
a966 2
  if (bfd_bwrite (buf, symesz, abfd) != symesz)
    return FALSE;
d977 1
a977 1
	return FALSE;
d984 1
a984 1
				 (int) j,
d987 2
a988 2
	  if (bfd_bwrite (buf, auxesz, abfd) != auxesz)
	    return FALSE;
d997 1
a997 1
  return TRUE;
d1004 1
a1004 1
static bfd_boolean
d1009 1
a1009 1
     bfd_vma *written;
d1037 1
a1037 1
      return TRUE;
d1048 1
a1048 1
      /* Copy the any flags from the file header into the symbol.
d1072 1
a1072 1
static bfd_boolean
d1077 1
a1077 1
     bfd_vma *written;
d1128 1
a1128 1
      symbol->done_lineno = TRUE;
d1130 2
a1131 3
      if (! bfd_is_const_section (symbol->symbol.section->output_section))
	symbol->symbol.section->output_section->moving_line_filepos +=
	  count * bfd_coff_linesz (abfd);
d1141 1
a1141 1
bfd_boolean
d1150 1
a1150 1
  bfd_signed_vma written = 0;
d1177 1
a1177 1
    return FALSE;
d1193 1
a1193 1
	    return FALSE;
d1200 1
a1200 1
	    return FALSE;
d1214 1
a1214 1
      H_PUT_32 (abfd, size, buffer);
d1216 1
a1216 1
 #error Change H_PUT_32
d1218 2
a1219 3
      if (bfd_bwrite ((PTR) buffer, (bfd_size_type) sizeof (buffer), abfd)
	  != sizeof (buffer))
	return FALSE;
d1234 2
a1235 3
		  if (bfd_bwrite (o->name, (bfd_size_type) (len + 1), abfd)
		      != len + 1)
		    return FALSE;
d1274 1
a1274 4
		{
		  if (bfd_bwrite (".file", (bfd_size_type) 6, abfd) != 6)
		    return FALSE;
		}
d1282 3
a1284 3
	      if (bfd_bwrite ((PTR) (q->name), (bfd_size_type) name_length + 1,
			     abfd) != name_length + 1)
		return FALSE;
d1297 1
a1297 1
      H_PUT_32 (abfd, size, buffer);
d1299 1
a1299 1
 #error Change H_PUT_32
d1301 1
a1301 1
      if (bfd_bwrite ((PTR) buffer, (bfd_size_type) STRING_SIZE_SIZE, abfd)
d1303 1
a1303 1
	return FALSE;
d1317 1
a1317 1
  return TRUE;
d1320 1
a1320 1
bfd_boolean
d1331 1
a1331 1
    return FALSE;
d1338 1
a1338 1
	    return FALSE;
d1356 2
a1357 3
		      if (bfd_bwrite (buff, (bfd_size_type) linesz, abfd)
			  != linesz)
			return FALSE;
d1364 2
a1365 3
			  if (bfd_bwrite (buff, (bfd_size_type) linesz, abfd)
			      != linesz)
			    return FALSE;
d1375 1
a1375 1
  return TRUE;
d1412 1
a1412 2

      f = (struct foo *) bfd_zalloc (abfd, (bfd_size_type) sizeof (*f));
d1418 1
d1495 1
a1495 2
  file_ptr position;
  bfd_size_type sec_size;
d1505 2
a1506 2
  sec_size = bfd_get_section_size_before_reloc (sect);
  debug_section = (PTR) bfd_alloc (abfd, sec_size);
d1516 3
a1518 1
      || bfd_bread (debug_section, sec_size, abfd) != sec_size
d1531 1
a1531 1
     size_t maxlen;
d1533 1
a1533 1
  size_t len;
d1544 1
a1544 1
  if ((newname = (PTR) bfd_alloc (abfd, (bfd_size_type) len + 1)) == NULL)
d1553 1
a1553 1
bfd_boolean
d1558 1
a1558 1
  bfd_size_type size;
d1562 1
a1562 1
    return TRUE;
d1570 1
a1570 1
    return FALSE;
d1573 1
a1573 1
      || bfd_bread (syms, size, abfd) != size)
d1577 1
a1577 1
      return FALSE;
d1582 1
a1582 1
  return TRUE;
d1594 1
a1594 1
  bfd_size_type strsize;
a1595 1
  file_ptr pos;
d1606 4
a1609 3
  pos = obj_sym_filepos (abfd);
  pos += obj_raw_syment_count (abfd) * bfd_coff_symesz (abfd);
  if (bfd_seek (abfd, pos, SEEK_SET) != 0)
d1612 1
a1612 2
  if (bfd_bread (extstrsize, (bfd_size_type) sizeof extstrsize, abfd)
      != sizeof extstrsize)
d1623 1
a1623 1
      strsize = H_GET_32 (abfd, extstrsize);
d1625 1
a1625 1
 #error Change H_GET_32
d1632 1
a1632 1
	(_("%s: bad string table size %lu"), bfd_archive_filename (abfd),
d1642 2
a1643 1
  if (bfd_bread (strings + STRING_SIZE_SIZE, strsize - STRING_SIZE_SIZE, abfd)
d1657 1
a1657 1
bfd_boolean
d1673 1
a1673 1
  return TRUE;
d1689 1
a1689 1
  size_t symesz;
d1694 1
a1694 1
  bfd_size_type size;
d1737 1
a1737 1
				(int) i, symbol_ptr->u.syment.n_numaux,
d1745 1
a1745 1
  obj_coff_keep_strings (abfd) = TRUE;
d1792 1
a1792 1
				(size_t) bfd_coff_filnmlen (abfd)));
d1801 2
a1802 2
	      size_t i;
	      char *newstring;
d1807 6
a1812 2
		if (internal_ptr->u.syment._n._n_name[i] == '\0')
		  break;
d1814 1
a1814 2
	      newstring = (PTR) bfd_zalloc (abfd, (bfd_size_type) (i + 1));
	      if (newstring == NULL)
d1816 2
a1817 1
	      strncpy (newstring, internal_ptr->u.syment._n._n_name, i);
d1874 1
a1874 2
  bfd_size_type amt = sizeof (coff_symbol_type);
  coff_symbol_type *new = (coff_symbol_type *) bfd_zalloc (abfd, amt);
d1877 1
d1881 1
a1881 1
  new->done_lineno = FALSE;
d1894 1
a1894 2
  bfd_size_type amt = sizeof (coff_symbol_type);
  coff_symbol_type *new = (coff_symbol_type *) bfd_alloc (abfd, amt);
d1899 1
a1899 2
  amt = sizeof (combined_entry_type) * 10;
  new->native = (combined_entry_type *) bfd_zalloc (abfd, amt);
d1905 1
a1905 1
  new->done_lineno = FALSE;
d1920 5
a1924 2
      ret->value = coffsymbol (symbol)->native->u.syment.n_value -
	(unsigned long) obj_raw_syments (abfd);
d1930 1
a1930 1
bfd_boolean
d1942 1
a1942 1
      return FALSE;
d1948 2
a1949 2
    psyment->n_value = psyment->n_value -
      (unsigned long) obj_raw_syments (abfd);
d1953 1
a1953 1
  return TRUE;
d1958 1
a1958 1
bfd_boolean
d1975 1
a1975 1
      return FALSE;
d1997 1
a1997 1
  return TRUE;
d2026 1
a2026 1
	  bfd_vma val;
d2035 1
a2035 1
	    val = (bfd_vma) combined->u.syment.n_value;
d2037 3
a2039 1
	    val = combined->u.syment.n_value - (unsigned long) root;
a2040 1
#ifndef XCOFF64
a2047 11
		   (unsigned long) val,
		   symbol->name);
#else
	  /* Print out the wide, 64 bit, symbol value */
	  fprintf (file,
		   "(sec %2d)(fl 0x%02x)(ty %3x)(scl %3d) (nx %d) 0x%016llx %s",
		   combined->u.syment.n_scnum,
		   combined->u.syment.n_flags,
		   combined->u.syment.n_type,
		   combined->u.syment.n_sclass,
		   combined->u.syment.n_numaux,
a2049 1
#endif
a2092 8
		      long next, llnos;

		      if (auxp->fix_end)
			next = (auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.p
			       - root);
		      else
			next = auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.l;
		      llnos = auxp->u.auxent.x_sym.x_fcnary.x_fcn.x_lnnoptr;
d2094 9
a2102 3
			       "AUX tagndx %ld ttlsiz 0x%lx lnnos %ld next %ld",
			       tagndx, auxp->u.auxent.x_sym.x_misc.x_fsize,
			       llnos, next);
d2136 1
a2136 1
	  bfd_print_symbol_vandf (abfd, (PTR) file, symbol);
d2151 1
a2151 1
bfd_boolean
d2163 1
a2163 1
bfd_boolean
d2170 2
a2171 2
     const char **filename_ptr;
     const char **functionname_ptr;
d2174 1
a2174 1
  bfd_boolean found;
a2182 1
  bfd_size_type amt;
d2190 1
a2190 1
    return FALSE;
d2193 1
a2193 1
    return TRUE;
d2200 1
a2200 1
    return TRUE;
d2208 1
a2208 1
    return FALSE;
d2211 1
a2211 1
    return FALSE;
d2216 1
a2216 1
    return FALSE;
d2267 1
a2267 1
	  if (p >= cof->raw_syments + p->u.syment.n_value)
d2357 3
a2359 2
      amt = sizeof (struct coff_section_tdata);
      section->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
d2370 1
a2370 1
  return TRUE;
d2376 1
a2376 1
     bfd_boolean reloc;
d2380 1
a2380 1
  if (! reloc)
d2394 1
a2394 1
bfd_boolean
d2406 1
a2406 1
      return FALSE;
a2415 1
      bfd_size_type amt = sizeof (* native);
d2417 1
a2417 1
      native = (combined_entry_type *) bfd_zalloc (abfd, amt);
d2419 3
a2421 1
	return FALSE;
d2445 1
a2445 1
	  /* Copy the any flags from the file header into the symbol.
d2457 1
a2457 1
  return TRUE;
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d332 1
a332 1
  struct bfd_section *answer = abfd->sections;
d368 1
a368 1
coff_canonicalize_symtab (abfd, alocation)
@


