head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.50
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.11.02.20.45.12;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.24;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.31;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.23;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.33.29;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.01.56;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.47.13;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.13;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.13;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.06.32;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.38.51;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.13.00;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.20.44;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.57;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.28.02;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.20;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.34;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD backend for SunOS binaries.
   Copyright 1990, 1991, 1992, 1994, 1995, 1996, 1997, 1998, 2000, 2001,
   2002, 2003 Free Software Foundation, Inc.
   Written by Cygnus Support.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#define TARGETNAME "a.out-sunos-big"

/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
#define MY(OP) CONCAT2 (sunos_big_,OP)

#include "bfd.h"
#include "bfdlink.h"
#include "libaout.h"

/* Static routines defined in this file.  */

static bfd_boolean sunos_read_dynamic_info PARAMS ((bfd *));
static long sunos_get_dynamic_symtab_upper_bound PARAMS ((bfd *));
static bfd_boolean sunos_slurp_dynamic_symtab PARAMS ((bfd *));
static long sunos_canonicalize_dynamic_symtab PARAMS ((bfd *, asymbol **));
static long sunos_get_dynamic_reloc_upper_bound PARAMS ((bfd *));
static long sunos_canonicalize_dynamic_reloc
  PARAMS ((bfd *, arelent **, asymbol **));
static struct bfd_hash_entry *sunos_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static struct bfd_link_hash_table *sunos_link_hash_table_create
  PARAMS ((bfd *));
static bfd_boolean sunos_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean));
static bfd_boolean sunos_add_dynamic_symbols
  PARAMS ((bfd *, struct bfd_link_info *, struct external_nlist **,
	   bfd_size_type *, char **));
static bfd_boolean sunos_add_one_symbol
  PARAMS ((struct bfd_link_info *, bfd *, const char *, flagword, asection *,
	   bfd_vma, const char *, bfd_boolean, bfd_boolean,
	   struct bfd_link_hash_entry **));
static bfd_boolean sunos_scan_relocs
  PARAMS ((struct bfd_link_info *, bfd *, asection *, bfd_size_type));
static bfd_boolean sunos_scan_std_relocs
  PARAMS ((struct bfd_link_info *, bfd *, asection *,
	   const struct reloc_std_external *, bfd_size_type));
static bfd_boolean sunos_scan_ext_relocs
  PARAMS ((struct bfd_link_info *, bfd *, asection *,
	   const struct reloc_ext_external *, bfd_size_type));
static bfd_boolean sunos_link_dynamic_object
  PARAMS ((struct bfd_link_info *, bfd *));
static bfd_boolean sunos_write_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct aout_link_hash_entry *));
static bfd_boolean sunos_check_dynamic_reloc
  PARAMS ((struct bfd_link_info *, bfd *, asection *,
	   struct aout_link_hash_entry *, PTR, bfd_byte *, bfd_boolean *,
	   bfd_vma *));
static bfd_boolean sunos_finish_dynamic_link
  PARAMS ((bfd *, struct bfd_link_info *));

#define MY_get_dynamic_symtab_upper_bound sunos_get_dynamic_symtab_upper_bound
#define MY_canonicalize_dynamic_symtab sunos_canonicalize_dynamic_symtab
#define MY_get_dynamic_reloc_upper_bound sunos_get_dynamic_reloc_upper_bound
#define MY_canonicalize_dynamic_reloc sunos_canonicalize_dynamic_reloc
#define MY_bfd_link_hash_table_create sunos_link_hash_table_create
#define MY_add_dynamic_symbols sunos_add_dynamic_symbols
#define MY_add_one_symbol sunos_add_one_symbol
#define MY_link_dynamic_object sunos_link_dynamic_object
#define MY_write_dynamic_symbol sunos_write_dynamic_symbol
#define MY_check_dynamic_reloc sunos_check_dynamic_reloc
#define MY_finish_dynamic_link sunos_finish_dynamic_link

/* ??? Where should this go?  */
#define MACHTYPE_OK(mtype) \
  (((mtype) == M_SPARC && bfd_lookup_arch (bfd_arch_sparc, 0) != NULL) \
   || ((mtype) == M_SPARCLET \
       && bfd_lookup_arch (bfd_arch_sparc, bfd_mach_sparc_sparclet) != NULL) \
   || ((mtype) == M_SPARCLITE_LE \
       && bfd_lookup_arch (bfd_arch_sparc, bfd_mach_sparc_sparclet) != NULL) \
   || (((mtype) == M_UNKNOWN || (mtype) == M_68010 || (mtype) == M_68020) \
       && bfd_lookup_arch (bfd_arch_m68k, 0) != NULL))

/* Include the usual a.out support.  */
#include "aoutf1.h"

/* The SunOS 4.1.4 /usr/include/locale.h defines valid as a macro.  */
#undef valid

/* SunOS shared library support.  We store a pointer to this structure
   in obj_aout_dynamic_info (abfd).  */

struct sunos_dynamic_info
{
  /* Whether we found any dynamic information.  */
  bfd_boolean valid;
  /* Dynamic information.  */
  struct internal_sun4_dynamic_link dyninfo;
  /* Number of dynamic symbols.  */
  unsigned long dynsym_count;
  /* Read in nlists for dynamic symbols.  */
  struct external_nlist *dynsym;
  /* asymbol structures for dynamic symbols.  */
  aout_symbol_type *canonical_dynsym;
  /* Read in dynamic string table.  */
  char *dynstr;
  /* Number of dynamic relocs.  */
  unsigned long dynrel_count;
  /* Read in dynamic relocs.  This may be reloc_std_external or
     reloc_ext_external.  */
  PTR dynrel;
  /* arelent structures for dynamic relocs.  */
  arelent *canonical_dynrel;
};

/* The hash table of dynamic symbols is composed of two word entries.
   See include/aout/sun4.h for details.  */

#define HASH_ENTRY_SIZE (2 * BYTES_IN_WORD)

/* Read in the basic dynamic information.  This locates the __DYNAMIC
   structure and uses it to find the dynamic_link structure.  It
   creates and saves a sunos_dynamic_info structure.  If it can't find
   __DYNAMIC, it sets the valid field of the sunos_dynamic_info
   structure to FALSE to avoid doing this work again.  */

static bfd_boolean
sunos_read_dynamic_info (abfd)
     bfd *abfd;
{
  struct sunos_dynamic_info *info;
  asection *dynsec;
  bfd_vma dynoff;
  struct external_sun4_dynamic dyninfo;
  unsigned long dynver;
  struct external_sun4_dynamic_link linkinfo;
  bfd_size_type amt;

  if (obj_aout_dynamic_info (abfd) != (PTR) NULL)
    return TRUE;

  if ((abfd->flags & DYNAMIC) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  amt = sizeof (struct sunos_dynamic_info);
  info = (struct sunos_dynamic_info *) bfd_zalloc (abfd, amt);
  if (!info)
    return FALSE;
  info->valid = FALSE;
  info->dynsym = NULL;
  info->dynstr = NULL;
  info->canonical_dynsym = NULL;
  info->dynrel = NULL;
  info->canonical_dynrel = NULL;
  obj_aout_dynamic_info (abfd) = (PTR) info;

  /* This code used to look for the __DYNAMIC symbol to locate the dynamic
     linking information.
     However this inhibits recovering the dynamic symbols from a
     stripped object file, so blindly assume that the dynamic linking
     information is located at the start of the data section.
     We could verify this assumption later by looking through the dynamic
     symbols for the __DYNAMIC symbol.  */
  if ((abfd->flags & DYNAMIC) == 0)
    return TRUE;
  if (! bfd_get_section_contents (abfd, obj_datasec (abfd), (PTR) &dyninfo,
				  (file_ptr) 0,
				  (bfd_size_type) sizeof dyninfo))
    return TRUE;

  dynver = GET_WORD (abfd, dyninfo.ld_version);
  if (dynver != 2 && dynver != 3)
    return TRUE;

  dynoff = GET_WORD (abfd, dyninfo.ld);

  /* dynoff is a virtual address.  It is probably always in the .data
     section, but this code should work even if it moves.  */
  if (dynoff < bfd_get_section_vma (abfd, obj_datasec (abfd)))
    dynsec = obj_textsec (abfd);
  else
    dynsec = obj_datasec (abfd);
  dynoff -= bfd_get_section_vma (abfd, dynsec);
  if (dynoff > bfd_section_size (abfd, dynsec))
    return TRUE;

  /* This executable appears to be dynamically linked in a way that we
     can understand.  */
  if (! bfd_get_section_contents (abfd, dynsec, (PTR) &linkinfo,
				  (file_ptr) dynoff,
				  (bfd_size_type) sizeof linkinfo))
    return TRUE;

  /* Swap in the dynamic link information.  */
  info->dyninfo.ld_loaded = GET_WORD (abfd, linkinfo.ld_loaded);
  info->dyninfo.ld_need = GET_WORD (abfd, linkinfo.ld_need);
  info->dyninfo.ld_rules = GET_WORD (abfd, linkinfo.ld_rules);
  info->dyninfo.ld_got = GET_WORD (abfd, linkinfo.ld_got);
  info->dyninfo.ld_plt = GET_WORD (abfd, linkinfo.ld_plt);
  info->dyninfo.ld_rel = GET_WORD (abfd, linkinfo.ld_rel);
  info->dyninfo.ld_hash = GET_WORD (abfd, linkinfo.ld_hash);
  info->dyninfo.ld_stab = GET_WORD (abfd, linkinfo.ld_stab);
  info->dyninfo.ld_stab_hash = GET_WORD (abfd, linkinfo.ld_stab_hash);
  info->dyninfo.ld_buckets = GET_WORD (abfd, linkinfo.ld_buckets);
  info->dyninfo.ld_symbols = GET_WORD (abfd, linkinfo.ld_symbols);
  info->dyninfo.ld_symb_size = GET_WORD (abfd, linkinfo.ld_symb_size);
  info->dyninfo.ld_text = GET_WORD (abfd, linkinfo.ld_text);
  info->dyninfo.ld_plt_sz = GET_WORD (abfd, linkinfo.ld_plt_sz);

  /* Reportedly the addresses need to be offset by the size of the
     exec header in an NMAGIC file.  */
  if (adata (abfd).magic == n_magic)
    {
      unsigned long exec_bytes_size = adata (abfd).exec_bytes_size;

      info->dyninfo.ld_need += exec_bytes_size;
      info->dyninfo.ld_rules += exec_bytes_size;
      info->dyninfo.ld_rel += exec_bytes_size;
      info->dyninfo.ld_hash += exec_bytes_size;
      info->dyninfo.ld_stab += exec_bytes_size;
      info->dyninfo.ld_symbols += exec_bytes_size;
    }

  /* The only way to get the size of the symbol information appears to
     be to determine the distance between it and the string table.  */
  info->dynsym_count = ((info->dyninfo.ld_symbols - info->dyninfo.ld_stab)
			/ EXTERNAL_NLIST_SIZE);
  BFD_ASSERT (info->dynsym_count * EXTERNAL_NLIST_SIZE
	      == (unsigned long) (info->dyninfo.ld_symbols
				  - info->dyninfo.ld_stab));

  /* Similarly, the relocs end at the hash table.  */
  info->dynrel_count = ((info->dyninfo.ld_hash - info->dyninfo.ld_rel)
			/ obj_reloc_entry_size (abfd));
  BFD_ASSERT (info->dynrel_count * obj_reloc_entry_size (abfd)
	      == (unsigned long) (info->dyninfo.ld_hash
				  - info->dyninfo.ld_rel));

  info->valid = TRUE;

  return TRUE;
}

/* Return the amount of memory required for the dynamic symbols.  */

static long
sunos_get_dynamic_symtab_upper_bound (abfd)
     bfd *abfd;
{
  struct sunos_dynamic_info *info;

  if (! sunos_read_dynamic_info (abfd))
    return -1;

  info = (struct sunos_dynamic_info *) obj_aout_dynamic_info (abfd);
  if (! info->valid)
    {
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

  return (info->dynsym_count + 1) * sizeof (asymbol *);
}

/* Read the external dynamic symbols.  */

static bfd_boolean
sunos_slurp_dynamic_symtab (abfd)
     bfd *abfd;
{
  struct sunos_dynamic_info *info;
  bfd_size_type amt;

  /* Get the general dynamic information.  */
  if (obj_aout_dynamic_info (abfd) == NULL)
    {
      if (! sunos_read_dynamic_info (abfd))
	  return FALSE;
    }

  info = (struct sunos_dynamic_info *) obj_aout_dynamic_info (abfd);
  if (! info->valid)
    {
      bfd_set_error (bfd_error_no_symbols);
      return FALSE;
    }

  /* Get the dynamic nlist structures.  */
  if (info->dynsym == (struct external_nlist *) NULL)
    {
      amt = (bfd_size_type) info->dynsym_count * EXTERNAL_NLIST_SIZE;
      info->dynsym = (struct external_nlist *) bfd_alloc (abfd, amt);
      if (info->dynsym == NULL && info->dynsym_count != 0)
	return FALSE;
      if (bfd_seek (abfd, (file_ptr) info->dyninfo.ld_stab, SEEK_SET) != 0
	  || bfd_bread ((PTR) info->dynsym, amt, abfd) != amt)
	{
	  if (info->dynsym != NULL)
	    {
	      bfd_release (abfd, info->dynsym);
	      info->dynsym = NULL;
	    }
	  return FALSE;
	}
    }

  /* Get the dynamic strings.  */
  if (info->dynstr == (char *) NULL)
    {
      amt = info->dyninfo.ld_symb_size;
      info->dynstr = (char *) bfd_alloc (abfd, amt);
      if (info->dynstr == NULL && info->dyninfo.ld_symb_size != 0)
	return FALSE;
      if (bfd_seek (abfd, (file_ptr) info->dyninfo.ld_symbols, SEEK_SET) != 0
	  || bfd_bread ((PTR) info->dynstr, amt, abfd) != amt)
	{
	  if (info->dynstr != NULL)
	    {
	      bfd_release (abfd, info->dynstr);
	      info->dynstr = NULL;
	    }
	  return FALSE;
	}
    }

  return TRUE;
}

/* Read in the dynamic symbols.  */

static long
sunos_canonicalize_dynamic_symtab (abfd, storage)
     bfd *abfd;
     asymbol **storage;
{
  struct sunos_dynamic_info *info;
  unsigned long i;

  if (! sunos_slurp_dynamic_symtab (abfd))
    return -1;

  info = (struct sunos_dynamic_info *) obj_aout_dynamic_info (abfd);

#ifdef CHECK_DYNAMIC_HASH
  /* Check my understanding of the dynamic hash table by making sure
     that each symbol can be located in the hash table.  */
  {
    bfd_size_type table_size;
    bfd_byte *table;
    bfd_size_type i;

    if (info->dyninfo.ld_buckets > info->dynsym_count)
      abort ();
    table_size = info->dyninfo.ld_stab - info->dyninfo.ld_hash;
    table = (bfd_byte *) bfd_malloc (table_size);
    if (table == NULL && table_size != 0)
      abort ();
    if (bfd_seek (abfd, (file_ptr) info->dyninfo.ld_hash, SEEK_SET) != 0
	|| bfd_bread ((PTR) table, table_size, abfd) != table_size)
      abort ();
    for (i = 0; i < info->dynsym_count; i++)
      {
	unsigned char *name;
	unsigned long hash;

	name = ((unsigned char *) info->dynstr
		+ GET_WORD (abfd, info->dynsym[i].e_strx));
	hash = 0;
	while (*name != '\0')
	  hash = (hash << 1) + *name++;
	hash &= 0x7fffffff;
	hash %= info->dyninfo.ld_buckets;
	while (GET_WORD (abfd, table + hash * HASH_ENTRY_SIZE) != i)
	  {
	    hash = GET_WORD (abfd,
			     table + hash * HASH_ENTRY_SIZE + BYTES_IN_WORD);
	    if (hash == 0 || hash >= table_size / HASH_ENTRY_SIZE)
	      abort ();
	  }
      }
    free (table);
  }
#endif /* CHECK_DYNAMIC_HASH */

  /* Get the asymbol structures corresponding to the dynamic nlist
     structures.  */
  if (info->canonical_dynsym == (aout_symbol_type *) NULL)
    {
      bfd_size_type size;
      bfd_size_type strsize = info->dyninfo.ld_symb_size;

      size = (bfd_size_type) info->dynsym_count * sizeof (aout_symbol_type);
      info->canonical_dynsym = (aout_symbol_type *) bfd_alloc (abfd, size);
      if (info->canonical_dynsym == NULL && info->dynsym_count != 0)
	return -1;

      if (! aout_32_translate_symbol_table (abfd, info->canonical_dynsym,
					    info->dynsym,
					    (bfd_size_type) info->dynsym_count,
					    info->dynstr, strsize, TRUE))
	{
	  if (info->canonical_dynsym != NULL)
	    {
	      bfd_release (abfd, info->canonical_dynsym);
	      info->canonical_dynsym = NULL;
	    }
	  return -1;
	}
    }

  /* Return pointers to the dynamic asymbol structures.  */
  for (i = 0; i < info->dynsym_count; i++)
    *storage++ = (asymbol *) (info->canonical_dynsym + i);
  *storage = NULL;

  return info->dynsym_count;
}

/* Return the amount of memory required for the dynamic relocs.  */

static long
sunos_get_dynamic_reloc_upper_bound (abfd)
     bfd *abfd;
{
  struct sunos_dynamic_info *info;

  if (! sunos_read_dynamic_info (abfd))
    return -1;

  info = (struct sunos_dynamic_info *) obj_aout_dynamic_info (abfd);
  if (! info->valid)
    {
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

  return (info->dynrel_count + 1) * sizeof (arelent *);
}

/* Read in the dynamic relocs.  */

static long
sunos_canonicalize_dynamic_reloc (abfd, storage, syms)
     bfd *abfd;
     arelent **storage;
     asymbol **syms;
{
  struct sunos_dynamic_info *info;
  unsigned long i;
  bfd_size_type size;

  /* Get the general dynamic information.  */
  if (obj_aout_dynamic_info (abfd) == (PTR) NULL)
    {
      if (! sunos_read_dynamic_info (abfd))
	return -1;
    }

  info = (struct sunos_dynamic_info *) obj_aout_dynamic_info (abfd);
  if (! info->valid)
    {
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

  /* Get the dynamic reloc information.  */
  if (info->dynrel == NULL)
    {
      size = (bfd_size_type) info->dynrel_count * obj_reloc_entry_size (abfd);
      info->dynrel = (PTR) bfd_alloc (abfd, size);
      if (info->dynrel == NULL && size != 0)
	return -1;
      if (bfd_seek (abfd, (file_ptr) info->dyninfo.ld_rel, SEEK_SET) != 0
	  || bfd_bread ((PTR) info->dynrel, size, abfd) != size)
	{
	  if (info->dynrel != NULL)
	    {
	      bfd_release (abfd, info->dynrel);
	      info->dynrel = NULL;
	    }
	  return -1;
	}
    }

  /* Get the arelent structures corresponding to the dynamic reloc
     information.  */
  if (info->canonical_dynrel == (arelent *) NULL)
    {
      arelent *to;

      size = (bfd_size_type) info->dynrel_count * sizeof (arelent);
      info->canonical_dynrel = (arelent *) bfd_alloc (abfd, size);
      if (info->canonical_dynrel == NULL && info->dynrel_count != 0)
	return -1;

      to = info->canonical_dynrel;

      if (obj_reloc_entry_size (abfd) == RELOC_EXT_SIZE)
	{
	  register struct reloc_ext_external *p;
	  struct reloc_ext_external *pend;

	  p = (struct reloc_ext_external *) info->dynrel;
	  pend = p + info->dynrel_count;
	  for (; p < pend; p++, to++)
	    NAME(aout,swap_ext_reloc_in) (abfd, p, to, syms,
					  (bfd_size_type) info->dynsym_count);
	}
      else
	{
	  register struct reloc_std_external *p;
	  struct reloc_std_external *pend;

	  p = (struct reloc_std_external *) info->dynrel;
	  pend = p + info->dynrel_count;
	  for (; p < pend; p++, to++)
	    NAME(aout,swap_std_reloc_in) (abfd, p, to, syms,
					  (bfd_size_type) info->dynsym_count);
	}
    }

  /* Return pointers to the dynamic arelent structures.  */
  for (i = 0; i < info->dynrel_count; i++)
    *storage++ = info->canonical_dynrel + i;
  *storage = NULL;

  return info->dynrel_count;
}

/* Code to handle linking of SunOS shared libraries.  */

/* A SPARC procedure linkage table entry is 12 bytes.  The first entry
   in the table is a jump which is filled in by the runtime linker.
   The remaining entries are branches back to the first entry,
   followed by an index into the relocation table encoded to look like
   a sethi of %g0.  */

#define SPARC_PLT_ENTRY_SIZE (12)

static const bfd_byte sparc_plt_first_entry[SPARC_PLT_ENTRY_SIZE] =
{
  /* sethi %hi(0),%g1; address filled in by runtime linker.  */
  0x3, 0, 0, 0,
  /* jmp %g1; offset filled in by runtime linker.  */
  0x81, 0xc0, 0x60, 0,
  /* nop */
  0x1, 0, 0, 0
};

/* save %sp, -96, %sp */
#define SPARC_PLT_ENTRY_WORD0 ((bfd_vma) 0x9de3bfa0)
/* call; address filled in later.  */
#define SPARC_PLT_ENTRY_WORD1 ((bfd_vma) 0x40000000)
/* sethi; reloc index filled in later.  */
#define SPARC_PLT_ENTRY_WORD2 ((bfd_vma) 0x01000000)

/* This sequence is used when for the jump table entry to a defined
   symbol in a complete executable.  It is used when linking PIC
   compiled code which is not being put into a shared library.  */
/* sethi <address to be filled in later>, %g1 */
#define SPARC_PLT_PIC_WORD0 ((bfd_vma) 0x03000000)
/* jmp %g1 + <address to be filled in later> */
#define SPARC_PLT_PIC_WORD1 ((bfd_vma) 0x81c06000)
/* nop */
#define SPARC_PLT_PIC_WORD2 ((bfd_vma) 0x01000000)

/* An m68k procedure linkage table entry is 8 bytes.  The first entry
   in the table is a jump which is filled in the by the runtime
   linker.  The remaining entries are branches back to the first
   entry, followed by a two byte index into the relocation table.  */

#define M68K_PLT_ENTRY_SIZE (8)

static const bfd_byte m68k_plt_first_entry[M68K_PLT_ENTRY_SIZE] =
{
  /* jmps @@# */
  0x4e, 0xf9,
  /* Filled in by runtime linker with a magic address.  */
  0, 0, 0, 0,
  /* Not used?  */
  0, 0
};

/* bsrl */
#define M68K_PLT_ENTRY_WORD0 ((bfd_vma) 0x61ff)
/* Remaining words filled in later.  */

/* An entry in the SunOS linker hash table.  */

struct sunos_link_hash_entry
{
  struct aout_link_hash_entry root;

  /* If this is a dynamic symbol, this is its index into the dynamic
     symbol table.  This is initialized to -1.  As the linker looks at
     the input files, it changes this to -2 if it will be added to the
     dynamic symbol table.  After all the input files have been seen,
     the linker will know whether to build a dynamic symbol table; if
     it does build one, this becomes the index into the table.  */
  long dynindx;

  /* If this is a dynamic symbol, this is the index of the name in the
     dynamic symbol string table.  */
  long dynstr_index;

  /* The offset into the global offset table used for this symbol.  If
     the symbol does not require a GOT entry, this is 0.  */
  bfd_vma got_offset;

  /* The offset into the procedure linkage table used for this symbol.
     If the symbol does not require a PLT entry, this is 0.  */
  bfd_vma plt_offset;

  /* Some linker flags.  */
  unsigned char flags;
  /* Symbol is referenced by a regular object.  */
#define SUNOS_REF_REGULAR 01
  /* Symbol is defined by a regular object.  */
#define SUNOS_DEF_REGULAR 02
  /* Symbol is referenced by a dynamic object.  */
#define SUNOS_REF_DYNAMIC 04
  /* Symbol is defined by a dynamic object.  */
#define SUNOS_DEF_DYNAMIC 010
  /* Symbol is a constructor symbol in a regular object.  */
#define SUNOS_CONSTRUCTOR 020
};

/* The SunOS linker hash table.  */

struct sunos_link_hash_table
{
  struct aout_link_hash_table root;

  /* The object which holds the dynamic sections.  */
  bfd *dynobj;

  /* Whether we have created the dynamic sections.  */
  bfd_boolean dynamic_sections_created;

  /* Whether we need the dynamic sections.  */
  bfd_boolean dynamic_sections_needed;

  /* Whether we need the .got table.  */
  bfd_boolean got_needed;

  /* The number of dynamic symbols.  */
  size_t dynsymcount;

  /* The number of buckets in the hash table.  */
  size_t bucketcount;

  /* The list of dynamic objects needed by dynamic objects included in
     the link.  */
  struct bfd_link_needed_list *needed;

  /* The offset of __GLOBAL_OFFSET_TABLE_ into the .got section.  */
  bfd_vma got_base;
};

/* Routine to create an entry in an SunOS link hash table.  */

static struct bfd_hash_entry *
sunos_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
{
  struct sunos_link_hash_entry *ret = (struct sunos_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct sunos_link_hash_entry *) NULL)
    ret = ((struct sunos_link_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct sunos_link_hash_entry)));
  if (ret == (struct sunos_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct sunos_link_hash_entry *)
	 NAME(aout,link_hash_newfunc) ((struct bfd_hash_entry *) ret,
				       table, string));
  if (ret != NULL)
    {
      /* Set local fields.  */
      ret->dynindx = -1;
      ret->dynstr_index = -1;
      ret->got_offset = 0;
      ret->plt_offset = 0;
      ret->flags = 0;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Create a SunOS link hash table.  */

static struct bfd_link_hash_table *
sunos_link_hash_table_create (abfd)
     bfd *abfd;
{
  struct sunos_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct sunos_link_hash_table);

  ret = (struct sunos_link_hash_table *) bfd_malloc (amt);
  if (ret == (struct sunos_link_hash_table *) NULL)
    return (struct bfd_link_hash_table *) NULL;
  if (! NAME(aout,link_hash_table_init) (&ret->root, abfd,
					 sunos_link_hash_newfunc))
    {
      free (ret);
      return (struct bfd_link_hash_table *) NULL;
    }

  ret->dynobj = NULL;
  ret->dynamic_sections_created = FALSE;
  ret->dynamic_sections_needed = FALSE;
  ret->got_needed = FALSE;
  ret->dynsymcount = 0;
  ret->bucketcount = 0;
  ret->needed = NULL;
  ret->got_base = 0;

  return &ret->root.root;
}

/* Look up an entry in an SunOS link hash table.  */

#define sunos_link_hash_lookup(table, string, create, copy, follow) \
  ((struct sunos_link_hash_entry *) \
   aout_link_hash_lookup (&(table)->root, (string), (create), (copy),\
			  (follow)))

/* Traverse a SunOS link hash table.  */

#define sunos_link_hash_traverse(table, func, info)			\
  (aout_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) PARAMS ((struct aout_link_hash_entry *, PTR))) (func), \
    (info)))

/* Get the SunOS link hash table from the info structure.  This is
   just a cast.  */

#define sunos_hash_table(p) ((struct sunos_link_hash_table *) ((p)->hash))

static bfd_boolean sunos_scan_dynamic_symbol
  PARAMS ((struct sunos_link_hash_entry *, PTR));

/* Create the dynamic sections needed if we are linking against a
   dynamic object, or if we are linking PIC compiled code.  ABFD is a
   bfd we can attach the dynamic sections to.  The linker script will
   look for these special sections names and put them in the right
   place in the output file.  See include/aout/sun4.h for more details
   of the dynamic linking information.  */

static bfd_boolean
sunos_create_dynamic_sections (abfd, info, needed)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean needed;
{
  asection *s;

  if (! sunos_hash_table (info)->dynamic_sections_created)
    {
      flagword flags;

      sunos_hash_table (info)->dynobj = abfd;

      flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	       | SEC_LINKER_CREATED);

      /* The .dynamic section holds the basic dynamic information: the
	 sun4_dynamic structure, the dynamic debugger information, and
	 the sun4_dynamic_link structure.  */
      s = bfd_make_section (abfd, ".dynamic");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags)
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      /* The .got section holds the global offset table.  The address
	 is put in the ld_got field.  */
      s = bfd_make_section (abfd, ".got");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags)
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      /* The .plt section holds the procedure linkage table.  The
	 address is put in the ld_plt field.  */
      s = bfd_make_section (abfd, ".plt");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_CODE)
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      /* The .dynrel section holds the dynamic relocs.  The address is
	 put in the ld_rel field.  */
      s = bfd_make_section (abfd, ".dynrel");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      /* The .hash section holds the dynamic hash table.  The address
	 is put in the ld_hash field.  */
      s = bfd_make_section (abfd, ".hash");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      /* The .dynsym section holds the dynamic symbols.  The address
	 is put in the ld_stab field.  */
      s = bfd_make_section (abfd, ".dynsym");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      /* The .dynstr section holds the dynamic symbol string table.
	 The address is put in the ld_symbols field.  */
      s = bfd_make_section (abfd, ".dynstr");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      sunos_hash_table (info)->dynamic_sections_created = TRUE;
    }

  if ((needed && ! sunos_hash_table (info)->dynamic_sections_needed)
      || info->shared)
    {
      bfd *dynobj;

      dynobj = sunos_hash_table (info)->dynobj;

      s = bfd_get_section_by_name (dynobj, ".got");
      if (s->_raw_size == 0)
	s->_raw_size = BYTES_IN_WORD;

      sunos_hash_table (info)->dynamic_sections_needed = TRUE;
      sunos_hash_table (info)->got_needed = TRUE;
    }

  return TRUE;
}

/* Add dynamic symbols during a link.  This is called by the a.out
   backend linker for each object it encounters.  */

static bfd_boolean
sunos_add_dynamic_symbols (abfd, info, symsp, sym_countp, stringsp)
     bfd *abfd;
     struct bfd_link_info *info;
     struct external_nlist **symsp;
     bfd_size_type *sym_countp;
     char **stringsp;
{
  bfd *dynobj;
  struct sunos_dynamic_info *dinfo;
  unsigned long need;
  asection **ps;

  /* Make sure we have all the required sections.  */
  if (info->hash->creator == abfd->xvec)
    {
      if (! sunos_create_dynamic_sections (abfd, info,
					   ((abfd->flags & DYNAMIC) != 0
					    && !info->relocatable)))
	return FALSE;
    }

  /* There is nothing else to do for a normal object.  */
  if ((abfd->flags & DYNAMIC) == 0)
    return TRUE;

  dynobj = sunos_hash_table (info)->dynobj;

  /* We do not want to include the sections in a dynamic object in the
     output file.  We hack by simply clobbering the list of sections
     in the BFD.  This could be handled more cleanly by, say, a new
     section flag; the existing SEC_NEVER_LOAD flag is not the one we
     want, because that one still implies that the section takes up
     space in the output file.  If this is the first object we have
     seen, we must preserve the dynamic sections we just created.  */
  for (ps = &abfd->sections; *ps != NULL; )
    {
      if (abfd != dynobj || ((*ps)->flags & SEC_LINKER_CREATED) == 0)
	bfd_section_list_remove (abfd, ps);
      else
	ps = &(*ps)->next;
    }

  /* The native linker seems to just ignore dynamic objects when -r is
     used.  */
  if (info->relocatable)
    return TRUE;

  /* There's no hope of using a dynamic object which does not exactly
     match the format of the output file.  */
  if (info->hash->creator != abfd->xvec)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  /* Make sure we have a .need and a .rules sections.  These are only
     needed if there really is a dynamic object in the link, so they
     are not added by sunos_create_dynamic_sections.  */
  if (bfd_get_section_by_name (dynobj, ".need") == NULL)
    {
      /* The .need section holds the list of names of shared objets
	 which must be included at runtime.  The address of this
	 section is put in the ld_need field.  */
      asection *s = bfd_make_section (dynobj, ".need");
      if (s == NULL
	  || ! bfd_set_section_flags (dynobj, s,
				      (SEC_ALLOC
				       | SEC_LOAD
				       | SEC_HAS_CONTENTS
				       | SEC_IN_MEMORY
				       | SEC_READONLY))
	  || ! bfd_set_section_alignment (dynobj, s, 2))
	return FALSE;
    }

  if (bfd_get_section_by_name (dynobj, ".rules") == NULL)
    {
      /* The .rules section holds the path to search for shared
	 objects.  The address of this section is put in the ld_rules
	 field.  */
      asection *s = bfd_make_section (dynobj, ".rules");
      if (s == NULL
	  || ! bfd_set_section_flags (dynobj, s,
				      (SEC_ALLOC
				       | SEC_LOAD
				       | SEC_HAS_CONTENTS
				       | SEC_IN_MEMORY
				       | SEC_READONLY))
	  || ! bfd_set_section_alignment (dynobj, s, 2))
	return FALSE;
    }

  /* Pick up the dynamic symbols and return them to the caller.  */
  if (! sunos_slurp_dynamic_symtab (abfd))
    return FALSE;

  dinfo = (struct sunos_dynamic_info *) obj_aout_dynamic_info (abfd);
  *symsp = dinfo->dynsym;
  *sym_countp = dinfo->dynsym_count;
  *stringsp = dinfo->dynstr;

  /* Record information about any other objects needed by this one.  */
  need = dinfo->dyninfo.ld_need;
  while (need != 0)
    {
      bfd_byte buf[16];
      unsigned long name, flags;
      unsigned short major_vno, minor_vno;
      struct bfd_link_needed_list *needed, **pp;
      char *namebuf, *p;
      bfd_size_type alc;
      bfd_byte b;
      char *namecopy;

      if (bfd_seek (abfd, (file_ptr) need, SEEK_SET) != 0
	  || bfd_bread (buf, (bfd_size_type) 16, abfd) != 16)
	return FALSE;

      /* For the format of an ld_need entry, see aout/sun4.h.  We
	 should probably define structs for this manipulation.  */

      name = bfd_get_32 (abfd, buf);
      flags = bfd_get_32 (abfd, buf + 4);
      major_vno = (unsigned short) bfd_get_16 (abfd, buf + 8);
      minor_vno = (unsigned short) bfd_get_16 (abfd, buf + 10);
      need = bfd_get_32 (abfd, buf + 12);

      alc = sizeof (struct bfd_link_needed_list);
      needed = (struct bfd_link_needed_list *) bfd_alloc (abfd, alc);
      if (needed == NULL)
	return FALSE;
      needed->by = abfd;

      /* We return the name as [-l]name[.maj][.min].  */
      alc = 30;
      namebuf = (char *) bfd_malloc (alc + 1);
      if (namebuf == NULL)
	return FALSE;
      p = namebuf;

      if ((flags & 0x80000000) != 0)
	{
	  *p++ = '-';
	  *p++ = 'l';
	}
      if (bfd_seek (abfd, (file_ptr) name, SEEK_SET) != 0)
	{
	  free (namebuf);
	  return FALSE;
	}

      do
	{
	  if (bfd_bread (&b, (bfd_size_type) 1, abfd) != 1)
	    {
	      free (namebuf);
	      return FALSE;
	    }

	  if ((bfd_size_type) (p - namebuf) >= alc)
	    {
	      char *n;

	      alc *= 2;
	      n = (char *) bfd_realloc (namebuf, alc + 1);
	      if (n == NULL)
		{
		  free (namebuf);
		  return FALSE;
		}
	      p = n + (p - namebuf);
	      namebuf = n;
	    }

	  *p++ = b;
	}
      while (b != '\0');

      if (major_vno == 0)
	*p = '\0';
      else
	{
	  char majbuf[30];
	  char minbuf[30];

	  sprintf (majbuf, ".%d", major_vno);
	  if (minor_vno == 0)
	    minbuf[0] = '\0';
	  else
	    sprintf (minbuf, ".%d", minor_vno);

	  if ((p - namebuf) + strlen (majbuf) + strlen (minbuf) >= alc)
	    {
	      char *n;

	      alc = (p - namebuf) + strlen (majbuf) + strlen (minbuf);
	      n = (char *) bfd_realloc (namebuf, alc + 1);
	      if (n == NULL)
		{
		  free (namebuf);
		  return FALSE;
		}
	      p = n + (p - namebuf);
	      namebuf = n;
	    }

	  strcpy (p, majbuf);
	  strcat (p, minbuf);
	}

      namecopy = bfd_alloc (abfd, (bfd_size_type) strlen (namebuf) + 1);
      if (namecopy == NULL)
	{
	  free (namebuf);
	  return FALSE;
	}
      strcpy (namecopy, namebuf);
      free (namebuf);
      needed->name = namecopy;

      needed->next = NULL;

      for (pp = &sunos_hash_table (info)->needed;
	   *pp != NULL;
	   pp = &(*pp)->next)
	;
      *pp = needed;
    }

  return TRUE;
}

/* Function to add a single symbol to the linker hash table.  This is
   a wrapper around _bfd_generic_link_add_one_symbol which handles the
   tweaking needed for dynamic linking support.  */

static bfd_boolean
sunos_add_one_symbol (info, abfd, name, flags, section, value, string,
		      copy, collect, hashp)
     struct bfd_link_info *info;
     bfd *abfd;
     const char *name;
     flagword flags;
     asection *section;
     bfd_vma value;
     const char *string;
     bfd_boolean copy;
     bfd_boolean collect;
     struct bfd_link_hash_entry **hashp;
{
  struct sunos_link_hash_entry *h;
  int new_flag;

  if ((flags & (BSF_INDIRECT | BSF_WARNING | BSF_CONSTRUCTOR)) != 0
      || ! bfd_is_und_section (section))
    h = sunos_link_hash_lookup (sunos_hash_table (info), name, TRUE, copy,
				FALSE);
  else
    h = ((struct sunos_link_hash_entry *)
	 bfd_wrapped_link_hash_lookup (abfd, info, name, TRUE, copy, FALSE));
  if (h == NULL)
    return FALSE;

  if (hashp != NULL)
    *hashp = (struct bfd_link_hash_entry *) h;

  /* Treat a common symbol in a dynamic object as defined in the .bss
     section of the dynamic object.  We don't want to allocate space
     for it in our process image.  */
  if ((abfd->flags & DYNAMIC) != 0
      && bfd_is_com_section (section))
    section = obj_bsssec (abfd);

  if (! bfd_is_und_section (section)
      && h->root.root.type != bfd_link_hash_new
      && h->root.root.type != bfd_link_hash_undefined
      && h->root.root.type != bfd_link_hash_defweak)
    {
      /* We are defining the symbol, and it is already defined.  This
	 is a potential multiple definition error.  */
      if ((abfd->flags & DYNAMIC) != 0)
	{
	  /* The definition we are adding is from a dynamic object.
	     We do not want this new definition to override the
	     existing definition, so we pretend it is just a
	     reference.  */
	  section = bfd_und_section_ptr;
	}
      else if (h->root.root.type == bfd_link_hash_defined
	       && h->root.root.u.def.section->owner != NULL
	       && (h->root.root.u.def.section->owner->flags & DYNAMIC) != 0)
	{
	  /* The existing definition is from a dynamic object.  We
	     want to override it with the definition we just found.
	     Clobber the existing definition.  */
	  h->root.root.type = bfd_link_hash_undefined;
	  h->root.root.u.undef.abfd = h->root.root.u.def.section->owner;
	}
      else if (h->root.root.type == bfd_link_hash_common
	       && (h->root.root.u.c.p->section->owner->flags & DYNAMIC) != 0)
	{
	  /* The existing definition is from a dynamic object.  We
	     want to override it with the definition we just found.
	     Clobber the existing definition.  We can't set it to new,
	     because it is on the undefined list.  */
	  h->root.root.type = bfd_link_hash_undefined;
	  h->root.root.u.undef.abfd = h->root.root.u.c.p->section->owner;
	}
    }

  if ((abfd->flags & DYNAMIC) != 0
      && abfd->xvec == info->hash->creator
      && (h->flags & SUNOS_CONSTRUCTOR) != 0)
    {
      /* The existing symbol is a constructor symbol, and this symbol
	 is from a dynamic object.  A constructor symbol is actually a
	 definition, although the type will be bfd_link_hash_undefined
	 at this point.  We want to ignore the definition from the
	 dynamic object.  */
      section = bfd_und_section_ptr;
    }
  else if ((flags & BSF_CONSTRUCTOR) != 0
	   && (abfd->flags & DYNAMIC) == 0
	   && h->root.root.type == bfd_link_hash_defined
	   && h->root.root.u.def.section->owner != NULL
	   && (h->root.root.u.def.section->owner->flags & DYNAMIC) != 0)
    {
      /* The existing symbol is defined by a dynamic object, and this
	 is a constructor symbol.  As above, we want to force the use
	 of the constructor symbol from the regular object.  */
      h->root.root.type = bfd_link_hash_new;
    }

  /* Do the usual procedure for adding a symbol.  */
  if (! _bfd_generic_link_add_one_symbol (info, abfd, name, flags, section,
					  value, string, copy, collect,
					  hashp))
    return FALSE;

  if (abfd->xvec == info->hash->creator)
    {
      /* Set a flag in the hash table entry indicating the type of
	 reference or definition we just found.  Keep a count of the
	 number of dynamic symbols we find.  A dynamic symbol is one
	 which is referenced or defined by both a regular object and a
	 shared object.  */
      if ((abfd->flags & DYNAMIC) == 0)
	{
	  if (bfd_is_und_section (section))
	    new_flag = SUNOS_REF_REGULAR;
	  else
	    new_flag = SUNOS_DEF_REGULAR;
	}
      else
	{
	  if (bfd_is_und_section (section))
	    new_flag = SUNOS_REF_DYNAMIC;
	  else
	    new_flag = SUNOS_DEF_DYNAMIC;
	}
      h->flags |= new_flag;

      if (h->dynindx == -1
	  && (h->flags & (SUNOS_DEF_REGULAR | SUNOS_REF_REGULAR)) != 0)
	{
	  ++sunos_hash_table (info)->dynsymcount;
	  h->dynindx = -2;
	}

      if ((flags & BSF_CONSTRUCTOR) != 0
	  && (abfd->flags & DYNAMIC) == 0)
	h->flags |= SUNOS_CONSTRUCTOR;
    }

  return TRUE;
}

/* Return the list of objects needed by BFD.  */

struct bfd_link_needed_list *
bfd_sunos_get_needed_list (abfd, info)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
{
  if (info->hash->creator != &MY(vec))
    return NULL;
  return sunos_hash_table (info)->needed;
}

/* Record an assignment made to a symbol by a linker script.  We need
   this in case some dynamic object refers to this symbol.  */

bfd_boolean
bfd_sunos_record_link_assignment (output_bfd, info, name)
     bfd *output_bfd;
     struct bfd_link_info *info;
     const char *name;
{
  struct sunos_link_hash_entry *h;

  if (output_bfd->xvec != &MY(vec))
    return TRUE;

  /* This is called after we have examined all the input objects.  If
     the symbol does not exist, it merely means that no object refers
     to it, and we can just ignore it at this point.  */
  h = sunos_link_hash_lookup (sunos_hash_table (info), name,
			      FALSE, FALSE, FALSE);
  if (h == NULL)
    return TRUE;

  /* In a shared library, the __DYNAMIC symbol does not appear in the
     dynamic symbol table.  */
  if (! info->shared || strcmp (name, "__DYNAMIC") != 0)
    {
      h->flags |= SUNOS_DEF_REGULAR;

      if (h->dynindx == -1)
	{
	  ++sunos_hash_table (info)->dynsymcount;
	  h->dynindx = -2;
	}
    }

  return TRUE;
}

/* Set up the sizes and contents of the dynamic sections created in
   sunos_add_dynamic_symbols.  This is called by the SunOS linker
   emulation before_allocation routine.  We must set the sizes of the
   sections before the linker sets the addresses of the various
   sections.  This unfortunately requires reading all the relocs so
   that we can work out which ones need to become dynamic relocs.  If
   info->keep_memory is TRUE, we keep the relocs in memory; otherwise,
   we discard them, and will read them again later.  */

bfd_boolean
bfd_sunos_size_dynamic_sections (output_bfd, info, sdynptr, sneedptr,
				 srulesptr)
     bfd *output_bfd;
     struct bfd_link_info *info;
     asection **sdynptr;
     asection **sneedptr;
     asection **srulesptr;
{
  bfd *dynobj;
  bfd_size_type dynsymcount;
  struct sunos_link_hash_entry *h;
  asection *s;
  size_t bucketcount;
  bfd_size_type hashalloc;
  size_t i;
  bfd *sub;

  *sdynptr = NULL;
  *sneedptr = NULL;
  *srulesptr = NULL;

  if (info->relocatable)
    return TRUE;

  if (output_bfd->xvec != &MY(vec))
    return TRUE;

  /* Look through all the input BFD's and read their relocs.  It would
     be better if we didn't have to do this, but there is no other way
     to determine the number of dynamic relocs we need, and, more
     importantly, there is no other way to know which symbols should
     get an entry in the procedure linkage table.  */
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      if ((sub->flags & DYNAMIC) == 0
	  && sub->xvec == output_bfd->xvec)
	{
	  if (! sunos_scan_relocs (info, sub, obj_textsec (sub),
				   exec_hdr (sub)->a_trsize)
	      || ! sunos_scan_relocs (info, sub, obj_datasec (sub),
				      exec_hdr (sub)->a_drsize))
	    return FALSE;
	}
    }

  dynobj = sunos_hash_table (info)->dynobj;
  dynsymcount = sunos_hash_table (info)->dynsymcount;

  /* If there were no dynamic objects in the link, and we don't need
     to build a global offset table, there is nothing to do here.  */
  if (! sunos_hash_table (info)->dynamic_sections_needed
      && ! sunos_hash_table (info)->got_needed)
    return TRUE;

  /* If __GLOBAL_OFFSET_TABLE_ was mentioned, define it.  */
  h = sunos_link_hash_lookup (sunos_hash_table (info),
			      "__GLOBAL_OFFSET_TABLE_", FALSE, FALSE, FALSE);
  if (h != NULL && (h->flags & SUNOS_REF_REGULAR) != 0)
    {
      h->flags |= SUNOS_DEF_REGULAR;
      if (h->dynindx == -1)
	{
	  ++sunos_hash_table (info)->dynsymcount;
	  h->dynindx = -2;
	}
      h->root.root.type = bfd_link_hash_defined;
      h->root.root.u.def.section = bfd_get_section_by_name (dynobj, ".got");

      /* If the .got section is more than 0x1000 bytes, we set
	 __GLOBAL_OFFSET_TABLE_ to be 0x1000 bytes into the section,
	 so that 13 bit relocations have a greater chance of working.  */
      s = bfd_get_section_by_name (dynobj, ".got");
      BFD_ASSERT (s != NULL);
      if (s->_raw_size >= 0x1000)
	h->root.root.u.def.value = 0x1000;
      else
	h->root.root.u.def.value = 0;

      sunos_hash_table (info)->got_base = h->root.root.u.def.value;
    }

  /* If there are any shared objects in the link, then we need to set
     up the dynamic linking information.  */
  if (sunos_hash_table (info)->dynamic_sections_needed)
    {
      *sdynptr = bfd_get_section_by_name (dynobj, ".dynamic");

      /* The .dynamic section is always the same size.  */
      s = *sdynptr;
      BFD_ASSERT (s != NULL);
      s->_raw_size = (sizeof (struct external_sun4_dynamic)
		      + EXTERNAL_SUN4_DYNAMIC_DEBUGGER_SIZE
		      + sizeof (struct external_sun4_dynamic_link));

      /* Set the size of the .dynsym and .hash sections.  We counted
	 the number of dynamic symbols as we read the input files.  We
	 will build the dynamic symbol table (.dynsym) and the hash
	 table (.hash) when we build the final symbol table, because
	 until then we do not know the correct value to give the
	 symbols.  We build the dynamic symbol string table (.dynstr)
	 in a traversal of the symbol table using
	 sunos_scan_dynamic_symbol.  */
      s = bfd_get_section_by_name (dynobj, ".dynsym");
      BFD_ASSERT (s != NULL);
      s->_raw_size = dynsymcount * sizeof (struct external_nlist);
      s->contents = (bfd_byte *) bfd_alloc (output_bfd, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
	return FALSE;

      /* The number of buckets is just the number of symbols divided
	 by four.  To compute the final size of the hash table, we
	 must actually compute the hash table.  Normally we need
	 exactly as many entries in the hash table as there are
	 dynamic symbols, but if some of the buckets are not used we
	 will need additional entries.  In the worst case, every
	 symbol will hash to the same bucket, and we will need
	 BUCKETCOUNT - 1 extra entries.  */
      if (dynsymcount >= 4)
	bucketcount = dynsymcount / 4;
      else if (dynsymcount > 0)
	bucketcount = dynsymcount;
      else
	bucketcount = 1;
      s = bfd_get_section_by_name (dynobj, ".hash");
      BFD_ASSERT (s != NULL);
      hashalloc = (dynsymcount + bucketcount - 1) * HASH_ENTRY_SIZE;
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, hashalloc);
      if (s->contents == NULL && dynsymcount > 0)
	return FALSE;
      for (i = 0; i < bucketcount; i++)
	PUT_WORD (output_bfd, (bfd_vma) -1, s->contents + i * HASH_ENTRY_SIZE);
      s->_raw_size = bucketcount * HASH_ENTRY_SIZE;

      sunos_hash_table (info)->bucketcount = bucketcount;

      /* Scan all the symbols, place them in the dynamic symbol table,
	 and build the dynamic hash table.  We reuse dynsymcount as a
	 counter for the number of symbols we have added so far.  */
      sunos_hash_table (info)->dynsymcount = 0;
      sunos_link_hash_traverse (sunos_hash_table (info),
				sunos_scan_dynamic_symbol,
				(PTR) info);
      BFD_ASSERT (sunos_hash_table (info)->dynsymcount == dynsymcount);

      /* The SunOS native linker seems to align the total size of the
	 symbol strings to a multiple of 8.  I don't know if this is
	 important, but it can't hurt much.  */
      s = bfd_get_section_by_name (dynobj, ".dynstr");
      BFD_ASSERT (s != NULL);
      if ((s->_raw_size & 7) != 0)
	{
	  bfd_size_type add;
	  bfd_byte *contents;

	  add = 8 - (s->_raw_size & 7);
	  contents = (bfd_byte *) bfd_realloc (s->contents,
					       s->_raw_size + add);
	  if (contents == NULL)
	    return FALSE;
	  memset (contents + s->_raw_size, 0, (size_t) add);
	  s->contents = contents;
	  s->_raw_size += add;
	}
    }

  /* Now that we have worked out the sizes of the procedure linkage
     table and the dynamic relocs, allocate storage for them.  */
  s = bfd_get_section_by_name (dynobj, ".plt");
  BFD_ASSERT (s != NULL);
  if (s->_raw_size != 0)
    {
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->_raw_size);
      if (s->contents == NULL)
	return FALSE;

      /* Fill in the first entry in the table.  */
      switch (bfd_get_arch (dynobj))
	{
	case bfd_arch_sparc:
	  memcpy (s->contents, sparc_plt_first_entry, SPARC_PLT_ENTRY_SIZE);
	  break;

	case bfd_arch_m68k:
	  memcpy (s->contents, m68k_plt_first_entry, M68K_PLT_ENTRY_SIZE);
	  break;

	default:
	  abort ();
	}
    }

  s = bfd_get_section_by_name (dynobj, ".dynrel");
  if (s->_raw_size != 0)
    {
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->_raw_size);
      if (s->contents == NULL)
	return FALSE;
    }
  /* We use the reloc_count field to keep track of how many of the
     relocs we have output so far.  */
  s->reloc_count = 0;

  /* Make space for the global offset table.  */
  s = bfd_get_section_by_name (dynobj, ".got");
  s->contents = (bfd_byte *) bfd_alloc (dynobj, s->_raw_size);
  if (s->contents == NULL)
    return FALSE;

  *sneedptr = bfd_get_section_by_name (dynobj, ".need");
  *srulesptr = bfd_get_section_by_name (dynobj, ".rules");

  return TRUE;
}

/* Scan the relocs for an input section.  */

static bfd_boolean
sunos_scan_relocs (info, abfd, sec, rel_size)
     struct bfd_link_info *info;
     bfd *abfd;
     asection *sec;
     bfd_size_type rel_size;
{
  PTR relocs;
  PTR free_relocs = NULL;

  if (rel_size == 0)
    return TRUE;

  if (! info->keep_memory)
    relocs = free_relocs = bfd_malloc (rel_size);
  else
    {
      struct aout_section_data_struct *n;
      bfd_size_type amt = sizeof (struct aout_section_data_struct);

      n = (struct aout_section_data_struct *) bfd_alloc (abfd, amt);
      if (n == NULL)
	relocs = NULL;
      else
	{
	  set_aout_section_data (sec, n);
	  relocs = bfd_malloc (rel_size);
	  aout_section_data (sec)->relocs = relocs;
	}
    }
  if (relocs == NULL)
    return FALSE;

  if (bfd_seek (abfd, sec->rel_filepos, SEEK_SET) != 0
      || bfd_bread (relocs, rel_size, abfd) != rel_size)
    goto error_return;

  if (obj_reloc_entry_size (abfd) == RELOC_STD_SIZE)
    {
      if (! sunos_scan_std_relocs (info, abfd, sec,
				   (struct reloc_std_external *) relocs,
				   rel_size))
	goto error_return;
    }
  else
    {
      if (! sunos_scan_ext_relocs (info, abfd, sec,
				   (struct reloc_ext_external *) relocs,
				   rel_size))
	goto error_return;
    }

  if (free_relocs != NULL)
    free (free_relocs);

  return TRUE;

 error_return:
  if (free_relocs != NULL)
    free (free_relocs);
  return FALSE;
}

/* Scan the relocs for an input section using standard relocs.  We
   need to figure out what to do for each reloc against a dynamic
   symbol.  If the symbol is in the .text section, an entry is made in
   the procedure linkage table.  Note that this will do the wrong
   thing if the symbol is actually data; I don't think the Sun 3
   native linker handles this case correctly either.  If the symbol is
   not in the .text section, we must preserve the reloc as a dynamic
   reloc.  FIXME: We should also handle the PIC relocs here by
   building global offset table entries.  */

static bfd_boolean
sunos_scan_std_relocs (info, abfd, sec, relocs, rel_size)
     struct bfd_link_info *info;
     bfd *abfd;
     asection *sec ATTRIBUTE_UNUSED;
     const struct reloc_std_external *relocs;
     bfd_size_type rel_size;
{
  bfd *dynobj;
  asection *splt = NULL;
  asection *srel = NULL;
  struct sunos_link_hash_entry **sym_hashes;
  const struct reloc_std_external *rel, *relend;

  /* We only know how to handle m68k plt entries.  */
  if (bfd_get_arch (abfd) != bfd_arch_m68k)
    {
      bfd_set_error (bfd_error_invalid_target);
      return FALSE;
    }

  dynobj = NULL;

  sym_hashes = (struct sunos_link_hash_entry **) obj_aout_sym_hashes (abfd);

  relend = relocs + rel_size / RELOC_STD_SIZE;
  for (rel = relocs; rel < relend; rel++)
    {
      int r_index;
      struct sunos_link_hash_entry *h;

      /* We only want relocs against external symbols.  */
      if (bfd_header_big_endian (abfd))
	{
	  if ((rel->r_type[0] & RELOC_STD_BITS_EXTERN_BIG) == 0)
	    continue;
	}
      else
	{
	  if ((rel->r_type[0] & RELOC_STD_BITS_EXTERN_LITTLE) == 0)
	    continue;
	}

      /* Get the symbol index.  */
      if (bfd_header_big_endian (abfd))
	r_index = ((rel->r_index[0] << 16)
		   | (rel->r_index[1] << 8)
		   | rel->r_index[2]);
      else
	r_index = ((rel->r_index[2] << 16)
		   | (rel->r_index[1] << 8)
		   | rel->r_index[0]);

      /* Get the hash table entry.  */
      h = sym_hashes[r_index];
      if (h == NULL)
	{
	  /* This should not normally happen, but it will in any case
	     be caught in the relocation phase.  */
	  continue;
	}

      /* At this point common symbols have already been allocated, so
	 we don't have to worry about them.  We need to consider that
	 we may have already seen this symbol and marked it undefined;
	 if the symbol is really undefined, then SUNOS_DEF_DYNAMIC
	 will be zero.  */
      if (h->root.root.type != bfd_link_hash_defined
	  && h->root.root.type != bfd_link_hash_defweak
	  && h->root.root.type != bfd_link_hash_undefined)
	continue;

      if ((h->flags & SUNOS_DEF_DYNAMIC) == 0
	  || (h->flags & SUNOS_DEF_REGULAR) != 0)
	continue;

      if (dynobj == NULL)
	{
	  asection *sgot;

	  if (! sunos_create_dynamic_sections (abfd, info, FALSE))
	    return FALSE;
	  dynobj = sunos_hash_table (info)->dynobj;
	  splt = bfd_get_section_by_name (dynobj, ".plt");
	  srel = bfd_get_section_by_name (dynobj, ".dynrel");
	  BFD_ASSERT (splt != NULL && srel != NULL);

	  sgot = bfd_get_section_by_name (dynobj, ".got");
	  BFD_ASSERT (sgot != NULL);
	  if (sgot->_raw_size == 0)
	    sgot->_raw_size = BYTES_IN_WORD;
	  sunos_hash_table (info)->got_needed = TRUE;
	}

      BFD_ASSERT ((h->flags & SUNOS_REF_REGULAR) != 0);
      BFD_ASSERT (h->plt_offset != 0
		  || ((h->root.root.type == bfd_link_hash_defined
		       || h->root.root.type == bfd_link_hash_defweak)
		      ? (h->root.root.u.def.section->owner->flags
			 & DYNAMIC) != 0
		      : (h->root.root.u.undef.abfd->flags & DYNAMIC) != 0));

      /* This reloc is against a symbol defined only by a dynamic
	 object.  */

      if (h->root.root.type == bfd_link_hash_undefined)
	{
	  /* Presumably this symbol was marked as being undefined by
	     an earlier reloc.  */
	  srel->_raw_size += RELOC_STD_SIZE;
	}
      else if ((h->root.root.u.def.section->flags & SEC_CODE) == 0)
	{
	  bfd *sub;

	  /* This reloc is not in the .text section.  It must be
	     copied into the dynamic relocs.  We mark the symbol as
	     being undefined.  */
	  srel->_raw_size += RELOC_STD_SIZE;
	  sub = h->root.root.u.def.section->owner;
	  h->root.root.type = bfd_link_hash_undefined;
	  h->root.root.u.undef.abfd = sub;
	}
      else
	{
	  /* This symbol is in the .text section.  We must give it an
	     entry in the procedure linkage table, if we have not
	     already done so.  We change the definition of the symbol
	     to the .plt section; this will cause relocs against it to
	     be handled correctly.  */
	  if (h->plt_offset == 0)
	    {
	      if (splt->_raw_size == 0)
		splt->_raw_size = M68K_PLT_ENTRY_SIZE;
	      h->plt_offset = splt->_raw_size;

	      if ((h->flags & SUNOS_DEF_REGULAR) == 0)
		{
		  h->root.root.u.def.section = splt;
		  h->root.root.u.def.value = splt->_raw_size;
		}

	      splt->_raw_size += M68K_PLT_ENTRY_SIZE;

	      /* We may also need a dynamic reloc entry.  */
	      if ((h->flags & SUNOS_DEF_REGULAR) == 0)
		srel->_raw_size += RELOC_STD_SIZE;
	    }
	}
    }

  return TRUE;
}

/* Scan the relocs for an input section using extended relocs.  We
   need to figure out what to do for each reloc against a dynamic
   symbol.  If the reloc is a WDISP30, and the symbol is in the .text
   section, an entry is made in the procedure linkage table.
   Otherwise, we must preserve the reloc as a dynamic reloc.  */

static bfd_boolean
sunos_scan_ext_relocs (info, abfd, sec, relocs, rel_size)
     struct bfd_link_info *info;
     bfd *abfd;
     asection *sec ATTRIBUTE_UNUSED;
     const struct reloc_ext_external *relocs;
     bfd_size_type rel_size;
{
  bfd *dynobj;
  struct sunos_link_hash_entry **sym_hashes;
  const struct reloc_ext_external *rel, *relend;
  asection *splt = NULL;
  asection *sgot = NULL;
  asection *srel = NULL;
  bfd_size_type amt;

  /* We only know how to handle SPARC plt entries.  */
  if (bfd_get_arch (abfd) != bfd_arch_sparc)
    {
      bfd_set_error (bfd_error_invalid_target);
      return FALSE;
    }

  dynobj = NULL;

  sym_hashes = (struct sunos_link_hash_entry **) obj_aout_sym_hashes (abfd);

  relend = relocs + rel_size / RELOC_EXT_SIZE;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned int r_index;
      int r_extern;
      int r_type;
      struct sunos_link_hash_entry *h = NULL;

      /* Swap in the reloc information.  */
      if (bfd_header_big_endian (abfd))
	{
	  r_index = ((rel->r_index[0] << 16)
		     | (rel->r_index[1] << 8)
		     | rel->r_index[2]);
	  r_extern = (0 != (rel->r_type[0] & RELOC_EXT_BITS_EXTERN_BIG));
	  r_type = ((rel->r_type[0] & RELOC_EXT_BITS_TYPE_BIG)
		    >> RELOC_EXT_BITS_TYPE_SH_BIG);
	}
      else
	{
	  r_index = ((rel->r_index[2] << 16)
		     | (rel->r_index[1] << 8)
		     | rel->r_index[0]);
	  r_extern = (0 != (rel->r_type[0] & RELOC_EXT_BITS_EXTERN_LITTLE));
	  r_type = ((rel->r_type[0] & RELOC_EXT_BITS_TYPE_LITTLE)
		    >> RELOC_EXT_BITS_TYPE_SH_LITTLE);
	}

      if (r_extern)
	{
	  h = sym_hashes[r_index];
	  if (h == NULL)
	    {
	      /* This should not normally happen, but it will in any
		 case be caught in the relocation phase.  */
	      continue;
	    }
	}

      /* If this is a base relative reloc, we need to make an entry in
	 the .got section.  */
      if (r_type == RELOC_BASE10
	  || r_type == RELOC_BASE13
	  || r_type == RELOC_BASE22)
	{
	  if (dynobj == NULL)
	    {
	      if (! sunos_create_dynamic_sections (abfd, info, FALSE))
		return FALSE;
	      dynobj = sunos_hash_table (info)->dynobj;
	      splt = bfd_get_section_by_name (dynobj, ".plt");
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      srel = bfd_get_section_by_name (dynobj, ".dynrel");
	      BFD_ASSERT (splt != NULL && sgot != NULL && srel != NULL);

	      /* Make sure we have an initial entry in the .got table.  */
	      if (sgot->_raw_size == 0)
		sgot->_raw_size = BYTES_IN_WORD;
	      sunos_hash_table (info)->got_needed = TRUE;
	    }

	  if (r_extern)
	    {
	      if (h->got_offset != 0)
		continue;

	      h->got_offset = sgot->_raw_size;
	    }
	  else
	    {
	      if (r_index >= bfd_get_symcount (abfd))
		{
		  /* This is abnormal, but should be caught in the
		     relocation phase.  */
		  continue;
		}

	      if (adata (abfd).local_got_offsets == NULL)
		{
		  amt = bfd_get_symcount (abfd);
		  amt *= sizeof (bfd_vma);
		  adata (abfd).local_got_offsets =
		    (bfd_vma *) bfd_zalloc (abfd, amt);
		  if (adata (abfd).local_got_offsets == NULL)
		    return FALSE;
		}

	      if (adata (abfd).local_got_offsets[r_index] != 0)
		continue;

	      adata (abfd).local_got_offsets[r_index] = sgot->_raw_size;
	    }

	  sgot->_raw_size += BYTES_IN_WORD;

	  /* If we are making a shared library, or if the symbol is
	     defined by a dynamic object, we will need a dynamic reloc
	     entry.  */
	  if (info->shared
	      || (h != NULL
		  && (h->flags & SUNOS_DEF_DYNAMIC) != 0
		  && (h->flags & SUNOS_DEF_REGULAR) == 0))
	    srel->_raw_size += RELOC_EXT_SIZE;

	  continue;
	}

      /* Otherwise, we are only interested in relocs against symbols
	 defined in dynamic objects but not in regular objects.  We
	 only need to consider relocs against external symbols.  */
      if (! r_extern)
	{
	  /* But, if we are creating a shared library, we need to
	     generate an absolute reloc.  */
	  if (info->shared)
	    {
	      if (dynobj == NULL)
		{
		  if (! sunos_create_dynamic_sections (abfd, info, TRUE))
		    return FALSE;
		  dynobj = sunos_hash_table (info)->dynobj;
		  splt = bfd_get_section_by_name (dynobj, ".plt");
		  sgot = bfd_get_section_by_name (dynobj, ".got");
		  srel = bfd_get_section_by_name (dynobj, ".dynrel");
		  BFD_ASSERT (splt != NULL && sgot != NULL && srel != NULL);
		}

	      srel->_raw_size += RELOC_EXT_SIZE;
	    }

	  continue;
	}

      /* At this point common symbols have already been allocated, so
	 we don't have to worry about them.  We need to consider that
	 we may have already seen this symbol and marked it undefined;
	 if the symbol is really undefined, then SUNOS_DEF_DYNAMIC
	 will be zero.  */
      if (h->root.root.type != bfd_link_hash_defined
	  && h->root.root.type != bfd_link_hash_defweak
	  && h->root.root.type != bfd_link_hash_undefined)
	continue;

      if (r_type != RELOC_JMP_TBL
	  && ! info->shared
	  && ((h->flags & SUNOS_DEF_DYNAMIC) == 0
	      || (h->flags & SUNOS_DEF_REGULAR) != 0))
	continue;

      if (r_type == RELOC_JMP_TBL
	  && ! info->shared
	  && (h->flags & SUNOS_DEF_DYNAMIC) == 0
	  && (h->flags & SUNOS_DEF_REGULAR) == 0)
	{
	  /* This symbol is apparently undefined.  Don't do anything
	     here; just let the relocation routine report an undefined
	     symbol.  */
	  continue;
	}

      if (strcmp (h->root.root.root.string, "__GLOBAL_OFFSET_TABLE_") == 0)
	continue;

      if (dynobj == NULL)
	{
	  if (! sunos_create_dynamic_sections (abfd, info, FALSE))
	    return FALSE;
	  dynobj = sunos_hash_table (info)->dynobj;
	  splt = bfd_get_section_by_name (dynobj, ".plt");
	  sgot = bfd_get_section_by_name (dynobj, ".got");
	  srel = bfd_get_section_by_name (dynobj, ".dynrel");
	  BFD_ASSERT (splt != NULL && sgot != NULL && srel != NULL);

	  /* Make sure we have an initial entry in the .got table.  */
	  if (sgot->_raw_size == 0)
	    sgot->_raw_size = BYTES_IN_WORD;
	  sunos_hash_table (info)->got_needed = TRUE;
	}

      BFD_ASSERT (r_type == RELOC_JMP_TBL
		  || info->shared
		  || (h->flags & SUNOS_REF_REGULAR) != 0);
      BFD_ASSERT (r_type == RELOC_JMP_TBL
		  || info->shared
		  || h->plt_offset != 0
		  || ((h->root.root.type == bfd_link_hash_defined
		       || h->root.root.type == bfd_link_hash_defweak)
		      ? (h->root.root.u.def.section->owner->flags
			 & DYNAMIC) != 0
		      : (h->root.root.u.undef.abfd->flags & DYNAMIC) != 0));

      /* This reloc is against a symbol defined only by a dynamic
	 object, or it is a jump table reloc from PIC compiled code.  */

      if (r_type != RELOC_JMP_TBL
	  && h->root.root.type == bfd_link_hash_undefined)
	{
	  /* Presumably this symbol was marked as being undefined by
	     an earlier reloc.  */
	  srel->_raw_size += RELOC_EXT_SIZE;
	}
      else if (r_type != RELOC_JMP_TBL
	       && (h->root.root.u.def.section->flags & SEC_CODE) == 0)
	{
	  bfd *sub;

	  /* This reloc is not in the .text section.  It must be
	     copied into the dynamic relocs.  We mark the symbol as
	     being undefined.  */
	  srel->_raw_size += RELOC_EXT_SIZE;
	  if ((h->flags & SUNOS_DEF_REGULAR) == 0)
	    {
	      sub = h->root.root.u.def.section->owner;
	      h->root.root.type = bfd_link_hash_undefined;
	      h->root.root.u.undef.abfd = sub;
	    }
	}
      else
	{
	  /* This symbol is in the .text section.  We must give it an
	     entry in the procedure linkage table, if we have not
	     already done so.  We change the definition of the symbol
	     to the .plt section; this will cause relocs against it to
	     be handled correctly.  */
	  if (h->plt_offset == 0)
	    {
	      if (splt->_raw_size == 0)
		splt->_raw_size = SPARC_PLT_ENTRY_SIZE;
	      h->plt_offset = splt->_raw_size;

	      if ((h->flags & SUNOS_DEF_REGULAR) == 0)
		{
		  if (h->root.root.type == bfd_link_hash_undefined)
		    h->root.root.type = bfd_link_hash_defined;
		  h->root.root.u.def.section = splt;
		  h->root.root.u.def.value = splt->_raw_size;
		}

	      splt->_raw_size += SPARC_PLT_ENTRY_SIZE;

	      /* We will also need a dynamic reloc entry, unless this
		 is a JMP_TBL reloc produced by linking PIC compiled
		 code, and we are not making a shared library.  */
	      if (info->shared || (h->flags & SUNOS_DEF_REGULAR) == 0)
		srel->_raw_size += RELOC_EXT_SIZE;
	    }

	  /* If we are creating a shared library, we need to copy over
	     any reloc other than a jump table reloc.  */
	  if (info->shared && r_type != RELOC_JMP_TBL)
	    srel->_raw_size += RELOC_EXT_SIZE;
	}
    }

  return TRUE;
}

/* Build the hash table of dynamic symbols, and to mark as written all
   symbols from dynamic objects which we do not plan to write out.  */

static bfd_boolean
sunos_scan_dynamic_symbol (h, data)
     struct sunos_link_hash_entry *h;
     PTR data;
{
  struct bfd_link_info *info = (struct bfd_link_info *) data;

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct sunos_link_hash_entry *) h->root.root.u.i.link;

  /* Set the written flag for symbols we do not want to write out as
     part of the regular symbol table.  This is all symbols which are
     not defined in a regular object file.  For some reason symbols
     which are referenced by a regular object and defined by a dynamic
     object do not seem to show up in the regular symbol table.  It is
     possible for a symbol to have only SUNOS_REF_REGULAR set here, it
     is an undefined symbol which was turned into a common symbol
     because it was found in an archive object which was not included
     in the link.  */
  if ((h->flags & SUNOS_DEF_REGULAR) == 0
      && (h->flags & SUNOS_DEF_DYNAMIC) != 0
      && strcmp (h->root.root.root.string, "__DYNAMIC") != 0)
    h->root.written = TRUE;

  /* If this symbol is defined by a dynamic object and referenced by a
     regular object, see whether we gave it a reasonable value while
     scanning the relocs.  */

  if ((h->flags & SUNOS_DEF_REGULAR) == 0
      && (h->flags & SUNOS_DEF_DYNAMIC) != 0
      && (h->flags & SUNOS_REF_REGULAR) != 0)
    {
      if ((h->root.root.type == bfd_link_hash_defined
	   || h->root.root.type == bfd_link_hash_defweak)
	  && ((h->root.root.u.def.section->owner->flags & DYNAMIC) != 0)
	  && h->root.root.u.def.section->output_section == NULL)
	{
	  bfd *sub;

	  /* This symbol is currently defined in a dynamic section
	     which is not being put into the output file.  This
	     implies that there is no reloc against the symbol.  I'm
	     not sure why this case would ever occur.  In any case, we
	     change the symbol to be undefined.  */
	  sub = h->root.root.u.def.section->owner;
	  h->root.root.type = bfd_link_hash_undefined;
	  h->root.root.u.undef.abfd = sub;
	}
    }

  /* If this symbol is defined or referenced by a regular file, add it
     to the dynamic symbols.  */
  if ((h->flags & (SUNOS_DEF_REGULAR | SUNOS_REF_REGULAR)) != 0)
    {
      asection *s;
      size_t len;
      bfd_byte *contents;
      unsigned char *name;
      unsigned long hash;
      bfd *dynobj;

      BFD_ASSERT (h->dynindx == -2);

      dynobj = sunos_hash_table (info)->dynobj;

      h->dynindx = sunos_hash_table (info)->dynsymcount;
      ++sunos_hash_table (info)->dynsymcount;

      len = strlen (h->root.root.root.string);

      /* We don't bother to construct a BFD hash table for the strings
	 which are the names of the dynamic symbols.  Using a hash
	 table for the regular symbols is beneficial, because the
	 regular symbols includes the debugging symbols, which have
	 long names and are often duplicated in several object files.
	 There are no debugging symbols in the dynamic symbols.  */
      s = bfd_get_section_by_name (dynobj, ".dynstr");
      BFD_ASSERT (s != NULL);
      contents = (bfd_byte *) bfd_realloc (s->contents,
					   s->_raw_size + len + 1);
      if (contents == NULL)
	return FALSE;
      s->contents = contents;

      h->dynstr_index = s->_raw_size;
      strcpy ((char *) contents + s->_raw_size, h->root.root.root.string);
      s->_raw_size += len + 1;

      /* Add it to the dynamic hash table.  */
      name = (unsigned char *) h->root.root.root.string;
      hash = 0;
      while (*name != '\0')
	hash = (hash << 1) + *name++;
      hash &= 0x7fffffff;
      hash %= sunos_hash_table (info)->bucketcount;

      s = bfd_get_section_by_name (dynobj, ".hash");
      BFD_ASSERT (s != NULL);

      if (GET_SWORD (dynobj, s->contents + hash * HASH_ENTRY_SIZE) == -1)
	PUT_WORD (dynobj, h->dynindx, s->contents + hash * HASH_ENTRY_SIZE);
      else
	{
	  bfd_vma next;

	  next = GET_WORD (dynobj,
			   (s->contents
			    + hash * HASH_ENTRY_SIZE
			    + BYTES_IN_WORD));
	  PUT_WORD (dynobj, s->_raw_size / HASH_ENTRY_SIZE,
		    s->contents + hash * HASH_ENTRY_SIZE + BYTES_IN_WORD);
	  PUT_WORD (dynobj, h->dynindx, s->contents + s->_raw_size);
	  PUT_WORD (dynobj, next, s->contents + s->_raw_size + BYTES_IN_WORD);
	  s->_raw_size += HASH_ENTRY_SIZE;
	}
    }

  return TRUE;
}

/* Link a dynamic object.  We actually don't have anything to do at
   this point.  This entry point exists to prevent the regular linker
   code from doing anything with the object.  */

static bfd_boolean
sunos_link_dynamic_object (info, abfd)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     bfd *abfd ATTRIBUTE_UNUSED;
{
  return TRUE;
}

/* Write out a dynamic symbol.  This is called by the final traversal
   over the symbol table.  */

static bfd_boolean
sunos_write_dynamic_symbol (output_bfd, info, harg)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct aout_link_hash_entry *harg;
{
  struct sunos_link_hash_entry *h = (struct sunos_link_hash_entry *) harg;
  int type;
  bfd_vma val;
  asection *s;
  struct external_nlist *outsym;

  /* If this symbol is in the procedure linkage table, fill in the
     table entry.  */
  if (h->plt_offset != 0)
    {
      bfd *dynobj;
      asection *splt;
      bfd_byte *p;
      bfd_vma r_address;

      dynobj = sunos_hash_table (info)->dynobj;
      splt = bfd_get_section_by_name (dynobj, ".plt");
      p = splt->contents + h->plt_offset;

      s = bfd_get_section_by_name (dynobj, ".dynrel");

      r_address = (splt->output_section->vma
		   + splt->output_offset
		   + h->plt_offset);

      switch (bfd_get_arch (output_bfd))
	{
	case bfd_arch_sparc:
	  if (info->shared || (h->flags & SUNOS_DEF_REGULAR) == 0)
	    {
	      bfd_put_32 (output_bfd, SPARC_PLT_ENTRY_WORD0, p);
	      bfd_put_32 (output_bfd,
			  (SPARC_PLT_ENTRY_WORD1
			   + (((- (h->plt_offset + 4) >> 2)
			       & 0x3fffffff))),
			  p + 4);
	      bfd_put_32 (output_bfd, SPARC_PLT_ENTRY_WORD2 + s->reloc_count,
			  p + 8);
	    }
	  else
	    {
	      val = (h->root.root.u.def.section->output_section->vma
		     + h->root.root.u.def.section->output_offset
		     + h->root.root.u.def.value);
	      bfd_put_32 (output_bfd,
			  SPARC_PLT_PIC_WORD0 + ((val >> 10) & 0x3fffff),
			  p);
	      bfd_put_32 (output_bfd,
			  SPARC_PLT_PIC_WORD1 + (val & 0x3ff),
			  p + 4);
	      bfd_put_32 (output_bfd, SPARC_PLT_PIC_WORD2, p + 8);
	    }
	  break;

	case bfd_arch_m68k:
	  if (! info->shared && (h->flags & SUNOS_DEF_REGULAR) != 0)
	    abort ();
	  bfd_put_16 (output_bfd, M68K_PLT_ENTRY_WORD0, p);
	  bfd_put_32 (output_bfd, (- (h->plt_offset + 2)), p + 2);
	  bfd_put_16 (output_bfd, (bfd_vma) s->reloc_count, p + 6);
	  r_address += 2;
	  break;

	default:
	  abort ();
	}

      /* We also need to add a jump table reloc, unless this is the
	 result of a JMP_TBL reloc from PIC compiled code.  */
      if (info->shared || (h->flags & SUNOS_DEF_REGULAR) == 0)
	{
	  BFD_ASSERT (h->dynindx >= 0);
	  BFD_ASSERT (s->reloc_count * obj_reloc_entry_size (dynobj)
		      < s->_raw_size);
	  p = s->contents + s->reloc_count * obj_reloc_entry_size (output_bfd);
	  if (obj_reloc_entry_size (output_bfd) == RELOC_STD_SIZE)
	    {
	      struct reloc_std_external *srel;

	      srel = (struct reloc_std_external *) p;
	      PUT_WORD (output_bfd, r_address, srel->r_address);
	      if (bfd_header_big_endian (output_bfd))
		{
		  srel->r_index[0] = (bfd_byte) (h->dynindx >> 16);
		  srel->r_index[1] = (bfd_byte) (h->dynindx >> 8);
		  srel->r_index[2] = (bfd_byte) (h->dynindx);
		  srel->r_type[0] = (RELOC_STD_BITS_EXTERN_BIG
				     | RELOC_STD_BITS_JMPTABLE_BIG);
		}
	      else
		{
		  srel->r_index[2] = (bfd_byte) (h->dynindx >> 16);
		  srel->r_index[1] = (bfd_byte) (h->dynindx >> 8);
		  srel->r_index[0] = (bfd_byte)h->dynindx;
		  srel->r_type[0] = (RELOC_STD_BITS_EXTERN_LITTLE
				     | RELOC_STD_BITS_JMPTABLE_LITTLE);
		}
	    }
	  else
	    {
	      struct reloc_ext_external *erel;

	      erel = (struct reloc_ext_external *) p;
	      PUT_WORD (output_bfd, r_address, erel->r_address);
	      if (bfd_header_big_endian (output_bfd))
		{
		  erel->r_index[0] = (bfd_byte) (h->dynindx >> 16);
		  erel->r_index[1] = (bfd_byte) (h->dynindx >> 8);
		  erel->r_index[2] = (bfd_byte)h->dynindx;
		  erel->r_type[0] =
		    (RELOC_EXT_BITS_EXTERN_BIG
		     | (RELOC_JMP_SLOT << RELOC_EXT_BITS_TYPE_SH_BIG));
		}
	      else
		{
		  erel->r_index[2] = (bfd_byte) (h->dynindx >> 16);
		  erel->r_index[1] = (bfd_byte) (h->dynindx >> 8);
		  erel->r_index[0] = (bfd_byte)h->dynindx;
		  erel->r_type[0] =
		    (RELOC_EXT_BITS_EXTERN_LITTLE
		     | (RELOC_JMP_SLOT << RELOC_EXT_BITS_TYPE_SH_LITTLE));
		}
	      PUT_WORD (output_bfd, (bfd_vma) 0, erel->r_addend);
	    }

	  ++s->reloc_count;
	}
    }

  /* If this is not a dynamic symbol, we don't have to do anything
     else.  We only check this after handling the PLT entry, because
     we can have a PLT entry for a nondynamic symbol when linking PIC
     compiled code from a regular object.  */
  if (h->dynindx < 0)
    return TRUE;

  switch (h->root.root.type)
    {
    default:
    case bfd_link_hash_new:
      abort ();
      /* Avoid variable not initialized warnings.  */
      return TRUE;
    case bfd_link_hash_undefined:
      type = N_UNDF | N_EXT;
      val = 0;
      break;
    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      {
	asection *sec;
	asection *output_section;

	sec = h->root.root.u.def.section;
	output_section = sec->output_section;
	BFD_ASSERT (bfd_is_abs_section (output_section)
		    || output_section->owner == output_bfd);
	if (h->plt_offset != 0
	    && (h->flags & SUNOS_DEF_REGULAR) == 0)
	  {
	    type = N_UNDF | N_EXT;
	    val = 0;
	  }
	else
	  {
	    if (output_section == obj_textsec (output_bfd))
	      type = (h->root.root.type == bfd_link_hash_defined
		      ? N_TEXT
		      : N_WEAKT);
	    else if (output_section == obj_datasec (output_bfd))
	      type = (h->root.root.type == bfd_link_hash_defined
		      ? N_DATA
		      : N_WEAKD);
	    else if (output_section == obj_bsssec (output_bfd))
	      type = (h->root.root.type == bfd_link_hash_defined
		      ? N_BSS
		      : N_WEAKB);
	    else
	      type = (h->root.root.type == bfd_link_hash_defined
		      ? N_ABS
		      : N_WEAKA);
	    type |= N_EXT;
	    val = (h->root.root.u.def.value
		   + output_section->vma
		   + sec->output_offset);
	  }
      }
      break;
    case bfd_link_hash_common:
      type = N_UNDF | N_EXT;
      val = h->root.root.u.c.size;
      break;
    case bfd_link_hash_undefweak:
      type = N_WEAKU;
      val = 0;
      break;
    case bfd_link_hash_indirect:
    case bfd_link_hash_warning:
      /* FIXME: Ignore these for now.  The circumstances under which
	 they should be written out are not clear to me.  */
      return TRUE;
    }

  s = bfd_get_section_by_name (sunos_hash_table (info)->dynobj, ".dynsym");
  BFD_ASSERT (s != NULL);
  outsym = ((struct external_nlist *)
	    (s->contents + h->dynindx * EXTERNAL_NLIST_SIZE));

  H_PUT_8 (output_bfd, type, outsym->e_type);
  H_PUT_8 (output_bfd, 0, outsym->e_other);

  /* FIXME: The native linker doesn't use 0 for desc.  It seems to use
     one less than the desc value in the shared library, although that
     seems unlikely.  */
  H_PUT_16 (output_bfd, 0, outsym->e_desc);

  PUT_WORD (output_bfd, h->dynstr_index, outsym->e_strx);
  PUT_WORD (output_bfd, val, outsym->e_value);

  return TRUE;
}

/* This is called for each reloc against an external symbol.  If this
   is a reloc which are are going to copy as a dynamic reloc, then
   copy it over, and tell the caller to not bother processing this
   reloc.  */

static bfd_boolean
sunos_check_dynamic_reloc (info, input_bfd, input_section, harg, reloc,
			   contents, skip, relocationp)
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     struct aout_link_hash_entry *harg;
     PTR reloc;
     bfd_byte *contents ATTRIBUTE_UNUSED;
     bfd_boolean *skip;
     bfd_vma *relocationp;
{
  struct sunos_link_hash_entry *h = (struct sunos_link_hash_entry *) harg;
  bfd *dynobj;
  bfd_boolean baserel;
  bfd_boolean jmptbl;
  bfd_boolean pcrel;
  asection *s;
  bfd_byte *p;
  long indx;

  *skip = FALSE;

  dynobj = sunos_hash_table (info)->dynobj;

  if (h != NULL
      && h->plt_offset != 0
      && (info->shared
	  || (h->flags & SUNOS_DEF_REGULAR) == 0))
    {
      asection *splt;

      /* Redirect the relocation to the PLT entry.  */
      splt = bfd_get_section_by_name (dynobj, ".plt");
      *relocationp = (splt->output_section->vma
		      + splt->output_offset
		      + h->plt_offset);
    }

  if (obj_reloc_entry_size (input_bfd) == RELOC_STD_SIZE)
    {
      struct reloc_std_external *srel;

      srel = (struct reloc_std_external *) reloc;
      if (bfd_header_big_endian (input_bfd))
	{
	  baserel = (0 != (srel->r_type[0] & RELOC_STD_BITS_BASEREL_BIG));
	  jmptbl = (0 != (srel->r_type[0] & RELOC_STD_BITS_JMPTABLE_BIG));
	  pcrel = (0 != (srel->r_type[0] & RELOC_STD_BITS_PCREL_BIG));
	}
      else
	{
	  baserel = (0 != (srel->r_type[0] & RELOC_STD_BITS_BASEREL_LITTLE));
	  jmptbl = (0 != (srel->r_type[0] & RELOC_STD_BITS_JMPTABLE_LITTLE));
	  pcrel = (0 != (srel->r_type[0] & RELOC_STD_BITS_PCREL_LITTLE));
	}
    }
  else
    {
      struct reloc_ext_external *erel;
      int r_type;

      erel = (struct reloc_ext_external *) reloc;
      if (bfd_header_big_endian (input_bfd))
	r_type = ((erel->r_type[0] & RELOC_EXT_BITS_TYPE_BIG)
		  >> RELOC_EXT_BITS_TYPE_SH_BIG);
      else
	r_type = ((erel->r_type[0] & RELOC_EXT_BITS_TYPE_LITTLE)
		  >> RELOC_EXT_BITS_TYPE_SH_LITTLE);
      baserel = (r_type == RELOC_BASE10
		 || r_type == RELOC_BASE13
		 || r_type == RELOC_BASE22);
      jmptbl = r_type == RELOC_JMP_TBL;
      pcrel = (r_type == RELOC_DISP8
	       || r_type == RELOC_DISP16
	       || r_type == RELOC_DISP32
	       || r_type == RELOC_WDISP30
	       || r_type == RELOC_WDISP22);
      /* We don't consider the PC10 and PC22 types to be PC relative,
	 because they are pcrel_offset.  */
    }

  if (baserel)
    {
      bfd_vma *got_offsetp;
      asection *sgot;

      if (h != NULL)
	got_offsetp = &h->got_offset;
      else if (adata (input_bfd).local_got_offsets == NULL)
	got_offsetp = NULL;
      else
	{
	  struct reloc_std_external *srel;
	  int r_index;

	  srel = (struct reloc_std_external *) reloc;
	  if (obj_reloc_entry_size (input_bfd) == RELOC_STD_SIZE)
	    {
	      if (bfd_header_big_endian (input_bfd))
		r_index = ((srel->r_index[0] << 16)
			   | (srel->r_index[1] << 8)
			   | srel->r_index[2]);
	      else
		r_index = ((srel->r_index[2] << 16)
			   | (srel->r_index[1] << 8)
			   | srel->r_index[0]);
	    }
	  else
	    {
	      struct reloc_ext_external *erel;

	      erel = (struct reloc_ext_external *) reloc;
	      if (bfd_header_big_endian (input_bfd))
		r_index = ((erel->r_index[0] << 16)
			   | (erel->r_index[1] << 8)
			   | erel->r_index[2]);
	      else
		r_index = ((erel->r_index[2] << 16)
			   | (erel->r_index[1] << 8)
			   | erel->r_index[0]);
	    }

	  got_offsetp = adata (input_bfd).local_got_offsets + r_index;
	}

      BFD_ASSERT (got_offsetp != NULL && *got_offsetp != 0);

      sgot = bfd_get_section_by_name (dynobj, ".got");

      /* We set the least significant bit to indicate whether we have
	 already initialized the GOT entry.  */
      if ((*got_offsetp & 1) == 0)
	{
	  if (h == NULL
	      || (! info->shared
		  && ((h->flags & SUNOS_DEF_DYNAMIC) == 0
		      || (h->flags & SUNOS_DEF_REGULAR) != 0)))
	    PUT_WORD (dynobj, *relocationp, sgot->contents + *got_offsetp);
	  else
	    PUT_WORD (dynobj, 0, sgot->contents + *got_offsetp);

	  if (info->shared
	      || (h != NULL
		  && (h->flags & SUNOS_DEF_DYNAMIC) != 0
		  && (h->flags & SUNOS_DEF_REGULAR) == 0))
	    {
	      /* We need to create a GLOB_DAT or 32 reloc to tell the
		 dynamic linker to fill in this entry in the table.  */

	      s = bfd_get_section_by_name (dynobj, ".dynrel");
	      BFD_ASSERT (s != NULL);
	      BFD_ASSERT (s->reloc_count * obj_reloc_entry_size (dynobj)
			  < s->_raw_size);

	      p = (s->contents
		   + s->reloc_count * obj_reloc_entry_size (dynobj));

	      if (h != NULL)
		indx = h->dynindx;
	      else
		indx = 0;

	      if (obj_reloc_entry_size (dynobj) == RELOC_STD_SIZE)
		{
		  struct reloc_std_external *srel;

		  srel = (struct reloc_std_external *) p;
		  PUT_WORD (dynobj,
			    (*got_offsetp
			     + sgot->output_section->vma
			     + sgot->output_offset),
			    srel->r_address);
		  if (bfd_header_big_endian (dynobj))
		    {
		      srel->r_index[0] = (bfd_byte) (indx >> 16);
		      srel->r_index[1] = (bfd_byte) (indx >> 8);
		      srel->r_index[2] = (bfd_byte)indx;
		      if (h == NULL)
			srel->r_type[0] = 2 << RELOC_STD_BITS_LENGTH_SH_BIG;
		      else
			srel->r_type[0] =
			  (RELOC_STD_BITS_EXTERN_BIG
			   | RELOC_STD_BITS_BASEREL_BIG
			   | RELOC_STD_BITS_RELATIVE_BIG
			   | (2 << RELOC_STD_BITS_LENGTH_SH_BIG));
		    }
		  else
		    {
		      srel->r_index[2] = (bfd_byte) (indx >> 16);
		      srel->r_index[1] = (bfd_byte) (indx >> 8);
		      srel->r_index[0] = (bfd_byte)indx;
		      if (h == NULL)
			srel->r_type[0] = 2 << RELOC_STD_BITS_LENGTH_SH_LITTLE;
		      else
			srel->r_type[0] =
			  (RELOC_STD_BITS_EXTERN_LITTLE
			   | RELOC_STD_BITS_BASEREL_LITTLE
			   | RELOC_STD_BITS_RELATIVE_LITTLE
			   | (2 << RELOC_STD_BITS_LENGTH_SH_LITTLE));
		    }
		}
	      else
		{
		  struct reloc_ext_external *erel;

		  erel = (struct reloc_ext_external *) p;
		  PUT_WORD (dynobj,
			    (*got_offsetp
			     + sgot->output_section->vma
			     + sgot->output_offset),
			    erel->r_address);
		  if (bfd_header_big_endian (dynobj))
		    {
		      erel->r_index[0] = (bfd_byte) (indx >> 16);
		      erel->r_index[1] = (bfd_byte) (indx >> 8);
		      erel->r_index[2] = (bfd_byte)indx;
		      if (h == NULL)
			erel->r_type[0] =
			  RELOC_32 << RELOC_EXT_BITS_TYPE_SH_BIG;
		      else
			erel->r_type[0] =
			  (RELOC_EXT_BITS_EXTERN_BIG
			   | (RELOC_GLOB_DAT << RELOC_EXT_BITS_TYPE_SH_BIG));
		    }
		  else
		    {
		      erel->r_index[2] = (bfd_byte) (indx >> 16);
		      erel->r_index[1] = (bfd_byte) (indx >> 8);
		      erel->r_index[0] = (bfd_byte)indx;
		      if (h == NULL)
			erel->r_type[0] =
			  RELOC_32 << RELOC_EXT_BITS_TYPE_SH_LITTLE;
		      else
			erel->r_type[0] =
			  (RELOC_EXT_BITS_EXTERN_LITTLE
			   | (RELOC_GLOB_DAT
			      << RELOC_EXT_BITS_TYPE_SH_LITTLE));
		    }
		  PUT_WORD (dynobj, 0, erel->r_addend);
		}

	      ++s->reloc_count;
	    }

	  *got_offsetp |= 1;
	}

      *relocationp = (sgot->vma
		      + (*got_offsetp &~ (bfd_vma) 1)
		      - sunos_hash_table (info)->got_base);

      /* There is nothing else to do for a base relative reloc.  */
      return TRUE;
    }

  if (! sunos_hash_table (info)->dynamic_sections_needed)
    return TRUE;
  if (! info->shared)
    {
      if (h == NULL
	  || h->dynindx == -1
	  || h->root.root.type != bfd_link_hash_undefined
	  || (h->flags & SUNOS_DEF_REGULAR) != 0
	  || (h->flags & SUNOS_DEF_DYNAMIC) == 0
	  || (h->root.root.u.undef.abfd->flags & DYNAMIC) == 0)
	return TRUE;
    }
  else
    {
      if (h != NULL
	  && (h->dynindx == -1
	      || jmptbl
	      || strcmp (h->root.root.root.string,
			 "__GLOBAL_OFFSET_TABLE_") == 0))
	return TRUE;
    }

  /* It looks like this is a reloc we are supposed to copy.  */

  s = bfd_get_section_by_name (dynobj, ".dynrel");
  BFD_ASSERT (s != NULL);
  BFD_ASSERT (s->reloc_count * obj_reloc_entry_size (dynobj) < s->_raw_size);

  p = s->contents + s->reloc_count * obj_reloc_entry_size (dynobj);

  /* Copy the reloc over.  */
  memcpy (p, reloc, obj_reloc_entry_size (dynobj));

  if (h != NULL)
    indx = h->dynindx;
  else
    indx = 0;

  /* Adjust the address and symbol index.  */
  if (obj_reloc_entry_size (dynobj) == RELOC_STD_SIZE)
    {
      struct reloc_std_external *srel;

      srel = (struct reloc_std_external *) p;
      PUT_WORD (dynobj,
		(GET_WORD (dynobj, srel->r_address)
		 + input_section->output_section->vma
		 + input_section->output_offset),
		srel->r_address);
      if (bfd_header_big_endian (dynobj))
	{
	  srel->r_index[0] = (bfd_byte) (indx >> 16);
	  srel->r_index[1] = (bfd_byte) (indx >> 8);
	  srel->r_index[2] = (bfd_byte)indx;
	}
      else
	{
	  srel->r_index[2] = (bfd_byte) (indx >> 16);
	  srel->r_index[1] = (bfd_byte) (indx >> 8);
	  srel->r_index[0] = (bfd_byte)indx;
	}
      /* FIXME: We may have to change the addend for a PC relative
	 reloc.  */
    }
  else
    {
      struct reloc_ext_external *erel;

      erel = (struct reloc_ext_external *) p;
      PUT_WORD (dynobj,
		(GET_WORD (dynobj, erel->r_address)
		 + input_section->output_section->vma
		 + input_section->output_offset),
		erel->r_address);
      if (bfd_header_big_endian (dynobj))
	{
	  erel->r_index[0] = (bfd_byte) (indx >> 16);
	  erel->r_index[1] = (bfd_byte) (indx >> 8);
	  erel->r_index[2] = (bfd_byte)indx;
	}
      else
	{
	  erel->r_index[2] = (bfd_byte) (indx >> 16);
	  erel->r_index[1] = (bfd_byte) (indx >> 8);
	  erel->r_index[0] = (bfd_byte)indx;
	}
      if (pcrel && h != NULL)
	{
	  /* Adjust the addend for the change in address.  */
	  PUT_WORD (dynobj,
		    (GET_WORD (dynobj, erel->r_addend)
		     - (input_section->output_section->vma
			+ input_section->output_offset
			- input_section->vma)),
		    erel->r_addend);
	}
    }

  ++s->reloc_count;

  if (h != NULL)
    *skip = TRUE;

  return TRUE;
}

/* Finish up the dynamic linking information.  */

static bfd_boolean
sunos_finish_dynamic_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  bfd *dynobj;
  asection *o;
  asection *s;
  asection *sdyn;

  if (! sunos_hash_table (info)->dynamic_sections_needed
      && ! sunos_hash_table (info)->got_needed)
    return TRUE;

  dynobj = sunos_hash_table (info)->dynobj;

  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
  BFD_ASSERT (sdyn != NULL);

  /* Finish up the .need section.  The linker emulation code filled it
     in, but with offsets from the start of the section instead of
     real addresses.  Now that we know the section location, we can
     fill in the final values.  */
  s = bfd_get_section_by_name (dynobj, ".need");
  if (s != NULL && s->_raw_size != 0)
    {
      file_ptr filepos;
      bfd_byte *p;

      filepos = s->output_section->filepos + s->output_offset;
      p = s->contents;
      while (1)
	{
	  bfd_vma val;

	  PUT_WORD (dynobj, GET_WORD (dynobj, p) + filepos, p);
	  val = GET_WORD (dynobj, p + 12);
	  if (val == 0)
	    break;
	  PUT_WORD (dynobj, val + filepos, p + 12);
	  p += 16;
	}
    }

  /* The first entry in the .got section is the address of the
     dynamic information, unless this is a shared library.  */
  s = bfd_get_section_by_name (dynobj, ".got");
  BFD_ASSERT (s != NULL);
  if (info->shared || sdyn->_raw_size == 0)
    PUT_WORD (dynobj, 0, s->contents);
  else
    PUT_WORD (dynobj, sdyn->output_section->vma + sdyn->output_offset,
	      s->contents);

  for (o = dynobj->sections; o != NULL; o = o->next)
    {
      if ((o->flags & SEC_HAS_CONTENTS) != 0
	  && o->contents != NULL)
	{
	  BFD_ASSERT (o->output_section != NULL
		      && o->output_section->owner == abfd);
	  if (! bfd_set_section_contents (abfd, o->output_section,
					  o->contents,
					  (file_ptr) o->output_offset,
					  o->_raw_size))
	    return FALSE;
	}
    }

  if (sdyn->_raw_size > 0)
    {
      struct external_sun4_dynamic esd;
      struct external_sun4_dynamic_link esdl;
      file_ptr pos;

      /* Finish up the dynamic link information.  */
      PUT_WORD (dynobj, (bfd_vma) 3, esd.ld_version);
      PUT_WORD (dynobj,
		sdyn->output_section->vma + sdyn->output_offset + sizeof esd,
		esd.ldd);
      PUT_WORD (dynobj,
		(sdyn->output_section->vma
		 + sdyn->output_offset
		 + sizeof esd
		 + EXTERNAL_SUN4_DYNAMIC_DEBUGGER_SIZE),
		esd.ld);

      if (! bfd_set_section_contents (abfd, sdyn->output_section, &esd,
				      (file_ptr) sdyn->output_offset,
				      (bfd_size_type) sizeof esd))
	return FALSE;

      PUT_WORD (dynobj, (bfd_vma) 0, esdl.ld_loaded);

      s = bfd_get_section_by_name (dynobj, ".need");
      if (s == NULL || s->_raw_size == 0)
	PUT_WORD (dynobj, (bfd_vma) 0, esdl.ld_need);
      else
	PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
		  esdl.ld_need);

      s = bfd_get_section_by_name (dynobj, ".rules");
      if (s == NULL || s->_raw_size == 0)
	PUT_WORD (dynobj, (bfd_vma) 0, esdl.ld_rules);
      else
	PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
		  esdl.ld_rules);

      s = bfd_get_section_by_name (dynobj, ".got");
      BFD_ASSERT (s != NULL);
      PUT_WORD (dynobj, s->output_section->vma + s->output_offset,
		esdl.ld_got);

      s = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (s != NULL);
      PUT_WORD (dynobj, s->output_section->vma + s->output_offset,
		esdl.ld_plt);
      PUT_WORD (dynobj, s->_raw_size, esdl.ld_plt_sz);

      s = bfd_get_section_by_name (dynobj, ".dynrel");
      BFD_ASSERT (s != NULL);
      BFD_ASSERT (s->reloc_count * obj_reloc_entry_size (dynobj)
		  == s->_raw_size);
      PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
		esdl.ld_rel);

      s = bfd_get_section_by_name (dynobj, ".hash");
      BFD_ASSERT (s != NULL);
      PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
		esdl.ld_hash);

      s = bfd_get_section_by_name (dynobj, ".dynsym");
      BFD_ASSERT (s != NULL);
      PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
		esdl.ld_stab);

      PUT_WORD (dynobj, (bfd_vma) 0, esdl.ld_stab_hash);

      PUT_WORD (dynobj, (bfd_vma) sunos_hash_table (info)->bucketcount,
		esdl.ld_buckets);

      s = bfd_get_section_by_name (dynobj, ".dynstr");
      BFD_ASSERT (s != NULL);
      PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
		esdl.ld_symbols);
      PUT_WORD (dynobj, s->_raw_size, esdl.ld_symb_size);

      /* The size of the text area is the size of the .text section
	 rounded up to a page boundary.  FIXME: Should the page size be
	 conditional on something?  */
      PUT_WORD (dynobj,
		BFD_ALIGN (obj_textsec (abfd)->_raw_size, 0x2000),
		esdl.ld_text);

      pos = sdyn->output_offset;
      pos += sizeof esd + EXTERNAL_SUN4_DYNAMIC_DEBUGGER_SIZE;
      if (! bfd_set_section_contents (abfd, sdyn->output_section, &esdl,
				      pos, (bfd_size_type) sizeof esdl))
	return FALSE;

      abfd->flags |= DYNAMIC;
    }

  return TRUE;
}
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2002 Free Software Foundation, Inc.
d887 1
a887 1
					    && !info->relocateable)))
d914 1
a914 1
  if (info->relocateable)
a1248 1
/*ARGSUSED*/
d1328 1
a1328 1
  if (info->relocateable)
a2166 1
/*ARGSUSED*/
a2410 1
/*ARGSUSED*/
@


1.6
log
@resolve conflicts.
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1992, 1994, 1995, 1996, 1997, 1998, 2000
   Free Software Foundation, Inc.
d23 5
a27 1
#define MY(OP) CAT(sunos_big_,OP)
d35 1
a35 1
static boolean sunos_read_dynamic_info PARAMS ((bfd *));
d37 1
a37 1
static boolean sunos_slurp_dynamic_symtab PARAMS ((bfd *));
d46 3
a48 3
static boolean sunos_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *, boolean));
static boolean sunos_add_dynamic_symbols
d51 1
a51 1
static boolean sunos_add_one_symbol
d53 1
a53 1
	   bfd_vma, const char *, boolean, boolean,
d55 1
a55 1
static boolean sunos_scan_relocs
d57 1
a57 1
static boolean sunos_scan_std_relocs
d60 1
a60 1
static boolean sunos_scan_ext_relocs
d63 1
a63 1
static boolean sunos_link_dynamic_object
d65 1
a65 1
static boolean sunos_write_dynamic_symbol
d67 1
a67 1
static boolean sunos_check_dynamic_reloc
d69 1
a69 1
	   struct aout_link_hash_entry *, PTR, bfd_byte *, boolean *,
d71 1
a71 1
static boolean sunos_finish_dynamic_link
d108 1
a108 1
  boolean valid;
d137 1
a137 1
   structure to false to avoid doing this work again.  */
d139 1
a139 1
static boolean
d149 1
d152 1
a152 1
    return true;
d157 1
a157 1
      return false;
d160 2
a161 2
  info = ((struct sunos_dynamic_info *)
	  bfd_zalloc (abfd, sizeof (struct sunos_dynamic_info)));
d163 2
a164 2
    return false;
  info->valid = false;
d180 1
a180 1
    return true;
d182 3
a184 2
				  (file_ptr) 0, sizeof dyninfo))
    return true;
d188 1
a188 1
    return true;
d200 1
a200 1
    return true;
d204 2
a205 1
  if (! bfd_get_section_contents (abfd, dynsec, (PTR) &linkinfo, dynoff,
d207 1
a207 1
    return true;
d254 1
a254 1
  info->valid = true;
d256 1
a256 1
  return true;
d282 1
a282 1
static boolean
d287 1
d293 1
a293 1
	  return false;
d300 1
a300 1
      return false;
d306 2
a307 4
      info->dynsym = ((struct external_nlist *)
		      bfd_alloc (abfd,
				 (info->dynsym_count
				  * EXTERNAL_NLIST_SIZE)));
d309 3
a311 5
	return false;
      if (bfd_seek (abfd, info->dyninfo.ld_stab, SEEK_SET) != 0
	  || (bfd_read ((PTR) info->dynsym, info->dynsym_count,
			EXTERNAL_NLIST_SIZE, abfd)
	      != info->dynsym_count * EXTERNAL_NLIST_SIZE))
d318 1
a318 1
	  return false;
d325 2
a326 1
      info->dynstr = (char *) bfd_alloc (abfd, info->dyninfo.ld_symb_size);
d328 3
a330 5
	return false;
      if (bfd_seek (abfd, info->dyninfo.ld_symbols, SEEK_SET) != 0
	  || (bfd_read ((PTR) info->dynstr, 1, info->dyninfo.ld_symb_size,
			abfd)
	      != info->dyninfo.ld_symb_size))
d337 1
a337 1
	  return false;
d341 1
a341 1
  return true;
d373 2
a374 2
    if (bfd_seek (abfd, info->dyninfo.ld_hash, SEEK_SET) != 0
	|| bfd_read ((PTR) table, 1, table_size, abfd) != table_size)
d404 5
a408 4
      info->canonical_dynsym = ((aout_symbol_type *)
				bfd_alloc (abfd,
					   (info->dynsym_count
					    * sizeof (aout_symbol_type))));
d413 3
a415 4
					    info->dynsym, info->dynsym_count,
					    info->dynstr,
					    info->dyninfo.ld_symb_size,
					    true))
d465 1
d484 3
a486 4
      info->dynrel = (PTR) bfd_alloc (abfd,
				      (info->dynrel_count
				       * obj_reloc_entry_size (abfd)));
      if (info->dynrel == NULL && info->dynrel_count != 0)
d488 2
a489 4
      if (bfd_seek (abfd, info->dyninfo.ld_rel, SEEK_SET) != 0
	  || (bfd_read ((PTR) info->dynrel, info->dynrel_count,
			obj_reloc_entry_size (abfd), abfd)
	      != info->dynrel_count * obj_reloc_entry_size (abfd)))
d506 2
a507 4
      info->canonical_dynrel = ((arelent *)
				bfd_alloc (abfd,
					   (info->dynrel_count
					    * sizeof (arelent))));
d522 1
a522 1
					  info->dynsym_count);
d533 1
a533 1
					  info->dynsym_count);
d566 1
a566 1
#define SPARC_PLT_ENTRY_WORD0 0x9de3bfa0
d568 1
a568 1
#define SPARC_PLT_ENTRY_WORD1 0x40000000
d570 1
a570 1
#define SPARC_PLT_ENTRY_WORD2 0x01000000
d576 1
a576 1
#define SPARC_PLT_PIC_WORD0 0x03000000
d578 1
a578 1
#define SPARC_PLT_PIC_WORD1 0x81c06000
d580 1
a580 1
#define SPARC_PLT_PIC_WORD2 0x01000000
d600 1
a600 1
#define M68K_PLT_ENTRY_WORD0 (0x61ff)
d653 1
a653 1
  boolean dynamic_sections_created;
d656 1
a656 1
  boolean dynamic_sections_needed;
d659 1
a659 1
  boolean got_needed;
d717 1
d719 1
a719 2
  ret = ((struct sunos_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct sunos_link_hash_table)));
d725 1
a725 1
      bfd_release (abfd, ret);
d730 3
a732 3
  ret->dynamic_sections_created = false;
  ret->dynamic_sections_needed = false;
  ret->got_needed = false;
d753 1
a753 1
    (boolean (*) PARAMS ((struct aout_link_hash_entry *, PTR))) (func),	\
d761 1
a761 1
static boolean sunos_scan_dynamic_symbol
d771 1
a771 1
static boolean
d775 1
a775 1
     boolean needed;
d795 1
a795 1
	return false;
d803 1
a803 1
	return false;
d811 1
a811 1
	return false;
d819 1
a819 1
	return false;
d827 1
a827 1
	return false;
d835 1
a835 1
	return false;
d843 1
a843 1
	return false;
d845 1
a845 1
      sunos_hash_table (info)->dynamic_sections_created = true;
d859 2
a860 2
      sunos_hash_table (info)->dynamic_sections_needed = true;
      sunos_hash_table (info)->got_needed = true;
d863 1
a863 1
  return true;
d869 1
a869 1
static boolean
a876 1
  asection *s;
d880 1
d886 3
a888 5
					   (((abfd->flags & DYNAMIC) != 0
					     && ! info->relocateable)
					    ? true
					    : false)))
	return false;
d893 1
a893 1
    return true;
d904 1
a904 3
  if (abfd != dynobj)
    abfd->sections = NULL;
  else
d906 4
a909 7
      asection *s;

      for (s = abfd->sections;
	   (s->flags & SEC_LINKER_CREATED) == 0;
	   s = s->next)
	;
      abfd->sections = s;
d915 1
a915 1
    return true;
d922 1
a922 1
      return false;
d933 1
a933 1
      s = bfd_make_section (dynobj, ".need");
d942 1
a942 1
	return false;
d950 1
a950 1
      s = bfd_make_section (dynobj, ".rules");
d959 1
a959 1
	return false;
d964 1
a964 1
    return false;
d980 1
a980 1
      size_t alc;
d984 3
a986 3
      if (bfd_seek (abfd, need, SEEK_SET) != 0
	  || bfd_read (buf, 1, 16, abfd) != 16)
	return false;
d989 1
a989 1
         should probably define structs for this manipulation.  */
d993 2
a994 2
      major_vno = (unsigned short)bfd_get_16 (abfd, buf + 8);
      minor_vno = (unsigned short)bfd_get_16 (abfd, buf + 10);
d997 2
a998 2
      needed = ((struct bfd_link_needed_list *)
		bfd_alloc (abfd, sizeof (struct bfd_link_needed_list)));
d1000 1
a1000 1
	return false;
d1007 1
a1007 1
	return false;
d1015 1
a1015 1
      if (bfd_seek (abfd, name, SEEK_SET) != 0)
d1018 1
a1018 1
	  return false;
d1023 1
a1023 1
	  if (bfd_read (&b, 1, 1, abfd) != 1)
d1026 1
a1026 1
	      return false;
d1029 1
a1029 1
	  if ((size_t) (p - namebuf) >= alc)
d1038 1
a1038 1
		  return false;
d1070 1
a1070 1
		  return false;
d1080 1
a1080 1
      namecopy = bfd_alloc (abfd, strlen (namebuf) + 1);
d1084 1
a1084 1
	  return false;
d1099 1
a1099 1
  return true;
d1106 1
a1106 1
static boolean
d1116 2
a1117 2
     boolean copy;
     boolean collect;
d1125 2
a1126 2
    h = sunos_link_hash_lookup (sunos_hash_table (info), name, true, copy,
				false);
d1129 1
a1129 1
	 bfd_wrapped_link_hash_lookup (abfd, info, name, true, copy, false));
d1131 1
a1131 1
    return false;
d1185 4
a1188 4
         is from a dynamic object.  A constructor symbol is actually a
         definition, although the type will be bfd_link_hash_undefined
         at this point.  We want to ignore the definition from the
         dynamic object.  */
d1198 2
a1199 2
         is a constructor symbol.  As above, we want to force the use
         of the constructor symbol from the regular object.  */
d1207 1
a1207 1
    return false;
d1244 1
a1244 1
  return true;
d1263 1
a1263 1
boolean
d1272 1
a1272 1
    return true;
d1278 1
a1278 1
			      false, false, false);
d1280 1
a1280 1
    return true;
d1295 1
a1295 1
  return true;
d1304 1
a1304 1
   info->keep_memory is true, we keep the relocs in memory; otherwise,
d1307 1
a1307 1
boolean
d1317 1
a1317 1
  size_t dynsymcount;
d1321 1
a1321 1
  size_t hashalloc;
d1330 1
a1330 1
    return true;
d1333 1
a1333 1
    return true;
d1349 1
a1349 1
	    return false;
d1360 1
a1360 1
    return true;
d1364 1
a1364 1
			      "__GLOBAL_OFFSET_TABLE_", false, false, false);
d1377 2
a1378 2
         __GLOBAL_OFFSET_TABLE_ to be 0x1000 bytes into the section,
         so that 13 bit relocations have a greater chance of working.  */
d1415 1
a1415 1
	return false;
d1434 1
a1434 1
      s->contents = (bfd_byte *) bfd_alloc (dynobj, hashalloc);
d1436 1
a1436 2
	return false;
      memset (s->contents, 0, hashalloc);
d1464 1
a1464 1
					       (size_t) (s->_raw_size + add));
d1466 1
a1466 1
	    return false;
d1481 1
a1481 1
	return false;
d1504 1
a1504 1
	return false;
d1514 1
a1514 1
    return false;
d1519 1
a1519 1
  return true;
d1524 1
a1524 1
static boolean
d1535 1
a1535 1
    return true;
d1538 1
a1538 1
    relocs = free_relocs = bfd_malloc ((size_t) rel_size);
d1542 1
d1544 1
a1544 2
      n = ((struct aout_section_data_struct *)
	   bfd_alloc (abfd, sizeof (struct aout_section_data_struct)));
d1550 1
a1550 1
	  relocs = bfd_malloc ((size_t) rel_size);
d1555 1
a1555 1
    return false;
d1558 1
a1558 1
      || bfd_read (relocs, 1, rel_size, abfd) != rel_size)
d1579 1
a1579 1
  return true;
d1584 1
a1584 1
  return false;
d1597 1
a1597 1
static boolean
d1615 1
a1615 1
      return false;
d1677 2
a1678 2
	  if (! sunos_create_dynamic_sections (abfd, info, false))
	    return false;
d1688 1
a1688 1
	  sunos_hash_table (info)->got_needed = true;
d1748 1
a1748 1
  return true;
d1757 1
a1757 1
static boolean
d1771 1
d1777 1
a1777 1
      return false;
d1824 1
a1824 1
         the .got section.  */
d1831 2
a1832 2
	      if (! sunos_create_dynamic_sections (abfd, info, false))
		return false;
d1842 1
a1842 1
	      sunos_hash_table (info)->got_needed = true;
d1863 2
d1866 1
a1866 3
		    (bfd_vma *) bfd_zalloc (abfd,
					    (bfd_get_symcount (abfd)
					     * sizeof (bfd_vma)));
d1868 1
a1868 1
		    return false;
d1892 2
a1893 2
         defined in dynamic objects but not in regular objects.  We
         only need to consider relocs against external symbols.  */
d1897 1
a1897 1
             generate an absolute reloc.  */
d1902 2
a1903 2
		  if (! sunos_create_dynamic_sections (abfd, info, true))
		    return false;
d1939 2
a1940 2
             here; just let the relocation routine report an undefined
             symbol.  */
d1949 2
a1950 2
	  if (! sunos_create_dynamic_sections (abfd, info, false))
	    return false;
d1960 1
a1960 1
	  sunos_hash_table (info)->got_needed = true;
d2025 2
a2026 2
                 is a JMP_TBL reloc produced by linking PIC compiled
                 code, and we are not making a shared library.  */
d2032 1
a2032 1
             any reloc other than a jump table reloc.  */
d2038 1
a2038 1
  return true;
d2044 1
a2044 1
static boolean
d2051 3
d2066 1
a2066 1
    h->root.written = true;
d2125 1
a2125 1
	return false;
d2161 1
a2161 1
  return true;
d2169 1
a2169 1
static boolean
d2174 1
a2174 1
  return true;
d2180 1
a2180 1
static boolean
a2198 1
      asection *s;
a2226 2
	      bfd_vma val;

d2245 1
a2245 1
	  bfd_put_16 (output_bfd, s->reloc_count, p + 6);
d2254 1
a2254 1
         result of a JMP_TBL reloc from PIC compiled code.  */
d2320 1
a2320 1
    return true;
d2328 1
a2328 1
      return true;
d2386 1
a2386 1
      return true;
d2394 2
a2395 2
  bfd_h_put_8 (output_bfd, type, outsym->e_type);
  bfd_h_put_8 (output_bfd, 0, outsym->e_other);
d2400 1
a2400 1
  bfd_h_put_16 (output_bfd, 0, outsym->e_desc);
d2405 1
a2405 1
  return true;
d2414 1
a2414 1
static boolean
d2423 1
a2423 1
     boolean *skip;
d2428 3
a2430 3
  boolean baserel;
  boolean jmptbl;
  boolean pcrel;
d2435 1
a2435 1
  *skip = false;
d2493 1
a2493 1
         because they are pcrel_offset.  */
d2562 1
a2562 1
                 dynamic linker to fill in this entry in the table.  */
d2663 1
a2663 1
		      + (*got_offsetp &~ 1)
d2667 1
a2667 1
      return true;
d2671 1
a2671 1
    return true;
d2680 1
a2680 1
	return true;
d2689 1
a2689 1
	return true;
d2732 1
a2732 1
         reloc.  */
d2771 1
a2771 1
    *skip = true;
d2773 1
a2773 1
  return true;
d2778 1
a2778 1
static boolean
d2790 1
a2790 1
    return true;
d2840 2
a2841 1
					  o->contents, o->output_offset,
d2843 1
a2843 1
	    return false;
d2851 1
d2866 3
a2868 2
				      sdyn->output_offset, sizeof esd))
	return false;
d2932 2
d2935 2
a2936 5
				      (sdyn->output_offset
				       + sizeof esd
				       + EXTERNAL_SUN4_DYNAMIC_DEBUGGER_SIZE),
				      sizeof esdl))
	return false;
d2941 1
a2941 1
  return true;
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d511 1
a511 1
      
d1424 1
a1424 1
      
d2277 3
a2279 3
		  srel->r_index[0] = (bfd_byte)(h->dynindx >> 16);
		  srel->r_index[1] = (bfd_byte)(h->dynindx >> 8);
		  srel->r_index[2] = (bfd_byte)(h->dynindx);
d2285 2
a2286 2
		  srel->r_index[2] = (bfd_byte)(h->dynindx >> 16);
		  srel->r_index[1] = (bfd_byte)(h->dynindx >> 8);
d2300 2
a2301 2
		  erel->r_index[0] = (bfd_byte)(h->dynindx >> 16);
		  erel->r_index[1] = (bfd_byte)(h->dynindx >> 8);
d2309 2
a2310 2
		  erel->r_index[2] = (bfd_byte)(h->dynindx >> 16);
		  erel->r_index[1] = (bfd_byte)(h->dynindx >> 8);
d2597 2
a2598 2
		      srel->r_index[0] = (bfd_byte)(indx >> 16);
		      srel->r_index[1] = (bfd_byte)(indx >> 8);
d2611 2
a2612 2
		      srel->r_index[2] = (bfd_byte)(indx >> 16);
		      srel->r_index[1] = (bfd_byte)(indx >> 8);
d2636 2
a2637 2
		      erel->r_index[0] = (bfd_byte)(indx >> 16);
		      erel->r_index[1] = (bfd_byte)(indx >> 8);
d2649 2
a2650 2
		      erel->r_index[2] = (bfd_byte)(indx >> 16);
		      erel->r_index[1] = (bfd_byte)(indx >> 8);
d2729 2
a2730 2
	  srel->r_index[0] = (bfd_byte)(indx >> 16);
	  srel->r_index[1] = (bfd_byte)(indx >> 8);
d2735 2
a2736 2
	  srel->r_index[2] = (bfd_byte)(indx >> 16);
	  srel->r_index[1] = (bfd_byte)(indx >> 8);
d2754 2
a2755 2
	  erel->r_index[0] = (bfd_byte)(indx >> 16);
	  erel->r_index[1] = (bfd_byte)(indx >> 8);
d2760 2
a2761 2
	  erel->r_index[2] = (bfd_byte)(indx >> 16);
	  erel->r_index[1] = (bfd_byte)(indx >> 8);
d2936 1
a2936 1
  
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d87 2
d95 3
d659 3
d733 1
d786 2
a787 1
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY;
d849 2
a850 1
  if (needed && ! sunos_hash_table (info)->dynamic_sections_needed)
d857 2
a858 1
      s->_raw_size = BYTES_IN_WORD;
d861 1
d898 2
d905 14
a918 2
     space in the output file.  */
  abfd->sections = NULL;
a935 1
  dynobj = sunos_hash_table (info)->dynobj;
d987 2
d990 1
d1001 2
a1002 2
      major_vno = bfd_get_16 (abfd, buf + 8);
      minor_vno = bfd_get_16 (abfd, buf + 10);
d1012 5
d1019 4
a1022 1
	bfd_alloc_grow (abfd, "-l", 2);
d1024 5
a1028 1
	return false;
d1032 21
a1052 2
	    return false;
	  bfd_alloc_grow (abfd, &b, 1);
d1055 4
a1058 1
      if (major_vno != 0)
d1060 2
a1061 1
	  char verbuf[30];
d1063 7
a1069 3
	  sprintf (verbuf, ".%d", major_vno);
	  bfd_alloc_grow (abfd, verbuf, strlen (verbuf));
	  if (minor_vno != 0)
d1071 11
a1081 2
	      sprintf (verbuf, ".%d", minor_vno);
	      bfd_alloc_grow (abfd, verbuf, strlen (verbuf));
d1083 3
d1087 10
a1096 3
      needed->name = bfd_alloc_finish (abfd);
      if (needed->name == NULL)
	return false;
d1173 2
a1174 1
	  h->root.root.type = bfd_link_hash_new;
d1260 1
a1260 1
     bfd *abfd;
d1366 2
a1367 1
  if (! sunos_hash_table (info)->dynamic_sections_needed)
d1397 3
a1399 62
  /* The .dynamic section is always the same size.  */
  s = bfd_get_section_by_name (dynobj, ".dynamic");
  BFD_ASSERT (s != NULL);
  s->_raw_size = (sizeof (struct external_sun4_dynamic)
		  + EXTERNAL_SUN4_DYNAMIC_DEBUGGER_SIZE
		  + sizeof (struct external_sun4_dynamic_link));

  /* Set the size of the .dynsym and .hash sections.  We counted the
     number of dynamic symbols as we read the input files.  We will
     build the dynamic symbol table (.dynsym) and the hash table
     (.hash) when we build the final symbol table, because until then
     we do not know the correct value to give the symbols.  We build
     the dynamic symbol string table (.dynstr) in a traversal of the
     symbol table using sunos_scan_dynamic_symbol.  */
  s = bfd_get_section_by_name (dynobj, ".dynsym");
  BFD_ASSERT (s != NULL);
  s->_raw_size = dynsymcount * sizeof (struct external_nlist);
  s->contents = (bfd_byte *) bfd_alloc (output_bfd, s->_raw_size);
  if (s->contents == NULL && s->_raw_size != 0)
    return false;
      
  /* The number of buckets is just the number of symbols divided by
     four.  To compute the final size of the hash table, we must
     actually compute the hash table.  Normally we need exactly as
     many entries in the hash table as there are dynamic symbols, but
     if some of the buckets are not used we will need additional
     entries.  In the worst case, every symbol will hash to the same
     bucket, and we will need BUCKETCOUNT - 1 extra entries.  */
  if (dynsymcount >= 4)
    bucketcount = dynsymcount / 4;
  else if (dynsymcount > 0)
    bucketcount = dynsymcount;
  else
    bucketcount = 1;
  s = bfd_get_section_by_name (dynobj, ".hash");
  BFD_ASSERT (s != NULL);
  hashalloc = (dynsymcount + bucketcount - 1) * HASH_ENTRY_SIZE;
  s->contents = (bfd_byte *) bfd_alloc (dynobj, hashalloc);
  if (s->contents == NULL && dynsymcount > 0)
    return false;
  memset (s->contents, 0, hashalloc);
  for (i = 0; i < bucketcount; i++)
    PUT_WORD (output_bfd, (bfd_vma) -1, s->contents + i * HASH_ENTRY_SIZE);
  s->_raw_size = bucketcount * HASH_ENTRY_SIZE;

  sunos_hash_table (info)->bucketcount = bucketcount;

  /* Scan all the symbols, place them in the dynamic symbol table, and
     build the dynamic hash table.  We reuse dynsymcount as a counter
     for the number of symbols we have added so far.  */
  sunos_hash_table (info)->dynsymcount = 0;
  sunos_link_hash_traverse (sunos_hash_table (info),
			    sunos_scan_dynamic_symbol,
			    (PTR) info);
  BFD_ASSERT (sunos_hash_table (info)->dynsymcount == dynsymcount);

  /* The SunOS native linker seems to align the total size of the
     symbol strings to a multiple of 8.  I don't know if this is
     important, but it can't hurt much.  */
  s = bfd_get_section_by_name (dynobj, ".dynstr");
  BFD_ASSERT (s != NULL);
  if ((s->_raw_size & 7) != 0)
d1401 1
a1401 2
      bfd_size_type add;
      bfd_byte *contents;
d1403 41
a1443 4
      add = 8 - (s->_raw_size & 7);
      contents = (bfd_byte *) bfd_realloc (s->contents,
					   (size_t) (s->_raw_size + add));
      if (contents == NULL)
d1445 35
a1479 3
      memset (contents + s->_raw_size, 0, (size_t) add);
      s->contents = contents;
      s->_raw_size += add;
a1524 1
  *sdynptr = bfd_get_section_by_name (dynobj, ".dynamic");
d1610 1
a1610 1
     asection *sec;
d1684 3
a1686 1
	  if (! sunos_create_dynamic_sections (abfd, info, true))
d1692 6
d1770 1
a1770 1
     asection *sec;
d1839 1
a1839 1
	      if (! sunos_create_dynamic_sections (abfd, info, true))
d1846 5
d1957 1
a1957 1
	  if (! sunos_create_dynamic_sections (abfd, info, true))
d1964 5
d2134 1
a2134 1
      strcpy (contents + s->_raw_size, h->root.root.root.string);
d2176 2
a2177 2
     struct bfd_link_info *info;
     bfd *abfd;
a2196 86
  if (h->dynindx < 0)
    return true;

  switch (h->root.root.type)
    {
    default:
    case bfd_link_hash_new:
      abort ();
      /* Avoid variable not initialized warnings.  */
      return true;
    case bfd_link_hash_undefined:
      type = N_UNDF | N_EXT;
      val = 0;
      break;
    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      {
	asection *sec;
	asection *output_section;

	sec = h->root.root.u.def.section;
	output_section = sec->output_section;
	BFD_ASSERT (bfd_is_abs_section (output_section)
		    || output_section->owner == output_bfd);
	if (h->plt_offset != 0
	    && (h->flags & SUNOS_DEF_REGULAR) == 0)
	  {
	    type = N_UNDF | N_EXT;
	    val = 0;
	  }
	else
	  {
	    if (output_section == obj_textsec (output_bfd))
	      type = (h->root.root.type == bfd_link_hash_defined
		      ? N_TEXT
		      : N_WEAKT);
	    else if (output_section == obj_datasec (output_bfd))
	      type = (h->root.root.type == bfd_link_hash_defined
		      ? N_DATA
		      : N_WEAKD);
	    else if (output_section == obj_bsssec (output_bfd))
	      type = (h->root.root.type == bfd_link_hash_defined
		      ? N_BSS
		      : N_WEAKB);
	    else
	      type = (h->root.root.type == bfd_link_hash_defined
		      ? N_ABS
		      : N_WEAKA);
	    type |= N_EXT;
	    val = (h->root.root.u.def.value
		   + output_section->vma
		   + sec->output_offset);
	  }
      }
      break;
    case bfd_link_hash_common:
      type = N_UNDF | N_EXT;
      val = h->root.root.u.c.size;
      break;
    case bfd_link_hash_undefweak:
      type = N_WEAKU;
      val = 0;
      break;
    case bfd_link_hash_indirect:
    case bfd_link_hash_warning:
      /* FIXME: Ignore these for now.  The circumstances under which
	 they should be written out are not clear to me.  */
      return true;
    }

  s = bfd_get_section_by_name (sunos_hash_table (info)->dynobj, ".dynsym");
  BFD_ASSERT (s != NULL);
  outsym = ((struct external_nlist *)
	    (s->contents + h->dynindx * EXTERNAL_NLIST_SIZE));

  bfd_h_put_8 (output_bfd, type, outsym->e_type);
  bfd_h_put_8 (output_bfd, 0, outsym->e_other);

  /* FIXME: The native linker doesn't use 0 for desc.  It seems to use
     one less than the desc value in the shared library, although that
     seems unlikely.  */
  bfd_h_put_16 (output_bfd, 0, outsym->e_desc);

  PUT_WORD (output_bfd, h->dynstr_index, outsym->e_strx);
  PUT_WORD (output_bfd, val, outsym->e_value);

d2265 1
d2277 3
a2279 3
		  srel->r_index[0] = h->dynindx >> 16;
		  srel->r_index[1] = h->dynindx >> 8;
		  srel->r_index[2] = h->dynindx;
d2285 3
a2287 3
		  srel->r_index[2] = h->dynindx >> 16;
		  srel->r_index[1] = h->dynindx >> 8;
		  srel->r_index[0] = h->dynindx;
d2300 3
a2302 3
		  erel->r_index[0] = h->dynindx >> 16;
		  erel->r_index[1] = h->dynindx >> 8;
		  erel->r_index[2] = h->dynindx;
d2309 3
a2311 3
		  erel->r_index[2] = h->dynindx >> 16;
		  erel->r_index[1] = h->dynindx >> 8;
		  erel->r_index[0] = h->dynindx;
d2323 90
d2430 1
a2430 1
     bfd_byte *contents;
d2438 1
d2447 4
a2450 1
  if (h != NULL && h->plt_offset != 0)
d2470 1
d2476 1
d2495 7
d2597 3
a2599 3
		      srel->r_index[0] = indx >> 16;
		      srel->r_index[1] = indx >> 8;
		      srel->r_index[2] = indx;
d2611 3
a2613 3
		      srel->r_index[2] = indx >> 16;
		      srel->r_index[1] = indx >> 8;
		      srel->r_index[0] = indx;
d2636 3
a2638 3
		      erel->r_index[0] = indx >> 16;
		      erel->r_index[1] = indx >> 8;
		      erel->r_index[2] = indx;
d2649 3
a2651 3
		      erel->r_index[2] = indx >> 16;
		      erel->r_index[1] = indx >> 8;
		      erel->r_index[0] = indx;
d2729 3
a2731 3
	  srel->r_index[0] = indx >> 16;
	  srel->r_index[1] = indx >> 8;
	  srel->r_index[2] = indx;
d2735 3
a2737 3
	  srel->r_index[2] = indx >> 16;
	  srel->r_index[1] = indx >> 8;
	  srel->r_index[0] = indx;
d2739 2
d2754 3
a2756 3
	  erel->r_index[0] = indx >> 16;
	  erel->r_index[1] = indx >> 8;
	  erel->r_index[2] = indx;
d2760 13
a2772 3
	  erel->r_index[2] = indx >> 16;
	  erel->r_index[1] = indx >> 8;
	  erel->r_index[0] = indx;
a2794 2
  struct external_sun4_dynamic esd;
  struct external_sun4_dynamic_link esdl;
d2796 2
a2797 1
  if (! sunos_hash_table (info)->dynamic_sections_needed)
d2834 1
a2834 1
  if (info->shared)
d2854 4
a2857 11
  /* Finish up the dynamic link information.  */
  PUT_WORD (dynobj, (bfd_vma) 3, esd.ld_version);
  PUT_WORD (dynobj,
	    sdyn->output_section->vma + sdyn->output_offset + sizeof esd,
	    esd.ldd);
  PUT_WORD (dynobj,
	    (sdyn->output_section->vma
	     + sdyn->output_offset
	     + sizeof esd
	     + EXTERNAL_SUN4_DYNAMIC_DEBUGGER_SIZE),
	    esd.ld);
d2859 11
a2869 3
  if (! bfd_set_section_contents (abfd, sdyn->output_section, &esd,
				  sdyn->output_offset, sizeof esd))
    return false;
d2871 3
d2875 1
a2875 1
  PUT_WORD (dynobj, (bfd_vma) 0, esdl.ld_loaded);
d2877 6
a2882 6
  s = bfd_get_section_by_name (dynobj, ".need");
  if (s == NULL || s->_raw_size == 0)
    PUT_WORD (dynobj, (bfd_vma) 0, esdl.ld_need);
  else
    PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
	      esdl.ld_need);
d2884 6
a2889 6
  s = bfd_get_section_by_name (dynobj, ".rules");
  if (s == NULL || s->_raw_size == 0)
    PUT_WORD (dynobj, (bfd_vma) 0, esdl.ld_rules);
  else
    PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
	      esdl.ld_rules);
d2891 4
a2894 3
  s = bfd_get_section_by_name (dynobj, ".got");
  BFD_ASSERT (s != NULL);
  PUT_WORD (dynobj, s->output_section->vma + s->output_offset, esdl.ld_got);
d2896 5
a2900 4
  s = bfd_get_section_by_name (dynobj, ".plt");
  BFD_ASSERT (s != NULL);
  PUT_WORD (dynobj, s->output_section->vma + s->output_offset, esdl.ld_plt);
  PUT_WORD (dynobj, s->_raw_size, esdl.ld_plt_sz);
d2902 6
a2907 5
  s = bfd_get_section_by_name (dynobj, ".dynrel");
  BFD_ASSERT (s != NULL);
  BFD_ASSERT (s->reloc_count * obj_reloc_entry_size (dynobj) == s->_raw_size);
  PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
	    esdl.ld_rel);
d2909 4
a2912 4
  s = bfd_get_section_by_name (dynobj, ".hash");
  BFD_ASSERT (s != NULL);
  PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
	    esdl.ld_hash);
d2914 4
a2917 4
  s = bfd_get_section_by_name (dynobj, ".dynsym");
  BFD_ASSERT (s != NULL);
  PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
	    esdl.ld_stab);
d2919 1
a2919 1
  PUT_WORD (dynobj, (bfd_vma) 0, esdl.ld_stab_hash);
d2921 2
a2922 2
  PUT_WORD (dynobj, (bfd_vma) sunos_hash_table (info)->bucketcount,
	    esdl.ld_buckets);
d2924 12
a2935 12
  s = bfd_get_section_by_name (dynobj, ".dynstr");
  BFD_ASSERT (s != NULL);
  PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
	    esdl.ld_symbols);
  PUT_WORD (dynobj, s->_raw_size, esdl.ld_symb_size);

  /* The size of the text area is the size of the .text section
     rounded up to a page boundary.  FIXME: Should the page size be
     conditional on something?  */
  PUT_WORD (dynobj,
	    BFD_ALIGN (obj_textsec (abfd)->_raw_size, 0x2000),
	    esdl.ld_text);
d2937 6
a2942 6
  if (! bfd_set_section_contents (abfd, sdyn->output_section, &esdl,
				  (sdyn->output_offset
				   + sizeof esd
				   + EXTERNAL_SUN4_DYNAMIC_DEBUGGER_SIZE),
				  sizeof esdl))
    return false;
d2944 2
a2945 1
  abfd->flags |= DYNAMIC;
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d662 3
d727 1
d1248 3
d1293 12
a1304 1
      h->root.root.u.def.value = 0;
d2536 3
a2538 1
      *relocationp = sgot->vma + (*got_offsetp &~ 1);
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d866 9
a874 6
  if (! sunos_create_dynamic_sections (abfd, info,
				       (((abfd->flags & DYNAMIC) != 0
					 && ! info->relocateable)
					? true
					: false)))
    return false;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 1995 Free Software Foundation, Inc.
d81 8
d152 1
a152 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d297 1
a297 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d317 1
a317 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d361 1
a361 1
    table = (bfd_byte *) malloc (table_size);
d400 1
a400 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return -1;
	}
d478 1
a478 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return -1;
	}
d504 1
a504 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return -1;
	}
d631 1
a631 1
#define SUNOS_REF_DYNAMIC 010
d633 3
a635 1
#define SUNOS_DEF_DYNAMIC 020
d680 1
a680 4
    {
      bfd_set_error (bfd_error_no_memory);
      return (struct bfd_hash_entry *) ret;
    }
d710 1
a710 4
    {
      bfd_set_error (bfd_error_no_memory);
      return (struct bfd_link_hash_table *) NULL;
    }
d850 1
a850 2
   backend linker when it encounters an object with the DYNAMIC flag
   set.  */
d865 12
a897 4
  /* Make sure we have all the required information.  */
  if (! sunos_create_dynamic_sections (abfd, info, true))
    return false;

d968 2
a969 1
      needed = (struct bfd_link_needed_list *) bfd_alloc (abfd, sizeof (struct bfd_link_needed_list));
d971 1
a971 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d1001 1
a1001 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d1036 7
a1042 13
  if (! sunos_hash_table (info)->dynamic_sections_created)
    {
      /* We must create the dynamic sections while reading the input
         files, even though at this point we don't know if any of the
         sections will be needed.  This will ensure that the dynamic
         sections are mapped to the right output section.  It does no
         harm to create these sections if they are not needed.  */
      if (! sunos_create_dynamic_sections (abfd, info, false))
	return false;
    }

  h = sunos_link_hash_lookup (sunos_hash_table (info), name, true, copy,
			      false);
d1092 23
d1150 4
d1305 1
a1305 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d1325 1
a1325 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d1353 2
a1354 2
      contents = (bfd_byte *) realloc (s->contents,
				       (size_t) (s->_raw_size + add));
d1356 1
a1356 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d1370 1
a1370 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d1393 1
a1393 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d1403 1
a1403 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d1428 1
a1428 1
    relocs = free_relocs = malloc ((size_t) rel_size);
d1440 1
a1440 1
	  relocs = malloc ((size_t) rel_size);
d1445 1
a1445 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d1519 1
a1519 1
      if (abfd->xvec->header_byteorder_big_p)
d1531 1
a1531 1
      if (abfd->xvec->header_byteorder_big_p)
d1674 1
a1674 1
      if (abfd->xvec->header_byteorder_big_p)
d1744 1
a1744 4
		    {
		      bfd_set_error (bfd_error_no_memory);
		      return false;
		    }
d1809 11
d1835 1
d1926 5
a1930 1
     object do not seem to show up in the regular symbol table.  */
d1932 1
d1990 2
a1991 5
      if (s->contents == NULL)
	contents = (bfd_byte *) malloc (len + 1);
      else
	contents = (bfd_byte *) realloc (s->contents,
					 (size_t) (s->_raw_size + len + 1));
d1993 1
a1993 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d2223 1
a2223 1
	      if (output_bfd->xvec->header_byteorder_big_p)
d2246 1
a2246 1
	      if (output_bfd->xvec->header_byteorder_big_p)
d2320 1
a2320 1
      if (input_bfd->xvec->header_byteorder_big_p)
d2337 1
a2337 1
      if (input_bfd->xvec->header_byteorder_big_p)
d2366 1
a2366 1
	      if (input_bfd->xvec->header_byteorder_big_p)
d2380 1
a2380 1
	      if (input_bfd->xvec->header_byteorder_big_p)
d2440 1
a2440 1
		  if (dynobj->xvec->header_byteorder_big_p)
d2479 1
a2479 1
		  if (dynobj->xvec->header_byteorder_big_p)
d2570 1
a2570 1
      if (dynobj->xvec->header_byteorder_big_p)
d2593 1
a2593 1
      if (dynobj->xvec->header_byteorder_big_p)
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a80 8
/* ??? Where should this go?  */
#define MACHTYPE_OK(mtype) \
  (((mtype) == M_SPARC && bfd_lookup_arch (bfd_arch_sparc, 0) != NULL) \
   || ((mtype) == M_SPARCLET \
       && bfd_lookup_arch (bfd_arch_sparc, bfd_mach_sparc_sparclet) != NULL) \
   || (((mtype) == M_UNKNOWN || (mtype) == M_68010 || (mtype) == M_68020) \
       && bfd_lookup_arch (bfd_arch_m68k, 0) != NULL))

d144 4
a147 1
    return false;
d292 4
a295 1
	return false;
d315 4
a318 1
	return false;
d362 1
a362 1
    table = (bfd_byte *) bfd_malloc (table_size);
d401 4
a404 1
	return -1;
d482 4
a485 1
	return -1;
d511 4
a514 1
	return -1;
d641 1
a641 1
#define SUNOS_REF_DYNAMIC 04
d643 1
a643 3
#define SUNOS_DEF_DYNAMIC 010
  /* Symbol is a constructor symbol in a regular object.  */
#define SUNOS_CONSTRUCTOR 020
d688 4
a691 1
    return (struct bfd_hash_entry *) ret;
d721 4
a724 1
    return (struct bfd_link_hash_table *) NULL;
d864 2
a865 1
   backend linker for each object it encounters.  */
a879 12
  /* Make sure we have all the required sections.  */
  if (! sunos_create_dynamic_sections (abfd, info,
				       (((abfd->flags & DYNAMIC) != 0
					 && ! info->relocateable)
					? true
					: false)))
    return false;

  /* There is nothing else to do for a normal object.  */
  if ((abfd->flags & DYNAMIC) == 0)
    return true;

d901 4
d975 1
a975 2
      needed = ((struct bfd_link_needed_list *)
		bfd_alloc (abfd, sizeof (struct bfd_link_needed_list)));
d977 4
a980 1
	return false;
d1010 4
a1013 1
	return false;
d1048 13
a1060 7
  if ((flags & (BSF_INDIRECT | BSF_WARNING | BSF_CONSTRUCTOR)) != 0
      || ! bfd_is_und_section (section))
    h = sunos_link_hash_lookup (sunos_hash_table (info), name, true, copy,
				false);
  else
    h = ((struct sunos_link_hash_entry *)
	 bfd_wrapped_link_hash_lookup (abfd, info, name, true, copy, false));
a1109 23
  if ((abfd->flags & DYNAMIC) != 0
      && abfd->xvec == info->hash->creator
      && (h->flags & SUNOS_CONSTRUCTOR) != 0)
    {
      /* The existing symbol is a constructor symbol, and this symbol
         is from a dynamic object.  A constructor symbol is actually a
         definition, although the type will be bfd_link_hash_undefined
         at this point.  We want to ignore the definition from the
         dynamic object.  */
      section = bfd_und_section_ptr;
    }
  else if ((flags & BSF_CONSTRUCTOR) != 0
	   && (abfd->flags & DYNAMIC) == 0
	   && h->root.root.type == bfd_link_hash_defined
	   && h->root.root.u.def.section->owner != NULL
	   && (h->root.root.u.def.section->owner->flags & DYNAMIC) != 0)
    {
      /* The existing symbol is defined by a dynamic object, and this
         is a constructor symbol.  As above, we want to force the use
         of the constructor symbol from the regular object.  */
      h->root.root.type = bfd_link_hash_new;
    }

a1144 4

      if ((flags & BSF_CONSTRUCTOR) != 0
	  && (abfd->flags & DYNAMIC) == 0)
	h->flags |= SUNOS_CONSTRUCTOR;
d1296 4
a1299 1
    return false;
d1319 4
a1322 1
    return false;
d1350 2
a1351 2
      contents = (bfd_byte *) bfd_realloc (s->contents,
					   (size_t) (s->_raw_size + add));
d1353 4
a1356 1
	return false;
d1370 4
a1373 1
	return false;
d1396 4
a1399 1
	return false;
d1409 4
a1412 1
    return false;
d1437 1
a1437 1
    relocs = free_relocs = bfd_malloc ((size_t) rel_size);
d1449 1
a1449 1
	  relocs = bfd_malloc ((size_t) rel_size);
d1454 4
a1457 1
    return false;
d1531 1
a1531 1
      if (bfd_header_big_endian (abfd))
d1543 1
a1543 1
      if (bfd_header_big_endian (abfd))
d1686 1
a1686 1
      if (bfd_header_big_endian (abfd))
d1756 4
a1759 1
		    return false;
a1823 11
      if (r_type == RELOC_JMP_TBL
	  && ! info->shared
	  && (h->flags & SUNOS_DEF_DYNAMIC) == 0
	  && (h->flags & SUNOS_DEF_REGULAR) == 0)
	{
	  /* This symbol is apparently undefined.  Don't do anything
             here; just let the relocation routine report an undefined
             symbol.  */
	  continue;
	}

a1838 1
		  || info->shared
d1929 1
a1929 5
     object do not seem to show up in the regular symbol table.  It is
     possible for a symbol to have only SUNOS_REF_REGULAR set here, it
     is an undefined symbol which was turned into a common symbol
     because it was found in an archive object which was not included
     in the link.  */
a1930 1
      && (h->flags & SUNOS_DEF_DYNAMIC) != 0
d1988 5
a1992 2
      contents = (bfd_byte *) bfd_realloc (s->contents,
					   s->_raw_size + len + 1);
d1994 4
a1997 1
	return false;
d2227 1
a2227 1
	      if (bfd_header_big_endian (output_bfd))
d2250 1
a2250 1
	      if (bfd_header_big_endian (output_bfd))
d2324 1
a2324 1
      if (bfd_header_big_endian (input_bfd))
d2341 1
a2341 1
      if (bfd_header_big_endian (input_bfd))
d2370 1
a2370 1
	      if (bfd_header_big_endian (input_bfd))
d2384 1
a2384 1
	      if (bfd_header_big_endian (input_bfd))
d2444 1
a2444 1
		  if (bfd_header_big_endian (dynobj))
d2483 1
a2483 1
		  if (bfd_header_big_endian (dynobj))
d2574 1
a2574 1
      if (bfd_header_big_endian (dynobj))
d2597 1
a2597 1
      if (bfd_header_big_endian (dynobj))
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d866 6
a871 9
  if (info->hash->creator == abfd->xvec)
    {
      if (! sunos_create_dynamic_sections (abfd, info,
					   (((abfd->flags & DYNAMIC) != 0
					     && ! info->relocateable)
					    ? true
					    : false)))
	return false;
    }
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a661 3

  /* The offset of __GLOBAL_OFFSET_TABLE_ into the .got section.  */
  bfd_vma got_base;
a723 1
  ret->got_base = 0;
a1243 3
  if (info->relocateable)
    return true;

d1286 1
a1286 12

      /* If the .got section is more than 0x1000 bytes, we set
         __GLOBAL_OFFSET_TABLE_ to be 0x1000 bytes into the section,
         so that 13 bit relocations have a greater chance of working.  */
      s = bfd_get_section_by_name (dynobj, ".got");
      BFD_ASSERT (s != NULL);
      if (s->_raw_size >= 0x1000)
	h->root.root.u.def.value = 0x1000;
      else
	h->root.root.u.def.value = 0;

      sunos_hash_table (info)->got_base = h->root.root.u.def.value;
d2518 1
a2518 3
      *relocationp = (sgot->vma
		      + (*got_offsetp &~ 1)
		      - sunos_hash_table (info)->got_base);
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@a652 3
  /* Whether we need the .got table.  */
  boolean got_needed;

a723 1
  ret->got_needed = false;
d838 1
a838 2
  if ((needed && ! sunos_hash_table (info)->dynamic_sections_needed)
      || info->shared)
d845 1
a845 2
      if (s->_raw_size == 0)
	s->_raw_size = BYTES_IN_WORD;
a847 1
      sunos_hash_table (info)->got_needed = true;
a959 2
      char *namebuf, *p;
      size_t alc;
a960 1
      char *namecopy;
d971 2
a972 2
      major_vno = (unsigned short)bfd_get_16 (abfd, buf + 8);
      minor_vno = (unsigned short)bfd_get_16 (abfd, buf + 10);
a981 5
      alc = 30;
      namebuf = (char *) bfd_malloc (alc + 1);
      if (namebuf == NULL)
	return false;
      p = namebuf;
d984 1
a984 4
	{
	  *p++ = '-';
	  *p++ = 'l';
	}
d986 1
a986 5
	{
	  free (namebuf);
	  return false;
	}

d990 2
a991 21
	    {
	      free (namebuf);
	      return false;
	    }

	  if (p - namebuf >= alc)
	    {
	      char *n;

	      alc *= 2;
	      n = (char *) bfd_realloc (namebuf, alc + 1);
	      if (n == NULL)
		{
		  free (namebuf);
		  return false;
		}
	      p = n + (p - namebuf);
	      namebuf = n;
	    }

	  *p++ = b;
d994 1
a994 4

      if (major_vno == 0)
	*p = '\0';
      else
d996 1
a996 8
	  char majbuf[30];
	  char minbuf[30];

	  sprintf (majbuf, ".%d", major_vno);
	  if (minor_vno == 0)
	    minbuf[0] = '\0';
	  else
	    sprintf (minbuf, ".%d", minor_vno);
d998 3
a1000 1
	  if ((p - namebuf) + strlen (majbuf) + strlen (minbuf) >= alc)
d1002 2
a1003 11
	      char *n;

	      alc = (p - namebuf) + strlen (majbuf) + strlen (minbuf);
	      n = (char *) bfd_realloc (namebuf, alc + 1);
	      if (n == NULL)
		{
		  free (namebuf);
		  return false;
		}
	      p = n + (p - namebuf);
	      namebuf = n;
a1004 3

	  strcpy (p, majbuf);
	  strcat (p, minbuf);
d1006 3
a1008 10

      namecopy = bfd_alloc (abfd, strlen (namebuf) + 1);
      if (namecopy == NULL)
	{
	  free (namebuf);
	  return false;
	}
      strcpy (namecopy, namebuf);
      free (namebuf);
      needed->name = namecopy;
d1277 1
a1277 2
  if (! sunos_hash_table (info)->dynamic_sections_needed
      && ! sunos_hash_table (info)->got_needed)
d1307 62
a1368 3
  /* If there are any shared objects in the link, then we need to set
     up the dynamic linking information.  */
  if (sunos_hash_table (info)->dynamic_sections_needed)
d1370 2
a1371 1
      *sdynptr = bfd_get_section_by_name (dynobj, ".dynamic");
d1373 4
a1376 20
      /* The .dynamic section is always the same size.  */
      s = *sdynptr;
      BFD_ASSERT (s != NULL);
      s->_raw_size = (sizeof (struct external_sun4_dynamic)
		      + EXTERNAL_SUN4_DYNAMIC_DEBUGGER_SIZE
		      + sizeof (struct external_sun4_dynamic_link));

      /* Set the size of the .dynsym and .hash sections.  We counted
	 the number of dynamic symbols as we read the input files.  We
	 will build the dynamic symbol table (.dynsym) and the hash
	 table (.hash) when we build the final symbol table, because
	 until then we do not know the correct value to give the
	 symbols.  We build the dynamic symbol string table (.dynstr)
	 in a traversal of the symbol table using
	 sunos_scan_dynamic_symbol.  */
      s = bfd_get_section_by_name (dynobj, ".dynsym");
      BFD_ASSERT (s != NULL);
      s->_raw_size = dynsymcount * sizeof (struct external_nlist);
      s->contents = (bfd_byte *) bfd_alloc (output_bfd, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
d1378 3
a1380 56
      
      /* The number of buckets is just the number of symbols divided
	 by four.  To compute the final size of the hash table, we
	 must actually compute the hash table.  Normally we need
	 exactly as many entries in the hash table as there are
	 dynamic symbols, but if some of the buckets are not used we
	 will need additional entries.  In the worst case, every
	 symbol will hash to the same bucket, and we will need
	 BUCKETCOUNT - 1 extra entries.  */
      if (dynsymcount >= 4)
	bucketcount = dynsymcount / 4;
      else if (dynsymcount > 0)
	bucketcount = dynsymcount;
      else
	bucketcount = 1;
      s = bfd_get_section_by_name (dynobj, ".hash");
      BFD_ASSERT (s != NULL);
      hashalloc = (dynsymcount + bucketcount - 1) * HASH_ENTRY_SIZE;
      s->contents = (bfd_byte *) bfd_alloc (dynobj, hashalloc);
      if (s->contents == NULL && dynsymcount > 0)
	return false;
      memset (s->contents, 0, hashalloc);
      for (i = 0; i < bucketcount; i++)
	PUT_WORD (output_bfd, (bfd_vma) -1, s->contents + i * HASH_ENTRY_SIZE);
      s->_raw_size = bucketcount * HASH_ENTRY_SIZE;

      sunos_hash_table (info)->bucketcount = bucketcount;

      /* Scan all the symbols, place them in the dynamic symbol table,
	 and build the dynamic hash table.  We reuse dynsymcount as a
	 counter for the number of symbols we have added so far.  */
      sunos_hash_table (info)->dynsymcount = 0;
      sunos_link_hash_traverse (sunos_hash_table (info),
				sunos_scan_dynamic_symbol,
				(PTR) info);
      BFD_ASSERT (sunos_hash_table (info)->dynsymcount == dynsymcount);

      /* The SunOS native linker seems to align the total size of the
	 symbol strings to a multiple of 8.  I don't know if this is
	 important, but it can't hurt much.  */
      s = bfd_get_section_by_name (dynobj, ".dynstr");
      BFD_ASSERT (s != NULL);
      if ((s->_raw_size & 7) != 0)
	{
	  bfd_size_type add;
	  bfd_byte *contents;

	  add = 8 - (s->_raw_size & 7);
	  contents = (bfd_byte *) bfd_realloc (s->contents,
					       (size_t) (s->_raw_size + add));
	  if (contents == NULL)
	    return false;
	  memset (contents + s->_raw_size, 0, (size_t) add);
	  s->contents = contents;
	  s->_raw_size += add;
	}
d1426 1
d1586 1
a1586 3
	  asection *sgot;

	  if (! sunos_create_dynamic_sections (abfd, info, false))
a1591 6

	  sgot = bfd_get_section_by_name (dynobj, ".got");
	  BFD_ASSERT (sgot != NULL);
	  if (sgot->_raw_size == 0)
	    sgot->_raw_size = BYTES_IN_WORD;
	  sunos_hash_table (info)->got_needed = true;
d1733 1
a1733 1
	      if (! sunos_create_dynamic_sections (abfd, info, false))
a1739 5

	      /* Make sure we have an initial entry in the .got table.  */
	      if (sgot->_raw_size == 0)
		sgot->_raw_size = BYTES_IN_WORD;
	      sunos_hash_table (info)->got_needed = true;
d1846 1
a1846 1
	  if (! sunos_create_dynamic_sections (abfd, info, false))
a1852 5

	  /* Make sure we have an initial entry in the .got table.  */
	  if (sgot->_raw_size == 0)
	    sgot->_raw_size = BYTES_IN_WORD;
	  sunos_hash_table (info)->got_needed = true;
d2081 86
a2234 1
	  BFD_ASSERT (h->dynindx >= 0);
d2246 3
a2248 3
		  srel->r_index[0] = (bfd_byte)(h->dynindx >> 16);
		  srel->r_index[1] = (bfd_byte)(h->dynindx >> 8);
		  srel->r_index[2] = (bfd_byte)(h->dynindx);
d2254 3
a2256 3
		  srel->r_index[2] = (bfd_byte)(h->dynindx >> 16);
		  srel->r_index[1] = (bfd_byte)(h->dynindx >> 8);
		  srel->r_index[0] = (bfd_byte)h->dynindx;
d2269 3
a2271 3
		  erel->r_index[0] = (bfd_byte)(h->dynindx >> 16);
		  erel->r_index[1] = (bfd_byte)(h->dynindx >> 8);
		  erel->r_index[2] = (bfd_byte)h->dynindx;
d2278 3
a2280 3
		  erel->r_index[2] = (bfd_byte)(h->dynindx >> 16);
		  erel->r_index[1] = (bfd_byte)(h->dynindx >> 8);
		  erel->r_index[0] = (bfd_byte)h->dynindx;
a2291 90
  /* If this is not a dynamic symbol, we don't have to do anything
     else.  We only check this after handling the PLT entry, because
     we can have a PLT entry for a nondynamic symbol when linking PIC
     compiled code from a regular object.  */
  if (h->dynindx < 0)
    return true;

  switch (h->root.root.type)
    {
    default:
    case bfd_link_hash_new:
      abort ();
      /* Avoid variable not initialized warnings.  */
      return true;
    case bfd_link_hash_undefined:
      type = N_UNDF | N_EXT;
      val = 0;
      break;
    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      {
	asection *sec;
	asection *output_section;

	sec = h->root.root.u.def.section;
	output_section = sec->output_section;
	BFD_ASSERT (bfd_is_abs_section (output_section)
		    || output_section->owner == output_bfd);
	if (h->plt_offset != 0
	    && (h->flags & SUNOS_DEF_REGULAR) == 0)
	  {
	    type = N_UNDF | N_EXT;
	    val = 0;
	  }
	else
	  {
	    if (output_section == obj_textsec (output_bfd))
	      type = (h->root.root.type == bfd_link_hash_defined
		      ? N_TEXT
		      : N_WEAKT);
	    else if (output_section == obj_datasec (output_bfd))
	      type = (h->root.root.type == bfd_link_hash_defined
		      ? N_DATA
		      : N_WEAKD);
	    else if (output_section == obj_bsssec (output_bfd))
	      type = (h->root.root.type == bfd_link_hash_defined
		      ? N_BSS
		      : N_WEAKB);
	    else
	      type = (h->root.root.type == bfd_link_hash_defined
		      ? N_ABS
		      : N_WEAKA);
	    type |= N_EXT;
	    val = (h->root.root.u.def.value
		   + output_section->vma
		   + sec->output_offset);
	  }
      }
      break;
    case bfd_link_hash_common:
      type = N_UNDF | N_EXT;
      val = h->root.root.u.c.size;
      break;
    case bfd_link_hash_undefweak:
      type = N_WEAKU;
      val = 0;
      break;
    case bfd_link_hash_indirect:
    case bfd_link_hash_warning:
      /* FIXME: Ignore these for now.  The circumstances under which
	 they should be written out are not clear to me.  */
      return true;
    }

  s = bfd_get_section_by_name (sunos_hash_table (info)->dynobj, ".dynsym");
  BFD_ASSERT (s != NULL);
  outsym = ((struct external_nlist *)
	    (s->contents + h->dynindx * EXTERNAL_NLIST_SIZE));

  bfd_h_put_8 (output_bfd, type, outsym->e_type);
  bfd_h_put_8 (output_bfd, 0, outsym->e_other);

  /* FIXME: The native linker doesn't use 0 for desc.  It seems to use
     one less than the desc value in the shared library, although that
     seems unlikely.  */
  bfd_h_put_16 (output_bfd, 0, outsym->e_desc);

  PUT_WORD (output_bfd, h->dynstr_index, outsym->e_strx);
  PUT_WORD (output_bfd, val, outsym->e_value);

d2463 3
a2465 3
		      srel->r_index[0] = (bfd_byte)(indx >> 16);
		      srel->r_index[1] = (bfd_byte)(indx >> 8);
		      srel->r_index[2] = (bfd_byte)indx;
d2477 3
a2479 3
		      srel->r_index[2] = (bfd_byte)(indx >> 16);
		      srel->r_index[1] = (bfd_byte)(indx >> 8);
		      srel->r_index[0] = (bfd_byte)indx;
d2502 3
a2504 3
		      erel->r_index[0] = (bfd_byte)(indx >> 16);
		      erel->r_index[1] = (bfd_byte)(indx >> 8);
		      erel->r_index[2] = (bfd_byte)indx;
d2515 3
a2517 3
		      erel->r_index[2] = (bfd_byte)(indx >> 16);
		      erel->r_index[1] = (bfd_byte)(indx >> 8);
		      erel->r_index[0] = (bfd_byte)indx;
d2595 3
a2597 3
	  srel->r_index[0] = (bfd_byte)(indx >> 16);
	  srel->r_index[1] = (bfd_byte)(indx >> 8);
	  srel->r_index[2] = (bfd_byte)indx;
d2601 3
a2603 3
	  srel->r_index[2] = (bfd_byte)(indx >> 16);
	  srel->r_index[1] = (bfd_byte)(indx >> 8);
	  srel->r_index[0] = (bfd_byte)indx;
d2618 3
a2620 3
	  erel->r_index[0] = (bfd_byte)(indx >> 16);
	  erel->r_index[1] = (bfd_byte)(indx >> 8);
	  erel->r_index[2] = (bfd_byte)indx;
d2624 3
a2626 3
	  erel->r_index[2] = (bfd_byte)(indx >> 16);
	  erel->r_index[1] = (bfd_byte)(indx >> 8);
	  erel->r_index[0] = (bfd_byte)indx;
d2649 2
d2652 1
a2652 2
  if (! sunos_hash_table (info)->dynamic_sections_needed
      && ! sunos_hash_table (info)->got_needed)
d2689 1
a2689 1
  if (info->shared || sdyn->_raw_size == 0)
d2709 11
a2719 4
  if (sdyn->_raw_size > 0)
    {
      struct external_sun4_dynamic esd;
      struct external_sun4_dynamic_link esdl;
d2721 3
a2723 11
      /* Finish up the dynamic link information.  */
      PUT_WORD (dynobj, (bfd_vma) 3, esd.ld_version);
      PUT_WORD (dynobj,
		sdyn->output_section->vma + sdyn->output_offset + sizeof esd,
		esd.ldd);
      PUT_WORD (dynobj,
		(sdyn->output_section->vma
		 + sdyn->output_offset
		 + sizeof esd
		 + EXTERNAL_SUN4_DYNAMIC_DEBUGGER_SIZE),
		esd.ld);
a2724 3
      if (! bfd_set_section_contents (abfd, sdyn->output_section, &esd,
				      sdyn->output_offset, sizeof esd))
	return false;
d2726 1
a2726 1
      PUT_WORD (dynobj, (bfd_vma) 0, esdl.ld_loaded);
d2728 6
a2733 6
      s = bfd_get_section_by_name (dynobj, ".need");
      if (s == NULL || s->_raw_size == 0)
	PUT_WORD (dynobj, (bfd_vma) 0, esdl.ld_need);
      else
	PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
		  esdl.ld_need);
d2735 6
a2740 6
      s = bfd_get_section_by_name (dynobj, ".rules");
      if (s == NULL || s->_raw_size == 0)
	PUT_WORD (dynobj, (bfd_vma) 0, esdl.ld_rules);
      else
	PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
		  esdl.ld_rules);
d2742 3
a2744 4
      s = bfd_get_section_by_name (dynobj, ".got");
      BFD_ASSERT (s != NULL);
      PUT_WORD (dynobj, s->output_section->vma + s->output_offset,
		esdl.ld_got);
d2746 4
a2749 5
      s = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (s != NULL);
      PUT_WORD (dynobj, s->output_section->vma + s->output_offset,
		esdl.ld_plt);
      PUT_WORD (dynobj, s->_raw_size, esdl.ld_plt_sz);
d2751 5
a2755 6
      s = bfd_get_section_by_name (dynobj, ".dynrel");
      BFD_ASSERT (s != NULL);
      BFD_ASSERT (s->reloc_count * obj_reloc_entry_size (dynobj)
		  == s->_raw_size);
      PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
		esdl.ld_rel);
d2757 4
a2760 4
      s = bfd_get_section_by_name (dynobj, ".hash");
      BFD_ASSERT (s != NULL);
      PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
		esdl.ld_hash);
d2762 4
a2765 4
      s = bfd_get_section_by_name (dynobj, ".dynsym");
      BFD_ASSERT (s != NULL);
      PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
		esdl.ld_stab);
d2767 1
a2767 1
      PUT_WORD (dynobj, (bfd_vma) 0, esdl.ld_stab_hash);
d2769 2
a2770 2
      PUT_WORD (dynobj, (bfd_vma) sunos_hash_table (info)->bucketcount,
		esdl.ld_buckets);
d2772 12
a2783 12
      s = bfd_get_section_by_name (dynobj, ".dynstr");
      BFD_ASSERT (s != NULL);
      PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
		esdl.ld_symbols);
      PUT_WORD (dynobj, s->_raw_size, esdl.ld_symb_size);

      /* The size of the text area is the size of the .text section
	 rounded up to a page boundary.  FIXME: Should the page size be
	 conditional on something?  */
      PUT_WORD (dynobj,
		BFD_ALIGN (obj_textsec (abfd)->_raw_size, 0x2000),
		esdl.ld_text);
d2785 6
a2790 6
      if (! bfd_set_section_contents (abfd, sdyn->output_section, &esdl,
				      (sdyn->output_offset
				       + sizeof esd
				       + EXTERNAL_SUN4_DYNAMIC_DEBUGGER_SIZE),
				      sizeof esdl))
	return false;
d2792 1
a2792 2
      abfd->flags |= DYNAMIC;
    }
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
   Free Software Foundation, Inc.
a85 2
   || ((mtype) == M_SPARCLITE_LE \
       && bfd_lookup_arch (bfd_arch_sparc, bfd_mach_sparc_sparclet) != NULL) \
a91 3
/* The SunOS 4.1.4 /usr/include/locale.h defines valid as a macro.  */
#undef valid

d780 1
a780 2
      flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	       | SEC_LINKER_CREATED);
a890 2
  dynobj = sunos_hash_table (info)->dynobj;

d896 2
a897 14
     space in the output file.  If this is the first object we have
     seen, we must preserve the dynamic sections we just created.  */
  if (abfd != dynobj)
    abfd->sections = NULL;
  else
    {
      asection *s;

      for (s = abfd->sections;
	   (s->flags & SEC_LINKER_CREATED) == 0;
	   s = s->next)
	;
      abfd->sections = s;
    }
d915 1
d1017 1
a1017 1
	  if ((size_t) (p - namebuf) >= alc)
d1153 1
a1153 2
	  h->root.root.type = bfd_link_hash_undefined;
	  h->root.root.u.undef.abfd = h->root.root.u.def.section->owner;
d1239 1
a1239 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1589 1
a1589 1
     asection *sec ATTRIBUTE_UNUSED;
d1749 1
a1749 1
     asection *sec ATTRIBUTE_UNUSED;
d2113 1
a2113 1
      strcpy ((char *) contents + s->_raw_size, h->root.root.root.string);
d2155 2
a2156 2
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     bfd *abfd ATTRIBUTE_UNUSED;
d2409 1
a2409 1
     bfd_byte *contents ATTRIBUTE_UNUSED;
a2416 1
  boolean pcrel;
d2425 1
a2425 4
  if (h != NULL
      && h->plt_offset != 0
      && (info->shared
	  || (h->flags & SUNOS_DEF_REGULAR) == 0))
a2444 1
	  pcrel = (0 != (srel->r_type[0] & RELOC_STD_BITS_PCREL_BIG));
a2449 1
	  pcrel = (0 != (srel->r_type[0] & RELOC_STD_BITS_PCREL_LITTLE));
a2467 7
      pcrel = (r_type == RELOC_DISP8
	       || r_type == RELOC_DISP16
	       || r_type == RELOC_DISP32
	       || r_type == RELOC_WDISP30
	       || r_type == RELOC_WDISP22);
      /* We don't consider the PC10 and PC22 types to be PC relative,
         because they are pcrel_offset.  */
a2704 2
      /* FIXME: We may have to change the addend for a PC relative
         reloc.  */
a2726 10
	}
      if (pcrel && h != NULL)
	{
	  /* Adjust the addend for the change in address.  */
	  PUT_WORD (dynobj,
		    (GET_WORD (dynobj, erel->r_addend)
		     - (input_section->output_section->vma
			+ input_section->output_offset
			- input_section->vma)),
		    erel->r_addend);
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1994, 1995, 1996, 1997, 1998, 2000
d511 1
a511 1

d1424 1
a1424 1

d2277 3
a2279 3
		  srel->r_index[0] = (bfd_byte) (h->dynindx >> 16);
		  srel->r_index[1] = (bfd_byte) (h->dynindx >> 8);
		  srel->r_index[2] = (bfd_byte) (h->dynindx);
d2285 2
a2286 2
		  srel->r_index[2] = (bfd_byte) (h->dynindx >> 16);
		  srel->r_index[1] = (bfd_byte) (h->dynindx >> 8);
d2300 2
a2301 2
		  erel->r_index[0] = (bfd_byte) (h->dynindx >> 16);
		  erel->r_index[1] = (bfd_byte) (h->dynindx >> 8);
d2309 2
a2310 2
		  erel->r_index[2] = (bfd_byte) (h->dynindx >> 16);
		  erel->r_index[1] = (bfd_byte) (h->dynindx >> 8);
d2597 2
a2598 2
		      srel->r_index[0] = (bfd_byte) (indx >> 16);
		      srel->r_index[1] = (bfd_byte) (indx >> 8);
d2611 2
a2612 2
		      srel->r_index[2] = (bfd_byte) (indx >> 16);
		      srel->r_index[1] = (bfd_byte) (indx >> 8);
d2636 2
a2637 2
		      erel->r_index[0] = (bfd_byte) (indx >> 16);
		      erel->r_index[1] = (bfd_byte) (indx >> 8);
d2649 2
a2650 2
		      erel->r_index[2] = (bfd_byte) (indx >> 16);
		      erel->r_index[1] = (bfd_byte) (indx >> 8);
d2729 2
a2730 2
	  srel->r_index[0] = (bfd_byte) (indx >> 16);
	  srel->r_index[1] = (bfd_byte) (indx >> 8);
d2735 2
a2736 2
	  srel->r_index[2] = (bfd_byte) (indx >> 16);
	  srel->r_index[1] = (bfd_byte) (indx >> 8);
d2754 2
a2755 2
	  erel->r_index[0] = (bfd_byte) (indx >> 16);
	  erel->r_index[1] = (bfd_byte) (indx >> 8);
d2760 2
a2761 2
	  erel->r_index[2] = (bfd_byte) (indx >> 16);
	  erel->r_index[1] = (bfd_byte) (indx >> 8);
d2936 1
a2936 1

@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1992, 1994, 1995, 1996, 1997, 1998, 2000, 2001,
   2002 Free Software Foundation, Inc.
d23 1
a23 5

/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
#define MY(OP) CONCAT2 (sunos_big_,OP)
d31 1
a31 1
static bfd_boolean sunos_read_dynamic_info PARAMS ((bfd *));
d33 1
a33 1
static bfd_boolean sunos_slurp_dynamic_symtab PARAMS ((bfd *));
d42 3
a44 3
static bfd_boolean sunos_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean));
static bfd_boolean sunos_add_dynamic_symbols
d47 1
a47 1
static bfd_boolean sunos_add_one_symbol
d49 1
a49 1
	   bfd_vma, const char *, bfd_boolean, bfd_boolean,
d51 1
a51 1
static bfd_boolean sunos_scan_relocs
d53 1
a53 1
static bfd_boolean sunos_scan_std_relocs
d56 1
a56 1
static bfd_boolean sunos_scan_ext_relocs
d59 1
a59 1
static bfd_boolean sunos_link_dynamic_object
d61 1
a61 1
static bfd_boolean sunos_write_dynamic_symbol
d63 1
a63 1
static bfd_boolean sunos_check_dynamic_reloc
d65 1
a65 1
	   struct aout_link_hash_entry *, PTR, bfd_byte *, bfd_boolean *,
d67 1
a67 1
static bfd_boolean sunos_finish_dynamic_link
d104 1
a104 1
  bfd_boolean valid;
d133 1
a133 1
   structure to FALSE to avoid doing this work again.  */
d135 1
a135 1
static bfd_boolean
a144 1
  bfd_size_type amt;
d147 1
a147 1
    return TRUE;
d152 1
a152 1
      return FALSE;
d155 2
a156 2
  amt = sizeof (struct sunos_dynamic_info);
  info = (struct sunos_dynamic_info *) bfd_zalloc (abfd, amt);
d158 2
a159 2
    return FALSE;
  info->valid = FALSE;
d175 1
a175 1
    return TRUE;
d177 2
a178 3
				  (file_ptr) 0,
				  (bfd_size_type) sizeof dyninfo))
    return TRUE;
d182 1
a182 1
    return TRUE;
d194 1
a194 1
    return TRUE;
d198 1
a198 2
  if (! bfd_get_section_contents (abfd, dynsec, (PTR) &linkinfo,
				  (file_ptr) dynoff,
d200 1
a200 1
    return TRUE;
d247 1
a247 1
  info->valid = TRUE;
d249 1
a249 1
  return TRUE;
d275 1
a275 1
static bfd_boolean
a279 1
  bfd_size_type amt;
d285 1
a285 1
	  return FALSE;
d292 1
a292 1
      return FALSE;
d298 4
a301 2
      amt = (bfd_size_type) info->dynsym_count * EXTERNAL_NLIST_SIZE;
      info->dynsym = (struct external_nlist *) bfd_alloc (abfd, amt);
d303 5
a307 3
	return FALSE;
      if (bfd_seek (abfd, (file_ptr) info->dyninfo.ld_stab, SEEK_SET) != 0
	  || bfd_bread ((PTR) info->dynsym, amt, abfd) != amt)
d314 1
a314 1
	  return FALSE;
d321 1
a321 2
      amt = info->dyninfo.ld_symb_size;
      info->dynstr = (char *) bfd_alloc (abfd, amt);
d323 5
a327 3
	return FALSE;
      if (bfd_seek (abfd, (file_ptr) info->dyninfo.ld_symbols, SEEK_SET) != 0
	  || bfd_bread ((PTR) info->dynstr, amt, abfd) != amt)
d334 1
a334 1
	  return FALSE;
d338 1
a338 1
  return TRUE;
d370 2
a371 2
    if (bfd_seek (abfd, (file_ptr) info->dyninfo.ld_hash, SEEK_SET) != 0
	|| bfd_bread ((PTR) table, table_size, abfd) != table_size)
d401 4
a404 5
      bfd_size_type size;
      bfd_size_type strsize = info->dyninfo.ld_symb_size;

      size = (bfd_size_type) info->dynsym_count * sizeof (aout_symbol_type);
      info->canonical_dynsym = (aout_symbol_type *) bfd_alloc (abfd, size);
d409 4
a412 3
					    info->dynsym,
					    (bfd_size_type) info->dynsym_count,
					    info->dynstr, strsize, TRUE))
a461 1
  bfd_size_type size;
d480 4
a483 3
      size = (bfd_size_type) info->dynrel_count * obj_reloc_entry_size (abfd);
      info->dynrel = (PTR) bfd_alloc (abfd, size);
      if (info->dynrel == NULL && size != 0)
d485 4
a488 2
      if (bfd_seek (abfd, (file_ptr) info->dyninfo.ld_rel, SEEK_SET) != 0
	  || bfd_bread ((PTR) info->dynrel, size, abfd) != size)
d505 4
a508 2
      size = (bfd_size_type) info->dynrel_count * sizeof (arelent);
      info->canonical_dynrel = (arelent *) bfd_alloc (abfd, size);
d523 1
a523 1
					  (bfd_size_type) info->dynsym_count);
d534 1
a534 1
					  (bfd_size_type) info->dynsym_count);
d567 1
a567 1
#define SPARC_PLT_ENTRY_WORD0 ((bfd_vma) 0x9de3bfa0)
d569 1
a569 1
#define SPARC_PLT_ENTRY_WORD1 ((bfd_vma) 0x40000000)
d571 1
a571 1
#define SPARC_PLT_ENTRY_WORD2 ((bfd_vma) 0x01000000)
d577 1
a577 1
#define SPARC_PLT_PIC_WORD0 ((bfd_vma) 0x03000000)
d579 1
a579 1
#define SPARC_PLT_PIC_WORD1 ((bfd_vma) 0x81c06000)
d581 1
a581 1
#define SPARC_PLT_PIC_WORD2 ((bfd_vma) 0x01000000)
d601 1
a601 1
#define M68K_PLT_ENTRY_WORD0 ((bfd_vma) 0x61ff)
d654 1
a654 1
  bfd_boolean dynamic_sections_created;
d657 1
a657 1
  bfd_boolean dynamic_sections_needed;
d660 1
a660 1
  bfd_boolean got_needed;
a717 1
  bfd_size_type amt = sizeof (struct sunos_link_hash_table);
d719 2
a720 1
  ret = (struct sunos_link_hash_table *) bfd_malloc (amt);
d726 1
a726 1
      free (ret);
d731 3
a733 3
  ret->dynamic_sections_created = FALSE;
  ret->dynamic_sections_needed = FALSE;
  ret->got_needed = FALSE;
d754 1
a754 1
    (bfd_boolean (*) PARAMS ((struct aout_link_hash_entry *, PTR))) (func), \
d762 1
a762 1
static bfd_boolean sunos_scan_dynamic_symbol
d772 1
a772 1
static bfd_boolean
d776 1
a776 1
     bfd_boolean needed;
d796 1
a796 1
	return FALSE;
d804 1
a804 1
	return FALSE;
d812 1
a812 1
	return FALSE;
d820 1
a820 1
	return FALSE;
d828 1
a828 1
	return FALSE;
d836 1
a836 1
	return FALSE;
d844 1
a844 1
	return FALSE;
d846 1
a846 1
      sunos_hash_table (info)->dynamic_sections_created = TRUE;
d860 2
a861 2
      sunos_hash_table (info)->dynamic_sections_needed = TRUE;
      sunos_hash_table (info)->got_needed = TRUE;
d864 1
a864 1
  return TRUE;
d870 1
a870 1
static bfd_boolean
d878 1
a881 1
  asection **ps;
d887 5
a891 3
					   ((abfd->flags & DYNAMIC) != 0
					    && !info->relocateable)))
	return FALSE;
d896 1
a896 1
    return TRUE;
d907 3
a909 1
  for (ps = &abfd->sections; *ps != NULL; )
d911 7
a917 4
      if (abfd != dynobj || ((*ps)->flags & SEC_LINKER_CREATED) == 0)
	bfd_section_list_remove (abfd, ps);
      else
	ps = &(*ps)->next;
d923 1
a923 1
    return TRUE;
d930 1
a930 1
      return FALSE;
d941 1
a941 1
      asection *s = bfd_make_section (dynobj, ".need");
d950 1
a950 1
	return FALSE;
d958 1
a958 1
      asection *s = bfd_make_section (dynobj, ".rules");
d967 1
a967 1
	return FALSE;
d972 1
a972 1
    return FALSE;
d988 1
a988 1
      bfd_size_type alc;
d992 3
a994 3
      if (bfd_seek (abfd, (file_ptr) need, SEEK_SET) != 0
	  || bfd_bread (buf, (bfd_size_type) 16, abfd) != 16)
	return FALSE;
d997 1
a997 1
	 should probably define structs for this manipulation.  */
d1001 2
a1002 2
      major_vno = (unsigned short) bfd_get_16 (abfd, buf + 8);
      minor_vno = (unsigned short) bfd_get_16 (abfd, buf + 10);
d1005 2
a1006 2
      alc = sizeof (struct bfd_link_needed_list);
      needed = (struct bfd_link_needed_list *) bfd_alloc (abfd, alc);
d1008 1
a1008 1
	return FALSE;
d1015 1
a1015 1
	return FALSE;
d1023 1
a1023 1
      if (bfd_seek (abfd, (file_ptr) name, SEEK_SET) != 0)
d1026 1
a1026 1
	  return FALSE;
d1031 1
a1031 1
	  if (bfd_bread (&b, (bfd_size_type) 1, abfd) != 1)
d1034 1
a1034 1
	      return FALSE;
d1037 1
a1037 1
	  if ((bfd_size_type) (p - namebuf) >= alc)
d1046 1
a1046 1
		  return FALSE;
d1078 1
a1078 1
		  return FALSE;
d1088 1
a1088 1
      namecopy = bfd_alloc (abfd, (bfd_size_type) strlen (namebuf) + 1);
d1092 1
a1092 1
	  return FALSE;
d1107 1
a1107 1
  return TRUE;
d1114 1
a1114 1
static bfd_boolean
d1124 2
a1125 2
     bfd_boolean copy;
     bfd_boolean collect;
d1133 2
a1134 2
    h = sunos_link_hash_lookup (sunos_hash_table (info), name, TRUE, copy,
				FALSE);
d1137 1
a1137 1
	 bfd_wrapped_link_hash_lookup (abfd, info, name, TRUE, copy, FALSE));
d1139 1
a1139 1
    return FALSE;
d1193 4
a1196 4
	 is from a dynamic object.  A constructor symbol is actually a
	 definition, although the type will be bfd_link_hash_undefined
	 at this point.  We want to ignore the definition from the
	 dynamic object.  */
d1206 2
a1207 2
	 is a constructor symbol.  As above, we want to force the use
	 of the constructor symbol from the regular object.  */
d1215 1
a1215 1
    return FALSE;
d1252 1
a1252 1
  return TRUE;
d1271 1
a1271 1
bfd_boolean
d1280 1
a1280 1
    return TRUE;
d1286 1
a1286 1
			      FALSE, FALSE, FALSE);
d1288 1
a1288 1
    return TRUE;
d1303 1
a1303 1
  return TRUE;
d1312 1
a1312 1
   info->keep_memory is TRUE, we keep the relocs in memory; otherwise,
d1315 1
a1315 1
bfd_boolean
d1325 1
a1325 1
  bfd_size_type dynsymcount;
d1329 1
a1329 1
  bfd_size_type hashalloc;
d1338 1
a1338 1
    return TRUE;
d1341 1
a1341 1
    return TRUE;
d1357 1
a1357 1
	    return FALSE;
d1368 1
a1368 1
    return TRUE;
d1372 1
a1372 1
			      "__GLOBAL_OFFSET_TABLE_", FALSE, FALSE, FALSE);
d1385 2
a1386 2
	 __GLOBAL_OFFSET_TABLE_ to be 0x1000 bytes into the section,
	 so that 13 bit relocations have a greater chance of working.  */
d1423 1
a1423 1
	return FALSE;
d1442 1
a1442 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, hashalloc);
d1444 2
a1445 1
	return FALSE;
d1473 1
a1473 1
					       s->_raw_size + add);
d1475 1
a1475 1
	    return FALSE;
d1490 1
a1490 1
	return FALSE;
d1513 1
a1513 1
	return FALSE;
d1523 1
a1523 1
    return FALSE;
d1528 1
a1528 1
  return TRUE;
d1533 1
a1533 1
static bfd_boolean
d1544 1
a1544 1
    return TRUE;
d1547 1
a1547 1
    relocs = free_relocs = bfd_malloc (rel_size);
a1550 1
      bfd_size_type amt = sizeof (struct aout_section_data_struct);
d1552 2
a1553 1
      n = (struct aout_section_data_struct *) bfd_alloc (abfd, amt);
d1559 1
a1559 1
	  relocs = bfd_malloc (rel_size);
d1564 1
a1564 1
    return FALSE;
d1567 1
a1567 1
      || bfd_bread (relocs, rel_size, abfd) != rel_size)
d1588 1
a1588 1
  return TRUE;
d1593 1
a1593 1
  return FALSE;
d1606 1
a1606 1
static bfd_boolean
d1624 1
a1624 1
      return FALSE;
d1686 2
a1687 2
	  if (! sunos_create_dynamic_sections (abfd, info, FALSE))
	    return FALSE;
d1697 1
a1697 1
	  sunos_hash_table (info)->got_needed = TRUE;
d1757 1
a1757 1
  return TRUE;
d1766 1
a1766 1
static bfd_boolean
a1779 1
  bfd_size_type amt;
d1785 1
a1785 1
      return FALSE;
d1832 1
a1832 1
	 the .got section.  */
d1839 2
a1840 2
	      if (! sunos_create_dynamic_sections (abfd, info, FALSE))
		return FALSE;
d1850 1
a1850 1
	      sunos_hash_table (info)->got_needed = TRUE;
a1870 2
		  amt = bfd_get_symcount (abfd);
		  amt *= sizeof (bfd_vma);
d1872 3
a1874 1
		    (bfd_vma *) bfd_zalloc (abfd, amt);
d1876 1
a1876 1
		    return FALSE;
d1900 2
a1901 2
	 defined in dynamic objects but not in regular objects.  We
	 only need to consider relocs against external symbols.  */
d1905 1
a1905 1
	     generate an absolute reloc.  */
d1910 2
a1911 2
		  if (! sunos_create_dynamic_sections (abfd, info, TRUE))
		    return FALSE;
d1947 2
a1948 2
	     here; just let the relocation routine report an undefined
	     symbol.  */
d1957 2
a1958 2
	  if (! sunos_create_dynamic_sections (abfd, info, FALSE))
	    return FALSE;
d1968 1
a1968 1
	  sunos_hash_table (info)->got_needed = TRUE;
d2033 2
a2034 2
		 is a JMP_TBL reloc produced by linking PIC compiled
		 code, and we are not making a shared library.  */
d2040 1
a2040 1
	     any reloc other than a jump table reloc.  */
d2046 1
a2046 1
  return TRUE;
d2052 1
a2052 1
static bfd_boolean
a2058 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct sunos_link_hash_entry *) h->root.root.u.i.link;

d2071 1
a2071 1
    h->root.written = TRUE;
d2130 1
a2130 1
	return FALSE;
d2166 1
a2166 1
  return TRUE;
d2174 1
a2174 1
static bfd_boolean
d2179 1
a2179 1
  return TRUE;
d2185 1
a2185 1
static bfd_boolean
d2204 1
d2233 2
d2253 1
a2253 1
	  bfd_put_16 (output_bfd, (bfd_vma) s->reloc_count, p + 6);
d2262 1
a2262 1
	 result of a JMP_TBL reloc from PIC compiled code.  */
d2328 1
a2328 1
    return TRUE;
d2336 1
a2336 1
      return TRUE;
d2394 1
a2394 1
      return TRUE;
d2402 2
a2403 2
  H_PUT_8 (output_bfd, type, outsym->e_type);
  H_PUT_8 (output_bfd, 0, outsym->e_other);
d2408 1
a2408 1
  H_PUT_16 (output_bfd, 0, outsym->e_desc);
d2413 1
a2413 1
  return TRUE;
d2422 1
a2422 1
static bfd_boolean
d2431 1
a2431 1
     bfd_boolean *skip;
d2436 3
a2438 3
  bfd_boolean baserel;
  bfd_boolean jmptbl;
  bfd_boolean pcrel;
d2443 1
a2443 1
  *skip = FALSE;
d2501 1
a2501 1
	 because they are pcrel_offset.  */
d2570 1
a2570 1
		 dynamic linker to fill in this entry in the table.  */
d2671 1
a2671 1
		      + (*got_offsetp &~ (bfd_vma) 1)
d2675 1
a2675 1
      return TRUE;
d2679 1
a2679 1
    return TRUE;
d2688 1
a2688 1
	return TRUE;
d2697 1
a2697 1
	return TRUE;
d2740 1
a2740 1
	 reloc.  */
d2779 1
a2779 1
    *skip = TRUE;
d2781 1
a2781 1
  return TRUE;
d2786 1
a2786 1
static bfd_boolean
d2798 1
a2798 1
    return TRUE;
d2848 1
a2848 2
					  o->contents,
					  (file_ptr) o->output_offset,
d2850 1
a2850 1
	    return FALSE;
a2857 1
      file_ptr pos;
d2872 2
a2873 3
				      (file_ptr) sdyn->output_offset,
				      (bfd_size_type) sizeof esd))
	return FALSE;
a2936 2
      pos = sdyn->output_offset;
      pos += sizeof esd + EXTERNAL_SUN4_DYNAMIC_DEBUGGER_SIZE;
d2938 5
a2942 2
				      pos, (bfd_size_type) sizeof esdl))
	return FALSE;
d2947 1
a2947 1
  return TRUE;
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2002, 2003 Free Software Foundation, Inc.
d887 1
a887 1
					    && !info->relocatable)))
d914 1
a914 1
  if (info->relocatable)
d1249 1
d1329 1
a1329 1
  if (info->relocatable)
d2168 1
d2413 1
@


