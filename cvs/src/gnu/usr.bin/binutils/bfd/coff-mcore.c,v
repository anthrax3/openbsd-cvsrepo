head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.4.0.50
	OPENBSD_6_2_BASE:1.1.1.4
	OPENBSD_6_1:1.1.1.4.0.52
	OPENBSD_6_1_BASE:1.1.1.4
	OPENBSD_6_0:1.1.1.4.0.48
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.44
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.46
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.38
	OPENBSD_5_7_BASE:1.1.1.4
	OPENBSD_5_6:1.1.1.4.0.42
	OPENBSD_5_6_BASE:1.1.1.4
	OPENBSD_5_5:1.1.1.4.0.40
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.36
	OPENBSD_5_4_BASE:1.1.1.4
	OPENBSD_5_3:1.1.1.4.0.34
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.32
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.30
	OPENBSD_5_0:1.1.1.4.0.28
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.26
	OPENBSD_4_9_BASE:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.24
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.20
	OPENBSD_4_7_BASE:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.22
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.18
	OPENBSD_4_5_BASE:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.16
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.14
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.12
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.10
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.8
	OPENBSD_4_0_BASE:1.1.1.4
	OPENBSD_3_9:1.1.1.4.0.6
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.4
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.2
	OPENBSD_3_7_BASE:1.1.1.4
	BINUTILS_2_15:1.1.1.4
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	BINUTILS-2_14:1.1.1.3
	OPENBSD_3_5:1.1.1.2.0.8
	OPENBSD_3_5_BASE:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.6
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.4
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.2
	OPENBSD_3_2_BASE:1.1.1.2
	binutils-2_11_2:1.1.1.2
	OPENBSD_3_1:1.1.1.1.0.8
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.6
	OPENBSD_3_0_BASE:1.1.1.1
	BINUTILS-2_10_1:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.4
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.2
	OPENBSD_2_8_BASE:1.1.1.1
	BINUTILS-2_10:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2000.09.12.14.45.27;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.09.12.14.45.27;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.05.13.13.20.57;	author fgsch;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.05.17.20.42.11;	author drahn;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.11.02.20.22.14;	author miod;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* BFD back-end for Motorola MCore COFF/PE
   Copyright (C) 1999 Free Software Foundation, Inc.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "coff/mcore.h"
#include "coff/internal.h"
#include "coff/pe.h"
#include "libcoff.h"

#ifdef BADMAG
#undef BADMAG
#endif
#define BADMAG(x) MCOREBADMAG(x)

#ifndef NUM_ELEM
#define NUM_ELEM(A) (sizeof (A) / sizeof (A)[0])
#endif

/* This file is compiled more than once, but we only compile the
   final_link routine once.  */
extern boolean mcore_bfd_coff_final_link
  PARAMS ((bfd *, struct bfd_link_info *));

static struct bfd_link_hash_table * coff_mcore_link_hash_table_create
  PARAMS ((bfd *));
static bfd_reloc_status_type        mcore_coff_unsupported_reloc 
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static boolean                      coff_mcore_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   struct internal_reloc *, struct internal_syment *, asection **));
static reloc_howto_type *           mcore_coff_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static reloc_howto_type *           coff_mcore_rtype_to_howto
  PARAMS ((bfd *, asection *, struct internal_reloc *,
	   struct coff_link_hash_entry *, struct internal_syment *, bfd_vma *));

/* The NT loader points the toc register to &toc + 32768, in order to
   use the complete range of a 16-bit displacement. We have to adjust
   for this when we fix up loads displaced off the toc reg.  */
#define TOC_LOAD_ADJUSTMENT (-32768)
#define TOC_SECTION_NAME ".private.toc"

/* The main body of code is in coffcode.h.  */
#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER 2

/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
   from smaller values.  Start with zero, widen, *then* decrement.  */
#define MINUS_ONE	(((bfd_vma)0) - 1)


static reloc_howto_type mcore_coff_howto_table[] =
{
  /* Unused: */
  HOWTO (IMAGE_REL_MCORE_ABSOLUTE,/* type */                                 
	 0,	                 /* rightshift */                           
	 0,	                 /* size (0 = byte, 1 = short, 2 = long) */ 
	 0,	                 /* bitsize */                   
	 false,	                 /* pc_relative */                          
	 0,	                 /* bitpos */                               
	 complain_overflow_dont, /* dont complain_on_overflow */
	 NULL,		         /* special_function */                     
	 "ABSOLUTE",             /* name */
	 false,	                 /* partial_inplace */                      
	 0x00,	 	         /* src_mask */                             
	 0x00,        		 /* dst_mask */                             
	 false),                 /* pcrel_offset */
  
  HOWTO (IMAGE_REL_MCORE_ADDR32,/* type */
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 NULL,		        /* special_function */                     
	 "ADDR32",              /* name */
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
	 false),                /* pcrel_offset */
  
  /* 8 bits + 2 zero bits; jmpi/jsri/lrw instructions.
     Should not appear in object files. */
  HOWTO (IMAGE_REL_MCORE_PCREL_IMM8BY4,	/* type */
	 2,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 mcore_coff_unsupported_reloc, /* special_function */
	 "IMM8BY4",             /* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 true),			/* pcrel_offset */

  /* bsr/bt/bf/br instructions; 11 bits + 1 zero bit 
     Span 2k instructions == 4k bytes.
     Only useful pieces at the relocated address are the opcode (5 bits) */
  HOWTO (IMAGE_REL_MCORE_PCREL_IMM11BY2,/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 11,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 NULL,	                /* special_function */
	 "IMM11BY2",            /* name */
	 false,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0x7ff,			/* dst_mask */
	 true),			/* pcrel_offset */

  /* 4 bits + 1 zero bit; 'loopt' instruction only; unsupported. */
  HOWTO (IMAGE_REL_MCORE_PCREL_IMM4BY2,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 4,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 mcore_coff_unsupported_reloc, /* special_function */
	 "IMM4BY2",              /* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 true),			/* pcrel_offset */

  /* 32-bit pc-relative. Eventually this will help support PIC code. */
  HOWTO (IMAGE_REL_MCORE_PCREL_32,/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 NULL,	                /* special_function */
	 "PCREL_32",	        /* name */
	 false,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 true),			/* pcrel_offset */

  /* Like PCREL_IMM11BY2, this relocation indicates that there is a
     'jsri' at the specified address. There is a separate relocation
     entry for the literal pool entry that it references, but we 
     might be able to change the jsri to a bsr if the target turns out
     to be close enough [even though we won't reclaim the literal pool
     entry, we'll get some runtime efficiency back]. Note that this
     is a relocation that we are allowed to safely ignore.  */ 
  HOWTO (IMAGE_REL_MCORE_PCREL_JSR_IMM11BY2,/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 11,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 NULL,	                /* special_function */
	 "JSR_IMM11BY2",        /* name */
	 false,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0x7ff,			/* dst_mask */
	 true),			/* pcrel_offset */
  
  HOWTO (IMAGE_REL_MCORE_RVA,   /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 NULL,                  /* special_function */
	 "MCORE_RVA",           /* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 true)			/* pcrel_offset */
};

/* Extend the coff_link_hash_table structure with a few M*Core specific fields.
   This allows us to store global data here without actually creating any
   global variables, which is a no-no in the BFD world.  */
typedef struct coff_mcore_link_hash_table
{
  /* The original coff_link_hash_table structure.  MUST be first field.  */
  struct coff_link_hash_table	root;

  bfd *                         bfd_of_toc_owner;
  long int                      global_toc_size;
  long int                      import_table_size;
  long int                      first_thunk_address;
  long int                      thunk_size;
}
mcore_hash_table;

/* Get the MCore coff linker hash table from a link_info structure.  */
#define coff_mcore_hash_table(info) \
  ((mcore_hash_table *) ((info)->hash))

/* Create an MCore coff linker hash table.  */
static struct bfd_link_hash_table *
coff_mcore_link_hash_table_create (abfd)
     bfd * abfd;
{
  mcore_hash_table * ret;

  ret = ((mcore_hash_table *) bfd_alloc (abfd, sizeof (* ret)));
  if (ret == (mcore_hash_table *) NULL)
    return NULL;

  if (! _bfd_coff_link_hash_table_init
      (& ret->root, abfd, _bfd_coff_link_hash_newfunc))
    {
      bfd_release (abfd, ret);
      return (struct bfd_link_hash_table *) NULL;
    }

  ret->bfd_of_toc_owner = NULL;
  ret->global_toc_size  = 0;
  ret->import_table_size = 0;
  ret->first_thunk_address = 0;
  ret->thunk_size = 0;

  return & ret->root.root;
}

/* Add an entry to the base file.  */
static void
mcore_emit_base_file_entry (info, output_bfd, input_section, reloc_offset)
      struct bfd_link_info * info;
      bfd *                  output_bfd;
      asection *             input_section;
      bfd_vma                reloc_offset;
{
  bfd_vma addr = reloc_offset
                 - input_section->vma
                 + input_section->output_offset
                 + input_section->output_section->vma;

  if (coff_data (output_bfd)->pe)
     addr -= pe_data (output_bfd)->pe_opthdr.ImageBase;
  
  fwrite (&addr, 1, sizeof (addr), (FILE *) info->base_file);
}

/*ARGSUSED*/
static bfd_reloc_status_type
mcore_coff_unsupported_reloc (abfd, reloc_entry, symbol, data, input_section,
			   output_bfd, error_message)
     bfd * abfd;
     arelent * reloc_entry;
     asymbol * symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection * input_section ATTRIBUTE_UNUSED;
     bfd * output_bfd ATTRIBUTE_UNUSED;
     char ** error_message ATTRIBUTE_UNUSED;
{
  BFD_ASSERT (reloc_entry->howto != (reloc_howto_type *)0);
  
  _bfd_error_handler (_("%s: Relocation %s (%d) is not currently supported.\n"),
		      bfd_get_filename (abfd),
		      reloc_entry->howto->name,
		      reloc_entry->howto->type);
  
  return bfd_reloc_notsupported;
}


/* A cheesy little macro to make the code a little more readable. */
#define HOW2MAP(bfd_rtype, mcore_rtype)  \
 case bfd_rtype: return & mcore_coff_howto_table [mcore_rtype]

static reloc_howto_type *
mcore_coff_reloc_type_lookup (abfd, code)
     bfd * abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
{
  switch (code)
    { 
      HOW2MAP (BFD_RELOC_32,                       IMAGE_REL_MCORE_ADDR32);
      HOW2MAP (BFD_RELOC_MCORE_PCREL_IMM8BY4,      IMAGE_REL_MCORE_PCREL_IMM8BY4);
      HOW2MAP (BFD_RELOC_MCORE_PCREL_IMM11BY2,     IMAGE_REL_MCORE_PCREL_IMM11BY2);
      HOW2MAP (BFD_RELOC_MCORE_PCREL_IMM4BY2,      IMAGE_REL_MCORE_PCREL_IMM4BY2);
      HOW2MAP (BFD_RELOC_32_PCREL,                 IMAGE_REL_MCORE_PCREL_32);
      HOW2MAP (BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2, IMAGE_REL_MCORE_PCREL_JSR_IMM11BY2);
      HOW2MAP (BFD_RELOC_RVA,                      IMAGE_REL_MCORE_RVA);
   default: 
      return NULL;
    }
  /*NOTREACHED*/
}

#undef HOW2MAP

#define RTYPE2HOWTO(cache_ptr, dst) \
  (cache_ptr)->howto = mcore_coff_howto_table + (dst)->r_type;

static reloc_howto_type *
coff_mcore_rtype_to_howto (abfd, sec, rel, h, sym, addendp)
     bfd * abfd ATTRIBUTE_UNUSED;
     asection * sec;
     struct internal_reloc * rel;
     struct coff_link_hash_entry * h ATTRIBUTE_UNUSED;
     struct internal_syment * sym;
     bfd_vma * addendp;
{
  reloc_howto_type * howto;


  if (rel->r_type >= NUM_ELEM (mcore_coff_howto_table))
    return NULL;
  
  howto = mcore_coff_howto_table + rel->r_type;

  if (rel->r_type == IMAGE_REL_MCORE_RVA)
    * addendp -= pe_data (sec->output_section->owner)->pe_opthdr.ImageBase;
  
  else if (howto->pc_relative)
    {
      * addendp = sec->vma - 2; /* XXX guess - is this right ? */
      
      /* If the symbol is defined, then the generic code is going to
         add back the symbol value in order to cancel out an
         adjustment it made to the addend.  However, we set the addend
         to 0 at the start of this function.  We need to adjust here,
         to avoid the adjustment the generic code will make.  FIXME:
         This is getting a bit hackish.  */
      if (sym != NULL && sym->n_scnum != 0)
	* addendp -= sym->n_value;
    }
  else
    * addendp = 0;
  
  return howto;
}

/* Return true if this relocation should appear in the output .reloc section.
   This function is referenced in pe_mkobject in peicode.h.  */
static boolean
in_reloc_p (abfd, howto)
     bfd * abfd ATTRIBUTE_UNUSED;
     reloc_howto_type * howto;
{
  return ! howto->pc_relative && howto->type != IMAGE_REL_MCORE_RVA;
}     


/* The reloc processing routine for the optimized COFF linker.  */
static boolean
coff_mcore_relocate_section (output_bfd, info, input_bfd, input_section,
			   contents, relocs, syms, sections)
     bfd * output_bfd;
     struct bfd_link_info * info;
     bfd * input_bfd;
     asection * input_section;
     bfd_byte * contents;
     struct internal_reloc * relocs;
     struct internal_syment * syms;
     asection ** sections;
{
  struct internal_reloc * rel;
  struct internal_reloc * relend;
  boolean hihalf;
  bfd_vma hihalf_val;
  
  /* If we are performing a relocateable link, we don't need to do a
     thing.  The caller will take care of adjusting the reloc
     addresses and symbol indices.  */
  if (info->relocateable)
    return true;
  
  /* Check if we have the same endianess */
  if (   input_bfd->xvec->byteorder != output_bfd->xvec->byteorder
      && output_bfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN)
    {
      (*_bfd_error_handler)
	(_("%s: compiled for a %s endian system and target is %s endian.\n"),
	 bfd_get_filename (input_bfd),
         bfd_big_endian (input_bfd) ? "big" : "little",
         bfd_big_endian (output_bfd) ? "big" : "little");

      bfd_set_error (bfd_error_wrong_format);
      return false;
    }

  hihalf = false;
  hihalf_val = 0;

  rel = relocs;
  relend = rel + input_section->reloc_count;
  
  for (; rel < relend; rel++)
    {
      long                           symndx;
      struct internal_syment *       sym;
      bfd_vma                        val;
      bfd_vma                        addend;
      bfd_reloc_status_type          rstat;
      bfd_byte *                     loc;
      unsigned short                 r_type = rel->r_type;
      reloc_howto_type *             howto = NULL;
      struct coff_link_hash_entry *  h;
      const char *                   my_name;
  
      symndx = rel->r_symndx;
      loc = contents + rel->r_vaddr - input_section->vma;

      if (symndx == -1)
	{
	  h = NULL;
	  sym = NULL;
	}
      else
	{
	  h = obj_coff_sym_hashes (input_bfd)[symndx];
	  sym = syms + symndx;
	}

      addend = 0;
      
      /* Get the howto and initialise the addend.  */
      howto = bfd_coff_rtype_to_howto (input_bfd, input_section, rel, h,
				       sym, & addend);
      if (howto == NULL)
	return false;

      val = 0;
      
      if (h == NULL)
	{
	  if (symndx == -1)
	    my_name = "*ABS*";
	  else
	    {
	      asection * sec = sections[symndx];
	      
	      val = (sym->n_value 
		     + sec->output_section->vma
		     + sec->output_offset);

	      if (sym == NULL)
		my_name = "*unknown*";
	      else if (   sym->_n._n_n._n_zeroes == 0
		       && sym->_n._n_n._n_offset != 0)
		my_name = obj_coff_strings (input_bfd) + sym->_n._n_n._n_offset;
	      else 
		{
		  static char buf [SYMNMLEN + 1];
		  
		  strncpy (buf, sym->_n._n_name, SYMNMLEN);
		  buf[SYMNMLEN] = '\0';
		  my_name = buf;
		}
	    }
	}
      else
	{
	  if (   h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      asection * sec = h->root.u.def.section;
	      
	      val = (h->root.u.def.value
		     + sec->output_section->vma
		     + sec->output_offset);
	    }
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd, input_section,
		      rel->r_vaddr - input_section->vma, true)))
		return false;
	    }
	  
	  my_name = h->root.root.string;
	}	

      rstat = bfd_reloc_ok;
      
      /* Each case must do its own relocation, setting rstat appropriately.  */
      switch (r_type)
	{
	default:
	  _bfd_error_handler (_("%s: unsupported relocation type 0x%02x"),
			      bfd_get_filename (input_bfd), r_type);
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	  
	case IMAGE_REL_MCORE_ABSOLUTE:
	  fprintf (stderr, 
		   _("Warning: unsupported reloc %s <file %s, section %s>\n"), 
		   howto->name,
		   bfd_get_filename (input_bfd),
		   input_section->name);
	  
	  fprintf (stderr,"sym %ld (%s), r_vaddr %ld (%lx)\n", 
		   rel->r_symndx, my_name, (long) rel->r_vaddr,
		   (unsigned long) rel->r_vaddr);  
	  break;
	  
	case IMAGE_REL_MCORE_PCREL_IMM8BY4:
	case IMAGE_REL_MCORE_PCREL_IMM11BY2:
	case IMAGE_REL_MCORE_PCREL_IMM4BY2:
	case IMAGE_REL_MCORE_PCREL_32:
	case IMAGE_REL_MCORE_PCREL_JSR_IMM11BY2:
	case IMAGE_REL_MCORE_ADDR32:
	  /* XXX fixme - shouldn't this be like the code for the RVA reloc ? */
	  rstat = _bfd_relocate_contents (howto, input_bfd, val, loc);
	  break;
	  
	case IMAGE_REL_MCORE_RVA:
	  rstat = _bfd_final_link_relocate
	    (howto, input_bfd,
	     input_section, contents, rel->r_vaddr - input_section->vma,
	     val, addend);
	  break;
	}
      
      if (info->base_file)
	{
	  /* Emit a reloc if the backend thinks it needs it.  */
	  if (sym && pe_data (output_bfd)->in_reloc_p (output_bfd, howto))
            mcore_emit_base_file_entry (info, output_bfd, input_section, rel->r_vaddr);
	}
  
      switch (rstat)
	{
	default:
	  abort ();
	  
	case bfd_reloc_ok:
	  break;
	  
	case bfd_reloc_overflow:
	  if (! ((*info->callbacks->reloc_overflow)
		 (info, my_name, howto->name, 
		  (bfd_vma) 0, input_bfd,
		  input_section, rel->r_vaddr - input_section->vma)))
	    return false;
	}
    }     

  return true;
}


/* Tailor coffcode.h -- macro heaven. */

/* We use the special COFF backend linker, with our own special touch.  */

#define coff_bfd_reloc_type_lookup   mcore_coff_reloc_type_lookup
#define coff_relocate_section        coff_mcore_relocate_section
#define coff_rtype_to_howto          coff_mcore_rtype_to_howto

#define SELECT_RELOC(internal, howto) {internal.r_type = howto->type;}

#define COFF_PAGE_SIZE               0x1000

#include "coffcode.h"

/* Forward declaration to initialise alterbative_target field.  */
extern const bfd_target TARGET_LITTLE_SYM;

/* The transfer vectors that lead the outside world to all of the above. */
CREATE_BIG_COFF_TARGET_VEC (TARGET_BIG_SYM, TARGET_BIG_NAME, D_PAGED, (SEC_LINK_ONCE | SEC_LINK_DUPLICATES), 0, & TARGET_LITTLE_SYM)
CREATE_LITTLE_COFF_TARGET_VEC (TARGET_LITTLE_SYM, TARGET_LITTLE_NAME, D_PAGED, (SEC_LINK_ONCE | SEC_LINK_DUPLICATES), 0, & TARGET_BIG_SYM)
@


1.1.1.1
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@@


1.1.1.2
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d45 1
a45 1
static bfd_reloc_status_type        mcore_coff_unsupported_reloc
d68 1
d73 6
a78 6
  HOWTO (IMAGE_REL_MCORE_ABSOLUTE,/* type */
	 0,	                 /* rightshift */
	 0,	                 /* size (0 = byte, 1 = short, 2 = long) */
	 0,	                 /* bitsize */
	 false,	                 /* pc_relative */
	 0,	                 /* bitpos */
d80 1
a80 1
	 NULL,		         /* special_function */
d82 3
a84 3
	 false,	                 /* partial_inplace */
	 0x00,	 	         /* src_mask */
	 0x00,        		 /* dst_mask */
d86 1
a86 1

d88 5
a92 5
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d94 1
a94 1
	 NULL,		        /* special_function */
d96 3
a98 3
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
d100 1
a100 1

d102 1
a102 1
     Should not appear in object files.  */
d117 1
a117 1
  /* bsr/bt/bf/br instructions; 11 bits + 1 zero bit
d134 1
a134 1
  /* 4 bits + 1 zero bit; 'loopt' instruction only; unsupported.  */
d149 1
a149 1
  /* 32-bit pc-relative. Eventually this will help support PIC code.  */
d166 1
a166 1
     entry for the literal pool entry that it references, but we
d170 1
a170 1
     is a relocation that we are allowed to safely ignore.  */
d184 1
a184 1

d262 1
a262 1

d266 1
d279 1
a279 1

d284 1
a284 1

d287 1
d289 1
a289 1
/* A cheesy little macro to make the code a little more readable.  */
d299 1
a299 1
    {
d307 1
a307 1
   default:
d329 1
d332 1
a332 1

d337 1
a337 1

d341 1
a341 1

d353 1
a353 1

d365 2
a366 1
}
d385 1
a385 1

d391 1
a391 1

d411 1
a411 1

d424 1
a424 1

d440 1
a440 1

d448 1
a448 1

d456 2
a457 2

	      val = (sym->n_value
d466 1
a466 1
	      else
d469 1
a469 1

d482 1
a482 1

d494 1
a494 1

d496 1
a496 1
	}
d499 1
a499 1

d508 1
a508 1

d510 2
a511 2
	  fprintf (stderr,
		   _("Warning: unsupported reloc %s <file %s, section %s>\n"),
d515 2
a516 2

	  fprintf (stderr,"sym %ld (%s), r_vaddr %ld (%lx)\n",
d518 1
a518 1
		   (unsigned long) rel->r_vaddr);
d520 1
a520 1

d530 1
a530 1

d538 1
a538 1

d545 1
a545 1

d550 1
a550 1

d553 1
a553 1

d556 1
a556 1
		 (info, my_name, howto->name,
d561 1
a561 1
    }
d565 1
d567 1
a567 1
/* Tailor coffcode.h -- macro heaven.  */
d584 3
a586 7
/* The transfer vectors that lead the outside world to all of the above.  */
CREATE_BIG_COFF_TARGET_VEC (TARGET_BIG_SYM, TARGET_BIG_NAME, D_PAGED,
			    (SEC_CODE | SEC_DATA | SEC_DEBUGGING | SEC_READONLY | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),
			    0, & TARGET_LITTLE_SYM)
CREATE_LITTLE_COFF_TARGET_VEC (TARGET_LITTLE_SYM, TARGET_LITTLE_NAME, D_PAGED,
			       (SEC_CODE | SEC_DATA | SEC_DEBUGGING | SEC_READONLY | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),
			       0, & TARGET_BIG_SYM)
@


1.1.1.3
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d40 1
a40 1
extern bfd_boolean mcore_bfd_coff_final_link
d42 2
a43 2
#if 0
static struct bfd_link_hash_table *coff_mcore_link_hash_table_create
d45 1
a45 2
#endif
static bfd_reloc_status_type mcore_coff_unsupported_reloc
d47 1
a47 1
static bfd_boolean coff_mcore_relocate_section
d50 1
a50 1
static reloc_howto_type *mcore_coff_reloc_type_lookup
d52 1
a52 1
static reloc_howto_type *coff_mcore_rtype_to_howto
d54 1
a54 5
	   struct coff_link_hash_entry *, struct internal_syment *,
	   bfd_vma *));
static void mcore_emit_base_file_entry
  PARAMS ((struct bfd_link_info *, bfd *, asection *, bfd_vma));
static bfd_boolean in_reloc_p PARAMS ((bfd *, reloc_howto_type *));
d76 1
a76 1
	 FALSE,	                 /* pc_relative */
d81 1
a81 1
	 FALSE,	                 /* partial_inplace */
d84 1
a84 1
	 FALSE),                 /* pcrel_offset */
d90 1
a90 1
	 FALSE,	                /* pc_relative */
d95 1
a95 1
	 TRUE,	                /* partial_inplace */
d98 1
a98 1
	 FALSE),                /* pcrel_offset */
d106 1
a106 1
	 TRUE,			/* pc_relative */
d111 1
a111 1
	 FALSE,			/* partial_inplace */
d114 1
a114 1
	 TRUE),			/* pcrel_offset */
d123 1
a123 1
	 TRUE,			/* pc_relative */
d128 1
a128 1
	 FALSE,			/* partial_inplace */
d131 1
a131 1
	 TRUE),			/* pcrel_offset */
d138 1
a138 1
	 TRUE,			/* pc_relative */
d143 1
a143 1
	 FALSE,			/* partial_inplace */
d146 1
a146 1
	 TRUE),			/* pcrel_offset */
d153 1
a153 1
	 TRUE,			/* pc_relative */
d158 1
a158 1
	 FALSE,			/* partial_inplace */
d161 1
a161 1
	 TRUE),			/* pcrel_offset */
d174 1
a174 1
	 TRUE,			/* pc_relative */
d179 1
a179 1
	 FALSE,			/* partial_inplace */
d182 1
a182 1
	 TRUE),			/* pcrel_offset */
d188 1
a188 1
	 FALSE,			/* pc_relative */
d193 1
a193 1
	 TRUE,			/* partial_inplace */
d196 1
a196 1
	 TRUE)			/* pcrel_offset */
a218 1
#if 0
a219 1

d226 1
a226 1
  ret = (mcore_hash_table *) bfd_malloc ((bfd_size_type) sizeof (* ret));
d233 1
a233 1
      free (ret);
a244 1
#endif
a246 1

d279 1
a279 1
		      bfd_archive_filename (abfd),
d353 1
a353 1
/* Return TRUE if this relocation should appear in the output .reloc section.
d355 1
a355 2

static bfd_boolean
d364 1
a364 1
static bfd_boolean
d378 1
a378 1
  bfd_boolean hihalf;
d385 1
a385 1
    return TRUE;
d392 4
a395 4
	(_("%s: compiled for a %s system and target is %s.\n"),
	 bfd_archive_filename (input_bfd),
         bfd_big_endian (input_bfd) ? _("big endian") : _("little endian"),
         bfd_big_endian (output_bfd) ? _("big endian") : _("little endian"));
d398 1
a398 1
      return FALSE;
d401 1
a401 1
  hihalf = FALSE;
d440 1
a440 1
	return FALSE;
d486 2
a487 2
		      rel->r_vaddr - input_section->vma, TRUE)))
		return FALSE;
d500 1
a500 1
			      bfd_archive_filename (input_bfd), r_type);
d502 1
a502 1
	  return FALSE;
d508 1
a508 1
		   bfd_archive_filename (input_bfd),
d554 1
a554 1
	    return FALSE;
d558 1
a558 1
  return TRUE;
a569 5

/* Make sure that the 'r_offset' field is copied properly
   so that identical binaries will compare the same.  */
#define SWAP_IN_RELOC_OFFSET         H_GET_32
#define SWAP_OUT_RELOC_OFFSET        H_PUT_32
@


1.1.1.4
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d391 1
a391 1
  /* If we are performing a relocatable link, we don't need to do a
d394 1
a394 1
  if (info->relocatable)
d590 1
a590 1
/* Forward declaration to initialise alternative_target field.  */
d596 1
a596 1
			    0, & TARGET_LITTLE_SYM, COFF_SWAP_TABLE)
d599 1
a599 1
			       0, & TARGET_BIG_SYM, COFF_SWAP_TABLE)
@


