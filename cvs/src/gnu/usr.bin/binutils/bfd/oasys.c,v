head	1.6;
access;
symbols
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.52
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.48
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.44
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.46
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.38
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.42
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.40
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.11.02.20.45.11;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.17.21.54.23;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.30;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.21;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.46.35;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.06;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.06;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.06.17;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.20.23;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.45.53;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.27.05;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.19;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.22.32;	author miod;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD back-end for oasys objects.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2001,
   2002, 2003 Free Software Foundation, Inc.
   Written by Steve Chamberlain of Cygnus Support, <sac@@cygnus.com>.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#define UNDERSCORE_HACK 1
#include "bfd.h"
#include "sysdep.h"
#include "safe-ctype.h"
#include "libbfd.h"
#include "oasys.h"
#include "liboasys.h"

static bfd_boolean oasys_slurp_section_data
  PARAMS ((bfd * const));
static bfd_boolean oasys_read_record
  PARAMS ((bfd *, oasys_record_union_type *));
static bfd_boolean oasys_write_sections
  PARAMS ((bfd *));
static bfd_boolean oasys_write_record
  PARAMS ((bfd *, oasys_record_enum_type, oasys_record_union_type *, size_t));
static bfd_boolean oasys_write_syms
  PARAMS ((bfd *));
static bfd_boolean oasys_write_header
  PARAMS ((bfd *));
static bfd_boolean oasys_write_end
  PARAMS ((bfd *));
static bfd_boolean oasys_write_data
  PARAMS ((bfd *));
static size_t oasys_string_length
  PARAMS ((oasys_record_union_type *));
static bfd_boolean oasys_slurp_symbol_table
  PARAMS ((bfd *const));
static long int oasys_get_symtab_upper_bound
  PARAMS ((bfd *const));
static const bfd_target *oasys_archive_p
  PARAMS ((bfd *));
static bfd_boolean oasys_mkobject
  PARAMS ((bfd *));
static const bfd_target *oasys_object_p
  PARAMS ((bfd *));
static void oasys_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
static void oasys_print_symbol
  PARAMS ((bfd *, void *, asymbol *, bfd_print_symbol_type));
static bfd_boolean oasys_new_section_hook
  PARAMS ((bfd *, asection *));
static long int oasys_get_reloc_upper_bound
  PARAMS ((bfd *, sec_ptr));
static bfd_boolean oasys_get_section_contents
  PARAMS ((bfd *, sec_ptr, void *, file_ptr, bfd_size_type));
static int comp
  PARAMS ((const void *, const void *));
static bfd_boolean oasys_write_object_contents
  PARAMS ((bfd *));
static bfd_boolean oasys_set_section_contents
  PARAMS ((bfd *, sec_ptr, const void *, file_ptr, bfd_size_type));
static asymbol *oasys_make_empty_symbol
  PARAMS ((bfd *));
static bfd *oasys_openr_next_archived_file
  PARAMS ((bfd *, bfd *));
static bfd_boolean oasys_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma,
	   const char **, const char **, unsigned int *));
static int oasys_generic_stat_arch_elt
  PARAMS ((bfd *, struct stat *));
static int oasys_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));

long oasys_canonicalize_symtab
  PARAMS ((bfd *, asymbol **));
long oasys_canonicalize_reloc
  PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));

/* Read in all the section data and relocation stuff too.  */

static bfd_boolean
oasys_read_record (abfd, record)
     bfd *abfd;
     oasys_record_union_type *record;
{
  bfd_size_type amt = sizeof (record->header);
  if (bfd_bread ((PTR) record, amt, abfd) != amt)
    return FALSE;

  amt = record->header.length - sizeof (record->header);
  if ((long) amt <= 0)
    return TRUE;
  if (bfd_bread ((PTR) ((char *) record + sizeof (record->header)), amt, abfd)
      != amt)
    return FALSE;
  return TRUE;
}

static size_t
oasys_string_length (record)
     oasys_record_union_type *record;
{
  return record->header.length
    - ((char *) record->symbol.name - (char *) record);
}

/*****************************************************************************/

/*

Slurp the symbol table by reading in all the records at the start file
till we get to the first section record.

We'll sort the symbolss into  two lists, defined and undefined. The
undefined symbols will be placed into the table according to their
refno.

We do this by placing all undefined symbols at the front of the table
moving in, and the defined symbols at the end of the table moving back.

*/

static bfd_boolean
oasys_slurp_symbol_table (abfd)
     bfd *const abfd;
{
  oasys_record_union_type record;
  oasys_data_type *data = OASYS_DATA (abfd);
  bfd_boolean loop = TRUE;
  asymbol *dest_defined;
  asymbol *dest;
  char *string_ptr;
  bfd_size_type amt;

  if (data->symbols != (asymbol *) NULL)
    {
      return TRUE;
    }
  /* Buy enough memory for all the symbols and all the names */
  amt = abfd->symcount;
  amt *= sizeof (asymbol);
  data->symbols = (asymbol *) bfd_alloc (abfd, amt);

  amt = data->symbol_string_length;
#ifdef UNDERSCORE_HACK
  /* buy 1 more char for each symbol to keep the underscore in*/
  amt += abfd->symcount;
#endif
  data->strings = bfd_alloc (abfd, amt);

  if (!data->symbols || !data->strings)
    return FALSE;

  dest_defined = data->symbols + abfd->symcount - 1;

  string_ptr = data->strings;
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    return FALSE;
  while (loop)
    {

      if (! oasys_read_record (abfd, &record))
	return FALSE;
      switch (record.header.type)
	{
	case oasys_record_is_header_enum:
	  break;
	case oasys_record_is_local_enum:
	case oasys_record_is_symbol_enum:
	  {
	    int flag = record.header.type == (int) oasys_record_is_local_enum ?
	    (BSF_LOCAL) : (BSF_GLOBAL | BSF_EXPORT);


	    size_t length = oasys_string_length (&record);
	    switch (record.symbol.relb & RELOCATION_TYPE_BITS)
	      {
	      case RELOCATION_TYPE_ABS:
		dest = dest_defined--;
		dest->section = bfd_abs_section_ptr;
		dest->flags = 0;

		break;
	      case RELOCATION_TYPE_REL:
		dest = dest_defined--;
		dest->section =
		  OASYS_DATA (abfd)->sections[record.symbol.relb &
					      RELOCATION_SECT_BITS];
		if (record.header.type == (int) oasys_record_is_local_enum)
		  {
		    dest->flags = BSF_LOCAL;
		    if (dest->section == (asection *) (~0))
		      {
			/* It seems that sometimes internal symbols are tied up, but
		       still get output, even though there is no
		       section */
			dest->section = 0;
		      }
		  }
		else
		  {

		    dest->flags = flag;
		  }
		break;
	      case RELOCATION_TYPE_UND:
		dest = data->symbols + H_GET_16 (abfd, record.symbol.refno);
		dest->section = bfd_und_section_ptr;
		break;
	      case RELOCATION_TYPE_COM:
		dest = dest_defined--;
		dest->name = string_ptr;
		dest->the_bfd = abfd;

		dest->section = bfd_com_section_ptr;

		break;
	      default:
		dest = dest_defined--;
		BFD_ASSERT (0);
		break;
	      }
	    dest->name = string_ptr;
	    dest->the_bfd = abfd;
	    dest->udata.p = (PTR) NULL;
	    dest->value = H_GET_32 (abfd, record.symbol.value);

#ifdef UNDERSCORE_HACK
	    if (record.symbol.name[0] != '_')
	      {
		string_ptr[0] = '_';
		string_ptr++;
	      }
#endif
	    memcpy (string_ptr, record.symbol.name, length);


	    string_ptr[length] = 0;
	    string_ptr += length + 1;
	  }
	  break;
	default:
	  loop = FALSE;
	}
    }
  return TRUE;
}

static long
oasys_get_symtab_upper_bound (abfd)
     bfd *const abfd;
{
  if (! oasys_slurp_symbol_table (abfd))
    return -1;

  return (abfd->symcount + 1) * (sizeof (oasys_symbol_type *));
}

extern const bfd_target oasys_vec;

long
oasys_canonicalize_symtab (abfd, location)
     bfd *abfd;
     asymbol **location;
{
  asymbol *symbase;
  unsigned int counter;
  if (! oasys_slurp_symbol_table (abfd))
    {
      return -1;
    }
  symbase = OASYS_DATA (abfd)->symbols;
  for (counter = 0; counter < abfd->symcount; counter++)
    {
      *(location++) = symbase++;
    }
  *location = 0;
  return abfd->symcount;
}

/***********************************************************************
*  archive stuff
*/

static const bfd_target *
oasys_archive_p (abfd)
     bfd *abfd;
{
  oasys_archive_header_type header;
  oasys_extarchive_header_type header_ext;
  unsigned int i;
  file_ptr filepos;
  bfd_size_type amt;

  amt = sizeof (header_ext);
  if (bfd_seek (abfd, (file_ptr) 0, 0) != 0
      || bfd_bread ((PTR) &header_ext, amt, abfd) != amt)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  header.version = H_GET_32 (abfd, header_ext.version);
  header.mod_count = H_GET_32 (abfd, header_ext.mod_count);
  header.mod_tbl_offset = H_GET_32 (abfd, header_ext.mod_tbl_offset);
  header.sym_tbl_size = H_GET_32 (abfd, header_ext.sym_tbl_size);
  header.sym_count = H_GET_32 (abfd, header_ext.sym_count);
  header.sym_tbl_offset = H_GET_32 (abfd, header_ext.sym_tbl_offset);
  header.xref_count = H_GET_32 (abfd, header_ext.xref_count);
  header.xref_lst_offset = H_GET_32 (abfd, header_ext.xref_lst_offset);

  /*
    There isn't a magic number in an Oasys archive, so the best we
    can do to verify reasonableness is to make sure that the values in
    the header are too weird
    */

  if (header.version > 10000 ||
      header.mod_count > 10000 ||
      header.sym_count > 100000 ||
      header.xref_count > 100000)
    return (const bfd_target *) NULL;

  /*
    That all worked, let's buy the space for the header and read in
    the headers.
    */
  {
    oasys_ar_data_type *ar;
    oasys_module_info_type *module;
    oasys_module_table_type record;

    amt = sizeof (oasys_ar_data_type);
    ar = (oasys_ar_data_type *) bfd_alloc (abfd, amt);

    amt = header.mod_count;
    amt *= sizeof (oasys_module_info_type);
    module = (oasys_module_info_type *) bfd_alloc (abfd, amt);

    if (!ar || !module)
      return NULL;

    abfd->tdata.oasys_ar_data = ar;
    ar->module = module;
    ar->module_count = header.mod_count;

    filepos = header.mod_tbl_offset;
    for (i = 0; i < header.mod_count; i++)
      {
	if (bfd_seek (abfd, filepos, SEEK_SET) != 0)
	  return NULL;

	/* There are two ways of specifying the archive header */

	if (0)
	  {
	    oasys_extmodule_table_type_a_type record_ext;

	    amt = sizeof (record_ext);
	    if (bfd_bread ((PTR) &record_ext, amt, abfd) != amt)
	      return NULL;

	    record.mod_size = H_GET_32 (abfd, record_ext.mod_size);
	    record.file_offset = H_GET_32 (abfd, record_ext.file_offset);

	    record.dep_count = H_GET_32 (abfd, record_ext.dep_count);
	    record.depee_count = H_GET_32 (abfd, record_ext.depee_count);
	    record.sect_count = H_GET_32 (abfd, record_ext.sect_count);

	    module[i].name = bfd_alloc (abfd, (bfd_size_type) 33);
	    if (!module[i].name)
	      return NULL;

	    memcpy (module[i].name, record_ext.mod_name, 33);
	    filepos +=
	      sizeof (record_ext) +
	      record.dep_count * 4 +
	      record.depee_count * 4 +
	      record.sect_count * 8 + 187;
	  }
	else
	  {
	    oasys_extmodule_table_type_b_type record_ext;

	    amt = sizeof (record_ext);
	    if (bfd_bread ((PTR) &record_ext, amt, abfd) != amt)
	      return NULL;

	    record.mod_size = H_GET_32 (abfd, record_ext.mod_size);
	    record.file_offset = H_GET_32 (abfd, record_ext.file_offset);

	    record.dep_count = H_GET_32 (abfd, record_ext.dep_count);
	    record.depee_count = H_GET_32 (abfd, record_ext.depee_count);
	    record.sect_count = H_GET_32 (abfd, record_ext.sect_count);
	    record.module_name_size = H_GET_32 (abfd,
						record_ext.mod_name_length);

	    amt = record.module_name_size;
	    module[i].name = bfd_alloc (abfd, amt + 1);
	    if (!module[i].name)
	      return NULL;
	    if (bfd_bread ((PTR) module[i].name, amt, abfd) != amt)
	      return NULL;
	    module[i].name[record.module_name_size] = 0;
	    filepos += (sizeof (record_ext)
			+ record.dep_count * 4
			+ record.module_name_size + 1);
	  }

	module[i].size = record.mod_size;
	module[i].pos = record.file_offset;
	module[i].abfd = 0;
      }
  }
  return abfd->xvec;
}

static bfd_boolean
oasys_mkobject (abfd)
     bfd *abfd;
{
  bfd_size_type amt = sizeof (oasys_data_type);
  abfd->tdata.oasys_obj_data = (oasys_data_type *) bfd_alloc (abfd, amt);
  return abfd->tdata.oasys_obj_data != NULL;
}

#define MAX_SECS 16
static const bfd_target *
oasys_object_p (abfd)
     bfd *abfd;
{
  oasys_data_type *oasys;
  oasys_data_type *save = OASYS_DATA (abfd);
  bfd_boolean loop = TRUE;
  bfd_boolean had_usefull = FALSE;

  abfd->tdata.oasys_obj_data = 0;
  oasys_mkobject (abfd);
  oasys = OASYS_DATA (abfd);
  memset ((PTR) oasys->sections, 0xff, sizeof (oasys->sections));

  /* Point to the start of the file */
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    goto fail;
  oasys->symbol_string_length = 0;
  /* Inspect the records, but only keep the section info -
     remember the size of the symbols
     */
  oasys->first_data_record = 0;
  while (loop)
    {
      oasys_record_union_type record;
      if (! oasys_read_record (abfd, &record))
	goto fail;
      if ((size_t) record.header.length < (size_t) sizeof (record.header))
	goto fail;


      switch ((oasys_record_enum_type) (record.header.type))
	{
	case oasys_record_is_header_enum:
	  had_usefull = TRUE;
	  break;
	case oasys_record_is_symbol_enum:
	case oasys_record_is_local_enum:
	  /* Count symbols and remember their size for a future malloc   */
	  abfd->symcount++;
	  oasys->symbol_string_length += 1 + oasys_string_length (&record);
	  had_usefull = TRUE;
	  break;
	case oasys_record_is_section_enum:
	  {
	    asection *s;
	    char *buffer;
	    unsigned int section_number;
	    if (record.section.header.length != sizeof (record.section))
	      {
		goto fail;
	      }
	    buffer = bfd_alloc (abfd, (bfd_size_type) 3);
	    if (!buffer)
	      goto fail;
	    section_number = record.section.relb & RELOCATION_SECT_BITS;
	    sprintf (buffer, "%u", section_number);
	    s = bfd_make_section (abfd, buffer);
	    oasys->sections[section_number] = s;
	    switch (record.section.relb & RELOCATION_TYPE_BITS)
	      {
	      case RELOCATION_TYPE_ABS:
	      case RELOCATION_TYPE_REL:
		break;
	      case RELOCATION_TYPE_UND:
	      case RELOCATION_TYPE_COM:
		BFD_FAIL ();
	      }

	    s->_raw_size = H_GET_32 (abfd, record.section.value);
	    s->vma = H_GET_32 (abfd, record.section.vma);
	    s->flags = 0;
	    had_usefull = TRUE;
	  }
	  break;
	case oasys_record_is_data_enum:
	  oasys->first_data_record = bfd_tell (abfd) - record.header.length;
	case oasys_record_is_debug_enum:
	case oasys_record_is_module_enum:
	case oasys_record_is_named_section_enum:
	case oasys_record_is_end_enum:
	  if (! had_usefull)
	    goto fail;
	  loop = FALSE;
	  break;
	default:
	  goto fail;
	}
    }
  oasys->symbols = (asymbol *) NULL;
  /*
    Oasys support several architectures, but I can't see a simple way
    to discover which one is in a particular file - we'll guess
    */
  bfd_default_set_arch_mach (abfd, bfd_arch_m68k, 0);
  if (abfd->symcount != 0)
    {
      abfd->flags |= HAS_SYMS;
    }

  /*
    We don't know if a section has data until we've read it..
    */

  oasys_slurp_section_data (abfd);


  return abfd->xvec;

fail:
  (void) bfd_release (abfd, oasys);
  abfd->tdata.oasys_obj_data = save;
  return (const bfd_target *) NULL;
}


static void
oasys_get_symbol_info (ignore_abfd, symbol, ret)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *symbol;
     symbol_info *ret;
{
  bfd_symbol_info (symbol, ret);
  if (!symbol->section)
    ret->type = (symbol->flags & BSF_LOCAL) ? 'a' : 'A';
}

static void
oasys_print_symbol (abfd, afile, symbol, how)
     bfd *abfd;
     PTR afile;
     asymbol *symbol;
     bfd_print_symbol_type how;
{
  FILE *file = (FILE *) afile;

  switch (how)
    {
    case bfd_print_symbol_name:
    case bfd_print_symbol_more:
      fprintf (file, "%s", symbol->name);
      break;
    case bfd_print_symbol_all:
      {
	const char *section_name = symbol->section == (asection *) NULL ?
	(const char *) "*abs" : symbol->section->name;

	bfd_print_symbol_vandf (abfd, (PTR) file, symbol);

	fprintf (file, " %-5s %s",
		 section_name,
		 symbol->name);
      }
      break;
    }
}
/*
 The howto table is build using the top two bits of a reloc byte to
 index into it. The bits are PCREL,WORD/LONG
*/
static reloc_howto_type howto_table[] =
{

  HOWTO (0, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, 0, "abs16", TRUE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (0, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, 0, "abs32", TRUE, 0xffffffff, 0xffffffff, FALSE),
  HOWTO (0, 0, 1, 16, TRUE, 0, complain_overflow_signed, 0, "pcrel16", TRUE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (0, 0, 2, 32, TRUE, 0, complain_overflow_signed, 0, "pcrel32", TRUE, 0xffffffff, 0xffffffff, FALSE)
};

/* Read in all the section data and relocation stuff too */
static bfd_boolean
oasys_slurp_section_data (abfd)
     bfd *const abfd;
{
  oasys_record_union_type record;
  oasys_data_type *data = OASYS_DATA (abfd);
  bfd_boolean loop = TRUE;
  oasys_per_section_type *per;
  asection *s;
  bfd_size_type amt;

  /* See if the data has been slurped already .. */
  for (s = abfd->sections; s != (asection *) NULL; s = s->next)
    {
      per = oasys_per_section (s);
      if (per->initialized)
	return TRUE;
    }

  if (data->first_data_record == 0)
    return TRUE;

  if (bfd_seek (abfd, data->first_data_record, SEEK_SET) != 0)
    return FALSE;
  while (loop)
    {
      if (! oasys_read_record (abfd, &record))
	return FALSE;
      switch (record.header.type)
	{
	case oasys_record_is_header_enum:
	  break;
	case oasys_record_is_data_enum:
	  {

	    bfd_byte *src = record.data.data;
	    bfd_byte *end_src = ((bfd_byte *) & record) + record.header.length;
	    bfd_byte *dst_ptr;
	    bfd_byte *dst_base_ptr;
	    unsigned int relbit;
	    unsigned int count;
	    asection *section =
	    data->sections[record.data.relb & RELOCATION_SECT_BITS];
	    bfd_vma dst_offset;

	    per = oasys_per_section (section);

	    if (! per->initialized)
	      {
		per->data = (bfd_byte *) bfd_zalloc (abfd, section->_raw_size);
		if (!per->data)
		  return FALSE;
		per->reloc_tail_ptr
		  = (oasys_reloc_type **) &section->relocation;
		per->had_vma = FALSE;
		per->initialized = TRUE;
		section->reloc_count = 0;
		section->flags = SEC_ALLOC;
	      }

	    dst_offset = H_GET_32 (abfd, record.data.addr);
	    if (! per->had_vma)
	      {
		/* Take the first vma we see as the base */
		section->vma = dst_offset;
		per->had_vma = TRUE;
	      }

	    dst_offset -= section->vma;

	    dst_base_ptr = oasys_per_section (section)->data;
	    dst_ptr = oasys_per_section (section)->data +
	      dst_offset;

	    if (src < end_src)
	      {
		section->flags |= SEC_LOAD | SEC_HAS_CONTENTS;
	      }
	    while (src < end_src)
	      {
		unsigned char mod_byte = *src++;
		size_t gap = end_src - src;

		count = 8;
		if (mod_byte == 0 && gap >= 8)
		  {
		    dst_ptr[0] = src[0];
		    dst_ptr[1] = src[1];
		    dst_ptr[2] = src[2];
		    dst_ptr[3] = src[3];
		    dst_ptr[4] = src[4];
		    dst_ptr[5] = src[5];
		    dst_ptr[6] = src[6];
		    dst_ptr[7] = src[7];
		    dst_ptr += 8;
		    src += 8;
		  }
		else
		  {
		    for (relbit = 1; count-- != 0 && src < end_src; relbit <<= 1)
		      {
			if (relbit & mod_byte)
			  {
			    unsigned char reloc = *src;
			    /* This item needs to be relocated */
			    switch (reloc & RELOCATION_TYPE_BITS)
			      {
			      case RELOCATION_TYPE_ABS:

				break;

			      case RELOCATION_TYPE_REL:
				{
				  /* Relocate the item relative to the section */
				  oasys_reloc_type *r;

				  amt = sizeof (oasys_reloc_type);
				  r = (oasys_reloc_type *) bfd_alloc (abfd,
								      amt);
				  if (!r)
				    return FALSE;
				  *(per->reloc_tail_ptr) = r;
				  per->reloc_tail_ptr = &r->next;
				  r->next = (oasys_reloc_type *) NULL;
				  /* Reference to undefined symbol */
				  src++;
				  /* There is no symbol */
				  r->symbol = 0;
				  /* Work out the howto */
				  abort ();
#if 0
				  r->relent.section =
				    data->sections[reloc &
						   RELOCATION_SECT_BITS];

				  r->relent.addend = -
				    r->relent.section->vma;
#endif
				  r->relent.address = dst_ptr - dst_base_ptr;
				  r->relent.howto = &howto_table[reloc >> 6];
				  r->relent.sym_ptr_ptr = (asymbol **) NULL;
				  section->reloc_count++;

				  /* Fake up the data to look like
				     it's got the -ve pc in it, this
				     makes it much easier to convert
				     into other formats.  This is done
				     by hitting the addend.  */
				  if (r->relent.howto->pc_relative)
				    r->relent.addend -= dst_ptr - dst_base_ptr;
				}
				break;


			      case RELOCATION_TYPE_UND:
				{
				  oasys_reloc_type *r;

				  amt = sizeof (oasys_reloc_type);
				  r = (oasys_reloc_type *) bfd_alloc (abfd,
								      amt);
				  if (!r)
				    return FALSE;
				  *(per->reloc_tail_ptr) = r;
				  per->reloc_tail_ptr = &r->next;
				  r->next = (oasys_reloc_type *) NULL;
				  /* Reference to undefined symbol */
				  src++;
				  /* Get symbol number */
				  r->symbol = (src[0] << 8) | src[1];
				  /* Work out the howto */
				  abort ();

#if 0
				  r->relent.section = (asection
						       *) NULL;
#endif
				  r->relent.addend = 0;
				  r->relent.address = dst_ptr - dst_base_ptr;
				  r->relent.howto = &howto_table[reloc >> 6];
				  r->relent.sym_ptr_ptr = (asymbol **) NULL;
				  section->reloc_count++;

				  src += 2;
				  /* Fake up the data to look like
				     it's got the -ve pc in it, this
				     makes it much easier to convert
				     into other formats.  This is done
				     by hitting the addend.  */
				  if (r->relent.howto->pc_relative)
				    r->relent.addend -= dst_ptr - dst_base_ptr;
				}
				break;
			      case RELOCATION_TYPE_COM:
				BFD_FAIL ();
			      }
			  }
			*dst_ptr++ = *src++;
		      }
		  }
	      }
	  }
	  break;
	case oasys_record_is_local_enum:
	case oasys_record_is_symbol_enum:
	case oasys_record_is_section_enum:
	  break;
	default:
	  loop = FALSE;
	}
    }

  return TRUE;

}

static bfd_boolean
oasys_new_section_hook (abfd, newsect)
     bfd *abfd;
     asection *newsect;
{
  newsect->used_by_bfd = (PTR)
    bfd_alloc (abfd, (bfd_size_type) sizeof (oasys_per_section_type));
  if (!newsect->used_by_bfd)
    return FALSE;
  oasys_per_section (newsect)->data = (bfd_byte *) NULL;
  oasys_per_section (newsect)->section = newsect;
  oasys_per_section (newsect)->offset = 0;
  oasys_per_section (newsect)->initialized = FALSE;
  newsect->alignment_power = 1;
  /* Turn the section string into an index */

  sscanf (newsect->name, "%u", &newsect->target_index);

  return TRUE;
}


static long
oasys_get_reloc_upper_bound (abfd, asect)
     bfd *abfd;
     sec_ptr asect;
{
  if (! oasys_slurp_section_data (abfd))
    return -1;
  return (asect->reloc_count + 1) * sizeof (arelent *);
}

static bfd_boolean
oasys_get_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     PTR location;
     file_ptr offset;
     bfd_size_type count;
{
  oasys_per_section_type *p = oasys_per_section (section);
  oasys_slurp_section_data (abfd);
  if (! p->initialized)
    {
      (void) memset (location, 0, (size_t) count);
    }
  else
    {
      (void) memcpy (location, (PTR) (p->data + offset), (size_t) count);
    }
  return TRUE;
}


long
oasys_canonicalize_reloc (ignore_abfd, section, relptr, symbols)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     sec_ptr section;
     arelent **relptr;
     asymbol **symbols ATTRIBUTE_UNUSED;
{
  unsigned int reloc_count = 0;
  oasys_reloc_type *src = (oasys_reloc_type *) (section->relocation);
  while (src != (oasys_reloc_type *) NULL)
    {
      abort ();

#if 0
      if (src->relent.section == (asection *) NULL)
	{
	  src->relent.sym_ptr_ptr = symbols + src->symbol;
	}
#endif

      *relptr++ = &src->relent;
      src = src->next;
      reloc_count++;
    }
  *relptr = (arelent *) NULL;
  return section->reloc_count = reloc_count;
}




/* Writing */


/* Calculate the checksum and write one record */
static bfd_boolean
oasys_write_record (abfd, type, record, size)
     bfd *abfd;
     oasys_record_enum_type type;
     oasys_record_union_type *record;
     size_t size;
{
  int checksum;
  size_t i;
  unsigned char *ptr;

  record->header.length = size;
  record->header.type = (int) type;
  record->header.check_sum = 0;
  record->header.fill = 0;
  ptr = (unsigned char *) &record->pad[0];
  checksum = 0;
  for (i = 0; i < size; i++)
    {
      checksum += *ptr++;
    }
  record->header.check_sum = 0xff & (-checksum);
  if (bfd_bwrite ((PTR) record, (bfd_size_type) size, abfd) != size)
    return FALSE;
  return TRUE;
}


/* Write out all the symbols */
static bfd_boolean
oasys_write_syms (abfd)
     bfd *abfd;
{
  unsigned int count;
  asymbol **generic = bfd_get_outsymbols (abfd);
  unsigned int index = 0;
  for (count = 0; count < bfd_get_symcount (abfd); count++)
    {

      oasys_symbol_record_type symbol;
      asymbol *const g = generic[count];

      const char *src = g->name;
      char *dst = symbol.name;
      unsigned int l = 0;

      if (bfd_is_com_section (g->section))
	{
	  symbol.relb = RELOCATION_TYPE_COM;
	  H_PUT_16 (abfd, index, symbol.refno);
	  index++;
	}
      else if (bfd_is_abs_section (g->section))
	{
	  symbol.relb = RELOCATION_TYPE_ABS;
	  H_PUT_16 (abfd, 0, symbol.refno);

	}
      else if (bfd_is_und_section (g->section))
	{
	  symbol.relb = RELOCATION_TYPE_UND;
	  H_PUT_16 (abfd, index, symbol.refno);
	  /* Overload the value field with the output index number */
	  index++;
	}
      else if (g->flags & BSF_DEBUGGING)
	{
	  /* throw it away */
	  continue;
	}
      else
	{
	  if (g->section == (asection *) NULL)
	    {
	      /* Sometime, the oasys tools give out a symbol with illegal
	   bits in it, we'll output it in the same broken way */

	      symbol.relb = RELOCATION_TYPE_REL | 0;
	    }
	  else
	    {
	      symbol.relb = RELOCATION_TYPE_REL | g->section->output_section->target_index;
	    }
	  H_PUT_16 (abfd, 0, symbol.refno);
	}
#ifdef UNDERSCORE_HACK
      if (src[l] == '_')
	dst[l++] = '.';
#endif
      while (src[l])
	{
	  dst[l] = src[l];
	  l++;
	}

      H_PUT_32 (abfd, g->value, symbol.value);


      if (g->flags & BSF_LOCAL)
	{
	  if (! oasys_write_record (abfd,
				    oasys_record_is_local_enum,
				    (oasys_record_union_type *) & symbol,
				    offsetof (oasys_symbol_record_type,
					      name[0]) + l))
	    return FALSE;
	}
      else
	{
	  if (! oasys_write_record (abfd,
				    oasys_record_is_symbol_enum,
				    (oasys_record_union_type *) & symbol,
				    offsetof (oasys_symbol_record_type,
					      name[0]) + l))
	    return FALSE;
	}
      g->value = index - 1;
    }

  return TRUE;
}


 /* Write a section header for each section */
static bfd_boolean
oasys_write_sections (abfd)
     bfd *abfd;
{
  asection *s;
  static oasys_section_record_type out;

  for (s = abfd->sections; s != (asection *) NULL; s = s->next)
    {
      if (!ISDIGIT (s->name[0]))
	{
	  (*_bfd_error_handler)
	    (_("%s: can not represent section `%s' in oasys"),
	     bfd_get_filename (abfd), s->name);
	  bfd_set_error (bfd_error_nonrepresentable_section);
	  return FALSE;
	}
      out.relb = RELOCATION_TYPE_REL | s->target_index;
      H_PUT_32 (abfd, s->_cooked_size, out.value);
      H_PUT_32 (abfd, s->vma, out.vma);

      if (! oasys_write_record (abfd,
				oasys_record_is_section_enum,
				(oasys_record_union_type *) & out,
				sizeof (out)))
	return FALSE;
    }
  return TRUE;
}

static bfd_boolean
oasys_write_header (abfd)
     bfd *abfd;
{
  /* Create and write the header */
  oasys_header_record_type r;
  size_t length = strlen (abfd->filename);
  if (length > (size_t) sizeof (r.module_name))
    {
      length = sizeof (r.module_name);
    }

  (void) memcpy (r.module_name,
		 abfd->filename,
		 length);
  (void) memset (r.module_name + length,
		 ' ',
		 sizeof (r.module_name) - length);

  r.version_number = OASYS_VERSION_NUMBER;
  r.rev_number = OASYS_REV_NUMBER;
  if (! oasys_write_record (abfd,
			    oasys_record_is_header_enum,
			    (oasys_record_union_type *) & r,
			    offsetof (oasys_header_record_type,
				      description[0])))
    return FALSE;

  return TRUE;
}

static bfd_boolean
oasys_write_end (abfd)
     bfd *abfd;
{
  oasys_end_record_type end;
  unsigned char null = 0;
  end.relb = RELOCATION_TYPE_ABS;
  H_PUT_32 (abfd, abfd->start_address, end.entry);
  H_PUT_16 (abfd, 0, end.fill);
  end.zero = 0;
  if (! oasys_write_record (abfd,
			    oasys_record_is_end_enum,
			    (oasys_record_union_type *) & end,
			    sizeof (end)))
    return FALSE;
  if (bfd_bwrite ((PTR) &null, (bfd_size_type) 1, abfd) != 1)
    return FALSE;
  return TRUE;
}

static int
comp (ap, bp)
     const PTR ap;
     const PTR bp;
{
  arelent *a = *((arelent **) ap);
  arelent *b = *((arelent **) bp);
  return a->address - b->address;
}

/*
 Writing data..

*/
static bfd_boolean
oasys_write_data (abfd)
     bfd *abfd;
{
  asection *s;
  for (s = abfd->sections; s != (asection *) NULL; s = s->next)
    {
      if (s->flags & SEC_LOAD)
	{
	  bfd_byte *raw_data = oasys_per_section (s)->data;
	  oasys_data_record_type processed_data;
	  bfd_size_type current_byte_index = 0;
	  unsigned int relocs_to_go = s->reloc_count;
	  arelent **p = s->orelocation;
	  if (s->reloc_count != 0)
	    {
/* Sort the reloc records so it's easy to insert the relocs into the
	   data */

	      qsort (s->orelocation,
		     s->reloc_count,
		     sizeof (arelent **),
		     comp);
	    }
	  current_byte_index = 0;
	  processed_data.relb = s->target_index | RELOCATION_TYPE_REL;

	  while (current_byte_index < s->_cooked_size)
	    {
	      /* Scan forwards by eight bytes or however much is left and see if
	       there are any relocations going on */
	      bfd_byte *mod = &processed_data.data[0];
	      bfd_byte *dst = &processed_data.data[1];

	      unsigned int i = 0;
	      *mod = 0;


	      H_PUT_32 (abfd, s->vma + current_byte_index,
			processed_data.addr);

	      /* Don't start a relocation unless you're sure you can finish it
 	       within the same data record.  The worst case relocation is a
 	       4-byte relocatable value which is split across two modification
 	       bytes (1 relocation byte + 2 symbol reference bytes + 2 data +
 	       1 modification byte + 2 data = 8 bytes total).  That's where
 	       the magic number 8 comes from.
 	    */
	      while (current_byte_index < s->_raw_size && dst <=
		     &processed_data.data[sizeof (processed_data.data) - 8])
		{


		  if (relocs_to_go != 0)
		    {
		      arelent *r = *p;
		      reloc_howto_type *const how = r->howto;
		      /* There is a relocation, is it for this byte ? */
		      if (r->address == current_byte_index)
			{
			  unsigned char rel_byte;

			  p++;
			  relocs_to_go--;

			  *mod |= (1 << i);
			  if (how->pc_relative)
			    {
			      rel_byte = RELOCATION_PCREL_BIT;

			      /* Also patch the raw data so that it doesn't have
			 the -ve stuff any more */
			      if (how->size != 2)
				{
				  bfd_put_16 (abfd,
					      bfd_get_16 (abfd, raw_data) +
					      current_byte_index, raw_data);
				}

			      else
				{
				  bfd_put_32 (abfd,
					      bfd_get_32 (abfd, raw_data) +
					      current_byte_index, raw_data);
				}
			    }
			  else
			    {
			      rel_byte = 0;
			    }
			  if (how->size == 2)
			    {
			      rel_byte |= RELOCATION_32BIT_BIT;
			    }

			  /* Is this a section relative relocation, or a symbol
		       relative relocation ? */
			  abort ();

#if 0
			  if (r->section != (asection *) NULL)
			    {
			      /* The relent has a section attached, so it must be section
			     relative */
			      rel_byte |= RELOCATION_TYPE_REL;
			      rel_byte |= r->section->output_section->target_index;
			      *dst++ = rel_byte;
			    }
			  else
#endif
			    {
			      asymbol *sym = *(r->sym_ptr_ptr);

			      /* If this symbol has a section attached, then it
			     has already been resolved.  Change from a symbol
			     ref to a section ref */
			      if (sym->section != (asection *) NULL)
				{
				  rel_byte |= RELOCATION_TYPE_REL;
				  rel_byte |=
				    sym->section->output_section->target_index;
				  *dst++ = rel_byte;
				}
			      else
				{
				  rel_byte |= RELOCATION_TYPE_UND;
				  *dst++ = rel_byte;
				  /* Next two bytes are a symbol index - we can get
			       this from the symbol value which has been zapped
			       into the symbol index in the table when the
			       symbol table was written
			       */
				  *dst++ = sym->value >> 8;
				  *dst++ = sym->value;
				}
			    }
#define ADVANCE { if (++i >= 8) { i = 0; mod = dst++; *mod = 0; } current_byte_index++; }
			  /* relocations never occur from an unloadable section,
		       so we can assume that raw_data is not NULL
		     */
			  *dst++ = *raw_data++;
			  ADVANCE
			    * dst++ = *raw_data++;
			  ADVANCE
			    if (how->size == 2)
			    {
			      *dst++ = *raw_data++;
			      ADVANCE
				* dst++ = *raw_data++;
			      ADVANCE
			    }
			  continue;
			}
		    }
		  /* If this is coming from an unloadable section then copy
		   zeros */
		  if (raw_data == NULL)
		    {
		      *dst++ = 0;
		    }
		  else
		    {
		      *dst++ = *raw_data++;
		    }
		  ADVANCE
		}

	      /* Don't write a useless null modification byte */
	      if (dst == mod + 1)
		{
		  --dst;
		}

	      if (! (oasys_write_record
		     (abfd, oasys_record_is_data_enum,
		      ((oasys_record_union_type *) &processed_data),
		      (size_t) (dst - (bfd_byte *) &processed_data))))
		return FALSE;
	    }
	}
    }

  return TRUE;
}

static bfd_boolean
oasys_write_object_contents (abfd)
     bfd *abfd;
{
  if (! oasys_write_header (abfd))
    return FALSE;
  if (! oasys_write_syms (abfd))
    return FALSE;
  if (! oasys_write_sections (abfd))
    return FALSE;
  if (! oasys_write_data (abfd))
    return FALSE;
  if (! oasys_write_end (abfd))
    return FALSE;
  return TRUE;
}




/** exec and core file sections */

/* set section contents is complicated with OASYS since the format is
* not a byte image, but a record stream.
*/
static bfd_boolean
oasys_set_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     const PTR location;
     file_ptr offset;
     bfd_size_type count;
{
  if (count != 0)
    {
      if (oasys_per_section (section)->data == (bfd_byte *) NULL)
	{
	  oasys_per_section (section)->data =
	    (bfd_byte *) (bfd_alloc (abfd, section->_cooked_size));
	  if (!oasys_per_section (section)->data)
	    return FALSE;
	}
      (void) memcpy ((PTR) (oasys_per_section (section)->data + offset),
		     location,
		     (size_t) count);
    }
  return TRUE;
}



/* Native-level interface to symbols. */

/* We read the symbols into a buffer, which is discarded when this
function exits.  We read the strings into a buffer large enough to
hold them all plus all the cached symbol entries. */

static asymbol *
oasys_make_empty_symbol (abfd)
     bfd *abfd;
{
  bfd_size_type amt = sizeof (oasys_symbol_type);
  oasys_symbol_type *new = (oasys_symbol_type *) bfd_zalloc (abfd, amt);
  if (!new)
    return NULL;
  new->symbol.the_bfd = abfd;
  return &new->symbol;
}




/* User should have checked the file flags; perhaps we should return
BFD_NO_MORE_SYMBOLS if there are none? */

static bfd *
oasys_openr_next_archived_file (arch, prev)
     bfd *arch;
     bfd *prev;
{
  oasys_ar_data_type *ar = OASYS_AR_DATA (arch);
  oasys_module_info_type *p;
  /* take the next one from the arch state, or reset */
  if (prev == (bfd *) NULL)
    {
      /* Reset the index - the first two entries are bogus*/
      ar->module_index = 0;
    }

  p = ar->module + ar->module_index;
  ar->module_index++;

  if (ar->module_index <= ar->module_count)
    {
      if (p->abfd == (bfd *) NULL)
	{
	  p->abfd = _bfd_create_empty_archive_element_shell (arch);
	  p->abfd->origin = p->pos;
	  p->abfd->filename = p->name;

	  /* Fixup a pointer to this element for the member */
	  p->abfd->arelt_data = (PTR) p;
	}
      return p->abfd;
    }
  else
    {
      bfd_set_error (bfd_error_no_more_archived_files);
      return (bfd *) NULL;
    }
}

static bfd_boolean
oasys_find_nearest_line (abfd, section, symbols, offset,
			 filename_ptr, functionname_ptr, line_ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
     asymbol **symbols ATTRIBUTE_UNUSED;
     bfd_vma offset ATTRIBUTE_UNUSED;
     const char **filename_ptr ATTRIBUTE_UNUSED;
     const char **functionname_ptr ATTRIBUTE_UNUSED;
     unsigned int *line_ptr ATTRIBUTE_UNUSED;
{
  return FALSE;

}

static int
oasys_generic_stat_arch_elt (abfd, buf)
     bfd *abfd;
     struct stat *buf;
{
  oasys_module_info_type *mod = (oasys_module_info_type *) abfd->arelt_data;
  if (mod == (oasys_module_info_type *) NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }
  else
    {
      buf->st_size = mod->size;
      buf->st_mode = 0666;
      return 0;
    }
}

static int
oasys_sizeof_headers (abfd, exec)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_boolean exec ATTRIBUTE_UNUSED;
{
  return 0;
}

#define	oasys_close_and_cleanup _bfd_generic_close_and_cleanup
#define oasys_bfd_free_cached_info _bfd_generic_bfd_free_cached_info

#define oasys_slurp_armap bfd_true
#define oasys_slurp_extended_name_table bfd_true
#define oasys_construct_extended_name_table \
  ((bfd_boolean (*) PARAMS ((bfd *, char **, bfd_size_type *, const char **))) \
   bfd_true)
#define oasys_truncate_arname bfd_dont_truncate_arname
#define oasys_write_armap \
  ((bfd_boolean (*) \
    PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int))) \
   bfd_true)
#define oasys_read_ar_hdr bfd_nullvoidptr
#define oasys_get_elt_at_index _bfd_generic_get_elt_at_index
#define oasys_update_armap_timestamp bfd_true

#define oasys_bfd_is_local_label_name bfd_generic_is_local_label_name
#define oasys_get_lineno _bfd_nosymbols_get_lineno
#define oasys_bfd_make_debug_symbol _bfd_nosymbols_bfd_make_debug_symbol
#define oasys_read_minisymbols _bfd_generic_read_minisymbols
#define oasys_minisymbol_to_symbol _bfd_generic_minisymbol_to_symbol

#define oasys_bfd_reloc_type_lookup _bfd_norelocs_bfd_reloc_type_lookup

#define oasys_set_arch_mach bfd_default_set_arch_mach

#define oasys_get_section_contents_in_window \
  _bfd_generic_get_section_contents_in_window

#define oasys_bfd_get_relocated_section_contents \
  bfd_generic_get_relocated_section_contents
#define oasys_bfd_relax_section bfd_generic_relax_section
#define oasys_bfd_gc_sections bfd_generic_gc_sections
#define oasys_bfd_merge_sections bfd_generic_merge_sections
#define oasys_bfd_discard_group bfd_generic_discard_group
#define oasys_bfd_link_hash_table_create _bfd_generic_link_hash_table_create
#define oasys_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
#define oasys_bfd_link_add_symbols _bfd_generic_link_add_symbols
#define oasys_bfd_link_just_syms _bfd_generic_link_just_syms
#define oasys_bfd_final_link _bfd_generic_final_link
#define oasys_bfd_link_split_section _bfd_generic_link_split_section

/*SUPPRESS 460 */
const bfd_target oasys_vec =
{
  "oasys",			/* name */
  bfd_target_oasys_flavour,
  BFD_ENDIAN_BIG,		/* target byte order */
  BFD_ENDIAN_BIG,		/* target headers byte order */
  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
  (SEC_CODE | SEC_DATA | SEC_ROM | SEC_HAS_CONTENTS
   | SEC_ALLOC | SEC_LOAD | SEC_RELOC),	/* section flags */
  0,				/* leading underscore */
  ' ',				/* ar_pad_char */
  16,				/* ar_max_namelen */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */

  {_bfd_dummy_target,
   oasys_object_p,		/* bfd_check_format */
   oasys_archive_p,
   _bfd_dummy_target,
  },
  {				/* bfd_set_format */
    bfd_false,
    oasys_mkobject,
    _bfd_generic_mkarchive,
    bfd_false
  },
  {				/* bfd_write_contents */
    bfd_false,
    oasys_write_object_contents,
    _bfd_write_archive_contents,
    bfd_false,
  },

  BFD_JUMP_TABLE_GENERIC (oasys),
  BFD_JUMP_TABLE_COPY (_bfd_generic),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (oasys),
  BFD_JUMP_TABLE_SYMBOLS (oasys),
  BFD_JUMP_TABLE_RELOCS (oasys),
  BFD_JUMP_TABLE_WRITE (oasys),
  BFD_JUMP_TABLE_LINK (oasys),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  NULL,

  (PTR) 0
};
@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d73 1
a73 1
  PARAMS ((bfd *, sec_ptr, void *, file_ptr, bfd_size_type));
d86 1
a86 1
long oasys_get_symtab
d274 1
a274 1
oasys_get_symtab (abfd, location)
d327 1
a327 1
    can do to verify reasnableness is to make sure that the values in
d1349 1
a1349 1
     PTR location;
@


1.4
log
@resolve conflicts.
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999
   Free Software Foundation, Inc.
d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d25 1
a25 1
#include <ctype.h>
d30 60
a89 3
/* XXX - FIXME.  offsetof belongs in the system-specific files in
   ../include/sys. */
/* Define offsetof for those systems which lack it */
d91 1
a91 15
#ifndef offsetof
#define offsetof(type, identifier) (size_t) &(((type *) 0)->identifier)
#endif

static boolean oasys_read_record PARAMS ((bfd *,
					  oasys_record_union_type *));
static boolean oasys_write_sections PARAMS ((bfd *));
static boolean oasys_write_record PARAMS ((bfd *,
					   oasys_record_enum_type,
					   oasys_record_union_type *,
					   size_t));
static boolean oasys_write_syms PARAMS ((bfd *));
static boolean oasys_write_header PARAMS ((bfd *));
static boolean oasys_write_end PARAMS ((bfd *));
static boolean oasys_write_data PARAMS ((bfd *));
d93 1
a93 4
/* Read in all the section data and relocation stuff too */
PROTO (static boolean, oasys_slurp_section_data, (bfd * CONST abfd));

static boolean
d98 11
a108 12
  if (bfd_read ((PTR) record, 1, sizeof (record->header), abfd)
      != sizeof (record->header))
    return false;

  if ((size_t) record->header.length <= (size_t) sizeof (record->header))
    return true;
  if (bfd_read ((PTR) (((char *) record) + sizeof (record->header)),
		1, record->header.length - sizeof (record->header),
		abfd)
      != record->header.length - sizeof (record->header))
    return false;
  return true;
d110 1
d135 1
a135 1
static boolean
d137 1
a137 1
     bfd *CONST abfd;
d141 1
a141 1
  boolean loop = true;
d145 1
a145 1

d149 1
a149 1
      return true;
d152 5
a156 2
  data->symbols =
    (asymbol *) bfd_alloc (abfd, sizeof (asymbol) * abfd->symcount);
d159 1
a159 4
  data->strings = bfd_alloc (abfd, data->symbol_string_length +
			     abfd->symcount);
#else
  data->strings = bfd_alloc (abfd, data->symbol_string_length);
d161 2
d164 1
a164 1
    return false;
d170 1
a170 1
    return false;
d175 1
a175 1
	return false;
d219 1
a219 1
		dest = data->symbols + bfd_h_get_16 (abfd, record.symbol.refno);
d238 1
a238 1
	    dest->value = bfd_h_get_32 (abfd, record.symbol.value);
d255 1
a255 1
	  loop = false;
d258 1
a258 1
  return true;
d263 1
a263 1
     bfd *CONST abfd;
a270 3
/*
*/

d280 1
a280 1
  if (oasys_slurp_symbol_table (abfd) == false)
d305 1
d307 3
a309 3
  if (bfd_seek (abfd, (file_ptr) 0, false) != 0
      || (bfd_read ((PTR) & header_ext, 1, sizeof (header_ext), abfd)
	  != sizeof (header_ext)))
d316 8
a323 8
  header.version = bfd_h_get_32 (abfd, header_ext.version);
  header.mod_count = bfd_h_get_32 (abfd, header_ext.mod_count);
  header.mod_tbl_offset = bfd_h_get_32 (abfd, header_ext.mod_tbl_offset);
  header.sym_tbl_size = bfd_h_get_32 (abfd, header_ext.sym_tbl_size);
  header.sym_count = bfd_h_get_32 (abfd, header_ext.sym_count);
  header.sym_tbl_offset = bfd_h_get_32 (abfd, header_ext.sym_tbl_offset);
  header.xref_count = bfd_h_get_32 (abfd, header_ext.xref_count);
  header.xref_lst_offset = bfd_h_get_32 (abfd, header_ext.xref_lst_offset);
d342 3
a344 2
    oasys_ar_data_type *ar =
    (oasys_ar_data_type *) bfd_alloc (abfd, sizeof (oasys_ar_data_type));
d346 6
a351 4
    oasys_module_info_type *module =
    (oasys_module_info_type *)
    bfd_alloc (abfd, sizeof (oasys_module_info_type) * header.mod_count);
    oasys_module_table_type record;
d371 3
a373 2
	    if (bfd_read ((PTR) & record_ext, 1, sizeof (record_ext), abfd)
		!= sizeof (record_ext))
d376 2
a377 2
	    record.mod_size = bfd_h_get_32 (abfd, record_ext.mod_size);
	    record.file_offset = bfd_h_get_32 (abfd, record_ext.file_offset);
d379 3
a381 3
	    record.dep_count = bfd_h_get_32 (abfd, record_ext.dep_count);
	    record.depee_count = bfd_h_get_32 (abfd, record_ext.depee_count);
	    record.sect_count = bfd_h_get_32 (abfd, record_ext.sect_count);
d383 1
a383 1
	    module[i].name = bfd_alloc (abfd, 33);
d397 3
a399 2
	    if (bfd_read ((PTR) & record_ext, 1, sizeof (record_ext), abfd)
		!= sizeof (record_ext))
d402 2
a403 2
	    record.mod_size = bfd_h_get_32 (abfd, record_ext.mod_size);
	    record.file_offset = bfd_h_get_32 (abfd, record_ext.file_offset);
d405 5
a409 4
	    record.dep_count = bfd_h_get_32 (abfd, record_ext.dep_count);
	    record.depee_count = bfd_h_get_32 (abfd, record_ext.depee_count);
	    record.sect_count = bfd_h_get_32 (abfd, record_ext.sect_count);
	    record.module_name_size = bfd_h_get_32 (abfd, record_ext.mod_name_length);
d411 2
a412 1
	    module[i].name = bfd_alloc (abfd, record.module_name_size + 1);
d415 1
a415 3
	    if (bfd_read ((PTR) module[i].name, 1, record.module_name_size,
			  abfd)
		!= record.module_name_size)
d418 3
a420 5
	    filepos +=
	      sizeof (record_ext) +
	      record.dep_count * 4 +
	      record.module_name_size + 1;

a422 1

a426 1

d431 1
a431 1
static boolean
d435 3
a437 3

  abfd->tdata.oasys_obj_data = (oasys_data_type *) bfd_alloc (abfd, sizeof (oasys_data_type));
  return abfd->tdata.oasys_obj_data ? true : false;
d447 2
a448 2
  boolean loop = true;
  boolean had_usefull = false;
d475 1
a475 1
	  had_usefull = true;
d482 1
a482 1
	  had_usefull = true;
d493 1
a493 1
	    buffer = bfd_alloc (abfd, 3);
d510 2
a511 2
	    s->_raw_size = bfd_h_get_32 (abfd, record.section.value);
	    s->vma = bfd_h_get_32 (abfd, record.section.vma);
d513 1
a513 1
	    had_usefull = true;
d522 1
a522 1
	  if (had_usefull == false)
d524 1
a524 1
	  loop = false;
d569 2
a570 2
oasys_print_symbol (ignore_abfd, afile, symbol, how)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d585 2
a586 2
	CONST char *section_name = symbol->section == (asection *) NULL ?
	(CONST char *) "*abs" : symbol->section->name;
d588 1
a588 1
	bfd_print_symbol_vandf ((PTR) file, symbol);
d604 4
a607 4
  HOWTO (0, 0, 1, 16, false, 0, complain_overflow_bitfield, 0, "abs16", true, 0x0000ffff, 0x0000ffff, false),
  HOWTO (0, 0, 2, 32, false, 0, complain_overflow_bitfield, 0, "abs32", true, 0xffffffff, 0xffffffff, false),
  HOWTO (0, 0, 1, 16, true, 0, complain_overflow_signed, 0, "pcrel16", true, 0x0000ffff, 0x0000ffff, false),
  HOWTO (0, 0, 2, 32, true, 0, complain_overflow_signed, 0, "pcrel32", true, 0xffffffff, 0xffffffff, false)
d611 1
a611 1
static boolean
d613 1
a613 1
     bfd *CONST abfd;
d617 1
a617 2
  boolean loop = true;

a618 1

d620 1
d626 2
a627 2
      if (per->initialized == true)
	return true;
d631 1
a631 1
    return true;
d634 1
a634 1
    return false;
d638 1
a638 1
	return false;
d658 1
a658 1
	    if (per->initialized == false)
d662 5
a666 4
		  return false;
		per->reloc_tail_ptr = (oasys_reloc_type **) & (section->relocation);
		per->had_vma = false;
		per->initialized = true;
d671 2
a672 2
	    dst_offset = bfd_h_get_32 (abfd, record.data.addr);
	    if (per->had_vma == false)
d676 1
a676 1
		per->had_vma = true;
d725 5
a729 4
				  oasys_reloc_type *r =
				  (oasys_reloc_type *)
				  bfd_alloc (abfd,
					     sizeof (oasys_reloc_type));
d731 1
a731 1
				    return false;
d754 7
a760 10
				  /* Fake up the data to look like it's got the -ve pc in it, this makes
				       it much easier to convert into other formats. This is done by
				       hitting the addend.
				       */
				  if (r->relent.howto->pc_relative == true)
				    {
				      r->relent.addend -= dst_ptr - dst_base_ptr;
				    }


d767 5
a771 4
				  oasys_reloc_type *r =
				  (oasys_reloc_type *)
				  bfd_alloc (abfd,
					     sizeof (oasys_reloc_type));
d773 1
a773 1
				    return false;
d795 7
a801 11
				  /* Fake up the data to look like it's got the -ve pc in it, this makes
				       it much easier to convert into other formats. This is done by
				       hitting the addend.
				       */
				  if (r->relent.howto->pc_relative == true)
				    {
				      r->relent.addend -= dst_ptr - dst_base_ptr;
				    }



d819 1
a819 1
	  loop = false;
d823 1
a823 1
  return true;
d827 1
a827 1
static boolean
d833 1
a833 1
    bfd_alloc (abfd, sizeof (oasys_per_section_type));
d835 1
a835 1
    return false;
d839 1
a839 1
  oasys_per_section (newsect)->initialized = false;
d845 1
a845 1
  return true;
d859 1
a859 1
static boolean
d867 1
a867 1
  oasys_per_section_type *p = (oasys_per_section_type *) section->used_by_bfd;
d869 1
a869 1
  if (p->initialized == false)
d871 1
a871 1
      (void) memset (location, 0, (int) count);
d875 1
a875 1
      (void) memcpy (location, (PTR) (p->data + offset), (int) count);
d877 1
a877 1
  return true;
d916 1
a916 1
static boolean
d938 3
a940 3
  if (bfd_write ((PTR) record, 1, size, abfd) != size)
    return false;
  return true;
d945 1
a945 1
static boolean
d956 1
a956 1
      asymbol *CONST g = generic[count];
d958 1
a958 1
      CONST char *src = g->name;
d965 1
a965 1
	  bfd_h_put_16 (abfd, index, symbol.refno);
d971 1
a971 1
	  bfd_h_put_16 (abfd, 0, symbol.refno);
d977 1
a977 1
	  bfd_h_put_16 (abfd, index, symbol.refno);
d999 1
a999 1
	  bfd_h_put_16 (abfd, 0, symbol.refno);
d1011 1
a1011 1
      bfd_h_put_32 (abfd, g->value, symbol.value);
d1021 1
a1021 1
	    return false;
d1030 1
a1030 1
	    return false;
d1035 1
a1035 1
  return true;
d1040 1
a1040 1
static boolean
d1049 1
a1049 1
      if (!isdigit ((unsigned char) s->name[0]))
d1055 1
a1055 1
	  return false;
d1058 2
a1059 2
      bfd_h_put_32 (abfd, s->_cooked_size, out.value);
      bfd_h_put_32 (abfd, s->vma, out.vma);
d1065 1
a1065 1
	return false;
d1067 1
a1067 1
  return true;
d1070 1
a1070 1
static boolean
d1096 1
a1096 1
    return false;
d1098 1
a1098 1
  return true;
d1101 1
a1101 1
static boolean
d1108 2
a1109 2
  bfd_h_put_32 (abfd, abfd->start_address, end.entry);
  bfd_h_put_16 (abfd, 0, end.fill);
d1115 4
a1118 4
    return false;
  if (bfd_write ((PTR) & null, 1, 1, abfd) != 1)
    return false;
  return true;
d1123 2
a1124 2
     CONST PTR ap;
     CONST PTR bp;
d1135 1
a1135 1
static boolean
d1173 2
a1174 2
	      bfd_h_put_32 (abfd, s->vma + current_byte_index,
			    processed_data.addr);
d1246 1
a1246 1
			      asymbol *p = *(r->sym_ptr_ptr);
d1251 1
a1251 1
			      if (p->section != (asection *) NULL)
d1255 1
a1255 1
				    p->section->output_section->target_index;
d1267 2
a1268 2
				  *dst++ = p->value >> 8;
				  *dst++ = p->value;
d1308 5
a1312 6
	      if (! oasys_write_record (abfd,
					oasys_record_is_data_enum,
					((oasys_record_union_type *)
					 & processed_data),
					dst - (bfd_byte *) & processed_data))
		return false;
d1317 1
a1317 1
  return true;
d1320 1
a1320 1
static boolean
d1325 1
a1325 1
    return false;
d1327 1
a1327 1
    return false;
d1329 1
a1329 1
    return false;
d1331 1
a1331 1
    return false;
d1333 2
a1334 2
    return false;
  return true;
d1345 1
a1345 1
static boolean
d1360 1
a1360 1
	    return false;
d1366 1
a1366 1
  return true;
d1381 2
a1382 3

  oasys_symbol_type *new =
  (oasys_symbol_type *) bfd_zalloc (abfd, sizeof (oasys_symbol_type));
d1432 3
a1434 8
static boolean
oasys_find_nearest_line (abfd,
			 section,
			 symbols,
			 offset,
			 filename_ptr,
			 functionname_ptr,
			 line_ptr)
d1439 2
a1440 2
     char **filename_ptr ATTRIBUTE_UNUSED;
     char **functionname_ptr ATTRIBUTE_UNUSED;
d1443 1
a1443 1
  return false;
d1469 1
a1469 1
     boolean exec ATTRIBUTE_UNUSED;
d1480 1
a1480 1
  ((boolean (*) PARAMS ((bfd *, char **, bfd_size_type *, const char **))) \
d1484 1
a1484 1
  ((boolean (*) \
d1508 2
d1511 1
d1513 1
d1568 1
a1568 1
  
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d518 1
a518 1
     bfd *ignore_abfd;
d529 1
a529 1
     bfd *ignore_abfd;
d847 1
a847 1
     bfd *ignore_abfd;
d850 1
a850 1
     asymbol **symbols;
d1013 1
a1013 1
      if (!isdigit (s->name[0]))
d1016 1
a1016 1
	    ("%s: can not represent section `%s' in oasys",
d1406 7
a1412 7
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     char **filename_ptr;
     char **functionname_ptr;
     unsigned int *line_ptr;
d1439 2
a1440 2
     bfd *abfd;
     boolean exec;
d1462 1
a1462 1
#define oasys_bfd_is_local_label bfd_generic_is_local_label
d1478 1
d1534 2
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
d121 1
a121 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d310 1
a310 4
      {
	bfd_set_error (bfd_error_no_memory);
	return NULL;
      }
d340 1
a340 4
	      {
		bfd_set_error (bfd_error_no_memory);
		return NULL;
	      }
d366 1
a366 4
	      {
		bfd_set_error (bfd_error_no_memory);
		return NULL;
	      }
d453 1
a453 4
	      {
		bfd_set_error (bfd_error_no_memory);
		goto fail;
	      }
d621 1
a621 4
		  {
		    bfd_set_error (bfd_error_no_memory);
		    return false;
		  }
d688 1
a688 4
				    {
				      bfd_set_error (bfd_error_no_memory);
				      return false;
				    }
d732 1
a732 4
				    {
				      bfd_set_error (bfd_error_no_memory);
				      return false;
				    }
d798 1
a798 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d1324 1
a1324 4
	    {
	      bfd_set_error (bfd_error_no_memory);
	      return false;
	    }
d1349 1
a1349 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d1458 1
d1487 2
a1488 2
  true,				/* target byte order */
  true,				/* target headers byte order */
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d121 4
a124 1
    return false;
d313 4
a316 1
      return NULL;
d346 4
a349 1
	      return NULL;
d375 4
a378 1
	      return NULL;
d465 4
a468 1
	      goto fail;
d636 4
a639 1
		  return false;
d706 4
a709 1
				    return false;
d753 4
a756 1
				    return false;
d822 4
a825 1
    return false;
d1351 4
a1354 1
	    return false;
d1379 4
a1382 1
    return NULL;
a1490 1
#define oasys_get_elt_at_index _bfd_generic_get_elt_at_index
d1519 2
a1520 2
  BFD_ENDIAN_BIG,		/* target byte order */
  BFD_ENDIAN_BIG,		/* target headers byte order */
@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d1461 1
a1461 1
#define oasys_bfd_is_local_label_name bfd_generic_is_local_label_name
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
   Free Software Foundation, Inc.
d517 1
a517 1
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d528 1
a528 1
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d846 1
a846 1
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d849 1
a849 1
     asymbol **symbols ATTRIBUTE_UNUSED;
d1012 1
a1012 1
      if (!isdigit ((unsigned char) s->name[0]))
d1015 1
a1015 1
	    (_("%s: can not represent section `%s' in oasys"),
d1405 7
a1411 7
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
     asymbol **symbols ATTRIBUTE_UNUSED;
     bfd_vma offset ATTRIBUTE_UNUSED;
     char **filename_ptr ATTRIBUTE_UNUSED;
     char **functionname_ptr ATTRIBUTE_UNUSED;
     unsigned int *line_ptr ATTRIBUTE_UNUSED;
d1438 2
a1439 2
     bfd *abfd ATTRIBUTE_UNUSED;
     boolean exec ATTRIBUTE_UNUSED;
a1476 1
#define oasys_bfd_gc_sections bfd_generic_gc_sections
a1531 2
  NULL,
  
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2001,
   2002, 2003 Free Software Foundation, Inc.
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d25 1
a25 1
#include "safe-ctype.h"
d30 3
a32 60
static bfd_boolean oasys_slurp_section_data
  PARAMS ((bfd * const));
static bfd_boolean oasys_read_record
  PARAMS ((bfd *, oasys_record_union_type *));
static bfd_boolean oasys_write_sections
  PARAMS ((bfd *));
static bfd_boolean oasys_write_record
  PARAMS ((bfd *, oasys_record_enum_type, oasys_record_union_type *, size_t));
static bfd_boolean oasys_write_syms
  PARAMS ((bfd *));
static bfd_boolean oasys_write_header
  PARAMS ((bfd *));
static bfd_boolean oasys_write_end
  PARAMS ((bfd *));
static bfd_boolean oasys_write_data
  PARAMS ((bfd *));
static size_t oasys_string_length
  PARAMS ((oasys_record_union_type *));
static bfd_boolean oasys_slurp_symbol_table
  PARAMS ((bfd *const));
static long int oasys_get_symtab_upper_bound
  PARAMS ((bfd *const));
static const bfd_target *oasys_archive_p
  PARAMS ((bfd *));
static bfd_boolean oasys_mkobject
  PARAMS ((bfd *));
static const bfd_target *oasys_object_p
  PARAMS ((bfd *));
static void oasys_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
static void oasys_print_symbol
  PARAMS ((bfd *, void *, asymbol *, bfd_print_symbol_type));
static bfd_boolean oasys_new_section_hook
  PARAMS ((bfd *, asection *));
static long int oasys_get_reloc_upper_bound
  PARAMS ((bfd *, sec_ptr));
static bfd_boolean oasys_get_section_contents
  PARAMS ((bfd *, sec_ptr, void *, file_ptr, bfd_size_type));
static int comp
  PARAMS ((const void *, const void *));
static bfd_boolean oasys_write_object_contents
  PARAMS ((bfd *));
static bfd_boolean oasys_set_section_contents
  PARAMS ((bfd *, sec_ptr, void *, file_ptr, bfd_size_type));
static asymbol *oasys_make_empty_symbol
  PARAMS ((bfd *));
static bfd *oasys_openr_next_archived_file
  PARAMS ((bfd *, bfd *));
static bfd_boolean oasys_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma,
	   const char **, const char **, unsigned int *));
static int oasys_generic_stat_arch_elt
  PARAMS ((bfd *, struct stat *));
static int oasys_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));

long oasys_get_symtab
  PARAMS ((bfd *, asymbol **));
long oasys_canonicalize_reloc
  PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));
d34 15
a48 1
/* Read in all the section data and relocation stuff too.  */
d50 4
a53 1
static bfd_boolean
d58 12
a69 11
  bfd_size_type amt = sizeof (record->header);
  if (bfd_bread ((PTR) record, amt, abfd) != amt)
    return FALSE;

  amt = record->header.length - sizeof (record->header);
  if ((long) amt <= 0)
    return TRUE;
  if (bfd_bread ((PTR) ((char *) record + sizeof (record->header)), amt, abfd)
      != amt)
    return FALSE;
  return TRUE;
a70 1

d95 1
a95 1
static bfd_boolean
d97 1
a97 1
     bfd *const abfd;
d101 1
a101 1
  bfd_boolean loop = TRUE;
d105 1
a105 1
  bfd_size_type amt;
d109 1
a109 1
      return TRUE;
d112 2
a113 5
  amt = abfd->symcount;
  amt *= sizeof (asymbol);
  data->symbols = (asymbol *) bfd_alloc (abfd, amt);

  amt = data->symbol_string_length;
d116 4
a119 1
  amt += abfd->symcount;
a120 2
  data->strings = bfd_alloc (abfd, amt);

d122 1
a122 1
    return FALSE;
d128 1
a128 1
    return FALSE;
d133 1
a133 1
	return FALSE;
d177 1
a177 1
		dest = data->symbols + H_GET_16 (abfd, record.symbol.refno);
d196 1
a196 1
	    dest->value = H_GET_32 (abfd, record.symbol.value);
d213 1
a213 1
	  loop = FALSE;
d216 1
a216 1
  return TRUE;
d221 1
a221 1
     bfd *const abfd;
d229 3
d241 1
a241 1
  if (! oasys_slurp_symbol_table (abfd))
a265 1
  bfd_size_type amt;
d267 3
a269 3
  amt = sizeof (header_ext);
  if (bfd_seek (abfd, (file_ptr) 0, 0) != 0
      || bfd_bread ((PTR) &header_ext, amt, abfd) != amt)
d276 8
a283 8
  header.version = H_GET_32 (abfd, header_ext.version);
  header.mod_count = H_GET_32 (abfd, header_ext.mod_count);
  header.mod_tbl_offset = H_GET_32 (abfd, header_ext.mod_tbl_offset);
  header.sym_tbl_size = H_GET_32 (abfd, header_ext.sym_tbl_size);
  header.sym_count = H_GET_32 (abfd, header_ext.sym_count);
  header.sym_tbl_offset = H_GET_32 (abfd, header_ext.sym_tbl_offset);
  header.xref_count = H_GET_32 (abfd, header_ext.xref_count);
  header.xref_lst_offset = H_GET_32 (abfd, header_ext.xref_lst_offset);
d302 6
a307 2
    oasys_ar_data_type *ar;
    oasys_module_info_type *module;
a309 7
    amt = sizeof (oasys_ar_data_type);
    ar = (oasys_ar_data_type *) bfd_alloc (abfd, amt);

    amt = header.mod_count;
    amt *= sizeof (oasys_module_info_type);
    module = (oasys_module_info_type *) bfd_alloc (abfd, amt);

d328 2
a329 3

	    amt = sizeof (record_ext);
	    if (bfd_bread ((PTR) &record_ext, amt, abfd) != amt)
d332 2
a333 2
	    record.mod_size = H_GET_32 (abfd, record_ext.mod_size);
	    record.file_offset = H_GET_32 (abfd, record_ext.file_offset);
d335 3
a337 3
	    record.dep_count = H_GET_32 (abfd, record_ext.dep_count);
	    record.depee_count = H_GET_32 (abfd, record_ext.depee_count);
	    record.sect_count = H_GET_32 (abfd, record_ext.sect_count);
d339 1
a339 1
	    module[i].name = bfd_alloc (abfd, (bfd_size_type) 33);
d353 2
a354 3

	    amt = sizeof (record_ext);
	    if (bfd_bread ((PTR) &record_ext, amt, abfd) != amt)
d357 2
a358 2
	    record.mod_size = H_GET_32 (abfd, record_ext.mod_size);
	    record.file_offset = H_GET_32 (abfd, record_ext.file_offset);
d360 4
a363 5
	    record.dep_count = H_GET_32 (abfd, record_ext.dep_count);
	    record.depee_count = H_GET_32 (abfd, record_ext.depee_count);
	    record.sect_count = H_GET_32 (abfd, record_ext.sect_count);
	    record.module_name_size = H_GET_32 (abfd,
						record_ext.mod_name_length);
d365 1
a365 2
	    amt = record.module_name_size;
	    module[i].name = bfd_alloc (abfd, amt + 1);
d368 3
a370 1
	    if (bfd_bread ((PTR) module[i].name, amt, abfd) != amt)
d373 5
a377 3
	    filepos += (sizeof (record_ext)
			+ record.dep_count * 4
			+ record.module_name_size + 1);
d380 1
d385 1
d390 1
a390 1
static bfd_boolean
d394 3
a396 3
  bfd_size_type amt = sizeof (oasys_data_type);
  abfd->tdata.oasys_obj_data = (oasys_data_type *) bfd_alloc (abfd, amt);
  return abfd->tdata.oasys_obj_data != NULL;
d406 2
a407 2
  bfd_boolean loop = TRUE;
  bfd_boolean had_usefull = FALSE;
d434 1
a434 1
	  had_usefull = TRUE;
d441 1
a441 1
	  had_usefull = TRUE;
d452 1
a452 1
	    buffer = bfd_alloc (abfd, (bfd_size_type) 3);
d469 2
a470 2
	    s->_raw_size = H_GET_32 (abfd, record.section.value);
	    s->vma = H_GET_32 (abfd, record.section.vma);
d472 1
a472 1
	    had_usefull = TRUE;
d481 1
a481 1
	  if (! had_usefull)
d483 1
a483 1
	  loop = FALSE;
d528 2
a529 2
oasys_print_symbol (abfd, afile, symbol, how)
     bfd *abfd;
d544 2
a545 2
	const char *section_name = symbol->section == (asection *) NULL ?
	(const char *) "*abs" : symbol->section->name;
d547 1
a547 1
	bfd_print_symbol_vandf (abfd, (PTR) file, symbol);
d563 4
a566 4
  HOWTO (0, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, 0, "abs16", TRUE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (0, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, 0, "abs32", TRUE, 0xffffffff, 0xffffffff, FALSE),
  HOWTO (0, 0, 1, 16, TRUE, 0, complain_overflow_signed, 0, "pcrel16", TRUE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (0, 0, 2, 32, TRUE, 0, complain_overflow_signed, 0, "pcrel32", TRUE, 0xffffffff, 0xffffffff, FALSE)
d570 1
a570 1
static bfd_boolean
d572 1
a572 1
     bfd *const abfd;
d576 2
a577 1
  bfd_boolean loop = TRUE;
d579 1
a580 1
  bfd_size_type amt;
d586 2
a587 2
      if (per->initialized)
	return TRUE;
d591 1
a591 1
    return TRUE;
d594 1
a594 1
    return FALSE;
d598 1
a598 1
	return FALSE;
d618 1
a618 1
	    if (! per->initialized)
d622 4
a625 5
		  return FALSE;
		per->reloc_tail_ptr
		  = (oasys_reloc_type **) &section->relocation;
		per->had_vma = FALSE;
		per->initialized = TRUE;
d630 2
a631 2
	    dst_offset = H_GET_32 (abfd, record.data.addr);
	    if (! per->had_vma)
d635 1
a635 1
		per->had_vma = TRUE;
d684 4
a687 5
				  oasys_reloc_type *r;

				  amt = sizeof (oasys_reloc_type);
				  r = (oasys_reloc_type *) bfd_alloc (abfd,
								      amt);
d689 1
a689 1
				    return FALSE;
d712 10
a721 7
				  /* Fake up the data to look like
				     it's got the -ve pc in it, this
				     makes it much easier to convert
				     into other formats.  This is done
				     by hitting the addend.  */
				  if (r->relent.howto->pc_relative)
				    r->relent.addend -= dst_ptr - dst_base_ptr;
d728 4
a731 5
				  oasys_reloc_type *r;

				  amt = sizeof (oasys_reloc_type);
				  r = (oasys_reloc_type *) bfd_alloc (abfd,
								      amt);
d733 1
a733 1
				    return FALSE;
d755 11
a765 7
				  /* Fake up the data to look like
				     it's got the -ve pc in it, this
				     makes it much easier to convert
				     into other formats.  This is done
				     by hitting the addend.  */
				  if (r->relent.howto->pc_relative)
				    r->relent.addend -= dst_ptr - dst_base_ptr;
d783 1
a783 1
	  loop = FALSE;
d787 1
a787 1
  return TRUE;
d791 1
a791 1
static bfd_boolean
d797 1
a797 1
    bfd_alloc (abfd, (bfd_size_type) sizeof (oasys_per_section_type));
d799 1
a799 1
    return FALSE;
d803 1
a803 1
  oasys_per_section (newsect)->initialized = FALSE;
d809 1
a809 1
  return TRUE;
d823 1
a823 1
static bfd_boolean
d831 1
a831 1
  oasys_per_section_type *p = oasys_per_section (section);
d833 1
a833 1
  if (! p->initialized)
d835 1
a835 1
      (void) memset (location, 0, (size_t) count);
d839 1
a839 1
      (void) memcpy (location, (PTR) (p->data + offset), (size_t) count);
d841 1
a841 1
  return TRUE;
d880 1
a880 1
static bfd_boolean
d902 3
a904 3
  if (bfd_bwrite ((PTR) record, (bfd_size_type) size, abfd) != size)
    return FALSE;
  return TRUE;
d909 1
a909 1
static bfd_boolean
d920 1
a920 1
      asymbol *const g = generic[count];
d922 1
a922 1
      const char *src = g->name;
d929 1
a929 1
	  H_PUT_16 (abfd, index, symbol.refno);
d935 1
a935 1
	  H_PUT_16 (abfd, 0, symbol.refno);
d941 1
a941 1
	  H_PUT_16 (abfd, index, symbol.refno);
d963 1
a963 1
	  H_PUT_16 (abfd, 0, symbol.refno);
d975 1
a975 1
      H_PUT_32 (abfd, g->value, symbol.value);
d985 1
a985 1
	    return FALSE;
d994 1
a994 1
	    return FALSE;
d999 1
a999 1
  return TRUE;
d1004 1
a1004 1
static bfd_boolean
d1013 1
a1013 1
      if (!ISDIGIT (s->name[0]))
d1019 1
a1019 1
	  return FALSE;
d1022 2
a1023 2
      H_PUT_32 (abfd, s->_cooked_size, out.value);
      H_PUT_32 (abfd, s->vma, out.vma);
d1029 1
a1029 1
	return FALSE;
d1031 1
a1031 1
  return TRUE;
d1034 1
a1034 1
static bfd_boolean
d1060 1
a1060 1
    return FALSE;
d1062 1
a1062 1
  return TRUE;
d1065 1
a1065 1
static bfd_boolean
d1072 2
a1073 2
  H_PUT_32 (abfd, abfd->start_address, end.entry);
  H_PUT_16 (abfd, 0, end.fill);
d1079 4
a1082 4
    return FALSE;
  if (bfd_bwrite ((PTR) &null, (bfd_size_type) 1, abfd) != 1)
    return FALSE;
  return TRUE;
d1087 2
a1088 2
     const PTR ap;
     const PTR bp;
d1099 1
a1099 1
static bfd_boolean
d1137 2
a1138 2
	      H_PUT_32 (abfd, s->vma + current_byte_index,
			processed_data.addr);
d1210 1
a1210 1
			      asymbol *sym = *(r->sym_ptr_ptr);
d1215 1
a1215 1
			      if (sym->section != (asection *) NULL)
d1219 1
a1219 1
				    sym->section->output_section->target_index;
d1231 2
a1232 2
				  *dst++ = sym->value >> 8;
				  *dst++ = sym->value;
d1272 6
a1277 5
	      if (! (oasys_write_record
		     (abfd, oasys_record_is_data_enum,
		      ((oasys_record_union_type *) &processed_data),
		      (size_t) (dst - (bfd_byte *) &processed_data))))
		return FALSE;
d1282 1
a1282 1
  return TRUE;
d1285 1
a1285 1
static bfd_boolean
d1290 1
a1290 1
    return FALSE;
d1292 1
a1292 1
    return FALSE;
d1294 1
a1294 1
    return FALSE;
d1296 1
a1296 1
    return FALSE;
d1298 2
a1299 2
    return FALSE;
  return TRUE;
d1310 1
a1310 1
static bfd_boolean
d1325 1
a1325 1
	    return FALSE;
d1331 1
a1331 1
  return TRUE;
d1346 3
a1348 2
  bfd_size_type amt = sizeof (oasys_symbol_type);
  oasys_symbol_type *new = (oasys_symbol_type *) bfd_zalloc (abfd, amt);
d1398 8
a1405 3
static bfd_boolean
oasys_find_nearest_line (abfd, section, symbols, offset,
			 filename_ptr, functionname_ptr, line_ptr)
d1410 2
a1411 2
     const char **filename_ptr ATTRIBUTE_UNUSED;
     const char **functionname_ptr ATTRIBUTE_UNUSED;
d1414 1
a1414 1
  return FALSE;
d1440 1
a1440 1
     bfd_boolean exec ATTRIBUTE_UNUSED;
d1451 1
a1451 1
  ((bfd_boolean (*) PARAMS ((bfd *, char **, bfd_size_type *, const char **))) \
d1455 1
a1455 1
  ((bfd_boolean (*) \
a1478 2
#define oasys_bfd_merge_sections bfd_generic_merge_sections
#define oasys_bfd_discard_group bfd_generic_discard_group
a1479 1
#define oasys_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
a1480 1
#define oasys_bfd_link_just_syms _bfd_generic_link_just_syms
d1535 1
a1535 1

@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d73 1
a73 1
  PARAMS ((bfd *, sec_ptr, const void *, file_ptr, bfd_size_type));
d86 1
a86 1
long oasys_canonicalize_symtab
d274 1
a274 1
oasys_canonicalize_symtab (abfd, location)
d327 1
a327 1
    can do to verify reasonableness is to make sure that the values in
d1349 1
a1349 1
     const PTR location;
@


