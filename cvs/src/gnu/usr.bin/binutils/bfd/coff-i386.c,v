head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.50
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.52
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.48
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.44
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.46
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.38
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.42
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.40
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.11.02.20.45.04;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.17.21.54.20;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.29;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.07;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.43.30;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.30;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.30;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.05.00;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.18.02;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.45.26;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.20.51;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.11;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.22.14;	author miod;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD back-end for Intel 386 COFF files.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Written by Cygnus Support.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"

#include "coff/i386.h"

#include "coff/internal.h"

#ifdef COFF_WITH_PE
#include "coff/pe.h"
#endif

#ifdef COFF_GO32_EXE
#include "coff/go32exe.h"
#endif

#include "libcoff.h"

static bfd_reloc_status_type coff_i386_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static reloc_howto_type *coff_i386_rtype_to_howto
  PARAMS ((bfd *, asection *, struct internal_reloc *,
	   struct coff_link_hash_entry *, struct internal_syment *,
	   bfd_vma *));
static reloc_howto_type *coff_i386_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));

#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (2)
/* The page size is a guess based on ELF.  */

#define COFF_PAGE_SIZE 0x1000

/* For some reason when using i386 COFF the value stored in the .text
   section for a reference to a common symbol is the value itself plus
   any desired offset.  Ian Taylor, Cygnus Support.  */

/* If we are producing relocatable output, we need to do some
   adjustments to the object file that are not done by the
   bfd_perform_relocation function.  This function is called by every
   reloc type to make any required adjustments.  */

static bfd_reloc_status_type
coff_i386_reloc (abfd, reloc_entry, symbol, data, input_section, output_bfd,
		 error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  symvalue diff;

#ifndef COFF_WITH_PE
  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;
#endif

  if (bfd_is_com_section (symbol->section))
    {
#ifndef COFF_WITH_PE
      /* We are relocating a common symbol.  The current value in the
	 object file is ORIG + OFFSET, where ORIG is the value of the
	 common symbol as seen by the object file when it was compiled
	 (this may be zero if the symbol was undefined) and OFFSET is
	 the offset into the common symbol (normally zero, but may be
	 non-zero when referring to a field in a common structure).
	 ORIG is the negative of reloc_entry->addend, which is set by
	 the CALC_ADDEND macro below.  We want to replace the value in
	 the object file with NEW + OFFSET, where NEW is the value of
	 the common symbol which we are going to put in the final
	 object file.  NEW is symbol->value.  */
      diff = symbol->value + reloc_entry->addend;
#else
      /* In PE mode, we do not offset the common symbol.  */
      diff = reloc_entry->addend;
#endif
    }
  else
    {
      /* For some reason bfd_perform_relocation always effectively
	 ignores the addend for a COFF target when producing
	 relocatable output.  This seems to be always wrong for 386
	 COFF, so we handle the addend here instead.  */
#ifdef COFF_WITH_PE
      if (output_bfd == (bfd *) NULL)
	{
	  reloc_howto_type *howto = reloc_entry->howto;

	  /* Although PC relative relocations are very similar between
	     PE and non-PE formats, but they are off by 1 << howto->size
	     bytes. For the external relocation, PE is very different
	     from others. See md_apply_fix3 () in gas/config/tc-i386.c.
	     When we link PE and non-PE object files together to
	     generate a non-PE executable, we have to compensate it
	     here.  */
	  if (howto->pc_relative && howto->pcrel_offset)
	    diff = -(1 << howto->size);
	  else
	    diff = -reloc_entry->addend;
	}
      else
#endif
	diff = reloc_entry->addend;
    }

#ifdef COFF_WITH_PE
  /* FIXME: How should this case be handled?  */
  if (reloc_entry->howto->type == R_IMAGEBASE
      && output_bfd != NULL
      && bfd_get_flavour(output_bfd) == bfd_target_coff_flavour)
    diff -= pe_data (output_bfd)->pe_opthdr.ImageBase;
#endif

#define DOIT(x) \
  x = ((x & ~howto->dst_mask) | (((x & howto->src_mask) + diff) & howto->dst_mask))

    if (diff != 0)
      {
	reloc_howto_type *howto = reloc_entry->howto;
	unsigned char *addr = (unsigned char *) data + reloc_entry->address;

	switch (howto->size)
	  {
	  case 0:
	    {
	      char x = bfd_get_8 (abfd, addr);
	      DOIT (x);
	      bfd_put_8 (abfd, x, addr);
	    }
	    break;

	  case 1:
	    {
	      short x = bfd_get_16 (abfd, addr);
	      DOIT (x);
	      bfd_put_16 (abfd, (bfd_vma) x, addr);
	    }
	    break;

	  case 2:
	    {
	      long x = bfd_get_32 (abfd, addr);
	      DOIT (x);
	      bfd_put_32 (abfd, (bfd_vma) x, addr);
	    }
	    break;

	  default:
	    abort ();
	  }
      }

  /* Now let bfd_perform_relocation finish everything up.  */
  return bfd_reloc_continue;
}

#ifdef COFF_WITH_PE
/* Return TRUE if this relocation should appear in the output .reloc
   section.  */

static bfd_boolean in_reloc_p PARAMS ((bfd *, reloc_howto_type *));

static bfd_boolean in_reloc_p (abfd, howto)
     bfd * abfd ATTRIBUTE_UNUSED;
     reloc_howto_type *howto;
{
  return ! howto->pc_relative && howto->type != R_IMAGEBASE;
}
#endif /* COFF_WITH_PE */

#ifndef PCRELOFFSET
#define PCRELOFFSET FALSE
#endif

static reloc_howto_type howto_table[] =
{
  EMPTY_HOWTO (0),
  EMPTY_HOWTO (1),
  EMPTY_HOWTO (2),
  EMPTY_HOWTO (3),
  EMPTY_HOWTO (4),
  EMPTY_HOWTO (5),
  HOWTO (R_DIR32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 coff_i386_reloc,	/* special_function */
	 "dir32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
  /* PE IMAGE_REL_I386_DIR32NB relocation (7).	*/
  HOWTO (R_IMAGEBASE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 coff_i386_reloc,	/* special_function */
	 "rva32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  EMPTY_HOWTO (010),
  EMPTY_HOWTO (011),
  EMPTY_HOWTO (012),
  EMPTY_HOWTO (013),
  EMPTY_HOWTO (014),
  EMPTY_HOWTO (015),
  EMPTY_HOWTO (016),
  /* Byte relocation (017).  */
  HOWTO (R_RELBYTE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 coff_i386_reloc,	/* special_function */
	 "8",			/* name */
	 TRUE,			/* partial_inplace */
	 0x000000ff,		/* src_mask */
	 0x000000ff,		/* dst_mask */
	 PCRELOFFSET),		/* pcrel_offset */
  /* 16-bit word relocation (020).  */
  HOWTO (R_RELWORD,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 coff_i386_reloc,	/* special_function */
	 "16",			/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 PCRELOFFSET),		/* pcrel_offset */
  /* 32-bit longword relocation (021).	*/
  HOWTO (R_RELLONG,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 coff_i386_reloc,	/* special_function */
	 "32",			/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 PCRELOFFSET),		/* pcrel_offset */
  /* Byte PC relative relocation (022).	 */
  HOWTO (R_PCRBYTE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 coff_i386_reloc,	/* special_function */
	 "DISP8",		/* name */
	 TRUE,			/* partial_inplace */
	 0x000000ff,		/* src_mask */
	 0x000000ff,		/* dst_mask */
	 PCRELOFFSET),		/* pcrel_offset */
  /* 16-bit word PC relative relocation (023).	*/
  HOWTO (R_PCRWORD,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 coff_i386_reloc,	/* special_function */
	 "DISP16",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 PCRELOFFSET),		/* pcrel_offset */
  /* 32-bit longword PC relative relocation (024).  */
  HOWTO (R_PCRLONG,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 coff_i386_reloc,	/* special_function */
	 "DISP32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 PCRELOFFSET)		/* pcrel_offset */
};

/* Turn a howto into a reloc  nunmber */

#define SELECT_RELOC(x,howto) { x.r_type = howto->type; }
#define BADMAG(x) I386BADMAG(x)
#define I386 1			/* Customize coffcode.h */

#define RTYPE2HOWTO(cache_ptr, dst)					\
  ((cache_ptr)->howto =							\
   ((dst)->r_type < sizeof (howto_table) / sizeof (howto_table[0])	\
    ? howto_table + (dst)->r_type					\
    : NULL))

/* For 386 COFF a STYP_NOLOAD | STYP_BSS section is part of a shared
   library.  On some other COFF targets STYP_BSS is normally
   STYP_NOLOAD.  */
#define BSS_NOLOAD_IS_SHARED_LIBRARY

/* Compute the addend of a reloc.  If the reloc is to a common symbol,
   the object file contains the value of the common symbol.  By the
   time this is called, the linker may be using a different symbol
   from a different object file with a different value.  Therefore, we
   hack wildly to locate the original symbol from this file so that we
   can make the correct adjustment.  This macro sets coffsym to the
   symbol from the original file, and uses it to set the addend value
   correctly.  If this is not a common symbol, the usual addend
   calculation is done, except that an additional tweak is needed for
   PC relative relocs.
   FIXME: This macro refers to symbols and asect; these are from the
   calling function, not the macro arguments.  */

#define CALC_ADDEND(abfd, ptr, reloc, cache_ptr)		\
  {								\
    coff_symbol_type *coffsym = (coff_symbol_type *) NULL;	\
    if (ptr && bfd_asymbol_bfd (ptr) != abfd)			\
      coffsym = (obj_symbols (abfd)				\
	         + (cache_ptr->sym_ptr_ptr - symbols));		\
    else if (ptr)						\
      coffsym = coff_symbol_from (abfd, ptr);			\
    if (coffsym != (coff_symbol_type *) NULL			\
	&& coffsym->native->u.syment.n_scnum == 0)		\
      cache_ptr->addend = - coffsym->native->u.syment.n_value;	\
    else if (ptr && bfd_asymbol_bfd (ptr) == abfd		\
	     && ptr->section != (asection *) NULL)		\
      cache_ptr->addend = - (ptr->section->vma + ptr->value);	\
    else							\
      cache_ptr->addend = 0;					\
    if (ptr && howto_table[reloc.r_type].pc_relative)		\
      cache_ptr->addend += asect->vma;				\
  }

/* We use the special COFF backend linker.  For normal i386 COFF, we
   can use the generic relocate_section routine.  For PE, we need our
   own routine.  */

#ifndef COFF_WITH_PE

#define coff_relocate_section _bfd_coff_generic_relocate_section

#else /* COFF_WITH_PE */

/* The PE relocate section routine.  The only difference between this
   and the regular routine is that we don't want to do anything for a
   relocatable link.  */

static bfd_boolean coff_pe_i386_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   struct internal_reloc *, struct internal_syment *, asection **));

static bfd_boolean
coff_pe_i386_relocate_section (output_bfd, info, input_bfd,
			       input_section, contents, relocs, syms,
			       sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     struct internal_reloc *relocs;
     struct internal_syment *syms;
     asection **sections;
{
  if (info->relocatable)
    return TRUE;

  return _bfd_coff_generic_relocate_section (output_bfd, info, input_bfd,
					     input_section, contents,
					     relocs, syms, sections);
}

#define coff_relocate_section coff_pe_i386_relocate_section

#endif /* COFF_WITH_PE */

/* Convert an rtype to howto for the COFF backend linker.  */

static reloc_howto_type *
coff_i386_rtype_to_howto (abfd, sec, rel, h, sym, addendp)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     struct internal_reloc *rel;
     struct coff_link_hash_entry *h;
     struct internal_syment *sym;
     bfd_vma *addendp;
{
  reloc_howto_type *howto;

  if (rel->r_type > sizeof (howto_table) / sizeof (howto_table[0]))
    {
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }

  howto = howto_table + rel->r_type;

#ifdef COFF_WITH_PE
  /* Cancel out code in _bfd_coff_generic_relocate_section.  */
  *addendp = 0;
#endif

  if (howto->pc_relative)
    *addendp += sec->vma;

  if (sym != NULL && sym->n_scnum == 0 && sym->n_value != 0)
    {
      /* This is a common symbol.  The section contents include the
	 size (sym->n_value) as an addend.  The relocate_section
	 function will be adding in the final value of the symbol.  We
	 need to subtract out the current size in order to get the
	 correct result.  */

      BFD_ASSERT (h != NULL);

#ifndef COFF_WITH_PE
      /* I think we *do* want to bypass this.  If we don't, I have
	 seen some data parameters get the wrong relocation address.
	 If I link two versions with and without this section bypassed
	 and then do a binary comparison, the addresses which are
	 different can be looked up in the map.  The case in which
	 this section has been bypassed has addresses which correspond
	 to values I can find in the map.  */
      *addendp -= sym->n_value;
#endif
    }

#ifndef COFF_WITH_PE
  /* If the output symbol is common (in which case this must be a
     relocatable link), we need to add in the final size of the
     common symbol.  */
  if (h != NULL && h->root.type == bfd_link_hash_common)
    *addendp += h->root.u.c.size;
#endif

#ifdef COFF_WITH_PE
  if (howto->pc_relative)
    {
      *addendp -= 4;

      /* If the symbol is defined, then the generic code is going to
         add back the symbol value in order to cancel out an
         adjustment it made to the addend.  However, we set the addend
         to 0 at the start of this function.  We need to adjust here,
         to avoid the adjustment the generic code will make.  FIXME:
         This is getting a bit hackish.  */
      if (sym != NULL && sym->n_scnum != 0)
	*addendp -= sym->n_value;
    }

  if (rel->r_type == R_IMAGEBASE
      && (bfd_get_flavour(sec->output_section->owner)
	  == bfd_target_coff_flavour))
    {
      *addendp -= pe_data(sec->output_section->owner)->pe_opthdr.ImageBase;
    }
#endif

  return howto;
}

#define coff_bfd_reloc_type_lookup coff_i386_reloc_type_lookup

static reloc_howto_type *
coff_i386_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
{
  switch (code)
    {
    case BFD_RELOC_RVA:
      return howto_table + R_IMAGEBASE;
    case BFD_RELOC_32:
      return howto_table + R_DIR32;
    case BFD_RELOC_32_PCREL:
      return howto_table + R_PCRLONG;
    case BFD_RELOC_16:
      return howto_table + R_RELWORD;
    case BFD_RELOC_16_PCREL:
      return howto_table + R_PCRWORD;
    case BFD_RELOC_8:
      return howto_table + R_RELBYTE;
    case BFD_RELOC_8_PCREL:
      return howto_table + R_PCRBYTE;
    default:
      BFD_FAIL ();
      return 0;
    }
}

#define coff_rtype_to_howto coff_i386_rtype_to_howto

#ifdef TARGET_UNDERSCORE

/* If i386 gcc uses underscores for symbol names, then it does not use
   a leading dot for local labels, so if TARGET_UNDERSCORE is defined
   we treat all symbols starting with L as local.  */

static bfd_boolean coff_i386_is_local_label_name
  PARAMS ((bfd *, const char *));

static bfd_boolean
coff_i386_is_local_label_name (abfd, name)
     bfd *abfd;
     const char *name;
{
  if (name[0] == 'L')
    return TRUE;

  return _bfd_coff_is_local_label_name (abfd, name);
}

#define coff_bfd_is_local_label_name coff_i386_is_local_label_name

#endif /* TARGET_UNDERSCORE */

#include "coffcode.h"

const bfd_target
#ifdef TARGET_SYM
  TARGET_SYM =
#else
  i386coff_vec =
#endif
{
#ifdef TARGET_NAME
  TARGET_NAME,
#else
  "coff-i386",			/* name */
#endif
  bfd_target_coff_flavour,
  BFD_ENDIAN_LITTLE,		/* data byte order is little */
  BFD_ENDIAN_LITTLE,		/* header byte order is little */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),

  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC /* section flags */
#ifdef COFF_WITH_PE
   | SEC_LINK_ONCE | SEC_LINK_DUPLICATES | SEC_READONLY
#endif
   | SEC_CODE | SEC_DATA),

#ifdef TARGET_UNDERSCORE
  TARGET_UNDERSCORE,		/* leading underscore */
#else
  0,				/* leading underscore */
#endif
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen */

  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */

/* Note that we allow an object file to be treated as a core file as well.  */
    {_bfd_dummy_target, coff_object_p, /* bfd_check_format */
       bfd_generic_archive_p, coff_object_p},
    {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format */
       bfd_false},
    {bfd_false, coff_write_object_contents, /* bfd_write_contents */
       _bfd_write_archive_contents, bfd_false},

     BFD_JUMP_TABLE_GENERIC (coff),
     BFD_JUMP_TABLE_COPY (coff),
     BFD_JUMP_TABLE_CORE (_bfd_nocore),
     BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
     BFD_JUMP_TABLE_SYMBOLS (coff),
     BFD_JUMP_TABLE_RELOCS (coff),
     BFD_JUMP_TABLE_WRITE (coff),
     BFD_JUMP_TABLE_LINK (coff),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  NULL,

  COFF_SWAP_TABLE
};
@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2000, 2001, 2002
d59 1
a59 1
/* If we are producing relocateable output, we need to do some
d106 1
a106 1
	 relocateable output.  This seems to be always wrong for 386
d389 1
a389 1
   relocateable link.  */
d408 1
a408 1
  if (info->relocateable)
d473 1
a473 1
     relocateable link), we need to add in the final size of the
@


1.4
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2000, 2001
d120 1
a120 1
	  if (howto->pc_relative == true && howto->pcrel_offset == true)
d160 1
a160 1
	      bfd_put_16 (abfd, x, addr);
d168 1
a168 1
	      bfd_put_32 (abfd, x, addr);
d182 1
a182 1
/* Return true if this relocation should appear in the output .reloc
d185 1
a185 1
static boolean in_reloc_p PARAMS ((bfd *, reloc_howto_type *));
d187 1
a187 1
static boolean in_reloc_p (abfd, howto)
d196 1
a196 1
#define PCRELOFFSET false
d211 1
a211 1
	 false,			/* pc_relative */
d216 1
a216 1
	 true,			/* partial_inplace */
d219 1
a219 1
	 true),			/* pcrel_offset */
d225 1
a225 1
	 false,			/* pc_relative */
d230 1
a230 1
	 true,			/* partial_inplace */
d233 1
a233 1
	 false),		/* pcrel_offset */
d246 1
a246 1
	 false,			/* pc_relative */
d251 1
a251 1
	 true,			/* partial_inplace */
d260 1
a260 1
	 false,			/* pc_relative */
d265 1
a265 1
	 true,			/* partial_inplace */
d274 1
a274 1
	 false,			/* pc_relative */
d279 1
a279 1
	 true,			/* partial_inplace */
d288 1
a288 1
	 true,			/* pc_relative */
d293 1
a293 1
	 true,			/* partial_inplace */
d302 1
a302 1
	 true,			/* pc_relative */
d307 1
a307 1
	 true,			/* partial_inplace */
d316 1
a316 1
	 true,			/* pc_relative */
d321 1
a321 1
	 true,			/* partial_inplace */
d391 1
a391 1
static boolean coff_pe_i386_relocate_section
d395 1
a395 1
static boolean
d409 1
a409 1
    return true;
d542 2
a543 1
static boolean coff_i386_is_local_label_name PARAMS ((bfd *, const char *));
d545 1
a545 1
static boolean
d551 1
a551 1
    return true;
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d77 1
d80 1
d108 20
a127 1
      diff = reloc_entry->addend;
d132 3
a134 1
  if (reloc_entry->howto->type == R_IMAGEBASE)
a181 1

d188 1
a188 1
     bfd *abfd ATTRIBUTE_UNUSED;
a192 1

d494 3
a496 1
  if (rel->r_type == R_IMAGEBASE)
d583 1
a583 1
   | SEC_LINK_ONCE | SEC_LINK_DUPLICATES
d602 1
a602 1
/* Note that we allow an object file to be treated as a core file as well. */
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
a24 1
#include "obstack.h"
d34 4
d40 1
a40 1
static bfd_reloc_status_type coff_i386_reloc 
a44 1

d46 2
d70 1
a70 1
     asection *input_section;
d72 1
a72 1
     char **error_message;
a78 1

d81 1
d94 4
a107 1

d109 3
a111 5
  if (reloc_entry->howto->type == 7)
    {
/*      diff -= coff_data(output_bfd)->link_info->pe_info.image_base.value;*/
      exit(1);
    }
a157 2
/* Return true if this relocation should
   appear in the output .reloc section. */
d159 7
a165 2
static boolean in_reloc_p(abfd, howto)
     bfd * abfd;
d169 3
a171 2
}     
#endif
d177 1
a177 1
static reloc_howto_type howto_table[] = 
d179 12
a190 12
  {0},
  {1},
  {2},
  {3},
  {4},
  {5},
  HOWTO (R_DIR32,               /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d192 13
a204 13
	 coff_i386_reloc,       /* special_function */                     
	 "dir32",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
	 true),                /* pcrel_offset */
  /* {7}, */
  HOWTO (R_IMAGEBASE,            /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d206 20
a225 19
	 coff_i386_reloc,       /* special_function */                     
	 "rva32",	           /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
	 false),                /* pcrel_offset */
  {010},
  {011},
  {012},
  {013},
  {014},
  {015},
  {016},
  HOWTO (R_RELBYTE,		/* type */                                 
	 0,			/* rightshift */                           
	 0,			/* size (0 = byte, 1 = short, 2 = long) */ 
	 8,			/* bitsize */                   
	 false,			/* pc_relative */                          
	 0,			/* bitpos */                               
d227 5
a231 5
	 coff_i386_reloc,	/* special_function */                     
	 "8",			/* name */                                 
	 true,			/* partial_inplace */                      
	 0x000000ff,		/* src_mask */                             
	 0x000000ff,		/* dst_mask */                             
d233 7
a239 6
  HOWTO (R_RELWORD,		/* type */                                 
	 0,			/* rightshift */                           
	 1,			/* size (0 = byte, 1 = short, 2 = long) */ 
	 16,			/* bitsize */                   
	 false,			/* pc_relative */                          
	 0,			/* bitpos */                               
d241 5
a245 5
	 coff_i386_reloc,	/* special_function */                     
	 "16",			/* name */                                 
	 true,			/* partial_inplace */                      
	 0x0000ffff,		/* src_mask */                             
	 0x0000ffff,		/* dst_mask */                             
d247 7
a253 6
  HOWTO (R_RELLONG,		/* type */                                 
	 0,			/* rightshift */                           
	 2,			/* size (0 = byte, 1 = short, 2 = long) */ 
	 32,			/* bitsize */                   
	 false,			/* pc_relative */                          
	 0,			/* bitpos */                               
d255 5
a259 5
	 coff_i386_reloc,	/* special_function */                     
	 "32",			/* name */                                 
	 true,			/* partial_inplace */                      
	 0xffffffff,		/* src_mask */                             
	 0xffffffff,		/* dst_mask */                             
d261 7
a267 6
  HOWTO (R_PCRBYTE,		/* type */                                 
	 0,			/* rightshift */                           
	 0,			/* size (0 = byte, 1 = short, 2 = long) */ 
	 8,			/* bitsize */                   
	 true,			/* pc_relative */                          
	 0,			/* bitpos */                               
d269 5
a273 5
	 coff_i386_reloc,	/* special_function */                     
	 "DISP8",		/* name */                                 
	 true,			/* partial_inplace */                      
	 0x000000ff,		/* src_mask */                             
	 0x000000ff,		/* dst_mask */                             
d275 7
a281 6
  HOWTO (R_PCRWORD,		/* type */                                 
	 0,			/* rightshift */                           
	 1,			/* size (0 = byte, 1 = short, 2 = long) */ 
	 16,			/* bitsize */                   
	 true,			/* pc_relative */                          
	 0,			/* bitpos */                               
d283 5
a287 5
	 coff_i386_reloc,	/* special_function */                     
	 "DISP16",		/* name */                                 
	 true,			/* partial_inplace */                      
	 0x0000ffff,		/* src_mask */                             
	 0x0000ffff,		/* dst_mask */                             
d289 7
a295 6
  HOWTO (R_PCRLONG,		/* type */                                 
	 0,			/* rightshift */                           
	 2,			/* size (0 = byte, 1 = short, 2 = long) */ 
	 32,			/* bitsize */                   
	 true,			/* pc_relative */                          
	 0,			/* bitpos */                               
d297 5
a301 5
	 coff_i386_reloc,	/* special_function */                     
	 "DISP32",		/* name */                                 
	 true,			/* partial_inplace */                      
	 0xffffffff,		/* src_mask */                             
	 0xffffffff,		/* dst_mask */                             
d311 5
a315 2
#define RTYPE2HOWTO(cache_ptr, dst) \
	    (cache_ptr)->howto = howto_table + (dst)->r_type;
d355 6
a360 1
/* We use the special COFF backend linker.  */
d363 37
d402 1
a402 1
     bfd *abfd;
d409 1
d411 5
a415 1
  reloc_howto_type *howto;
d420 1
d434 1
a434 1
 
a436 1

d438 7
a444 6
      /* I think we *do* want to bypass this.  If we don't, I have seen some data
	 parameters get the wrong relcation address.  If I link two versions
	 with and without this section bypassed and then do a binary comparison,
	 the addresses which are different can be looked up in the map.  The 
	 case in which this section has been bypassed has addresses which correspond
	 to values I can find in the map */
d449 1
d453 1
a453 1
  if (h != NULL && h->root.type == bfd_link_hash_common) 
d455 1
a455 1

d459 12
a470 1
    *addendp -= 4;
a480 1

a482 1

d485 1
a485 1
     bfd *abfd;
d491 1
a491 1
      return howto_table +R_IMAGEBASE;
d496 8
d510 1
d512 1
d514 3
a516 1
#define coff_rtype_to_howto coff_i386_rtype_to_howto
d518 1
a518 1
#include "coffcode.h"
d520 4
a523 3
static const bfd_target *
i3coff_object_p(a)
     bfd *a;
d525 4
a528 1
  return coff_object_p(a);
d531 6
a556 3
#ifndef COFF_WITH_PE
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
#else
d558 2
a559 1
   | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),
d561 1
d579 2
a580 2
    {_bfd_dummy_target, i3coff_object_p, /* bfd_check_format */
       bfd_generic_archive_p, i3coff_object_p},
d596 3
a598 1
  COFF_SWAP_TABLE,
@


1.1
log
@Initial revision
@
text
@d417 2
d451 2
a452 2
  false,			/* data byte order is little */
  false,			/* header byte order is little */
d458 1
d460 5
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@a416 2
    case BFD_RELOC_32_PCREL:
      return howto_table + R_PCRLONG;
d449 2
a450 2
  BFD_ENDIAN_LITTLE,		/* data byte order is little */
  BFD_ENDIAN_LITTLE,		/* header byte order is little */
a455 1
#ifndef COFF_WITH_PE
a456 5
#else
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC /* section flags */
   | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),
#endif

@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d24 1
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
a32 4
#ifdef COFF_GO32_EXE
#include "coff/go32exe.h"
#endif

d35 1
a35 1
static bfd_reloc_status_type coff_i386_reloc
d40 1
a41 2
static reloc_howto_type *coff_i386_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d64 1
a64 1
     asection *input_section ATTRIBUTE_UNUSED;
d66 1
a66 1
     char **error_message ATTRIBUTE_UNUSED;
d73 1
a75 1
#ifndef COFF_WITH_PE
a87 4
#else
      /* In PE mode, we do not offset the common symbol.  */
      diff = reloc_entry->addend;
#endif
d98 1
d100 5
a104 3
  /* FIXME: How should this case be handled?  */
  if (reloc_entry->howto->type == R_IMAGEBASE)
    diff -= pe_data (output_bfd)->pe_opthdr.ImageBase;
d151 2
d154 2
a155 7
/* Return true if this relocation should appear in the output .reloc
   section.  */

static boolean in_reloc_p PARAMS ((bfd *, reloc_howto_type *));

static boolean in_reloc_p (abfd, howto)
     bfd *abfd ATTRIBUTE_UNUSED;
d159 2
a160 3
}

#endif /* COFF_WITH_PE */
d166 1
a166 1
static reloc_howto_type howto_table[] =
d168 12
a179 12
  EMPTY_HOWTO (0),
  EMPTY_HOWTO (1),
  EMPTY_HOWTO (2),
  EMPTY_HOWTO (3),
  EMPTY_HOWTO (4),
  EMPTY_HOWTO (5),
  HOWTO (R_DIR32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d181 13
a193 13
	 coff_i386_reloc,	/* special_function */
	 "dir32",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 true),			/* pcrel_offset */
  /* PE IMAGE_REL_I386_DIR32NB relocation (7).	*/
  HOWTO (R_IMAGEBASE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d195 19
a213 20
	 coff_i386_reloc,	/* special_function */
	 "rva32",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */
  EMPTY_HOWTO (010),
  EMPTY_HOWTO (011),
  EMPTY_HOWTO (012),
  EMPTY_HOWTO (013),
  EMPTY_HOWTO (014),
  EMPTY_HOWTO (015),
  EMPTY_HOWTO (016),
  /* Byte relocation (017).  */
  HOWTO (R_RELBYTE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d215 5
a219 5
	 coff_i386_reloc,	/* special_function */
	 "8",			/* name */
	 true,			/* partial_inplace */
	 0x000000ff,		/* src_mask */
	 0x000000ff,		/* dst_mask */
d221 6
a226 7
  /* 16-bit word relocation (020).  */
  HOWTO (R_RELWORD,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d228 5
a232 5
	 coff_i386_reloc,	/* special_function */
	 "16",			/* name */
	 true,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
d234 6
a239 7
  /* 32-bit longword relocation (021).	*/
  HOWTO (R_RELLONG,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d241 5
a245 5
	 coff_i386_reloc,	/* special_function */
	 "32",			/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
d247 6
a252 7
  /* Byte PC relative relocation (022).	 */
  HOWTO (R_PCRBYTE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
d254 5
a258 5
	 coff_i386_reloc,	/* special_function */
	 "DISP8",		/* name */
	 true,			/* partial_inplace */
	 0x000000ff,		/* src_mask */
	 0x000000ff,		/* dst_mask */
d260 6
a265 7
  /* 16-bit word PC relative relocation (023).	*/
  HOWTO (R_PCRWORD,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
d267 5
a271 5
	 coff_i386_reloc,	/* special_function */
	 "DISP16",		/* name */
	 true,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
d273 6
a278 7
  /* 32-bit longword PC relative relocation (024).  */
  HOWTO (R_PCRLONG,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
d280 5
a284 5
	 coff_i386_reloc,	/* special_function */
	 "DISP32",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
d294 2
a295 5
#define RTYPE2HOWTO(cache_ptr, dst)					\
  ((cache_ptr)->howto =							\
   ((dst)->r_type < sizeof (howto_table) / sizeof (howto_table[0])	\
    ? howto_table + (dst)->r_type					\
    : NULL))
d335 1
a335 6
/* We use the special COFF backend linker.  For normal i386 COFF, we
   can use the generic relocate_section routine.  For PE, we need our
   own routine.  */

#ifndef COFF_WITH_PE

a337 37
#else /* COFF_WITH_PE */

/* The PE relocate section routine.  The only difference between this
   and the regular routine is that we don't want to do anything for a
   relocateable link.  */

static boolean coff_pe_i386_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   struct internal_reloc *, struct internal_syment *, asection **));

static boolean
coff_pe_i386_relocate_section (output_bfd, info, input_bfd,
			       input_section, contents, relocs, syms,
			       sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     struct internal_reloc *relocs;
     struct internal_syment *syms;
     asection **sections;
{
  if (info->relocateable)
    return true;

  return _bfd_coff_generic_relocate_section (output_bfd, info, input_bfd,
					     input_section, contents,
					     relocs, syms, sections);
}

#define coff_relocate_section coff_pe_i386_relocate_section

#endif /* COFF_WITH_PE */

/* Convert an rtype to howto for the COFF backend linker.  */

d340 1
a340 1
     bfd *abfd ATTRIBUTE_UNUSED;
d347 1
a349 6
  if (rel->r_type > sizeof (howto_table) / sizeof (howto_table[0]))
    {
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }

a352 1
  /* Cancel out code in _bfd_coff_generic_relocate_section.  */
d366 2
a368 1
      BFD_ASSERT (h != NULL);
d371 6
a376 7
      /* I think we *do* want to bypass this.  If we don't, I have
	 seen some data parameters get the wrong relocation address.
	 If I link two versions with and without this section bypassed
	 and then do a binary comparison, the addresses which are
	 different can be looked up in the map.  The case in which
	 this section has been bypassed has addresses which correspond
	 to values I can find in the map.  */
a380 1
#ifndef COFF_WITH_PE
d384 1
a384 1
  if (h != NULL && h->root.type == bfd_link_hash_common)
d386 1
a386 1
#endif
d390 1
a390 12
    {
      *addendp -= 4;

      /* If the symbol is defined, then the generic code is going to
         add back the symbol value in order to cancel out an
         adjustment it made to the addend.  However, we set the addend
         to 0 at the start of this function.  We need to adjust here,
         to avoid the adjustment the generic code will make.  FIXME:
         This is getting a bit hackish.  */
      if (sym != NULL && sym->n_scnum != 0)
	*addendp -= sym->n_value;
    }
d401 1
d404 1
d407 1
a407 1
     bfd *abfd ATTRIBUTE_UNUSED;
d413 1
a413 1
      return howto_table + R_IMAGEBASE;
a417 8
    case BFD_RELOC_16:
      return howto_table + R_RELWORD;
    case BFD_RELOC_16_PCREL:
      return howto_table + R_PCRWORD;
    case BFD_RELOC_8:
      return howto_table + R_RELBYTE;
    case BFD_RELOC_8_PCREL:
      return howto_table + R_PCRBYTE;
a423 1
#define coff_rtype_to_howto coff_i386_rtype_to_howto
a424 1
#ifdef TARGET_UNDERSCORE
d426 1
a426 3
/* If i386 gcc uses underscores for symbol names, then it does not use
   a leading dot for local labels, so if TARGET_UNDERSCORE is defined
   we treat all symbols starting with L as local.  */
d428 1
a428 1
static boolean coff_i386_is_local_label_name PARAMS ((bfd *, const char *));
d430 3
a432 4
static boolean
coff_i386_is_local_label_name (abfd, name)
     bfd *abfd;
     const char *name;
d434 1
a434 4
  if (name[0] == 'L')
    return true;

  return _bfd_coff_is_local_label_name (abfd, name);
a436 6
#define coff_bfd_is_local_label_name coff_i386_is_local_label_name

#endif /* TARGET_UNDERSCORE */

#include "coffcode.h"

d457 3
d461 1
a461 2
#ifdef COFF_WITH_PE
   | SEC_LINK_ONCE | SEC_LINK_DUPLICATES
a462 1
   | SEC_CODE | SEC_DATA),
d480 2
a481 2
    {_bfd_dummy_target, coff_object_p, /* bfd_check_format */
       bfd_generic_archive_p, coff_object_p},
d497 1
a497 3
  NULL,

  COFF_SWAP_TABLE
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
a75 1
#ifndef COFF_WITH_PE
a77 1
#endif
d105 1
a105 20
#ifdef COFF_WITH_PE
      if (output_bfd == (bfd *) NULL)
	{
	  reloc_howto_type *howto = reloc_entry->howto;

	  /* Although PC relative relocations are very similar between
	     PE and non-PE formats, but they are off by 1 << howto->size
	     bytes. For the external relocation, PE is very different
	     from others. See md_apply_fix3 () in gas/config/tc-i386.c.
	     When we link PE and non-PE object files together to
	     generate a non-PE executable, we have to compensate it
	     here.  */
	  if (howto->pc_relative == true && howto->pcrel_offset == true)
	    diff = -(1 << howto->size);
	  else
	    diff = -reloc_entry->addend;
	}
      else
#endif
	diff = reloc_entry->addend;
d110 1
a110 3
  if (reloc_entry->howto->type == R_IMAGEBASE
      && output_bfd != NULL
      && bfd_get_flavour(output_bfd) == bfd_target_coff_flavour)
d158 1
d165 1
a165 1
     bfd * abfd ATTRIBUTE_UNUSED;
d170 1
d472 1
a472 3
  if (rel->r_type == R_IMAGEBASE
      && (bfd_get_flavour(sec->output_section->owner)
	  == bfd_target_coff_flavour))
d559 1
a559 1
   | SEC_LINK_ONCE | SEC_LINK_DUPLICATES | SEC_READONLY
d578 1
a578 1
/* Note that we allow an object file to be treated as a core file as well.  */
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2000, 2001, 2002
d120 1
a120 1
	  if (howto->pc_relative && howto->pcrel_offset)
d160 1
a160 1
	      bfd_put_16 (abfd, (bfd_vma) x, addr);
d168 1
a168 1
	      bfd_put_32 (abfd, (bfd_vma) x, addr);
d182 1
a182 1
/* Return TRUE if this relocation should appear in the output .reloc
d185 1
a185 1
static bfd_boolean in_reloc_p PARAMS ((bfd *, reloc_howto_type *));
d187 1
a187 1
static bfd_boolean in_reloc_p (abfd, howto)
d196 1
a196 1
#define PCRELOFFSET FALSE
d211 1
a211 1
	 FALSE,			/* pc_relative */
d216 1
a216 1
	 TRUE,			/* partial_inplace */
d219 1
a219 1
	 TRUE),			/* pcrel_offset */
d225 1
a225 1
	 FALSE,			/* pc_relative */
d230 1
a230 1
	 TRUE,			/* partial_inplace */
d233 1
a233 1
	 FALSE),		/* pcrel_offset */
d246 1
a246 1
	 FALSE,			/* pc_relative */
d251 1
a251 1
	 TRUE,			/* partial_inplace */
d260 1
a260 1
	 FALSE,			/* pc_relative */
d265 1
a265 1
	 TRUE,			/* partial_inplace */
d274 1
a274 1
	 FALSE,			/* pc_relative */
d279 1
a279 1
	 TRUE,			/* partial_inplace */
d288 1
a288 1
	 TRUE,			/* pc_relative */
d293 1
a293 1
	 TRUE,			/* partial_inplace */
d302 1
a302 1
	 TRUE,			/* pc_relative */
d307 1
a307 1
	 TRUE,			/* partial_inplace */
d316 1
a316 1
	 TRUE,			/* pc_relative */
d321 1
a321 1
	 TRUE,			/* partial_inplace */
d391 1
a391 1
static bfd_boolean coff_pe_i386_relocate_section
d395 1
a395 1
static bfd_boolean
d409 1
a409 1
    return TRUE;
d542 1
a542 2
static bfd_boolean coff_i386_is_local_label_name
  PARAMS ((bfd *, const char *));
d544 1
a544 1
static bfd_boolean
d550 1
a550 1
    return TRUE;
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d59 1
a59 1
/* If we are producing relocatable output, we need to do some
d106 1
a106 1
	 relocatable output.  This seems to be always wrong for 386
d389 1
a389 1
   relocatable link.  */
d408 1
a408 1
  if (info->relocatable)
d473 1
a473 1
     relocatable link), we need to add in the final size of the
@


