head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.8
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.10
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.8
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.4
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.9.0.10
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.8
	OPENBSD_5_0:1.9.0.6
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.4
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.12.22.14.09.58;	author kettenis;	state Exp;
branches;
next	1.10;
commitid	mlKqkMkgtkgOcmHH;

1.10
date	2012.08.31.19.45.34;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2010.07.19.17.32.18;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.02.20.45.06;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.21;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.29;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.12;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.33.04;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.00.33;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.44.44;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.46;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.46;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.05.34;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.37.47;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.12.26;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.18.57;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.37;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.23.36;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.14;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.22;	author miod;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Teach ld(1) not to add a PT_INTERP entry for -static -pie.

ok kurt@@
@
text
@/* BFD back-end for HP PA-RISC ELF files.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000, 2001,
   2002, 2003, 2004 Free Software Foundation, Inc.

   Original code by
	Center for Software Science
	Department of Computer Science
	University of Utah
   Largely rewritten by Alan Modra <alan@@linuxcare.com.au>

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/hppa.h"
#include "libhppa.h"
#include "elf32-hppa.h"
#define ARCH_SIZE		32
#include "elf32-hppa.h"
#include "elf-hppa.h"

/* In order to gain some understanding of code in this file without
   knowing all the intricate details of the linker, note the
   following:

   Functions named elf32_hppa_* are called by external routines, other
   functions are only called locally.  elf32_hppa_* functions appear
   in this file more or less in the order in which they are called
   from external routines.  eg. elf32_hppa_check_relocs is called
   early in the link process, elf32_hppa_finish_dynamic_sections is
   one of the last functions.  */

/* We use two hash tables to hold information for linking PA ELF objects.

   The first is the elf32_hppa_link_hash_table which is derived
   from the standard ELF linker hash table.  We use this as a place to
   attach other hash tables and static information.

   The second is the stub hash table which is derived from the
   base BFD hash table.  The stub hash table holds the information
   necessary to build the linker stubs during a link.

   There are a number of different stubs generated by the linker.

   Long branch stub:
   :		ldil LR'X,%r1
   :		be,n RR'X(%sr4,%r1)

   PIC long branch stub:
   :		b,l .+8,%r1
   :		addil LR'X - ($PIC_pcrel$0 - 4),%r1
   :		be,n RR'X - ($PIC_pcrel$0 - 8)(%sr4,%r1)

   Import stub to call shared library routine from normal object file
   (single sub-space version)
   :		addil LR'lt_ptr+ltoff,%dp	; get procedure entry point
   :		ldw RR'lt_ptr+ltoff(%r1),%r21
   :		bv %r0(%r21)
   :		ldw RR'lt_ptr+ltoff+4(%r1),%r19	; get new dlt value.

   Import stub to call shared library routine from shared library
   (single sub-space version)
   :		addil LR'ltoff,%r19		; get procedure entry point
   :		ldw RR'ltoff(%r1),%r21
   :		bv %r0(%r21)
   :		ldw RR'ltoff+4(%r1),%r19	; get new dlt value.

   Import stub to call shared library routine from normal object file
   (multiple sub-space support)
   :		addil LR'lt_ptr+ltoff,%dp	; get procedure entry point
   :		ldw RR'lt_ptr+ltoff(%r1),%r21
   :		ldw RR'lt_ptr+ltoff+4(%r1),%r19	; get new dlt value.
   :		ldsid (%r21),%r1
   :		mtsp %r1,%sr0
   :		be 0(%sr0,%r21)			; branch to target
   :		stw %rp,-24(%sp)		; save rp

   Import stub to call shared library routine from shared library
   (multiple sub-space support)
   :		addil LR'ltoff,%r19		; get procedure entry point
   :		ldw RR'ltoff(%r1),%r21
   :		ldw RR'ltoff+4(%r1),%r19	; get new dlt value.
   :		ldsid (%r21),%r1
   :		mtsp %r1,%sr0
   :		be 0(%sr0,%r21)			; branch to target
   :		stw %rp,-24(%sp)		; save rp

   Export stub to return from shared lib routine (multiple sub-space support)
   One of these is created for each exported procedure in a shared
   library (and stored in the shared lib).  Shared lib routines are
   called via the first instruction in the export stub so that we can
   do an inter-space return.  Not required for single sub-space.
   :		bl,n X,%rp			; trap the return
   :		nop
   :		ldw -24(%sp),%rp		; restore the original rp
   :		ldsid (%rp),%r1
   :		mtsp %r1,%sr0
   :		be,n 0(%sr0,%rp)		; inter-space return.  */

#define PLT_ENTRY_SIZE 8
#define GOT_ENTRY_SIZE 4
#define ELF_DYNAMIC_INTERPRETER "/lib/ld.so.1"

static const bfd_byte plt_stub[] =
{
  0x0e, 0x80, 0x10, 0x96,  /* 1: ldw	0(%r20),%r22		*/
  0xea, 0xc0, 0xc0, 0x00,  /*    bv	%r0(%r22)		*/
  0x0e, 0x88, 0x10, 0x95,  /*    ldw	4(%r20),%r21		*/
#define PLT_STUB_ENTRY (3*4)
  0xea, 0x9f, 0x1f, 0xdd,  /*    b,l	1b,%r20			*/
  0xd6, 0x80, 0x1c, 0x1e,  /*    depi	0,31,2,%r20		*/
  0x00, 0xc0, 0xff, 0xee,  /* 9: .word	fixup_func		*/
  0xde, 0xad, 0xbe, 0xef   /*    .word	fixup_ltp		*/
};

/* Section name for stubs is the associated section name plus this
   string.  */
#define STUB_SUFFIX ".stub"

/* We don't need to copy certain PC- or GP-relative dynamic relocs
   into a shared object's dynamic section.  All the relocs of the
   limited class we are interested in, are absolute.  */
#ifndef RELATIVE_DYNRELOCS
#define RELATIVE_DYNRELOCS 0
#define IS_ABSOLUTE_RELOC(r_type) 1
#endif

/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

enum elf32_hppa_stub_type {
  hppa_stub_long_branch,
  hppa_stub_long_branch_shared,
  hppa_stub_import,
  hppa_stub_import_shared,
  hppa_stub_export,
  hppa_stub_none
};

struct elf32_hppa_stub_hash_entry {

  /* Base hash table entry structure.  */
  struct bfd_hash_entry root;

  /* The stub section.  */
  asection *stub_sec;

  /* Offset within stub_sec of the beginning of this stub.  */
  bfd_vma stub_offset;

  /* Given the symbol's value and its section we can determine its final
     value when building the stubs (so the stub knows where to jump.  */
  bfd_vma target_value;
  asection *target_section;

  enum elf32_hppa_stub_type stub_type;

  /* The symbol table entry, if any, that this was derived from.  */
  struct elf32_hppa_link_hash_entry *h;

  /* Where this stub is being called from, or, in the case of combined
     stub sections, the first input section in the group.  */
  asection *id_sec;
};

struct elf32_hppa_link_hash_entry {

  struct elf_link_hash_entry elf;

  /* A pointer to the most recently used stub hash entry against this
     symbol.  */
  struct elf32_hppa_stub_hash_entry *stub_cache;

  /* Used to count relocations for delayed sizing of relocation
     sections.  */
  struct elf32_hppa_dyn_reloc_entry {

    /* Next relocation in the chain.  */
    struct elf32_hppa_dyn_reloc_entry *next;

    /* The input section of the reloc.  */
    asection *sec;

    /* Number of relocs copied in this section.  */
    bfd_size_type count;

#if RELATIVE_DYNRELOCS
  /* Number of relative relocs copied for the input section.  */
    bfd_size_type relative_count;
#endif
  } *dyn_relocs;

  /* Set if this symbol is used by a plabel reloc.  */
  unsigned int plabel:1;
};

struct elf32_hppa_link_hash_table {

  /* The main hash table.  */
  struct elf_link_hash_table elf;

  /* The stub hash table.  */
  struct bfd_hash_table stub_hash_table;

  /* Linker stub bfd.  */
  bfd *stub_bfd;

  /* Linker call-backs.  */
  asection * (*add_stub_section) (const char *, asection *);
  void (*layout_sections_again) (void);

  /* Array to keep track of which stub sections have been created, and
     information on stub grouping.  */
  struct map_stub {
    /* This is the section to which stubs in the group will be
       attached.  */
    asection *link_sec;
    /* The stub section.  */
    asection *stub_sec;
  } *stub_group;

  /* Assorted information used by elf32_hppa_size_stubs.  */
  unsigned int bfd_count;
  int top_index;
  asection **input_list;
  Elf_Internal_Sym **all_local_syms;

  /* Short-cuts to get to dynamic linker sections.  */
  asection *sgot;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
  asection *sdynbss;
  asection *srelbss;

  /* Used during a final link to store the base of the text and data
     segments so that we can perform SEGREL relocations.  */
  bfd_vma text_segment_base;
  bfd_vma data_segment_base;

  /* Whether we support multiple sub-spaces for shared libs.  */
  unsigned int multi_subspace:1;

  /* Flags set when various size branches are detected.  Used to
     select suitable defaults for the stub group size.  */
  unsigned int has_12bit_branch:1;
  unsigned int has_17bit_branch:1;
  unsigned int has_22bit_branch:1;

  /* Set if we need a .plt stub to support lazy dynamic linking.  */
  unsigned int need_plt_stub:1;

  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
};

/* Various hash macros and functions.  */
#define hppa_link_hash_table(p) \
  ((struct elf32_hppa_link_hash_table *) ((p)->hash))

#define hppa_stub_hash_lookup(table, string, create, copy) \
  ((struct elf32_hppa_stub_hash_entry *) \
   bfd_hash_lookup ((table), (string), (create), (copy)))

/* Assorted hash table functions.  */

/* Initialize an entry in the stub hash table.  */

static struct bfd_hash_entry *
stub_hash_newfunc (struct bfd_hash_entry *entry,
		   struct bfd_hash_table *table,
		   const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table,
				 sizeof (struct elf32_hppa_stub_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = bfd_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      struct elf32_hppa_stub_hash_entry *eh;

      /* Initialize the local fields.  */
      eh = (struct elf32_hppa_stub_hash_entry *) entry;
      eh->stub_sec = NULL;
      eh->stub_offset = 0;
      eh->target_value = 0;
      eh->target_section = NULL;
      eh->stub_type = hppa_stub_long_branch;
      eh->h = NULL;
      eh->id_sec = NULL;
    }

  return entry;
}

/* Initialize an entry in the link hash table.  */

static struct bfd_hash_entry *
hppa_link_hash_newfunc (struct bfd_hash_entry *entry,
			struct bfd_hash_table *table,
			const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table,
				 sizeof (struct elf32_hppa_link_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      struct elf32_hppa_link_hash_entry *eh;

      /* Initialize the local fields.  */
      eh = (struct elf32_hppa_link_hash_entry *) entry;
      eh->stub_cache = NULL;
      eh->dyn_relocs = NULL;
      eh->plabel = 0;
    }

  return entry;
}

/* Create the derived linker hash table.  The PA ELF port uses the derived
   hash table to keep information specific to the PA ELF linker (without
   using static variables).  */

static struct bfd_link_hash_table *
elf32_hppa_link_hash_table_create (bfd *abfd)
{
  struct elf32_hppa_link_hash_table *ret;
  bfd_size_type amt = sizeof (*ret);

  ret = bfd_malloc (amt);
  if (ret == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd, hppa_link_hash_newfunc))
    {
      free (ret);
      return NULL;
    }

  /* Init the stub hash table too.  */
  if (!bfd_hash_table_init (&ret->stub_hash_table, stub_hash_newfunc))
    return NULL;

  ret->stub_bfd = NULL;
  ret->add_stub_section = NULL;
  ret->layout_sections_again = NULL;
  ret->stub_group = NULL;
  ret->sgot = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
  ret->text_segment_base = (bfd_vma) -1;
  ret->data_segment_base = (bfd_vma) -1;
  ret->multi_subspace = 0;
  ret->has_12bit_branch = 0;
  ret->has_17bit_branch = 0;
  ret->has_22bit_branch = 0;
  ret->need_plt_stub = 0;
  ret->sym_sec.abfd = NULL;

  return &ret->elf.root;
}

/* Free the derived linker hash table.  */

static void
elf32_hppa_link_hash_table_free (struct bfd_link_hash_table *hash)
{
  struct elf32_hppa_link_hash_table *ret
    = (struct elf32_hppa_link_hash_table *) hash;

  bfd_hash_table_free (&ret->stub_hash_table);
  _bfd_generic_link_hash_table_free (hash);
}

/* Build a name for an entry in the stub hash table.  */

static char *
hppa_stub_name (const asection *input_section,
		const asection *sym_sec,
		const struct elf32_hppa_link_hash_entry *hash,
		const Elf_Internal_Rela *rel)
{
  char *stub_name;
  bfd_size_type len;

  if (hash)
    {
      len = 8 + 1 + strlen (hash->elf.root.root.string) + 1 + 8 + 1;
      stub_name = bfd_malloc (len);
      if (stub_name != NULL)
	{
	  sprintf (stub_name, "%08x_%s+%x",
		   input_section->id & 0xffffffff,
		   hash->elf.root.root.string,
		   (int) rel->r_addend & 0xffffffff);
	}
    }
  else
    {
      len = 8 + 1 + 8 + 1 + 8 + 1 + 8 + 1;
      stub_name = bfd_malloc (len);
      if (stub_name != NULL)
	{
	  sprintf (stub_name, "%08x_%x:%x+%x",
		   input_section->id & 0xffffffff,
		   sym_sec->id & 0xffffffff,
		   (int) ELF32_R_SYM (rel->r_info) & 0xffffffff,
		   (int) rel->r_addend & 0xffffffff);
	}
    }
  return stub_name;
}

/* Look up an entry in the stub hash.  Stub entries are cached because
   creating the stub name takes a bit of time.  */

static struct elf32_hppa_stub_hash_entry *
hppa_get_stub_entry (const asection *input_section,
		     const asection *sym_sec,
		     struct elf32_hppa_link_hash_entry *hash,
		     const Elf_Internal_Rela *rel,
		     struct elf32_hppa_link_hash_table *htab)
{
  struct elf32_hppa_stub_hash_entry *stub_entry;
  const asection *id_sec;

  /* If this input section is part of a group of sections sharing one
     stub section, then use the id of the first section in the group.
     Stub names need to include a section id, as there may well be
     more than one stub used to reach say, printf, and we need to
     distinguish between them.  */
  id_sec = htab->stub_group[input_section->id].link_sec;

  if (hash != NULL && hash->stub_cache != NULL
      && hash->stub_cache->h == hash
      && hash->stub_cache->id_sec == id_sec)
    {
      stub_entry = hash->stub_cache;
    }
  else
    {
      char *stub_name;

      stub_name = hppa_stub_name (id_sec, sym_sec, hash, rel);
      if (stub_name == NULL)
	return NULL;

      stub_entry = hppa_stub_hash_lookup (&htab->stub_hash_table,
					  stub_name, FALSE, FALSE);
      if (hash != NULL)
	hash->stub_cache = stub_entry;

      free (stub_name);
    }

  return stub_entry;
}

/* Add a new stub entry to the stub hash.  Not all fields of the new
   stub entry are initialised.  */

static struct elf32_hppa_stub_hash_entry *
hppa_add_stub (const char *stub_name,
	       asection *section,
	       struct elf32_hppa_link_hash_table *htab)
{
  asection *link_sec;
  asection *stub_sec;
  struct elf32_hppa_stub_hash_entry *stub_entry;

  link_sec = htab->stub_group[section->id].link_sec;
  stub_sec = htab->stub_group[section->id].stub_sec;
  if (stub_sec == NULL)
    {
      stub_sec = htab->stub_group[link_sec->id].stub_sec;
      if (stub_sec == NULL)
	{
	  size_t namelen;
	  bfd_size_type len;
	  char *s_name;

	  namelen = strlen (link_sec->name);
	  len = namelen + sizeof (STUB_SUFFIX);
	  s_name = bfd_alloc (htab->stub_bfd, len);
	  if (s_name == NULL)
	    return NULL;

	  memcpy (s_name, link_sec->name, namelen);
	  memcpy (s_name + namelen, STUB_SUFFIX, sizeof (STUB_SUFFIX));
	  stub_sec = (*htab->add_stub_section) (s_name, link_sec);
	  if (stub_sec == NULL)
	    return NULL;
	  htab->stub_group[link_sec->id].stub_sec = stub_sec;
	}
      htab->stub_group[section->id].stub_sec = stub_sec;
    }

  /* Enter this entry into the linker stub hash table.  */
  stub_entry = hppa_stub_hash_lookup (&htab->stub_hash_table, stub_name,
				      TRUE, FALSE);
  if (stub_entry == NULL)
    {
      (*_bfd_error_handler) (_("%s: cannot create stub entry %s"),
			     bfd_archive_filename (section->owner),
			     stub_name);
      return NULL;
    }

  stub_entry->stub_sec = stub_sec;
  stub_entry->stub_offset = 0;
  stub_entry->id_sec = link_sec;
  return stub_entry;
}

/* Determine the type of stub needed, if any, for a call.  */

static enum elf32_hppa_stub_type
hppa_type_of_stub (asection *input_sec,
		   const Elf_Internal_Rela *rel,
		   struct elf32_hppa_link_hash_entry *hash,
		   bfd_vma destination,
		   struct bfd_link_info *info)
{
  bfd_vma location;
  bfd_vma branch_offset;
  bfd_vma max_branch_offset;
  unsigned int r_type;

  if (hash != NULL
      && hash->elf.plt.offset != (bfd_vma) -1
      && hash->elf.dynindx != -1
      && !hash->plabel
      && (info->shared
	  || !(hash->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
	  || hash->elf.root.type == bfd_link_hash_defweak))
    {
      /* We need an import stub.  Decide between hppa_stub_import
	 and hppa_stub_import_shared later.  */
      return hppa_stub_import;
    }

  /* Determine where the call point is.  */
  location = (input_sec->output_offset
	      + input_sec->output_section->vma
	      + rel->r_offset);

  branch_offset = destination - location - 8;
  r_type = ELF32_R_TYPE (rel->r_info);

  /* Determine if a long branch stub is needed.  parisc branch offsets
     are relative to the second instruction past the branch, ie. +8
     bytes on from the branch instruction location.  The offset is
     signed and counts in units of 4 bytes.  */
  if (r_type == (unsigned int) R_PARISC_PCREL17F)
    {
      max_branch_offset = (1 << (17-1)) << 2;
    }
  else if (r_type == (unsigned int) R_PARISC_PCREL12F)
    {
      max_branch_offset = (1 << (12-1)) << 2;
    }
  else /* R_PARISC_PCREL22F.  */
    {
      max_branch_offset = (1 << (22-1)) << 2;
    }

  if (branch_offset + max_branch_offset >= 2*max_branch_offset)
    return hppa_stub_long_branch;

  return hppa_stub_none;
}

/* Build one linker stub as defined by the stub hash table entry GEN_ENTRY.
   IN_ARG contains the link info pointer.  */

#define LDIL_R1		0x20200000	/* ldil  LR'XXX,%r1		*/
#define BE_SR4_R1	0xe0202002	/* be,n  RR'XXX(%sr4,%r1)	*/

#define BL_R1		0xe8200000	/* b,l   .+8,%r1		*/
#define ADDIL_R1	0x28200000	/* addil LR'XXX,%r1,%r1		*/
#define DEPI_R1		0xd4201c1e	/* depi  0,31,2,%r1		*/

#define ADDIL_DP	0x2b600000	/* addil LR'XXX,%dp,%r1		*/
#define LDW_R1_R21	0x48350000	/* ldw   RR'XXX(%sr0,%r1),%r21	*/
#define BV_R0_R21	0xeaa0c000	/* bv    %r0(%r21)		*/
#define LDW_R1_R19	0x48330000	/* ldw   RR'XXX(%sr0,%r1),%r19	*/

#define ADDIL_R19	0x2a600000	/* addil LR'XXX,%r19,%r1	*/
#define LDW_R1_DP	0x483b0000	/* ldw   RR'XXX(%sr0,%r1),%dp	*/

#define LDSID_R21_R1	0x02a010a1	/* ldsid (%sr0,%r21),%r1	*/
#define MTSP_R1		0x00011820	/* mtsp  %r1,%sr0		*/
#define BE_SR0_R21	0xe2a00000	/* be    0(%sr0,%r21)		*/
#define STW_RP		0x6bc23fd1	/* stw   %rp,-24(%sr0,%sp)	*/

#define BL22_RP		0xe800a002	/* b,l,n XXX,%rp		*/
#define BL_RP		0xe8400002	/* b,l,n XXX,%rp		*/
#define NOP		0x08000240	/* nop				*/
#define LDW_RP		0x4bc23fd1	/* ldw   -24(%sr0,%sp),%rp	*/
#define LDSID_RP_R1	0x004010a1	/* ldsid (%sr0,%rp),%r1		*/
#define BE_SR0_RP	0xe0400002	/* be,n  0(%sr0,%rp)		*/

#ifndef R19_STUBS
#define R19_STUBS 1
#endif

#if R19_STUBS
#define LDW_R1_DLT	LDW_R1_R19
#else
#define LDW_R1_DLT	LDW_R1_DP
#endif

static bfd_boolean
hppa_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
{
  struct elf32_hppa_stub_hash_entry *stub_entry;
  struct bfd_link_info *info;
  struct elf32_hppa_link_hash_table *htab;
  asection *stub_sec;
  bfd *stub_bfd;
  bfd_byte *loc;
  bfd_vma sym_value;
  bfd_vma insn;
  bfd_vma off;
  int val;
  int size;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_hppa_stub_hash_entry *) gen_entry;
  info = in_arg;

  htab = hppa_link_hash_table (info);
  stub_sec = stub_entry->stub_sec;

  /* Make a note of the offset within the stubs for this entry.  */
  stub_entry->stub_offset = stub_sec->_raw_size;
  loc = stub_sec->contents + stub_entry->stub_offset;

  stub_bfd = stub_sec->owner;

  switch (stub_entry->stub_type)
    {
    case hppa_stub_long_branch:
      /* Create the long branch.  A long branch is formed with "ldil"
	 loading the upper bits of the target address into a register,
	 then branching with "be" which adds in the lower bits.
	 The "be" has its delay slot nullified.  */
      sym_value = (stub_entry->target_value
		   + stub_entry->target_section->output_offset
		   + stub_entry->target_section->output_section->vma);

      val = hppa_field_adjust (sym_value, 0, e_lrsel);
      insn = hppa_rebuild_insn ((int) LDIL_R1, val, 21);
      bfd_put_32 (stub_bfd, insn, loc);

      val = hppa_field_adjust (sym_value, 0, e_rrsel) >> 2;
      insn = hppa_rebuild_insn ((int) BE_SR4_R1, val, 17);
      bfd_put_32 (stub_bfd, insn, loc + 4);

      size = 8;
      break;

    case hppa_stub_long_branch_shared:
      /* Branches are relative.  This is where we are going to.  */
      sym_value = (stub_entry->target_value
		   + stub_entry->target_section->output_offset
		   + stub_entry->target_section->output_section->vma);

      /* And this is where we are coming from, more or less.  */
      sym_value -= (stub_entry->stub_offset
		    + stub_sec->output_offset
		    + stub_sec->output_section->vma);

      bfd_put_32 (stub_bfd, (bfd_vma) BL_R1, loc);
      val = hppa_field_adjust (sym_value, (bfd_signed_vma) -8, e_lrsel);
      insn = hppa_rebuild_insn ((int) ADDIL_R1, val, 21);
      bfd_put_32 (stub_bfd, insn, loc + 4);

      val = hppa_field_adjust (sym_value, (bfd_signed_vma) -8, e_rrsel) >> 2;
      insn = hppa_rebuild_insn ((int) BE_SR4_R1, val, 17);
      bfd_put_32 (stub_bfd, insn, loc + 8);
      size = 12;
      break;

    case hppa_stub_import:
    case hppa_stub_import_shared:
      off = stub_entry->h->elf.plt.offset;
      if (off >= (bfd_vma) -2)
	abort ();

      off &= ~ (bfd_vma) 1;
      sym_value = (off
		   + htab->splt->output_offset
		   + htab->splt->output_section->vma
		   - elf_gp (htab->splt->output_section->owner));

      insn = ADDIL_DP;
#if R19_STUBS
      if (stub_entry->stub_type == hppa_stub_import_shared)
	insn = ADDIL_R19;
#endif
      val = hppa_field_adjust (sym_value, 0, e_lrsel),
      insn = hppa_rebuild_insn ((int) insn, val, 21);
      bfd_put_32 (stub_bfd, insn, loc);

      /* It is critical to use lrsel/rrsel here because we are using
	 two different offsets (+0 and +4) from sym_value.  If we use
	 lsel/rsel then with unfortunate sym_values we will round
	 sym_value+4 up to the next 2k block leading to a mis-match
	 between the lsel and rsel value.  */
      val = hppa_field_adjust (sym_value, 0, e_rrsel);
      insn = hppa_rebuild_insn ((int) LDW_R1_R21, val, 14);
      bfd_put_32 (stub_bfd, insn, loc + 4);

      if (htab->multi_subspace)
	{
	  val = hppa_field_adjust (sym_value, (bfd_signed_vma) 4, e_rrsel);
	  insn = hppa_rebuild_insn ((int) LDW_R1_DLT, val, 14);
	  bfd_put_32 (stub_bfd, insn, loc + 8);

	  bfd_put_32 (stub_bfd, (bfd_vma) LDSID_R21_R1, loc + 12);
	  bfd_put_32 (stub_bfd, (bfd_vma) MTSP_R1,      loc + 16);
	  bfd_put_32 (stub_bfd, (bfd_vma) BE_SR0_R21,   loc + 20);
	  bfd_put_32 (stub_bfd, (bfd_vma) STW_RP,       loc + 24);

	  size = 28;
	}
      else
	{
	  bfd_put_32 (stub_bfd, (bfd_vma) BV_R0_R21, loc + 8);
	  val = hppa_field_adjust (sym_value, (bfd_signed_vma) 4, e_rrsel);
	  insn = hppa_rebuild_insn ((int) LDW_R1_DLT, val, 14);
	  bfd_put_32 (stub_bfd, insn, loc + 12);

	  size = 16;
	}

      break;

    case hppa_stub_export:
      /* Branches are relative.  This is where we are going to.  */
      sym_value = (stub_entry->target_value
		   + stub_entry->target_section->output_offset
		   + stub_entry->target_section->output_section->vma);

      /* And this is where we are coming from.  */
      sym_value -= (stub_entry->stub_offset
		    + stub_sec->output_offset
		    + stub_sec->output_section->vma);

      if (sym_value - 8 + (1 << (17 + 1)) >= (1 << (17 + 2))
	  && (!htab->has_22bit_branch
	      || sym_value - 8 + (1 << (22 + 1)) >= (1 << (22 + 2))))
	{
	  (*_bfd_error_handler)
	    (_("%s(%s+0x%lx): cannot reach %s, recompile with -ffunction-sections"),
	     bfd_archive_filename (stub_entry->target_section->owner),
	     stub_sec->name,
	     (long) stub_entry->stub_offset,
	     stub_entry->root.string);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      val = hppa_field_adjust (sym_value, (bfd_signed_vma) -8, e_fsel) >> 2;
      if (!htab->has_22bit_branch)
	insn = hppa_rebuild_insn ((int) BL_RP, val, 17);
      else
	insn = hppa_rebuild_insn ((int) BL22_RP, val, 22);
      bfd_put_32 (stub_bfd, insn, loc);

      bfd_put_32 (stub_bfd, (bfd_vma) NOP,         loc + 4);
      bfd_put_32 (stub_bfd, (bfd_vma) LDW_RP,      loc + 8);
      bfd_put_32 (stub_bfd, (bfd_vma) LDSID_RP_R1, loc + 12);
      bfd_put_32 (stub_bfd, (bfd_vma) MTSP_R1,     loc + 16);
      bfd_put_32 (stub_bfd, (bfd_vma) BE_SR0_RP,   loc + 20);

      /* Point the function symbol at the stub.  */
      stub_entry->h->elf.root.u.def.section = stub_sec;
      stub_entry->h->elf.root.u.def.value = stub_sec->_raw_size;

      size = 24;
      break;

    default:
      BFD_FAIL ();
      return FALSE;
    }

  stub_sec->_raw_size += size;
  return TRUE;
}

#undef LDIL_R1
#undef BE_SR4_R1
#undef BL_R1
#undef ADDIL_R1
#undef DEPI_R1
#undef LDW_R1_R21
#undef LDW_R1_DLT
#undef LDW_R1_R19
#undef ADDIL_R19
#undef LDW_R1_DP
#undef LDSID_R21_R1
#undef MTSP_R1
#undef BE_SR0_R21
#undef STW_RP
#undef BV_R0_R21
#undef BL_RP
#undef NOP
#undef LDW_RP
#undef LDSID_RP_R1
#undef BE_SR0_RP

/* As above, but don't actually build the stub.  Just bump offset so
   we know stub section sizes.  */

static bfd_boolean
hppa_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
{
  struct elf32_hppa_stub_hash_entry *stub_entry;
  struct elf32_hppa_link_hash_table *htab;
  int size;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_hppa_stub_hash_entry *) gen_entry;
  htab = in_arg;

  if (stub_entry->stub_type == hppa_stub_long_branch)
    size = 8;
  else if (stub_entry->stub_type == hppa_stub_long_branch_shared)
    size = 12;
  else if (stub_entry->stub_type == hppa_stub_export)
    size = 24;
  else /* hppa_stub_import or hppa_stub_import_shared.  */
    {
      if (htab->multi_subspace)
	size = 28;
      else
	size = 16;
    }

  stub_entry->stub_sec->_raw_size += size;
  return TRUE;
}

/* Return nonzero if ABFD represents an HPPA ELF32 file.
   Additionally we set the default architecture and machine.  */

static bfd_boolean
elf32_hppa_object_p (bfd *abfd)
{
  Elf_Internal_Ehdr * i_ehdrp;
  unsigned int flags;

  i_ehdrp = elf_elfheader (abfd);
  if (strcmp (bfd_get_target (abfd), "elf32-hppa-linux") == 0)
    {
      /* GCC on hppa-linux produces binaries with OSABI=Linux,
	 but the kernel produces corefiles with OSABI=SysV.  */
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_LINUX &&
	  i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_NONE) /* aka SYSV */
	return FALSE;
    }
  else
    {
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_HPUX)
	return FALSE;
    }

  flags = i_ehdrp->e_flags;
  switch (flags & (EF_PARISC_ARCH | EF_PARISC_WIDE))
    {
    case EFA_PARISC_1_0:
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 10);
    case EFA_PARISC_1_1:
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 11);
    case EFA_PARISC_2_0:
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 20);
    case EFA_PARISC_2_0 | EF_PARISC_WIDE:
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 25);
    }
  return TRUE;
}

/* Create the .plt and .got sections, and set up our hash table
   short-cuts to various dynamic sections.  */

static bfd_boolean
elf32_hppa_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  struct elf32_hppa_link_hash_table *htab;

  /* Don't try to create the .plt and .got twice.  */
  htab = hppa_link_hash_table (info);
  if (htab->splt != NULL)
    return TRUE;

  /* Call the generic code to do most of the work.  */
  if (! _bfd_elf_create_dynamic_sections (abfd, info))
    return FALSE;

  htab->splt = bfd_get_section_by_name (abfd, ".plt");
  htab->srelplt = bfd_get_section_by_name (abfd, ".rela.plt");

  htab->sgot = bfd_get_section_by_name (abfd, ".got");
  htab->srelgot = bfd_make_section (abfd, ".rela.got");
  if (htab->srelgot == NULL
      || ! bfd_set_section_flags (abfd, htab->srelgot,
				  (SEC_ALLOC
				   | SEC_LOAD
				   | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY
				   | SEC_LINKER_CREATED
				   | SEC_READONLY))
      || ! bfd_set_section_alignment (abfd, htab->srelgot, 2))
    return FALSE;

  htab->sdynbss = bfd_get_section_by_name (abfd, ".dynbss");
  htab->srelbss = bfd_get_section_by_name (abfd, ".rela.bss");

  return TRUE;
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
elf32_hppa_copy_indirect_symbol (const struct elf_backend_data *bed,
				 struct elf_link_hash_entry *dir,
				 struct elf_link_hash_entry *ind)
{
  struct elf32_hppa_link_hash_entry *edir, *eind;

  edir = (struct elf32_hppa_link_hash_entry *) dir;
  eind = (struct elf32_hppa_link_hash_entry *) ind;

  if (eind->dyn_relocs != NULL)
    {
      if (edir->dyn_relocs != NULL)
	{
	  struct elf32_hppa_dyn_reloc_entry **pp;
	  struct elf32_hppa_dyn_reloc_entry *p;

	  if (ind->root.type == bfd_link_hash_indirect)
	    abort ();

	  /* Add reloc counts against the weak sym to the strong sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
	    {
	      struct elf32_hppa_dyn_reloc_entry *q;

	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
		if (q->sec == p->sec)
		  {
#if RELATIVE_DYNRELOCS
		    q->relative_count += p->relative_count;
#endif
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->dyn_relocs;
	}

      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
    }

  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
}

/* Look through the relocs for a section during the first phase, and
   calculate needed space in the global offset table, procedure linkage
   table, and dynamic reloc sections.  At this point we haven't
   necessarily read all the input files.  */

static bfd_boolean
elf32_hppa_check_relocs (bfd *abfd,
			 struct bfd_link_info *info,
			 asection *sec,
			 const Elf_Internal_Rela *relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  struct elf32_hppa_link_hash_table *htab;
  asection *sreloc;
  asection *stubreloc;

  if (info->relocatable)
    return TRUE;

  htab = hppa_link_hash_table (info);
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  sreloc = NULL;
  stubreloc = NULL;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      enum {
	NEED_GOT = 1,
	NEED_PLT = 2,
	NEED_DYNREL = 4,
	PLT_PLABEL = 8
      };

      unsigned int r_symndx, r_type;
      struct elf32_hppa_link_hash_entry *h;
      int need_entry;

      r_symndx = ELF32_R_SYM (rel->r_info);

      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	h = ((struct elf32_hppa_link_hash_entry *)
	     sym_hashes[r_symndx - symtab_hdr->sh_info]);

      r_type = ELF32_R_TYPE (rel->r_info);

      switch (r_type)
	{
	case R_PARISC_DLTIND14F:
	case R_PARISC_DLTIND14R:
	case R_PARISC_DLTIND21L:
	  /* This symbol requires a global offset table entry.  */
	  need_entry = NEED_GOT;
	  break;

	case R_PARISC_PLABEL14R: /* "Official" procedure labels.  */
	case R_PARISC_PLABEL21L:
	case R_PARISC_PLABEL32:
	  /* If the addend is non-zero, we break badly.  */
	  if (rel->r_addend != 0)
	    abort ();

	  /* If we are creating a shared library, then we need to
	     create a PLT entry for all PLABELs, because PLABELs with
	     local symbols may be passed via a pointer to another
	     object.  Additionally, output a dynamic relocation
	     pointing to the PLT entry.
	     For executables, the original 32-bit ABI allowed two
	     different styles of PLABELs (function pointers):  For
	     global functions, the PLABEL word points into the .plt
	     two bytes past a (function address, gp) pair, and for
	     local functions the PLABEL points directly at the
	     function.  The magic +2 for the first type allows us to
	     differentiate between the two.  As you can imagine, this
	     is a real pain when it comes to generating code to call
	     functions indirectly or to compare function pointers.
	     We avoid the mess by always pointing a PLABEL into the
	     .plt, even for local functions.  */
	  need_entry = PLT_PLABEL | NEED_PLT | NEED_DYNREL;
	  break;

	case R_PARISC_PCREL12F:
	  htab->has_12bit_branch = 1;
	  goto branch_common;

	case R_PARISC_PCREL17C:
	case R_PARISC_PCREL17F:
	  htab->has_17bit_branch = 1;
	  goto branch_common;

	case R_PARISC_PCREL22F:
	  htab->has_22bit_branch = 1;
	branch_common:
	  /* Function calls might need to go through the .plt, and
	     might require long branch stubs.  */
	  if (h == NULL)
	    {
	      /* We know local syms won't need a .plt entry, and if
		 they need a long branch stub we can't guarantee that
		 we can reach the stub.  So just flag an error later
		 if we're doing a shared link and find we need a long
		 branch stub.  */
	      continue;
	    }
	  else
	    {
	      /* Global symbols will need a .plt entry if they remain
		 global, and in most cases won't need a long branch
		 stub.  Unfortunately, we have to cater for the case
		 where a symbol is forced local by versioning, or due
		 to symbolic linking, and we lose the .plt entry.  */
	      need_entry = NEED_PLT;
	      if (h->elf.type == STT_PARISC_MILLI)
		need_entry = 0;
	    }
	  break;

	case R_PARISC_SEGBASE:  /* Used to set segment base.  */
	case R_PARISC_SEGREL32: /* Relative reloc, used for unwind.  */
	case R_PARISC_PCREL14F: /* PC relative load/store.  */
	case R_PARISC_PCREL14R:
	case R_PARISC_PCREL17R: /* External branches.  */
	case R_PARISC_PCREL21L: /* As above, and for load/store too.  */
	case R_PARISC_PCREL32:
	  /* We don't need to propagate the relocation if linking a
	     shared object since these are section relative.  */
	  continue;

	case R_PARISC_DPREL14F: /* Used for gp rel data load/store.  */
	case R_PARISC_DPREL14R:
	case R_PARISC_DPREL21L:
	  if (info->shared)
	    {
	      (*_bfd_error_handler)
		(_("%s: relocation %s can not be used when making a shared object; recompile with -fPIC"),
		 bfd_archive_filename (abfd),
		 elf_hppa_howto_table[r_type].name);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  /* Fall through.  */

	case R_PARISC_DIR17F: /* Used for external branches.  */
	case R_PARISC_DIR17R:
	case R_PARISC_DIR14F: /* Used for load/store from absolute locn.  */
	case R_PARISC_DIR14R:
	case R_PARISC_DIR21L: /* As above, and for ext branches too.  */
#if 0
	  /* Help debug shared library creation.  Any of the above
	     relocs can be used in shared libs, but they may cause
	     pages to become unshared.  */
	  if (info->shared)
	    {
	      (*_bfd_error_handler)
		(_("%s: relocation %s should not be used when making a shared object; recompile with -fPIC"),
		 bfd_archive_filename (abfd),
		 elf_hppa_howto_table[r_type].name);
	    }
	  /* Fall through.  */
#endif

	case R_PARISC_DIR32: /* .word relocs.  */
	  /* We may want to output a dynamic relocation later.  */
	  need_entry = NEED_DYNREL;
	  break;

	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
	case R_PARISC_GNU_VTINHERIT:
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, &h->elf, rel->r_offset))
	    return FALSE;
	  continue;

	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
	case R_PARISC_GNU_VTENTRY:
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, &h->elf, rel->r_addend))
	    return FALSE;
	  continue;

	default:
	  continue;
	}

      /* Now carry out our orders.  */
      if (need_entry & NEED_GOT)
	{
	  /* Allocate space for a GOT entry, as well as a dynamic
	     relocation for this entry.  */
	  if (htab->sgot == NULL)
	    {
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;
	      if (!elf32_hppa_create_dynamic_sections (htab->elf.dynobj, info))
		return FALSE;
	    }

	  if (h != NULL)
	    {
	      h->elf.got.refcount += 1;
	    }
	  else
	    {
	      bfd_signed_vma *local_got_refcounts;

	      /* This is a global offset table entry for a local symbol.  */
	      local_got_refcounts = elf_local_got_refcounts (abfd);
	      if (local_got_refcounts == NULL)
		{
		  bfd_size_type size;

		  /* Allocate space for local got offsets and local
		     plt offsets.  Done this way to save polluting
		     elf_obj_tdata with another target specific
		     pointer.  */
		  size = symtab_hdr->sh_info;
		  size *= 2 * sizeof (bfd_signed_vma);
		  local_got_refcounts = bfd_zalloc (abfd, size);
		  if (local_got_refcounts == NULL)
		    return FALSE;
		  elf_local_got_refcounts (abfd) = local_got_refcounts;
		}
	      local_got_refcounts[r_symndx] += 1;
	    }
	}

      if (need_entry & NEED_PLT)
	{
	  /* If we are creating a shared library, and this is a reloc
	     against a weak symbol or a global symbol in a dynamic
	     object, then we will be creating an import stub and a
	     .plt entry for the symbol.  Similarly, on a normal link
	     to symbols defined in a dynamic object we'll need the
	     import stub and a .plt entry.  We don't know yet whether
	     the symbol is defined or not, so make an entry anyway and
	     clean up later in adjust_dynamic_symbol.  */
	  if ((sec->flags & SEC_ALLOC) != 0)
	    {
	      if (h != NULL)
		{
		  h->elf.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
		  h->elf.plt.refcount += 1;

		  /* If this .plt entry is for a plabel, mark it so
		     that adjust_dynamic_symbol will keep the entry
		     even if it appears to be local.  */
		  if (need_entry & PLT_PLABEL)
		    h->plabel = 1;
		}
	      else if (need_entry & PLT_PLABEL)
		{
		  bfd_signed_vma *local_got_refcounts;
		  bfd_signed_vma *local_plt_refcounts;

		  local_got_refcounts = elf_local_got_refcounts (abfd);
		  if (local_got_refcounts == NULL)
		    {
		      bfd_size_type size;

		      /* Allocate space for local got offsets and local
			 plt offsets.  */
		      size = symtab_hdr->sh_info;
		      size *= 2 * sizeof (bfd_signed_vma);
		      local_got_refcounts = bfd_zalloc (abfd, size);
		      if (local_got_refcounts == NULL)
			return FALSE;
		      elf_local_got_refcounts (abfd) = local_got_refcounts;
		    }
		  local_plt_refcounts = (local_got_refcounts
					 + symtab_hdr->sh_info);
		  local_plt_refcounts[r_symndx] += 1;
		}
	    }
	}

      if (need_entry & NEED_DYNREL)
	{
	  /* Flag this symbol as having a non-got, non-plt reference
	     so that we generate copy relocs if it turns out to be
	     dynamic.  */
	  if (h != NULL && !info->shared)
	    h->elf.elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;

	  /* If we are creating a shared library then we need to copy
	     the reloc into the shared library.  However, if we are
	     linking with -Bsymbolic, we need only copy absolute
	     relocs or relocs against symbols that are not defined in
	     an object we are including in the link.  PC- or DP- or
	     DLT-relative relocs against any local sym or global sym
	     with DEF_REGULAR set, can be discarded.  At this point we
	     have not seen all the input files, so it is possible that
	     DEF_REGULAR is not set now but will be set later (it is
	     never cleared).  We account for that possibility below by
	     storing information in the dyn_relocs field of the
	     hash table entry.

	     A similar situation to the -Bsymbolic case occurs when
	     creating shared libraries and symbol visibility changes
	     render the symbol local.

	     As it turns out, all the relocs we will be creating here
	     are absolute, so we cannot remove them on -Bsymbolic
	     links or visibility changes anyway.  A STUB_REL reloc
	     is absolute too, as in that case it is the reloc in the
	     stub we will be creating, rather than copying the PCREL
	     reloc in the branch.

	     If on the other hand, we are creating an executable, we
	     may need to keep relocations for symbols satisfied by a
	     dynamic library if we manage to avoid copy relocs for the
	     symbol.  */
	  if ((info->shared
	       && (sec->flags & SEC_ALLOC) != 0
	       && (IS_ABSOLUTE_RELOC (r_type)
		   || (h != NULL
		       && (!info->symbolic
			   || h->elf.root.type == bfd_link_hash_defweak
			   || (h->elf.elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
		  && (sec->flags & SEC_ALLOC) != 0
		  && h != NULL
		  && (h->elf.root.type == bfd_link_hash_defweak
		      || (h->elf.elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)))
	    {
	      struct elf32_hppa_dyn_reloc_entry *p;
	      struct elf32_hppa_dyn_reloc_entry **head;

	      /* Create a reloc section in dynobj and make room for
		 this reloc.  */
	      if (sreloc == NULL)
		{
		  char *name;
		  bfd *dynobj;

		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
		  if (name == NULL)
		    {
		      (*_bfd_error_handler)
			(_("Could not find relocation section for %s"),
			 sec->name);
		      bfd_set_error (bfd_error_bad_value);
		      return FALSE;
		    }

		  if (htab->elf.dynobj == NULL)
		    htab->elf.dynobj = abfd;

		  dynobj = htab->elf.dynobj;
		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    {
		      flagword flags;

		      sreloc = bfd_make_section (dynobj, name);
		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		      if ((sec->flags & SEC_ALLOC) != 0)
			flags |= SEC_ALLOC | SEC_LOAD;
		      if (sreloc == NULL
			  || !bfd_set_section_flags (dynobj, sreloc, flags)
			  || !bfd_set_section_alignment (dynobj, sreloc, 2))
			return FALSE;
		    }

		  elf_section_data (sec)->sreloc = sreloc;
		}

	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (h != NULL)
		{
		  head = &h->dyn_relocs;
		}
	      else
		{
		  /* Track dynamic relocs needed for local syms too.
		     We really need local syms available to do this
		     easily.  Oh well.  */

		  asection *s;
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
		  if (s == NULL)
		    return FALSE;

		  head = ((struct elf32_hppa_dyn_reloc_entry **)
			  &elf_section_data (s)->local_dynrel);
		}

	      p = *head;
	      if (p == NULL || p->sec != sec)
		{
		  p = bfd_alloc (htab->elf.dynobj, sizeof *p);
		  if (p == NULL)
		    return FALSE;
		  p->next = *head;
		  *head = p;
		  p->sec = sec;
		  p->count = 0;
#if RELATIVE_DYNRELOCS
		  p->relative_count = 0;
#endif
		}

	      p->count += 1;
#if RELATIVE_DYNRELOCS
	      if (!IS_ABSOLUTE_RELOC (rtype))
		p->relative_count += 1;
#endif
	    }
	}
    }

  return TRUE;
}

/* Return the section that should be marked against garbage collection
   for a given relocation.  */

static asection *
elf32_hppa_gc_mark_hook (asection *sec,
			 struct bfd_link_info *info ATTRIBUTE_UNUSED,
			 Elf_Internal_Rela *rel,
			 struct elf_link_hash_entry *h,
			 Elf_Internal_Sym *sym)
{
  if (h != NULL)
    {
      switch ((unsigned int) ELF32_R_TYPE (rel->r_info))
	{
	case R_PARISC_GNU_VTINHERIT:
	case R_PARISC_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
}

/* Update the got and plt entry reference counts for the section being
   removed.  */

static bfd_boolean
elf32_hppa_gc_sweep_hook (bfd *abfd,
			  struct bfd_link_info *info ATTRIBUTE_UNUSED,
			  asection *sec,
			  const Elf_Internal_Rela *relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  bfd_signed_vma *local_plt_refcounts;
  const Elf_Internal_Rela *rel, *relend;

  elf_section_data (sec)->local_dynrel = NULL;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);
  local_plt_refcounts = local_got_refcounts;
  if (local_plt_refcounts != NULL)
    local_plt_refcounts += symtab_hdr->sh_info;

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h = NULL;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct elf32_hppa_link_hash_entry *eh;
	  struct elf32_hppa_dyn_reloc_entry **pp;
	  struct elf32_hppa_dyn_reloc_entry *p;

	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  eh = (struct elf32_hppa_link_hash_entry *) h;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}

      r_type = ELF32_R_TYPE (rel->r_info);
      switch (r_type)
	{
	case R_PARISC_DLTIND14F:
	case R_PARISC_DLTIND14R:
	case R_PARISC_DLTIND21L:
	  if (h != NULL)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;

	case R_PARISC_PCREL12F:
	case R_PARISC_PCREL17C:
	case R_PARISC_PCREL17F:
	case R_PARISC_PCREL22F:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  break;

	case R_PARISC_PLABEL14R:
	case R_PARISC_PLABEL21L:
	case R_PARISC_PLABEL32:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  else if (local_plt_refcounts != NULL)
	    {
	      if (local_plt_refcounts[r_symndx] > 0)
		local_plt_refcounts[r_symndx] -= 1;
	    }
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

/* Our own version of hide_symbol, so that we can keep plt entries for
   plabels.  */

static void
elf32_hppa_hide_symbol (struct bfd_link_info *info,
			struct elf_link_hash_entry *h,
			bfd_boolean force_local)
{
  if (force_local)
    {
      h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
      if (h->dynindx != -1)
	{
	  h->dynindx = -1;
	  _bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
				  h->dynstr_index);
	}
    }

  if (! ((struct elf32_hppa_link_hash_entry *) h)->plabel)
    {
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
      h->plt = elf_hash_table (info)->init_refcount;
    }
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
elf32_hppa_adjust_dynamic_symbol (struct bfd_link_info *info,
				  struct elf_link_hash_entry *h)
{
  struct elf32_hppa_link_hash_table *htab;
  asection *s;
  unsigned int power_of_two;

  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later.  */
  if (h->type == STT_FUNC
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
    {
      if (h->plt.refcount <= 0
	  || ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	      && h->root.type != bfd_link_hash_defweak
	      && ! ((struct elf32_hppa_link_hash_entry *) h)->plabel
	      && (!info->shared || info->symbolic)))
	{
	  /* The .plt entry is not needed when:
	     a) Garbage collection has removed all references to the
	     symbol, or
	     b) We know for certain the symbol is defined in this
	     object, and it's not a weak definition, nor is the symbol
	     used by a plabel relocation.  Either this object is the
	     application or we are doing a shared symbolic link.  */

	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	}

      return TRUE;
    }
  else
    h->plt.offset = (bfd_vma) -1;

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->weakdef != NULL)
    {
      if (h->weakdef->root.type != bfd_link_hash_defined
	  && h->weakdef->root.type != bfd_link_hash_defweak)
	abort ();
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
      if (ELIMINATE_COPY_RELOCS)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;

  /* If there are no references to this symbol that do not use the
     GOT, we don't need to generate a copy reloc.  */
  if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0)
    return TRUE;

  if (ELIMINATE_COPY_RELOCS)
    {
      struct elf32_hppa_link_hash_entry *eh;
      struct elf32_hppa_dyn_reloc_entry *p;

      eh = (struct elf32_hppa_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
    }

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */

  htab = hppa_link_hash_table (info);

  /* We must generate a COPY reloc to tell the dynamic linker to
     copy the initial value out of the dynamic object and into the
     runtime process image.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
    {
      htab->srelbss->_raw_size += sizeof (Elf32_External_Rela);
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
    }

  /* We need to figure out the alignment required for this symbol.  I
     have no idea how other ELF linkers handle this.  */

  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 3)
    power_of_two = 3;

  /* Apply the required alignment.  */
  s = htab->sdynbss;
  s->_raw_size = BFD_ALIGN (s->_raw_size,
			    (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (htab->elf.dynobj, s))
    {
      if (! bfd_set_section_alignment (htab->elf.dynobj, s, power_of_two))
	return FALSE;
    }

  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->_raw_size;

  /* Increment the section size to make room for the symbol.  */
  s->_raw_size += h->size;

  return TRUE;
}

/* Allocate space in the .plt for entries that won't have relocations.
   ie. plabel entries.  */

static bfd_boolean
allocate_plt_static (struct elf_link_hash_entry *h, void *inf)
{
  struct bfd_link_info *info;
  struct elf32_hppa_link_hash_table *htab;
  asection *s;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  info = inf;
  htab = hppa_link_hash_table (info);
  if (htab->elf.dynamic_sections_created
	   && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0
	  && h->type != STT_PARISC_MILLI)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared, h))
	{
	  /* Allocate these later.  From this point on, h->plabel
	     means that the plt entry is only used by a plabel.
	     We'll be using a normal plt entry for this symbol, so
	     clear the plabel indicator.  */
	  ((struct elf32_hppa_link_hash_entry *) h)->plabel = 0;
	}
      else if (((struct elf32_hppa_link_hash_entry *) h)->plabel)
	{
	  /* Make an entry in the .plt section for plabel references
	     that won't have a .plt entry for other reasons.  */
	  s = htab->splt;
	  h->plt.offset = s->_raw_size;
	  s->_raw_size += PLT_ENTRY_SIZE;
	}
      else
	{
	  /* No .plt entry needed.  */
	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
    }

  return TRUE;
}

/* Allocate space in .plt, .got and associated reloc sections for
   global syms.  */

static bfd_boolean
allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
{
  struct bfd_link_info *info;
  struct elf32_hppa_link_hash_table *htab;
  asection *s;
  struct elf32_hppa_link_hash_entry *eh;
  struct elf32_hppa_dyn_reloc_entry *p;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  info = inf;
  htab = hppa_link_hash_table (info);
  if (htab->elf.dynamic_sections_created
      && h->plt.offset != (bfd_vma) -1
      && !((struct elf32_hppa_link_hash_entry *) h)->plabel)
    {
      /* Make an entry in the .plt section.  */
      s = htab->splt;
      h->plt.offset = s->_raw_size;
      s->_raw_size += PLT_ENTRY_SIZE;

      /* We also need to make an entry in the .rela.plt section.  */
      htab->srelplt->_raw_size += sizeof (Elf32_External_Rela);
      htab->need_plt_stub = 1;
    }

  if (h->got.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0
	  && h->type != STT_PARISC_MILLI)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      s = htab->sgot;
      h->got.offset = s->_raw_size;
      s->_raw_size += GOT_ENTRY_SIZE;
      if (htab->elf.dynamic_sections_created
	  && (info->shared
	      || (h->dynindx != -1
		  && h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0))
	{
	  htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
	}
    }
  else
    h->got.offset = (bfd_vma) -1;

  eh = (struct elf32_hppa_link_hash_entry *) h;
  if (eh->dyn_relocs == NULL)
    return TRUE;

  /* If this is a -Bsymbolic shared link, then we need to discard all
     space allocated for dynamic pc-relative relocs against symbols
     defined in a regular object.  For the normal shared case, discard
     space for relocs that have become local due to symbol visibility
     changes.  */
  if (info->shared)
    {
#if RELATIVE_DYNRELOCS
      if (SYMBOL_CALLS_LOCAL (info, h))
	{
	  struct elf32_hppa_dyn_reloc_entry **pp;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      p->count -= p->relative_count;
	      p->relative_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}
#endif

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
    }
  else
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */
      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
	  && ((ELIMINATE_COPY_RELOCS
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	      || (htab->elf.dynamic_sections_created
		  && (h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined))))
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0
	      && h->type != STT_PARISC_MILLI)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}

      eh->dyn_relocs = NULL;
      return TRUE;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->sec)->sreloc;
      sreloc->_raw_size += p->count * sizeof (Elf32_External_Rela);
    }

  return TRUE;
}

/* This function is called via elf_link_hash_traverse to force
   millicode symbols local so they do not end up as globals in the
   dynamic symbol table.  We ought to be able to do this in
   adjust_dynamic_symbol, but our adjust_dynamic_symbol is not called
   for all dynamic symbols.  Arguably, this is a bug in
   elf_adjust_dynamic_symbol.  */

static bfd_boolean
clobber_millicode_symbols (struct elf_link_hash_entry *h,
			   struct bfd_link_info *info)
{
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->type == STT_PARISC_MILLI
      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
    {
      elf32_hppa_hide_symbol (info, h, TRUE);
    }
  return TRUE;
}

/* Find any dynamic relocs that apply to read-only sections.  */

static bfd_boolean
readonly_dynrelocs (struct elf_link_hash_entry *h, void *inf)
{
  struct elf32_hppa_link_hash_entry *eh;
  struct elf32_hppa_dyn_reloc_entry *p;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  eh = (struct elf32_hppa_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *s = p->sec->output_section;

      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	{
	  struct bfd_link_info *info = inf;

	  info->flags |= DF_TEXTREL;

	  /* Not an error, just cut short the traversal.  */
	  return FALSE;
	}
    }
  return TRUE;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
elf32_hppa_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				  struct bfd_link_info *info)
{
  struct elf32_hppa_link_hash_table *htab;
  bfd *dynobj;
  bfd *ibfd;
  asection *s;
  bfd_boolean relocs;

  htab = hppa_link_hash_table (info);
  dynobj = htab->elf.dynobj;
  if (dynobj == NULL)
    abort ();

  if (htab->elf.dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable && !info->static_link)
	{
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  if (s == NULL)
	    abort ();
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}

      /* Force millicode symbols local.  */
      elf_link_hash_traverse (&htab->elf,
			      clobber_millicode_symbols,
			      info);
    }

  /* Set up .got and .plt offsets for local syms, and space for local
     dynamic relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      bfd_signed_vma *local_plt;
      bfd_signed_vma *end_local_plt;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;

      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
	continue;

      for (s = ibfd->sections; s != NULL; s = s->next)
	{
	  struct elf32_hppa_dyn_reloc_entry *p;

	  for (p = ((struct elf32_hppa_dyn_reloc_entry *)
		    elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
	    {
	      if (!bfd_is_abs_section (p->sec)
		  && bfd_is_abs_section (p->sec->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (p->count != 0)
		{
		  srel = elf_section_data (p->sec)->sreloc;
		  srel->_raw_size += p->count * sizeof (Elf32_External_Rela);
		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
		    info->flags |= DF_TEXTREL;
		}
	    }
	}

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      s = htab->sgot;
      srel = htab->srelgot;
      for (; local_got < end_local_got; ++local_got)
	{
	  if (*local_got > 0)
	    {
	      *local_got = s->_raw_size;
	      s->_raw_size += GOT_ENTRY_SIZE;
	      if (info->shared)
		srel->_raw_size += sizeof (Elf32_External_Rela);
	    }
	  else
	    *local_got = (bfd_vma) -1;
	}

      local_plt = end_local_got;
      end_local_plt = local_plt + locsymcount;
      if (! htab->elf.dynamic_sections_created)
	{
	  /* Won't be used, but be safe.  */
	  for (; local_plt < end_local_plt; ++local_plt)
	    *local_plt = (bfd_vma) -1;
	}
      else
	{
	  s = htab->splt;
	  srel = htab->srelplt;
	  for (; local_plt < end_local_plt; ++local_plt)
	    {
	      if (*local_plt > 0)
		{
		  *local_plt = s->_raw_size;
		  s->_raw_size += PLT_ENTRY_SIZE;
		  if (info->shared)
		    srel->_raw_size += sizeof (Elf32_External_Rela);
		}
	      else
		*local_plt = (bfd_vma) -1;
	    }
	}
    }

  /* Do all the .plt entries without relocs first.  The dynamic linker
     uses the last .plt reloc to find the end of the .plt (and hence
     the start of the .got) for lazy linking.  */
  elf_link_hash_traverse (&htab->elf, allocate_plt_static, info);

  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, info);

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  relocs = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      if (s == htab->splt)
	{
	  if (htab->need_plt_stub)
	    {
	      /* Make space for the plt stub at the end of the .plt
		 section.  We want this stub right at the end, up
		 against the .got section.  */
	      int gotalign = bfd_section_alignment (dynobj, htab->sgot);
	      int pltalign = bfd_section_alignment (dynobj, s);
	      bfd_size_type mask;

	      if (gotalign > pltalign)
		bfd_set_section_alignment (dynobj, s, gotalign);
	      mask = ((bfd_size_type) 1 << gotalign) - 1;
	      s->_raw_size = (s->_raw_size + sizeof (plt_stub) + mask) & ~mask;
	    }
	}
      else if (s == htab->sgot)
	;
      else if (strncmp (bfd_get_section_name (dynobj, s), ".rela", 5) == 0)
	{
	  if (s->_raw_size != 0)
	    {
	      /* Remember whether there are any reloc sections other
		 than .rela.plt.  */
	      if (s != htab->srelplt)
		relocs = TRUE;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (s->_raw_size == 0)
	{
	  /* If we don't need this section, strip it from the
	     output file.  This is mostly to handle .rela.bss and
	     .rela.plt.  We must create both sections in
	     create_dynamic_sections, because they must be created
	     before the linker maps input sections to output
	     sections.  The linker does that before
	     adjust_dynamic_symbol is called, and it is that
	     function which decides whether anything needs to go
	     into these sections.  */
	  _bfd_strip_section_from_output (info, s);
	  continue;
	}

      /* Allocate memory for the section contents.  Zero it, because
	 we may not fill in all the reloc sections.  */
      s->contents = bfd_zalloc (dynobj, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
	return FALSE;
    }

  if (htab->elf.dynamic_sections_created)
    {
      /* Like IA-64 and HPPA64, always create a DT_PLTGOT.  It
	 actually has nothing to do with the PLT, it is how we
	 communicate the LTP value of a load module to the dynamic
	 linker.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

      if (!add_dynamic_entry (DT_PLTGOT, 0))
	return FALSE;

      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf32_hppa_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
      if (info->executable)
	{
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}

      if (htab->srelplt->_raw_size != 0)
	{
	  if (!add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
	}

      if (relocs)
	{
	  if (!add_dynamic_entry (DT_RELA, 0)
	      || !add_dynamic_entry (DT_RELASZ, 0)
	      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))
	    return FALSE;

	  /* If any dynamic relocs apply to a read-only section,
	     then we need a DT_TEXTREL entry.  */
	  if ((info->flags & DF_TEXTREL) == 0)
	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs, info);

	  if ((info->flags & DF_TEXTREL) != 0)
	    {
	      if (!add_dynamic_entry (DT_TEXTREL, 0))
		return FALSE;
	    }
	}
    }
#undef add_dynamic_entry

  return TRUE;
}

/* External entry points for sizing and building linker stubs.  */

/* Set up various things so that we can make a list of input sections
   for each output section included in the link.  Returns -1 on error,
   0 when no stubs will be needed, and 1 on success.  */

int
elf32_hppa_setup_section_lists (bfd *output_bfd, struct bfd_link_info *info)
{
  bfd *input_bfd;
  unsigned int bfd_count;
  int top_id, top_index;
  asection *section;
  asection **input_list, **list;
  bfd_size_type amt;
  struct elf32_hppa_link_hash_table *htab = hppa_link_hash_table (info);

  /* Count the number of input BFDs and find the top input section id.  */
  for (input_bfd = info->input_bfds, bfd_count = 0, top_id = 0;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next)
    {
      bfd_count += 1;
      for (section = input_bfd->sections;
	   section != NULL;
	   section = section->next)
	{
	  if (top_id < section->id)
	    top_id = section->id;
	}
    }
  htab->bfd_count = bfd_count;

  amt = sizeof (struct map_stub) * (top_id + 1);
  htab->stub_group = bfd_zmalloc (amt);
  if (htab->stub_group == NULL)
    return -1;

  /* We can't use output_bfd->section_count here to find the top output
     section index as some sections may have been removed, and
     _bfd_strip_section_from_output doesn't renumber the indices.  */
  for (section = output_bfd->sections, top_index = 0;
       section != NULL;
       section = section->next)
    {
      if (top_index < section->index)
	top_index = section->index;
    }

  htab->top_index = top_index;
  amt = sizeof (asection *) * (top_index + 1);
  input_list = bfd_malloc (amt);
  htab->input_list = input_list;
  if (input_list == NULL)
    return -1;

  /* For sections we aren't interested in, mark their entries with a
     value we can check later.  */
  list = input_list + top_index;
  do
    *list = bfd_abs_section_ptr;
  while (list-- != input_list);

  for (section = output_bfd->sections;
       section != NULL;
       section = section->next)
    {
      if ((section->flags & SEC_CODE) != 0)
	input_list[section->index] = NULL;
    }

  return 1;
}

/* The linker repeatedly calls this function for each input section,
   in the order that input sections are linked into output sections.
   Build lists of input sections to determine groupings between which
   we may insert linker stubs.  */

void
elf32_hppa_next_input_section (struct bfd_link_info *info, asection *isec)
{
  struct elf32_hppa_link_hash_table *htab = hppa_link_hash_table (info);

  if (isec->output_section->index <= htab->top_index)
    {
      asection **list = htab->input_list + isec->output_section->index;
      if (*list != bfd_abs_section_ptr)
	{
	  /* Steal the link_sec pointer for our list.  */
#define PREV_SEC(sec) (htab->stub_group[(sec)->id].link_sec)
	  /* This happens to make the list in reverse order,
	     which is what we want.  */
	  PREV_SEC (isec) = *list;
	  *list = isec;
	}
    }
}

/* See whether we can group stub sections together.  Grouping stub
   sections may result in fewer stubs.  More importantly, we need to
   put all .init* and .fini* stubs at the beginning of the .init or
   .fini output sections respectively, because glibc splits the
   _init and _fini functions into multiple parts.  Putting a stub in
   the middle of a function is not a good idea.  */

static void
group_sections (struct elf32_hppa_link_hash_table *htab,
		bfd_size_type stub_group_size,
		bfd_boolean stubs_always_before_branch)
{
  asection **list = htab->input_list + htab->top_index;
  do
    {
      asection *tail = *list;
      if (tail == bfd_abs_section_ptr)
	continue;
      while (tail != NULL)
	{
	  asection *curr;
	  asection *prev;
	  bfd_size_type total;
	  bfd_boolean big_sec;

	  curr = tail;
	  if (tail->_cooked_size)
	    total = tail->_cooked_size;
	  else
	    total = tail->_raw_size;
	  big_sec = total >= stub_group_size;

	  while ((prev = PREV_SEC (curr)) != NULL
		 && ((total += curr->output_offset - prev->output_offset)
		     < stub_group_size))
	    curr = prev;

	  /* OK, the size from the start of CURR to the end is less
	     than 240000 bytes and thus can be handled by one stub
	     section.  (or the tail section is itself larger than
	     240000 bytes, in which case we may be toast.)
	     We should really be keeping track of the total size of
	     stubs added here, as stubs contribute to the final output
	     section size.  That's a little tricky, and this way will
	     only break if stubs added total more than 22144 bytes, or
	     2768 long branch stubs.  It seems unlikely for more than
	     2768 different functions to be called, especially from
	     code only 240000 bytes long.  This limit used to be
	     250000, but c++ code tends to generate lots of little
	     functions, and sometimes violated the assumption.  */
	  do
	    {
	      prev = PREV_SEC (tail);
	      /* Set up this stub group.  */
	      htab->stub_group[tail->id].link_sec = curr;
	    }
	  while (tail != curr && (tail = prev) != NULL);

	  /* But wait, there's more!  Input sections up to 240000
	     bytes before the stub section can be handled by it too.
	     Don't do this if we have a really large section after the
	     stubs, as adding more stubs increases the chance that
	     branches may not reach into the stub section.  */
	  if (!stubs_always_before_branch && !big_sec)
	    {
	      total = 0;
	      while (prev != NULL
		     && ((total += tail->output_offset - prev->output_offset)
			 < stub_group_size))
		{
		  tail = prev;
		  prev = PREV_SEC (tail);
		  htab->stub_group[tail->id].link_sec = curr;
		}
	    }
	  tail = prev;
	}
    }
  while (list-- != htab->input_list);
  free (htab->input_list);
#undef PREV_SEC
}

/* Read in all local syms for all input bfds, and create hash entries
   for export stubs if we are building a multi-subspace shared lib.
   Returns -1 on error, 1 if export stubs created, 0 otherwise.  */

static int
get_local_syms (bfd *output_bfd, bfd *input_bfd, struct bfd_link_info *info)
{
  unsigned int bfd_indx;
  Elf_Internal_Sym *local_syms, **all_local_syms;
  int stub_changed = 0;
  struct elf32_hppa_link_hash_table *htab = hppa_link_hash_table (info);

  /* We want to read in symbol extension records only once.  To do this
     we need to read in the local symbols in parallel and save them for
     later use; so hold pointers to the local symbols in an array.  */
  bfd_size_type amt = sizeof (Elf_Internal_Sym *) * htab->bfd_count;
  all_local_syms = bfd_zmalloc (amt);
  htab->all_local_syms = all_local_syms;
  if (all_local_syms == NULL)
    return -1;

  /* Walk over all the input BFDs, swapping in local symbols.
     If we are creating a shared library, create hash entries for the
     export stubs.  */
  for (bfd_indx = 0;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next, bfd_indx++)
    {
      Elf_Internal_Shdr *symtab_hdr;

      /* We'll need the symbol table in a second.  */
      symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
      if (symtab_hdr->sh_info == 0)
	continue;

      /* We need an array of the local symbols attached to the input bfd.  */
      local_syms = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (local_syms == NULL)
	{
	  local_syms = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
					     symtab_hdr->sh_info, 0,
					     NULL, NULL, NULL);
	  /* Cache them for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) local_syms;
	}
      if (local_syms == NULL)
	return -1;

      all_local_syms[bfd_indx] = local_syms;

      if (info->shared && htab->multi_subspace)
	{
	  struct elf_link_hash_entry **sym_hashes;
	  struct elf_link_hash_entry **end_hashes;
	  unsigned int symcount;

	  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
		      - symtab_hdr->sh_info);
	  sym_hashes = elf_sym_hashes (input_bfd);
	  end_hashes = sym_hashes + symcount;

	  /* Look through the global syms for functions;  We need to
	     build export stubs for all globally visible functions.  */
	  for (; sym_hashes < end_hashes; sym_hashes++)
	    {
	      struct elf32_hppa_link_hash_entry *hash;

	      hash = (struct elf32_hppa_link_hash_entry *) *sym_hashes;

	      while (hash->elf.root.type == bfd_link_hash_indirect
		     || hash->elf.root.type == bfd_link_hash_warning)
		hash = ((struct elf32_hppa_link_hash_entry *)
			hash->elf.root.u.i.link);

	      /* At this point in the link, undefined syms have been
		 resolved, so we need to check that the symbol was
		 defined in this BFD.  */
	      if ((hash->elf.root.type == bfd_link_hash_defined
		   || hash->elf.root.type == bfd_link_hash_defweak)
		  && hash->elf.type == STT_FUNC
		  && hash->elf.root.u.def.section->output_section != NULL
		  && (hash->elf.root.u.def.section->output_section->owner
		      == output_bfd)
		  && hash->elf.root.u.def.section->owner == input_bfd
		  && (hash->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
		  && !(hash->elf.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
		  && ELF_ST_VISIBILITY (hash->elf.other) == STV_DEFAULT)
		{
		  asection *sec;
		  const char *stub_name;
		  struct elf32_hppa_stub_hash_entry *stub_entry;

		  sec = hash->elf.root.u.def.section;
		  stub_name = hash->elf.root.root.string;
		  stub_entry = hppa_stub_hash_lookup (&htab->stub_hash_table,
						      stub_name,
						      FALSE, FALSE);
		  if (stub_entry == NULL)
		    {
		      stub_entry = hppa_add_stub (stub_name, sec, htab);
		      if (!stub_entry)
			return -1;

		      stub_entry->target_value = hash->elf.root.u.def.value;
		      stub_entry->target_section = hash->elf.root.u.def.section;
		      stub_entry->stub_type = hppa_stub_export;
		      stub_entry->h = hash;
		      stub_changed = 1;
		    }
		  else
		    {
		      (*_bfd_error_handler) (_("%s: duplicate export stub %s"),
					     bfd_archive_filename (input_bfd),
					     stub_name);
		    }
		}
	    }
	}
    }

  return stub_changed;
}

/* Determine and set the size of the stub section for a final link.

   The basic idea here is to examine all the relocations looking for
   PC-relative calls to a target that is unreachable with a "bl"
   instruction.  */

bfd_boolean
elf32_hppa_size_stubs
  (bfd *output_bfd, bfd *stub_bfd, struct bfd_link_info *info,
   bfd_boolean multi_subspace, bfd_signed_vma group_size,
   asection * (*add_stub_section) (const char *, asection *),
   void (*layout_sections_again) (void))
{
  bfd_size_type stub_group_size;
  bfd_boolean stubs_always_before_branch;
  bfd_boolean stub_changed;
  struct elf32_hppa_link_hash_table *htab = hppa_link_hash_table (info);

  /* Stash our params away.  */
  htab->stub_bfd = stub_bfd;
  htab->multi_subspace = multi_subspace;
  htab->add_stub_section = add_stub_section;
  htab->layout_sections_again = layout_sections_again;
  stubs_always_before_branch = group_size < 0;
  if (group_size < 0)
    stub_group_size = -group_size;
  else
    stub_group_size = group_size;
  if (stub_group_size == 1)
    {
      /* Default values.  */
      if (stubs_always_before_branch)
	{
	  stub_group_size = 7680000;
	  if (htab->has_17bit_branch || htab->multi_subspace)
	    stub_group_size = 240000;
	  if (htab->has_12bit_branch)
	    stub_group_size = 7500;
	}
      else
	{
	  stub_group_size = 6971392;
	  if (htab->has_17bit_branch || htab->multi_subspace)
	    stub_group_size = 217856;
	  if (htab->has_12bit_branch)
	    stub_group_size = 6808;
	}
    }

  group_sections (htab, stub_group_size, stubs_always_before_branch);

  switch (get_local_syms (output_bfd, info->input_bfds, info))
    {
    default:
      if (htab->all_local_syms)
	goto error_ret_free_local;
      return FALSE;

    case 0:
      stub_changed = FALSE;
      break;

    case 1:
      stub_changed = TRUE;
      break;
    }

  while (1)
    {
      bfd *input_bfd;
      unsigned int bfd_indx;
      asection *stub_sec;

      for (input_bfd = info->input_bfds, bfd_indx = 0;
	   input_bfd != NULL;
	   input_bfd = input_bfd->link_next, bfd_indx++)
	{
	  Elf_Internal_Shdr *symtab_hdr;
	  asection *section;
	  Elf_Internal_Sym *local_syms;

	  /* We'll need the symbol table in a second.  */
	  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
	  if (symtab_hdr->sh_info == 0)
	    continue;

	  local_syms = htab->all_local_syms[bfd_indx];

	  /* Walk over each section attached to the input bfd.  */
	  for (section = input_bfd->sections;
	       section != NULL;
	       section = section->next)
	    {
	      Elf_Internal_Rela *internal_relocs, *irelaend, *irela;

	      /* If there aren't any relocs, then there's nothing more
		 to do.  */
	      if ((section->flags & SEC_RELOC) == 0
		  || section->reloc_count == 0)
		continue;

	      /* If this section is a link-once section that will be
		 discarded, then don't create any stubs.  */
	      if (section->output_section == NULL
		  || section->output_section->owner != output_bfd)
		continue;

	      /* Get the relocs.  */
	      internal_relocs
		= _bfd_elf_link_read_relocs (input_bfd, section, NULL, NULL,
					     info->keep_memory);
	      if (internal_relocs == NULL)
		goto error_ret_free_local;

	      /* Now examine each relocation.  */
	      irela = internal_relocs;
	      irelaend = irela + section->reloc_count;
	      for (; irela < irelaend; irela++)
		{
		  unsigned int r_type, r_indx;
		  enum elf32_hppa_stub_type stub_type;
		  struct elf32_hppa_stub_hash_entry *stub_entry;
		  asection *sym_sec;
		  bfd_vma sym_value;
		  bfd_vma destination;
		  struct elf32_hppa_link_hash_entry *hash;
		  char *stub_name;
		  const asection *id_sec;

		  r_type = ELF32_R_TYPE (irela->r_info);
		  r_indx = ELF32_R_SYM (irela->r_info);

		  if (r_type >= (unsigned int) R_PARISC_UNIMPLEMENTED)
		    {
		      bfd_set_error (bfd_error_bad_value);
		    error_ret_free_internal:
		      if (elf_section_data (section)->relocs == NULL)
			free (internal_relocs);
		      goto error_ret_free_local;
		    }

		  /* Only look for stubs on call instructions.  */
		  if (r_type != (unsigned int) R_PARISC_PCREL12F
		      && r_type != (unsigned int) R_PARISC_PCREL17F
		      && r_type != (unsigned int) R_PARISC_PCREL22F)
		    continue;

		  /* Now determine the call target, its name, value,
		     section.  */
		  sym_sec = NULL;
		  sym_value = 0;
		  destination = 0;
		  hash = NULL;
		  if (r_indx < symtab_hdr->sh_info)
		    {
		      /* It's a local symbol.  */
		      Elf_Internal_Sym *sym;
		      Elf_Internal_Shdr *hdr;

		      sym = local_syms + r_indx;
		      hdr = elf_elfsections (input_bfd)[sym->st_shndx];
		      sym_sec = hdr->bfd_section;
		      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
			sym_value = sym->st_value;
		      destination = (sym_value + irela->r_addend
				     + sym_sec->output_offset
				     + sym_sec->output_section->vma);
		    }
		  else
		    {
		      /* It's an external symbol.  */
		      int e_indx;

		      e_indx = r_indx - symtab_hdr->sh_info;
		      hash = ((struct elf32_hppa_link_hash_entry *)
			      elf_sym_hashes (input_bfd)[e_indx]);

		      while (hash->elf.root.type == bfd_link_hash_indirect
			     || hash->elf.root.type == bfd_link_hash_warning)
			hash = ((struct elf32_hppa_link_hash_entry *)
				hash->elf.root.u.i.link);

		      if (hash->elf.root.type == bfd_link_hash_defined
			  || hash->elf.root.type == bfd_link_hash_defweak)
			{
			  sym_sec = hash->elf.root.u.def.section;
			  sym_value = hash->elf.root.u.def.value;
			  if (sym_sec->output_section != NULL)
			    destination = (sym_value + irela->r_addend
					   + sym_sec->output_offset
					   + sym_sec->output_section->vma);
			}
		      else if (hash->elf.root.type == bfd_link_hash_undefweak)
			{
			  if (! info->shared)
			    continue;
			}
		      else if (hash->elf.root.type == bfd_link_hash_undefined)
			{
			  if (! (info->unresolved_syms_in_objects == RM_IGNORE
				 && (ELF_ST_VISIBILITY (hash->elf.other)
				     == STV_DEFAULT)
				 && hash->elf.type != STT_PARISC_MILLI))
			    continue;
			}
		      else
			{
			  bfd_set_error (bfd_error_bad_value);
			  goto error_ret_free_internal;
			}
		    }

		  /* Determine what (if any) linker stub is needed.  */
		  stub_type = hppa_type_of_stub (section, irela, hash,
						 destination, info);
		  if (stub_type == hppa_stub_none)
		    continue;

		  /* Support for grouping stub sections.  */
		  id_sec = htab->stub_group[section->id].link_sec;

		  /* Get the name of this stub.  */
		  stub_name = hppa_stub_name (id_sec, sym_sec, hash, irela);
		  if (!stub_name)
		    goto error_ret_free_internal;

		  stub_entry = hppa_stub_hash_lookup (&htab->stub_hash_table,
						      stub_name,
						      FALSE, FALSE);
		  if (stub_entry != NULL)
		    {
		      /* The proper stub has already been created.  */
		      free (stub_name);
		      continue;
		    }

		  stub_entry = hppa_add_stub (stub_name, section, htab);
		  if (stub_entry == NULL)
		    {
		      free (stub_name);
		      goto error_ret_free_internal;
		    }

		  stub_entry->target_value = sym_value;
		  stub_entry->target_section = sym_sec;
		  stub_entry->stub_type = stub_type;
		  if (info->shared)
		    {
		      if (stub_type == hppa_stub_import)
			stub_entry->stub_type = hppa_stub_import_shared;
		      else if (stub_type == hppa_stub_long_branch)
			stub_entry->stub_type = hppa_stub_long_branch_shared;
		    }
		  stub_entry->h = hash;
		  stub_changed = TRUE;
		}

	      /* We're done with the internal relocs, free them.  */
	      if (elf_section_data (section)->relocs == NULL)
		free (internal_relocs);
	    }
	}

      if (!stub_changed)
	break;

      /* OK, we've added some stubs.  Find out the new size of the
	 stub sections.  */
      for (stub_sec = htab->stub_bfd->sections;
	   stub_sec != NULL;
	   stub_sec = stub_sec->next)
	{
	  stub_sec->_raw_size = 0;
	  stub_sec->_cooked_size = 0;
	}

      bfd_hash_traverse (&htab->stub_hash_table, hppa_size_one_stub, htab);

      /* Ask the linker to do its stuff.  */
      (*htab->layout_sections_again) ();
      stub_changed = FALSE;
    }

  free (htab->all_local_syms);
  return TRUE;

 error_ret_free_local:
  free (htab->all_local_syms);
  return FALSE;
}

/* For a final link, this function is called after we have sized the
   stubs to provide a value for __gp.  */

bfd_boolean
elf32_hppa_set_gp (bfd *abfd, struct bfd_link_info *info)
{
  struct bfd_link_hash_entry *h;
  asection *sec = NULL;
  bfd_vma gp_val = 0;
  struct elf32_hppa_link_hash_table *htab;

  htab = hppa_link_hash_table (info);
  h = bfd_link_hash_lookup (&htab->elf.root, "$global$", FALSE, FALSE, FALSE);

  if (h != NULL
      && (h->type == bfd_link_hash_defined
	  || h->type == bfd_link_hash_defweak))
    {
      gp_val = h->u.def.value;
      sec = h->u.def.section;
    }
  else
    {
      asection *splt = bfd_get_section_by_name (abfd, ".plt");
      asection *sgot = bfd_get_section_by_name (abfd, ".got");

      /* Choose to point our LTP at, in this order, one of .plt, .got,
	 or .data, if these sections exist.  In the case of choosing
	 .plt try to make the LTP ideal for addressing anywhere in the
	 .plt or .got with a 14 bit signed offset.  Typically, the end
	 of the .plt is the start of the .got, so choose .plt + 0x2000
	 if either the .plt or .got is larger than 0x2000.  If both
	 the .plt and .got are smaller than 0x2000, choose the end of
	 the .plt section.  */
      sec = splt;
      if (sec != NULL)
	{
	  gp_val = sec->_raw_size;
	  if (gp_val > 0x2000 || (sgot && sgot->_raw_size > 0x2000))
	    {
	      gp_val = 0x2000;
	    }
	}
      else
	{
	  sec = sgot;
	  if (sec != NULL)
	    {
	      /* We know we don't have a .plt.  If .got is large,
		 offset our LTP.  */
	      if (sec->_raw_size > 0x2000)
		gp_val = 0x2000;
	    }
	  else
	    {
	      /* No .plt or .got.  Who cares what the LTP is?  */
	      sec = bfd_get_section_by_name (abfd, ".data");
	    }
	}

      if (h != NULL)
	{
	  h->type = bfd_link_hash_defined;
	  h->u.def.value = gp_val;
	  if (sec != NULL)
	    h->u.def.section = sec;
	  else
	    h->u.def.section = bfd_abs_section_ptr;
	}
    }

  if (sec != NULL && sec->output_section != NULL)
    gp_val += sec->output_section->vma + sec->output_offset;

  elf_gp (abfd) = gp_val;
  return TRUE;
}

/* Build all the stubs associated with the current output file.  The
   stubs are kept in a hash table attached to the main linker hash
   table.  We also set up the .plt entries for statically linked PIC
   functions here.  This function is called via hppaelf_finish in the
   linker.  */

bfd_boolean
elf32_hppa_build_stubs (struct bfd_link_info *info)
{
  asection *stub_sec;
  struct bfd_hash_table *table;
  struct elf32_hppa_link_hash_table *htab;

  htab = hppa_link_hash_table (info);

  for (stub_sec = htab->stub_bfd->sections;
       stub_sec != NULL;
       stub_sec = stub_sec->next)
    {
      bfd_size_type size;

      /* Allocate memory to hold the linker stubs.  */
      size = stub_sec->_raw_size;
      stub_sec->contents = bfd_zalloc (htab->stub_bfd, size);
      if (stub_sec->contents == NULL && size != 0)
	return FALSE;
      stub_sec->_raw_size = 0;
    }

  /* Build the stubs as directed by the stub hash table.  */
  table = &htab->stub_hash_table;
  bfd_hash_traverse (table, hppa_build_one_stub, info);

  return TRUE;
}

/* Perform a final link.  */

static bfd_boolean
elf32_hppa_final_link (bfd *abfd, struct bfd_link_info *info)
{
  /* Invoke the regular ELF linker to do all the work.  */
  if (!bfd_elf_final_link (abfd, info))
    return FALSE;

  /* If we're producing a final executable, sort the contents of the
     unwind section.  */
  return elf_hppa_sort_unwind (abfd);
}

/* Record the lowest address for the data and text segments.  */

static void
hppa_record_segment_addr (bfd *abfd ATTRIBUTE_UNUSED,
			  asection *section,
			  void *data)
{
  struct elf32_hppa_link_hash_table *htab;

  htab = (struct elf32_hppa_link_hash_table *) data;

  if ((section->flags & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
    {
      bfd_vma value = section->vma - section->filepos;

      if ((section->flags & SEC_READONLY) != 0)
	{
	  if (value < htab->text_segment_base)
	    htab->text_segment_base = value;
	}
      else
	{
	  if (value < htab->data_segment_base)
	    htab->data_segment_base = value;
	}
    }
}

/* Perform a relocation as part of a final link.  */

static bfd_reloc_status_type
final_link_relocate (asection *input_section,
		     bfd_byte *contents,
		     const Elf_Internal_Rela *rel,
		     bfd_vma value,
		     struct elf32_hppa_link_hash_table *htab,
		     asection *sym_sec,
		     struct elf32_hppa_link_hash_entry *h,
		     struct bfd_link_info *info)
{
  int insn;
  unsigned int r_type = ELF32_R_TYPE (rel->r_info);
  unsigned int orig_r_type = r_type;
  reloc_howto_type *howto = elf_hppa_howto_table + r_type;
  int r_format = howto->bitsize;
  enum hppa_reloc_field_selector_type_alt r_field;
  bfd *input_bfd = input_section->owner;
  bfd_vma offset = rel->r_offset;
  bfd_vma max_branch_offset = 0;
  bfd_byte *hit_data = contents + offset;
  bfd_signed_vma addend = rel->r_addend;
  bfd_vma location;
  struct elf32_hppa_stub_hash_entry *stub_entry = NULL;
  int val;

  if (r_type == R_PARISC_NONE)
    return bfd_reloc_ok;

  insn = bfd_get_32 (input_bfd, hit_data);

  /* Find out where we are and where we're going.  */
  location = (offset +
	      input_section->output_offset +
	      input_section->output_section->vma);

  /* If we are not building a shared library, convert DLTIND relocs to
     DPREL relocs.  */
  if (!info->shared)
    {
      switch (r_type)
	{
	  case R_PARISC_DLTIND21L:
	    r_type = R_PARISC_DPREL21L;
	    break;

	  case R_PARISC_DLTIND14R:
	    r_type = R_PARISC_DPREL14R;
	    break;

	  case R_PARISC_DLTIND14F:
	    r_type = R_PARISC_DPREL14F;
	    break;
	}
    }

  switch (r_type)
    {
    case R_PARISC_PCREL12F:
    case R_PARISC_PCREL17F:
    case R_PARISC_PCREL22F:
      /* If this call should go via the plt, find the import stub in
	 the stub hash.  */
      if (sym_sec == NULL
	  || sym_sec->output_section == NULL
	  || (h != NULL
	      && h->elf.plt.offset != (bfd_vma) -1
	      && h->elf.dynindx != -1
	      && !h->plabel
	      && (info->shared
		  || !(h->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
		  || h->elf.root.type == bfd_link_hash_defweak)))
	{
	  stub_entry = hppa_get_stub_entry (input_section, sym_sec,
					    h, rel, htab);
	  if (stub_entry != NULL)
	    {
	      value = (stub_entry->stub_offset
		       + stub_entry->stub_sec->output_offset
		       + stub_entry->stub_sec->output_section->vma);
	      addend = 0;
	    }
	  else if (sym_sec == NULL && h != NULL
		   && h->elf.root.type == bfd_link_hash_undefweak)
	    {
	      /* It's OK if undefined weak.  Calls to undefined weak
		 symbols behave as if the "called" function
		 immediately returns.  We can thus call to a weak
		 function without first checking whether the function
		 is defined.  */
	      value = location;
	      addend = 8;
	    }
	  else
	    return bfd_reloc_undefined;
	}
      /* Fall thru.  */

    case R_PARISC_PCREL21L:
    case R_PARISC_PCREL17C:
    case R_PARISC_PCREL17R:
    case R_PARISC_PCREL14R:
    case R_PARISC_PCREL14F:
    case R_PARISC_PCREL32:
      /* Make it a pc relative offset.  */
      value -= location;
      addend -= 8;
      break;

    case R_PARISC_DPREL21L:
    case R_PARISC_DPREL14R:
    case R_PARISC_DPREL14F:
      /* Convert instructions that use the linkage table pointer (r19) to
	 instructions that use the global data pointer (dp).  This is the
	 most efficient way of using PIC code in an incomplete executable,
	 but the user must follow the standard runtime conventions for
	 accessing data for this to work.  */
      if (orig_r_type == R_PARISC_DLTIND21L)
	{
	  /* Convert addil instructions if the original reloc was a
	     DLTIND21L.  GCC sometimes uses a register other than r19 for
	     the operation, so we must convert any addil instruction
	     that uses this relocation.  */
	  if ((insn & 0xfc000000) == ((int) OP_ADDIL << 26))
	    insn = ADDIL_DP;
	  else
	    /* We must have a ldil instruction.  It's too hard to find
	       and convert the associated add instruction, so issue an
	       error.  */
	    (*_bfd_error_handler)
	      (_("%s(%s+0x%lx): %s fixup for insn 0x%x is not supported in a non-shared link"),
	       bfd_archive_filename (input_bfd),
	       input_section->name,
	       (long) rel->r_offset,
	       howto->name,
	       insn);
	}
      else if (orig_r_type == R_PARISC_DLTIND14F)
	{
	  /* This must be a format 1 load/store.  Change the base
	     register to dp.  */
	  insn = (insn & 0xfc1ffff) | (27 << 21);
	}

    /* For all the DP relative relocations, we need to examine the symbol's
       section.  If it has no section or if it's a code section, then
       "data pointer relative" makes no sense.  In that case we don't
       adjust the "value", and for 21 bit addil instructions, we change the
       source addend register from %dp to %r0.  This situation commonly
       arises for undefined weak symbols and when a variable's "constness"
       is declared differently from the way the variable is defined.  For
       instance: "extern int foo" with foo defined as "const int foo".  */
      if (sym_sec == NULL || (sym_sec->flags & SEC_CODE) != 0)
	{
	  if ((insn & ((0x3f << 26) | (0x1f << 21)))
	      == (((int) OP_ADDIL << 26) | (27 << 21)))
	    {
	      insn &= ~ (0x1f << 21);
#if 0 /* debug them.  */
	      (*_bfd_error_handler)
		(_("%s(%s+0x%lx): fixing %s"),
		 bfd_archive_filename (input_bfd),
		 input_section->name,
		 (long) rel->r_offset,
		 howto->name);
#endif
	    }
	  /* Now try to make things easy for the dynamic linker.  */

	  break;
	}
      /* Fall thru.  */

    case R_PARISC_DLTIND21L:
    case R_PARISC_DLTIND14R:
    case R_PARISC_DLTIND14F:
      value -= elf_gp (input_section->output_section->owner);
      break;

    case R_PARISC_SEGREL32:
      if ((sym_sec->flags & SEC_CODE) != 0)
	value -= htab->text_segment_base;
      else
	value -= htab->data_segment_base;
      break;

    default:
      break;
    }

  switch (r_type)
    {
    case R_PARISC_DIR32:
    case R_PARISC_DIR14F:
    case R_PARISC_DIR17F:
    case R_PARISC_PCREL17C:
    case R_PARISC_PCREL14F:
    case R_PARISC_PCREL32:
    case R_PARISC_DPREL14F:
    case R_PARISC_PLABEL32:
    case R_PARISC_DLTIND14F:
    case R_PARISC_SEGBASE:
    case R_PARISC_SEGREL32:
      r_field = e_fsel;
      break;

    case R_PARISC_DLTIND21L:
    case R_PARISC_PCREL21L:
    case R_PARISC_PLABEL21L:
      r_field = e_lsel;
      break;

    case R_PARISC_DIR21L:
    case R_PARISC_DPREL21L:
      r_field = e_lrsel;
      break;

    case R_PARISC_PCREL17R:
    case R_PARISC_PCREL14R:
    case R_PARISC_PLABEL14R:
    case R_PARISC_DLTIND14R:
      r_field = e_rsel;
      break;

    case R_PARISC_DIR17R:
    case R_PARISC_DIR14R:
    case R_PARISC_DPREL14R:
      r_field = e_rrsel;
      break;

    case R_PARISC_PCREL12F:
    case R_PARISC_PCREL17F:
    case R_PARISC_PCREL22F:
      r_field = e_fsel;

      if (r_type == (unsigned int) R_PARISC_PCREL17F)
	{
	  max_branch_offset = (1 << (17-1)) << 2;
	}
      else if (r_type == (unsigned int) R_PARISC_PCREL12F)
	{
	  max_branch_offset = (1 << (12-1)) << 2;
	}
      else
	{
	  max_branch_offset = (1 << (22-1)) << 2;
	}

      /* sym_sec is NULL on undefined weak syms or when shared on
	 undefined syms.  We've already checked for a stub for the
	 shared undefined case.  */
      if (sym_sec == NULL)
	break;

      /* If the branch is out of reach, then redirect the
	 call to the local stub for this function.  */
      if (value + addend + max_branch_offset >= 2*max_branch_offset)
	{
	  stub_entry = hppa_get_stub_entry (input_section, sym_sec,
					    h, rel, htab);
	  if (stub_entry == NULL)
	    return bfd_reloc_undefined;

	  /* Munge up the value and addend so that we call the stub
	     rather than the procedure directly.  */
	  value = (stub_entry->stub_offset
		   + stub_entry->stub_sec->output_offset
		   + stub_entry->stub_sec->output_section->vma
		   - location);
	  addend = -8;
	}
      break;

    /* Something we don't know how to handle.  */
    default:
      return bfd_reloc_notsupported;
    }

  /* Make sure we can reach the stub.  */
  if (max_branch_offset != 0
      && value + addend + max_branch_offset >= 2*max_branch_offset)
    {
      (*_bfd_error_handler)
	(_("%s(%s+0x%lx): cannot reach %s, recompile with -ffunction-sections"),
	 bfd_archive_filename (input_bfd),
	 input_section->name,
	 (long) rel->r_offset,
	 stub_entry->root.string);
      bfd_set_error (bfd_error_bad_value);
      return bfd_reloc_notsupported;
    }

  val = hppa_field_adjust (value, addend, r_field);

  switch (r_type)
    {
    case R_PARISC_PCREL12F:
    case R_PARISC_PCREL17C:
    case R_PARISC_PCREL17F:
    case R_PARISC_PCREL17R:
    case R_PARISC_PCREL22F:
    case R_PARISC_DIR17F:
    case R_PARISC_DIR17R:
      /* This is a branch.  Divide the offset by four.
	 Note that we need to decide whether it's a branch or
	 otherwise by inspecting the reloc.  Inspecting insn won't
	 work as insn might be from a .word directive.  */
      val >>= 2;
      break;

    default:
      break;
    }

  insn = hppa_rebuild_insn (insn, val, r_format);

  /* Update the instruction word.  */
  bfd_put_32 (input_bfd, (bfd_vma) insn, hit_data);
  return bfd_reloc_ok;
}

/* Relocate an HPPA ELF section.  */

static bfd_boolean
elf32_hppa_relocate_section (bfd *output_bfd,
			     struct bfd_link_info *info,
			     bfd *input_bfd,
			     asection *input_section,
			     bfd_byte *contents,
			     Elf_Internal_Rela *relocs,
			     Elf_Internal_Sym *local_syms,
			     asection **local_sections)
{
  bfd_vma *local_got_offsets;
  struct elf32_hppa_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;

  if (info->relocatable)
    return TRUE;

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;

  htab = hppa_link_hash_table (info);
  local_got_offsets = elf_local_got_offsets (input_bfd);

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      unsigned int r_type;
      reloc_howto_type *howto;
      unsigned int r_symndx;
      struct elf32_hppa_link_hash_entry *h;
      Elf_Internal_Sym *sym;
      asection *sym_sec;
      bfd_vma relocation;
      bfd_reloc_status_type r;
      const char *sym_name;
      bfd_boolean plabel;
      bfd_boolean warned_undef;

      r_type = ELF32_R_TYPE (rel->r_info);
      if (r_type >= (unsigned int) R_PARISC_UNIMPLEMENTED)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      if (r_type == (unsigned int) R_PARISC_GNU_VTENTRY
	  || r_type == (unsigned int) R_PARISC_GNU_VTINHERIT)
	continue;

      /* This is a final link.  */
      r_symndx = ELF32_R_SYM (rel->r_info);
      h = NULL;
      sym = NULL;
      sym_sec = NULL;
      warned_undef = FALSE;
      if (r_symndx < symtab_hdr->sh_info)
	{
	  /* This is a local symbol, h defaults to NULL.  */
	  sym = local_syms + r_symndx;
	  sym_sec = local_sections[r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sym_sec, rel);
	}
      else
	{
	  struct elf_link_hash_entry *hh;
	  bfd_boolean unresolved_reloc;
	  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   hh, sym_sec, relocation,
				   unresolved_reloc, warned_undef);

	  if (relocation == 0
	      && hh->root.type != bfd_link_hash_defined
	      && hh->root.type != bfd_link_hash_defweak
	      && hh->root.type != bfd_link_hash_undefweak)
	    {
	      if (info->unresolved_syms_in_objects == RM_IGNORE
		  && ELF_ST_VISIBILITY (hh->other) == STV_DEFAULT
		  && hh->type == STT_PARISC_MILLI)
		{
		  if (! info->callbacks->undefined_symbol
		      (info, hh->root.root.string, input_bfd,
		       input_section, rel->r_offset, FALSE))
		    return FALSE;
		  warned_undef = TRUE;
		}
	    }
	  h = (struct elf32_hppa_link_hash_entry *) hh;
	}

      /* Do any required modifications to the relocation value, and
	 determine what types of dynamic info we need to output, if
	 any.  */
      plabel = 0;
      switch (r_type)
	{
	case R_PARISC_DLTIND14F:
	case R_PARISC_DLTIND14R:
	case R_PARISC_DLTIND21L:
	  {
	    bfd_vma off;
	    bfd_boolean do_got = 0;

	    /* Relocation is to the entry for this symbol in the
	       global offset table.  */
	    if (h != NULL)
	      {
		bfd_boolean dyn;

		off = h->elf.got.offset;
		dyn = htab->elf.dynamic_sections_created;
		if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared,
						       &h->elf))
		  {
		    /* If we aren't going to call finish_dynamic_symbol,
		       then we need to handle initialisation of the .got
		       entry and create needed relocs here.  Since the
		       offset must always be a multiple of 4, we use the
		       least significant bit to record whether we have
		       initialised it already.  */
		    if ((off & 1) != 0)
		      off &= ~1;
		    else
		      {
			h->elf.got.offset |= 1;
			do_got = 1;
		      }
		  }
	      }
	    else
	      {
		/* Local symbol case.  */
		if (local_got_offsets == NULL)
		  abort ();

		off = local_got_offsets[r_symndx];

		/* The offset must always be a multiple of 4.  We use
		   the least significant bit to record whether we have
		   already generated the necessary reloc.  */
		if ((off & 1) != 0)
		  off &= ~1;
		else
		  {
		    local_got_offsets[r_symndx] |= 1;
		    do_got = 1;
		  }
	      }

	    if (do_got)
	      {
		if (info->shared)
		  {
		    /* Output a dynamic relocation for this GOT entry.
		       In this case it is relative to the base of the
		       object because the symbol index is zero.  */
		    Elf_Internal_Rela outrel;
		    bfd_byte *loc;
		    asection *s = htab->srelgot;

		    outrel.r_offset = (off
				       + htab->sgot->output_offset
				       + htab->sgot->output_section->vma);
		    outrel.r_info = ELF32_R_INFO (0, R_PARISC_DIR32);
		    outrel.r_addend = relocation;
		    loc = s->contents;
		    loc += s->reloc_count++ * sizeof (Elf32_External_Rela);
		    bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		  }
		else
		  bfd_put_32 (output_bfd, relocation,
			      htab->sgot->contents + off);
	      }

	    if (off >= (bfd_vma) -2)
	      abort ();

	    /* Add the base of the GOT to the relocation value.  */
	    relocation = (off
			  + htab->sgot->output_offset
			  + htab->sgot->output_section->vma);
	  }
	  break;

	case R_PARISC_SEGREL32:
	  /* If this is the first SEGREL relocation, then initialize
	     the segment base values.  */
	  if (htab->text_segment_base == (bfd_vma) -1)
	    bfd_map_over_sections (output_bfd, hppa_record_segment_addr, htab);
	  break;

	case R_PARISC_PLABEL14R:
	case R_PARISC_PLABEL21L:
	case R_PARISC_PLABEL32:
	  if (htab->elf.dynamic_sections_created)
	    {
	      bfd_vma off;
	      bfd_boolean do_plt = 0;

	      /* If we have a global symbol with a PLT slot, then
		 redirect this relocation to it.  */
	      if (h != NULL)
		{
		  off = h->elf.plt.offset;
		  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared,
							 &h->elf))
		    {
		      /* In a non-shared link, adjust_dynamic_symbols
			 isn't called for symbols forced local.  We
			 need to write out the plt entry here.  */
		      if ((off & 1) != 0)
			off &= ~1;
		      else
			{
			  h->elf.plt.offset |= 1;
			  do_plt = 1;
			}
		    }
		}
	      else
		{
		  bfd_vma *local_plt_offsets;

		  if (local_got_offsets == NULL)
		    abort ();

		  local_plt_offsets = local_got_offsets + symtab_hdr->sh_info;
		  off = local_plt_offsets[r_symndx];

		  /* As for the local .got entry case, we use the last
		     bit to record whether we've already initialised
		     this local .plt entry.  */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
		      local_plt_offsets[r_symndx] |= 1;
		      do_plt = 1;
		    }
		}

	      if (do_plt)
		{
		  if (info->shared)
		    {
		      /* Output a dynamic IPLT relocation for this
			 PLT entry.  */
		      Elf_Internal_Rela outrel;
		      bfd_byte *loc;
		      asection *s = htab->srelplt;

		      outrel.r_offset = (off
					 + htab->splt->output_offset
					 + htab->splt->output_section->vma);
		      outrel.r_info = ELF32_R_INFO (0, R_PARISC_IPLT);
		      outrel.r_addend = relocation;
		      loc = s->contents;
		      loc += s->reloc_count++ * sizeof (Elf32_External_Rela);
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		    }
		  else
		    {
		      bfd_put_32 (output_bfd,
				  relocation,
				  htab->splt->contents + off);
		      bfd_put_32 (output_bfd,
				  elf_gp (htab->splt->output_section->owner),
				  htab->splt->contents + off + 4);
		    }
		}

	      if (off >= (bfd_vma) -2)
		abort ();

	      /* PLABELs contain function pointers.  Relocation is to
		 the entry for the function in the .plt.  The magic +2
		 offset signals to $$dyncall that the function pointer
		 is in the .plt and thus has a gp pointer too.
		 Exception:  Undefined PLABELs should have a value of
		 zero.  */
	      if (h == NULL
		  || (h->elf.root.type != bfd_link_hash_undefweak
		      && h->elf.root.type != bfd_link_hash_undefined))
		{
		  relocation = (off
				+ htab->splt->output_offset
				+ htab->splt->output_section->vma
				+ 2);
		}
	      plabel = 1;
	    }
	  /* Fall through and possibly emit a dynamic relocation.  */

	case R_PARISC_DIR17F:
	case R_PARISC_DIR17R:
	case R_PARISC_DIR14F:
	case R_PARISC_DIR14R:
	case R_PARISC_DIR21L:
	case R_PARISC_DPREL14F:
	case R_PARISC_DPREL14R:
	case R_PARISC_DPREL21L:
	case R_PARISC_DIR32:
	  /* r_symndx will be zero only for relocs against symbols
	     from removed linkonce sections, or sections discarded by
	     a linker script.  */
	  if (r_symndx == 0
	      || (input_section->flags & SEC_ALLOC) == 0)
	    break;

	  /* The reloc types handled here and this conditional
	     expression must match the code in ..check_relocs and
	     allocate_dynrelocs.  ie. We need exactly the same condition
	     as in ..check_relocs, with some extra conditions (dynindx
	     test in this case) to cater for relocs removed by
	     allocate_dynrelocs.  If you squint, the non-shared test
	     here does indeed match the one in ..check_relocs, the
	     difference being that here we test DEF_DYNAMIC as well as
	     !DEF_REGULAR.  All common syms end up with !DEF_REGULAR,
	     which is why we can't use just that test here.
	     Conversely, DEF_DYNAMIC can't be used in check_relocs as
	     there all files have not been loaded.  */
	  if ((info->shared
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->elf.other) == STV_DEFAULT
		   || h->elf.root.type != bfd_link_hash_undefweak)
	       && (IS_ABSOLUTE_RELOC (r_type)
		   || !SYMBOL_CALLS_LOCAL (info, &h->elf)))
	      || (!info->shared
		  && h != NULL
		  && h->elf.dynindx != -1
		  && (h->elf.elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
		  && ((ELIMINATE_COPY_RELOCS
		       && (h->elf.elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		       && (h->elf.elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR) == 0)
		      || h->elf.root.type == bfd_link_hash_undefweak
		      || h->elf.root.type == bfd_link_hash_undefined)))
	    {
	      Elf_Internal_Rela outrel;
	      bfd_boolean skip;
	      asection *sreloc;
	      bfd_byte *loc;

	      /* When generating a shared object, these relocations
		 are copied into the output file to be resolved at run
		 time.  */

	      outrel.r_addend = rel->r_addend;
	      outrel.r_offset =
		_bfd_elf_section_offset (output_bfd, info, input_section,
					 rel->r_offset);
	      skip = (outrel.r_offset == (bfd_vma) -1
		      || outrel.r_offset == (bfd_vma) -2);
	      outrel.r_offset += (input_section->output_offset
				  + input_section->output_section->vma);

	      if (skip)
		{
		  memset (&outrel, 0, sizeof (outrel));
		}
	      else if (h != NULL
		       && h->elf.dynindx != -1
		       && (plabel
			   || !IS_ABSOLUTE_RELOC (r_type)
			   || !info->shared
			   || !info->symbolic
			   || (h->elf.elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))
		{
		  outrel.r_info = ELF32_R_INFO (h->elf.dynindx, r_type);
		}
	      else /* It's a local symbol, or one marked to become local.  */
		{
		  int indx = 0;

		  /* Add the absolute offset of the symbol.  */
		  outrel.r_addend += relocation;

		  /* Global plabels need to be processed by the
		     dynamic linker so that functions have at most one
		     fptr.  For this reason, we need to differentiate
		     between global and local plabels, which we do by
		     providing the function symbol for a global plabel
		     reloc, and no symbol for local plabels.  */
		  if (! plabel
		      && sym_sec != NULL
		      && sym_sec->output_section != NULL
		      && ! bfd_is_abs_section (sym_sec))
		    {
		      /* Skip this relocation if the output section has
			 been discarded.  */
		      if (bfd_is_abs_section (sym_sec->output_section))
			break;

		      indx = elf_section_data (sym_sec->output_section)->dynindx;
		      /* We are turning this relocation into one
			 against a section symbol, so subtract out the
			 output section's address but not the offset
			 of the input section in the output section.  */
		      outrel.r_addend -= sym_sec->output_section->vma;
		    }

		  outrel.r_info = ELF32_R_INFO (indx, r_type);
		}
#if 0
	      /* EH info can cause unaligned DIR32 relocs.
		 Tweak the reloc type for the dynamic linker.  */
	      if (r_type == R_PARISC_DIR32 && (outrel.r_offset & 3) != 0)
		outrel.r_info = ELF32_R_INFO (ELF32_R_SYM (outrel.r_info),
					      R_PARISC_DIR32U);
#endif
	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();

	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
	    }
	  break;

	default:
	  break;
	}

      r = final_link_relocate (input_section, contents, rel, relocation,
			       htab, sym_sec, h, info);

      if (r == bfd_reloc_ok)
	continue;

      if (h != NULL)
	sym_name = h->elf.root.root.string;
      else
	{
	  sym_name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
						      sym->st_name);
	  if (sym_name == NULL)
	    return FALSE;
	  if (*sym_name == '\0')
	    sym_name = bfd_section_name (input_bfd, sym_sec);
	}

      howto = elf_hppa_howto_table + r_type;

      if (r == bfd_reloc_undefined || r == bfd_reloc_notsupported)
	{
	  if (r == bfd_reloc_notsupported || !warned_undef)
	    {
	      (*_bfd_error_handler)
		(_("%s(%s+0x%lx): cannot handle %s for %s"),
		 bfd_archive_filename (input_bfd),
		 input_section->name,
		 (long) rel->r_offset,
		 howto->name,
		 sym_name);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	}
      else
	{
	  if (!((*info->callbacks->reloc_overflow)
		(info, sym_name, howto->name, 0, input_bfd, input_section,
		 rel->r_offset)))
	    return FALSE;
	}
    }

  return TRUE;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
elf32_hppa_finish_dynamic_symbol (bfd *output_bfd,
				  struct bfd_link_info *info,
				  struct elf_link_hash_entry *h,
				  Elf_Internal_Sym *sym)
{
  struct elf32_hppa_link_hash_table *htab;
  Elf_Internal_Rela rel;
  bfd_byte *loc;

  htab = hppa_link_hash_table (info);

  if (h->plt.offset != (bfd_vma) -1)
    {
      bfd_vma value;

      if (h->plt.offset & 1)
	abort ();

      /* This symbol has an entry in the procedure linkage table.  Set
	 it up.

	 The format of a plt entry is
	 <funcaddr>
	 <__gp>
      */
      value = 0;
      if (h->root.type == bfd_link_hash_defined
	  || h->root.type == bfd_link_hash_defweak)
	{
	  value = h->root.u.def.value;
	  if (h->root.u.def.section->output_section != NULL)
	    value += (h->root.u.def.section->output_offset
		      + h->root.u.def.section->output_section->vma);
	}

      /* Create a dynamic IPLT relocation for this entry.  */
      rel.r_offset = (h->plt.offset
		      + htab->splt->output_offset
		      + htab->splt->output_section->vma);
      if (h->dynindx != -1)
	{
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_PARISC_IPLT);
	  rel.r_addend = 0;
	}
      else
	{
	  /* This symbol has been marked to become local, and is
	     used by a plabel so must be kept in the .plt.  */
	  rel.r_info = ELF32_R_INFO (0, R_PARISC_IPLT);
	  rel.r_addend = value;
	}

      loc = htab->srelplt->contents;
      loc += htab->srelplt->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (htab->splt->output_section->owner, &rel, loc);

      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	{
	  /* Mark the symbol as undefined, rather than as defined in
	     the .plt section.  Leave the value alone.  */
	  sym->st_shndx = SHN_UNDEF;
	}
    }

  if (h->got.offset != (bfd_vma) -1)
    {
      /* This symbol has an entry in the global offset table.  Set it
	 up.  */

      rel.r_offset = ((h->got.offset &~ (bfd_vma) 1)
		      + htab->sgot->output_offset
		      + htab->sgot->output_section->vma);

      /* If this is a -Bsymbolic link and the symbol is defined
	 locally or was forced to be local because of a version file,
	 we just want to emit a RELATIVE reloc.  The entry in the
	 global offset table will already have been initialized in the
	 relocate_section function.  */
      if (info->shared
	  && (info->symbolic || h->dynindx == -1)
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
	{
	  rel.r_info = ELF32_R_INFO (0, R_PARISC_DIR32);
	  rel.r_addend = (h->root.u.def.value
			  + h->root.u.def.section->output_offset
			  + h->root.u.def.section->output_section->vma);
	}
      else
	{
	  if ((h->got.offset & 1) != 0)
	    abort ();
	  bfd_put_32 (output_bfd, 0, htab->sgot->contents + h->got.offset);
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_PARISC_DIR32);
	  rel.r_addend = 0;
	}

      loc = htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
    }

  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) != 0)
    {
      asection *s;

      /* This symbol needs a copy reloc.  Set it up.  */

      if (! (h->dynindx != -1
	     && (h->root.type == bfd_link_hash_defined
		 || h->root.type == bfd_link_hash_defweak)))
	abort ();

      s = htab->srelbss;

      rel.r_offset = (h->root.u.def.value
		      + h->root.u.def.section->output_offset
		      + h->root.u.def.section->output_section->vma);
      rel.r_addend = 0;
      rel.r_info = ELF32_R_INFO (h->dynindx, R_PARISC_COPY);
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
    }

  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
  if (h->root.root.string[0] == '_'
      && (strcmp (h->root.root.string, "_DYNAMIC") == 0
	  || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0))
    {
      sym->st_shndx = SHN_ABS;
    }

  return TRUE;
}

/* Used to decide how to sort relocs in an optimal manner for the
   dynamic linker, before writing them out.  */

static enum elf_reloc_type_class
elf32_hppa_reloc_type_class (const Elf_Internal_Rela *rela)
{
  if (ELF32_R_SYM (rela->r_info) == 0)
    return reloc_class_relative;

  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    case R_PARISC_IPLT:
      return reloc_class_plt;
    case R_PARISC_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

/* Finish up the dynamic sections.  */

static bfd_boolean
elf32_hppa_finish_dynamic_sections (bfd *output_bfd,
				    struct bfd_link_info *info)
{
  bfd *dynobj;
  struct elf32_hppa_link_hash_table *htab;
  asection *sdyn;

  htab = hppa_link_hash_table (info);
  dynobj = htab->elf.dynobj;

  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");

  if (htab->elf.dynamic_sections_created)
    {
      Elf32_External_Dyn *dyncon, *dynconend;

      if (sdyn == NULL)
	abort ();

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  asection *s;

	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      continue;

	    case DT_PLTGOT:
	      /* Use PLTGOT to set the GOT register.  */
	      dyn.d_un.d_ptr = elf_gp (output_bfd);
	      break;

	    case DT_JMPREL:
	      s = htab->srelplt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      break;

	    case DT_PLTRELSZ:
	      s = htab->srelplt;
	      dyn.d_un.d_val = s->_raw_size;
	      break;

	    case DT_RELASZ:
	      /* Don't count procedure linkage table relocs in the
		 overall reloc count.  */
	      s = htab->srelplt;
	      if (s == NULL)
		continue;
	      dyn.d_un.d_val -= s->_raw_size;
	      break;

	    case DT_RELA:
	      /* We may not be using the standard ELF linker script.
		 If .rela.plt is the first .rela section, we adjust
		 DT_RELA to not include it.  */
	      s = htab->srelplt;
	      if (s == NULL)
		continue;
	      if (dyn.d_un.d_ptr != s->output_section->vma + s->output_offset)
		continue;
	      dyn.d_un.d_ptr += s->_raw_size;
	      break;
	    }

	  bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	}
    }

  if (htab->sgot != NULL && htab->sgot->_raw_size != 0)
    {
      /* Fill in the first entry in the global offset table.
	 We use it to point to our dynamic section, if we have one.  */
      bfd_put_32 (output_bfd,
		  sdyn ? sdyn->output_section->vma + sdyn->output_offset : 0,
		  htab->sgot->contents);

      /* The second entry is reserved for use by the dynamic linker.  */
      memset (htab->sgot->contents + GOT_ENTRY_SIZE, 0, GOT_ENTRY_SIZE);

      /* Set .got entry size.  */
      elf_section_data (htab->sgot->output_section)
	->this_hdr.sh_entsize = GOT_ENTRY_SIZE;
    }

  if (htab->splt != NULL && htab->splt->_raw_size != 0)
    {
      /* Set plt entry size.  */
      elf_section_data (htab->splt->output_section)
	->this_hdr.sh_entsize = PLT_ENTRY_SIZE;

      if (htab->need_plt_stub)
	{
	  /* Set up the .plt stub.  */
	  memcpy (htab->splt->contents
		  + htab->splt->_raw_size - sizeof (plt_stub),
		  plt_stub, sizeof (plt_stub));

	  if ((htab->splt->output_offset
	       + htab->splt->output_section->vma
	       + htab->splt->_raw_size)
	      != (htab->sgot->output_offset
		  + htab->sgot->output_section->vma))
	    {
	      (*_bfd_error_handler)
		(_(".got section not immediately after .plt section"));
	      return FALSE;
	    }
	}
    }

  return TRUE;
}

/* Tweak the OSABI field of the elf header.  */

static void
elf32_hppa_post_process_headers (bfd *abfd,
				 struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  Elf_Internal_Ehdr * i_ehdrp;

  i_ehdrp = elf_elfheader (abfd);

  if (strcmp (bfd_get_target (abfd), "elf32-hppa-linux") == 0)
    {
      i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_LINUX;
    }
  else
    {
      i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_HPUX;
    }
}

/* Called when writing out an object file to decide the type of a
   symbol.  */
static int
elf32_hppa_elf_get_symbol_type (Elf_Internal_Sym *elf_sym, int type)
{
  if (ELF_ST_TYPE (elf_sym->st_info) == STT_PARISC_MILLI)
    return STT_PARISC_MILLI;
  else
    return type;
}

/* Misc BFD support code.  */
#define bfd_elf32_bfd_is_local_label_name    elf_hppa_is_local_label_name
#define bfd_elf32_bfd_reloc_type_lookup	     elf_hppa_reloc_type_lookup
#define elf_info_to_howto		     elf_hppa_info_to_howto
#define elf_info_to_howto_rel		     elf_hppa_info_to_howto_rel

/* Stuff for the BFD linker.  */
#define bfd_elf32_bfd_final_link	     elf32_hppa_final_link
#define bfd_elf32_bfd_link_hash_table_create elf32_hppa_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_free   elf32_hppa_link_hash_table_free
#define elf_backend_adjust_dynamic_symbol    elf32_hppa_adjust_dynamic_symbol
#define elf_backend_copy_indirect_symbol     elf32_hppa_copy_indirect_symbol
#define elf_backend_check_relocs	     elf32_hppa_check_relocs
#define elf_backend_create_dynamic_sections  elf32_hppa_create_dynamic_sections
#define elf_backend_fake_sections	     elf_hppa_fake_sections
#define elf_backend_relocate_section	     elf32_hppa_relocate_section
#define elf_backend_hide_symbol		     elf32_hppa_hide_symbol
#define elf_backend_finish_dynamic_symbol    elf32_hppa_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections  elf32_hppa_finish_dynamic_sections
#define elf_backend_size_dynamic_sections    elf32_hppa_size_dynamic_sections
#define elf_backend_gc_mark_hook	     elf32_hppa_gc_mark_hook
#define elf_backend_gc_sweep_hook	     elf32_hppa_gc_sweep_hook
#define elf_backend_object_p		     elf32_hppa_object_p
#define elf_backend_final_write_processing   elf_hppa_final_write_processing
#define elf_backend_post_process_headers     elf32_hppa_post_process_headers
#define elf_backend_get_symbol_type	     elf32_hppa_elf_get_symbol_type
#define elf_backend_reloc_type_class	     elf32_hppa_reloc_type_class

#define elf_backend_can_gc_sections	     1
#define elf_backend_can_refcount	     1
#define elf_backend_plt_alignment	     2
#define elf_backend_want_got_plt	     0
#define elf_backend_plt_readonly	     0
#define elf_backend_want_plt_sym	     0
#define elf_backend_got_header_size	     8
#define elf_backend_rela_normal		     1

#define TARGET_BIG_SYM		bfd_elf32_hppa_vec
#define TARGET_BIG_NAME		"elf32-hppa"
#define ELF_ARCH		bfd_arch_hppa
#define ELF_MACHINE_CODE	EM_PARISC
#define ELF_MAXPAGESIZE		0x1000

#include "elf32-target.h"

#undef TARGET_BIG_SYM
#define TARGET_BIG_SYM			bfd_elf32_hppa_linux_vec
#undef TARGET_BIG_NAME
#define TARGET_BIG_NAME			"elf32-hppa-linux"

#define INCLUDED_TARGET_FILE 1
#include "elf32-target.h"
@


1.10
log
@Add a DT_DEBUG tag to PIEs as well.

ok pascal@@
@
text
@d2039 1
a2039 1
      if (info->executable)
@


1.9
log
@Fix handling of hidden symbols on hppa.  Patch from upstream (Alan Modra).

ok miod@@, tested by landry@@
@
text
@d2241 1
a2241 1
      if (!info->shared)
@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d1618 1
a1618 1
      h->plt.offset = (bfd_vma) -1;
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2002, 2003 Free Software Foundation, Inc.
d144 6
a211 4
  /* Set if the only reason we need a .plt entry is for a non-PIC to
     PIC function call.  */
  unsigned int pic_call:1;

d228 2
a229 2
  asection * (*add_stub_section) PARAMS ((const char *, asection *));
  void (*layout_sections_again) PARAMS ((void));
a283 124
static struct bfd_hash_entry *stub_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));

static struct bfd_hash_entry *hppa_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));

static struct bfd_link_hash_table *elf32_hppa_link_hash_table_create
  PARAMS ((bfd *));

static void elf32_hppa_link_hash_table_free
  PARAMS ((struct bfd_link_hash_table *));

/* Stub handling functions.  */
static char *hppa_stub_name
  PARAMS ((const asection *, const asection *,
	   const struct elf32_hppa_link_hash_entry *,
	   const Elf_Internal_Rela *));

static struct elf32_hppa_stub_hash_entry *hppa_get_stub_entry
  PARAMS ((const asection *, const asection *,
	   struct elf32_hppa_link_hash_entry *,
	   const Elf_Internal_Rela *,
	   struct elf32_hppa_link_hash_table *));

static struct elf32_hppa_stub_hash_entry *hppa_add_stub
  PARAMS ((const char *, asection *, struct elf32_hppa_link_hash_table *));

static enum elf32_hppa_stub_type hppa_type_of_stub
  PARAMS ((asection *, const Elf_Internal_Rela *,
	   struct elf32_hppa_link_hash_entry *, bfd_vma));

static bfd_boolean hppa_build_one_stub
  PARAMS ((struct bfd_hash_entry *, PTR));

static bfd_boolean hppa_size_one_stub
  PARAMS ((struct bfd_hash_entry *, PTR));

/* BFD and elf backend functions.  */
static bfd_boolean elf32_hppa_object_p PARAMS ((bfd *));

static bfd_boolean elf32_hppa_add_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
	   const char **, flagword *, asection **, bfd_vma *));

static bfd_boolean elf32_hppa_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

static void elf32_hppa_copy_indirect_symbol
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));

static bfd_boolean elf32_hppa_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *,
	   asection *, const Elf_Internal_Rela *));

static asection *elf32_hppa_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));

static bfd_boolean elf32_hppa_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *,
	   asection *, const Elf_Internal_Rela *));

static void elf32_hppa_hide_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean));

static bfd_boolean elf32_hppa_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));

static bfd_boolean mark_PIC_calls
  PARAMS ((struct elf_link_hash_entry *, PTR));

static bfd_boolean allocate_plt_static
  PARAMS ((struct elf_link_hash_entry *, PTR));

static bfd_boolean allocate_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));

static bfd_boolean readonly_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));

static bfd_boolean clobber_millicode_symbols
  PARAMS ((struct elf_link_hash_entry *, struct bfd_link_info *));

static bfd_boolean elf32_hppa_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

static void group_sections
  PARAMS ((struct elf32_hppa_link_hash_table *, bfd_size_type, bfd_boolean));

static int get_local_syms
  PARAMS ((bfd *, bfd *, struct bfd_link_info *));

static bfd_boolean elf32_hppa_final_link
  PARAMS ((bfd *, struct bfd_link_info *));

static void hppa_record_segment_addr
  PARAMS ((bfd *, asection *, PTR));

static bfd_reloc_status_type final_link_relocate
  PARAMS ((asection *, bfd_byte *, const Elf_Internal_Rela *,
	   bfd_vma, struct elf32_hppa_link_hash_table *, asection *,
	   struct elf32_hppa_link_hash_entry *));

static bfd_boolean elf32_hppa_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *,
	   bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));

static bfd_boolean elf32_hppa_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));

static enum elf_reloc_type_class elf32_hppa_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));

static bfd_boolean elf32_hppa_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

static void elf32_hppa_post_process_headers
  PARAMS ((bfd *, struct bfd_link_info *));

static int elf32_hppa_elf_get_symbol_type
  PARAMS ((Elf_Internal_Sym *, int));

d289 3
a291 4
stub_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d326 3
a328 4
hppa_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
a349 1
      eh->pic_call = 0;
d361 1
a361 2
elf32_hppa_link_hash_table_create (abfd)
     bfd *abfd;
d366 1
a366 1
  ret = (struct elf32_hppa_link_hash_table *) bfd_malloc (amt);
d405 1
a405 2
elf32_hppa_link_hash_table_free (hash)
     struct bfd_link_hash_table *hash;
d417 4
a420 5
hppa_stub_name (input_section, sym_sec, hash, rel)
     const asection *input_section;
     const asection *sym_sec;
     const struct elf32_hppa_link_hash_entry *hash;
     const Elf_Internal_Rela *rel;
d457 5
a461 6
hppa_get_stub_entry (input_section, sym_sec, hash, rel, htab)
     const asection *input_section;
     const asection *sym_sec;
     struct elf32_hppa_link_hash_entry *hash;
     const Elf_Internal_Rela *rel;
     struct elf32_hppa_link_hash_table *htab;
d502 3
a504 4
hppa_add_stub (stub_name, section, htab)
     const char *stub_name;
     asection *section;
     struct elf32_hppa_link_hash_table *htab;
d557 5
a561 5
hppa_type_of_stub (input_sec, rel, hash, destination)
     asection *input_sec;
     const Elf_Internal_Rela *rel;
     struct elf32_hppa_link_hash_entry *hash;
     bfd_vma destination;
d570 5
a574 2
      && (hash->elf.dynindx != -1 || hash->pic_call)
      && !hash->plabel)
d653 1
a653 3
hppa_build_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg;
d669 1
a669 1
  info = (struct bfd_link_info *) in_arg;
d691 1
a691 1
      val = hppa_field_adjust (sym_value, (bfd_signed_vma) 0, e_lrsel);
d695 1
a695 1
      val = hppa_field_adjust (sym_value, (bfd_signed_vma) 0, e_rrsel) >> 2;
d741 1
a741 1
      val = hppa_field_adjust (sym_value, (bfd_signed_vma) 0, e_lrsel),
d750 1
a750 1
      val = hppa_field_adjust (sym_value, (bfd_signed_vma) 0, e_rrsel);
a776 33
      if (!info->shared
	  && stub_entry->h != NULL
	  && stub_entry->h->pic_call)
	{
	  /* Build the .plt entry needed to call a PIC function from
	     statically linked code.  We don't need any relocs.  */
	  bfd *dynobj;
	  struct elf32_hppa_link_hash_entry *eh;
	  bfd_vma value;

	  dynobj = htab->elf.dynobj;
	  eh = (struct elf32_hppa_link_hash_entry *) stub_entry->h;

	  if (eh->elf.root.type != bfd_link_hash_defined
	      && eh->elf.root.type != bfd_link_hash_defweak)
	    abort ();

	  value = (eh->elf.root.u.def.value
		   + eh->elf.root.u.def.section->output_offset
		   + eh->elf.root.u.def.section->output_section->vma);

	  /* Fill in the entry in the procedure linkage table.

	     The format of a plt entry is
	     <funcaddr>
	     <__gp>.  */

	  bfd_put_32 (htab->splt->owner, value,
		      htab->splt->contents + off);
	  value = elf_gp (htab->splt->output_section->owner);
	  bfd_put_32 (htab->splt->owner, value,
		      htab->splt->contents + off + 4);
	}
a837 1
#undef ADDIL_DP
d858 1
a858 3
hppa_size_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg;
d866 1
a866 1
  htab = (struct elf32_hppa_link_hash_table *) in_arg;
d890 1
a890 2
elf32_hppa_object_p (abfd)
     bfd *abfd;
d898 4
a901 1
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_LINUX)
a924 17
/* Undo the generic ELF code's subtraction of section->vma from the
   value of each external symbol.  */

static bfd_boolean
elf32_hppa_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const Elf_Internal_Sym *sym ATTRIBUTE_UNUSED;
     const char **namep ATTRIBUTE_UNUSED;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
{
  *valp += (*secp)->vma;
  return TRUE;
}

d929 1
a929 3
elf32_hppa_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d967 3
a969 3
elf32_hppa_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
     struct elf_link_hash_entry *dir, *ind;
d1012 13
a1024 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d1033 4
a1036 5
elf32_hppa_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d1046 1
a1046 1
  if (info->relocateable)
a1085 3

	  /* Mark this section as containing PIC code.  */
	  sec->flags |= SEC_HAS_GOT_REF;
d1150 1
a1150 1
	case R_PARISC_SEGBASE: /* Used to set segment base.  */
d1156 1
d1202 1
a1202 2
	  if (!_bfd_elf32_gc_record_vtinherit (abfd, sec,
					       &h->elf, rel->r_offset))
d1209 1
a1209 2
	  if (!_bfd_elf32_gc_record_vtentry (abfd, sec,
					     &h->elf, rel->r_addend))
d1250 1
a1250 2
		  local_got_refcounts = ((bfd_signed_vma *)
					 bfd_zalloc (abfd, size));
d1296 1
a1296 2
		      local_got_refcounts = ((bfd_signed_vma *)
					     bfd_zalloc (abfd, size));
d1352 2
a1353 1
	      || (!info->shared
d1431 1
a1431 3
		  p = ((struct elf32_hppa_dyn_reloc_entry *)
		       bfd_alloc (htab->elf.dynobj,
				  (bfd_size_type) sizeof *p));
d1459 5
a1463 6
elf32_hppa_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d1498 4
a1501 5
elf32_hppa_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d1600 3
a1602 4
elf32_hppa_hide_symbol (info, h, force_local)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     bfd_boolean force_local;
a1621 11
/* This is the condition under which elf32_hppa_finish_dynamic_symbol
   will be called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in elf32_hppa_relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, INFO, H) \
  ((DYN)								\
   && ((INFO)->shared							\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

d1629 2
a1630 3
elf32_hppa_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
a1632 2
  struct elf32_hppa_link_hash_entry *eh;
  struct elf32_hppa_dyn_reloc_entry *p;
d1655 2
a1656 12
	  /* As a special sop to the hppa ABI, we keep a .plt entry
	     for functions in sections containing PIC code.  */
	  if (!info->shared
	      && h->plt.refcount > 0
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	      && (h->root.u.def.section->flags & SEC_HAS_GOT_REF) != 0)
	    ((struct elf32_hppa_link_hash_entry *) h)->pic_call = 1;
	  else
	    {
	      h->plt.offset = (bfd_vma) -1;
	      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	    }
d1674 4
d1696 1
a1696 2
  eh = (struct elf32_hppa_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
d1698 10
a1707 4
      s = p->sec->output_section;
      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	break;
    }
d1709 7
a1715 6
  /* If we didn't find any dynamic relocs in read-only sections, then
     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
  if (p == NULL)
    {
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
      return TRUE;
a1765 28
/* Called via elf_link_hash_traverse to create .plt entries for an
   application that uses statically linked PIC functions.  Similar to
   the first part of elf32_hppa_adjust_dynamic_symbol.  */

static bfd_boolean
mark_PIC_calls (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf ATTRIBUTE_UNUSED;
{
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (! (h->plt.refcount > 0
	 && (h->root.type == bfd_link_hash_defined
	     || h->root.type == bfd_link_hash_defweak)
	 && (h->root.u.def.section->flags & SEC_HAS_GOT_REF) != 0))
    {
      h->plt.offset = (bfd_vma) -1;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
      return TRUE;
    }

  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
  ((struct elf32_hppa_link_hash_entry *) h)->pic_call = 1;

  return TRUE;
}

d1767 1
a1767 1
   ie. pic_call and plabel entries.  */
d1770 1
a1770 3
allocate_plt_static (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d1782 1
a1782 1
  info = (struct bfd_link_info *) inf;
d1784 1
a1784 10
  if (((struct elf32_hppa_link_hash_entry *) h)->pic_call)
    {
      /* Make an entry in the .plt section for non-pic code that is
	 calling pic code.  */
      ((struct elf32_hppa_link_hash_entry *) h)->plabel = 0;
      s = htab->splt;
      h->plt.offset = s->_raw_size;
      s->_raw_size += PLT_ENTRY_SIZE;
    }
  else if (htab->elf.dynamic_sections_created
d1793 1
a1793 1
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d1797 1
a1797 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d1833 1
a1833 3
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d1847 1
a1847 1
  info = (struct bfd_link_info *) inf;
a1850 1
      && !((struct elf32_hppa_link_hash_entry *) h)->pic_call
d1871 1
a1871 1
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d1901 1
a1901 3
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
	      || info->symbolic))
d1916 6
d1929 2
a1930 1
	  && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
d1942 1
a1942 1
	      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d1976 2
a1977 3
clobber_millicode_symbols (h, info)
     struct elf_link_hash_entry *h;
     struct bfd_link_info *info;
d1993 1
a1993 3
readonly_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d2008 1
a2008 1
	  struct bfd_link_info *info = (struct bfd_link_info *) inf;
d2022 2
a2023 3
elf32_hppa_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d2039 1
a2039 1
      if (! info->shared)
a2052 8
  else
    {
      /* Run through the function symbols, looking for any that are
	 PIC, and mark them as needing .plt entries so that %r19 will
	 be set up.  */
      if (! info->shared)
	elf_link_hash_traverse (&htab->elf, mark_PIC_calls, (PTR) info);
    }
d2148 1
a2148 1
  elf_link_hash_traverse (&htab->elf, allocate_plt_static, (PTR) info);
d2152 1
a2152 1
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, (PTR) info);
d2219 1
a2219 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
d2231 1
a2231 1
  bfd_elf32_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
d2265 1
a2265 2
	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs,
				    (PTR) info);
d2286 1
a2286 3
elf32_hppa_setup_section_lists (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
a2295 3
  if (htab->elf.root.creator->flavour != bfd_target_elf_flavour)
    return 0;

d2313 1
a2313 1
  htab->stub_group = (struct map_stub *) bfd_zmalloc (amt);
d2330 1
a2330 1
  input_list = (asection **) bfd_malloc (amt);
d2359 1
a2359 3
elf32_hppa_next_input_section (info, isec)
     struct bfd_link_info *info;
     asection *isec;
d2386 3
a2388 4
group_sections (htab, stub_group_size, stubs_always_before_branch)
     struct elf32_hppa_link_hash_table *htab;
     bfd_size_type stub_group_size;
     bfd_boolean stubs_always_before_branch;
d2466 1
a2466 4
get_local_syms (output_bfd, input_bfd, info)
     bfd *output_bfd;
     bfd *input_bfd;
     struct bfd_link_info *info;
d2477 1
a2477 1
  all_local_syms = (Elf_Internal_Sym **) bfd_zmalloc (amt);
d2591 5
a2595 9
elf32_hppa_size_stubs (output_bfd, stub_bfd, info, multi_subspace, group_size,
		       add_stub_section, layout_sections_again)
     bfd *output_bfd;
     bfd *stub_bfd;
     struct bfd_link_info *info;
     bfd_boolean multi_subspace;
     bfd_signed_vma group_size;
     asection * (*add_stub_section) PARAMS ((const char *, asection *));
     void (*layout_sections_again) PARAMS ((void));
d2693 2
a2694 3
		= _bfd_elf32_link_read_relocs (input_bfd, section, NULL,
					       (Elf_Internal_Rela *) NULL,
					       info->keep_memory);
d2783 1
a2783 2
			  if (! (info->shared
				 && !info->no_undefined
d2798 1
a2798 1
						 destination);
d2879 1
a2879 3
elf32_hppa_set_gp (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d2898 2
a2899 15
      asection *splt;
      asection *sgot;

      if (htab->elf.root.creator->flavour == bfd_target_elf_flavour)
	{
	  splt = htab->splt;
	  sgot = htab->sgot;
	}
      else
	{
	  /* If we're not elf, look up the output sections in the
	     hope we may actually find them.  */
	  splt = bfd_get_section_by_name (abfd, ".plt");
	  sgot = bfd_get_section_by_name (abfd, ".got");
	}
d2960 1
a2960 2
elf32_hppa_build_stubs (info)
     struct bfd_link_info *info;
d2976 1
a2976 1
      stub_sec->contents = (unsigned char *) bfd_zalloc (htab->stub_bfd, size);
d2992 1
a2992 3
elf32_hppa_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d2995 1
a2995 1
  if (!bfd_elf32_bfd_final_link (abfd, info))
d3006 3
a3008 4
hppa_record_segment_addr (abfd, section, data)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section;
     PTR data;
d3034 8
a3041 8
final_link_relocate (input_section, contents, rel, value, htab, sym_sec, h)
     asection *input_section;
     bfd_byte *contents;
     const Elf_Internal_Rela *rel;
     bfd_vma value;
     struct elf32_hppa_link_hash_table *htab;
     asection *sym_sec;
     struct elf32_hppa_link_hash_entry *h;
d3045 1
d3068 20
d3099 5
a3103 2
	      && (h->elf.dynindx != -1 || h->pic_call)
	      && !h->plabel))
d3135 1
d3144 32
d3229 1
d3356 8
a3363 10
elf32_hppa_relocate_section (output_bfd, info, input_bfd, input_section,
			     contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d3371 1
a3371 1
  if (info->relocateable)
d3416 1
a3416 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sym_sec, rel);
d3420 24
a3443 36
	  int indx;

	  /* It's a global; Find its entry in the link hash.  */
	  indx = r_symndx - symtab_hdr->sh_info;
	  h = ((struct elf32_hppa_link_hash_entry *)
	       elf_sym_hashes (input_bfd)[indx]);
	  while (h->elf.root.type == bfd_link_hash_indirect
		 || h->elf.root.type == bfd_link_hash_warning)
	    h = (struct elf32_hppa_link_hash_entry *) h->elf.root.u.i.link;

	  relocation = 0;
	  if (h->elf.root.type == bfd_link_hash_defined
	      || h->elf.root.type == bfd_link_hash_defweak)
	    {
	      sym_sec = h->elf.root.u.def.section;
	      /* If sym_sec->output_section is NULL, then it's a
		 symbol defined in a shared library.  */
	      if (sym_sec->output_section != NULL)
		relocation = (h->elf.root.u.def.value
			      + sym_sec->output_offset
			      + sym_sec->output_section->vma);
	    }
	  else if (h->elf.root.type == bfd_link_hash_undefweak)
	    ;
	  else if (info->shared
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->elf.other) == STV_DEFAULT
		   && h->elf.type != STT_PARISC_MILLI)
	    ;
	  else
	    {
	      if (!((*info->callbacks->undefined_symbol)
		    (info, h->elf.root.root.string, input_bfd,
		     input_section, rel->r_offset, TRUE)))
		return FALSE;
	      warned_undef = TRUE;
d3445 1
d3469 2
a3470 1
		if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, &h->elf))
d3562 2
a3563 1
		  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, &h->elf))
d3680 3
d3684 1
a3684 5
		   || (h != NULL
		       && h->elf.dynindx != -1
		       && (!info->symbolic
			   || (h->elf.elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d3689 3
a3691 2
		  && (((h->elf.elf_link_hash_flags
			& ELF_LINK_HASH_DEF_DYNAMIC) != 0
d3748 5
d3785 1
a3785 1
			       htab, sym_sec, h);
d3823 2
a3824 2
		(info, sym_name, howto->name, (bfd_vma) 0,
		 input_bfd, input_section, rel->r_offset)))
d3836 4
a3839 5
elf32_hppa_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d3842 2
d3871 5
a3875 1
      if (! ((struct elf32_hppa_link_hash_entry *) h)->pic_call)
d3877 2
a3878 24
	  Elf_Internal_Rela rel;
	  bfd_byte *loc;

	  /* Create a dynamic IPLT relocation for this entry.  */
	  rel.r_offset = (h->plt.offset
			  + htab->splt->output_offset
			  + htab->splt->output_section->vma);
	  if (h->dynindx != -1)
	    {
	      rel.r_info = ELF32_R_INFO (h->dynindx, R_PARISC_IPLT);
	      rel.r_addend = 0;
	    }
	  else
	    {
	      /* This symbol has been marked to become local, and is
		 used by a plabel so must be kept in the .plt.  */
	      rel.r_info = ELF32_R_INFO (0, R_PARISC_IPLT);
	      rel.r_addend = value;
	    }

	  loc = htab->srelplt->contents;
	  loc += htab->srelplt->reloc_count++ * sizeof (Elf32_External_Rela);
	  bfd_elf32_swap_reloca_out (htab->splt->output_section->owner,
				     &rel, loc);
d3882 4
a3885 6
	  bfd_put_32 (htab->splt->owner,
		      value,
		      htab->splt->contents + h->plt.offset);
	  bfd_put_32 (htab->splt->owner,
		      elf_gp (htab->splt->output_section->owner),
		      htab->splt->contents + h->plt.offset + 4);
d3888 4
a3901 3
      Elf_Internal_Rela rel;
      bfd_byte *loc;

d3927 1
a3927 2
	  bfd_put_32 (output_bfd, (bfd_vma) 0,
		      htab->sgot->contents + h->got.offset);
a3939 2
      Elf_Internal_Rela rel;
      bfd_byte *loc;
d3974 1
a3974 2
elf32_hppa_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
d3993 2
a3994 3
elf32_hppa_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d4072 1
a4072 3
		  (sdyn != NULL
		   ? sdyn->output_section->vma + sdyn->output_offset
		   : (bfd_vma) 0),
d4115 2
a4116 3
elf32_hppa_post_process_headers (abfd, link_info)
     bfd *abfd;
     struct bfd_link_info *link_info ATTRIBUTE_UNUSED;
d4135 1
a4135 3
elf32_hppa_elf_get_symbol_type (elf_sym, type)
     Elf_Internal_Sym *elf_sym;
     int type;
a4152 1
#define elf_backend_add_symbol_hook	     elf32_hppa_add_symbol_hook
@


1.6
log
@resolve conflicts.
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000, 2001
   Free Software Foundation, Inc.
d11 1
a11 1
This file is part of BFD, the Binary File Descriptor library.
d13 13
a25 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d35 1
a36 1
#include "elf32-hppa.h"
d74 1
a74 1
   :            bv %r0(%r21)
d81 1
a81 1
   :            bv %r0(%r21)
d114 1
a114 1
   :		be,n 0(%sr0,%rp)		; inter-space return  */
a116 1
#define PLABEL_PLT_ENTRY_SIZE PLT_ENTRY_SIZE
d136 6
a141 18
/* Setting the following non-zero makes all long branch stubs
   generated during a shared link of the PIC variety.  This saves on
   relocs, but costs one extra instruction per stub.  */
#ifndef LONG_BRANCH_PIC_IN_SHLIB
#define LONG_BRANCH_PIC_IN_SHLIB 1
#endif

/* Set this non-zero to use import stubs instead of long branch stubs
   where a .plt entry exists for the symbol.  This is a fairly useless
   option as import stubs are bigger than PIC long branch stubs.  */
#ifndef LONG_BRANCH_VIA_PLT
#define LONG_BRANCH_VIA_PLT 0
#endif

/* We don't need to copy any PC- or GP-relative dynamic relocs into a
   shared object's dynamic section.  */
#ifndef RELATIVE_DYNAMIC_RELOCS
#define RELATIVE_DYNAMIC_RELOCS 0
a160 5
#if ! LONG_BRANCH_PIC_IN_SHLIB
  /* It's associated reloc section.  */
  asection *reloc_sec;
#endif

a186 7
#if ! LONG_BRANCH_PIC_IN_SHLIB
  /* Used to track whether we have allocated space for a long branch
     stub relocation for this symbol in the given section.  */
  asection *stub_reloc_sec;
#endif

#if ! LONG_BRANCH_PIC_IN_SHLIB || RELATIVE_DYNAMIC_RELOCS
d194 2
a195 2
    /* The section in dynobj.  */
    asection *section;
d199 4
a202 1
  } *reloc_entries;
d204 1
a204 3

  /* Set during a static link if we detect a function is PIC.  */
  unsigned int maybe_pic_call:1;
a211 4

  /* Set if this symbol is an init or fini function and thus should
     use an absolute reloc.  */
  unsigned int plt_abs:1;
d217 1
a217 1
  struct elf_link_hash_table root;
a236 4
#if ! LONG_BRANCH_PIC_IN_SHLIB
    /* The stub section's reloc section.  */
    asection *reloc_sec;
#endif
d239 6
d261 1
a261 1
  /* Flags set when PCREL12F and PCREL17F branches detected.  Used to
d265 1
d269 3
d291 3
d313 1
a313 1
static boolean hppa_build_one_stub
d316 1
a316 1
static boolean hppa_size_one_stub
d320 1
a320 1
static boolean elf32_hppa_object_p PARAMS ((bfd *));
d322 1
a322 1
static boolean elf32_hppa_add_symbol_hook
d326 1
a326 1
static boolean elf32_hppa_create_dynamic_sections
d329 5
a333 1
static boolean elf32_hppa_check_relocs
d338 1
a338 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
d341 1
a341 1
static boolean elf32_hppa_gc_sweep_hook
d346 3
d351 2
a352 2
static boolean elf32_hppa_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
d354 1
a354 1
static boolean hppa_handle_PIC_calls
d357 1
a357 1
static boolean allocate_plt_and_got
d360 1
a360 3
#if ((! LONG_BRANCH_PIC_IN_SHLIB && LONG_BRANCH_VIA_PLT) \
     || RELATIVE_DYNAMIC_RELOCS)
static boolean hppa_discard_copies
a361 1
#endif
d363 1
a363 1
static boolean clobber_millicode_symbols
d366 1
a366 1
static boolean elf32_hppa_size_dynamic_sections
d369 7
a375 1
static boolean elf32_hppa_final_link
d386 1
a386 1
static boolean elf32_hppa_relocate_section
d390 1
a390 4
static int hppa_unwind_entry_compare
  PARAMS ((const PTR, const PTR));

static boolean elf32_hppa_finish_dynamic_symbol
d394 4
a397 1
static boolean elf32_hppa_finish_dynamic_sections
a415 4
  struct elf32_hppa_stub_hash_entry *ret;

  ret = (struct elf32_hppa_stub_hash_entry *) entry;

d418 1
a418 1
  if (ret == NULL)
d420 4
a423 5
      ret = ((struct elf32_hppa_stub_hash_entry *)
	     bfd_hash_allocate (table,
				sizeof (struct elf32_hppa_stub_hash_entry)));
      if (ret == NULL)
	return NULL;
d427 4
a430 2
  ret = ((struct elf32_hppa_stub_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));
a431 2
  if (ret)
    {
d433 8
a440 10
      ret->stub_sec = NULL;
#if ! LONG_BRANCH_PIC_IN_SHLIB
      ret->reloc_sec = NULL;
#endif
      ret->stub_offset = 0;
      ret->target_value = 0;
      ret->target_section = NULL;
      ret->stub_type = hppa_stub_long_branch;
      ret->h = NULL;
      ret->id_sec = NULL;
d443 1
a443 1
  return (struct bfd_hash_entry *) ret;
a453 4
  struct elf32_hppa_link_hash_entry *ret;

  ret = (struct elf32_hppa_link_hash_entry *) entry;

d456 1
a456 1
  if (ret == NULL)
d458 4
a461 5
      ret = ((struct elf32_hppa_link_hash_entry *)
	     bfd_hash_allocate (table,
				sizeof (struct elf32_hppa_link_hash_entry)));
      if (ret == NULL)
	return NULL;
d465 4
a468 3
  ret = ((struct elf32_hppa_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
a469 2
  if (ret)
    {
d471 5
a475 11
#if ! LONG_BRANCH_PIC_IN_SHLIB
      ret->stub_reloc_sec = NULL;
#endif
      ret->stub_cache = NULL;
#if ! LONG_BRANCH_PIC_IN_SHLIB || RELATIVE_DYNAMIC_RELOCS
      ret->reloc_entries = NULL;
#endif
      ret->maybe_pic_call = 0;
      ret->pic_call = 0;
      ret->plabel = 0;
      ret->plt_abs = 0;
d478 1
a478 1
  return (struct bfd_hash_entry *) ret;
d490 1
d492 1
a492 1
  ret = ((struct elf32_hppa_link_hash_table *) bfd_alloc (abfd, sizeof (*ret)));
d496 1
a496 1
  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd, hppa_link_hash_newfunc))
d498 1
a498 1
      bfd_release (abfd, ret);
d521 1
d523 6
d530 9
a538 1
  return &ret->root.root;
d551 1
a551 1
  size_t len;
d585 1
a585 1
hppa_get_stub_entry (input_section, sym_sec, hash, rel, hplink)
d590 1
a590 1
     struct elf32_hppa_link_hash_table *hplink;
d600 1
a600 1
  id_sec = hplink->stub_group[input_section->id].link_sec;
d616 4
a619 16
      stub_entry = hppa_stub_hash_lookup (&hplink->stub_hash_table,
					  stub_name, false, false);
      if (stub_entry == NULL)
	{
	  if (hash == NULL || hash->elf.root.type != bfd_link_hash_undefweak)
	    (*_bfd_error_handler) (_("%s(%s+0x%lx): cannot find stub entry %s"),
				   bfd_get_filename (input_section->owner),
				   input_section->name,
				   (long) rel->r_offset,
				   stub_name);
	}
      else
	{
	  if (hash != NULL)
	    hash->stub_cache = stub_entry;
	}
d631 1
a631 1
hppa_add_stub (stub_name, section, hplink)
d634 1
a634 1
     struct elf32_hppa_link_hash_table *hplink;
d640 2
a641 2
  link_sec = hplink->stub_group[section->id].link_sec;
  stub_sec = hplink->stub_group[section->id].stub_sec;
d644 1
a644 1
      stub_sec = hplink->stub_group[link_sec->id].stub_sec;
d647 2
a648 1
	  size_t len;
d651 3
a653 2
	  len = strlen (link_sec->name) + sizeof (STUB_SUFFIX);
	  s_name = bfd_alloc (hplink->stub_bfd, len);
d657 3
a659 3
	  strcpy (s_name, link_sec->name);
	  strcpy (s_name + len - sizeof (STUB_SUFFIX), STUB_SUFFIX);
	  stub_sec = (*hplink->add_stub_section) (s_name, link_sec);
d662 1
a662 1
	  hplink->stub_group[link_sec->id].stub_sec = stub_sec;
d664 1
a664 1
      hplink->stub_group[section->id].stub_sec = stub_sec;
d668 2
a669 2
  stub_entry = hppa_stub_hash_lookup (&hplink->stub_hash_table, stub_name,
				      true, false);
d673 1
a673 1
			     bfd_get_filename (section->owner),
a678 3
#if ! LONG_BRANCH_PIC_IN_SHLIB
  stub_entry->reloc_sec = hplink->stub_group[section->id].reloc_sec;
#endif
d699 6
a704 15
      && (((hash->elf.root.type == bfd_link_hash_defined
	    || hash->elf.root.type == bfd_link_hash_defweak)
	   && hash->elf.root.u.def.section->output_section == NULL)
	  || (hash->elf.root.type == bfd_link_hash_defweak
	      && hash->elf.dynindx != -1
	      && hash->elf.plt.offset != (bfd_vma) -1)
	  || hash->elf.root.type == bfd_link_hash_undefweak
	  || hash->elf.root.type == bfd_link_hash_undefined
	  || (hash->maybe_pic_call && !(input_sec->flags & SEC_HAS_GOT_REF))))
    {
      /* If output_section is NULL, then it's a symbol defined in a
	 shared library.  We will need an import stub.  Decide between
	 hppa_stub_import and hppa_stub_import_shared later.  For
	 shared links we need stubs for undefined or weak syms too;
	 They will presumably be resolved by the dynamic linker.  */
d734 2
a735 15
    {
#if LONG_BRANCH_VIA_PLT
      if (hash != NULL
	  && hash->elf.dynindx != -1
	  && hash->elf.plt.offset != (bfd_vma) -1
	  && hash->elf.type != STT_PARISC_MILLI)
	{
	  /* If we are doing a shared link and find we need a long
	     branch stub, then go via the .plt if possible.  */
	  return hppa_stub_import;
	}
      else
#endif
	return hppa_stub_long_branch;
    }
d762 1
d779 1
a779 1
static boolean
d786 1
a786 1
  struct elf32_hppa_link_hash_table *hplink;
d800 1
a800 1
  hplink = hppa_link_hash_table (info);
a827 45
#if ! LONG_BRANCH_PIC_IN_SHLIB
      if (info->shared)
	{
	  /* Output a dynamic relocation for this stub.  We only
	     output one PCREL21L reloc per stub, trusting that the
	     dynamic linker will also fix the implied PCREL17R for the
	     second instruction.  PCREL21L dynamic relocs had better
	     never be emitted for some other purpose...  */
	  asection *srel;
	  Elf_Internal_Rela outrel;

	  if (stub_entry->h == NULL)
	    {
	      (*_bfd_error_handler)
		(_("%s(%s+0x%lx): cannot relocate %s, recompile with -ffunction-sections"),
		 bfd_get_filename (stub_entry->target_section->owner),
		 stub_sec->name,
		 (long) stub_entry->stub_offset,
		 stub_entry->root.string);
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }

	  srel = stub_entry->reloc_sec;
	  if (srel == NULL)
	    {
	      (*_bfd_error_handler)
		(_("Could not find relocation section for %s"),
		 stub_sec->name);
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }

	  outrel.r_offset = (stub_entry->stub_offset
			     + stub_sec->output_offset
			     + stub_sec->output_section->vma);
	  outrel.r_info = ELF32_R_INFO (0, R_PARISC_PCREL21L);
	  outrel.r_addend = sym_value;
	  bfd_elf32_swap_reloca_out (stub_sec->output_section->owner,
				     &outrel,
				     ((Elf32_External_Rela *)
				      srel->contents + srel->reloc_count));
	  ++srel->reloc_count;
	}
#endif
d861 3
a863 3
		   + hplink->splt->output_offset
		   + hplink->splt->output_section->vma
		   - elf_gp (hplink->splt->output_section->owner));
d883 1
a883 1
      if (hplink->multi_subspace)
d916 1
a916 1
	  dynobj = hplink->root.dynobj;
d933 5
a937 5
	  bfd_put_32 (hplink->splt->owner, value,
		      hplink->splt->contents + off);
	  value = elf_gp (hplink->splt->output_section->owner);
	  bfd_put_32 (hplink->splt->owner, value,
		      hplink->splt->contents + off + 4);
d952 3
a954 1
      if (sym_value - 8 + 0x40000 >= 0x80000)
d958 1
a958 1
	     bfd_get_filename (stub_entry->target_section->owner),
d963 1
a963 1
	  return false;
d967 4
a970 1
      insn = hppa_rebuild_insn ((int) BL_RP, val, 17);
d988 1
a988 1
      return false;
d992 1
a992 1
  return true;
d1020 1
a1020 1
static boolean
d1026 1
a1026 1
  struct elf32_hppa_link_hash_table *hplink;
d1031 1
a1031 1
  hplink = (struct elf32_hppa_link_hash_table *) in_arg;
d1034 1
a1034 7
    {
#if ! LONG_BRANCH_PIC_IN_SHLIB
      if (stub_entry->reloc_sec != NULL)
	stub_entry->reloc_sec->_raw_size += sizeof (Elf32_External_Rela);
#endif
      size = 8;
    }
d1041 1
a1041 1
      if (hplink->multi_subspace)
d1048 1
a1048 1
  return true;
d1054 1
a1054 1
static boolean
d1065 1
a1065 1
	return false;
d1070 1
a1070 1
	return false;
d1085 1
a1085 1
  return true;
d1091 1
a1091 1
static boolean
d1102 1
a1102 1
  return true;
d1108 1
a1108 1
static boolean
d1113 1
a1113 1
  struct elf32_hppa_link_hash_table *hplink;
d1116 3
a1118 3
  hplink = hppa_link_hash_table (info);
  if (hplink->splt != NULL)
    return true;
d1122 1
a1122 1
    return false;
d1124 2
a1125 2
  hplink->splt = bfd_get_section_by_name (abfd, ".plt");
  hplink->srelplt = bfd_get_section_by_name (abfd, ".rela.plt");
d1127 4
a1130 4
  hplink->sgot = bfd_get_section_by_name (abfd, ".got");
  hplink->srelgot = bfd_make_section (abfd, ".rela.got");
  if (hplink->srelgot == NULL
      || ! bfd_set_section_flags (abfd, hplink->srelgot,
d1137 52
a1188 2
      || ! bfd_set_section_alignment (abfd, hplink->srelgot, 2))
    return false;
d1190 3
a1192 2
  hplink->sdynbss = bfd_get_section_by_name (abfd, ".dynbss");
  hplink->srelbss = bfd_get_section_by_name (abfd, ".rela.bss");
d1194 1
a1194 1
  return true;
d1198 3
a1200 3
   allocate space in the global offset table or procedure linkage
   table.  At this point we haven't necessarily read all the input
   files.  */
d1202 1
a1202 1
static boolean
a1208 1
  bfd *dynobj;
a1210 1
  bfd_signed_vma *local_got_refcounts;
d1213 1
a1213 1
  struct elf32_hppa_link_hash_table *hplink;
d1218 1
a1218 1
    return true;
d1220 1
a1220 2
  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;
a1222 1
  local_got_refcounts = elf_local_got_refcounts (abfd);
d1233 1
a1233 6
#if LONG_BRANCH_PIC_IN_SHLIB
	NEED_STUBREL = 0,  /* We won't be needing them in this case.  */
#else
	NEED_STUBREL = 8,
#endif
	PLT_PLABEL = 16
d1289 3
a1291 2
	  hplink->has_12bit_branch = 1;
	  /* Fall thru.  */
d1294 3
a1296 2
	  hplink->has_17bit_branch = 1;
	  /* Fall thru.  */
d1298 2
d1318 1
a1318 1
	      need_entry = NEED_PLT | NEED_STUBREL;
d1320 1
a1320 1
		need_entry = NEED_STUBREL;
d1341 1
a1341 1
		 bfd_get_filename (abfd),
d1344 1
a1344 1
	      return false;
d1353 1
a1353 1
#if 1
d1361 1
a1361 1
		 bfd_get_filename (abfd),
d1377 1
a1377 1
	    return false;
d1385 1
a1385 1
	    return false;
d1397 1
a1397 4
	  if (dynobj == NULL)
	    hplink->root.dynobj = dynobj = abfd;

	  if (hplink->sgot == NULL)
d1399 4
a1402 2
	      if (! elf32_hppa_create_dynamic_sections (dynobj, info))
		return false;
d1407 1
a1407 14
	      if (h->elf.got.refcount == -1)
		{
		  h->elf.got.refcount = 1;

		  /* Make sure this symbol is output as a dynamic symbol.  */
		  if (h->elf.dynindx == -1)
		    {
		      if (! bfd_elf32_link_record_dynamic_symbol (info,
								  &h->elf))
			return false;
		    }
		}
	      else
		h->elf.got.refcount += 1;
d1411 2
d1414 1
d1417 1
a1417 1
		  size_t size;
d1423 2
a1424 1
		  size = symtab_hdr->sh_info * 2 * sizeof (bfd_signed_vma);
d1426 1
a1426 1
					 bfd_alloc (abfd, size));
d1428 1
a1428 1
		    return false;
a1429 1
		  memset (local_got_refcounts, -1, size);
d1431 1
a1431 4
	      if (local_got_refcounts[r_symndx] == -1)
		local_got_refcounts[r_symndx] = 1;
	      else
		local_got_refcounts[r_symndx] += 1;
d1449 2
a1450 7
		  if (h->elf.plt.refcount == -1)
		    {
		      h->elf.plt.refcount = 1;
		      h->elf.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
		    }
		  else
		    h->elf.plt.refcount += 1;
d1460 2
a1461 1
		  int indx;
d1463 1
d1466 1
a1466 1
		      size_t size;
d1470 2
a1471 1
		      size = symtab_hdr->sh_info * 2 * sizeof (bfd_signed_vma);
d1473 1
a1473 1
					     bfd_alloc (abfd, size));
d1475 1
a1475 1
			return false;
a1476 1
		      memset (local_got_refcounts, -1, size);
d1478 3
a1480 5
		  indx = r_symndx + symtab_hdr->sh_info;
		  if (local_got_refcounts[indx] == -1)
		    local_got_refcounts[indx] = 1;
		  else
		    local_got_refcounts[indx] += 1;
d1485 1
a1485 1
      if (need_entry & (NEED_DYNREL | NEED_STUBREL))
d1490 1
a1490 1
	  if (h != NULL)
d1503 1
a1503 1
	     storing information in the reloc_entries field of the
d1515 20
a1534 11
	     reloc in the branch.  */
	  if ((sec->flags & SEC_ALLOC) != 0
	      && info->shared
#if RELATIVE_DYNAMIC_RELOCS
	      && (!info->symbolic
		  || is_absolute_reloc (r_type)
		  || (h != NULL
		      && ((h->elf.elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR) == 0)))
#endif
	      )
d1536 2
a1537 6
	      boolean doit;
	      asection *srel;

	      srel = sreloc;
	      if ((need_entry & NEED_STUBREL))
		srel = stubreloc;
d1541 1
a1541 1
	      if (srel == NULL)
d1544 1
d1546 4
a1549 7
		  if (dynobj == NULL)
		    hplink->root.dynobj = dynobj = abfd;

		  name = bfd_elf_string_from_elf_section
		    (abfd,
		     elf_elfheader (abfd)->e_shstrndx,
		     elf_section_data (sec)->rel_hdr.sh_name);
d1556 1
a1556 1
		      return false;
d1559 2
a1560 4
		  if ((need_entry & NEED_STUBREL))
		    {
		      size_t len = strlen (name) + sizeof (STUB_SUFFIX);
		      char *newname = bfd_malloc (len);
d1562 3
a1564 10
		      if (newname == NULL)
			return false;
		      strcpy (newname, name);
		      strcpy (newname + len - sizeof (STUB_SUFFIX),
			      STUB_SUFFIX);
		      name = newname;
		    }

		  srel = bfd_get_section_by_name (dynobj, name);
		  if (srel == NULL)
d1568 1
a1568 1
		      srel = bfd_make_section (dynobj, name);
d1573 4
a1576 4
		      if (srel == NULL
			  || !bfd_set_section_flags (dynobj, srel, flags)
			  || !bfd_set_section_alignment (dynobj, srel, 2))
			return false;
a1577 2
		  else if ((need_entry & NEED_STUBREL))
		    free (name);
d1579 1
a1579 4
		  if ((need_entry & NEED_STUBREL))
		    stubreloc = srel;
		  else
		    sreloc = srel;
d1582 3
a1584 8
#if ! LONG_BRANCH_PIC_IN_SHLIB
	      /* If this is a function call, we only need one dynamic
		 reloc for the stub as all calls to a particular
		 function will go through the same stub.  Actually, a
		 long branch stub needs two relocations, but we count
		 on some intelligence on the part of the dynamic
		 linker.  */
	      if ((need_entry & NEED_STUBREL))
d1586 1
a1586 2
		  doit = h->stub_reloc_sec != stubreloc;
		  h->stub_reloc_sec = stubreloc;
d1589 14
a1602 2
#endif
		doit = 1;
d1604 2
a1605 1
	      if (doit)
d1607 11
a1617 10
		  srel->_raw_size += sizeof (Elf32_External_Rela);

#if ! LONG_BRANCH_PIC_IN_SHLIB || RELATIVE_DYNAMIC_RELOCS
		  /* Keep track of relocations we have entered for
		     this global symbol, so that we can discard them
		     later if necessary.  */
		  if (h != NULL
		      && (0
#if RELATIVE_DYNAMIC_RELOCS
			  || ! is_absolute_reloc (rtype)
d1619 1
a1619 19
			  || (need_entry & NEED_STUBREL)))
		    {
		      struct elf32_hppa_dyn_reloc_entry *p;

		      for (p = h->reloc_entries; p != NULL; p = p->next)
			if (p->section == srel)
			  break;

		      if (p == NULL)
			{
			  p = ((struct elf32_hppa_dyn_reloc_entry *)
			       bfd_alloc (dynobj, sizeof *p));
			  if (p == NULL)
			    return false;
			  p->next = h->reloc_entries;
			  h->reloc_entries = p;
			  p->section = srel;
			  p->count = 0;
			}
d1621 4
a1624 8
		      /* NEED_STUBREL and NEED_DYNREL are never both
			 set.  Leave the count at zero for the
			 NEED_STUBREL case as we only ever have one
			 stub reloc per section per symbol, and this
			 simplifies code in hppa_discard_copies.  */
		      if (! (need_entry & NEED_STUBREL))
			++p->count;
		    }
a1625 1
		}
d1630 1
a1630 1
  return true;
d1637 2
a1638 2
elf32_hppa_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
d1668 1
a1668 9
    {
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		&& sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
    }
d1676 1
a1676 1
static boolean
d1688 2
a1689 4
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;
  struct elf32_hppa_link_hash_table *hplink;
  bfd *dynobj;
a1696 4
  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;
  if (dynobj == NULL)
    return true;
d1700 41
a1740 18
    switch ((unsigned int) ELF32_R_TYPE (rel->r_info))
      {
      case R_PARISC_DLTIND14F:
      case R_PARISC_DLTIND14R:
      case R_PARISC_DLTIND21L:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount -= 1;
	  }
	else if (local_got_refcounts != NULL)
	  {
	    if (local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx] -= 1;
	  }
	break;
d1742 10
a1751 12
      case R_PARISC_PCREL12F:
      case R_PARISC_PCREL17C:
      case R_PARISC_PCREL17F:
      case R_PARISC_PCREL22F:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;
	  }
	break;
d1753 14
a1766 16
      case R_PARISC_PLABEL14R:
      case R_PARISC_PLABEL21L:
      case R_PARISC_PLABEL32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;
	  }
	else if (local_plt_refcounts != NULL)
	  {
	    if (local_plt_refcounts[r_symndx] > 0)
	      local_plt_refcounts[r_symndx] -= 1;
	  }
	break;
d1768 4
a1771 3
      default:
	break;
      }
d1773 1
a1773 1
  return true;
d1780 2
a1781 2
elf32_hppa_hide_symbol (info, h)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d1783 1
d1785 11
a1795 2
  if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
    h->dynindx = -1;
d1820 1
a1820 1
static boolean
d1825 3
a1827 2
  bfd *dynobj;
  struct elf32_hppa_link_hash_table *hplink;
d1829 1
a1829 3

  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;
d1832 1
a1832 2
     will fill in the contents of the procedure linkage table later,
     when we know the address of the .got section.  */
a1835 8
      if (!info->shared
	  && h->plt.refcount > 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && (h->root.u.def.section->flags & SEC_HAS_GOT_REF) != 0)
	{
	  ((struct elf32_hppa_link_hash_entry *) h)->maybe_pic_call = 1;
	}

d1852 4
a1855 1
	  if (((struct elf32_hppa_link_hash_entry *) h)->maybe_pic_call)
a1860 12
	      return true;
	    }
	}

      if (! ((struct elf32_hppa_link_hash_entry *) h)->pic_call)
	{
	  /* Make sure this symbol is output as a dynamic symbol.  */
	  if (h->dynindx == -1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	    {
	      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
		return false;
d1864 1
a1864 1
      return true;
d1866 2
d1879 1
a1879 1
      return true;
d1890 1
a1890 1
    return true;
d1895 17
a1911 1
    return true;
d1923 1
a1923 1
  s = hplink->sdynbss;
d1927 1
a1927 2
     runtime process image.  We need to remember the offset into the
     .rela.bss section we are going to use.  */
d1930 6
a1935 1
      asection *srel;
d1937 12
a1948 3
      srel = hplink->srelbss;
      srel->_raw_size += sizeof (Elf32_External_Rela);
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
a1950 18
  {
    /* We need to figure out the alignment required for this symbol.  I
       have no idea how other ELF linkers handle this.  */
    unsigned int power_of_two;

    power_of_two = bfd_log2 (h->size);
    if (power_of_two > 3)
      power_of_two = 3;

    /* Apply the required alignment.  */
    s->_raw_size = BFD_ALIGN (s->_raw_size,
			      (bfd_size_type) (1 << power_of_two));
    if (power_of_two > bfd_get_section_alignment (dynobj, s))
      {
	if (! bfd_set_section_alignment (dynobj, s, power_of_two))
	  return false;
      }
  }
d1958 1
a1958 1
  return true;
d1965 2
a1966 2
static boolean
hppa_handle_PIC_calls (h, inf)
d1970 3
d1980 1
a1980 1
      return true;
a1983 1
  ((struct elf32_hppa_link_hash_entry *) h)->maybe_pic_call = 1;
d1986 1
a1986 1
  return true;
d1989 2
a1990 2
/* Allocate space in .plt, .got and associated reloc sections for
   global syms.  */
d1992 2
a1993 2
static boolean
allocate_plt_and_got (h, inf)
d1998 1
a1998 1
  struct elf32_hppa_link_hash_table *hplink;
d2001 5
a2005 3
  if (h->root.type == bfd_link_hash_indirect
      || h->root.type == bfd_link_hash_warning)
    return true;
d2008 2
a2009 4
  hplink = hppa_link_hash_table (info);
  if ((hplink->root.dynamic_sections_created
       && h->plt.refcount > 0)
      || ((struct elf32_hppa_link_hash_entry *) h)->pic_call)
d2011 4
a2014 2
      /* Make an entry in the .plt section.  */
      s = hplink->splt;
d2016 16
a2031 3
      if (PLABEL_PLT_ENTRY_SIZE != PLT_ENTRY_SIZE
	  && ((struct elf32_hppa_link_hash_entry *) h)->plabel
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d2033 13
a2045 2
	  /* Add some extra space for the dynamic linker to use.  */
	  s->_raw_size += PLABEL_PLT_ENTRY_SIZE;
a2047 4
	s->_raw_size += PLT_ENTRY_SIZE;

      if (! ((struct elf32_hppa_link_hash_entry *) h)->pic_call
	  && WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d2049 3
a2051 3
	  /* We also need to make an entry in the .rela.plt section.  */
	  hplink->srelplt->_raw_size += sizeof (Elf32_External_Rela);
	  hplink->need_plt_stub = 1;
d2060 40
d2102 9
a2110 1
      boolean dyn;
d2112 1
a2112 1
      s = hplink->sgot;
d2115 7
a2121 3
      dyn = hplink->root.dynamic_sections_created;
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
	hplink->srelgot->_raw_size += sizeof (Elf32_External_Rela);
d2126 3
a2128 2
  return true;
}
d2130 47
a2176 4
#if ((! LONG_BRANCH_PIC_IN_SHLIB && LONG_BRANCH_VIA_PLT) \
     || RELATIVE_DYNAMIC_RELOCS)
/* This function is called via elf_link_hash_traverse to discard space
   we allocated for relocs that it turned out we didn't need.  */
d2178 5
a2182 8
static boolean
hppa_discard_copies (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct elf32_hppa_dyn_reloc_entry *s;
  struct elf32_hppa_link_hash_entry *eh;
  struct bfd_link_info *info;
d2184 2
a2185 2
  eh = (struct elf32_hppa_link_hash_entry *) h;
  info = (struct bfd_link_info *) inf;
d2187 1
a2187 12
#if ! LONG_BRANCH_PIC_IN_SHLIB && LONG_BRANCH_VIA_PLT
  /* Handle the stub reloc case.  If we have a plt entry for the
     function, we won't be needing long branch stubs.  s->count will
     only be zero for stub relocs, which provides a handy way of
     flagging these relocs, and means we need do nothing special for
     the forced local and symbolic link case.  */
  if (eh->stub_reloc_sec != NULL
      && eh->elf.plt.offset != (bfd_vma) -1)
    {
      for (s = eh->reloc_entries; s != NULL; s = s->next)
	if (s->count == 0)
	  s->section->_raw_size -= sizeof (Elf32_External_Rela);
a2188 1
#endif
d2190 2
a2191 8
#if RELATIVE_DYNAMIC_RELOCS
  /* If a symbol has been forced local or we have found a regular
     definition for the symbolic link case, then we won't be needing
     any relocs.  */
  if (eh->elf.dynindx == -1
      || ((eh->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && !is_absolute_reloc (r_type)
	  && info->symbolic))
d2193 2
a2194 2
      for (s = eh->reloc_entries; s != NULL; s = s->next)
	s->section->_raw_size -= s->count * sizeof (Elf32_External_Rela);
a2195 1
#endif
d2197 1
a2197 1
  return true;
a2198 1
#endif
d2207 1
a2207 1
static boolean
d2212 26
a2237 3
  /* We only want to remove these from the dynamic symbol table.
     Therefore we do not leave ELF_LINK_FORCED_LOCAL set.  */
  if (h->type == STT_PARISC_MILLI)
d2239 11
a2249 5
      unsigned short oldflags = h->elf_link_hash_flags;
      h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
      elf32_hppa_hide_symbol (info, h);
      h->elf_link_hash_flags &= ~ELF_LINK_FORCED_LOCAL;
      h->elf_link_hash_flags |= oldflags & ELF_LINK_FORCED_LOCAL;
d2251 1
a2251 1
  return true;
d2256 1
a2256 1
static boolean
d2258 1
a2258 1
     bfd *output_bfd;
d2261 1
a2261 1
  struct elf32_hppa_link_hash_table *hplink;
d2263 1
d2265 1
a2265 2
  boolean relocs;
  boolean reltext;
d2267 2
a2268 2
  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;
d2272 1
a2272 1
  if (hplink->root.dynamic_sections_created)
a2273 2
      bfd *i;

d2285 1
a2285 1
      elf_link_hash_traverse (&hplink->root,
d2288 9
d2298 11
a2308 10
      /* Set up .got and .plt offsets for local syms.  */
      for (i = info->input_bfds; i; i = i->link_next)
	{
	  bfd_signed_vma *local_got;
	  bfd_signed_vma *end_local_got;
	  bfd_signed_vma *local_plt;
	  bfd_signed_vma *end_local_plt;
	  bfd_size_type locsymcount;
	  Elf_Internal_Shdr *symtab_hdr;
	  asection *srel;
d2310 2
a2311 2
	  if (bfd_get_flavour (i) != bfd_target_elf_flavour)
	    continue;
d2313 3
a2315 3
	  local_got = elf_local_got_refcounts (i);
	  if (!local_got)
	    continue;
d2317 4
a2320 6
	  symtab_hdr = &elf_tdata (i)->symtab_hdr;
	  locsymcount = symtab_hdr->sh_info;
	  end_local_got = local_got + locsymcount;
	  s = hplink->sgot;
	  srel = hplink->srelgot;
	  for (; local_got < end_local_got; ++local_got)
d2322 9
a2330 1
	      if (*local_got > 0)
d2332 4
a2335 4
		  *local_got = s->_raw_size;
		  s->_raw_size += GOT_ENTRY_SIZE;
		  if (info->shared)
		    srel->_raw_size += sizeof (Elf32_External_Rela);
a2336 2
	      else
		*local_got = (bfd_vma) -1;
d2338 23
d2362 12
a2373 4
	  local_plt = end_local_got;
	  end_local_plt = local_plt + locsymcount;
	  s = hplink->splt;
	  srel = hplink->srelplt;
a2387 15
  else
    {
      /* Run through the function symbols, looking for any that are
	 PIC, and allocate space for the necessary .plt entries so
	 that %r19 will be set up.  */
      if (! info->shared)
	elf_link_hash_traverse (&hplink->root,
				hppa_handle_PIC_calls,
				info);
    }

  /* Allocate global sym .plt and .got entries.  */
  elf_link_hash_traverse (&hplink->root,
			  allocate_plt_and_got,
			  info);
d2389 8
a2396 11
#if ((! LONG_BRANCH_PIC_IN_SHLIB && LONG_BRANCH_VIA_PLT) \
     || RELATIVE_DYNAMIC_RELOCS)
  /* If this is a -Bsymbolic shared link, then we need to discard all
     relocs against symbols defined in a regular object.  We also need
     to lose relocs we've allocated for long branch stubs if we know
     we won't be generating a stub.  */
  if (info->shared)
    elf_link_hash_traverse (&hplink->root,
			    hppa_discard_copies,
			    info);
#endif
d2401 1
a2401 2
  relocs = false;
  reltext = false;
a2403 2
      const char *name;

d2407 1
a2407 5
      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      if (strncmp (name, ".rela", 5) == 0)
d2409 1
a2409 28
	  if (s->_raw_size != 0)
	    {
	      asection *target;
	      const char *outname;

	      /* Remember whether there are any reloc sections other
		 than .rela.plt.  */
	      if (strcmp (name+5, ".plt") != 0)
		relocs = true;

	      /* If this relocation section applies to a read only
		 section, then we probably need a DT_TEXTREL entry.  */
	      outname = bfd_get_section_name (output_bfd,
					      s->output_section);
	      target = bfd_get_section_by_name (output_bfd, outname + 5);
	      if (target != NULL
		  && (target->flags & SEC_READONLY) != 0
		  && (target->flags & SEC_ALLOC) != 0)
		reltext = true;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else if (strcmp (name, ".plt") == 0)
	{
	  if (hplink->need_plt_stub)
d2414 1
a2414 1
	      int gotalign = bfd_section_alignment (dynobj, hplink->sgot);
d2424 1
a2424 1
      else if (strcmp (name, ".got") == 0)
d2426 14
d2465 1
a2465 1
	return false;
d2468 1
a2468 1
  if (hplink->root.dynamic_sections_created)
d2474 5
a2478 2
      if (! bfd_elf32_add_dynamic_entry (info, DT_PLTGOT, 0))
	return false;
d2485 1
a2485 1
      if (! info->shared)
d2487 2
a2488 2
	  if (! bfd_elf32_add_dynamic_entry (info, DT_DEBUG, 0))
	    return false;
d2491 1
a2491 1
      if (hplink->srelplt->_raw_size != 0)
d2493 4
a2496 4
	  if (! bfd_elf32_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_JMPREL, 0))
	    return false;
d2501 10
a2510 6
	  if (! bfd_elf32_add_dynamic_entry (info, DT_RELA, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_RELASZ, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_RELAENT,
						sizeof (Elf32_External_Rela)))
	    return false;
	}
d2512 5
a2516 5
      if (reltext)
	{
	  if (! bfd_elf32_add_dynamic_entry (info, DT_TEXTREL, 0))
	    return false;
	  info->flags |= DF_TEXTREL;
d2519 1
d2521 1
a2521 1
  return true;
d2526 3
a2528 5
/* Determine and set the size of the stub section for a final link.

   The basic idea here is to examine all the relocations looking for
   PC-relative calls to a target that is unreachable with a "bl"
   instruction.  */
d2530 2
a2531 3
boolean
elf32_hppa_size_stubs (output_bfd, stub_bfd, info, multi_subspace, group_size,
		       add_stub_section, layout_sections_again)
a2532 1
     bfd *stub_bfd;
a2533 4
     boolean multi_subspace;
     bfd_signed_vma group_size;
     asection * (*add_stub_section) PARAMS ((const char *, asection *));
     void (*layout_sections_again) PARAMS ((void));
d2536 2
d2540 2
a2541 10
  Elf_Internal_Sym *local_syms, **all_local_syms;
  unsigned int bfd_indx, bfd_count;
  int top_id, top_index;
  struct elf32_hppa_link_hash_table *hplink;
  bfd_size_type stub_group_size;
  boolean stubs_always_before_branch;
  boolean stub_changed = 0;
  boolean ret = 0;

  hplink = hppa_link_hash_table (info);
d2543 2
a2544 19
  /* Stash our params away.  */
  hplink->stub_bfd = stub_bfd;
  hplink->multi_subspace = multi_subspace;
  hplink->add_stub_section = add_stub_section;
  hplink->layout_sections_again = layout_sections_again;
  stubs_always_before_branch = group_size < 0;
  if (group_size < 0)
    stub_group_size = -group_size;
  else
    stub_group_size = group_size;
  if (stub_group_size == 1)
    {
      /* Default values.  */
      stub_group_size = 8000000;
      if (hplink->has_17bit_branch || hplink->multi_subspace)
	stub_group_size = 250000;
      if (hplink->has_12bit_branch)
	stub_group_size = 7812;
    }
d2560 1
d2562 4
a2565 4
  hplink->stub_group
    = (struct map_stub *) bfd_zmalloc (sizeof (struct map_stub) * (top_id + 1));
  if (hplink->stub_group == NULL)
    return false;
d2567 1
a2567 4
  /* Make a list of input sections for each output section included in
     the link.

     We can't use output_bfd->section_count here to find the top output
d2578 4
a2581 2
  input_list
    = (asection **) bfd_malloc (sizeof (asection *) * (top_index + 1));
d2583 1
a2583 1
    return false;
d2600 16
a2615 4
  /* Now actually build the lists.  */
  for (input_bfd = info->input_bfds;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next)
d2617 2
a2618 3
      for (section = input_bfd->sections;
	   section != NULL;
	   section = section->next)
d2620 6
a2625 15
	  if (section->output_section != NULL
	      && section->output_section->owner == output_bfd
	      && section->output_section->index <= top_index)
	    {
	      list = input_list + section->output_section->index;
	      if (*list != bfd_abs_section_ptr)
		{
		  /* Steal the link_sec pointer for our list.  */
#define PREV_SEC(sec) (hplink->stub_group[(sec)->id].link_sec)
		  /* This happens to make the list in reverse order,
		     which is what we want.  */
		  PREV_SEC (section) = *list;
		  *list = section;
		}
	    }
d2628 8
d2637 7
a2643 7
  /* See whether we can group stub sections together.  Grouping stub
     sections may result in fewer stubs.  More importantly, we need to
     put all .init* and .fini* stubs at the beginning of the .init or
     .fini output sections respectively, because glibc splits the
     _init and _fini functions into multiple parts.  Putting a stub in
     the middle of a function is not a good idea.  */
  list = input_list + top_index;
d2654 1
d2661 2
d2669 1
a2669 1
	     than 250000 bytes and thus can be handled by one stub
d2671 1
a2671 1
	     250000 bytes, in which case we may be toast.)
d2675 6
a2680 4
	     only break if stubs added total more than 12144 bytes, or
	     1518 long branch stubs.  It seems unlikely for more than
	     1518 different functions to be called, especially from
	     code only 250000 bytes long.  */
d2685 1
a2685 1
	      hplink->stub_group[tail->id].link_sec = curr;
d2689 6
a2694 3
	  /* But wait, there's more!  Input sections up to 250000
	     bytes before the stub section can be handled by it too.  */
	  if (!stubs_always_before_branch)
d2703 1
a2703 1
		  hplink->stub_group[tail->id].link_sec = curr;
d2709 2
a2710 2
  while (list-- != input_list);
  free (input_list);
d2712 16
d2732 3
a2734 3
  all_local_syms
    = (Elf_Internal_Sym **) bfd_zmalloc (sizeof (Elf_Internal_Sym *)
					 * bfd_count);
d2736 1
a2736 1
    return false;
d2741 1
a2741 1
  for (input_bfd = info->input_bfds, bfd_indx = 0;
a2745 2
      Elf_Internal_Sym *isym;
      Elf32_External_Sym *ext_syms, *esym, *end_sy;
d2752 2
a2753 4
      /* We need an array of the local symbols attached to the input bfd.
	 Unfortunately, we're going to have to read & swap them in.  */
      local_syms = (Elf_Internal_Sym *)
	bfd_malloc (symtab_hdr->sh_info * sizeof (Elf_Internal_Sym));
d2756 5
a2760 1
	  goto error_ret_free_local;
d2762 3
a2765 35
      ext_syms = (Elf32_External_Sym *)
	bfd_malloc (symtab_hdr->sh_info * sizeof (Elf32_External_Sym));
      if (ext_syms == NULL)
	{
	  goto error_ret_free_local;
	}

      if (bfd_seek (input_bfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	  || (bfd_read (ext_syms, 1,
			(symtab_hdr->sh_info * sizeof (Elf32_External_Sym)),
			input_bfd)
	      != (symtab_hdr->sh_info * sizeof (Elf32_External_Sym))))
	{
	  free (ext_syms);
	  goto error_ret_free_local;
	}

      /* Swap the local symbols in.  */
      isym = local_syms;
      esym = ext_syms;
      for (end_sy = esym + symtab_hdr->sh_info; esym < end_sy; esym++, isym++)
	bfd_elf32_swap_symbol_in (input_bfd, esym, isym);

      /* Now we can free the external symbols.  */
      free (ext_syms);

#if ! LONG_BRANCH_PIC_IN_SHLIB
      /* If this is a shared link, find all the stub reloc sections.  */
      if (info->shared)
	for (section = input_bfd->sections;
	     section != NULL;
	     section = section->next)
	  {
	    char *name;
	    asection *reloc_sec;
d2767 1
a2767 13
	    name = bfd_malloc (strlen (section->name)
			       + sizeof STUB_SUFFIX
			       + 5);
	    if (name == NULL)
	      return false;
	    sprintf (name, ".rela%s%s", section->name, STUB_SUFFIX);
	    reloc_sec = bfd_get_section_by_name (hplink->root.dynobj, name);
	    hplink->stub_group[section->id].reloc_sec = reloc_sec;
	    free (name);
	  }
#endif

      if (info->shared && hplink->multi_subspace)
d2811 1
a2811 1
		  stub_entry = hppa_stub_hash_lookup (&hplink->stub_hash_table,
d2813 1
a2813 1
						      false, false);
d2816 1
a2816 1
		      stub_entry = hppa_add_stub (stub_name, sec, hplink);
d2818 1
a2818 1
			goto error_ret_free_local;
d2829 2
a2830 2
			     bfd_get_filename (input_bfd),
			     stub_name);
d2837 74
d2913 2
d2922 2
d2930 1
a2930 1
	  local_syms = all_local_syms[bfd_indx];
a2936 2
	      Elf_Internal_Shdr *input_rel_hdr;
	      Elf32_External_Rela *external_relocs, *erelaend, *erela;
d2951 5
a2955 14
	      /* Allocate space for the external relocations.  */
	      external_relocs
		= ((Elf32_External_Rela *)
		   bfd_malloc (section->reloc_count
			       * sizeof (Elf32_External_Rela)));
	      if (external_relocs == NULL)
		{
		  goto error_ret_free_local;
		}

	      /* Likewise for the internal relocations.  */
	      internal_relocs = ((Elf_Internal_Rela *)
				 bfd_malloc (section->reloc_count
					     * sizeof (Elf_Internal_Rela)));
d2957 1
a2957 27
		{
		  free (external_relocs);
		  goto error_ret_free_local;
		}

	      /* Read in the external relocs.  */
	      input_rel_hdr = &elf_section_data (section)->rel_hdr;
	      if (bfd_seek (input_bfd, input_rel_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_read (external_relocs, 1,
			       input_rel_hdr->sh_size,
			       input_bfd) != input_rel_hdr->sh_size)
		{
		  free (external_relocs);
		error_ret_free_internal:
		  free (internal_relocs);
		  goto error_ret_free_local;
		}

	      /* Swap in the relocs.  */
	      erela = external_relocs;
	      erelaend = erela + section->reloc_count;
	      irela = internal_relocs;
	      for (; erela < erelaend; erela++, irela++)
		bfd_elf32_swap_reloca_in (input_bfd, erela, irela);

	      /* We're done with the external relocs, free them.  */
	      free (external_relocs);
d2980 4
a2983 1
		      goto error_ret_free_internal;
d3047 2
a3048 1
				     == STV_DEFAULT)))
d3065 1
a3065 1
		  id_sec = hplink->stub_group[section->id].link_sec;
d3072 1
a3072 1
		  stub_entry = hppa_stub_hash_lookup (&hplink->stub_hash_table,
d3074 1
a3074 1
						      false, false);
d3082 1
a3082 1
		  stub_entry = hppa_add_stub (stub_name, section, hplink);
d3086 1
a3086 1
		      goto error_ret_free_local;
d3096 1
a3096 2
		      else if (stub_type == hppa_stub_long_branch
			       && (LONG_BRANCH_PIC_IN_SHLIB || hash == NULL))
d3100 1
a3100 1
		  stub_changed = 1;
d3104 2
a3105 1
	      free (internal_relocs);
d3114 1
a3114 1
      for (stub_sec = hplink->stub_bfd->sections;
a3120 3
#if ! LONG_BRANCH_PIC_IN_SHLIB
      {
	int i;
d3122 1
a3122 16
	for (i = top_id; i >= 0; --i)
	  {
	    /* This will probably hit the same section many times..  */
	    stub_sec = hplink->stub_group[i].reloc_sec;
	    if (stub_sec != NULL)
	      {
		stub_sec->_raw_size = 0;
		stub_sec->_cooked_size = 0;
	      }
	  }
      }
#endif

      bfd_hash_traverse (&hplink->stub_hash_table,
			 hppa_size_one_stub,
			 hplink);
d3125 2
a3126 2
      (*hplink->layout_sections_again) ();
      stub_changed = 0;
d3129 2
a3130 1
  ret = 1;
d3133 2
a3134 6
  while (bfd_count-- > 0)
    if (all_local_syms[bfd_count])
      free (all_local_syms[bfd_count]);
  free (all_local_syms);

  return ret;
d3140 1
a3140 1
boolean
d3145 7
a3151 8
  struct elf32_hppa_link_hash_table *hplink;
  struct elf_link_hash_entry *h;
  asection *sec;
  bfd_vma gp_val;

  hplink = hppa_link_hash_table (info);
  h = elf_link_hash_lookup (&hplink->root, "$global$",
			    false, false, false);
d3154 2
a3155 2
      && (h->root.type == bfd_link_hash_defined
	  || h->root.type == bfd_link_hash_defweak))
d3157 2
a3158 2
      gp_val = h->root.u.def.value;
      sec = h->root.u.def.section;
d3162 16
d3186 1
a3186 2

      sec = hplink->splt;
d3190 1
a3190 2
	  if (gp_val > 0x2000
	      || (hplink->sgot && hplink->sgot->_raw_size > 0x2000))
d3197 1
a3197 2
	  gp_val = 0;
	  sec = hplink->sgot;
d3214 2
a3215 2
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.value = gp_val;
d3217 1
a3217 1
	    h->root.u.def.section = sec;
d3219 1
a3219 1
	    h->root.u.def.section = bfd_abs_section_ptr;
d3227 1
a3227 1
  return true;
d3236 1
a3236 1
boolean
d3242 1
a3242 1
  struct elf32_hppa_link_hash_table *hplink;
d3244 1
a3244 1
  hplink = hppa_link_hash_table (info);
d3246 1
a3246 1
  for (stub_sec = hplink->stub_bfd->sections;
d3250 1
a3250 1
      size_t size;
d3254 1
a3254 2
      stub_sec->contents = (unsigned char *) bfd_zalloc (hplink->stub_bfd,
							 size);
d3256 1
a3256 1
	return false;
d3261 1
a3261 1
  table = &hplink->stub_hash_table;
d3264 1
a3264 1
  return true;
d3269 1
a3269 1
static boolean
a3273 2
  asection *s;

d3276 1
a3276 1
    return false;
d3279 2
a3280 24
     unwind section.  Magic section names, but this is much safer than
     having elf32_hppa_relocate_section remember where SEGREL32 relocs
     occurred.  Consider what happens if someone inept creates a
     linker script that puts unwind information in .text.  */
  s = bfd_get_section_by_name (abfd, ".PARISC.unwind");
  if (s != NULL)
    {
      bfd_size_type size;
      char *contents;

      size = s->_raw_size;
      contents = bfd_malloc (size);
      if (contents == NULL)
	return false;

      if (! bfd_get_section_contents (abfd, s, contents, (file_ptr) 0, size))
	return false;

      qsort (contents, size / 16, 16, hppa_unwind_entry_compare);

      if (! bfd_set_section_contents (abfd, s, contents, (file_ptr) 0, size))
	return false;
    }
  return true;
d3291 1
a3291 1
  struct elf32_hppa_link_hash_table *hplink;
d3293 1
a3293 1
  hplink = (struct elf32_hppa_link_hash_table *) data;
d3301 2
a3302 2
	  if (value < hplink->text_segment_base)
	    hplink->text_segment_base = value;
d3306 2
a3307 2
	  if (value < hplink->data_segment_base)
	    hplink->data_segment_base = value;
d3315 1
a3315 1
final_link_relocate (input_section, contents, rel, value, hplink, sym_sec, h)
d3320 1
a3320 1
     struct elf32_hppa_link_hash_table *hplink;
d3353 2
a3354 5
      /* If this is a call to a function defined in another dynamic
	 library, or if it is a call to a PIC function in the same
	 object, or if this is a shared link and it is a call to a
	 weak symbol which may or may not be in the same object, then
	 find the import stub in the stub hash.  */
d3358 3
a3360 5
	      && ((h->maybe_pic_call
		   && !(input_section->flags & SEC_HAS_GOT_REF))
		  || (h->elf.root.type == bfd_link_hash_defweak
		      && h->elf.dynindx != -1
		      && h->elf.plt.offset != (bfd_vma) -1))))
d3363 1
a3363 1
					    h, rel, hplink);
d3383 1
a3383 1
	    return bfd_reloc_notsupported;
d3401 5
a3405 4
       section.  If it's a code section, then "data pointer relative" makes
       no sense.  In that case we don't adjust the "value", and for 21 bit
       addil instructions, we change the source addend register from %dp to
       %r0.  This situation commonly arises when a variable's "constness"
d3408 1
a3408 3
      if (sym_sec == NULL)
	break;
      if ((sym_sec->flags & SEC_CODE) != 0)
d3414 1
a3414 1
#if 1 /* debug them.  */
d3417 1
a3417 1
		 bfd_get_filename (input_bfd),
d3437 1
a3437 1
	value -= hplink->text_segment_base;
d3439 1
a3439 1
	value -= hplink->data_segment_base;
d3461 6
a3467 1
    case R_PARISC_PCREL21L:
a3468 2
    case R_PARISC_PLABEL21L:
    case R_PARISC_DLTIND21L:
a3471 1
    case R_PARISC_DIR17R:
a3472 1
    case R_PARISC_DIR14R:
a3473 1
    case R_PARISC_DPREL14R:
d3476 6
d3514 1
a3514 1
					    h, rel, hplink);
d3516 1
a3516 1
	    return bfd_reloc_notsupported;
d3539 1
a3539 1
	 bfd_get_filename (input_bfd),
d3543 1
d3578 1
a3578 1
static boolean
a3589 1
  bfd *dynobj;
d3591 1
a3591 1
  struct elf32_hppa_link_hash_table *hplink;
d3595 3
a3597 1
  asection *sreloc;
d3601 1
a3601 2
  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;
a3602 1
  sreloc = NULL;
d3617 2
a3618 1
      boolean plabel;
d3624 1
a3624 1
	  return false;
d3630 1
a3631 20

      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sym_sec = local_sections[r_symndx];
		  rel->r_addend += sym_sec->output_offset;
		}
	    }
	  continue;
	}

      /* This is a final link.  */
d3635 1
d3641 1
a3641 4
	  relocation = ((ELF_ST_TYPE (sym->st_info) == STT_SECTION
			   ? 0 : sym->st_value)
			 + sym_sec->output_offset
			 + sym_sec->output_section->vma);
d3669 2
a3670 1
	  else if (info->shared && !info->no_undefined
d3673 1
a3673 7
	    {
	      if (info->symbolic)
		if (!((*info->callbacks->undefined_symbol)
		      (info, h->elf.root.root.string, input_bfd,
		       input_section, rel->r_offset, false)))
		  return false;
	    }
d3678 3
a3680 2
		     input_section, rel->r_offset, true)))
		return false;
d3693 3
a3695 6
	  /* Relocation is to the entry for this symbol in the global
	     offset table.  */
	  if (h != NULL)
	    {
	      bfd_vma off;
	      boolean dyn;
d3697 5
a3701 3
	      off = h->elf.got.offset;
	      if (off == (bfd_vma) -1)
		abort ();
d3703 38
a3740 24
	      dyn = hplink->root.dynamic_sections_created;
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, &h->elf))
		{
		  /* This is actually a static link, or it is a
		     -Bsymbolic link and the symbol is defined
		     locally, or the symbol was forced to be local
		     because of a version file.  We must initialize
		     this entry in the global offset table.  Since the
		     offset must always be a multiple of 4, we use the
		     least significant bit to record whether we have
		     initialized it already.

		     When doing a dynamic link, we create a .rela.got
		     relocation entry to initialize the value.  This
		     is done in the finish_dynamic_symbol routine.  */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
		      bfd_put_32 (output_bfd, relocation,
				  hplink->sgot->contents + off);
		      h->elf.got.offset |= 1;
		    }
		}
d3742 21
a3762 18
	      relocation = off;
	    }
	  else
	    {
	      /* Local symbol case.  */
	      bfd_vma off;

	      if (local_got_offsets == NULL
		  || (off = local_got_offsets[r_symndx]) == (bfd_vma) -1)
		abort ();

	      /* The offset must always be a multiple of 4.  We use
		 the least significant bit to record whether we have
		 already generated the necessary reloc.  */
	      if ((off & 1) != 0)
		off &= ~1;
	      else
		{
d3764 2
a3765 1
			      hplink->sgot->contents + off);
d3767 2
a3768 8
		  if (info->shared)
		    {
		      /* Output a dynamic relocation for this GOT
			 entry.  In this case it is relative to the
			 base of the object because the symbol index
			 is zero.  */
		      Elf_Internal_Rela outrel;
		      asection *srelgot = hplink->srelgot;
d3770 5
a3774 21
		      outrel.r_offset = (off
					 + hplink->sgot->output_offset
					 + hplink->sgot->output_section->vma);
		      outrel.r_info = ELF32_R_INFO (0, R_PARISC_DIR32);
		      outrel.r_addend = relocation;
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
						 ((Elf32_External_Rela *)
						  srelgot->contents
						  + srelgot->reloc_count));
		      ++srelgot->reloc_count;
		    }

		  local_got_offsets[r_symndx] |= 1;
		}

	      relocation = off;
	    }

	  /* Add the base of the GOT to the relocation value.  */
	  relocation += (hplink->sgot->output_offset
			 + hplink->sgot->output_section->vma);
d3780 2
a3781 4
	  if (hplink->text_segment_base == (bfd_vma) -1)
	    bfd_map_over_sections (output_bfd,
				   hppa_record_segment_addr,
				   hplink);
d3787 1
a3787 1
	  if (hplink->root.dynamic_sections_created)
d3790 1
d3801 1
a3801 1
			 need to write out the plt entry here.  */ 
a3805 6
			  bfd_put_32 (output_bfd,
				      relocation,
				      hplink->splt->contents + off);
			  bfd_put_32 (output_bfd,
				      elf_gp (hplink->splt->output_section->owner),
				      hplink->splt->contents + off + 4);
d3807 1
d3813 1
a3813 1
		  int indx;
d3815 5
a3819 2
		  indx = r_symndx + symtab_hdr->sh_info;
		  off = local_got_offsets[indx];
d3828 26
d3856 1
a3856 1
				  hplink->splt->contents + off);
d3858 2
a3859 23
				  elf_gp (hplink->splt->output_section->owner),
				  hplink->splt->contents + off + 4);

		      if (info->shared)
			{
			  /* Output a dynamic IPLT relocation for this
			     PLT entry.  */
			  Elf_Internal_Rela outrel;
			  asection *srelplt = hplink->srelplt;

			  outrel.r_offset = (off
					     + hplink->splt->output_offset
					     + hplink->splt->output_section->vma);
			  outrel.r_info = ELF32_R_INFO (0, R_PARISC_IPLT);
			  outrel.r_addend = relocation;
			  bfd_elf32_swap_reloca_out (output_bfd, &outrel,
						     ((Elf32_External_Rela *)
						      srelplt->contents
						      + srelplt->reloc_count));
			  ++srelplt->reloc_count;
			}

		      local_got_offsets[indx] |= 1;
d3863 1
a3863 1
	      if (off >= (bfd_vma) -2 || (off & 1) != 0)
d3877 2
a3878 2
				+ hplink->splt->output_offset
				+ hplink->splt->output_section->vma
d3894 7
d3902 28
a3929 17
	     expression must match the code in check_relocs and
	     hppa_discard_copies.  ie. We need exactly the same
	     condition as in check_relocs, with some extra conditions
	     (dynindx test in this case) to cater for relocs removed
	     by hppa_discard_copies.  */
	  if ((input_section->flags & SEC_ALLOC) != 0
	      && info->shared
#if RELATIVE_DYNAMIC_RELOCS
	      && (is_absolute_reloc (r_type)
		  || ((!info->symbolic
		       || (h != NULL
			   && ((h->elf.elf_link_hash_flags
				& ELF_LINK_HASH_DEF_REGULAR) == 0
			       || h->elf.root.type == bfd_link_hash_defweak)))
		      && (h == NULL || h->elf.dynindx != -1)))
#endif
	      )
d3932 3
a3934 1
	      boolean skip;
a3939 16
	      if (sreloc == NULL)
		{
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
		    return false;
		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    abort ();
		}

	      outrel.r_offset = rel->r_offset;
d3941 5
a3945 15
	      skip = false;
	      if (elf_section_data (input_section)->stab_info != NULL)
		{
		  bfd_vma off;

		  off = (_bfd_stab_section_offset
			 (output_bfd, &hplink->root.stab_info,
			  input_section,
			  &elf_section_data (input_section)->stab_info,
			  rel->r_offset));
		  if (off == (bfd_vma) -1)
		    skip = true;
		  outrel.r_offset = off;
		}

d3956 2
d3992 10
d4003 3
a4005 5
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
					 ((Elf32_External_Rela *)
					  sreloc->contents
					  + sreloc->reloc_count));
	      ++sreloc->reloc_count;
d4014 1
a4014 1
			       hplink, sym_sec, h);
d4027 1
a4027 1
	    return false;
d4036 12
a4047 7
	  (*_bfd_error_handler)
	    (_("%s(%s+0x%lx): cannot handle %s for %s"),
	     bfd_get_filename (input_bfd),
	     input_section->name,
	     (long) rel->r_offset,
	     howto->name,
	     sym_name);
d4054 1
a4054 1
	    return false;
d4058 1
a4058 27
  return true;
}

/* Comparison function for qsort to sort unwind section during a
   final link.  */

static int
hppa_unwind_entry_compare (a, b)
     const PTR a;
     const PTR b;
{
  const bfd_byte *ap, *bp;
  unsigned long av, bv;

  ap = (const bfd_byte *) a;
  av = (unsigned long) ap[0] << 24;
  av |= (unsigned long) ap[1] << 16;
  av |= (unsigned long) ap[2] << 8;
  av |= (unsigned long) ap[3];

  bp = (const bfd_byte *) b;
  bv = (unsigned long) bp[0] << 24;
  bv |= (unsigned long) bp[1] << 16;
  bv |= (unsigned long) bp[2] << 8;
  bv |= (unsigned long) bp[3];

  return av < bv ? -1 : av > bv ? 1 : 0;
d4064 1
a4064 1
static boolean
d4071 1
a4071 2
  struct elf32_hppa_link_hash_table *hplink;
  bfd *dynobj;
d4073 1
a4073 2
  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;
d4102 1
d4106 4
a4109 14
			  + hplink->splt->output_offset
			  + hplink->splt->output_section->vma);
	  if (! ((struct elf32_hppa_link_hash_entry *) h)->plt_abs
	      && h->dynindx != -1)
	    {
	      /* To support lazy linking, the function pointer is
		 initialised to point to a special stub stored at the
		 end of the .plt.  This is not done for plt entries
		 with a base-relative dynamic relocation.  */
	      value = (hplink->splt->output_offset
		       + hplink->splt->output_section->vma
		       + hplink->splt->_raw_size
		       - sizeof (plt_stub)
		       + PLT_STUB_ENTRY);
d4121 6
a4126 17
	  bfd_elf32_swap_reloca_out (hplink->splt->output_section->owner,
				     &rel,
				     ((Elf32_External_Rela *)
				      hplink->srelplt->contents
				      + hplink->srelplt->reloc_count));
	  hplink->srelplt->reloc_count++;
	}

      bfd_put_32 (hplink->splt->owner,
		  value,
		  hplink->splt->contents + h->plt.offset);
      bfd_put_32 (hplink->splt->owner,
		  elf_gp (hplink->splt->output_section->owner),
		  hplink->splt->contents + h->plt.offset + 4);
      if (PLABEL_PLT_ENTRY_SIZE != PLT_ENTRY_SIZE
	  && ((struct elf32_hppa_link_hash_entry *) h)->plabel
	  && h->dynindx != -1)
d4128 6
a4133 2
	  memset (hplink->splt->contents + h->plt.offset + 8,
		  0, PLABEL_PLT_ENTRY_SIZE - PLT_ENTRY_SIZE);
d4147 1
d4153 2
a4154 2
		      + hplink->sgot->output_offset
		      + hplink->sgot->output_section->vma);
d4175 1
a4175 1
		      hplink->sgot->contents + h->got.offset);
d4180 3
a4182 5
      bfd_elf32_swap_reloca_out (output_bfd, &rel,
				 ((Elf32_External_Rela *)
				  hplink->srelgot->contents
				  + hplink->srelgot->reloc_count));
      ++hplink->srelgot->reloc_count;
d4189 1
d4198 1
a4198 1
      s = hplink->srelbss;
d4205 2
a4206 4
      bfd_elf32_swap_reloca_out (output_bfd, &rel,
				 ((Elf32_External_Rela *) s->contents
				  + s->reloc_count));
      ++s->reloc_count;
d4217 22
a4238 1
  return true;
d4243 1
a4243 1
static boolean
d4249 1
a4249 1
  struct elf32_hppa_link_hash_table *hplink;
d4252 2
a4253 2
  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;
d4257 1
a4257 1
  if (hplink->root.dynamic_sections_created)
d4276 1
a4276 1
	      break;
a4280 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d4284 1
a4284 1
	      s = hplink->srelplt;
a4285 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d4289 23
a4311 6
	      s = hplink->srelplt;
	      if (s->_cooked_size != 0)
		dyn.d_un.d_val = s->_cooked_size;
	      else
		dyn.d_un.d_val = s->_raw_size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d4314 2
d4319 1
a4319 1
  if (hplink->sgot->_raw_size != 0)
d4327 1
a4327 1
		  hplink->sgot->contents);
d4330 1
a4330 1
      memset (hplink->sgot->contents + GOT_ENTRY_SIZE, 0, GOT_ENTRY_SIZE);
d4333 1
a4333 1
      elf_section_data (hplink->sgot->output_section)
d4337 1
a4337 1
  if (hplink->splt->_raw_size != 0)
d4340 1
a4340 1
      elf_section_data (hplink->splt->output_section)
d4343 1
a4343 1
      if (hplink->need_plt_stub)
d4346 2
a4347 2
	  memcpy (hplink->splt->contents
		  + hplink->splt->_raw_size - sizeof (plt_stub),
d4350 5
a4354 5
	  if ((hplink->splt->output_offset
	       + hplink->splt->output_section->vma
	       + hplink->splt->_raw_size)
	      != (hplink->sgot->output_offset
		  + hplink->sgot->output_section->vma))
d4358 1
a4358 1
	      return false;
d4363 1
a4363 1
  return true;
d4409 1
d4412 1
d4427 1
d4430 1
d4436 1
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d5 1
a5 2
   Written by

d9 1
d36 1
d38 10
d49 1
a49 2
/* We use three different hash tables to hold information for
   linking PA ELF objects.
d57 1
a57 1
   necessary to build the linker stubs during a link.  */
d59 1
a59 1
/* Hash table for linker stubs.  */
d61 61
a121 1
struct elf32_hppa_stub_hash_entry
d123 46
a168 3
  /* Base hash table entry structure, we can get the name of the stub
     (and thus know exactly what actions it performs) from the base
     hash table entry.  */
d171 10
a180 2
  /* Offset of the beginning of this stub.  */
  bfd_vma offset;
d184 1
a184 1
  symvalue target_value;
d186 9
d197 29
a225 4
struct elf32_hppa_stub_hash_table
{
  /* The hash table itself.  */
  struct bfd_hash_table root;
d227 2
a228 2
  /* The stub BFD.  */
  bfd *stub_bfd;
d230 3
a232 2
  /* Where to place the next stub.  */
  bfd_byte *location;
d234 2
a235 2
  /* Current offset in the stub section.  */
  unsigned int offset;
d237 3
d242 1
a242 4
struct elf32_hppa_link_hash_entry
{
  struct elf_link_hash_entry root;
};
a243 2
struct elf32_hppa_link_hash_table
{
d248 4
a251 1
  struct elf32_hppa_stub_hash_table *stub_hash_table;
d253 38
a290 2
  /* A count of the number of output symbols.  */
  unsigned int output_symbol_count;
d292 2
a293 3
  /* Stuff so we can handle DP relative relocations.  */
  long global_value;
  int global_sym_defined;
d296 35
a330 1
/* ELF32/HPPA relocation support
d332 2
a333 3
	This file contains ELF32/HPPA relocation support as specified
	in the Stratus FTX/Golf Object File Format (SED-1762) dated
	February 1994.  */
d335 2
a336 2
#include "elf32-hppa.h"
#include "hppa_stubs.h"
d338 2
a339 3
static unsigned long hppa_elf_relocate_insn
  PARAMS ((bfd *, asection *, unsigned long, unsigned long, long,
	   long, unsigned long, unsigned long, unsigned long));
d345 6
a350 4
static bfd_reloc_status_type elf32_hppa_bfd_final_link_relocate
  PARAMS ((reloc_howto_type *, bfd *, bfd *, asection *,
	   bfd_byte *, bfd_vma, bfd_vma, bfd_vma, struct bfd_link_info *,
	   asection *, const char *, int));
d352 25
a376 2
static struct bfd_link_hash_table *elf32_hppa_link_hash_table_create
  PARAMS ((bfd *));
d378 2
a379 3
static struct bfd_hash_entry *
elf32_hppa_stub_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d381 2
a382 4
static boolean
elf32_hppa_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *,
	   bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
d384 2
a385 6
static boolean
elf32_hppa_stub_hash_table_init
  PARAMS ((struct elf32_hppa_stub_hash_table *, bfd *,
	   struct bfd_hash_entry *(*) PARAMS ((struct bfd_hash_entry *,
					       struct bfd_hash_table *,
					       const char *))));
d387 2
a388 2
static boolean
elf32_hppa_build_one_stub PARAMS ((struct bfd_hash_entry *, PTR));
d390 4
a393 2
static unsigned int elf32_hppa_size_of_stub
  PARAMS ((bfd_vma, bfd_vma, const char *));
d395 3
a397 2
static void elf32_hppa_name_of_stub
  PARAMS ((bfd_vma, bfd_vma, char *));
d399 2
a400 4
/* For linker stub hash tables.  */
#define elf32_hppa_stub_hash_lookup(table, string, create, copy) \
  ((struct elf32_hppa_stub_hash_entry *) \
   bfd_hash_lookup (&(table)->root, (string), (create), (copy)))
d402 3
a404 18
#define elf32_hppa_stub_hash_traverse(table, func, info) \
  (bfd_hash_traverse \
   (&(table)->root, \
    (boolean (*) PARAMS ((struct bfd_hash_entry *, PTR))) (func), \
    (info)))

/* For HPPA linker hash table.  */

#define elf32_hppa_link_hash_lookup(table, string, create, copy, follow)\
  ((struct elf32_hppa_link_hash_entry *)				\
   elf_link_hash_lookup (&(table)->root, (string), (create),		\
			 (copy), (follow)))

#define elf32_hppa_link_hash_traverse(table, func, info)		\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
    (info)))
d406 2
a407 1
/* Get the PA ELF linker hash table from a link_info structure.  */
d409 2
a410 2
#define elf32_hppa_hash_table(p) \
  ((struct elf32_hppa_link_hash_table *) ((p)->hash))
d412 2
d420 1
a420 1
elf32_hppa_stub_hash_newfunc (entry, table, string)
d432 7
a438 5
    ret = ((struct elf32_hppa_stub_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct elf32_hppa_stub_hash_entry)));
  if (ret == NULL)
    return NULL;
d447 5
a451 1
      ret->offset = 0;
d454 3
d462 43
a504 1
/* Initialize a stub hash table.  */
d506 1
a506 12
static boolean
elf32_hppa_stub_hash_table_init (table, stub_bfd, newfunc)
     struct elf32_hppa_stub_hash_table *table;
     bfd *stub_bfd;
     struct bfd_hash_entry *(*newfunc) PARAMS ((struct bfd_hash_entry *,
						struct bfd_hash_table *,
						const char *));
{
  table->offset = 0;
  table->location = 0;
  table->stub_bfd = stub_bfd;
  return (bfd_hash_table_init (&table->root, newfunc));
d519 1
a519 2
  ret = ((struct elf32_hppa_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct elf32_hppa_link_hash_table)));
d522 2
a523 2
  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
				      _bfd_elf_link_hash_newfunc))
d528 21
a548 4
  ret->stub_hash_table = NULL;
  ret->output_symbol_count = 0;
  ret->global_value = 0;
  ret->global_sym_defined = 0;
d553 42
a594 1
/* Relocate the given INSN given the various input parameters.
d596 27
a622 1
   FIXME: endianness and sizeof (long) issues abound here.  */
d624 14
a637 56
static unsigned long
hppa_elf_relocate_insn (abfd, input_sect, insn, address, sym_value,
			r_addend, r_format, r_field, pcrel)
     bfd *abfd;
     asection *input_sect;
     unsigned long insn;
     unsigned long address;
     long sym_value;
     long r_addend;
     unsigned long r_format;
     unsigned long r_field;
     unsigned long pcrel;
{
  unsigned char opcode = get_opcode (insn);
  long constant_value;

  switch (opcode)
    {
    case LDO:
    case LDB:
    case LDH:
    case LDW:
    case LDWM:
    case STB:
    case STH:
    case STW:
    case STWM:
    case COMICLR:
    case SUBI:
    case ADDIT:
    case ADDI:
    case LDIL:
    case ADDIL:
      constant_value = HPPA_R_CONSTANT (r_addend);

      if (pcrel)
	sym_value -= address;

      sym_value = hppa_field_adjust (sym_value, constant_value, r_field);
      return hppa_rebuild_insn (abfd, insn, sym_value, r_format);

    case BL:
    case BE:
    case BLE:
      /* XXX computing constant_value is not needed??? */
      constant_value = assemble_17 ((insn & 0x001f0000) >> 16,
				    (insn & 0x00001ffc) >> 2,
				    insn & 1);

      constant_value = (constant_value << 15) >> 15;
      if (pcrel)
	{
	  sym_value -=
	    address + input_sect->output_offset
	    + input_sect->output_section->vma;
	  sym_value = hppa_field_adjust (sym_value, -8, r_field);
d640 7
a646 1
	sym_value = hppa_field_adjust (sym_value, constant_value, r_field);
d648 5
a652 1
      return hppa_rebuild_insn (abfd, insn, sym_value >> 2, r_format);
d654 16
a669 2
    default:
      if (opcode == 0)
d671 28
a698 1
	  constant_value = HPPA_R_CONSTANT (r_addend);
d700 66
a765 2
	  if (pcrel)
	    sym_value -= address;
d767 11
a777 1
	  return hppa_field_adjust (sym_value, constant_value, r_field);
d780 2
a781 1
	abort ();
d783 1
d786 38
a823 1
/* Relocate an HPPA ELF section.  */
d826 3
a828 10
elf32_hppa_relocate_section (output_bfd, info, input_bfd, input_section,
			     contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d830 22
a851 3
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
d853 1
a853 1
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
d855 1
a855 3
  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
d857 16
a872 9
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      Elf_Internal_Sym *sym;
      asection *sym_sec;
      bfd_vma relocation;
      bfd_reloc_status_type r;
      const char *sym_name;
d874 2
a875 2
      r_type = ELF32_R_TYPE (rel->r_info);
      if (r_type < 0 || r_type >= (int) R_PARISC_UNIMPLEMENTED)
d877 7
a883 4
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}
      howto = elf_hppa_howto_table + r_type;
d885 11
a895 1
      r_symndx = ELF32_R_SYM (rel->r_info);
d897 2
a898 7
      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
d900 5
a904 6
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sym_sec = local_sections[r_symndx];
		  rel->r_addend += sym_sec->output_offset;
		}
d907 10
a916 1
	  continue;
d918 55
d974 1
a974 5
      /* This is a final link.  */
      h = NULL;
      sym = NULL;
      sym_sec = NULL;
      if (r_symndx < symtab_hdr->sh_info)
d976 10
a985 6
	  sym = local_syms + r_symndx;
	  sym_sec = local_sections[r_symndx];
	  relocation = ((ELF_ST_TYPE (sym->st_info) == STT_SECTION
			   ? 0 : sym->st_value)
			 + sym_sec->output_offset
			 + sym_sec->output_section->vma);
d989 7
a995 1
	  long indx;
d997 32
a1028 23
	  indx = r_symndx - symtab_hdr->sh_info;
	  h = elf_sym_hashes (input_bfd)[indx];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sym_sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sym_sec->output_offset
			    + sym_sec->output_section->vma);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    relocation = 0;
	  else
	    {
	      if (!((*info->callbacks->undefined_symbol)
		    (info, h->root.root.string, input_bfd,
		     input_section, rel->r_offset, true)))
		return false;
	      break;
	    }
d1030 1
d1032 12
a1043 3
      if (h != NULL)
	sym_name = h->root.root.string;
      else
d1045 8
a1052 7
	  sym_name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
						      sym->st_name);
	  if (sym_name == NULL)
	    return false;
	  if (*sym_name == '\0')
	    sym_name = bfd_section_name (input_bfd, sym_sec);
d1055 23
a1077 57
      r = elf32_hppa_bfd_final_link_relocate (howto, input_bfd, output_bfd,
					      input_section, contents,
					      rel->r_offset, relocation,
					      rel->r_addend, info, sym_sec,
					      sym_name, h == NULL);

      if (r != bfd_reloc_ok)
	{
	  switch (r)
	    {
	    /* This can happen for DP relative relocs if $global$ is
	       undefined.  This is a panic situation so we don't try
	       to continue.  */
	    case bfd_reloc_undefined:
	    case bfd_reloc_notsupported:
	      if (!((*info->callbacks->undefined_symbol)
		    (info, "$global$", input_bfd,
		     input_section, rel->r_offset, true)))
		return false;
	      return false;
	    case bfd_reloc_dangerous:
	      {
		/* We use this return value to indicate that we performed
		   a "dangerous" relocation.  This doesn't mean we did
		   the wrong thing, it just means there may be some cleanup
		   that needs to be done here.

		   In particular we had to swap the last call insn and its
		   delay slot.  If the delay slot insn needed a relocation,
		   then we'll need to adjust the next relocation entry's
		   offset to account for the fact that the insn moved.

		   This hair wouldn't be necessary if we inserted stubs
		   between procedures and used a "bl" to get to the stub.  */
		if (rel != relend)
		  {
		    Elf_Internal_Rela *next_rel = rel + 1;

		    if (rel->r_offset + 4 == next_rel->r_offset)
		      next_rel->r_offset -= 4;
		  }
		break;
	      }
	    default:
	    case bfd_reloc_outofrange:
	    case bfd_reloc_overflow:
	      {
		if (!((*info->callbacks->reloc_overflow)
		      (info, sym_name, howto->name, (bfd_vma) 0,
			input_bfd, input_section, rel->r_offset)))
		  return false;
	      }
	      break;
	    }
	}
    }

d1081 24
a1104 2
/* Actually perform a relocation as part of a final link.  This can get
   rather hairy when linker stubs are needed.  */
d1106 4
a1109 16
static bfd_reloc_status_type
elf32_hppa_bfd_final_link_relocate (howto, input_bfd, output_bfd,
				    input_section, contents, offset, value,
				    addend, info, sym_sec, sym_name, is_local)
     reloc_howto_type *howto;
     bfd *input_bfd;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd_byte *contents;
     bfd_vma offset;
     bfd_vma value;
     bfd_vma addend;
     struct bfd_link_info *info;
     asection *sym_sec;
     const char *sym_name;
     int is_local;
d1111 7
a1117 6
  unsigned long insn;
  unsigned long r_type = howto->type;
  unsigned long r_format = howto->bitsize;
  unsigned long r_field = e_fsel;
  bfd_byte *hit_data = contents + offset;
  boolean r_pcrel = howto->pc_relative;
d1119 7
a1125 27
  insn = bfd_get_32 (input_bfd, hit_data);

  /* Make sure we have a value for $global$.  FIXME isn't this effectively
     just like the gp pointer on MIPS?  Can we use those routines for this
     purpose?  */
  if (!elf32_hppa_hash_table (info)->global_sym_defined)
    {
      struct elf_link_hash_entry *h;
      asection *sec;

      h = elf_link_hash_lookup (elf_hash_table (info), "$global$", false,
				 false, false);

      /* If there isn't a $global$, then we're in deep trouble.  */
      if (h == NULL)
	return bfd_reloc_notsupported;

      /* If $global$ isn't a defined symbol, then we're still in deep
	 trouble.  */
      if (h->root.type != bfd_link_hash_defined)
	return bfd_reloc_undefined;

      sec = h->root.u.def.section;
      elf32_hppa_hash_table (info)->global_value = (h->root.u.def.value
						    + sec->output_section->vma
						    + sec->output_offset);
      elf32_hppa_hash_table (info)->global_sym_defined = 1;
d1127 5
a1131 2

  switch (r_type)
d1133 2
a1134 32
    case R_PARISC_NONE:
      break;

    case R_PARISC_DIR32:
    case R_PARISC_DIR17F:
    case R_PARISC_PCREL17C:
      r_field = e_fsel;
      goto do_basic_type_1;
    case R_PARISC_DIR21L:
    case R_PARISC_PCREL21L:
      r_field = e_lrsel;
      goto do_basic_type_1;
    case R_PARISC_DIR17R:
    case R_PARISC_PCREL17R:
    case R_PARISC_DIR14R:
    case R_PARISC_PCREL14R:
      r_field = e_rrsel;
      goto do_basic_type_1;

    /* For all the DP relative relocations, we need to examine the symbol's
       section.  If it's a code section, then "data pointer relative" makes
       no sense.  In that case we don't adjust the "value", and for 21 bit
       addil instructions, we change the source addend register from %dp to
       %r0.  */
    case R_PARISC_DPREL21L:
      r_field = e_lrsel;
      if (sym_sec->flags & SEC_CODE)
	{
	  if ((insn & 0xfc000000) >> 26 == 0xa
	       && (insn & 0x03e00000) >> 21 == 0x1b)
	    insn &= ~0x03e00000;
	}
d1136 2
a1137 12
	value -= elf32_hppa_hash_table (info)->global_value;
      goto do_basic_type_1;
    case R_PARISC_DPREL14R:
      r_field = e_rrsel;
      if ((sym_sec->flags & SEC_CODE) == 0)
	value -= elf32_hppa_hash_table (info)->global_value;
      goto do_basic_type_1;
    case R_PARISC_DPREL14F:
      r_field = e_fsel;
      if ((sym_sec->flags & SEC_CODE) == 0)
	value -= elf32_hppa_hash_table (info)->global_value;
      goto do_basic_type_1;
d1139 3
a1141 61
    /* These cases are separate as they may involve a lot more work
       to deal with linker stubs.  */
    case R_PARISC_PLABEL32:
    case R_PARISC_PLABEL21L:
    case R_PARISC_PLABEL14R:
    case R_PARISC_PCREL17F:
      {
	bfd_vma location;
	unsigned int len;
	char *new_name, *stub_name;

	/* Get the field selector right.  We'll need it in a minute.  */
	if (r_type == R_PARISC_PCREL17F
	    || r_type == R_PARISC_PLABEL32)
	  r_field = e_fsel;
	else if (r_type == R_PARISC_PLABEL21L)
	  r_field = e_lrsel;
	else if (r_type == R_PARISC_PLABEL14R)
	  r_field = e_rrsel;

	/* Find out where we are and where we're going.  */
	location = (offset +
		    input_section->output_offset +
		    input_section->output_section->vma);

	len = strlen (sym_name) + 1;
	if (is_local)
	  len += 9;
	new_name = bfd_malloc (len);
	if (!new_name)
	  return bfd_reloc_notsupported;
	strcpy (new_name, sym_name);

	/* Local symbols have unique IDs.  */
	if (is_local)
	  sprintf (new_name + len - 10, "_%08x", (int)sym_sec);

	/* Any kind of linker stub needed?  */
	if (((int)(value - location) > 0x3ffff)
	    || ((int)(value - location) < (int)0xfffc0000))
	  {
	    struct elf32_hppa_stub_hash_table *stub_hash_table;
	    struct elf32_hppa_stub_hash_entry *stub_hash;
	    asection *stub_section;

	    /* Build a name for the stub.  */

	    len = strlen (new_name);
	    len += 23;
	    stub_name = bfd_malloc (len);
	    if (!stub_name)
	      return bfd_reloc_notsupported;
	    elf32_hppa_name_of_stub (location, value, stub_name);
	    strcat (stub_name, new_name);
	    free (new_name);

	    stub_hash_table = elf32_hppa_hash_table (info)->stub_hash_table;

	    stub_hash
	      = elf32_hppa_stub_hash_lookup (stub_hash_table, stub_name,
					     false, false);
d1143 2
a1144 2
	    /* We're done with that name.  */
	    free (stub_name);
d1146 6
a1151 2
	    /* The stub BFD only has one section.  */
	    stub_section = stub_hash_table->stub_bfd->sections;
d1153 11
a1163 79
	    if (stub_hash != NULL)
	      {
		if (r_type == R_PARISC_PCREL17F)
		  {
		    unsigned long delay_insn;
		    unsigned int opcode, rtn_reg, ldo_target_reg, ldo_src_reg;

		    /* We'll need to peek at the next insn.  */
		    delay_insn = bfd_get_32 (input_bfd, hit_data + 4);
		    opcode = get_opcode (delay_insn);

		    /* We also need to know the return register for this
		       call.  */
		    rtn_reg = (insn & 0x03e00000) >> 21;

		    ldo_src_reg = (delay_insn & 0x03e00000) >> 21;
		    ldo_target_reg = (delay_insn & 0x001f0000) >> 16;

		    /* Munge up the value and other parameters for
		       hppa_elf_relocate_insn.  */

		    value = (stub_hash->offset
			     + stub_section->output_offset
			     + stub_section->output_section->vma);

		    r_format = 17;
		    r_field = e_fsel;
		    r_pcrel = 0;
		    addend = 0;

		    /* We need to peek at the delay insn and determine if
		       we'll need to swap the branch and its delay insn.  */
		    if ((insn & 2)
			|| (opcode == LDO
			    && ldo_target_reg == rtn_reg)
			|| (delay_insn == 0x08000240))
		      {
			/* No need to swap the branch and its delay slot, but
			   we do need to make sure to jump past the return
			   pointer update in the stub.  */
			value += 4;

			/* If the delay insn does a return pointer adjustment,
			   then we have to make sure it stays valid.  */
			if (opcode == LDO
			    && ldo_target_reg == rtn_reg)
			  {
			    delay_insn &= 0xfc00ffff;
			    delay_insn |= ((31 << 21) | (31 << 16));
			    bfd_put_32 (input_bfd, delay_insn, hit_data + 4);
			  }
			/* Use a BLE to reach the stub.  */
			insn = BLE_SR4_R0;
		      }
		    else
		      {
			/* Wonderful, we have to swap the call insn and its
			   delay slot.  */
			bfd_put_32 (input_bfd, delay_insn, hit_data);
			/* Use a BLE,n to reach the stub.  */
			insn = (BLE_SR4_R0 | 0x2);
			bfd_put_32 (input_bfd, insn, hit_data + 4);
			insn = hppa_elf_relocate_insn (input_bfd,
						       input_section,
						       insn, offset + 4,
						       value, addend,
						       r_format, r_field,
						       r_pcrel);
			/* Update the instruction word.  */
			bfd_put_32 (input_bfd, insn, hit_data + 4);
			return bfd_reloc_dangerous;
		      }
		  }
	        else
		  return bfd_reloc_notsupported;
	      }
	  }
	goto do_basic_type_1;
      }
d1165 11
a1175 9
do_basic_type_1:
      insn = hppa_elf_relocate_insn (input_bfd, input_section, insn,
				     offset, value, addend, r_format,
				     r_field, r_pcrel);
      break;

    /* Something we don't know how to handle.  */
    default:
      return bfd_reloc_notsupported;
d1177 1
a1177 4

  /* Update the instruction word.  */
  bfd_put_32 (input_bfd, insn, hit_data);
  return (bfd_reloc_ok);
d1197 2
a1198 36
/* Determine the name of the stub needed to perform a call assuming the
   argument relocation bits for caller and callee are in CALLER and CALLEE
   for a call from LOCATION to DESTINATION.  Copy the name into STUB_NAME.  */

static void
elf32_hppa_name_of_stub (location, destination, stub_name)
     bfd_vma location ATTRIBUTE_UNUSED;
     bfd_vma destination ATTRIBUTE_UNUSED;
     char *stub_name;
{
  strcpy (stub_name, "_____long_branch_stub_");
}

/* Compute the size of the stub needed to call from LOCATION to DESTINATION
   (a function named SYM_NAME), with argument relocation bits CALLER and
   CALLEE.  Return zero if no stub is needed to perform such a call.  */

static unsigned int
elf32_hppa_size_of_stub (location, destination, sym_name)
     bfd_vma location, destination;
     const char *sym_name;
{
  /* Determine if a long branch stub is needed.  */
  if (!(((int)(location - destination) > 0x3ffff)
	|| ((int)(location - destination) < (int)0xfffc0000)))
    return 0;

  if (!strncmp ("$$", sym_name, 2)
      && strcmp ("$$dyncall", sym_name))
    return 12;
  else
    return 16;
}

/* Build one linker stub as defined by the stub hash table entry GEN_ENTRY.
   IN_ARGS contains the stub BFD and link info pointers.  */
d1201 3
a1203 3
elf32_hppa_build_one_stub (gen_entry, in_args)
     struct bfd_hash_entry *gen_entry;
     PTR in_args;
d1205 1
a1205 8
  void **args = (void **)in_args;
  bfd *stub_bfd = (bfd *)args[0];
  struct bfd_link_info *info = (struct bfd_link_info *)args[1];
  struct elf32_hppa_stub_hash_entry *entry;
  struct elf32_hppa_stub_hash_table *stub_hash_table;
  bfd_byte *loc;
  symvalue sym_value;
  const char *sym_name;
d1207 4
a1210 6
  /* Initialize pointers to the stub hash table, the particular entry we
     are building a stub for, and where (in memory) we should place the stub
     instructions.  */
  entry = (struct elf32_hppa_stub_hash_entry *)gen_entry;
  stub_hash_table = elf32_hppa_hash_table(info)->stub_hash_table;
  loc = stub_hash_table->location;
d1212 3
a1214 2
  /* Make a note of the offset within the stubs for this entry.  */
  entry->offset = stub_hash_table->offset;
d1216 2
a1217 2
  /* The symbol's name starts at offset 22.  */
  sym_name = entry->root.string + 22;
d1219 12
a1230 29
  sym_value = (entry->target_value
	       + entry->target_section->output_offset
	       + entry->target_section->output_section->vma);

  if (1)
    {
      /* Create one of two variant long branch stubs.  One for $$dyncall and
	 normal calls, the other for calls to millicode.  */
      unsigned long insn;
      int millicode_call = 0;

      if (!strncmp ("$$", sym_name, 2) && strcmp ("$$dyncall", sym_name))
	millicode_call = 1;

      /* First the return pointer adjustment.  Depending on exact calling
	 sequence this instruction may be skipped.  */
      bfd_put_32 (stub_bfd, LDO_M4_R31_R31, loc);

      /* The next two instructions are the long branch itself.  A long branch
	 is formed with "ldil" loading the upper bits of the target address
	 into a register, then branching with "be" which adds in the lower bits.
	 Long branches to millicode nullify the delay slot of the "be".  */
      insn = hppa_rebuild_insn (stub_bfd, LDIL_R1,
				hppa_field_adjust (sym_value, 0, e_lrsel), 21);
      bfd_put_32 (stub_bfd, insn, loc + 4);
      insn = hppa_rebuild_insn (stub_bfd, BE_SR4_R1 | (millicode_call ? 2 : 0),
				hppa_field_adjust (sym_value, 0, e_rrsel) >> 2,
				17);
      bfd_put_32 (stub_bfd, insn, loc + 8);
d1232 2
a1233 17
      if (!millicode_call)
	{
	  /* The sequence to call this stub places the return pointer into %r31,
	     the final target expects the return pointer in %r2, so copy the
	      return pointer into the proper register.  */
	  bfd_put_32 (stub_bfd, COPY_R31_R2, loc + 12);

	  /* Update the location and offsets.  */
	  stub_hash_table->location += 16;
	  stub_hash_table->offset += 16;
	}
      else
	{
	  /* Update the location and offsets.  */
	  stub_hash_table->location += 12;
	  stub_hash_table->offset += 12;
	}
a1234 1
    }
d1238 4
a1241 5
/* External entry points for sizing and building linker stubs.  */

/* Build all the stubs associated with the current output file.  The
   stubs are kept in a hash table attached to the main linker hash
   table.  This is called via hppaelf_finish in the linker.  */
d1243 3
a1245 3
boolean
elf32_hppa_build_stubs (stub_bfd, info)
     bfd *stub_bfd;
d1247 2
d1250 20
a1269 18
  /* The stub BFD only has one section.  */
  asection *stub_sec = stub_bfd->sections;
  struct elf32_hppa_stub_hash_table *table;
  unsigned int size;
  void *args[2];

  /* So we can pass both the BFD for the stubs and the link info
     structure to the routine which actually builds stubs.  */
  args[0] = stub_bfd;
  args[1] = info;

  /* Allocate memory to hold the linker stubs.  */
  size = bfd_section_size (stub_bfd, stub_sec);
  stub_sec->contents = (unsigned char *) bfd_zalloc (stub_bfd, size);
  if (stub_sec->contents == NULL)
    return false;
  table = elf32_hppa_hash_table(info)->stub_hash_table;
  table->location = stub_sec->contents;
d1271 18
a1288 2
  /* Build the stubs as directed by the stub hash table.  */
  elf32_hppa_stub_hash_traverse (table, elf32_hppa_build_one_stub, args);
d1290 1
a1290 2
  return true;
}
d1292 5
a1296 1
/* Determine and set the size of the stub section for a final link.
d1298 1
a1298 4
   The basic idea here is to examine all the relocations looking for
   PC-relative calls to a target that is unreachable with a "bl"
   instruction or calls where the caller and callee disagree on the
   location of their arguments or return value.  */
d1300 69
a1368 12
boolean
elf32_hppa_size_stubs (stub_bfd, output_bfd, link_info)
     bfd *stub_bfd;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *link_info;
{
  bfd *input_bfd;
  asection *section, *stub_sec = 0;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Sym *local_syms, **all_local_syms;
  unsigned int i, index, bfd_count = 0;
  struct elf32_hppa_stub_hash_table *stub_hash_table = 0;
d1370 9
a1378 9
  /* Create and initialize the stub hash table.  */
  stub_hash_table = ((struct elf32_hppa_stub_hash_table *)
		     bfd_malloc (sizeof (struct elf32_hppa_stub_hash_table)));
  if (!stub_hash_table)
    goto error_return;

  if (!elf32_hppa_stub_hash_table_init (stub_hash_table, stub_bfd,
					elf32_hppa_stub_hash_newfunc))
    goto error_return;
d1380 13
a1392 2
  /* Attach the hash tables to the main hash table.  */
  elf32_hppa_hash_table(link_info)->stub_hash_table = stub_hash_table;
d1394 18
a1411 5
  /* Count the number of input BFDs.  */
  for (input_bfd = link_info->input_bfds;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next)
     bfd_count++;
d1413 12
a1424 2
  /* Magic as we know the stub bfd only has one section.  */
  stub_sec = stub_bfd->sections;
d1426 7
a1432 10
  /* If generating a relocateable output file, then we don't
     have to examine the relocs.  */
  if (link_info->relocateable)
    {
      for (i = 0; i < bfd_count; i++)
	if (all_local_syms[i])
	  free (all_local_syms[i]);
      free (all_local_syms);
      return true;
    }
d1434 3
a1436 10
  /* Now that we have argument location information for all the global
     functions we can start looking for stubs.  */
  for (input_bfd = link_info->input_bfds, index = 0;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next, index++)
    {
      /* We'll need the symbol table in a second.  */
      symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
      if (symtab_hdr->sh_info == 0)
	continue;
d1438 2
a1439 6
      local_syms = all_local_syms[index];

      /* Walk over each section attached to the input bfd.  */
      for (section = input_bfd->sections;
	   section != NULL;
	   section = section->next)
d1441 4
a1444 8
	  Elf_Internal_Shdr *input_rel_hdr;
	  Elf32_External_Rela *external_relocs, *erelaend, *erela;
	  Elf_Internal_Rela *internal_relocs, *irelaend, *irela;

	  /* If there aren't any relocs, then there's nothing to do.  */
	  if ((section->flags & SEC_RELOC) == 0
	      || section->reloc_count == 0)
	    continue;
d1446 1
a1446 19
	  /* Allocate space for the external relocations.  */
	  external_relocs
	    = ((Elf32_External_Rela *)
	       bfd_malloc (section->reloc_count
			   * sizeof (Elf32_External_Rela)));
	  if (external_relocs == NULL)
	    {
	      for (i = 0; i < bfd_count; i++)
		if (all_local_syms[i])
		  free (all_local_syms[i]);
	      free (all_local_syms);
	      goto error_return;
	    }

	  /* Likewise for the internal relocations.  */
	  internal_relocs
	    = ((Elf_Internal_Rela *)
	       bfd_malloc (section->reloc_count * sizeof (Elf_Internal_Rela)));
	  if (internal_relocs == NULL)
d1448 2
a1449 6
	      free (external_relocs);
	      for (i = 0; i < bfd_count; i++)
		if (all_local_syms[i])
		  free (all_local_syms[i]);
	      free (all_local_syms);
	      goto error_return;
d1452 1
a1452 5
	  /* Read in the external relocs.  */
	  input_rel_hdr = &elf_section_data (section)->rel_hdr;
	  if (bfd_seek (input_bfd, input_rel_hdr->sh_offset, SEEK_SET) != 0
	      || bfd_read (external_relocs, 1, input_rel_hdr->sh_size,
			   input_bfd) != input_rel_hdr->sh_size)
d1454 1
a1454 39
	      free (external_relocs);
	      free (internal_relocs);
	      for (i = 0; i < bfd_count; i++)
		if (all_local_syms[i])
		  free (all_local_syms[i]);
	      free (all_local_syms);
	      goto error_return;
	    }

	  /* Swap in the relocs.  */
	  erela = external_relocs;
	  erelaend = erela + section->reloc_count;
	  irela = internal_relocs;
	  for (; erela < erelaend; erela++, irela++)
	    bfd_elf32_swap_reloca_in (input_bfd, erela, irela);

	  /* We're done with the external relocs, free them.  */
	  free (external_relocs);

	  /* Now examine each relocation.  */
	  irela = internal_relocs;
	  irelaend = irela + section->reloc_count;
	  for (; irela < irelaend; irela++)
	    {
	      long r_type, size_of_stub;
	      unsigned long r_index;
	      struct elf_link_hash_entry *hash;
	      struct elf32_hppa_stub_hash_entry *stub_hash;
	      Elf_Internal_Sym *sym;
	      asection *sym_sec;
	      const char *sym_name;
	      symvalue sym_value;
	      bfd_vma location, destination;
	      char *new_name = NULL;

	      r_type = ELF32_R_TYPE (irela->r_info);
	      r_index = ELF32_R_SYM (irela->r_info);

	      if (r_type < 0 || r_type >= (int) R_PARISC_UNIMPLEMENTED)
d1456 1
a1456 16
		  bfd_set_error (bfd_error_bad_value);
		  free (internal_relocs);
		  for (i = 0; i < bfd_count; i++)
		    if (all_local_syms[i])
		      free (all_local_syms[i]);
		  free (all_local_syms);
		  goto error_return;
		}

	      /* Only look for stubs on call instructions or plabel
		 references.  */
	      if (r_type != R_PARISC_PCREL17F
		  && r_type != R_PARISC_PLABEL32
		  && r_type != R_PARISC_PLABEL21L
		  && r_type != R_PARISC_PLABEL14R)
		continue;
d1458 2
a1459 26
	      /* Now determine the call target, its name, value, section
		 and argument relocation bits.  */
	      hash = NULL;
	      sym = NULL;
	      sym_sec = NULL;
	      if (r_index < symtab_hdr->sh_info)
		{
		  /* It's a local symbol.  */
		  Elf_Internal_Shdr *hdr;

		  sym = local_syms + r_index;
		  hdr = elf_elfsections (input_bfd)[sym->st_shndx];
		  sym_sec = hdr->bfd_section;
		  sym_name = bfd_elf_string_from_elf_section (input_bfd,
							      symtab_hdr->sh_link,
							      sym->st_name);
		  sym_value = (ELF_ST_TYPE (sym->st_info) == STT_SECTION
			       ? 0 : sym->st_value);
		  destination = (sym_value
				 + sym_sec->output_offset
				 + sym_sec->output_section->vma);

		  /* Tack on an ID so we can uniquely identify this local
		     symbol in the stub or arg info hash tables.  */
		  new_name = bfd_malloc (strlen (sym_name) + 10);
		  if (new_name == 0)
d1461 3
a1463 6
		      free (internal_relocs);
		      for (i = 0; i < bfd_count; i++)
			if (all_local_syms[i])
			  free (all_local_syms[i]);
		      free (all_local_syms);
		      goto error_return;
a1464 2
		  sprintf (new_name, "%s_%08x", sym_name, (int)sym_sec);
		  sym_name = new_name;
d1467 6
d1474 1
a1474 2
		  /* It's an external symbol.  */
		  long index;
d1476 34
a1509 4
		  index = r_index - symtab_hdr->sh_info;
		  hash = elf_sym_hashes (input_bfd)[index];
		  if (hash->root.type == bfd_link_hash_defined
		      || hash->root.type == bfd_link_hash_defweak)
d1511 2
a1512 6
		      sym_sec = hash->root.u.def.section;
		      sym_name = hash->root.root.string;
		      sym_value = hash->root.u.def.value;
		      destination = (sym_value
				     + sym_sec->output_offset
				     + sym_sec->output_section->vma);
d1515 13
d1529 11
a1539 7
		      bfd_set_error (bfd_error_bad_value);
		      free (internal_relocs);
		      for (i = 0; i < bfd_count; i++)
			if (all_local_syms[i])
			  free (all_local_syms[i]);
		      free (all_local_syms);
		      goto error_return;
d1541 5
d1547 47
d1595 7
a1601 16
	      /* Now determine where the call point is.  */
	      location = (section->output_offset
			  + section->output_section->vma
			  + irela->r_offset);

	      /* We only care about the destination for PCREL function
		 calls (eg. we don't care for PLABELS).  */
	      if (r_type != R_PARISC_PCREL17F)
		location = destination;

	      /* Determine what (if any) linker stub is needed and its
		 size (in bytes).  */
	      size_of_stub = elf32_hppa_size_of_stub (location,
						      destination,
						      sym_name);
	      if (size_of_stub != 0)
d1603 4
a1606 2
		  char *stub_name;
		  unsigned int len;
d1608 12
a1619 3
		  /* Get the name of this stub.  */
		  len = strlen (sym_name);
		  len += 23;
d1621 1
a1621 2
		  stub_name = bfd_malloc (len);
		  if (!stub_name)
d1623 9
a1631 11
		      /* Because sym_name was mallocd above for local
			 symbols.  */
		      if (r_index < symtab_hdr->sh_info)
			free (new_name);

		      free (internal_relocs);
		      for (i = 0; i < bfd_count; i++)
			if (all_local_syms[i])
			  free (all_local_syms[i]);
		      free (all_local_syms);
		      goto error_return;
a1632 2
		  elf32_hppa_name_of_stub (location, destination, stub_name);
		  strcat (stub_name + 22, sym_name);
d1634 2
a1635 8
		  /* Because sym_name was malloced above for local symbols.  */
		  if (r_index < symtab_hdr->sh_info)
		    free (new_name);

		  stub_hash
		    = elf32_hppa_stub_hash_lookup (stub_hash_table, stub_name,
						   false, false);
		  if (stub_hash != NULL)
d1637 11
a1647 3
		      /* The proper stub has already been created, nothing
			 else to do.  */
		      free (stub_name);
d1649 5
d1655 33
d1689 7
a1695 10
		      bfd_set_section_size (stub_bfd, stub_sec,
					    (bfd_section_size (stub_bfd,
							       stub_sec)
					     + size_of_stub));

		      /* Enter this entry into the linker stub hash table.  */
		      stub_hash
			= elf32_hppa_stub_hash_lookup (stub_hash_table,
						       stub_name, true, true);
		      if (stub_hash == NULL)
d1697 8
a1704 7
			  free (stub_name);
			  free (internal_relocs);
			  for (i = 0; i < bfd_count; i++)
			    if (all_local_syms[i])
			      free (all_local_syms[i]);
			  free (all_local_syms);
			  goto error_return;
d1707 7
a1713 4
		      /* We'll need these to determine the address that the
			 stub will branch to.  */
		      stub_hash->target_value = sym_value;
		      stub_hash->target_section = sym_sec;
d1715 1
a1715 1
		  free (stub_name);
a1717 2
	  /* We're done with the internal relocs, free them.  */
	  free (internal_relocs);
d1720 1
a1720 5
  /* We're done with the local symbols, free them.  */
  for (i = 0; i < bfd_count; i++)
    if (all_local_syms[i])
      free (all_local_syms[i]);
  free (all_local_syms);
d1722 27
d1750 2
a1751 13
error_return:
  /* Return gracefully, avoiding dangling references to the hash tables.  */
  if (stub_hash_table)
    {
      elf32_hppa_hash_table(link_info)->stub_hash_table = NULL;
      free (stub_hash_table);
    }
  /* Set the size of the stub section to zero since we're never going
     to create them.   Avoids losing when we try to get its contents
     too.  */
  bfd_set_section_size (stub_bfd, stub_sec, 0);
  return false;
}
d1753 15
a1767 5
/* Misc BFD support code.  */
#define bfd_elf32_bfd_reloc_type_lookup		elf_hppa_reloc_type_lookup
#define bfd_elf32_bfd_is_local_label_name	elf_hppa_is_local_label_name
#define elf_info_to_howto               	elf_hppa_info_to_howto
#define elf_info_to_howto_rel           	elf_hppa_info_to_howto_rel
d1769 2
a1770 6
/* Stuff for the BFD linker.  */
#define elf_backend_relocate_section		elf32_hppa_relocate_section
#define elf_backend_add_symbol_hook		elf32_hppa_add_symbol_hook
#define bfd_elf32_bfd_link_hash_table_create \
  elf32_hppa_link_hash_table_create
#define elf_backend_fake_sections		elf_hppa_fake_sections
d1772 2658
d4437 8
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a28 1
#include "bfdlink.h"
a29 1
#include "obstack.h"
d31 5
a36 43
/* The internal type of a symbol table extension entry.  */
typedef unsigned long symext_entryS;

/* The external type of a symbol table extension entry.  */
#define ELF32_PARISC_SX_SIZE (4)
#define ELF32_PARISC_SX_GET(bfd, addr) bfd_h_get_32 ((bfd), (addr))
#define ELF32_PARISC_SX_PUT(bfd, val, addr) \
  bfd_h_put_32 ((bfd), (val), (addr))

/* HPPA symbol table extension entry types */
enum elf32_hppa_symextn_types
{
  PARISC_SXT_NULL,
  PARISC_SXT_SYMNDX,
  PARISC_SXT_ARG_RELOC,
};

/* These macros compose and decompose the value of a symextn entry:

   entry_type = ELF32_PARISC_SX_TYPE(word);
   entry_value = ELF32_PARISC_SX_VAL(word);
   word = ELF32_PARISC_SX_WORD(type,val);  */

#define ELF32_PARISC_SX_TYPE(p)		((p) >> 24)
#define ELF32_PARISC_SX_VAL(p)		((p) & 0xFFFFFF)
#define ELF32_PARISC_SX_WORD(type,val)	(((type) << 24) + (val & 0xFFFFFF))

/* The following was added facilitate implementation of the .hppa_symextn
   section.  This section is built after the symbol table is built in the
   elf_write_object_contents routine (called from bfd_close).  It is built
   so late because it requires information that is not known until
   the symbol and string table sections have been allocated, and
   the symbol table has been built. */

#define SYMEXTN_SECTION_NAME ".PARISC.symext"

struct symext_chain
  {
    symext_entryS entry;
    struct symext_chain *next;
  };

typedef struct symext_chain symext_chainS;
d47 1
a47 5
   necessary to build the linker stubs during a link.

   The last hash table keeps track of argument location information needed
   to build hash tables.  Each function with nonzero argument location
   bits will have an entry in this table.  */
a82 17
/* Hash table for argument location information.  */

struct elf32_hppa_args_hash_entry
{
  /* Base hash table entry structure.  */
  struct bfd_hash_entry root;

  /* The argument location bits for this entry.  */
  int arg_bits;
};

struct elf32_hppa_args_hash_table
{
  /* The hash table itself.  */
  struct bfd_hash_table root;
};

a95 3
  /* The argument relocation bits hash table.  */
  struct elf32_hppa_args_hash_table *args_hash_table;

a103 26
/* FIXME.  */
#define ARGUMENTS	0
#define RETURN_VALUE	1

/* The various argument relocations that may be performed.  */
typedef enum
{
  /* No relocation.  */
  NO,
  /* Relocate 32 bits from GR to FP register.  */
  GF,
  /* Relocate 64 bits from a GR pair to FP pair.  */
  GD,
  /* Relocate 32 bits from FP to GR.  */
  FG,
  /* Relocate 64 bits from FP pair to GR pair.  */
  DG,
} arg_reloc_type;

/* What is being relocated (eg which argument or the return value).  */
typedef enum
{
  ARG0, ARG1, ARG2, ARG3, RET,
} arg_reloc_location;


a112 3
static bfd_reloc_status_type hppa_elf_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));

a116 30
static bfd_reloc_status_type hppa_elf_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd*, char **));

static reloc_howto_type * elf_hppa_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));

static boolean elf32_hppa_set_section_contents
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));

static void elf32_hppa_info_to_howto
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rela *));

static boolean elf32_hppa_backend_symbol_table_processing
  PARAMS ((bfd *, elf_symbol_type *, unsigned int));

static void elf32_hppa_backend_begin_write_processing
  PARAMS ((bfd *, struct bfd_link_info *));

static void elf32_hppa_backend_final_write_processing
  PARAMS ((bfd *, boolean));

static void add_entry_to_symext_chain
  PARAMS ((bfd *, unsigned int, unsigned int, symext_chainS **,
	   symext_chainS **));

static void
elf_hppa_tc_make_sections PARAMS ((bfd *, symext_chainS *));

static boolean hppa_elf_is_local_label PARAMS ((bfd *, asymbol *));

a132 4
static struct bfd_hash_entry *
elf32_hppa_args_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));

a147 5
static boolean
elf32_hppa_read_symext_info
  PARAMS ((bfd *, Elf_Internal_Shdr *, struct elf32_hppa_args_hash_table *,
	   Elf_Internal_Sym *));

d149 1
a149 4
  PARAMS ((unsigned int, unsigned int, bfd_vma, bfd_vma, const char *));

static boolean elf32_hppa_arg_reloc_needed
  PARAMS ((unsigned int, unsigned int, arg_reloc_type []));
d152 1
a152 220
  PARAMS ((unsigned int, unsigned int, bfd_vma, bfd_vma, char *));

static boolean elf32_hppa_size_symext PARAMS ((struct bfd_hash_entry *, PTR));

static boolean elf32_hppa_link_output_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, const char *,
	   Elf_Internal_Sym *, asection *));

/* ELF/PA relocation howto entries.  */

static reloc_howto_type elf_hppa_howto_table[ELF_HOWTO_TABLE_SIZE] =
{
  {R_PARISC_NONE, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_NONE"},
  /* The values in DIR32 are to placate the check in
     _bfd_stab_section_find_nearest_line.  */
  {R_PARISC_DIR32, 0, 2, 32, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DIR32", false, 0, 0xffffffff, false},
  {R_PARISC_DIR21L, 0, 0, 21, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DIR21L"},
  {R_PARISC_DIR17R, 0, 0, 17, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DIR17R"},
  {R_PARISC_DIR17F, 0, 0, 17, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DIR17F"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_DIR14R, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DIR14R"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_PCREL21L, 0, 0, 21, true, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PCREL21L"},
  {R_PARISC_PCREL17R, 0, 0, 17, true, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PCREL17R"},
  {R_PARISC_PCREL17F, 0, 0, 17, true, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PCREL17F"},
  {R_PARISC_PCREL17C, 0, 0, 17, true, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PCREL17C"},
  {R_PARISC_PCREL14R, 0, 0, 14, true, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PCREL14R"},
  {R_PARISC_PCREL14F, 0, 0, 14, true, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PCREL14F"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_DPREL21L, 0, 0, 21, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DPREL21L"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_DPREL14R, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DPREL14R"},
  {R_PARISC_DPREL14F, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DPREL14F"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_DLTREL21L, 0, 0, 21, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DLTREL21L"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_DLTREL14R, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DLTREL14R"},
  {R_PARISC_DLTREL14F, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DLTREL14F"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_DLTIND21L, 0, 0, 21, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DLTIND21L"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_DLTIND14R, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DLTIND14R"},
  {R_PARISC_DLTIND14F, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DLTIND14F"},

  {R_PARISC_SETBASE, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_SETBASE"},
  {R_PARISC_BASEREL32, 0, 0, 32, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_BASEREL32"},
  {R_PARISC_BASEREL21L, 0, 0, 21, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_BASEREL21L"},
  {R_PARISC_BASEREL17R, 0, 0, 17, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_BASEREL17R"},
  {R_PARISC_BASEREL17F, 0, 0, 17, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_BASEREL17F"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_BASEREL14R, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_BASEREL14R"},
  {R_PARISC_BASEREL14F, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_BASEREL14F"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_TEXTREL32, 0, 0, 32, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_TEXTREL32"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_DATAREL32, 0, 0, 32, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},


  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_PLABEL32, 0, 0, 32, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PLABEL32"},
  {R_PARISC_PLABEL21L, 0, 0, 21, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PLABEL21L"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_PLABEL14R, 0, 0, 14, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PLABEL14R"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},


  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_PLTIND21L, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PLTIND21L"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_UNIMPLEMENTED"},
  {R_PARISC_PLTIND14R, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PLTIND14R"},
  {R_PARISC_PLTIND14F, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_PLTIND14F"},


  {R_PARISC_COPY, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_COPY"},
  {R_PARISC_GLOB_DAT, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_GLOB_DAT"},
  {R_PARISC_JMP_SLOT, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_JMP_SLOT"},
  {R_PARISC_RELATIVE, 0, 0, 0, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_RELATIVE"},

  {R_PARISC_UNIMPLEMENTED, 0, 0, 0, false, 0, complain_overflow_dont, NULL, "R_PARISC_UNIMPLEMENTED"},
};

/* Where (what register type) is an argument comming from?  */
typedef enum
{
  AR_NO,
  AR_GR,
  AR_FR,
  AR_FU,
  AR_FPDBL1,
  AR_FPDBL2,
} arg_location;

/* Horizontal represents the callee's argument location information,
   vertical represents caller's argument location information.  Value at a
   particular X,Y location represents what (if any) argument relocation
   needs to be performed to make caller and callee agree.  */

static CONST arg_reloc_type arg_mismatches[6][6] =
{
  {NO, NO, NO, NO, NO, NO},
  {NO, NO, GF, NO, GD, NO},
  {NO, FG, NO, NO, NO, NO},
  {NO, NO, NO, NO, NO, NO},
  {NO, DG, NO, NO, NO, NO},
  {NO, DG, NO, NO, NO, NO},
};

/* Likewise, but reversed for the return value.  */
static CONST arg_reloc_type ret_mismatches[6][6] =
{
  {NO, NO, NO, NO, NO, NO},
  {NO, NO, FG, NO, DG, NO},
  {NO, GF, NO, NO, NO, NO},
  {NO, NO, NO, NO, NO, NO},
  {NO, GD, NO, NO, NO, NO},
  {NO, GD, NO, NO, NO, NO},
};

/* Misc static crud for symbol extension records.  */
static symext_chainS *symext_rootP;
static symext_chainS *symext_lastP;
static bfd_size_type symext_chain_size;

/* FIXME: We should be able to try this static variable!  */
static bfd_byte *symextn_contents;

a164 18
/* For linker args hash tables.  */
#define elf32_hppa_args_hash_lookup(table, string, create, copy) \
  ((struct elf32_hppa_args_hash_entry *) \
   bfd_hash_lookup (&(table)->root, (string), (create), (copy)))

#define elf32_hppa_args_hash_traverse(table, func, info) \
  (bfd_hash_traverse \
   (&(table)->root, \
    (boolean (*) PARAMS ((struct bfd_hash_entry *, PTR))) (func), \
    (info)))

#define elf32_hppa_args_hash_table_init(table, newfunc) \
  (bfd_hash_table_init \
   (&(table)->root, \
    (struct bfd_hash_entry *(*) PARAMS ((struct bfd_hash_entry *, \
					 struct bfd_hash_table *, \
					 const char *))) (newfunc)))

a183 4
/* Extract specific argument location bits for WHICH from
   the full argument location in AR.  */
#define EXTRACT_ARBITS(ar, which) ((ar) >> (8 - ((which) * 2))) & 3

a237 32
/* Initialize an entry in the argument location hash table.  */

static struct bfd_hash_entry *
elf32_hppa_args_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
{
  struct elf32_hppa_args_hash_entry *ret;

  ret = (struct elf32_hppa_args_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = ((struct elf32_hppa_args_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct elf32_hppa_args_hash_entry)));
  if (ret == NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct elf32_hppa_args_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));

  /* Initialize the local fields.  */
  if (ret)
    ret->arg_bits = 0;

  return (struct bfd_hash_entry *) ret;
}

a258 1
  ret->args_hash_table = NULL;
d446 1
a446 1
		     input_section, rel->r_offset)))
a464 7
      /* If args_hash_table is NULL, then we have encountered some
	 kind of link error (ex. undefined symbols).  Do not try to
	 apply any relocations, continue the loop so we can notify
	 the user of several errors in a single attempted link.  */
      if (elf32_hppa_hash_table (info)->args_hash_table == NULL)
	continue;

d482 1
a482 1
		     input_section, rel->r_offset)))
a524 280
/* Return one (or more) BFD relocations which implement the base
   relocation with modifications based on format and field.  */

elf32_hppa_reloc_type **
hppa_elf_gen_reloc_type (abfd, base_type, format, field, ignore, sym)
     bfd *abfd;
     elf32_hppa_reloc_type base_type;
     int format;
     int field;
     int ignore;
     asymbol *sym;
{
  elf32_hppa_reloc_type *finaltype;
  elf32_hppa_reloc_type **final_types;

  /* Allocate slots for the BFD relocation.  */
  final_types = (elf32_hppa_reloc_type **)
    bfd_alloc_by_size_t (abfd, sizeof (elf32_hppa_reloc_type *) * 2);
  if (final_types == NULL)
    return NULL;

  /* Allocate space for the relocation itself.  */
  finaltype = (elf32_hppa_reloc_type *)
    bfd_alloc_by_size_t (abfd, sizeof (elf32_hppa_reloc_type));
  if (finaltype == NULL)
    return NULL;

  /* Some reasonable defaults.  */
  final_types[0] = finaltype;
  final_types[1] = NULL;

#define final_type finaltype[0]

  final_type = base_type;

  /* Just a tangle of nested switch statements to deal with the braindamage
     that a different field selector means a completely different relocation
     for PA ELF.  */
  switch (base_type)
    {
    case R_HPPA:
    case R_HPPA_ABS_CALL:
      switch (format)
	{
	case 14:
	  switch (field)
	    {
	    case e_rsel:
	    case e_rrsel:
	      final_type = R_PARISC_DIR14R;
	      break;
	    case e_rtsel:
	      final_type = R_PARISC_DLTREL14R;
	      break;
	    case e_tsel:
	      final_type = R_PARISC_DLTREL14F;
	      break;
	    case e_rpsel:
	      final_type = R_PARISC_PLABEL14R;
	      break;
	    default:
	      return NULL;
	    }
	  break;

	case 17:
	  switch (field)
	    {
	    case e_fsel:
	      final_type = R_PARISC_DIR17F;
	      break;
	    case e_rsel:
	    case e_rrsel:
	      final_type = R_PARISC_DIR17R;
	      break;
	    default:
	      return NULL;
	    }
	  break;

	case 21:
	  switch (field)
	    {
	    case e_lsel:
	    case e_lrsel:
	      final_type = R_PARISC_DIR21L;
	      break;
	    case e_ltsel:
	      final_type = R_PARISC_DLTREL21L;
	      break;
	    case e_lpsel:
	      final_type = R_PARISC_PLABEL21L;
	      break;
	    default:
	      return NULL;
	    }
	  break;

	case 32:
	  switch (field)
	    {
	    case e_fsel:
	      final_type = R_PARISC_DIR32;
	      break;
	    case e_psel:
	      final_type = R_PARISC_PLABEL32;
	      break;
	    default:
	      return NULL;
	    }
	  break;

	default:
	  return NULL;
	}
      break;


    case R_HPPA_GOTOFF:
      switch (format)
	{
	case 14:
	  switch (field)
	    {
	    case e_rsel:
	    case e_rrsel:
	      final_type = R_PARISC_DPREL14R;
	      break;
	    case e_fsel:
	      final_type = R_PARISC_DPREL14F;
	      break;
	    default:
	      return NULL;
	    }
	  break;

	case 21:
	  switch (field)
	    {
	    case e_lrsel:
	    case e_lsel:
	      final_type = R_PARISC_DPREL21L;
	      break;
	    default:
	      return NULL;
	    }
	  break;

	default:
	  return NULL;
	}
      break;


    case R_HPPA_PCREL_CALL:
      switch (format)
	{
	case 14:
	  switch (field)
	    {
	    case e_rsel:
	    case e_rrsel:
	      final_type = R_PARISC_PCREL14R;
	      break;
	    case e_fsel:
	      final_type = R_PARISC_PCREL14F;
	      break;
	    default:
	      return NULL;
	    }
	  break;

	case 17:
	  switch (field)
	    {
	    case e_rsel:
	    case e_rrsel:
	      final_type = R_PARISC_PCREL17R;
	      break;
	    case e_fsel:
	      final_type = R_PARISC_PCREL17F;
	      break;
	    default:
	      return NULL;
	    }
	  break;

	case 21:
	  switch (field)
	    {
	    case e_lsel:
	    case e_lrsel:
	      final_type = R_PARISC_PCREL21L;
	      break;
	    default:
	      return NULL;
	    }
	  break;

	default:
	  return NULL;
	}
      break;

    default:
      return NULL;
    }

  return final_types;
}

#undef final_type

/* Set the contents of a particular section at a particular location.  */

static boolean
elf32_hppa_set_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     PTR location;
     file_ptr offset;
     bfd_size_type count;
{
  /* Ignore write requests for the symbol extension section until we've
     had the chance to rebuild it ourselves.  */
  if (!strcmp (section->name, ".PARISC.symextn") && !symext_chain_size)
    return true;
  else
    return _bfd_elf_set_section_contents (abfd, section, location,
					  offset, count);
}

/* Translate from an elf into field into a howto relocation pointer.  */

static void
elf32_hppa_info_to_howto (abfd, cache_ptr, dst)
     bfd *abfd;
     arelent *cache_ptr;
     Elf32_Internal_Rela *dst;
{
  BFD_ASSERT (ELF32_R_TYPE(dst->r_info) < (unsigned int) R_PARISC_UNIMPLEMENTED);
  cache_ptr->howto = &elf_hppa_howto_table[ELF32_R_TYPE (dst->r_info)];
}


/* Actually perform a relocation.  NOTE this is (mostly) superceeded
   by elf32_hppa_bfd_final_link_relocate which is called by the new
   fast linker.  */

static bfd_reloc_status_type
hppa_elf_reloc (abfd, reloc_entry, symbol_in, data, input_section, output_bfd,
		error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol_in;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  /* It is no longer valid to call hppa_elf_reloc when creating
     a final executable.  */
  if (output_bfd)
    {
      reloc_entry->address += input_section->output_offset;

      /* Work around lossage in generic elf code to write relocations.
	 (maps different section symbols into the same symbol index).  */
      if ((symbol_in->flags & BSF_SECTION_SYM)
	  && symbol_in->section)
	reloc_entry->addend += symbol_in->section->output_offset;
      return bfd_reloc_ok;
    }
  else
    {
      *error_message = (char *) "Unsupported call to hppa_elf_reloc";
      return bfd_reloc_notsupported;
    }
}

d534 1
a534 1
     bfd *output_bfd;
d637 1
a637 4
	unsigned int len, caller_args, callee_args;
	arg_reloc_type arg_reloc_types[5];
	struct elf32_hppa_args_hash_table *args_hash_table;
	struct elf32_hppa_args_hash_entry *args_hash;
a653 2
	/* Now look for the argument relocation bits associated with the
	   target.  */
a665 21
	args_hash_table = elf32_hppa_hash_table (info)->args_hash_table;

	args_hash = elf32_hppa_args_hash_lookup (args_hash_table,
						 new_name, false, false);
	if (args_hash == NULL)
	  callee_args = 0;
	else
	  callee_args = args_hash->arg_bits;

	/* If this is a CALL relocation, then get the caller's bits
	   from the addend.  Else use the magic 0x155 value for PLABELS.

	   Also we don't care about the destination (value) for PLABELS.  */
	if (r_type == R_PARISC_PCREL17F)
	  caller_args = HPPA_R_ARG_RELOC (addend);
	else
	  {
	    caller_args = 0x155;
	    location = value;
	  }

d668 1
a668 3
	    || ((int)(value - location) < (int)0xfffc0000)
	    || elf32_hppa_arg_reloc_needed (caller_args, callee_args,
					    arg_reloc_types))
d681 1
a681 2
	    elf32_hppa_name_of_stub (caller_args, callee_args,
				     location, value, stub_name);
a698 1

d770 3
a772 22
		else
		  {
		    /* PLABEL stuff is easy.  */

		    value = (stub_hash->offset
			     + stub_section->output_offset
			     + stub_section->output_section->vma);
		    /* We don't need the RP adjustment for PLABELs.  */
		    value += 4;
		    if (r_type == R_PARISC_PLABEL32)
		      r_format = 32;
		    else if (r_type == R_PARISC_PLABEL21L)
		      r_format = 21;
		    else if (r_type == R_PARISC_PLABEL14R)
		      r_format = 14;

		    r_pcrel = 0;
		    addend = 0;
		  }
		}
	      else
		return bfd_reloc_notsupported;
d793 2
a794 17
/* Return the address of the howto table entry to perform the CODE
   relocation for an ARCH machine.  */

static reloc_howto_type *
elf_hppa_reloc_type_lookup (abfd, code)
     bfd *abfd;
     bfd_reloc_code_real_type code;
{
  if ((int) code < (int) R_PARISC_UNIMPLEMENTED)
    {
      BFD_ASSERT ((int) elf_hppa_howto_table[(int) code].type == (int) code);
      return &elf_hppa_howto_table[(int) code];
    }
  return NULL;
}

/* Return true if SYM represents a local label symbol.  */
d797 8
a804 3
hppa_elf_is_local_label (abfd, sym)
     bfd *abfd;
     asymbol *sym;
d806 2
a807 1
  return (sym->name[0] == 'L' && sym->name[1] == '$');
d810 3
a812 3
/* Do any backend specific processing when beginning to write an object
   file.  For PA ELF we need to determine the size of the symbol extension
   section *before* any other output processing happens.  */
d815 4
a818 3
elf32_hppa_backend_begin_write_processing (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d820 2
a821 2
  unsigned int i;
  asection *symextn_sec;
d823 3
a825 5
  /* Size up the symbol extension section.  */
  if ((abfd->outsymbols == NULL
       && info == NULL)
      || symext_chain_size != 0)
    return;
d827 2
a828 608
  if (info == NULL)
    {
      /* We were not called from the BFD ELF linker code, so we need
	 to examine the output BFD's outsymbols.

	 Note we can not build the symbol extensions now as the symbol
	 map hasn't been set up.  */
      for (i = 0; i < abfd->symcount; i++)
	{
	  elf_symbol_type *symbol = (elf_symbol_type *)abfd->outsymbols[i];

	  /* Only functions ever need an entry in the symbol extension
	     section.  */
	  if (!(symbol->symbol.flags & BSF_FUNCTION))
	    continue;

	  /* And only if they specify the locations of their arguments.  */
	  if (symbol->tc_data.hppa_arg_reloc == 0)
	    continue;

	  /* Yup.  This function symbol needs an entry.  */
	  symext_chain_size += 2 * ELF32_PARISC_SX_SIZE;
	}
    }
  else if (info->relocateable == true)
    {
      struct elf32_hppa_args_hash_table *table;
      table = elf32_hppa_hash_table (info)->args_hash_table;

      /* Determine the size of the symbol extension section.  */
      elf32_hppa_args_hash_traverse (table,
				     elf32_hppa_size_symext,
				     &symext_chain_size);
    }

  /* Now create the section and set its size.  We'll fill in the
     contents later.  */
  symextn_sec = bfd_get_section_by_name (abfd, SYMEXTN_SECTION_NAME);
  if (symextn_sec == NULL)
    symextn_sec = bfd_make_section (abfd, SYMEXTN_SECTION_NAME);

  bfd_set_section_flags (abfd, symextn_sec,
			 SEC_LOAD | SEC_HAS_CONTENTS | SEC_DATA);
  symextn_sec->output_section = symextn_sec;
  symextn_sec->output_offset = 0;
  bfd_set_section_alignment (abfd, symextn_sec, 2);
  bfd_set_section_size (abfd, symextn_sec, symext_chain_size);
}

/* Called for each entry in the args location hash table.  For each
   entry we bump the size pointer by 2 records (16 bytes).  */

static boolean
elf32_hppa_size_symext (gen_entry, in_args)
     struct bfd_hash_entry *gen_entry;
     PTR in_args;
{
  bfd_size_type *sizep = (bfd_size_type *)in_args;

  *sizep += 2 * ELF32_PARISC_SX_SIZE;
  return true;
}

/* Backend routine called by the linker for each output symbol.

   For PA ELF we use this opportunity to add an appropriate entry
   to the symbol extension chain for function symbols.  */

static boolean
elf32_hppa_link_output_symbol_hook (abfd, info, name, sym, section)
     bfd *abfd;
     struct bfd_link_info *info;
     const char *name;
     Elf_Internal_Sym *sym;
     asection *section;
{
  char *new_name;
  unsigned int len, index;
  struct elf32_hppa_args_hash_table *args_hash_table;
  struct elf32_hppa_args_hash_entry *args_hash;

  /* If the args hash table is NULL, then we've encountered an error
     of some sorts (for example, an undefined symbol).  In that case
     we've got nothing else to do.

     NOTE: elf_link_output_symbol will abort if we return false here!  */
  if (elf32_hppa_hash_table (info)->args_hash_table == NULL)
    return true;

  index = elf32_hppa_hash_table (info)->output_symbol_count++;

  /* We need to look up this symbol in the args hash table to see if
     it has argument relocation bits.  */
  if (ELF_ST_TYPE (sym->st_info) != STT_FUNC)
    return true;

  /* We know it's a function symbol of some kind.  */
  len = strlen (name) + 1;
  if (ELF_ST_BIND (sym->st_info) == STB_LOCAL)
    len += 9;

  new_name = bfd_malloc (len);
  if (new_name == NULL)
    return false;

  strcpy (new_name, name);
  if (ELF_ST_BIND (sym->st_info) == STB_LOCAL)
    sprintf (new_name + len - 10, "_%08x", (int)section);

  /* Now that we have the unique name, we can look it up in the
     args hash table.  */
  args_hash_table = elf32_hppa_hash_table (info)->args_hash_table;
  args_hash = elf32_hppa_args_hash_lookup (args_hash_table, new_name,
					   false, false);
  free (new_name);
  if (args_hash == NULL)
    return true;

  /* We know this symbol has arg reloc bits.  */
  add_entry_to_symext_chain (abfd, args_hash->arg_bits,
			     index, &symext_rootP, &symext_lastP);
  return true;
}

/* Perform any processing needed late in the object file writing process.
   For PA ELF we build and set the contents of the symbol extension
   section.  */

static void
elf32_hppa_backend_final_write_processing (abfd, linker)
     bfd *abfd;
     boolean linker;
{
  asection *symextn_sec;
  unsigned int i;

  /* Now build the symbol extension section.  */
  if (symext_chain_size == 0)
    return;

  if (! linker)
    {
      /* We were not called from the backend linker, so we still need
	 to build the symbol extension chain.

         Look at each symbol, adding the appropriate information to the
	 symbol extension section list as necessary.  */
      for (i = 0; i < abfd->symcount; i++)
	{
	  elf_symbol_type *symbol = (elf_symbol_type *) abfd->outsymbols[i];

	  /* Only functions ever need an entry in the symbol extension
	     section.  */
	  if (!(symbol->symbol.flags & BSF_FUNCTION))
	    continue;

	  /* And only if they specify the locations of their arguments.  */
	  if (symbol->tc_data.hppa_arg_reloc == 0)
	    continue;

	  /* Add this symbol's information to the chain.  */
	  add_entry_to_symext_chain (abfd, symbol->tc_data.hppa_arg_reloc,
				     symbol->symbol.udata.i, &symext_rootP,
				     &symext_lastP);
	}
    }

  /* Now fill in the contents of the symbol extension section.  */
  elf_hppa_tc_make_sections (abfd, symext_rootP);

  /* And attach that as the section's contents.  */
  symextn_sec = bfd_get_section_by_name (abfd, SYMEXTN_SECTION_NAME);
  if (symextn_sec == (asection *) 0)
    abort();

  symextn_sec->contents = (void *)symextn_contents;

  bfd_set_section_contents (abfd, symextn_sec, symextn_sec->contents,
			    symextn_sec->output_offset, symextn_sec->_raw_size);
}

/* Update the symbol extention chain to include the symbol pointed to
   by SYMBOLP if SYMBOLP is a function symbol.  Used internally and by GAS.  */

static void
add_entry_to_symext_chain (abfd, arg_reloc, sym_idx, symext_root, symext_last)
     bfd *abfd;
     unsigned int arg_reloc;
     unsigned int sym_idx;
     symext_chainS **symext_root;
     symext_chainS **symext_last;
{
  symext_chainS *symextP;

  /* Allocate memory and initialize this entry.  */
  symextP = (symext_chainS *) bfd_alloc (abfd, sizeof (symext_chainS) * 2);
  if (!symextP)
    abort();			/* FIXME */

  symextP[0].entry = ELF32_PARISC_SX_WORD (PARISC_SXT_SYMNDX, sym_idx);
  symextP[0].next = &symextP[1];

  symextP[1].entry = ELF32_PARISC_SX_WORD (PARISC_SXT_ARG_RELOC, arg_reloc);
  symextP[1].next = NULL;

  /* Now update the chain itself so it can be walked later to build
     the symbol extension section.  */
  if (*symext_root == NULL)
    {
      *symext_root = &symextP[0];
      *symext_last = &symextP[1];
    }
  else
    {
      (*symext_last)->next = &symextP[0];
      *symext_last = &symextP[1];
    }
}

/* Build the symbol extension section.  */

static void
elf_hppa_tc_make_sections (abfd, symext_root)
     bfd *abfd;
     symext_chainS *symext_root;
{
  symext_chainS *symextP;
  unsigned int i;
  asection *symextn_sec;

  symextn_sec = bfd_get_section_by_name (abfd, SYMEXTN_SECTION_NAME);

  /* Grab some memory for the contents of the symbol extension section
     itself.  */
  symextn_contents = (bfd_byte *) bfd_zalloc (abfd,
					      symextn_sec->_raw_size);
  if (!symextn_contents)
    abort();			/* FIXME */

  /* Fill in the contents of the symbol extension chain.  */
  for (i = 0, symextP = symext_root; symextP; symextP = symextP->next, ++i)
    ELF32_PARISC_SX_PUT (abfd, (bfd_vma) symextP->entry,
			 symextn_contents + i * ELF32_PARISC_SX_SIZE);

  return;
}

/* Do some PA ELF specific work after reading in the symbol table.
   In particular attach the argument relocation from the
   symbol extension section to the appropriate symbols.  */

static boolean
elf32_hppa_backend_symbol_table_processing (abfd, esyms,symcnt)
     bfd *abfd;
     elf_symbol_type *esyms;
     unsigned int symcnt;
{
  Elf32_Internal_Shdr *symextn_hdr =
    bfd_elf_find_section (abfd, SYMEXTN_SECTION_NAME);
  unsigned int i, current_sym_idx = 0;

  /* If no symbol extension existed, then all symbol extension information
     is assumed to be zero.  */
  if (symextn_hdr == NULL)
    {
      for (i = 0; i < symcnt; i++)
	esyms[i].tc_data.hppa_arg_reloc = 0;
      return (true);
    }

  /* FIXME:  Why not use bfd_get_section_contents here?  Also should give
     memory back when we're done.  */
  /* Allocate a buffer of the appropriate size for the symextn section.  */
  symextn_hdr->contents = bfd_zalloc(abfd,symextn_hdr->sh_size);
  if (!symextn_hdr->contents)
    return false;

  /* Read in the symextn section.  */
  if (bfd_seek (abfd, symextn_hdr->sh_offset, SEEK_SET) == -1)
    return false;
  if (bfd_read ((PTR) symextn_hdr->contents, 1, symextn_hdr->sh_size, abfd)
      != symextn_hdr->sh_size)
    return false;

  /* Parse entries in the symbol extension section, updating the symtab
     entries as we go */
  for (i = 0; i < symextn_hdr->sh_size / ELF32_PARISC_SX_SIZE; i++)
    {
      symext_entryS se =
	ELF32_PARISC_SX_GET (abfd,
			     ((unsigned char *)symextn_hdr->contents
			      + i * ELF32_PARISC_SX_SIZE));
      unsigned int se_value = ELF32_PARISC_SX_VAL (se);
      unsigned int se_type = ELF32_PARISC_SX_TYPE (se);

      switch (se_type)
	{
	case PARISC_SXT_NULL:
	  break;

	case PARISC_SXT_SYMNDX:
	  if (se_value >= symcnt)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      return (false);
	    }
	  current_sym_idx = se_value - 1;
	  break;

	case PARISC_SXT_ARG_RELOC:
	  esyms[current_sym_idx].tc_data.hppa_arg_reloc = se_value;
	  break;

	default:
	  bfd_set_error (bfd_error_bad_value);
	  return (false);
	}
    }
  return (true);
}

/* Read and attach the symbol extension information for the symbols
   in INPUT_BFD to the argument location hash table.  Handle locals
   if DO_LOCALS is true; likewise for globals when DO_GLOBALS is true.  */

static boolean
elf32_hppa_read_symext_info (input_bfd, symtab_hdr, args_hash_table, local_syms)
     bfd *input_bfd;
     Elf_Internal_Shdr *symtab_hdr;
     struct elf32_hppa_args_hash_table *args_hash_table;
     Elf_Internal_Sym *local_syms;
{
  asection *symextn_sec;
  bfd_byte *contents;
  unsigned int i, n_entries, current_index = 0;

  /* Get the symbol extension section for this BFD.  If no section exists
     then there's nothing to do.  Likewise if the section exists, but
     has no contents.  */
  symextn_sec = bfd_get_section_by_name (input_bfd, SYMEXTN_SECTION_NAME);
  if (symextn_sec == NULL)
    return true;

  /* Done separately so we can turn off SEC_HAS_CONTENTS (see below).  */
  if (symextn_sec->_raw_size == 0)
    {
      symextn_sec->flags &= ~SEC_HAS_CONTENTS;
      return true;
    }

  contents = (bfd_byte *) bfd_malloc ((size_t) symextn_sec->_raw_size);
  if (contents == NULL)
    return false;

  /* How gross.  We turn off SEC_HAS_CONTENTS for the input symbol extension
     sections to keep the generic ELF/BFD code from trying to do anything
     with them.  We have to undo that hack temporarily so that we can read
     in the contents with the generic code.  */
  symextn_sec->flags |= SEC_HAS_CONTENTS;
  if (bfd_get_section_contents (input_bfd, symextn_sec, contents,
				0, symextn_sec->_raw_size) == false)
    {
      symextn_sec->flags &= ~SEC_HAS_CONTENTS;
      free (contents);
      return false;
    }

  /* Gross.  Turn off SEC_HAS_CONTENTS for the input symbol extension
     sections (see above).  */
  symextn_sec->flags &= ~SEC_HAS_CONTENTS;

  n_entries = symextn_sec->_raw_size / ELF32_PARISC_SX_SIZE;
  for (i = 0; i < n_entries; i++)
    {
      symext_entryS entry =
	ELF32_PARISC_SX_GET (input_bfd, contents + i * ELF32_PARISC_SX_SIZE);
      unsigned int value = ELF32_PARISC_SX_VAL (entry);
      unsigned int type = ELF32_PARISC_SX_TYPE (entry);
      struct elf32_hppa_args_hash_entry *args_hash;

      switch (type)
	{
	case PARISC_SXT_NULL:
	  break;

	case PARISC_SXT_SYMNDX:
	  if (value >= symtab_hdr->sh_size / sizeof (Elf32_External_Sym))
	    {
	      bfd_set_error (bfd_error_bad_value);
	      free (contents);
	      return false;
	    }
	  current_index = value;
	  break;

	case PARISC_SXT_ARG_RELOC:
	  if (current_index < symtab_hdr->sh_info)
	    {
	      Elf_Internal_Shdr *hdr;
	      char *new_name;
	      const char *sym_name;
	      asection *sym_sec;
	      unsigned int len;

	      hdr = elf_elfsections (input_bfd)[local_syms[current_index].st_shndx];
	      sym_sec = hdr->bfd_section;
	      sym_name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
	 			        local_syms[current_index].st_name);
	      len = strlen (sym_name) + 10;
	      new_name = bfd_malloc (len);
	      if (new_name == NULL)
		{
		  free (contents);
		  return false;
		}
	      strcpy (new_name, sym_name);
	      sprintf (new_name + len - 10, "_%08x", (int)sym_sec);

	      /* This is a global symbol with argument location info.
		 We need to enter it into the hash table.  */
	      args_hash = elf32_hppa_args_hash_lookup (args_hash_table,
						       new_name, true,
						       true);
	      free (new_name);
	      if (args_hash == NULL)
		{
		  free (contents);
		  return false;
		}
	      args_hash->arg_bits = value;
	      break;
	    }
	  else if (current_index >= symtab_hdr->sh_info)
	    {
	      struct elf_link_hash_entry *h;

	      current_index -= symtab_hdr->sh_info;
	      h = elf_sym_hashes(input_bfd)[current_index];
	      /* This is a global symbol with argument location
		 information.  We need to enter it into the hash table.  */
	      args_hash = elf32_hppa_args_hash_lookup (args_hash_table,
						       h->root.root.string,
						       true, true);
	      if (args_hash == NULL)
		{
		  bfd_set_error (bfd_error_bad_value);
		  free (contents);
		  return false;
		}
	      args_hash->arg_bits = value;
	      break;
	    }
	  else
	    break;

	default:
	  bfd_set_error (bfd_error_bad_value);
	  free (contents);
	  return false;
	}
    }
  free (contents);
  return true;
}

/* Undo the generic ELF code's subtraction of section->vma from the
   value of each external symbol.  */

static boolean
elf32_hppa_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd;
     struct bfd_link_info *info;
     const Elf_Internal_Sym *sym;
     const char **namep;
     flagword *flagsp;
     asection **secp;
     bfd_vma *valp;
{
  *valp += (*secp)->vma;
  return true;
}

/* Determine the name of the stub needed to perform a call assuming the
   argument relocation bits for caller and callee are in CALLER and CALLEE
   for a call from LOCATION to DESTINATION.  Copy the name into STUB_NAME.  */

static void
elf32_hppa_name_of_stub (caller, callee, location, destination, stub_name)
     unsigned int caller, callee;
     bfd_vma location, destination;
     char *stub_name;
{
  arg_reloc_type arg_reloc_types[5];

  if (elf32_hppa_arg_reloc_needed (caller, callee, arg_reloc_types))
    {
      arg_reloc_location i;
      /* Fill in the basic template.  */
      strcpy (stub_name, "__XX_XX_XX_XX_XX_stub_");

      /* Now fix the specifics.  */
      for (i = ARG0; i <= RET; i++)
	switch (arg_reloc_types[i])
	  {
	    case NO:
	      stub_name[3 * i + 2] = 'N';
	      stub_name[3 * i + 3] = 'O';
	      break;
	    case GF:
	      stub_name[3 * i + 2] = 'G';
	      stub_name[3 * i + 3] = 'F';
	      break;
	    case FG:
	      stub_name[3 * i + 2] = 'F';
	      stub_name[3 * i + 3] = 'G';
	      break;
	    case GD:
	      stub_name[3 * i + 2] = 'G';
	      stub_name[3 * i + 3] = 'D';
	      break;
	    case DG:
	      stub_name[3 * i + 2] = 'D';
	      stub_name[3 * i + 3] = 'G';
	      break;
	  }
    }
  else
    strcpy (stub_name, "_____long_branch_stub_");
}

/* Determine if an argument relocation stub is needed to perform a
   call assuming the argument relocation bits for caller and callee
   are in CALLER and CALLEE.  Place the type of relocations (if any)
   into stub_types_p.  */

static boolean
elf32_hppa_arg_reloc_needed (caller, callee, stub_types)
     unsigned int caller, callee;
     arg_reloc_type stub_types[5];
{
  /* Special case for no relocations.  */
  if (caller == 0 || callee == 0)
    return 0;
  else
    {
      arg_location caller_loc[5];
      arg_location callee_loc[5];

      /* Extract the location information for the argument and return
	 value on both the caller and callee sides.  */
      caller_loc[ARG0] = EXTRACT_ARBITS (caller, ARG0);
      callee_loc[ARG0] = EXTRACT_ARBITS (callee, ARG0);
      caller_loc[ARG1] = EXTRACT_ARBITS (caller, ARG1);
      callee_loc[ARG1] = EXTRACT_ARBITS (callee, ARG1);
      caller_loc[ARG2] = EXTRACT_ARBITS (caller, ARG2);
      callee_loc[ARG2] = EXTRACT_ARBITS (callee, ARG2);
      caller_loc[ARG3] = EXTRACT_ARBITS (caller, ARG3);
      callee_loc[ARG3] = EXTRACT_ARBITS (callee, ARG3);
      caller_loc[RET] = EXTRACT_ARBITS (caller, RET);
      callee_loc[RET] = EXTRACT_ARBITS (callee, RET);

      /* Check some special combinations.  This is necessary to
	 deal with double precision FP arguments.  */
      if (caller_loc[ARG0] == AR_FU || caller_loc[ARG1] == AR_FU)
	{
	  caller_loc[ARG0] = AR_FPDBL1;
	  caller_loc[ARG1] = AR_NO;
	}
      if (caller_loc[ARG2] == AR_FU || caller_loc[ARG3] == AR_FU)
	{
	  caller_loc[ARG2] = AR_FPDBL2;
	  caller_loc[ARG3] = AR_NO;
	}
      if (callee_loc[ARG0] == AR_FU || callee_loc[ARG1] == AR_FU)
	{
	  callee_loc[ARG0] = AR_FPDBL1;
	  callee_loc[ARG1] = AR_NO;
	}
      if (callee_loc[ARG2] == AR_FU || callee_loc[ARG3] == AR_FU)
	{
	  callee_loc[ARG2] = AR_FPDBL2;
	  callee_loc[ARG3] = AR_NO;
	}

      /* Now look up any relocation needed for each argument and the
	 return value.  */
      stub_types[ARG0] = arg_mismatches[caller_loc[ARG0]][callee_loc[ARG0]];
      stub_types[ARG1] = arg_mismatches[caller_loc[ARG1]][callee_loc[ARG1]];
      stub_types[ARG2] = arg_mismatches[caller_loc[ARG2]][callee_loc[ARG2]];
      stub_types[ARG3] = arg_mismatches[caller_loc[ARG3]][callee_loc[ARG3]];
      stub_types[RET] = ret_mismatches[caller_loc[RET]][callee_loc[RET]];

      return (stub_types[ARG0] != NO
	      || stub_types[ARG1] != NO
	      || stub_types[ARG2] != NO
	      || stub_types[ARG3] != NO
	      || stub_types[RET] != NO);
    }
}

/* Compute the size of the stub needed to call from LOCATION to DESTINATION
   (a function named SYM_NAME), with argument relocation bits CALLER and
   CALLEE.  Return zero if no stub is needed to perform such a call.  */

static unsigned int
elf32_hppa_size_of_stub (callee, caller, location, destination, sym_name)
     unsigned int callee, caller;
d832 1
a832 5
  arg_reloc_type arg_reloc_types[5];

  /* Determine if a long branch or argument relocation stub is needed.
     If an argument relocation stub is needed, the relocation will be
     stored into arg_reloc_types.  */
d834 1
a834 2
	|| ((int)(location - destination) < (int)0xfffc0000)
	|| elf32_hppa_arg_reloc_needed (caller, callee, arg_reloc_types)))
d837 1
a837 41
  /* Some kind of stub is needed.  Determine how big it needs to be.
     First check for argument relocation stubs as they also handle
     long calls.  Then check for long calls to millicode and finally
     the normal long calls.  */
  if (arg_reloc_types[ARG0] != NO
      || arg_reloc_types[ARG1] != NO
      || arg_reloc_types[ARG2] != NO
      || arg_reloc_types[ARG3] != NO
      || arg_reloc_types[RET] != NO)
    {
      /* Some kind of argument relocation stub is needed.  */
      unsigned int len = 16;
      arg_reloc_location i;

      /* Each GR or FG relocation takes 2 insns, each GD or DG
	 relocation takes 3 insns.  Plus 4 more insns for the
         RP adjustment, ldil & (be | ble) and copy.  */
      for (i = ARG0; i <= RET; i++)
	switch (arg_reloc_types[i])
	  {
	    case GF:
	    case FG:
	      len += 8;
	      break;

	    case GD:
	    case DG:
	      len += 12;
	      break;

	    default:
	      break;
	  }

      /* Extra instructions are needed if we're relocating a return value.  */
      if (arg_reloc_types[RET] != NO)
	len += 12;

      return len;
    }
  else if (!strncmp ("$$", sym_name, 2)
d878 1
a878 125
  if (strncmp ("_____long_branch_stub_", entry->root.string, 22))
    {
      /* This must be an argument or return value relocation stub.  */
      unsigned long insn;
      arg_reloc_location i;
      bfd_byte *begin_loc = loc;

      /* First the return pointer adjustment.  Depending on exact calling
	 sequence this instruction may be skipped.  */
      bfd_put_32 (stub_bfd, LDO_M4_R31_R31, loc);
      loc += 4;

      /* If we are relocating a return value, then we're going to have
	 to return into the stub.  So we have to save off the user's
	 return pointer into the stack at RP'.  */
      if (strncmp (entry->root.string + 14, "NO", 2))
	{
	  bfd_put_32 (stub_bfd, STW_R31_M8R30, loc);
	  loc += 4;
	}

      /* Iterate over the argument relocations, emitting instructions
	 to move them around as necessary.  */
      for (i = ARG0; i <= ARG3; i++)
	{
	  if (!strncmp (entry->root.string + 3 * i + 2, "GF", 2))
	    {
	      bfd_put_32 (stub_bfd, STW_ARG_M16R30 | ((26 - i) << 16), loc);
	      bfd_put_32 (stub_bfd, FLDW_M16R30_FARG | (4 + i), loc + 4);
	      loc += 8;
	    }
	  else if (!strncmp (entry->root.string + 3 * i + 2, "FG", 2))
	    {
	      bfd_put_32 (stub_bfd, FSTW_FARG_M16R30 | (4 + i), loc);
	      bfd_put_32 (stub_bfd, LDW_M16R30_ARG | ((26 - i) << 16), loc + 4);
	      loc += 8;
	    }
	  else if (!strncmp (entry->root.string + 3 * i + 2, "GD", 2))
	    {
	      bfd_put_32 (stub_bfd, STW_ARG_M12R30 | ((26 - i) << 16), loc);
	      bfd_put_32 (stub_bfd, STW_ARG_M16R30 | ((25 - i) << 16), loc + 4);
	      bfd_put_32 (stub_bfd, FLDD_M16R30_FARG | (5 + i), loc + 8);
	      loc += 12;
	    }
	  else if (!strncmp (entry->root.string + 3 * i + 2, "DG", 2))
	    {
	      bfd_put_32 (stub_bfd, FSTD_FARG_M16R30 | (5 + i), loc);
	      bfd_put_32 (stub_bfd, LDW_M12R30_ARG | ((26 - i) << 16), loc + 4);
	      bfd_put_32 (stub_bfd, LDW_M16R30_ARG | ((25 - i) << 16), loc + 8);
	      loc += 12;
	    }
	}

      /* Load the high bits of the target address into %r1.  */
      insn = hppa_rebuild_insn (stub_bfd, LDIL_R1,
				hppa_field_adjust (sym_value, 0, e_lrsel), 21);
      bfd_put_32 (stub_bfd, insn, loc);
      loc += 4;

      /* If we are relocating a return value, then we're going to have
	 to return into the stub, then perform the return value relocation.  */
      if (strncmp (entry->root.string + 14, "NO", 2))
	{
	  /* To return to the stub we "ble" to the target and copy the return
	     pointer from %r31 into %r2.  */
	  insn = hppa_rebuild_insn (stub_bfd,
				    BLE_SR4_R1,
				    hppa_field_adjust (sym_value, 0,
						       e_rrsel) >> 2,
				    17);
	  bfd_put_32 (stub_bfd, insn, loc);
	  bfd_put_32 (stub_bfd, COPY_R31_R2, loc + 4);

	  /* Reload the return pointer for our caller from the stack.  */
	  bfd_put_32 (stub_bfd, LDW_M8R30_R31, loc + 8);
	  loc += 12;

	  /* Perform the return value relocation.  */
	  if (!strncmp (entry->root.string + 14, "GF", 2))
	    {
	      bfd_put_32 (stub_bfd, STW_ARG_M16R30 | (28 << 16), loc);
	      bfd_put_32 (stub_bfd, FLDW_M16R30_FARG | 4, loc + 4);
	      loc += 8;
	    }
	  else if (!strncmp (entry->root.string + 14, "FG", 2))
	    {
	      bfd_put_32 (stub_bfd, FSTW_FARG_M16R30 | 4, loc);
	      bfd_put_32 (stub_bfd, LDW_M16R30_ARG | (28 << 16), loc + 4);
	      loc += 8;
	    }
	  else if (!strncmp (entry->root.string + 2, "GD", 2))
	    {
	      bfd_put_32 (stub_bfd, STW_ARG_M12R30 | (28 << 16), loc);
	      bfd_put_32 (stub_bfd, STW_ARG_M16R30 | (29 << 16), loc + 4);
	      bfd_put_32 (stub_bfd, FLDD_M16R30_FARG | 4, loc + 8);
	      loc += 12;
	    }
	  else if (!strncmp (entry->root.string + 2, "DG", 2))
	    {
	      bfd_put_32 (stub_bfd, FSTD_FARG_M16R30 | 4, loc);
	      bfd_put_32 (stub_bfd, LDW_M12R30_ARG | (28 << 16), loc + 4);
	      bfd_put_32 (stub_bfd, LDW_M16R30_ARG | (29 << 16), loc + 8);
	      loc += 12;
	    }
	  /* Branch back to the user's code now.  */
	  bfd_put_32 (stub_bfd, BV_N_0_R31, loc);
	  loc += 4;
	}
      else
	{
	  /* No return value relocation, so we can simply "be" to the
	     target and copy out return pointer into %r2.  */
	  insn = hppa_rebuild_insn (stub_bfd, BE_SR4_R1,
				    hppa_field_adjust (sym_value, 0,
						       e_rrsel) >> 2, 17);
	  bfd_put_32 (stub_bfd, insn, loc);
	  bfd_put_32 (stub_bfd, COPY_R31_R2, loc + 4);
	  loc += 8;
	}

      /* Update the location and offsets.  */
      stub_hash_table->location += (loc - begin_loc);
      stub_hash_table->offset += (loc - begin_loc);
    }
  else
d972 1
a972 1
     bfd *output_bfd;
d978 1
a978 2
  Elf_Internal_Sym *local_syms, *isym, **all_local_syms;
  Elf32_External_Sym *ext_syms, *esym;
a980 1
  struct elf32_hppa_args_hash_table *args_hash_table = 0;
a991 10
  /* Likewise for the argument location hash table.  */
  args_hash_table = ((struct elf32_hppa_args_hash_table *)
		     bfd_malloc (sizeof (struct elf32_hppa_args_hash_table)));
  if (!args_hash_table)
    goto error_return;

  if (!elf32_hppa_args_hash_table_init (args_hash_table,
					elf32_hppa_args_hash_newfunc))
    goto error_return;

a993 1
  elf32_hppa_hash_table(link_info)->args_hash_table = args_hash_table;
a1000 82
  /* We want to read in symbol extension records only once.  To do this
     we need to read in the local symbols in parallel and save them for
     later use; so hold pointers to the local symbols in an array.  */
  all_local_syms
    = (Elf_Internal_Sym **) bfd_malloc (sizeof (Elf_Internal_Sym *)
					* bfd_count);
  if (all_local_syms == NULL)
    goto error_return;
  memset (all_local_syms, 0, sizeof (Elf_Internal_Sym *) * bfd_count);

  /* Walk over all the input BFDs adding entries to the args hash table
     for all the external functions.  */
  for (input_bfd = link_info->input_bfds, index = 0;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next, index++)
    {
      /* We'll need the symbol table in a second.  */
      symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
      if (symtab_hdr->sh_info == 0)
	continue;

      /* We need an array of the local symbols attached to the input bfd.
	 Unfortunately, we're going to have to read & swap them in.  */
      local_syms
	= (Elf_Internal_Sym *) bfd_malloc (symtab_hdr->sh_info
					   * sizeof (Elf_Internal_Sym));
      if (local_syms == NULL)
	{
	  for (i = 0; i < bfd_count; i++)
	    if (all_local_syms[i])
	      free (all_local_syms[i]);
	  free (all_local_syms);
	  goto error_return;
	}
      all_local_syms[index] = local_syms;

      ext_syms
	= (Elf32_External_Sym *) bfd_malloc (symtab_hdr->sh_info
					     * sizeof (Elf32_External_Sym));
      if (ext_syms == NULL)
	{
	  for (i = 0; i < bfd_count; i++)
	    if (all_local_syms[i])
	      free (all_local_syms[i]);
	  free (all_local_syms);
	  goto error_return;
	}

      if (bfd_seek (input_bfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_read (ext_syms, 1,
		       (symtab_hdr->sh_info
			* sizeof (Elf32_External_Sym)), input_bfd)
	  != (symtab_hdr->sh_info * sizeof (Elf32_External_Sym)))
	{
	  for (i = 0; i < bfd_count; i++)
	    if (all_local_syms[i])
	      free (all_local_syms[i]);
	  free (all_local_syms);
	  free (ext_syms);
	  goto error_return;
	}

      /* Swap the local symbols in.  */
      isym = local_syms;
      esym = ext_syms;
      for (i = 0; i < symtab_hdr->sh_info; i++, esym++, isym++)
	 bfd_elf32_swap_symbol_in (input_bfd, esym, isym);

      /* Now we can free the external symbols.  */
      free (ext_syms);

      if (elf32_hppa_read_symext_info (input_bfd, symtab_hdr, args_hash_table,
				       local_syms) == false)
	{
	  for (i = 0; i < bfd_count; i++)
	    if (all_local_syms[i])
	      free (all_local_syms[i]);
	  free (all_local_syms);
	  goto error_return;
	}
    }

d1100 1
a1100 1
	      long r_type, callee_args, caller_args, size_of_stub;
a1103 1
	      struct elf32_hppa_args_hash_entry *args_hash;
a1198 18
	      args_hash = elf32_hppa_args_hash_lookup (args_hash_table,
						       sym_name, false, false);

	      /* Get both caller and callee argument information.  */
	      if (args_hash == NULL)
		callee_args = 0;
	      else
		callee_args = args_hash->arg_bits;

	      /* For calls get the caller's bits from the addend of
		 the call relocation.  For PLABELS the caller's bits
		 are assumed to have all args & return values in general
		 registers (0x155).  */
	      if (r_type == R_PARISC_PCREL17F)
		caller_args = HPPA_R_ARG_RELOC (irela->r_addend);
	      else
		caller_args = 0x155;

d1211 1
a1211 3
	      size_of_stub = elf32_hppa_size_of_stub (callee_args,
						      caller_args,
						      location,
d1238 1
a1238 2
		  elf32_hppa_name_of_stub (caller_args, callee_args,
					   location, destination, stub_name);
a1301 5
  if (args_hash_table)
    {
      elf32_hppa_hash_table(link_info)->args_hash_table = NULL;
      free (args_hash_table);
    }
d1311 3
a1313 11
#define bfd_elf32_bfd_is_local_label		hppa_elf_is_local_label

/* Symbol extension stuff.  */
#define bfd_elf32_set_section_contents		elf32_hppa_set_section_contents
#define elf_info_to_howto			elf32_hppa_info_to_howto
#define elf_backend_symbol_table_processing \
  elf32_hppa_backend_symbol_table_processing
#define elf_backend_begin_write_processing \
  elf32_hppa_backend_begin_write_processing
#define elf_backend_final_write_processing \
  elf32_hppa_backend_final_write_processing
a1317 2
#define elf_backend_link_output_symbol_hook \
  elf32_hppa_link_output_symbol_hook
d1320 2
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 1995 Free Software Foundation, Inc.
d299 3
a301 1
  {R_PARISC_DIR32, 0, 0, 32, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DIR32"},
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d942 1
a942 1
hppa_elf_gen_reloc_type (abfd, base_type, format, field, ignore)
d948 1
@


1.1
log
@Initial revision
@
text
@d218 1
a218 1
static void elf_info_to_howto
d578 1
a578 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d630 1
a630 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d656 1
a656 4
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }
d835 3
d1172 1
a1172 1
elf_info_to_howto (abfd, cache_ptr, dst)
d1354 1
a1354 1
	new_name = malloc (len);
d1356 1
a1356 4
	  {
	    bfd_set_error (bfd_error_no_memory);
	    return bfd_reloc_notsupported;
	  }
d1398 1
a1398 1
	    stub_name = malloc (len);
d1400 1
a1400 4
	      {
		bfd_set_error (bfd_error_no_memory);
		return bfd_reloc_notsupported;
	      }
d1679 1
a1679 1
  new_name = malloc (len);
d1681 1
a1681 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d1775 1
a1775 4
    {
      bfd_set_error (bfd_error_no_memory);
      abort();			/* FIXME */
    }
d1815 1
a1815 4
    {
      bfd_set_error (bfd_error_no_memory);
      abort();			/* FIXME */
    }
d1853 1
a1853 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d1868 1
a1868 1
			     (symextn_hdr->contents
d1928 1
a1928 1
  contents = (bfd_byte *) malloc ((size_t) symextn_sec->_raw_size);
d1930 1
a1930 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d1988 1
a1988 1
	      new_name = malloc (len);
a1990 1
		  bfd_set_error (bfd_error_no_memory);
d2478 1
a2478 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d2512 1
a2512 1
		     malloc (sizeof (struct elf32_hppa_stub_hash_table)));
d2514 1
a2514 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d2522 1
a2522 1
		     malloc (sizeof (struct elf32_hppa_args_hash_table)));
d2524 1
a2524 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d2544 2
a2545 1
    = (Elf_Internal_Sym **) malloc (sizeof (Elf_Internal_Sym *) * bfd_count);
d2547 1
a2547 4
    {
      bfd_set_error (bfd_error_no_memory);
      goto error_return;
    }
d2564 2
a2565 2
	= (Elf_Internal_Sym *)malloc (symtab_hdr->sh_info
				      * sizeof (Elf_Internal_Sym));
a2567 1
	  bfd_set_error (bfd_error_no_memory);
d2577 2
a2578 2
	= (Elf32_External_Sym *)malloc (symtab_hdr->sh_info
					* sizeof (Elf32_External_Sym));
a2580 1
	  bfd_set_error (bfd_error_no_memory);
d2665 3
a2667 1
	    = (Elf32_External_Rela *) malloc (section->reloc_count * sizeof (Elf32_External_Rela));
a2669 1
	      bfd_set_error (bfd_error_no_memory);
d2679 2
a2680 1
	    = (Elf_Internal_Rela *) malloc (section->reloc_count * sizeof (Elf_Internal_Rela));
a2682 1
	      bfd_set_error (bfd_error_no_memory);
d2779 1
a2779 1
		  new_name = malloc (strlen (sym_name) + 10);
a2781 1
		      bfd_set_error (bfd_error_bad_value);
d2865 1
a2865 1
		  stub_name = malloc (len);
a2867 2
		      bfd_set_error (bfd_error_no_memory);

a2909 1
			  bfd_set_error (bfd_error_no_memory);
d2963 1
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d218 1
a218 1
static void elf32_hppa_info_to_howto
d578 4
a581 1
    return NULL;
d633 4
a636 1
    return NULL;
d662 4
a665 1
    return NULL;
a843 3
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d1178 1
a1178 1
elf32_hppa_info_to_howto (abfd, cache_ptr, dst)
d1360 1
a1360 1
	new_name = bfd_malloc (len);
d1362 4
a1365 1
	  return bfd_reloc_notsupported;
d1407 1
a1407 1
	    stub_name = bfd_malloc (len);
d1409 4
a1412 1
	      return bfd_reloc_notsupported;
d1691 1
a1691 1
  new_name = bfd_malloc (len);
d1693 4
a1696 1
    return false;
d1790 4
a1793 1
    abort();			/* FIXME */
d1833 4
a1836 1
    abort();			/* FIXME */
d1874 4
a1877 1
    return false;
d1892 1
a1892 1
			     ((unsigned char *)symextn_hdr->contents
d1952 1
a1952 1
  contents = (bfd_byte *) bfd_malloc ((size_t) symextn_sec->_raw_size);
d1954 4
a1957 1
    return false;
d2015 1
a2015 1
	      new_name = bfd_malloc (len);
d2018 1
d2506 4
a2509 1
    return false;
d2543 1
a2543 1
		     bfd_malloc (sizeof (struct elf32_hppa_stub_hash_table)));
d2545 4
a2548 1
    goto error_return;
d2556 1
a2556 1
		     bfd_malloc (sizeof (struct elf32_hppa_args_hash_table)));
d2558 4
a2561 1
    goto error_return;
d2581 1
a2581 2
    = (Elf_Internal_Sym **) bfd_malloc (sizeof (Elf_Internal_Sym *)
					* bfd_count);
d2583 4
a2586 1
    goto error_return;
d2603 2
a2604 2
	= (Elf_Internal_Sym *) bfd_malloc (symtab_hdr->sh_info
					   * sizeof (Elf_Internal_Sym));
d2607 1
d2617 2
a2618 2
	= (Elf32_External_Sym *) bfd_malloc (symtab_hdr->sh_info
					     * sizeof (Elf32_External_Sym));
d2621 1
d2706 1
a2706 3
	    = ((Elf32_External_Rela *)
	       bfd_malloc (section->reloc_count
			   * sizeof (Elf32_External_Rela)));
d2709 1
d2719 1
a2719 2
	    = ((Elf_Internal_Rela *)
	       bfd_malloc (section->reloc_count * sizeof (Elf_Internal_Rela)));
d2722 1
d2819 1
a2819 1
		  new_name = bfd_malloc (strlen (sym_name) + 10);
d2822 1
d2906 1
a2906 1
		  stub_name = bfd_malloc (len);
d2909 2
d2953 1
a3006 1
#define elf_info_to_howto			elf32_hppa_info_to_howto
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d942 1
a942 1
hppa_elf_gen_reloc_type (abfd, base_type, format, field, ignore, sym)
a947 1
     asymbol *sym;
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d299 1
a299 3
  /* The values in DIR32 are to placate the check in
     _bfd_stab_section_find_nearest_line.  */
  {R_PARISC_DIR32, 0, 2, 32, false, 0, complain_overflow_bitfield, hppa_elf_reloc, "R_PARISC_DIR32", false, 0, 0xffffffff, false},
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 2
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 1997
   Free Software Foundation, Inc.
d30 1
d237 1
a237 1
static boolean hppa_elf_is_local_label_name PARAMS ((bfd *, const char *));
d956 2
a957 2
  final_types = ((elf32_hppa_reloc_type **)
		 bfd_alloc (abfd, sizeof (elf32_hppa_reloc_type *) * 2));
d962 2
a963 2
  finaltype = ((elf32_hppa_reloc_type *)
	       bfd_alloc (abfd, sizeof (elf32_hppa_reloc_type)));
d1556 1
a1556 1
hppa_elf_is_local_label_name (abfd, name)
d1558 1
a1558 1
     const char *name;
d1560 1
a1560 1
  return (name[0] == 'L' && name[1] == '$');
d2962 1
a2962 1
#define bfd_elf32_bfd_is_local_label_name	hppa_elf_is_local_label_name
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d29 1
a31 5
#include "elf/hppa.h"
#include "libhppa.h"
#include "elf32-hppa.h"
#define ARCH_SIZE		32
#include "elf-hppa.h"
d33 43
d86 5
a90 1
   necessary to build the linker stubs during a link.  */
d126 17
d156 3
d167 26
d202 3
d209 30
d255 4
d274 5
d280 4
a283 1
  PARAMS ((bfd_vma, bfd_vma, const char *));
d286 220
a505 1
  PARAMS ((bfd_vma, bfd_vma, char *));
d518 18
d555 4
d613 32
d666 1
d854 1
a854 1
		     input_section, rel->r_offset, true)))
d873 7
d897 1
a897 1
		     input_section, rel->r_offset, true)))
d940 280
d1229 1
a1229 1
     bfd *output_bfd ATTRIBUTE_UNUSED;
d1332 4
a1335 1
	unsigned int len;
d1352 2
d1366 21
d1389 3
a1391 1
	    || ((int)(value - location) < (int)0xfffc0000))
d1404 2
a1405 1
	    elf32_hppa_name_of_stub (location, value, stub_name);
d1423 1
d1495 22
a1516 3
	        else
		  return bfd_reloc_notsupported;
	      }
d1537 17
a1553 2
/* Undo the generic ELF code's subtraction of section->vma from the
   value of each external symbol.  */
d1556 3
a1558 8
elf32_hppa_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const Elf_Internal_Sym *sym ATTRIBUTE_UNUSED;
     const char **namep ATTRIBUTE_UNUSED;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
d1560 1
a1560 2
  *valp += (*secp)->vma;
  return true;
d1563 3
a1565 3
/* Determine the name of the stub needed to perform a call assuming the
   argument relocation bits for caller and callee are in CALLER and CALLEE
   for a call from LOCATION to DESTINATION.  Copy the name into STUB_NAME.  */
d1568 3
a1570 4
elf32_hppa_name_of_stub (location, destination, stub_name)
     bfd_vma location ATTRIBUTE_UNUSED;
     bfd_vma destination ATTRIBUTE_UNUSED;
     char *stub_name;
d1572 2
a1573 2
  strcpy (stub_name, "_____long_branch_stub_");
}
d1575 610
a2184 3
/* Compute the size of the stub needed to call from LOCATION to DESTINATION
   (a function named SYM_NAME), with argument relocation bits CALLER and
   CALLEE.  Return zero if no stub is needed to perform such a call.  */
d2187 2
a2188 1
elf32_hppa_size_of_stub (location, destination, sym_name)
d2192 5
a2196 1
  /* Determine if a long branch stub is needed.  */
d2198 2
a2199 1
	|| ((int)(location - destination) < (int)0xfffc0000)))
d2202 41
a2242 1
  if (!strncmp ("$$", sym_name, 2)
d2283 125
a2407 1
  if (1)
d2501 1
a2501 1
     bfd *output_bfd ATTRIBUTE_UNUSED;
d2507 2
a2508 1
  Elf_Internal_Sym *local_syms, **all_local_syms;
d2511 1
d2523 10
d2535 1
d2543 82
d2724 1
a2724 1
	      long r_type, size_of_stub;
d2728 1
d2824 18
d2854 3
a2856 1
	      size_of_stub = elf32_hppa_size_of_stub (location,
d2883 2
a2884 1
		  elf32_hppa_name_of_stub (location, destination, stub_name);
d2948 5
d2962 11
a2972 3
#define bfd_elf32_bfd_is_local_label_name	elf_hppa_is_local_label_name
#define elf_info_to_howto               	elf_hppa_info_to_howto
#define elf_info_to_howto_rel           	elf_hppa_info_to_howto_rel
d2977 2
a2980 2
#define elf_backend_fake_sections		elf_hppa_fake_sections

@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000, 2001
d5 2
a6 1
   Original code by
a9 1
   Largely rewritten by Alan Modra <alan@@linuxcare.com.au>
a35 1
#include "elf32-hppa.h"
a36 10
/* In order to gain some understanding of code in this file without
   knowing all the intricate details of the linker, note the
   following:

   Functions named elf32_hppa_* are called by external routines, other
   functions are only called locally.  elf32_hppa_* functions appear
   in this file more or less in the order in which they are called
   from external routines.  eg. elf32_hppa_check_relocs is called
   early in the link process, elf32_hppa_finish_dynamic_sections is
   one of the last functions.  */
d38 2
a39 1
/* We use two hash tables to hold information for linking PA ELF objects.
d47 1
a47 1
   necessary to build the linker stubs during a link.
d49 1
a49 1
   There are a number of different stubs generated by the linker.
d51 1
a51 61
   Long branch stub:
   :		ldil LR'X,%r1
   :		be,n RR'X(%sr4,%r1)

   PIC long branch stub:
   :		b,l .+8,%r1
   :		addil LR'X - ($PIC_pcrel$0 - 4),%r1
   :		be,n RR'X - ($PIC_pcrel$0 - 8)(%sr4,%r1)

   Import stub to call shared library routine from normal object file
   (single sub-space version)
   :		addil LR'lt_ptr+ltoff,%dp	; get procedure entry point
   :		ldw RR'lt_ptr+ltoff(%r1),%r21
   :            bv %r0(%r21)
   :		ldw RR'lt_ptr+ltoff+4(%r1),%r19	; get new dlt value.

   Import stub to call shared library routine from shared library
   (single sub-space version)
   :		addil LR'ltoff,%r19		; get procedure entry point
   :		ldw RR'ltoff(%r1),%r21
   :            bv %r0(%r21)
   :		ldw RR'ltoff+4(%r1),%r19	; get new dlt value.

   Import stub to call shared library routine from normal object file
   (multiple sub-space support)
   :		addil LR'lt_ptr+ltoff,%dp	; get procedure entry point
   :		ldw RR'lt_ptr+ltoff(%r1),%r21
   :		ldw RR'lt_ptr+ltoff+4(%r1),%r19	; get new dlt value.
   :		ldsid (%r21),%r1
   :		mtsp %r1,%sr0
   :		be 0(%sr0,%r21)			; branch to target
   :		stw %rp,-24(%sp)		; save rp

   Import stub to call shared library routine from shared library
   (multiple sub-space support)
   :		addil LR'ltoff,%r19		; get procedure entry point
   :		ldw RR'ltoff(%r1),%r21
   :		ldw RR'ltoff+4(%r1),%r19	; get new dlt value.
   :		ldsid (%r21),%r1
   :		mtsp %r1,%sr0
   :		be 0(%sr0,%r21)			; branch to target
   :		stw %rp,-24(%sp)		; save rp

   Export stub to return from shared lib routine (multiple sub-space support)
   One of these is created for each exported procedure in a shared
   library (and stored in the shared lib).  Shared lib routines are
   called via the first instruction in the export stub so that we can
   do an inter-space return.  Not required for single sub-space.
   :		bl,n X,%rp			; trap the return
   :		nop
   :		ldw -24(%sp),%rp		; restore the original rp
   :		ldsid (%rp),%r1
   :		mtsp %r1,%sr0
   :		be,n 0(%sr0,%rp)		; inter-space return  */

#define PLT_ENTRY_SIZE 8
#define PLABEL_PLT_ENTRY_SIZE PLT_ENTRY_SIZE
#define GOT_ENTRY_SIZE 4
#define ELF_DYNAMIC_INTERPRETER "/lib/ld.so.1"

static const bfd_byte plt_stub[] =
d53 3
a55 46
  0x0e, 0x80, 0x10, 0x96,  /* 1: ldw	0(%r20),%r22		*/
  0xea, 0xc0, 0xc0, 0x00,  /*    bv	%r0(%r22)		*/
  0x0e, 0x88, 0x10, 0x95,  /*    ldw	4(%r20),%r21		*/
#define PLT_STUB_ENTRY (3*4)
  0xea, 0x9f, 0x1f, 0xdd,  /*    b,l	1b,%r20			*/
  0xd6, 0x80, 0x1c, 0x1e,  /*    depi	0,31,2,%r20		*/
  0x00, 0xc0, 0xff, 0xee,  /* 9: .word	fixup_func		*/
  0xde, 0xad, 0xbe, 0xef   /*    .word	fixup_ltp		*/
};

/* Section name for stubs is the associated section name plus this
   string.  */
#define STUB_SUFFIX ".stub"

/* Setting the following non-zero makes all long branch stubs
   generated during a shared link of the PIC variety.  This saves on
   relocs, but costs one extra instruction per stub.  */
#ifndef LONG_BRANCH_PIC_IN_SHLIB
#define LONG_BRANCH_PIC_IN_SHLIB 1
#endif

/* Set this non-zero to use import stubs instead of long branch stubs
   where a .plt entry exists for the symbol.  This is a fairly useless
   option as import stubs are bigger than PIC long branch stubs.  */
#ifndef LONG_BRANCH_VIA_PLT
#define LONG_BRANCH_VIA_PLT 0
#endif

/* We don't need to copy any PC- or GP-relative dynamic relocs into a
   shared object's dynamic section.  */
#ifndef RELATIVE_DYNAMIC_RELOCS
#define RELATIVE_DYNAMIC_RELOCS 0
#endif

enum elf32_hppa_stub_type {
  hppa_stub_long_branch,
  hppa_stub_long_branch_shared,
  hppa_stub_import,
  hppa_stub_import_shared,
  hppa_stub_export,
  hppa_stub_none
};

struct elf32_hppa_stub_hash_entry {

  /* Base hash table entry structure.  */
d58 2
a59 10
  /* The stub section.  */
  asection *stub_sec;

#if ! LONG_BRANCH_PIC_IN_SHLIB
  /* It's associated reloc section.  */
  asection *reloc_sec;
#endif

  /* Offset within stub_sec of the beginning of this stub.  */
  bfd_vma stub_offset;
d63 1
a63 1
  bfd_vma target_value;
a64 9

  enum elf32_hppa_stub_type stub_type;

  /* The symbol table entry, if any, that this was derived from.  */
  struct elf32_hppa_link_hash_entry *h;

  /* Where this stub is being called from, or, in the case of combined
     stub sections, the first input section in the group.  */
  asection *id_sec;
d67 4
a70 1
struct elf32_hppa_link_hash_entry {
d72 2
a73 1
  struct elf_link_hash_entry elf;
d75 2
a76 3
  /* A pointer to the most recently used stub hash entry against this
     symbol.  */
  struct elf32_hppa_stub_hash_entry *stub_cache;
d78 2
a79 5
#if ! LONG_BRANCH_PIC_IN_SHLIB
  /* Used to track whether we have allocated space for a long branch
     stub relocation for this symbol in the given section.  */
  asection *stub_reloc_sec;
#endif
d81 1
a81 4
#if ! LONG_BRANCH_PIC_IN_SHLIB || RELATIVE_DYNAMIC_RELOCS
  /* Used to count relocations for delayed sizing of relocation
     sections.  */
  struct elf32_hppa_dyn_reloc_entry {
d83 3
a85 24
    /* Next relocation in the chain.  */
    struct elf32_hppa_dyn_reloc_entry *next;

    /* The section in dynobj.  */
    asection *section;

    /* Number of relocs copied in this section.  */
    bfd_size_type count;
  } *reloc_entries;
#endif

  /* Set during a static link if we detect a function is PIC.  */
  unsigned int maybe_pic_call:1;

  /* Set if the only reason we need a .plt entry is for a non-PIC to
     PIC function call.  */
  unsigned int pic_call:1;

  /* Set if this symbol is used by a plabel reloc.  */
  unsigned int plabel:1;

  /* Set if this symbol is an init or fini function and thus should
     use an absolute reloc.  */
  unsigned int plt_abs:1;
d88 2
a89 2
struct elf32_hppa_link_hash_table {

d94 1
a94 4
  struct bfd_hash_table stub_hash_table;

  /* Linker stub bfd.  */
  bfd *stub_bfd;
d96 2
a97 38
  /* Linker call-backs.  */
  asection * (*add_stub_section) PARAMS ((const char *, asection *));
  void (*layout_sections_again) PARAMS ((void));

  /* Array to keep track of which stub sections have been created, and
     information on stub grouping.  */
  struct map_stub {
    /* This is the section to which stubs in the group will be
       attached.  */
    asection *link_sec;
    /* The stub section.  */
    asection *stub_sec;
#if ! LONG_BRANCH_PIC_IN_SHLIB
    /* The stub section's reloc section.  */
    asection *reloc_sec;
#endif
  } *stub_group;

  /* Short-cuts to get to dynamic linker sections.  */
  asection *sgot;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
  asection *sdynbss;
  asection *srelbss;

  /* Used during a final link to store the base of the text and data
     segments so that we can perform SEGREL relocations.  */
  bfd_vma text_segment_base;
  bfd_vma data_segment_base;

  /* Whether we support multiple sub-spaces for shared libs.  */
  unsigned int multi_subspace:1;

  /* Flags set when PCREL12F and PCREL17F branches detected.  Used to
     select suitable defaults for the stub group size.  */
  unsigned int has_12bit_branch:1;
  unsigned int has_17bit_branch:1;
d99 3
a101 2
  /* Set if we need a .plt stub to support lazy dynamic linking.  */
  unsigned int need_plt_stub:1;
d104 1
a104 7
/* Various hash macros and functions.  */
#define hppa_link_hash_table(p) \
  ((struct elf32_hppa_link_hash_table *) ((p)->hash))

#define hppa_stub_hash_lookup(table, string, create, copy) \
  ((struct elf32_hppa_stub_hash_entry *) \
   bfd_hash_lookup ((table), (string), (create), (copy)))
d106 3
a108 2
static struct bfd_hash_entry *stub_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d110 2
a111 5
static struct bfd_hash_entry *hppa_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));

static struct bfd_link_hash_table *elf32_hppa_link_hash_table_create
  PARAMS ((bfd *));
d113 3
a115 27
/* Stub handling functions.  */
static char *hppa_stub_name
  PARAMS ((const asection *, const asection *,
	   const struct elf32_hppa_link_hash_entry *,
	   const Elf_Internal_Rela *));

static struct elf32_hppa_stub_hash_entry *hppa_get_stub_entry
  PARAMS ((const asection *, const asection *,
	   struct elf32_hppa_link_hash_entry *,
	   const Elf_Internal_Rela *,
	   struct elf32_hppa_link_hash_table *));

static struct elf32_hppa_stub_hash_entry *hppa_add_stub
  PARAMS ((const char *, asection *, struct elf32_hppa_link_hash_table *));

static enum elf32_hppa_stub_type hppa_type_of_stub
  PARAMS ((asection *, const Elf_Internal_Rela *,
	   struct elf32_hppa_link_hash_entry *, bfd_vma));

static boolean hppa_build_one_stub
  PARAMS ((struct bfd_hash_entry *, PTR));

static boolean hppa_size_one_stub
  PARAMS ((struct bfd_hash_entry *, PTR));

/* BFD and elf backend functions.  */
static boolean elf32_hppa_object_p PARAMS ((bfd *));
d121 4
a124 2
static boolean elf32_hppa_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
d126 2
a127 3
static boolean elf32_hppa_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *,
	   asection *, const Elf_Internal_Rela *));
d129 3
a131 3
static asection *elf32_hppa_gc_mark_hook
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
d133 4
a136 3
static boolean elf32_hppa_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *,
	   asection *, const Elf_Internal_Rela *));
d138 6
a143 2
static void elf32_hppa_hide_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
d145 2
a146 2
static boolean elf32_hppa_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
d148 2
a149 2
static boolean hppa_handle_PIC_calls
  PARAMS ((struct elf_link_hash_entry *, PTR));
d151 2
a152 2
static boolean allocate_plt_and_got
  PARAMS ((struct elf_link_hash_entry *, PTR));
d154 4
a157 5
#if ((! LONG_BRANCH_PIC_IN_SHLIB && LONG_BRANCH_VIA_PLT) \
     || RELATIVE_DYNAMIC_RELOCS)
static boolean hppa_discard_copies
  PARAMS ((struct elf_link_hash_entry *, PTR));
#endif
d159 18
a176 2
static boolean clobber_millicode_symbols
  PARAMS ((struct elf_link_hash_entry *, struct bfd_link_info *));
d178 1
a178 2
static boolean elf32_hppa_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
d180 2
a181 17
static boolean elf32_hppa_final_link
  PARAMS ((bfd *, struct bfd_link_info *));

static void hppa_record_segment_addr
  PARAMS ((bfd *, asection *, PTR));

static bfd_reloc_status_type final_link_relocate
  PARAMS ((asection *, bfd_byte *, const Elf_Internal_Rela *,
	   bfd_vma, struct elf32_hppa_link_hash_table *, asection *,
	   struct elf32_hppa_link_hash_entry *));

static boolean elf32_hppa_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *,
	   bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));

static int hppa_unwind_entry_compare
  PARAMS ((const PTR, const PTR));
a182 12
static boolean elf32_hppa_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));

static boolean elf32_hppa_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

static void elf32_hppa_post_process_headers
  PARAMS ((bfd *, struct bfd_link_info *));

static int elf32_hppa_elf_get_symbol_type
  PARAMS ((Elf_Internal_Sym *, int));
d189 1
a189 1
stub_hash_newfunc (entry, table, string)
d201 5
a205 7
    {
      ret = ((struct elf32_hppa_stub_hash_entry *)
	     bfd_hash_allocate (table,
				sizeof (struct elf32_hppa_stub_hash_entry)));
      if (ret == NULL)
	return NULL;
    }
d214 1
a214 5
      ret->stub_sec = NULL;
#if ! LONG_BRANCH_PIC_IN_SHLIB
      ret->reloc_sec = NULL;
#endif
      ret->stub_offset = 0;
a216 3
      ret->stub_type = hppa_stub_long_branch;
      ret->h = NULL;
      ret->id_sec = NULL;
d222 1
a222 1
/* Initialize an entry in the link hash table.  */
d224 12
a235 43
static struct bfd_hash_entry *
hppa_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
{
  struct elf32_hppa_link_hash_entry *ret;

  ret = (struct elf32_hppa_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    {
      ret = ((struct elf32_hppa_link_hash_entry *)
	     bfd_hash_allocate (table,
				sizeof (struct elf32_hppa_link_hash_entry)));
      if (ret == NULL)
	return NULL;
    }

  /* Call the allocation method of the superclass.  */
  ret = ((struct elf32_hppa_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));

  if (ret)
    {
      /* Initialize the local fields.  */
#if ! LONG_BRANCH_PIC_IN_SHLIB
      ret->stub_reloc_sec = NULL;
#endif
      ret->stub_cache = NULL;
#if ! LONG_BRANCH_PIC_IN_SHLIB || RELATIVE_DYNAMIC_RELOCS
      ret->reloc_entries = NULL;
#endif
      ret->maybe_pic_call = 0;
      ret->pic_call = 0;
      ret->plabel = 0;
      ret->plt_abs = 0;
    }

  return (struct bfd_hash_entry *) ret;
d248 2
a249 1
  ret = ((struct elf32_hppa_link_hash_table *) bfd_alloc (abfd, sizeof (*ret)));
d252 2
a253 2

  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd, hppa_link_hash_newfunc))
d258 4
a261 21

  /* Init the stub hash table too.  */
  if (!bfd_hash_table_init (&ret->stub_hash_table, stub_hash_newfunc))
    return NULL;

  ret->stub_bfd = NULL;
  ret->add_stub_section = NULL;
  ret->layout_sections_again = NULL;
  ret->stub_group = NULL;
  ret->sgot = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
  ret->text_segment_base = (bfd_vma) -1;
  ret->data_segment_base = (bfd_vma) -1;
  ret->multi_subspace = 0;
  ret->has_12bit_branch = 0;
  ret->has_17bit_branch = 0;
  ret->need_plt_stub = 0;
d266 1
a266 1
/* Build a name for an entry in the stub hash table.  */
d268 1
a268 9
static char *
hppa_stub_name (input_section, sym_sec, hash, rel)
     const asection *input_section;
     const asection *sym_sec;
     const struct elf32_hppa_link_hash_entry *hash;
     const Elf_Internal_Rela *rel;
{
  char *stub_name;
  size_t len;
d270 56
a325 73
  if (hash)
    {
      len = 8 + 1 + strlen (hash->elf.root.root.string) + 1 + 8 + 1;
      stub_name = bfd_malloc (len);
      if (stub_name != NULL)
	{
	  sprintf (stub_name, "%08x_%s+%x",
		   input_section->id & 0xffffffff,
		   hash->elf.root.root.string,
		   (int) rel->r_addend & 0xffffffff);
	}
    }
  else
    {
      len = 8 + 1 + 8 + 1 + 8 + 1 + 8 + 1;
      stub_name = bfd_malloc (len);
      if (stub_name != NULL)
	{
	  sprintf (stub_name, "%08x_%x:%x+%x",
		   input_section->id & 0xffffffff,
		   sym_sec->id & 0xffffffff,
		   (int) ELF32_R_SYM (rel->r_info) & 0xffffffff,
		   (int) rel->r_addend & 0xffffffff);
	}
    }
  return stub_name;
}

/* Look up an entry in the stub hash.  Stub entries are cached because
   creating the stub name takes a bit of time.  */

static struct elf32_hppa_stub_hash_entry *
hppa_get_stub_entry (input_section, sym_sec, hash, rel, hplink)
     const asection *input_section;
     const asection *sym_sec;
     struct elf32_hppa_link_hash_entry *hash;
     const Elf_Internal_Rela *rel;
     struct elf32_hppa_link_hash_table *hplink;
{
  struct elf32_hppa_stub_hash_entry *stub_entry;
  const asection *id_sec;

  /* If this input section is part of a group of sections sharing one
     stub section, then use the id of the first section in the group.
     Stub names need to include a section id, as there may well be
     more than one stub used to reach say, printf, and we need to
     distinguish between them.  */
  id_sec = hplink->stub_group[input_section->id].link_sec;

  if (hash != NULL && hash->stub_cache != NULL
      && hash->stub_cache->h == hash
      && hash->stub_cache->id_sec == id_sec)
    {
      stub_entry = hash->stub_cache;
    }
  else
    {
      char *stub_name;

      stub_name = hppa_stub_name (id_sec, sym_sec, hash, rel);
      if (stub_name == NULL)
	return NULL;

      stub_entry = hppa_stub_hash_lookup (&hplink->stub_hash_table,
					  stub_name, false, false);
      if (stub_entry == NULL)
	{
	  if (hash == NULL || hash->elf.root.type != bfd_link_hash_undefweak)
	    (*_bfd_error_handler) (_("%s(%s+0x%lx): cannot find stub entry %s"),
				   bfd_get_filename (input_section->owner),
				   input_section->name,
				   (long) rel->r_offset,
				   stub_name);
d328 1
a328 4
	{
	  if (hash != NULL)
	    hash->stub_cache = stub_entry;
	}
d330 1
a330 2
      free (stub_name);
    }
d332 2
a333 22
  return stub_entry;
}

/* Add a new stub entry to the stub hash.  Not all fields of the new
   stub entry are initialised.  */

static struct elf32_hppa_stub_hash_entry *
hppa_add_stub (stub_name, section, hplink)
     const char *stub_name;
     asection *section;
     struct elf32_hppa_link_hash_table *hplink;
{
  asection *link_sec;
  asection *stub_sec;
  struct elf32_hppa_stub_hash_entry *stub_entry;

  link_sec = hplink->stub_group[section->id].link_sec;
  stub_sec = hplink->stub_group[section->id].stub_sec;
  if (stub_sec == NULL)
    {
      stub_sec = hplink->stub_group[link_sec->id].stub_sec;
      if (stub_sec == NULL)
d335 1
a335 28
	  size_t len;
	  char *s_name;

	  len = strlen (link_sec->name) + sizeof (STUB_SUFFIX);
	  s_name = bfd_alloc (hplink->stub_bfd, len);
	  if (s_name == NULL)
	    return NULL;

	  strcpy (s_name, link_sec->name);
	  strcpy (s_name + len - sizeof (STUB_SUFFIX), STUB_SUFFIX);
	  stub_sec = (*hplink->add_stub_section) (s_name, link_sec);
	  if (stub_sec == NULL)
	    return NULL;
	  hplink->stub_group[link_sec->id].stub_sec = stub_sec;
	}
      hplink->stub_group[section->id].stub_sec = stub_sec;
    }

  /* Enter this entry into the linker stub hash table.  */
  stub_entry = hppa_stub_hash_lookup (&hplink->stub_hash_table, stub_name,
				      true, false);
  if (stub_entry == NULL)
    {
      (*_bfd_error_handler) (_("%s: cannot create stub entry %s"),
			     bfd_get_filename (section->owner),
			     stub_name);
      return NULL;
    }
d337 2
a338 66
  stub_entry->stub_sec = stub_sec;
#if ! LONG_BRANCH_PIC_IN_SHLIB
  stub_entry->reloc_sec = hplink->stub_group[section->id].reloc_sec;
#endif
  stub_entry->stub_offset = 0;
  stub_entry->id_sec = link_sec;
  return stub_entry;
}

/* Determine the type of stub needed, if any, for a call.  */

static enum elf32_hppa_stub_type
hppa_type_of_stub (input_sec, rel, hash, destination)
     asection *input_sec;
     const Elf_Internal_Rela *rel;
     struct elf32_hppa_link_hash_entry *hash;
     bfd_vma destination;
{
  bfd_vma location;
  bfd_vma branch_offset;
  bfd_vma max_branch_offset;
  unsigned int r_type;

  if (hash != NULL
      && (((hash->elf.root.type == bfd_link_hash_defined
	    || hash->elf.root.type == bfd_link_hash_defweak)
	   && hash->elf.root.u.def.section->output_section == NULL)
	  || (hash->elf.root.type == bfd_link_hash_defweak
	      && hash->elf.dynindx != -1
	      && hash->elf.plt.offset != (bfd_vma) -1)
	  || hash->elf.root.type == bfd_link_hash_undefweak
	  || hash->elf.root.type == bfd_link_hash_undefined
	  || (hash->maybe_pic_call && !(input_sec->flags & SEC_HAS_GOT_REF))))
    {
      /* If output_section is NULL, then it's a symbol defined in a
	 shared library.  We will need an import stub.  Decide between
	 hppa_stub_import and hppa_stub_import_shared later.  For
	 shared links we need stubs for undefined or weak syms too;
	 They will presumably be resolved by the dynamic linker.  */
      return hppa_stub_import;
    }

  /* Determine where the call point is.  */
  location = (input_sec->output_offset
	      + input_sec->output_section->vma
	      + rel->r_offset);

  branch_offset = destination - location - 8;
  r_type = ELF32_R_TYPE (rel->r_info);

  /* Determine if a long branch stub is needed.  parisc branch offsets
     are relative to the second instruction past the branch, ie. +8
     bytes on from the branch instruction location.  The offset is
     signed and counts in units of 4 bytes.  */
  if (r_type == (unsigned int) R_PARISC_PCREL17F)
    {
      max_branch_offset = (1 << (17-1)) << 2;
    }
  else if (r_type == (unsigned int) R_PARISC_PCREL12F)
    {
      max_branch_offset = (1 << (12-1)) << 2;
    }
  else /* R_PARISC_PCREL22F.  */
    {
      max_branch_offset = (1 << (22-1)) << 2;
    }
d340 1
a340 11
  if (branch_offset + max_branch_offset >= 2*max_branch_offset)
    {
#if LONG_BRANCH_VIA_PLT
      if (hash != NULL
	  && hash->elf.dynindx != -1
	  && hash->elf.plt.offset != (bfd_vma) -1
	  && hash->elf.type != STT_PARISC_MILLI)
	{
	  /* If we are doing a shared link and find we need a long
	     branch stub, then go via the .plt if possible.  */
	  return hppa_stub_import;
d343 1
a343 2
#endif
	return hppa_stub_long_branch;
a344 1
  return hppa_stub_none;
d347 1
a347 38
/* Build one linker stub as defined by the stub hash table entry GEN_ENTRY.
   IN_ARG contains the link info pointer.  */

#define LDIL_R1		0x20200000	/* ldil  LR'XXX,%r1		*/
#define BE_SR4_R1	0xe0202002	/* be,n  RR'XXX(%sr4,%r1)	*/

#define BL_R1		0xe8200000	/* b,l   .+8,%r1		*/
#define ADDIL_R1	0x28200000	/* addil LR'XXX,%r1,%r1		*/
#define DEPI_R1		0xd4201c1e	/* depi  0,31,2,%r1		*/

#define ADDIL_DP	0x2b600000	/* addil LR'XXX,%dp,%r1		*/
#define LDW_R1_R21	0x48350000	/* ldw   RR'XXX(%sr0,%r1),%r21	*/
#define BV_R0_R21	0xeaa0c000	/* bv    %r0(%r21)		*/
#define LDW_R1_R19	0x48330000	/* ldw   RR'XXX(%sr0,%r1),%r19	*/

#define ADDIL_R19	0x2a600000	/* addil LR'XXX,%r19,%r1	*/
#define LDW_R1_DP	0x483b0000	/* ldw   RR'XXX(%sr0,%r1),%dp	*/

#define LDSID_R21_R1	0x02a010a1	/* ldsid (%sr0,%r21),%r1	*/
#define MTSP_R1		0x00011820	/* mtsp  %r1,%sr0		*/
#define BE_SR0_R21	0xe2a00000	/* be    0(%sr0,%r21)		*/
#define STW_RP		0x6bc23fd1	/* stw   %rp,-24(%sr0,%sp)	*/

#define BL_RP		0xe8400002	/* b,l,n XXX,%rp		*/
#define NOP		0x08000240	/* nop				*/
#define LDW_RP		0x4bc23fd1	/* ldw   -24(%sr0,%sp),%rp	*/
#define LDSID_RP_R1	0x004010a1	/* ldsid (%sr0,%rp),%r1		*/
#define BE_SR0_RP	0xe0400002	/* be,n  0(%sr0,%rp)		*/

#ifndef R19_STUBS
#define R19_STUBS 1
#endif

#if R19_STUBS
#define LDW_R1_DLT	LDW_R1_R19
#else
#define LDW_R1_DLT	LDW_R1_DP
#endif
d350 10
a359 3
hppa_build_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg;
d361 3
a363 15
  struct elf32_hppa_stub_hash_entry *stub_entry;
  struct bfd_link_info *info;
  struct elf32_hppa_link_hash_table *hplink;
  asection *stub_sec;
  bfd *stub_bfd;
  bfd_byte *loc;
  bfd_vma sym_value;
  bfd_vma insn;
  bfd_vma off;
  int val;
  int size;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_hppa_stub_hash_entry *) gen_entry;
  info = (struct bfd_link_info *) in_arg;
d365 1
a365 2
  hplink = hppa_link_hash_table (info);
  stub_sec = stub_entry->stub_sec;
d367 3
a369 7
  /* Make a note of the offset within the stubs for this entry.  */
  stub_entry->stub_offset = stub_sec->_raw_size;
  loc = stub_sec->contents + stub_entry->stub_offset;

  stub_bfd = stub_sec->owner;

  switch (stub_entry->stub_type)
d371 9
a379 12
    case hppa_stub_long_branch:
      /* Create the long branch.  A long branch is formed with "ldil"
	 loading the upper bits of the target address into a register,
	 then branching with "be" which adds in the lower bits.
	 The "be" has its delay slot nullified.  */
      sym_value = (stub_entry->target_value
		   + stub_entry->target_section->output_offset
		   + stub_entry->target_section->output_section->vma);

      val = hppa_field_adjust (sym_value, (bfd_signed_vma) 0, e_lrsel);
      insn = hppa_rebuild_insn ((int) LDIL_R1, val, 21);
      bfd_put_32 (stub_bfd, insn, loc);
d381 2
a382 6
      val = hppa_field_adjust (sym_value, (bfd_signed_vma) 0, e_rrsel) >> 2;
      insn = hppa_rebuild_insn ((int) BE_SR4_R1, val, 17);
      bfd_put_32 (stub_bfd, insn, loc + 4);

#if ! LONG_BRANCH_PIC_IN_SHLIB
      if (info->shared)
d384 4
a387 7
	  /* Output a dynamic relocation for this stub.  We only
	     output one PCREL21L reloc per stub, trusting that the
	     dynamic linker will also fix the implied PCREL17R for the
	     second instruction.  PCREL21L dynamic relocs had better
	     never be emitted for some other purpose...  */
	  asection *srel;
	  Elf_Internal_Rela outrel;
d389 1
a389 11
	  if (stub_entry->h == NULL)
	    {
	      (*_bfd_error_handler)
		(_("%s(%s+0x%lx): cannot relocate %s, recompile with -ffunction-sections"),
		 bfd_get_filename (stub_entry->target_section->owner),
		 stub_sec->name,
		 (long) stub_entry->stub_offset,
		 stub_entry->root.string);
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }
d391 7
a397 2
	  srel = stub_entry->reloc_sec;
	  if (srel == NULL)
d399 6
a404 5
	      (*_bfd_error_handler)
		(_("Could not find relocation section for %s"),
		 stub_sec->name);
	      bfd_set_error (bfd_error_bad_value);
	      return false;
d407 1
a407 10
	  outrel.r_offset = (stub_entry->stub_offset
			     + stub_sec->output_offset
			     + stub_sec->output_section->vma);
	  outrel.r_info = ELF32_R_INFO (0, R_PARISC_PCREL21L);
	  outrel.r_addend = sym_value;
	  bfd_elf32_swap_reloca_out (stub_sec->output_section->owner,
				     &outrel,
				     ((Elf32_External_Rela *)
				      srel->contents + srel->reloc_count));
	  ++srel->reloc_count;
a408 3
#endif
      size = 8;
      break;
d410 5
a414 53
    case hppa_stub_long_branch_shared:
      /* Branches are relative.  This is where we are going to.  */
      sym_value = (stub_entry->target_value
		   + stub_entry->target_section->output_offset
		   + stub_entry->target_section->output_section->vma);

      /* And this is where we are coming from, more or less.  */
      sym_value -= (stub_entry->stub_offset
		    + stub_sec->output_offset
		    + stub_sec->output_section->vma);

      bfd_put_32 (stub_bfd, (bfd_vma) BL_R1, loc);
      val = hppa_field_adjust (sym_value, (bfd_signed_vma) -8, e_lrsel);
      insn = hppa_rebuild_insn ((int) ADDIL_R1, val, 21);
      bfd_put_32 (stub_bfd, insn, loc + 4);

      val = hppa_field_adjust (sym_value, (bfd_signed_vma) -8, e_rrsel) >> 2;
      insn = hppa_rebuild_insn ((int) BE_SR4_R1, val, 17);
      bfd_put_32 (stub_bfd, insn, loc + 8);
      size = 12;
      break;

    case hppa_stub_import:
    case hppa_stub_import_shared:
      off = stub_entry->h->elf.plt.offset;
      if (off >= (bfd_vma) -2)
	abort ();

      off &= ~ (bfd_vma) 1;
      sym_value = (off
		   + hplink->splt->output_offset
		   + hplink->splt->output_section->vma
		   - elf_gp (hplink->splt->output_section->owner));

      insn = ADDIL_DP;
#if R19_STUBS
      if (stub_entry->stub_type == hppa_stub_import_shared)
	insn = ADDIL_R19;
#endif
      val = hppa_field_adjust (sym_value, (bfd_signed_vma) 0, e_lrsel),
      insn = hppa_rebuild_insn ((int) insn, val, 21);
      bfd_put_32 (stub_bfd, insn, loc);

      /* It is critical to use lrsel/rrsel here because we are using
	 two different offsets (+0 and +4) from sym_value.  If we use
	 lsel/rsel then with unfortunate sym_values we will round
	 sym_value+4 up to the next 2k block leading to a mis-match
	 between the lsel and rsel value.  */
      val = hppa_field_adjust (sym_value, (bfd_signed_vma) 0, e_rrsel);
      insn = hppa_rebuild_insn ((int) LDW_R1_R21, val, 14);
      bfd_put_32 (stub_bfd, insn, loc + 4);

      if (hplink->multi_subspace)
d416 6
a421 10
	  val = hppa_field_adjust (sym_value, (bfd_signed_vma) 4, e_rrsel);
	  insn = hppa_rebuild_insn ((int) LDW_R1_DLT, val, 14);
	  bfd_put_32 (stub_bfd, insn, loc + 8);

	  bfd_put_32 (stub_bfd, (bfd_vma) LDSID_R21_R1, loc + 12);
	  bfd_put_32 (stub_bfd, (bfd_vma) MTSP_R1,      loc + 16);
	  bfd_put_32 (stub_bfd, (bfd_vma) BE_SR0_R21,   loc + 20);
	  bfd_put_32 (stub_bfd, (bfd_vma) STW_RP,       loc + 24);

	  size = 28;
d425 1
a425 4
	  bfd_put_32 (stub_bfd, (bfd_vma) BV_R0_R21, loc + 8);
	  val = hppa_field_adjust (sym_value, (bfd_signed_vma) 4, e_rrsel);
	  insn = hppa_rebuild_insn ((int) LDW_R1_DLT, val, 14);
	  bfd_put_32 (stub_bfd, insn, loc + 12);
d427 23
a449 1
	  size = 16;
d452 3
a454 3
      if (!info->shared
	  && stub_entry->h != NULL
	  && stub_entry->h->pic_call)
d456 7
a462 28
	  /* Build the .plt entry needed to call a PIC function from
	     statically linked code.  We don't need any relocs.  */
	  bfd *dynobj;
	  struct elf32_hppa_link_hash_entry *eh;
	  bfd_vma value;

	  dynobj = hplink->root.dynobj;
	  eh = (struct elf32_hppa_link_hash_entry *) stub_entry->h;

	  if (eh->elf.root.type != bfd_link_hash_defined
	      && eh->elf.root.type != bfd_link_hash_defweak)
	    abort ();

	  value = (eh->elf.root.u.def.value
		   + eh->elf.root.u.def.section->output_offset
		   + eh->elf.root.u.def.section->output_section->vma);

	  /* Fill in the entry in the procedure linkage table.

	     The format of a plt entry is
	     <funcaddr>
	     <__gp>.  */

	  bfd_put_32 (hplink->splt->owner, value,
		      hplink->splt->contents + off);
	  value = elf_gp (hplink->splt->output_section->owner);
	  bfd_put_32 (hplink->splt->owner, value,
		      hplink->splt->contents + off + 4);
a463 1
      break;
d465 54
a518 21
    case hppa_stub_export:
      /* Branches are relative.  This is where we are going to.  */
      sym_value = (stub_entry->target_value
		   + stub_entry->target_section->output_offset
		   + stub_entry->target_section->output_section->vma);

      /* And this is where we are coming from.  */
      sym_value -= (stub_entry->stub_offset
		    + stub_sec->output_offset
		    + stub_sec->output_section->vma);

      if (sym_value - 8 + 0x40000 >= 0x80000)
	{
	  (*_bfd_error_handler)
	    (_("%s(%s+0x%lx): cannot reach %s, recompile with -ffunction-sections"),
	     bfd_get_filename (stub_entry->target_section->owner),
	     stub_sec->name,
	     (long) stub_entry->stub_offset,
	     stub_entry->root.string);
	  bfd_set_error (bfd_error_bad_value);
	  return false;
a519 21

      val = hppa_field_adjust (sym_value, (bfd_signed_vma) -8, e_fsel) >> 2;
      insn = hppa_rebuild_insn ((int) BL_RP, val, 17);
      bfd_put_32 (stub_bfd, insn, loc);

      bfd_put_32 (stub_bfd, (bfd_vma) NOP,         loc + 4);
      bfd_put_32 (stub_bfd, (bfd_vma) LDW_RP,      loc + 8);
      bfd_put_32 (stub_bfd, (bfd_vma) LDSID_RP_R1, loc + 12);
      bfd_put_32 (stub_bfd, (bfd_vma) MTSP_R1,     loc + 16);
      bfd_put_32 (stub_bfd, (bfd_vma) BE_SR0_RP,   loc + 20);

      /* Point the function symbol at the stub.  */
      stub_entry->h->elf.root.u.def.section = stub_sec;
      stub_entry->h->elf.root.u.def.value = stub_sec->_raw_size;

      size = 24;
      break;

    default:
      BFD_FAIL ();
      return false;
a521 1
  stub_sec->_raw_size += size;
d525 26
a550 21
#undef LDIL_R1
#undef BE_SR4_R1
#undef BL_R1
#undef ADDIL_R1
#undef DEPI_R1
#undef ADDIL_DP
#undef LDW_R1_R21
#undef LDW_R1_DLT
#undef LDW_R1_R19
#undef ADDIL_R19
#undef LDW_R1_DP
#undef LDSID_R21_R1
#undef MTSP_R1
#undef BE_SR0_R21
#undef STW_RP
#undef BV_R0_R21
#undef BL_RP
#undef NOP
#undef LDW_RP
#undef LDSID_RP_R1
#undef BE_SR0_RP
d552 1
a552 2
/* As above, but don't actually build the stub.  Just bump offset so
   we know stub section sizes.  */
d554 19
a572 12
static boolean
hppa_size_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg;
{
  struct elf32_hppa_stub_hash_entry *stub_entry;
  struct elf32_hppa_link_hash_table *hplink;
  int size;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_hppa_stub_hash_entry *) gen_entry;
  hplink = (struct elf32_hppa_link_hash_table *) in_arg;
d574 5
a578 7
  if (stub_entry->stub_type == hppa_stub_long_branch)
    {
#if ! LONG_BRANCH_PIC_IN_SHLIB
      if (stub_entry->reloc_sec != NULL)
	stub_entry->reloc_sec->_raw_size += sizeof (Elf32_External_Rela);
#endif
      size = 8;
d580 2
a581 5
  else if (stub_entry->stub_type == hppa_stub_long_branch_shared)
    size = 12;
  else if (stub_entry->stub_type == hppa_stub_export)
    size = 24;
  else /* hppa_stub_import or hppa_stub_import_shared.  */
d583 32
a614 2
      if (hplink->multi_subspace)
	size = 28;
d616 77
a692 2
	size = 16;
    }
d694 2
a695 3
  stub_entry->stub_sec->_raw_size += size;
  return true;
}
d697 79
a775 2
/* Return nonzero if ABFD represents an HPPA ELF32 file.
   Additionally we set the default architecture and machine.  */
d777 5
a781 6
static boolean
elf32_hppa_object_p (abfd)
     bfd *abfd;
{
  Elf_Internal_Ehdr * i_ehdrp;
  unsigned int flags;
d783 3
a785 10
  i_ehdrp = elf_elfheader (abfd);
  if (strcmp (bfd_get_target (abfd), "elf32-hppa-linux") == 0)
    {
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_LINUX)
	return false;
    }
  else
    {
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_HPUX)
	return false;
d788 3
a790 13
  flags = i_ehdrp->e_flags;
  switch (flags & (EF_PARISC_ARCH | EF_PARISC_WIDE))
    {
    case EFA_PARISC_1_0:
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 10);
    case EFA_PARISC_1_1:
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 11);
    case EFA_PARISC_2_0:
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 20);
    case EFA_PARISC_2_0 | EF_PARISC_WIDE:
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 25);
    }
  return true;
d810 36
a845 2
/* Create the .plt and .got sections, and set up our hash table
   short-cuts to various dynamic sections.  */
d848 3
a850 3
elf32_hppa_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d852 8
a859 1
  struct elf32_hppa_link_hash_table *hplink;
d861 6
a866 4
  /* Don't try to create the .plt and .got twice.  */
  hplink = hppa_link_hash_table (info);
  if (hplink->splt != NULL)
    return true;
d868 2
a869 3
  /* Call the generic code to do most of the work.  */
  if (! _bfd_elf_create_dynamic_sections (abfd, info))
    return false;
d871 2
a872 2
  hplink->splt = bfd_get_section_by_name (abfd, ".plt");
  hplink->srelplt = bfd_get_section_by_name (abfd, ".rela.plt");
d874 29
a902 12
  hplink->sgot = bfd_get_section_by_name (abfd, ".got");
  hplink->srelgot = bfd_make_section (abfd, ".rela.got");
  if (hplink->srelgot == NULL
      || ! bfd_set_section_flags (abfd, hplink->srelgot,
				  (SEC_ALLOC
				   | SEC_LOAD
				   | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY
				   | SEC_LINKER_CREATED
				   | SEC_READONLY))
      || ! bfd_set_section_alignment (abfd, hplink->srelgot, 2))
    return false;
d904 17
a920 2
  hplink->sdynbss = bfd_get_section_by_name (abfd, ".dynbss");
  hplink->srelbss = bfd_get_section_by_name (abfd, ".rela.bss");
d922 1
d926 5
a930 4
/* Look through the relocs for a section during the first phase, and
   allocate space in the global offset table or procedure linkage
   table.  At this point we haven't necessarily read all the input
   files.  */
d932 3
a934 3
static boolean
elf32_hppa_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
a935 2
     asection *sec;
     const Elf_Internal_Rela *relocs;
d937 21
a957 20
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  struct elf32_hppa_link_hash_table *hplink;
  asection *sreloc;
  asection *stubreloc;

  if (info->relocateable)
    return true;

  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);
  sreloc = NULL;
  stubreloc = NULL;
d959 2
a960 18
  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      enum {
	NEED_GOT = 1,
	NEED_PLT = 2,
	NEED_DYNREL = 4,
#if LONG_BRANCH_PIC_IN_SHLIB
	NEED_STUBREL = 0,  /* We won't be needing them in this case.  */
#else
	NEED_STUBREL = 8,
#endif
	PLT_PLABEL = 16
      };

      unsigned int r_symndx, r_type;
      struct elf32_hppa_link_hash_entry *h;
      int need_entry;
d962 1
a962 1
      r_symndx = ELF32_R_SYM (rel->r_info);
d964 4
a967 5
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	h = ((struct elf32_hppa_link_hash_entry *)
	     sym_hashes[r_symndx - symtab_hdr->sh_info]);
d969 12
a980 1
      r_type = ELF32_R_TYPE (rel->r_info);
d982 9
a990 69
      switch (r_type)
	{
	case R_PARISC_DLTIND14F:
	case R_PARISC_DLTIND14R:
	case R_PARISC_DLTIND21L:
	  /* This symbol requires a global offset table entry.  */
	  need_entry = NEED_GOT;

	  /* Mark this section as containing PIC code.  */
	  sec->flags |= SEC_HAS_GOT_REF;
	  break;

	case R_PARISC_PLABEL14R: /* "Official" procedure labels.  */
	case R_PARISC_PLABEL21L:
	case R_PARISC_PLABEL32:
	  /* If the addend is non-zero, we break badly.  */
	  if (rel->r_addend != 0)
	    abort ();

	  /* If we are creating a shared library, then we need to
	     create a PLT entry for all PLABELs, because PLABELs with
	     local symbols may be passed via a pointer to another
	     object.  Additionally, output a dynamic relocation
	     pointing to the PLT entry.
	     For executables, the original 32-bit ABI allowed two
	     different styles of PLABELs (function pointers):  For
	     global functions, the PLABEL word points into the .plt
	     two bytes past a (function address, gp) pair, and for
	     local functions the PLABEL points directly at the
	     function.  The magic +2 for the first type allows us to
	     differentiate between the two.  As you can imagine, this
	     is a real pain when it comes to generating code to call
	     functions indirectly or to compare function pointers.
	     We avoid the mess by always pointing a PLABEL into the
	     .plt, even for local functions.  */
	  need_entry = PLT_PLABEL | NEED_PLT | NEED_DYNREL;
	  break;

	case R_PARISC_PCREL12F:
	  hplink->has_12bit_branch = 1;
	  /* Fall thru.  */
	case R_PARISC_PCREL17C:
	case R_PARISC_PCREL17F:
	  hplink->has_17bit_branch = 1;
	  /* Fall thru.  */
	case R_PARISC_PCREL22F:
	  /* Function calls might need to go through the .plt, and
	     might require long branch stubs.  */
	  if (h == NULL)
	    {
	      /* We know local syms won't need a .plt entry, and if
		 they need a long branch stub we can't guarantee that
		 we can reach the stub.  So just flag an error later
		 if we're doing a shared link and find we need a long
		 branch stub.  */
	      continue;
	    }
	  else
	    {
	      /* Global symbols will need a .plt entry if they remain
		 global, and in most cases won't need a long branch
		 stub.  Unfortunately, we have to cater for the case
		 where a symbol is forced local by versioning, or due
		 to symbolic linking, and we lose the .plt entry.  */
	      need_entry = NEED_PLT | NEED_STUBREL;
	      if (h->elf.type == STT_PARISC_MILLI)
		need_entry = NEED_STUBREL;
	    }
	  break;
d992 2
a993 9
	case R_PARISC_SEGBASE: /* Used to set segment base.  */
	case R_PARISC_SEGREL32: /* Relative reloc, used for unwind.  */
	case R_PARISC_PCREL14F: /* PC relative load/store.  */
	case R_PARISC_PCREL14R:
	case R_PARISC_PCREL17R: /* External branches.  */
	case R_PARISC_PCREL21L: /* As above, and for load/store too.  */
	  /* We don't need to propagate the relocation if linking a
	     shared object since these are section relative.  */
	  continue;
d995 5
a999 13
	case R_PARISC_DPREL14F: /* Used for gp rel data load/store.  */
	case R_PARISC_DPREL14R:
	case R_PARISC_DPREL21L:
	  if (info->shared)
	    {
	      (*_bfd_error_handler)
		(_("%s: relocation %s can not be used when making a shared object; recompile with -fPIC"),
		 bfd_get_filename (abfd),
		 elf_hppa_howto_table[r_type].name);
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }
	  /* Fall through.  */
d1001 2
a1002 18
	case R_PARISC_DIR17F: /* Used for external branches.  */
	case R_PARISC_DIR17R:
	case R_PARISC_DIR14F: /* Used for load/store from absolute locn.  */
	case R_PARISC_DIR14R:
	case R_PARISC_DIR21L: /* As above, and for ext branches too.  */
#if 1
	  /* Help debug shared library creation.  Any of the above
	     relocs can be used in shared libs, but they may cause
	     pages to become unshared.  */
	  if (info->shared)
	    {
	      (*_bfd_error_handler)
		(_("%s: relocation %s should not be used when making a shared object; recompile with -fPIC"),
		 bfd_get_filename (abfd),
		 elf_hppa_howto_table[r_type].name);
	    }
	  /* Fall through.  */
#endif
d1004 10
a1013 12
	case R_PARISC_DIR32: /* .word relocs.  */
	  /* We may want to output a dynamic relocation later.  */
	  need_entry = NEED_DYNREL;
	  break;

	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
	case R_PARISC_GNU_VTINHERIT:
	  if (!_bfd_elf32_gc_record_vtinherit (abfd, sec,
					       &h->elf, rel->r_offset))
	    return false;
	  continue;
d1015 10
a1024 7
	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
	case R_PARISC_GNU_VTENTRY:
	  if (!_bfd_elf32_gc_record_vtentry (abfd, sec,
					     &h->elf, rel->r_addend))
	    return false;
	  continue;
d1026 1
a1026 3
	default:
	  continue;
	}
d1028 4
a1031 2
      /* Now carry out our orders.  */
      if (need_entry & NEED_GOT)
d1033 8
a1040 4
	  /* Allocate space for a GOT entry, as well as a dynamic
	     relocation for this entry.  */
	  if (dynobj == NULL)
	    hplink->root.dynobj = dynobj = abfd;
d1042 19
a1060 1
	  if (hplink->sgot == NULL)
d1062 6
a1067 2
	      if (! elf32_hppa_create_dynamic_sections (dynobj, info))
		return false;
d1070 5
a1074 1
	  if (h != NULL)
d1076 39
a1114 1
	      if (h->elf.got.refcount == -1)
d1116 16
a1131 1
		  h->elf.got.refcount = 1;
d1133 26
a1158 2
		  /* Make sure this symbol is output as a dynamic symbol.  */
		  if (h->elf.dynindx == -1)
d1160 6
a1165 3
		      if (! bfd_elf32_link_record_dynamic_symbol (info,
								  &h->elf))
			return false;
d1167 2
a1170 6
		h->elf.got.refcount += 1;
	    }
	  else
	    {
	      /* This is a global offset table entry for a local symbol.  */
	      if (local_got_refcounts == NULL)
d1172 2
a1173 20
		  size_t size;

		  /* Allocate space for local got offsets and local
		     plt offsets.  Done this way to save polluting
		     elf_obj_tdata with another target specific
		     pointer.  */
		  size = symtab_hdr->sh_info * 2 * sizeof (bfd_signed_vma);
		  local_got_refcounts = ((bfd_signed_vma *)
					 bfd_alloc (abfd, size));
		  if (local_got_refcounts == NULL)
		    return false;
		  elf_local_got_refcounts (abfd) = local_got_refcounts;
		  memset (local_got_refcounts, -1, size);
		}
	      if (local_got_refcounts[r_symndx] == -1)
		local_got_refcounts[r_symndx] = 1;
	      else
		local_got_refcounts[r_symndx] += 1;
	    }
	}
d1175 4
a1178 15
      if (need_entry & NEED_PLT)
	{
	  /* If we are creating a shared library, and this is a reloc
	     against a weak symbol or a global symbol in a dynamic
	     object, then we will be creating an import stub and a
	     .plt entry for the symbol.  Similarly, on a normal link
	     to symbols defined in a dynamic object we'll need the
	     import stub and a .plt entry.  We don't know yet whether
	     the symbol is defined or not, so make an entry anyway and
	     clean up later in adjust_dynamic_symbol.  */
	  if ((sec->flags & SEC_ALLOC) != 0)
	    {
	      if (h != NULL)
		{
		  if (h->elf.plt.refcount == -1)
d1180 6
a1185 2
		      h->elf.plt.refcount = 1;
		      h->elf.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
a1187 13
		    h->elf.plt.refcount += 1;

		  /* If this .plt entry is for a plabel, mark it so
		     that adjust_dynamic_symbol will keep the entry
		     even if it appears to be local.  */
		  if (need_entry & PLT_PLABEL)
		    h->plabel = 1;
		}
	      else if (need_entry & PLT_PLABEL)
		{
		  int indx;

		  if (local_got_refcounts == NULL)
d1189 7
a1195 11
		      size_t size;

		      /* Allocate space for local got offsets and local
			 plt offsets.  */
		      size = symtab_hdr->sh_info * 2 * sizeof (bfd_signed_vma);
		      local_got_refcounts = ((bfd_signed_vma *)
					     bfd_alloc (abfd, size));
		      if (local_got_refcounts == NULL)
			return false;
		      elf_local_got_refcounts (abfd) = local_got_refcounts;
		      memset (local_got_refcounts, -1, size);
a1196 5
		  indx = r_symndx + symtab_hdr->sh_info;
		  if (local_got_refcounts[indx] == -1)
		    local_got_refcounts[indx] = 1;
		  else
		    local_got_refcounts[indx] += 1;
a1197 47
	    }
	}

      if (need_entry & (NEED_DYNREL | NEED_STUBREL))
	{
	  /* Flag this symbol as having a non-got, non-plt reference
	     so that we generate copy relocs if it turns out to be
	     dynamic.  */
	  if (h != NULL)
	    h->elf.elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;

	  /* If we are creating a shared library then we need to copy
	     the reloc into the shared library.  However, if we are
	     linking with -Bsymbolic, we need only copy absolute
	     relocs or relocs against symbols that are not defined in
	     an object we are including in the link.  PC- or DP- or
	     DLT-relative relocs against any local sym or global sym
	     with DEF_REGULAR set, can be discarded.  At this point we
	     have not seen all the input files, so it is possible that
	     DEF_REGULAR is not set now but will be set later (it is
	     never cleared).  We account for that possibility below by
	     storing information in the reloc_entries field of the
	     hash table entry.

	     A similar situation to the -Bsymbolic case occurs when
	     creating shared libraries and symbol visibility changes
	     render the symbol local.

	     As it turns out, all the relocs we will be creating here
	     are absolute, so we cannot remove them on -Bsymbolic
	     links or visibility changes anyway.  A STUB_REL reloc
	     is absolute too, as in that case it is the reloc in the
	     stub we will be creating, rather than copying the PCREL
	     reloc in the branch.  */
	  if ((sec->flags & SEC_ALLOC) != 0
	      && info->shared
#if RELATIVE_DYNAMIC_RELOCS
	      && (!info->symbolic
		  || is_absolute_reloc (r_type)
		  || (h != NULL
		      && ((h->elf.elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR) == 0)))
#endif
	      )
	    {
	      boolean doit;
	      asection *srel;
d1199 16
a1214 7
	      srel = sreloc;
	      if ((need_entry & NEED_STUBREL))
		srel = stubreloc;

	      /* Create a reloc section in dynobj and make room for
		 this reloc.  */
	      if (srel == NULL)
d1216 2
a1217 1
		  char *name;
d1219 3
a1221 2
		  if (dynobj == NULL)
		    hplink->root.dynobj = dynobj = abfd;
d1223 2
a1224 5
		  name = bfd_elf_string_from_elf_section
		    (abfd,
		     elf_elfheader (abfd)->e_shstrndx,
		     elf_section_data (sec)->rel_hdr.sh_name);
		  if (name == NULL)
d1226 11
a1236 5
		      (*_bfd_error_handler)
			(_("Could not find relocation section for %s"),
			 sec->name);
		      bfd_set_error (bfd_error_bad_value);
		      return false;
d1238 2
d1241 8
a1248 1
		  if ((need_entry & NEED_STUBREL))
d1250 3
a1252 25
		      size_t len = strlen (name) + sizeof (STUB_SUFFIX);
		      char *newname = bfd_malloc (len);

		      if (newname == NULL)
			return false;
		      strcpy (newname, name);
		      strcpy (newname + len - sizeof (STUB_SUFFIX),
			      STUB_SUFFIX);
		      name = newname;
		    }

		  srel = bfd_get_section_by_name (dynobj, name);
		  if (srel == NULL)
		    {
		      flagword flags;

		      srel = bfd_make_section (dynobj, name);
		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		      if ((sec->flags & SEC_ALLOC) != 0)
			flags |= SEC_ALLOC | SEC_LOAD;
		      if (srel == NULL
			  || !bfd_set_section_flags (dynobj, srel, flags)
			  || !bfd_set_section_alignment (dynobj, srel, 2))
			return false;
a1253 5
		  else if ((need_entry & NEED_STUBREL))
		    free (name);

		  if ((need_entry & NEED_STUBREL))
		    stubreloc = srel;
a1254 33
		    sreloc = srel;
		}

#if ! LONG_BRANCH_PIC_IN_SHLIB
	      /* If this is a function call, we only need one dynamic
		 reloc for the stub as all calls to a particular
		 function will go through the same stub.  Actually, a
		 long branch stub needs two relocations, but we count
		 on some intelligence on the part of the dynamic
		 linker.  */
	      if ((need_entry & NEED_STUBREL))
		{
		  doit = h->stub_reloc_sec != stubreloc;
		  h->stub_reloc_sec = stubreloc;
		}
	      else
#endif
		doit = 1;

	      if (doit)
		{
		  srel->_raw_size += sizeof (Elf32_External_Rela);

#if ! LONG_BRANCH_PIC_IN_SHLIB || RELATIVE_DYNAMIC_RELOCS
		  /* Keep track of relocations we have entered for
		     this global symbol, so that we can discard them
		     later if necessary.  */
		  if (h != NULL
		      && (0
#if RELATIVE_DYNAMIC_RELOCS
			  || ! is_absolute_reloc (rtype)
#endif
			  || (need_entry & NEED_STUBREL)))
d1256 10
a1265 7
		      struct elf32_hppa_dyn_reloc_entry *p;

		      for (p = h->reloc_entries; p != NULL; p = p->next)
			if (p->section == srel)
			  break;

		      if (p == NULL)
d1267 7
a1273 8
			  p = ((struct elf32_hppa_dyn_reloc_entry *)
			       bfd_alloc (dynobj, sizeof *p));
			  if (p == NULL)
			    return false;
			  p->next = h->reloc_entries;
			  h->reloc_entries = p;
			  p->section = srel;
			  p->count = 0;
d1276 4
a1279 7
		      /* NEED_STUBREL and NEED_DYNREL are never both
			 set.  Leave the count at zero for the
			 NEED_STUBREL case as we only ever have one
			 stub reloc per section per symbol, and this
			 simplifies code in hppa_discard_copies.  */
		      if (! (need_entry & NEED_STUBREL))
			++p->count;
d1281 1
a1281 1
#endif
d1284 2
d1288 6
d1295 12
a1306 1
  return true;
d1309 5
a1313 2
/* Return the section that should be marked against garbage collection
   for a given relocation.  */
d1315 6
a1320 22
static asection *
elf32_hppa_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
{
  if (h != NULL)
    {
      switch ((unsigned int) ELF32_R_TYPE (rel->r_info))
	{
	case R_PARISC_GNU_VTINHERIT:
	case R_PARISC_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;
a1321 2
	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;
d1323 5
a1327 2690
	    default:
	      break;
	    }
	}
    }
  else
    {
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		&& sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
    }

  return NULL;
}

/* Update the got and plt entry reference counts for the section being
   removed.  */

static boolean
elf32_hppa_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec;
     const Elf_Internal_Rela *relocs;
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  bfd_signed_vma *local_plt_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;
  struct elf32_hppa_link_hash_table *hplink;
  bfd *dynobj;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);
  local_plt_refcounts = local_got_refcounts;
  if (local_plt_refcounts != NULL)
    local_plt_refcounts += symtab_hdr->sh_info;
  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;
  if (dynobj == NULL)
    return true;

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    switch ((unsigned int) ELF32_R_TYPE (rel->r_info))
      {
      case R_PARISC_DLTIND14F:
      case R_PARISC_DLTIND14R:
      case R_PARISC_DLTIND21L:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount -= 1;
	  }
	else if (local_got_refcounts != NULL)
	  {
	    if (local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx] -= 1;
	  }
	break;

      case R_PARISC_PCREL12F:
      case R_PARISC_PCREL17C:
      case R_PARISC_PCREL17F:
      case R_PARISC_PCREL22F:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;
	  }
	break;

      case R_PARISC_PLABEL14R:
      case R_PARISC_PLABEL21L:
      case R_PARISC_PLABEL32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;
	  }
	else if (local_plt_refcounts != NULL)
	  {
	    if (local_plt_refcounts[r_symndx] > 0)
	      local_plt_refcounts[r_symndx] -= 1;
	  }
	break;

      default:
	break;
      }

  return true;
}

/* Our own version of hide_symbol, so that we can keep plt entries for
   plabels.  */

static void
elf32_hppa_hide_symbol (info, h)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     struct elf_link_hash_entry *h;
{
  if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
    h->dynindx = -1;
  if (! ((struct elf32_hppa_link_hash_entry *) h)->plabel)
    {
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
      h->plt.offset = (bfd_vma) -1;
    }
}

/* This is the condition under which elf32_hppa_finish_dynamic_symbol
   will be called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in elf32_hppa_relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, INFO, H) \
  ((DYN)								\
   && ((INFO)->shared							\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static boolean
elf32_hppa_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
{
  bfd *dynobj;
  struct elf32_hppa_link_hash_table *hplink;
  asection *s;

  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;

  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later,
     when we know the address of the .got section.  */
  if (h->type == STT_FUNC
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
    {
      if (!info->shared
	  && h->plt.refcount > 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && (h->root.u.def.section->flags & SEC_HAS_GOT_REF) != 0)
	{
	  ((struct elf32_hppa_link_hash_entry *) h)->maybe_pic_call = 1;
	}

      if (h->plt.refcount <= 0
	  || ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	      && h->root.type != bfd_link_hash_defweak
	      && ! ((struct elf32_hppa_link_hash_entry *) h)->plabel
	      && (!info->shared || info->symbolic)))
	{
	  /* The .plt entry is not needed when:
	     a) Garbage collection has removed all references to the
	     symbol, or
	     b) We know for certain the symbol is defined in this
	     object, and it's not a weak definition, nor is the symbol
	     used by a plabel relocation.  Either this object is the
	     application or we are doing a shared symbolic link.  */

	  /* As a special sop to the hppa ABI, we keep a .plt entry
	     for functions in sections containing PIC code.  */
	  if (((struct elf32_hppa_link_hash_entry *) h)->maybe_pic_call)
	    ((struct elf32_hppa_link_hash_entry *) h)->pic_call = 1;
	  else
	    {
	      h->plt.offset = (bfd_vma) -1;
	      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	      return true;
	    }
	}

      if (! ((struct elf32_hppa_link_hash_entry *) h)->pic_call)
	{
	  /* Make sure this symbol is output as a dynamic symbol.  */
	  if (h->dynindx == -1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	    {
	      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
		return false;
	    }
	}

      return true;
    }

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->weakdef != NULL)
    {
      if (h->weakdef->root.type != bfd_link_hash_defined
	  && h->weakdef->root.type != bfd_link_hash_defweak)
	abort ();
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
      return true;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return true;

  /* If there are no references to this symbol that do not use the
     GOT, we don't need to generate a copy reloc.  */
  if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0)
    return true;

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */

  s = hplink->sdynbss;

  /* We must generate a COPY reloc to tell the dynamic linker to
     copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rela.bss section we are going to use.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
    {
      asection *srel;

      srel = hplink->srelbss;
      srel->_raw_size += sizeof (Elf32_External_Rela);
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
    }

  {
    /* We need to figure out the alignment required for this symbol.  I
       have no idea how other ELF linkers handle this.  */
    unsigned int power_of_two;

    power_of_two = bfd_log2 (h->size);
    if (power_of_two > 3)
      power_of_two = 3;

    /* Apply the required alignment.  */
    s->_raw_size = BFD_ALIGN (s->_raw_size,
			      (bfd_size_type) (1 << power_of_two));
    if (power_of_two > bfd_get_section_alignment (dynobj, s))
      {
	if (! bfd_set_section_alignment (dynobj, s, power_of_two))
	  return false;
      }
  }
  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->_raw_size;

  /* Increment the section size to make room for the symbol.  */
  s->_raw_size += h->size;

  return true;
}

/* Called via elf_link_hash_traverse to create .plt entries for an
   application that uses statically linked PIC functions.  Similar to
   the first part of elf32_hppa_adjust_dynamic_symbol.  */

static boolean
hppa_handle_PIC_calls (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf ATTRIBUTE_UNUSED;
{
  if (! (h->plt.refcount > 0
	 && (h->root.type == bfd_link_hash_defined
	     || h->root.type == bfd_link_hash_defweak)
	 && (h->root.u.def.section->flags & SEC_HAS_GOT_REF) != 0))
    {
      h->plt.offset = (bfd_vma) -1;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
      return true;
    }

  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
  ((struct elf32_hppa_link_hash_entry *) h)->maybe_pic_call = 1;
  ((struct elf32_hppa_link_hash_entry *) h)->pic_call = 1;

  return true;
}

/* Allocate space in .plt, .got and associated reloc sections for
   global syms.  */

static boolean
allocate_plt_and_got (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct bfd_link_info *info;
  struct elf32_hppa_link_hash_table *hplink;
  asection *s;

  if (h->root.type == bfd_link_hash_indirect
      || h->root.type == bfd_link_hash_warning)
    return true;

  info = (struct bfd_link_info *) inf;
  hplink = hppa_link_hash_table (info);
  if ((hplink->root.dynamic_sections_created
       && h->plt.refcount > 0)
      || ((struct elf32_hppa_link_hash_entry *) h)->pic_call)
    {
      /* Make an entry in the .plt section.  */
      s = hplink->splt;
      h->plt.offset = s->_raw_size;
      if (PLABEL_PLT_ENTRY_SIZE != PLT_ENTRY_SIZE
	  && ((struct elf32_hppa_link_hash_entry *) h)->plabel
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  /* Add some extra space for the dynamic linker to use.  */
	  s->_raw_size += PLABEL_PLT_ENTRY_SIZE;
	}
      else
	s->_raw_size += PLT_ENTRY_SIZE;

      if (! ((struct elf32_hppa_link_hash_entry *) h)->pic_call
	  && WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
	{
	  /* We also need to make an entry in the .rela.plt section.  */
	  hplink->srelplt->_raw_size += sizeof (Elf32_External_Rela);
	  hplink->need_plt_stub = 1;
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
    }

  if (h->got.refcount > 0)
    {
      boolean dyn;

      s = hplink->sgot;
      h->got.offset = s->_raw_size;
      s->_raw_size += GOT_ENTRY_SIZE;
      dyn = hplink->root.dynamic_sections_created;
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
	hplink->srelgot->_raw_size += sizeof (Elf32_External_Rela);
    }
  else
    h->got.offset = (bfd_vma) -1;

  return true;
}

#if ((! LONG_BRANCH_PIC_IN_SHLIB && LONG_BRANCH_VIA_PLT) \
     || RELATIVE_DYNAMIC_RELOCS)
/* This function is called via elf_link_hash_traverse to discard space
   we allocated for relocs that it turned out we didn't need.  */

static boolean
hppa_discard_copies (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct elf32_hppa_dyn_reloc_entry *s;
  struct elf32_hppa_link_hash_entry *eh;
  struct bfd_link_info *info;

  eh = (struct elf32_hppa_link_hash_entry *) h;
  info = (struct bfd_link_info *) inf;

#if ! LONG_BRANCH_PIC_IN_SHLIB && LONG_BRANCH_VIA_PLT
  /* Handle the stub reloc case.  If we have a plt entry for the
     function, we won't be needing long branch stubs.  s->count will
     only be zero for stub relocs, which provides a handy way of
     flagging these relocs, and means we need do nothing special for
     the forced local and symbolic link case.  */
  if (eh->stub_reloc_sec != NULL
      && eh->elf.plt.offset != (bfd_vma) -1)
    {
      for (s = eh->reloc_entries; s != NULL; s = s->next)
	if (s->count == 0)
	  s->section->_raw_size -= sizeof (Elf32_External_Rela);
    }
#endif

#if RELATIVE_DYNAMIC_RELOCS
  /* If a symbol has been forced local or we have found a regular
     definition for the symbolic link case, then we won't be needing
     any relocs.  */
  if (eh->elf.dynindx == -1
      || ((eh->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && !is_absolute_reloc (r_type)
	  && info->symbolic))
    {
      for (s = eh->reloc_entries; s != NULL; s = s->next)
	s->section->_raw_size -= s->count * sizeof (Elf32_External_Rela);
    }
#endif

  return true;
}
#endif

/* This function is called via elf_link_hash_traverse to force
   millicode symbols local so they do not end up as globals in the
   dynamic symbol table.  We ought to be able to do this in
   adjust_dynamic_symbol, but our adjust_dynamic_symbol is not called
   for all dynamic symbols.  Arguably, this is a bug in
   elf_adjust_dynamic_symbol.  */

static boolean
clobber_millicode_symbols (h, info)
     struct elf_link_hash_entry *h;
     struct bfd_link_info *info;
{
  /* We only want to remove these from the dynamic symbol table.
     Therefore we do not leave ELF_LINK_FORCED_LOCAL set.  */
  if (h->type == STT_PARISC_MILLI)
    {
      unsigned short oldflags = h->elf_link_hash_flags;
      h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
      elf32_hppa_hide_symbol (info, h);
      h->elf_link_hash_flags &= ~ELF_LINK_FORCED_LOCAL;
      h->elf_link_hash_flags |= oldflags & ELF_LINK_FORCED_LOCAL;
    }
  return true;
}

/* Set the sizes of the dynamic sections.  */

static boolean
elf32_hppa_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  struct elf32_hppa_link_hash_table *hplink;
  bfd *dynobj;
  asection *s;
  boolean relocs;
  boolean reltext;

  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;
  if (dynobj == NULL)
    abort ();

  if (hplink->root.dynamic_sections_created)
    {
      bfd *i;

      /* Set the contents of the .interp section to the interpreter.  */
      if (! info->shared)
	{
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  if (s == NULL)
	    abort ();
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}

      /* Force millicode symbols local.  */
      elf_link_hash_traverse (&hplink->root,
			      clobber_millicode_symbols,
			      info);

      /* Set up .got and .plt offsets for local syms.  */
      for (i = info->input_bfds; i; i = i->link_next)
	{
	  bfd_signed_vma *local_got;
	  bfd_signed_vma *end_local_got;
	  bfd_signed_vma *local_plt;
	  bfd_signed_vma *end_local_plt;
	  bfd_size_type locsymcount;
	  Elf_Internal_Shdr *symtab_hdr;
	  asection *srel;

	  if (bfd_get_flavour (i) != bfd_target_elf_flavour)
	    continue;

	  local_got = elf_local_got_refcounts (i);
	  if (!local_got)
	    continue;

	  symtab_hdr = &elf_tdata (i)->symtab_hdr;
	  locsymcount = symtab_hdr->sh_info;
	  end_local_got = local_got + locsymcount;
	  s = hplink->sgot;
	  srel = hplink->srelgot;
	  for (; local_got < end_local_got; ++local_got)
	    {
	      if (*local_got > 0)
		{
		  *local_got = s->_raw_size;
		  s->_raw_size += GOT_ENTRY_SIZE;
		  if (info->shared)
		    srel->_raw_size += sizeof (Elf32_External_Rela);
		}
	      else
		*local_got = (bfd_vma) -1;
	    }

	  local_plt = end_local_got;
	  end_local_plt = local_plt + locsymcount;
	  s = hplink->splt;
	  srel = hplink->srelplt;
	  for (; local_plt < end_local_plt; ++local_plt)
	    {
	      if (*local_plt > 0)
		{
		  *local_plt = s->_raw_size;
		  s->_raw_size += PLT_ENTRY_SIZE;
		  if (info->shared)
		    srel->_raw_size += sizeof (Elf32_External_Rela);
		}
	      else
		*local_plt = (bfd_vma) -1;
	    }
	}
    }
  else
    {
      /* Run through the function symbols, looking for any that are
	 PIC, and allocate space for the necessary .plt entries so
	 that %r19 will be set up.  */
      if (! info->shared)
	elf_link_hash_traverse (&hplink->root,
				hppa_handle_PIC_calls,
				info);
    }

  /* Allocate global sym .plt and .got entries.  */
  elf_link_hash_traverse (&hplink->root,
			  allocate_plt_and_got,
			  info);

#if ((! LONG_BRANCH_PIC_IN_SHLIB && LONG_BRANCH_VIA_PLT) \
     || RELATIVE_DYNAMIC_RELOCS)
  /* If this is a -Bsymbolic shared link, then we need to discard all
     relocs against symbols defined in a regular object.  We also need
     to lose relocs we've allocated for long branch stubs if we know
     we won't be generating a stub.  */
  if (info->shared)
    elf_link_hash_traverse (&hplink->root,
			    hppa_discard_copies,
			    info);
#endif

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  relocs = false;
  reltext = false;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;

      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      if (strncmp (name, ".rela", 5) == 0)
	{
	  if (s->_raw_size != 0)
	    {
	      asection *target;
	      const char *outname;

	      /* Remember whether there are any reloc sections other
		 than .rela.plt.  */
	      if (strcmp (name+5, ".plt") != 0)
		relocs = true;

	      /* If this relocation section applies to a read only
		 section, then we probably need a DT_TEXTREL entry.  */
	      outname = bfd_get_section_name (output_bfd,
					      s->output_section);
	      target = bfd_get_section_by_name (output_bfd, outname + 5);
	      if (target != NULL
		  && (target->flags & SEC_READONLY) != 0
		  && (target->flags & SEC_ALLOC) != 0)
		reltext = true;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else if (strcmp (name, ".plt") == 0)
	{
	  if (hplink->need_plt_stub)
	    {
	      /* Make space for the plt stub at the end of the .plt
		 section.  We want this stub right at the end, up
		 against the .got section.  */
	      int gotalign = bfd_section_alignment (dynobj, hplink->sgot);
	      int pltalign = bfd_section_alignment (dynobj, s);
	      bfd_size_type mask;

	      if (gotalign > pltalign)
		bfd_set_section_alignment (dynobj, s, gotalign);
	      mask = ((bfd_size_type) 1 << gotalign) - 1;
	      s->_raw_size = (s->_raw_size + sizeof (plt_stub) + mask) & ~mask;
	    }
	}
      else if (strcmp (name, ".got") == 0)
	;
      else
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (s->_raw_size == 0)
	{
	  /* If we don't need this section, strip it from the
	     output file.  This is mostly to handle .rela.bss and
	     .rela.plt.  We must create both sections in
	     create_dynamic_sections, because they must be created
	     before the linker maps input sections to output
	     sections.  The linker does that before
	     adjust_dynamic_symbol is called, and it is that
	     function which decides whether anything needs to go
	     into these sections.  */
	  _bfd_strip_section_from_output (info, s);
	  continue;
	}

      /* Allocate memory for the section contents.  Zero it, because
	 we may not fill in all the reloc sections.  */
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
	return false;
    }

  if (hplink->root.dynamic_sections_created)
    {
      /* Like IA-64 and HPPA64, always create a DT_PLTGOT.  It
	 actually has nothing to do with the PLT, it is how we
	 communicate the LTP value of a load module to the dynamic
	 linker.  */
      if (! bfd_elf32_add_dynamic_entry (info, DT_PLTGOT, 0))
	return false;

      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf32_hppa_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
      if (! info->shared)
	{
	  if (! bfd_elf32_add_dynamic_entry (info, DT_DEBUG, 0))
	    return false;
	}

      if (hplink->srelplt->_raw_size != 0)
	{
	  if (! bfd_elf32_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_JMPREL, 0))
	    return false;
	}

      if (relocs)
	{
	  if (! bfd_elf32_add_dynamic_entry (info, DT_RELA, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_RELASZ, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_RELAENT,
						sizeof (Elf32_External_Rela)))
	    return false;
	}

      if (reltext)
	{
	  if (! bfd_elf32_add_dynamic_entry (info, DT_TEXTREL, 0))
	    return false;
	  info->flags |= DF_TEXTREL;
	}
    }

  return true;
}

/* External entry points for sizing and building linker stubs.  */

/* Determine and set the size of the stub section for a final link.

   The basic idea here is to examine all the relocations looking for
   PC-relative calls to a target that is unreachable with a "bl"
   instruction.  */

boolean
elf32_hppa_size_stubs (output_bfd, stub_bfd, info, multi_subspace, group_size,
		       add_stub_section, layout_sections_again)
     bfd *output_bfd;
     bfd *stub_bfd;
     struct bfd_link_info *info;
     boolean multi_subspace;
     bfd_signed_vma group_size;
     asection * (*add_stub_section) PARAMS ((const char *, asection *));
     void (*layout_sections_again) PARAMS ((void));
{
  bfd *input_bfd;
  asection *section;
  asection **input_list, **list;
  Elf_Internal_Sym *local_syms, **all_local_syms;
  unsigned int bfd_indx, bfd_count;
  int top_id, top_index;
  struct elf32_hppa_link_hash_table *hplink;
  bfd_size_type stub_group_size;
  boolean stubs_always_before_branch;
  boolean stub_changed = 0;
  boolean ret = 0;

  hplink = hppa_link_hash_table (info);

  /* Stash our params away.  */
  hplink->stub_bfd = stub_bfd;
  hplink->multi_subspace = multi_subspace;
  hplink->add_stub_section = add_stub_section;
  hplink->layout_sections_again = layout_sections_again;
  stubs_always_before_branch = group_size < 0;
  if (group_size < 0)
    stub_group_size = -group_size;
  else
    stub_group_size = group_size;
  if (stub_group_size == 1)
    {
      /* Default values.  */
      stub_group_size = 8000000;
      if (hplink->has_17bit_branch || hplink->multi_subspace)
	stub_group_size = 250000;
      if (hplink->has_12bit_branch)
	stub_group_size = 7812;
    }

  /* Count the number of input BFDs and find the top input section id.  */
  for (input_bfd = info->input_bfds, bfd_count = 0, top_id = 0;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next)
    {
      bfd_count += 1;
      for (section = input_bfd->sections;
	   section != NULL;
	   section = section->next)
	{
	  if (top_id < section->id)
	    top_id = section->id;
	}
    }

  hplink->stub_group
    = (struct map_stub *) bfd_zmalloc (sizeof (struct map_stub) * (top_id + 1));
  if (hplink->stub_group == NULL)
    return false;

  /* Make a list of input sections for each output section included in
     the link.

     We can't use output_bfd->section_count here to find the top output
     section index as some sections may have been removed, and
     _bfd_strip_section_from_output doesn't renumber the indices.  */
  for (section = output_bfd->sections, top_index = 0;
       section != NULL;
       section = section->next)
    {
      if (top_index < section->index)
	top_index = section->index;
    }

  input_list
    = (asection **) bfd_malloc (sizeof (asection *) * (top_index + 1));
  if (input_list == NULL)
    return false;

  /* For sections we aren't interested in, mark their entries with a
     value we can check later.  */
  list = input_list + top_index;
  do
    *list = bfd_abs_section_ptr;
  while (list-- != input_list);

  for (section = output_bfd->sections;
       section != NULL;
       section = section->next)
    {
      if ((section->flags & SEC_CODE) != 0)
	input_list[section->index] = NULL;
    }

  /* Now actually build the lists.  */
  for (input_bfd = info->input_bfds;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next)
    {
      for (section = input_bfd->sections;
	   section != NULL;
	   section = section->next)
	{
	  if (section->output_section != NULL
	      && section->output_section->owner == output_bfd
	      && section->output_section->index <= top_index)
	    {
	      list = input_list + section->output_section->index;
	      if (*list != bfd_abs_section_ptr)
		{
		  /* Steal the link_sec pointer for our list.  */
#define PREV_SEC(sec) (hplink->stub_group[(sec)->id].link_sec)
		  /* This happens to make the list in reverse order,
		     which is what we want.  */
		  PREV_SEC (section) = *list;
		  *list = section;
		}
	    }
	}
    }

  /* See whether we can group stub sections together.  Grouping stub
     sections may result in fewer stubs.  More importantly, we need to
     put all .init* and .fini* stubs at the beginning of the .init or
     .fini output sections respectively, because glibc splits the
     _init and _fini functions into multiple parts.  Putting a stub in
     the middle of a function is not a good idea.  */
  list = input_list + top_index;
  do
    {
      asection *tail = *list;
      if (tail == bfd_abs_section_ptr)
	continue;
      while (tail != NULL)
	{
	  asection *curr;
	  asection *prev;
	  bfd_size_type total;

	  curr = tail;
	  if (tail->_cooked_size)
	    total = tail->_cooked_size;
	  else
	    total = tail->_raw_size;
	  while ((prev = PREV_SEC (curr)) != NULL
		 && ((total += curr->output_offset - prev->output_offset)
		     < stub_group_size))
	    curr = prev;

	  /* OK, the size from the start of CURR to the end is less
	     than 250000 bytes and thus can be handled by one stub
	     section.  (or the tail section is itself larger than
	     250000 bytes, in which case we may be toast.)
	     We should really be keeping track of the total size of
	     stubs added here, as stubs contribute to the final output
	     section size.  That's a little tricky, and this way will
	     only break if stubs added total more than 12144 bytes, or
	     1518 long branch stubs.  It seems unlikely for more than
	     1518 different functions to be called, especially from
	     code only 250000 bytes long.  */
	  do
	    {
	      prev = PREV_SEC (tail);
	      /* Set up this stub group.  */
	      hplink->stub_group[tail->id].link_sec = curr;
	    }
	  while (tail != curr && (tail = prev) != NULL);

	  /* But wait, there's more!  Input sections up to 250000
	     bytes before the stub section can be handled by it too.  */
	  if (!stubs_always_before_branch)
	    {
	      total = 0;
	      while (prev != NULL
		     && ((total += tail->output_offset - prev->output_offset)
			 < stub_group_size))
		{
		  tail = prev;
		  prev = PREV_SEC (tail);
		  hplink->stub_group[tail->id].link_sec = curr;
		}
	    }
	  tail = prev;
	}
    }
  while (list-- != input_list);
  free (input_list);
#undef PREV_SEC

  /* We want to read in symbol extension records only once.  To do this
     we need to read in the local symbols in parallel and save them for
     later use; so hold pointers to the local symbols in an array.  */
  all_local_syms
    = (Elf_Internal_Sym **) bfd_zmalloc (sizeof (Elf_Internal_Sym *)
					 * bfd_count);
  if (all_local_syms == NULL)
    return false;

  /* Walk over all the input BFDs, swapping in local symbols.
     If we are creating a shared library, create hash entries for the
     export stubs.  */
  for (input_bfd = info->input_bfds, bfd_indx = 0;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next, bfd_indx++)
    {
      Elf_Internal_Shdr *symtab_hdr;
      Elf_Internal_Sym *isym;
      Elf32_External_Sym *ext_syms, *esym, *end_sy;

      /* We'll need the symbol table in a second.  */
      symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
      if (symtab_hdr->sh_info == 0)
	continue;

      /* We need an array of the local symbols attached to the input bfd.
	 Unfortunately, we're going to have to read & swap them in.  */
      local_syms = (Elf_Internal_Sym *)
	bfd_malloc (symtab_hdr->sh_info * sizeof (Elf_Internal_Sym));
      if (local_syms == NULL)
	{
	  goto error_ret_free_local;
	}
      all_local_syms[bfd_indx] = local_syms;
      ext_syms = (Elf32_External_Sym *)
	bfd_malloc (symtab_hdr->sh_info * sizeof (Elf32_External_Sym));
      if (ext_syms == NULL)
	{
	  goto error_ret_free_local;
	}

      if (bfd_seek (input_bfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	  || (bfd_read (ext_syms, 1,
			(symtab_hdr->sh_info * sizeof (Elf32_External_Sym)),
			input_bfd)
	      != (symtab_hdr->sh_info * sizeof (Elf32_External_Sym))))
	{
	  free (ext_syms);
	  goto error_ret_free_local;
	}

      /* Swap the local symbols in.  */
      isym = local_syms;
      esym = ext_syms;
      for (end_sy = esym + symtab_hdr->sh_info; esym < end_sy; esym++, isym++)
	bfd_elf32_swap_symbol_in (input_bfd, esym, isym);

      /* Now we can free the external symbols.  */
      free (ext_syms);

#if ! LONG_BRANCH_PIC_IN_SHLIB
      /* If this is a shared link, find all the stub reloc sections.  */
      if (info->shared)
	for (section = input_bfd->sections;
	     section != NULL;
	     section = section->next)
	  {
	    char *name;
	    asection *reloc_sec;

	    name = bfd_malloc (strlen (section->name)
			       + sizeof STUB_SUFFIX
			       + 5);
	    if (name == NULL)
	      return false;
	    sprintf (name, ".rela%s%s", section->name, STUB_SUFFIX);
	    reloc_sec = bfd_get_section_by_name (hplink->root.dynobj, name);
	    hplink->stub_group[section->id].reloc_sec = reloc_sec;
	    free (name);
	  }
#endif

      if (info->shared && hplink->multi_subspace)
	{
	  struct elf_link_hash_entry **sym_hashes;
	  struct elf_link_hash_entry **end_hashes;
	  unsigned int symcount;

	  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
		      - symtab_hdr->sh_info);
	  sym_hashes = elf_sym_hashes (input_bfd);
	  end_hashes = sym_hashes + symcount;

	  /* Look through the global syms for functions;  We need to
	     build export stubs for all globally visible functions.  */
	  for (; sym_hashes < end_hashes; sym_hashes++)
	    {
	      struct elf32_hppa_link_hash_entry *hash;

	      hash = (struct elf32_hppa_link_hash_entry *) *sym_hashes;

	      while (hash->elf.root.type == bfd_link_hash_indirect
		     || hash->elf.root.type == bfd_link_hash_warning)
		hash = ((struct elf32_hppa_link_hash_entry *)
			hash->elf.root.u.i.link);

	      /* At this point in the link, undefined syms have been
		 resolved, so we need to check that the symbol was
		 defined in this BFD.  */
	      if ((hash->elf.root.type == bfd_link_hash_defined
		   || hash->elf.root.type == bfd_link_hash_defweak)
		  && hash->elf.type == STT_FUNC
		  && hash->elf.root.u.def.section->output_section != NULL
		  && (hash->elf.root.u.def.section->output_section->owner
		      == output_bfd)
		  && hash->elf.root.u.def.section->owner == input_bfd
		  && (hash->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
		  && !(hash->elf.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
		  && ELF_ST_VISIBILITY (hash->elf.other) == STV_DEFAULT)
		{
		  asection *sec;
		  const char *stub_name;
		  struct elf32_hppa_stub_hash_entry *stub_entry;

		  sec = hash->elf.root.u.def.section;
		  stub_name = hash->elf.root.root.string;
		  stub_entry = hppa_stub_hash_lookup (&hplink->stub_hash_table,
						      stub_name,
						      false, false);
		  if (stub_entry == NULL)
		    {
		      stub_entry = hppa_add_stub (stub_name, sec, hplink);
		      if (!stub_entry)
			goto error_ret_free_local;

		      stub_entry->target_value = hash->elf.root.u.def.value;
		      stub_entry->target_section = hash->elf.root.u.def.section;
		      stub_entry->stub_type = hppa_stub_export;
		      stub_entry->h = hash;
		      stub_changed = 1;
		    }
		  else
		    {
		      (*_bfd_error_handler) (_("%s: duplicate export stub %s"),
			     bfd_get_filename (input_bfd),
			     stub_name);
		    }
		}
	    }
	}
    }

  while (1)
    {
      asection *stub_sec;

      for (input_bfd = info->input_bfds, bfd_indx = 0;
	   input_bfd != NULL;
	   input_bfd = input_bfd->link_next, bfd_indx++)
	{
	  Elf_Internal_Shdr *symtab_hdr;

	  /* We'll need the symbol table in a second.  */
	  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
	  if (symtab_hdr->sh_info == 0)
	    continue;

	  local_syms = all_local_syms[bfd_indx];

	  /* Walk over each section attached to the input bfd.  */
	  for (section = input_bfd->sections;
	       section != NULL;
	       section = section->next)
	    {
	      Elf_Internal_Shdr *input_rel_hdr;
	      Elf32_External_Rela *external_relocs, *erelaend, *erela;
	      Elf_Internal_Rela *internal_relocs, *irelaend, *irela;

	      /* If there aren't any relocs, then there's nothing more
		 to do.  */
	      if ((section->flags & SEC_RELOC) == 0
		  || section->reloc_count == 0)
		continue;

	      /* If this section is a link-once section that will be
		 discarded, then don't create any stubs.  */
	      if (section->output_section == NULL
		  || section->output_section->owner != output_bfd)
		continue;

	      /* Allocate space for the external relocations.  */
	      external_relocs
		= ((Elf32_External_Rela *)
		   bfd_malloc (section->reloc_count
			       * sizeof (Elf32_External_Rela)));
	      if (external_relocs == NULL)
		{
		  goto error_ret_free_local;
		}

	      /* Likewise for the internal relocations.  */
	      internal_relocs = ((Elf_Internal_Rela *)
				 bfd_malloc (section->reloc_count
					     * sizeof (Elf_Internal_Rela)));
	      if (internal_relocs == NULL)
		{
		  free (external_relocs);
		  goto error_ret_free_local;
		}

	      /* Read in the external relocs.  */
	      input_rel_hdr = &elf_section_data (section)->rel_hdr;
	      if (bfd_seek (input_bfd, input_rel_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_read (external_relocs, 1,
			       input_rel_hdr->sh_size,
			       input_bfd) != input_rel_hdr->sh_size)
		{
		  free (external_relocs);
		error_ret_free_internal:
		  free (internal_relocs);
		  goto error_ret_free_local;
		}

	      /* Swap in the relocs.  */
	      erela = external_relocs;
	      erelaend = erela + section->reloc_count;
	      irela = internal_relocs;
	      for (; erela < erelaend; erela++, irela++)
		bfd_elf32_swap_reloca_in (input_bfd, erela, irela);

	      /* We're done with the external relocs, free them.  */
	      free (external_relocs);

	      /* Now examine each relocation.  */
	      irela = internal_relocs;
	      irelaend = irela + section->reloc_count;
	      for (; irela < irelaend; irela++)
		{
		  unsigned int r_type, r_indx;
		  enum elf32_hppa_stub_type stub_type;
		  struct elf32_hppa_stub_hash_entry *stub_entry;
		  asection *sym_sec;
		  bfd_vma sym_value;
		  bfd_vma destination;
		  struct elf32_hppa_link_hash_entry *hash;
		  char *stub_name;
		  const asection *id_sec;

		  r_type = ELF32_R_TYPE (irela->r_info);
		  r_indx = ELF32_R_SYM (irela->r_info);

		  if (r_type >= (unsigned int) R_PARISC_UNIMPLEMENTED)
		    {
		      bfd_set_error (bfd_error_bad_value);
		      goto error_ret_free_internal;
		    }

		  /* Only look for stubs on call instructions.  */
		  if (r_type != (unsigned int) R_PARISC_PCREL12F
		      && r_type != (unsigned int) R_PARISC_PCREL17F
		      && r_type != (unsigned int) R_PARISC_PCREL22F)
		    continue;

		  /* Now determine the call target, its name, value,
		     section.  */
		  sym_sec = NULL;
		  sym_value = 0;
		  destination = 0;
		  hash = NULL;
		  if (r_indx < symtab_hdr->sh_info)
		    {
		      /* It's a local symbol.  */
		      Elf_Internal_Sym *sym;
		      Elf_Internal_Shdr *hdr;

		      sym = local_syms + r_indx;
		      hdr = elf_elfsections (input_bfd)[sym->st_shndx];
		      sym_sec = hdr->bfd_section;
		      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
			sym_value = sym->st_value;
		      destination = (sym_value + irela->r_addend
				     + sym_sec->output_offset
				     + sym_sec->output_section->vma);
		    }
		  else
		    {
		      /* It's an external symbol.  */
		      int e_indx;

		      e_indx = r_indx - symtab_hdr->sh_info;
		      hash = ((struct elf32_hppa_link_hash_entry *)
			      elf_sym_hashes (input_bfd)[e_indx]);

		      while (hash->elf.root.type == bfd_link_hash_indirect
			     || hash->elf.root.type == bfd_link_hash_warning)
			hash = ((struct elf32_hppa_link_hash_entry *)
				hash->elf.root.u.i.link);

		      if (hash->elf.root.type == bfd_link_hash_defined
			  || hash->elf.root.type == bfd_link_hash_defweak)
			{
			  sym_sec = hash->elf.root.u.def.section;
			  sym_value = hash->elf.root.u.def.value;
			  if (sym_sec->output_section != NULL)
			    destination = (sym_value + irela->r_addend
					   + sym_sec->output_offset
					   + sym_sec->output_section->vma);
			}
		      else if (hash->elf.root.type == bfd_link_hash_undefweak)
			{
			  if (! info->shared)
			    continue;
			}
		      else if (hash->elf.root.type == bfd_link_hash_undefined)
			{
			  if (! (info->shared
				 && !info->no_undefined
				 && (ELF_ST_VISIBILITY (hash->elf.other)
				     == STV_DEFAULT)))
			    continue;
			}
		      else
			{
			  bfd_set_error (bfd_error_bad_value);
			  goto error_ret_free_internal;
			}
		    }

		  /* Determine what (if any) linker stub is needed.  */
		  stub_type = hppa_type_of_stub (section, irela, hash,
						 destination);
		  if (stub_type == hppa_stub_none)
		    continue;

		  /* Support for grouping stub sections.  */
		  id_sec = hplink->stub_group[section->id].link_sec;

		  /* Get the name of this stub.  */
		  stub_name = hppa_stub_name (id_sec, sym_sec, hash, irela);
		  if (!stub_name)
		    goto error_ret_free_internal;

		  stub_entry = hppa_stub_hash_lookup (&hplink->stub_hash_table,
						      stub_name,
						      false, false);
		  if (stub_entry != NULL)
		    {
		      /* The proper stub has already been created.  */
		      free (stub_name);
		      continue;
		    }

		  stub_entry = hppa_add_stub (stub_name, section, hplink);
		  if (stub_entry == NULL)
		    {
		      free (stub_name);
		      goto error_ret_free_local;
		    }

		  stub_entry->target_value = sym_value;
		  stub_entry->target_section = sym_sec;
		  stub_entry->stub_type = stub_type;
		  if (info->shared)
		    {
		      if (stub_type == hppa_stub_import)
			stub_entry->stub_type = hppa_stub_import_shared;
		      else if (stub_type == hppa_stub_long_branch
			       && (LONG_BRANCH_PIC_IN_SHLIB || hash == NULL))
			stub_entry->stub_type = hppa_stub_long_branch_shared;
		    }
		  stub_entry->h = hash;
		  stub_changed = 1;
		}

	      /* We're done with the internal relocs, free them.  */
	      free (internal_relocs);
	    }
	}

      if (!stub_changed)
	break;

      /* OK, we've added some stubs.  Find out the new size of the
	 stub sections.  */
      for (stub_sec = hplink->stub_bfd->sections;
	   stub_sec != NULL;
	   stub_sec = stub_sec->next)
	{
	  stub_sec->_raw_size = 0;
	  stub_sec->_cooked_size = 0;
	}
#if ! LONG_BRANCH_PIC_IN_SHLIB
      {
	int i;

	for (i = top_id; i >= 0; --i)
	  {
	    /* This will probably hit the same section many times..  */
	    stub_sec = hplink->stub_group[i].reloc_sec;
	    if (stub_sec != NULL)
	      {
		stub_sec->_raw_size = 0;
		stub_sec->_cooked_size = 0;
	      }
	  }
      }
#endif

      bfd_hash_traverse (&hplink->stub_hash_table,
			 hppa_size_one_stub,
			 hplink);

      /* Ask the linker to do its stuff.  */
      (*hplink->layout_sections_again) ();
      stub_changed = 0;
    }

  ret = 1;

 error_ret_free_local:
  while (bfd_count-- > 0)
    if (all_local_syms[bfd_count])
      free (all_local_syms[bfd_count]);
  free (all_local_syms);

  return ret;
}

/* For a final link, this function is called after we have sized the
   stubs to provide a value for __gp.  */

boolean
elf32_hppa_set_gp (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  struct elf32_hppa_link_hash_table *hplink;
  struct elf_link_hash_entry *h;
  asection *sec;
  bfd_vma gp_val;

  hplink = hppa_link_hash_table (info);
  h = elf_link_hash_lookup (&hplink->root, "$global$",
			    false, false, false);

  if (h != NULL
      && (h->root.type == bfd_link_hash_defined
	  || h->root.type == bfd_link_hash_defweak))
    {
      gp_val = h->root.u.def.value;
      sec = h->root.u.def.section;
    }
  else
    {
      /* Choose to point our LTP at, in this order, one of .plt, .got,
	 or .data, if these sections exist.  In the case of choosing
	 .plt try to make the LTP ideal for addressing anywhere in the
	 .plt or .got with a 14 bit signed offset.  Typically, the end
	 of the .plt is the start of the .got, so choose .plt + 0x2000
	 if either the .plt or .got is larger than 0x2000.  If both
	 the .plt and .got are smaller than 0x2000, choose the end of
	 the .plt section.  */

      sec = hplink->splt;
      if (sec != NULL)
	{
	  gp_val = sec->_raw_size;
	  if (gp_val > 0x2000
	      || (hplink->sgot && hplink->sgot->_raw_size > 0x2000))
	    {
	      gp_val = 0x2000;
	    }
	}
      else
	{
	  gp_val = 0;
	  sec = hplink->sgot;
	  if (sec != NULL)
	    {
	      /* We know we don't have a .plt.  If .got is large,
		 offset our LTP.  */
	      if (sec->_raw_size > 0x2000)
		gp_val = 0x2000;
	    }
	  else
	    {
	      /* No .plt or .got.  Who cares what the LTP is?  */
	      sec = bfd_get_section_by_name (abfd, ".data");
	    }
	}

      if (h != NULL)
	{
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.value = gp_val;
	  if (sec != NULL)
	    h->root.u.def.section = sec;
	  else
	    h->root.u.def.section = bfd_abs_section_ptr;
	}
    }

  if (sec != NULL && sec->output_section != NULL)
    gp_val += sec->output_section->vma + sec->output_offset;

  elf_gp (abfd) = gp_val;
  return true;
}

/* Build all the stubs associated with the current output file.  The
   stubs are kept in a hash table attached to the main linker hash
   table.  We also set up the .plt entries for statically linked PIC
   functions here.  This function is called via hppaelf_finish in the
   linker.  */

boolean
elf32_hppa_build_stubs (info)
     struct bfd_link_info *info;
{
  asection *stub_sec;
  struct bfd_hash_table *table;
  struct elf32_hppa_link_hash_table *hplink;

  hplink = hppa_link_hash_table (info);

  for (stub_sec = hplink->stub_bfd->sections;
       stub_sec != NULL;
       stub_sec = stub_sec->next)
    {
      size_t size;

      /* Allocate memory to hold the linker stubs.  */
      size = stub_sec->_raw_size;
      stub_sec->contents = (unsigned char *) bfd_zalloc (hplink->stub_bfd,
							 size);
      if (stub_sec->contents == NULL && size != 0)
	return false;
      stub_sec->_raw_size = 0;
    }

  /* Build the stubs as directed by the stub hash table.  */
  table = &hplink->stub_hash_table;
  bfd_hash_traverse (table, hppa_build_one_stub, info);

  return true;
}

/* Perform a final link.  */

static boolean
elf32_hppa_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  asection *s;

  /* Invoke the regular ELF linker to do all the work.  */
  if (!bfd_elf32_bfd_final_link (abfd, info))
    return false;

  /* If we're producing a final executable, sort the contents of the
     unwind section.  Magic section names, but this is much safer than
     having elf32_hppa_relocate_section remember where SEGREL32 relocs
     occurred.  Consider what happens if someone inept creates a
     linker script that puts unwind information in .text.  */
  s = bfd_get_section_by_name (abfd, ".PARISC.unwind");
  if (s != NULL)
    {
      bfd_size_type size;
      char *contents;

      size = s->_raw_size;
      contents = bfd_malloc (size);
      if (contents == NULL)
	return false;

      if (! bfd_get_section_contents (abfd, s, contents, (file_ptr) 0, size))
	return false;

      qsort (contents, size / 16, 16, hppa_unwind_entry_compare);

      if (! bfd_set_section_contents (abfd, s, contents, (file_ptr) 0, size))
	return false;
    }
  return true;
}

/* Record the lowest address for the data and text segments.  */

static void
hppa_record_segment_addr (abfd, section, data)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section;
     PTR data;
{
  struct elf32_hppa_link_hash_table *hplink;

  hplink = (struct elf32_hppa_link_hash_table *) data;

  if ((section->flags & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
    {
      bfd_vma value = section->vma - section->filepos;

      if ((section->flags & SEC_READONLY) != 0)
	{
	  if (value < hplink->text_segment_base)
	    hplink->text_segment_base = value;
	}
      else
	{
	  if (value < hplink->data_segment_base)
	    hplink->data_segment_base = value;
	}
    }
}

/* Perform a relocation as part of a final link.  */

static bfd_reloc_status_type
final_link_relocate (input_section, contents, rel, value, hplink, sym_sec, h)
     asection *input_section;
     bfd_byte *contents;
     const Elf_Internal_Rela *rel;
     bfd_vma value;
     struct elf32_hppa_link_hash_table *hplink;
     asection *sym_sec;
     struct elf32_hppa_link_hash_entry *h;
{
  int insn;
  unsigned int r_type = ELF32_R_TYPE (rel->r_info);
  reloc_howto_type *howto = elf_hppa_howto_table + r_type;
  int r_format = howto->bitsize;
  enum hppa_reloc_field_selector_type_alt r_field;
  bfd *input_bfd = input_section->owner;
  bfd_vma offset = rel->r_offset;
  bfd_vma max_branch_offset = 0;
  bfd_byte *hit_data = contents + offset;
  bfd_signed_vma addend = rel->r_addend;
  bfd_vma location;
  struct elf32_hppa_stub_hash_entry *stub_entry = NULL;
  int val;

  if (r_type == R_PARISC_NONE)
    return bfd_reloc_ok;

  insn = bfd_get_32 (input_bfd, hit_data);

  /* Find out where we are and where we're going.  */
  location = (offset +
	      input_section->output_offset +
	      input_section->output_section->vma);

  switch (r_type)
    {
    case R_PARISC_PCREL12F:
    case R_PARISC_PCREL17F:
    case R_PARISC_PCREL22F:
      /* If this is a call to a function defined in another dynamic
	 library, or if it is a call to a PIC function in the same
	 object, or if this is a shared link and it is a call to a
	 weak symbol which may or may not be in the same object, then
	 find the import stub in the stub hash.  */
      if (sym_sec == NULL
	  || sym_sec->output_section == NULL
	  || (h != NULL
	      && ((h->maybe_pic_call
		   && !(input_section->flags & SEC_HAS_GOT_REF))
		  || (h->elf.root.type == bfd_link_hash_defweak
		      && h->elf.dynindx != -1
		      && h->elf.plt.offset != (bfd_vma) -1))))
	{
	  stub_entry = hppa_get_stub_entry (input_section, sym_sec,
					    h, rel, hplink);
	  if (stub_entry != NULL)
	    {
	      value = (stub_entry->stub_offset
		       + stub_entry->stub_sec->output_offset
		       + stub_entry->stub_sec->output_section->vma);
	      addend = 0;
	    }
	  else if (sym_sec == NULL && h != NULL
		   && h->elf.root.type == bfd_link_hash_undefweak)
	    {
	      /* It's OK if undefined weak.  Calls to undefined weak
		 symbols behave as if the "called" function
		 immediately returns.  We can thus call to a weak
		 function without first checking whether the function
		 is defined.  */
	      value = location;
	      addend = 8;
	    }
	  else
	    return bfd_reloc_notsupported;
	}
      /* Fall thru.  */

    case R_PARISC_PCREL21L:
    case R_PARISC_PCREL17C:
    case R_PARISC_PCREL17R:
    case R_PARISC_PCREL14R:
    case R_PARISC_PCREL14F:
      /* Make it a pc relative offset.  */
      value -= location;
      addend -= 8;
      break;

    case R_PARISC_DPREL21L:
    case R_PARISC_DPREL14R:
    case R_PARISC_DPREL14F:
    /* For all the DP relative relocations, we need to examine the symbol's
       section.  If it's a code section, then "data pointer relative" makes
       no sense.  In that case we don't adjust the "value", and for 21 bit
       addil instructions, we change the source addend register from %dp to
       %r0.  This situation commonly arises when a variable's "constness"
       is declared differently from the way the variable is defined.  For
       instance: "extern int foo" with foo defined as "const int foo".  */
      if (sym_sec == NULL)
	break;
      if ((sym_sec->flags & SEC_CODE) != 0)
	{
	  if ((insn & ((0x3f << 26) | (0x1f << 21)))
	      == (((int) OP_ADDIL << 26) | (27 << 21)))
	    {
	      insn &= ~ (0x1f << 21);
#if 1 /* debug them.  */
	      (*_bfd_error_handler)
		(_("%s(%s+0x%lx): fixing %s"),
		 bfd_get_filename (input_bfd),
		 input_section->name,
		 (long) rel->r_offset,
		 howto->name);
#endif
	    }
	  /* Now try to make things easy for the dynamic linker.  */

	  break;
	}
      /* Fall thru.  */

    case R_PARISC_DLTIND21L:
    case R_PARISC_DLTIND14R:
    case R_PARISC_DLTIND14F:
      value -= elf_gp (input_section->output_section->owner);
      break;

    case R_PARISC_SEGREL32:
      if ((sym_sec->flags & SEC_CODE) != 0)
	value -= hplink->text_segment_base;
      else
	value -= hplink->data_segment_base;
      break;

    default:
      break;
    }

  switch (r_type)
    {
    case R_PARISC_DIR32:
    case R_PARISC_DIR14F:
    case R_PARISC_DIR17F:
    case R_PARISC_PCREL17C:
    case R_PARISC_PCREL14F:
    case R_PARISC_DPREL14F:
    case R_PARISC_PLABEL32:
    case R_PARISC_DLTIND14F:
    case R_PARISC_SEGBASE:
    case R_PARISC_SEGREL32:
      r_field = e_fsel;
      break;

    case R_PARISC_DIR21L:
    case R_PARISC_PCREL21L:
    case R_PARISC_DPREL21L:
    case R_PARISC_PLABEL21L:
    case R_PARISC_DLTIND21L:
      r_field = e_lrsel;
      break;

    case R_PARISC_DIR17R:
    case R_PARISC_PCREL17R:
    case R_PARISC_DIR14R:
    case R_PARISC_PCREL14R:
    case R_PARISC_DPREL14R:
    case R_PARISC_PLABEL14R:
    case R_PARISC_DLTIND14R:
      r_field = e_rrsel;
      break;

    case R_PARISC_PCREL12F:
    case R_PARISC_PCREL17F:
    case R_PARISC_PCREL22F:
      r_field = e_fsel;

      if (r_type == (unsigned int) R_PARISC_PCREL17F)
	{
	  max_branch_offset = (1 << (17-1)) << 2;
	}
      else if (r_type == (unsigned int) R_PARISC_PCREL12F)
	{
	  max_branch_offset = (1 << (12-1)) << 2;
	}
      else
	{
	  max_branch_offset = (1 << (22-1)) << 2;
	}

      /* sym_sec is NULL on undefined weak syms or when shared on
	 undefined syms.  We've already checked for a stub for the
	 shared undefined case.  */
      if (sym_sec == NULL)
	break;

      /* If the branch is out of reach, then redirect the
	 call to the local stub for this function.  */
      if (value + addend + max_branch_offset >= 2*max_branch_offset)
	{
	  stub_entry = hppa_get_stub_entry (input_section, sym_sec,
					    h, rel, hplink);
	  if (stub_entry == NULL)
	    return bfd_reloc_notsupported;

	  /* Munge up the value and addend so that we call the stub
	     rather than the procedure directly.  */
	  value = (stub_entry->stub_offset
		   + stub_entry->stub_sec->output_offset
		   + stub_entry->stub_sec->output_section->vma
		   - location);
	  addend = -8;
	}
      break;

    /* Something we don't know how to handle.  */
    default:
      return bfd_reloc_notsupported;
    }

  /* Make sure we can reach the stub.  */
  if (max_branch_offset != 0
      && value + addend + max_branch_offset >= 2*max_branch_offset)
    {
      (*_bfd_error_handler)
	(_("%s(%s+0x%lx): cannot reach %s, recompile with -ffunction-sections"),
	 bfd_get_filename (input_bfd),
	 input_section->name,
	 (long) rel->r_offset,
	 stub_entry->root.string);
      return bfd_reloc_notsupported;
    }

  val = hppa_field_adjust (value, addend, r_field);

  switch (r_type)
    {
    case R_PARISC_PCREL12F:
    case R_PARISC_PCREL17C:
    case R_PARISC_PCREL17F:
    case R_PARISC_PCREL17R:
    case R_PARISC_PCREL22F:
    case R_PARISC_DIR17F:
    case R_PARISC_DIR17R:
      /* This is a branch.  Divide the offset by four.
	 Note that we need to decide whether it's a branch or
	 otherwise by inspecting the reloc.  Inspecting insn won't
	 work as insn might be from a .word directive.  */
      val >>= 2;
      break;

    default:
      break;
    }

  insn = hppa_rebuild_insn (insn, val, r_format);

  /* Update the instruction word.  */
  bfd_put_32 (input_bfd, (bfd_vma) insn, hit_data);
  return bfd_reloc_ok;
}

/* Relocate an HPPA ELF section.  */

static boolean
elf32_hppa_relocate_section (output_bfd, info, input_bfd, input_section,
			     contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  bfd *dynobj;
  bfd_vma *local_got_offsets;
  struct elf32_hppa_link_hash_table *hplink;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  asection *sreloc;

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;

  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;
  local_got_offsets = elf_local_got_offsets (input_bfd);
  sreloc = NULL;

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      unsigned int r_type;
      reloc_howto_type *howto;
      unsigned int r_symndx;
      struct elf32_hppa_link_hash_entry *h;
      Elf_Internal_Sym *sym;
      asection *sym_sec;
      bfd_vma relocation;
      bfd_reloc_status_type r;
      const char *sym_name;
      boolean plabel;

      r_type = ELF32_R_TYPE (rel->r_info);
      if (r_type >= (unsigned int) R_PARISC_UNIMPLEMENTED)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}
      if (r_type == (unsigned int) R_PARISC_GNU_VTENTRY
	  || r_type == (unsigned int) R_PARISC_GNU_VTINHERIT)
	continue;

      r_symndx = ELF32_R_SYM (rel->r_info);

      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sym_sec = local_sections[r_symndx];
		  rel->r_addend += sym_sec->output_offset;
		}
	    }
	  continue;
	}

      /* This is a final link.  */
      h = NULL;
      sym = NULL;
      sym_sec = NULL;
      if (r_symndx < symtab_hdr->sh_info)
	{
	  /* This is a local symbol, h defaults to NULL.  */
	  sym = local_syms + r_symndx;
	  sym_sec = local_sections[r_symndx];
	  relocation = ((ELF_ST_TYPE (sym->st_info) == STT_SECTION
			   ? 0 : sym->st_value)
			 + sym_sec->output_offset
			 + sym_sec->output_section->vma);
	}
      else
	{
	  int indx;

	  /* It's a global; Find its entry in the link hash.  */
	  indx = r_symndx - symtab_hdr->sh_info;
	  h = ((struct elf32_hppa_link_hash_entry *)
	       elf_sym_hashes (input_bfd)[indx]);
	  while (h->elf.root.type == bfd_link_hash_indirect
		 || h->elf.root.type == bfd_link_hash_warning)
	    h = (struct elf32_hppa_link_hash_entry *) h->elf.root.u.i.link;

	  relocation = 0;
	  if (h->elf.root.type == bfd_link_hash_defined
	      || h->elf.root.type == bfd_link_hash_defweak)
	    {
	      sym_sec = h->elf.root.u.def.section;
	      /* If sym_sec->output_section is NULL, then it's a
		 symbol defined in a shared library.  */
	      if (sym_sec->output_section != NULL)
		relocation = (h->elf.root.u.def.value
			      + sym_sec->output_offset
			      + sym_sec->output_section->vma);
	    }
	  else if (h->elf.root.type == bfd_link_hash_undefweak)
	    ;
	  else if (info->shared && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->elf.other) == STV_DEFAULT
		   && h->elf.type != STT_PARISC_MILLI)
	    {
	      if (info->symbolic)
		if (!((*info->callbacks->undefined_symbol)
		      (info, h->elf.root.root.string, input_bfd,
		       input_section, rel->r_offset, false)))
		  return false;
	    }
	  else
	    {
	      if (!((*info->callbacks->undefined_symbol)
		    (info, h->elf.root.root.string, input_bfd,
		     input_section, rel->r_offset, true)))
		return false;
	    }
	}

      /* Do any required modifications to the relocation value, and
	 determine what types of dynamic info we need to output, if
	 any.  */
      plabel = 0;
      switch (r_type)
	{
	case R_PARISC_DLTIND14F:
	case R_PARISC_DLTIND14R:
	case R_PARISC_DLTIND21L:
	  /* Relocation is to the entry for this symbol in the global
	     offset table.  */
	  if (h != NULL)
	    {
	      bfd_vma off;
	      boolean dyn;

	      off = h->elf.got.offset;
	      if (off == (bfd_vma) -1)
		abort ();

	      dyn = hplink->root.dynamic_sections_created;
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, &h->elf))
		{
		  /* This is actually a static link, or it is a
		     -Bsymbolic link and the symbol is defined
		     locally, or the symbol was forced to be local
		     because of a version file.  We must initialize
		     this entry in the global offset table.  Since the
		     offset must always be a multiple of 4, we use the
		     least significant bit to record whether we have
		     initialized it already.

		     When doing a dynamic link, we create a .rela.got
		     relocation entry to initialize the value.  This
		     is done in the finish_dynamic_symbol routine.  */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
		      bfd_put_32 (output_bfd, relocation,
				  hplink->sgot->contents + off);
		      h->elf.got.offset |= 1;
		    }
		}

	      relocation = off;
	    }
	  else
	    {
	      /* Local symbol case.  */
	      bfd_vma off;

	      if (local_got_offsets == NULL
		  || (off = local_got_offsets[r_symndx]) == (bfd_vma) -1)
		abort ();

	      /* The offset must always be a multiple of 4.  We use
		 the least significant bit to record whether we have
		 already generated the necessary reloc.  */
	      if ((off & 1) != 0)
		off &= ~1;
	      else
		{
		  bfd_put_32 (output_bfd, relocation,
			      hplink->sgot->contents + off);

		  if (info->shared)
		    {
		      /* Output a dynamic relocation for this GOT
			 entry.  In this case it is relative to the
			 base of the object because the symbol index
			 is zero.  */
		      Elf_Internal_Rela outrel;
		      asection *srelgot = hplink->srelgot;

		      outrel.r_offset = (off
					 + hplink->sgot->output_offset
					 + hplink->sgot->output_section->vma);
		      outrel.r_info = ELF32_R_INFO (0, R_PARISC_DIR32);
		      outrel.r_addend = relocation;
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
						 ((Elf32_External_Rela *)
						  srelgot->contents
						  + srelgot->reloc_count));
		      ++srelgot->reloc_count;
		    }

		  local_got_offsets[r_symndx] |= 1;
		}

	      relocation = off;
	    }

	  /* Add the base of the GOT to the relocation value.  */
	  relocation += (hplink->sgot->output_offset
			 + hplink->sgot->output_section->vma);
	  break;

	case R_PARISC_SEGREL32:
	  /* If this is the first SEGREL relocation, then initialize
	     the segment base values.  */
	  if (hplink->text_segment_base == (bfd_vma) -1)
	    bfd_map_over_sections (output_bfd,
				   hppa_record_segment_addr,
				   hplink);
	  break;

	case R_PARISC_PLABEL14R:
	case R_PARISC_PLABEL21L:
	case R_PARISC_PLABEL32:
	  if (hplink->root.dynamic_sections_created)
	    {
	      bfd_vma off;

	      /* If we have a global symbol with a PLT slot, then
		 redirect this relocation to it.  */
	      if (h != NULL)
		{
		  off = h->elf.plt.offset;
		  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, &h->elf))
		    {
		      /* In a non-shared link, adjust_dynamic_symbols
			 isn't called for symbols forced local.  We
			 need to write out the plt entry here.  */ 
		      if ((off & 1) != 0)
			off &= ~1;
		      else
			{
			  bfd_put_32 (output_bfd,
				      relocation,
				      hplink->splt->contents + off);
			  bfd_put_32 (output_bfd,
				      elf_gp (hplink->splt->output_section->owner),
				      hplink->splt->contents + off + 4);
			  h->elf.plt.offset |= 1;
			}
		    }
		}
	      else
		{
		  int indx;

		  indx = r_symndx + symtab_hdr->sh_info;
		  off = local_got_offsets[indx];

		  /* As for the local .got entry case, we use the last
		     bit to record whether we've already initialised
		     this local .plt entry.  */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
		      bfd_put_32 (output_bfd,
				  relocation,
				  hplink->splt->contents + off);
		      bfd_put_32 (output_bfd,
				  elf_gp (hplink->splt->output_section->owner),
				  hplink->splt->contents + off + 4);

		      if (info->shared)
			{
			  /* Output a dynamic IPLT relocation for this
			     PLT entry.  */
			  Elf_Internal_Rela outrel;
			  asection *srelplt = hplink->srelplt;

			  outrel.r_offset = (off
					     + hplink->splt->output_offset
					     + hplink->splt->output_section->vma);
			  outrel.r_info = ELF32_R_INFO (0, R_PARISC_IPLT);
			  outrel.r_addend = relocation;
			  bfd_elf32_swap_reloca_out (output_bfd, &outrel,
						     ((Elf32_External_Rela *)
						      srelplt->contents
						      + srelplt->reloc_count));
			  ++srelplt->reloc_count;
			}

		      local_got_offsets[indx] |= 1;
		    }
		}

	      if (off >= (bfd_vma) -2 || (off & 1) != 0)
		abort ();

	      /* PLABELs contain function pointers.  Relocation is to
		 the entry for the function in the .plt.  The magic +2
		 offset signals to $$dyncall that the function pointer
		 is in the .plt and thus has a gp pointer too.
		 Exception:  Undefined PLABELs should have a value of
		 zero.  */
	      if (h == NULL
		  || (h->elf.root.type != bfd_link_hash_undefweak
		      && h->elf.root.type != bfd_link_hash_undefined))
		{
		  relocation = (off
				+ hplink->splt->output_offset
				+ hplink->splt->output_section->vma
				+ 2);
		}
	      plabel = 1;
	    }
	  /* Fall through and possibly emit a dynamic relocation.  */

	case R_PARISC_DIR17F:
	case R_PARISC_DIR17R:
	case R_PARISC_DIR14F:
	case R_PARISC_DIR14R:
	case R_PARISC_DIR21L:
	case R_PARISC_DPREL14F:
	case R_PARISC_DPREL14R:
	case R_PARISC_DPREL21L:
	case R_PARISC_DIR32:
	  /* The reloc types handled here and this conditional
	     expression must match the code in check_relocs and
	     hppa_discard_copies.  ie. We need exactly the same
	     condition as in check_relocs, with some extra conditions
	     (dynindx test in this case) to cater for relocs removed
	     by hppa_discard_copies.  */
	  if ((input_section->flags & SEC_ALLOC) != 0
	      && info->shared
#if RELATIVE_DYNAMIC_RELOCS
	      && (is_absolute_reloc (r_type)
		  || ((!info->symbolic
		       || (h != NULL
			   && ((h->elf.elf_link_hash_flags
				& ELF_LINK_HASH_DEF_REGULAR) == 0
			       || h->elf.root.type == bfd_link_hash_defweak)))
		      && (h == NULL || h->elf.dynindx != -1)))
#endif
	      )
	    {
	      Elf_Internal_Rela outrel;
	      boolean skip;

	      /* When generating a shared object, these relocations
		 are copied into the output file to be resolved at run
		 time.  */

	      if (sreloc == NULL)
		{
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
		    return false;
		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    abort ();
		}

	      outrel.r_offset = rel->r_offset;
	      outrel.r_addend = rel->r_addend;
	      skip = false;
	      if (elf_section_data (input_section)->stab_info != NULL)
		{
		  bfd_vma off;

		  off = (_bfd_stab_section_offset
			 (output_bfd, &hplink->root.stab_info,
			  input_section,
			  &elf_section_data (input_section)->stab_info,
			  rel->r_offset));
		  if (off == (bfd_vma) -1)
		    skip = true;
		  outrel.r_offset = off;
		}

	      outrel.r_offset += (input_section->output_offset
				  + input_section->output_section->vma);

	      if (skip)
		{
		  memset (&outrel, 0, sizeof (outrel));
		}
	      else if (h != NULL
		       && h->elf.dynindx != -1
		       && (plabel
			   || !info->symbolic
			   || (h->elf.elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))
		{
		  outrel.r_info = ELF32_R_INFO (h->elf.dynindx, r_type);
		}
	      else /* It's a local symbol, or one marked to become local.  */
		{
		  int indx = 0;

		  /* Add the absolute offset of the symbol.  */
		  outrel.r_addend += relocation;

		  /* Global plabels need to be processed by the
		     dynamic linker so that functions have at most one
		     fptr.  For this reason, we need to differentiate
		     between global and local plabels, which we do by
		     providing the function symbol for a global plabel
		     reloc, and no symbol for local plabels.  */
		  if (! plabel
		      && sym_sec != NULL
		      && sym_sec->output_section != NULL
		      && ! bfd_is_abs_section (sym_sec))
		    {
		      indx = elf_section_data (sym_sec->output_section)->dynindx;
		      /* We are turning this relocation into one
			 against a section symbol, so subtract out the
			 output section's address but not the offset
			 of the input section in the output section.  */
		      outrel.r_addend -= sym_sec->output_section->vma;
		    }

		  outrel.r_info = ELF32_R_INFO (indx, r_type);
		}

	      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
					 ((Elf32_External_Rela *)
					  sreloc->contents
					  + sreloc->reloc_count));
	      ++sreloc->reloc_count;
	    }
	  break;

	default:
	  break;
	}

      r = final_link_relocate (input_section, contents, rel, relocation,
			       hplink, sym_sec, h);

      if (r == bfd_reloc_ok)
	continue;

      if (h != NULL)
	sym_name = h->elf.root.root.string;
      else
	{
	  sym_name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
						      sym->st_name);
	  if (sym_name == NULL)
	    return false;
	  if (*sym_name == '\0')
	    sym_name = bfd_section_name (input_bfd, sym_sec);
	}

      howto = elf_hppa_howto_table + r_type;

      if (r == bfd_reloc_undefined || r == bfd_reloc_notsupported)
	{
	  (*_bfd_error_handler)
	    (_("%s(%s+0x%lx): cannot handle %s for %s"),
	     bfd_get_filename (input_bfd),
	     input_section->name,
	     (long) rel->r_offset,
	     howto->name,
	     sym_name);
	}
      else
	{
	  if (!((*info->callbacks->reloc_overflow)
		(info, sym_name, howto->name, (bfd_vma) 0,
		 input_bfd, input_section, rel->r_offset)))
	    return false;
	}
    }

  return true;
}

/* Comparison function for qsort to sort unwind section during a
   final link.  */

static int
hppa_unwind_entry_compare (a, b)
     const PTR a;
     const PTR b;
{
  const bfd_byte *ap, *bp;
  unsigned long av, bv;

  ap = (const bfd_byte *) a;
  av = (unsigned long) ap[0] << 24;
  av |= (unsigned long) ap[1] << 16;
  av |= (unsigned long) ap[2] << 8;
  av |= (unsigned long) ap[3];

  bp = (const bfd_byte *) b;
  bv = (unsigned long) bp[0] << 24;
  bv |= (unsigned long) bp[1] << 16;
  bv |= (unsigned long) bp[2] << 8;
  bv |= (unsigned long) bp[3];

  return av < bv ? -1 : av > bv ? 1 : 0;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static boolean
elf32_hppa_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
{
  struct elf32_hppa_link_hash_table *hplink;
  bfd *dynobj;

  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;

  if (h->plt.offset != (bfd_vma) -1)
    {
      bfd_vma value;

      if (h->plt.offset & 1)
	abort ();

      /* This symbol has an entry in the procedure linkage table.  Set
	 it up.

	 The format of a plt entry is
	 <funcaddr>
	 <__gp>
      */
      value = 0;
      if (h->root.type == bfd_link_hash_defined
	  || h->root.type == bfd_link_hash_defweak)
	{
	  value = h->root.u.def.value;
	  if (h->root.u.def.section->output_section != NULL)
	    value += (h->root.u.def.section->output_offset
		      + h->root.u.def.section->output_section->vma);
	}

      if (! ((struct elf32_hppa_link_hash_entry *) h)->pic_call)
	{
	  Elf_Internal_Rela rel;

	  /* Create a dynamic IPLT relocation for this entry.  */
	  rel.r_offset = (h->plt.offset
			  + hplink->splt->output_offset
			  + hplink->splt->output_section->vma);
	  if (! ((struct elf32_hppa_link_hash_entry *) h)->plt_abs
	      && h->dynindx != -1)
	    {
	      /* To support lazy linking, the function pointer is
		 initialised to point to a special stub stored at the
		 end of the .plt.  This is not done for plt entries
		 with a base-relative dynamic relocation.  */
	      value = (hplink->splt->output_offset
		       + hplink->splt->output_section->vma
		       + hplink->splt->_raw_size
		       - sizeof (plt_stub)
		       + PLT_STUB_ENTRY);
	      rel.r_info = ELF32_R_INFO (h->dynindx, R_PARISC_IPLT);
	      rel.r_addend = 0;
	    }
	  else
	    {
	      /* This symbol has been marked to become local, and is
		 used by a plabel so must be kept in the .plt.  */
	      rel.r_info = ELF32_R_INFO (0, R_PARISC_IPLT);
	      rel.r_addend = value;
	    }

	  bfd_elf32_swap_reloca_out (hplink->splt->output_section->owner,
				     &rel,
				     ((Elf32_External_Rela *)
				      hplink->srelplt->contents
				      + hplink->srelplt->reloc_count));
	  hplink->srelplt->reloc_count++;
	}

      bfd_put_32 (hplink->splt->owner,
		  value,
		  hplink->splt->contents + h->plt.offset);
      bfd_put_32 (hplink->splt->owner,
		  elf_gp (hplink->splt->output_section->owner),
		  hplink->splt->contents + h->plt.offset + 4);
      if (PLABEL_PLT_ENTRY_SIZE != PLT_ENTRY_SIZE
	  && ((struct elf32_hppa_link_hash_entry *) h)->plabel
	  && h->dynindx != -1)
	{
	  memset (hplink->splt->contents + h->plt.offset + 8,
		  0, PLABEL_PLT_ENTRY_SIZE - PLT_ENTRY_SIZE);
	}

      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	{
	  /* Mark the symbol as undefined, rather than as defined in
	     the .plt section.  Leave the value alone.  */
	  sym->st_shndx = SHN_UNDEF;
	}
    }

  if (h->got.offset != (bfd_vma) -1)
    {
      Elf_Internal_Rela rel;

      /* This symbol has an entry in the global offset table.  Set it
	 up.  */

      rel.r_offset = ((h->got.offset &~ (bfd_vma) 1)
		      + hplink->sgot->output_offset
		      + hplink->sgot->output_section->vma);

      /* If this is a -Bsymbolic link and the symbol is defined
	 locally or was forced to be local because of a version file,
	 we just want to emit a RELATIVE reloc.  The entry in the
	 global offset table will already have been initialized in the
	 relocate_section function.  */
      if (info->shared
	  && (info->symbolic || h->dynindx == -1)
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
	{
	  rel.r_info = ELF32_R_INFO (0, R_PARISC_DIR32);
	  rel.r_addend = (h->root.u.def.value
			  + h->root.u.def.section->output_offset
			  + h->root.u.def.section->output_section->vma);
	}
      else
	{
	  if ((h->got.offset & 1) != 0)
	    abort ();
	  bfd_put_32 (output_bfd, (bfd_vma) 0,
		      hplink->sgot->contents + h->got.offset);
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_PARISC_DIR32);
	  rel.r_addend = 0;
	}

      bfd_elf32_swap_reloca_out (output_bfd, &rel,
				 ((Elf32_External_Rela *)
				  hplink->srelgot->contents
				  + hplink->srelgot->reloc_count));
      ++hplink->srelgot->reloc_count;
    }

  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) != 0)
    {
      asection *s;
      Elf_Internal_Rela rel;

      /* This symbol needs a copy reloc.  Set it up.  */

      if (! (h->dynindx != -1
	     && (h->root.type == bfd_link_hash_defined
		 || h->root.type == bfd_link_hash_defweak)))
	abort ();

      s = hplink->srelbss;

      rel.r_offset = (h->root.u.def.value
		      + h->root.u.def.section->output_offset
		      + h->root.u.def.section->output_section->vma);
      rel.r_addend = 0;
      rel.r_info = ELF32_R_INFO (h->dynindx, R_PARISC_COPY);
      bfd_elf32_swap_reloca_out (output_bfd, &rel,
				 ((Elf32_External_Rela *) s->contents
				  + s->reloc_count));
      ++s->reloc_count;
    }

  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
  if (h->root.root.string[0] == '_'
      && (strcmp (h->root.root.string, "_DYNAMIC") == 0
	  || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0))
    {
      sym->st_shndx = SHN_ABS;
    }

  return true;
}

/* Finish up the dynamic sections.  */

static boolean
elf32_hppa_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  bfd *dynobj;
  struct elf32_hppa_link_hash_table *hplink;
  asection *sdyn;

  hplink = hppa_link_hash_table (info);
  dynobj = hplink->root.dynobj;

  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");

  if (hplink->root.dynamic_sections_created)
    {
      Elf32_External_Dyn *dyncon, *dynconend;

      if (sdyn == NULL)
	abort ();

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  asection *s;

	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      break;

	    case DT_PLTGOT:
	      /* Use PLTGOT to set the GOT register.  */
	      dyn.d_un.d_ptr = elf_gp (output_bfd);
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_JMPREL:
	      s = hplink->srelplt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_PLTRELSZ:
	      s = hplink->srelplt;
	      if (s->_cooked_size != 0)
		dyn.d_un.d_val = s->_cooked_size;
	      else
		dyn.d_un.d_val = s->_raw_size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;
	    }
	}
    }

  if (hplink->sgot->_raw_size != 0)
    {
      /* Fill in the first entry in the global offset table.
	 We use it to point to our dynamic section, if we have one.  */
      bfd_put_32 (output_bfd,
		  (sdyn != NULL
		   ? sdyn->output_section->vma + sdyn->output_offset
		   : (bfd_vma) 0),
		  hplink->sgot->contents);

      /* The second entry is reserved for use by the dynamic linker.  */
      memset (hplink->sgot->contents + GOT_ENTRY_SIZE, 0, GOT_ENTRY_SIZE);

      /* Set .got entry size.  */
      elf_section_data (hplink->sgot->output_section)
	->this_hdr.sh_entsize = GOT_ENTRY_SIZE;
    }

  if (hplink->splt->_raw_size != 0)
    {
      /* Set plt entry size.  */
      elf_section_data (hplink->splt->output_section)
	->this_hdr.sh_entsize = PLT_ENTRY_SIZE;

      if (hplink->need_plt_stub)
	{
	  /* Set up the .plt stub.  */
	  memcpy (hplink->splt->contents
		  + hplink->splt->_raw_size - sizeof (plt_stub),
		  plt_stub, sizeof (plt_stub));

	  if ((hplink->splt->output_offset
	       + hplink->splt->output_section->vma
	       + hplink->splt->_raw_size)
	      != (hplink->sgot->output_offset
		  + hplink->sgot->output_section->vma))
	    {
	      (*_bfd_error_handler)
		(_(".got section not immediately after .plt section"));
	      return false;
	    }
	}
    }

  return true;
}

/* Tweak the OSABI field of the elf header.  */

static void
elf32_hppa_post_process_headers (abfd, link_info)
     bfd *abfd;
     struct bfd_link_info *link_info ATTRIBUTE_UNUSED;
{
  Elf_Internal_Ehdr * i_ehdrp;

  i_ehdrp = elf_elfheader (abfd);

  if (strcmp (bfd_get_target (abfd), "elf32-hppa-linux") == 0)
    {
      i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_LINUX;
    }
  else
    {
      i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_HPUX;
    }
}

/* Called when writing out an object file to decide the type of a
   symbol.  */
static int
elf32_hppa_elf_get_symbol_type (elf_sym, type)
     Elf_Internal_Sym *elf_sym;
     int type;
{
  if (ELF_ST_TYPE (elf_sym->st_info) == STT_PARISC_MILLI)
    return STT_PARISC_MILLI;
  else
    return type;
}

/* Misc BFD support code.  */
#define bfd_elf32_bfd_is_local_label_name    elf_hppa_is_local_label_name
#define bfd_elf32_bfd_reloc_type_lookup	     elf_hppa_reloc_type_lookup
#define elf_info_to_howto		     elf_hppa_info_to_howto
#define elf_info_to_howto_rel		     elf_hppa_info_to_howto_rel

/* Stuff for the BFD linker.  */
#define bfd_elf32_bfd_final_link	     elf32_hppa_final_link
#define bfd_elf32_bfd_link_hash_table_create elf32_hppa_link_hash_table_create
#define elf_backend_add_symbol_hook	     elf32_hppa_add_symbol_hook
#define elf_backend_adjust_dynamic_symbol    elf32_hppa_adjust_dynamic_symbol
#define elf_backend_check_relocs	     elf32_hppa_check_relocs
#define elf_backend_create_dynamic_sections  elf32_hppa_create_dynamic_sections
#define elf_backend_fake_sections	     elf_hppa_fake_sections
#define elf_backend_relocate_section	     elf32_hppa_relocate_section
#define elf_backend_hide_symbol		     elf32_hppa_hide_symbol
#define elf_backend_finish_dynamic_symbol    elf32_hppa_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections  elf32_hppa_finish_dynamic_sections
#define elf_backend_size_dynamic_sections    elf32_hppa_size_dynamic_sections
#define elf_backend_gc_mark_hook	     elf32_hppa_gc_mark_hook
#define elf_backend_gc_sweep_hook	     elf32_hppa_gc_sweep_hook
#define elf_backend_object_p		     elf32_hppa_object_p
#define elf_backend_final_write_processing   elf_hppa_final_write_processing
#define elf_backend_post_process_headers     elf32_hppa_post_process_headers
#define elf_backend_get_symbol_type	     elf32_hppa_elf_get_symbol_type

#define elf_backend_can_gc_sections	     1
#define elf_backend_plt_alignment	     2
#define elf_backend_want_got_plt	     0
#define elf_backend_plt_readonly	     0
#define elf_backend_want_plt_sym	     0
#define elf_backend_got_header_size	     8

#define TARGET_BIG_SYM		bfd_elf32_hppa_vec
#define TARGET_BIG_NAME		"elf32-hppa"
#define ELF_ARCH		bfd_arch_hppa
#define ELF_MACHINE_CODE	EM_PARISC
#define ELF_MAXPAGESIZE		0x1000

#include "elf32-target.h"

#undef TARGET_BIG_SYM
#define TARGET_BIG_SYM			bfd_elf32_hppa_linux_vec
#undef TARGET_BIG_NAME
#define TARGET_BIG_NAME			"elf32-hppa-linux"
a1328 1
#define INCLUDED_TARGET_FILE 1
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000, 2001,
   2002, 2003 Free Software Foundation, Inc.
d11 1
a11 1
   This file is part of BFD, the Binary File Descriptor library.
d13 13
a25 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d35 1
a36 1
#include "elf-hppa.h"
d74 1
a74 1
   :		bv %r0(%r21)
d81 1
a81 1
   :		bv %r0(%r21)
d114 1
a114 1
   :		be,n 0(%sr0,%rp)		; inter-space return.  */
d117 1
d137 18
a154 6
/* We don't need to copy certain PC- or GP-relative dynamic relocs
   into a shared object's dynamic section.  All the relocs of the
   limited class we are interested in, are absolute.  */
#ifndef RELATIVE_DYNRELOCS
#define RELATIVE_DYNRELOCS 0
#define IS_ABSOLUTE_RELOC(r_type) 1
d174 5
d205 7
d219 2
a220 2
    /* The input section of the reloc.  */
    asection *sec;
d224 2
d227 2
a228 5
#if RELATIVE_DYNRELOCS
  /* Number of relative relocs copied for the input section.  */
    bfd_size_type relative_count;
#endif
  } *dyn_relocs;
d236 4
d245 1
a245 1
  struct elf_link_hash_table elf;
d265 4
a270 6
  /* Assorted information used by elf32_hppa_size_stubs.  */
  unsigned int bfd_count;
  int top_index;
  asection **input_list;
  Elf_Internal_Sym **all_local_syms;

d287 1
a287 1
  /* Flags set when various size branches are detected.  Used to
a290 1
  unsigned int has_22bit_branch:1;
a293 3

  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
a312 3
static void elf32_hppa_link_hash_table_free
  PARAMS ((struct bfd_link_hash_table *));

d332 1
a332 1
static bfd_boolean hppa_build_one_stub
d335 1
a335 1
static bfd_boolean hppa_size_one_stub
d339 1
a339 1
static bfd_boolean elf32_hppa_object_p PARAMS ((bfd *));
d341 1
a341 1
static bfd_boolean elf32_hppa_add_symbol_hook
d345 1
a345 1
static bfd_boolean elf32_hppa_create_dynamic_sections
d348 1
a348 5
static void elf32_hppa_copy_indirect_symbol
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));

static bfd_boolean elf32_hppa_check_relocs
d353 1
a353 1
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
d356 1
a356 1
static bfd_boolean elf32_hppa_gc_sweep_hook
d361 1
a361 1
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean));
d363 1
a363 1
static bfd_boolean elf32_hppa_adjust_dynamic_symbol
d366 1
a366 1
static bfd_boolean mark_PIC_calls
d369 1
a369 1
static bfd_boolean allocate_plt_static
d372 3
a374 1
static bfd_boolean allocate_dynrelocs
d376 1
d378 1
a378 4
static bfd_boolean readonly_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));

static bfd_boolean clobber_millicode_symbols
d381 1
a381 1
static bfd_boolean elf32_hppa_size_dynamic_sections
d384 1
a384 7
static void group_sections
  PARAMS ((struct elf32_hppa_link_hash_table *, bfd_size_type, bfd_boolean));

static int get_local_syms
  PARAMS ((bfd *, bfd *, struct bfd_link_info *));

static bfd_boolean elf32_hppa_final_link
d395 1
a395 1
static bfd_boolean elf32_hppa_relocate_section
d399 4
a402 1
static bfd_boolean elf32_hppa_finish_dynamic_symbol
d406 1
a406 4
static enum elf_reloc_type_class elf32_hppa_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));

static bfd_boolean elf32_hppa_finish_dynamic_sections
d425 4
d431 1
a431 1
  if (entry == NULL)
d433 5
a437 4
      entry = bfd_hash_allocate (table,
				 sizeof (struct elf32_hppa_stub_hash_entry));
      if (entry == NULL)
	return entry;
d441 4
a444 2
  entry = bfd_hash_newfunc (entry, table, string);
  if (entry != NULL)
a445 2
      struct elf32_hppa_stub_hash_entry *eh;

d447 10
a456 8
      eh = (struct elf32_hppa_stub_hash_entry *) entry;
      eh->stub_sec = NULL;
      eh->stub_offset = 0;
      eh->target_value = 0;
      eh->target_section = NULL;
      eh->stub_type = hppa_stub_long_branch;
      eh->h = NULL;
      eh->id_sec = NULL;
d459 1
a459 1
  return entry;
d470 4
d476 1
a476 1
  if (entry == NULL)
d478 5
a482 4
      entry = bfd_hash_allocate (table,
				 sizeof (struct elf32_hppa_link_hash_entry));
      if (entry == NULL)
	return entry;
d486 5
a490 2
  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
  if (entry != NULL)
a491 2
      struct elf32_hppa_link_hash_entry *eh;

d493 11
a503 5
      eh = (struct elf32_hppa_link_hash_entry *) entry;
      eh->stub_cache = NULL;
      eh->dyn_relocs = NULL;
      eh->pic_call = 0;
      eh->plabel = 0;
d506 1
a506 1
  return entry;
a517 1
  bfd_size_type amt = sizeof (*ret);
d519 1
a519 1
  ret = (struct elf32_hppa_link_hash_table *) bfd_malloc (amt);
d523 1
a523 1
  if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd, hppa_link_hash_newfunc))
d525 1
a525 1
      free (ret);
a547 1
  ret->has_22bit_branch = 0;
a548 6
  ret->sym_sec.abfd = NULL;

  return &ret->elf.root;
}

/* Free the derived linker hash table.  */
d550 1
a550 9
static void
elf32_hppa_link_hash_table_free (hash)
     struct bfd_link_hash_table *hash;
{
  struct elf32_hppa_link_hash_table *ret
    = (struct elf32_hppa_link_hash_table *) hash;

  bfd_hash_table_free (&ret->stub_hash_table);
  _bfd_generic_link_hash_table_free (hash);
d563 1
a563 1
  bfd_size_type len;
d597 1
a597 1
hppa_get_stub_entry (input_section, sym_sec, hash, rel, htab)
d602 1
a602 1
     struct elf32_hppa_link_hash_table *htab;
d612 1
a612 1
  id_sec = htab->stub_group[input_section->id].link_sec;
d628 16
a643 4
      stub_entry = hppa_stub_hash_lookup (&htab->stub_hash_table,
					  stub_name, FALSE, FALSE);
      if (hash != NULL)
	hash->stub_cache = stub_entry;
d655 1
a655 1
hppa_add_stub (stub_name, section, htab)
d658 1
a658 1
     struct elf32_hppa_link_hash_table *htab;
d664 2
a665 2
  link_sec = htab->stub_group[section->id].link_sec;
  stub_sec = htab->stub_group[section->id].stub_sec;
d668 1
a668 1
      stub_sec = htab->stub_group[link_sec->id].stub_sec;
d671 1
a671 2
	  size_t namelen;
	  bfd_size_type len;
d674 2
a675 3
	  namelen = strlen (link_sec->name);
	  len = namelen + sizeof (STUB_SUFFIX);
	  s_name = bfd_alloc (htab->stub_bfd, len);
d679 3
a681 3
	  memcpy (s_name, link_sec->name, namelen);
	  memcpy (s_name + namelen, STUB_SUFFIX, sizeof (STUB_SUFFIX));
	  stub_sec = (*htab->add_stub_section) (s_name, link_sec);
d684 1
a684 1
	  htab->stub_group[link_sec->id].stub_sec = stub_sec;
d686 1
a686 1
      htab->stub_group[section->id].stub_sec = stub_sec;
d690 2
a691 2
  stub_entry = hppa_stub_hash_lookup (&htab->stub_hash_table, stub_name,
				      TRUE, FALSE);
d695 1
a695 1
			     bfd_archive_filename (section->owner),
d701 3
d724 15
a738 6
      && hash->elf.plt.offset != (bfd_vma) -1
      && (hash->elf.dynindx != -1 || hash->pic_call)
      && !hash->plabel)
    {
      /* We need an import stub.  Decide between hppa_stub_import
	 and hppa_stub_import_shared later.  */
d768 15
a782 2
    return hppa_stub_long_branch;

a808 1
#define BL22_RP		0xe800a002	/* b,l,n XXX,%rp		*/
d825 1
a825 1
static bfd_boolean
d832 1
a832 1
  struct elf32_hppa_link_hash_table *htab;
d846 1
a846 1
  htab = hppa_link_hash_table (info);
d874 45
d952 3
a954 3
		   + htab->splt->output_offset
		   + htab->splt->output_section->vma
		   - elf_gp (htab->splt->output_section->owner));
d974 1
a974 1
      if (htab->multi_subspace)
d1007 1
a1007 1
	  dynobj = htab->elf.dynobj;
d1024 5
a1028 5
	  bfd_put_32 (htab->splt->owner, value,
		      htab->splt->contents + off);
	  value = elf_gp (htab->splt->output_section->owner);
	  bfd_put_32 (htab->splt->owner, value,
		      htab->splt->contents + off + 4);
d1043 1
a1043 3
      if (sym_value - 8 + (1 << (17 + 1)) >= (1 << (17 + 2))
	  && (!htab->has_22bit_branch
	      || sym_value - 8 + (1 << (22 + 1)) >= (1 << (22 + 2))))
d1047 1
a1047 1
	     bfd_archive_filename (stub_entry->target_section->owner),
d1052 1
a1052 1
	  return FALSE;
d1056 1
a1056 4
      if (!htab->has_22bit_branch)
	insn = hppa_rebuild_insn ((int) BL_RP, val, 17);
      else
	insn = hppa_rebuild_insn ((int) BL22_RP, val, 22);
d1074 1
a1074 1
      return FALSE;
d1078 1
a1078 1
  return TRUE;
d1106 1
a1106 1
static bfd_boolean
d1112 1
a1112 1
  struct elf32_hppa_link_hash_table *htab;
d1117 1
a1117 1
  htab = (struct elf32_hppa_link_hash_table *) in_arg;
d1120 7
a1126 1
    size = 8;
d1133 1
a1133 1
      if (htab->multi_subspace)
d1140 1
a1140 1
  return TRUE;
d1146 1
a1146 1
static bfd_boolean
d1157 1
a1157 1
	return FALSE;
d1162 1
a1162 1
	return FALSE;
d1177 1
a1177 1
  return TRUE;
d1183 1
a1183 1
static bfd_boolean
d1194 1
a1194 1
  return TRUE;
d1200 1
a1200 1
static bfd_boolean
d1205 1
a1205 1
  struct elf32_hppa_link_hash_table *htab;
d1208 3
a1210 3
  htab = hppa_link_hash_table (info);
  if (htab->splt != NULL)
    return TRUE;
d1214 1
a1214 1
    return FALSE;
d1216 2
a1217 2
  htab->splt = bfd_get_section_by_name (abfd, ".plt");
  htab->srelplt = bfd_get_section_by_name (abfd, ".rela.plt");
d1219 4
a1222 4
  htab->sgot = bfd_get_section_by_name (abfd, ".got");
  htab->srelgot = bfd_make_section (abfd, ".rela.got");
  if (htab->srelgot == NULL
      || ! bfd_set_section_flags (abfd, htab->srelgot,
d1229 2
a1230 52
      || ! bfd_set_section_alignment (abfd, htab->srelgot, 2))
    return FALSE;

  htab->sdynbss = bfd_get_section_by_name (abfd, ".dynbss");
  htab->srelbss = bfd_get_section_by_name (abfd, ".rela.bss");

  return TRUE;
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
elf32_hppa_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
     struct elf_link_hash_entry *dir, *ind;
{
  struct elf32_hppa_link_hash_entry *edir, *eind;

  edir = (struct elf32_hppa_link_hash_entry *) dir;
  eind = (struct elf32_hppa_link_hash_entry *) ind;

  if (eind->dyn_relocs != NULL)
    {
      if (edir->dyn_relocs != NULL)
	{
	  struct elf32_hppa_dyn_reloc_entry **pp;
	  struct elf32_hppa_dyn_reloc_entry *p;

	  if (ind->root.type == bfd_link_hash_indirect)
	    abort ();

	  /* Add reloc counts against the weak sym to the strong sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
	    {
	      struct elf32_hppa_dyn_reloc_entry *q;

	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
		if (q->sec == p->sec)
		  {
#if RELATIVE_DYNRELOCS
		    q->relative_count += p->relative_count;
#endif
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->dyn_relocs;
	}
d1232 2
a1233 3
      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
    }
d1235 1
a1235 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d1239 3
a1241 3
   calculate needed space in the global offset table, procedure linkage
   table, and dynamic reloc sections.  At this point we haven't
   necessarily read all the input files.  */
d1243 1
a1243 1
static bfd_boolean
d1250 1
d1253 1
d1256 1
a1256 1
  struct elf32_hppa_link_hash_table *htab;
d1261 1
a1261 1
    return TRUE;
d1263 2
a1264 1
  htab = hppa_link_hash_table (info);
d1267 1
d1278 6
a1283 1
	PLT_PLABEL = 8
d1339 2
a1340 3
	  htab->has_12bit_branch = 1;
	  goto branch_common;

d1343 2
a1344 3
	  htab->has_17bit_branch = 1;
	  goto branch_common;

a1345 2
	  htab->has_22bit_branch = 1;
	branch_common:
d1364 1
a1364 1
	      need_entry = NEED_PLT;
d1366 1
a1366 1
		need_entry = 0;
d1387 1
a1387 1
		 bfd_archive_filename (abfd),
d1390 1
a1390 1
	      return FALSE;
d1399 1
a1399 1
#if 0
d1407 1
a1407 1
		 bfd_archive_filename (abfd),
d1423 1
a1423 1
	    return FALSE;
d1431 1
a1431 1
	    return FALSE;
d1443 4
a1446 1
	  if (htab->sgot == NULL)
d1448 2
a1449 4
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;
	      if (!elf32_hppa_create_dynamic_sections (htab->elf.dynobj, info))
		return FALSE;
d1454 14
a1467 1
	      h->elf.got.refcount += 1;
a1470 2
	      bfd_signed_vma *local_got_refcounts;

a1471 1
	      local_got_refcounts = elf_local_got_refcounts (abfd);
d1474 1
a1474 1
		  bfd_size_type size;
d1480 1
a1480 2
		  size = symtab_hdr->sh_info;
		  size *= 2 * sizeof (bfd_signed_vma);
d1482 1
a1482 1
					 bfd_zalloc (abfd, size));
d1484 1
a1484 1
		    return FALSE;
d1486 1
d1488 4
a1491 1
	      local_got_refcounts[r_symndx] += 1;
d1509 7
a1515 2
		  h->elf.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
		  h->elf.plt.refcount += 1;
d1525 1
a1525 2
		  bfd_signed_vma *local_got_refcounts;
		  bfd_signed_vma *local_plt_refcounts;
a1526 1
		  local_got_refcounts = elf_local_got_refcounts (abfd);
d1529 1
a1529 1
		      bfd_size_type size;
d1533 1
a1533 2
		      size = symtab_hdr->sh_info;
		      size *= 2 * sizeof (bfd_signed_vma);
d1535 1
a1535 1
					     bfd_zalloc (abfd, size));
d1537 1
a1537 1
			return FALSE;
d1539 1
d1541 5
a1545 3
		  local_plt_refcounts = (local_got_refcounts
					 + symtab_hdr->sh_info);
		  local_plt_refcounts[r_symndx] += 1;
d1550 1
a1550 1
      if (need_entry & NEED_DYNREL)
d1555 1
a1555 1
	  if (h != NULL && !info->shared)
d1568 1
a1568 1
	     storing information in the dyn_relocs field of the
d1580 14
a1593 1
	     reloc in the branch.
d1595 3
a1597 21
	     If on the other hand, we are creating an executable, we
	     may need to keep relocations for symbols satisfied by a
	     dynamic library if we manage to avoid copy relocs for the
	     symbol.  */
	  if ((info->shared
	       && (sec->flags & SEC_ALLOC) != 0
	       && (IS_ABSOLUTE_RELOC (r_type)
		   || (h != NULL
		       && (!info->symbolic
			   || h->elf.root.type == bfd_link_hash_defweak
			   || (h->elf.elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
	      || (!info->shared
		  && (sec->flags & SEC_ALLOC) != 0
		  && h != NULL
		  && (h->elf.root.type == bfd_link_hash_defweak
		      || (h->elf.elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)))
	    {
	      struct elf32_hppa_dyn_reloc_entry *p;
	      struct elf32_hppa_dyn_reloc_entry **head;
d1601 1
a1601 1
	      if (sreloc == NULL)
a1603 1
		  bfd *dynobj;
d1605 7
a1611 4
		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
d1618 1
a1618 1
		      return FALSE;
d1621 12
a1632 2
		  if (htab->elf.dynobj == NULL)
		    htab->elf.dynobj = abfd;
d1634 2
a1635 3
		  dynobj = htab->elf.dynobj;
		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
d1639 1
a1639 1
		      sreloc = bfd_make_section (dynobj, name);
d1644 4
a1647 4
		      if (sreloc == NULL
			  || !bfd_set_section_flags (dynobj, sreloc, flags)
			  || !bfd_set_section_alignment (dynobj, sreloc, 2))
			return FALSE;
d1649 2
d1652 4
a1655 1
		  elf_section_data (sec)->sreloc = sreloc;
d1658 8
a1665 3
	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (h != NULL)
d1667 2
a1668 1
		  head = &h->dyn_relocs;
d1671 4
d1676 14
a1689 9
		  /* Track dynamic relocs needed for local syms too.
		     We really need local syms available to do this
		     easily.  Oh well.  */

		  asection *s;
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
		  if (s == NULL)
		    return FALSE;
d1691 15
a1705 3
		  head = ((struct elf32_hppa_dyn_reloc_entry **)
			  &elf_section_data (s)->local_dynrel);
		}
d1707 8
a1714 14
	      p = *head;
	      if (p == NULL || p->sec != sec)
		{
		  p = ((struct elf32_hppa_dyn_reloc_entry *)
		       bfd_alloc (htab->elf.dynobj,
				  (bfd_size_type) sizeof *p));
		  if (p == NULL)
		    return FALSE;
		  p->next = *head;
		  *head = p;
		  p->sec = sec;
		  p->count = 0;
#if RELATIVE_DYNRELOCS
		  p->relative_count = 0;
a1716 6

	      p->count += 1;
#if RELATIVE_DYNRELOCS
	      if (!IS_ABSOLUTE_RELOC (rtype))
		p->relative_count += 1;
#endif
d1721 1
a1721 1
  return TRUE;
d1728 2
a1729 2
elf32_hppa_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
d1759 9
a1767 1
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d1775 1
a1775 1
static bfd_boolean
d1787 4
a1790 2

  elf_section_data (sec)->local_dynrel = NULL;
d1798 4
d1805 18
a1822 4
    {
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h = NULL;
d1824 12
a1835 6
      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct elf32_hppa_link_hash_entry *eh;
	  struct elf32_hppa_dyn_reloc_entry **pp;
	  struct elf32_hppa_dyn_reloc_entry *p;
d1837 16
a1852 2
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  eh = (struct elf32_hppa_link_hash_entry *) h;
d1854 3
a1856 57
	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}

      r_type = ELF32_R_TYPE (rel->r_info);
      switch (r_type)
	{
	case R_PARISC_DLTIND14F:
	case R_PARISC_DLTIND14R:
	case R_PARISC_DLTIND21L:
	  if (h != NULL)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;

	case R_PARISC_PCREL12F:
	case R_PARISC_PCREL17C:
	case R_PARISC_PCREL17F:
	case R_PARISC_PCREL22F:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  break;

	case R_PARISC_PLABEL14R:
	case R_PARISC_PLABEL21L:
	case R_PARISC_PLABEL32:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  else if (local_plt_refcounts != NULL)
	    {
	      if (local_plt_refcounts[r_symndx] > 0)
		local_plt_refcounts[r_symndx] -= 1;
	    }
	  break;

	default:
	  break;
	}
    }
d1858 1
a1858 1
  return TRUE;
d1865 2
a1866 2
elf32_hppa_hide_symbol (info, h, force_local)
     struct bfd_link_info *info;
a1867 1
     bfd_boolean force_local;
d1869 2
a1870 11
  if (force_local)
    {
      h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
      if (h->dynindx != -1)
	{
	  h->dynindx = -1;
	  _bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
				  h->dynstr_index);
	}
    }

d1895 1
a1895 1
static bfd_boolean
d1900 2
a1901 3
  struct elf32_hppa_link_hash_table *htab;
  struct elf32_hppa_link_hash_entry *eh;
  struct elf32_hppa_dyn_reloc_entry *p;
d1903 3
a1905 1
  unsigned int power_of_two;
d1908 2
a1909 1
     will fill in the contents of the procedure linkage table later.  */
d1913 8
d1937 1
a1937 4
	  if (!info->shared
	      && h->plt.refcount > 0
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	      && (h->root.u.def.section->flags & SEC_HAS_GOT_REF) != 0)
d1943 12
d1958 1
a1958 1
      return TRUE;
a1959 2
  else
    h->plt.offset = (bfd_vma) -1;
d1971 1
a1971 1
      return TRUE;
d1982 1
a1982 1
    return TRUE;
d1987 1
a1987 17
    return TRUE;

  eh = (struct elf32_hppa_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      s = p->sec->output_section;
      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	break;
    }

  /* If we didn't find any dynamic relocs in read-only sections, then
     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
  if (p == NULL)
    {
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
      return TRUE;
    }
d1999 1
a1999 1
  htab = hppa_link_hash_table (info);
d2003 2
a2004 1
     runtime process image.  */
d2007 4
a2010 1
      htab->srelbss->_raw_size += sizeof (Elf32_External_Rela);
d2014 18
a2031 17
  /* We need to figure out the alignment required for this symbol.  I
     have no idea how other ELF linkers handle this.  */

  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 3)
    power_of_two = 3;

  /* Apply the required alignment.  */
  s = htab->sdynbss;
  s->_raw_size = BFD_ALIGN (s->_raw_size,
			    (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (htab->elf.dynobj, s))
    {
      if (! bfd_set_section_alignment (htab->elf.dynobj, s, power_of_two))
	return FALSE;
    }

d2039 1
a2039 1
  return TRUE;
d2046 2
a2047 2
static bfd_boolean
mark_PIC_calls (h, inf)
a2050 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

d2058 1
a2058 1
      return TRUE;
d2062 1
d2065 1
a2065 1
  return TRUE;
d2068 2
a2069 2
/* Allocate space in the .plt for entries that won't have relocations.
   ie. pic_call and plabel entries.  */
d2071 2
a2072 2
static bfd_boolean
allocate_plt_static (h, inf)
d2077 1
a2077 1
  struct elf32_hppa_link_hash_table *htab;
d2080 3
a2082 5
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d2085 4
a2088 2
  htab = hppa_link_hash_table (info);
  if (((struct elf32_hppa_link_hash_entry *) h)->pic_call)
d2090 2
a2091 4
      /* Make an entry in the .plt section for non-pic code that is
	 calling pic code.  */
      ((struct elf32_hppa_link_hash_entry *) h)->plabel = 0;
      s = htab->splt;
d2093 6
a2098 13
      s->_raw_size += PLT_ENTRY_SIZE;
    }
  else if (htab->elf.dynamic_sections_created
	   && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0
	  && h->type != STT_PARISC_MILLI)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return FALSE;
d2100 2
d2103 2
a2104 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d2106 3
a2108 19
	  /* Allocate these later.  From this point on, h->plabel
	     means that the plt entry is only used by a plabel.
	     We'll be using a normal plt entry for this symbol, so
	     clear the plabel indicator.  */
	  ((struct elf32_hppa_link_hash_entry *) h)->plabel = 0;
	}
      else if (((struct elf32_hppa_link_hash_entry *) h)->plabel)
	{
	  /* Make an entry in the .plt section for plabel references
	     that won't have a .plt entry for other reasons.  */
	  s = htab->splt;
	  h->plt.offset = s->_raw_size;
	  s->_raw_size += PLT_ENTRY_SIZE;
	}
      else
	{
	  /* No .plt entry needed.  */
	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
a2116 40
  return TRUE;
}

/* Allocate space in .plt, .got and associated reloc sections for
   global syms.  */

static bfd_boolean
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct bfd_link_info *info;
  struct elf32_hppa_link_hash_table *htab;
  asection *s;
  struct elf32_hppa_link_hash_entry *eh;
  struct elf32_hppa_dyn_reloc_entry *p;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  info = (struct bfd_link_info *) inf;
  htab = hppa_link_hash_table (info);
  if (htab->elf.dynamic_sections_created
      && h->plt.offset != (bfd_vma) -1
      && !((struct elf32_hppa_link_hash_entry *) h)->pic_call
      && !((struct elf32_hppa_link_hash_entry *) h)->plabel)
    {
      /* Make an entry in the .plt section.  */
      s = htab->splt;
      h->plt.offset = s->_raw_size;
      s->_raw_size += PLT_ENTRY_SIZE;

      /* We also need to make an entry in the .rela.plt section.  */
      htab->srelplt->_raw_size += sizeof (Elf32_External_Rela);
      htab->need_plt_stub = 1;
    }

d2119 1
a2119 9
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0
	  && h->type != STT_PARISC_MILLI)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}
d2121 1
a2121 1
      s = htab->sgot;
d2124 3
a2126 7
      if (htab->elf.dynamic_sections_created
	  && (info->shared
	      || (h->dynindx != -1
		  && h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0))
	{
	  htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
	}
d2131 2
a2132 3
  eh = (struct elf32_hppa_link_hash_entry *) h;
  if (eh->dyn_relocs == NULL)
    return TRUE;
d2134 4
a2137 47
  /* If this is a -Bsymbolic shared link, then we need to discard all
     space allocated for dynamic pc-relative relocs against symbols
     defined in a regular object.  For the normal shared case, discard
     space for relocs that have become local due to symbol visibility
     changes.  */
  if (info->shared)
    {
#if RELATIVE_DYNRELOCS
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
	      || info->symbolic))
	{
	  struct elf32_hppa_dyn_reloc_entry **pp;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      p->count -= p->relative_count;
	      p->relative_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}
#endif
    }
  else
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */
      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
	  && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	      || (htab->elf.dynamic_sections_created
		  && (h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined))))
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0
	      && h->type != STT_PARISC_MILLI)
	    {
	      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }
d2139 8
a2146 5
	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}
d2148 2
a2149 2
      eh->dyn_relocs = NULL;
      return TRUE;
d2151 12
a2162 1
    keep: ;
d2164 1
d2166 8
a2173 2
  /* Finally, allocate space.  */
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
d2175 2
a2176 2
      asection *sreloc = elf_section_data (p->sec)->sreloc;
      sreloc->_raw_size += p->count * sizeof (Elf32_External_Rela);
d2178 1
d2180 1
a2180 1
  return TRUE;
d2182 1
d2191 1
a2191 1
static bfd_boolean
d2196 3
a2198 5
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->type == STT_PARISC_MILLI
      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d2200 5
a2204 1
      elf32_hppa_hide_symbol (info, h, TRUE);
d2206 1
a2206 32
  return TRUE;
}

/* Find any dynamic relocs that apply to read-only sections.  */

static bfd_boolean
readonly_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct elf32_hppa_link_hash_entry *eh;
  struct elf32_hppa_dyn_reloc_entry *p;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  eh = (struct elf32_hppa_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *s = p->sec->output_section;

      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	{
	  struct bfd_link_info *info = (struct bfd_link_info *) inf;

	  info->flags |= DF_TEXTREL;

	  /* Not an error, just cut short the traversal.  */
	  return FALSE;
	}
    }
  return TRUE;
d2211 1
a2211 1
static bfd_boolean
d2213 1
a2213 1
     bfd *output_bfd ATTRIBUTE_UNUSED;
d2216 1
a2216 1
  struct elf32_hppa_link_hash_table *htab;
a2217 1
  bfd *ibfd;
d2219 2
a2220 1
  bfd_boolean relocs;
d2222 2
a2223 2
  htab = hppa_link_hash_table (info);
  dynobj = htab->elf.dynobj;
d2227 1
a2227 1
  if (htab->elf.dynamic_sections_created)
d2229 2
d2242 1
a2242 1
      elf_link_hash_traverse (&htab->elf,
a2244 9
    }
  else
    {
      /* Run through the function symbols, looking for any that are
	 PIC, and mark them as needing .plt entries so that %r19 will
	 be set up.  */
      if (! info->shared)
	elf_link_hash_traverse (&htab->elf, mark_PIC_calls, (PTR) info);
    }
d2246 10
a2255 11
  /* Set up .got and .plt offsets for local syms, and space for local
     dynamic relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      bfd_signed_vma *local_plt;
      bfd_signed_vma *end_local_plt;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;
d2257 2
a2258 2
      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
	continue;
d2260 3
a2262 3
      for (s = ibfd->sections; s != NULL; s = s->next)
	{
	  struct elf32_hppa_dyn_reloc_entry *p;
d2264 6
a2269 4
	  for (p = ((struct elf32_hppa_dyn_reloc_entry *)
		    elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
d2271 1
a2271 2
	      if (!bfd_is_abs_section (p->sec)
		  && bfd_is_abs_section (p->sec->output_section))
d2273 4
a2276 4
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
d2278 2
a2279 27
	      else if (p->count != 0)
		{
		  srel = elf_section_data (p->sec)->sreloc;
		  srel->_raw_size += p->count * sizeof (Elf32_External_Rela);
		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
		    info->flags |= DF_TEXTREL;
		}
	    }
	}

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      s = htab->sgot;
      srel = htab->srelgot;
      for (; local_got < end_local_got; ++local_got)
	{
	  if (*local_got > 0)
	    {
	      *local_got = s->_raw_size;
	      s->_raw_size += GOT_ENTRY_SIZE;
	      if (info->shared)
		srel->_raw_size += sizeof (Elf32_External_Rela);
a2280 3
	  else
	    *local_got = (bfd_vma) -1;
	}
d2282 4
a2285 12
      local_plt = end_local_got;
      end_local_plt = local_plt + locsymcount;
      if (! htab->elf.dynamic_sections_created)
	{
	  /* Won't be used, but be safe.  */
	  for (; local_plt < end_local_plt; ++local_plt)
	    *local_plt = (bfd_vma) -1;
	}
      else
	{
	  s = htab->splt;
	  srel = htab->srelplt;
d2300 10
d2311 16
a2326 8
  /* Do all the .plt entries without relocs first.  The dynamic linker
     uses the last .plt reloc to find the end of the .plt (and hence
     the start of the .got) for lazy linking.  */
  elf_link_hash_traverse (&htab->elf, allocate_plt_static, (PTR) info);

  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, (PTR) info);
d2331 2
a2332 1
  relocs = FALSE;
d2335 2
d2340 5
a2344 1
      if (s == htab->splt)
d2346 28
a2373 1
	  if (htab->need_plt_stub)
d2378 1
a2378 1
	      int gotalign = bfd_section_alignment (dynobj, htab->sgot);
d2388 1
a2388 1
      else if (s == htab->sgot)
a2389 14
      else if (strncmp (bfd_get_section_name (dynobj, s), ".rela", 5) == 0)
	{
	  if (s->_raw_size != 0)
	    {
	      /* Remember whether there are any reloc sections other
		 than .rela.plt.  */
	      if (s != htab->srelplt)
		relocs = TRUE;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
d2415 1
a2415 1
	return FALSE;
d2418 1
a2418 1
  if (htab->elf.dynamic_sections_created)
d2424 2
a2425 5
#define add_dynamic_entry(TAG, VAL) \
  bfd_elf32_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))

      if (!add_dynamic_entry (DT_PLTGOT, 0))
	return FALSE;
d2432 1
a2432 1
      if (!info->shared)
d2434 2
a2435 2
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
d2438 1
a2438 1
      if (htab->srelplt->_raw_size != 0)
d2440 4
a2443 4
	  if (!add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
d2448 6
a2453 4
	  if (!add_dynamic_entry (DT_RELA, 0)
	      || !add_dynamic_entry (DT_RELASZ, 0)
	      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))
	    return FALSE;
d2455 5
a2459 11
	  /* If any dynamic relocs apply to a read-only section,
	     then we need a DT_TEXTREL entry.  */
	  if ((info->flags & DF_TEXTREL) == 0)
	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs,
				    (PTR) info);

	  if ((info->flags & DF_TEXTREL) != 0)
	    {
	      if (!add_dynamic_entry (DT_TEXTREL, 0))
		return FALSE;
	    }
a2461 1
#undef add_dynamic_entry
d2463 1
a2463 1
  return TRUE;
d2468 1
a2468 3
/* Set up various things so that we can make a list of input sections
   for each output section included in the link.  Returns -1 on error,
   0 when no stubs will be needed, and 1 on success.  */
d2470 7
a2476 2
int
elf32_hppa_setup_section_lists (output_bfd, info)
d2478 1
d2480 4
a2485 2
  unsigned int bfd_count;
  int top_id, top_index;
d2488 8
a2495 2
  bfd_size_type amt;
  struct elf32_hppa_link_hash_table *htab = hppa_link_hash_table (info);
d2497 21
a2517 2
  if (htab->elf.root.creator->flavour != bfd_target_elf_flavour)
    return 0;
a2532 1
  htab->bfd_count = bfd_count;
d2534 7
a2540 4
  amt = sizeof (struct map_stub) * (top_id + 1);
  htab->stub_group = (struct map_stub *) bfd_zmalloc (amt);
  if (htab->stub_group == NULL)
    return -1;
d2542 1
a2542 1
  /* We can't use output_bfd->section_count here to find the top output
d2553 2
a2554 4
  htab->top_index = top_index;
  amt = sizeof (asection *) * (top_index + 1);
  input_list = (asection **) bfd_malloc (amt);
  htab->input_list = input_list;
d2556 1
a2556 1
    return -1;
d2573 4
a2576 16
  return 1;
}

/* The linker repeatedly calls this function for each input section,
   in the order that input sections are linked into output sections.
   Build lists of input sections to determine groupings between which
   we may insert linker stubs.  */

void
elf32_hppa_next_input_section (info, isec)
     struct bfd_link_info *info;
     asection *isec;
{
  struct elf32_hppa_link_hash_table *htab = hppa_link_hash_table (info);

  if (isec->output_section->index <= htab->top_index)
d2578 3
a2580 2
      asection **list = htab->input_list + isec->output_section->index;
      if (*list != bfd_abs_section_ptr)
d2582 15
a2596 6
	  /* Steal the link_sec pointer for our list.  */
#define PREV_SEC(sec) (htab->stub_group[(sec)->id].link_sec)
	  /* This happens to make the list in reverse order,
	     which is what we want.  */
	  PREV_SEC (isec) = *list;
	  *list = isec;
a2598 1
}
d2600 7
a2606 14
/* See whether we can group stub sections together.  Grouping stub
   sections may result in fewer stubs.  More importantly, we need to
   put all .init* and .fini* stubs at the beginning of the .init or
   .fini output sections respectively, because glibc splits the
   _init and _fini functions into multiple parts.  Putting a stub in
   the middle of a function is not a good idea.  */

static void
group_sections (htab, stub_group_size, stubs_always_before_branch)
     struct elf32_hppa_link_hash_table *htab;
     bfd_size_type stub_group_size;
     bfd_boolean stubs_always_before_branch;
{
  asection **list = htab->input_list + htab->top_index;
a2616 1
	  bfd_boolean big_sec;
a2622 2
	  big_sec = total >= stub_group_size;

d2629 1
a2629 1
	     than 240000 bytes and thus can be handled by one stub
d2631 1
a2631 1
	     240000 bytes, in which case we may be toast.)
d2635 4
a2638 6
	     only break if stubs added total more than 22144 bytes, or
	     2768 long branch stubs.  It seems unlikely for more than
	     2768 different functions to be called, especially from
	     code only 240000 bytes long.  This limit used to be
	     250000, but c++ code tends to generate lots of little
	     functions, and sometimes violated the assumption.  */
d2643 1
a2643 1
	      htab->stub_group[tail->id].link_sec = curr;
d2647 3
a2649 6
	  /* But wait, there's more!  Input sections up to 240000
	     bytes before the stub section can be handled by it too.
	     Don't do this if we have a really large section after the
	     stubs, as adding more stubs increases the chance that
	     branches may not reach into the stub section.  */
	  if (!stubs_always_before_branch && !big_sec)
d2658 1
a2658 1
		  htab->stub_group[tail->id].link_sec = curr;
d2664 2
a2665 2
  while (list-- != htab->input_list);
  free (htab->input_list);
a2666 16
}

/* Read in all local syms for all input bfds, and create hash entries
   for export stubs if we are building a multi-subspace shared lib.
   Returns -1 on error, 1 if export stubs created, 0 otherwise.  */

static int
get_local_syms (output_bfd, input_bfd, info)
     bfd *output_bfd;
     bfd *input_bfd;
     struct bfd_link_info *info;
{
  unsigned int bfd_indx;
  Elf_Internal_Sym *local_syms, **all_local_syms;
  int stub_changed = 0;
  struct elf32_hppa_link_hash_table *htab = hppa_link_hash_table (info);
d2671 3
a2673 3
  bfd_size_type amt = sizeof (Elf_Internal_Sym *) * htab->bfd_count;
  all_local_syms = (Elf_Internal_Sym **) bfd_zmalloc (amt);
  htab->all_local_syms = all_local_syms;
d2675 1
a2675 1
    return -1;
d2680 1
a2680 1
  for (bfd_indx = 0;
d2685 2
d2693 4
a2696 2
      /* We need an array of the local symbols attached to the input bfd.  */
      local_syms = (Elf_Internal_Sym *) symtab_hdr->contents;
d2699 1
a2699 5
	  local_syms = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
					     symtab_hdr->sh_info, 0,
					     NULL, NULL, NULL);
	  /* Cache them for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) local_syms;
d2701 36
a2736 2
      if (local_syms == NULL)
	return -1;
d2738 11
a2748 1
      all_local_syms[bfd_indx] = local_syms;
d2750 1
a2750 1
      if (info->shared && htab->multi_subspace)
d2794 1
a2794 1
		  stub_entry = hppa_stub_hash_lookup (&htab->stub_hash_table,
d2796 1
a2796 1
						      FALSE, FALSE);
d2799 1
a2799 1
		      stub_entry = hppa_add_stub (stub_name, sec, htab);
d2801 1
a2801 1
			return -1;
d2812 2
a2813 2
					     bfd_archive_filename (input_bfd),
					     stub_name);
a2819 74
  return stub_changed;
}

/* Determine and set the size of the stub section for a final link.

   The basic idea here is to examine all the relocations looking for
   PC-relative calls to a target that is unreachable with a "bl"
   instruction.  */

bfd_boolean
elf32_hppa_size_stubs (output_bfd, stub_bfd, info, multi_subspace, group_size,
		       add_stub_section, layout_sections_again)
     bfd *output_bfd;
     bfd *stub_bfd;
     struct bfd_link_info *info;
     bfd_boolean multi_subspace;
     bfd_signed_vma group_size;
     asection * (*add_stub_section) PARAMS ((const char *, asection *));
     void (*layout_sections_again) PARAMS ((void));
{
  bfd_size_type stub_group_size;
  bfd_boolean stubs_always_before_branch;
  bfd_boolean stub_changed;
  struct elf32_hppa_link_hash_table *htab = hppa_link_hash_table (info);

  /* Stash our params away.  */
  htab->stub_bfd = stub_bfd;
  htab->multi_subspace = multi_subspace;
  htab->add_stub_section = add_stub_section;
  htab->layout_sections_again = layout_sections_again;
  stubs_always_before_branch = group_size < 0;
  if (group_size < 0)
    stub_group_size = -group_size;
  else
    stub_group_size = group_size;
  if (stub_group_size == 1)
    {
      /* Default values.  */
      if (stubs_always_before_branch)
	{
	  stub_group_size = 7680000;
	  if (htab->has_17bit_branch || htab->multi_subspace)
	    stub_group_size = 240000;
	  if (htab->has_12bit_branch)
	    stub_group_size = 7500;
	}
      else
	{
	  stub_group_size = 6971392;
	  if (htab->has_17bit_branch || htab->multi_subspace)
	    stub_group_size = 217856;
	  if (htab->has_12bit_branch)
	    stub_group_size = 6808;
	}
    }

  group_sections (htab, stub_group_size, stubs_always_before_branch);

  switch (get_local_syms (output_bfd, info->input_bfds, info))
    {
    default:
      if (htab->all_local_syms)
	goto error_ret_free_local;
      return FALSE;

    case 0:
      stub_changed = FALSE;
      break;

    case 1:
      stub_changed = TRUE;
      break;
    }

a2821 2
      bfd *input_bfd;
      unsigned int bfd_indx;
a2828 2
	  asection *section;
	  Elf_Internal_Sym *local_syms;
d2835 1
a2835 1
	  local_syms = htab->all_local_syms[bfd_indx];
d2842 2
d2858 14
a2871 5
	      /* Get the relocs.  */
	      internal_relocs
		= _bfd_elf32_link_read_relocs (input_bfd, section, NULL,
					       (Elf_Internal_Rela *) NULL,
					       info->keep_memory);
d2873 27
a2899 1
		goto error_ret_free_local;
d2922 1
a2922 4
		    error_ret_free_internal:
		      if (elf_section_data (section)->relocs == NULL)
			free (internal_relocs);
		      goto error_ret_free_local;
d2986 1
a2986 2
				     == STV_DEFAULT)
				 && hash->elf.type != STT_PARISC_MILLI))
d3003 1
a3003 1
		  id_sec = htab->stub_group[section->id].link_sec;
d3010 1
a3010 1
		  stub_entry = hppa_stub_hash_lookup (&htab->stub_hash_table,
d3012 1
a3012 1
						      FALSE, FALSE);
d3020 1
a3020 1
		  stub_entry = hppa_add_stub (stub_name, section, htab);
d3024 1
a3024 1
		      goto error_ret_free_internal;
d3034 2
a3035 1
		      else if (stub_type == hppa_stub_long_branch)
d3039 1
a3039 1
		  stub_changed = TRUE;
d3043 1
a3043 2
	      if (elf_section_data (section)->relocs == NULL)
		free (internal_relocs);
d3052 1
a3052 1
      for (stub_sec = htab->stub_bfd->sections;
d3059 16
d3076 3
a3078 1
      bfd_hash_traverse (&htab->stub_hash_table, hppa_size_one_stub, htab);
d3081 2
a3082 2
      (*htab->layout_sections_again) ();
      stub_changed = FALSE;
d3085 1
a3085 2
  free (htab->all_local_syms);
  return TRUE;
d3088 6
a3093 2
  free (htab->all_local_syms);
  return FALSE;
d3099 1
a3099 1
bfd_boolean
d3104 8
a3111 7
  struct bfd_link_hash_entry *h;
  asection *sec = NULL;
  bfd_vma gp_val = 0;
  struct elf32_hppa_link_hash_table *htab;

  htab = hppa_link_hash_table (info);
  h = bfd_link_hash_lookup (&htab->elf.root, "$global$", FALSE, FALSE, FALSE);
d3114 2
a3115 2
      && (h->type == bfd_link_hash_defined
	  || h->type == bfd_link_hash_defweak))
d3117 2
a3118 2
      gp_val = h->u.def.value;
      sec = h->u.def.section;
a3121 16
      asection *splt;
      asection *sgot;

      if (htab->elf.root.creator->flavour == bfd_target_elf_flavour)
	{
	  splt = htab->splt;
	  sgot = htab->sgot;
	}
      else
	{
	  /* If we're not elf, look up the output sections in the
	     hope we may actually find them.  */
	  splt = bfd_get_section_by_name (abfd, ".plt");
	  sgot = bfd_get_section_by_name (abfd, ".got");
	}

d3130 2
a3131 1
      sec = splt;
d3135 2
a3136 1
	  if (gp_val > 0x2000 || (sgot && sgot->_raw_size > 0x2000))
d3143 2
a3144 1
	  sec = sgot;
d3161 2
a3162 2
	  h->type = bfd_link_hash_defined;
	  h->u.def.value = gp_val;
d3164 1
a3164 1
	    h->u.def.section = sec;
d3166 1
a3166 1
	    h->u.def.section = bfd_abs_section_ptr;
d3174 1
a3174 1
  return TRUE;
d3183 1
a3183 1
bfd_boolean
d3189 1
a3189 1
  struct elf32_hppa_link_hash_table *htab;
d3191 1
a3191 1
  htab = hppa_link_hash_table (info);
d3193 1
a3193 1
  for (stub_sec = htab->stub_bfd->sections;
d3197 1
a3197 1
      bfd_size_type size;
d3201 2
a3202 1
      stub_sec->contents = (unsigned char *) bfd_zalloc (htab->stub_bfd, size);
d3204 1
a3204 1
	return FALSE;
d3209 1
a3209 1
  table = &htab->stub_hash_table;
d3212 1
a3212 1
  return TRUE;
d3217 1
a3217 1
static bfd_boolean
d3222 2
d3226 1
a3226 1
    return FALSE;
d3229 24
a3252 2
     unwind section.  */
  return elf_hppa_sort_unwind (abfd);
d3263 1
a3263 1
  struct elf32_hppa_link_hash_table *htab;
d3265 1
a3265 1
  htab = (struct elf32_hppa_link_hash_table *) data;
d3273 2
a3274 2
	  if (value < htab->text_segment_base)
	    htab->text_segment_base = value;
d3278 2
a3279 2
	  if (value < htab->data_segment_base)
	    htab->data_segment_base = value;
d3287 1
a3287 1
final_link_relocate (input_section, contents, rel, value, htab, sym_sec, h)
d3292 1
a3292 1
     struct elf32_hppa_link_hash_table *htab;
d3325 5
a3329 2
      /* If this call should go via the plt, find the import stub in
	 the stub hash.  */
d3333 5
a3337 3
	      && h->elf.plt.offset != (bfd_vma) -1
	      && (h->elf.dynindx != -1 || h->pic_call)
	      && !h->plabel))
d3340 1
a3340 1
					    h, rel, htab);
d3360 1
a3360 1
	    return bfd_reloc_undefined;
d3378 4
a3381 5
       section.  If it has no section or if it's a code section, then
       "data pointer relative" makes no sense.  In that case we don't
       adjust the "value", and for 21 bit addil instructions, we change the
       source addend register from %dp to %r0.  This situation commonly
       arises for undefined weak symbols and when a variable's "constness"
d3384 3
a3386 1
      if (sym_sec == NULL || (sym_sec->flags & SEC_CODE) != 0)
d3392 1
a3392 1
#if 0 /* debug them.  */
d3395 1
a3395 1
		 bfd_archive_filename (input_bfd),
d3415 1
a3415 1
	value -= htab->text_segment_base;
d3417 1
a3417 1
	value -= htab->data_segment_base;
d3439 1
a3439 1
    case R_PARISC_DLTIND21L:
d3441 1
d3443 1
a3443 5
      r_field = e_lsel;
      break;

    case R_PARISC_DIR21L:
    case R_PARISC_DPREL21L:
d3447 1
d3449 1
d3451 1
a3453 6
      r_field = e_rsel;
      break;

    case R_PARISC_DIR17R:
    case R_PARISC_DIR14R:
    case R_PARISC_DPREL14R:
d3486 1
a3486 1
					    h, rel, htab);
d3488 1
a3488 1
	    return bfd_reloc_undefined;
d3511 1
a3511 1
	 bfd_archive_filename (input_bfd),
a3514 1
      bfd_set_error (bfd_error_bad_value);
d3549 1
a3549 1
static bfd_boolean
d3561 1
d3563 1
a3563 1
  struct elf32_hppa_link_hash_table *htab;
d3567 1
a3567 3

  if (info->relocateable)
    return TRUE;
d3571 2
a3572 1
  htab = hppa_link_hash_table (info);
d3574 1
d3589 1
a3589 2
      bfd_boolean plabel;
      bfd_boolean warned_undef;
d3595 1
a3595 1
	  return FALSE;
d3601 20
a3621 1
      r_symndx = ELF32_R_SYM (rel->r_info);
a3624 1
      warned_undef = FALSE;
d3630 4
a3633 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sym_sec, rel);
d3661 1
a3661 2
	  else if (info->shared
		   && !info->no_undefined
d3664 7
a3670 1
	    ;
d3675 2
a3676 3
		     input_section, rel->r_offset, TRUE)))
		return FALSE;
	      warned_undef = TRUE;
d3689 35
a3723 3
	  {
	    bfd_vma off;
	    bfd_boolean do_got = 0;
d3725 6
a3730 5
	    /* Relocation is to the entry for this symbol in the
	       global offset table.  */
	    if (h != NULL)
	      {
		bfd_boolean dyn;
d3732 3
a3734 38
		off = h->elf.got.offset;
		dyn = htab->elf.dynamic_sections_created;
		if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, &h->elf))
		  {
		    /* If we aren't going to call finish_dynamic_symbol,
		       then we need to handle initialisation of the .got
		       entry and create needed relocs here.  Since the
		       offset must always be a multiple of 4, we use the
		       least significant bit to record whether we have
		       initialised it already.  */
		    if ((off & 1) != 0)
		      off &= ~1;
		    else
		      {
			h->elf.got.offset |= 1;
			do_got = 1;
		      }
		  }
	      }
	    else
	      {
		/* Local symbol case.  */
		if (local_got_offsets == NULL)
		  abort ();

		off = local_got_offsets[r_symndx];

		/* The offset must always be a multiple of 4.  We use
		   the least significant bit to record whether we have
		   already generated the necessary reloc.  */
		if ((off & 1) != 0)
		  off &= ~1;
		else
		  {
		    local_got_offsets[r_symndx] |= 1;
		    do_got = 1;
		  }
	      }
d3736 7
a3742 21
	    if (do_got)
	      {
		if (info->shared)
		  {
		    /* Output a dynamic relocation for this GOT entry.
		       In this case it is relative to the base of the
		       object because the symbol index is zero.  */
		    Elf_Internal_Rela outrel;
		    bfd_byte *loc;
		    asection *s = htab->srelgot;

		    outrel.r_offset = (off
				       + htab->sgot->output_offset
				       + htab->sgot->output_section->vma);
		    outrel.r_info = ELF32_R_INFO (0, R_PARISC_DIR32);
		    outrel.r_addend = relocation;
		    loc = s->contents;
		    loc += s->reloc_count++ * sizeof (Elf32_External_Rela);
		    bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		  }
		else
d3744 25
a3768 2
			      htab->sgot->contents + off);
	      }
d3770 2
a3771 2
	    if (off >= (bfd_vma) -2)
	      abort ();
d3773 3
a3775 5
	    /* Add the base of the GOT to the relocation value.  */
	    relocation = (off
			  + htab->sgot->output_offset
			  + htab->sgot->output_section->vma);
	  }
d3781 4
a3784 2
	  if (htab->text_segment_base == (bfd_vma) -1)
	    bfd_map_over_sections (output_bfd, hppa_record_segment_addr, htab);
d3790 1
a3790 1
	  if (htab->elf.dynamic_sections_created)
a3792 1
	      bfd_boolean do_plt = 0;
d3803 1
a3803 1
			 need to write out the plt entry here.  */
d3808 6
a3814 1
			  do_plt = 1;
d3820 1
a3820 1
		  bfd_vma *local_plt_offsets;
d3822 2
a3823 5
		  if (local_got_offsets == NULL)
		    abort ();

		  local_plt_offsets = local_got_offsets + symtab_hdr->sh_info;
		  off = local_plt_offsets[r_symndx];
a3831 26
		      local_plt_offsets[r_symndx] |= 1;
		      do_plt = 1;
		    }
		}

	      if (do_plt)
		{
		  if (info->shared)
		    {
		      /* Output a dynamic IPLT relocation for this
			 PLT entry.  */
		      Elf_Internal_Rela outrel;
		      bfd_byte *loc;
		      asection *s = htab->srelplt;

		      outrel.r_offset = (off
					 + htab->splt->output_offset
					 + htab->splt->output_section->vma);
		      outrel.r_info = ELF32_R_INFO (0, R_PARISC_IPLT);
		      outrel.r_addend = relocation;
		      loc = s->contents;
		      loc += s->reloc_count++ * sizeof (Elf32_External_Rela);
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		    }
		  else
		    {
d3834 1
a3834 1
				  htab->splt->contents + off);
d3836 23
a3858 2
				  elf_gp (htab->splt->output_section->owner),
				  htab->splt->contents + off + 4);
d3862 1
a3862 1
	      if (off >= (bfd_vma) -2)
d3876 2
a3877 2
				+ htab->splt->output_offset
				+ htab->splt->output_section->vma
a3892 7
	  /* r_symndx will be zero only for relocs against symbols
	     from removed linkonce sections, or sections discarded by
	     a linker script.  */
	  if (r_symndx == 0
	      || (input_section->flags & SEC_ALLOC) == 0)
	    break;

d3894 17
a3910 28
	     expression must match the code in ..check_relocs and
	     allocate_dynrelocs.  ie. We need exactly the same condition
	     as in ..check_relocs, with some extra conditions (dynindx
	     test in this case) to cater for relocs removed by
	     allocate_dynrelocs.  If you squint, the non-shared test
	     here does indeed match the one in ..check_relocs, the
	     difference being that here we test DEF_DYNAMIC as well as
	     !DEF_REGULAR.  All common syms end up with !DEF_REGULAR,
	     which is why we can't use just that test here.
	     Conversely, DEF_DYNAMIC can't be used in check_relocs as
	     there all files have not been loaded.  */
	  if ((info->shared
	       && (IS_ABSOLUTE_RELOC (r_type)
		   || (h != NULL
		       && h->elf.dynindx != -1
		       && (!info->symbolic
			   || (h->elf.elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
	      || (!info->shared
		  && h != NULL
		  && h->elf.dynindx != -1
		  && (h->elf.elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
		  && (((h->elf.elf_link_hash_flags
			& ELF_LINK_HASH_DEF_DYNAMIC) != 0
		       && (h->elf.elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR) == 0)
		      || h->elf.root.type == bfd_link_hash_undefweak
		      || h->elf.root.type == bfd_link_hash_undefined)))
d3913 1
a3913 3
	      bfd_boolean skip;
	      asection *sreloc;
	      bfd_byte *loc;
d3919 16
d3936 15
a3950 5
	      outrel.r_offset =
		_bfd_elf_section_offset (output_bfd, info, input_section,
					 rel->r_offset);
	      skip = (outrel.r_offset == (bfd_vma) -1
		      || outrel.r_offset == (bfd_vma) -2);
a3960 2
			   || !IS_ABSOLUTE_RELOC (r_type)
			   || !info->shared
a3994 10
#if 0
	      /* EH info can cause unaligned DIR32 relocs.
		 Tweak the reloc type for the dynamic linker.  */
	      if (r_type == R_PARISC_DIR32 && (outrel.r_offset & 3) != 0)
		outrel.r_info = ELF32_R_INFO (ELF32_R_SYM (outrel.r_info),
					      R_PARISC_DIR32U);
#endif
	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();
d3996 5
a4000 3
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
d4009 1
a4009 1
			       htab, sym_sec, h);
d4022 1
a4022 1
	    return FALSE;
d4031 7
a4037 12
	  if (r == bfd_reloc_notsupported || !warned_undef)
	    {
	      (*_bfd_error_handler)
		(_("%s(%s+0x%lx): cannot handle %s for %s"),
		 bfd_archive_filename (input_bfd),
		 input_section->name,
		 (long) rel->r_offset,
		 howto->name,
		 sym_name);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
d4044 1
a4044 1
	    return FALSE;
d4048 27
a4074 1
  return TRUE;
d4080 1
a4080 1
static bfd_boolean
d4087 2
a4088 1
  struct elf32_hppa_link_hash_table *htab;
d4090 2
a4091 1
  htab = hppa_link_hash_table (info);
a4119 1
	  bfd_byte *loc;
d4123 14
a4136 4
			  + htab->splt->output_offset
			  + htab->splt->output_section->vma);
	  if (h->dynindx != -1)
	    {
d4148 17
a4164 6
	  loc = htab->srelplt->contents;
	  loc += htab->srelplt->reloc_count++ * sizeof (Elf32_External_Rela);
	  bfd_elf32_swap_reloca_out (htab->splt->output_section->owner,
				     &rel, loc);
	}
      else
d4166 2
a4167 6
	  bfd_put_32 (htab->splt->owner,
		      value,
		      htab->splt->contents + h->plt.offset);
	  bfd_put_32 (htab->splt->owner,
		      elf_gp (htab->splt->output_section->owner),
		      htab->splt->contents + h->plt.offset + 4);
a4180 1
      bfd_byte *loc;
d4186 2
a4187 2
		      + htab->sgot->output_offset
		      + htab->sgot->output_section->vma);
d4208 1
a4208 1
		      htab->sgot->contents + h->got.offset);
d4213 5
a4217 3
      loc = htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
a4223 1
      bfd_byte *loc;
d4232 1
a4232 1
      s = htab->srelbss;
d4239 4
a4242 2
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
d4253 1
a4253 22
  return TRUE;
}

/* Used to decide how to sort relocs in an optimal manner for the
   dynamic linker, before writing them out.  */

static enum elf_reloc_type_class
elf32_hppa_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
{
  if (ELF32_R_SYM (rela->r_info) == 0)
    return reloc_class_relative;

  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    case R_PARISC_IPLT:
      return reloc_class_plt;
    case R_PARISC_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
d4258 1
a4258 1
static bfd_boolean
d4264 1
a4264 1
  struct elf32_hppa_link_hash_table *htab;
d4267 2
a4268 2
  htab = hppa_link_hash_table (info);
  dynobj = htab->elf.dynobj;
d4272 1
a4272 1
  if (htab->elf.dynamic_sections_created)
d4291 1
a4291 1
	      continue;
d4296 1
d4300 1
a4300 1
	      s = htab->srelplt;
d4302 1
d4306 6
a4311 23
	      s = htab->srelplt;
	      dyn.d_un.d_val = s->_raw_size;
	      break;

	    case DT_RELASZ:
	      /* Don't count procedure linkage table relocs in the
		 overall reloc count.  */
	      s = htab->srelplt;
	      if (s == NULL)
		continue;
	      dyn.d_un.d_val -= s->_raw_size;
	      break;

	    case DT_RELA:
	      /* We may not be using the standard ELF linker script.
		 If .rela.plt is the first .rela section, we adjust
		 DT_RELA to not include it.  */
	      s = htab->srelplt;
	      if (s == NULL)
		continue;
	      if (dyn.d_un.d_ptr != s->output_section->vma + s->output_offset)
		continue;
	      dyn.d_un.d_ptr += s->_raw_size;
a4313 2

	  bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d4317 1
a4317 1
  if (htab->sgot != NULL && htab->sgot->_raw_size != 0)
d4325 1
a4325 1
		  htab->sgot->contents);
d4328 1
a4328 1
      memset (htab->sgot->contents + GOT_ENTRY_SIZE, 0, GOT_ENTRY_SIZE);
d4331 1
a4331 1
      elf_section_data (htab->sgot->output_section)
d4335 1
a4335 1
  if (htab->splt != NULL && htab->splt->_raw_size != 0)
d4338 1
a4338 1
      elf_section_data (htab->splt->output_section)
d4341 1
a4341 1
      if (htab->need_plt_stub)
d4344 2
a4345 2
	  memcpy (htab->splt->contents
		  + htab->splt->_raw_size - sizeof (plt_stub),
d4348 5
a4352 5
	  if ((htab->splt->output_offset
	       + htab->splt->output_section->vma
	       + htab->splt->_raw_size)
	      != (htab->sgot->output_offset
		  + htab->sgot->output_section->vma))
d4356 1
a4356 1
	      return FALSE;
d4361 1
a4361 1
  return TRUE;
a4406 1
#define bfd_elf32_bfd_link_hash_table_free   elf32_hppa_link_hash_table_free
a4408 1
#define elf_backend_copy_indirect_symbol     elf32_hppa_copy_indirect_symbol
a4422 1
#define elf_backend_reloc_type_class	     elf32_hppa_reloc_type_class
a4424 1
#define elf_backend_can_refcount	     1
a4429 1
#define elf_backend_rela_normal		     1
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2002, 2003, 2004 Free Software Foundation, Inc.
a143 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

d206 4
d226 2
a227 2
  asection * (*add_stub_section) (const char *, asection *);
  void (*layout_sections_again) (void);
d282 124
d411 4
a414 3
stub_hash_newfunc (struct bfd_hash_entry *entry,
		   struct bfd_hash_table *table,
		   const char *string)
d449 4
a452 3
hppa_link_hash_newfunc (struct bfd_hash_entry *entry,
			struct bfd_hash_table *table,
			const char *string)
d474 1
d486 2
a487 1
elf32_hppa_link_hash_table_create (bfd *abfd)
d492 1
a492 1
  ret = bfd_malloc (amt);
d531 2
a532 1
elf32_hppa_link_hash_table_free (struct bfd_link_hash_table *hash)
d544 5
a548 4
hppa_stub_name (const asection *input_section,
		const asection *sym_sec,
		const struct elf32_hppa_link_hash_entry *hash,
		const Elf_Internal_Rela *rel)
d585 6
a590 5
hppa_get_stub_entry (const asection *input_section,
		     const asection *sym_sec,
		     struct elf32_hppa_link_hash_entry *hash,
		     const Elf_Internal_Rela *rel,
		     struct elf32_hppa_link_hash_table *htab)
d631 4
a634 3
hppa_add_stub (const char *stub_name,
	       asection *section,
	       struct elf32_hppa_link_hash_table *htab)
d687 5
a691 5
hppa_type_of_stub (asection *input_sec,
		   const Elf_Internal_Rela *rel,
		   struct elf32_hppa_link_hash_entry *hash,
		   bfd_vma destination,
		   struct bfd_link_info *info)
d700 2
a701 5
      && hash->elf.dynindx != -1
      && !hash->plabel
      && (info->shared
	  || !(hash->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
	  || hash->elf.root.type == bfd_link_hash_defweak))
d780 3
a782 1
hppa_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
d798 1
a798 1
  info = in_arg;
d820 1
a820 1
      val = hppa_field_adjust (sym_value, 0, e_lrsel);
d824 1
a824 1
      val = hppa_field_adjust (sym_value, 0, e_rrsel) >> 2;
d870 1
a870 1
      val = hppa_field_adjust (sym_value, 0, e_lrsel),
d879 1
a879 1
      val = hppa_field_adjust (sym_value, 0, e_rrsel);
d906 33
d1000 1
d1021 3
a1023 1
hppa_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
d1031 1
a1031 1
  htab = in_arg;
d1055 2
a1056 1
elf32_hppa_object_p (bfd *abfd)
d1064 1
a1064 4
      /* GCC on hppa-linux produces binaries with OSABI=Linux,
	 but the kernel produces corefiles with OSABI=SysV.  */
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_LINUX &&
	  i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_NONE) /* aka SYSV */
d1088 17
d1109 3
a1111 1
elf32_hppa_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
d1149 3
a1151 3
elf32_hppa_copy_indirect_symbol (const struct elf_backend_data *bed,
				 struct elf_link_hash_entry *dir,
				 struct elf_link_hash_entry *ind)
d1194 1
a1194 13
  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d1203 5
a1207 4
elf32_hppa_check_relocs (bfd *abfd,
			 struct bfd_link_info *info,
			 asection *sec,
			 const Elf_Internal_Rela *relocs)
d1217 1
a1217 1
  if (info->relocatable)
d1257 3
d1324 1
a1324 1
	case R_PARISC_SEGBASE:  /* Used to set segment base.  */
a1329 1
	case R_PARISC_PCREL32:
d1375 2
a1376 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, &h->elf, rel->r_offset))
d1383 2
a1384 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, &h->elf, rel->r_addend))
d1425 2
a1426 1
		  local_got_refcounts = bfd_zalloc (abfd, size);
d1472 2
a1473 1
		      local_got_refcounts = bfd_zalloc (abfd, size);
d1529 1
a1529 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d1607 3
a1609 1
		  p = bfd_alloc (htab->elf.dynobj, sizeof *p);
d1637 6
a1642 5
elf32_hppa_gc_mark_hook (asection *sec,
			 struct bfd_link_info *info ATTRIBUTE_UNUSED,
			 Elf_Internal_Rela *rel,
			 struct elf_link_hash_entry *h,
			 Elf_Internal_Sym *sym)
d1677 5
a1681 4
elf32_hppa_gc_sweep_hook (bfd *abfd,
			  struct bfd_link_info *info ATTRIBUTE_UNUSED,
			  asection *sec,
			  const Elf_Internal_Rela *relocs)
d1780 4
a1783 3
elf32_hppa_hide_symbol (struct bfd_link_info *info,
			struct elf_link_hash_entry *h,
			bfd_boolean force_local)
d1803 11
d1821 3
a1823 2
elf32_hppa_adjust_dynamic_symbol (struct bfd_link_info *info,
				  struct elf_link_hash_entry *h)
d1826 2
d1850 12
a1861 2
	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
a1878 4
      if (ELIMINATE_COPY_RELOCS)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d1897 2
a1898 1
  if (ELIMINATE_COPY_RELOCS)
d1900 4
a1903 2
      struct elf32_hppa_link_hash_entry *eh;
      struct elf32_hppa_dyn_reloc_entry *p;
d1905 6
a1910 15
      eh = (struct elf32_hppa_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
d1961 28
d1990 1
a1990 1
   ie. plabel entries.  */
d1993 3
a1995 1
allocate_plt_static (struct elf_link_hash_entry *h, void *inf)
d2007 1
a2007 1
  info = inf;
d2009 10
a2018 1
  if (htab->elf.dynamic_sections_created
d2027 1
a2027 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2031 1
a2031 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared, h))
d2067 3
a2069 1
allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
d2083 1
a2083 1
  info = inf;
d2087 1
d2108 1
a2108 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2138 3
a2140 1
      if (SYMBOL_CALLS_LOCAL (info, h))
a2154 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d2162 1
a2162 2
	  && ((ELIMINATE_COPY_RELOCS
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
d2174 1
a2174 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2208 3
a2210 2
clobber_millicode_symbols (struct elf_link_hash_entry *h,
			   struct bfd_link_info *info)
d2226 3
a2228 1
readonly_dynrelocs (struct elf_link_hash_entry *h, void *inf)
d2243 1
a2243 1
	  struct bfd_link_info *info = inf;
d2257 3
a2259 2
elf32_hppa_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				  struct bfd_link_info *info)
d2275 1
a2275 1
      if (info->executable)
d2289 8
d2392 1
a2392 1
  elf_link_hash_traverse (&htab->elf, allocate_plt_static, info);
d2396 1
a2396 1
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, info);
d2463 1
a2463 1
      s->contents = bfd_zalloc (dynobj, s->_raw_size);
d2475 1
a2475 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d2509 2
a2510 1
	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs, info);
d2531 3
a2533 1
elf32_hppa_setup_section_lists (bfd *output_bfd, struct bfd_link_info *info)
d2543 3
d2563 1
a2563 1
  htab->stub_group = bfd_zmalloc (amt);
d2580 1
a2580 1
  input_list = bfd_malloc (amt);
d2609 3
a2611 1
elf32_hppa_next_input_section (struct bfd_link_info *info, asection *isec)
d2638 4
a2641 3
group_sections (struct elf32_hppa_link_hash_table *htab,
		bfd_size_type stub_group_size,
		bfd_boolean stubs_always_before_branch)
d2719 4
a2722 1
get_local_syms (bfd *output_bfd, bfd *input_bfd, struct bfd_link_info *info)
d2733 1
a2733 1
  all_local_syms = bfd_zmalloc (amt);
d2847 9
a2855 5
elf32_hppa_size_stubs
  (bfd *output_bfd, bfd *stub_bfd, struct bfd_link_info *info,
   bfd_boolean multi_subspace, bfd_signed_vma group_size,
   asection * (*add_stub_section) (const char *, asection *),
   void (*layout_sections_again) (void))
d2953 3
a2955 2
		= _bfd_elf_link_read_relocs (input_bfd, section, NULL, NULL,
					     info->keep_memory);
d3044 2
a3045 1
			  if (! (info->unresolved_syms_in_objects == RM_IGNORE
d3060 1
a3060 1
						 destination, info);
d3141 3
a3143 1
elf32_hppa_set_gp (bfd *abfd, struct bfd_link_info *info)
d3162 15
a3176 2
      asection *splt = bfd_get_section_by_name (abfd, ".plt");
      asection *sgot = bfd_get_section_by_name (abfd, ".got");
d3237 2
a3238 1
elf32_hppa_build_stubs (struct bfd_link_info *info)
d3254 1
a3254 1
      stub_sec->contents = bfd_zalloc (htab->stub_bfd, size);
d3270 3
a3272 1
elf32_hppa_final_link (bfd *abfd, struct bfd_link_info *info)
d3275 1
a3275 1
  if (!bfd_elf_final_link (abfd, info))
d3286 4
a3289 3
hppa_record_segment_addr (bfd *abfd ATTRIBUTE_UNUSED,
			  asection *section,
			  void *data)
d3315 8
a3322 8
final_link_relocate (asection *input_section,
		     bfd_byte *contents,
		     const Elf_Internal_Rela *rel,
		     bfd_vma value,
		     struct elf32_hppa_link_hash_table *htab,
		     asection *sym_sec,
		     struct elf32_hppa_link_hash_entry *h,
		     struct bfd_link_info *info)
a3325 1
  unsigned int orig_r_type = r_type;
a3347 20
  /* If we are not building a shared library, convert DLTIND relocs to
     DPREL relocs.  */
  if (!info->shared)
    {
      switch (r_type)
	{
	  case R_PARISC_DLTIND21L:
	    r_type = R_PARISC_DPREL21L;
	    break;

	  case R_PARISC_DLTIND14R:
	    r_type = R_PARISC_DPREL14R;
	    break;

	  case R_PARISC_DLTIND14F:
	    r_type = R_PARISC_DPREL14F;
	    break;
	}
    }

d3359 2
a3360 5
	      && h->elf.dynindx != -1
	      && !h->plabel
	      && (info->shared
		  || !(h->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
		  || h->elf.root.type == bfd_link_hash_defweak)))
a3391 1
    case R_PARISC_PCREL32:
a3399 32
      /* Convert instructions that use the linkage table pointer (r19) to
	 instructions that use the global data pointer (dp).  This is the
	 most efficient way of using PIC code in an incomplete executable,
	 but the user must follow the standard runtime conventions for
	 accessing data for this to work.  */
      if (orig_r_type == R_PARISC_DLTIND21L)
	{
	  /* Convert addil instructions if the original reloc was a
	     DLTIND21L.  GCC sometimes uses a register other than r19 for
	     the operation, so we must convert any addil instruction
	     that uses this relocation.  */
	  if ((insn & 0xfc000000) == ((int) OP_ADDIL << 26))
	    insn = ADDIL_DP;
	  else
	    /* We must have a ldil instruction.  It's too hard to find
	       and convert the associated add instruction, so issue an
	       error.  */
	    (*_bfd_error_handler)
	      (_("%s(%s+0x%lx): %s fixup for insn 0x%x is not supported in a non-shared link"),
	       bfd_archive_filename (input_bfd),
	       input_section->name,
	       (long) rel->r_offset,
	       howto->name,
	       insn);
	}
      else if (orig_r_type == R_PARISC_DLTIND14F)
	{
	  /* This must be a format 1 load/store.  Change the base
	     register to dp.  */
	  insn = (insn & 0xfc1ffff) | (27 << 21);
	}

a3452 1
    case R_PARISC_PCREL32:
d3579 10
a3588 8
elf32_hppa_relocate_section (bfd *output_bfd,
			     struct bfd_link_info *info,
			     bfd *input_bfd,
			     asection *input_section,
			     bfd_byte *contents,
			     Elf_Internal_Rela *relocs,
			     Elf_Internal_Sym *local_syms,
			     asection **local_sections)
d3596 1
a3596 1
  if (info->relocatable)
d3641 1
a3641 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sym_sec, rel);
d3645 36
a3680 24
	  struct elf_link_hash_entry *hh;
	  bfd_boolean unresolved_reloc;
	  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   hh, sym_sec, relocation,
				   unresolved_reloc, warned_undef);

	  if (relocation == 0
	      && hh->root.type != bfd_link_hash_defined
	      && hh->root.type != bfd_link_hash_defweak
	      && hh->root.type != bfd_link_hash_undefweak)
	    {
	      if (info->unresolved_syms_in_objects == RM_IGNORE
		  && ELF_ST_VISIBILITY (hh->other) == STV_DEFAULT
		  && hh->type == STT_PARISC_MILLI)
		{
		  if (! info->callbacks->undefined_symbol
		      (info, hh->root.root.string, input_bfd,
		       input_section, rel->r_offset, FALSE))
		    return FALSE;
		  warned_undef = TRUE;
		}
a3681 1
	  h = (struct elf32_hppa_link_hash_entry *) hh;
d3705 1
a3705 2
		if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared,
						       &h->elf))
d3797 1
a3797 2
		  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared,
							 &h->elf))
a3913 3
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->elf.other) == STV_DEFAULT
		   || h->elf.root.type != bfd_link_hash_undefweak)
d3915 5
a3919 1
		   || !SYMBOL_CALLS_LOCAL (info, &h->elf)))
d3924 2
a3925 3
		  && ((ELIMINATE_COPY_RELOCS
		       && (h->elf.elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_DYNAMIC) != 0
a3981 5
		      /* Skip this relocation if the output section has
			 been discarded.  */
		      if (bfd_is_abs_section (sym_sec->output_section))
			break;

d4014 1
a4014 1
			       htab, sym_sec, h, info);
d4052 2
a4053 2
		(info, sym_name, howto->name, 0, input_bfd, input_section,
		 rel->r_offset)))
d4065 5
a4069 4
elf32_hppa_finish_dynamic_symbol (bfd *output_bfd,
				  struct bfd_link_info *info,
				  struct elf_link_hash_entry *h,
				  Elf_Internal_Sym *sym)
a4071 2
  Elf_Internal_Rela rel;
  bfd_byte *loc;
d4099 1
a4099 5
      /* Create a dynamic IPLT relocation for this entry.  */
      rel.r_offset = (h->plt.offset
		      + htab->splt->output_offset
		      + htab->splt->output_section->vma);
      if (h->dynindx != -1)
d4101 24
a4124 2
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_PARISC_IPLT);
	  rel.r_addend = 0;
d4128 6
a4133 4
	  /* This symbol has been marked to become local, and is
	     used by a plabel so must be kept in the .plt.  */
	  rel.r_info = ELF32_R_INFO (0, R_PARISC_IPLT);
	  rel.r_addend = value;
a4135 4
      loc = htab->srelplt->contents;
      loc += htab->srelplt->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (htab->splt->output_section->owner, &rel, loc);

d4146 3
d4174 2
a4175 1
	  bfd_put_32 (output_bfd, 0, htab->sgot->contents + h->got.offset);
d4188 2
d4224 2
a4225 1
elf32_hppa_reloc_type_class (const Elf_Internal_Rela *rela)
d4244 3
a4246 2
elf32_hppa_finish_dynamic_sections (bfd *output_bfd,
				    struct bfd_link_info *info)
d4324 3
a4326 1
		  sdyn ? sdyn->output_section->vma + sdyn->output_offset : 0,
d4369 3
a4371 2
elf32_hppa_post_process_headers (bfd *abfd,
				 struct bfd_link_info *info ATTRIBUTE_UNUSED)
d4390 3
a4392 1
elf32_hppa_elf_get_symbol_type (Elf_Internal_Sym *elf_sym, int type)
d4410 1
@


