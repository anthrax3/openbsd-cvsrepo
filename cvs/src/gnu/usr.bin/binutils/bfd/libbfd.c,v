head	1.7;
access;
symbols
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.52
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.10;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.23;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.30;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.19;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.01.15;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.45.56;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.58;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.58;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.06.01;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.38.17;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.19.57;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.45.48;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.26.27;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.18;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.30;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* Assorted BFD support routines, only used internally.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"

#ifndef HAVE_GETPAGESIZE
#define getpagesize() 2048
#endif

/*
SECTION
	Internal functions

DESCRIPTION
	These routines are used within BFD.
	They are not intended for export, but are documented here for
	completeness.
*/

/* A routine which is used in target vectors for unsupported
   operations.  */

bfd_boolean
bfd_false (bfd *ignore ATTRIBUTE_UNUSED)
{
  bfd_set_error (bfd_error_invalid_operation);
  return FALSE;
}

/* A routine which is used in target vectors for supported operations
   which do not actually do anything.  */

bfd_boolean
bfd_true (bfd *ignore ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/* A routine which is used in target vectors for unsupported
   operations which return a pointer value.  */

void *
bfd_nullvoidptr (bfd *ignore ATTRIBUTE_UNUSED)
{
  bfd_set_error (bfd_error_invalid_operation);
  return NULL;
}

int
bfd_0 (bfd *ignore ATTRIBUTE_UNUSED)
{
  return 0;
}

unsigned int
bfd_0u (bfd *ignore ATTRIBUTE_UNUSED)
{
   return 0;
}

long
bfd_0l (bfd *ignore ATTRIBUTE_UNUSED)
{
  return 0;
}

/* A routine which is used in target vectors for unsupported
   operations which return -1 on error.  */

long
_bfd_n1 (bfd *ignore_abfd ATTRIBUTE_UNUSED)
{
  bfd_set_error (bfd_error_invalid_operation);
  return -1;
}

void
bfd_void (bfd *ignore ATTRIBUTE_UNUSED)
{
}

bfd_boolean
_bfd_nocore_core_file_matches_executable_p
  (bfd *ignore_core_bfd ATTRIBUTE_UNUSED,
   bfd *ignore_exec_bfd ATTRIBUTE_UNUSED)
{
  bfd_set_error (bfd_error_invalid_operation);
  return FALSE;
}

/* Routine to handle core_file_failing_command entry point for targets
   without core file support.  */

char *
_bfd_nocore_core_file_failing_command (bfd *ignore_abfd ATTRIBUTE_UNUSED)
{
  bfd_set_error (bfd_error_invalid_operation);
  return NULL;
}

/* Routine to handle core_file_failing_signal entry point for targets
   without core file support.  */

int
_bfd_nocore_core_file_failing_signal (bfd *ignore_abfd ATTRIBUTE_UNUSED)
{
  bfd_set_error (bfd_error_invalid_operation);
  return 0;
}

const bfd_target *
_bfd_dummy_target (bfd *ignore_abfd ATTRIBUTE_UNUSED)
{
  bfd_set_error (bfd_error_wrong_format);
  return 0;
}

/* Allocate memory using malloc.  */

void *
bfd_malloc (bfd_size_type size)
{
  void *ptr;

  if (size != (size_t) size)
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

  ptr = malloc ((size_t) size);
  if (ptr == NULL && (size_t) size != 0)
    bfd_set_error (bfd_error_no_memory);

  return ptr;
}

/* Reallocate memory using realloc.  */

void *
bfd_realloc (void *ptr, bfd_size_type size)
{
  void *ret;

  if (size != (size_t) size)
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

  if (ptr == NULL)
    ret = malloc ((size_t) size);
  else
    ret = realloc (ptr, (size_t) size);

  if (ret == NULL && (size_t) size != 0)
    bfd_set_error (bfd_error_no_memory);

  return ret;
}

/* Allocate memory using malloc and clear it.  */

void *
bfd_zmalloc (bfd_size_type size)
{
  void *ptr;

  if (size != (size_t) size)
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

  ptr = malloc ((size_t) size);

  if ((size_t) size != 0)
    {
      if (ptr == NULL)
	bfd_set_error (bfd_error_no_memory);
      else
	memset (ptr, 0, (size_t) size);
    }

  return ptr;
}
/*
INTERNAL_FUNCTION
	bfd_write_bigendian_4byte_int

SYNOPSIS
	bfd_boolean bfd_write_bigendian_4byte_int (bfd *, unsigned int);

DESCRIPTION
	Write a 4 byte integer @@var{i} to the output BFD @@var{abfd}, in big
	endian order regardless of what else is going on.  This is useful in
	archives.

*/
bfd_boolean
bfd_write_bigendian_4byte_int (bfd *abfd, unsigned int i)
{
  bfd_byte buffer[4];
  bfd_putb32 ((bfd_vma) i, buffer);
  return bfd_bwrite (buffer, (bfd_size_type) 4, abfd) == 4;
}


/** The do-it-yourself (byte) sex-change kit */

/* The middle letter e.g. get<b>short indicates Big or Little endian
   target machine.  It doesn't matter what the byte order of the host
   machine is; these routines work for either.  */

/* FIXME: Should these take a count argument?
   Answer (gnu@@cygnus.com):  No, but perhaps they should be inline
                             functions in swap.h #ifdef __GNUC__.
                             Gprof them later and find out.  */

/*
FUNCTION
	bfd_put_size
FUNCTION
	bfd_get_size

DESCRIPTION
	These macros as used for reading and writing raw data in
	sections; each access (except for bytes) is vectored through
	the target format of the BFD and mangled accordingly. The
	mangling performs any necessary endian translations and
	removes alignment restrictions.  Note that types accepted and
	returned by these macros are identical so they can be swapped
	around in macros---for example, @@file{libaout.h} defines <<GET_WORD>>
	to either <<bfd_get_32>> or <<bfd_get_64>>.

	In the put routines, @@var{val} must be a <<bfd_vma>>.  If we are on a
	system without prototypes, the caller is responsible for making
	sure that is true, with a cast if necessary.  We don't cast
	them in the macro definitions because that would prevent <<lint>>
	or <<gcc -Wall>> from detecting sins such as passing a pointer.
	To detect calling these with less than a <<bfd_vma>>, use
	<<gcc -Wconversion>> on a host with 64 bit <<bfd_vma>>'s.

.
.{* Byte swapping macros for user section data.  *}
.
.#define bfd_put_8(abfd, val, ptr) \
.  ((void) (*((unsigned char *) (ptr)) = (val) & 0xff))
.#define bfd_put_signed_8 \
.  bfd_put_8
.#define bfd_get_8(abfd, ptr) \
.  (*(unsigned char *) (ptr) & 0xff)
.#define bfd_get_signed_8(abfd, ptr) \
.  (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)
.
.#define bfd_put_16(abfd, val, ptr) \
.  BFD_SEND (abfd, bfd_putx16, ((val),(ptr)))
.#define bfd_put_signed_16 \
.  bfd_put_16
.#define bfd_get_16(abfd, ptr) \
.  BFD_SEND (abfd, bfd_getx16, (ptr))
.#define bfd_get_signed_16(abfd, ptr) \
.  BFD_SEND (abfd, bfd_getx_signed_16, (ptr))
.
.#define bfd_put_32(abfd, val, ptr) \
.  BFD_SEND (abfd, bfd_putx32, ((val),(ptr)))
.#define bfd_put_signed_32 \
.  bfd_put_32
.#define bfd_get_32(abfd, ptr) \
.  BFD_SEND (abfd, bfd_getx32, (ptr))
.#define bfd_get_signed_32(abfd, ptr) \
.  BFD_SEND (abfd, bfd_getx_signed_32, (ptr))
.
.#define bfd_put_64(abfd, val, ptr) \
.  BFD_SEND (abfd, bfd_putx64, ((val), (ptr)))
.#define bfd_put_signed_64 \
.  bfd_put_64
.#define bfd_get_64(abfd, ptr) \
.  BFD_SEND (abfd, bfd_getx64, (ptr))
.#define bfd_get_signed_64(abfd, ptr) \
.  BFD_SEND (abfd, bfd_getx_signed_64, (ptr))
.
.#define bfd_get(bits, abfd, ptr)			\
.  ((bits) == 8 ? (bfd_vma) bfd_get_8 (abfd, ptr)	\
.   : (bits) == 16 ? bfd_get_16 (abfd, ptr)		\
.   : (bits) == 32 ? bfd_get_32 (abfd, ptr)		\
.   : (bits) == 64 ? bfd_get_64 (abfd, ptr)		\
.   : (abort (), (bfd_vma) - 1))
.
.#define bfd_put(bits, abfd, val, ptr)			\
.  ((bits) == 8 ? bfd_put_8  (abfd, val, ptr)		\
.   : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)		\
.   : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)		\
.   : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)		\
.   : (abort (), (void) 0))
.
*/

/*
FUNCTION
	bfd_h_put_size
	bfd_h_get_size

DESCRIPTION
	These macros have the same function as their <<bfd_get_x>>
	brethren, except that they are used for removing information
	for the header records of object files. Believe it or not,
	some object files keep their header records in big endian
	order and their data in little endian order.
.
.{* Byte swapping macros for file header data.  *}
.
.#define bfd_h_put_8(abfd, val, ptr) \
.  bfd_put_8 (abfd, val, ptr)
.#define bfd_h_put_signed_8(abfd, val, ptr) \
.  bfd_put_8 (abfd, val, ptr)
.#define bfd_h_get_8(abfd, ptr) \
.  bfd_get_8 (abfd, ptr)
.#define bfd_h_get_signed_8(abfd, ptr) \
.  bfd_get_signed_8 (abfd, ptr)
.
.#define bfd_h_put_16(abfd, val, ptr) \
.  BFD_SEND (abfd, bfd_h_putx16, (val, ptr))
.#define bfd_h_put_signed_16 \
.  bfd_h_put_16
.#define bfd_h_get_16(abfd, ptr) \
.  BFD_SEND (abfd, bfd_h_getx16, (ptr))
.#define bfd_h_get_signed_16(abfd, ptr) \
.  BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr))
.
.#define bfd_h_put_32(abfd, val, ptr) \
.  BFD_SEND (abfd, bfd_h_putx32, (val, ptr))
.#define bfd_h_put_signed_32 \
.  bfd_h_put_32
.#define bfd_h_get_32(abfd, ptr) \
.  BFD_SEND (abfd, bfd_h_getx32, (ptr))
.#define bfd_h_get_signed_32(abfd, ptr) \
.  BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr))
.
.#define bfd_h_put_64(abfd, val, ptr) \
.  BFD_SEND (abfd, bfd_h_putx64, (val, ptr))
.#define bfd_h_put_signed_64 \
.  bfd_h_put_64
.#define bfd_h_get_64(abfd, ptr) \
.  BFD_SEND (abfd, bfd_h_getx64, (ptr))
.#define bfd_h_get_signed_64(abfd, ptr) \
.  BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr))
.
.{* Aliases for the above, which should eventually go away.  *}
.
.#define H_PUT_64  bfd_h_put_64
.#define H_PUT_32  bfd_h_put_32
.#define H_PUT_16  bfd_h_put_16
.#define H_PUT_8   bfd_h_put_8
.#define H_PUT_S64 bfd_h_put_signed_64
.#define H_PUT_S32 bfd_h_put_signed_32
.#define H_PUT_S16 bfd_h_put_signed_16
.#define H_PUT_S8  bfd_h_put_signed_8
.#define H_GET_64  bfd_h_get_64
.#define H_GET_32  bfd_h_get_32
.#define H_GET_16  bfd_h_get_16
.#define H_GET_8   bfd_h_get_8
.#define H_GET_S64 bfd_h_get_signed_64
.#define H_GET_S32 bfd_h_get_signed_32
.#define H_GET_S16 bfd_h_get_signed_16
.#define H_GET_S8  bfd_h_get_signed_8
.
.*/

/* Sign extension to bfd_signed_vma.  */
#define COERCE16(x) (((bfd_signed_vma) (x) ^ 0x8000) - 0x8000)
#define COERCE32(x) (((bfd_signed_vma) (x) ^ 0x80000000) - 0x80000000)
#define EIGHT_GAZILLION ((bfd_int64_t) 1 << 63)
#define COERCE64(x) \
  (((bfd_int64_t) (x) ^ EIGHT_GAZILLION) - EIGHT_GAZILLION)

bfd_vma
bfd_getb16 (const void *p)
{
  const bfd_byte *addr = p;
  return (addr[0] << 8) | addr[1];
}

bfd_vma
bfd_getl16 (const void *p)
{
  const bfd_byte *addr = p;
  return (addr[1] << 8) | addr[0];
}

bfd_signed_vma
bfd_getb_signed_16 (const void *p)
{
  const bfd_byte *addr = p;
  return COERCE16 ((addr[0] << 8) | addr[1]);
}

bfd_signed_vma
bfd_getl_signed_16 (const void *p)
{
  const bfd_byte *addr = p;
  return COERCE16 ((addr[1] << 8) | addr[0]);
}

void
bfd_putb16 (bfd_vma data, void *p)
{
  bfd_byte *addr = p;
  addr[0] = (data >> 8) & 0xff;
  addr[1] = data & 0xff;
}

void
bfd_putl16 (bfd_vma data, void *p)
{
  bfd_byte *addr = p;
  addr[0] = data & 0xff;
  addr[1] = (data >> 8) & 0xff;
}

bfd_vma
bfd_getb32 (const void *p)
{
  const bfd_byte *addr = p;
  unsigned long v;

  v = (unsigned long) addr[0] << 24;
  v |= (unsigned long) addr[1] << 16;
  v |= (unsigned long) addr[2] << 8;
  v |= (unsigned long) addr[3];
  return v;
}

bfd_vma
bfd_getl32 (const void *p)
{
  const bfd_byte *addr = p;
  unsigned long v;

  v = (unsigned long) addr[0];
  v |= (unsigned long) addr[1] << 8;
  v |= (unsigned long) addr[2] << 16;
  v |= (unsigned long) addr[3] << 24;
  return v;
}

bfd_signed_vma
bfd_getb_signed_32 (const void *p)
{
  const bfd_byte *addr = p;
  unsigned long v;

  v = (unsigned long) addr[0] << 24;
  v |= (unsigned long) addr[1] << 16;
  v |= (unsigned long) addr[2] << 8;
  v |= (unsigned long) addr[3];
  return COERCE32 (v);
}

bfd_signed_vma
bfd_getl_signed_32 (const void *p)
{
  const bfd_byte *addr = p;
  unsigned long v;

  v = (unsigned long) addr[0];
  v |= (unsigned long) addr[1] << 8;
  v |= (unsigned long) addr[2] << 16;
  v |= (unsigned long) addr[3] << 24;
  return COERCE32 (v);
}

bfd_uint64_t
bfd_getb64 (const void *p ATTRIBUTE_UNUSED)
{
#ifdef BFD_HOST_64_BIT
  const bfd_byte *addr = p;
  bfd_uint64_t v;

  v  = addr[0]; v <<= 8;
  v |= addr[1]; v <<= 8;
  v |= addr[2]; v <<= 8;
  v |= addr[3]; v <<= 8;
  v |= addr[4]; v <<= 8;
  v |= addr[5]; v <<= 8;
  v |= addr[6]; v <<= 8;
  v |= addr[7];

  return v;
#else
  BFD_FAIL();
  return 0;
#endif
}

bfd_uint64_t
bfd_getl64 (const void *p ATTRIBUTE_UNUSED)
{
#ifdef BFD_HOST_64_BIT
  const bfd_byte *addr = p;
  bfd_uint64_t v;

  v  = addr[7]; v <<= 8;
  v |= addr[6]; v <<= 8;
  v |= addr[5]; v <<= 8;
  v |= addr[4]; v <<= 8;
  v |= addr[3]; v <<= 8;
  v |= addr[2]; v <<= 8;
  v |= addr[1]; v <<= 8;
  v |= addr[0];

  return v;
#else
  BFD_FAIL();
  return 0;
#endif

}

bfd_int64_t
bfd_getb_signed_64 (const void *p ATTRIBUTE_UNUSED)
{
#ifdef BFD_HOST_64_BIT
  const bfd_byte *addr = p;
  bfd_uint64_t v;

  v  = addr[0]; v <<= 8;
  v |= addr[1]; v <<= 8;
  v |= addr[2]; v <<= 8;
  v |= addr[3]; v <<= 8;
  v |= addr[4]; v <<= 8;
  v |= addr[5]; v <<= 8;
  v |= addr[6]; v <<= 8;
  v |= addr[7];

  return COERCE64 (v);
#else
  BFD_FAIL();
  return 0;
#endif
}

bfd_int64_t
bfd_getl_signed_64 (const void *p ATTRIBUTE_UNUSED)
{
#ifdef BFD_HOST_64_BIT
  const bfd_byte *addr = p;
  bfd_uint64_t v;

  v  = addr[7]; v <<= 8;
  v |= addr[6]; v <<= 8;
  v |= addr[5]; v <<= 8;
  v |= addr[4]; v <<= 8;
  v |= addr[3]; v <<= 8;
  v |= addr[2]; v <<= 8;
  v |= addr[1]; v <<= 8;
  v |= addr[0];

  return COERCE64 (v);
#else
  BFD_FAIL();
  return 0;
#endif
}

void
bfd_putb32 (bfd_vma data, void *p)
{
  bfd_byte *addr = p;
  addr[0] = (data >> 24) & 0xff;
  addr[1] = (data >> 16) & 0xff;
  addr[2] = (data >>  8) & 0xff;
  addr[3] = data & 0xff;
}

void
bfd_putl32 (bfd_vma data, void *p)
{
  bfd_byte *addr = p;
  addr[0] = data & 0xff;
  addr[1] = (data >>  8) & 0xff;
  addr[2] = (data >> 16) & 0xff;
  addr[3] = (data >> 24) & 0xff;
}

void
bfd_putb64 (bfd_uint64_t data ATTRIBUTE_UNUSED, void *p ATTRIBUTE_UNUSED)
{
#ifdef BFD_HOST_64_BIT
  bfd_byte *addr = p;
  addr[0] = (data >> (7*8)) & 0xff;
  addr[1] = (data >> (6*8)) & 0xff;
  addr[2] = (data >> (5*8)) & 0xff;
  addr[3] = (data >> (4*8)) & 0xff;
  addr[4] = (data >> (3*8)) & 0xff;
  addr[5] = (data >> (2*8)) & 0xff;
  addr[6] = (data >> (1*8)) & 0xff;
  addr[7] = (data >> (0*8)) & 0xff;
#else
  BFD_FAIL();
#endif
}

void
bfd_putl64 (bfd_uint64_t data ATTRIBUTE_UNUSED, void *p ATTRIBUTE_UNUSED)
{
#ifdef BFD_HOST_64_BIT
  bfd_byte *addr = p;
  addr[7] = (data >> (7*8)) & 0xff;
  addr[6] = (data >> (6*8)) & 0xff;
  addr[5] = (data >> (5*8)) & 0xff;
  addr[4] = (data >> (4*8)) & 0xff;
  addr[3] = (data >> (3*8)) & 0xff;
  addr[2] = (data >> (2*8)) & 0xff;
  addr[1] = (data >> (1*8)) & 0xff;
  addr[0] = (data >> (0*8)) & 0xff;
#else
  BFD_FAIL();
#endif
}

void
bfd_put_bits (bfd_uint64_t data, void *p, int bits, bfd_boolean big_p)
{
  bfd_byte *addr = p;
  int i;
  int bytes;

  if (bits % 8 != 0)
    abort ();

  bytes = bits / 8;
  for (i = 0; i < bytes; i++)
    {
      int index = big_p ? bytes - i - 1 : i;

      addr[index] = data & 0xff;
      data >>= 8;
    }
}

bfd_uint64_t
bfd_get_bits (const void *p, int bits, bfd_boolean big_p)
{
  const bfd_byte *addr = p;
  bfd_uint64_t data;
  int i;
  int bytes;

  if (bits % 8 != 0)
    abort ();

  data = 0;
  bytes = bits / 8;
  for (i = 0; i < bytes; i++)
    {
      int index = big_p ? i : bytes - i - 1;

      data = (data << 8) | addr[index];
    }

  return data;
}

/* Default implementation */

bfd_boolean
_bfd_generic_get_section_contents (bfd *abfd,
				   sec_ptr section,
				   void *location,
				   file_ptr offset,
				   bfd_size_type count)
{
  if (count == 0)
    return TRUE;

  if (offset + count > section->_raw_size)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  if (bfd_seek (abfd, section->filepos + offset, SEEK_SET) != 0
      || bfd_bread (location, count, abfd) != count)
    return FALSE;

  return TRUE;
}

bfd_boolean
_bfd_generic_get_section_contents_in_window
  (bfd *abfd ATTRIBUTE_UNUSED,
   sec_ptr section ATTRIBUTE_UNUSED,
   bfd_window *w ATTRIBUTE_UNUSED,
   file_ptr offset ATTRIBUTE_UNUSED,
   bfd_size_type count ATTRIBUTE_UNUSED)
{
#ifdef USE_MMAP
  if (count == 0)
    return TRUE;
  if (abfd->xvec->_bfd_get_section_contents
      != _bfd_generic_get_section_contents)
    {
      /* We don't know what changes the bfd's get_section_contents
	 method may have to make.  So punt trying to map the file
	 window, and let get_section_contents do its thing.  */
      /* @@@@ FIXME : If the internal window has a refcount of 1 and was
	 allocated with malloc instead of mmap, just reuse it.  */
      bfd_free_window (w);
      w->i = bfd_zmalloc (sizeof (bfd_window_internal));
      if (w->i == NULL)
	return FALSE;
      w->i->data = bfd_malloc (count);
      if (w->i->data == NULL)
	{
	  free (w->i);
	  w->i = NULL;
	  return FALSE;
	}
      w->i->mapped = 0;
      w->i->refcount = 1;
      w->size = w->i->size = count;
      w->data = w->i->data;
      return bfd_get_section_contents (abfd, section, w->data, offset, count);
    }
  if (offset + count > section->_raw_size
      || ! bfd_get_file_window (abfd, section->filepos + offset, count, w,
				TRUE))
    return FALSE;
  return TRUE;
#else
  abort ();
#endif
}

/* This generic function can only be used in implementations where creating
   NEW sections is disallowed.  It is useful in patching existing sections
   in read-write files, though.  See other set_section_contents functions
   to see why it doesn't work for new sections.  */
bfd_boolean
_bfd_generic_set_section_contents (bfd *abfd,
				   sec_ptr section,
				   const void *location,
				   file_ptr offset,
				   bfd_size_type count)
{
  if (count == 0)
    return TRUE;

  if (bfd_seek (abfd, section->filepos + offset, SEEK_SET) != 0
      || bfd_bwrite (location, count, abfd) != count)
    return FALSE;

  return TRUE;
}

/*
INTERNAL_FUNCTION
	bfd_log2

SYNOPSIS
	unsigned int bfd_log2 (bfd_vma x);

DESCRIPTION
	Return the log base 2 of the value supplied, rounded up.  E.g., an
	@@var{x} of 1025 returns 11.  A @@var{x} of 0 returns 0.
*/

unsigned int
bfd_log2 (bfd_vma x)
{
  unsigned int result = 0;

  while ((x = (x >> 1)) != 0)
    ++result;
  return result;
}

bfd_boolean
bfd_generic_is_local_label_name (bfd *abfd, const char *name)
{
  char locals_prefix = (bfd_get_symbol_leading_char (abfd) == '_') ? 'L' : '.';

  return name[0] == locals_prefix;
}

/*  Can be used from / for bfd_merge_private_bfd_data to check that
    endianness matches between input and output file.  Returns
    TRUE for a match, otherwise returns FALSE and emits an error.  */
bfd_boolean
_bfd_generic_verify_endian_match (bfd *ibfd, bfd *obfd)
{
  if (ibfd->xvec->byteorder != obfd->xvec->byteorder
      && ibfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN
      && obfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN)
    {
      const char *msg;

      if (bfd_big_endian (ibfd))
	msg = _("%s: compiled for a big endian system and target is little endian");
      else
	msg = _("%s: compiled for a little endian system and target is big endian");

      (*_bfd_error_handler) (msg, bfd_archive_filename (ibfd));

      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }

  return TRUE;
}

/* Give a warning at runtime if someone compiles code which calls
   old routines.  */

void
warn_deprecated (const char *what,
		 const char *file,
		 int line,
		 const char *func)
{
  /* Poor man's tracking of functions we've already warned about.  */
  static size_t mask = 0;

  if (~(size_t) func & ~mask)
    {
      /* Note: separate sentences in order to allow
	 for translation into other languages.  */
      if (func)
	fprintf (stderr, _("Deprecated %s called at %s line %d in %s\n"),
		 what, file, line, func);
      else
	fprintf (stderr, _("Deprecated %s called\n"), what);
      mask |= ~(size_t) func;
    }
}
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2000, 2001, 2002
d45 1
a45 2
bfd_false (ignore)
     bfd *ignore ATTRIBUTE_UNUSED;
d55 1
a55 2
bfd_true (ignore)
     bfd *ignore ATTRIBUTE_UNUSED;
d63 2
a64 3
PTR
bfd_nullvoidptr (ignore)
     bfd *ignore ATTRIBUTE_UNUSED;
d71 1
a71 2
bfd_0 (ignore)
     bfd *ignore ATTRIBUTE_UNUSED;
d77 1
a77 2
bfd_0u (ignore)
     bfd *ignore ATTRIBUTE_UNUSED;
d83 1
a83 2
bfd_0l (ignore)
     bfd *ignore ATTRIBUTE_UNUSED;
d92 1
a92 2
_bfd_n1 (ignore_abfd)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d99 1
a99 2
bfd_void (ignore)
     bfd *ignore ATTRIBUTE_UNUSED;
d104 3
a106 3
_bfd_nocore_core_file_matches_executable_p (ignore_core_bfd, ignore_exec_bfd)
     bfd *ignore_core_bfd ATTRIBUTE_UNUSED;
     bfd *ignore_exec_bfd ATTRIBUTE_UNUSED;
d116 1
a116 2
_bfd_nocore_core_file_failing_command (ignore_abfd)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d119 1
a119 1
  return (char *)NULL;
d126 1
a126 2
_bfd_nocore_core_file_failing_signal (ignore_abfd)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d133 1
a133 2
_bfd_dummy_target (ignore_abfd)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d141 2
a142 3
PTR
bfd_malloc (size)
     bfd_size_type size;
d144 1
a144 1
  PTR ptr;
d152 1
a152 1
  ptr = (PTR) malloc ((size_t) size);
d161 2
a162 4
PTR
bfd_realloc (ptr, size)
     PTR ptr;
     bfd_size_type size;
d164 1
a164 1
  PTR ret;
d173 1
a173 1
    ret = (PTR) malloc ((size_t) size);
d175 1
a175 1
    ret = (PTR) realloc (ptr, (size_t) size);
d185 2
a186 3
PTR
bfd_zmalloc (size)
     bfd_size_type size;
d188 1
a188 1
  PTR ptr;
d196 1
a196 1
  ptr = (PTR) malloc ((size_t) size);
d222 1
a222 3
bfd_write_bigendian_4byte_int (abfd, i)
     bfd *abfd;
     unsigned int i;
d226 1
a226 1
  return bfd_bwrite ((PTR) buffer, (bfd_size_type) 4, abfd) == 4;
d269 1
a269 1
.                ((void) (*((unsigned char *) (ptr)) = (unsigned char) (val)))
d271 1
a271 1
.		bfd_put_8
d273 1
a273 1
.                (*(unsigned char *) (ptr) & 0xff)
d275 1
a275 1
.		(((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)
d278 1
a278 1
.                BFD_SEND(abfd, bfd_putx16, ((val),(ptr)))
d280 1
a280 1
.		 bfd_put_16
d282 1
a282 1
.                BFD_SEND(abfd, bfd_getx16, (ptr))
d284 1
a284 1
.         	 BFD_SEND (abfd, bfd_getx_signed_16, (ptr))
d287 1
a287 1
.                BFD_SEND(abfd, bfd_putx32, ((val),(ptr)))
d289 1
a289 1
.		 bfd_put_32
d291 1
a291 1
.                BFD_SEND(abfd, bfd_getx32, (ptr))
d293 1
a293 1
.		 BFD_SEND(abfd, bfd_getx_signed_32, (ptr))
d296 1
a296 1
.                BFD_SEND(abfd, bfd_putx64, ((val), (ptr)))
d298 1
a298 1
.		 bfd_put_64
d300 1
a300 1
.                BFD_SEND(abfd, bfd_getx64, (ptr))
d302 1
a302 1
.		 BFD_SEND(abfd, bfd_getx_signed_64, (ptr))
d304 13
a316 13
.#define bfd_get(bits, abfd, ptr)				\
.                ( (bits) ==  8 ? (bfd_vma) bfd_get_8 (abfd, ptr)	\
.		 : (bits) == 16 ? bfd_get_16 (abfd, ptr)	\
.		 : (bits) == 32 ? bfd_get_32 (abfd, ptr)	\
.		 : (bits) == 64 ? bfd_get_64 (abfd, ptr)	\
.		 : (abort (), (bfd_vma) - 1))
.
.#define bfd_put(bits, abfd, val, ptr)				\
.                ( (bits) ==  8 ? bfd_put_8  (abfd, val, ptr)	\
.		 : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)	\
.		 : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)	\
.		 : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)	\
.		 : (abort (), (void) 0))
d370 1
a370 38
.{* Refinements on the above, which should eventually go away.  Save
.   cluttering the source with (bfd_vma) and (bfd_byte *) casts.  *}
.
.#define H_PUT_64(abfd, val, where) \
.  bfd_h_put_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))
.
.#define H_PUT_32(abfd, val, where) \
.  bfd_h_put_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))
.
.#define H_PUT_16(abfd, val, where) \
.  bfd_h_put_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))
.
.#define H_PUT_8 bfd_h_put_8
.
.#define H_PUT_S64(abfd, val, where) \
.  bfd_h_put_signed_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))
.
.#define H_PUT_S32(abfd, val, where) \
.  bfd_h_put_signed_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))
.
.#define H_PUT_S16(abfd, val, where) \
.  bfd_h_put_signed_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))
.
.#define H_PUT_S8 bfd_h_put_signed_8
.
.#define H_GET_64(abfd, where) \
.  bfd_h_get_64 ((abfd), (bfd_byte *) (where))
.
.#define H_GET_32(abfd, where) \
.  bfd_h_get_32 ((abfd), (bfd_byte *) (where))
.
.#define H_GET_16(abfd, where) \
.  bfd_h_get_16 ((abfd), (bfd_byte *) (where))
.
.#define H_GET_8 bfd_h_get_8
.
.#define H_GET_S64(abfd, where) \
.  bfd_h_get_signed_64 ((abfd), (bfd_byte *) (where))
d372 16
a387 7
.#define H_GET_S32(abfd, where) \
.  bfd_h_get_signed_32 ((abfd), (bfd_byte *) (where))
.
.#define H_GET_S16(abfd, where) \
.  bfd_h_get_signed_16 ((abfd), (bfd_byte *) (where))
.
.#define H_GET_S8 bfd_h_get_signed_8
d393 2
a394 3
#define COERCE32(x) \
  ((bfd_signed_vma) (long) (((unsigned long) (x) ^ 0x80000000) - 0x80000000))
#define EIGHT_GAZILLION (((BFD_HOST_64_BIT)0x80000000) << 32)
d396 1
a396 1
  (((bfd_signed_vma) (x) ^ EIGHT_GAZILLION) - EIGHT_GAZILLION)
d399 1
a399 2
bfd_getb16 (addr)
     register const bfd_byte *addr;
d401 1
d406 1
a406 2
bfd_getl16 (addr)
     register const bfd_byte *addr;
d408 1
d413 1
a413 2
bfd_getb_signed_16 (addr)
     register const bfd_byte *addr;
d415 2
a416 1
  return COERCE16((addr[0] << 8) | addr[1]);
d420 1
a420 2
bfd_getl_signed_16 (addr)
     register const bfd_byte *addr;
d422 2
a423 1
  return COERCE16((addr[1] << 8) | addr[0]);
d427 1
a427 3
bfd_putb16 (data, addr)
     bfd_vma data;
     register bfd_byte *addr;
d429 3
a431 2
  addr[0] = (bfd_byte) (data >> 8);
  addr[1] = (bfd_byte) data;
d435 1
a435 3
bfd_putl16 (data, addr)
     bfd_vma data;
     register bfd_byte *addr;
d437 3
a439 2
  addr[0] = (bfd_byte) data;
  addr[1] = (bfd_byte) (data >> 8);
d443 1
a443 2
bfd_getb32 (addr)
     register const bfd_byte *addr;
d445 1
d452 1
a452 1
  return (bfd_vma) v;
d456 1
a456 2
bfd_getl32 (addr)
     register const bfd_byte *addr;
d458 1
d465 1
a465 1
  return (bfd_vma) v;
d469 1
a469 2
bfd_getb_signed_32 (addr)
     register const bfd_byte *addr;
d471 1
d482 1
a482 2
bfd_getl_signed_32 (addr)
     register const bfd_byte *addr;
d484 1
d494 2
a495 3
bfd_vma
bfd_getb64 (addr)
     register const bfd_byte *addr ATTRIBUTE_UNUSED;
d497 12
a508 12
#ifdef BFD64
  bfd_vma low, high;

  high= ((((((((addr[0]) << 8) |
              addr[1]) << 8) |
            addr[2]) << 8) |
          addr[3]) );

  low = (((((((((bfd_vma)addr[4]) << 8) |
              addr[5]) << 8) |
            addr[6]) << 8) |
          addr[7]));
d510 1
a510 1
  return high << 32 | low;
d517 2
a518 3
bfd_vma
bfd_getl64 (addr)
     register const bfd_byte *addr ATTRIBUTE_UNUSED;
d520 12
a531 11
#ifdef BFD64
  bfd_vma low, high;
  high= (((((((addr[7] << 8) |
              addr[6]) << 8) |
            addr[5]) << 8) |
          addr[4]));

  low = ((((((((bfd_vma)addr[3] << 8) |
              addr[2]) << 8) |
            addr[1]) << 8) |
          addr[0]) );
d533 1
a533 1
  return high << 32 | low;
d541 2
a542 3
bfd_signed_vma
bfd_getb_signed_64 (addr)
     register const bfd_byte *addr ATTRIBUTE_UNUSED;
d544 12
a555 12
#ifdef BFD64
  bfd_vma low, high;

  high= ((((((((addr[0]) << 8) |
              addr[1]) << 8) |
            addr[2]) << 8) |
          addr[3]) );

  low = (((((((((bfd_vma)addr[4]) << 8) |
              addr[5]) << 8) |
            addr[6]) << 8) |
          addr[7]));
d557 1
a557 1
  return COERCE64(high << 32 | low);
d564 2
a565 3
bfd_signed_vma
bfd_getl_signed_64 (addr)
     register const bfd_byte *addr ATTRIBUTE_UNUSED;
d567 12
a578 11
#ifdef BFD64
  bfd_vma low, high;
  high= (((((((addr[7] << 8) |
              addr[6]) << 8) |
            addr[5]) << 8) |
          addr[4]));

  low = ((((((((bfd_vma)addr[3] << 8) |
              addr[2]) << 8) |
            addr[1]) << 8) |
          addr[0]) );
d580 1
a580 1
  return COERCE64(high << 32 | low);
d588 7
a594 8
bfd_putb32 (data, addr)
     bfd_vma data;
     register bfd_byte *addr;
{
        addr[0] = (bfd_byte) (data >> 24);
        addr[1] = (bfd_byte) (data >> 16);
        addr[2] = (bfd_byte) (data >>  8);
        addr[3] = (bfd_byte) data;
d598 7
a604 8
bfd_putl32 (data, addr)
     bfd_vma data;
     register bfd_byte *addr;
{
        addr[0] = (bfd_byte) data;
        addr[1] = (bfd_byte) (data >>  8);
        addr[2] = (bfd_byte) (data >> 16);
        addr[3] = (bfd_byte) (data >> 24);
d608 12
a619 13
bfd_putb64 (data, addr)
     bfd_vma data ATTRIBUTE_UNUSED;
     register bfd_byte *addr ATTRIBUTE_UNUSED;
{
#ifdef BFD64
  addr[0] = (bfd_byte) (data >> (7*8));
  addr[1] = (bfd_byte) (data >> (6*8));
  addr[2] = (bfd_byte) (data >> (5*8));
  addr[3] = (bfd_byte) (data >> (4*8));
  addr[4] = (bfd_byte) (data >> (3*8));
  addr[5] = (bfd_byte) (data >> (2*8));
  addr[6] = (bfd_byte) (data >> (1*8));
  addr[7] = (bfd_byte) (data >> (0*8));
d626 12
a637 13
bfd_putl64 (data, addr)
     bfd_vma data ATTRIBUTE_UNUSED;
     register bfd_byte *addr ATTRIBUTE_UNUSED;
{
#ifdef BFD64
  addr[7] = (bfd_byte) (data >> (7*8));
  addr[6] = (bfd_byte) (data >> (6*8));
  addr[5] = (bfd_byte) (data >> (5*8));
  addr[4] = (bfd_byte) (data >> (4*8));
  addr[3] = (bfd_byte) (data >> (3*8));
  addr[2] = (bfd_byte) (data >> (2*8));
  addr[1] = (bfd_byte) (data >> (1*8));
  addr[0] = (bfd_byte) (data >> (0*8));
d644 1
a644 5
bfd_put_bits (data, addr, bits, big_p)
     bfd_vma data;
     bfd_byte *addr;
     int bits;
     bfd_boolean big_p;
d646 1
d658 1
a658 1
      addr[index] = (bfd_byte) data;
d663 2
a664 5
bfd_vma
bfd_get_bits (addr, bits, big_p)
     bfd_byte *addr;
     int bits;
     bfd_boolean big_p;
d666 2
a667 1
  bfd_vma data;
d689 5
a693 6
_bfd_generic_get_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     PTR location;
     file_ptr offset;
     bfd_size_type count;
d712 6
a717 6
_bfd_generic_get_section_contents_in_window (abfd, section, w, offset, count)
     bfd *abfd ATTRIBUTE_UNUSED;
     sec_ptr section ATTRIBUTE_UNUSED;
     bfd_window *w ATTRIBUTE_UNUSED;
     file_ptr offset ATTRIBUTE_UNUSED;
     bfd_size_type count ATTRIBUTE_UNUSED;
d722 2
a723 1
  if (abfd->xvec->_bfd_get_section_contents != _bfd_generic_get_section_contents)
d731 1
a731 2
      w->i = ((bfd_window_internal *)
	      bfd_zmalloc ((bfd_size_type) sizeof (bfd_window_internal)));
d734 1
a734 1
      w->i->data = (PTR) bfd_malloc (count);
d762 5
a766 6
_bfd_generic_set_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     PTR location;
     file_ptr offset;
     bfd_size_type count;
d791 1
a791 2
bfd_log2 (x)
     bfd_vma x;
d801 1
a801 3
bfd_generic_is_local_label_name (abfd, name)
     bfd *abfd;
     const char *name;
d812 1
a812 3
_bfd_generic_verify_endian_match (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d838 4
a841 5
warn_deprecated (what, file, line, func)
     const char *what;
     const char *file;
     int line;
     const char *func;
@


1.5
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2000, 2001
d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a30 2
static int real_read PARAMS ((PTR, size_t, size_t, FILE *));

d44 1
a44 1
boolean
d49 1
a49 1
  return false;
d55 1
a55 1
boolean
d59 1
a59 1
  return true;
d111 1
a111 1
boolean
d117 1
a117 1
  return false;
d154 1
a154 1
     size_t size;
d158 8
a165 2
  ptr = (PTR) malloc (size);
  if (ptr == NULL && size != 0)
d167 1
d176 1
a176 1
     size_t size;
d180 6
d187 1
a187 1
    ret = malloc (size);
d189 1
a189 1
    ret = realloc (ptr, size);
d191 1
a191 1
  if (ret == NULL)
d201 1
a201 1
     size_t size;
d205 5
a209 1
  ptr = (PTR) malloc (size);
d211 3
a213 1
  if (size != 0)
d218 1
a218 1
	memset (ptr, 0, size);
a222 368

/* Some IO code */

/* Note that archive entries don't have streams; they share their parent's.
   This allows someone to play with the iostream behind BFD's back.

   Also, note that the origin pointer points to the beginning of a file's
   contents (0 for non-archive elements).  For archive entries this is the
   first octet in the file, NOT the beginning of the archive header.  */

static int
real_read (where, a,b, file)
     PTR where;
     size_t a;
     size_t b;
     FILE *file;
{
  /* FIXME - this looks like an optimization, but it's really to cover
     up for a feature of some OSs (not solaris - sigh) that
     ld/pe-dll.c takes advantage of (apparently) when it creates BFDs
     internally and tries to link against them.  BFD seems to be smart
     enough to realize there are no symbol records in the "file" that
     doesn't exist but attempts to read them anyway.  On Solaris,
     attempting to read zero bytes from a NULL file results in a core
     dump, but on other platforms it just returns zero bytes read.
     This makes it to something reasonable. - DJ */
  if (a == 0 || b == 0)
    return 0;


#if defined (__VAX) && defined (VMS)
  /* Apparently fread on Vax VMS does not keep the record length
     information.  */
  return read (fileno (file), where, a * b);
#else
  return fread (where, a, b, file);
#endif
}

/* Return value is amount read (FIXME: how are errors and end of file dealt
   with?  We never call bfd_set_error, which is probably a mistake).  */

bfd_size_type
bfd_read (ptr, size, nitems, abfd)
     PTR ptr;
     bfd_size_type size;
     bfd_size_type nitems;
     bfd *abfd;
{
  int nread;

  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    {
      struct bfd_in_memory *bim;
      bfd_size_type get;

      bim = (struct bfd_in_memory *) abfd->iostream;
      get = size * nitems;
      if (abfd->where + get > bim->size)
	{
	  if (bim->size < (bfd_size_type) abfd->where)
	    get = 0;
	  else
	    get = bim->size - abfd->where;
	  bfd_set_error (bfd_error_file_truncated);
	}
      memcpy (ptr, bim->buffer + abfd->where, get);
      abfd->where += get;
      return get;
    }

  nread = real_read (ptr, 1, (size_t) (size*nitems), bfd_cache_lookup(abfd));
  if (nread > 0)
    abfd->where += nread;

  /* Set bfd_error if we did not read as much data as we expected.

     If the read failed due to an error set the bfd_error_system_call,
     else set bfd_error_file_truncated.

     A BFD backend may wish to override bfd_error_file_truncated to
     provide something more useful (eg. no_symbols or wrong_format).  */
  if (nread != (int) (size * nitems))
    {
      if (ferror (bfd_cache_lookup (abfd)))
	bfd_set_error (bfd_error_system_call);
      else
	bfd_set_error (bfd_error_file_truncated);
    }

  return nread;
}

/* The window support stuff should probably be broken out into
   another file....  */
/* The idea behind the next and refcount fields is that one mapped
   region can suffice for multiple read-only windows or multiple
   non-overlapping read-write windows.  It's not implemented yet
   though.  */
struct _bfd_window_internal {
  struct _bfd_window_internal *next;
  PTR data;
  bfd_size_type size;
  int refcount : 31;		/* should be enough...  */
  unsigned mapped : 1;		/* 1 = mmap, 0 = malloc */
};

void
bfd_init_window (windowp)
     bfd_window *windowp;
{
  windowp->data = 0;
  windowp->i = 0;
  windowp->size = 0;
}

/* Currently, if USE_MMAP is undefined, none if the window stuff is
   used.  Okay, so it's mis-named.  At least the command-line option
   "--without-mmap" is more obvious than "--without-windows" or some
   such.  */
#ifdef USE_MMAP

#undef HAVE_MPROTECT /* code's not tested yet */

#if HAVE_MMAP || HAVE_MPROTECT || HAVE_MADVISE
#include <sys/mman.h>
#endif

#ifndef MAP_FILE
#define MAP_FILE 0
#endif

static int debug_windows;

void
bfd_free_window (windowp)
     bfd_window *windowp;
{
  bfd_window_internal *i = windowp->i;
  windowp->i = 0;
  windowp->data = 0;
  if (i == 0)
    return;
  i->refcount--;
  if (debug_windows)
    fprintf (stderr, "freeing window @@%p<%p,%lx,%p>\n",
	     windowp, windowp->data, windowp->size, windowp->i);
  if (i->refcount != 0)
    return;

  if (i->mapped)
    {
#ifdef HAVE_MMAP
      munmap (i->data, i->size);
      goto no_free;
#else
      abort ();
#endif
    }
#ifdef HAVE_MPROTECT
  mprotect (i->data, i->size, PROT_READ | PROT_WRITE);
#endif
  free (i->data);
#ifdef HAVE_MMAP
 no_free:
#endif
  i->data = 0;
  /* There should be no more references to i at this point.  */
  free (i);
}

static int ok_to_map = 1;

boolean
bfd_get_file_window (abfd, offset, size, windowp, writable)
     bfd *abfd;
     file_ptr offset;
     bfd_size_type size;
     bfd_window *windowp;
     boolean writable;
{
  static size_t pagesize;
  bfd_window_internal *i = windowp->i;
  size_t size_to_alloc = size;

  if (debug_windows)
    fprintf (stderr, "bfd_get_file_window (%p, %6ld, %6ld, %p<%p,%lx,%p>, %d)",
	     abfd, (long) offset, (long) size,
	     windowp, windowp->data, (unsigned long) windowp->size,
	     windowp->i, writable);

  /* Make sure we know the page size, so we can be friendly to mmap.  */
  if (pagesize == 0)
    pagesize = getpagesize ();
  if (pagesize == 0)
    abort ();

  if (i == 0)
    {
      windowp->i = i = (bfd_window_internal *) bfd_zmalloc (sizeof (bfd_window_internal));
      if (i == 0)
	return false;
      i->data = 0;
    }
#ifdef HAVE_MMAP
  if (ok_to_map
      && (i->data == 0 || i->mapped == 1)
      && (abfd->flags & BFD_IN_MEMORY) == 0)
    {
      file_ptr file_offset, offset2;
      size_t real_size;
      int fd;
      FILE *f;

      /* Find the real file and the real offset into it.  */
      while (abfd->my_archive != NULL)
	{
	  offset += abfd->origin;
	  abfd = abfd->my_archive;
	}
      f = bfd_cache_lookup (abfd);
      fd = fileno (f);

      /* Compute offsets and size for mmap and for the user's data.  */
      offset2 = offset % pagesize;
      if (offset2 < 0)
	abort ();
      file_offset = offset - offset2;
      real_size = offset + size - file_offset;
      real_size = real_size + pagesize - 1;
      real_size -= real_size % pagesize;

      /* If we're re-using a memory region, make sure it's big enough.  */
      if (i->data && i->size < size)
	{
	  munmap (i->data, i->size);
	  i->data = 0;
	}
      i->data = mmap (i->data, real_size,
		      writable ? PROT_WRITE | PROT_READ : PROT_READ,
		      (writable
		       ? MAP_FILE | MAP_PRIVATE
		       : MAP_FILE | MAP_SHARED),
		      fd, file_offset);
      if (i->data == (PTR) -1)
	{
	  /* An error happened.  Report it, or try using malloc, or
	     something.  */
	  bfd_set_error (bfd_error_system_call);
	  i->data = 0;
	  windowp->data = 0;
	  if (debug_windows)
	    fprintf (stderr, "\t\tmmap failed!\n");
	  return false;
	}
      if (debug_windows)
	fprintf (stderr, "\n\tmapped %ld at %p, offset is %ld\n",
		 (long) real_size, i->data, (long) offset2);
      i->size = real_size;
      windowp->data = (PTR) ((bfd_byte *) i->data + offset2);
      windowp->size = size;
      i->mapped = 1;
      return true;
    }
  else if (debug_windows)
    {
      if (ok_to_map)
	fprintf (stderr, _("not mapping: data=%lx mapped=%d\n"),
		 (unsigned long) i->data, (int) i->mapped);
      else
	fprintf (stderr, _("not mapping: env var not set\n"));
    }
#else
  ok_to_map = 0;
#endif

#ifdef HAVE_MPROTECT
  if (!writable)
    {
      size_to_alloc += pagesize - 1;
      size_to_alloc -= size_to_alloc % pagesize;
    }
#endif
  if (debug_windows)
    fprintf (stderr, "\n\t%s(%6ld)",
	     i->data ? "realloc" : " malloc", (long) size_to_alloc);
  i->data = (PTR) bfd_realloc (i->data, size_to_alloc);
  if (debug_windows)
    fprintf (stderr, "\t-> %p\n", i->data);
  i->refcount = 1;
  if (i->data == NULL)
    {
      if (size_to_alloc == 0)
	return true;
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
  if (bfd_seek (abfd, offset, SEEK_SET) != 0)
    return false;
  i->size = bfd_read (i->data, size, 1, abfd);
  if (i->size != size)
    return false;
  i->mapped = 0;
#ifdef HAVE_MPROTECT
  if (!writable)
    {
      if (debug_windows)
	fprintf (stderr, "\tmprotect (%p, %ld, PROT_READ)\n", i->data,
		 (long) i->size);
      mprotect (i->data, i->size, PROT_READ);
    }
#endif
  windowp->data = i->data;
  windowp->size = i->size;
  return true;
}

#endif /* USE_MMAP */

bfd_size_type
bfd_write (ptr, size, nitems, abfd)
     CONST PTR ptr;
     bfd_size_type size;
     bfd_size_type nitems;
     bfd *abfd;
{
  long nwrote;

  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    {
      struct bfd_in_memory *bim = (struct bfd_in_memory *) (abfd->iostream);
      size *= nitems;
      if (abfd->where + size > bim->size)
	{
	  long newsize, oldsize = (bim->size + 127) & ~127;
	  bim->size = abfd->where + size;
	  /* Round up to cut down on memory fragmentation */
	  newsize = (bim->size + 127) & ~127;
	  if (newsize > oldsize)
	    {
	      bim->buffer = bfd_realloc (bim->buffer, newsize);
	      if (bim->buffer == 0)
		{
		  bim->size = 0;
		  return 0;
		}
	    }
	}
      memcpy (bim->buffer + abfd->where, ptr, size);
      abfd->where += size;
      return size;
    }

  nwrote = fwrite (ptr, 1, (size_t) (size * nitems),
		   bfd_cache_lookup (abfd));
  if (nwrote > 0)
    abfd->where += nwrote;
  if ((bfd_size_type) nwrote != size * nitems)
    {
#ifdef ENOSPC
      if (nwrote >= 0)
	errno = ENOSPC;
#endif
      bfd_set_error (bfd_error_system_call);
    }
  return nwrote;
}

d228 1
a228 1
	void bfd_write_bigendian_4byte_int(bfd *abfd,  int i);
d236 1
a236 1
void
d239 1
a239 1
     int i;
d242 2
a243 3
  bfd_putb32(i, buffer);
  if (bfd_write((PTR)buffer, 4, 1, abfd) != 4)
    abort ();
a245 180
long
bfd_tell (abfd)
     bfd *abfd;
{
  file_ptr ptr;

  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    return abfd->where;

  ptr = ftell (bfd_cache_lookup(abfd));

  if (abfd->my_archive)
    ptr -= abfd->origin;
  abfd->where = ptr;
  return ptr;
}

int
bfd_flush (abfd)
     bfd *abfd;
{
  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    return 0;
  return fflush (bfd_cache_lookup(abfd));
}

/* Returns 0 for success, negative value for failure (in which case
   bfd_get_error can retrieve the error code).  */
int
bfd_stat (abfd, statbuf)
     bfd *abfd;
     struct stat *statbuf;
{
  FILE *f;
  int result;

  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    abort ();

  f = bfd_cache_lookup (abfd);
  if (f == NULL)
    {
      bfd_set_error (bfd_error_system_call);
      return -1;
    }
  result = fstat (fileno (f), statbuf);
  if (result < 0)
    bfd_set_error (bfd_error_system_call);
  return result;
}

/* Returns 0 for success, nonzero for failure (in which case bfd_get_error
   can retrieve the error code).  */

int
bfd_seek (abfd, position, direction)
     bfd *abfd;
     file_ptr position;
     int direction;
{
  int result;
  FILE *f;
  file_ptr file_position;
  /* For the time being, a BFD may not seek to it's end.  The problem
     is that we don't easily have a way to recognize the end of an
     element in an archive.  */

  BFD_ASSERT (direction == SEEK_SET || direction == SEEK_CUR);

  if (direction == SEEK_CUR && position == 0)
    return 0;

  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    {
      struct bfd_in_memory *bim;

      bim = (struct bfd_in_memory *) abfd->iostream;

      if (direction == SEEK_SET)
	abfd->where = position;
      else
	abfd->where += position;

      if ((bfd_size_type) abfd->where > bim->size)
	{
	  if ((abfd->direction == write_direction) ||
	      (abfd->direction == both_direction))
	    {
	      long newsize, oldsize = (bim->size + 127) & ~127;
	      bim->size = abfd->where;
	      /* Round up to cut down on memory fragmentation */
	      newsize = (bim->size + 127) & ~127;
	      if (newsize > oldsize)
	        {
		  bim->buffer = bfd_realloc (bim->buffer, newsize);
		  if (bim->buffer == 0)
		    {
		      bim->size = 0;
		      bfd_set_error (bfd_error_no_memory);
		      return -1;
		    }
	        }
	    }
	  else
	    {
	      abfd->where = bim->size;
	      bfd_set_error (bfd_error_file_truncated);
	      return -1;
	    }
	}
      return 0;
    }

  if (abfd->format != bfd_archive && abfd->my_archive == 0)
    {
#if 0
      /* Explanation for this code: I'm only about 95+% sure that the above
	 conditions are sufficient and that all i/o calls are properly
	 adjusting the `where' field.  So this is sort of an `assert'
	 that the `where' field is correct.  If we can go a while without
	 tripping the abort, we can probably safely disable this code,
	 so that the real optimizations happen.  */
      file_ptr where_am_i_now;
      where_am_i_now = ftell (bfd_cache_lookup (abfd));
      if (abfd->my_archive)
	where_am_i_now -= abfd->origin;
      if (where_am_i_now != abfd->where)
	abort ();
#endif
      if (direction == SEEK_SET && position == abfd->where)
	return 0;
    }
  else
    {
      /* We need something smarter to optimize access to archives.
	 Currently, anything inside an archive is read via the file
	 handle for the archive.  Which means that a bfd_seek on one
	 component affects the `current position' in the archive, as
	 well as in any other component.

	 It might be sufficient to put a spike through the cache
	 abstraction, and look to the archive for the file position,
	 but I think we should try for something cleaner.

	 In the meantime, no optimization for archives.  */
    }

  f = bfd_cache_lookup (abfd);
  file_position = position;
  if (direction == SEEK_SET && abfd->my_archive != NULL)
    file_position += abfd->origin;

  result = fseek (f, file_position, direction);
  if (result != 0)
    {
      int hold_errno = errno;

      /* Force redetermination of `where' field.  */
      bfd_tell (abfd);

      /* An EINVAL error probably means that the file offset was
         absurd.  */
      if (hold_errno == EINVAL)
	bfd_set_error (bfd_error_file_truncated);
      else
	{
	  bfd_set_error (bfd_error_system_call);
	  errno = hold_errno;
	}
    }
  else
    {
      /* Adjust `where' field.  */
      if (direction == SEEK_SET)
	abfd->where = position;
      else
	abfd->where += position;
    }
  return result;
}
d290 1
a290 1
.                (*(unsigned char *) (ptr))
d292 1
a292 1
.		((*(unsigned char *) (ptr) ^ 0x80) - 0x80)
d322 1
a322 1
.                ((bits) == 8 ? bfd_get_8 (abfd, ptr)		\
d329 1
a329 1
.                ((bits) == 8 ? bfd_put_8 (abfd, val, ptr)	\
d344 1
a344 1
	bretheren, except that they are used for removing information
d352 1
a352 1
.		bfd_put_8 (abfd, val, ptr)
d354 1
a354 1
.		bfd_put_8 (abfd, val, ptr)
d356 1
a356 1
.		bfd_get_8 (abfd, ptr)
d358 1
a358 1
.		bfd_get_signed_8 (abfd, ptr)
d361 1
a361 1
.                BFD_SEND(abfd, bfd_h_putx16,(val,ptr))
d363 1
a363 1
.		 bfd_h_put_16
d365 1
a365 1
.                BFD_SEND(abfd, bfd_h_getx16,(ptr))
d367 1
a367 1
.		 BFD_SEND(abfd, bfd_h_getx_signed_16, (ptr))
d370 1
a370 1
.                BFD_SEND(abfd, bfd_h_putx32,(val,ptr))
d372 1
a372 1
.		 bfd_h_put_32
d374 1
a374 1
.                BFD_SEND(abfd, bfd_h_getx32,(ptr))
d376 1
a376 1
.		 BFD_SEND(abfd, bfd_h_getx_signed_32, (ptr))
d379 1
a379 1
.                BFD_SEND(abfd, bfd_h_putx64,(val, ptr))
d381 1
a381 1
.		 bfd_h_put_64
d383 1
a383 1
.                BFD_SEND(abfd, bfd_h_getx64,(ptr))
d385 7
a391 1
.		 BFD_SEND(abfd, bfd_h_getx_signed_64, (ptr))
d393 42
a434 1
*/
d702 1
a702 1
     boolean big_p;
d724 1
a724 1
     boolean big_p;
d747 1
a747 1
boolean
d756 1
a756 1
    return true;
d758 1
a758 1
  if ((bfd_size_type) (offset + count) > section->_raw_size)
d761 1
a761 1
      return false;
d765 2
a766 2
      || bfd_read (location, (bfd_size_type) 1, count, abfd) != count)
    return false;
d768 1
a768 1
  return true;
d771 1
a771 1
boolean
d781 1
a781 1
    return true;
d790 2
a791 1
      w->i = (bfd_window_internal *) bfd_zmalloc (sizeof (bfd_window_internal));
d793 2
a794 2
	return false;
      w->i->data = (PTR) bfd_malloc ((size_t) count);
d799 1
a799 1
	  return false;
d807 5
a811 5
  if ((bfd_size_type) (offset+count) > section->_raw_size
      || (bfd_get_file_window (abfd, section->filepos + offset, count, w, true)
	  == false))
    return false;
  return true;
d821 1
a821 1
boolean
d830 1
a830 1
    return true;
d832 3
a834 3
  if (bfd_seek (abfd, (file_ptr) (section->filepos + offset), SEEK_SET) == -1
      || bfd_write (location, (bfd_size_type) 1, count, abfd) != count)
    return false;
d836 1
a836 1
  return true;
d844 1
a844 1
	unsigned int bfd_log2(bfd_vma x);
d848 1
a848 1
	@@var{x} of 1025 returns 11.
d862 1
a862 1
boolean
d869 1
a869 1
  return (name[0] == locals_prefix);
d874 2
a875 2
    true for a match, otherwise returns false and emits an error.  */
boolean
d891 1
a891 1
      (*_bfd_error_handler) (msg, bfd_get_filename (ibfd));
d894 1
a894 1
      return false;
d897 27
a923 1
  return true;
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
a45 1
/*ARGSUSED*/
a56 1
/*ARGSUSED*/
a66 1
/*ARGSUSED*/
d75 1
a75 2
/*ARGSUSED*/
int 
d82 1
a82 2
/*ARGSUSED*/
unsigned int 
a88 1
/*ARGUSED*/
a98 1
/*ARGSUSED*/
d107 1
a107 2
/*ARGSUSED*/
void 
a112 1
/*ARGSUSED*/
a124 1
/*ARGSUSED*/
a135 1
/*ARGSUSED*/
a143 1
/*ARGSUSED*/
a208 1

d214 1
a214 1
   first octet in the file, NOT the beginning of the archive header. */
d235 1
d277 1
a277 1
  nread = real_read (ptr, 1, (size_t)(size*nitems), bfd_cache_lookup(abfd));
d309 1
a309 1
  int refcount : 31;		/* should be enough... */
d663 1
a663 1
     element in an archive. */
d675 1
a675 1
      
d680 1
a680 1
      
d683 24
a706 3
	  abfd->where = bim->size;
	  bfd_set_error (bfd_error_file_truncated);
	  return -1;
a707 1
      
a750 1

d787 1
a787 1
                             functions in swap.h #ifdef __GNUC__. 
d818 1
a818 1
.                ((void) (*((unsigned char *)(ptr)) = (unsigned char)(val)))
d822 1
a822 1
.                (*(unsigned char *)(ptr))
d824 1
a824 1
.		((*(unsigned char *)(ptr) ^ 0x80) - 0x80)
d867 1
a867 1
*/ 
d919 1
a919 1
*/ 
d962 2
a963 2
  addr[0] = (bfd_byte)(data >> 8);
  addr[1] = (bfd_byte )data;
d968 1
a968 1
     bfd_vma data;             
d971 2
a972 2
  addr[0] = (bfd_byte )data;
  addr[1] = (bfd_byte)(data >> 8);
d1127 4
a1130 4
        addr[0] = (bfd_byte)(data >> 24);
        addr[1] = (bfd_byte)(data >> 16);
        addr[2] = (bfd_byte)(data >>  8);
        addr[3] = (bfd_byte)data;
d1138 4
a1141 4
        addr[0] = (bfd_byte)data;
        addr[1] = (bfd_byte)(data >>  8);
        addr[2] = (bfd_byte)(data >> 16);
        addr[3] = (bfd_byte)(data >> 24);
d1150 8
a1157 8
  addr[0] = (bfd_byte)(data >> (7*8));
  addr[1] = (bfd_byte)(data >> (6*8));
  addr[2] = (bfd_byte)(data >> (5*8));
  addr[3] = (bfd_byte)(data >> (4*8));
  addr[4] = (bfd_byte)(data >> (3*8));
  addr[5] = (bfd_byte)(data >> (2*8));
  addr[6] = (bfd_byte)(data >> (1*8));
  addr[7] = (bfd_byte)(data >> (0*8));
d1169 8
a1176 8
  addr[7] = (bfd_byte)(data >> (7*8));
  addr[6] = (bfd_byte)(data >> (6*8));
  addr[5] = (bfd_byte)(data >> (5*8));
  addr[4] = (bfd_byte)(data >> (4*8));
  addr[3] = (bfd_byte)(data >> (3*8));
  addr[2] = (bfd_byte)(data >> (2*8));
  addr[1] = (bfd_byte)(data >> (1*8));
  addr[0] = (bfd_byte)(data >> (0*8));
d1181 48
d1365 1
d1368 8
a1375 5
      (*_bfd_error_handler)
	("%s: compiled for a %s endian system and target is %s endian",
	 bfd_get_filename (ibfd),
	 bfd_big_endian (ibfd) ? "big" : "little",
	 bfd_big_endian (obfd) ? "big" : "little");
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d48 1
a48 1
     bfd *ignore;
d60 1
a60 1
     bfd *ignore;
d71 1
a71 1
     bfd *ignore;
d80 1
a80 1
     bfd *ignore;
d88 1
a88 1
     bfd *ignore;
d96 1
a96 1
     bfd *ignore;
d107 1
a107 1
     bfd *ignore_abfd;
d116 1
a116 1
     bfd *ignore;
d123 2
a124 2
     bfd *ignore_core_bfd;
     bfd *ignore_exec_bfd;
d136 1
a136 1
     bfd *ignore_abfd;
d148 1
a148 1
     bfd *ignore_abfd;
d157 1
a157 1
     bfd *ignore_abfd;
d235 17
d253 1
d277 4
a280 1
	  get = bim->size - abfd->where;
d299 1
a299 1
  if (nread < (int)(size * nitems))
d332 6
a341 1
#include <sys/types.h>
a350 6
/* Currently, if USE_MMAP is undefined, none if the window stuff is
   used.  Okay, so it's mis-named.  At least the command-line option
   "--without-mmap" is more obvious than "--without-windows" or some
   such.  */
#ifdef USE_MMAP

a386 1
#endif
a401 4
#ifndef USE_MMAP
  abort ();
#endif

d484 1
a484 1
	fprintf (stderr, "not mapping: data=%lx mapped=%d\n",
d487 1
a487 1
	fprintf (stderr, "not mapping: env var not set\n");
d534 2
d546 23
a568 1
    abort ();
d683 4
d691 8
d745 2
d749 10
a758 1
      bfd_set_error (bfd_error_system_call);
d810 1
a810 1
.                (*((unsigned char *)(ptr)) = (unsigned char)(val))
d845 14
d915 2
a916 1
#define COERCE32(x) (((bfd_signed_vma) (x) ^ 0x80000000) - 0x80000000)
d971 7
a977 2
  return (((((bfd_vma)addr[0] << 8) | addr[1]) << 8)
	  | addr[2]) << 8 | addr[3];
d984 7
a990 2
  return (((((bfd_vma)addr[3] << 8) | addr[2]) << 8)
	  | addr[1]) << 8 | addr[0];
d997 7
a1003 2
  return COERCE32((((((bfd_vma)addr[0] << 8) | addr[1]) << 8)
		   | addr[2]) << 8 | addr[3]);
d1010 7
a1016 2
  return COERCE32((((((bfd_vma)addr[3] << 8) | addr[2]) << 8)
		   | addr[1]) << 8 | addr[0]);
d1021 1
a1021 1
     register const bfd_byte *addr;
d1045 1
a1045 1
     register const bfd_byte *addr;
d1069 1
a1069 1
     register const bfd_byte *addr;
d1093 1
a1093 1
     register const bfd_byte *addr;
d1138 2
a1139 2
     bfd_vma data;
     register bfd_byte *addr;
d1157 2
a1158 2
     bfd_vma data;
     register bfd_byte *addr;
d1184 14
a1197 7
    if (count == 0)
        return true;
    if ((bfd_size_type)(offset+count) > section->_raw_size
        || bfd_seek(abfd, (file_ptr)(section->filepos + offset), SEEK_SET) == -1
        || bfd_read(location, (bfd_size_type)1, count, abfd) != count)
        return (false); /* on error */
    return (true);
d1202 5
a1206 5
     bfd *abfd;
     sec_ptr section;
     bfd_window *w;
     file_ptr offset;
     bfd_size_type count;
d1279 2
a1280 2
unsigned
bfd_log2(x)
d1283 4
a1286 3
  unsigned result = 0;
  while ( (bfd_vma)(1<< result) < x)
    result++;
d1291 1
a1291 1
bfd_generic_is_local_label (abfd, sym)
d1293 1
a1293 1
     asymbol *sym;
d1297 1
a1297 1
  return (sym->name[0] == locals_prefix);
d1300 23
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d25 4
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94 Free Software Foundation, Inc.
d158 1
d160 28
a187 2
#ifndef bfd_zmalloc
/* allocate and clear storage */
d189 6
a194 1
char *
d196 1
a196 1
     bfd_size_type size;
d198 1
a198 1
  char *ptr = (char *) malloc ((size_t) size);
d200 9
a208 2
  if (ptr && size)
   memset(ptr, 0, (size_t) size);
a211 1
#endif /* bfd_zmalloc */
d244 18
a262 1
#ifdef FILE_OFFSET_IS_CHAR_INDEX
a264 1
#endif
d385 2
a386 2
	     windowp, windowp->data, windowp->size, windowp->i,
	     writable);
d402 3
a404 1
  if (ok_to_map && (i->data == 0 || i->mapped == 1))
d483 1
a483 4
  if (i->data)
    i->data = (PTR) realloc (i->data, size_to_alloc);
  else
    i->data = (PTR) malloc (size_to_alloc);
d521 7
a527 3
  long nwrote = fwrite (ptr, 1, (size_t) (size * nitems),
			bfd_cache_lookup (abfd));
#ifdef FILE_OFFSET_IS_CHAR_INDEX
a529 1
#endif
d571 3
d586 2
d600 4
d636 10
a645 1
#ifdef FILE_OFFSET_IS_CHAR_INDEX
a678 1
#endif
a694 1
#ifdef FILE_OFFSET_IS_CHAR_INDEX
a699 1
#endif
d1113 1
a1113 1
      w->i->data = (PTR) malloc ((size_t) count);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a157 1
/* Allocate memory using malloc.  */
d159 2
a160 5
PTR
bfd_malloc (size)
     size_t size;
{
  PTR ptr;
d162 1
a162 29
  ptr = (PTR) malloc (size);
  if (ptr == NULL && size != 0)
    bfd_set_error (bfd_error_no_memory);
  return ptr;
}

/* Reallocate memory using realloc.  */

PTR
bfd_realloc (ptr, size)
     PTR ptr;
     size_t size;
{
  PTR ret;

  if (ptr == NULL)
    ret = malloc (size);
  else
    ret = realloc (ptr, size);

  if (ret == NULL)
    bfd_set_error (bfd_error_no_memory);

  return ret;
}

/* Allocate memory using malloc and clear it.  */

PTR
d164 1
a164 1
     size_t size;
d166 1
a166 1
  PTR ptr;
d168 2
a169 9
  ptr = (PTR) malloc (size);

  if (size != 0)
    {
      if (ptr == NULL)
	bfd_set_error (bfd_error_no_memory);
      else
	memset (ptr, 0, size);
    }
d173 1
a205 18

  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    {
      struct bfd_in_memory *bim;
      bfd_size_type get;

      bim = (struct bfd_in_memory *) abfd->iostream;
      get = size * nitems;
      if (abfd->where + get > bim->size)
	{
	  get = bim->size - abfd->where;
	  bfd_set_error (bfd_error_file_truncated);
	}
      memcpy (ptr, bim->buffer + abfd->where, get);
      abfd->where += get;
      return get;
    }

d207 1
d210 1
d331 2
a332 2
	     windowp, windowp->data, (unsigned long) windowp->size,
	     windowp->i, writable);
d348 1
a348 3
  if (ok_to_map
      && (i->data == 0 || i->mapped == 1)
      && (abfd->flags & BFD_IN_MEMORY) == 0)
d427 4
a430 1
  i->data = (PTR) bfd_realloc (i->data, size_to_alloc);
d468 3
a470 7
  long nwrote;

  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    abort ();

  nwrote = fwrite (ptr, 1, (size_t) (size * nitems),
		   bfd_cache_lookup (abfd));
d473 1
a514 3
  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    return abfd->where;

a526 2
  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    return 0;
a538 4

  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    abort ();

d571 1
a571 10

  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    {
      if (direction == SEEK_SET)
	abfd->where = position;
      else
	abfd->where += position;
      return 0;
    }

d605 1
d622 1
d628 1
d1042 1
a1042 1
      w->i->data = (PTR) bfd_malloc ((size_t) count);
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a24 4
#ifndef HAVE_GETPAGESIZE
#define getpagesize() 2048
#endif

@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
a309 6

/* Currently, if USE_MMAP is undefined, none if the window stuff is
   used.  Okay, so it's mis-named.  At least the command-line option
   "--without-mmap" is more obvious than "--without-windows" or some
   such.  */
#ifdef USE_MMAP
d324 6
d366 1
d382 4
a517 2
#endif /* USE_MMAP */

d1185 1
a1185 1
bfd_generic_is_local_label_name (abfd, name)
d1187 1
a1187 1
     const char *name;
d1191 1
a1191 1
  return (name[0] == locals_prefix);
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
   Free Software Foundation, Inc.
d47 1
a47 1
     bfd *ignore ATTRIBUTE_UNUSED;
d59 1
a59 1
     bfd *ignore ATTRIBUTE_UNUSED;
d70 1
a70 1
     bfd *ignore ATTRIBUTE_UNUSED;
d79 1
a79 1
     bfd *ignore ATTRIBUTE_UNUSED;
d87 1
a87 1
     bfd *ignore ATTRIBUTE_UNUSED;
d95 1
a95 1
     bfd *ignore ATTRIBUTE_UNUSED;
d106 1
a106 1
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d115 1
a115 1
     bfd *ignore ATTRIBUTE_UNUSED;
d122 2
a123 2
     bfd *ignore_core_bfd ATTRIBUTE_UNUSED;
     bfd *ignore_exec_bfd ATTRIBUTE_UNUSED;
d135 1
a135 1
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d147 1
a147 1
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d156 1
a156 1
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
a233 17
  /* FIXME - this looks like an optimization, but it's really to cover
     up for a feature of some OSs (not solaris - sigh) that
     ld/pe-dll.c takes advantage of (apparently) when it creates BFDs
     internally and tries to link against them.  BFD seems to be smart
     enough to realize there are no symbol records in the "file" that
     doesn't exist but attempts to read them anyway.  On Solaris,
     attempting to read zero bytes from a NULL file results in a core
     dump, but on other platforms it just returns zero bytes read.
     This makes it to something reasonable. - DJ */
  if (a == 0 || b == 0)
    return 0;

#if defined (__VAX) && defined (VMS)
  /* Apparently fread on Vax VMS does not keep the record length
     information.  */
  return read (fileno (file), where, a * b);
#else
a234 1
#endif
d258 1
a258 4
	  if (bim->size < (bfd_size_type) abfd->where)
	    get = 0;
	  else
	    get = bim->size - abfd->where;
d277 1
a277 1
  if (nread != (int) (size * nitems))
d320 1
d463 1
a463 1
	fprintf (stderr, _("not mapping: data=%lx mapped=%d\n"),
d466 1
a466 1
	fprintf (stderr, _("not mapping: env var not set\n"));
d525 1
a525 23
    {
      struct bfd_in_memory *bim = (struct bfd_in_memory *) (abfd->iostream);
      size *= nitems;
      if (abfd->where + size > bim->size)
	{
	  long newsize, oldsize = (bim->size + 127) & ~127;
	  bim->size = abfd->where + size;
	  /* Round up to cut down on memory fragmentation */
	  newsize = (bim->size + 127) & ~127;
	  if (newsize > oldsize)
	    {
	      bim->buffer = bfd_realloc (bim->buffer, newsize);
	      if (bim->buffer == 0)
		{
		  bim->size = 0;
		  return 0;
		}
	    }
	}
      memcpy (bim->buffer + abfd->where, ptr, size);
      abfd->where += size;
      return size;
    }
a639 4
      struct bfd_in_memory *bim;

      bim = (struct bfd_in_memory *) abfd->iostream;
      
a643 8
      
      if ((bfd_size_type) abfd->where > bim->size)
	{
	  abfd->where = bim->size;
	  bfd_set_error (bfd_error_file_truncated);
	  return -1;
	}
      
a689 2
      int hold_errno = errno;

d692 1
a692 10

      /* An EINVAL error probably means that the file offset was
         absurd.  */
      if (hold_errno == EINVAL)
	bfd_set_error (bfd_error_file_truncated);
      else
	{
	  bfd_set_error (bfd_error_system_call);
	  errno = hold_errno;
	}
d744 1
a744 1
.                ((void) (*((unsigned char *)(ptr)) = (unsigned char)(val)))
a778 14
.#define bfd_get(bits, abfd, ptr)				\
.                ((bits) == 8 ? bfd_get_8 (abfd, ptr)		\
.		 : (bits) == 16 ? bfd_get_16 (abfd, ptr)	\
.		 : (bits) == 32 ? bfd_get_32 (abfd, ptr)	\
.		 : (bits) == 64 ? bfd_get_64 (abfd, ptr)	\
.		 : (abort (), (bfd_vma) - 1))
.
.#define bfd_put(bits, abfd, val, ptr)				\
.                ((bits) == 8 ? bfd_put_8 (abfd, val, ptr)	\
.		 : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)	\
.		 : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)	\
.		 : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)	\
.		 : (abort (), (void) 0))
.
d835 1
a835 2
#define COERCE32(x) \
  ((bfd_signed_vma) (long) (((unsigned long) (x) ^ 0x80000000) - 0x80000000))
d890 2
a891 7
  unsigned long v;

  v = (unsigned long) addr[0] << 24;
  v |= (unsigned long) addr[1] << 16;
  v |= (unsigned long) addr[2] << 8;
  v |= (unsigned long) addr[3];
  return (bfd_vma) v;
d898 2
a899 7
  unsigned long v;

  v = (unsigned long) addr[0];
  v |= (unsigned long) addr[1] << 8;
  v |= (unsigned long) addr[2] << 16;
  v |= (unsigned long) addr[3] << 24;
  return (bfd_vma) v;
d906 2
a907 7
  unsigned long v;

  v = (unsigned long) addr[0] << 24;
  v |= (unsigned long) addr[1] << 16;
  v |= (unsigned long) addr[2] << 8;
  v |= (unsigned long) addr[3];
  return COERCE32 (v);
d914 2
a915 7
  unsigned long v;

  v = (unsigned long) addr[0];
  v |= (unsigned long) addr[1] << 8;
  v |= (unsigned long) addr[2] << 16;
  v |= (unsigned long) addr[3] << 24;
  return COERCE32 (v);
d920 1
a920 1
     register const bfd_byte *addr ATTRIBUTE_UNUSED;
d944 1
a944 1
     register const bfd_byte *addr ATTRIBUTE_UNUSED;
d968 1
a968 1
     register const bfd_byte *addr ATTRIBUTE_UNUSED;
d992 1
a992 1
     register const bfd_byte *addr ATTRIBUTE_UNUSED;
d1037 2
a1038 2
     bfd_vma data ATTRIBUTE_UNUSED;
     register bfd_byte *addr ATTRIBUTE_UNUSED;
d1056 2
a1057 2
     bfd_vma data ATTRIBUTE_UNUSED;
     register bfd_byte *addr ATTRIBUTE_UNUSED;
d1083 7
a1089 14
  if (count == 0)
    return true;

  if ((bfd_size_type) (offset + count) > section->_raw_size)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return false;
    }

  if (bfd_seek (abfd, section->filepos + offset, SEEK_SET) != 0
      || bfd_read (location, (bfd_size_type) 1, count, abfd) != count)
    return false;

  return true;
d1094 5
a1098 5
     bfd *abfd ATTRIBUTE_UNUSED;
     sec_ptr section ATTRIBUTE_UNUSED;
     bfd_window *w ATTRIBUTE_UNUSED;
     file_ptr offset ATTRIBUTE_UNUSED;
     bfd_size_type count ATTRIBUTE_UNUSED;
d1171 2
a1172 2
unsigned int
bfd_log2 (x)
d1175 3
a1177 4
  unsigned int result = 0;

  while ((x = (x >> 1)) != 0)
    ++result;
a1190 23
/*  Can be used from / for bfd_merge_private_bfd_data to check that
    endianness matches between input and output file.  Returns
    true for a match, otherwise returns false and emits an error.  */
boolean
_bfd_generic_verify_endian_match (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  if (ibfd->xvec->byteorder != obfd->xvec->byteorder
      && obfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN)
    {
      (*_bfd_error_handler)
	("%s: compiled for a %s endian system and target is %s endian",
	 bfd_get_filename (ibfd),
	 bfd_big_endian (ibfd) ? "big" : "little",
	 bfd_big_endian (obfd) ? "big" : "little");

      bfd_set_error (bfd_error_wrong_format);
      return false;
    }

  return true;
}
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
d45 1
d57 1
d68 1
d77 2
a78 1
int
d85 2
a86 1
unsigned int
d93 1
d104 1
d113 2
a114 1
void
d120 1
d133 1
d145 1
d154 1
d220 1
d226 1
a226 1
   first octet in the file, NOT the beginning of the archive header.  */
a246 1

d288 1
a288 1
  nread = real_read (ptr, 1, (size_t) (size*nitems), bfd_cache_lookup(abfd));
d320 1
a320 1
  int refcount : 31;		/* should be enough...  */
d674 1
a674 1
     element in an archive.  */
d686 1
a686 1

d691 1
a691 1

d694 3
a696 24
	  if ((abfd->direction == write_direction) ||
	      (abfd->direction == both_direction))
	    {
	      long newsize, oldsize = (bim->size + 127) & ~127;
	      bim->size = abfd->where;
	      /* Round up to cut down on memory fragmentation */
	      newsize = (bim->size + 127) & ~127;
	      if (newsize > oldsize)
	        {
		  bim->buffer = bfd_realloc (bim->buffer, newsize);
		  if (bim->buffer == 0)
		    {
		      bim->size = 0;
		      bfd_set_error (bfd_error_no_memory);
		      return -1;
		    }
	        }
	    }
	  else
	    {
	      abfd->where = bim->size;
	      bfd_set_error (bfd_error_file_truncated);
	      return -1;
	    }
d698 1
d742 1
d779 1
a779 1
                             functions in swap.h #ifdef __GNUC__.
d810 1
a810 1
.                ((void) (*((unsigned char *) (ptr)) = (unsigned char) (val)))
d814 1
a814 1
.                (*(unsigned char *) (ptr))
d816 1
a816 1
.		((*(unsigned char *) (ptr) ^ 0x80) - 0x80)
d859 1
a859 1
*/
d911 1
a911 1
*/
d954 2
a955 2
  addr[0] = (bfd_byte) (data >> 8);
  addr[1] = (bfd_byte) data;
d960 1
a960 1
     bfd_vma data;
d963 2
a964 2
  addr[0] = (bfd_byte) data;
  addr[1] = (bfd_byte) (data >> 8);
d1119 4
a1122 4
        addr[0] = (bfd_byte) (data >> 24);
        addr[1] = (bfd_byte) (data >> 16);
        addr[2] = (bfd_byte) (data >>  8);
        addr[3] = (bfd_byte) data;
d1130 4
a1133 4
        addr[0] = (bfd_byte) data;
        addr[1] = (bfd_byte) (data >>  8);
        addr[2] = (bfd_byte) (data >> 16);
        addr[3] = (bfd_byte) (data >> 24);
d1142 8
a1149 8
  addr[0] = (bfd_byte) (data >> (7*8));
  addr[1] = (bfd_byte) (data >> (6*8));
  addr[2] = (bfd_byte) (data >> (5*8));
  addr[3] = (bfd_byte) (data >> (4*8));
  addr[4] = (bfd_byte) (data >> (3*8));
  addr[5] = (bfd_byte) (data >> (2*8));
  addr[6] = (bfd_byte) (data >> (1*8));
  addr[7] = (bfd_byte) (data >> (0*8));
d1161 8
a1168 8
  addr[7] = (bfd_byte) (data >> (7*8));
  addr[6] = (bfd_byte) (data >> (6*8));
  addr[5] = (bfd_byte) (data >> (5*8));
  addr[4] = (bfd_byte) (data >> (4*8));
  addr[3] = (bfd_byte) (data >> (3*8));
  addr[2] = (bfd_byte) (data >> (2*8));
  addr[1] = (bfd_byte) (data >> (1*8));
  addr[0] = (bfd_byte) (data >> (0*8));
a1172 48

void
bfd_put_bits (data, addr, bits, big_p)
     bfd_vma data;
     bfd_byte *addr;
     int bits;
     boolean big_p;
{
  int i;
  int bytes;

  if (bits % 8 != 0)
    abort ();

  bytes = bits / 8;
  for (i = 0; i < bytes; i++)
    {
      int index = big_p ? bytes - i - 1 : i;

      addr[index] = (bfd_byte) data;
      data >>= 8;
    }
}

bfd_vma
bfd_get_bits (addr, bits, big_p)
     bfd_byte *addr;
     int bits;
     boolean big_p;
{
  bfd_vma data;
  int i;
  int bytes;

  if (bits % 8 != 0)
    abort ();

  data = 0;
  bytes = bits / 8;
  for (i = 0; i < bytes; i++)
    {
      int index = big_p ? i : bytes - i - 1;

      data = (data << 8) | addr[index];
    }

  return data;
}
a1308 1
      && ibfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN
d1311 5
a1315 8
      const char *msg;

      if (bfd_big_endian (ibfd))
	msg = _("%s: compiled for a big endian system and target is little endian");
      else
	msg = _("%s: compiled for a little endian system and target is big endian");

      (*_bfd_error_handler) (msg, bfd_get_filename (ibfd));
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2000, 2001, 2002
d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 2
d46 1
a46 1
bfd_boolean
d51 1
a51 1
  return FALSE;
d57 1
a57 1
bfd_boolean
d61 1
a61 1
  return TRUE;
d113 1
a113 1
bfd_boolean
d119 1
a119 1
  return FALSE;
d156 1
a156 1
     bfd_size_type size;
d160 2
a161 8
  if (size != (size_t) size)
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

  ptr = (PTR) malloc ((size_t) size);
  if (ptr == NULL && (size_t) size != 0)
a162 1

d171 1
a171 1
     bfd_size_type size;
a174 6
  if (size != (size_t) size)
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

d176 1
a176 1
    ret = (PTR) malloc ((size_t) size);
d178 1
a178 1
    ret = (PTR) realloc (ptr, (size_t) size);
d180 1
a180 1
  if (ret == NULL && (size_t) size != 0)
d190 193
d384 2
d387 94
a480 1
  PTR ptr;
d482 15
a496 1
  if (size != (size_t) size)
d498 2
d501 1
a501 1
      return NULL;
d503 19
d523 10
a532 1
  ptr = (PTR) malloc ((size_t) size);
d534 1
a534 1
  if ((size_t) size != 0)
d536 21
a556 4
      if (ptr == NULL)
	bfd_set_error (bfd_error_no_memory);
      else
	memset (ptr, 0, (size_t) size);
d559 13
a571 1
  return ptr;
d573 1
d579 1
a579 1
	bfd_boolean bfd_write_bigendian_4byte_int (bfd *, unsigned int);
d587 1
a587 1
bfd_boolean
d590 1
a590 1
     unsigned int i;
d593 3
a595 2
  bfd_putb32 ((bfd_vma) i, buffer);
  return bfd_bwrite ((PTR) buffer, (bfd_size_type) 4, abfd) == 4;
d598 180
d822 1
a822 1
.                (*(unsigned char *) (ptr) & 0xff)
d824 1
a824 1
.		(((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)
d854 1
a854 1
.                ( (bits) ==  8 ? (bfd_vma) bfd_get_8 (abfd, ptr)	\
d861 1
a861 1
.                ( (bits) ==  8 ? bfd_put_8  (abfd, val, ptr)	\
d876 1
a876 1
	brethren, except that they are used for removing information
d884 1
a884 1
.  bfd_put_8 (abfd, val, ptr)
d886 1
a886 1
.  bfd_put_8 (abfd, val, ptr)
d888 1
a888 1
.  bfd_get_8 (abfd, ptr)
d890 1
a890 1
.  bfd_get_signed_8 (abfd, ptr)
d893 1
a893 1
.  BFD_SEND (abfd, bfd_h_putx16, (val, ptr))
d895 1
a895 1
.  bfd_h_put_16
d897 1
a897 1
.  BFD_SEND (abfd, bfd_h_getx16, (ptr))
d899 1
a899 1
.  BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr))
d902 1
a902 1
.  BFD_SEND (abfd, bfd_h_putx32, (val, ptr))
d904 1
a904 1
.  bfd_h_put_32
d906 1
a906 1
.  BFD_SEND (abfd, bfd_h_getx32, (ptr))
d908 1
a908 1
.  BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr))
d911 1
a911 1
.  BFD_SEND (abfd, bfd_h_putx64, (val, ptr))
d913 1
a913 1
.  bfd_h_put_64
d915 1
a915 1
.  BFD_SEND (abfd, bfd_h_getx64, (ptr))
d917 1
a917 1
.  BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr))
d919 1
a919 48
.{* Refinements on the above, which should eventually go away.  Save
.   cluttering the source with (bfd_vma) and (bfd_byte *) casts.  *}
.
.#define H_PUT_64(abfd, val, where) \
.  bfd_h_put_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))
.
.#define H_PUT_32(abfd, val, where) \
.  bfd_h_put_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))
.
.#define H_PUT_16(abfd, val, where) \
.  bfd_h_put_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))
.
.#define H_PUT_8 bfd_h_put_8
.
.#define H_PUT_S64(abfd, val, where) \
.  bfd_h_put_signed_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))
.
.#define H_PUT_S32(abfd, val, where) \
.  bfd_h_put_signed_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))
.
.#define H_PUT_S16(abfd, val, where) \
.  bfd_h_put_signed_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))
.
.#define H_PUT_S8 bfd_h_put_signed_8
.
.#define H_GET_64(abfd, where) \
.  bfd_h_get_64 ((abfd), (bfd_byte *) (where))
.
.#define H_GET_32(abfd, where) \
.  bfd_h_get_32 ((abfd), (bfd_byte *) (where))
.
.#define H_GET_16(abfd, where) \
.  bfd_h_get_16 ((abfd), (bfd_byte *) (where))
.
.#define H_GET_8 bfd_h_get_8
.
.#define H_GET_S64(abfd, where) \
.  bfd_h_get_signed_64 ((abfd), (bfd_byte *) (where))
.
.#define H_GET_S32(abfd, where) \
.  bfd_h_get_signed_32 ((abfd), (bfd_byte *) (where))
.
.#define H_GET_S16(abfd, where) \
.  bfd_h_get_signed_16 ((abfd), (bfd_byte *) (where))
.
.#define H_GET_S8 bfd_h_get_signed_8
.
.*/
d1187 1
a1187 1
     bfd_boolean big_p;
d1209 1
a1209 1
     bfd_boolean big_p;
d1232 1
a1232 1
bfd_boolean
d1241 1
a1241 1
    return TRUE;
d1243 1
a1243 1
  if (offset + count > section->_raw_size)
d1246 1
a1246 1
      return FALSE;
d1250 2
a1251 2
      || bfd_bread (location, count, abfd) != count)
    return FALSE;
d1253 1
a1253 1
  return TRUE;
d1256 1
a1256 1
bfd_boolean
d1266 1
a1266 1
    return TRUE;
d1275 1
a1275 2
      w->i = ((bfd_window_internal *)
	      bfd_zmalloc ((bfd_size_type) sizeof (bfd_window_internal)));
d1277 2
a1278 2
	return FALSE;
      w->i->data = (PTR) bfd_malloc (count);
d1283 1
a1283 1
	  return FALSE;
d1291 5
a1295 5
  if (offset + count > section->_raw_size
      || ! bfd_get_file_window (abfd, section->filepos + offset, count, w,
				TRUE))
    return FALSE;
  return TRUE;
d1305 1
a1305 1
bfd_boolean
d1314 1
a1314 1
    return TRUE;
d1316 3
a1318 3
  if (bfd_seek (abfd, section->filepos + offset, SEEK_SET) != 0
      || bfd_bwrite (location, count, abfd) != count)
    return FALSE;
d1320 1
a1320 1
  return TRUE;
d1328 1
a1328 1
	unsigned int bfd_log2 (bfd_vma x);
d1332 1
a1332 1
	@@var{x} of 1025 returns 11.  A @@var{x} of 0 returns 0.
d1346 1
a1346 1
bfd_boolean
d1353 1
a1353 1
  return name[0] == locals_prefix;
d1358 2
a1359 2
    TRUE for a match, otherwise returns FALSE and emits an error.  */
bfd_boolean
d1375 1
a1375 1
      (*_bfd_error_handler) (msg, bfd_archive_filename (ibfd));
d1378 1
a1378 1
      return FALSE;
d1381 1
a1381 27
  return TRUE;
}

/* Give a warning at runtime if someone compiles code which calls
   old routines.  */

void
warn_deprecated (what, file, line, func)
     const char *what;
     const char *file;
     int line;
     const char *func;
{
  /* Poor man's tracking of functions we've already warned about.  */
  static size_t mask = 0;

  if (~(size_t) func & ~mask)
    {
      /* Note: separate sentences in order to allow
	 for translation into other languages.  */
      if (func)
	fprintf (stderr, _("Deprecated %s called at %s line %d in %s\n"),
		 what, file, line, func);
      else
	fprintf (stderr, _("Deprecated %s called\n"), what);
      mask |= ~(size_t) func;
    }
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
d45 2
a46 1
bfd_false (bfd *ignore ATTRIBUTE_UNUSED)
d56 2
a57 1
bfd_true (bfd *ignore ATTRIBUTE_UNUSED)
d65 3
a67 2
void *
bfd_nullvoidptr (bfd *ignore ATTRIBUTE_UNUSED)
d74 2
a75 1
bfd_0 (bfd *ignore ATTRIBUTE_UNUSED)
d81 2
a82 1
bfd_0u (bfd *ignore ATTRIBUTE_UNUSED)
d88 2
a89 1
bfd_0l (bfd *ignore ATTRIBUTE_UNUSED)
d98 2
a99 1
_bfd_n1 (bfd *ignore_abfd ATTRIBUTE_UNUSED)
d106 2
a107 1
bfd_void (bfd *ignore ATTRIBUTE_UNUSED)
d112 3
a114 3
_bfd_nocore_core_file_matches_executable_p
  (bfd *ignore_core_bfd ATTRIBUTE_UNUSED,
   bfd *ignore_exec_bfd ATTRIBUTE_UNUSED)
d124 2
a125 1
_bfd_nocore_core_file_failing_command (bfd *ignore_abfd ATTRIBUTE_UNUSED)
d128 1
a128 1
  return NULL;
d135 2
a136 1
_bfd_nocore_core_file_failing_signal (bfd *ignore_abfd ATTRIBUTE_UNUSED)
d143 2
a144 1
_bfd_dummy_target (bfd *ignore_abfd ATTRIBUTE_UNUSED)
d152 3
a154 2
void *
bfd_malloc (bfd_size_type size)
d156 1
a156 1
  void *ptr;
d164 1
a164 1
  ptr = malloc ((size_t) size);
d173 4
a176 2
void *
bfd_realloc (void *ptr, bfd_size_type size)
d178 1
a178 1
  void *ret;
d187 1
a187 1
    ret = malloc ((size_t) size);
d189 1
a189 1
    ret = realloc (ptr, (size_t) size);
d199 3
a201 2
void *
bfd_zmalloc (bfd_size_type size)
d203 1
a203 1
  void *ptr;
d211 1
a211 1
  ptr = malloc ((size_t) size);
d237 3
a239 1
bfd_write_bigendian_4byte_int (bfd *abfd, unsigned int i)
d243 1
a243 1
  return bfd_bwrite (buffer, (bfd_size_type) 4, abfd) == 4;
d286 1
a286 1
.  ((void) (*((unsigned char *) (ptr)) = (val) & 0xff))
d288 1
a288 1
.  bfd_put_8
d290 1
a290 1
.  (*(unsigned char *) (ptr) & 0xff)
d292 1
a292 1
.  (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)
d295 1
a295 1
.  BFD_SEND (abfd, bfd_putx16, ((val),(ptr)))
d297 1
a297 1
.  bfd_put_16
d299 1
a299 1
.  BFD_SEND (abfd, bfd_getx16, (ptr))
d301 1
a301 1
.  BFD_SEND (abfd, bfd_getx_signed_16, (ptr))
d304 1
a304 1
.  BFD_SEND (abfd, bfd_putx32, ((val),(ptr)))
d306 1
a306 1
.  bfd_put_32
d308 1
a308 1
.  BFD_SEND (abfd, bfd_getx32, (ptr))
d310 1
a310 1
.  BFD_SEND (abfd, bfd_getx_signed_32, (ptr))
d313 1
a313 1
.  BFD_SEND (abfd, bfd_putx64, ((val), (ptr)))
d315 1
a315 1
.  bfd_put_64
d317 1
a317 1
.  BFD_SEND (abfd, bfd_getx64, (ptr))
d319 1
a319 1
.  BFD_SEND (abfd, bfd_getx_signed_64, (ptr))
d321 13
a333 13
.#define bfd_get(bits, abfd, ptr)			\
.  ((bits) == 8 ? (bfd_vma) bfd_get_8 (abfd, ptr)	\
.   : (bits) == 16 ? bfd_get_16 (abfd, ptr)		\
.   : (bits) == 32 ? bfd_get_32 (abfd, ptr)		\
.   : (bits) == 64 ? bfd_get_64 (abfd, ptr)		\
.   : (abort (), (bfd_vma) - 1))
.
.#define bfd_put(bits, abfd, val, ptr)			\
.  ((bits) == 8 ? bfd_put_8  (abfd, val, ptr)		\
.   : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)		\
.   : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)		\
.   : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)		\
.   : (abort (), (void) 0))
d387 38
a424 1
.{* Aliases for the above, which should eventually go away.  *}
d426 7
a432 16
.#define H_PUT_64  bfd_h_put_64
.#define H_PUT_32  bfd_h_put_32
.#define H_PUT_16  bfd_h_put_16
.#define H_PUT_8   bfd_h_put_8
.#define H_PUT_S64 bfd_h_put_signed_64
.#define H_PUT_S32 bfd_h_put_signed_32
.#define H_PUT_S16 bfd_h_put_signed_16
.#define H_PUT_S8  bfd_h_put_signed_8
.#define H_GET_64  bfd_h_get_64
.#define H_GET_32  bfd_h_get_32
.#define H_GET_16  bfd_h_get_16
.#define H_GET_8   bfd_h_get_8
.#define H_GET_S64 bfd_h_get_signed_64
.#define H_GET_S32 bfd_h_get_signed_32
.#define H_GET_S16 bfd_h_get_signed_16
.#define H_GET_S8  bfd_h_get_signed_8
d438 3
a440 2
#define COERCE32(x) (((bfd_signed_vma) (x) ^ 0x80000000) - 0x80000000)
#define EIGHT_GAZILLION ((bfd_int64_t) 1 << 63)
d442 1
a442 1
  (((bfd_int64_t) (x) ^ EIGHT_GAZILLION) - EIGHT_GAZILLION)
d445 2
a446 1
bfd_getb16 (const void *p)
a447 1
  const bfd_byte *addr = p;
d452 2
a453 1
bfd_getl16 (const void *p)
a454 1
  const bfd_byte *addr = p;
d459 2
a460 1
bfd_getb_signed_16 (const void *p)
d462 1
a462 2
  const bfd_byte *addr = p;
  return COERCE16 ((addr[0] << 8) | addr[1]);
d466 2
a467 1
bfd_getl_signed_16 (const void *p)
d469 1
a469 2
  const bfd_byte *addr = p;
  return COERCE16 ((addr[1] << 8) | addr[0]);
d473 3
a475 1
bfd_putb16 (bfd_vma data, void *p)
d477 2
a478 3
  bfd_byte *addr = p;
  addr[0] = (data >> 8) & 0xff;
  addr[1] = data & 0xff;
d482 3
a484 1
bfd_putl16 (bfd_vma data, void *p)
d486 2
a487 3
  bfd_byte *addr = p;
  addr[0] = data & 0xff;
  addr[1] = (data >> 8) & 0xff;
d491 2
a492 1
bfd_getb32 (const void *p)
a493 1
  const bfd_byte *addr = p;
d500 1
a500 1
  return v;
d504 2
a505 1
bfd_getl32 (const void *p)
a506 1
  const bfd_byte *addr = p;
d513 1
a513 1
  return v;
d517 2
a518 1
bfd_getb_signed_32 (const void *p)
a519 1
  const bfd_byte *addr = p;
d530 2
a531 1
bfd_getl_signed_32 (const void *p)
a532 1
  const bfd_byte *addr = p;
d542 3
a544 2
bfd_uint64_t
bfd_getb64 (const void *p ATTRIBUTE_UNUSED)
d546 12
a557 12
#ifdef BFD_HOST_64_BIT
  const bfd_byte *addr = p;
  bfd_uint64_t v;

  v  = addr[0]; v <<= 8;
  v |= addr[1]; v <<= 8;
  v |= addr[2]; v <<= 8;
  v |= addr[3]; v <<= 8;
  v |= addr[4]; v <<= 8;
  v |= addr[5]; v <<= 8;
  v |= addr[6]; v <<= 8;
  v |= addr[7];
d559 1
a559 1
  return v;
d566 3
a568 2
bfd_uint64_t
bfd_getl64 (const void *p ATTRIBUTE_UNUSED)
d570 11
a580 12
#ifdef BFD_HOST_64_BIT
  const bfd_byte *addr = p;
  bfd_uint64_t v;

  v  = addr[7]; v <<= 8;
  v |= addr[6]; v <<= 8;
  v |= addr[5]; v <<= 8;
  v |= addr[4]; v <<= 8;
  v |= addr[3]; v <<= 8;
  v |= addr[2]; v <<= 8;
  v |= addr[1]; v <<= 8;
  v |= addr[0];
d582 1
a582 1
  return v;
d590 3
a592 2
bfd_int64_t
bfd_getb_signed_64 (const void *p ATTRIBUTE_UNUSED)
d594 12
a605 12
#ifdef BFD_HOST_64_BIT
  const bfd_byte *addr = p;
  bfd_uint64_t v;

  v  = addr[0]; v <<= 8;
  v |= addr[1]; v <<= 8;
  v |= addr[2]; v <<= 8;
  v |= addr[3]; v <<= 8;
  v |= addr[4]; v <<= 8;
  v |= addr[5]; v <<= 8;
  v |= addr[6]; v <<= 8;
  v |= addr[7];
d607 1
a607 1
  return COERCE64 (v);
d614 3
a616 2
bfd_int64_t
bfd_getl_signed_64 (const void *p ATTRIBUTE_UNUSED)
d618 11
a628 12
#ifdef BFD_HOST_64_BIT
  const bfd_byte *addr = p;
  bfd_uint64_t v;

  v  = addr[7]; v <<= 8;
  v |= addr[6]; v <<= 8;
  v |= addr[5]; v <<= 8;
  v |= addr[4]; v <<= 8;
  v |= addr[3]; v <<= 8;
  v |= addr[2]; v <<= 8;
  v |= addr[1]; v <<= 8;
  v |= addr[0];
d630 1
a630 1
  return COERCE64 (v);
d638 8
a645 7
bfd_putb32 (bfd_vma data, void *p)
{
  bfd_byte *addr = p;
  addr[0] = (data >> 24) & 0xff;
  addr[1] = (data >> 16) & 0xff;
  addr[2] = (data >>  8) & 0xff;
  addr[3] = data & 0xff;
d649 8
a656 7
bfd_putl32 (bfd_vma data, void *p)
{
  bfd_byte *addr = p;
  addr[0] = data & 0xff;
  addr[1] = (data >>  8) & 0xff;
  addr[2] = (data >> 16) & 0xff;
  addr[3] = (data >> 24) & 0xff;
d660 13
a672 12
bfd_putb64 (bfd_uint64_t data ATTRIBUTE_UNUSED, void *p ATTRIBUTE_UNUSED)
{
#ifdef BFD_HOST_64_BIT
  bfd_byte *addr = p;
  addr[0] = (data >> (7*8)) & 0xff;
  addr[1] = (data >> (6*8)) & 0xff;
  addr[2] = (data >> (5*8)) & 0xff;
  addr[3] = (data >> (4*8)) & 0xff;
  addr[4] = (data >> (3*8)) & 0xff;
  addr[5] = (data >> (2*8)) & 0xff;
  addr[6] = (data >> (1*8)) & 0xff;
  addr[7] = (data >> (0*8)) & 0xff;
d679 13
a691 12
bfd_putl64 (bfd_uint64_t data ATTRIBUTE_UNUSED, void *p ATTRIBUTE_UNUSED)
{
#ifdef BFD_HOST_64_BIT
  bfd_byte *addr = p;
  addr[7] = (data >> (7*8)) & 0xff;
  addr[6] = (data >> (6*8)) & 0xff;
  addr[5] = (data >> (5*8)) & 0xff;
  addr[4] = (data >> (4*8)) & 0xff;
  addr[3] = (data >> (3*8)) & 0xff;
  addr[2] = (data >> (2*8)) & 0xff;
  addr[1] = (data >> (1*8)) & 0xff;
  addr[0] = (data >> (0*8)) & 0xff;
d698 5
a702 1
bfd_put_bits (bfd_uint64_t data, void *p, int bits, bfd_boolean big_p)
a703 1
  bfd_byte *addr = p;
d715 1
a715 1
      addr[index] = data & 0xff;
d720 5
a724 2
bfd_uint64_t
bfd_get_bits (const void *p, int bits, bfd_boolean big_p)
d726 1
a726 2
  const bfd_byte *addr = p;
  bfd_uint64_t data;
d748 6
a753 5
_bfd_generic_get_section_contents (bfd *abfd,
				   sec_ptr section,
				   void *location,
				   file_ptr offset,
				   bfd_size_type count)
d772 6
a777 6
_bfd_generic_get_section_contents_in_window
  (bfd *abfd ATTRIBUTE_UNUSED,
   sec_ptr section ATTRIBUTE_UNUSED,
   bfd_window *w ATTRIBUTE_UNUSED,
   file_ptr offset ATTRIBUTE_UNUSED,
   bfd_size_type count ATTRIBUTE_UNUSED)
d782 1
a782 2
  if (abfd->xvec->_bfd_get_section_contents
      != _bfd_generic_get_section_contents)
d790 2
a791 1
      w->i = bfd_zmalloc (sizeof (bfd_window_internal));
d794 1
a794 1
      w->i->data = bfd_malloc (count);
d822 6
a827 5
_bfd_generic_set_section_contents (bfd *abfd,
				   sec_ptr section,
				   const void *location,
				   file_ptr offset,
				   bfd_size_type count)
d852 2
a853 1
bfd_log2 (bfd_vma x)
d863 3
a865 1
bfd_generic_is_local_label_name (bfd *abfd, const char *name)
d876 3
a878 1
_bfd_generic_verify_endian_match (bfd *ibfd, bfd *obfd)
d904 5
a908 4
warn_deprecated (const char *what,
		 const char *file,
		 int line,
		 const char *func)
@


