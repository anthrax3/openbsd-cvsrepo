head	1.12;
access;
symbols
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.48
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.44
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.46
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.38
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.42
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.40
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.36
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.34
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.32
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.30
	OPENBSD_5_0:1.12.0.28
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.26
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.24
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.20
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.22
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.18
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.16
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.14
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.12
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.10
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.3.0.8
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.6
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2004.11.02.20.45.10;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.07.22.05.23;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.23.14.52.57;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.21.21.33.08;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.20.21.33.53;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.23;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.30;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.14.16.21.01;	author hugh;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.19;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	99.02.09.04.01.36;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.45.51;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.57;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.57;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.06.00;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.19.55;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.45.47;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.26.23;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.18;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.22.30;	author miod;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD back-end data structures for a.out (and similar) files.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifndef LIBAOUT_H
#define LIBAOUT_H

/* We try to encapsulate the differences in the various a.out file
   variants in a few routines, and otherwise share large masses of code.
   This means we only have to fix bugs in one place, most of the time.  */

#include "bfdlink.h"

/* Macros for accessing components in an aout header.  */

#define H_PUT_64 bfd_h_put_64
#define H_PUT_32 bfd_h_put_32
#define H_PUT_16 bfd_h_put_16
#define H_PUT_8 bfd_h_put_8
#define H_PUT_S64 bfd_h_put_signed_64
#define H_PUT_S32 bfd_h_put_signed_32
#define H_PUT_S16 bfd_h_put_signed_16
#define H_PUT_S8 bfd_h_put_signed_8
#define H_GET_64 bfd_h_get_64
#define H_GET_32 bfd_h_get_32
#define H_GET_16 bfd_h_get_16
#define H_GET_8 bfd_h_get_8
#define H_GET_S64 bfd_h_get_signed_64
#define H_GET_S32 bfd_h_get_signed_32
#define H_GET_S16 bfd_h_get_signed_16
#define H_GET_S8 bfd_h_get_signed_8

/* Parameterize the a.out code based on whether it is being built
   for a 32-bit architecture or a 64-bit architecture.  */
/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
#if ARCH_SIZE==64
#define GET_WORD H_GET_64
#define GET_SWORD H_GET_S64
#define GET_MAGIC H_GET_32
#define PUT_WORD H_PUT_64
#define PUT_MAGIC H_PUT_32
#ifndef NAME
#define NAME(x,y) CONCAT3 (x,_64_,y)
#endif
#define JNAME(x) CONCAT2 (x,_64)
#define BYTES_IN_WORD 8
#else
#if ARCH_SIZE==16
#define GET_WORD H_GET_16
#define GET_SWORD H_GET_S16
#define GET_MAGIC H_GET_16
#define PUT_WORD H_PUT_16
#define PUT_MAGIC H_PUT_16
#ifndef NAME
#define NAME(x,y) CONCAT3 (x,_16_,y)
#endif
#define JNAME(x) CONCAT2 (x,_16)
#define BYTES_IN_WORD 2
#else /* ARCH_SIZE == 32 */
#define GET_WORD H_GET_32
#define GET_SWORD H_GET_S32
#define GET_MAGIC H_GET_32
#define PUT_WORD H_PUT_32
#define PUT_MAGIC H_PUT_32
#ifndef NAME
#define NAME(x,y) CONCAT3 (x,_32_,y)
#endif
#define JNAME(x) CONCAT2 (x,_32)
#define BYTES_IN_WORD 4
#endif /* ARCH_SIZE==32 */
#endif /* ARCH_SIZE==64 */

/* Declare at file level, since used in parameter lists, which have
   weird scope.  */
struct external_exec;
struct external_nlist;
struct reloc_ext_external;
struct reloc_std_external;

/* a.out backend linker hash table entries.  */

struct aout_link_hash_entry
{
  struct bfd_link_hash_entry root;
  /* Whether this symbol has been written out.  */
  bfd_boolean written;
  /* Symbol index in output file.  */
  int indx;
};

/* a.out backend linker hash table.  */

struct aout_link_hash_table
{
  struct bfd_link_hash_table root;
};

/* Look up an entry in an a.out link hash table.  */

#define aout_link_hash_lookup(table, string, create, copy, follow) \
  ((struct aout_link_hash_entry *) \
   bfd_link_hash_lookup (&(table)->root, (string), (create), (copy), (follow)))

/* Traverse an a.out link hash table.  */

#define aout_link_hash_traverse(table, func, info)			\
  (bfd_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func), \
    (info)))

/* Get the a.out link hash table from the info structure.  This is
   just a cast.  */

#define aout_hash_table(p) ((struct aout_link_hash_table *) ((p)->hash))

/* Back-end information for various a.out targets.  */
struct aout_backend_data
{
  /* Are ZMAGIC files mapped contiguously?  If so, the text section may
     need more padding, if the segment size (granularity for memory access
     control) is larger than the page size.  */
  unsigned char zmagic_mapped_contiguous;
  /* If this flag is set, ZMAGIC/NMAGIC file headers get mapped in with the
     text section, which starts immediately after the file header.
     If not, the text section starts on the next page.  */
  unsigned char text_includes_header;

  /* If this flag is set, then if the entry address is not in the
     first SEGMENT_SIZE bytes of the text section, it is taken to be
     the address of the start of the text section.  This can be useful
     for kernels.  */
  unsigned char entry_is_text_address;

  /* The value to pass to N_SET_FLAGS.  */
  unsigned char exec_hdr_flags;

  /* If the text section VMA isn't specified, and we need an absolute
     address, use this as the default.  If we're producing a relocatable
     file, zero is always used.  */
  /* ?? Perhaps a callback would be a better choice?  Will this do anything
     reasonable for a format that handles multiple CPUs with different
     load addresses for each?  */
  bfd_vma default_text_vma;

  /* Callback for setting the page and segment sizes, if they can't be
     trivially determined from the architecture.  */
  bfd_boolean (*set_sizes)
    PARAMS ((bfd *));

  /* zmagic files only. For go32, the length of the exec header contributes
     to the size of the text section in the file for alignment purposes but
     does *not* get counted in the length of the text section. */
  unsigned char exec_header_not_counted;

  /* Callback from the add symbols phase of the linker code to handle
     a dynamic object.  */
  bfd_boolean (*add_dynamic_symbols)
    PARAMS ((bfd *, struct bfd_link_info *, struct external_nlist **,
	     bfd_size_type *, char **));

  /* Callback from the add symbols phase of the linker code to handle
     adding a single symbol to the global linker hash table.  */
  bfd_boolean (*add_one_symbol)
    PARAMS ((struct bfd_link_info *, bfd *, const char *, flagword,
	     asection *, bfd_vma, const char *, bfd_boolean, bfd_boolean,
	     struct bfd_link_hash_entry **));

  /* Called to handle linking a dynamic object.  */
  bfd_boolean (*link_dynamic_object)
    PARAMS ((struct bfd_link_info *, bfd *));

  /* Called for each global symbol being written out by the linker.
     This should write out the dynamic symbol information.  */
  bfd_boolean (*write_dynamic_symbol)
    PARAMS ((bfd *, struct bfd_link_info *, struct aout_link_hash_entry *));

  /* If this callback is not NULL, the linker calls it for each reloc.
     RELOC is a pointer to the unswapped reloc.  If *SKIP is set to
     TRUE, the reloc will be skipped.  *RELOCATION may be changed to
     change the effects of the relocation.  */
  bfd_boolean (*check_dynamic_reloc)
    PARAMS ((struct bfd_link_info *info, bfd *input_bfd,
	     asection *input_section, struct aout_link_hash_entry *h,
	     PTR reloc, bfd_byte *contents, bfd_boolean *skip,
	     bfd_vma *relocation));

  /* Called at the end of a link to finish up any dynamic linking
     information.  */
  bfd_boolean (*finish_dynamic_link)
    PARAMS ((bfd *, struct bfd_link_info *));
};
#define aout_backend_info(abfd) \
	((const struct aout_backend_data *)((abfd)->xvec->backend_data))

/* This is the layout in memory of a "struct exec" while we process it.
   All 'lengths' are given as a number of bytes.
   All 'alignments' are for relinkable files only;  an alignment of
	'n' indicates the corresponding segment must begin at an
	address that is a multiple of (2**n).  */

struct internal_exec
{
    long a_info;		/* Magic number and flags, packed */
    bfd_vma a_text;		/* length of text, in bytes  */
    bfd_vma a_data;		/* length of data, in bytes  */
    bfd_vma a_bss;		/* length of uninitialized data area in mem */
    bfd_vma a_syms;		/* length of symbol table data in file */
    bfd_vma a_entry;		/* start address */
    bfd_vma a_trsize;		/* length of text's relocation info, in bytes */
    bfd_vma a_drsize;		/* length of data's relocation info, in bytes */
    /* Added for i960 */
    bfd_vma a_tload;		/* Text runtime load address */
    bfd_vma a_dload;		/* Data runtime load address */
    unsigned char a_talign;	/* Alignment of text segment */
    unsigned char a_dalign;	/* Alignment of data segment */
    unsigned char a_balign;	/* Alignment of bss segment */
    char a_relaxable;           /* Enough info for linker relax */
};

/* Magic number is written
< MSB          >
3130292827262524232221201918171615141312111009080706050403020100
< FLAGS        >< MACHINE TYPE ><  MAGIC NUMBER                >
*/
/* Magic number for NetBSD is
<MSB           >
3130292827262524232221201918171615141312111009080706050403020100
< FLAGS    >< MACHINE TYPE     ><  MAGIC NUMBER                >
*/

enum machine_type {
  M_UNKNOWN = 0,
  M_68010 = 1,
  M_68020 = 2,
  M_SPARC = 3,
  /* Skip a bunch so we don't run into any of SUN's numbers.  */
  /* Make these up for the ns32k.  */
  M_NS32032 = (64),	/* ns32032 running ? */
  M_NS32532 = (64 + 5),	/* ns32532 running mach */

  M_386 = 100,
  M_29K = 101,          /* AMD 29000 */
  M_386_DYNIX = 102,	/* Sequent running dynix */
  M_ARM = 103,		/* Advanced Risc Machines ARM */
  M_SPARCLET = 131,	/* SPARClet = M_SPARC + 128 */
  M_386_NETBSD = 134,	/* NetBSD/i386 binary */
  M_68K_NETBSD = 135,	/* NetBSD/m68k binary */
  M_68K4K_NETBSD = 136,	/* NetBSD/m68k4k binary */
  M_532_NETBSD = 137,	/* NetBSD/ns32k binary */
  M_SPARC_NETBSD = 138,	/* NetBSD/sparc binary */
  M_PMAX_NETBSD = 139,	/* NetBSD/pmax (MIPS little-endian) binary */
  M_VAX_NETBSD = 140,	/* NetBSD/vax binary */
  M_ALPHA_NETBSD = 141,	/* NetBSD/alpha binary */
  M_ARM6_NETBSD = 143,	/* NetBSD/arm32 binary */
  M_SPARCLET_1 = 147,	/* 0x93, reserved */
  M_POWERPC_NETBSD = 149, /* NetBSD/powerpc (big-endian) binary */
  M_VAX4K_NETBSD = 150,	/* NetBSD/vax 4K pages binary */
  M_MIPS1 = 151,        /* MIPS R2000/R3000 binary */
  M_MIPS2 = 152,        /* MIPS R4000/R6000 binary */
  M_88K_OPENBSD = 153,	/* OpenBSD/m88k binary */
  M_HPPA_OPENBSD = 154,	/* OpenBSD/hppa binary */
  M_SPARC64_NETBSD = 156, /* NetBSD/sparc64 binary */
  M_X86_64_NETBSD = 157, /* NetBSD/amd64 binary */
  M_SPARCLET_2 = 163,	/* 0xa3, reserved */
  M_SPARCLET_3 = 179,	/* 0xb3, reserved */
  M_SPARCLET_4 = 195,	/* 0xc3, reserved */
  M_HP200 = 200,	/* HP 200 (68010) BSD binary */
  M_HP300 = (300 % 256), /* HP 300 (68020+68881) BSD binary */
  M_HPUX = (0x20c % 256), /* HP 200/300 HPUX binary */
  M_SPARCLET_5 = 211,	/* 0xd3, reserved */
  M_SPARCLET_6 = 227,	/* 0xe3, reserved */
  /*  M_SPARCLET_7 = 243	/ * 0xf3, reserved */
  M_SPARCLITE_LE = 243,
  M_CRIS = 255		/* Axis CRIS binary.  */
};

#define N_DYNAMIC(exec) ((exec).a_info & 0x80000000)

#ifndef N_MAGIC
# define N_MAGIC(exec) ((exec).a_info & 0xffff)
#endif

#ifndef N_MACHTYPE
# define N_MACHTYPE(exec) ((enum machine_type)(((exec).a_info >> 16) & 0xff))
#endif

#ifndef N_FLAGS
# define N_FLAGS(exec) (((exec).a_info >> 24) & 0xff)
#endif

#ifndef N_SET_INFO
# define N_SET_INFO(exec, magic, type, flags) \
((exec).a_info = ((magic) & 0xffff) \
 | (((int)(type) & 0xff) << 16) \
 | (((flags) & 0xff) << 24))
#endif

#ifndef N_SET_DYNAMIC
# define N_SET_DYNAMIC(exec, dynamic) \
((exec).a_info = (dynamic) ? (long) ((exec).a_info | 0x80000000) : \
((exec).a_info & 0x7fffffff))
#endif

#ifndef N_SET_MAGIC
# define N_SET_MAGIC(exec, magic) \
((exec).a_info = (((exec).a_info & 0xffff0000) | ((magic) & 0xffff)))
#endif

#ifndef N_SET_MACHTYPE
# define N_SET_MACHTYPE(exec, machtype) \
((exec).a_info = \
 ((exec).a_info&0xff00ffff) | ((((int)(machtype))&0xff) << 16))
#endif

#ifndef N_SET_FLAGS
# define N_SET_FLAGS(exec, flags) \
((exec).a_info = \
 ((exec).a_info&0x00ffffff) | (((flags) & 0xff) << 24))
#endif

typedef struct aout_symbol {
  asymbol symbol;
  short desc;
  char other;
  unsigned char type;
} aout_symbol_type;

/* The `tdata' struct for all a.out-like object file formats.
   Various things depend on this struct being around any time an a.out
   file is being handled.  An example is dbxread.c in GDB.  */

struct aoutdata {
  struct internal_exec *hdr;		/* exec file header */
  aout_symbol_type *symbols;		/* symtab for input bfd */

  /* For ease, we do this.  */
  asection *textsec;
  asection *datasec;
  asection *bsssec;

  /* We remember these offsets so that after check_file_format, we have
     no dependencies on the particular format of the exec_hdr.  */
  file_ptr sym_filepos;
  file_ptr str_filepos;

  /* Size of a relocation entry in external form.  */
  unsigned reloc_entry_size;

  /* Size of a symbol table entry in external form.  */
  unsigned symbol_entry_size;

  /* Page size - needed for alignment of demand paged files.  */
  unsigned long page_size;

  /* Segment size - needed for alignment of demand paged files.  */
  unsigned long segment_size;

  /* Zmagic disk block size - need to align the start of the text
     section in ZMAGIC binaries.  Normally the same as page_size.  */
  unsigned long zmagic_disk_block_size;

  unsigned exec_bytes_size;
  unsigned vma_adjusted : 1;

  /* Used when a bfd supports several highly similar formats.  */
  enum
    {
      default_format = 0,
      /* Used on HP 9000/300 running HP/UX.  See hp300hpux.c.  */
      gnu_encap_format,
      /* Used on Linux, 386BSD, etc.  See include/aout/aout64.h.  */
      q_magic_format
    } subformat;

  enum
    {
      undecided_magic = 0,
      z_magic,
      o_magic,
      n_magic
    } magic;

  /* A buffer for find_nearest_line.  */
  char *line_buf;

  /* The external symbol information.  */
  struct external_nlist *external_syms;
  bfd_size_type external_sym_count;
  bfd_window sym_window;
  char *external_strings;
  bfd_size_type external_string_size;
  bfd_window string_window;
  struct aout_link_hash_entry **sym_hashes;

  /* A pointer for shared library information.  */
  PTR dynamic_info;

  /* A mapping from local symbols to offsets into the global offset
     table, used when linking on SunOS.  This is indexed by the symbol
     index.  */
  bfd_vma *local_got_offsets;
};

struct  aout_data_struct {
    struct aoutdata a;
    struct internal_exec e;
};

#define	adata(bfd)		((bfd)->tdata.aout_data->a)
#define	exec_hdr(bfd)		(adata(bfd).hdr)
#define	obj_aout_symbols(bfd)	(adata(bfd).symbols)
#define	obj_textsec(bfd)	(adata(bfd).textsec)
#define	obj_datasec(bfd)	(adata(bfd).datasec)
#define	obj_bsssec(bfd)		(adata(bfd).bsssec)
#define	obj_sym_filepos(bfd)	(adata(bfd).sym_filepos)
#define	obj_str_filepos(bfd)	(adata(bfd).str_filepos)
#define	obj_reloc_entry_size(bfd) (adata(bfd).reloc_entry_size)
#define	obj_symbol_entry_size(bfd) (adata(bfd).symbol_entry_size)
#define obj_aout_subformat(bfd)	(adata(bfd).subformat)
#define obj_aout_external_syms(bfd) (adata(bfd).external_syms)
#define obj_aout_external_sym_count(bfd) (adata(bfd).external_sym_count)
#define obj_aout_sym_window(bfd) (adata(bfd).sym_window)
#define obj_aout_external_strings(bfd) (adata(bfd).external_strings)
#define obj_aout_external_string_size(bfd) (adata(bfd).external_string_size)
#define obj_aout_string_window(bfd) (adata(bfd).string_window)
#define obj_aout_sym_hashes(bfd) (adata(bfd).sym_hashes)
#define obj_aout_dynamic_info(bfd) (adata(bfd).dynamic_info)

/* We take the address of the first element of an asymbol to ensure that the
   macro is only ever applied to an asymbol.  */
#define aout_symbol(asymbol) ((aout_symbol_type *)(&(asymbol)->the_bfd))

/* Information we keep for each a.out section.  This is currently only
   used by the a.out backend linker.  */

struct aout_section_data_struct
{
  /* The unswapped relocation entries for this section.  */
  PTR relocs;
};

#define aout_section_data(s) \
  ((struct aout_section_data_struct *) (s)->used_by_bfd)

#define set_aout_section_data(s,v) \
  ((s)->used_by_bfd = (PTR)&(v)->relocs)

/* Prototype declarations for functions defined in aoutx.h.  */

extern bfd_boolean NAME(aout,squirt_out_relocs)
  PARAMS ((bfd *, asection *));

extern bfd_boolean NAME(aout,make_sections)
  PARAMS ((bfd *));

extern const bfd_target * NAME(aout,some_aout_object_p)
  PARAMS ((bfd *, struct internal_exec *, const bfd_target *(*) (bfd *)));

extern bfd_boolean NAME(aout,mkobject)
  PARAMS ((bfd *));

extern enum machine_type NAME(aout,machine_type)
  PARAMS ((enum bfd_architecture, unsigned long, bfd_boolean *));

extern bfd_boolean NAME(aout,set_arch_mach)
  PARAMS ((bfd *, enum bfd_architecture, unsigned long));

extern bfd_boolean NAME(aout,new_section_hook)
  PARAMS ((bfd *, asection *));

extern bfd_boolean NAME(aout,set_section_contents)
  PARAMS ((bfd *, sec_ptr, const PTR, file_ptr, bfd_size_type));

extern asymbol * NAME(aout,make_empty_symbol)
  PARAMS ((bfd *));

extern bfd_boolean NAME(aout,translate_symbol_table)
  PARAMS ((bfd *, aout_symbol_type *, struct external_nlist *, bfd_size_type,
	   char *, bfd_size_type, bfd_boolean));

extern bfd_boolean NAME(aout,slurp_symbol_table)
  PARAMS ((bfd *));

extern bfd_boolean NAME(aout,write_syms)
  PARAMS ((bfd *));

extern void NAME(aout,reclaim_symbol_table)
  PARAMS ((bfd *));

extern long NAME(aout,get_symtab_upper_bound)
  PARAMS ((bfd *));

extern long NAME(aout,canonicalize_symtab)
  PARAMS ((bfd *, asymbol **));

extern void NAME(aout,swap_ext_reloc_in)
  PARAMS ((bfd *, struct reloc_ext_external *, arelent *, asymbol **,
	   bfd_size_type));
extern void NAME(aout,swap_std_reloc_in)
  PARAMS ((bfd *, struct reloc_std_external *, arelent *, asymbol **,
	   bfd_size_type));

extern reloc_howto_type * NAME(aout,reloc_type_lookup)
  PARAMS ((bfd *, bfd_reloc_code_real_type));

extern bfd_boolean NAME(aout,slurp_reloc_table)
  PARAMS ((bfd *, sec_ptr, asymbol **));

extern long NAME(aout,canonicalize_reloc)
  PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));

extern long NAME(aout,get_reloc_upper_bound)
  PARAMS ((bfd *, sec_ptr));

extern void NAME(aout,reclaim_reloc)
  PARAMS ((bfd *, sec_ptr));

extern alent * NAME(aout,get_lineno)
  PARAMS ((bfd *, asymbol *));

extern void NAME(aout,print_symbol)
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));

extern void NAME(aout,get_symbol_info)
  PARAMS ((bfd *, asymbol *, symbol_info *));

extern bfd_boolean NAME(aout,find_nearest_line)
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));

extern long NAME(aout,read_minisymbols)
  PARAMS ((bfd *, bfd_boolean, PTR *, unsigned int *));

extern asymbol * NAME(aout,minisymbol_to_symbol)
  PARAMS ((bfd *, bfd_boolean, const PTR, asymbol *));

extern int NAME(aout,sizeof_headers)
  PARAMS ((bfd *, bfd_boolean));

extern bfd_boolean NAME(aout,adjust_sizes_and_vmas)
  PARAMS ((bfd *, bfd_size_type *, file_ptr *));

extern void NAME(aout,swap_exec_header_in)
  PARAMS ((bfd *, struct external_exec *, struct internal_exec *));

extern void NAME(aout,swap_exec_header_out)
  PARAMS ((bfd *, struct internal_exec *, struct external_exec *));

extern struct bfd_hash_entry * NAME(aout,link_hash_newfunc)
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));

extern bfd_boolean NAME(aout,link_hash_table_init)
  PARAMS ((struct aout_link_hash_table *, bfd *,
	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
				       struct bfd_hash_table *,
				       const char *)));

extern struct bfd_link_hash_table * NAME(aout,link_hash_table_create)
  PARAMS ((bfd *));

extern bfd_boolean NAME(aout,link_add_symbols)
  PARAMS ((bfd *, struct bfd_link_info *));

extern bfd_boolean NAME(aout,final_link)
  PARAMS ((bfd *, struct bfd_link_info *,
	   void (*) (bfd *, file_ptr *, file_ptr *, file_ptr *)));

extern bfd_boolean NAME(aout,bfd_free_cached_info)
  PARAMS ((bfd *));

/* A.out uses the generic versions of these routines...  */

#define	aout_16_get_section_contents	_bfd_generic_get_section_contents

#define	aout_32_get_section_contents	_bfd_generic_get_section_contents

#define	aout_64_get_section_contents	_bfd_generic_get_section_contents
#ifndef NO_WRITE_HEADER_KLUDGE
#define NO_WRITE_HEADER_KLUDGE 0
#endif

#ifndef aout_32_bfd_is_local_label_name
#define aout_32_bfd_is_local_label_name bfd_generic_is_local_label_name
#endif

#ifndef WRITE_HEADERS
#define WRITE_HEADERS(abfd, execp)					      \
      {									      \
	bfd_size_type text_size; /* dummy vars */			      \
	file_ptr text_end;						      \
	if (adata(abfd).magic == undecided_magic)			      \
	  NAME(aout,adjust_sizes_and_vmas) (abfd, &text_size, &text_end);     \
    									      \
	execp->a_syms = bfd_get_symcount (abfd) * EXTERNAL_NLIST_SIZE;	      \
	execp->a_entry = bfd_get_start_address (abfd);			      \
    									      \
	execp->a_trsize = ((obj_textsec (abfd)->reloc_count) *		      \
			   obj_reloc_entry_size (abfd));		      \
	execp->a_drsize = ((obj_datasec (abfd)->reloc_count) *		      \
			   obj_reloc_entry_size (abfd));		      \
	NAME(aout,swap_exec_header_out) (abfd, execp, &exec_bytes);	      \
									      \
	if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0		      \
	    || bfd_bwrite ((PTR) &exec_bytes, (bfd_size_type) EXEC_BYTES_SIZE, \
			  abfd) != EXEC_BYTES_SIZE)			      \
	  return FALSE;							      \
	/* Now write out reloc info, followed by syms and strings.  */	      \
  									      \
	if (bfd_get_outsymbols (abfd) != (asymbol **) NULL		      \
	    && bfd_get_symcount (abfd) != 0) 				      \
	  {								      \
	    if (bfd_seek (abfd, (file_ptr) (N_SYMOFF(*execp)), SEEK_SET) != 0)\
	      return FALSE;						      \
									      \
	    if (! NAME(aout,write_syms) (abfd))				      \
	      return FALSE;						      \
	  }								      \
									      \
	if (bfd_seek (abfd, (file_ptr) (N_TRELOFF(*execp)), SEEK_SET) != 0)   \
	  return FALSE;						      	      \
	if (!NAME(aout,squirt_out_relocs) (abfd, obj_textsec (abfd)))         \
	  return FALSE;						      	      \
									      \
	if (bfd_seek (abfd, (file_ptr) (N_DRELOFF(*execp)), SEEK_SET) != 0)   \
	  return FALSE;						      	      \
	if (!NAME(aout,squirt_out_relocs) (abfd, obj_datasec (abfd)))         \
	  return FALSE;						      	      \
      }
#endif

/* Test if a read-only section can be merged with .text.  This is
   possible if:

   1. Section has file contents and is read-only.
   2. The VMA of the section is after the end of .text and before
      the start of .data.
   3. The image is demand-pageable (otherwise, a_text in the header
      will not reflect the gap between .text and .data).  */

#define aout_section_merge_with_text_p(abfd, sec)			\
  (((sec)->flags & (SEC_HAS_CONTENTS | SEC_READONLY)) ==		\
      (SEC_HAS_CONTENTS | SEC_READONLY)					\
   && obj_textsec (abfd) != NULL					\
   && obj_datasec (abfd) != NULL					\
   && (sec)->vma >= (obj_textsec (abfd)->vma +				\
		     obj_textsec (abfd)->_cooked_size)			\
   && ((sec)->vma + (sec)->_cooked_size) <= obj_datasec (abfd)->vma	\
   && ((abfd)->flags & D_PAGED) != 0)

#endif /* ! defined (LIBAOUT_H) */
@


1.11
log
@Recognize hppa core files.
ok mickey@@, drahn@@, deraadt@@
@
text
@d3 1
a3 1
   2000, 2001, 2002
d32 1
a32 11
/* Macros for accessing components in an aout header.  Saves cluttering
   the source with (bfd_vma) and (bfd_byte *) casts.  */

#define H_PUT_64(abfd, val, where) \
  bfd_h_put_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_32(abfd, val, where) \
  bfd_h_put_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_16(abfd, val, where) \
  bfd_h_put_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))
d34 3
d38 3
a40 10

#define H_PUT_S64(abfd, val, where) \
  bfd_h_put_signed_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S32(abfd, val, where) \
  bfd_h_put_signed_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S16(abfd, val, where) \
  bfd_h_put_signed_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

d42 3
a44 10

#define H_GET_64(abfd, where) \
  bfd_h_get_64 ((abfd), (bfd_byte *) (where))

#define H_GET_32(abfd, where) \
  bfd_h_get_32 ((abfd), (bfd_byte *) (where))

#define H_GET_16(abfd, where) \
  bfd_h_get_16 ((abfd), (bfd_byte *) (where))

d46 3
a48 10

#define H_GET_S64(abfd, where) \
  bfd_h_get_signed_64 ((abfd), (bfd_byte *) (where))

#define H_GET_S32(abfd, where) \
  bfd_h_get_signed_32 ((abfd), (bfd_byte *) (where))

#define H_GET_S16(abfd, where) \
  bfd_h_get_signed_16 ((abfd), (bfd_byte *) (where))

d493 1
a493 1
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
d514 1
a514 1
extern long NAME(aout,get_symtab)
@


1.10
log
@s/M_M88K_OPENBSD/M_88K_OPENBSD/g
ok miod@@
@
text
@d310 1
@


1.9
log
@Properly recognize core dump architecture.  Add StackGhost support.
ok drahn@@
@
text
@d309 1
a309 1
  M_M88K_OPENBSD = 153,	/* OpenBSD/m88k binary */
@


1.8
log
@bfd support for OpenBSD/m88k a.out binaries, glueing existing bits together.
Gives us working objcopy, objdump, etc, and the ability to process core files
to some extent.

ok and pushed upstream kettenis@@
@
text
@d305 1
d310 2
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d308 1
@


1.6
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2000, 2001
d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d32 47
d81 3
d85 5
a89 3
#define GET_WORD bfd_h_get_64
#define GET_SWORD bfd_h_get_signed_64
#define PUT_WORD bfd_h_put_64
d91 1
a91 1
#define NAME(x,y) CAT3(x,_64_,y)
d93 1
a93 1
#define JNAME(x) CAT(x,_64)
d95 12
d108 5
a112 3
#define GET_WORD bfd_h_get_32
#define GET_SWORD bfd_h_get_signed_32
#define PUT_WORD bfd_h_put_32
d114 1
a114 1
#define NAME(x,y) CAT3(x,_32_,y)
d116 1
a116 1
#define JNAME(x) CAT(x,_32)
d119 1
d134 1
a134 1
  boolean written;
d157 1
a157 1
    (boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func),	\
d196 2
a197 1
  boolean (*set_sizes) PARAMS ((bfd *));
d206 3
a208 3
  boolean (*add_dynamic_symbols) PARAMS ((bfd *, struct bfd_link_info *,
					  struct external_nlist **,
					  bfd_size_type *, char **));
d212 4
a215 5
  boolean (*add_one_symbol) PARAMS ((struct bfd_link_info *, bfd *,
				     const char *, flagword, asection *,
				     bfd_vma, const char *, boolean,
				     boolean,
				     struct bfd_link_hash_entry **));
d218 2
a219 1
  boolean (*link_dynamic_object) PARAMS ((struct bfd_link_info *, bfd *));
d223 2
a224 2
  boolean (*write_dynamic_symbol) PARAMS ((bfd *, struct bfd_link_info *,
					   struct aout_link_hash_entry *));
d228 1
a228 1
     true, the reloc will be skipped.  *RELOCATION may be changed to
d230 5
a234 7
  boolean (*check_dynamic_reloc) PARAMS ((struct bfd_link_info *info,
					  bfd *input_bfd,
					  asection *input_section,
					  struct aout_link_hash_entry *h,
					  PTR reloc, bfd_byte *contents,
					  boolean *skip,
					  bfd_vma *relocation));
d238 2
a239 1
  boolean (*finish_dynamic_link) PARAMS ((bfd *, struct bfd_link_info *));
d242 1
a242 1
	((CONST struct aout_backend_data *)((abfd)->xvec->backend_data))
d269 1
a269 1
/* Magic number is written 
d285 4
a288 4
  /* skip a bunch so we don't run into any of suns numbers */
  /* make these up for the ns32k*/
  M_NS32032 = (64),		/* ns32032 running ? */
  M_NS32532 = (64 + 5),		/* ns32532 running mach */
d301 1
a301 1
  M_VAX1K_NETBSD = 140,	/* old NetBSD/vax binary */
d305 1
a305 1
  M_VAX_NETBSD = 150,	/* NetBSD/vax binary */
d344 1
a344 1
((exec).a_info = (dynamic) ? ((exec).a_info | 0x80000000) : \
d379 2
a380 2
  
  /* For ease, we do this */
d390 1
a390 1
  /* Size of a relocation entry in external form */
d393 1
a393 1
  /* Size of a symbol table entry in external form */
d396 1
a396 1
  /* Page size - needed for alignment of demand paged files. */
d399 1
a399 1
  /* Segment size - needed for alignment of demand paged files. */
d409 1
a409 1
  /* used when a bfd supports several highly similar formats */
d474 1
a474 1
   macro is only ever applied to an asymbol */
d492 1
a492 1
/* Prototype declarations for functions defined in aoutx.h  */
d494 2
a495 2
boolean
NAME(aout,squirt_out_relocs) PARAMS ((bfd *abfd, asection *section));
d497 2
a498 2
boolean
NAME(aout,make_sections) PARAMS ((bfd *));
d500 2
a501 4
const bfd_target *
NAME(aout,some_aout_object_p) PARAMS ((bfd *abfd,
				       struct internal_exec *execp,
				       const bfd_target *(*callback)(bfd *)));
d503 2
a504 2
boolean
NAME(aout,mkobject) PARAMS ((bfd *abfd));
d506 2
a507 4
enum machine_type
NAME(aout,machine_type) PARAMS ((enum bfd_architecture arch,
				 unsigned long machine,
				 boolean *unknown));
d509 2
a510 3
boolean
NAME(aout,set_arch_mach) PARAMS ((bfd *abfd, enum bfd_architecture arch,
		 		  unsigned long machine));
d512 2
a513 2
boolean
NAME(aout,new_section_hook) PARAMS ((bfd *abfd, asection *newsect));
d515 2
a516 3
boolean
NAME(aout,set_section_contents) PARAMS ((bfd *abfd, sec_ptr section,
			 PTR location, file_ptr offset, bfd_size_type count));
d518 2
a519 2
asymbol *
NAME(aout,make_empty_symbol) PARAMS ((bfd *abfd));
d521 3
a523 6
boolean
NAME(aout,translate_symbol_table) PARAMS ((bfd *, aout_symbol_type *,
					   struct external_nlist *,
					   bfd_size_type, char *,
					   bfd_size_type,
					   boolean dynamic));
d525 2
a526 2
boolean
NAME(aout,slurp_symbol_table) PARAMS ((bfd *abfd));
d528 2
a529 2
boolean
NAME(aout,write_syms) PARAMS ((bfd *abfd));
d531 2
a532 2
void
NAME(aout,reclaim_symbol_table) PARAMS ((bfd *abfd));
d534 2
a535 2
long
NAME(aout,get_symtab_upper_bound) PARAMS ((bfd *abfd));
d537 2
a538 2
long
NAME(aout,get_symtab) PARAMS ((bfd *abfd, asymbol **location));
d540 6
a545 6
void
NAME(aout,swap_ext_reloc_in) PARAMS ((bfd *, struct reloc_ext_external *,
				      arelent *, asymbol **, bfd_size_type));
void
NAME(aout,swap_std_reloc_in) PARAMS ((bfd *, struct reloc_std_external *,
				      arelent *, asymbol **, bfd_size_type));
d547 2
a548 3
reloc_howto_type *
NAME(aout,reloc_type_lookup) PARAMS ((bfd *abfd,
				      bfd_reloc_code_real_type code));
d550 2
a551 3
boolean
NAME(aout,slurp_reloc_table) PARAMS ((bfd *abfd, sec_ptr asect,
				      asymbol **symbols));
d553 2
a554 3
long
NAME(aout,canonicalize_reloc) PARAMS ((bfd *abfd, sec_ptr section,
				       arelent **relptr, asymbol **symbols));
d556 2
a557 2
long
NAME(aout,get_reloc_upper_bound) PARAMS ((bfd *abfd, sec_ptr asect));
d559 2
a560 2
void
NAME(aout,reclaim_reloc) PARAMS ((bfd *ignore_abfd, sec_ptr ignore));
d562 2
a563 2
alent *
NAME(aout,get_lineno) PARAMS ((bfd *ignore_abfd, asymbol *ignore_symbol));
d565 2
a566 3
void
NAME(aout,print_symbol) PARAMS ((bfd *ignore_abfd, PTR file,
			    asymbol *symbol, bfd_print_symbol_type how));
d568 2
a569 3
void
NAME(aout,get_symbol_info) PARAMS ((bfd *ignore_abfd,
                           asymbol *symbol, symbol_info *ret));
d571 3
a573 4
boolean
NAME(aout,find_nearest_line) PARAMS ((bfd *abfd, asection *section,
      asymbol **symbols, bfd_vma offset, CONST char **filename_ptr,
      CONST char **functionname_ptr, unsigned int *line_ptr));
d575 2
a576 2
long
NAME(aout,read_minisymbols) PARAMS ((bfd *, boolean, PTR *, unsigned int *));
d578 2
a579 3
asymbol *
NAME(aout,minisymbol_to_symbol) PARAMS ((bfd *, boolean, const PTR,
					 asymbol *));
d581 2
a582 2
int
NAME(aout,sizeof_headers) PARAMS ((bfd *abfd, boolean exec));
d584 2
a585 3
boolean
NAME(aout,adjust_sizes_and_vmas) PARAMS ((bfd *abfd,
       bfd_size_type *text_size, file_ptr *text_end));
d587 2
a588 3
void
NAME(aout,swap_exec_header_in) PARAMS ((bfd *abfd,
       struct external_exec *raw_bytes, struct internal_exec *execp));
d590 2
a591 3
void
NAME(aout,swap_exec_header_out) PARAMS ((bfd *abfd,
       struct internal_exec *execp, struct external_exec *raw_bytes));
d593 1
a593 2
struct bfd_hash_entry *
NAME(aout,link_hash_newfunc)
d596 11
a606 17
boolean
NAME(aout,link_hash_table_init)
     PARAMS ((struct aout_link_hash_table *, bfd *,
	      struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
					  struct bfd_hash_table *,
					  const char *)));

struct bfd_link_hash_table *
NAME(aout,link_hash_table_create) PARAMS ((bfd *));

boolean
NAME(aout,link_add_symbols) PARAMS ((bfd *, struct bfd_link_info *));

boolean
NAME(aout,final_link) PARAMS ((bfd *, struct bfd_link_info *,
			       void (*) (bfd *, file_ptr *, file_ptr *,
					 file_ptr *)));
d608 3
a610 2
boolean
NAME(aout,bfd_free_cached_info) PARAMS ((bfd *));
d612 6
a617 1
/* A.out uses the generic versions of these routines... */
d647 5
a651 5
	if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0) return false;	      \
	if (bfd_write ((PTR) &exec_bytes, 1, EXEC_BYTES_SIZE, abfd)	      \
	    != EXEC_BYTES_SIZE)						      \
	  return false;							      \
	/* Now write out reloc info, followed by syms and strings */	      \
d656 2
a657 2
	    if (bfd_seek (abfd, (file_ptr)(N_SYMOFF(*execp)), SEEK_SET) != 0) \
	      return false;						      \
d659 2
a660 1
	    if (! NAME(aout,write_syms)(abfd)) return false;		      \
d663 2
a664 2
	if (bfd_seek (abfd, (file_ptr)(N_TRELOFF(*execp)), SEEK_SET) != 0)    \
	  return false;						      	      \
d666 1
a666 1
	  return false;						      	      \
d668 25
a692 6
	if (bfd_seek (abfd, (file_ptr)(N_DRELOFF(*execp)), SEEK_SET) != 0)    \
	  return false;						      	      \
	if (!NAME(aout,squirt_out_relocs)(abfd, obj_datasec (abfd)))          \
	  return false;						      	      \
      }									      
#endif
@


1.5
log
@Change Vax aout magic and set binary page size to 4k.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 1998
d250 2
a251 1
  M_SPARCLITE_LE = 243
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d233 1
a233 1
  M_VAX_NETBSD = 140,	/* NetBSD/vax binary */
d237 1
@


1.3
log
@Adding support for Motorola mvme88k
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d109 6
d226 1
a228 1
  M_88K_NETBSD = 151,   /* NetBSD/OpendBSD m88k binary */
d232 5
a236 1
  M_SPARCLET = 142,	/* SPARClet */
d239 3
d244 5
a248 1
  M_HPUX = (0x20c % 256)/* HP 200/300 HPUX binary */
d576 2
a577 2
#ifndef aout_32_bfd_is_local_label
#define aout_32_bfd_is_local_label bfd_generic_is_local_label
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d221 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992 Free Software Foundation, Inc.
d195 1
a195 1
< MSB        >
d197 1
a197 1
< FLAGS      >< MACHINE TYPE ><  MAGIC NUMBER		       >
d200 1
a200 1
<MSB         >
d202 1
a202 1
< FLAGS    ><                  ><  MAGIC NUMBER                >
d224 1
a547 5
/* Prototypes for functions in stab-syms.c. */

CONST char *
aout_stab_name PARAMS ((int code));

d586 3
a588 6
	    {								      \
	      if (bfd_seek (abfd, (file_ptr)(N_SYMOFF(*execp)), SEEK_SET)     \
		  != 0)							      \
	        return false;						      \
									      \
	      if (! NAME(aout,write_syms)(abfd)) return false;		      \
d590 2
a591 3
	      if (bfd_seek (abfd, (file_ptr)(N_TRELOFF(*execp)), SEEK_SET)    \
		  != 0)							      \
	        return false;						      \
d593 4
a596 5
	      if (!NAME(aout,squirt_out_relocs) (abfd, obj_textsec (abfd)))   \
		return false;						      \
	      if (bfd_seek (abfd, (file_ptr)(N_DRELOFF(*execp)), SEEK_SET)    \
		  != 0)							      \
	        return false;						      \
d598 4
a601 3
	      if (!NAME(aout,squirt_out_relocs)(abfd, obj_datasec (abfd)))    \
		return false;						      \
	    }								      \
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d195 1
a195 1
< MSB          >
d197 1
a197 1
< FLAGS        >< MACHINE TYPE ><  MAGIC NUMBER                >
d200 1
a200 1
<MSB           >
d202 1
a202 1
< FLAGS    >< MACHINE TYPE     ><  MAGIC NUMBER                >
a223 1
  M_SPARCLET = 142,	/* SPARClet */
d547 5
d590 6
a595 3
	  {								      \
	    if (bfd_seek (abfd, (file_ptr)(N_SYMOFF(*execp)), SEEK_SET) != 0) \
	      return false;						      \
d597 3
a599 2
	    if (! NAME(aout,write_syms)(abfd)) return false;		      \
	  }								      \
d601 5
a605 4
	if (bfd_seek (abfd, (file_ptr)(N_TRELOFF(*execp)), SEEK_SET) != 0)    \
	  return false;						      	      \
	if (!NAME(aout,squirt_out_relocs) (abfd, obj_textsec (abfd)))         \
	  return false;						      	      \
d607 3
a609 4
	if (bfd_seek (abfd, (file_ptr)(N_DRELOFF(*execp)), SEEK_SET) != 0)    \
	  return false;						      	      \
	if (!NAME(aout,squirt_out_relocs)(abfd, obj_datasec (abfd)))          \
	  return false;						      	      \
@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
a107 6
  /* If this flag is set, then if the entry address is not in the
     first SEGMENT_SIZE bytes of the text section, it is taken to be
     the address of the start of the text section.  This can be useful
     for kernels.  */
  unsigned char entry_is_text_address;

a218 1
  M_SPARCLET = 131,	/* SPARClet = M_SPARC + 128 */
d224 1
a224 1
  M_SPARCLET_1 = 147,	/* 0x93, reserved */
a226 3
  M_SPARCLET_2 = 163,	/* 0xa3, reserved */
  M_SPARCLET_3 = 179,	/* 0xb3, reserved */
  M_SPARCLET_4 = 195,	/* 0xc3, reserved */
d229 1
a229 4
  M_HPUX = (0x20c % 256), /* HP 200/300 HPUX binary */
  M_SPARCLET_5 = 211,	/* 0xd3, reserved */
  M_SPARCLET_6 = 227,	/* 0xe3, reserved */
  M_SPARCLET_7 = 243	/* 0xf3, reserved */
d557 2
a558 2
#ifndef aout_32_bfd_is_local_label_name
#define aout_32_bfd_is_local_label_name bfd_generic_is_local_label_name
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 1998
   Free Software Foundation, Inc.
a230 4
  M_PMAX_NETBSD = 139,	/* NetBSD/pmax (MIPS little-endian) binary */
  M_VAX_NETBSD = 140,	/* NetBSD/vax binary */
  M_ALPHA_NETBSD = 141,	/* NetBSD/alpha binary */
  M_ARM6_NETBSD = 143,	/* NetBSD/arm32 binary */
d242 1
a242 2
  /*  M_SPARCLET_7 = 243	/ * 0xf3, reserved */
  M_SPARCLITE_LE = 243
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
d248 1
a248 2
  M_SPARCLITE_LE = 243,
  M_CRIS = 255		/* Axis CRIS binary.  */
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2000, 2001, 2002
d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a31 47
/* Macros for accessing components in an aout header.  Saves cluttering
   the source with (bfd_vma) and (bfd_byte *) casts.  */

#define H_PUT_64(abfd, val, where) \
  bfd_h_put_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_32(abfd, val, where) \
  bfd_h_put_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_16(abfd, val, where) \
  bfd_h_put_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_8 bfd_h_put_8

#define H_PUT_S64(abfd, val, where) \
  bfd_h_put_signed_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S32(abfd, val, where) \
  bfd_h_put_signed_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S16(abfd, val, where) \
  bfd_h_put_signed_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S8 bfd_h_put_signed_8

#define H_GET_64(abfd, where) \
  bfd_h_get_64 ((abfd), (bfd_byte *) (where))

#define H_GET_32(abfd, where) \
  bfd_h_get_32 ((abfd), (bfd_byte *) (where))

#define H_GET_16(abfd, where) \
  bfd_h_get_16 ((abfd), (bfd_byte *) (where))

#define H_GET_8 bfd_h_get_8

#define H_GET_S64(abfd, where) \
  bfd_h_get_signed_64 ((abfd), (bfd_byte *) (where))

#define H_GET_S32(abfd, where) \
  bfd_h_get_signed_32 ((abfd), (bfd_byte *) (where))

#define H_GET_S16(abfd, where) \
  bfd_h_get_signed_16 ((abfd), (bfd_byte *) (where))

#define H_GET_S8 bfd_h_get_signed_8

a33 3
/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
d35 3
a37 5
#define GET_WORD H_GET_64
#define GET_SWORD H_GET_S64
#define GET_MAGIC H_GET_32
#define PUT_WORD H_PUT_64
#define PUT_MAGIC H_PUT_32
d39 1
a39 1
#define NAME(x,y) CONCAT3 (x,_64_,y)
d41 1
a41 1
#define JNAME(x) CONCAT2 (x,_64)
a42 12
#else
#if ARCH_SIZE==16
#define GET_WORD H_GET_16
#define GET_SWORD H_GET_S16
#define GET_MAGIC H_GET_16
#define PUT_WORD H_PUT_16
#define PUT_MAGIC H_PUT_16
#ifndef NAME
#define NAME(x,y) CONCAT3 (x,_16_,y)
#endif
#define JNAME(x) CONCAT2 (x,_16)
#define BYTES_IN_WORD 2
d44 3
a46 5
#define GET_WORD H_GET_32
#define GET_SWORD H_GET_S32
#define GET_MAGIC H_GET_32
#define PUT_WORD H_PUT_32
#define PUT_MAGIC H_PUT_32
d48 1
a48 1
#define NAME(x,y) CONCAT3 (x,_32_,y)
d50 1
a50 1
#define JNAME(x) CONCAT2 (x,_32)
a52 1
#endif /* ARCH_SIZE==64 */
d67 1
a67 1
  bfd_boolean written;
d90 1
a90 1
    (bfd_boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func), \
d129 1
a129 2
  bfd_boolean (*set_sizes)
    PARAMS ((bfd *));
d138 3
a140 3
  bfd_boolean (*add_dynamic_symbols)
    PARAMS ((bfd *, struct bfd_link_info *, struct external_nlist **,
	     bfd_size_type *, char **));
d144 5
a148 4
  bfd_boolean (*add_one_symbol)
    PARAMS ((struct bfd_link_info *, bfd *, const char *, flagword,
	     asection *, bfd_vma, const char *, bfd_boolean, bfd_boolean,
	     struct bfd_link_hash_entry **));
d151 1
a151 2
  bfd_boolean (*link_dynamic_object)
    PARAMS ((struct bfd_link_info *, bfd *));
d155 2
a156 2
  bfd_boolean (*write_dynamic_symbol)
    PARAMS ((bfd *, struct bfd_link_info *, struct aout_link_hash_entry *));
d160 1
a160 1
     TRUE, the reloc will be skipped.  *RELOCATION may be changed to
d162 7
a168 5
  bfd_boolean (*check_dynamic_reloc)
    PARAMS ((struct bfd_link_info *info, bfd *input_bfd,
	     asection *input_section, struct aout_link_hash_entry *h,
	     PTR reloc, bfd_byte *contents, bfd_boolean *skip,
	     bfd_vma *relocation));
d172 1
a172 2
  bfd_boolean (*finish_dynamic_link)
    PARAMS ((bfd *, struct bfd_link_info *));
d175 1
a175 1
	((const struct aout_backend_data *)((abfd)->xvec->backend_data))
d202 1
a202 1
/* Magic number is written
d218 4
a221 4
  /* Skip a bunch so we don't run into any of SUN's numbers.  */
  /* Make these up for the ns32k.  */
  M_NS32032 = (64),	/* ns32032 running ? */
  M_NS32532 = (64 + 5),	/* ns32532 running mach */
a237 1
  M_VAX4K_NETBSD = 150,	/* NetBSD/vax 4K pages binary */
d276 1
a276 1
((exec).a_info = (dynamic) ? (long) ((exec).a_info | 0x80000000) : \
d311 2
a312 2

  /* For ease, we do this.  */
d322 1
a322 1
  /* Size of a relocation entry in external form.  */
d325 1
a325 1
  /* Size of a symbol table entry in external form.  */
d328 1
a328 1
  /* Page size - needed for alignment of demand paged files.  */
d331 1
a331 1
  /* Segment size - needed for alignment of demand paged files.  */
d341 1
a341 1
  /* Used when a bfd supports several highly similar formats.  */
d406 1
a406 1
   macro is only ever applied to an asymbol.  */
d424 1
a424 1
/* Prototype declarations for functions defined in aoutx.h.  */
d426 2
a427 2
extern bfd_boolean NAME(aout,squirt_out_relocs)
  PARAMS ((bfd *, asection *));
d429 2
a430 2
extern bfd_boolean NAME(aout,make_sections)
  PARAMS ((bfd *));
d432 4
a435 2
extern const bfd_target * NAME(aout,some_aout_object_p)
  PARAMS ((bfd *, struct internal_exec *, const bfd_target *(*) (bfd *)));
d437 2
a438 2
extern bfd_boolean NAME(aout,mkobject)
  PARAMS ((bfd *));
d440 4
a443 2
extern enum machine_type NAME(aout,machine_type)
  PARAMS ((enum bfd_architecture, unsigned long, bfd_boolean *));
d445 3
a447 2
extern bfd_boolean NAME(aout,set_arch_mach)
  PARAMS ((bfd *, enum bfd_architecture, unsigned long));
d449 2
a450 2
extern bfd_boolean NAME(aout,new_section_hook)
  PARAMS ((bfd *, asection *));
d452 3
a454 2
extern bfd_boolean NAME(aout,set_section_contents)
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
d456 2
a457 2
extern asymbol * NAME(aout,make_empty_symbol)
  PARAMS ((bfd *));
d459 6
a464 3
extern bfd_boolean NAME(aout,translate_symbol_table)
  PARAMS ((bfd *, aout_symbol_type *, struct external_nlist *, bfd_size_type,
	   char *, bfd_size_type, bfd_boolean));
d466 2
a467 2
extern bfd_boolean NAME(aout,slurp_symbol_table)
  PARAMS ((bfd *));
d469 2
a470 2
extern bfd_boolean NAME(aout,write_syms)
  PARAMS ((bfd *));
d472 2
a473 2
extern void NAME(aout,reclaim_symbol_table)
  PARAMS ((bfd *));
d475 2
a476 2
extern long NAME(aout,get_symtab_upper_bound)
  PARAMS ((bfd *));
d478 2
a479 2
extern long NAME(aout,get_symtab)
  PARAMS ((bfd *, asymbol **));
d481 6
a486 6
extern void NAME(aout,swap_ext_reloc_in)
  PARAMS ((bfd *, struct reloc_ext_external *, arelent *, asymbol **,
	   bfd_size_type));
extern void NAME(aout,swap_std_reloc_in)
  PARAMS ((bfd *, struct reloc_std_external *, arelent *, asymbol **,
	   bfd_size_type));
d488 3
a490 2
extern reloc_howto_type * NAME(aout,reloc_type_lookup)
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d492 3
a494 2
extern bfd_boolean NAME(aout,slurp_reloc_table)
  PARAMS ((bfd *, sec_ptr, asymbol **));
d496 3
a498 2
extern long NAME(aout,canonicalize_reloc)
  PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));
d500 2
a501 2
extern long NAME(aout,get_reloc_upper_bound)
  PARAMS ((bfd *, sec_ptr));
d503 2
a504 2
extern void NAME(aout,reclaim_reloc)
  PARAMS ((bfd *, sec_ptr));
d506 2
a507 2
extern alent * NAME(aout,get_lineno)
  PARAMS ((bfd *, asymbol *));
d509 3
a511 2
extern void NAME(aout,print_symbol)
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
d513 3
a515 2
extern void NAME(aout,get_symbol_info)
  PARAMS ((bfd *, asymbol *, symbol_info *));
d517 4
a520 3
extern bfd_boolean NAME(aout,find_nearest_line)
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
d522 2
a523 2
extern long NAME(aout,read_minisymbols)
  PARAMS ((bfd *, bfd_boolean, PTR *, unsigned int *));
d525 3
a527 2
extern asymbol * NAME(aout,minisymbol_to_symbol)
  PARAMS ((bfd *, bfd_boolean, const PTR, asymbol *));
d529 2
a530 2
extern int NAME(aout,sizeof_headers)
  PARAMS ((bfd *, bfd_boolean));
d532 3
a534 2
extern bfd_boolean NAME(aout,adjust_sizes_and_vmas)
  PARAMS ((bfd *, bfd_size_type *, file_ptr *));
d536 3
a538 2
extern void NAME(aout,swap_exec_header_in)
  PARAMS ((bfd *, struct external_exec *, struct internal_exec *));
d540 3
a542 2
extern void NAME(aout,swap_exec_header_out)
  PARAMS ((bfd *, struct internal_exec *, struct external_exec *));
d544 2
a545 1
extern struct bfd_hash_entry * NAME(aout,link_hash_newfunc)
d548 17
a564 11
extern bfd_boolean NAME(aout,link_hash_table_init)
  PARAMS ((struct aout_link_hash_table *, bfd *,
	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
				       struct bfd_hash_table *,
				       const char *)));

extern struct bfd_link_hash_table * NAME(aout,link_hash_table_create)
  PARAMS ((bfd *));

extern bfd_boolean NAME(aout,link_add_symbols)
  PARAMS ((bfd *, struct bfd_link_info *));
d566 2
a567 3
extern bfd_boolean NAME(aout,final_link)
  PARAMS ((bfd *, struct bfd_link_info *,
	   void (*) (bfd *, file_ptr *, file_ptr *, file_ptr *)));
d569 1
a569 6
extern bfd_boolean NAME(aout,bfd_free_cached_info)
  PARAMS ((bfd *));

/* A.out uses the generic versions of these routines...  */

#define	aout_16_get_section_contents	_bfd_generic_get_section_contents
d599 5
a603 5
	if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0		      \
	    || bfd_bwrite ((PTR) &exec_bytes, (bfd_size_type) EXEC_BYTES_SIZE, \
			  abfd) != EXEC_BYTES_SIZE)			      \
	  return FALSE;							      \
	/* Now write out reloc info, followed by syms and strings.  */	      \
d608 2
a609 2
	    if (bfd_seek (abfd, (file_ptr) (N_SYMOFF(*execp)), SEEK_SET) != 0)\
	      return FALSE;						      \
d611 1
a611 2
	    if (! NAME(aout,write_syms) (abfd))				      \
	      return FALSE;						      \
d614 2
a615 2
	if (bfd_seek (abfd, (file_ptr) (N_TRELOFF(*execp)), SEEK_SET) != 0)   \
	  return FALSE;						      	      \
d617 1
a617 1
	  return FALSE;						      	      \
d619 6
a624 25
	if (bfd_seek (abfd, (file_ptr) (N_DRELOFF(*execp)), SEEK_SET) != 0)   \
	  return FALSE;						      	      \
	if (!NAME(aout,squirt_out_relocs) (abfd, obj_datasec (abfd)))         \
	  return FALSE;						      	      \
      }
#endif

/* Test if a read-only section can be merged with .text.  This is
   possible if:

   1. Section has file contents and is read-only.
   2. The VMA of the section is after the end of .text and before
      the start of .data.
   3. The image is demand-pageable (otherwise, a_text in the header
      will not reflect the gap between .text and .data).  */

#define aout_section_merge_with_text_p(abfd, sec)			\
  (((sec)->flags & (SEC_HAS_CONTENTS | SEC_READONLY)) ==		\
      (SEC_HAS_CONTENTS | SEC_READONLY)					\
   && obj_textsec (abfd) != NULL					\
   && obj_datasec (abfd) != NULL					\
   && (sec)->vma >= (obj_textsec (abfd)->vma +				\
		     obj_textsec (abfd)->_cooked_size)			\
   && ((sec)->vma + (sec)->_cooked_size) <= obj_datasec (abfd)->vma	\
   && ((abfd)->flags & D_PAGED) != 0)
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d32 11
a42 1
/* Macros for accessing components in an aout header.  */
a43 3
#define H_PUT_64 bfd_h_put_64
#define H_PUT_32 bfd_h_put_32
#define H_PUT_16 bfd_h_put_16
d45 10
a54 3
#define H_PUT_S64 bfd_h_put_signed_64
#define H_PUT_S32 bfd_h_put_signed_32
#define H_PUT_S16 bfd_h_put_signed_16
d56 10
a65 3
#define H_GET_64 bfd_h_get_64
#define H_GET_32 bfd_h_get_32
#define H_GET_16 bfd_h_get_16
d67 10
a76 3
#define H_GET_S64 bfd_h_get_signed_64
#define H_GET_S32 bfd_h_get_signed_32
#define H_GET_S16 bfd_h_get_signed_16
d516 1
a516 1
  PARAMS ((bfd *, sec_ptr, const PTR, file_ptr, bfd_size_type));
d537 1
a537 1
extern long NAME(aout,canonicalize_symtab)
@


