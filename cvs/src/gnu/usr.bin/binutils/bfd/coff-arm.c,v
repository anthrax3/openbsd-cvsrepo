head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.52
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.14
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.03;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.20;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.29;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.06;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.11.23.03.32.45;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.43.22;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.29;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.29;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.04.57;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.11.19.14.12.04;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.17.57;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.45.25;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.20.34;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.10;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.14;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD back-end for ARM COFF files.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"

#include "coff/arm.h"

#include "coff/internal.h"

#ifdef COFF_WITH_PE
#include "coff/pe.h"
#endif

#include "libcoff.h"

/* Macros for manipulation the bits in the flags field of the coff data
   structure.  */
#define APCS_26_FLAG(abfd) \
  (coff_data (abfd)->flags & F_APCS_26)

#define APCS_FLOAT_FLAG(abfd) \
  (coff_data (abfd)->flags & F_APCS_FLOAT)

#define PIC_FLAG(abfd) \
  (coff_data (abfd)->flags & F_PIC)

#define APCS_SET(abfd) \
  (coff_data (abfd)->flags & F_APCS_SET)

#define SET_APCS_FLAGS(abfd, flgs) \
  do									\
    {									\
      coff_data (abfd)->flags &= ~(F_APCS_26 | F_APCS_FLOAT | F_PIC);	\
      coff_data (abfd)->flags |= (flgs) | F_APCS_SET;			\
    }									\
  while (0)

#define INTERWORK_FLAG(abfd) \
  (coff_data (abfd)->flags & F_INTERWORK)

#define INTERWORK_SET(abfd) \
  (coff_data (abfd)->flags & F_INTERWORK_SET)

#define SET_INTERWORK_FLAG(abfd, flg) \
  do									\
    {									\
      coff_data (abfd)->flags &= ~F_INTERWORK;				\
      coff_data (abfd)->flags |= (flg) | F_INTERWORK_SET;		\
    }									\
  while (0)

#ifndef NUM_ELEM
#define NUM_ELEM(a) ((sizeof (a)) / sizeof ((a)[0]))
#endif

typedef enum {bunknown, b9, b12, b23} thumb_pcrel_branchtype;
/* some typedefs for holding instructions */
typedef unsigned long int insn32;
typedef unsigned short int insn16;

     /* Forward declarations for stupid compilers.  */
static bfd_boolean coff_arm_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
           struct internal_reloc *, struct internal_syment *, asection **));
static bfd_reloc_status_type aoutarm_fix_pcrel_26_done
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type aoutarm_fix_pcrel_26
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
#ifndef ARM_WINCE
static bfd_reloc_status_type coff_thumb_pcrel_23
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type coff_thumb_pcrel_9
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static insn32 insert_thumb_branch
  PARAMS ((insn32, int));
#endif
static bfd_reloc_status_type coff_thumb_pcrel_12
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type coff_arm_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_boolean coff_arm_adjust_symndx
  PARAMS ((bfd *, struct bfd_link_info *, bfd *,
	   asection *, struct internal_reloc *,	bfd_boolean *));
static reloc_howto_type * coff_arm_rtype_to_howto
  PARAMS ((bfd *, asection *, struct internal_reloc *,
	   struct coff_link_hash_entry *, struct internal_syment *,
	   bfd_vma *));
static bfd_reloc_status_type coff_thumb_pcrel_common
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **,
	   thumb_pcrel_branchtype));
static const struct reloc_howto_struct * coff_arm_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static struct bfd_link_hash_table * coff_arm_link_hash_table_create
  PARAMS ((bfd *));
static struct coff_link_hash_entry * find_thumb_glue
  PARAMS ((struct bfd_link_info *, const char *, bfd *));
static struct coff_link_hash_entry * find_arm_glue
  PARAMS ((struct bfd_link_info *, const char *, bfd *));
#ifndef COFF_IMAGE_WITH_PE
static void record_arm_to_thumb_glue
  PARAMS ((struct bfd_link_info *, struct coff_link_hash_entry *));
#ifndef ARM_WINCE
static void record_thumb_to_arm_glue
  PARAMS ((struct bfd_link_info *, struct coff_link_hash_entry *));
#endif
#endif
static bfd_boolean coff_arm_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean coff_arm_print_private_bfd_data
  PARAMS ((bfd *, PTR));
static bfd_boolean _bfd_coff_arm_set_private_flags
  PARAMS ((bfd *, flagword));
static bfd_boolean coff_arm_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean coff_arm_is_local_label_name
  PARAMS ((bfd *, const char *));
static bfd_boolean coff_arm_link_output_has_begun
  PARAMS ((bfd *, struct coff_final_link_info *));
static bfd_boolean coff_arm_final_link_postscript
  PARAMS ((bfd *, struct coff_final_link_info *));
static void arm_emit_base_file_entry
  PARAMS ((struct bfd_link_info *, bfd *, asection *, bfd_vma));

/* The linker script knows the section names for placement.
   The entry_names are used to do simple name mangling on the stubs.
   Given a function name, and its type, the stub can be found. The
   name can be changed. The only requirement is the %s be present.  */

#define THUMB2ARM_GLUE_SECTION_NAME ".glue_7t"
#define THUMB2ARM_GLUE_ENTRY_NAME   "__%s_from_thumb"

#define ARM2THUMB_GLUE_SECTION_NAME ".glue_7"
#define ARM2THUMB_GLUE_ENTRY_NAME   "__%s_from_arm"

/* Used by the assembler.  */

static bfd_reloc_status_type
coff_arm_reloc (abfd, reloc_entry, symbol, data, input_section, output_bfd,
		 error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  symvalue diff;
  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  diff = reloc_entry->addend;

#define DOIT(x)							\
  x = ((x & ~howto->dst_mask)					\
       | (((x & howto->src_mask) + diff) & howto->dst_mask))

    if (diff != 0)
      {
	reloc_howto_type *howto = reloc_entry->howto;
	unsigned char *addr = (unsigned char *) data + reloc_entry->address;

	switch (howto->size)
	  {
	  case 0:
	    {
	      char x = bfd_get_8 (abfd, addr);
	      DOIT (x);
	      bfd_put_8 (abfd, x, addr);
	    }
	    break;

	  case 1:
	    {
	      short x = bfd_get_16 (abfd, addr);
	      DOIT (x);
	      bfd_put_16 (abfd, (bfd_vma) x, addr);
	    }
	    break;

	  case 2:
	    {
	      long x = bfd_get_32 (abfd, addr);
	      DOIT (x);
	      bfd_put_32 (abfd, (bfd_vma) x, addr);
	    }
	    break;

	  default:
	    abort ();
	  }
      }

  /* Now let bfd_perform_relocation finish everything up.  */
  return bfd_reloc_continue;
}

/* If USER_LABEL_PREFIX is defined as "_" (see coff_arm_is_local_label_name()
   in this file), then TARGET_UNDERSCORE should be defined, otherwise it
   should not.  */
#ifndef TARGET_UNDERSCORE
#define TARGET_UNDERSCORE '_'
#endif

#ifndef PCRELOFFSET
#define PCRELOFFSET TRUE
#endif

/* These most certainly belong somewhere else. Just had to get rid of
   the manifest constants in the code.  */
#define ARM_8        0
#define ARM_16       1
#define ARM_32       2
#define ARM_26       3
#define ARM_DISP8    4
#define ARM_DISP16   5
#define ARM_DISP32   6
#define ARM_26D      7
/* 8 is unused */
#define ARM_NEG16    9
#define ARM_NEG32   10
#define ARM_RVA32   11
#define ARM_THUMB9  12
#define ARM_THUMB12 13
#define ARM_THUMB23 14

#ifdef ARM_WINCE
#undef  ARM_32
#undef  ARM_RVA32
#undef  ARM_26
#undef  ARM_THUMB12
#undef  ARM_26D

#define ARM_26D      0
#define ARM_32       1
#define ARM_RVA32    2
#define ARM_26	     3
#define ARM_THUMB12  4
#define ARM_SECTION  14
#define ARM_SECREL   15
#endif

static reloc_howto_type aoutarm_std_reloc_howto[] =
  {
#ifdef ARM_WINCE
    HOWTO (ARM_26D,
	   2,
	   2,
	   24,
	   TRUE,
	   0,
	   complain_overflow_dont,
	   aoutarm_fix_pcrel_26_done,
	   "ARM_26D",
	   FALSE,
	   0x00ffffff,
	   0x0,
	   PCRELOFFSET),
    HOWTO (ARM_32,
	   0,
	   2,
	   32,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_32",
	   FALSE,
	   0xffffffff,
	   0xffffffff,
	   PCRELOFFSET),
    HOWTO (ARM_RVA32,
	   0,
	   2,
	   32,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_RVA32",
	   FALSE,
	   0xffffffff,
	   0xffffffff,
	   PCRELOFFSET),
    HOWTO (ARM_26,
	   2,
	   2,
	   24,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   aoutarm_fix_pcrel_26 ,
	   "ARM_26",
	   FALSE,
	   0x00ffffff,
	   0x00ffffff,
	   PCRELOFFSET),
    HOWTO (ARM_THUMB12,
	   1,
	   1,
	   11,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_thumb_pcrel_12 ,
	   "ARM_THUMB12",
	   FALSE,
	   0x000007ff,
	   0x000007ff,
	   PCRELOFFSET),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    HOWTO (ARM_SECTION,
	   0,
	   1,
	   16,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_SECTION",
	   FALSE,
	   0x0000ffff,
	   0x0000ffff,
	   PCRELOFFSET),
    HOWTO (ARM_SECREL,
	   0,
	   2,
	   32,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_SECREL",
	   FALSE,
	   0xffffffff,
	   0xffffffff,
	   PCRELOFFSET),
#else /* not ARM_WINCE */
    HOWTO (ARM_8,		/* type */
	   0,			/* rightshift */
	   0,			/* size */
	   8,			/* bitsize */
	   FALSE,		/* pc_relative */
	   0,			/* bitpos */
	   complain_overflow_bitfield, /* complain_on_overflow */
	   coff_arm_reloc,	/* special_function */
	   "ARM_8",		/* name */
	   TRUE,		/* partial_inplace */
	   0x000000ff,		/* src_mask */
	   0x000000ff,		/* dst_mask */
	   PCRELOFFSET		/* pcrel_offset */),
    HOWTO (ARM_16,
	   0,
	   1,
	   16,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_16",
	   TRUE,
	   0x0000ffff,
	   0x0000ffff,
	   PCRELOFFSET),
    HOWTO (ARM_32,
	   0,
	   2,
	   32,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_32",
	   TRUE,
	   0xffffffff,
	   0xffffffff,
	   PCRELOFFSET),
    HOWTO (ARM_26,
	   2,
	   2,
	   24,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   aoutarm_fix_pcrel_26 ,
	   "ARM_26",
	   FALSE,
	   0x00ffffff,
	   0x00ffffff,
	   PCRELOFFSET),
    HOWTO (ARM_DISP8,
	   0,
	   0,
	   8,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_arm_reloc,
	   "ARM_DISP8",
	   TRUE,
	   0x000000ff,
	   0x000000ff,
	   TRUE),
    HOWTO (ARM_DISP16,
	   0,
	   1,
	   16,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_arm_reloc,
	   "ARM_DISP16",
	   TRUE,
	   0x0000ffff,
	   0x0000ffff,
	   TRUE),
    HOWTO (ARM_DISP32,
	   0,
	   2,
	   32,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_arm_reloc,
	   "ARM_DISP32",
	   TRUE,
	   0xffffffff,
	   0xffffffff,
	   TRUE),
    HOWTO (ARM_26D,
	   2,
	   2,
	   24,
	   FALSE,
	   0,
	   complain_overflow_dont,
	   aoutarm_fix_pcrel_26_done,
	   "ARM_26D",
	   TRUE,
	   0x00ffffff,
	   0x0,
	   FALSE),
    /* 8 is unused */
    EMPTY_HOWTO (-1),
    HOWTO (ARM_NEG16,
	   0,
	   -1,
	   16,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_NEG16",
	   TRUE,
	   0x0000ffff,
	   0x0000ffff,
	   FALSE),
    HOWTO (ARM_NEG32,
	   0,
	   -2,
	   32,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_NEG32",
	   TRUE,
	   0xffffffff,
	   0xffffffff,
	   FALSE),
    HOWTO (ARM_RVA32,
	   0,
	   2,
	   32,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_RVA32",
	   TRUE,
	   0xffffffff,
	   0xffffffff,
	   PCRELOFFSET),
    HOWTO (ARM_THUMB9,
	   1,
	   1,
	   8,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_thumb_pcrel_9 ,
	   "ARM_THUMB9",
	   FALSE,
	   0x000000ff,
	   0x000000ff,
	   PCRELOFFSET),
    HOWTO (ARM_THUMB12,
	   1,
	   1,
	   11,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_thumb_pcrel_12 ,
	   "ARM_THUMB12",
	   FALSE,
	   0x000007ff,
	   0x000007ff,
	   PCRELOFFSET),
    HOWTO (ARM_THUMB23,
	   1,
	   2,
	   22,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_thumb_pcrel_23 ,
	   "ARM_THUMB23",
	   FALSE,
	   0x07ff07ff,
	   0x07ff07ff,
	   PCRELOFFSET)
#endif /* not ARM_WINCE */
  };

#define NUM_RELOCS NUM_ELEM (aoutarm_std_reloc_howto)

#ifdef COFF_WITH_PE
static bfd_boolean in_reloc_p PARAMS ((bfd *, reloc_howto_type *));
/* Return TRUE if this relocation should
   appear in the output .reloc section.  */

static bfd_boolean
in_reloc_p (abfd, howto)
     bfd * abfd ATTRIBUTE_UNUSED;
     reloc_howto_type * howto;
{
  return !howto->pc_relative && howto->type != ARM_RVA32;
}
#endif

#define RTYPE2HOWTO(cache_ptr, dst)		\
  (cache_ptr)->howto =				\
    (dst)->r_type < NUM_RELOCS			\
    ? aoutarm_std_reloc_howto + (dst)->r_type	\
    : NULL

#define coff_rtype_to_howto coff_arm_rtype_to_howto

static reloc_howto_type *
coff_arm_rtype_to_howto (abfd, sec, rel, h, sym, addendp)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     struct internal_reloc *rel;
     struct coff_link_hash_entry *h ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     bfd_vma *addendp;
{
  reloc_howto_type * howto;

  if (rel->r_type >= NUM_RELOCS)
    return NULL;

  howto = aoutarm_std_reloc_howto + rel->r_type;

  if (rel->r_type == ARM_RVA32)
    *addendp -= pe_data (sec->output_section->owner)->pe_opthdr.ImageBase;

  return howto;
}

/* Used by the assembler.  */

static bfd_reloc_status_type
aoutarm_fix_pcrel_26_done (abfd, reloc_entry, symbol, data, input_section,
			  output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     char **error_message ATTRIBUTE_UNUSED;
{
  /* This is dead simple at present.  */
  return bfd_reloc_ok;
}

/* Used by the assembler.  */

static bfd_reloc_status_type
aoutarm_fix_pcrel_26 (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  bfd_vma relocation;
  bfd_size_type addr = reloc_entry->address;
  long target = bfd_get_32 (abfd, (bfd_byte *) data + addr);
  bfd_reloc_status_type flag = bfd_reloc_ok;

  /* If this is an undefined symbol, return error.  */
  if (symbol->section == &bfd_und_section
      && (symbol->flags & BSF_WEAK) == 0)
    return output_bfd ? bfd_reloc_continue : bfd_reloc_undefined;

  /* If the sections are different, and we are doing a partial relocation,
     just ignore it for now.  */
  if (symbol->section->name != input_section->name
      && output_bfd != (bfd *)NULL)
    return bfd_reloc_continue;

  relocation = (target & 0x00ffffff) << 2;
  relocation = (relocation ^ 0x02000000) - 0x02000000; /* Sign extend.  */
  relocation += symbol->value;
  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;
  relocation -= input_section->output_section->vma;
  relocation -= input_section->output_offset;
  relocation -= addr;

  if (relocation & 3)
    return bfd_reloc_overflow;

  /* Check for overflow.  */
  if (relocation & 0x02000000)
    {
      if ((relocation & ~ (bfd_vma) 0x03ffffff) != ~ (bfd_vma) 0x03ffffff)
	flag = bfd_reloc_overflow;
    }
  else if (relocation & ~(bfd_vma) 0x03ffffff)
    flag = bfd_reloc_overflow;

  target &= ~0x00ffffff;
  target |= (relocation >> 2) & 0x00ffffff;
  bfd_put_32 (abfd, (bfd_vma) target, (bfd_byte *) data + addr);

  /* Now the ARM magic... Change the reloc type so that it is marked as done.
     Strictly this is only necessary if we are doing a partial relocation.  */
  reloc_entry->howto = &aoutarm_std_reloc_howto[ARM_26D];

  return flag;
}

static bfd_reloc_status_type
coff_thumb_pcrel_common (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message, btype)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
     thumb_pcrel_branchtype btype;
{
  bfd_vma relocation = 0;
  bfd_size_type addr = reloc_entry->address;
  long target = bfd_get_32 (abfd, (bfd_byte *) data + addr);
  bfd_reloc_status_type flag = bfd_reloc_ok;
  bfd_vma dstmsk;
  bfd_vma offmsk;
  bfd_vma signbit;

  /* NOTE: This routine is currently used by GAS, but not by the link
     phase.  */

  switch (btype)
    {
    case b9:
      dstmsk  = 0x000000ff;
      offmsk  = 0x000001fe;
      signbit = 0x00000100;
      break;

    case b12:
      dstmsk  = 0x000007ff;
      offmsk  = 0x00000ffe;
      signbit = 0x00000800;
      break;

    case b23:
      dstmsk  = 0x07ff07ff;
      offmsk  = 0x007fffff;
      signbit = 0x00400000;
      break;

    default:
      abort ();
    }

  /* If this is an undefined symbol, return error.  */
  if (symbol->section == &bfd_und_section
      && (symbol->flags & BSF_WEAK) == 0)
    return output_bfd ? bfd_reloc_continue : bfd_reloc_undefined;

  /* If the sections are different, and we are doing a partial relocation,
     just ignore it for now.  */
  if (symbol->section->name != input_section->name
      && output_bfd != (bfd *)NULL)
    return bfd_reloc_continue;

  switch (btype)
    {
    case b9:
    case b12:
      relocation = ((target & dstmsk) << 1);
      break;

    case b23:
      if (bfd_big_endian (abfd))
	relocation = ((target & 0x7ff) << 1)  | ((target & 0x07ff0000) >> 4);
      else
	relocation = ((target & 0x7ff) << 12) | ((target & 0x07ff0000) >> 15);
      break;

    default:
      abort ();
    }

  relocation = (relocation ^ signbit) - signbit; /* Sign extend.  */
  relocation += symbol->value;
  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;
  relocation -= input_section->output_section->vma;
  relocation -= input_section->output_offset;
  relocation -= addr;

  if (relocation & 1)
    return bfd_reloc_overflow;

  /* Check for overflow.  */
  if (relocation & signbit)
    {
      if ((relocation & ~offmsk) != ~offmsk)
	flag = bfd_reloc_overflow;
    }
  else if (relocation & ~offmsk)
    flag = bfd_reloc_overflow;

  target &= ~dstmsk;
  switch (btype)
   {
   case b9:
   case b12:
     target |= (relocation >> 1);
     break;

   case b23:
     if (bfd_big_endian (abfd))
       target |= (((relocation & 0xfff) >> 1)
		  | ((relocation << 4)  & 0x07ff0000));
     else
       target |= (((relocation & 0xffe) << 15)
		  | ((relocation >> 12) & 0x7ff));
     break;

   default:
     abort ();
   }

  bfd_put_32 (abfd, (bfd_vma) target, (bfd_byte *) data + addr);

  /* Now the ARM magic... Change the reloc type so that it is marked as done.
     Strictly this is only necessary if we are doing a partial relocation.  */
  reloc_entry->howto = & aoutarm_std_reloc_howto [ARM_26D];

  /* TODO: We should possibly have DONE entries for the THUMB PCREL relocations.  */
  return flag;
}

#ifndef ARM_WINCE
static bfd_reloc_status_type
coff_thumb_pcrel_23 (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  return coff_thumb_pcrel_common (abfd, reloc_entry, symbol, data,
                                  input_section, output_bfd, error_message,
				  b23);
}

static bfd_reloc_status_type
coff_thumb_pcrel_9 (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  return coff_thumb_pcrel_common (abfd, reloc_entry, symbol, data,
                                  input_section, output_bfd, error_message,
				  b9);
}
#endif /* not ARM_WINCE */

static bfd_reloc_status_type
coff_thumb_pcrel_12 (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  return coff_thumb_pcrel_common (abfd, reloc_entry, symbol, data,
                                  input_section, output_bfd, error_message,
				  b12);
}

static const struct reloc_howto_struct *
coff_arm_reloc_type_lookup (abfd, code)
      bfd * abfd;
      bfd_reloc_code_real_type code;
{
#define ASTD(i,j)       case i: return aoutarm_std_reloc_howto + j

  if (code == BFD_RELOC_CTOR)
    switch (bfd_get_arch_info (abfd)->bits_per_address)
      {
      case 32:
        code = BFD_RELOC_32;
        break;
      default:
	return (const struct reloc_howto_struct *) 0;
      }

  switch (code)
    {
#ifdef ARM_WINCE
      ASTD (BFD_RELOC_32,                   ARM_32);
      ASTD (BFD_RELOC_RVA,                  ARM_RVA32);
      ASTD (BFD_RELOC_ARM_PCREL_BRANCH,     ARM_26);
      ASTD (BFD_RELOC_THUMB_PCREL_BRANCH12, ARM_THUMB12);
#else
      ASTD (BFD_RELOC_8,                    ARM_8);
      ASTD (BFD_RELOC_16,                   ARM_16);
      ASTD (BFD_RELOC_32,                   ARM_32);
      ASTD (BFD_RELOC_ARM_PCREL_BRANCH,     ARM_26);
      ASTD (BFD_RELOC_ARM_PCREL_BLX,        ARM_26);
      ASTD (BFD_RELOC_8_PCREL,              ARM_DISP8);
      ASTD (BFD_RELOC_16_PCREL,             ARM_DISP16);
      ASTD (BFD_RELOC_32_PCREL,             ARM_DISP32);
      ASTD (BFD_RELOC_RVA,                  ARM_RVA32);
      ASTD (BFD_RELOC_THUMB_PCREL_BRANCH9,  ARM_THUMB9);
      ASTD (BFD_RELOC_THUMB_PCREL_BRANCH12, ARM_THUMB12);
      ASTD (BFD_RELOC_THUMB_PCREL_BRANCH23, ARM_THUMB23);
      ASTD (BFD_RELOC_THUMB_PCREL_BLX,      ARM_THUMB23);
#endif
    default: return (const struct reloc_howto_struct *) 0;
    }
}

#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (2)
#define COFF_PAGE_SIZE 0x1000
/* Turn a howto into a reloc  nunmber */

#define SELECT_RELOC(x,howto) { x.r_type = howto->type; }
#define BADMAG(x) ARMBADMAG(x)
#define ARM 1			/* Customize coffcode.h */

#ifndef ARM_WINCE
/* Make sure that the 'r_offset' field is copied properly
   so that identical binaries will compare the same.  */
#define SWAP_IN_RELOC_OFFSET	H_GET_32
#define SWAP_OUT_RELOC_OFFSET	H_PUT_32
#endif

/* Extend the coff_link_hash_table structure with a few ARM specific fields.
   This allows us to store global data here without actually creating any
   global variables, which is a no-no in the BFD world.  */
struct coff_arm_link_hash_table
  {
    /* The original coff_link_hash_table structure.  MUST be first field.  */
    struct coff_link_hash_table	root;

    /* The size in bytes of the section containing the Thumb-to-ARM glue.  */
    bfd_size_type		thumb_glue_size;

    /* The size in bytes of the section containing the ARM-to-Thumb glue.  */
    bfd_size_type		arm_glue_size;

    /* An arbitrary input BFD chosen to hold the glue sections.  */
    bfd *			bfd_of_glue_owner;

    /* Support interworking with old, non-interworking aware ARM code.  */
    int 			support_old_code;
};

/* Get the ARM coff linker hash table from a link_info structure.  */
#define coff_arm_hash_table(info) \
  ((struct coff_arm_link_hash_table *) ((info)->hash))

/* Create an ARM coff linker hash table.  */

static struct bfd_link_hash_table *
coff_arm_link_hash_table_create (abfd)
     bfd * abfd;
{
  struct coff_arm_link_hash_table * ret;
  bfd_size_type amt = sizeof (struct coff_arm_link_hash_table);

  ret = (struct coff_arm_link_hash_table *) bfd_malloc (amt);
  if (ret == (struct coff_arm_link_hash_table *) NULL)
    return NULL;

  if (! _bfd_coff_link_hash_table_init
      (& ret->root, abfd, _bfd_coff_link_hash_newfunc))
    {
      free (ret);
      return (struct bfd_link_hash_table *) NULL;
    }

  ret->thumb_glue_size   = 0;
  ret->arm_glue_size     = 0;
  ret->bfd_of_glue_owner = NULL;

  return & ret->root.root;
}

static void
arm_emit_base_file_entry (info, output_bfd, input_section, reloc_offset)
      struct bfd_link_info *info;
      bfd *output_bfd;
      asection *input_section;
      bfd_vma reloc_offset;
{
  bfd_vma addr = reloc_offset
                - input_section->vma
                + input_section->output_offset
                  + input_section->output_section->vma;

  if (coff_data (output_bfd)->pe)
     addr -= pe_data (output_bfd)->pe_opthdr.ImageBase;
  fwrite (& addr, 1, sizeof (addr), (FILE *) info->base_file);

}

#ifndef ARM_WINCE
/* The thumb form of a long branch is a bit finicky, because the offset
   encoding is split over two fields, each in it's own instruction. They
   can occur in any order. So given a thumb form of long branch, and an
   offset, insert the offset into the thumb branch and return finished
   instruction.

   It takes two thumb instructions to encode the target address. Each has
   11 bits to invest. The upper 11 bits are stored in one (identified by
   H-0.. see below), the lower 11 bits are stored in the other (identified
   by H-1).

   Combine together and shifted left by 1 (it's a half word address) and
   there you have it.

     Op: 1111 = F,
     H-0, upper address-0 = 000
     Op: 1111 = F,
     H-1, lower address-0 = 800

   They can be ordered either way, but the arm tools I've seen always put
   the lower one first. It probably doesn't matter. krk@@cygnus.com

   XXX:  Actually the order does matter.  The second instruction (H-1)
   moves the computed address into the PC, so it must be the second one
   in the sequence.  The problem, however is that whilst little endian code
   stores the instructions in HI then LOW order, big endian code does the
   reverse.  nickc@@cygnus.com.  */

#define LOW_HI_ORDER 0xF800F000
#define HI_LOW_ORDER 0xF000F800

static insn32
insert_thumb_branch (br_insn, rel_off)
     insn32 br_insn;
     int rel_off;
{
  unsigned int low_bits;
  unsigned int high_bits;

  BFD_ASSERT((rel_off & 1) != 1);

  rel_off >>= 1;                              /* half word aligned address */
  low_bits = rel_off & 0x000007FF;            /* the bottom 11 bits */
  high_bits = (rel_off >> 11) & 0x000007FF;   /* the top 11 bits */

  if ((br_insn & LOW_HI_ORDER) == LOW_HI_ORDER)
    br_insn = LOW_HI_ORDER | (low_bits << 16) | high_bits;
  else if ((br_insn & HI_LOW_ORDER) == HI_LOW_ORDER)
    br_insn = HI_LOW_ORDER | (high_bits << 16) | low_bits;
  else
    /* FIXME: the BFD library should never abort except for internal errors
       - it should return an error status.  */
    abort (); /* Error - not a valid branch instruction form.  */

  return br_insn;
}


static struct coff_link_hash_entry *
find_thumb_glue (info, name, input_bfd)
     struct bfd_link_info *info;
     const char *name;
     bfd *input_bfd;
{
  char *tmp_name;
  struct coff_link_hash_entry *myh;
  bfd_size_type amt = strlen (name) + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1;

  tmp_name = (char *) bfd_malloc (amt);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, THUMB2ARM_GLUE_ENTRY_NAME, name);

  myh = coff_link_hash_lookup
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);

  if (myh == NULL)
    /* xgettext:c-format */
    _bfd_error_handler (_("%s: unable to find THUMB glue '%s' for `%s'"),
			bfd_archive_filename (input_bfd), tmp_name, name);

  free (tmp_name);

  return myh;
}
#endif /* not ARM_WINCE */

static struct coff_link_hash_entry *
find_arm_glue (info, name, input_bfd)
     struct bfd_link_info *info;
     const char *name;
     bfd *input_bfd;
{
  char *tmp_name;
  struct coff_link_hash_entry * myh;
  bfd_size_type amt = strlen (name) + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1;

  tmp_name = (char *) bfd_malloc (amt);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, ARM2THUMB_GLUE_ENTRY_NAME, name);

  myh = coff_link_hash_lookup
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);

  if (myh == NULL)
    /* xgettext:c-format */
    _bfd_error_handler (_("%s: unable to find ARM glue '%s' for `%s'"),
			bfd_archive_filename (input_bfd), tmp_name, name);

  free (tmp_name);

  return myh;
}

/*
  ARM->Thumb glue:

       .arm
       __func_from_arm:
	     ldr r12, __func_addr
	     bx  r12
       __func_addr:
            .word func    @@ behave as if you saw a ARM_32 reloc
*/

#define ARM2THUMB_GLUE_SIZE 12
static const insn32 a2t1_ldr_insn       = 0xe59fc000;
static const insn32 a2t2_bx_r12_insn    = 0xe12fff1c;
static const insn32 a2t3_func_addr_insn = 0x00000001;

/*
   Thumb->ARM:				Thumb->(non-interworking aware) ARM

   .thumb				.thumb
   .align 2				.align 2
      __func_from_thumb:		   __func_from_thumb:
	   bx pc				push {r6, lr}
	   nop					ldr  r6, __func_addr
   .arm						mov  lr, pc
      __func_change_to_arm:			bx   r6
	   b func   			.arm
					   __func_back_to_thumb:
   		  				ldmia r13! {r6, lr}
   					        bx    lr
   					   __func_addr:
					        .word	func
*/

#define THUMB2ARM_GLUE_SIZE (globals->support_old_code ? 20 : 8)
static const insn16 t2a1_bx_pc_insn = 0x4778;
static const insn16 t2a2_noop_insn  = 0x46c0;
static const insn32 t2a3_b_insn     = 0xea000000;

static const insn16 t2a1_push_insn  = 0xb540;
static const insn16 t2a2_ldr_insn   = 0x4e03;
static const insn16 t2a3_mov_insn   = 0x46fe;
static const insn16 t2a4_bx_insn    = 0x4730;
static const insn32 t2a5_pop_insn   = 0xe8bd4040;
static const insn32 t2a6_bx_insn    = 0xe12fff1e;

/* TODO:
     We should really create new local (static) symbols in destination
     object for each stub we create.  We should also create local
     (static) symbols within the stubs when switching between ARM and
     Thumb code.  This will ensure that the debugger and disassembler
     can present a better view of stubs.

     We can treat stubs like literal sections, and for the THUMB9 ones
     (short addressing range) we should be able to insert the stubs
     between sections. i.e. the simplest approach (since relocations
     are done on a section basis) is to dump the stubs at the end of
     processing a section. That way we can always try and minimise the
     offset to and from a stub. However, this does not map well onto
     the way that the linker/BFD does its work: mapping all input
     sections to output sections via the linker script before doing
     all the processing.

     Unfortunately it may be easier to just to disallow short range
     Thumb->ARM stubs (i.e. no conditional inter-working branches,
     only branch-and-link (BL) calls.  This will simplify the processing
     since we can then put all of the stubs into their own section.

  TODO:
     On a different subject, rather than complaining when a
     branch cannot fit in the number of bits available for the
     instruction we should generate a trampoline stub (needed to
     address the complete 32bit address space).  */

/* The standard COFF backend linker does not cope with the special
   Thumb BRANCH23 relocation.  The alternative would be to split the
   BRANCH23 into seperate HI23 and LO23 relocations. However, it is a
   bit simpler simply providing our own relocation driver.  */

/* The reloc processing routine for the ARM/Thumb COFF linker.  NOTE:
   This code is a very slightly modified copy of
   _bfd_coff_generic_relocate_section.  It would be a much more
   maintainable solution to have a MACRO that could be expanded within
   _bfd_coff_generic_relocate_section that would only be provided for
   ARM/Thumb builds.  It is only the code marked THUMBEXTENSION that
   is different from the original.  */

static bfd_boolean
coff_arm_relocate_section (output_bfd, info, input_bfd, input_section,
                           contents, relocs, syms, sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     struct internal_reloc *relocs;
     struct internal_syment *syms;
     asection **sections;
{
  struct internal_reloc * rel;
  struct internal_reloc * relend;

  rel = relocs;
  relend = rel + input_section->reloc_count;

  for (; rel < relend; rel++)
    {
      int                            done = 0;
      long                           symndx;
      struct coff_link_hash_entry *  h;
      struct internal_syment *       sym;
      bfd_vma                        addend;
      bfd_vma                        val;
      reloc_howto_type *             howto;
      bfd_reloc_status_type          rstat;
      bfd_vma                        h_val;

      symndx = rel->r_symndx;

      if (symndx == -1)
	{
	  h = NULL;
	  sym = NULL;
	}
      else
	{
	  h = obj_coff_sym_hashes (input_bfd)[symndx];
	  sym = syms + symndx;
	}

      /* COFF treats common symbols in one of two ways.  Either the
         size of the symbol is included in the section contents, or it
         is not.  We assume that the size is not included, and force
         the rtype_to_howto function to adjust the addend as needed.  */

      if (sym != NULL && sym->n_scnum != 0)
	addend = - sym->n_value;
      else
	addend = 0;

      howto = coff_rtype_to_howto (input_bfd, input_section, rel, h,
				       sym, &addend);
      if (howto == NULL)
	return FALSE;

      /* The relocation_section function will skip pcrel_offset relocs
         when doing a relocatable link.  However, we want to convert
         ARM_26 to ARM_26D relocs if possible.  We return a fake howto in
         this case without pcrel_offset set, and adjust the addend to
         compensate.  'partial_inplace' is also set, since we want 'done'
         relocations to be reflected in section's data.  */
      if (rel->r_type == ARM_26
          && h != NULL
          && info->relocatable
          && (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
          && (h->root.u.def.section->output_section
	      == input_section->output_section))
        {
          static reloc_howto_type fake_arm26_reloc =
	    HOWTO (ARM_26,
    	       2,
    	       2,
    	       24,
    	       TRUE,
    	       0,
    	       complain_overflow_signed,
    	       aoutarm_fix_pcrel_26 ,
    	       "ARM_26",
    	       TRUE,
    	       0x00ffffff,
    	       0x00ffffff,
    	       FALSE);

          addend -= rel->r_vaddr - input_section->vma;
#ifdef ARM_WINCE
          /* FIXME: I don't know why, but the hack is necessary for correct
                    generation of bl's instruction offset. */
          addend -= 8;
#endif
          howto = &fake_arm26_reloc;
        }

#ifdef ARM_WINCE
      /* MS ARM-CE makes the reloc relative to the opcode's pc, not
	 the next opcode's pc, so is off by one.  */
#if 0 /* This appears to have been true for WINCE 2.0, but it is not
	 true for WINCE 3.0.  */
      if (howto->pc_relative && !info->relocatable)
	addend -= 8;
#endif
#endif

      /* If we are doing a relocatable link, then we can just ignore
         a PC relative reloc that is pcrel_offset.  It will already
         have the correct value.  If this is not a relocatable link,
         then we should ignore the symbol value.  */
      if (howto->pc_relative && howto->pcrel_offset)
        {
          if (info->relocatable)
            continue;
	  /* FIXME - it is not clear which targets need this next test
	     and which do not.  It is known that it is needed for the
	     VxWorks and EPOC-PE targets, but it is also known that it
	     was suppressed for other ARM targets.  This ought to be
	     sorted out one day.  */
#ifdef ARM_COFF_BUGFIX
	  /* We must not ignore the symbol value.  If the symbol is
	     within the same section, the relocation should have already
	     been fixed, but if it is not, we'll be handed a reloc into
	     the beginning of the symbol's section, so we must not cancel
	     out the symbol's value, otherwise we'll be adding it in
	     twice.  */
          if (sym != NULL && sym->n_scnum != 0)
            addend += sym->n_value;
#endif
        }

      val = 0;

      if (h == NULL)
	{
	  asection *sec;

	  if (symndx == -1)
	    {
	      sec = bfd_abs_section_ptr;
	      val = 0;
	    }
	  else
	    {
	      sec = sections[symndx];
              val = (sec->output_section->vma
		     + sec->output_offset
		     + sym->n_value
		     - sec->vma);
	    }
	}
      else
	{
#if 1 /* THUMBEXTENSION */
          /* We don't output the stubs if we are generating a
             relocatable output file, since we may as well leave the
             stub generation to the final linker pass. If we fail to
	     verify that the name is defined, we'll try to build stubs
	     for an undefined name...  */
          if (! info->relocatable
	      && (   h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak))
            {
	      asection *   h_sec = h->root.u.def.section;
	      const char * name  = h->root.root.string;

	      /* h locates the symbol referenced in the reloc.  */
	      h_val = (h->root.u.def.value
		       + h_sec->output_section->vma
		       + h_sec->output_offset);

              if (howto->type == ARM_26)
                {
                  if (   h->class == C_THUMBSTATFUNC
		      || h->class == C_THUMBEXTFUNC)
		    {
		      /* Arm code calling a Thumb function.  */
		      unsigned long int                 tmp;
		      bfd_vma                           my_offset;
		      asection *                        s;
		      long int                          ret_offset;
		      struct coff_link_hash_entry *     myh;
		      struct coff_arm_link_hash_table * globals;

		      myh = find_arm_glue (info, name, input_bfd);
		      if (myh == NULL)
			return FALSE;

		      globals = coff_arm_hash_table (info);

		      BFD_ASSERT (globals != NULL);
		      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

		      my_offset = myh->root.u.def.value;

		      s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
						  ARM2THUMB_GLUE_SECTION_NAME);
		      BFD_ASSERT (s != NULL);
		      BFD_ASSERT (s->contents != NULL);
		      BFD_ASSERT (s->output_section != NULL);

		      if ((my_offset & 0x01) == 0x01)
			{
			  if (h_sec->owner != NULL
			      && INTERWORK_SET (h_sec->owner)
			      && ! INTERWORK_FLAG (h_sec->owner))
			    {
			      _bfd_error_handler
				/* xgettext:c-format */
				(_("%s(%s): warning: interworking not enabled."),
				 bfd_archive_filename (h_sec->owner), name);
			      _bfd_error_handler
				/* xgettext:c-format */
				(_("  first occurrence: %s: arm call to thumb"),
				 bfd_archive_filename (input_bfd));
			    }

			  --my_offset;
			  myh->root.u.def.value = my_offset;

			  bfd_put_32 (output_bfd, (bfd_vma) a2t1_ldr_insn,
				      s->contents + my_offset);

			  bfd_put_32 (output_bfd, (bfd_vma) a2t2_bx_r12_insn,
				      s->contents + my_offset + 4);

			  /* It's a thumb address.  Add the low order bit.  */
			  bfd_put_32 (output_bfd, h_val | a2t3_func_addr_insn,
				      s->contents + my_offset + 8);

                          if (info->base_file)
                            arm_emit_base_file_entry (info, output_bfd, s,
                                                      my_offset + 8);

			}

		      BFD_ASSERT (my_offset <= globals->arm_glue_size);

		      tmp = bfd_get_32 (input_bfd, contents + rel->r_vaddr
					- input_section->vma);

		      tmp = tmp & 0xFF000000;

		      /* Somehow these are both 4 too far, so subtract 8.  */
		      ret_offset =
			s->output_offset
			+ my_offset
			+ s->output_section->vma
			- (input_section->output_offset
			   + input_section->output_section->vma
			   + rel->r_vaddr)
			- 8;

		      tmp = tmp | ((ret_offset >> 2) & 0x00FFFFFF);

		      bfd_put_32 (output_bfd, (bfd_vma) tmp,
				  contents + rel->r_vaddr - input_section->vma);
		      done = 1;
		    }
                }

#ifndef ARM_WINCE
	      /* Note: We used to check for ARM_THUMB9 and ARM_THUMB12.  */
              else if (howto->type == ARM_THUMB23)
                {
                  if (   h->class == C_EXT
		      || h->class == C_STAT
		      || h->class == C_LABEL)
		    {
		      /* Thumb code calling an ARM function */
		      asection *                         s = 0;
		      bfd_vma                            my_offset;
		      unsigned long int                  tmp;
		      long int                           ret_offset;
		      struct coff_link_hash_entry *      myh;
		      struct coff_arm_link_hash_table *  globals;

		      myh = find_thumb_glue (info, name, input_bfd);
		      if (myh == NULL)
			return FALSE;

		      globals = coff_arm_hash_table (info);

		      BFD_ASSERT (globals != NULL);
		      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

		      my_offset = myh->root.u.def.value;

		      s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
						   THUMB2ARM_GLUE_SECTION_NAME);

		      BFD_ASSERT (s != NULL);
		      BFD_ASSERT (s->contents != NULL);
		      BFD_ASSERT (s->output_section != NULL);

		      if ((my_offset & 0x01) == 0x01)
			{
			  if (h_sec->owner != NULL
			      && INTERWORK_SET (h_sec->owner)
			      && ! INTERWORK_FLAG (h_sec->owner)
			      && ! globals->support_old_code)
			    {
			      _bfd_error_handler
				/* xgettext:c-format */
				(_("%s(%s): warning: interworking not enabled."),
				 bfd_archive_filename (h_sec->owner), name);
			      _bfd_error_handler
				/* xgettext:c-format */
				(_("  first occurrence: %s: thumb call to arm"),
				 bfd_archive_filename (input_bfd));
			      _bfd_error_handler
				(_("  consider relinking with --support-old-code enabled"));
			    }

			  -- my_offset;
			  myh->root.u.def.value = my_offset;

			  if (globals->support_old_code)
			    {
			      bfd_put_16 (output_bfd, (bfd_vma) t2a1_push_insn,
					  s->contents + my_offset);

			      bfd_put_16 (output_bfd, (bfd_vma) t2a2_ldr_insn,
					  s->contents + my_offset + 2);

			      bfd_put_16 (output_bfd, (bfd_vma) t2a3_mov_insn,
					  s->contents + my_offset + 4);

			      bfd_put_16 (output_bfd, (bfd_vma) t2a4_bx_insn,
					  s->contents + my_offset + 6);

			      bfd_put_32 (output_bfd, (bfd_vma) t2a5_pop_insn,
					  s->contents + my_offset + 8);

			      bfd_put_32 (output_bfd, (bfd_vma) t2a6_bx_insn,
					  s->contents + my_offset + 12);

			      /* Store the address of the function in the last word of the stub.  */
			      bfd_put_32 (output_bfd, h_val,
					  s->contents + my_offset + 16);

                              if (info->base_file)
                                arm_emit_base_file_entry (info, output_bfd, s,
							  my_offset + 16);
			    }
			  else
			    {
			      bfd_put_16 (output_bfd, (bfd_vma) t2a1_bx_pc_insn,
					  s->contents + my_offset);

			      bfd_put_16 (output_bfd, (bfd_vma) t2a2_noop_insn,
					  s->contents + my_offset + 2);

			      ret_offset =
				((bfd_signed_vma) h_val)	/* Address of destination of the stub.  */
				- ((bfd_signed_vma)
				   (s->output_offset 		/* Offset from the start of the current section to the start of the stubs.  */
				    + my_offset			/* Offset of the start of this stub from the start of the stubs.  */
				    + s->output_section->vma) 	/* Address of the start of the current section.  */
				   + 4				/* The branch instruction is 4 bytes into the stub.  */
				   + 8);			/* ARM branches work from the pc of the instruction + 8.  */

			      bfd_put_32 (output_bfd,
					  (bfd_vma) t2a3_b_insn | ((ret_offset >> 2) & 0x00FFFFFF),
					  s->contents + my_offset + 4);

			    }
			}

		      BFD_ASSERT (my_offset <= globals->thumb_glue_size);

		      /* Now go back and fix up the original BL insn to point
			 to here.  */
		      ret_offset =
			s->output_offset
			+ my_offset
			- (input_section->output_offset
			   + rel->r_vaddr)
			-4;

		      tmp = bfd_get_32 (input_bfd, contents + rel->r_vaddr
					- input_section->vma);

		      bfd_put_32 (output_bfd,
				  (bfd_vma) insert_thumb_branch (tmp,
								 ret_offset),
				  contents + rel->r_vaddr - input_section->vma);

		      done = 1;
                    }
                }
#endif
            }

          /* If the relocation type and destination symbol does not
             fall into one of the above categories, then we can just
             perform a direct link.  */

	  if (done)
	    rstat = bfd_reloc_ok;
	  else
#endif /* THUMBEXTENSION */
	    if (   h->root.type == bfd_link_hash_defined
		|| h->root.type == bfd_link_hash_defweak)
	    {
	      asection *sec;

	      sec = h->root.u.def.section;
	      val = (h->root.u.def.value
		     + sec->output_section->vma
		     + sec->output_offset);
	      }

	  else if (! info->relocatable)
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd, input_section,
		      rel->r_vaddr - input_section->vma, TRUE)))
		return FALSE;
	    }
	}

      if (info->base_file)
	{
	  /* Emit a reloc if the backend thinks it needs it.  */
	  if (sym && pe_data(output_bfd)->in_reloc_p(output_bfd, howto))
            arm_emit_base_file_entry (info, output_bfd, input_section,
				      rel->r_vaddr);
	}

#if 1 /* THUMBEXTENSION */
      if (done)
	rstat = bfd_reloc_ok;
#ifndef ARM_WINCE
      /* Only perform this fix during the final link, not a relocatable link.  nickc@@cygnus.com  */
      else if (! info->relocatable
	       && howto->type == ARM_THUMB23)
        {
          /* This is pretty much a copy of what the default
             _bfd_final_link_relocate and _bfd_relocate_contents
             routines do to perform a relocation, with special
             processing for the split addressing of the Thumb BL
             instruction.  Again, it would probably be simpler adding a
             ThumbBRANCH23 specific macro expansion into the default
             code.  */

          bfd_vma address = rel->r_vaddr - input_section->vma;

          if (address > input_section->_raw_size)
	    rstat = bfd_reloc_outofrange;
          else
            {
              bfd_vma relocation = val + addend;
	      int size = bfd_get_reloc_size (howto);
	      bfd_boolean overflow = FALSE;
	      bfd_byte *location = contents + address;
	      bfd_vma x = bfd_get_32 (input_bfd, location);
	      bfd_vma src_mask = 0x007FFFFE;
	      bfd_signed_vma reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;
	      bfd_signed_vma reloc_signed_min = ~reloc_signed_max;
	      bfd_vma check;
	      bfd_signed_vma signed_check;
	      bfd_vma add;
	      bfd_signed_vma signed_add;

	      BFD_ASSERT (size == 4);

              /* howto->pc_relative should be TRUE for type 14 BRANCH23.  */
              relocation -= (input_section->output_section->vma
                             + input_section->output_offset);

              /* howto->pcrel_offset should be TRUE for type 14 BRANCH23.  */
              relocation -= address;

	      /* No need to negate the relocation with BRANCH23.  */
	      /* howto->complain_on_overflow == complain_overflow_signed for BRANCH23.  */
	      /* howto->rightshift == 1 */

	      /* Drop unwanted bits from the value we are relocating to.  */
	      check = relocation >> howto->rightshift;

	      /* If this is a signed value, the rightshift just dropped
		 leading 1 bits (assuming twos complement).  */
	      if ((bfd_signed_vma) relocation >= 0)
		signed_check = check;
	      else
		signed_check = (check
				| ((bfd_vma) - 1
				   & ~((bfd_vma) - 1 >> howto->rightshift)));

	      /* Get the value from the object file.  */
	      if (bfd_big_endian (input_bfd))
		add = (((x) & 0x07ff0000) >> 4) | (((x) & 0x7ff) << 1);
	      else
		add = ((((x) & 0x7ff) << 12) | (((x) & 0x07ff0000) >> 15));

	      /* Get the value from the object file with an appropriate sign.
		 The expression involving howto->src_mask isolates the upper
		 bit of src_mask.  If that bit is set in the value we are
		 adding, it is negative, and we subtract out that number times
		 two.  If src_mask includes the highest possible bit, then we
		 can not get the upper bit, but that does not matter since
		 signed_add needs no adjustment to become negative in that
		 case.  */
	      signed_add = add;

	      if ((add & (((~ src_mask) >> 1) & src_mask)) != 0)
		signed_add -= (((~ src_mask) >> 1) & src_mask) << 1;

	      /* howto->bitpos == 0 */
	      /* Add the value from the object file, shifted so that it is a
		 straight number.  */
	      signed_check += signed_add;
	      relocation   += signed_add;

	      BFD_ASSERT (howto->complain_on_overflow == complain_overflow_signed);

	      /* Assumes two's complement.  */
	      if (   signed_check > reloc_signed_max
		  || signed_check < reloc_signed_min)
		overflow = TRUE;

	      /* Put the relocation into the correct bits.
		 For a BLX instruction, make sure that the relocation is rounded up
		 to a word boundary.  This follows the semantics of the instruction
		 which specifies that bit 1 of the target address will come from bit
		 1 of the base address.  */
	      if (bfd_big_endian (input_bfd))
	        {
		  if ((x & 0x1800) == 0x0800 && (relocation & 0x02))
		    relocation += 2;
		  relocation = (((relocation & 0xffe) >> 1)  | ((relocation << 4) & 0x07ff0000));
		}
	      else
	        {
		  if ((x & 0x18000000) == 0x08000000 && (relocation & 0x02))
		    relocation += 2;
		  relocation = (((relocation & 0xffe) << 15) | ((relocation >> 12) & 0x7ff));
		}

	      /* Add the relocation to the correct bits of X.  */
	      x = ((x & ~howto->dst_mask) | relocation);

	      /* Put the relocated value back in the object file.  */
	      bfd_put_32 (input_bfd, x, location);

	      rstat = overflow ? bfd_reloc_overflow : bfd_reloc_ok;
            }
        }
#endif
      else
#endif /* THUMBEXTENSION */
        if (info->relocatable && ! howto->partial_inplace)
            rstat = bfd_reloc_ok;
        else
	  rstat = _bfd_final_link_relocate (howto, input_bfd, input_section,
					    contents,
					    rel->r_vaddr - input_section->vma,
					    val, addend);
#if 1 /* THUMBEXTENSION */
      /* FIXME:
	 Is this the best way to fix up thumb addresses? krk@@cygnus.com
	 Probably not, but it works, and if it works it don't need fixing!  nickc@@cygnus.com */
      /* Only perform this fix during the final link, not a relocatable link.  nickc@@cygnus.com  */
      if (! info->relocatable
	  && (rel->r_type == ARM_32 || rel->r_type == ARM_RVA32))
	{
	  /* Determine if we need to set the bottom bit of a relocated address
	     because the address is the address of a Thumb code symbol.  */

	  int patchit = FALSE;

	  if (h != NULL
	      && (   h->class == C_THUMBSTATFUNC
		  || h->class == C_THUMBEXTFUNC))
	    {
	      patchit = TRUE;
	    }
	  else if (sym != NULL
		   && sym->n_scnum > N_UNDEF)
	    {
	      /* No hash entry - use the symbol instead.  */

	      if (   sym->n_sclass == C_THUMBSTATFUNC
		  || sym->n_sclass == C_THUMBEXTFUNC)
		patchit = TRUE;
	    }

	  if (patchit)
	    {
	      bfd_byte * location = contents + rel->r_vaddr - input_section->vma;
	      bfd_vma    x        = bfd_get_32 (input_bfd, location);

	      bfd_put_32 (input_bfd, x | 1, location);
	    }
	}
#endif /* THUMBEXTENSION */

      switch (rstat)
	{
	default:
	  abort ();
	case bfd_reloc_ok:
	  break;
	case bfd_reloc_outofrange:
	  (*_bfd_error_handler)
	    (_("%s: bad reloc address 0x%lx in section `%s'"),
	     bfd_archive_filename (input_bfd),
	     (unsigned long) rel->r_vaddr,
	     bfd_get_section_name (input_bfd, input_section));
	  return FALSE;
	case bfd_reloc_overflow:
	  {
	    const char *name;
	    char buf[SYMNMLEN + 1];

	    if (symndx == -1)
	      name = "*ABS*";
	    else if (h != NULL)
	      name = h->root.root.string;
	    else
	      {
		name = _bfd_coff_internal_syment_name (input_bfd, sym, buf);
		if (name == NULL)
		  return FALSE;
	      }

	    if (! ((*info->callbacks->reloc_overflow)
		   (info, name, howto->name, (bfd_vma) 0, input_bfd,
		    input_section, rel->r_vaddr - input_section->vma)))
	      return FALSE;
	  }
	}
    }

  return TRUE;
}

#ifndef COFF_IMAGE_WITH_PE

bfd_boolean
bfd_arm_allocate_interworking_sections (info)
     struct bfd_link_info * info;
{
  asection *                        s;
  bfd_byte *                        foo;
  struct coff_arm_link_hash_table * globals;
#if 0
  static char                       test_char = '1';
#endif

  globals = coff_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);

  if (globals->arm_glue_size != 0)
    {
      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

      s = bfd_get_section_by_name
	(globals->bfd_of_glue_owner, ARM2THUMB_GLUE_SECTION_NAME);

      BFD_ASSERT (s != NULL);

      foo = (bfd_byte *) bfd_alloc (globals->bfd_of_glue_owner,
				    globals->arm_glue_size);
#if 0
      memset (foo, test_char, (size_t) globals->arm_glue_size);
#endif

      s->_raw_size = s->_cooked_size = globals->arm_glue_size;
      s->contents = foo;
    }

  if (globals->thumb_glue_size != 0)
    {
      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

      s = bfd_get_section_by_name
	(globals->bfd_of_glue_owner, THUMB2ARM_GLUE_SECTION_NAME);

      BFD_ASSERT (s != NULL);

      foo = (bfd_byte *) bfd_alloc (globals->bfd_of_glue_owner,
				    globals->thumb_glue_size);
#if 0
      memset (foo, test_char, (size_t) globals->thumb_glue_size);
#endif

      s->_raw_size = s->_cooked_size = globals->thumb_glue_size;
      s->contents = foo;
    }

  return TRUE;
}

static void
record_arm_to_thumb_glue (info, h)
     struct bfd_link_info *        info;
     struct coff_link_hash_entry * h;
{
  const char *                      name = h->root.root.string;
  register asection *               s;
  char *                            tmp_name;
  struct coff_link_hash_entry *     myh;
  struct bfd_link_hash_entry *      bh;
  struct coff_arm_link_hash_table * globals;
  bfd_vma val;
  bfd_size_type amt;

  globals = coff_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  s = bfd_get_section_by_name
    (globals->bfd_of_glue_owner, ARM2THUMB_GLUE_SECTION_NAME);

  BFD_ASSERT (s != NULL);

  amt = strlen (name) + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1;
  tmp_name = (char *) bfd_malloc (amt);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, ARM2THUMB_GLUE_ENTRY_NAME, name);

  myh = coff_link_hash_lookup
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);

  if (myh != NULL)
    {
      free (tmp_name);
      return; /* we've already seen this guy */
    }

  /* The only trick here is using globals->arm_glue_size as the value. Even
     though the section isn't allocated yet, this is where we will be putting
     it.  */

  bh = NULL;
  val = globals->arm_glue_size + 1;
  bfd_coff_link_add_one_symbol (info, globals->bfd_of_glue_owner, tmp_name,
				BSF_GLOBAL, s, val, NULL, TRUE, FALSE, &bh);

  free (tmp_name);

  globals->arm_glue_size += ARM2THUMB_GLUE_SIZE;

  return;
}

#ifndef ARM_WINCE
static void
record_thumb_to_arm_glue (info, h)
     struct bfd_link_info *        info;
     struct coff_link_hash_entry * h;
{
  const char *                       name = h->root.root.string;
  register asection *                s;
  char *                             tmp_name;
  struct coff_link_hash_entry *      myh;
  struct bfd_link_hash_entry *       bh;
  struct coff_arm_link_hash_table *  globals;
  bfd_vma val;
  bfd_size_type amt;

  globals = coff_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  s = bfd_get_section_by_name
    (globals->bfd_of_glue_owner, THUMB2ARM_GLUE_SECTION_NAME);

  BFD_ASSERT (s != NULL);

  amt = strlen (name) + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1;
  tmp_name = (char *) bfd_malloc (amt);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, THUMB2ARM_GLUE_ENTRY_NAME, name);

  myh = coff_link_hash_lookup
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);

  if (myh != NULL)
    {
      free (tmp_name);
      return; /* we've already seen this guy */
    }

  bh = NULL;
  val = globals->thumb_glue_size + 1;
  bfd_coff_link_add_one_symbol (info, globals->bfd_of_glue_owner, tmp_name,
				BSF_GLOBAL, s, val, NULL, TRUE, FALSE, &bh);

  /* If we mark it 'thumb', the disassembler will do a better job.  */
  myh = (struct coff_link_hash_entry *) bh;
  myh->class = C_THUMBEXTFUNC;

  free (tmp_name);

  /* Allocate another symbol to mark where we switch to arm mode.  */

#define CHANGE_TO_ARM "__%s_change_to_arm"
#define BACK_FROM_ARM "__%s_back_from_arm"

  amt = strlen (name) + strlen (CHANGE_TO_ARM) + 1;
  tmp_name = (char *) bfd_malloc (amt);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, globals->support_old_code ? BACK_FROM_ARM : CHANGE_TO_ARM, name);

  bh = NULL;
  val = globals->thumb_glue_size + (globals->support_old_code ? 8 : 4);
  bfd_coff_link_add_one_symbol (info, globals->bfd_of_glue_owner, tmp_name,
				BSF_LOCAL, s, val, NULL, TRUE, FALSE, &bh);

  free (tmp_name);

  globals->thumb_glue_size += THUMB2ARM_GLUE_SIZE;

  return;
}
#endif /* not ARM_WINCE */

/* Select a BFD to be used to hold the sections used by the glue code.
   This function is called from the linker scripts in ld/emultempl/
   {armcoff/pe}.em  */

bfd_boolean
bfd_arm_get_bfd_for_interworking (abfd, info)
     bfd * 		    abfd;
     struct bfd_link_info * info;
{
  struct coff_arm_link_hash_table * globals;
  flagword   			    flags;
  asection * 			    sec;

  /* If we are only performing a partial link do not bother
     getting a bfd to hold the glue.  */
  if (info->relocatable)
    return TRUE;

  globals = coff_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);

  if (globals->bfd_of_glue_owner != NULL)
    return TRUE;

  sec = bfd_get_section_by_name (abfd, ARM2THUMB_GLUE_SECTION_NAME);

  if (sec == NULL)
    {
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_CODE | SEC_READONLY;

      sec = bfd_make_section (abfd, ARM2THUMB_GLUE_SECTION_NAME);

      if (sec == NULL
	  || ! bfd_set_section_flags (abfd, sec, flags)
	  || ! bfd_set_section_alignment (abfd, sec, 2))
	return FALSE;
    }

  sec = bfd_get_section_by_name (abfd, THUMB2ARM_GLUE_SECTION_NAME);

  if (sec == NULL)
    {
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_CODE | SEC_READONLY;

      sec = bfd_make_section (abfd, THUMB2ARM_GLUE_SECTION_NAME);

      if (sec == NULL
	  || ! bfd_set_section_flags (abfd, sec, flags)
	  || ! bfd_set_section_alignment (abfd, sec, 2))
	return FALSE;
    }

  /* Save the bfd for later use.  */
  globals->bfd_of_glue_owner = abfd;

  return TRUE;
}

bfd_boolean
bfd_arm_process_before_allocation (abfd, info, support_old_code)
     bfd *                   abfd;
     struct bfd_link_info *  info;
     int		     support_old_code;
{
  asection * sec;
  struct coff_arm_link_hash_table * globals;

  /* If we are only performing a partial link do not bother
     to construct any glue.  */
  if (info->relocatable)
    return TRUE;

  /* Here we have a bfd that is to be included on the link.  We have a hook
     to do reloc rummaging, before section sizes are nailed down.  */

  _bfd_coff_get_external_symbols (abfd);

  globals = coff_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  globals->support_old_code = support_old_code;

  /* Rummage around all the relocs and map the glue vectors.  */
  sec = abfd->sections;

  if (sec == NULL)
    return TRUE;

  for (; sec != NULL; sec = sec->next)
    {
      struct internal_reloc * i;
      struct internal_reloc * rel;

      if (sec->reloc_count == 0)
	continue;

      /* Load the relocs.  */
      /* FIXME: there may be a storage leak here.  */

      i = _bfd_coff_read_internal_relocs (abfd, sec, 1, 0, 0, 0);

      BFD_ASSERT (i != 0);

      for (rel = i; rel < i + sec->reloc_count; ++rel)
	{
	  unsigned short                 r_type  = rel->r_type;
	  long                           symndx;
	  struct coff_link_hash_entry *  h;

	  symndx = rel->r_symndx;

	  /* If the relocation is not against a symbol it cannot concern us.  */
	  if (symndx == -1)
	    continue;

	  /* If the index is outside of the range of our table, something has gone wrong.  */
	  if (symndx >= obj_conv_table_size (abfd))
	    {
	      _bfd_error_handler (_("%s: illegal symbol index in reloc: %d"),
				  bfd_archive_filename (abfd), symndx);
	      continue;
	    }

	  h = obj_coff_sym_hashes (abfd)[symndx];

	  /* If the relocation is against a static symbol it must be within
	     the current section and so cannot be a cross ARM/Thumb relocation.  */
	  if (h == NULL)
	    continue;

	  switch (r_type)
	    {
	    case ARM_26:
	      /* This one is a call from arm code.  We need to look up
		 the target of the call. If it is a thumb target, we
		 insert glue.  */

	      if (h->class == C_THUMBEXTFUNC)
		record_arm_to_thumb_glue (info, h);
	      break;

#ifndef ARM_WINCE
	    case ARM_THUMB23:
	      /* This one is a call from thumb code.  We used to look
		 for ARM_THUMB9 and ARM_THUMB12 as well.  We need to look
		 up the target of the call. If it is an arm target, we
		 insert glue.  If the symbol does not exist it will be
		 given a class of C_EXT and so we will generate a stub
		 for it.  This is not really a problem, since the link
		 is doomed anyway.  */

	      switch (h->class)
		{
		case C_EXT:
		case C_STAT:
		case C_LABEL:
		  record_thumb_to_arm_glue (info, h);
		  break;
		default:
		  ;
		}
	      break;
#endif

	    default:
	      break;
	    }
	}
    }

  return TRUE;
}

#endif /* ! defined (COFF_IMAGE_WITH_PE) */

#define coff_bfd_reloc_type_lookup 		coff_arm_reloc_type_lookup
#define coff_relocate_section 			coff_arm_relocate_section
#define coff_bfd_is_local_label_name 		coff_arm_is_local_label_name
#define coff_adjust_symndx			coff_arm_adjust_symndx
#define coff_link_output_has_begun 		coff_arm_link_output_has_begun
#define coff_final_link_postscript		coff_arm_final_link_postscript
#define coff_bfd_merge_private_bfd_data		coff_arm_merge_private_bfd_data
#define coff_bfd_print_private_bfd_data		coff_arm_print_private_bfd_data
#define coff_bfd_set_private_flags              _bfd_coff_arm_set_private_flags
#define coff_bfd_copy_private_bfd_data          coff_arm_copy_private_bfd_data
#define coff_bfd_link_hash_table_create		coff_arm_link_hash_table_create

/* When doing a relocatable link, we want to convert ARM_26 relocs
   into ARM_26D relocs.  */

static bfd_boolean
coff_arm_adjust_symndx (obfd, info, ibfd, sec, irel, adjustedp)
     bfd *obfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     bfd *ibfd;
     asection *sec;
     struct internal_reloc *irel;
     bfd_boolean *adjustedp;
{
  if (irel->r_type == ARM_26)
    {
      struct coff_link_hash_entry *h;

      h = obj_coff_sym_hashes (ibfd)[irel->r_symndx];
      if (h != NULL
	  && (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	  && h->root.u.def.section->output_section == sec->output_section)
	irel->r_type = ARM_26D;
    }
  *adjustedp = FALSE;
  return TRUE;
}

/* Called when merging the private data areas of two BFDs.
   This is important as it allows us to detect if we are
   attempting to merge binaries compiled for different ARM
   targets, eg different CPUs or different APCS's.     */

static bfd_boolean
coff_arm_merge_private_bfd_data (ibfd, obfd)
     bfd *   ibfd;
     bfd *   obfd;
{
  BFD_ASSERT (ibfd != NULL && obfd != NULL);

  if (ibfd == obfd)
    return TRUE;

  /* If the two formats are different we cannot merge anything.
     This is not an error, since it is permissable to change the
     input and output formats.  */
  if (   ibfd->xvec->flavour != bfd_target_coff_flavour
      || obfd->xvec->flavour != bfd_target_coff_flavour)
    return TRUE;

  /* Determine what should happen if the input ARM architecture
     does not match the output ARM architecture.  */
  if (! bfd_arm_merge_machines (ibfd, obfd))
    return FALSE;

  /* Verify that the APCS is the same for the two BFDs.  */
  if (APCS_SET (ibfd))
    {
      if (APCS_SET (obfd))
	{
	  /* If the src and dest have different APCS flag bits set, fail.  */
	  if (APCS_26_FLAG (obfd) != APCS_26_FLAG (ibfd))
	    {
	      _bfd_error_handler
		/* xgettext: c-format */
		(_("ERROR: %s is compiled for APCS-%d, whereas %s is compiled for APCS-%d"),
		 bfd_archive_filename (ibfd), APCS_26_FLAG (ibfd) ? 26 : 32,
		 bfd_get_filename (obfd), APCS_26_FLAG (obfd) ? 26 : 32
		 );

	      bfd_set_error (bfd_error_wrong_format);
	      return FALSE;
	    }

	  if (APCS_FLOAT_FLAG (obfd) != APCS_FLOAT_FLAG (ibfd))
	    {
	      const char *msg;

	      if (APCS_FLOAT_FLAG (ibfd))
		/* xgettext: c-format */
		msg = _("ERROR: %s passes floats in float registers, whereas %s passes them in integer registers");
	      else
		/* xgettext: c-format */
		msg = _("ERROR: %s passes floats in integer registers, whereas %s passes them in float registers");

	      _bfd_error_handler (msg, bfd_archive_filename (ibfd),
				  bfd_get_filename (obfd));

	      bfd_set_error (bfd_error_wrong_format);
	      return FALSE;
	    }

	  if (PIC_FLAG (obfd) != PIC_FLAG (ibfd))
	    {
	      const char * msg;

	      if (PIC_FLAG (ibfd))
		/* xgettext: c-format */
		msg = _("ERROR: %s is compiled as position independent code, whereas target %s is absolute position");
	      else
		/* xgettext: c-format */
		msg = _("ERROR: %s is compiled as absolute position code, whereas target %s is position independent");
	      _bfd_error_handler (msg, bfd_archive_filename (ibfd),
				  bfd_get_filename (obfd));

	      bfd_set_error (bfd_error_wrong_format);
	      return FALSE;
	    }
	}
      else
	{
	  SET_APCS_FLAGS (obfd, APCS_26_FLAG (ibfd) | APCS_FLOAT_FLAG (ibfd) | PIC_FLAG (ibfd));

	  /* Set up the arch and fields as well as these are probably wrong.  */
	  bfd_set_arch_mach (obfd, bfd_get_arch (ibfd), bfd_get_mach (ibfd));
	}
    }

  /* Check the interworking support.  */
  if (INTERWORK_SET (ibfd))
    {
      if (INTERWORK_SET (obfd))
	{
	  /* If the src and dest differ in their interworking issue a warning.  */
	  if (INTERWORK_FLAG (obfd) != INTERWORK_FLAG (ibfd))
	    {
	      const char * msg;

	      if (INTERWORK_FLAG (ibfd))
		/* xgettext: c-format */
		msg = _("Warning: %s supports interworking, whereas %s does not");
	      else
		/* xgettext: c-format */
		msg = _("Warning: %s does not support interworking, whereas %s does");

	      _bfd_error_handler (msg, bfd_archive_filename (ibfd),
				  bfd_get_filename (obfd));
	    }
	}
      else
	{
	  SET_INTERWORK_FLAG (obfd, INTERWORK_FLAG (ibfd));
	}
    }

  return TRUE;
}

/* Display the flags field.  */

static bfd_boolean
coff_arm_print_private_bfd_data (abfd, ptr)
     bfd *   abfd;
     PTR     ptr;
{
  FILE * file = (FILE *) ptr;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  /* xgettext:c-format */
  fprintf (file, _("private flags = %x:"), coff_data (abfd)->flags);

  if (APCS_SET (abfd))
    {
      /* xgettext: APCS is ARM Procedure Call Standard, it should not be translated.  */
      fprintf (file, " [APCS-%d]", APCS_26_FLAG (abfd) ? 26 : 32);

      if (APCS_FLOAT_FLAG (abfd))
	fprintf (file, _(" [floats passed in float registers]"));
      else
	fprintf (file, _(" [floats passed in integer registers]"));

      if (PIC_FLAG (abfd))
	fprintf (file, _(" [position independent]"));
      else
	fprintf (file, _(" [absolute position]"));
    }

  if (! INTERWORK_SET (abfd))
    fprintf (file, _(" [interworking flag not initialised]"));
  else if (INTERWORK_FLAG (abfd))
    fprintf (file, _(" [interworking supported]"));
  else
    fprintf (file, _(" [interworking not supported]"));

  fputc ('\n', file);

  return TRUE;
}

/* Copies the given flags into the coff_tdata.flags field.
   Typically these flags come from the f_flags[] field of
   the COFF filehdr structure, which contains important,
   target specific information.
   Note: Although this function is static, it is explicitly
   called from both coffcode.h and peicode.h.  */

static bfd_boolean
_bfd_coff_arm_set_private_flags (abfd, flags)
	bfd *	   abfd;
	flagword   flags;
{
  flagword flag;

  BFD_ASSERT (abfd != NULL);

  flag = (flags & F_APCS26) ? F_APCS_26 : 0;

  /* Make sure that the APCS field has not been initialised to the opposite
     value.  */
  if (APCS_SET (abfd)
      && (   (APCS_26_FLAG    (abfd) != flag)
	  || (APCS_FLOAT_FLAG (abfd) != (flags & F_APCS_FLOAT))
	  || (PIC_FLAG        (abfd) != (flags & F_PIC))
	  ))
    return FALSE;

  flag |= (flags & (F_APCS_FLOAT | F_PIC));

  SET_APCS_FLAGS (abfd, flag);

  flag = (flags & F_INTERWORK);

  /* If the BFD has already had its interworking flag set, but it
     is different from the value that we have been asked to set,
     then assume that that merged code will not support interworking
     and set the flag accordingly.  */
  if (INTERWORK_SET (abfd) && (INTERWORK_FLAG (abfd) != flag))
    {
      if (flag)
	/* xgettext: c-format */
	_bfd_error_handler (_("Warning: Not setting interworking flag of %s since it has already been specified as non-interworking"),
			    bfd_archive_filename (abfd));
      else
	/* xgettext: c-format */
	_bfd_error_handler (_("Warning: Clearing the interworking flag of %s due to outside request"),
			    bfd_archive_filename (abfd));
      flag = 0;
    }

  SET_INTERWORK_FLAG (abfd, flag);

  return TRUE;
}

/* Copy the important parts of the target specific data
   from one instance of a BFD to another.  */

static bfd_boolean
coff_arm_copy_private_bfd_data (src, dest)
     bfd *  src;
     bfd *  dest;
{
  BFD_ASSERT (src != NULL && dest != NULL);

  if (src == dest)
    return TRUE;

  /* If the destination is not in the same format as the source, do not do
     the copy.  */
  if (src->xvec != dest->xvec)
    return TRUE;

  /* copy the flags field */
  if (APCS_SET (src))
    {
      if (APCS_SET (dest))
	{
	  /* If the src and dest have different APCS flag bits set, fail.  */
	  if (APCS_26_FLAG (dest) != APCS_26_FLAG (src))
	    return FALSE;

	  if (APCS_FLOAT_FLAG (dest) != APCS_FLOAT_FLAG (src))
	    return FALSE;

	  if (PIC_FLAG (dest) != PIC_FLAG (src))
	    return FALSE;
	}
      else
	SET_APCS_FLAGS (dest, APCS_26_FLAG (src) | APCS_FLOAT_FLAG (src)
			| PIC_FLAG (src));
    }

  if (INTERWORK_SET (src))
    {
      if (INTERWORK_SET (dest))
	{
	  /* If the src and dest have different interworking flags then turn
	     off the interworking bit.  */
	  if (INTERWORK_FLAG (dest) != INTERWORK_FLAG (src))
	    {
	      if (INTERWORK_FLAG (dest))
		{
		  /* xgettext:c-format */
		  _bfd_error_handler (("\
Warning: Clearing the interworking flag of %s because non-interworking code in %s has been linked with it"),
				      bfd_get_filename (dest),
				      bfd_archive_filename (src));
		}

	      SET_INTERWORK_FLAG (dest, 0);
	    }
	}
      else
	{
	  SET_INTERWORK_FLAG (dest, INTERWORK_FLAG (src));
	}
    }

  return TRUE;
}

/* Note:  the definitions here of LOCAL_LABEL_PREFIX and USER_LABEL_PREIFX
   *must* match the definitions in gcc/config/arm/{coff|semi|aout}.h.  */
#define LOCAL_LABEL_PREFIX ""
#ifndef USER_LABEL_PREFIX
#define USER_LABEL_PREFIX "_"
#endif

/* Like _bfd_coff_is_local_label_name, but
   a) test against USER_LABEL_PREFIX, to avoid stripping labels known to be
      non-local.
   b) Allow other prefixes than ".", e.g. an empty prefix would cause all
      labels of the form Lxxx to be stripped.  */
static bfd_boolean
coff_arm_is_local_label_name (abfd, name)
     bfd *        abfd ATTRIBUTE_UNUSED;
     const char * name;
{
#ifdef USER_LABEL_PREFIX
  if (USER_LABEL_PREFIX[0] != 0)
    {
      if (strncmp (name, USER_LABEL_PREFIX, strlen (USER_LABEL_PREFIX)) == 0)
	return FALSE;
    }
#endif

#ifdef LOCAL_LABEL_PREFIX
  /* If there is a prefix for local labels then look for this.
     If the prefix exists, but it is empty, then ignore the test.  */

  if (LOCAL_LABEL_PREFIX[0] != 0)
    {
      size_t len = strlen (LOCAL_LABEL_PREFIX);

      if (strncmp (name, LOCAL_LABEL_PREFIX, len) != 0)
	return FALSE;

      /* Perform the checks below for the rest of the name.  */
      name += len;
    }
#endif

  return name[0] == 'L';
}

/* This piece of machinery exists only to guarantee that the bfd that holds
   the glue section is written last.

   This does depend on bfd_make_section attaching a new section to the
   end of the section list for the bfd.

   krk@@cygnus.com  */

static bfd_boolean
coff_arm_link_output_has_begun (sub, info)
     bfd * sub;
     struct coff_final_link_info * info;
{
  return (sub->output_has_begun
	  || sub == coff_arm_hash_table (info->info)->bfd_of_glue_owner);
}

static bfd_boolean
coff_arm_final_link_postscript (abfd, pfinfo)
     bfd * abfd ATTRIBUTE_UNUSED;
     struct coff_final_link_info * pfinfo;
{
  struct coff_arm_link_hash_table * globals;

  globals = coff_arm_hash_table (pfinfo->info);

  BFD_ASSERT (globals != NULL);

  if (globals->bfd_of_glue_owner != NULL)
    {
      if (! _bfd_coff_link_input_bfd (pfinfo, globals->bfd_of_glue_owner))
	return FALSE;

      globals->bfd_of_glue_owner->output_has_begun = TRUE;
    }

  return bfd_arm_update_notes (abfd, ARM_NOTE_SECTION);
}

#include "coffcode.h"

#ifndef TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM armcoff_little_vec
#endif
#ifndef TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME "coff-arm-little"
#endif
#ifndef TARGET_BIG_SYM
#define TARGET_BIG_SYM armcoff_big_vec
#endif
#ifndef TARGET_BIG_NAME
#define TARGET_BIG_NAME "coff-arm-big"
#endif

#ifndef TARGET_UNDERSCORE
#define TARGET_UNDERSCORE 0
#endif

#ifndef EXTRA_S_FLAGS
#ifdef COFF_WITH_PE
#define EXTRA_S_FLAGS (SEC_CODE | SEC_LINK_ONCE | SEC_LINK_DUPLICATES)
#else
#define EXTRA_S_FLAGS SEC_CODE
#endif
#endif

/* Forward declaration for use initialising alternative_target field.  */
extern const bfd_target TARGET_BIG_SYM ;

/* Target vectors.  */
CREATE_LITTLE_COFF_TARGET_VEC (TARGET_LITTLE_SYM, TARGET_LITTLE_NAME, D_PAGED, EXTRA_S_FLAGS, TARGET_UNDERSCORE, & TARGET_BIG_SYM, COFF_SWAP_TABLE)
CREATE_BIG_COFF_TARGET_VEC (TARGET_BIG_SYM, TARGET_BIG_NAME, D_PAGED, EXTRA_S_FLAGS, TARGET_UNDERSCORE, & TARGET_LITTLE_SYM, COFF_SWAP_TABLE)
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2000, 2001, 2002
d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d255 1
a259 1
#define ARM_26D      5
d267 13
a279 1
    EMPTY_HOWTO (-1),
d289 1
a289 1
	   TRUE,
d302 1
a302 1
	   TRUE,
d332 1
a332 13
    HOWTO (ARM_26D,
	   2,
	   2,
	   24,
	   FALSE,
	   0,
	   complain_overflow_dont,
	   aoutarm_fix_pcrel_26_done,
	   "ARM_26D",
	   TRUE,
	   0x00ffffff,
	   0x0,
	   FALSE),
d349 2
a350 2
	   "ARM_16",
	   TRUE,
d362 2
a363 2
	   "ARM_32",
	   TRUE,
d924 1
a924 1
    /* The size in bytes of the section containg the Thumb-to-ARM glue.  */
d927 1
a927 1
    /* The size in bytes of the section containg the ARM-to-Thumb glue.  */
d930 1
a930 1
    /* An arbitary input BFD chosen to hold the glue sections.  */
d994 1
a994 1
   11 bits to invest. The upper 11 bits are stored in one (identifed by
d1250 2
a1251 2
         when doing a relocateable link.  However, we want to convert
         ARM26 to ARM26D relocs if possible.  We return a fake howto in
d1253 2
a1254 1
         compensate.  */
d1257 1
a1257 1
          && info->relocateable
d1273 1
a1273 1
    	       FALSE,
d1279 5
d1292 1
a1292 1
      if (howto->pc_relative && !info->relocateable)
d1297 1
a1297 1
      /* If we are doing a relocateable link, then we can just ignore
d1299 1
a1299 1
         have the correct value.  If this is not a relocateable link,
d1303 1
a1303 1
          if (info->relocateable)
d1308 1
a1308 1
	     was supressed for other ARM targets.  This ought to be
d1350 1
a1350 1
          if (! info->relocateable
d1604 1
a1604 1
	  else if (! info->relocateable)
d1626 1
a1626 1
      else if (! info->relocateable
d1743 7
a1749 4
        rstat = _bfd_final_link_relocate (howto, input_bfd, input_section,
                                          contents,
                                          rel->r_vaddr - input_section->vma,
                                          val, addend);
d1755 1
a1755 1
      if (! info->relocateable
d2035 1
a2035 1
  if (info->relocateable)
d2090 1
a2090 1
  if (info->relocateable)
d2210 2
a2211 2
/* When doing a relocateable link, we want to convert ARM26 relocs
   into ARM26D relocs.  */
d2222 1
a2222 1
  if (irel->r_type == 3)
d2231 1
a2231 1
	irel->r_type = 7;
d2240 1
a2240 1
   targets, eg different CPUs or differents APCS's.     */
d2373 1
a2373 1
      /* xgettext: APCS is ARM Prodecure Call Standard, it should not be translated.  */
d2625 1
a2625 1
#define EXTRA_S_FLAGS (SEC_LINK_ONCE | SEC_LINK_DUPLICATES)
d2627 1
a2627 1
#define EXTRA_S_FLAGS 0
d2635 2
a2636 2
CREATE_LITTLE_COFF_TARGET_VEC (TARGET_LITTLE_SYM, TARGET_LITTLE_NAME, D_PAGED, EXTRA_S_FLAGS, TARGET_UNDERSCORE, & TARGET_BIG_SYM)
CREATE_BIG_COFF_TARGET_VEC (TARGET_BIG_SYM, TARGET_BIG_NAME, D_PAGED, EXTRA_S_FLAGS, TARGET_UNDERSCORE, & TARGET_LITTLE_SYM)
@


1.5
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2000, 2001
d39 33
a71 12
#define APCS_26_FLAG(       abfd )	(coff_data (abfd)->flags & F_APCS_26)
#define APCS_FLOAT_FLAG(    abfd )	(coff_data (abfd)->flags & F_APCS_FLOAT)
#define PIC_FLAG(           abfd )	(coff_data (abfd)->flags & F_PIC)
#define APCS_SET(           abfd )	(coff_data (abfd)->flags & F_APCS_SET)
#define SET_APCS_FLAGS(     abfd, flgs)	(coff_data (abfd)->flags = \
					(coff_data (abfd)->flags & ~ (F_APCS_26 | F_APCS_FLOAT | F_PIC)) \
					 | (flgs | F_APCS_SET))
#define INTERWORK_FLAG(     abfd ) 	(coff_data (abfd)->flags & F_INTERWORK)
#define INTERWORK_SET(      abfd ) 	(coff_data (abfd)->flags & F_INTERWORK_SET)
#define SET_INTERWORK_FLAG( abfd, flg )	(coff_data (abfd)->flags = \
					(coff_data (abfd)->flags & ~ F_INTERWORK) \
					 | (flg | F_INTERWORK_SET))
d83 1
a83 1
static boolean coff_arm_relocate_section
d90 1
d93 5
a99 2
static bfd_reloc_status_type coff_thumb_pcrel_9
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d102 1
a102 1
static boolean coff_arm_adjust_symndx
d104 1
a104 1
	   asection *, struct internal_reloc *,	boolean *));
d107 2
a108 1
	   struct coff_link_hash_entry *, struct internal_syment *, bfd_vma *));
d112 1
a112 1
static CONST struct reloc_howto_struct * coff_arm_reloc_type_lookup
a115 2
static insn32 insert_thumb_branch
  PARAMS ((insn32, int));
d117 1
a117 1
  PARAMS ((struct bfd_link_info *, CONST char *, bfd *));
d119 1
a119 1
  PARAMS ((struct bfd_link_info *, CONST char *, bfd *));
d123 1
d127 2
a128 1
static boolean coff_arm_merge_private_bfd_data
d130 1
a130 1
static boolean coff_arm_print_private_bfd_data
d132 1
a132 1
static boolean _bfd_coff_arm_set_private_flags
d134 1
a134 1
static boolean coff_arm_copy_private_bfd_data
d136 1
a136 1
static boolean coff_arm_is_local_label_name
d138 1
a138 1
static boolean coff_arm_link_output_has_begun
d140 1
a140 1
static boolean coff_arm_final_link_postscript
d142 2
d148 1
a148 2
   name can be changed. The only requirement is the %s be present.
   */
d157 1
d175 3
a177 2
#define DOIT(x) \
  x = ((x & ~howto->dst_mask) | (((x & howto->src_mask) + diff) & howto->dst_mask))
d198 1
a198 1
	      bfd_put_16 (abfd, x, addr);
d206 1
a206 1
	      bfd_put_32 (abfd, x, addr);
d227 1
a227 1
#define PCRELOFFSET true
d265 1
a265 2
{
  /* type              rs size bsz  pcrel bitpos ovrf                     sf name     part_inpl readmask  setmask    pcdone */
d267 100
a366 100
  EMPTY_HOWTO (-1),
  HOWTO (ARM_32,
	0,
	2,
	32,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_32",
        true,
	0xffffffff,
	0xffffffff,
	PCRELOFFSET),
  HOWTO (ARM_RVA32,
	0,
	2,
	32,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_RVA32",
        true,
	0xffffffff,
	0xffffffff,
	PCRELOFFSET),
  HOWTO (ARM_26,
	2,
	2,
	24,
	true,
	0,
	complain_overflow_signed,
	aoutarm_fix_pcrel_26 ,
	"ARM_26",
	false,
	0x00ffffff,
	0x00ffffff,
	PCRELOFFSET),
  HOWTO (ARM_THUMB12,
	1,
	1,
	11,
	true,
	0,
	complain_overflow_signed,
	coff_thumb_pcrel_12 ,
	"ARM_THUMB12",
	false,
	0x000007ff,
	0x000007ff,
	PCRELOFFSET),
  HOWTO (ARM_26D,
	2,
	2,
	24,
	false,
	0,
	complain_overflow_dont,
	aoutarm_fix_pcrel_26_done,
	"ARM_26D",
	true,
	0x00ffffff,
	0x0,
	false),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  HOWTO (ARM_SECTION,
	0,
	1,
	16,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_16",
	true,
	0x0000ffff,
	0x0000ffff,
	PCRELOFFSET),
  HOWTO (ARM_SECREL,
	0,
	2,
	32,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_32",
        true,
	0xffffffff,
	0xffffffff,
	PCRELOFFSET),
d368 184
a551 184
  HOWTO(ARM_8,			/* type */
	0,			/* rightshift */
	0,			/* size */
	8,			/* bitsize */
	false,			/* pc_relative */
	0,			/* bitpos */
	complain_overflow_bitfield, /* complain_on_overflow */
	coff_arm_reloc,		/* special_function */
	"ARM_8",		/* name */
        true,			/* partial_inplace */
	0x000000ff,		/* src_mask */
	0x000000ff,		/* dst_mask */
	PCRELOFFSET		/* pcrel_offset */),
  HOWTO(ARM_16,
	0,
	1,
	16,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_16",
	true,
	0x0000ffff,
	0x0000ffff,
	PCRELOFFSET),
  HOWTO(ARM_32,
	0,
	2,
	32,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_32",
        true,
	0xffffffff,
	0xffffffff,
	PCRELOFFSET),
  HOWTO(ARM_26,
	2,
	2,
	24,
	true,
	0,
	complain_overflow_signed,
	aoutarm_fix_pcrel_26 ,
	"ARM_26",
	false,
	0x00ffffff,
	0x00ffffff,
	PCRELOFFSET),
  HOWTO(ARM_DISP8,
	0,
	0,
	8,
	true,
	0,
	complain_overflow_signed,
	coff_arm_reloc,
	"ARM_DISP8",
	true,
	0x000000ff,
	0x000000ff,
	true),
  HOWTO( ARM_DISP16,
	0,
	1,
	16,
	true,
	0,
	complain_overflow_signed,
	coff_arm_reloc,
	"ARM_DISP16",
	true,
	0x0000ffff,
	0x0000ffff,
	true),
  HOWTO( ARM_DISP32,
	0,
	2,
	32,
	true,
	0,
	complain_overflow_signed,
 	coff_arm_reloc,
	"ARM_DISP32",
	true,
	0xffffffff,
	0xffffffff,
	true),
  HOWTO( ARM_26D,
	2,
	2,
	24,
	false,
	0,
	complain_overflow_dont,
	aoutarm_fix_pcrel_26_done,
	"ARM_26D",
	true,
	0x00ffffff,
	0x0,
	false),
  /* 8 is unused */
  EMPTY_HOWTO (-1),
  HOWTO( ARM_NEG16,
	0,
	-1,
	16,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_NEG16",
        true,
	0x0000ffff,
	0x0000ffff,
	false),
  HOWTO( ARM_NEG32,
	0,
	-2,
	32,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_NEG32",
        true,
	0xffffffff,
	0xffffffff,
	false),
  HOWTO( ARM_RVA32,
	0,
	2,
	32,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_RVA32",
        true,
	0xffffffff,
	0xffffffff,
	PCRELOFFSET),
  HOWTO( ARM_THUMB9,
	1,
	1,
	8,
	true,
	0,
	complain_overflow_signed,
	coff_thumb_pcrel_9 ,
	"ARM_THUMB9",
	false,
	0x000000ff,
	0x000000ff,
	PCRELOFFSET),
  HOWTO( ARM_THUMB12,
	1,
	1,
	11,
	true,
	0,
	complain_overflow_signed,
	coff_thumb_pcrel_12 ,
	"ARM_THUMB12",
	false,
	0x000007ff,
	0x000007ff,
	PCRELOFFSET),
  HOWTO( ARM_THUMB23,
	1,
	2,
	22,
	true,
	0,
	complain_overflow_signed,
	coff_thumb_pcrel_23 ,
	"ARM_THUMB23",
	false,
	0x07ff07ff,
	0x07ff07ff,
	PCRELOFFSET)
d553 1
a553 1
};
d558 2
a559 1
/* Return true if this relocation should
d562 1
a562 1
static boolean
d600 1
d636 1
a636 1
  /* If this is an undefined symbol, return error */
d648 1
a648 1
  relocation = (relocation ^ 0x02000000) - 0x02000000; /* Sign extend */
d660 1
a660 1
  /* Check for overflow */
d666 1
a666 1
  else if (relocation & ~0x03ffffff)
d671 1
a671 1
  bfd_put_32 (abfd, target, (bfd_byte *) data + addr);
d727 1
a727 1
  /* If this is an undefined symbol, return error */
d756 1
a756 1
  relocation = (relocation ^ signbit) - signbit; /* Sign extend */
d768 1
a768 1
  /* Check for overflow */
d787 2
a788 1
       target |= ((relocation & 0xfff) >> 1)  | ((relocation << 4)  & 0x07ff0000);
d790 2
a791 1
       target |= ((relocation & 0xffe) << 15) | ((relocation >> 12) & 0x7ff);
d798 1
a798 1
  bfd_put_32 (abfd, target, (bfd_byte *) data + addr);
d804 1
a804 1
  /* TODO: We should possibly have DONE entries for the THUMB PCREL relocations */
d808 1
d821 2
a822 1
                                  input_section, output_bfd, error_message, b23);
d826 1
a826 1
coff_thumb_pcrel_12 (abfd, reloc_entry, symbol, data, input_section,
d837 2
a838 1
                                  input_section, output_bfd, error_message, b12);
d840 1
d843 1
a843 1
coff_thumb_pcrel_9 (abfd, reloc_entry, symbol, data, input_section,
d854 2
a855 1
                                  input_section, output_bfd, error_message, b9);
d858 1
a858 1
static CONST struct reloc_howto_struct *
d871 2
a872 1
      default: return (CONST struct reloc_howto_struct *) 0;
d897 1
a897 1
    default: return (CONST struct reloc_howto_struct *) 0;
d909 7
d920 3
a922 3
{
  /* The original coff_link_hash_table structure.  MUST be first field.  */
  struct coff_link_hash_table	root;
d924 2
a925 2
  /* The size in bytes of the section containg the Thumb-to-ARM glue.  */
  long int 			thumb_glue_size;
d927 2
a928 2
  /* The size in bytes of the section containg the ARM-to-Thumb glue.  */
  long int 			arm_glue_size;
d930 2
a931 2
  /* An arbitary input BFD chosen to hold the glue sections.  */
  bfd *				bfd_of_glue_owner;
d933 2
a934 2
  /* Support interworking with old, non-interworking aware ARM code.  */
  int 				support_old_code;
d948 1
d950 1
a950 2
  ret = ((struct coff_arm_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct coff_arm_link_hash_table)));
d957 1
a957 1
      bfd_release (abfd, ret);
d980 3
a982 3
  if (coff_data(output_bfd)->pe)
     addr -= pe_data(output_bfd)->pe_opthdr.ImageBase;
  fwrite (&addr, 1, sizeof (addr), (FILE *) info->base_file);
d986 1
d1013 1
a1013 1
   reverse.  nickc@@cygnus.com  */
d1037 3
a1039 3
    abort (); /* error - not a valid branch instruction form */

  /* FIXME: abort is probably not the right call. krk@@cygnus.com */
d1043 1
d1047 3
a1049 3
     struct bfd_link_info * info;
     CONST char *           name;
     bfd *                  input_bfd;
d1051 3
a1053 2
  char *                        tmp_name;
  struct coff_link_hash_entry * myh;
d1055 1
a1055 2
  tmp_name = ((char *)
	 bfd_malloc (strlen (name) + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1));
d1062 1
a1062 1
    (coff_hash_table (info), tmp_name, false, false, true);
d1067 1
a1067 1
			bfd_get_filename (input_bfd), tmp_name, name);
d1073 1
d1077 3
a1079 3
     struct bfd_link_info * info;
     CONST char *           name;
     bfd *                  input_bfd;
d1081 1
a1081 1
  char *                        tmp_name;
d1083 1
d1085 1
a1085 2
  tmp_name = ((char *)
	      bfd_malloc (strlen (name) + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1));
d1092 1
a1092 1
    (coff_hash_table (info), tmp_name, false, false, true);
d1097 1
a1097 1
			bfd_get_filename (input_bfd), tmp_name, name);
d1191 1
a1191 1
static boolean
d1247 1
a1247 1
	return false;
d1259 2
a1260 1
          && h->root.u.def.section->output_section == input_section->output_section)
d1267 1
a1267 1
    	       true,
d1272 1
a1272 1
    	       false,
d1275 1
a1275 1
    	       false);
d1284 2
d1289 1
d1301 4
a1304 4
	     VXworks target (hence the #ifdef), but it is also known
	     that it was supressed for other (arm) targets.  This ought
	     to be sorted out one day.  */
#ifdef VXWORKS
d1361 1
a1361 1
		      /* Arm code calling a Thumb function */
d1363 1
a1363 1
		      long int                          my_offset;
d1371 1
a1371 1
			return false;
d1395 1
a1395 1
				 bfd_get_filename (h_sec->owner), name);
d1399 1
a1399 1
				 bfd_get_filename (input_bfd));
d1405 1
a1405 1
			  bfd_put_32 (output_bfd, a2t1_ldr_insn,
d1408 1
a1408 1
			  bfd_put_32 (output_bfd, a2t2_bx_r12_insn,
d1417 1
a1417 1
                                                            my_offset + 8);
d1440 2
a1441 2
		      bfd_put_32 (output_bfd, tmp, contents + rel->r_vaddr
				  - input_section->vma);
d1447 1
a1447 1
	      /* Note: We used to check for ARM_THUMB9 and ARM_THUMB12 */
d1456 1
a1456 1
		      long int                           my_offset;
d1464 1
a1464 1
			return false;
d1490 1
a1490 1
				 bfd_get_filename (h_sec->owner), name);
d1494 1
a1494 1
				 bfd_get_filename (input_bfd));
d1504 1
a1504 1
			      bfd_put_16 (output_bfd, t2a1_push_insn,
d1507 1
a1507 1
			      bfd_put_16 (output_bfd, t2a2_ldr_insn,
d1510 1
a1510 1
			      bfd_put_16 (output_bfd, t2a3_mov_insn,
d1513 1
a1513 1
			      bfd_put_16 (output_bfd, t2a4_bx_insn,
d1516 1
a1516 1
			      bfd_put_32 (output_bfd, t2a5_pop_insn,
d1519 1
a1519 1
			      bfd_put_32 (output_bfd, t2a6_bx_insn,
d1527 2
a1528 1
                                arm_emit_base_file_entry (info, output_bfd, s, my_offset + 16);
d1532 1
a1532 1
			      bfd_put_16 (output_bfd, t2a1_bx_pc_insn,
d1535 1
a1535 1
			      bfd_put_16 (output_bfd, t2a2_noop_insn,
d1539 1
a1539 1
				((bfd_signed_vma) h_val)	/* Address of destination of the stub */
d1548 1
a1548 1
					  t2a3_b_insn | ((ret_offset >> 2) & 0x00FFFFFF),
d1569 3
a1571 3
				  insert_thumb_branch (tmp, ret_offset),
				  contents + rel->r_vaddr
				  - input_section->vma);
d1602 2
a1603 2
		      rel->r_vaddr - input_section->vma, true)))
		return false;
d1611 2
a1612 1
            arm_emit_base_file_entry (info, output_bfd, input_section, rel->r_vaddr);
d1637 12
a1648 12
              bfd_vma         relocation       = val + addend;
	      int             size             = bfd_get_reloc_size (howto);
	      boolean         overflow         = false;
	      bfd_byte *      location         = contents + address;
	      bfd_vma         x                = bfd_get_32 (input_bfd, location);
	      bfd_vma         src_mask         = 0x007FFFFE;
	      bfd_signed_vma  reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;
	      bfd_signed_vma  reloc_signed_min = ~reloc_signed_max;
	      bfd_vma         check;
	      bfd_signed_vma  signed_check;
	      bfd_vma         add;
	      bfd_signed_vma  signed_add;
d1705 1
a1705 11
		overflow = true;

	      /* For the BLX(1) instruction remove bit 0 of the adjusted offset.
		 Bit 0 can only be set if the upper insn is at a half-word boundary,
		 since the destination address, an ARM instruction, must always be
		 on a word boundary.  The semantics of the BLX (1) instruction,
		 however, are that bit 0 in the offset must always be 0, and the
		 corresponding bit 1 in the target address will be set from bit
		 1 of the source address.  */
	      if ((x & 0x18000000) == 0x08000000)
		relocation &= ~0x2;
d1707 5
a1711 1
	      /* Put the relocation into the correct bits.  */
d1713 5
a1717 1
		relocation = (((relocation & 0xffe) >> 1)  | ((relocation << 4) & 0x07ff0000));
d1719 5
a1723 1
		relocation = (((relocation & 0xffe) << 15) | ((relocation >> 12) & 0x7ff));
d1752 1
a1752 1
	  int patchit = false;
d1758 1
a1758 1
	      patchit = true;
d1767 1
a1767 1
		patchit = true;
d1789 1
a1789 1
	     bfd_get_filename (input_bfd),
d1792 1
a1792 1
	  return false;
d1806 1
a1806 1
		  return false;
d1812 1
a1812 1
	      return false;
d1817 1
a1817 1
  return true;
d1822 1
a1822 1
boolean
d1846 2
a1847 2
      foo = (bfd_byte *) bfd_alloc
	(globals->bfd_of_glue_owner, globals->arm_glue_size);
d1849 1
a1849 1
      memset (foo, test_char, globals->arm_glue_size);
d1865 2
a1866 2
      foo = (bfd_byte *) bfd_alloc
	(globals->bfd_of_glue_owner, globals->thumb_glue_size);
d1868 1
a1868 1
      memset (foo, test_char, globals->thumb_glue_size);
d1875 1
a1875 1
  return true;
d1887 1
d1889 2
d1902 2
a1903 2
  tmp_name = ((char *)
	      bfd_malloc (strlen (name) + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1));
d1910 1
a1910 1
    (coff_hash_table (info), tmp_name, false, false, true);
d1922 2
d1925 1
a1925 4
				BSF_GLOBAL,
				s, globals->arm_glue_size + 1,
				NULL, true, false,
				(struct bfd_link_hash_entry **) & myh);
d1934 1
d1944 1
d1946 2
d1959 2
a1960 1
  tmp_name = (char *) bfd_malloc (strlen (name) + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);
d1967 1
a1967 1
    (coff_hash_table (info), tmp_name, false, false, true);
d1975 2
d1978 1
a1978 3
				BSF_GLOBAL, s, globals->thumb_glue_size + 1,
				NULL, true, false,
				(struct bfd_link_hash_entry **) & myh);
d1981 1
d1991 2
a1992 1
  tmp_name = (char *) bfd_malloc (strlen (name) + strlen (CHANGE_TO_ARM) + 1);
d1998 2
a1999 2
  myh = NULL;

d2001 1
a2001 4
				BSF_LOCAL, s, globals->thumb_glue_size
				+ (globals->support_old_code ? 8 : 4),
				NULL, true, false,
				(struct bfd_link_hash_entry **) & myh);
d2009 1
d2015 1
a2015 1
boolean
d2027 1
a2027 1
    return true;
d2034 1
a2034 1
    return true;
d2047 1
a2047 1
	return false;
d2061 1
a2061 1
	return false;
d2067 1
a2067 1
  return true;
d2070 1
a2070 1
boolean
d2082 1
a2082 1
    return true;
d2100 1
a2100 1
    return true;
d2133 1
a2133 1
				  bfd_get_filename (abfd), symndx);
d2184 1
a2184 1
  return true;
d2204 1
a2204 1
static boolean
d2211 1
a2211 1
     boolean *adjustedp;
d2224 2
a2225 2
  *adjustedp = false;
  return true;
d2233 1
a2233 1
static boolean
d2241 1
a2241 1
    return true;
d2248 6
a2253 1
    return true;
d2255 1
a2255 1
  /* Verify that the APCS is the same for the two BFDs */
d2265 2
a2266 2
		(_("%s: ERROR: compiled for APCS-%d whereas target %s uses APCS-%d"),
		 bfd_get_filename (ibfd), APCS_26_FLAG (ibfd) ? 26 : 32,
d2271 1
a2271 1
	      return false;
d2280 1
a2280 1
		msg = _("%s: ERROR: passes floats in float registers whereas target %s uses integer registers");
d2283 1
a2283 1
		msg = _("%s: ERROR: passes floats in integer registers whereas target %s uses float registers");
d2285 1
a2285 1
	      _bfd_error_handler (msg, bfd_get_filename (ibfd),
d2289 1
a2289 1
	      return false;
d2298 1
a2298 1
		msg = _("%s: ERROR: compiled as position independent code, whereas target %s is absolute position");
d2301 2
a2302 2
		msg = _("%s: ERROR: compiled as absolute position code, whereas target %s is position independent");
	      _bfd_error_handler (msg, bfd_get_filename (ibfd),
d2306 1
a2306 1
	      return false;
d2330 1
a2330 1
		msg = _("Warning: input file %s supports interworking, whereas %s does not.");
d2333 1
a2333 1
		msg = _("Warning: input file %s does not support interworking, whereas %s does.");
d2335 1
a2335 1
	      _bfd_error_handler (msg, bfd_get_filename (ibfd),
d2345 1
a2345 1
  return true;
d2350 1
a2350 1
static boolean
d2387 1
a2387 1
  return true;
d2397 1
a2397 1
static boolean
d2415 1
a2415 1
    return false;
d2431 2
a2432 2
	_bfd_error_handler (_("Warning: Not setting interworking flag of %s, since it has already been specified as non-interworking"),
			    bfd_get_filename (abfd));
d2436 1
a2436 1
			    bfd_get_filename (abfd));
d2442 1
a2442 1
  return true;
d2448 1
a2448 1
static boolean
d2456 1
a2456 1
    return true;
d2461 1
a2461 1
    return true;
d2470 1
a2470 1
	    return false;
d2473 1
a2473 1
	    return false;
d2476 1
a2476 1
	    return false;
d2494 2
a2495 1
		  _bfd_error_handler (("Warning: Clearing the interworking bit of %s, because the non-interworking code in %s has been copied into it"),
d2497 1
a2497 1
				      bfd_get_filename (src));
d2509 1
a2509 1
  return true;
d2524 1
a2524 1
static boolean
d2533 1
a2533 1
	return false;
d2543 1
a2543 1
      int len = strlen (LOCAL_LABEL_PREFIX);
d2546 1
a2546 1
	return false;
d2564 1
a2564 1
static boolean
d2573 1
a2573 1
static boolean
d2587 1
a2587 1
	return false;
d2589 1
a2589 1
      globals->bfd_of_glue_owner->output_has_begun = true;
d2592 1
a2592 1
  return true;
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d55 1
a55 1
     
a60 1

d80 1
a80 1
static reloc_howto_type * coff_arm_rtype_to_howto 
d122 1
a122 1
   
d129 1
a129 1
/* Used by the assembler. */
d235 1
a235 1
static reloc_howto_type aoutarm_std_reloc_howto[] = 
d240 1
a240 1
  HOWTO (ARM_32, 
d242 1
a242 1
	2, 
d253 1
a253 1
  HOWTO (ARM_RVA32, 
d255 1
a255 1
	2, 
d277 1
a277 1
	0x00ffffff, 
d290 1
a290 1
	0x000007ff, 
d292 2
a293 2
  HOWTO (ARM_26D,  
	2, 
d299 1
a299 1
	aoutarm_fix_pcrel_26_done, 
d313 4
a316 4
  HOWTO (ARM_SECTION,  
	0, 
	1, 
	16, 
d321 1
a321 1
	"ARM_16", 
d324 1
a324 1
	0x0000ffff, 
d326 1
a326 1
  HOWTO (ARM_SECREL, 
d328 1
a328 1
	2, 
d353 4
a356 4
  HOWTO(ARM_16,  
	0, 
	1, 
	16, 
d361 1
a361 1
	"ARM_16", 
d364 1
a364 1
	0x0000ffff, 
d366 1
a366 1
  HOWTO(ARM_32, 
d368 1
a368 1
	2, 
d390 1
a390 1
	0x00ffffff, 
d392 1
a392 1
  HOWTO(ARM_DISP8,        
d395 1
a395 1
	8, 
d398 1
a398 1
	complain_overflow_signed, 
d400 1
a400 1
	"ARM_DISP8",  
d405 1
a405 1
  HOWTO( ARM_DISP16, 
d411 1
a411 1
	complain_overflow_signed, 
d424 1
a424 1
	complain_overflow_signed, 
d431 2
a432 2
  HOWTO( ARM_26D,  
	2, 
d438 1
a438 1
	aoutarm_fix_pcrel_26_done, 
d451 1
a451 1
	0, 
d455 2
a456 1
        true, 
a457 1
	0x0000ffff, 
d459 2
a460 2
  HOWTO( ARM_NEG32, 
	0, 
d472 1
a472 1
  HOWTO( ARM_RVA32, 
d474 1
a474 1
	2, 
d496 1
a496 1
	0x000000ff, 
d509 1
a509 1
	0x000007ff, 
d522 1
a522 1
	0x07ff07ff, 
d531 1
a531 1
   appear in the output .reloc section. */
d539 1
a539 1
}     
d563 1
a563 1
  
d571 1
a571 1
/* Used by the assembler. */
d588 1
a588 1
/* Used by the assembler. */
d605 1
a605 1
  
d626 1
a626 1
  
d696 1
a696 1
  
d771 1
a771 1
  
a820 1

d827 1
a827 1
  
d849 1
d857 2
a858 1
#endif      
d878 1
a878 1
  
d881 1
a881 1
  
d888 1
a888 1
  /* Support interworking with old, non-interworking aware ARM code. */
d943 1
a943 1
   can occur in any order. So given a thumb form of long branch, and an 
d945 1
a945 1
   instruction. 
d947 1
a947 1
   It takes two thumb instructions to encode the target address. Each has 
d949 2
a950 2
   H-0.. see below), the lower 11 bits are stored in the other (identified 
   by H-1). 
d952 1
a952 1
   Combine together and shifted left by 1 (it's a half word address) and 
d960 1
a960 1
   They can be ordered either way, but the arm tools I've seen always put 
a979 1

d991 1
a991 1
    abort(); /* error - not a valid branch instruction form */
a996 1

d1013 1
a1013 1
  
d1016 1
a1016 1
  
d1021 1
a1021 1
  
d1042 1
a1042 1
  
d1050 1
a1050 1
  
d1087 1
a1087 1
					        .word	func 
d1130 1
a1130 1
/* The standard COFF backend linker does not cope with the special 
d1133 1
a1133 1
   bit simpler simply providing our own relocation driver. */
d1181 1
a1181 1
	{    
a1195 1

d1213 1
a1213 1
          static reloc_howto_type fake_arm26_reloc = 
d1225 1
a1225 1
    	       0x00ffffff, 
d1234 1
a1234 1
	 the next opcode's pc, so is off by one. */
d1238 1
a1238 1
      
d1247 12
d1261 1
d1291 1
a1291 1
	     for an undefined name... */
d1298 1
a1298 1
	      
d1314 1
a1314 1
		      struct coff_link_hash_entry *     myh; 
d1316 1
a1316 1
		      
d1325 1
a1325 1
			
d1327 2
a1328 2
		      
		      s = bfd_get_section_by_name (globals->bfd_of_glue_owner, 
d1355 1
a1355 1
			  
d1358 1
a1358 1
			  
d1364 1
a1364 1
                            arm_emit_base_file_entry (info, output_bfd, s, 
d1373 1
a1373 1
		      
d1376 1
a1376 1
		      /* Somehow these are both 4 too far, so subtract 8. */
d1379 1
a1379 1
			+ my_offset 
d1382 1
a1382 1
			   + input_section->output_section->vma 
d1387 1
a1387 1
		      
d1393 1
a1393 1
	      
d1398 1
a1398 1
                  if (   h->class == C_EXT 
d1415 1
a1415 1
		      
d1418 1
a1418 1
		      
d1420 2
a1421 2
		      
		      s = bfd_get_section_by_name (globals->bfd_of_glue_owner, 
d1423 1
a1423 1
		      
d1427 1
a1427 1
		      
d1446 1
a1446 1
			  
d1454 1
a1454 1
			      
d1463 1
a1463 1
			      
d1466 1
a1466 1
			      
d1469 1
a1469 1
			      
d1481 1
a1481 1
		      
d1484 1
a1484 1
		      
d1493 1
a1493 1
			      
d1511 1
a1511 1
		      
d1519 1
a1519 1
		      
d1525 1
a1525 1
	  
d1528 1
a1528 1
             perform a direct link. */
d1532 1
a1532 1
	  else 
d1556 1
a1556 1
	  /* Emit a reloc if the backend thinks it needs it. */
d1560 1
a1560 1
  
d1576 1
a1576 1
	  
d1578 1
a1578 1
	  
d1597 2
a1598 2
	      
              /* howto->pc_relative should be TRUE for type 14 BRANCH23 */
d1601 2
a1602 2
	      
              /* howto->pcrel_offset should be TRUE for type 14 BRANCH23 */
d1604 2
a1605 2
	      
	      /* No need to negate the relocation with BRANCH23. */
d1608 1
a1609 1
	      
d1611 1
a1611 1
		
d1620 1
a1620 1
	      
d1623 1
a1623 3
		{
		  add = (((x) & 0x07ff0000) >> 4) | (((x) & 0x7ff) << 1);
		}
d1625 1
a1625 3
		{
		  add = ((((x) & 0x7ff) << 12) | (((x) & 0x07ff0000) >> 15));
		}
a1634 1
	      
d1636 1
a1636 1
	      
d1639 2
a1640 1
	      
a1642 2
	      /* howto->bitpos == 0 */
	      
d1644 1
a1644 1
	      relocation += signed_add;
d1652 12
a1663 3
	      
	      /* Put RELOCATION into the correct bits:  */
	      
d1665 1
a1665 3
		{
		  relocation = (((relocation & 0xffe) >> 1)  | ((relocation << 4) & 0x07ff0000));
		}
d1667 3
a1669 5
		{
		  relocation = (((relocation & 0xffe) << 15) | ((relocation >> 12) & 0x7ff));
		}
	      
	      /* Add RELOCATION to the correct bits of X:  */
d1672 1
a1672 1
	      /* Put the relocated value back in the object file:  */
d1686 1
a1686 1
      /* FIXME: 
d1695 1
a1695 1
	     
d1697 1
a1697 1
	  
d1722 2
a1723 2
#endif /* THUMBEXTENSION */      
      
d1767 1
a1767 1
bfd_arm_allocate_interworking_sections (info) 
d1778 1
a1778 1
  
d1784 1
a1784 1
      
d1789 1
a1789 1
      
d1795 1
a1795 1
      
d1803 1
a1803 1
      
d1808 1
a1808 1
      
d1814 1
a1814 1
      
d1849 1
a1849 1
  
d1852 1
a1852 1
  
d1864 1
a1864 1
				BSF_GLOBAL, 
d1866 1
a1866 1
				NULL, true, false, 
d1868 1
a1868 1
  
d1870 1
a1870 1
  
a1886 1
  
d1888 1
a1888 1
  
d1905 1
a1905 1
  
d1914 1
a1914 1
				NULL, true, false, 
d1916 1
a1916 1
  
d1923 1
a1923 1
      
d1926 1
a1926 1
  
d1928 1
a1928 1
  
d1930 1
a1930 1
  
d1934 1
a1934 1
  
d1938 1
a1938 1
				NULL, true, false, 
d1941 2
a1942 2
  free (tmp_name);  
  
d1960 1
a1960 1
    
d1965 1
a1965 1
  
d1967 1
a1967 1
  
d1972 1
a1972 1
  
d1974 2
a1975 2
  
  if (sec == NULL) 
d1978 1
a1978 1
      
d1980 1
a1980 1
      
d1989 1
a1989 1
  if (sec == NULL) 
d1992 1
a1992 1
      
d1994 1
a1994 1
      
d2000 1
a2000 1
  
d2003 1
a2003 1
  
d2020 1
a2020 1
  
d2027 1
a2027 1
  
d2032 1
a2032 1
  
d2044 1
a2044 1
      if (sec->reloc_count == 0) 
d2048 2
a2049 2
      /* FIXME: there may be a storage leak here. */
      
d2051 1
a2051 1
    
d2054 1
a2054 1
      for (rel = i; rel < i + sec->reloc_count; ++rel) 
d2062 1
a2062 1
	  /* If the relocation is not against a symbol it cannot concern us. */
d2073 1
a2073 1
	  
d2087 1
a2087 1
	      
d2091 1
a2091 1
	      
d2114 1
a2114 1
	      
a2137 1

d2205 1
a2205 1
	  
d2216 1
a2216 1
	      
d2223 1
a2223 1
	  
d2244 1
a2244 1
	  
d2266 1
a2266 1
	      
a2279 1

d2288 1
a2288 1
  
d2290 1
a2290 1
  
d2293 1
a2293 1
  
d2309 1
a2309 1
  
d2316 1
a2316 1
  
d2318 1
a2318 1
  
a2321 1

d2339 1
a2339 1
  
d2350 1
a2350 1
  
d2354 1
a2354 1
  
a2376 1

d2386 1
a2386 1
 
d2403 1
a2403 1
	  
d2406 1
a2406 1
	  
d2430 1
a2430 1
	      
d2444 2
a2445 2
 *must* match the definitions in gcc/config/arm/coff.h and semi.h */
#define LOCAL_LABEL_PREFIX "."
d2470 2
a2471 2
     If the prefix exists, but it is empty, then ignore the test. */
  
d2475 1
a2475 1
      
d2478 1
a2478 1
      
d2483 1
a2483 1
  
d2488 1
a2488 1
   the glue section is written last. 
d2491 1
a2491 1
   end of the section list for the bfd. 
d2512 1
a2512 1
  
d2514 1
a2514 1
  
d2519 1
a2519 1
      
d2522 1
a2522 1
  
d2545 1
d2551 1
a2558 1

@


1.3
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
a24 1
#include "obstack.h"
d36 14
a49 3
static bfd_reloc_status_type
aoutarm_fix_pcrel_26_done PARAMS ((bfd *, arelent *, asymbol *, PTR,
				  asection *, bfd *, char **));
d51 8
a58 3
static bfd_reloc_status_type
aoutarm_fix_pcrel_26 PARAMS ((bfd *, arelent *, asymbol *, PTR,
			     asection *, bfd *, char **));
d61 15
a75 1
static bfd_reloc_status_type coff_arm_reloc 
d78 50
a127 2
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *,
	   struct internal_reloc *, boolean *));
d135 1
a135 1
     asymbol *symbol;
d137 1
a137 1
     asection *input_section;
d139 1
a139 1
     char **error_message;
d190 7
d201 34
d238 104
a341 2
  HOWTO(0,			/* type */
	0,			/* rs */
d343 2
a344 2
	8,			/* bsz */
	false,			/* pcrel */
d346 8
a353 8
	complain_overflow_bitfield, /* ovf */
	coff_arm_reloc,		/* sf */
	"8",			/*name */
        true,			/* partial */
	0x000000ff,		/*read mask */
	0x000000ff,		/* setmask */
	PCRELOFFSET		/* pcdone */),
  HOWTO(1,  
d361 1
a361 1
	"16", 
d366 1
a366 1
  HOWTO( 2, 
d374 1
a374 1
	"32",
d379 1
a379 1
  HOWTO( 3,
d382 1
a382 1
	26,
d387 1
a387 1
	"ARM26",
d392 1
a392 1
  HOWTO( 4,        
d400 1
a400 1
	"DISP8",  
d405 1
a405 1
  HOWTO( 5, 
d413 1
a413 1
	"DISP16",
d418 1
a418 1
  HOWTO( 6,
d426 1
a426 1
	"DISP32",
d431 1
a431 1
  HOWTO( 7,  
d434 1
a434 1
	26,
d437 1
a437 1
	complain_overflow_signed,
d439 1
a439 1
	"ARM26D",
d444 3
a446 2
  {-1},
  HOWTO( 9,
d454 1
a454 1
	"NEG16",
d459 1
a459 1
  HOWTO( 10, 
d467 1
a467 1
	"NEG32",
d472 1
a472 1
  HOWTO( 11, 
d480 1
a480 1
	"rva32",
d485 40
d526 3
d533 4
a536 3
static boolean in_reloc_p (abfd, howto)
     bfd * abfd;
     reloc_howto_type *howto;
d538 1
a538 1
  return !howto->pc_relative && howto->type != 11;
d542 5
a546 3

#define RTYPE2HOWTO(cache_ptr, dst) \
	    (cache_ptr)->howto = aoutarm_std_reloc_howto + (dst)->r_type;
d552 1
a552 1
     bfd *abfd;
d555 2
a556 2
     struct coff_link_hash_entry *h;
     struct internal_syment *sym;
d559 1
a559 1
  reloc_howto_type *howto;
d561 3
d566 3
a568 4
  if (rel->r_type == 11)
    {
      *addendp -= pe_data(sec->output_section->owner)->pe_opthdr.ImageBase;
    }
a569 1

d576 7
a582 7
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d599 1
a599 1
     char **error_message;
d626 1
d633 1
a633 1
      if ((relocation & ~0x03ffffff) != ~0x03ffffff)
d645 62
a706 1
  reloc_entry->howto = &aoutarm_std_reloc_howto[7];
d708 65
d776 45
d823 2
a824 2
arm_reloc_type_lookup(abfd,code)
      bfd *abfd;
d827 2
a828 1
#define ASTD(i,j)       case i: return &aoutarm_std_reloc_howto[j]
d840 18
a857 7
      ASTD (BFD_RELOC_16, 1);
      ASTD (BFD_RELOC_32, 2);
      ASTD (BFD_RELOC_ARM_PCREL_BRANCH, 3);
      ASTD (BFD_RELOC_8_PCREL, 4);
      ASTD (BFD_RELOC_16_PCREL, 5);
      ASTD (BFD_RELOC_32_PCREL, 6);
      ASTD (BFD_RELOC_RVA, 11);
a861 3

#define coff_bfd_reloc_type_lookup arm_reloc_type_lookup

d870 20
d891 3
a893 2
/* We use the special COFF backend linker.  */
#define coff_relocate_section _bfd_coff_generic_relocate_section
d895 1
a895 2
/* When doing a relocateable link, we want to convert ARM26 relocs
   into ARM26D relocs.  */
d897 3
a899 8
static boolean
coff_arm_adjust_symndx (obfd, info, ibfd, sec, irel, adjustedp)
     bfd *obfd;
     struct bfd_link_info *info;
     bfd *ibfd;
     asection *sec;
     struct internal_reloc *irel;
     boolean *adjustedp;
d901 13
a913 5
  if (irel->r_type == 3)
    irel->r_type = 7;
  *adjustedp = false;
  return true;
}
d915 3
a917 1
#define coff_adjust_symndx coff_arm_adjust_symndx
d919 2
a920 1
#include "coffcode.h"
d922 6
a927 6
const bfd_target
#ifdef TARGET_LITTLE_SYM
TARGET_LITTLE_SYM =
#else
armcoff_little_vec =
#endif
d929 8
a936 12
#ifdef TARGET_LITTLE_NAME
  TARGET_LITTLE_NAME,
#else
  "coff-arm-little",
#endif
  bfd_target_coff_flavour,
  BFD_ENDIAN_LITTLE,		/* data byte order is little */
  BFD_ENDIAN_LITTLE,		/* header byte order is little */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
d938 865
a1802 5
#ifndef COFF_WITH_PE
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
#else
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC /* section flags */
   | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),
d1804 267
d2072 32
a2103 4
#ifdef TARGET_UNDERSCORE
  TARGET_UNDERSCORE,		/* leading underscore */
#else
  0,				/* leading underscore */
d2105 304
a2408 2
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen */
d2410 27
a2436 24
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */

/* Note that we allow an object file to be treated as a core file as well. */
    {_bfd_dummy_target, coff_object_p, /* bfd_check_format */
       bfd_generic_archive_p, coff_object_p},
    {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format */
       bfd_false},
    {bfd_false, coff_write_object_contents, /* bfd_write_contents */
       _bfd_write_archive_contents, bfd_false},

     BFD_JUMP_TABLE_GENERIC (coff),
     BFD_JUMP_TABLE_COPY (coff),
     BFD_JUMP_TABLE_CORE (_bfd_nocore),
     BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
     BFD_JUMP_TABLE_SYMBOLS (coff),
     BFD_JUMP_TABLE_RELOCS (coff),
     BFD_JUMP_TABLE_WRITE (coff),
     BFD_JUMP_TABLE_LINK (coff),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
d2438 24
a2461 2
  COFF_SWAP_TABLE,
};
d2463 14
a2476 5
const bfd_target
#ifdef TARGET_BIG_SYM
TARGET_BIG_SYM =
#else
armcoff_big_vec =
d2478 25
d2504 30
a2533 4
#ifdef TARGET_BIG_NAME
  TARGET_BIG_NAME,
#else
  "coff-arm-big",
a2534 7
  bfd_target_coff_flavour,
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
d2536 2
a2537 5
#ifndef COFF_WITH_PE
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
#else
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC /* section flags */
   | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),
d2540 2
a2541 2
#ifdef TARGET_UNDERSCORE
  TARGET_UNDERSCORE,		/* leading underscore */
d2543 1
a2543 1
  0,				/* leading underscore */
a2544 2
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen */
d2546 6
a2551 24
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */

/* Note that we allow an object file to be treated as a core file as well. */
    {_bfd_dummy_target, coff_object_p, /* bfd_check_format */
       bfd_generic_archive_p, coff_object_p},
    {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format */
       bfd_false},
    {bfd_false, coff_write_object_contents, /* bfd_write_contents */
       _bfd_write_archive_contents, bfd_false},

     BFD_JUMP_TABLE_GENERIC (coff),
     BFD_JUMP_TABLE_COPY (coff),
     BFD_JUMP_TABLE_CORE (_bfd_nocore),
     BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
     BFD_JUMP_TABLE_SYMBOLS (coff),
     BFD_JUMP_TABLE_RELOCS (coff),
     BFD_JUMP_TABLE_WRITE (coff),
     BFD_JUMP_TABLE_LINK (coff),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
a2552 2
  COFF_SWAP_TABLE,
};
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d47 3
a49 1

d221 1
a221 1
	0x00ffffff, 
d424 19
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* BFD back-end for Intel arm COFF files.
d438 2
a439 2
  false,			/* data byte order is little */
  false,			/* header byte order is little */
d445 1
d447 5
d501 2
a502 2
  true,				/* data byte order is big */
  true,				/* header byte order is big */
d508 1
d510 5
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d1 1
a1 1
/* BFD back-end for ARM COFF files.
d438 2
a439 2
  BFD_ENDIAN_LITTLE,		/* data byte order is little */
  BFD_ENDIAN_LITTLE,		/* header byte order is little */
a444 1
#ifndef COFF_WITH_PE
a445 5
#else
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC /* section flags */
   | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),
#endif

d495 2
a496 2
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */
a501 1
#ifndef COFF_WITH_PE
a502 5
#else
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC /* section flags */
   | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),
#endif

@


1.1.1.3
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d47 1
a47 3
static boolean coff_arm_adjust_symndx
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *,
	   struct internal_reloc *, boolean *));
d219 1
a219 1
	0x0,
a421 19
/* When doing a relocateable link, we want to convert ARM26 relocs
   into ARM26D relocs.  */

static boolean
coff_arm_adjust_symndx (obfd, info, ibfd, sec, irel, adjustedp)
     bfd *obfd;
     struct bfd_link_info *info;
     bfd *ibfd;
     asection *sec;
     struct internal_reloc *irel;
     boolean *adjustedp;
{
  if (irel->r_type == 3)
    irel->r_type = 7;
  *adjustedp = false;
  return true;
}

#define coff_adjust_symndx coff_arm_adjust_symndx
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d24 1
a298 31

  /* The relocation_section function will skip pcrel_offset relocs
     when doing a relocateable link.  However, we want to convert
     ARM26 to ARM26D relocs if possible.  We return a fake howto in
     this case without pcrel_offset set, and adjust the addend to
     compensate.  */
  if (rel->r_type == 3
      && h != NULL
      && (h->root.type == bfd_link_hash_defined
	  || h->root.type == bfd_link_hash_defweak)
      && h->root.u.def.section->output_section == sec->output_section)
    {
      static reloc_howto_type fake_arm26_reloc = 
	HOWTO (3,
	       2,
	       2,
	       26,
	       true,
	       0,
	       complain_overflow_signed,
	       aoutarm_fix_pcrel_26 ,
	       "ARM26",
	       false,
	       0x00ffffff,
	       0x00ffffff, 
	       false);

      *addendp -= rel->r_vaddr - sec->vma;
      return &fake_arm26_reloc;
    }

d437 1
a437 10
    {
      struct coff_link_hash_entry *h;

      h = obj_coff_sym_hashes (ibfd)[irel->r_symndx];
      if (h != NULL
	  && (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	  && h->root.u.def.section->output_section == sec->output_section)
	irel->r_type = 7;
    }
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
d35 3
a37 14
/* Macros for manipulation the bits in the flags field of the coff data
   structure.  */
#define APCS_26_FLAG(       abfd )	(coff_data (abfd)->flags & F_APCS_26)
#define APCS_FLOAT_FLAG(    abfd )	(coff_data (abfd)->flags & F_APCS_FLOAT)
#define PIC_FLAG(           abfd )	(coff_data (abfd)->flags & F_PIC)
#define APCS_SET(           abfd )	(coff_data (abfd)->flags & F_APCS_SET)
#define SET_APCS_FLAGS(     abfd, flgs)	(coff_data (abfd)->flags = \
					(coff_data (abfd)->flags & ~ (F_APCS_26 | F_APCS_FLOAT | F_PIC)) \
					 | (flgs | F_APCS_SET))
#define INTERWORK_FLAG(     abfd ) 	(coff_data (abfd)->flags & F_INTERWORK)
#define INTERWORK_SET(      abfd ) 	(coff_data (abfd)->flags & F_INTERWORK_SET)
#define SET_INTERWORK_FLAG( abfd, flg )	(coff_data (abfd)->flags = \
					(coff_data (abfd)->flags & ~ F_INTERWORK) \
					 | (flg | F_INTERWORK_SET))
d39 3
a41 8
#ifndef NUM_ELEM
#define NUM_ELEM(a) ((sizeof (a)) / sizeof ((a)[0]))
#endif
     
typedef enum {bunknown, b9, b12, b23} thumb_pcrel_branchtype;
/* some typedefs for holding instructions */
typedef unsigned long int insn32;
typedef unsigned short int insn16;
d44 1
a44 15
     /* Forward declarations for stupid compilers.  */
static boolean coff_arm_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
           struct internal_reloc *, struct internal_syment *, asection **));
static bfd_reloc_status_type aoutarm_fix_pcrel_26_done
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type aoutarm_fix_pcrel_26
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type coff_thumb_pcrel_23
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type coff_thumb_pcrel_12
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type coff_thumb_pcrel_9
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type coff_arm_reloc
d47 2
a48 50
  PARAMS ((bfd *, struct bfd_link_info *, bfd *,
	   asection *, struct internal_reloc *,	boolean *));
static reloc_howto_type * coff_arm_rtype_to_howto 
  PARAMS ((bfd *, asection *, struct internal_reloc *,
	   struct coff_link_hash_entry *, struct internal_syment *, bfd_vma *));
static bfd_reloc_status_type coff_thumb_pcrel_common
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **,
	   thumb_pcrel_branchtype));
static CONST struct reloc_howto_struct * coff_arm_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static struct bfd_link_hash_table * coff_arm_link_hash_table_create
  PARAMS ((bfd *));
static insn32 insert_thumb_branch
  PARAMS ((insn32, int));
static struct coff_link_hash_entry * find_thumb_glue
  PARAMS ((struct bfd_link_info *, CONST char *, bfd *));
static struct coff_link_hash_entry * find_arm_glue
  PARAMS ((struct bfd_link_info *, CONST char *, bfd *));
#ifndef COFF_IMAGE_WITH_PE
static void record_arm_to_thumb_glue
  PARAMS ((struct bfd_link_info *, struct coff_link_hash_entry *));
static void record_thumb_to_arm_glue
  PARAMS ((struct bfd_link_info *, struct coff_link_hash_entry *));
#endif
static boolean coff_arm_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));
static boolean coff_arm_print_private_bfd_data
  PARAMS ((bfd *, PTR));
static boolean _bfd_coff_arm_set_private_flags
  PARAMS ((bfd *, flagword));
static boolean coff_arm_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
static boolean coff_arm_is_local_label_name
  PARAMS ((bfd *, const char *));
static boolean coff_arm_link_output_has_begun
  PARAMS ((bfd *, struct coff_final_link_info *));
static boolean coff_arm_final_link_postscript
  PARAMS ((bfd *, struct coff_final_link_info *));

/* The linker script knows the section names for placement.
   The entry_names are used to do simple name mangling on the stubs.
   Given a function name, and its type, the stub can be found. The
   name can be changed. The only requirement is the %s be present.
   */
   
#define THUMB2ARM_GLUE_SECTION_NAME ".glue_7t"
#define THUMB2ARM_GLUE_ENTRY_NAME   "__%s_from_thumb"

#define ARM2THUMB_GLUE_SECTION_NAME ".glue_7"
#define ARM2THUMB_GLUE_ENTRY_NAME   "__%s_from_arm"
d56 1
a56 1
     asymbol *symbol ATTRIBUTE_UNUSED;
d58 1
a58 1
     asection *input_section ATTRIBUTE_UNUSED;
d60 1
a60 1
     char **error_message ATTRIBUTE_UNUSED;
a110 7
/* If USER_LABEL_PREFIX is defined as "_" (see coff_arm_is_local_label_name()
   in this file), then TARGET_UNDERSCORE should be defined, otherwise it
   should not.  */
#ifndef TARGET_UNDERSCORE
#define TARGET_UNDERSCORE '_'
#endif

a114 34
/* These most certainly belong somewhere else. Just had to get rid of
   the manifest constants in the code.  */
#define ARM_8        0
#define ARM_16       1
#define ARM_32       2
#define ARM_26       3
#define ARM_DISP8    4
#define ARM_DISP16   5
#define ARM_DISP32   6
#define ARM_26D      7
/* 8 is unused */
#define ARM_NEG16    9
#define ARM_NEG32   10
#define ARM_RVA32   11
#define ARM_THUMB9  12
#define ARM_THUMB12 13
#define ARM_THUMB23 14

#ifdef ARM_WINCE
#undef  ARM_32
#undef  ARM_RVA32
#undef  ARM_26
#undef  ARM_THUMB12
#undef  ARM_26D

#define ARM_32       1
#define ARM_RVA32    2
#define ARM_26	     3
#define ARM_THUMB12  4
#define ARM_26D      5
#define ARM_SECTION  14
#define ARM_SECREL   15
#endif

d118 2
a119 104
#ifdef ARM_WINCE
  EMPTY_HOWTO (-1),
  HOWTO (ARM_32, 
	0,
	2, 
	32,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_32",
        true,
	0xffffffff,
	0xffffffff,
	PCRELOFFSET),
  HOWTO (ARM_RVA32, 
	0,
	2, 
	32,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_RVA32",
        true,
	0xffffffff,
	0xffffffff,
	PCRELOFFSET),
  HOWTO (ARM_26,
	2,
	2,
	24,
	true,
	0,
	complain_overflow_signed,
	aoutarm_fix_pcrel_26 ,
	"ARM_26",
	false,
	0x00ffffff,
	0x00ffffff, 
	PCRELOFFSET),
  HOWTO (ARM_THUMB12,
	1,
	1,
	11,
	true,
	0,
	complain_overflow_signed,
	coff_thumb_pcrel_12 ,
	"ARM_THUMB12",
	false,
	0x000007ff,
	0x000007ff, 
	PCRELOFFSET),
  HOWTO (ARM_26D,  
	2, 
	2,
	24,
	false,
	0,
	complain_overflow_dont,
	aoutarm_fix_pcrel_26_done, 
	"ARM_26D",
	true,
	0x00ffffff,
	0x0,
	false),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  HOWTO (ARM_SECTION,  
	0, 
	1, 
	16, 
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_16", 
	true,
	0x0000ffff,
	0x0000ffff, 
	PCRELOFFSET),
  HOWTO (ARM_SECREL, 
	0,
	2, 
	32,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_32",
        true,
	0xffffffff,
	0xffffffff,
	PCRELOFFSET),
#else /* not ARM_WINCE */
  HOWTO(ARM_8,			/* type */
	0,			/* rightshift */
d121 2
a122 2
	8,			/* bitsize */
	false,			/* pc_relative */
d124 8
a131 8
	complain_overflow_bitfield, /* complain_on_overflow */
	coff_arm_reloc,		/* special_function */
	"ARM_8",		/* name */
        true,			/* partial_inplace */
	0x000000ff,		/* src_mask */
	0x000000ff,		/* dst_mask */
	PCRELOFFSET		/* pcrel_offset */),
  HOWTO(ARM_16,  
d139 1
a139 1
	"ARM_16", 
d144 1
a144 1
  HOWTO(ARM_32, 
d152 1
a152 1
	"ARM_32",
d157 1
a157 1
  HOWTO(ARM_26,
d160 1
a160 1
	24,
d165 1
a165 1
	"ARM_26",
d170 1
a170 1
  HOWTO(ARM_DISP8,        
d178 1
a178 1
	"ARM_DISP8",  
d183 1
a183 1
  HOWTO( ARM_DISP16, 
d191 1
a191 1
	"ARM_DISP16",
d196 1
a196 1
  HOWTO( ARM_DISP32,
d204 1
a204 1
	"ARM_DISP32",
d209 1
a209 1
  HOWTO( ARM_26D,  
d212 1
a212 1
	24,
d215 1
a215 1
	complain_overflow_dont,
d217 1
a217 1
	"ARM_26D",
d222 2
a223 3
  /* 8 is unused */
  EMPTY_HOWTO (-1),
  HOWTO( ARM_NEG16,
d231 1
a231 1
	"ARM_NEG16",
d236 1
a236 1
  HOWTO( ARM_NEG32, 
d244 1
a244 1
	"ARM_NEG32",
d249 1
a249 1
  HOWTO( ARM_RVA32, 
d257 1
a257 1
	"ARM_RVA32",
a261 40
  HOWTO( ARM_THUMB9,
	1,
	1,
	8,
	true,
	0,
	complain_overflow_signed,
	coff_thumb_pcrel_9 ,
	"ARM_THUMB9",
	false,
	0x000000ff,
	0x000000ff, 
	PCRELOFFSET),
  HOWTO( ARM_THUMB12,
	1,
	1,
	11,
	true,
	0,
	complain_overflow_signed,
	coff_thumb_pcrel_12 ,
	"ARM_THUMB12",
	false,
	0x000007ff,
	0x000007ff, 
	PCRELOFFSET),
  HOWTO( ARM_THUMB23,
	1,
	2,
	22,
	true,
	0,
	complain_overflow_signed,
	coff_thumb_pcrel_23 ,
	"ARM_THUMB23",
	false,
	0x07ff07ff,
	0x07ff07ff, 
	PCRELOFFSET)
#endif /* not ARM_WINCE */
a262 3

#define NUM_RELOCS NUM_ELEM (aoutarm_std_reloc_howto)

d267 3
a269 4
static boolean
in_reloc_p (abfd, howto)
     bfd * abfd ATTRIBUTE_UNUSED;
     reloc_howto_type * howto;
d271 1
a271 1
  return !howto->pc_relative && howto->type != ARM_RVA32;
d275 3
a277 5
#define RTYPE2HOWTO(cache_ptr, dst)		\
  (cache_ptr)->howto =				\
    (dst)->r_type < NUM_RELOCS			\
    ? aoutarm_std_reloc_howto + (dst)->r_type	\
    : NULL
d283 1
a283 1
     bfd *abfd ATTRIBUTE_UNUSED;
d286 2
a287 2
     struct coff_link_hash_entry *h ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
d290 1
a290 1
  reloc_howto_type * howto;
a291 3
  if (rel->r_type >= NUM_RELOCS)
    return NULL;
  
d294 34
a327 2
  if (rel->r_type == ARM_RVA32)
    *addendp -= pe_data (sec->output_section->owner)->pe_opthdr.ImageBase;
d330 1
d337 7
a343 7
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     char **error_message ATTRIBUTE_UNUSED;
d360 1
a360 1
     char **error_message ATTRIBUTE_UNUSED;
a386 1
  
d393 1
a393 1
      if ((relocation & ~ (bfd_vma) 0x03ffffff) != ~ (bfd_vma) 0x03ffffff)
d405 1
a405 92
  reloc_entry->howto = &aoutarm_std_reloc_howto[ARM_26D];

  return flag;
}

static bfd_reloc_status_type
coff_thumb_pcrel_common (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message, btype)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
     thumb_pcrel_branchtype btype;
{
  bfd_vma relocation = 0;
  bfd_size_type addr = reloc_entry->address;
  long target = bfd_get_32 (abfd, (bfd_byte *) data + addr);
  bfd_reloc_status_type flag = bfd_reloc_ok;
  bfd_vma dstmsk;
  bfd_vma offmsk;
  bfd_vma signbit;

  /* NOTE: This routine is currently used by GAS, but not by the link
     phase.  */

  switch (btype)
    {
    case b9:
      dstmsk  = 0x000000ff;
      offmsk  = 0x000001fe;
      signbit = 0x00000100;
      break;

    case b12:
      dstmsk  = 0x000007ff;
      offmsk  = 0x00000ffe;
      signbit = 0x00000800;
      break;

    case b23:
      dstmsk  = 0x07ff07ff;
      offmsk  = 0x007fffff;
      signbit = 0x00400000;
      break;

    default:
      abort ();
    }
  
  /* If this is an undefined symbol, return error */
  if (symbol->section == &bfd_und_section
      && (symbol->flags & BSF_WEAK) == 0)
    return output_bfd ? bfd_reloc_continue : bfd_reloc_undefined;

  /* If the sections are different, and we are doing a partial relocation,
     just ignore it for now.  */
  if (symbol->section->name != input_section->name
      && output_bfd != (bfd *)NULL)
    return bfd_reloc_continue;

  switch (btype)
    {
    case b9:
    case b12:
      relocation = ((target & dstmsk) << 1);
      break;

    case b23:
      if (bfd_big_endian (abfd))
	relocation = ((target & 0x7ff) << 1)  | ((target & 0x07ff0000) >> 4);
      else
	relocation = ((target & 0x7ff) << 12) | ((target & 0x07ff0000) >> 15);
      break;

    default:
      abort ();
    }

  relocation = (relocation ^ signbit) - signbit; /* Sign extend */
  relocation += symbol->value;
  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;
  relocation -= input_section->output_section->vma;
  relocation -= input_section->output_offset;
  relocation -= addr;

  if (relocation & 1)
    return bfd_reloc_overflow;
a406 35
  /* Check for overflow */
  if (relocation & signbit)
    {
      if ((relocation & ~offmsk) != ~offmsk)
	flag = bfd_reloc_overflow;
    }
  else if (relocation & ~offmsk)
    flag = bfd_reloc_overflow;

  target &= ~dstmsk;
  switch (btype)
   {
   case b9:
   case b12:
     target |= (relocation >> 1);
     break;

   case b23:
     if (bfd_big_endian (abfd))
       target |= ((relocation & 0xfff) >> 1)  | ((relocation << 4)  & 0x07ff0000);
     else
       target |= ((relocation & 0xffe) << 15) | ((relocation >> 12) & 0x7ff);
     break;

   default:
     abort ();
   }

  bfd_put_32 (abfd, target, (bfd_byte *) data + addr);

  /* Now the ARM magic... Change the reloc type so that it is marked as done.
     Strictly this is only necessary if we are doing a partial relocation.  */
  reloc_entry->howto = & aoutarm_std_reloc_howto [ARM_26D];
  
  /* TODO: We should possibly have DONE entries for the THUMB PCREL relocations */
a409 45
static bfd_reloc_status_type
coff_thumb_pcrel_23 (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  return coff_thumb_pcrel_common (abfd, reloc_entry, symbol, data,
                                  input_section, output_bfd, error_message, b23);
}

static bfd_reloc_status_type
coff_thumb_pcrel_12 (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  return coff_thumb_pcrel_common (abfd, reloc_entry, symbol, data,
                                  input_section, output_bfd, error_message, b12);
}

static bfd_reloc_status_type
coff_thumb_pcrel_9 (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  return coff_thumb_pcrel_common (abfd, reloc_entry, symbol, data,
                                  input_section, output_bfd, error_message, b9);
}

d412 2
a413 2
coff_arm_reloc_type_lookup (abfd, code)
      bfd * abfd;
d416 1
a416 2
#define ASTD(i,j)       case i: return aoutarm_std_reloc_howto + j
  
d428 7
a434 18
#ifdef ARM_WINCE
      ASTD (BFD_RELOC_32,                   ARM_32);
      ASTD (BFD_RELOC_RVA,                  ARM_RVA32);
      ASTD (BFD_RELOC_ARM_PCREL_BRANCH,     ARM_26);
      ASTD (BFD_RELOC_THUMB_PCREL_BRANCH12, ARM_THUMB12);
#else
      ASTD (BFD_RELOC_8,                    ARM_8);
      ASTD (BFD_RELOC_16,                   ARM_16);
      ASTD (BFD_RELOC_32,                   ARM_32);
      ASTD (BFD_RELOC_ARM_PCREL_BRANCH,     ARM_26);
      ASTD (BFD_RELOC_8_PCREL,              ARM_DISP8);
      ASTD (BFD_RELOC_16_PCREL,             ARM_DISP16);
      ASTD (BFD_RELOC_32_PCREL,             ARM_DISP32);
      ASTD (BFD_RELOC_RVA,                  ARM_RVA32);
      ASTD (BFD_RELOC_THUMB_PCREL_BRANCH9,  ARM_THUMB9);
      ASTD (BFD_RELOC_THUMB_PCREL_BRANCH12, ARM_THUMB12);
      ASTD (BFD_RELOC_THUMB_PCREL_BRANCH23, ARM_THUMB23);
#endif      
d439 3
a449 13
/* Extend the coff_link_hash_table structure with a few ARM specific fields.
   This allows us to store global data here without actually creating any
   global variables, which is a no-no in the BFD world.  */
struct coff_arm_link_hash_table
{
  /* The original coff_link_hash_table structure.  MUST be first field.  */
  struct coff_link_hash_table	root;
  
  /* The size in bytes of the section containg the Thumb-to-ARM glue.  */
  long int 			thumb_glue_size;
  
  /* The size in bytes of the section containg the ARM-to-Thumb glue.  */
  long int 			arm_glue_size;
d451 2
a452 2
  /* An arbitary input BFD chosen to hold the glue sections.  */
  bfd *				bfd_of_glue_owner;
d454 2
a455 3
  /* Support interworking with old, non-interworking aware ARM code. */
  int 				support_old_code;
};
d457 8
a464 9
/* Get the ARM coff linker hash table from a link_info structure.  */
#define coff_arm_hash_table(info) \
  ((struct coff_arm_link_hash_table *) ((info)->hash))

/* Create an ARM coff linker hash table.  */

static struct bfd_link_hash_table *
coff_arm_link_hash_table_create (abfd)
     bfd * abfd;
d466 3
a468 1
  struct coff_arm_link_hash_table * ret;
d470 6
a475 10
  ret = ((struct coff_arm_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct coff_arm_link_hash_table)));
  if (ret == (struct coff_arm_link_hash_table *) NULL)
    return NULL;

  if (! _bfd_coff_link_hash_table_init
      (& ret->root, abfd, _bfd_coff_link_hash_newfunc))
    {
      bfd_release (abfd, ret);
      return (struct bfd_link_hash_table *) NULL;
d477 2
a478 6

  ret->thumb_glue_size   = 0;
  ret->arm_glue_size     = 0;
  ret->bfd_of_glue_owner = NULL;

  return & ret->root.root;
d481 1
a481 15
static void
arm_emit_base_file_entry (info, output_bfd, input_section, reloc_offset)
      struct bfd_link_info *info;
      bfd *output_bfd;
      asection *input_section;
      bfd_vma reloc_offset;
{
  bfd_vma addr = reloc_offset
                - input_section->vma
                + input_section->output_offset
                  + input_section->output_section->vma;

  if (coff_data(output_bfd)->pe)
     addr -= pe_data(output_bfd)->pe_opthdr.ImageBase;
  fwrite (&addr, 1, sizeof (addr), (FILE *) info->base_file);
d483 1
a483 40
}

/* The thumb form of a long branch is a bit finicky, because the offset
   encoding is split over two fields, each in it's own instruction. They
   can occur in any order. So given a thumb form of long branch, and an 
   offset, insert the offset into the thumb branch and return finished
   instruction. 

   It takes two thumb instructions to encode the target address. Each has 
   11 bits to invest. The upper 11 bits are stored in one (identifed by
   H-0.. see below), the lower 11 bits are stored in the other (identified 
   by H-1). 

   Combine together and shifted left by 1 (it's a half word address) and 
   there you have it.

     Op: 1111 = F,
     H-0, upper address-0 = 000
     Op: 1111 = F,
     H-1, lower address-0 = 800

   They can be ordered either way, but the arm tools I've seen always put 
   the lower one first. It probably doesn't matter. krk@@cygnus.com

   XXX:  Actually the order does matter.  The second instruction (H-1)
   moves the computed address into the PC, so it must be the second one
   in the sequence.  The problem, however is that whilst little endian code
   stores the instructions in HI then LOW order, big endian code does the
   reverse.  nickc@@cygnus.com  */

#define LOW_HI_ORDER 0xF800F000
#define HI_LOW_ORDER 0xF000F800

static insn32
insert_thumb_branch (br_insn, rel_off)
     insn32 br_insn;
     int rel_off;
{
  unsigned int low_bits;
  unsigned int high_bits;
d485 5
a489 533

  BFD_ASSERT((rel_off & 1) != 1);

  rel_off >>= 1;                              /* half word aligned address */
  low_bits = rel_off & 0x000007FF;            /* the bottom 11 bits */
  high_bits = (rel_off >> 11) & 0x000007FF;   /* the top 11 bits */

  if ((br_insn & LOW_HI_ORDER) == LOW_HI_ORDER)
    br_insn = LOW_HI_ORDER | (low_bits << 16) | high_bits;
  else if ((br_insn & HI_LOW_ORDER) == HI_LOW_ORDER)
    br_insn = HI_LOW_ORDER | (high_bits << 16) | low_bits;
  else
    abort(); /* error - not a valid branch instruction form */

  /* FIXME: abort is probably not the right call. krk@@cygnus.com */

  return br_insn;
}


static struct coff_link_hash_entry *
find_thumb_glue (info, name, input_bfd)
     struct bfd_link_info * info;
     CONST char *           name;
     bfd *                  input_bfd;
{
  char *                        tmp_name;
  struct coff_link_hash_entry * myh;

  tmp_name = ((char *)
	 bfd_malloc (strlen (name) + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1));

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, THUMB2ARM_GLUE_ENTRY_NAME, name);
  
  myh = coff_link_hash_lookup
    (coff_hash_table (info), tmp_name, false, false, true);
  
  if (myh == NULL)
    /* xgettext:c-format */
    _bfd_error_handler (_("%s: unable to find THUMB glue '%s' for `%s'"),
			bfd_get_filename (input_bfd), tmp_name, name);
  
  free (tmp_name);

  return myh;
}

static struct coff_link_hash_entry *
find_arm_glue (info, name, input_bfd)
     struct bfd_link_info * info;
     CONST char *           name;
     bfd *                  input_bfd;
{
  char *                        tmp_name;
  struct coff_link_hash_entry * myh;

  tmp_name = ((char *)
	      bfd_malloc (strlen (name) + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1));

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, ARM2THUMB_GLUE_ENTRY_NAME, name);
  
  myh = coff_link_hash_lookup
    (coff_hash_table (info), tmp_name, false, false, true);

  if (myh == NULL)
    /* xgettext:c-format */
    _bfd_error_handler (_("%s: unable to find ARM glue '%s' for `%s'"),
			bfd_get_filename (input_bfd), tmp_name, name);
  
  free (tmp_name);

  return myh;
}

/*
  ARM->Thumb glue:

       .arm
       __func_from_arm:
	     ldr r12, __func_addr
	     bx  r12
       __func_addr:
            .word func    @@ behave as if you saw a ARM_32 reloc
*/

#define ARM2THUMB_GLUE_SIZE 12
static const insn32 a2t1_ldr_insn       = 0xe59fc000;
static const insn32 a2t2_bx_r12_insn    = 0xe12fff1c;
static const insn32 a2t3_func_addr_insn = 0x00000001;

/*
   Thumb->ARM:				Thumb->(non-interworking aware) ARM

   .thumb				.thumb
   .align 2				.align 2
      __func_from_thumb:		   __func_from_thumb:
	   bx pc				push {r6, lr}
	   nop					ldr  r6, __func_addr
   .arm						mov  lr, pc
      __func_change_to_arm:			bx   r6
	   b func   			.arm
					   __func_back_to_thumb:
   		  				ldmia r13! {r6, lr}
   					        bx    lr
   					   __func_addr:
					        .word	func 
*/

#define THUMB2ARM_GLUE_SIZE (globals->support_old_code ? 20 : 8)
static const insn16 t2a1_bx_pc_insn = 0x4778;
static const insn16 t2a2_noop_insn  = 0x46c0;
static const insn32 t2a3_b_insn     = 0xea000000;

static const insn16 t2a1_push_insn  = 0xb540;
static const insn16 t2a2_ldr_insn   = 0x4e03;
static const insn16 t2a3_mov_insn   = 0x46fe;
static const insn16 t2a4_bx_insn    = 0x4730;
static const insn32 t2a5_pop_insn   = 0xe8bd4040;
static const insn32 t2a6_bx_insn    = 0xe12fff1e;

/* TODO:
     We should really create new local (static) symbols in destination
     object for each stub we create.  We should also create local
     (static) symbols within the stubs when switching between ARM and
     Thumb code.  This will ensure that the debugger and disassembler
     can present a better view of stubs.

     We can treat stubs like literal sections, and for the THUMB9 ones
     (short addressing range) we should be able to insert the stubs
     between sections. i.e. the simplest approach (since relocations
     are done on a section basis) is to dump the stubs at the end of
     processing a section. That way we can always try and minimise the
     offset to and from a stub. However, this does not map well onto
     the way that the linker/BFD does its work: mapping all input
     sections to output sections via the linker script before doing
     all the processing.

     Unfortunately it may be easier to just to disallow short range
     Thumb->ARM stubs (i.e. no conditional inter-working branches,
     only branch-and-link (BL) calls.  This will simplify the processing
     since we can then put all of the stubs into their own section.

  TODO:
     On a different subject, rather than complaining when a
     branch cannot fit in the number of bits available for the
     instruction we should generate a trampoline stub (needed to
     address the complete 32bit address space).  */

/* The standard COFF backend linker does not cope with the special 
   Thumb BRANCH23 relocation.  The alternative would be to split the
   BRANCH23 into seperate HI23 and LO23 relocations. However, it is a
   bit simpler simply providing our own relocation driver. */

/* The reloc processing routine for the ARM/Thumb COFF linker.  NOTE:
   This code is a very slightly modified copy of
   _bfd_coff_generic_relocate_section.  It would be a much more
   maintainable solution to have a MACRO that could be expanded within
   _bfd_coff_generic_relocate_section that would only be provided for
   ARM/Thumb builds.  It is only the code marked THUMBEXTENSION that
   is different from the original.  */

static boolean
coff_arm_relocate_section (output_bfd, info, input_bfd, input_section,
                           contents, relocs, syms, sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     struct internal_reloc *relocs;
     struct internal_syment *syms;
     asection **sections;
{
  struct internal_reloc * rel;
  struct internal_reloc * relend;

  rel = relocs;
  relend = rel + input_section->reloc_count;

  for (; rel < relend; rel++)
    {
      int                            done = 0;
      long                           symndx;
      struct coff_link_hash_entry *  h;
      struct internal_syment *       sym;
      bfd_vma                        addend;
      bfd_vma                        val;
      reloc_howto_type *             howto;
      bfd_reloc_status_type          rstat;
      bfd_vma                        h_val;

      symndx = rel->r_symndx;

      if (symndx == -1)
	{
	  h = NULL;
	  sym = NULL;
	}
      else
	{    
	  h = obj_coff_sym_hashes (input_bfd)[symndx];
	  sym = syms + symndx;
	}

      /* COFF treats common symbols in one of two ways.  Either the
         size of the symbol is included in the section contents, or it
         is not.  We assume that the size is not included, and force
         the rtype_to_howto function to adjust the addend as needed.  */

      if (sym != NULL && sym->n_scnum != 0)
	addend = - sym->n_value;
      else
	addend = 0;


      howto = coff_rtype_to_howto (input_bfd, input_section, rel, h,
				       sym, &addend);
      if (howto == NULL)
	return false;

      /* The relocation_section function will skip pcrel_offset relocs
         when doing a relocateable link.  However, we want to convert
         ARM26 to ARM26D relocs if possible.  We return a fake howto in
         this case without pcrel_offset set, and adjust the addend to
         compensate.  */
      if (rel->r_type == ARM_26
          && h != NULL
          && info->relocateable
          && (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
          && h->root.u.def.section->output_section == input_section->output_section)
        {
          static reloc_howto_type fake_arm26_reloc = 
	    HOWTO (ARM_26,
    	       2,
    	       2,
    	       24,
    	       true,
    	       0,
    	       complain_overflow_signed,
    	       aoutarm_fix_pcrel_26 ,
    	       "ARM_26",
    	       false,
    	       0x00ffffff,
    	       0x00ffffff, 
    	       false);

          addend -= rel->r_vaddr - input_section->vma;
          howto = &fake_arm26_reloc;
        }

#ifdef ARM_WINCE
      /* MS ARM-CE makes the reloc relative to the opcode's pc, not
	 the next opcode's pc, so is off by one. */
      if (howto->pc_relative && !info->relocateable)
	addend -= 8;
#endif
      
      /* If we are doing a relocateable link, then we can just ignore
         a PC relative reloc that is pcrel_offset.  It will already
         have the correct value.  If this is not a relocateable link,
         then we should ignore the symbol value.  */
      if (howto->pc_relative && howto->pcrel_offset)
        {
          if (info->relocateable)
            continue;
          if (sym != NULL && sym->n_scnum != 0)
            addend += sym->n_value;
        }

      val = 0;

      if (h == NULL)
	{
	  asection *sec;

	  if (symndx == -1)
	    {
	      sec = bfd_abs_section_ptr;
	      val = 0;
	    }
	  else
	    {
	      sec = sections[symndx];
              val = (sec->output_section->vma
		     + sec->output_offset
		     + sym->n_value
		     - sec->vma);
	    }
	}
      else
	{
#if 1 /* THUMBEXTENSION */
          /* We don't output the stubs if we are generating a
             relocatable output file, since we may as well leave the
             stub generation to the final linker pass. If we fail to
	     verify that the name is defined, we'll try to build stubs
	     for an undefined name... */
          if (! info->relocateable
	      && (   h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak))
            {
	      asection *   h_sec = h->root.u.def.section;
	      const char * name  = h->root.root.string;
	      
	      /* h locates the symbol referenced in the reloc.  */
	      h_val = (h->root.u.def.value
		       + h_sec->output_section->vma
		       + h_sec->output_offset);

              if (howto->type == ARM_26)
                {
                  if (   h->class == C_THUMBSTATFUNC
		      || h->class == C_THUMBEXTFUNC)
		    {
		      /* Arm code calling a Thumb function */
		      unsigned long int                 tmp;
		      long int                          my_offset;
		      asection *                        s;
		      long int                          ret_offset;
		      struct coff_link_hash_entry *     myh; 
		      struct coff_arm_link_hash_table * globals;
		      
		      myh = find_arm_glue (info, name, input_bfd);
		      if (myh == NULL)
			return false;

		      globals = coff_arm_hash_table (info);

		      BFD_ASSERT (globals != NULL);
		      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);
			
		      my_offset = myh->root.u.def.value;
		      
		      s = bfd_get_section_by_name (globals->bfd_of_glue_owner, 
						  ARM2THUMB_GLUE_SECTION_NAME);
		      BFD_ASSERT (s != NULL);
		      BFD_ASSERT (s->contents != NULL);
		      BFD_ASSERT (s->output_section != NULL);

		      if ((my_offset & 0x01) == 0x01)
			{
			  if (h_sec->owner != NULL
			      && INTERWORK_SET (h_sec->owner)
			      && ! INTERWORK_FLAG (h_sec->owner))
			    {
			      _bfd_error_handler
				/* xgettext:c-format */
				(_("%s(%s): warning: interworking not enabled."),
				 bfd_get_filename (h_sec->owner), name);
			      _bfd_error_handler
				/* xgettext:c-format */
				(_("  first occurrence: %s: arm call to thumb"),
				 bfd_get_filename (input_bfd));
			    }

			  --my_offset;
			  myh->root.u.def.value = my_offset;

			  bfd_put_32 (output_bfd, a2t1_ldr_insn,
				      s->contents + my_offset);
			  
			  bfd_put_32 (output_bfd, a2t2_bx_r12_insn,
				      s->contents + my_offset + 4);
			  
			  /* It's a thumb address.  Add the low order bit.  */
			  bfd_put_32 (output_bfd, h_val | a2t3_func_addr_insn,
				      s->contents + my_offset + 8);

                          if (info->base_file)
                            arm_emit_base_file_entry (info, output_bfd, s, 
                                                            my_offset + 8);

			}

		      BFD_ASSERT (my_offset <= globals->arm_glue_size);

		      tmp = bfd_get_32 (input_bfd, contents + rel->r_vaddr
					- input_section->vma);
		      
		      tmp = tmp & 0xFF000000;

		      /* Somehow these are both 4 too far, so subtract 8. */
		      ret_offset =
			s->output_offset
			+ my_offset 
			+ s->output_section->vma
			- (input_section->output_offset
			   + input_section->output_section->vma 
			   + rel->r_vaddr)
			- 8;

		      tmp = tmp | ((ret_offset >> 2) & 0x00FFFFFF);
		      
		      bfd_put_32 (output_bfd, tmp, contents + rel->r_vaddr
				  - input_section->vma);
		      done = 1;
		    }
                }
	      
#ifndef ARM_WINCE
	      /* Note: We used to check for ARM_THUMB9 and ARM_THUMB12 */
              else if (howto->type == ARM_THUMB23)
                {
                  if (   h->class == C_EXT 
		      || h->class == C_STAT
		      || h->class == C_LABEL)
		    {
		      /* Thumb code calling an ARM function */
		      asection *                         s = 0;
		      long int                           my_offset;
		      unsigned long int                  tmp;
		      long int                           ret_offset;
		      struct coff_link_hash_entry *      myh;
		      struct coff_arm_link_hash_table *  globals;

		      myh = find_thumb_glue (info, name, input_bfd);
		      if (myh == NULL)
			return false;

		      globals = coff_arm_hash_table (info);
		      
		      BFD_ASSERT (globals != NULL);
		      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);
		      
		      my_offset = myh->root.u.def.value;
		      
		      s = bfd_get_section_by_name (globals->bfd_of_glue_owner, 
						   THUMB2ARM_GLUE_SECTION_NAME);
		      
		      BFD_ASSERT (s != NULL);
		      BFD_ASSERT (s->contents != NULL);
		      BFD_ASSERT (s->output_section != NULL);
		      
		      if ((my_offset & 0x01) == 0x01)
			{
			  if (h_sec->owner != NULL
			      && INTERWORK_SET (h_sec->owner)
			      && ! INTERWORK_FLAG (h_sec->owner)
			      && ! globals->support_old_code)
			    {
			      _bfd_error_handler
				/* xgettext:c-format */
				(_("%s(%s): warning: interworking not enabled."),
				 bfd_get_filename (h_sec->owner), name);
			      _bfd_error_handler
				/* xgettext:c-format */
				(_("  first occurrence: %s: thumb call to arm"),
				 bfd_get_filename (input_bfd));
			      _bfd_error_handler
				(_("  consider relinking with --support-old-code enabled"));
			    }
			  
			  -- my_offset;
			  myh->root.u.def.value = my_offset;

			  if (globals->support_old_code)
			    {
			      bfd_put_16 (output_bfd, t2a1_push_insn,
					  s->contents + my_offset);
			      
			      bfd_put_16 (output_bfd, t2a2_ldr_insn,
					  s->contents + my_offset + 2);

			      bfd_put_16 (output_bfd, t2a3_mov_insn,
					  s->contents + my_offset + 4);

			      bfd_put_16 (output_bfd, t2a4_bx_insn,
					  s->contents + my_offset + 6);
			      
			      bfd_put_32 (output_bfd, t2a5_pop_insn,
					  s->contents + my_offset + 8);
			      
			      bfd_put_32 (output_bfd, t2a6_bx_insn,
					  s->contents + my_offset + 12);
			      
			      /* Store the address of the function in the last word of the stub.  */
			      bfd_put_32 (output_bfd, h_val,
					  s->contents + my_offset + 16);

                              if (info->base_file)
                                arm_emit_base_file_entry (info, output_bfd, s, my_offset + 16);
			    }
			  else
			    {
			      bfd_put_16 (output_bfd, t2a1_bx_pc_insn,
					  s->contents + my_offset);
		      
			      bfd_put_16 (output_bfd, t2a2_noop_insn,
					  s->contents + my_offset + 2);
		      
			      ret_offset =
				((bfd_signed_vma) h_val)	/* Address of destination of the stub */
				- ((bfd_signed_vma)
				   (s->output_offset 		/* Offset from the start of the current section to the start of the stubs.  */
				    + my_offset			/* Offset of the start of this stub from the start of the stubs.  */
				    + s->output_section->vma) 	/* Address of the start of the current section.  */
				   + 4				/* The branch instruction is 4 bytes into the stub.  */
				   + 8);			/* ARM branches work from the pc of the instruction + 8.  */
			      
			      bfd_put_32 (output_bfd,
					  t2a3_b_insn | ((ret_offset >> 2) & 0x00FFFFFF),
					  s->contents + my_offset + 4);

			    }
			}

		      BFD_ASSERT (my_offset <= globals->thumb_glue_size);

		      /* Now go back and fix up the original BL insn to point
			 to here.  */
		      ret_offset =
			s->output_offset
			+ my_offset
			- (input_section->output_offset
			   + rel->r_vaddr)
			-4;
		      
		      tmp = bfd_get_32 (input_bfd, contents + rel->r_vaddr
					- input_section->vma);

		      bfd_put_32 (output_bfd,
				  insert_thumb_branch (tmp, ret_offset),
				  contents + rel->r_vaddr
				  - input_section->vma);
		      
		      done = 1;
                    }
                }
a490 246
            }
	  
          /* If the relocation type and destination symbol does not
             fall into one of the above categories, then we can just
             perform a direct link. */

	  if (done)
	    rstat = bfd_reloc_ok;
	  else 
#endif /* THUMBEXTENSION */
	    if (   h->root.type == bfd_link_hash_defined
		|| h->root.type == bfd_link_hash_defweak)
	    {
	      asection *sec;

	      sec = h->root.u.def.section;
	      val = (h->root.u.def.value
		     + sec->output_section->vma
		     + sec->output_offset);
	      }

	  else if (! info->relocateable)
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd, input_section,
		      rel->r_vaddr - input_section->vma, true)))
		return false;
	    }
	}

      if (info->base_file)
	{
	  /* Emit a reloc if the backend thinks it needs it. */
	  if (sym && pe_data(output_bfd)->in_reloc_p(output_bfd, howto))
            arm_emit_base_file_entry (info, output_bfd, input_section, rel->r_vaddr);
	}
  
#if 1 /* THUMBEXTENSION */
      if (done)
	rstat = bfd_reloc_ok;
#ifndef ARM_WINCE
      /* Only perform this fix during the final link, not a relocatable link.  nickc@@cygnus.com  */
      else if (! info->relocateable
	       && howto->type == ARM_THUMB23)
        {
          /* This is pretty much a copy of what the default
             _bfd_final_link_relocate and _bfd_relocate_contents
             routines do to perform a relocation, with special
             processing for the split addressing of the Thumb BL
             instruction.  Again, it would probably be simpler adding a
             ThumbBRANCH23 specific macro expansion into the default
             code.  */
	  
          bfd_vma address = rel->r_vaddr - input_section->vma;
	  
          if (address > input_section->_raw_size)
	    rstat = bfd_reloc_outofrange;
          else
            {
              bfd_vma         relocation       = val + addend;
	      int             size             = bfd_get_reloc_size (howto);
	      boolean         overflow         = false;
	      bfd_byte *      location         = contents + address;
	      bfd_vma         x                = bfd_get_32 (input_bfd, location);
	      bfd_vma         src_mask         = 0x007FFFFE;
	      bfd_signed_vma  reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;
	      bfd_signed_vma  reloc_signed_min = ~reloc_signed_max;
	      bfd_vma         check;
	      bfd_signed_vma  signed_check;
	      bfd_vma         add;
	      bfd_signed_vma  signed_add;

	      BFD_ASSERT (size == 4);
	      
              /* howto->pc_relative should be TRUE for type 14 BRANCH23 */
              relocation -= (input_section->output_section->vma
                             + input_section->output_offset);
	      
              /* howto->pcrel_offset should be TRUE for type 14 BRANCH23 */
              relocation -= address;
	      
	      /* No need to negate the relocation with BRANCH23. */
	      /* howto->complain_on_overflow == complain_overflow_signed for BRANCH23.  */
	      /* howto->rightshift == 1 */
	      /* Drop unwanted bits from the value we are relocating to.  */
	      
	      check = relocation >> howto->rightshift;
		
	      /* If this is a signed value, the rightshift just dropped
		 leading 1 bits (assuming twos complement).  */
	      if ((bfd_signed_vma) relocation >= 0)
		signed_check = check;
	      else
		signed_check = (check
				| ((bfd_vma) - 1
				   & ~((bfd_vma) - 1 >> howto->rightshift)));
	      
	      /* Get the value from the object file.  */
	      if (bfd_big_endian (input_bfd))
		{
		  add = (((x) & 0x07ff0000) >> 4) | (((x) & 0x7ff) << 1);
		}
	      else
		{
		  add = ((((x) & 0x7ff) << 12) | (((x) & 0x07ff0000) >> 15));
		}

	      /* Get the value from the object file with an appropriate sign.
		 The expression involving howto->src_mask isolates the upper
		 bit of src_mask.  If that bit is set in the value we are
		 adding, it is negative, and we subtract out that number times
		 two.  If src_mask includes the highest possible bit, then we
		 can not get the upper bit, but that does not matter since
		 signed_add needs no adjustment to become negative in that
		 case.  */
	      
	      signed_add = add;
	      
	      if ((add & (((~ src_mask) >> 1) & src_mask)) != 0)
		signed_add -= (((~ src_mask) >> 1) & src_mask) << 1;
	      
	      /* Add the value from the object file, shifted so that it is a
		 straight number.  */
	      /* howto->bitpos == 0 */
	      
	      signed_check += signed_add;
	      relocation += signed_add;

	      BFD_ASSERT (howto->complain_on_overflow == complain_overflow_signed);

	      /* Assumes two's complement.  */
	      if (   signed_check > reloc_signed_max
		  || signed_check < reloc_signed_min)
		overflow = true;
	      
	      /* Put RELOCATION into the correct bits:  */
	      
	      if (bfd_big_endian (input_bfd))
		{
		  relocation = (((relocation & 0xffe) >> 1)  | ((relocation << 4) & 0x07ff0000));
		}
	      else
		{
		  relocation = (((relocation & 0xffe) << 15) | ((relocation >> 12) & 0x7ff));
		}
	      
	      /* Add RELOCATION to the correct bits of X:  */
	      x = ((x & ~howto->dst_mask) | relocation);

	      /* Put the relocated value back in the object file:  */
	      bfd_put_32 (input_bfd, x, location);

	      rstat = overflow ? bfd_reloc_overflow : bfd_reloc_ok;
            }
        }
#endif
      else
#endif /* THUMBEXTENSION */
        rstat = _bfd_final_link_relocate (howto, input_bfd, input_section,
                                          contents,
                                          rel->r_vaddr - input_section->vma,
                                          val, addend);
#if 1 /* THUMBEXTENSION */
      /* FIXME: 
	 Is this the best way to fix up thumb addresses? krk@@cygnus.com
	 Probably not, but it works, and if it works it don't need fixing!  nickc@@cygnus.com */
      /* Only perform this fix during the final link, not a relocatable link.  nickc@@cygnus.com  */
      if (! info->relocateable
	  && (rel->r_type == ARM_32 || rel->r_type == ARM_RVA32))
	{
	  /* Determine if we need to set the bottom bit of a relocated address
	     because the address is the address of a Thumb code symbol.  */
	     
	  int patchit = false;
	  
	  if (h != NULL
	      && (   h->class == C_THUMBSTATFUNC
		  || h->class == C_THUMBEXTFUNC))
	    {
	      patchit = true;
	    }
	  else if (sym != NULL
		   && sym->n_scnum > N_UNDEF)
	    {
	      /* No hash entry - use the symbol instead.  */

	      if (   sym->n_sclass == C_THUMBSTATFUNC
		  || sym->n_sclass == C_THUMBEXTFUNC)
		patchit = true;
	    }

	  if (patchit)
	    {
	      bfd_byte * location = contents + rel->r_vaddr - input_section->vma;
	      bfd_vma    x        = bfd_get_32 (input_bfd, location);

	      bfd_put_32 (input_bfd, x | 1, location);
	    }
	}
#endif /* THUMBEXTENSION */      
      
      switch (rstat)
	{
	default:
	  abort ();
	case bfd_reloc_ok:
	  break;
	case bfd_reloc_outofrange:
	  (*_bfd_error_handler)
	    (_("%s: bad reloc address 0x%lx in section `%s'"),
	     bfd_get_filename (input_bfd),
	     (unsigned long) rel->r_vaddr,
	     bfd_get_section_name (input_bfd, input_section));
	  return false;
	case bfd_reloc_overflow:
	  {
	    const char *name;
	    char buf[SYMNMLEN + 1];

	    if (symndx == -1)
	      name = "*ABS*";
	    else if (h != NULL)
	      name = h->root.root.string;
	    else
	      {
		name = _bfd_coff_internal_syment_name (input_bfd, sym, buf);
		if (name == NULL)
		  return false;
	      }

	    if (! ((*info->callbacks->reloc_overflow)
		   (info, name, howto->name, (bfd_vma) 0, input_bfd,
		    input_section, rel->r_vaddr - input_section->vma)))
	      return false;
	  }
	}
    }

  return true;
}

#ifndef COFF_IMAGE_WITH_PE

boolean
bfd_arm_allocate_interworking_sections (info) 
     struct bfd_link_info * info;
d492 4
a495 5
  asection *                        s;
  bfd_byte *                        foo;
  struct coff_arm_link_hash_table * globals;
#if 0
  static char                       test_char = '1';
d497 7
d505 5
a509 17
  globals = coff_arm_hash_table (info);
  
  BFD_ASSERT (globals != NULL);

  if (globals->arm_glue_size != 0)
    {
      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);
      
      s = bfd_get_section_by_name
	(globals->bfd_of_glue_owner, ARM2THUMB_GLUE_SECTION_NAME);

      BFD_ASSERT (s != NULL);
      
      foo = (bfd_byte *) bfd_alloc
	(globals->bfd_of_glue_owner, globals->arm_glue_size);
#if 0
      memset (foo, test_char, globals->arm_glue_size);
a510 4
      
      s->_raw_size = s->_cooked_size = globals->arm_glue_size;
      s->contents = foo;
    }
d512 4
a515 13
  if (globals->thumb_glue_size != 0)
    {
      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);
      
      s = bfd_get_section_by_name
	(globals->bfd_of_glue_owner, THUMB2ARM_GLUE_SECTION_NAME);

      BFD_ASSERT (s != NULL);
      
      foo = (bfd_byte *) bfd_alloc
	(globals->bfd_of_glue_owner, globals->thumb_glue_size);
#if 0
      memset (foo, test_char, globals->thumb_glue_size);
d517 2
a518 4
      
      s->_raw_size = s->_cooked_size = globals->thumb_glue_size;
      s->contents = foo;
    }
d520 24
a543 2
  return true;
}
d545 2
a546 10
static void
record_arm_to_thumb_glue (info, h)
     struct bfd_link_info *        info;
     struct coff_link_hash_entry * h;
{
  const char *                      name = h->root.root.string;
  register asection *               s;
  char *                            tmp_name;
  struct coff_link_hash_entry *     myh;
  struct coff_arm_link_hash_table * globals;
d548 5
a552 281
  globals = coff_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  s = bfd_get_section_by_name
    (globals->bfd_of_glue_owner, ARM2THUMB_GLUE_SECTION_NAME);

  BFD_ASSERT (s != NULL);

  tmp_name = ((char *)
	      bfd_malloc (strlen (name) + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1));

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, ARM2THUMB_GLUE_ENTRY_NAME, name);
  
  myh = coff_link_hash_lookup
    (coff_hash_table (info), tmp_name, false, false, true);
  
  if (myh != NULL)
    {
      free (tmp_name);
      return; /* we've already seen this guy */
    }

  /* The only trick here is using globals->arm_glue_size as the value. Even
     though the section isn't allocated yet, this is where we will be putting
     it.  */

  bfd_coff_link_add_one_symbol (info, globals->bfd_of_glue_owner, tmp_name,
				BSF_GLOBAL, 
				s, globals->arm_glue_size + 1,
				NULL, true, false, 
				(struct bfd_link_hash_entry **) & myh);
  
  free (tmp_name);
  
  globals->arm_glue_size += ARM2THUMB_GLUE_SIZE;

  return;
}

static void
record_thumb_to_arm_glue (info, h)
     struct bfd_link_info *        info;
     struct coff_link_hash_entry * h;
{
  const char *                       name = h->root.root.string;
  register asection *                s;
  char *                             tmp_name;
  struct coff_link_hash_entry *      myh;
  struct coff_arm_link_hash_table *  globals;

  
  globals = coff_arm_hash_table (info);
  
  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  s = bfd_get_section_by_name
    (globals->bfd_of_glue_owner, THUMB2ARM_GLUE_SECTION_NAME);

  BFD_ASSERT (s != NULL);

  tmp_name = (char *) bfd_malloc (strlen (name) + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, THUMB2ARM_GLUE_ENTRY_NAME, name);

  myh = coff_link_hash_lookup
    (coff_hash_table (info), tmp_name, false, false, true);
  
  if (myh != NULL)
    {
      free (tmp_name);
      return; /* we've already seen this guy */
    }

  bfd_coff_link_add_one_symbol (info, globals->bfd_of_glue_owner, tmp_name,
				BSF_GLOBAL, s, globals->thumb_glue_size + 1,
				NULL, true, false, 
				(struct bfd_link_hash_entry **) & myh);
  
  /* If we mark it 'thumb', the disassembler will do a better job.  */
  myh->class = C_THUMBEXTFUNC;

  free (tmp_name);

  /* Allocate another symbol to mark where we switch to arm mode.  */
      
#define CHANGE_TO_ARM "__%s_change_to_arm"
#define BACK_FROM_ARM "__%s_back_from_arm"
  
  tmp_name = (char *) bfd_malloc (strlen (name) + strlen (CHANGE_TO_ARM) + 1);
  
  BFD_ASSERT (tmp_name);
  
  sprintf (tmp_name, globals->support_old_code ? BACK_FROM_ARM : CHANGE_TO_ARM, name);

  myh = NULL;
  
  bfd_coff_link_add_one_symbol (info, globals->bfd_of_glue_owner, tmp_name,
				BSF_LOCAL, s, globals->thumb_glue_size
				+ (globals->support_old_code ? 8 : 4),
				NULL, true, false, 
				(struct bfd_link_hash_entry **) & myh);

  free (tmp_name);  
  
  globals->thumb_glue_size += THUMB2ARM_GLUE_SIZE;

  return;
}

/* Select a BFD to be used to hold the sections used by the glue code.
   This function is called from the linker scripts in ld/emultempl/
   {armcoff/pe}.em  */

boolean
bfd_arm_get_bfd_for_interworking (abfd, info)
     bfd * 		    abfd;
     struct bfd_link_info * info;
{
  struct coff_arm_link_hash_table * globals;
  flagword   			    flags;
  asection * 			    sec;
    
  /* If we are only performing a partial link do not bother
     getting a bfd to hold the glue.  */
  if (info->relocateable)
    return true;
  
  globals = coff_arm_hash_table (info);
  
  BFD_ASSERT (globals != NULL);

  if (globals->bfd_of_glue_owner != NULL)
    return true;
  
  sec = bfd_get_section_by_name (abfd, ARM2THUMB_GLUE_SECTION_NAME);
  
  if (sec == NULL) 
    {
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_CODE | SEC_READONLY;
      
      sec = bfd_make_section (abfd, ARM2THUMB_GLUE_SECTION_NAME);
      
      if (sec == NULL
	  || ! bfd_set_section_flags (abfd, sec, flags)
	  || ! bfd_set_section_alignment (abfd, sec, 2))
	return false;
    }

  sec = bfd_get_section_by_name (abfd, THUMB2ARM_GLUE_SECTION_NAME);

  if (sec == NULL) 
    {
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_CODE | SEC_READONLY;
      
      sec = bfd_make_section (abfd, THUMB2ARM_GLUE_SECTION_NAME);
      
      if (sec == NULL
	  || ! bfd_set_section_flags (abfd, sec, flags)
	  || ! bfd_set_section_alignment (abfd, sec, 2))
	return false;
    }
  
  /* Save the bfd for later use.  */
  globals->bfd_of_glue_owner = abfd;
  
  return true;
}

boolean
bfd_arm_process_before_allocation (abfd, info, support_old_code)
     bfd *                   abfd;
     struct bfd_link_info *  info;
     int		     support_old_code;
{
  asection * sec;
  struct coff_arm_link_hash_table * globals;

  /* If we are only performing a partial link do not bother
     to construct any glue.  */
  if (info->relocateable)
    return true;
  
  /* Here we have a bfd that is to be included on the link.  We have a hook
     to do reloc rummaging, before section sizes are nailed down.  */

  _bfd_coff_get_external_symbols (abfd);

  globals = coff_arm_hash_table (info);
  
  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  globals->support_old_code = support_old_code;
  
  /* Rummage around all the relocs and map the glue vectors.  */
  sec = abfd->sections;

  if (sec == NULL)
    return true;

  for (; sec != NULL; sec = sec->next)
    {
      struct internal_reloc * i;
      struct internal_reloc * rel;

      if (sec->reloc_count == 0) 
	continue;

      /* Load the relocs.  */
      /* FIXME: there may be a storage leak here. */
      
      i = _bfd_coff_read_internal_relocs (abfd, sec, 1, 0, 0, 0);
    
      BFD_ASSERT (i != 0);

      for (rel = i; rel < i + sec->reloc_count; ++rel) 
	{
	  unsigned short                 r_type  = rel->r_type;
	  long                           symndx;
	  struct coff_link_hash_entry *  h;

	  symndx = rel->r_symndx;

	  /* If the relocation is not against a symbol it cannot concern us. */
	  if (symndx == -1)
	    continue;

	  /* If the index is outside of the range of our table, something has gone wrong.  */
	  if (symndx >= obj_conv_table_size (abfd))
	    {
	      _bfd_error_handler (_("%s: illegal symbol index in reloc: %d"),
				  bfd_get_filename (abfd), symndx);
	      continue;
	    }
	  
	  h = obj_coff_sym_hashes (abfd)[symndx];

	  /* If the relocation is against a static symbol it must be within
	     the current section and so cannot be a cross ARM/Thumb relocation.  */
	  if (h == NULL)
	    continue;

	  switch (r_type)
	    {
	    case ARM_26:
	      /* This one is a call from arm code.  We need to look up
		 the target of the call. If it is a thumb target, we
		 insert glue.  */
	      
	      if (h->class == C_THUMBEXTFUNC)
		record_arm_to_thumb_glue (info, h);
	      break;
	      
#ifndef ARM_WINCE
	    case ARM_THUMB23:
	      /* This one is a call from thumb code.  We used to look
		 for ARM_THUMB9 and ARM_THUMB12 as well.  We need to look
		 up the target of the call. If it is an arm target, we
		 insert glue.  If the symbol does not exist it will be
		 given a class of C_EXT and so we will generate a stub
		 for it.  This is not really a problem, since the link
		 is doomed anyway.  */

	      switch (h->class)
		{
		case C_EXT:
		case C_STAT:
		case C_LABEL:
		  record_thumb_to_arm_glue (info, h);
		  break;
		default:
		  ;
		}
	      break;
a553 36
	      
	    default:
	      break;
	    }
	}
    }

  return true;
}

#endif /* ! defined (COFF_IMAGE_WITH_PE) */

#define coff_bfd_reloc_type_lookup 		coff_arm_reloc_type_lookup
#define coff_relocate_section 			coff_arm_relocate_section
#define coff_bfd_is_local_label_name 		coff_arm_is_local_label_name
#define coff_adjust_symndx			coff_arm_adjust_symndx
#define coff_link_output_has_begun 		coff_arm_link_output_has_begun
#define coff_final_link_postscript		coff_arm_final_link_postscript
#define coff_bfd_merge_private_bfd_data		coff_arm_merge_private_bfd_data
#define coff_bfd_print_private_bfd_data		coff_arm_print_private_bfd_data
#define coff_bfd_set_private_flags              _bfd_coff_arm_set_private_flags
#define coff_bfd_copy_private_bfd_data          coff_arm_copy_private_bfd_data
#define coff_bfd_link_hash_table_create		coff_arm_link_hash_table_create


/* When doing a relocateable link, we want to convert ARM26 relocs
   into ARM26D relocs.  */

static boolean
coff_arm_adjust_symndx (obfd, info, ibfd, sec, irel, adjustedp)
     bfd *obfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     bfd *ibfd;
     asection *sec;
     struct internal_reloc *irel;
     boolean *adjustedp;
d555 4
a558 301
  if (irel->r_type == 3)
    {
      struct coff_link_hash_entry *h;

      h = obj_coff_sym_hashes (ibfd)[irel->r_symndx];
      if (h != NULL
	  && (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	  && h->root.u.def.section->output_section == sec->output_section)
	irel->r_type = 7;
    }
  *adjustedp = false;
  return true;
}

/* Called when merging the private data areas of two BFDs.
   This is important as it allows us to detect if we are
   attempting to merge binaries compiled for different ARM
   targets, eg different CPUs or differents APCS's.     */

static boolean
coff_arm_merge_private_bfd_data (ibfd, obfd)
     bfd *   ibfd;
     bfd *   obfd;
{
  BFD_ASSERT (ibfd != NULL && obfd != NULL);

  if (ibfd == obfd)
    return true;

  /* If the two formats are different we cannot merge anything.
     This is not an error, since it is permissable to change the
     input and output formats.  */
  if (   ibfd->xvec->flavour != bfd_target_coff_flavour
      || obfd->xvec->flavour != bfd_target_coff_flavour)
    return true;

  /* Verify that the APCS is the same for the two BFDs */
  if (APCS_SET (ibfd))
    {
      if (APCS_SET (obfd))
	{
	  /* If the src and dest have different APCS flag bits set, fail.  */
	  if (APCS_26_FLAG (obfd) != APCS_26_FLAG (ibfd))
	    {
	      _bfd_error_handler
		/* xgettext: c-format */
		(_("%s: ERROR: compiled for APCS-%d whereas target %s uses APCS-%d"),
		 bfd_get_filename (ibfd), APCS_26_FLAG (ibfd) ? 26 : 32,
		 bfd_get_filename (obfd), APCS_26_FLAG (obfd) ? 26 : 32
		 );

	      bfd_set_error (bfd_error_wrong_format);
	      return false;
	    }
	  
	  if (APCS_FLOAT_FLAG (obfd) != APCS_FLOAT_FLAG (ibfd))
	    {
	      const char *msg;

	      if (APCS_FLOAT_FLAG (ibfd))
		/* xgettext: c-format */
		msg = _("%s: ERROR: passes floats in float registers whereas target %s uses integer registers");
	      else
		/* xgettext: c-format */
		msg = _("%s: ERROR: passes floats in integer registers whereas target %s uses float registers");
	      
	      _bfd_error_handler (msg, bfd_get_filename (ibfd),
				  bfd_get_filename (obfd));

	      bfd_set_error (bfd_error_wrong_format);
	      return false;
	    }
	  
	  if (PIC_FLAG (obfd) != PIC_FLAG (ibfd))
	    {
	      const char * msg;

	      if (PIC_FLAG (ibfd))
		/* xgettext: c-format */
		msg = _("%s: ERROR: compiled as position independent code, whereas target %s is absolute position");
	      else
		/* xgettext: c-format */
		msg = _("%s: ERROR: compiled as absolute position code, whereas target %s is position independent");
	      _bfd_error_handler (msg, bfd_get_filename (ibfd),
				  bfd_get_filename (obfd));

	      bfd_set_error (bfd_error_wrong_format);
	      return false;
	    }
	}
      else
	{
	  SET_APCS_FLAGS (obfd, APCS_26_FLAG (ibfd) | APCS_FLOAT_FLAG (ibfd) | PIC_FLAG (ibfd));
	  
	  /* Set up the arch and fields as well as these are probably wrong.  */
	  bfd_set_arch_mach (obfd, bfd_get_arch (ibfd), bfd_get_mach (ibfd));
	}
    }

  /* Check the interworking support.  */
  if (INTERWORK_SET (ibfd))
    {
      if (INTERWORK_SET (obfd))
	{
	  /* If the src and dest differ in their interworking issue a warning.  */
	  if (INTERWORK_FLAG (obfd) != INTERWORK_FLAG (ibfd))
	    {
	      const char * msg;

	      if (INTERWORK_FLAG (ibfd))
		/* xgettext: c-format */
		msg = _("Warning: input file %s supports interworking, whereas %s does not.");
	      else
		/* xgettext: c-format */
		msg = _("Warning: input file %s does not support interworking, whereas %s does.");
	      
	      _bfd_error_handler (msg, bfd_get_filename (ibfd),
				  bfd_get_filename (obfd));
	    }
	}
      else
	{
	  SET_INTERWORK_FLAG (obfd, INTERWORK_FLAG (ibfd));
	}
    }

  return true;
}


/* Display the flags field.  */

static boolean
coff_arm_print_private_bfd_data (abfd, ptr)
     bfd *   abfd;
     PTR     ptr;
{
  FILE * file = (FILE *) ptr;
  
  BFD_ASSERT (abfd != NULL && ptr != NULL);
  
  /* xgettext:c-format */
  fprintf (file, _("private flags = %x:"), coff_data (abfd)->flags);
  
  if (APCS_SET (abfd))
    {
      /* xgettext: APCS is ARM Prodecure Call Standard, it should not be translated.  */
      fprintf (file, " [APCS-%d]", APCS_26_FLAG (abfd) ? 26 : 32);

      if (APCS_FLOAT_FLAG (abfd))
	fprintf (file, _(" [floats passed in float registers]"));
      else
	fprintf (file, _(" [floats passed in integer registers]"));

      if (PIC_FLAG (abfd))
	fprintf (file, _(" [position independent]"));
      else
	fprintf (file, _(" [absolute position]"));
    }
  
  if (! INTERWORK_SET (abfd))
    fprintf (file, _(" [interworking flag not initialised]"));
  else if (INTERWORK_FLAG (abfd))
    fprintf (file, _(" [interworking supported]"));
  else
    fprintf (file, _(" [interworking not supported]"));
  
  fputc ('\n', file);
  
  return true;
}


/* Copies the given flags into the coff_tdata.flags field.
   Typically these flags come from the f_flags[] field of
   the COFF filehdr structure, which contains important,
   target specific information.
   Note: Although this function is static, it is explicitly
   called from both coffcode.h and peicode.h.  */

static boolean
_bfd_coff_arm_set_private_flags (abfd, flags)
	bfd *	   abfd;
	flagword   flags;
{
  flagword flag;

  BFD_ASSERT (abfd != NULL);

  flag = (flags & F_APCS26) ? F_APCS_26 : 0;
  
  /* Make sure that the APCS field has not been initialised to the opposite
     value.  */
  if (APCS_SET (abfd)
      && (   (APCS_26_FLAG    (abfd) != flag)
	  || (APCS_FLOAT_FLAG (abfd) != (flags & F_APCS_FLOAT))
	  || (PIC_FLAG        (abfd) != (flags & F_PIC))
	  ))
    return false;

  flag |= (flags & (F_APCS_FLOAT | F_PIC));
  
  SET_APCS_FLAGS (abfd, flag);

  flag = (flags & F_INTERWORK);
  
  /* If the BFD has already had its interworking flag set, but it
     is different from the value that we have been asked to set,
     then assume that that merged code will not support interworking
     and set the flag accordingly.  */
  if (INTERWORK_SET (abfd) && (INTERWORK_FLAG (abfd) != flag))
    {
      if (flag)
	/* xgettext: c-format */
	_bfd_error_handler (_("Warning: Not setting interworking flag of %s, since it has already been specified as non-interworking"),
			    bfd_get_filename (abfd));
      else
	/* xgettext: c-format */
	_bfd_error_handler (_("Warning: Clearing the interworking flag of %s due to outside request"),
			    bfd_get_filename (abfd));
      flag = 0;
    }

  SET_INTERWORK_FLAG (abfd, flag);

  return true;
}


/* Copy the important parts of the target specific data
   from one instance of a BFD to another.  */

static boolean
coff_arm_copy_private_bfd_data (src, dest)
     bfd *  src;
     bfd *  dest;
{
  BFD_ASSERT (src != NULL && dest != NULL);
 
  if (src == dest)
    return true;

  /* If the destination is not in the same format as the source, do not do
     the copy.  */
  if (src->xvec != dest->xvec)
    return true;

  /* copy the flags field */
  if (APCS_SET (src))
    {
      if (APCS_SET (dest))
	{
	  /* If the src and dest have different APCS flag bits set, fail.  */
	  if (APCS_26_FLAG (dest) != APCS_26_FLAG (src))
	    return false;
	  
	  if (APCS_FLOAT_FLAG (dest) != APCS_FLOAT_FLAG (src))
	    return false;
	  
	  if (PIC_FLAG (dest) != PIC_FLAG (src))
	    return false;
	}
      else
	SET_APCS_FLAGS (dest, APCS_26_FLAG (src) | APCS_FLOAT_FLAG (src)
			| PIC_FLAG (src));
    }

  if (INTERWORK_SET (src))
    {
      if (INTERWORK_SET (dest))
	{
	  /* If the src and dest have different interworking flags then turn
	     off the interworking bit.  */
	  if (INTERWORK_FLAG (dest) != INTERWORK_FLAG (src))
	    {
	      if (INTERWORK_FLAG (dest))
		{
		  /* xgettext:c-format */
		  _bfd_error_handler (("Warning: Clearing the interworking bit of %s, because the non-interworking code in %s has been copied into it"),
				      bfd_get_filename (dest),
				      bfd_get_filename (src));
		}
	      
	      SET_INTERWORK_FLAG (dest, 0);
	    }
	}
      else
	{
	  SET_INTERWORK_FLAG (dest, INTERWORK_FLAG (src));
	}
    }

  return true;
}

/* Note:  the definitions here of LOCAL_LABEL_PREFIX and USER_LABEL_PREIFX
 *must* match the definitions in gcc/config/arm/coff.h and semi.h */
#define LOCAL_LABEL_PREFIX "."
#ifndef USER_LABEL_PREFIX
#define USER_LABEL_PREFIX "_"
d560 7
d568 5
a572 89
/* Like _bfd_coff_is_local_label_name, but
   a) test against USER_LABEL_PREFIX, to avoid stripping labels known to be
      non-local.
   b) Allow other prefixes than ".", e.g. an empty prefix would cause all
      labels of the form Lxxx to be stripped.  */
static boolean
coff_arm_is_local_label_name (abfd, name)
     bfd *        abfd ATTRIBUTE_UNUSED;
     const char * name;
{
#ifdef USER_LABEL_PREFIX
  if (USER_LABEL_PREFIX[0] != 0)
    {
      if (strncmp (name, USER_LABEL_PREFIX, strlen (USER_LABEL_PREFIX)) == 0)
	return false;
    }
#endif

#ifdef LOCAL_LABEL_PREFIX
  /* If there is a prefix for local labels then look for this.
     If the prefix exists, but it is empty, then ignore the test. */
  
  if (LOCAL_LABEL_PREFIX[0] != 0)
    {
      int len = strlen (LOCAL_LABEL_PREFIX);
      
      if (strncmp (name, LOCAL_LABEL_PREFIX, len) != 0)
	return false;
      
      /* Perform the checks below for the rest of the name.  */
      name += len;
    }
#endif
  
  return name[0] == 'L';
}

/* This piece of machinery exists only to guarantee that the bfd that holds
   the glue section is written last. 

   This does depend on bfd_make_section attaching a new section to the
   end of the section list for the bfd. 

   krk@@cygnus.com  */

static boolean
coff_arm_link_output_has_begun (sub, info)
     bfd * sub;
     struct coff_final_link_info * info;
{
  return (sub->output_has_begun
	  || sub == coff_arm_hash_table (info->info)->bfd_of_glue_owner);
}

static boolean
coff_arm_final_link_postscript (abfd, pfinfo)
     bfd * abfd ATTRIBUTE_UNUSED;
     struct coff_final_link_info * pfinfo;
{
  struct coff_arm_link_hash_table * globals;

  globals = coff_arm_hash_table (pfinfo->info);
  
  BFD_ASSERT (globals != NULL);
  
  if (globals->bfd_of_glue_owner != NULL)
    {
      if (! _bfd_coff_link_input_bfd (pfinfo, globals->bfd_of_glue_owner))
	return false;
      
      globals->bfd_of_glue_owner->output_has_begun = true;
    }
  
  return true;
}

#include "coffcode.h"

#ifndef TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM armcoff_little_vec
#endif
#ifndef TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME "coff-arm-little"
#endif
#ifndef TARGET_BIG_SYM
#define TARGET_BIG_SYM armcoff_big_vec
#endif
#ifndef TARGET_BIG_NAME
#define TARGET_BIG_NAME "coff-arm-big"
d575 2
a576 6
#ifndef TARGET_UNDERSCORE
#define TARGET_UNDERSCORE 0
#endif

#ifdef COFF_WITH_PE
#define EXTRA_S_FLAGS (SEC_LINK_ONCE | SEC_LINK_DUPLICATES)
d578 1
a578 1
#define EXTRA_S_FLAGS 0
d580 2
d583 24
a606 6
/* Forward declaration for use initialising alternative_target field.  */
extern const bfd_target TARGET_BIG_SYM ;

/* Target vectors.  */
CREATE_LITTLE_COFF_TARGET_VEC (TARGET_LITTLE_SYM, TARGET_LITTLE_NAME, D_PAGED, EXTRA_S_FLAGS, TARGET_UNDERSCORE, & TARGET_BIG_SYM)
CREATE_BIG_COFF_TARGET_VEC (TARGET_BIG_SYM, TARGET_BIG_NAME, D_PAGED, EXTRA_S_FLAGS, TARGET_UNDERSCORE, & TARGET_LITTLE_SYM)
d608 2
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
d54 1
a54 1

d60 1
d80 1
a80 1
static reloc_howto_type * coff_arm_rtype_to_howto
d122 1
a122 1

d129 1
a129 1
/* Used by the assembler.  */
d235 1
a235 1
static reloc_howto_type aoutarm_std_reloc_howto[] =
d240 1
a240 1
  HOWTO (ARM_32,
d242 1
a242 1
	2,
d253 1
a253 1
  HOWTO (ARM_RVA32,
d255 1
a255 1
	2,
d277 1
a277 1
	0x00ffffff,
d290 1
a290 1
	0x000007ff,
d292 2
a293 2
  HOWTO (ARM_26D,
	2,
d299 1
a299 1
	aoutarm_fix_pcrel_26_done,
d313 4
a316 4
  HOWTO (ARM_SECTION,
	0,
	1,
	16,
d321 1
a321 1
	"ARM_16",
d324 1
a324 1
	0x0000ffff,
d326 1
a326 1
  HOWTO (ARM_SECREL,
d328 1
a328 1
	2,
d353 4
a356 4
  HOWTO(ARM_16,
	0,
	1,
	16,
d361 1
a361 1
	"ARM_16",
d364 1
a364 1
	0x0000ffff,
d366 1
a366 1
  HOWTO(ARM_32,
d368 1
a368 1
	2,
d390 1
a390 1
	0x00ffffff,
d392 1
a392 1
  HOWTO(ARM_DISP8,
d395 1
a395 1
	8,
d398 1
a398 1
	complain_overflow_signed,
d400 1
a400 1
	"ARM_DISP8",
d405 1
a405 1
  HOWTO( ARM_DISP16,
d411 1
a411 1
	complain_overflow_signed,
d424 1
a424 1
	complain_overflow_signed,
d431 2
a432 2
  HOWTO( ARM_26D,
	2,
d438 1
a438 1
	aoutarm_fix_pcrel_26_done,
d451 1
a451 1
	0,
d455 1
a455 2
        true,
	0x0000ffff,
d457 1
d459 2
a460 2
  HOWTO( ARM_NEG32,
	0,
d472 1
a472 1
  HOWTO( ARM_RVA32,
d474 1
a474 1
	2,
d496 1
a496 1
	0x000000ff,
d509 1
a509 1
	0x000007ff,
d522 1
a522 1
	0x07ff07ff,
d531 1
a531 1
   appear in the output .reloc section.  */
d539 1
a539 1
}
d563 1
a563 1

d571 1
a571 1
/* Used by the assembler.  */
d588 1
a588 1
/* Used by the assembler.  */
d605 1
a605 1

d626 1
a626 1

d696 1
a696 1

d771 1
a771 1

d821 1
d828 1
a828 1

a849 1
      ASTD (BFD_RELOC_ARM_PCREL_BLX,        ARM_26);
d857 1
a857 2
      ASTD (BFD_RELOC_THUMB_PCREL_BLX,      ARM_THUMB23);
#endif
d877 1
a877 1

d880 1
a880 1

d887 1
a887 1
  /* Support interworking with old, non-interworking aware ARM code.  */
d942 1
a942 1
   can occur in any order. So given a thumb form of long branch, and an
d944 1
a944 1
   instruction.
d946 1
a946 1
   It takes two thumb instructions to encode the target address. Each has
d948 2
a949 2
   H-0.. see below), the lower 11 bits are stored in the other (identified
   by H-1).
d951 1
a951 1
   Combine together and shifted left by 1 (it's a half word address) and
d959 1
a959 1
   They can be ordered either way, but the arm tools I've seen always put
d979 1
d991 1
a991 1
    abort (); /* error - not a valid branch instruction form */
d997 1
d1014 1
a1014 1

d1017 1
a1017 1

d1022 1
a1022 1

d1043 1
a1043 1

d1051 1
a1051 1

d1088 1
a1088 1
					        .word	func
d1131 1
a1131 1
/* The standard COFF backend linker does not cope with the special
d1134 1
a1134 1
   bit simpler simply providing our own relocation driver.  */
d1182 1
a1182 1
	{
d1197 1
d1215 1
a1215 1
          static reloc_howto_type fake_arm26_reloc =
d1227 1
a1227 1
    	       0x00ffffff,
d1236 1
a1236 1
	 the next opcode's pc, so is off by one.  */
d1240 1
a1240 1

a1248 12
	  /* FIXME - it is not clear which targets need this next test
	     and which do not.  It is known that it is needed for the
	     VXworks target (hence the #ifdef), but it is also known
	     that it was supressed for other (arm) targets.  This ought
	     to be sorted out one day.  */
#ifdef VXWORKS
	  /* We must not ignore the symbol value.  If the symbol is
	     within the same section, the relocation should have already
	     been fixed, but if it is not, we'll be handed a reloc into
	     the beginning of the symbol's section, so we must not cancel
	     out the symbol's value, otherwise we'll be adding it in
	     twice.  */
a1250 1
#endif
d1280 1
a1280 1
	     for an undefined name...  */
d1287 1
a1287 1

d1303 1
a1303 1
		      struct coff_link_hash_entry *     myh;
d1305 1
a1305 1

d1314 1
a1314 1

d1316 2
a1317 2

		      s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
d1344 1
a1344 1

d1347 1
a1347 1

d1353 1
a1353 1
                            arm_emit_base_file_entry (info, output_bfd, s,
d1362 1
a1362 1

d1365 1
a1365 1
		      /* Somehow these are both 4 too far, so subtract 8.  */
d1368 1
a1368 1
			+ my_offset
d1371 1
a1371 1
			   + input_section->output_section->vma
d1376 1
a1376 1

d1382 1
a1382 1

d1387 1
a1387 1
                  if (   h->class == C_EXT
d1404 1
a1404 1

d1407 1
a1407 1

d1409 2
a1410 2

		      s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
d1412 1
a1412 1

d1416 1
a1416 1

d1435 1
a1435 1

d1443 1
a1443 1

d1452 1
a1452 1

d1455 1
a1455 1

d1458 1
a1458 1

d1470 1
a1470 1

d1473 1
a1473 1

d1482 1
a1482 1

d1500 1
a1500 1

d1508 1
a1508 1

d1514 1
a1514 1

d1517 1
a1517 1
             perform a direct link.  */
d1521 1
a1521 1
	  else
d1545 1
a1545 1
	  /* Emit a reloc if the backend thinks it needs it.  */
d1549 1
a1549 1

d1565 1
a1565 1

d1567 1
a1567 1

d1586 2
a1587 2

              /* howto->pc_relative should be TRUE for type 14 BRANCH23.  */
d1590 2
a1591 2

              /* howto->pcrel_offset should be TRUE for type 14 BRANCH23.  */
d1593 2
a1594 2

	      /* No need to negate the relocation with BRANCH23.  */
a1596 1

d1598 1
d1600 1
a1600 1

d1609 1
a1609 1

d1612 3
a1614 1
		add = (((x) & 0x07ff0000) >> 4) | (((x) & 0x7ff) << 1);
d1616 3
a1618 1
		add = ((((x) & 0x7ff) << 12) | (((x) & 0x07ff0000) >> 15));
d1628 1
d1630 1
a1630 1

d1633 1
a1633 2

	      /* howto->bitpos == 0 */
d1636 2
d1639 1
a1639 1
	      relocation   += signed_add;
d1647 3
a1649 12

	      /* For the BLX(1) instruction remove bit 0 of the adjusted offset.
		 Bit 0 can only be set if the upper insn is at a half-word boundary,
		 since the destination address, an ARM instruction, must always be
		 on a word boundary.  The semantics of the BLX (1) instruction,
		 however, are that bit 0 in the offset must always be 0, and the
		 corresponding bit 1 in the target address will be set from bit
		 1 of the source address.  */
	      if ((x & 0x18000000) == 0x08000000)
		relocation &= ~0x2;

	      /* Put the relocation into the correct bits.  */
d1651 3
a1653 1
		relocation = (((relocation & 0xffe) >> 1)  | ((relocation << 4) & 0x07ff0000));
d1655 5
a1659 3
		relocation = (((relocation & 0xffe) << 15) | ((relocation >> 12) & 0x7ff));

	      /* Add the relocation to the correct bits of X.  */
d1662 1
a1662 1
	      /* Put the relocated value back in the object file.  */
d1676 1
a1676 1
      /* FIXME:
d1685 1
a1685 1

d1687 1
a1687 1

d1712 2
a1713 2
#endif /* THUMBEXTENSION */

d1757 1
a1757 1
bfd_arm_allocate_interworking_sections (info)
d1768 1
a1768 1

d1774 1
a1774 1

d1779 1
a1779 1

d1785 1
a1785 1

d1793 1
a1793 1

d1798 1
a1798 1

d1804 1
a1804 1

d1839 1
a1839 1

d1842 1
a1842 1

d1854 1
a1854 1
				BSF_GLOBAL,
d1856 1
a1856 1
				NULL, true, false,
d1858 1
a1858 1

d1860 1
a1860 1

d1877 1
d1879 1
a1879 1

d1896 1
a1896 1

d1905 1
a1905 1
				NULL, true, false,
d1907 1
a1907 1

d1914 1
a1914 1

d1917 1
a1917 1

d1919 1
a1919 1

d1921 1
a1921 1

d1925 1
a1925 1

d1929 1
a1929 1
				NULL, true, false,
d1932 2
a1933 2
  free (tmp_name);

d1951 1
a1951 1

d1956 1
a1956 1

d1958 1
a1958 1

d1963 1
a1963 1

d1965 2
a1966 2

  if (sec == NULL)
d1969 1
a1969 1

d1971 1
a1971 1

d1980 1
a1980 1
  if (sec == NULL)
d1983 1
a1983 1

d1985 1
a1985 1

d1991 1
a1991 1

d1994 1
a1994 1

d2011 1
a2011 1

d2018 1
a2018 1

d2023 1
a2023 1

d2035 1
a2035 1
      if (sec->reloc_count == 0)
d2039 2
a2040 2
      /* FIXME: there may be a storage leak here.  */

d2042 1
a2042 1

d2045 1
a2045 1
      for (rel = i; rel < i + sec->reloc_count; ++rel)
d2053 1
a2053 1
	  /* If the relocation is not against a symbol it cannot concern us.  */
d2064 1
a2064 1

d2078 1
a2078 1

d2082 1
a2082 1

d2105 1
a2105 1

d2129 1
d2197 1
a2197 1

d2208 1
a2208 1

d2215 1
a2215 1

d2236 1
a2236 1

d2258 1
a2258 1

d2272 1
d2281 1
a2281 1

d2283 1
a2283 1

d2286 1
a2286 1

d2302 1
a2302 1

d2309 1
a2309 1

d2311 1
a2311 1

d2315 1
d2333 1
a2333 1

d2344 1
a2344 1

d2348 1
a2348 1

d2371 1
d2381 1
a2381 1

d2398 1
a2398 1

d2401 1
a2401 1

d2425 1
a2425 1

d2439 2
a2440 2
   *must* match the definitions in gcc/config/arm/{coff|semi|aout}.h.  */
#define LOCAL_LABEL_PREFIX ""
d2465 2
a2466 2
     If the prefix exists, but it is empty, then ignore the test.  */

d2470 1
a2470 1

d2473 1
a2473 1

d2478 1
a2478 1

d2483 1
a2483 1
   the glue section is written last.
d2486 1
a2486 1
   end of the section list for the bfd.
d2507 1
a2507 1

d2509 1
a2509 1

d2514 1
a2514 1

d2517 1
a2517 1

a2539 1
#ifndef EXTRA_S_FLAGS
a2544 1
#endif
d2552 1
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2000, 2001, 2002
d39 12
a50 33
#define APCS_26_FLAG(abfd) \
  (coff_data (abfd)->flags & F_APCS_26)

#define APCS_FLOAT_FLAG(abfd) \
  (coff_data (abfd)->flags & F_APCS_FLOAT)

#define PIC_FLAG(abfd) \
  (coff_data (abfd)->flags & F_PIC)

#define APCS_SET(abfd) \
  (coff_data (abfd)->flags & F_APCS_SET)

#define SET_APCS_FLAGS(abfd, flgs) \
  do									\
    {									\
      coff_data (abfd)->flags &= ~(F_APCS_26 | F_APCS_FLOAT | F_PIC);	\
      coff_data (abfd)->flags |= (flgs) | F_APCS_SET;			\
    }									\
  while (0)

#define INTERWORK_FLAG(abfd) \
  (coff_data (abfd)->flags & F_INTERWORK)

#define INTERWORK_SET(abfd) \
  (coff_data (abfd)->flags & F_INTERWORK_SET)

#define SET_INTERWORK_FLAG(abfd, flg) \
  do									\
    {									\
      coff_data (abfd)->flags &= ~F_INTERWORK;				\
      coff_data (abfd)->flags |= (flg) | F_INTERWORK_SET;		\
    }									\
  while (0)
d62 1
a62 1
static bfd_boolean coff_arm_relocate_section
a68 1
#ifndef ARM_WINCE
d71 2
a74 5
static insn32 insert_thumb_branch
  PARAMS ((insn32, int));
#endif
static bfd_reloc_status_type coff_thumb_pcrel_12
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d77 1
a77 1
static bfd_boolean coff_arm_adjust_symndx
d79 1
a79 1
	   asection *, struct internal_reloc *,	bfd_boolean *));
d82 1
a82 2
	   struct coff_link_hash_entry *, struct internal_syment *,
	   bfd_vma *));
d86 1
a86 1
static const struct reloc_howto_struct * coff_arm_reloc_type_lookup
d90 2
d93 1
a93 1
  PARAMS ((struct bfd_link_info *, const char *, bfd *));
d95 1
a95 1
  PARAMS ((struct bfd_link_info *, const char *, bfd *));
a98 1
#ifndef ARM_WINCE
d102 1
a102 2
#endif
static bfd_boolean coff_arm_merge_private_bfd_data
d104 1
a104 1
static bfd_boolean coff_arm_print_private_bfd_data
d106 1
a106 1
static bfd_boolean _bfd_coff_arm_set_private_flags
d108 1
a108 1
static bfd_boolean coff_arm_copy_private_bfd_data
d110 1
a110 1
static bfd_boolean coff_arm_is_local_label_name
d112 1
a112 1
static bfd_boolean coff_arm_link_output_has_begun
d114 1
a114 1
static bfd_boolean coff_arm_final_link_postscript
a115 2
static void arm_emit_base_file_entry
  PARAMS ((struct bfd_link_info *, bfd *, asection *, bfd_vma));
d120 2
a121 1
   name can be changed. The only requirement is the %s be present.  */
a129 1

d147 2
a148 3
#define DOIT(x)							\
  x = ((x & ~howto->dst_mask)					\
       | (((x & howto->src_mask) + diff) & howto->dst_mask))
d169 1
a169 1
	      bfd_put_16 (abfd, (bfd_vma) x, addr);
d177 1
a177 1
	      bfd_put_32 (abfd, (bfd_vma) x, addr);
d198 1
a198 1
#define PCRELOFFSET TRUE
d236 2
a237 1
  {
d239 100
a338 100
    EMPTY_HOWTO (-1),
    HOWTO (ARM_32,
	   0,
	   2,
	   32,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_32",
	   TRUE,
	   0xffffffff,
	   0xffffffff,
	   PCRELOFFSET),
    HOWTO (ARM_RVA32,
	   0,
	   2,
	   32,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_RVA32",
	   TRUE,
	   0xffffffff,
	   0xffffffff,
	   PCRELOFFSET),
    HOWTO (ARM_26,
	   2,
	   2,
	   24,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   aoutarm_fix_pcrel_26 ,
	   "ARM_26",
	   FALSE,
	   0x00ffffff,
	   0x00ffffff,
	   PCRELOFFSET),
    HOWTO (ARM_THUMB12,
	   1,
	   1,
	   11,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_thumb_pcrel_12 ,
	   "ARM_THUMB12",
	   FALSE,
	   0x000007ff,
	   0x000007ff,
	   PCRELOFFSET),
    HOWTO (ARM_26D,
	   2,
	   2,
	   24,
	   FALSE,
	   0,
	   complain_overflow_dont,
	   aoutarm_fix_pcrel_26_done,
	   "ARM_26D",
	   TRUE,
	   0x00ffffff,
	   0x0,
	   FALSE),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    HOWTO (ARM_SECTION,
	   0,
	   1,
	   16,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_16",
	   TRUE,
	   0x0000ffff,
	   0x0000ffff,
	   PCRELOFFSET),
    HOWTO (ARM_SECREL,
	   0,
	   2,
	   32,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_32",
	   TRUE,
	   0xffffffff,
	   0xffffffff,
	   PCRELOFFSET),
d340 184
a523 184
    HOWTO (ARM_8,		/* type */
	   0,			/* rightshift */
	   0,			/* size */
	   8,			/* bitsize */
	   FALSE,		/* pc_relative */
	   0,			/* bitpos */
	   complain_overflow_bitfield, /* complain_on_overflow */
	   coff_arm_reloc,	/* special_function */
	   "ARM_8",		/* name */
	   TRUE,		/* partial_inplace */
	   0x000000ff,		/* src_mask */
	   0x000000ff,		/* dst_mask */
	   PCRELOFFSET		/* pcrel_offset */),
    HOWTO (ARM_16,
	   0,
	   1,
	   16,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_16",
	   TRUE,
	   0x0000ffff,
	   0x0000ffff,
	   PCRELOFFSET),
    HOWTO (ARM_32,
	   0,
	   2,
	   32,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_32",
	   TRUE,
	   0xffffffff,
	   0xffffffff,
	   PCRELOFFSET),
    HOWTO (ARM_26,
	   2,
	   2,
	   24,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   aoutarm_fix_pcrel_26 ,
	   "ARM_26",
	   FALSE,
	   0x00ffffff,
	   0x00ffffff,
	   PCRELOFFSET),
    HOWTO (ARM_DISP8,
	   0,
	   0,
	   8,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_arm_reloc,
	   "ARM_DISP8",
	   TRUE,
	   0x000000ff,
	   0x000000ff,
	   TRUE),
    HOWTO (ARM_DISP16,
	   0,
	   1,
	   16,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_arm_reloc,
	   "ARM_DISP16",
	   TRUE,
	   0x0000ffff,
	   0x0000ffff,
	   TRUE),
    HOWTO (ARM_DISP32,
	   0,
	   2,
	   32,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_arm_reloc,
	   "ARM_DISP32",
	   TRUE,
	   0xffffffff,
	   0xffffffff,
	   TRUE),
    HOWTO (ARM_26D,
	   2,
	   2,
	   24,
	   FALSE,
	   0,
	   complain_overflow_dont,
	   aoutarm_fix_pcrel_26_done,
	   "ARM_26D",
	   TRUE,
	   0x00ffffff,
	   0x0,
	   FALSE),
    /* 8 is unused */
    EMPTY_HOWTO (-1),
    HOWTO (ARM_NEG16,
	   0,
	   -1,
	   16,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_NEG16",
	   TRUE,
	   0x0000ffff,
	   0x0000ffff,
	   FALSE),
    HOWTO (ARM_NEG32,
	   0,
	   -2,
	   32,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_NEG32",
	   TRUE,
	   0xffffffff,
	   0xffffffff,
	   FALSE),
    HOWTO (ARM_RVA32,
	   0,
	   2,
	   32,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_RVA32",
	   TRUE,
	   0xffffffff,
	   0xffffffff,
	   PCRELOFFSET),
    HOWTO (ARM_THUMB9,
	   1,
	   1,
	   8,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_thumb_pcrel_9 ,
	   "ARM_THUMB9",
	   FALSE,
	   0x000000ff,
	   0x000000ff,
	   PCRELOFFSET),
    HOWTO (ARM_THUMB12,
	   1,
	   1,
	   11,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_thumb_pcrel_12 ,
	   "ARM_THUMB12",
	   FALSE,
	   0x000007ff,
	   0x000007ff,
	   PCRELOFFSET),
    HOWTO (ARM_THUMB23,
	   1,
	   2,
	   22,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_thumb_pcrel_23 ,
	   "ARM_THUMB23",
	   FALSE,
	   0x07ff07ff,
	   0x07ff07ff,
	   PCRELOFFSET)
d525 1
a525 1
  };
d530 1
a530 2
static bfd_boolean in_reloc_p PARAMS ((bfd *, reloc_howto_type *));
/* Return TRUE if this relocation should
d533 1
a533 1
static bfd_boolean
a570 1

d606 1
a606 1
  /* If this is an undefined symbol, return error.  */
d618 1
a618 1
  relocation = (relocation ^ 0x02000000) - 0x02000000; /* Sign extend.  */
d630 1
a630 1
  /* Check for overflow.  */
d636 1
a636 1
  else if (relocation & ~(bfd_vma) 0x03ffffff)
d641 1
a641 1
  bfd_put_32 (abfd, (bfd_vma) target, (bfd_byte *) data + addr);
d697 1
a697 1
  /* If this is an undefined symbol, return error.  */
d726 1
a726 1
  relocation = (relocation ^ signbit) - signbit; /* Sign extend.  */
d738 1
a738 1
  /* Check for overflow.  */
d757 1
a757 2
       target |= (((relocation & 0xfff) >> 1)
		  | ((relocation << 4)  & 0x07ff0000));
d759 1
a759 2
       target |= (((relocation & 0xffe) << 15)
		  | ((relocation >> 12) & 0x7ff));
d766 1
a766 1
  bfd_put_32 (abfd, (bfd_vma) target, (bfd_byte *) data + addr);
d772 1
a772 1
  /* TODO: We should possibly have DONE entries for the THUMB PCREL relocations.  */
a775 1
#ifndef ARM_WINCE
d788 1
a788 2
                                  input_section, output_bfd, error_message,
				  b23);
d792 1
a792 1
coff_thumb_pcrel_9 (abfd, reloc_entry, symbol, data, input_section,
d803 1
a803 2
                                  input_section, output_bfd, error_message,
				  b9);
a804 1
#endif /* not ARM_WINCE */
d807 1
a807 1
coff_thumb_pcrel_12 (abfd, reloc_entry, symbol, data, input_section,
d818 1
a818 2
                                  input_section, output_bfd, error_message,
				  b12);
d821 1
a821 1
static const struct reloc_howto_struct *
d834 1
a834 2
      default:
	return (const struct reloc_howto_struct *) 0;
d859 1
a859 1
    default: return (const struct reloc_howto_struct *) 0;
a870 7
#ifndef ARM_WINCE
/* Make sure that the 'r_offset' field is copied properly
   so that identical binaries will compare the same.  */
#define SWAP_IN_RELOC_OFFSET	H_GET_32
#define SWAP_OUT_RELOC_OFFSET	H_PUT_32
#endif

d875 3
a877 3
  {
    /* The original coff_link_hash_table structure.  MUST be first field.  */
    struct coff_link_hash_table	root;
d879 2
a880 2
    /* The size in bytes of the section containg the Thumb-to-ARM glue.  */
    bfd_size_type		thumb_glue_size;
d882 2
a883 2
    /* The size in bytes of the section containg the ARM-to-Thumb glue.  */
    bfd_size_type		arm_glue_size;
d885 2
a886 2
    /* An arbitary input BFD chosen to hold the glue sections.  */
    bfd *			bfd_of_glue_owner;
d888 2
a889 2
    /* Support interworking with old, non-interworking aware ARM code.  */
    int 			support_old_code;
a902 1
  bfd_size_type amt = sizeof (struct coff_arm_link_hash_table);
d904 2
a905 1
  ret = (struct coff_arm_link_hash_table *) bfd_malloc (amt);
d912 1
a912 1
      free (ret);
d935 3
a937 3
  if (coff_data (output_bfd)->pe)
     addr -= pe_data (output_bfd)->pe_opthdr.ImageBase;
  fwrite (& addr, 1, sizeof (addr), (FILE *) info->base_file);
a940 1
#ifndef ARM_WINCE
d967 1
a967 1
   reverse.  nickc@@cygnus.com.  */
d991 3
a993 3
    /* FIXME: the BFD library should never abort except for internal errors
       - it should return an error status.  */
    abort (); /* Error - not a valid branch instruction form.  */
a996 1

d1000 3
a1002 3
     struct bfd_link_info *info;
     const char *name;
     bfd *input_bfd;
d1004 2
a1005 3
  char *tmp_name;
  struct coff_link_hash_entry *myh;
  bfd_size_type amt = strlen (name) + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1;
d1007 2
a1008 1
  tmp_name = (char *) bfd_malloc (amt);
d1015 1
a1015 1
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);
d1020 1
a1020 1
			bfd_archive_filename (input_bfd), tmp_name, name);
a1025 1
#endif /* not ARM_WINCE */
d1029 3
a1031 3
     struct bfd_link_info *info;
     const char *name;
     bfd *input_bfd;
d1033 1
a1033 1
  char *tmp_name;
a1034 1
  bfd_size_type amt = strlen (name) + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1;
d1036 2
a1037 1
  tmp_name = (char *) bfd_malloc (amt);
d1044 1
a1044 1
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);
d1049 1
a1049 1
			bfd_archive_filename (input_bfd), tmp_name, name);
d1143 1
a1143 1
static bfd_boolean
d1199 1
a1199 1
	return FALSE;
d1211 1
a1211 2
          && (h->root.u.def.section->output_section
	      == input_section->output_section))
d1218 1
a1218 1
    	       TRUE,
d1223 1
a1223 1
    	       FALSE,
d1226 1
a1226 1
    	       FALSE);
a1234 2
#if 0 /* This appears to have been true for WINCE 2.0, but it is not
	 true for WINCE 3.0.  */
a1237 1
#endif
d1249 4
a1252 4
	     VxWorks and EPOC-PE targets, but it is also known that it
	     was supressed for other ARM targets.  This ought to be
	     sorted out one day.  */
#ifdef ARM_COFF_BUGFIX
d1309 1
a1309 1
		      /* Arm code calling a Thumb function.  */
d1311 1
a1311 1
		      bfd_vma                           my_offset;
d1319 1
a1319 1
			return FALSE;
d1343 1
a1343 1
				 bfd_archive_filename (h_sec->owner), name);
d1347 1
a1347 1
				 bfd_archive_filename (input_bfd));
d1353 1
a1353 1
			  bfd_put_32 (output_bfd, (bfd_vma) a2t1_ldr_insn,
d1356 1
a1356 1
			  bfd_put_32 (output_bfd, (bfd_vma) a2t2_bx_r12_insn,
d1365 1
a1365 1
                                                      my_offset + 8);
d1388 2
a1389 2
		      bfd_put_32 (output_bfd, (bfd_vma) tmp,
				  contents + rel->r_vaddr - input_section->vma);
d1395 1
a1395 1
	      /* Note: We used to check for ARM_THUMB9 and ARM_THUMB12.  */
d1404 1
a1404 1
		      bfd_vma                            my_offset;
d1412 1
a1412 1
			return FALSE;
d1438 1
a1438 1
				 bfd_archive_filename (h_sec->owner), name);
d1442 1
a1442 1
				 bfd_archive_filename (input_bfd));
d1452 1
a1452 1
			      bfd_put_16 (output_bfd, (bfd_vma) t2a1_push_insn,
d1455 1
a1455 1
			      bfd_put_16 (output_bfd, (bfd_vma) t2a2_ldr_insn,
d1458 1
a1458 1
			      bfd_put_16 (output_bfd, (bfd_vma) t2a3_mov_insn,
d1461 1
a1461 1
			      bfd_put_16 (output_bfd, (bfd_vma) t2a4_bx_insn,
d1464 1
a1464 1
			      bfd_put_32 (output_bfd, (bfd_vma) t2a5_pop_insn,
d1467 1
a1467 1
			      bfd_put_32 (output_bfd, (bfd_vma) t2a6_bx_insn,
d1475 1
a1475 2
                                arm_emit_base_file_entry (info, output_bfd, s,
							  my_offset + 16);
d1479 1
a1479 1
			      bfd_put_16 (output_bfd, (bfd_vma) t2a1_bx_pc_insn,
d1482 1
a1482 1
			      bfd_put_16 (output_bfd, (bfd_vma) t2a2_noop_insn,
d1486 1
a1486 1
				((bfd_signed_vma) h_val)	/* Address of destination of the stub.  */
d1495 1
a1495 1
					  (bfd_vma) t2a3_b_insn | ((ret_offset >> 2) & 0x00FFFFFF),
d1516 3
a1518 3
				  (bfd_vma) insert_thumb_branch (tmp,
								 ret_offset),
				  contents + rel->r_vaddr - input_section->vma);
d1549 2
a1550 2
		      rel->r_vaddr - input_section->vma, TRUE)))
		return FALSE;
d1558 1
a1558 2
            arm_emit_base_file_entry (info, output_bfd, input_section,
				      rel->r_vaddr);
d1583 12
a1594 12
              bfd_vma relocation = val + addend;
	      int size = bfd_get_reloc_size (howto);
	      bfd_boolean overflow = FALSE;
	      bfd_byte *location = contents + address;
	      bfd_vma x = bfd_get_32 (input_bfd, location);
	      bfd_vma src_mask = 0x007FFFFE;
	      bfd_signed_vma reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;
	      bfd_signed_vma reloc_signed_min = ~reloc_signed_max;
	      bfd_vma check;
	      bfd_signed_vma signed_check;
	      bfd_vma add;
	      bfd_signed_vma signed_add;
d1651 11
a1661 1
		overflow = TRUE;
d1663 1
a1663 5
	      /* Put the relocation into the correct bits.
		 For a BLX instruction, make sure that the relocation is rounded up
		 to a word boundary.  This follows the semantics of the instruction
		 which specifies that bit 1 of the target address will come from bit
		 1 of the base address.  */
d1665 1
a1665 5
	        {
		  if ((x & 0x1800) == 0x0800 && (relocation & 0x02))
		    relocation += 2;
		  relocation = (((relocation & 0xffe) >> 1)  | ((relocation << 4) & 0x07ff0000));
		}
d1667 1
a1667 5
	        {
		  if ((x & 0x18000000) == 0x08000000 && (relocation & 0x02))
		    relocation += 2;
		  relocation = (((relocation & 0xffe) << 15) | ((relocation >> 12) & 0x7ff));
		}
d1696 1
a1696 1
	  int patchit = FALSE;
d1702 1
a1702 1
	      patchit = TRUE;
d1711 1
a1711 1
		patchit = TRUE;
d1733 1
a1733 1
	     bfd_archive_filename (input_bfd),
d1736 1
a1736 1
	  return FALSE;
d1750 1
a1750 1
		  return FALSE;
d1756 1
a1756 1
	      return FALSE;
d1761 1
a1761 1
  return TRUE;
d1766 1
a1766 1
bfd_boolean
d1790 2
a1791 2
      foo = (bfd_byte *) bfd_alloc (globals->bfd_of_glue_owner,
				    globals->arm_glue_size);
d1793 1
a1793 1
      memset (foo, test_char, (size_t) globals->arm_glue_size);
d1809 2
a1810 2
      foo = (bfd_byte *) bfd_alloc (globals->bfd_of_glue_owner,
				    globals->thumb_glue_size);
d1812 1
a1812 1
      memset (foo, test_char, (size_t) globals->thumb_glue_size);
d1819 1
a1819 1
  return TRUE;
a1830 1
  struct bfd_link_hash_entry *      bh;
a1831 2
  bfd_vma val;
  bfd_size_type amt;
d1843 2
a1844 2
  amt = strlen (name) + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1;
  tmp_name = (char *) bfd_malloc (amt);
d1851 1
a1851 1
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);
a1862 2
  bh = NULL;
  val = globals->arm_glue_size + 1;
d1864 4
a1867 1
				BSF_GLOBAL, s, val, NULL, TRUE, FALSE, &bh);
a1875 1
#ifndef ARM_WINCE
a1884 1
  struct bfd_link_hash_entry *       bh;
a1885 2
  bfd_vma val;
  bfd_size_type amt;
d1897 1
a1897 2
  amt = strlen (name) + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1;
  tmp_name = (char *) bfd_malloc (amt);
d1904 1
a1904 1
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);
a1911 2
  bh = NULL;
  val = globals->thumb_glue_size + 1;
d1913 3
a1915 1
				BSF_GLOBAL, s, val, NULL, TRUE, FALSE, &bh);
a1917 1
  myh = (struct coff_link_hash_entry *) bh;
d1927 1
a1927 2
  amt = strlen (name) + strlen (CHANGE_TO_ARM) + 1;
  tmp_name = (char *) bfd_malloc (amt);
d1933 2
a1934 2
  bh = NULL;
  val = globals->thumb_glue_size + (globals->support_old_code ? 8 : 4);
d1936 4
a1939 1
				BSF_LOCAL, s, val, NULL, TRUE, FALSE, &bh);
a1946 1
#endif /* not ARM_WINCE */
d1952 1
a1952 1
bfd_boolean
d1964 1
a1964 1
    return TRUE;
d1971 1
a1971 1
    return TRUE;
d1984 1
a1984 1
	return FALSE;
d1998 1
a1998 1
	return FALSE;
d2004 1
a2004 1
  return TRUE;
d2007 1
a2007 1
bfd_boolean
d2019 1
a2019 1
    return TRUE;
d2037 1
a2037 1
    return TRUE;
d2070 1
a2070 1
				  bfd_archive_filename (abfd), symndx);
d2121 1
a2121 1
  return TRUE;
d2141 1
a2141 1
static bfd_boolean
d2148 1
a2148 1
     bfd_boolean *adjustedp;
d2161 2
a2162 2
  *adjustedp = FALSE;
  return TRUE;
d2170 1
a2170 1
static bfd_boolean
d2178 1
a2178 1
    return TRUE;
d2185 1
a2185 6
    return TRUE;

  /* Determine what should happen if the input ARM architecture
     does not match the output ARM architecture.  */
  if (! bfd_arm_merge_machines (ibfd, obfd))
    return FALSE;
d2187 1
a2187 1
  /* Verify that the APCS is the same for the two BFDs.  */
d2197 2
a2198 2
		(_("ERROR: %s is compiled for APCS-%d, whereas %s is compiled for APCS-%d"),
		 bfd_archive_filename (ibfd), APCS_26_FLAG (ibfd) ? 26 : 32,
d2203 1
a2203 1
	      return FALSE;
d2212 1
a2212 1
		msg = _("ERROR: %s passes floats in float registers, whereas %s passes them in integer registers");
d2215 1
a2215 1
		msg = _("ERROR: %s passes floats in integer registers, whereas %s passes them in float registers");
d2217 1
a2217 1
	      _bfd_error_handler (msg, bfd_archive_filename (ibfd),
d2221 1
a2221 1
	      return FALSE;
d2230 1
a2230 1
		msg = _("ERROR: %s is compiled as position independent code, whereas target %s is absolute position");
d2233 2
a2234 2
		msg = _("ERROR: %s is compiled as absolute position code, whereas target %s is position independent");
	      _bfd_error_handler (msg, bfd_archive_filename (ibfd),
d2238 1
a2238 1
	      return FALSE;
d2262 1
a2262 1
		msg = _("Warning: %s supports interworking, whereas %s does not");
d2265 1
a2265 1
		msg = _("Warning: %s does not support interworking, whereas %s does");
d2267 1
a2267 1
	      _bfd_error_handler (msg, bfd_archive_filename (ibfd),
d2277 1
a2277 1
  return TRUE;
d2282 1
a2282 1
static bfd_boolean
d2319 1
a2319 1
  return TRUE;
d2329 1
a2329 1
static bfd_boolean
d2347 1
a2347 1
    return FALSE;
d2363 2
a2364 2
	_bfd_error_handler (_("Warning: Not setting interworking flag of %s since it has already been specified as non-interworking"),
			    bfd_archive_filename (abfd));
d2368 1
a2368 1
			    bfd_archive_filename (abfd));
d2374 1
a2374 1
  return TRUE;
d2380 1
a2380 1
static bfd_boolean
d2388 1
a2388 1
    return TRUE;
d2393 1
a2393 1
    return TRUE;
d2402 1
a2402 1
	    return FALSE;
d2405 1
a2405 1
	    return FALSE;
d2408 1
a2408 1
	    return FALSE;
d2426 1
a2426 2
		  _bfd_error_handler (("\
Warning: Clearing the interworking flag of %s because non-interworking code in %s has been linked with it"),
d2428 1
a2428 1
				      bfd_archive_filename (src));
d2440 1
a2440 1
  return TRUE;
d2455 1
a2455 1
static bfd_boolean
d2464 1
a2464 1
	return FALSE;
d2474 1
a2474 1
      size_t len = strlen (LOCAL_LABEL_PREFIX);
d2477 1
a2477 1
	return FALSE;
d2495 1
a2495 1
static bfd_boolean
d2504 1
a2504 1
static bfd_boolean
d2518 1
a2518 1
	return FALSE;
d2520 1
a2520 1
      globals->bfd_of_glue_owner->output_has_begun = TRUE;
d2523 1
a2523 1
  return bfd_arm_update_notes (abfd, ARM_NOTE_SECTION);
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a254 1
#define ARM_26D      0
d259 1
d267 1
a267 13
    HOWTO (ARM_26D,
	   2,
	   2,
	   24,
	   TRUE,
	   0,
	   complain_overflow_dont,
	   aoutarm_fix_pcrel_26_done,
	   "ARM_26D",
	   FALSE,
	   0x00ffffff,
	   0x0,
	   PCRELOFFSET),
d277 1
a277 1
	   FALSE,
d290 1
a290 1
	   FALSE,
d320 13
a332 1
    EMPTY_HOWTO (-1),
d349 2
a350 2
	   "ARM_SECTION",
	   FALSE,
d362 2
a363 2
	   "ARM_SECREL",
	   FALSE,
d924 1
a924 1
    /* The size in bytes of the section containing the Thumb-to-ARM glue.  */
d927 1
a927 1
    /* The size in bytes of the section containing the ARM-to-Thumb glue.  */
d930 1
a930 1
    /* An arbitrary input BFD chosen to hold the glue sections.  */
d994 1
a994 1
   11 bits to invest. The upper 11 bits are stored in one (identified by
d1250 2
a1251 2
         when doing a relocatable link.  However, we want to convert
         ARM_26 to ARM_26D relocs if possible.  We return a fake howto in
d1253 1
a1253 2
         compensate.  'partial_inplace' is also set, since we want 'done'
         relocations to be reflected in section's data.  */
d1256 1
a1256 1
          && info->relocatable
d1272 1
a1272 1
    	       TRUE,
a1277 5
#ifdef ARM_WINCE
          /* FIXME: I don't know why, but the hack is necessary for correct
                    generation of bl's instruction offset. */
          addend -= 8;
#endif
d1286 1
a1286 1
      if (howto->pc_relative && !info->relocatable)
d1291 1
a1291 1
      /* If we are doing a relocatable link, then we can just ignore
d1293 1
a1293 1
         have the correct value.  If this is not a relocatable link,
d1297 1
a1297 1
          if (info->relocatable)
d1302 1
a1302 1
	     was suppressed for other ARM targets.  This ought to be
d1344 1
a1344 1
          if (! info->relocatable
d1598 1
a1598 1
	  else if (! info->relocatable)
d1620 1
a1620 1
      else if (! info->relocatable
d1737 4
a1740 7
        if (info->relocatable && ! howto->partial_inplace)
            rstat = bfd_reloc_ok;
        else
	  rstat = _bfd_final_link_relocate (howto, input_bfd, input_section,
					    contents,
					    rel->r_vaddr - input_section->vma,
					    val, addend);
d1746 1
a1746 1
      if (! info->relocatable
d2026 1
a2026 1
  if (info->relocatable)
d2081 1
a2081 1
  if (info->relocatable)
d2201 2
a2202 2
/* When doing a relocatable link, we want to convert ARM_26 relocs
   into ARM_26D relocs.  */
d2213 1
a2213 1
  if (irel->r_type == ARM_26)
d2222 1
a2222 1
	irel->r_type = ARM_26D;
d2231 1
a2231 1
   targets, eg different CPUs or different APCS's.     */
d2364 1
a2364 1
      /* xgettext: APCS is ARM Procedure Call Standard, it should not be translated.  */
d2616 1
a2616 1
#define EXTRA_S_FLAGS (SEC_CODE | SEC_LINK_ONCE | SEC_LINK_DUPLICATES)
d2618 1
a2618 1
#define EXTRA_S_FLAGS SEC_CODE
d2626 2
a2627 2
CREATE_LITTLE_COFF_TARGET_VEC (TARGET_LITTLE_SYM, TARGET_LITTLE_NAME, D_PAGED, EXTRA_S_FLAGS, TARGET_UNDERSCORE, & TARGET_BIG_SYM, COFF_SWAP_TABLE)
CREATE_BIG_COFF_TARGET_VEC (TARGET_BIG_SYM, TARGET_BIG_NAME, D_PAGED, EXTRA_S_FLAGS, TARGET_UNDERSCORE, & TARGET_LITTLE_SYM, COFF_SWAP_TABLE)
@


