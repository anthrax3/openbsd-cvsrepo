head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.3
	OPENBSD_6_0:1.1.1.3.0.50
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.46
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.48
	OPENBSD_5_8_BASE:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.40
	OPENBSD_5_7_BASE:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.44
	OPENBSD_5_6_BASE:1.1.1.3
	OPENBSD_5_5:1.1.1.3.0.42
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.38
	OPENBSD_5_4_BASE:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.36
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.34
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.32
	OPENBSD_5_0:1.1.1.3.0.30
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.28
	OPENBSD_4_9_BASE:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.26
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.22
	OPENBSD_4_7_BASE:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.24
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.20
	OPENBSD_4_5_BASE:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.18
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.16
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.14
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.12
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.10
	OPENBSD_4_0_BASE:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	BINUTILS_2_15:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	BINUTILS-2_14:1.1.1.3
	OPENBSD_3_5:1.1.1.2.0.8
	OPENBSD_3_5_BASE:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.6
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.4
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.2
	OPENBSD_3_2_BASE:1.1.1.2
	binutils-2_11_2:1.1.1.2
	OPENBSD_3_1:1.1.1.1.0.8
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.6
	OPENBSD_3_0_BASE:1.1.1.1
	BINUTILS-2_10_1:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.4
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.2
	OPENBSD_2_8_BASE:1.1.1.1
	BINUTILS-2_10:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2000.09.12.14.45.35;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.09.12.14.45.35;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.05.13.13.22.27;	author fgsch;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.05.17.20.42.13;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* DWARF 1 find nearest line (_bfd_dwarf1_find_nearest_line).
   Copyright 1998, 1999 Free Software Foundation, Inc.

Written by Gavin Romig-Koch of Cygnus Solutions (gavin@@cygnus.com).  

This file is part of BFD.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "libiberty.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/dwarf.h"

/* dwarf1_debug is the starting point for all dwarf1 info. */

struct dwarf1_debug {

  /* The bfd we are working with. */
  bfd* abfd;

  /* List of already parsed compilation units. */
  struct dwarf1_unit* lastUnit;

  /* The buffer for the .debug section. 
     Zero indicates that the .debug section failed to load. */
  char* debug_section;

  /* Pointer to the end of the .debug_info section memory buffer. */
  char* debug_section_end;

  /* The buffer for the .line section. */
  char* line_section;

  /* End of that buffer. */
  char* line_section_end;

  /* The current or next unread die within the .debug section. */
  char* currentDie;
};

/* One dwarf1_unit for each parsed compilation unit die. */

struct dwarf1_unit {
  /* Linked starting from stash->lastUnit. */
  struct dwarf1_unit* prev;

  /* Name of the compilation unit. */
  char* name;

  /* The highest and lowest address used in the compilation unit. */
  unsigned long low_pc;
  unsigned long high_pc;

  /* Does this unit have a statement list? */
  int has_stmt_list;

  /* If any, the offset of the line number table in the .line section. */
  unsigned long stmt_list_offset;

  /* If non-zero, a pointer to the first child of this unit. */
  char* first_child;

  /* How many line entries? */
  unsigned long line_count;

  /* The decoded line number table (line_count entries). */
  struct linenumber* linenumber_table;

  /* The list of functions in this unit. */
  struct dwarf1_func* func_list;
};



/* One dwarf1_func for each parsed function die.  */

struct dwarf1_func {
  /* Linked starting from aUnit->func_list. */
  struct dwarf1_func* prev;
  
  /* Name of function. */
  char* name;
  
  /* The highest and lowest address used in the compilation unit. */
  unsigned long low_pc;
  unsigned long high_pc;
};


/* Used to return info about a parsed die. */
struct die_info {
  unsigned long length;
  unsigned long sibling;
  unsigned long low_pc;
  unsigned long high_pc;
  unsigned long stmt_list_offset;
  
  char* name; 
  
  int has_stmt_list;

  unsigned short tag;
};


/* Parsed line number information. */
struct linenumber {
  /* First address in the line. */
  unsigned long addr;

  /* The line number. */
  unsigned long linenumber;
};


/* Find the form of an attr, from the attr field. */
#define FORM_FROM_ATTR(attr)	((attr) & 0xF)	/* Implicitly specified */


/* Return a newly allocated dwarf1_unit.  It should be cleared and
   then attached into the 'stash' at 'stash->lastUnit'. */

static struct dwarf1_unit*
alloc_dwarf1_unit (stash)
  struct dwarf1_debug* stash;
{
  struct dwarf1_unit* x = 
    (struct dwarf1_unit*) bfd_zalloc (stash->abfd, 
				      sizeof (struct dwarf1_unit));
  x->prev = stash->lastUnit;
  stash->lastUnit = x;

  return x;
}

/* Return a newly allocated dwarf1_func.  It must be cleared and
   attached into 'aUnit' at 'aUnit->func_list'. */

static struct dwarf1_func*
alloc_dwarf1_func (stash, aUnit)
     struct dwarf1_debug* stash;
     struct dwarf1_unit* aUnit;
{
  struct dwarf1_func* x = 
    (struct dwarf1_func*) bfd_zalloc (stash->abfd, 
				      sizeof (struct dwarf1_func));
  x->prev = aUnit->func_list;
  aUnit->func_list = x;
  
  return x;
}

/* parse_die - parse a Dwarf1 die.
   Parse the die starting at 'aDiePtr' into 'aDieInfo'.
   'abfd' must be the bfd from which the section that 'aDiePtr'
   points to was pulled from. 

   Return false if the die is invalidly formatted; true otherwise. */

static boolean
parse_die (abfd, aDieInfo, aDiePtr)
     bfd* abfd;
     struct die_info* aDieInfo;
     char*            aDiePtr;
{
  char* this_die = aDiePtr;
  char* xptr = this_die;

  memset (aDieInfo,0,sizeof(*aDieInfo));

  /* First comes the length. */
  aDieInfo->length = bfd_get_32 (abfd, xptr);
  xptr += 4;
  if (aDieInfo->length == 0)
    return false;
  if (aDieInfo->length < 6)
    {
      /* Just padding bytes. */
      aDieInfo->tag = TAG_padding;
      return true;
    }

  /* Then the tag. */
  aDieInfo->tag = bfd_get_16 (abfd, xptr);
  xptr += 2;
      
  /* Then the attributes. */
  while (xptr < (this_die + aDieInfo->length))
    {
      unsigned short attr;
      
      /* Parse the attribute based on its form.  This section 
         must handle all dwarf1 forms, but need only handle the
	 actual attributes that we care about. */

      attr = bfd_get_16 (abfd, xptr);
      xptr += 2;
      
      switch (FORM_FROM_ATTR (attr))
	{
	case FORM_DATA2:
	  xptr += 2;
	  break;
	case FORM_DATA4:
	case FORM_REF:
	  if (attr == AT_sibling)
	    aDieInfo->sibling = bfd_get_32 (abfd, xptr);
	  else if (attr == AT_stmt_list)
	    {
	      aDieInfo->stmt_list_offset = bfd_get_32 (abfd, xptr);
	      aDieInfo->has_stmt_list = 1;
	    }
	  xptr += 4;
	  break;
	case FORM_DATA8:
	  xptr += 8;
	  break;
	case FORM_ADDR:
	  if (attr == AT_low_pc)
	    aDieInfo->low_pc = bfd_get_32 (abfd, xptr);
	  else if (attr == AT_high_pc)
	    aDieInfo->high_pc = bfd_get_32 (abfd, xptr);
	  xptr += 4;
	  break;
	case FORM_BLOCK2:
	  xptr += 2 + bfd_get_16 (abfd, xptr);
	  break;
	case FORM_BLOCK4:
	  xptr += 4 + bfd_get_32 (abfd, xptr);
	  break;
	case FORM_STRING:
	  if (attr == AT_name)
	    aDieInfo->name = xptr;
	  xptr += strlen (xptr) + 1;
	  break;
	}
    }

  return true;
}

/* Parse a dwarf1 line number table for 'aUnit->stmt_list_offset'
   into 'aUnit->linenumber_table'.  Return false if an error 
   occurs; true otherwise. */
  
static boolean
parse_line_table (stash, aUnit)
  struct dwarf1_debug* stash;
  struct dwarf1_unit* aUnit;
{
  char* xptr;

  /* Load the ".line" section from the bfd if we haven't already. */ 
  if (stash->line_section == 0)
    {
      asection *msec;
      unsigned long size;
      
      msec = bfd_get_section_by_name (stash->abfd, ".line");
      if (! msec)
	return false;
	  
      size = bfd_get_section_size_before_reloc (msec);
      stash->line_section = (unsigned char*) bfd_alloc (stash->abfd, size);
      
      if (! stash->line_section)
	return false;

      if (! bfd_get_section_contents (stash->abfd, msec, stash->line_section, 0, size))
	{
	  stash->line_section = 0;
	  return false;
	}

      stash->line_section_end = stash->line_section + size;
    }

  xptr = stash->line_section + aUnit->stmt_list_offset;
  if (xptr < stash->line_section_end)
    {
      unsigned long eachLine;

      char* tblend;
      unsigned long base;

      /* First comes the length. */
      tblend = bfd_get_32 (stash->abfd, xptr) + xptr;
      xptr += 4;

      /* Then the base address for each address in the table. */
      base = bfd_get_32 (stash->abfd, xptr);
      xptr += 4;

      /* How many line entrys?
	 10 = 4 (line number) + 2 (pos in line) + 4 (address in line) */
      aUnit->line_count = (tblend - xptr) / 10;

      /* Allocate an array for the entries. */
      aUnit->linenumber_table = (struct linenumber*)
	bfd_alloc (stash->abfd, 
		   sizeof (struct linenumber) * aUnit->line_count);
	
      for (eachLine = 0; eachLine < aUnit->line_count; eachLine++)
	{
	  /* A line number. */
	  aUnit->linenumber_table[eachLine].linenumber
	    = bfd_get_32 (stash->abfd, xptr);
	  xptr += 4;

	  /* Skip the position within the line. */
	  xptr += 2;

	  /* And finally the address. */
	  aUnit->linenumber_table[eachLine].addr 
	    = base + bfd_get_32 (stash->abfd, xptr);
	  xptr += 4;
	}
    }

  return true;
}

/* Parse each function die in a compilation unit 'aUnit'.
   The first child die of 'aUnit' should be in 'aUnit->first_child',
   the result is placed in 'aUnit->func_list'.
   Return false if error; true otherwise. */

static boolean
parse_functions_in_unit (stash, aUnit)
     struct dwarf1_debug* stash;
     struct dwarf1_unit* aUnit;
{
  char* eachDie;

  if (aUnit->first_child)
    for (eachDie = aUnit->first_child;
	 eachDie < stash->debug_section_end;
	 )
      {
	struct die_info eachDieInfo;
	
	if (! parse_die (stash->abfd, &eachDieInfo, eachDie))
	  return false;
	
	if (eachDieInfo.tag == TAG_global_subroutine
	    || eachDieInfo.tag == TAG_subroutine
	    || eachDieInfo.tag == TAG_inlined_subroutine
	    || eachDieInfo.tag == TAG_entry_point)
	  {
	    struct dwarf1_func* aFunc = alloc_dwarf1_func (stash,aUnit);
	    
	    aFunc->name = eachDieInfo.name;
	    aFunc->low_pc = eachDieInfo.low_pc;
	    aFunc->high_pc = eachDieInfo.high_pc;
	  }
	
	/* Move to next sibling, if none, end loop */
	if (eachDieInfo.sibling)
	  eachDie = stash->debug_section + eachDieInfo.sibling;
	else
	  break;
      }
  
  return true;
}

/* Find the nearest line to 'addr' in 'aUnit'.
   Return whether we found the line (or a function) without error. */

static boolean
dwarf1_unit_find_nearest_line (stash, aUnit, addr, 
		       filename_ptr, functionname_ptr,
		       linenumber_ptr)
  struct dwarf1_debug* stash;
  struct dwarf1_unit* aUnit;
  unsigned long addr;
  const char **filename_ptr;
  const char **functionname_ptr;
  unsigned int *linenumber_ptr;
{
  int line_p = false;
  int func_p = false;

  if (aUnit->low_pc <= addr && addr < aUnit->high_pc)
    {
      if (aUnit->has_stmt_list)
	{
	  unsigned long i;
	  struct dwarf1_func* eachFunc;

	  if (! aUnit->linenumber_table)
	    {
	      if (! parse_line_table (stash, aUnit))
		return false;
	    }

	  if (! aUnit->func_list)
	    {
	      if (! parse_functions_in_unit (stash, aUnit))
		return false;
	    }

	  for (i = 0; i < aUnit->line_count; i++)
	    {
	      if (aUnit->linenumber_table[i].addr <= addr
		  && addr < aUnit->linenumber_table[i+1].addr)
		{
		  *filename_ptr = aUnit->name;
		  *linenumber_ptr = aUnit->linenumber_table[i].linenumber;
		  line_p = true;
		  break;
		}
	    }

	  for (eachFunc = aUnit->func_list; 
	       eachFunc; 
	       eachFunc = eachFunc->prev)
	    {
	      if (eachFunc->low_pc <= addr
		  && addr < eachFunc->high_pc)
		{
		  *functionname_ptr = eachFunc->name;
		  func_p = true;
		  break;
		}
	    }
	}
    }

  return line_p || func_p;
}




/* The DWARF 1 version of find_nearest line.
   Return true if the line is found without error. */

boolean
_bfd_dwarf1_find_nearest_line (abfd, section, symbols, offset,
                              filename_ptr, functionname_ptr, linenumber_ptr)
     bfd *abfd;
     asection *section;
     asymbol **symbols ATTRIBUTE_UNUSED;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *linenumber_ptr;
{
  struct dwarf1_debug *stash = elf_tdata (abfd)->dwarf1_find_line_info;

  struct dwarf1_unit* eachUnit;

  /* What address are we looking for? */
  bfd_vma addr = offset + section->vma;

  *filename_ptr = NULL;
  *functionname_ptr = NULL;
  *linenumber_ptr = 0;
  

  if (! stash)
    {
      asection *msec;
      unsigned long size;
      
      stash = elf_tdata (abfd)->dwarf1_find_line_info =
	(struct dwarf1_debug*) bfd_zalloc (abfd, sizeof (struct dwarf1_debug));
      
      if (! stash)
	return false;
      
      msec = bfd_get_section_by_name (abfd, ".debug");
      if (! msec)
	{
	  /* No dwarf1 info.  Note that at this point the stash
	     has been allocated, but contains zeros, this lets
	     future calls to this function fail quicker. */
	  return false;
	}

      size = bfd_get_section_size_before_reloc (msec);
      stash->debug_section = (unsigned char*) bfd_alloc (abfd, size);
      
      if (! stash->debug_section)
	return false;

      if (! bfd_get_section_contents (abfd, msec, stash->debug_section, 0, size))
	{
	  stash->debug_section = 0;
	  return false;
	}

      stash->debug_section_end = stash->debug_section + size;
      stash->currentDie = stash->debug_section;
      stash->abfd = abfd;
    }

  /* A null debug_section indicates that there was no dwarf1 info
     or that an error occured while setting up the stash. */

  if (! stash->debug_section)
    return false;
  

  /* Look at the previously parsed units to see if any contain
     the addr. */
  for (eachUnit = stash->lastUnit; eachUnit; eachUnit = eachUnit->prev)
    {
      if (eachUnit->low_pc <= addr && addr < eachUnit->high_pc)
	return dwarf1_unit_find_nearest_line (stash, eachUnit, addr,
					      filename_ptr, 
					      functionname_ptr, 
					      linenumber_ptr);
    }

  while (stash->currentDie < stash->debug_section_end)
    {
      struct die_info aDieInfo;

      if (! parse_die (stash->abfd, &aDieInfo, stash->currentDie))
	return false;
      
      if (aDieInfo.tag == TAG_compile_unit)
	{
	  struct dwarf1_unit* aUnit
	    = alloc_dwarf1_unit (stash);
	  
	  aUnit->name = aDieInfo.name;
	  aUnit->low_pc = aDieInfo.low_pc;
	  aUnit->high_pc = aDieInfo.high_pc;
	  aUnit->has_stmt_list = aDieInfo.has_stmt_list;
	  aUnit->stmt_list_offset = aDieInfo.stmt_list_offset;
	  
	  /* A die has a child if it's followed by a die that is
	     not it's sibling. */
	  if (aDieInfo.sibling 
	      && stash->currentDie + aDieInfo.length 
                    < stash->debug_section_end
	      && stash->currentDie + aDieInfo.length 
	            != stash->debug_section + aDieInfo.sibling)
	    aUnit->first_child = stash->currentDie + aDieInfo.length;
	  else
	    aUnit->first_child = 0;

	  if (aUnit->low_pc <= addr && addr < aUnit->high_pc)
	    return dwarf1_unit_find_nearest_line (stash, aUnit, addr, 
						  filename_ptr, 
						  functionname_ptr, 
						  linenumber_ptr);
	}
      
      if (aDieInfo.sibling != 0)
	stash->currentDie = stash->debug_section + aDieInfo.sibling;
      else
	stash->currentDie += aDieInfo.length;
    }

  return false;
}


/* EOF */
@


1.1.1.1
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@@


1.1.1.2
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000 Free Software Foundation, Inc.
d4 1
a4 1
Written by Gavin Romig-Koch of Cygnus Solutions (gavin@@cygnus.com).
d29 1
a29 1
/* dwarf1_debug is the starting point for all dwarf1 info.  */
d33 1
a33 1
  /* The bfd we are working with.  */
d36 1
a36 1
  /* List of already parsed compilation units.  */
d39 2
a40 2
  /* The buffer for the .debug section.
     Zero indicates that the .debug section failed to load.  */
d43 1
a43 1
  /* Pointer to the end of the .debug_info section memory buffer.  */
d46 1
a46 1
  /* The buffer for the .line section.  */
d49 1
a49 1
  /* End of that buffer.  */
d52 1
a52 1
  /* The current or next unread die within the .debug section.  */
d56 1
a56 1
/* One dwarf1_unit for each parsed compilation unit die.  */
d59 1
a59 1
  /* Linked starting from stash->lastUnit.  */
d62 1
a62 1
  /* Name of the compilation unit.  */
d65 1
a65 1
  /* The highest and lowest address used in the compilation unit.  */
d72 1
a72 1
  /* If any, the offset of the line number table in the .line section.  */
d75 1
a75 1
  /* If non-zero, a pointer to the first child of this unit.  */
d81 1
a81 1
  /* The decoded line number table (line_count entries).  */
d84 1
a84 1
  /* The list of functions in this unit.  */
d88 2
d93 1
a93 1
  /* Linked starting from aUnit->func_list.  */
d95 2
a96 2

  /* Name of function.  */
d98 2
a99 2

  /* The highest and lowest address used in the compilation unit.  */
d104 2
a105 1
/* Used to return info about a parsed die.  */
d112 3
a114 3

  char* name;

d120 2
a121 1
/* Parsed line number information.  */
d123 1
a123 1
  /* First address in the line.  */
d126 1
a126 1
  /* The line number.  */
d130 2
a131 1
/* Find the form of an attr, from the attr field.  */
d134 1
d136 1
a136 1
   then attached into the 'stash' at 'stash->lastUnit'.  */
d142 2
a143 2
  struct dwarf1_unit* x =
    (struct dwarf1_unit*) bfd_zalloc (stash->abfd,
d152 1
a152 1
   attached into 'aUnit' at 'aUnit->func_list'.  */
d159 2
a160 2
  struct dwarf1_func* x =
    (struct dwarf1_func*) bfd_zalloc (stash->abfd,
d164 1
a164 1

d171 1
a171 1
   points to was pulled from.
d173 1
a173 1
   Return false if the die is invalidly formatted; true otherwise.  */
d184 1
a184 1
  memset (aDieInfo,0,sizeof (*aDieInfo));
d186 2
a187 2
  /* First comes the length.  */
  aDieInfo->length = bfd_get_32 (abfd, (bfd_byte *) xptr);
d193 1
a193 1
      /* Just padding bytes.  */
d198 2
a199 2
  /* Then the tag.  */
  aDieInfo->tag = bfd_get_16 (abfd, (bfd_byte *) xptr);
d201 2
a202 2

  /* Then the attributes.  */
d206 2
a207 2

      /* Parse the attribute based on its form.  This section
d209 1
a209 1
	 actual attributes that we care about.  */
d211 1
a211 1
      attr = bfd_get_16 (abfd, (bfd_byte *) xptr);
d213 1
a213 1

d222 1
a222 1
	    aDieInfo->sibling = bfd_get_32 (abfd, (bfd_byte *) xptr);
d225 1
a225 1
	      aDieInfo->stmt_list_offset = bfd_get_32 (abfd, (bfd_byte *) xptr);
d235 1
a235 1
	    aDieInfo->low_pc = bfd_get_32 (abfd, (bfd_byte *) xptr);
d237 1
a237 1
	    aDieInfo->high_pc = bfd_get_32 (abfd, (bfd_byte *) xptr);
d241 1
a241 1
	  xptr += 2 + bfd_get_16 (abfd, (bfd_byte *) xptr);
d244 1
a244 1
	  xptr += 4 + bfd_get_32 (abfd, (bfd_byte *) xptr);
d258 3
a260 3
   into 'aUnit->linenumber_table'.  Return false if an error
   occurs; true otherwise.  */

d268 1
a268 1
  /* Load the ".line" section from the bfd if we haven't already.  */
d273 1
a273 1

d277 1
a277 1

d279 2
a280 2
      stash->line_section = (char *) bfd_alloc (stash->abfd, size);

d301 2
a302 2
      /* First comes the length.  */
      tblend = bfd_get_32 (stash->abfd, (bfd_byte *) xptr) + xptr;
d305 2
a306 2
      /* Then the base address for each address in the table.  */
      base = bfd_get_32 (stash->abfd, (bfd_byte *) xptr);
d313 3
a315 3
      /* Allocate an array for the entries.  */
      aUnit->linenumber_table = (struct linenumber *)
	bfd_alloc (stash->abfd,
d317 1
a317 1

d320 1
a320 1
	  /* A line number.  */
d322 1
a322 1
	    = bfd_get_32 (stash->abfd, (bfd_byte *) xptr);
d325 1
a325 1
	  /* Skip the position within the line.  */
d328 3
a330 3
	  /* And finally the address.  */
	  aUnit->linenumber_table[eachLine].addr
	    = base + bfd_get_32 (stash->abfd, (bfd_byte *) xptr);
d341 1
a341 1
   Return false if error; true otherwise.  */
d356 1
a356 1

d359 1
a359 1

d366 1
a366 1

d371 1
a371 1

d378 1
a378 1

d383 1
a383 1
   Return whether we found the line (or a function) without error.  */
d386 1
a386 1
dwarf1_unit_find_nearest_line (stash, aUnit, addr,
d430 2
a431 2
	  for (eachFunc = aUnit->func_list;
	       eachFunc;
d448 3
d452 1
a452 1
   Return true if the line is found without error.  */
d470 1
a470 1
  unsigned long addr = (unsigned long)(offset + section->vma);
d475 1
d481 1
a481 1

d484 1
a484 1

d487 1
a487 1

d493 1
a493 1
	     future calls to this function fail quicker.  */
d498 2
a499 2
      stash->debug_section = (char *) bfd_alloc (abfd, size);

d515 1
a515 1
     or that an error occured while setting up the stash.  */
d519 1
d522 1
a522 1
     the addr.  */
d527 2
a528 2
					      filename_ptr,
					      functionname_ptr,
d538 1
a538 1

d543 1
a543 1

d549 1
a549 1

d551 3
a553 3
	     not it's sibling.  */
	  if (aDieInfo.sibling
	      && stash->currentDie + aDieInfo.length
d555 1
a555 1
	      && stash->currentDie + aDieInfo.length
d562 3
a564 3
	    return dwarf1_unit_find_nearest_line (stash, aUnit, addr,
						  filename_ptr,
						  functionname_ptr,
d567 1
a567 1

d576 1
@


1.1.1.3
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
a128 14
static struct dwarf1_unit *alloc_dwarf1_unit
  PARAMS ((struct dwarf1_debug *));
static struct dwarf1_func *alloc_dwarf1_func
  PARAMS ((struct dwarf1_debug *, struct dwarf1_unit *));
static bfd_boolean parse_die
  PARAMS ((bfd *, struct die_info *, char *, char *));
static bfd_boolean parse_line_table
  PARAMS ((struct dwarf1_debug *, struct dwarf1_unit *));
static bfd_boolean parse_functions_in_unit
  PARAMS ((struct dwarf1_debug *, struct dwarf1_unit *));
static bfd_boolean dwarf1_unit_find_nearest_line
  PARAMS ((struct dwarf1_debug *, struct dwarf1_unit *, unsigned long,
	   const char **, const char **, unsigned int *));

d136 3
a138 3
  bfd_size_type amt = sizeof (struct dwarf1_unit);

  struct dwarf1_unit* x = (struct dwarf1_unit*) bfd_zalloc (stash->abfd, amt);
d153 3
a155 3
  bfd_size_type amt = sizeof (struct dwarf1_func);

  struct dwarf1_func* x = (struct dwarf1_func*) bfd_zalloc (stash->abfd, amt);
d167 1
a167 1
   Return FALSE if the die is invalidly formatted; TRUE otherwise.  */
d169 2
a170 2
static bfd_boolean
parse_die (abfd, aDieInfo, aDiePtr, aDiePtrEnd)
a173 1
     char*            aDiePtrEnd;
d183 2
a184 3
  if (aDieInfo->length == 0
      || (this_die + aDieInfo->length) >= aDiePtrEnd)
    return FALSE;
d189 1
a189 1
      return TRUE;
d248 1
a248 1
  return TRUE;
d252 2
a253 2
   into 'aUnit->linenumber_table'.  Return FALSE if an error
   occurs; TRUE otherwise.  */
d255 1
a255 1
static bfd_boolean
d266 1
a266 1
      bfd_size_type size;
d270 1
a270 1
	return FALSE;
d276 1
a276 1
	return FALSE;
d278 1
a278 2
      if (! bfd_get_section_contents (stash->abfd, msec, stash->line_section,
				      (bfd_vma) 0, size))
d281 1
a281 1
	  return FALSE;
d291 2
a292 1
      char *tblend;
a293 1
      bfd_size_type amt;
d308 3
a310 3
      amt = sizeof (struct linenumber) * aUnit->line_count;
      aUnit->linenumber_table = ((struct linenumber *)
				 bfd_alloc (stash->abfd, amt));
d329 1
a329 1
  return TRUE;
d335 1
a335 1
   Return FALSE if error; TRUE otherwise.  */
d337 1
a337 1
static bfd_boolean
d351 2
a352 3
	if (! parse_die (stash->abfd, &eachDieInfo, eachDie,
			 stash->debug_section_end))
	  return FALSE;
d373 1
a373 1
  return TRUE;
d379 1
a379 1
static bfd_boolean
d390 2
a391 2
  int line_p = FALSE;
  int func_p = FALSE;
d403 1
a403 1
		return FALSE;
d409 1
a409 1
		return FALSE;
d419 1
a419 1
		  line_p = TRUE;
d432 1
a432 1
		  func_p = TRUE;
d443 1
a443 1
   Return TRUE if the line is found without error.  */
d445 1
a445 1
bfd_boolean
d470 1
a470 1
      bfd_size_type size = sizeof (struct dwarf1_debug);
d472 2
a473 2
      stash = elf_tdata (abfd)->dwarf1_find_line_info
	= (struct dwarf1_debug *) bfd_zalloc (abfd, size);
d476 1
a476 1
	return FALSE;
d484 1
a484 1
	  return FALSE;
d491 1
a491 1
	return FALSE;
d493 1
a493 2
      if (! bfd_get_section_contents (abfd, msec, stash->debug_section,
				      (bfd_vma) 0, size))
d496 1
a496 1
	  return FALSE;
d508 1
a508 1
    return FALSE;
d525 2
a526 3
      if (! parse_die (stash->abfd, &aDieInfo, stash->currentDie,
		       stash->debug_section_end))
	return FALSE;
d563 1
a563 1
  return FALSE;
@


