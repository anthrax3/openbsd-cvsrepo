head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.50
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.52
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.11.02.20.45.04;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.20;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.29;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.09.22.29.24;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.07;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.18.59.35;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.43.25;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.29;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.29;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.04.58;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.37.06;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.18.00;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.45.25;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2001.06.09.22.06.35;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.20.48;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.10;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.14;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD back-end for Renesas H8/300 COFF binaries.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
   Written by Steve Chamberlain, <sac@@cygnus.com>.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "bfdlink.h"
#include "genlink.h"
#include "coff/h8300.h"
#include "coff/internal.h"
#include "libcoff.h"
#include "libiberty.h"

#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (1)

/* We derive a hash table from the basic BFD hash table to
   hold entries in the function vector.  Aside from the
   info stored by the basic hash table, we need the offset
   of a particular entry within the hash table as well as
   the offset where we'll add the next entry.  */

struct funcvec_hash_entry
  {
    /* The basic hash table entry.  */
    struct bfd_hash_entry root;

    /* The offset within the vectors section where
       this entry lives.  */
    bfd_vma offset;
  };

struct funcvec_hash_table
  {
    /* The basic hash table.  */
    struct bfd_hash_table root;

    bfd *abfd;

    /* Offset at which we'll add the next entry.  */
    unsigned int offset;
  };

static struct bfd_hash_entry *
funcvec_hash_newfunc
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);

static bfd_boolean
funcvec_hash_table_init
  (struct funcvec_hash_table *, bfd *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
			       struct bfd_hash_table *,
			       const char *));

static bfd_reloc_status_type special
  (bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **);
static int select_reloc
  (reloc_howto_type *);
static void rtype2howto
  (arelent *, struct internal_reloc *);
static void reloc_processing
  (arelent *, struct internal_reloc *, asymbol **, bfd *, asection *);
static bfd_boolean h8300_symbol_address_p
  (bfd *, asection *, bfd_vma);
static int h8300_reloc16_estimate
  (bfd *, asection *, arelent *, unsigned int,
   struct bfd_link_info *);
static void h8300_reloc16_extra_cases
  (bfd *, struct bfd_link_info *, struct bfd_link_order *, arelent *,
   bfd_byte *, unsigned int *, unsigned int *);
static bfd_boolean h8300_bfd_link_add_symbols
  (bfd *, struct bfd_link_info *);

/* To lookup a value in the function vector hash table.  */
#define funcvec_hash_lookup(table, string, create, copy) \
  ((struct funcvec_hash_entry *) \
   bfd_hash_lookup (&(table)->root, (string), (create), (copy)))

/* The derived h8300 COFF linker table.  Note it's derived from
   the generic linker hash table, not the COFF backend linker hash
   table!  We use this to attach additional data structures we
   need while linking on the h8300.  */
struct h8300_coff_link_hash_table {
  /* The main hash table.  */
  struct generic_link_hash_table root;

  /* Section for the vectors table.  This gets attached to a
     random input bfd, we keep it here for easy access.  */
  asection *vectors_sec;

  /* Hash table of the functions we need to enter into the function
     vector.  */
  struct funcvec_hash_table *funcvec_hash_table;
};

static struct bfd_link_hash_table *h8300_coff_link_hash_table_create (bfd *);

/* Get the H8/300 COFF linker hash table from a link_info structure.  */

#define h8300_coff_hash_table(p) \
  ((struct h8300_coff_link_hash_table *) ((coff_hash_table (p))))

/* Initialize fields within a funcvec hash table entry.  Called whenever
   a new entry is added to the funcvec hash table.  */

static struct bfd_hash_entry *
funcvec_hash_newfunc (struct bfd_hash_entry *entry,
		      struct bfd_hash_table *gen_table,
		      const char *string)
{
  struct funcvec_hash_entry *ret;
  struct funcvec_hash_table *table;

  ret = (struct funcvec_hash_entry *) entry;
  table = (struct funcvec_hash_table *) gen_table;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = ((struct funcvec_hash_entry *)
	   bfd_hash_allocate (gen_table,
			      sizeof (struct funcvec_hash_entry)));
  if (ret == NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct funcvec_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, gen_table, string));

  if (ret == NULL)
    return NULL;

  /* Note where this entry will reside in the function vector table.  */
  ret->offset = table->offset;

  /* Bump the offset at which we store entries in the function
     vector.  We'd like to bump up the size of the vectors section,
     but it's not easily available here.  */
 switch (bfd_get_mach (table->abfd))
   {
   case bfd_mach_h8300:
   case bfd_mach_h8300hn:
   case bfd_mach_h8300sn:
     table->offset += 2;
     break;
   case bfd_mach_h8300h:
   case bfd_mach_h8300s:
     table->offset += 4;
     break;
   default:
     return NULL;
   }

  /* Everything went OK.  */
  return (struct bfd_hash_entry *) ret;
}

/* Initialize the function vector hash table.  */

static bfd_boolean
funcvec_hash_table_init (struct funcvec_hash_table *table,
			 bfd *abfd,
			 struct bfd_hash_entry *(*newfunc)
			   (struct bfd_hash_entry *,
			    struct bfd_hash_table *,
			    const char *))
{
  /* Initialize our local fields, then call the generic initialization
     routine.  */
  table->offset = 0;
  table->abfd = abfd;
  return (bfd_hash_table_init (&table->root, newfunc));
}

/* Create the derived linker hash table.  We use a derived hash table
   basically to hold "static" information during an H8/300 coff link
   without using static variables.  */

static struct bfd_link_hash_table *
h8300_coff_link_hash_table_create (bfd *abfd)
{
  struct h8300_coff_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct h8300_coff_link_hash_table);

  ret = (struct h8300_coff_link_hash_table *) bfd_malloc (amt);
  if (ret == NULL)
    return NULL;
  if (!_bfd_link_hash_table_init (&ret->root.root, abfd,
				  _bfd_generic_link_hash_newfunc))
    {
      free (ret);
      return NULL;
    }

  /* Initialize our data.  */
  ret->vectors_sec = NULL;
  ret->funcvec_hash_table = NULL;

  /* OK.  Everything's initialized, return the base pointer.  */
  return &ret->root.root;
}

/* Special handling for H8/300 relocs.
   We only come here for pcrel stuff and return normally if not an -r link.
   When doing -r, we can't do any arithmetic for the pcrel stuff, because
   the code in reloc.c assumes that we can manipulate the targets of
   the pcrel branches.  This isn't so, since the H8/300 can do relaxing,
   which means that the gap after the instruction may not be enough to
   contain the offset required for the branch, so we have to use only
   the addend until the final link.  */

static bfd_reloc_status_type
special (bfd *abfd ATTRIBUTE_UNUSED,
	 arelent *reloc_entry ATTRIBUTE_UNUSED,
	 asymbol *symbol ATTRIBUTE_UNUSED,
	 PTR data ATTRIBUTE_UNUSED,
	 asection *input_section ATTRIBUTE_UNUSED,
	 bfd *output_bfd,
	 char **error_message ATTRIBUTE_UNUSED)
{
  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  /* Adjust the reloc address to that in the output section.  */
  reloc_entry->address += input_section->output_offset;
  return bfd_reloc_ok;
}

static reloc_howto_type howto_table[] = {
  HOWTO (R_RELBYTE, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "8", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_RELWORD, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "16", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (R_RELLONG, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, special, "32", FALSE, 0xffffffff, 0xffffffff, FALSE),
  HOWTO (R_PCRBYTE, 0, 0, 8, TRUE, 0, complain_overflow_signed, special, "DISP8", FALSE, 0x000000ff, 0x000000ff, TRUE),
  HOWTO (R_PCRWORD, 0, 1, 16, TRUE, 0, complain_overflow_signed, special, "DISP16", FALSE, 0x0000ffff, 0x0000ffff, TRUE),
  HOWTO (R_PCRLONG, 0, 2, 32, TRUE, 0, complain_overflow_signed, special, "DISP32", FALSE, 0xffffffff, 0xffffffff, TRUE),
  HOWTO (R_MOV16B1, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "relaxable mov.b:16", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (R_MOV16B2, 0, 1, 8, FALSE, 0, complain_overflow_bitfield, special, "relaxed mov.b:16", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_JMP1, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "16/pcrel", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (R_JMP2, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "pcrecl/16", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_JMPL1, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, special, "24/pcrell", FALSE, 0x00ffffff, 0x00ffffff, FALSE),
  HOWTO (R_JMPL2, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "pc8/24", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_MOV24B1, 0, 1, 32, FALSE, 0, complain_overflow_bitfield, special, "relaxable mov.b:24", FALSE, 0xffffffff, 0xffffffff, FALSE),
  HOWTO (R_MOV24B2, 0, 1, 8, FALSE, 0, complain_overflow_bitfield, special, "relaxed mov.b:24", FALSE, 0x0000ffff, 0x0000ffff, FALSE),

  /* An indirect reference to a function.  This causes the function's address
     to be added to the function vector in lo-mem and puts the address of
     the function vector's entry in the jsr instruction.  */
  HOWTO (R_MEM_INDIRECT, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "8/indirect", FALSE, 0x000000ff, 0x000000ff, FALSE),

  /* Internal reloc for relaxing.  This is created when a 16-bit pc-relative
     branch is turned into an 8-bit pc-relative branch.  */
  HOWTO (R_PCRWORD_B, 0, 0, 8, TRUE, 0, complain_overflow_bitfield, special, "relaxed bCC:16", FALSE, 0x000000ff, 0x000000ff, FALSE),

  HOWTO (R_MOVL1, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,special, "32/24 relaxable move", FALSE, 0xffffffff, 0xffffffff, FALSE),

  HOWTO (R_MOVL2, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "32/24 relaxed move", FALSE, 0x0000ffff, 0x0000ffff, FALSE),

  HOWTO (R_BCC_INV, 0, 0, 8, TRUE, 0, complain_overflow_signed, special, "DISP8 inverted", FALSE, 0x000000ff, 0x000000ff, TRUE),

  HOWTO (R_JMP_DEL, 0, 0, 8, TRUE, 0, complain_overflow_signed, special, "Deleted jump", FALSE, 0x000000ff, 0x000000ff, TRUE),
};

/* Turn a howto into a reloc number.  */

#define SELECT_RELOC(x,howto) \
  { x.r_type = select_reloc (howto); }

#define BADMAG(x) (H8300BADMAG (x) && H8300HBADMAG (x) && H8300SBADMAG (x) \
				   && H8300HNBADMAG(x) && H8300SNBADMAG(x))
#define H8300 1			/* Customize coffcode.h  */
#define __A_MAGIC_SET__

/* Code to swap in the reloc.  */
#define SWAP_IN_RELOC_OFFSET	H_GET_32
#define SWAP_OUT_RELOC_OFFSET	H_PUT_32
#define SWAP_OUT_RELOC_EXTRA(abfd, src, dst) \
  dst->r_stuff[0] = 'S'; \
  dst->r_stuff[1] = 'C';

static int
select_reloc (reloc_howto_type *howto)
{
  return howto->type;
}

/* Code to turn a r_type into a howto ptr, uses the above howto table.  */

static void
rtype2howto (arelent *internal, struct internal_reloc *dst)
{
  switch (dst->r_type)
    {
    case R_RELBYTE:
      internal->howto = howto_table + 0;
      break;
    case R_RELWORD:
      internal->howto = howto_table + 1;
      break;
    case R_RELLONG:
      internal->howto = howto_table + 2;
      break;
    case R_PCRBYTE:
      internal->howto = howto_table + 3;
      break;
    case R_PCRWORD:
      internal->howto = howto_table + 4;
      break;
    case R_PCRLONG:
      internal->howto = howto_table + 5;
      break;
    case R_MOV16B1:
      internal->howto = howto_table + 6;
      break;
    case R_MOV16B2:
      internal->howto = howto_table + 7;
      break;
    case R_JMP1:
      internal->howto = howto_table + 8;
      break;
    case R_JMP2:
      internal->howto = howto_table + 9;
      break;
    case R_JMPL1:
      internal->howto = howto_table + 10;
      break;
    case R_JMPL2:
      internal->howto = howto_table + 11;
      break;
    case R_MOV24B1:
      internal->howto = howto_table + 12;
      break;
    case R_MOV24B2:
      internal->howto = howto_table + 13;
      break;
    case R_MEM_INDIRECT:
      internal->howto = howto_table + 14;
      break;
    case R_PCRWORD_B:
      internal->howto = howto_table + 15;
      break;
    case R_MOVL1:
      internal->howto = howto_table + 16;
      break;
    case R_MOVL2:
      internal->howto = howto_table + 17;
      break;
    case R_BCC_INV:
      internal->howto = howto_table + 18;
      break;
    case R_JMP_DEL:
      internal->howto = howto_table + 19;
      break;
    default:
      abort ();
      break;
    }
}

#define RTYPE2HOWTO(internal, relocentry) rtype2howto (internal, relocentry)

/* Perform any necessary magic to the addend in a reloc entry.  */

#define CALC_ADDEND(abfd, symbol, ext_reloc, cache_ptr) \
 cache_ptr->addend = ext_reloc.r_offset;

#define RELOC_PROCESSING(relent,reloc,symbols,abfd,section) \
 reloc_processing (relent, reloc, symbols, abfd, section)

static void
reloc_processing (arelent *relent, struct internal_reloc *reloc,
		  asymbol **symbols, bfd *abfd, asection *section)
{
  relent->address = reloc->r_vaddr;
  rtype2howto (relent, reloc);

  if (((int) reloc->r_symndx) > 0)
    relent->sym_ptr_ptr = symbols + obj_convert (abfd)[reloc->r_symndx];
  else
    relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;

  relent->addend = reloc->r_offset;

  relent->address -= section->vma;
#if 0
  relent->section = 0;
#endif
}

static bfd_boolean
h8300_symbol_address_p (bfd *abfd, asection *input_section, bfd_vma address)
{
  asymbol **s;

  s = _bfd_generic_link_get_symbols (abfd);
  BFD_ASSERT (s != (asymbol **) NULL);

  /* Search all the symbols for one in INPUT_SECTION with
     address ADDRESS.  */
  while (*s)
    {
      asymbol *p = *s;

      if (p->section == input_section
	  && (input_section->output_section->vma
	      + input_section->output_offset
	      + p->value) == address)
	return TRUE;
      s++;
    }
  return FALSE;
}

/* If RELOC represents a relaxable instruction/reloc, change it into
   the relaxed reloc, notify the linker that symbol addresses
   have changed (bfd_perform_slip) and return how much the current
   section has shrunk by.

   FIXME: Much of this code has knowledge of the ordering of entries
   in the howto table.  This needs to be fixed.  */

static int
h8300_reloc16_estimate (bfd *abfd, asection *input_section, arelent *reloc,
			unsigned int shrink, struct bfd_link_info *link_info)
{
  bfd_vma value;
  bfd_vma dot;
  bfd_vma gap;
  static asection *last_input_section = NULL;
  static arelent *last_reloc = NULL;

  /* The address of the thing to be relocated will have moved back by
     the size of the shrink - but we don't change reloc->address here,
     since we need it to know where the relocation lives in the source
     uncooked section.  */
  bfd_vma address = reloc->address - shrink;

  if (input_section != last_input_section)
    last_reloc = NULL;

  /* Only examine the relocs which might be relaxable.  */
  switch (reloc->howto->type)
    {
      /* This is the 16-/24-bit absolute branch which could become an
	 8-bit pc-relative branch.  */
    case R_JMP1:
    case R_JMPL1:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      /* Get the address of the next instruction (not the reloc).  */
      dot = (input_section->output_section->vma
	     + input_section->output_offset + address);

      /* Adjust for R_JMP1 vs R_JMPL1.  */
      dot += (reloc->howto->type == R_JMP1 ? 1 : 2);

      /* Compute the distance from this insn to the branch target.  */
      gap = value - dot;

      /* If the distance is within -128..+128 inclusive, then we can relax
	 this jump.  +128 is valid since the target will move two bytes
	 closer if we do relax this branch.  */
      if ((int) gap >= -128 && (int) gap <= 128)
	{
	  bfd_byte code;

	  if (!bfd_get_section_contents (abfd, input_section, & code,
					 reloc->address, 1))
	    break;
	  code = bfd_get_8 (abfd, & code);

	  /* It's possible we may be able to eliminate this branch entirely;
	     if the previous instruction is a branch around this instruction,
	     and there's no label at this instruction, then we can reverse
	     the condition on the previous branch and eliminate this jump.

	       original:			new:
		 bCC lab1			bCC' lab2
		 jmp lab2
		lab1:				lab1:

	     This saves 4 bytes instead of two, and should be relatively
	     common.

	     Only perform this optimisation for jumps (code 0x5a) not
	     subroutine calls, as otherwise it could transform:

			     mov.w   r0,r0
			     beq     .L1
			     jsr     @@_bar
		      .L1:   rts
		      _bar:  rts
	     into:
			     mov.w   r0,r0
			     bne     _bar
			     rts
		      _bar:  rts

	     which changes the call (jsr) into a branch (bne).  */
	  if (code == 0x5a
	      && gap <= 126
	      && last_reloc
	      && last_reloc->howto->type == R_PCRBYTE)
	    {
	      bfd_vma last_value;
	      last_value = bfd_coff_reloc16_get_value (last_reloc, link_info,
						       input_section) + 1;

	      if (last_value == dot + 2
		  && last_reloc->address + 1 == reloc->address
		  && !h8300_symbol_address_p (abfd, input_section, dot - 2))
		{
		  reloc->howto = howto_table + 19;
		  last_reloc->howto = howto_table + 18;
		  last_reloc->sym_ptr_ptr = reloc->sym_ptr_ptr;
		  last_reloc->addend = reloc->addend;
		  shrink += 4;
		  bfd_perform_slip (abfd, 4, input_section, address);
		  break;
		}
	    }

	  /* Change the reloc type.  */
	  reloc->howto = reloc->howto + 1;

	  /* This shrinks this section by two bytes.  */
	  shrink += 2;
	  bfd_perform_slip (abfd, 2, input_section, address);
	}
      break;

    /* This is the 16-bit pc-relative branch which could become an 8-bit
       pc-relative branch.  */
    case R_PCRWORD:
      /* Get the address of the target of this branch, add one to the value
	 because the addend field in PCrel jumps is off by -1.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section) + 1;

      /* Get the address of the next instruction if we were to relax.  */
      dot = input_section->output_section->vma +
	input_section->output_offset + address;

      /* Compute the distance from this insn to the branch target.  */
      gap = value - dot;

      /* If the distance is within -128..+128 inclusive, then we can relax
	 this jump.  +128 is valid since the target will move two bytes
	 closer if we do relax this branch.  */
      if ((int) gap >= -128 && (int) gap <= 128)
	{
	  /* Change the reloc type.  */
	  reloc->howto = howto_table + 15;

	  /* This shrinks this section by two bytes.  */
	  shrink += 2;
	  bfd_perform_slip (abfd, 2, input_section, address);
	}
      break;

    /* This is a 16-bit absolute address in a mov.b insn, which can
       become an 8-bit absolute address if it's in the right range.  */
    case R_MOV16B1:
      /* Get the address of the data referenced by this mov.b insn.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
      value = bfd_h8300_pad_address (abfd, value);

      /* If the address is in the top 256 bytes of the address space
	 then we can relax this instruction.  */
      if (value >= 0xffffff00u)
	{
	  /* Change the reloc type.  */
	  reloc->howto = reloc->howto + 1;

	  /* This shrinks this section by two bytes.  */
	  shrink += 2;
	  bfd_perform_slip (abfd, 2, input_section, address);
	}
      break;

    /* Similarly for a 24-bit absolute address in a mov.b.  Note that
       if we can't relax this into an 8-bit absolute, we'll fall through
       and try to relax it into a 16-bit absolute.  */
    case R_MOV24B1:
      /* Get the address of the data referenced by this mov.b insn.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
      value = bfd_h8300_pad_address (abfd, value);

      if (value >= 0xffffff00u)
	{
	  /* Change the reloc type.  */
	  reloc->howto = reloc->howto + 1;

	  /* This shrinks this section by four bytes.  */
	  shrink += 4;
	  bfd_perform_slip (abfd, 4, input_section, address);

	  /* Done with this reloc.  */
	  break;
	}

      /* FALLTHROUGH and try to turn the 24-/32-bit reloc into a 16-bit
	 reloc.  */

    /* This is a 24-/32-bit absolute address in a mov insn, which can
       become an 16-bit absolute address if it's in the right range.  */
    case R_MOVL1:
      /* Get the address of the data referenced by this mov insn.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
      value = bfd_h8300_pad_address (abfd, value);

      /* If the address is a sign-extended 16-bit value then we can
         relax this instruction.  */
      if (value <= 0x7fff || value >= 0xffff8000u)
	{
	  /* Change the reloc type.  */
	  reloc->howto = howto_table + 17;

	  /* This shrinks this section by two bytes.  */
	  shrink += 2;
	  bfd_perform_slip (abfd, 2, input_section, address);
	}
      break;

      /* No other reloc types represent relaxing opportunities.  */
    default:
      break;
    }

  last_reloc = reloc;
  last_input_section = input_section;
  return shrink;
}

/* Handle relocations for the H8/300, including relocs for relaxed
   instructions.

   FIXME: Not all relocations check for overflow!  */

static void
h8300_reloc16_extra_cases (bfd *abfd, struct bfd_link_info *link_info,
			   struct bfd_link_order *link_order, arelent *reloc,
			   bfd_byte *data, unsigned int *src_ptr,
			   unsigned int *dst_ptr)
{
  unsigned int src_address = *src_ptr;
  unsigned int dst_address = *dst_ptr;
  asection *input_section = link_order->u.indirect.section;
  bfd_vma value;
  bfd_vma dot;
  int gap, tmp;
  unsigned char temp_code;

  switch (reloc->howto->type)
    {
    /* Generic 8-bit pc-relative relocation.  */
    case R_PCRBYTE:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      dot = (link_order->offset
	     + dst_address
	     + link_order->u.indirect.section->output_section->vma);

      gap = value - dot;

      /* Sanity check.  */
      if (gap < -128 || gap > 126)
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}

      /* Everything looks OK.  Apply the relocation and update the
	 src/dst address appropriately.  */
      bfd_put_8 (abfd, gap, data + dst_address);
      dst_address++;
      src_address++;

      /* All done.  */
      break;

    /* Generic 16-bit pc-relative relocation.  */
    case R_PCRWORD:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      /* Get the address of the instruction (not the reloc).  */
      dot = (link_order->offset
	     + dst_address
	     + link_order->u.indirect.section->output_section->vma + 1);

      gap = value - dot;

      /* Sanity check.  */
      if (gap > 32766 || gap < -32768)
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}

      /* Everything looks OK.  Apply the relocation and update the
	 src/dst address appropriately.  */
      bfd_put_16 (abfd, (bfd_vma) gap, data + dst_address);
      dst_address += 2;
      src_address += 2;

      /* All done.  */
      break;

    /* Generic 8-bit absolute relocation.  */
    case R_RELBYTE:
      /* Get the address of the object referenced by this insn.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      bfd_put_8 (abfd, value & 0xff, data + dst_address);
      dst_address += 1;
      src_address += 1;

      /* All done.  */
      break;

    /* Various simple 16-bit absolute relocations.  */
    case R_MOV16B1:
    case R_JMP1:
    case R_RELWORD:
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
      bfd_put_16 (abfd, value, data + dst_address);
      dst_address += 2;
      src_address += 2;
      break;

    /* Various simple 24-/32-bit absolute relocations.  */
    case R_MOV24B1:
    case R_MOVL1:
    case R_RELLONG:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
      bfd_put_32 (abfd, value, data + dst_address);
      dst_address += 4;
      src_address += 4;
      break;

    /* Another 24-/32-bit absolute relocation.  */
    case R_JMPL1:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      value = ((value & 0x00ffffff)
	       | (bfd_get_32 (abfd, data + src_address) & 0xff000000));
      bfd_put_32 (abfd, value, data + dst_address);
      dst_address += 4;
      src_address += 4;
      break;

      /* This is a 24-/32-bit absolute address in one of the following
	 instructions:

	   "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	   "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", "ldc.w",
	   "stc.w" and "mov.[bwl]"

	 We may relax this into an 16-bit absolute address if it's in
	 the right range.  */
    case R_MOVL2:
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
      value = bfd_h8300_pad_address (abfd, value);

      /* Sanity check.  */
      if (value <= 0x7fff || value >= 0xffff8000u)
	{
	  /* Insert the 16-bit value into the proper location.  */
	  bfd_put_16 (abfd, value, data + dst_address);

	  /* Fix the opcode.  For all the instructions that belong to
	     this relaxation, we simply need to turn off bit 0x20 in
	     the previous byte.  */
	  data[dst_address - 1] &= ~0x20;
	  dst_address += 2;
	  src_address += 4;
	}
      else
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}
      break;

    /* A 16-bit absolute branch that is now an 8-bit pc-relative branch.  */
    case R_JMP2:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      /* Get the address of the next instruction.  */
      dot = (link_order->offset
	     + dst_address
	     + link_order->u.indirect.section->output_section->vma + 1);

      gap = value - dot;

      /* Sanity check.  */
      if (gap < -128 || gap > 126)
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}

      /* Now fix the instruction itself.  */
      switch (data[dst_address - 1])
	{
	case 0x5e:
	  /* jsr -> bsr */
	  bfd_put_8 (abfd, 0x55, data + dst_address - 1);
	  break;
	case 0x5a:
	  /* jmp -> bra */
	  bfd_put_8 (abfd, 0x40, data + dst_address - 1);
	  break;

	default:
	  abort ();
	}

      /* Write out the 8-bit value.  */
      bfd_put_8 (abfd, gap, data + dst_address);

      dst_address += 1;
      src_address += 3;

      break;

    /* A 16-bit pc-relative branch that is now an 8-bit pc-relative branch.  */
    case R_PCRWORD_B:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      /* Get the address of the instruction (not the reloc).  */
      dot = (link_order->offset
	     + dst_address
	     + link_order->u.indirect.section->output_section->vma - 1);

      gap = value - dot;

      /* Sanity check.  */
      if (gap < -128 || gap > 126)
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}

      /* Now fix the instruction.  */
      switch (data[dst_address - 2])
	{
	case 0x58:
	  /* bCC:16 -> bCC:8 */
	  /* Get the second byte of the original insn, which contains
	     the condition code.  */
	  tmp = data[dst_address - 1];

	  /* Compute the fisrt byte of the relaxed instruction.  The
	     original sequence 0x58 0xX0 is relaxed to 0x4X, where X
	     represents the condition code.  */
	  tmp &= 0xf0;
	  tmp >>= 4;
	  tmp |= 0x40;

	  /* Write it.  */
	  bfd_put_8 (abfd, tmp, data + dst_address - 2);
	  break;

	case 0x5c:
	  /* bsr:16 -> bsr:8 */
	  bfd_put_8 (abfd, 0x55, data + dst_address - 2);
	  break;

	default:
	  abort ();
	}

      /* Output the target.  */
      bfd_put_8 (abfd, gap, data + dst_address - 1);

      /* We don't advance dst_address -- the 8-bit reloc is applied at
	 dst_address - 1, so the next insn should begin at dst_address.  */
      src_address += 2;

      break;

    /* Similarly for a 24-bit absolute that is now 8 bits.  */
    case R_JMPL2:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      /* Get the address of the instruction (not the reloc).  */
      dot = (link_order->offset
	     + dst_address
	     + link_order->u.indirect.section->output_section->vma + 2);

      gap = value - dot;

      /* Fix the instruction.  */
      switch (data[src_address])
	{
	case 0x5e:
	  /* jsr -> bsr */
	  bfd_put_8 (abfd, 0x55, data + dst_address);
	  break;
	case 0x5a:
	  /* jmp ->bra */
	  bfd_put_8 (abfd, 0x40, data + dst_address);
	  break;
	default:
	  abort ();
	}

      bfd_put_8 (abfd, gap, data + dst_address + 1);
      dst_address += 2;
      src_address += 4;

      break;

      /* This is a 16-bit absolute address in one of the following
	 instructions:

	   "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	   "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and
	   "mov.b"

	 We may relax this into an 8-bit absolute address if it's in
	 the right range.  */
    case R_MOV16B2:
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      /* All instructions with R_H8_DIR16B2 start with 0x6a.  */
      if (data[dst_address - 2] != 0x6a)
	abort ();

      temp_code = data[src_address - 1];

      /* If this is a mov.b instruction, clear the lower nibble, which
	 contains the source/destination register number.  */
      if ((temp_code & 0x10) != 0x10)
	temp_code &= 0xf0;

      /* Fix up the opcode.  */
      switch (temp_code)
	{
	case 0x00:
	  /* This is mov.b @@aa:16,Rd.  */
	  data[dst_address - 2] = (data[src_address - 1] & 0xf) | 0x20;
	  break;
	case 0x80:
	  /* This is mov.b Rs,@@aa:16.  */
	  data[dst_address - 2] = (data[src_address - 1] & 0xf) | 0x30;
	  break;
	case 0x18:
	  /* This is a bit-maniputation instruction that stores one
	     bit into memory, one of "bclr", "bist", "bnot", "bset",
	     and "bst".  */
	  data[dst_address - 2] = 0x7f;
	  break;
	case 0x10:
	  /* This is a bit-maniputation instruction that loads one bit
	     from memory, one of "band", "biand", "bild", "bior",
	     "bixor", "bld", "bor", "btst", and "bxor".  */
	  data[dst_address - 2] = 0x7e;
	  break;
	default:
	  abort ();
	}

      bfd_put_8 (abfd, value & 0xff, data + dst_address - 1);
      src_address += 2;
      break;

      /* This is a 24-bit absolute address in one of the following
	 instructions:

	   "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	   "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and
	   "mov.b"

	 We may relax this into an 8-bit absolute address if it's in
	 the right range.  */
    case R_MOV24B2:
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      /* All instructions with R_MOV24B2 start with 0x6a.  */
      if (data[dst_address - 2] != 0x6a)
	abort ();

      temp_code = data[src_address - 1];

      /* If this is a mov.b instruction, clear the lower nibble, which
	 contains the source/destination register number.  */
      if ((temp_code & 0x30) != 0x30)
	temp_code &= 0xf0;

      /* Fix up the opcode.  */
      switch (temp_code)
	{
	case 0x20:
	  /* This is mov.b @@aa:24/32,Rd.  */
	  data[dst_address - 2] = (data[src_address - 1] & 0xf) | 0x20;
	  break;
	case 0xa0:
	  /* This is mov.b Rs,@@aa:24/32.  */
	  data[dst_address - 2] = (data[src_address - 1] & 0xf) | 0x30;
	  break;
	case 0x38:
	  /* This is a bit-maniputation instruction that stores one
	     bit into memory, one of "bclr", "bist", "bnot", "bset",
	     and "bst".  */
	  data[dst_address - 2] = 0x7f;
	  break;
	case 0x30:
	  /* This is a bit-maniputation instruction that loads one bit
	     from memory, one of "band", "biand", "bild", "bior",
	     "bixor", "bld", "bor", "btst", and "bxor".  */
	  data[dst_address - 2] = 0x7e;
	  break;
	default:
	  abort ();
	}

      bfd_put_8 (abfd, value & 0xff, data + dst_address - 1);
      src_address += 4;
      break;

    case R_BCC_INV:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      dot = (link_order->offset
	     + dst_address
	     + link_order->u.indirect.section->output_section->vma) + 1;

      gap = value - dot;

      /* Sanity check.  */
      if (gap < -128 || gap > 126)
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}

      /* Everything looks OK.  Fix the condition in the instruction, apply
	 the relocation, and update the src/dst address appropriately.  */

      bfd_put_8 (abfd, bfd_get_8 (abfd, data + dst_address - 1) ^ 1,
		 data + dst_address - 1);
      bfd_put_8 (abfd, gap, data + dst_address);
      dst_address++;
      src_address++;

      /* All done.  */
      break;

    case R_JMP_DEL:
      src_address += 4;
      break;

    /* An 8-bit memory indirect instruction (jmp/jsr).

       There's several things that need to be done to handle
       this relocation.

       If this is a reloc against the absolute symbol, then
       we should handle it just R_RELBYTE.  Likewise if it's
       for a symbol with a value ge 0 and le 0xff.

       Otherwise it's a jump/call through the function vector,
       and the linker is expected to set up the function vector
       and put the right value into the jump/call instruction.  */
    case R_MEM_INDIRECT:
      {
	/* We need to find the symbol so we can determine it's
	   address in the function vector table.  */
	asymbol *symbol;
	const char *name;
	struct funcvec_hash_table *ftab;
	struct funcvec_hash_entry *h;
	struct h8300_coff_link_hash_table *htab;
	asection *vectors_sec;

	if (link_info->hash->creator != abfd->xvec)
	  {
	    (*_bfd_error_handler)
	      (_("cannot handle R_MEM_INDIRECT reloc when using %s output"),
	       link_info->hash->creator->name);

	    /* What else can we do?  This function doesn't allow return
	       of an error, and we don't want to call abort as that
	       indicates an internal error.  */
#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
#endif
	    xexit (EXIT_FAILURE);
	  }
	htab = h8300_coff_hash_table (link_info);
	vectors_sec = htab->vectors_sec;

	/* First see if this is a reloc against the absolute symbol
	   or against a symbol with a nonnegative value <= 0xff.  */
	symbol = *(reloc->sym_ptr_ptr);
	value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
	if (symbol == bfd_abs_section_ptr->symbol
	    || value <= 0xff)
	  {
	    /* This should be handled in a manner very similar to
	       R_RELBYTES.   If the value is in range, then just slam
	       the value into the right location.  Else trigger a
	       reloc overflow callback.  */
	    if (value <= 0xff)
	      {
		bfd_put_8 (abfd, value, data + dst_address);
		dst_address += 1;
		src_address += 1;
	      }
	    else
	      {
		if (! ((*link_info->callbacks->reloc_overflow)
		       (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
			reloc->howto->name, reloc->addend, input_section->owner,
			input_section, reloc->address)))
		  abort ();
	      }
	    break;
	  }

	/* This is a jump/call through a function vector, and we're
	   expected to create the function vector ourselves.

	   First look up this symbol in the linker hash table -- we need
	   the derived linker symbol which holds this symbol's index
	   in the function vector.  */
	name = symbol->name;
	if (symbol->flags & BSF_LOCAL)
	  {
	    char *new_name = bfd_malloc ((bfd_size_type) strlen (name) + 9);

	    if (new_name == NULL)
	      abort ();

	    strcpy (new_name, name);
	    sprintf (new_name + strlen (name), "_%08x",
		     (int) symbol->section);
	    name = new_name;
	  }

	ftab = htab->funcvec_hash_table;
	h = funcvec_hash_lookup (ftab, name, FALSE, FALSE);

	/* This shouldn't ever happen.  If it does that means we've got
	   data corruption of some kind.  Aborting seems like a reasonable
	   thing to do here.  */
	if (h == NULL || vectors_sec == NULL)
	  abort ();

	/* Place the address of the function vector entry into the
	   reloc's address.  */
	bfd_put_8 (abfd,
		   vectors_sec->output_offset + h->offset,
		   data + dst_address);

	dst_address++;
	src_address++;

	/* Now create an entry in the function vector itself.  */
	switch (bfd_get_mach (input_section->owner))
	  {
	  case bfd_mach_h8300:
	  case bfd_mach_h8300hn:
	  case bfd_mach_h8300sn:
	    bfd_put_16 (abfd,
			bfd_coff_reloc16_get_value (reloc,
						    link_info,
						    input_section),
			vectors_sec->contents + h->offset);
	    break;
	  case bfd_mach_h8300h:
	  case bfd_mach_h8300s:
	    bfd_put_32 (abfd,
			bfd_coff_reloc16_get_value (reloc,
						    link_info,
						    input_section),
			vectors_sec->contents + h->offset);
	    break;
	  default:
	    abort ();
	  }

	/* Gross.  We've already written the contents of the vector section
	   before we get here...  So we write it again with the new data.  */
	bfd_set_section_contents (vectors_sec->output_section->owner,
				  vectors_sec->output_section,
				  vectors_sec->contents,
				  (file_ptr) vectors_sec->output_offset,
				  vectors_sec->_raw_size);
	break;
      }

    default:
      abort ();
      break;

    }

  *src_ptr = src_address;
  *dst_ptr = dst_address;
}

/* Routine for the h8300 linker.

   This routine is necessary to handle the special R_MEM_INDIRECT
   relocs on the h8300.  It's responsible for generating a vectors
   section and attaching it to an input bfd as well as sizing
   the vectors section.  It also creates our vectors hash table.

   It uses the generic linker routines to actually add the symbols.
   from this BFD to the bfd linker hash table.  It may add a few
   selected static symbols to the bfd linker hash table.  */

static bfd_boolean
h8300_bfd_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
{
  asection *sec;
  struct funcvec_hash_table *funcvec_hash_table;
  bfd_size_type amt;
  struct h8300_coff_link_hash_table *htab;

  /* Add the symbols using the generic code.  */
  _bfd_generic_link_add_symbols (abfd, info);

  if (info->hash->creator != abfd->xvec)
    return TRUE;

  htab = h8300_coff_hash_table (info);

  /* If we haven't created a vectors section, do so now.  */
  if (!htab->vectors_sec)
    {
      flagword flags;

      /* Make sure the appropriate flags are set, including SEC_IN_MEMORY.  */
      flags = (SEC_ALLOC | SEC_LOAD
	       | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_READONLY);
      htab->vectors_sec = bfd_make_section (abfd, ".vectors");

      /* If the section wasn't created, or we couldn't set the flags,
	 quit quickly now, rather than dying a painful death later.  */
      if (!htab->vectors_sec
	  || !bfd_set_section_flags (abfd, htab->vectors_sec, flags))
	return FALSE;

      /* Also create the vector hash table.  */
      amt = sizeof (struct funcvec_hash_table);
      funcvec_hash_table = (struct funcvec_hash_table *) bfd_alloc (abfd, amt);

      if (!funcvec_hash_table)
	return FALSE;

      /* And initialize the funcvec hash table.  */
      if (!funcvec_hash_table_init (funcvec_hash_table, abfd,
				    funcvec_hash_newfunc))
	{
	  bfd_release (abfd, funcvec_hash_table);
	  return FALSE;
	}

      /* Store away a pointer to the funcvec hash table.  */
      htab->funcvec_hash_table = funcvec_hash_table;
    }

  /* Load up the function vector hash table.  */
  funcvec_hash_table = htab->funcvec_hash_table;

  /* Now scan the relocs for all the sections in this bfd; create
     additional space in the .vectors section as needed.  */
  for (sec = abfd->sections; sec; sec = sec->next)
    {
      long reloc_size, reloc_count, i;
      asymbol **symbols;
      arelent **relocs;

      /* Suck in the relocs, symbols & canonicalize them.  */
      reloc_size = bfd_get_reloc_upper_bound (abfd, sec);
      if (reloc_size <= 0)
	continue;

      relocs = (arelent **) bfd_malloc ((bfd_size_type) reloc_size);
      if (!relocs)
	return FALSE;

      /* The symbols should have been read in by _bfd_generic link_add_symbols
	 call abovec, so we can cheat and use the pointer to them that was
	 saved in the above call.  */
      symbols = _bfd_generic_link_get_symbols(abfd);
      reloc_count = bfd_canonicalize_reloc (abfd, sec, relocs, symbols);
      if (reloc_count <= 0)
	{
	  free (relocs);
	  continue;
	}

      /* Now walk through all the relocations in this section.  */
      for (i = 0; i < reloc_count; i++)
	{
	  arelent *reloc = relocs[i];
	  asymbol *symbol = *(reloc->sym_ptr_ptr);
	  const char *name;

	  /* We've got an indirect reloc.  See if we need to add it
	     to the function vector table.   At this point, we have
	     to add a new entry for each unique symbol referenced
	     by an R_MEM_INDIRECT relocation except for a reloc
	     against the absolute section symbol.  */
	  if (reloc->howto->type == R_MEM_INDIRECT
	      && symbol != bfd_abs_section_ptr->symbol)

	    {
	      struct funcvec_hash_table *ftab;
	      struct funcvec_hash_entry *h;

	      name = symbol->name;
	      if (symbol->flags & BSF_LOCAL)
		{
		  char *new_name;

		  new_name = bfd_malloc ((bfd_size_type) strlen (name) + 9);
		  if (new_name == NULL)
		    abort ();

		  strcpy (new_name, name);
		  sprintf (new_name + strlen (name), "_%08x",
			   (int) symbol->section);
		  name = new_name;
		}

	      /* Look this symbol up in the function vector hash table.  */
	      ftab = htab->funcvec_hash_table;
	      h = funcvec_hash_lookup (ftab, name, FALSE, FALSE);

	      /* If this symbol isn't already in the hash table, add
		 it and bump up the size of the hash table.  */
	      if (h == NULL)
		{
		  h = funcvec_hash_lookup (ftab, name, TRUE, TRUE);
		  if (h == NULL)
		    {
		      free (relocs);
		      return FALSE;
		    }

		  /* Bump the size of the vectors section.  Each vector
		     takes 2 bytes on the h8300 and 4 bytes on the h8300h.  */
		  switch (bfd_get_mach (abfd))
		    {
		    case bfd_mach_h8300:
		    case bfd_mach_h8300hn:
		    case bfd_mach_h8300sn:
		      htab->vectors_sec->_raw_size += 2;
		      break;
		    case bfd_mach_h8300h:
		    case bfd_mach_h8300s:
		      htab->vectors_sec->_raw_size += 4;
		      break;
		    default:
		      abort ();
		    }
		}
	    }
	}

      /* We're done with the relocations, release them.  */
      free (relocs);
    }

  /* Now actually allocate some space for the function vector.  It's
     wasteful to do this more than once, but this is easier.  */
  sec = htab->vectors_sec;
  if (sec->_raw_size != 0)
    {
      /* Free the old contents.  */
      if (sec->contents)
	free (sec->contents);

      /* Allocate new contents.  */
      sec->contents = bfd_malloc (sec->_raw_size);
    }

  return TRUE;
}

#define coff_reloc16_extra_cases h8300_reloc16_extra_cases
#define coff_reloc16_estimate h8300_reloc16_estimate
#define coff_bfd_link_add_symbols h8300_bfd_link_add_symbols
#define coff_bfd_link_hash_table_create h8300_coff_link_hash_table_create

#define COFF_LONG_FILENAMES
#include "coffcode.h"

#undef coff_bfd_get_relocated_section_contents
#undef coff_bfd_relax_section
#define coff_bfd_get_relocated_section_contents \
  bfd_coff_reloc16_get_relocated_section_contents
#define coff_bfd_relax_section bfd_coff_reloc16_relax_section

CREATE_BIG_COFF_TARGET_VEC (h8300coff_vec, "coff-h8300", BFD_IS_RELAXABLE, 0, '_', NULL, COFF_SWAP_TABLE)
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d64 1
a64 1
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d68 4
a71 4
  PARAMS ((struct funcvec_hash_table *, bfd *,
	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
				       struct bfd_hash_table *,
				       const char *)));
d74 1
a74 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d76 1
a76 1
  PARAMS ((reloc_howto_type *));
d78 1
a78 1
  PARAMS ((arelent *, struct internal_reloc *));
d80 1
a80 1
  PARAMS ((arelent *, struct internal_reloc *, asymbol **, bfd *, asection *));
d82 1
a82 1
  PARAMS ((bfd *, asection *, bfd_vma));
d84 2
a85 2
  PARAMS ((bfd *, asection *, arelent *, unsigned int,
    struct bfd_link_info *));
d87 2
a88 2
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *, arelent *,
    bfd_byte *, unsigned int *, unsigned int *));
d90 1
a90 1
  PARAMS ((bfd *, struct bfd_link_info *));
d114 1
a114 2
static struct bfd_link_hash_table *h8300_coff_link_hash_table_create
  PARAMS ((bfd *));
d125 3
a127 4
funcvec_hash_newfunc (entry, gen_table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *gen_table;
     const char *string;
d157 14
a170 7
  if (bfd_get_mach (table->abfd) == bfd_mach_h8300)
    table->offset += 2;
  else if (bfd_get_mach (table->abfd) == bfd_mach_h8300h
	   || bfd_get_mach (table->abfd) == bfd_mach_h8300s)
    table->offset += 4;
  else
    return NULL;
d179 6
a184 6
funcvec_hash_table_init (table, abfd, newfunc)
     struct funcvec_hash_table *table;
     bfd *abfd;
     struct bfd_hash_entry *(*newfunc)
       PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
		const char *));
d198 1
a198 2
h8300_coff_link_hash_table_create (abfd)
     bfd *abfd;
d231 7
a237 9
special (abfd, reloc_entry, symbol, data, input_section, output_bfd,
	 error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d268 2
a269 2
  /* Internal reloc for relaxing.  This is created when a 16bit pc-relative
     branch is turned into an 8bit pc-relative branch.  */
d299 1
a299 2
select_reloc (howto)
     reloc_howto_type *howto;
d307 1
a307 3
rtype2howto (internal, dst)
     arelent *internal;
     struct internal_reloc *dst;
d388 2
a389 6
reloc_processing (relent, reloc, symbols, abfd, section)
     arelent *relent;
     struct internal_reloc *reloc;
     asymbol **symbols;
     bfd *abfd;
     asection *section;
d408 1
a408 4
h8300_symbol_address_p (abfd, input_section, address)
     bfd *abfd;
     asection *input_section;
     bfd_vma address;
d440 2
a441 6
h8300_reloc16_estimate (abfd, input_section, reloc, shrink, link_info)
     bfd *abfd;
     asection *input_section;
     arelent *reloc;
     unsigned int shrink;
     struct bfd_link_info *link_info;
d461 2
a462 2
      /* This is the 16/24 bit absolute branch which could become an 8 bit
	 pc-relative branch.  */
d550 1
a550 1
    /* This is the 16 bit pc-relative branch which could become an 8 bit
d578 2
a579 2
    /* This is a 16 bit absolute address in a mov.b insn, which can
       become an 8 bit absolute address if it's in the right range.  */
d583 1
d585 3
a587 10
      /* The address is in 0xff00..0xffff inclusive on the h8300 or
	 0xffff00..0xffffff inclusive on the h8300h, then we can
	 relax this mov.b  */
      if ((bfd_get_mach (abfd) == bfd_mach_h8300
	   && value >= 0xff00
	   && value <= 0xffff)
	  || ((bfd_get_mach (abfd) == bfd_mach_h8300h
	       || bfd_get_mach (abfd) == bfd_mach_h8300s)
	      && value >= 0xffff00
	      && value <= 0xffffff))
d598 3
a600 3
    /* Similarly for a 24 bit absolute address in a mov.b.  Note that
       if we can't relax this into an 8 bit absolute, we'll fall through
       and try to relax it into a 16bit absolute.  */
d604 1
d606 1
a606 6
      /* The address is in 0xffff00..0xffffff inclusive on the h8300h,
	 then we can relax this mov.b  */
      if ((bfd_get_mach (abfd) == bfd_mach_h8300h
	   || bfd_get_mach (abfd) == bfd_mach_h8300s)
	  && value >= 0xffff00
	  && value <= 0xffffff)
d619 1
a619 1
      /* FALLTHROUGH and try to turn the 32/24 bit reloc into a 16 bit
d622 2
a623 2
    /* This is a 24/32 bit absolute address in a mov insn, which can
       become an 16 bit absolute address if it's in the right range.  */
d627 1
d629 3
a631 3
      /* If this address is in 0x0000..0x7fff inclusive or
	 0xff8000..0xffffff inclusive, then it can be relaxed.  */
      if (value <= 0x7fff || value >= 0xff8000)
d658 4
a661 9
h8300_reloc16_extra_cases (abfd, link_info, link_order, reloc, data, src_ptr,
			   dst_ptr)
     bfd *abfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     arelent *reloc;
     bfd_byte *data;
     unsigned int *src_ptr;
     unsigned int *dst_ptr;
d669 1
d673 1
a673 1
    /* Generic 8bit pc-relative relocation.  */
d703 1
a703 1
    /* Generic 16bit pc-relative relocation.  */
d734 1
a734 1
    /* Generic 8bit absolute relocation.  */
d739 3
a741 20
      /* Sanity check.  */
      if (value <= 0xff
	  || (value >= 0x0000ff00 && value <= 0x0000ffff)
	  || (value >= 0x00ffff00 && value <= 0x00ffffff)
	  || (value >= 0xffffff00 && value <= 0xffffffff))
	{
	  /* Everything looks OK.  Apply the relocation and update the
	     src/dst address appropriately.  */
	  bfd_put_8 (abfd, value & 0xff, data + dst_address);
	  dst_address += 1;
	  src_address += 1;
	}
      else
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}
d746 1
a746 1
    /* Various simple 16bit absolute relocations.  */
d756 1
a756 1
    /* Various simple 24/32bit absolute relocations.  */
d767 1
a767 1
    /* Another 24/32bit absolute relocation.  */
d779 9
a787 2
    /* A 16bit abolute relocation that was formerlly a 24/32bit
       absolute relocation.  */
d790 1
d793 1
a793 1
      if (value <= 0x7fff || value >= 0xff8000)
d795 1
a795 1
	  /* Insert the 16bit value into the proper location.  */
d798 3
a800 2
	  /* Fix the opcode.  For all the move insns, we simply
	     need to turn off bit 0x20 in the previous byte.  */
d815 1
a815 1
    /* A 16bit absolute branch that is now an 8-bit pc-relative branch.  */
d845 1
a845 1
	  /* jmp ->bra */
d853 1
a853 1
      /* Write out the 8bit value.  */
d861 1
a861 1
    /* A 16bit pc-relative branch that is now an 8-bit pc-relative branch.  */
d888 2
a889 1
	  /* Get the condition code from the original insn.  */
d891 4
a896 2

	  /* Now or in the high nibble of the opcode.  */
d915 1
a915 1
      /* We don't advance dst_address -- the 8bit reloc is applied at
d921 1
a921 1
    /* Similarly for a 24bit absolute that is now 8 bits.  */
d954 9
a962 1
    /* A 16bit absolute mov.b that is now an 8bit absolute mov.b.  */
d966 1
a966 1
      /* Sanity check.  */
d970 7
d978 1
a978 1
      switch (data[src_address - 1] & 0xf0)
d981 1
d985 1
d988 12
d1008 9
a1016 1
    /* Similarly for a 24bit mov.b  */
d1020 1
a1020 1
      /* Sanity check.  */
d1024 7
d1032 1
a1032 1
      switch (data[src_address - 1] & 0xf0)
d1035 1
d1039 1
d1042 12
d1098 1
a1098 1
    /* An 8bit memory indirect instruction (jmp/jsr).
d1176 1
d1205 22
a1226 15
	if (bfd_get_mach (input_section->owner) == bfd_mach_h8300)
	  bfd_put_16 (abfd,
		      bfd_coff_reloc16_get_value (reloc,
						  link_info,
						  input_section),
		      vectors_sec->contents + h->offset);
	else if (bfd_get_mach (input_section->owner) == bfd_mach_h8300h
		 || bfd_get_mach (input_section->owner) == bfd_mach_h8300s)
	  bfd_put_32 (abfd,
		      bfd_coff_reloc16_get_value (reloc,
						  link_info,
						  input_section),
		      vectors_sec->contents + h->offset);
	else
	  abort ();
d1260 1
a1260 3
h8300_bfd_link_add_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d1392 14
a1405 5
		  if (bfd_get_mach (abfd) == bfd_mach_h8300)
		    htab->vectors_sec->_raw_size += 2;
		  else if (bfd_get_mach (abfd) == bfd_mach_h8300h
			   || bfd_get_mach (abfd) == bfd_mach_h8300s)
		    htab->vectors_sec->_raw_size += 4;
d1444 1
a1444 1
CREATE_BIG_COFF_TARGET_VEC (h8300coff_vec, "coff-h8300", BFD_IS_RELAXABLE, 0, '_', NULL)
@


1.6
log
@resolve conflicts.
@
text
@d1 1
a1 1
/* BFD back-end for Hitachi H8/300 COFF binaries.
d3 1
a3 1
   2000
d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 1
d42 8
a49 8
{
  /* The basic hash table entry.  */
  struct bfd_hash_entry root;

  /* The offset within the vectors section where
     this entry lives.  */
  bfd_vma offset;
};
d52 9
a60 9
{
  /* The basic hash table.  */
  struct bfd_hash_table root;

  bfd *abfd;

  /* Offset at which we'll add the next entry.  */
  unsigned int offset;
};
d66 1
a66 1
static boolean
d69 22
a90 3
           struct bfd_hash_entry *(*) PARAMS ((struct bfd_hash_entry *,
                                               struct bfd_hash_table *,
                                               const char *))));
d101 1
a101 2
struct h8300_coff_link_hash_table
{
d141 2
a142 2
           bfd_hash_allocate (gen_table,
                              sizeof (struct funcvec_hash_entry)));
d148 1
a148 1
         bfd_hash_newfunc ((struct bfd_hash_entry *) ret, gen_table, string));
d173 1
a173 1
static boolean
d177 3
a179 3
     struct bfd_hash_entry *(*newfunc) PARAMS ((struct bfd_hash_entry *,
                                                struct bfd_hash_table *,
                                                const char *));
d189 1
a189 1
   basically to hold "static" information during an h8/300 coff link
d197 3
a199 2
  ret = ((struct h8300_coff_link_hash_table *)
         bfd_alloc (abfd, sizeof (struct h8300_coff_link_hash_table)));
d202 2
a203 1
  if (!_bfd_link_hash_table_init (&ret->root.root, abfd, _bfd_generic_link_hash_newfunc))
d205 1
a205 1
      bfd_release (abfd, ret);
d213 1
a213 1
  /* OK.  Everything's intialized, return the base pointer.  */
d245 15
a259 16
static reloc_howto_type howto_table[] =
{
  HOWTO (R_RELBYTE, 0, 0, 8, false, 0, complain_overflow_bitfield, special, "8", false, 0x000000ff, 0x000000ff, false),
  HOWTO (R_RELWORD, 0, 1, 16, false, 0, complain_overflow_bitfield, special, "16", false, 0x0000ffff, 0x0000ffff, false),
  HOWTO (R_RELLONG, 0, 2, 32, false, 0, complain_overflow_bitfield, special, "32", false, 0xffffffff, 0xffffffff, false),
  HOWTO (R_PCRBYTE, 0, 0, 8, true, 0, complain_overflow_signed, special, "DISP8", false, 0x000000ff, 0x000000ff, true),
  HOWTO (R_PCRWORD, 0, 1, 16, true, 0, complain_overflow_signed, special, "DISP16", false, 0x0000ffff, 0x0000ffff, true),
  HOWTO (R_PCRLONG, 0, 2, 32, true, 0, complain_overflow_signed, special, "DISP32", false, 0xffffffff, 0xffffffff, true),
  HOWTO (R_MOV16B1, 0, 1, 16, false, 0, complain_overflow_bitfield, special, "relaxable mov.b:16", false, 0x0000ffff, 0x0000ffff, false),
  HOWTO (R_MOV16B2, 0, 1, 8, false, 0, complain_overflow_bitfield, special, "relaxed mov.b:16", false, 0x000000ff, 0x000000ff, false),
  HOWTO (R_JMP1, 0, 1, 16, false, 0, complain_overflow_bitfield, special, "16/pcrel", false, 0x0000ffff, 0x0000ffff, false),
  HOWTO (R_JMP2, 0, 0, 8, false, 0, complain_overflow_bitfield, special, "pcrecl/16", false, 0x000000ff, 0x000000ff, false),
  HOWTO (R_JMPL1, 0, 2, 32, false, 0, complain_overflow_bitfield, special, "24/pcrell", false, 0x00ffffff, 0x00ffffff, false),
  HOWTO (R_JMPL2, 0, 0, 8, false, 0, complain_overflow_bitfield, special, "pc8/24", false, 0x000000ff, 0x000000ff, false),
  HOWTO (R_MOV24B1, 0, 1, 32, false, 0, complain_overflow_bitfield, special, "relaxable mov.b:24", false, 0xffffffff, 0xffffffff, false),
  HOWTO (R_MOV24B2, 0, 1, 8, false, 0, complain_overflow_bitfield, special, "relaxed mov.b:24", false, 0x0000ffff, 0x0000ffff, false),
d264 1
a264 1
  HOWTO (R_MEM_INDIRECT, 0, 0, 8, false, 0, complain_overflow_bitfield, special, "8/indirect", false, 0x000000ff, 0x000000ff, false),
d268 1
a268 1
  HOWTO (R_PCRWORD_B, 0, 0, 8, true, 0, complain_overflow_bitfield, special, "relaxed bCC:16", false, 0x000000ff, 0x000000ff, false),
d270 1
a270 1
  HOWTO (R_MOVL1, 0, 2, 32, false, 0, complain_overflow_bitfield,special, "32/24 relaxable move", false, 0xffffffff, 0xffffffff, false),
d272 1
a272 1
  HOWTO (R_MOVL2, 0, 1, 16, false, 0, complain_overflow_bitfield, special, "32/24 relaxed move", false, 0x0000ffff, 0x0000ffff, false),
d274 1
a274 1
  HOWTO (R_BCC_INV, 0, 0, 8, true, 0, complain_overflow_signed, special, "DISP8 inverted", false, 0x000000ff, 0x000000ff, true),
d276 1
a276 1
  HOWTO (R_JMP_DEL, 0, 0, 8, true, 0, complain_overflow_signed, special, "Deleted jump", false, 0x000000ff, 0x000000ff, true),
d282 1
a282 1
  { x.r_type = select_reloc(howto); }
d284 3
a286 2
#define BADMAG(x) (H8300BADMAG(x) && H8300HBADMAG(x) && H8300SBADMAG(x))
#define H8300 1			/* Customize coffcode.h */
d290 2
a291 2
#define SWAP_IN_RELOC_OFFSET   bfd_h_get_32
#define SWAP_OUT_RELOC_OFFSET bfd_h_put_32
d378 1
a378 1
#define RTYPE2HOWTO(internal, relocentry) rtype2howto(internal,relocentry)
d383 1
a383 1
 cache_ptr->addend =  ext_reloc.r_offset;
d386 1
a386 1
 reloc_processing(relent, reloc, symbols, abfd, section)
d400 1
a400 3
    {
      relent->sym_ptr_ptr = symbols + obj_convert (abfd)[reloc->r_symndx];
    }
d402 1
a402 3
    {
      relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
    }
d412 1
a412 1
static boolean
d428 1
d433 1
a433 1
	return true;
d436 1
a436 1
  return false;
d473 2
a474 2
    /* This is the 16/24 bit absolute branch which could become an 8 bit
       pc-relative branch.  */
d493 1
a493 1
      if ((int)gap >= -128 && (int)gap <= 128 )
d495 7
d513 4
a516 1
	     common.  */
d518 14
a531 1
	  if (gap <= 126
d566 1
a566 1
         because the addend field in PCrel jumps is off by -1.  */
d579 1
a579 1
      if ((int)gap >= -128 && (int)gap <= 128 )
d651 1
a651 1
         0xff8000..0xffffff inclusive, then it can be relaxed.  */
a720 1

d752 1
a752 2

      bfd_put_16 (abfd, gap, data + dst_address);
d767 1
a767 1
  	  || (value >= 0x00ffff00 && value <= 0x00ffffff)
a771 1

d834 1
a834 1
          data[dst_address - 1] &= ~0x20;
d845 1
a845 1
        }
d942 2
a943 2
	/* Output the target.  */
	bfd_put_8 (abfd, gap, data + dst_address - 1);
d945 3
a947 3
	/* We don't advance dst_address -- the 8bit reloc is applied at
	   dst_address - 1, so the next insn should begin at dst_address.  */
	src_address += 2;
d949 1
a949 1
	break;
a1086 1
	bfd_vma value;
d1088 1
d1090 19
a1108 1
	asection *vectors_sec = h8300_coff_hash_table (link_info)->vectors_sec;
d1147 1
a1147 1
	    char *new_name = bfd_malloc (strlen (name) + 9);
d1157 2
a1158 2
	h = funcvec_hash_lookup (h8300_coff_hash_table (link_info)->funcvec_hash_table,
				 name, false, false);
d1162 1
a1162 1
	   think to do here.  */
d1197 1
a1197 1
				  vectors_sec->output_offset,
d1223 1
a1223 1
static boolean
d1230 10
d1242 1
a1242 1
  if (!h8300_coff_hash_table (info)->vectors_sec)
d1249 1
a1249 2
      h8300_coff_hash_table (info)->vectors_sec = bfd_make_section (abfd,
								    ".vectors");
d1252 4
a1255 6
	 quit quickly now, rather than dieing a painful death later.  */
      if (! h8300_coff_hash_table (info)->vectors_sec
	  || ! bfd_set_section_flags (abfd,
				      h8300_coff_hash_table(info)->vectors_sec,
				      flags))
	return false;
d1258 2
a1259 2
      funcvec_hash_table = ((struct funcvec_hash_table *)
	bfd_alloc (abfd, sizeof (struct funcvec_hash_table)));
d1262 1
a1262 1
	return false;
d1269 1
a1269 1
	  return false;
d1273 1
a1273 1
      h8300_coff_hash_table (info)->funcvec_hash_table = funcvec_hash_table;
d1277 1
a1277 4
  funcvec_hash_table = h8300_coff_hash_table (info)->funcvec_hash_table;

  /* Add the symbols using the generic code.  */
  _bfd_generic_link_add_symbols (abfd, info);
d1292 1
a1292 1
      relocs = (arelent **) bfd_malloc ((size_t) reloc_size);
d1294 1
a1294 1
	return false;
d1323 1
d1329 1
a1329 1
		  char *new_name = bfd_malloc (strlen (name) + 9);
d1331 1
d1342 2
a1343 2
	      h = funcvec_hash_lookup (h8300_coff_hash_table (info)->funcvec_hash_table,
				       name, false, false);
d1349 1
a1349 2
		  h = funcvec_hash_lookup (h8300_coff_hash_table (info)->funcvec_hash_table,
					   name, true, true);
d1353 1
a1353 1
		      return false;
d1359 1
a1359 1
		    h8300_coff_hash_table (info)->vectors_sec->_raw_size += 2;
d1362 1
a1362 1
		    h8300_coff_hash_table (info)->vectors_sec->_raw_size += 4;
d1373 2
a1374 1
  if (h8300_coff_hash_table (info)->vectors_sec->_raw_size != 0)
d1377 2
a1378 2
      if (h8300_coff_hash_table (info)->vectors_sec->contents)
	free (h8300_coff_hash_table (info)->vectors_sec->contents);
d1381 1
a1381 2
      h8300_coff_hash_table (info)->vectors_sec->contents
	= bfd_malloc (h8300_coff_hash_table (info)->vectors_sec->_raw_size);
d1384 1
a1384 1
  return true;
@


1.5
log
@Automatic cvs merge. Dread what I will have to fix after this excuse
of a program is done...
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d35 1
a35 1
   hold entries in the function vector.  Aside from the 
d200 1
a200 1
   the pcrel branches.  This isn't so, since the H8/300 can do relaxing, 
d259 1
a259 2

/* Turn a howto into a reloc number */
d268 1
a268 3


/* Code to swap in the reloc */
a274 1

d282 1
a282 2
/* Code to turn a r_type into a howto ptr, uses the above howto table
   */
d359 1
a359 3

/* Perform any necessary magic to the addend in a reloc entry */

a363 1

d369 1
a369 1
     arelent * relent;
d371 3
a373 3
     asymbol ** symbols;
     bfd * abfd;
     asection * section;
a386 2


d390 3
a392 1
  /*  relent->section = 0;*/
d408 1
a408 1
  while (*s) 
d417 1
a417 1
    }    
a420 1

d430 1
a430 1
h8300_reloc16_estimate(abfd, input_section, reloc, shrink, link_info)
d437 1
a437 1
  bfd_vma value;  
d443 1
a443 1
  /* The address of the thing to be relocated will have moved back by 
d454 1
a454 2
    {     

d460 1
a460 1
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
d471 1
a471 1
  
d476 1
a476 2
	{ 

d486 1
a486 1
	
d500 1
a500 1
		  && ! h8300_symbol_address_p (abfd, input_section, dot - 2))
d513 1
a513 1
	  reloc->howto = reloc->howto + 1;	  
d517 1
a517 1
	  bfd_perform_slip(abfd, 2, input_section, address);
d526 2
a527 2
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section) + 1;
	
d531 1
a531 1
  
d539 1
a539 1
	{ 
d545 1
a545 1
	  bfd_perform_slip(abfd, 2, input_section, address);
d553 1
a553 1
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
d571 1
a571 1
	  bfd_perform_slip(abfd, 2, input_section, address);
d580 1
a580 1
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
d594 1
a594 1
	  bfd_perform_slip(abfd, 4, input_section, address);
d607 1
a607 1
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
d618 1
a618 1
	  bfd_perform_slip(abfd, 2, input_section, address);
d623 2
a624 2
      default:
	break;
a631 1

d653 1
a653 1
  int gap,tmp;
a656 1

d660 1
a660 1
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
d662 2
a663 2
      dot = (link_order->offset 
	     + dst_address 
d691 1
a691 1
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
d694 2
a695 2
      dot = (link_order->offset 
	     + dst_address 
d754 1
a754 1
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
d765 1
a765 1
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section),
d912 1
a912 1
      
d955 1
a955 1
      switch (data[src_address-1] & 0xf0)
d958 1
a958 1
	  data[dst_address - 2] = (data[src_address-1] & 0xf) | 0x20;
d961 1
a961 1
	  data[dst_address - 2] = (data[src_address-1] & 0xf) | 0x30;
d980 1
a980 1
      switch (data[src_address-1] & 0xf0)
d983 1
a983 1
	  data[dst_address - 2] = (data[src_address-1] & 0xf) | 0x20;
d986 1
a986 1
	  data[dst_address - 2] = (data[src_address-1] & 0xf) | 0x30;
d998 1
a998 1
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
d1000 2
a1001 2
      dot = (link_order->offset 
	     + dst_address 
d1083 1
a1083 1
	   expected to create the function vector ourselves. 
d1097 1
a1097 1
		     (int)symbol->section);
a1155 1

d1168 1
a1168 1
h8300_bfd_link_add_symbols(abfd, info)
d1232 1
a1232 1
      relocs = (arelent **)bfd_malloc ((size_t)reloc_size);
d1275 1
a1275 1
			   (int)symbol->section);
a1282 1

a1333 1

a1338 1

@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d195 1
a195 1
/* special handling for H8/300 relocs.
d201 2
a202 2
   contain the offset required for the branch, so we have to use the only
   the addend until the final link */
d206 1
a206 1
		 error_message)
d218 2
d905 5
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a23 1
#include "obstack.h"
d207 5
a211 5
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
d213 1
a213 1
     char **error_message;
d362 1
a362 1
/* Perform any necessaru magic to the addend in a reloc entry */
d736 1
a736 1
      if (value < 0xff 
d799 1
a799 1
      if (value < 0x8000 || value > 0xff8000)
d1064 1
a1064 1
	    || (value >= 0 && value <= 0xff))
d1070 1
a1070 1
	    if (value >= 0 && value <= 0xff)
d1229 1
a1229 1
      unsigned long reloc_size, reloc_count, i;
d1247 5
d1349 1
a1349 41

const bfd_target h8300coff_vec =
{
  "coff-h8300",			/* name */
  bfd_target_coff_flavour,
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | BFD_IS_RELAXABLE ),
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC),	/* section flags */
  '_',				/* leading char */
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */

  {_bfd_dummy_target, coff_object_p,	/* bfd_check_format */
   bfd_generic_archive_p, _bfd_dummy_target},
  {bfd_false, coff_mkobject, _bfd_generic_mkarchive,	/* bfd_set_format */
   bfd_false},
  {bfd_false, coff_write_object_contents,	/* bfd_write_contents */
   _bfd_write_archive_contents, bfd_false},

     BFD_JUMP_TABLE_GENERIC (coff),
     BFD_JUMP_TABLE_COPY (coff),
     BFD_JUMP_TABLE_CORE (_bfd_nocore),
     BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
     BFD_JUMP_TABLE_SYMBOLS (coff),
     BFD_JUMP_TABLE_RELOCS (coff),
     BFD_JUMP_TABLE_WRITE (coff),
     BFD_JUMP_TABLE_LINK (coff),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  COFF_SWAP_TABLE,
};
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d141 2
a142 1
  else if (bfd_get_mach (table->abfd) == bfd_mach_h8300h)
d251 3
d262 1
a262 1
#define BADMAG(x) (H8300BADMAG(x)&& H8300HBADMAG(x))
d347 6
d400 27
d446 2
d455 3
d471 4
a474 1
	     + input_section->output_offset + address + 2);
d479 4
a482 3
      /* If the distance is within -128..+126 inclusive, then we can relax
	 this jump.  */
      if ((int)gap >= -128 && (int)gap <= 126 )
d484 36
d524 1
a524 1
	  shrink +=2 ;
d532 3
a534 2
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
d536 1
a536 1
      /* Get the address of the next instruction.  */
d538 1
a538 1
	input_section->output_offset + address - 1;
d543 4
a546 3
      /* If the distance is within -128..+126 inclusive, then we can relax
	 this jump.  */
      if ((int)gap >= -128 && (int)gap <= 126 )
d552 1
a552 1
	  shrink +=2 ;
d569 2
a570 1
	  || (bfd_get_mach (abfd) == bfd_mach_h8300h
d592 2
a593 1
      if (bfd_get_mach (abfd) == bfd_mach_h8300h
d625 1
a625 1
	  shrink +=2 ;
d635 2
d724 2
a725 2
      dst_address+=2;
      src_address+=2;
d744 1
a744 1
	  bfd_put_8 (abfd, gap, data + dst_address);
d807 2
a808 2
	  dst_address+=2;
	  src_address+=4;
d1001 36
d1055 1
a1055 1
	char *name;
d1131 2
a1132 1
	else if (bfd_get_mach (input_section->owner) == bfd_mach_h8300h)
d1253 1
a1253 1
	  char *name;
d1301 2
a1302 1
		  else if (bfd_get_mach (abfd) == bfd_mach_h8300h)
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
d26 1
d33 160
d228 2
a229 2
  HOWTO (R_MOVB1, 0, 1, 16, false, 0, complain_overflow_bitfield, special, "16/8", false, 0x0000ffff, 0x0000ffff, false),
  HOWTO (R_MOVB2, 0, 1, 16, false, 0, complain_overflow_bitfield, special, "8/16", false, 0x0000ffff, 0x0000ffff, false),
d232 13
d246 1
d248 1
a248 5
  HOWTO (R_JMPL1, 0, 2, 32, false, 0, complain_overflow_bitfield, special, "24/pcrell", false, 0x00ffffff, 0x00ffffff, false),
  HOWTO (R_JMPL_B8, 0, 0, 8, false, 0, complain_overflow_bitfield, special, "pc8/24", false, 0x000000ff, 0x000000ff, false),

  HOWTO (R_MOVLB1, 0, 1, 16, false, 0, complain_overflow_bitfield,special, "24/8", false, 0x0000ffff, 0x0000ffff, false),
  HOWTO (R_MOVLB2, 0, 1, 16, false, 0, complain_overflow_bitfield, special, "8/24", false, 0x0000ffff, 0x0000ffff, false),
d307 1
a307 1
    case R_MOVB1:
d310 1
a310 1
    case R_MOVB2:
d322 1
a322 1
    case R_JMPL_B8:
d325 1
a325 1
    case R_MOVLB1:
d328 1
a328 1
    case R_MOVLB2:
d331 12
d390 7
d411 3
a413 6
   the size of the shrink  - but we don't change reloc->address here,
   since we need it to know where the relocation lives in the source
   uncooked section */

  /*  reloc->address -= shrink;   conceptual */

a414 1
  
d416 1
a418 4
    case R_MOVB2:
    case R_JMP2:
      shrink+=2;
      break;
d420 5
a424 2
      /* Thing is a move one byte */
    case R_MOVB1:
d427 10
a436 1
      if (value >= 0xff00)
d438 2
d441 1
a441 5
	  /* Change the reloc type from 16bit, possible 8 to 8bit
	     possible 16 */
	  reloc->howto = reloc->howto + 1;	  
	  /* The place to relc moves back by one */
	  /* This will be two bytes smaller in the long run */
d444 1
a444 2
	}      

a445 3
      /* This is the 24 bit branch which could become an 8 bitter, 
       the relocation points to the first byte of the insn, not the
       actual data */
d447 4
a450 1
    case R_JMPL1:
d453 1
d455 1
a455 1
	input_section->output_offset + address;
d457 2
a458 3
      /* See if the address we're looking at within 127 bytes of where
	 we are, if so then we can use a small branch rather than the
	 jump we were going to */
d460 3
a462 3
      gap = value - dot ;
  
      if (-120 < (long)gap && (long)gap < 120 )
d464 2
d467 1
a467 4
	  /* Change the reloc type from 24bit, possible 8 to 8bit
	     possible 32 */
	  reloc->howto = reloc->howto + 1;	  
	  /* This will be two bytes smaller in the long run */
d473 24
a496 1
    case R_JMP1:
d498 5
a503 7
	
      dot = input_section->output_section->vma +
	input_section->output_offset + address;
  
      /* See if the address we're looking at within 127 bytes of where
	 we are, if so then we can use a small branch rather than the
	 jump we were going to */
d505 19
a523 2
      gap = value - (dot - shrink);
  
d525 5
a529 2
      if (-120 < (long)gap && (long)gap < 120 )
	{ 
d531 6
a536 4
	  /* Change the reloc type from 16bit, possible 8 to 8bit
	     possible 16 */
	  reloc->howto = reloc->howto + 1;	  
	  /* The place to relc moves back by one */
d538 1
a538 1
	  /* This will be two bytes smaller in the long run */
d543 4
a548 1
  
d553 2
a554 1
/* First phase of a relaxing link */
d556 1
a556 8
/* Reloc types
   large		small
   R_MOVB1		R_MOVB2		mov.b with 16bit or 8 bit address
   R_JMP1		R_JMP2		jmp or pcrel branch
   R_JMPL1		R_JMPL_B8	24jmp or pcrel branch
   R_MOVLB1		R_MOVLB2	24 or 8 bit reloc for mov.b

*/
d572 3
d578 2
a579 2
      /* A 24 bit branch which could be a 8 bit pcrel, really pointing to
	 the byte before the 24bit hole, so we can treat it as a 32bit pointer */
d581 28
a608 18
      {
	bfd_vma dot = link_order->offset 
	  + dst_address 
	    + link_order->u.indirect.section->output_section->vma;
	int gap = (bfd_coff_reloc16_get_value (reloc, link_info, input_section)
		   - dot);
	if (gap > 127 || gap < -128)
	  {
	    if (! ((*link_info->callbacks->reloc_overflow)
		   (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
		    reloc->howto->name, reloc->addend, input_section->owner,
		    input_section, reloc->address)))
	      abort ();
	  }
	gap &= ~1;
	bfd_put_8 (abfd, gap, data + dst_address);
	dst_address++;
	src_address++;
d610 1
a610 2
	break;
      }
d612 22
a633 14
      {
	bfd_vma dot = link_order->offset 
	  + dst_address 
	    + link_order->u.indirect.section->output_section->vma;
	int gap = (bfd_coff_reloc16_get_value (reloc, link_info, input_section)
		   - dot) - 1;
	if (gap > 32767 || gap < -32768)
	  {
	    if (! ((*link_info->callbacks->reloc_overflow)
		   (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
		    reloc->howto->name, reloc->addend, input_section->owner,
		    input_section, reloc->address)))
	      abort ();
	  }
d635 3
a637 3
	bfd_put_16 (abfd, gap, data + dst_address);
	dst_address+=2;
	src_address+=2;
d639 2
a640 2
	break;
      }
d642 1
d644 26
a669 24
      {
	unsigned int gap = bfd_coff_reloc16_get_value (reloc, link_info,
						       input_section);
	if (gap < 0xff 
	    || (gap >= 0x0000ff00
	        && gap <= 0x0000ffff)
  	    || (   gap >= 0x00ffff00 
		&& gap <= 0x00ffffff)
	    || (   gap >= 0xffffff00
		&& gap <= 0xffffffff))
	  {
	    bfd_put_8 (abfd, gap, data + dst_address);
	    dst_address += 1;
	    src_address += 1;
	  }
	else
	  {
	    if (! ((*link_info->callbacks->reloc_overflow)
		   (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
		    reloc->howto->name, reloc->addend, input_section->owner,
		    input_section, reloc->address)))
	      abort ();
	  }
      }
d671 3
a674 4
      /* A relword which would have like to have been a pcrel */
    case R_MOVB1:
      /* A relword which would like to have been modified but
	     didn't make it */
d676 2
a677 3
      bfd_put_16 (abfd,
		  bfd_coff_reloc16_get_value (reloc, link_info, input_section),
		  data + dst_address);
d681 4
d686 3
a688 3
      bfd_put_32 (abfd,
		  bfd_coff_reloc16_get_value (reloc, link_info, input_section),
		  data + dst_address);
d693 63
a755 11
    case R_MOVB2:
      /* Special relaxed type, there will be a gap between where we
	     get stuff from and where we put stuff to now
	
	     for a mov.b @@aa:16 -> mov.b @@aa:8
	     opcode 0x6a 0x0y offset
	     ->     0x2y off
	     */
      if (data[dst_address - 1] != 0x6a)
	abort ();
      switch (data[src_address] & 0xf0)
d757 3
a759 3
	case 0x00:
	  /* Src is memory */
	  data[dst_address - 1] = (data[src_address] & 0xf) | 0x20;
d761 3
a763 3
	case 0x80:
	  /* Src is reg */
	  data[dst_address - 1] = (data[src_address] & 0xf) | 0x30;
d765 1
d770 2
a771 6
      /* the offset must fit ! after all, what was all the relaxing
	     about ? */

      bfd_put_8 (abfd,
		 bfd_coff_reloc16_get_value (reloc, link_info, input_section),
		 data + dst_address);
a772 2
      /* Note the magic - src goes up by two bytes, but dst by only
	     one */
d778 51
a828 1
    case R_JMP2:
d830 9
a838 5
      /* Speciial relaxed type */
      {
	bfd_vma dot = link_order->offset
	+ dst_address
	+ link_order->u.indirect.section->output_section->vma;
d840 1
a840 2
	int gap = (bfd_coff_reloc16_get_value (reloc, link_info, input_section)
		   - dot - 1);
d842 12
a853 1
	if ((gap & ~0xff) != 0 && ((gap & 0xff00) != 0xff00))
d855 1
d857 9
a865 1
	bfd_put_8 (abfd, gap, data + dst_address);
d867 3
a869 10
	switch (data[dst_address - 1])
	  {
	  case 0x5e:
	    /* jsr -> bsr */
	    bfd_put_8 (abfd, 0x55, data + dst_address - 1);
	    break;
	  case 0x5a:
	    /* jmp ->bra */
	    bfd_put_8 (abfd, 0x40, data + dst_address - 1);
	    break;
d871 12
a882 5
	  default:
	    abort ();
	  }
	dst_address++;
	src_address += 3;
d884 2
a885 2
	break;
      }
a886 8
      
    case R_JMPL_B8: /* 24 bit branch which is now 8 bits */
      
      /* Speciial relaxed type */
      {
	bfd_vma dot = link_order->offset
	+ dst_address
	+ link_order->u.indirect.section->output_section->vma;
d888 7
a894 2
	int gap = (bfd_coff_reloc16_get_value (reloc, link_info, input_section)
		   - dot - 2);
d896 10
a905 1
	if ((gap & ~0xff) != 0 && ((gap & 0xff00) != 0xff00))
d907 10
d918 23
a940 1
	switch (data[src_address])
d942 18
a959 7
	  case 0x5e:
	    /* jsr -> bsr */
	    bfd_put_8 (abfd, 0x55, data + dst_address);
	    break;
	  case 0x5a:
	    /* jmp ->bra */
	    bfd_put_8 (abfd, 0x40, data + dst_address);
d961 14
d976 4
a979 3
	  default:
	    bfd_put_8 (abfd, 0xde, data + dst_address);
	    break;
d982 2
a983 3
	bfd_put_8 (abfd, gap, data + dst_address + 1);
	dst_address += 2;
	src_address += 4;
d985 5
a989 2
	break;
      }
d991 5
a995 9
    case R_JMPL1:
      {
	int v = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
	int o = bfd_get_32 (abfd, data + src_address);
	v = (v & 0x00ffffff) | (o & 0xff000000);
	bfd_put_32 (abfd, v, data + dst_address);
	dst_address += 4;
	src_address += 4;
      }
d997 2
a998 1
      break;
d1000 15
d1016 8
a1023 10
      /* A 24 bit mov  which could be an 8 bit move, really pointing to
	 the byte before the 24bit hole, so we can treat it as a 32bit pointer */
    case R_MOVLB1:
      {
	int v = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
	int o = bfd_get_32 (abfd, data + dst_address);
	v = (v & 0x00ffffff) | (o & 0xff000000);
	bfd_put_32 (abfd, v, data + dst_address);
	dst_address += 4;
	src_address += 4;
a1025 1
      break;
a1026 1

d1031 1
d1034 164
d1199 1
d1204 2
d1223 2
a1224 2
  true,				/* data byte order is big */
  true,				/* header byte order is big */
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a25 1
#include "genlink.h"
a31 160
/* We derive a hash table from the basic BFD hash table to
   hold entries in the function vector.  Aside from the 
   info stored by the basic hash table, we need the offset
   of a particular entry within the hash table as well as
   the offset where we'll add the next entry.  */

struct funcvec_hash_entry
{
  /* The basic hash table entry.  */
  struct bfd_hash_entry root;

  /* The offset within the vectors section where
     this entry lives.  */
  bfd_vma offset;
};

struct funcvec_hash_table
{
  /* The basic hash table.  */
  struct bfd_hash_table root;

  bfd *abfd;

  /* Offset at which we'll add the next entry.  */
  unsigned int offset;
};

static struct bfd_hash_entry *
funcvec_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));

static boolean
funcvec_hash_table_init
  PARAMS ((struct funcvec_hash_table *, bfd *,
           struct bfd_hash_entry *(*) PARAMS ((struct bfd_hash_entry *,
                                               struct bfd_hash_table *,
                                               const char *))));

/* To lookup a value in the function vector hash table.  */
#define funcvec_hash_lookup(table, string, create, copy) \
  ((struct funcvec_hash_entry *) \
   bfd_hash_lookup (&(table)->root, (string), (create), (copy)))

/* The derived h8300 COFF linker table.  Note it's derived from
   the generic linker hash table, not the COFF backend linker hash
   table!  We use this to attach additional data structures we
   need while linking on the h8300.  */
struct h8300_coff_link_hash_table
{
  /* The main hash table.  */
  struct generic_link_hash_table root;

  /* Section for the vectors table.  This gets attached to a
     random input bfd, we keep it here for easy access.  */
  asection *vectors_sec;

  /* Hash table of the functions we need to enter into the function
     vector.  */
  struct funcvec_hash_table *funcvec_hash_table;
};

static struct bfd_link_hash_table *h8300_coff_link_hash_table_create
  PARAMS ((bfd *));

/* Get the H8/300 COFF linker hash table from a link_info structure.  */

#define h8300_coff_hash_table(p) \
  ((struct h8300_coff_link_hash_table *) ((coff_hash_table (p))))

/* Initialize fields within a funcvec hash table entry.  Called whenever
   a new entry is added to the funcvec hash table.  */

static struct bfd_hash_entry *
funcvec_hash_newfunc (entry, gen_table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *gen_table;
     const char *string;
{
  struct funcvec_hash_entry *ret;
  struct funcvec_hash_table *table;

  ret = (struct funcvec_hash_entry *) entry;
  table = (struct funcvec_hash_table *) gen_table;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = ((struct funcvec_hash_entry *)
           bfd_hash_allocate (gen_table,
                              sizeof (struct funcvec_hash_entry)));
  if (ret == NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct funcvec_hash_entry *)
         bfd_hash_newfunc ((struct bfd_hash_entry *) ret, gen_table, string));

  if (ret == NULL)
    return NULL;

  /* Note where this entry will reside in the function vector table.  */
  ret->offset = table->offset;

  /* Bump the offset at which we store entries in the function
     vector.  We'd like to bump up the size of the vectors section,
     but it's not easily available here.  */
  if (bfd_get_mach (table->abfd) == bfd_mach_h8300)
    table->offset += 2;
  else if (bfd_get_mach (table->abfd) == bfd_mach_h8300h)
    table->offset += 4;
  else
    return NULL;

  /* Everything went OK.  */
  return (struct bfd_hash_entry *) ret;
}

/* Initialize the function vector hash table.  */

static boolean
funcvec_hash_table_init (table, abfd, newfunc)
     struct funcvec_hash_table *table;
     bfd *abfd;
     struct bfd_hash_entry *(*newfunc) PARAMS ((struct bfd_hash_entry *,
                                                struct bfd_hash_table *,
                                                const char *));
{
  /* Initialize our local fields, then call the generic initialization
     routine.  */
  table->offset = 0;
  table->abfd = abfd;
  return (bfd_hash_table_init (&table->root, newfunc));
}

/* Create the derived linker hash table.  We use a derived hash table
   basically to hold "static" information during an h8/300 coff link
   without using static variables.  */

static struct bfd_link_hash_table *
h8300_coff_link_hash_table_create (abfd)
     bfd *abfd;
{
  struct h8300_coff_link_hash_table *ret;
  ret = ((struct h8300_coff_link_hash_table *)
         bfd_alloc (abfd, sizeof (struct h8300_coff_link_hash_table)));
  if (ret == NULL)
    return NULL;
  if (!_bfd_link_hash_table_init (&ret->root.root, abfd, _bfd_generic_link_hash_newfunc))
    {
      bfd_release (abfd, ret);
      return NULL;
    }

  /* Initialize our data.  */
  ret->vectors_sec = NULL;
  ret->funcvec_hash_table = NULL;

  /* OK.  Everything's intialized, return the base pointer.  */
  return &ret->root.root;
}
d67 2
a68 2
  HOWTO (R_MOV16B1, 0, 1, 16, false, 0, complain_overflow_bitfield, special, "relaxable mov.b:16", false, 0x0000ffff, 0x0000ffff, false),
  HOWTO (R_MOV16B2, 0, 1, 8, false, 0, complain_overflow_bitfield, special, "relaxed mov.b:16", false, 0x000000ff, 0x000000ff, false),
d71 2
d74 1
a74 12
  HOWTO (R_JMPL2, 0, 0, 8, false, 0, complain_overflow_bitfield, special, "pc8/24", false, 0x000000ff, 0x000000ff, false),
  HOWTO (R_MOV24B1, 0, 1, 32, false, 0, complain_overflow_bitfield, special, "relaxable mov.b:24", false, 0xffffffff, 0xffffffff, false),
  HOWTO (R_MOV24B2, 0, 1, 8, false, 0, complain_overflow_bitfield, special, "relaxed mov.b:24", false, 0x0000ffff, 0x0000ffff, false),

  /* An indirect reference to a function.  This causes the function's address
     to be added to the function vector in lo-mem and puts the address of
     the function vector's entry in the jsr instruction.  */
  HOWTO (R_MEM_INDIRECT, 0, 0, 8, false, 0, complain_overflow_bitfield, special, "8/indirect", false, 0x000000ff, 0x000000ff, false),

  /* Internal reloc for relaxing.  This is created when a 16bit pc-relative
     branch is turned into an 8bit pc-relative branch.  */
  HOWTO (R_PCRWORD_B, 0, 0, 8, true, 0, complain_overflow_bitfield, special, "relaxed bCC:16", false, 0x000000ff, 0x000000ff, false),
d76 2
a77 3
  HOWTO (R_MOVL1, 0, 2, 32, false, 0, complain_overflow_bitfield,special, "32/24 relaxable move", false, 0xffffffff, 0xffffffff, false),

  HOWTO (R_MOVL2, 0, 1, 16, false, 0, complain_overflow_bitfield, special, "32/24 relaxed move", false, 0x0000ffff, 0x0000ffff, false),
d136 1
a136 1
    case R_MOV16B1:
d139 1
a139 1
    case R_MOV16B2:
d151 1
a151 1
    case R_JMPL2:
d154 1
a154 1
    case R_MOV24B1:
d157 1
a157 1
    case R_MOV24B2:
a159 12
    case R_MEM_INDIRECT:
      internal->howto = howto_table + 14;
      break;
    case R_PCRWORD_B:
      internal->howto = howto_table + 15;
      break;
    case R_MOVL1:
      internal->howto = howto_table + 16;
      break;
    case R_MOVL2:
      internal->howto = howto_table + 17;
      break;
a206 7
/* If RELOC represents a relaxable instruction/reloc, change it into
   the relaxed reloc, notify the linker that symbol addresses
   have changed (bfd_perform_slip) and return how much the current
   section has shrunk by.

   FIXME: Much of this code has knowledge of the ordering of entries
   in the howto table.  This needs to be fixed.  */
d221 6
a226 3
     the size of the shrink - but we don't change reloc->address here,
     since we need it to know where the relocation lives in the source
     uncooked section.  */
d228 1
a229 1
  /* Only examine the relocs which might be relaxable.  */
d232 4
d237 2
a238 5
    /* This is the 16/24 bit absolute branch which could become an 8 bit
       pc-relative branch.  */
    case R_JMP1:
    case R_JMPL1:
      /* Get the address of the target of this branch.  */
d241 2
a242 3
      /* Get the address of the next instruction (not the reloc).  */
      dot = (input_section->output_section->vma
	     + input_section->output_offset + address + 2);
d244 2
a245 8
      /* Compute the distance from this insn to the branch target.  */
      gap = value - dot;
  
      /* If the distance is within -128..+126 inclusive, then we can relax
	 this jump.  */
      if ((int)gap >= -128 && (int)gap <= 126 )
	{ 
	  /* Change the reloc type.  */
d247 2
a248 2

	  /* This shrinks this section by two bytes.  */
d251 2
a252 1
	}
d254 3
d258 1
a258 4
    /* This is the 16 bit pc-relative branch which could become an 8 bit
       pc-relative branch.  */
    case R_PCRWORD:
      /* Get the address of the target of this branch.  */
a260 1
      /* Get the address of the next instruction.  */
d262 1
a262 1
	input_section->output_offset + address - 1;
d264 3
a266 2
      /* Compute the distance from this insn to the branch target.  */
      gap = value - dot;
d268 3
a270 3
      /* If the distance is within -128..+126 inclusive, then we can relax
	 this jump.  */
      if ((int)gap >= -128 && (int)gap <= 126 )
a271 2
	  /* Change the reloc type.  */
	  reloc->howto = howto_table + 15;
d273 4
a276 1
	  /* This shrinks this section by two bytes.  */
d282 1
a282 24
    /* This is a 16 bit absolute address in a mov.b insn, which can
       become an 8 bit absolute address if it's in the right range.  */
    case R_MOV16B1:
      /* Get the address of the data referenced by this mov.b insn.  */
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);

      /* The address is in 0xff00..0xffff inclusive on the h8300 or
	 0xffff00..0xffffff inclusive on the h8300h, then we can
	 relax this mov.b  */
      if ((bfd_get_mach (abfd) == bfd_mach_h8300
	   && value >= 0xff00
	   && value <= 0xffff)
	  || (bfd_get_mach (abfd) == bfd_mach_h8300h
	      && value >= 0xffff00
	      && value <= 0xffffff))
	{
	  /* Change the reloc type.  */
	  reloc->howto = reloc->howto + 1;

	  /* This shrinks this section by two bytes.  */
	  shrink += 2;
	  bfd_perform_slip(abfd, 2, input_section, address);
	}
      break;
a283 5
    /* Similarly for a 24 bit absolute address in a mov.b.  Note that
       if we can't relax this into an 8 bit absolute, we'll fall through
       and try to relax it into a 16bit absolute.  */
    case R_MOV24B1:
      /* Get the address of the data referenced by this mov.b insn.  */
d285 7
d293 2
a294 8
      /* The address is in 0xffff00..0xffffff inclusive on the h8300h,
	 then we can relax this mov.b  */
      if (bfd_get_mach (abfd) == bfd_mach_h8300h
	  && value >= 0xffff00
	  && value <= 0xffffff)
	{
	  /* Change the reloc type.  */
	  reloc->howto = reloc->howto + 1;
d296 2
a297 3
	  /* This shrinks this section by four bytes.  */
	  shrink += 4;
	  bfd_perform_slip(abfd, 4, input_section, address);
d299 4
a302 6
	  /* Done with this reloc.  */
	  break;
	}

      /* FALLTHROUGH and try to turn the 32/24 bit reloc into a 16 bit
	 reloc.  */
d304 1
a304 14
    /* This is a 24/32 bit absolute address in a mov insn, which can
       become an 16 bit absolute address if it's in the right range.  */
    case R_MOVL1:
      /* Get the address of the data referenced by this mov insn.  */
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);

      /* If this address is in 0x0000..0x7fff inclusive or
         0xff8000..0xffffff inclusive, then it can be relaxed.  */
      if (value <= 0x7fff || value >= 0xff8000)
	{
	  /* Change the reloc type.  */
	  reloc->howto = howto_table + 17;

	  /* This shrinks this section by two bytes.  */
a308 4

      /* No other reloc types represent relaxing opportunities.  */
      default:
	break;
d311 1
d316 1
a316 2
/* Handle relocations for the H8/300, including relocs for relaxed
   instructions.
d318 8
a325 1
   FIXME: Not all relocations check for overflow!  */
a340 3
  bfd_vma value;
  bfd_vma dot;
  int gap,tmp;
d344 2
a345 2

    /* Generic 8bit pc-relative relocation.  */
d347 18
a364 2
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
d366 2
a367 27
      dot = (link_order->offset 
	     + dst_address 
	     + link_order->u.indirect.section->output_section->vma);

      gap = value - dot;

      /* Sanity check.  */
      if (gap < -128 || gap > 126)
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}

      /* Everything looks OK.  Apply the relocation and update the
	 src/dst address appropriately.  */

      bfd_put_8 (abfd, gap, data + dst_address);
      dst_address++;
      src_address++;

      /* All done.  */
      break;

    /* Generic 16bit pc-relative relocation.  */
d369 14
a382 2
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
d384 3
a386 4
      /* Get the address of the instruction (not the reloc).  */
      dot = (link_order->offset 
	     + dst_address 
	     + link_order->u.indirect.section->output_section->vma + 1);
d388 2
a389 1
      gap = value - dot;
a390 21
      /* Sanity check.  */
      if (gap > 32766 || gap < -32768)
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}

      /* Everything looks OK.  Apply the relocation and update the
	 src/dst address appropriately.  */

      bfd_put_16 (abfd, gap, data + dst_address);
      dst_address+=2;
      src_address+=2;

      /* All done.  */
      break;

    /* Generic 8bit absolute relocation.  */
d392 24
a415 26
      /* Get the address of the object referenced by this insn.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      /* Sanity check.  */
      if (value < 0xff 
	  || (value >= 0x0000ff00 && value <= 0x0000ffff)
  	  || (value >= 0x00ffff00 && value <= 0x00ffffff)
	  || (value >= 0xffffff00 && value <= 0xffffffff))
	{
	  /* Everything looks OK.  Apply the relocation and update the
	     src/dst address appropriately.  */

	  bfd_put_8 (abfd, gap, data + dst_address);
	  dst_address += 1;
	  src_address += 1;
	}
      else
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}

      /* All done.  */
a416 3

    /* Various simple 16bit absolute relocations.  */
    case R_MOV16B1:
d418 4
d423 3
a425 2
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);
      bfd_put_16 (abfd, value, data + dst_address);
a428 4

    /* Various simple 24/32bit absolute relocations.  */
    case R_MOV24B1:
    case R_MOVL1:
d430 3
a432 3
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section),
      bfd_put_32 (abfd, value, data + dst_address);
d437 11
a447 19
    /* Another 24/32bit absolute relocation.  */
    case R_JMPL1:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      value = ((value & 0x00ffffff)
	       | (bfd_get_32 (abfd, data + src_address) & 0xff000000));
      bfd_put_32 (abfd, value, data + dst_address);
      dst_address += 4;
      src_address += 4;
      break;

    /* A 16bit abolute relocation that was formerlly a 24/32bit
       absolute relocation.  */
    case R_MOVL2:
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      /* Sanity check.  */
      if (value < 0x8000 || value > 0xff8000)
d449 3
a451 47
	  /* Insert the 16bit value into the proper location.  */
	  bfd_put_16 (abfd, value, data + dst_address);

	  /* Fix the opcode.  For all the move insns, we simply
	     need to turn off bit 0x20 in the previous byte.  */
          data[dst_address - 1] &= ~0x20;
	  dst_address+=2;
	  src_address+=4;
	}
      else
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
        }
      break;

    /* A 16bit absolute branch that is now an 8-bit pc-relative branch.  */
    case R_JMP2:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      /* Get the address of the next instruction.  */
      dot = (link_order->offset
	     + dst_address
	     + link_order->u.indirect.section->output_section->vma + 1);

      gap = value - dot;

      /* Sanity check.  */
      if (gap < -128 || gap > 126)
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}

      /* Now fix the instruction itself.  */
      switch (data[dst_address - 1])
	{
	case 0x5e:
	  /* jsr -> bsr */
	  bfd_put_8 (abfd, 0x55, data + dst_address - 1);
d453 3
a455 3
	case 0x5a:
	  /* jmp ->bra */
	  bfd_put_8 (abfd, 0x40, data + dst_address - 1);
a456 1

d461 6
a466 2
      /* Write out the 8bit value.  */
      bfd_put_8 (abfd, gap, data + dst_address);
d468 2
d475 1
a475 51
    /* A 16bit pc-relative branch that is now an 8-bit pc-relative branch.  */
    case R_PCRWORD_B:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      /* Get the address of the instruction (not the reloc).  */
      dot = (link_order->offset
	     + dst_address
	     + link_order->u.indirect.section->output_section->vma - 1);

      gap = value - dot;

      /* Sanity check.  */
      if (gap < -128 || gap > 126)
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}

      /* Now fix the instruction.  */
      switch (data[dst_address - 2])
	{
	case 0x58:
	  /* bCC:16 -> bCC:8 */
	  /* Get the condition code from the original insn.  */
	  tmp = data[dst_address - 1];
	  tmp &= 0xf0;
	  tmp >>= 4;

	  /* Now or in the high nibble of the opcode.  */
	  tmp |= 0x40;

	  /* Write it.  */
	  bfd_put_8 (abfd, tmp, data + dst_address - 2);
	  break;

	default:
	  abort ();
	}

	/* Output the target.  */
	bfd_put_8 (abfd, gap, data + dst_address - 1);

	/* We don't advance dst_address -- the 8bit reloc is applied at
	   dst_address - 1, so the next insn should begin at dst_address.  */
	src_address += 2;

	break;
d477 5
a481 9
    /* Similarly for a 24bit absolute that is now 8 bits.  */
    case R_JMPL2:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);

      /* Get the address of the instruction (not the reloc).  */
      dot = (link_order->offset
	     + dst_address
	     + link_order->u.indirect.section->output_section->vma + 2);
d483 2
a484 1
      gap = value - dot;
d486 1
a486 12
      /* Fix the instruction.  */
      switch (data[src_address])
	{
	case 0x5e:
	  /* jsr -> bsr */
	  bfd_put_8 (abfd, 0x55, data + dst_address);
	  break;
	case 0x5a:
	  /* jmp ->bra */
	  bfd_put_8 (abfd, 0x40, data + dst_address);
	  break;
	default:
a487 1
	}
d489 1
a489 3
      bfd_put_8 (abfd, gap, data + dst_address + 1);
      dst_address += 2;
      src_address += 4;
d491 10
a500 1
      break;
d502 5
a506 3
    /* A 16bit absolute mov.b that is now an 8bit absolute mov.b.  */
    case R_MOV16B2:
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
d508 2
a509 19
      /* Sanity check.  */
      if (data[dst_address - 2] != 0x6a)
	abort ();

      /* Fix up the opcode.  */
      switch (data[src_address-1] & 0xf0)
	{
	case 0x00:
	  data[dst_address - 2] = (data[src_address-1] & 0xf) | 0x20;
	  break;
	case 0x80:
	  data[dst_address - 2] = (data[src_address-1] & 0xf) | 0x30;
	  break;
	default:
	  abort ();
	}

      bfd_put_8 (abfd, value & 0xff, data + dst_address - 1);
      src_address += 2;
d511 8
d520 2
a521 3
    /* Similarly for a 24bit mov.b  */
    case R_MOV24B2:
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
d523 1
a523 14
      /* Sanity check.  */
      if (data[dst_address - 2] != 0x6a)
	abort ();

      /* Fix up the opcode.  */
      switch (data[src_address-1] & 0xf0)
	{
	case 0x20:
	  data[dst_address - 2] = (data[src_address-1] & 0xf) | 0x20;
	  break;
	case 0xa0:
	  data[dst_address - 2] = (data[src_address-1] & 0xf) | 0x30;
	  break;
	default:
a524 10
	}

      bfd_put_8 (abfd, value & 0xff, data + dst_address - 1);
      src_address += 4;
      break;

    /* An 8bit memory indirect instruction (jmp/jsr).

       There's several things that need to be done to handle
       this relocation.
d526 1
a526 23
       If this is a reloc against the absolute symbol, then
       we should handle it just R_RELBYTE.  Likewise if it's
       for a symbol with a value ge 0 and le 0xff.

       Otherwise it's a jump/call through the function vector,
       and the linker is expected to set up the function vector
       and put the right value into the jump/call instruction.  */
    case R_MEM_INDIRECT:
      {
	/* We need to find the symbol so we can determine it's
	   address in the function vector table.  */
	asymbol *symbol;
	bfd_vma value;
	char *name;
	struct funcvec_hash_entry *h;
	asection *vectors_sec = h8300_coff_hash_table (link_info)->vectors_sec;

	/* First see if this is a reloc against the absolute symbol
	   or against a symbol with a nonnegative value <= 0xff.  */
	symbol = *(reloc->sym_ptr_ptr);
	value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
	if (symbol == bfd_abs_section_ptr->symbol
	    || (value >= 0 && value <= 0xff))
d528 7
a534 18
	    /* This should be handled in a manner very similar to
	       R_RELBYTES.   If the value is in range, then just slam
	       the value into the right location.  Else trigger a
	       reloc overflow callback.  */
	    if (value >= 0 && value <= 0xff)
	      {
		bfd_put_8 (abfd, value, data + dst_address);
		dst_address += 1;
		src_address += 1;
	      }
	    else
	      {
		if (! ((*link_info->callbacks->reloc_overflow)
		       (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
			reloc->howto->name, reloc->addend, input_section->owner,
			input_section, reloc->address)))
		  abort ();
	      }
a535 1
	  }
d537 3
a539 17
	/* This is a jump/call through a function vector, and we're
	   expected to create the function vector ourselves. 

	   First look up this symbol in the linker hash table -- we need
	   the derived linker symbol which holds this symbol's index
	   in the function vector.  */
	name = symbol->name;
	if (symbol->flags & BSF_LOCAL)
	  {
	    char *new_name = bfd_malloc (strlen (name) + 9);
	    if (new_name == NULL)
	      abort ();

	    strcpy (new_name, name);
	    sprintf (new_name + strlen (name), "_%08x",
		     (int)symbol->section);
	    name = new_name;
d542 3
a544 2
	h = funcvec_hash_lookup (h8300_coff_hash_table (link_info)->funcvec_hash_table,
				 name, false, false);
d546 2
a547 5
	/* This shouldn't ever happen.  If it does that means we've got
	   data corruption of some kind.  Aborting seems like a reasonable
	   think to do here.  */
	if (h == NULL || vectors_sec == NULL)
	  abort ();
d549 9
a557 5
	/* Place the address of the function vector entry into the
	   reloc's address.  */
	bfd_put_8 (abfd,
		   vectors_sec->output_offset + h->offset,
		   data + dst_address);
d559 1
a559 2
	dst_address++;
	src_address++;
a560 15
	/* Now create an entry in the function vector itself.  */
	if (bfd_get_mach (input_section->owner) == bfd_mach_h8300)
	  bfd_put_16 (abfd,
		      bfd_coff_reloc16_get_value (reloc,
						  link_info,
						  input_section),
		      vectors_sec->contents + h->offset);
	else if (bfd_get_mach (input_section->owner) == bfd_mach_h8300h)
	  bfd_put_32 (abfd,
		      bfd_coff_reloc16_get_value (reloc,
						  link_info,
						  input_section),
		      vectors_sec->contents + h->offset);
	else
	  abort ();
d562 10
a571 8
	/* Gross.  We've already written the contents of the vector section
	   before we get here...  So we write it again with the new data.  */
	bfd_set_section_contents (vectors_sec->output_section->owner,
				  vectors_sec->output_section,
				  vectors_sec->contents,
				  vectors_sec->output_offset,
				  vectors_sec->_raw_size);
	break;
d574 1
d576 1
a580 1

a582 164
}


/* Routine for the h8300 linker.

   This routine is necessary to handle the special R_MEM_INDIRECT
   relocs on the h8300.  It's responsible for generating a vectors
   section and attaching it to an input bfd as well as sizing
   the vectors section.  It also creates our vectors hash table.

   It uses the generic linker routines to actually add the symbols.
   from this BFD to the bfd linker hash table.  It may add a few
   selected static symbols to the bfd linker hash table.  */

static boolean
h8300_bfd_link_add_symbols(abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  asection *sec;
  struct funcvec_hash_table *funcvec_hash_table;

  /* If we haven't created a vectors section, do so now.  */
  if (!h8300_coff_hash_table (info)->vectors_sec)
    {
      flagword flags;

      /* Make sure the appropriate flags are set, including SEC_IN_MEMORY.  */
      flags = (SEC_ALLOC | SEC_LOAD
	       | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_READONLY);
      h8300_coff_hash_table (info)->vectors_sec = bfd_make_section (abfd,
								    ".vectors");

      /* If the section wasn't created, or we couldn't set the flags,
	 quit quickly now, rather than dieing a painful death later.  */
      if (! h8300_coff_hash_table (info)->vectors_sec
	  || ! bfd_set_section_flags (abfd,
				      h8300_coff_hash_table(info)->vectors_sec,
				      flags))
	return false;

      /* Also create the vector hash table.  */
      funcvec_hash_table = ((struct funcvec_hash_table *)
	bfd_alloc (abfd, sizeof (struct funcvec_hash_table)));

      if (!funcvec_hash_table)
	return false;

      /* And initialize the funcvec hash table.  */
      if (!funcvec_hash_table_init (funcvec_hash_table, abfd,
				    funcvec_hash_newfunc))
	{
	  bfd_release (abfd, funcvec_hash_table);
	  return false;
	}

      /* Store away a pointer to the funcvec hash table.  */
      h8300_coff_hash_table (info)->funcvec_hash_table = funcvec_hash_table;
    }

  /* Load up the function vector hash table.  */
  funcvec_hash_table = h8300_coff_hash_table (info)->funcvec_hash_table;

  /* Add the symbols using the generic code.  */
  _bfd_generic_link_add_symbols (abfd, info);

  /* Now scan the relocs for all the sections in this bfd; create
     additional space in the .vectors section as needed.  */
  for (sec = abfd->sections; sec; sec = sec->next)
    {
      unsigned long reloc_size, reloc_count, i;
      asymbol **symbols;
      arelent **relocs;

      /* Suck in the relocs, symbols & canonicalize them.  */
      reloc_size = bfd_get_reloc_upper_bound (abfd, sec);
      if (reloc_size <= 0)
	continue;

      relocs = (arelent **)bfd_malloc ((size_t)reloc_size);
      if (!relocs)
	return false;

      /* The symbols should have been read in by _bfd_generic link_add_symbols
	 call abovec, so we can cheat and use the pointer to them that was
	 saved in the above call.  */
      symbols = _bfd_generic_link_get_symbols(abfd);
      reloc_count = bfd_canonicalize_reloc (abfd, sec, relocs, symbols);

      /* Now walk through all the relocations in this section.  */
      for (i = 0; i < reloc_count; i++)
	{
	  arelent *reloc = relocs[i];
	  asymbol *symbol = *(reloc->sym_ptr_ptr);
	  char *name;

	  /* We've got an indirect reloc.  See if we need to add it
	     to the function vector table.   At this point, we have
	     to add a new entry for each unique symbol referenced
	     by an R_MEM_INDIRECT relocation except for a reloc
	     against the absolute section symbol.  */
	  if (reloc->howto->type == R_MEM_INDIRECT
	      && symbol != bfd_abs_section_ptr->symbol)

	    {
	      struct funcvec_hash_entry *h;

	      name = symbol->name;
	      if (symbol->flags & BSF_LOCAL)
		{
		  char *new_name = bfd_malloc (strlen (name) + 9);

		  if (new_name == NULL)
		    abort ();

		  strcpy (new_name, name);
		  sprintf (new_name + strlen (name), "_%08x",
			   (int)symbol->section);
		  name = new_name;
		}

	      /* Look this symbol up in the function vector hash table.  */
	      h = funcvec_hash_lookup (h8300_coff_hash_table (info)->funcvec_hash_table,
				       name, false, false);


	      /* If this symbol isn't already in the hash table, add
		 it and bump up the size of the hash table.  */
	      if (h == NULL)
		{
		  h = funcvec_hash_lookup (h8300_coff_hash_table (info)->funcvec_hash_table,
					   name, true, true);
		  if (h == NULL)
		    {
		      free (relocs);
		      return false;
		    }

		  /* Bump the size of the vectors section.  Each vector
		     takes 2 bytes on the h8300 and 4 bytes on the h8300h.  */
		  if (bfd_get_mach (abfd) == bfd_mach_h8300)
		    h8300_coff_hash_table (info)->vectors_sec->_raw_size += 2;
		  else if (bfd_get_mach (abfd) == bfd_mach_h8300h)
		    h8300_coff_hash_table (info)->vectors_sec->_raw_size += 4;
		}
	    }
	}

      /* We're done with the relocations, release them.  */
      free (relocs);
    }

  /* Now actually allocate some space for the function vector.  It's
     wasteful to do this more than once, but this is easier.  */
  if (h8300_coff_hash_table (info)->vectors_sec->_raw_size != 0)
    {
      /* Free the old contents.  */
      if (h8300_coff_hash_table (info)->vectors_sec->contents)
	free (h8300_coff_hash_table (info)->vectors_sec->contents);

      /* Allocate new contents.  */
      h8300_coff_hash_table (info)->vectors_sec->contents
	= bfd_malloc (h8300_coff_hash_table (info)->vectors_sec->_raw_size);
    }
a583 1
  return true;
a587 2
#define coff_bfd_link_add_symbols h8300_bfd_link_add_symbols
#define coff_bfd_link_hash_table_create h8300_coff_link_hash_table_create
d605 2
a606 2
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d141 1
a141 2
  else if (bfd_get_mach (table->abfd) == bfd_mach_h8300h
	   || bfd_get_mach (table->abfd) == bfd_mach_h8300s)
a249 3
  HOWTO (R_BCC_INV, 0, 0, 8, true, 0, complain_overflow_signed, special, "DISP8 inverted", false, 0x000000ff, 0x000000ff, true),

  HOWTO (R_JMP_DEL, 0, 0, 8, true, 0, complain_overflow_signed, special, "Deleted jump", false, 0x000000ff, 0x000000ff, true),
d258 1
a258 1
#define BADMAG(x) (H8300BADMAG(x) && H8300HBADMAG(x) && H8300SBADMAG(x))
a342 6
    case R_BCC_INV:
      internal->howto = howto_table + 18;
      break;
    case R_JMP_DEL:
      internal->howto = howto_table + 19;
      break;
a389 27
static boolean
h8300_symbol_address_p (abfd, input_section, address)
     bfd *abfd;
     asection *input_section;
     bfd_vma address;
{
  asymbol **s;

  s = _bfd_generic_link_get_symbols (abfd);
  BFD_ASSERT (s != (asymbol **) NULL);

  /* Search all the symbols for one in INPUT_SECTION with
     address ADDRESS.  */
  while (*s) 
    {
      asymbol *p = *s;
      if (p->section == input_section
	  && (input_section->output_section->vma
	      + input_section->output_offset
	      + p->value) == address)
	return true;
      s++;
    }    
  return false;
}


a408 2
  static asection *last_input_section = NULL;
  static arelent *last_reloc = NULL;
a415 3
  if (input_section != last_input_section)
    last_reloc = NULL;

d429 1
a429 4
	     + input_section->output_offset + address);

      /* Adjust for R_JMP1 vs R_JMPL1.  */
      dot += (reloc->howto->type == R_JMP1 ? 1 : 2);
d434 3
a436 4
      /* If the distance is within -128..+128 inclusive, then we can relax
	 this jump.  +128 is valid since the target will move two bytes
	 closer if we do relax this branch.  */
      if ((int)gap >= -128 && (int)gap <= 128 )
a437 36

	  /* It's possible we may be able to eliminate this branch entirely;
	     if the previous instruction is a branch around this instruction,
	     and there's no label at this instruction, then we can reverse
	     the condition on the previous branch and eliminate this jump.

	       original:			new:
		 bCC lab1			bCC' lab2
		 jmp lab2
		lab1:				lab1:
	
	     This saves 4 bytes instead of two, and should be relatively
	     common.  */

	  if (gap <= 126
	      && last_reloc
	      && last_reloc->howto->type == R_PCRBYTE)
	    {
	      bfd_vma last_value;
	      last_value = bfd_coff_reloc16_get_value (last_reloc, link_info,
						       input_section) + 1;

	      if (last_value == dot + 2
		  && last_reloc->address + 1 == reloc->address
		  && ! h8300_symbol_address_p (abfd, input_section, dot - 2))
		{
		  reloc->howto = howto_table + 19;
		  last_reloc->howto = howto_table + 18;
		  last_reloc->sym_ptr_ptr = reloc->sym_ptr_ptr;
		  last_reloc->addend = reloc->addend;
		  shrink += 4;
		  bfd_perform_slip (abfd, 4, input_section, address);
		  break;
		}
	    }

d442 1
a442 1
	  shrink += 2;
d450 2
a451 3
      /* Get the address of the target of this branch, add one to the value
         because the addend field in PCrel jumps is off by -1.  */
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section) + 1;
d453 1
a453 1
      /* Get the address of the next instruction if we were to relax.  */
d455 1
a455 1
	input_section->output_offset + address;
d460 3
a462 4
      /* If the distance is within -128..+128 inclusive, then we can relax
	 this jump.  +128 is valid since the target will move two bytes
	 closer if we do relax this branch.  */
      if ((int)gap >= -128 && (int)gap <= 128 )
d468 1
a468 1
	  shrink += 2;
d485 1
a485 2
	  || ((bfd_get_mach (abfd) == bfd_mach_h8300h
	       || bfd_get_mach (abfd) == bfd_mach_h8300s)
d507 1
a507 2
      if ((bfd_get_mach (abfd) == bfd_mach_h8300h
	   || bfd_get_mach (abfd) == bfd_mach_h8300s)
d539 1
a539 1
	  shrink += 2;
a548 2
  last_reloc = reloc;
  last_input_section = input_section;
d636 2
a637 2
      dst_address += 2;
      src_address += 2;
d656 1
a656 1
	  bfd_put_8 (abfd, value & 0xff, data + dst_address);
d719 2
a720 2
	  dst_address += 2;
	  src_address += 4;
a912 36
    case R_BCC_INV:
      /* Get the address of the target of this branch.  */
      value = bfd_coff_reloc16_get_value(reloc, link_info, input_section);

      dot = (link_order->offset 
	     + dst_address 
	     + link_order->u.indirect.section->output_section->vma) + 1;

      gap = value - dot;

      /* Sanity check.  */
      if (gap < -128 || gap > 126)
	{
	  if (! ((*link_info->callbacks->reloc_overflow)
		 (link_info, bfd_asymbol_name (*reloc->sym_ptr_ptr),
		  reloc->howto->name, reloc->addend, input_section->owner,
		  input_section, reloc->address)))
	    abort ();
	}

      /* Everything looks OK.  Fix the condition in the instruction, apply
	 the relocation, and update the src/dst address appropriately.  */

      bfd_put_8 (abfd, bfd_get_8 (abfd, data + dst_address - 1) ^ 1,
		 data + dst_address - 1);
      bfd_put_8 (abfd, gap, data + dst_address);
      dst_address++;
      src_address++;

      /* All done.  */
      break;

    case R_JMP_DEL:
      src_address += 4;
      break;

d931 1
a931 1
	const char *name;
d1007 1
a1007 2
	else if (bfd_get_mach (input_section->owner) == bfd_mach_h8300h
		 || bfd_get_mach (input_section->owner) == bfd_mach_h8300s)
d1128 1
a1128 1
	  const char *name;
d1176 1
a1176 2
		  else if (bfd_get_mach (abfd) == bfd_mach_h8300h
			   || bfd_get_mach (abfd) == bfd_mach_h8300s)
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d23 1
d362 1
a362 1
/* Perform any necessary magic to the addend in a reloc entry */
d736 1
a736 1
      if (value <= 0xff
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
   Free Software Foundation, Inc.
d206 5
a210 5
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
d212 1
a212 1
     char **error_message ATTRIBUTE_UNUSED;
d798 1
a798 1
      if (value <= 0x7fff || value >= 0xff8000)
d1063 1
a1063 1
	    || value <= 0xff)
d1069 1
a1069 1
	    if (value <= 0xff)
d1228 1
a1228 1
      long reloc_size, reloc_count, i;
a1245 5
      if (reloc_count <= 0)
	{
	  free (relocs);
	  continue;
	}
d1343 41
a1383 1
CREATE_BIG_COFF_TARGET_VEC (h8300coff_vec, "coff-h8300", BFD_IS_RELAXABLE, 0, '_', NULL)
@


1.1.1.6
log
@Long delayed import of binutils-2.10.1. Turns out art@@ needs some alpha
bug-fixes...
@
text
@d195 1
a195 1
/* Special handling for H8/300 relocs.
d201 2
a202 2
   contain the offset required for the branch, so we have to use only
   the addend until the final link.  */
d206 1
a206 1
	 error_message)
a217 2
  /* Adjust the reloc address to that in the output section.  */
  reloc_entry->address += input_section->output_offset;
a902 5
	  break;

	case 0x5c:
	  /* bsr:16 -> bsr:8 */
	  bfd_put_8 (abfd, 0x55, data + dst_address - 2);
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000
d34 1
a34 1
   hold entries in the function vector.  Aside from the
d199 1
a199 1
   the pcrel branches.  This isn't so, since the H8/300 can do relaxing,
d258 2
a259 1
/* Turn a howto into a reloc number.  */
d268 3
a270 1
/* Code to swap in the reloc.  */
d277 1
d285 2
a286 1
/* Code to turn a r_type into a howto ptr, uses the above howto table.  */
d363 3
a365 1
/* Perform any necessary magic to the addend in a reloc entry.  */
d370 1
d376 1
a376 1
     arelent *relent;
d378 3
a380 3
     asymbol **symbols;
     bfd *abfd;
     asection *section;
d394 2
d399 1
a399 3
#if 0
  relent->section = 0;
#endif
d415 1
a415 1
  while (*s)
d424 1
a424 1
    }
d428 1
d438 1
a438 1
h8300_reloc16_estimate (abfd, input_section, reloc, shrink, link_info)
d445 1
a445 1
  bfd_vma value;
d451 1
a451 1
  /* The address of the thing to be relocated will have moved back by
d462 2
a463 1
    {
d469 1
a469 1
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
d480 1
a480 1

d485 2
a486 1
	{
d496 1
a496 1

d510 1
a510 1
		  && !h8300_symbol_address_p (abfd, input_section, dot - 2))
d523 1
a523 1
	  reloc->howto = reloc->howto + 1;
d527 1
a527 1
	  bfd_perform_slip (abfd, 2, input_section, address);
d536 2
a537 2
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section) + 1;

d541 1
a541 1

d549 1
a549 1
	{
d555 1
a555 1
	  bfd_perform_slip (abfd, 2, input_section, address);
d563 1
a563 1
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
d581 1
a581 1
	  bfd_perform_slip (abfd, 2, input_section, address);
d590 1
a590 1
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
d604 1
a604 1
	  bfd_perform_slip (abfd, 4, input_section, address);
d617 1
a617 1
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
d628 1
a628 1
	  bfd_perform_slip (abfd, 2, input_section, address);
d633 2
a634 2
    default:
      break;
d642 1
d664 1
a664 1
  int gap, tmp;
d668 1
d672 1
a672 1
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
d674 2
a675 2
      dot = (link_order->offset
	     + dst_address
d703 1
a703 1
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
d706 2
a707 2
      dot = (link_order->offset
	     + dst_address
d766 1
a766 1
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
d777 1
a777 1
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
d924 1
a924 1

d967 1
a967 1
      switch (data[src_address - 1] & 0xf0)
d970 1
a970 1
	  data[dst_address - 2] = (data[src_address - 1] & 0xf) | 0x20;
d973 1
a973 1
	  data[dst_address - 2] = (data[src_address - 1] & 0xf) | 0x30;
d992 1
a992 1
      switch (data[src_address - 1] & 0xf0)
d995 1
a995 1
	  data[dst_address - 2] = (data[src_address - 1] & 0xf) | 0x20;
d998 1
a998 1
	  data[dst_address - 2] = (data[src_address - 1] & 0xf) | 0x30;
d1010 1
a1010 1
      value = bfd_coff_reloc16_get_value (reloc, link_info, input_section);
d1012 2
a1013 2
      dot = (link_order->offset
	     + dst_address
d1095 1
a1095 1
	   expected to create the function vector ourselves.
d1109 1
a1109 1
		     (int) symbol->section);
d1168 1
d1181 1
a1181 1
h8300_bfd_link_add_symbols (abfd, info)
d1245 1
a1245 1
      relocs = (arelent **) bfd_malloc ((size_t) reloc_size);
d1288 1
a1288 1
			   (int) symbol->section);
d1296 1
d1348 1
d1354 1
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d1 1
a1 1
/* BFD back-end for Renesas H8/300 COFF binaries.
d3 1
a3 1
   2000, 2001, 2002, 2003
d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a30 1
#include "libiberty.h"
d41 8
a48 8
  {
    /* The basic hash table entry.  */
    struct bfd_hash_entry root;

    /* The offset within the vectors section where
       this entry lives.  */
    bfd_vma offset;
  };
d51 9
a59 9
  {
    /* The basic hash table.  */
    struct bfd_hash_table root;

    bfd *abfd;

    /* Offset at which we'll add the next entry.  */
    unsigned int offset;
  };
d65 1
a65 1
static bfd_boolean
d68 3
a70 22
	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
				       struct bfd_hash_table *,
				       const char *)));

static bfd_reloc_status_type special
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static int select_reloc
  PARAMS ((reloc_howto_type *));
static void rtype2howto
  PARAMS ((arelent *, struct internal_reloc *));
static void reloc_processing
  PARAMS ((arelent *, struct internal_reloc *, asymbol **, bfd *, asection *));
static bfd_boolean h8300_symbol_address_p
  PARAMS ((bfd *, asection *, bfd_vma));
static int h8300_reloc16_estimate
  PARAMS ((bfd *, asection *, arelent *, unsigned int,
    struct bfd_link_info *));
static void h8300_reloc16_extra_cases
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *, arelent *,
    bfd_byte *, unsigned int *, unsigned int *));
static bfd_boolean h8300_bfd_link_add_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
d81 2
a82 1
struct h8300_coff_link_hash_table {
d122 2
a123 2
	   bfd_hash_allocate (gen_table,
			      sizeof (struct funcvec_hash_entry)));
d129 1
a129 1
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, gen_table, string));
d154 1
a154 1
static bfd_boolean
d158 3
a160 3
     struct bfd_hash_entry *(*newfunc)
       PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
		const char *));
d170 1
a170 1
   basically to hold "static" information during an H8/300 coff link
d178 2
a179 3
  bfd_size_type amt = sizeof (struct h8300_coff_link_hash_table);

  ret = (struct h8300_coff_link_hash_table *) bfd_malloc (amt);
d182 1
a182 2
  if (!_bfd_link_hash_table_init (&ret->root.root, abfd,
				  _bfd_generic_link_hash_newfunc))
d184 1
a184 1
      free (ret);
d192 1
a192 1
  /* OK.  Everything's initialized, return the base pointer.  */
d224 16
a239 15
static reloc_howto_type howto_table[] = {
  HOWTO (R_RELBYTE, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "8", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_RELWORD, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "16", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (R_RELLONG, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, special, "32", FALSE, 0xffffffff, 0xffffffff, FALSE),
  HOWTO (R_PCRBYTE, 0, 0, 8, TRUE, 0, complain_overflow_signed, special, "DISP8", FALSE, 0x000000ff, 0x000000ff, TRUE),
  HOWTO (R_PCRWORD, 0, 1, 16, TRUE, 0, complain_overflow_signed, special, "DISP16", FALSE, 0x0000ffff, 0x0000ffff, TRUE),
  HOWTO (R_PCRLONG, 0, 2, 32, TRUE, 0, complain_overflow_signed, special, "DISP32", FALSE, 0xffffffff, 0xffffffff, TRUE),
  HOWTO (R_MOV16B1, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "relaxable mov.b:16", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (R_MOV16B2, 0, 1, 8, FALSE, 0, complain_overflow_bitfield, special, "relaxed mov.b:16", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_JMP1, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "16/pcrel", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
  HOWTO (R_JMP2, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "pcrecl/16", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_JMPL1, 0, 2, 32, FALSE, 0, complain_overflow_bitfield, special, "24/pcrell", FALSE, 0x00ffffff, 0x00ffffff, FALSE),
  HOWTO (R_JMPL2, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "pc8/24", FALSE, 0x000000ff, 0x000000ff, FALSE),
  HOWTO (R_MOV24B1, 0, 1, 32, FALSE, 0, complain_overflow_bitfield, special, "relaxable mov.b:24", FALSE, 0xffffffff, 0xffffffff, FALSE),
  HOWTO (R_MOV24B2, 0, 1, 8, FALSE, 0, complain_overflow_bitfield, special, "relaxed mov.b:24", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
d244 1
a244 1
  HOWTO (R_MEM_INDIRECT, 0, 0, 8, FALSE, 0, complain_overflow_bitfield, special, "8/indirect", FALSE, 0x000000ff, 0x000000ff, FALSE),
d248 1
a248 1
  HOWTO (R_PCRWORD_B, 0, 0, 8, TRUE, 0, complain_overflow_bitfield, special, "relaxed bCC:16", FALSE, 0x000000ff, 0x000000ff, FALSE),
d250 1
a250 1
  HOWTO (R_MOVL1, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,special, "32/24 relaxable move", FALSE, 0xffffffff, 0xffffffff, FALSE),
d252 1
a252 1
  HOWTO (R_MOVL2, 0, 1, 16, FALSE, 0, complain_overflow_bitfield, special, "32/24 relaxed move", FALSE, 0x0000ffff, 0x0000ffff, FALSE),
d254 1
a254 1
  HOWTO (R_BCC_INV, 0, 0, 8, TRUE, 0, complain_overflow_signed, special, "DISP8 inverted", FALSE, 0x000000ff, 0x000000ff, TRUE),
d256 1
a256 1
  HOWTO (R_JMP_DEL, 0, 0, 8, TRUE, 0, complain_overflow_signed, special, "Deleted jump", FALSE, 0x000000ff, 0x000000ff, TRUE),
d262 1
a262 1
  { x.r_type = select_reloc (howto); }
d264 2
a265 3
#define BADMAG(x) (H8300BADMAG (x) && H8300HBADMAG (x) && H8300SBADMAG (x) \
				   && H8300HNBADMAG(x) && H8300SNBADMAG(x))
#define H8300 1			/* Customize coffcode.h  */
d269 2
a270 2
#define SWAP_IN_RELOC_OFFSET	H_GET_32
#define SWAP_OUT_RELOC_OFFSET	H_PUT_32
d357 1
a357 1
#define RTYPE2HOWTO(internal, relocentry) rtype2howto (internal, relocentry)
d362 1
a362 1
 cache_ptr->addend = ext_reloc.r_offset;
d365 1
a365 1
 reloc_processing (relent, reloc, symbols, abfd, section)
d379 3
a381 1
    relent->sym_ptr_ptr = symbols + obj_convert (abfd)[reloc->r_symndx];
d383 3
a385 1
    relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
d395 1
a395 1
static bfd_boolean
a410 1

d415 1
a415 1
	return TRUE;
d418 1
a418 1
  return FALSE;
d455 2
a456 2
      /* This is the 16/24 bit absolute branch which could become an 8 bit
	 pc-relative branch.  */
d475 1
a475 1
      if ((int) gap >= -128 && (int) gap <= 128)
a476 7
	  bfd_byte code;

	  if (!bfd_get_section_contents (abfd, input_section, & code,
					 reloc->address, 1))
	    break;
	  code = bfd_get_8 (abfd, & code);

d488 1
a488 4
	     common.

	     Only perform this optimisation for jumps (code 0x5a) not
	     subroutine calls, as otherwise it could transform:
d490 1
a490 14
			     mov.w   r0,r0
			     beq     .L1
			     jsr     @@_bar
		      .L1:   rts
		      _bar:  rts
	     into:
			     mov.w   r0,r0
			     bne     _bar
			     rts
		      _bar:  rts

	     which changes the call (jsr) into a branch (bne).  */
	  if (code == 0x5a
	      && gap <= 126
d525 1
a525 1
	 because the addend field in PCrel jumps is off by -1.  */
d538 1
a538 1
      if ((int) gap >= -128 && (int) gap <= 128)
d610 1
a610 1
	 0xff8000..0xffffff inclusive, then it can be relaxed.  */
d680 1
d712 2
a713 1
      bfd_put_16 (abfd, (bfd_vma) gap, data + dst_address);
d728 1
a728 1
	  || (value >= 0x00ffff00 && value <= 0x00ffffff)
d733 1
d796 1
a796 1
	  data[dst_address - 1] &= ~0x20;
d807 1
a807 1
	}
d904 2
a905 2
      /* Output the target.  */
      bfd_put_8 (abfd, gap, data + dst_address - 1);
d907 3
a909 3
      /* We don't advance dst_address -- the 8bit reloc is applied at
	 dst_address - 1, so the next insn should begin at dst_address.  */
      src_address += 2;
d911 1
a911 1
      break;
d1049 1
a1050 1
	struct funcvec_hash_table *ftab;
d1052 1
a1052 19
	struct h8300_coff_link_hash_table *htab;
	asection *vectors_sec;

	if (link_info->hash->creator != abfd->xvec)
	  {
	    (*_bfd_error_handler)
	      (_("cannot handle R_MEM_INDIRECT reloc when using %s output"),
	       link_info->hash->creator->name);

	    /* What else can we do?  This function doesn't allow return
	       of an error, and we don't want to call abort as that
	       indicates an internal error.  */
#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
#endif
	    xexit (EXIT_FAILURE);
	  }
	htab = h8300_coff_hash_table (link_info);
	vectors_sec = htab->vectors_sec;
d1091 1
a1091 1
	    char *new_name = bfd_malloc ((bfd_size_type) strlen (name) + 9);
d1101 2
a1102 2
	ftab = htab->funcvec_hash_table;
	h = funcvec_hash_lookup (ftab, name, FALSE, FALSE);
d1106 1
a1106 1
	   thing to do here.  */
d1141 1
a1141 1
				  (file_ptr) vectors_sec->output_offset,
d1167 1
a1167 1
static bfd_boolean
a1173 10
  bfd_size_type amt;
  struct h8300_coff_link_hash_table *htab;

  /* Add the symbols using the generic code.  */
  _bfd_generic_link_add_symbols (abfd, info);

  if (info->hash->creator != abfd->xvec)
    return TRUE;

  htab = h8300_coff_hash_table (info);
d1176 1
a1176 1
  if (!htab->vectors_sec)
d1183 2
a1184 1
      htab->vectors_sec = bfd_make_section (abfd, ".vectors");
d1187 6
a1192 4
	 quit quickly now, rather than dying a painful death later.  */
      if (!htab->vectors_sec
	  || !bfd_set_section_flags (abfd, htab->vectors_sec, flags))
	return FALSE;
d1195 2
a1196 2
      amt = sizeof (struct funcvec_hash_table);
      funcvec_hash_table = (struct funcvec_hash_table *) bfd_alloc (abfd, amt);
d1199 1
a1199 1
	return FALSE;
d1206 1
a1206 1
	  return FALSE;
d1210 1
a1210 1
      htab->funcvec_hash_table = funcvec_hash_table;
d1214 4
a1217 1
  funcvec_hash_table = htab->funcvec_hash_table;
d1232 1
a1232 1
      relocs = (arelent **) bfd_malloc ((bfd_size_type) reloc_size);
d1234 1
a1234 1
	return FALSE;
a1262 1
	      struct funcvec_hash_table *ftab;
d1268 1
a1268 1
		  char *new_name;
a1269 1
		  new_name = bfd_malloc ((bfd_size_type) strlen (name) + 9);
d1280 2
a1281 2
	      ftab = htab->funcvec_hash_table;
	      h = funcvec_hash_lookup (ftab, name, FALSE, FALSE);
d1287 2
a1288 1
		  h = funcvec_hash_lookup (ftab, name, TRUE, TRUE);
d1292 1
a1292 1
		      return FALSE;
d1298 1
a1298 1
		    htab->vectors_sec->_raw_size += 2;
d1301 1
a1301 1
		    htab->vectors_sec->_raw_size += 4;
d1312 1
a1312 2
  sec = htab->vectors_sec;
  if (sec->_raw_size != 0)
d1315 2
a1316 2
      if (sec->contents)
	free (sec->contents);
d1319 2
a1320 1
      sec->contents = bfd_malloc (sec->_raw_size);
d1323 1
a1323 1
  return TRUE;
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
d64 1
a64 1
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
d68 4
a71 4
  (struct funcvec_hash_table *, bfd *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
			       struct bfd_hash_table *,
			       const char *));
d74 1
a74 1
  (bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **);
d76 1
a76 1
  (reloc_howto_type *);
d78 1
a78 1
  (arelent *, struct internal_reloc *);
d80 1
a80 1
  (arelent *, struct internal_reloc *, asymbol **, bfd *, asection *);
d82 1
a82 1
  (bfd *, asection *, bfd_vma);
d84 2
a85 2
  (bfd *, asection *, arelent *, unsigned int,
   struct bfd_link_info *);
d87 2
a88 2
  (bfd *, struct bfd_link_info *, struct bfd_link_order *, arelent *,
   bfd_byte *, unsigned int *, unsigned int *);
d90 1
a90 1
  (bfd *, struct bfd_link_info *);
d114 2
a115 1
static struct bfd_link_hash_table *h8300_coff_link_hash_table_create (bfd *);
d126 4
a129 3
funcvec_hash_newfunc (struct bfd_hash_entry *entry,
		      struct bfd_hash_table *gen_table,
		      const char *string)
d159 7
a165 14
 switch (bfd_get_mach (table->abfd))
   {
   case bfd_mach_h8300:
   case bfd_mach_h8300hn:
   case bfd_mach_h8300sn:
     table->offset += 2;
     break;
   case bfd_mach_h8300h:
   case bfd_mach_h8300s:
     table->offset += 4;
     break;
   default:
     return NULL;
   }
d174 6
a179 6
funcvec_hash_table_init (struct funcvec_hash_table *table,
			 bfd *abfd,
			 struct bfd_hash_entry *(*newfunc)
			   (struct bfd_hash_entry *,
			    struct bfd_hash_table *,
			    const char *))
d193 2
a194 1
h8300_coff_link_hash_table_create (bfd *abfd)
d227 9
a235 7
special (bfd *abfd ATTRIBUTE_UNUSED,
	 arelent *reloc_entry ATTRIBUTE_UNUSED,
	 asymbol *symbol ATTRIBUTE_UNUSED,
	 PTR data ATTRIBUTE_UNUSED,
	 asection *input_section ATTRIBUTE_UNUSED,
	 bfd *output_bfd,
	 char **error_message ATTRIBUTE_UNUSED)
d266 2
a267 2
  /* Internal reloc for relaxing.  This is created when a 16-bit pc-relative
     branch is turned into an 8-bit pc-relative branch.  */
d297 2
a298 1
select_reloc (reloc_howto_type *howto)
d306 3
a308 1
rtype2howto (arelent *internal, struct internal_reloc *dst)
d389 6
a394 2
reloc_processing (arelent *relent, struct internal_reloc *reloc,
		  asymbol **symbols, bfd *abfd, asection *section)
d413 4
a416 1
h8300_symbol_address_p (bfd *abfd, asection *input_section, bfd_vma address)
d448 6
a453 2
h8300_reloc16_estimate (bfd *abfd, asection *input_section, arelent *reloc,
			unsigned int shrink, struct bfd_link_info *link_info)
d473 2
a474 2
      /* This is the 16-/24-bit absolute branch which could become an
	 8-bit pc-relative branch.  */
d562 1
a562 1
    /* This is the 16-bit pc-relative branch which could become an 8-bit
d590 2
a591 2
    /* This is a 16-bit absolute address in a mov.b insn, which can
       become an 8-bit absolute address if it's in the right range.  */
a594 1
      value = bfd_h8300_pad_address (abfd, value);
d596 10
a605 3
      /* If the address is in the top 256 bytes of the address space
	 then we can relax this instruction.  */
      if (value >= 0xffffff00u)
d616 3
a618 3
    /* Similarly for a 24-bit absolute address in a mov.b.  Note that
       if we can't relax this into an 8-bit absolute, we'll fall through
       and try to relax it into a 16-bit absolute.  */
a621 1
      value = bfd_h8300_pad_address (abfd, value);
d623 6
a628 1
      if (value >= 0xffffff00u)
d641 1
a641 1
      /* FALLTHROUGH and try to turn the 24-/32-bit reloc into a 16-bit
d644 2
a645 2
    /* This is a 24-/32-bit absolute address in a mov insn, which can
       become an 16-bit absolute address if it's in the right range.  */
a648 1
      value = bfd_h8300_pad_address (abfd, value);
d650 3
a652 3
      /* If the address is a sign-extended 16-bit value then we can
         relax this instruction.  */
      if (value <= 0x7fff || value >= 0xffff8000u)
d679 9
a687 4
h8300_reloc16_extra_cases (bfd *abfd, struct bfd_link_info *link_info,
			   struct bfd_link_order *link_order, arelent *reloc,
			   bfd_byte *data, unsigned int *src_ptr,
			   unsigned int *dst_ptr)
a694 1
  unsigned char temp_code;
d698 1
a698 1
    /* Generic 8-bit pc-relative relocation.  */
d728 1
a728 1
    /* Generic 16-bit pc-relative relocation.  */
d759 1
a759 1
    /* Generic 8-bit absolute relocation.  */
d764 20
a783 3
      bfd_put_8 (abfd, value & 0xff, data + dst_address);
      dst_address += 1;
      src_address += 1;
d788 1
a788 1
    /* Various simple 16-bit absolute relocations.  */
d798 1
a798 1
    /* Various simple 24-/32-bit absolute relocations.  */
d809 1
a809 1
    /* Another 24-/32-bit absolute relocation.  */
d821 2
a822 9
      /* This is a 24-/32-bit absolute address in one of the following
	 instructions:

	   "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	   "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", "ldc.w",
	   "stc.w" and "mov.[bwl]"

	 We may relax this into an 16-bit absolute address if it's in
	 the right range.  */
a824 1
      value = bfd_h8300_pad_address (abfd, value);
d827 1
a827 1
      if (value <= 0x7fff || value >= 0xffff8000u)
d829 1
a829 1
	  /* Insert the 16-bit value into the proper location.  */
d832 2
a833 3
	  /* Fix the opcode.  For all the instructions that belong to
	     this relaxation, we simply need to turn off bit 0x20 in
	     the previous byte.  */
d848 1
a848 1
    /* A 16-bit absolute branch that is now an 8-bit pc-relative branch.  */
d878 1
a878 1
	  /* jmp -> bra */
d886 1
a886 1
      /* Write out the 8-bit value.  */
d894 1
a894 1
    /* A 16-bit pc-relative branch that is now an 8-bit pc-relative branch.  */
d921 1
a921 2
	  /* Get the second byte of the original insn, which contains
	     the condition code.  */
a922 4

	  /* Compute the fisrt byte of the relaxed instruction.  The
	     original sequence 0x58 0xX0 is relaxed to 0x4X, where X
	     represents the condition code.  */
d925 2
d945 1
a945 1
      /* We don't advance dst_address -- the 8-bit reloc is applied at
d951 1
a951 1
    /* Similarly for a 24-bit absolute that is now 8 bits.  */
d984 1
a984 9
      /* This is a 16-bit absolute address in one of the following
	 instructions:

	   "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	   "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and
	   "mov.b"

	 We may relax this into an 8-bit absolute address if it's in
	 the right range.  */
d988 1
a988 1
      /* All instructions with R_H8_DIR16B2 start with 0x6a.  */
a991 7
      temp_code = data[src_address - 1];

      /* If this is a mov.b instruction, clear the lower nibble, which
	 contains the source/destination register number.  */
      if ((temp_code & 0x10) != 0x10)
	temp_code &= 0xf0;

d993 1
a993 1
      switch (temp_code)
a995 1
	  /* This is mov.b @@aa:16,Rd.  */
a998 1
	  /* This is mov.b Rs,@@aa:16.  */
a1000 12
	case 0x18:
	  /* This is a bit-maniputation instruction that stores one
	     bit into memory, one of "bclr", "bist", "bnot", "bset",
	     and "bst".  */
	  data[dst_address - 2] = 0x7f;
	  break;
	case 0x10:
	  /* This is a bit-maniputation instruction that loads one bit
	     from memory, one of "band", "biand", "bild", "bior",
	     "bixor", "bld", "bor", "btst", and "bxor".  */
	  data[dst_address - 2] = 0x7e;
	  break;
d1009 1
a1009 9
      /* This is a 24-bit absolute address in one of the following
	 instructions:

	   "band", "bclr", "biand", "bild", "bior", "bist", "bixor",
	   "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and
	   "mov.b"

	 We may relax this into an 8-bit absolute address if it's in
	 the right range.  */
d1013 1
a1013 1
      /* All instructions with R_MOV24B2 start with 0x6a.  */
a1016 7
      temp_code = data[src_address - 1];

      /* If this is a mov.b instruction, clear the lower nibble, which
	 contains the source/destination register number.  */
      if ((temp_code & 0x30) != 0x30)
	temp_code &= 0xf0;

d1018 1
a1018 1
      switch (temp_code)
a1020 1
	  /* This is mov.b @@aa:24/32,Rd.  */
a1023 1
	  /* This is mov.b Rs,@@aa:24/32.  */
a1025 12
	case 0x38:
	  /* This is a bit-maniputation instruction that stores one
	     bit into memory, one of "bclr", "bist", "bnot", "bset",
	     and "bst".  */
	  data[dst_address - 2] = 0x7f;
	  break;
	case 0x30:
	  /* This is a bit-maniputation instruction that loads one bit
	     from memory, one of "band", "biand", "bild", "bior",
	     "bixor", "bld", "bor", "btst", and "bxor".  */
	  data[dst_address - 2] = 0x7e;
	  break;
d1070 1
a1070 1
    /* An 8-bit memory indirect instruction (jmp/jsr).
a1147 1

d1176 15
a1190 22
	switch (bfd_get_mach (input_section->owner))
	  {
	  case bfd_mach_h8300:
	  case bfd_mach_h8300hn:
	  case bfd_mach_h8300sn:
	    bfd_put_16 (abfd,
			bfd_coff_reloc16_get_value (reloc,
						    link_info,
						    input_section),
			vectors_sec->contents + h->offset);
	    break;
	  case bfd_mach_h8300h:
	  case bfd_mach_h8300s:
	    bfd_put_32 (abfd,
			bfd_coff_reloc16_get_value (reloc,
						    link_info,
						    input_section),
			vectors_sec->contents + h->offset);
	    break;
	  default:
	    abort ();
	  }
d1224 3
a1226 1
h8300_bfd_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
d1358 5
a1362 14
		  switch (bfd_get_mach (abfd))
		    {
		    case bfd_mach_h8300:
		    case bfd_mach_h8300hn:
		    case bfd_mach_h8300sn:
		      htab->vectors_sec->_raw_size += 2;
		      break;
		    case bfd_mach_h8300h:
		    case bfd_mach_h8300s:
		      htab->vectors_sec->_raw_size += 4;
		      break;
		    default:
		      abort ();
		    }
d1401 1
a1401 1
CREATE_BIG_COFF_TARGET_VEC (h8300coff_vec, "coff-h8300", BFD_IS_RELAXABLE, 0, '_', NULL, COFF_SWAP_TABLE)
@


