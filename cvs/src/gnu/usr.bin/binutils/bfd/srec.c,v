head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.50
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.52
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.14
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.12;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.24;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.31;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.23;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.11.23.03.33.27;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.47.10;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.12;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.12;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.06.31;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.11.19.14.12.58;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.20.41;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.45.57;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.27.54;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.20;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.34;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD back-end for s-record objects.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Written by Steve Chamberlain of Cygnus Support <sac@@cygnus.com>.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/*
SUBSECTION
	S-Record handling

DESCRIPTION

	Ordinary S-Records cannot hold anything but addresses and
	data, so that's all that we implement.

	The only interesting thing is that S-Records may come out of
	order and there is no header, so an initial scan is required
	to discover the minimum and maximum addresses used to create
	the vma and size of the only section we create.  We
	arbitrarily call this section ".text".

	When bfd_get_section_contents is called the file is read
	again, and this time the data is placed into a bfd_alloc'd
	area.

	Any number of sections may be created for output, we save them
	up and output them when it's time to close the bfd.

	An s record looks like:

EXAMPLE
	S<type><length><address><data><checksum>

DESCRIPTION
	Where
	o length
	is the number of bytes following upto the checksum. Note that
	this is not the number of chars following, since it takes two
	chars to represent a byte.
	o type
	is one of:
	0) header record
	1) two byte address data record
	2) three byte address data record
	3) four byte address data record
	7) four byte address termination record
	8) three byte address termination record
	9) two byte address termination record

	o address
	is the start address of the data following, or in the case of
	a termination record, the start address of the image
	o data
	is the data.
	o checksum
	is the sum of all the raw byte data in the record, from the length
	upwards, modulo 256 and subtracted from 255.

SUBSECTION
	Symbol S-Record handling

DESCRIPTION
	Some ICE equipment understands an addition to the standard
	S-Record format; symbols and their addresses can be sent
	before the data.

	The format of this is:
	($$ <modulename>
		(<space> <symbol> <address>)*)
	$$

	so a short symbol table could look like:

EXAMPLE
	$$ flash.x
	$$ flash.c
	  _port6 $0
	  _delay $4
	  _start $14
	  _etext $8036
	  _edata $8036
 	  _end $8036
	$$

DESCRIPTION
	We allow symbols to be anywhere in the data stream - the module names
	are always ignored.

*/

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "libiberty.h"
#include "safe-ctype.h"

static void srec_get_symbol_info PARAMS ((bfd *, asymbol *, symbol_info *));
static void srec_print_symbol
 PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
static void srec_init PARAMS ((void));
static bfd_boolean srec_mkobject PARAMS ((bfd *));
static int srec_get_byte PARAMS ((bfd *, bfd_boolean *));
static void srec_bad_byte PARAMS ((bfd *, unsigned int, int, bfd_boolean));
static bfd_boolean srec_scan PARAMS ((bfd *));
static const bfd_target *srec_object_p PARAMS ((bfd *));
static const bfd_target *symbolsrec_object_p PARAMS ((bfd *));
static bfd_boolean srec_read_section PARAMS ((bfd *, asection *, bfd_byte *));

static bfd_boolean srec_write_record
  PARAMS ((bfd *, unsigned int, bfd_vma, const bfd_byte *, const bfd_byte *));
static bfd_boolean srec_write_header PARAMS ((bfd *));
static bfd_boolean srec_write_symbols PARAMS ((bfd *));
static bfd_boolean srec_new_symbol PARAMS ((bfd *, const char *, bfd_vma));
static bfd_boolean srec_get_section_contents
  PARAMS ((bfd *, asection *, PTR, file_ptr, bfd_size_type));
static bfd_boolean srec_set_arch_mach
  PARAMS ((bfd *, enum bfd_architecture, unsigned long));
static bfd_boolean srec_set_section_contents
  PARAMS ((bfd *, sec_ptr, const PTR, file_ptr, bfd_size_type));
static bfd_boolean internal_srec_write_object_contents PARAMS ((bfd *, int));
static bfd_boolean srec_write_object_contents PARAMS ((bfd *));
static bfd_boolean symbolsrec_write_object_contents PARAMS ((bfd *));
static int srec_sizeof_headers PARAMS ((bfd *, bfd_boolean));
static long srec_get_symtab_upper_bound PARAMS ((bfd *));
static long srec_canonicalize_symtab PARAMS ((bfd *, asymbol **));

/* Macros for converting between hex and binary.  */

static const char digs[] = "0123456789ABCDEF";

#define NIBBLE(x) hex_value(x)
#define HEX(buffer) ((NIBBLE((buffer)[0])<<4) + NIBBLE((buffer)[1]))
#define TOHEX(d, x, ch) \
	d[1] = digs[(x) & 0xf]; \
	d[0] = digs[((x)>>4)&0xf]; \
	ch += ((x) & 0xff);
#define	ISHEX(x)  hex_p(x)

/* Initialize by filling in the hex conversion array.  */

static void
srec_init ()
{
  static bfd_boolean inited = FALSE;

  if (! inited)
    {
      inited = TRUE;
      hex_init ();
    }
}

/* The maximum number of address+data+crc bytes on a line is FF.  */
#define MAXCHUNK 0xff

/* Default size for a CHUNK.  */
#define DEFAULT_CHUNK 16

/* The number of data bytes we actually fit onto a line on output.
   This variable can be modified by objcopy's --srec-len parameter.
   For a 0x75 byte record you should set --srec-len=0x70.  */
unsigned int Chunk = DEFAULT_CHUNK;

/* The type of srec output (free or forced to S3).
   This variable can be modified by objcopy's --srec-forceS3
   parameter.  */
bfd_boolean S3Forced = FALSE;

/* When writing an S-record file, the S-records can not be output as
   they are seen.  This structure is used to hold them in memory.  */

struct srec_data_list_struct
{
  struct srec_data_list_struct *next;
  bfd_byte *data;
  bfd_vma where;
  bfd_size_type size;
};

typedef struct srec_data_list_struct srec_data_list_type;

/* When scanning the S-record file, a linked list of srec_symbol
   structures is built to represent the symbol table (if there is
   one).  */

struct srec_symbol
{
  struct srec_symbol *next;
  const char *name;
  bfd_vma val;
};

/* The S-record tdata information.  */

typedef struct srec_data_struct
  {
    srec_data_list_type *head;
    srec_data_list_type *tail;
    unsigned int type;
    struct srec_symbol *symbols;
    struct srec_symbol *symtail;
    asymbol *csymbols;
  }
tdata_type;

static bfd_boolean srec_write_section
  PARAMS ((bfd *, tdata_type *, srec_data_list_type *));
static bfd_boolean srec_write_terminator
  PARAMS ((bfd *, tdata_type *));

/* Set up the S-record tdata information.  */

static bfd_boolean
srec_mkobject (abfd)
     bfd *abfd;
{
  bfd_size_type amt;
  tdata_type *tdata;

  srec_init ();

  amt = sizeof (tdata_type);
  tdata = (tdata_type *) bfd_alloc (abfd, amt);
  if (tdata == NULL)
    return FALSE;

  abfd->tdata.srec_data = tdata;
  tdata->type = 1;
  tdata->head = NULL;
  tdata->tail = NULL;
  tdata->symbols = NULL;
  tdata->symtail = NULL;
  tdata->csymbols = NULL;

  return TRUE;
}

/* Read a byte from an S record file.  Set *ERRORPTR if an error
   occurred.  Return EOF on error or end of file.  */

static int
srec_get_byte (abfd, errorptr)
     bfd *abfd;
     bfd_boolean *errorptr;
{
  bfd_byte c;

  if (bfd_bread (&c, (bfd_size_type) 1, abfd) != 1)
    {
      if (bfd_get_error () != bfd_error_file_truncated)
	*errorptr = TRUE;
      return EOF;
    }

  return (int) (c & 0xff);
}

/* Report a problem in an S record file.  FIXME: This probably should
   not call fprintf, but we really do need some mechanism for printing
   error messages.  */

static void
srec_bad_byte (abfd, lineno, c, error)
     bfd *abfd;
     unsigned int lineno;
     int c;
     bfd_boolean error;
{
  if (c == EOF)
    {
      if (! error)
	bfd_set_error (bfd_error_file_truncated);
    }
  else
    {
      char buf[10];

      if (! ISPRINT (c))
	sprintf (buf, "\\%03o", (unsigned int) c);
      else
	{
	  buf[0] = c;
	  buf[1] = '\0';
	}
      (*_bfd_error_handler)
	(_("%s:%d: Unexpected character `%s' in S-record file\n"),
	 bfd_archive_filename (abfd), lineno, buf);
      bfd_set_error (bfd_error_bad_value);
    }
}

/* Add a new symbol found in an S-record file.  */

static bfd_boolean
srec_new_symbol (abfd, name, val)
     bfd *abfd;
     const char *name;
     bfd_vma val;
{
  struct srec_symbol *n;
  bfd_size_type amt = sizeof (struct srec_symbol);

  n = (struct srec_symbol *) bfd_alloc (abfd, amt);
  if (n == NULL)
    return FALSE;

  n->name = name;
  n->val = val;

  if (abfd->tdata.srec_data->symbols == NULL)
    abfd->tdata.srec_data->symbols = n;
  else
    abfd->tdata.srec_data->symtail->next = n;
  abfd->tdata.srec_data->symtail = n;
  n->next = NULL;

  ++abfd->symcount;

  return TRUE;
}

/* Read the S record file and turn it into sections.  We create a new
   section for each contiguous set of bytes.  */

static bfd_boolean
srec_scan (abfd)
     bfd *abfd;
{
  int c;
  unsigned int lineno = 1;
  bfd_boolean error = FALSE;
  bfd_byte *buf = NULL;
  size_t bufsize = 0;
  asection *sec = NULL;
  char *symbuf = NULL;

  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    goto error_return;

  while ((c = srec_get_byte (abfd, &error)) != EOF)
    {
      /* We only build sections from contiguous S-records, so if this
	 is not an S-record, then stop building a section.  */
      if (c != 'S' && c != '\r' && c != '\n')
	sec = NULL;

      switch (c)
	{
	default:
	  srec_bad_byte (abfd, lineno, c, error);
	  goto error_return;

	case '\n':
	  ++lineno;
	  break;

	case '\r':
	  break;

	case '$':
	  /* Starting a module name, which we ignore.  */
	  while ((c = srec_get_byte (abfd, &error)) != '\n'
		 && c != EOF)
	    ;
	  if (c == EOF)
	    {
	      srec_bad_byte (abfd, lineno, c, error);
	      goto error_return;
	    }

	  ++lineno;

	  break;

	case ' ':
	  do
	    {
	      bfd_size_type alc;
	      char *p, *symname;
	      bfd_vma symval;

	      /* Starting a symbol definition.  */
	      while ((c = srec_get_byte (abfd, &error)) != EOF
		     && (c == ' ' || c == '\t'))
		;

	      if (c == '\n' || c == '\r')
		break;

	      if (c == EOF)
		{
		  srec_bad_byte (abfd, lineno, c, error);
		  goto error_return;
		}

	      alc = 10;
	      symbuf = (char *) bfd_malloc (alc + 1);
	      if (symbuf == NULL)
		goto error_return;

	      p = symbuf;

	      *p++ = c;
	      while ((c = srec_get_byte (abfd, &error)) != EOF
		     && ! ISSPACE (c))
		{
		  if ((bfd_size_type) (p - symbuf) >= alc)
		    {
		      char *n;

		      alc *= 2;
		      n = (char *) bfd_realloc (symbuf, alc + 1);
		      if (n == NULL)
			goto error_return;
		      p = n + (p - symbuf);
		      symbuf = n;
		    }

		  *p++ = c;
		}

	      if (c == EOF)
		{
		  srec_bad_byte (abfd, lineno, c, error);
		  goto error_return;
		}

	      *p++ = '\0';
	      symname = bfd_alloc (abfd, (bfd_size_type) (p - symbuf));
	      if (symname == NULL)
		goto error_return;
	      strcpy (symname, symbuf);
	      free (symbuf);
	      symbuf = NULL;

	      while ((c = srec_get_byte (abfd, &error)) != EOF
		     && (c == ' ' || c == '\t'))
		;
	      if (c == EOF)
		{
		  srec_bad_byte (abfd, lineno, c, error);
		  goto error_return;
		}

	      /* Skip a dollar sign before the hex value.  */
	      if (c == '$')
		{
		  c = srec_get_byte (abfd, &error);
		  if (c == EOF)
		    {
		      srec_bad_byte (abfd, lineno, c, error);
		      goto error_return;
		    }
		}

	      symval = 0;
	      while (ISHEX (c))
		{
		  symval <<= 4;
		  symval += NIBBLE (c);
		  c = srec_get_byte (abfd, &error);
		}

	      if (! srec_new_symbol (abfd, symname, symval))
		goto error_return;
	    }
	  while (c == ' ' || c == '\t')
	    ;

	  if (c == '\n')
	    ++lineno;
	  else if (c != '\r')
	    {
	      srec_bad_byte (abfd, lineno, c, error);
	      goto error_return;
	    }

	  break;

	case 'S':
	  {
	    file_ptr pos;
	    char hdr[3];
	    unsigned int bytes;
	    bfd_vma address;
	    bfd_byte *data;

	    /* Starting an S-record.  */

	    pos = bfd_tell (abfd) - 1;

	    if (bfd_bread (hdr, (bfd_size_type) 3, abfd) != 3)
	      goto error_return;

	    if (! ISHEX (hdr[1]) || ! ISHEX (hdr[2]))
	      {
		if (! ISHEX (hdr[1]))
		  c = hdr[1];
		else
		  c = hdr[2];
		srec_bad_byte (abfd, lineno, c, error);
		goto error_return;
	      }

	    bytes = HEX (hdr + 1);
	    if (bytes * 2 > bufsize)
	      {
		if (buf != NULL)
		  free (buf);
		buf = (bfd_byte *) bfd_malloc ((bfd_size_type) bytes * 2);
		if (buf == NULL)
		  goto error_return;
		bufsize = bytes * 2;
	      }

	    if (bfd_bread (buf, (bfd_size_type) bytes * 2, abfd) != bytes * 2)
	      goto error_return;

	    /* Ignore the checksum byte.  */
	    --bytes;

	    address = 0;
	    data = buf;
	    switch (hdr[0])
	      {
	      case '0':
	      case '5':
		/* Prologue--ignore the file name, but stop building a
		   section at this point.  */
		sec = NULL;
		break;

	      case '3':
		address = HEX (data);
		data += 2;
		--bytes;
		/* Fall through.  */
	      case '2':
		address = (address << 8) | HEX (data);
		data += 2;
		--bytes;
		/* Fall through.  */
	      case '1':
		address = (address << 8) | HEX (data);
		data += 2;
		address = (address << 8) | HEX (data);
		data += 2;
		bytes -= 2;

		if (sec != NULL
		    && sec->vma + sec->_raw_size == address)
		  {
		    /* This data goes at the end of the section we are
		       currently building.  */
		    sec->_raw_size += bytes;
		  }
		else
		  {
		    char secbuf[20];
		    char *secname;
		    bfd_size_type amt;

		    sprintf (secbuf, ".sec%d", bfd_count_sections (abfd) + 1);
		    amt = strlen (secbuf) + 1;
		    secname = (char *) bfd_alloc (abfd, amt);
		    strcpy (secname, secbuf);
		    sec = bfd_make_section (abfd, secname);
		    if (sec == NULL)
		      goto error_return;
		    sec->flags = SEC_HAS_CONTENTS | SEC_LOAD | SEC_ALLOC;
		    sec->vma = address;
		    sec->lma = address;
		    sec->_raw_size = bytes;
		    sec->filepos = pos;
		  }

		break;

	      case '7':
		address = HEX (data);
		data += 2;
		/* Fall through.  */
	      case '8':
		address = (address << 8) | HEX (data);
		data += 2;
		/* Fall through.  */
	      case '9':
		address = (address << 8) | HEX (data);
		data += 2;
		address = (address << 8) | HEX (data);
		data += 2;

		/* This is a termination record.  */
		abfd->start_address = address;

		if (buf != NULL)
		  free (buf);

		return TRUE;
	      }
	  }
	  break;
	}
    }

  if (error)
    goto error_return;

  if (buf != NULL)
    free (buf);

  return TRUE;

 error_return:
  if (symbuf != NULL)
    free (symbuf);
  if (buf != NULL)
    free (buf);
  return FALSE;
}

/* Check whether an existing file is an S-record file.  */

static const bfd_target *
srec_object_p (abfd)
     bfd *abfd;
{
  PTR tdata_save;
  bfd_byte b[4];

  srec_init ();

  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
      || bfd_bread (b, (bfd_size_type) 4, abfd) != 4)
    return NULL;

  if (b[0] != 'S' || !ISHEX (b[1]) || !ISHEX (b[2]) || !ISHEX (b[3]))
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  tdata_save = abfd->tdata.any;
  if (! srec_mkobject (abfd) || ! srec_scan (abfd))
    {
      if (abfd->tdata.any != tdata_save && abfd->tdata.any != NULL)
	bfd_release (abfd, abfd->tdata.any);
      abfd->tdata.any = tdata_save;
      return NULL;
    }

  if (abfd->symcount > 0)
    abfd->flags |= HAS_SYMS;

  return abfd->xvec;
}

/* Check whether an existing file is an S-record file with symbols.  */

static const bfd_target *
symbolsrec_object_p (abfd)
     bfd *abfd;
{
  PTR tdata_save;
  char b[2];

  srec_init ();

  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
      || bfd_bread (b, (bfd_size_type) 2, abfd) != 2)
    return NULL;

  if (b[0] != '$' || b[1] != '$')
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  tdata_save = abfd->tdata.any;
  if (! srec_mkobject (abfd) || ! srec_scan (abfd))
    {
      if (abfd->tdata.any != tdata_save && abfd->tdata.any != NULL)
	bfd_release (abfd, abfd->tdata.any);
      abfd->tdata.any = tdata_save;
      return NULL;
    }

  if (abfd->symcount > 0)
    abfd->flags |= HAS_SYMS;

  return abfd->xvec;
}

/* Read in the contents of a section in an S-record file.  */

static bfd_boolean
srec_read_section (abfd, section, contents)
     bfd *abfd;
     asection *section;
     bfd_byte *contents;
{
  int c;
  bfd_size_type sofar = 0;
  bfd_boolean error = FALSE;
  bfd_byte *buf = NULL;
  size_t bufsize = 0;

  if (bfd_seek (abfd, section->filepos, SEEK_SET) != 0)
    goto error_return;

  while ((c = srec_get_byte (abfd, &error)) != EOF)
    {
      bfd_byte hdr[3];
      unsigned int bytes;
      bfd_vma address;
      bfd_byte *data;

      if (c == '\r' || c == '\n')
	continue;

      /* This is called after srec_scan has already been called, so we
	 ought to know the exact format.  */
      BFD_ASSERT (c == 'S');

      if (bfd_bread (hdr, (bfd_size_type) 3, abfd) != 3)
	goto error_return;

      BFD_ASSERT (ISHEX (hdr[1]) && ISHEX (hdr[2]));

      bytes = HEX (hdr + 1);

      if (bytes * 2 > bufsize)
	{
	  if (buf != NULL)
	    free (buf);
	  buf = (bfd_byte *) bfd_malloc ((bfd_size_type) bytes * 2);
	  if (buf == NULL)
	    goto error_return;
	  bufsize = bytes * 2;
	}

      if (bfd_bread (buf, (bfd_size_type) bytes * 2, abfd) != bytes * 2)
	goto error_return;

      address = 0;
      data = buf;
      switch (hdr[0])
	{
	default:
	  BFD_ASSERT (sofar == section->_raw_size);
	  if (buf != NULL)
	    free (buf);
	  return TRUE;

	case '3':
	  address = HEX (data);
	  data += 2;
	  --bytes;
	  /* Fall through.  */
	case '2':
	  address = (address << 8) | HEX (data);
	  data += 2;
	  --bytes;
	  /* Fall through.  */
	case '1':
	  address = (address << 8) | HEX (data);
	  data += 2;
	  address = (address << 8) | HEX (data);
	  data += 2;
	  bytes -= 2;

	  if (address != section->vma + sofar)
	    {
	      /* We've come to the end of this section.  */
	      BFD_ASSERT (sofar == section->_raw_size);
	      if (buf != NULL)
		free (buf);
	      return TRUE;
	    }

	  /* Don't consider checksum.  */
	  --bytes;

	  while (bytes-- != 0)
	    {
	      contents[sofar] = HEX (data);
	      data += 2;
	      ++sofar;
	    }

	  break;
	}
    }

  if (error)
    goto error_return;

  BFD_ASSERT (sofar == section->_raw_size);

  if (buf != NULL)
    free (buf);

  return TRUE;

 error_return:
  if (buf != NULL)
    free (buf);
  return FALSE;
}

/* Get the contents of a section in an S-record file.  */

static bfd_boolean
srec_get_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     asection *section;
     PTR location;
     file_ptr offset;
     bfd_size_type count;
{
  if (section->used_by_bfd == NULL)
    {
      section->used_by_bfd = bfd_alloc (abfd, section->_raw_size);
      if (section->used_by_bfd == NULL && section->_raw_size != 0)
	return FALSE;

      if (! srec_read_section (abfd, section, section->used_by_bfd))
	return FALSE;
    }

  memcpy (location, (bfd_byte *) section->used_by_bfd + offset,
	  (size_t) count);

  return TRUE;
}

/* Set the architecture.  We accept an unknown architecture here.  */

static bfd_boolean
srec_set_arch_mach (abfd, arch, mach)
     bfd *abfd;
     enum bfd_architecture arch;
     unsigned long mach;
{
  if (arch == bfd_arch_unknown)
    {
      abfd->arch_info = &bfd_default_arch_struct;
      return TRUE;
    }
  return bfd_default_set_arch_mach (abfd, arch, mach);
}

/* We have to save up all the Srecords for a splurge before output.  */

static bfd_boolean
srec_set_section_contents (abfd, section, location, offset, bytes_to_do)
     bfd *abfd;
     sec_ptr section;
     const PTR location;
     file_ptr offset;
     bfd_size_type bytes_to_do;
{
  tdata_type *tdata = abfd->tdata.srec_data;
  register srec_data_list_type *entry;

  entry = ((srec_data_list_type *)
	   bfd_alloc (abfd, (bfd_size_type) sizeof (srec_data_list_type)));
  if (entry == NULL)
    return FALSE;

  if (bytes_to_do
      && (section->flags & SEC_ALLOC)
      && (section->flags & SEC_LOAD))
    {
      bfd_byte *data;

      data = (bfd_byte *) bfd_alloc (abfd, bytes_to_do);
      if (data == NULL)
	return FALSE;
      memcpy ((PTR) data, location, (size_t) bytes_to_do);

      /* Ff S3Forced is TRUE then always select S3 records,
	 regardless of the siez of the addresses.  */
      if (S3Forced)
	tdata->type = 3;
      else if ((section->lma + offset + bytes_to_do - 1) <= 0xffff)
	;  /* The default, S1, is OK.  */
      else if ((section->lma + offset + bytes_to_do - 1) <= 0xffffff
	       && tdata->type <= 2)
	tdata->type = 2;
      else
	tdata->type = 3;

      entry->data = data;
      entry->where = section->lma + offset;
      entry->size = bytes_to_do;

      /* Sort the records by address.  Optimize for the common case of
	 adding a record to the end of the list.  */
      if (tdata->tail != NULL
	  && entry->where >= tdata->tail->where)
	{
	  tdata->tail->next = entry;
	  entry->next = NULL;
	  tdata->tail = entry;
	}
      else
	{
	  register srec_data_list_type **look;

	  for (look = &tdata->head;
	       *look != NULL && (*look)->where < entry->where;
	       look = &(*look)->next)
	    ;
	  entry->next = *look;
	  *look = entry;
	  if (entry->next == NULL)
	    tdata->tail = entry;
	}
    }
  return TRUE;
}

/* Write a record of type, of the supplied number of bytes. The
   supplied bytes and length don't have a checksum. That's worked out
   here.  */

static bfd_boolean
srec_write_record (abfd, type, address, data, end)
     bfd *abfd;
     unsigned int type;
     bfd_vma address;
     const bfd_byte *data;
     const bfd_byte *end;
{
  char buffer[2 * MAXCHUNK + 6];
  unsigned int check_sum = 0;
  const bfd_byte *src = data;
  char *dst = buffer;
  char *length;
  bfd_size_type wrlen;

  *dst++ = 'S';
  *dst++ = '0' + type;

  length = dst;
  dst += 2;			/* Leave room for dst.  */

  switch (type)
    {
    case 3:
    case 7:
      TOHEX (dst, (address >> 24), check_sum);
      dst += 2;
    case 8:
    case 2:
      TOHEX (dst, (address >> 16), check_sum);
      dst += 2;
    case 9:
    case 1:
    case 0:
      TOHEX (dst, (address >> 8), check_sum);
      dst += 2;
      TOHEX (dst, (address), check_sum);
      dst += 2;
      break;

    }
  for (src = data; src < end; src++)
    {
      TOHEX (dst, *src, check_sum);
      dst += 2;
    }

  /* Fill in the length.  */
  TOHEX (length, (dst - length) / 2, check_sum);
  check_sum &= 0xff;
  check_sum = 255 - check_sum;
  TOHEX (dst, check_sum, check_sum);
  dst += 2;

  *dst++ = '\r';
  *dst++ = '\n';
  wrlen = dst - buffer;
  if (bfd_bwrite ((PTR) buffer, wrlen, abfd) != wrlen)
    return FALSE;
  return TRUE;
}

static bfd_boolean
srec_write_header (abfd)
     bfd *abfd;
{
  unsigned int len = strlen (abfd->filename);

  /* I'll put an arbitrary 40 char limit on header size.  */
  if (len > 40)
    len = 40;

  return srec_write_record (abfd, 0, (bfd_vma) 0,
			    abfd->filename, abfd->filename + len);
}

static bfd_boolean
srec_write_section (abfd, tdata, list)
     bfd *abfd;
     tdata_type *tdata;
     srec_data_list_type *list;
{
  unsigned int octets_written = 0;
  bfd_byte *location = list->data;

  /* Validate number of data bytes to write.  The srec length byte
     counts the address, data and crc bytes.  S1 (tdata->type == 1)
     records have two address bytes, S2 (tdata->type == 2) records
     have three, and S3 (tdata->type == 3) records have four.
     The total length can't exceed 255, and a zero data length will
     spin for a long time.  */
  if (Chunk == 0)
    Chunk = 1;
  else if (Chunk > MAXCHUNK - tdata->type - 2)
    Chunk = MAXCHUNK - tdata->type - 2;

  while (octets_written < list->size)
    {
      bfd_vma address;
      unsigned int octets_this_chunk = list->size - octets_written;

      if (octets_this_chunk > Chunk)
	octets_this_chunk = Chunk;

      address = list->where + octets_written / bfd_octets_per_byte (abfd);

      if (! srec_write_record (abfd,
			       tdata->type,
			       address,
			       location,
			       location + octets_this_chunk))
	return FALSE;

      octets_written += octets_this_chunk;
      location += octets_this_chunk;
    }

  return TRUE;
}

static bfd_boolean
srec_write_terminator (abfd, tdata)
     bfd *abfd;
     tdata_type *tdata;
{
  return srec_write_record (abfd, 10 - tdata->type,
			    abfd->start_address, NULL, NULL);
}

static bfd_boolean
srec_write_symbols (abfd)
     bfd *abfd;
{
  /* Dump out the symbols of a bfd.  */
  int i;
  int count = bfd_get_symcount (abfd);

  if (count)
    {
      bfd_size_type len;
      asymbol **table = bfd_get_outsymbols (abfd);
      len = strlen (abfd->filename);
      if (bfd_bwrite ("$$ ", (bfd_size_type) 3, abfd) != 3
	  || bfd_bwrite (abfd->filename, len, abfd) != len
	  || bfd_bwrite ("\r\n", (bfd_size_type) 2, abfd) != 2)
	return FALSE;

      for (i = 0; i < count; i++)
	{
	  asymbol *s = table[i];
	  if (! bfd_is_local_label (abfd, s)
	      && (s->flags & BSF_DEBUGGING) == 0)
	    {
	      /* Just dump out non debug symbols.  */
	      char buf[43], *p;

	      len = strlen (s->name);
	      if (bfd_bwrite ("  ", (bfd_size_type) 2, abfd) != 2
		  || bfd_bwrite (s->name, len, abfd) != len)
		return FALSE;

	      sprintf_vma (buf + 2, (s->value
				     + s->section->output_section->lma
				     + s->section->output_offset));
	      p = buf + 2;
	      while (p[0] == '0' && p[1] != 0)
		p++;
	      len = strlen (p);
	      p[len] = '\r';
	      p[len + 1] = '\n';
	      *--p = '$';
	      *--p = ' ';
	      len += 4;
	      if (bfd_bwrite (p, len, abfd) != len)
		return FALSE;
	    }
	}
      if (bfd_bwrite ("$$ \r\n", (bfd_size_type) 5, abfd) != 5)
	return FALSE;
    }

  return TRUE;
}

static bfd_boolean
internal_srec_write_object_contents (abfd, symbols)
     bfd *abfd;
     int symbols;
{
  tdata_type *tdata = abfd->tdata.srec_data;
  srec_data_list_type *list;

  if (symbols)
    {
      if (! srec_write_symbols (abfd))
	return FALSE;
    }

  if (! srec_write_header (abfd))
    return FALSE;

  /* Now wander though all the sections provided and output them.  */
  list = tdata->head;

  while (list != (srec_data_list_type *) NULL)
    {
      if (! srec_write_section (abfd, tdata, list))
	return FALSE;
      list = list->next;
    }
  return srec_write_terminator (abfd, tdata);
}

static bfd_boolean
srec_write_object_contents (abfd)
     bfd *abfd;
{
  return internal_srec_write_object_contents (abfd, 0);
}

static bfd_boolean
symbolsrec_write_object_contents (abfd)
     bfd *abfd;
{
  return internal_srec_write_object_contents (abfd, 1);
}

static int
srec_sizeof_headers (abfd, exec)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_boolean exec ATTRIBUTE_UNUSED;
{
  return 0;
}

/* Return the amount of memory needed to read the symbol table.  */

static long
srec_get_symtab_upper_bound (abfd)
     bfd *abfd;
{
  return (bfd_get_symcount (abfd) + 1) * sizeof (asymbol *);
}

/* Return the symbol table.  */

static long
srec_canonicalize_symtab (abfd, alocation)
     bfd *abfd;
     asymbol **alocation;
{
  bfd_size_type symcount = bfd_get_symcount (abfd);
  asymbol *csymbols;
  unsigned int i;

  csymbols = abfd->tdata.srec_data->csymbols;
  if (csymbols == NULL)
    {
      asymbol *c;
      struct srec_symbol *s;

      csymbols = (asymbol *) bfd_alloc (abfd, symcount * sizeof (asymbol));
      if (csymbols == NULL && symcount != 0)
	return 0;
      abfd->tdata.srec_data->csymbols = csymbols;

      for (s = abfd->tdata.srec_data->symbols, c = csymbols;
	   s != NULL;
	   s = s->next, ++c)
	{
	  c->the_bfd = abfd;
	  c->name = s->name;
	  c->value = s->val;
	  c->flags = BSF_GLOBAL;
	  c->section = bfd_abs_section_ptr;
	  c->udata.p = NULL;
	}
    }

  for (i = 0; i < symcount; i++)
    *alocation++ = csymbols++;
  *alocation = NULL;

  return symcount;
}

static void
srec_get_symbol_info (ignore_abfd, symbol, ret)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *symbol;
     symbol_info *ret;
{
  bfd_symbol_info (symbol, ret);
}

static void
srec_print_symbol (abfd, afile, symbol, how)
     bfd *abfd;
     PTR afile;
     asymbol *symbol;
     bfd_print_symbol_type how;
{
  FILE *file = (FILE *) afile;
  switch (how)
    {
    case bfd_print_symbol_name:
      fprintf (file, "%s", symbol->name);
      break;
    default:
      bfd_print_symbol_vandf (abfd, (PTR) file, symbol);
      fprintf (file, " %-5s %s",
	       symbol->section->name,
	       symbol->name);

    }
}

#define	srec_close_and_cleanup _bfd_generic_close_and_cleanup
#define srec_bfd_free_cached_info _bfd_generic_bfd_free_cached_info
#define srec_new_section_hook _bfd_generic_new_section_hook

#define srec_bfd_is_local_label_name bfd_generic_is_local_label_name
#define srec_get_lineno _bfd_nosymbols_get_lineno
#define srec_find_nearest_line _bfd_nosymbols_find_nearest_line
#define srec_make_empty_symbol _bfd_generic_make_empty_symbol
#define srec_bfd_make_debug_symbol _bfd_nosymbols_bfd_make_debug_symbol
#define srec_read_minisymbols _bfd_generic_read_minisymbols
#define srec_minisymbol_to_symbol _bfd_generic_minisymbol_to_symbol

#define srec_get_reloc_upper_bound \
  ((long (*) PARAMS ((bfd *, asection *))) bfd_0l)
#define srec_canonicalize_reloc \
  ((long (*) PARAMS ((bfd *, asection *, arelent **, asymbol **))) bfd_0l)
#define srec_bfd_reloc_type_lookup _bfd_norelocs_bfd_reloc_type_lookup

#define srec_get_section_contents_in_window \
  _bfd_generic_get_section_contents_in_window

#define srec_bfd_get_relocated_section_contents \
  bfd_generic_get_relocated_section_contents
#define srec_bfd_relax_section bfd_generic_relax_section
#define srec_bfd_gc_sections bfd_generic_gc_sections
#define srec_bfd_merge_sections bfd_generic_merge_sections
#define srec_bfd_discard_group bfd_generic_discard_group
#define srec_bfd_link_hash_table_create _bfd_generic_link_hash_table_create
#define srec_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
#define srec_bfd_link_add_symbols _bfd_generic_link_add_symbols
#define srec_bfd_link_just_syms _bfd_generic_link_just_syms
#define srec_bfd_final_link _bfd_generic_final_link
#define srec_bfd_link_split_section _bfd_generic_link_split_section

const bfd_target srec_vec =
{
  "srec",			/* name */
  bfd_target_srec_flavour,
  BFD_ENDIAN_UNKNOWN,		/* target byte order */
  BFD_ENDIAN_UNKNOWN,		/* target headers byte order */
  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
  (SEC_CODE | SEC_DATA | SEC_ROM | SEC_HAS_CONTENTS
   | SEC_ALLOC | SEC_LOAD | SEC_RELOC),	/* section flags */
  0,				/* leading underscore */
  ' ',				/* ar_pad_char */
  16,				/* ar_max_namelen */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */

  {
    _bfd_dummy_target,
    srec_object_p,		/* bfd_check_format */
    _bfd_dummy_target,
    _bfd_dummy_target,
  },
  {
    bfd_false,
    srec_mkobject,
    _bfd_generic_mkarchive,
    bfd_false,
  },
  {				/* bfd_write_contents */
    bfd_false,
    srec_write_object_contents,
    _bfd_write_archive_contents,
    bfd_false,
  },

  BFD_JUMP_TABLE_GENERIC (srec),
  BFD_JUMP_TABLE_COPY (_bfd_generic),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (_bfd_noarchive),
  BFD_JUMP_TABLE_SYMBOLS (srec),
  BFD_JUMP_TABLE_RELOCS (srec),
  BFD_JUMP_TABLE_WRITE (srec),
  BFD_JUMP_TABLE_LINK (srec),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  NULL,

  (PTR) 0
};

const bfd_target symbolsrec_vec =
{
  "symbolsrec",			/* name */
  bfd_target_srec_flavour,
  BFD_ENDIAN_UNKNOWN,		/* target byte order */
  BFD_ENDIAN_UNKNOWN,		/* target headers byte order */
  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
  (SEC_CODE | SEC_DATA | SEC_ROM | SEC_HAS_CONTENTS
   | SEC_ALLOC | SEC_LOAD | SEC_RELOC),	/* section flags */
  0,				/* leading underscore */
  ' ',				/* ar_pad_char */
  16,				/* ar_max_namelen */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */

  {
    _bfd_dummy_target,
    symbolsrec_object_p,	/* bfd_check_format */
    _bfd_dummy_target,
    _bfd_dummy_target,
  },
  {
    bfd_false,
    srec_mkobject,
    _bfd_generic_mkarchive,
    bfd_false,
  },
  {				/* bfd_write_contents */
    bfd_false,
    symbolsrec_write_object_contents,
    _bfd_write_archive_contents,
    bfd_false,
  },

  BFD_JUMP_TABLE_GENERIC (srec),
  BFD_JUMP_TABLE_COPY (_bfd_generic),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (_bfd_noarchive),
  BFD_JUMP_TABLE_SYMBOLS (srec),
  BFD_JUMP_TABLE_RELOCS (srec),
  BFD_JUMP_TABLE_WRITE (srec),
  BFD_JUMP_TABLE_LINK (srec),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  NULL,

  (PTR) 0
};
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2000, 2001, 2002
d135 1
a135 1
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
d141 1
a141 1
static long srec_get_symtab PARAMS ((bfd *, asymbol **));
d875 1
a875 1
     PTR location;
d1012 1
a1012 1
  /* I'll put an arbitary 40 char limit on header size.  */
d1191 1
a1191 1
srec_get_symtab (abfd, alocation)
@


1.5
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2000
d111 1
a111 1
#include <ctype.h>
d117 4
a120 4
static boolean srec_mkobject PARAMS ((bfd *));
static int srec_get_byte PARAMS ((bfd *, boolean *));
static void srec_bad_byte PARAMS ((bfd *, unsigned int, int, boolean));
static boolean srec_scan PARAMS ((bfd *));
d123 1
a123 1
static boolean srec_read_section PARAMS ((bfd *, asection *, bfd_byte *));
d125 6
a130 7
static boolean srec_write_record PARAMS ((bfd *, int, bfd_vma,
					  const bfd_byte *,
					  const bfd_byte *));
static boolean srec_write_header PARAMS ((bfd *));
static boolean srec_write_symbols PARAMS ((bfd *));
static boolean srec_new_symbol PARAMS ((bfd *, const char *, bfd_vma));
static boolean srec_get_section_contents
d132 1
a132 1
static boolean srec_set_arch_mach
d134 1
a134 1
static boolean srec_set_section_contents
d136 4
a139 5
static boolean internal_srec_write_object_contents PARAMS ((bfd *, int));
static boolean srec_write_object_contents PARAMS ((bfd *));
static boolean symbolsrec_write_object_contents PARAMS ((bfd *));
static int srec_sizeof_headers PARAMS ((bfd *, boolean));
static asymbol *srec_make_empty_symbol PARAMS ((bfd *));
d145 1
a145 1
static CONST char digs[] = "0123456789ABCDEF";
d160 1
a160 1
  static boolean inited = false;
d162 1
a162 1
  if (inited == false)
d164 1
a164 1
      inited = true;
d169 1
a169 1
/* The maximum number of bytes on a line is FF.  */
d175 1
a175 1
/* The number of bytes we actually fit onto a line on output.
d183 1
a183 1
boolean S3Forced = 0;
d222 4
a225 3
static boolean srec_write_section PARAMS ((bfd *, tdata_type *,
					   srec_data_list_type *));
static boolean srec_write_terminator PARAMS ((bfd *, tdata_type *));
d229 1
a229 1
static boolean
d233 3
d238 12
a249 13
  if (abfd->tdata.srec_data == NULL)
    {
      tdata_type *tdata = (tdata_type *) bfd_alloc (abfd, sizeof (tdata_type));
      if (tdata == NULL)
	return false;
      abfd->tdata.srec_data = tdata;
      tdata->type = 1;
      tdata->head = NULL;
      tdata->tail = NULL;
      tdata->symbols = NULL;
      tdata->symtail = NULL;
      tdata->csymbols = NULL;
    }
d251 1
a251 1
  return true;
d260 1
a260 1
     boolean *errorptr;
d264 1
a264 1
  if (bfd_read (&c, 1, 1, abfd) != 1)
d267 1
a267 1
	*errorptr = true;
d283 1
a283 1
     boolean error;
d294 1
a294 1
      if (! isprint (c))
d303 1
a303 1
	 bfd_get_filename (abfd), lineno, buf);
d310 1
a310 1
static boolean
d317 1
d319 1
a319 1
  n = (struct srec_symbol *) bfd_alloc (abfd, sizeof (struct srec_symbol));
d321 1
a321 1
    return false;
d335 1
a335 1
  return true;
d341 1
a341 1
static boolean
d347 1
a347 1
  boolean error = false;
d359 1
a359 1
         is not an S-record, then stop building a section.  */
d394 1
a394 1
	      unsigned int alc;
d421 1
a421 1
		     && ! isspace (c))
d423 1
a423 1
		  if ((unsigned int) (p - symbuf) >= alc)
d445 1
a445 1
	      symname = bfd_alloc (abfd, p - symbuf);
d508 1
a508 1
	    if (bfd_read (hdr, 1, 3, abfd) != 3)
d526 1
a526 1
		buf = (bfd_byte *) bfd_malloc (bytes * 2);
d532 1
a532 1
	    if (bfd_read (buf, 1, bytes * 2, abfd) != bytes * 2)
d545 1
a545 1
                   section at this point.  */
d570 1
a570 1
                       currently building.  */
d577 1
d580 2
a581 1
		    secname = (char *) bfd_alloc (abfd, strlen (secbuf) + 1);
d615 1
a615 1
		return true;
d628 1
a628 1
  return true;
d635 1
a635 1
  return false;
d644 1
d650 1
a650 1
      || bfd_read (b, 1, 4, abfd) != 4)
d659 8
a666 3
  if (! srec_mkobject (abfd)
      || ! srec_scan (abfd))
    return NULL;
d680 1
d686 1
a686 1
      || bfd_read (b, 1, 2, abfd) != 2)
d695 8
a702 3
  if (! srec_mkobject (abfd)
      || ! srec_scan (abfd))
    return NULL;
d712 1
a712 1
static boolean
d720 1
a720 1
  boolean error = false;
d738 1
a738 1
         ought to know the exact format.  */
d741 1
a741 1
      if (bfd_read (hdr, 1, 3, abfd) != 3)
d752 1
a752 1
	  buf = (bfd_byte *) bfd_malloc (bytes * 2);
d758 1
a758 1
      if (bfd_read (buf, 1, bytes * 2, abfd) != bytes * 2)
d769 1
a769 1
	  return true;
d794 1
a794 1
	      return true;
d819 1
a819 1
  return true;
d824 1
a824 1
  return false;
d829 1
a829 1
static boolean
d840 2
a841 3
      if (section->used_by_bfd == NULL
	  && section->_raw_size != 0)
	return false;
d844 1
a844 1
	return false;
d850 1
a850 1
  return true;
d855 1
a855 1
static boolean
d864 1
a864 1
      return true;
d871 1
a871 1
static boolean
d883 1
a883 1
	   bfd_alloc (abfd, sizeof (srec_data_list_type)));
d885 1
a885 1
    return false;
d891 3
a893 1
      bfd_byte *data = (bfd_byte *) bfd_alloc (abfd, bytes_to_do);
d895 1
a895 1
	return false;
d898 1
a898 1
      /* Ff S3Forced is true then always select S3 records,
d915 1
a915 1
         adding a record to the end of the list.  */
d937 1
a937 1
  return true;
d944 1
a944 1
static boolean
d947 1
a947 1
     int type;
d952 1
a952 1
  char buffer[MAXCHUNK];
d954 1
a954 1
  CONST bfd_byte *src = data;
d1001 3
a1003 3
  if (bfd_write ((PTR) buffer, 1, wrlen, abfd) != wrlen)
    return false;
  return true;
d1006 1
a1006 1
static boolean
d1010 1
a1010 3
  bfd_byte buffer[MAXCHUNK];
  bfd_byte *dst = buffer;
  unsigned int i;
d1013 2
a1014 2
  for (i = 0; i < 40 && abfd->filename[i]; i++)
    *dst++ = abfd->filename[i];
d1016 2
a1017 1
  return srec_write_record (abfd, 0, 0, buffer, dst);
d1020 1
a1020 1
static boolean
d1029 11
d1055 1
a1055 1
	return false;
d1061 1
a1061 1
  return true;
d1064 1
a1064 1
static boolean
a1068 2
  bfd_byte buffer[2];

d1070 1
a1070 1
			    abfd->start_address, buffer, buffer);
d1073 1
a1073 1
static boolean
a1076 1
  char buffer[MAXCHUNK];
d1083 1
a1083 1
      size_t len;
d1085 5
a1089 5
      sprintf (buffer, "$$ %s\r\n", abfd->filename);

      len = strlen (buffer);
      if (bfd_write (buffer, len, 1, abfd) != len)
	return false;
d1098 1
a1098 2
	      bfd_size_type l;
	      char buf2[40], *p;
d1100 9
a1108 4
	      sprintf_vma (buf2,
			   s->value + s->section->output_section->lma
			   + s->section->output_offset);
	      p = buf2;
d1111 8
a1118 4
	      sprintf (buffer, "  %s $%s\r\n", s->name, p);
	      l = strlen (buffer);
	      if (bfd_write (buffer, l, 1, abfd) != l)
		return false;
d1121 2
a1122 4
      sprintf (buffer, "$$ \r\n");
      len = strlen (buffer);
      if (bfd_write (buffer, len, 1, abfd) != len)
	return false;
d1125 1
a1125 1
  return true;
d1128 1
a1128 1
static boolean
d1139 1
a1139 1
	return false;
d1143 1
a1143 1
    return false;
d1151 1
a1151 1
	return false;
d1157 1
a1157 1
static boolean
d1164 1
a1164 1
static boolean
d1174 1
a1174 1
     boolean exec ATTRIBUTE_UNUSED;
a1178 10
static asymbol *
srec_make_empty_symbol (abfd)
     bfd *abfd;
{
  asymbol *new = (asymbol *) bfd_zalloc (abfd, sizeof (asymbol));
  if (new)
    new->the_bfd = abfd;
  return new;
}

d1195 1
a1195 1
  unsigned int symcount = bfd_get_symcount (abfd);
d1207 1
a1207 1
	return false;
d1240 2
a1241 2
srec_print_symbol (ignore_abfd, afile, symbol, how)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d1253 1
a1253 1
      bfd_print_symbol_vandf ((PTR) file, symbol);
d1268 1
d1286 2
d1289 1
d1291 1
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d28 1
a28 1
	
d46 1
a46 1
	
d49 1
a49 1
	
d65 1
a65 1
	
a74 1

d104 1
a104 1
		
d145 1
a145 1
/* Macros for converting between hex and binary. */
d157 1
a157 1
/* Initialize by filling in the hex conversion array. */
d171 1
a171 1
/* The maximum number of bytes on a line is FF */
d173 13
a185 2
/* The number of bytes we fit onto a line on output */
#define CHUNK 16
d481 2
a482 1
	  while (c == ' ' || c == '\t');
d493 1
a493 1
    
d854 1
a854 1
/* we have to save up all the Srecords for a splurge before output */
d881 6
a886 4
      if ((section->lma + offset + bytes_to_do - 1) <= 0xffff)
	{

	}
d889 1
a889 3
	{
	  tdata->type = 2;
	}
d891 1
a891 3
	{
	  tdata->type = 3;
	}
d925 2
a926 2
   here
*/
d946 1
a946 1
  dst += 2;			/* leave room for dst*/
d974 1
a974 1
  /* Fill in the length */
a988 2


d997 1
a997 1
  /* I'll put an arbitary 40 char limit on header size */
d999 2
a1000 3
    {
      *dst++ = abfd->filename[i];
    }
d1018 2
a1019 2
      if (octets_this_chunk > CHUNK)
	octets_this_chunk = CHUNK;
a1047 2


d1053 1
a1053 1
  /* Dump out the symbols of a bfd */
d1073 1
a1073 1
	      /* Just dump out non debug symbols */
d1115 1
a1115 1
  /* Now wander though all the sections provided and output them */
a1140 1
/*ARGSUSED*/
d1202 1
a1202 1
	
a1209 1
/*ARGSUSED*/
a1218 1
/*ARGSUSED*/
d1321 1
a1321 1
  
a1324 2


d1376 1
a1376 1
  
@


1.3
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
d113 1
d174 1
a174 1
#define CHUNK 21
d290 1
a290 1
	("%s:%d: Unexpected character `%s' in S-record file\n",
d338 1
d381 2
a382 1
	      char *symname;
d390 1
a390 1
	      if (c == '\n')
d399 8
a406 1
	      obstack_1grow (&abfd->memory, c);
d409 16
a424 1
		obstack_1grow (&abfd->memory, c);
d431 2
a432 1
	      symname = obstack_finish (&abfd->memory);
d434 5
a438 5
		{
		  bfd_set_error (bfd_error_no_memory);
		  goto error_return;
		}
      
d472 3
a474 1
	  if (c != '\n')
a479 2
	  ++lineno;

d615 2
d646 3
d676 3
d874 1
a874 1
	       && tdata->type < 2)
d1003 1
a1003 1
  unsigned int bytes_written = 0;
d1006 1
a1006 1
  while (bytes_written < list->size)
d1009 1
d1011 2
a1012 6
      unsigned int bytes_this_chunk = list->size - bytes_written;

      if (bytes_this_chunk > CHUNK)
	{
	  bytes_this_chunk = CHUNK;
	}
d1014 1
a1014 1
      address = list->where + bytes_written;
d1020 1
a1020 1
			       location + bytes_this_chunk))
d1023 2
a1024 2
      bytes_written += bytes_this_chunk;
      location += bytes_this_chunk;
d1065 2
a1066 20
#if 0
	  int len = strlen (s->name);

	  /* If this symbol has a .[ocs] in it, it's probably a file name
	 and we'll output that as the module name */

	  if (len > 3 && s->name[len - 2] == '.')
	    {
	      int l;
	      sprintf (buffer, "$$ %s\r\n", s->name);
	      l = strlen (buffer);
	      if (bfd_write (buffer, l, 1, abfd) != l)
		return false;
	    }
	  else
#endif
	    if (s->flags & (BSF_GLOBAL | BSF_LOCAL)
		&& (s->flags & BSF_DEBUGGING) == 0
		&& s->name[0] != '.'
		&& s->name[0] != 't')
d1139 2
a1140 2
     bfd *abfd;
     boolean exec;
d1207 1
a1207 1
void
d1209 1
a1209 1
     bfd *ignore_abfd;
d1219 1
a1219 1
     bfd *ignore_abfd;
d1243 1
a1243 1
#define srec_bfd_is_local_label bfd_generic_is_local_label
d1262 1
d1318 2
d1375 2
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d112 2
d128 14
d376 12
a387 3
	  {
	    char *symname;
	    bfd_vma symval;
d389 5
a393 9
	    /* Starting a symbol definition.  */
	    while ((c = srec_get_byte (abfd, &error)) != EOF
		   && (c == ' ' || c == '\t'))
	      ;
	    if (c == EOF)
	      {
		srec_bad_byte (abfd, lineno, c, error);
		goto error_return;
	      }
a394 3
	    obstack_1grow (&abfd->memory, c);
	    while ((c = srec_get_byte (abfd, &error)) != EOF
		   && ! isspace (c))
d396 8
a403 5
	    if (c == EOF)
	      {
		srec_bad_byte (abfd, lineno, c, error);
		goto error_return;
	      }
d405 6
a410 6
	    symname = obstack_finish (&abfd->memory);
	    if (symname == NULL)
	      {
		bfd_set_error (bfd_error_no_memory);
		goto error_return;
	      }
d412 8
a419 8
	    while ((c = srec_get_byte (abfd, &error)) != EOF
		   && (c == ' ' || c == '\t'))
	      ;
	    if (c == EOF)
	      {
		srec_bad_byte (abfd, lineno, c, error);
		goto error_return;
	      }
d421 10
a430 10
	    /* Skip a dollar sign before the hex value.  */
	    if (c == '$')
	      {
		c = srec_get_byte (abfd, &error);
		if (c == EOF)
		  {
		    srec_bad_byte (abfd, lineno, c, error);
		    goto error_return;
		  }
	      }
d432 7
a438 7
	    symval = 0;
	    while (ISHEX (c))
	      {
		symval <<= 4;
		symval += NIBBLE (c);
		c = srec_get_byte (abfd, &error);
	      }
d440 1
a440 3
	    if (c == EOF || ! isspace (c))
	      {
		srec_bad_byte (abfd, lineno, c, error);
d442 2
a443 1
	      }
d445 3
a447 1
	    if (! srec_new_symbol (abfd, symname, symval))
d449 1
d451 1
a451 2
	    if (c == '\n')
	      ++lineno;
a452 1
	  }
d1203 1
a1203 1
void
@


1.1
log
@Initial revision
@
text
@d211 1
a211 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d290 1
a290 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d464 1
a464 1
		buf = (bfd_byte *) malloc (bytes * 2);
d466 1
a466 4
		  {
		    bfd_set_error (bfd_error_no_memory);
		    goto error_return;
		  }
d524 1
d668 1
a668 1
	  buf = (bfd_byte *) malloc (bytes * 2);
d670 1
a670 4
	    {
	      bfd_set_error (bfd_error_no_memory);
	      goto error_return;
	    }
d758 1
a758 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d770 16
d802 1
a802 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d810 1
a810 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d1148 1
a1148 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
a1223 2
#define srec_set_arch_mach bfd_default_set_arch_mach

d1236 2
a1237 2
  true,				/* target byte order */
  true,				/* target headers byte order */
d1291 2
a1292 2
  true,				/* target byte order */
  true,				/* target headers byte order */
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d211 4
a214 1
	return false;
d293 4
a296 1
    return false;
d470 1
a470 1
		buf = (bfd_byte *) bfd_malloc (bytes * 2);
d472 4
a475 1
		  goto error_return;
a532 1
		    sec->lma = address;
d676 1
a676 1
	  buf = (bfd_byte *) bfd_malloc (bytes * 2);
d678 4
a681 1
	    goto error_return;
d769 4
a772 1
	return false;
a783 16
/* Set the architecture.  We accept an unknown architecture here.  */

static boolean
srec_set_arch_mach (abfd, arch, mach)
     bfd *abfd;
     enum bfd_architecture arch;
     unsigned long mach;
{
  if (arch == bfd_arch_unknown)
    {
      abfd->arch_info = &bfd_default_arch_struct;
      return true;
    }
  return bfd_default_set_arch_mach (abfd, arch, mach);
}

d800 4
a803 1
    return false;
d811 4
a814 1
	return false;
d1152 4
a1155 1
	return false;
d1231 2
d1245 2
a1246 2
  BFD_ENDIAN_UNKNOWN,		/* target byte order */
  BFD_ENDIAN_UNKNOWN,		/* target headers byte order */
d1300 2
a1301 2
  BFD_ENDIAN_UNKNOWN,		/* target byte order */
  BFD_ENDIAN_UNKNOWN,		/* target headers byte order */
@


1.1.1.3
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a111 2
static void srec_print_symbol
 PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
a125 14
static boolean srec_new_symbol PARAMS ((bfd *, const char *, bfd_vma));
static boolean srec_get_section_contents
  PARAMS ((bfd *, asection *, PTR, file_ptr, bfd_size_type));
static boolean srec_set_arch_mach
  PARAMS ((bfd *, enum bfd_architecture, unsigned long));
static boolean srec_set_section_contents
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
static boolean internal_srec_write_object_contents PARAMS ((bfd *, int));
static boolean srec_write_object_contents PARAMS ((bfd *));
static boolean symbolsrec_write_object_contents PARAMS ((bfd *));
static int srec_sizeof_headers PARAMS ((bfd *, boolean));
static asymbol *srec_make_empty_symbol PARAMS ((bfd *));
static long srec_get_symtab_upper_bound PARAMS ((bfd *));
static long srec_get_symtab PARAMS ((bfd *, asymbol **));
d360 3
a362 4
	  do
	    {
	      char *symname;
	      bfd_vma symval;
d364 9
a372 13
	      /* Starting a symbol definition.  */
	      while ((c = srec_get_byte (abfd, &error)) != EOF
		     && (c == ' ' || c == '\t'))
		;

	      if (c == '\n')
		break;

	      if (c == EOF)
		{
		  srec_bad_byte (abfd, lineno, c, error);
		  goto error_return;
		}
d374 3
d378 5
a382 8
	      while ((c = srec_get_byte (abfd, &error)) != EOF
		     && ! isspace (c))
		obstack_1grow (&abfd->memory, c);
	      if (c == EOF)
		{
		  srec_bad_byte (abfd, lineno, c, error);
		  goto error_return;
		}
d384 6
a389 6
	      symname = obstack_finish (&abfd->memory);
	      if (symname == NULL)
		{
		  bfd_set_error (bfd_error_no_memory);
		  goto error_return;
		}
d391 8
a398 8
	      while ((c = srec_get_byte (abfd, &error)) != EOF
		     && (c == ' ' || c == '\t'))
		;
	      if (c == EOF)
		{
		  srec_bad_byte (abfd, lineno, c, error);
		  goto error_return;
		}
d400 10
a409 10
	      /* Skip a dollar sign before the hex value.  */
	      if (c == '$')
		{
		  c = srec_get_byte (abfd, &error);
		  if (c == EOF)
		    {
		      srec_bad_byte (abfd, lineno, c, error);
		      goto error_return;
		    }
		}
d411 7
a417 7
	      symval = 0;
	      while (ISHEX (c))
		{
		  symval <<= 4;
		  symval += NIBBLE (c);
		  c = srec_get_byte (abfd, &error);
		}
d419 3
a421 1
	      if (! srec_new_symbol (abfd, symname, symval))
d423 1
a423 2
	    }
	  while (c == ' ' || c == '\t');
d425 1
a425 3
	  if (c != '\n')
	    {
	      srec_bad_byte (abfd, lineno, c, error);
a426 1
	    }
d428 2
a429 1
	  ++lineno;
d431 1
d1182 1
a1182 1
static void
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
a111 1
static void srec_get_symbol_info PARAMS ((bfd *, asymbol *, symbol_info *));
a335 1
  char *symbuf = NULL;
d378 1
a378 2
	      unsigned int alc;
	      char *p, *symname;
d395 1
a395 8
	      alc = 10;
	      symbuf = (char *) bfd_malloc (alc + 1);
	      if (symbuf == NULL)
		goto error_return;

	      p = symbuf;

	      *p++ = c;
d398 1
a398 16
		{
		  if (p - symbuf >= alc)
		    {
		      char *n;

		      alc *= 2;
		      n = (char *) bfd_realloc (symbuf, alc + 1);
		      if (n == NULL)
			goto error_return;
		      p = n + (p - symbuf);
		      symbuf = n;
		    }

		  *p++ = c;
		}

d405 1
a405 2
	      *p++ = '\0';
	      symname = bfd_alloc (abfd, p - symbuf);
d407 5
a411 5
		goto error_return;
	      strcpy (symname, symbuf);
	      free (symbuf);
	      symbuf = NULL;

a587 2
  if (symbuf != NULL)
    free (symbuf);
d1193 1
a1193 1
static void
d1229 1
a1229 1
#define srec_bfd_is_local_label_name bfd_generic_is_local_label_name
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
   Free Software Foundation, Inc.
d173 1
a173 1
#define CHUNK 16
d289 1
a289 1
	(_("%s:%d: Unexpected character `%s' in S-record file\n"),
d389 1
a389 1
	      if (c == '\n' || c == '\r')
d409 1
a409 1
		  if ((unsigned int) (p - symbuf) >= alc)
d471 1
a471 3
	  if (c == '\n')
	    ++lineno;
	  else if (c != '\r')
d477 2
a644 3
  if (abfd->symcount > 0)
    abfd->flags |= HAS_SYMS;

a671 3
  if (abfd->symcount > 0)
    abfd->flags |= HAS_SYMS;

d867 1
a867 1
	       && tdata->type <= 2)
d996 1
a996 1
  unsigned int octets_written = 0;
d999 1
a999 1
  while (octets_written < list->size)
a1001 1
      unsigned int octets_this_chunk = list->size - octets_written;
d1003 1
a1003 2
      if (octets_this_chunk > CHUNK)
	octets_this_chunk = CHUNK;
d1005 6
a1010 1
      address = list->where + octets_written / bfd_octets_per_byte (abfd);
d1016 1
a1016 1
			       location + octets_this_chunk))
d1019 2
a1020 2
      octets_written += octets_this_chunk;
      location += octets_this_chunk;
d1061 20
a1080 2
	  if (! bfd_is_local_label (abfd, s)
	      && (s->flags & BSF_DEBUGGING) == 0)
d1153 2
a1154 2
     bfd *abfd ATTRIBUTE_UNUSED;
     boolean exec ATTRIBUTE_UNUSED;
d1223 1
a1223 1
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d1233 1
a1233 1
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
a1275 1
#define srec_bfd_gc_sections bfd_generic_gc_sections
a1330 2
  NULL,
  
a1385 2
  NULL,
  
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000
d27 1
a27 1

d45 1
a45 1

d48 1
a48 1

d64 1
a64 1

d74 1
d104 1
a104 1

d145 1
a145 1
/* Macros for converting between hex and binary.  */
d157 1
a157 1
/* Initialize by filling in the hex conversion array.  */
d171 1
a171 1
/* The maximum number of bytes on a line is FF.  */
d173 2
a174 13

/* Default size for a CHUNK.  */
#define DEFAULT_CHUNK 16

/* The number of bytes we actually fit onto a line on output.
   This variable can be modified by objcopy's --srec-len parameter.
   For a 0x75 byte record you should set --srec-len=0x70.  */
unsigned int Chunk = DEFAULT_CHUNK;

/* The type of srec output (free or forced to S3).
   This variable can be modified by objcopy's --srec-forceS3
   parameter.  */
boolean S3Forced = 0;
d470 1
a470 2
	  while (c == ' ' || c == '\t')
	    ;
d481 1
a481 1

d842 1
a842 1
/* We have to save up all the Srecords for a splurge before output.  */
d869 4
a872 6
      /* Ff S3Forced is true then always select S3 records,
	 regardless of the siez of the addresses.  */
      if (S3Forced)
	tdata->type = 3;
      else if ((section->lma + offset + bytes_to_do - 1) <= 0xffff)
	;  /* The default, S1, is OK.  */
d875 3
a877 1
	tdata->type = 2;
d879 3
a881 1
	tdata->type = 3;
d915 2
a916 2
   here.  */

d936 1
a936 1
  dst += 2;			/* Leave room for dst.  */
d964 1
a964 1
  /* Fill in the length.  */
d979 2
d989 1
a989 1
  /* I'll put an arbitary 40 char limit on header size.  */
d991 3
a993 2
    *dst++ = abfd->filename[i];

d1011 2
a1012 2
      if (octets_this_chunk > Chunk)
	octets_this_chunk = Chunk;
d1041 2
d1048 1
a1048 1
  /* Dump out the symbols of a bfd.  */
d1068 1
a1068 1
	      /* Just dump out non debug symbols.  */
d1110 1
a1110 1
  /* Now wander though all the sections provided and output them.  */
d1136 1
d1198 1
a1198 1

d1206 1
d1216 1
d1319 1
a1319 1

d1323 2
d1376 1
a1376 1

@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2000, 2001, 2002
d111 1
a111 1
#include "safe-ctype.h"
d117 4
a120 4
static bfd_boolean srec_mkobject PARAMS ((bfd *));
static int srec_get_byte PARAMS ((bfd *, bfd_boolean *));
static void srec_bad_byte PARAMS ((bfd *, unsigned int, int, bfd_boolean));
static bfd_boolean srec_scan PARAMS ((bfd *));
d123 1
a123 1
static bfd_boolean srec_read_section PARAMS ((bfd *, asection *, bfd_byte *));
d125 7
a131 6
static bfd_boolean srec_write_record
  PARAMS ((bfd *, unsigned int, bfd_vma, const bfd_byte *, const bfd_byte *));
static bfd_boolean srec_write_header PARAMS ((bfd *));
static bfd_boolean srec_write_symbols PARAMS ((bfd *));
static bfd_boolean srec_new_symbol PARAMS ((bfd *, const char *, bfd_vma));
static bfd_boolean srec_get_section_contents
d133 1
a133 1
static bfd_boolean srec_set_arch_mach
d135 1
a135 1
static bfd_boolean srec_set_section_contents
d137 5
a141 4
static bfd_boolean internal_srec_write_object_contents PARAMS ((bfd *, int));
static bfd_boolean srec_write_object_contents PARAMS ((bfd *));
static bfd_boolean symbolsrec_write_object_contents PARAMS ((bfd *));
static int srec_sizeof_headers PARAMS ((bfd *, bfd_boolean));
d147 1
a147 1
static const char digs[] = "0123456789ABCDEF";
d162 1
a162 1
  static bfd_boolean inited = FALSE;
d164 1
a164 1
  if (! inited)
d166 1
a166 1
      inited = TRUE;
d171 1
a171 1
/* The maximum number of address+data+crc bytes on a line is FF.  */
d177 1
a177 1
/* The number of data bytes we actually fit onto a line on output.
d185 1
a185 1
bfd_boolean S3Forced = FALSE;
d224 3
a226 4
static bfd_boolean srec_write_section
  PARAMS ((bfd *, tdata_type *, srec_data_list_type *));
static bfd_boolean srec_write_terminator
  PARAMS ((bfd *, tdata_type *));
d230 1
a230 1
static bfd_boolean
a233 3
  bfd_size_type amt;
  tdata_type *tdata;

d236 13
a248 12
  amt = sizeof (tdata_type);
  tdata = (tdata_type *) bfd_alloc (abfd, amt);
  if (tdata == NULL)
    return FALSE;

  abfd->tdata.srec_data = tdata;
  tdata->type = 1;
  tdata->head = NULL;
  tdata->tail = NULL;
  tdata->symbols = NULL;
  tdata->symtail = NULL;
  tdata->csymbols = NULL;
d250 1
a250 1
  return TRUE;
d259 1
a259 1
     bfd_boolean *errorptr;
d263 1
a263 1
  if (bfd_bread (&c, (bfd_size_type) 1, abfd) != 1)
d266 1
a266 1
	*errorptr = TRUE;
d282 1
a282 1
     bfd_boolean error;
d293 1
a293 1
      if (! ISPRINT (c))
d302 1
a302 1
	 bfd_archive_filename (abfd), lineno, buf);
d309 1
a309 1
static bfd_boolean
a315 1
  bfd_size_type amt = sizeof (struct srec_symbol);
d317 1
a317 1
  n = (struct srec_symbol *) bfd_alloc (abfd, amt);
d319 1
a319 1
    return FALSE;
d333 1
a333 1
  return TRUE;
d339 1
a339 1
static bfd_boolean
d345 1
a345 1
  bfd_boolean error = FALSE;
d357 1
a357 1
	 is not an S-record, then stop building a section.  */
d392 1
a392 1
	      bfd_size_type alc;
d419 1
a419 1
		     && ! ISSPACE (c))
d421 1
a421 1
		  if ((bfd_size_type) (p - symbuf) >= alc)
d443 1
a443 1
	      symname = bfd_alloc (abfd, (bfd_size_type) (p - symbuf));
d506 1
a506 1
	    if (bfd_bread (hdr, (bfd_size_type) 3, abfd) != 3)
d524 1
a524 1
		buf = (bfd_byte *) bfd_malloc ((bfd_size_type) bytes * 2);
d530 1
a530 1
	    if (bfd_bread (buf, (bfd_size_type) bytes * 2, abfd) != bytes * 2)
d543 1
a543 1
		   section at this point.  */
d568 1
a568 1
		       currently building.  */
a574 1
		    bfd_size_type amt;
d577 1
a577 2
		    amt = strlen (secbuf) + 1;
		    secname = (char *) bfd_alloc (abfd, amt);
d611 1
a611 1
		return TRUE;
d624 1
a624 1
  return TRUE;
d631 1
a631 1
  return FALSE;
a639 1
  PTR tdata_save;
d645 1
a645 1
      || bfd_bread (b, (bfd_size_type) 4, abfd) != 4)
d654 3
a656 8
  tdata_save = abfd->tdata.any;
  if (! srec_mkobject (abfd) || ! srec_scan (abfd))
    {
      if (abfd->tdata.any != tdata_save && abfd->tdata.any != NULL)
	bfd_release (abfd, abfd->tdata.any);
      abfd->tdata.any = tdata_save;
      return NULL;
    }
a669 1
  PTR tdata_save;
d675 1
a675 1
      || bfd_bread (b, (bfd_size_type) 2, abfd) != 2)
d684 3
a686 8
  tdata_save = abfd->tdata.any;
  if (! srec_mkobject (abfd) || ! srec_scan (abfd))
    {
      if (abfd->tdata.any != tdata_save && abfd->tdata.any != NULL)
	bfd_release (abfd, abfd->tdata.any);
      abfd->tdata.any = tdata_save;
      return NULL;
    }
d696 1
a696 1
static bfd_boolean
d704 1
a704 1
  bfd_boolean error = FALSE;
d722 1
a722 1
	 ought to know the exact format.  */
d725 1
a725 1
      if (bfd_bread (hdr, (bfd_size_type) 3, abfd) != 3)
d736 1
a736 1
	  buf = (bfd_byte *) bfd_malloc ((bfd_size_type) bytes * 2);
d742 1
a742 1
      if (bfd_bread (buf, (bfd_size_type) bytes * 2, abfd) != bytes * 2)
d753 1
a753 1
	  return TRUE;
d778 1
a778 1
	      return TRUE;
d803 1
a803 1
  return TRUE;
d808 1
a808 1
  return FALSE;
d813 1
a813 1
static bfd_boolean
d824 3
a826 2
      if (section->used_by_bfd == NULL && section->_raw_size != 0)
	return FALSE;
d829 1
a829 1
	return FALSE;
d835 1
a835 1
  return TRUE;
d840 1
a840 1
static bfd_boolean
d849 1
a849 1
      return TRUE;
d856 1
a856 1
static bfd_boolean
d868 1
a868 1
	   bfd_alloc (abfd, (bfd_size_type) sizeof (srec_data_list_type)));
d870 1
a870 1
    return FALSE;
d876 1
a876 3
      bfd_byte *data;

      data = (bfd_byte *) bfd_alloc (abfd, bytes_to_do);
d878 1
a878 1
	return FALSE;
d881 1
a881 1
      /* Ff S3Forced is TRUE then always select S3 records,
d898 1
a898 1
	 adding a record to the end of the list.  */
d920 1
a920 1
  return TRUE;
d927 1
a927 1
static bfd_boolean
d930 1
a930 1
     unsigned int type;
d935 1
a935 1
  char buffer[2 * MAXCHUNK + 6];
d937 1
a937 1
  const bfd_byte *src = data;
d984 3
a986 3
  if (bfd_bwrite ((PTR) buffer, wrlen, abfd) != wrlen)
    return FALSE;
  return TRUE;
d989 1
a989 1
static bfd_boolean
d993 3
a995 1
  unsigned int len = strlen (abfd->filename);
d998 2
a999 2
  if (len > 40)
    len = 40;
d1001 1
a1001 2
  return srec_write_record (abfd, 0, (bfd_vma) 0,
			    abfd->filename, abfd->filename + len);
d1004 1
a1004 1
static bfd_boolean
a1012 11
  /* Validate number of data bytes to write.  The srec length byte
     counts the address, data and crc bytes.  S1 (tdata->type == 1)
     records have two address bytes, S2 (tdata->type == 2) records
     have three, and S3 (tdata->type == 3) records have four.
     The total length can't exceed 255, and a zero data length will
     spin for a long time.  */
  if (Chunk == 0)
    Chunk = 1;
  else if (Chunk > MAXCHUNK - tdata->type - 2)
    Chunk = MAXCHUNK - tdata->type - 2;

d1028 1
a1028 1
	return FALSE;
d1034 1
a1034 1
  return TRUE;
d1037 1
a1037 1
static bfd_boolean
d1042 2
d1045 1
a1045 1
			    abfd->start_address, NULL, NULL);
d1048 1
a1048 1
static bfd_boolean
d1052 1
d1059 1
a1059 1
      bfd_size_type len;
d1061 5
a1065 5
      len = strlen (abfd->filename);
      if (bfd_bwrite ("$$ ", (bfd_size_type) 3, abfd) != 3
	  || bfd_bwrite (abfd->filename, len, abfd) != len
	  || bfd_bwrite ("\r\n", (bfd_size_type) 2, abfd) != 2)
	return FALSE;
d1074 2
a1075 1
	      char buf[43], *p;
d1077 4
a1080 9
	      len = strlen (s->name);
	      if (bfd_bwrite ("  ", (bfd_size_type) 2, abfd) != 2
		  || bfd_bwrite (s->name, len, abfd) != len)
		return FALSE;

	      sprintf_vma (buf + 2, (s->value
				     + s->section->output_section->lma
				     + s->section->output_offset));
	      p = buf + 2;
d1083 4
a1086 8
	      len = strlen (p);
	      p[len] = '\r';
	      p[len + 1] = '\n';
	      *--p = '$';
	      *--p = ' ';
	      len += 4;
	      if (bfd_bwrite (p, len, abfd) != len)
		return FALSE;
d1089 4
a1092 2
      if (bfd_bwrite ("$$ \r\n", (bfd_size_type) 5, abfd) != 5)
	return FALSE;
d1095 1
a1095 1
  return TRUE;
d1098 1
a1098 1
static bfd_boolean
d1109 1
a1109 1
	return FALSE;
d1113 1
a1113 1
    return FALSE;
d1121 1
a1121 1
	return FALSE;
d1127 1
a1127 1
static bfd_boolean
d1134 1
a1134 1
static bfd_boolean
d1144 1
a1144 1
     bfd_boolean exec ATTRIBUTE_UNUSED;
d1149 10
d1175 1
a1175 1
  bfd_size_type symcount = bfd_get_symcount (abfd);
d1187 1
a1187 1
	return 0;
d1220 2
a1221 2
srec_print_symbol (abfd, afile, symbol, how)
     bfd *abfd;
d1233 1
a1233 1
      bfd_print_symbol_vandf (abfd, (PTR) file, symbol);
a1247 1
#define srec_make_empty_symbol _bfd_generic_make_empty_symbol
a1264 2
#define srec_bfd_merge_sections bfd_generic_merge_sections
#define srec_bfd_discard_group bfd_generic_discard_group
a1265 1
#define srec_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
a1266 1
#define srec_bfd_link_just_syms _bfd_generic_link_just_syms
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d135 1
a135 1
  PARAMS ((bfd *, sec_ptr, const PTR, file_ptr, bfd_size_type));
d141 1
a141 1
static long srec_canonicalize_symtab PARAMS ((bfd *, asymbol **));
d875 1
a875 1
     const PTR location;
d1012 1
a1012 1
  /* I'll put an arbitrary 40 char limit on header size.  */
d1191 1
a1191 1
srec_canonicalize_symtab (abfd, alocation)
@


