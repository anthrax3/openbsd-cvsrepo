head	1.7;
access;
symbols
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.4
	FSF:1.1.1
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.08;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.22;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.30;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.22.24.30;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.15;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.09.04.19.00.52;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.06.07.11.05.42;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.07.11.05.42;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.09.04.17.37.59;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.19.15;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.45.42;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.25.12;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.16;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.22.27;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* MIPS-specific support for 64-bit ELF
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Ian Lance Taylor, Cygnus Support
   Linker support added by Mark Mitchell, CodeSourcery, LLC.
   <mark@@codesourcery.com>

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* This file supports the 64-bit MIPS ELF ABI.

   The MIPS 64-bit ELF ABI uses an unusual reloc format.  This file
   overrides the usual ELF reloc handling, and handles reading and
   writing the relocations here.  */

/* TODO: Many things are unsupported, even if there is some code for it
 .       (which was mostly stolen from elf32-mips.c and slightly adapted).
 .
 .   - Relocation handling for REL relocs is wrong in many cases and
 .     generally untested.
 .   - Relocation handling for RELA relocs related to GOT support are
 .     also likely to be wrong.
 .   - Support for MIPS16 is untested.
 .   - Combined relocs with RSS_* entries are unsupported.
 .   - The whole GOT handling for NewABI is missing, some parts of
 .     the OldABI version is still lying around and should be removed.
 */

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "aout/ar.h"
#include "bfdlink.h"
#include "genlink.h"
#include "elf-bfd.h"
#include "elfxx-mips.h"
#include "elf/mips.h"

/* Get the ECOFF swapping routines.  The 64-bit ABI is not supposed to
   use ECOFF.  However, we support it anyhow for an easier changeover.  */
#include "coff/sym.h"
#include "coff/symconst.h"
#include "coff/internal.h"
#include "coff/ecoff.h"
/* The 64 bit versions of the mdebug data structures are in alpha.h.  */
#include "coff/alpha.h"
#define ECOFF_SIGNED_64
#include "ecoffswap.h"

static void mips_elf64_swap_reloc_in
  (bfd *, const Elf64_Mips_External_Rel *, Elf64_Mips_Internal_Rela *);
static void mips_elf64_swap_reloca_in
  (bfd *, const Elf64_Mips_External_Rela *, Elf64_Mips_Internal_Rela *);
static void mips_elf64_swap_reloc_out
  (bfd *, const Elf64_Mips_Internal_Rela *, Elf64_Mips_External_Rel *);
static void mips_elf64_swap_reloca_out
  (bfd *, const Elf64_Mips_Internal_Rela *, Elf64_Mips_External_Rela *);
static void mips_elf64_be_swap_reloc_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
static void mips_elf64_be_swap_reloc_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
static void mips_elf64_be_swap_reloca_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
static void mips_elf64_be_swap_reloca_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
static reloc_howto_type *bfd_elf64_bfd_reloc_type_lookup
  (bfd *, bfd_reloc_code_real_type);
static reloc_howto_type *mips_elf64_rtype_to_howto
  (unsigned int, bfd_boolean);
static void mips_elf64_info_to_howto_rel
  (bfd *, arelent *, Elf_Internal_Rela *);
static void mips_elf64_info_to_howto_rela
  (bfd *, arelent *, Elf_Internal_Rela *);
static long mips_elf64_get_reloc_upper_bound
  (bfd *, asection *);
static long mips_elf64_canonicalize_reloc
  (bfd *, asection *, arelent **, asymbol **);
static long mips_elf64_get_dynamic_reloc_upper_bound
  (bfd *);
static long mips_elf64_canonicalize_dynamic_reloc
  (bfd *, arelent **, asymbol **);
static bfd_boolean mips_elf64_slurp_one_reloc_table
  (bfd *, asection *, Elf_Internal_Shdr *, bfd_size_type, arelent *,
   asymbol **, bfd_boolean);
static bfd_boolean mips_elf64_slurp_reloc_table
  (bfd *, asection *, asymbol **, bfd_boolean);
static void mips_elf64_write_relocs
  (bfd *, asection *, void *);
static void mips_elf64_write_rel
  (bfd *, asection *, Elf_Internal_Shdr *, int *, void *);
static void mips_elf64_write_rela
  (bfd *, asection *, Elf_Internal_Shdr *, int *, void *);
static bfd_reloc_status_type mips_elf64_gprel16_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type mips_elf64_literal_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type mips_elf64_gprel32_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type mips_elf64_shift6_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type mips16_jump_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type mips16_gprel_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_boolean mips_elf64_assign_gp
  (bfd *, bfd_vma *);
static bfd_reloc_status_type mips_elf64_final_gp
  (bfd *, asymbol *, bfd_boolean, char **, bfd_vma *);
static bfd_boolean mips_elf64_object_p
  (bfd *);
static irix_compat_t elf64_mips_irix_compat
  (bfd *);
static bfd_boolean elf64_mips_grok_prstatus
  (bfd *, Elf_Internal_Note *);
static bfd_boolean elf64_mips_grok_psinfo
  (bfd *, Elf_Internal_Note *);

extern const bfd_target bfd_elf64_bigmips_vec;
extern const bfd_target bfd_elf64_littlemips_vec;

/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
   from smaller values.  Start with zero, widen, *then* decrement.  */
#define MINUS_ONE	(((bfd_vma)0) - 1)

/* The number of local .got entries we reserve.  */
#define MIPS_RESERVED_GOTNO (2)

/* The relocation table used for SHT_REL sections.  */

static reloc_howto_type mips_elf64_howto_table_rel[] =
{
  /* No relocation.  */
  HOWTO (R_MIPS_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit relocation.  */
  HOWTO (R_MIPS_16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_16",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit relocation.  */
  HOWTO (R_MIPS_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit symbol relative relocation.  */
  HOWTO (R_MIPS_REL32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_REL32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 26 bit jump address.  */
  HOWTO (R_MIPS_26,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
				/* This needs complex overflow
				   detection, because the upper 36
				   bits must match the PC + 4.  */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_26",		/* name */
	 TRUE,			/* partial_inplace */
	 0x03ffffff,		/* src_mask */
	 0x03ffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* R_MIPS_HI16 and R_MIPS_LO16 are unsupported for NewABI REL.
     However, the native IRIX6 tools use them, so we try our best. */

  /* High 16 bits of symbol value.  */
  HOWTO (R_MIPS_HI16,		/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_hi16_reloc, /* special_function */
	 "R_MIPS_HI16",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of symbol value.  */
  HOWTO (R_MIPS_LO16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_lo16_reloc, /* special_function */
	 "R_MIPS_LO16",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GP relative reference.  */
  HOWTO (R_MIPS_GPREL16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips_elf64_gprel16_reloc, /* special_function */
	 "R_MIPS_GPREL16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Reference to literal section.  */
  HOWTO (R_MIPS_LITERAL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips_elf64_literal_reloc, /* special_function */
	 "R_MIPS_LITERAL",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Reference to global offset table.  */
  HOWTO (R_MIPS_GOT16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_got16_reloc, /* special_function */
	 "R_MIPS_GOT16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit PC relative reference.  */
  HOWTO (R_MIPS_PC16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_PC16",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 16 bit call through global offset table.  */
  HOWTO (R_MIPS_CALL16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_CALL16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit GP relative reference.  */
  HOWTO (R_MIPS_GPREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 mips_elf64_gprel32_reloc, /* special_function */
	 "R_MIPS_GPREL32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),

  /* A 5 bit shift field.  */
  HOWTO (R_MIPS_SHIFT5,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 5,			/* bitsize */
	 FALSE,			/* pc_relative */
	 6,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_SHIFT5",	/* name */
	 TRUE,			/* partial_inplace */
	 0x000007c0,		/* src_mask */
	 0x000007c0,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 6 bit shift field.  */
  HOWTO (R_MIPS_SHIFT6,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 6,			/* bitsize */
	 FALSE,			/* pc_relative */
	 6,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 mips_elf64_shift6_reloc, /* special_function */
	 "R_MIPS_SHIFT6",	/* name */
	 TRUE,			/* partial_inplace */
	 0x000007c4,		/* src_mask */
	 0x000007c4,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 64 bit relocation.  */
  HOWTO (R_MIPS_64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_64",		/* name */
	 TRUE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Displacement in the global offset table.  */
  HOWTO (R_MIPS_GOT_DISP,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_DISP",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Displacement to page pointer in the global offset table.  */
  HOWTO (R_MIPS_GOT_PAGE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_PAGE",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Offset from page pointer in the global offset table.  */
  HOWTO (R_MIPS_GOT_OFST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_OFST",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_GOT_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_GOT_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 64 bit subtraction.  */
  HOWTO (R_MIPS_SUB,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_SUB",		/* name */
	 TRUE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Insert the addend as an instruction.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_INSERT_A,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_INSERT_A",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Insert the addend as an instruction, and change all relocations
     to refer to the old instruction at the address.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_INSERT_B,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_INSERT_B",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Delete a 32 bit instruction.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_DELETE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_DELETE",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The MIPS ELF64 ABI Draft wants us to support these for REL relocations.
     We don't, because
       a) It means building the addend from a R_MIPS_HIGHEST/R_MIPS_HIGHER/
	  R_MIPS_HI16/R_MIPS_LO16 sequence with varying ordering, using
	  fallable heuristics.
       b) No other NewABI toolchain actually emits such relocations.  */
  EMPTY_HOWTO (R_MIPS_HIGHER),
  EMPTY_HOWTO (R_MIPS_HIGHEST),

  /* High 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_CALL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_CALL_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_CALL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_CALL_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Section displacement, used by an associated event location section.  */
  HOWTO (R_MIPS_SCN_DISP,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_SCN_DISP",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_MIPS_REL16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_REL16",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* These two are obsolete.  */
  EMPTY_HOWTO (R_MIPS_ADD_IMMEDIATE),
  EMPTY_HOWTO (R_MIPS_PJUMP),

  /* Similiar to R_MIPS_REL32, but used for relocations in a GOT section.
     It must be used for multigot GOT's (and only there).  */
  HOWTO (R_MIPS_RELGOT,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_RELGOT",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Protected jump conversion.  This is an optimization hint.  No
     relocation is required for correctness.  */
  HOWTO (R_MIPS_JALR,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_JALR",	        /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x00000000,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

/* The relocation table used for SHT_RELA sections.  */

static reloc_howto_type mips_elf64_howto_table_rela[] =
{
  /* No relocation.  */
  HOWTO (R_MIPS_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit relocation.  */
  HOWTO (R_MIPS_16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit relocation.  */
  HOWTO (R_MIPS_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_32",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit symbol relative relocation.  */
  HOWTO (R_MIPS_REL32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_REL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 26 bit jump address.  */
  HOWTO (R_MIPS_26,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
				/* This needs complex overflow
				   detection, because the upper 36
				   bits must match the PC + 4.  */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_26",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x03ffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of symbol value.  */
  HOWTO (R_MIPS_HI16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_HI16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of symbol value.  */
  HOWTO (R_MIPS_LO16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_LO16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GP relative reference.  */
  HOWTO (R_MIPS_GPREL16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips_elf64_gprel16_reloc, /* special_function */
	 "R_MIPS_GPREL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Reference to literal section.  */
  HOWTO (R_MIPS_LITERAL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips_elf64_literal_reloc, /* special_function */
	 "R_MIPS_LITERAL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Reference to global offset table.  */
  HOWTO (R_MIPS_GOT16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_GOT16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit PC relative reference.  */
  HOWTO (R_MIPS_PC16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_PC16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 16 bit call through global offset table.  */
  HOWTO (R_MIPS_CALL16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_CALL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit GP relative reference.  */
  HOWTO (R_MIPS_GPREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 mips_elf64_gprel32_reloc, /* special_function */
	 "R_MIPS_GPREL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),

  /* A 5 bit shift field.  */
  HOWTO (R_MIPS_SHIFT5,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 5,			/* bitsize */
	 FALSE,			/* pc_relative */
	 6,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_SHIFT5",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x000007c0,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 6 bit shift field.  */
  HOWTO (R_MIPS_SHIFT6,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 6,			/* bitsize */
	 FALSE,			/* pc_relative */
	 6,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 mips_elf64_shift6_reloc, /* special_function */
	 "R_MIPS_SHIFT6",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x000007c4,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 64 bit relocation.  */
  HOWTO (R_MIPS_64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_64",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Displacement in the global offset table.  */
  HOWTO (R_MIPS_GOT_DISP,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_DISP",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Displacement to page pointer in the global offset table.  */
  HOWTO (R_MIPS_GOT_PAGE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_PAGE",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Offset from page pointer in the global offset table.  */
  HOWTO (R_MIPS_GOT_OFST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_OFST",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_GOT_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_GOT_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_LO16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 64 bit subtraction.  */
  HOWTO (R_MIPS_SUB,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_SUB",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Insert the addend as an instruction.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_INSERT_A,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_INSERT_A",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Insert the addend as an instruction, and change all relocations
     to refer to the old instruction at the address.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_INSERT_B,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_INSERT_B",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Delete a 32 bit instruction.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_DELETE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_DELETE",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Get the higher value of a 64 bit addend.  */
  HOWTO (R_MIPS_HIGHER,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_HIGHER",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Get the highest value of a 64 bit addend.  */
  HOWTO (R_MIPS_HIGHEST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_HIGHEST",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_CALL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_CALL_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_CALL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_CALL_LO16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Section displacement, used by an associated event location section.  */
  HOWTO (R_MIPS_SCN_DISP,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_SCN_DISP",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_MIPS_REL16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_REL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* These two are obsolete.  */
  EMPTY_HOWTO (R_MIPS_ADD_IMMEDIATE),
  EMPTY_HOWTO (R_MIPS_PJUMP),

  /* Similiar to R_MIPS_REL32, but used for relocations in a GOT section.
     It must be used for multigot GOT's (and only there).  */
  HOWTO (R_MIPS_RELGOT,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_RELGOT",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Protected jump conversion.  This is an optimization hint.  No
     relocation is required for correctness.  */
  HOWTO (R_MIPS_JALR,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_JALR",	        /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x00000000,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

/* The reloc used for the mips16 jump instruction.  */
static reloc_howto_type elf_mips16_jump_howto =
  HOWTO (R_MIPS16_26,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 			/* This needs complex overflow
				   detection, because the upper four
				   bits must match the PC.  */
	 mips16_jump_reloc,	/* special_function */
	 "R_MIPS16_26",		/* name */
	 TRUE,			/* partial_inplace */
	 0x3ffffff,		/* src_mask */
	 0x3ffffff,		/* dst_mask */
	 FALSE);		/* pcrel_offset */

/* The reloc used for the mips16 gprel instruction.  */
static reloc_howto_type elf_mips16_gprel_howto =
  HOWTO (R_MIPS16_GPREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips16_gprel_reloc,	/* special_function */
	 "R_MIPS16_GPREL",	/* name */
	 TRUE,			/* partial_inplace */
	 0x07ff001f,		/* src_mask */
	 0x07ff001f,	        /* dst_mask */
	 FALSE);		/* pcrel_offset */

/* GNU extension to record C++ vtable hierarchy */
static reloc_howto_type elf_mips_gnu_vtinherit_howto =
  HOWTO (R_MIPS_GNU_VTINHERIT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_MIPS_GNU_VTINHERIT", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE);		/* pcrel_offset */

/* GNU extension to record C++ vtable member usage */
static reloc_howto_type elf_mips_gnu_vtentry_howto =
  HOWTO (R_MIPS_GNU_VTENTRY,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
	 "R_MIPS_GNU_VTENTRY",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE);		/* pcrel_offset */

/* 16 bit offset for pc-relative branches.  */
static reloc_howto_type elf_mips_gnu_rel16_s2 =
  HOWTO (R_MIPS_GNU_REL16_S2,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GNU_REL16_S2",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

/* 16 bit offset for pc-relative branches.  */
static reloc_howto_type elf_mips_gnu_rela16_s2 =
  HOWTO (R_MIPS_GNU_REL16_S2,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GNU_REL16_S2",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

/* Swap in a MIPS 64-bit Rel reloc.  */

static void
mips_elf64_swap_reloc_in (bfd *abfd, const Elf64_Mips_External_Rel *src,
			  Elf64_Mips_Internal_Rela *dst)
{
  dst->r_offset = H_GET_64 (abfd, src->r_offset);
  dst->r_sym = H_GET_32 (abfd, src->r_sym);
  dst->r_ssym = H_GET_8 (abfd, src->r_ssym);
  dst->r_type3 = H_GET_8 (abfd, src->r_type3);
  dst->r_type2 = H_GET_8 (abfd, src->r_type2);
  dst->r_type = H_GET_8 (abfd, src->r_type);
  dst->r_addend = 0;
}

/* Swap in a MIPS 64-bit Rela reloc.  */

static void
mips_elf64_swap_reloca_in (bfd *abfd, const Elf64_Mips_External_Rela *src,
			   Elf64_Mips_Internal_Rela *dst)
{
  dst->r_offset = H_GET_64 (abfd, src->r_offset);
  dst->r_sym = H_GET_32 (abfd, src->r_sym);
  dst->r_ssym = H_GET_8 (abfd, src->r_ssym);
  dst->r_type3 = H_GET_8 (abfd, src->r_type3);
  dst->r_type2 = H_GET_8 (abfd, src->r_type2);
  dst->r_type = H_GET_8 (abfd, src->r_type);
  dst->r_addend = H_GET_S64 (abfd, src->r_addend);
}

/* Swap out a MIPS 64-bit Rel reloc.  */

static void
mips_elf64_swap_reloc_out (bfd *abfd, const Elf64_Mips_Internal_Rela *src,
			   Elf64_Mips_External_Rel *dst)
{
  H_PUT_64 (abfd, src->r_offset, dst->r_offset);
  H_PUT_32 (abfd, src->r_sym, dst->r_sym);
  H_PUT_8 (abfd, src->r_ssym, dst->r_ssym);
  H_PUT_8 (abfd, src->r_type3, dst->r_type3);
  H_PUT_8 (abfd, src->r_type2, dst->r_type2);
  H_PUT_8 (abfd, src->r_type, dst->r_type);
}

/* Swap out a MIPS 64-bit Rela reloc.  */

static void
mips_elf64_swap_reloca_out (bfd *abfd, const Elf64_Mips_Internal_Rela *src,
			    Elf64_Mips_External_Rela *dst)
{
  H_PUT_64 (abfd, src->r_offset, dst->r_offset);
  H_PUT_32 (abfd, src->r_sym, dst->r_sym);
  H_PUT_8 (abfd, src->r_ssym, dst->r_ssym);
  H_PUT_8 (abfd, src->r_type3, dst->r_type3);
  H_PUT_8 (abfd, src->r_type2, dst->r_type2);
  H_PUT_8 (abfd, src->r_type, dst->r_type);
  H_PUT_S64 (abfd, src->r_addend, dst->r_addend);
}

/* Swap in a MIPS 64-bit Rel reloc.  */

static void
mips_elf64_be_swap_reloc_in (bfd *abfd, const bfd_byte *src,
			     Elf_Internal_Rela *dst)
{
  Elf64_Mips_Internal_Rela mirel;

  mips_elf64_swap_reloc_in (abfd,
			    (const Elf64_Mips_External_Rel *) src,
			    &mirel);

  dst[0].r_offset = mirel.r_offset;
  dst[0].r_info = ELF64_R_INFO (mirel.r_sym, mirel.r_type);
  dst[0].r_addend = 0;
  dst[1].r_offset = mirel.r_offset;
  dst[1].r_info = ELF64_R_INFO (mirel.r_ssym, mirel.r_type2);
  dst[1].r_addend = 0;
  dst[2].r_offset = mirel.r_offset;
  dst[2].r_info = ELF64_R_INFO (STN_UNDEF, mirel.r_type3);
  dst[2].r_addend = 0;
}

/* Swap in a MIPS 64-bit Rela reloc.  */

static void
mips_elf64_be_swap_reloca_in (bfd *abfd, const bfd_byte *src,
			      Elf_Internal_Rela *dst)
{
  Elf64_Mips_Internal_Rela mirela;

  mips_elf64_swap_reloca_in (abfd,
			     (const Elf64_Mips_External_Rela *) src,
			     &mirela);

  dst[0].r_offset = mirela.r_offset;
  dst[0].r_info = ELF64_R_INFO (mirela.r_sym, mirela.r_type);
  dst[0].r_addend = mirela.r_addend;
  dst[1].r_offset = mirela.r_offset;
  dst[1].r_info = ELF64_R_INFO (mirela.r_ssym, mirela.r_type2);
  dst[1].r_addend = 0;
  dst[2].r_offset = mirela.r_offset;
  dst[2].r_info = ELF64_R_INFO (STN_UNDEF, mirela.r_type3);
  dst[2].r_addend = 0;
}

/* Swap out a MIPS 64-bit Rel reloc.  */

static void
mips_elf64_be_swap_reloc_out (bfd *abfd, const Elf_Internal_Rela *src,
			      bfd_byte *dst)
{
  Elf64_Mips_Internal_Rela mirel;

  mirel.r_offset = src[0].r_offset;
  BFD_ASSERT(src[0].r_offset == src[1].r_offset);
#if 0
  BFD_ASSERT(src[0].r_offset == src[2].r_offset);
#endif

  mirel.r_type = ELF64_MIPS_R_TYPE (src[0].r_info);
  mirel.r_sym = ELF64_R_SYM (src[0].r_info);
  mirel.r_type2 = ELF64_MIPS_R_TYPE (src[1].r_info);
  mirel.r_ssym = ELF64_MIPS_R_SSYM (src[1].r_info);
  mirel.r_type3 = ELF64_MIPS_R_TYPE (src[2].r_info);

  mips_elf64_swap_reloc_out (abfd, &mirel,
			     (Elf64_Mips_External_Rel *) dst);
}

/* Swap out a MIPS 64-bit Rela reloc.  */

static void
mips_elf64_be_swap_reloca_out (bfd *abfd, const Elf_Internal_Rela *src,
			       bfd_byte *dst)
{
  Elf64_Mips_Internal_Rela mirela;

  mirela.r_offset = src[0].r_offset;
  BFD_ASSERT(src[0].r_offset == src[1].r_offset);
  BFD_ASSERT(src[0].r_offset == src[2].r_offset);

  mirela.r_type = ELF64_MIPS_R_TYPE (src[0].r_info);
  mirela.r_sym = ELF64_R_SYM (src[0].r_info);
  mirela.r_addend = src[0].r_addend;
  BFD_ASSERT(src[1].r_addend == 0);
  BFD_ASSERT(src[2].r_addend == 0);

  mirela.r_type2 = ELF64_MIPS_R_TYPE (src[1].r_info);
  mirela.r_ssym = ELF64_MIPS_R_SSYM (src[1].r_info);
  mirela.r_type3 = ELF64_MIPS_R_TYPE (src[2].r_info);

  mips_elf64_swap_reloca_out (abfd, &mirela,
			      (Elf64_Mips_External_Rela *) dst);
}

/* Set the GP value for OUTPUT_BFD.  Returns FALSE if this is a
   dangerous relocation.  */

static bfd_boolean
mips_elf64_assign_gp (bfd *output_bfd, bfd_vma *pgp)
{
  unsigned int count;
  asymbol **sym;
  unsigned int i;

  /* If we've already figured out what GP will be, just return it.  */
  *pgp = _bfd_get_gp_value (output_bfd);
  if (*pgp)
    return TRUE;

  count = bfd_get_symcount (output_bfd);
  sym = bfd_get_outsymbols (output_bfd);

  /* The linker script will have created a symbol named `_gp' with the
     appropriate value.  */
  if (sym == NULL)
    i = count;
  else
    {
      for (i = 0; i < count; i++, sym++)
	{
	  register const char *name;

	  name = bfd_asymbol_name (*sym);
	  if (*name == '_' && strcmp (name, "_gp") == 0)
	    {
	      *pgp = bfd_asymbol_value (*sym);
	      _bfd_set_gp_value (output_bfd, *pgp);
	      break;
	    }
	}
    }

  if (i >= count)
    {
      /* Only get the error once.  */
      *pgp = 4;
      _bfd_set_gp_value (output_bfd, *pgp);
      return FALSE;
    }

  return TRUE;
}

/* We have to figure out the gp value, so that we can adjust the
   symbol value correctly.  We look up the symbol _gp in the output
   BFD.  If we can't find it, we're stuck.  We cache it in the ELF
   target data.  We don't need to adjust the symbol value for an
   external symbol if we are producing relocatable output.  */

static bfd_reloc_status_type
mips_elf64_final_gp (bfd *output_bfd, asymbol *symbol, bfd_boolean relocatable,
		     char **error_message, bfd_vma *pgp)
{
  if (bfd_is_und_section (symbol->section)
      && ! relocatable)
    {
      *pgp = 0;
      return bfd_reloc_undefined;
    }

  *pgp = _bfd_get_gp_value (output_bfd);
  if (*pgp == 0
      && (! relocatable
	  || (symbol->flags & BSF_SECTION_SYM) != 0))
    {
      if (relocatable)
	{
	  /* Make up a value.  */
	  *pgp = symbol->section->output_section->vma /*+ 0x4000*/;
	  _bfd_set_gp_value (output_bfd, *pgp);
	}
      else if (!mips_elf64_assign_gp (output_bfd, pgp))
	{
	  *error_message =
	    (char *) _("GP relative relocation when _gp not defined");
	  return bfd_reloc_dangerous;
	}
    }

  return bfd_reloc_ok;
}

/* Do a R_MIPS_GPREL16 relocation.  This is a 16 bit value which must
   become the offset from the gp register.  */

static bfd_reloc_status_type
mips_elf64_gprel16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			  void *data, asection *input_section, bfd *output_bfd,
			  char **error_message)
{
  bfd_boolean relocatable;
  bfd_reloc_status_type ret;
  bfd_vma gp;

  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    relocatable = TRUE;
  else
    {
      relocatable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf64_final_gp (output_bfd, symbol, relocatable, error_message,
			     &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  return _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
					input_section, relocatable,
					data, gp);
}

/* Do a R_MIPS_LITERAL relocation.  */

static bfd_reloc_status_type
mips_elf64_literal_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			  void *data, asection *input_section, bfd *output_bfd,
			  char **error_message)
{
  bfd_boolean relocatable;
  bfd_reloc_status_type ret;
  bfd_vma gp;

  /* If we're relocating, and this is an external symbol, we don't
     want to change anything.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* FIXME: The entries in the .lit8 and .lit4 sections should be merged.  */
  if (output_bfd != NULL)
    relocatable = TRUE;
  else
    {
      relocatable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf64_final_gp (output_bfd, symbol, relocatable, error_message,
			     &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  return _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
					input_section, relocatable,
					data, gp);
}

/* Do a R_MIPS_GPREL32 relocation.  This is a 32 bit value which must
   become the offset from the gp register.  */

static bfd_reloc_status_type
mips_elf64_gprel32_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			  void *data, asection *input_section, bfd *output_bfd,
			  char **error_message)
{
  bfd_boolean relocatable;
  bfd_reloc_status_type ret;
  bfd_vma gp;
  bfd_vma relocation;
  bfd_vma val;

  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      *error_message = (char *)
	_("32bits gp relative relocation occurs for an external symbol");
      return bfd_reloc_outofrange;
    }

  if (output_bfd != NULL)
    relocatable = TRUE;
  else
    {
      relocatable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

    ret = mips_elf64_final_gp (output_bfd, symbol, relocatable,
			       error_message, &gp);
    if (ret != bfd_reloc_ok)
      return ret;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  /* Set val to the offset into the section or symbol.  */
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    val += bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);

  /* Adjust val for the final section location and GP value.  If we
     are producing relocatable output, we don't want to do this for
     an external symbol.  */
  if (! relocatable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  if (reloc_entry->howto->partial_inplace)
    bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);
  else
    reloc_entry->addend = val;

  if (relocatable)
    reloc_entry->address += input_section->output_offset;

  return bfd_reloc_ok;
}

/* Do a R_MIPS_SHIFT6 relocation. The MSB of the shift is stored at bit 2,
   the rest is at bits 6-10. The bitpos already got right by the howto.  */

static bfd_reloc_status_type
mips_elf64_shift6_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			 void *data, asection *input_section, bfd *output_bfd,
			 char **error_message)
{
  if (reloc_entry->howto->partial_inplace)
    {
      reloc_entry->addend = ((reloc_entry->addend & 0x00007c0)
			     | (reloc_entry->addend & 0x00000800) >> 9);
    }

  return _bfd_mips_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				      input_section, output_bfd,
				      error_message);
}

/* Handle a mips16 jump.  */

static bfd_reloc_status_type
mips16_jump_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		   asymbol *symbol, void *data ATTRIBUTE_UNUSED,
		   asection *input_section, bfd *output_bfd,
		   char **error_message ATTRIBUTE_UNUSED)
{
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* FIXME.  */
  {
    static bfd_boolean warned;

    if (! warned)
      (*_bfd_error_handler)
	(_("Linking mips16 objects into %s format is not supported"),
	 bfd_get_target (input_section->output_section->owner));
    warned = TRUE;
  }

  return bfd_reloc_undefined;
}

/* Handle a mips16 GP relative reloc.  */

static bfd_reloc_status_type
mips16_gprel_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		    void *data, asection *input_section, bfd *output_bfd,
		    char **error_message)
{
  bfd_boolean relocatable;
  bfd_reloc_status_type ret;
  bfd_vma gp;
  unsigned short extend = 0;
  unsigned short insn = 0;
  bfd_signed_vma val;
  bfd_vma relocation;

  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    relocatable = TRUE;
  else
    {
      relocatable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf64_final_gp (output_bfd, symbol, relocatable, error_message,
			     &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  /* Set val to the offset into the section or symbol.  */
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    {
      /* Pick up the mips16 extend instruction and the real instruction.  */
      extend = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address);
      insn = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address + 2);
      val += ((extend & 0x1f) << 11) | (extend & 0x7e0) | (insn & 0x1f);
    }

  _bfd_mips_elf_sign_extend(val, 16);

  /* Adjust val for the final section location and GP value.  If we
     are producing relocatable output, we don't want to do this for
     an external symbol.  */
  if (! relocatable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  if (reloc_entry->howto->partial_inplace)
    {
      bfd_put_16 (abfd,
		  (extend & 0xf800) | ((val >> 11) & 0x1f) | (val & 0x7e0),
		  (bfd_byte *) data + reloc_entry->address);
      bfd_put_16 (abfd,
		  (insn & 0xffe0) | (val & 0x1f),
		  (bfd_byte *) data + reloc_entry->address + 2);
    }
  else
    reloc_entry->addend = val;

  if (relocatable)
    reloc_entry->address += input_section->output_offset;
  else if (((val & ~0xffff) != ~0xffff) && ((val & ~0xffff) != 0))
    return bfd_reloc_overflow;

  return bfd_reloc_ok;
}

/* A mapping from BFD reloc types to MIPS ELF reloc types.  */

struct elf_reloc_map {
  bfd_reloc_code_real_type bfd_val;
  enum elf_mips_reloc_type elf_val;
};

static const struct elf_reloc_map mips_reloc_map[] =
{
  { BFD_RELOC_NONE, R_MIPS_NONE },
  { BFD_RELOC_16, R_MIPS_16 },
  { BFD_RELOC_32, R_MIPS_32 },
  /* There is no BFD reloc for R_MIPS_REL32.  */
  { BFD_RELOC_64, R_MIPS_64 },
  { BFD_RELOC_CTOR, R_MIPS_64 },
  { BFD_RELOC_16_PCREL, R_MIPS_PC16 },
  { BFD_RELOC_HI16_S, R_MIPS_HI16 },
  { BFD_RELOC_LO16, R_MIPS_LO16 },
  { BFD_RELOC_GPREL16, R_MIPS_GPREL16 },
  { BFD_RELOC_GPREL32, R_MIPS_GPREL32 },
  { BFD_RELOC_MIPS_JMP, R_MIPS_26 },
  { BFD_RELOC_MIPS_LITERAL, R_MIPS_LITERAL },
  { BFD_RELOC_MIPS_GOT16, R_MIPS_GOT16 },
  { BFD_RELOC_MIPS_CALL16, R_MIPS_CALL16 },
  { BFD_RELOC_MIPS_SHIFT5, R_MIPS_SHIFT5 },
  { BFD_RELOC_MIPS_SHIFT6, R_MIPS_SHIFT6 },
  { BFD_RELOC_MIPS_GOT_DISP, R_MIPS_GOT_DISP },
  { BFD_RELOC_MIPS_GOT_PAGE, R_MIPS_GOT_PAGE },
  { BFD_RELOC_MIPS_GOT_OFST, R_MIPS_GOT_OFST },
  { BFD_RELOC_MIPS_GOT_HI16, R_MIPS_GOT_HI16 },
  { BFD_RELOC_MIPS_GOT_LO16, R_MIPS_GOT_LO16 },
  { BFD_RELOC_MIPS_SUB, R_MIPS_SUB },
  { BFD_RELOC_MIPS_INSERT_A, R_MIPS_INSERT_A },
  { BFD_RELOC_MIPS_INSERT_B, R_MIPS_INSERT_B },
  { BFD_RELOC_MIPS_DELETE, R_MIPS_DELETE },
  { BFD_RELOC_MIPS_HIGHEST, R_MIPS_HIGHEST },
  { BFD_RELOC_MIPS_HIGHER, R_MIPS_HIGHER },
  { BFD_RELOC_MIPS_CALL_HI16, R_MIPS_CALL_HI16 },
  { BFD_RELOC_MIPS_CALL_LO16, R_MIPS_CALL_LO16 },
  { BFD_RELOC_MIPS_SCN_DISP, R_MIPS_SCN_DISP },
  { BFD_RELOC_MIPS_REL16, R_MIPS_REL16 },
  /* Use of R_MIPS_ADD_IMMEDIATE and R_MIPS_PJUMP is deprecated.  */
  { BFD_RELOC_MIPS_RELGOT, R_MIPS_RELGOT },
  { BFD_RELOC_MIPS_JALR, R_MIPS_JALR }
};

/* Given a BFD reloc type, return a howto structure.  */

static reloc_howto_type *
bfd_elf64_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				 bfd_reloc_code_real_type code)
{
  unsigned int i;
  /* FIXME: We default to RELA here instead of choosing the right
     relocation variant.  */
  reloc_howto_type *howto_table = mips_elf64_howto_table_rela;

  for (i = 0; i < sizeof (mips_reloc_map) / sizeof (struct elf_reloc_map);
       i++)
    {
      if (mips_reloc_map[i].bfd_val == code)
	return &howto_table[(int) mips_reloc_map[i].elf_val];
    }

  switch (code)
    {
    case BFD_RELOC_MIPS16_JMP:
      return &elf_mips16_jump_howto;
    case BFD_RELOC_MIPS16_GPREL:
      return &elf_mips16_gprel_howto;
    case BFD_RELOC_VTABLE_INHERIT:
      return &elf_mips_gnu_vtinherit_howto;
    case BFD_RELOC_VTABLE_ENTRY:
      return &elf_mips_gnu_vtentry_howto;
    case BFD_RELOC_16_PCREL_S2:
      return &elf_mips_gnu_rela16_s2;
    default:
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }
}

/* Given a MIPS Elf_Internal_Rel, fill in an arelent structure.  */

static reloc_howto_type *
mips_elf64_rtype_to_howto (unsigned int r_type, bfd_boolean rela_p)
{
  switch (r_type)
    {
    case R_MIPS16_26:
      return &elf_mips16_jump_howto;
    case R_MIPS16_GPREL:
      return &elf_mips16_gprel_howto;
    case R_MIPS_GNU_VTINHERIT:
      return &elf_mips_gnu_vtinherit_howto;
    case R_MIPS_GNU_VTENTRY:
      return &elf_mips_gnu_vtentry_howto;
    case R_MIPS_GNU_REL16_S2:
      if (rela_p)
	return &elf_mips_gnu_rela16_s2;
      else
	return &elf_mips_gnu_rel16_s2;
    default:
      BFD_ASSERT (r_type < (unsigned int) R_MIPS_max);
      if (rela_p)
	return &mips_elf64_howto_table_rela[r_type];
      else
	return &mips_elf64_howto_table_rel[r_type];
      break;
    }
}

/* Prevent relocation handling by bfd for MIPS ELF64.  */

static void
mips_elf64_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
			      arelent *cache_ptr ATTRIBUTE_UNUSED,
			      Elf_Internal_Rela *dst ATTRIBUTE_UNUSED)
{
  BFD_ASSERT (0);
}

static void
mips_elf64_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
			       arelent *cache_ptr ATTRIBUTE_UNUSED,
			       Elf_Internal_Rela *dst ATTRIBUTE_UNUSED)
{
  BFD_ASSERT (0);
}

/* Since each entry in an SHT_REL or SHT_RELA section can represent up
   to three relocs, we must tell the user to allocate more space.  */

static long
mips_elf64_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
{
  return (sec->reloc_count * 3 + 1) * sizeof (arelent *);
}

static long
mips_elf64_get_dynamic_reloc_upper_bound (bfd *abfd)
{
  return _bfd_elf_get_dynamic_reloc_upper_bound (abfd) * 3;
}

/* We must also copy more relocations than the corresponding functions
   in elf.c would, so the two following functions are slightly
   modified from elf.c, that multiply the external relocation count by
   3 to obtain the internal relocation count.  */

static long
mips_elf64_canonicalize_reloc (bfd *abfd, sec_ptr section,
			       arelent **relptr, asymbol **symbols)
{
  arelent *tblptr;
  unsigned int i;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if (! bed->s->slurp_reloc_table (abfd, section, symbols, FALSE))
    return -1;

  tblptr = section->relocation;
  for (i = 0; i < section->reloc_count * 3; i++)
    *relptr++ = tblptr++;

  *relptr = NULL;

  return section->reloc_count * 3;
}

static long
mips_elf64_canonicalize_dynamic_reloc (bfd *abfd, arelent **storage,
				       asymbol **syms)
{
  bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
  asection *s;
  long ret;

  if (elf_dynsymtab (abfd) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
  ret = 0;
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if (elf_section_data (s)->this_hdr.sh_link == elf_dynsymtab (abfd)
	  && (elf_section_data (s)->this_hdr.sh_type == SHT_REL
	      || elf_section_data (s)->this_hdr.sh_type == SHT_RELA))
	{
	  arelent *p;
	  long count, i;

	  if (! (*slurp_relocs) (abfd, s, syms, TRUE))
	    return -1;
	  count = s->_raw_size / elf_section_data (s)->this_hdr.sh_entsize * 3;
	  p = s->relocation;
	  for (i = 0; i < count; i++)
	    *storage++ = p++;
	  ret += count;
	}
    }

  *storage = NULL;

  return ret;
}

/* Read the relocations from one reloc section.  This is mostly copied
   from elfcode.h, except for the changes to expand one external
   relocation to 3 internal ones.  We must unfortunately set
   reloc_count to the number of external relocations, because a lot of
   generic code seems to depend on this.  */

static bfd_boolean
mips_elf64_slurp_one_reloc_table (bfd *abfd, asection *asect,
				  Elf_Internal_Shdr *rel_hdr,
				  bfd_size_type reloc_count,
				  arelent *relents, asymbol **symbols,
				  bfd_boolean dynamic)
{
  void *allocated;
  bfd_byte *native_relocs;
  arelent *relent;
  bfd_vma i;
  int entsize;
  bfd_boolean rela_p;

  allocated = bfd_malloc (rel_hdr->sh_size);
  if (allocated == NULL)
    return FALSE;

  if (bfd_seek (abfd, rel_hdr->sh_offset, SEEK_SET) != 0
      || (bfd_bread (allocated, rel_hdr->sh_size, abfd)
	  != rel_hdr->sh_size))
    goto error_return;

  native_relocs = allocated;

  entsize = rel_hdr->sh_entsize;
  BFD_ASSERT (entsize == sizeof (Elf64_Mips_External_Rel)
	      || entsize == sizeof (Elf64_Mips_External_Rela));

  if (entsize == sizeof (Elf64_Mips_External_Rel))
    rela_p = FALSE;
  else
    rela_p = TRUE;

  for (i = 0, relent = relents;
       i < reloc_count;
       i++, native_relocs += entsize)
    {
      Elf64_Mips_Internal_Rela rela;
      bfd_boolean used_sym, used_ssym;
      int ir;

      if (entsize == sizeof (Elf64_Mips_External_Rela))
	mips_elf64_swap_reloca_in (abfd,
				   (Elf64_Mips_External_Rela *) native_relocs,
				   &rela);
      else
	mips_elf64_swap_reloc_in (abfd,
				  (Elf64_Mips_External_Rel *) native_relocs,
				  &rela);

      /* Each entry represents exactly three actual relocations.  */

      used_sym = FALSE;
      used_ssym = FALSE;
      for (ir = 0; ir < 3; ir++)
	{
	  enum elf_mips_reloc_type type;

	  switch (ir)
	    {
	    default:
	      abort ();
	    case 0:
	      type = (enum elf_mips_reloc_type) rela.r_type;
	      break;
	    case 1:
	      type = (enum elf_mips_reloc_type) rela.r_type2;
	      break;
	    case 2:
	      type = (enum elf_mips_reloc_type) rela.r_type3;
	      break;
	    }

	  /* Some types require symbols, whereas some do not.  */
	  switch (type)
	    {
	    case R_MIPS_NONE:
	    case R_MIPS_LITERAL:
	    case R_MIPS_INSERT_A:
	    case R_MIPS_INSERT_B:
	    case R_MIPS_DELETE:
	      relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
	      break;

	    default:
	      if (! used_sym)
		{
		  if (rela.r_sym == 0)
		    relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
		  else
		    {
		      asymbol **ps, *s;

		      ps = symbols + rela.r_sym - 1;
		      s = *ps;
		      if ((s->flags & BSF_SECTION_SYM) == 0)
			relent->sym_ptr_ptr = ps;
		      else
			relent->sym_ptr_ptr = s->section->symbol_ptr_ptr;
		    }

		  used_sym = TRUE;
		}
	      else if (! used_ssym)
		{
		  switch (rela.r_ssym)
		    {
		    case RSS_UNDEF:
		      relent->sym_ptr_ptr =
			bfd_abs_section_ptr->symbol_ptr_ptr;
		      break;

		    case RSS_GP:
		    case RSS_GP0:
		    case RSS_LOC:
		      /* FIXME: I think these need to be handled using
                         special howto structures.  */
		      BFD_ASSERT (0);
		      break;

		    default:
		      BFD_ASSERT (0);
		      break;
		    }

		  used_ssym = TRUE;
		}
	      else
		relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;

	      break;
	    }

	  /* The address of an ELF reloc is section relative for an
	     object file, and absolute for an executable file or
	     shared library.  The address of a BFD reloc is always
	     section relative.  */
	  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0 || dynamic)
	    relent->address = rela.r_offset;
	  else
	    relent->address = rela.r_offset - asect->vma;

	  relent->addend = rela.r_addend;

	  relent->howto = mips_elf64_rtype_to_howto (type, rela_p);

	  ++relent;
	}
    }

  asect->reloc_count += (relent - relents) / 3;

  if (allocated != NULL)
    free (allocated);

  return TRUE;

 error_return:
  if (allocated != NULL)
    free (allocated);
  return FALSE;
}

/* Read the relocations.  On Irix 6, there can be two reloc sections
   associated with a single data section.  This is copied from
   elfcode.h as well, with changes as small as accounting for 3
   internal relocs per external reloc and resetting reloc_count to
   zero before processing the relocs of a section.  */

static bfd_boolean
mips_elf64_slurp_reloc_table (bfd *abfd, asection *asect,
			      asymbol **symbols, bfd_boolean dynamic)
{
  struct bfd_elf_section_data * const d = elf_section_data (asect);
  Elf_Internal_Shdr *rel_hdr;
  Elf_Internal_Shdr *rel_hdr2;
  bfd_size_type reloc_count;
  bfd_size_type reloc_count2;
  arelent *relents;
  bfd_size_type amt;

  if (asect->relocation != NULL)
    return TRUE;

  if (! dynamic)
    {
      if ((asect->flags & SEC_RELOC) == 0
	  || asect->reloc_count == 0)
	return TRUE;

      rel_hdr = &d->rel_hdr;
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
      rel_hdr2 = d->rel_hdr2;
      reloc_count2 = (rel_hdr2 ? NUM_SHDR_ENTRIES (rel_hdr2) : 0);

      BFD_ASSERT (asect->reloc_count == reloc_count + reloc_count2);
      BFD_ASSERT (asect->rel_filepos == rel_hdr->sh_offset
		  || (rel_hdr2 && asect->rel_filepos == rel_hdr2->sh_offset));

    }
  else
    {
      /* Note that ASECT->RELOC_COUNT tends not to be accurate in this
	 case because relocations against this section may use the
	 dynamic symbol table, and in that case bfd_section_from_shdr
	 in elf.c does not update the RELOC_COUNT.  */
      if (asect->_raw_size == 0)
	return TRUE;

      rel_hdr = &d->this_hdr;
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
      rel_hdr2 = NULL;
      reloc_count2 = 0;
    }

  /* Allocate space for 3 arelent structures for each Rel structure.  */
  amt = (reloc_count + reloc_count2) * 3 * sizeof (arelent);
  relents = bfd_alloc (abfd, amt);
  if (relents == NULL)
    return FALSE;

  /* The slurp_one_reloc_table routine increments reloc_count.  */
  asect->reloc_count = 0;

  if (! mips_elf64_slurp_one_reloc_table (abfd, asect,
					  rel_hdr, reloc_count,
					  relents,
					  symbols, dynamic))
    return FALSE;
  if (d->rel_hdr2 != NULL)
    {
      if (! mips_elf64_slurp_one_reloc_table (abfd, asect,
					      rel_hdr2, reloc_count2,
					      relents + reloc_count * 3,
					      symbols, dynamic))
	return FALSE;
    }

  asect->relocation = relents;
  return TRUE;
}

/* Write out the relocations.  */

static void
mips_elf64_write_relocs (bfd *abfd, asection *sec, void *data)
{
  bfd_boolean *failedp = data;
  int count;
  Elf_Internal_Shdr *rel_hdr;
  unsigned int idx;

  /* If we have already failed, don't do anything.  */
  if (*failedp)
    return;

  if ((sec->flags & SEC_RELOC) == 0)
    return;

  /* The linker backend writes the relocs out itself, and sets the
     reloc_count field to zero to inhibit writing them here.  Also,
     sometimes the SEC_RELOC flag gets set even when there aren't any
     relocs.  */
  if (sec->reloc_count == 0)
    return;

  /* We can combine up to three relocs that refer to the same address
     if the latter relocs have no associated symbol.  */
  count = 0;
  for (idx = 0; idx < sec->reloc_count; idx++)
    {
      bfd_vma addr;
      unsigned int i;

      ++count;

      addr = sec->orelocation[idx]->address;
      for (i = 0; i < 2; i++)
	{
	  arelent *r;

	  if (idx + 1 >= sec->reloc_count)
	    break;
	  r = sec->orelocation[idx + 1];
	  if (r->address != addr
	      || ! bfd_is_abs_section ((*r->sym_ptr_ptr)->section)
	      || (*r->sym_ptr_ptr)->value != 0)
	    break;

	  /* We can merge the reloc at IDX + 1 with the reloc at IDX.  */

	  ++idx;
	}
    }

  rel_hdr = &elf_section_data (sec)->rel_hdr;

  /* Do the actual relocation.  */

  if (rel_hdr->sh_entsize == sizeof(Elf64_Mips_External_Rel))
    mips_elf64_write_rel (abfd, sec, rel_hdr, &count, data);
  else if (rel_hdr->sh_entsize == sizeof(Elf64_Mips_External_Rela))
    mips_elf64_write_rela (abfd, sec, rel_hdr, &count, data);
  else
    BFD_ASSERT (0);
}

static void
mips_elf64_write_rel (bfd *abfd, asection *sec,
		      Elf_Internal_Shdr *rel_hdr,
		      int *count, void *data)
{
  bfd_boolean *failedp = data;
  Elf64_Mips_External_Rel *ext_rel;
  unsigned int idx;
  asymbol *last_sym = 0;
  int last_sym_idx = 0;

  rel_hdr->sh_size = rel_hdr->sh_entsize * *count;
  rel_hdr->contents = bfd_alloc (abfd, rel_hdr->sh_size);
  if (rel_hdr->contents == NULL)
    {
      *failedp = TRUE;
      return;
    }

  ext_rel = (Elf64_Mips_External_Rel *) rel_hdr->contents;
  for (idx = 0; idx < sec->reloc_count; idx++, ext_rel++)
    {
      arelent *ptr;
      Elf64_Mips_Internal_Rela int_rel;
      asymbol *sym;
      int n;
      unsigned int i;

      ptr = sec->orelocation[idx];

      /* The address of an ELF reloc is section relative for an object
	 file, and absolute for an executable file or shared library.
	 The address of a BFD reloc is always section relative.  */
      if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
	int_rel.r_offset = ptr->address;
      else
	int_rel.r_offset = ptr->address + sec->vma;

      sym = *ptr->sym_ptr_ptr;
      if (sym == last_sym)
	n = last_sym_idx;
      else
	{
	  last_sym = sym;
	  n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
	  if (n < 0)
	    {
	      *failedp = TRUE;
	      return;
	    }
	  last_sym_idx = n;
	}

      int_rel.r_sym = n;
      int_rel.r_ssym = RSS_UNDEF;

      if ((*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
	  && ! _bfd_elf_validate_reloc (abfd, ptr))
	{
	  *failedp = TRUE;
	  return;
	}

      int_rel.r_type = ptr->howto->type;
      int_rel.r_type2 = (int) R_MIPS_NONE;
      int_rel.r_type3 = (int) R_MIPS_NONE;

      for (i = 0; i < 2; i++)
	{
	  arelent *r;

	  if (idx + 1 >= sec->reloc_count)
	    break;
	  r = sec->orelocation[idx + 1];
	  if (r->address != ptr->address
	      || ! bfd_is_abs_section ((*r->sym_ptr_ptr)->section)
	      || (*r->sym_ptr_ptr)->value != 0)
	    break;

	  /* We can merge the reloc at IDX + 1 with the reloc at IDX.  */

	  if (i == 0)
	    int_rel.r_type2 = r->howto->type;
	  else
	    int_rel.r_type3 = r->howto->type;

	  ++idx;
	}

      mips_elf64_swap_reloc_out (abfd, &int_rel, ext_rel);
    }

  BFD_ASSERT (ext_rel - (Elf64_Mips_External_Rel *) rel_hdr->contents
	      == *count);
}

static void
mips_elf64_write_rela (bfd *abfd, asection *sec,
		       Elf_Internal_Shdr *rela_hdr,
		       int *count, void *data)
{
  bfd_boolean *failedp = data;
  Elf64_Mips_External_Rela *ext_rela;
  unsigned int idx;
  asymbol *last_sym = 0;
  int last_sym_idx = 0;

  rela_hdr->sh_size = rela_hdr->sh_entsize * *count;
  rela_hdr->contents = bfd_alloc (abfd, rela_hdr->sh_size);
  if (rela_hdr->contents == NULL)
    {
      *failedp = TRUE;
      return;
    }

  ext_rela = (Elf64_Mips_External_Rela *) rela_hdr->contents;
  for (idx = 0; idx < sec->reloc_count; idx++, ext_rela++)
    {
      arelent *ptr;
      Elf64_Mips_Internal_Rela int_rela;
      asymbol *sym;
      int n;
      unsigned int i;

      ptr = sec->orelocation[idx];

      /* The address of an ELF reloc is section relative for an object
	 file, and absolute for an executable file or shared library.
	 The address of a BFD reloc is always section relative.  */
      if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
	int_rela.r_offset = ptr->address;
      else
	int_rela.r_offset = ptr->address + sec->vma;

      sym = *ptr->sym_ptr_ptr;
      if (sym == last_sym)
	n = last_sym_idx;
      else
	{
	  last_sym = sym;
	  n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
	  if (n < 0)
	    {
	      *failedp = TRUE;
	      return;
	    }
	  last_sym_idx = n;
	}

      int_rela.r_sym = n;
      int_rela.r_addend = ptr->addend;
      int_rela.r_ssym = RSS_UNDEF;

      if ((*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
	  && ! _bfd_elf_validate_reloc (abfd, ptr))
	{
	  *failedp = TRUE;
	  return;
	}

      int_rela.r_type = ptr->howto->type;
      int_rela.r_type2 = (int) R_MIPS_NONE;
      int_rela.r_type3 = (int) R_MIPS_NONE;

      for (i = 0; i < 2; i++)
	{
	  arelent *r;

	  if (idx + 1 >= sec->reloc_count)
	    break;
	  r = sec->orelocation[idx + 1];
	  if (r->address != ptr->address
	      || ! bfd_is_abs_section ((*r->sym_ptr_ptr)->section)
	      || (*r->sym_ptr_ptr)->value != 0)
	    break;

	  /* We can merge the reloc at IDX + 1 with the reloc at IDX.  */

	  if (i == 0)
	    int_rela.r_type2 = r->howto->type;
	  else
	    int_rela.r_type3 = r->howto->type;

	  ++idx;
	}

      mips_elf64_swap_reloca_out (abfd, &int_rela, ext_rela);
    }

  BFD_ASSERT (ext_rela - (Elf64_Mips_External_Rela *) rela_hdr->contents
	      == *count);
}

/* Set the right machine number for a MIPS ELF file.  */

static bfd_boolean
mips_elf64_object_p (bfd *abfd)
{
  unsigned long mach;

  /* Irix 6 is broken.  Object file symbol tables are not always
     sorted correctly such that local symbols precede global symbols,
     and the sh_info field in the symbol table is not always right.  */
  if (elf64_mips_irix_compat (abfd) != ict_none)
    elf_bad_symtab (abfd) = TRUE;

  mach = _bfd_elf_mips_mach (elf_elfheader (abfd)->e_flags);
  bfd_default_set_arch_mach (abfd, bfd_arch_mips, mach);
  return TRUE;
}

/* Depending on the target vector we generate some version of Irix
   executables or "normal" MIPS ELF ABI executables.  */
static irix_compat_t
elf64_mips_irix_compat (bfd *abfd)
{
  if ((abfd->xvec == &bfd_elf64_bigmips_vec)
      || (abfd->xvec == &bfd_elf64_littlemips_vec))
    return ict_irix6;
  else
    return ict_none;
}

/* Support for core dump NOTE sections.  */
static bfd_boolean
elf64_mips_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  int offset;
  unsigned int raw_size;

  switch (note->descsz)
    {
      default:
	return FALSE;

      case 480:		/* Linux/MIPS - N64 kernel */
	/* pr_cursig */
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 32);

	/* pr_reg */
	offset = 112;
	raw_size = 360;

	break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  raw_size, note->descpos + offset);
}

static bfd_boolean
elf64_mips_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->descsz)
    {
      default:
	return FALSE;

      case 136:		/* Linux/MIPS - N64 kernel elf_prpsinfo */
	elf_tdata (abfd)->core_program
	 = _bfd_elfcore_strndup (abfd, note->descdata + 40, 16);
	elf_tdata (abfd)->core_command
	 = _bfd_elfcore_strndup (abfd, note->descdata + 56, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core_command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return TRUE;
}

/* ECOFF swapping routines.  These are used when dealing with the
   .mdebug section, which is in the ECOFF debugging format.  */
static const struct ecoff_debug_swap mips_elf64_ecoff_debug_swap =
{
  /* Symbol table magic number.  */
  magicSym2,
  /* Alignment of debugging information.  E.g., 4.  */
  8,
  /* Sizes of external symbolic information.  */
  sizeof (struct hdr_ext),
  sizeof (struct dnr_ext),
  sizeof (struct pdr_ext),
  sizeof (struct sym_ext),
  sizeof (struct opt_ext),
  sizeof (struct fdr_ext),
  sizeof (struct rfd_ext),
  sizeof (struct ext_ext),
  /* Functions to swap in external symbolic data.  */
  ecoff_swap_hdr_in,
  ecoff_swap_dnr_in,
  ecoff_swap_pdr_in,
  ecoff_swap_sym_in,
  ecoff_swap_opt_in,
  ecoff_swap_fdr_in,
  ecoff_swap_rfd_in,
  ecoff_swap_ext_in,
  _bfd_ecoff_swap_tir_in,
  _bfd_ecoff_swap_rndx_in,
  /* Functions to swap out external symbolic data.  */
  ecoff_swap_hdr_out,
  ecoff_swap_dnr_out,
  ecoff_swap_pdr_out,
  ecoff_swap_sym_out,
  ecoff_swap_opt_out,
  ecoff_swap_fdr_out,
  ecoff_swap_rfd_out,
  ecoff_swap_ext_out,
  _bfd_ecoff_swap_tir_out,
  _bfd_ecoff_swap_rndx_out,
  /* Function to read in symbolic data.  */
  _bfd_mips_elf_read_ecoff_info
};

/* Relocations in the 64 bit MIPS ELF ABI are more complex than in
   standard ELF.  This structure is used to redirect the relocation
   handling routines.  */

const struct elf_size_info mips_elf64_size_info =
{
  sizeof (Elf64_External_Ehdr),
  sizeof (Elf64_External_Phdr),
  sizeof (Elf64_External_Shdr),
  sizeof (Elf64_Mips_External_Rel),
  sizeof (Elf64_Mips_External_Rela),
  sizeof (Elf64_External_Sym),
  sizeof (Elf64_External_Dyn),
  sizeof (Elf_External_Note),
  4,            /* hash-table entry size */
  3,            /* internal relocations per external relocations */
  64,		/* arch_size */
  3,		/* log_file_align */
  ELFCLASS64,
  EV_CURRENT,
  bfd_elf64_write_out_phdrs,
  bfd_elf64_write_shdrs_and_ehdr,
  mips_elf64_write_relocs,
  bfd_elf64_swap_symbol_in,
  bfd_elf64_swap_symbol_out,
  mips_elf64_slurp_reloc_table,
  bfd_elf64_slurp_symbol_table,
  bfd_elf64_swap_dyn_in,
  bfd_elf64_swap_dyn_out,
  mips_elf64_be_swap_reloc_in,
  mips_elf64_be_swap_reloc_out,
  mips_elf64_be_swap_reloca_in,
  mips_elf64_be_swap_reloca_out
};

#define ELF_ARCH			bfd_arch_mips
#define ELF_MACHINE_CODE		EM_MIPS

#define elf_backend_collect		TRUE
#define elf_backend_type_change_ok	TRUE
#define elf_backend_can_gc_sections	TRUE
#define elf_info_to_howto		mips_elf64_info_to_howto_rela
#define elf_info_to_howto_rel		mips_elf64_info_to_howto_rel
#define elf_backend_object_p		mips_elf64_object_p
#define elf_backend_symbol_processing	_bfd_mips_elf_symbol_processing
#define elf_backend_section_processing	_bfd_mips_elf_section_processing
#define elf_backend_section_from_shdr	_bfd_mips_elf_section_from_shdr
#define elf_backend_fake_sections	_bfd_mips_elf_fake_sections
#define elf_backend_section_from_bfd_section \
				_bfd_mips_elf_section_from_bfd_section
#define elf_backend_add_symbol_hook	_bfd_mips_elf_add_symbol_hook
#define elf_backend_link_output_symbol_hook \
				_bfd_mips_elf_link_output_symbol_hook
#define elf_backend_create_dynamic_sections \
				_bfd_mips_elf_create_dynamic_sections
#define elf_backend_check_relocs	_bfd_mips_elf_check_relocs
#define elf_backend_adjust_dynamic_symbol \
				_bfd_mips_elf_adjust_dynamic_symbol
#define elf_backend_always_size_sections \
				_bfd_mips_elf_always_size_sections
#define elf_backend_size_dynamic_sections \
				_bfd_mips_elf_size_dynamic_sections
#define elf_backend_relocate_section    _bfd_mips_elf_relocate_section
#define elf_backend_finish_dynamic_symbol \
				_bfd_mips_elf_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
				_bfd_mips_elf_finish_dynamic_sections
#define elf_backend_final_write_processing \
				_bfd_mips_elf_final_write_processing
#define elf_backend_additional_program_headers \
				_bfd_mips_elf_additional_program_headers
#define elf_backend_modify_segment_map	_bfd_mips_elf_modify_segment_map
#define elf_backend_gc_mark_hook	_bfd_mips_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook	_bfd_mips_elf_gc_sweep_hook
#define elf_backend_copy_indirect_symbol \
					_bfd_mips_elf_copy_indirect_symbol
#define elf_backend_hide_symbol		_bfd_mips_elf_hide_symbol
#define elf_backend_ignore_discarded_relocs \
					_bfd_mips_elf_ignore_discarded_relocs
#define elf_backend_mips_irix_compat	elf64_mips_irix_compat
#define elf_backend_mips_rtype_to_howto	mips_elf64_rtype_to_howto
#define elf_backend_ecoff_debug_swap	&mips_elf64_ecoff_debug_swap
#define elf_backend_size_info		mips_elf64_size_info

#define elf_backend_grok_prstatus	elf64_mips_grok_prstatus
#define elf_backend_grok_psinfo		elf64_mips_grok_psinfo

#define elf_backend_got_header_size	(4 * MIPS_RESERVED_GOTNO)

/* MIPS ELF64 can use a mixture of REL and RELA, but some Relocations
   work better/work only in RELA, so we default to this.  */
#define elf_backend_may_use_rel_p	1
#define elf_backend_may_use_rela_p	1
#define elf_backend_default_use_rela_p	1

#define elf_backend_write_section	_bfd_mips_elf_write_section

/* We don't set bfd_elf64_bfd_is_local_label_name because the 32-bit
   MIPS-specific function only applies to IRIX5, which had no 64-bit
   ABI.  */
#define bfd_elf64_find_nearest_line	_bfd_mips_elf_find_nearest_line
#define bfd_elf64_new_section_hook	_bfd_mips_elf_new_section_hook
#define bfd_elf64_set_section_contents	_bfd_mips_elf_set_section_contents
#define bfd_elf64_bfd_get_relocated_section_contents \
				_bfd_elf_mips_get_relocated_section_contents
#define bfd_elf64_bfd_link_hash_table_create \
				_bfd_mips_elf_link_hash_table_create
#define bfd_elf64_bfd_final_link	_bfd_mips_elf_final_link
#define bfd_elf64_bfd_merge_private_bfd_data \
				_bfd_mips_elf_merge_private_bfd_data
#define bfd_elf64_bfd_set_private_flags	_bfd_mips_elf_set_private_flags
#define bfd_elf64_bfd_print_private_bfd_data \
				_bfd_mips_elf_print_private_bfd_data

#define bfd_elf64_get_reloc_upper_bound mips_elf64_get_reloc_upper_bound
#define bfd_elf64_canonicalize_reloc mips_elf64_canonicalize_reloc
#define bfd_elf64_get_dynamic_reloc_upper_bound mips_elf64_get_dynamic_reloc_upper_bound
#define bfd_elf64_canonicalize_dynamic_reloc mips_elf64_canonicalize_dynamic_reloc
#define bfd_elf64_bfd_relax_section     _bfd_mips_relax_section

/* MIPS ELF64 archive functions.  */
#define bfd_elf64_archive_functions
extern bfd_boolean bfd_elf64_archive_slurp_armap
  (bfd *);
extern bfd_boolean bfd_elf64_archive_write_armap
  (bfd *, unsigned int, struct orl *, unsigned int, int);
#define bfd_elf64_archive_slurp_extended_name_table \
			_bfd_archive_coff_slurp_extended_name_table
#define bfd_elf64_archive_construct_extended_name_table \
			_bfd_archive_coff_construct_extended_name_table
#define bfd_elf64_archive_truncate_arname \
			_bfd_archive_coff_truncate_arname
#define bfd_elf64_archive_read_ar_hdr	_bfd_archive_coff_read_ar_hdr
#define bfd_elf64_archive_openr_next_archived_file \
			_bfd_archive_coff_openr_next_archived_file
#define bfd_elf64_archive_get_elt_at_index \
			_bfd_archive_coff_get_elt_at_index
#define bfd_elf64_archive_generic_stat_arch_elt \
			_bfd_archive_coff_generic_stat_arch_elt
#define bfd_elf64_archive_update_armap_timestamp \
			_bfd_archive_coff_update_armap_timestamp

/* The SGI style (n)64 NewABI.  */
#define TARGET_LITTLE_SYM		bfd_elf64_littlemips_vec
#define TARGET_LITTLE_NAME		"elf64-littlemips"
#define TARGET_BIG_SYM			bfd_elf64_bigmips_vec
#define TARGET_BIG_NAME			"elf64-bigmips"

/* The SVR4 MIPS ABI says that this should be 0x10000, but Irix 5 uses
   a value of 0x1000, and we are compatible.
   FIXME: How does this affect NewABI?  */
#define ELF_MAXPAGESIZE			0x1000

#include "elf64-target.h"

/* The SYSV-style 'traditional' (n)64 NewABI.  */
#undef TARGET_LITTLE_SYM
#undef TARGET_LITTLE_NAME
#undef TARGET_BIG_SYM
#undef TARGET_BIG_NAME

#undef ELF_MAXPAGESIZE

#define TARGET_LITTLE_SYM               bfd_elf64_tradlittlemips_vec
#define TARGET_LITTLE_NAME              "elf64-tradlittlemips"
#define TARGET_BIG_SYM                  bfd_elf64_tradbigmips_vec
#define TARGET_BIG_NAME                 "elf64-tradbigmips"

/* The SVR4 MIPS ABI says that this should be 0x10000, and Linux uses
   page sizes of up to that limit, so we need to respect it.  */
#define ELF_MAXPAGESIZE			0x10000
#define elf64_bed			elf64_tradbed

/* Include the target file again for this target.  */
#include "elf64-target.h"
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d65 1
a65 2
  PARAMS ((bfd *, const Elf64_Mips_External_Rel *,
	   Elf64_Mips_Internal_Rela *));
d67 1
a67 2
  PARAMS ((bfd *, const Elf64_Mips_External_Rela *,
	   Elf64_Mips_Internal_Rela *));
d69 1
a69 2
  PARAMS ((bfd *, const Elf64_Mips_Internal_Rela *,
	   Elf64_Mips_External_Rel *));
d71 1
a71 2
  PARAMS ((bfd *, const Elf64_Mips_Internal_Rela *,
	   Elf64_Mips_External_Rela *));
d73 1
a73 1
  PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
d75 1
a75 1
  PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d77 1
a77 1
  PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
d79 1
a79 1
  PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d81 1
a81 1
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d83 1
a83 1
  PARAMS ((unsigned int, bfd_boolean));
d85 1
a85 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d87 1
a87 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d89 1
a89 1
  PARAMS ((bfd *, asection *));
d91 3
a93 2
  PARAMS ((bfd *, asection *, arelent **, asymbol **));
static long mips_elf64_get_dynamic_reloc_upper_bound PARAMS ((bfd *));
d95 1
a95 1
  PARAMS ((bfd *, arelent **, asymbol **));
d97 2
a98 2
  PARAMS ((bfd *, asection *, Elf_Internal_Shdr *, bfd_size_type,
	   arelent *, asymbol **, bfd_boolean));
d100 1
a100 1
  PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
d102 1
a102 1
  PARAMS ((bfd *, asection *, PTR));
d104 1
a104 1
  PARAMS((bfd *, asection *, Elf_Internal_Shdr *, int *, PTR));
d106 1
a106 3
  PARAMS((bfd *, asection *, Elf_Internal_Shdr *, int *, PTR));
static bfd_reloc_status_type mips_elf64_hi16_reloc
  PARAMS ((bfd *, arelent *, asymbol *,	PTR, asection *, bfd *, char **));
d108 1
a108 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d110 1
a110 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d112 1
a112 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d114 1
a114 3
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type mips_elf64_got16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d116 1
a116 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d118 1
a118 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d120 1
a120 1
  PARAMS ((bfd *, bfd_vma *));
d122 1
a122 1
  PARAMS ((bfd *, asymbol *, bfd_boolean, char **, bfd_vma *));
d124 1
a124 1
  PARAMS ((bfd *));
d126 1
a126 1
  PARAMS ((bfd *));
d128 1
a128 1
  PARAMS ((bfd *, Elf_Internal_Note *));
d130 1
a130 1
  PARAMS ((bfd *, Elf_Internal_Note *));
d154 1
a154 1
	 bfd_elf_generic_reloc,	/* special_function */
d169 1
a169 1
	 bfd_elf_generic_reloc,	/* special_function */
d184 1
a184 1
	 bfd_elf_generic_reloc,	/* special_function */
d199 1
a199 1
	 bfd_elf_generic_reloc,	/* special_function */
d217 1
a217 1
	 bfd_elf_generic_reloc,	/* special_function */
d229 1
a229 1
	 0,			/* rightshift */
d235 1
a235 1
	 mips_elf64_hi16_reloc,	/* special_function */
d250 1
a250 1
	 bfd_elf_generic_reloc,	/* special_function */
d295 1
a295 1
	 mips_elf64_got16_reloc, /* special_function */
d310 1
a310 1
	 bfd_elf_generic_reloc,	/* special_function */
d325 1
a325 1
	 bfd_elf_generic_reloc,	/* special_function */
d359 1
a359 1
	 bfd_elf_generic_reloc,	/* special_function */
d389 1
a389 1
	 bfd_elf_generic_reloc,	/* special_function */
d404 1
a404 1
	 bfd_elf_generic_reloc,	/* special_function */
d419 1
a419 1
	 bfd_elf_generic_reloc,	/* special_function */
d434 1
a434 1
	 bfd_elf_generic_reloc,	/* special_function */
d449 1
a449 1
	 bfd_elf_generic_reloc,	/* special_function */
d464 1
a464 1
	 bfd_elf_generic_reloc,	/* special_function */
d471 1
a471 1
  /* 64 bit substraction.  */
d479 1
a479 1
	 bfd_elf_generic_reloc,	/* special_function */
d495 1
a495 1
	 bfd_elf_generic_reloc,	/* special_function */
d512 1
a512 1
	 bfd_elf_generic_reloc,	/* special_function */
d528 1
a528 1
	 bfd_elf_generic_reloc,	/* special_function */
d552 1
a552 1
	 bfd_elf_generic_reloc,	/* special_function */
d567 1
a567 1
	 bfd_elf_generic_reloc,	/* special_function */
d582 1
a582 1
	 bfd_elf_generic_reloc,	/* special_function */
d596 1
a596 1
	 bfd_elf_generic_reloc,	/* special_function */
d616 1
a616 1
	 bfd_elf_generic_reloc,	/* special_function */
d632 1
a632 1
	 bfd_elf_generic_reloc,	/* special_function */
d652 1
a652 1
	 bfd_elf_generic_reloc,	/* special_function */
d667 1
a667 1
	 bfd_elf_generic_reloc,	/* special_function */
d682 1
a682 1
	 bfd_elf_generic_reloc,	/* special_function */
d697 1
a697 1
	 bfd_elf_generic_reloc,	/* special_function */
d715 1
a715 1
	 bfd_elf_generic_reloc,	/* special_function */
d730 1
a730 1
	 bfd_elf_generic_reloc,	/* special_function */
d745 1
a745 1
	 bfd_elf_generic_reloc,	/* special_function */
d790 1
a790 1
	 mips_elf64_got16_reloc, /* special_function */
d805 1
a805 1
	 bfd_elf_generic_reloc,	/* special_function */
d820 1
a820 1
	 bfd_elf_generic_reloc,	/* special_function */
d854 1
a854 1
	 bfd_elf_generic_reloc,	/* special_function */
d884 1
a884 1
	 bfd_elf_generic_reloc,	/* special_function */
d899 1
a899 1
	 bfd_elf_generic_reloc,	/* special_function */
d914 1
a914 1
	 bfd_elf_generic_reloc,	/* special_function */
d929 1
a929 1
	 bfd_elf_generic_reloc,	/* special_function */
d944 1
a944 1
	 bfd_elf_generic_reloc,	/* special_function */
d959 1
a959 1
	 bfd_elf_generic_reloc,	/* special_function */
d966 1
a966 1
  /* 64 bit substraction.  */
d974 1
a974 1
	 bfd_elf_generic_reloc,	/* special_function */
d990 1
a990 1
	 bfd_elf_generic_reloc,	/* special_function */
d1007 1
a1007 1
	 bfd_elf_generic_reloc,	/* special_function */
d1023 1
a1023 1
	 bfd_elf_generic_reloc,	/* special_function */
d1038 1
a1038 1
	 bfd_elf_generic_reloc, /* special_function */
d1053 1
a1053 1
	 bfd_elf_generic_reloc, /* special_function */
d1068 1
a1068 1
	 bfd_elf_generic_reloc,	/* special_function */
d1083 1
a1083 1
	 bfd_elf_generic_reloc,	/* special_function */
d1098 1
a1098 1
	 bfd_elf_generic_reloc,	/* special_function */
d1112 1
a1112 1
	 bfd_elf_generic_reloc,	/* special_function */
d1132 1
a1132 1
	 bfd_elf_generic_reloc,	/* special_function */
d1148 1
a1148 1
	 bfd_elf_generic_reloc,	/* special_function */
d1223 32
d1258 2
a1259 4
mips_elf64_swap_reloc_in (abfd, src, dst)
     bfd *abfd;
     const Elf64_Mips_External_Rel *src;
     Elf64_Mips_Internal_Rela *dst;
d1273 2
a1274 4
mips_elf64_swap_reloca_in (abfd, src, dst)
     bfd *abfd;
     const Elf64_Mips_External_Rela *src;
     Elf64_Mips_Internal_Rela *dst;
d1288 2
a1289 4
mips_elf64_swap_reloc_out (abfd, src, dst)
     bfd *abfd;
     const Elf64_Mips_Internal_Rela *src;
     Elf64_Mips_External_Rel *dst;
d1302 2
a1303 4
mips_elf64_swap_reloca_out (abfd, src, dst)
     bfd *abfd;
     const Elf64_Mips_Internal_Rela *src;
     Elf64_Mips_External_Rela *dst;
d1317 2
a1318 4
mips_elf64_be_swap_reloc_in (abfd, src, dst)
     bfd *abfd;
     const bfd_byte *src;
     Elf_Internal_Rela *dst;
d1340 2
a1341 4
mips_elf64_be_swap_reloca_in (abfd, src, dst)
     bfd *abfd;
     const bfd_byte *src;
     Elf_Internal_Rela *dst;
d1363 2
a1364 4
mips_elf64_be_swap_reloc_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Rela *src;
     bfd_byte *dst;
d1387 2
a1388 4
mips_elf64_be_swap_reloca_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Rela *src;
     bfd_byte *dst;
a1409 68
/* Do a R_MIPS_HI16 relocation.  */

static bfd_reloc_status_type
mips_elf64_hi16_reloc (abfd, reloc_entry, symbol, data, input_section,
		       output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  /* If we're relocating, and this is an external symbol, we don't
     want to change anything.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (((reloc_entry->addend & 0xffff) + 0x8000) & ~0xffff)
    reloc_entry->addend += 0x8000;

  return bfd_reloc_continue;
}

/* Do a R_MIPS_GOT16 reloc.  This is a reloc against the global offset
   table used for PIC code.  If the symbol is an external symbol, the
   instruction is modified to contain the offset of the appropriate
   entry in the global offset table.  If the symbol is a section
   symbol, the next reloc is a R_MIPS_LO16 reloc.  The two 16 bit
   addends are combined to form the real addend against the section
   symbol; the GOT16 is modified to contain the offset of an entry in
   the global offset table, and the LO16 is modified to offset it
   appropriately.  Thus an offset larger than 16 bits requires a
   modified value in the global offset table.

   This implementation suffices for the assembler, but the linker does
   not yet know how to create global offset tables.  */

static bfd_reloc_status_type
mips_elf64_got16_reloc (abfd, reloc_entry, symbol, data, input_section,
			output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  /* If we're relocating, and this is a local symbol, we can handle it
     just like an R_MIPS_HI16.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) != 0)
    return mips_elf64_hi16_reloc (abfd, reloc_entry, symbol, data,
				  input_section, output_bfd, error_message);


  /* Otherwise we try to handle it as R_MIPS_GOT_DISP.  */
  return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				input_section, output_bfd, error_message);
}

d1414 1
a1414 3
mips_elf64_assign_gp (output_bfd, pgp)
     bfd *output_bfd;
     bfd_vma *pgp;
d1430 1
a1430 1
  if (sym == (asymbol **) NULL)
d1463 1
a1463 1
   external symbol if we are producing relocateable output.  */
d1466 2
a1467 6
mips_elf64_final_gp (output_bfd, symbol, relocateable, error_message, pgp)
     bfd *output_bfd;
     asymbol *symbol;
     bfd_boolean relocateable;
     char **error_message;
     bfd_vma *pgp;
d1470 1
a1470 1
      && ! relocateable)
d1478 1
a1478 1
      && (! relocateable
d1481 1
a1481 1
      if (relocateable)
d1502 3
a1504 9
mips_elf64_gprel16_reloc (abfd, reloc_entry, symbol, data, input_section,
			  output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d1506 1
a1506 1
  bfd_boolean relocateable;
d1510 3
a1512 5
  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
  if (output_bfd != (bfd *) NULL
d1514 1
a1514 2
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
d1520 2
a1521 2
  if (output_bfd != (bfd *) NULL)
    relocateable = TRUE;
d1524 1
a1524 1
      relocateable = FALSE;
d1528 1
a1528 1
  ret = mips_elf64_final_gp (output_bfd, symbol, relocateable, error_message,
d1534 1
a1534 1
					input_section, relocateable,
d1541 3
a1543 9
mips_elf64_literal_reloc (abfd, reloc_entry, symbol, data, input_section,
			  output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d1545 1
a1545 1
  bfd_boolean relocateable;
d1551 1
a1551 1
  if (output_bfd != (bfd *) NULL
d1553 1
a1553 2
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
d1560 2
a1561 2
  if (output_bfd != (bfd *) NULL)
    relocateable = TRUE;
d1564 1
a1564 1
      relocateable = FALSE;
d1568 1
a1568 1
  ret = mips_elf64_final_gp (output_bfd, symbol, relocateable, error_message,
d1574 1
a1574 1
					input_section, relocateable,
d1582 3
a1584 9
mips_elf64_gprel32_reloc (abfd, reloc_entry, symbol, data, input_section,
			  output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d1586 1
a1586 1
  bfd_boolean relocateable;
d1590 1
a1590 1
  unsigned long val;
d1592 3
a1594 5
  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
  if (output_bfd != (bfd *) NULL
d1596 1
a1596 1
      && reloc_entry->addend == 0)
d1603 2
a1604 5
  if (output_bfd != (bfd *) NULL)
    {
      relocateable = TRUE;
      gp = _bfd_get_gp_value (output_bfd);
    }
d1607 1
a1607 1
      relocateable = FALSE;
d1609 1
d1611 4
a1614 5
      ret = mips_elf64_final_gp (output_bfd, symbol, relocateable,
				 error_message, &gp);
      if (ret != bfd_reloc_ok)
	return ret;
    }
d1627 2
a1628 7
  if (reloc_entry->howto->src_mask == 0)
    {
      /* This case arises with the 64-bit MIPS ELF ABI.  */
      val = 0;
    }
  else
    val = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d1630 2
a1631 2
  /* Set val to the offset into the section or symbol.  */
  val += reloc_entry->addend;
d1634 1
a1634 1
     are producing relocateable output, we don't want to do this for
d1636 1
a1636 1
  if (! relocateable
d1640 4
a1643 1
  bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);
d1645 1
a1645 1
  if (relocateable)
d1655 3
a1657 9
mips_elf64_shift6_reloc (abfd, reloc_entry, symbol, data, input_section,
			 output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d1659 1
a1659 6
  /* If we're relocating, and this is an external symbol, we don't
     want to change anything.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
d1661 2
a1662 2
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
d1665 3
a1667 4
  reloc_entry->addend = (reloc_entry->addend & 0x00007c0)
			| (reloc_entry->addend & 0x00000800) >> 9;

  return bfd_reloc_continue;
d1673 4
a1676 9
mips16_jump_reloc (abfd, reloc_entry, symbol, data, input_section,
		   output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d1678 1
a1678 1
  if (output_bfd != (bfd *) NULL
d1704 3
a1706 9
mips16_gprel_reloc (abfd, reloc_entry, symbol, data, input_section,
		    output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d1708 1
a1708 1
  bfd_boolean relocateable;
d1711 4
a1714 2
  unsigned short extend, insn;
  unsigned long final;
d1717 1
a1717 3
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
d1720 1
a1720 1
      && reloc_entry->addend == 0)
d1727 1
a1727 1
    relocateable = TRUE;
d1730 1
a1730 1
      relocateable = FALSE;
d1734 1
a1734 1
  ret = mips_elf64_final_gp (output_bfd, symbol, relocateable, error_message,
d1742 20
a1761 25
  /* Pick up the mips16 extend instruction and the real instruction.  */
  extend = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address);
  insn = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address + 2);

  /* Stuff the current addend back as a 32 bit value, do the usual
     relocation, and then clean up.  */
  bfd_put_32 (abfd,
	      (bfd_vma) (((extend & 0x1f) << 11)
			 | (extend & 0x7e0)
			 | (insn & 0x1f)),
	      (bfd_byte *) data + reloc_entry->address);

  ret = _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
				       input_section, relocateable, data, gp);

  final = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
  bfd_put_16 (abfd,
	      (bfd_vma) ((extend & 0xf800)
			 | ((final >> 11) & 0x1f)
			 | (final & 0x7e0)),
	      (bfd_byte *) data + reloc_entry->address);
  bfd_put_16 (abfd,
	      (bfd_vma) ((insn & 0xffe0)
			 | (final & 0x1f)),
	      (bfd_byte *) data + reloc_entry->address + 2);
d1763 25
a1787 1
  return ret;
d1839 2
a1840 3
bfd_elf64_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d1864 2
d1875 1
a1875 3
mips_elf64_rtype_to_howto (r_type, rela_p)
     unsigned int r_type;
     bfd_boolean rela_p;
d1887 5
d1905 3
a1907 4
mips_elf64_info_to_howto_rel (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *dst ATTRIBUTE_UNUSED;
d1913 3
a1915 4
mips_elf64_info_to_howto_rela (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *dst ATTRIBUTE_UNUSED;
d1924 1
a1924 3
mips_elf64_get_reloc_upper_bound (abfd, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
d1930 1
a1930 2
mips_elf64_get_dynamic_reloc_upper_bound (abfd)
     bfd *abfd;
d1941 2
a1942 5
mips_elf64_canonicalize_reloc (abfd, section, relptr, symbols)
     bfd *abfd;
     sec_ptr section;
     arelent **relptr;
     asymbol **symbols;
d1946 1
a1946 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d1961 2
a1962 4
mips_elf64_canonicalize_dynamic_reloc (abfd, storage, syms)
     bfd *abfd;
     arelent **storage;
     asymbol **syms;
d1964 1
a1964 2
  bfd_boolean (*slurp_relocs)
    PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
d2007 5
a2011 9
mips_elf64_slurp_one_reloc_table (abfd, asect, rel_hdr, reloc_count,
				  relents, symbols, dynamic)
     bfd *abfd;
     asection *asect;
     Elf_Internal_Shdr *rel_hdr;
     bfd_size_type reloc_count;
     arelent *relents;
     asymbol **symbols;
     bfd_boolean dynamic;
d2013 1
a2013 1
  PTR allocated = NULL;
d2018 1
a2018 1
  reloc_howto_type *howto_table;
d2020 1
a2020 1
  allocated = (PTR) bfd_malloc (rel_hdr->sh_size);
d2029 1
a2029 1
  native_relocs = (bfd_byte *) allocated;
d2036 1
a2036 1
    howto_table = mips_elf64_howto_table_rel;
d2038 1
a2038 1
    howto_table = mips_elf64_howto_table_rela;
d2151 1
a2151 1
	  relent->howto = &howto_table[(int) type];
d2177 2
a2178 5
mips_elf64_slurp_reloc_table (abfd, asect, symbols, dynamic)
     bfd *abfd;
     asection *asect;
     asymbol **symbols;
     bfd_boolean dynamic;
d2224 1
a2224 1
  relents = (arelent *) bfd_alloc (abfd, amt);
d2252 1
a2252 4
mips_elf64_write_relocs (abfd, sec, data)
     bfd *abfd;
     asection *sec;
     PTR data;
d2254 1
a2254 1
  bfd_boolean *failedp = (bfd_boolean *) data;
d2315 3
a2317 6
mips_elf64_write_rel (abfd, sec, rel_hdr, count, data)
     bfd *abfd;
     asection *sec;
     Elf_Internal_Shdr *rel_hdr;
     int *count;
     PTR data;
d2319 1
a2319 1
  bfd_boolean *failedp = (bfd_boolean *) data;
d2325 2
a2326 2
  rel_hdr->sh_size = (bfd_vma)(rel_hdr->sh_entsize * *count);
  rel_hdr->contents = (PTR) bfd_alloc (abfd, rel_hdr->sh_size);
d2411 3
a2413 6
mips_elf64_write_rela (abfd, sec, rela_hdr, count, data)
     bfd *abfd;
     asection *sec;
     Elf_Internal_Shdr *rela_hdr;
     int *count;
     PTR data;
d2415 1
a2415 1
  bfd_boolean *failedp = (bfd_boolean *) data;
d2421 2
a2422 2
  rela_hdr->sh_size = (bfd_vma)(rela_hdr->sh_entsize * *count);
  rela_hdr->contents = (PTR) bfd_alloc (abfd, rela_hdr->sh_size);
d2510 1
a2510 2
mips_elf64_object_p (abfd)
     bfd *abfd;
d2528 1
a2528 2
elf64_mips_irix_compat (abfd)
     bfd *abfd;
d2539 1
a2539 3
elf64_mips_grok_prstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d2569 1
a2569 3
elf64_mips_grok_psinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d2658 1
a2658 1
  8,		/* file_align */
a2678 5
/* The SVR4 MIPS ABI says that this should be 0x10000, but Irix 5 uses
   a value of 0x1000, and we are compatible.
   FIXME: How does this affect NewABI?  */
#define ELF_MAXPAGESIZE			0x1000

d2715 2
a2728 1
#define elf_backend_plt_header_size	0
d2764 1
a2764 1
  PARAMS ((bfd *));
d2766 1
a2766 1
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
d2789 5
a2795 2
#define INCLUDED_TARGET_FILE            /* More a type of flag.  */

d2802 2
d2808 5
@


1.5
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
d28 1
a28 1
   writing the relocations here.
d30 12
a41 1
   The MIPS 64-bit ELF ABI also uses an unusual archive map format.  */
d50 1
d66 1
a66 1
	   Elf64_Mips_Internal_Rel *));
d71 1
a71 1
  PARAMS ((bfd *, const Elf64_Mips_Internal_Rel *,
d77 1
a77 1
  PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rel *));
d79 1
a79 1
  PARAMS ((bfd *, const Elf_Internal_Rel *, bfd_byte *));
d84 1
a84 1
static reloc_howto_type *mips_elf64_reloc_type_lookup
d86 55
a140 9
static long mips_elf64_get_reloc_upper_bound PARAMS ((bfd *, asection *));
static boolean mips_elf64_slurp_one_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, const Elf_Internal_Shdr *));
static boolean mips_elf64_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, boolean));
static void mips_elf64_write_relocs PARAMS ((bfd *, asection *, PTR));
static boolean mips_elf64_slurp_armap PARAMS ((bfd *));
static boolean mips_elf64_write_armap
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
d148 1
a148 1

d158 1
a158 1
	 false,			/* pc_relative */
d163 1
a163 1
	 false,			/* partial_inplace */
d166 1
a166 1
	 false),		/* pcrel_offset */
d171 1
a171 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d173 1
a173 1
	 false,			/* pc_relative */
d175 1
a175 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d178 4
a181 4
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d188 1
a188 1
	 false,			/* pc_relative */
d190 1
a190 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d193 1
a193 1
	 true,			/* partial_inplace */
d196 1
a196 1
	 false),		/* pcrel_offset */
d203 1
a203 1
	 false,			/* pc_relative */
d205 1
a205 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d208 1
a208 1
	 true,			/* partial_inplace */
d211 1
a211 1
	 false),		/* pcrel_offset */
d213 1
a213 1
  /* 26 bit branch address.  */
d218 1
a218 1
	 false,			/* pc_relative */
d222 1
a222 1
				   detection, because the upper four
d226 7
a232 4
	 true,			/* partial_inplace */
	 0x3ffffff,		/* src_mask */
	 0x3ffffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d239 1
a239 1
	 false,			/* pc_relative */
d242 1
a242 1
	 _bfd_mips_elf_hi16_reloc,	/* special_function */
d244 4
a247 4
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d254 1
a254 1
	 false,			/* pc_relative */
d257 1
a257 1
	 _bfd_mips_elf_lo16_reloc,	/* special_function */
d259 4
a262 4
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d269 1
a269 1
	 false,			/* pc_relative */
d272 1
a272 1
	 _bfd_mips_elf_gprel16_reloc, /* special_function */
d274 4
a277 4
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d284 1
a284 1
	 false,			/* pc_relative */
d287 1
a287 1
	 _bfd_mips_elf_gprel16_reloc, /* special_function */
d289 4
a292 4
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d299 1
a299 1
	 false,			/* pc_relative */
d302 1
a302 1
	 _bfd_mips_elf_got16_reloc,	/* special_function */
d304 4
a307 4
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d314 1
a314 1
	 true,			/* pc_relative */
d319 4
a322 4
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
a324 1
  /* FIXME: This is not handled correctly.  */
d329 1
a329 1
	 false,			/* pc_relative */
d334 4
a337 4
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d344 1
a344 1
	 false,			/* pc_relative */
d346 2
a347 2
	 complain_overflow_bitfield, /* complain_on_overflow */
	 _bfd_mips_elf_gprel32_reloc, /* special_function */
d349 1
a349 1
	 true,			/* partial_inplace */
d352 1
a352 1
	 false),		/* pcrel_offset */
d354 3
a356 3
    { 13 },
    { 14 },
    { 15 },
d363 1
a363 1
	 false,			/* pc_relative */
d368 1
a368 1
	 true,			/* partial_inplace */
d371 1
a371 1
	 false),		/* pcrel_offset */
a373 2
  /* FIXME: This is not handled correctly; a special function is
     needed to put the most significant bit in the right place.  */
d378 1
a378 1
	 false,			/* pc_relative */
d381 1
a381 1
	 bfd_elf_generic_reloc,	/* special_function */
d383 1
a383 1
	 true,			/* partial_inplace */
d386 1
a386 1
	 false),		/* pcrel_offset */
d393 1
a393 1
	 false,			/* pc_relative */
d395 1
a395 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d398 1
a398 1
	 true,			/* partial_inplace */
d401 1
a401 1
	 false),		/* pcrel_offset */
a403 1
  /* FIXME: Not handled correctly.  */
d408 1
a408 1
	 false,			/* pc_relative */
d410 1
a410 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d413 1
a413 1
	 true,			/* partial_inplace */
d416 1
a416 1
	 false),		/* pcrel_offset */
a418 1
  /* FIXME: Not handled correctly.  */
d423 1
a423 1
	 false,			/* pc_relative */
d425 1
a425 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d428 1
a428 1
	 true,			/* partial_inplace */
d431 1
a431 1
	 false),		/* pcrel_offset */
a433 1
  /* FIXME: Not handled correctly.  */
d438 1
a438 1
	 false,			/* pc_relative */
d440 1
a440 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d443 1
a443 1
	 true,			/* partial_inplace */
d446 1
a446 1
	 false),		/* pcrel_offset */
a448 1
  /* FIXME: Not handled correctly.  */
d453 1
a453 1
	 false,			/* pc_relative */
d458 1
a458 1
	 true,			/* partial_inplace */
d461 1
a461 1
	 false),		/* pcrel_offset */
a463 1
  /* FIXME: Not handled correctly.  */
d468 1
a468 1
	 false,			/* pc_relative */
d473 1
a473 1
	 true,			/* partial_inplace */
d476 1
a476 1
	 false),		/* pcrel_offset */
a478 1
  /* FIXME: Not handled correctly.  */
d483 1
a483 1
	 false,			/* pc_relative */
d485 1
a485 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d488 1
a488 1
	 true,			/* partial_inplace */
d491 1
a491 1
	 false),		/* pcrel_offset */
d497 3
a499 3
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
d504 4
a507 4
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d514 3
a516 3
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
d521 4
a524 4
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d530 3
a532 3
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
d537 4
a540 4
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d542 8
a549 31
  /* Get the higher value of a 64 bit addend.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_HIGHER,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_HIGHER",	/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Get the highest value of a 64 bit addend.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_HIGHEST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_HIGHEST",	/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
a551 1
  /* FIXME: Not handled correctly.  */
d556 1
a556 1
	 false,			/* pc_relative */
d561 1
a561 1
	 true,			/* partial_inplace */
d564 1
a564 1
	 false),		/* pcrel_offset */
a566 1
  /* FIXME: Not handled correctly.  */
d571 1
a571 1
	 false,			/* pc_relative */
d576 1
a576 1
	 true,			/* partial_inplace */
d579 1
a579 4
	 false),		/* pcrel_offset */

  /* I'm not sure what the remaining relocs are, but they are defined
     on Irix 6.  */
d581 1
d584 3
a586 3
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
d591 4
a594 4
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d598 3
a600 3
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
d602 1
a602 1
	 complain_overflow_dont, /* complain_on_overflow */
d605 4
a608 18
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_MIPS_ADD_IMMEDIATE,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_ADD_IMMEDIATE", /* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d610 3
a612 13
  HOWTO (R_MIPS_PJUMP,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_PJUMP",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d614 2
d618 3
a620 3
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
d625 4
a628 4
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d634 3
a636 3
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
d641 2
a642 2
	 false,			/* partial_inplace */
	 0x00000000,		/* src_mask */
d644 1
a644 1
	 false),		/* pcrel_offset */
d656 1
a656 1
	 false,			/* pc_relative */
d661 1
a661 1
	 false,			/* partial_inplace */
d664 1
a664 1
	 false),		/* pcrel_offset */
d669 1
a669 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d671 1
a671 1
	 false,			/* pc_relative */
d673 1
a673 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d676 1
a676 1
	 true,			/* partial_inplace */
d678 2
a679 2
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d686 1
a686 1
	 false,			/* pc_relative */
d688 1
a688 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d691 1
a691 1
	 true,			/* partial_inplace */
d694 1
a694 1
	 false),		/* pcrel_offset */
d701 1
a701 1
	 false,			/* pc_relative */
d703 1
a703 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d706 1
a706 1
	 true,			/* partial_inplace */
d709 1
a709 1
	 false),		/* pcrel_offset */
d711 1
a711 1
  /* 26 bit branch address.  */
d716 1
a716 1
	 false,			/* pc_relative */
d720 1
a720 1
				   detection, because the upper four
d724 1
a724 1
	 true,			/* partial_inplace */
d726 2
a727 2
	 0x3ffffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d734 1
a734 1
	 false,			/* pc_relative */
d739 1
a739 1
	 true,			/* partial_inplace */
d741 2
a742 2
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d749 1
a749 1
	 false,			/* pc_relative */
d754 1
a754 1
	 true,			/* partial_inplace */
d756 2
a757 2
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d764 1
a764 1
	 false,			/* pc_relative */
d767 1
a767 1
	 _bfd_mips_elf_gprel16_reloc, /* special_function */
d769 1
a769 1
	 true,			/* partial_inplace */
d771 2
a772 2
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d779 1
a779 1
	 false,			/* pc_relative */
d782 1
a782 1
	 _bfd_mips_elf_gprel16_reloc, /* special_function */
d784 1
a784 1
	 true,			/* partial_inplace */
d786 2
a787 2
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
a789 1
  /* FIXME: This is not handled correctly.  */
d794 1
a794 1
	 false,			/* pc_relative */
d797 1
a797 1
	 bfd_elf_generic_reloc,	/* special_function */
d799 1
a799 1
	 false,			/* partial_inplace */
d801 2
a802 2
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d809 1
a809 1
	 true,			/* pc_relative */
d814 1
a814 1
	 true,			/* partial_inplace */
d816 2
a817 2
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
a819 1
  /* FIXME: This is not handled correctly.  */
d824 1
a824 1
	 false,			/* pc_relative */
d829 1
a829 1
	 false,			/* partial_inplace */
d831 2
a832 2
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d839 1
a839 1
	 false,			/* pc_relative */
d841 2
a842 2
	 complain_overflow_bitfield, /* complain_on_overflow */
	 _bfd_mips_elf_gprel32_reloc, /* special_function */
d844 1
a844 1
	 true,			/* partial_inplace */
d847 1
a847 1
	 false),		/* pcrel_offset */
d849 3
a851 3
    { 13 },
    { 14 },
    { 15 },
d858 1
a858 1
	 false,			/* pc_relative */
d863 1
a863 1
	 true,			/* partial_inplace */
d866 1
a866 1
	 false),		/* pcrel_offset */
a868 2
  /* FIXME: This is not handled correctly; a special function is
     needed to put the most significant bit in the right place.  */
d873 1
a873 1
	 false,			/* pc_relative */
d876 1
a876 1
	 bfd_elf_generic_reloc,	/* special_function */
d878 1
a878 1
	 true,			/* partial_inplace */
d881 1
a881 1
	 false),		/* pcrel_offset */
d888 1
a888 1
	 false,			/* pc_relative */
d890 1
a890 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d893 1
a893 1
	 true,			/* partial_inplace */
d896 1
a896 1
	 false),		/* pcrel_offset */
a898 1
  /* FIXME: Not handled correctly.  */
d903 1
a903 1
	 false,			/* pc_relative */
d905 1
a905 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d908 1
a908 1
	 true,			/* partial_inplace */
d911 1
a911 1
	 false),		/* pcrel_offset */
a913 1
  /* FIXME: Not handled correctly.  */
d918 1
a918 1
	 false,			/* pc_relative */
d920 1
a920 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d923 1
a923 1
	 true,			/* partial_inplace */
d926 1
a926 1
	 false),		/* pcrel_offset */
a928 1
  /* FIXME: Not handled correctly.  */
d933 1
a933 1
	 false,			/* pc_relative */
d935 1
a935 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d938 1
a938 1
	 true,			/* partial_inplace */
d941 1
a941 1
	 false),		/* pcrel_offset */
a943 1
  /* FIXME: Not handled correctly.  */
d948 1
a948 1
	 false,			/* pc_relative */
d953 1
a953 1
	 true,			/* partial_inplace */
d956 1
a956 1
	 false),		/* pcrel_offset */
a958 1
  /* FIXME: Not handled correctly.  */
d963 1
a963 1
	 false,			/* pc_relative */
d968 1
a968 1
	 true,			/* partial_inplace */
d971 1
a971 1
	 false),		/* pcrel_offset */
a973 1
  /* FIXME: Not handled correctly.  */
d978 1
a978 1
	 false,			/* pc_relative */
d980 1
a980 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d983 1
a983 1
	 true,			/* partial_inplace */
d986 1
a986 1
	 false),		/* pcrel_offset */
d992 3
a994 3
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
d999 1
a999 1
	 false,			/* partial_inplace */
d1001 2
a1002 2
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d1009 3
a1011 3
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
d1016 1
a1016 1
	 false,			/* partial_inplace */
d1018 2
a1019 2
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d1025 3
a1027 3
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
d1032 1
a1032 1
	 false,			/* partial_inplace */
d1034 2
a1035 2
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
a1037 1
  /* FIXME: Not handled correctly.  */
d1042 1
a1042 1
	 false,			/* pc_relative */
d1045 1
a1045 1
	 bfd_elf_generic_reloc,	/* special_function */
d1047 1
a1047 1
	 true,			/* partial_inplace */
d1049 2
a1050 2
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
a1052 1
  /* FIXME: Not handled correctly.  */
d1057 1
a1057 1
	 false,			/* pc_relative */
d1060 1
a1060 1
	 bfd_elf_generic_reloc,	/* special_function */
d1062 1
a1062 1
	 true,			/* partial_inplace */
d1064 2
a1065 2
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
a1067 1
  /* FIXME: Not handled correctly.  */
d1072 1
a1072 1
	 false,			/* pc_relative */
d1077 1
a1077 1
	 true,			/* partial_inplace */
d1080 1
a1080 1
	 false),		/* pcrel_offset */
a1082 1
  /* FIXME: Not handled correctly.  */
d1087 1
a1087 1
	 false,			/* pc_relative */
d1092 1
a1092 1
	 true,			/* partial_inplace */
d1095 1
a1095 4
	 false),		/* pcrel_offset */

  /* I'm not sure what the remaining relocs are, but they are defined
     on Irix 6.  */
d1097 1
d1100 3
a1102 3
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
d1107 1
a1107 1
	 false,			/* partial_inplace */
d1109 2
a1110 2
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d1114 5
a1118 5
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
d1121 1
a1121 1
	 false,			/* partial_inplace */
d1123 6
a1128 2
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d1130 3
a1132 1
  HOWTO (R_MIPS_ADD_IMMEDIATE,	/* type */
d1134 3
a1136 3
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
d1140 2
a1141 2
	 "R_MIPS_ADD_IMMEDIATE", /* name */
	 false,			/* partial_inplace */
d1143 2
a1144 2
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d1146 3
a1148 1
  HOWTO (R_MIPS_PJUMP,		/* type */
d1150 3
a1152 3
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
d1156 2
a1157 2
	 "R_MIPS_PJUMP",	/* name */
	 false,			/* partial_inplace */
d1159 22
a1180 2
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d1182 19
a1200 1
  HOWTO (R_MIPS_RELGOT,		/* type */
d1202 1
a1202 1
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
d1204 1
a1204 1
	 false,			/* pc_relative */
d1207 3
a1209 3
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_RELGOT",	/* name */
	 false,			/* partial_inplace */
d1212 1
a1212 1
	 false),		/* pcrel_offset */
d1214 3
a1216 3
  /* Protected jump conversion.  This is an optimization hint.  No
     relocation is required for correctness.  */
  HOWTO (R_MIPS_JALR,	        /* type */
d1218 1
a1218 1
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
d1220 1
a1220 1
	 false,			/* pc_relative */
d1223 7
a1229 8
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_JALR",	        /* name */
	 false,			/* partial_inplace */
	 0x00000000,		/* src_mask */
	 0x00000000,		/* dst_mask */
	 false),		/* pcrel_offset */
};

d1236 1
a1236 1
     Elf64_Mips_Internal_Rel *dst;
d1238 7
a1244 6
  dst->r_offset = bfd_h_get_64 (abfd, (bfd_byte *) src->r_offset);
  dst->r_sym = bfd_h_get_32 (abfd, (bfd_byte *) src->r_sym);
  dst->r_ssym = bfd_h_get_8 (abfd, (bfd_byte *) src->r_ssym);
  dst->r_type3 = bfd_h_get_8 (abfd, (bfd_byte *) src->r_type3);
  dst->r_type2 = bfd_h_get_8 (abfd, (bfd_byte *) src->r_type2);
  dst->r_type = bfd_h_get_8 (abfd, (bfd_byte *) src->r_type);
d1255 7
a1261 7
  dst->r_offset = bfd_h_get_64 (abfd, (bfd_byte *) src->r_offset);
  dst->r_sym = bfd_h_get_32 (abfd, (bfd_byte *) src->r_sym);
  dst->r_ssym = bfd_h_get_8 (abfd, (bfd_byte *) src->r_ssym);
  dst->r_type3 = bfd_h_get_8 (abfd, (bfd_byte *) src->r_type3);
  dst->r_type2 = bfd_h_get_8 (abfd, (bfd_byte *) src->r_type2);
  dst->r_type = bfd_h_get_8 (abfd, (bfd_byte *) src->r_type);
  dst->r_addend = bfd_h_get_signed_64 (abfd, (bfd_byte *) src->r_addend);
d1269 1
a1269 1
     const Elf64_Mips_Internal_Rel *src;
d1272 6
a1277 6
  bfd_h_put_64 (abfd, src->r_offset, (bfd_byte *) dst->r_offset);
  bfd_h_put_32 (abfd, src->r_sym, (bfd_byte *) dst->r_sym);
  bfd_h_put_8 (abfd, src->r_ssym, (bfd_byte *) dst->r_ssym);
  bfd_h_put_8 (abfd, src->r_type3, (bfd_byte *) dst->r_type3);
  bfd_h_put_8 (abfd, src->r_type2, (bfd_byte *) dst->r_type2);
  bfd_h_put_8 (abfd, src->r_type, (bfd_byte *) dst->r_type);
d1288 7
a1294 7
  bfd_h_put_64 (abfd, src->r_offset, (bfd_byte *) dst->r_offset);
  bfd_h_put_32 (abfd, src->r_sym, (bfd_byte *) dst->r_sym);
  bfd_h_put_8 (abfd, src->r_ssym, (bfd_byte *) dst->r_ssym);
  bfd_h_put_8 (abfd, src->r_type3, (bfd_byte *) dst->r_type3);
  bfd_h_put_8 (abfd, src->r_type2, (bfd_byte *) dst->r_type2);
  bfd_h_put_8 (abfd, src->r_type, (bfd_byte *) dst->r_type);
  bfd_h_put_64 (abfd, src->r_addend, (bfd_byte *) dst->r_addend);
d1303 1
a1303 1
     Elf_Internal_Rel *dst;
d1305 1
a1305 1
  Elf64_Mips_Internal_Rel mirel;
d1312 2
a1313 1
  dst[0].r_info = ELF32_R_INFO (mirel.r_sym, mirel.r_type);
d1315 2
a1316 1
  dst[1].r_info = ELF32_R_INFO (mirel.r_ssym, mirel.r_type2);
d1318 2
a1319 1
  dst[2].r_info = ELF32_R_INFO (STN_UNDEF, mirel.r_type3);
d1337 1
a1337 1
  dst[0].r_info = ELF32_R_INFO (mirela.r_sym, mirela.r_type);
d1340 1
a1340 1
  dst[1].r_info = ELF32_R_INFO (mirela.r_ssym, mirela.r_type2);
d1343 1
a1343 1
  dst[2].r_info = ELF32_R_INFO (STN_UNDEF, mirela.r_type3);
d1352 1
a1352 1
     const Elf_Internal_Rel *src;
d1355 1
a1355 1
  Elf64_Mips_Internal_Rel mirel;
d1357 11
a1367 6
  mirel.r_offset = src->r_offset;
  mirel.r_type = ELF32_R_TYPE (src->r_info);
  mirel.r_sym = ELF32_R_SYM (src->r_info);
  mirel.r_type2 = R_MIPS_NONE;
  mirel.r_ssym = STN_UNDEF;
  mirel.r_type3 = R_MIPS_NONE;
d1383 13
a1395 7
  mirela.r_offset = src->r_offset;
  mirela.r_type = ELF32_R_TYPE (src->r_info);
  mirela.r_addend = src->r_addend;
  mirela.r_sym = ELF32_R_SYM (src->r_info);
  mirela.r_type2 = R_MIPS_NONE;
  mirela.r_ssym = STN_UNDEF;
  mirela.r_type3 = R_MIPS_NONE;
d1400 291
d1692 196
d1890 3
a1892 4
struct elf_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_val;
  enum elf_mips_reloc_type elf_reloc_val;
d1895 1
a1895 1
static CONST struct elf_reloc_map mips_reloc_map[] =
d1897 1
a1897 1
  { BFD_RELOC_NONE, R_MIPS_NONE, },
d1900 1
d1903 1
a1903 2
  { BFD_RELOC_32_PCREL, R_MIPS_REL32 },
  { BFD_RELOC_MIPS_JMP, R_MIPS_26 },
d1906 3
a1908 1
  { BFD_RELOC_MIPS_GPREL, R_MIPS_GPREL16 },
a1910 1
  { BFD_RELOC_16_PCREL, R_MIPS_PC16 },
d1912 5
a1916 1
  { BFD_RELOC_MIPS_GPREL32, R_MIPS_GPREL32 },
d1919 6
d1927 5
a1931 4
  { BFD_RELOC_MIPS_SUB, R_MIPS_SUB },
  { BFD_RELOC_MIPS_GOT_PAGE, R_MIPS_GOT_PAGE },
  { BFD_RELOC_MIPS_GOT_OFST, R_MIPS_GOT_OFST },
  { BFD_RELOC_MIPS_GOT_DISP, R_MIPS_GOT_DISP }
d1937 1
a1937 1
mips_elf64_reloc_type_lookup (abfd, code)
d1942 10
d1953 1
a1953 1
  for (i = 0; i < sizeof (mips_reloc_map) / sizeof (struct elf_reloc_map); i++)
d1955 15
a1969 3
      if (mips_reloc_map[i].bfd_reloc_val == code)
	{
	  int v;
d1971 22
a1992 3
	  v = (int) mips_reloc_map[i].elf_reloc_val;
	  return &mips_elf64_howto_table_rel[v];
	}
d1994 12
d2007 7
a2013 1
  return NULL;
d2027 11
a2037 1
/* Read the relocations from one reloc section.  */
d2039 75
a2113 2
static boolean
mips_elf64_slurp_one_reloc_table (abfd, asect, symbols, rel_hdr)
d2116 3
d2120 1
a2120 1
     const Elf_Internal_Shdr *rel_hdr;
a2123 1
  arelent *relents;
d2125 1
a2125 2
  unsigned int count;
  unsigned int i;
d2131 1
a2131 1
    goto error_return;
d2134 2
a2135 1
      || (bfd_read (allocated, 1, rel_hdr->sh_size, abfd) != rel_hdr->sh_size))
a2139 2
  relents = asect->relocation + asect->reloc_count;

a2143 2
  count = rel_hdr->sh_size / entsize;

d2149 3
a2151 2
  relent = relents;
  for (i = 0; i < count; i++, native_relocs += entsize)
d2154 1
a2154 1
      boolean used_sym, used_ssym;
d2162 3
a2164 2
	{
	  Elf64_Mips_Internal_Rel rel;
d2166 1
a2166 11
	  mips_elf64_swap_reloc_in (abfd,
				    (Elf64_Mips_External_Rel *) native_relocs,
				    &rel);
	  rela.r_offset = rel.r_offset;
	  rela.r_sym = rel.r_sym;
	  rela.r_ssym = rel.r_ssym;
	  rela.r_type3 = rel.r_type3;
	  rela.r_type2 = rel.r_type2;
	  rela.r_type = rel.r_type;
	  rela.r_addend = 0;
	}
d2168 2
a2169 4
      /* Each entry represents up to three actual relocations.  */

      used_sym = false;
      used_ssym = false;
a2188 21
	  if (type == R_MIPS_NONE)
	    {
	      /* There are no more relocations in this entry.  If this
                 is the first entry, we need to generate a dummy
                 relocation so that the generic linker knows that
                 there has been a break in the sequence of relocations
                 applying to a particular address.  */
	      if (ir == 0)
		{
		  relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
		  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
		    relent->address = rela.r_offset;
		  else
		    relent->address = rela.r_offset - asect->vma;
		  relent->addend = 0;
		  relent->howto = &howto_table[(int) R_MIPS_NONE];
		  ++relent;
		}
	      break;
	    }

d2217 1
a2217 1
		  used_sym = true;
d2241 1
a2241 1
		  used_ssym = true;
d2253 1
a2253 1
	  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
d2266 1
a2266 1
  asect->reloc_count += relent - relents;
d2271 1
a2271 1
  return true;
d2276 1
a2276 1
  return false;
d2280 4
a2283 1
   associated with a single data section.  */
d2285 1
a2285 1
static boolean
d2290 1
a2290 1
     boolean dynamic;
d2293 9
d2303 1
a2303 1
  if (dynamic)
d2305 27
a2331 2
      bfd_set_error (bfd_error_invalid_operation);
      return false;
a2333 5
  if (asect->relocation != NULL
      || (asect->flags & SEC_RELOC) == 0
      || asect->reloc_count == 0)
    return true;

d2335 4
a2338 5
  asect->relocation = ((arelent *)
		       bfd_alloc (abfd,
				  asect->reloc_count * 3 * sizeof (arelent)));
  if (asect->relocation == NULL)
    return false;
d2343 5
a2347 2
  if (! mips_elf64_slurp_one_reloc_table (abfd, asect, symbols, &d->rel_hdr))
    return false;
d2350 5
a2354 3
      if (! mips_elf64_slurp_one_reloc_table (abfd, asect, symbols,
					      d->rel_hdr2))
	return false;
d2357 2
a2358 1
  return true;
d2369 3
a2371 4
  boolean *failedp = (boolean *) data;
  unsigned int count;
  Elf_Internal_Shdr *rela_hdr;
  Elf64_Mips_External_Rela *ext_rela;
a2372 2
  asymbol *last_sym = 0;
  int last_sym_idx = 0;
d2417 81
a2497 1
  rela_hdr = &elf_section_data (sec)->rel_hdr;
d2499 44
a2542 1
  rela_hdr->sh_size = rela_hdr->sh_entsize * count;
d2546 1
a2546 1
      *failedp = true;
d2578 1
a2578 1
	      *failedp = true;
a2584 1

a2585 1

d2591 1
a2591 1
	  *failedp = true;
d2625 1
a2625 1
	      == count);
d2628 1
a2628 4
/* Irix 6 defines a brand new archive map format, so that they can
   have archives more than 4 GB in size.  */

/* Read an Irix 6 armap.  */
d2630 2
a2631 2
static boolean
mips_elf64_slurp_armap (abfd)
d2634 1
a2634 9
  struct artdata *ardata = bfd_ardata (abfd);
  char nextname[17];
  file_ptr arhdrpos;
  bfd_size_type i, parsed_size, nsymz, stringsize, carsym_size, ptrsize;
  struct areltdata *mapdata;
  bfd_byte int_buf[8];
  char *stringbase;
  bfd_byte *raw_armap = NULL;
  carsym *carsyms;
d2636 10
a2645 1
  ardata->symdefs = NULL;
d2647 21
a2667 26
  /* Get the name of the first element.  */
  arhdrpos = bfd_tell (abfd);
  i = bfd_read ((PTR) nextname, 1, 16, abfd);
  if (i == 0)
    return true;
  if (i != 16)
    return false;

  if (bfd_seek (abfd, (file_ptr) - 16, SEEK_CUR) != 0)
    return false;

  /* Archives with traditional armaps are still permitted.  */
  if (strncmp (nextname, "/               ", 16) == 0)
    return bfd_slurp_armap (abfd);

  if (strncmp (nextname, "/SYM64/         ", 16) != 0)
    {
      bfd_has_map (abfd) = false;
      return true;
    }

  mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
  if (mapdata == NULL)
    return false;
  parsed_size = mapdata->parsed_size;
  bfd_release (abfd, (PTR) mapdata);
d2669 1
a2669 1
  if (bfd_read (int_buf, 1, 8, abfd) != 8)
d2671 2
a2672 4
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_malformed_archive);
      return false;
    }
d2674 3
a2676 2
  nsymz = bfd_getb64 (int_buf);
  stringsize = parsed_size - 8 * nsymz - 8;
d2678 2
a2679 2
  carsym_size = nsymz * sizeof (carsym);
  ptrsize = 8 * nsymz;
d2681 3
a2683 5
  ardata->symdefs = (carsym *) bfd_zalloc (abfd, carsym_size + stringsize + 1);
  if (ardata->symdefs == NULL)
    return false;
  carsyms = ardata->symdefs;
  stringbase = ((char *) ardata->symdefs) + carsym_size;
d2685 1
a2685 10
  raw_armap = (bfd_byte *) bfd_alloc (abfd, ptrsize);
  if (raw_armap == NULL)
    goto error_return;

  if (bfd_read (raw_armap, 1, ptrsize, abfd) != ptrsize
      || bfd_read (stringbase, 1, stringsize, abfd) != stringsize)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_malformed_archive);
      goto error_return;
d2688 4
a2691 8
  for (i = 0; i < nsymz; i++)
    {
      carsyms->file_offset = bfd_getb64 (raw_armap + i * 8);
      carsyms->name = stringbase;
      stringbase += strlen (stringbase) + 1;
      ++carsyms;
    }
  *stringbase = '\0';
d2693 6
a2698 102
  ardata->symdef_count = nsymz;
  ardata->first_file_filepos = arhdrpos + sizeof (struct ar_hdr) + parsed_size;

  bfd_has_map (abfd) = true;
  bfd_release (abfd, raw_armap);

  return true;

 error_return:
  if (raw_armap != NULL)
    bfd_release (abfd, raw_armap);
  if (ardata->symdefs != NULL)
    bfd_release (abfd, ardata->symdefs);
  return false;
}

/* Write out an Irix 6 armap.  The Irix 6 tools are supposed to be
   able to handle ordinary ELF armaps, but at least on Irix 6.2 the
   linker crashes.  */

static boolean
mips_elf64_write_armap (arch, elength, map, symbol_count, stridx)
     bfd *arch;
     unsigned int elength;
     struct orl *map;
     unsigned int symbol_count;
     int stridx;
{
  unsigned int ranlibsize = (symbol_count * 8) + 8;
  unsigned int stringsize = stridx;
  unsigned int mapsize = stringsize + ranlibsize;
  file_ptr archive_member_file_ptr;
  bfd *current = arch->archive_head;
  unsigned int count;
  struct ar_hdr hdr;
  unsigned int i;
  int padding;
  bfd_byte buf[8];

  padding = BFD_ALIGN (mapsize, 8) - mapsize;
  mapsize += padding;

  /* work out where the first object file will go in the archive */
  archive_member_file_ptr = (mapsize
			     + elength
			     + sizeof (struct ar_hdr)
			     + SARMAG);

  memset ((char *) (&hdr), 0, sizeof (struct ar_hdr));
  strcpy (hdr.ar_name, "/SYM64/");
  sprintf (hdr.ar_size, "%-10d", (int) mapsize);
  sprintf (hdr.ar_date, "%ld", (long) time (NULL));
  /* This, at least, is what Intel coff sets the values to.: */
  sprintf ((hdr.ar_uid), "%d", 0);
  sprintf ((hdr.ar_gid), "%d", 0);
  sprintf ((hdr.ar_mode), "%-7o", (unsigned) 0);
  strncpy (hdr.ar_fmag, ARFMAG, 2);

  for (i = 0; i < sizeof (struct ar_hdr); i++)
    if (((char *) (&hdr))[i] == '\0')
      (((char *) (&hdr))[i]) = ' ';

  /* Write the ar header for this item and the number of symbols */

  if (bfd_write ((PTR) &hdr, 1, sizeof (struct ar_hdr), arch)
      != sizeof (struct ar_hdr))
    return false;

  bfd_putb64 (symbol_count, buf);
  if (bfd_write (buf, 1, 8, arch) != 8)
    return false;

  /* Two passes, first write the file offsets for each symbol -
     remembering that each offset is on a two byte boundary.  */

  /* Write out the file offset for the file associated with each
     symbol, and remember to keep the offsets padded out.  */

  current = arch->archive_head;
  count = 0;
  while (current != (bfd *) NULL && count < symbol_count)
    {
      /* For each symbol which is used defined in this object, write out
	 the object file's address in the archive */

      while (((bfd *) (map[count]).pos) == current)
	{
	  bfd_putb64 (archive_member_file_ptr, buf);
	  if (bfd_write (buf, 1, 8, arch) != 8)
	    return false;
	  count++;
	}
      /* Add size of this archive entry */
      archive_member_file_ptr += (arelt_size (current)
				  + sizeof (struct ar_hdr));
      /* remember about the even alignment */
      archive_member_file_ptr += archive_member_file_ptr % 2;
      current = current->next;
    }

  /* now write the strings themselves */
  for (count = 0; count < symbol_count; count++)
d2700 2
a2701 1
      size_t len = strlen (*map[count].name) + 1;
d2703 5
a2707 2
      if (bfd_write (*map[count].name, 1, len, arch) != len)
	return false;
d2710 11
a2720 8
  /* The spec says that this should be padded to an 8 byte boundary.
     However, the Irix 6.2 tools do not appear to do this.  */
  while (padding != 0)
    {
      if (bfd_write ("", 1, 1, arch) != 1)
	return false;
      --padding;
    }
d2722 1
a2722 1
  return true;
d2791 1
a2802 4
#define TARGET_LITTLE_SYM		bfd_elf64_littlemips_vec
#define TARGET_LITTLE_NAME		"elf64-littlemips"
#define TARGET_BIG_SYM			bfd_elf64_bigmips_vec
#define TARGET_BIG_NAME			"elf64-bigmips"
d2806 3
d2811 8
a2818 5
#define elf_backend_collect		true
#define elf_backend_type_change_ok	true
#define elf_backend_can_gc_sections	true
#define elf_backend_size_info		mips_elf64_size_info
#define elf_backend_object_p		_bfd_mips_elf_object_p
d2822 1
a2822 9
					_bfd_mips_elf_section_from_bfd_section
#define elf_backend_section_processing	_bfd_mips_elf_section_processing
#define elf_backend_symbol_processing	_bfd_mips_elf_symbol_processing
#define elf_backend_additional_program_headers \
					_bfd_mips_elf_additional_program_headers
#define elf_backend_modify_segment_map	_bfd_mips_elf_modify_segment_map
#define elf_backend_final_write_processing \
					_bfd_mips_elf_final_write_processing
#define elf_backend_ecoff_debug_swap	&mips_elf64_ecoff_debug_swap
d2824 2
d2827 1
a2827 1
					_bfd_mips_elf_create_dynamic_sections
d2830 1
a2830 1
					_bfd_mips_elf_adjust_dynamic_symbol
d2832 1
a2832 1
					_bfd_mips_elf_always_size_sections
d2834 1
a2834 1
					_bfd_mips_elf_size_dynamic_sections
a2835 2
#define elf_backend_link_output_symbol_hook \
					_bfd_mips_elf_link_output_symbol_hook
d2837 1
a2837 1
					_bfd_mips_elf_finish_dynamic_symbol
d2839 6
a2844 1
					_bfd_mips_elf_finish_dynamic_sections
d2847 12
a2858 1
#define elf_backend_got_header_size	(4*MIPS_RESERVED_GOTNO)
d2860 8
a2867 1
#define elf_backend_may_use_rel_p       1
d2873 1
d2875 2
d2878 1
a2878 1
					_bfd_mips_elf_link_hash_table_create
a2879 2
#define bfd_elf64_bfd_copy_private_bfd_data \
					_bfd_mips_elf_copy_private_bfd_data
d2881 1
a2881 1
					_bfd_mips_elf_merge_private_bfd_data
d2884 1
a2884 1
					_bfd_mips_elf_print_private_bfd_data
d2887 6
a2892 1
#define bfd_elf64_bfd_reloc_type_lookup	mips_elf64_reloc_type_lookup
d2894 4
a2897 1
#define bfd_elf64_archive_slurp_armap	mips_elf64_slurp_armap
d2899 1
a2899 1
				_bfd_archive_coff_slurp_extended_name_table
d2901 1
a2901 1
				_bfd_archive_coff_construct_extended_name_table
d2903 1
a2903 2
					_bfd_archive_coff_truncate_arname
#define bfd_elf64_archive_write_armap	mips_elf64_write_armap
d2906 1
a2906 1
				_bfd_archive_coff_openr_next_archived_file
d2908 1
a2908 1
					_bfd_archive_coff_get_elt_at_index
d2910 1
a2910 1
					_bfd_archive_coff_generic_stat_arch_elt
d2912 7
a2918 1
				_bfd_archive_coff_update_armap_timestamp
d2922 1
a2922 3
/* Support for traditional mips targets */

#define INCLUDED_TARGET_FILE            /* More a type of flag */
d2924 1
d2935 1
a2935 1
/* Include the target file again for this target */
@


1.4
log
@Resolve other problems that dumb cvs can't find out by itself.

(trivial part done, `interesting' patches remain)
@
text
@d2 2
a3 1
   Copyright 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d49 1
a49 1
#define ECOFF_64
d163 1
a163 1
	 			/* This needs complex overflow
d165 1
a165 1
				   bits must match the PC.  */
d627 1
a627 1
  /* Protected jump conversion.  This is an optimization hint.  No 
d716 1
a716 1
	 			/* This needs complex overflow
d718 1
a718 1
				   bits must match the PC.  */
d1181 1
a1181 1
  /* Protected jump conversion.  This is an optimization hint.  No 
d1274 1
a1274 1
  mips_elf64_swap_reloc_in (abfd, 
d1296 1
a1296 1
  mips_elf64_swap_reloca_in (abfd, 
d1328 1
a1328 1
  mips_elf64_swap_reloc_out (abfd, &mirel, 
d1350 1
a1350 1
  mips_elf64_swap_reloca_out (abfd, &mirela, 
d1393 1
a1393 1
     bfd *abfd;
d1417 1
a1417 1
     bfd *abfd;
d2154 1
a2154 1
/* We don't set bfd_elf64_bfd_is_local_label_name because the 32-bit 
d2191 17
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d77 1
a77 1
  PARAMS ((bfd *, asection *, asymbol **));
d1628 1
a1628 1
mips_elf64_slurp_reloc_table (abfd, asect, symbols)
d1632 1
d1635 6
@


1.2
log
@Merge the Cygnus 960904 sources
@
text
@d2 1
a2 1
   Copyright 1996 Free Software Foundation, Inc.
d4 2
a56 1
#if 0
a59 1
#endif
d63 8
a78 4
static boolean mips_elf64_section_from_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, char *));
static boolean mips_elf64_section_processing
  PARAMS ((bfd *, Elf_Internal_Shdr *));
a82 45
/* The relocation types.  */

enum mips_elf64_reloc_type
{
  R_MIPS_NONE = 0,
  R_MIPS_16 = 1,
  R_MIPS_32 = 2,
  R_MIPS_ADD = 2,
  R_MIPS_REL32 = 3,
  R_MIPS_REL = 3,
  R_MIPS_26 = 4,
  R_MIPS_HI16 = 5,
  R_MIPS_LO16 = 6,
  R_MIPS_GPREL16 = 7,
  R_MIPS_GPREL = 7,
  R_MIPS_LITERAL = 8,
  R_MIPS_GOT16 = 9,
  R_MIPS_GOT = 9,
  R_MIPS_PC16 = 10,
  R_MIPS_CALL16 = 11,
  R_MIPS_CALL = 11,
  R_MIPS_GPREL32 = 12,
  R_MIPS_SHIFT5 = 16,
  R_MIPS_SHIFT6 = 17,
  R_MIPS_64 = 18,
  R_MIPS_GOT_DISP = 19,
  R_MIPS_GOT_PAGE = 20,
  R_MIPS_GOT_OFST = 21,
  R_MIPS_GOT_HI16 = 22,
  R_MIPS_GOT_LO16 = 23,
  R_MIPS_SUB = 24,
  R_MIPS_INSERT_A = 25,
  R_MIPS_INSERT_B = 26,
  R_MIPS_DELETE = 27,
  R_MIPS_HIGHER = 28,
  R_MIPS_HIGHEST = 29,
  R_MIPS_CALL_HI16 = 30,
  R_MIPS_CALL_LO16 = 31,
  R_MIPS_SCN_DISP = 32,
  R_MIPS_REL16 = 33,
  R_MIPS_ADD_IMMEDIATE = 34,
  R_MIPS_PJUMP = 35,
  R_MIPS_RELGOT = 36
};

d87 3
d624 17
a640 1
	 false)			/* pcrel_offset */
d1178 17
a1194 1
	 false)			/* pcrel_offset */
d1227 1
a1227 1
  dst->r_addend = bfd_h_get_64 (abfd, (bfd_byte *) src->r_addend);
a1229 4
#if 0

/* This is not currently used.  */

a1245 2
#endif /* 0 */

d1260 91
a1350 1
  bfd_h_put_64 (abfd, src->r_offset, (bfd_byte *) dst->r_offset);
d1358 1
a1358 1
  enum mips_elf64_reloc_type elf_reloc_val;
d1381 5
a1385 1
  { BFD_RELOC_MIPS_CALL_LO16, R_MIPS_CALL_LO16 }
d1496 1
a1496 1
	  enum mips_elf64_reloc_type type;
d1503 1
a1503 1
	      type = (enum mips_elf64_reloc_type) rela.r_type;
d1506 1
a1506 1
	      type = (enum mips_elf64_reloc_type) rela.r_type2;
d1509 1
a1509 1
	      type = (enum mips_elf64_reloc_type) rela.r_type3;
a1810 109
/* Handle a 64-bit MIPS ELF specific section.  */

static boolean
mips_elf64_section_from_shdr (abfd, hdr, name)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     char *name;
{
  if (! _bfd_mips_elf_section_from_shdr (abfd, hdr, name))
    return false;

  /* For a SHT_MIPS_OPTIONS section, look for a ODK_REGINFO entry, and
     set the gp value based on what we find.  We may see both
     SHT_MIPS_REGINFO and SHT_MIPS_OPTIONS/ODK_REGINFO; in that case,
     they should agree.  */
  if (hdr->sh_type == SHT_MIPS_OPTIONS)
    {
      bfd_byte *contents, *l, *lend;

      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
      if (contents == NULL)
	return false;
      if (! bfd_get_section_contents (abfd, hdr->bfd_section, contents,
				      (file_ptr) 0, hdr->sh_size))
	{
	  free (contents);
	  return false;
	}
      l = contents;
      lend = contents + hdr->sh_size;
      while (l + sizeof (Elf_External_Options) <= lend)
	{
	  Elf_Internal_Options intopt;

	  bfd_mips_elf_swap_options_in (abfd, (Elf_External_Options *) l,
					&intopt);
	  if (intopt.kind == ODK_REGINFO)
	    {
	      Elf64_Internal_RegInfo intreg;

	      bfd_mips_elf64_swap_reginfo_in
		(abfd,
		 ((Elf64_External_RegInfo *)
		  (l + sizeof (Elf_External_Options))),
		 &intreg);
	      elf_gp (abfd) = intreg.ri_gp_value;
	    }
	  l += intopt.size;
	}
      free (contents);
    }

  return true;
}

/* Work over a section just before writing it out.  We update the GP
   value in the SHT_MIPS_OPTIONS section based on the value we are
   using.  */

static boolean
mips_elf64_section_processing (abfd, hdr)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
{
  if (hdr->sh_type == SHT_MIPS_OPTIONS
      && hdr->bfd_section != NULL
      && elf_section_data (hdr->bfd_section) != NULL
      && elf_section_data (hdr->bfd_section)->tdata != NULL)
    {
      bfd_byte *contents, *l, *lend;

      /* We stored the section contents in the elf_section_data tdata
	 field in the set_section_contents routine.  We save the
	 section contents so that we don't have to read them again.
	 At this point we know that elf_gp is set, so we can look
	 through the section contents to see if there is an
	 ODK_REGINFO structure.  */

      contents = (bfd_byte *) elf_section_data (hdr->bfd_section)->tdata;
      l = contents;
      lend = contents + hdr->sh_size;
      while (l + sizeof (Elf_External_Options) <= lend)
	{
	  Elf_Internal_Options intopt;

	  bfd_mips_elf_swap_options_in (abfd, (Elf_External_Options *) l,
					&intopt);
	  if (intopt.kind == ODK_REGINFO)
	    {
	      bfd_byte buf[8];

	      if (bfd_seek (abfd,
			    (hdr->sh_offset
			     + (l - contents)
			     + sizeof (Elf_External_Options)
			     + (sizeof (Elf64_External_RegInfo) - 8)),
			     SEEK_SET) == -1)
		return false;
	      bfd_h_put_64 (abfd, elf_gp (abfd), buf);
	      if (bfd_write (buf, 1, 8, abfd) != 8)
		return false;
	    }
	  l += intopt.size;
	}
    }

  return _bfd_mips_elf_section_processing (abfd, hdr);
}

d2077 2
d2089 6
a2094 1
  bfd_elf64_swap_dyn_in
d2103 1
d2105 4
d2111 1
a2111 1
#define elf_backend_section_from_shdr	mips_elf64_section_from_shdr
d2115 1
a2115 1
#define elf_backend_section_processing	mips_elf64_section_processing
d2117 3
d2123 26
a2148 1

a2149 2
#define bfd_elf64_get_reloc_upper_bound mips_elf64_get_reloc_upper_bound
#define bfd_elf64_bfd_reloc_type_lookup	mips_elf64_reloc_type_lookup
d2151 3
d2159 2
d2162 2
@


1.1
log
@Initial revision
@
text
@d25 3
a27 1
   writing the relocations here.  */
d32 1
d75 3
d1838 209
d2145 19
@


1.1.1.1
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d25 1
a25 3
   writing the relocations here.

   The MIPS 64-bit ELF ABI also uses an unusual archive map format.  */
a29 1
#include "aout/ar.h"
a71 3
static boolean mips_elf64_slurp_armap PARAMS ((bfd *));
static boolean mips_elf64_write_armap
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
a1831 209
/* Irix 6 defines a brand new archive map format, so that they can
   have archives more than 4 GB in size.  */

/* Read an Irix 6 armap.  */

static boolean
mips_elf64_slurp_armap (abfd)
     bfd *abfd;
{
  struct artdata *ardata = bfd_ardata (abfd);
  char nextname[17];
  file_ptr arhdrpos;
  bfd_size_type i, parsed_size, nsymz, stringsize, carsym_size, ptrsize;
  struct areltdata *mapdata;
  bfd_byte int_buf[8];
  char *stringbase;
  bfd_byte *raw_armap = NULL;
  carsym *carsyms;

  ardata->symdefs = NULL;

  /* Get the name of the first element.  */
  arhdrpos = bfd_tell (abfd);
  i = bfd_read ((PTR) nextname, 1, 16, abfd);
  if (i == 0)
    return true;
  if (i != 16)
    return false;

  if (bfd_seek (abfd, (file_ptr) - 16, SEEK_CUR) != 0)
    return false;

  /* Archives with traditional armaps are still permitted.  */
  if (strncmp (nextname, "/               ", 16) == 0)
    return bfd_slurp_armap (abfd);

  if (strncmp (nextname, "/SYM64/         ", 16) != 0)
    {
      bfd_has_map (abfd) = false;
      return true;
    }

  mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
  if (mapdata == NULL)
    return false;
  parsed_size = mapdata->parsed_size;
  bfd_release (abfd, (PTR) mapdata);

  if (bfd_read (int_buf, 1, 8, abfd) != 8)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_malformed_archive);
      return false;
    }

  nsymz = bfd_getb64 (int_buf);
  stringsize = parsed_size - 8 * nsymz - 8;

  carsym_size = nsymz * sizeof (carsym);
  ptrsize = 8 * nsymz;

  ardata->symdefs = (carsym *) bfd_zalloc (abfd, carsym_size + stringsize + 1);
  if (ardata->symdefs == NULL)
    return false;
  carsyms = ardata->symdefs;
  stringbase = ((char *) ardata->symdefs) + carsym_size;

  raw_armap = (bfd_byte *) bfd_alloc (abfd, ptrsize);
  if (raw_armap == NULL)
    goto error_return;

  if (bfd_read (raw_armap, 1, ptrsize, abfd) != ptrsize
      || bfd_read (stringbase, 1, stringsize, abfd) != stringsize)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_malformed_archive);
      goto error_return;
    }

  for (i = 0; i < nsymz; i++)
    {
      carsyms->file_offset = bfd_getb64 (raw_armap + i * 8);
      carsyms->name = stringbase;
      stringbase += strlen (stringbase) + 1;
      ++carsyms;
    }
  *stringbase = '\0';

  ardata->symdef_count = nsymz;
  ardata->first_file_filepos = arhdrpos + sizeof (struct ar_hdr) + parsed_size;

  bfd_has_map (abfd) = true;
  bfd_release (abfd, raw_armap);

  return true;

 error_return:
  if (raw_armap != NULL)
    bfd_release (abfd, raw_armap);
  if (ardata->symdefs != NULL)
    bfd_release (abfd, ardata->symdefs);
  return false;
}

/* Write out an Irix 6 armap.  The Irix 6 tools are supposed to be
   able to handle ordinary ELF armaps, but at least on Irix 6.2 the
   linker crashes.  */

static boolean
mips_elf64_write_armap (arch, elength, map, symbol_count, stridx)
     bfd *arch;
     unsigned int elength;
     struct orl *map;
     unsigned int symbol_count;
     int stridx;
{
  unsigned int ranlibsize = (symbol_count * 8) + 8;
  unsigned int stringsize = stridx;
  unsigned int mapsize = stringsize + ranlibsize;
  file_ptr archive_member_file_ptr;
  bfd *current = arch->archive_head;
  unsigned int count;
  struct ar_hdr hdr;
  unsigned int i;
  int padding;
  bfd_byte buf[8];

  padding = BFD_ALIGN (mapsize, 8) - mapsize;
  mapsize += padding;

  /* work out where the first object file will go in the archive */
  archive_member_file_ptr = (mapsize
			     + elength
			     + sizeof (struct ar_hdr)
			     + SARMAG);

  memset ((char *) (&hdr), 0, sizeof (struct ar_hdr));
  strcpy (hdr.ar_name, "/SYM64/");
  sprintf (hdr.ar_size, "%-10d", (int) mapsize);
  sprintf (hdr.ar_date, "%ld", (long) time (NULL));
  /* This, at least, is what Intel coff sets the values to.: */
  sprintf ((hdr.ar_uid), "%d", 0);
  sprintf ((hdr.ar_gid), "%d", 0);
  sprintf ((hdr.ar_mode), "%-7o", (unsigned) 0);
  strncpy (hdr.ar_fmag, ARFMAG, 2);

  for (i = 0; i < sizeof (struct ar_hdr); i++)
    if (((char *) (&hdr))[i] == '\0')
      (((char *) (&hdr))[i]) = ' ';

  /* Write the ar header for this item and the number of symbols */

  if (bfd_write ((PTR) &hdr, 1, sizeof (struct ar_hdr), arch)
      != sizeof (struct ar_hdr))
    return false;

  bfd_putb64 (symbol_count, buf);
  if (bfd_write (buf, 1, 8, arch) != 8)
    return false;

  /* Two passes, first write the file offsets for each symbol -
     remembering that each offset is on a two byte boundary.  */

  /* Write out the file offset for the file associated with each
     symbol, and remember to keep the offsets padded out.  */

  current = arch->archive_head;
  count = 0;
  while (current != (bfd *) NULL && count < symbol_count)
    {
      /* For each symbol which is used defined in this object, write out
	 the object file's address in the archive */

      while (((bfd *) (map[count]).pos) == current)
	{
	  bfd_putb64 (archive_member_file_ptr, buf);
	  if (bfd_write (buf, 1, 8, arch) != 8)
	    return false;
	  count++;
	}
      /* Add size of this archive entry */
      archive_member_file_ptr += (arelt_size (current)
				  + sizeof (struct ar_hdr));
      /* remember about the even alignment */
      archive_member_file_ptr += archive_member_file_ptr % 2;
      current = current->next;
    }

  /* now write the strings themselves */
  for (count = 0; count < symbol_count; count++)
    {
      size_t len = strlen (*map[count].name) + 1;

      if (bfd_write (*map[count].name, 1, len, arch) != len)
	return false;
    }

  /* The spec says that this should be padded to an 8 byte boundary.
     However, the Irix 6.2 tools do not appear to do this.  */
  while (padding != 0)
    {
      if (bfd_write ("", 1, 1, arch) != 1)
	return false;
      --padding;
    }

  return true;
}

a1929 19

#define bfd_elf64_archive_functions
#define bfd_elf64_archive_slurp_armap	mips_elf64_slurp_armap
#define bfd_elf64_archive_slurp_extended_name_table \
				_bfd_archive_coff_slurp_extended_name_table
#define bfd_elf64_archive_construct_extended_name_table \
				_bfd_archive_coff_construct_extended_name_table
#define bfd_elf64_archive_truncate_arname \
					_bfd_archive_coff_truncate_arname
#define bfd_elf64_archive_write_armap	mips_elf64_write_armap
#define bfd_elf64_archive_read_ar_hdr	_bfd_archive_coff_read_ar_hdr
#define bfd_elf64_archive_openr_next_archived_file \
				_bfd_archive_coff_openr_next_archived_file
#define bfd_elf64_archive_get_elt_at_index \
					_bfd_archive_coff_get_elt_at_index
#define bfd_elf64_archive_generic_stat_arch_elt \
					_bfd_archive_coff_generic_stat_arch_elt
#define bfd_elf64_archive_update_armap_timestamp \
				_bfd_archive_coff_update_armap_timestamp
@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d69 1
a69 1
  PARAMS ((bfd *, asection *, asymbol **, boolean));
d1546 1
a1546 1
mips_elf64_slurp_reloc_table (abfd, asect, symbols, dynamic)
a1549 1
     boolean dynamic;
a1551 6

  if (dynamic)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return false;
    }
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
a3 2
   Linker support added by Mark Mitchell, CodeSourcery, LLC.
   <mark@@codesourcery.com>
d55 1
d59 1
a62 8
static void mips_elf64_be_swap_reloc_in
  PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rel *));
static void mips_elf64_be_swap_reloc_out
  PARAMS ((bfd *, const Elf_Internal_Rel *, bfd_byte *));
static void mips_elf64_be_swap_reloca_in
  PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
static void mips_elf64_be_swap_reloca_out
  PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d71 4
d79 45
a127 3
/* The number of local .got entries we reserve.  */
#define MIPS_RESERVED_GOTNO (2)

d662 1
a662 17
	 false),		/* pcrel_offset */

  /* Protected jump conversion.  This is an optimization hint.  No 
     relocation is required for correctness.  */
  HOWTO (R_MIPS_JALR,	        /* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_JALR",	        /* name */
	 false,			/* partial_inplace */
	 0x00000000,		/* src_mask */
	 0x00000000,		/* dst_mask */
	 false),		/* pcrel_offset */
d1200 1
a1200 17
	 false),		/* pcrel_offset */

  /* Protected jump conversion.  This is an optimization hint.  No 
     relocation is required for correctness.  */
  HOWTO (R_MIPS_JALR,	        /* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_JALR",	        /* name */
	 false,			/* partial_inplace */
	 0x00000000,		/* src_mask */
	 0x00000000,		/* dst_mask */
	 false),		/* pcrel_offset */
d1233 1
a1233 1
  dst->r_addend = bfd_h_get_signed_64 (abfd, (bfd_byte *) src->r_addend);
d1236 4
d1256 2
d1272 1
a1272 91
  bfd_h_put_64 (abfd, src->r_addend, (bfd_byte *) dst->r_addend);
}

/* Swap in a MIPS 64-bit Rel reloc.  */

static void
mips_elf64_be_swap_reloc_in (abfd, src, dst)
     bfd *abfd;
     const bfd_byte *src;
     Elf_Internal_Rel *dst;
{
  Elf64_Mips_Internal_Rel mirel;

  mips_elf64_swap_reloc_in (abfd, 
			    (const Elf64_Mips_External_Rel *) src,
			    &mirel);

  dst[0].r_offset = mirel.r_offset;
  dst[0].r_info = ELF32_R_INFO (mirel.r_sym, mirel.r_type);
  dst[1].r_offset = mirel.r_offset;
  dst[1].r_info = ELF32_R_INFO (mirel.r_ssym, mirel.r_type2);
  dst[2].r_offset = mirel.r_offset;
  dst[2].r_info = ELF32_R_INFO (STN_UNDEF, mirel.r_type3);
}

/* Swap in a MIPS 64-bit Rela reloc.  */

static void
mips_elf64_be_swap_reloca_in (abfd, src, dst)
     bfd *abfd;
     const bfd_byte *src;
     Elf_Internal_Rela *dst;
{
  Elf64_Mips_Internal_Rela mirela;

  mips_elf64_swap_reloca_in (abfd, 
			     (const Elf64_Mips_External_Rela *) src,
			     &mirela);

  dst[0].r_offset = mirela.r_offset;
  dst[0].r_info = ELF32_R_INFO (mirela.r_sym, mirela.r_type);
  dst[0].r_addend = mirela.r_addend;
  dst[1].r_offset = mirela.r_offset;
  dst[1].r_info = ELF32_R_INFO (mirela.r_ssym, mirela.r_type2);
  dst[1].r_addend = 0;
  dst[2].r_offset = mirela.r_offset;
  dst[2].r_info = ELF32_R_INFO (STN_UNDEF, mirela.r_type3);
  dst[2].r_addend = 0;
}

/* Swap out a MIPS 64-bit Rel reloc.  */

static void
mips_elf64_be_swap_reloc_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Rel *src;
     bfd_byte *dst;
{
  Elf64_Mips_Internal_Rel mirel;

  mirel.r_offset = src->r_offset;
  mirel.r_type = ELF32_R_TYPE (src->r_info);
  mirel.r_sym = ELF32_R_SYM (src->r_info);
  mirel.r_type2 = R_MIPS_NONE;
  mirel.r_ssym = STN_UNDEF;
  mirel.r_type3 = R_MIPS_NONE;

  mips_elf64_swap_reloc_out (abfd, &mirel, 
			     (Elf64_Mips_External_Rel *) dst);
}

/* Swap out a MIPS 64-bit Rela reloc.  */

static void
mips_elf64_be_swap_reloca_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Rela *src;
     bfd_byte *dst;
{
  Elf64_Mips_Internal_Rela mirela;

  mirela.r_offset = src->r_offset;
  mirela.r_type = ELF32_R_TYPE (src->r_info);
  mirela.r_addend = src->r_addend;
  mirela.r_sym = ELF32_R_SYM (src->r_info);
  mirela.r_type2 = R_MIPS_NONE;
  mirela.r_ssym = STN_UNDEF;
  mirela.r_type3 = R_MIPS_NONE;

  mips_elf64_swap_reloca_out (abfd, &mirela, 
			      (Elf64_Mips_External_Rela *) dst);
d1280 1
a1280 1
  enum elf_mips_reloc_type elf_reloc_val;
d1303 1
a1303 5
  { BFD_RELOC_MIPS_CALL_LO16, R_MIPS_CALL_LO16 },
  { BFD_RELOC_MIPS_SUB, R_MIPS_SUB },
  { BFD_RELOC_MIPS_GOT_PAGE, R_MIPS_GOT_PAGE },
  { BFD_RELOC_MIPS_GOT_OFST, R_MIPS_GOT_OFST },
  { BFD_RELOC_MIPS_GOT_DISP, R_MIPS_GOT_DISP }
d1414 1
a1414 1
	  enum elf_mips_reloc_type type;
d1421 1
a1421 1
	      type = (enum elf_mips_reloc_type) rela.r_type;
d1424 1
a1424 1
	      type = (enum elf_mips_reloc_type) rela.r_type2;
d1427 1
a1427 1
	      type = (enum elf_mips_reloc_type) rela.r_type3;
d1736 109
a2110 2
  4,            /* hash-table entry size */
  3,            /* internal relocations per external relocations */
d2121 1
a2121 6
  bfd_elf64_swap_dyn_in,
  bfd_elf64_swap_dyn_out,
  mips_elf64_be_swap_reloc_in,
  mips_elf64_be_swap_reloc_out,
  mips_elf64_be_swap_reloca_in,
  mips_elf64_be_swap_reloca_out
a2129 1

a2130 4

#define elf_backend_collect		true
#define elf_backend_type_change_ok	true
#define elf_backend_can_gc_sections	true
d2133 1
a2133 1
#define elf_backend_section_from_shdr	_bfd_mips_elf_section_from_shdr
d2137 1
a2137 1
#define elf_backend_section_processing	_bfd_mips_elf_section_processing
a2138 3
#define elf_backend_additional_program_headers \
					_bfd_mips_elf_additional_program_headers
#define elf_backend_modify_segment_map	_bfd_mips_elf_modify_segment_map
d2142 1
a2142 26
#define elf_backend_add_symbol_hook	_bfd_mips_elf_add_symbol_hook
#define elf_backend_create_dynamic_sections \
					_bfd_mips_elf_create_dynamic_sections
#define elf_backend_check_relocs	_bfd_mips_elf_check_relocs
#define elf_backend_adjust_dynamic_symbol \
					_bfd_mips_elf_adjust_dynamic_symbol
#define elf_backend_always_size_sections \
					_bfd_mips_elf_always_size_sections
#define elf_backend_size_dynamic_sections \
					_bfd_mips_elf_size_dynamic_sections
#define elf_backend_relocate_section    _bfd_mips_elf_relocate_section
#define elf_backend_link_output_symbol_hook \
					_bfd_mips_elf_link_output_symbol_hook
#define elf_backend_finish_dynamic_symbol \
					_bfd_mips_elf_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
					_bfd_mips_elf_finish_dynamic_sections
#define elf_backend_gc_mark_hook	_bfd_mips_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook	_bfd_mips_elf_gc_sweep_hook
#define elf_backend_got_header_size	(4*MIPS_RESERVED_GOTNO)
#define elf_backend_plt_header_size	0
#define elf_backend_may_use_rel_p       1

/* We don't set bfd_elf64_bfd_is_local_label_name because the 32-bit 
   MIPS-specific function only applies to IRIX5, which had no 64-bit
   ABI.  */
d2144 2
a2146 3
#define bfd_elf64_bfd_link_hash_table_create \
					_bfd_mips_elf_link_hash_table_create
#define bfd_elf64_bfd_final_link	_bfd_mips_elf_final_link
a2151 2
#define bfd_elf64_bfd_print_private_bfd_data \
					_bfd_mips_elf_print_private_bfd_data
a2152 2
#define bfd_elf64_get_reloc_upper_bound mips_elf64_get_reloc_upper_bound
#define bfd_elf64_bfd_reloc_type_lookup	mips_elf64_reloc_type_lookup
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d48 1
a48 1
#define ECOFF_SIGNED_64
d162 1
a162 1
				/* This needs complex overflow
d164 1
a164 1
				   bits must match the PC + 4.  */
d626 1
a626 1
  /* Protected jump conversion.  This is an optimization hint.  No
d715 1
a715 1
				/* This needs complex overflow
d717 1
a717 1
				   bits must match the PC + 4.  */
d1180 1
a1180 1
  /* Protected jump conversion.  This is an optimization hint.  No
d1273 1
a1273 1
  mips_elf64_swap_reloc_in (abfd,
d1295 1
a1295 1
  mips_elf64_swap_reloca_in (abfd,
d1327 1
a1327 1
  mips_elf64_swap_reloc_out (abfd, &mirel,
d1349 1
a1349 1
  mips_elf64_swap_reloca_out (abfd, &mirela,
d1392 1
a1392 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1416 1
a1416 1
     bfd *abfd ATTRIBUTE_UNUSED;
d2153 1
a2153 1
/* We don't set bfd_elf64_bfd_is_local_label_name because the 32-bit
a2189 17
#include "elf64-target.h"

/* Support for traditional mips targets */

#define INCLUDED_TARGET_FILE            /* More a type of flag */

#undef TARGET_LITTLE_SYM
#undef TARGET_LITTLE_NAME
#undef TARGET_BIG_SYM
#undef TARGET_BIG_NAME

#define TARGET_LITTLE_SYM               bfd_elf64_tradlittlemips_vec
#define TARGET_LITTLE_NAME              "elf64-tradlittlemips"
#define TARGET_BIG_SYM                  bfd_elf64_tradbigmips_vec
#define TARGET_BIG_NAME                 "elf64-tradbigmips"

/* Include the target file again for this target */
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d28 1
a28 1
   writing the relocations here.  */
d30 1
a30 12
/* TODO: Many things are unsupported, even if there is some code for it
 .       (which was mostly stolen from elf32-mips.c and slightly adapted).
 .
 .   - Relocation handling for REL relocs is wrong in many cases and
 .     generally untested.
 .   - Relocation handling for RELA relocs related to GOT support are
 .     also likely to be wrong.
 .   - Support for MIPS16 is untested.
 .   - Combined relocs with RSS_* entries are unsupported.
 .   - The whole GOT handling for NewABI is missing, some parts of
 .     the OldABI version is still lying around and should be removed.
 */
a38 1
#include "elfxx-mips.h"
d54 1
a54 1
	   Elf64_Mips_Internal_Rela *));
d59 1
a59 1
  PARAMS ((bfd *, const Elf64_Mips_Internal_Rela *,
d65 1
a65 1
  PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
d67 1
a67 1
  PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d72 1
a72 1
static reloc_howto_type *bfd_elf64_bfd_reloc_type_lookup
d74 9
a82 55
static reloc_howto_type *mips_elf64_rtype_to_howto
  PARAMS ((unsigned int, bfd_boolean));
static void mips_elf64_info_to_howto_rel
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static void mips_elf64_info_to_howto_rela
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static long mips_elf64_get_reloc_upper_bound
  PARAMS ((bfd *, asection *));
static long mips_elf64_canonicalize_reloc
  PARAMS ((bfd *, asection *, arelent **, asymbol **));
static long mips_elf64_get_dynamic_reloc_upper_bound PARAMS ((bfd *));
static long mips_elf64_canonicalize_dynamic_reloc
  PARAMS ((bfd *, arelent **, asymbol **));
static bfd_boolean mips_elf64_slurp_one_reloc_table
  PARAMS ((bfd *, asection *, Elf_Internal_Shdr *, bfd_size_type,
	   arelent *, asymbol **, bfd_boolean));
static bfd_boolean mips_elf64_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
static void mips_elf64_write_relocs
  PARAMS ((bfd *, asection *, PTR));
static void mips_elf64_write_rel
  PARAMS((bfd *, asection *, Elf_Internal_Shdr *, int *, PTR));
static void mips_elf64_write_rela
  PARAMS((bfd *, asection *, Elf_Internal_Shdr *, int *, PTR));
static bfd_reloc_status_type mips_elf64_hi16_reloc
  PARAMS ((bfd *, arelent *, asymbol *,	PTR, asection *, bfd *, char **));
static bfd_reloc_status_type mips_elf64_gprel16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type mips_elf64_literal_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type mips_elf64_gprel32_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type mips_elf64_shift6_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type mips_elf64_got16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type mips16_jump_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type mips16_gprel_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_boolean mips_elf64_assign_gp
  PARAMS ((bfd *, bfd_vma *));
static bfd_reloc_status_type mips_elf64_final_gp
  PARAMS ((bfd *, asymbol *, bfd_boolean, char **, bfd_vma *));
static bfd_boolean mips_elf64_object_p
  PARAMS ((bfd *));
static irix_compat_t elf64_mips_irix_compat
  PARAMS ((bfd *));
static bfd_boolean elf64_mips_grok_prstatus
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elf64_mips_grok_psinfo
  PARAMS ((bfd *, Elf_Internal_Note *));

extern const bfd_target bfd_elf64_bigmips_vec;
extern const bfd_target bfd_elf64_littlemips_vec;
d90 1
a90 1

d100 1
a100 1
	 FALSE,			/* pc_relative */
d105 1
a105 1
	 FALSE,			/* partial_inplace */
d108 1
a108 1
	 FALSE),		/* pcrel_offset */
d113 1
a113 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d115 1
a115 1
	 FALSE,			/* pc_relative */
d117 1
a117 1
	 complain_overflow_signed, /* complain_on_overflow */
d120 4
a123 4
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d130 1
a130 1
	 FALSE,			/* pc_relative */
d132 1
a132 1
	 complain_overflow_dont, /* complain_on_overflow */
d135 1
a135 1
	 TRUE,			/* partial_inplace */
d138 1
a138 1
	 FALSE),		/* pcrel_offset */
d145 1
a145 1
	 FALSE,			/* pc_relative */
d147 1
a147 1
	 complain_overflow_dont, /* complain_on_overflow */
d150 1
a150 1
	 TRUE,			/* partial_inplace */
d153 1
a153 1
	 FALSE),		/* pcrel_offset */
d155 1
a155 1
  /* 26 bit jump address.  */
d160 1
a160 1
	 FALSE,			/* pc_relative */
d164 1
a164 1
				   detection, because the upper 36
d168 4
a171 7
	 TRUE,			/* partial_inplace */
	 0x03ffffff,		/* src_mask */
	 0x03ffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* R_MIPS_HI16 and R_MIPS_LO16 are unsupported for NewABI REL.
     However, the native IRIX6 tools use them, so we try our best. */
d178 1
a178 1
	 FALSE,			/* pc_relative */
d181 1
a181 1
	 mips_elf64_hi16_reloc,	/* special_function */
d183 4
a186 4
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d193 1
a193 1
	 FALSE,			/* pc_relative */
d196 1
a196 1
	 bfd_elf_generic_reloc,	/* special_function */
d198 4
a201 4
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d208 1
a208 1
	 FALSE,			/* pc_relative */
d211 1
a211 1
	 mips_elf64_gprel16_reloc, /* special_function */
d213 4
a216 4
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d223 1
a223 1
	 FALSE,			/* pc_relative */
d226 1
a226 1
	 mips_elf64_literal_reloc, /* special_function */
d228 4
a231 4
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d238 1
a238 1
	 FALSE,			/* pc_relative */
d241 1
a241 1
	 mips_elf64_got16_reloc, /* special_function */
d243 4
a246 4
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d253 1
a253 1
	 TRUE,			/* pc_relative */
d258 4
a261 4
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d264 1
d269 1
a269 1
	 FALSE,			/* pc_relative */
d274 4
a277 4
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d284 1
a284 1
	 FALSE,			/* pc_relative */
d286 2
a287 2
	 complain_overflow_dont, /* complain_on_overflow */
	 mips_elf64_gprel32_reloc, /* special_function */
d289 1
a289 1
	 TRUE,			/* partial_inplace */
d292 1
a292 1
	 FALSE),		/* pcrel_offset */
d294 3
a296 3
  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),
d303 1
a303 1
	 FALSE,			/* pc_relative */
d308 1
a308 1
	 TRUE,			/* partial_inplace */
d311 1
a311 1
	 FALSE),		/* pcrel_offset */
d314 2
d320 1
a320 1
	 FALSE,			/* pc_relative */
d323 1
a323 1
	 mips_elf64_shift6_reloc, /* special_function */
d325 1
a325 1
	 TRUE,			/* partial_inplace */
d328 1
a328 1
	 FALSE),		/* pcrel_offset */
d335 1
a335 1
	 FALSE,			/* pc_relative */
d337 1
a337 1
	 complain_overflow_dont, /* complain_on_overflow */
d340 1
a340 1
	 TRUE,			/* partial_inplace */
d343 1
a343 1
	 FALSE),		/* pcrel_offset */
d346 1
d351 1
a351 1
	 FALSE,			/* pc_relative */
d353 1
a353 1
	 complain_overflow_signed, /* complain_on_overflow */
d356 1
a356 1
	 TRUE,			/* partial_inplace */
d359 1
a359 1
	 FALSE),		/* pcrel_offset */
d362 1
d367 1
a367 1
	 FALSE,			/* pc_relative */
d369 1
a369 1
	 complain_overflow_signed, /* complain_on_overflow */
d372 1
a372 1
	 TRUE,			/* partial_inplace */
d375 1
a375 1
	 FALSE),		/* pcrel_offset */
d378 1
d383 1
a383 1
	 FALSE,			/* pc_relative */
d385 1
a385 1
	 complain_overflow_signed, /* complain_on_overflow */
d388 1
a388 1
	 TRUE,			/* partial_inplace */
d391 1
a391 1
	 FALSE),		/* pcrel_offset */
d394 1
d399 1
a399 1
	 FALSE,			/* pc_relative */
d404 1
a404 1
	 TRUE,			/* partial_inplace */
d407 1
a407 1
	 FALSE),		/* pcrel_offset */
d410 1
d415 1
a415 1
	 FALSE,			/* pc_relative */
d420 1
a420 1
	 TRUE,			/* partial_inplace */
d423 1
a423 1
	 FALSE),		/* pcrel_offset */
d426 1
d431 1
a431 1
	 FALSE,			/* pc_relative */
d433 1
a433 1
	 complain_overflow_dont, /* complain_on_overflow */
d436 1
a436 1
	 TRUE,			/* partial_inplace */
d439 1
a439 1
	 FALSE),		/* pcrel_offset */
d445 3
a447 3
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
d452 4
a455 4
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d462 3
a464 3
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
d469 4
a472 4
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d478 16
d495 2
a496 2
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
d500 5
a504 5
	 "R_MIPS_DELETE",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d506 15
a520 8
  /* The MIPS ELF64 ABI Draft wants us to support these for REL relocations.
     We don't, because
       a) It means building the addend from a R_MIPS_HIGHEST/R_MIPS_HIGHER/
	  R_MIPS_HI16/R_MIPS_LO16 sequence with varying ordering, using
	  fallable heuristics.
       b) No other NewABI toolchain actually emits such relocations.  */
  EMPTY_HOWTO (R_MIPS_HIGHER),
  EMPTY_HOWTO (R_MIPS_HIGHEST),
d523 1
d528 1
a528 1
	 FALSE,			/* pc_relative */
d533 1
a533 1
	 TRUE,			/* partial_inplace */
d536 1
a536 1
	 FALSE),		/* pcrel_offset */
d539 1
d544 1
a544 1
	 FALSE,			/* pc_relative */
d549 1
a549 1
	 TRUE,			/* partial_inplace */
d552 4
a555 1
	 FALSE),		/* pcrel_offset */
a556 1
  /* Section displacement, used by an associated event location section.  */
d559 3
a561 3
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
d566 4
a569 4
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d573 3
a575 3
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
d577 1
a577 1
	 complain_overflow_signed, /* complain_on_overflow */
d580 18
a597 4
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d599 13
a611 3
  /* These two are obsolete.  */
  EMPTY_HOWTO (R_MIPS_ADD_IMMEDIATE),
  EMPTY_HOWTO (R_MIPS_PJUMP),
a612 2
  /* Similiar to R_MIPS_REL32, but used for relocations in a GOT section.
     It must be used for multigot GOT's (and only there).  */
d615 3
a617 3
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
d622 4
a625 4
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d631 3
a633 3
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
d638 2
a639 2
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
d641 1
a641 1
	 FALSE),		/* pcrel_offset */
d653 1
a653 1
	 FALSE,			/* pc_relative */
d658 1
a658 1
	 FALSE,			/* partial_inplace */
d661 1
a661 1
	 FALSE),		/* pcrel_offset */
d666 1
a666 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d668 1
a668 1
	 FALSE,			/* pc_relative */
d670 1
a670 1
	 complain_overflow_signed, /* complain_on_overflow */
d673 1
a673 1
	 FALSE,			/* partial_inplace */
d675 2
a676 2
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d683 1
a683 1
	 FALSE,			/* pc_relative */
d685 1
a685 1
	 complain_overflow_dont, /* complain_on_overflow */
d688 1
a688 1
	 FALSE,			/* partial_inplace */
d691 1
a691 1
	 FALSE),		/* pcrel_offset */
d698 1
a698 1
	 FALSE,			/* pc_relative */
d700 1
a700 1
	 complain_overflow_dont, /* complain_on_overflow */
d703 1
a703 1
	 FALSE,			/* partial_inplace */
d706 1
a706 1
	 FALSE),		/* pcrel_offset */
d708 1
a708 1
  /* 26 bit jump address.  */
d713 1
a713 1
	 FALSE,			/* pc_relative */
d717 1
a717 1
				   detection, because the upper 36
d721 1
a721 1
	 FALSE,			/* partial_inplace */
d723 2
a724 2
	 0x03ffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d731 1
a731 1
	 FALSE,			/* pc_relative */
d736 1
a736 1
	 FALSE,			/* partial_inplace */
d738 2
a739 2
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d746 1
a746 1
	 FALSE,			/* pc_relative */
d751 1
a751 1
	 FALSE,			/* partial_inplace */
d753 2
a754 2
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d761 1
a761 1
	 FALSE,			/* pc_relative */
d764 1
a764 1
	 mips_elf64_gprel16_reloc, /* special_function */
d766 1
a766 1
	 FALSE,			/* partial_inplace */
d768 2
a769 2
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d776 1
a776 1
	 FALSE,			/* pc_relative */
d779 1
a779 1
	 mips_elf64_literal_reloc, /* special_function */
d781 1
a781 1
	 FALSE,			/* partial_inplace */
d783 2
a784 2
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d787 1
d792 1
a792 1
	 FALSE,			/* pc_relative */
d795 1
a795 1
	 mips_elf64_got16_reloc, /* special_function */
d797 1
a797 1
	 FALSE,			/* partial_inplace */
d799 2
a800 2
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d807 1
a807 1
	 TRUE,			/* pc_relative */
d812 1
a812 1
	 FALSE,			/* partial_inplace */
d814 2
a815 2
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d818 1
d823 1
a823 1
	 FALSE,			/* pc_relative */
d828 1
a828 1
	 FALSE,			/* partial_inplace */
d830 2
a831 2
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d838 1
a838 1
	 FALSE,			/* pc_relative */
d840 2
a841 2
	 complain_overflow_dont, /* complain_on_overflow */
	 mips_elf64_gprel32_reloc, /* special_function */
d843 1
a843 1
	 FALSE,			/* partial_inplace */
d846 1
a846 1
	 FALSE),		/* pcrel_offset */
d848 3
a850 3
  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),
d857 1
a857 1
	 FALSE,			/* pc_relative */
d862 1
a862 1
	 FALSE,			/* partial_inplace */
d865 1
a865 1
	 FALSE),		/* pcrel_offset */
d868 2
d874 1
a874 1
	 FALSE,			/* pc_relative */
d877 1
a877 1
	 mips_elf64_shift6_reloc, /* special_function */
d879 1
a879 1
	 FALSE,			/* partial_inplace */
d882 1
a882 1
	 FALSE),		/* pcrel_offset */
d889 1
a889 1
	 FALSE,			/* pc_relative */
d891 1
a891 1
	 complain_overflow_dont, /* complain_on_overflow */
d894 1
a894 1
	 FALSE,			/* partial_inplace */
d897 1
a897 1
	 FALSE),		/* pcrel_offset */
d900 1
d905 1
a905 1
	 FALSE,			/* pc_relative */
d907 1
a907 1
	 complain_overflow_signed, /* complain_on_overflow */
d910 1
a910 1
	 FALSE,			/* partial_inplace */
d913 1
a913 1
	 FALSE),		/* pcrel_offset */
d916 1
d921 1
a921 1
	 FALSE,			/* pc_relative */
d923 1
a923 1
	 complain_overflow_signed, /* complain_on_overflow */
d926 1
a926 1
	 FALSE,			/* partial_inplace */
d929 1
a929 1
	 FALSE),		/* pcrel_offset */
d932 1
d937 1
a937 1
	 FALSE,			/* pc_relative */
d939 1
a939 1
	 complain_overflow_signed, /* complain_on_overflow */
d942 1
a942 1
	 FALSE,			/* partial_inplace */
d945 1
a945 1
	 FALSE),		/* pcrel_offset */
d948 1
d953 1
a953 1
	 FALSE,			/* pc_relative */
d958 1
a958 1
	 FALSE,			/* partial_inplace */
d961 1
a961 1
	 FALSE),		/* pcrel_offset */
d964 1
d969 1
a969 1
	 FALSE,			/* pc_relative */
d974 1
a974 1
	 FALSE,			/* partial_inplace */
d977 1
a977 1
	 FALSE),		/* pcrel_offset */
d980 1
d985 1
a985 1
	 FALSE,			/* pc_relative */
d987 1
a987 1
	 complain_overflow_dont, /* complain_on_overflow */
d990 1
a990 1
	 FALSE,			/* partial_inplace */
d993 1
a993 1
	 FALSE),		/* pcrel_offset */
d999 3
a1001 3
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
d1006 1
a1006 1
	 FALSE,			/* partial_inplace */
d1008 2
a1009 2
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1016 3
a1018 3
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
d1023 1
a1023 1
	 FALSE,			/* partial_inplace */
d1025 2
a1026 2
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1032 3
a1034 3
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
d1039 1
a1039 1
	 FALSE,			/* partial_inplace */
d1041 2
a1042 2
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1045 1
d1050 1
a1050 1
	 FALSE,			/* pc_relative */
d1053 1
a1053 1
	 bfd_elf_generic_reloc, /* special_function */
d1055 1
a1055 1
	 FALSE,			/* partial_inplace */
d1057 2
a1058 2
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1061 1
d1066 1
a1066 1
	 FALSE,			/* pc_relative */
d1069 1
a1069 1
	 bfd_elf_generic_reloc, /* special_function */
d1071 1
a1071 1
	 FALSE,			/* partial_inplace */
d1073 2
a1074 2
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1077 1
d1082 1
a1082 1
	 FALSE,			/* pc_relative */
d1087 1
a1087 1
	 FALSE,			/* partial_inplace */
d1090 1
a1090 1
	 FALSE),		/* pcrel_offset */
d1093 1
d1098 1
a1098 1
	 FALSE,			/* pc_relative */
d1103 1
a1103 1
	 FALSE,			/* partial_inplace */
d1106 4
a1109 1
	 FALSE),		/* pcrel_offset */
a1110 1
  /* Section displacement, used by an associated event location section.  */
d1113 3
a1115 3
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
d1120 1
a1120 1
	 FALSE,			/* partial_inplace */
d1122 2
a1123 2
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1127 5
a1131 5
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
d1134 1
a1134 1
	 FALSE,			/* partial_inplace */
d1136 2
a1137 6
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* These two are obsolete.  */
  EMPTY_HOWTO (R_MIPS_ADD_IMMEDIATE),
  EMPTY_HOWTO (R_MIPS_PJUMP),
d1139 1
a1139 3
  /* Similiar to R_MIPS_REL32, but used for relocations in a GOT section.
     It must be used for multigot GOT's (and only there).  */
  HOWTO (R_MIPS_RELGOT,		/* type */
d1141 3
a1143 3
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
d1147 2
a1148 2
	 "R_MIPS_RELGOT",	/* name */
	 FALSE,			/* partial_inplace */
d1150 2
a1151 2
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1153 1
a1153 3
  /* Protected jump conversion.  This is an optimization hint.  No
     relocation is required for correctness.  */
  HOWTO (R_MIPS_JALR,	        /* type */
d1155 3
a1157 3
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
d1161 2
a1162 2
	 "R_MIPS_JALR",	        /* name */
	 FALSE,			/* partial_inplace */
d1164 2
a1165 3
	 0x00000000,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};
d1167 1
a1167 22
/* The reloc used for the mips16 jump instruction.  */
static reloc_howto_type elf_mips16_jump_howto =
  HOWTO (R_MIPS16_26,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 			/* This needs complex overflow
				   detection, because the upper four
				   bits must match the PC.  */
	 mips16_jump_reloc,	/* special_function */
	 "R_MIPS16_26",		/* name */
	 TRUE,			/* partial_inplace */
	 0x3ffffff,		/* src_mask */
	 0x3ffffff,		/* dst_mask */
	 FALSE);		/* pcrel_offset */

/* The reloc used for the mips16 gprel instruction.  */
static reloc_howto_type elf_mips16_gprel_howto =
  HOWTO (R_MIPS16_GPREL,	/* type */
d1169 1
a1169 17
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips16_gprel_reloc,	/* special_function */
	 "R_MIPS16_GPREL",	/* name */
	 TRUE,			/* partial_inplace */
	 0x07ff001f,		/* src_mask */
	 0x07ff001f,	        /* dst_mask */
	 FALSE);		/* pcrel_offset */

/* GNU extension to record C++ vtable hierarchy */
static reloc_howto_type elf_mips_gnu_vtinherit_howto =
  HOWTO (R_MIPS_GNU_VTINHERIT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d1171 1
a1171 1
	 FALSE,			/* pc_relative */
d1174 3
a1176 3
	 NULL,			/* special_function */
	 "R_MIPS_GNU_VTINHERIT", /* name */
	 FALSE,			/* partial_inplace */
d1179 1
a1179 1
	 FALSE);		/* pcrel_offset */
d1181 3
a1183 3
/* GNU extension to record C++ vtable member usage */
static reloc_howto_type elf_mips_gnu_vtentry_howto =
  HOWTO (R_MIPS_GNU_VTENTRY,	/* type */
d1185 1
a1185 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d1187 1
a1187 1
	 FALSE,			/* pc_relative */
d1190 8
a1197 7
	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
	 "R_MIPS_GNU_VTENTRY",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE);		/* pcrel_offset */

d1204 1
a1204 1
     Elf64_Mips_Internal_Rela *dst;
d1206 6
a1211 7
  dst->r_offset = H_GET_64 (abfd, src->r_offset);
  dst->r_sym = H_GET_32 (abfd, src->r_sym);
  dst->r_ssym = H_GET_8 (abfd, src->r_ssym);
  dst->r_type3 = H_GET_8 (abfd, src->r_type3);
  dst->r_type2 = H_GET_8 (abfd, src->r_type2);
  dst->r_type = H_GET_8 (abfd, src->r_type);
  dst->r_addend = 0;
d1222 7
a1228 7
  dst->r_offset = H_GET_64 (abfd, src->r_offset);
  dst->r_sym = H_GET_32 (abfd, src->r_sym);
  dst->r_ssym = H_GET_8 (abfd, src->r_ssym);
  dst->r_type3 = H_GET_8 (abfd, src->r_type3);
  dst->r_type2 = H_GET_8 (abfd, src->r_type2);
  dst->r_type = H_GET_8 (abfd, src->r_type);
  dst->r_addend = H_GET_S64 (abfd, src->r_addend);
d1236 1
a1236 1
     const Elf64_Mips_Internal_Rela *src;
d1239 6
a1244 6
  H_PUT_64 (abfd, src->r_offset, dst->r_offset);
  H_PUT_32 (abfd, src->r_sym, dst->r_sym);
  H_PUT_8 (abfd, src->r_ssym, dst->r_ssym);
  H_PUT_8 (abfd, src->r_type3, dst->r_type3);
  H_PUT_8 (abfd, src->r_type2, dst->r_type2);
  H_PUT_8 (abfd, src->r_type, dst->r_type);
d1255 7
a1261 7
  H_PUT_64 (abfd, src->r_offset, dst->r_offset);
  H_PUT_32 (abfd, src->r_sym, dst->r_sym);
  H_PUT_8 (abfd, src->r_ssym, dst->r_ssym);
  H_PUT_8 (abfd, src->r_type3, dst->r_type3);
  H_PUT_8 (abfd, src->r_type2, dst->r_type2);
  H_PUT_8 (abfd, src->r_type, dst->r_type);
  H_PUT_S64 (abfd, src->r_addend, dst->r_addend);
d1270 1
a1270 1
     Elf_Internal_Rela *dst;
d1272 1
a1272 1
  Elf64_Mips_Internal_Rela mirel;
d1279 1
a1279 2
  dst[0].r_info = ELF64_R_INFO (mirel.r_sym, mirel.r_type);
  dst[0].r_addend = 0;
d1281 1
a1281 2
  dst[1].r_info = ELF64_R_INFO (mirel.r_ssym, mirel.r_type2);
  dst[1].r_addend = 0;
d1283 1
a1283 2
  dst[2].r_info = ELF64_R_INFO (STN_UNDEF, mirel.r_type3);
  dst[2].r_addend = 0;
d1301 1
a1301 1
  dst[0].r_info = ELF64_R_INFO (mirela.r_sym, mirela.r_type);
d1304 1
a1304 1
  dst[1].r_info = ELF64_R_INFO (mirela.r_ssym, mirela.r_type2);
d1307 1
a1307 1
  dst[2].r_info = ELF64_R_INFO (STN_UNDEF, mirela.r_type3);
d1316 1
a1316 1
     const Elf_Internal_Rela *src;
d1319 1
a1319 1
  Elf64_Mips_Internal_Rela mirel;
d1321 6
a1326 11
  mirel.r_offset = src[0].r_offset;
  BFD_ASSERT(src[0].r_offset == src[1].r_offset);
#if 0
  BFD_ASSERT(src[0].r_offset == src[2].r_offset);
#endif

  mirel.r_type = ELF64_MIPS_R_TYPE (src[0].r_info);
  mirel.r_sym = ELF64_R_SYM (src[0].r_info);
  mirel.r_type2 = ELF64_MIPS_R_TYPE (src[1].r_info);
  mirel.r_ssym = ELF64_MIPS_R_SSYM (src[1].r_info);
  mirel.r_type3 = ELF64_MIPS_R_TYPE (src[2].r_info);
d1342 7
a1348 13
  mirela.r_offset = src[0].r_offset;
  BFD_ASSERT(src[0].r_offset == src[1].r_offset);
  BFD_ASSERT(src[0].r_offset == src[2].r_offset);

  mirela.r_type = ELF64_MIPS_R_TYPE (src[0].r_info);
  mirela.r_sym = ELF64_R_SYM (src[0].r_info);
  mirela.r_addend = src[0].r_addend;
  BFD_ASSERT(src[1].r_addend == 0);
  BFD_ASSERT(src[2].r_addend == 0);

  mirela.r_type2 = ELF64_MIPS_R_TYPE (src[1].r_info);
  mirela.r_ssym = ELF64_MIPS_R_SSYM (src[1].r_info);
  mirela.r_type3 = ELF64_MIPS_R_TYPE (src[2].r_info);
a1352 2

/* Do a R_MIPS_HI16 relocation.  */
d1354 1
a1354 116
static bfd_reloc_status_type
mips_elf64_hi16_reloc (abfd, reloc_entry, symbol, data, input_section,
		       output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  /* If we're relocating, and this is an external symbol, we don't
     want to change anything.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (((reloc_entry->addend & 0xffff) + 0x8000) & ~0xffff)
    reloc_entry->addend += 0x8000;

  return bfd_reloc_continue;
}

/* Do a R_MIPS_GOT16 reloc.  This is a reloc against the global offset
   table used for PIC code.  If the symbol is an external symbol, the
   instruction is modified to contain the offset of the appropriate
   entry in the global offset table.  If the symbol is a section
   symbol, the next reloc is a R_MIPS_LO16 reloc.  The two 16 bit
   addends are combined to form the real addend against the section
   symbol; the GOT16 is modified to contain the offset of an entry in
   the global offset table, and the LO16 is modified to offset it
   appropriately.  Thus an offset larger than 16 bits requires a
   modified value in the global offset table.

   This implementation suffices for the assembler, but the linker does
   not yet know how to create global offset tables.  */

static bfd_reloc_status_type
mips_elf64_got16_reloc (abfd, reloc_entry, symbol, data, input_section,
			output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  /* If we're relocating, and this is a local symbol, we can handle it
     just like an R_MIPS_HI16.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) != 0)
    return mips_elf64_hi16_reloc (abfd, reloc_entry, symbol, data,
				  input_section, output_bfd, error_message);


  /* Otherwise we try to handle it as R_MIPS_GOT_DISP.  */
  return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				input_section, output_bfd, error_message);
}

/* Set the GP value for OUTPUT_BFD.  Returns FALSE if this is a
   dangerous relocation.  */

static bfd_boolean
mips_elf64_assign_gp (output_bfd, pgp)
     bfd *output_bfd;
     bfd_vma *pgp;
{
  unsigned int count;
  asymbol **sym;
  unsigned int i;

  /* If we've already figured out what GP will be, just return it.  */
  *pgp = _bfd_get_gp_value (output_bfd);
  if (*pgp)
    return TRUE;

  count = bfd_get_symcount (output_bfd);
  sym = bfd_get_outsymbols (output_bfd);

  /* The linker script will have created a symbol named `_gp' with the
     appropriate value.  */
  if (sym == (asymbol **) NULL)
    i = count;
  else
    {
      for (i = 0; i < count; i++, sym++)
	{
	  register const char *name;

	  name = bfd_asymbol_name (*sym);
	  if (*name == '_' && strcmp (name, "_gp") == 0)
	    {
	      *pgp = bfd_asymbol_value (*sym);
	      _bfd_set_gp_value (output_bfd, *pgp);
	      break;
	    }
	}
    }

  if (i >= count)
    {
      /* Only get the error once.  */
      *pgp = 4;
      _bfd_set_gp_value (output_bfd, *pgp);
      return FALSE;
    }

  return TRUE;
}
d1356 1
a1356 13
/* We have to figure out the gp value, so that we can adjust the
   symbol value correctly.  We look up the symbol _gp in the output
   BFD.  If we can't find it, we're stuck.  We cache it in the ELF
   target data.  We don't need to adjust the symbol value for an
   external symbol if we are producing relocateable output.  */

static bfd_reloc_status_type
mips_elf64_final_gp (output_bfd, symbol, relocateable, error_message, pgp)
     bfd *output_bfd;
     asymbol *symbol;
     bfd_boolean relocateable;
     char **error_message;
     bfd_vma *pgp;
d1358 2
a1359 359
  if (bfd_is_und_section (symbol->section)
      && ! relocateable)
    {
      *pgp = 0;
      return bfd_reloc_undefined;
    }

  *pgp = _bfd_get_gp_value (output_bfd);
  if (*pgp == 0
      && (! relocateable
	  || (symbol->flags & BSF_SECTION_SYM) != 0))
    {
      if (relocateable)
	{
	  /* Make up a value.  */
	  *pgp = symbol->section->output_section->vma /*+ 0x4000*/;
	  _bfd_set_gp_value (output_bfd, *pgp);
	}
      else if (!mips_elf64_assign_gp (output_bfd, pgp))
	{
	  *error_message =
	    (char *) _("GP relative relocation when _gp not defined");
	  return bfd_reloc_dangerous;
	}
    }

  return bfd_reloc_ok;
}

/* Do a R_MIPS_GPREL16 relocation.  This is a 16 bit value which must
   become the offset from the gp register.  */

static bfd_reloc_status_type
mips_elf64_gprel16_reloc (abfd, reloc_entry, symbol, data, input_section,
			  output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  bfd_boolean relocateable;
  bfd_reloc_status_type ret;
  bfd_vma gp;

  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != (bfd *) NULL)
    relocateable = TRUE;
  else
    {
      relocateable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf64_final_gp (output_bfd, symbol, relocateable, error_message,
			     &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  return _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
					input_section, relocateable,
					data, gp);
}

/* Do a R_MIPS_LITERAL relocation.  */

static bfd_reloc_status_type
mips_elf64_literal_reloc (abfd, reloc_entry, symbol, data, input_section,
			  output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  bfd_boolean relocateable;
  bfd_reloc_status_type ret;
  bfd_vma gp;

  /* If we're relocating, and this is an external symbol, we don't
     want to change anything.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* FIXME: The entries in the .lit8 and .lit4 sections should be merged.  */
  if (output_bfd != (bfd *) NULL)
    relocateable = TRUE;
  else
    {
      relocateable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf64_final_gp (output_bfd, symbol, relocateable, error_message,
			     &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  return _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
					input_section, relocateable,
					data, gp);
}

/* Do a R_MIPS_GPREL32 relocation.  This is a 32 bit value which must
   become the offset from the gp register.  */

static bfd_reloc_status_type
mips_elf64_gprel32_reloc (abfd, reloc_entry, symbol, data, input_section,
			  output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  bfd_boolean relocateable;
  bfd_reloc_status_type ret;
  bfd_vma gp;
  bfd_vma relocation;
  unsigned long val;

  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      *error_message = (char *)
	_("32bits gp relative relocation occurs for an external symbol");
      return bfd_reloc_outofrange;
    }

  if (output_bfd != (bfd *) NULL)
    {
      relocateable = TRUE;
      gp = _bfd_get_gp_value (output_bfd);
    }
  else
    {
      relocateable = FALSE;
      output_bfd = symbol->section->output_section->owner;

      ret = mips_elf64_final_gp (output_bfd, symbol, relocateable,
				 error_message, &gp);
      if (ret != bfd_reloc_ok)
	return ret;
    }

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  if (reloc_entry->howto->src_mask == 0)
    {
      /* This case arises with the 64-bit MIPS ELF ABI.  */
      val = 0;
    }
  else
    val = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);

  /* Set val to the offset into the section or symbol.  */
  val += reloc_entry->addend;

  /* Adjust val for the final section location and GP value.  If we
     are producing relocateable output, we don't want to do this for
     an external symbol.  */
  if (! relocateable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);

  if (relocateable)
    reloc_entry->address += input_section->output_offset;

  return bfd_reloc_ok;
}

/* Do a R_MIPS_SHIFT6 relocation. The MSB of the shift is stored at bit 2,
   the rest is at bits 6-10. The bitpos already got right by the howto.  */

static bfd_reloc_status_type
mips_elf64_shift6_reloc (abfd, reloc_entry, symbol, data, input_section,
			 output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  /* If we're relocating, and this is an external symbol, we don't
     want to change anything.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  reloc_entry->addend = (reloc_entry->addend & 0x00007c0)
			| (reloc_entry->addend & 0x00000800) >> 9;

  return bfd_reloc_continue;
}

/* Handle a mips16 jump.  */

static bfd_reloc_status_type
mips16_jump_reloc (abfd, reloc_entry, symbol, data, input_section,
		   output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* FIXME.  */
  {
    static bfd_boolean warned;

    if (! warned)
      (*_bfd_error_handler)
	(_("Linking mips16 objects into %s format is not supported"),
	 bfd_get_target (input_section->output_section->owner));
    warned = TRUE;
  }

  return bfd_reloc_undefined;
}

/* Handle a mips16 GP relative reloc.  */

static bfd_reloc_status_type
mips16_gprel_reloc (abfd, reloc_entry, symbol, data, input_section,
		    output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  bfd_boolean relocateable;
  bfd_reloc_status_type ret;
  bfd_vma gp;
  unsigned short extend, insn;
  unsigned long final;

  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    relocateable = TRUE;
  else
    {
      relocateable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf64_final_gp (output_bfd, symbol, relocateable, error_message,
			     &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  /* Pick up the mips16 extend instruction and the real instruction.  */
  extend = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address);
  insn = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address + 2);

  /* Stuff the current addend back as a 32 bit value, do the usual
     relocation, and then clean up.  */
  bfd_put_32 (abfd,
	      (bfd_vma) (((extend & 0x1f) << 11)
			 | (extend & 0x7e0)
			 | (insn & 0x1f)),
	      (bfd_byte *) data + reloc_entry->address);

  ret = _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
				       input_section, relocateable, data, gp);

  final = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
  bfd_put_16 (abfd,
	      (bfd_vma) ((extend & 0xf800)
			 | ((final >> 11) & 0x1f)
			 | (final & 0x7e0)),
	      (bfd_byte *) data + reloc_entry->address);
  bfd_put_16 (abfd,
	      (bfd_vma) ((insn & 0xffe0)
			 | (final & 0x1f)),
	      (bfd_byte *) data + reloc_entry->address + 2);

  return ret;
}

/* A mapping from BFD reloc types to MIPS ELF reloc types.  */

struct elf_reloc_map {
  bfd_reloc_code_real_type bfd_val;
  enum elf_mips_reloc_type elf_val;
d1362 1
a1362 1
static const struct elf_reloc_map mips_reloc_map[] =
d1364 1
a1364 1
  { BFD_RELOC_NONE, R_MIPS_NONE },
a1366 1
  /* There is no BFD reloc for R_MIPS_REL32.  */
d1369 2
a1370 1
  { BFD_RELOC_16_PCREL, R_MIPS_PC16 },
d1373 1
a1373 3
  { BFD_RELOC_GPREL16, R_MIPS_GPREL16 },
  { BFD_RELOC_GPREL32, R_MIPS_GPREL32 },
  { BFD_RELOC_MIPS_JMP, R_MIPS_26 },
d1376 1
d1378 1
a1378 5
  { BFD_RELOC_MIPS_SHIFT5, R_MIPS_SHIFT5 },
  { BFD_RELOC_MIPS_SHIFT6, R_MIPS_SHIFT6 },
  { BFD_RELOC_MIPS_GOT_DISP, R_MIPS_GOT_DISP },
  { BFD_RELOC_MIPS_GOT_PAGE, R_MIPS_GOT_PAGE },
  { BFD_RELOC_MIPS_GOT_OFST, R_MIPS_GOT_OFST },
a1380 6
  { BFD_RELOC_MIPS_SUB, R_MIPS_SUB },
  { BFD_RELOC_MIPS_INSERT_A, R_MIPS_INSERT_A },
  { BFD_RELOC_MIPS_INSERT_B, R_MIPS_INSERT_B },
  { BFD_RELOC_MIPS_DELETE, R_MIPS_DELETE },
  { BFD_RELOC_MIPS_HIGHEST, R_MIPS_HIGHEST },
  { BFD_RELOC_MIPS_HIGHER, R_MIPS_HIGHER },
d1383 4
a1386 5
  { BFD_RELOC_MIPS_SCN_DISP, R_MIPS_SCN_DISP },
  { BFD_RELOC_MIPS_REL16, R_MIPS_REL16 },
  /* Use of R_MIPS_ADD_IMMEDIATE and R_MIPS_PJUMP is deprecated.  */
  { BFD_RELOC_MIPS_RELGOT, R_MIPS_RELGOT },
  { BFD_RELOC_MIPS_JALR, R_MIPS_JALR }
d1392 1
a1392 1
bfd_elf64_bfd_reloc_type_lookup (abfd, code)
a1396 3
  /* FIXME: We default to RELA here instead of choosing the right
     relocation variant.  */
  reloc_howto_type *howto_table = mips_elf64_howto_table_rela;
d1398 1
a1398 2
  for (i = 0; i < sizeof (mips_reloc_map) / sizeof (struct elf_reloc_map);
       i++)
d1400 3
a1402 3
      if (mips_reloc_map[i].bfd_val == code)
	return &howto_table[(int) mips_reloc_map[i].elf_val];
    }
d1404 3
a1406 40
  switch (code)
    {
    case BFD_RELOC_MIPS16_JMP:
      return &elf_mips16_jump_howto;
    case BFD_RELOC_MIPS16_GPREL:
      return &elf_mips16_gprel_howto;
    case BFD_RELOC_VTABLE_INHERIT:
      return &elf_mips_gnu_vtinherit_howto;
    case BFD_RELOC_VTABLE_ENTRY:
      return &elf_mips_gnu_vtentry_howto;
    default:
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }
}

/* Given a MIPS Elf_Internal_Rel, fill in an arelent structure.  */

static reloc_howto_type *
mips_elf64_rtype_to_howto (r_type, rela_p)
     unsigned int r_type;
     bfd_boolean rela_p;
{
  switch (r_type)
    {
    case R_MIPS16_26:
      return &elf_mips16_jump_howto;
    case R_MIPS16_GPREL:
      return &elf_mips16_gprel_howto;
    case R_MIPS_GNU_VTINHERIT:
      return &elf_mips_gnu_vtinherit_howto;
    case R_MIPS_GNU_VTENTRY:
      return &elf_mips_gnu_vtentry_howto;
    default:
      BFD_ASSERT (r_type < (unsigned int) R_MIPS_max);
      if (rela_p)
	return &mips_elf64_howto_table_rela[r_type];
      else
	return &mips_elf64_howto_table_rel[r_type];
      break;
a1407 12
}

/* Prevent relocation handling by bfd for MIPS ELF64.  */

static void
mips_elf64_info_to_howto_rel (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *dst ATTRIBUTE_UNUSED;
{
  BFD_ASSERT (0);
}
d1409 1
a1409 7
static void
mips_elf64_info_to_howto_rela (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *dst ATTRIBUTE_UNUSED;
{
  BFD_ASSERT (0);
d1423 1
a1423 11
static long
mips_elf64_get_dynamic_reloc_upper_bound (abfd)
     bfd *abfd;
{
  return _bfd_elf_get_dynamic_reloc_upper_bound (abfd) * 3;
}

/* We must also copy more relocations than the corresponding functions
   in elf.c would, so the two following functions are slightly
   modified from elf.c, that multiply the external relocation count by
   3 to obtain the internal relocation count.  */
d1425 2
a1426 75
static long
mips_elf64_canonicalize_reloc (abfd, section, relptr, symbols)
     bfd *abfd;
     sec_ptr section;
     arelent **relptr;
     asymbol **symbols;
{
  arelent *tblptr;
  unsigned int i;
  struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if (! bed->s->slurp_reloc_table (abfd, section, symbols, FALSE))
    return -1;

  tblptr = section->relocation;
  for (i = 0; i < section->reloc_count * 3; i++)
    *relptr++ = tblptr++;

  *relptr = NULL;

  return section->reloc_count * 3;
}

static long
mips_elf64_canonicalize_dynamic_reloc (abfd, storage, syms)
     bfd *abfd;
     arelent **storage;
     asymbol **syms;
{
  bfd_boolean (*slurp_relocs)
    PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
  asection *s;
  long ret;

  if (elf_dynsymtab (abfd) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
  ret = 0;
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if (elf_section_data (s)->this_hdr.sh_link == elf_dynsymtab (abfd)
	  && (elf_section_data (s)->this_hdr.sh_type == SHT_REL
	      || elf_section_data (s)->this_hdr.sh_type == SHT_RELA))
	{
	  arelent *p;
	  long count, i;

	  if (! (*slurp_relocs) (abfd, s, syms, TRUE))
	    return -1;
	  count = s->_raw_size / elf_section_data (s)->this_hdr.sh_entsize * 3;
	  p = s->relocation;
	  for (i = 0; i < count; i++)
	    *storage++ = p++;
	  ret += count;
	}
    }

  *storage = NULL;

  return ret;
}

/* Read the relocations from one reloc section.  This is mostly copied
   from elfcode.h, except for the changes to expand one external
   relocation to 3 internal ones.  We must unfortunately set
   reloc_count to the number of external relocations, because a lot of
   generic code seems to depend on this.  */

static bfd_boolean
mips_elf64_slurp_one_reloc_table (abfd, asect, rel_hdr, reloc_count,
				  relents, symbols, dynamic)
a1428 3
     Elf_Internal_Shdr *rel_hdr;
     bfd_size_type reloc_count;
     arelent *relents;
d1430 1
a1430 1
     bfd_boolean dynamic;
d1434 1
d1436 2
a1437 1
  bfd_vma i;
d1443 1
a1443 1
    return FALSE;
d1446 1
a1446 2
      || (bfd_bread (allocated, rel_hdr->sh_size, abfd)
	  != rel_hdr->sh_size))
d1451 2
d1457 2
d1464 2
a1465 3
  for (i = 0, relent = relents;
       i < reloc_count;
       i++, native_relocs += entsize)
d1468 1
a1468 1
      bfd_boolean used_sym, used_ssym;
d1476 2
a1477 3
	mips_elf64_swap_reloc_in (abfd,
				  (Elf64_Mips_External_Rel *) native_relocs,
				  &rela);
d1479 11
a1489 1
      /* Each entry represents exactly three actual relocations.  */
d1491 4
a1494 2
      used_sym = FALSE;
      used_ssym = FALSE;
d1514 21
d1563 1
a1563 1
		  used_sym = TRUE;
d1587 1
a1587 1
		  used_ssym = TRUE;
d1599 1
a1599 1
	  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0 || dynamic)
d1612 1
a1612 1
  asect->reloc_count += (relent - relents) / 3;
d1617 1
a1617 1
  return TRUE;
d1622 1
a1622 1
  return FALSE;
d1626 1
a1626 4
   associated with a single data section.  This is copied from
   elfcode.h as well, with changes as small as accounting for 3
   internal relocs per external reloc and resetting reloc_count to
   zero before processing the relocs of a section.  */
d1628 1
a1628 1
static bfd_boolean
d1633 1
a1633 1
     bfd_boolean dynamic;
a1635 9
  Elf_Internal_Shdr *rel_hdr;
  Elf_Internal_Shdr *rel_hdr2;
  bfd_size_type reloc_count;
  bfd_size_type reloc_count2;
  arelent *relents;
  bfd_size_type amt;

  if (asect->relocation != NULL)
    return TRUE;
d1637 1
a1637 1
  if (! dynamic)
d1639 3
a1641 12
      if ((asect->flags & SEC_RELOC) == 0
	  || asect->reloc_count == 0)
	return TRUE;

      rel_hdr = &d->rel_hdr;
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
      rel_hdr2 = d->rel_hdr2;
      reloc_count2 = (rel_hdr2 ? NUM_SHDR_ENTRIES (rel_hdr2) : 0);

      BFD_ASSERT (asect->reloc_count == reloc_count + reloc_count2);
      BFD_ASSERT (asect->rel_filepos == rel_hdr->sh_offset
		  || (rel_hdr2 && asect->rel_filepos == rel_hdr2->sh_offset));
d1643 4
a1646 15
    }
  else
    {
      /* Note that ASECT->RELOC_COUNT tends not to be accurate in this
	 case because relocations against this section may use the
	 dynamic symbol table, and in that case bfd_section_from_shdr
	 in elf.c does not update the RELOC_COUNT.  */
      if (asect->_raw_size == 0)
	return TRUE;

      rel_hdr = &d->this_hdr;
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
      rel_hdr2 = NULL;
      reloc_count2 = 0;
    }
d1649 5
a1653 4
  amt = (reloc_count + reloc_count2) * 3 * sizeof (arelent);
  relents = (arelent *) bfd_alloc (abfd, amt);
  if (relents == NULL)
    return FALSE;
d1658 2
a1659 5
  if (! mips_elf64_slurp_one_reloc_table (abfd, asect,
					  rel_hdr, reloc_count,
					  relents,
					  symbols, dynamic))
    return FALSE;
d1662 3
a1664 5
      if (! mips_elf64_slurp_one_reloc_table (abfd, asect,
					      rel_hdr2, reloc_count2,
					      relents + reloc_count * 3,
					      symbols, dynamic))
	return FALSE;
d1667 1
a1667 2
  asect->relocation = relents;
  return TRUE;
d1678 4
a1681 3
  bfd_boolean *failedp = (bfd_boolean *) data;
  int count;
  Elf_Internal_Shdr *rel_hdr;
d1683 2
d1729 1
a1729 81
  rel_hdr = &elf_section_data (sec)->rel_hdr;

  /* Do the actual relocation.  */

  if (rel_hdr->sh_entsize == sizeof(Elf64_Mips_External_Rel))
    mips_elf64_write_rel (abfd, sec, rel_hdr, &count, data);
  else if (rel_hdr->sh_entsize == sizeof(Elf64_Mips_External_Rela))
    mips_elf64_write_rela (abfd, sec, rel_hdr, &count, data);
  else
    BFD_ASSERT (0);
}

static void
mips_elf64_write_rel (abfd, sec, rel_hdr, count, data)
     bfd *abfd;
     asection *sec;
     Elf_Internal_Shdr *rel_hdr;
     int *count;
     PTR data;
{
  bfd_boolean *failedp = (bfd_boolean *) data;
  Elf64_Mips_External_Rel *ext_rel;
  unsigned int idx;
  asymbol *last_sym = 0;
  int last_sym_idx = 0;

  rel_hdr->sh_size = (bfd_vma)(rel_hdr->sh_entsize * *count);
  rel_hdr->contents = (PTR) bfd_alloc (abfd, rel_hdr->sh_size);
  if (rel_hdr->contents == NULL)
    {
      *failedp = TRUE;
      return;
    }

  ext_rel = (Elf64_Mips_External_Rel *) rel_hdr->contents;
  for (idx = 0; idx < sec->reloc_count; idx++, ext_rel++)
    {
      arelent *ptr;
      Elf64_Mips_Internal_Rela int_rel;
      asymbol *sym;
      int n;
      unsigned int i;

      ptr = sec->orelocation[idx];

      /* The address of an ELF reloc is section relative for an object
	 file, and absolute for an executable file or shared library.
	 The address of a BFD reloc is always section relative.  */
      if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
	int_rel.r_offset = ptr->address;
      else
	int_rel.r_offset = ptr->address + sec->vma;

      sym = *ptr->sym_ptr_ptr;
      if (sym == last_sym)
	n = last_sym_idx;
      else
	{
	  last_sym = sym;
	  n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
	  if (n < 0)
	    {
	      *failedp = TRUE;
	      return;
	    }
	  last_sym_idx = n;
	}

      int_rel.r_sym = n;
      int_rel.r_ssym = RSS_UNDEF;

      if ((*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
	  && ! _bfd_elf_validate_reloc (abfd, ptr))
	{
	  *failedp = TRUE;
	  return;
	}

      int_rel.r_type = ptr->howto->type;
      int_rel.r_type2 = (int) R_MIPS_NONE;
      int_rel.r_type3 = (int) R_MIPS_NONE;
d1731 1
a1731 44
      for (i = 0; i < 2; i++)
	{
	  arelent *r;

	  if (idx + 1 >= sec->reloc_count)
	    break;
	  r = sec->orelocation[idx + 1];
	  if (r->address != ptr->address
	      || ! bfd_is_abs_section ((*r->sym_ptr_ptr)->section)
	      || (*r->sym_ptr_ptr)->value != 0)
	    break;

	  /* We can merge the reloc at IDX + 1 with the reloc at IDX.  */

	  if (i == 0)
	    int_rel.r_type2 = r->howto->type;
	  else
	    int_rel.r_type3 = r->howto->type;

	  ++idx;
	}

      mips_elf64_swap_reloc_out (abfd, &int_rel, ext_rel);
    }

  BFD_ASSERT (ext_rel - (Elf64_Mips_External_Rel *) rel_hdr->contents
	      == *count);
}

static void
mips_elf64_write_rela (abfd, sec, rela_hdr, count, data)
     bfd *abfd;
     asection *sec;
     Elf_Internal_Shdr *rela_hdr;
     int *count;
     PTR data;
{
  bfd_boolean *failedp = (bfd_boolean *) data;
  Elf64_Mips_External_Rela *ext_rela;
  unsigned int idx;
  asymbol *last_sym = 0;
  int last_sym_idx = 0;

  rela_hdr->sh_size = (bfd_vma)(rela_hdr->sh_entsize * *count);
d1735 1
a1735 1
      *failedp = TRUE;
d1767 1
a1767 1
	      *failedp = TRUE;
d1774 1
d1776 1
d1782 1
a1782 1
	  *failedp = TRUE;
d1816 1
a1816 1
	      == *count);
d1819 4
a1822 1
/* Set the right machine number for a MIPS ELF file.  */
d1824 2
a1825 2
static bfd_boolean
mips_elf64_object_p (abfd)
d1828 19
a1846 1
  unsigned long mach;
d1848 12
a1859 10
  /* Irix 6 is broken.  Object file symbol tables are not always
     sorted correctly such that local symbols precede global symbols,
     and the sh_info field in the symbol table is not always right.  */
  if (elf64_mips_irix_compat (abfd) != ict_none)
    elf_bad_symtab (abfd) = TRUE;

  mach = _bfd_elf_mips_mach (elf_elfheader (abfd)->e_flags);
  bfd_default_set_arch_mach (abfd, bfd_arch_mips, mach);
  return TRUE;
}
d1861 5
a1865 21
/* Depending on the target vector we generate some version of Irix
   executables or "normal" MIPS ELF ABI executables.  */
static irix_compat_t
elf64_mips_irix_compat (abfd)
     bfd *abfd;
{
  if ((abfd->xvec == &bfd_elf64_bigmips_vec)
      || (abfd->xvec == &bfd_elf64_littlemips_vec))
    return ict_irix6;
  else
    return ict_none;
}

/* Support for core dump NOTE sections.  */
static bfd_boolean
elf64_mips_grok_prstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
{
  int offset;
  unsigned int raw_size;
d1867 1
a1867 1
  switch (note->descsz)
d1869 7
a1875 2
      default:
	return FALSE;
d1877 2
a1878 3
      case 480:		/* Linux/MIPS - N64 kernel */
	/* pr_cursig */
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
d1880 5
a1884 2
	/* pr_pid */
	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 32);
d1886 11
a1896 3
	/* pr_reg */
	offset = 112;
	raw_size = 360;
d1898 6
a1903 1
	break;
d1905 86
d1992 14
a2005 4
  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  raw_size, note->descpos + offset);
}
d2007 2
a2008 6
static bfd_boolean
elf64_mips_grok_psinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
{
  switch (note->descsz)
d2010 1
a2010 2
      default:
	return FALSE;
d2012 2
a2013 5
      case 136:		/* Linux/MIPS - N64 kernel elf_prpsinfo */
	elf_tdata (abfd)->core_program
	 = _bfd_elfcore_strndup (abfd, note->descdata + 40, 16);
	elf_tdata (abfd)->core_command
	 = _bfd_elfcore_strndup (abfd, note->descdata + 56, 80);
d2016 8
a2023 11
  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core_command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }
d2025 1
a2025 1
  return TRUE;
a2093 1
  bfd_elf64_swap_symbol_in,
d2105 4
a2111 3
/* The SVR4 MIPS ABI says that this should be 0x10000, but Irix 5 uses
   a value of 0x1000, and we are compatible.
   FIXME: How does this affect NewABI?  */
d2114 5
a2118 8
#define elf_backend_collect		TRUE
#define elf_backend_type_change_ok	TRUE
#define elf_backend_can_gc_sections	TRUE
#define elf_info_to_howto		mips_elf64_info_to_howto_rela
#define elf_info_to_howto_rel		mips_elf64_info_to_howto_rel
#define elf_backend_object_p		mips_elf64_object_p
#define elf_backend_symbol_processing	_bfd_mips_elf_symbol_processing
#define elf_backend_section_processing	_bfd_mips_elf_section_processing
d2122 9
a2130 1
				_bfd_mips_elf_section_from_bfd_section
a2131 2
#define elf_backend_link_output_symbol_hook \
				_bfd_mips_elf_link_output_symbol_hook
d2133 1
a2133 1
				_bfd_mips_elf_create_dynamic_sections
d2136 1
a2136 1
				_bfd_mips_elf_adjust_dynamic_symbol
d2138 1
a2138 1
				_bfd_mips_elf_always_size_sections
d2140 1
a2140 1
				_bfd_mips_elf_size_dynamic_sections
d2142 2
d2145 1
a2145 1
				_bfd_mips_elf_finish_dynamic_symbol
d2147 1
a2147 6
				_bfd_mips_elf_finish_dynamic_sections
#define elf_backend_final_write_processing \
				_bfd_mips_elf_final_write_processing
#define elf_backend_additional_program_headers \
				_bfd_mips_elf_additional_program_headers
#define elf_backend_modify_segment_map	_bfd_mips_elf_modify_segment_map
d2150 1
a2150 12
#define elf_backend_hide_symbol		_bfd_mips_elf_hide_symbol
#define elf_backend_ignore_discarded_relocs \
					_bfd_mips_elf_ignore_discarded_relocs
#define elf_backend_mips_irix_compat	elf64_mips_irix_compat
#define elf_backend_mips_rtype_to_howto	mips_elf64_rtype_to_howto
#define elf_backend_ecoff_debug_swap	&mips_elf64_ecoff_debug_swap
#define elf_backend_size_info		mips_elf64_size_info

#define elf_backend_grok_prstatus	elf64_mips_grok_prstatus
#define elf_backend_grok_psinfo		elf64_mips_grok_psinfo

#define elf_backend_got_header_size	(4 * MIPS_RESERVED_GOTNO)
d2152 1
a2152 8

/* MIPS ELF64 can use a mixture of REL and RELA, but some Relocations
   work better/work only in RELA, so we default to this.  */
#define elf_backend_may_use_rel_p	1
#define elf_backend_may_use_rela_p	1
#define elf_backend_default_use_rela_p	1

#define elf_backend_write_section	_bfd_mips_elf_write_section
a2157 1
#define bfd_elf64_new_section_hook	_bfd_mips_elf_new_section_hook
a2158 2
#define bfd_elf64_bfd_get_relocated_section_contents \
				_bfd_elf_mips_get_relocated_section_contents
d2160 1
a2160 1
				_bfd_mips_elf_link_hash_table_create
d2162 2
d2165 1
a2165 1
				_bfd_mips_elf_merge_private_bfd_data
d2168 1
a2168 1
				_bfd_mips_elf_print_private_bfd_data
d2171 1
a2171 6
#define bfd_elf64_canonicalize_reloc mips_elf64_canonicalize_reloc
#define bfd_elf64_get_dynamic_reloc_upper_bound mips_elf64_get_dynamic_reloc_upper_bound
#define bfd_elf64_canonicalize_dynamic_reloc mips_elf64_canonicalize_dynamic_reloc
#define bfd_elf64_bfd_relax_section     _bfd_mips_relax_section

/* MIPS ELF64 archive functions.  */
d2173 1
a2173 4
extern bfd_boolean bfd_elf64_archive_slurp_armap
  PARAMS ((bfd *));
extern bfd_boolean bfd_elf64_archive_write_armap
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
d2175 1
a2175 1
			_bfd_archive_coff_slurp_extended_name_table
d2177 1
a2177 1
			_bfd_archive_coff_construct_extended_name_table
d2179 2
a2180 1
			_bfd_archive_coff_truncate_arname
d2183 1
a2183 1
			_bfd_archive_coff_openr_next_archived_file
d2185 1
a2185 1
			_bfd_archive_coff_get_elt_at_index
d2187 1
a2187 1
			_bfd_archive_coff_generic_stat_arch_elt
d2189 1
a2189 1
			_bfd_archive_coff_update_armap_timestamp
d2191 1
a2191 5
/* The SGI style (n)64 NewABI.  */
#define TARGET_LITTLE_SYM		bfd_elf64_littlemips_vec
#define TARGET_LITTLE_NAME		"elf64-littlemips"
#define TARGET_BIG_SYM			bfd_elf64_bigmips_vec
#define TARGET_BIG_NAME			"elf64-bigmips"
d2193 1
a2193 1
#include "elf64-target.h"
d2195 1
a2195 1
#define INCLUDED_TARGET_FILE            /* More a type of flag.  */
a2196 1
/* The SYSV-style 'traditional' (n)64 NewABI.  */
d2207 1
a2207 1
/* Include the target file again for this target.  */
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d65 2
a66 1
  (bfd *, const Elf64_Mips_External_Rel *, Elf64_Mips_Internal_Rela *);
d68 2
a69 1
  (bfd *, const Elf64_Mips_External_Rela *, Elf64_Mips_Internal_Rela *);
d71 2
a72 1
  (bfd *, const Elf64_Mips_Internal_Rela *, Elf64_Mips_External_Rel *);
d74 2
a75 1
  (bfd *, const Elf64_Mips_Internal_Rela *, Elf64_Mips_External_Rela *);
d77 1
a77 1
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
d79 1
a79 1
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
d81 1
a81 1
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
d83 1
a83 1
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
d85 1
a85 1
  (bfd *, bfd_reloc_code_real_type);
d87 1
a87 1
  (unsigned int, bfd_boolean);
d89 1
a89 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d91 1
a91 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d93 1
a93 1
  (bfd *, asection *);
d95 2
a96 3
  (bfd *, asection *, arelent **, asymbol **);
static long mips_elf64_get_dynamic_reloc_upper_bound
  (bfd *);
d98 1
a98 1
  (bfd *, arelent **, asymbol **);
d100 2
a101 2
  (bfd *, asection *, Elf_Internal_Shdr *, bfd_size_type, arelent *,
   asymbol **, bfd_boolean);
d103 1
a103 1
  (bfd *, asection *, asymbol **, bfd_boolean);
d105 1
a105 1
  (bfd *, asection *, void *);
d107 1
a107 1
  (bfd *, asection *, Elf_Internal_Shdr *, int *, void *);
d109 3
a111 1
  (bfd *, asection *, Elf_Internal_Shdr *, int *, void *);
d113 1
a113 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d115 1
a115 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d117 1
a117 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d119 3
a121 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d123 1
a123 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d125 1
a125 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d127 1
a127 1
  (bfd *, bfd_vma *);
d129 1
a129 1
  (bfd *, asymbol *, bfd_boolean, char **, bfd_vma *);
d131 1
a131 1
  (bfd *);
d133 1
a133 1
  (bfd *);
d135 1
a135 1
  (bfd *, Elf_Internal_Note *);
d137 1
a137 1
  (bfd *, Elf_Internal_Note *);
d161 1
a161 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d176 1
a176 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d191 1
a191 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d206 1
a206 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d224 1
a224 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d236 1
a236 1
	 16,			/* rightshift */
d242 1
a242 1
	 _bfd_mips_elf_hi16_reloc, /* special_function */
d257 1
a257 1
	 _bfd_mips_elf_lo16_reloc, /* special_function */
d302 1
a302 1
	 _bfd_mips_elf_got16_reloc, /* special_function */
d317 1
a317 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d332 1
a332 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d366 1
a366 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d396 1
a396 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d411 1
a411 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d426 1
a426 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d441 1
a441 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d456 1
a456 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d471 1
a471 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d478 1
a478 1
  /* 64 bit subtraction.  */
d486 1
a486 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d502 1
a502 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d519 1
a519 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d535 1
a535 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d559 1
a559 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d574 1
a574 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d589 1
a589 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d603 1
a603 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d623 1
a623 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d639 1
a639 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d659 1
a659 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d674 1
a674 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d689 1
a689 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d704 1
a704 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d722 1
a722 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d737 1
a737 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d752 1
a752 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d797 1
a797 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d812 1
a812 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d827 1
a827 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d861 1
a861 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d891 1
a891 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d906 1
a906 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d921 1
a921 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d936 1
a936 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d951 1
a951 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d966 1
a966 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d973 1
a973 1
  /* 64 bit subtraction.  */
d981 1
a981 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d997 1
a997 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1014 1
a1014 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1030 1
a1030 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1045 1
a1045 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d1060 1
a1060 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d1075 1
a1075 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1090 1
a1090 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1105 1
a1105 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1119 1
a1119 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1139 1
a1139 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1155 1
a1155 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
a1229 32
/* 16 bit offset for pc-relative branches.  */
static reloc_howto_type elf_mips_gnu_rel16_s2 =
  HOWTO (R_MIPS_GNU_REL16_S2,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GNU_REL16_S2",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

/* 16 bit offset for pc-relative branches.  */
static reloc_howto_type elf_mips_gnu_rela16_s2 =
  HOWTO (R_MIPS_GNU_REL16_S2,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GNU_REL16_S2",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

d1233 4
a1236 2
mips_elf64_swap_reloc_in (bfd *abfd, const Elf64_Mips_External_Rel *src,
			  Elf64_Mips_Internal_Rela *dst)
d1250 4
a1253 2
mips_elf64_swap_reloca_in (bfd *abfd, const Elf64_Mips_External_Rela *src,
			   Elf64_Mips_Internal_Rela *dst)
d1267 4
a1270 2
mips_elf64_swap_reloc_out (bfd *abfd, const Elf64_Mips_Internal_Rela *src,
			   Elf64_Mips_External_Rel *dst)
d1283 4
a1286 2
mips_elf64_swap_reloca_out (bfd *abfd, const Elf64_Mips_Internal_Rela *src,
			    Elf64_Mips_External_Rela *dst)
d1300 4
a1303 2
mips_elf64_be_swap_reloc_in (bfd *abfd, const bfd_byte *src,
			     Elf_Internal_Rela *dst)
d1325 4
a1328 2
mips_elf64_be_swap_reloca_in (bfd *abfd, const bfd_byte *src,
			      Elf_Internal_Rela *dst)
d1350 4
a1353 2
mips_elf64_be_swap_reloc_out (bfd *abfd, const Elf_Internal_Rela *src,
			      bfd_byte *dst)
d1376 4
a1379 2
mips_elf64_be_swap_reloca_out (bfd *abfd, const Elf_Internal_Rela *src,
			       bfd_byte *dst)
d1401 68
d1473 3
a1475 1
mips_elf64_assign_gp (bfd *output_bfd, bfd_vma *pgp)
d1491 1
a1491 1
  if (sym == NULL)
d1524 1
a1524 1
   external symbol if we are producing relocatable output.  */
d1527 6
a1532 2
mips_elf64_final_gp (bfd *output_bfd, asymbol *symbol, bfd_boolean relocatable,
		     char **error_message, bfd_vma *pgp)
d1535 1
a1535 1
      && ! relocatable)
d1543 1
a1543 1
      && (! relocatable
d1546 1
a1546 1
      if (relocatable)
d1567 9
a1575 3
mips_elf64_gprel16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			  void *data, asection *input_section, bfd *output_bfd,
			  char **error_message)
d1577 1
a1577 1
  bfd_boolean relocatable;
d1581 5
a1585 3
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
d1587 2
a1588 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1594 2
a1595 2
  if (output_bfd != NULL)
    relocatable = TRUE;
d1598 1
a1598 1
      relocatable = FALSE;
d1602 1
a1602 1
  ret = mips_elf64_final_gp (output_bfd, symbol, relocatable, error_message,
d1608 1
a1608 1
					input_section, relocatable,
d1615 9
a1623 3
mips_elf64_literal_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			  void *data, asection *input_section, bfd *output_bfd,
			  char **error_message)
d1625 1
a1625 1
  bfd_boolean relocatable;
d1631 1
a1631 1
  if (output_bfd != NULL
d1633 2
a1634 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1641 2
a1642 2
  if (output_bfd != NULL)
    relocatable = TRUE;
d1645 1
a1645 1
      relocatable = FALSE;
d1649 1
a1649 1
  ret = mips_elf64_final_gp (output_bfd, symbol, relocatable, error_message,
d1655 1
a1655 1
					input_section, relocatable,
d1663 9
a1671 3
mips_elf64_gprel32_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			  void *data, asection *input_section, bfd *output_bfd,
			  char **error_message)
d1673 1
a1673 1
  bfd_boolean relocatable;
d1677 1
a1677 1
  bfd_vma val;
d1679 5
a1683 3
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
d1685 1
a1685 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1692 5
a1696 2
  if (output_bfd != NULL)
    relocatable = TRUE;
d1699 1
a1699 1
      relocatable = FALSE;
d1701 5
a1707 5
    ret = mips_elf64_final_gp (output_bfd, symbol, relocatable,
			       error_message, &gp);
    if (ret != bfd_reloc_ok)
      return ret;

d1719 8
d1728 1
a1728 4
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    val += bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d1731 1
a1731 1
     are producing relocatable output, we don't want to do this for
d1733 1
a1733 1
  if (! relocatable
d1737 1
a1737 4
  if (reloc_entry->howto->partial_inplace)
    bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);
  else
    reloc_entry->addend = val;
d1739 1
a1739 1
  if (relocatable)
d1749 9
a1757 3
mips_elf64_shift6_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			 void *data, asection *input_section, bfd *output_bfd,
			 char **error_message)
d1759 6
a1764 1
  if (reloc_entry->howto->partial_inplace)
d1766 2
a1767 2
      reloc_entry->addend = ((reloc_entry->addend & 0x00007c0)
			     | (reloc_entry->addend & 0x00000800) >> 9);
d1770 4
a1773 3
  return _bfd_mips_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				      input_section, output_bfd,
				      error_message);
d1779 9
a1787 4
mips16_jump_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		   asymbol *symbol, void *data ATTRIBUTE_UNUSED,
		   asection *input_section, bfd *output_bfd,
		   char **error_message ATTRIBUTE_UNUSED)
d1789 1
a1789 1
  if (output_bfd != NULL
d1815 9
a1823 3
mips16_gprel_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		    void *data, asection *input_section, bfd *output_bfd,
		    char **error_message)
d1825 1
a1825 1
  bfd_boolean relocatable;
d1828 2
a1829 4
  unsigned short extend = 0;
  unsigned short insn = 0;
  bfd_signed_vma val;
  bfd_vma relocation;
d1832 3
a1834 1
     addend, we don't want to change anything.  */
d1837 1
a1837 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1844 1
a1844 1
    relocatable = TRUE;
d1847 1
a1847 1
      relocatable = FALSE;
d1851 1
a1851 1
  ret = mips_elf64_final_gp (output_bfd, symbol, relocatable, error_message,
d1859 25
a1883 4
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;
d1885 1
a1885 41
  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  /* Set val to the offset into the section or symbol.  */
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    {
      /* Pick up the mips16 extend instruction and the real instruction.  */
      extend = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address);
      insn = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address + 2);
      val += ((extend & 0x1f) << 11) | (extend & 0x7e0) | (insn & 0x1f);
    }

  _bfd_mips_elf_sign_extend(val, 16);

  /* Adjust val for the final section location and GP value.  If we
     are producing relocatable output, we don't want to do this for
     an external symbol.  */
  if (! relocatable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  if (reloc_entry->howto->partial_inplace)
    {
      bfd_put_16 (abfd,
		  (extend & 0xf800) | ((val >> 11) & 0x1f) | (val & 0x7e0),
		  (bfd_byte *) data + reloc_entry->address);
      bfd_put_16 (abfd,
		  (insn & 0xffe0) | (val & 0x1f),
		  (bfd_byte *) data + reloc_entry->address + 2);
    }
  else
    reloc_entry->addend = val;

  if (relocatable)
    reloc_entry->address += input_section->output_offset;
  else if (((val & ~0xffff) != ~0xffff) && ((val & ~0xffff) != 0))
    return bfd_reloc_overflow;

  return bfd_reloc_ok;
d1937 3
a1939 2
bfd_elf64_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				 bfd_reloc_code_real_type code)
a1962 2
    case BFD_RELOC_16_PCREL_S2:
      return &elf_mips_gnu_rela16_s2;
d1972 3
a1974 1
mips_elf64_rtype_to_howto (unsigned int r_type, bfd_boolean rela_p)
a1985 5
    case R_MIPS_GNU_REL16_S2:
      if (rela_p)
	return &elf_mips_gnu_rela16_s2;
      else
	return &elf_mips_gnu_rel16_s2;
d1999 4
a2002 3
mips_elf64_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
			      arelent *cache_ptr ATTRIBUTE_UNUSED,
			      Elf_Internal_Rela *dst ATTRIBUTE_UNUSED)
d2008 4
a2011 3
mips_elf64_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
			       arelent *cache_ptr ATTRIBUTE_UNUSED,
			       Elf_Internal_Rela *dst ATTRIBUTE_UNUSED)
d2020 3
a2022 1
mips_elf64_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
d2028 2
a2029 1
mips_elf64_get_dynamic_reloc_upper_bound (bfd *abfd)
d2040 5
a2044 2
mips_elf64_canonicalize_reloc (bfd *abfd, sec_ptr section,
			       arelent **relptr, asymbol **symbols)
d2048 1
a2048 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d2063 4
a2066 2
mips_elf64_canonicalize_dynamic_reloc (bfd *abfd, arelent **storage,
				       asymbol **syms)
d2068 2
a2069 1
  bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
d2112 9
a2120 5
mips_elf64_slurp_one_reloc_table (bfd *abfd, asection *asect,
				  Elf_Internal_Shdr *rel_hdr,
				  bfd_size_type reloc_count,
				  arelent *relents, asymbol **symbols,
				  bfd_boolean dynamic)
d2122 1
a2122 1
  void *allocated;
d2127 1
a2127 1
  bfd_boolean rela_p;
d2129 1
a2129 1
  allocated = bfd_malloc (rel_hdr->sh_size);
d2138 1
a2138 1
  native_relocs = allocated;
d2145 1
a2145 1
    rela_p = FALSE;
d2147 1
a2147 1
    rela_p = TRUE;
d2260 1
a2260 1
	  relent->howto = mips_elf64_rtype_to_howto (type, rela_p);
d2286 5
a2290 2
mips_elf64_slurp_reloc_table (bfd *abfd, asection *asect,
			      asymbol **symbols, bfd_boolean dynamic)
d2336 1
a2336 1
  relents = bfd_alloc (abfd, amt);
d2364 4
a2367 1
mips_elf64_write_relocs (bfd *abfd, asection *sec, void *data)
d2369 1
a2369 1
  bfd_boolean *failedp = data;
d2430 6
a2435 3
mips_elf64_write_rel (bfd *abfd, asection *sec,
		      Elf_Internal_Shdr *rel_hdr,
		      int *count, void *data)
d2437 1
a2437 1
  bfd_boolean *failedp = data;
d2443 2
a2444 2
  rel_hdr->sh_size = rel_hdr->sh_entsize * *count;
  rel_hdr->contents = bfd_alloc (abfd, rel_hdr->sh_size);
d2529 6
a2534 3
mips_elf64_write_rela (bfd *abfd, asection *sec,
		       Elf_Internal_Shdr *rela_hdr,
		       int *count, void *data)
d2536 1
a2536 1
  bfd_boolean *failedp = data;
d2542 2
a2543 2
  rela_hdr->sh_size = rela_hdr->sh_entsize * *count;
  rela_hdr->contents = bfd_alloc (abfd, rela_hdr->sh_size);
d2631 2
a2632 1
mips_elf64_object_p (bfd *abfd)
d2650 2
a2651 1
elf64_mips_irix_compat (bfd *abfd)
d2662 3
a2664 1
elf64_mips_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
d2694 3
a2696 1
elf64_mips_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
d2785 1
a2785 1
  3,		/* log_file_align */
d2806 5
a2846 2
#define elf_backend_copy_indirect_symbol \
					_bfd_mips_elf_copy_indirect_symbol
d2859 1
d2895 1
a2895 1
  (bfd *);
d2897 1
a2897 1
  (bfd *, unsigned int, struct orl *, unsigned int, int);
d2920 1
a2920 4
/* The SVR4 MIPS ABI says that this should be 0x10000, but Irix 5 uses
   a value of 0x1000, and we are compatible.
   FIXME: How does this affect NewABI?  */
#define ELF_MAXPAGESIZE			0x1000
d2922 1
a2922 1
#include "elf64-target.h"
a2929 2
#undef ELF_MAXPAGESIZE

a2933 5

/* The SVR4 MIPS ABI says that this should be 0x10000, and Linux uses
   page sizes of up to that limit, so we need to respect it.  */
#define ELF_MAXPAGESIZE			0x10000
#define elf64_bed			elf64_tradbed
@


