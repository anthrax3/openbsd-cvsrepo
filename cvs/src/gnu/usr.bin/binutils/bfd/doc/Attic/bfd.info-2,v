head	1.2;
access;
symbols
	BINUTILS_2_15:1.1.1.3
	BINUTILS-2_10_1:1.1.1.2
	FSF:1.1.1
	OPENBSD_2_7:1.1.1.1.0.14
	OPENBSD_2_7_BASE:1.1.1.1
	new-binutils:1.1.1.1.0.12
	OPENBSD_2_6:1.1.1.1.0.10
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.8
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.6
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.4
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.2
	OPENBSD_2_2_BASE:1.1.1.1
	BINUTILS-2_8_1:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2000.09.12.22.24.35;	author espie;	state dead;
branches;
next	1.1;

1.1
date	97.05.29.09.20.59;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.29.09.20.59;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.06.09.22.07.00;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.11.02.20.22.36;	author miod;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Resolve other problems that dumb cvs can't find out by itself.

(trivial part done, `interesting' patches remain)
@
text
@This is Info file bfd.info, produced by Makeinfo-1.64 from the input
file ./bfd.texinfo.

START-INFO-DIR-ENTRY
* Bfd: (bfd).                   The Binary File Descriptor library.
END-INFO-DIR-ENTRY

   This file documents the BFD library.

   Copyright (C) 1991 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, subject to the
terms of the GNU General Public License, which includes the provision
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: bfd.info,  Node: section prototypes,  Prev: typedef asection,  Up: Sections

Section prototypes
------------------

   These are the functions exported by the section handling part of BFD.
`bfd_get_section_by_name'
.........................

*Synopsis*
     asection *bfd_get_section_by_name(bfd *abfd, CONST char *name);
   *Description*
Run through ABFD and return the one of the `asection's whose name
matches NAME, otherwise `NULL'.  *Note Sections::, for more information.

   This should only be used in special cases; the normal way to process
all sections of a given name is to use `bfd_map_over_sections' and
`strcmp' on the name (or better yet, base it on the section flags or
something else) for each section.
`bfd_make_section_old_way'
..........................

*Synopsis*
     asection *bfd_make_section_old_way(bfd *abfd, CONST char *name);
   *Description*
Create a new empty section called NAME and attach it to the end of the
chain of sections for the BFD ABFD. An attempt to create a section with
a name which is already in use returns its pointer without changing the
section chain.

   It has the funny name since this is the way it used to be before it
was rewritten....

   Possible errors are:
   * `bfd_error_invalid_operation' - If output has already started for
     this BFD.

   * `bfd_error_no_memory' - If memory allocation fails.
`bfd_make_section_anyway'
.........................

*Synopsis*
     asection *bfd_make_section_anyway(bfd *abfd, CONST char *name);
   *Description*
Create a new empty section called NAME and attach it to the end of the
chain of sections for ABFD.  Create a new section even if there is
already a section with that name.

   Return `NULL' and set `bfd_error' on error; possible errors are:
   * `bfd_error_invalid_operation' - If output has already started for
     ABFD.

   * `bfd_error_no_memory' - If memory allocation fails.
`bfd_make_section'
..................

*Synopsis*
     asection *bfd_make_section(bfd *, CONST char *name);
   *Description*
Like `bfd_make_section_anyway', but return `NULL' (without calling
bfd_set_error ()) without changing the section chain if there is
already a section named NAME.  If there is an error, return `NULL' and
set `bfd_error'.
`bfd_set_section_flags'
.......................

*Synopsis*
     boolean bfd_set_section_flags(bfd *abfd, asection *sec, flagword flags);
   *Description*
Set the attributes of the section SEC in the BFD ABFD to the value
FLAGS. Return `true' on success, `false' on error. Possible error
returns are:

   * `bfd_error_invalid_operation' - The section cannot have one or
     more of the attributes requested. For example, a .bss section in
     `a.out' may not have the `SEC_HAS_CONTENTS' field set.
`bfd_map_over_sections'
.......................

*Synopsis*
     void bfd_map_over_sections(bfd *abfd,
         void (*func)(bfd *abfd,
         asection *sect,
         PTR obj),
         PTR obj);
   *Description*
Call the provided function FUNC for each section attached to the BFD
ABFD, passing OBJ as an argument. The function will be called as if by

     	func(abfd, the_section, obj);

   This is the prefered method for iterating over sections; an
alternative would be to use a loop:

     	   section *p;
     	   for (p = abfd->sections; p != NULL; p = p->next)
     	      func(abfd, p, ...)

`bfd_set_section_size'
......................

*Synopsis*
     boolean bfd_set_section_size(bfd *abfd, asection *sec, bfd_size_type val);
   *Description*
Set SEC to the size VAL. If the operation is ok, then `true' is
returned, else `false'.

   Possible error returns:
   * `bfd_error_invalid_operation' - Writing has started to the BFD, so
     setting the size is invalid.
`bfd_set_section_contents'
..........................

*Synopsis*
     boolean bfd_set_section_contents
        (bfd *abfd,
         asection *section,
         PTR data,
         file_ptr offset,
         bfd_size_type count);
   *Description*
Sets the contents of the section SECTION in BFD ABFD to the data
starting in memory at DATA. The data is written to the output section
starting at offset OFFSET for COUNT bytes.

   Normally `true' is returned, else `false'. Possible error returns
are:
   * `bfd_error_no_contents' - The output section does not have the
     `SEC_HAS_CONTENTS' attribute, so nothing can be written to it.

   * and some more too This routine is front end to the back end
function `_bfd_set_section_contents'.
`bfd_get_section_contents'
..........................

*Synopsis*
     boolean bfd_get_section_contents
        (bfd *abfd, asection *section, PTR location,
         file_ptr offset, bfd_size_type count);
   *Description*
Read data from SECTION in BFD ABFD into memory starting at LOCATION.
The data is read at an offset of OFFSET from the start of the input
section, and is read for COUNT bytes.

   If the contents of a constructor with the `SEC_CONSTRUCTOR' flag set
are requested or if the section does not have the `SEC_HAS_CONTENTS'
flag set, then the LOCATION is filled with zeroes. If no errors occur,
`true' is returned, else `false'.
`bfd_copy_private_section_data'
...............................

*Synopsis*
     boolean bfd_copy_private_section_data(bfd *ibfd, asection *isec, bfd *obfd, asection *osec);
   *Description*
Copy private section information from ISEC in the BFD IBFD to the
section OSEC in the BFD OBFD.  Return `true' on success, `false' on
error.  Possible error returns are:

   * `bfd_error_no_memory' - Not enough memory exists to create private
     data for OSEC.
     #define bfd_copy_private_section_data(ibfd, isection, obfd, osection) \
          BFD_SEND (obfd, _bfd_copy_private_section_data, \
     		(ibfd, isection, obfd, osection))


File: bfd.info,  Node: Symbols,  Next: Archives,  Prev: Sections,  Up: BFD front end

Symbols
=======

BFD tries to maintain as much symbol information as it can when it
moves information from file to file. BFD passes information to
applications though the `asymbol' structure. When the application
requests the symbol table, BFD reads the table in the native form and
translates parts of it into the internal format. To maintain more than
the information passed to applications, some targets keep some
information "behind the scenes" in a structure only the particular back
end knows about. For example, the coff back end keeps the original
symbol table structure as well as the canonical structure when a BFD is
read in. On output, the coff back end can reconstruct the output symbol
table so that no information is lost, even information unique to coff
which BFD doesn't know or understand. If a coff symbol table were read,
but were written through an a.out back end, all the coff specific
information would be lost. The symbol table of a BFD is not necessarily
read in until a canonicalize request is made. Then the BFD back end
fills in a table provided by the application with pointers to the
canonical information.  To output symbols, the application provides BFD
with a table of pointers to pointers to `asymbol's. This allows
applications like the linker to output a symbol as it was read, since
the "behind the scenes" information will be still available.

* Menu:

* Reading Symbols::
* Writing Symbols::
* Mini Symbols::
* typedef asymbol::
* symbol handling functions::


File: bfd.info,  Node: Reading Symbols,  Next: Writing Symbols,  Prev: Symbols,  Up: Symbols

Reading symbols
---------------

There are two stages to reading a symbol table from a BFD: allocating
storage, and the actual reading process. This is an excerpt from an
application which reads the symbol table:

     	  long storage_needed;
     	  asymbol **symbol_table;
     	  long number_of_symbols;
     	  long i;
     
     	  storage_needed = bfd_get_symtab_upper_bound (abfd);
     
              if (storage_needed < 0)
                FAIL
     
     	  if (storage_needed == 0) {
     	     return ;
     	  }
     	  symbol_table = (asymbol **) xmalloc (storage_needed);
     	    ...
     	  number_of_symbols =
     	     bfd_canonicalize_symtab (abfd, symbol_table);
     
              if (number_of_symbols < 0)
                FAIL
     
     	  for (i = 0; i < number_of_symbols; i++) {
     	     process_symbol (symbol_table[i]);
     	  }

   All storage for the symbols themselves is in an objalloc connected
to the BFD; it is freed when the BFD is closed.

File: bfd.info,  Node: Writing Symbols,  Next: Mini Symbols,  Prev: Reading Symbols,  Up: Symbols

Writing symbols
---------------

Writing of a symbol table is automatic when a BFD open for writing is
closed. The application attaches a vector of pointers to pointers to
symbols to the BFD being written, and fills in the symbol count. The
close and cleanup code reads through the table provided and performs
all the necessary operations. The BFD output code must always be
provided with an "owned" symbol: one which has come from another BFD,
or one which has been created using `bfd_make_empty_symbol'.  Here is an
example showing the creation of a symbol table with only one element:

     	#include "bfd.h"
     	main()
     	{
     	  bfd *abfd;
     	  asymbol *ptrs[2];
     	  asymbol *new;
     
     	  abfd = bfd_openw("foo","a.out-sunos-big");
     	  bfd_set_format(abfd, bfd_object);
     	  new = bfd_make_empty_symbol(abfd);
     	  new->name = "dummy_symbol";
     	  new->section = bfd_make_section_old_way(abfd, ".text");
     	  new->flags = BSF_GLOBAL;
     	  new->value = 0x12345;
     
     	  ptrs[0] = new;
     	  ptrs[1] = (asymbol *)0;
     
     	  bfd_set_symtab(abfd, ptrs, 1);
     	  bfd_close(abfd);
     	}
     
     	./makesym
     	nm foo
     	00012345 A dummy_symbol

   Many formats cannot represent arbitary symbol information; for
instance, the `a.out' object format does not allow an arbitary number
of sections. A symbol pointing to a section which is not one  of
`.text', `.data' or `.bss' cannot be described.

File: bfd.info,  Node: Mini Symbols,  Next: typedef asymbol,  Prev: Writing Symbols,  Up: Symbols

Mini Symbols
------------

Mini symbols provide read-only access to the symbol table.  They use
less memory space, but require more time to access.  They can be useful
for tools like nm or objdump, which may have to handle symbol tables of
extremely large executables.

   The `bfd_read_minisymbols' function will read the symbols into
memory in an internal form.  It will return a `void *' pointer to a
block of memory, a symbol count, and the size of each symbol.  The
pointer is allocated using `malloc', and should be freed by the caller
when it is no longer needed.

   The function `bfd_minisymbol_to_symbol' will take a pointer to a
minisymbol, and a pointer to a structure returned by
`bfd_make_empty_symbol', and return a `asymbol' structure.  The return
value may or may not be the same as the value from
`bfd_make_empty_symbol' which was passed in.

File: bfd.info,  Node: typedef asymbol,  Next: symbol handling functions,  Prev: Mini Symbols,  Up: Symbols

typedef asymbol
---------------

An `asymbol' has the form:
.
     typedef struct symbol_cache_entry
     {
     	/* A pointer to the BFD which owns the symbol. This information
     	   is necessary so that a back end can work out what additional
        	   information (invisible to the application writer) is carried
     	   with the symbol.
     
     	   This field is *almost* redundant, since you can use section->owner
     	   instead, except that some symbols point to the global sections
     	   bfd_{abs,com,und}_section.  This could be fixed by making
     	   these globals be per-bfd (or per-target-flavor).  FIXME. */
     
       struct _bfd *the_bfd; /* Use bfd_asymbol_bfd(sym) to access this field. */
     
     	/* The text of the symbol. The name is left alone, and not copied; the
     	   application may not alter it. */
       CONST char *name;
     
     	/* The value of the symbol.  This really should be a union of a
               numeric value with a pointer, since some flags indicate that
               a pointer to another symbol is stored here.  */
       symvalue value;
     
     	/* Attributes of a symbol: */
     
     #define BSF_NO_FLAGS    0x00
     
     	/* The symbol has local scope; `static' in `C'. The value
      	   is the offset into the section of the data. */
     #define BSF_LOCAL	0x01
     
     	/* The symbol has global scope; initialized data in `C'. The
     	   value is the offset into the section of the data. */
     #define BSF_GLOBAL	0x02
     
     	/* The symbol has global scope and is exported. The value is
     	   the offset into the section of the data. */
     #define BSF_EXPORT	BSF_GLOBAL /* no real difference */
     
     	/* A normal C symbol would be one of:
     	   `BSF_LOCAL', `BSF_FORT_COMM',  `BSF_UNDEFINED' or
     	   `BSF_GLOBAL' */
     
     	/* The symbol is a debugging record. The value has an arbitary
     	   meaning. */
     #define BSF_DEBUGGING	0x08
     
     	/* The symbol denotes a function entry point.  Used in ELF,
     	   perhaps others someday.  */
     #define BSF_FUNCTION    0x10
     
     	/* Used by the linker. */
     #define BSF_KEEP        0x20
     #define BSF_KEEP_G      0x40
     
     	/* A weak global symbol, overridable without warnings by
     	   a regular global symbol of the same name.  */
     #define BSF_WEAK        0x80
     
            /* This symbol was created to point to a section, e.g. ELF's
     	   STT_SECTION symbols.  */
     #define BSF_SECTION_SYM 0x100
     
     	/* The symbol used to be a common symbol, but now it is
     	   allocated. */
     #define BSF_OLD_COMMON  0x200
     
     	/* The default value for common data. */
     #define BFD_FORT_COMM_DEFAULT_VALUE 0
     
     	/* In some files the type of a symbol sometimes alters its
     	   location in an output file - ie in coff a `ISFCN' symbol
     	   which is also `C_EXT' symbol appears where it was
     	   declared and not at the end of a section.  This bit is set
       	   by the target BFD part to convey this information. */
     
     #define BSF_NOT_AT_END    0x400
     
     	/* Signal that the symbol is the label of constructor section. */
     #define BSF_CONSTRUCTOR   0x800
     
     	/* Signal that the symbol is a warning symbol.  The name is a
     	   warning.  The name of the next symbol is the one to warn about;
     	   if a reference is made to a symbol with the same name as the next
     	   symbol, a warning is issued by the linker. */
     #define BSF_WARNING       0x1000
     
     	/* Signal that the symbol is indirect.  This symbol is an indirect
     	   pointer to the symbol with the same name as the next symbol. */
     #define BSF_INDIRECT      0x2000
     
     	/* BSF_FILE marks symbols that contain a file name.  This is used
     	   for ELF STT_FILE symbols.  */
     #define BSF_FILE          0x4000
     
     	/* Symbol is from dynamic linking information.  */
     #define BSF_DYNAMIC	   0x8000
     
            /* The symbol denotes a data object.  Used in ELF, and perhaps
               others someday.  */
     #define BSF_OBJECT	   0x10000
     
       flagword flags;
     
     	/* A pointer to the section to which this symbol is
     	   relative.  This will always be non NULL, there are special
               sections for undefined and absolute symbols.  */
       struct sec *section;
     
     	/* Back end special data.  */
       union
         {
           PTR p;
           bfd_vma i;
         } udata;
     
     } asymbol;


File: bfd.info,  Node: symbol handling functions,  Prev: typedef asymbol,  Up: Symbols

Symbol handling functions
-------------------------

`bfd_get_symtab_upper_bound'
............................

*Description*
Return the number of bytes required to store a vector of pointers to
`asymbols' for all the symbols in the BFD ABFD, including a terminal
NULL pointer. If there are no symbols in the BFD, then return 0.  If an
error occurs, return -1.
     #define bfd_get_symtab_upper_bound(abfd) \
          BFD_SEND (abfd, _bfd_get_symtab_upper_bound, (abfd))

`bfd_is_local_label'
....................

*Synopsis*
     boolean bfd_is_local_label(bfd *abfd, asymbol *sym);
   *Description*
Return true if the given symbol SYM in the BFD ABFD is a compiler
generated local label, else return false.
`bfd_is_local_label_name'
.........................

*Synopsis*
     boolean bfd_is_local_label_name(bfd *abfd, const char *name);
   *Description*
Return true if a symbol with the name NAME in the BFD ABFD is a
compiler generated local label, else return false.  This just checks
whether the name has the form of a local label.
     #define bfd_is_local_label_name(abfd, name) \
          BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name))

`bfd_canonicalize_symtab'
.........................

*Description*
Read the symbols from the BFD ABFD, and fills in the vector LOCATION
with pointers to the symbols and a trailing NULL.  Return the actual
number of symbol pointers, not including the NULL.
     #define bfd_canonicalize_symtab(abfd, location) \
          BFD_SEND (abfd, _bfd_canonicalize_symtab,\
                       (abfd, location))

`bfd_set_symtab'
................

*Synopsis*
     boolean bfd_set_symtab (bfd *abfd, asymbol **location, unsigned int count);
   *Description*
Arrange that when the output BFD ABFD is closed, the table LOCATION of
COUNT pointers to symbols will be written.
`bfd_print_symbol_vandf'
........................

*Synopsis*
     void bfd_print_symbol_vandf(PTR file, asymbol *symbol);
   *Description*
Print the value and flags of the SYMBOL supplied to the stream FILE.
`bfd_make_empty_symbol'
.......................

*Description*
Create a new `asymbol' structure for the BFD ABFD and return a pointer
to it.

   This routine is necessary because each back end has private
information surrounding the `asymbol'. Building your own `asymbol' and
pointing to it will not create the private information, and will cause
problems later on.
     #define bfd_make_empty_symbol(abfd) \
          BFD_SEND (abfd, _bfd_make_empty_symbol, (abfd))

`bfd_make_debug_symbol'
.......................

*Description*
Create a new `asymbol' structure for the BFD ABFD, to be used as a
debugging symbol.  Further details of its use have yet to be worked out.
     #define bfd_make_debug_symbol(abfd,ptr,size) \
             BFD_SEND (abfd, _bfd_make_debug_symbol, (abfd, ptr, size))

`bfd_decode_symclass'
.....................

*Description*
Return a character corresponding to the symbol class of SYMBOL, or '?'
for an unknown class.
*Synopsis*
     int bfd_decode_symclass(asymbol *symbol);

`bfd_symbol_info'
.................

   *Description*
Fill in the basic info about symbol that nm needs.  Additional info may
be added by the back-ends after calling this function.
*Synopsis*
     void bfd_symbol_info(asymbol *symbol, symbol_info *ret);

`bfd_copy_private_symbol_data'
..............................

   *Synopsis*
     boolean bfd_copy_private_symbol_data(bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
   *Description*
Copy private symbol information from ISYM in the BFD IBFD to the symbol
OSYM in the BFD OBFD.  Return `true' on success, `false' on error.
Possible error returns are:

   * `bfd_error_no_memory' - Not enough memory exists to create private
     data for OSEC.
     #define bfd_copy_private_symbol_data(ibfd, isymbol, obfd, osymbol) \
          BFD_SEND (obfd, _bfd_copy_private_symbol_data, \
     		(ibfd, isymbol, obfd, osymbol))


File: bfd.info,  Node: Archives,  Next: Formats,  Prev: Symbols,  Up: BFD front end

Archives
========

*Description*
An archive (or library) is just another BFD.  It has a symbol table,
although there's not much a user program will do with it.

   The big difference between an archive BFD and an ordinary BFD is
that the archive doesn't have sections.  Instead it has a chain of BFDs
that are considered its contents.  These BFDs can be manipulated like
any other.  The BFDs contained in an archive opened for reading will
all be opened for reading.  You may put either input or output BFDs
into an archive opened for output; they will be handled correctly when
the archive is closed.

   Use `bfd_openr_next_archived_file' to step through the contents of
an archive opened for input.  You don't have to read the entire archive
if you don't want to!  Read it until you find what you want.

   Archive contents of output BFDs are chained through the `next'
pointer in a BFD.  The first one is findable through the `archive_head'
slot of the archive.  Set it with `bfd_set_archive_head' (q.v.).  A
given BFD may be in only one open output archive at a time.

   As expected, the BFD archive code is more general than the archive
code of any given environment.  BFD archives may contain files of
different formats (e.g., a.out and coff) and even different
architectures.  You may even place archives recursively into archives!

   This can cause unexpected confusion, since some archive formats are
more expressive than others.  For instance, Intel COFF archives can
preserve long filenames; SunOS a.out archives cannot.  If you move a
file from the first to the second format and back again, the filename
may be truncated.  Likewise, different a.out environments have different
conventions as to how they truncate filenames, whether they preserve
directory names in filenames, etc.  When interoperating with native
tools, be sure your files are homogeneous.

   Beware: most of these formats do not react well to the presence of
spaces in filenames.  We do the best we can, but can't always handle
this case due to restrictions in the format of archives.  Many Unix
utilities are braindead in regards to spaces and such in filenames
anyway, so this shouldn't be much of a restriction.

   Archives are supported in BFD in `archive.c'.
`bfd_get_next_mapent'
.....................

*Synopsis*
     symindex bfd_get_next_mapent(bfd *abfd, symindex previous, carsym **sym);
   *Description*
Step through archive ABFD's symbol table (if it has one).  Successively
update SYM with the next symbol's information, returning that symbol's
(internal) index into the symbol table.

   Supply `BFD_NO_MORE_SYMBOLS' as the PREVIOUS entry to get the first
one; returns `BFD_NO_MORE_SYMBOLS' when you've already got the last one.

   A `carsym' is a canonical archive symbol.  The only user-visible
element is its name, a null-terminated string.
`bfd_set_archive_head'
......................

*Synopsis*
     boolean bfd_set_archive_head(bfd *output, bfd *new_head);
   *Description*
Set the head of the chain of BFDs contained in the archive OUTPUT to
NEW_HEAD.
`bfd_openr_next_archived_file'
..............................

*Synopsis*
     bfd *bfd_openr_next_archived_file(bfd *archive, bfd *previous);
   *Description*
Provided a BFD, ARCHIVE, containing an archive and NULL, open an input
BFD on the first contained element and returns that.  Subsequent calls
should pass the archive and the previous return value to return a
created BFD to the next contained element. NULL is returned when there
are no more.

File: bfd.info,  Node: Formats,  Next: Relocations,  Prev: Archives,  Up: BFD front end

File formats
============

A format is a BFD concept of high level file contents type. The formats
supported by BFD are:

   * `bfd_object' The BFD may contain data, symbols, relocations and
debug info.

   * `bfd_archive' The BFD contains other BFDs and an optional index.

   * `bfd_core' The BFD contains the result of an executable core dump.
`bfd_check_format'
..................

*Synopsis*
     boolean bfd_check_format(bfd *abfd, bfd_format format);
   *Description*
Verify if the file attached to the BFD ABFD is compatible with the
format FORMAT (i.e., one of `bfd_object', `bfd_archive' or `bfd_core').

   If the BFD has been set to a specific target before the call, only
the named target and format combination is checked. If the target has
not been set, or has been set to `default', then all the known target
backends is interrogated to determine a match.  If the default target
matches, it is used.  If not, exactly one target must recognize the
file, or an error results.

   The function returns `true' on success, otherwise `false' with one
of the following error codes:

   * `bfd_error_invalid_operation' - if `format' is not one of
     `bfd_object', `bfd_archive' or `bfd_core'.

   * `bfd_error_system_call' - if an error occured during a read - even
     some file mismatches can cause bfd_error_system_calls.

   * `file_not_recognised' - none of the backends recognised the file
     format.

   * `bfd_error_file_ambiguously_recognized' - more than one backend
     recognised the file format.
`bfd_check_format_matches'
..........................

*Synopsis*
     boolean bfd_check_format_matches(bfd *abfd, bfd_format format, char ***matching);
   *Description*
Like `bfd_check_format', except when it returns false with `bfd_errno'
set to `bfd_error_file_ambiguously_recognized'.  In that case, if
MATCHING is not NULL, it will be filled in with a NULL-terminated list
of the names of the formats that matched, allocated with `malloc'.
Then the user may choose a format and try again.

   When done with the list that MATCHING points to, the caller should
free it.
`bfd_set_format'
................

*Synopsis*
     boolean bfd_set_format(bfd *abfd, bfd_format format);
   *Description*
This function sets the file format of the BFD ABFD to the format
FORMAT. If the target set in the BFD does not support the format
requested, the format is invalid, or the BFD is not open for writing,
then an error occurs.
`bfd_format_string'
...................

*Synopsis*
     CONST char *bfd_format_string(bfd_format format);
   *Description*
Return a pointer to a const string `invalid', `object', `archive',
`core', or `unknown', depending upon the value of FORMAT.

File: bfd.info,  Node: Relocations,  Next: Core Files,  Prev: Formats,  Up: BFD front end

Relocations
===========

BFD maintains relocations in much the same way it maintains symbols:
they are left alone until required, then read in en-mass and translated
into an internal form.  A common routine `bfd_perform_relocation' acts
upon the canonical form to do the fixup.

   Relocations are maintained on a per section basis, while symbols are
maintained on a per BFD basis.

   All that a back end has to do to fit the BFD interface is to create
a `struct reloc_cache_entry' for each relocation in a particular
section, and fill in the right bits of the structures.

* Menu:

* typedef arelent::
* howto manager::


File: bfd.info,  Node: typedef arelent,  Next: howto manager,  Prev: Relocations,  Up: Relocations

typedef arelent
---------------

This is the structure of a relocation entry:
.
     typedef enum bfd_reloc_status
     {
            /* No errors detected */
       bfd_reloc_ok,
     
            /* The relocation was performed, but there was an overflow. */
       bfd_reloc_overflow,
     
            /* The address to relocate was not within the section supplied. */
       bfd_reloc_outofrange,
     
            /* Used by special functions */
       bfd_reloc_continue,
     
            /* Unsupported relocation size requested. */
       bfd_reloc_notsupported,
     
            /* Unused */
       bfd_reloc_other,
     
            /* The symbol to relocate against was undefined. */
       bfd_reloc_undefined,
     
            /* The relocation was performed, but may not be ok - presently
               generated only when linking i960 coff files with i960 b.out
               symbols.  If this type is returned, the error_message argument
               to bfd_perform_relocation will be set.  */
       bfd_reloc_dangerous
      }
      bfd_reloc_status_type;
     
     
     typedef struct reloc_cache_entry
     {
            /* A pointer into the canonical table of pointers  */
       struct symbol_cache_entry **sym_ptr_ptr;
     
            /* offset in section */
       bfd_size_type address;
     
            /* addend for relocation value */
       bfd_vma addend;
     
            /* Pointer to how to perform the required relocation */
       reloc_howto_type *howto;
     
     } arelent;
   *Description*
Here is a description of each of the fields within an `arelent':

   * `sym_ptr_ptr' The symbol table pointer points to a pointer to the
symbol associated with the relocation request.  It is the pointer into
the table returned by the back end's `get_symtab' action. *Note
Symbols::. The symbol is referenced through a pointer to a pointer so
that tools like the linker can fix up all the symbols of the same name
by modifying only one pointer. The relocation routine looks in the
symbol and uses the base of the section the symbol is attached to and
the value of the symbol as the initial relocation offset. If the symbol
pointer is zero, then the section provided is looked up.

   * `address' The `address' field gives the offset in bytes from the
base of the section data which owns the relocation record to the first
byte of relocatable information. The actual data relocated will be
relative to this point; for example, a relocation type which modifies
the bottom two bytes of a four byte word would not touch the first byte
pointed to in a big endian world.

   * `addend' The `addend' is a value provided by the back end to be
added (!) to the relocation offset. Its interpretation is dependent upon
the howto. For example, on the 68k the code:

             char foo[];
             main()
                     {
                     return foo[0x12345678];
                     }

   Could be compiled into:

             linkw fp,#-4
             moveb @@#12345678,d0
             extbl d0
             unlk fp
             rts

   This could create a reloc pointing to `foo', but leave the offset in
the data, something like:

     RELOCATION RECORDS FOR [.text]:
     offset   type      value
     00000006 32        _foo
     
     00000000 4e56 fffc          ; linkw fp,#-4
     00000004 1039 1234 5678     ; moveb @@#12345678,d0
     0000000a 49c0               ; extbl d0
     0000000c 4e5e               ; unlk fp
     0000000e 4e75               ; rts

   Using coff and an 88k, some instructions don't have enough space in
them to represent the full address range, and pointers have to be
loaded in two parts. So you'd get something like:

             or.u     r13,r0,hi16(_foo+0x12345678)
             ld.b     r2,r13,lo16(_foo+0x12345678)
             jmp      r1

   This should create two relocs, both pointing to `_foo', and with
0x12340000 in their addend field. The data would consist of:

     RELOCATION RECORDS FOR [.text]:
     offset   type      value
     00000002 HVRT16    _foo+0x12340000
     00000006 LVRT16    _foo+0x12340000
     
     00000000 5da05678           ; or.u r13,r0,0x5678
     00000004 1c4d5678           ; ld.b r2,r13,0x5678
     00000008 f400c001           ; jmp r1

   The relocation routine digs out the value from the data, adds it to
the addend to get the original offset, and then adds the value of
`_foo'. Note that all 32 bits have to be kept around somewhere, to cope
with carry from bit 15 to bit 16.

   One further example is the sparc and the a.out format. The sparc has
a similar problem to the 88k, in that some instructions don't have room
for an entire offset, but on the sparc the parts are created in odd
sized lumps. The designers of the a.out format chose to not use the
data within the section for storing part of the offset; all the offset
is kept within the reloc. Anything in the data should be ignored.

             save %sp,-112,%sp
             sethi %hi(_foo+0x12345678),%g2
             ldsb [%g2+%lo(_foo+0x12345678)],%i0
             ret
             restore

   Both relocs contain a pointer to `foo', and the offsets contain junk.

     RELOCATION RECORDS FOR [.text]:
     offset   type      value
     00000004 HI22      _foo+0x12345678
     00000008 LO10      _foo+0x12345678
     
     00000000 9de3bf90     ; save %sp,-112,%sp
     00000004 05000000     ; sethi %hi(_foo+0),%g2
     00000008 f048a000     ; ldsb [%g2+%lo(_foo+0)],%i0
     0000000c 81c7e008     ; ret
     00000010 81e80000     ; restore

   * `howto' The `howto' field can be imagined as a relocation
instruction. It is a pointer to a structure which contains information
on what to do with all of the other information in the reloc record and
data section. A back end would normally have a relocation instruction
set and turn relocations into pointers to the correct structure on
input - but it would be possible to create each howto field on demand.
`enum complain_overflow'
........................

Indicates what sort of overflow checking should be done when performing
a relocation.
.
     enum complain_overflow
     {
     	/* Do not complain on overflow. */
       complain_overflow_dont,
     
     	/* Complain if the bitfield overflows, whether it is considered
     	   as signed or unsigned. */
       complain_overflow_bitfield,
     
     	/* Complain if the value overflows when considered as signed
     	   number. */
       complain_overflow_signed,
     
     	/* Complain if the value overflows when considered as an
     	   unsigned number. */
       complain_overflow_unsigned
     };

`reloc_howto_type'
..................

   The `reloc_howto_type' is a structure which contains all the
information that libbfd needs to know to tie up a back end's data.
.struct symbol_cache_entry;		/* Forward declaration */

     struct reloc_howto_struct
     {
            /*  The type field has mainly a documentary use - the back end can
                do what it wants with it, though normally the back end's
                external idea of what a reloc number is stored
                in this field. For example, a PC relative word relocation
                in a coff environment has the type 023 - because that's
                what the outside world calls a R_PCRWORD reloc. */
       unsigned int type;
     
            /*  The value the final relocation is shifted right by. This drops
                unwanted data from the relocation.  */
       unsigned int rightshift;
     
     	/*  The size of the item to be relocated.  This is *not* a
     	    power-of-two measure.  To get the number of bytes operated
     	    on by a type of relocation, use bfd_get_reloc_size.  */
       int size;
     
            /*  The number of bits in the item to be relocated.  This is used
     	    when doing overflow checking.  */
       unsigned int bitsize;
     
            /*  Notes that the relocation is relative to the location in the
                data section of the addend. The relocation function will
                subtract from the relocation value the address of the location
                being relocated. */
       boolean pc_relative;
     
     	/*  The bit position of the reloc value in the destination.
     	    The relocated value is left shifted by this amount. */
       unsigned int bitpos;
     
     	/* What type of overflow error should be checked for when
     	   relocating. */
       enum complain_overflow complain_on_overflow;
     
            /* If this field is non null, then the supplied function is
               called rather than the normal function. This allows really
               strange relocation methods to be accomodated (e.g., i960 callj
               instructions). */
       bfd_reloc_status_type (*special_function)
     				    PARAMS ((bfd *abfd,
     					     arelent *reloc_entry,
                                                 struct symbol_cache_entry *symbol,
                                                 PTR data,
                                                 asection *input_section,
                                                 bfd *output_bfd,
                                                 char **error_message));
     
            /* The textual name of the relocation type. */
       char *name;
     
            /* When performing a partial link, some formats must modify the
               relocations rather than the data - this flag signals this.*/
       boolean partial_inplace;
     
            /* The src_mask selects which parts of the read in data
               are to be used in the relocation sum.  E.g., if this was an 8 bit
               bit of data which we read and relocated, this would be
               0x000000ff. When we have relocs which have an addend, such as
               sun4 extended relocs, the value in the offset part of a
               relocating field is garbage so we never use it. In this case
               the mask would be 0x00000000. */
       bfd_vma src_mask;
     
            /* The dst_mask selects which parts of the instruction are replaced
               into the instruction. In most cases src_mask == dst_mask,
               except in the above special case, where dst_mask would be
               0x000000ff, and src_mask would be 0x00000000.   */
       bfd_vma dst_mask;
     
            /* When some formats create PC relative instructions, they leave
               the value of the pc of the place being relocated in the offset
               slot of the instruction, so that a PC relative relocation can
               be made just by adding in an ordinary offset (e.g., sun3 a.out).
               Some formats leave the displacement part of an instruction
               empty (e.g., m88k bcs); this flag signals the fact.*/
       boolean pcrel_offset;
     
     };

`The HOWTO Macro'
.................

   *Description*
The HOWTO define is horrible and will go away.
     #define HOWTO(C, R,S,B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC) \
       {(unsigned)C,R,S,B, P, BI, O,SF,NAME,INPLACE,MASKSRC,MASKDST,PC}

*Description*
And will be replaced with the totally magic way. But for the moment, we
are compatible, so do it this way.
     #define NEWHOWTO( FUNCTION, NAME,SIZE,REL,IN) HOWTO(0,0,SIZE,0,REL,0,complain_overflow_dont,FUNCTION, NAME,false,0,0,IN)

*Description*
Helper routine to turn a symbol into a relocation value.
     #define HOWTO_PREPARE(relocation, symbol)      \
       {                                            \
       if (symbol != (asymbol *)NULL) {             \
         if (bfd_is_com_section (symbol->section)) { \
           relocation = 0;                          \
         }                                          \
         else {                                     \
           relocation = symbol->value;              \
         }                                          \
       }                                            \
     }

`bfd_get_reloc_size'
....................

*Synopsis*
     int bfd_get_reloc_size (reloc_howto_type *);
   *Description*
For a reloc_howto_type that operates on a fixed number of bytes, this
returns the number of bytes operated on.
`arelent_chain'
...............

*Description*
How relocs are tied together in an `asection':
     typedef struct relent_chain {
       arelent relent;
       struct   relent_chain *next;
     } arelent_chain;

`bfd_perform_relocation'
........................

*Synopsis*
     bfd_reloc_status_type
     bfd_perform_relocation
        (bfd *abfd,
         arelent *reloc_entry,
         PTR data,
         asection *input_section,
         bfd *output_bfd,
         char **error_message);
   *Description*
If OUTPUT_BFD is supplied to this function, the generated image will be
relocatable; the relocations are copied to the output file after they
have been changed to reflect the new state of the world. There are two
ways of reflecting the results of partial linkage in an output file: by
modifying the output data in place, and by modifying the relocation
record.  Some native formats (e.g., basic a.out and basic coff) have no
way of specifying an addend in the relocation type, so the addend has
to go in the output data.  This is no big deal since in these formats
the output data slot will always be big enough for the addend. Complex
reloc types with addends were invented to solve just this problem.  The
ERROR_MESSAGE argument is set to an error message if this return
`bfd_reloc_dangerous'.
`bfd_install_relocation'
........................

*Synopsis*
     bfd_reloc_status_type
     bfd_install_relocation
        (bfd *abfd,
         arelent *reloc_entry,
         PTR data, bfd_vma data_start,
         asection *input_section,
         char **error_message);
   *Description*
This looks remarkably like `bfd_perform_relocation', except it does not
expect that the section contents have been filled in.  I.e., it's
suitable for use when creating, rather than applying a relocation.

   For now, this function should be considered reserved for the
assembler.
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@@


1.1.1.2
log
@Long delayed import of binutils-2.10.1. Turns out art@@ needs some alpha
bug-fixes...
@
text
@d1 2
a2 1
This is bfd.info, produced by makeinfo version 4.0 from bfd.texinfo.
a26 373
File: bfd.info,  Node: typedef asection,  Next: section prototypes,  Prev: Section Output,  Up: Sections

typedef asection
----------------

   Here is the section structure:


      /* This structure is used for a comdat section, as in PE.  A comdat
         section is associated with a particular symbol.  When the linker
         sees a comdat section, it keeps only one of the sections with a
         given name and associated with a given symbol. */
     
     struct bfd_comdat_info
     {
       /* The name of the symbol associated with a comdat section.  */
       const char *name;
     
       /* The local symbol table index of the symbol associated with a
          comdat section.  This is only meaningful to the object file format
          specific code; it is not an index into the list returned by
          bfd_canonicalize_symtab.  */
       long symbol;
     
       /* If this section is being discarded, the linker uses this field
          to point to the input section which is being kept.  */
       struct sec *sec;
     };
     
     typedef struct sec
     {
             /* The name of the section; the name isn't a copy, the pointer is
             the same as that passed to bfd_make_section. */
     
         CONST char *name;
     
             /* Which section is it; 0..nth.      */
     
        int index;
     
             /* The next section in the list belonging to the BFD, or NULL. */
     
         struct sec *next;
     
             /* The field flags contains attributes of the section. Some
                flags are read in from the object file, and some are
                synthesized from other information.  */
     
         flagword flags;
     
     #define SEC_NO_FLAGS   0x000
     
             /* Tells the OS to allocate space for this section when loading.
                This is clear for a section containing debug information
                only. */
     #define SEC_ALLOC      0x001
     
             /* Tells the OS to load the section from the file when loading.
                This is clear for a .bss section. */
     #define SEC_LOAD       0x002
     
             /* The section contains data still to be relocated, so there is
                some relocation information too. */
     #define SEC_RELOC      0x004
     
     #if 0   /* Obsolete ? */
     #define SEC_BALIGN     0x008
     #endif
     
             /* A signal to the OS that the section contains read only
               data. */
     #define SEC_READONLY   0x010
     
             /* The section contains code only. */
     #define SEC_CODE       0x020
     
             /* The section contains data only. */
     #define SEC_DATA       0x040
     
             /* The section will reside in ROM. */
     #define SEC_ROM        0x080
     
             /* The section contains constructor information. This section
                type is used by the linker to create lists of constructors and
                destructors used by `g++'. When a back end sees a symbol
                which should be used in a constructor list, it creates a new
                section for the type of name (e.g., `__CTOR_LIST__'), attaches
                the symbol to it, and builds a relocation. To build the lists
                of constructors, all the linker has to do is catenate all the
                sections called `__CTOR_LIST__' and relocate the data
                contained within - exactly the operations it would peform on
                standard data. */
     #define SEC_CONSTRUCTOR 0x100
     
             /* The section is a constructor, and should be placed at the
               end of the text, data, or bss section(?). */
     #define SEC_CONSTRUCTOR_TEXT 0x1100
     #define SEC_CONSTRUCTOR_DATA 0x2100
     #define SEC_CONSTRUCTOR_BSS  0x3100
     
             /* The section has contents - a data section could be
                `SEC_ALLOC' | `SEC_HAS_CONTENTS'; a debug section could be
                `SEC_HAS_CONTENTS' */
     #define SEC_HAS_CONTENTS 0x200
     
             /* An instruction to the linker to not output the section
                even if it has information which would normally be written. */
     #define SEC_NEVER_LOAD 0x400
     
             /* The section is a COFF shared library section.  This flag is
                only for the linker.  If this type of section appears in
                the input file, the linker must copy it to the output file
                without changing the vma or size.  FIXME: Although this
                was originally intended to be general, it really is COFF
                specific (and the flag was renamed to indicate this).  It
                might be cleaner to have some more general mechanism to
                allow the back end to control what the linker does with
                sections. */
     #define SEC_COFF_SHARED_LIBRARY 0x800
     
             /* The section contains common symbols (symbols may be defined
                multiple times, the value of a symbol is the amount of
                space it requires, and the largest symbol value is the one
                used).  Most targets have exactly one of these (which we
                translate to bfd_com_section_ptr), but ECOFF has two. */
     #define SEC_IS_COMMON 0x8000
     
             /* The section contains only debugging information.  For
                example, this is set for ELF .debug and .stab sections.
                strip tests this flag to see if a section can be
                discarded. */
     #define SEC_DEBUGGING 0x10000
     
             /* The contents of this section are held in memory pointed to
                by the contents field.  This is checked by
                bfd_get_section_contents, and the data is retrieved from
                memory if appropriate.  */
     #define SEC_IN_MEMORY 0x20000
     
             /* The contents of this section are to be excluded by the
                linker for executable and shared objects unless those
                objects are to be further relocated.  */
     #define SEC_EXCLUDE 0x40000
     
            /* The contents of this section are to be sorted by the
               based on the address specified in the associated symbol
               table.  */
     #define SEC_SORT_ENTRIES 0x80000
     
            /* When linking, duplicate sections of the same name should be
               discarded, rather than being combined into a single section as
               is usually done.  This is similar to how common symbols are
               handled.  See SEC_LINK_DUPLICATES below.  */
     #define SEC_LINK_ONCE 0x100000
     
            /* If SEC_LINK_ONCE is set, this bitfield describes how the linker
               should handle duplicate sections.  */
     #define SEC_LINK_DUPLICATES 0x600000
     
            /* This value for SEC_LINK_DUPLICATES means that duplicate
               sections with the same name should simply be discarded. */
     #define SEC_LINK_DUPLICATES_DISCARD 0x0
     
            /* This value for SEC_LINK_DUPLICATES means that the linker
               should warn if there are any duplicate sections, although
               it should still only link one copy.  */
     #define SEC_LINK_DUPLICATES_ONE_ONLY 0x200000
     
            /* This value for SEC_LINK_DUPLICATES means that the linker
               should warn if any duplicate sections are a different size.  */
     #define SEC_LINK_DUPLICATES_SAME_SIZE 0x400000
     
            /* This value for SEC_LINK_DUPLICATES means that the linker
               should warn if any duplicate sections contain different
               contents.  */
     #define SEC_LINK_DUPLICATES_SAME_CONTENTS 0x600000
     
            /* This section was created by the linker as part of dynamic
               relocation or other arcane processing.  It is skipped when
               going through the first-pass output, trusting that someone
               else up the line will take care of it later.  */
     #define SEC_LINKER_CREATED 0x800000
     
            /* This section should not be subject to garbage collection.  */
     #define SEC_KEEP 0x1000000
     
            /* This section contains "short" data, and should be placed
               "near" the GP.  */
     #define SEC_SMALL_DATA 0x2000000
     
            /* This section contains data which may be shared with other
               executables or shared objects.  */
     #define SEC_SHARED 0x4000000
     
            /*  End of section flags.  */
     
            /* Some internal packed boolean fields.  */
     
            /* See the vma field.  */
            unsigned int user_set_vma : 1;
     
            /* Whether relocations have been processed.  */
            unsigned int reloc_done : 1;
     
            /* A mark flag used by some of the linker backends.  */
            unsigned int linker_mark : 1;
     
            /* A mark flag used by some linker backends for garbage collection.  */
            unsigned int gc_mark : 1;
     
            /* End of internal packed boolean fields.  */
     
            /*  The virtual memory address of the section - where it will be
                at run time.  The symbols are relocated against this.  The
                user_set_vma flag is maintained by bfd; if it's not set, the
                backend can assign addresses (for example, in `a.out', where
                the default address for `.data' is dependent on the specific
                target and various flags).  */
     
        bfd_vma vma;
     
            /*  The load address of the section - where it would be in a
                rom image; really only used for writing section header
                information. */
     
        bfd_vma lma;
     
             /* The size of the section in octets, as it will be output.
                Contains a value even if the section has no contents (e.g., the
                size of `.bss').  This will be filled in after relocation.  */
     
        bfd_size_type _cooked_size;
     
             /* The original size on disk of the section, in octets.  Normally this
                value is the same as the size, but if some relaxing has
                been done, then this value will be bigger.  */
     
        bfd_size_type _raw_size;
     
             /* If this section is going to be output, then this value is the
                offset in *bytes* into the output section of the first byte in the
                input section (byte ==> smallest addressable unit on the
                target).  In most cases, if this was going to start at the
                100th octet (8-bit quantity) in the output section, this value
                would be 100.  However, if the target byte size is 16 bits
                (bfd_octets_per_byte is "2"), this value would be 50. */
     
        bfd_vma output_offset;
     
             /* The output section through which to map on output. */
     
        struct sec *output_section;
     
             /* The alignment requirement of the section, as an exponent of 2 -
                e.g., 3 aligns to 2^3 (or 8). */
     
        unsigned int alignment_power;
     
             /* If an input section, a pointer to a vector of relocation
                records for the data in this section. */
     
        struct reloc_cache_entry *relocation;
     
             /* If an output section, a pointer to a vector of pointers to
                relocation records for the data in this section. */
     
        struct reloc_cache_entry **orelocation;
     
             /* The number of relocation records in one of the above  */
     
        unsigned reloc_count;
     
             /* Information below is back end specific - and not always used
                or updated.  */
     
             /* File position of section data    */
     
        file_ptr filepos;
     
             /* File position of relocation info */
     
        file_ptr rel_filepos;
     
             /* File position of line data       */
     
        file_ptr line_filepos;
     
             /* Pointer to data for applications */
     
        PTR userdata;
     
             /* If the SEC_IN_MEMORY flag is set, this points to the actual
                contents.  */
        unsigned char *contents;
     
             /* Attached line number information */
     
        alent *lineno;
     
             /* Number of line number records   */
     
        unsigned int lineno_count;
     
             /* Optional information about a COMDAT entry; NULL if not COMDAT */
     
        struct bfd_comdat_info *comdat;
     
             /* When a section is being output, this value changes as more
                linenumbers are written out */
     
        file_ptr moving_line_filepos;
     
             /* What the section number is in the target world  */
     
        int target_index;
     
        PTR used_by_bfd;
     
             /* If this is a constructor section then here is a list of the
                relocations created to relocate items within it. */
     
        struct relent_chain *constructor_chain;
     
             /* The BFD which owns the section. */
     
        bfd *owner;
     
             /* A symbol which points at this section only */
        struct symbol_cache_entry *symbol;
        struct symbol_cache_entry **symbol_ptr_ptr;
     
        struct bfd_link_order *link_order_head;
        struct bfd_link_order *link_order_tail;
     } asection ;
     
         /* These sections are global, and are managed by BFD.  The application
            and target back end are not permitted to change the values in
            these sections.  New code should use the section_ptr macros rather
            than referring directly to the const sections.  The const sections
            may eventually vanish.  */
     #define BFD_ABS_SECTION_NAME "*ABS*"
     #define BFD_UND_SECTION_NAME "*UND*"
     #define BFD_COM_SECTION_NAME "*COM*"
     #define BFD_IND_SECTION_NAME "*IND*"
     
         /* the absolute section */
     extern const asection bfd_abs_section;
     #define bfd_abs_section_ptr ((asection *) &bfd_abs_section)
     #define bfd_is_abs_section(sec) ((sec) == bfd_abs_section_ptr)
         /* Pointer to the undefined section */
     extern const asection bfd_und_section;
     #define bfd_und_section_ptr ((asection *) &bfd_und_section)
     #define bfd_is_und_section(sec) ((sec) == bfd_und_section_ptr)
         /* Pointer to the common section */
     extern const asection bfd_com_section;
     #define bfd_com_section_ptr ((asection *) &bfd_com_section)
         /* Pointer to the indirect section */
     extern const asection bfd_ind_section;
     #define bfd_ind_section_ptr ((asection *) &bfd_ind_section)
     #define bfd_is_ind_section(sec) ((sec) == bfd_ind_section_ptr)
     
     extern const struct symbol_cache_entry * const bfd_abs_symbol;
     extern const struct symbol_cache_entry * const bfd_com_symbol;
     extern const struct symbol_cache_entry * const bfd_und_symbol;
     extern const struct symbol_cache_entry * const bfd_ind_symbol;
     #define bfd_get_section_size_before_reloc(section) \
          ((section)->reloc_done ? (abort (), (bfd_size_type) 1) \
                                 : (section)->_raw_size)
     #define bfd_get_section_size_after_reloc(section) \
          ((section)->reloc_done ? (section)->_cooked_size \
                                 : (abort (), (bfd_size_type) 1))


a32 1

d36 1
a36 1
   *Synopsis*
a45 1

d49 1
a49 1
   *Synopsis*
a64 1

d68 1
a68 1
   *Synopsis*
a79 1

d83 1
a83 1
   *Synopsis*
a89 1

d93 1
a93 1
   *Synopsis*
a102 1

d106 1
a106 1
   *Synopsis*
d116 1
a116 1
            func(abfd, the_section, obj);
d121 3
a123 3
               section *p;
               for (p = abfd->sections; p != NULL; p = p->next)
                  func(abfd, p, ...)
d128 1
a128 1
   *Synopsis*
a136 1

d140 1
a140 1
   *Synopsis*
d150 1
a150 1
starting at offset OFFSET for COUNT octets.
d157 2
a158 4
   * and some more too
   This routine is front end to the back end function
`_bfd_set_section_contents'.

d162 1
a162 1
   *Synopsis*
a174 1

d178 1
a178 1
   *Synopsis*
a186 1

d189 1
a189 12
                    (ibfd, isection, obfd, osection))

`_bfd_strip_section_from_output'
................................

   *Synopsis*
     void _bfd_strip_section_from_output
        (struct bfd_link_info *info, asection *section);
   *Description*
Remove SECTION from the output.  If the output section becomes empty,
remove it from the output bfd.  INFO may be NULL; if it is not, it is
used to decide whether the output section is empty.
d197 1
a197 1
   BFD tries to maintain as much symbol information as it can when it
d232 8
a239 8
   There are two stages to reading a symbol table from a BFD:
allocating storage, and the actual reading process. This is an excerpt
from an application which reads the symbol table:

              long storage_needed;
              asymbol **symbol_table;
              long number_of_symbols;
              long i;
d241 1
a241 1
              storage_needed = bfd_get_symtab_upper_bound (abfd);
d246 7
a252 7
              if (storage_needed == 0) {
                 return ;
              }
              symbol_table = (asymbol **) xmalloc (storage_needed);
                ...
              number_of_symbols =
                 bfd_canonicalize_symtab (abfd, symbol_table);
d257 3
a259 3
              for (i = 0; i < number_of_symbols; i++) {
                 process_symbol (symbol_table[i]);
              }
a262 1

d269 2
a270 2
   Writing of a symbol table is automatic when a BFD open for writing
is closed. The application attaches a vector of pointers to pointers to
d278 25
a302 25
            #include "bfd.h"
            main()
            {
              bfd *abfd;
              asymbol *ptrs[2];
              asymbol *new;
     
              abfd = bfd_openw("foo","a.out-sunos-big");
              bfd_set_format(abfd, bfd_object);
              new = bfd_make_empty_symbol(abfd);
              new->name = "dummy_symbol";
              new->section = bfd_make_section_old_way(abfd, ".text");
              new->flags = BSF_GLOBAL;
              new->value = 0x12345;
     
              ptrs[0] = new;
              ptrs[1] = (asymbol *)0;
     
              bfd_set_symtab(abfd, ptrs, 1);
              bfd_close(abfd);
            }
     
            ./makesym
            nm foo
            00012345 A dummy_symbol
a307 1

d314 1
a314 1
   Mini symbols provide read-only access to the symbol table.  They use
a329 1

d336 2
a337 3
   An `asymbol' has the form:


d340 9
a348 9
            /* A pointer to the BFD which owns the symbol. This information
               is necessary so that a back end can work out what additional
               information (invisible to the application writer) is carried
               with the symbol.
     
               This field is *almost* redundant, since you can use section->owner
               instead, except that some symbols point to the global sections
               bfd_{abs,com,und}_section.  This could be fixed by making
               these globals be per-bfd (or per-target-flavor).  FIXME. */
d352 2
a353 2
            /* The text of the symbol. The name is left alone, and not copied; the
               application may not alter it. */
d356 1
a356 1
            /* The value of the symbol.  This really should be a union of a
d361 1
a361 1
            /* Attributes of a symbol: */
d365 19
a383 19
            /* The symbol has local scope; `static' in `C'. The value
               is the offset into the section of the data. */
     #define BSF_LOCAL      0x01
     
            /* The symbol has global scope; initialized data in `C'. The
               value is the offset into the section of the data. */
     #define BSF_GLOBAL     0x02
     
            /* The symbol has global scope and is exported. The value is
               the offset into the section of the data. */
     #define BSF_EXPORT     BSF_GLOBAL /* no real difference */
     
            /* A normal C symbol would be one of:
               `BSF_LOCAL', `BSF_FORT_COMM',  `BSF_UNDEFINED' or
               `BSF_GLOBAL' */
     
            /* The symbol is a debugging record. The value has an arbitary
               meaning, unless BSF_DEBUGGING_RELOC is also set.  */
     #define BSF_DEBUGGING  0x08
d385 2
a386 2
            /* The symbol denotes a function entry point.  Used in ELF,
               perhaps others someday.  */
d389 1
a389 1
            /* Used by the linker. */
d393 2
a394 2
            /* A weak global symbol, overridable without warnings by
               a regular global symbol of the same name.  */
d398 1
a398 1
               STT_SECTION symbols.  */
d401 2
a402 2
            /* The symbol used to be a common symbol, but now it is
               allocated. */
d405 1
a405 1
            /* The default value for common data. */
d408 5
a412 5
            /* In some files the type of a symbol sometimes alters its
               location in an output file - ie in coff a `ISFCN' symbol
               which is also `C_EXT' symbol appears where it was
               declared and not at the end of a section.  This bit is set
               by the target BFD part to convey this information. */
d416 1
a416 1
            /* Signal that the symbol is the label of constructor section. */
d419 4
a422 4
            /* Signal that the symbol is a warning symbol.  The name is a
               warning.  The name of the next symbol is the one to warn about;
               if a reference is made to a symbol with the same name as the next
               symbol, a warning is issued by the linker. */
d425 2
a426 2
            /* Signal that the symbol is indirect.  This symbol is an indirect
               pointer to the symbol with the same name as the next symbol. */
d429 2
a430 2
            /* BSF_FILE marks symbols that contain a file name.  This is used
               for ELF STT_FILE symbols.  */
d433 2
a434 2
            /* Symbol is from dynamic linking information.  */
     #define BSF_DYNAMIC       0x8000
d438 1
a438 6
     #define BSF_OBJECT        0x10000
     
            /* This symbol is a debugging symbol.  The value is the offset
               into the section of the data.  BSF_DEBUGGING should be set
               as well.  */
     #define BSF_DEBUGGING_RELOC 0x20000
d442 2
a443 2
            /* A pointer to the section to which this symbol is
               relative.  This will always be non NULL, there are special
d447 1
a447 1
            /* Back end special data.  */
d465 1
a465 1
   *Description*
d476 1
a476 1
   *Synopsis*
a480 1

d484 1
a484 1
   *Synopsis*
d496 1
a496 1
   *Description*
d507 1
a507 1
   *Synopsis*
a511 1

d515 1
a515 1
   *Synopsis*
a518 1

d522 1
a522 1
   *Description*
d536 1
a536 1
   *Description*
d545 1
a545 1
   *Description*
d548 1
a548 2

   *Synopsis*
a550 10
`bfd_is_undefined_symclass '
............................

   *Description*
Returns non-zero if the class symbol returned by bfd_decode_symclass
represents an undefined symbol.  Returns zero otherwise.

   *Synopsis*
     boolean bfd_is_undefined_symclass (int symclass);

d557 1
a557 2

   *Synopsis*
a571 1

d574 1
a574 1
                    (ibfd, isymbol, obfd, osymbol))
d582 1
a582 1
   *Description*
a623 1

d627 1
a627 1
   *Synopsis*
a638 1

d642 1
a642 1
   *Synopsis*
a646 1

d650 1
a650 1
   *Synopsis*
a657 1

d664 2
a665 5
   A format is a BFD concept of high level file contents type. The
formats supported by BFD are:

   * `bfd_object'
   The BFD may contain data, symbols, relocations and debug info.
d667 2
a668 2
   * `bfd_archive'
   The BFD contains other BFDs and an optional index.
d670 1
a670 2
   * `bfd_core'
   The BFD contains the result of an executable core dump.
d672 1
d676 1
a676 1
   *Synopsis*
a702 1

d706 1
a706 1
   *Synopsis*
a716 1

d720 1
a720 1
   *Synopsis*
a726 1

d730 1
a730 1
   *Synopsis*
a734 1

d741 4
a744 4
   BFD maintains relocations in much the same way it maintains symbols:
they are left alone until required, then read in en-masse and
translated into an internal form.  A common routine
`bfd_perform_relocation' acts upon the canonical form to do the fixup.
d758 364
@


1.1.1.3
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d1 1
a1 1
This is bfd.info, produced by makeinfo version 4.6 from bfd.texinfo.
d9 1
a9 1
   Copyright (C) 1991, 2000, 2001, 2003 Free Software Foundation, Inc.
d11 13
a23 6
   Permission is granted to copy, distribute and/or modify this document
     under the terms of the GNU Free Documentation License, Version 1.1
     or any later version published by the Free Software Foundation;
   with no Invariant Sections, with no Front-Cover Texts, and with no
    Back-Cover Texts.  A copy of the license is included in the
section entitled "GNU Free Documentation License".
d26 1
a26 1
File: bfd.info,  Node: GNU Free Documentation License,  Next: Index,  Prev: BFD back ends,  Up: Top
d28 2
a29 2
GNU Free Documentation License
******************************
d31 553
a583 367
                        Version 1.1, March 2000
     Copyright (C) 2000, Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
     
     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.


  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     written document "free" in the sense of freedom: to assure everyone
     the effective freedom to copy and redistribute it, with or without
     modifying it, either commercially or noncommercially.  Secondarily,
     this License preserves for the author and publisher a way to get
     credit for their work, while not being considered responsible for
     modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.
     We recommend this License principally for works whose purpose is
     instruction or reference.


  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work that contains a
     notice placed by the copyright holder saying it can be distributed
     under the terms of this License.  The "Document", below, refers to
     any such manual or work.  Any member of the public is a licensee,
     and is addressed as "you."

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter
     section of the Document that deals exclusively with the
     relationship of the publishers or authors of the Document to the
     Document's overall subject (or to related matters) and contains
     nothing that could fall directly within that overall subject.
     (For example, if the Document is in part a textbook of
     mathematics, a Secondary Section may not explain any mathematics.)
     The relationship could be a matter of historical connection with
     the subject or with related matters, or of legal, commercial,
     philosophical, ethical or political position regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in
     the notice that says that the Document is released under this
     License.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, whose contents can be viewed and edited directly
     and straightforwardly with generic text editors or (for images
     composed of pixels) generic paint programs or (for drawings) some
     widely available drawing editor, and that is suitable for input to
     text formatters or for automatic translation to a variety of
     formats suitable for input to text formatters.  A copy made in an
     otherwise Transparent file format whose markup has been designed
     to thwart or discourage subsequent modification by readers is not
     Transparent.  A copy that is not "Transparent" is called "Opaque."

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and
     standard-conforming simple HTML designed for human modification.
     Opaque formats include PostScript, PDF, proprietary formats that
     can be read and edited only by proprietary word processors, SGML
     or XML for which the DTD and/or processing tools are not generally
     available, and the machine-generated HTML produced by some word
     processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow
     the conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies of the Document numbering more than
     100, and the Document's license notice requires Cover Texts, you
     must enclose the copies in covers that carry, clearly and legibly,
     all these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the
     title equally prominent and visible.  You may add other material
     on the covers in addition.  Copying with changes limited to the
     covers, as long as they preserve the title of the Document and
     satisfy these conditions, can be treated as verbatim copying in
     other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a
     machine-readable Transparent copy along with each Opaque copy, or
     state in or with each Opaque copy a publicly-accessible
     computer-network location containing a complete Transparent copy
     of the Document, free of added material, which the general
     network-using public has access to download anonymously at no
     charge using public-standard network protocols.  If you use the
     latter option, you must take reasonably prudent steps, when you
     begin distribution of Opaque copies in quantity, to ensure that
     this Transparent copy will remain thus accessible at the stated
     location until at least one year after the last time you
     distribute an Opaque copy (directly or through your agents or
     retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of
     copies, to give them a chance to provide you with an updated
     version of the Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with
     the Modified Version filling the role of the Document, thus
     licensing distribution and modification of the Modified Version to
     whoever possesses a copy of it.  In addition, you must do these
     things in the Modified Version:

     A. Use in the Title Page (and on the covers, if any) a title
     distinct    from that of the Document, and from those of previous
     versions    (which should, if there were any, be listed in the
     History section    of the Document).  You may use the same title
     as a previous version    if the original publisher of that version
     gives permission.
     B. List on the Title Page, as authors, one or more persons or
     entities    responsible for authorship of the modifications in the
     Modified    Version, together with at least five of the principal
     authors of the    Document (all of its principal authors, if it
     has less than five).
     C. State on the Title page the name of the publisher of the
     Modified Version, as the publisher.
     D. Preserve all the copyright notices of the Document.
     E. Add an appropriate copyright notice for your modifications
     adjacent to the other copyright notices.
     F. Include, immediately after the copyright notices, a license
     notice    giving the public permission to use the Modified Version
     under the    terms of this License, in the form shown in the
     Addendum below.
     G. Preserve in that license notice the full lists of Invariant
     Sections    and required Cover Texts given in the Document's
     license notice.
     H. Include an unaltered copy of this License.
     I. Preserve the section entitled "History", and its title, and add
     to    it an item stating at least the title, year, new authors, and
       publisher of the Modified Version as given on the Title Page.
     If    there is no section entitled "History" in the Document,
     create one    stating the title, year, authors, and publisher of
     the Document as    given on its Title Page, then add an item
     describing the Modified    Version as stated in the previous
     sentence.
     J. Preserve the network location, if any, given in the Document for
       public access to a Transparent copy of the Document, and
     likewise    the network locations given in the Document for
     previous versions    it was based on.  These may be placed in the
     "History" section.     You may omit a network location for a work
     that was published at    least four years before the Document
     itself, or if the original    publisher of the version it refers
     to gives permission.
     K. In any section entitled "Acknowledgements" or "Dedications",
     preserve the section's title, and preserve in the section all the
      substance and tone of each of the contributor acknowledgements
     and/or dedications given therein.
     L. Preserve all the Invariant Sections of the Document,
     unaltered in their text and in their titles.  Section numbers
     or the equivalent are not considered part of the section titles.
     M. Delete any section entitled "Endorsements."  Such a section
     may not be included in the Modified Version.
     N. Do not retitle any existing section as "Endorsements"    or to
     conflict in title with any Invariant Section.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option
     designate some or all of these sections as invariant.  To do this,
     add their titles to the list of Invariant Sections in the Modified
     Version's license notice.  These titles must be distinct from any
     other section titles.

     You may add a section entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties-for example, statements of peer review or that the text has
     been approved by an organization as the authoritative definition
     of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end
     of the list of Cover Texts in the Modified Version.  Only one
     passage of Front-Cover Text and one of Back-Cover Text may be
     added by (or through arrangements made by) any one entity.  If the
     Document already includes a cover text for the same cover,
     previously added by you or by arrangement made by the same entity
     you are acting on behalf of, you may not add another; but you may
     replace the old one, on explicit permission from the previous
     publisher that added the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination
     all of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections entitled
     "History" in the various original documents, forming one section
     entitled "History"; likewise combine any sections entitled
     "Acknowledgements", and any sections entitled "Dedications."  You
     must delete all sections entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the
     documents in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow
     this License in all other respects regarding verbatim copying of
     that document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of
     a storage or distribution medium, does not as a whole count as a
     Modified Version of the Document, provided no compilation
     copyright is claimed for the compilation.  Such a compilation is
     called an "aggregate", and this License does not apply to the
     other self-contained works thus compiled with the Document, on
     account of their being thus compiled, if they are not themselves
     derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one
     quarter of the entire aggregate, the Document's Cover Texts may be
     placed on covers that surround only the Document within the
     aggregate.  Otherwise they must appear on covers around the whole
     aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License provided that you also include the
     original English version of this License.  In case of a
     disagreement between the translation and the original English
     version of this License, the original English version will prevail.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided for under this License.  Any other
     attempt to copy, modify, sublicense or distribute the Document is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

 10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     http://www.gnu.org/copyleft/.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If
     the Document does not specify a version number of this License,
     you may choose any version ever published (not as a draft) by the
     Free Software Foundation.


ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

     Copyright (C)  YEAR  YOUR NAME.
     Permission is granted to copy, distribute and/or modify this document
     under the terms of the GNU Free Documentation License, Version 1.1
     or any later version published by the Free Software Foundation;
     with the Invariant Sections being LIST THEIR TITLES, with the
     Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
     A copy of the license is included in the section entitled "GNU
     Free Documentation License."

   If you have no Invariant Sections, write "with no Invariant Sections"
instead of saying which ones are invariant.  If you have no Front-Cover
Texts, write "no Front-Cover Texts" instead of "Front-Cover Texts being
LIST"; likewise for Back-Cover Texts.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License, to
permit their use in free software.
d586 1
a586 1
File: bfd.info,  Node: Index,  Prev: GNU Free Documentation License,  Up: Top
d588 23
a610 2
Index
*****
d614 570
a1183 995
* _bfd_final_link_relocate:              Relocating the section contents.
* _bfd_generic_link_add_archive_symbols: Adding symbols from an archive.
* _bfd_generic_link_add_one_symbol:      Adding symbols from an object file.
* _bfd_generic_make_empty_symbol:        symbol handling functions.
* _bfd_link_add_symbols in target vector: Adding Symbols to the Hash Table.
* _bfd_link_final_link in target vector: Performing the Final Link.
* _bfd_link_hash_table_create in target vector: Creating a Linker Hash Table.
* _bfd_relocate_contents:                Relocating the section contents.
* _bfd_strip_section_from_output:        section prototypes.
* aout_SIZE_machine_type:                aout.
* aout_SIZE_mkobject:                    aout.
* aout_SIZE_new_section_hook:            aout.
* aout_SIZE_set_arch_mach:               aout.
* aout_SIZE_some_aout_object_p:          aout.
* aout_SIZE_swap_exec_header_in:         aout.
* aout_SIZE_swap_exec_header_out:        aout.
* arelent_chain:                         typedef arelent.
* BFD:                                   Overview.
* BFD canonical format:                  Canonical format.
* bfd_alloc:                             Opening and Closing.
* bfd_alt_mach_code:                     BFD front end.
* bfd_arch_bits_per_address:             Architectures.
* bfd_arch_bits_per_byte:                Architectures.
* bfd_arch_get_compatible:               Architectures.
* bfd_arch_list:                         Architectures.
* bfd_arch_mach_octets_per_byte:         Architectures.
* bfd_archive_filename:                  BFD front end.
* bfd_cache_close:                       File Caching.
* bfd_cache_init:                        File Caching.
* bfd_cache_lookup:                      File Caching.
* bfd_cache_lookup_worker:               File Caching.
* BFD_CACHE_MAX_OPEN macro:              File Caching.
* bfd_calc_gnu_debuglink_crc32:          Opening and Closing.
* bfd_canonicalize_reloc:                BFD front end.
* bfd_canonicalize_symtab:               symbol handling functions.
* bfd_check_format:                      Formats.
* bfd_check_format_matches:              Formats.
* bfd_check_overflow:                    typedef arelent.
* bfd_close:                             Opening and Closing.
* bfd_close_all_done:                    Opening and Closing.
* bfd_coff_backend_data:                 coff.
* bfd_copy_private_bfd_data:             BFD front end.
* bfd_copy_private_section_data:         section prototypes.
* bfd_copy_private_symbol_data:          symbol handling functions.
* bfd_core_file_failing_command:         Core Files.
* bfd_core_file_failing_signal:          Core Files.
* bfd_create:                            Opening and Closing.
* bfd_create_gnu_debuglink_section:      Opening and Closing.
* bfd_decode_symclass:                   symbol handling functions.
* bfd_default_arch_struct:               Architectures.
* bfd_default_compatible:                Architectures.
* bfd_default_reloc_type_lookup:         howto manager.
* bfd_default_scan:                      Architectures.
* bfd_default_set_arch_mach:             Architectures.
* bfd_elf_find_section:                  elf.
* bfd_errmsg:                            BFD front end.
* bfd_fdopenr:                           Opening and Closing.
* bfd_fill_in_gnu_debuglink_section:     Opening and Closing.
* bfd_find_target:                       bfd_target.
* bfd_follow_gnu_debuglink:              Opening and Closing.
* bfd_format_string:                     Formats.
* bfd_generic_discard_group:             section prototypes.
* bfd_generic_gc_sections:               howto manager.
* bfd_generic_get_relocated_section_contents: howto manager.
* bfd_generic_merge_sections:            howto manager.
* bfd_generic_relax_section:             howto manager.
* bfd_get_arch:                          Architectures.
* bfd_get_arch_info:                     Architectures.
* bfd_get_arch_size:                     BFD front end.
* bfd_get_error:                         BFD front end.
* bfd_get_error_handler:                 BFD front end.
* bfd_get_gp_size:                       BFD front end.
* bfd_get_mach:                          Architectures.
* bfd_get_mtime:                         BFD front end.
* bfd_get_next_mapent:                   Archives.
* bfd_get_reloc_code_name:               howto manager.
* bfd_get_reloc_size:                    typedef arelent.
* bfd_get_reloc_upper_bound:             BFD front end.
* bfd_get_section_by_name:               section prototypes.
* bfd_get_section_contents:              section prototypes.
* bfd_get_sign_extend_vma:               BFD front end.
* bfd_get_size <1>:                      Internal.
* bfd_get_size:                          BFD front end.
* bfd_get_symtab_upper_bound:            symbol handling functions.
* bfd_get_unique_section_name:           section prototypes.
* bfd_h_put_size:                        Internal.
* bfd_hash_allocate:                     Creating and Freeing a Hash Table.
* bfd_hash_lookup:                       Looking Up or Entering a String.
* bfd_hash_newfunc:                      Creating and Freeing a Hash Table.
* bfd_hash_table_free:                   Creating and Freeing a Hash Table.
* bfd_hash_table_init:                   Creating and Freeing a Hash Table.
* bfd_hash_table_init_n:                 Creating and Freeing a Hash Table.
* bfd_hash_traverse:                     Traversing a Hash Table.
* bfd_init:                              Initialization.
* bfd_install_relocation:                typedef arelent.
* bfd_is_local_label:                    symbol handling functions.
* bfd_is_local_label_name:               symbol handling functions.
* bfd_is_undefined_symclass:             symbol handling functions.
* bfd_last_cache:                        File Caching.
* bfd_link_split_section:                Writing the symbol table.
* bfd_log2:                              Internal.
* bfd_lookup_arch:                       Architectures.
* bfd_make_debug_symbol:                 symbol handling functions.
* bfd_make_empty_symbol:                 symbol handling functions.
* bfd_make_readable:                     Opening and Closing.
* bfd_make_section:                      section prototypes.
* bfd_make_section_anyway:               section prototypes.
* bfd_make_section_old_way:              section prototypes.
* bfd_make_writable:                     Opening and Closing.
* bfd_map_over_sections:                 section prototypes.
* bfd_merge_private_bfd_data:            BFD front end.
* bfd_octets_per_byte:                   Architectures.
* bfd_open_file:                         File Caching.
* bfd_openr:                             Opening and Closing.
* bfd_openr_next_archived_file:          Archives.
* bfd_openstreamr:                       Opening and Closing.
* bfd_openw:                             Opening and Closing.
* bfd_perform_relocation:                typedef arelent.
* bfd_perror:                            BFD front end.
* bfd_preserve_finish:                   BFD front end.
* bfd_preserve_restore:                  BFD front end.
* bfd_preserve_save:                     BFD front end.
* bfd_print_symbol_vandf:                symbol handling functions.
* bfd_printable_arch_mach:               Architectures.
* bfd_printable_name:                    Architectures.
* bfd_put_size:                          Internal.
* BFD_RELOC_12_PCREL:                    howto manager.
* BFD_RELOC_14:                          howto manager.
* BFD_RELOC_16:                          howto manager.
* BFD_RELOC_16_BASEREL:                  howto manager.
* BFD_RELOC_16_GOT_PCREL:                howto manager.
* BFD_RELOC_16_GOTOFF:                   howto manager.
* BFD_RELOC_16_PCREL:                    howto manager.
* BFD_RELOC_16_PCREL_S2:                 howto manager.
* BFD_RELOC_16_PLT_PCREL:                howto manager.
* BFD_RELOC_16_PLTOFF:                   howto manager.
* BFD_RELOC_23_PCREL_S2:                 howto manager.
* BFD_RELOC_24:                          howto manager.
* BFD_RELOC_24_PCREL:                    howto manager.
* BFD_RELOC_24_PLT_PCREL:                howto manager.
* BFD_RELOC_26:                          howto manager.
* BFD_RELOC_32:                          howto manager.
* BFD_RELOC_32_BASEREL:                  howto manager.
* BFD_RELOC_32_GOT_PCREL:                howto manager.
* BFD_RELOC_32_GOTOFF:                   howto manager.
* BFD_RELOC_32_PCREL:                    howto manager.
* BFD_RELOC_32_PCREL_S2:                 howto manager.
* BFD_RELOC_32_PLT_PCREL:                howto manager.
* BFD_RELOC_32_PLTOFF:                   howto manager.
* BFD_RELOC_386_COPY:                    howto manager.
* BFD_RELOC_386_GLOB_DAT:                howto manager.
* BFD_RELOC_386_GOT32:                   howto manager.
* BFD_RELOC_386_GOTOFF:                  howto manager.
* BFD_RELOC_386_GOTPC:                   howto manager.
* BFD_RELOC_386_JUMP_SLOT:               howto manager.
* BFD_RELOC_386_PLT32:                   howto manager.
* BFD_RELOC_386_RELATIVE:                howto manager.
* BFD_RELOC_386_TLS_DTPMOD32:            howto manager.
* BFD_RELOC_386_TLS_DTPOFF32:            howto manager.
* BFD_RELOC_386_TLS_GD:                  howto manager.
* BFD_RELOC_386_TLS_GOTIE:               howto manager.
* BFD_RELOC_386_TLS_IE:                  howto manager.
* BFD_RELOC_386_TLS_IE_32:               howto manager.
* BFD_RELOC_386_TLS_LDM:                 howto manager.
* BFD_RELOC_386_TLS_LDO_32:              howto manager.
* BFD_RELOC_386_TLS_LE:                  howto manager.
* BFD_RELOC_386_TLS_LE_32:               howto manager.
* BFD_RELOC_386_TLS_TPOFF:               howto manager.
* BFD_RELOC_386_TLS_TPOFF32:             howto manager.
* BFD_RELOC_390_12:                      howto manager.
* BFD_RELOC_390_20:                      howto manager.
* BFD_RELOC_390_COPY:                    howto manager.
* BFD_RELOC_390_GLOB_DAT:                howto manager.
* BFD_RELOC_390_GOT12:                   howto manager.
* BFD_RELOC_390_GOT16:                   howto manager.
* BFD_RELOC_390_GOT20:                   howto manager.
* BFD_RELOC_390_GOT64:                   howto manager.
* BFD_RELOC_390_GOTENT:                  howto manager.
* BFD_RELOC_390_GOTOFF64:                howto manager.
* BFD_RELOC_390_GOTPC:                   howto manager.
* BFD_RELOC_390_GOTPCDBL:                howto manager.
* BFD_RELOC_390_GOTPLT12:                howto manager.
* BFD_RELOC_390_GOTPLT16:                howto manager.
* BFD_RELOC_390_GOTPLT20:                howto manager.
* BFD_RELOC_390_GOTPLT32:                howto manager.
* BFD_RELOC_390_GOTPLT64:                howto manager.
* BFD_RELOC_390_GOTPLTENT:               howto manager.
* BFD_RELOC_390_JMP_SLOT:                howto manager.
* BFD_RELOC_390_PC16DBL:                 howto manager.
* BFD_RELOC_390_PC32DBL:                 howto manager.
* BFD_RELOC_390_PLT16DBL:                howto manager.
* BFD_RELOC_390_PLT32:                   howto manager.
* BFD_RELOC_390_PLT32DBL:                howto manager.
* BFD_RELOC_390_PLT64:                   howto manager.
* BFD_RELOC_390_PLTOFF16:                howto manager.
* BFD_RELOC_390_PLTOFF32:                howto manager.
* BFD_RELOC_390_PLTOFF64:                howto manager.
* BFD_RELOC_390_RELATIVE:                howto manager.
* BFD_RELOC_390_TLS_DTPMOD:              howto manager.
* BFD_RELOC_390_TLS_DTPOFF:              howto manager.
* BFD_RELOC_390_TLS_GD32:                howto manager.
* BFD_RELOC_390_TLS_GD64:                howto manager.
* BFD_RELOC_390_TLS_GDCALL:              howto manager.
* BFD_RELOC_390_TLS_GOTIE12:             howto manager.
* BFD_RELOC_390_TLS_GOTIE20:             howto manager.
* BFD_RELOC_390_TLS_GOTIE32:             howto manager.
* BFD_RELOC_390_TLS_GOTIE64:             howto manager.
* BFD_RELOC_390_TLS_IE32:                howto manager.
* BFD_RELOC_390_TLS_IE64:                howto manager.
* BFD_RELOC_390_TLS_IEENT:               howto manager.
* BFD_RELOC_390_TLS_LDCALL:              howto manager.
* BFD_RELOC_390_TLS_LDM32:               howto manager.
* BFD_RELOC_390_TLS_LDM64:               howto manager.
* BFD_RELOC_390_TLS_LDO32:               howto manager.
* BFD_RELOC_390_TLS_LDO64:               howto manager.
* BFD_RELOC_390_TLS_LE32:                howto manager.
* BFD_RELOC_390_TLS_LE64:                howto manager.
* BFD_RELOC_390_TLS_LOAD:                howto manager.
* BFD_RELOC_390_TLS_TPOFF:               howto manager.
* BFD_RELOC_64:                          howto manager.
* BFD_RELOC_64_PCREL:                    howto manager.
* BFD_RELOC_64_PLT_PCREL:                howto manager.
* BFD_RELOC_64_PLTOFF:                   howto manager.
* BFD_RELOC_68K_GLOB_DAT:                howto manager.
* BFD_RELOC_68K_JMP_SLOT:                howto manager.
* BFD_RELOC_68K_RELATIVE:                howto manager.
* BFD_RELOC_8:                           howto manager.
* BFD_RELOC_860_COPY:                    howto manager.
* BFD_RELOC_860_GLOB_DAT:                howto manager.
* BFD_RELOC_860_HAGOT:                   howto manager.
* BFD_RELOC_860_HAGOTOFF:                howto manager.
* BFD_RELOC_860_HAPC:                    howto manager.
* BFD_RELOC_860_HIGH:                    howto manager.
* BFD_RELOC_860_HIGHADJ:                 howto manager.
* BFD_RELOC_860_HIGOT:                   howto manager.
* BFD_RELOC_860_HIGOTOFF:                howto manager.
* BFD_RELOC_860_JUMP_SLOT:               howto manager.
* BFD_RELOC_860_LOGOT0:                  howto manager.
* BFD_RELOC_860_LOGOT1:                  howto manager.
* BFD_RELOC_860_LOGOTOFF0:               howto manager.
* BFD_RELOC_860_LOGOTOFF1:               howto manager.
* BFD_RELOC_860_LOGOTOFF2:               howto manager.
* BFD_RELOC_860_LOGOTOFF3:               howto manager.
* BFD_RELOC_860_LOPC:                    howto manager.
* BFD_RELOC_860_LOW0:                    howto manager.
* BFD_RELOC_860_LOW1:                    howto manager.
* BFD_RELOC_860_LOW2:                    howto manager.
* BFD_RELOC_860_LOW3:                    howto manager.
* BFD_RELOC_860_PC16:                    howto manager.
* BFD_RELOC_860_PC26:                    howto manager.
* BFD_RELOC_860_PLT26:                   howto manager.
* BFD_RELOC_860_RELATIVE:                howto manager.
* BFD_RELOC_860_SPGOT0:                  howto manager.
* BFD_RELOC_860_SPGOT1:                  howto manager.
* BFD_RELOC_860_SPGOTOFF0:               howto manager.
* BFD_RELOC_860_SPGOTOFF1:               howto manager.
* BFD_RELOC_860_SPLIT0:                  howto manager.
* BFD_RELOC_860_SPLIT1:                  howto manager.
* BFD_RELOC_860_SPLIT2:                  howto manager.
* BFD_RELOC_8_BASEREL:                   howto manager.
* BFD_RELOC_8_FFnn:                      howto manager.
* BFD_RELOC_8_GOT_PCREL:                 howto manager.
* BFD_RELOC_8_GOTOFF:                    howto manager.
* BFD_RELOC_8_PCREL:                     howto manager.
* BFD_RELOC_8_PLT_PCREL:                 howto manager.
* BFD_RELOC_8_PLTOFF:                    howto manager.
* BFD_RELOC_ALPHA_BRSGP:                 howto manager.
* BFD_RELOC_ALPHA_CODEADDR:              howto manager.
* BFD_RELOC_ALPHA_DTPMOD64:              howto manager.
* BFD_RELOC_ALPHA_DTPREL16:              howto manager.
* BFD_RELOC_ALPHA_DTPREL64:              howto manager.
* BFD_RELOC_ALPHA_DTPREL_HI16:           howto manager.
* BFD_RELOC_ALPHA_DTPREL_LO16:           howto manager.
* BFD_RELOC_ALPHA_ELF_LITERAL:           howto manager.
* BFD_RELOC_ALPHA_GOTDTPREL16:           howto manager.
* BFD_RELOC_ALPHA_GOTTPREL16:            howto manager.
* BFD_RELOC_ALPHA_GPDISP:                howto manager.
* BFD_RELOC_ALPHA_GPDISP_HI16:           howto manager.
* BFD_RELOC_ALPHA_GPDISP_LO16:           howto manager.
* BFD_RELOC_ALPHA_GPREL_HI16:            howto manager.
* BFD_RELOC_ALPHA_GPREL_LO16:            howto manager.
* BFD_RELOC_ALPHA_HINT:                  howto manager.
* BFD_RELOC_ALPHA_LINKAGE:               howto manager.
* BFD_RELOC_ALPHA_LITERAL:               howto manager.
* BFD_RELOC_ALPHA_LITUSE:                howto manager.
* BFD_RELOC_ALPHA_TLSGD:                 howto manager.
* BFD_RELOC_ALPHA_TLSLDM:                howto manager.
* BFD_RELOC_ALPHA_TPREL16:               howto manager.
* BFD_RELOC_ALPHA_TPREL64:               howto manager.
* BFD_RELOC_ALPHA_TPREL_HI16:            howto manager.
* BFD_RELOC_ALPHA_TPREL_LO16:            howto manager.
* BFD_RELOC_ARC_B22_PCREL:               howto manager.
* BFD_RELOC_ARC_B26:                     howto manager.
* BFD_RELOC_ARM_ADR_IMM:                 howto manager.
* BFD_RELOC_ARM_ADRL_IMMEDIATE:          howto manager.
* BFD_RELOC_ARM_COPY:                    howto manager.
* BFD_RELOC_ARM_CP_OFF_IMM:              howto manager.
* BFD_RELOC_ARM_CP_OFF_IMM_S2:           howto manager.
* BFD_RELOC_ARM_GLOB_DAT:                howto manager.
* BFD_RELOC_ARM_GOT12:                   howto manager.
* BFD_RELOC_ARM_GOT32:                   howto manager.
* BFD_RELOC_ARM_GOTOFF:                  howto manager.
* BFD_RELOC_ARM_GOTPC:                   howto manager.
* BFD_RELOC_ARM_HWLITERAL:               howto manager.
* BFD_RELOC_ARM_IMMEDIATE:               howto manager.
* BFD_RELOC_ARM_IN_POOL:                 howto manager.
* BFD_RELOC_ARM_JUMP_SLOT:               howto manager.
* BFD_RELOC_ARM_LDR_IMM:                 howto manager.
* BFD_RELOC_ARM_LITERAL:                 howto manager.
* BFD_RELOC_ARM_MULTI:                   howto manager.
* BFD_RELOC_ARM_OFFSET_IMM:              howto manager.
* BFD_RELOC_ARM_OFFSET_IMM8:             howto manager.
* BFD_RELOC_ARM_PCREL_BLX:               howto manager.
* BFD_RELOC_ARM_PCREL_BRANCH:            howto manager.
* BFD_RELOC_ARM_PLT32:                   howto manager.
* BFD_RELOC_ARM_RELATIVE:                howto manager.
* BFD_RELOC_ARM_SHIFT_IMM:               howto manager.
* BFD_RELOC_ARM_SWI:                     howto manager.
* BFD_RELOC_ARM_THUMB_ADD:               howto manager.
* BFD_RELOC_ARM_THUMB_IMM:               howto manager.
* BFD_RELOC_ARM_THUMB_OFFSET:            howto manager.
* BFD_RELOC_ARM_THUMB_SHIFT:             howto manager.
* BFD_RELOC_AVR_13_PCREL:                howto manager.
* BFD_RELOC_AVR_16_PM:                   howto manager.
* BFD_RELOC_AVR_7_PCREL:                 howto manager.
* BFD_RELOC_AVR_CALL:                    howto manager.
* BFD_RELOC_AVR_HH8_LDI:                 howto manager.
* BFD_RELOC_AVR_HH8_LDI_NEG:             howto manager.
* BFD_RELOC_AVR_HH8_LDI_PM:              howto manager.
* BFD_RELOC_AVR_HH8_LDI_PM_NEG:          howto manager.
* BFD_RELOC_AVR_HI8_LDI:                 howto manager.
* BFD_RELOC_AVR_HI8_LDI_NEG:             howto manager.
* BFD_RELOC_AVR_HI8_LDI_PM:              howto manager.
* BFD_RELOC_AVR_HI8_LDI_PM_NEG:          howto manager.
* BFD_RELOC_AVR_LO8_LDI:                 howto manager.
* BFD_RELOC_AVR_LO8_LDI_NEG:             howto manager.
* BFD_RELOC_AVR_LO8_LDI_PM:              howto manager.
* BFD_RELOC_AVR_LO8_LDI_PM_NEG:          howto manager.
* bfd_reloc_code_type:                   howto manager.
* BFD_RELOC_CRIS_16_GOT:                 howto manager.
* BFD_RELOC_CRIS_16_GOTPLT:              howto manager.
* BFD_RELOC_CRIS_32_GOT:                 howto manager.
* BFD_RELOC_CRIS_32_GOTPLT:              howto manager.
* BFD_RELOC_CRIS_32_GOTREL:              howto manager.
* BFD_RELOC_CRIS_32_PLT_GOTREL:          howto manager.
* BFD_RELOC_CRIS_32_PLT_PCREL:           howto manager.
* BFD_RELOC_CRIS_BDISP8:                 howto manager.
* BFD_RELOC_CRIS_COPY:                   howto manager.
* BFD_RELOC_CRIS_GLOB_DAT:               howto manager.
* BFD_RELOC_CRIS_JUMP_SLOT:              howto manager.
* BFD_RELOC_CRIS_RELATIVE:               howto manager.
* BFD_RELOC_CRIS_SIGNED_6:               howto manager.
* BFD_RELOC_CRIS_UNSIGNED_4:             howto manager.
* BFD_RELOC_CRIS_UNSIGNED_5:             howto manager.
* BFD_RELOC_CRIS_UNSIGNED_6:             howto manager.
* BFD_RELOC_CTOR:                        howto manager.
* BFD_RELOC_D10V_10_PCREL_L:             howto manager.
* BFD_RELOC_D10V_10_PCREL_R:             howto manager.
* BFD_RELOC_D10V_18:                     howto manager.
* BFD_RELOC_D10V_18_PCREL:               howto manager.
* BFD_RELOC_D30V_15:                     howto manager.
* BFD_RELOC_D30V_15_PCREL:               howto manager.
* BFD_RELOC_D30V_15_PCREL_R:             howto manager.
* BFD_RELOC_D30V_21:                     howto manager.
* BFD_RELOC_D30V_21_PCREL:               howto manager.
* BFD_RELOC_D30V_21_PCREL_R:             howto manager.
* BFD_RELOC_D30V_32:                     howto manager.
* BFD_RELOC_D30V_32_PCREL:               howto manager.
* BFD_RELOC_D30V_6:                      howto manager.
* BFD_RELOC_D30V_9_PCREL:                howto manager.
* BFD_RELOC_D30V_9_PCREL_R:              howto manager.
* BFD_RELOC_DLX_HI16_S:                  howto manager.
* BFD_RELOC_DLX_JMP26:                   howto manager.
* BFD_RELOC_DLX_LO16:                    howto manager.
* BFD_RELOC_FR30_10_IN_8:                howto manager.
* BFD_RELOC_FR30_12_PCREL:               howto manager.
* BFD_RELOC_FR30_20:                     howto manager.
* BFD_RELOC_FR30_48:                     howto manager.
* BFD_RELOC_FR30_6_IN_4:                 howto manager.
* BFD_RELOC_FR30_8_IN_8:                 howto manager.
* BFD_RELOC_FR30_9_IN_8:                 howto manager.
* BFD_RELOC_FR30_9_PCREL:                howto manager.
* BFD_RELOC_FRV_FUNCDESC:                howto manager.
* BFD_RELOC_FRV_FUNCDESC_GOT12:          howto manager.
* BFD_RELOC_FRV_FUNCDESC_GOTHI:          howto manager.
* BFD_RELOC_FRV_FUNCDESC_GOTLO:          howto manager.
* BFD_RELOC_FRV_FUNCDESC_GOTOFF12:       howto manager.
* BFD_RELOC_FRV_FUNCDESC_GOTOFFHI:       howto manager.
* BFD_RELOC_FRV_FUNCDESC_GOTOFFLO:       howto manager.
* BFD_RELOC_FRV_FUNCDESC_VALUE:          howto manager.
* BFD_RELOC_FRV_GOT12:                   howto manager.
* BFD_RELOC_FRV_GOTHI:                   howto manager.
* BFD_RELOC_FRV_GOTLO:                   howto manager.
* BFD_RELOC_FRV_GOTOFF12:                howto manager.
* BFD_RELOC_FRV_GOTOFFHI:                howto manager.
* BFD_RELOC_FRV_GOTOFFLO:                howto manager.
* BFD_RELOC_FRV_GPREL12:                 howto manager.
* BFD_RELOC_FRV_GPREL32:                 howto manager.
* BFD_RELOC_FRV_GPRELHI:                 howto manager.
* BFD_RELOC_FRV_GPRELLO:                 howto manager.
* BFD_RELOC_FRV_GPRELU12:                howto manager.
* BFD_RELOC_FRV_HI16:                    howto manager.
* BFD_RELOC_FRV_LABEL16:                 howto manager.
* BFD_RELOC_FRV_LABEL24:                 howto manager.
* BFD_RELOC_FRV_LO16:                    howto manager.
* BFD_RELOC_GPREL16:                     howto manager.
* BFD_RELOC_GPREL32:                     howto manager.
* BFD_RELOC_H8_DIR16A8:                  howto manager.
* BFD_RELOC_H8_DIR16R8:                  howto manager.
* BFD_RELOC_H8_DIR24A8:                  howto manager.
* BFD_RELOC_H8_DIR24R8:                  howto manager.
* BFD_RELOC_H8_DIR32A16:                 howto manager.
* BFD_RELOC_HI16:                        howto manager.
* BFD_RELOC_HI16_BASEREL:                howto manager.
* BFD_RELOC_HI16_GOTOFF:                 howto manager.
* BFD_RELOC_HI16_PLTOFF:                 howto manager.
* BFD_RELOC_HI16_S:                      howto manager.
* BFD_RELOC_HI16_S_BASEREL:              howto manager.
* BFD_RELOC_HI16_S_GOTOFF:               howto manager.
* BFD_RELOC_HI16_S_PLTOFF:               howto manager.
* BFD_RELOC_HI22:                        howto manager.
* BFD_RELOC_I370_D12:                    howto manager.
* BFD_RELOC_I960_CALLJ:                  howto manager.
* BFD_RELOC_IA64_COPY:                   howto manager.
* BFD_RELOC_IA64_DIR32LSB:               howto manager.
* BFD_RELOC_IA64_DIR32MSB:               howto manager.
* BFD_RELOC_IA64_DIR64LSB:               howto manager.
* BFD_RELOC_IA64_DIR64MSB:               howto manager.
* BFD_RELOC_IA64_DTPMOD64LSB:            howto manager.
* BFD_RELOC_IA64_DTPMOD64MSB:            howto manager.
* BFD_RELOC_IA64_DTPREL14:               howto manager.
* BFD_RELOC_IA64_DTPREL22:               howto manager.
* BFD_RELOC_IA64_DTPREL32LSB:            howto manager.
* BFD_RELOC_IA64_DTPREL32MSB:            howto manager.
* BFD_RELOC_IA64_DTPREL64I:              howto manager.
* BFD_RELOC_IA64_DTPREL64LSB:            howto manager.
* BFD_RELOC_IA64_DTPREL64MSB:            howto manager.
* BFD_RELOC_IA64_FPTR32LSB:              howto manager.
* BFD_RELOC_IA64_FPTR32MSB:              howto manager.
* BFD_RELOC_IA64_FPTR64I:                howto manager.
* BFD_RELOC_IA64_FPTR64LSB:              howto manager.
* BFD_RELOC_IA64_FPTR64MSB:              howto manager.
* BFD_RELOC_IA64_GPREL22:                howto manager.
* BFD_RELOC_IA64_GPREL32LSB:             howto manager.
* BFD_RELOC_IA64_GPREL32MSB:             howto manager.
* BFD_RELOC_IA64_GPREL64I:               howto manager.
* BFD_RELOC_IA64_GPREL64LSB:             howto manager.
* BFD_RELOC_IA64_GPREL64MSB:             howto manager.
* BFD_RELOC_IA64_IMM14:                  howto manager.
* BFD_RELOC_IA64_IMM22:                  howto manager.
* BFD_RELOC_IA64_IMM64:                  howto manager.
* BFD_RELOC_IA64_IPLTLSB:                howto manager.
* BFD_RELOC_IA64_IPLTMSB:                howto manager.
* BFD_RELOC_IA64_LDXMOV:                 howto manager.
* BFD_RELOC_IA64_LTOFF22:                howto manager.
* BFD_RELOC_IA64_LTOFF22X:               howto manager.
* BFD_RELOC_IA64_LTOFF64I:               howto manager.
* BFD_RELOC_IA64_LTOFF_DTPMOD22:         howto manager.
* BFD_RELOC_IA64_LTOFF_DTPREL22:         howto manager.
* BFD_RELOC_IA64_LTOFF_FPTR22:           howto manager.
* BFD_RELOC_IA64_LTOFF_FPTR32LSB:        howto manager.
* BFD_RELOC_IA64_LTOFF_FPTR32MSB:        howto manager.
* BFD_RELOC_IA64_LTOFF_FPTR64I:          howto manager.
* BFD_RELOC_IA64_LTOFF_FPTR64LSB:        howto manager.
* BFD_RELOC_IA64_LTOFF_FPTR64MSB:        howto manager.
* BFD_RELOC_IA64_LTOFF_TPREL22:          howto manager.
* BFD_RELOC_IA64_LTV32LSB:               howto manager.
* BFD_RELOC_IA64_LTV32MSB:               howto manager.
* BFD_RELOC_IA64_LTV64LSB:               howto manager.
* BFD_RELOC_IA64_LTV64MSB:               howto manager.
* BFD_RELOC_IA64_PCREL21B:               howto manager.
* BFD_RELOC_IA64_PCREL21BI:              howto manager.
* BFD_RELOC_IA64_PCREL21F:               howto manager.
* BFD_RELOC_IA64_PCREL21M:               howto manager.
* BFD_RELOC_IA64_PCREL22:                howto manager.
* BFD_RELOC_IA64_PCREL32LSB:             howto manager.
* BFD_RELOC_IA64_PCREL32MSB:             howto manager.
* BFD_RELOC_IA64_PCREL60B:               howto manager.
* BFD_RELOC_IA64_PCREL64I:               howto manager.
* BFD_RELOC_IA64_PCREL64LSB:             howto manager.
* BFD_RELOC_IA64_PCREL64MSB:             howto manager.
* BFD_RELOC_IA64_PLTOFF22:               howto manager.
* BFD_RELOC_IA64_PLTOFF64I:              howto manager.
* BFD_RELOC_IA64_PLTOFF64LSB:            howto manager.
* BFD_RELOC_IA64_PLTOFF64MSB:            howto manager.
* BFD_RELOC_IA64_REL32LSB:               howto manager.
* BFD_RELOC_IA64_REL32MSB:               howto manager.
* BFD_RELOC_IA64_REL64LSB:               howto manager.
* BFD_RELOC_IA64_REL64MSB:               howto manager.
* BFD_RELOC_IA64_SECREL32LSB:            howto manager.
* BFD_RELOC_IA64_SECREL32MSB:            howto manager.
* BFD_RELOC_IA64_SECREL64LSB:            howto manager.
* BFD_RELOC_IA64_SECREL64MSB:            howto manager.
* BFD_RELOC_IA64_SEGREL32LSB:            howto manager.
* BFD_RELOC_IA64_SEGREL32MSB:            howto manager.
* BFD_RELOC_IA64_SEGREL64LSB:            howto manager.
* BFD_RELOC_IA64_SEGREL64MSB:            howto manager.
* BFD_RELOC_IA64_TPREL14:                howto manager.
* BFD_RELOC_IA64_TPREL22:                howto manager.
* BFD_RELOC_IA64_TPREL64I:               howto manager.
* BFD_RELOC_IA64_TPREL64LSB:             howto manager.
* BFD_RELOC_IA64_TPREL64MSB:             howto manager.
* BFD_RELOC_IP2K_ADDR16CJP:              howto manager.
* BFD_RELOC_IP2K_BANK:                   howto manager.
* BFD_RELOC_IP2K_EX8DATA:                howto manager.
* BFD_RELOC_IP2K_FR9:                    howto manager.
* BFD_RELOC_IP2K_FR_OFFSET:              howto manager.
* BFD_RELOC_IP2K_HI8DATA:                howto manager.
* BFD_RELOC_IP2K_HI8INSN:                howto manager.
* BFD_RELOC_IP2K_LO8DATA:                howto manager.
* BFD_RELOC_IP2K_LO8INSN:                howto manager.
* BFD_RELOC_IP2K_PAGE3:                  howto manager.
* BFD_RELOC_IP2K_PC_SKIP:                howto manager.
* BFD_RELOC_IP2K_TEXT:                   howto manager.
* BFD_RELOC_IQ2000_OFFSET_16:            howto manager.
* BFD_RELOC_IQ2000_OFFSET_21:            howto manager.
* BFD_RELOC_IQ2000_UHI16:                howto manager.
* BFD_RELOC_LO10:                        howto manager.
* BFD_RELOC_LO16:                        howto manager.
* BFD_RELOC_LO16_BASEREL:                howto manager.
* BFD_RELOC_LO16_GOTOFF:                 howto manager.
* BFD_RELOC_LO16_PLTOFF:                 howto manager.
* BFD_RELOC_M32R_10_PCREL:               howto manager.
* BFD_RELOC_M32R_18_PCREL:               howto manager.
* BFD_RELOC_M32R_24:                     howto manager.
* BFD_RELOC_M32R_26_PCREL:               howto manager.
* BFD_RELOC_M32R_26_PLTREL:              howto manager.
* BFD_RELOC_M32R_COPY:                   howto manager.
* BFD_RELOC_M32R_GLOB_DAT:               howto manager.
* BFD_RELOC_M32R_GOT16_HI_SLO:           howto manager.
* BFD_RELOC_M32R_GOT16_HI_ULO:           howto manager.
* BFD_RELOC_M32R_GOT16_LO:               howto manager.
* BFD_RELOC_M32R_GOT24:                  howto manager.
* BFD_RELOC_M32R_GOTOFF:                 howto manager.
* BFD_RELOC_M32R_GOTPC24:                howto manager.
* BFD_RELOC_M32R_GOTPC_HI_SLO:           howto manager.
* BFD_RELOC_M32R_GOTPC_HI_ULO:           howto manager.
* BFD_RELOC_M32R_GOTPC_LO:               howto manager.
* BFD_RELOC_M32R_HI16_SLO:               howto manager.
* BFD_RELOC_M32R_HI16_ULO:               howto manager.
* BFD_RELOC_M32R_JMP_SLOT:               howto manager.
* BFD_RELOC_M32R_LO16:                   howto manager.
* BFD_RELOC_M32R_RELATIVE:               howto manager.
* BFD_RELOC_M32R_SDA16:                  howto manager.
* BFD_RELOC_M68HC11_24:                  howto manager.
* BFD_RELOC_M68HC11_3B:                  howto manager.
* BFD_RELOC_M68HC11_HI8:                 howto manager.
* BFD_RELOC_M68HC11_LO16:                howto manager.
* BFD_RELOC_M68HC11_LO8:                 howto manager.
* BFD_RELOC_M68HC11_PAGE:                howto manager.
* BFD_RELOC_M68HC11_RL_GROUP:            howto manager.
* BFD_RELOC_M68HC11_RL_JUMP:             howto manager.
* BFD_RELOC_M68HC12_5B:                  howto manager.
* BFD_RELOC_MCORE_PCREL_32:              howto manager.
* BFD_RELOC_MCORE_PCREL_IMM11BY2:        howto manager.
* BFD_RELOC_MCORE_PCREL_IMM4BY2:         howto manager.
* BFD_RELOC_MCORE_PCREL_IMM8BY4:         howto manager.
* BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2:    howto manager.
* BFD_RELOC_MCORE_RVA:                   howto manager.
* BFD_RELOC_MIPS16_GPREL:                howto manager.
* BFD_RELOC_MIPS16_JMP:                  howto manager.
* BFD_RELOC_MIPS_CALL16:                 howto manager.
* BFD_RELOC_MIPS_CALL_HI16:              howto manager.
* BFD_RELOC_MIPS_CALL_LO16:              howto manager.
* BFD_RELOC_MIPS_DELETE:                 howto manager.
* BFD_RELOC_MIPS_GOT16:                  howto manager.
* BFD_RELOC_MIPS_GOT_DISP:               howto manager.
* BFD_RELOC_MIPS_GOT_HI16:               howto manager.
* BFD_RELOC_MIPS_GOT_LO16:               howto manager.
* BFD_RELOC_MIPS_GOT_OFST:               howto manager.
* BFD_RELOC_MIPS_GOT_PAGE:               howto manager.
* BFD_RELOC_MIPS_HIGHER:                 howto manager.
* BFD_RELOC_MIPS_HIGHEST:                howto manager.
* BFD_RELOC_MIPS_INSERT_A:               howto manager.
* BFD_RELOC_MIPS_INSERT_B:               howto manager.
* BFD_RELOC_MIPS_JALR:                   howto manager.
* BFD_RELOC_MIPS_JMP:                    howto manager.
* BFD_RELOC_MIPS_LITERAL:                howto manager.
* BFD_RELOC_MIPS_REL16:                  howto manager.
* BFD_RELOC_MIPS_RELGOT:                 howto manager.
* BFD_RELOC_MIPS_SCN_DISP:               howto manager.
* BFD_RELOC_MIPS_SHIFT5:                 howto manager.
* BFD_RELOC_MIPS_SHIFT6:                 howto manager.
* BFD_RELOC_MIPS_SUB:                    howto manager.
* BFD_RELOC_MMIX_ADDR19:                 howto manager.
* BFD_RELOC_MMIX_ADDR27:                 howto manager.
* BFD_RELOC_MMIX_BASE_PLUS_OFFSET:       howto manager.
* BFD_RELOC_MMIX_CBRANCH:                howto manager.
* BFD_RELOC_MMIX_CBRANCH_1:              howto manager.
* BFD_RELOC_MMIX_CBRANCH_2:              howto manager.
* BFD_RELOC_MMIX_CBRANCH_3:              howto manager.
* BFD_RELOC_MMIX_CBRANCH_J:              howto manager.
* BFD_RELOC_MMIX_GETA:                   howto manager.
* BFD_RELOC_MMIX_GETA_1:                 howto manager.
* BFD_RELOC_MMIX_GETA_2:                 howto manager.
* BFD_RELOC_MMIX_GETA_3:                 howto manager.
* BFD_RELOC_MMIX_JMP:                    howto manager.
* BFD_RELOC_MMIX_JMP_1:                  howto manager.
* BFD_RELOC_MMIX_JMP_2:                  howto manager.
* BFD_RELOC_MMIX_JMP_3:                  howto manager.
* BFD_RELOC_MMIX_LOCAL:                  howto manager.
* BFD_RELOC_MMIX_PUSHJ:                  howto manager.
* BFD_RELOC_MMIX_PUSHJ_1:                howto manager.
* BFD_RELOC_MMIX_PUSHJ_2:                howto manager.
* BFD_RELOC_MMIX_PUSHJ_3:                howto manager.
* BFD_RELOC_MMIX_PUSHJ_STUBBABLE:        howto manager.
* BFD_RELOC_MMIX_REG:                    howto manager.
* BFD_RELOC_MMIX_REG_OR_BYTE:            howto manager.
* BFD_RELOC_MN10300_16_PCREL:            howto manager.
* BFD_RELOC_MN10300_32_PCREL:            howto manager.
* BFD_RELOC_MN10300_COPY:                howto manager.
* BFD_RELOC_MN10300_GLOB_DAT:            howto manager.
* BFD_RELOC_MN10300_GOT16:               howto manager.
* BFD_RELOC_MN10300_GOT24:               howto manager.
* BFD_RELOC_MN10300_GOT32:               howto manager.
* BFD_RELOC_MN10300_GOTOFF24:            howto manager.
* BFD_RELOC_MN10300_JMP_SLOT:            howto manager.
* BFD_RELOC_MN10300_RELATIVE:            howto manager.
* BFD_RELOC_MSP430_10_PCREL:             howto manager.
* BFD_RELOC_MSP430_16:                   howto manager.
* BFD_RELOC_MSP430_16_BYTE:              howto manager.
* BFD_RELOC_MSP430_16_PCREL:             howto manager.
* BFD_RELOC_MSP430_16_PCREL_BYTE:        howto manager.
* BFD_RELOC_NONE:                        howto manager.
* BFD_RELOC_NS32K_DISP_16:               howto manager.
* BFD_RELOC_NS32K_DISP_16_PCREL:         howto manager.
* BFD_RELOC_NS32K_DISP_32:               howto manager.
* BFD_RELOC_NS32K_DISP_32_PCREL:         howto manager.
* BFD_RELOC_NS32K_DISP_8:                howto manager.
* BFD_RELOC_NS32K_DISP_8_PCREL:          howto manager.
* BFD_RELOC_NS32K_IMM_16:                howto manager.
* BFD_RELOC_NS32K_IMM_16_PCREL:          howto manager.
* BFD_RELOC_NS32K_IMM_32:                howto manager.
* BFD_RELOC_NS32K_IMM_32_PCREL:          howto manager.
* BFD_RELOC_NS32K_IMM_8:                 howto manager.
* BFD_RELOC_NS32K_IMM_8_PCREL:           howto manager.
* BFD_RELOC_OPENRISC_ABS_26:             howto manager.
* BFD_RELOC_OPENRISC_REL_26:             howto manager.
* BFD_RELOC_PCREL_HI16_S:                howto manager.
* BFD_RELOC_PCREL_LO16:                  howto manager.
* BFD_RELOC_PDP11_DISP_6_PCREL:          howto manager.
* BFD_RELOC_PDP11_DISP_8_PCREL:          howto manager.
* BFD_RELOC_PJ_CODE_DIR16:               howto manager.
* BFD_RELOC_PJ_CODE_DIR32:               howto manager.
* BFD_RELOC_PJ_CODE_HI16:                howto manager.
* BFD_RELOC_PJ_CODE_LO16:                howto manager.
* BFD_RELOC_PJ_CODE_REL16:               howto manager.
* BFD_RELOC_PJ_CODE_REL32:               howto manager.
* BFD_RELOC_PPC64_ADDR16_DS:             howto manager.
* BFD_RELOC_PPC64_ADDR16_LO_DS:          howto manager.
* BFD_RELOC_PPC64_DTPREL16_DS:           howto manager.
* BFD_RELOC_PPC64_DTPREL16_HIGHER:       howto manager.
* BFD_RELOC_PPC64_DTPREL16_HIGHERA:      howto manager.
* BFD_RELOC_PPC64_DTPREL16_HIGHEST:      howto manager.
* BFD_RELOC_PPC64_DTPREL16_HIGHESTA:     howto manager.
* BFD_RELOC_PPC64_DTPREL16_LO_DS:        howto manager.
* BFD_RELOC_PPC64_GOT16_DS:              howto manager.
* BFD_RELOC_PPC64_GOT16_LO_DS:           howto manager.
* BFD_RELOC_PPC64_HIGHER:                howto manager.
* BFD_RELOC_PPC64_HIGHER_S:              howto manager.
* BFD_RELOC_PPC64_HIGHEST:               howto manager.
* BFD_RELOC_PPC64_HIGHEST_S:             howto manager.
* BFD_RELOC_PPC64_PLT16_LO_DS:           howto manager.
* BFD_RELOC_PPC64_PLTGOT16:              howto manager.
* BFD_RELOC_PPC64_PLTGOT16_DS:           howto manager.
* BFD_RELOC_PPC64_PLTGOT16_HA:           howto manager.
* BFD_RELOC_PPC64_PLTGOT16_HI:           howto manager.
* BFD_RELOC_PPC64_PLTGOT16_LO:           howto manager.
* BFD_RELOC_PPC64_PLTGOT16_LO_DS:        howto manager.
* BFD_RELOC_PPC64_SECTOFF_DS:            howto manager.
* BFD_RELOC_PPC64_SECTOFF_LO_DS:         howto manager.
* BFD_RELOC_PPC64_TOC:                   howto manager.
* BFD_RELOC_PPC64_TOC16_DS:              howto manager.
* BFD_RELOC_PPC64_TOC16_HA:              howto manager.
* BFD_RELOC_PPC64_TOC16_HI:              howto manager.
* BFD_RELOC_PPC64_TOC16_LO:              howto manager.
* BFD_RELOC_PPC64_TOC16_LO_DS:           howto manager.
* BFD_RELOC_PPC64_TPREL16_DS:            howto manager.
* BFD_RELOC_PPC64_TPREL16_HIGHER:        howto manager.
* BFD_RELOC_PPC64_TPREL16_HIGHERA:       howto manager.
* BFD_RELOC_PPC64_TPREL16_HIGHEST:       howto manager.
* BFD_RELOC_PPC64_TPREL16_HIGHESTA:      howto manager.
* BFD_RELOC_PPC64_TPREL16_LO_DS:         howto manager.
* BFD_RELOC_PPC_B16:                     howto manager.
* BFD_RELOC_PPC_B16_BRNTAKEN:            howto manager.
* BFD_RELOC_PPC_B16_BRTAKEN:             howto manager.
* BFD_RELOC_PPC_B26:                     howto manager.
* BFD_RELOC_PPC_BA16:                    howto manager.
* BFD_RELOC_PPC_BA16_BRNTAKEN:           howto manager.
* BFD_RELOC_PPC_BA16_BRTAKEN:            howto manager.
* BFD_RELOC_PPC_BA26:                    howto manager.
* BFD_RELOC_PPC_COPY:                    howto manager.
* BFD_RELOC_PPC_DTPMOD:                  howto manager.
* BFD_RELOC_PPC_DTPREL:                  howto manager.
* BFD_RELOC_PPC_DTPREL16:                howto manager.
* BFD_RELOC_PPC_DTPREL16_HA:             howto manager.
* BFD_RELOC_PPC_DTPREL16_HI:             howto manager.
* BFD_RELOC_PPC_DTPREL16_LO:             howto manager.
* BFD_RELOC_PPC_EMB_BIT_FLD:             howto manager.
* BFD_RELOC_PPC_EMB_MRKREF:              howto manager.
* BFD_RELOC_PPC_EMB_NADDR16:             howto manager.
* BFD_RELOC_PPC_EMB_NADDR16_HA:          howto manager.
* BFD_RELOC_PPC_EMB_NADDR16_HI:          howto manager.
* BFD_RELOC_PPC_EMB_NADDR16_LO:          howto manager.
* BFD_RELOC_PPC_EMB_NADDR32:             howto manager.
* BFD_RELOC_PPC_EMB_RELSDA:              howto manager.
* BFD_RELOC_PPC_EMB_RELSEC16:            howto manager.
* BFD_RELOC_PPC_EMB_RELST_HA:            howto manager.
* BFD_RELOC_PPC_EMB_RELST_HI:            howto manager.
* BFD_RELOC_PPC_EMB_RELST_LO:            howto manager.
* BFD_RELOC_PPC_EMB_SDA21:               howto manager.
* BFD_RELOC_PPC_EMB_SDA2I16:             howto manager.
* BFD_RELOC_PPC_EMB_SDA2REL:             howto manager.
* BFD_RELOC_PPC_EMB_SDAI16:              howto manager.
* BFD_RELOC_PPC_GLOB_DAT:                howto manager.
* BFD_RELOC_PPC_GOT_DTPREL16:            howto manager.
* BFD_RELOC_PPC_GOT_DTPREL16_HA:         howto manager.
* BFD_RELOC_PPC_GOT_DTPREL16_HI:         howto manager.
* BFD_RELOC_PPC_GOT_DTPREL16_LO:         howto manager.
* BFD_RELOC_PPC_GOT_TLSGD16:             howto manager.
* BFD_RELOC_PPC_GOT_TLSGD16_HA:          howto manager.
* BFD_RELOC_PPC_GOT_TLSGD16_HI:          howto manager.
* BFD_RELOC_PPC_GOT_TLSGD16_LO:          howto manager.
* BFD_RELOC_PPC_GOT_TLSLD16:             howto manager.
* BFD_RELOC_PPC_GOT_TLSLD16_HA:          howto manager.
* BFD_RELOC_PPC_GOT_TLSLD16_HI:          howto manager.
* BFD_RELOC_PPC_GOT_TLSLD16_LO:          howto manager.
* BFD_RELOC_PPC_GOT_TPREL16:             howto manager.
* BFD_RELOC_PPC_GOT_TPREL16_HA:          howto manager.
* BFD_RELOC_PPC_GOT_TPREL16_HI:          howto manager.
* BFD_RELOC_PPC_GOT_TPREL16_LO:          howto manager.
* BFD_RELOC_PPC_JMP_SLOT:                howto manager.
* BFD_RELOC_PPC_LOCAL24PC:               howto manager.
* BFD_RELOC_PPC_RELATIVE:                howto manager.
* BFD_RELOC_PPC_TLS:                     howto manager.
* BFD_RELOC_PPC_TOC16:                   howto manager.
* BFD_RELOC_PPC_TPREL:                   howto manager.
* BFD_RELOC_PPC_TPREL16:                 howto manager.
* BFD_RELOC_PPC_TPREL16_HA:              howto manager.
* BFD_RELOC_PPC_TPREL16_HI:              howto manager.
* BFD_RELOC_PPC_TPREL16_LO:              howto manager.
* BFD_RELOC_RVA:                         howto manager.
* BFD_RELOC_SH_ALIGN:                    howto manager.
* BFD_RELOC_SH_CODE:                     howto manager.
* BFD_RELOC_SH_COPY:                     howto manager.
* BFD_RELOC_SH_COPY64:                   howto manager.
* BFD_RELOC_SH_COUNT:                    howto manager.
* BFD_RELOC_SH_DATA:                     howto manager.
* BFD_RELOC_SH_GLOB_DAT:                 howto manager.
* BFD_RELOC_SH_GLOB_DAT64:               howto manager.
* BFD_RELOC_SH_GOT10BY4:                 howto manager.
* BFD_RELOC_SH_GOT10BY8:                 howto manager.
* BFD_RELOC_SH_GOT_HI16:                 howto manager.
* BFD_RELOC_SH_GOT_LOW16:                howto manager.
* BFD_RELOC_SH_GOT_MEDHI16:              howto manager.
* BFD_RELOC_SH_GOT_MEDLOW16:             howto manager.
* BFD_RELOC_SH_GOTOFF_HI16:              howto manager.
* BFD_RELOC_SH_GOTOFF_LOW16:             howto manager.
* BFD_RELOC_SH_GOTOFF_MEDHI16:           howto manager.
* BFD_RELOC_SH_GOTOFF_MEDLOW16:          howto manager.
* BFD_RELOC_SH_GOTPC:                    howto manager.
* BFD_RELOC_SH_GOTPC_HI16:               howto manager.
* BFD_RELOC_SH_GOTPC_LOW16:              howto manager.
* BFD_RELOC_SH_GOTPC_MEDHI16:            howto manager.
* BFD_RELOC_SH_GOTPC_MEDLOW16:           howto manager.
* BFD_RELOC_SH_GOTPLT10BY4:              howto manager.
* BFD_RELOC_SH_GOTPLT10BY8:              howto manager.
* BFD_RELOC_SH_GOTPLT32:                 howto manager.
* BFD_RELOC_SH_GOTPLT_HI16:              howto manager.
* BFD_RELOC_SH_GOTPLT_LOW16:             howto manager.
* BFD_RELOC_SH_GOTPLT_MEDHI16:           howto manager.
* BFD_RELOC_SH_GOTPLT_MEDLOW16:          howto manager.
* BFD_RELOC_SH_IMM4:                     howto manager.
* BFD_RELOC_SH_IMM4BY2:                  howto manager.
* BFD_RELOC_SH_IMM4BY4:                  howto manager.
* BFD_RELOC_SH_IMM8:                     howto manager.
* BFD_RELOC_SH_IMM8BY2:                  howto manager.
* BFD_RELOC_SH_IMM8BY4:                  howto manager.
* BFD_RELOC_SH_IMM_HI16:                 howto manager.
* BFD_RELOC_SH_IMM_HI16_PCREL:           howto manager.
* BFD_RELOC_SH_IMM_LOW16:                howto manager.
* BFD_RELOC_SH_IMM_LOW16_PCREL:          howto manager.
* BFD_RELOC_SH_IMM_MEDHI16:              howto manager.
* BFD_RELOC_SH_IMM_MEDHI16_PCREL:        howto manager.
* BFD_RELOC_SH_IMM_MEDLOW16:             howto manager.
* BFD_RELOC_SH_IMM_MEDLOW16_PCREL:       howto manager.
* BFD_RELOC_SH_IMMS10:                   howto manager.
* BFD_RELOC_SH_IMMS10BY2:                howto manager.
* BFD_RELOC_SH_IMMS10BY4:                howto manager.
* BFD_RELOC_SH_IMMS10BY8:                howto manager.
* BFD_RELOC_SH_IMMS16:                   howto manager.
* BFD_RELOC_SH_IMMS6:                    howto manager.
* BFD_RELOC_SH_IMMS6BY32:                howto manager.
* BFD_RELOC_SH_IMMU16:                   howto manager.
* BFD_RELOC_SH_IMMU5:                    howto manager.
* BFD_RELOC_SH_IMMU6:                    howto manager.
* BFD_RELOC_SH_JMP_SLOT:                 howto manager.
* BFD_RELOC_SH_JMP_SLOT64:               howto manager.
* BFD_RELOC_SH_LABEL:                    howto manager.
* BFD_RELOC_SH_LOOP_END:                 howto manager.
* BFD_RELOC_SH_LOOP_START:               howto manager.
* BFD_RELOC_SH_PCDISP12BY2:              howto manager.
* BFD_RELOC_SH_PCDISP8BY2:               howto manager.
* BFD_RELOC_SH_PCRELIMM8BY2:             howto manager.
* BFD_RELOC_SH_PCRELIMM8BY4:             howto manager.
* BFD_RELOC_SH_PLT_HI16:                 howto manager.
* BFD_RELOC_SH_PLT_LOW16:                howto manager.
* BFD_RELOC_SH_PLT_MEDHI16:              howto manager.
* BFD_RELOC_SH_PLT_MEDLOW16:             howto manager.
* BFD_RELOC_SH_PT_16:                    howto manager.
* BFD_RELOC_SH_RELATIVE:                 howto manager.
* BFD_RELOC_SH_RELATIVE64:               howto manager.
* BFD_RELOC_SH_SHMEDIA_CODE:             howto manager.
* BFD_RELOC_SH_SWITCH16:                 howto manager.
* BFD_RELOC_SH_SWITCH32:                 howto manager.
* BFD_RELOC_SH_TLS_DTPMOD32:             howto manager.
* BFD_RELOC_SH_TLS_DTPOFF32:             howto manager.
* BFD_RELOC_SH_TLS_GD_32:                howto manager.
* BFD_RELOC_SH_TLS_IE_32:                howto manager.
* BFD_RELOC_SH_TLS_LD_32:                howto manager.
* BFD_RELOC_SH_TLS_LDO_32:               howto manager.
* BFD_RELOC_SH_TLS_LE_32:                howto manager.
* BFD_RELOC_SH_TLS_TPOFF32:              howto manager.
* BFD_RELOC_SH_USES:                     howto manager.
* BFD_RELOC_SPARC13:                     howto manager.
* BFD_RELOC_SPARC22:                     howto manager.
* BFD_RELOC_SPARC_10:                    howto manager.
* BFD_RELOC_SPARC_11:                    howto manager.
* BFD_RELOC_SPARC_5:                     howto manager.
* BFD_RELOC_SPARC_6:                     howto manager.
* BFD_RELOC_SPARC_64:                    howto manager.
* BFD_RELOC_SPARC_7:                     howto manager.
* BFD_RELOC_SPARC_BASE13:                howto manager.
* BFD_RELOC_SPARC_BASE22:                howto manager.
* BFD_RELOC_SPARC_COPY:                  howto manager.
* BFD_RELOC_SPARC_DISP64:                howto manager.
* BFD_RELOC_SPARC_GLOB_DAT:              howto manager.
* BFD_RELOC_SPARC_GOT10:                 howto manager.
* BFD_RELOC_SPARC_GOT13:                 howto manager.
* BFD_RELOC_SPARC_GOT22:                 howto manager.
* BFD_RELOC_SPARC_H44:                   howto manager.
* BFD_RELOC_SPARC_HH22:                  howto manager.
* BFD_RELOC_SPARC_HIX22:                 howto manager.
* BFD_RELOC_SPARC_HM10:                  howto manager.
* BFD_RELOC_SPARC_JMP_SLOT:              howto manager.
* BFD_RELOC_SPARC_L44:                   howto manager.
* BFD_RELOC_SPARC_LM22:                  howto manager.
* BFD_RELOC_SPARC_LOX10:                 howto manager.
* BFD_RELOC_SPARC_M44:                   howto manager.
* BFD_RELOC_SPARC_OLO10:                 howto manager.
* BFD_RELOC_SPARC_PC10:                  howto manager.
* BFD_RELOC_SPARC_PC22:                  howto manager.
* BFD_RELOC_SPARC_PC_HH22:               howto manager.
* BFD_RELOC_SPARC_PC_HM10:               howto manager.
* BFD_RELOC_SPARC_PC_LM22:               howto manager.
* BFD_RELOC_SPARC_PLT32:                 howto manager.
* BFD_RELOC_SPARC_PLT64:                 howto manager.
* BFD_RELOC_SPARC_REGISTER:              howto manager.
* BFD_RELOC_SPARC_RELATIVE:              howto manager.
* BFD_RELOC_SPARC_REV32:                 howto manager.
* BFD_RELOC_SPARC_TLS_DTPMOD32:          howto manager.
* BFD_RELOC_SPARC_TLS_DTPMOD64:          howto manager.
* BFD_RELOC_SPARC_TLS_DTPOFF32:          howto manager.
* BFD_RELOC_SPARC_TLS_DTPOFF64:          howto manager.
* BFD_RELOC_SPARC_TLS_GD_ADD:            howto manager.
* BFD_RELOC_SPARC_TLS_GD_CALL:           howto manager.
* BFD_RELOC_SPARC_TLS_GD_HI22:           howto manager.
* BFD_RELOC_SPARC_TLS_GD_LO10:           howto manager.
* BFD_RELOC_SPARC_TLS_IE_ADD:            howto manager.
* BFD_RELOC_SPARC_TLS_IE_HI22:           howto manager.
* BFD_RELOC_SPARC_TLS_IE_LD:             howto manager.
* BFD_RELOC_SPARC_TLS_IE_LDX:            howto manager.
* BFD_RELOC_SPARC_TLS_IE_LO10:           howto manager.
* BFD_RELOC_SPARC_TLS_LDM_ADD:           howto manager.
* BFD_RELOC_SPARC_TLS_LDM_CALL:          howto manager.
* BFD_RELOC_SPARC_TLS_LDM_HI22:          howto manager.
* BFD_RELOC_SPARC_TLS_LDM_LO10:          howto manager.
* BFD_RELOC_SPARC_TLS_LDO_ADD:           howto manager.
* BFD_RELOC_SPARC_TLS_LDO_HIX22:         howto manager.
* BFD_RELOC_SPARC_TLS_LDO_LOX10:         howto manager.
* BFD_RELOC_SPARC_TLS_LE_HIX22:          howto manager.
* BFD_RELOC_SPARC_TLS_LE_LOX10:          howto manager.
* BFD_RELOC_SPARC_TLS_TPOFF32:           howto manager.
* BFD_RELOC_SPARC_TLS_TPOFF64:           howto manager.
* BFD_RELOC_SPARC_UA16:                  howto manager.
* BFD_RELOC_SPARC_UA32:                  howto manager.
* BFD_RELOC_SPARC_UA64:                  howto manager.
* BFD_RELOC_SPARC_WDISP16:               howto manager.
* BFD_RELOC_SPARC_WDISP19:               howto manager.
* BFD_RELOC_SPARC_WDISP22:               howto manager.
* BFD_RELOC_SPARC_WPLT30:                howto manager.
* BFD_RELOC_THUMB_PCREL_BLX:             howto manager.
* BFD_RELOC_THUMB_PCREL_BRANCH12:        howto manager.
* BFD_RELOC_THUMB_PCREL_BRANCH23:        howto manager.
* BFD_RELOC_THUMB_PCREL_BRANCH9:         howto manager.
* BFD_RELOC_TIC30_LDP:                   howto manager.
* BFD_RELOC_TIC54X_16_OF_23:             howto manager.
* BFD_RELOC_TIC54X_23:                   howto manager.
* BFD_RELOC_TIC54X_MS7_OF_23:            howto manager.
* BFD_RELOC_TIC54X_PARTLS7:              howto manager.
* BFD_RELOC_TIC54X_PARTMS9:              howto manager.
* bfd_reloc_type_lookup:                 howto manager.
* BFD_RELOC_V850_22_PCREL:               howto manager.
* BFD_RELOC_V850_9_PCREL:                howto manager.
* BFD_RELOC_V850_ALIGN:                  howto manager.
* BFD_RELOC_V850_CALLT_16_16_OFFSET:     howto manager.
* BFD_RELOC_V850_CALLT_6_7_OFFSET:       howto manager.
* BFD_RELOC_V850_LONGCALL:               howto manager.
* BFD_RELOC_V850_LONGJUMP:               howto manager.
* BFD_RELOC_V850_SDA_15_16_OFFSET:       howto manager.
* BFD_RELOC_V850_SDA_16_16_OFFSET:       howto manager.
* BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET: howto manager.
* BFD_RELOC_V850_TDA_16_16_OFFSET:       howto manager.
* BFD_RELOC_V850_TDA_4_4_OFFSET:         howto manager.
* BFD_RELOC_V850_TDA_4_5_OFFSET:         howto manager.
* BFD_RELOC_V850_TDA_6_8_OFFSET:         howto manager.
* BFD_RELOC_V850_TDA_7_7_OFFSET:         howto manager.
* BFD_RELOC_V850_TDA_7_8_OFFSET:         howto manager.
* BFD_RELOC_V850_ZDA_15_16_OFFSET:       howto manager.
* BFD_RELOC_V850_ZDA_16_16_OFFSET:       howto manager.
* BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET: howto manager.
* BFD_RELOC_VAX_GLOB_DAT:                howto manager.
* BFD_RELOC_VAX_JMP_SLOT:                howto manager.
* BFD_RELOC_VAX_RELATIVE:                howto manager.
* BFD_RELOC_VPE4KMATH_DATA:              howto manager.
* BFD_RELOC_VPE4KMATH_INSN:              howto manager.
* BFD_RELOC_VTABLE_ENTRY:                howto manager.
* BFD_RELOC_VTABLE_INHERIT:              howto manager.
* BFD_RELOC_X86_64_32S:                  howto manager.
* BFD_RELOC_X86_64_COPY:                 howto manager.
* BFD_RELOC_X86_64_DTPMOD64:             howto manager.
* BFD_RELOC_X86_64_DTPOFF32:             howto manager.
* BFD_RELOC_X86_64_DTPOFF64:             howto manager.
* BFD_RELOC_X86_64_GLOB_DAT:             howto manager.
* BFD_RELOC_X86_64_GOT32:                howto manager.
* BFD_RELOC_X86_64_GOTPCREL:             howto manager.
* BFD_RELOC_X86_64_GOTTPOFF:             howto manager.
* BFD_RELOC_X86_64_JUMP_SLOT:            howto manager.
* BFD_RELOC_X86_64_PLT32:                howto manager.
* BFD_RELOC_X86_64_RELATIVE:             howto manager.
* BFD_RELOC_X86_64_TLSGD:                howto manager.
* BFD_RELOC_X86_64_TLSLD:                howto manager.
* BFD_RELOC_X86_64_TPOFF32:              howto manager.
* BFD_RELOC_X86_64_TPOFF64:              howto manager.
* BFD_RELOC_XSTORMY16_12:                howto manager.
* BFD_RELOC_XSTORMY16_24:                howto manager.
* BFD_RELOC_XSTORMY16_FPTR16:            howto manager.
* BFD_RELOC_XSTORMY16_REL_12:            howto manager.
* BFD_RELOC_XTENSA_ASM_EXPAND:           howto manager.
* BFD_RELOC_XTENSA_ASM_SIMPLIFY:         howto manager.
* BFD_RELOC_XTENSA_GLOB_DAT:             howto manager.
* BFD_RELOC_XTENSA_JMP_SLOT:             howto manager.
* BFD_RELOC_XTENSA_OP0:                  howto manager.
* BFD_RELOC_XTENSA_OP1:                  howto manager.
* BFD_RELOC_XTENSA_OP2:                  howto manager.
* BFD_RELOC_XTENSA_PLT:                  howto manager.
* BFD_RELOC_XTENSA_RELATIVE:             howto manager.
* BFD_RELOC_XTENSA_RTLD:                 howto manager.
* bfd_scan_arch:                         Architectures.
* bfd_scan_vma:                          BFD front end.
* bfd_seach_for_target:                  bfd_target.
* bfd_section_list_clear:                section prototypes.
* bfd_set_arch_info:                     Architectures.
* bfd_set_archive_head:                  Archives.
* bfd_set_default_target:                bfd_target.
* bfd_set_error:                         BFD front end.
* bfd_set_error_handler:                 BFD front end.
* bfd_set_error_program_name:            BFD front end.
* bfd_set_file_flags:                    BFD front end.
* bfd_set_format:                        Formats.
* bfd_set_gp_size:                       BFD front end.
* bfd_set_private_flags:                 BFD front end.
* bfd_set_reloc:                         BFD front end.
* bfd_set_section_contents:              section prototypes.
* bfd_set_section_flags:                 section prototypes.
* bfd_set_section_size:                  section prototypes.
* bfd_set_start_address:                 BFD front end.
* bfd_set_symtab:                        symbol handling functions.
* bfd_symbol_info:                       symbol handling functions.
* bfd_target_list:                       bfd_target.
* bfd_write_bigendian_4byte_int:         Internal.
* coff_symbol_type:                      coff.
* core_file_matches_executable_p:        Core Files.
* find_separate_debug_file:              Opening and Closing.
* get_debug_link_info:                   Opening and Closing.
* Hash tables:                           Hash Tables.
* internal object-file format:           Canonical format.
* Linker:                                Linker Functions.
* Other functions:                       BFD front end.
* separate_debug_file_exists:            Opening and Closing.
* target vector (_bfd_final_link):       Performing the Final Link.
* target vector (_bfd_link_add_symbols): Adding Symbols to the Hash Table.
* target vector (_bfd_link_hash_table_create): Creating a Linker Hash Table.
* The HOWTO Macro:                       typedef arelent.
* what is it?:                           Overview.
d1185 2
@


