head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.50
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.52
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.48
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.44
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.46
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.38
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.42
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.40
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BINUTILS_2_15:1.1.1.6
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.5
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.4
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.3
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.11.02.20.45.14;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.17.21.54.24;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.31;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.26;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.09.04.19.02.14;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.18;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.18;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.09.04.17.38.59;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.09.12.14.46.01;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.05.13.13.28.59;	author fgsch;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.05.17.20.42.21;	author drahn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.11.02.20.22.36;	author miod;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* chew
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001,
   2002, 2003
   Free Software Foundation, Inc.
   Contributed by steve chamberlain @@cygnus

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* Yet another way of extracting documentation from source.
   No, I haven't finished it yet, but I hope you people like it better
   than the old way

   sac

   Basically, this is a sort of string forth, maybe we should call it
   struth?

   You define new words thus:
   : <newword> <oldwords> ;

*/

/* Primitives provided by the program:

   Two stacks are provided, a string stack and an integer stack.

   Internal state variables:
	internal_wanted - indicates whether `-i' was passed
	internal_mode - user-settable

   Commands:
	push_text
	! - pop top of integer stack for address, pop next for value; store
	@@ - treat value on integer stack as the address of an integer; push
		that integer on the integer stack after popping the "address"
	hello - print "hello\n" to stdout
	stdout - put stdout marker on TOS
	stderr - put stderr marker on TOS
	print - print TOS-1 on TOS (eg: "hello\n" stdout print)
	skip_past_newline
	catstr - fn icatstr
	copy_past_newline - append input, up to and including newline into TOS
	dup - fn other_dup
	drop - discard TOS
	idrop - ditto
	remchar - delete last character from TOS
	get_stuff_in_command
	do_fancy_stuff - translate <<foo>> to @@code{foo} in TOS
	bulletize - if "o" lines found, prepend @@itemize @@bullet to TOS
		and @@item to each "o" line; append @@end itemize
	courierize - put @@example around . and | lines, translate {* *} { }
	exit - fn chew_exit
	swap
	outputdots - strip out lines without leading dots
	paramstuff - convert full declaration into "PARAMS" form if not already
	maybecatstr - do catstr if internal_mode == internal_wanted, discard
		value in any case
	translatecomments - turn {* and *} into comment delimiters
	kill_bogus_lines - get rid of extra newlines
	indent
	internalmode - pop from integer stack, set `internalmode' to that value
	print_stack_level - print current stack depth to stderr
	strip_trailing_newlines - go ahead, guess...
	[quoted string] - push string onto string stack
	[word starting with digit] - push atol(str) onto integer stack

   A command must be all upper-case, and alone on a line.

   Foo.  */

#include "ansidecl.h"
#include "sysdep.h"
#include <assert.h>
#include <stdio.h>
#include <ctype.h>

#define DEF_SIZE 5000
#define STACK 50

int internal_wanted;
int internal_mode;

int warning;

/* Here is a string type ...  */

typedef struct buffer
{
  char *ptr;
  unsigned long write_idx;
  unsigned long size;
} string_type;

#ifdef __STDC__
static void init_string_with_size (string_type *, unsigned int);
static void init_string (string_type *);
static int find (string_type *, char *);
static void write_buffer (string_type *, FILE *);
static void delete_string (string_type *);
static char *addr (string_type *, unsigned int);
static char at (string_type *, unsigned int);
static void catchar (string_type *, int);
static void overwrite_string (string_type *, string_type *);
static void catbuf (string_type *, char *, unsigned int);
static void cattext (string_type *, char *);
static void catstr (string_type *, string_type *);
#endif

static void
init_string_with_size (buffer, size)
     string_type *buffer;
     unsigned int size;
{
  buffer->write_idx = 0;
  buffer->size = size;
  buffer->ptr = malloc (size);
}

static void
init_string (buffer)
     string_type *buffer;
{
  init_string_with_size (buffer, DEF_SIZE);
}

static int
find (str, what)
     string_type *str;
     char *what;
{
  unsigned int i;
  char *p;
  p = what;
  for (i = 0; i < str->write_idx && *p; i++)
    {
      if (*p == str->ptr[i])
	p++;
      else
	p = what;
    }
  return (*p == 0);
}

static void
write_buffer (buffer, f)
     string_type *buffer;
     FILE *f;
{
  fwrite (buffer->ptr, buffer->write_idx, 1, f);
}

static void
delete_string (buffer)
     string_type *buffer;
{
  free (buffer->ptr);
}

static char *
addr (buffer, idx)
     string_type *buffer;
     unsigned int idx;
{
  return buffer->ptr + idx;
}

static char
at (buffer, pos)
     string_type *buffer;
     unsigned int pos;
{
  if (pos >= buffer->write_idx)
    return 0;
  return buffer->ptr[pos];
}

static void
catchar (buffer, ch)
     string_type *buffer;
     int ch;
{
  if (buffer->write_idx == buffer->size)
    {
      buffer->size *= 2;
      buffer->ptr = realloc (buffer->ptr, buffer->size);
    }

  buffer->ptr[buffer->write_idx++] = ch;
}

static void
overwrite_string (dst, src)
     string_type *dst;
     string_type *src;
{
  free (dst->ptr);
  dst->size = src->size;
  dst->write_idx = src->write_idx;
  dst->ptr = src->ptr;
}

static void
catbuf (buffer, buf, len)
     string_type *buffer;
     char *buf;
     unsigned int len;
{
  if (buffer->write_idx + len >= buffer->size)
    {
      while (buffer->write_idx + len >= buffer->size)
	buffer->size *= 2;
      buffer->ptr = realloc (buffer->ptr, buffer->size);
    }
  memcpy (buffer->ptr + buffer->write_idx, buf, len);
  buffer->write_idx += len;
}

static void
cattext (buffer, string)
     string_type *buffer;
     char *string;
{
  catbuf (buffer, string, (unsigned int) strlen (string));
}

static void
catstr (dst, src)
     string_type *dst;
     string_type *src;
{
  catbuf (dst, src->ptr, src->write_idx);
}

static unsigned int
skip_white_and_stars (src, idx)
     string_type *src;
     unsigned int idx;
{
  char c;
  while ((c = at (src, idx)),
	 isspace ((unsigned char) c)
	 || (c == '*'
	     /* Don't skip past end-of-comment or star as first
		character on its line.  */
	     && at (src, idx +1) != '/'
	     && at (src, idx -1) != '\n'))
    idx++;
  return idx;
}

/***********************************************************************/

string_type stack[STACK];
string_type *tos;

unsigned int idx = 0; /* Pos in input buffer */
string_type *ptr; /* and the buffer */
typedef void (*stinst_type)();
stinst_type *pc;
stinst_type sstack[STACK];
stinst_type *ssp = &sstack[0];
long istack[STACK];
long *isp = &istack[0];

typedef int *word_type;

struct dict_struct
{
  char *word;
  struct dict_struct *next;
  stinst_type *code;
  int code_length;
  int code_end;
  int var;
};

typedef struct dict_struct dict_type;

static void
die (msg)
     char *msg;
{
  fprintf (stderr, "%s\n", msg);
  exit (1);
}

static void
check_range ()
{
  if (tos < stack)
    die ("underflow in string stack");
  if (tos >= stack + STACK)
    die ("overflow in string stack");
}

static void
icheck_range ()
{
  if (isp < istack)
    die ("underflow in integer stack");
  if (isp >= istack + STACK)
    die ("overflow in integer stack");
}

#ifdef __STDC__
static void exec (dict_type *);
static void call (void);
static void remchar (void), strip_trailing_newlines (void), push_number (void);
static void push_text (void);
static void remove_noncomments (string_type *, string_type *);
static void print_stack_level (void);
static void paramstuff (void), translatecomments (void);
static void outputdots (void), courierize (void), bulletize (void);
static void do_fancy_stuff (void);
static int iscommand (string_type *, unsigned int);
static int copy_past_newline (string_type *, unsigned int, string_type *);
static void icopy_past_newline (void), kill_bogus_lines (void), indent (void);
static void get_stuff_in_command (void), swap (void), other_dup (void);
static void drop (void), idrop (void);
static void icatstr (void), skip_past_newline (void), internalmode (void);
static void maybecatstr (void);
static char *nextword (char *, char **);
dict_type *lookup_word (char *);
static void perform (void);
dict_type *newentry (char *);
unsigned int add_to_definition (dict_type *, stinst_type);
void add_intrinsic (char *, void (*)());
void add_var (char *);
void compile (char *);
static void bang (void);
static void atsign (void);
static void hello (void);
static void stdout_ (void);
static void stderr_ (void);
static void print (void);
static void read_in (string_type *, FILE *);
static void usage (void);
static void chew_exit (void);
#endif

static void
exec (word)
     dict_type *word;
{
  pc = word->code;
  while (*pc)
    (*pc) ();
}

static void
call ()
{
  stinst_type *oldpc = pc;
  dict_type *e;
  e = (dict_type *) (pc[1]);
  exec (e);
  pc = oldpc + 2;
}

static void
remchar ()
{
  if (tos->write_idx)
    tos->write_idx--;
  pc++;
}

static void
strip_trailing_newlines ()
{
  while ((isspace ((unsigned char) at (tos, tos->write_idx - 1))
	  || at (tos, tos->write_idx - 1) == '\n')
	 && tos->write_idx > 0)
    tos->write_idx--;
  pc++;
}

static void
push_number ()
{
  isp++;
  icheck_range ();
  pc++;
  *isp = (long) (*pc);
  pc++;
}

static void
push_text ()
{
  tos++;
  check_range ();
  init_string (tos);
  pc++;
  cattext (tos, *((char **) pc));
  pc++;
}

/* This function removes everything not inside comments starting on
   the first char of the line from the  string, also when copying
   comments, removes blank space and leading *'s.
   Blank lines are turned into one blank line.  */

static void
remove_noncomments (src, dst)
     string_type *src;
     string_type *dst;
{
  unsigned int idx = 0;

  while (at (src, idx))
    {
      /* Now see if we have a comment at the start of the line.  */
      if (at (src, idx) == '\n'
	  && at (src, idx + 1) == '/'
	  && at (src, idx + 2) == '*')
	{
	  idx += 3;

	  idx = skip_white_and_stars (src, idx);

	  /* Remove leading dot */
	  if (at (src, idx) == '.')
	    idx++;

	  /* Copy to the end of the line, or till the end of the
	     comment.  */
	  while (at (src, idx))
	    {
	      if (at (src, idx) == '\n')
		{
		  /* end of line, echo and scrape of leading blanks  */
		  if (at (src, idx + 1) == '\n')
		    catchar (dst, '\n');
		  catchar (dst, '\n');
		  idx++;
		  idx = skip_white_and_stars (src, idx);
		}
	      else if (at (src, idx) == '*' && at (src, idx + 1) == '/')
		{
		  idx += 2;
		  cattext (dst, "\nENDDD\n");
		  break;
		}
	      else
		{
		  catchar (dst, at (src, idx));
		  idx++;
		}
	    }
	}
      else
	idx++;
    }
}

static void
print_stack_level ()
{
  fprintf (stderr, "current string stack depth = %d, ", tos - stack);
  fprintf (stderr, "current integer stack depth = %d\n", isp - istack);
  pc++;
}

/* turn:
     foobar name(stuff);
   into:
     foobar
     name PARAMS ((stuff));
   and a blank line.
 */

static void
paramstuff ()
{
  unsigned int openp;
  unsigned int fname;
  unsigned int idx;
  unsigned int len;
  string_type out;
  init_string (&out);

#define NO_PARAMS 1

  /* Make sure that it's not already param'd or proto'd.  */
  if (NO_PARAMS
      || find (tos, "PARAMS") || find (tos, "PROTO") || !find (tos, "("))
    {
      catstr (&out, tos);
    }
  else
    {
      /* Find the open paren.  */
      for (openp = 0; at (tos, openp) != '(' && at (tos, openp); openp++)
	;

      fname = openp;
      /* Step back to the fname.  */
      fname--;
      while (fname && isspace ((unsigned char) at (tos, fname)))
	fname--;
      while (fname
	     && !isspace ((unsigned char) at (tos,fname))
	     && at (tos,fname) != '*')
	fname--;

      fname++;

      /* Output type, omitting trailing whitespace character(s), if
         any.  */
      for (len = fname; 0 < len; len--)
	{
	  if (!isspace ((unsigned char) at (tos, len - 1)))
	    break;
	}
      for (idx = 0; idx < len; idx++)
	catchar (&out, at (tos, idx));

      cattext (&out, "\n");	/* Insert a newline between type and fnname */

      /* Output function name, omitting trailing whitespace
         character(s), if any.  */
      for (len = openp; 0 < len; len--)
	{
	  if (!isspace ((unsigned char) at (tos, len - 1)))
	    break;
	}
      for (idx = fname; idx < len; idx++)
	catchar (&out, at (tos, idx));

      cattext (&out, " PARAMS (");

      for (idx = openp; at (tos, idx) && at (tos, idx) != ';'; idx++)
	catchar (&out, at (tos, idx));

      cattext (&out, ");\n\n");
    }
  overwrite_string (tos, &out);
  pc++;

}

/* turn {*
   and *} into comments */

static void
translatecomments ()
{
  unsigned int idx = 0;
  string_type out;
  init_string (&out);

  while (at (tos, idx))
    {
      if (at (tos, idx) == '{' && at (tos, idx + 1) == '*')
	{
	  cattext (&out, "/*");
	  idx += 2;
	}
      else if (at (tos, idx) == '*' && at (tos, idx + 1) == '}')
	{
	  cattext (&out, "*/");
	  idx += 2;
	}
      else
	{
	  catchar (&out, at (tos, idx));
	  idx++;
	}
    }

  overwrite_string (tos, &out);

  pc++;
}

#if 0

/* This is not currently used.  */

/* turn everything not starting with a . into a comment */

static void
manglecomments ()
{
  unsigned int idx = 0;
  string_type out;
  init_string (&out);

  while (at (tos, idx))
    {
      if (at (tos, idx) == '\n' && at (tos, idx + 1) == '*')
	{
	  cattext (&out, "	/*");
	  idx += 2;
	}
      else if (at (tos, idx) == '*' && at (tos, idx + 1) == '}')
	{
	  cattext (&out, "*/");
	  idx += 2;
	}
      else
	{
	  catchar (&out, at (tos, idx));
	  idx++;
	}
    }

  overwrite_string (tos, &out);

  pc++;
}

#endif

/* Mod tos so that only lines with leading dots remain */
static void
outputdots ()
{
  unsigned int idx = 0;
  string_type out;
  init_string (&out);

  while (at (tos, idx))
    {
      if (at (tos, idx) == '\n' && at (tos, idx + 1) == '.')
	{
	  char c;
	  idx += 2;

	  while ((c = at (tos, idx)) && c != '\n')
	    {
	      if (c == '{' && at (tos, idx + 1) == '*')
		{
		  cattext (&out, "/*");
		  idx += 2;
		}
	      else if (c == '*' && at (tos, idx + 1) == '}')
		{
		  cattext (&out, "*/");
		  idx += 2;
		}
	      else
		{
		  catchar (&out, c);
		  idx++;
		}
	    }
	  catchar (&out, '\n');
	}
      else
	{
	  idx++;
	}
    }

  overwrite_string (tos, &out);
  pc++;
}

/* Find lines starting with . and | and put example around them on tos */
static void
courierize ()
{
  string_type out;
  unsigned int idx = 0;
  int command = 0;

  init_string (&out);

  while (at (tos, idx))
    {
      if (at (tos, idx) == '\n'
	  && (at (tos, idx +1 ) == '.'
	      || at (tos, idx + 1) == '|'))
	{
	  cattext (&out, "\n@@example\n");
	  do
	    {
	      idx += 2;

	      while (at (tos, idx) && at (tos, idx) != '\n')
		{
		  if (command > 1)
		    {
		      /* We are inside {} parameters of some command;
			 Just pass through until matching brace.  */
		      if (at (tos, idx) == '{')
			++command;
		      else if (at (tos, idx) == '}')
			--command;
		    }
		  else if (command != 0)
		    {
		      if (at (tos, idx) == '{')
			++command;
		      else if (!islower ((unsigned char) at (tos, idx)))
			--command;
		    }
		  else if (at (tos, idx) == '@@'
			   && islower ((unsigned char) at (tos, idx + 1)))
		    {
		      ++command;
		    }
		  else if (at (tos, idx) == '{' && at (tos, idx + 1) == '*')
		    {
		      cattext (&out, "/*");
		      idx += 2;
		      continue;
		    }
		  else if (at (tos, idx) == '*' && at (tos, idx + 1) == '}')
		    {
		      cattext (&out, "*/");
		      idx += 2;
		      continue;
		    }
		  else if (at (tos, idx) == '{'
			   || at (tos, idx) == '}')
		    {
		      catchar (&out, '@@');
		    }

		  catchar (&out, at (tos, idx));
		  idx++;
		}
	      catchar (&out, '\n');
	    }
	  while (at (tos, idx) == '\n'
		 && ((at (tos, idx + 1) == '.')
		     || (at (tos, idx + 1) == '|')))
	    ;
	  cattext (&out, "@@end example");
	}
      else
	{
	  catchar (&out, at (tos, idx));
	  idx++;
	}
    }

  overwrite_string (tos, &out);
  pc++;
}

/* Finds any lines starting with "o ", if there are any, then turns
   on @@itemize @@bullet, and @@items each of them. Then ends with @@end
   itemize, inplace at TOS*/

static void
bulletize ()
{
  unsigned int idx = 0;
  int on = 0;
  string_type out;
  init_string (&out);

  while (at (tos, idx))
    {
      if (at (tos, idx) == '@@'
	  && at (tos, idx + 1) == '*')
	{
	  cattext (&out, "*");
	  idx += 2;
	}
      else if (at (tos, idx) == '\n'
	       && at (tos, idx + 1) == 'o'
	       && isspace ((unsigned char) at (tos, idx + 2)))
	{
	  if (!on)
	    {
	      cattext (&out, "\n@@itemize @@bullet\n");
	      on = 1;

	    }
	  cattext (&out, "\n@@item\n");
	  idx += 3;
	}
      else
	{
	  catchar (&out, at (tos, idx));
	  if (on && at (tos, idx) == '\n'
	      && at (tos, idx + 1) == '\n'
	      && at (tos, idx + 2) != 'o')
	    {
	      cattext (&out, "@@end itemize");
	      on = 0;
	    }
	  idx++;

	}
    }
  if (on)
    {
      cattext (&out, "@@end itemize\n");
    }

  delete_string (tos);
  *tos = out;
  pc++;
}

/* Turn <<foo>> into @@code{foo} in place at TOS*/

static void
do_fancy_stuff ()
{
  unsigned int idx = 0;
  string_type out;
  init_string (&out);
  while (at (tos, idx))
    {
      if (at (tos, idx) == '<'
	  && at (tos, idx + 1) == '<'
	  && !isspace ((unsigned char) at (tos, idx + 2)))
	{
	  /* This qualifies as a << startup.  */
	  idx += 2;
	  cattext (&out, "@@code{");
	  while (at (tos, idx)
		 && at (tos, idx) != '>' )
	    {
	      catchar (&out, at (tos, idx));
	      idx++;

	    }
	  cattext (&out, "}");
	  idx += 2;
	}
      else
	{
	  catchar (&out, at (tos, idx));
	  idx++;
	}
    }
  delete_string (tos);
  *tos = out;
  pc++;

}

/* A command is all upper case,and alone on a line.  */

static int
iscommand (ptr, idx)
     string_type *ptr;
     unsigned int idx;
{
  unsigned int len = 0;
  while (at (ptr, idx))
    {
      if (isupper ((unsigned char) at (ptr, idx))
	  || at (ptr, idx) == ' ' || at (ptr, idx) == '_')
	{
	  len++;
	  idx++;
	}
      else if (at (ptr, idx) == '\n')
	{
	  if (len > 3)
	    return 1;
	  return 0;
	}
      else
	return 0;
    }
  return 0;
}

static int
copy_past_newline (ptr, idx, dst)
     string_type *ptr;
     unsigned int idx;
     string_type *dst;
{
  int column = 0;

  while (at (ptr, idx) && at (ptr, idx) != '\n')
    {
      if (at (ptr, idx) == '\t')
	{
	  /* Expand tabs.  Neither makeinfo nor TeX can cope well with
	     them.  */
	  do
	    catchar (dst, ' ');
	  while (++column & 7);
	}
      else
	{
	  catchar (dst, at (ptr, idx));
	  column++;
	}
      idx++;

    }
  catchar (dst, at (ptr, idx));
  idx++;
  return idx;

}

static void
icopy_past_newline ()
{
  tos++;
  check_range ();
  init_string (tos);
  idx = copy_past_newline (ptr, idx, tos);
  pc++;
}

/* indent
   Take the string at the top of the stack, do some prettying.  */

static void
kill_bogus_lines ()
{
  int sl;

  int idx = 0;
  int c;
  int dot = 0;

  string_type out;
  init_string (&out);
  /* Drop leading nl.  */
  while (at (tos, idx) == '\n')
    {
      idx++;
    }
  c = idx;

  /* If the first char is a '.' prepend a newline so that it is
     recognized properly later.  */
  if (at (tos, idx) == '.')
    catchar (&out, '\n');

  /* Find the last char.  */
  while (at (tos, idx))
    {
      idx++;
    }

  /* Find the last non white before the nl.  */
  idx--;

  while (idx && isspace ((unsigned char) at (tos, idx)))
    idx--;
  idx++;

  /* Copy buffer upto last char, but blank lines before and after
     dots don't count.  */
  sl = 1;

  while (c < idx)
    {
      if (at (tos, c) == '\n'
	  && at (tos, c + 1) == '\n'
	  && at (tos, c + 2) == '.')
	{
	  /* Ignore two newlines before a dot.  */
	  c++;
	}
      else if (at (tos, c) == '.' && sl)
	{
	  /* remember that this line started with a dot.  */
	  dot = 2;
	}
      else if (at (tos, c) == '\n'
	       && at (tos, c + 1) == '\n'
	       && dot)
	{
	  c++;
	  /* Ignore two newlines when last line was dot.  */
	}

      catchar (&out, at (tos, c));
      if (at (tos, c) == '\n')
	{
	  sl = 1;

	  if (dot == 2)
	    dot = 1;
	  else
	    dot = 0;
	}
      else
	sl = 0;

      c++;

    }

  /* Append nl.  */
  catchar (&out, '\n');
  pc++;
  delete_string (tos);
  *tos = out;

}

static void
indent ()
{
  string_type out;
  int tab = 0;
  int idx = 0;
  int ol = 0;
  init_string (&out);
  while (at (tos, idx))
    {
      switch (at (tos, idx))
	{
	case '\n':
	  cattext (&out, "\n");
	  idx++;
	  if (tab && at (tos, idx))
	    {
	      cattext (&out, "    ");
	    }
	  ol = 0;
	  break;
	case '(':
	  tab++;
	  if (ol == 0)
	    cattext (&out, "   ");
	  idx++;
	  cattext (&out, "(");
	  ol = 1;
	  break;
	case ')':
	  tab--;
	  cattext (&out, ")");
	  idx++;
	  ol = 1;

	  break;
	default:
	  catchar (&out, at (tos, idx));
	  ol = 1;

	  idx++;
	  break;
	}
    }

  pc++;
  delete_string (tos);
  *tos = out;

}

static void
get_stuff_in_command ()
{
  tos++;
  check_range ();
  init_string (tos);

  while (at (ptr, idx))
    {
      if (iscommand (ptr, idx))
	break;
      idx = copy_past_newline (ptr, idx, tos);
    }
  pc++;
}

static void
swap ()
{
  string_type t;

  t = tos[0];
  tos[0] = tos[-1];
  tos[-1] = t;
  pc++;
}

static void
other_dup ()
{
  tos++;
  check_range ();
  init_string (tos);
  catstr (tos, tos - 1);
  pc++;
}

static void
drop ()
{
  tos--;
  check_range ();
  pc++;
}

static void
idrop ()
{
  isp--;
  icheck_range ();
  pc++;
}

static void
icatstr ()
{
  tos--;
  check_range ();
  catstr (tos, tos + 1);
  delete_string (tos + 1);
  pc++;
}

static void
skip_past_newline ()
{
  while (at (ptr, idx)
	 && at (ptr, idx) != '\n')
    idx++;
  idx++;
  pc++;
}

static void
internalmode ()
{
  internal_mode = *(isp);
  isp--;
  icheck_range ();
  pc++;
}

static void
maybecatstr ()
{
  if (internal_wanted == internal_mode)
    {
      catstr (tos - 1, tos);
    }
  delete_string (tos);
  tos--;
  check_range ();
  pc++;
}

char *
nextword (string, word)
     char *string;
     char **word;
{
  char *word_start;
  int idx;
  char *dst;
  char *src;

  int length = 0;

  while (isspace ((unsigned char) *string) || *string == '-')
    {
      if (*string == '-')
	{
	  while (*string && *string != '\n')
	    string++;

	}
      else
	{
	  string++;
	}
    }
  if (!*string)
    return 0;

  word_start = string;
  if (*string == '"')
    {
      do
	{
	  string++;
	  length++;
	  if (*string == '\\')
	    {
	      string += 2;
	      length += 2;
	    }
	}
      while (*string != '"');
    }
  else
    {
      while (!isspace ((unsigned char) *string))
	{
	  string++;
	  length++;

	}
    }

  *word = malloc (length + 1);

  dst = *word;
  src = word_start;

  for (idx = 0; idx < length; idx++)
    {
      if (src[idx] == '\\')
	switch (src[idx + 1])
	  {
	  case 'n':
	    *dst++ = '\n';
	    idx++;
	    break;
	  case '"':
	  case '\\':
	    *dst++ = src[idx + 1];
	    idx++;
	    break;
	  default:
	    *dst++ = '\\';
	    break;
	  }
      else
	*dst++ = src[idx];
    }
  *dst++ = 0;

  if (*string)
    return string + 1;
  else
    return 0;
}

dict_type *root;

dict_type *
lookup_word (word)
     char *word;
{
  dict_type *ptr = root;
  while (ptr)
    {
      if (strcmp (ptr->word, word) == 0)
	return ptr;
      ptr = ptr->next;
    }
  if (warning)
    fprintf (stderr, "Can't find %s\n", word);
  return 0;
}

static void
perform ()
{
  tos = stack;

  while (at (ptr, idx))
    {
      /* It's worth looking through the command list.  */
      if (iscommand (ptr, idx))
	{
	  char *next;
	  dict_type *word;

	  (void) nextword (addr (ptr, idx), &next);

	  word = lookup_word (next);

	  if (word)
	    {
	      exec (word);
	    }
	  else
	    {
	      if (warning)
		fprintf (stderr, "warning, %s is not recognised\n", next);
	      skip_past_newline ();
	    }

	}
      else
	skip_past_newline ();
    }
}

dict_type *
newentry (word)
     char *word;
{
  dict_type *new = (dict_type *) malloc (sizeof (dict_type));
  new->word = word;
  new->next = root;
  root = new;
  new->code = (stinst_type *) malloc (sizeof (stinst_type));
  new->code_length = 1;
  new->code_end = 0;
  return new;
}

unsigned int
add_to_definition (entry, word)
     dict_type *entry;
     stinst_type word;
{
  if (entry->code_end == entry->code_length)
    {
      entry->code_length += 2;
      entry->code =
	(stinst_type *) realloc ((char *) (entry->code),
				 entry->code_length * sizeof (word_type));
    }
  entry->code[entry->code_end] = word;

  return entry->code_end++;
}

void
add_intrinsic (name, func)
     char *name;
     void (*func) ();
{
  dict_type *new = newentry (name);
  add_to_definition (new, func);
  add_to_definition (new, 0);
}

void
add_var (name)
     char *name;
{
  dict_type *new = newentry (name);
  add_to_definition (new, push_number);
  add_to_definition (new, (stinst_type) (&(new->var)));
  add_to_definition (new, 0);
}

void
compile (string)
     char *string;
{
  /* Add words to the dictionary.  */
  char *word;
  string = nextword (string, &word);
  while (string && *string && word[0])
    {
      if (strcmp (word, "var") == 0)
	{
	  string = nextword (string, &word);

	  add_var (word);
	  string = nextword (string, &word);
	}
      else if (word[0] == ':')
	{
	  dict_type *ptr;
	  /* Compile a word and add to dictionary.  */
	  string = nextword (string, &word);

	  ptr = newentry (word);
	  string = nextword (string, &word);
	  while (word[0] != ';')
	    {
	      switch (word[0])
		{
		case '"':
		  /* got a string, embed magic push string
		     function */
		  add_to_definition (ptr, push_text);
		  add_to_definition (ptr, (stinst_type) (word + 1));
		  break;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		  /* Got a number, embedd the magic push number
		     function */
		  add_to_definition (ptr, push_number);
		  add_to_definition (ptr, (stinst_type) atol (word));
		  break;
		default:
		  add_to_definition (ptr, call);
		  add_to_definition (ptr, (stinst_type) lookup_word (word));
		}

	      string = nextword (string, &word);
	    }
	  add_to_definition (ptr, 0);
	  string = nextword (string, &word);
	}
      else
	{
	  fprintf (stderr, "syntax error at %s\n", string - 1);
	}
    }
}

static void
bang ()
{
  *(long *) ((isp[0])) = isp[-1];
  isp -= 2;
  icheck_range ();
  pc++;
}

static void
atsign ()
{
  isp[0] = *(long *) (isp[0]);
  pc++;
}

static void
hello ()
{
  printf ("hello\n");
  pc++;
}

static void
stdout_ ()
{
  isp++;
  icheck_range ();
  *isp = 1;
  pc++;
}

static void
stderr_ ()
{
  isp++;
  icheck_range ();
  *isp = 2;
  pc++;
}

static void
print ()
{
  if (*isp == 1)
    write_buffer (tos, stdout);
  else if (*isp == 2)
    write_buffer (tos, stderr);
  else
    fprintf (stderr, "print: illegal print destination `%ld'\n", *isp);
  isp--;
  tos--;
  icheck_range ();
  check_range ();
  pc++;
}

static void
read_in (str, file)
     string_type *str;
     FILE *file;
{
  char buff[10000];
  unsigned int r;
  do
    {
      r = fread (buff, 1, sizeof (buff), file);
      catbuf (str, buff, r);
    }
  while (r);
  buff[0] = 0;

  catbuf (str, buff, 1);
}

static void
usage ()
{
  fprintf (stderr, "usage: -[d|i|g] <file >file\n");
  exit (33);
}

/* There is no reliable way to declare exit.  Sometimes it returns
   int, and sometimes it returns void.  Sometimes it changes between
   OS releases.  Trying to get it declared correctly in the hosts file
   is a pointless waste of time.  */

static void
chew_exit ()
{
  exit (0);
}

int
main (ac, av)
     int ac;
     char *av[];
{
  unsigned int i;
  string_type buffer;
  string_type pptr;

  init_string (&buffer);
  init_string (&pptr);
  init_string (stack + 0);
  tos = stack + 1;
  ptr = &pptr;

  add_intrinsic ("push_text", push_text);
  add_intrinsic ("!", bang);
  add_intrinsic ("@@", atsign);
  add_intrinsic ("hello", hello);
  add_intrinsic ("stdout", stdout_);
  add_intrinsic ("stderr", stderr_);
  add_intrinsic ("print", print);
  add_intrinsic ("skip_past_newline", skip_past_newline);
  add_intrinsic ("catstr", icatstr);
  add_intrinsic ("copy_past_newline", icopy_past_newline);
  add_intrinsic ("dup", other_dup);
  add_intrinsic ("drop", drop);
  add_intrinsic ("idrop", idrop);
  add_intrinsic ("remchar", remchar);
  add_intrinsic ("get_stuff_in_command", get_stuff_in_command);
  add_intrinsic ("do_fancy_stuff", do_fancy_stuff);
  add_intrinsic ("bulletize", bulletize);
  add_intrinsic ("courierize", courierize);
  /* If the following line gives an error, exit() is not declared in the
     ../hosts/foo.h file for this host.  Fix it there, not here!  */
  /* No, don't fix it anywhere; see comment on chew_exit--Ian Taylor.  */
  add_intrinsic ("exit", chew_exit);
  add_intrinsic ("swap", swap);
  add_intrinsic ("outputdots", outputdots);
  add_intrinsic ("paramstuff", paramstuff);
  add_intrinsic ("maybecatstr", maybecatstr);
  add_intrinsic ("translatecomments", translatecomments);
  add_intrinsic ("kill_bogus_lines", kill_bogus_lines);
  add_intrinsic ("indent", indent);
  add_intrinsic ("internalmode", internalmode);
  add_intrinsic ("print_stack_level", print_stack_level);
  add_intrinsic ("strip_trailing_newlines", strip_trailing_newlines);

  /* Put a nl at the start.  */
  catchar (&buffer, '\n');

  read_in (&buffer, stdin);
  remove_noncomments (&buffer, ptr);
  for (i = 1; i < (unsigned int) ac; i++)
    {
      if (av[i][0] == '-')
	{
	  if (av[i][1] == 'f')
	    {
	      string_type b;
	      FILE *f;
	      init_string (&b);

	      f = fopen (av[i + 1], "r");
	      if (!f)
		{
		  fprintf (stderr, "Can't open the input file %s\n",
			   av[i + 1]);
		  return 33;
		}

	      read_in (&b, f);
	      compile (b.ptr);
	      perform ();
	    }
	  else if (av[i][1] == 'i')
	    {
	      internal_wanted = 1;
	    }
	  else if (av[i][1] == 'w')
	    {
	      warning = 1;
	    }
	  else
	    usage ();
	}
    }
  write_buffer (stack + 0, stdout);
  if (tos != stack)
    {
      fprintf (stderr, "finishing with current stack level %d\n",
	       tos - stack);
      return 1;
    }
  return 0;
}
@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2002
d497 2
d500 2
a501 1
  if (find (tos, "PARAMS") || find (tos, "PROTO") || !find (tos, "("))
@


1.4
log
@resolve conflicts.
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001
d85 1
a85 1
#include <ansidecl.h>
a292 2
#define WORD(x) static void x()

d364 2
a365 1
WORD (call)
d374 2
a375 1
WORD (remchar)
d392 2
a393 1
WORD (push_number)
d402 2
a403 1
WORD (push_text)
d488 1
a488 1
paramstuff (void)
d557 2
a558 1
WORD (translatecomments)
d594 2
a595 1
WORD (manglecomments)
d629 1
a629 1
outputdots (void)
d673 2
a674 1
WORD (courierize)
d695 22
a716 1
		  if (at (tos, idx) == '{' && at (tos, idx + 1) == '*')
d720 1
d726 1
d728 2
a729 1
		  else if (at (tos, idx) == '{' && !command)
d731 1
a731 17
		      cattext (&out, "@@{");
		      idx++;
		    }
		  else if (at (tos, idx) == '}' && !command)
		    {
		      cattext (&out, "@@}");
		      idx++;
		    }
		  else
		    {
		      if (at (tos, idx) == '@@')
			command = 1;
		      else if (isspace ((unsigned char) at (tos, idx))
			       || at (tos, idx) == '}')
			command = 0;
		      catchar (&out, at (tos, idx));
		      idx++;
d734 2
d760 2
a761 1
WORD (bulletize)
d815 2
a816 1
WORD (do_fancy_stuff)
d912 2
a913 1
WORD (icopy_past_newline)
d925 2
a926 1
WORD (kill_bogus_lines)
d1012 2
a1013 1
WORD (indent)
d1063 2
a1064 1
WORD (get_stuff_in_command)
d1079 2
a1080 1
WORD (swap)
d1090 2
a1091 1
WORD (other_dup)
d1100 2
a1101 1
WORD (drop)
d1108 2
a1109 1
WORD (idrop)
d1116 2
a1117 1
WORD (icatstr)
d1126 2
a1127 1
WORD (skip_past_newline)
d1136 2
a1137 1
WORD (internalmode)
d1145 2
a1146 1
WORD (maybecatstr)
d1264 1
a1264 1
perform (void)
d1415 1
a1415 1
bang (void)
d1423 2
a1424 1
WORD (atsign)
d1430 2
a1431 1
WORD (hello)
d1437 2
a1438 1
WORD (stdout_)
d1446 2
a1447 1
WORD (stderr_)
d1455 2
a1456 1
WORD (print)
d1490 1
a1490 1
usage (void)
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 1998
d25 1
a25 1
  
a83 1

d98 1
a98 1
/* Here is a string type ... */
d100 1
a100 1
typedef struct buffer 
a106 1

d122 8
a129 8

static void DEFUN(init_string_with_size,(buffer, size),
	   string_type *buffer AND
	   unsigned int size )
{
    buffer->write_idx = 0;
    buffer->size = size;
    buffer->ptr = malloc(size);
d132 3
a134 2
static void DEFUN(init_string,(buffer),
	   string_type *buffer)
d136 1
a136 2
    init_string_with_size(buffer, DEF_SIZE);

d139 4
a142 3
static int DEFUN(find, (str, what),
	  string_type *str AND
	  char *what)
d144 4
a147 4
    unsigned int i;
    char *p;
    p = what;
    for (i = 0; i < str->write_idx && *p; i++) 
d149 4
a152 4
	if (*p == str->ptr[i])
	 p++;
	else
	 p = what;
d154 1
a154 2
    return (*p == 0);
    
d157 4
a160 3
static void DEFUN(write_buffer,(buffer, f),
	   string_type *buffer AND
	   FILE *f)
d162 1
a162 1
    fwrite(buffer->ptr, buffer->write_idx, 1, f);
d165 3
a167 3

static void DEFUN(delete_string,(buffer),
	   string_type *buffer)
d169 1
a169 1
    free(buffer->ptr);
d172 4
a175 4

static char *DEFUN(addr, (buffer, idx),
	    string_type *buffer AND
	    unsigned int idx)
d177 1
a177 1
    return buffer->ptr + idx;
d180 4
a183 3
static char DEFUN(at,(buffer, pos),
	   string_type *buffer AND
	   unsigned int pos) 
d185 1
a185 1
  if (pos >= buffer->write_idx) 
d190 4
a193 3
static void DEFUN(catchar,(buffer, ch), 
	   string_type *buffer AND
	   int ch)
d195 1
a195 1
  if (buffer->write_idx == buffer->size) 
d197 2
a198 2
      buffer->size *=2;
      buffer->ptr = realloc(buffer->ptr, buffer->size);
d201 1
a201 1
  buffer->ptr[buffer->write_idx ++ ] = ch;
d204 9
a212 9

static void DEFUN(overwrite_string,(dst,   src),
	   string_type *dst AND
	   string_type *src)
{
    free(dst->ptr);
    dst->size = src->size;
    dst->write_idx = src->write_idx;
    dst->ptr = src->ptr;
d215 5
a219 4
static void DEFUN(catbuf,(buffer, buf, len),
	   string_type *buffer AND
	   char *buf AND
	   unsigned int len)
d231 4
a234 3
static void DEFUN(cattext,(buffer, string),
	   string_type *buffer AND
	   char *string)
d239 4
a242 3
static void DEFUN(catstr,(dst, src),
	   string_type *dst AND
	   string_type *src)
d247 4
a250 5

static unsigned int 
DEFUN(skip_white_and_stars,(src, idx),
      string_type *src AND
      unsigned int idx)
d253 1
a253 1
  while ((c = at(src,idx)),
d258 2
a259 2
	     && at(src,idx +1) != '/'
	     && at(src,idx -1) != '\n')) 
a265 1

a279 2


d282 6
a287 7
    char *word;
    struct dict_struct *next;
    stinst_type *code;
    int code_length;
    int code_end;
    int var;
    
d289 1
d291 1
d356 3
a358 2
static void DEFUN(exec,(word),
		  dict_type *word)
d361 2
a362 2
  while (*pc) 
    (*pc)();
d364 2
a365 1
WORD(call)
d367 5
a371 6
    stinst_type *oldpc = pc;
    dict_type *e;
    e =  (dict_type *)(pc [1]);
    exec(e);
    pc = oldpc + 2;
    
d374 1
a374 1
WORD(remchar)
d377 1
a377 1
    tos->write_idx--;    
d391 1
a391 1
WORD(push_number)
d393 5
a397 16
    isp++;
    icheck_range ();
    pc++;
    *isp = (long)(*pc);
    pc++;
}

WORD(push_text)
{
    tos++;
    check_range ();
    init_string(tos);
    pc++;
    cattext(tos,*((char **)pc));
    pc++;
    
d400 9
d415 25
a439 25
static void 
DEFUN(remove_noncomments,(src,dst),
	   string_type *src AND
	   string_type *dst)
{
    unsigned int idx = 0;
    
    while (at(src,idx)) 
    {
	/* Now see if we have a comment at the start of the line */
	if (at(src,idx) == '\n' 
	    && at(src,idx+1) ==  '/' 
	    && at(src,idx+2) == '*') 
	{
	    idx+=3;
	    
	    idx = skip_white_and_stars(src,idx);

	    /* Remove leading dot */
	    if (at(src, idx) == '.')
	     idx++;
	    
	    /* Copy to the end of the line, or till the end of the
	       comment */
	    while (at(src, idx))
d441 1
a441 1
		if (at(src, idx) == '\n') 
d443 6
a448 6
		    /* end of line, echo and scrape of leading blanks  */
		    if (at(src,idx +1) == '\n')
		     catchar(dst,'\n');
		    catchar(dst,'\n');
		    idx++;
		    idx =   skip_white_and_stars(src, idx);
d450 1
a450 1
		else if (at(src, idx) == '*' && at(src,idx+1) == '/') 
d452 3
a454 3
		    idx +=2 ;
		    cattext(dst,"\nENDDD\n");
		    break;
d456 1
a456 1
		else 
d458 2
a459 2
		    catchar(dst, at(src, idx));
		    idx++;
d463 2
a464 1
	else idx++;
d485 1
a485 1
DEFUN_VOID(paramstuff)
d487 6
a492 16
    unsigned int openp;
    unsigned int fname;
    unsigned int idx;
    string_type out;
    init_string(&out);
    

    /* make sure that it's not already param'd or proto'd */
    if(find(tos,"PARAMS") || find(tos,"PROTO") || !find(tos,"(")) {
	    catstr(&out,tos);
	}
    else 
    {
	/* Find the open paren */
	for (openp = 0; at(tos, openp) != '('  && at(tos,openp); openp++)
	 ;
d494 15
a508 2
	fname = openp;
	/* Step back to the fname */
d510 6
a515 6
	while (fname && isspace((unsigned char) at(tos, fname)))
	 fname --;
	while (fname
	       && !isspace((unsigned char) at(tos,fname))
	       && at(tos,fname) != '*')
	 fname--;
d517 3
a519 3
	fname++;
	
	for (idx = 0; idx < fname; idx++) 	/* Output type */
d521 2
a522 1
	    catchar(&out, at(tos,idx));
d524 4
a527 2
    
        cattext(&out, "\n");	/* Insert a newline between type and fnname */
d529 3
a531 1
	for (idx = fname; idx < openp; idx++) 		/* Output fnname */
d533 2
a534 1
	    catchar(&out, at(tos,idx));
d536 2
d539 1
a539 1
	cattext(&out," PARAMS (");
d541 4
a544 6
	while (at(tos,idx) && at(tos,idx) !=';') 
	{
	    catchar(&out, at(tos, idx));
	    idx++;
	}
	cattext(&out,");\n\n");
d546 3
a548 3
    overwrite_string(tos, &out);    
    pc++;
    
a550 2


d554 1
a554 1
WORD(translatecomments)
d556 5
a560 5
    unsigned int idx = 0;
    string_type out;
    init_string(&out);
    
    while (at(tos, idx)) 
d562 1
a562 1
	if (at(tos,idx) == '{' && at(tos,idx+1) =='*') 
d564 2
a565 2
	    cattext(&out,"/*");
	    idx+=2;
d567 1
a567 1
	else if (at(tos,idx) == '*' && at(tos,idx+1) =='}') 
d569 2
a570 2
	    cattext(&out,"*/");
	    idx+=2;
d572 1
a572 1
	else  
d574 2
a575 2
	    catchar(&out, at(tos, idx));
	    idx++;
d579 1
d581 1
a581 4
    overwrite_string(tos, &out);
    
    pc++;
    
d590 1
a590 1
WORD(manglecomments)
d592 5
a596 5
    unsigned int idx = 0;
    string_type out;
    init_string(&out);
    
    while (at(tos, idx)) 
d598 1
a598 1
	if (at(tos,idx) == '\n' && at(tos,idx+1) =='*') 
d600 2
a601 2
	    cattext(&out,"	/*");
	    idx+=2;
d603 1
a603 1
	else if (at(tos,idx) == '*' && at(tos,idx+1) =='}') 
d605 2
a606 2
	    cattext(&out,"*/");
	    idx+=2;
d608 1
a608 1
	else  
d610 2
a611 2
	    catchar(&out, at(tos, idx));
	    idx++;
d615 1
d617 1
a617 4
    overwrite_string(tos, &out);
    
    pc++;
    
d624 1
a624 1
DEFUN_VOID(outputdots)
d626 5
a630 5
    unsigned int idx = 0;
    string_type out;
    init_string(&out);
    
    while (at(tos, idx)) 
d632 1
a632 1
	if (at(tos, idx) == '\n' && at(tos, idx+1) == '.') 
d636 2
a637 2
	    
	    while ((c = at(tos, idx)) && c != '\n')
d639 1
a639 1
	      if (c == '{' && at(tos,idx+1) =='*') 
d641 2
a642 2
		    cattext(&out," /*");
		    idx+=2;
d644 1
a644 1
	      else if (c == '*' && at(tos,idx+1) =='}') 
d646 2
a647 2
		    cattext(&out,"*/");
		    idx+=2;
d651 2
a652 2
		    catchar(&out, c);
		    idx++;
d655 1
a655 1
	    catchar(&out,'\n');
d657 1
a657 1
	else 
d659 1
a659 1
	    idx++;
d661 1
a661 1
    }	
d663 2
a664 3
    overwrite_string(tos, &out);
    pc++;
    
d668 1
a668 1
WORD(courierize)
d670 11
a680 11
    string_type out;
    unsigned int idx = 0;
    int command = 0;
    
    init_string(&out);
    
    while (at(tos, idx)) 
    {
	if (at(tos, idx) == '\n' 
	    && (at(tos, idx +1 ) == '.'
		|| at(tos,idx+1) == '|')) 
d682 2
a683 2
	    cattext(&out,"\n@@example\n");
	    do 
d685 3
a687 3
		idx += 2;
		
		while (at(tos, idx) && at(tos, idx)!='\n')
d689 1
a689 1
		    if (at(tos,idx)=='{' && at(tos,idx+1) =='*') 
d691 2
a692 2
			cattext(&out," /*");
			idx+=2;
d694 1
a694 1
		    else if (at(tos,idx)=='*' && at(tos,idx+1) =='}') 
d696 2
a697 2
			cattext(&out,"*/");
			idx+=2;
d699 1
a699 1
	            else if (at(tos,idx) == '{' && !command)
d701 2
a702 2
			cattext(&out,"@@{");
			idx++;
d704 1
a704 1
	            else if (at(tos,idx) == '}' && !command)
d706 2
a707 2
			cattext(&out,"@@}");
			idx++;
d709 1
a709 1
		    else 
d711 7
a717 7
			if (at(tos,idx) == '@@')
			    command = 1;
			else if (isspace((unsigned char) at(tos,idx))
				 || at(tos,idx) == '}')
			    command = 0;
			catchar(&out, at(tos, idx));
			idx++;
d719 1
a719 1
		    
d721 12
a732 12
		catchar(&out,'\n');
	    }  
	    while (at(tos, idx) == '\n' 
		   && ((at(tos, idx+1) == '.')
		       || (at(tos,idx+1) == '|')))
	      ;
	    cattext(&out,"@@end example");
	}
	else 
	{    
	    catchar(&out, at(tos, idx));
	    idx++;
d734 1
a734 1
    }    
d736 2
a737 4
    overwrite_string(tos, &out);
    pc++;

    
d744 6
d751 13
a763 19
WORD(bulletize)
{
    unsigned int idx = 0;
    int on = 0;
    string_type out;
    init_string(&out);
    
    while (at(tos, idx)) {
	if (at(tos, idx) == '@@' &&
	    at(tos, idx+1) == '*') 
	{
	  cattext(&out,"*");
	  idx+=2;
	}
	
	else
	    if (at(tos, idx) == '\n' &&
		at(tos, idx+1) == 'o' &&
		isspace((unsigned char) at(tos, idx +2)))
d765 3
a767 8
		if (!on) 
		{
		    cattext(&out,"\n@@itemize @@bullet\n");
		    on = 1;
		    
		}
		cattext(&out,"\n@@item\n");
		idx+=3;
d769 9
a777 1
	    else 
d779 2
a780 10
		catchar(&out, at(tos, idx));
		if (on && at(tos, idx) == '\n' &&
		    at(tos, idx+1) == '\n' &&
		    at(tos, idx+2) != 'o')
		{
		    cattext(&out, "@@end itemize");
		    on = 0;
		}
		idx++;
		
d782 2
d785 2
a786 1
    if (on) 
d788 2
a789 2
	cattext(&out,"@@end itemize\n");
    }	
d791 3
a793 4
    delete_string(tos);
    *tos = out;
    pc++;
    
a796 1
   
d798 1
a798 1
WORD(do_fancy_stuff)
d800 14
a813 14
    unsigned int idx = 0;
    string_type out;
    init_string(&out);
    while (at(tos, idx)) 
    {
	if (at(tos, idx) == '<' 
	    && at(tos, idx+1) == '<'
	    && !isspace((unsigned char) at(tos,idx + 2))) 
	{
	    /* This qualifies as a << startup */
	    idx +=2;
	    cattext(&out,"@@code{");
	    while(at(tos,idx) &&
		  at(tos,idx) != '>' )
d815 3
a817 3
		catchar(&out, at(tos, idx));
		idx++;
		
d819 2
a820 2
	    cattext(&out,"}");
	    idx+=2;
d822 1
a822 1
	else 
d824 2
a825 2
	    catchar(&out, at(tos, idx));
	    idx++;
d828 3
a830 27
    delete_string(tos);
    *tos = out;
    pc++;
    
}
/* A command is all upper case,and alone on a line */
static int 
DEFUN( iscommand,(ptr, idx),
      string_type *ptr AND
      unsigned int idx)
{
    unsigned int len = 0;
    while (at(ptr,idx)) {
	    if (isupper((unsigned char) at(ptr,idx)) || at(ptr,idx) == ' ' ||
		at(ptr,idx) == '_') 
	    {
	     len++;
	     idx++;
	 }
	    else if(at(ptr,idx) == '\n')
	    {
		if (len > 3) return 1;
		return 0;
	    }
	    else return 0;
	}
    return 0;
d834 1
d837 3
a839 4
DEFUN(copy_past_newline,(ptr, idx, dst),
      string_type *ptr AND
      unsigned int idx AND
      string_type *dst)
d841 45
a885 1
    int column = 0;
d887 4
a890 21
    while (at(ptr, idx) && at(ptr, idx) != '\n') 
    {
	if (at (ptr, idx) == '\t')
	  {
	    /* Expand tabs.  Neither makeinfo nor TeX can cope well with
	       them.  */
	    do
	      catchar (dst, ' ');
	    while (++column & 7);
	  }
	else
	  {
	    catchar(dst, at(ptr, idx));
	    column++;
	  }
	idx++;
	
    }    
    catchar(dst, at(ptr, idx));
    idx++;
    return idx;
d894 1
a894 1
WORD(icopy_past_newline)
d896 5
a900 5
    tos++;
    check_range ();
    init_string(tos);
    idx = copy_past_newline(ptr, idx, tos);
    pc++;	
d904 1
a904 1
   Take the string at the top of the stack, do some prettying */
d906 3
d910 8
a917 12
WORD(kill_bogus_lines)
{
    int sl ;
    
    int idx = 0;
    int c;
    int dot = 0    ;
    
    string_type out;    
    init_string(&out);
    /* Drop leading nl */
    while (at(tos,idx) == '\n')
d919 1
a919 1
	idx++;
d921 6
a926 6
    c = idx;
    
    /* If the first char is a '.' prepend a newline so that it is
       recognized properly later.  */
    if (at (tos, idx) == '.')
      catchar (&out, '\n');
d928 2
a929 2
    /* Find the last char */
    while (at(tos,idx))
d931 1
a931 1
	idx++;
d933 5
a937 2
    
    /* find the last non white before the nl */
d939 5
a943 8
    
    while (idx && isspace((unsigned char) at(tos,idx)))
     idx--;
    idx++;
    
    /* Copy buffer upto last char, but blank lines before and after
       dots don't count */
    sl = 1;
d945 1
a945 1
    while (c < idx)
d947 3
a949 3
	if (at(tos,c) == '\n' 
	    && at(tos,c+1) == '\n'
	    && at(tos,c+2) == '.') 
d951 2
a952 2
	    /* Ignore two newlines before a dot*/
	    c++;
d954 1
a954 1
	else if (at(tos,c) == '.' && sl)
d956 2
a957 2
	    /* remember that this line started with a dot */
	    dot=2;
d959 3
a961 3
	else if (at(tos,c) == '\n' 
		 && at(tos,c+1) == '\n'
		 && dot)
d963 2
a964 2
	    c++;
	    /* Ignore two newlines when last line was dot */
d967 2
a968 2
	catchar(&out, at(tos,c));
	if (at(tos,c) == '\n')
d970 6
a975 3
	    sl = 1;
	    
	    if (dot == 2)dot=1;else dot = 0;
d977 4
a980 4
	else
	  sl = 0;
	
	c++;	
d983 7
a989 8
    
    /* Append nl*/
    catchar(&out, '\n');
    pc++;
    delete_string(tos);
    *tos = out;
    
    
d992 1
a992 1
WORD(indent)
d994 13
a1006 7
    string_type out;
    int tab = 0;
    int idx = 0;
    int ol =0;
    init_string(&out);
    while (at(tos,idx)) {
	    switch (at(tos,idx)) 
d1008 1
a1008 30
	      case '\n':
		cattext(&out,"\n");
		idx++;
		if (tab && at(tos,idx))
		{
		    cattext(&out,"    ");
		}
		ol = 0;
		break;
	      case '(':
		tab++;
		if (ol == 0)
		    cattext(&out,"   ");
		idx++;
		cattext(&out,"(");
		ol = 1;
		break;
	      case ')':
		tab--;
		cattext(&out,")");
		idx++;
		ol=1;
		
		break;
	      default:
		catchar(&out,at(tos,idx));
		ol=1;
		
		idx++;
		break;
d1010 20
a1029 1
	}	
d1031 8
a1038 3
    pc++;
    delete_string(tos);
    *tos = out;
d1042 1
a1042 2

WORD(get_stuff_in_command)
d1044 3
a1046 3
    tos++;
    check_range ();
    init_string(tos);
d1048 7
a1054 5
    while (at(ptr, idx)) {
	    if (iscommand(ptr, idx))  break;
	    idx =   copy_past_newline(ptr, idx, tos);
	}
    pc++;    
d1057 1
a1057 1
WORD(swap)
d1059 6
a1064 7
    string_type t;
    
    t = tos[0];
    tos[0] = tos[-1];
    tos[-1] =t; 
    pc++;
    
d1067 1
a1067 1
WORD(other_dup)
d1069 5
a1073 5
    tos++;
    check_range ();
    init_string(tos);
    catstr(tos, tos-1);
    pc++;
d1076 1
a1076 1
WORD(drop)
d1083 1
a1083 1
WORD(idrop)
d1090 1
a1090 1
WORD(icatstr)
d1092 5
a1096 5
    tos--;
    check_range ();
    catstr(tos, tos+1);
    delete_string(tos+1);
    pc++;
d1099 1
a1099 1
WORD(skip_past_newline)
d1101 2
a1102 3
    while (at(ptr,idx) 
	   && at(ptr,idx) != '\n')
     idx++;
d1104 2
a1105 1
    pc++;
d1108 1
a1108 2

WORD(internalmode)
d1110 4
a1113 4
    internal_mode = *(isp);
    isp--;
    icheck_range ();
    pc++;
d1116 1
a1116 1
WORD(maybecatstr)
d1118 1
a1118 1
    if (internal_wanted == internal_mode) 
d1120 1
a1120 1
	catstr(tos-1, tos);
d1122 4
a1125 4
    delete_string(tos);
    tos--;
    check_range ();
    pc++;
d1129 18
a1146 21
DEFUN(nextword,(string, word),
      char *string AND
      char **word)
{
    char *word_start;
    int idx;
    char *dst;
    char *src;
    
    int length = 0;
    
    while (isspace((unsigned char) *string) || *string == '-') {
	    if (*string == '-') 
	    {
		while (*string && *string != '\n') 
		 string++;
		
	    }
	    else {
		    string++;
		}
d1148 1
a1148 20
    if (!*string) return 0;
    
    word_start = string;
    if (*string == '"') 
      {
	do
	  {
	    string++;
	    length++;
	    if (*string == '\\')
	      {
		string += 2;
		length += 2;
	      }
	  }
	while (*string != '"');
      }
    else     
      {
	while (!isspace((unsigned char) *string)) 
d1150 1
a1150 3
	    string++;
	    length++;
	
d1153 2
a1154 2
    
    *word = malloc(length + 1);
d1156 8
a1163 8
    dst = *word;
    src = word_start;


    for (idx= 0; idx < length; idx++) 
      {
	if (src[idx] == '\\')
	  switch (src[idx+1])
d1165 2
a1166 12
	    case 'n':
	      *dst++ = '\n';
	      idx++;
	      break;
	    case '"':
	    case '\\':
	      *dst++ = src[idx+1];
	      idx++;
	      break;
	    default:
	      *dst++ = '\\';
	      break;
d1168 2
a1169 2
	else
	  *dst++ = src[idx];
d1171 6
a1176 1
    *dst++ = 0;
d1178 2
d1181 1
d1183 2
d1186 22
d1209 4
a1212 5
    if(*string)    
     return string + 1;
    else 
     return 0;
    
d1214 1
d1216 1
d1218 2
a1219 2
DEFUN(lookup_word,(word),
      char *word)
d1222 4
a1225 2
  while (ptr) {
      if (strcmp(ptr->word, word) == 0) return ptr;
a1226 1
	    
d1229 1
a1229 1
   fprintf(stderr,"Can't find %s\n",word);
a1230 2
    
    
d1233 2
a1234 1
static void DEFUN_VOID(perform)
a1236 9
    
  while (at(ptr, idx)) {
      /* It's worth looking through the command list */
      if (iscommand(ptr, idx))
      {
	char *next;
	dict_type *word ;
		
	(void)		nextword(addr(ptr, idx), &next);
d1238 7
d1246 1
a1246 1
	word = lookup_word(next);
d1248 1
d1250 10
a1259 1
		
a1260 3
	if (word) 
	{
	  exec(word);
d1262 2
a1263 10
	else
	{
	  if (warning)
	   fprintf(stderr,"warning, %s is not recognised\n",  next);
	  skip_past_newline();
	}
		
      }
      else skip_past_newline();

d1268 2
a1269 2
DEFUN(newentry,(word),
      char *word)
d1271 8
a1278 9
    dict_type *new = (dict_type *)malloc(sizeof(dict_type));
    new->word = word;
    new->next = root;
    root = new;
    new->code = (stinst_type *)malloc(sizeof(stinst_type ));
    new->code_length = 1;
    new->code_end = 0;
    return new;
    
d1281 13
d1295 1
a1295 15
unsigned int
DEFUN(add_to_definition,(entry, word), 
      dict_type *entry AND
      stinst_type word)
{
    if (entry->code_end == entry->code_length) 
    {
	entry->code_length += 2;
	entry->code =
	 (stinst_type *) realloc((char *)(entry->code),
			       entry->code_length *sizeof(word_type));
    }
    entry->code[entry->code_end] = word;
    
return     entry->code_end++;  
d1298 9
a1306 5





d1309 7
a1315 7
DEFUN(add_intrinsic,(name, func),
      char *name AND
      void (*func)())
{
    dict_type *new = newentry(name);
    add_to_definition(new, func);
    add_to_definition(new, 0);
d1319 2
a1320 2
DEFUN(add_var,(name),
      char *name)
d1322 8
a1329 5
    dict_type *new = newentry(name);
    add_to_definition(new, push_number);
    add_to_definition(new, (stinst_type)(&(new->var)));
    add_to_definition(new,0);
}
d1331 8
d1340 3
a1342 27
void 
DEFUN(compile, (string), 
      char *string)
{
    /* add words to the dictionary */
    char *word;
    string = nextword(string, &word);
    while (string && *string && word[0]) 
    {
	if (strcmp(word,"var")==0) 
	{
 string=nextword(string, &word);
	  
	  add_var(word);
 string=nextword(string, &word);
	}
else	
	    
	if (word[0] == ':')
	{
	    dict_type *ptr;
	    /* Compile a word and add to dictionary */
	    string = nextword(string, &word);
	    
	    ptr = newentry(word);
	    string = nextword(string, &word);
	    while (word[0] != ';' ) 
d1344 27
a1370 27
		 switch (word[0]) 
		 {
		   case '"':
		     /* got a string, embed magic push string
			function */
		     add_to_definition(ptr, push_text);
		     add_to_definition(ptr, (stinst_type)(word+1));
		     break;
		   case '0':
		   case '1':
		   case '2':
		   case '3':
		   case '4':
		   case '5':
		   case '6':
		   case '7':
		   case '8':
		   case '9':
		     /* Got a number, embedd the magic push number
			function */
		     add_to_definition(ptr, push_number);
		     add_to_definition(ptr, (stinst_type)atol(word));
		     break;
		   default:
		     add_to_definition(ptr, call);
		     add_to_definition(ptr, (stinst_type)lookup_word(word));
		 }
d1372 1
a1372 1
		string = nextword(string, &word);		     
d1374 2
a1375 2
	    add_to_definition(ptr,0);
	    string = nextword(string, &word);
d1377 1
a1377 1
	else 
d1379 2
a1380 2
	    fprintf(stderr,"syntax error at %s\n",string-1);
	}	    
a1381 1

d1384 2
a1385 2
 
static void DEFUN_VOID(bang)
d1387 2
a1388 2
  *(long *)((isp[0])) = isp[-1];
  isp-=2;
d1393 1
a1393 1
WORD(atsign)
d1395 2
a1396 2
    isp[0] = *(long *)(isp[0]);
    pc++;
d1399 1
a1399 1
WORD(hello)
d1401 2
a1402 2
  printf("hello\n");
  pc++;    
d1405 1
a1405 1
WORD(stdout_)
d1413 1
a1413 1
WORD(stderr_)
d1421 1
a1421 1
WORD(print)
d1436 8
a1443 8

static void DEFUN(read_in, (str, file), 
	   string_type *str AND
		  FILE *file)
{
    char buff[10000];    
    unsigned int r;
    do 
d1445 2
a1446 2
	r = fread(buff, 1, sizeof(buff), file);
	catbuf(str, buff, r);
d1448 4
a1451 4
    while (r);
    buff[0] = 0;
    
    catbuf(str, buff,1);
d1454 2
a1455 2

static void DEFUN_VOID(usage)
d1457 2
a1458 2
    fprintf(stderr,"usage: -[d|i|g] <file >file\n");
    exit(33);    
d1472 4
a1475 3
int DEFUN(main,(ac,av),
int ac AND
char *av[])
d1481 4
a1484 4
  init_string(&buffer);
  init_string(&pptr);
  init_string(stack+0);
  tos=stack+1;
d1486 19
a1504 19
    
  add_intrinsic("push_text", push_text);
  add_intrinsic("!", bang);
  add_intrinsic("@@", atsign);
  add_intrinsic("hello",hello);    
  add_intrinsic("stdout",stdout_);    
  add_intrinsic("stderr",stderr_);    
  add_intrinsic("print",print);    
  add_intrinsic("skip_past_newline", skip_past_newline );
  add_intrinsic("catstr", icatstr );
  add_intrinsic("copy_past_newline", icopy_past_newline );
  add_intrinsic("dup", other_dup );
  add_intrinsic("drop", drop);
  add_intrinsic("idrop", idrop);
  add_intrinsic("remchar", remchar );
  add_intrinsic("get_stuff_in_command", get_stuff_in_command );
  add_intrinsic("do_fancy_stuff", do_fancy_stuff );
  add_intrinsic("bulletize", bulletize );
  add_intrinsic("courierize", courierize );
d1508 50
a1557 48
  add_intrinsic("exit", chew_exit );
  add_intrinsic("swap", swap );
  add_intrinsic("outputdots", outputdots );
  add_intrinsic("paramstuff", paramstuff );
  add_intrinsic("maybecatstr", maybecatstr );
  add_intrinsic("translatecomments", translatecomments );
  add_intrinsic("kill_bogus_lines", kill_bogus_lines);
  add_intrinsic("indent", indent);
  add_intrinsic("internalmode", internalmode);
  add_intrinsic("print_stack_level", print_stack_level);
  add_intrinsic("strip_trailing_newlines", strip_trailing_newlines);
    
  /* Put a nl at the start */
  catchar(&buffer,'\n');

  read_in(&buffer, stdin); 
  remove_noncomments(&buffer, ptr);
  for (i= 1; i < (unsigned int) ac; i++) 
  {
    if (av[i][0] == '-')
    {
      if (av[i][1] == 'f')
      {
	string_type b;
	FILE *f;
	init_string(&b);

	f  = fopen(av[i+1],"r");
	if (!f) 
	{
	  fprintf(stderr,"Can't open the input file %s\n",av[i+1]);
	  return 33;
	}

	read_in(&b, f);
	compile(b.ptr);
	perform();	
      }
      else if (av[i][1] == 'i') 
      {
	internal_wanted = 1;
      }
      else if (av[i][1] == 'w') 
      {
	warning = 1;
      }
      else
	usage ();
d1559 1
a1559 2
  }      
  write_buffer(stack+0, stdout);
d1562 2
a1563 1
      fprintf (stderr, "finishing with current stack level %d\n", tos - stack);
@


1.2
log
@Merge the Cygnus 960904 sources
@
text
@d2 2
a3 1
   Copyright (C) 1990-1991 Free Software Foundation, Inc.
a121 1
static unsigned int skip_white_and_starts (string_type *, unsigned int);
d251 1
a251 1
	 isspace (c)
d326 1
a326 1
static void paramstuff (void), translatecomments (void), manglecomments (void);
d382 1
a382 1
  while ((isspace (at (tos, tos->write_idx - 1))
d506 1
a506 1
	while (fname && isspace(at(tos, fname)))
d508 3
a510 1
	while (fname && !isspace(at(tos,fname)) && at(tos,fname) != '*')
d578 4
d616 2
d630 1
a630 1
	  char c, c2;
d710 2
a711 1
			else if (isspace(at(tos,idx)) || at(tos,idx) == '}')
d721 3
a723 2
		   && (at(tos, idx+1) == '.')
		   || (at(tos,idx+1) == '|'));
d759 1
a759 1
else
d762 1
a762 1
		isspace(at(tos, idx +2)))
d810 1
a810 1
	    && !isspace(at(tos,idx + 2))) 
d844 1
a844 1
	    if (isupper(at(ptr,idx)) || at(ptr,idx) == ' ' ||
d862 1
d868 2
d872 13
a884 1
	catchar(dst, at(ptr, idx));
a910 1
    int nl = 0;
d924 5
d938 1
a938 1
    while (idx && isspace(at(tos,idx)))
d1004 1
a1004 1
		if (tab) 
d1139 1
a1139 1
    while (isspace(*string) || *string == '-') {
d1169 1
a1169 1
	while (!isspace(*string)) 
a1241 3
	unsigned int i;
	int found = 0;

a1333 2
    int jstack[STACK];
    int *jptr = jstack;
d1443 1
a1443 1
    fprintf (stderr, "print: illegal print destination `%d'\n", *isp);
d1539 1
a1539 1
  for (i= 1; i < ac; i++) 
d1568 2
@


1.1
log
@Initial revision
@
text
@d946 2
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a945 2
	else
	  sl = 0;
@


1.1.1.3
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 1998
   Free Software Foundation, Inc.
d121 1
d251 1
a251 1
	 isspace ((unsigned char) c)
d326 1
a326 1
static void paramstuff (void), translatecomments (void);
d382 1
a382 1
  while ((isspace ((unsigned char) at (tos, tos->write_idx - 1))
d506 1
a506 1
	while (fname && isspace((unsigned char) at(tos, fname)))
d508 1
a508 3
	while (fname
	       && !isspace((unsigned char) at(tos,fname))
	       && at(tos,fname) != '*')
a575 4
#if 0

/* This is not currently used.  */

a609 2
#endif

d622 1
a622 1
	  char c;
d702 1
a702 2
			else if (isspace((unsigned char) at(tos,idx))
				 || at(tos,idx) == '}')
d712 2
a713 3
		   && ((at(tos, idx+1) == '.')
		       || (at(tos,idx+1) == '|')))
	      ;
d749 1
a749 1
	else
d752 1
a752 1
		isspace((unsigned char) at(tos, idx +2)))
d800 1
a800 1
	    && !isspace((unsigned char) at(tos,idx + 2))) 
d834 1
a834 1
	    if (isupper((unsigned char) at(ptr,idx)) || at(ptr,idx) == ' ' ||
a851 1
static int
a856 2
    int column = 0;

d859 1
a859 13
	if (at (ptr, idx) == '\t')
	  {
	    /* Expand tabs.  Neither makeinfo nor TeX can cope well with
	       them.  */
	    do
	      catchar (dst, ' ');
	    while (++column & 7);
	  }
	else
	  {
	    catchar(dst, at(ptr, idx));
	    column++;
	  }
d886 1
a899 5
    /* If the first char is a '.' prepend a newline so that it is
       recognized properly later.  */
    if (at (tos, idx) == '.')
      catchar (&out, '\n');

d909 1
a909 1
    while (idx && isspace((unsigned char) at(tos,idx)))
d975 1
a975 1
		if (tab && at(tos,idx))
d1110 1
a1110 1
    while (isspace((unsigned char) *string) || *string == '-') {
d1140 1
a1140 1
	while (!isspace((unsigned char) *string)) 
d1213 3
d1308 2
d1419 1
a1419 1
    fprintf (stderr, "print: illegal print destination `%ld'\n", *isp);
d1515 1
a1515 1
  for (i= 1; i < (unsigned int) ac; i++) 
a1543 2
      else
	usage ();
@


1.1.1.4
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001
d25 1
a25 1

d84 1
d99 1
a99 1
/* Here is a string type ...  */
d101 1
a101 1
typedef struct buffer
d108 1
d124 8
a131 8
static void
init_string_with_size (buffer, size)
     string_type *buffer;
     unsigned int size;
{
  buffer->write_idx = 0;
  buffer->size = size;
  buffer->ptr = malloc (size);
d134 2
a135 3
static void
init_string (buffer)
     string_type *buffer;
d137 2
a138 1
  init_string_with_size (buffer, DEF_SIZE);
d141 3
a143 4
static int
find (str, what)
     string_type *str;
     char *what;
d145 4
a148 4
  unsigned int i;
  char *p;
  p = what;
  for (i = 0; i < str->write_idx && *p; i++)
d150 4
a153 4
      if (*p == str->ptr[i])
	p++;
      else
	p = what;
d155 2
a156 1
  return (*p == 0);
d159 3
a161 4
static void
write_buffer (buffer, f)
     string_type *buffer;
     FILE *f;
d163 1
a163 1
  fwrite (buffer->ptr, buffer->write_idx, 1, f);
d166 3
a168 3
static void
delete_string (buffer)
     string_type *buffer;
d170 1
a170 1
  free (buffer->ptr);
d173 4
a176 4
static char *
addr (buffer, idx)
     string_type *buffer;
     unsigned int idx;
d178 1
a178 1
  return buffer->ptr + idx;
d181 3
a183 4
static char
at (buffer, pos)
     string_type *buffer;
     unsigned int pos;
d185 1
a185 1
  if (pos >= buffer->write_idx)
d190 3
a192 4
static void
catchar (buffer, ch)
     string_type *buffer;
     int ch;
d194 1
a194 1
  if (buffer->write_idx == buffer->size)
d196 2
a197 2
      buffer->size *= 2;
      buffer->ptr = realloc (buffer->ptr, buffer->size);
d200 1
a200 1
  buffer->ptr[buffer->write_idx++] = ch;
d203 9
a211 9
static void
overwrite_string (dst, src)
     string_type *dst;
     string_type *src;
{
  free (dst->ptr);
  dst->size = src->size;
  dst->write_idx = src->write_idx;
  dst->ptr = src->ptr;
d214 4
a217 5
static void
catbuf (buffer, buf, len)
     string_type *buffer;
     char *buf;
     unsigned int len;
d229 3
a231 4
static void
cattext (buffer, string)
     string_type *buffer;
     char *string;
d236 3
a238 4
static void
catstr (dst, src)
     string_type *dst;
     string_type *src;
d243 5
a247 4
static unsigned int
skip_white_and_stars (src, idx)
     string_type *src;
     unsigned int idx;
d250 1
a250 1
  while ((c = at (src, idx)),
d255 2
a256 2
	     && at (src, idx +1) != '/'
	     && at (src, idx -1) != '\n'))
d263 1
d278 2
d282 7
a288 6
  char *word;
  struct dict_struct *next;
  stinst_type *code;
  int code_length;
  int code_end;
  int var;
a289 1

a290 1

d355 2
a356 3
static void
exec (word)
     dict_type *word;
d359 2
a360 2
  while (*pc)
    (*pc) ();
d362 1
a362 2

WORD (call)
d364 6
a369 5
  stinst_type *oldpc = pc;
  dict_type *e;
  e = (dict_type *) (pc[1]);
  exec (e);
  pc = oldpc + 2;
d372 1
a372 1
WORD (remchar)
d375 1
a375 1
    tos->write_idx--;
d389 1
a389 1
WORD (push_number)
d391 16
a406 5
  isp++;
  icheck_range ();
  pc++;
  *isp = (long) (*pc);
  pc++;
a408 9
WORD (push_text)
{
  tos++;
  check_range ();
  init_string (tos);
  pc++;
  cattext (tos, *((char **) pc));
  pc++;
}
d415 25
a439 25
static void
remove_noncomments (src, dst)
     string_type *src;
     string_type *dst;
{
  unsigned int idx = 0;

  while (at (src, idx))
    {
      /* Now see if we have a comment at the start of the line.  */
      if (at (src, idx) == '\n'
	  && at (src, idx + 1) == '/'
	  && at (src, idx + 2) == '*')
	{
	  idx += 3;

	  idx = skip_white_and_stars (src, idx);

	  /* Remove leading dot */
	  if (at (src, idx) == '.')
	    idx++;

	  /* Copy to the end of the line, or till the end of the
	     comment.  */
	  while (at (src, idx))
d441 1
a441 1
	      if (at (src, idx) == '\n')
d443 6
a448 6
		  /* end of line, echo and scrape of leading blanks  */
		  if (at (src, idx + 1) == '\n')
		    catchar (dst, '\n');
		  catchar (dst, '\n');
		  idx++;
		  idx = skip_white_and_stars (src, idx);
d450 1
a450 1
	      else if (at (src, idx) == '*' && at (src, idx + 1) == '/')
d452 3
a454 3
		  idx += 2;
		  cattext (dst, "\nENDDD\n");
		  break;
d456 1
a456 1
	      else
d458 2
a459 2
		  catchar (dst, at (src, idx));
		  idx++;
d463 1
a463 2
      else
	idx++;
d484 1
a484 1
paramstuff (void)
d486 16
a501 6
  unsigned int openp;
  unsigned int fname;
  unsigned int idx;
  unsigned int len;
  string_type out;
  init_string (&out);
d503 2
a504 19
  /* Make sure that it's not already param'd or proto'd.  */
  if (find (tos, "PARAMS") || find (tos, "PROTO") || !find (tos, "("))
    {
      catstr (&out, tos);
    }
  else
    {
      /* Find the open paren.  */
      for (openp = 0; at (tos, openp) != '(' && at (tos, openp); openp++)
	;

      fname = openp;
      /* Step back to the fname.  */
      fname--;
      while (fname && isspace ((unsigned char) at (tos, fname)))
	fname--;
      while (fname
	     && !isspace ((unsigned char) at (tos,fname))
	     && at (tos,fname) != '*')
d506 6
d513 8
a520 1
      fname++;
d522 1
a522 3
      /* Output type, omitting trailing whitespace character(s), if
         any.  */
      for (len = fname; 0 < len; len--)
d524 1
a524 2
	  if (!isspace ((unsigned char) at (tos, len - 1)))
	    break;
a525 2
      for (idx = 0; idx < len; idx++)
	catchar (&out, at (tos, idx));
d527 1
a527 1
      cattext (&out, "\n");	/* Insert a newline between type and fnname */
d529 1
a529 3
      /* Output function name, omitting trailing whitespace
         character(s), if any.  */
      for (len = openp; 0 < len; len--)
d531 2
a532 2
	  if (!isspace ((unsigned char) at (tos, len - 1)))
	    break;
d534 6
a539 4
      for (idx = fname; idx < len; idx++)
	catchar (&out, at (tos, idx));

      cattext (&out, " PARAMS (");
a540 7
      for (idx = openp; at (tos, idx) && at (tos, idx) != ';'; idx++)
	catchar (&out, at (tos, idx));

      cattext (&out, ");\n\n");
    }
  overwrite_string (tos, &out);
  pc++;
a541 1
}
d546 1
a546 1
WORD (translatecomments)
d548 5
a552 5
  unsigned int idx = 0;
  string_type out;
  init_string (&out);

  while (at (tos, idx))
d554 1
a554 1
      if (at (tos, idx) == '{' && at (tos, idx + 1) == '*')
d556 2
a557 2
	  cattext (&out, "/*");
	  idx += 2;
d559 1
a559 1
      else if (at (tos, idx) == '*' && at (tos, idx + 1) == '}')
d561 2
a562 2
	  cattext (&out, "*/");
	  idx += 2;
d564 1
a564 1
      else
d566 2
a567 2
	  catchar (&out, at (tos, idx));
	  idx++;
a570 1
  overwrite_string (tos, &out);
d572 4
a575 1
  pc++;
d584 1
a584 1
WORD (manglecomments)
d586 5
a590 5
  unsigned int idx = 0;
  string_type out;
  init_string (&out);

  while (at (tos, idx))
d592 1
a592 1
      if (at (tos, idx) == '\n' && at (tos, idx + 1) == '*')
d594 2
a595 2
	  cattext (&out, "	/*");
	  idx += 2;
d597 1
a597 1
      else if (at (tos, idx) == '*' && at (tos, idx + 1) == '}')
d599 2
a600 2
	  cattext (&out, "*/");
	  idx += 2;
d602 1
a602 1
      else
d604 2
a605 2
	  catchar (&out, at (tos, idx));
	  idx++;
a608 1
  overwrite_string (tos, &out);
d610 4
a613 1
  pc++;
d620 1
a620 1
outputdots (void)
d622 5
a626 5
  unsigned int idx = 0;
  string_type out;
  init_string (&out);

  while (at (tos, idx))
d628 1
a628 1
      if (at (tos, idx) == '\n' && at (tos, idx + 1) == '.')
d632 2
a633 2

	  while ((c = at (tos, idx)) && c != '\n')
d635 1
a635 1
	      if (c == '{' && at (tos, idx + 1) == '*')
d637 2
a638 2
		  cattext (&out, "/*");
		  idx += 2;
d640 1
a640 1
	      else if (c == '*' && at (tos, idx + 1) == '}')
d642 2
a643 2
		  cattext (&out, "*/");
		  idx += 2;
d647 2
a648 2
		  catchar (&out, c);
		  idx++;
d651 1
a651 1
	  catchar (&out, '\n');
d653 1
a653 1
      else
d655 1
a655 1
	  idx++;
d657 1
a657 1
    }
d659 3
a661 2
  overwrite_string (tos, &out);
  pc++;
d665 1
a665 1
WORD (courierize)
d667 11
a677 11
  string_type out;
  unsigned int idx = 0;
  int command = 0;

  init_string (&out);

  while (at (tos, idx))
    {
      if (at (tos, idx) == '\n'
	  && (at (tos, idx +1 ) == '.'
	      || at (tos, idx + 1) == '|'))
d679 2
a680 2
	  cattext (&out, "\n@@example\n");
	  do
d682 3
a684 3
	      idx += 2;

	      while (at (tos, idx) && at (tos, idx) != '\n')
d686 1
a686 1
		  if (at (tos, idx) == '{' && at (tos, idx + 1) == '*')
d688 2
a689 2
		      cattext (&out, "/*");
		      idx += 2;
d691 1
a691 1
		  else if (at (tos, idx) == '*' && at (tos, idx + 1) == '}')
d693 2
a694 2
		      cattext (&out, "*/");
		      idx += 2;
d696 1
a696 1
		  else if (at (tos, idx) == '{' && !command)
d698 2
a699 2
		      cattext (&out, "@@{");
		      idx++;
d701 1
a701 1
		  else if (at (tos, idx) == '}' && !command)
d703 2
a704 2
		      cattext (&out, "@@}");
		      idx++;
d706 1
a706 1
		  else
d708 7
a714 7
		      if (at (tos, idx) == '@@')
			command = 1;
		      else if (isspace ((unsigned char) at (tos, idx))
			       || at (tos, idx) == '}')
			command = 0;
		      catchar (&out, at (tos, idx));
		      idx++;
d716 1
a716 1

d718 12
a729 7
	      catchar (&out, '\n');
	    }
	  while (at (tos, idx) == '\n'
		 && ((at (tos, idx + 1) == '.')
		     || (at (tos, idx + 1) == '|')))
	    ;
	  cattext (&out, "@@end example");
d731 4
a734 6
      else
	{
	  catchar (&out, at (tos, idx));
	  idx++;
	}
    }
d736 1
a736 2
  overwrite_string (tos, &out);
  pc++;
d743 2
a744 1
WORD (bulletize)
d746 17
a762 18
  unsigned int idx = 0;
  int on = 0;
  string_type out;
  init_string (&out);

  while (at (tos, idx))
    {
      if (at (tos, idx) == '@@'
	  && at (tos, idx + 1) == '*')
	{
	  cattext (&out, "*");
	  idx += 2;
	}
      else if (at (tos, idx) == '\n'
	       && at (tos, idx + 1) == 'o'
	       && isspace ((unsigned char) at (tos, idx + 2)))
	{
	  if (!on)
d764 8
a771 3
	      cattext (&out, "\n@@itemize @@bullet\n");
	      on = 1;

d773 1
a773 9
	  cattext (&out, "\n@@item\n");
	  idx += 3;
	}
      else
	{
	  catchar (&out, at (tos, idx));
	  if (on && at (tos, idx) == '\n'
	      && at (tos, idx + 1) == '\n'
	      && at (tos, idx + 2) != 'o')
d775 10
a784 2
	      cattext (&out, "@@end itemize");
	      on = 0;
a785 2
	  idx++;

d787 1
a787 2
    }
  if (on)
d789 2
a790 2
      cattext (&out, "@@end itemize\n");
    }
d792 4
a795 3
  delete_string (tos);
  *tos = out;
  pc++;
d799 1
d801 1
a801 1
WORD (do_fancy_stuff)
d803 14
a816 14
  unsigned int idx = 0;
  string_type out;
  init_string (&out);
  while (at (tos, idx))
    {
      if (at (tos, idx) == '<'
	  && at (tos, idx + 1) == '<'
	  && !isspace ((unsigned char) at (tos, idx + 2)))
	{
	  /* This qualifies as a << startup.  */
	  idx += 2;
	  cattext (&out, "@@code{");
	  while (at (tos, idx)
		 && at (tos, idx) != '>' )
d818 3
a820 3
	      catchar (&out, at (tos, idx));
	      idx++;

d822 2
a823 2
	  cattext (&out, "}");
	  idx += 2;
d825 1
a825 1
      else
d827 2
a828 2
	  catchar (&out, at (tos, idx));
	  idx++;
d831 27
a857 3
  delete_string (tos);
  *tos = out;
  pc++;
a860 1
/* A command is all upper case,and alone on a line.  */
d863 4
a866 3
iscommand (ptr, idx)
     string_type *ptr;
     unsigned int idx;
d868 3
a870 2
  unsigned int len = 0;
  while (at (ptr, idx))
d872 19
a890 47
      if (isupper ((unsigned char) at (ptr, idx))
	  || at (ptr, idx) == ' ' || at (ptr, idx) == '_')
	{
	  len++;
	  idx++;
	}
      else if (at (ptr, idx) == '\n')
	{
	  if (len > 3)
	    return 1;
	  return 0;
	}
      else
	return 0;
    }
  return 0;
}

static int
copy_past_newline (ptr, idx, dst)
     string_type *ptr;
     unsigned int idx;
     string_type *dst;
{
  int column = 0;

  while (at (ptr, idx) && at (ptr, idx) != '\n')
    {
      if (at (ptr, idx) == '\t')
	{
	  /* Expand tabs.  Neither makeinfo nor TeX can cope well with
	     them.  */
	  do
	    catchar (dst, ' ');
	  while (++column & 7);
	}
      else
	{
	  catchar (dst, at (ptr, idx));
	  column++;
	}
      idx++;

    }
  catchar (dst, at (ptr, idx));
  idx++;
  return idx;
d894 1
a894 1
WORD (icopy_past_newline)
d896 5
a900 5
  tos++;
  check_range ();
  init_string (tos);
  idx = copy_past_newline (ptr, idx, tos);
  pc++;
d904 2
a905 1
   Take the string at the top of the stack, do some prettying.  */
d907 1
a907 1
WORD (kill_bogus_lines)
d909 10
a918 10
  int sl;

  int idx = 0;
  int c;
  int dot = 0;

  string_type out;
  init_string (&out);
  /* Drop leading nl.  */
  while (at (tos, idx) == '\n')
d920 1
a920 1
      idx++;
d922 6
a927 6
  c = idx;

  /* If the first char is a '.' prepend a newline so that it is
     recognized properly later.  */
  if (at (tos, idx) == '.')
    catchar (&out, '\n');
d929 2
a930 2
  /* Find the last char.  */
  while (at (tos, idx))
d932 1
a932 1
      idx++;
d934 2
a935 5

  /* Find the last non white before the nl.  */
  idx--;

  while (idx && isspace ((unsigned char) at (tos, idx)))
d937 8
a944 5
  idx++;

  /* Copy buffer upto last char, but blank lines before and after
     dots don't count.  */
  sl = 1;
d946 1
a946 1
  while (c < idx)
d948 3
a950 3
      if (at (tos, c) == '\n'
	  && at (tos, c + 1) == '\n'
	  && at (tos, c + 2) == '.')
d952 2
a953 2
	  /* Ignore two newlines before a dot.  */
	  c++;
d955 1
a955 1
      else if (at (tos, c) == '.' && sl)
d957 2
a958 2
	  /* remember that this line started with a dot.  */
	  dot = 2;
d960 3
a962 3
      else if (at (tos, c) == '\n'
	       && at (tos, c + 1) == '\n'
	       && dot)
d964 2
a965 2
	  c++;
	  /* Ignore two newlines when last line was dot.  */
d968 2
a969 2
      catchar (&out, at (tos, c));
      if (at (tos, c) == '\n')
d971 3
a973 6
	  sl = 1;

	  if (dot == 2)
	    dot = 1;
	  else
	    dot = 0;
d975 4
a978 4
      else
	sl = 0;

      c++;
d981 8
a988 7

  /* Append nl.  */
  catchar (&out, '\n');
  pc++;
  delete_string (tos);
  *tos = out;

d991 1
a991 1
WORD (indent)
d993 7
a999 13
  string_type out;
  int tab = 0;
  int idx = 0;
  int ol = 0;
  init_string (&out);
  while (at (tos, idx))
    {
      switch (at (tos, idx))
	{
	case '\n':
	  cattext (&out, "\n");
	  idx++;
	  if (tab && at (tos, idx))
d1001 30
a1030 1
	      cattext (&out, "    ");
d1032 1
a1032 20
	  ol = 0;
	  break;
	case '(':
	  tab++;
	  if (ol == 0)
	    cattext (&out, "   ");
	  idx++;
	  cattext (&out, "(");
	  ol = 1;
	  break;
	case ')':
	  tab--;
	  cattext (&out, ")");
	  idx++;
	  ol = 1;

	  break;
	default:
	  catchar (&out, at (tos, idx));
	  ol = 1;
d1034 3
a1036 4
	  idx++;
	  break;
	}
    }
d1038 1
a1038 3
  pc++;
  delete_string (tos);
  *tos = out;
a1039 1
}
d1041 1
a1041 1
WORD (get_stuff_in_command)
d1043 3
a1045 3
  tos++;
  check_range ();
  init_string (tos);
d1047 5
a1051 7
  while (at (ptr, idx))
    {
      if (iscommand (ptr, idx))
	break;
      idx = copy_past_newline (ptr, idx, tos);
    }
  pc++;
d1054 1
a1054 1
WORD (swap)
d1056 7
a1062 6
  string_type t;

  t = tos[0];
  tos[0] = tos[-1];
  tos[-1] = t;
  pc++;
d1065 1
a1065 1
WORD (other_dup)
d1067 5
a1071 5
  tos++;
  check_range ();
  init_string (tos);
  catstr (tos, tos - 1);
  pc++;
d1074 1
a1074 1
WORD (drop)
d1081 1
a1081 1
WORD (idrop)
d1088 1
a1088 1
WORD (icatstr)
d1090 5
a1094 5
  tos--;
  check_range ();
  catstr (tos, tos + 1);
  delete_string (tos + 1);
  pc++;
d1097 1
a1097 1
WORD (skip_past_newline)
d1099 3
a1101 2
  while (at (ptr, idx)
	 && at (ptr, idx) != '\n')
d1103 1
a1103 2
  idx++;
  pc++;
d1106 2
a1107 1
WORD (internalmode)
d1109 4
a1112 4
  internal_mode = *(isp);
  isp--;
  icheck_range ();
  pc++;
d1115 1
a1115 1
WORD (maybecatstr)
d1117 1
a1117 1
  if (internal_wanted == internal_mode)
d1119 1
a1119 1
      catstr (tos - 1, tos);
d1121 4
a1124 4
  delete_string (tos);
  tos--;
  check_range ();
  pc++;
d1128 42
a1169 14
nextword (string, word)
     char *string;
     char **word;
{
  char *word_start;
  int idx;
  char *dst;
  char *src;

  int length = 0;

  while (isspace ((unsigned char) *string) || *string == '-')
    {
      if (*string == '-')
a1170 1
	  while (*string && *string != '\n')
d1172 2
a1173 5

	}
      else
	{
	  string++;
d1176 6
a1181 2
  if (!*string)
    return 0;
d1183 4
a1186 8
  word_start = string;
  if (*string == '"')
    {
      do
	{
	  string++;
	  length++;
	  if (*string == '\\')
d1188 12
a1199 2
	      string += 2;
	      length += 2;
d1201 2
a1202 2
	}
      while (*string != '"');
d1204 1
a1204 6
  else
    {
      while (!isspace ((unsigned char) *string))
	{
	  string++;
	  length++;
a1205 2
	}
    }
a1206 1
  *word = malloc (length + 1);
a1207 2
  dst = *word;
  src = word_start;
a1208 22
  for (idx = 0; idx < length; idx++)
    {
      if (src[idx] == '\\')
	switch (src[idx + 1])
	  {
	  case 'n':
	    *dst++ = '\n';
	    idx++;
	    break;
	  case '"':
	  case '\\':
	    *dst++ = src[idx + 1];
	    idx++;
	    break;
	  default:
	    *dst++ = '\\';
	    break;
	  }
      else
	*dst++ = src[idx];
    }
  *dst++ = 0;
d1210 5
a1214 4
  if (*string)
    return string + 1;
  else
    return 0;
a1215 1

a1216 1

d1218 2
a1219 2
lookup_word (word)
     char *word;
d1222 2
a1223 4
  while (ptr)
    {
      if (strcmp (ptr->word, word) == 0)
	return ptr;
d1225 1
d1228 1
a1228 1
    fprintf (stderr, "Can't find %s\n", word);
d1230 2
d1234 1
a1234 2
static void
perform (void)
d1237 9
a1246 7
  while (at (ptr, idx))
    {
      /* It's worth looking through the command list.  */
      if (iscommand (ptr, idx))
	{
	  char *next;
	  dict_type *word;
d1248 1
a1248 1
	  (void) nextword (addr (ptr, idx), &next);
a1249 1
	  word = lookup_word (next);
d1251 1
a1251 10
	  if (word)
	    {
	      exec (word);
	    }
	  else
	    {
	      if (warning)
		fprintf (stderr, "warning, %s is not recognised\n", next);
	      skip_past_newline ();
	    }
d1253 9
d1263 4
a1266 2
      else
	skip_past_newline ();
d1271 2
a1272 2
newentry (word)
     char *word;
d1274 9
a1282 8
  dict_type *new = (dict_type *) malloc (sizeof (dict_type));
  new->word = word;
  new->next = root;
  root = new;
  new->code = (stinst_type *) malloc (sizeof (stinst_type));
  new->code_length = 1;
  new->code_end = 0;
  return new;
d1285 1
d1287 20
a1306 12
add_to_definition (entry, word)
     dict_type *entry;
     stinst_type word;
{
  if (entry->code_end == entry->code_length)
    {
      entry->code_length += 2;
      entry->code =
	(stinst_type *) realloc ((char *) (entry->code),
				 entry->code_length * sizeof (word_type));
    }
  entry->code[entry->code_end] = word;
a1307 2
  return entry->code_end++;
}
d1310 7
a1316 7
add_intrinsic (name, func)
     char *name;
     void (*func) ();
{
  dict_type *new = newentry (name);
  add_to_definition (new, func);
  add_to_definition (new, 0);
d1320 2
a1321 2
add_var (name)
     char *name;
d1323 4
a1326 4
  dict_type *new = newentry (name);
  add_to_definition (new, push_number);
  add_to_definition (new, (stinst_type) (&(new->var)));
  add_to_definition (new, 0);
a1328 21
void
compile (string)
     char *string;
{
  /* Add words to the dictionary.  */
  char *word;
  string = nextword (string, &word);
  while (string && *string && word[0])
    {
      if (strcmp (word, "var") == 0)
	{
	  string = nextword (string, &word);

	  add_var (word);
	  string = nextword (string, &word);
	}
      else if (word[0] == ':')
	{
	  dict_type *ptr;
	  /* Compile a word and add to dictionary.  */
	  string = nextword (string, &word);
d1330 27
a1356 3
	  ptr = newentry (word);
	  string = nextword (string, &word);
	  while (word[0] != ';')
d1358 27
a1384 27
	      switch (word[0])
		{
		case '"':
		  /* got a string, embed magic push string
		     function */
		  add_to_definition (ptr, push_text);
		  add_to_definition (ptr, (stinst_type) (word + 1));
		  break;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		  /* Got a number, embedd the magic push number
		     function */
		  add_to_definition (ptr, push_number);
		  add_to_definition (ptr, (stinst_type) atol (word));
		  break;
		default:
		  add_to_definition (ptr, call);
		  add_to_definition (ptr, (stinst_type) lookup_word (word));
		}
d1386 1
a1386 1
	      string = nextword (string, &word);
d1388 2
a1389 2
	  add_to_definition (ptr, 0);
	  string = nextword (string, &word);
d1391 1
a1391 1
      else
d1393 2
a1394 2
	  fprintf (stderr, "syntax error at %s\n", string - 1);
	}
d1396 1
d1399 2
a1400 2
static void
bang (void)
d1402 2
a1403 2
  *(long *) ((isp[0])) = isp[-1];
  isp -= 2;
d1408 1
a1408 1
WORD (atsign)
d1410 2
a1411 2
  isp[0] = *(long *) (isp[0]);
  pc++;
d1414 1
a1414 1
WORD (hello)
d1416 2
a1417 2
  printf ("hello\n");
  pc++;
d1420 1
a1420 1
WORD (stdout_)
d1428 1
a1428 1
WORD (stderr_)
d1436 1
a1436 1
WORD (print)
d1451 8
a1458 8
static void
read_in (str, file)
     string_type *str;
     FILE *file;
{
  char buff[10000];
  unsigned int r;
  do
d1460 2
a1461 2
      r = fread (buff, 1, sizeof (buff), file);
      catbuf (str, buff, r);
d1463 5
a1467 2
  while (r);
  buff[0] = 0;
a1468 2
  catbuf (str, buff, 1);
}
d1470 1
a1470 2
static void
usage (void)
d1472 2
a1473 2
  fprintf (stderr, "usage: -[d|i|g] <file >file\n");
  exit (33);
d1487 3
a1489 4
int
main (ac, av)
     int ac;
     char *av[];
d1495 4
a1498 4
  init_string (&buffer);
  init_string (&pptr);
  init_string (stack + 0);
  tos = stack + 1;
d1500 19
a1518 19

  add_intrinsic ("push_text", push_text);
  add_intrinsic ("!", bang);
  add_intrinsic ("@@", atsign);
  add_intrinsic ("hello", hello);
  add_intrinsic ("stdout", stdout_);
  add_intrinsic ("stderr", stderr_);
  add_intrinsic ("print", print);
  add_intrinsic ("skip_past_newline", skip_past_newline);
  add_intrinsic ("catstr", icatstr);
  add_intrinsic ("copy_past_newline", icopy_past_newline);
  add_intrinsic ("dup", other_dup);
  add_intrinsic ("drop", drop);
  add_intrinsic ("idrop", idrop);
  add_intrinsic ("remchar", remchar);
  add_intrinsic ("get_stuff_in_command", get_stuff_in_command);
  add_intrinsic ("do_fancy_stuff", do_fancy_stuff);
  add_intrinsic ("bulletize", bulletize);
  add_intrinsic ("courierize", courierize);
d1522 48
a1569 50
  add_intrinsic ("exit", chew_exit);
  add_intrinsic ("swap", swap);
  add_intrinsic ("outputdots", outputdots);
  add_intrinsic ("paramstuff", paramstuff);
  add_intrinsic ("maybecatstr", maybecatstr);
  add_intrinsic ("translatecomments", translatecomments);
  add_intrinsic ("kill_bogus_lines", kill_bogus_lines);
  add_intrinsic ("indent", indent);
  add_intrinsic ("internalmode", internalmode);
  add_intrinsic ("print_stack_level", print_stack_level);
  add_intrinsic ("strip_trailing_newlines", strip_trailing_newlines);

  /* Put a nl at the start.  */
  catchar (&buffer, '\n');

  read_in (&buffer, stdin);
  remove_noncomments (&buffer, ptr);
  for (i = 1; i < (unsigned int) ac; i++)
    {
      if (av[i][0] == '-')
	{
	  if (av[i][1] == 'f')
	    {
	      string_type b;
	      FILE *f;
	      init_string (&b);

	      f = fopen (av[i + 1], "r");
	      if (!f)
		{
		  fprintf (stderr, "Can't open the input file %s\n",
			   av[i + 1]);
		  return 33;
		}

	      read_in (&b, f);
	      compile (b.ptr);
	      perform ();
	    }
	  else if (av[i][1] == 'i')
	    {
	      internal_wanted = 1;
	    }
	  else if (av[i][1] == 'w')
	    {
	      warning = 1;
	    }
	  else
	    usage ();
	}
d1571 2
a1572 1
  write_buffer (stack + 0, stdout);
d1575 1
a1575 2
      fprintf (stderr, "finishing with current stack level %d\n",
	       tos - stack);
@


1.1.1.5
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001,
   2002
d84 1
a84 1
#include "ansidecl.h"
d292 2
d365 1
a365 2
static void
call ()
d374 1
a374 2
static void
remchar ()
d391 1
a391 2
static void
push_number ()
d400 1
a400 2
static void
push_text ()
d485 1
a485 1
paramstuff ()
d554 1
a554 2
static void
translatecomments ()
d590 1
a590 2
static void
manglecomments ()
d624 1
a624 1
outputdots ()
d668 1
a668 2
static void
courierize ()
d689 1
a689 22
		  if (command > 1)
		    {
		      /* We are inside {} parameters of some command;
			 Just pass through until matching brace.  */
		      if (at (tos, idx) == '{')
			++command;
		      else if (at (tos, idx) == '}')
			--command;
		    }
		  else if (command != 0)
		    {
		      if (at (tos, idx) == '{')
			++command;
		      else if (!islower ((unsigned char) at (tos, idx)))
			--command;
		    }
		  else if (at (tos, idx) == '@@'
			   && islower ((unsigned char) at (tos, idx + 1)))
		    {
		      ++command;
		    }
		  else if (at (tos, idx) == '{' && at (tos, idx + 1) == '*')
a692 1
		      continue;
a697 1
		      continue;
d699 1
a699 2
		  else if (at (tos, idx) == '{'
			   || at (tos, idx) == '}')
d701 17
a717 1
		      catchar (&out, '@@');
a719 2
		  catchar (&out, at (tos, idx));
		  idx++;
d744 1
a744 2
static void
bulletize ()
d798 1
a798 2
static void
do_fancy_stuff ()
d894 1
a894 2
static void
icopy_past_newline ()
d906 1
a906 2
static void
kill_bogus_lines ()
d992 1
a992 2
static void
indent ()
d1042 1
a1042 2
static void
get_stuff_in_command ()
d1057 1
a1057 2
static void
swap ()
d1067 1
a1067 2
static void
other_dup ()
d1076 1
a1076 2
static void
drop ()
d1083 1
a1083 2
static void
idrop ()
d1090 1
a1090 2
static void
icatstr ()
d1099 1
a1099 2
static void
skip_past_newline ()
d1108 1
a1108 2
static void
internalmode ()
d1116 1
a1116 2
static void
maybecatstr ()
d1234 1
a1234 1
perform ()
d1385 1
a1385 1
bang ()
d1393 1
a1393 2
static void
atsign ()
d1399 1
a1399 2
static void
hello ()
d1405 1
a1405 2
static void
stdout_ ()
d1413 1
a1413 2
static void
stderr_ ()
d1421 1
a1421 2
static void
print ()
d1455 1
a1455 1
usage ()
@


1.1.1.6
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2002, 2003
a496 2
#define NO_PARAMS 1

d498 1
a498 2
  if (NO_PARAMS
      || find (tos, "PARAMS") || find (tos, "PROTO") || !find (tos, "("))
@


