head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.50
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.52
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.48
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.44
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.46
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.38
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.42
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.40
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.11.02.20.45.03;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.17.21.54.20;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.29;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.06;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.43.18;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.27;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.27;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.04.55;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.17.53;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.45.24;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.20.23;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.10;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.22.13;	author miod;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD back-end for AMD 29000 COFF binaries.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1999, 2000, 2001,
   2002, 2003
   Free Software Foundation, Inc.
   Contributed by David Wood at New York University 7/8/91.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#define A29K 1

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "coff/a29k.h"
#include "coff/internal.h"
#include "libcoff.h"

static long get_symbol_value PARAMS ((asymbol *));
static bfd_reloc_status_type a29k_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_boolean coff_a29k_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   struct internal_reloc *, struct internal_syment *, asection **));
static bfd_boolean coff_a29k_adjust_symndx
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *,
	   struct internal_reloc *, bfd_boolean *));
static void reloc_processing
  PARAMS ((arelent *, struct internal_reloc *, asymbol **, bfd *, asection *));

#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (2)

#define INSERT_HWORD(WORD,HWORD)	\
    (((WORD) & 0xff00ff00) | (((HWORD) & 0xff00) << 8) | ((HWORD)& 0xff))
#define EXTRACT_HWORD(WORD) \
    ((((WORD) & 0x00ff0000) >> 8) | ((WORD) & 0xff))
#define SIGN_EXTEND_HWORD(HWORD) \
    (((HWORD) ^ 0x8000) - 0x8000)

/* Provided the symbol, returns the value reffed.  */

static long
get_symbol_value (symbol)
     asymbol *symbol;
{
  long relocation = 0;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value +
      symbol->section->output_section->vma +
      symbol->section->output_offset;

  return relocation;
}

/* This function is in charge of performing all the 29k relocations.  */

static bfd_reloc_status_type
a29k_reloc (abfd, reloc_entry, symbol_in, data, input_section, output_bfd,
	    error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol_in;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  /* The consth relocation comes in two parts, we have to remember
     the state between calls, in these variables.  */
  static bfd_boolean part1_consth_active = FALSE;
  static unsigned long part1_consth_value;
  unsigned long insn;
  unsigned long sym_value;
  unsigned long unsigned_value;
  unsigned short r_type;
  long signed_value;
  unsigned long addr = reloc_entry->address ; /*+ input_section->vma*/
  bfd_byte  *hit_data =addr + (bfd_byte *) (data);

  r_type = reloc_entry->howto->type;

  if (output_bfd)
    {
      /* Partial linking - do nothing.  */
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (symbol_in != NULL
      && bfd_is_und_section (symbol_in->section))
    {
      /* Keep the state machine happy in case we're called again.  */
      if (r_type == R_IHIHALF)
	{
	  part1_consth_active = TRUE;
	  part1_consth_value  = 0;
	}
      return bfd_reloc_undefined;
    }

  if ((part1_consth_active) && (r_type != R_IHCONST))
    {
      part1_consth_active = FALSE;
      *error_message = (char *) _("Missing IHCONST");

      return bfd_reloc_dangerous;
    }

  sym_value = get_symbol_value(symbol_in);

  switch (r_type)
    {
    case R_IREL:
      insn = bfd_get_32 (abfd, hit_data);
      /* Take the value in the field and sign extend it.  */
      signed_value = EXTRACT_HWORD(insn);
      signed_value = SIGN_EXTEND_HWORD(signed_value);
      signed_value <<= 2;

      /* See the note on the R_IREL reloc in coff_a29k_relocate_section.  */
      if (signed_value == - (long) reloc_entry->address)
	signed_value = 0;

      signed_value += sym_value + reloc_entry->addend;
      if ((signed_value & ~0x3ffff) == 0)
	{				/* Absolute jmp/call */
	  insn |= (1 << 24);		/* Make it absolute */
	  /* FIXME: Should we change r_type to R_IABS.  */
	}
      else
	{
	  /* Relative jmp/call, so subtract from the value the
	     address of the place we're coming from.  */
	  signed_value -= (reloc_entry->address
			   + input_section->output_section->vma
			   + input_section->output_offset);
	  if (signed_value > 0x1ffff || signed_value < -0x20000)
	    return bfd_reloc_overflow;
	}
      signed_value >>= 2;
      insn = INSERT_HWORD (insn, signed_value);
      bfd_put_32 (abfd, (bfd_vma) insn ,hit_data);
      break;
    case R_ILOHALF:
      insn = bfd_get_32 (abfd, hit_data);
      unsigned_value = EXTRACT_HWORD(insn);
      unsigned_value +=  sym_value + reloc_entry->addend;
      insn = INSERT_HWORD(insn, unsigned_value);
      bfd_put_32 (abfd, (bfd_vma) insn, hit_data);
      break;
    case R_IHIHALF:
      insn = bfd_get_32 (abfd, hit_data);
      /* consth, part 1
	 Just get the symbol value that is referenced.  */
      part1_consth_active = TRUE;
      part1_consth_value = sym_value + reloc_entry->addend;
      /* Don't modify insn until R_IHCONST.  */
      break;
    case R_IHCONST:
      insn = bfd_get_32 (abfd, hit_data);
      /* consth, part 2
	 Now relocate the reference.  */
      if (! part1_consth_active)
	{
	  *error_message = (char *) _("Missing IHIHALF");
	  return bfd_reloc_dangerous;
	}
      /* sym_ptr_ptr = r_symndx, in coff_slurp_reloc_table() */
      unsigned_value = 0;		/*EXTRACT_HWORD(insn) << 16;*/
      unsigned_value += reloc_entry->addend; /* r_symndx */
      unsigned_value += part1_consth_value;
      unsigned_value = unsigned_value >> 16;
      insn = INSERT_HWORD(insn, unsigned_value);
      part1_consth_active = FALSE;
      bfd_put_32 (abfd, (bfd_vma) insn, hit_data);
      break;
    case R_BYTE:
      insn = bfd_get_8 (abfd, hit_data);
      unsigned_value = insn + sym_value + reloc_entry->addend;
      if (unsigned_value & 0xffffff00)
	return bfd_reloc_overflow;
      bfd_put_8 (abfd, unsigned_value, hit_data);
      break;
    case R_HWORD:
      insn = bfd_get_16 (abfd, hit_data);
      unsigned_value = insn + sym_value + reloc_entry->addend;
      if (unsigned_value & 0xffff0000)
	return bfd_reloc_overflow;
      bfd_put_16 (abfd, (bfd_vma) insn, hit_data);
      break;
    case R_WORD:
      insn = bfd_get_32 (abfd, hit_data);
      insn += sym_value + reloc_entry->addend;
      bfd_put_32 (abfd, (bfd_vma) insn, hit_data);
      break;
    default:
      *error_message = _("Unrecognized reloc");
      return bfd_reloc_dangerous;
    }

  return(bfd_reloc_ok);
}

/*FIXME: I'm not real sure about this table.  */
static reloc_howto_type howto_table[] =
  {
    {R_ABS,     0, 3, 32, FALSE, 0, complain_overflow_bitfield,a29k_reloc,"ABS",     TRUE, 0xffffffff,0xffffffff, FALSE},
    EMPTY_HOWTO (1),
    EMPTY_HOWTO (2),
    EMPTY_HOWTO (3),
    EMPTY_HOWTO (4),
    EMPTY_HOWTO (5),
    EMPTY_HOWTO (6),
    EMPTY_HOWTO (7),
    EMPTY_HOWTO (8),
    EMPTY_HOWTO (9),
    EMPTY_HOWTO (10),
    EMPTY_HOWTO (11),
    EMPTY_HOWTO (12),
    EMPTY_HOWTO (13),
    EMPTY_HOWTO (14),
    EMPTY_HOWTO (15),
    EMPTY_HOWTO (16),
    EMPTY_HOWTO (17),
    EMPTY_HOWTO (18),
    EMPTY_HOWTO (19),
    EMPTY_HOWTO (20),
    EMPTY_HOWTO (21),
    EMPTY_HOWTO (22),
    EMPTY_HOWTO (23),
    {R_IREL,    0, 3, 32, TRUE,  0, complain_overflow_signed,a29k_reloc,"IREL",    TRUE, 0xffffffff,0xffffffff, FALSE},
    {R_IABS,    0, 3, 32, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"IABS",    TRUE, 0xffffffff,0xffffffff, FALSE},
    {R_ILOHALF, 0, 3, 16, TRUE,  0, complain_overflow_signed, a29k_reloc,"ILOHALF", TRUE, 0x0000ffff,0x0000ffff, FALSE},
    {R_IHIHALF, 0, 3, 16, TRUE,  16, complain_overflow_signed, a29k_reloc,"IHIHALF", TRUE, 0xffff0000,0xffff0000, FALSE},
    {R_IHCONST, 0, 3, 16, TRUE,  0, complain_overflow_signed, a29k_reloc,"IHCONST", TRUE, 0xffff0000,0xffff0000, FALSE},
    {R_BYTE,    0, 0, 8, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"BYTE",    TRUE, 0x000000ff,0x000000ff, FALSE},
    {R_HWORD,   0, 1, 16, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"HWORD",   TRUE, 0x0000ffff,0x0000ffff, FALSE},
    {R_WORD,    0, 2, 32, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"WORD",    TRUE, 0xffffffff,0xffffffff, FALSE},
  };

#define BADMAG(x) A29KBADMAG(x)

#define RELOC_PROCESSING(relent, reloc, symbols, abfd, section) \
 reloc_processing(relent, reloc, symbols, abfd, section)

static void
reloc_processing (relent,reloc, symbols, abfd, section)
     arelent *relent;
     struct internal_reloc *reloc;
     asymbol **symbols;
     bfd *abfd;
     asection *section;
{
  static bfd_vma ihihalf_vaddr = (bfd_vma) -1;

  relent->address = reloc->r_vaddr;
  relent->howto = howto_table + reloc->r_type;
  if (reloc->r_type == R_IHCONST)
    {
      /* The address of an R_IHCONST should always be the address of
	 the immediately preceding R_IHIHALF.  relocs generated by gas
	 are correct, but relocs generated by High C are different (I
	 can't figure out what the address means for High C).  We can
	 handle both gas and High C by ignoring the address here, and
	 simply reusing the address saved for R_IHIHALF.  */
      if (ihihalf_vaddr == (bfd_vma) -1)
	abort ();
      relent->address = ihihalf_vaddr;
      ihihalf_vaddr = (bfd_vma) -1;
      relent->addend = reloc->r_symndx;
      relent->sym_ptr_ptr= bfd_abs_section_ptr->symbol_ptr_ptr;
    }
  else
    {
      asymbol *ptr;

      relent->sym_ptr_ptr = symbols + obj_convert (abfd)[reloc->r_symndx];

      ptr = *(relent->sym_ptr_ptr);

      if (ptr
	  && bfd_asymbol_bfd(ptr) == abfd
	  && ((ptr->flags & BSF_OLD_COMMON) == 0))
	relent->addend = 0;
      else
	relent->addend = 0;

      relent->address-= section->vma;
      if (reloc->r_type == R_IHIHALF)
	ihihalf_vaddr = relent->address;
      else if (ihihalf_vaddr != (bfd_vma) -1)
	abort ();
    }
}

/* The reloc processing routine for the optimized COFF linker.  */

static bfd_boolean
coff_a29k_relocate_section (output_bfd, info, input_bfd, input_section,
			    contents, relocs, syms, sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     struct internal_reloc *relocs;
     struct internal_syment *syms;
     asection **sections;
{
  struct internal_reloc *rel;
  struct internal_reloc *relend;
  bfd_boolean hihalf;
  bfd_vma hihalf_val;

  /* If we are performing a relocatable link, we don't need to do a
     thing.  The caller will take care of adjusting the reloc
     addresses and symbol indices.  */
  if (info->relocatable)
    return TRUE;

  hihalf = FALSE;
  hihalf_val = 0;

  rel = relocs;
  relend = rel + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      long symndx;
      bfd_byte *loc;
      struct coff_link_hash_entry *h;
      struct internal_syment *sym;
      asection *sec;
      bfd_vma val;
      bfd_boolean overflow;
      unsigned long insn;
      long signed_value;
      unsigned long unsigned_value;
      bfd_reloc_status_type rstat;

      symndx = rel->r_symndx;
      loc = contents + rel->r_vaddr - input_section->vma;

      if (symndx == -1 || rel->r_type == R_IHCONST)
	h = NULL;
      else
	h = obj_coff_sym_hashes (input_bfd)[symndx];

      sym = NULL;
      sec = NULL;
      val = 0;

      /* An R_IHCONST reloc does not have a symbol.  Instead, the
         symbol index is an addend.  R_IHCONST is always used in
         conjunction with R_IHHALF.  */
      if (rel->r_type != R_IHCONST)
	{
	  if (h == NULL)
	    {
	      if (symndx == -1)
		sec = bfd_abs_section_ptr;
	      else
		{
		  sym = syms + symndx;
		  sec = sections[symndx];
		  val = (sec->output_section->vma
			 + sec->output_offset
			 + sym->n_value
			 - sec->vma);
		}
	    }
	  else
	    {
	      if (   h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak)
		{
		  sec = h->root.u.def.section;
		  val = (h->root.u.def.value
			 + sec->output_section->vma
			 + sec->output_offset);
		}
	      else
		{
		  if (! ((*info->callbacks->undefined_symbol)
			 (info, h->root.root.string, input_bfd, input_section,
			  rel->r_vaddr - input_section->vma, TRUE)))
		    return FALSE;
		}
	    }

	  if (hihalf)
	    {
	      if (! ((*info->callbacks->reloc_dangerous)
		     (info, _("missing IHCONST reloc"), input_bfd,
		      input_section, rel->r_vaddr - input_section->vma)))
		return FALSE;
	      hihalf = FALSE;
	    }
	}

      overflow = FALSE;

      switch (rel->r_type)
	{
	default:
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;

	case R_IREL:
	  insn = bfd_get_32 (input_bfd, loc);

	  /* Extract the addend.  */
	  signed_value = EXTRACT_HWORD (insn);
	  signed_value = SIGN_EXTEND_HWORD (signed_value);
	  signed_value <<= 2;

	  /* Unfortunately, there are two different versions of COFF
	     a29k.  In the original AMD version, the value stored in
	     the field for the R_IREL reloc is a simple addend.  In
	     the GNU version, the value is the negative of the address
	     of the reloc within section.  We try to cope here by
	     assuming the AMD version, unless the addend is exactly
	     the negative of the address; in the latter case we assume
	     the GNU version.  This means that something like
	         .text
		 nop
		 jmp i-4
	     will fail, because the addend of -4 will happen to equal
	     the negative of the address within the section.  The
	     compiler will never generate code like this.

	     At some point in the future we may want to take out this
	     check.  */

	  if (signed_value == - (long) (rel->r_vaddr - input_section->vma))
	    signed_value = 0;

	  /* Determine the destination of the jump.  */
	  signed_value += val;

	  if ((signed_value & ~0x3ffff) == 0)
	    {
	      /* We can use an absolute jump.  */
	      insn |= (1 << 24);
	    }
	  else
	    {
	      /* Make the destination PC relative.  */
	      signed_value -= (input_section->output_section->vma
			       + input_section->output_offset
			       + (rel->r_vaddr - input_section->vma));
	      if (signed_value > 0x1ffff || signed_value < - 0x20000)
		{
		  overflow = TRUE;
		  signed_value = 0;
		}
	    }

	  /* Put the adjusted value back into the instruction.  */
	  signed_value >>= 2;
	  insn = INSERT_HWORD (insn, signed_value);

	  bfd_put_32 (input_bfd, (bfd_vma) insn, loc);
	  break;

	case R_ILOHALF:
	  insn = bfd_get_32 (input_bfd, loc);
	  unsigned_value = EXTRACT_HWORD (insn);
	  unsigned_value += val;
	  insn = INSERT_HWORD (insn, unsigned_value);
	  bfd_put_32 (input_bfd, (bfd_vma) insn, loc);
	  break;

	case R_IHIHALF:
	  /* Save the value for the R_IHCONST reloc.  */
	  hihalf = TRUE;
	  hihalf_val = val;
	  break;

	case R_IHCONST:
	  if (! hihalf)
	    {
	      if (! ((*info->callbacks->reloc_dangerous)
		     (info, _("missing IHIHALF reloc"), input_bfd,
		      input_section, rel->r_vaddr - input_section->vma)))
		return FALSE;
	      hihalf_val = 0;
	    }

	  insn = bfd_get_32 (input_bfd, loc);
	  unsigned_value = rel->r_symndx + hihalf_val;
	  unsigned_value >>= 16;
	  insn = INSERT_HWORD (insn, unsigned_value);
	  bfd_put_32 (input_bfd, (bfd_vma) insn, loc);

	  hihalf = FALSE;

	  break;

	case R_BYTE:
	case R_HWORD:
	case R_WORD:
	  rstat = _bfd_relocate_contents (howto_table + rel->r_type,
					  input_bfd, val, loc);
	  if (rstat == bfd_reloc_overflow)
	    overflow = TRUE;
	  else if (rstat != bfd_reloc_ok)
	    abort ();
	  break;
	}

      if (overflow)
	{
	  const char *name;
	  char buf[SYMNMLEN + 1];

	  if (symndx == -1)
	    name = "*ABS*";
	  else if (h != NULL)
	    name = h->root.root.string;
	  else if (sym == NULL)
	    name = "*unknown*";
	  else if (sym->_n._n_n._n_zeroes == 0
		   && sym->_n._n_n._n_offset != 0)
	    name = obj_coff_strings (input_bfd) + sym->_n._n_n._n_offset;
	  else
	    {
	      strncpy (buf, sym->_n._n_name, SYMNMLEN);
	      buf[SYMNMLEN] = '\0';
	      name = buf;
	    }

	  if (! ((*info->callbacks->reloc_overflow)
		 (info, name, howto_table[rel->r_type].name, (bfd_vma) 0,
		  input_bfd, input_section,
		  rel->r_vaddr - input_section->vma)))
	    return FALSE;
	}
    }

  return TRUE;
}

#define coff_relocate_section coff_a29k_relocate_section

/* We don't want to change the symndx of a R_IHCONST reloc, since it
   is actually an addend, not a symbol index at all.  */

static bfd_boolean
coff_a29k_adjust_symndx (obfd, info, ibfd, sec, irel, adjustedp)
     bfd *obfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     bfd *ibfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     struct internal_reloc *irel;
     bfd_boolean *adjustedp;
{
  if (irel->r_type == R_IHCONST)
    *adjustedp = TRUE;
  else
    *adjustedp = FALSE;
  return TRUE;
}

#define coff_adjust_symndx coff_a29k_adjust_symndx

#include "coffcode.h"

CREATE_BIG_COFF_TARGET_VEC (a29kcoff_big_vec, "coff-a29k-big", 0, SEC_READONLY, '_', NULL, COFF_SWAP_TABLE)
@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1999, 2000, 2001, 2002
d331 1
a331 1
  /* If we are performing a relocateable link, we don't need to do a
d334 1
a334 1
  if (info->relocateable)
d584 1
a584 1
CREATE_BIG_COFF_TARGET_VEC (a29kcoff_big_vec, "coff-a29k-big", 0, SEC_READONLY, '_', NULL)
@


1.4
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1999, 2000, 2001
d34 1
a34 1
static boolean coff_a29k_relocate_section
d37 1
a37 1
static boolean coff_a29k_adjust_symndx
d39 3
a41 1
	   struct internal_reloc *, boolean *));
d52 2
a53 1
/* Provided the symbol, returns the value reffed */
d61 1
a61 3
    {
      relocation = 0;
    }
d63 3
a65 5
    {
      relocation = symbol->value +
	symbol->section->output_section->vma +
	symbol->section->output_offset;
    }
d67 1
a67 1
  return(relocation);
d70 1
a70 1
/* this function is in charge of performing all the 29k relocations */
d83 3
a85 3
  /* the consth relocation comes in two parts, we have to remember
     the state between calls, in these variables */
  static boolean part1_consth_active = false;
a86 1

a91 1

d99 1
a99 1
      /* Partial linking - do nothing */
a101 1

d107 1
a107 1
      /* Keep the state machine happy in case we're called again */
d110 1
a110 1
	  part1_consth_active = true;
d113 1
a113 1
      return(bfd_reloc_undefined);
d118 1
a118 1
      part1_consth_active = false;
d120 2
a121 1
      return(bfd_reloc_dangerous);
d130 1
a130 1
      /* Take the value in the field and sign extend it */
d142 2
a143 2
	  insn |= (1<<24);		/* Make it absolute */
	  /* FIXME: Should we change r_type to R_IABS */
d148 1
a148 1
	     address of the place we're coming from */
d152 2
a153 2
	  if (signed_value>0x1ffff || signed_value<-0x20000)
	    return(bfd_reloc_overflow);
d156 2
a157 2
      insn = INSERT_HWORD(insn, signed_value);
      bfd_put_32 (abfd, insn ,hit_data);
d164 1
a164 1
      bfd_put_32 (abfd, insn, hit_data);
d169 2
a170 2
	 Just get the symbol value that is referenced */
      part1_consth_active = true;
d172 1
a172 1
      /* Don't modify insn until R_IHCONST */
d177 2
a178 2
	 Now relocate the reference */
      if (part1_consth_active == false)
d181 1
a181 1
	  return(bfd_reloc_dangerous);
d189 2
a190 2
      part1_consth_active = false;
      bfd_put_32 (abfd, insn, hit_data);
d196 1
a196 1
	return(bfd_reloc_overflow);
d203 2
a204 2
	return(bfd_reloc_overflow);
      bfd_put_16 (abfd, insn, hit_data);
d209 1
a209 1
      bfd_put_32 (abfd, insn, hit_data);
d213 1
a213 1
      return (bfd_reloc_dangerous);
d219 1
a219 14
/*      type	   rightshift
		       size
			  bitsize
			       pc-relative
				     bitpos
					 absolute
					     complain_on_overflow
						  special_function
						    relocation name
							       partial_inplace
								      src_mask
*/

/*FIXME: I'm not real sure about this table */
d221 34
a254 34
{
  {R_ABS,     0, 3, 32, false, 0, complain_overflow_bitfield,a29k_reloc,"ABS",     true, 0xffffffff,0xffffffff, false},
  EMPTY_HOWTO (1),
  EMPTY_HOWTO (2),
  EMPTY_HOWTO (3),
  EMPTY_HOWTO (4),
  EMPTY_HOWTO (5),
  EMPTY_HOWTO (6),
  EMPTY_HOWTO (7),
  EMPTY_HOWTO (8),
  EMPTY_HOWTO (9),
  EMPTY_HOWTO (10),
  EMPTY_HOWTO (11),
  EMPTY_HOWTO (12),
  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),
  EMPTY_HOWTO (16),
  EMPTY_HOWTO (17),
  EMPTY_HOWTO (18),
  EMPTY_HOWTO (19),
  EMPTY_HOWTO (20),
  EMPTY_HOWTO (21),
  EMPTY_HOWTO (22),
  EMPTY_HOWTO (23),
  {R_IREL,    0, 3, 32, true,  0, complain_overflow_signed,a29k_reloc,"IREL",    true, 0xffffffff,0xffffffff, false},
  {R_IABS,    0, 3, 32, false, 0, complain_overflow_bitfield, a29k_reloc,"IABS",    true, 0xffffffff,0xffffffff, false},
  {R_ILOHALF, 0, 3, 16, true,  0, complain_overflow_signed, a29k_reloc,"ILOHALF", true, 0x0000ffff,0x0000ffff, false},
  {R_IHIHALF, 0, 3, 16, true,  16, complain_overflow_signed, a29k_reloc,"IHIHALF", true, 0xffff0000,0xffff0000, false},
  {R_IHCONST, 0, 3, 16, true,  0, complain_overflow_signed, a29k_reloc,"IHCONST", true, 0xffff0000,0xffff0000, false},
  {R_BYTE,    0, 0, 8, false, 0, complain_overflow_bitfield, a29k_reloc,"BYTE",    true, 0x000000ff,0x000000ff, false},
  {R_HWORD,   0, 1, 16, false, 0, complain_overflow_bitfield, a29k_reloc,"HWORD",   true, 0x0000ffff,0x0000ffff, false},
  {R_WORD,    0, 2, 32, false, 0, complain_overflow_bitfield, a29k_reloc,"WORD",    true, 0xffffffff,0xffffffff, false},
};
d291 2
a292 1
      relent->sym_ptr_ptr = symbols + obj_convert(abfd)[reloc->r_symndx];
d298 4
a302 8
	  && ((ptr->flags & BSF_OLD_COMMON)== 0))
	{
	  relent->addend = 0;
	}
      else
	{
	  relent->addend = 0;
	}
d313 1
a313 1
static boolean
d327 1
a327 1
  boolean hihalf;
d334 1
a334 1
    return true;
d336 1
a336 1
  hihalf = false;
d349 1
a349 1
      boolean overflow;
d388 1
a388 1
	      if (h->root.type == bfd_link_hash_defined
d400 2
a401 2
			  rel->r_vaddr - input_section->vma, true)))
		    return false;
d410 2
a411 2
		return false;
	      hihalf = false;
d415 1
a415 1
      overflow = false;
d421 1
a421 1
	  return false;
d468 1
a468 1
		  overflow = true;
a477 1

d485 1
a485 1
	  bfd_put_32 (input_bfd, insn, loc);
d490 1
a490 1
	  hihalf = true;
d500 1
a500 1
		return false;
d510 1
a510 1
	  hihalf = false;
d520 1
a520 1
	    overflow = true;
d551 1
a551 1
	    return false;
d555 1
a555 1
  return true;
d563 1
a563 1
static boolean
d570 1
a570 1
     boolean *adjustedp;
d573 1
a573 1
    *adjustedp = true;
d575 2
a576 2
    *adjustedp = false;
  return true;
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 97, 98, 1999
d46 1
a46 1
    ((((WORD) & 0x00ff0000) >> 8) | ((WORD)& 0xff))
d48 1
a48 1
    ((HWORD) & 0x8000 ? (HWORD)|(~0xffffL) : (HWORD))
d52 1
a52 1
get_symbol_value (symbol)       
d54 1
a54 1
{                                             
d58 9
a66 9
  {
    relocation = 0;                           
  }
  else 
  {                                      
    relocation = symbol->value +
     symbol->section->output_section->vma +
      symbol->section->output_offset;
  }                                           
d96 2
a97 2
  bfd_byte  *hit_data =addr + (bfd_byte *)(data);
	
d100 5
a104 4
  if (output_bfd) {
    /* Partial linking - do nothing */
    reloc_entry->address += input_section->output_offset;
    return bfd_reloc_ok;
d106 1
a106 1
  }
a109 3
  {
    /* Keep the state machine happy in case we're called again */
    if (r_type == R_IHIHALF) 
d111 7
a117 2
      part1_consth_active = true;
      part1_consth_value  = 0;
a118 9
    return(bfd_reloc_undefined);
  }

  if ((part1_consth_active) && (r_type != R_IHCONST)) 
  {
    part1_consth_active = false;
    *error_message = (char *) _("Missing IHCONST");
    return(bfd_reloc_dangerous);
  }
d120 6
d129 1
a129 20
  switch (r_type) 
  {
   case R_IREL: 	
    insn = bfd_get_32(abfd, hit_data); 
    /* Take the value in the field and sign extend it */
    signed_value = EXTRACT_HWORD(insn);
    signed_value = SIGN_EXTEND_HWORD(signed_value);
    signed_value <<= 2;

    /* See the note on the R_IREL reloc in coff_a29k_relocate_section.  */
    if (signed_value == - (long) reloc_entry->address)
      signed_value = 0;

    signed_value += sym_value + reloc_entry->addend;
    if ((signed_value & ~0x3ffff) == 0)
    {				/* Absolute jmp/call */
      insn |= (1<<24);		/* Make it absolute */
      /* FIXME: Should we change r_type to R_IABS */
    } 
    else 
d131 86
a216 7
      /* Relative jmp/call, so subtract from the value the
	 address of the place we're coming from */
      signed_value -= (reloc_entry->address
		       + input_section->output_section->vma
		       + input_section->output_offset);
      if (signed_value>0x1ffff || signed_value<-0x20000) 
       return(bfd_reloc_overflow);
a217 59
    signed_value >>= 2;
    insn = INSERT_HWORD(insn, signed_value);
    bfd_put_32(abfd, insn ,hit_data); 
    break;
   case R_ILOHALF: 
    insn = bfd_get_32(abfd, hit_data); 
    unsigned_value = EXTRACT_HWORD(insn);
    unsigned_value +=  sym_value + reloc_entry->addend;
    insn = INSERT_HWORD(insn, unsigned_value);
    bfd_put_32(abfd, insn, hit_data); 
    break;
   case R_IHIHALF:
    insn = bfd_get_32(abfd, hit_data); 
    /* consth, part 1 
       Just get the symbol value that is referenced */
    part1_consth_active = true;
    part1_consth_value = sym_value + reloc_entry->addend;
    /* Don't modify insn until R_IHCONST */
    break;
   case R_IHCONST:	
    insn = bfd_get_32(abfd, hit_data); 
    /* consth, part 2 
       Now relocate the reference */
    if (part1_consth_active == false) {
      *error_message = (char *) _("Missing IHIHALF");
      return(bfd_reloc_dangerous);
    }
    /* sym_ptr_ptr = r_symndx, in coff_slurp_reloc_table() */
    unsigned_value = 0;		/*EXTRACT_HWORD(insn) << 16;*/
    unsigned_value += reloc_entry->addend; /* r_symndx */
    unsigned_value += part1_consth_value;
    unsigned_value = unsigned_value >> 16;
    insn = INSERT_HWORD(insn, unsigned_value);
    part1_consth_active = false;
    bfd_put_32(abfd, insn, hit_data); 
    break;
   case R_BYTE:
    insn = bfd_get_8(abfd, hit_data); 
    unsigned_value = insn + sym_value + reloc_entry->addend;	
    if (unsigned_value & 0xffffff00)
      return(bfd_reloc_overflow);
    bfd_put_8(abfd, unsigned_value, hit_data); 
    break;
   case R_HWORD:
    insn = bfd_get_16(abfd, hit_data); 
    unsigned_value = insn + sym_value + reloc_entry->addend;	
    if (unsigned_value & 0xffff0000)
      return(bfd_reloc_overflow);
    bfd_put_16(abfd, insn, hit_data); 
    break;
   case R_WORD:
    insn = bfd_get_32(abfd, hit_data); 
    insn += sym_value + reloc_entry->addend;  
    bfd_put_32(abfd, insn, hit_data);
    break;
   default:
    *error_message = _("Unrecognized reloc");
    return (bfd_reloc_dangerous);
  }
d219 1
a219 2

  return(bfd_reloc_ok);	
d231 1
a231 1
							       partial_inplace 
d236 1
a236 1
static reloc_howto_type howto_table[] = 
d285 1
a285 1
    static bfd_vma ihihalf_vaddr = (bfd_vma) -1;
d287 4
a290 4
    relent->address = reloc->r_vaddr;		
    relent->howto = howto_table + reloc->r_type;
    if (reloc->r_type == R_IHCONST) 
    {		
d297 6
a302 6
        if (ihihalf_vaddr == (bfd_vma) -1)
	  abort ();
	relent->address = ihihalf_vaddr;
	ihihalf_vaddr = (bfd_vma) -1;
	relent->addend = reloc->r_symndx;		
	relent->sym_ptr_ptr= bfd_abs_section_ptr->symbol_ptr_ptr;
d304 1
a304 1
    else 
d311 2
a312 2
      if (ptr 
	  && bfd_asymbol_bfd(ptr) == abfd		
d314 2
a315 2
	  && ((ptr->flags & BSF_OLD_COMMON)== 0))	
      {						
d317 1
a317 1
      }						
d319 3
a321 3
      {					
	  relent->addend = 0;			
      }			
d327 1
a327 1
  }
d573 1
a573 1
    }     
a582 1
/*ARGSUSED*/
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.
a26 1
#include "obstack.h"
d122 1
a122 1
    *error_message = (char *) "Missing IHCONST";
d182 1
a182 1
      *error_message = (char *) "Missing IHIHALF";
d214 1
a214 1
    *error_message = "Unrecognized reloc";
d239 23
a261 3
  {1},  {2},  {3},   {4},  {5},  {6},  {7},  {8},  {9}, {10},
  {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20},
  {21}, {22}, {23},
d335 1
a335 1
     bfd *output_bfd;
d377 1
a377 1
      if (symndx == -1)
d419 1
a419 1
			  rel->r_vaddr - input_section->vma)))
d427 1
a427 1
		     (info, "missing IHCONST reloc", input_bfd,
d518 1
a518 1
		     (info, "missing IHIHALF reloc", input_bfd,
d586 4
a589 4
     bfd *obfd;
     struct bfd_link_info *info;
     bfd *ibfd;
     asection *sec;
d604 1
a604 58
const bfd_target a29kcoff_big_vec =
{
  "coff-a29k-big",		/* name */
  bfd_target_coff_flavour,
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT),

  (SEC_HAS_CONTENTS | SEC_ALLOC /* section flags */
   | SEC_LOAD | SEC_RELOC  
   | SEC_READONLY ),
  '_',				/* leading underscore */
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  /* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32,   bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16,
  /* hdrs */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32,   bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16,

 {
	    
   _bfd_dummy_target,
   coff_object_p,
   bfd_generic_archive_p,
   _bfd_dummy_target
  },
 {
   bfd_false,
   coff_mkobject,
   _bfd_generic_mkarchive,
   bfd_false
  },
 {
   bfd_false,
   coff_write_object_contents,
   _bfd_write_archive_contents,
   bfd_false
  },

     BFD_JUMP_TABLE_GENERIC (coff),
     BFD_JUMP_TABLE_COPY (coff),
     BFD_JUMP_TABLE_CORE (_bfd_nocore),
     BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
     BFD_JUMP_TABLE_SYMBOLS (coff),
     BFD_JUMP_TABLE_RELOCS (coff),
     BFD_JUMP_TABLE_WRITE (coff),
     BFD_JUMP_TABLE_LINK (coff),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  COFF_SWAP_TABLE
 };
@


1.1
log
@Initial revision
@
text
@d588 2
a589 2
  true,				/* data byte order is big */
  true,				/* header byte order is big */
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d588 2
a589 2
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */
@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 1997 Free Software Foundation, Inc.
d26 1
d357 1
a357 1
      if (symndx == -1 || rel->r_type == R_IHCONST)
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 97, 98, 1999
   Free Software Foundation, Inc.
d121 1
a121 1
    *error_message = (char *) _("Missing IHCONST");
d181 1
a181 1
      *error_message = (char *) _("Missing IHIHALF");
d213 1
a213 1
    *error_message = _("Unrecognized reloc");
d238 3
a240 23
  EMPTY_HOWTO (1),
  EMPTY_HOWTO (2),
  EMPTY_HOWTO (3),
  EMPTY_HOWTO (4),
  EMPTY_HOWTO (5),
  EMPTY_HOWTO (6),
  EMPTY_HOWTO (7),
  EMPTY_HOWTO (8),
  EMPTY_HOWTO (9),
  EMPTY_HOWTO (10),
  EMPTY_HOWTO (11),
  EMPTY_HOWTO (12),
  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),
  EMPTY_HOWTO (16),
  EMPTY_HOWTO (17),
  EMPTY_HOWTO (18),
  EMPTY_HOWTO (19),
  EMPTY_HOWTO (20),
  EMPTY_HOWTO (21),
  EMPTY_HOWTO (22),
  EMPTY_HOWTO (23),
d314 1
a314 1
     bfd *output_bfd ATTRIBUTE_UNUSED;
d398 1
a398 1
			  rel->r_vaddr - input_section->vma, true)))
d406 1
a406 1
		     (info, _("missing IHCONST reloc"), input_bfd,
d497 1
a497 1
		     (info, _("missing IHIHALF reloc"), input_bfd,
d565 4
a568 4
     bfd *obfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     bfd *ibfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
d583 58
a640 1
CREATE_BIG_COFF_TARGET_VEC (a29kcoff_big_vec, "coff-a29k-big", 0, SEC_READONLY, '_', NULL)
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1999, 2000, 2001
d46 1
a46 1
    ((((WORD) & 0x00ff0000) >> 8) | ((WORD) & 0xff))
d48 1
a48 1
    (((HWORD) ^ 0x8000) - 0x8000)
d52 1
a52 1
get_symbol_value (symbol)
d54 1
a54 1
{
d58 9
a66 9
    {
      relocation = 0;
    }
  else
    {
      relocation = symbol->value +
	symbol->section->output_section->vma +
	symbol->section->output_offset;
    }
d96 2
a97 2
  bfd_byte  *hit_data =addr + (bfd_byte *) (data);

d100 4
a103 5
  if (output_bfd)
    {
      /* Partial linking - do nothing */
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
d105 1
a105 1
    }
d109 3
d113 2
a114 7
      /* Keep the state machine happy in case we're called again */
      if (r_type == R_IHIHALF)
	{
	  part1_consth_active = true;
	  part1_consth_value  = 0;
	}
      return(bfd_reloc_undefined);
d116 9
a125 6
  if ((part1_consth_active) && (r_type != R_IHCONST))
    {
      part1_consth_active = false;
      *error_message = (char *) _("Missing IHCONST");
      return(bfd_reloc_dangerous);
    }
d129 20
a148 1
  switch (r_type)
d150 34
a183 86
    case R_IREL:
      insn = bfd_get_32 (abfd, hit_data);
      /* Take the value in the field and sign extend it */
      signed_value = EXTRACT_HWORD(insn);
      signed_value = SIGN_EXTEND_HWORD(signed_value);
      signed_value <<= 2;

      /* See the note on the R_IREL reloc in coff_a29k_relocate_section.  */
      if (signed_value == - (long) reloc_entry->address)
	signed_value = 0;

      signed_value += sym_value + reloc_entry->addend;
      if ((signed_value & ~0x3ffff) == 0)
	{				/* Absolute jmp/call */
	  insn |= (1<<24);		/* Make it absolute */
	  /* FIXME: Should we change r_type to R_IABS */
	}
      else
	{
	  /* Relative jmp/call, so subtract from the value the
	     address of the place we're coming from */
	  signed_value -= (reloc_entry->address
			   + input_section->output_section->vma
			   + input_section->output_offset);
	  if (signed_value>0x1ffff || signed_value<-0x20000)
	    return(bfd_reloc_overflow);
	}
      signed_value >>= 2;
      insn = INSERT_HWORD(insn, signed_value);
      bfd_put_32 (abfd, insn ,hit_data);
      break;
    case R_ILOHALF:
      insn = bfd_get_32 (abfd, hit_data);
      unsigned_value = EXTRACT_HWORD(insn);
      unsigned_value +=  sym_value + reloc_entry->addend;
      insn = INSERT_HWORD(insn, unsigned_value);
      bfd_put_32 (abfd, insn, hit_data);
      break;
    case R_IHIHALF:
      insn = bfd_get_32 (abfd, hit_data);
      /* consth, part 1
	 Just get the symbol value that is referenced */
      part1_consth_active = true;
      part1_consth_value = sym_value + reloc_entry->addend;
      /* Don't modify insn until R_IHCONST */
      break;
    case R_IHCONST:
      insn = bfd_get_32 (abfd, hit_data);
      /* consth, part 2
	 Now relocate the reference */
      if (part1_consth_active == false)
	{
	  *error_message = (char *) _("Missing IHIHALF");
	  return(bfd_reloc_dangerous);
	}
      /* sym_ptr_ptr = r_symndx, in coff_slurp_reloc_table() */
      unsigned_value = 0;		/*EXTRACT_HWORD(insn) << 16;*/
      unsigned_value += reloc_entry->addend; /* r_symndx */
      unsigned_value += part1_consth_value;
      unsigned_value = unsigned_value >> 16;
      insn = INSERT_HWORD(insn, unsigned_value);
      part1_consth_active = false;
      bfd_put_32 (abfd, insn, hit_data);
      break;
    case R_BYTE:
      insn = bfd_get_8 (abfd, hit_data);
      unsigned_value = insn + sym_value + reloc_entry->addend;
      if (unsigned_value & 0xffffff00)
	return(bfd_reloc_overflow);
      bfd_put_8 (abfd, unsigned_value, hit_data);
      break;
    case R_HWORD:
      insn = bfd_get_16 (abfd, hit_data);
      unsigned_value = insn + sym_value + reloc_entry->addend;
      if (unsigned_value & 0xffff0000)
	return(bfd_reloc_overflow);
      bfd_put_16 (abfd, insn, hit_data);
      break;
    case R_WORD:
      insn = bfd_get_32 (abfd, hit_data);
      insn += sym_value + reloc_entry->addend;
      bfd_put_32 (abfd, insn, hit_data);
      break;
    default:
      *error_message = _("Unrecognized reloc");
      return (bfd_reloc_dangerous);
d185 32
d218 2
a219 1
  return(bfd_reloc_ok);
d231 1
a231 1
							       partial_inplace
d236 1
a236 1
static reloc_howto_type howto_table[] =
d285 1
a285 1
  static bfd_vma ihihalf_vaddr = (bfd_vma) -1;
d287 4
a290 4
  relent->address = reloc->r_vaddr;
  relent->howto = howto_table + reloc->r_type;
  if (reloc->r_type == R_IHCONST)
    {
d297 6
a302 6
      if (ihihalf_vaddr == (bfd_vma) -1)
	abort ();
      relent->address = ihihalf_vaddr;
      ihihalf_vaddr = (bfd_vma) -1;
      relent->addend = reloc->r_symndx;
      relent->sym_ptr_ptr= bfd_abs_section_ptr->symbol_ptr_ptr;
d304 1
a304 1
  else
d311 2
a312 2
      if (ptr
	  && bfd_asymbol_bfd(ptr) == abfd
d314 2
a315 2
	  && ((ptr->flags & BSF_OLD_COMMON)== 0))
	{
d317 1
a317 1
	}
d319 3
a321 3
	{
	  relent->addend = 0;
	}
d327 1
a327 1
    }
d573 1
a573 1
    }
d583 1
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1999, 2000, 2001, 2002
d34 1
a34 1
static bfd_boolean coff_a29k_relocate_section
d37 1
a37 1
static bfd_boolean coff_a29k_adjust_symndx
d39 1
a39 3
	   struct internal_reloc *, bfd_boolean *));
static void reloc_processing
  PARAMS ((arelent *, struct internal_reloc *, asymbol **, bfd *, asection *));
d50 1
a50 2
/* Provided the symbol, returns the value reffed.  */

d58 3
a60 1
    relocation = 0;
d62 5
a66 3
    relocation = symbol->value +
      symbol->section->output_section->vma +
      symbol->section->output_offset;
d68 1
a68 1
  return relocation;
d71 1
a71 1
/* This function is in charge of performing all the 29k relocations.  */
d84 3
a86 3
  /* The consth relocation comes in two parts, we have to remember
     the state between calls, in these variables.  */
  static bfd_boolean part1_consth_active = FALSE;
d88 1
d94 1
d102 1
a102 1
      /* Partial linking - do nothing.  */
d105 1
d111 1
a111 1
      /* Keep the state machine happy in case we're called again.  */
d114 1
a114 1
	  part1_consth_active = TRUE;
d117 1
a117 1
      return bfd_reloc_undefined;
d122 1
a122 1
      part1_consth_active = FALSE;
d124 1
a124 2

      return bfd_reloc_dangerous;
d133 1
a133 1
      /* Take the value in the field and sign extend it.  */
d145 2
a146 2
	  insn |= (1 << 24);		/* Make it absolute */
	  /* FIXME: Should we change r_type to R_IABS.  */
d151 1
a151 1
	     address of the place we're coming from.  */
d155 2
a156 2
	  if (signed_value > 0x1ffff || signed_value < -0x20000)
	    return bfd_reloc_overflow;
d159 2
a160 2
      insn = INSERT_HWORD (insn, signed_value);
      bfd_put_32 (abfd, (bfd_vma) insn ,hit_data);
d167 1
a167 1
      bfd_put_32 (abfd, (bfd_vma) insn, hit_data);
d172 2
a173 2
	 Just get the symbol value that is referenced.  */
      part1_consth_active = TRUE;
d175 1
a175 1
      /* Don't modify insn until R_IHCONST.  */
d180 2
a181 2
	 Now relocate the reference.  */
      if (! part1_consth_active)
d184 1
a184 1
	  return bfd_reloc_dangerous;
d192 2
a193 2
      part1_consth_active = FALSE;
      bfd_put_32 (abfd, (bfd_vma) insn, hit_data);
d199 1
a199 1
	return bfd_reloc_overflow;
d206 2
a207 2
	return bfd_reloc_overflow;
      bfd_put_16 (abfd, (bfd_vma) insn, hit_data);
d212 1
a212 1
      bfd_put_32 (abfd, (bfd_vma) insn, hit_data);
d216 1
a216 1
      return bfd_reloc_dangerous;
d222 14
a235 1
/*FIXME: I'm not real sure about this table.  */
d237 34
a270 34
  {
    {R_ABS,     0, 3, 32, FALSE, 0, complain_overflow_bitfield,a29k_reloc,"ABS",     TRUE, 0xffffffff,0xffffffff, FALSE},
    EMPTY_HOWTO (1),
    EMPTY_HOWTO (2),
    EMPTY_HOWTO (3),
    EMPTY_HOWTO (4),
    EMPTY_HOWTO (5),
    EMPTY_HOWTO (6),
    EMPTY_HOWTO (7),
    EMPTY_HOWTO (8),
    EMPTY_HOWTO (9),
    EMPTY_HOWTO (10),
    EMPTY_HOWTO (11),
    EMPTY_HOWTO (12),
    EMPTY_HOWTO (13),
    EMPTY_HOWTO (14),
    EMPTY_HOWTO (15),
    EMPTY_HOWTO (16),
    EMPTY_HOWTO (17),
    EMPTY_HOWTO (18),
    EMPTY_HOWTO (19),
    EMPTY_HOWTO (20),
    EMPTY_HOWTO (21),
    EMPTY_HOWTO (22),
    EMPTY_HOWTO (23),
    {R_IREL,    0, 3, 32, TRUE,  0, complain_overflow_signed,a29k_reloc,"IREL",    TRUE, 0xffffffff,0xffffffff, FALSE},
    {R_IABS,    0, 3, 32, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"IABS",    TRUE, 0xffffffff,0xffffffff, FALSE},
    {R_ILOHALF, 0, 3, 16, TRUE,  0, complain_overflow_signed, a29k_reloc,"ILOHALF", TRUE, 0x0000ffff,0x0000ffff, FALSE},
    {R_IHIHALF, 0, 3, 16, TRUE,  16, complain_overflow_signed, a29k_reloc,"IHIHALF", TRUE, 0xffff0000,0xffff0000, FALSE},
    {R_IHCONST, 0, 3, 16, TRUE,  0, complain_overflow_signed, a29k_reloc,"IHCONST", TRUE, 0xffff0000,0xffff0000, FALSE},
    {R_BYTE,    0, 0, 8, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"BYTE",    TRUE, 0x000000ff,0x000000ff, FALSE},
    {R_HWORD,   0, 1, 16, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"HWORD",   TRUE, 0x0000ffff,0x0000ffff, FALSE},
    {R_WORD,    0, 2, 32, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"WORD",    TRUE, 0xffffffff,0xffffffff, FALSE},
  };
d307 1
a307 2

      relent->sym_ptr_ptr = symbols + obj_convert (abfd)[reloc->r_symndx];
d313 5
a317 2
	  && ((ptr->flags & BSF_OLD_COMMON) == 0))
	relent->addend = 0;
d319 3
a321 2
	relent->addend = 0;

d332 1
a332 1
static bfd_boolean
d346 1
a346 1
  bfd_boolean hihalf;
d353 1
a353 1
    return TRUE;
d355 1
a355 1
  hihalf = FALSE;
d368 1
a368 1
      bfd_boolean overflow;
d407 1
a407 1
	      if (   h->root.type == bfd_link_hash_defined
d419 2
a420 2
			  rel->r_vaddr - input_section->vma, TRUE)))
		    return FALSE;
d429 2
a430 2
		return FALSE;
	      hihalf = FALSE;
d434 1
a434 1
      overflow = FALSE;
d440 1
a440 1
	  return FALSE;
d487 1
a487 1
		  overflow = TRUE;
d497 1
d505 1
a505 1
	  bfd_put_32 (input_bfd, (bfd_vma) insn, loc);
d510 1
a510 1
	  hihalf = TRUE;
d520 1
a520 1
		return FALSE;
d530 1
a530 1
	  hihalf = FALSE;
d540 1
a540 1
	    overflow = TRUE;
d571 1
a571 1
	    return FALSE;
d575 1
a575 1
  return TRUE;
d583 1
a583 1
static bfd_boolean
d590 1
a590 1
     bfd_boolean *adjustedp;
d593 1
a593 1
    *adjustedp = TRUE;
d595 2
a596 2
    *adjustedp = FALSE;
  return TRUE;
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1999, 2000, 2001,
   2002, 2003
d330 1
a330 1
  /* If we are performing a relocatable link, we don't need to do a
d333 1
a333 1
  if (info->relocatable)
d583 1
a583 1
CREATE_BIG_COFF_TARGET_VEC (a29kcoff_big_vec, "coff-a29k-big", 0, SEC_READONLY, '_', NULL, COFF_SWAP_TABLE)
@


