head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.6
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.04.06.18.29.27;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	DQNigUiY2QvUNxoT;

1.8
date	2004.11.02.20.45.11;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.23;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.31;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.22;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.33.23;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.01.36;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.46.49;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.08;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.08;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.06.22;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.38.38;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.12.53;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.20.30;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.54;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.27.17;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.19;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.33;	author miod;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Add support for an efi-app-x86_64 target.  Needed for UEFI bootloader work.

ok mlarkin@@
@
text
@/* Support for the generic parts of PE/PEI, for BFD.
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Written by Cygnus Solutions.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* Most of this hacked by  Steve Chamberlain,
			sac@@cygnus.com

   PE/PEI rearrangement (and code added): Donn Terry
                                       Softway Systems, Inc.  */

/* Hey look, some documentation [and in a place you expect to find it]!

   The main reference for the pei format is "Microsoft Portable Executable
   and Common Object File Format Specification 4.1".  Get it if you need to
   do some serious hacking on this code.

   Another reference:
   "Peering Inside the PE: A Tour of the Win32 Portable Executable
   File Format", MSJ 1994, Volume 9.

   The *sole* difference between the pe format and the pei format is that the
   latter has an MSDOS 2.0 .exe header on the front that prints the message
   "This app must be run under Windows." (or some such).
   (FIXME: Whether that statement is *really* true or not is unknown.
   Are there more subtle differences between pe and pei formats?
   For now assume there aren't.  If you find one, then for God sakes
   document it here!)

   The Microsoft docs use the word "image" instead of "executable" because
   the former can also refer to a DLL (shared library).  Confusion can arise
   because the `i' in `pei' also refers to "image".  The `pe' format can
   also create images (i.e. executables), it's just that to run on a win32
   system you need to use the pei format.

   FIXME: Please add more docs here so the next poor fool that has to hack
   on this code has a chance of getting something accomplished without
   wasting too much time.  */

#include "libpei.h"

static bfd_boolean (*pe_saved_coff_bfd_print_private_bfd_data)
    PARAMS ((bfd *, PTR)) =
#ifndef coff_bfd_print_private_bfd_data
     NULL;
#else
     coff_bfd_print_private_bfd_data;
#undef coff_bfd_print_private_bfd_data
#endif

static bfd_boolean pe_print_private_bfd_data PARAMS ((bfd *, PTR));
#define coff_bfd_print_private_bfd_data pe_print_private_bfd_data

static bfd_boolean (*pe_saved_coff_bfd_copy_private_bfd_data)
    PARAMS ((bfd *, bfd *)) =
#ifndef coff_bfd_copy_private_bfd_data
     NULL;
#else
     coff_bfd_copy_private_bfd_data;
#undef coff_bfd_copy_private_bfd_data
#endif

static bfd_boolean pe_bfd_copy_private_bfd_data PARAMS ((bfd *, bfd *));
#define coff_bfd_copy_private_bfd_data pe_bfd_copy_private_bfd_data

#define coff_mkobject      pe_mkobject
#define coff_mkobject_hook pe_mkobject_hook

#ifndef NO_COFF_RELOCS
static void coff_swap_reloc_in PARAMS ((bfd *, PTR, PTR));
static unsigned int coff_swap_reloc_out PARAMS ((bfd *, PTR, PTR));
#endif
static void coff_swap_filehdr_in PARAMS ((bfd *, PTR, PTR));
static void coff_swap_scnhdr_in PARAMS ((bfd *, PTR, PTR));
static bfd_boolean pe_mkobject PARAMS ((bfd *));
static PTR pe_mkobject_hook PARAMS ((bfd *, PTR, PTR));

#ifdef COFF_IMAGE_WITH_PE
/* This structure contains static variables used by the ILF code.  */
typedef asection * asection_ptr;

typedef struct
{
  bfd *			abfd;
  bfd_byte *		data;
  struct bfd_in_memory * bim;
  unsigned short        magic;

  arelent *		reltab;
  unsigned int 		relcount;

  coff_symbol_type * 	sym_cache;
  coff_symbol_type * 	sym_ptr;
  unsigned int       	sym_index;

  unsigned int * 	sym_table;
  unsigned int * 	table_ptr;

  combined_entry_type * native_syms;
  combined_entry_type * native_ptr;

  coff_symbol_type **	sym_ptr_table;
  coff_symbol_type **	sym_ptr_ptr;

  unsigned int		sec_index;

  char *                string_table;
  char *                string_ptr;
  char *		end_string_ptr;

  SYMENT *              esym_table;
  SYMENT *              esym_ptr;

  struct internal_reloc * int_reltab;
}
pe_ILF_vars;

static asection_ptr       pe_ILF_make_a_section   PARAMS ((pe_ILF_vars *, const char *, unsigned int, flagword));
static void               pe_ILF_make_a_reloc     PARAMS ((pe_ILF_vars *, bfd_vma, bfd_reloc_code_real_type, asection_ptr));
static void               pe_ILF_make_a_symbol    PARAMS ((pe_ILF_vars *, const char *, const char *, asection_ptr, flagword));
static void               pe_ILF_save_relocs      PARAMS ((pe_ILF_vars *, asection_ptr));
static void		  pe_ILF_make_a_symbol_reloc  PARAMS ((pe_ILF_vars *, bfd_vma, bfd_reloc_code_real_type, struct bfd_symbol **, unsigned int));
static bfd_boolean        pe_ILF_build_a_bfd      PARAMS ((bfd *, unsigned int, bfd_byte *, bfd_byte *, unsigned int, unsigned int));
static const bfd_target * pe_ILF_object_p         PARAMS ((bfd *));
static const bfd_target * pe_bfd_object_p 	  PARAMS ((bfd *));
#endif /* COFF_IMAGE_WITH_PE */

/**********************************************************************/

#ifndef NO_COFF_RELOCS
static void
coff_swap_reloc_in (abfd, src, dst)
     bfd *abfd;
     PTR src;
     PTR dst;
{
  RELOC *reloc_src = (RELOC *) src;
  struct internal_reloc *reloc_dst = (struct internal_reloc *) dst;

  reloc_dst->r_vaddr = H_GET_32 (abfd, reloc_src->r_vaddr);
  reloc_dst->r_symndx = H_GET_S32 (abfd, reloc_src->r_symndx);

  reloc_dst->r_type = H_GET_16 (abfd, reloc_src->r_type);

#ifdef SWAP_IN_RELOC_OFFSET
  reloc_dst->r_offset = SWAP_IN_RELOC_OFFSET (abfd, reloc_src->r_offset);
#endif
}

static unsigned int
coff_swap_reloc_out (abfd, src, dst)
     bfd       *abfd;
     PTR	src;
     PTR	dst;
{
  struct internal_reloc *reloc_src = (struct internal_reloc *)src;
  struct external_reloc *reloc_dst = (struct external_reloc *)dst;
  H_PUT_32 (abfd, reloc_src->r_vaddr, reloc_dst->r_vaddr);
  H_PUT_32 (abfd, reloc_src->r_symndx, reloc_dst->r_symndx);

  H_PUT_16 (abfd, reloc_src->r_type, reloc_dst->r_type);

#ifdef SWAP_OUT_RELOC_OFFSET
  SWAP_OUT_RELOC_OFFSET (abfd, reloc_src->r_offset, reloc_dst->r_offset);
#endif
#ifdef SWAP_OUT_RELOC_EXTRA
  SWAP_OUT_RELOC_EXTRA(abfd, reloc_src, reloc_dst);
#endif
  return RELSZ;
}
#endif /* not NO_COFF_RELOCS */

static void
coff_swap_filehdr_in (abfd, src, dst)
     bfd            *abfd;
     PTR	     src;
     PTR	     dst;
{
  FILHDR *filehdr_src = (FILHDR *) src;
  struct internal_filehdr *filehdr_dst = (struct internal_filehdr *) dst;
  filehdr_dst->f_magic = H_GET_16 (abfd, filehdr_src->f_magic);
  filehdr_dst->f_nscns = H_GET_16 (abfd, filehdr_src-> f_nscns);
  filehdr_dst->f_timdat = H_GET_32 (abfd, filehdr_src-> f_timdat);

  filehdr_dst->f_nsyms = H_GET_32 (abfd, filehdr_src-> f_nsyms);
  filehdr_dst->f_flags = H_GET_16 (abfd, filehdr_src-> f_flags);
  filehdr_dst->f_symptr = H_GET_32 (abfd, filehdr_src->f_symptr);

  /* Other people's tools sometimes generate headers with an nsyms but
     a zero symptr.  */
  if (filehdr_dst->f_nsyms != 0 && filehdr_dst->f_symptr == 0)
    {
      filehdr_dst->f_nsyms = 0;
      filehdr_dst->f_flags |= F_LSYMS;
    }

  filehdr_dst->f_opthdr = H_GET_16 (abfd, filehdr_src-> f_opthdr);
}

#ifdef COFF_IMAGE_WITH_PE
# define coff_swap_filehdr_out _bfd_XXi_only_swap_filehdr_out
#else
# define coff_swap_filehdr_out _bfd_pe_only_swap_filehdr_out
#endif

static void
coff_swap_scnhdr_in (abfd, ext, in)
     bfd            *abfd;
     PTR	     ext;
     PTR	     in;
{
  SCNHDR *scnhdr_ext = (SCNHDR *) ext;
  struct internal_scnhdr *scnhdr_int = (struct internal_scnhdr *) in;

  memcpy(scnhdr_int->s_name, scnhdr_ext->s_name, sizeof (scnhdr_int->s_name));
  scnhdr_int->s_vaddr = GET_SCNHDR_VADDR (abfd, scnhdr_ext->s_vaddr);
  scnhdr_int->s_paddr = GET_SCNHDR_PADDR (abfd, scnhdr_ext->s_paddr);
  scnhdr_int->s_size = GET_SCNHDR_SIZE (abfd, scnhdr_ext->s_size);
  scnhdr_int->s_scnptr = GET_SCNHDR_SCNPTR (abfd, scnhdr_ext->s_scnptr);
  scnhdr_int->s_relptr = GET_SCNHDR_RELPTR (abfd, scnhdr_ext->s_relptr);
  scnhdr_int->s_lnnoptr = GET_SCNHDR_LNNOPTR (abfd, scnhdr_ext->s_lnnoptr);
  scnhdr_int->s_flags = H_GET_32 (abfd, scnhdr_ext->s_flags);

  /* MS handles overflow of line numbers by carrying into the reloc
     field (it appears).  Since it's supposed to be zero for PE
     *IMAGE* format, that's safe.  This is still a bit iffy.  */
#ifdef COFF_IMAGE_WITH_PE
  scnhdr_int->s_nlnno = (H_GET_16 (abfd, scnhdr_ext->s_nlnno)
			 + (H_GET_16 (abfd, scnhdr_ext->s_nreloc) << 16));
  scnhdr_int->s_nreloc = 0;
#else
  scnhdr_int->s_nreloc = H_GET_16 (abfd, scnhdr_ext->s_nreloc);
  scnhdr_int->s_nlnno = H_GET_16 (abfd, scnhdr_ext->s_nlnno);
#endif

  if (scnhdr_int->s_vaddr != 0)
    {
      scnhdr_int->s_vaddr += pe_data (abfd)->pe_opthdr.ImageBase;
      scnhdr_int->s_vaddr &= 0xffffffff;
    }

#ifndef COFF_NO_HACK_SCNHDR_SIZE
  /* If this section holds uninitialized data and is from an object file
     or from an executable image that has not initialized the field,
     or if the image is an executable file and the physical size is padded,
     use the virtual size (stored in s_paddr) instead.  */
  if (scnhdr_int->s_paddr > 0
      && (((scnhdr_int->s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) != 0
	   && (! bfd_pe_executable_p (abfd) || scnhdr_int->s_size == 0))
          || (bfd_pe_executable_p (abfd) && scnhdr_int->s_size > scnhdr_int->s_paddr)))
    {
      scnhdr_int->s_size = scnhdr_int->s_paddr;

      /* This code used to set scnhdr_int->s_paddr to 0.  However,
         coff_set_alignment_hook stores s_paddr in virt_size, which
         only works if it correctly holds the virtual size of the
         section.  */
    }
#endif
}

static bfd_boolean
pe_mkobject (abfd)
     bfd * abfd;
{
  pe_data_type *pe;
  bfd_size_type amt = sizeof (pe_data_type);

  abfd->tdata.pe_obj_data = (struct pe_tdata *) bfd_zalloc (abfd, amt);

  if (abfd->tdata.pe_obj_data == 0)
    return FALSE;

  pe = pe_data (abfd);

  pe->coff.pe = 1;

  /* in_reloc_p is architecture dependent.  */
  pe->in_reloc_p = in_reloc_p;

#ifdef PEI_FORCE_MINIMUM_ALIGNMENT
  pe->force_minimum_alignment = 1;
#endif
#ifdef PEI_TARGET_SUBSYSTEM
  pe->target_subsystem = PEI_TARGET_SUBSYSTEM;
#endif

  return TRUE;
}

/* Create the COFF backend specific information.  */
static PTR
pe_mkobject_hook (abfd, filehdr, aouthdr)
     bfd * abfd;
     PTR filehdr;
     PTR aouthdr ATTRIBUTE_UNUSED;
{
  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;
  pe_data_type *pe;

  if (! pe_mkobject (abfd))
    return NULL;

  pe = pe_data (abfd);
  pe->coff.sym_filepos = internal_f->f_symptr;
  /* These members communicate important constants about the symbol
     table to GDB's symbol-reading code.  These `constants'
     unfortunately vary among coff implementations...  */
  pe->coff.local_n_btmask = N_BTMASK;
  pe->coff.local_n_btshft = N_BTSHFT;
  pe->coff.local_n_tmask = N_TMASK;
  pe->coff.local_n_tshift = N_TSHIFT;
  pe->coff.local_symesz = SYMESZ;
  pe->coff.local_auxesz = AUXESZ;
  pe->coff.local_linesz = LINESZ;

  pe->coff.timestamp = internal_f->f_timdat;

  obj_raw_syment_count (abfd) =
    obj_conv_table_size (abfd) =
      internal_f->f_nsyms;

  pe->real_flags = internal_f->f_flags;

  if ((internal_f->f_flags & F_DLL) != 0)
    pe->dll = 1;

  if ((internal_f->f_flags & IMAGE_FILE_DEBUG_STRIPPED) == 0)
    abfd->flags |= HAS_DEBUG;

#ifdef COFF_IMAGE_WITH_PE
  if (aouthdr)
    pe->pe_opthdr = ((struct internal_aouthdr *)aouthdr)->pe;
#endif

#ifdef ARM
  if (! _bfd_coff_arm_set_private_flags (abfd, internal_f->f_flags))
    coff_data (abfd) ->flags = 0;
#endif

  return (PTR) pe;
}

static bfd_boolean
pe_print_private_bfd_data (abfd, vfile)
     bfd *abfd;
     PTR vfile;
{
  FILE *file = (FILE *) vfile;

  if (!_bfd_XX_print_private_bfd_data_common (abfd, vfile))
    return FALSE;

  if (pe_saved_coff_bfd_print_private_bfd_data != NULL)
    {
      fputc ('\n', file);

      return pe_saved_coff_bfd_print_private_bfd_data (abfd, vfile);
    }

  return TRUE;
}

/* Copy any private info we understand from the input bfd
   to the output bfd.  */

static bfd_boolean
pe_bfd_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd, *obfd;
{
  if (!_bfd_XX_bfd_copy_private_bfd_data_common (ibfd, obfd))
    return FALSE;

  if (pe_saved_coff_bfd_copy_private_bfd_data)
    return pe_saved_coff_bfd_copy_private_bfd_data (ibfd, obfd);

  return TRUE;
}

#define coff_bfd_copy_private_section_data \
  _bfd_XX_bfd_copy_private_section_data

#define coff_get_symbol_info _bfd_XX_get_symbol_info

#ifdef COFF_IMAGE_WITH_PE

/* Code to handle Microsoft's Image Library Format.
   Also known as LINK6 format.
   Documentation about this format can be found at:

   http://msdn.microsoft.com/library/specs/pecoff_section8.htm  */

/* The following constants specify the sizes of the various data
   structures that we have to create in order to build a bfd describing
   an ILF object file.  The final "+ 1" in the definitions of SIZEOF_IDATA6
   and SIZEOF_IDATA7 below is to allow for the possibility that we might
   need a padding byte in order to ensure 16 bit alignment for the section's
   contents.

   The value for SIZEOF_ILF_STRINGS is computed as follows:

      There will be NUM_ILF_SECTIONS section symbols.  Allow 9 characters
      per symbol for their names (longest section name is .idata$x).

      There will be two symbols for the imported value, one the symbol name
      and one with _imp__ prefixed.  Allowing for the terminating nul's this
      is strlen (symbol_name) * 2 + 8 + 21 + strlen (source_dll).

      The strings in the string table must start STRING__SIZE_SIZE bytes into
      the table in order to for the string lookup code in coffgen/coffcode to
      work.  */
#define NUM_ILF_RELOCS		8
#define NUM_ILF_SECTIONS        6
#define NUM_ILF_SYMS 		(2 + NUM_ILF_SECTIONS)

#define SIZEOF_ILF_SYMS		(NUM_ILF_SYMS * sizeof (* vars.sym_cache))
#define SIZEOF_ILF_SYM_TABLE	(NUM_ILF_SYMS * sizeof (* vars.sym_table))
#define SIZEOF_ILF_NATIVE_SYMS	(NUM_ILF_SYMS * sizeof (* vars.native_syms))
#define SIZEOF_ILF_SYM_PTR_TABLE (NUM_ILF_SYMS * sizeof (* vars.sym_ptr_table))
#define SIZEOF_ILF_EXT_SYMS	(NUM_ILF_SYMS * sizeof (* vars.esym_table))
#define SIZEOF_ILF_RELOCS	(NUM_ILF_RELOCS * sizeof (* vars.reltab))
#define SIZEOF_ILF_INT_RELOCS	(NUM_ILF_RELOCS * sizeof (* vars.int_reltab))
#define SIZEOF_ILF_STRINGS	(strlen (symbol_name) * 2 + 8 \
					+ 21 + strlen (source_dll) \
					+ NUM_ILF_SECTIONS * 9 \
					+ STRING_SIZE_SIZE)
#define SIZEOF_IDATA2		(5 * 4)
#define SIZEOF_IDATA4		(1 * 4)
#define SIZEOF_IDATA5		(1 * 4)
#define SIZEOF_IDATA6		(2 + strlen (symbol_name) + 1 + 1)
#define SIZEOF_IDATA7		(strlen (source_dll) + 1 + 1)
#define SIZEOF_ILF_SECTIONS     (NUM_ILF_SECTIONS * sizeof (struct coff_section_tdata))

#define ILF_DATA_SIZE				\
      sizeof (* vars.bim)			\
    + SIZEOF_ILF_SYMS				\
    + SIZEOF_ILF_SYM_TABLE			\
    + SIZEOF_ILF_NATIVE_SYMS			\
    + SIZEOF_ILF_SYM_PTR_TABLE			\
    + SIZEOF_ILF_EXT_SYMS			\
    + SIZEOF_ILF_RELOCS				\
    + SIZEOF_ILF_INT_RELOCS			\
    + SIZEOF_ILF_STRINGS			\
    + SIZEOF_IDATA2				\
    + SIZEOF_IDATA4				\
    + SIZEOF_IDATA5				\
    + SIZEOF_IDATA6				\
    + SIZEOF_IDATA7				\
    + SIZEOF_ILF_SECTIONS			\
    + MAX_TEXT_SECTION_SIZE

/* Create an empty relocation against the given symbol.  */
static void
pe_ILF_make_a_symbol_reloc (pe_ILF_vars *                 vars,
			    bfd_vma                       address,
			    bfd_reloc_code_real_type      reloc,
			    struct bfd_symbol **  sym,
			    unsigned int                  sym_index)
{
  arelent * entry;
  struct internal_reloc * internal;

  entry = vars->reltab + vars->relcount;
  internal = vars->int_reltab + vars->relcount;

  entry->address     = address;
  entry->addend      = 0;
  entry->howto       = bfd_reloc_type_lookup (vars->abfd, reloc);
  entry->sym_ptr_ptr = sym;

  internal->r_vaddr  = address;
  internal->r_symndx = sym_index;
  internal->r_type   = entry->howto->type;
#if 0  /* These fields do not need to be initialised.  */
  internal->r_size   = 0;
  internal->r_extern = 0;
  internal->r_offset = 0;
#endif

  vars->relcount ++;

  BFD_ASSERT (vars->relcount <= NUM_ILF_RELOCS);
}

/* Create an empty relocation against the given section.  */
static void
pe_ILF_make_a_reloc (pe_ILF_vars *             vars,
		     bfd_vma                   address,
		     bfd_reloc_code_real_type  reloc,
		     asection_ptr              sec)
{
  pe_ILF_make_a_symbol_reloc (vars, address, reloc, sec->symbol_ptr_ptr,
			      coff_section_data (vars->abfd, sec)->i);
}

/* Move the queued relocs into the given section.  */
static void
pe_ILF_save_relocs (pe_ILF_vars * vars,
		    asection_ptr  sec)
{
  /* Make sure that there is somewhere to store the internal relocs.  */
  if (coff_section_data (vars->abfd, sec) == NULL)
    /* We should probably return an error indication here.  */
    abort ();

  coff_section_data (vars->abfd, sec)->relocs = vars->int_reltab;
  coff_section_data (vars->abfd, sec)->keep_relocs = TRUE;

  sec->relocation  = vars->reltab;
  sec->reloc_count = vars->relcount;
  sec->flags      |= SEC_RELOC;

  vars->reltab     += vars->relcount;
  vars->int_reltab += vars->relcount;
  vars->relcount   = 0;

  BFD_ASSERT ((bfd_byte *) vars->int_reltab < (bfd_byte *) vars->string_table);
}

/* Create a global symbol and add it to the relevant tables.  */
static void
pe_ILF_make_a_symbol (pe_ILF_vars *  vars,
		      const char *   prefix,
		      const char *   symbol_name,
		      asection_ptr   section,
		      flagword       extra_flags)
{
  coff_symbol_type * sym;
  combined_entry_type * ent;
  SYMENT * esym;
  unsigned short sclass;

  if (extra_flags & BSF_LOCAL)
    sclass = C_STAT;
  else
    sclass = C_EXT;

#ifdef THUMBPEMAGIC
  if (vars->magic == THUMBPEMAGIC)
    {
      if (extra_flags & BSF_FUNCTION)
	sclass = C_THUMBEXTFUNC;
      else if (extra_flags & BSF_LOCAL)
	sclass = C_THUMBSTAT;
      else
	sclass = C_THUMBEXT;
    }
#endif

  BFD_ASSERT (vars->sym_index < NUM_ILF_SYMS);

  sym = vars->sym_ptr;
  ent = vars->native_ptr;
  esym = vars->esym_ptr;

  /* Copy the symbol's name into the string table.  */
  sprintf (vars->string_ptr, "%s%s", prefix, symbol_name);

  if (section == NULL)
    section = (asection_ptr) & bfd_und_section;

  /* Initialise the external symbol.  */
  H_PUT_32 (vars->abfd, vars->string_ptr - vars->string_table,
	    esym->e.e.e_offset);
  H_PUT_16 (vars->abfd, section->target_index, esym->e_scnum);
  esym->e_sclass[0] = sclass;

  /* The following initialisations are unnecessary - the memory is
     zero initialised.  They are just kept here as reminders.  */
#if 0
  esym->e.e.e_zeroes = 0;
  esym->e_value = 0;
  esym->e_type = T_NULL;
  esym->e_numaux = 0;
#endif

  /* Initialise the internal symbol structure.  */
  ent->u.syment.n_sclass          = sclass;
  ent->u.syment.n_scnum           = section->target_index;
  ent->u.syment._n._n_n._n_offset = (long) sym;

#if 0 /* See comment above.  */
  ent->u.syment.n_value  = 0;
  ent->u.syment.n_flags  = 0;
  ent->u.syment.n_type   = T_NULL;
  ent->u.syment.n_numaux = 0;
  ent->fix_value         = 0;
#endif

  sym->symbol.the_bfd = vars->abfd;
  sym->symbol.name    = vars->string_ptr;
  sym->symbol.flags   = BSF_EXPORT | BSF_GLOBAL | extra_flags;
  sym->symbol.section = section;
  sym->native         = ent;

#if 0 /* See comment above.  */
  sym->symbol.value   = 0;
  sym->symbol.udata.i = 0;
  sym->done_lineno    = FALSE;
  sym->lineno         = NULL;
#endif

  * vars->table_ptr = vars->sym_index;
  * vars->sym_ptr_ptr = sym;

  /* Adjust pointers for the next symbol.  */
  vars->sym_index ++;
  vars->sym_ptr ++;
  vars->sym_ptr_ptr ++;
  vars->table_ptr ++;
  vars->native_ptr ++;
  vars->esym_ptr ++;
  vars->string_ptr += strlen (symbol_name) + strlen (prefix) + 1;

  BFD_ASSERT (vars->string_ptr < vars->end_string_ptr);
}

/* Create a section.  */
static asection_ptr
pe_ILF_make_a_section (pe_ILF_vars * vars,
		       const char *  name,
		       unsigned int  size,
		       flagword      extra_flags)
{
  asection_ptr sec;
  flagword     flags;

  sec = bfd_make_section_old_way (vars->abfd, name);
  if (sec == NULL)
    return NULL;

  flags = SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_KEEP | SEC_IN_MEMORY;

  bfd_set_section_flags (vars->abfd, sec, flags | extra_flags);

  bfd_set_section_alignment (vars->abfd, sec, 2);

  /* Check that we will not run out of space.  */
  BFD_ASSERT (vars->data + size < vars->bim->buffer + vars->bim->size);

  /* Set the section size and contents.  The actual
     contents are filled in by our parent.  */
  bfd_set_section_size (vars->abfd, sec, (bfd_size_type) size);
  sec->contents = vars->data;
  sec->target_index = vars->sec_index ++;

  /* Advance data pointer in the vars structure.  */
  vars->data += size;

  /* Skip the padding byte if it was not needed.
     The logic here is that if the string length is odd,
     then the entire string length, including the null byte,
     is even and so the extra, padding byte, is not needed.  */
  if (size & 1)
    vars->data --;

  /* Create a coff_section_tdata structure for our use.  */
  sec->used_by_bfd = (struct coff_section_tdata *) vars->data;
  vars->data += sizeof (struct coff_section_tdata);

  BFD_ASSERT (vars->data <= vars->bim->buffer + vars->bim->size);

  /* Create a symbol to refer to this section.  */
  pe_ILF_make_a_symbol (vars, "", name, sec, BSF_LOCAL);

  /* Cache the index to the symbol in the coff_section_data structure.  */
  coff_section_data (vars->abfd, sec)->i = vars->sym_index - 1;

  return sec;
}

/* This structure contains the code that goes into the .text section
   in order to perform a jump into the DLL lookup table.  The entries
   in the table are index by the magic number used to represent the
   machine type in the PE file.  The contents of the data[] arrays in
   these entries are stolen from the jtab[] arrays in ld/pe-dll.c.
   The SIZE field says how many bytes in the DATA array are actually
   used.  The OFFSET field says where in the data array the address
   of the .idata$5 section should be placed.  */
#define MAX_TEXT_SECTION_SIZE 32

typedef struct
{
  unsigned short magic;
  unsigned char  data[MAX_TEXT_SECTION_SIZE];
  unsigned int   size;
  unsigned int   offset;
}
jump_table;

static jump_table jtab[] =
{
#ifdef I386MAGIC
  { I386MAGIC,
    { 0xff, 0x25, 0x00, 0x00, 0x00, 0x00, 0x90, 0x90 },
    8, 2
  },
#endif

#ifdef  MC68MAGIC
  { MC68MAGIC, { /* XXX fill me in */ }, 0, 0 },
#endif
#ifdef  MIPS_ARCH_MAGIC_WINCE
  { MIPS_ARCH_MAGIC_WINCE,
    { 0x00, 0x00, 0x08, 0x3c, 0x00, 0x00, 0x08, 0x8d,
      0x08, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 },
    16, 0
  },
#endif

#ifdef  SH_ARCH_MAGIC_WINCE
  { SH_ARCH_MAGIC_WINCE,
    { 0x01, 0xd0, 0x02, 0x60, 0x2b, 0x40,
      0x09, 0x00, 0x00, 0x00, 0x00, 0x00 },
    12, 8
  },
#endif

#ifdef  ARMPEMAGIC
  { ARMPEMAGIC,
    { 0x00, 0xc0, 0x9f, 0xe5, 0x00, 0xf0,
      0x9c, 0xe5, 0x00, 0x00, 0x00, 0x00},
    12, 8
  },
#endif

#ifdef  THUMBPEMAGIC
  { THUMBPEMAGIC,
    { 0x40, 0xb4, 0x02, 0x4e, 0x36, 0x68, 0xb4, 0x46,
      0x40, 0xbc, 0x60, 0x47, 0x00, 0x00, 0x00, 0x00 },
    16, 12
  },
#endif
  { 0, { 0 }, 0, 0 }
};

#ifndef NUM_ENTRIES
#define NUM_ENTRIES(a) (sizeof (a) / sizeof (a)[0])
#endif

/* Build a full BFD from the information supplied in a ILF object.  */
static bfd_boolean
pe_ILF_build_a_bfd (bfd *           abfd,
		    unsigned int    magic,
		    bfd_byte *      symbol_name,
		    bfd_byte *      source_dll,
		    unsigned int    ordinal,
		    unsigned int    types)
{
  bfd_byte *               ptr;
  pe_ILF_vars              vars;
  struct internal_filehdr  internal_f;
  unsigned int             import_type;
  unsigned int             import_name_type;
  asection_ptr             id4, id5, id6 = NULL, text = NULL;
  coff_symbol_type **      imp_sym;
  unsigned int             imp_index;

  /* Decode and verify the types field of the ILF structure.  */
  import_type = types & 0x3;
  import_name_type = (types & 0x1c) >> 2;

  switch (import_type)
    {
    case IMPORT_CODE:
    case IMPORT_DATA:
      break;

    case IMPORT_CONST:
      /* XXX code yet to be written.  */
      _bfd_error_handler (_("%s: Unhandled import type; %x"),
			  bfd_archive_filename (abfd), import_type);
      return FALSE;

    default:
      _bfd_error_handler (_("%s: Unrecognised import type; %x"),
			  bfd_archive_filename (abfd), import_type);
      return FALSE;
    }

  switch (import_name_type)
    {
    case IMPORT_ORDINAL:
    case IMPORT_NAME:
    case IMPORT_NAME_NOPREFIX:
    case IMPORT_NAME_UNDECORATE:
      break;

    default:
      _bfd_error_handler (_("%s: Unrecognised import name type; %x"),
			  bfd_archive_filename (abfd), import_name_type);
      return FALSE;
    }

  /* Initialise local variables.

     Note these are kept in a structure rather than being
     declared as statics since bfd frowns on global variables.

     We are going to construct the contents of the BFD in memory,
     so allocate all the space that we will need right now.  */
  ptr = bfd_zalloc (abfd, (bfd_size_type) ILF_DATA_SIZE);
  if (ptr == NULL)
    return FALSE;

  /* Create a bfd_in_memory structure.  */
  vars.bim = (struct bfd_in_memory *) ptr;
  vars.bim->buffer = ptr;
  vars.bim->size   = ILF_DATA_SIZE;
  ptr += sizeof (* vars.bim);

  /* Initialise the pointers to regions of the memory and the
     other contents of the pe_ILF_vars structure as well.  */
  vars.sym_cache = (coff_symbol_type *) ptr;
  vars.sym_ptr   = (coff_symbol_type *) ptr;
  vars.sym_index = 0;
  ptr += SIZEOF_ILF_SYMS;

  vars.sym_table = (unsigned int *) ptr;
  vars.table_ptr = (unsigned int *) ptr;
  ptr += SIZEOF_ILF_SYM_TABLE;

  vars.native_syms = (combined_entry_type *) ptr;
  vars.native_ptr  = (combined_entry_type *) ptr;
  ptr += SIZEOF_ILF_NATIVE_SYMS;

  vars.sym_ptr_table = (coff_symbol_type **) ptr;
  vars.sym_ptr_ptr   = (coff_symbol_type **) ptr;
  ptr += SIZEOF_ILF_SYM_PTR_TABLE;

  vars.esym_table = (SYMENT *) ptr;
  vars.esym_ptr   = (SYMENT *) ptr;
  ptr += SIZEOF_ILF_EXT_SYMS;

  vars.reltab   = (arelent *) ptr;
  vars.relcount = 0;
  ptr += SIZEOF_ILF_RELOCS;

  vars.int_reltab  = (struct internal_reloc *) ptr;
  ptr += SIZEOF_ILF_INT_RELOCS;

  vars.string_table = ptr;
  vars.string_ptr   = ptr + STRING_SIZE_SIZE;
  ptr += SIZEOF_ILF_STRINGS;
  vars.end_string_ptr = ptr;

  /* The remaining space in bim->buffer is used
     by the pe_ILF_make_a_section() function.  */
  vars.data = ptr;
  vars.abfd = abfd;
  vars.sec_index = 0;
  vars.magic = magic;

  /* Create the initial .idata$<n> sections:
     [.idata$2:  Import Directory Table -- not needed]
     .idata$4:  Import Lookup Table
     .idata$5:  Import Address Table

     Note we do not create a .idata$3 section as this is
     created for us by the linker script.  */
  id4 = pe_ILF_make_a_section (& vars, ".idata$4", SIZEOF_IDATA4, 0);
  id5 = pe_ILF_make_a_section (& vars, ".idata$5", SIZEOF_IDATA5, 0);
  if (id4 == NULL || id5 == NULL)
    return FALSE;

  /* Fill in the contents of these sections.  */
  if (import_name_type == IMPORT_ORDINAL)
    {
      if (ordinal == 0)
	/* XXX - treat as IMPORT_NAME ??? */
	abort ();

      * (unsigned int *) id4->contents = ordinal | 0x80000000;
      * (unsigned int *) id5->contents = ordinal | 0x80000000;
    }
  else
    {
      char * symbol;

      /* Create .idata$6 - the Hint Name Table.  */
      id6 = pe_ILF_make_a_section (& vars, ".idata$6", SIZEOF_IDATA6, 0);
      if (id6 == NULL)
	return FALSE;

      /* If necessary, trim the import symbol name.  */
      symbol = symbol_name;

      if (import_name_type != IMPORT_NAME)
	{
	  bfd_boolean skipped_leading_underscore = FALSE;
	  bfd_boolean skipped_leading_at = FALSE;
	  bfd_boolean skipped_leading_question_mark = FALSE;
	  bfd_boolean check_again;
	  
	  /* Skip any prefix in symbol_name.  */
	  -- symbol;
	  do
	    {
	      check_again = FALSE;
	      ++ symbol;

	      switch (*symbol)
		{
		case '@@':
		  if (! skipped_leading_at)
		    check_again = skipped_leading_at = TRUE;
		  break;
		case '?':
		  if (! skipped_leading_question_mark)
		    check_again = skipped_leading_question_mark = TRUE;
		  break;
		case '_':
		  if (! skipped_leading_underscore)
		    check_again = skipped_leading_underscore = TRUE;
		  break;
		default:
		  break;
		}
	    }
	  while (check_again);
	}
      
      if (import_name_type == IMPORT_NAME_UNDECORATE)
	{
	  /* Truncate at the first '@@'  */
	  while (* symbol != 0 && * symbol != '@@')
	    symbol ++;

	  * symbol = 0;
	}

      id6->contents[0] = ordinal & 0xff;
      id6->contents[1] = ordinal >> 8;

      strcpy (id6->contents + 2, symbol);
    }

  if (import_name_type != IMPORT_ORDINAL)
    {
      pe_ILF_make_a_reloc (&vars, (bfd_vma) 0, BFD_RELOC_RVA, id6);
      pe_ILF_save_relocs (&vars, id4);

      pe_ILF_make_a_reloc (&vars, (bfd_vma) 0, BFD_RELOC_RVA, id6);
      pe_ILF_save_relocs (&vars, id5);
    }

  /* Create extra sections depending upon the type of import we are dealing with.  */
  switch (import_type)
    {
      int i;

    case IMPORT_CODE:
      /* Create a .text section.
	 First we need to look up its contents in the jump table.  */
      for (i = NUM_ENTRIES (jtab); i--;)
	{
	  if (jtab[i].size == 0)
	    continue;
	  if (jtab[i].magic == magic)
	    break;
	}
      /* If we did not find a matching entry something is wrong.  */
      if (i < 0)
	abort ();

      /* Create the .text section.  */
      text = pe_ILF_make_a_section (& vars, ".text", jtab[i].size, SEC_CODE);
      if (text == NULL)
	return FALSE;

      /* Copy in the jump code.  */
      memcpy (text->contents, jtab[i].data, jtab[i].size);

      /* Create an import symbol.  */
      pe_ILF_make_a_symbol (& vars, "__imp_", symbol_name, id5, 0);
      imp_sym   = vars.sym_ptr_ptr - 1;
      imp_index = vars.sym_index - 1;

      /* Create a reloc for the data in the text section.  */
#ifdef MIPS_ARCH_MAGIC_WINCE
      if (magic == MIPS_ARCH_MAGIC_WINCE)
	{
	  pe_ILF_make_a_symbol_reloc (&vars, (bfd_vma) 0, BFD_RELOC_HI16_S,
				      (struct bfd_symbol **) imp_sym,
				      imp_index);
	  pe_ILF_make_a_reloc (&vars, (bfd_vma) 0, BFD_RELOC_LO16, text);
	  pe_ILF_make_a_symbol_reloc (&vars, (bfd_vma) 4, BFD_RELOC_LO16,
				      (struct bfd_symbol **) imp_sym,
				      imp_index);
	}
      else
#endif
	pe_ILF_make_a_symbol_reloc (&vars, (bfd_vma) jtab[i].offset,
				    BFD_RELOC_32, (asymbol **) imp_sym,
				    imp_index);

      pe_ILF_save_relocs (& vars, text);
      break;

    case IMPORT_DATA:
      break;

    default:
      /* XXX code not yet written.  */
      abort ();
    }

  /* Initialise the bfd.  */
  memset (& internal_f, 0, sizeof (internal_f));

  internal_f.f_magic  = magic;
  internal_f.f_symptr = 0;
  internal_f.f_nsyms  = 0;
  internal_f.f_flags  = F_AR32WR | F_LNNO; /* XXX is this correct ?  */

  if (   ! bfd_set_start_address (abfd, (bfd_vma) 0)
      || ! bfd_coff_set_arch_mach_hook (abfd, & internal_f))
    return FALSE;

  if (bfd_coff_mkobject_hook (abfd, (PTR) & internal_f, NULL) == NULL)
    return FALSE;

  coff_data (abfd)->pe = 1;
#ifdef THUMBPEMAGIC
  if (vars.magic == THUMBPEMAGIC)
    /* Stop some linker warnings about thumb code not supporting interworking.  */
    coff_data (abfd)->flags |= F_INTERWORK | F_INTERWORK_SET;
#endif

  /* Switch from file contents to memory contents.  */
  bfd_cache_close (abfd);

  abfd->iostream = (PTR) vars.bim;
  abfd->flags |= BFD_IN_MEMORY /* | HAS_LOCALS */;
  abfd->where = 0;
  obj_sym_filepos (abfd) = 0;

  /* Now create a symbol describing the imported value.  */
  switch (import_type)
    {
    case IMPORT_CODE:
      pe_ILF_make_a_symbol (& vars, "", symbol_name, text,
			    BSF_NOT_AT_END | BSF_FUNCTION);

      /* Create an import symbol for the DLL, without the
       .dll suffix.  */
      ptr = strrchr (source_dll, '.');
      if (ptr)
	* ptr = 0;
      pe_ILF_make_a_symbol (& vars, "__IMPORT_DESCRIPTOR_", source_dll, NULL, 0);
      if (ptr)
	* ptr = '.';
      break;

    case IMPORT_DATA:
      /* Nothing to do here.  */
      break;

    default:
      /* XXX code not yet written.  */
      abort ();
    }

  /* Point the bfd at the symbol table.  */
  obj_symbols (abfd) = vars.sym_cache;
  bfd_get_symcount (abfd) = vars.sym_index;

  obj_raw_syments (abfd) = vars.native_syms;
  obj_raw_syment_count (abfd) = vars.sym_index;

  obj_coff_external_syms (abfd) = (PTR) vars.esym_table;
  obj_coff_keep_syms (abfd) = TRUE;

  obj_convert (abfd) = vars.sym_table;
  obj_conv_table_size (abfd) = vars.sym_index;

  obj_coff_strings (abfd) = vars.string_table;
  obj_coff_keep_strings (abfd) = TRUE;

  abfd->flags |= HAS_SYMS;

  return TRUE;
}

/* We have detected a Image Library Format archive element.
   Decode the element and return the appropriate target.  */
static const bfd_target *
pe_ILF_object_p (bfd * abfd)
{
  bfd_byte        buffer[16];
  bfd_byte *      ptr;
  bfd_byte *      symbol_name;
  bfd_byte *      source_dll;
  unsigned int    machine;
  bfd_size_type   size;
  unsigned int    ordinal;
  unsigned int    types;
  unsigned int    magic;

  /* Upon entry the first four buyes of the ILF header have
      already been read.  Now read the rest of the header.  */
  if (bfd_bread (buffer, (bfd_size_type) 16, abfd) != 16)
    return NULL;

  ptr = buffer;

  /*  We do not bother to check the version number.
      version = H_GET_16 (abfd, ptr);  */
  ptr += 2;

  machine = H_GET_16 (abfd, ptr);
  ptr += 2;

  /* Check that the machine type is recognised.  */
  magic = 0;

  switch (machine)
    {
    case IMAGE_FILE_MACHINE_UNKNOWN:
    case IMAGE_FILE_MACHINE_ALPHA:
    case IMAGE_FILE_MACHINE_ALPHA64:
    case IMAGE_FILE_MACHINE_IA64:
      break;

    case IMAGE_FILE_MACHINE_I386:
#ifdef I386MAGIC
      magic = I386MAGIC;
#endif
      break;

    case IMAGE_FILE_MACHINE_AMD64:
#ifdef AMD64MAGIC
      magic = AMD64MAGIC;
#endif
      break;

    case IMAGE_FILE_MACHINE_M68K:
#ifdef MC68AGIC
      magic = MC68MAGIC;
#endif
      break;

    case IMAGE_FILE_MACHINE_R3000:
    case IMAGE_FILE_MACHINE_R4000:
    case IMAGE_FILE_MACHINE_R10000:

    case IMAGE_FILE_MACHINE_MIPS16:
    case IMAGE_FILE_MACHINE_MIPSFPU:
    case IMAGE_FILE_MACHINE_MIPSFPU16:
#ifdef MIPS_ARCH_MAGIC_WINCE
      magic = MIPS_ARCH_MAGIC_WINCE;
#endif
      break;

    case IMAGE_FILE_MACHINE_SH3:
    case IMAGE_FILE_MACHINE_SH4:
#ifdef SH_ARCH_MAGIC_WINCE
      magic = SH_ARCH_MAGIC_WINCE;
#endif
      break;

    case IMAGE_FILE_MACHINE_ARM:
#ifdef ARMPEMAGIC
      magic = ARMPEMAGIC;
#endif
      break;

    case IMAGE_FILE_MACHINE_THUMB:
#ifdef THUMBPEMAGIC
      {
	extern const bfd_target TARGET_LITTLE_SYM;

	if (abfd->xvec == & TARGET_LITTLE_SYM)
	  magic = THUMBPEMAGIC;
      }
#endif
      break;

    case IMAGE_FILE_MACHINE_POWERPC:
      /* We no longer support PowerPC.  */
    default:
      _bfd_error_handler
	(
_("%s: Unrecognised machine type (0x%x) in Import Library Format archive"),
         bfd_archive_filename (abfd), machine);
      bfd_set_error (bfd_error_malformed_archive);

      return NULL;
      break;
    }

  if (magic == 0)
    {
      _bfd_error_handler
	(
_("%s: Recognised but unhandled machine type (0x%x) in Import Library Format archive"),
	 bfd_archive_filename (abfd), machine);
      bfd_set_error (bfd_error_wrong_format);

      return NULL;
    }

  /* We do not bother to check the date.
     date = H_GET_32 (abfd, ptr);  */
  ptr += 4;

  size = H_GET_32 (abfd, ptr);
  ptr += 4;

  if (size == 0)
    {
      _bfd_error_handler
	(_("%s: size field is zero in Import Library Format header"),
	 bfd_archive_filename (abfd));
      bfd_set_error (bfd_error_malformed_archive);

      return NULL;
    }

  ordinal = H_GET_16 (abfd, ptr);
  ptr += 2;

  types = H_GET_16 (abfd, ptr);
  /* ptr += 2; */

  /* Now read in the two strings that follow.  */
  ptr = bfd_alloc (abfd, size);
  if (ptr == NULL)
    return NULL;

  if (bfd_bread (ptr, size, abfd) != size)
    {
      bfd_release (abfd, ptr);
      return NULL;
    }

  symbol_name = ptr;
  source_dll  = ptr + strlen (ptr) + 1;

  /* Verify that the strings are null terminated.  */
  if (ptr[size - 1] != 0 || ((unsigned long) (source_dll - ptr) >= size))
    {
      _bfd_error_handler
	(_("%s: string not null terminated in ILF object file."),
	 bfd_archive_filename (abfd));
      bfd_set_error (bfd_error_malformed_archive);
      bfd_release (abfd, ptr);
      return NULL;
    }

  /* Now construct the bfd.  */
  if (! pe_ILF_build_a_bfd (abfd, magic, symbol_name,
			    source_dll, ordinal, types))
    {
      bfd_release (abfd, ptr);
      return NULL;
    }

  return abfd->xvec;
}

static const bfd_target *
pe_bfd_object_p (bfd * abfd)
{
  bfd_byte buffer[4];
  struct external_PEI_DOS_hdr dos_hdr;
  struct external_PEI_IMAGE_hdr image_hdr;
  file_ptr offset;

  /* Detect if this a Microsoft Import Library Format element.  */
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
      || bfd_bread (buffer, (bfd_size_type) 4, abfd) != 4)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  if (H_GET_32 (abfd, buffer) == 0xffff0000)
    return pe_ILF_object_p (abfd);

  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
      || bfd_bread (&dos_hdr, (bfd_size_type) sizeof (dos_hdr), abfd)
	 != sizeof (dos_hdr))
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  /* There are really two magic numbers involved; the magic number
     that says this is a NT executable (PEI) and the magic number that
     determines the architecture.  The former is DOSMAGIC, stored in
     the e_magic field.  The latter is stored in the f_magic field.
     If the NT magic number isn't valid, the architecture magic number
     could be mimicked by some other field (specifically, the number
     of relocs in section 3).  Since this routine can only be called
     correctly for a PEI file, check the e_magic number here, and, if
     it doesn't match, clobber the f_magic number so that we don't get
     a false match.  */
  if (H_GET_16 (abfd, dos_hdr.e_magic) != DOSMAGIC)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  offset = H_GET_32 (abfd, dos_hdr.e_lfanew);
  if (bfd_seek (abfd, offset, SEEK_SET) != 0
      || (bfd_bread (&image_hdr, (bfd_size_type) sizeof (image_hdr), abfd)
	  != sizeof (image_hdr)))
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  if (H_GET_32 (abfd, image_hdr.nt_signature) != 0x4550)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  /* Here is the hack.  coff_object_p wants to read filhsz bytes to
     pick up the COFF header for PE, see "struct external_PEI_filehdr"
     in include/coff/pe.h.  We adjust so that that will work. */
  if (bfd_seek (abfd, (file_ptr) (offset - sizeof (dos_hdr)), SEEK_SET) != 0)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  return coff_object_p (abfd);
}

#define coff_object_p pe_bfd_object_p
#endif /* COFF_IMAGE_WITH_PE */
@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d1147 6
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d138 1
a138 1
static void		  pe_ILF_make_a_symbol_reloc  PARAMS ((pe_ILF_vars *, bfd_vma, bfd_reloc_code_real_type, struct symbol_cache_entry **, unsigned int));
d261 2
a262 2
     or if the physical size is padded, use the virtual size (stored in
     s_paddr) instead.  */
d265 2
a266 2
          && (! bfd_pe_executable_p (abfd) || scnhdr_int->s_size == 0))
          || scnhdr_int->s_size > scnhdr_int->s_paddr))
d473 1
a473 1
			    struct symbol_cache_entry **  sym,
d905 34
a938 4
	/* Skip any prefix in symbol_name.  */
	while (*symbol == '@@' || * symbol == '?' || * symbol == '_')
	  ++ symbol;

d1000 1
a1000 1
				      (struct symbol_cache_entry **) imp_sym,
d1004 1
a1004 1
				      (struct symbol_cache_entry **) imp_sym,
@


1.6
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001
d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d22 1
a22 2
/*
Most of this hacked by  Steve Chamberlain,
d25 2
a26 3
PE/PEI rearrangement (and code added): Donn Terry
                                       Softway Systems, Inc.
*/
d54 1
a54 2
   wasting too much time.
*/
d58 1
a58 1
static boolean (*pe_saved_coff_bfd_print_private_bfd_data)
d67 1
a67 1
static boolean pe_print_private_bfd_data PARAMS ((bfd *, PTR));
d70 1
a70 1
static boolean (*pe_saved_coff_bfd_copy_private_bfd_data)
d79 1
a79 1
static boolean pe_bfd_copy_private_bfd_data PARAMS ((bfd *, bfd *));
d91 1
a91 1
static boolean pe_mkobject PARAMS ((bfd *));
d139 1
a139 1
static boolean            pe_ILF_build_a_bfd      PARAMS ((bfd *, unsigned short, bfd_byte *, bfd_byte *, unsigned int, unsigned int));
d156 2
a157 2
  reloc_dst->r_vaddr = bfd_h_get_32(abfd, (bfd_byte *)reloc_src->r_vaddr);
  reloc_dst->r_symndx = bfd_h_get_signed_32(abfd, (bfd_byte *) reloc_src->r_symndx);
d159 1
a159 1
  reloc_dst->r_type = bfd_h_get_16(abfd, (bfd_byte *) reloc_src->r_type);
d162 1
a162 2
  reloc_dst->r_offset = SWAP_IN_RELOC_OFFSET(abfd,
					     (bfd_byte *) reloc_src->r_offset);
d174 2
a175 2
  bfd_h_put_32(abfd, reloc_src->r_vaddr, (bfd_byte *) reloc_dst->r_vaddr);
  bfd_h_put_32(abfd, reloc_src->r_symndx, (bfd_byte *) reloc_dst->r_symndx);
d177 1
a177 2
  bfd_h_put_16(abfd, reloc_src->r_type, (bfd_byte *)
	       reloc_dst->r_type);
d180 1
a180 3
  SWAP_OUT_RELOC_OFFSET(abfd,
			reloc_src->r_offset,
			(bfd_byte *) reloc_dst->r_offset);
d183 1
a183 1
  SWAP_OUT_RELOC_EXTRA(abfd,reloc_src, reloc_dst);
d197 7
a203 7
  filehdr_dst->f_magic = bfd_h_get_16(abfd, (bfd_byte *) filehdr_src->f_magic);
  filehdr_dst->f_nscns = bfd_h_get_16(abfd, (bfd_byte *)filehdr_src-> f_nscns);
  filehdr_dst->f_timdat = bfd_h_get_32(abfd, (bfd_byte *)filehdr_src-> f_timdat);

  filehdr_dst->f_nsyms = bfd_h_get_32(abfd, (bfd_byte *)filehdr_src-> f_nsyms);
  filehdr_dst->f_flags = bfd_h_get_16(abfd, (bfd_byte *)filehdr_src-> f_flags);
  filehdr_dst->f_symptr = bfd_h_get_32 (abfd, (bfd_byte *) filehdr_src->f_symptr);
d213 1
a213 2
  filehdr_dst->f_opthdr = bfd_h_get_16(abfd,
				       (bfd_byte *)filehdr_src-> f_opthdr);
d232 7
a238 13
  scnhdr_int->s_vaddr =
    GET_SCNHDR_VADDR (abfd, (bfd_byte *) scnhdr_ext->s_vaddr);
  scnhdr_int->s_paddr =
    GET_SCNHDR_PADDR (abfd, (bfd_byte *) scnhdr_ext->s_paddr);
  scnhdr_int->s_size =
    GET_SCNHDR_SIZE (abfd, (bfd_byte *) scnhdr_ext->s_size);
  scnhdr_int->s_scnptr =
    GET_SCNHDR_SCNPTR (abfd, (bfd_byte *) scnhdr_ext->s_scnptr);
  scnhdr_int->s_relptr =
    GET_SCNHDR_RELPTR (abfd, (bfd_byte *) scnhdr_ext->s_relptr);
  scnhdr_int->s_lnnoptr =
    GET_SCNHDR_LNNOPTR (abfd, (bfd_byte *) scnhdr_ext->s_lnnoptr);
  scnhdr_int->s_flags = bfd_h_get_32(abfd, (bfd_byte *) scnhdr_ext->s_flags);
d244 2
a245 3
  scnhdr_int->s_nlnno =
    (bfd_h_get_16 (abfd, (bfd_byte *) scnhdr_ext->s_nlnno)
     + (bfd_h_get_16 (abfd, (bfd_byte *) scnhdr_ext->s_nreloc) << 16));
d248 2
a249 4
  scnhdr_int->s_nreloc = bfd_h_get_16 (abfd,
				       (bfd_byte *) scnhdr_ext->s_nreloc);
  scnhdr_int->s_nlnno = bfd_h_get_16 (abfd,
				      (bfd_byte *) scnhdr_ext->s_nlnno);
d259 8
a266 3
  /* If this section holds uninitialized data, use the virtual size
     (stored in s_paddr) instead of the physical size.  */
  if ((scnhdr_int->s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) != 0)
d269 1
d278 1
a278 1
static boolean
d283 3
a285 2
  abfd->tdata.pe_obj_data =
    (struct pe_tdata *) bfd_zalloc (abfd, sizeof (pe_data_type));
d288 1
a288 1
    return false;
d304 1
a304 1
  return true;
d317 1
a317 1
  if (pe_mkobject (abfd) == false)
d360 1
a360 1
static boolean
d368 1
a368 1
    return false;
d377 1
a377 1
  return true;
d383 1
a383 1
static boolean
d388 1
a388 1
    return false;
d393 1
a393 1
  return true;
d523 1
a523 1
  coff_section_data (vars->abfd, sec)->keep_relocs = true;
d533 1
a533 1
  BFD_ASSERT ((bfd_byte *)vars->int_reltab < (bfd_byte *)vars->string_table);
d579 3
a581 2
  bfd_h_put_32 (vars->abfd, vars->string_ptr - vars->string_table, (bfd_byte *) esym->e.e.e_offset);
  bfd_h_put_16 (vars->abfd, section->target_index, (bfd_byte *) esym->e_scnum);
d615 1
a615 1
  sym->done_lineno    = false;
d659 1
a659 1
  bfd_set_section_size (vars->abfd, sec, size);
d758 1
a758 1
static boolean
d760 1
a760 1
		    unsigned short  magic,
d788 2
a789 2
			  bfd_get_filename (abfd), import_type);
      return false;
d793 2
a794 2
			  bfd_get_filename (abfd), import_type);
      return false;
d807 2
a808 2
			  bfd_get_filename (abfd), import_name_type);
      return false;
d818 1
a818 1
  ptr = bfd_zalloc (abfd, ILF_DATA_SIZE);
d820 1
a820 1
    return false;
d880 1
a880 1
    return false;
d899 1
a899 1
	return false;
d926 2
a927 2
      pe_ILF_make_a_reloc (& vars, 0, BFD_RELOC_RVA, id6);
      pe_ILF_save_relocs (& vars, id4);
d929 2
a930 2
      pe_ILF_make_a_reloc (& vars, 0, BFD_RELOC_RVA, id6);
      pe_ILF_save_relocs (& vars, id5);
d955 1
a955 1
	return false;
d969 7
a975 5
	  pe_ILF_make_a_symbol_reloc (& vars, 0, BFD_RELOC_HI16_S,
				      (struct symbol_cache_entry **) imp_sym, imp_index);
	  pe_ILF_make_a_reloc (& vars, 0, BFD_RELOC_LO16, text);
	  pe_ILF_make_a_symbol_reloc (& vars, 4, BFD_RELOC_LO16,
				      (struct symbol_cache_entry **) imp_sym, imp_index);
d979 3
a981 2
	pe_ILF_make_a_symbol_reloc (& vars, jtab[i].offset, BFD_RELOC_32,
				    (asymbol **) imp_sym, imp_index);
d1002 1
a1002 1
  if (   ! bfd_set_start_address (abfd, 0)
d1004 1
a1004 1
    return false;
d1007 1
a1007 1
    return false;
a1026 2
      bfd_byte * ptr;

d1058 1
a1058 1
  obj_coff_keep_syms (abfd) = true;
d1064 1
a1064 1
  obj_coff_keep_strings (abfd) = true;
d1068 1
a1068 1
  return true;
d1081 1
a1081 1
  unsigned long   size;
d1084 1
a1084 1
  unsigned short  magic;
d1088 1
a1088 1
  if (bfd_read (buffer, 1, 16, abfd) != 16)
d1094 1
a1094 1
      version = bfd_h_get_16 (abfd, ptr);  */
d1097 1
a1097 1
  machine = bfd_h_get_16 (abfd, ptr);
d1165 1
a1165 1
         bfd_get_filename (abfd), machine);
d1177 1
a1177 1
	 bfd_get_filename (abfd), machine);
d1184 1
a1184 1
     date = bfd_h_get_32 (abfd, ptr);  */
d1187 1
a1187 1
  size = bfd_h_get_32 (abfd, ptr);
d1194 1
a1194 1
	 bfd_get_filename (abfd));
d1200 1
a1200 1
  ordinal = bfd_h_get_16 (abfd, ptr);
d1203 1
a1203 1
  types = bfd_h_get_16 (abfd, ptr);
d1211 5
a1215 2
  if (bfd_read (ptr, 1, size, abfd) != size)
    return NULL;
d1225 1
a1225 1
	 bfd_get_filename (abfd));
d1227 1
a1227 1

d1234 4
a1237 1
    return NULL;
d1251 2
a1252 2
  if (bfd_seek (abfd, 0x00, SEEK_SET) != 0
      || bfd_read (buffer, 1, 4, abfd) != 4)
d1259 1
a1259 1
  if (bfd_h_get_32 (abfd, buffer) == 0xffff0000)
d1262 2
a1263 2
  if (bfd_seek (abfd, 0x00, SEEK_SET) != 0
      || bfd_read (&dos_hdr, 1, sizeof (dos_hdr), abfd)
d1281 1
a1281 1
  if (bfd_h_get_16 (abfd, (bfd_byte *) dos_hdr.e_magic) != DOSMAGIC)
d1287 4
a1290 4
  offset = bfd_h_get_32 (abfd, (bfd_byte *) dos_hdr.e_lfanew);
  if (bfd_seek (abfd, (file_ptr) offset, SEEK_SET) != 0
      || bfd_read (&image_hdr, 1, sizeof (image_hdr), abfd)
	 != sizeof (image_hdr))
d1297 1
a1297 2
  if (bfd_h_get_32 (abfd, (bfd_byte *) image_hdr.nt_signature)
      != 0x4550)
d1306 1
a1306 4
  if (bfd_seek (abfd,
		(file_ptr) (offset - sizeof (dos_hdr)),
		SEEK_SET)
      != 0)
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
a72 1

d107 1
a107 1
  
d114 1
a114 1
  
d117 1
a117 1
  
d123 1
a123 1
  
d129 1
a129 1
  
d141 1
a141 1
static void		  pe_ILF_make_a_symbol_reloc  PARAMS ((pe_ILF_vars *, bfd_vma, bfd_reloc_code_real_type,	   struct symbol_cache_entry **, unsigned int));
a169 1

a211 15
#ifdef COFF_IMAGE_WITH_PE
  /* There are really two magic numbers involved; the magic number
     that says this is a NT executable (PEI) and the magic number that
     determines the architecture.  The former is DOSMAGIC, stored in
     the e_magic field.  The latter is stored in the f_magic field.
     If the NT magic number isn't valid, the architecture magic number
     could be mimicked by some other field (specifically, the number
     of relocs in section 3).  Since this routine can only be called
     correctly for a PEI file, check the e_magic number here, and, if
     it doesn't match, clobber the f_magic number so that we don't get
     a false match.  */
  if (bfd_h_get_16 (abfd, (bfd_byte *) filehdr_src->e_magic) != DOSMAGIC)
    filehdr_dst->f_magic = -1;
#endif

d220 1
a220 1
  filehdr_dst->f_opthdr = bfd_h_get_16(abfd, 
d225 1
a225 1
#define coff_swap_filehdr_out _bfd_pei_only_swap_filehdr_out
d227 1
a227 1
#define coff_swap_filehdr_out _bfd_pe_only_swap_filehdr_out
a229 1

d239 1
a239 1
  memcpy(scnhdr_int->s_name, scnhdr_ext->s_name, sizeof(scnhdr_int->s_name));
d269 1
a269 1
  if (scnhdr_int->s_vaddr != 0) 
d294 1
a294 1
  abfd->tdata.pe_obj_data = 
d306 8
d358 1
a358 1
  if (aouthdr) 
d362 1
a362 1
#ifdef ARM 
d366 1
a366 1
  
d377 1
a377 1
  if (!_bfd_pe_print_private_bfd_data_common (abfd, vfile))
d397 1
a397 1
  if (!_bfd_pe_bfd_copy_private_bfd_data_common (ibfd, obfd))
d407 1
a407 1
  _bfd_pe_bfd_copy_private_section_data
d409 1
a409 1
#define coff_get_symbol_info _bfd_pe_get_symbol_info
d415 1
a415 1
   Documentation about this format can be found at: 
d441 1
a441 1
  
d459 1
a459 1
  
a477 1

d491 1
a491 1
  
d505 1
a505 1
  
d507 1
a507 1
  
d563 2
a564 2
  
#ifdef THUMBPEMAGIC  
d577 1
a577 1
  
d587 1
a587 1
  
d601 1
a601 1
  
d606 1
a606 1
  
d614 1
a614 1
  
d620 1
a620 1
  
d627 1
a627 1
  
d630 1
a630 1
  
d652 1
a652 1
  
d656 1
a656 1
  
d658 1
a658 1
  
d660 1
a660 1
     
d662 1
a662 1
  
d665 1
a665 1
  
d674 1
a674 1
  
d681 1
a681 1
  
d687 1
a687 1
  
d693 1
a693 1
  
d724 1
a724 1
  
d735 1
a735 1
  
d743 1
a743 1
  
d751 1
a751 1
  
d774 1
a774 1
{ 
d793 1
a793 1
      
d799 1
a799 1
      
d813 1
a813 1
      
d821 1
a821 1
     
d824 1
a824 1
     
d836 1
a836 1
  
d843 1
a843 1
  
d855 1
a855 1
  
d859 1
a859 1
  
d871 1
a871 1
  
d878 1
a878 1
  
d890 1
a890 1
  
d897 3
a899 3
      
      * (unsigned int *) id4->contents = ordinal | 0x80000000UL;
      * (unsigned int *) id5->contents = ordinal | 0x80000000UL;
d904 1
a904 1
      
d926 1
a926 1
      
d929 1
a929 1
      
d937 1
a937 1
      
d946 1
a946 1
      
d973 1
a973 1
    
d975 1
a975 1
#ifdef MIPS_ARCH_MAGIC_WINCE      
d979 1
a979 1
				      (asection **) imp_sym, imp_index);
d982 1
a982 1
				      (asection **) imp_sym, imp_index);
d988 1
a988 1
      
d999 1
a999 1
  
d1002 1
a1002 1
  
d1007 1
a1007 1
  
d1016 1
a1016 1
#ifdef THUMBPEMAGIC  
d1021 1
a1021 1
    
d1034 1
a1034 1
      
d1038 1
a1038 1
      
d1052 1
a1052 1
      
d1061 1
a1061 1
  
d1067 1
a1067 1
  
d1070 1
a1070 1
  
d1093 1
a1093 1
  
d1100 1
a1100 1
  
d1110 1
a1110 1
  
d1118 1
a1118 1
      
d1124 1
a1124 1
      
d1130 1
a1130 1
      
d1134 1
a1134 1
      
d1142 1
a1142 1
      
d1149 1
a1149 1
      
d1153 1
a1153 1
#endif      
d1155 1
a1155 1
      
d1159 3
a1161 3
	extern bfd_target armpei_little_vec;
	
	if (abfd->xvec == & armpei_little_vec)
d1164 1
a1164 1
#endif      
d1166 1
a1166 1
      
d1175 1
a1175 1
	
d1187 1
a1187 1
	
d1189 1
a1189 1
    }  
d1194 1
a1194 1
  
d1204 1
a1204 1
	
d1218 1
a1218 1
  
d1224 1
a1224 1
  
d1232 1
a1232 1
	
d1235 1
a1235 1
  
d1240 1
a1240 1
  
a1246 7
  /* We need to handle a PE image correctly.  In PE images created by
     the GNU linker, the offset to the COFF header is always the size.
     However, this is not the case in images generated by other PE
     linkers.  The PE format stores a four byte offset to the PE
     signature just before the COFF header at location 0x3c of the file.
     We pick up that offset, verify that the PE signature is there, and
     then set ourselves up to read in the COFF header.  */
d1248 2
a1250 1
  unsigned long signature;
d1260 2
a1261 4
  
  signature = bfd_h_get_32 (abfd, buffer);
  
  if (signature == 0xffff0000)
d1263 4
a1266 3
  
  if (bfd_seek (abfd, 0x3c, SEEK_SET) != 0
      || bfd_read (buffer, 1, 4, abfd) != 4)
d1273 15
a1287 1
  offset = bfd_h_get_32 (abfd, buffer);
d1289 4
a1292 2
  if (bfd_seek (abfd, offset, SEEK_SET) != 0
      || bfd_read (buffer, 1, 4, abfd) != 4)
d1299 2
a1300 3
  signature = bfd_h_get_32 (abfd, buffer);

  if (signature != 0x4550)
d1305 1
a1305 1
  
d1307 2
a1308 2
     pick up the COFF header.  We adjust so that that will work.  20
     is the size of the i386 COFF filehdr.  */
d1310 1
a1310 3
		(bfd_tell (abfd)
		 - bfd_coff_filhsz (abfd)
		 + 20),
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d1 3
a3 3
/* Support for the generic parts of most COFF variants, for BFD.
   Copyright 1995, 1996 Free Software Foundation, Inc.
   Written by Cygnus Support.
d24 3
d58 12
d71 15
a85 1
#define coff_mkobject pe_mkobject
d88 8
a95 4
#ifndef GET_FCN_LNNOPTR
#define GET_FCN_LNNOPTR(abfd, ext) \
     bfd_h_get_32(abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_lnnoptr)
#endif
d97 3
a99 4
#ifndef GET_FCN_ENDNDX
#define GET_FCN_ENDNDX(abfd, ext)  \
	bfd_h_get_32(abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_endndx)
#endif
d101 9
a109 42
#ifndef PUT_FCN_LNNOPTR
#define PUT_FCN_LNNOPTR(abfd, in, ext)  bfd_h_put_32(abfd,  in, (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_lnnoptr)
#endif
#ifndef PUT_FCN_ENDNDX
#define PUT_FCN_ENDNDX(abfd, in, ext) bfd_h_put_32(abfd, in, (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_endndx)
#endif
#ifndef GET_LNSZ_LNNO
#define GET_LNSZ_LNNO(abfd, ext) bfd_h_get_16(abfd, (bfd_byte *) ext->x_sym.x_misc.x_lnsz.x_lnno)
#endif
#ifndef GET_LNSZ_SIZE
#define GET_LNSZ_SIZE(abfd, ext) bfd_h_get_16(abfd, (bfd_byte *) ext->x_sym.x_misc.x_lnsz.x_size)
#endif
#ifndef PUT_LNSZ_LNNO
#define PUT_LNSZ_LNNO(abfd, in, ext) bfd_h_put_16(abfd, in, (bfd_byte *)ext->x_sym.x_misc.x_lnsz.x_lnno)
#endif
#ifndef PUT_LNSZ_SIZE
#define PUT_LNSZ_SIZE(abfd, in, ext) bfd_h_put_16(abfd, in, (bfd_byte*) ext->x_sym.x_misc.x_lnsz.x_size)
#endif
#ifndef GET_SCN_SCNLEN
#define GET_SCN_SCNLEN(abfd,  ext) bfd_h_get_32(abfd, (bfd_byte *) ext->x_scn.x_scnlen)
#endif
#ifndef GET_SCN_NRELOC
#define GET_SCN_NRELOC(abfd,  ext) bfd_h_get_16(abfd, (bfd_byte *)ext->x_scn.x_nreloc)
#endif
#ifndef GET_SCN_NLINNO
#define GET_SCN_NLINNO(abfd, ext)  bfd_h_get_16(abfd, (bfd_byte *)ext->x_scn.x_nlinno)
#endif
#ifndef PUT_SCN_SCNLEN
#define PUT_SCN_SCNLEN(abfd,in, ext) bfd_h_put_32(abfd, in, (bfd_byte *) ext->x_scn.x_scnlen)
#endif
#ifndef PUT_SCN_NRELOC
#define PUT_SCN_NRELOC(abfd,in, ext) bfd_h_put_16(abfd, in, (bfd_byte *)ext->x_scn.x_nreloc)
#endif
#ifndef PUT_SCN_NLINNO
#define PUT_SCN_NLINNO(abfd,in, ext)  bfd_h_put_16(abfd,in, (bfd_byte  *) ext->x_scn.x_nlinno)
#endif
#ifndef GET_LINENO_LNNO
#define GET_LINENO_LNNO(abfd, ext) bfd_h_get_16(abfd, (bfd_byte *) (ext->l_lnno));
#endif
#ifndef PUT_LINENO_LNNO
#define PUT_LINENO_LNNO(abfd,val, ext) bfd_h_put_16(abfd,val,  (bfd_byte *) (ext->l_lnno));
#endif
d111 9
a119 7
/* The f_symptr field in the filehdr is sometimes 64 bits.  */
#ifndef GET_FILEHDR_SYMPTR
#define GET_FILEHDR_SYMPTR bfd_h_get_32
#endif
#ifndef PUT_FILEHDR_SYMPTR
#define PUT_FILEHDR_SYMPTR bfd_h_put_32
#endif
d121 4
a124 37
/* Some fields in the aouthdr are sometimes 64 bits.  */
#ifndef GET_AOUTHDR_TSIZE
#define GET_AOUTHDR_TSIZE bfd_h_get_32
#endif
#ifndef PUT_AOUTHDR_TSIZE
#define PUT_AOUTHDR_TSIZE bfd_h_put_32
#endif
#ifndef GET_AOUTHDR_DSIZE
#define GET_AOUTHDR_DSIZE bfd_h_get_32
#endif
#ifndef PUT_AOUTHDR_DSIZE
#define PUT_AOUTHDR_DSIZE bfd_h_put_32
#endif
#ifndef GET_AOUTHDR_BSIZE
#define GET_AOUTHDR_BSIZE bfd_h_get_32
#endif
#ifndef PUT_AOUTHDR_BSIZE
#define PUT_AOUTHDR_BSIZE bfd_h_put_32
#endif
#ifndef GET_AOUTHDR_ENTRY
#define GET_AOUTHDR_ENTRY bfd_h_get_32
#endif
#ifndef PUT_AOUTHDR_ENTRY
#define PUT_AOUTHDR_ENTRY bfd_h_put_32
#endif
#ifndef GET_AOUTHDR_TEXT_START
#define GET_AOUTHDR_TEXT_START bfd_h_get_32
#endif
#ifndef PUT_AOUTHDR_TEXT_START
#define PUT_AOUTHDR_TEXT_START bfd_h_put_32
#endif
#ifndef GET_AOUTHDR_DATA_START
#define GET_AOUTHDR_DATA_START bfd_h_get_32
#endif
#ifndef PUT_AOUTHDR_DATA_START
#define PUT_AOUTHDR_DATA_START bfd_h_put_32
#endif
d126 6
a131 37
/* Some fields in the scnhdr are sometimes 64 bits.  */
#ifndef GET_SCNHDR_PADDR
#define GET_SCNHDR_PADDR bfd_h_get_32
#endif
#ifndef PUT_SCNHDR_PADDR
#define PUT_SCNHDR_PADDR bfd_h_put_32
#endif
#ifndef GET_SCNHDR_VADDR
#define GET_SCNHDR_VADDR bfd_h_get_32
#endif
#ifndef PUT_SCNHDR_VADDR
#define PUT_SCNHDR_VADDR bfd_h_put_32
#endif
#ifndef GET_SCNHDR_SIZE
#define GET_SCNHDR_SIZE bfd_h_get_32
#endif
#ifndef PUT_SCNHDR_SIZE
#define PUT_SCNHDR_SIZE bfd_h_put_32
#endif
#ifndef GET_SCNHDR_SCNPTR
#define GET_SCNHDR_SCNPTR bfd_h_get_32
#endif
#ifndef PUT_SCNHDR_SCNPTR
#define PUT_SCNHDR_SCNPTR bfd_h_put_32
#endif
#ifndef GET_SCNHDR_RELPTR
#define GET_SCNHDR_RELPTR bfd_h_get_32
#endif
#ifndef PUT_SCNHDR_RELPTR
#define PUT_SCNHDR_RELPTR bfd_h_put_32
#endif
#ifndef GET_SCNHDR_LNNOPTR
#define GET_SCNHDR_LNNOPTR bfd_h_get_32
#endif
#ifndef PUT_SCNHDR_LNNOPTR
#define PUT_SCNHDR_LNNOPTR bfd_h_put_32
#endif
d133 3
d137 9
d149 1
d195 1
a195 1

d213 18
a230 7
  /* Other people's tools sometimes generate headers
     with an nsyms but a zero symptr. */
  if (filehdr_dst->f_nsyms && filehdr_dst->f_symptr)
    {
      filehdr_dst->f_flags |= HAS_SYMS;
    }
  else 
d233 1
a233 1
      filehdr_dst->f_flags &= ~HAS_SYMS;
d241 1
a241 128

static  unsigned int
coff_swap_filehdr_out (abfd, in, out)
     bfd       *abfd;
     PTR	in;
     PTR	out;
{
  int idx;
  struct internal_filehdr *filehdr_in = (struct internal_filehdr *)in;
  FILHDR *filehdr_out = (FILHDR *)out;

  if (pe_data (abfd)->has_reloc_section)
    filehdr_in->f_flags &= ~F_RELFLG;

  if (pe_data (abfd)->dll)
    filehdr_in->f_flags |= F_DLL;

  filehdr_in->pe.e_magic    = DOSMAGIC;
  filehdr_in->pe.e_cblp     = 0x90;
  filehdr_in->pe.e_cp       = 0x3;
  filehdr_in->pe.e_crlc     = 0x0;
  filehdr_in->pe.e_cparhdr  = 0x4;
  filehdr_in->pe.e_minalloc = 0x0;
  filehdr_in->pe.e_maxalloc = 0xffff;
  filehdr_in->pe.e_ss       = 0x0;
  filehdr_in->pe.e_sp       = 0xb8;
  filehdr_in->pe.e_csum     = 0x0;
  filehdr_in->pe.e_ip       = 0x0;
  filehdr_in->pe.e_cs       = 0x0;
  filehdr_in->pe.e_lfarlc   = 0x40;
  filehdr_in->pe.e_ovno     = 0x0;

  for (idx=0; idx < 4; idx++)
    filehdr_in->pe.e_res[idx] = 0x0;

  filehdr_in->pe.e_oemid   = 0x0;
  filehdr_in->pe.e_oeminfo = 0x0;

  for (idx=0; idx < 10; idx++)
    filehdr_in->pe.e_res2[idx] = 0x0;

  filehdr_in->pe.e_lfanew = 0x80;

  /* this next collection of data are mostly just characters.  It appears
     to be constant within the headers put on NT exes */
  filehdr_in->pe.dos_message[0]  = 0x0eba1f0e;
  filehdr_in->pe.dos_message[1]  = 0xcd09b400;
  filehdr_in->pe.dos_message[2]  = 0x4c01b821;
  filehdr_in->pe.dos_message[3]  = 0x685421cd;
  filehdr_in->pe.dos_message[4]  = 0x70207369;
  filehdr_in->pe.dos_message[5]  = 0x72676f72;
  filehdr_in->pe.dos_message[6]  = 0x63206d61;
  filehdr_in->pe.dos_message[7]  = 0x6f6e6e61;
  filehdr_in->pe.dos_message[8]  = 0x65622074;
  filehdr_in->pe.dos_message[9]  = 0x6e757220;
  filehdr_in->pe.dos_message[10] = 0x206e6920;
  filehdr_in->pe.dos_message[11] = 0x20534f44;
  filehdr_in->pe.dos_message[12] = 0x65646f6d;
  filehdr_in->pe.dos_message[13] = 0x0a0d0d2e;
  filehdr_in->pe.dos_message[14] = 0x24;
  filehdr_in->pe.dos_message[15] = 0x0;
  filehdr_in->pe.nt_signature = NT_SIGNATURE;



  bfd_h_put_16(abfd, filehdr_in->f_magic, (bfd_byte *) filehdr_out->f_magic);
  bfd_h_put_16(abfd, filehdr_in->f_nscns, (bfd_byte *) filehdr_out->f_nscns);

  bfd_h_put_32(abfd, time (0), (bfd_byte *) filehdr_out->f_timdat);
  PUT_FILEHDR_SYMPTR (abfd, (bfd_vma) filehdr_in->f_symptr,
		      (bfd_byte *) filehdr_out->f_symptr);
  bfd_h_put_32(abfd, filehdr_in->f_nsyms, (bfd_byte *) filehdr_out->f_nsyms);
  bfd_h_put_16(abfd, filehdr_in->f_opthdr, (bfd_byte *) filehdr_out->f_opthdr);
  bfd_h_put_16(abfd, filehdr_in->f_flags, (bfd_byte *) filehdr_out->f_flags);

  /* put in extra dos header stuff.  This data remains essentially
     constant, it just has to be tacked on to the beginning of all exes 
     for NT */
  bfd_h_put_16(abfd, filehdr_in->pe.e_magic, (bfd_byte *) filehdr_out->e_magic);
  bfd_h_put_16(abfd, filehdr_in->pe.e_cblp, (bfd_byte *) filehdr_out->e_cblp);
  bfd_h_put_16(abfd, filehdr_in->pe.e_cp, (bfd_byte *) filehdr_out->e_cp);
  bfd_h_put_16(abfd, filehdr_in->pe.e_crlc, (bfd_byte *) filehdr_out->e_crlc);
  bfd_h_put_16(abfd, filehdr_in->pe.e_cparhdr, 
	       (bfd_byte *) filehdr_out->e_cparhdr);
  bfd_h_put_16(abfd, filehdr_in->pe.e_minalloc, 
	       (bfd_byte *) filehdr_out->e_minalloc);
  bfd_h_put_16(abfd, filehdr_in->pe.e_maxalloc, 
	       (bfd_byte *) filehdr_out->e_maxalloc);
  bfd_h_put_16(abfd, filehdr_in->pe.e_ss, (bfd_byte *) filehdr_out->e_ss);
  bfd_h_put_16(abfd, filehdr_in->pe.e_sp, (bfd_byte *) filehdr_out->e_sp);
  bfd_h_put_16(abfd, filehdr_in->pe.e_csum, (bfd_byte *) filehdr_out->e_csum);
  bfd_h_put_16(abfd, filehdr_in->pe.e_ip, (bfd_byte *) filehdr_out->e_ip);
  bfd_h_put_16(abfd, filehdr_in->pe.e_cs, (bfd_byte *) filehdr_out->e_cs);
  bfd_h_put_16(abfd, filehdr_in->pe.e_lfarlc, (bfd_byte *) filehdr_out->e_lfarlc);
  bfd_h_put_16(abfd, filehdr_in->pe.e_ovno, (bfd_byte *) filehdr_out->e_ovno);
  {
    int idx;
    for (idx=0; idx < 4; idx++)
      bfd_h_put_16(abfd, filehdr_in->pe.e_res[idx], 
		   (bfd_byte *) filehdr_out->e_res[idx]);
  }
  bfd_h_put_16(abfd, filehdr_in->pe.e_oemid, (bfd_byte *) filehdr_out->e_oemid);
  bfd_h_put_16(abfd, filehdr_in->pe.e_oeminfo,
	       (bfd_byte *) filehdr_out->e_oeminfo);
  {
    int idx;
    for (idx=0; idx < 10; idx++)
      bfd_h_put_16(abfd, filehdr_in->pe.e_res2[idx],
		   (bfd_byte *) filehdr_out->e_res2[idx]);
  }
  bfd_h_put_32(abfd, filehdr_in->pe.e_lfanew, (bfd_byte *) filehdr_out->e_lfanew);

  {
    int idx;
    for (idx=0; idx < 16; idx++)
      bfd_h_put_32(abfd, filehdr_in->pe.dos_message[idx],
		   (bfd_byte *) filehdr_out->dos_message[idx]);
  }

  /* also put in the NT signature */
  bfd_h_put_32(abfd, filehdr_in->pe.nt_signature, 
	       (bfd_byte *) filehdr_out->nt_signature);




  return FILHSZ;
}
d243 1
a243 22

static  unsigned int
coff_swap_filehdr_out (abfd, in, out)
     bfd       *abfd;
     PTR	in;
     PTR	out;
{
  struct internal_filehdr *filehdr_in = (struct internal_filehdr *)in;
  FILHDR *filehdr_out = (FILHDR *)out;

  bfd_h_put_16(abfd, filehdr_in->f_magic, (bfd_byte *) filehdr_out->f_magic);
  bfd_h_put_16(abfd, filehdr_in->f_nscns, (bfd_byte *) filehdr_out->f_nscns);
  bfd_h_put_32(abfd, filehdr_in->f_timdat, (bfd_byte *) filehdr_out->f_timdat);
  PUT_FILEHDR_SYMPTR (abfd, (bfd_vma) filehdr_in->f_symptr,
		      (bfd_byte *) filehdr_out->f_symptr);
  bfd_h_put_32(abfd, filehdr_in->f_nsyms, (bfd_byte *) filehdr_out->f_nsyms);
  bfd_h_put_16(abfd, filehdr_in->f_opthdr, (bfd_byte *) filehdr_out->f_opthdr);
  bfd_h_put_16(abfd, filehdr_in->f_flags, (bfd_byte *) filehdr_out->f_flags);

  return FILHSZ;
}

d248 1
a248 1
coff_swap_sym_in (abfd, ext1, in1)
d250 2
a251 2
     PTR ext1;
     PTR in1;
d253 17
a269 2
  SYMENT *ext = (SYMENT *)ext1;
  struct internal_syment      *in = (struct internal_syment *)in1;
d271 8
a278 7
  if( ext->e.e_name[0] == 0) {
    in->_n._n_n._n_zeroes = 0;
    in->_n._n_n._n_offset = bfd_h_get_32(abfd, (bfd_byte *) ext->e.e.e_offset);
  }
  else {
#if SYMNMLEN != E_SYMNMLEN
    -> Error, we need to cope with truncating or extending SYMNMLEN!;
d280 4
a283 1
    memcpy(in->_n._n_name, ext->e.e_name, SYMNMLEN);
a284 1
  }
d286 5
a290 29
  in->n_value = bfd_h_get_32(abfd, (bfd_byte *) ext->e_value); 
  in->n_scnum = bfd_h_get_16(abfd, (bfd_byte *) ext->e_scnum);
  if (sizeof(ext->e_type) == 2){
    in->n_type = bfd_h_get_16(abfd, (bfd_byte *) ext->e_type);
  }
  else {
    in->n_type = bfd_h_get_32(abfd, (bfd_byte *) ext->e_type);
  }
  in->n_sclass = bfd_h_get_8(abfd, ext->e_sclass);
  in->n_numaux = bfd_h_get_8(abfd, ext->e_numaux);

  /* The section symbols for the .idata$ sections have class 68, which MS
     documentation indicates is a section symbol.  The problem is that the
     value field in the symbol is simply a copy of the .idata section's flags
     rather than something useful.  When these symbols are encountered, change
     the value to 0 and the section number to 1 so that they will be handled
     somewhat correctly in the bfd code. */
  if (in->n_sclass == 0x68) {
    in->n_value = 0x0;
    in->n_scnum = 1;
    /* I have tried setting the class to 3 and using the following to set
       the section number.  This will put the address of the pointer to the
       string kernel32.dll at addresses 0 and 0x10 off start of idata section
       which is not correct */
    /*    if (strcmp (in->_n._n_name, ".idata$4") == 0) */
    /*      in->n_scnum = 3; */
    /*    else */
    /*      in->n_scnum = 2; */
  }
d292 11
a302 2
#ifdef coff_swap_sym_in_hook
  coff_swap_sym_in_hook(abfd, ext1, in1);
d306 3
a308 5
static unsigned int
coff_swap_sym_out (abfd, inp, extp)
     bfd       *abfd;
     PTR	inp;
     PTR	extp;
d310 8
a317 13
  struct internal_syment *in = (struct internal_syment *)inp;
  SYMENT *ext =(SYMENT *)extp;
  if(in->_n._n_name[0] == 0) {
    bfd_h_put_32(abfd, 0, (bfd_byte *) ext->e.e.e_zeroes);
    bfd_h_put_32(abfd, in->_n._n_n._n_offset, (bfd_byte *)  ext->e.e.e_offset);
  }
  else {
#if SYMNMLEN != E_SYMNMLEN
    -> Error, we need to cope with truncating or extending SYMNMLEN!;
#else
    memcpy(ext->e.e_name, in->_n._n_name, SYMNMLEN);
#endif
  }
d319 1
a319 12
  bfd_h_put_32(abfd,  in->n_value , (bfd_byte *) ext->e_value);
  bfd_h_put_16(abfd,  in->n_scnum , (bfd_byte *) ext->e_scnum);
  if (sizeof(ext->e_type) == 2)
    {
      bfd_h_put_16(abfd,  in->n_type , (bfd_byte *) ext->e_type);
    }
  else
    {
      bfd_h_put_32(abfd,  in->n_type , (bfd_byte *) ext->e_type);
    }
  bfd_h_put_8(abfd,  in->n_sclass , ext->e_sclass);
  bfd_h_put_8(abfd,  in->n_numaux , ext->e_numaux);
d321 3
a323 1
  return SYMESZ;
d326 6
a331 9
static void
coff_swap_aux_in (abfd, ext1, type, class, indx, numaux, in1)
     bfd            *abfd;
     PTR 	      ext1;
     int             type;
     int             class;
     int	      indx;
     int	      numaux;
     PTR 	      in1;
d333 2
a334 2
  AUXENT    *ext = (AUXENT *)ext1;
  union internal_auxent *in = (union internal_auxent *)in1;
d336 2
a337 14
  switch (class) {
  case C_FILE:
    if (ext->x_file.x_fname[0] == 0) {
      in->x_file.x_n.x_zeroes = 0;
      in->x_file.x_n.x_offset = 
	bfd_h_get_32(abfd, (bfd_byte *) ext->x_file.x_n.x_offset);
    } else {
#if FILNMLEN != E_FILNMLEN
      -> Error, we need to cope with truncating or extending FILNMLEN!;
#else
      memcpy (in->x_file.x_fname, ext->x_file.x_fname, FILNMLEN);
#endif
    }
    return;
d339 12
d352 1
a352 19
  case C_STAT:
#ifdef C_LEAFSTAT
  case C_LEAFSTAT:
#endif
  case C_HIDDEN:
    if (type == T_NULL) {
      in->x_scn.x_scnlen = GET_SCN_SCNLEN(abfd, ext);
      in->x_scn.x_nreloc = GET_SCN_NRELOC(abfd, ext);
      in->x_scn.x_nlinno = GET_SCN_NLINNO(abfd, ext);
      in->x_scn.x_checksum = bfd_h_get_32 (abfd,
					   (bfd_byte *) ext->x_scn.x_checksum);
      in->x_scn.x_associated =
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_scn.x_associated);
      in->x_scn.x_comdat = bfd_h_get_8 (abfd,
					(bfd_byte *) ext->x_scn.x_comdat);
      return;
    }
    break;
  }
d354 3
a356 4
  in->x_sym.x_tagndx.l = bfd_h_get_32(abfd, (bfd_byte *) ext->x_sym.x_tagndx);
#ifndef NO_TVNDX
  in->x_sym.x_tvndx = bfd_h_get_16(abfd, (bfd_byte *) ext->x_sym.x_tvndx);
#endif
d358 1
a358 19
  if (class == C_BLOCK || class == C_FCN || ISFCN (type) || ISTAG (class))
    {
      in->x_sym.x_fcnary.x_fcn.x_lnnoptr = GET_FCN_LNNOPTR (abfd, ext);
      in->x_sym.x_fcnary.x_fcn.x_endndx.l = GET_FCN_ENDNDX (abfd, ext);
    }
  else
    {
#if DIMNUM != E_DIMNUM
 #error we need to cope with truncating or extending DIMNUM
#endif
      in->x_sym.x_fcnary.x_ary.x_dimen[0] =
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
      in->x_sym.x_fcnary.x_ary.x_dimen[1] =
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
      in->x_sym.x_fcnary.x_ary.x_dimen[2] =
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
      in->x_sym.x_fcnary.x_ary.x_dimen[3] =
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
    }
d360 2
a361 8
  if (ISFCN(type)) {
    in->x_sym.x_misc.x_fsize = bfd_h_get_32(abfd, (bfd_byte *) ext->x_sym.x_misc.x_fsize);
  }
  else {
    in->x_sym.x_misc.x_lnsz.x_lnno = GET_LNSZ_LNNO(abfd, ext);
    in->x_sym.x_misc.x_lnsz.x_size = GET_LNSZ_SIZE(abfd, ext);
  }
}
d363 2
a364 12
static unsigned int
coff_swap_aux_out (abfd, inp, type, class, indx, numaux, extp)
     bfd   *abfd;
     PTR 	inp;
     int   type;
     int   class;
     int   indx;
     int   numaux;
     PTR	extp;
{
  union internal_auxent *in = (union internal_auxent *)inp;
  AUXENT *ext = (AUXENT *)extp;
d366 3
a368 14
  memset((PTR)ext, 0, AUXESZ);
  switch (class) {
  case C_FILE:
    if (in->x_file.x_fname[0] == 0) {
      bfd_h_put_32(abfd, 0, (bfd_byte *) ext->x_file.x_n.x_zeroes);
      bfd_h_put_32(abfd,
	      in->x_file.x_n.x_offset,
	      (bfd_byte *) ext->x_file.x_n.x_offset);
    }
    else {
#if FILNMLEN != E_FILNMLEN
      -> Error, we need to cope with truncating or extending FILNMLEN!;
#else
      memcpy (ext->x_file.x_fname, in->x_file.x_fname, FILNMLEN);
a369 2
    }
    return AUXESZ;
d371 7
d379 6
a384 19
  case C_STAT:
#ifdef C_LEAFSTAT
  case C_LEAFSTAT:
#endif
  case C_HIDDEN:
    if (type == T_NULL) {
      PUT_SCN_SCNLEN(abfd, in->x_scn.x_scnlen, ext);
      PUT_SCN_NRELOC(abfd, in->x_scn.x_nreloc, ext);
      PUT_SCN_NLINNO(abfd, in->x_scn.x_nlinno, ext);
      bfd_h_put_32 (abfd, in->x_scn.x_checksum,
		    (bfd_byte *) ext->x_scn.x_checksum);
      bfd_h_put_16 (abfd, in->x_scn.x_associated,
		    (bfd_byte *) ext->x_scn.x_associated);
      bfd_h_put_8 (abfd, in->x_scn.x_comdat,
		   (bfd_byte *) ext->x_scn.x_comdat);
      return AUXESZ;
    }
    break;
  }
d386 2
a387 4
  bfd_h_put_32(abfd, in->x_sym.x_tagndx.l, (bfd_byte *) ext->x_sym.x_tagndx);
#ifndef NO_TVNDX
  bfd_h_put_16(abfd, in->x_sym.x_tvndx , (bfd_byte *) ext->x_sym.x_tvndx);
#endif
d389 1
a389 1
  if (class == C_BLOCK || class == C_FCN || ISFCN (type) || ISTAG (class))
d391 1
a391 17
      PUT_FCN_LNNOPTR(abfd,  in->x_sym.x_fcnary.x_fcn.x_lnnoptr, ext);
      PUT_FCN_ENDNDX(abfd,  in->x_sym.x_fcnary.x_fcn.x_endndx.l, ext);
    }
  else
    {
#if DIMNUM != E_DIMNUM
 #error we need to cope with truncating or extending DIMNUM
#endif
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[0],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[1],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[2],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[3],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
    }
d393 1
a393 7
  if (ISFCN (type))
    bfd_h_put_32 (abfd, in->x_sym.x_misc.x_fsize,
	     (bfd_byte *)  ext->x_sym.x_misc.x_fsize);
  else
    {
      PUT_LNSZ_LNNO (abfd, in->x_sym.x_misc.x_lnsz.x_lnno, ext);
      PUT_LNSZ_SIZE (abfd, in->x_sym.x_misc.x_lnsz.x_size, ext);
d396 1
a396 1
  return AUXESZ;
d399 2
d402 3
a404 5
static void
coff_swap_lineno_in (abfd, ext1, in1)
     bfd            *abfd;
     PTR ext1;
     PTR in1;
d406 2
a407 2
  LINENO *ext = (LINENO *)ext1;
  struct internal_lineno      *in = (struct internal_lineno *)in1;
d409 4
a412 2
  in->l_addr.l_symndx = bfd_h_get_32(abfd, (bfd_byte *) ext->l_addr.l_symndx);
  in->l_lnno = GET_LINENO_LNNO(abfd, ext);
d415 2
a416 10
static unsigned int
coff_swap_lineno_out (abfd, inp, outp)
     bfd       *abfd;
     PTR	inp;
     PTR	outp;
{
  struct internal_lineno *in = (struct internal_lineno *)inp;
  struct external_lineno *ext = (struct external_lineno *)outp;
  bfd_h_put_32(abfd, in->l_addr.l_symndx, (bfd_byte *)
	  ext->l_addr.l_symndx);
d418 1
a418 3
  PUT_LINENO_LNNO (abfd, in->l_lnno, ext);
  return LINESZ;
}
d420 66
d488 1
d490 5
a494 4
coff_swap_aouthdr_in (abfd, aouthdr_ext1, aouthdr_int1)
     bfd            *abfd;
     PTR aouthdr_ext1;
     PTR aouthdr_int1;
d496 2
a497 55
  struct internal_extra_pe_aouthdr *a;
  PEAOUTHDR *src = (PEAOUTHDR *)(aouthdr_ext1);
  AOUTHDR        *aouthdr_ext = (AOUTHDR *) aouthdr_ext1;
  struct internal_aouthdr *aouthdr_int = (struct internal_aouthdr *)aouthdr_int1;

  aouthdr_int->magic = bfd_h_get_16(abfd, (bfd_byte *) aouthdr_ext->magic);
  aouthdr_int->vstamp = bfd_h_get_16(abfd, (bfd_byte *) aouthdr_ext->vstamp);
  aouthdr_int->tsize =
    GET_AOUTHDR_TSIZE (abfd, (bfd_byte *) aouthdr_ext->tsize);
  aouthdr_int->dsize =
    GET_AOUTHDR_DSIZE (abfd, (bfd_byte *) aouthdr_ext->dsize);
  aouthdr_int->bsize =
    GET_AOUTHDR_BSIZE (abfd, (bfd_byte *) aouthdr_ext->bsize);
  aouthdr_int->entry =
    GET_AOUTHDR_ENTRY (abfd, (bfd_byte *) aouthdr_ext->entry);
  aouthdr_int->text_start =
    GET_AOUTHDR_TEXT_START (abfd, (bfd_byte *) aouthdr_ext->text_start);
  aouthdr_int->data_start =
    GET_AOUTHDR_DATA_START (abfd, (bfd_byte *) aouthdr_ext->data_start);

  a = &aouthdr_int->pe;
  a->ImageBase = bfd_h_get_32 (abfd, src->ImageBase);
  a->SectionAlignment = bfd_h_get_32 (abfd, src->SectionAlignment);
  a->FileAlignment = bfd_h_get_32 (abfd, src->FileAlignment);
  a->MajorOperatingSystemVersion = 
    bfd_h_get_16 (abfd, src->MajorOperatingSystemVersion);
  a->MinorOperatingSystemVersion = 
    bfd_h_get_16 (abfd, src->MinorOperatingSystemVersion);
  a->MajorImageVersion = bfd_h_get_16 (abfd, src->MajorImageVersion);
  a->MinorImageVersion = bfd_h_get_16 (abfd, src->MinorImageVersion);
  a->MajorSubsystemVersion = bfd_h_get_16 (abfd, src->MajorSubsystemVersion);
  a->MinorSubsystemVersion = bfd_h_get_16 (abfd, src->MinorSubsystemVersion);
  a->Reserved1 = bfd_h_get_32 (abfd, src->Reserved1);
  a->SizeOfImage = bfd_h_get_32 (abfd, src->SizeOfImage);
  a->SizeOfHeaders = bfd_h_get_32 (abfd, src->SizeOfHeaders);
  a->CheckSum = bfd_h_get_32 (abfd, src->CheckSum);
  a->Subsystem = bfd_h_get_16 (abfd, src->Subsystem);
  a->DllCharacteristics = bfd_h_get_16 (abfd, src->DllCharacteristics);
  a->SizeOfStackReserve = bfd_h_get_32 (abfd, src->SizeOfStackReserve);
  a->SizeOfStackCommit = bfd_h_get_32 (abfd, src->SizeOfStackCommit);
  a->SizeOfHeapReserve = bfd_h_get_32 (abfd, src->SizeOfHeapReserve);
  a->SizeOfHeapCommit = bfd_h_get_32 (abfd, src->SizeOfHeapCommit);
  a->LoaderFlags = bfd_h_get_32 (abfd, src->LoaderFlags);
  a->NumberOfRvaAndSizes = bfd_h_get_32 (abfd, src->NumberOfRvaAndSizes);

  {
    int idx;
    for (idx=0; idx < 16; idx++)
      {
	a->DataDirectory[idx].VirtualAddress =
	  bfd_h_get_32 (abfd, src->DataDirectory[idx][0]);
	a->DataDirectory[idx].Size =
	  bfd_h_get_32 (abfd, src->DataDirectory[idx][1]);
      }
  }
d499 15
a513 15
  if (aouthdr_int->entry)
    aouthdr_int->entry += a->ImageBase;
  if (aouthdr_int->tsize) 
    aouthdr_int->text_start += a->ImageBase;
  if (aouthdr_int->dsize) 
    aouthdr_int->data_start += a->ImageBase;

#ifdef POWERPC_LE_PE
  /* These three fields are normally set up by ppc_relocate_section.
     In the case of reading a file in, we can pick them up from
     the DataDirectory.
  */
  first_thunk_address = a->DataDirectory[12].VirtualAddress ;
  thunk_size = a->DataDirectory[12].Size;
  import_table_size = a->DataDirectory[1].Size;
d515 4
d521 6
a526 7

static void add_data_entry (abfd, aout, idx, name, base)
     bfd *abfd;
     struct internal_extra_pe_aouthdr *aout;
     int idx;
     char *name;
     bfd_vma base;
d528 2
a529 9
  asection *sec = bfd_get_section_by_name (abfd, name);

  /* add import directory information if it exists */
  if (sec != NULL)
    {
      aout->DataDirectory[idx].VirtualAddress = sec->vma - base;
      aout->DataDirectory[idx].Size = pei_section_data (abfd, sec)->virt_size;
      sec->flags |= SEC_DATA;
    }
d532 4
a535 5
static unsigned int
coff_swap_aouthdr_out (abfd, in, out)
     bfd       *abfd;
     PTR	in;
     PTR	out;
d537 4
a540 3
  struct internal_aouthdr *aouthdr_in = (struct internal_aouthdr *)in;
  struct internal_extra_pe_aouthdr *extra = &pe_data (abfd)->pe_opthdr;
  PEAOUTHDR *aouthdr_out = (PEAOUTHDR *)out;
d542 2
a543 3
  bfd_vma sa = extra->SectionAlignment;
  bfd_vma fa = extra->FileAlignment;
  bfd_vma ib = extra->ImageBase ;
d545 3
a547 6
  if (aouthdr_in->tsize) 
    aouthdr_in->text_start -= ib;
  if (aouthdr_in->dsize) 
    aouthdr_in->data_start -= ib;
  if (aouthdr_in->entry) 
    aouthdr_in->entry -= ib;
d549 3
a551 2
#define FA(x)  (((x) + fa -1 ) & (- fa))
#define SA(x)  (((x) + sa -1 ) & (- sa))
d553 2
a554 1
  /* We like to have the sizes aligned */
d556 12
a567 1
  aouthdr_in->bsize = FA (aouthdr_in->bsize);
d569 16
d586 5
a590 1
  extra->NumberOfRvaAndSizes = IMAGE_NUMBEROF_DIRECTORY_ENTRIES;
d592 2
a593 2
  /* first null out all data directory entries .. */
  memset (extra->DataDirectory, sizeof (extra->DataDirectory), 0);
d595 41
a635 7
  add_data_entry (abfd, extra, 0, ".edata", ib);
  add_data_entry (abfd, extra, 1, ".idata", ib);
  add_data_entry (abfd, extra, 2, ".rsrc" ,ib);

#ifdef POWERPC_LE_PE
  /* FIXME: do other PE platforms use this? */
  add_data_entry (abfd, extra, 3, ".pdata" ,ib);
d637 44
d682 13
a694 1
  add_data_entry (abfd, extra, 5, ".reloc", ib);
d696 4
a699 8
#ifdef POWERPC_LE_PE
  /* On the PPC NT system, this field is set up as follows. It is
     not an "officially" reserved field, so it currently has no title.
     first_thunk_address is idata$5, and the thunk_size is the size
     of the idata$5 chunk of the idata section.
  */
  extra->DataDirectory[12].VirtualAddress = first_thunk_address;
  extra->DataDirectory[12].Size = thunk_size;
d701 67
a767 6
  /* On the PPC NT system, the size of the directory entry is not the
     size of the entire section. It's actually offset to the end of 
     the idata$3 component of the idata section. This is the size of
     the entire import table. (also known as the start of idata$4)
  */
  extra->DataDirectory[1].Size = import_table_size;
d769 2
d772 2
a773 31
  {
    asection *sec;
    bfd_vma dsize= 0;
    bfd_vma isize = SA(abfd->sections->filepos);
    bfd_vma tsize= 0;

    for (sec = abfd->sections; sec; sec = sec->next)
      {
	int rounded = FA(sec->_raw_size);

	if (sec->flags & SEC_DATA) 
	  dsize += rounded;
	if (sec->flags & SEC_CODE)
	  tsize += rounded;
	isize += SA(rounded);
      }

    aouthdr_in->dsize = dsize;
    aouthdr_in->tsize = tsize;
    extra->SizeOfImage = isize;
  }

  extra->SizeOfHeaders = abfd->sections->filepos;
  bfd_h_put_16(abfd, aouthdr_in->magic, (bfd_byte *) aouthdr_out->standard.magic);

#ifdef POWERPC_LE_PE
  /* this little piece of magic sets the "linker version" field to 2.60 */
  bfd_h_put_16(abfd, 2  + 60 * 256, (bfd_byte *) aouthdr_out->standard.vstamp);
#else
  /* this little piece of magic sets the "linker version" field to 2.55 */
  bfd_h_put_16(abfd, 2  + 55 * 256, (bfd_byte *) aouthdr_out->standard.vstamp);
d776 39
a814 63
  PUT_AOUTHDR_TSIZE (abfd, aouthdr_in->tsize, (bfd_byte *) aouthdr_out->standard.tsize);
  PUT_AOUTHDR_DSIZE (abfd, aouthdr_in->dsize, (bfd_byte *) aouthdr_out->standard.dsize);
  PUT_AOUTHDR_BSIZE (abfd, aouthdr_in->bsize, (bfd_byte *) aouthdr_out->standard.bsize);
  PUT_AOUTHDR_ENTRY (abfd, aouthdr_in->entry, (bfd_byte *) aouthdr_out->standard.entry);
  PUT_AOUTHDR_TEXT_START (abfd, aouthdr_in->text_start,
			  (bfd_byte *) aouthdr_out->standard.text_start);

  PUT_AOUTHDR_DATA_START (abfd, aouthdr_in->data_start,
			  (bfd_byte *) aouthdr_out->standard.data_start);


  bfd_h_put_32 (abfd, extra->ImageBase, 
		(bfd_byte *) aouthdr_out->ImageBase);
  bfd_h_put_32 (abfd, extra->SectionAlignment,
		(bfd_byte *) aouthdr_out->SectionAlignment);
  bfd_h_put_32 (abfd, extra->FileAlignment,
		(bfd_byte *) aouthdr_out->FileAlignment);
  bfd_h_put_16 (abfd, extra->MajorOperatingSystemVersion,
		(bfd_byte *) aouthdr_out->MajorOperatingSystemVersion);
  bfd_h_put_16 (abfd, extra->MinorOperatingSystemVersion,
		(bfd_byte *) aouthdr_out->MinorOperatingSystemVersion);
  bfd_h_put_16 (abfd, extra->MajorImageVersion,
		(bfd_byte *) aouthdr_out->MajorImageVersion);
  bfd_h_put_16 (abfd, extra->MinorImageVersion,
		(bfd_byte *) aouthdr_out->MinorImageVersion);
  bfd_h_put_16 (abfd, extra->MajorSubsystemVersion,
		(bfd_byte *) aouthdr_out->MajorSubsystemVersion);
  bfd_h_put_16 (abfd, extra->MinorSubsystemVersion,
		(bfd_byte *) aouthdr_out->MinorSubsystemVersion);
  bfd_h_put_32 (abfd, extra->Reserved1,
		(bfd_byte *) aouthdr_out->Reserved1);
  bfd_h_put_32 (abfd, extra->SizeOfImage,
		(bfd_byte *) aouthdr_out->SizeOfImage);
  bfd_h_put_32 (abfd, extra->SizeOfHeaders,
		(bfd_byte *) aouthdr_out->SizeOfHeaders);
  bfd_h_put_32 (abfd, extra->CheckSum,
		(bfd_byte *) aouthdr_out->CheckSum);
  bfd_h_put_16 (abfd, extra->Subsystem,
		(bfd_byte *) aouthdr_out->Subsystem);
  bfd_h_put_16 (abfd, extra->DllCharacteristics,
		(bfd_byte *) aouthdr_out->DllCharacteristics);
  bfd_h_put_32 (abfd, extra->SizeOfStackReserve,
		(bfd_byte *) aouthdr_out->SizeOfStackReserve);
  bfd_h_put_32 (abfd, extra->SizeOfStackCommit,
		(bfd_byte *) aouthdr_out->SizeOfStackCommit);
  bfd_h_put_32 (abfd, extra->SizeOfHeapReserve,
		(bfd_byte *) aouthdr_out->SizeOfHeapReserve);
  bfd_h_put_32 (abfd, extra->SizeOfHeapCommit,
		(bfd_byte *) aouthdr_out->SizeOfHeapCommit);
  bfd_h_put_32 (abfd, extra->LoaderFlags,
		(bfd_byte *) aouthdr_out->LoaderFlags);
  bfd_h_put_32 (abfd, extra->NumberOfRvaAndSizes,
		(bfd_byte *) aouthdr_out->NumberOfRvaAndSizes);
  {
    int idx;
    for (idx=0; idx < 16; idx++)
      {
	bfd_h_put_32 (abfd, extra->DataDirectory[idx].VirtualAddress,
		      (bfd_byte *) aouthdr_out->DataDirectory[idx][0]);
	bfd_h_put_32 (abfd, extra->DataDirectory[idx].Size,
		      (bfd_byte *) aouthdr_out->DataDirectory[idx][1]);
      }
  }
d816 12
a827 38
  return AOUTSZ;
}

static void
    coff_swap_scnhdr_in (abfd, ext, in)
      bfd            *abfd;
  PTR	     ext;
  PTR	     in;
{
  SCNHDR *scnhdr_ext = (SCNHDR *) ext;
  struct internal_scnhdr *scnhdr_int = (struct internal_scnhdr *) in;

  memcpy(scnhdr_int->s_name, scnhdr_ext->s_name, sizeof(scnhdr_int->s_name));
  scnhdr_int->s_vaddr =
    GET_SCNHDR_VADDR (abfd, (bfd_byte *) scnhdr_ext->s_vaddr);
  scnhdr_int->s_paddr =
    GET_SCNHDR_PADDR (abfd, (bfd_byte *) scnhdr_ext->s_paddr);
  scnhdr_int->s_size =
    GET_SCNHDR_SIZE (abfd, (bfd_byte *) scnhdr_ext->s_size);
  scnhdr_int->s_scnptr =
    GET_SCNHDR_SCNPTR (abfd, (bfd_byte *) scnhdr_ext->s_scnptr);
  scnhdr_int->s_relptr =
    GET_SCNHDR_RELPTR (abfd, (bfd_byte *) scnhdr_ext->s_relptr);
  scnhdr_int->s_lnnoptr =
    GET_SCNHDR_LNNOPTR (abfd, (bfd_byte *) scnhdr_ext->s_lnnoptr);
  scnhdr_int->s_flags = bfd_h_get_32(abfd, (bfd_byte *) scnhdr_ext->s_flags);

  scnhdr_int->s_nreloc = bfd_h_get_16(abfd, (bfd_byte *) scnhdr_ext->s_nreloc);
  scnhdr_int->s_nlnno = bfd_h_get_16(abfd, (bfd_byte *) scnhdr_ext->s_nlnno);

  if (scnhdr_int->s_vaddr != 0) 
    {
      scnhdr_int->s_vaddr += pe_data (abfd)->pe_opthdr.ImageBase;
    }
  if (strcmp (scnhdr_int->s_name, _BSS) == 0) 
    {
      scnhdr_int->s_size = scnhdr_int->s_paddr;
      scnhdr_int->s_paddr = 0;
a828 1
}
d830 10
a839 11
static unsigned int
coff_swap_scnhdr_out (abfd, in, out)
     bfd       *abfd;
     PTR	in;
     PTR	out;
{
  struct internal_scnhdr *scnhdr_int = (struct internal_scnhdr *)in;
  SCNHDR *scnhdr_ext = (SCNHDR *)out;
  unsigned int ret = SCNHSZ;
  bfd_vma ps;
  bfd_vma ss;
d841 62
a902 12
  memcpy(scnhdr_ext->s_name, scnhdr_int->s_name, sizeof(scnhdr_int->s_name));

  PUT_SCNHDR_VADDR (abfd, 
		    (scnhdr_int->s_vaddr 
		     - pe_data(abfd)->pe_opthdr.ImageBase),
		    (bfd_byte *) scnhdr_ext->s_vaddr);

  /* NT wants the size data to be rounded up to the next NT_FILE_ALIGNMENT
     value except for the BSS section, its s_size should be 0 */


  if (strcmp (scnhdr_int->s_name, _BSS) == 0) 
d904 6
a909 2
      ps = scnhdr_int->s_size;
      ss = 0;
d913 6
a918 3
      ps = scnhdr_int->s_paddr;
      ss = scnhdr_int->s_size;
    }
d920 2
a921 2
  PUT_SCNHDR_SIZE (abfd, ss,
		   (bfd_byte *) scnhdr_ext->s_size);
d923 4
d928 5
a932 1
  PUT_SCNHDR_PADDR (abfd, ps, (bfd_byte *) scnhdr_ext->s_paddr);
d934 8
a941 63
  PUT_SCNHDR_SCNPTR (abfd, scnhdr_int->s_scnptr,
		     (bfd_byte *) scnhdr_ext->s_scnptr);
  PUT_SCNHDR_RELPTR (abfd, scnhdr_int->s_relptr,
		     (bfd_byte *) scnhdr_ext->s_relptr);
  PUT_SCNHDR_LNNOPTR (abfd, scnhdr_int->s_lnnoptr,
		      (bfd_byte *) scnhdr_ext->s_lnnoptr);

  /* Extra flags must be set when dealing with NT.  All sections should also
     have the IMAGE_SCN_MEM_READ (0x40000000) flag set.  In addition, the
     .text section must have IMAGE_SCN_MEM_EXECUTE (0x20000000) and the data
     sections (.idata, .data, .bss, .CRT) must have IMAGE_SCN_MEM_WRITE set
     (this is especially important when dealing with the .idata section since
     the addresses for routines from .dlls must be overwritten).  If .reloc
     section data is ever generated, we must add IMAGE_SCN_MEM_DISCARDABLE
     (0x02000000).  Also, the resource data should also be read and
     writable.  */

  /* FIXME: alignment is also encoded in this field, at least on ppc (krk) */
  /* FIXME: even worse, I don't see how to get the original alignment field*/
  /*        back...                                                        */

  {
    int flags = scnhdr_int->s_flags;
    if (strcmp (scnhdr_int->s_name, ".data")  == 0 ||
	strcmp (scnhdr_int->s_name, ".CRT")   == 0 ||
	strcmp (scnhdr_int->s_name, ".rsrc")  == 0 ||
	strcmp (scnhdr_int->s_name, ".bss")   == 0)
      flags |= IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;
    else if (strcmp (scnhdr_int->s_name, ".text") == 0)
      flags |= IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_EXECUTE;
    else if (strcmp (scnhdr_int->s_name, ".reloc") == 0)
      flags = SEC_DATA| IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_DISCARDABLE;
    else if (strcmp (scnhdr_int->s_name, ".idata") == 0)
      flags = IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | SEC_DATA;     
    else if (strcmp (scnhdr_int->s_name, ".rdata") == 0
	     || strcmp (scnhdr_int->s_name, ".edata") == 0)
      flags =  IMAGE_SCN_MEM_READ | SEC_DATA;     
    else if (strcmp (scnhdr_int->s_name, ".pdata") == 0)
      flags = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_ALIGN_4BYTES |
			  IMAGE_SCN_MEM_READ ;
    /* Remember this field is a max of 8 chars, so the null is _not_ there
       for an 8 character name like ".reldata". (yep. Stupid bug) */
    else if (strncmp (scnhdr_int->s_name, ".reldata", strlen(".reldata")) == 0)
      flags =  IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_ALIGN_8BYTES |
	       IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE ;
    else if (strcmp (scnhdr_int->s_name, ".ydata") == 0)
      flags =  IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_ALIGN_8BYTES |
	       IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE ;
    else if (strncmp (scnhdr_int->s_name, ".drectve", strlen(".drectve")) == 0)
      flags =  IMAGE_SCN_LNK_INFO | IMAGE_SCN_LNK_REMOVE ;
#ifdef POWERPC_LE_PE
    else if (strncmp (scnhdr_int->s_name, ".stabstr", strlen(".stabstr")) == 0)
      {
	flags =  IMAGE_SCN_LNK_INFO;
      }
    else if (strcmp (scnhdr_int->s_name, ".stab") == 0)
      {
	flags =  IMAGE_SCN_LNK_INFO;
      }
#endif

    bfd_h_put_32(abfd, flags, (bfd_byte *) scnhdr_ext->s_flags);
  }
d943 1
a943 3
  if (scnhdr_int->s_nlnno <= 0xffff)
    bfd_h_put_16(abfd, scnhdr_int->s_nlnno, (bfd_byte *) scnhdr_ext->s_nlnno);
  else
d945 5
a949 17
      (*_bfd_error_handler) ("%s: line number overflow: 0x%lx > 0xffff",
			     bfd_get_filename (abfd),
			     scnhdr_int->s_nlnno);
      bfd_set_error (bfd_error_file_truncated);
      bfd_h_put_16 (abfd, 0xffff, (bfd_byte *) scnhdr_ext->s_nlnno);
      ret = 0;
    }
  if (scnhdr_int->s_nreloc <= 0xffff)
    bfd_h_put_16(abfd, scnhdr_int->s_nreloc, (bfd_byte *) scnhdr_ext->s_nreloc);
  else
    {
      (*_bfd_error_handler) ("%s: reloc overflow: 0x%lx > 0xffff",
			     bfd_get_filename (abfd),
			     scnhdr_int->s_nreloc);
      bfd_set_error (bfd_error_file_truncated);
      bfd_h_put_16 (abfd, 0xffff, (bfd_byte *) scnhdr_ext->s_nreloc);
      ret = 0;
a950 2
  return ret;
}
d952 2
a953 86
static char * dir_names[IMAGE_NUMBEROF_DIRECTORY_ENTRIES] = 
{
  "Export Directory [.edata (or where ever we found it)]",
  "Import Directory [parts of .idata]",
  "Resource Directory [.rsrc]",
  "Exception Directory [.pdata]",
  "Security Directory",
  "Base Relocation Directory [.reloc]",
  "Debug Directory",
  "Description Directory",
  "Special Directory",
  "Thread Storage Directory [.tls]",
  "Load Configuration Directory",
  "Bound Import Directory",
  "Import Address Table Directory",
  "Reserved",
  "Reserved",
  "Reserved"
};

/**********************************************************************/
static boolean
pe_print_idata(abfd, vfile)
     bfd*abfd;
     void *vfile;
{
  FILE *file = vfile;
  bfd_byte *data = 0;
  asection *section = bfd_get_section_by_name (abfd, ".idata");

#ifdef POWERPC_LE_PE
  asection *rel_section = bfd_get_section_by_name (abfd, ".reldata");
#endif

  bfd_size_type datasize = 0;
  bfd_size_type i;
  bfd_size_type start, stop;
  int onaline = 20;

  pe_data_type *pe = pe_data (abfd);
  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;

  if (section == 0)
    return true;

#ifdef POWERPC_LE_PE
  if (rel_section != 0 && bfd_section_size (abfd, rel_section) != 0)
    {
      /* The toc address can be found by taking the starting address,
	 which on the PPC locates a function descriptor. The descriptor
	 consists of the function code starting address followed by the
	 address of the toc. The starting address we get from the bfd,
	 and the descriptor is supposed to be in the .reldata section. 
      */

      bfd_vma loadable_toc_address;
      bfd_vma toc_address;
      bfd_vma start_address;
      bfd_byte *data = 0;
      int offset;
      data = (bfd_byte *) bfd_malloc ((size_t) bfd_section_size (abfd, 
								 rel_section));
      if (data == NULL && bfd_section_size (abfd, rel_section) != 0)
	return false;

      datasize = bfd_section_size (abfd, rel_section);
  
      bfd_get_section_contents (abfd, 
				rel_section, 
				(PTR) data, 0, 
				bfd_section_size (abfd, rel_section));

      offset = abfd->start_address - rel_section->vma;

      start_address = bfd_get_32(abfd, data+offset);
      loadable_toc_address = bfd_get_32(abfd, data+offset+4);
      toc_address = loadable_toc_address - 32768;

      fprintf(file,
	      "\nFunction descriptor located at the start address: %04lx\n",
	      (unsigned long int) (abfd->start_address));
      fprintf (file,
	       "\tcode-base %08lx toc (loadable/actual) %08lx/%08lx\n", 
	       start_address, loadable_toc_address, toc_address);
    }
  else 
d955 1
a955 44
      fprintf(file,
	      "\nNo reldata section! Function descriptor not decoded.\n");
    }
#endif

  fprintf(file,
	  "\nThe Import Tables (interpreted .idata section contents)\n");
  fprintf(file,
	  " vma:    Hint    Time      Forward  DLL       First\n");
  fprintf(file,
	  "         Table   Stamp     Chain    Name      Thunk\n");

  if (bfd_section_size (abfd, section) == 0)
    return true;

  data = (bfd_byte *) bfd_malloc ((size_t) bfd_section_size (abfd, section));
  datasize = bfd_section_size (abfd, section);
  if (data == NULL && datasize != 0)
    return false;

  bfd_get_section_contents (abfd, 
			    section, 
			    (PTR) data, 0, 
			    bfd_section_size (abfd, section));

  start = 0;

  stop = bfd_section_size (abfd, section);

  for (i = start; i < stop; i += onaline)
    {
      bfd_vma hint_addr;
      bfd_vma time_stamp;
      bfd_vma forward_chain;
      bfd_vma dll_name;
      bfd_vma first_thunk;
      int idx;
      int j;
      char *dll;
      int adj = extra->ImageBase - section->vma;

      fprintf (file,
	       " %04lx\t", 
	       (unsigned long int) (i + section->vma));
d957 4
a960 1
      if (i+20 > stop)
d962 4
a965 2
	  /* check stuff */
	  ;
d967 8
a974 25
      
      hint_addr = bfd_get_32(abfd, data+i);
      time_stamp = bfd_get_32(abfd, data+i+4);
      forward_chain = bfd_get_32(abfd, data+i+8);
      dll_name = bfd_get_32(abfd, data+i+12);
      first_thunk = bfd_get_32(abfd, data+i+16);
      
      fprintf(file, "%08lx %08lx %08lx %08lx %08lx\n",
	      hint_addr,
	      time_stamp,
	      forward_chain,
	      dll_name,
	      first_thunk);

      if (hint_addr ==0)
	{
	  break;
	}

      /* the image base is present in the section->vma */
      dll = (char *) data + dll_name + adj;
      fprintf(file, "\n\tDLL Name: %s\n", dll);
      fprintf(file, "\tvma:  Ordinal  Member-Name\n");

      idx = hint_addr + adj;
d976 2
a977 13
      for (j=0;j<stop;j+=4)
	{
	  int ordinal;
	  char *member_name;
	  bfd_vma member = bfd_get_32(abfd, data + idx + j);
	  if (member == 0)
	    break;
	  ordinal = bfd_get_16(abfd,
			       data + member + adj);
	  member_name = (char *) data + member + adj + 2;
	  fprintf(file, "\t%04lx\t %4d  %s\n",
		  member, ordinal, member_name);
	}
d979 8
a986 1
      if (hint_addr != first_thunk) 
d988 5
a992 43
	  int differ = 0;
	  int idx2;

	  idx2 = first_thunk + adj;

	  for (j=0;j<stop;j+=4)
	    {
	      int ordinal;
	      char *member_name;
	      bfd_vma hint_member = bfd_get_32(abfd, data + idx + j);
	      bfd_vma iat_member = bfd_get_32(abfd, data + idx2 + j);
	      if (hint_member != iat_member)
		{
		  if (differ == 0)
		    {
		      fprintf(file, 
			      "\tThe Import Address Table (difference found)\n");
		      fprintf(file, "\tvma:  Ordinal  Member-Name\n");
		      differ = 1;
		    }
		  if (iat_member == 0)
		    {
		      fprintf(file,
			      "\t>>> Ran out of IAT members!\n");
		    }
		  else 
		    {
		      ordinal = bfd_get_16(abfd,
					   data + iat_member + adj);
		      member_name = (char *) data + iat_member + adj + 2;
		      fprintf(file, "\t%04lx\t %4d  %s\n",
			      iat_member, ordinal, member_name);
		    }
		  break;
		}
	      if (hint_member == 0)
		break;
	    }
	  if (differ == 0)
	    {
	      fprintf(file,
		      "\tThe Import Address Table is identical\n");
	    }
d994 7
d1002 2
a1003 1
      fprintf(file, "\n");
d1005 3
d1009 12
d1022 1
a1022 44
  free (data);

  return true;
}

static boolean
pe_print_edata(abfd, vfile)
     bfd*abfd;
     void *vfile;
{
  FILE *file = vfile;
  bfd_byte *data = 0;
  asection *section = bfd_get_section_by_name (abfd, ".edata");

  bfd_size_type datasize = 0;
  bfd_size_type i;

  int adj;
  struct EDT_type 
    {
      long export_flags;             /* reserved - should be zero */
      long time_stamp;
      short major_ver;
      short minor_ver;
      bfd_vma name;                  /* rva - relative to image base */
      long base;                     /* ordinal base */
      long num_functions;        /* Number in the export address table */
      long num_names;            /* Number in the name pointer table */
      bfd_vma eat_addr;    /* rva to the export address table */
      bfd_vma npt_addr;        /* rva to the Export Name Pointer Table */
      bfd_vma ot_addr; /* rva to the Ordinal Table */
    } edt;

  pe_data_type *pe = pe_data (abfd);
  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;

  if (section == 0)
    return true;

  data = (bfd_byte *) bfd_malloc ((size_t) bfd_section_size (abfd, 
							     section));
  datasize = bfd_section_size (abfd, section);

  if (data == NULL && datasize != 0)
d1025 14
a1038 81
  bfd_get_section_contents (abfd, 
			    section, 
			    (PTR) data, 0, 
			    bfd_section_size (abfd, section));

  /* Go get Export Directory Table */
  edt.export_flags   = bfd_get_32(abfd, data+0); 
  edt.time_stamp     = bfd_get_32(abfd, data+4);
  edt.major_ver      = bfd_get_16(abfd, data+8);
  edt.minor_ver      = bfd_get_16(abfd, data+10);
  edt.name           = bfd_get_32(abfd, data+12);
  edt.base           = bfd_get_32(abfd, data+16);
  edt.num_functions  = bfd_get_32(abfd, data+20); 
  edt.num_names      = bfd_get_32(abfd, data+24); 
  edt.eat_addr       = bfd_get_32(abfd, data+28);
  edt.npt_addr       = bfd_get_32(abfd, data+32); 
  edt.ot_addr        = bfd_get_32(abfd, data+36);

  adj = extra->ImageBase - section->vma;


  /* Dump the EDT first first */
  fprintf(file,
	  "\nThe Export Tables (interpreted .edata section contents)\n\n");

  fprintf(file,
	  "Export Flags \t\t\t%lx\n", (unsigned long) edt.export_flags);

  fprintf(file,
	  "Time/Date stamp \t\t%lx\n", (unsigned long) edt.time_stamp);

  fprintf(file,
	  "Major/Minor \t\t\t%d/%d\n", edt.major_ver, edt.minor_ver);

  fprintf (file,
	   "Name \t\t\t\t");
  fprintf_vma (file, edt.name);
  fprintf (file,
	   " %s\n", data + edt.name + adj);

  fprintf(file,
	  "Ordinal Base \t\t\t%ld\n", edt.base);

  fprintf(file,
	  "Number in:\n");

  fprintf(file,
	  "\tExport Address Table \t\t%lx\n",
	  (unsigned long) edt.num_functions);

  fprintf(file,
	  "\t[Name Pointer/Ordinal] Table\t%ld\n", edt.num_names);

  fprintf(file,
	  "Table Addresses\n");

  fprintf (file,
	   "\tExport Address Table \t\t");
  fprintf_vma (file, edt.eat_addr);
  fprintf (file, "\n");

  fprintf (file,
	  "\tName Pointer Table \t\t");
  fprintf_vma (file, edt.npt_addr);
  fprintf (file, "\n");

  fprintf (file,
	   "\tOrdinal Table \t\t\t");
  fprintf_vma (file, edt.ot_addr);
  fprintf (file, "\n");

  
  /* The next table to find si the Export Address Table. It's basically
     a list of pointers that either locate a function in this dll, or
     forward the call to another dll. Something like:
      typedef union 
      {
        long export_rva;
        long forwarder_rva;
      } export_address_table_entry;
  */
d1040 2
a1041 5
  fprintf(file,
	  "\nExport Address Table -- Ordinal Base %ld\n",
	  edt.base);

  for (i = 0; i < edt.num_functions; ++i)
d1043 23
a1065 26
      bfd_vma eat_member = bfd_get_32(abfd, 
				      data + edt.eat_addr + (i*4) + adj);
      bfd_vma eat_actual = extra->ImageBase + eat_member;
      bfd_vma edata_start = bfd_get_section_vma(abfd,section);
      bfd_vma edata_end = edata_start + bfd_section_size (abfd, section);


      if (eat_member == 0)
	continue;

      if (edata_start < eat_actual && eat_actual < edata_end) 
	{
	  /* this rva is to a name (forwarding function) in our section */
	  /* Should locate a function descriptor */
	  fprintf(file,
		  "\t[%4ld] +base[%4ld] %04lx %s -- %s\n", 
		  (long) i, (long) (i + edt.base), eat_member,
		  "Forwarder RVA", data + eat_member + adj);
	}
      else
	{
	  /* Should locate a function descriptor in the reldata section */
	  fprintf(file,
		  "\t[%4ld] +base[%4ld] %04lx %s\n", 
		  (long) i, (long) (i + edt.base), eat_member, "Export RVA");
	}
d1068 6
a1073 20
  /* The Export Name Pointer Table is paired with the Export Ordinal Table */
  /* Dump them in parallel for clarity */
  fprintf(file,
	  "\n[Ordinal/Name Pointer] Table\n");

  for (i = 0; i < edt.num_names; ++i)
    {
      bfd_vma name_ptr = bfd_get_32(abfd, 
				    data + 
				    edt.npt_addr
				    + (i*4) + adj);
      
      char *name = (char *) data + name_ptr + adj;

      bfd_vma ord = bfd_get_16(abfd, 
				    data + 
				    edt.ot_addr
				    + (i*2) + adj);
      fprintf(file,
	      "\t[%4ld] %s\n", (long) ord, name);
d1075 8
a1082 1
    }
d1084 1
a1084 1
  free (data);
d1089 28
a1116 35
static boolean
pe_print_pdata(abfd, vfile)
     bfd*abfd;
     void *vfile;
{
  FILE *file = vfile;
  bfd_byte *data = 0;
  asection *section = bfd_get_section_by_name (abfd, ".pdata");
  bfd_size_type datasize = 0;
  bfd_size_type i;
  bfd_size_type start, stop;
  int onaline = 20;

  if (section == 0)
    return true;

  stop = bfd_section_size (abfd, section);
  if ((stop % onaline) != 0)
    fprintf (file, "Warning, .pdata section size (%ld) is not a multiple of %d\n",
	     (long)stop, onaline);

  fprintf(file,
	  "\nThe Function Table (interpreted .pdata section contents)\n");
  fprintf(file,
	  " vma:\t\tBegin    End      EH       EH       PrologEnd\n");
  fprintf(file,
	  "     \t\tAddress  Address  Handler  Data     Address\n");

  if (bfd_section_size (abfd, section) == 0)
    return true;

  data = (bfd_byte *) bfd_malloc ((size_t) bfd_section_size (abfd, section));
  datasize = bfd_section_size (abfd, section);
  if (data == NULL && datasize != 0)
    return false;
d1118 58
a1175 23
  bfd_get_section_contents (abfd, 
			    section, 
			    (PTR) data, 0, 
			    bfd_section_size (abfd, section));

  start = 0;

  for (i = start; i < stop; i += onaline)
    {
      bfd_vma begin_addr;
      bfd_vma end_addr;
      bfd_vma eh_handler;
      bfd_vma eh_data;
      bfd_vma prolog_end_addr;

      if (i+20 > stop)
	  break;
      
      begin_addr = bfd_get_32(abfd, data+i);
      end_addr = bfd_get_32(abfd, data+i+4);
      eh_handler = bfd_get_32(abfd, data+i+8);
      eh_data = bfd_get_32(abfd, data+i+12);
      prolog_end_addr = bfd_get_32(abfd, data+i+16);
d1177 30
a1206 7
      if (begin_addr == 0 && end_addr == 0 && eh_handler == 0
	  && eh_data == 0 && prolog_end_addr == 0)
	{
	  /* We are probably into the padding of the
	     section now */
	  break;
	}
d1208 8
a1215 39
      fprintf (file,
	       " %08lx\t", 
	       (unsigned long int) (i + section->vma));

      fprintf(file, "%08lx %08lx %08lx %08lx %08lx",
	      begin_addr,
	      end_addr,
	      eh_handler,
	      eh_data,
	      prolog_end_addr);

#ifdef POWERPC_LE_PE
      if (eh_handler == 0 && eh_data != 0)
	{
	  /* Special bits here, although the meaning may */
	  /* be a little mysterious. The only one I know */
	  /* for sure is 0x03.                           */
	  /* Code Significance                           */
	  /* 0x00 None                                   */
	  /* 0x01 Register Save Millicode                */
	  /* 0x02 Register Restore Millicode             */
	  /* 0x03 Glue Code Sequence                     */
	  switch (eh_data)
	    {
	    case 0x01:
	      fprintf(file, " Register save millicode");
	      break;
	    case 0x02:
	      fprintf(file, " Register restore millicode");
	      break;
	    case 0x03:
	      fprintf(file, " Glue code sequence");
	      break;
	    default:
	      break;
	    }
	}
#endif	   
      fprintf(file, "\n");
d1218 2
a1219 1
  free (data);
d1221 2
a1222 2
  return true;
}
d1224 7
a1230 9
static const char *tbl[6] =
{
"ABSOLUTE",
"HIGH",
"LOW",
"HIGHLOW",
"HIGHADJ",
"MIPS_JMPADDR"
};
d1232 5
a1236 36
static boolean
pe_print_reloc(abfd, vfile)
     bfd*abfd;
     void *vfile;
{
  FILE *file = vfile;
  bfd_byte *data = 0;
  asection *section = bfd_get_section_by_name (abfd, ".reloc");
  bfd_size_type datasize = 0;
  bfd_size_type i;
  bfd_size_type start, stop;

  if (section == 0)
    return true;

  if (bfd_section_size (abfd, section) == 0)
    return true;

  fprintf(file,
	  "\n\nPE File Base Relocations (interpreted .reloc section contents)\n");

  data = (bfd_byte *) bfd_malloc ((size_t) bfd_section_size (abfd, section));
  datasize = bfd_section_size (abfd, section);
  if (data == NULL && datasize != 0)
    return false;

  bfd_get_section_contents (abfd, 
			    section, 
			    (PTR) data, 0, 
			    bfd_section_size (abfd, section));

  start = 0;

  stop = bfd_section_size (abfd, section);

  for (i = start; i < stop;)
d1238 6
a1243 35
      int j;
      bfd_vma virtual_address;
      long number, size;

      /* The .reloc section is a sequence of blocks, with a header consisting
	 of two 32 bit quantities, followed by a number of 16 bit entries */

      virtual_address = bfd_get_32(abfd, data+i);
      size = bfd_get_32(abfd, data+i+4);
      number = (size - 8) / 2;

      if (size == 0) 
	{
	  break;
	}

      fprintf (file,
	       "\nVirtual Address: %08lx Chunk size %ld (0x%lx) Number of fixups %ld\n",
	       virtual_address, size, size, number);

      for (j = 0; j < number; ++j)
	{
	  unsigned short e = bfd_get_16(abfd, data + i + 8 + j*2);
	  int t =   (e & 0xF000) >> 12;
	  int off = e & 0x0FFF;

	  if (t > 5) 
	    abort();

	  fprintf(file,
		  "\treloc %4d offset %4x [%4lx] %s\n", 
		  j, off, (long) (off + virtual_address), tbl[t]);
	  
	}
      i += size;
d1245 7
a1251 4

  free (data);

  return true;
d1254 2
a1255 4
static boolean
pe_print_private_bfd_data (abfd, vfile)
     bfd *abfd;
     PTR vfile;
d1257 31
a1287 41
  FILE *file = (FILE *) vfile;
  int j;
  pe_data_type *pe = pe_data (abfd);
  struct internal_extra_pe_aouthdr *i = &pe->pe_opthdr;

  fprintf (file,"\nImageBase\t\t");
  fprintf_vma (file, i->ImageBase);
  fprintf (file,"\nSectionAlignment\t");
  fprintf_vma (file, i->SectionAlignment);
  fprintf (file,"\nFileAlignment\t\t");
  fprintf_vma (file, i->FileAlignment);
  fprintf (file,"\nMajorOSystemVersion\t%d\n", i->MajorOperatingSystemVersion);
  fprintf (file,"MinorOSystemVersion\t%d\n", i->MinorOperatingSystemVersion);
  fprintf (file,"MajorImageVersion\t%d\n", i->MajorImageVersion);
  fprintf (file,"MinorImageVersion\t%d\n", i->MinorImageVersion);
  fprintf (file,"MajorSubsystemVersion\t%d\n", i->MajorSubsystemVersion);
  fprintf (file,"MinorSubsystemVersion\t%d\n", i->MinorSubsystemVersion);
  fprintf (file,"Reserved1\t\t%08lx\n", i->Reserved1);
  fprintf (file,"SizeOfImage\t\t%08lx\n", i->SizeOfImage);
  fprintf (file,"SizeOfHeaders\t\t%08lx\n", i->SizeOfHeaders);
  fprintf (file,"CheckSum\t\t%08lx\n", i->CheckSum);
  fprintf (file,"Subsystem\t\t%08x\n", i->Subsystem);
  fprintf (file,"DllCharacteristics\t%08x\n", i->DllCharacteristics);
  fprintf (file,"SizeOfStackReserve\t");
  fprintf_vma (file, i->SizeOfStackReserve);
  fprintf (file,"\nSizeOfStackCommit\t");
  fprintf_vma (file, i->SizeOfStackCommit);
  fprintf (file,"\nSizeOfHeapReserve\t");
  fprintf_vma (file, i->SizeOfHeapReserve);
  fprintf (file,"\nSizeOfHeapCommit\t");
  fprintf_vma (file, i->SizeOfHeapCommit);
  fprintf (file,"\nLoaderFlags\t\t%08lx\n", i->LoaderFlags);
  fprintf (file,"NumberOfRvaAndSizes\t%08lx\n", i->NumberOfRvaAndSizes);

  fprintf (file,"\nThe Data Directory\n");
  for (j = 0; j < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; j++) 
    {
      fprintf (file, "Entry %1x ", j);
      fprintf_vma (file, i->DataDirectory[j].VirtualAddress);
      fprintf (file, " %08lx ", i->DataDirectory[j].Size);
      fprintf (file, "%s\n", dir_names[j]);
d1290 1
a1290 57
  pe_print_idata(abfd, vfile);
  pe_print_edata(abfd, vfile);
  pe_print_pdata(abfd, vfile);
  pe_print_reloc(abfd, vfile);

  return true;
}

static boolean
pe_mkobject (abfd)
     bfd * abfd;
{
  pe_data_type *pe;
  abfd->tdata.pe_obj_data = 
    (struct pe_tdata *) bfd_zalloc (abfd, sizeof (pe_data_type));

  if (abfd->tdata.pe_obj_data == 0)
    return false;

  pe = pe_data (abfd);

  pe->coff.pe = 1;
  pe->in_reloc_p = in_reloc_p;
  return true;
}

/* Create the COFF backend specific information.  */
static PTR
pe_mkobject_hook (abfd, filehdr, aouthdr)
     bfd * abfd;
     PTR filehdr;
     PTR aouthdr;
{
  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;
  pe_data_type *pe;

  if (pe_mkobject (abfd) == false)
    return NULL;

  pe = pe_data (abfd);
  pe->coff.sym_filepos = internal_f->f_symptr;
  /* These members communicate important constants about the symbol
     table to GDB's symbol-reading code.  These `constants'
     unfortunately vary among coff implementations...  */
  pe->coff.local_n_btmask = N_BTMASK;
  pe->coff.local_n_btshft = N_BTSHFT;
  pe->coff.local_n_tmask = N_TMASK;
  pe->coff.local_n_tshift = N_TSHIFT;
  pe->coff.local_symesz = SYMESZ;
  pe->coff.local_auxesz = AUXESZ;
  pe->coff.local_linesz = LINESZ;

  obj_raw_syment_count (abfd) =
    obj_conv_table_size (abfd) =
      internal_f->f_nsyms;

  pe->real_flags = internal_f->f_flags;
d1292 2
a1293 2
#ifdef COFF_IMAGE_WITH_PE
  if (aouthdr) 
d1295 3
a1297 1
      pe->pe_opthdr = ((struct internal_aouthdr *)aouthdr)->pe;
a1298 20
#endif

  return (PTR) pe;
}



/* Copy any private info we understand from the input bfd
   to the output bfd.  */

#define coff_bfd_copy_private_bfd_data pe_bfd_copy_private_bfd_data

static boolean
pe_bfd_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd, *obfd;
{
  /* One day we may try to grok other private data.  */
  if (ibfd->xvec->flavour != bfd_target_coff_flavour
      || obfd->xvec->flavour != bfd_target_coff_flavour)
    return true;
d1300 1
a1300 1
  pe_data(obfd)->pe_opthdr = pe_data (ibfd)->pe_opthdr;
d1302 1
a1302 25
  return true;
}

#ifdef COFF_IMAGE_WITH_PE

/* Copy private section data.  */

#define coff_bfd_copy_private_section_data pe_bfd_copy_private_section_data

static boolean pe_bfd_copy_private_section_data
  PARAMS ((bfd *, asection *, bfd *, asection *));

static boolean
pe_bfd_copy_private_section_data (ibfd, isec, obfd, osec)
     bfd *ibfd;
     asection *isec;
     bfd *obfd;
     asection *osec;
{
  if (bfd_get_flavour (ibfd) != bfd_target_coff_flavour
      || bfd_get_flavour (obfd) != bfd_target_coff_flavour)
    return true;

  if (coff_section_data (ibfd, isec) != NULL
      && pei_section_data (ibfd, isec) != NULL)
d1304 17
a1320 16
      if (coff_section_data (obfd, osec) == NULL)
	{
	  osec->used_by_bfd =
	    (PTR) bfd_zalloc (obfd, sizeof (struct coff_section_tdata));
	  if (osec->used_by_bfd == NULL)
	    return false;
	}
      if (pei_section_data (obfd, osec) == NULL)
	{
	  coff_section_data (obfd, osec)->tdata =
	    (PTR) bfd_zalloc (obfd, sizeof (struct pei_section_tdata));
	  if (coff_section_data (obfd, osec)->tdata == NULL)
	    return false;
	}
      pei_section_data (obfd, osec)->virt_size =
	pei_section_data (ibfd, isec)->virt_size;
d1323 1
a1323 1
  return true;
d1326 2
a1327 1
#endif
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d1931 4
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d26 1
d28 26
d243 1
a243 1
  return sizeof(struct external_reloc);
a270 1
      filehdr_dst->f_symptr = 0;
d406 1
a406 1
  return sizeof(FILHDR);
d428 1
a428 1
  return sizeof(FILHDR);
d523 1
a523 1
  return sizeof(SYMENT);
d638 1
a638 1
    return sizeof (AUXENT);
d656 1
a656 1
      return sizeof (AUXENT);
d695 1
a695 1
  return sizeof(AUXENT);
d724 1
a724 1
  return sizeof(struct external_lineno);
d797 10
d823 1
a823 1
      aout->DataDirectory[idx].Size = sec->_cooked_size;
d987 1
a987 1
  return sizeof(AOUTHDR);
d1036 1
a1036 1
  unsigned int ret = sizeof (SCNHDR);
a1104 1
    /* ppc-nt additions */
d1116 1
a1116 1
    else if (strcmp (scnhdr_int->s_name, ".drectve") == 0)
a1117 1
    /* end of ppc-nt additions */
d1159 1
a1159 1
  "Export Directory [.edata]",
d1242 5
d1469 1
a1469 1
	   "%s\n", data + edt.name + adj);
d1696 1
a1696 1
"unknown"
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1995 Free Software Foundation, Inc.
d538 6
d554 1
a554 1
  if (class == C_BLOCK || ISFCN (type) || ISTAG (class))
d624 6
d640 1
a640 1
  if (class == C_BLOCK || ISFCN (type) || ISTAG (class))
d786 1
a786 1
      aout->DataDirectory[idx].VirtualAddress = sec->lma - base;
d859 1
a859 3
#ifdef PPC
    isize = 0;
#endif
d863 1
d1084 10
d1136 2
a1137 2
  "Reserved",
  "Reserved [first thunk address on PPC]",
a1160 4
  bfd_vma addr_value;
  bfd_vma loadable_toc_address;
  bfd_vma toc_address;
  bfd_vma start_address;
d1178 3
d1183 5
a1187 2
      data = (bfd_byte *) xmalloc ((size_t) bfd_section_size (abfd, 
							      rel_section));
d1200 1
d1202 2
a1203 1
	      "\nFunction descriptor located at the start address:\n");
d1205 1
a1205 2
	       " %04lx code-base %08lx toc (loadable) %08lx toc (actual) %08lx\n", 
	       (unsigned long int) (abfd->start_address),
a1207 6
  else
    {
      loadable_toc_address = 0; 
      toc_address = 0; 
      start_address = 0;
    }
d1220 1
a1220 1
  data = (bfd_byte *) xmalloc ((size_t) bfd_section_size (abfd, section));
d1222 2
d1275 1
a1275 1
      dll = data + dll_name + adj;
d1290 1
a1290 1
	  member_name = data + member + adj + 2;
d1326 1
a1326 1
		      member_name = data + iat_member + adj + 2;
d1346 184
d1532 2
d1535 1
a1547 1
  bfd_vma addr_value;
d1552 5
d1560 1
a1560 1
	  " vma:   Begin    End      EH       EH       PrologEnd\n");
d1562 1
a1562 1
	  "        Address  Address  Handler  Data     Address\n");
d1567 1
a1567 1
  data = (bfd_byte *) xmalloc ((size_t) bfd_section_size (abfd, section));
d1569 2
a1578 2
  stop = bfd_section_size (abfd, section);

d1596 2
a1597 1
      if (begin_addr == 0)
d1605 1
a1605 1
	       " %04lx\t", 
d1646 91
d1788 1
d1790 1
d1804 1
a1804 4
    {
      bfd_set_error (bfd_error_no_memory);
      return false;
    }
d1875 42
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1995, 1996 Free Software Foundation, Inc.
a537 6
      in->x_scn.x_checksum = bfd_h_get_32 (abfd,
					   (bfd_byte *) ext->x_scn.x_checksum);
      in->x_scn.x_associated =
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_scn.x_associated);
      in->x_scn.x_comdat = bfd_h_get_8 (abfd,
					(bfd_byte *) ext->x_scn.x_comdat);
d548 1
a548 1
  if (class == C_BLOCK || class == C_FCN || ISFCN (type) || ISTAG (class))
a617 6
      bfd_h_put_32 (abfd, in->x_scn.x_checksum,
		    (bfd_byte *) ext->x_scn.x_checksum);
      bfd_h_put_16 (abfd, in->x_scn.x_associated,
		    (bfd_byte *) ext->x_scn.x_associated);
      bfd_h_put_8 (abfd, in->x_scn.x_comdat,
		   (bfd_byte *) ext->x_scn.x_comdat);
d628 1
a628 1
  if (class == C_BLOCK || class == C_FCN || ISFCN (type) || ISTAG (class))
d774 1
a774 1
      aout->DataDirectory[idx].VirtualAddress = sec->vma - base;
d847 3
a849 1

a852 1

a1072 10
#ifdef POWERPC_LE_PE
    else if (strncmp (scnhdr_int->s_name, ".stabstr", strlen(".stabstr")) == 0)
      {
	flags =  IMAGE_SCN_LNK_INFO;
      }
    else if (strcmp (scnhdr_int->s_name, ".stab") == 0)
      {
	flags =  IMAGE_SCN_LNK_INFO;
      }
#endif
d1115 2
a1116 2
  "Bound Import Directory",
  "Import Address Table Directory",
d1140 4
a1160 3
      bfd_vma loadable_toc_address;
      bfd_vma toc_address;
      bfd_vma start_address;
d1163 2
a1164 5
      data = (bfd_byte *) bfd_malloc ((size_t) bfd_section_size (abfd, 
								 rel_section));
      if (data == NULL && bfd_section_size (abfd, rel_section) != 0)
	return false;

a1176 1

d1178 1
a1178 2
	      "\nFunction descriptor located at the start address: %04lx\n",
	      (unsigned long int) (abfd->start_address));
d1180 2
a1181 1
	       "\tcode-base %08lx toc (loadable/actual) %08lx/%08lx\n", 
d1184 6
d1202 1
a1202 1
  data = (bfd_byte *) bfd_malloc ((size_t) bfd_section_size (abfd, section));
a1203 2
  if (data == NULL && datasize != 0)
    return false;
d1255 1
a1255 1
      dll = (char *) data + dll_name + adj;
d1270 1
a1270 1
	  member_name = (char *) data + member + adj + 2;
d1306 1
a1306 1
		      member_name = (char *) data + iat_member + adj + 2;
a1325 184
  free (data);

  return true;
}

static boolean
pe_print_edata(abfd, vfile)
     bfd*abfd;
     void *vfile;
{
  FILE *file = vfile;
  bfd_byte *data = 0;
  asection *section = bfd_get_section_by_name (abfd, ".edata");

  bfd_size_type datasize = 0;
  bfd_size_type i;

  int adj;
  struct EDT_type 
    {
      long export_flags;             /* reserved - should be zero */
      long time_stamp;
      short major_ver;
      short minor_ver;
      bfd_vma name;                  /* rva - relative to image base */
      long base;                     /* ordinal base */
      long num_functions;        /* Number in the export address table */
      long num_names;            /* Number in the name pointer table */
      bfd_vma eat_addr;    /* rva to the export address table */
      bfd_vma npt_addr;        /* rva to the Export Name Pointer Table */
      bfd_vma ot_addr; /* rva to the Ordinal Table */
    } edt;

  pe_data_type *pe = pe_data (abfd);
  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;

  if (section == 0)
    return true;

  data = (bfd_byte *) bfd_malloc ((size_t) bfd_section_size (abfd, 
							     section));
  datasize = bfd_section_size (abfd, section);

  if (data == NULL && datasize != 0)
    return false;

  bfd_get_section_contents (abfd, 
			    section, 
			    (PTR) data, 0, 
			    bfd_section_size (abfd, section));

  /* Go get Export Directory Table */
  edt.export_flags   = bfd_get_32(abfd, data+0); 
  edt.time_stamp     = bfd_get_32(abfd, data+4);
  edt.major_ver      = bfd_get_16(abfd, data+8);
  edt.minor_ver      = bfd_get_16(abfd, data+10);
  edt.name           = bfd_get_32(abfd, data+12);
  edt.base           = bfd_get_32(abfd, data+16);
  edt.num_functions  = bfd_get_32(abfd, data+20); 
  edt.num_names      = bfd_get_32(abfd, data+24); 
  edt.eat_addr       = bfd_get_32(abfd, data+28);
  edt.npt_addr       = bfd_get_32(abfd, data+32); 
  edt.ot_addr        = bfd_get_32(abfd, data+36);

  adj = extra->ImageBase - section->vma;


  /* Dump the EDT first first */
  fprintf(file,
	  "\nThe Export Tables (interpreted .edata section contents)\n\n");

  fprintf(file,
	  "Export Flags \t\t\t%lx\n", (unsigned long) edt.export_flags);

  fprintf(file,
	  "Time/Date stamp \t\t%lx\n", (unsigned long) edt.time_stamp);

  fprintf(file,
	  "Major/Minor \t\t\t%d/%d\n", edt.major_ver, edt.minor_ver);

  fprintf (file,
	   "Name \t\t\t\t");
  fprintf_vma (file, edt.name);
  fprintf (file,
	   "%s\n", data + edt.name + adj);

  fprintf(file,
	  "Ordinal Base \t\t\t%ld\n", edt.base);

  fprintf(file,
	  "Number in:\n");

  fprintf(file,
	  "\tExport Address Table \t\t%lx\n",
	  (unsigned long) edt.num_functions);

  fprintf(file,
	  "\t[Name Pointer/Ordinal] Table\t%ld\n", edt.num_names);

  fprintf(file,
	  "Table Addresses\n");

  fprintf (file,
	   "\tExport Address Table \t\t");
  fprintf_vma (file, edt.eat_addr);
  fprintf (file, "\n");

  fprintf (file,
	  "\tName Pointer Table \t\t");
  fprintf_vma (file, edt.npt_addr);
  fprintf (file, "\n");

  fprintf (file,
	   "\tOrdinal Table \t\t\t");
  fprintf_vma (file, edt.ot_addr);
  fprintf (file, "\n");

  
  /* The next table to find si the Export Address Table. It's basically
     a list of pointers that either locate a function in this dll, or
     forward the call to another dll. Something like:
      typedef union 
      {
        long export_rva;
        long forwarder_rva;
      } export_address_table_entry;
  */

  fprintf(file,
	  "\nExport Address Table -- Ordinal Base %ld\n",
	  edt.base);

  for (i = 0; i < edt.num_functions; ++i)
    {
      bfd_vma eat_member = bfd_get_32(abfd, 
				      data + edt.eat_addr + (i*4) + adj);
      bfd_vma eat_actual = extra->ImageBase + eat_member;
      bfd_vma edata_start = bfd_get_section_vma(abfd,section);
      bfd_vma edata_end = edata_start + bfd_section_size (abfd, section);


      if (eat_member == 0)
	continue;

      if (edata_start < eat_actual && eat_actual < edata_end) 
	{
	  /* this rva is to a name (forwarding function) in our section */
	  /* Should locate a function descriptor */
	  fprintf(file,
		  "\t[%4ld] +base[%4ld] %04lx %s -- %s\n", 
		  (long) i, (long) (i + edt.base), eat_member,
		  "Forwarder RVA", data + eat_member + adj);
	}
      else
	{
	  /* Should locate a function descriptor in the reldata section */
	  fprintf(file,
		  "\t[%4ld] +base[%4ld] %04lx %s\n", 
		  (long) i, (long) (i + edt.base), eat_member, "Export RVA");
	}
    }

  /* The Export Name Pointer Table is paired with the Export Ordinal Table */
  /* Dump them in parallel for clarity */
  fprintf(file,
	  "\n[Ordinal/Name Pointer] Table\n");

  for (i = 0; i < edt.num_names; ++i)
    {
      bfd_vma name_ptr = bfd_get_32(abfd, 
				    data + 
				    edt.npt_addr
				    + (i*4) + adj);
      
      char *name = (char *) data + name_ptr + adj;

      bfd_vma ord = bfd_get_16(abfd, 
				    data + 
				    edt.ot_addr
				    + (i*2) + adj);
      fprintf(file,
	      "\t[%4ld] %s\n", (long) ord, name);

    }
a1327 2

  return true;
a1328 1

d1341 1
a1345 5
  stop = bfd_section_size (abfd, section);
  if ((stop % onaline) != 0)
    fprintf (file, "Warning, .pdata section size (%ld) is not a multiple of %d\n",
	     (long)stop, onaline);

d1349 1
a1349 1
	  " vma:\t\tBegin    End      EH       EH       PrologEnd\n");
d1351 1
a1351 1
	  "     \t\tAddress  Address  Handler  Data     Address\n");
d1356 1
a1356 1
  data = (bfd_byte *) bfd_malloc ((size_t) bfd_section_size (abfd, section));
a1357 2
  if (data == NULL && datasize != 0)
    return false;
d1366 2
d1385 1
a1385 2
      if (begin_addr == 0 && end_addr == 0 && eh_handler == 0
	  && eh_data == 0 && prolog_end_addr == 0)
d1393 1
a1393 1
	       " %08lx\t", 
a1433 91

  return true;
}

static const char *tbl[6] =
{
"ABSOLUTE",
"HIGH",
"LOW",
"HIGHLOW",
"HIGHADJ",
"unknown"
};

static boolean
pe_print_reloc(abfd, vfile)
     bfd*abfd;
     void *vfile;
{
  FILE *file = vfile;
  bfd_byte *data = 0;
  asection *section = bfd_get_section_by_name (abfd, ".reloc");
  bfd_size_type datasize = 0;
  bfd_size_type i;
  bfd_size_type start, stop;

  if (section == 0)
    return true;

  if (bfd_section_size (abfd, section) == 0)
    return true;

  fprintf(file,
	  "\n\nPE File Base Relocations (interpreted .reloc section contents)\n");

  data = (bfd_byte *) bfd_malloc ((size_t) bfd_section_size (abfd, section));
  datasize = bfd_section_size (abfd, section);
  if (data == NULL && datasize != 0)
    return false;

  bfd_get_section_contents (abfd, 
			    section, 
			    (PTR) data, 0, 
			    bfd_section_size (abfd, section));

  start = 0;

  stop = bfd_section_size (abfd, section);

  for (i = start; i < stop;)
    {
      int j;
      bfd_vma virtual_address;
      long number, size;

      /* The .reloc section is a sequence of blocks, with a header consisting
	 of two 32 bit quantities, followed by a number of 16 bit entries */

      virtual_address = bfd_get_32(abfd, data+i);
      size = bfd_get_32(abfd, data+i+4);
      number = (size - 8) / 2;

      if (size == 0) 
	{
	  break;
	}

      fprintf (file,
	       "\nVirtual Address: %08lx Chunk size %ld (0x%lx) Number of fixups %ld\n",
	       virtual_address, size, size, number);

      for (j = 0; j < number; ++j)
	{
	  unsigned short e = bfd_get_16(abfd, data + i + 8 + j*2);
	  int t =   (e & 0xF000) >> 12;
	  int off = e & 0x0FFF;

	  if (t > 5) 
	    abort();

	  fprintf(file,
		  "\treloc %4d offset %4x [%4lx] %s\n", 
		  j, off, (long) (off + virtual_address), tbl[t]);
	  
	}
      i += size;
    }

  free (data);

  return true;
a1484 1
  pe_print_edata(abfd, vfile);
a1485 1
  pe_print_reloc(abfd, vfile);
d1499 4
a1502 1
    return false;
a1572 42

#ifdef COFF_IMAGE_WITH_PE

/* Copy private section data.  */

#define coff_bfd_copy_private_section_data pe_bfd_copy_private_section_data

static boolean pe_bfd_copy_private_section_data
  PARAMS ((bfd *, asection *, bfd *, asection *));

static boolean
pe_bfd_copy_private_section_data (ibfd, isec, obfd, osec)
     bfd *ibfd;
     asection *isec;
     bfd *obfd;
     asection *osec;
{
  if (coff_section_data (ibfd, isec) != NULL
      && pei_section_data (ibfd, isec) != NULL)
    {
      if (coff_section_data (obfd, osec) == NULL)
	{
	  osec->used_by_bfd =
	    (PTR) bfd_zalloc (obfd, sizeof (struct coff_section_tdata));
	  if (osec->used_by_bfd == NULL)
	    return false;
	}
      if (pei_section_data (obfd, osec) == NULL)
	{
	  coff_section_data (obfd, osec)->tdata =
	    (PTR) bfd_zalloc (obfd, sizeof (struct pei_section_tdata));
	  if (coff_section_data (obfd, osec)->tdata == NULL)
	    return false;
	}
      pei_section_data (obfd, osec)->virt_size =
	pei_section_data (ibfd, isec)->virt_size;
    }

  return true;
}

#endif
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a25 1
/* Hey look, some documentation [and in a place you expect to find it]!
a26 26
   The main reference for the pei format is "Microsoft Portable Executable
   and Common Object File Format Specification 4.1".  Get it if you need to
   do some serious hacking on this code.

   Another reference:
   "Peering Inside the PE: A Tour of the Win32 Portable Executable
   File Format", MSJ 1994, Volume 9.

   The *sole* difference between the pe format and the pei format is that the
   latter has an MSDOS 2.0 .exe header on the front that prints the message
   "This app must be run under Windows." (or some such).
   (FIXME: Whether that statement is *really* true or not is unknown.
   Are there more subtle differences between pe and pei formats?
   For now assume there aren't.  If you find one, then for God sakes
   document it here!)

   The Microsoft docs use the word "image" instead of "executable" because
   the former can also refer to a DLL (shared library).  Confusion can arise
   because the `i' in `pei' also refers to "image".  The `pe' format can
   also create images (i.e. executables), it's just that to run on a win32
   system you need to use the pei format.

   FIXME: Please add more docs here so the next poor fool that has to hack
   on this code has a chance of getting something accomplished without
   wasting too much time.
*/
d216 1
a216 1
  return RELSZ;
d244 1
d380 1
a380 1
  return FILHSZ;
d402 1
a402 1
  return FILHSZ;
d497 1
a497 1
  return SYMESZ;
d612 1
a612 1
    return AUXESZ;
d630 1
a630 1
      return AUXESZ;
d669 1
a669 1
  return AUXESZ;
d698 1
a698 1
  return LINESZ;
a770 10

#ifdef POWERPC_LE_PE
  /* These three fields are normally set up by ppc_relocate_section.
     In the case of reading a file in, we can pick them up from
     the DataDirectory.
  */
  first_thunk_address = a->DataDirectory[12].VirtualAddress ;
  thunk_size = a->DataDirectory[12].Size;
  import_table_size = a->DataDirectory[1].Size;
#endif
d787 1
a787 1
      aout->DataDirectory[idx].Size = pei_section_data (abfd, sec)->virt_size;
d951 1
a951 1
  return AOUTSZ;
d1000 1
a1000 1
  unsigned int ret = SCNHSZ;
d1069 1
d1081 1
a1081 1
    else if (strncmp (scnhdr_int->s_name, ".drectve", strlen(".drectve")) == 0)
d1083 1
d1125 1
a1125 1
  "Export Directory [.edata (or where ever we found it)]",
a1207 5
  else 
    {
      fprintf(file,
	      "\nNo reldata section! Function descriptor not decoded.\n");
    }
d1430 1
a1430 1
	   " %s\n", data + edt.name + adj);
d1657 1
a1657 1
"MIPS_JMPADDR"
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a1930 4
  if (bfd_get_flavour (ibfd) != bfd_target_coff_flavour
      || bfd_get_flavour (obfd) != bfd_target_coff_flavour)
    return true;

@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997 Free Software Foundation, Inc.
d196 1
a196 25
static void coff_swap_reloc_in PARAMS ((bfd *, PTR, PTR));
static unsigned int coff_swap_reloc_out PARAMS ((bfd *, PTR, PTR));
static void coff_swap_filehdr_in PARAMS ((bfd *, PTR, PTR));
static unsigned int coff_swap_filehdr_out PARAMS ((bfd *, PTR, PTR));
static void coff_swap_sym_in PARAMS ((bfd *, PTR, PTR));
static unsigned int coff_swap_sym_out PARAMS ((bfd *, PTR, PTR));
static void coff_swap_aux_in PARAMS ((bfd *, PTR, int, int, int, int, PTR));
static unsigned int coff_swap_aux_out
  PARAMS ((bfd *, PTR, int, int, int, int, PTR));
static void coff_swap_lineno_in PARAMS ((bfd *, PTR, PTR));
static unsigned int coff_swap_lineno_out PARAMS ((bfd *, PTR, PTR));
static void coff_swap_aouthdr_in PARAMS ((bfd *, PTR, PTR));
static void add_data_entry
  PARAMS ((bfd *, struct internal_extra_pe_aouthdr *, int, char *, bfd_vma));
static unsigned int coff_swap_aouthdr_out PARAMS ((bfd *, PTR, PTR));
static void coff_swap_scnhdr_in PARAMS ((bfd *, PTR, PTR));
static unsigned int coff_swap_scnhdr_out PARAMS ((bfd *, PTR, PTR));
static boolean pe_print_idata PARAMS ((bfd *, PTR));
static boolean pe_print_edata PARAMS ((bfd *, PTR));
static boolean pe_print_pdata PARAMS ((bfd *, PTR));
static boolean pe_print_reloc PARAMS ((bfd *, PTR));
static boolean pe_print_private_bfd_data PARAMS ((bfd *, PTR));
static boolean pe_mkobject PARAMS ((bfd *));
static PTR pe_mkobject_hook PARAMS ((bfd *, PTR, PTR));
static boolean pe_bfd_copy_private_bfd_data PARAMS ((bfd *, bfd *));
d1180 2
a1181 2
     bfd *abfd;
     PTR vfile;
d1391 3
a1393 3
pe_print_edata (abfd, vfile)
     bfd *abfd;
     PTR vfile;
d1576 3
a1578 3
pe_print_pdata (abfd, vfile)
     bfd  *abfd;
     PTR vfile;
d1700 3
a1702 3
pe_print_reloc (abfd, vfile)
     bfd *abfd;
     PTR vfile;
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d1 3
a3 3
/* Support for the generic parts of PE/PEI, for BFD.
   Copyright 1995, 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
   Written by Cygnus Solutions.
a23 3

PE/PEI rearrangement (and code added): Donn Terry
                                       Softway Systems, Inc.
d55 3
a57 1
#include "libpei.h"
d59 3
a61 7
static boolean (*pe_saved_coff_bfd_print_private_bfd_data)
    PARAMS ((bfd *, PTR)) =
#ifndef coff_bfd_print_private_bfd_data
     NULL;
#else
     coff_bfd_print_private_bfd_data;
#undef coff_bfd_print_private_bfd_data
d64 4
a67 2
static boolean pe_print_private_bfd_data PARAMS ((bfd *, PTR));
#define coff_bfd_print_private_bfd_data pe_print_private_bfd_data
d69 42
d112 6
a117 7
static boolean (*pe_saved_coff_bfd_copy_private_bfd_data)
    PARAMS ((bfd *, bfd *)) =
#ifndef coff_bfd_copy_private_bfd_data
     NULL;
#else
     coff_bfd_copy_private_bfd_data;
#undef coff_bfd_copy_private_bfd_data
d120 37
a156 2
static boolean pe_bfd_copy_private_bfd_data PARAMS ((bfd *, bfd *));
#define coff_bfd_copy_private_bfd_data pe_bfd_copy_private_bfd_data
d158 37
a194 2
#define coff_mkobject      pe_mkobject
#define coff_mkobject_hook pe_mkobject_hook
a195 1
#ifndef NO_COFF_RELOCS
a197 1
#endif
d199 12
d212 6
d220 1
a220 50

#ifdef COFF_IMAGE_WITH_PE
/* This structure contains static variables used by the ILF code.  */
typedef asection * asection_ptr;

typedef struct
{
  bfd *			abfd;
  bfd_byte *		data;
  struct bfd_in_memory * bim;
  unsigned short        magic;
  
  arelent *		reltab;
  unsigned int 		relcount;

  coff_symbol_type * 	sym_cache;
  coff_symbol_type * 	sym_ptr;
  unsigned int       	sym_index;
  
  unsigned int * 	sym_table;
  unsigned int * 	table_ptr;
  
  combined_entry_type * native_syms;
  combined_entry_type * native_ptr;

  coff_symbol_type **	sym_ptr_table;
  coff_symbol_type **	sym_ptr_ptr;
  
  unsigned int		sec_index;

  char *                string_table;
  char *                string_ptr;
  char *		end_string_ptr;
  
  SYMENT *              esym_table;
  SYMENT *              esym_ptr;

  struct internal_reloc * int_reltab;
}
pe_ILF_vars;

static asection_ptr       pe_ILF_make_a_section   PARAMS ((pe_ILF_vars *, const char *, unsigned int, flagword));
static void               pe_ILF_make_a_reloc     PARAMS ((pe_ILF_vars *, bfd_vma, bfd_reloc_code_real_type, asection_ptr));
static void               pe_ILF_make_a_symbol    PARAMS ((pe_ILF_vars *, const char *, const char *, asection_ptr, flagword));
static void               pe_ILF_save_relocs      PARAMS ((pe_ILF_vars *, asection_ptr));
static void		  pe_ILF_make_a_symbol_reloc  PARAMS ((pe_ILF_vars *, bfd_vma, bfd_reloc_code_real_type,	   struct symbol_cache_entry **, unsigned int));
static boolean            pe_ILF_build_a_bfd      PARAMS ((bfd *, unsigned short, bfd_byte *, bfd_byte *, unsigned int, unsigned int));
static const bfd_target * pe_ILF_object_p         PARAMS ((bfd *));
static const bfd_target * pe_bfd_object_p 	  PARAMS ((bfd *));
#endif /* COFF_IMAGE_WITH_PE */
a223 1
#ifndef NO_COFF_RELOCS
d269 1
a269 1
#endif /* not NO_COFF_RELOCS */
d287 7
a293 18
#ifdef COFF_IMAGE_WITH_PE
  /* There are really two magic numbers involved; the magic number
     that says this is a NT executable (PEI) and the magic number that
     determines the architecture.  The former is DOSMAGIC, stored in
     the e_magic field.  The latter is stored in the f_magic field.
     If the NT magic number isn't valid, the architecture magic number
     could be mimicked by some other field (specifically, the number
     of relocs in section 3).  Since this routine can only be called
     correctly for a PEI file, check the e_magic number here, and, if
     it doesn't match, clobber the f_magic number so that we don't get
     a false match.  */
  if (bfd_h_get_16 (abfd, (bfd_byte *) filehdr_src->e_magic) != DOSMAGIC)
    filehdr_dst->f_magic = -1;
#endif

  /* Other people's tools sometimes generate headers with an nsyms but
     a zero symptr.  */
  if (filehdr_dst->f_nsyms != 0 && filehdr_dst->f_symptr == 0)
d296 1
a296 1
      filehdr_dst->f_flags |= F_LSYMS;
d304 128
a431 1
#define coff_swap_filehdr_out _bfd_pei_only_swap_filehdr_out
d433 22
a454 1
#define coff_swap_filehdr_out _bfd_pe_only_swap_filehdr_out
d459 1
a459 1
coff_swap_scnhdr_in (abfd, ext, in)
d461 2
a462 2
     PTR	     ext;
     PTR	     in;
d464 2
a465 17
  SCNHDR *scnhdr_ext = (SCNHDR *) ext;
  struct internal_scnhdr *scnhdr_int = (struct internal_scnhdr *) in;

  memcpy(scnhdr_int->s_name, scnhdr_ext->s_name, sizeof(scnhdr_int->s_name));
  scnhdr_int->s_vaddr =
    GET_SCNHDR_VADDR (abfd, (bfd_byte *) scnhdr_ext->s_vaddr);
  scnhdr_int->s_paddr =
    GET_SCNHDR_PADDR (abfd, (bfd_byte *) scnhdr_ext->s_paddr);
  scnhdr_int->s_size =
    GET_SCNHDR_SIZE (abfd, (bfd_byte *) scnhdr_ext->s_size);
  scnhdr_int->s_scnptr =
    GET_SCNHDR_SCNPTR (abfd, (bfd_byte *) scnhdr_ext->s_scnptr);
  scnhdr_int->s_relptr =
    GET_SCNHDR_RELPTR (abfd, (bfd_byte *) scnhdr_ext->s_relptr);
  scnhdr_int->s_lnnoptr =
    GET_SCNHDR_LNNOPTR (abfd, (bfd_byte *) scnhdr_ext->s_lnnoptr);
  scnhdr_int->s_flags = bfd_h_get_32(abfd, (bfd_byte *) scnhdr_ext->s_flags);
d467 7
a473 8
  /* MS handles overflow of line numbers by carrying into the reloc
     field (it appears).  Since it's supposed to be zero for PE
     *IMAGE* format, that's safe.  This is still a bit iffy.  */
#ifdef COFF_IMAGE_WITH_PE
  scnhdr_int->s_nlnno =
    (bfd_h_get_16 (abfd, (bfd_byte *) scnhdr_ext->s_nlnno)
     + (bfd_h_get_16 (abfd, (bfd_byte *) scnhdr_ext->s_nreloc) << 16));
  scnhdr_int->s_nreloc = 0;
d475 1
a475 4
  scnhdr_int->s_nreloc = bfd_h_get_16 (abfd,
				       (bfd_byte *) scnhdr_ext->s_nreloc);
  scnhdr_int->s_nlnno = bfd_h_get_16 (abfd,
				      (bfd_byte *) scnhdr_ext->s_nlnno);
d477 1
d479 29
a507 5
  if (scnhdr_int->s_vaddr != 0) 
    {
      scnhdr_int->s_vaddr += pe_data (abfd)->pe_opthdr.ImageBase;
      scnhdr_int->s_vaddr &= 0xffffffff;
    }
d509 2
a510 11
#ifndef COFF_NO_HACK_SCNHDR_SIZE
  /* If this section holds uninitialized data, use the virtual size
     (stored in s_paddr) instead of the physical size.  */
  if ((scnhdr_int->s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) != 0)
    {
      scnhdr_int->s_size = scnhdr_int->s_paddr;
      /* This code used to set scnhdr_int->s_paddr to 0.  However,
         coff_set_alignment_hook stores s_paddr in virt_size, which
         only works if it correctly holds the virtual size of the
         section.  */
    }
d514 5
a518 3
static boolean
pe_mkobject (abfd)
     bfd * abfd;
d520 13
a532 3
  pe_data_type *pe;
  abfd->tdata.pe_obj_data = 
    (struct pe_tdata *) bfd_zalloc (abfd, sizeof (pe_data_type));
d534 12
a545 6
  if (abfd->tdata.pe_obj_data == 0)
    return false;

  pe = pe_data (abfd);

  pe->coff.pe = 1;
d547 1
a547 3
  /* in_reloc_p is architecture dependent.  */
  pe->in_reloc_p = in_reloc_p;
  return true;
d550 9
a558 6
/* Create the COFF backend specific information.  */
static PTR
pe_mkobject_hook (abfd, filehdr, aouthdr)
     bfd * abfd;
     PTR filehdr;
     PTR aouthdr ATTRIBUTE_UNUSED;
d560 2
a561 2
  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;
  pe_data_type *pe;
d563 14
a576 2
  if (pe_mkobject (abfd) == false)
    return NULL;
a577 12
  pe = pe_data (abfd);
  pe->coff.sym_filepos = internal_f->f_symptr;
  /* These members communicate important constants about the symbol
     table to GDB's symbol-reading code.  These `constants'
     unfortunately vary among coff implementations...  */
  pe->coff.local_n_btmask = N_BTMASK;
  pe->coff.local_n_btshft = N_BTSHFT;
  pe->coff.local_n_tmask = N_TMASK;
  pe->coff.local_n_tshift = N_TSHIFT;
  pe->coff.local_symesz = SYMESZ;
  pe->coff.local_auxesz = AUXESZ;
  pe->coff.local_linesz = LINESZ;
d579 19
a597 1
  pe->coff.timestamp = internal_f->f_timdat;
d599 4
a602 3
  obj_raw_syment_count (abfd) =
    obj_conv_table_size (abfd) =
      internal_f->f_nsyms;
d604 19
a622 1
  pe->real_flags = internal_f->f_flags;
d624 8
a631 2
  if ((internal_f->f_flags & F_DLL) != 0)
    pe->dll = 1;
d633 12
a644 2
  if ((internal_f->f_flags & IMAGE_FILE_DEBUG_STRIPPED) == 0)
    abfd->flags |= HAS_DEBUG;
d646 14
a659 3
#ifdef COFF_IMAGE_WITH_PE
  if (aouthdr) 
    pe->pe_opthdr = ((struct internal_aouthdr *)aouthdr)->pe;
d661 2
a663 7
#ifdef ARM 
  if (! _bfd_coff_arm_set_private_flags (abfd, internal_f->f_flags))
    coff_data (abfd) ->flags = 0;
#endif
  
  return (PTR) pe;
}
d665 19
a683 6
static boolean
pe_print_private_bfd_data (abfd, vfile)
     bfd *abfd;
     PTR vfile;
{
  FILE *file = (FILE *) vfile;
d685 4
a688 2
  if (!_bfd_pe_print_private_bfd_data_common (abfd, vfile))
    return false;
d690 6
a695 1
  if (pe_saved_coff_bfd_print_private_bfd_data != NULL)
d697 12
a708 1
      fputc ('\n', file);
d710 7
a716 1
      return pe_saved_coff_bfd_print_private_bfd_data (abfd, vfile);
d719 1
a719 1
  return true;
a721 2
/* Copy any private info we understand from the input bfd
   to the output bfd.  */
d723 5
a727 3
static boolean
pe_bfd_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd, *obfd;
d729 2
a730 2
  if (!_bfd_pe_bfd_copy_private_bfd_data_common (ibfd, obfd))
    return false;
d732 2
a733 4
  if (pe_saved_coff_bfd_copy_private_bfd_data)
    return pe_saved_coff_bfd_copy_private_bfd_data (ibfd, obfd);

  return true;
d736 10
a745 2
#define coff_bfd_copy_private_section_data \
  _bfd_pe_bfd_copy_private_section_data
d747 3
a749 1
#define coff_get_symbol_info _bfd_pe_get_symbol_info
a750 66
#ifdef COFF_IMAGE_WITH_PE

/* Code to handle Microsoft's Image Library Format.
   Also known as LINK6 format.
   Documentation about this format can be found at: 

   http://msdn.microsoft.com/library/specs/pecoff_section8.htm  */

/* The following constants specify the sizes of the various data
   structures that we have to create in order to build a bfd describing
   an ILF object file.  The final "+ 1" in the definitions of SIZEOF_IDATA6
   and SIZEOF_IDATA7 below is to allow for the possibility that we might
   need a padding byte in order to ensure 16 bit alignment for the section's
   contents.

   The value for SIZEOF_ILF_STRINGS is computed as follows:

      There will be NUM_ILF_SECTIONS section symbols.  Allow 9 characters
      per symbol for their names (longest section name is .idata$x).

      There will be two symbols for the imported value, one the symbol name
      and one with _imp__ prefixed.  Allowing for the terminating nul's this
      is strlen (symbol_name) * 2 + 8 + 21 + strlen (source_dll).

      The strings in the string table must start STRING__SIZE_SIZE bytes into
      the table in order to for the string lookup code in coffgen/coffcode to
      work.  */
#define NUM_ILF_RELOCS		8
#define NUM_ILF_SECTIONS        6
#define NUM_ILF_SYMS 		(2 + NUM_ILF_SECTIONS)
  
#define SIZEOF_ILF_SYMS		(NUM_ILF_SYMS * sizeof (* vars.sym_cache))
#define SIZEOF_ILF_SYM_TABLE	(NUM_ILF_SYMS * sizeof (* vars.sym_table))
#define SIZEOF_ILF_NATIVE_SYMS	(NUM_ILF_SYMS * sizeof (* vars.native_syms))
#define SIZEOF_ILF_SYM_PTR_TABLE (NUM_ILF_SYMS * sizeof (* vars.sym_ptr_table))
#define SIZEOF_ILF_EXT_SYMS	(NUM_ILF_SYMS * sizeof (* vars.esym_table))
#define SIZEOF_ILF_RELOCS	(NUM_ILF_RELOCS * sizeof (* vars.reltab))
#define SIZEOF_ILF_INT_RELOCS	(NUM_ILF_RELOCS * sizeof (* vars.int_reltab))
#define SIZEOF_ILF_STRINGS	(strlen (symbol_name) * 2 + 8 \
					+ 21 + strlen (source_dll) \
					+ NUM_ILF_SECTIONS * 9 \
					+ STRING_SIZE_SIZE)
#define SIZEOF_IDATA2		(5 * 4)
#define SIZEOF_IDATA4		(1 * 4)
#define SIZEOF_IDATA5		(1 * 4)
#define SIZEOF_IDATA6		(2 + strlen (symbol_name) + 1 + 1)
#define SIZEOF_IDATA7		(strlen (source_dll) + 1 + 1)
#define SIZEOF_ILF_SECTIONS     (NUM_ILF_SECTIONS * sizeof (struct coff_section_tdata))
  
#define ILF_DATA_SIZE				\
      sizeof (* vars.bim)			\
    + SIZEOF_ILF_SYMS				\
    + SIZEOF_ILF_SYM_TABLE			\
    + SIZEOF_ILF_NATIVE_SYMS			\
    + SIZEOF_ILF_SYM_PTR_TABLE			\
    + SIZEOF_ILF_EXT_SYMS			\
    + SIZEOF_ILF_RELOCS				\
    + SIZEOF_ILF_INT_RELOCS			\
    + SIZEOF_ILF_STRINGS			\
    + SIZEOF_IDATA2				\
    + SIZEOF_IDATA4				\
    + SIZEOF_IDATA5				\
    + SIZEOF_IDATA6				\
    + SIZEOF_IDATA7				\
    + SIZEOF_ILF_SECTIONS			\
    + MAX_TEXT_SECTION_SIZE
a752 1
/* Create an empty relocation against the given symbol.  */
d754 4
a757 5
pe_ILF_make_a_symbol_reloc (pe_ILF_vars *                 vars,
			    bfd_vma                       address,
			    bfd_reloc_code_real_type      reloc,
			    struct symbol_cache_entry **  sym,
			    unsigned int                  sym_index)
d759 55
a813 2
  arelent * entry;
  struct internal_reloc * internal;
d815 15
a829 15
  entry = vars->reltab + vars->relcount;
  internal = vars->int_reltab + vars->relcount;
  
  entry->address     = address;
  entry->addend      = 0;
  entry->howto       = bfd_reloc_type_lookup (vars->abfd, reloc);
  entry->sym_ptr_ptr = sym;

  internal->r_vaddr  = address;
  internal->r_symndx = sym_index;
  internal->r_type   = entry->howto->type;
#if 0  /* These fields do not need to be initialised.  */
  internal->r_size   = 0;
  internal->r_extern = 0;
  internal->r_offset = 0;
a830 4
  
  vars->relcount ++;
  
  BFD_ASSERT (vars->relcount <= NUM_ILF_RELOCS);
d833 7
a839 6
/* Create an empty relocation against the given section.  */
static void
pe_ILF_make_a_reloc (pe_ILF_vars *             vars,
		     bfd_vma                   address,
		     bfd_reloc_code_real_type  reloc,
		     asection_ptr              sec)
d841 9
a849 2
  pe_ILF_make_a_symbol_reloc (vars, address, reloc, sec->symbol_ptr_ptr,
			      coff_section_data (vars->abfd, sec)->i);
d852 5
a856 4
/* Move the queued relocs into the given section.  */
static void
pe_ILF_save_relocs (pe_ILF_vars * vars,
		    asection_ptr  sec)
d858 14
a871 4
  /* Make sure that there is somewhere to store the internal relocs.  */
  if (coff_section_data (vars->abfd, sec) == NULL)
    /* We should probably return an error indication here.  */
    abort ();
d873 2
a874 2
  coff_section_data (vars->abfd, sec)->relocs = vars->int_reltab;
  coff_section_data (vars->abfd, sec)->keep_relocs = true;
d876 1
a876 3
  sec->relocation  = vars->reltab;
  sec->reloc_count = vars->relcount;
  sec->flags      |= SEC_RELOC;
d878 1
a878 3
  vars->reltab     += vars->relcount;
  vars->int_reltab += vars->relcount;
  vars->relcount   = 0;
a879 2
  BFD_ASSERT ((bfd_byte *)vars->int_reltab < (bfd_byte *)vars->string_table);
}
d881 8
a888 12
/* Create a global symbol and add it to the relevant tables.  */
static void
pe_ILF_make_a_symbol (pe_ILF_vars *  vars,
		      const char *   prefix,
		      const char *   symbol_name,
		      asection_ptr   section,
		      flagword       extra_flags)
{
  coff_symbol_type * sym;
  combined_entry_type * ent;
  SYMENT * esym;
  unsigned short sclass;
d890 3
a892 15
  if (extra_flags & BSF_LOCAL)
    sclass = C_STAT;
  else
    sclass = C_EXT;
  
#ifdef THUMBPEMAGIC  
  if (vars->magic == THUMBPEMAGIC)
    {
      if (extra_flags & BSF_FUNCTION)
	sclass = C_THUMBEXTFUNC;
      else if (extra_flags & BSF_LOCAL)
	sclass = C_THUMBSTAT;
      else
	sclass = C_THUMBEXT;
    }
d895 1
a895 5
  BFD_ASSERT (vars->sym_index < NUM_ILF_SYMS);
  
  sym = vars->sym_ptr;
  ent = vars->native_ptr;
  esym = vars->esym_ptr;
d897 8
a904 2
  /* Copy the symbol's name into the string table.  */
  sprintf (vars->string_ptr, "%s%s", prefix, symbol_name);
d906 6
a911 15
  if (section == NULL)
    section = (asection_ptr) & bfd_und_section;
  
  /* Initialise the external symbol.  */
  bfd_h_put_32 (vars->abfd, vars->string_ptr - vars->string_table, (bfd_byte *) esym->e.e.e_offset);
  bfd_h_put_16 (vars->abfd, section->target_index, (bfd_byte *) esym->e_scnum);
  esym->e_sclass[0] = sclass;

  /* The following initialisations are unnecessary - the memory is
     zero initialised.  They are just kept here as reminders.  */
#if 0
  esym->e.e.e_zeroes = 0;
  esym->e_value = 0;
  esym->e_type = T_NULL;
  esym->e_numaux = 0;
d913 32
a944 12
  
  /* Initialise the internal symbol structure.  */
  ent->u.syment.n_sclass          = sclass;
  ent->u.syment.n_scnum           = section->target_index;
  ent->u.syment._n._n_n._n_offset = (long) sym;
  
#if 0 /* See comment above.  */
  ent->u.syment.n_value  = 0;
  ent->u.syment.n_flags  = 0;
  ent->u.syment.n_type   = T_NULL;
  ent->u.syment.n_numaux = 0;
  ent->fix_value         = 0;
d946 73
a1018 35
  
  sym->symbol.the_bfd = vars->abfd;
  sym->symbol.name    = vars->string_ptr;
  sym->symbol.flags   = BSF_EXPORT | BSF_GLOBAL | extra_flags;
  sym->symbol.section = section;
  sym->native         = ent;
  
#if 0 /* See comment above.  */
  sym->symbol.value   = 0;
  sym->symbol.udata.i = 0;
  sym->done_lineno    = false;
  sym->lineno         = NULL;
#endif
  
  * vars->table_ptr = vars->sym_index;
  * vars->sym_ptr_ptr = sym;
  
  /* Adjust pointers for the next symbol.  */
  vars->sym_index ++;
  vars->sym_ptr ++;
  vars->sym_ptr_ptr ++;
  vars->table_ptr ++;
  vars->native_ptr ++;
  vars->esym_ptr ++;
  vars->string_ptr += strlen (symbol_name) + strlen (prefix) + 1;

  BFD_ASSERT (vars->string_ptr < vars->end_string_ptr);
}

/* Create a section.  */
static asection_ptr
pe_ILF_make_a_section (pe_ILF_vars * vars,
		       const char *  name,
		       unsigned int  size,
		       flagword      extra_flags)
d1020 2
a1021 21
  asection_ptr sec;
  flagword     flags;
  
  sec = bfd_make_section_old_way (vars->abfd, name);
  if (sec == NULL)
    return NULL;
  
  flags = SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_KEEP | SEC_IN_MEMORY;
  
  bfd_set_section_flags (vars->abfd, sec, flags | extra_flags);
     
  bfd_set_section_alignment (vars->abfd, sec, 2);
  
  /* Check that we will not run out of space.  */
  BFD_ASSERT (vars->data + size < vars->bim->buffer + vars->bim->size);
  
  /* Set the section size and contents.  The actual
     contents are filled in by our parent.  */
  bfd_set_section_size (vars->abfd, sec, size);
  sec->contents = vars->data;
  sec->target_index = vars->sec_index ++;
d1023 14
a1036 13
  /* Advance data pointer in the vars structure.  */
  vars->data += size;
  
  /* Skip the padding byte if it was not needed.
     The logic here is that if the string length is odd,
     then the entire string length, including the null byte,
     is even and so the extra, padding byte, is not needed.  */
  if (size & 1)
    vars->data --;
  
  /* Create a coff_section_tdata structure for our use.  */
  sec->used_by_bfd = (struct coff_section_tdata *) vars->data;
  vars->data += sizeof (struct coff_section_tdata);
d1038 2
a1039 4
  BFD_ASSERT (vars->data <= vars->bim->buffer + vars->bim->size);
  
  /* Create a symbol to refer to this section.  */
  pe_ILF_make_a_symbol (vars, "", name, sec, BSF_LOCAL);
d1041 9
a1049 4
  /* Cache the index to the symbol in the coff_section_data structure.  */
  coff_section_data (vars->abfd, sec)->i = vars->sym_index - 1;
  
  return sec;
d1052 99
a1150 26
/* This structure contains the code that goes into the .text section
   in order to perform a jump into the DLL lookup table.  The entries
   in the table are index by the magic number used to represent the
   machine type in the PE file.  The contents of the data[] arrays in
   these entries are stolen from the jtab[] arrays in ld/pe-dll.c.
   The SIZE field says how many bytes in the DATA array are actually
   used.  The OFFSET field says where in the data array the address
   of the .idata$5 section should be placed.  */
#define MAX_TEXT_SECTION_SIZE 32

typedef struct
{
  unsigned short magic;
  unsigned char  data[MAX_TEXT_SECTION_SIZE];
  unsigned int   size;
  unsigned int   offset;
}
jump_table;

static jump_table jtab[] =
{
#ifdef I386MAGIC
  { I386MAGIC,
    { 0xff, 0x25, 0x00, 0x00, 0x00, 0x00, 0x90, 0x90 },
    8, 2
  },
d1152 95
d1248 23
a1270 33
#ifdef  MC68MAGIC
  { MC68MAGIC, { /* XXX fill me in */ }, 0, 0 },
#endif
#ifdef  MIPS_ARCH_MAGIC_WINCE
  { MIPS_ARCH_MAGIC_WINCE,
    { 0x00, 0x00, 0x08, 0x3c, 0x00, 0x00, 0x08, 0x8d,
      0x08, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 },
    16, 0
  },
#endif
  
#ifdef  SH_ARCH_MAGIC_WINCE
  { SH_ARCH_MAGIC_WINCE,
    { 0x01, 0xd0, 0x02, 0x60, 0x2b, 0x40,
      0x09, 0x00, 0x00, 0x00, 0x00, 0x00 },
    12, 8
  },
#endif
  
#ifdef  ARMPEMAGIC
  { ARMPEMAGIC,
    { 0x00, 0xc0, 0x9f, 0xe5, 0x00, 0xf0,
      0x9c, 0xe5, 0x00, 0x00, 0x00, 0x00},
    12, 8
  },
#endif
  
#ifdef  THUMBPEMAGIC
  { THUMBPEMAGIC,
    { 0x40, 0xb4, 0x02, 0x4e, 0x36, 0x68, 0xb4, 0x46,
      0x40, 0xbc, 0x60, 0x47, 0x00, 0x00, 0x00, 0x00 },
    16, 12
  },
a1271 2
  { 0, { 0 }, 0, 0 }
};
d1273 14
a1286 3
#ifndef NUM_ENTRIES
#define NUM_ENTRIES(a) (sizeof (a) / sizeof (a)[0])
#endif
d1288 24
a1311 27
/* Build a full BFD from the information supplied in a ILF object.  */
static boolean
pe_ILF_build_a_bfd (bfd *           abfd,
		    unsigned short  magic,
		    bfd_byte *      symbol_name,
		    bfd_byte *      source_dll,
		    unsigned int    ordinal,
		    unsigned int    types)
{ 
  bfd_byte *               ptr;
  pe_ILF_vars              vars;
  struct internal_filehdr  internal_f;
  unsigned int             import_type;
  unsigned int             import_name_type;
  asection_ptr             id4, id5, id6 = NULL, text = NULL;
  coff_symbol_type **      imp_sym;
  unsigned int             imp_index;

  /* Decode and verify the types field of the ILF structure.  */
  import_type = types & 0x3;
  import_name_type = (types & 0x1c) >> 2;

  switch (import_type)
    {
    case IMPORT_CODE:
    case IMPORT_DATA:
      break;
d1313 5
a1317 5
    case IMPORT_CONST:
      /* XXX code yet to be written.  */
      _bfd_error_handler (_("%s: Unhandled import type; %x"),
			  bfd_get_filename (abfd), import_type);
      return false;
d1319 88
a1406 4
    default:
      _bfd_error_handler (_("%s: Unrecognised import type; %x"),
			  bfd_get_filename (abfd), import_type);
      return false;
d1409 42
a1450 13
  switch (import_name_type)
    {
    case IMPORT_ORDINAL:
    case IMPORT_NAME:
    case IMPORT_NAME_NOPREFIX:
    case IMPORT_NAME_UNDECORATE:
      break;
      
    default:
      _bfd_error_handler (_("%s: Unrecognised import name type; %x"),
			  bfd_get_filename (abfd), import_name_type);
      return false;
    }
d1452 1
a1452 9
  /* Initialise local variables.
     
     Note these are kept in a structure rather than being
     declared as statics since bfd frowns on global variables.
     
     We are going to construct the contents of the BFD in memory,
     so allocate all the space that we will need right now.  */
  ptr = bfd_zalloc (abfd, ILF_DATA_SIZE);
  if (ptr == NULL)
d1455 87
a1541 71
  /* Create a bfd_in_memory structure.  */
  vars.bim = (struct bfd_in_memory *) ptr;
  vars.bim->buffer = ptr;
  vars.bim->size   = ILF_DATA_SIZE;
  ptr += sizeof (* vars.bim);
  
  /* Initialise the pointers to regions of the memory and the
     other contents of the pe_ILF_vars structure as well.  */
  vars.sym_cache = (coff_symbol_type *) ptr;
  vars.sym_ptr   = (coff_symbol_type *) ptr;
  vars.sym_index = 0;
  ptr += SIZEOF_ILF_SYMS;
  
  vars.sym_table = (unsigned int *) ptr;
  vars.table_ptr = (unsigned int *) ptr;
  ptr += SIZEOF_ILF_SYM_TABLE;

  vars.native_syms = (combined_entry_type *) ptr;
  vars.native_ptr  = (combined_entry_type *) ptr;
  ptr += SIZEOF_ILF_NATIVE_SYMS;

  vars.sym_ptr_table = (coff_symbol_type **) ptr;
  vars.sym_ptr_ptr   = (coff_symbol_type **) ptr;
  ptr += SIZEOF_ILF_SYM_PTR_TABLE;
  
  vars.esym_table = (SYMENT *) ptr;
  vars.esym_ptr   = (SYMENT *) ptr;
  ptr += SIZEOF_ILF_EXT_SYMS;
  
  vars.reltab   = (arelent *) ptr;
  vars.relcount = 0;
  ptr += SIZEOF_ILF_RELOCS;

  vars.int_reltab  = (struct internal_reloc *) ptr;
  ptr += SIZEOF_ILF_INT_RELOCS;

  vars.string_table = ptr;
  vars.string_ptr   = ptr + STRING_SIZE_SIZE;
  ptr += SIZEOF_ILF_STRINGS;
  vars.end_string_ptr = ptr;
  
  /* The remaining space in bim->buffer is used
     by the pe_ILF_make_a_section() function.  */
  vars.data = ptr;
  vars.abfd = abfd;
  vars.sec_index = 0;
  vars.magic = magic;
  
  /* Create the initial .idata$<n> sections:
     [.idata$2:  Import Directory Table -- not needed]
     .idata$4:  Import Lookup Table
     .idata$5:  Import Address Table

     Note we do not create a .idata$3 section as this is
     created for us by the linker script.  */
  id4 = pe_ILF_make_a_section (& vars, ".idata$4", SIZEOF_IDATA4, 0);
  id5 = pe_ILF_make_a_section (& vars, ".idata$5", SIZEOF_IDATA5, 0);
  if (id4 == NULL || id5 == NULL)
    return false;
  
  /* Fill in the contents of these sections.  */
  if (import_name_type == IMPORT_ORDINAL)
    {
      if (ordinal == 0)
	/* XXX - treat as IMPORT_NAME ??? */
	abort ();
      
      * (unsigned int *) id4->contents = ordinal | 0x80000000UL;
      * (unsigned int *) id5->contents = ordinal | 0x80000000UL;
    }
  else
d1543 5
a1547 6
      char * symbol;
      
      /* Create .idata$6 - the Hint Name Table.  */
      id6 = pe_ILF_make_a_section (& vars, ".idata$6", SIZEOF_IDATA6, 0);
      if (id6 == NULL)
	return false;
a1548 2
      /* If necessary, trim the import symbol name.  */
      symbol = symbol_name;
d1550 2
a1551 4
      if (import_name_type != IMPORT_NAME)
	/* Skip any prefix in symbol_name.  */
	while (*symbol == '@@' || * symbol == '?' || * symbol == '_')
	  ++ symbol;
d1553 10
a1562 1
      if (import_name_type == IMPORT_NAME_UNDECORATE)
d1564 4
a1567 5
	  /* Truncate at the first '@@'  */
	  while (* symbol != 0 && * symbol != '@@')
	    symbol ++;

	  * symbol = 0;
a1568 5
      
      id6->contents[0] = ordinal & 0xff;
      id6->contents[1] = ordinal >> 8;
      
      strcpy (id6->contents + 2, symbol);
d1571 21
a1591 7
  if (import_name_type != IMPORT_ORDINAL)
    {
      pe_ILF_make_a_reloc (& vars, 0, BFD_RELOC_RVA, id6);
      pe_ILF_save_relocs (& vars, id4);
      
      pe_ILF_make_a_reloc (& vars, 0, BFD_RELOC_RVA, id6);
      pe_ILF_save_relocs (& vars, id5);
d1594 64
a1657 4
  /* Create extra sections depending upon the type of import we are dealing with.  */
  switch (import_type)
    {
      int i;
d1659 2
a1660 4
    case IMPORT_CODE:
      /* Create a .text section.
	 First we need to look up its contents in the jump table.  */
      for (i = NUM_ENTRIES (jtab); i--;)
d1662 3
a1664 4
	  if (jtab[i].size == 0)
	    continue;
	  if (jtab[i].magic == magic)
	    break;
a1665 8
      /* If we did not find a matching entry something is wrong.  */
      if (i < 0)
	abort ();

      /* Create the .text section.  */
      text = pe_ILF_make_a_section (& vars, ".text", jtab[i].size, SEC_CODE);
      if (text == NULL)
	return false;
d1667 10
a1676 2
      /* Copy in the jump code.  */
      memcpy (text->contents, jtab[i].data, jtab[i].size);
d1678 2
a1679 8
      /* Create an import symbol.  */
      pe_ILF_make_a_symbol (& vars, "__imp_", symbol_name, id5, 0);
      imp_sym   = vars.sym_ptr_ptr - 1;
      imp_index = vars.sym_index - 1;
    
      /* Create a reloc for the data in the text section.  */
#ifdef MIPS_ARCH_MAGIC_WINCE      
      if (magic == MIPS_ARCH_MAGIC_WINCE)
d1681 22
a1702 5
	  pe_ILF_make_a_symbol_reloc (& vars, 0, BFD_RELOC_HI16_S,
				      (asection **) imp_sym, imp_index);
	  pe_ILF_make_a_reloc (& vars, 0, BFD_RELOC_LO16, text);
	  pe_ILF_make_a_symbol_reloc (& vars, 4, BFD_RELOC_LO16,
				      (asection **) imp_sym, imp_index);
d1704 8
a1711 7
      else
#endif
	pe_ILF_make_a_symbol_reloc (& vars, jtab[i].offset, BFD_RELOC_32,
				    (asymbol **) imp_sym, imp_index);
      
      pe_ILF_save_relocs (& vars, text);
      break;
d1713 9
a1721 2
    case IMPORT_DATA:
      break;
d1723 24
a1746 15
    default:
      /* XXX code not yet written.  */
      abort ();
    }
  
  /* Initialise the bfd.  */
  memset (& internal_f, 0, sizeof (internal_f));
  
  internal_f.f_magic  = magic;
  internal_f.f_symptr = 0;
  internal_f.f_nsyms  = 0;
  internal_f.f_flags  = F_AR32WR | F_LNNO; /* XXX is this correct ?  */
  
  if (   ! bfd_set_start_address (abfd, 0)
      || ! bfd_coff_set_arch_mach_hook (abfd, & internal_f))
d1749 6
a1754 2
  if (bfd_coff_mkobject_hook (abfd, (PTR) & internal_f, NULL) == NULL)
    return false;
d1756 1
a1756 14
  coff_data (abfd)->pe = 1;
#ifdef THUMBPEMAGIC  
  if (vars.magic == THUMBPEMAGIC)
    /* Stop some linker warnings about thumb code not supporting interworking.  */
    coff_data (abfd)->flags |= F_INTERWORK | F_INTERWORK_SET;
#endif
    
  /* Switch from file contents to memory contents.  */
  bfd_cache_close (abfd);

  abfd->iostream = (PTR) vars.bim;
  abfd->flags |= BFD_IN_MEMORY /* | HAS_LOCALS */;
  abfd->where = 0;
  obj_sym_filepos (abfd) = 0;
d1758 1
a1758 2
  /* Now create a symbol describing the imported value.  */
  switch (import_type)
d1760 88
a1847 23
      bfd_byte * ptr;
      
    case IMPORT_CODE:
      pe_ILF_make_a_symbol (& vars, "", symbol_name, text,
			    BSF_NOT_AT_END | BSF_FUNCTION);
      
      /* Create an import symbol for the DLL, without the
       .dll suffix.  */
      ptr = strrchr (source_dll, '.');
      if (ptr)
	* ptr = 0;
      pe_ILF_make_a_symbol (& vars, "__IMPORT_DESCRIPTOR_", source_dll, NULL, 0);
      if (ptr)
	* ptr = '.';
      break;

    case IMPORT_DATA:
      /* Nothing to do here.  */
      break;
      
    default:
      /* XXX code not yet written.  */
      abort ();
d1850 15
a1864 6
  /* Point the bfd at the symbol table.  */
  obj_symbols (abfd) = vars.sym_cache;
  bfd_get_symcount (abfd) = vars.sym_index;
  
  obj_raw_syments (abfd) = vars.native_syms;
  obj_raw_syment_count (abfd) = vars.sym_index;
d1866 2
a1867 8
  obj_coff_external_syms (abfd) = (PTR) vars.esym_table;
  obj_coff_keep_syms (abfd) = true;
  
  obj_convert (abfd) = vars.sym_table;
  obj_conv_table_size (abfd) = vars.sym_index;
  
  obj_coff_strings (abfd) = vars.string_table;
  obj_coff_keep_strings (abfd) = true;
d1869 1
a1869 1
  abfd->flags |= HAS_SYMS;
d1871 2
d1876 11
a1886 18
/* We have detected a Image Library Format archive element.
   Decode the element and return the appropriate target.  */
static const bfd_target *
pe_ILF_object_p (bfd * abfd)
{
  bfd_byte        buffer[16];
  bfd_byte *      ptr;
  bfd_byte *      symbol_name;
  bfd_byte *      source_dll;
  unsigned int    machine;
  unsigned long   size;
  unsigned int    ordinal;
  unsigned int    types;
  unsigned short  magic;
  
  /* Upon entry the first four buyes of the ILF header have
      already been read.  Now read the rest of the header.  */
  if (bfd_read (buffer, 1, 16, abfd) != 16)
d1889 16
a1904 5
  ptr = buffer;
  
  /*  We do not bother to check the version number.
      version = bfd_h_get_16 (abfd, ptr);  */
  ptr += 2;
d1906 1
a1906 2
  machine = bfd_h_get_16 (abfd, ptr);
  ptr += 2;
d1908 2
a1909 4
  /* Check that the machine type is recognised.  */
  magic = 0;
  
  switch (machine)
d1911 2
a1912 9
    case IMAGE_FILE_MACHINE_UNKNOWN:
    case IMAGE_FILE_MACHINE_ALPHA:
    case IMAGE_FILE_MACHINE_ALPHA64:
    case IMAGE_FILE_MACHINE_IA64:
      break;
      
    case IMAGE_FILE_MACHINE_I386:
#ifdef I386MAGIC
      magic = I386MAGIC;
a1913 74
      break;
      
    case IMAGE_FILE_MACHINE_M68K:
#ifdef MC68AGIC
      magic = MC68MAGIC;
#endif
      break;
      
    case IMAGE_FILE_MACHINE_R3000:
    case IMAGE_FILE_MACHINE_R4000:
    case IMAGE_FILE_MACHINE_R10000:
      
    case IMAGE_FILE_MACHINE_MIPS16:
    case IMAGE_FILE_MACHINE_MIPSFPU:
    case IMAGE_FILE_MACHINE_MIPSFPU16:
#ifdef MIPS_ARCH_MAGIC_WINCE
      magic = MIPS_ARCH_MAGIC_WINCE;
#endif
      break;
      
    case IMAGE_FILE_MACHINE_SH3:
    case IMAGE_FILE_MACHINE_SH4:
#ifdef SH_ARCH_MAGIC_WINCE
      magic = SH_ARCH_MAGIC_WINCE;
#endif
      break;
      
    case IMAGE_FILE_MACHINE_ARM:
#ifdef ARMPEMAGIC
      magic = ARMPEMAGIC;
#endif      
      break;
      
    case IMAGE_FILE_MACHINE_THUMB:
#ifdef THUMBPEMAGIC
      {
	extern bfd_target armpei_little_vec;
	
	if (abfd->xvec == & armpei_little_vec)
	  magic = THUMBPEMAGIC;
      }
#endif      
      break;
      
    case IMAGE_FILE_MACHINE_POWERPC:
      /* We no longer support PowerPC.  */
    default:
      _bfd_error_handler
	(
_("%s: Unrecognised machine type (0x%x) in Import Library Format archive"),
         bfd_get_filename (abfd), machine);
      bfd_set_error (bfd_error_malformed_archive);
	
      return NULL;
      break;
    }

  if (magic == 0)
    {
      _bfd_error_handler
	(
_("%s: Recognised but unhandled machine type (0x%x) in Import Library Format archive"),
	 bfd_get_filename (abfd), machine);
      bfd_set_error (bfd_error_wrong_format);
	
      return NULL;
    }  

  /* We do not bother to check the date.
     date = bfd_h_get_32 (abfd, ptr);  */
  ptr += 4;
  
  size = bfd_h_get_32 (abfd, ptr);
  ptr += 4;
d1915 7
a1921 9
  if (size == 0)
    {
      _bfd_error_handler
	(_("%s: size field is zero in Import Library Format header"),
	 bfd_get_filename (abfd));
      bfd_set_error (bfd_error_malformed_archive);
	
      return NULL;
    }
d1923 1
a1923 2
  ordinal = bfd_h_get_16 (abfd, ptr);
  ptr += 2;
d1925 8
a1932 2
  types = bfd_h_get_16 (abfd, ptr);
  /* ptr += 2; */
d1934 1
a1934 7
  /* Now read in the two strings that follow.  */
  ptr = bfd_alloc (abfd, size);
  if (ptr == NULL)
    return NULL;
  
  if (bfd_read (ptr, 1, size, abfd) != size)
    return NULL;
d1936 1
a1936 20
  symbol_name = ptr;
  source_dll  = ptr + strlen (ptr) + 1;
  
  /* Verify that the strings are null terminated.  */
  if (ptr[size - 1] != 0 || ((unsigned long) (source_dll - ptr) >= size))
    {
      _bfd_error_handler
	(_("%s: string not null terminated in ILF object file."),
	 bfd_get_filename (abfd));
      bfd_set_error (bfd_error_malformed_archive);
	
      return NULL;
    }
  
  /* Now construct the bfd.  */
  if (! pe_ILF_build_a_bfd (abfd, magic, symbol_name,
			    source_dll, ordinal, types))
    return NULL;
  
  return abfd->xvec;
d1939 3
a1941 35
static const bfd_target *
pe_bfd_object_p (bfd * abfd)
{
  /* We need to handle a PE image correctly.  In PE images created by
     the GNU linker, the offset to the COFF header is always the size.
     However, this is not the case in images generated by other PE
     linkers.  The PE format stores a four byte offset to the PE
     signature just before the COFF header at location 0x3c of the file.
     We pick up that offset, verify that the PE signature is there, and
     then set ourselves up to read in the COFF header.  */
  bfd_byte buffer[4];
  file_ptr offset;
  unsigned long signature;

  /* Detect if this a Microsoft Import Library Format element.  */
  if (bfd_seek (abfd, 0x00, SEEK_SET) != 0
      || bfd_read (buffer, 1, 4, abfd) != 4)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }
  
  signature = bfd_h_get_32 (abfd, buffer);
  
  if (signature == 0xffff0000)
    return pe_ILF_object_p (abfd);
  
  if (bfd_seek (abfd, 0x3c, SEEK_SET) != 0
      || bfd_read (buffer, 1, 4, abfd) != 4)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }
d1943 1
a1943 1
  offset = bfd_h_get_32 (abfd, buffer);
d1945 2
a1946 7
  if (bfd_seek (abfd, offset, SEEK_SET) != 0
      || bfd_read (buffer, 1, 4, abfd) != 4)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }
d1948 10
a1957 1
  signature = bfd_h_get_32 (abfd, buffer);
d1959 2
a1960 1
  if (signature != 0x4550)
d1962 16
a1977 17
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }
  
  /* Here is the hack.  coff_object_p wants to read filhsz bytes to
     pick up the COFF header.  We adjust so that that will work.  20
     is the size of the i386 COFF filehdr.  */
  if (bfd_seek (abfd,
		(bfd_tell (abfd)
		 - bfd_coff_filhsz (abfd)
		 + 20),
		SEEK_SET)
      != 0)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
d1980 1
a1980 1
  return coff_object_p (abfd);
d1983 1
a1983 2
#define coff_object_p pe_bfd_object_p
#endif /* COFF_IMAGE_WITH_PE */
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d72 1
d107 1
a107 1

d114 1
a114 1

d117 1
a117 1

d123 1
a123 1

d129 1
a129 1

d141 1
a141 1
static void		  pe_ILF_make_a_symbol_reloc  PARAMS ((pe_ILF_vars *, bfd_vma, bfd_reloc_code_real_type, struct symbol_cache_entry **, unsigned int));
d170 1
d213 15
d236 1
a236 1
  filehdr_dst->f_opthdr = bfd_h_get_16(abfd,
d241 1
a241 1
# define coff_swap_filehdr_out _bfd_XXi_only_swap_filehdr_out
d243 1
a243 1
# define coff_swap_filehdr_out _bfd_pe_only_swap_filehdr_out
d246 1
d256 1
a256 1
  memcpy(scnhdr_int->s_name, scnhdr_ext->s_name, sizeof (scnhdr_int->s_name));
d286 1
a286 1
  if (scnhdr_int->s_vaddr != 0)
d311 1
a311 1
  abfd->tdata.pe_obj_data =
a322 8

#ifdef PEI_FORCE_MINIMUM_ALIGNMENT
  pe->force_minimum_alignment = 1;
#endif
#ifdef PEI_TARGET_SUBSYSTEM
  pe->target_subsystem = PEI_TARGET_SUBSYSTEM;
#endif

d367 1
a367 1
  if (aouthdr)
d371 1
a371 1
#ifdef ARM
d375 1
a375 1

d386 1
a386 1
  if (!_bfd_XX_print_private_bfd_data_common (abfd, vfile))
d406 1
a406 1
  if (!_bfd_XX_bfd_copy_private_bfd_data_common (ibfd, obfd))
d416 1
a416 1
  _bfd_XX_bfd_copy_private_section_data
d418 1
a418 1
#define coff_get_symbol_info _bfd_XX_get_symbol_info
d424 1
a424 1
   Documentation about this format can be found at:
d450 1
a450 1

d468 1
a468 1

d487 1
d501 1
a501 1

d515 1
a515 1

d517 1
a517 1

d573 2
a574 2

#ifdef THUMBPEMAGIC
d587 1
a587 1

d597 1
a597 1

d611 1
a611 1

d616 1
a616 1

d624 1
a624 1

d630 1
a630 1

d637 1
a637 1

d640 1
a640 1

d662 1
a662 1

d666 1
a666 1

d668 1
a668 1

d670 1
a670 1

d672 1
a672 1

d675 1
a675 1

d684 1
a684 1

d691 1
a691 1

d697 1
a697 1

d703 1
a703 1

d734 1
a734 1

d745 1
a745 1

d753 1
a753 1

d761 1
a761 1

d784 1
a784 1
{
d803 1
a803 1

d809 1
a809 1

d823 1
a823 1

d831 1
a831 1

d834 1
a834 1

d846 1
a846 1

d853 1
a853 1

d865 1
a865 1

d869 1
a869 1

d881 1
a881 1

d888 1
a888 1

d900 1
a900 1

d907 3
a909 3

      * (unsigned int *) id4->contents = ordinal | 0x80000000;
      * (unsigned int *) id5->contents = ordinal | 0x80000000;
d914 1
a914 1

d936 1
a936 1

d939 1
a939 1

d947 1
a947 1

d956 1
a956 1

d983 1
a983 1

d985 1
a985 1
#ifdef MIPS_ARCH_MAGIC_WINCE
d989 1
a989 1
				      (struct symbol_cache_entry **) imp_sym, imp_index);
d992 1
a992 1
				      (struct symbol_cache_entry **) imp_sym, imp_index);
d998 1
a998 1

d1009 1
a1009 1

d1012 1
a1012 1

d1017 1
a1017 1

d1026 1
a1026 1
#ifdef THUMBPEMAGIC
d1031 1
a1031 1

d1044 1
a1044 1

d1048 1
a1048 1

d1062 1
a1062 1

d1071 1
a1071 1

d1077 1
a1077 1

d1080 1
a1080 1

d1103 1
a1103 1

d1110 1
a1110 1

d1120 1
a1120 1

d1128 1
a1128 1

d1134 1
a1134 1

d1140 1
a1140 1

d1144 1
a1144 1

d1152 1
a1152 1

d1159 1
a1159 1

d1163 1
a1163 1
#endif
d1165 1
a1165 1

d1169 3
a1171 3
	extern const bfd_target TARGET_LITTLE_SYM;

	if (abfd->xvec == & TARGET_LITTLE_SYM)
d1174 1
a1174 1
#endif
d1176 1
a1176 1

d1185 1
a1185 1

d1197 1
a1197 1

d1199 1
a1199 1
    }
d1204 1
a1204 1

d1214 1
a1214 1

d1228 1
a1228 1

d1234 1
a1234 1

d1242 1
a1242 1

d1245 1
a1245 1

d1250 1
a1250 1

d1257 7
a1264 2
  struct external_PEI_DOS_hdr dos_hdr;
  struct external_PEI_IMAGE_hdr image_hdr;
d1266 1
d1276 4
a1279 2

  if (bfd_h_get_32 (abfd, buffer) == 0xffff0000)
d1281 3
a1283 4

  if (bfd_seek (abfd, 0x00, SEEK_SET) != 0
      || bfd_read (&dos_hdr, 1, sizeof (dos_hdr), abfd)
	 != sizeof (dos_hdr))
d1290 1
a1290 15
  /* There are really two magic numbers involved; the magic number
     that says this is a NT executable (PEI) and the magic number that
     determines the architecture.  The former is DOSMAGIC, stored in
     the e_magic field.  The latter is stored in the f_magic field.
     If the NT magic number isn't valid, the architecture magic number
     could be mimicked by some other field (specifically, the number
     of relocs in section 3).  Since this routine can only be called
     correctly for a PEI file, check the e_magic number here, and, if
     it doesn't match, clobber the f_magic number so that we don't get
     a false match.  */
  if (bfd_h_get_16 (abfd, (bfd_byte *) dos_hdr.e_magic) != DOSMAGIC)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }
d1292 2
a1293 4
  offset = bfd_h_get_32 (abfd, (bfd_byte *) dos_hdr.e_lfanew);
  if (bfd_seek (abfd, (file_ptr) offset, SEEK_SET) != 0
      || bfd_read (&image_hdr, 1, sizeof (image_hdr), abfd)
	 != sizeof (image_hdr))
d1300 3
a1302 2
  if (bfd_h_get_32 (abfd, (bfd_byte *) image_hdr.nt_signature)
      != 0x4550)
d1307 1
a1307 1

d1309 2
a1310 2
     pick up the COFF header for PE, see "struct external_PEI_filehdr"
     in include/coff/pe.h.  We adjust so that that will work. */
d1312 3
a1314 1
		(file_ptr) (offset - sizeof (dos_hdr)),
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d22 2
a23 1
/* Most of this hacked by  Steve Chamberlain,
d26 3
a28 2
   PE/PEI rearrangement (and code added): Donn Terry
                                       Softway Systems, Inc.  */
d56 2
a57 1
   wasting too much time.  */
d61 1
a61 1
static bfd_boolean (*pe_saved_coff_bfd_print_private_bfd_data)
d70 1
a70 1
static bfd_boolean pe_print_private_bfd_data PARAMS ((bfd *, PTR));
d73 1
a73 1
static bfd_boolean (*pe_saved_coff_bfd_copy_private_bfd_data)
d82 1
a82 1
static bfd_boolean pe_bfd_copy_private_bfd_data PARAMS ((bfd *, bfd *));
d94 1
a94 1
static bfd_boolean pe_mkobject PARAMS ((bfd *));
d142 1
a142 1
static bfd_boolean        pe_ILF_build_a_bfd      PARAMS ((bfd *, unsigned int, bfd_byte *, bfd_byte *, unsigned int, unsigned int));
d159 2
a160 2
  reloc_dst->r_vaddr = H_GET_32 (abfd, reloc_src->r_vaddr);
  reloc_dst->r_symndx = H_GET_S32 (abfd, reloc_src->r_symndx);
d162 1
a162 1
  reloc_dst->r_type = H_GET_16 (abfd, reloc_src->r_type);
d165 2
a166 1
  reloc_dst->r_offset = SWAP_IN_RELOC_OFFSET (abfd, reloc_src->r_offset);
d178 2
a179 2
  H_PUT_32 (abfd, reloc_src->r_vaddr, reloc_dst->r_vaddr);
  H_PUT_32 (abfd, reloc_src->r_symndx, reloc_dst->r_symndx);
d181 2
a182 1
  H_PUT_16 (abfd, reloc_src->r_type, reloc_dst->r_type);
d185 3
a187 1
  SWAP_OUT_RELOC_OFFSET (abfd, reloc_src->r_offset, reloc_dst->r_offset);
d190 1
a190 1
  SWAP_OUT_RELOC_EXTRA(abfd, reloc_src, reloc_dst);
d204 7
a210 7
  filehdr_dst->f_magic = H_GET_16 (abfd, filehdr_src->f_magic);
  filehdr_dst->f_nscns = H_GET_16 (abfd, filehdr_src-> f_nscns);
  filehdr_dst->f_timdat = H_GET_32 (abfd, filehdr_src-> f_timdat);

  filehdr_dst->f_nsyms = H_GET_32 (abfd, filehdr_src-> f_nsyms);
  filehdr_dst->f_flags = H_GET_16 (abfd, filehdr_src-> f_flags);
  filehdr_dst->f_symptr = H_GET_32 (abfd, filehdr_src->f_symptr);
d220 2
a221 1
  filehdr_dst->f_opthdr = H_GET_16 (abfd, filehdr_src-> f_opthdr);
d240 13
a252 7
  scnhdr_int->s_vaddr = GET_SCNHDR_VADDR (abfd, scnhdr_ext->s_vaddr);
  scnhdr_int->s_paddr = GET_SCNHDR_PADDR (abfd, scnhdr_ext->s_paddr);
  scnhdr_int->s_size = GET_SCNHDR_SIZE (abfd, scnhdr_ext->s_size);
  scnhdr_int->s_scnptr = GET_SCNHDR_SCNPTR (abfd, scnhdr_ext->s_scnptr);
  scnhdr_int->s_relptr = GET_SCNHDR_RELPTR (abfd, scnhdr_ext->s_relptr);
  scnhdr_int->s_lnnoptr = GET_SCNHDR_LNNOPTR (abfd, scnhdr_ext->s_lnnoptr);
  scnhdr_int->s_flags = H_GET_32 (abfd, scnhdr_ext->s_flags);
d258 3
a260 2
  scnhdr_int->s_nlnno = (H_GET_16 (abfd, scnhdr_ext->s_nlnno)
			 + (H_GET_16 (abfd, scnhdr_ext->s_nreloc) << 16));
d263 4
a266 2
  scnhdr_int->s_nreloc = H_GET_16 (abfd, scnhdr_ext->s_nreloc);
  scnhdr_int->s_nlnno = H_GET_16 (abfd, scnhdr_ext->s_nlnno);
d276 3
a278 8
  /* If this section holds uninitialized data and is from an object file
     or from an executable image that has not initialized the field,
     or if the physical size is padded, use the virtual size (stored in
     s_paddr) instead.  */
  if (scnhdr_int->s_paddr > 0
      && (((scnhdr_int->s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) != 0
          && (! bfd_pe_executable_p (abfd) || scnhdr_int->s_size == 0))
          || scnhdr_int->s_size > scnhdr_int->s_paddr))
a280 1

d289 1
a289 1
static bfd_boolean
d294 2
a295 3
  bfd_size_type amt = sizeof (pe_data_type);

  abfd->tdata.pe_obj_data = (struct pe_tdata *) bfd_zalloc (abfd, amt);
d298 1
a298 1
    return FALSE;
d314 1
a314 1
  return TRUE;
d327 1
a327 1
  if (! pe_mkobject (abfd))
d370 1
a370 1
static bfd_boolean
d378 1
a378 1
    return FALSE;
d387 1
a387 1
  return TRUE;
d393 1
a393 1
static bfd_boolean
d398 1
a398 1
    return FALSE;
d403 1
a403 1
  return TRUE;
d533 1
a533 1
  coff_section_data (vars->abfd, sec)->keep_relocs = TRUE;
d543 1
a543 1
  BFD_ASSERT ((bfd_byte *) vars->int_reltab < (bfd_byte *) vars->string_table);
d589 2
a590 3
  H_PUT_32 (vars->abfd, vars->string_ptr - vars->string_table,
	    esym->e.e.e_offset);
  H_PUT_16 (vars->abfd, section->target_index, esym->e_scnum);
d624 1
a624 1
  sym->done_lineno    = FALSE;
d668 1
a668 1
  bfd_set_section_size (vars->abfd, sec, (bfd_size_type) size);
d767 1
a767 1
static bfd_boolean
d769 1
a769 1
		    unsigned int    magic,
d797 2
a798 2
			  bfd_archive_filename (abfd), import_type);
      return FALSE;
d802 2
a803 2
			  bfd_archive_filename (abfd), import_type);
      return FALSE;
d816 2
a817 2
			  bfd_archive_filename (abfd), import_name_type);
      return FALSE;
d827 1
a827 1
  ptr = bfd_zalloc (abfd, (bfd_size_type) ILF_DATA_SIZE);
d829 1
a829 1
    return FALSE;
d889 1
a889 1
    return FALSE;
d908 1
a908 1
	return FALSE;
d935 2
a936 2
      pe_ILF_make_a_reloc (&vars, (bfd_vma) 0, BFD_RELOC_RVA, id6);
      pe_ILF_save_relocs (&vars, id4);
d938 2
a939 2
      pe_ILF_make_a_reloc (&vars, (bfd_vma) 0, BFD_RELOC_RVA, id6);
      pe_ILF_save_relocs (&vars, id5);
d964 1
a964 1
	return FALSE;
d978 5
a982 7
	  pe_ILF_make_a_symbol_reloc (&vars, (bfd_vma) 0, BFD_RELOC_HI16_S,
				      (struct symbol_cache_entry **) imp_sym,
				      imp_index);
	  pe_ILF_make_a_reloc (&vars, (bfd_vma) 0, BFD_RELOC_LO16, text);
	  pe_ILF_make_a_symbol_reloc (&vars, (bfd_vma) 4, BFD_RELOC_LO16,
				      (struct symbol_cache_entry **) imp_sym,
				      imp_index);
d986 2
a987 3
	pe_ILF_make_a_symbol_reloc (&vars, (bfd_vma) jtab[i].offset,
				    BFD_RELOC_32, (asymbol **) imp_sym,
				    imp_index);
d1008 1
a1008 1
  if (   ! bfd_set_start_address (abfd, (bfd_vma) 0)
d1010 1
a1010 1
    return FALSE;
d1013 1
a1013 1
    return FALSE;
d1033 2
d1066 1
a1066 1
  obj_coff_keep_syms (abfd) = TRUE;
d1072 1
a1072 1
  obj_coff_keep_strings (abfd) = TRUE;
d1076 1
a1076 1
  return TRUE;
d1089 1
a1089 1
  bfd_size_type   size;
d1092 1
a1092 1
  unsigned int    magic;
d1096 1
a1096 1
  if (bfd_bread (buffer, (bfd_size_type) 16, abfd) != 16)
d1102 1
a1102 1
      version = H_GET_16 (abfd, ptr);  */
d1105 1
a1105 1
  machine = H_GET_16 (abfd, ptr);
d1173 1
a1173 1
         bfd_archive_filename (abfd), machine);
d1185 1
a1185 1
	 bfd_archive_filename (abfd), machine);
d1192 1
a1192 1
     date = H_GET_32 (abfd, ptr);  */
d1195 1
a1195 1
  size = H_GET_32 (abfd, ptr);
d1202 1
a1202 1
	 bfd_archive_filename (abfd));
d1208 1
a1208 1
  ordinal = H_GET_16 (abfd, ptr);
d1211 1
a1211 1
  types = H_GET_16 (abfd, ptr);
d1219 2
a1220 5
  if (bfd_bread (ptr, size, abfd) != size)
    {
      bfd_release (abfd, ptr);
      return NULL;
    }
d1230 1
a1230 1
	 bfd_archive_filename (abfd));
d1232 1
a1232 1
      bfd_release (abfd, ptr);
d1239 1
a1239 4
    {
      bfd_release (abfd, ptr);
      return NULL;
    }
d1253 2
a1254 2
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
      || bfd_bread (buffer, (bfd_size_type) 4, abfd) != 4)
d1261 1
a1261 1
  if (H_GET_32 (abfd, buffer) == 0xffff0000)
d1264 2
a1265 2
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
      || bfd_bread (&dos_hdr, (bfd_size_type) sizeof (dos_hdr), abfd)
d1283 1
a1283 1
  if (H_GET_16 (abfd, dos_hdr.e_magic) != DOSMAGIC)
d1289 4
a1292 4
  offset = H_GET_32 (abfd, dos_hdr.e_lfanew);
  if (bfd_seek (abfd, offset, SEEK_SET) != 0
      || (bfd_bread (&image_hdr, (bfd_size_type) sizeof (image_hdr), abfd)
	  != sizeof (image_hdr)))
d1299 2
a1300 1
  if (H_GET_32 (abfd, image_hdr.nt_signature) != 0x4550)
d1309 4
a1312 1
  if (bfd_seek (abfd, (file_ptr) (offset - sizeof (dos_hdr)), SEEK_SET) != 0)
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d138 1
a138 1
static void		  pe_ILF_make_a_symbol_reloc  PARAMS ((pe_ILF_vars *, bfd_vma, bfd_reloc_code_real_type, struct bfd_symbol **, unsigned int));
d261 2
a262 2
     or if the image is an executable file and the physical size is padded,
     use the virtual size (stored in s_paddr) instead.  */
d265 2
a266 2
	   && (! bfd_pe_executable_p (abfd) || scnhdr_int->s_size == 0))
          || (bfd_pe_executable_p (abfd) && scnhdr_int->s_size > scnhdr_int->s_paddr)))
d473 1
a473 1
			    struct bfd_symbol **  sym,
d905 4
a908 34
	{
	  bfd_boolean skipped_leading_underscore = FALSE;
	  bfd_boolean skipped_leading_at = FALSE;
	  bfd_boolean skipped_leading_question_mark = FALSE;
	  bfd_boolean check_again;
	  
	  /* Skip any prefix in symbol_name.  */
	  -- symbol;
	  do
	    {
	      check_again = FALSE;
	      ++ symbol;

	      switch (*symbol)
		{
		case '@@':
		  if (! skipped_leading_at)
		    check_again = skipped_leading_at = TRUE;
		  break;
		case '?':
		  if (! skipped_leading_question_mark)
		    check_again = skipped_leading_question_mark = TRUE;
		  break;
		case '_':
		  if (! skipped_leading_underscore)
		    check_again = skipped_leading_underscore = TRUE;
		  break;
		default:
		  break;
		}
	    }
	  while (check_again);
	}
      
d970 1
a970 1
				      (struct bfd_symbol **) imp_sym,
d974 1
a974 1
				      (struct bfd_symbol **) imp_sym,
@


