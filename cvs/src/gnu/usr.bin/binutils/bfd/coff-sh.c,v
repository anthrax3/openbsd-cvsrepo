head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.54
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.52
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.11.02.20.45.04;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.20;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.29;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.08;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.32.48;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.18.59.47;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.43.50;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.33;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.33;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.05.07;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.37.14;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.12.08;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.18.15;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.28;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.21.22;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.11;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.15;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD back-end for Renesas Super-H COFF binaries.
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Contributed by Cygnus Support.
   Written by Steve Chamberlain, <sac@@cygnus.com>.
   Relaxing code written by Ian Lance Taylor, <ian@@cygnus.com>.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "libiberty.h"
#include "libbfd.h"
#include "bfdlink.h"
#include "coff/sh.h"
#include "coff/internal.h"

#ifdef COFF_WITH_PE
#include "coff/pe.h"

#ifndef COFF_IMAGE_WITH_PE
static bfd_boolean sh_align_load_span
  PARAMS ((bfd *, asection *, bfd_byte *,
	   bfd_boolean (*) (bfd *, asection *, PTR, bfd_byte *, bfd_vma),
	   PTR, bfd_vma **, bfd_vma *, bfd_vma, bfd_vma, bfd_boolean *));

#define _bfd_sh_align_load_span sh_align_load_span
#endif
#endif

#include "libcoff.h"

/* Internal functions.  */
static bfd_reloc_status_type sh_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static long get_symbol_value PARAMS ((asymbol *));
static bfd_boolean sh_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean sh_relax_delete_bytes
  PARAMS ((bfd *, asection *, bfd_vma, int));
#ifndef COFF_IMAGE_WITH_PE
static const struct sh_opcode *sh_insn_info PARAMS ((unsigned int));
#endif
static bfd_boolean sh_align_loads
  PARAMS ((bfd *, asection *, struct internal_reloc *, bfd_byte *,
	   bfd_boolean *));
static bfd_boolean sh_swap_insns
  PARAMS ((bfd *, asection *, PTR, bfd_byte *, bfd_vma));
static bfd_boolean sh_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   struct internal_reloc *, struct internal_syment *, asection **));
static bfd_byte *sh_coff_get_relocated_section_contents
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *,
	   bfd_byte *, bfd_boolean, asymbol **));
static reloc_howto_type * sh_coff_reloc_type_lookup PARAMS ((bfd *, bfd_reloc_code_real_type));

#ifdef COFF_WITH_PE
/* Can't build import tables with 2**4 alignment.  */
#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER	2
#else
/* Default section alignment to 2**4.  */
#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER	4
#endif

#ifdef COFF_IMAGE_WITH_PE
/* Align PE executables.  */
#define COFF_PAGE_SIZE 0x1000
#endif

/* Generate long file names.  */
#define COFF_LONG_FILENAMES

#ifdef COFF_WITH_PE
static bfd_boolean in_reloc_p PARAMS ((bfd *, reloc_howto_type *));
/* Return TRUE if this relocation should
   appear in the output .reloc section.  */
static bfd_boolean in_reloc_p (abfd, howto)
     bfd * abfd ATTRIBUTE_UNUSED;
     reloc_howto_type * howto;
{
  return ! howto->pc_relative && howto->type != R_SH_IMAGEBASE;
}
#endif

/* The supported relocations.  There are a lot of relocations defined
   in coff/internal.h which we do not expect to ever see.  */
static reloc_howto_type sh_coff_howtos[] =
{
  EMPTY_HOWTO (0),
  EMPTY_HOWTO (1),
#ifdef COFF_WITH_PE
  /* Windows CE */
  HOWTO (R_SH_IMM32CE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_imm32ce",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
#else
  EMPTY_HOWTO (2),
#endif
  EMPTY_HOWTO (3), /* R_SH_PCREL8 */
  EMPTY_HOWTO (4), /* R_SH_PCREL16 */
  EMPTY_HOWTO (5), /* R_SH_HIGH8 */
  EMPTY_HOWTO (6), /* R_SH_IMM24 */
  EMPTY_HOWTO (7), /* R_SH_LOW16 */
  EMPTY_HOWTO (8),
  EMPTY_HOWTO (9), /* R_SH_PCDISP8BY4 */

  HOWTO (R_SH_PCDISP8BY2,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_pcdisp8by2",	/* name */
	 TRUE,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  EMPTY_HOWTO (11), /* R_SH_PCDISP8 */

  HOWTO (R_SH_PCDISP,		/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_pcdisp12by2",	/* name */
	 TRUE,			/* partial_inplace */
	 0xfff,			/* src_mask */
	 0xfff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  EMPTY_HOWTO (13),

  HOWTO (R_SH_IMM32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_imm32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (15),
#ifdef COFF_WITH_PE
  HOWTO (R_SH_IMAGEBASE,        /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,       	/* special_function */
	 "rva32",	        /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 FALSE),                /* pcrel_offset */
#else
  EMPTY_HOWTO (16), /* R_SH_IMM8 */
#endif
  EMPTY_HOWTO (17), /* R_SH_IMM8BY2 */
  EMPTY_HOWTO (18), /* R_SH_IMM8BY4 */
  EMPTY_HOWTO (19), /* R_SH_IMM4 */
  EMPTY_HOWTO (20), /* R_SH_IMM4BY2 */
  EMPTY_HOWTO (21), /* R_SH_IMM4BY4 */

  HOWTO (R_SH_PCRELIMM8BY2,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_pcrelimm8by2",	/* name */
	 TRUE,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_SH_PCRELIMM8BY4,	/* type */
	 2,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_pcrelimm8by4",	/* name */
	 TRUE,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_SH_IMM16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_imm16",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_SWITCH16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_switch16",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_SWITCH32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_switch32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_USES,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_uses",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_COUNT,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_count",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_ALIGN,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_align",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_CODE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_code",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DATA,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_data",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_LABEL,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_label",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_SWITCH8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_switch8",		/* name */
	 TRUE,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
	 FALSE)			/* pcrel_offset */
};

#define SH_COFF_HOWTO_COUNT (sizeof sh_coff_howtos / sizeof sh_coff_howtos[0])

/* Check for a bad magic number.  */
#define BADMAG(x) SHBADMAG(x)

/* Customize coffcode.h (this is not currently used).  */
#define SH 1

/* FIXME: This should not be set here.  */
#define __A_MAGIC_SET__

#ifndef COFF_WITH_PE
/* Swap the r_offset field in and out.  */
#define SWAP_IN_RELOC_OFFSET  H_GET_32
#define SWAP_OUT_RELOC_OFFSET H_PUT_32

/* Swap out extra information in the reloc structure.  */
#define SWAP_OUT_RELOC_EXTRA(abfd, src, dst)	\
  do						\
    {						\
      dst->r_stuff[0] = 'S';			\
      dst->r_stuff[1] = 'C';			\
    }						\
  while (0)
#endif

/* Get the value of a symbol, when performing a relocation.  */

static long
get_symbol_value (symbol)
     asymbol *symbol;
{
  bfd_vma relocation;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = (symbol->value +
		  symbol->section->output_section->vma +
		  symbol->section->output_offset);

  return relocation;
}

#ifdef COFF_WITH_PE
/* Convert an rtype to howto for the COFF backend linker.
   Copied from coff-i386.  */
#define coff_rtype_to_howto coff_sh_rtype_to_howto
static reloc_howto_type * coff_sh_rtype_to_howto PARAMS ((bfd *, asection *, struct internal_reloc *, struct coff_link_hash_entry *, struct internal_syment *, bfd_vma *));

static reloc_howto_type *
coff_sh_rtype_to_howto (abfd, sec, rel, h, sym, addendp)
     bfd * abfd ATTRIBUTE_UNUSED;
     asection * sec;
     struct internal_reloc * rel;
     struct coff_link_hash_entry * h;
     struct internal_syment * sym;
     bfd_vma * addendp;
{
  reloc_howto_type * howto;

  howto = sh_coff_howtos + rel->r_type;

  *addendp = 0;

  if (howto->pc_relative)
    *addendp += sec->vma;

  if (sym != NULL && sym->n_scnum == 0 && sym->n_value != 0)
    {
      /* This is a common symbol.  The section contents include the
	 size (sym->n_value) as an addend.  The relocate_section
	 function will be adding in the final value of the symbol.  We
	 need to subtract out the current size in order to get the
	 correct result.  */
      BFD_ASSERT (h != NULL);
    }

  if (howto->pc_relative)
    {
      *addendp -= 4;

      /* If the symbol is defined, then the generic code is going to
         add back the symbol value in order to cancel out an
         adjustment it made to the addend.  However, we set the addend
         to 0 at the start of this function.  We need to adjust here,
         to avoid the adjustment the generic code will make.  FIXME:
         This is getting a bit hackish.  */
      if (sym != NULL && sym->n_scnum != 0)
	*addendp -= sym->n_value;
    }

  if (rel->r_type == R_SH_IMAGEBASE)
    *addendp -= pe_data (sec->output_section->owner)->pe_opthdr.ImageBase;

  return howto;
}

#endif /* COFF_WITH_PE */

/* This structure is used to map BFD reloc codes to SH PE relocs.  */
struct shcoff_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_val;
  unsigned char shcoff_reloc_val;
};

#ifdef COFF_WITH_PE
/* An array mapping BFD reloc codes to SH PE relocs.  */
static const struct shcoff_reloc_map sh_reloc_map[] =
{
  { BFD_RELOC_32, R_SH_IMM32CE },
  { BFD_RELOC_RVA, R_SH_IMAGEBASE },
  { BFD_RELOC_CTOR, R_SH_IMM32CE },
};
#else
/* An array mapping BFD reloc codes to SH PE relocs.  */
static const struct shcoff_reloc_map sh_reloc_map[] =
{
  { BFD_RELOC_32, R_SH_IMM32 },
  { BFD_RELOC_CTOR, R_SH_IMM32 },
};
#endif

/* Given a BFD reloc code, return the howto structure for the
   corresponding SH PE reloc.  */
#define coff_bfd_reloc_type_lookup	sh_coff_reloc_type_lookup

static reloc_howto_type *
sh_coff_reloc_type_lookup (abfd, code)
     bfd * abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
{
  unsigned int i;

  for (i = ARRAY_SIZE (sh_reloc_map); i--;)
    if (sh_reloc_map[i].bfd_reloc_val == code)
      return &sh_coff_howtos[(int) sh_reloc_map[i].shcoff_reloc_val];

  fprintf (stderr, "SH Error: unknown reloc type %d\n", code);
  return NULL;
}

/* This macro is used in coffcode.h to get the howto corresponding to
   an internal reloc.  */

#define RTYPE2HOWTO(relent, internal)		\
  ((relent)->howto =				\
   ((internal)->r_type < SH_COFF_HOWTO_COUNT	\
    ? &sh_coff_howtos[(internal)->r_type]	\
    : (reloc_howto_type *) NULL))

/* This is the same as the macro in coffcode.h, except that it copies
   r_offset into reloc_entry->addend for some relocs.  */
#define CALC_ADDEND(abfd, ptr, reloc, cache_ptr)                \
  {                                                             \
    coff_symbol_type *coffsym = (coff_symbol_type *) NULL;      \
    if (ptr && bfd_asymbol_bfd (ptr) != abfd)                   \
      coffsym = (obj_symbols (abfd)                             \
                 + (cache_ptr->sym_ptr_ptr - symbols));         \
    else if (ptr)                                               \
      coffsym = coff_symbol_from (abfd, ptr);                   \
    if (coffsym != (coff_symbol_type *) NULL                    \
        && coffsym->native->u.syment.n_scnum == 0)              \
      cache_ptr->addend = 0;                                    \
    else if (ptr && bfd_asymbol_bfd (ptr) == abfd               \
             && ptr->section != (asection *) NULL)              \
      cache_ptr->addend = - (ptr->section->vma + ptr->value);   \
    else                                                        \
      cache_ptr->addend = 0;                                    \
    if ((reloc).r_type == R_SH_SWITCH8				\
	|| (reloc).r_type == R_SH_SWITCH16			\
	|| (reloc).r_type == R_SH_SWITCH32			\
	|| (reloc).r_type == R_SH_USES				\
	|| (reloc).r_type == R_SH_COUNT				\
	|| (reloc).r_type == R_SH_ALIGN)			\
      cache_ptr->addend = (reloc).r_offset;			\
  }

/* This is the howto function for the SH relocations.  */

static bfd_reloc_status_type
sh_reloc (abfd, reloc_entry, symbol_in, data, input_section, output_bfd,
	  error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol_in;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  unsigned long insn;
  bfd_vma sym_value;
  unsigned short r_type;
  bfd_vma addr = reloc_entry->address;
  bfd_byte *hit_data = addr + (bfd_byte *) data;

  r_type = reloc_entry->howto->type;

  if (output_bfd != NULL)
    {
      /* Partial linking--do nothing.  */
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* Almost all relocs have to do with relaxing.  If any work must be
     done for them, it has been done in sh_relax_section.  */
  if (r_type != R_SH_IMM32
#ifdef COFF_WITH_PE
      && r_type != R_SH_IMM32CE
      && r_type != R_SH_IMAGEBASE
#endif
      && (r_type != R_SH_PCDISP
	  || (symbol_in->flags & BSF_LOCAL) != 0))
    return bfd_reloc_ok;

  if (symbol_in != NULL
      && bfd_is_und_section (symbol_in->section))
    return bfd_reloc_undefined;

  sym_value = get_symbol_value (symbol_in);

  switch (r_type)
    {
    case R_SH_IMM32:
#ifdef COFF_WITH_PE
    case R_SH_IMM32CE:
#endif
      insn = bfd_get_32 (abfd, hit_data);
      insn += sym_value + reloc_entry->addend;
      bfd_put_32 (abfd, (bfd_vma) insn, hit_data);
      break;
#ifdef COFF_WITH_PE
    case R_SH_IMAGEBASE:
      insn = bfd_get_32 (abfd, hit_data);
      insn += sym_value + reloc_entry->addend;
      insn -= pe_data (input_section->output_section->owner)->pe_opthdr.ImageBase;
      bfd_put_32 (abfd, (bfd_vma) insn, hit_data);
      break;
#endif
    case R_SH_PCDISP:
      insn = bfd_get_16 (abfd, hit_data);
      sym_value += reloc_entry->addend;
      sym_value -= (input_section->output_section->vma
		    + input_section->output_offset
		    + addr
		    + 4);
      sym_value += (insn & 0xfff) << 1;
      if (insn & 0x800)
	sym_value -= 0x1000;
      insn = (insn & 0xf000) | (sym_value & 0xfff);
      bfd_put_16 (abfd, (bfd_vma) insn, hit_data);
      if (sym_value < (bfd_vma) -0x1000 || sym_value >= 0x1000)
	return bfd_reloc_overflow;
      break;
    default:
      abort ();
      break;
    }

  return bfd_reloc_ok;
}

#define coff_bfd_merge_private_bfd_data _bfd_generic_verify_endian_match

/* We can do relaxing.  */
#define coff_bfd_relax_section sh_relax_section

/* We use the special COFF backend linker.  */
#define coff_relocate_section sh_relocate_section

/* When relaxing, we need to use special code to get the relocated
   section contents.  */
#define coff_bfd_get_relocated_section_contents \
  sh_coff_get_relocated_section_contents

#include "coffcode.h"

/* This function handles relaxing on the SH.

   Function calls on the SH look like this:

       movl  L1,r0
       ...
       jsr   @@r0
       ...
     L1:
       .long function

   The compiler and assembler will cooperate to create R_SH_USES
   relocs on the jsr instructions.  The r_offset field of the
   R_SH_USES reloc is the PC relative offset to the instruction which
   loads the register (the r_offset field is computed as though it
   were a jump instruction, so the offset value is actually from four
   bytes past the instruction).  The linker can use this reloc to
   determine just which function is being called, and thus decide
   whether it is possible to replace the jsr with a bsr.

   If multiple function calls are all based on a single register load
   (i.e., the same function is called multiple times), the compiler
   guarantees that each function call will have an R_SH_USES reloc.
   Therefore, if the linker is able to convert each R_SH_USES reloc
   which refers to that address, it can safely eliminate the register
   load.

   When the assembler creates an R_SH_USES reloc, it examines it to
   determine which address is being loaded (L1 in the above example).
   It then counts the number of references to that address, and
   creates an R_SH_COUNT reloc at that address.  The r_offset field of
   the R_SH_COUNT reloc will be the number of references.  If the
   linker is able to eliminate a register load, it can use the
   R_SH_COUNT reloc to see whether it can also eliminate the function
   address.

   SH relaxing also handles another, unrelated, matter.  On the SH, if
   a load or store instruction is not aligned on a four byte boundary,
   the memory cycle interferes with the 32 bit instruction fetch,
   causing a one cycle bubble in the pipeline.  Therefore, we try to
   align load and store instructions on four byte boundaries if we
   can, by swapping them with one of the adjacent instructions.  */

static bfd_boolean
sh_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
{
  struct internal_reloc *internal_relocs;
  struct internal_reloc *free_relocs = NULL;
  bfd_boolean have_code;
  struct internal_reloc *irel, *irelend;
  bfd_byte *contents = NULL;
  bfd_byte *free_contents = NULL;

  *again = FALSE;

  if (link_info->relocatable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0)
    return TRUE;

  /* If this is the first time we have been called for this section,
     initialize the cooked size.  */
  if (sec->_cooked_size == 0)
    sec->_cooked_size = sec->_raw_size;

  internal_relocs = (_bfd_coff_read_internal_relocs
		     (abfd, sec, link_info->keep_memory,
		      (bfd_byte *) NULL, FALSE,
		      (struct internal_reloc *) NULL));
  if (internal_relocs == NULL)
    goto error_return;
  if (! link_info->keep_memory)
    free_relocs = internal_relocs;

  have_code = FALSE;

  irelend = internal_relocs + sec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma laddr, paddr, symval;
      unsigned short insn;
      struct internal_reloc *irelfn, *irelscan, *irelcount;
      struct internal_syment sym;
      bfd_signed_vma foff;

      if (irel->r_type == R_SH_CODE)
	have_code = TRUE;

      if (irel->r_type != R_SH_USES)
	continue;

      /* Get the section contents.  */
      if (contents == NULL)
	{
	  if (coff_section_data (abfd, sec) != NULL
	      && coff_section_data (abfd, sec)->contents != NULL)
	    contents = coff_section_data (abfd, sec)->contents;
	  else
	    {
	      contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
	      if (contents == NULL)
		goto error_return;
	      free_contents = contents;

	      if (! bfd_get_section_contents (abfd, sec, contents,
					      (file_ptr) 0, sec->_raw_size))
		goto error_return;
	    }
	}

      /* The r_offset field of the R_SH_USES reloc will point us to
         the register load.  The 4 is because the r_offset field is
         computed as though it were a jump offset, which are based
         from 4 bytes after the jump instruction.  */
      laddr = irel->r_vaddr - sec->vma + 4;
      /* Careful to sign extend the 32-bit offset.  */
      laddr += ((irel->r_offset & 0xffffffff) ^ 0x80000000) - 0x80000000;
      if (laddr >= sec->_raw_size)
	{
	  (*_bfd_error_handler) ("%s: 0x%lx: warning: bad R_SH_USES offset",
				 bfd_archive_filename (abfd),
				 (unsigned long) irel->r_vaddr);
	  continue;
	}
      insn = bfd_get_16 (abfd, contents + laddr);

      /* If the instruction is not mov.l NN,rN, we don't know what to do.  */
      if ((insn & 0xf000) != 0xd000)
	{
	  ((*_bfd_error_handler)
	   ("%s: 0x%lx: warning: R_SH_USES points to unrecognized insn 0x%x",
	    bfd_archive_filename (abfd), (unsigned long) irel->r_vaddr, insn));
	  continue;
	}

      /* Get the address from which the register is being loaded.  The
      	 displacement in the mov.l instruction is quadrupled.  It is a
      	 displacement from four bytes after the movl instruction, but,
      	 before adding in the PC address, two least significant bits
      	 of the PC are cleared.  We assume that the section is aligned
      	 on a four byte boundary.  */
      paddr = insn & 0xff;
      paddr *= 4;
      paddr += (laddr + 4) &~ (bfd_vma) 3;
      if (paddr >= sec->_raw_size)
	{
	  ((*_bfd_error_handler)
	   ("%s: 0x%lx: warning: bad R_SH_USES load offset",
	    bfd_archive_filename (abfd), (unsigned long) irel->r_vaddr));
	  continue;
	}

      /* Get the reloc for the address from which the register is
         being loaded.  This reloc will tell us which function is
         actually being called.  */
      paddr += sec->vma;
      for (irelfn = internal_relocs; irelfn < irelend; irelfn++)
	if (irelfn->r_vaddr == paddr
#ifdef COFF_WITH_PE
	    && (irelfn->r_type == R_SH_IMM32
		|| irelfn->r_type == R_SH_IMM32CE
		|| irelfn->r_type == R_SH_IMAGEBASE))

#else
	    && irelfn->r_type == R_SH_IMM32)
#endif
	  break;
      if (irelfn >= irelend)
	{
	  ((*_bfd_error_handler)
	   ("%s: 0x%lx: warning: could not find expected reloc",
	    bfd_archive_filename (abfd), (unsigned long) paddr));
	  continue;
	}

      /* Get the value of the symbol referred to by the reloc.  */
      if (! _bfd_coff_get_external_symbols (abfd))
	goto error_return;
      bfd_coff_swap_sym_in (abfd,
			    ((bfd_byte *) obj_coff_external_syms (abfd)
			     + (irelfn->r_symndx
				* bfd_coff_symesz (abfd))),
			    &sym);
      if (sym.n_scnum != 0 && sym.n_scnum != sec->target_index)
	{
	  ((*_bfd_error_handler)
	   ("%s: 0x%lx: warning: symbol in unexpected section",
	    bfd_archive_filename (abfd), (unsigned long) paddr));
	  continue;
	}

      if (sym.n_sclass != C_EXT)
	{
	  symval = (sym.n_value
		    - sec->vma
		    + sec->output_section->vma
		    + sec->output_offset);
	}
      else
	{
	  struct coff_link_hash_entry *h;

	  h = obj_coff_sym_hashes (abfd)[irelfn->r_symndx];
	  BFD_ASSERT (h != NULL);
	  if (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	    {
	      /* This appears to be a reference to an undefined
                 symbol.  Just ignore it--it will be caught by the
                 regular reloc processing.  */
	      continue;
	    }

	  symval = (h->root.u.def.value
		    + h->root.u.def.section->output_section->vma
		    + h->root.u.def.section->output_offset);
	}

      symval += bfd_get_32 (abfd, contents + paddr - sec->vma);

      /* See if this function call can be shortened.  */
      foff = (symval
	      - (irel->r_vaddr
		 - sec->vma
		 + sec->output_section->vma
		 + sec->output_offset
		 + 4));
      if (foff < -0x1000 || foff >= 0x1000)
	{
	  /* After all that work, we can't shorten this function call.  */
	  continue;
	}

      /* Shorten the function call.  */

      /* For simplicity of coding, we are going to modify the section
	 contents, the section relocs, and the BFD symbol table.  We
	 must tell the rest of the code not to free up this
	 information.  It would be possible to instead create a table
	 of changes which have to be made, as is done in coff-mips.c;
	 that would be more work, but would require less memory when
	 the linker is run.  */

      if (coff_section_data (abfd, sec) == NULL)
	{
	  bfd_size_type amt = sizeof (struct coff_section_tdata);
	  sec->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
	  if (sec->used_by_bfd == NULL)
	    goto error_return;
	}

      coff_section_data (abfd, sec)->relocs = internal_relocs;
      coff_section_data (abfd, sec)->keep_relocs = TRUE;
      free_relocs = NULL;

      coff_section_data (abfd, sec)->contents = contents;
      coff_section_data (abfd, sec)->keep_contents = TRUE;
      free_contents = NULL;

      obj_coff_keep_syms (abfd) = TRUE;

      /* Replace the jsr with a bsr.  */

      /* Change the R_SH_USES reloc into an R_SH_PCDISP reloc, and
         replace the jsr with a bsr.  */
      irel->r_type = R_SH_PCDISP;
      irel->r_symndx = irelfn->r_symndx;
      if (sym.n_sclass != C_EXT)
	{
	  /* If this needs to be changed because of future relaxing,
             it will be handled here like other internal PCDISP
             relocs.  */
	  bfd_put_16 (abfd,
		      (bfd_vma) 0xb000 | ((foff >> 1) & 0xfff),
		      contents + irel->r_vaddr - sec->vma);
	}
      else
	{
	  /* We can't fully resolve this yet, because the external
             symbol value may be changed by future relaxing.  We let
             the final link phase handle it.  */
	  bfd_put_16 (abfd, (bfd_vma) 0xb000,
		      contents + irel->r_vaddr - sec->vma);
	}

      /* See if there is another R_SH_USES reloc referring to the same
         register load.  */
      for (irelscan = internal_relocs; irelscan < irelend; irelscan++)
	if (irelscan->r_type == R_SH_USES
	    && laddr == irelscan->r_vaddr - sec->vma + 4 + irelscan->r_offset)
	  break;
      if (irelscan < irelend)
	{
	  /* Some other function call depends upon this register load,
	     and we have not yet converted that function call.
	     Indeed, we may never be able to convert it.  There is
	     nothing else we can do at this point.  */
	  continue;
	}

      /* Look for a R_SH_COUNT reloc on the location where the
         function address is stored.  Do this before deleting any
         bytes, to avoid confusion about the address.  */
      for (irelcount = internal_relocs; irelcount < irelend; irelcount++)
	if (irelcount->r_vaddr == paddr
	    && irelcount->r_type == R_SH_COUNT)
	  break;

      /* Delete the register load.  */
      if (! sh_relax_delete_bytes (abfd, sec, laddr, 2))
	goto error_return;

      /* That will change things, so, just in case it permits some
         other function call to come within range, we should relax
         again.  Note that this is not required, and it may be slow.  */
      *again = TRUE;

      /* Now check whether we got a COUNT reloc.  */
      if (irelcount >= irelend)
	{
	  ((*_bfd_error_handler)
	   ("%s: 0x%lx: warning: could not find expected COUNT reloc",
	    bfd_archive_filename (abfd), (unsigned long) paddr));
	  continue;
	}

      /* The number of uses is stored in the r_offset field.  We've
         just deleted one.  */
      if (irelcount->r_offset == 0)
	{
	  ((*_bfd_error_handler) ("%s: 0x%lx: warning: bad count",
				  bfd_archive_filename (abfd),
				  (unsigned long) paddr));
	  continue;
	}

      --irelcount->r_offset;

      /* If there are no more uses, we can delete the address.  Reload
         the address from irelfn, in case it was changed by the
         previous call to sh_relax_delete_bytes.  */
      if (irelcount->r_offset == 0)
	{
	  if (! sh_relax_delete_bytes (abfd, sec,
				       irelfn->r_vaddr - sec->vma, 4))
	    goto error_return;
	}

      /* We've done all we can with that function call.  */
    }

  /* Look for load and store instructions that we can align on four
     byte boundaries.  */
  if (have_code)
    {
      bfd_boolean swapped;

      /* Get the section contents.  */
      if (contents == NULL)
	{
	  if (coff_section_data (abfd, sec) != NULL
	      && coff_section_data (abfd, sec)->contents != NULL)
	    contents = coff_section_data (abfd, sec)->contents;
	  else
	    {
	      contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
	      if (contents == NULL)
		goto error_return;
	      free_contents = contents;

	      if (! bfd_get_section_contents (abfd, sec, contents,
					      (file_ptr) 0, sec->_raw_size))
		goto error_return;
	    }
	}

      if (! sh_align_loads (abfd, sec, internal_relocs, contents, &swapped))
	goto error_return;

      if (swapped)
	{
	  if (coff_section_data (abfd, sec) == NULL)
	    {
	      bfd_size_type amt = sizeof (struct coff_section_tdata);
	      sec->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
	      if (sec->used_by_bfd == NULL)
		goto error_return;
	    }

	  coff_section_data (abfd, sec)->relocs = internal_relocs;
	  coff_section_data (abfd, sec)->keep_relocs = TRUE;
	  free_relocs = NULL;

	  coff_section_data (abfd, sec)->contents = contents;
	  coff_section_data (abfd, sec)->keep_contents = TRUE;
	  free_contents = NULL;

	  obj_coff_keep_syms (abfd) = TRUE;
	}
    }

  if (free_relocs != NULL)
    {
      free (free_relocs);
      free_relocs = NULL;
    }

  if (free_contents != NULL)
    {
      if (! link_info->keep_memory)
	free (free_contents);
      else
	{
	  /* Cache the section contents for coff_link_input_bfd.  */
	  if (coff_section_data (abfd, sec) == NULL)
	    {
	      bfd_size_type amt = sizeof (struct coff_section_tdata);
	      sec->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
	      if (sec->used_by_bfd == NULL)
		goto error_return;
	      coff_section_data (abfd, sec)->relocs = NULL;
	    }
	  coff_section_data (abfd, sec)->contents = contents;
	}
    }

  return TRUE;

 error_return:
  if (free_relocs != NULL)
    free (free_relocs);
  if (free_contents != NULL)
    free (free_contents);
  return FALSE;
}

/* Delete some bytes from a section while relaxing.  */

static bfd_boolean
sh_relax_delete_bytes (abfd, sec, addr, count)
     bfd *abfd;
     asection *sec;
     bfd_vma addr;
     int count;
{
  bfd_byte *contents;
  struct internal_reloc *irel, *irelend;
  struct internal_reloc *irelalign;
  bfd_vma toaddr;
  bfd_byte *esym, *esymend;
  bfd_size_type symesz;
  struct coff_link_hash_entry **sym_hash;
  asection *o;

  contents = coff_section_data (abfd, sec)->contents;

  /* The deletion must stop at the next ALIGN reloc for an aligment
     power larger than the number of bytes we are deleting.  */

  irelalign = NULL;
  toaddr = sec->_cooked_size;

  irel = coff_section_data (abfd, sec)->relocs;
  irelend = irel + sec->reloc_count;
  for (; irel < irelend; irel++)
    {
      if (irel->r_type == R_SH_ALIGN
	  && irel->r_vaddr - sec->vma > addr
	  && count < (1 << irel->r_offset))
	{
	  irelalign = irel;
	  toaddr = irel->r_vaddr - sec->vma;
	  break;
	}
    }

  /* Actually delete the bytes.  */
  memmove (contents + addr, contents + addr + count,
	   (size_t) (toaddr - addr - count));
  if (irelalign == NULL)
    sec->_cooked_size -= count;
  else
    {
      int i;

#define NOP_OPCODE (0x0009)

      BFD_ASSERT ((count & 1) == 0);
      for (i = 0; i < count; i += 2)
	bfd_put_16 (abfd, (bfd_vma) NOP_OPCODE, contents + toaddr - count + i);
    }

  /* Adjust all the relocs.  */
  for (irel = coff_section_data (abfd, sec)->relocs; irel < irelend; irel++)
    {
      bfd_vma nraddr, stop;
      bfd_vma start = 0;
      int insn = 0;
      struct internal_syment sym;
      int off, adjust, oinsn;
      bfd_signed_vma voff = 0;
      bfd_boolean overflow;

      /* Get the new reloc address.  */
      nraddr = irel->r_vaddr - sec->vma;
      if ((irel->r_vaddr - sec->vma > addr
	   && irel->r_vaddr - sec->vma < toaddr)
	  || (irel->r_type == R_SH_ALIGN
	      && irel->r_vaddr - sec->vma == toaddr))
	nraddr -= count;

      /* See if this reloc was for the bytes we have deleted, in which
	 case we no longer care about it.  Don't delete relocs which
	 represent addresses, though.  */
      if (irel->r_vaddr - sec->vma >= addr
	  && irel->r_vaddr - sec->vma < addr + count
	  && irel->r_type != R_SH_ALIGN
	  && irel->r_type != R_SH_CODE
	  && irel->r_type != R_SH_DATA
	  && irel->r_type != R_SH_LABEL)
	irel->r_type = R_SH_UNUSED;

      /* If this is a PC relative reloc, see if the range it covers
         includes the bytes we have deleted.  */
      switch (irel->r_type)
	{
	default:
	  break;

	case R_SH_PCDISP8BY2:
	case R_SH_PCDISP:
	case R_SH_PCRELIMM8BY2:
	case R_SH_PCRELIMM8BY4:
	  start = irel->r_vaddr - sec->vma;
	  insn = bfd_get_16 (abfd, contents + nraddr);
	  break;
	}

      switch (irel->r_type)
	{
	default:
	  start = stop = addr;
	  break;

	case R_SH_IMM32:
#ifdef COFF_WITH_PE
	case R_SH_IMM32CE:
	case R_SH_IMAGEBASE:
#endif
	  /* If this reloc is against a symbol defined in this
             section, and the symbol will not be adjusted below, we
             must check the addend to see it will put the value in
             range to be adjusted, and hence must be changed.  */
	  bfd_coff_swap_sym_in (abfd,
				((bfd_byte *) obj_coff_external_syms (abfd)
				 + (irel->r_symndx
				    * bfd_coff_symesz (abfd))),
				&sym);
	  if (sym.n_sclass != C_EXT
	      && sym.n_scnum == sec->target_index
	      && ((bfd_vma) sym.n_value <= addr
		  || (bfd_vma) sym.n_value >= toaddr))
	    {
	      bfd_vma val;

	      val = bfd_get_32 (abfd, contents + nraddr);
	      val += sym.n_value;
	      if (val > addr && val < toaddr)
		bfd_put_32 (abfd, val - count, contents + nraddr);
	    }
	  start = stop = addr;
	  break;

	case R_SH_PCDISP8BY2:
	  off = insn & 0xff;
	  if (off & 0x80)
	    off -= 0x100;
	  stop = (bfd_vma) ((bfd_signed_vma) start + 4 + off * 2);
	  break;

	case R_SH_PCDISP:
	  bfd_coff_swap_sym_in (abfd,
				((bfd_byte *) obj_coff_external_syms (abfd)
				 + (irel->r_symndx
				    * bfd_coff_symesz (abfd))),
				&sym);
	  if (sym.n_sclass == C_EXT)
	    start = stop = addr;
	  else
	    {
	      off = insn & 0xfff;
	      if (off & 0x800)
		off -= 0x1000;
	      stop = (bfd_vma) ((bfd_signed_vma) start + 4 + off * 2);
	    }
	  break;

	case R_SH_PCRELIMM8BY2:
	  off = insn & 0xff;
	  stop = start + 4 + off * 2;
	  break;

	case R_SH_PCRELIMM8BY4:
	  off = insn & 0xff;
	  stop = (start &~ (bfd_vma) 3) + 4 + off * 4;
	  break;

	case R_SH_SWITCH8:
	case R_SH_SWITCH16:
	case R_SH_SWITCH32:
	  /* These relocs types represent
	       .word L2-L1
	     The r_offset field holds the difference between the reloc
	     address and L1.  That is the start of the reloc, and
	     adding in the contents gives us the top.  We must adjust
	     both the r_offset field and the section contents.  */

	  start = irel->r_vaddr - sec->vma;
	  stop = (bfd_vma) ((bfd_signed_vma) start - (long) irel->r_offset);

	  if (start > addr
	      && start < toaddr
	      && (stop <= addr || stop >= toaddr))
	    irel->r_offset += count;
	  else if (stop > addr
		   && stop < toaddr
		   && (start <= addr || start >= toaddr))
	    irel->r_offset -= count;

	  start = stop;

	  if (irel->r_type == R_SH_SWITCH16)
	    voff = bfd_get_signed_16 (abfd, contents + nraddr);
	  else if (irel->r_type == R_SH_SWITCH8)
	    voff = bfd_get_8 (abfd, contents + nraddr);
	  else
	    voff = bfd_get_signed_32 (abfd, contents + nraddr);
	  stop = (bfd_vma) ((bfd_signed_vma) start + voff);

	  break;

	case R_SH_USES:
	  start = irel->r_vaddr - sec->vma;
	  stop = (bfd_vma) ((bfd_signed_vma) start
			    + (long) irel->r_offset
			    + 4);
	  break;
	}

      if (start > addr
	  && start < toaddr
	  && (stop <= addr || stop >= toaddr))
	adjust = count;
      else if (stop > addr
	       && stop < toaddr
	       && (start <= addr || start >= toaddr))
	adjust = - count;
      else
	adjust = 0;

      if (adjust != 0)
	{
	  oinsn = insn;
	  overflow = FALSE;
	  switch (irel->r_type)
	    {
	    default:
	      abort ();
	      break;

	    case R_SH_PCDISP8BY2:
	    case R_SH_PCRELIMM8BY2:
	      insn += adjust / 2;
	      if ((oinsn & 0xff00) != (insn & 0xff00))
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, contents + nraddr);
	      break;

	    case R_SH_PCDISP:
	      insn += adjust / 2;
	      if ((oinsn & 0xf000) != (insn & 0xf000))
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, contents + nraddr);
	      break;

	    case R_SH_PCRELIMM8BY4:
	      BFD_ASSERT (adjust == count || count >= 4);
	      if (count >= 4)
		insn += adjust / 4;
	      else
		{
		  if ((irel->r_vaddr & 3) == 0)
		    ++insn;
		}
	      if ((oinsn & 0xff00) != (insn & 0xff00))
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, contents + nraddr);
	      break;

	    case R_SH_SWITCH8:
	      voff += adjust;
	      if (voff < 0 || voff >= 0xff)
		overflow = TRUE;
	      bfd_put_8 (abfd, (bfd_vma) voff, contents + nraddr);
	      break;

	    case R_SH_SWITCH16:
	      voff += adjust;
	      if (voff < - 0x8000 || voff >= 0x8000)
		overflow = TRUE;
	      bfd_put_signed_16 (abfd, (bfd_vma) voff, contents + nraddr);
	      break;

	    case R_SH_SWITCH32:
	      voff += adjust;
	      bfd_put_signed_32 (abfd, (bfd_vma) voff, contents + nraddr);
	      break;

	    case R_SH_USES:
	      irel->r_offset += adjust;
	      break;
	    }

	  if (overflow)
	    {
	      ((*_bfd_error_handler)
	       ("%s: 0x%lx: fatal: reloc overflow while relaxing",
		bfd_archive_filename (abfd), (unsigned long) irel->r_vaddr));
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	}

      irel->r_vaddr = nraddr + sec->vma;
    }

  /* Look through all the other sections.  If there contain any IMM32
     relocs against internal symbols which we are not going to adjust
     below, we may need to adjust the addends.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      struct internal_reloc *internal_relocs;
      struct internal_reloc *irelscan, *irelscanend;
      bfd_byte *ocontents;

      if (o == sec
	  || (o->flags & SEC_RELOC) == 0
	  || o->reloc_count == 0)
	continue;

      /* We always cache the relocs.  Perhaps, if info->keep_memory is
         FALSE, we should free them, if we are permitted to, when we
         leave sh_coff_relax_section.  */
      internal_relocs = (_bfd_coff_read_internal_relocs
			 (abfd, o, TRUE, (bfd_byte *) NULL, FALSE,
			  (struct internal_reloc *) NULL));
      if (internal_relocs == NULL)
	return FALSE;

      ocontents = NULL;
      irelscanend = internal_relocs + o->reloc_count;
      for (irelscan = internal_relocs; irelscan < irelscanend; irelscan++)
	{
	  struct internal_syment sym;

#ifdef COFF_WITH_PE
	  if (irelscan->r_type != R_SH_IMM32
	      && irelscan->r_type != R_SH_IMAGEBASE
	      && irelscan->r_type != R_SH_IMM32CE)
#else
	  if (irelscan->r_type != R_SH_IMM32)
#endif
	    continue;

	  bfd_coff_swap_sym_in (abfd,
				((bfd_byte *) obj_coff_external_syms (abfd)
				 + (irelscan->r_symndx
				    * bfd_coff_symesz (abfd))),
				&sym);
	  if (sym.n_sclass != C_EXT
	      && sym.n_scnum == sec->target_index
	      && ((bfd_vma) sym.n_value <= addr
		  || (bfd_vma) sym.n_value >= toaddr))
	    {
	      bfd_vma val;

	      if (ocontents == NULL)
		{
		  if (coff_section_data (abfd, o)->contents != NULL)
		    ocontents = coff_section_data (abfd, o)->contents;
		  else
		    {
		      /* We always cache the section contents.
                         Perhaps, if info->keep_memory is FALSE, we
                         should free them, if we are permitted to,
                         when we leave sh_coff_relax_section.  */
		      ocontents = (bfd_byte *) bfd_malloc (o->_raw_size);
		      if (ocontents == NULL)
			return FALSE;
		      if (! bfd_get_section_contents (abfd, o, ocontents,
						      (file_ptr) 0,
						      o->_raw_size))
			return FALSE;
		      coff_section_data (abfd, o)->contents = ocontents;
		    }
		}

	      val = bfd_get_32 (abfd, ocontents + irelscan->r_vaddr - o->vma);
	      val += sym.n_value;
	      if (val > addr && val < toaddr)
		bfd_put_32 (abfd, val - count,
			    ocontents + irelscan->r_vaddr - o->vma);

	      coff_section_data (abfd, o)->keep_contents = TRUE;
	    }
	}
    }

  /* Adjusting the internal symbols will not work if something has
     already retrieved the generic symbols.  It would be possible to
     make this work by adjusting the generic symbols at the same time.
     However, this case should not arise in normal usage.  */
  if (obj_symbols (abfd) != NULL
      || obj_raw_syments (abfd) != NULL)
    {
      ((*_bfd_error_handler)
       ("%s: fatal: generic symbols retrieved before relaxing",
	bfd_archive_filename (abfd)));
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  /* Adjust all the symbols.  */
  sym_hash = obj_coff_sym_hashes (abfd);
  symesz = bfd_coff_symesz (abfd);
  esym = (bfd_byte *) obj_coff_external_syms (abfd);
  esymend = esym + obj_raw_syment_count (abfd) * symesz;
  while (esym < esymend)
    {
      struct internal_syment isym;

      bfd_coff_swap_sym_in (abfd, (PTR) esym, (PTR) &isym);

      if (isym.n_scnum == sec->target_index
	  && (bfd_vma) isym.n_value > addr
	  && (bfd_vma) isym.n_value < toaddr)
	{
	  isym.n_value -= count;

	  bfd_coff_swap_sym_out (abfd, (PTR) &isym, (PTR) esym);

	  if (*sym_hash != NULL)
	    {
	      BFD_ASSERT ((*sym_hash)->root.type == bfd_link_hash_defined
			  || (*sym_hash)->root.type == bfd_link_hash_defweak);
	      BFD_ASSERT ((*sym_hash)->root.u.def.value >= addr
			  && (*sym_hash)->root.u.def.value < toaddr);
	      (*sym_hash)->root.u.def.value -= count;
	    }
	}

      esym += (isym.n_numaux + 1) * symesz;
      sym_hash += isym.n_numaux + 1;
    }

  /* See if we can move the ALIGN reloc forward.  We have adjusted
     r_vaddr for it already.  */
  if (irelalign != NULL)
    {
      bfd_vma alignto, alignaddr;

      alignto = BFD_ALIGN (toaddr, 1 << irelalign->r_offset);
      alignaddr = BFD_ALIGN (irelalign->r_vaddr - sec->vma,
			     1 << irelalign->r_offset);
      if (alignto != alignaddr)
	{
	  /* Tail recursion.  */
	  return sh_relax_delete_bytes (abfd, sec, alignaddr,
					(int) (alignto - alignaddr));
	}
    }

  return TRUE;
}

/* This is yet another version of the SH opcode table, used to rapidly
   get information about a particular instruction.  */

/* The opcode map is represented by an array of these structures.  The
   array is indexed by the high order four bits in the instruction.  */

struct sh_major_opcode
{
  /* A pointer to the instruction list.  This is an array which
     contains all the instructions with this major opcode.  */
  const struct sh_minor_opcode *minor_opcodes;
  /* The number of elements in minor_opcodes.  */
  unsigned short count;
};

/* This structure holds information for a set of SH opcodes.  The
   instruction code is anded with the mask value, and the resulting
   value is used to search the order opcode list.  */

struct sh_minor_opcode
{
  /* The sorted opcode list.  */
  const struct sh_opcode *opcodes;
  /* The number of elements in opcodes.  */
  unsigned short count;
  /* The mask value to use when searching the opcode list.  */
  unsigned short mask;
};

/* This structure holds information for an SH instruction.  An array
   of these structures is sorted in order by opcode.  */

struct sh_opcode
{
  /* The code for this instruction, after it has been anded with the
     mask value in the sh_major_opcode structure.  */
  unsigned short opcode;
  /* Flags for this instruction.  */
  unsigned long flags;
};

/* Flag which appear in the sh_opcode structure.  */

/* This instruction loads a value from memory.  */
#define LOAD (0x1)

/* This instruction stores a value to memory.  */
#define STORE (0x2)

/* This instruction is a branch.  */
#define BRANCH (0x4)

/* This instruction has a delay slot.  */
#define DELAY (0x8)

/* This instruction uses the value in the register in the field at
   mask 0x0f00 of the instruction.  */
#define USES1 (0x10)
#define USES1_REG(x) ((x & 0x0f00) >> 8)

/* This instruction uses the value in the register in the field at
   mask 0x00f0 of the instruction.  */
#define USES2 (0x20)
#define USES2_REG(x) ((x & 0x00f0) >> 4)

/* This instruction uses the value in register 0.  */
#define USESR0 (0x40)

/* This instruction sets the value in the register in the field at
   mask 0x0f00 of the instruction.  */
#define SETS1 (0x80)
#define SETS1_REG(x) ((x & 0x0f00) >> 8)

/* This instruction sets the value in the register in the field at
   mask 0x00f0 of the instruction.  */
#define SETS2 (0x100)
#define SETS2_REG(x) ((x & 0x00f0) >> 4)

/* This instruction sets register 0.  */
#define SETSR0 (0x200)

/* This instruction sets a special register.  */
#define SETSSP (0x400)

/* This instruction uses a special register.  */
#define USESSP (0x800)

/* This instruction uses the floating point register in the field at
   mask 0x0f00 of the instruction.  */
#define USESF1 (0x1000)
#define USESF1_REG(x) ((x & 0x0f00) >> 8)

/* This instruction uses the floating point register in the field at
   mask 0x00f0 of the instruction.  */
#define USESF2 (0x2000)
#define USESF2_REG(x) ((x & 0x00f0) >> 4)

/* This instruction uses floating point register 0.  */
#define USESF0 (0x4000)

/* This instruction sets the floating point register in the field at
   mask 0x0f00 of the instruction.  */
#define SETSF1 (0x8000)
#define SETSF1_REG(x) ((x & 0x0f00) >> 8)

#define USESAS (0x10000)
#define USESAS_REG(x) (((((x) >> 8) - 2) & 3) + 2)
#define USESR8 (0x20000)
#define SETSAS (0x40000)
#define SETSAS_REG(x) USESAS_REG (x)

#define MAP(a) a, sizeof a / sizeof a[0]

#ifndef COFF_IMAGE_WITH_PE
static bfd_boolean sh_insn_uses_reg
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int));
static bfd_boolean sh_insn_sets_reg
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int));
static bfd_boolean sh_insn_uses_or_sets_reg
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int));
static bfd_boolean sh_insn_uses_freg
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int));
static bfd_boolean sh_insn_sets_freg
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int));
static bfd_boolean sh_insn_uses_or_sets_freg
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int));
static bfd_boolean sh_insns_conflict
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int,
	   const struct sh_opcode *));
static bfd_boolean sh_load_use
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int,
	   const struct sh_opcode *));

/* The opcode maps.  */

static const struct sh_opcode sh_opcode00[] =
{
  { 0x0008, SETSSP },			/* clrt */
  { 0x0009, 0 },			/* nop */
  { 0x000b, BRANCH | DELAY | USESSP },	/* rts */
  { 0x0018, SETSSP },			/* sett */
  { 0x0019, SETSSP },			/* div0u */
  { 0x001b, 0 },			/* sleep */
  { 0x0028, SETSSP },			/* clrmac */
  { 0x002b, BRANCH | DELAY | SETSSP },	/* rte */
  { 0x0038, USESSP | SETSSP },		/* ldtlb */
  { 0x0048, SETSSP },			/* clrs */
  { 0x0058, SETSSP }			/* sets */
};

static const struct sh_opcode sh_opcode01[] =
{
  { 0x0003, BRANCH | DELAY | USES1 | SETSSP },	/* bsrf rn */
  { 0x000a, SETS1 | USESSP },			/* sts mach,rn */
  { 0x001a, SETS1 | USESSP },			/* sts macl,rn */
  { 0x0023, BRANCH | DELAY | USES1 },		/* braf rn */
  { 0x0029, SETS1 | USESSP },			/* movt rn */
  { 0x002a, SETS1 | USESSP },			/* sts pr,rn */
  { 0x005a, SETS1 | USESSP },			/* sts fpul,rn */
  { 0x006a, SETS1 | USESSP },			/* sts fpscr,rn / sts dsr,rn */
  { 0x0083, LOAD | USES1 },			/* pref @@rn */
  { 0x007a, SETS1 | USESSP },			/* sts a0,rn */
  { 0x008a, SETS1 | USESSP },			/* sts x0,rn */
  { 0x009a, SETS1 | USESSP },			/* sts x1,rn */
  { 0x00aa, SETS1 | USESSP },			/* sts y0,rn */
  { 0x00ba, SETS1 | USESSP }			/* sts y1,rn */
};

/* These sixteen instructions can be handled with one table entry below.  */
#if 0
  { 0x0002, SETS1 | USESSP },			/* stc sr,rn */
  { 0x0012, SETS1 | USESSP },			/* stc gbr,rn */
  { 0x0022, SETS1 | USESSP },			/* stc vbr,rn */
  { 0x0032, SETS1 | USESSP },			/* stc ssr,rn */
  { 0x0042, SETS1 | USESSP },			/* stc spc,rn */
  { 0x0052, SETS1 | USESSP },			/* stc mod,rn */
  { 0x0062, SETS1 | USESSP },			/* stc rs,rn */
  { 0x0072, SETS1 | USESSP },			/* stc re,rn */
  { 0x0082, SETS1 | USESSP },			/* stc r0_bank,rn */
  { 0x0092, SETS1 | USESSP },			/* stc r1_bank,rn */
  { 0x00a2, SETS1 | USESSP },			/* stc r2_bank,rn */
  { 0x00b2, SETS1 | USESSP },			/* stc r3_bank,rn */
  { 0x00c2, SETS1 | USESSP },			/* stc r4_bank,rn */
  { 0x00d2, SETS1 | USESSP },			/* stc r5_bank,rn */
  { 0x00e2, SETS1 | USESSP },			/* stc r6_bank,rn */
  { 0x00f2, SETS1 | USESSP }			/* stc r7_bank,rn */
#endif

static const struct sh_opcode sh_opcode02[] =
{
  { 0x0002, SETS1 | USESSP },			/* stc <special_reg>,rn */
  { 0x0004, STORE | USES1 | USES2 | USESR0 },	/* mov.b rm,@@(r0,rn) */
  { 0x0005, STORE | USES1 | USES2 | USESR0 },	/* mov.w rm,@@(r0,rn) */
  { 0x0006, STORE | USES1 | USES2 | USESR0 },	/* mov.l rm,@@(r0,rn) */
  { 0x0007, SETSSP | USES1 | USES2 },		/* mul.l rm,rn */
  { 0x000c, LOAD | SETS1 | USES2 | USESR0 },	/* mov.b @@(r0,rm),rn */
  { 0x000d, LOAD | SETS1 | USES2 | USESR0 },	/* mov.w @@(r0,rm),rn */
  { 0x000e, LOAD | SETS1 | USES2 | USESR0 },	/* mov.l @@(r0,rm),rn */
  { 0x000f, LOAD|SETS1|SETS2|SETSSP|USES1|USES2|USESSP }, /* mac.l @@rm+,@@rn+ */
};

static const struct sh_minor_opcode sh_opcode0[] =
{
  { MAP (sh_opcode00), 0xffff },
  { MAP (sh_opcode01), 0xf0ff },
  { MAP (sh_opcode02), 0xf00f }
};

static const struct sh_opcode sh_opcode10[] =
{
  { 0x1000, STORE | USES1 | USES2 }	/* mov.l rm,@@(disp,rn) */
};

static const struct sh_minor_opcode sh_opcode1[] =
{
  { MAP (sh_opcode10), 0xf000 }
};

static const struct sh_opcode sh_opcode20[] =
{
  { 0x2000, STORE | USES1 | USES2 },		/* mov.b rm,@@rn */
  { 0x2001, STORE | USES1 | USES2 },		/* mov.w rm,@@rn */
  { 0x2002, STORE | USES1 | USES2 },		/* mov.l rm,@@rn */
  { 0x2004, STORE | SETS1 | USES1 | USES2 },	/* mov.b rm,@@-rn */
  { 0x2005, STORE | SETS1 | USES1 | USES2 },	/* mov.w rm,@@-rn */
  { 0x2006, STORE | SETS1 | USES1 | USES2 },	/* mov.l rm,@@-rn */
  { 0x2007, SETSSP | USES1 | USES2 | USESSP },	/* div0s */
  { 0x2008, SETSSP | USES1 | USES2 },		/* tst rm,rn */
  { 0x2009, SETS1 | USES1 | USES2 },		/* and rm,rn */
  { 0x200a, SETS1 | USES1 | USES2 },		/* xor rm,rn */
  { 0x200b, SETS1 | USES1 | USES2 },		/* or rm,rn */
  { 0x200c, SETSSP | USES1 | USES2 },		/* cmp/str rm,rn */
  { 0x200d, SETS1 | USES1 | USES2 },		/* xtrct rm,rn */
  { 0x200e, SETSSP | USES1 | USES2 },		/* mulu.w rm,rn */
  { 0x200f, SETSSP | USES1 | USES2 }		/* muls.w rm,rn */
};

static const struct sh_minor_opcode sh_opcode2[] =
{
  { MAP (sh_opcode20), 0xf00f }
};

static const struct sh_opcode sh_opcode30[] =
{
  { 0x3000, SETSSP | USES1 | USES2 },		/* cmp/eq rm,rn */
  { 0x3002, SETSSP | USES1 | USES2 },		/* cmp/hs rm,rn */
  { 0x3003, SETSSP | USES1 | USES2 },		/* cmp/ge rm,rn */
  { 0x3004, SETSSP | USESSP | USES1 | USES2 },	/* div1 rm,rn */
  { 0x3005, SETSSP | USES1 | USES2 },		/* dmulu.l rm,rn */
  { 0x3006, SETSSP | USES1 | USES2 },		/* cmp/hi rm,rn */
  { 0x3007, SETSSP | USES1 | USES2 },		/* cmp/gt rm,rn */
  { 0x3008, SETS1 | USES1 | USES2 },		/* sub rm,rn */
  { 0x300a, SETS1 | SETSSP | USES1 | USES2 | USESSP }, /* subc rm,rn */
  { 0x300b, SETS1 | SETSSP | USES1 | USES2 },	/* subv rm,rn */
  { 0x300c, SETS1 | USES1 | USES2 },		/* add rm,rn */
  { 0x300d, SETSSP | USES1 | USES2 },		/* dmuls.l rm,rn */
  { 0x300e, SETS1 | SETSSP | USES1 | USES2 | USESSP }, /* addc rm,rn */
  { 0x300f, SETS1 | SETSSP | USES1 | USES2 }	/* addv rm,rn */
};

static const struct sh_minor_opcode sh_opcode3[] =
{
  { MAP (sh_opcode30), 0xf00f }
};

static const struct sh_opcode sh_opcode40[] =
{
  { 0x4000, SETS1 | SETSSP | USES1 },		/* shll rn */
  { 0x4001, SETS1 | SETSSP | USES1 },		/* shlr rn */
  { 0x4002, STORE | SETS1 | USES1 | USESSP },	/* sts.l mach,@@-rn */
  { 0x4004, SETS1 | SETSSP | USES1 },		/* rotl rn */
  { 0x4005, SETS1 | SETSSP | USES1 },		/* rotr rn */
  { 0x4006, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,mach */
  { 0x4008, SETS1 | USES1 },			/* shll2 rn */
  { 0x4009, SETS1 | USES1 },			/* shlr2 rn */
  { 0x400a, SETSSP | USES1 },			/* lds rm,mach */
  { 0x400b, BRANCH | DELAY | USES1 },		/* jsr @@rn */
  { 0x4010, SETS1 | SETSSP | USES1 },		/* dt rn */
  { 0x4011, SETSSP | USES1 },			/* cmp/pz rn */
  { 0x4012, STORE | SETS1 | USES1 | USESSP },	/* sts.l macl,@@-rn */
  { 0x4014, SETSSP | USES1 },			/* setrc rm */
  { 0x4015, SETSSP | USES1 },			/* cmp/pl rn */
  { 0x4016, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,macl */
  { 0x4018, SETS1 | USES1 },			/* shll8 rn */
  { 0x4019, SETS1 | USES1 },			/* shlr8 rn */
  { 0x401a, SETSSP | USES1 },			/* lds rm,macl */
  { 0x401b, LOAD | SETSSP | USES1 },		/* tas.b @@rn */
  { 0x4020, SETS1 | SETSSP | USES1 },		/* shal rn */
  { 0x4021, SETS1 | SETSSP | USES1 },		/* shar rn */
  { 0x4022, STORE | SETS1 | USES1 | USESSP },	/* sts.l pr,@@-rn */
  { 0x4024, SETS1 | SETSSP | USES1 | USESSP },	/* rotcl rn */
  { 0x4025, SETS1 | SETSSP | USES1 | USESSP },	/* rotcr rn */
  { 0x4026, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,pr */
  { 0x4028, SETS1 | USES1 },			/* shll16 rn */
  { 0x4029, SETS1 | USES1 },			/* shlr16 rn */
  { 0x402a, SETSSP | USES1 },			/* lds rm,pr */
  { 0x402b, BRANCH | DELAY | USES1 },		/* jmp @@rn */
  { 0x4052, STORE | SETS1 | USES1 | USESSP },	/* sts.l fpul,@@-rn */
  { 0x4056, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,fpul */
  { 0x405a, SETSSP | USES1 },			/* lds.l rm,fpul */
  { 0x4062, STORE | SETS1 | USES1 | USESSP },	/* sts.l fpscr / dsr,@@-rn */
  { 0x4066, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,fpscr / dsr */
  { 0x406a, SETSSP | USES1 },			/* lds rm,fpscr / lds rm,dsr */
  { 0x4072, STORE | SETS1 | USES1 | USESSP },	/* sts.l a0,@@-rn */
  { 0x4076, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,a0 */
  { 0x407a, SETSSP | USES1 },			/* lds.l rm,a0 */
  { 0x4082, STORE | SETS1 | USES1 | USESSP },	/* sts.l x0,@@-rn */
  { 0x4086, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,x0 */
  { 0x408a, SETSSP | USES1 },			/* lds.l rm,x0 */
  { 0x4092, STORE | SETS1 | USES1 | USESSP },	/* sts.l x1,@@-rn */
  { 0x4096, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,x1 */
  { 0x409a, SETSSP | USES1 },			/* lds.l rm,x1 */
  { 0x40a2, STORE | SETS1 | USES1 | USESSP },	/* sts.l y0,@@-rn */
  { 0x40a6, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,y0 */
  { 0x40aa, SETSSP | USES1 },			/* lds.l rm,y0 */
  { 0x40b2, STORE | SETS1 | USES1 | USESSP },	/* sts.l y1,@@-rn */
  { 0x40b6, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,y1 */
  { 0x40ba, SETSSP | USES1 }			/* lds.l rm,y1 */
#if 0 /* These groups sixteen insns can be
         handled with one table entry each below.  */
  { 0x4003, STORE | SETS1 | USES1 | USESSP },	/* stc.l sr,@@-rn */
  { 0x4013, STORE | SETS1 | USES1 | USESSP },	/* stc.l gbr,@@-rn */
  { 0x4023, STORE | SETS1 | USES1 | USESSP },	/* stc.l vbr,@@-rn */
  { 0x4033, STORE | SETS1 | USES1 | USESSP },	/* stc.l ssr,@@-rn */
  { 0x4043, STORE | SETS1 | USES1 | USESSP },	/* stc.l spc,@@-rn */
  { 0x4053, STORE | SETS1 | USES1 | USESSP },	/* stc.l mod,@@-rn */
  { 0x4063, STORE | SETS1 | USES1 | USESSP },	/* stc.l rs,@@-rn */
  { 0x4073, STORE | SETS1 | USES1 | USESSP },	/* stc.l re,@@-rn */
  { 0x4083, STORE | SETS1 | USES1 | USESSP },	/* stc.l r0_bank,@@-rn */
  ..
  { 0x40f3, STORE | SETS1 | USES1 | USESSP },	/* stc.l r7_bank,@@-rn */

  { 0x4007, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,sr */
  { 0x4017, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,gbr */
  { 0x4027, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,vbr */
  { 0x4037, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,ssr */
  { 0x4047, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,spc */
  { 0x4057, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,mod */
  { 0x4067, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,rs */
  { 0x4077, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,re */
  { 0x4087, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,r0_bank */
  ..
  { 0x40f7, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,r7_bank */

  { 0x400e, SETSSP | USES1 },			/* ldc rm,sr */
  { 0x401e, SETSSP | USES1 },			/* ldc rm,gbr */
  { 0x402e, SETSSP | USES1 },			/* ldc rm,vbr */
  { 0x403e, SETSSP | USES1 },			/* ldc rm,ssr */
  { 0x404e, SETSSP | USES1 },			/* ldc rm,spc */
  { 0x405e, SETSSP | USES1 },			/* ldc rm,mod */
  { 0x406e, SETSSP | USES1 },			/* ldc rm,rs */
  { 0x407e, SETSSP | USES1 }			/* ldc rm,re */
  { 0x408e, SETSSP | USES1 }			/* ldc rm,r0_bank */
  ..
  { 0x40fe, SETSSP | USES1 }			/* ldc rm,r7_bank */
#endif
};

static const struct sh_opcode sh_opcode41[] =
{
  { 0x4003, STORE | SETS1 | USES1 | USESSP },	/* stc.l <special_reg>,@@-rn */
  { 0x4007, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,<special_reg> */
  { 0x400c, SETS1 | USES1 | USES2 },		/* shad rm,rn */
  { 0x400d, SETS1 | USES1 | USES2 },		/* shld rm,rn */
  { 0x400e, SETSSP | USES1 },			/* ldc rm,<special_reg> */
  { 0x400f, LOAD|SETS1|SETS2|SETSSP|USES1|USES2|USESSP }, /* mac.w @@rm+,@@rn+ */
};

static const struct sh_minor_opcode sh_opcode4[] =
{
  { MAP (sh_opcode40), 0xf0ff },
  { MAP (sh_opcode41), 0xf00f }
};

static const struct sh_opcode sh_opcode50[] =
{
  { 0x5000, LOAD | SETS1 | USES2 }	/* mov.l @@(disp,rm),rn */
};

static const struct sh_minor_opcode sh_opcode5[] =
{
  { MAP (sh_opcode50), 0xf000 }
};

static const struct sh_opcode sh_opcode60[] =
{
  { 0x6000, LOAD | SETS1 | USES2 },		/* mov.b @@rm,rn */
  { 0x6001, LOAD | SETS1 | USES2 },		/* mov.w @@rm,rn */
  { 0x6002, LOAD | SETS1 | USES2 },		/* mov.l @@rm,rn */
  { 0x6003, SETS1 | USES2 },			/* mov rm,rn */
  { 0x6004, LOAD | SETS1 | SETS2 | USES2 },	/* mov.b @@rm+,rn */
  { 0x6005, LOAD | SETS1 | SETS2 | USES2 },	/* mov.w @@rm+,rn */
  { 0x6006, LOAD | SETS1 | SETS2 | USES2 },	/* mov.l @@rm+,rn */
  { 0x6007, SETS1 | USES2 },			/* not rm,rn */
  { 0x6008, SETS1 | USES2 },			/* swap.b rm,rn */
  { 0x6009, SETS1 | USES2 },			/* swap.w rm,rn */
  { 0x600a, SETS1 | SETSSP | USES2 | USESSP },	/* negc rm,rn */
  { 0x600b, SETS1 | USES2 },			/* neg rm,rn */
  { 0x600c, SETS1 | USES2 },			/* extu.b rm,rn */
  { 0x600d, SETS1 | USES2 },			/* extu.w rm,rn */
  { 0x600e, SETS1 | USES2 },			/* exts.b rm,rn */
  { 0x600f, SETS1 | USES2 }			/* exts.w rm,rn */
};

static const struct sh_minor_opcode sh_opcode6[] =
{
  { MAP (sh_opcode60), 0xf00f }
};

static const struct sh_opcode sh_opcode70[] =
{
  { 0x7000, SETS1 | USES1 }		/* add #imm,rn */
};

static const struct sh_minor_opcode sh_opcode7[] =
{
  { MAP (sh_opcode70), 0xf000 }
};

static const struct sh_opcode sh_opcode80[] =
{
  { 0x8000, STORE | USES2 | USESR0 },	/* mov.b r0,@@(disp,rn) */
  { 0x8100, STORE | USES2 | USESR0 },	/* mov.w r0,@@(disp,rn) */
  { 0x8200, SETSSP },			/* setrc #imm */
  { 0x8400, LOAD | SETSR0 | USES2 },	/* mov.b @@(disp,rm),r0 */
  { 0x8500, LOAD | SETSR0 | USES2 },	/* mov.w @@(disp,rn),r0 */
  { 0x8800, SETSSP | USESR0 },		/* cmp/eq #imm,r0 */
  { 0x8900, BRANCH | USESSP },		/* bt label */
  { 0x8b00, BRANCH | USESSP },		/* bf label */
  { 0x8c00, SETSSP },			/* ldrs @@(disp,pc) */
  { 0x8d00, BRANCH | DELAY | USESSP },	/* bt/s label */
  { 0x8e00, SETSSP },			/* ldre @@(disp,pc) */
  { 0x8f00, BRANCH | DELAY | USESSP }	/* bf/s label */
};

static const struct sh_minor_opcode sh_opcode8[] =
{
  { MAP (sh_opcode80), 0xff00 }
};

static const struct sh_opcode sh_opcode90[] =
{
  { 0x9000, LOAD | SETS1 }	/* mov.w @@(disp,pc),rn */
};

static const struct sh_minor_opcode sh_opcode9[] =
{
  { MAP (sh_opcode90), 0xf000 }
};

static const struct sh_opcode sh_opcodea0[] =
{
  { 0xa000, BRANCH | DELAY }	/* bra label */
};

static const struct sh_minor_opcode sh_opcodea[] =
{
  { MAP (sh_opcodea0), 0xf000 }
};

static const struct sh_opcode sh_opcodeb0[] =
{
  { 0xb000, BRANCH | DELAY }	/* bsr label */
};

static const struct sh_minor_opcode sh_opcodeb[] =
{
  { MAP (sh_opcodeb0), 0xf000 }
};

static const struct sh_opcode sh_opcodec0[] =
{
  { 0xc000, STORE | USESR0 | USESSP },		/* mov.b r0,@@(disp,gbr) */
  { 0xc100, STORE | USESR0 | USESSP },		/* mov.w r0,@@(disp,gbr) */
  { 0xc200, STORE | USESR0 | USESSP },		/* mov.l r0,@@(disp,gbr) */
  { 0xc300, BRANCH | USESSP },			/* trapa #imm */
  { 0xc400, LOAD | SETSR0 | USESSP },		/* mov.b @@(disp,gbr),r0 */
  { 0xc500, LOAD | SETSR0 | USESSP },		/* mov.w @@(disp,gbr),r0 */
  { 0xc600, LOAD | SETSR0 | USESSP },		/* mov.l @@(disp,gbr),r0 */
  { 0xc700, SETSR0 },				/* mova @@(disp,pc),r0 */
  { 0xc800, SETSSP | USESR0 },			/* tst #imm,r0 */
  { 0xc900, SETSR0 | USESR0 },			/* and #imm,r0 */
  { 0xca00, SETSR0 | USESR0 },			/* xor #imm,r0 */
  { 0xcb00, SETSR0 | USESR0 },			/* or #imm,r0 */
  { 0xcc00, LOAD | SETSSP | USESR0 | USESSP },	/* tst.b #imm,@@(r0,gbr) */
  { 0xcd00, LOAD | STORE | USESR0 | USESSP },	/* and.b #imm,@@(r0,gbr) */
  { 0xce00, LOAD | STORE | USESR0 | USESSP },	/* xor.b #imm,@@(r0,gbr) */
  { 0xcf00, LOAD | STORE | USESR0 | USESSP }	/* or.b #imm,@@(r0,gbr) */
};

static const struct sh_minor_opcode sh_opcodec[] =
{
  { MAP (sh_opcodec0), 0xff00 }
};

static const struct sh_opcode sh_opcoded0[] =
{
  { 0xd000, LOAD | SETS1 }		/* mov.l @@(disp,pc),rn */
};

static const struct sh_minor_opcode sh_opcoded[] =
{
  { MAP (sh_opcoded0), 0xf000 }
};

static const struct sh_opcode sh_opcodee0[] =
{
  { 0xe000, SETS1 }		/* mov #imm,rn */
};

static const struct sh_minor_opcode sh_opcodee[] =
{
  { MAP (sh_opcodee0), 0xf000 }
};

static const struct sh_opcode sh_opcodef0[] =
{
  { 0xf000, SETSF1 | USESF1 | USESF2 },		/* fadd fm,fn */
  { 0xf001, SETSF1 | USESF1 | USESF2 },		/* fsub fm,fn */
  { 0xf002, SETSF1 | USESF1 | USESF2 },		/* fmul fm,fn */
  { 0xf003, SETSF1 | USESF1 | USESF2 },		/* fdiv fm,fn */
  { 0xf004, SETSSP | USESF1 | USESF2 },		/* fcmp/eq fm,fn */
  { 0xf005, SETSSP | USESF1 | USESF2 },		/* fcmp/gt fm,fn */
  { 0xf006, LOAD | SETSF1 | USES2 | USESR0 },	/* fmov.s @@(r0,rm),fn */
  { 0xf007, STORE | USES1 | USESF2 | USESR0 },	/* fmov.s fm,@@(r0,rn) */
  { 0xf008, LOAD | SETSF1 | USES2 },		/* fmov.s @@rm,fn */
  { 0xf009, LOAD | SETS2 | SETSF1 | USES2 },	/* fmov.s @@rm+,fn */
  { 0xf00a, STORE | USES1 | USESF2 },		/* fmov.s fm,@@rn */
  { 0xf00b, STORE | SETS1 | USES1 | USESF2 },	/* fmov.s fm,@@-rn */
  { 0xf00c, SETSF1 | USESF2 },			/* fmov fm,fn */
  { 0xf00e, SETSF1 | USESF1 | USESF2 | USESF0 }	/* fmac f0,fm,fn */
};

static const struct sh_opcode sh_opcodef1[] =
{
  { 0xf00d, SETSF1 | USESSP },	/* fsts fpul,fn */
  { 0xf01d, SETSSP | USESF1 },	/* flds fn,fpul */
  { 0xf02d, SETSF1 | USESSP },	/* float fpul,fn */
  { 0xf03d, SETSSP | USESF1 },	/* ftrc fn,fpul */
  { 0xf04d, SETSF1 | USESF1 },	/* fneg fn */
  { 0xf05d, SETSF1 | USESF1 },	/* fabs fn */
  { 0xf06d, SETSF1 | USESF1 },	/* fsqrt fn */
  { 0xf07d, SETSSP | USESF1 },	/* ftst/nan fn */
  { 0xf08d, SETSF1 },		/* fldi0 fn */
  { 0xf09d, SETSF1 }		/* fldi1 fn */
};

static const struct sh_minor_opcode sh_opcodef[] =
{
  { MAP (sh_opcodef0), 0xf00f },
  { MAP (sh_opcodef1), 0xf0ff }
};

static struct sh_major_opcode sh_opcodes[] =
{
  { MAP (sh_opcode0) },
  { MAP (sh_opcode1) },
  { MAP (sh_opcode2) },
  { MAP (sh_opcode3) },
  { MAP (sh_opcode4) },
  { MAP (sh_opcode5) },
  { MAP (sh_opcode6) },
  { MAP (sh_opcode7) },
  { MAP (sh_opcode8) },
  { MAP (sh_opcode9) },
  { MAP (sh_opcodea) },
  { MAP (sh_opcodeb) },
  { MAP (sh_opcodec) },
  { MAP (sh_opcoded) },
  { MAP (sh_opcodee) },
  { MAP (sh_opcodef) }
};

/* The double data transfer / parallel processing insns are not
   described here.  This will cause sh_align_load_span to leave them alone.  */

static const struct sh_opcode sh_dsp_opcodef0[] =
{
  { 0xf400, USESAS | SETSAS | LOAD | SETSSP },	/* movs.x @@-as,ds */
  { 0xf401, USESAS | SETSAS | STORE | USESSP },	/* movs.x ds,@@-as */
  { 0xf404, USESAS | LOAD | SETSSP },		/* movs.x @@as,ds */
  { 0xf405, USESAS | STORE | USESSP },		/* movs.x ds,@@as */
  { 0xf408, USESAS | SETSAS | LOAD | SETSSP },	/* movs.x @@as+,ds */
  { 0xf409, USESAS | SETSAS | STORE | USESSP },	/* movs.x ds,@@as+ */
  { 0xf40c, USESAS | SETSAS | LOAD | SETSSP | USESR8 },	/* movs.x @@as+r8,ds */
  { 0xf40d, USESAS | SETSAS | STORE | USESSP | USESR8 }	/* movs.x ds,@@as+r8 */
};

static const struct sh_minor_opcode sh_dsp_opcodef[] =
{
  { MAP (sh_dsp_opcodef0), 0xfc0d }
};

/* Given an instruction, return a pointer to the corresponding
   sh_opcode structure.  Return NULL if the instruction is not
   recognized.  */

static const struct sh_opcode *
sh_insn_info (insn)
     unsigned int insn;
{
  const struct sh_major_opcode *maj;
  const struct sh_minor_opcode *min, *minend;

  maj = &sh_opcodes[(insn & 0xf000) >> 12];
  min = maj->minor_opcodes;
  minend = min + maj->count;
  for (; min < minend; min++)
    {
      unsigned int l;
      const struct sh_opcode *op, *opend;

      l = insn & min->mask;
      op = min->opcodes;
      opend = op + min->count;

      /* Since the opcodes tables are sorted, we could use a binary
         search here if the count were above some cutoff value.  */
      for (; op < opend; op++)
	if (op->opcode == l)
	  return op;
    }

  return NULL;
}

/* See whether an instruction uses or sets a general purpose register */

static bfd_boolean
sh_insn_uses_or_sets_reg (insn, op, reg)
     unsigned int insn;
     const struct sh_opcode *op;
     unsigned int reg;
{
  if (sh_insn_uses_reg (insn, op, reg))
    return TRUE;

  return sh_insn_sets_reg (insn, op, reg);
}

/* See whether an instruction uses a general purpose register.  */

static bfd_boolean
sh_insn_uses_reg (insn, op, reg)
     unsigned int insn;
     const struct sh_opcode *op;
     unsigned int reg;
{
  unsigned int f;

  f = op->flags;

  if ((f & USES1) != 0
      && USES1_REG (insn) == reg)
    return TRUE;
  if ((f & USES2) != 0
      && USES2_REG (insn) == reg)
    return TRUE;
  if ((f & USESR0) != 0
      && reg == 0)
    return TRUE;
  if ((f & USESAS) && reg == USESAS_REG (insn))
    return TRUE;
  if ((f & USESR8) && reg == 8)
    return TRUE;

  return FALSE;
}

/* See whether an instruction sets a general purpose register.  */

static bfd_boolean
sh_insn_sets_reg (insn, op, reg)
     unsigned int insn;
     const struct sh_opcode *op;
     unsigned int reg;
{
  unsigned int f;

  f = op->flags;

  if ((f & SETS1) != 0
      && SETS1_REG (insn) == reg)
    return TRUE;
  if ((f & SETS2) != 0
      && SETS2_REG (insn) == reg)
    return TRUE;
  if ((f & SETSR0) != 0
      && reg == 0)
    return TRUE;
  if ((f & SETSAS) && reg == SETSAS_REG (insn))
    return TRUE;

  return FALSE;
}

/* See whether an instruction uses or sets a floating point register */

static bfd_boolean
sh_insn_uses_or_sets_freg (insn, op, reg)
     unsigned int insn;
     const struct sh_opcode *op;
     unsigned int reg;
{
  if (sh_insn_uses_freg (insn, op, reg))
    return TRUE;

  return sh_insn_sets_freg (insn, op, reg);
}

/* See whether an instruction uses a floating point register.  */

static bfd_boolean
sh_insn_uses_freg (insn, op, freg)
     unsigned int insn;
     const struct sh_opcode *op;
     unsigned int freg;
{
  unsigned int f;

  f = op->flags;

  /* We can't tell if this is a double-precision insn, so just play safe
     and assume that it might be.  So not only have we test FREG against
     itself, but also even FREG against FREG+1 - if the using insn uses
     just the low part of a double precision value - but also an odd
     FREG against FREG-1 -  if the setting insn sets just the low part
     of a double precision value.
     So what this all boils down to is that we have to ignore the lowest
     bit of the register number.  */

  if ((f & USESF1) != 0
      && (USESF1_REG (insn) & 0xe) == (freg & 0xe))
    return TRUE;
  if ((f & USESF2) != 0
      && (USESF2_REG (insn) & 0xe) == (freg & 0xe))
    return TRUE;
  if ((f & USESF0) != 0
      && freg == 0)
    return TRUE;

  return FALSE;
}

/* See whether an instruction sets a floating point register.  */

static bfd_boolean
sh_insn_sets_freg (insn, op, freg)
     unsigned int insn;
     const struct sh_opcode *op;
     unsigned int freg;
{
  unsigned int f;

  f = op->flags;

  /* We can't tell if this is a double-precision insn, so just play safe
     and assume that it might be.  So not only have we test FREG against
     itself, but also even FREG against FREG+1 - if the using insn uses
     just the low part of a double precision value - but also an odd
     FREG against FREG-1 -  if the setting insn sets just the low part
     of a double precision value.
     So what this all boils down to is that we have to ignore the lowest
     bit of the register number.  */

  if ((f & SETSF1) != 0
      && (SETSF1_REG (insn) & 0xe) == (freg & 0xe))
    return TRUE;

  return FALSE;
}

/* See whether instructions I1 and I2 conflict, assuming I1 comes
   before I2.  OP1 and OP2 are the corresponding sh_opcode structures.
   This should return TRUE if there is a conflict, or FALSE if the
   instructions can be swapped safely.  */

static bfd_boolean
sh_insns_conflict (i1, op1, i2, op2)
     unsigned int i1;
     const struct sh_opcode *op1;
     unsigned int i2;
     const struct sh_opcode *op2;
{
  unsigned int f1, f2;

  f1 = op1->flags;
  f2 = op2->flags;

  /* Load of fpscr conflicts with floating point operations.
     FIXME: shouldn't test raw opcodes here.  */
  if (((i1 & 0xf0ff) == 0x4066 && (i2 & 0xf000) == 0xf000)
      || ((i2 & 0xf0ff) == 0x4066 && (i1 & 0xf000) == 0xf000))
    return TRUE;

  if ((f1 & (BRANCH | DELAY)) != 0
      || (f2 & (BRANCH | DELAY)) != 0)
    return TRUE;

  if (((f1 | f2) & SETSSP)
      && (f1 & (SETSSP | USESSP))
      && (f2 & (SETSSP | USESSP)))
    return TRUE;

  if ((f1 & SETS1) != 0
      && sh_insn_uses_or_sets_reg (i2, op2, SETS1_REG (i1)))
    return TRUE;
  if ((f1 & SETS2) != 0
      && sh_insn_uses_or_sets_reg (i2, op2, SETS2_REG (i1)))
    return TRUE;
  if ((f1 & SETSR0) != 0
      && sh_insn_uses_or_sets_reg (i2, op2, 0))
    return TRUE;
  if ((f1 & SETSAS)
      && sh_insn_uses_or_sets_reg (i2, op2, SETSAS_REG (i1)))
    return TRUE;
  if ((f1 & SETSF1) != 0
      && sh_insn_uses_or_sets_freg (i2, op2, SETSF1_REG (i1)))
    return TRUE;

  if ((f2 & SETS1) != 0
      && sh_insn_uses_or_sets_reg (i1, op1, SETS1_REG (i2)))
    return TRUE;
  if ((f2 & SETS2) != 0
      && sh_insn_uses_or_sets_reg (i1, op1, SETS2_REG (i2)))
    return TRUE;
  if ((f2 & SETSR0) != 0
      && sh_insn_uses_or_sets_reg (i1, op1, 0))
    return TRUE;
  if ((f2 & SETSAS)
      && sh_insn_uses_or_sets_reg (i1, op1, SETSAS_REG (i2)))
    return TRUE;
  if ((f2 & SETSF1) != 0
      && sh_insn_uses_or_sets_freg (i1, op1, SETSF1_REG (i2)))
    return TRUE;

  /* The instructions do not conflict.  */
  return FALSE;
}

/* I1 is a load instruction, and I2 is some other instruction.  Return
   TRUE if I1 loads a register which I2 uses.  */

static bfd_boolean
sh_load_use (i1, op1, i2, op2)
     unsigned int i1;
     const struct sh_opcode *op1;
     unsigned int i2;
     const struct sh_opcode *op2;
{
  unsigned int f1;

  f1 = op1->flags;

  if ((f1 & LOAD) == 0)
    return FALSE;

  /* If both SETS1 and SETSSP are set, that means a load to a special
     register using postincrement addressing mode, which we don't care
     about here.  */
  if ((f1 & SETS1) != 0
      && (f1 & SETSSP) == 0
      && sh_insn_uses_reg (i2, op2, (i1 & 0x0f00) >> 8))
    return TRUE;

  if ((f1 & SETSR0) != 0
      && sh_insn_uses_reg (i2, op2, 0))
    return TRUE;

  if ((f1 & SETSF1) != 0
      && sh_insn_uses_freg (i2, op2, (i1 & 0x0f00) >> 8))
    return TRUE;

  return FALSE;
}

/* Try to align loads and stores within a span of memory.  This is
   called by both the ELF and the COFF sh targets.  ABFD and SEC are
   the BFD and section we are examining.  CONTENTS is the contents of
   the section.  SWAP is the routine to call to swap two instructions.
   RELOCS is a pointer to the internal relocation information, to be
   passed to SWAP.  PLABEL is a pointer to the current label in a
   sorted list of labels; LABEL_END is the end of the list.  START and
   STOP are the range of memory to examine.  If a swap is made,
   *PSWAPPED is set to TRUE.  */

#ifdef COFF_WITH_PE
static
#endif
bfd_boolean
_bfd_sh_align_load_span (abfd, sec, contents, swap, relocs,
			 plabel, label_end, start, stop, pswapped)
     bfd *abfd;
     asection *sec;
     bfd_byte *contents;
     bfd_boolean (*swap) PARAMS ((bfd *, asection *, PTR, bfd_byte *, bfd_vma));
     PTR relocs;
     bfd_vma **plabel;
     bfd_vma *label_end;
     bfd_vma start;
     bfd_vma stop;
     bfd_boolean *pswapped;
{
  int dsp = (abfd->arch_info->mach == bfd_mach_sh_dsp
	     || abfd->arch_info->mach == bfd_mach_sh3_dsp);
  bfd_vma i;

  /* The SH4 has a Harvard architecture, hence aligning loads is not
     desirable.  In fact, it is counter-productive, since it interferes
     with the schedules generated by the compiler.  */
  if (abfd->arch_info->mach == bfd_mach_sh4)
    return TRUE;

  /* If we are linking sh[3]-dsp code, swap the FPU instructions for DSP
     instructions.  */
  if (dsp)
    {
      sh_opcodes[0xf].minor_opcodes = sh_dsp_opcodef;
      sh_opcodes[0xf].count = sizeof sh_dsp_opcodef / sizeof sh_dsp_opcodef;
    }

  /* Instructions should be aligned on 2 byte boundaries.  */
  if ((start & 1) == 1)
    ++start;

  /* Now look through the unaligned addresses.  */
  i = start;
  if ((i & 2) == 0)
    i += 2;
  for (; i < stop; i += 4)
    {
      unsigned int insn;
      const struct sh_opcode *op;
      unsigned int prev_insn = 0;
      const struct sh_opcode *prev_op = NULL;

      insn = bfd_get_16 (abfd, contents + i);
      op = sh_insn_info (insn);
      if (op == NULL
	  || (op->flags & (LOAD | STORE)) == 0)
	continue;

      /* This is a load or store which is not on a four byte boundary.  */

      while (*plabel < label_end && **plabel < i)
	++*plabel;

      if (i > start)
	{
	  prev_insn = bfd_get_16 (abfd, contents + i - 2);
	  /* If INSN is the field b of a parallel processing insn, it is not
	     a load / store after all.  Note that the test here might mistake
	     the field_b of a pcopy insn for the starting code of a parallel
	     processing insn; this might miss a swapping opportunity, but at
	     least we're on the safe side.  */
	  if (dsp && (prev_insn & 0xfc00) == 0xf800)
	    continue;

	  /* Check if prev_insn is actually the field b of a parallel
	     processing insn.  Again, this can give a spurious match
	     after a pcopy.  */
	  if (dsp && i - 2 > start)
	    {
	      unsigned pprev_insn = bfd_get_16 (abfd, contents + i - 4);

	      if ((pprev_insn & 0xfc00) == 0xf800)
		prev_op = NULL;
	      else
		prev_op = sh_insn_info (prev_insn);
	    }
	  else
	    prev_op = sh_insn_info (prev_insn);

	  /* If the load/store instruction is in a delay slot, we
	     can't swap.  */
	  if (prev_op == NULL
	      || (prev_op->flags & DELAY) != 0)
	    continue;
	}
      if (i > start
	  && (*plabel >= label_end || **plabel != i)
	  && prev_op != NULL
	  && (prev_op->flags & (LOAD | STORE)) == 0
	  && ! sh_insns_conflict (prev_insn, prev_op, insn, op))
	{
	  bfd_boolean ok;

	  /* The load/store instruction does not have a label, and
	     there is a previous instruction; PREV_INSN is not
	     itself a load/store instruction, and PREV_INSN and
	     INSN do not conflict.  */

	  ok = TRUE;

	  if (i >= start + 4)
	    {
	      unsigned int prev2_insn;
	      const struct sh_opcode *prev2_op;

	      prev2_insn = bfd_get_16 (abfd, contents + i - 4);
	      prev2_op = sh_insn_info (prev2_insn);

	      /* If the instruction before PREV_INSN has a delay
		 slot--that is, PREV_INSN is in a delay slot--we
		 can not swap.  */
	      if (prev2_op == NULL
		  || (prev2_op->flags & DELAY) != 0)
		ok = FALSE;

	      /* If the instruction before PREV_INSN is a load,
		 and it sets a register which INSN uses, then
		 putting INSN immediately after PREV_INSN will
		 cause a pipeline bubble, so there is no point to
		 making the swap.  */
	      if (ok
		  && (prev2_op->flags & LOAD) != 0
		  && sh_load_use (prev2_insn, prev2_op, insn, op))
		ok = FALSE;
	    }

	  if (ok)
	    {
	      if (! (*swap) (abfd, sec, relocs, contents, i - 2))
		return FALSE;
	      *pswapped = TRUE;
	      continue;
	    }
	}

      while (*plabel < label_end && **plabel < i + 2)
	++*plabel;

      if (i + 2 < stop
	  && (*plabel >= label_end || **plabel != i + 2))
	{
	  unsigned int next_insn;
	  const struct sh_opcode *next_op;

	  /* There is an instruction after the load/store
	     instruction, and it does not have a label.  */
	  next_insn = bfd_get_16 (abfd, contents + i + 2);
	  next_op = sh_insn_info (next_insn);
	  if (next_op != NULL
	      && (next_op->flags & (LOAD | STORE)) == 0
	      && ! sh_insns_conflict (insn, op, next_insn, next_op))
	    {
	      bfd_boolean ok;

	      /* NEXT_INSN is not itself a load/store instruction,
		 and it does not conflict with INSN.  */

	      ok = TRUE;

	      /* If PREV_INSN is a load, and it sets a register
		 which NEXT_INSN uses, then putting NEXT_INSN
		 immediately after PREV_INSN will cause a pipeline
		 bubble, so there is no reason to make this swap.  */
	      if (prev_op != NULL
		  && (prev_op->flags & LOAD) != 0
		  && sh_load_use (prev_insn, prev_op, next_insn, next_op))
		ok = FALSE;

	      /* If INSN is a load, and it sets a register which
		 the insn after NEXT_INSN uses, then doing the
		 swap will cause a pipeline bubble, so there is no
		 reason to make the swap.  However, if the insn
		 after NEXT_INSN is itself a load or store
		 instruction, then it is misaligned, so
		 optimistically hope that it will be swapped
		 itself, and just live with the pipeline bubble if
		 it isn't.  */
	      if (ok
		  && i + 4 < stop
		  && (op->flags & LOAD) != 0)
		{
		  unsigned int next2_insn;
		  const struct sh_opcode *next2_op;

		  next2_insn = bfd_get_16 (abfd, contents + i + 4);
		  next2_op = sh_insn_info (next2_insn);
		  if ((next2_op->flags & (LOAD | STORE)) == 0
		      && sh_load_use (insn, op, next2_insn, next2_op))
		    ok = FALSE;
		}

	      if (ok)
		{
		  if (! (*swap) (abfd, sec, relocs, contents, i))
		    return FALSE;
		  *pswapped = TRUE;
		  continue;
		}
	    }
	}
    }

  return TRUE;
}
#endif /* not COFF_IMAGE_WITH_PE */

/* Look for loads and stores which we can align to four byte
   boundaries.  See the longer comment above sh_relax_section for why
   this is desirable.  This sets *PSWAPPED if some instruction was
   swapped.  */

static bfd_boolean
sh_align_loads (abfd, sec, internal_relocs, contents, pswapped)
     bfd *abfd;
     asection *sec;
     struct internal_reloc *internal_relocs;
     bfd_byte *contents;
     bfd_boolean *pswapped;
{
  struct internal_reloc *irel, *irelend;
  bfd_vma *labels = NULL;
  bfd_vma *label, *label_end;
  bfd_size_type amt;

  *pswapped = FALSE;

  irelend = internal_relocs + sec->reloc_count;

  /* Get all the addresses with labels on them.  */
  amt = (bfd_size_type) sec->reloc_count * sizeof (bfd_vma);
  labels = (bfd_vma *) bfd_malloc (amt);
  if (labels == NULL)
    goto error_return;
  label_end = labels;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      if (irel->r_type == R_SH_LABEL)
	{
	  *label_end = irel->r_vaddr - sec->vma;
	  ++label_end;
	}
    }

  /* Note that the assembler currently always outputs relocs in
     address order.  If that ever changes, this code will need to sort
     the label values and the relocs.  */

  label = labels;

  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma start, stop;

      if (irel->r_type != R_SH_CODE)
	continue;

      start = irel->r_vaddr - sec->vma;

      for (irel++; irel < irelend; irel++)
	if (irel->r_type == R_SH_DATA)
	  break;
      if (irel < irelend)
	stop = irel->r_vaddr - sec->vma;
      else
	stop = sec->_cooked_size;

      if (! _bfd_sh_align_load_span (abfd, sec, contents, sh_swap_insns,
				     (PTR) internal_relocs, &label,
				     label_end, start, stop, pswapped))
	goto error_return;
    }

  free (labels);

  return TRUE;

 error_return:
  if (labels != NULL)
    free (labels);
  return FALSE;
}

/* Swap two SH instructions.  */

static bfd_boolean
sh_swap_insns (abfd, sec, relocs, contents, addr)
     bfd *abfd;
     asection *sec;
     PTR relocs;
     bfd_byte *contents;
     bfd_vma addr;
{
  struct internal_reloc *internal_relocs = (struct internal_reloc *) relocs;
  unsigned short i1, i2;
  struct internal_reloc *irel, *irelend;

  /* Swap the instructions themselves.  */
  i1 = bfd_get_16 (abfd, contents + addr);
  i2 = bfd_get_16 (abfd, contents + addr + 2);
  bfd_put_16 (abfd, (bfd_vma) i2, contents + addr);
  bfd_put_16 (abfd, (bfd_vma) i1, contents + addr + 2);

  /* Adjust all reloc addresses.  */
  irelend = internal_relocs + sec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      int type, add;

      /* There are a few special types of relocs that we don't want to
         adjust.  These relocs do not apply to the instruction itself,
         but are only associated with the address.  */
      type = irel->r_type;
      if (type == R_SH_ALIGN
	  || type == R_SH_CODE
	  || type == R_SH_DATA
	  || type == R_SH_LABEL)
	continue;

      /* If an R_SH_USES reloc points to one of the addresses being
         swapped, we must adjust it.  It would be incorrect to do this
         for a jump, though, since we want to execute both
         instructions after the jump.  (We have avoided swapping
         around a label, so the jump will not wind up executing an
         instruction it shouldn't).  */
      if (type == R_SH_USES)
	{
	  bfd_vma off;

	  off = irel->r_vaddr - sec->vma + 4 + irel->r_offset;
	  if (off == addr)
	    irel->r_offset += 2;
	  else if (off == addr + 2)
	    irel->r_offset -= 2;
	}

      if (irel->r_vaddr - sec->vma == addr)
	{
	  irel->r_vaddr += 2;
	  add = -2;
	}
      else if (irel->r_vaddr - sec->vma == addr + 2)
	{
	  irel->r_vaddr -= 2;
	  add = 2;
	}
      else
	add = 0;

      if (add != 0)
	{
	  bfd_byte *loc;
	  unsigned short insn, oinsn;
	  bfd_boolean overflow;

	  loc = contents + irel->r_vaddr - sec->vma;
	  overflow = FALSE;
	  switch (type)
	    {
	    default:
	      break;

	    case R_SH_PCDISP8BY2:
	    case R_SH_PCRELIMM8BY2:
	      insn = bfd_get_16 (abfd, loc);
	      oinsn = insn;
	      insn += add / 2;
	      if ((oinsn & 0xff00) != (insn & 0xff00))
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, loc);
	      break;

	    case R_SH_PCDISP:
	      insn = bfd_get_16 (abfd, loc);
	      oinsn = insn;
	      insn += add / 2;
	      if ((oinsn & 0xf000) != (insn & 0xf000))
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, loc);
	      break;

	    case R_SH_PCRELIMM8BY4:
	      /* This reloc ignores the least significant 3 bits of
                 the program counter before adding in the offset.
                 This means that if ADDR is at an even address, the
                 swap will not affect the offset.  If ADDR is an at an
                 odd address, then the instruction will be crossing a
                 four byte boundary, and must be adjusted.  */
	      if ((addr & 3) != 0)
		{
		  insn = bfd_get_16 (abfd, loc);
		  oinsn = insn;
		  insn += add / 2;
		  if ((oinsn & 0xff00) != (insn & 0xff00))
		    overflow = TRUE;
		  bfd_put_16 (abfd, (bfd_vma) insn, loc);
		}

	      break;
	    }

	  if (overflow)
	    {
	      ((*_bfd_error_handler)
	       ("%s: 0x%lx: fatal: reloc overflow while relaxing",
		bfd_archive_filename (abfd), (unsigned long) irel->r_vaddr));
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	}
    }

  return TRUE;
}

/* This is a modification of _bfd_coff_generic_relocate_section, which
   will handle SH relaxing.  */

static bfd_boolean
sh_relocate_section (output_bfd, info, input_bfd, input_section, contents,
		     relocs, syms, sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     struct internal_reloc *relocs;
     struct internal_syment *syms;
     asection **sections;
{
  struct internal_reloc *rel;
  struct internal_reloc *relend;

  rel = relocs;
  relend = rel + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      long symndx;
      struct coff_link_hash_entry *h;
      struct internal_syment *sym;
      bfd_vma addend;
      bfd_vma val;
      reloc_howto_type *howto;
      bfd_reloc_status_type rstat;

      /* Almost all relocs have to do with relaxing.  If any work must
         be done for them, it has been done in sh_relax_section.  */
      if (rel->r_type != R_SH_IMM32
#ifdef COFF_WITH_PE
	  && rel->r_type != R_SH_IMM32CE
	  && rel->r_type != R_SH_IMAGEBASE
#endif
	  && rel->r_type != R_SH_PCDISP)
	continue;

      symndx = rel->r_symndx;

      if (symndx == -1)
	{
	  h = NULL;
	  sym = NULL;
	}
      else
	{
	  if (symndx < 0
	      || (unsigned long) symndx >= obj_raw_syment_count (input_bfd))
	    {
	      (*_bfd_error_handler)
		("%s: illegal symbol index %ld in relocs",
		 bfd_archive_filename (input_bfd), symndx);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  h = obj_coff_sym_hashes (input_bfd)[symndx];
	  sym = syms + symndx;
	}

      if (sym != NULL && sym->n_scnum != 0)
	addend = - sym->n_value;
      else
	addend = 0;

      if (rel->r_type == R_SH_PCDISP)
	addend -= 4;

      if (rel->r_type >= SH_COFF_HOWTO_COUNT)
	howto = NULL;
      else
	howto = &sh_coff_howtos[rel->r_type];

      if (howto == NULL)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

#ifdef COFF_WITH_PE
      if (rel->r_type == R_SH_IMAGEBASE)
	addend -= pe_data (input_section->output_section->owner)->pe_opthdr.ImageBase;
#endif

      val = 0;

      if (h == NULL)
	{
	  asection *sec;

	  /* There is nothing to do for an internal PCDISP reloc.  */
	  if (rel->r_type == R_SH_PCDISP)
	    continue;

	  if (symndx == -1)
	    {
	      sec = bfd_abs_section_ptr;
	      val = 0;
	    }
	  else
	    {
	      sec = sections[symndx];
              val = (sec->output_section->vma
		     + sec->output_offset
		     + sym->n_value
		     - sec->vma);
	    }
	}
      else
	{
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      asection *sec;

	      sec = h->root.u.def.section;
	      val = (h->root.u.def.value
		     + sec->output_section->vma
		     + sec->output_offset);
	    }
	  else if (! info->relocatable)
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd, input_section,
		      rel->r_vaddr - input_section->vma, TRUE)))
		return FALSE;
	    }
	}

      rstat = _bfd_final_link_relocate (howto, input_bfd, input_section,
					contents,
					rel->r_vaddr - input_section->vma,
					val, addend);

      switch (rstat)
	{
	default:
	  abort ();
	case bfd_reloc_ok:
	  break;
	case bfd_reloc_overflow:
	  {
	    const char *name;
	    char buf[SYMNMLEN + 1];

	    if (symndx == -1)
	      name = "*ABS*";
	    else if (h != NULL)
	      name = h->root.root.string;
	    else if (sym->_n._n_n._n_zeroes == 0
		     && sym->_n._n_n._n_offset != 0)
	      name = obj_coff_strings (input_bfd) + sym->_n._n_n._n_offset;
	    else
	      {
 		strncpy (buf, sym->_n._n_name, SYMNMLEN);
		buf[SYMNMLEN] = '\0';
		name = buf;
	      }

	    if (! ((*info->callbacks->reloc_overflow)
		   (info, name, howto->name, (bfd_vma) 0, input_bfd,
		    input_section, rel->r_vaddr - input_section->vma)))
	      return FALSE;
	  }
	}
    }

  return TRUE;
}

/* This is a version of bfd_generic_get_relocated_section_contents
   which uses sh_relocate_section.  */

static bfd_byte *
sh_coff_get_relocated_section_contents (output_bfd, link_info, link_order,
					data, relocatable, symbols)
     bfd *output_bfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     bfd_byte *data;
     bfd_boolean relocatable;
     asymbol **symbols;
{
  asection *input_section = link_order->u.indirect.section;
  bfd *input_bfd = input_section->owner;
  asection **sections = NULL;
  struct internal_reloc *internal_relocs = NULL;
  struct internal_syment *internal_syms = NULL;

  /* We only need to handle the case of relaxing, or of having a
     particular set of section contents, specially.  */
  if (relocatable
      || coff_section_data (input_bfd, input_section) == NULL
      || coff_section_data (input_bfd, input_section)->contents == NULL)
    return bfd_generic_get_relocated_section_contents (output_bfd, link_info,
						       link_order, data,
						       relocatable,
						       symbols);

  memcpy (data, coff_section_data (input_bfd, input_section)->contents,
	  (size_t) input_section->_raw_size);

  if ((input_section->flags & SEC_RELOC) != 0
      && input_section->reloc_count > 0)
    {
      bfd_size_type symesz = bfd_coff_symesz (input_bfd);
      bfd_byte *esym, *esymend;
      struct internal_syment *isymp;
      asection **secpp;
      bfd_size_type amt;

      if (! _bfd_coff_get_external_symbols (input_bfd))
	goto error_return;

      internal_relocs = (_bfd_coff_read_internal_relocs
			 (input_bfd, input_section, FALSE, (bfd_byte *) NULL,
			  FALSE, (struct internal_reloc *) NULL));
      if (internal_relocs == NULL)
	goto error_return;

      amt = obj_raw_syment_count (input_bfd);
      amt *= sizeof (struct internal_syment);
      internal_syms = (struct internal_syment *) bfd_malloc (amt);
      if (internal_syms == NULL)
	goto error_return;

      amt = obj_raw_syment_count (input_bfd);
      amt *= sizeof (asection *);
      sections = (asection **) bfd_malloc (amt);
      if (sections == NULL)
	goto error_return;

      isymp = internal_syms;
      secpp = sections;
      esym = (bfd_byte *) obj_coff_external_syms (input_bfd);
      esymend = esym + obj_raw_syment_count (input_bfd) * symesz;
      while (esym < esymend)
	{
	  bfd_coff_swap_sym_in (input_bfd, (PTR) esym, (PTR) isymp);

	  if (isymp->n_scnum != 0)
	    *secpp = coff_section_from_bfd_index (input_bfd, isymp->n_scnum);
	  else
	    {
	      if (isymp->n_value == 0)
		*secpp = bfd_und_section_ptr;
	      else
		*secpp = bfd_com_section_ptr;
	    }

	  esym += (isymp->n_numaux + 1) * symesz;
	  secpp += isymp->n_numaux + 1;
	  isymp += isymp->n_numaux + 1;
	}

      if (! sh_relocate_section (output_bfd, link_info, input_bfd,
				 input_section, data, internal_relocs,
				 internal_syms, sections))
	goto error_return;

      free (sections);
      sections = NULL;
      free (internal_syms);
      internal_syms = NULL;
      free (internal_relocs);
      internal_relocs = NULL;
    }

  return data;

 error_return:
  if (internal_relocs != NULL)
    free (internal_relocs);
  if (internal_syms != NULL)
    free (internal_syms);
  if (sections != NULL)
    free (sections);
  return NULL;
}

/* The target vectors.  */

#ifndef TARGET_SHL_SYM
CREATE_BIG_COFF_TARGET_VEC (shcoff_vec, "coff-sh", BFD_IS_RELAXABLE, 0, '_', NULL, COFF_SWAP_TABLE)
#endif

#ifdef TARGET_SHL_SYM
#define TARGET_SYM TARGET_SHL_SYM
#else
#define TARGET_SYM shlcoff_vec
#endif

#ifndef TARGET_SHL_NAME
#define TARGET_SHL_NAME "coff-shl"
#endif

#ifdef COFF_WITH_PE
CREATE_LITTLE_COFF_TARGET_VEC (TARGET_SYM, TARGET_SHL_NAME, BFD_IS_RELAXABLE,
			       SEC_CODE | SEC_DATA, '_', NULL, COFF_SWAP_TABLE);
#else
CREATE_LITTLE_COFF_TARGET_VEC (TARGET_SYM, TARGET_SHL_NAME, BFD_IS_RELAXABLE,
			       0, '_', NULL, COFF_SWAP_TABLE)
#endif

#ifndef TARGET_SHL_SYM
static const bfd_target * coff_small_object_p PARAMS ((bfd *));
static bfd_boolean coff_small_new_section_hook PARAMS ((bfd *, asection *));
/* Some people want versions of the SH COFF target which do not align
   to 16 byte boundaries.  We implement that by adding a couple of new
   target vectors.  These are just like the ones above, but they
   change the default section alignment.  To generate them in the
   assembler, use -small.  To use them in the linker, use -b
   coff-sh{l}-small and -oformat coff-sh{l}-small.

   Yes, this is a horrible hack.  A general solution for setting
   section alignment in COFF is rather complex.  ELF handles this
   correctly.  */

/* Only recognize the small versions if the target was not defaulted.
   Otherwise we won't recognize the non default endianness.  */

static const bfd_target *
coff_small_object_p (abfd)
     bfd *abfd;
{
  if (abfd->target_defaulted)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }
  return coff_object_p (abfd);
}

/* Set the section alignment for the small versions.  */

static bfd_boolean
coff_small_new_section_hook (abfd, section)
     bfd *abfd;
     asection *section;
{
  if (! coff_new_section_hook (abfd, section))
    return FALSE;

  /* We must align to at least a four byte boundary, because longword
     accesses must be on a four byte boundary.  */
  if (section->alignment_power == COFF_DEFAULT_SECTION_ALIGNMENT_POWER)
    section->alignment_power = 2;

  return TRUE;
}

/* This is copied from bfd_coff_std_swap_table so that we can change
   the default section alignment power.  */

static const bfd_coff_backend_data bfd_coff_small_swap_table =
{
  coff_swap_aux_in, coff_swap_sym_in, coff_swap_lineno_in,
  coff_swap_aux_out, coff_swap_sym_out,
  coff_swap_lineno_out, coff_swap_reloc_out,
  coff_swap_filehdr_out, coff_swap_aouthdr_out,
  coff_swap_scnhdr_out,
  FILHSZ, AOUTSZ, SCNHSZ, SYMESZ, AUXESZ, RELSZ, LINESZ, FILNMLEN,
#ifdef COFF_LONG_FILENAMES
  TRUE,
#else
  FALSE,
#endif
#ifdef COFF_LONG_SECTION_NAMES
  TRUE,
#else
  FALSE,
#endif
  2,
#ifdef COFF_FORCE_SYMBOLS_IN_STRINGS
  TRUE,
#else
  FALSE,
#endif
#ifdef COFF_DEBUG_STRING_WIDE_PREFIX
  4,
#else
  2,
#endif
  coff_swap_filehdr_in, coff_swap_aouthdr_in, coff_swap_scnhdr_in,
  coff_swap_reloc_in, coff_bad_format_hook, coff_set_arch_mach_hook,
  coff_mkobject_hook, styp_to_sec_flags, coff_set_alignment_hook,
  coff_slurp_symbol_table, symname_in_debug_hook, coff_pointerize_aux_hook,
  coff_print_aux, coff_reloc16_extra_cases, coff_reloc16_estimate,
  coff_classify_symbol, coff_compute_section_file_positions,
  coff_start_final_link, coff_relocate_section, coff_rtype_to_howto,
  coff_adjust_symndx, coff_link_add_one_symbol,
  coff_link_output_has_begun, coff_final_link_postscript
};

#define coff_small_close_and_cleanup \
  coff_close_and_cleanup
#define coff_small_bfd_free_cached_info \
  coff_bfd_free_cached_info
#define coff_small_get_section_contents \
  coff_get_section_contents
#define coff_small_get_section_contents_in_window \
  coff_get_section_contents_in_window

extern const bfd_target shlcoff_small_vec;

const bfd_target shcoff_small_vec =
{
  "coff-sh-small",		/* name */
  bfd_target_coff_flavour,
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | BFD_IS_RELAXABLE),

  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC),
  '_',				/* leading symbol underscore */
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */

  {_bfd_dummy_target, coff_small_object_p, /* bfd_check_format */
     bfd_generic_archive_p, _bfd_dummy_target},
  {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format */
     bfd_false},
  {bfd_false, coff_write_object_contents, /* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

  BFD_JUMP_TABLE_GENERIC (coff_small),
  BFD_JUMP_TABLE_COPY (coff),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
  BFD_JUMP_TABLE_SYMBOLS (coff),
  BFD_JUMP_TABLE_RELOCS (coff),
  BFD_JUMP_TABLE_WRITE (coff),
  BFD_JUMP_TABLE_LINK (coff),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  & shlcoff_small_vec,

  (PTR) &bfd_coff_small_swap_table
};

const bfd_target shlcoff_small_vec =
{
  "coff-shl-small",		/* name */
  bfd_target_coff_flavour,
  BFD_ENDIAN_LITTLE,		/* data byte order is little */
  BFD_ENDIAN_LITTLE,		/* header byte order is little endian too*/

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | BFD_IS_RELAXABLE),

  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC),
  '_',				/* leading symbol underscore */
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,
  bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,
  bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */

  {_bfd_dummy_target, coff_small_object_p, /* bfd_check_format */
     bfd_generic_archive_p, _bfd_dummy_target},
  {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format */
     bfd_false},
  {bfd_false, coff_write_object_contents, /* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

  BFD_JUMP_TABLE_GENERIC (coff_small),
  BFD_JUMP_TABLE_COPY (coff),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
  BFD_JUMP_TABLE_SYMBOLS (coff),
  BFD_JUMP_TABLE_RELOCS (coff),
  BFD_JUMP_TABLE_WRITE (coff),
  BFD_JUMP_TABLE_LINK (coff),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  & shcoff_small_vec,

  (PTR) &bfd_coff_small_swap_table
};
#endif
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d709 1
a709 1
  if (link_info->relocateable
d1650 2
d1671 1
a1671 1
#endif
a1673 2
#define MAP(a) a, sizeof a / sizeof a[0]

a2091 1
#ifndef COFF_IMAGE_WITH_PE
a2110 1
#endif
a2131 1
#ifndef COFF_IMAGE_WITH_PE
d2969 1
a2969 1
	  else if (! info->relocateable)
d3024 1
a3024 1
					data, relocateable, symbols)
d3029 1
a3029 1
     bfd_boolean relocateable;
d3040 1
a3040 1
  if (relocateable
d3045 1
a3045 1
						       relocateable,
d3132 1
a3132 1
CREATE_BIG_COFF_TARGET_VEC (shcoff_vec, "coff-sh", BFD_IS_RELAXABLE, 0, '_', NULL)
d3147 1
a3147 1
			       SEC_CODE | SEC_DATA, '_', NULL);
d3150 1
a3150 1
			       0, '_', NULL)
@


1.6
log
@resolve conflicts.
@
text
@d1 2
a2 2
/* BFD back-end for Hitachi Super-H COFF binaries.
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
d8 1
a8 1
This file is part of BFD, the Binary File Descriptor library.
d10 13
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d26 1
d36 1
a36 1
static boolean sh_align_load_span
d38 2
a39 2
	   boolean (*) (bfd *, asection *, PTR, bfd_byte *, bfd_vma),
	   PTR, bfd_vma **, bfd_vma *, bfd_vma, bfd_vma, boolean *));
d51 3
a53 3
static boolean sh_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, boolean *));
static boolean sh_relax_delete_bytes
d58 4
a61 3
static boolean sh_align_loads
  PARAMS ((bfd *, asection *, struct internal_reloc *, bfd_byte *, boolean *));
static boolean sh_swap_insns
d63 1
a63 1
static boolean sh_relocate_section
d68 2
a69 1
	   bfd_byte *, boolean, asymbol **));
d88 2
a89 1
/* Return true if this relocation should
d91 1
a91 1
static boolean in_reloc_p (abfd, howto)
d111 1
a111 1
	 false,			/* pc_relative */
d116 1
a116 1
	 true,			/* partial_inplace */
d119 1
a119 1
	 false),		/* pcrel_offset */
d135 1
a135 1
	 true,			/* pc_relative */
d140 1
a140 1
	 true,			/* partial_inplace */
d143 1
a143 1
	 true),			/* pcrel_offset */
d151 1
a151 1
	 true,			/* pc_relative */
d156 1
a156 1
	 true,			/* partial_inplace */
d159 1
a159 1
	 true),			/* pcrel_offset */
d167 1
a167 1
	 false,			/* pc_relative */
d172 1
a172 1
	 true,			/* partial_inplace */
d175 1
a175 1
	 false),		/* pcrel_offset */
d183 1
a183 1
	 false,	                /* pc_relative */
d188 1
a188 1
	 true,	                /* partial_inplace */
d191 1
a191 1
	 false),                /* pcrel_offset */
d205 1
a205 1
	 true,			/* pc_relative */
d210 1
a210 1
	 true,			/* partial_inplace */
d213 1
a213 1
	 true),			/* pcrel_offset */
d219 1
a219 1
	 true,			/* pc_relative */
d224 1
a224 1
	 true,			/* partial_inplace */
d227 1
a227 1
	 true),			/* pcrel_offset */
d233 1
a233 1
	 false,			/* pc_relative */
d238 1
a238 1
	 true,			/* partial_inplace */
d241 1
a241 1
	 false),		/* pcrel_offset */
d247 1
a247 1
	 false,			/* pc_relative */
d252 1
a252 1
	 true,			/* partial_inplace */
d255 1
a255 1
	 false),		/* pcrel_offset */
d261 1
a261 1
	 false,			/* pc_relative */
d266 1
a266 1
	 true,			/* partial_inplace */
d269 1
a269 1
	 false),		/* pcrel_offset */
d275 1
a275 1
	 false,			/* pc_relative */
d280 1
a280 1
	 true,			/* partial_inplace */
d283 1
a283 1
	 false),		/* pcrel_offset */
d289 1
a289 1
	 false,			/* pc_relative */
d294 1
a294 1
	 true,			/* partial_inplace */
d297 1
a297 1
	 false),		/* pcrel_offset */
d303 1
a303 1
	 false,			/* pc_relative */
d308 1
a308 1
	 true,			/* partial_inplace */
d311 1
a311 1
	 false),		/* pcrel_offset */
d317 1
a317 1
	 false,			/* pc_relative */
d322 1
a322 1
	 true,			/* partial_inplace */
d325 1
a325 1
	 false),		/* pcrel_offset */
d331 1
a331 1
	 false,			/* pc_relative */
d336 1
a336 1
	 true,			/* partial_inplace */
d339 1
a339 1
	 false),		/* pcrel_offset */
d345 1
a345 1
	 false,			/* pc_relative */
d350 1
a350 1
	 true,			/* partial_inplace */
d353 1
a353 1
	 false),		/* pcrel_offset */
d359 1
a359 1
	 false,			/* pc_relative */
d364 1
a364 1
	 true,			/* partial_inplace */
d367 1
a367 1
	 false)			/* pcrel_offset */
d383 2
a384 2
#define SWAP_IN_RELOC_OFFSET  bfd_h_get_32
#define SWAP_OUT_RELOC_OFFSET bfd_h_put_32
d418 1
d468 2
d473 1
a473 1
  unsigned char bfd_reloc_val;
d477 1
d485 8
d505 3
a507 5
  for (i = 0; i < sizeof (sh_reloc_map) / sizeof (struct shcoff_reloc_map); i++)
    {
      if (sh_reloc_map[i].bfd_reloc_val == code)
	return &sh_coff_howtos[(int) sh_reloc_map[i].shcoff_reloc_val];
    }
a511 1
#endif /* COFF_WITH_PE */
d602 1
a602 1
      bfd_put_32 (abfd, insn, hit_data);
d607 3
a609 3
      insn += (sym_value + reloc_entry->addend
	       - pe_data (input_section->output_section->owner)->pe_opthdr.ImageBase);
      bfd_put_32 (abfd, insn, hit_data);
d623 1
a623 1
      bfd_put_16 (abfd, insn, hit_data);
d693 1
a693 1
static boolean
d698 1
a698 1
     boolean *again;
d702 1
a702 1
  boolean have_code;
d707 1
a707 1
  *again = false;
d712 1
a712 1
    return true;
d721 1
a721 1
		      (bfd_byte *) NULL, false,
d728 1
a728 1
  have_code = false;
d740 1
a740 1
	have_code = true;
d774 1
a774 1
				 bfd_get_filename (abfd),
d785 1
a785 1
	    bfd_get_filename (abfd), (unsigned long) irel->r_vaddr, insn));
d797 1
a797 1
      paddr += (laddr + 4) &~ 3;
d802 1
a802 1
	    bfd_get_filename (abfd), (unsigned long) irel->r_vaddr));
d825 1
a825 1
	    bfd_get_filename (abfd), (unsigned long) paddr));
d841 1
a841 1
	    bfd_get_filename (abfd), (unsigned long) paddr));
d899 2
a900 2
	  sec->used_by_bfd =
	    ((PTR) bfd_zalloc (abfd, sizeof (struct coff_section_tdata)));
d906 1
a906 1
      coff_section_data (abfd, sec)->keep_relocs = true;
d910 1
a910 1
      coff_section_data (abfd, sec)->keep_contents = true;
d913 1
a913 1
      obj_coff_keep_syms (abfd) = true;
d927 1
a927 1
		      0xb000 | ((foff >> 1) & 0xfff),
d935 2
a936 1
	  bfd_put_16 (abfd, 0xb000, contents + irel->r_vaddr - sec->vma);
d969 1
a969 1
      *again = true;
d976 1
a976 1
	    bfd_get_filename (abfd), (unsigned long) paddr));
d985 1
a985 1
				  bfd_get_filename (abfd),
d1009 1
a1009 1
      boolean swapped;
d1037 2
a1038 2
	      sec->used_by_bfd =
		((PTR) bfd_zalloc (abfd, sizeof (struct coff_section_tdata)));
d1044 1
a1044 1
	  coff_section_data (abfd, sec)->keep_relocs = true;
d1048 1
a1048 1
	  coff_section_data (abfd, sec)->keep_contents = true;
d1051 1
a1051 1
	  obj_coff_keep_syms (abfd) = true;
d1070 2
a1071 2
	      sec->used_by_bfd =
		((PTR) bfd_zalloc (abfd, sizeof (struct coff_section_tdata)));
d1080 1
a1080 1
  return true;
d1087 1
a1087 1
  return false;
d1092 1
a1092 1
static boolean
d1131 2
a1132 1
  memmove (contents + addr, contents + addr + count, toaddr - addr - count);
d1143 1
a1143 1
	bfd_put_16 (abfd, NOP_OPCODE, contents + toaddr - count + i);
d1155 1
a1155 1
      boolean overflow;
d1317 1
a1317 1
	  overflow = false;
d1328 2
a1329 2
		overflow = true;
	      bfd_put_16 (abfd, insn, contents + nraddr);
d1335 2
a1336 2
		overflow = true;
	      bfd_put_16 (abfd, insn, contents + nraddr);
d1349 2
a1350 2
		overflow = true;
	      bfd_put_16 (abfd, insn, contents + nraddr);
d1356 2
a1357 2
		overflow = true;
	      bfd_put_8 (abfd, voff, contents + nraddr);
d1363 2
a1364 2
		overflow = true;
	      bfd_put_signed_16 (abfd, voff, contents + nraddr);
d1369 1
a1369 1
	      bfd_put_signed_32 (abfd, voff, contents + nraddr);
d1381 1
a1381 1
		bfd_get_filename (abfd), (unsigned long) irel->r_vaddr));
d1383 1
a1383 1
	      return false;
d1405 1
a1405 1
         false, we should free them, if we are permitted to, when we
d1408 1
a1408 1
			 (abfd, o, true, (bfd_byte *) NULL, false,
d1411 1
a1411 1
	return false;
d1447 1
a1447 1
                         Perhaps, if info->keep_memory is false, we
d1452 1
a1452 1
			return false;
d1456 1
a1456 1
			return false;
d1467 1
a1467 1
	      coff_section_data (abfd, o)->keep_contents = true;
d1481 1
a1481 1
	bfd_get_filename (abfd)));
d1483 1
a1483 1
      return false;
d1532 1
a1532 1
					alignto - alignaddr);
d1536 1
a1536 1
  return true;
d1651 1
a1651 1
static boolean sh_insn_uses_reg
d1653 1
a1653 1
static boolean sh_insn_sets_reg
d1655 1
a1655 1
static boolean sh_insn_uses_or_sets_reg
d1657 1
a1657 1
static boolean sh_insn_uses_freg
d1659 1
a1659 1
static boolean sh_insn_sets_freg
d1661 1
a1661 1
static boolean sh_insn_uses_or_sets_freg
d1663 1
a1663 1
static boolean sh_insns_conflict
d1666 1
a1666 1
static boolean sh_load_use
d2092 1
d2112 1
d2170 1
a2170 1
static boolean
d2177 1
a2177 1
    return true;
d2184 1
a2184 1
static boolean
d2196 1
a2196 1
    return true;
d2199 1
a2199 1
    return true;
d2202 1
a2202 1
    return true;
d2204 1
a2204 1
    return true;
d2206 1
a2206 1
    return true;
d2208 1
a2208 1
  return false;
d2213 1
a2213 1
static boolean
d2225 1
a2225 1
    return true;
d2228 1
a2228 1
    return true;
d2231 1
a2231 1
    return true;
d2233 1
a2233 1
    return true;
d2235 1
a2235 1
  return false;
d2240 1
a2240 1
static boolean
d2247 1
a2247 1
    return true;
d2254 1
a2254 1
static boolean
d2275 1
a2275 1
    return true;
d2278 1
a2278 1
    return true;
d2281 1
a2281 1
    return true;
d2283 1
a2283 1
  return false;
d2288 1
a2288 1
static boolean
d2309 1
a2309 1
    return true;
d2311 1
a2311 1
  return false;
d2316 1
a2316 1
   This should return true if there is a conflict, or false if the
d2319 1
a2319 1
static boolean
d2335 1
a2335 1
    return true;
d2339 1
a2339 1
    return true;
d2344 1
a2344 1
    return true;
d2348 1
a2348 1
    return true;
d2351 1
a2351 1
    return true;
d2354 1
a2354 1
    return true;
d2357 1
a2357 1
    return true;
d2360 1
a2360 1
    return true;
d2364 1
a2364 1
    return true;
d2367 1
a2367 1
    return true;
d2370 1
a2370 1
    return true;
d2373 1
a2373 1
    return true;
d2376 1
a2376 1
    return true;
d2379 1
a2379 1
  return false;
d2383 1
a2383 1
   true if I1 loads a register which I2 uses.  */
d2385 1
a2385 1
static boolean
d2397 1
a2397 1
    return false;
d2405 1
a2405 1
    return true;
d2409 1
a2409 1
    return true;
d2413 1
a2413 1
    return true;
d2415 1
a2415 1
  return false;
d2426 1
a2426 1
   *PSWAPPED is set to true.  */
d2431 1
a2431 1
boolean
d2437 1
a2437 1
     boolean (*swap) PARAMS ((bfd *, asection *, PTR, bfd_byte *, bfd_vma));
d2443 1
a2443 1
     boolean *pswapped;
d2453 1
a2453 1
    return true;
d2527 1
a2527 1
	  boolean ok;
d2534 1
a2534 1
	  ok = true;
d2549 1
a2549 1
		ok = false;
d2559 1
a2559 1
		ok = false;
d2565 2
a2566 2
		return false;
	      *pswapped = true;
d2588 1
a2588 1
	      boolean ok;
d2593 1
a2593 1
	      ok = true;
d2602 1
a2602 1
		ok = false;
d2624 1
a2624 1
		    ok = false;
d2630 2
a2631 2
		    return false;
		  *pswapped = true;
d2638 1
a2638 1
  return true;
d2647 1
a2647 1
static boolean
d2653 1
a2653 1
     boolean *pswapped;
d2658 1
d2660 1
a2660 1
  *pswapped = false;
d2665 2
a2666 1
  labels = (bfd_vma *) bfd_malloc (sec->reloc_count * sizeof (bfd_vma));
d2710 1
a2710 1
  return true;
d2715 1
a2715 1
  return false;
d2720 1
a2720 1
static boolean
d2735 2
a2736 2
  bfd_put_16 (abfd, i2, contents + addr);
  bfd_put_16 (abfd, i1, contents + addr + 2);
d2788 1
a2788 1
	  boolean overflow;
d2791 1
a2791 1
	  overflow = false;
d2803 2
a2804 2
		overflow = true;
	      bfd_put_16 (abfd, insn, loc);
d2812 2
a2813 2
		overflow = true;
	      bfd_put_16 (abfd, insn, loc);
d2829 2
a2830 2
		    overflow = true;
		  bfd_put_16 (abfd, insn, loc);
d2840 1
a2840 1
		bfd_get_filename (abfd), (unsigned long) irel->r_vaddr));
d2842 1
a2842 1
	      return false;
d2847 1
a2847 1
  return true;
d2853 1
a2853 1
static boolean
d2904 1
a2904 1
		 bfd_get_filename (input_bfd), symndx);
d2906 1
a2906 1
	      return false;
d2928 1
a2928 1
	  return false;
d2976 2
a2977 2
		      rel->r_vaddr - input_section->vma, true)))
		return false;
d3014 1
a3014 1
	      return false;
d3019 1
a3019 1
  return true;
d3032 1
a3032 1
     boolean relocateable;
d3052 1
a3052 1
	  input_section->_raw_size);
d3061 1
d3067 2
a3068 2
			 (input_bfd, input_section, false, (bfd_byte *) NULL,
			  false, (struct internal_reloc *) NULL));
d3072 3
a3074 3
      internal_syms = ((struct internal_syment *)
		       bfd_malloc (obj_raw_syment_count (input_bfd)
				   * sizeof (struct internal_syment)));
d3078 3
a3080 2
      sections = (asection **) bfd_malloc (obj_raw_syment_count (input_bfd)
					   * sizeof (asection *));
d3157 2
d3187 1
a3187 1
static boolean
d3193 1
a3193 1
    return false;
d3200 1
a3200 1
  return true;
d3215 1
a3215 1
  true,
d3217 1
a3217 1
  false,
d3220 1
a3220 1
  true,
d3222 1
a3222 1
  false,
d3226 1
a3226 1
  true,
d3228 1
a3228 1
  false,
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright 1993, 94, 95, 96, 97, 98, 1999, 2000 Free Software Foundation, Inc.
d35 1
a35 1
static boolean sh_align_load_span 
d92 1
a92 1
}     
d175 6
a180 6
  HOWTO (R_SH_IMAGEBASE,        /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d182 5
a186 5
	 sh_reloc,       	/* special_function */                     
	 "rva32",	        /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
d395 1
a395 1
get_symbol_value (symbol)       
d397 1
a397 1
{                                             
d401 2
a402 2
    relocation = 0;                           
  else 
d680 1
a680 1
static boolean 
d2148 1
a2148 1
  return NULL;  
d2255 1
a2255 1
     
d2289 1
a2289 1
     
d2489 1
a2489 1
	
d2879 1
a2879 1
	{    
d2916 1
a2916 1
      
d3122 1
a3122 1
     
d3202 10
d3274 1
a3274 1
  
d3301 1
a3301 1
     bfd_generic_archive_p, _bfd_dummy_target},   
d3318 1
a3318 1
  
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
a24 1
#include "obstack.h"
d29 14
d53 1
d55 1
d67 4
d72 7
a78 1
#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (4)
d83 11
d98 27
a124 10
  { 0 },
  { 1 },
  { 2 },
  { 3 }, /* R_SH_PCREL8 */
  { 4 }, /* R_SH_PCREL16 */
  { 5 }, /* R_SH_HIGH8 */
  { 6 }, /* R_SH_IMM24 */
  { 7 }, /* R_SH_LOW16 */
  { 8 },
  { 9 }, /* R_SH_PCDISP8BY4 */
d140 1
a140 1
  { 11 }, /* R_SH_PCDISP8 */
d156 1
a156 1
  { 13 },
d172 23
a194 7
  { 15 },
  { 16 }, /* R_SH_IMM8 */
  { 17 }, /* R_SH_IMM8BY2 */
  { 18 }, /* R_SH_IMM8BY4 */
  { 19 }, /* R_SH_IMM4 */
  { 20 }, /* R_SH_IMM4BY2 */
  { 21 }, /* R_SH_IMM4BY4 */
d348 14
d376 1
d389 1
d409 90
d526 2
a527 1
    if ((reloc).r_type == R_SH_SWITCH16				\
d546 1
a546 1
     char **error_message;
d566 4
d583 3
d590 8
d621 2
d754 3
a756 1
      laddr = irel->r_vaddr - sec->vma + 4 + irel->r_offset;
d766 1
a766 2
      /* If the instruction is not mov.l NN,rN, we don't know what to
         do.  */
d798 6
d805 1
d1133 2
a1134 1
      bfd_vma nraddr, start, stop;
d1138 1
a1138 1
      bfd_signed_vma voff;
d1156 2
a1157 1
	  && irel->r_type != R_SH_DATA)
d1183 4
d1205 1
a1205 1
	      if (val >= addr && val < toaddr)
d1245 1
d1271 2
d1337 7
d1403 5
d1409 1
d1447 1
a1447 1
	      if (val >= addr && val < toaddr)
d1561 1
a1561 1
  unsigned short flags;
d1581 1
d1586 1
d1594 1
d1599 1
d1613 1
d1618 1
d1626 1
d1628 7
d1637 4
d1643 4
d1653 1
a1653 1

a1674 1
  { 0x0002, SETS1 | USESSP },			/* stc sr,rn */
a1676 1
  { 0x0012, SETS1 | USESSP },			/* stc gbr,rn */
a1677 1
  { 0x0022, SETS1 | USESSP },			/* stc vbr,rn */
d1681 15
d1698 3
a1700 2
  { 0x005a, SETS1 | USESSP },			/* sts fpul,rn */
  { 0x006a, SETS1 | USESSP },			/* sts fpscr,rn */
a1701 1
  { 0x0083, LOAD | USES1 },			/* pref @@rn */
d1709 1
a1709 1
};
d1713 1
a1792 1
  { 0x4003, STORE | SETS1 | USES1 | USESSP },	/* stc.l sr,@@-rn */
a1795 1
  { 0x4007, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,sr */
a1799 1
  { 0x400e, SETSSP | USES1 },			/* ldc rm,sr */
d1803 1
a1803 1
  { 0x4013, STORE | SETS1 | USES1 | USESSP },	/* stc.l gbr,@@-rn */
a1805 1
  { 0x4017, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,gbr */
a1809 1
  { 0x401e, SETSSP | USES1 },			/* ldc rm,gbr */
a1812 1
  { 0x4023, STORE | SETS1 | USES1 | USESSP },	/* stc.l vbr,@@-rn */
a1815 1
  { 0x4027, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,vbr */
d1820 26
a1845 1
  { 0x402e, SETSSP | USES1 },			/* ldc rm,vbr */
d1847 11
d1859 11
a1870 2
  { 0x4043, STORE | SETS1 | USES1 | USESSP },	/* stc.l spc,@@-rn */
  { 0x4047, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,spc */
d1872 7
a1878 6
  { 0x4052, STORE | SETS1 | USES1 | USESSP },	/* sts.l fpul,@@-rn */
  { 0x4056, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,fpul */
  { 0x405a, SETSSP | USES1 },			/* lds.l rm,fpul */
  { 0x4062, STORE | SETS1 | USES1 | USESSP },	/* sts.l fpscr,@@-rn */
  { 0x4066, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,fpscr */
  { 0x406a, SETSSP | USES1 }			/* lds rm,fpscr */
d1883 5
a1887 9
  { 0x4083, STORE | SETS1 | USES1 | USESSP },	/* stc.l rx_bank,@@-rn */
  { 0x4087, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,rx_bank */
  { 0x408e, SETSSP | USES1 }			/* ldc rm,rx_bank */
};

static const struct sh_opcode sh_opcode42[] =
{
  { 0x400c, SETS1 | USES1 | USES2 },			/* shad rm,rn */
  { 0x400d, SETS1 | USES1 | USES2 },			/* shld rm,rn */
d1894 1
a1894 2
  { MAP (sh_opcode41), 0xf08f },
  { MAP (sh_opcode42), 0xf00f }
d1946 1
d1952 1
d1954 1
d2076 1
a2076 1
static const struct sh_major_opcode sh_opcodes[] =
d2096 21
d2150 14
d2177 1
a2177 1
      && ((insn & 0x0f00) >> 8) == reg)
d2180 1
a2180 1
      && ((insn & 0x00f0) >> 4) == reg)
d2185 31
d2220 14
d2246 9
d2256 1
a2256 1
      && ((insn & 0x0f00) >> 8) == freg)
d2259 1
a2259 1
      && ((insn & 0x00f0) >> 4) == freg)
d2268 28
d2313 6
d2323 3
a2325 3
  if ((f1 & SETSSP) != 0 && (f2 & USESSP) != 0)
    return true;
  if ((f2 & SETSSP) != 0 && (f1 & USESSP) != 0)
d2329 1
a2329 1
      && sh_insn_uses_reg (i2, op2, (i1 & 0x0f00) >> 8))
d2332 1
a2332 1
      && sh_insn_uses_reg (i2, op2, (i1 & 0x00f0) >> 4))
d2335 4
a2338 1
      && sh_insn_uses_reg (i2, op2, 0))
d2341 1
a2341 1
      && sh_insn_uses_freg (i2, op2, (i1 & 0x0f00) >> 8))
d2345 1
a2345 1
      && sh_insn_uses_reg (i1, op1, (i2 & 0x0f00) >> 8))
d2348 1
a2348 1
      && sh_insn_uses_reg (i1, op1, (i2 & 0x00f0) >> 4))
d2351 4
a2354 1
      && sh_insn_uses_reg (i1, op1, 0))
d2357 1
a2357 1
      && sh_insn_uses_freg (i1, op1, (i2 & 0x0f00) >> 8))
d2410 3
d2427 2
d2431 14
d2474 22
a2495 1
	  prev_op = sh_insn_info (prev_insn);
d2622 1
d2836 1
a2836 1
     bfd *output_bfd;
d2863 4
d2879 2
a2880 1
	  if (symndx < 0 || symndx >= obj_raw_syment_count (input_bfd))
d2911 5
d2956 1
a2956 1
		      rel->r_vaddr - input_section->vma)))
d3112 112
a3223 1
const bfd_target shcoff_vec =
d3225 1
a3225 1
  "coff-sh",			/* name */
d3245 1
a3245 1
  {_bfd_dummy_target, coff_object_p, /* bfd_check_format */
d3252 1
a3252 1
  BFD_JUMP_TABLE_GENERIC (coff),
d3262 3
a3264 1
  COFF_SWAP_TABLE,
d3267 1
a3267 1
const bfd_target shlcoff_vec =
d3269 1
a3269 1
  "coff-shl",			/* name */
d3289 1
a3289 1
  {_bfd_dummy_target, coff_object_p, /* bfd_check_format */
d3296 1
a3296 1
  BFD_JUMP_TABLE_GENERIC (coff),
d3306 3
a3308 1
  COFF_SWAP_TABLE,
d3310 1
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2410 8
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d44 1
a44 1
  PARAMS ((bfd *, asection *, struct internal_reloc *, bfd_byte *, bfd_vma));
d1886 2
a1887 1
   This should return true if the instructions can be swapped safely.  */
d1906 1
a1906 1
    return false;
d1976 183
d2202 1
a2202 1
      bfd_vma start, stop, i;
d2217 4
a2220 156
      /* Instructions should be aligned on 2 byte boundaries.  */
      if ((start & 1) == 1)
	++start;

      /* Now look through the unaligned addresses.  */
      i = start;
      if ((i & 2) == 0)
	i += 2;
      for (; i < stop; i += 4)
	{
	  unsigned int insn;
	  const struct sh_opcode *op;
	  unsigned int prev_insn = 0;
	  const struct sh_opcode *prev_op = NULL;

	  insn = bfd_get_16 (abfd, contents + i);
	  op = sh_insn_info (insn);
	  if (op == NULL
	      || (op->flags & (LOAD | STORE)) == 0)
	    continue;

	  /* This is a load or store which is not on a four byte
             boundary.  */

	  while (label < label_end && *label < i)
	    ++label;

	  if (i > start)
	    {
	      prev_insn = bfd_get_16 (abfd, contents + i - 2);
	      prev_op = sh_insn_info (prev_insn);

	      /* If the load/store instruction is in a delay slot, we
		 can't swap.  */
	      if (prev_op == NULL
		  || (prev_op->flags & DELAY) != 0)
		continue;
	    }
	  if (i > start
	      && (label >= label_end || *label != i)
	      && prev_op != NULL
	      && (prev_op->flags & (LOAD | STORE)) == 0
	      && ! sh_insns_conflict (prev_insn, prev_op, insn, op))
	    {
	      boolean ok;

	      /* The load/store instruction does not have a label, and
		 there is a previous instruction; PREV_INSN is not
		 itself a load/store instruction, and PREV_INSN and
		 INSN do not conflict.  */

	      ok = true;

	      if (i >= start + 4)
		{
		  unsigned int prev2_insn;
		  const struct sh_opcode *prev2_op;

		  prev2_insn = bfd_get_16 (abfd, contents + i - 4);
		  prev2_op = sh_insn_info (prev2_insn);

		  /* If the instruction before PREV_INSN has a delay
		     slot--that is, PREV_INSN is in a delay slot--we
		     can not swap.  */
		  if (prev2_op == NULL
		      || (prev2_op->flags & DELAY) != 0)
		    ok = false;

		  /* If the instruction before PREV_INSN is a load,
                     and it sets a register which INSN uses, then
                     putting INSN immediately after PREV_INSN will
                     cause a pipeline bubble, so there is no point to
                     making the swap.  */
		  if (ok
		      && (prev2_op->flags & LOAD) != 0
		      && sh_load_use (prev2_insn, prev2_op, insn, op))
		    ok = false;
		}

	      if (ok)
		{
		  if (! sh_swap_insns (abfd, sec, internal_relocs,
				       contents, i - 2))
		    goto error_return;
		  *pswapped = true;
		  continue;
		}
	    }

	  while (label < label_end && *label < i + 2)
	    ++label;

	  if (i + 2 < stop
	      && (label >= label_end || *label != i + 2))
	    {
	      unsigned int next_insn;
	      const struct sh_opcode *next_op;

	      /* There is an instruction after the load/store
                 instruction, and it does not have a label.  */
	      next_insn = bfd_get_16 (abfd, contents + i + 2);
	      next_op = sh_insn_info (next_insn);
	      if (next_op != NULL
		  && (next_op->flags & (LOAD | STORE)) == 0
		  && ! sh_insns_conflict (insn, op, next_insn, next_op))
		{
		  boolean ok;

		  /* NEXT_INSN is not itself a load/store instruction,
                     and it does not conflict with INSN.  */

		  ok = true;

		  /* If PREV_INSN is a load, and it sets a register
		     which NEXT_INSN uses, then putting NEXT_INSN
		     immediately after PREV_INSN will cause a pipeline
		     bubble, so there is no reason to make this swap.  */
		  if (prev_op != NULL
		      && (prev_op->flags & LOAD) != 0
		      && sh_load_use (prev_insn, prev_op, next_insn, next_op))
		    ok = false;

		  /* If INSN is a load, and it sets a register which
                     the insn after NEXT_INSN uses, then doing the
                     swap will cause a pipeline bubble, so there is no
                     reason to make the swap.  However, if the insn
                     after NEXT_INSN is itself a load or store
                     instruction, then it is misaligned, so
                     optimistically hope that it will be swapped
                     itself, and just live with the pipeline bubble if
                     it isn't.  */
		  if (ok
		      && i + 4 < stop
		      && (op->flags & LOAD) != 0)
		    {
		      unsigned int next2_insn;
		      const struct sh_opcode *next2_op;

		      next2_insn = bfd_get_16 (abfd, contents + i + 4);
		      next2_op = sh_insn_info (next2_insn);
		      if ((next2_op->flags & (LOAD | STORE)) == 0
			   && sh_load_use (insn, op, next2_insn, next2_op))
			ok = false;
		    }

		  if (ok)
		    {
		      if (! sh_swap_insns (abfd, sec, internal_relocs,
					   contents, i))
			goto error_return;
		      *pswapped = true;
		      continue;
		    }
		}
	    }
	}
d2236 1
a2236 1
sh_swap_insns (abfd, sec, internal_relocs, contents, addr)
d2239 1
a2239 1
     struct internal_reloc *internal_relocs;
d2243 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995 Free Software Foundation, Inc.
d5 1
d40 5
d52 2
a53 2
/* Default section alignment to 2**2.  */
#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (2)
d237 42
d442 1
a442 1

d477 8
a484 1
   address.  */
d495 1
d521 2
d532 3
d546 1
a546 1
	      contents = (bfd_byte *) malloc (sec->_raw_size);
d548 1
a548 4
		{
		  bfd_set_error (bfd_error_no_memory);
		  goto error_return;
		}
d687 1
a687 4
	    {
	      bfd_set_error (bfd_error_no_memory);
	      goto error_return;
	    }
d789 50
d857 1
a857 4
		{
		  bfd_set_error (bfd_error_no_memory);
		  goto error_return;
		}
d919 9
a927 1
    memset (contents + toaddr - count, 0, count);
d948 2
a949 1
	 case we no longer care about it.  */
d952 3
a954 1
	  && irel->r_type != R_SH_ALIGN)
d1071 3
a1073 1
	  stop = (bfd_vma) ((bfd_signed_vma) start + (long) irel->r_offset);
d1211 1
a1211 1
		      ocontents = (bfd_byte *) malloc (o->_raw_size);
d1213 1
a1213 4
			{
			  bfd_set_error (bfd_error_no_memory);
			  return false;
			}
d1284 1
a1284 1
      bfd_vma alignaddr;
d1286 1
d1289 1
a1289 1
      if (alignaddr != toaddr)
d1292 715
a2006 3
	  return sh_relax_delete_bytes (abfd, sec,
					irelalign->r_vaddr - sec->vma,
					1 << irelalign->r_offset);
d2010 183
d2194 5
d2201 131
d2536 2
a2537 2
		       malloc (obj_raw_syment_count (input_bfd)
			       * sizeof (struct internal_syment)));
d2539 1
a2539 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  goto error_return;
	}
d2541 2
a2542 2
      sections = (asection **) malloc (obj_raw_syment_count (input_bfd)
				       * sizeof (asection *));
d2544 1
a2544 4
	{
	  bfd_set_error (bfd_error_no_memory);
	  goto error_return;
	}
d2600 2
a2601 2
  true,				/* data byte order is big */
  true,				/* header byte order is big */
d2642 2
a2643 2
  false,			/* data byte order is little */
  false,			/* header byte order is little endian too*/
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
a4 1
   Relaxing code written by Ian Lance Taylor, <ian@@cygnus.com>.
a38 5
static const struct sh_opcode *sh_insn_info PARAMS ((unsigned int));
static boolean sh_align_loads
  PARAMS ((bfd *, asection *, struct internal_reloc *, bfd_byte *, boolean *));
static boolean sh_swap_insns
  PARAMS ((bfd *, asection *, struct internal_reloc *, bfd_byte *, bfd_vma));
d46 2
a47 2
/* Default section alignment to 2**4.  */
#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (4)
a230 42
	 false),		/* pcrel_offset */

  HOWTO (R_SH_CODE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_code",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_DATA,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_data",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_LABEL,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_label",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
d394 1
a394 1

d429 1
a429 8
   address.

   SH relaxing also handles another, unrelated, matter.  On the SH, if
   a load or store instruction is not aligned on a four byte boundary,
   the memory cycle interferes with the 32 bit instruction fetch,
   causing a one cycle bubble in the pipeline.  Therefore, we try to
   align load and store instructions on four byte boundaries if we
   can, by swapping them with one of the adjacent instructions.  */
a439 1
  boolean have_code;
a464 2
  have_code = false;

a473 3
      if (irel->r_type == R_SH_CODE)
	have_code = true;

d485 1
a485 1
	      contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
d487 4
a490 1
		goto error_return;
d629 4
a632 1
	    goto error_return;
a733 50
  /* Look for load and store instructions that we can align on four
     byte boundaries.  */
  if (have_code)
    {
      boolean swapped;

      /* Get the section contents.  */
      if (contents == NULL)
	{
	  if (coff_section_data (abfd, sec) != NULL
	      && coff_section_data (abfd, sec)->contents != NULL)
	    contents = coff_section_data (abfd, sec)->contents;
	  else
	    {
	      contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
	      if (contents == NULL)
		goto error_return;
	      free_contents = contents;

	      if (! bfd_get_section_contents (abfd, sec, contents,
					      (file_ptr) 0, sec->_raw_size))
		goto error_return;
	    }
	}

      if (! sh_align_loads (abfd, sec, internal_relocs, contents, &swapped))
	goto error_return;

      if (swapped)
	{
	  if (coff_section_data (abfd, sec) == NULL)
	    {
	      sec->used_by_bfd =
		((PTR) bfd_zalloc (abfd, sizeof (struct coff_section_tdata)));
	      if (sec->used_by_bfd == NULL)
		goto error_return;
	    }

	  coff_section_data (abfd, sec)->relocs = internal_relocs;
	  coff_section_data (abfd, sec)->keep_relocs = true;
	  free_relocs = NULL;

	  coff_section_data (abfd, sec)->contents = contents;
	  coff_section_data (abfd, sec)->keep_contents = true;
	  free_contents = NULL;

	  obj_coff_keep_syms (abfd) = true;
	}
    }

d752 4
a755 1
		goto error_return;
d817 1
a817 9
    {
      int i;

#define NOP_OPCODE (0x0009)

      BFD_ASSERT ((count & 1) == 0);
      for (i = 0; i < count; i += 2)
	bfd_put_16 (abfd, NOP_OPCODE, contents + toaddr - count + i);
    }
d838 1
a838 2
	 case we no longer care about it.  Don't delete relocs which
	 represent addresses, though.  */
d841 1
a841 3
	  && irel->r_type != R_SH_ALIGN
	  && irel->r_type != R_SH_CODE
	  && irel->r_type != R_SH_DATA)
d958 1
a958 3
	  stop = (bfd_vma) ((bfd_signed_vma) start
			    + (long) irel->r_offset
			    + 4);
d1096 1
a1096 1
		      ocontents = (bfd_byte *) bfd_malloc (o->_raw_size);
d1098 4
a1101 1
			return false;
d1172 1
a1172 1
      bfd_vma alignto, alignaddr;
a1173 1
      alignto = BFD_ALIGN (toaddr, 1 << irelalign->r_offset);
d1176 1
a1176 1
      if (alignto != alignaddr)
d1179 3
a1181 715
	  return sh_relax_delete_bytes (abfd, sec, alignaddr,
					alignto - alignaddr);
	}
    }

  return true;
}

/* This is yet another version of the SH opcode table, used to rapidly
   get information about a particular instruction.  */

/* The opcode map is represented by an array of these structures.  The
   array is indexed by the high order four bits in the instruction.  */

struct sh_major_opcode
{
  /* A pointer to the instruction list.  This is an array which
     contains all the instructions with this major opcode.  */
  const struct sh_minor_opcode *minor_opcodes;
  /* The number of elements in minor_opcodes.  */
  unsigned short count;
};

/* This structure holds information for a set of SH opcodes.  The
   instruction code is anded with the mask value, and the resulting
   value is used to search the order opcode list.  */

struct sh_minor_opcode
{
  /* The sorted opcode list.  */
  const struct sh_opcode *opcodes;
  /* The number of elements in opcodes.  */
  unsigned short count;
  /* The mask value to use when searching the opcode list.  */
  unsigned short mask;
};

/* This structure holds information for an SH instruction.  An array
   of these structures is sorted in order by opcode.  */

struct sh_opcode
{
  /* The code for this instruction, after it has been anded with the
     mask value in the sh_major_opcode structure.  */
  unsigned short opcode;
  /* Flags for this instruction.  */
  unsigned short flags;
};

/* Flag which appear in the sh_opcode structure.  */

/* This instruction loads a value from memory.  */
#define LOAD (0x1)

/* This instruction stores a value to memory.  */
#define STORE (0x2)

/* This instruction is a branch.  */
#define BRANCH (0x4)

/* This instruction has a delay slot.  */
#define DELAY (0x8)

/* This instruction uses the value in the register in the field at
   mask 0x0f00 of the instruction.  */
#define USES1 (0x10)

/* This instruction uses the value in the register in the field at
   mask 0x00f0 of the instruction.  */
#define USES2 (0x20)

/* This instruction uses the value in register 0.  */
#define USESR0 (0x40)

/* This instruction sets the value in the register in the field at
   mask 0x0f00 of the instruction.  */
#define SETS1 (0x80)

/* This instruction sets the value in the register in the field at
   mask 0x00f0 of the instruction.  */
#define SETS2 (0x100)

/* This instruction sets register 0.  */
#define SETSR0 (0x200)

/* This instruction sets a special register.  */
#define SETSSP (0x400)

/* This instruction uses a special register.  */
#define USESSP (0x800)

/* This instruction uses the floating point register in the field at
   mask 0x0f00 of the instruction.  */
#define USESF1 (0x1000)

/* This instruction uses the floating point register in the field at
   mask 0x00f0 of the instruction.  */
#define USESF2 (0x2000)

/* This instruction uses floating point register 0.  */
#define USESF0 (0x4000)

/* This instruction sets the floating point register in the field at
   mask 0x0f00 of the instruction.  */
#define SETSF1 (0x8000)

static boolean sh_insn_uses_reg
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int));
static boolean sh_insn_uses_freg
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int));
static boolean sh_insns_conflict
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int,
	   const struct sh_opcode *));
static boolean sh_load_use
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int,
	   const struct sh_opcode *));

/* The opcode maps.  */

#define MAP(a) a, sizeof a / sizeof a[0]

static const struct sh_opcode sh_opcode00[] =
{
  { 0x0008, SETSSP },			/* clrt */
  { 0x0009, 0 },			/* nop */
  { 0x000b, BRANCH | DELAY | USESSP },	/* rts */
  { 0x0018, SETSSP },			/* sett */
  { 0x0019, SETSSP },			/* div0u */
  { 0x001b, 0 },			/* sleep */
  { 0x0028, SETSSP },			/* clrmac */
  { 0x002b, BRANCH | DELAY | SETSSP },	/* rte */
  { 0x0038, USESSP | SETSSP },		/* ldtlb */
  { 0x0048, SETSSP },			/* clrs */
  { 0x0058, SETSSP }			/* sets */
};

static const struct sh_opcode sh_opcode01[] =
{
  { 0x0002, SETS1 | USESSP },			/* stc sr,rn */
  { 0x0003, BRANCH | DELAY | USES1 | SETSSP },	/* bsrf rn */
  { 0x000a, SETS1 | USESSP },			/* sts mach,rn */
  { 0x0012, SETS1 | USESSP },			/* stc gbr,rn */
  { 0x001a, SETS1 | USESSP },			/* sts macl,rn */
  { 0x0022, SETS1 | USESSP },			/* stc vbr,rn */
  { 0x0023, BRANCH | DELAY | USES1 },		/* braf rn */
  { 0x0029, SETS1 | USESSP },			/* movt rn */
  { 0x002a, SETS1 | USESSP },			/* sts pr,rn */
  { 0x0032, SETS1 | USESSP },			/* stc ssr,rn */
  { 0x0042, SETS1 | USESSP },			/* stc spc,rn */
  { 0x005a, SETS1 | USESSP },			/* sts fpul,rn */
  { 0x006a, SETS1 | USESSP },			/* sts fpscr,rn */
  { 0x0082, SETS1 | USESSP },			/* stc r0_bank,rn */
  { 0x0083, LOAD | USES1 },			/* pref @@rn */
  { 0x0092, SETS1 | USESSP },			/* stc r1_bank,rn */
  { 0x00a2, SETS1 | USESSP },			/* stc r2_bank,rn */
  { 0x00b2, SETS1 | USESSP },			/* stc r3_bank,rn */
  { 0x00c2, SETS1 | USESSP },			/* stc r4_bank,rn */
  { 0x00d2, SETS1 | USESSP },			/* stc r5_bank,rn */
  { 0x00e2, SETS1 | USESSP },			/* stc r6_bank,rn */
  { 0x00f2, SETS1 | USESSP }			/* stc r7_bank,rn */
};

static const struct sh_opcode sh_opcode02[] =
{
  { 0x0004, STORE | USES1 | USES2 | USESR0 },	/* mov.b rm,@@(r0,rn) */
  { 0x0005, STORE | USES1 | USES2 | USESR0 },	/* mov.w rm,@@(r0,rn) */
  { 0x0006, STORE | USES1 | USES2 | USESR0 },	/* mov.l rm,@@(r0,rn) */
  { 0x0007, SETSSP | USES1 | USES2 },		/* mul.l rm,rn */
  { 0x000c, LOAD | SETS1 | USES2 | USESR0 },	/* mov.b @@(r0,rm),rn */
  { 0x000d, LOAD | SETS1 | USES2 | USESR0 },	/* mov.w @@(r0,rm),rn */
  { 0x000e, LOAD | SETS1 | USES2 | USESR0 },	/* mov.l @@(r0,rm),rn */
  { 0x000f, LOAD|SETS1|SETS2|SETSSP|USES1|USES2|USESSP }, /* mac.l @@rm+,@@rn+ */
};

static const struct sh_minor_opcode sh_opcode0[] =
{
  { MAP (sh_opcode00), 0xffff },
  { MAP (sh_opcode01), 0xf0ff },
  { MAP (sh_opcode02), 0xf00f }
};

static const struct sh_opcode sh_opcode10[] =
{
  { 0x1000, STORE | USES1 | USES2 }	/* mov.l rm,@@(disp,rn) */
};

static const struct sh_minor_opcode sh_opcode1[] =
{
  { MAP (sh_opcode10), 0xf000 }
};

static const struct sh_opcode sh_opcode20[] =
{
  { 0x2000, STORE | USES1 | USES2 },		/* mov.b rm,@@rn */
  { 0x2001, STORE | USES1 | USES2 },		/* mov.w rm,@@rn */
  { 0x2002, STORE | USES1 | USES2 },		/* mov.l rm,@@rn */
  { 0x2004, STORE | SETS1 | USES1 | USES2 },	/* mov.b rm,@@-rn */
  { 0x2005, STORE | SETS1 | USES1 | USES2 },	/* mov.w rm,@@-rn */
  { 0x2006, STORE | SETS1 | USES1 | USES2 },	/* mov.l rm,@@-rn */
  { 0x2007, SETSSP | USES1 | USES2 | USESSP },	/* div0s */
  { 0x2008, SETSSP | USES1 | USES2 },		/* tst rm,rn */
  { 0x2009, SETS1 | USES1 | USES2 },		/* and rm,rn */
  { 0x200a, SETS1 | USES1 | USES2 },		/* xor rm,rn */
  { 0x200b, SETS1 | USES1 | USES2 },		/* or rm,rn */
  { 0x200c, SETSSP | USES1 | USES2 },		/* cmp/str rm,rn */
  { 0x200d, SETS1 | USES1 | USES2 },		/* xtrct rm,rn */
  { 0x200e, SETSSP | USES1 | USES2 },		/* mulu.w rm,rn */
  { 0x200f, SETSSP | USES1 | USES2 }		/* muls.w rm,rn */
};

static const struct sh_minor_opcode sh_opcode2[] =
{
  { MAP (sh_opcode20), 0xf00f }
};

static const struct sh_opcode sh_opcode30[] =
{
  { 0x3000, SETSSP | USES1 | USES2 },		/* cmp/eq rm,rn */
  { 0x3002, SETSSP | USES1 | USES2 },		/* cmp/hs rm,rn */
  { 0x3003, SETSSP | USES1 | USES2 },		/* cmp/ge rm,rn */
  { 0x3004, SETSSP | USESSP | USES1 | USES2 },	/* div1 rm,rn */
  { 0x3005, SETSSP | USES1 | USES2 },		/* dmulu.l rm,rn */
  { 0x3006, SETSSP | USES1 | USES2 },		/* cmp/hi rm,rn */
  { 0x3007, SETSSP | USES1 | USES2 },		/* cmp/gt rm,rn */
  { 0x3008, SETS1 | USES1 | USES2 },		/* sub rm,rn */
  { 0x300a, SETS1 | SETSSP | USES1 | USES2 | USESSP }, /* subc rm,rn */
  { 0x300b, SETS1 | SETSSP | USES1 | USES2 },	/* subv rm,rn */
  { 0x300c, SETS1 | USES1 | USES2 },		/* add rm,rn */
  { 0x300d, SETSSP | USES1 | USES2 },		/* dmuls.l rm,rn */
  { 0x300e, SETS1 | SETSSP | USES1 | USES2 | USESSP }, /* addc rm,rn */
  { 0x300f, SETS1 | SETSSP | USES1 | USES2 }	/* addv rm,rn */
};

static const struct sh_minor_opcode sh_opcode3[] =
{
  { MAP (sh_opcode30), 0xf00f }
};

static const struct sh_opcode sh_opcode40[] =
{
  { 0x4000, SETS1 | SETSSP | USES1 },		/* shll rn */
  { 0x4001, SETS1 | SETSSP | USES1 },		/* shlr rn */
  { 0x4002, STORE | SETS1 | USES1 | USESSP },	/* sts.l mach,@@-rn */
  { 0x4003, STORE | SETS1 | USES1 | USESSP },	/* stc.l sr,@@-rn */
  { 0x4004, SETS1 | SETSSP | USES1 },		/* rotl rn */
  { 0x4005, SETS1 | SETSSP | USES1 },		/* rotr rn */
  { 0x4006, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,mach */
  { 0x4007, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,sr */
  { 0x4008, SETS1 | USES1 },			/* shll2 rn */
  { 0x4009, SETS1 | USES1 },			/* shlr2 rn */
  { 0x400a, SETSSP | USES1 },			/* lds rm,mach */
  { 0x400b, BRANCH | DELAY | USES1 },		/* jsr @@rn */
  { 0x400e, SETSSP | USES1 },			/* ldc rm,sr */
  { 0x4010, SETS1 | SETSSP | USES1 },		/* dt rn */
  { 0x4011, SETSSP | USES1 },			/* cmp/pz rn */
  { 0x4012, STORE | SETS1 | USES1 | USESSP },	/* sts.l macl,@@-rn */
  { 0x4013, STORE | SETS1 | USES1 | USESSP },	/* stc.l gbr,@@-rn */
  { 0x4015, SETSSP | USES1 },			/* cmp/pl rn */
  { 0x4016, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,macl */
  { 0x4017, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,gbr */
  { 0x4018, SETS1 | USES1 },			/* shll8 rn */
  { 0x4019, SETS1 | USES1 },			/* shlr8 rn */
  { 0x401a, SETSSP | USES1 },			/* lds rm,macl */
  { 0x401b, LOAD | SETSSP | USES1 },		/* tas.b @@rn */
  { 0x401e, SETSSP | USES1 },			/* ldc rm,gbr */
  { 0x4020, SETS1 | SETSSP | USES1 },		/* shal rn */
  { 0x4021, SETS1 | SETSSP | USES1 },		/* shar rn */
  { 0x4022, STORE | SETS1 | USES1 | USESSP },	/* sts.l pr,@@-rn */
  { 0x4023, STORE | SETS1 | USES1 | USESSP },	/* stc.l vbr,@@-rn */
  { 0x4024, SETS1 | SETSSP | USES1 | USESSP },	/* rotcl rn */
  { 0x4025, SETS1 | SETSSP | USES1 | USESSP },	/* rotcr rn */
  { 0x4026, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,pr */
  { 0x4027, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,vbr */
  { 0x4028, SETS1 | USES1 },			/* shll16 rn */
  { 0x4029, SETS1 | USES1 },			/* shlr16 rn */
  { 0x402a, SETSSP | USES1 },			/* lds rm,pr */
  { 0x402b, BRANCH | DELAY | USES1 },		/* jmp @@rn */
  { 0x402e, SETSSP | USES1 },			/* ldc rm,vbr */
  { 0x4033, STORE | SETS1 | USES1 | USESSP },	/* stc.l ssr,@@-rn */
  { 0x4037, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,ssr */
  { 0x403e, SETSSP | USES1 },			/* ldc rm,ssr */
  { 0x4043, STORE | SETS1 | USES1 | USESSP },	/* stc.l spc,@@-rn */
  { 0x4047, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,spc */
  { 0x404e, SETSSP | USES1 },			/* ldc rm,spc */
  { 0x4052, STORE | SETS1 | USES1 | USESSP },	/* sts.l fpul,@@-rn */
  { 0x4056, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,fpul */
  { 0x405a, SETSSP | USES1 },			/* lds.l rm,fpul */
  { 0x4062, STORE | SETS1 | USES1 | USESSP },	/* sts.l fpscr,@@-rn */
  { 0x4066, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,fpscr */
  { 0x406a, SETSSP | USES1 }			/* lds rm,fpscr */
};

static const struct sh_opcode sh_opcode41[] =
{
  { 0x4083, STORE | SETS1 | USES1 | USESSP },	/* stc.l rx_bank,@@-rn */
  { 0x4087, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,rx_bank */
  { 0x408e, SETSSP | USES1 }			/* ldc rm,rx_bank */
};

static const struct sh_opcode sh_opcode42[] =
{
  { 0x400c, SETS1 | USES1 | USES2 },			/* shad rm,rn */
  { 0x400d, SETS1 | USES1 | USES2 },			/* shld rm,rn */
  { 0x400f, LOAD|SETS1|SETS2|SETSSP|USES1|USES2|USESSP }, /* mac.w @@rm+,@@rn+ */
};

static const struct sh_minor_opcode sh_opcode4[] =
{
  { MAP (sh_opcode40), 0xf0ff },
  { MAP (sh_opcode41), 0xf08f },
  { MAP (sh_opcode42), 0xf00f }
};

static const struct sh_opcode sh_opcode50[] =
{
  { 0x5000, LOAD | SETS1 | USES2 }	/* mov.l @@(disp,rm),rn */
};

static const struct sh_minor_opcode sh_opcode5[] =
{
  { MAP (sh_opcode50), 0xf000 }
};

static const struct sh_opcode sh_opcode60[] =
{
  { 0x6000, LOAD | SETS1 | USES2 },		/* mov.b @@rm,rn */
  { 0x6001, LOAD | SETS1 | USES2 },		/* mov.w @@rm,rn */
  { 0x6002, LOAD | SETS1 | USES2 },		/* mov.l @@rm,rn */
  { 0x6003, SETS1 | USES2 },			/* mov rm,rn */
  { 0x6004, LOAD | SETS1 | SETS2 | USES2 },	/* mov.b @@rm+,rn */
  { 0x6005, LOAD | SETS1 | SETS2 | USES2 },	/* mov.w @@rm+,rn */
  { 0x6006, LOAD | SETS1 | SETS2 | USES2 },	/* mov.l @@rm+,rn */
  { 0x6007, SETS1 | USES2 },			/* not rm,rn */
  { 0x6008, SETS1 | USES2 },			/* swap.b rm,rn */
  { 0x6009, SETS1 | USES2 },			/* swap.w rm,rn */
  { 0x600a, SETS1 | SETSSP | USES2 | USESSP },	/* negc rm,rn */
  { 0x600b, SETS1 | USES2 },			/* neg rm,rn */
  { 0x600c, SETS1 | USES2 },			/* extu.b rm,rn */
  { 0x600d, SETS1 | USES2 },			/* extu.w rm,rn */
  { 0x600e, SETS1 | USES2 },			/* exts.b rm,rn */
  { 0x600f, SETS1 | USES2 }			/* exts.w rm,rn */
};

static const struct sh_minor_opcode sh_opcode6[] =
{
  { MAP (sh_opcode60), 0xf00f }
};

static const struct sh_opcode sh_opcode70[] =
{
  { 0x7000, SETS1 | USES1 }		/* add #imm,rn */
};

static const struct sh_minor_opcode sh_opcode7[] =
{
  { MAP (sh_opcode70), 0xf000 }
};

static const struct sh_opcode sh_opcode80[] =
{
  { 0x8000, STORE | USES2 | USESR0 },	/* mov.b r0,@@(disp,rn) */
  { 0x8100, STORE | USES2 | USESR0 },	/* mov.w r0,@@(disp,rn) */
  { 0x8400, LOAD | SETSR0 | USES2 },	/* mov.b @@(disp,rm),r0 */
  { 0x8500, LOAD | SETSR0 | USES2 },	/* mov.w @@(disp,rn),r0 */
  { 0x8800, SETSSP | USESR0 },		/* cmp/eq #imm,r0 */
  { 0x8900, BRANCH | USESSP },		/* bt label */
  { 0x8b00, BRANCH | USESSP },		/* bf label */
  { 0x8d00, BRANCH | DELAY | USESSP },	/* bt/s label */
  { 0x8f00, BRANCH | DELAY | USESSP }	/* bf/s label */
};

static const struct sh_minor_opcode sh_opcode8[] =
{
  { MAP (sh_opcode80), 0xff00 }
};

static const struct sh_opcode sh_opcode90[] =
{
  { 0x9000, LOAD | SETS1 }	/* mov.w @@(disp,pc),rn */
};

static const struct sh_minor_opcode sh_opcode9[] =
{
  { MAP (sh_opcode90), 0xf000 }
};

static const struct sh_opcode sh_opcodea0[] =
{
  { 0xa000, BRANCH | DELAY }	/* bra label */
};

static const struct sh_minor_opcode sh_opcodea[] =
{
  { MAP (sh_opcodea0), 0xf000 }
};

static const struct sh_opcode sh_opcodeb0[] =
{
  { 0xb000, BRANCH | DELAY }	/* bsr label */
};

static const struct sh_minor_opcode sh_opcodeb[] =
{
  { MAP (sh_opcodeb0), 0xf000 }
};

static const struct sh_opcode sh_opcodec0[] =
{
  { 0xc000, STORE | USESR0 | USESSP },		/* mov.b r0,@@(disp,gbr) */
  { 0xc100, STORE | USESR0 | USESSP },		/* mov.w r0,@@(disp,gbr) */
  { 0xc200, STORE | USESR0 | USESSP },		/* mov.l r0,@@(disp,gbr) */
  { 0xc300, BRANCH | USESSP },			/* trapa #imm */
  { 0xc400, LOAD | SETSR0 | USESSP },		/* mov.b @@(disp,gbr),r0 */
  { 0xc500, LOAD | SETSR0 | USESSP },		/* mov.w @@(disp,gbr),r0 */
  { 0xc600, LOAD | SETSR0 | USESSP },		/* mov.l @@(disp,gbr),r0 */
  { 0xc700, SETSR0 },				/* mova @@(disp,pc),r0 */
  { 0xc800, SETSSP | USESR0 },			/* tst #imm,r0 */
  { 0xc900, SETSR0 | USESR0 },			/* and #imm,r0 */
  { 0xca00, SETSR0 | USESR0 },			/* xor #imm,r0 */
  { 0xcb00, SETSR0 | USESR0 },			/* or #imm,r0 */
  { 0xcc00, LOAD | SETSSP | USESR0 | USESSP },	/* tst.b #imm,@@(r0,gbr) */
  { 0xcd00, LOAD | STORE | USESR0 | USESSP },	/* and.b #imm,@@(r0,gbr) */
  { 0xce00, LOAD | STORE | USESR0 | USESSP },	/* xor.b #imm,@@(r0,gbr) */
  { 0xcf00, LOAD | STORE | USESR0 | USESSP }	/* or.b #imm,@@(r0,gbr) */
};

static const struct sh_minor_opcode sh_opcodec[] =
{
  { MAP (sh_opcodec0), 0xff00 }
};

static const struct sh_opcode sh_opcoded0[] =
{
  { 0xd000, LOAD | SETS1 }		/* mov.l @@(disp,pc),rn */
};

static const struct sh_minor_opcode sh_opcoded[] =
{
  { MAP (sh_opcoded0), 0xf000 }
};

static const struct sh_opcode sh_opcodee0[] =
{
  { 0xe000, SETS1 }		/* mov #imm,rn */
};

static const struct sh_minor_opcode sh_opcodee[] =
{
  { MAP (sh_opcodee0), 0xf000 }
};

static const struct sh_opcode sh_opcodef0[] =
{
  { 0xf000, SETSF1 | USESF1 | USESF2 },		/* fadd fm,fn */
  { 0xf001, SETSF1 | USESF1 | USESF2 },		/* fsub fm,fn */
  { 0xf002, SETSF1 | USESF1 | USESF2 },		/* fmul fm,fn */
  { 0xf003, SETSF1 | USESF1 | USESF2 },		/* fdiv fm,fn */
  { 0xf004, SETSSP | USESF1 | USESF2 },		/* fcmp/eq fm,fn */
  { 0xf005, SETSSP | USESF1 | USESF2 },		/* fcmp/gt fm,fn */
  { 0xf006, LOAD | SETSF1 | USES2 | USESR0 },	/* fmov.s @@(r0,rm),fn */
  { 0xf007, STORE | USES1 | USESF2 | USESR0 },	/* fmov.s fm,@@(r0,rn) */
  { 0xf008, LOAD | SETSF1 | USES2 },		/* fmov.s @@rm,fn */
  { 0xf009, LOAD | SETS2 | SETSF1 | USES2 },	/* fmov.s @@rm+,fn */
  { 0xf00a, STORE | USES1 | USESF2 },		/* fmov.s fm,@@rn */
  { 0xf00b, STORE | SETS1 | USES1 | USESF2 },	/* fmov.s fm,@@-rn */
  { 0xf00c, SETSF1 | USESF2 },			/* fmov fm,fn */
  { 0xf00e, SETSF1 | USESF1 | USESF2 | USESF0 }	/* fmac f0,fm,fn */
};

static const struct sh_opcode sh_opcodef1[] =
{
  { 0xf00d, SETSF1 | USESSP },	/* fsts fpul,fn */
  { 0xf01d, SETSSP | USESF1 },	/* flds fn,fpul */
  { 0xf02d, SETSF1 | USESSP },	/* float fpul,fn */
  { 0xf03d, SETSSP | USESF1 },	/* ftrc fn,fpul */
  { 0xf04d, SETSF1 | USESF1 },	/* fneg fn */
  { 0xf05d, SETSF1 | USESF1 },	/* fabs fn */
  { 0xf06d, SETSF1 | USESF1 },	/* fsqrt fn */
  { 0xf07d, SETSSP | USESF1 },	/* ftst/nan fn */
  { 0xf08d, SETSF1 },		/* fldi0 fn */
  { 0xf09d, SETSF1 }		/* fldi1 fn */
};

static const struct sh_minor_opcode sh_opcodef[] =
{
  { MAP (sh_opcodef0), 0xf00f },
  { MAP (sh_opcodef1), 0xf0ff }
};

static const struct sh_major_opcode sh_opcodes[] =
{
  { MAP (sh_opcode0) },
  { MAP (sh_opcode1) },
  { MAP (sh_opcode2) },
  { MAP (sh_opcode3) },
  { MAP (sh_opcode4) },
  { MAP (sh_opcode5) },
  { MAP (sh_opcode6) },
  { MAP (sh_opcode7) },
  { MAP (sh_opcode8) },
  { MAP (sh_opcode9) },
  { MAP (sh_opcodea) },
  { MAP (sh_opcodeb) },
  { MAP (sh_opcodec) },
  { MAP (sh_opcoded) },
  { MAP (sh_opcodee) },
  { MAP (sh_opcodef) }
};

/* Given an instruction, return a pointer to the corresponding
   sh_opcode structure.  Return NULL if the instruction is not
   recognized.  */

static const struct sh_opcode *
sh_insn_info (insn)
     unsigned int insn;
{
  const struct sh_major_opcode *maj;
  const struct sh_minor_opcode *min, *minend;

  maj = &sh_opcodes[(insn & 0xf000) >> 12];
  min = maj->minor_opcodes;
  minend = min + maj->count;
  for (; min < minend; min++)
    {
      unsigned int l;
      const struct sh_opcode *op, *opend;

      l = insn & min->mask;
      op = min->opcodes;
      opend = op + min->count;

      /* Since the opcodes tables are sorted, we could use a binary
         search here if the count were above some cutoff value.  */
      for (; op < opend; op++)
	if (op->opcode == l)
	  return op;
    }

  return NULL;  
}

/* See whether an instruction uses a general purpose register.  */

static boolean
sh_insn_uses_reg (insn, op, reg)
     unsigned int insn;
     const struct sh_opcode *op;
     unsigned int reg;
{
  unsigned int f;

  f = op->flags;

  if ((f & USES1) != 0
      && ((insn & 0x0f00) >> 8) == reg)
    return true;
  if ((f & USES2) != 0
      && ((insn & 0x00f0) >> 4) == reg)
    return true;
  if ((f & USESR0) != 0
      && reg == 0)
    return true;

  return false;
}

/* See whether an instruction uses a floating point register.  */

static boolean
sh_insn_uses_freg (insn, op, freg)
     unsigned int insn;
     const struct sh_opcode *op;
     unsigned int freg;
{
  unsigned int f;

  f = op->flags;

  if ((f & USESF1) != 0
      && ((insn & 0x0f00) >> 8) == freg)
    return true;
  if ((f & USESF2) != 0
      && ((insn & 0x00f0) >> 4) == freg)
    return true;
  if ((f & USESF0) != 0
      && freg == 0)
    return true;

  return false;
}

/* See whether instructions I1 and I2 conflict, assuming I1 comes
   before I2.  OP1 and OP2 are the corresponding sh_opcode structures.
   This should return true if the instructions can be swapped safely.  */

static boolean
sh_insns_conflict (i1, op1, i2, op2)
     unsigned int i1;
     const struct sh_opcode *op1;
     unsigned int i2;
     const struct sh_opcode *op2;
{
  unsigned int f1, f2;

  f1 = op1->flags;
  f2 = op2->flags;

  if ((f1 & (BRANCH | DELAY)) != 0
      || (f2 & (BRANCH | DELAY)) != 0)
    return true;

  if ((f1 & SETSSP) != 0 && (f2 & USESSP) != 0)
    return false;
  if ((f2 & SETSSP) != 0 && (f1 & USESSP) != 0)
    return true;

  if ((f1 & SETS1) != 0
      && sh_insn_uses_reg (i2, op2, (i1 & 0x0f00) >> 8))
    return true;
  if ((f1 & SETS2) != 0
      && sh_insn_uses_reg (i2, op2, (i1 & 0x00f0) >> 4))
    return true;
  if ((f1 & SETSR0) != 0
      && sh_insn_uses_reg (i2, op2, 0))
    return true;
  if ((f1 & SETSF1) != 0
      && sh_insn_uses_freg (i2, op2, (i1 & 0x0f00) >> 8))
    return true;

  if ((f2 & SETS1) != 0
      && sh_insn_uses_reg (i1, op1, (i2 & 0x0f00) >> 8))
    return true;
  if ((f2 & SETS2) != 0
      && sh_insn_uses_reg (i1, op1, (i2 & 0x00f0) >> 4))
    return true;
  if ((f2 & SETSR0) != 0
      && sh_insn_uses_reg (i1, op1, 0))
    return true;
  if ((f2 & SETSF1) != 0
      && sh_insn_uses_freg (i1, op1, (i2 & 0x0f00) >> 8))
    return true;

  /* The instructions do not conflict.  */
  return false;
}

/* I1 is a load instruction, and I2 is some other instruction.  Return
   true if I1 loads a register which I2 uses.  */

static boolean
sh_load_use (i1, op1, i2, op2)
     unsigned int i1;
     const struct sh_opcode *op1;
     unsigned int i2;
     const struct sh_opcode *op2;
{
  unsigned int f1;

  f1 = op1->flags;

  if ((f1 & LOAD) == 0)
    return false;

  /* If both SETS1 and SETSSP are set, that means a load to a special
     register using postincrement addressing mode, which we don't care
     about here.  */
  if ((f1 & SETS1) != 0
      && (f1 & SETSSP) == 0
      && sh_insn_uses_reg (i2, op2, (i1 & 0x0f00) >> 8))
    return true;

  if ((f1 & SETSR0) != 0
      && sh_insn_uses_reg (i2, op2, 0))
    return true;

  if ((f1 & SETSF1) != 0
      && sh_insn_uses_freg (i2, op2, (i1 & 0x0f00) >> 8))
    return true;

  return false;
}

/* Look for loads and stores which we can align to four byte
   boundaries.  See the longer comment above sh_relax_section for why
   this is desirable.  This sets *PSWAPPED if some instruction was
   swapped.  */

static boolean
sh_align_loads (abfd, sec, internal_relocs, contents, pswapped)
     bfd *abfd;
     asection *sec;
     struct internal_reloc *internal_relocs;
     bfd_byte *contents;
     boolean *pswapped;
{
  struct internal_reloc *irel, *irelend;
  bfd_vma *labels = NULL;
  bfd_vma *label, *label_end;

  *pswapped = false;

  irelend = internal_relocs + sec->reloc_count;

  /* Get all the addresses with labels on them.  */
  labels = (bfd_vma *) bfd_malloc (sec->reloc_count * sizeof (bfd_vma));
  if (labels == NULL)
    goto error_return;
  label_end = labels;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      if (irel->r_type == R_SH_LABEL)
	{
	  *label_end = irel->r_vaddr - sec->vma;
	  ++label_end;
a1184 183
  /* Note that the assembler currently always outputs relocs in
     address order.  If that ever changes, this code will need to sort
     the label values and the relocs.  */

  label = labels;

  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma start, stop, i;

      if (irel->r_type != R_SH_CODE)
	continue;

      start = irel->r_vaddr - sec->vma;

      for (irel++; irel < irelend; irel++)
	if (irel->r_type == R_SH_DATA)
	  break;
      if (irel < irelend)
	stop = irel->r_vaddr - sec->vma;
      else
	stop = sec->_cooked_size;

      /* Instructions should be aligned on 2 byte boundaries.  */
      if ((start & 1) == 1)
	++start;

      /* Now look through the unaligned addresses.  */
      i = start;
      if ((i & 2) == 0)
	i += 2;
      for (; i < stop; i += 4)
	{
	  unsigned int insn;
	  const struct sh_opcode *op;
	  unsigned int prev_insn = 0;
	  const struct sh_opcode *prev_op = NULL;

	  insn = bfd_get_16 (abfd, contents + i);
	  op = sh_insn_info (insn);
	  if (op == NULL
	      || (op->flags & (LOAD | STORE)) == 0)
	    continue;

	  /* This is a load or store which is not on a four byte
             boundary.  */

	  while (label < label_end && *label < i)
	    ++label;

	  if (i > start)
	    {
	      prev_insn = bfd_get_16 (abfd, contents + i - 2);
	      prev_op = sh_insn_info (prev_insn);

	      /* If the load/store instruction is in a delay slot, we
		 can't swap.  */
	      if (prev_op == NULL
		  || (prev_op->flags & DELAY) != 0)
		continue;
	    }
	  if (i > start
	      && (label >= label_end || *label != i)
	      && prev_op != NULL
	      && (prev_op->flags & (LOAD | STORE)) == 0
	      && ! sh_insns_conflict (prev_insn, prev_op, insn, op))
	    {
	      boolean ok;

	      /* The load/store instruction does not have a label, and
		 there is a previous instruction; PREV_INSN is not
		 itself a load/store instruction, and PREV_INSN and
		 INSN do not conflict.  */

	      ok = true;

	      if (i >= start + 4)
		{
		  unsigned int prev2_insn;
		  const struct sh_opcode *prev2_op;

		  prev2_insn = bfd_get_16 (abfd, contents + i - 4);
		  prev2_op = sh_insn_info (prev2_insn);

		  /* If the instruction before PREV_INSN has a delay
		     slot--that is, PREV_INSN is in a delay slot--we
		     can not swap.  */
		  if (prev2_op == NULL
		      || (prev2_op->flags & DELAY) != 0)
		    ok = false;

		  /* If the instruction before PREV_INSN is a load,
                     and it sets a register which INSN uses, then
                     putting INSN immediately after PREV_INSN will
                     cause a pipeline bubble, so there is no point to
                     making the swap.  */
		  if (ok
		      && (prev2_op->flags & LOAD) != 0
		      && sh_load_use (prev2_insn, prev2_op, insn, op))
		    ok = false;
		}

	      if (ok)
		{
		  if (! sh_swap_insns (abfd, sec, internal_relocs,
				       contents, i - 2))
		    goto error_return;
		  *pswapped = true;
		  continue;
		}
	    }

	  while (label < label_end && *label < i + 2)
	    ++label;

	  if (i + 2 < stop
	      && (label >= label_end || *label != i + 2))
	    {
	      unsigned int next_insn;
	      const struct sh_opcode *next_op;

	      /* There is an instruction after the load/store
                 instruction, and it does not have a label.  */
	      next_insn = bfd_get_16 (abfd, contents + i + 2);
	      next_op = sh_insn_info (next_insn);
	      if (next_op != NULL
		  && (next_op->flags & (LOAD | STORE)) == 0
		  && ! sh_insns_conflict (insn, op, next_insn, next_op))
		{
		  boolean ok;

		  /* NEXT_INSN is not itself a load/store instruction,
                     and it does not conflict with INSN.  */

		  ok = true;

		  /* If PREV_INSN is a load, and it sets a register
		     which NEXT_INSN uses, then putting NEXT_INSN
		     immediately after PREV_INSN will cause a pipeline
		     bubble, so there is no reason to make this swap.  */
		  if (prev_op != NULL
		      && (prev_op->flags & LOAD) != 0
		      && sh_load_use (prev_insn, prev_op, next_insn, next_op))
		    ok = false;

		  /* If INSN is a load, and it sets a register which
                     the insn after NEXT_INSN uses, then doing the
                     swap will cause a pipeline bubble, so there is no
                     reason to make the swap.  However, if the insn
                     after NEXT_INSN is itself a load or store
                     instruction, then it is misaligned, so
                     optimistically hope that it will be swapped
                     itself, and just live with the pipeline bubble if
                     it isn't.  */
		  if (ok
		      && i + 4 < stop
		      && (op->flags & LOAD) != 0)
		    {
		      unsigned int next2_insn;
		      const struct sh_opcode *next2_op;

		      next2_insn = bfd_get_16 (abfd, contents + i + 4);
		      next2_op = sh_insn_info (next2_insn);
		      if ((next2_op->flags & (LOAD | STORE)) == 0
			   && sh_load_use (insn, op, next2_insn, next2_op))
			ok = false;
		    }

		  if (ok)
		    {
		      if (! sh_swap_insns (abfd, sec, internal_relocs,
					   contents, i))
			goto error_return;
		      *pswapped = true;
		      continue;
		    }
		}
	    }
	}
    }

  free (labels);

a1185 5

 error_return:
  if (labels != NULL)
    free (labels);
  return false;
a1187 131
/* Swap two SH instructions.  */

static boolean
sh_swap_insns (abfd, sec, internal_relocs, contents, addr)
     bfd *abfd;
     asection *sec;
     struct internal_reloc *internal_relocs;
     bfd_byte *contents;
     bfd_vma addr;
{
  unsigned short i1, i2;
  struct internal_reloc *irel, *irelend;

  /* Swap the instructions themselves.  */
  i1 = bfd_get_16 (abfd, contents + addr);
  i2 = bfd_get_16 (abfd, contents + addr + 2);
  bfd_put_16 (abfd, i2, contents + addr);
  bfd_put_16 (abfd, i1, contents + addr + 2);

  /* Adjust all reloc addresses.  */
  irelend = internal_relocs + sec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      int type, add;

      /* There are a few special types of relocs that we don't want to
         adjust.  These relocs do not apply to the instruction itself,
         but are only associated with the address.  */
      type = irel->r_type;
      if (type == R_SH_ALIGN
	  || type == R_SH_CODE
	  || type == R_SH_DATA
	  || type == R_SH_LABEL)
	continue;

      /* If an R_SH_USES reloc points to one of the addresses being
         swapped, we must adjust it.  It would be incorrect to do this
         for a jump, though, since we want to execute both
         instructions after the jump.  (We have avoided swapping
         around a label, so the jump will not wind up executing an
         instruction it shouldn't).  */
      if (type == R_SH_USES)
	{
	  bfd_vma off;

	  off = irel->r_vaddr - sec->vma + 4 + irel->r_offset;
	  if (off == addr)
	    irel->r_offset += 2;
	  else if (off == addr + 2)
	    irel->r_offset -= 2;
	}

      if (irel->r_vaddr - sec->vma == addr)
	{
	  irel->r_vaddr += 2;
	  add = -2;
	}
      else if (irel->r_vaddr - sec->vma == addr + 2)
	{
	  irel->r_vaddr -= 2;
	  add = 2;
	}
      else
	add = 0;

      if (add != 0)
	{
	  bfd_byte *loc;
	  unsigned short insn, oinsn;
	  boolean overflow;

	  loc = contents + irel->r_vaddr - sec->vma;
	  overflow = false;
	  switch (type)
	    {
	    default:
	      break;

	    case R_SH_PCDISP8BY2:
	    case R_SH_PCRELIMM8BY2:
	      insn = bfd_get_16 (abfd, loc);
	      oinsn = insn;
	      insn += add / 2;
	      if ((oinsn & 0xff00) != (insn & 0xff00))
		overflow = true;
	      bfd_put_16 (abfd, insn, loc);
	      break;

	    case R_SH_PCDISP:
	      insn = bfd_get_16 (abfd, loc);
	      oinsn = insn;
	      insn += add / 2;
	      if ((oinsn & 0xf000) != (insn & 0xf000))
		overflow = true;
	      bfd_put_16 (abfd, insn, loc);
	      break;

	    case R_SH_PCRELIMM8BY4:
	      /* This reloc ignores the least significant 3 bits of
                 the program counter before adding in the offset.
                 This means that if ADDR is at an even address, the
                 swap will not affect the offset.  If ADDR is an at an
                 odd address, then the instruction will be crossing a
                 four byte boundary, and must be adjusted.  */
	      if ((addr & 3) != 0)
		{
		  insn = bfd_get_16 (abfd, loc);
		  oinsn = insn;
		  insn += add / 2;
		  if ((oinsn & 0xff00) != (insn & 0xff00))
		    overflow = true;
		  bfd_put_16 (abfd, insn, loc);
		}

	      break;
	    }

	  if (overflow)
	    {
	      ((*_bfd_error_handler)
	       ("%s: 0x%lx: fatal: reloc overflow while relaxing",
		bfd_get_filename (abfd), (unsigned long) irel->r_vaddr));
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }
	}
    }

  return true;
}

d1392 2
a1393 2
		       bfd_malloc (obj_raw_syment_count (input_bfd)
				   * sizeof (struct internal_syment)));
d1395 4
a1398 1
	goto error_return;
d1400 2
a1401 2
      sections = (asection **) bfd_malloc (obj_raw_syment_count (input_bfd)
					   * sizeof (asection *));
d1403 4
a1406 1
	goto error_return;
d1462 2
a1463 2
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */
d1504 2
a1505 2
  BFD_ENDIAN_LITTLE,		/* data byte order is little */
  BFD_ENDIAN_LITTLE,		/* header byte order is little endian too*/
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d44 1
a44 1
  PARAMS ((bfd *, asection *, PTR, bfd_byte *, bfd_vma));
d1886 1
a1886 2
   This should return true if there is a conflict, or false if the
   instructions can be swapped safely.  */
d1905 1
a1905 1
    return true;
a1974 183
/* Try to align loads and stores within a span of memory.  This is
   called by both the ELF and the COFF sh targets.  ABFD and SEC are
   the BFD and section we are examining.  CONTENTS is the contents of
   the section.  SWAP is the routine to call to swap two instructions.
   RELOCS is a pointer to the internal relocation information, to be
   passed to SWAP.  PLABEL is a pointer to the current label in a
   sorted list of labels; LABEL_END is the end of the list.  START and
   STOP are the range of memory to examine.  If a swap is made,
   *PSWAPPED is set to true.  */

boolean
_bfd_sh_align_load_span (abfd, sec, contents, swap, relocs,
			 plabel, label_end, start, stop, pswapped)
     bfd *abfd;
     asection *sec;
     bfd_byte *contents;
     boolean (*swap) PARAMS ((bfd *, asection *, PTR, bfd_byte *, bfd_vma));
     PTR relocs;
     bfd_vma **plabel;
     bfd_vma *label_end;
     bfd_vma start;
     bfd_vma stop;
     boolean *pswapped;
{
  bfd_vma i;

  /* Instructions should be aligned on 2 byte boundaries.  */
  if ((start & 1) == 1)
    ++start;

  /* Now look through the unaligned addresses.  */
  i = start;
  if ((i & 2) == 0)
    i += 2;
  for (; i < stop; i += 4)
    {
      unsigned int insn;
      const struct sh_opcode *op;
      unsigned int prev_insn = 0;
      const struct sh_opcode *prev_op = NULL;

      insn = bfd_get_16 (abfd, contents + i);
      op = sh_insn_info (insn);
      if (op == NULL
	  || (op->flags & (LOAD | STORE)) == 0)
	continue;

      /* This is a load or store which is not on a four byte boundary.  */

      while (*plabel < label_end && **plabel < i)
	++*plabel;

      if (i > start)
	{
	  prev_insn = bfd_get_16 (abfd, contents + i - 2);
	  prev_op = sh_insn_info (prev_insn);

	  /* If the load/store instruction is in a delay slot, we
	     can't swap.  */
	  if (prev_op == NULL
	      || (prev_op->flags & DELAY) != 0)
	    continue;
	}
      if (i > start
	  && (*plabel >= label_end || **plabel != i)
	  && prev_op != NULL
	  && (prev_op->flags & (LOAD | STORE)) == 0
	  && ! sh_insns_conflict (prev_insn, prev_op, insn, op))
	{
	  boolean ok;

	  /* The load/store instruction does not have a label, and
	     there is a previous instruction; PREV_INSN is not
	     itself a load/store instruction, and PREV_INSN and
	     INSN do not conflict.  */

	  ok = true;

	  if (i >= start + 4)
	    {
	      unsigned int prev2_insn;
	      const struct sh_opcode *prev2_op;

	      prev2_insn = bfd_get_16 (abfd, contents + i - 4);
	      prev2_op = sh_insn_info (prev2_insn);

	      /* If the instruction before PREV_INSN has a delay
		 slot--that is, PREV_INSN is in a delay slot--we
		 can not swap.  */
	      if (prev2_op == NULL
		  || (prev2_op->flags & DELAY) != 0)
		ok = false;

	      /* If the instruction before PREV_INSN is a load,
		 and it sets a register which INSN uses, then
		 putting INSN immediately after PREV_INSN will
		 cause a pipeline bubble, so there is no point to
		 making the swap.  */
	      if (ok
		  && (prev2_op->flags & LOAD) != 0
		  && sh_load_use (prev2_insn, prev2_op, insn, op))
		ok = false;
	    }

	  if (ok)
	    {
	      if (! (*swap) (abfd, sec, relocs, contents, i - 2))
		return false;
	      *pswapped = true;
	      continue;
	    }
	}

      while (*plabel < label_end && **plabel < i + 2)
	++*plabel;

      if (i + 2 < stop
	  && (*plabel >= label_end || **plabel != i + 2))
	{
	  unsigned int next_insn;
	  const struct sh_opcode *next_op;

	  /* There is an instruction after the load/store
	     instruction, and it does not have a label.  */
	  next_insn = bfd_get_16 (abfd, contents + i + 2);
	  next_op = sh_insn_info (next_insn);
	  if (next_op != NULL
	      && (next_op->flags & (LOAD | STORE)) == 0
	      && ! sh_insns_conflict (insn, op, next_insn, next_op))
	    {
	      boolean ok;

	      /* NEXT_INSN is not itself a load/store instruction,
		 and it does not conflict with INSN.  */

	      ok = true;

	      /* If PREV_INSN is a load, and it sets a register
		 which NEXT_INSN uses, then putting NEXT_INSN
		 immediately after PREV_INSN will cause a pipeline
		 bubble, so there is no reason to make this swap.  */
	      if (prev_op != NULL
		  && (prev_op->flags & LOAD) != 0
		  && sh_load_use (prev_insn, prev_op, next_insn, next_op))
		ok = false;

	      /* If INSN is a load, and it sets a register which
		 the insn after NEXT_INSN uses, then doing the
		 swap will cause a pipeline bubble, so there is no
		 reason to make the swap.  However, if the insn
		 after NEXT_INSN is itself a load or store
		 instruction, then it is misaligned, so
		 optimistically hope that it will be swapped
		 itself, and just live with the pipeline bubble if
		 it isn't.  */
	      if (ok
		  && i + 4 < stop
		  && (op->flags & LOAD) != 0)
		{
		  unsigned int next2_insn;
		  const struct sh_opcode *next2_op;

		  next2_insn = bfd_get_16 (abfd, contents + i + 4);
		  next2_op = sh_insn_info (next2_insn);
		  if ((next2_op->flags & (LOAD | STORE)) == 0
		      && sh_load_use (insn, op, next2_insn, next2_op))
		    ok = false;
		}

	      if (ok)
		{
		  if (! (*swap) (abfd, sec, relocs, contents, i))
		    return false;
		  *pswapped = true;
		  continue;
		}
	    }
	}
    }

  return true;
}

d2018 1
a2018 1
      bfd_vma start, stop;
d2033 156
a2188 4
      if (! _bfd_sh_align_load_span (abfd, sec, contents, sh_swap_insns,
				     (PTR) internal_relocs, &label,
				     label_end, start, stop, pswapped))
	goto error_return;
d2204 1
a2204 1
sh_swap_insns (abfd, sec, relocs, contents, addr)
d2207 1
a2207 1
     PTR relocs;
a2210 1
  struct internal_reloc *internal_relocs = (struct internal_reloc *) relocs;
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a2409 8
	  if (symndx < 0 || symndx >= obj_raw_syment_count (input_bfd))
	    {
	      (*_bfd_error_handler)
		("%s: illegal symbol index %ld in relocs",
		 bfd_get_filename (input_bfd), symndx);
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1993, 94, 95, 96, 1997 Free Software Foundation, Inc.
d25 1
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1993, 94, 95, 96, 97, 98, 1999, 2000 Free Software Foundation, Inc.
a28 14

#ifdef COFF_WITH_PE
#include "coff/pe.h"

#ifndef COFF_IMAGE_WITH_PE
static boolean sh_align_load_span 
  PARAMS ((bfd *, asection *, bfd_byte *,
	   boolean (*) (bfd *, asection *, PTR, bfd_byte *, bfd_vma),
	   PTR, bfd_vma **, bfd_vma *, bfd_vma, bfd_vma, boolean *));

#define _bfd_sh_align_load_span sh_align_load_span
#endif
#endif

a38 1
#ifndef COFF_IMAGE_WITH_PE
a39 1
#endif
a50 4
#ifdef COFF_WITH_PE
/* Can't build import tables with 2**4 alignment.  */
#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER	2
#else
d52 1
a52 7
#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER	4
#endif

#ifdef COFF_IMAGE_WITH_PE
/* Align PE executables.  */
#define COFF_PAGE_SIZE 0x1000
#endif
a56 11
#ifdef COFF_WITH_PE
/* Return true if this relocation should
   appear in the output .reloc section.  */
static boolean in_reloc_p (abfd, howto)
     bfd * abfd ATTRIBUTE_UNUSED;
     reloc_howto_type * howto;
{
  return ! howto->pc_relative && howto->type != R_SH_IMAGEBASE;
}     
#endif

d61 10
a70 27
  EMPTY_HOWTO (0),
  EMPTY_HOWTO (1),
#ifdef COFF_WITH_PE
  /* Windows CE */
  HOWTO (R_SH_IMM32CE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_imm32ce",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */
#else
  EMPTY_HOWTO (2),
#endif
  EMPTY_HOWTO (3), /* R_SH_PCREL8 */
  EMPTY_HOWTO (4), /* R_SH_PCREL16 */
  EMPTY_HOWTO (5), /* R_SH_HIGH8 */
  EMPTY_HOWTO (6), /* R_SH_IMM24 */
  EMPTY_HOWTO (7), /* R_SH_LOW16 */
  EMPTY_HOWTO (8),
  EMPTY_HOWTO (9), /* R_SH_PCDISP8BY4 */
d86 1
a86 1
  EMPTY_HOWTO (11), /* R_SH_PCDISP8 */
d102 1
a102 1
  EMPTY_HOWTO (13),
d118 7
a124 23
  EMPTY_HOWTO (15),
#ifdef COFF_WITH_PE
  HOWTO (R_SH_IMAGEBASE,        /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,       	/* special_function */                     
	 "rva32",	        /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
	 false),                /* pcrel_offset */
#else
  EMPTY_HOWTO (16), /* R_SH_IMM8 */
#endif
  EMPTY_HOWTO (17), /* R_SH_IMM8BY2 */
  EMPTY_HOWTO (18), /* R_SH_IMM8BY4 */
  EMPTY_HOWTO (19), /* R_SH_IMM4 */
  EMPTY_HOWTO (20), /* R_SH_IMM4BY2 */
  EMPTY_HOWTO (21), /* R_SH_IMM4BY4 */
a277 14
	 false),		/* pcrel_offset */

  HOWTO (R_SH_SWITCH8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_reloc,		/* special_function */
	 "r_switch8",		/* name */
	 true,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
a291 1
#ifndef COFF_WITH_PE
a303 1
#endif
a322 90
#ifdef COFF_WITH_PE
/* Convert an rtype to howto for the COFF backend linker.
   Copied from coff-i386.  */
#define coff_rtype_to_howto coff_sh_rtype_to_howto

static reloc_howto_type *
coff_sh_rtype_to_howto (abfd, sec, rel, h, sym, addendp)
     bfd * abfd ATTRIBUTE_UNUSED;
     asection * sec;
     struct internal_reloc * rel;
     struct coff_link_hash_entry * h;
     struct internal_syment * sym;
     bfd_vma * addendp;
{
  reloc_howto_type * howto;

  howto = sh_coff_howtos + rel->r_type;

  *addendp = 0;

  if (howto->pc_relative)
    *addendp += sec->vma;

  if (sym != NULL && sym->n_scnum == 0 && sym->n_value != 0)
    {
      /* This is a common symbol.  The section contents include the
	 size (sym->n_value) as an addend.  The relocate_section
	 function will be adding in the final value of the symbol.  We
	 need to subtract out the current size in order to get the
	 correct result.  */
      BFD_ASSERT (h != NULL);
    }

  if (howto->pc_relative)
    {
      *addendp -= 4;

      /* If the symbol is defined, then the generic code is going to
         add back the symbol value in order to cancel out an
         adjustment it made to the addend.  However, we set the addend
         to 0 at the start of this function.  We need to adjust here,
         to avoid the adjustment the generic code will make.  FIXME:
         This is getting a bit hackish.  */
      if (sym != NULL && sym->n_scnum != 0)
	*addendp -= sym->n_value;
    }

  if (rel->r_type == R_SH_IMAGEBASE)
    *addendp -= pe_data (sec->output_section->owner)->pe_opthdr.ImageBase;

  return howto;
}

/* This structure is used to map BFD reloc codes to SH PE relocs.  */
struct shcoff_reloc_map
{
  unsigned char bfd_reloc_val;
  unsigned char shcoff_reloc_val;
};

/* An array mapping BFD reloc codes to SH PE relocs.  */
static const struct shcoff_reloc_map sh_reloc_map[] =
{
  { BFD_RELOC_32, R_SH_IMM32CE },
  { BFD_RELOC_RVA, R_SH_IMAGEBASE },
  { BFD_RELOC_CTOR, R_SH_IMM32CE },
};

/* Given a BFD reloc code, return the howto structure for the
   corresponding SH PE reloc.  */
#define coff_bfd_reloc_type_lookup	sh_coff_reloc_type_lookup

static reloc_howto_type *
sh_coff_reloc_type_lookup (abfd, code)
     bfd * abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
{
  unsigned int i;

  for (i = 0; i < sizeof (sh_reloc_map) / sizeof (struct shcoff_reloc_map); i++)
    {
      if (sh_reloc_map[i].bfd_reloc_val == code)
	return &sh_coff_howtos[(int) sh_reloc_map[i].shcoff_reloc_val];
    }

  fprintf (stderr, "SH Error: unknown reloc type %d\n", code);
  return NULL;
}
#endif /* COFF_WITH_PE */

d350 1
a350 2
    if ((reloc).r_type == R_SH_SWITCH8				\
	|| (reloc).r_type == R_SH_SWITCH16			\
d369 1
a369 1
     char **error_message ATTRIBUTE_UNUSED;
a388 4
#ifdef COFF_WITH_PE
      && r_type != R_SH_IMM32CE
      && r_type != R_SH_IMAGEBASE
#endif
a401 3
#ifdef COFF_WITH_PE
    case R_SH_IMM32CE:
#endif
a405 8
#ifdef COFF_WITH_PE
    case R_SH_IMAGEBASE:
      insn = bfd_get_32 (abfd, hit_data);
      insn += (sym_value + reloc_entry->addend
	       - pe_data (input_section->output_section->owner)->pe_opthdr.ImageBase);
      bfd_put_32 (abfd, insn, hit_data);
      break;
#endif
a428 2
#define coff_bfd_merge_private_bfd_data _bfd_generic_verify_endian_match

d560 1
a560 3
      laddr = irel->r_vaddr - sec->vma + 4;
      /* Careful to sign extend the 32-bit offset.  */
      laddr += ((irel->r_offset & 0xffffffff) ^ 0x80000000) - 0x80000000;
d570 2
a571 1
      /* If the instruction is not mov.l NN,rN, we don't know what to do.  */
a602 6
#ifdef COFF_WITH_PE
	    && (irelfn->r_type == R_SH_IMM32
		|| irelfn->r_type == R_SH_IMM32CE
		|| irelfn->r_type == R_SH_IMAGEBASE))

#else
a603 1
#endif
d931 1
a931 2
      bfd_vma nraddr, stop;
      bfd_vma start = 0;
d935 1
a935 1
      bfd_signed_vma voff = 0;
d953 1
a953 2
	  && irel->r_type != R_SH_DATA
	  && irel->r_type != R_SH_LABEL)
a978 4
#ifdef COFF_WITH_PE
	case R_SH_IMM32CE:
	case R_SH_IMAGEBASE:
#endif
d997 1
a997 1
	      if (val > addr && val < toaddr)
a1036 1
	case R_SH_SWITCH8:
a1061 2
	  else if (irel->r_type == R_SH_SWITCH8)
	    voff = bfd_get_8 (abfd, contents + nraddr);
a1125 7
	    case R_SH_SWITCH8:
	      voff += adjust;
	      if (voff < 0 || voff >= 0xff)
		overflow = true;
	      bfd_put_8 (abfd, voff, contents + nraddr);
	      break;

a1184 5
#ifdef COFF_WITH_PE
	  if (irelscan->r_type != R_SH_IMM32
	      && irelscan->r_type != R_SH_IMAGEBASE
	      && irelscan->r_type != R_SH_IMM32CE)
#else
a1185 1
#endif
d1223 1
a1223 1
	      if (val > addr && val < toaddr)
d1337 1
a1337 1
  unsigned long flags;
a1356 1
#define USES1_REG(x) ((x & 0x0f00) >> 8)
a1360 1
#define USES2_REG(x) ((x & 0x00f0) >> 4)
a1367 1
#define SETS1_REG(x) ((x & 0x0f00) >> 8)
a1371 1
#define SETS2_REG(x) ((x & 0x00f0) >> 4)
a1384 1
#define USESF1_REG(x) ((x & 0x0f00) >> 8)
a1388 1
#define USESF2_REG(x) ((x & 0x00f0) >> 4)
a1395 1
#define SETSF1_REG(x) ((x & 0x0f00) >> 8)
a1396 7
#define USESAS (0x10000)
#define USESAS_REG(x) (((((x) >> 8) - 2) & 3) + 2)
#define USESR8 (0x20000)
#define SETSAS (0x40000)
#define SETSAS_REG(x) USESAS_REG (x)

#ifndef COFF_IMAGE_WITH_PE
a1398 4
static boolean sh_insn_sets_reg
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int));
static boolean sh_insn_uses_or_sets_reg
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int));
a1400 4
static boolean sh_insn_sets_freg
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int));
static boolean sh_insn_uses_or_sets_freg
  PARAMS ((unsigned int, const struct sh_opcode *, unsigned int));
d1407 1
a1407 1
#endif
d1429 1
d1432 1
d1434 1
a1437 15
  { 0x005a, SETS1 | USESSP },			/* sts fpul,rn */
  { 0x006a, SETS1 | USESSP },			/* sts fpscr,rn / sts dsr,rn */
  { 0x0083, LOAD | USES1 },			/* pref @@rn */
  { 0x007a, SETS1 | USESSP },			/* sts a0,rn */
  { 0x008a, SETS1 | USESSP },			/* sts x0,rn */
  { 0x009a, SETS1 | USESSP },			/* sts x1,rn */
  { 0x00aa, SETS1 | USESSP },			/* sts y0,rn */
  { 0x00ba, SETS1 | USESSP }			/* sts y1,rn */
};

/* These sixteen instructions can be handled with one table entry below.  */
#if 0
  { 0x0002, SETS1 | USESSP },			/* stc sr,rn */
  { 0x0012, SETS1 | USESSP },			/* stc gbr,rn */
  { 0x0022, SETS1 | USESSP },			/* stc vbr,rn */
d1440 2
a1441 3
  { 0x0052, SETS1 | USESSP },			/* stc mod,rn */
  { 0x0062, SETS1 | USESSP },			/* stc rs,rn */
  { 0x0072, SETS1 | USESSP },			/* stc re,rn */
d1443 1
d1451 1
a1451 1
#endif
a1454 1
  { 0x0002, SETS1 | USESSP },			/* stc <special_reg>,rn */
d1534 1
d1538 1
d1543 1
d1547 1
a1547 1
  { 0x4014, SETSSP | USES1 },			/* setrc rm */
d1550 1
d1555 1
d1559 1
d1563 1
d1568 1
a1568 26
  { 0x4052, STORE | SETS1 | USES1 | USESSP },	/* sts.l fpul,@@-rn */
  { 0x4056, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,fpul */
  { 0x405a, SETSSP | USES1 },			/* lds.l rm,fpul */
  { 0x4062, STORE | SETS1 | USES1 | USESSP },	/* sts.l fpscr / dsr,@@-rn */
  { 0x4066, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,fpscr / dsr */
  { 0x406a, SETSSP | USES1 },			/* lds rm,fpscr / lds rm,dsr */
  { 0x4072, STORE | SETS1 | USES1 | USESSP },	/* sts.l a0,@@-rn */
  { 0x4076, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,a0 */
  { 0x407a, SETSSP | USES1 },			/* lds.l rm,a0 */
  { 0x4082, STORE | SETS1 | USES1 | USESSP },	/* sts.l x0,@@-rn */
  { 0x4086, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,x0 */
  { 0x408a, SETSSP | USES1 },			/* lds.l rm,x0 */
  { 0x4092, STORE | SETS1 | USES1 | USESSP },	/* sts.l x1,@@-rn */
  { 0x4096, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,x1 */
  { 0x409a, SETSSP | USES1 },			/* lds.l rm,x1 */
  { 0x40a2, STORE | SETS1 | USES1 | USESSP },	/* sts.l y0,@@-rn */
  { 0x40a6, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,y0 */
  { 0x40aa, SETSSP | USES1 },			/* lds.l rm,y0 */
  { 0x40b2, STORE | SETS1 | USES1 | USESSP },	/* sts.l y1,@@-rn */
  { 0x40b6, LOAD | SETS1 | SETSSP | USES1 },	/* lds.l @@rm+,y1 */
  { 0x40ba, SETSSP | USES1 }			/* lds.l rm,y1 */
#if 0 /* These groups sixteen insns can be
         handled with one table entry each below.  */
  { 0x4003, STORE | SETS1 | USES1 | USESSP },	/* stc.l sr,@@-rn */
  { 0x4013, STORE | SETS1 | USES1 | USESSP },	/* stc.l gbr,@@-rn */
  { 0x4023, STORE | SETS1 | USES1 | USESSP },	/* stc.l vbr,@@-rn */
d1570 2
a1572 11
  { 0x4053, STORE | SETS1 | USES1 | USESSP },	/* stc.l mod,@@-rn */
  { 0x4063, STORE | SETS1 | USES1 | USESSP },	/* stc.l rs,@@-rn */
  { 0x4073, STORE | SETS1 | USES1 | USESSP },	/* stc.l re,@@-rn */
  { 0x4083, STORE | SETS1 | USES1 | USESSP },	/* stc.l r0_bank,@@-rn */
  ..
  { 0x40f3, STORE | SETS1 | USES1 | USESSP },	/* stc.l r7_bank,@@-rn */

  { 0x4007, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,sr */
  { 0x4017, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,gbr */
  { 0x4027, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,vbr */
  { 0x4037, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,ssr */
a1573 11
  { 0x4057, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,mod */
  { 0x4067, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,rs */
  { 0x4077, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,re */
  { 0x4087, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,r0_bank */
  ..
  { 0x40f7, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,r7_bank */

  { 0x400e, SETSSP | USES1 },			/* ldc rm,sr */
  { 0x401e, SETSSP | USES1 },			/* ldc rm,gbr */
  { 0x402e, SETSSP | USES1 },			/* ldc rm,vbr */
  { 0x403e, SETSSP | USES1 },			/* ldc rm,ssr */
d1575 6
a1580 7
  { 0x405e, SETSSP | USES1 },			/* ldc rm,mod */
  { 0x406e, SETSSP | USES1 },			/* ldc rm,rs */
  { 0x407e, SETSSP | USES1 }			/* ldc rm,re */
  { 0x408e, SETSSP | USES1 }			/* ldc rm,r0_bank */
  ..
  { 0x40fe, SETSSP | USES1 }			/* ldc rm,r7_bank */
#endif
d1585 9
a1593 5
  { 0x4003, STORE | SETS1 | USES1 | USESSP },	/* stc.l <special_reg>,@@-rn */
  { 0x4007, LOAD | SETS1 | SETSSP | USES1 },	/* ldc.l @@rm+,<special_reg> */
  { 0x400c, SETS1 | USES1 | USES2 },		/* shad rm,rn */
  { 0x400d, SETS1 | USES1 | USES2 },		/* shld rm,rn */
  { 0x400e, SETSSP | USES1 },			/* ldc rm,<special_reg> */
d1600 2
a1601 1
  { MAP (sh_opcode41), 0xf00f }
a1652 1
  { 0x8200, SETSSP },			/* setrc #imm */
a1657 1
  { 0x8c00, SETSSP },			/* ldrs @@(disp,pc) */
a1658 1
  { 0x8e00, SETSSP },			/* ldre @@(disp,pc) */
d1780 1
a1780 1
static struct sh_major_opcode sh_opcodes[] =
a1799 21
/* The double data transfer / parallel processing insns are not
   described here.  This will cause sh_align_load_span to leave them alone.  */

static const struct sh_opcode sh_dsp_opcodef0[] =
{
  { 0xf400, USESAS | SETSAS | LOAD | SETSSP },	/* movs.x @@-as,ds */
  { 0xf401, USESAS | SETSAS | STORE | USESSP },	/* movs.x ds,@@-as */
  { 0xf404, USESAS | LOAD | SETSSP },		/* movs.x @@as,ds */
  { 0xf405, USESAS | STORE | USESSP },		/* movs.x ds,@@as */
  { 0xf408, USESAS | SETSAS | LOAD | SETSSP },	/* movs.x @@as+,ds */
  { 0xf409, USESAS | SETSAS | STORE | USESSP },	/* movs.x ds,@@as+ */
  { 0xf40c, USESAS | SETSAS | LOAD | SETSSP | USESR8 },	/* movs.x @@as+r8,ds */
  { 0xf40d, USESAS | SETSAS | STORE | USESSP | USESR8 }	/* movs.x ds,@@as+r8 */
};

static const struct sh_minor_opcode sh_dsp_opcodef[] =
{
  { MAP (sh_dsp_opcodef0), 0xfc0d }
};

#ifndef COFF_IMAGE_WITH_PE
a1832 14
/* See whether an instruction uses or sets a general purpose register */

static boolean
sh_insn_uses_or_sets_reg (insn, op, reg)
     unsigned int insn;
     const struct sh_opcode *op;
     unsigned int reg;
{
  if (sh_insn_uses_reg (insn, op, reg))
    return true;

  return sh_insn_sets_reg (insn, op, reg);
}

d1846 1
a1846 1
      && USES1_REG (insn) == reg)
d1849 1
a1849 1
      && USES2_REG (insn) == reg)
a1853 31
  if ((f & USESAS) && reg == USESAS_REG (insn))
    return true;
  if ((f & USESR8) && reg == 8)
    return true;

  return false;
}

/* See whether an instruction sets a general purpose register.  */

static boolean
sh_insn_sets_reg (insn, op, reg)
     unsigned int insn;
     const struct sh_opcode *op;
     unsigned int reg;
{
  unsigned int f;

  f = op->flags;

  if ((f & SETS1) != 0
      && SETS1_REG (insn) == reg)
    return true;
  if ((f & SETS2) != 0
      && SETS2_REG (insn) == reg)
    return true;
  if ((f & SETSR0) != 0
      && reg == 0)
    return true;
  if ((f & SETSAS) && reg == SETSAS_REG (insn))
    return true;
a1857 14
/* See whether an instruction uses or sets a floating point register */

static boolean
sh_insn_uses_or_sets_freg (insn, op, reg)
     unsigned int insn;
     const struct sh_opcode *op;
     unsigned int reg;
{
  if (sh_insn_uses_freg (insn, op, reg))
    return true;

  return sh_insn_sets_freg (insn, op, reg);
}

a1869 9
  /* We can't tell if this is a double-precision insn, so just play safe
     and assume that it might be.  So not only have we test FREG against
     itself, but also even FREG against FREG+1 - if the using insn uses
     just the low part of a double precision value - but also an odd
     FREG against FREG-1 -  if the setting insn sets just the low part
     of a double precision value.
     So what this all boils down to is that we have to ignore the lowest
     bit of the register number.  */
     
d1871 1
a1871 1
      && (USESF1_REG (insn) & 0xe) == (freg & 0xe))
d1874 1
a1874 1
      && (USESF2_REG (insn) & 0xe) == (freg & 0xe))
a1882 28
/* See whether an instruction sets a floating point register.  */

static boolean
sh_insn_sets_freg (insn, op, freg)
     unsigned int insn;
     const struct sh_opcode *op;
     unsigned int freg;
{
  unsigned int f;

  f = op->flags;

  /* We can't tell if this is a double-precision insn, so just play safe
     and assume that it might be.  So not only have we test FREG against
     itself, but also even FREG against FREG+1 - if the using insn uses
     just the low part of a double precision value - but also an odd
     FREG against FREG-1 -  if the setting insn sets just the low part
     of a double precision value.
     So what this all boils down to is that we have to ignore the lowest
     bit of the register number.  */
     
  if ((f & SETSF1) != 0
      && (SETSF1_REG (insn) & 0xe) == (freg & 0xe))
    return true;

  return false;
}

a1899 6
  /* Load of fpscr conflicts with floating point operations.
     FIXME: shouldn't test raw opcodes here.  */
  if (((i1 & 0xf0ff) == 0x4066 && (i2 & 0xf000) == 0xf000)
      || ((i2 & 0xf0ff) == 0x4066 && (i1 & 0xf000) == 0xf000))
    return true;

d1904 3
a1906 3
  if (((f1 | f2) & SETSSP)
      && (f1 & (SETSSP | USESSP))
      && (f2 & (SETSSP | USESSP)))
d1910 1
a1910 1
      && sh_insn_uses_or_sets_reg (i2, op2, SETS1_REG (i1)))
d1913 1
a1913 1
      && sh_insn_uses_or_sets_reg (i2, op2, SETS2_REG (i1)))
d1916 1
a1916 4
      && sh_insn_uses_or_sets_reg (i2, op2, 0))
    return true;
  if ((f1 & SETSAS)
      && sh_insn_uses_or_sets_reg (i2, op2, SETSAS_REG (i1)))
d1919 1
a1919 1
      && sh_insn_uses_or_sets_freg (i2, op2, SETSF1_REG (i1)))
d1923 1
a1923 1
      && sh_insn_uses_or_sets_reg (i1, op1, SETS1_REG (i2)))
d1926 1
a1926 1
      && sh_insn_uses_or_sets_reg (i1, op1, SETS2_REG (i2)))
d1929 1
a1929 4
      && sh_insn_uses_or_sets_reg (i1, op1, 0))
    return true;
  if ((f2 & SETSAS)
      && sh_insn_uses_or_sets_reg (i1, op1, SETSAS_REG (i2)))
d1932 1
a1932 1
      && sh_insn_uses_or_sets_freg (i1, op1, SETSF1_REG (i2)))
a1984 3
#ifdef COFF_WITH_PE
static
#endif
a1998 2
  int dsp = (abfd->arch_info->mach == bfd_mach_sh_dsp
	     || abfd->arch_info->mach == bfd_mach_sh3_dsp);
a2000 14
  /* The SH4 has a Harvard architecture, hence aligning loads is not
     desirable.  In fact, it is counter-productive, since it interferes
     with the schedules generated by the compiler.  */
  if (abfd->arch_info->mach == bfd_mach_sh4)
    return true;

  /* If we are linking sh[3]-dsp code, swap the FPU instructions for DSP
     instructions.  */
  if (dsp)
    {
      sh_opcodes[0xf].minor_opcodes = sh_dsp_opcodef;
      sh_opcodes[0xf].count = sizeof sh_dsp_opcodef / sizeof sh_dsp_opcodef;
    }

d2030 1
a2030 22
	  /* If INSN is the field b of a parallel processing insn, it is not
	     a load / store after all.  Note that the test here might mistake
	     the field_b of a pcopy insn for the starting code of a parallel
	     processing insn; this might miss a swapping opportunity, but at
	     least we're on the safe side.  */
	  if (dsp && (prev_insn & 0xfc00) == 0xf800)
	    continue;

	  /* Check if prev_insn is actually the field b of a parallel
	     processing insn.  Again, this can give a spurious match
	     after a pcopy.  */
	  if (dsp && i - 2 > start)
	    {
	      unsigned pprev_insn = bfd_get_16 (abfd, contents + i - 4);
	
	      if ((pprev_insn & 0xfc00) == 0xf800)
		prev_op = NULL;
	      else
		prev_op = sh_insn_info (prev_insn);
	    }
	  else
	    prev_op = sh_insn_info (prev_insn);
a2156 1
#endif /* not COFF_IMAGE_WITH_PE */
d2370 1
a2370 1
     bfd *output_bfd ATTRIBUTE_UNUSED;
a2396 4
#ifdef COFF_WITH_PE
	  && rel->r_type != R_SH_IMM32CE
	  && rel->r_type != R_SH_IMAGEBASE
#endif
d2409 1
a2409 2
	  if (symndx < 0
	      || (unsigned long) symndx >= obj_raw_syment_count (input_bfd))
a2439 5
#ifdef COFF_WITH_PE
      if (rel->r_type == R_SH_IMAGEBASE)
	addend -= pe_data (input_section->output_section->owner)->pe_opthdr.ImageBase;
#endif
      
d2480 1
a2480 1
		      rel->r_vaddr - input_section->vma, true)))
d2636 1
a2636 112
#ifndef TARGET_SHL_SYM
CREATE_BIG_COFF_TARGET_VEC (shcoff_vec, "coff-sh", BFD_IS_RELAXABLE, 0, '_', NULL)
#endif

#ifdef TARGET_SHL_SYM
#define TARGET_SYM TARGET_SHL_SYM
#else
#define TARGET_SYM shlcoff_vec
#endif
     
#ifndef TARGET_SHL_NAME
#define TARGET_SHL_NAME "coff-shl"
#endif

#ifdef COFF_WITH_PE
CREATE_LITTLE_COFF_TARGET_VEC (TARGET_SYM, TARGET_SHL_NAME, BFD_IS_RELAXABLE,
			       SEC_CODE | SEC_DATA, '_', NULL);
#else
CREATE_LITTLE_COFF_TARGET_VEC (TARGET_SYM, TARGET_SHL_NAME, BFD_IS_RELAXABLE,
			       0, '_', NULL)
#endif

#ifndef TARGET_SHL_SYM
/* Some people want versions of the SH COFF target which do not align
   to 16 byte boundaries.  We implement that by adding a couple of new
   target vectors.  These are just like the ones above, but they
   change the default section alignment.  To generate them in the
   assembler, use -small.  To use them in the linker, use -b
   coff-sh{l}-small and -oformat coff-sh{l}-small.

   Yes, this is a horrible hack.  A general solution for setting
   section alignment in COFF is rather complex.  ELF handles this
   correctly.  */

/* Only recognize the small versions if the target was not defaulted.
   Otherwise we won't recognize the non default endianness.  */

static const bfd_target *
coff_small_object_p (abfd)
     bfd *abfd;
{
  if (abfd->target_defaulted)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }
  return coff_object_p (abfd);
}

/* Set the section alignment for the small versions.  */

static boolean
coff_small_new_section_hook (abfd, section)
     bfd *abfd;
     asection *section;
{
  if (! coff_new_section_hook (abfd, section))
    return false;

  /* We must align to at least a four byte boundary, because longword
     accesses must be on a four byte boundary.  */
  if (section->alignment_power == COFF_DEFAULT_SECTION_ALIGNMENT_POWER)
    section->alignment_power = 2;

  return true;
}

/* This is copied from bfd_coff_std_swap_table so that we can change
   the default section alignment power.  */

static const bfd_coff_backend_data bfd_coff_small_swap_table =
{
  coff_swap_aux_in, coff_swap_sym_in, coff_swap_lineno_in,
  coff_swap_aux_out, coff_swap_sym_out,
  coff_swap_lineno_out, coff_swap_reloc_out,
  coff_swap_filehdr_out, coff_swap_aouthdr_out,
  coff_swap_scnhdr_out,
  FILHSZ, AOUTSZ, SCNHSZ, SYMESZ, AUXESZ, RELSZ, LINESZ, FILNMLEN,
#ifdef COFF_LONG_FILENAMES
  true,
#else
  false,
#endif
#ifdef COFF_LONG_SECTION_NAMES
  true,
#else
  false,
#endif
  2,
  coff_swap_filehdr_in, coff_swap_aouthdr_in, coff_swap_scnhdr_in,
  coff_swap_reloc_in, coff_bad_format_hook, coff_set_arch_mach_hook,
  coff_mkobject_hook, styp_to_sec_flags, coff_set_alignment_hook,
  coff_slurp_symbol_table, symname_in_debug_hook, coff_pointerize_aux_hook,
  coff_print_aux, coff_reloc16_extra_cases, coff_reloc16_estimate,
  coff_classify_symbol, coff_compute_section_file_positions,
  coff_start_final_link, coff_relocate_section, coff_rtype_to_howto,
  coff_adjust_symndx, coff_link_add_one_symbol,
  coff_link_output_has_begun, coff_final_link_postscript
};

#define coff_small_close_and_cleanup \
  coff_close_and_cleanup
#define coff_small_bfd_free_cached_info \
  coff_bfd_free_cached_info
#define coff_small_get_section_contents \
  coff_get_section_contents
#define coff_small_get_section_contents_in_window \
  coff_get_section_contents_in_window

extern const bfd_target shlcoff_small_vec;

const bfd_target shcoff_small_vec =
d2638 1
a2638 1
  "coff-sh-small",		/* name */
d2658 1
a2658 1
  {_bfd_dummy_target, coff_small_object_p, /* bfd_check_format */
d2665 1
a2665 1
  BFD_JUMP_TABLE_GENERIC (coff_small),
d2675 1
a2675 3
  & shlcoff_small_vec,
  
  (PTR) &bfd_coff_small_swap_table
d2678 1
a2678 1
const bfd_target shlcoff_small_vec =
d2680 1
a2680 1
  "coff-shl-small",		/* name */
d2700 1
a2700 1
  {_bfd_dummy_target, coff_small_object_p, /* bfd_check_format */
d2707 1
a2707 1
  BFD_JUMP_TABLE_GENERIC (coff_small),
d2717 1
a2717 3
  & shcoff_small_vec,
  
  (PTR) &bfd_coff_small_swap_table
a2718 1
#endif
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.
d34 1
a34 1
static boolean sh_align_load_span
d91 1
a91 1
}
d174 6
a179 6
  HOWTO (R_SH_IMAGEBASE,        /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d181 5
a185 5
	 sh_reloc,       	/* special_function */
	 "rva32",	        /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
d394 1
a394 1
get_symbol_value (symbol)
d396 1
a396 1
{
d400 2
a401 2
    relocation = 0;
  else
d679 1
a679 1
static boolean
d2147 1
a2147 1
  return NULL;
d2254 1
a2254 1

d2288 1
a2288 1

d2488 1
a2488 1

d2878 1
a2878 1
	{
d2915 1
a2915 1

d3121 1
a3121 1

a3200 10
#ifdef COFF_FORCE_SYMBOLS_IN_STRINGS
  true,
#else
  false,
#endif
#ifdef COFF_DEBUG_STRING_WIDE_PREFIX
  4,
#else
  2,
#endif
d3263 1
a3263 1

d3290 1
a3290 1
     bfd_generic_archive_p, _bfd_dummy_target},
d3307 1
a3307 1

@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d1 2
a2 2
/* BFD back-end for Renesas Super-H COFF binaries.
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d8 1
a8 1
   This file is part of BFD, the Binary File Descriptor library.
d10 13
a22 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a25 1
#include "libiberty.h"
d35 1
a35 1
static bfd_boolean sh_align_load_span
d37 2
a38 2
	   bfd_boolean (*) (bfd *, asection *, PTR, bfd_byte *, bfd_vma),
	   PTR, bfd_vma **, bfd_vma *, bfd_vma, bfd_vma, bfd_boolean *));
d50 3
a52 3
static bfd_boolean sh_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean sh_relax_delete_bytes
d57 3
a59 4
static bfd_boolean sh_align_loads
  PARAMS ((bfd *, asection *, struct internal_reloc *, bfd_byte *,
	   bfd_boolean *));
static bfd_boolean sh_swap_insns
d61 1
a61 1
static bfd_boolean sh_relocate_section
d66 1
a66 2
	   bfd_byte *, bfd_boolean, asymbol **));
static reloc_howto_type * sh_coff_reloc_type_lookup PARAMS ((bfd *, bfd_reloc_code_real_type));
d85 1
a85 2
static bfd_boolean in_reloc_p PARAMS ((bfd *, reloc_howto_type *));
/* Return TRUE if this relocation should
d87 1
a87 1
static bfd_boolean in_reloc_p (abfd, howto)
d107 1
a107 1
	 FALSE,			/* pc_relative */
d112 1
a112 1
	 TRUE,			/* partial_inplace */
d115 1
a115 1
	 FALSE),		/* pcrel_offset */
d131 1
a131 1
	 TRUE,			/* pc_relative */
d136 1
a136 1
	 TRUE,			/* partial_inplace */
d139 1
a139 1
	 TRUE),			/* pcrel_offset */
d147 1
a147 1
	 TRUE,			/* pc_relative */
d152 1
a152 1
	 TRUE,			/* partial_inplace */
d155 1
a155 1
	 TRUE),			/* pcrel_offset */
d163 1
a163 1
	 FALSE,			/* pc_relative */
d168 1
a168 1
	 TRUE,			/* partial_inplace */
d171 1
a171 1
	 FALSE),		/* pcrel_offset */
d179 1
a179 1
	 FALSE,	                /* pc_relative */
d184 1
a184 1
	 TRUE,	                /* partial_inplace */
d187 1
a187 1
	 FALSE),                /* pcrel_offset */
d201 1
a201 1
	 TRUE,			/* pc_relative */
d206 1
a206 1
	 TRUE,			/* partial_inplace */
d209 1
a209 1
	 TRUE),			/* pcrel_offset */
d215 1
a215 1
	 TRUE,			/* pc_relative */
d220 1
a220 1
	 TRUE,			/* partial_inplace */
d223 1
a223 1
	 TRUE),			/* pcrel_offset */
d229 1
a229 1
	 FALSE,			/* pc_relative */
d234 1
a234 1
	 TRUE,			/* partial_inplace */
d237 1
a237 1
	 FALSE),		/* pcrel_offset */
d243 1
a243 1
	 FALSE,			/* pc_relative */
d248 1
a248 1
	 TRUE,			/* partial_inplace */
d251 1
a251 1
	 FALSE),		/* pcrel_offset */
d257 1
a257 1
	 FALSE,			/* pc_relative */
d262 1
a262 1
	 TRUE,			/* partial_inplace */
d265 1
a265 1
	 FALSE),		/* pcrel_offset */
d271 1
a271 1
	 FALSE,			/* pc_relative */
d276 1
a276 1
	 TRUE,			/* partial_inplace */
d279 1
a279 1
	 FALSE),		/* pcrel_offset */
d285 1
a285 1
	 FALSE,			/* pc_relative */
d290 1
a290 1
	 TRUE,			/* partial_inplace */
d293 1
a293 1
	 FALSE),		/* pcrel_offset */
d299 1
a299 1
	 FALSE,			/* pc_relative */
d304 1
a304 1
	 TRUE,			/* partial_inplace */
d307 1
a307 1
	 FALSE),		/* pcrel_offset */
d313 1
a313 1
	 FALSE,			/* pc_relative */
d318 1
a318 1
	 TRUE,			/* partial_inplace */
d321 1
a321 1
	 FALSE),		/* pcrel_offset */
d327 1
a327 1
	 FALSE,			/* pc_relative */
d332 1
a332 1
	 TRUE,			/* partial_inplace */
d335 1
a335 1
	 FALSE),		/* pcrel_offset */
d341 1
a341 1
	 FALSE,			/* pc_relative */
d346 1
a346 1
	 TRUE,			/* partial_inplace */
d349 1
a349 1
	 FALSE),		/* pcrel_offset */
d355 1
a355 1
	 FALSE,			/* pc_relative */
d360 1
a360 1
	 TRUE,			/* partial_inplace */
d363 1
a363 1
	 FALSE)			/* pcrel_offset */
d379 2
a380 2
#define SWAP_IN_RELOC_OFFSET  H_GET_32
#define SWAP_OUT_RELOC_OFFSET H_PUT_32
a413 1
static reloc_howto_type * coff_sh_rtype_to_howto PARAMS ((bfd *, asection *, struct internal_reloc *, struct coff_link_hash_entry *, struct internal_syment *, bfd_vma *));
a462 2
#endif /* COFF_WITH_PE */

d466 1
a466 1
  bfd_reloc_code_real_type bfd_reloc_val;
a469 1
#ifdef COFF_WITH_PE
a476 8
#else
/* An array mapping BFD reloc codes to SH PE relocs.  */
static const struct shcoff_reloc_map sh_reloc_map[] =
{
  { BFD_RELOC_32, R_SH_IMM32 },
  { BFD_RELOC_CTOR, R_SH_IMM32 },
};
#endif
d489 5
a493 3
  for (i = ARRAY_SIZE (sh_reloc_map); i--;)
    if (sh_reloc_map[i].bfd_reloc_val == code)
      return &sh_coff_howtos[(int) sh_reloc_map[i].shcoff_reloc_val];
d498 1
d589 1
a589 1
      bfd_put_32 (abfd, (bfd_vma) insn, hit_data);
d594 3
a596 3
      insn += sym_value + reloc_entry->addend;
      insn -= pe_data (input_section->output_section->owner)->pe_opthdr.ImageBase;
      bfd_put_32 (abfd, (bfd_vma) insn, hit_data);
d610 1
a610 1
      bfd_put_16 (abfd, (bfd_vma) insn, hit_data);
d680 1
a680 1
static bfd_boolean
d685 1
a685 1
     bfd_boolean *again;
d689 1
a689 1
  bfd_boolean have_code;
d694 1
a694 1
  *again = FALSE;
d699 1
a699 1
    return TRUE;
d708 1
a708 1
		      (bfd_byte *) NULL, FALSE,
d715 1
a715 1
  have_code = FALSE;
d727 1
a727 1
	have_code = TRUE;
d761 1
a761 1
				 bfd_archive_filename (abfd),
d772 1
a772 1
	    bfd_archive_filename (abfd), (unsigned long) irel->r_vaddr, insn));
d784 1
a784 1
      paddr += (laddr + 4) &~ (bfd_vma) 3;
d789 1
a789 1
	    bfd_archive_filename (abfd), (unsigned long) irel->r_vaddr));
d812 1
a812 1
	    bfd_archive_filename (abfd), (unsigned long) paddr));
d828 1
a828 1
	    bfd_archive_filename (abfd), (unsigned long) paddr));
d886 2
a887 2
	  bfd_size_type amt = sizeof (struct coff_section_tdata);
	  sec->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
d893 1
a893 1
      coff_section_data (abfd, sec)->keep_relocs = TRUE;
d897 1
a897 1
      coff_section_data (abfd, sec)->keep_contents = TRUE;
d900 1
a900 1
      obj_coff_keep_syms (abfd) = TRUE;
d914 1
a914 1
		      (bfd_vma) 0xb000 | ((foff >> 1) & 0xfff),
d922 1
a922 2
	  bfd_put_16 (abfd, (bfd_vma) 0xb000,
		      contents + irel->r_vaddr - sec->vma);
d955 1
a955 1
      *again = TRUE;
d962 1
a962 1
	    bfd_archive_filename (abfd), (unsigned long) paddr));
d971 1
a971 1
				  bfd_archive_filename (abfd),
d995 1
a995 1
      bfd_boolean swapped;
d1023 2
a1024 2
	      bfd_size_type amt = sizeof (struct coff_section_tdata);
	      sec->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
d1030 1
a1030 1
	  coff_section_data (abfd, sec)->keep_relocs = TRUE;
d1034 1
a1034 1
	  coff_section_data (abfd, sec)->keep_contents = TRUE;
d1037 1
a1037 1
	  obj_coff_keep_syms (abfd) = TRUE;
d1056 2
a1057 2
	      bfd_size_type amt = sizeof (struct coff_section_tdata);
	      sec->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
d1066 1
a1066 1
  return TRUE;
d1073 1
a1073 1
  return FALSE;
d1078 1
a1078 1
static bfd_boolean
d1117 1
a1117 2
  memmove (contents + addr, contents + addr + count,
	   (size_t) (toaddr - addr - count));
d1128 1
a1128 1
	bfd_put_16 (abfd, (bfd_vma) NOP_OPCODE, contents + toaddr - count + i);
d1140 1
a1140 1
      bfd_boolean overflow;
d1302 1
a1302 1
	  overflow = FALSE;
d1313 2
a1314 2
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, contents + nraddr);
d1320 2
a1321 2
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, contents + nraddr);
d1334 2
a1335 2
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, contents + nraddr);
d1341 2
a1342 2
		overflow = TRUE;
	      bfd_put_8 (abfd, (bfd_vma) voff, contents + nraddr);
d1348 2
a1349 2
		overflow = TRUE;
	      bfd_put_signed_16 (abfd, (bfd_vma) voff, contents + nraddr);
d1354 1
a1354 1
	      bfd_put_signed_32 (abfd, (bfd_vma) voff, contents + nraddr);
d1366 1
a1366 1
		bfd_archive_filename (abfd), (unsigned long) irel->r_vaddr));
d1368 1
a1368 1
	      return FALSE;
d1390 1
a1390 1
         FALSE, we should free them, if we are permitted to, when we
d1393 1
a1393 1
			 (abfd, o, TRUE, (bfd_byte *) NULL, FALSE,
d1396 1
a1396 1
	return FALSE;
d1432 1
a1432 1
                         Perhaps, if info->keep_memory is FALSE, we
d1437 1
a1437 1
			return FALSE;
d1441 1
a1441 1
			return FALSE;
d1452 1
a1452 1
	      coff_section_data (abfd, o)->keep_contents = TRUE;
d1466 1
a1466 1
	bfd_archive_filename (abfd)));
d1468 1
a1468 1
      return FALSE;
d1517 1
a1517 1
					(int) (alignto - alignaddr));
d1521 1
a1521 1
  return TRUE;
d1636 1
a1636 1
static bfd_boolean sh_insn_uses_reg
d1638 1
a1638 1
static bfd_boolean sh_insn_sets_reg
d1640 1
a1640 1
static bfd_boolean sh_insn_uses_or_sets_reg
d1642 1
a1642 1
static bfd_boolean sh_insn_uses_freg
d1644 1
a1644 1
static bfd_boolean sh_insn_sets_freg
d1646 1
a1646 1
static bfd_boolean sh_insn_uses_or_sets_freg
d1648 1
a1648 1
static bfd_boolean sh_insns_conflict
d1651 1
a1651 1
static bfd_boolean sh_load_use
a2076 1
#ifndef COFF_IMAGE_WITH_PE
a2095 1
#endif
d2153 1
a2153 1
static bfd_boolean
d2160 1
a2160 1
    return TRUE;
d2167 1
a2167 1
static bfd_boolean
d2179 1
a2179 1
    return TRUE;
d2182 1
a2182 1
    return TRUE;
d2185 1
a2185 1
    return TRUE;
d2187 1
a2187 1
    return TRUE;
d2189 1
a2189 1
    return TRUE;
d2191 1
a2191 1
  return FALSE;
d2196 1
a2196 1
static bfd_boolean
d2208 1
a2208 1
    return TRUE;
d2211 1
a2211 1
    return TRUE;
d2214 1
a2214 1
    return TRUE;
d2216 1
a2216 1
    return TRUE;
d2218 1
a2218 1
  return FALSE;
d2223 1
a2223 1
static bfd_boolean
d2230 1
a2230 1
    return TRUE;
d2237 1
a2237 1
static bfd_boolean
d2258 1
a2258 1
    return TRUE;
d2261 1
a2261 1
    return TRUE;
d2264 1
a2264 1
    return TRUE;
d2266 1
a2266 1
  return FALSE;
d2271 1
a2271 1
static bfd_boolean
d2292 1
a2292 1
    return TRUE;
d2294 1
a2294 1
  return FALSE;
d2299 1
a2299 1
   This should return TRUE if there is a conflict, or FALSE if the
d2302 1
a2302 1
static bfd_boolean
d2318 1
a2318 1
    return TRUE;
d2322 1
a2322 1
    return TRUE;
d2327 1
a2327 1
    return TRUE;
d2331 1
a2331 1
    return TRUE;
d2334 1
a2334 1
    return TRUE;
d2337 1
a2337 1
    return TRUE;
d2340 1
a2340 1
    return TRUE;
d2343 1
a2343 1
    return TRUE;
d2347 1
a2347 1
    return TRUE;
d2350 1
a2350 1
    return TRUE;
d2353 1
a2353 1
    return TRUE;
d2356 1
a2356 1
    return TRUE;
d2359 1
a2359 1
    return TRUE;
d2362 1
a2362 1
  return FALSE;
d2366 1
a2366 1
   TRUE if I1 loads a register which I2 uses.  */
d2368 1
a2368 1
static bfd_boolean
d2380 1
a2380 1
    return FALSE;
d2388 1
a2388 1
    return TRUE;
d2392 1
a2392 1
    return TRUE;
d2396 1
a2396 1
    return TRUE;
d2398 1
a2398 1
  return FALSE;
d2409 1
a2409 1
   *PSWAPPED is set to TRUE.  */
d2414 1
a2414 1
bfd_boolean
d2420 1
a2420 1
     bfd_boolean (*swap) PARAMS ((bfd *, asection *, PTR, bfd_byte *, bfd_vma));
d2426 1
a2426 1
     bfd_boolean *pswapped;
d2436 1
a2436 1
    return TRUE;
d2510 1
a2510 1
	  bfd_boolean ok;
d2517 1
a2517 1
	  ok = TRUE;
d2532 1
a2532 1
		ok = FALSE;
d2542 1
a2542 1
		ok = FALSE;
d2548 2
a2549 2
		return FALSE;
	      *pswapped = TRUE;
d2571 1
a2571 1
	      bfd_boolean ok;
d2576 1
a2576 1
	      ok = TRUE;
d2585 1
a2585 1
		ok = FALSE;
d2607 1
a2607 1
		    ok = FALSE;
d2613 2
a2614 2
		    return FALSE;
		  *pswapped = TRUE;
d2621 1
a2621 1
  return TRUE;
d2630 1
a2630 1
static bfd_boolean
d2636 1
a2636 1
     bfd_boolean *pswapped;
a2640 1
  bfd_size_type amt;
d2642 1
a2642 1
  *pswapped = FALSE;
d2647 1
a2647 2
  amt = (bfd_size_type) sec->reloc_count * sizeof (bfd_vma);
  labels = (bfd_vma *) bfd_malloc (amt);
d2691 1
a2691 1
  return TRUE;
d2696 1
a2696 1
  return FALSE;
d2701 1
a2701 1
static bfd_boolean
d2716 2
a2717 2
  bfd_put_16 (abfd, (bfd_vma) i2, contents + addr);
  bfd_put_16 (abfd, (bfd_vma) i1, contents + addr + 2);
d2769 1
a2769 1
	  bfd_boolean overflow;
d2772 1
a2772 1
	  overflow = FALSE;
d2784 2
a2785 2
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, loc);
d2793 2
a2794 2
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, loc);
d2810 2
a2811 2
		    overflow = TRUE;
		  bfd_put_16 (abfd, (bfd_vma) insn, loc);
d2821 1
a2821 1
		bfd_archive_filename (abfd), (unsigned long) irel->r_vaddr));
d2823 1
a2823 1
	      return FALSE;
d2828 1
a2828 1
  return TRUE;
d2834 1
a2834 1
static bfd_boolean
d2885 1
a2885 1
		 bfd_archive_filename (input_bfd), symndx);
d2887 1
a2887 1
	      return FALSE;
d2909 1
a2909 1
	  return FALSE;
d2957 2
a2958 2
		      rel->r_vaddr - input_section->vma, TRUE)))
		return FALSE;
d2995 1
a2995 1
	      return FALSE;
d3000 1
a3000 1
  return TRUE;
d3013 1
a3013 1
     bfd_boolean relocateable;
d3033 1
a3033 1
	  (size_t) input_section->_raw_size);
a3041 1
      bfd_size_type amt;
d3047 2
a3048 2
			 (input_bfd, input_section, FALSE, (bfd_byte *) NULL,
			  FALSE, (struct internal_reloc *) NULL));
d3052 3
a3054 3
      amt = obj_raw_syment_count (input_bfd);
      amt *= sizeof (struct internal_syment);
      internal_syms = (struct internal_syment *) bfd_malloc (amt);
d3058 2
a3059 3
      amt = obj_raw_syment_count (input_bfd);
      amt *= sizeof (asection *);
      sections = (asection **) bfd_malloc (amt);
a3135 2
static const bfd_target * coff_small_object_p PARAMS ((bfd *));
static bfd_boolean coff_small_new_section_hook PARAMS ((bfd *, asection *));
d3164 1
a3164 1
static bfd_boolean
d3170 1
a3170 1
    return FALSE;
d3177 1
a3177 1
  return TRUE;
d3192 1
a3192 1
  TRUE,
d3194 1
a3194 1
  FALSE,
d3197 1
a3197 1
  TRUE,
d3199 1
a3199 1
  FALSE,
d3203 1
a3203 1
  TRUE,
d3205 1
a3205 1
  FALSE,
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d709 1
a709 1
  if (link_info->relocatable
a1649 2
#define MAP(a) a, sizeof a / sizeof a[0]

d1669 2
d1672 1
a1672 1
/* The opcode maps.  */
d2092 1
d2112 1
d2134 1
d2972 1
a2972 1
	  else if (! info->relocatable)
d3027 1
a3027 1
					data, relocatable, symbols)
d3032 1
a3032 1
     bfd_boolean relocatable;
d3043 1
a3043 1
  if (relocatable
d3048 1
a3048 1
						       relocatable,
d3135 1
a3135 1
CREATE_BIG_COFF_TARGET_VEC (shcoff_vec, "coff-sh", BFD_IS_RELAXABLE, 0, '_', NULL, COFF_SWAP_TABLE)
d3150 1
a3150 1
			       SEC_CODE | SEC_DATA, '_', NULL, COFF_SWAP_TABLE);
d3153 1
a3153 1
			       0, '_', NULL, COFF_SWAP_TABLE)
@


