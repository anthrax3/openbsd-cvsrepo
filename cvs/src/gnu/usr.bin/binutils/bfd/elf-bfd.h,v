head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.10
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.12
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.8
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.8
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.01.13.20.05.01;	author kettenis;	state Exp;
branches;
next	1.10;
commitid	g6XJnUzGzjQTJJPi;

1.10
date	2013.04.28.17.17.07;	author bcallah;	state Exp;
branches;
next	1.9;

1.9
date	2013.04.26.03.41.32;	author bcallah;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.02.20.45.06;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.21;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.29;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.12;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.33.01;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.00.24;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.44.35;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.04.45;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.04.45;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.05.30;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.37.39;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.12.23;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.18.55;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.45.36;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.22.41;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.14;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.20;	author miod;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Generate a PT_PHDR entry for static PIE binaries.  Modern GDB needs this to
do some sanity checking while it determines the load base.

ok kurt@@
@
text
@/* BFD back-end data structures for ELF files.
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004 Free Software Foundation, Inc.
   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifndef _LIBELF_H_
#define _LIBELF_H_ 1

#include "elf/common.h"
#include "elf/internal.h"
#include "elf/external.h"
#include "bfdlink.h"

/* The number of entries in a section is its size divided by the size
   of a single entry.  This is normally only applicable to reloc and
   symbol table sections.  */
#define NUM_SHDR_ENTRIES(shdr) ((shdr)->sh_size / (shdr)->sh_entsize)

/* If size isn't specified as 64 or 32, NAME macro should fail.  */
#ifndef NAME
#if ARCH_SIZE == 64
#define NAME(x, y) x ## 64 ## _ ## y
#endif
#if ARCH_SIZE == 32
#define NAME(x, y) x ## 32 ## _ ## y
#endif
#endif

#ifndef NAME
#define NAME(x, y) x ## NOSIZE ## _ ## y
#endif

#define ElfNAME(X)	NAME(Elf,X)
#define elfNAME(X)	NAME(elf,X)

/* Information held for an ELF symbol.  The first field is the
   corresponding asymbol.  Every symbol is an ELF file is actually a
   pointer to this structure, although it is often handled as a
   pointer to an asymbol.  */

typedef struct
{
  /* The BFD symbol.  */
  asymbol symbol;
  /* ELF symbol information.  */
  Elf_Internal_Sym internal_elf_sym;
  /* Backend specific information.  */
  union
    {
      unsigned int hppa_arg_reloc;
      void *mips_extr;
      void *any;
    }
  tc_data;

  /* Version information.  This is from an Elf_Internal_Versym
     structure in a SHT_GNU_versym section.  It is zero if there is no
     version information.  */
  unsigned short version;

} elf_symbol_type;

struct elf_strtab_hash;
struct got_entry;
struct plt_entry;

/* ELF linker hash table entries.  */

struct elf_link_hash_entry
{
  struct bfd_link_hash_entry root;

  /* Symbol index in output file.  This is initialized to -1.  It is
     set to -2 if the symbol is used by a reloc.  */
  long indx;

  /* Symbol index as a dynamic symbol.  Initialized to -1, and remains
     -1 if this is not a dynamic symbol.  */
  /* ??? Note that this is consistently used as a synonym for tests
     against whether we can perform various simplifying transformations
     to the code.  (E.g. changing a pc-relative jump to a PLT entry
     into a pc-relative jump to the target function.)  That test, which
     is often relatively complex, and someplaces wrong or incomplete,
     should really be replaced by a predicate in elflink.c.

     End result: this field -1 does not indicate that the symbol is
     not in the dynamic symbol table, but rather that the symbol is
     not visible outside this DSO.  */
  long dynindx;

  /* String table index in .dynstr if this is a dynamic symbol.  */
  unsigned long dynstr_index;

  /* Hash value of the name computed using the ELF hash function.  */
  unsigned long elf_hash_value;

  /* If this is a weak defined symbol from a dynamic object, this
     field points to a defined symbol with the same value, if there is
     one.  Otherwise it is NULL.  */
  struct elf_link_hash_entry *weakdef;

  /* Version information.  */
  union
  {
    /* This field is used for a symbol which is not defined in a
       regular object.  It points to the version information read in
       from the dynamic object.  */
    Elf_Internal_Verdef *verdef;
    /* This field is used for a symbol which is defined in a regular
       object.  It is set up in size_dynamic_sections.  It points to
       the version information we should write out for this symbol.  */
    struct bfd_elf_version_tree *vertree;
  } verinfo;

  /* Virtual table entry use information.  This array is nominally of size
     size/sizeof(target_void_pointer), though we have to be able to assume
     and track a size while the symbol is still undefined.  It is indexed
     via offset/sizeof(target_void_pointer).  */
  size_t vtable_entries_size;
  bfd_boolean *vtable_entries_used;

  /* Virtual table derivation info.  */
  struct elf_link_hash_entry *vtable_parent;

  /* If this symbol requires an entry in the global offset table, the
     processor specific backend uses this field to track usage and
     final offset.  Two schemes are supported:  The first assumes that
     a symbol may only have one GOT entry, and uses REFCOUNT until
     size_dynamic_sections, at which point the contents of the .got is
     fixed.  Afterward, if OFFSET is -1, then the symbol does not
     require a global offset table entry.  The second scheme allows
     multiple GOT entries per symbol, managed via a linked list
     pointed to by GLIST.  */
  union gotplt_union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
      struct got_entry *glist;
      struct plt_entry *plist;
    } got;

  /* Same, but tracks a procedure linkage table entry.  */
  union gotplt_union plt;

  /* Symbol size.  */
  bfd_size_type size;

  /* Symbol type (STT_NOTYPE, STT_OBJECT, etc.).  */
  char type;

  /* Symbol st_other value, symbol visibility.  */
  unsigned char other;

  /* Some flags; legal values follow.  */
  unsigned short elf_link_hash_flags;
  /* Symbol is referenced by a non-shared object.  */
#define ELF_LINK_HASH_REF_REGULAR 01
  /* Symbol is defined by a non-shared object.  */
#define ELF_LINK_HASH_DEF_REGULAR 02
  /* Symbol is referenced by a shared object.  */
#define ELF_LINK_HASH_REF_DYNAMIC 04
  /* Symbol is defined by a shared object.  */
#define ELF_LINK_HASH_DEF_DYNAMIC 010
  /* Symbol has a non-weak reference from a non-shared object.  */
#define ELF_LINK_HASH_REF_REGULAR_NONWEAK 020
  /* Dynamic symbol has been adjustd.  */
#define ELF_LINK_HASH_DYNAMIC_ADJUSTED 040
  /* Symbol needs a copy reloc.  */
#define ELF_LINK_HASH_NEEDS_COPY 0100
  /* Symbol needs a procedure linkage table entry.  */
#define ELF_LINK_HASH_NEEDS_PLT 0200
  /* Symbol appears in a non-ELF input file.  */
#define ELF_LINK_NON_ELF 0400
  /* Symbol should be marked as hidden in the version information.  */
#define ELF_LINK_HIDDEN 01000
  /* Symbol was forced to local scope due to a version script file.  */
#define ELF_LINK_FORCED_LOCAL 02000
  /* Symbol was marked during garbage collection.  */
#define ELF_LINK_HASH_MARK 04000
  /* Symbol is referenced by a non-GOT/non-PLT relocation.  This is
     not currently set by all the backends.  */
#define ELF_LINK_NON_GOT_REF 010000
  /* Symbol has a definition in a shared object.  */
#define ELF_LINK_DYNAMIC_DEF 020000
  /* Symbol is weak in all shared objects.  */
#define ELF_LINK_DYNAMIC_WEAK 040000
  /* Symbol is referenced with a relocation where C/C++ pointer equality
     matters.  */
#define ELF_LINK_POINTER_EQUALITY_NEEDED 0100000
};

/* Will references to this symbol always reference the symbol
   in this object?  STV_PROTECTED is excluded from the visibility test
   here so that function pointer comparisons work properly.  Since
   function symbols not defined in an app are set to their .plt entry,
   it's necessary for shared libs to also reference the .plt even
   though the symbol is really local to the shared lib.  */
#define SYMBOL_REFERENCES_LOCAL(INFO, H) \
  _bfd_elf_symbol_refs_local_p (H, INFO, 0)

/* Will _calls_ to this symbol always call the version in this object?  */
#define SYMBOL_CALLS_LOCAL(INFO, H) \
  _bfd_elf_symbol_refs_local_p (H, INFO, 1)

/* Records local symbols to be emitted in the dynamic symbol table.  */

struct elf_link_local_dynamic_entry
{
  struct elf_link_local_dynamic_entry *next;

  /* The input bfd this symbol came from.  */
  bfd *input_bfd;

  /* The index of the local symbol being copied.  */
  long input_indx;

  /* The index in the outgoing dynamic symbol table.  */
  long dynindx;

  /* A copy of the input symbol.  */
  Elf_Internal_Sym isym;
};

struct elf_link_loaded_list
{
  struct elf_link_loaded_list *next;
  bfd *abfd;
};

/* Structures used by the eh_frame optimization code.  */
struct cie_header
{
  unsigned int length;
  unsigned int id;
};

struct cie
{
  struct cie_header hdr;
  unsigned char version;
  unsigned char augmentation[20];
  unsigned int code_align;
  int data_align;
  unsigned int ra_column;
  unsigned int augmentation_size;
  struct elf_link_hash_entry *personality;
  unsigned char per_encoding;
  unsigned char lsda_encoding;
  unsigned char fde_encoding;
  unsigned char initial_insn_length;
  unsigned char make_relative;
  unsigned char make_lsda_relative;
  unsigned char initial_instructions[50];
};

struct eh_cie_fde
{
  unsigned int offset;
  unsigned int size;
  asection *sec;
  unsigned int new_offset;
  unsigned char fde_encoding;
  unsigned char lsda_encoding;
  unsigned char lsda_offset;
  unsigned char cie : 1;
  unsigned char removed : 1;
  unsigned char make_relative : 1;
  unsigned char make_lsda_relative : 1;
  unsigned char per_encoding_relative : 1;
};

struct eh_frame_sec_info
{
  unsigned int count;
  unsigned int alloced;
  struct eh_cie_fde entry[1];
};

struct eh_frame_array_ent
{
  bfd_vma initial_loc;
  bfd_vma fde;
};

struct eh_frame_hdr_info
{
  struct cie last_cie;
  asection *last_cie_sec;
  asection *hdr_sec;
  unsigned int last_cie_offset;
  unsigned int fde_count, array_count;
  struct eh_frame_array_ent *array;
  /* TRUE if .eh_frame_hdr should contain the sorted search table.
     We build it if we successfully read all .eh_frame input sections
     and recognize them.  */
  bfd_boolean table;
};

/* ELF linker hash table.  */

struct elf_link_hash_table
{
  struct bfd_link_hash_table root;

  /* Whether we have created the special dynamic sections required
     when linking against or generating a shared object.  */
  bfd_boolean dynamic_sections_created;

  /* The BFD used to hold special sections created by the linker.
     This will be the first BFD found which requires these sections to
     be created.  */
  bfd *dynobj;

  /* The value to use when initialising got.refcount/offset and
     plt.refcount/offset in an elf_link_hash_entry.  Set to zero when
     the values are refcounts.  Set to init_offset in
     size_dynamic_sections when the values may be offsets.  */
  union gotplt_union init_refcount;

  /* The value to use for got.refcount/offset and plt.refcount/offset
     when the values may be offsets.  Normally (bfd_vma) -1.  */
  union gotplt_union init_offset;

  /* The number of symbols found in the link which must be put into
     the .dynsym section.  */
  bfd_size_type dynsymcount;

  /* The string table of dynamic symbols, which becomes the .dynstr
     section.  */
  struct elf_strtab_hash *dynstr;

  /* The number of buckets in the hash table in the .hash section.
     This is based on the number of dynamic symbols.  */
  bfd_size_type bucketcount;

  /* A linked list of DT_NEEDED names found in dynamic objects
     included in the link.  */
  struct bfd_link_needed_list *needed;

  /* The _GLOBAL_OFFSET_TABLE_ symbol.  */
  struct elf_link_hash_entry *hgot;

  /* A pointer to information used to link stabs in sections.  */
  void *stab_info;

  /* A pointer to information used to merge SEC_MERGE sections.  */
  void *merge_info;

  /* Used by eh_frame code when editing .eh_frame.  */
  struct eh_frame_hdr_info eh_info;

  /* A linked list of local symbols to be added to .dynsym.  */
  struct elf_link_local_dynamic_entry *dynlocal;

  /* A linked list of DT_RPATH/DT_RUNPATH names found in dynamic
     objects included in the link.  */
  struct bfd_link_needed_list *runpath;

  /* Cached first output tls section and size of PT_TLS segment.  */
  asection *tls_sec;
  bfd_size_type tls_size;

  /* A linked list of BFD's loaded in the link.  */
  struct elf_link_loaded_list *loaded;
};

/* Look up an entry in an ELF linker hash table.  */

#define elf_link_hash_lookup(table, string, create, copy, follow)	\
  ((struct elf_link_hash_entry *)					\
   bfd_link_hash_lookup (&(table)->root, (string), (create),		\
			 (copy), (follow)))

/* Traverse an ELF linker hash table.  */

#define elf_link_hash_traverse(table, func, info)			\
  (bfd_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) (struct bfd_link_hash_entry *, void *)) (func),	\
    (info)))

/* Get the ELF linker hash table from a link_info structure.  */

#define elf_hash_table(p) ((struct elf_link_hash_table *) ((p)->hash))

/* Returns TRUE if the hash table is a struct elf_link_hash_table.  */
#define is_elf_hash_table(htab)					      	\
  (((struct bfd_link_hash_table *) (htab))->type == bfd_link_elf_hash_table)

/* Used by bfd_section_from_r_symndx to cache a small number of local
   symbol to section mappings.  */
#define LOCAL_SYM_CACHE_SIZE 32
struct sym_sec_cache
{
  bfd *abfd;
  unsigned long indx[LOCAL_SYM_CACHE_SIZE];
  asection *sec[LOCAL_SYM_CACHE_SIZE];
};

/* Constant information held for an ELF backend.  */

struct elf_size_info {
  unsigned char sizeof_ehdr, sizeof_phdr, sizeof_shdr;
  unsigned char sizeof_rel, sizeof_rela, sizeof_sym, sizeof_dyn, sizeof_note;

  /* The size of entries in the .hash section.  */
  unsigned char sizeof_hash_entry;

  /* The number of internal relocations to allocate per external
     relocation entry.  */
  unsigned char int_rels_per_ext_rel;
  /* We use some fixed size arrays.  This should be large enough to
     handle all back-ends.  */
#define MAX_INT_RELS_PER_EXT_REL 3

  unsigned char arch_size, log_file_align;
  unsigned char elfclass, ev_current;
  int (*write_out_phdrs)
    (bfd *, const Elf_Internal_Phdr *, unsigned int);
  bfd_boolean
    (*write_shdrs_and_ehdr) (bfd *);
  void (*write_relocs)
    (bfd *, asection *, void *);
  void (*swap_symbol_in)
    (bfd *, const void *, const void *, Elf_Internal_Sym *);
  void (*swap_symbol_out)
    (bfd *, const Elf_Internal_Sym *, void *, void *);
  bfd_boolean (*slurp_reloc_table)
    (bfd *, asection *, asymbol **, bfd_boolean);
  long (*slurp_symbol_table)
    (bfd *, asymbol **, bfd_boolean);
  void (*swap_dyn_in)
    (bfd *, const void *, Elf_Internal_Dyn *);
  void (*swap_dyn_out)
    (bfd *, const Elf_Internal_Dyn *, void *);

  /* This function is called to swap in a REL relocation.  If an
     external relocation corresponds to more than one internal
     relocation, then all relocations are swapped in at once.  */
  void (*swap_reloc_in)
    (bfd *, const bfd_byte *, Elf_Internal_Rela *);

  /* This function is called to swap out a REL relocation.  */
  void (*swap_reloc_out)
    (bfd *, const Elf_Internal_Rela *, bfd_byte *);

  /* This function is called to swap in a RELA relocation.  If an
     external relocation corresponds to more than one internal
     relocation, then all relocations are swapped in at once.  */
  void (*swap_reloca_in)
    (bfd *, const bfd_byte *, Elf_Internal_Rela *);

  /* This function is called to swap out a RELA relocation.  */
  void (*swap_reloca_out)
    (bfd *, const Elf_Internal_Rela *, bfd_byte *);
};

#define elf_symbol_from(ABFD,S) \
	(((S)->the_bfd->xvec->flavour == bfd_target_elf_flavour \
	  && (S)->the_bfd->tdata.elf_obj_data != 0) \
	 ? (elf_symbol_type *) (S) \
	 : 0)

enum elf_reloc_type_class {
  reloc_class_normal,
  reloc_class_relative,
  reloc_class_plt,
  reloc_class_copy
};

struct elf_reloc_cookie
{
  Elf_Internal_Rela *rels, *rel, *relend;
  Elf_Internal_Sym *locsyms;
  bfd *abfd;
  size_t locsymcount;
  size_t extsymoff;
  struct elf_link_hash_entry **sym_hashes;
  int r_sym_shift;
  bfd_boolean bad_symtab;
};

/* The level of IRIX compatibility we're striving for.  */

typedef enum {
  ict_none,
  ict_irix5,
  ict_irix6
} irix_compat_t;

/* Mapping of ELF section names and types.  */
struct bfd_elf_special_section
{
  const char *prefix;
  int prefix_length;
  /* 0 means name must match PREFIX exactly.
     -1 means name must start with PREFIX followed by an arbitrary string.
     -2 means name must match PREFIX exactly or consist of PREFIX followed
     by a dot then anything.
     > 0 means name must start with the first PREFIX_LENGTH chars of
     PREFIX and finish with the last SUFFIX_LENGTH chars of PREFIX.  */
  int suffix_length;
  int type;
  int attr;
};

struct elf_backend_data
{
  /* The architecture for this backend.  */
  enum bfd_architecture arch;

  /* The ELF machine code (EM_xxxx) for this backend.  */
  int elf_machine_code;

  /* The maximum page size for this backend.  */
  bfd_vma maxpagesize;

  /* A function to translate an ELF RELA relocation to a BFD arelent
     structure.  */
  void (*elf_info_to_howto)
    (bfd *, arelent *, Elf_Internal_Rela *);

  /* A function to translate an ELF REL relocation to a BFD arelent
     structure.  */
  void (*elf_info_to_howto_rel)
    (bfd *, arelent *, Elf_Internal_Rela *);

  /* A function to determine whether a symbol is global when
     partitioning the symbol table into local and global symbols.
     This should be NULL for most targets, in which case the correct
     thing will be done.  MIPS ELF, at least on the Irix 5, has
     special requirements.  */
  bfd_boolean (*elf_backend_sym_is_global)
    (bfd *, asymbol *);

  /* The remaining functions are hooks which are called only if they
     are not NULL.  */

  /* A function to permit a backend specific check on whether a
     particular BFD format is relevant for an object file, and to
     permit the backend to set any global information it wishes.  When
     this is called elf_elfheader is set, but anything else should be
     used with caution.  If this returns FALSE, the check_format
     routine will return a bfd_error_wrong_format error.  */
  bfd_boolean (*elf_backend_object_p)
    (bfd *);

  /* A function to do additional symbol processing when reading the
     ELF symbol table.  This is where any processor-specific special
     section indices are handled.  */
  void (*elf_backend_symbol_processing)
    (bfd *, asymbol *);

  /* A function to do additional symbol processing after reading the
     entire ELF symbol table.  */
  bfd_boolean (*elf_backend_symbol_table_processing)
    (bfd *, elf_symbol_type *, unsigned int);

   /* A function to set the type of the info field.  Processor-specific
     types should be handled here.  */
  int (*elf_backend_get_symbol_type)
    (Elf_Internal_Sym *, int);

  /* Return true if local section symbols should have a non-null st_name.
     NULL implies false.  */
  bfd_boolean (*elf_backend_name_local_section_symbols)
    (bfd *);

  /* A function to do additional processing on the ELF section header
     just before writing it out.  This is used to set the flags and
     type fields for some sections, or to actually write out data for
     unusual sections.  */
  bfd_boolean (*elf_backend_section_processing)
    (bfd *, Elf_Internal_Shdr *);

  /* A function to handle unusual section types when creating BFD
     sections from ELF sections.  */
  bfd_boolean (*elf_backend_section_from_shdr)
    (bfd *, Elf_Internal_Shdr *, const char *);

  /* A function to convert machine dependent section header flags to
     BFD internal section header flags.  */
  bfd_boolean (*elf_backend_section_flags)
    (flagword *, Elf_Internal_Shdr *);

  /* A function to handle unusual program segment types when creating BFD
     sections from ELF program segments.  */
  bfd_boolean (*elf_backend_section_from_phdr)
    (bfd *, Elf_Internal_Phdr *, int);

  /* A function to set up the ELF section header for a BFD section in
     preparation for writing it out.  This is where the flags and type
     fields are set for unusual sections.  */
  bfd_boolean (*elf_backend_fake_sections)
    (bfd *, Elf_Internal_Shdr *, asection *);

  /* A function to get the ELF section index for a BFD section.  If
     this returns TRUE, the section was found.  If it is a normal ELF
     section, *RETVAL should be left unchanged.  If it is not a normal
     ELF section *RETVAL should be set to the SHN_xxxx index.  */
  bfd_boolean (*elf_backend_section_from_bfd_section)
    (bfd *, asection *, int *retval);

  /* If this field is not NULL, it is called by the add_symbols phase
     of a link just before adding a symbol to the global linker hash
     table.  It may modify any of the fields as it wishes.  If *NAME
     is set to NULL, the symbol will be skipped rather than being
     added to the hash table.  This function is responsible for
     handling all processor dependent symbol bindings and section
     indices, and must set at least *FLAGS and *SEC for each processor
     dependent case; failure to do so will cause a link error.  */
  bfd_boolean (*elf_add_symbol_hook)
    (bfd *abfd, struct bfd_link_info *info, Elf_Internal_Sym *,
     const char **name, flagword *flags, asection **sec, bfd_vma *value);

  /* If this field is not NULL, it is called by the elf_link_output_sym
     phase of a link for each symbol which will appear in the object file.  */
  bfd_boolean (*elf_backend_link_output_symbol_hook)
    (struct bfd_link_info *info, const char *, Elf_Internal_Sym *,
     asection *, struct elf_link_hash_entry *);

  /* The CREATE_DYNAMIC_SECTIONS function is called by the ELF backend
     linker the first time it encounters a dynamic object in the link.
     This function must create any sections required for dynamic
     linking.  The ABFD argument is a dynamic object.  The .interp,
     .dynamic, .dynsym, .dynstr, and .hash functions have already been
     created, and this function may modify the section flags if
     desired.  This function will normally create the .got and .plt
     sections, but different backends have different requirements.  */
  bfd_boolean (*elf_backend_create_dynamic_sections)
    (bfd *abfd, struct bfd_link_info *info);

  /* The CHECK_RELOCS function is called by the add_symbols phase of
     the ELF backend linker.  It is called once for each section with
     relocs of an object file, just after the symbols for the object
     file have been added to the global linker hash table.  The
     function must look through the relocs and do any special handling
     required.  This generally means allocating space in the global
     offset table, and perhaps allocating space for a reloc.  The
     relocs are always passed as Rela structures; if the section
     actually uses Rel structures, the r_addend field will always be
     zero.  */
  bfd_boolean (*check_relocs)
    (bfd *abfd, struct bfd_link_info *info, asection *o,
     const Elf_Internal_Rela *relocs);

  /* The ADJUST_DYNAMIC_SYMBOL function is called by the ELF backend
     linker for every symbol which is defined by a dynamic object and
     referenced by a regular object.  This is called after all the
     input files have been seen, but before the SIZE_DYNAMIC_SECTIONS
     function has been called.  The hash table entry should be
     bfd_link_hash_defined ore bfd_link_hash_defweak, and it should be
     defined in a section from a dynamic object.  Dynamic object
     sections are not included in the final link, and this function is
     responsible for changing the value to something which the rest of
     the link can deal with.  This will normally involve adding an
     entry to the .plt or .got or some such section, and setting the
     symbol to point to that.  */
  bfd_boolean (*elf_backend_adjust_dynamic_symbol)
    (struct bfd_link_info *info, struct elf_link_hash_entry *h);

  /* The ALWAYS_SIZE_SECTIONS function is called by the backend linker
     after all the linker input files have been seen but before the
     section sizes have been set.  This is called after
     ADJUST_DYNAMIC_SYMBOL, but before SIZE_DYNAMIC_SECTIONS.  */
  bfd_boolean (*elf_backend_always_size_sections)
    (bfd *output_bfd, struct bfd_link_info *info);

  /* The SIZE_DYNAMIC_SECTIONS function is called by the ELF backend
     linker after all the linker input files have been seen but before
     the sections sizes have been set.  This is called after
     ADJUST_DYNAMIC_SYMBOL has been called on all appropriate symbols.
     It is only called when linking against a dynamic object.  It must
     set the sizes of the dynamic sections, and may fill in their
     contents as well.  The generic ELF linker can handle the .dynsym,
     .dynstr and .hash sections.  This function must handle the
     .interp section and any sections created by the
     CREATE_DYNAMIC_SECTIONS entry point.  */
  bfd_boolean (*elf_backend_size_dynamic_sections)
    (bfd *output_bfd, struct bfd_link_info *info);

  /* The RELOCATE_SECTION function is called by the ELF backend linker
     to handle the relocations for a section.

     The relocs are always passed as Rela structures; if the section
     actually uses Rel structures, the r_addend field will always be
     zero.

     This function is responsible for adjust the section contents as
     necessary, and (if using Rela relocs and generating a
     relocatable output file) adjusting the reloc addend as
     necessary.

     This function does not have to worry about setting the reloc
     address or the reloc symbol index.

     LOCAL_SYMS is a pointer to the swapped in local symbols.

     LOCAL_SECTIONS is an array giving the section in the input file
     corresponding to the st_shndx field of each local symbol.

     The global hash table entry for the global symbols can be found
     via elf_sym_hashes (input_bfd).

     When generating relocatable output, this function must handle
     STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
     going to be the section symbol corresponding to the output
     section, which means that the addend must be adjusted
     accordingly.  */
  bfd_boolean (*elf_backend_relocate_section)
    (bfd *output_bfd, struct bfd_link_info *info, bfd *input_bfd,
     asection *input_section, bfd_byte *contents, Elf_Internal_Rela *relocs,
     Elf_Internal_Sym *local_syms, asection **local_sections);

  /* The FINISH_DYNAMIC_SYMBOL function is called by the ELF backend
     linker just before it writes a symbol out to the .dynsym section.
     The processor backend may make any required adjustment to the
     symbol.  It may also take the opportunity to set contents of the
     dynamic sections.  Note that FINISH_DYNAMIC_SYMBOL is called on
     all .dynsym symbols, while ADJUST_DYNAMIC_SYMBOL is only called
     on those symbols which are defined by a dynamic object.  */
  bfd_boolean (*elf_backend_finish_dynamic_symbol)
    (bfd *output_bfd, struct bfd_link_info *info,
     struct elf_link_hash_entry *h, Elf_Internal_Sym *sym);

  /* The FINISH_DYNAMIC_SECTIONS function is called by the ELF backend
     linker just before it writes all the dynamic sections out to the
     output file.  The FINISH_DYNAMIC_SYMBOL will have been called on
     all dynamic symbols.  */
  bfd_boolean (*elf_backend_finish_dynamic_sections)
    (bfd *output_bfd, struct bfd_link_info *info);

  /* A function to do any beginning processing needed for the ELF file
     before building the ELF headers and computing file positions.  */
  void (*elf_backend_begin_write_processing)
    (bfd *, struct bfd_link_info *);

  /* A function to do any final processing needed for the ELF file
     before writing it out.  The LINKER argument is TRUE if this BFD
     was created by the ELF backend linker.  */
  void (*elf_backend_final_write_processing)
    (bfd *, bfd_boolean linker);

  /* This function is called by get_program_header_size.  It should
     return the number of additional program segments which this BFD
     will need.  It should return -1 on error.  */
  int (*elf_backend_additional_program_headers)
    (bfd *);

  /* This function is called to modify an existing segment map in a
     backend specific fashion.  */
  bfd_boolean (*elf_backend_modify_segment_map)
    (bfd *, struct bfd_link_info *);

  /* This function is called during section gc to discover the section a
     particular relocation refers to.  */
  asection * (*gc_mark_hook)
    (asection *sec, struct bfd_link_info *, Elf_Internal_Rela *,
     struct elf_link_hash_entry *h, Elf_Internal_Sym *);

  /* This function, if defined, is called during the sweep phase of gc
     in order that a backend might update any data structures it might
     be maintaining.  */
  bfd_boolean (*gc_sweep_hook)
    (bfd *abfd, struct bfd_link_info *info, asection *o,
     const Elf_Internal_Rela *relocs);

  /* This function, if defined, is called after the ELF headers have
     been created.  This allows for things like the OS and ABI versions
     to be changed.  */
  void (*elf_backend_post_process_headers)
    (bfd *, struct bfd_link_info *);

  /* This function, if defined, prints a symbol to file and returns the
     name of the symbol to be printed.  It should return NULL to fall
     back to default symbol printing.  */
  const char *(*elf_backend_print_symbol_all)
    (bfd *, void *, asymbol *);

  /* This function, if defined, is called after all local symbols and
     global symbols converted to locals are emitted into the symtab
     section.  It allows the backend to emit special global symbols
     not handled in the hash table.  */
  bfd_boolean (*elf_backend_output_arch_syms)
    (bfd *, struct bfd_link_info *, void *,
     bfd_boolean (*) (void *, const char *, Elf_Internal_Sym *, asection *,
		      struct elf_link_hash_entry *));

  /* Copy any information related to dynamic linking from a pre-existing
     symbol to a newly created symbol.  Also called to copy flags and
     other back-end info to a weakdef, in which case the symbol is not
     newly created and plt/got refcounts and dynamic indices should not
     be copied.  */
  void (*elf_backend_copy_indirect_symbol)
    (const struct elf_backend_data *, struct elf_link_hash_entry *,
     struct elf_link_hash_entry *);

  /* Modify any information related to dynamic linking such that the
     symbol is not exported.  */
  void (*elf_backend_hide_symbol)
    (struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean);

  /* Merge the backend specific symbol attribute.  */
  void (*elf_backend_merge_symbol_attribute)
    (struct elf_link_hash_entry *, const Elf_Internal_Sym *, bfd_boolean,
     bfd_boolean);

  /* Emit relocations.  Overrides default routine for emitting relocs,
     except during a relocatable link, or if all relocs are being emitted.  */
  bfd_boolean (*elf_backend_emit_relocs)
    (bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *);

  /* Count relocations.  Not called for relocatable links
     or if all relocs are being preserved in the output.  */
  unsigned int (*elf_backend_count_relocs)
    (asection *, Elf_Internal_Rela *);

  /* This function, if defined, is called when an NT_PRSTATUS note is found
     in a core file. */
  bfd_boolean (*elf_backend_grok_prstatus)
    (bfd *, Elf_Internal_Note *);

  /* This function, if defined, is called when an NT_PSINFO or NT_PRPSINFO
     note is found in a core file. */
  bfd_boolean (*elf_backend_grok_psinfo)
    (bfd *, Elf_Internal_Note *);

  /* Functions to print VMAs.  Special code to handle 64 bit ELF files.  */
  void (* elf_backend_sprintf_vma)
    (bfd *, char *, bfd_vma);
  void (* elf_backend_fprintf_vma)
    (bfd *, void *, bfd_vma);

  /* This function returns class of a reloc type.  */
  enum elf_reloc_type_class (*elf_backend_reloc_type_class)
    (const Elf_Internal_Rela *);

  /* This function, if defined, removes information about discarded functions
     from other sections which mention them.  */
  bfd_boolean (*elf_backend_discard_info)
    (bfd *, struct elf_reloc_cookie *, struct bfd_link_info *);

  /* This function, if defined, signals that the function above has removed
     the discarded relocations for this section.  */
  bfd_boolean (*elf_backend_ignore_discarded_relocs)
    (asection *);

  /* These functions tell elf-eh-frame whether to attempt to turn
     absolute or lsda encodings into pc-relative ones.  The default
     definition enables these transformations.  */
  bfd_boolean (*elf_backend_can_make_relative_eh_frame)
     (bfd *, struct bfd_link_info *, asection *);
  bfd_boolean (*elf_backend_can_make_lsda_relative_eh_frame)
     (bfd *, struct bfd_link_info *, asection *);

  /* This function returns an encoding after computing the encoded
     value (and storing it in ENCODED) for the given OFFSET into OSEC,
     to be stored in at LOC_OFFSET into the LOC_SEC input section.
     The default definition chooses a 32-bit PC-relative encoding.  */
  bfd_byte (*elf_backend_encode_eh_address)
     (bfd *abfd, struct bfd_link_info *info,
      asection *osec, bfd_vma offset,
      asection *loc_sec, bfd_vma loc_offset,
      bfd_vma *encoded);

  /* This function, if defined, may write out the given section.
     Returns TRUE if it did so and FALSE if the caller should.  */
  bfd_boolean (*elf_backend_write_section)
    (bfd *, asection *, bfd_byte *);

  /* The level of IRIX compatibility we're striving for.
     MIPS ELF specific function.  */
  irix_compat_t (*elf_backend_mips_irix_compat)
    (bfd *);

  reloc_howto_type *(*elf_backend_mips_rtype_to_howto)
    (unsigned int, bfd_boolean);

  /* The swapping table to use when dealing with ECOFF information.
     Used for the MIPS ELF .mdebug section.  */
  const struct ecoff_debug_swap *elf_backend_ecoff_debug_swap;

  /* This function implements `bfd_elf_bfd_from_remote_memory';
     see elf.c, elfcode.h.  */
  bfd *(*elf_backend_bfd_from_remote_memory)
     (bfd *templ, bfd_vma ehdr_vma, bfd_vma *loadbasep,
      int (*target_read_memory) (bfd_vma vma, char *myaddr, int len));

  /* Alternate EM_xxxx machine codes for this backend.  */
  int elf_machine_alt1;
  int elf_machine_alt2;

  const struct elf_size_info *s;

  /* An array of target specific special section map.  */
  const struct bfd_elf_special_section *special_sections;

  /* offset of the _GLOBAL_OFFSET_TABLE_ symbol from the start of the
     .got section */
  bfd_vma got_symbol_offset;

  /* The size in bytes of the header for the GOT.  This includes the
     so-called reserved entries on some systems.  */
  bfd_vma got_header_size;

  /* This is TRUE if the linker should act like collect and gather
     global constructors and destructors by name.  This is TRUE for
     MIPS ELF because the Irix 5 tools can not handle the .init
     section.  */
  unsigned collect : 1;

  /* This is TRUE if the linker should ignore changes to the type of a
     symbol.  This is TRUE for MIPS ELF because some Irix 5 objects
     record undefined functions as STT_OBJECT although the definitions
     are STT_FUNC.  */
  unsigned type_change_ok : 1;

  /* Whether the backend may use REL relocations.  (Some backends use
     both REL and RELA relocations, and this flag is set for those
     backends.)  */
  unsigned may_use_rel_p : 1;

  /* Whether the backend may use RELA relocations.  (Some backends use
     both REL and RELA relocations, and this flag is set for those
     backends.)  */
  unsigned may_use_rela_p : 1;

  /* Whether the default relocation type is RELA.  If a backend with
     this flag set wants REL relocations for a particular section,
     it must note that explicitly.  Similarly, if this flag is clear,
     and the backend wants RELA relocations for a particular
     section.  */
  unsigned default_use_rela_p : 1;

  /* Set if RELA relocations for a relocatable link can be handled by
     generic code.  Backends that set this flag need do nothing in the
     backend relocate_section routine for relocatable linking.  */
  unsigned rela_normal : 1;

  /* TRUE if addresses "naturally" sign extend.  This is used when
     swapping in from Elf32 when BFD64.  */
  unsigned sign_extend_vma : 1;

  unsigned want_got_plt : 1;
  unsigned plt_readonly : 1;
  unsigned want_plt_sym : 1;
  unsigned plt_not_loaded : 1;
  unsigned plt_alignment : 4;
  unsigned can_gc_sections : 1;
  unsigned can_refcount : 1;
  unsigned want_got_sym : 1;
  unsigned want_dynbss : 1;
    /* Targets which do not support physical addressing often require
       that the p_paddr field in the section header to be set to zero.
       This field indicates whether this behavior is required.  */
  unsigned want_p_paddr_set_to_zero : 1;
};

/* Information stored for each BFD section in an ELF file.  This
   structure is allocated by elf_new_section_hook.  */

struct bfd_elf_section_data
{
  /* The ELF header for this section.  */
  Elf_Internal_Shdr this_hdr;

  /* The ELF header for the reloc section associated with this
     section, if any.  */
  Elf_Internal_Shdr rel_hdr;

  /* If there is a second reloc section associated with this section,
     as can happen on Irix 6, this field points to the header.  */
  Elf_Internal_Shdr *rel_hdr2;

  /* The number of relocations currently assigned to REL_HDR.  */
  unsigned int rel_count;

  /* The number of relocations currently assigned to REL_HDR2.  */
  unsigned int rel_count2;

  /* The ELF section number of this section.  Only used for an output
     file.  */
  int this_idx;

  /* The ELF section number of the reloc section indicated by
     REL_HDR if any.  Only used for an output file.  */
  int rel_idx;

  /* The ELF section number of the reloc section indicated by
     REL_HDR2 if any.  Only used for an output file.  */
  int rel_idx2;

  /* Used by the backend linker when generating a shared library to
     record the dynamic symbol index for a section symbol
     corresponding to this section.  A value of 0 means that there is
     no dynamic symbol for this section.  */
  int dynindx;

  /* Used by the backend linker to store the symbol hash table entries
     associated with relocs against global symbols.  */
  struct elf_link_hash_entry **rel_hashes;

  /* A pointer to the swapped relocs.  If the section uses REL relocs,
     rather than RELA, all the r_addend fields will be zero.  This
     pointer may be NULL.  It is used by the backend linker.  */
  Elf_Internal_Rela *relocs;

  /* A pointer to a linked list tracking dynamic relocs copied for
     local symbols.  */
  void *local_dynrel;

  /* A pointer to the bfd section used for dynamic relocs.  */
  asection *sreloc;

  union {
    /* Group name, if this section is a member of a group.  */
    const char *name;

    /* Group signature sym, if this is the SHT_GROUP section.  */
    struct bfd_symbol *id;
  } group;

  /* A linked list of sections in the group.  Circular when used by
     the linker.  */
  asection *next_in_group;

  /* A pointer used for various section optimizations.  */
  void *sec_info;
};

#define elf_section_data(sec)  ((struct bfd_elf_section_data*)sec->used_by_bfd)
#define elf_section_type(sec)  (elf_section_data(sec)->this_hdr.sh_type)
#define elf_section_flags(sec) (elf_section_data(sec)->this_hdr.sh_flags)
#define elf_group_name(sec)    (elf_section_data(sec)->group.name)
#define elf_group_id(sec)      (elf_section_data(sec)->group.id)
#define elf_next_in_group(sec) (elf_section_data(sec)->next_in_group)

/* Return TRUE if section has been discarded.  */
#define elf_discarded_section(sec)				\
  (!bfd_is_abs_section (sec)					\
   && bfd_is_abs_section ((sec)->output_section)		\
   && sec->sec_info_type != ELF_INFO_TYPE_MERGE			\
   && sec->sec_info_type != ELF_INFO_TYPE_JUST_SYMS)

#define get_elf_backend_data(abfd) \
  ((const struct elf_backend_data *) (abfd)->xvec->backend_data)

/* This struct is used to pass information to routines called via
   elf_link_hash_traverse which must return failure.  */

struct elf_info_failed
{
  bfd_boolean failed;
  struct bfd_link_info *info;
  struct bfd_elf_version_tree *verdefs;
};

/* This structure is used to pass information to
   _bfd_elf_link_assign_sym_version.  */

struct elf_assign_sym_version_info
{
  /* Output BFD.  */
  bfd *output_bfd;
  /* General link information.  */
  struct bfd_link_info *info;
  /* Version tree.  */
  struct bfd_elf_version_tree *verdefs;
  /* Whether we had a failure.  */
  bfd_boolean failed;
};

/* This structure is used to pass information to
   _bfd_elf_link_find_version_dependencies.  */

struct elf_find_verdep_info
{
  /* Output BFD.  */
  bfd *output_bfd;
  /* General link information.  */
  struct bfd_link_info *info;
  /* The number of dependencies.  */
  unsigned int vers;
  /* Whether we had a failure.  */
  bfd_boolean failed;
};

/* Some private data is stashed away for future use using the tdata pointer
   in the bfd structure.  */

struct elf_obj_tdata
{
  Elf_Internal_Ehdr elf_header[1];	/* Actual data, but ref like ptr */
  Elf_Internal_Shdr **elf_sect_ptr;
  Elf_Internal_Phdr *phdr;
  struct elf_segment_map *segment_map;
  struct elf_strtab_hash *strtab_ptr;
  int num_locals;
  int num_globals;
  unsigned int num_elf_sections;	/* elf_sect_ptr size */
  int num_section_syms;
  asymbol **section_syms;		/* STT_SECTION symbols for each section */
  Elf_Internal_Shdr symtab_hdr;
  Elf_Internal_Shdr shstrtab_hdr;
  Elf_Internal_Shdr strtab_hdr;
  Elf_Internal_Shdr dynsymtab_hdr;
  Elf_Internal_Shdr dynstrtab_hdr;
  Elf_Internal_Shdr dynversym_hdr;
  Elf_Internal_Shdr dynverref_hdr;
  Elf_Internal_Shdr dynverdef_hdr;
  Elf_Internal_Shdr symtab_shndx_hdr;
  unsigned int symtab_section, shstrtab_section;
  unsigned int strtab_section, dynsymtab_section;
  unsigned int symtab_shndx_section;
  unsigned int dynversym_section, dynverdef_section, dynverref_section;
  file_ptr next_file_pos;
  bfd_vma gp;				/* The gp value */
  unsigned int gp_size;			/* The gp size */

  /* Information grabbed from an elf core file.  */
  int core_signal;
  int core_pid;
  int core_lwpid;
  char* core_program;
  char* core_command;

  /* A mapping from external symbols to entries in the linker hash
     table, used when linking.  This is indexed by the symbol index
     minus the sh_info field of the symbol table header.  */
  struct elf_link_hash_entry **sym_hashes;

  /* Track usage and final offsets of GOT entries for local symbols.
     This array is indexed by symbol index.  Elements are used
     identically to "got" in struct elf_link_hash_entry.  */
  union
    {
      bfd_signed_vma *refcounts;
      bfd_vma *offsets;
      struct got_entry **ents;
    } local_got;

  /* The linker ELF emulation code needs to let the backend ELF linker
     know what filename should be used for a dynamic object if the
     dynamic object is found using a search.  The emulation code then
     sometimes needs to know what name was actually used.  Until the
     file has been added to the linker symbol table, this field holds
     the name the linker wants.  After it has been added, it holds the
     name actually used, which will be the DT_SONAME entry if there is
     one.  */
  const char *dt_name;

  /* Records the result of `get_program_header_size'.  */
  bfd_size_type program_header_size;

  /* Used by find_nearest_line entry point.  */
  void *line_info;

  /* Used by MIPS ELF find_nearest_line entry point.  The structure
     could be included directly in this one, but there's no point to
     wasting the memory just for the infrequently called
     find_nearest_line.  */
  struct mips_elf_find_line *find_line_info;

  /* A place to stash dwarf1 info for this bfd.  */
  struct dwarf1_debug *dwarf1_find_line_info;

  /* A place to stash dwarf2 info for this bfd.  */
  void *dwarf2_find_line_info;

  /* An array of stub sections indexed by symbol number, used by the
     MIPS ELF linker.  FIXME: We should figure out some way to only
     include this field for a MIPS ELF target.  */
  asection **local_stubs;

  /* Used to determine if PT_GNU_EH_FRAME segment header should be
     created.  */
  asection *eh_frame_hdr;

  Elf_Internal_Shdr **group_sect_ptr;
  int num_group;

  /* Number of symbol version definitions we are about to emit.  */
  unsigned int cverdefs;

  /* Number of symbol version references we are about to emit.  */
  unsigned int cverrefs;

  /* Segment flags for the PT_GNU_STACK segment.  */
  unsigned int stack_flags;  

  /* Symbol version definitions in external objects.  */
  Elf_Internal_Verdef *verdef;

  /* Symbol version references to external objects.  */
  Elf_Internal_Verneed *verref;

  /* The Irix 5 support uses two virtual sections, which represent
     text/data symbols defined in dynamic objects.  */
  asymbol *elf_data_symbol;
  asymbol *elf_text_symbol;
  asection *elf_data_section;
  asection *elf_text_section;

  /* Whether a dyanmic object was specified normally on the linker
     command line, or was specified when --as-needed was in effect,
     or was found via a DT_NEEDED entry.  */
  enum dynamic_lib_link_class dyn_lib_class;

  /* This is set to TRUE if the object was created by the backend
     linker.  */
  bfd_boolean linker;

  /* Irix 5 often screws up the symbol table, sorting local symbols
     after global symbols.  This flag is set if the symbol table in
     this BFD appears to be screwed up.  If it is, we ignore the
     sh_info field in the symbol table header, and always read all the
     symbols.  */
  bfd_boolean bad_symtab;

  /* Used to determine if the e_flags field has been initialized */
  bfd_boolean flags_init;

  /* Used to determine if we are creating an executable.  */
  bfd_boolean executable;
};

#define elf_tdata(bfd)		((bfd) -> tdata.elf_obj_data)
#define elf_elfheader(bfd)	(elf_tdata(bfd) -> elf_header)
#define elf_elfsections(bfd)	(elf_tdata(bfd) -> elf_sect_ptr)
#define elf_numsections(bfd)	(elf_tdata(bfd) -> num_elf_sections)
#define elf_shstrtab(bfd)	(elf_tdata(bfd) -> strtab_ptr)
#define elf_onesymtab(bfd)	(elf_tdata(bfd) -> symtab_section)
#define elf_symtab_shndx(bfd)	(elf_tdata(bfd) -> symtab_shndx_section)
#define elf_dynsymtab(bfd)	(elf_tdata(bfd) -> dynsymtab_section)
#define elf_dynversym(bfd)	(elf_tdata(bfd) -> dynversym_section)
#define elf_dynverdef(bfd)	(elf_tdata(bfd) -> dynverdef_section)
#define elf_dynverref(bfd)	(elf_tdata(bfd) -> dynverref_section)
#define elf_num_locals(bfd)	(elf_tdata(bfd) -> num_locals)
#define elf_num_globals(bfd)	(elf_tdata(bfd) -> num_globals)
#define elf_section_syms(bfd)	(elf_tdata(bfd) -> section_syms)
#define elf_num_section_syms(bfd) (elf_tdata(bfd) -> num_section_syms)
#define core_prpsinfo(bfd)	(elf_tdata(bfd) -> prpsinfo)
#define core_prstatus(bfd)	(elf_tdata(bfd) -> prstatus)
#define elf_gp(bfd)		(elf_tdata(bfd) -> gp)
#define elf_gp_size(bfd)	(elf_tdata(bfd) -> gp_size)
#define elf_sym_hashes(bfd)	(elf_tdata(bfd) -> sym_hashes)
#define elf_local_got_refcounts(bfd) (elf_tdata(bfd) -> local_got.refcounts)
#define elf_local_got_offsets(bfd) (elf_tdata(bfd) -> local_got.offsets)
#define elf_local_got_ents(bfd) (elf_tdata(bfd) -> local_got.ents)
#define elf_dt_name(bfd)	(elf_tdata(bfd) -> dt_name)
#define elf_dyn_lib_class(bfd)	(elf_tdata(bfd) -> dyn_lib_class)
#define elf_bad_symtab(bfd)	(elf_tdata(bfd) -> bad_symtab)
#define elf_flags_init(bfd)	(elf_tdata(bfd) -> flags_init)

extern void _bfd_elf_swap_verdef_in
  (bfd *, const Elf_External_Verdef *, Elf_Internal_Verdef *);
extern void _bfd_elf_swap_verdef_out
  (bfd *, const Elf_Internal_Verdef *, Elf_External_Verdef *);
extern void _bfd_elf_swap_verdaux_in
  (bfd *, const Elf_External_Verdaux *, Elf_Internal_Verdaux *);
extern void _bfd_elf_swap_verdaux_out
  (bfd *, const Elf_Internal_Verdaux *, Elf_External_Verdaux *);
extern void _bfd_elf_swap_verneed_in
  (bfd *, const Elf_External_Verneed *, Elf_Internal_Verneed *);
extern void _bfd_elf_swap_verneed_out
  (bfd *, const Elf_Internal_Verneed *, Elf_External_Verneed *);
extern void _bfd_elf_swap_vernaux_in
  (bfd *, const Elf_External_Vernaux *, Elf_Internal_Vernaux *);
extern void _bfd_elf_swap_vernaux_out
  (bfd *, const Elf_Internal_Vernaux *, Elf_External_Vernaux *);
extern void _bfd_elf_swap_versym_in
  (bfd *, const Elf_External_Versym *, Elf_Internal_Versym *);
extern void _bfd_elf_swap_versym_out
  (bfd *, const Elf_Internal_Versym *, Elf_External_Versym *);

extern int _bfd_elf_section_from_bfd_section
  (bfd *, asection *);
extern char *bfd_elf_string_from_elf_section
  (bfd *, unsigned, unsigned);
extern char *bfd_elf_get_str_section
  (bfd *, unsigned);
extern Elf_Internal_Sym *bfd_elf_get_elf_syms
  (bfd *, Elf_Internal_Shdr *, size_t, size_t, Elf_Internal_Sym *, void *,
   Elf_External_Sym_Shndx *);
extern const char *bfd_elf_local_sym_name
  (bfd *, Elf_Internal_Sym *);

extern bfd_boolean _bfd_elf_copy_private_bfd_data
  (bfd *, bfd *);
extern bfd_boolean _bfd_elf_print_private_bfd_data
  (bfd *, void *);
extern void bfd_elf_print_symbol
  (bfd *, void *, asymbol *, bfd_print_symbol_type);

#define elf_string_from_elf_strtab(abfd, strindex) \
  bfd_elf_string_from_elf_section (abfd, elf_elfheader(abfd)->e_shstrndx, \
				   strindex)

extern void _bfd_elf_sprintf_vma
  (bfd *, char *, bfd_vma);
extern void _bfd_elf_fprintf_vma
  (bfd *, void *, bfd_vma);

extern bfd_byte _bfd_elf_encode_eh_address
  (bfd *abfd, struct bfd_link_info *info, asection *osec, bfd_vma offset,
   asection *loc_sec, bfd_vma loc_offset, bfd_vma *encoded);
extern bfd_boolean _bfd_elf_can_make_relative
  (bfd *input_bfd, struct bfd_link_info *info, asection *eh_frame_section);

extern enum elf_reloc_type_class _bfd_elf_reloc_type_class
  (const Elf_Internal_Rela *);
extern bfd_vma _bfd_elf_rela_local_sym
  (bfd *, Elf_Internal_Sym *, asection **, Elf_Internal_Rela *);
extern bfd_vma _bfd_elf_rel_local_sym
  (bfd *, Elf_Internal_Sym *, asection **, bfd_vma);
extern bfd_vma _bfd_elf_section_offset
  (bfd *, struct bfd_link_info *, asection *, bfd_vma);

extern unsigned long bfd_elf_hash
  (const char *);

extern bfd_reloc_status_type bfd_elf_generic_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
extern bfd_boolean bfd_elf_mkobject
  (bfd *);
extern bfd_boolean bfd_elf_mkcorefile
  (bfd *);
extern Elf_Internal_Shdr *bfd_elf_find_section
  (bfd *, char *);
extern bfd_boolean _bfd_elf_make_section_from_shdr
  (bfd *, Elf_Internal_Shdr *, const char *);
extern bfd_boolean _bfd_elf_make_section_from_phdr
  (bfd *, Elf_Internal_Phdr *, int, const char *);
extern struct bfd_hash_entry *_bfd_elf_link_hash_newfunc
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
extern struct bfd_link_hash_table *_bfd_elf_link_hash_table_create
  (bfd *);
extern void _bfd_elf_link_hash_copy_indirect
  (const struct elf_backend_data *, struct elf_link_hash_entry *,
   struct elf_link_hash_entry *);
extern void _bfd_elf_link_hash_hide_symbol
  (struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean);
extern bfd_boolean _bfd_elf_link_hash_table_init
  (struct elf_link_hash_table *, bfd *,
   struct bfd_hash_entry *(*)
     (struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
extern bfd_boolean _bfd_elf_slurp_version_tables
  (bfd *);
extern bfd_boolean _bfd_elf_merge_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_elf_discard_group
  (bfd *, struct bfd_section *);
extern void bfd_elf_set_group_contents
  (bfd *, asection *, void *);
extern void _bfd_elf_link_just_syms
  (asection *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_copy_private_symbol_data
  (bfd *, asymbol *, bfd *, asymbol *);
extern bfd_boolean _bfd_elf_copy_private_section_data
  (bfd *, asection *, bfd *, asection *);
extern bfd_boolean _bfd_elf_write_object_contents
  (bfd *);
extern bfd_boolean _bfd_elf_write_corefile_contents
  (bfd *);
extern bfd_boolean _bfd_elf_set_section_contents
  (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
extern long _bfd_elf_get_symtab_upper_bound
  (bfd *);
extern long _bfd_elf_canonicalize_symtab
  (bfd *, asymbol **);
extern long _bfd_elf_get_dynamic_symtab_upper_bound
  (bfd *);
extern long _bfd_elf_canonicalize_dynamic_symtab
  (bfd *, asymbol **);
extern long _bfd_elf_get_reloc_upper_bound
  (bfd *, sec_ptr);
extern long _bfd_elf_canonicalize_reloc
  (bfd *, sec_ptr, arelent **, asymbol **);
extern long _bfd_elf_get_dynamic_reloc_upper_bound
  (bfd *);
extern long _bfd_elf_canonicalize_dynamic_reloc
  (bfd *, arelent **, asymbol **);
extern asymbol *_bfd_elf_make_empty_symbol
  (bfd *);
extern void _bfd_elf_get_symbol_info
  (bfd *, asymbol *, symbol_info *);
extern bfd_boolean _bfd_elf_is_local_label_name
  (bfd *, const char *);
extern alent *_bfd_elf_get_lineno
  (bfd *, asymbol *);
extern bfd_boolean _bfd_elf_set_arch_mach
  (bfd *, enum bfd_architecture, unsigned long);
extern bfd_boolean _bfd_elf_find_nearest_line
  (bfd *, asection *, asymbol **, bfd_vma, const char **, const char **,
   unsigned int *);
#define _bfd_elf_read_minisymbols _bfd_generic_read_minisymbols
#define _bfd_elf_minisymbol_to_symbol _bfd_generic_minisymbol_to_symbol
extern int _bfd_elf_sizeof_headers
  (bfd *, bfd_boolean);
extern bfd_boolean _bfd_elf_new_section_hook
  (bfd *, asection *);
extern bfd_boolean _bfd_elf_init_reloc_shdr
  (bfd *, Elf_Internal_Shdr *, asection *, bfd_boolean);
extern const struct bfd_elf_special_section *_bfd_elf_get_sec_type_attr
  (bfd *, const char *);

/* If the target doesn't have reloc handling written yet:  */
extern void _bfd_elf_no_info_to_howto
  (bfd *, arelent *, Elf_Internal_Rela *);

extern bfd_boolean bfd_section_from_shdr
  (bfd *, unsigned int shindex);
extern bfd_boolean bfd_section_from_phdr
  (bfd *, Elf_Internal_Phdr *, int);

extern int _bfd_elf_symbol_from_bfd_symbol
  (bfd *, asymbol **);

extern asection *bfd_section_from_r_symndx
  (bfd *, struct sym_sec_cache *, asection *, unsigned long);
extern asection *bfd_section_from_elf_index
  (bfd *, unsigned int);
extern struct bfd_strtab_hash *_bfd_elf_stringtab_init
  (void);

extern struct elf_strtab_hash * _bfd_elf_strtab_init
  (void);
extern void _bfd_elf_strtab_free
  (struct elf_strtab_hash *);
extern bfd_size_type _bfd_elf_strtab_add
  (struct elf_strtab_hash *, const char *, bfd_boolean);
extern void _bfd_elf_strtab_addref
  (struct elf_strtab_hash *, bfd_size_type);
extern void _bfd_elf_strtab_delref
  (struct elf_strtab_hash *, bfd_size_type);
extern void _bfd_elf_strtab_clear_all_refs
  (struct elf_strtab_hash *);
extern bfd_size_type _bfd_elf_strtab_size
  (struct elf_strtab_hash *);
extern bfd_size_type _bfd_elf_strtab_offset
  (struct elf_strtab_hash *, bfd_size_type);
extern bfd_boolean _bfd_elf_strtab_emit
  (bfd *, struct elf_strtab_hash *);
extern void _bfd_elf_strtab_finalize
  (struct elf_strtab_hash *);

extern bfd_boolean _bfd_elf_discard_section_eh_frame
  (bfd *, struct bfd_link_info *, asection *,
   bfd_boolean (*) (bfd_vma, void *), struct elf_reloc_cookie *);
extern bfd_boolean _bfd_elf_discard_section_eh_frame_hdr
  (bfd *, struct bfd_link_info *);
extern bfd_vma _bfd_elf_eh_frame_section_offset
  (bfd *, asection *, bfd_vma);
extern bfd_boolean _bfd_elf_write_section_eh_frame
  (bfd *, struct bfd_link_info *, asection *, bfd_byte *);
extern bfd_boolean _bfd_elf_write_section_eh_frame_hdr
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_maybe_strip_eh_frame_hdr
  (struct bfd_link_info *);

extern bfd_boolean _bfd_elf_merge_symbol
  (bfd *, struct bfd_link_info *, const char *, Elf_Internal_Sym *,
   asection **, bfd_vma *, struct elf_link_hash_entry **, bfd_boolean *,
   bfd_boolean *, bfd_boolean *, bfd_boolean *);

extern bfd_boolean _bfd_elf_add_default_symbol
  (bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
   const char *, Elf_Internal_Sym *, asection **, bfd_vma *,
   bfd_boolean *, bfd_boolean);

extern bfd_boolean _bfd_elf_export_symbol
  (struct elf_link_hash_entry *, void *);

extern bfd_boolean _bfd_elf_link_find_version_dependencies
  (struct elf_link_hash_entry *, void *);

extern bfd_boolean _bfd_elf_link_assign_sym_version
  (struct elf_link_hash_entry *, void *);

extern long _bfd_elf_link_lookup_local_dynindx
  (struct bfd_link_info *, bfd *, long);
extern bfd_boolean _bfd_elf_compute_section_file_positions
  (bfd *, struct bfd_link_info *);
extern void _bfd_elf_assign_file_positions_for_relocs
  (bfd *);
extern file_ptr _bfd_elf_assign_file_position_for_section
  (Elf_Internal_Shdr *, file_ptr, bfd_boolean);

extern bfd_boolean _bfd_elf_validate_reloc
  (bfd *, arelent *);

extern bfd_boolean _bfd_elf_link_create_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_create_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_create_got_section
  (bfd *, struct bfd_link_info *);
extern unsigned long _bfd_elf_link_renumber_dynsyms
  (bfd *, struct bfd_link_info *);

extern bfd_boolean _bfd_elfcore_make_pseudosection
  (bfd *, char *, size_t, ufile_ptr);
extern char *_bfd_elfcore_strndup
  (bfd *, char *, size_t);

extern Elf_Internal_Rela *_bfd_elf_link_read_relocs
  (bfd *, asection *, void *, Elf_Internal_Rela *, bfd_boolean);

extern bfd_boolean _bfd_elf_link_size_reloc_section
  (bfd *, Elf_Internal_Shdr *, asection *);

extern bfd_boolean _bfd_elf_link_output_relocs
  (bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *);

extern bfd_boolean _bfd_elf_fix_symbol_flags
  (struct elf_link_hash_entry *, struct elf_info_failed *);

extern bfd_boolean _bfd_elf_adjust_dynamic_symbol
  (struct elf_link_hash_entry *, void *);

extern bfd_boolean _bfd_elf_link_sec_merge_syms
  (struct elf_link_hash_entry *, void *);

extern bfd_boolean _bfd_elf_dynamic_symbol_p
  (struct elf_link_hash_entry *, struct bfd_link_info *, bfd_boolean);

extern bfd_boolean _bfd_elf_symbol_refs_local_p
  (struct elf_link_hash_entry *, struct bfd_link_info *, bfd_boolean);

extern const bfd_target *bfd_elf32_object_p
  (bfd *);
extern const bfd_target *bfd_elf32_core_file_p
  (bfd *);
extern char *bfd_elf32_core_file_failing_command
  (bfd *);
extern int bfd_elf32_core_file_failing_signal
  (bfd *);
extern bfd_boolean bfd_elf32_core_file_matches_executable_p
  (bfd *, bfd *);

extern void bfd_elf32_swap_symbol_in
  (bfd *, const void *, const void *, Elf_Internal_Sym *);
extern void bfd_elf32_swap_symbol_out
  (bfd *, const Elf_Internal_Sym *, void *, void *);
extern void bfd_elf32_swap_reloc_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
extern void bfd_elf32_swap_reloc_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
extern void bfd_elf32_swap_reloca_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
extern void bfd_elf32_swap_reloca_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
extern void bfd_elf32_swap_phdr_in
  (bfd *, const Elf32_External_Phdr *, Elf_Internal_Phdr *);
extern void bfd_elf32_swap_phdr_out
  (bfd *, const Elf_Internal_Phdr *, Elf32_External_Phdr *);
extern void bfd_elf32_swap_dyn_in
  (bfd *, const void *, Elf_Internal_Dyn *);
extern void bfd_elf32_swap_dyn_out
  (bfd *, const Elf_Internal_Dyn *, void *);
extern long bfd_elf32_slurp_symbol_table
  (bfd *, asymbol **, bfd_boolean);
extern bfd_boolean bfd_elf32_write_shdrs_and_ehdr
  (bfd *);
extern int bfd_elf32_write_out_phdrs
  (bfd *, const Elf_Internal_Phdr *, unsigned int);
extern void bfd_elf32_write_relocs
  (bfd *, asection *, void *);
extern bfd_boolean bfd_elf32_slurp_reloc_table
  (bfd *, asection *, asymbol **, bfd_boolean);

extern const bfd_target *bfd_elf64_object_p
  (bfd *);
extern const bfd_target *bfd_elf64_core_file_p
  (bfd *);
extern char *bfd_elf64_core_file_failing_command
  (bfd *);
extern int bfd_elf64_core_file_failing_signal
  (bfd *);
extern bfd_boolean bfd_elf64_core_file_matches_executable_p
  (bfd *, bfd *);

extern void bfd_elf64_swap_symbol_in
  (bfd *, const void *, const void *, Elf_Internal_Sym *);
extern void bfd_elf64_swap_symbol_out
  (bfd *, const Elf_Internal_Sym *, void *, void *);
extern void bfd_elf64_swap_reloc_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
extern void bfd_elf64_swap_reloc_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
extern void bfd_elf64_swap_reloca_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
extern void bfd_elf64_swap_reloca_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
extern void bfd_elf64_swap_phdr_in
  (bfd *, const Elf64_External_Phdr *, Elf_Internal_Phdr *);
extern void bfd_elf64_swap_phdr_out
  (bfd *, const Elf_Internal_Phdr *, Elf64_External_Phdr *);
extern void bfd_elf64_swap_dyn_in
  (bfd *, const void *, Elf_Internal_Dyn *);
extern void bfd_elf64_swap_dyn_out
  (bfd *, const Elf_Internal_Dyn *, void *);
extern long bfd_elf64_slurp_symbol_table
  (bfd *, asymbol **, bfd_boolean);
extern bfd_boolean bfd_elf64_write_shdrs_and_ehdr
  (bfd *);
extern int bfd_elf64_write_out_phdrs
  (bfd *, const Elf_Internal_Phdr *, unsigned int);
extern void bfd_elf64_write_relocs
  (bfd *, asection *, void *);
extern bfd_boolean bfd_elf64_slurp_reloc_table
  (bfd *, asection *, asymbol **, bfd_boolean);

extern bfd_boolean bfd_elf_link_add_symbols
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_add_dynamic_entry
  (struct bfd_link_info *, bfd_vma, bfd_vma);

extern bfd_boolean bfd_elf_link_record_dynamic_symbol
  (struct bfd_link_info *, struct elf_link_hash_entry *);

extern int bfd_elf_link_record_local_dynamic_symbol
  (struct bfd_link_info *, bfd *, long);

extern bfd_boolean _bfd_elf_close_and_cleanup
  (bfd *);
extern bfd_reloc_status_type _bfd_elf_rel_vtable_reloc_fn
  (bfd *, arelent *, struct bfd_symbol *, void *,
   asection *, bfd *, char **);

extern bfd_boolean bfd_elf_final_link
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf_gc_sections
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf_gc_record_vtinherit
  (bfd *, asection *, struct elf_link_hash_entry *, bfd_vma);

extern bfd_boolean bfd_elf_gc_record_vtentry
  (bfd *, asection *, struct elf_link_hash_entry *, bfd_vma);

extern bfd_boolean bfd_elf_gc_common_finalize_got_offsets
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf_gc_common_final_link
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf_reloc_symbol_deleted_p
  (bfd_vma, void *);

/* Exported interface for writing elf corefile notes. */
extern char *elfcore_write_note
  (bfd *, char *, int *, const char *, int, const void *, int);
extern char *elfcore_write_prpsinfo
  (bfd *, char *, int *, const char *, const char *);
extern char *elfcore_write_prstatus
  (bfd *, char *, int *, long, int, const void *);
extern char * elfcore_write_pstatus
  (bfd *, char *, int *, long, int, const void *);
extern char *elfcore_write_prfpreg
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_prxfpreg
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_lwpstatus
  (bfd *, char *, int *, long, int, const void *);

extern bfd *_bfd_elf32_bfd_from_remote_memory
  (bfd *templ, bfd_vma ehdr_vma, bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, char *, int));
extern bfd *_bfd_elf64_bfd_from_remote_memory
  (bfd *templ, bfd_vma ehdr_vma, bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, char *, int));

/* SH ELF specific routine.  */

extern bfd_boolean _sh_elf_set_mach_from_flags
  (bfd *);

/* This is the condition under which finish_dynamic_symbol will be called.
   If our finish_dynamic_symbol isn't called, we'll need to do something
   about initializing any .plt and .got entries in relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
  ((DYN)								\
   && ((SHARED)								\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

/* This macro is to avoid lots of duplicated code in the body
   of xxx_relocate_section() in the various elfxx-xxxx.c files.  */
#define RELOC_FOR_GLOBAL_SYMBOL(info, input_bfd, input_section, rel,	\
				r_symndx, symtab_hdr, sym_hashes,	\
				h, sec, relocation,			\
				unresolved_reloc, warned)		\
  do									\
    {									\
      /* It seems this can happen with erroneous or unsupported		\
	 input (mixing a.out and elf in an archive, for example.)  */	\
      if (sym_hashes == NULL)						\
	return FALSE;							\
									\
      h = sym_hashes[r_symndx - symtab_hdr->sh_info];			\
									\
      while (h->root.type == bfd_link_hash_indirect			\
	     || h->root.type == bfd_link_hash_warning)			\
	h = (struct elf_link_hash_entry *) h->root.u.i.link;		\
									\
      warned = FALSE;							\
      unresolved_reloc = FALSE;						\
      relocation = 0;							\
      if (h->root.type == bfd_link_hash_defined				\
	  || h->root.type == bfd_link_hash_defweak)			\
	{								\
	  sec = h->root.u.def.section;					\
	  if (sec == NULL						\
	      || sec->output_section == NULL)				\
	    /* Set a flag that will be cleared later if we find a	\
	       relocation value for this symbol.  output_section	\
	       is typically NULL for symbols satisfied by a shared	\
	       library.  */						\
	    unresolved_reloc = TRUE;					\
	  else								\
	    relocation = (h->root.u.def.value				\
			  + sec->output_section->vma			\
			  + sec->output_offset);			\
	}								\
      else if (h->root.type == bfd_link_hash_undefweak)			\
	;								\
      else if (info->unresolved_syms_in_objects == RM_IGNORE		\
	       && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)		\
	;								\
      else								\
	{								\
	  bfd_boolean err;						\
	  err = (info->unresolved_syms_in_objects == RM_GENERATE_ERROR	\
		 || ELF_ST_VISIBILITY (h->other) != STV_DEFAULT);	\
	  if (!info->callbacks->undefined_symbol (info,			\
						  h->root.root.string,	\
						  input_bfd,		\
						  input_section,	\
						  rel->r_offset, err))	\
	    return FALSE;						\
	  warned = TRUE;						\
	}								\
    }									\
  while (0)

#endif /* _LIBELF_H_ */
@


1.10
log
@Revert the previous commit. It breaks the xenocara build on macppc and the
issue it fixes will be fixed anyway once the move to binutils-2.17 happens.
xenocara breakage discovered by matthieu@@
@
text
@d1238 3
@


1.9
log
@Fix linker errors when using llvm/clang.
See http://lists.gnu.org/archive/html/bug-binutils/2004-07/msg00000.html for a description of the error.
Fix taken from the binutils 2.16 timeframe (GPLv2)

"Then go for it." miod@@
@
text
@d1058 2
a1059 2
   && (sec)->sec_info_type != ELF_INFO_TYPE_MERGE			\
   && (sec)->sec_info_type != ELF_INFO_TYPE_JUST_SYMS)
@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d1058 2
a1059 2
   && sec->sec_info_type != ELF_INFO_TYPE_MERGE			\
   && sec->sec_info_type != ELF_INFO_TYPE_JUST_SYMS)
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2002, 2003 Free Software Foundation, Inc.
a35 3
/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
d37 2
a38 2
#if ARCH_SIZE==64
#define NAME(x,y) CONCAT4 (x,64,_,y)
d40 2
a41 2
#if ARCH_SIZE==32
#define NAME(x,y) CONCAT4 (x,32,_,y)
d46 1
a46 1
#define NAME(x,y) CONCAT4 (x,NOSIZE,_,y)
d67 2
a68 2
      PTR mips_extr;
      PTR any;
a117 5
  /* If this symbol is used in the linker created sections, the processor
     specific backend uses this field to map the field into the offset
     from the beginning of the section.  */
  struct elf_linker_section_pointers *linker_section_pointer;

d203 3
d208 13
a314 8
/* Cached start, size and alignment of PT_TLS segment.  */
struct elf_link_tls_segment
{
  bfd_vma start;
  bfd_size_type size;
  unsigned int align;
};

d360 1
a360 1
  PTR stab_info;
d363 1
a363 1
  PTR merge_info;
d375 3
a377 2
  /* Cached start, size and alignment of PT_TLS segment.  */
  struct elf_link_tls_segment *tls_segment;
d395 1
a395 1
    (bfd_boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func), \
d403 2
a404 2
#define is_elf_hash_table(p)					      	\
  ((p)->hash->type == bfd_link_elf_hash_table)
d432 1
a432 1
  unsigned char arch_size, file_align;
d435 3
a437 3
    PARAMS ((bfd *, const Elf_Internal_Phdr *, unsigned int));
  bfd_boolean (*write_shdrs_and_ehdr)
    PARAMS ((bfd *));
d439 1
a439 1
    PARAMS ((bfd *, asection *, PTR));
d441 1
a441 1
    PARAMS ((bfd *, const PTR, const PTR, Elf_Internal_Sym *));
d443 1
a443 1
    PARAMS ((bfd *, const Elf_Internal_Sym *, PTR, PTR));
d445 1
a445 1
    PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
d447 1
a447 1
    PARAMS ((bfd *, asymbol **, bfd_boolean));
d449 1
a449 1
    PARAMS ((bfd *, const PTR, Elf_Internal_Dyn *));
d451 1
a451 1
    PARAMS ((bfd *, const Elf_Internal_Dyn *, PTR));
d457 1
a457 1
    PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
d461 1
a461 1
    PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d467 1
a467 1
    PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
d471 1
a471 1
    PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d495 1
d507 16
d537 1
a537 1
    PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d542 1
a542 1
    PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d550 1
a550 1
    PARAMS ((bfd *, asymbol *));
d562 1
a562 1
    PARAMS ((bfd *));
d568 1
a568 1
    PARAMS ((bfd *, asymbol *));
d573 1
a573 1
    PARAMS ((bfd *, elf_symbol_type *, unsigned int));
d578 6
a583 1
    PARAMS (( Elf_Internal_Sym *, int));
d590 1
a590 1
    PARAMS ((bfd *, Elf_Internal_Shdr *));
d595 1
a595 1
    PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
d600 1
a600 1
    PARAMS ((flagword *, Elf_Internal_Shdr *));
d605 1
a605 1
    PARAMS ((bfd *, Elf_Internal_Phdr *, int));
d611 1
a611 1
    PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
d618 1
a618 1
    PARAMS ((bfd *, asection *, int *retval));
d629 2
a630 3
    PARAMS ((bfd *abfd, struct bfd_link_info *info,
	     const Elf_Internal_Sym *, const char **name,
	     flagword *flags, asection **sec, bfd_vma *value));
d635 2
a636 2
    PARAMS ((bfd *, struct bfd_link_info *info, const char *,
	     Elf_Internal_Sym *, asection *));
d647 1
a647 1
    PARAMS ((bfd *abfd, struct bfd_link_info *info));
d660 2
a661 2
    PARAMS ((bfd *abfd, struct bfd_link_info *info, asection *o,
	     const Elf_Internal_Rela *relocs));
d676 1
a676 1
    PARAMS ((struct bfd_link_info *info, struct elf_link_hash_entry *h));
d683 1
a683 1
    PARAMS ((bfd *output_bfd, struct bfd_link_info *info));
d696 1
a696 1
    PARAMS ((bfd *output_bfd, struct bfd_link_info *info));
d707 1
a707 1
     relocateable output file) adjusting the reloc addend as
d721 1
a721 1
     When generating relocateable output, this function must handle
d727 3
a729 4
    PARAMS ((bfd *output_bfd, struct bfd_link_info *info,
	     bfd *input_bfd, asection *input_section, bfd_byte *contents,
	     Elf_Internal_Rela *relocs, Elf_Internal_Sym *local_syms,
	     asection **local_sections));
d739 2
a740 2
    PARAMS ((bfd *output_bfd, struct bfd_link_info *info,
	     struct elf_link_hash_entry *h, Elf_Internal_Sym *sym));
d747 1
a747 1
    PARAMS ((bfd *output_bfd, struct bfd_link_info *info));
d752 1
a752 1
    PARAMS ((bfd *, struct bfd_link_info *));
d758 1
a758 1
    PARAMS ((bfd *, bfd_boolean linker));
d764 1
a764 1
    PARAMS ((bfd *));
d769 1
a769 1
    PARAMS ((bfd *));
d774 2
a775 2
    PARAMS ((asection *sec, struct bfd_link_info *, Elf_Internal_Rela *,
	     struct elf_link_hash_entry *h, Elf_Internal_Sym *));
d781 2
a782 2
    PARAMS ((bfd *abfd, struct bfd_link_info *info, asection *o,
	     const Elf_Internal_Rela *relocs));
d788 1
a788 1
    PARAMS ((bfd *, struct bfd_link_info *));
d794 1
a794 1
    PARAMS ((bfd *, PTR, asymbol *));
d797 1
a797 1
     global symbols converted to locals are emited into the symtab
d801 3
a803 2
    PARAMS ((bfd *, struct bfd_link_info *, PTR,
	    bfd_boolean (*) (PTR, const char *, Elf_Internal_Sym *, asection *)));
d811 2
a812 2
    PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	     struct elf_link_hash_entry *));
d817 6
a822 1
    PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean));
d827 1
a827 1
    PARAMS ((bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *));
d832 1
a832 1
    PARAMS ((asection *, Elf_Internal_Rela *));
d837 1
a837 1
    PARAMS ((bfd *, Elf_Internal_Note *));
d842 1
a842 1
    PARAMS ((bfd *, Elf_Internal_Note *));
d846 1
a846 1
    PARAMS ((bfd *, char *, bfd_vma));
d848 1
a848 1
    PARAMS ((bfd *, PTR, bfd_vma));
d852 1
a852 1
    PARAMS ((const Elf_Internal_Rela *));
d857 1
a857 1
    PARAMS ((bfd *, struct elf_reloc_cookie *, struct bfd_link_info *));
d862 19
a880 1
    PARAMS ((asection *));
d885 1
a885 1
    PARAMS ((bfd *, asection *, bfd_byte *));
d890 1
a890 1
    PARAMS ((bfd *));
d893 1
a893 1
    PARAMS ((unsigned int, bfd_boolean));
d899 6
d911 3
d918 2
a919 2
  /* The size in bytes of the headers for the GOT and PLT.  This includes
     the so-called reserved entries on some systems.  */
a920 1
  bfd_vma plt_header_size;
d1026 1
a1026 1
  PTR local_dynrel;
d1036 1
a1036 1
    struct symbol_cache_entry *id;
d1044 1
a1044 1
  PTR sec_info;
d1048 2
d1062 1
a1062 1
  ((struct elf_backend_data *) (abfd)->xvec->backend_data)
d1064 4
a1067 2
/* Enumeration to specify the special section.  */
typedef enum elf_linker_section_enum
d1069 4
a1072 7
  LINKER_SECTION_UNKNOWN,		/* not used */
  LINKER_SECTION_GOT,			/* .got section for global offset pointers */
  LINKER_SECTION_PLT,			/* .plt section for generated procedure stubs */
  LINKER_SECTION_SDATA,			/* .sdata/.sbss section for PowerPC */
  LINKER_SECTION_SDATA2,		/* .sdata2/.sbss2 section for PowerPC */
  LINKER_SECTION_MAX			/* # of linker sections */
} elf_linker_section_enum_t;
d1074 2
a1075 1
/* Sections created by the linker.  */
d1077 1
a1077 1
typedef struct elf_linker_section
d1079 9
a1087 18
  char *name;				/* name of the section */
  char *rel_name;			/* name of the associated .rel{,a}. section */
  char *bss_name;			/* name of a related .bss section */
  char *sym_name;			/* name of symbol to reference this section */
  asection *section;			/* pointer to the section */
  asection *bss_section;		/* pointer to the bss section associated with this */
  asection *rel_section;		/* pointer to the relocations needed for this section */
  struct elf_link_hash_entry *sym_hash;	/* pointer to the created symbol hash value */
  bfd_vma initial_size;			/* initial size before any linker generated allocations */
  bfd_vma sym_offset;			/* offset of symbol from beginning of section */
  bfd_vma hole_size;			/* size of reserved address hole in allocation */
  bfd_vma hole_offset;			/* current offset for the hole */
  bfd_vma max_hole_offset;		/* maximum offset for the hole */
  elf_linker_section_enum_t which;	/* which section this is */
  bfd_boolean hole_written_p;		/* whether the hole has been initialized */
  unsigned int alignment;		/* alignment for the section */
  flagword flags;			/* flags to use to create the section */
} elf_linker_section_t;
d1089 2
a1090 2
/* Linked list of allocated pointer entries.  This hangs off of the symbol lists, and
   provides allows us to return different pointers, based on different addend's.  */
d1092 1
a1092 1
typedef struct elf_linker_section_pointers
d1094 9
a1102 6
  struct elf_linker_section_pointers *next;	/* next allocated pointer for this symbol */
  bfd_vma offset;				/* offset of pointer from beginning of section */
  bfd_vma addend;				/* addend used */
  elf_linker_section_enum_t which;		/* which linker section this is */
  bfd_boolean written_address_p;		/* whether address was written yet */
} elf_linker_section_pointers_t;
a1132 6
#if 0
  /* we don't need these inside bfd anymore, and I think
     these weren't used outside bfd.  */
  void *prstatus;			/* The raw /proc prstatus structure */
  void *prpsinfo;			/* The raw /proc prpsinfo structure */
#endif
a1135 3
  Elf_Internal_Shdr **group_sect_ptr;
  int num_group;

a1142 4
  /* This is set to TRUE if the object was created by the backend
     linker.  */
  bfd_boolean linker;

a1157 4
  /* A mapping from local symbols to offsets into the various linker
     sections added.  This is index by the symbol index.  */
  elf_linker_section_pointers_t **linker_section_pointers;

a1167 15
  /* When a reference in a regular object is resolved by a shared
     object is loaded into via the DT_NEEDED entries by the linker
     ELF emulation code, we need to add the shared object to the
     DT_NEEDED list of the resulting binary to indicate the dependency
     as if the -l option is passed to the linker. This field holds the
     name of the loaded shared object.  */
  const char *dt_soname;

  /* Irix 5 often screws up the symbol table, sorting local symbols
     after global symbols.  This flag is set if the symbol table in
     this BFD appears to be screwed up.  If it is, we ignore the
     sh_info field in the symbol table header, and always read all the
     symbols.  */
  bfd_boolean bad_symtab;

d1172 1
a1172 1
  PTR line_info;
d1184 1
a1184 1
  PTR dwarf2_find_line_info;
d1195 2
a1196 2
  /* Used to determine if the e_flags field has been initialized */
  bfd_boolean flags_init;
d1204 3
a1212 3
  /* Linker sections that we are interested in.  */
  struct elf_linker_section *linker_section[ (int)LINKER_SECTION_MAX ];

d1219 19
a1262 1
#define elf_local_ptr_offsets(bfd) (elf_tdata(bfd) -> linker_section_pointers)
d1264 1
a1264 1
#define elf_dt_soname(bfd)	(elf_tdata(bfd) -> dt_soname)
a1266 1
#define elf_linker_section(bfd,n) (elf_tdata(bfd) -> linker_section[(int)n])
d1269 1
a1269 1
  PARAMS ((bfd *, const Elf_External_Verdef *, Elf_Internal_Verdef *));
d1271 1
a1271 1
  PARAMS ((bfd *, const Elf_Internal_Verdef *, Elf_External_Verdef *));
d1273 1
a1273 1
  PARAMS ((bfd *, const Elf_External_Verdaux *, Elf_Internal_Verdaux *));
d1275 1
a1275 1
  PARAMS ((bfd *, const Elf_Internal_Verdaux *, Elf_External_Verdaux *));
d1277 1
a1277 1
  PARAMS ((bfd *, const Elf_External_Verneed *, Elf_Internal_Verneed *));
d1279 1
a1279 1
  PARAMS ((bfd *, const Elf_Internal_Verneed *, Elf_External_Verneed *));
d1281 1
a1281 1
  PARAMS ((bfd *, const Elf_External_Vernaux *, Elf_Internal_Vernaux *));
d1283 1
a1283 1
  PARAMS ((bfd *, const Elf_Internal_Vernaux *, Elf_External_Vernaux *));
d1285 1
a1285 1
  PARAMS ((bfd *, const Elf_External_Versym *, Elf_Internal_Versym *));
d1287 1
a1287 1
  PARAMS ((bfd *, const Elf_Internal_Versym *, Elf_External_Versym *));
d1290 1
a1290 1
  PARAMS ((bfd *, asection *));
d1292 1
a1292 1
  PARAMS ((bfd *, unsigned, unsigned));
d1294 1
a1294 1
  PARAMS ((bfd *, unsigned));
d1296 2
a1297 2
  PARAMS ((bfd *, Elf_Internal_Shdr *, size_t, size_t,
	   Elf_Internal_Sym *, PTR, Elf_External_Sym_Shndx *));
d1299 1
a1299 1
  PARAMS ((bfd *, Elf_Internal_Sym *));
d1302 1
a1302 1
  PARAMS ((bfd *, bfd *));
d1304 1
a1304 1
  PARAMS ((bfd *, PTR));
d1306 1
a1306 1
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
d1309 2
a1310 5
  bfd_elf_string_from_elf_section(abfd, elf_elfheader(abfd)->e_shstrndx, \
				  strindex)

#define bfd_elf32_print_symbol	bfd_elf_print_symbol
#define bfd_elf64_print_symbol	bfd_elf_print_symbol
d1313 1
a1313 1
  PARAMS ((bfd *, char *, bfd_vma));
d1315 7
a1321 1
  PARAMS ((bfd *, PTR, bfd_vma));
d1324 1
a1324 1
  PARAMS ((const Elf_Internal_Rela *));
d1326 1
a1326 1
  PARAMS ((bfd *, Elf_Internal_Sym *, asection *, Elf_Internal_Rela *));
d1328 1
a1328 1
  PARAMS ((bfd *, Elf_Internal_Sym *, asection **, bfd_vma));
d1330 1
a1330 1
  PARAMS ((bfd *, struct bfd_link_info *, asection *, bfd_vma));
d1333 1
a1333 1
  PARAMS ((const char *));
d1336 1
a1336 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d1338 1
a1338 1
  PARAMS ((bfd *));
d1340 1
a1340 1
  PARAMS ((bfd *));
d1342 1
a1342 1
  PARAMS ((bfd *, char *));
d1344 1
a1344 1
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
d1346 1
a1346 1
  PARAMS ((bfd *, Elf_Internal_Phdr *, int, const char *));
d1348 1
a1348 1
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d1350 1
a1350 1
  PARAMS ((bfd *));
d1352 2
a1353 2
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
d1355 1
a1355 1
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean));
d1357 3
a1359 4
  PARAMS ((struct elf_link_hash_table *, bfd *,
	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
				       struct bfd_hash_table *,
				       const char *)));
d1361 1
a1361 1
  PARAMS ((bfd *));
d1363 1
a1363 1
  PARAMS ((bfd *, struct bfd_link_info *));
d1365 1
a1365 1
  PARAMS ((bfd *, struct sec *));
d1367 1
a1367 1
  PARAMS ((bfd *, asection *, PTR));
d1369 1
a1369 1
  PARAMS ((asection *, struct bfd_link_info *));
d1371 1
a1371 1
  PARAMS ((bfd *, asymbol *, bfd *, asymbol *));
d1373 1
a1373 1
  PARAMS ((bfd *, asection *, bfd *, asection *));
d1375 1
a1375 1
  PARAMS ((bfd *));
d1377 1
a1377 1
  PARAMS ((bfd *));
d1379 1
a1379 1
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
d1381 3
a1383 3
  PARAMS ((bfd *));
extern long _bfd_elf_get_symtab
  PARAMS ((bfd *, asymbol **));
d1385 1
a1385 1
  PARAMS ((bfd *));
d1387 1
a1387 1
  PARAMS ((bfd *, asymbol **));
d1389 1
a1389 1
  PARAMS ((bfd *, sec_ptr));
d1391 1
a1391 1
  PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));
d1393 1
a1393 1
  PARAMS ((bfd *));
d1395 1
a1395 1
  PARAMS ((bfd *, arelent **, asymbol **));
d1397 1
a1397 1
  PARAMS ((bfd *));
d1399 1
a1399 1
  PARAMS ((bfd *, asymbol *, symbol_info *));
d1401 1
a1401 1
  PARAMS ((bfd *, const char *));
d1403 1
a1403 1
  PARAMS ((bfd *, asymbol *));
d1405 1
a1405 1
  PARAMS ((bfd *, enum bfd_architecture, unsigned long));
d1407 2
a1408 2
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
d1412 1
a1412 1
  PARAMS ((bfd *, bfd_boolean));
d1414 1
a1414 1
  PARAMS ((bfd *, asection *));
d1416 3
a1418 1
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *, bfd_boolean));
d1422 1
a1422 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d1425 1
a1425 1
  PARAMS ((bfd *, unsigned int shindex));
d1427 1
a1427 1
  PARAMS ((bfd *, Elf_Internal_Phdr *, int));
d1430 1
a1430 1
  PARAMS ((bfd *, asymbol **));
d1433 1
a1433 1
  PARAMS ((bfd *, struct sym_sec_cache *, asection *, unsigned long));
d1435 1
a1435 3
  PARAMS ((bfd *, unsigned int));
extern bfd_boolean _bfd_elf_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
d1437 1
a1437 1
  PARAMS ((void));
d1440 1
a1440 1
  PARAMS ((void));
d1442 1
a1442 1
  PARAMS ((struct elf_strtab_hash *));
d1444 1
a1444 1
  PARAMS ((struct elf_strtab_hash *, const char *, bfd_boolean));
d1446 1
a1446 1
  PARAMS ((struct elf_strtab_hash *, bfd_size_type));
d1448 1
a1448 1
  PARAMS ((struct elf_strtab_hash *, bfd_size_type));
d1450 1
a1450 1
  PARAMS ((struct elf_strtab_hash *));
d1452 1
a1452 1
  PARAMS ((struct elf_strtab_hash *));
d1454 1
a1454 1
  PARAMS ((struct elf_strtab_hash *, bfd_size_type));
d1456 1
a1456 1
  PARAMS ((bfd *, struct elf_strtab_hash *));
d1458 1
a1458 1
  PARAMS ((struct elf_strtab_hash *));
d1461 2
a1462 2
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   bfd_boolean (*) (bfd_vma, PTR), struct elf_reloc_cookie *));
d1464 1
a1464 1
  PARAMS ((bfd *, struct bfd_link_info *));
d1466 1
a1466 1
  PARAMS ((bfd *, asection *, bfd_vma));
d1468 1
a1468 1
  PARAMS ((bfd *, struct bfd_link_info *, asection *, bfd_byte *));
d1470 1
a1470 1
  PARAMS ((bfd *, struct bfd_link_info *));
d1472 20
a1491 1
  PARAMS ((struct bfd_link_info *));
a1492 2
extern bfd_boolean _bfd_elf_link_record_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
d1494 1
a1494 1
  PARAMS ((struct bfd_link_info *, bfd *, long));
d1496 1
a1496 1
  PARAMS ((bfd *, struct bfd_link_info *));
d1498 1
a1498 1
  PARAMS ((bfd *));
d1500 1
a1500 1
  PARAMS ((Elf_Internal_Shdr *, file_ptr, bfd_boolean));
d1503 1
a1503 1
  PARAMS ((bfd *, arelent *));
d1505 2
d1508 1
a1508 1
  PARAMS ((bfd *, struct bfd_link_info *));
d1510 1
a1510 1
  PARAMS ((bfd *, struct bfd_link_info *));
d1512 1
a1512 1
  PARAMS ((bfd *, struct bfd_link_info *));
d1515 1
a1515 1
  PARAMS ((bfd *, char *, size_t, ufile_ptr));
d1517 10
a1526 1
  PARAMS ((bfd *, char *, size_t));
d1528 2
a1529 25
extern elf_linker_section_t *_bfd_elf_create_linker_section
  PARAMS ((bfd *, struct bfd_link_info *, enum elf_linker_section_enum,
	   elf_linker_section_t *));

extern elf_linker_section_pointers_t *_bfd_elf_find_pointer_linker_section
  PARAMS ((elf_linker_section_pointers_t *, bfd_vma,
	   elf_linker_section_enum_t));

extern bfd_boolean bfd_elf32_create_pointer_linker_section
  PARAMS ((bfd *, struct bfd_link_info *, elf_linker_section_t *,
	   struct elf_link_hash_entry *, const Elf_Internal_Rela *));

extern bfd_vma bfd_elf32_finish_pointer_linker_section
  PARAMS ((bfd *, bfd *, struct bfd_link_info *, elf_linker_section_t *,
	   struct elf_link_hash_entry *, bfd_vma,
	   const Elf_Internal_Rela *, int));

extern bfd_boolean bfd_elf64_create_pointer_linker_section
  PARAMS ((bfd *, struct bfd_link_info *, elf_linker_section_t *,
	   struct elf_link_hash_entry *, const Elf_Internal_Rela *));

extern bfd_vma bfd_elf64_finish_pointer_linker_section
  PARAMS ((bfd *, bfd *, struct bfd_link_info *, elf_linker_section_t *,
	   struct elf_link_hash_entry *, bfd_vma,
	   const Elf_Internal_Rela *, int));
d1531 11
a1541 2
extern bfd_boolean _bfd_elf_make_linker_section_rela
  PARAMS ((bfd *, elf_linker_section_t *, int));
d1544 1
a1544 1
  PARAMS ((bfd *));
d1546 1
a1546 1
  PARAMS ((bfd *));
d1548 1
a1548 1
  PARAMS ((bfd *));
d1550 1
a1550 1
  PARAMS ((bfd *));
d1552 1
a1552 6
  PARAMS ((bfd *, bfd *));

extern bfd_boolean bfd_elf32_bfd_link_add_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
extern bfd_boolean bfd_elf32_bfd_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
d1555 1
a1555 1
  PARAMS ((bfd *, const PTR, const PTR, Elf_Internal_Sym *));
d1557 1
a1557 1
  PARAMS ((bfd *, const Elf_Internal_Sym *, PTR, PTR));
d1559 1
a1559 1
  PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
d1561 1
a1561 1
  PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d1563 1
a1563 1
  PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
d1565 1
a1565 1
  PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d1567 1
a1567 1
  PARAMS ((bfd *, const Elf32_External_Phdr *, Elf_Internal_Phdr *));
d1569 1
a1569 1
  PARAMS ((bfd *, const Elf_Internal_Phdr *, Elf32_External_Phdr *));
d1571 1
a1571 1
  PARAMS ((bfd *, const PTR, Elf_Internal_Dyn *));
d1573 1
a1573 1
  PARAMS ((bfd *, const Elf_Internal_Dyn *, PTR));
d1575 1
a1575 1
  PARAMS ((bfd *, asymbol **, bfd_boolean));
d1577 1
a1577 1
  PARAMS ((bfd *));
d1579 1
a1579 1
  PARAMS ((bfd *, const Elf_Internal_Phdr *, unsigned int));
d1581 1
a1581 1
  PARAMS ((bfd *, asection *, PTR));
d1583 1
a1583 7
  PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
extern bfd_boolean bfd_elf32_add_dynamic_entry
  PARAMS ((struct bfd_link_info *, bfd_vma, bfd_vma));
extern bfd_boolean bfd_elf32_link_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
extern Elf_Internal_Rela *_bfd_elf32_link_read_relocs
  PARAMS ((bfd *, asection *, PTR, Elf_Internal_Rela *, bfd_boolean));
d1586 1
a1586 1
  PARAMS ((bfd *));
d1588 1
a1588 1
  PARAMS ((bfd *));
d1590 1
a1590 1
  PARAMS ((bfd *));
d1592 1
a1592 1
  PARAMS ((bfd *));
d1594 1
a1594 5
  PARAMS ((bfd *, bfd *));
extern bfd_boolean bfd_elf64_bfd_link_add_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
extern bfd_boolean bfd_elf64_bfd_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
d1597 1
a1597 1
  PARAMS ((bfd *, const PTR, const PTR, Elf_Internal_Sym *));
d1599 1
a1599 1
  PARAMS ((bfd *, const Elf_Internal_Sym *, PTR, PTR));
d1601 1
a1601 1
  PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
d1603 1
a1603 1
  PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d1605 1
a1605 1
  PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
d1607 1
a1607 1
  PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d1609 1
a1609 1
  PARAMS ((bfd *, const Elf64_External_Phdr *, Elf_Internal_Phdr *));
d1611 1
a1611 1
  PARAMS ((bfd *, const Elf_Internal_Phdr *, Elf64_External_Phdr *));
d1613 1
a1613 1
  PARAMS ((bfd *, const PTR, Elf_Internal_Dyn *));
d1615 1
a1615 1
  PARAMS ((bfd *, const Elf_Internal_Dyn *, PTR));
d1617 1
a1617 1
  PARAMS ((bfd *, asymbol **, bfd_boolean));
d1619 1
a1619 1
  PARAMS ((bfd *));
d1621 1
a1621 1
  PARAMS ((bfd *, const Elf_Internal_Phdr *, unsigned int));
d1623 1
a1623 1
  PARAMS ((bfd *, asection *, PTR));
d1625 12
a1636 19
  PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
extern bfd_boolean bfd_elf64_add_dynamic_entry
  PARAMS ((struct bfd_link_info *, bfd_vma, bfd_vma));
extern bfd_boolean bfd_elf64_link_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
extern Elf_Internal_Rela *_bfd_elf64_link_read_relocs
  PARAMS ((bfd *, asection *, PTR, Elf_Internal_Rela *, bfd_boolean));

#define bfd_elf32_link_record_dynamic_symbol \
  _bfd_elf_link_record_dynamic_symbol
#define bfd_elf64_link_record_dynamic_symbol \
  _bfd_elf_link_record_dynamic_symbol

extern int elf_link_record_local_dynamic_symbol
  PARAMS ((struct bfd_link_info *, bfd *, long));
#define _bfd_elf32_link_record_local_dynamic_symbol \
  elf_link_record_local_dynamic_symbol
#define _bfd_elf64_link_record_local_dynamic_symbol \
  elf_link_record_local_dynamic_symbol
d1639 1
a1639 1
  PARAMS ((bfd *));
d1641 11
a1651 2
  PARAMS ((bfd *, arelent *, struct symbol_cache_entry *, PTR,
           asection *, bfd *, char **));
d1653 11
a1663 26
extern bfd_boolean _bfd_elf32_gc_sections
  PARAMS ((bfd *, struct bfd_link_info *));
extern bfd_boolean _bfd_elf32_gc_common_finalize_got_offsets
  PARAMS ((bfd *, struct bfd_link_info *));
extern bfd_boolean _bfd_elf32_gc_common_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
extern bfd_boolean _bfd_elf32_gc_record_vtinherit
  PARAMS ((bfd *, asection *, struct elf_link_hash_entry *, bfd_vma));
extern bfd_boolean _bfd_elf32_gc_record_vtentry
  PARAMS ((bfd *, asection *, struct elf_link_hash_entry *, bfd_vma));

extern bfd_boolean _bfd_elf64_gc_sections
  PARAMS ((bfd *, struct bfd_link_info *));
extern bfd_boolean _bfd_elf64_gc_common_finalize_got_offsets
  PARAMS ((bfd *, struct bfd_link_info *));
extern bfd_boolean _bfd_elf64_gc_common_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
extern bfd_boolean _bfd_elf64_gc_record_vtinherit
  PARAMS ((bfd *, asection *, struct elf_link_hash_entry *, bfd_vma));
extern bfd_boolean _bfd_elf64_gc_record_vtentry
  PARAMS ((bfd *, asection *, struct elf_link_hash_entry *, bfd_vma));

extern bfd_boolean _bfd_elf32_reloc_symbol_deleted_p
  PARAMS ((bfd_vma, PTR));
extern bfd_boolean _bfd_elf64_reloc_symbol_deleted_p
  PARAMS ((bfd_vma, PTR));
d1667 1
a1667 1
  PARAMS ((bfd *, char *, int *, const char *, int, const PTR, int));
d1669 1
a1669 1
  PARAMS ((bfd *, char *, int *, const char *, const char *));
d1671 1
a1671 1
  PARAMS ((bfd *, char *, int *, long, int, const PTR));
d1673 1
a1673 1
  PARAMS ((bfd *, char *, int *, long, int, const PTR));
d1675 1
a1675 1
  PARAMS ((bfd *, char *, int *, const PTR, int));
d1677 1
a1677 1
  PARAMS ((bfd *, char *, int *, const PTR, int));
d1679 8
a1686 1
  PARAMS ((bfd *, char *, int *, long, int, const PTR));
d1691 70
a1760 1
  PARAMS ((bfd *));
@


1.6
log
@resolve conflicts.
@
text
@d2 2
a3 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 1
a31 1
   of a single entry.  This is normally only applicaable to reloc and
d36 3
d41 1
a41 1
#define NAME(x,y) CAT4(x,64,_,y)
d44 1
a44 1
#define NAME(x,y) CAT4(x,32,_,y)
d49 1
a49 1
#define NAME(x,y) CAT4(x,NOSIZE,_,y)
d82 4
a95 3
  /* Symbol size.  */
  bfd_size_type size;

d113 3
a120 20
  /* If this symbol requires an entry in the global offset table, the
     processor specific backend uses this field to track usage and
     final offset.  We use a union and two names primarily to document
     the intent of any particular piece of code.  The field should be
     used as a count until size_dynamic_sections, at which point the
     contents of the .got is fixed.  Afterward, if this field is -1,
     then the symbol does not require a global offset table entry.  */
  union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
    } got;

  /* Same, but tracks a procedure linkage table entry.  */
  union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
    } plt;

d144 1
a144 1
  boolean *vtable_entries_used;
d149 23
a177 3
  /* Hash value of the name computed using the ELF hash function.  */
  unsigned long elf_hash_value;

d207 4
d232 83
d320 1
d323 2
a324 1
  boolean dynamic_sections_created;
d329 11
d343 1
d346 2
a347 1
  struct bfd_strtab_hash *dynstr;
d351 1
d355 1
d358 1
d361 7
d370 1
d374 6
d394 1
a394 1
    (boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func),	\
d400 14
d427 3
d433 22
a454 14
  int (*write_out_phdrs) PARAMS ((bfd *, const Elf_Internal_Phdr *, int));
  boolean (*write_shdrs_and_ehdr) PARAMS ((bfd *));
  void (*write_relocs) PARAMS ((bfd *, asection *, PTR));
  void (*swap_symbol_out) PARAMS ((bfd *, const Elf_Internal_Sym *, PTR));
  boolean (*slurp_reloc_table)
    PARAMS ((bfd *, asection *, asymbol **, boolean));
  long (*slurp_symbol_table) PARAMS ((bfd *, asymbol **, boolean));
  void (*swap_dyn_in) PARAMS ((bfd *, const PTR, Elf_Internal_Dyn *));
  void (*swap_dyn_out) PARAMS ((bfd *, const Elf_Internal_Dyn *, PTR));

  /* This function, if defined, is called to swap in a REL
     relocation.  If an external relocation corresponds to more than
     one internal relocation, then all relocations are swapped in at
     once.  */
d456 1
a456 1
    PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rel *));
d458 1
a458 2
  /* This function, if defined, is called to swap out a REL
     relocation.  */
d460 1
a460 1
    PARAMS ((bfd *, const Elf_Internal_Rel *, bfd_byte *));
d462 3
a464 4
  /* This function, if defined, is called to swap in a RELA
     relocation.  If an external relocation corresponds to more than
     one internal relocation, then all relocations are swapped in at
     once.  */
d468 1
a468 2
  /* This function, if defined, is called to swap out a RELA
     relocation.  */
a470 1

d479 26
d518 2
a519 2
  void (*elf_info_to_howto) PARAMS ((bfd *, arelent *,
				     Elf_Internal_Rela *));
d523 2
a524 2
  void (*elf_info_to_howto_rel) PARAMS ((bfd *, arelent *,
					 Elf_Internal_Rel *));
d531 2
a532 1
  boolean (*elf_backend_sym_is_global) PARAMS ((bfd *, asymbol *));
d541 1
a541 1
     used with caution.  If this returns false, the check_format
d543 2
a544 1
  boolean (*elf_backend_object_p) PARAMS ((bfd *));
d549 2
a550 1
  void (*elf_backend_symbol_processing) PARAMS ((bfd *, asymbol *));
d554 2
a555 3
  boolean (*elf_backend_symbol_table_processing) PARAMS ((bfd *,
							  elf_symbol_type *,
							  unsigned int));
d559 2
a560 1
  int (*elf_backend_get_symbol_type) PARAMS (( Elf_Internal_Sym *, int));
d566 2
a567 2
  boolean (*elf_backend_section_processing) PARAMS ((bfd *,
						     Elf32_Internal_Shdr *));
d571 2
a572 3
  boolean (*elf_backend_section_from_shdr) PARAMS ((bfd *,
						    Elf32_Internal_Shdr *,
						    char *));
d576 2
a577 2
  boolean (*elf_backend_section_flags) PARAMS ((flagword *,
						Elf32_Internal_Shdr *));
d581 2
a582 3
  boolean (*elf_backend_section_from_phdr) PARAMS ((bfd *,
						    Elf32_Internal_Phdr *,
						    int));
d587 2
a588 2
  boolean (*elf_backend_fake_sections) PARAMS ((bfd *, Elf32_Internal_Shdr *,
						asection *));
d591 1
a591 1
     this returns true, the section was found.  If it is a normal ELF
d594 2
a595 2
  boolean (*elf_backend_section_from_bfd_section)
    PARAMS ((bfd *, Elf32_Internal_Shdr *, asection *, int *retval));
d605 1
a605 1
  boolean (*elf_add_symbol_hook)
d612 1
a612 1
  boolean (*elf_backend_link_output_symbol_hook)
d624 1
a624 1
  boolean (*elf_backend_create_dynamic_sections)
d637 1
a637 1
  boolean (*check_relocs)
d653 1
a653 1
  boolean (*elf_backend_adjust_dynamic_symbol)
d660 1
a660 1
  boolean (*elf_backend_always_size_sections)
d673 1
a673 1
  boolean (*elf_backend_size_dynamic_sections)
d704 1
a704 1
  boolean (*elf_backend_relocate_section)
d717 1
a717 1
  boolean (*elf_backend_finish_dynamic_symbol)
d725 1
a725 1
  boolean (*elf_backend_finish_dynamic_sections)
d734 1
a734 1
     before writing it out.  The LINKER argument is true if this BFD
d737 1
a737 1
    PARAMS ((bfd *, boolean linker));
d742 2
a743 1
  int (*elf_backend_additional_program_headers) PARAMS ((bfd *));
d747 2
a748 1
  boolean (*elf_backend_modify_segment_map) PARAMS ((bfd *));
d751 1
a751 2
     particular relocation refers to.  It need not be defined for hosts
     that have no queer relocation types.  */
d753 1
a753 1
    PARAMS ((bfd *abfd, struct bfd_link_info *, Elf_Internal_Rela *,
d759 1
a759 1
  boolean (*gc_sweep_hook)
d779 1
a779 1
  boolean (*elf_backend_output_arch_syms)
d781 1
a781 2
	    boolean (*) PARAMS ((PTR, const char *,
             Elf_Internal_Sym *, asection *))));
d784 4
a787 1
     symbol IND to a newly created symbol DIR.  */
d789 2
a790 1
    PARAMS ((struct elf_link_hash_entry *, struct elf_link_hash_entry *));
d795 54
a848 1
    PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
d869 2
a870 2
  /* This is true if the linker should act like collect and gather
     global constructors and destructors by name.  This is true for
d875 2
a876 2
  /* This is true if the linker should ignore changes to the type of a
     symbol.  This is true for MIPS ELF because some Irix 5 objects
d898 6
a903 1
  /* True if addresses "naturally" sign extend.  This is used when
d913 2
d916 4
d929 1
d933 1
d937 1
d940 1
d943 1
d947 1
d951 1
d955 7
d965 1
d970 22
a991 11
  /* Used by the backend linker when generating a shared library to
     record the dynamic symbol index for a section symbol
     corresponding to this section.  A value of 0 means that there is
     no dynamic symbol for this section.  */
  long dynindx;
  /* A pointer used for .stab linking optimizations.  */
  PTR stab_info;
  /* A pointer available for the processor specific ELF backend.  */
  PTR tdata;
  /* Nonzero if this section uses RELA relocations, rather than REL.  */
  unsigned int use_rela_p:1;
d995 10
d1038 1
a1038 1
  boolean hole_written_p;		/* whether the hole has been initialized */
d1050 1
a1050 1
  bfd_signed_vma addend;			/* addend used */
d1052 1
a1052 1
  boolean written_address_p;			/* whether address was written yet */
d1064 1
a1064 1
  struct bfd_strtab_hash *strtab_ptr;
d1067 2
d1078 1
d1081 1
d1090 5
a1094 2
  bfd_vma gp;				/* The gp value (MIPS only, for now) */
  unsigned int gp_size;			/* The gp size (MIPS only, for now) */
d1103 1
a1103 1
  /* This is set to true if the object was created by the backend
d1105 1
a1105 1
  boolean linker;
d1112 3
a1114 7
  /* A mapping from local symbols to offsets into the global offset
     table, used when linking.  This is indexed by the symbol index.
     Like for the globals, we use a union and two names primarily to
     document the intent of any particular piece of code.  The field
     should be used as a count until size_dynamic_sections, at which
     point the contents of the .got is fixed.  Afterward, if an entry
     is -1, then the symbol does not require a global offset table entry.  */
d1119 1
d1149 1
a1149 1
  boolean bad_symtab;
d1174 4
d1179 1
a1179 1
  boolean flags_init;
d1207 1
d1210 1
d1218 1
d1226 1
d1255 2
a1256 1
extern int _bfd_elf_section_from_bfd_section PARAMS ((bfd *, asection *));
d1259 14
a1272 1
extern char *bfd_elf_get_str_section PARAMS ((bfd *, unsigned));
d1274 3
a1276 5
extern boolean _bfd_elf_print_private_bfd_data PARAMS ((bfd *, PTR));
extern void bfd_elf_print_symbol PARAMS ((bfd *, PTR, asymbol *,
					  bfd_print_symbol_type));
#define elf_string_from_elf_strtab(abfd,strindex) \
     bfd_elf_string_from_elf_section(abfd,elf_elfheader(abfd)->e_shstrndx,strindex)
d1281 16
a1296 1
extern unsigned long bfd_elf_hash PARAMS ((const char *));
d1298 12
a1309 14
extern bfd_reloc_status_type bfd_elf_generic_reloc PARAMS ((bfd *,
							    arelent *,
							    asymbol *,
							    PTR,
							    asection *,
							    bfd *,
							    char **));
extern boolean bfd_elf_mkobject PARAMS ((bfd *));
extern boolean bfd_elf_mkcorefile PARAMS ((bfd *));
extern Elf_Internal_Shdr *bfd_elf_find_section PARAMS ((bfd *, char *));
extern boolean _bfd_elf_make_section_from_shdr
  PARAMS ((bfd *abfd, Elf_Internal_Shdr *hdr, const char *name));
extern boolean _bfd_elf_make_section_from_phdr
  PARAMS ((bfd *abfd, Elf_Internal_Phdr *hdr, int index, const char *typename));
d1315 2
a1316 1
  PARAMS ((struct elf_link_hash_entry *, struct elf_link_hash_entry *));
d1318 2
a1319 2
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
extern boolean _bfd_elf_link_hash_table_init
d1324 11
a1334 3
extern boolean _bfd_elf_slurp_version_tables PARAMS ((bfd *));

extern boolean _bfd_elf_copy_private_symbol_data
d1336 1
a1336 1
extern boolean _bfd_elf_copy_private_section_data
d1338 35
a1372 27
extern boolean _bfd_elf_write_object_contents PARAMS ((bfd *));
extern boolean _bfd_elf_write_corefile_contents PARAMS ((bfd *));
extern boolean _bfd_elf_set_section_contents PARAMS ((bfd *, sec_ptr, PTR,
						       file_ptr,
						       bfd_size_type));
extern long _bfd_elf_get_symtab_upper_bound PARAMS ((bfd *));
extern long _bfd_elf_get_symtab PARAMS ((bfd *, asymbol **));
extern long _bfd_elf_get_dynamic_symtab_upper_bound PARAMS ((bfd *));
extern long _bfd_elf_canonicalize_dynamic_symtab PARAMS ((bfd *, asymbol **));
extern long _bfd_elf_get_reloc_upper_bound PARAMS ((bfd *, sec_ptr));
extern long _bfd_elf_canonicalize_reloc PARAMS ((bfd *, sec_ptr,
						  arelent **, asymbol **));
extern long _bfd_elf_get_dynamic_reloc_upper_bound PARAMS ((bfd *));
extern long _bfd_elf_canonicalize_dynamic_reloc PARAMS ((bfd *, arelent **,
							 asymbol **));
extern asymbol *_bfd_elf_make_empty_symbol PARAMS ((bfd *));
extern void _bfd_elf_get_symbol_info PARAMS ((bfd *, asymbol *,
					       symbol_info *));
extern boolean _bfd_elf_is_local_label_name PARAMS ((bfd *, const char *));
extern alent *_bfd_elf_get_lineno PARAMS ((bfd *, asymbol *));
extern boolean _bfd_elf_set_arch_mach PARAMS ((bfd *, enum bfd_architecture,
						unsigned long));
extern boolean _bfd_elf_find_nearest_line PARAMS ((bfd *, asection *,
						    asymbol **,
						    bfd_vma, const char **,
						    const char **,
						    unsigned int *));
d1375 6
a1380 4
extern int _bfd_elf_sizeof_headers PARAMS ((bfd *, boolean));
extern boolean _bfd_elf_new_section_hook PARAMS ((bfd *, asection *));
extern boolean _bfd_elf_init_reloc_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *, boolean));
d1383 65
a1447 2
extern void _bfd_elf_no_info_to_howto PARAMS ((bfd *, arelent *,
					       Elf_Internal_Rela *));
d1449 2
a1450 2
extern boolean bfd_section_from_shdr PARAMS ((bfd *, unsigned int shindex));
extern boolean bfd_section_from_phdr PARAMS ((bfd *, Elf_Internal_Phdr *, int));
d1452 6
a1457 1
extern int _bfd_elf_symbol_from_bfd_symbol PARAMS ((bfd *, asymbol **));
d1459 30
a1488 76
asection *bfd_section_from_elf_index PARAMS ((bfd *, unsigned int));
boolean _bfd_elf_create_dynamic_sections PARAMS ((bfd *,
						  struct bfd_link_info *));
struct bfd_strtab_hash *_bfd_elf_stringtab_init PARAMS ((void));
boolean
_bfd_elf_link_record_dynamic_symbol PARAMS ((struct bfd_link_info *,
					     struct elf_link_hash_entry *));
long
_bfd_elf_link_lookup_local_dynindx PARAMS ((struct bfd_link_info *,
					    bfd *, long));
boolean
_bfd_elf_compute_section_file_positions PARAMS ((bfd *,
						 struct bfd_link_info *));
void _bfd_elf_assign_file_positions_for_relocs PARAMS ((bfd *));
file_ptr _bfd_elf_assign_file_position_for_section PARAMS ((Elf_Internal_Shdr *,
							    file_ptr,
							    boolean));

extern boolean _bfd_elf_validate_reloc PARAMS ((bfd *, arelent *));

boolean _bfd_elf_create_dynamic_sections PARAMS ((bfd *,
						  struct bfd_link_info *));
boolean _bfd_elf_create_got_section PARAMS ((bfd *,
					     struct bfd_link_info *));
unsigned long _bfd_elf_link_renumber_dynsyms PARAMS ((bfd *,
						      struct bfd_link_info *));

elf_linker_section_t *_bfd_elf_create_linker_section
  PARAMS ((bfd *abfd,
	   struct bfd_link_info *info,
	   enum elf_linker_section_enum,
	   elf_linker_section_t *defaults));

elf_linker_section_pointers_t *_bfd_elf_find_pointer_linker_section
  PARAMS ((elf_linker_section_pointers_t *linker_pointers,
	   bfd_signed_vma addend,
	   elf_linker_section_enum_t which));

boolean bfd_elf32_create_pointer_linker_section
  PARAMS ((bfd *abfd,
	   struct bfd_link_info *info,
	   elf_linker_section_t *lsect,
	   struct elf_link_hash_entry *h,
	   const Elf32_Internal_Rela *rel));

bfd_vma bfd_elf32_finish_pointer_linker_section
  PARAMS ((bfd *output_abfd,
	   bfd *input_bfd,
	   struct bfd_link_info *info,
	   elf_linker_section_t *lsect,
	   struct elf_link_hash_entry *h,
	   bfd_vma relocation,
	   const Elf32_Internal_Rela *rel,
	   int relative_reloc));

boolean bfd_elf64_create_pointer_linker_section
  PARAMS ((bfd *abfd,
	   struct bfd_link_info *info,
	   elf_linker_section_t *lsect,
	   struct elf_link_hash_entry *h,
	   const Elf64_Internal_Rela *rel));

bfd_vma bfd_elf64_finish_pointer_linker_section
  PARAMS ((bfd *output_abfd,
	   bfd *input_bfd,
	   struct bfd_link_info *info,
	   elf_linker_section_t *lsect,
	   struct elf_link_hash_entry *h,
	   bfd_vma relocation,
	   const Elf64_Internal_Rela *rel,
	   int relative_reloc));

boolean _bfd_elf_make_linker_section_rela
  PARAMS ((bfd *dynobj,
	   elf_linker_section_t *lsect,
	   int alignment));
d1490 2
a1491 2
boolean _bfd_elfcore_section_from_phdr
  PARAMS ((bfd *, Elf_Internal_Phdr *, int));
d1493 10
a1502 6
extern const bfd_target *bfd_elf32_object_p PARAMS ((bfd *));
extern const bfd_target *bfd_elf32_core_file_p PARAMS ((bfd *));
extern char *bfd_elf32_core_file_failing_command PARAMS ((bfd *));
extern int bfd_elf32_core_file_failing_signal PARAMS ((bfd *));
extern boolean bfd_elf32_core_file_matches_executable_p PARAMS ((bfd *,
								 bfd *));
d1504 1
a1504 1
extern boolean bfd_elf32_bfd_link_add_symbols
d1506 1
a1506 1
extern boolean bfd_elf32_bfd_final_link
d1510 1
a1510 1
  PARAMS ((bfd *, const Elf32_External_Sym *, Elf_Internal_Sym *));
d1512 1
a1512 1
  PARAMS ((bfd *, const Elf_Internal_Sym *, PTR));
d1514 1
a1514 1
  PARAMS ((bfd *, const Elf32_External_Rel *, Elf_Internal_Rel *));
d1516 1
a1516 1
  PARAMS ((bfd *, const Elf_Internal_Rel *, Elf32_External_Rel *));
d1518 1
a1518 1
  PARAMS ((bfd *, const Elf32_External_Rela *, Elf_Internal_Rela *));
d1520 1
a1520 1
  PARAMS ((bfd *, const Elf_Internal_Rela *, Elf32_External_Rela *));
d1530 3
a1532 2
  PARAMS ((bfd *, asymbol **, boolean));
extern boolean bfd_elf32_write_shdrs_and_ehdr PARAMS ((bfd *));
d1534 1
a1534 1
  PARAMS ((bfd *, const Elf_Internal_Phdr *, int));
d1537 3
a1539 3
extern boolean bfd_elf32_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, boolean));
extern boolean bfd_elf32_add_dynamic_entry
d1541 1
a1541 1
extern boolean bfd_elf32_link_create_dynamic_sections
d1544 1
a1544 1
  PARAMS ((bfd *, asection *, PTR, Elf_Internal_Rela *, boolean));
d1546 11
a1556 7
extern const bfd_target *bfd_elf64_object_p PARAMS ((bfd *));
extern const bfd_target *bfd_elf64_core_file_p PARAMS ((bfd *));
extern char *bfd_elf64_core_file_failing_command PARAMS ((bfd *));
extern int bfd_elf64_core_file_failing_signal PARAMS ((bfd *));
extern boolean bfd_elf64_core_file_matches_executable_p PARAMS ((bfd *,
								 bfd *));
extern boolean bfd_elf64_bfd_link_add_symbols
d1558 1
a1558 1
extern boolean bfd_elf64_bfd_final_link
d1562 1
a1562 1
  PARAMS ((bfd *, const Elf64_External_Sym *, Elf_Internal_Sym *));
d1564 1
a1564 1
  PARAMS ((bfd *, const Elf_Internal_Sym *, PTR));
d1566 1
a1566 1
  PARAMS ((bfd *, const Elf64_External_Rel *, Elf_Internal_Rel *));
d1568 1
a1568 1
  PARAMS ((bfd *, const Elf_Internal_Rel *, Elf64_External_Rel *));
d1570 1
a1570 1
  PARAMS ((bfd *, const Elf64_External_Rela *, Elf_Internal_Rela *));
d1572 1
a1572 1
  PARAMS ((bfd *, const Elf_Internal_Rela *, Elf64_External_Rela *));
d1582 3
a1584 2
  PARAMS ((bfd *, asymbol **, boolean));
extern boolean bfd_elf64_write_shdrs_and_ehdr PARAMS ((bfd *));
d1586 1
a1586 1
  PARAMS ((bfd *, const Elf_Internal_Phdr *, int));
d1589 3
a1591 3
extern boolean bfd_elf64_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, boolean));
extern boolean bfd_elf64_add_dynamic_entry
d1593 1
a1593 1
extern boolean bfd_elf64_link_create_dynamic_sections
d1596 1
a1596 1
  PARAMS ((bfd *, asection *, PTR, Elf_Internal_Rela *, boolean));
d1603 1
a1603 3
boolean _bfd_elf32_link_record_local_dynamic_symbol
  PARAMS ((struct bfd_link_info *, bfd *, long));
boolean _bfd_elf64_link_record_local_dynamic_symbol
d1605 4
d1610 2
a1611 1
extern boolean _bfd_elf_close_and_cleanup PARAMS ((bfd *));
d1616 1
a1616 5
boolean _bfd_elf32_gc_sections
  PARAMS ((bfd *abfd, struct bfd_link_info *info));
boolean _bfd_elf32_gc_common_finalize_got_offsets
  PARAMS ((bfd *abfd, struct bfd_link_info *info));
boolean _bfd_elf32_gc_common_final_link
d1618 5
a1622 1
boolean _bfd_elf32_gc_record_vtinherit
d1624 1
a1624 1
boolean _bfd_elf32_gc_record_vtentry
d1627 3
a1629 5
boolean _bfd_elf64_gc_sections
  PARAMS ((bfd *abfd, struct bfd_link_info *info));
boolean _bfd_elf64_gc_common_finalize_got_offsets
  PARAMS ((bfd *abfd, struct bfd_link_info *info));
boolean _bfd_elf64_gc_common_final_link
d1631 3
a1633 1
boolean _bfd_elf64_gc_record_vtinherit
d1635 1
a1635 1
boolean _bfd_elf64_gc_record_vtentry
d1638 20
a1657 72
/* MIPS ELF specific routines.  */

extern boolean _bfd_mips_elf_object_p PARAMS ((bfd *));
extern boolean _bfd_mips_elf_section_from_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, char *));
extern boolean _bfd_mips_elf_fake_sections
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
extern boolean _bfd_mips_elf_section_from_bfd_section
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *, int *));
extern boolean _bfd_mips_elf_section_processing
  PARAMS ((bfd *, Elf_Internal_Shdr *));
extern void _bfd_mips_elf_symbol_processing PARAMS ((bfd *, asymbol *));
extern boolean _bfd_mips_elf_read_ecoff_info
  PARAMS ((bfd *, asection *, struct ecoff_debug_info *));
extern void _bfd_mips_elf_final_write_processing PARAMS ((bfd *, boolean));
extern bfd_reloc_status_type _bfd_mips_elf_hi16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
extern bfd_reloc_status_type _bfd_mips_elf_lo16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
extern bfd_reloc_status_type _bfd_mips_elf_gprel16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
extern bfd_reloc_status_type _bfd_mips_elf_got16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
extern bfd_reloc_status_type _bfd_mips_elf_gprel32_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
extern boolean _bfd_mips_elf_set_private_flags PARAMS ((bfd *, flagword));
extern boolean _bfd_mips_elf_copy_private_bfd_data PARAMS ((bfd *, bfd *));
extern boolean _bfd_mips_elf_merge_private_bfd_data PARAMS ((bfd *, bfd *));
extern boolean _bfd_mips_elf_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
extern boolean _bfd_mips_elf_set_section_contents
  PARAMS ((bfd *, asection *, PTR, file_ptr, bfd_size_type));
extern boolean _bfd_mips_elf_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
extern boolean _bfd_mips_elf_add_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
	   const char **, flagword *, asection **, bfd_vma *));
extern boolean _bfd_mips_elf_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
extern boolean _bfd_mips_elf_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
extern boolean _bfd_mips_elf_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
extern asection * _bfd_mips_elf_gc_mark_hook
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
extern boolean _bfd_mips_elf_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
extern boolean _bfd_mips_elf_always_size_sections
  PARAMS ((bfd *, struct bfd_link_info *));
extern boolean _bfd_mips_elf_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
extern boolean _bfd_mips_elf_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
extern struct bfd_link_hash_table *_bfd_mips_elf_link_hash_table_create
  PARAMS ((bfd *));
extern boolean _bfd_mips_elf_print_private_bfd_data
  PARAMS ((bfd *, PTR));
extern boolean _bfd_mips_elf_link_output_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, const char *, Elf_Internal_Sym *,
	   asection *));
extern boolean _bfd_mips_elf_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
extern int _bfd_mips_elf_additional_program_headers PARAMS ((bfd *));
extern boolean _bfd_mips_elf_modify_segment_map PARAMS ((bfd *));
extern boolean _bfd_mips_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
d1661 2
a1662 1
extern boolean _sh_elf_set_mach_from_flags PARAMS ((bfd *));
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 2
   Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 1999, 2000 Free Software
   Foundation, Inc.
d30 5
d216 1
a216 1
  
d251 3
d383 3
a385 3
     types should be handled here. */
  int (*elf_backend_get_symbol_type) PARAMS (( Elf_Internal_Sym *, int)); 
 
d399 5
d405 1
a405 1
     sections from ELF program segments. */
d617 1
a617 1
    PARAMS ((struct elf_link_hash_entry *));
d654 1
a654 1
    
d663 2
a664 2
     and the backend wants RELA relocations for a particular 
     section.  */   
d804 1
a804 1
     these weren't used outside bfd. */
d811 1
a811 1
  /* Information grabbed from an elf core file. */
d833 1
a833 1
     is -1, then the symbol does not require a global offset table entry. */
d854 8
d881 1
a881 1
  /* A place to stash dwarf1 info for this bfd. */
d884 2
a885 2
  /* A place to stash dwarf2 info for this bfd. */
  struct dwarf2_debug *dwarf2_find_line_info;
d909 7
d939 1
d1002 1
a1002 1
  PARAMS ((struct elf_link_hash_entry *));
d1038 2
a1039 2
						    bfd_vma, CONST char **,
						    CONST char **,
d1045 1
a1045 1
extern boolean _bfd_elf_init_reloc_shdr 
d1174 4
d1221 4
d1314 1
a1314 1
extern asection * _bfd_mips_elf_gc_mark_hook 
d1317 2
a1318 2
extern boolean _bfd_mips_elf_gc_sweep_hook 
  PARAMS ((bfd *, struct bfd_link_info *, asection *, 
d1329 1
a1329 1
extern boolean _bfd_mips_elf_print_private_bfd_data 
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright (C) 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
d66 6
d89 10
d110 18
a127 11
     processor specific backend uses this field to hold the offset
     into the .got section.  If this field is -1, then the symbol does
     not require a global offset table entry.  */
  bfd_vma got_offset;

  /* If this symbol requires an entry in the procedure linkage table,
     the processor specific backend uses these two fields to hold the
     offset into the procedure linkage section and the offset into the
     .got section.  If plt_offset is -1, then the symbol does not
     require an entry in the procedure linkage table.  */
  bfd_vma plt_offset;
d134 23
d160 6
d167 1
a167 1
  unsigned char elf_link_hash_flags;
d176 2
d179 1
a179 1
#define ELF_LINK_HASH_DYNAMIC_ADJUSTED 020
d181 1
a181 1
#define ELF_LINK_HASH_NEEDS_COPY 040
d183 1
a183 1
#define ELF_LINK_HASH_NEEDS_PLT 0100
d185 29
a213 3
#define ELF_LINK_NON_ELF 0200
  /* Note: If you add more flags, you must change the type of
     elf_link_hash_flags.  */
d244 2
d273 7
d286 2
a287 1
  boolean (*slurp_reloc_table) PARAMS ((bfd *, asection *, asymbol **));
d290 26
a325 5
  /* Whether the backend uses REL or RELA relocations.  FIXME: some
     ELF backends use both.  When we need to support one, this whole
     approach will need to be changed.  */
  int use_rela_p;

a334 12
  /* This is true if the linker should act like collect and gather
     global constructors and destructors by name.  This is true for
     MIPS ELF because the Irix 5 tools can not handle the .init
     section.  */
  boolean collect;

  /* This is true if the linker should ignore changes to the type of a
     symbol.  This is true for MIPS ELF because some Irix 5 objects
     record undefined functions as STT_OBJECT although the definitions
     are STT_FUNC.  */
  boolean type_change_ok;

d374 4
d391 6
d469 7
d561 45
d616 42
d661 4
d680 4
d687 2
a688 2
  /* The ELF section number of the reloc section associated with this
     section, if any.  Only used for an output file.  */
d690 3
d702 2
a703 1
     corresponding to this section.  */
d709 2
d748 1
a748 1
  int alignment;			/* alignment for the section */
d782 3
d787 1
d789 3
d794 1
d798 7
d815 11
a825 2
     table, used when linking.  This is indexed by the symbol index.  */
  bfd_vma *local_got_offsets;
d860 11
d874 12
d896 3
d907 2
a908 1
#define elf_local_got_offsets(bfd) (elf_tdata(bfd) -> local_got_offsets)
d915 21
a948 3
#define bfd_elf32_mkobject	bfd_elf_mkobject
#define bfd_elf64_mkobject	bfd_elf_mkobject
#define elf_mkobject		bfd_elf_mkobject
d950 1
a950 1
extern unsigned long bfd_elf_hash PARAMS ((CONST unsigned char *));
d960 1
d964 2
d970 4
d979 1
d986 1
d997 3
d1003 1
d1016 2
d1035 3
d1052 2
d1105 3
d1139 1
a1139 1
  PARAMS ((bfd *, const Elf_Internal_Dyn *, Elf32_External_Dyn *));
d1182 1
a1182 1
  PARAMS ((bfd *, const Elf_Internal_Dyn *, Elf64_External_Dyn *));
d1195 36
a1230 2
#define bfd_elf32_link_record_dynamic_symbol _bfd_elf_link_record_dynamic_symbol
#define bfd_elf64_link_record_dynamic_symbol _bfd_elf_link_record_dynamic_symbol
d1236 1
a1236 1
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
d1265 43
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d722 1
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d838 2
d881 2
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1992, 1993 Free Software Foundation, Inc.
d105 5
d129 4
d149 1
a149 1
  size_t dynsymcount;
d155 1
a155 1
  size_t bucketcount;
d159 4
d192 1
a192 1
  int (*write_out_phdrs) PARAMS ((bfd *, Elf_Internal_Phdr *, int));
d195 1
a195 1
  void (*swap_symbol_out) PARAMS ((bfd *, Elf_Internal_Sym *, PTR));
d198 1
d229 6
d435 8
a442 7
  /* A function to create any special program headers required by the
     backend.  PHDRS are the program headers, and PHDR_COUNT is the
     number of them.  If PHDRS is NULL, this just counts headers
     without creating them.  This returns an updated value for
     PHDR_COUNT.  */
  int (*elf_backend_create_program_headers)
    PARAMS ((bfd *, Elf_Internal_Phdr *phdrs, int phdr_count));
a456 3

  /* Put ELF and program headers in the first loadable segment.  */
  unsigned want_hdr_in_seg : 1;
d462 2
a463 1
struct bfd_elf_section_data {
d469 3
d489 4
d500 46
d554 1
d558 1
a558 1
  asymbol **section_syms;	/* STT_SECTION symbols for each section */
d567 4
a570 4
  void *prstatus;		/* The raw /proc prstatus structure */
  void *prpsinfo;		/* The raw /proc prpsinfo structure */
  bfd_vma gp;			/* The gp value (MIPS only, for now) */
  unsigned int gp_size;		/* The gp size (MIPS only, for now) */
d585 4
d591 7
a597 3
     dynamic object is found using a search.  This field is used to
     hold that information.  */
  const char *dt_needed_name;
d609 3
d618 5
a622 2
  /* Used by PowerPC to determine if the e_flags field has been intiialized */
  boolean ppc_flags_init;
d640 2
a641 1
#define elf_dt_needed_name(bfd)	(elf_tdata(bfd) -> dt_needed_name)
d643 2
a644 1
#define elf_ppc_flags_init(bfd)	(elf_tdata(bfd) -> ppc_flags_init)
d646 4
a649 2
extern char * bfd_elf_string_from_elf_section PARAMS ((bfd *, unsigned, unsigned));
extern char * bfd_elf_get_str_section PARAMS ((bfd *, unsigned));
d651 1
d721 4
d740 2
d747 50
d810 1
a810 1
  PARAMS ((bfd *, Elf32_External_Sym *, Elf_Internal_Sym *));
d812 1
a812 1
  PARAMS ((bfd *, Elf_Internal_Sym *, PTR));
d814 1
a814 1
  PARAMS ((bfd *, Elf32_External_Rel *, Elf_Internal_Rel *));
d816 1
a816 1
  PARAMS ((bfd *, Elf_Internal_Rel *, Elf32_External_Rel *));
d818 1
a818 1
  PARAMS ((bfd *, Elf32_External_Rela *, Elf_Internal_Rela *));
d820 1
a820 1
  PARAMS ((bfd *, Elf_Internal_Rela *, Elf32_External_Rela *));
d822 1
a822 1
  PARAMS ((bfd *, Elf32_External_Phdr *, Elf_Internal_Phdr *));
d824 1
a824 1
  PARAMS ((bfd *, Elf_Internal_Phdr *, Elf32_External_Phdr *));
d826 1
a826 1
  PARAMS ((bfd *, const Elf32_External_Dyn *, Elf_Internal_Dyn *));
d829 5
d851 1
a851 1
  PARAMS ((bfd *, Elf64_External_Sym *, Elf_Internal_Sym *));
d853 1
a853 1
  PARAMS ((bfd *, Elf_Internal_Sym *, PTR));
d855 1
a855 1
  PARAMS ((bfd *, Elf64_External_Rel *, Elf_Internal_Rel *));
d857 1
a857 1
  PARAMS ((bfd *, Elf_Internal_Rel *, Elf64_External_Rel *));
d859 1
a859 1
  PARAMS ((bfd *, Elf64_External_Rela *, Elf_Internal_Rela *));
d861 1
a861 1
  PARAMS ((bfd *, Elf_Internal_Rela *, Elf64_External_Rela *));
d863 1
a863 1
  PARAMS ((bfd *, Elf64_External_Phdr *, Elf_Internal_Phdr *));
d865 1
a865 1
  PARAMS ((bfd *, Elf_Internal_Phdr *, Elf64_External_Phdr *));
d867 1
a867 1
  PARAMS ((bfd *, const Elf64_External_Dyn *, Elf_Internal_Dyn *));
d870 5
d882 34
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright (C) 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
a104 5
  /* If this symbol is used in the linker created sections, the processor
     specific backend uses this field to map the field into the offset
     from the beginning of the section.  */
  struct elf_linker_section_pointers *linker_section_pointer;

a123 4
  /* Symbol appears in a non-ELF input file.  */
#define ELF_LINK_NON_ELF 0200
  /* Note: If you add more flags, you must change the type of
     elf_link_hash_flags.  */
d140 1
a140 1
  bfd_size_type dynsymcount;
d146 1
a146 1
  bfd_size_type bucketcount;
a149 4
  /* The _GLOBAL_OFFSET_TABLE_ symbol.  */
  struct elf_link_hash_entry *hgot;
  /* A pointer to information used to link stabs in sections.  */
  PTR stab_info;
d179 1
a179 1
  int (*write_out_phdrs) PARAMS ((bfd *, const Elf_Internal_Phdr *, int));
d182 1
a182 1
  void (*swap_symbol_out) PARAMS ((bfd *, const Elf_Internal_Sym *, PTR));
a184 1
  void (*swap_dyn_in) PARAMS ((bfd *, const PTR, Elf_Internal_Dyn *));
a214 6
  /* This is true if the linker should ignore changes to the type of a
     symbol.  This is true for MIPS ELF because some Irix 5 objects
     record undefined functions as STT_OBJECT although the definitions
     are STT_FUNC.  */
  boolean type_change_ok;

d415 7
a421 8
  /* This function is called by get_program_header_size.  It should
     return the number of additional program segments which this BFD
     will need.  It should return -1 on error.  */
  int (*elf_backend_additional_program_headers) PARAMS ((bfd *));

  /* This function is called to modify an existing segment map in a
     backend specific fashion.  */
  boolean (*elf_backend_modify_segment_map) PARAMS ((bfd *));
d436 3
d444 1
a444 2
struct bfd_elf_section_data
{
a449 3
  /* If there is a second reloc section associated with this section,
     as can happen on Irix 6, this field points to the header.  */
  Elf_Internal_Shdr *rel_hdr2;
a466 4
  /* A pointer used for .stab linking optimizations.  */
  PTR stab_info;
  /* A pointer available for the processor specific ELF backend.  */
  PTR tdata;
a473 46
/* Enumeration to specify the special section.  */
typedef enum elf_linker_section_enum
{
  LINKER_SECTION_UNKNOWN,		/* not used */
  LINKER_SECTION_GOT,			/* .got section for global offset pointers */
  LINKER_SECTION_PLT,			/* .plt section for generated procedure stubs */
  LINKER_SECTION_SDATA,			/* .sdata/.sbss section for PowerPC */
  LINKER_SECTION_SDATA2,		/* .sdata2/.sbss2 section for PowerPC */
  LINKER_SECTION_MAX			/* # of linker sections */
} elf_linker_section_enum_t;

/* Sections created by the linker.  */

typedef struct elf_linker_section
{
  char *name;				/* name of the section */
  char *rel_name;			/* name of the associated .rel{,a}. section */
  char *bss_name;			/* name of a related .bss section */
  char *sym_name;			/* name of symbol to reference this section */
  asection *section;			/* pointer to the section */
  asection *bss_section;		/* pointer to the bss section associated with this */
  asection *rel_section;		/* pointer to the relocations needed for this section */
  struct elf_link_hash_entry *sym_hash;	/* pointer to the created symbol hash value */
  bfd_vma initial_size;			/* initial size before any linker generated allocations */
  bfd_vma sym_offset;			/* offset of symbol from beginning of section */
  bfd_vma hole_size;			/* size of reserved address hole in allocation */
  bfd_vma hole_offset;			/* current offset for the hole */
  bfd_vma max_hole_offset;		/* maximum offset for the hole */
  elf_linker_section_enum_t which;	/* which section this is */
  boolean hole_written_p;		/* whether the hole has been initialized */
  int alignment;			/* alignment for the section */
  flagword flags;			/* flags to use to create the section */
} elf_linker_section_t;

/* Linked list of allocated pointer entries.  This hangs off of the symbol lists, and
   provides allows us to return different pointers, based on different addend's.  */

typedef struct elf_linker_section_pointers
{
  struct elf_linker_section_pointers *next;	/* next allocated pointer for this symbol */
  bfd_vma offset;				/* offset of pointer from beginning of section */
  bfd_signed_vma addend;			/* addend used */
  elf_linker_section_enum_t which;		/* which linker section this is */
  boolean written_address_p;			/* whether address was written yet */
} elf_linker_section_pointers_t;

a481 1
  struct elf_segment_map *segment_map;
d485 1
a485 1
  asymbol **section_syms;		/* STT_SECTION symbols for each section */
d494 4
a497 4
  void *prstatus;			/* The raw /proc prstatus structure */
  void *prpsinfo;			/* The raw /proc prpsinfo structure */
  bfd_vma gp;				/* The gp value (MIPS only, for now) */
  unsigned int gp_size;			/* The gp size (MIPS only, for now) */
a511 4
  /* A mapping from local symbols to offsets into the various linker
     sections added.  This is index by the symbol index.  */
  elf_linker_section_pointers_t **linker_section_pointers;

d514 3
a516 7
     dynamic object is found using a search.  The emulation code then
     sometimes needs to know what name was actually used.  Until the
     file has been added to the linker symbol table, this field holds
     the name the linker wants.  After it has been added, it holds the
     name actually used, which will be the DT_SONAME entry if there is
     one.  */
  const char *dt_name;
a527 3
  /* Used by find_nearest_line entry point.  */
  PTR line_info;

d534 2
a535 5
  /* Used to determine if the e_flags field has been initialized */
  boolean flags_init;

  /* Linker sections that we are interested in.  */
  struct elf_linker_section *linker_section[ (int)LINKER_SECTION_MAX ];
d553 1
a553 2
#define elf_local_ptr_offsets(bfd) (elf_tdata(bfd) -> linker_section_pointers)
#define elf_dt_name(bfd)	(elf_tdata(bfd) -> dt_name)
d555 1
a555 2
#define elf_flags_init(bfd)	(elf_tdata(bfd) -> flags_init)
#define elf_linker_section(bfd,n) (elf_tdata(bfd) -> linker_section[(int)n])
d557 2
a558 4
extern int _bfd_elf_section_from_bfd_section PARAMS ((bfd *, asection *));
extern char *bfd_elf_string_from_elf_section
  PARAMS ((bfd *, unsigned, unsigned));
extern char *bfd_elf_get_str_section PARAMS ((bfd *, unsigned));
a559 1
extern boolean _bfd_elf_print_private_bfd_data PARAMS ((bfd *, PTR));
a628 4
extern boolean bfd_section_from_shdr PARAMS ((bfd *, unsigned int shindex));

extern int _bfd_elf_symbol_from_bfd_symbol PARAMS ((bfd *, asymbol **));

a643 2
extern boolean _bfd_elf_validate_reloc PARAMS ((bfd *, arelent *));

a648 50
elf_linker_section_t *_bfd_elf_create_linker_section
  PARAMS ((bfd *abfd,
	   struct bfd_link_info *info,
	   enum elf_linker_section_enum,
	   elf_linker_section_t *defaults));

elf_linker_section_pointers_t *_bfd_elf_find_pointer_linker_section
  PARAMS ((elf_linker_section_pointers_t *linker_pointers,
	   bfd_signed_vma addend,
	   elf_linker_section_enum_t which));

boolean bfd_elf32_create_pointer_linker_section
  PARAMS ((bfd *abfd,
	   struct bfd_link_info *info,
	   elf_linker_section_t *lsect,
	   struct elf_link_hash_entry *h,
	   const Elf32_Internal_Rela *rel));

bfd_vma bfd_elf32_finish_pointer_linker_section
  PARAMS ((bfd *output_abfd,
	   bfd *input_bfd,
	   struct bfd_link_info *info,
	   elf_linker_section_t *lsect,
	   struct elf_link_hash_entry *h,
	   bfd_vma relocation,
	   const Elf32_Internal_Rela *rel,
	   int relative_reloc));

boolean bfd_elf64_create_pointer_linker_section
  PARAMS ((bfd *abfd,
	   struct bfd_link_info *info,
	   elf_linker_section_t *lsect,
	   struct elf_link_hash_entry *h,
	   const Elf64_Internal_Rela *rel));

bfd_vma bfd_elf64_finish_pointer_linker_section
  PARAMS ((bfd *output_abfd,
	   bfd *input_bfd,
	   struct bfd_link_info *info,
	   elf_linker_section_t *lsect,
	   struct elf_link_hash_entry *h,
	   bfd_vma relocation,
	   const Elf64_Internal_Rela *rel,
	   int relative_reloc));

boolean _bfd_elf_make_linker_section_rela
  PARAMS ((bfd *dynobj,
	   elf_linker_section_t *lsect,
	   int alignment));

d662 1
a662 1
  PARAMS ((bfd *, const Elf32_External_Sym *, Elf_Internal_Sym *));
d664 1
a664 1
  PARAMS ((bfd *, const Elf_Internal_Sym *, PTR));
d666 1
a666 1
  PARAMS ((bfd *, const Elf32_External_Rel *, Elf_Internal_Rel *));
d668 1
a668 1
  PARAMS ((bfd *, const Elf_Internal_Rel *, Elf32_External_Rel *));
d670 1
a670 1
  PARAMS ((bfd *, const Elf32_External_Rela *, Elf_Internal_Rela *));
d672 1
a672 1
  PARAMS ((bfd *, const Elf_Internal_Rela *, Elf32_External_Rela *));
d674 1
a674 1
  PARAMS ((bfd *, const Elf32_External_Phdr *, Elf_Internal_Phdr *));
d676 1
a676 1
  PARAMS ((bfd *, const Elf_Internal_Phdr *, Elf32_External_Phdr *));
d678 1
a678 1
  PARAMS ((bfd *, const PTR, Elf_Internal_Dyn *));
a680 5
extern long bfd_elf32_slurp_symbol_table
  PARAMS ((bfd *, asymbol **, boolean));
extern boolean bfd_elf32_write_shdrs_and_ehdr PARAMS ((bfd *));
extern int bfd_elf32_write_out_phdrs
  PARAMS ((bfd *, const Elf_Internal_Phdr *, int));
d698 1
a698 1
  PARAMS ((bfd *, const Elf64_External_Sym *, Elf_Internal_Sym *));
d700 1
a700 1
  PARAMS ((bfd *, const Elf_Internal_Sym *, PTR));
d702 1
a702 1
  PARAMS ((bfd *, const Elf64_External_Rel *, Elf_Internal_Rel *));
d704 1
a704 1
  PARAMS ((bfd *, const Elf_Internal_Rel *, Elf64_External_Rel *));
d706 1
a706 1
  PARAMS ((bfd *, const Elf64_External_Rela *, Elf_Internal_Rela *));
d708 1
a708 1
  PARAMS ((bfd *, const Elf_Internal_Rela *, Elf64_External_Rela *));
d710 1
a710 1
  PARAMS ((bfd *, const Elf64_External_Phdr *, Elf_Internal_Phdr *));
d712 1
a712 1
  PARAMS ((bfd *, const Elf_Internal_Phdr *, Elf64_External_Phdr *));
d714 1
a714 1
  PARAMS ((bfd *, const PTR, Elf_Internal_Dyn *));
a716 5
extern long bfd_elf64_slurp_symbol_table
  PARAMS ((bfd *, asymbol **, boolean));
extern boolean bfd_elf64_write_shdrs_and_ehdr PARAMS ((bfd *));
extern int bfd_elf64_write_out_phdrs
  PARAMS ((bfd *, const Elf_Internal_Phdr *, int));
a723 34

/* MIPS ELF specific routines.  */

extern boolean _bfd_mips_elf_object_p PARAMS ((bfd *));
extern boolean _bfd_mips_elf_section_from_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
extern boolean _bfd_mips_elf_fake_sections
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
extern boolean _bfd_mips_elf_section_from_bfd_section
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *, int *));
extern boolean _bfd_mips_elf_section_processing
  PARAMS ((bfd *, Elf_Internal_Shdr *));
extern void _bfd_mips_elf_symbol_processing PARAMS ((bfd *, asymbol *));
extern boolean _bfd_mips_elf_read_ecoff_info
  PARAMS ((bfd *, asection *, struct ecoff_debug_info *));
extern void _bfd_mips_elf_final_write_processing PARAMS ((bfd *, boolean));
extern bfd_reloc_status_type _bfd_mips_elf_hi16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
extern bfd_reloc_status_type _bfd_mips_elf_lo16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
extern bfd_reloc_status_type _bfd_mips_elf_gprel16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
extern bfd_reloc_status_type _bfd_mips_elf_got16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
extern bfd_reloc_status_type _bfd_mips_elf_gprel32_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
extern boolean _bfd_mips_elf_set_private_flags PARAMS ((bfd *, flagword));
extern boolean _bfd_mips_elf_copy_private_bfd_data PARAMS ((bfd *, bfd *));
extern boolean _bfd_mips_elf_merge_private_bfd_data PARAMS ((bfd *, bfd *));
extern boolean _bfd_mips_elf_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
extern boolean _bfd_mips_elf_set_section_contents
  PARAMS ((bfd *, asection *, PTR, file_ptr, bfd_size_type));
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a837 2
extern Elf_Internal_Rela *_bfd_elf32_link_read_relocs
  PARAMS ((bfd *, asection *, PTR, Elf_Internal_Rela *, boolean));
a878 2
extern Elf_Internal_Rela *_bfd_elf64_link_read_relocs
  PARAMS ((bfd *, asection *, PTR, Elf_Internal_Rela *, boolean));
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a721 1
extern boolean bfd_section_from_phdr PARAMS ((bfd *, Elf_Internal_Phdr *, int));
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1992, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
a64 6

  /* Version information.  This is from an Elf_Internal_Versym
     structure in a SHT_GNU_versym section.  It is zero if there is no
     version information.  */
  unsigned short version;

a109 13
  /* Version information.  */
  union
  {
    /* This field is used for a symbol which is not defined in a
       regular object.  It points to the version information read in
       from the dynamic object.  */
    Elf_Internal_Verdef *verdef;
    /* This field is used for a symbol which is defined in a regular
       object.  It is set up in size_dynamic_sections.  It points to
       the version information we should write out for this symbol.  */
    struct bfd_elf_version_tree *vertree;
  } verinfo;

a112 3
  /* Symbol st_other value.  */
  unsigned char other;

d114 1
a114 1
  unsigned short elf_link_hash_flags;
d131 2
a132 4
  /* Symbol should be marked as hidden in the version information.  */
#define ELF_LINK_HIDDEN 0400
  /* Symbol was forced to local scope due to a version script file.  */
#define ELF_LINK_FORCED_LOCAL 01000
d196 1
a196 2
  boolean (*slurp_reloc_table)
    PARAMS ((bfd *, asection *, asymbol **, boolean));
a358 7
  /* The ALWAYS_SIZE_SECTIONS function is called by the backend linker
     after all the linker input files have been seen but before the
     section sizes have been set.  This is called after
     ADJUST_DYNAMIC_SYMBOL, but before SIZE_DYNAMIC_SECTIONS.  */
  boolean (*elf_backend_always_size_sections)
    PARAMS ((bfd *output_bfd, struct bfd_link_info *info));

a563 3
  Elf_Internal_Shdr dynversym_hdr;
  Elf_Internal_Shdr dynverref_hdr;
  Elf_Internal_Shdr dynverdef_hdr;
a565 1
  unsigned int dynversym_section, dynverdef_section, dynverref_section;
a617 5
  /* An array of stub sections indexed by symbol number, used by the
     MIPS ELF linker.  FIXME: We should figure out some way to only
     include this field for a MIPS ELF target.  */
  asection **local_stubs;

a620 12
  /* Number of symbol version definitions we are about to emit.  */
  int cverdefs;

  /* Number of symbol version references we are about to emit.  */
  int cverrefs;

  /* Symbol version definitions in external objects.  */
  Elf_Internal_Verdef *verdef;

  /* Symbol version references to external objects.  */
  Elf_Internal_Verneed *verref;

a630 3
#define elf_dynversym(bfd)	(elf_tdata(bfd) -> dynversym_section)
#define elf_dynverdef(bfd)	(elf_tdata(bfd) -> dynverdef_section)
#define elf_dynverref(bfd)	(elf_tdata(bfd) -> dynverref_section)
a645 21
extern void _bfd_elf_swap_verdef_in
  PARAMS ((bfd *, const Elf_External_Verdef *, Elf_Internal_Verdef *));
extern void _bfd_elf_swap_verdef_out
  PARAMS ((bfd *, const Elf_Internal_Verdef *, Elf_External_Verdef *));
extern void _bfd_elf_swap_verdaux_in
  PARAMS ((bfd *, const Elf_External_Verdaux *, Elf_Internal_Verdaux *));
extern void _bfd_elf_swap_verdaux_out
  PARAMS ((bfd *, const Elf_Internal_Verdaux *, Elf_External_Verdaux *));
extern void _bfd_elf_swap_verneed_in
  PARAMS ((bfd *, const Elf_External_Verneed *, Elf_Internal_Verneed *));
extern void _bfd_elf_swap_verneed_out
  PARAMS ((bfd *, const Elf_Internal_Verneed *, Elf_External_Verneed *));
extern void _bfd_elf_swap_vernaux_in
  PARAMS ((bfd *, const Elf_External_Vernaux *, Elf_Internal_Vernaux *));
extern void _bfd_elf_swap_vernaux_out
  PARAMS ((bfd *, const Elf_Internal_Vernaux *, Elf_External_Vernaux *));
extern void _bfd_elf_swap_versym_in
  PARAMS ((bfd *, const Elf_External_Versym *, Elf_Internal_Versym *));
extern void _bfd_elf_swap_versym_out
  PARAMS ((bfd *, const Elf_Internal_Versym *, Elf_External_Versym *));

d659 3
a684 1
extern boolean _bfd_elf_slurp_version_tables PARAMS ((bfd *));
a700 3
extern long _bfd_elf_get_dynamic_reloc_upper_bound PARAMS ((bfd *));
extern long _bfd_elf_canonicalize_dynamic_reloc PARAMS ((bfd *, arelent **,
							 asymbol **));
a703 1
extern boolean _bfd_elf_is_local_label_name PARAMS ((bfd *, const char *));
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 1999, 2000 Free Software
   Foundation, Inc.
a87 10
  /* ??? Note that this is consistently used as a synonym for tests
     against whether we can perform various simplifying transformations
     to the code.  (E.g. changing a pc-relative jump to a PLT entry
     into a pc-relative jump to the target function.)  That test, which
     is often relatively complex, and someplaces wrong or incomplete,
     should really be replaced by a predicate in elflink.c.

     End result: this field -1 does not indicate that the symbol is
     not in the dynamic symbol table, but rather that the symbol is
     not visible outside this DSO.  */
d99 11
a109 18
     processor specific backend uses this field to track usage and
     final offset.  We use a union and two names primarily to document
     the intent of any particular piece of code.  The field should be
     used as a count until size_dynamic_sections, at which point the
     contents of the .got is fixed.  Afterward, if this field is -1,
     then the symbol does not require a global offset table entry.  */
  union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
    } got;

  /* Same, but tracks a procedure linkage table entry.  */
  union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
    } plt;
a128 10
  /* Virtual table entry use information.  This array is nominally of size
     size/sizeof(target_void_pointer), though we have to be able to assume
     and track a size while the symbol is still undefined.  It is indexed
     via offset/sizeof(target_void_pointer).  */
  size_t vtable_entries_size;
  boolean *vtable_entries_used;

  /* Virtual table derivation info.  */
  struct elf_link_hash_entry *vtable_parent;

d132 1
a132 1
  /* Symbol st_other value, symbol visibility.  */
a134 3
  /* Hash value of the name computed using the ELF hash function.  */
  unsigned long elf_hash_value;

a144 2
  /* Symbol has a non-weak reference from a non-shared object.  */
#define ELF_LINK_HASH_REF_REGULAR_NONWEAK 020
d146 1
a146 1
#define ELF_LINK_HASH_DYNAMIC_ADJUSTED 040
d148 1
a148 1
#define ELF_LINK_HASH_NEEDS_COPY 0100
d150 1
a150 1
#define ELF_LINK_HASH_NEEDS_PLT 0200
d152 1
a152 1
#define ELF_LINK_NON_ELF 0400
d154 1
a154 1
#define ELF_LINK_HIDDEN 01000
d156 1
a156 25
#define ELF_LINK_FORCED_LOCAL 02000
  /* Symbol was marked during garbage collection.  */
#define ELF_LINK_HASH_MARK 04000
  /* Symbol is referenced by a non-GOT/non-PLT relocation.  This is
     not currently set by all the backends.  */
#define ELF_LINK_NON_GOT_REF 010000
};

/* Records local symbols to be emitted in the dynamic symbol table.  */

struct elf_link_local_dynamic_entry
{
  struct elf_link_local_dynamic_entry *next;

  /* The input bfd this symbol came from.  */
  bfd *input_bfd;

  /* The index of the local symbol being copied.  */
  long input_indx;

  /* The index in the outgoing dynamic symbol table.  */
  long dynindx;
  
  /* A copy of the input symbol.  */
  Elf_Internal_Sym isym;
a186 2
  /* A linked list of local symbols to be added to .dynsym.  */
  struct elf_link_local_dynamic_entry *dynlocal;
a213 7
  /* The size of entries in the .hash section.  */
  unsigned char sizeof_hash_entry;

  /* The number of internal relocations to allocate per external
     relocation entry.  */
  unsigned char int_rels_per_ext_rel;

a223 26
  void (*swap_dyn_out) PARAMS ((bfd *, const Elf_Internal_Dyn *, PTR));

  /* This function, if defined, is called to swap in a REL
     relocation.  If an external relocation corresponds to more than
     one internal relocation, then all relocations are swapped in at
     once.  */
  void (*swap_reloc_in)
    PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rel *));

  /* This function, if defined, is called to swap out a REL
     relocation.  */
  void (*swap_reloc_out)
    PARAMS ((bfd *, const Elf_Internal_Rel *, bfd_byte *));

  /* This function, if defined, is called to swap in a RELA
     relocation.  If an external relocation corresponds to more than
     one internal relocation, then all relocations are swapped in at
     once.  */
  void (*swap_reloca_in)
    PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));

  /* This function, if defined, is called to swap out a RELA
     relocation.  */
  void (*swap_reloca_out)
    PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));

d234 5
d248 12
a298 4
   /* A function to set the type of the info field.  Processor-specific
     types should be handled here. */
  int (*elf_backend_get_symbol_type) PARAMS (( Elf_Internal_Sym *, int)); 
 
a311 6
  /* A function to handle unusual program segment types when creating BFD
     sections from ELF program segments. */
  boolean (*elf_backend_section_from_phdr) PARAMS ((bfd *,
						    Elf32_Internal_Phdr *,
						    int));

a475 45
  /* This function is called during section gc to discover the section a
     particular relocation refers to.  It need not be defined for hosts
     that have no queer relocation types.  */
  asection * (*gc_mark_hook)
    PARAMS ((bfd *abfd, struct bfd_link_info *, Elf_Internal_Rela *,
	     struct elf_link_hash_entry *h, Elf_Internal_Sym *));

  /* This function, if defined, is called during the sweep phase of gc
     in order that a backend might update any data structures it might
     be maintaining.  */
  boolean (*gc_sweep_hook)
    PARAMS ((bfd *abfd, struct bfd_link_info *info, asection *o,
	     const Elf_Internal_Rela *relocs));

  /* This function, if defined, is called after the ELF headers have
     been created.  This allows for things like the OS and ABI versions
     to be changed.  */
  void (*elf_backend_post_process_headers)
    PARAMS ((bfd *, struct bfd_link_info *));

  /* This function, if defined, prints a symbol to file and returns the
     name of the symbol to be printed.  It should return NULL to fall
     back to default symbol printing.  */
  const char *(*elf_backend_print_symbol_all)
    PARAMS ((bfd *, PTR, asymbol *));

  /* This function, if defined, is called after all local symbols and
     global symbols converted to locals are emited into the symtab
     section.  It allows the backend to emit special global symbols
     not handled in the hash table.  */
  boolean (*elf_backend_output_arch_syms)
    PARAMS ((bfd *, struct bfd_link_info *, PTR,
	    boolean (*) PARAMS ((PTR, const char *,
             Elf_Internal_Sym *, asection *))));

  /* Copy any information related to dynamic linking from a pre-existing
     symbol IND to a newly created symbol DIR.  */
  void (*elf_backend_copy_indirect_symbol)
    PARAMS ((struct elf_link_hash_entry *, struct elf_link_hash_entry *));

  /* Modify any information related to dynamic linking such that the
     symbol is not exported.  */
  void (*elf_backend_hide_symbol)
    PARAMS ((struct elf_link_hash_entry *));

a485 42
  /* offset of the _GLOBAL_OFFSET_TABLE_ symbol from the start of the
     .got section */
  bfd_vma got_symbol_offset;

  /* The size in bytes of the headers for the GOT and PLT.  This includes
     the so-called reserved entries on some systems.  */
  bfd_vma got_header_size;
  bfd_vma plt_header_size;

  /* This is true if the linker should act like collect and gather
     global constructors and destructors by name.  This is true for
     MIPS ELF because the Irix 5 tools can not handle the .init
     section.  */
  unsigned collect : 1;

  /* This is true if the linker should ignore changes to the type of a
     symbol.  This is true for MIPS ELF because some Irix 5 objects
     record undefined functions as STT_OBJECT although the definitions
     are STT_FUNC.  */
  unsigned type_change_ok : 1;

  /* Whether the backend may use REL relocations.  (Some backends use
     both REL and RELA relocations, and this flag is set for those
     backends.)  */
  unsigned may_use_rel_p : 1;
    
  /* Whether the backend may use RELA relocations.  (Some backends use
     both REL and RELA relocations, and this flag is set for those
     backends.)  */
  unsigned may_use_rela_p : 1;

  /* Whether the default relocation type is RELA.  If a backend with
     this flag set wants REL relocations for a particular section,
     it must note that explicitly.  Similarly, if this flag is clear,
     and the backend wants RELA relocations for a particular 
     section.  */   
  unsigned default_use_rela_p : 1;

  /* True if addresses "naturally" sign extend.  This is used when
     swapping in from Elf32 when BFD64.  */
  unsigned sign_extend_vma : 1;

a488 4
  unsigned plt_not_loaded : 1;
  unsigned plt_alignment : 4;
  unsigned can_gc_sections : 1;
  unsigned want_dynbss : 1;
a503 4
  /* The number of relocations currently assigned to REL_HDR.  */
  unsigned int rel_count;
  /* The number of relocations currently assigned to REL_HDR2.  */
  unsigned int rel_count2;
d507 2
a508 2
  /* The ELF section number of the reloc section indicated by
     REL_HDR if any.  Only used for an output file.  */
a509 3
  /* The ELF section number of the reloc section indicated by
     REL_HDR2 if any.  Only used for an output file.  */
  int rel_idx2;
d519 1
a519 2
     corresponding to this section.  A value of 0 means that there is
     no dynamic symbol for this section.  */
a524 2
  /* Nonzero if this section uses RELA relocations, rather than REL.  */
  unsigned int use_rela_p:1;
d562 1
a562 1
  unsigned int alignment;		/* alignment for the section */
a602 3
#if 0
  /* we don't need these inside bfd anymore, and I think
     these weren't used outside bfd. */
a604 1
#endif
a607 7
  /* Information grabbed from an elf core file. */
  int core_signal;
  int core_pid;
  int core_lwpid;
  char* core_program;
  char* core_command;

d618 2
a619 11
     table, used when linking.  This is indexed by the symbol index.
     Like for the globals, we use a union and two names primarily to
     document the intent of any particular piece of code.  The field
     should be used as a count until size_dynamic_sections, at which
     point the contents of the .got is fixed.  Afterward, if an entry
     is -1, then the symbol does not require a global offset table entry. */
  union
    {
      bfd_signed_vma *refcounts;
      bfd_vma *offsets;
    } local_got;
a653 6
  /* A place to stash dwarf1 info for this bfd. */
  struct dwarf1_debug *dwarf1_find_line_info;

  /* A place to stash dwarf2 info for this bfd. */
  struct dwarf2_debug *dwarf2_find_line_info;

d663 1
a663 1
  unsigned int cverdefs;
d666 1
a666 1
  unsigned int cverrefs;
d695 1
a695 2
#define elf_local_got_refcounts(bfd) (elf_tdata(bfd) -> local_got.refcounts)
#define elf_local_got_offsets(bfd) (elf_tdata(bfd) -> local_got.offsets)
d737 1
a737 1
extern unsigned long bfd_elf_hash PARAMS ((const char *));
a746 1
extern boolean bfd_elf_mkcorefile PARAMS ((bfd *));
a749 2
extern boolean _bfd_elf_make_section_from_phdr
  PARAMS ((bfd *abfd, Elf_Internal_Phdr *hdr, int index, const char *typename));
a753 4
extern void _bfd_elf_link_hash_copy_indirect
  PARAMS ((struct elf_link_hash_entry *, struct elf_link_hash_entry *));
extern void _bfd_elf_link_hash_hide_symbol
  PARAMS ((struct elf_link_hash_entry *));
a765 1
extern boolean _bfd_elf_write_corefile_contents PARAMS ((bfd *));
a794 2
extern boolean _bfd_elf_init_reloc_shdr 
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *, boolean));
a811 3
long
_bfd_elf_link_lookup_local_dynindx PARAMS ((struct bfd_link_info *,
					    bfd *, long));
a825 2
unsigned long _bfd_elf_link_renumber_dynsyms PARAMS ((bfd *,
						      struct bfd_link_info *));
a876 3
boolean _bfd_elfcore_section_from_phdr
  PARAMS ((bfd *, Elf_Internal_Phdr *, int));

d908 1
a908 1
  PARAMS ((bfd *, const Elf_Internal_Dyn *, PTR));
d951 1
a951 1
  PARAMS ((bfd *, const Elf_Internal_Dyn *, PTR));
d964 2
a965 36
#define bfd_elf32_link_record_dynamic_symbol \
  _bfd_elf_link_record_dynamic_symbol
#define bfd_elf64_link_record_dynamic_symbol \
  _bfd_elf_link_record_dynamic_symbol

boolean _bfd_elf32_link_record_local_dynamic_symbol
  PARAMS ((struct bfd_link_info *, bfd *, long));
boolean _bfd_elf64_link_record_local_dynamic_symbol
  PARAMS ((struct bfd_link_info *, bfd *, long));

extern boolean _bfd_elf_close_and_cleanup PARAMS ((bfd *));
extern bfd_reloc_status_type _bfd_elf_rel_vtable_reloc_fn
  PARAMS ((bfd *, arelent *, struct symbol_cache_entry *, PTR,
           asection *, bfd *, char **));

boolean _bfd_elf32_gc_sections
  PARAMS ((bfd *abfd, struct bfd_link_info *info));
boolean _bfd_elf32_gc_common_finalize_got_offsets
  PARAMS ((bfd *abfd, struct bfd_link_info *info));
boolean _bfd_elf32_gc_common_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
boolean _bfd_elf32_gc_record_vtinherit
  PARAMS ((bfd *, asection *, struct elf_link_hash_entry *, bfd_vma));
boolean _bfd_elf32_gc_record_vtentry
  PARAMS ((bfd *, asection *, struct elf_link_hash_entry *, bfd_vma));

boolean _bfd_elf64_gc_sections
  PARAMS ((bfd *abfd, struct bfd_link_info *info));
boolean _bfd_elf64_gc_common_finalize_got_offsets
  PARAMS ((bfd *abfd, struct bfd_link_info *info));
boolean _bfd_elf64_gc_common_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
boolean _bfd_elf64_gc_record_vtinherit
  PARAMS ((bfd *, asection *, struct elf_link_hash_entry *, bfd_vma));
boolean _bfd_elf64_gc_record_vtentry
  PARAMS ((bfd *, asection *, struct elf_link_hash_entry *, bfd_vma));
d971 1
a971 1
  PARAMS ((bfd *, Elf_Internal_Shdr *, char *));
a999 43
extern boolean _bfd_mips_elf_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
extern boolean _bfd_mips_elf_add_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
	   const char **, flagword *, asection **, bfd_vma *));
extern boolean _bfd_mips_elf_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
extern boolean _bfd_mips_elf_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
extern boolean _bfd_mips_elf_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
extern asection * _bfd_mips_elf_gc_mark_hook 
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
extern boolean _bfd_mips_elf_gc_sweep_hook 
  PARAMS ((bfd *, struct bfd_link_info *, asection *, 
	   const Elf_Internal_Rela *));
extern boolean _bfd_mips_elf_always_size_sections
  PARAMS ((bfd *, struct bfd_link_info *));
extern boolean _bfd_mips_elf_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
extern boolean _bfd_mips_elf_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
extern struct bfd_link_hash_table *_bfd_mips_elf_link_hash_table_create
  PARAMS ((bfd *));
extern boolean _bfd_mips_elf_print_private_bfd_data 
  PARAMS ((bfd *, PTR));
extern boolean _bfd_mips_elf_link_output_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, const char *, Elf_Internal_Sym *,
	   asection *));
extern boolean _bfd_mips_elf_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
extern int _bfd_mips_elf_additional_program_headers PARAMS ((bfd *));
extern boolean _bfd_mips_elf_modify_segment_map PARAMS ((bfd *));
extern boolean _bfd_mips_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));

/* SH ELF specific routine.  */

extern boolean _sh_elf_set_mach_from_flags PARAMS ((bfd *));
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 2
a3 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
a29 5
/* The number of entries in a section is its size divided by the size
   of a single entry.  This is normally only applicaable to reloc and
   symbol table sections.  */
#define NUM_SHDR_ENTRIES(shdr) ((shdr)->sh_size / (shdr)->sh_entsize)

d211 1
a211 1

a245 3
  /* A linked list of DT_RPATH/DT_RUNPATH names found in dynamic
     objects included in the link.  */
  struct bfd_link_needed_list *runpath;
d375 3
a377 3
     types should be handled here.  */
  int (*elf_backend_get_symbol_type) PARAMS (( Elf_Internal_Sym *, int));

a390 5
  /* A function to convert machine dependent section header flags to
     BFD internal section header flags.  */
  boolean (*elf_backend_section_flags) PARAMS ((flagword *,
						Elf32_Internal_Shdr *));

d392 1
a392 1
     sections from ELF program segments.  */
d604 1
a604 1
    PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
d641 1
a641 1

d650 2
a651 2
     and the backend wants RELA relocations for a particular
     section.  */
d791 1
a791 1
     these weren't used outside bfd.  */
d798 1
a798 1
  /* Information grabbed from an elf core file.  */
d820 1
a820 1
     is -1, then the symbol does not require a global offset table entry.  */
a840 8
  /* When a reference in a regular object is resolved by a shared
     object is loaded into via the DT_NEEDED entries by the linker
     ELF emulation code, we need to add the shared object to the
     DT_NEEDED list of the resulting binary to indicate the dependency
     as if the -l option is passed to the linker. This field holds the
     name of the loaded shared object.  */
  const char *dt_soname;

d860 1
a860 1
  /* A place to stash dwarf1 info for this bfd.  */
d863 2
a864 2
  /* A place to stash dwarf2 info for this bfd.  */
  PTR dwarf2_find_line_info;
a887 7

  /* The Irix 5 support uses two virtual sections, which represent
     text/data symbols defined in dynamic objects.  */
  asymbol *elf_data_symbol;
  asymbol *elf_text_symbol;
  asection *elf_data_section;
  asection *elf_text_section;
a910 1
#define elf_dt_soname(bfd)	(elf_tdata(bfd) -> dt_soname)
d973 1
a973 1
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
d1009 2
a1010 2
						    bfd_vma, const char **,
						    const char **,
d1016 1
a1016 1
extern boolean _bfd_elf_init_reloc_shdr
a1144 4
extern void bfd_elf32_write_relocs
  PARAMS ((bfd *, asection *, PTR));
extern boolean bfd_elf32_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, boolean));
a1187 4
extern void bfd_elf64_write_relocs
  PARAMS ((bfd *, asection *, PTR));
extern boolean bfd_elf64_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, boolean));
d1277 1
a1277 1
extern asection * _bfd_mips_elf_gc_mark_hook
d1280 2
a1281 2
extern boolean _bfd_mips_elf_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
d1292 1
a1292 1
extern boolean _bfd_mips_elf_print_private_bfd_data
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 2
a3 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003 Free Software Foundation, Inc.
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 1
a31 1
   of a single entry.  This is normally only applicable to reloc and
a35 3
/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
d38 1
a38 1
#define NAME(x,y) CONCAT4 (x,64,_,y)
d41 1
a41 1
#define NAME(x,y) CONCAT4 (x,32,_,y)
d46 1
a46 1
#define NAME(x,y) CONCAT4 (x,NOSIZE,_,y)
a78 4
struct elf_strtab_hash;
struct got_entry;
struct plt_entry;

d89 3
a108 3
  /* Hash value of the name computed using the ELF hash function.  */
  unsigned long elf_hash_value;

d114 20
d157 1
a157 1
  bfd_boolean *vtable_entries_used;
a161 23
  /* If this symbol requires an entry in the global offset table, the
     processor specific backend uses this field to track usage and
     final offset.  Two schemes are supported:  The first assumes that
     a symbol may only have one GOT entry, and uses REFCOUNT until
     size_dynamic_sections, at which point the contents of the .got is
     fixed.  Afterward, if OFFSET is -1, then the symbol does not
     require a global offset table entry.  The second scheme allows
     multiple GOT entries per symbol, managed via a linked list
     pointed to by GLIST.  */
  union gotplt_union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
      struct got_entry *glist;
      struct plt_entry *plist;
    } got;

  /* Same, but tracks a procedure linkage table entry.  */
  union gotplt_union plt;

  /* Symbol size.  */
  bfd_size_type size;

d168 3
a199 4
  /* Symbol has a definition in a shared object.  */
#define ELF_LINK_DYNAMIC_DEF 020000
  /* Symbol is weak in all shared objects.  */
#define ELF_LINK_DYNAMIC_WEAK 040000
a220 83
struct elf_link_loaded_list
{
  struct elf_link_loaded_list *next;
  bfd *abfd;
};

/* Structures used by the eh_frame optimization code.  */
struct cie_header
{
  unsigned int length;
  unsigned int id;
};

struct cie
{
  struct cie_header hdr;
  unsigned char version;
  unsigned char augmentation[20];
  unsigned int code_align;
  int data_align;
  unsigned int ra_column;
  unsigned int augmentation_size;
  struct elf_link_hash_entry *personality;
  unsigned char per_encoding;
  unsigned char lsda_encoding;
  unsigned char fde_encoding;
  unsigned char initial_insn_length;
  unsigned char make_relative;
  unsigned char make_lsda_relative;
  unsigned char initial_instructions[50];
};

struct eh_cie_fde
{
  unsigned int offset;
  unsigned int size;
  asection *sec;
  unsigned int new_offset;
  unsigned char fde_encoding;
  unsigned char lsda_encoding;
  unsigned char lsda_offset;
  unsigned char cie : 1;
  unsigned char removed : 1;
  unsigned char make_relative : 1;
  unsigned char make_lsda_relative : 1;
  unsigned char per_encoding_relative : 1;
};

struct eh_frame_sec_info
{
  unsigned int count;
  unsigned int alloced;
  struct eh_cie_fde entry[1];
};

struct eh_frame_array_ent
{
  bfd_vma initial_loc;
  bfd_vma fde;
};

struct eh_frame_hdr_info
{
  struct cie last_cie;
  asection *last_cie_sec;
  asection *hdr_sec;
  unsigned int last_cie_offset;
  unsigned int fde_count, array_count;
  struct eh_frame_array_ent *array;
  /* TRUE if .eh_frame_hdr should contain the sorted search table.
     We build it if we successfully read all .eh_frame input sections
     and recognize them.  */
  bfd_boolean table;
};

/* Cached start, size and alignment of PT_TLS segment.  */
struct elf_link_tls_segment
{
  bfd_vma start;
  bfd_size_type size;
  unsigned int align;
};

a225 1

d228 1
a228 2
  bfd_boolean dynamic_sections_created;

a232 11

  /* The value to use when initialising got.refcount/offset and
     plt.refcount/offset in an elf_link_hash_entry.  Set to zero when
     the values are refcounts.  Set to init_offset in
     size_dynamic_sections when the values may be offsets.  */
  union gotplt_union init_refcount;

  /* The value to use for got.refcount/offset and plt.refcount/offset
     when the values may be offsets.  Normally (bfd_vma) -1.  */
  union gotplt_union init_offset;

a235 1

d238 1
a238 2
  struct elf_strtab_hash *dynstr;

a241 1

a244 1

a246 1

a248 7

  /* A pointer to information used to merge SEC_MERGE sections.  */
  PTR merge_info;

  /* Used by eh_frame code when editing .eh_frame.  */
  struct eh_frame_hdr_info eh_info;

a250 1

a253 6

  /* Cached start, size and alignment of PT_TLS segment.  */
  struct elf_link_tls_segment *tls_segment;

  /* A linked list of BFD's loaded in the link.  */
  struct elf_link_loaded_list *loaded;
d268 1
a268 1
    (bfd_boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func), \
a273 14

/* Returns TRUE if the hash table is a struct elf_link_hash_table.  */
#define is_elf_hash_table(p)					      	\
  ((p)->hash->type == bfd_link_elf_hash_table)

/* Used by bfd_section_from_r_symndx to cache a small number of local
   symbol to section mappings.  */
#define LOCAL_SYM_CACHE_SIZE 32
struct sym_sec_cache
{
  bfd *abfd;
  unsigned long indx[LOCAL_SYM_CACHE_SIZE];
  asection *sec[LOCAL_SYM_CACHE_SIZE];
};
a286 3
  /* We use some fixed size arrays.  This should be large enough to
     handle all back-ends.  */
#define MAX_INT_RELS_PER_EXT_REL 3
d290 14
a303 22
  int (*write_out_phdrs)
    PARAMS ((bfd *, const Elf_Internal_Phdr *, unsigned int));
  bfd_boolean (*write_shdrs_and_ehdr)
    PARAMS ((bfd *));
  void (*write_relocs)
    PARAMS ((bfd *, asection *, PTR));
  void (*swap_symbol_in)
    PARAMS ((bfd *, const PTR, const PTR, Elf_Internal_Sym *));
  void (*swap_symbol_out)
    PARAMS ((bfd *, const Elf_Internal_Sym *, PTR, PTR));
  bfd_boolean (*slurp_reloc_table)
    PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
  long (*slurp_symbol_table)
    PARAMS ((bfd *, asymbol **, bfd_boolean));
  void (*swap_dyn_in)
    PARAMS ((bfd *, const PTR, Elf_Internal_Dyn *));
  void (*swap_dyn_out)
    PARAMS ((bfd *, const Elf_Internal_Dyn *, PTR));

  /* This function is called to swap in a REL relocation.  If an
     external relocation corresponds to more than one internal
     relocation, then all relocations are swapped in at once.  */
d305 1
a305 1
    PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
d307 2
a308 1
  /* This function is called to swap out a REL relocation.  */
d310 1
a310 1
    PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d312 4
a315 3
  /* This function is called to swap in a RELA relocation.  If an
     external relocation corresponds to more than one internal
     relocation, then all relocations are swapped in at once.  */
d319 2
a320 1
  /* This function is called to swap out a RELA relocation.  */
d323 1
a331 26
enum elf_reloc_type_class {
  reloc_class_normal,
  reloc_class_relative,
  reloc_class_plt,
  reloc_class_copy
};

struct elf_reloc_cookie
{
  Elf_Internal_Rela *rels, *rel, *relend;
  Elf_Internal_Sym *locsyms;
  bfd *abfd;
  size_t locsymcount;
  size_t extsymoff;
  struct elf_link_hash_entry **sym_hashes;
  bfd_boolean bad_symtab;
};

/* The level of IRIX compatibility we're striving for.  */

typedef enum {
  ict_none,
  ict_irix5,
  ict_irix6
} irix_compat_t;

d345 2
a346 2
  void (*elf_info_to_howto)
    PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d350 2
a351 2
  void (*elf_info_to_howto_rel)
    PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d358 1
a358 2
  bfd_boolean (*elf_backend_sym_is_global)
    PARAMS ((bfd *, asymbol *));
d367 1
a367 1
     used with caution.  If this returns FALSE, the check_format
d369 1
a369 2
  bfd_boolean (*elf_backend_object_p)
    PARAMS ((bfd *));
d374 1
a374 2
  void (*elf_backend_symbol_processing)
    PARAMS ((bfd *, asymbol *));
d378 3
a380 2
  bfd_boolean (*elf_backend_symbol_table_processing)
    PARAMS ((bfd *, elf_symbol_type *, unsigned int));
d384 1
a384 2
  int (*elf_backend_get_symbol_type)
    PARAMS (( Elf_Internal_Sym *, int));
d390 2
a391 2
  bfd_boolean (*elf_backend_section_processing)
    PARAMS ((bfd *, Elf_Internal_Shdr *));
d395 3
a397 2
  bfd_boolean (*elf_backend_section_from_shdr)
    PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
d401 2
a402 2
  bfd_boolean (*elf_backend_section_flags)
    PARAMS ((flagword *, Elf_Internal_Shdr *));
d406 3
a408 2
  bfd_boolean (*elf_backend_section_from_phdr)
    PARAMS ((bfd *, Elf_Internal_Phdr *, int));
d413 2
a414 2
  bfd_boolean (*elf_backend_fake_sections)
    PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
d417 1
a417 1
     this returns TRUE, the section was found.  If it is a normal ELF
d420 2
a421 2
  bfd_boolean (*elf_backend_section_from_bfd_section)
    PARAMS ((bfd *, asection *, int *retval));
d431 1
a431 1
  bfd_boolean (*elf_add_symbol_hook)
d438 1
a438 1
  bfd_boolean (*elf_backend_link_output_symbol_hook)
d450 1
a450 1
  bfd_boolean (*elf_backend_create_dynamic_sections)
d463 1
a463 1
  bfd_boolean (*check_relocs)
d479 1
a479 1
  bfd_boolean (*elf_backend_adjust_dynamic_symbol)
d486 1
a486 1
  bfd_boolean (*elf_backend_always_size_sections)
d499 1
a499 1
  bfd_boolean (*elf_backend_size_dynamic_sections)
d530 1
a530 1
  bfd_boolean (*elf_backend_relocate_section)
d543 1
a543 1
  bfd_boolean (*elf_backend_finish_dynamic_symbol)
d551 1
a551 1
  bfd_boolean (*elf_backend_finish_dynamic_sections)
d560 1
a560 1
     before writing it out.  The LINKER argument is TRUE if this BFD
d563 1
a563 1
    PARAMS ((bfd *, bfd_boolean linker));
d568 1
a568 2
  int (*elf_backend_additional_program_headers)
    PARAMS ((bfd *));
d572 1
a572 2
  bfd_boolean (*elf_backend_modify_segment_map)
    PARAMS ((bfd *));
d575 2
a576 1
     particular relocation refers to.  */
d578 1
a578 1
    PARAMS ((asection *sec, struct bfd_link_info *, Elf_Internal_Rela *,
d584 1
a584 1
  bfd_boolean (*gc_sweep_hook)
d604 1
a604 1
  bfd_boolean (*elf_backend_output_arch_syms)
d606 2
a607 1
	    bfd_boolean (*) (PTR, const char *, Elf_Internal_Sym *, asection *)));
d610 1
a610 4
     symbol to a newly created symbol.  Also called to copy flags and
     other back-end info to a weakdef, in which case the symbol is not
     newly created and plt/got refcounts and dynamic indices should not
     be copied.  */
d612 1
a612 2
    PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	     struct elf_link_hash_entry *));
d617 1
a617 54
    PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean));

  /* Emit relocations.  Overrides default routine for emitting relocs,
     except during a relocatable link, or if all relocs are being emitted.  */
  bfd_boolean (*elf_backend_emit_relocs)
    PARAMS ((bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *));

  /* Count relocations.  Not called for relocatable links
     or if all relocs are being preserved in the output.  */
  unsigned int (*elf_backend_count_relocs)
    PARAMS ((asection *, Elf_Internal_Rela *));

  /* This function, if defined, is called when an NT_PRSTATUS note is found
     in a core file. */
  bfd_boolean (*elf_backend_grok_prstatus)
    PARAMS ((bfd *, Elf_Internal_Note *));

  /* This function, if defined, is called when an NT_PSINFO or NT_PRPSINFO
     note is found in a core file. */
  bfd_boolean (*elf_backend_grok_psinfo)
    PARAMS ((bfd *, Elf_Internal_Note *));

  /* Functions to print VMAs.  Special code to handle 64 bit ELF files.  */
  void (* elf_backend_sprintf_vma)
    PARAMS ((bfd *, char *, bfd_vma));
  void (* elf_backend_fprintf_vma)
    PARAMS ((bfd *, PTR, bfd_vma));

  /* This function returns class of a reloc type.  */
  enum elf_reloc_type_class (*elf_backend_reloc_type_class)
    PARAMS ((const Elf_Internal_Rela *));

  /* This function, if defined, removes information about discarded functions
     from other sections which mention them.  */
  bfd_boolean (*elf_backend_discard_info)
    PARAMS ((bfd *, struct elf_reloc_cookie *, struct bfd_link_info *));

  /* This function, if defined, signals that the function above has removed
     the discarded relocations for this section.  */
  bfd_boolean (*elf_backend_ignore_discarded_relocs)
    PARAMS ((asection *));

  /* This function, if defined, may write out the given section.
     Returns TRUE if it did so and FALSE if the caller should.  */
  bfd_boolean (*elf_backend_write_section)
    PARAMS ((bfd *, asection *, bfd_byte *));

  /* The level of IRIX compatibility we're striving for.
     MIPS ELF specific function.  */
  irix_compat_t (*elf_backend_mips_irix_compat)
    PARAMS ((bfd *));

  reloc_howto_type *(*elf_backend_mips_rtype_to_howto)
    PARAMS ((unsigned int, bfd_boolean));
d638 2
a639 2
  /* This is TRUE if the linker should act like collect and gather
     global constructors and destructors by name.  This is TRUE for
d644 2
a645 2
  /* This is TRUE if the linker should ignore changes to the type of a
     symbol.  This is TRUE for MIPS ELF because some Irix 5 objects
d667 1
a667 6
  /* Set if RELA relocations for a relocatable link can be handled by
     generic code.  Backends that set this flag need do nothing in the
     backend relocate_section routine for relocatable linking.  */
  unsigned rela_normal : 1;

  /* TRUE if addresses "naturally" sign extend.  This is used when
a676 2
  unsigned can_refcount : 1;
  unsigned want_got_sym : 1;
a677 4
    /* Targets which do not support physical addressing often require
       that the p_paddr field in the section header to be set to zero.
       This field indicates whether this behavior is required.  */
  unsigned want_p_paddr_set_to_zero : 1;
a686 1

a689 1

a692 1

a694 1

a696 1

a699 1

a702 1

a705 7

  /* Used by the backend linker when generating a shared library to
     record the dynamic symbol index for a section symbol
     corresponding to this section.  A value of 0 means that there is
     no dynamic symbol for this section.  */
  int dynindx;

a708 1

d713 11
a723 22

  /* A pointer to a linked list tracking dynamic relocs copied for
     local symbols.  */
  PTR local_dynrel;

  /* A pointer to the bfd section used for dynamic relocs.  */
  asection *sreloc;

  union {
    /* Group name, if this section is a member of a group.  */
    const char *name;

    /* Group signature sym, if this is the SHT_GROUP section.  */
    struct symbol_cache_entry *id;
  } group;

  /* A linked list of sections in the group.  Circular when used by
     the linker.  */
  asection *next_in_group;

  /* A pointer used for various section optimizations.  */
  PTR sec_info;
a726 10
#define elf_group_name(sec)    (elf_section_data(sec)->group.name)
#define elf_group_id(sec)      (elf_section_data(sec)->group.id)
#define elf_next_in_group(sec) (elf_section_data(sec)->next_in_group)

/* Return TRUE if section has been discarded.  */
#define elf_discarded_section(sec)				\
  (!bfd_is_abs_section (sec)					\
   && bfd_is_abs_section ((sec)->output_section)		\
   && sec->sec_info_type != ELF_INFO_TYPE_MERGE			\
   && sec->sec_info_type != ELF_INFO_TYPE_JUST_SYMS)
d760 1
a760 1
  bfd_boolean hole_written_p;		/* whether the hole has been initialized */
d772 1
a772 1
  bfd_vma addend;				/* addend used */
d774 1
a774 1
  bfd_boolean written_address_p;		/* whether address was written yet */
d786 1
a786 1
  struct elf_strtab_hash *strtab_ptr;
a788 2
  unsigned int num_elf_sections;	/* elf_sect_ptr size */
  int num_section_syms;
a797 1
  Elf_Internal_Shdr symtab_shndx_hdr;
a799 1
  unsigned int symtab_shndx_section;
d808 2
a809 5
  bfd_vma gp;				/* The gp value */
  unsigned int gp_size;			/* The gp size */

  Elf_Internal_Shdr **group_sect_ptr;
  int num_group;
d818 1
a818 1
  /* This is set to TRUE if the object was created by the backend
d820 1
a820 1
  bfd_boolean linker;
d827 7
a833 3
  /* Track usage and final offsets of GOT entries for local symbols.
     This array is indexed by symbol index.  Elements are used
     identically to "got" in struct elf_link_hash_entry.  */
a837 1
      struct got_entry **ents;
d867 1
a867 1
  bfd_boolean bad_symtab;
a891 4
  /* Used to determine if PT_GNU_EH_FRAME segment header should be
     created.  */
  asection *eh_frame_hdr;

d893 1
a893 1
  bfd_boolean flags_init;
a920 1
#define elf_numsections(bfd)	(elf_tdata(bfd) -> num_elf_sections)
a922 1
#define elf_symtab_shndx(bfd)	(elf_tdata(bfd) -> symtab_shndx_section)
a929 1
#define elf_num_section_syms(bfd) (elf_tdata(bfd) -> num_section_syms)
a936 1
#define elf_local_got_ents(bfd) (elf_tdata(bfd) -> local_got.ents)
d965 1
a965 2
extern int _bfd_elf_section_from_bfd_section
  PARAMS ((bfd *, asection *));
d968 1
a968 14
extern char *bfd_elf_get_str_section
  PARAMS ((bfd *, unsigned));
extern Elf_Internal_Sym *bfd_elf_get_elf_syms
  PARAMS ((bfd *, Elf_Internal_Shdr *, size_t, size_t,
	   Elf_Internal_Sym *, PTR, Elf_External_Sym_Shndx *));
extern const char *bfd_elf_local_sym_name
  PARAMS ((bfd *, Elf_Internal_Sym *));

extern bfd_boolean _bfd_elf_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
extern bfd_boolean _bfd_elf_print_private_bfd_data
  PARAMS ((bfd *, PTR));
extern void bfd_elf_print_symbol
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
d970 5
a974 3
#define elf_string_from_elf_strtab(abfd, strindex) \
  bfd_elf_string_from_elf_section(abfd, elf_elfheader(abfd)->e_shstrndx, \
				  strindex)
d979 1
a979 16
extern void _bfd_elf_sprintf_vma
  PARAMS ((bfd *, char *, bfd_vma));
extern void _bfd_elf_fprintf_vma
  PARAMS ((bfd *, PTR, bfd_vma));

extern enum elf_reloc_type_class _bfd_elf_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
extern bfd_vma _bfd_elf_rela_local_sym
  PARAMS ((bfd *, Elf_Internal_Sym *, asection *, Elf_Internal_Rela *));
extern bfd_vma _bfd_elf_rel_local_sym
  PARAMS ((bfd *, Elf_Internal_Sym *, asection **, bfd_vma));
extern bfd_vma _bfd_elf_section_offset
  PARAMS ((bfd *, struct bfd_link_info *, asection *, bfd_vma));

extern unsigned long bfd_elf_hash
  PARAMS ((const char *));
d981 14
a994 12
extern bfd_reloc_status_type bfd_elf_generic_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
extern bfd_boolean bfd_elf_mkobject
  PARAMS ((bfd *));
extern bfd_boolean bfd_elf_mkcorefile
  PARAMS ((bfd *));
extern Elf_Internal_Shdr *bfd_elf_find_section
  PARAMS ((bfd *, char *));
extern bfd_boolean _bfd_elf_make_section_from_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
extern bfd_boolean _bfd_elf_make_section_from_phdr
  PARAMS ((bfd *, Elf_Internal_Phdr *, int, const char *));
d1000 1
a1000 2
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
d1002 2
a1003 2
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean));
extern bfd_boolean _bfd_elf_link_hash_table_init
d1008 3
a1010 11
extern bfd_boolean _bfd_elf_slurp_version_tables
  PARAMS ((bfd *));
extern bfd_boolean _bfd_elf_merge_sections
  PARAMS ((bfd *, struct bfd_link_info *));
extern bfd_boolean bfd_elf_discard_group
  PARAMS ((bfd *, struct sec *));
extern void bfd_elf_set_group_contents
  PARAMS ((bfd *, asection *, PTR));
extern void _bfd_elf_link_just_syms
  PARAMS ((asection *, struct bfd_link_info *));
extern bfd_boolean _bfd_elf_copy_private_symbol_data
d1012 1
a1012 1
extern bfd_boolean _bfd_elf_copy_private_section_data
d1014 27
a1040 35
extern bfd_boolean _bfd_elf_write_object_contents
  PARAMS ((bfd *));
extern bfd_boolean _bfd_elf_write_corefile_contents
  PARAMS ((bfd *));
extern bfd_boolean _bfd_elf_set_section_contents
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
extern long _bfd_elf_get_symtab_upper_bound
  PARAMS ((bfd *));
extern long _bfd_elf_get_symtab
  PARAMS ((bfd *, asymbol **));
extern long _bfd_elf_get_dynamic_symtab_upper_bound
  PARAMS ((bfd *));
extern long _bfd_elf_canonicalize_dynamic_symtab
  PARAMS ((bfd *, asymbol **));
extern long _bfd_elf_get_reloc_upper_bound
  PARAMS ((bfd *, sec_ptr));
extern long _bfd_elf_canonicalize_reloc
  PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));
extern long _bfd_elf_get_dynamic_reloc_upper_bound
  PARAMS ((bfd *));
extern long _bfd_elf_canonicalize_dynamic_reloc
  PARAMS ((bfd *, arelent **, asymbol **));
extern asymbol *_bfd_elf_make_empty_symbol
  PARAMS ((bfd *));
extern void _bfd_elf_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
extern bfd_boolean _bfd_elf_is_local_label_name
  PARAMS ((bfd *, const char *));
extern alent *_bfd_elf_get_lineno
  PARAMS ((bfd *, asymbol *));
extern bfd_boolean _bfd_elf_set_arch_mach
  PARAMS ((bfd *, enum bfd_architecture, unsigned long));
extern bfd_boolean _bfd_elf_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
d1043 4
a1046 6
extern int _bfd_elf_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
extern bfd_boolean _bfd_elf_new_section_hook
  PARAMS ((bfd *, asection *));
extern bfd_boolean _bfd_elf_init_reloc_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *, bfd_boolean));
d1049 2
a1050 2
extern void _bfd_elf_no_info_to_howto
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d1052 2
a1053 4
extern bfd_boolean bfd_section_from_shdr
  PARAMS ((bfd *, unsigned int shindex));
extern bfd_boolean bfd_section_from_phdr
  PARAMS ((bfd *, Elf_Internal_Phdr *, int));
d1055 1
a1055 2
extern int _bfd_elf_symbol_from_bfd_symbol
  PARAMS ((bfd *, asymbol **));
d1057 76
a1132 8
extern asection *bfd_section_from_r_symndx
  PARAMS ((bfd *, struct sym_sec_cache *, asection *, unsigned long));
extern asection *bfd_section_from_elf_index
  PARAMS ((bfd *, unsigned int));
extern bfd_boolean _bfd_elf_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
extern struct bfd_strtab_hash *_bfd_elf_stringtab_init
  PARAMS ((void));
d1134 2
a1135 34
extern struct elf_strtab_hash * _bfd_elf_strtab_init
  PARAMS ((void));
extern void _bfd_elf_strtab_free
  PARAMS ((struct elf_strtab_hash *));
extern bfd_size_type _bfd_elf_strtab_add
  PARAMS ((struct elf_strtab_hash *, const char *, bfd_boolean));
extern void _bfd_elf_strtab_addref
  PARAMS ((struct elf_strtab_hash *, bfd_size_type));
extern void _bfd_elf_strtab_delref
  PARAMS ((struct elf_strtab_hash *, bfd_size_type));
extern void _bfd_elf_strtab_clear_all_refs
  PARAMS ((struct elf_strtab_hash *));
extern bfd_size_type _bfd_elf_strtab_size
  PARAMS ((struct elf_strtab_hash *));
extern bfd_size_type _bfd_elf_strtab_offset
  PARAMS ((struct elf_strtab_hash *, bfd_size_type));
extern bfd_boolean _bfd_elf_strtab_emit
  PARAMS ((bfd *, struct elf_strtab_hash *));
extern void _bfd_elf_strtab_finalize
  PARAMS ((struct elf_strtab_hash *));

extern bfd_boolean _bfd_elf_discard_section_eh_frame
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   bfd_boolean (*) (bfd_vma, PTR), struct elf_reloc_cookie *));
extern bfd_boolean _bfd_elf_discard_section_eh_frame_hdr
  PARAMS ((bfd *, struct bfd_link_info *));
extern bfd_vma _bfd_elf_eh_frame_section_offset
  PARAMS ((bfd *, asection *, bfd_vma));
extern bfd_boolean _bfd_elf_write_section_eh_frame
  PARAMS ((bfd *, struct bfd_link_info *, asection *, bfd_byte *));
extern bfd_boolean _bfd_elf_write_section_eh_frame_hdr
  PARAMS ((bfd *, struct bfd_link_info *));
extern bfd_boolean _bfd_elf_maybe_strip_eh_frame_hdr
  PARAMS ((struct bfd_link_info *));
d1137 6
a1142 65
extern bfd_boolean _bfd_elf_link_record_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
extern long _bfd_elf_link_lookup_local_dynindx
  PARAMS ((struct bfd_link_info *, bfd *, long));
extern bfd_boolean _bfd_elf_compute_section_file_positions
  PARAMS ((bfd *, struct bfd_link_info *));
extern void _bfd_elf_assign_file_positions_for_relocs
  PARAMS ((bfd *));
extern file_ptr _bfd_elf_assign_file_position_for_section
  PARAMS ((Elf_Internal_Shdr *, file_ptr, bfd_boolean));

extern bfd_boolean _bfd_elf_validate_reloc
  PARAMS ((bfd *, arelent *));

extern bfd_boolean _bfd_elf_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
extern bfd_boolean _bfd_elf_create_got_section
  PARAMS ((bfd *, struct bfd_link_info *));
extern unsigned long _bfd_elf_link_renumber_dynsyms
  PARAMS ((bfd *, struct bfd_link_info *));

extern bfd_boolean _bfd_elfcore_make_pseudosection
  PARAMS ((bfd *, char *, size_t, ufile_ptr));
extern char *_bfd_elfcore_strndup
  PARAMS ((bfd *, char *, size_t));

extern elf_linker_section_t *_bfd_elf_create_linker_section
  PARAMS ((bfd *, struct bfd_link_info *, enum elf_linker_section_enum,
	   elf_linker_section_t *));

extern elf_linker_section_pointers_t *_bfd_elf_find_pointer_linker_section
  PARAMS ((elf_linker_section_pointers_t *, bfd_vma,
	   elf_linker_section_enum_t));

extern bfd_boolean bfd_elf32_create_pointer_linker_section
  PARAMS ((bfd *, struct bfd_link_info *, elf_linker_section_t *,
	   struct elf_link_hash_entry *, const Elf_Internal_Rela *));

extern bfd_vma bfd_elf32_finish_pointer_linker_section
  PARAMS ((bfd *, bfd *, struct bfd_link_info *, elf_linker_section_t *,
	   struct elf_link_hash_entry *, bfd_vma,
	   const Elf_Internal_Rela *, int));

extern bfd_boolean bfd_elf64_create_pointer_linker_section
  PARAMS ((bfd *, struct bfd_link_info *, elf_linker_section_t *,
	   struct elf_link_hash_entry *, const Elf_Internal_Rela *));

extern bfd_vma bfd_elf64_finish_pointer_linker_section
  PARAMS ((bfd *, bfd *, struct bfd_link_info *, elf_linker_section_t *,
	   struct elf_link_hash_entry *, bfd_vma,
	   const Elf_Internal_Rela *, int));

extern bfd_boolean _bfd_elf_make_linker_section_rela
  PARAMS ((bfd *, elf_linker_section_t *, int));

extern const bfd_target *bfd_elf32_object_p
  PARAMS ((bfd *));
extern const bfd_target *bfd_elf32_core_file_p
  PARAMS ((bfd *));
extern char *bfd_elf32_core_file_failing_command
  PARAMS ((bfd *));
extern int bfd_elf32_core_file_failing_signal
  PARAMS ((bfd *));
extern bfd_boolean bfd_elf32_core_file_matches_executable_p
  PARAMS ((bfd *, bfd *));
d1144 1
a1144 1
extern bfd_boolean bfd_elf32_bfd_link_add_symbols
d1146 1
a1146 1
extern bfd_boolean bfd_elf32_bfd_final_link
d1150 1
a1150 1
  PARAMS ((bfd *, const PTR, const PTR, Elf_Internal_Sym *));
d1152 1
a1152 1
  PARAMS ((bfd *, const Elf_Internal_Sym *, PTR, PTR));
d1154 1
a1154 1
  PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
d1156 1
a1156 1
  PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d1158 1
a1158 1
  PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
d1160 1
a1160 1
  PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d1170 2
a1171 3
  PARAMS ((bfd *, asymbol **, bfd_boolean));
extern bfd_boolean bfd_elf32_write_shdrs_and_ehdr
  PARAMS ((bfd *));
d1173 1
a1173 1
  PARAMS ((bfd *, const Elf_Internal_Phdr *, unsigned int));
d1176 3
a1178 3
extern bfd_boolean bfd_elf32_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
extern bfd_boolean bfd_elf32_add_dynamic_entry
d1180 1
a1180 1
extern bfd_boolean bfd_elf32_link_create_dynamic_sections
d1183 1
a1183 1
  PARAMS ((bfd *, asection *, PTR, Elf_Internal_Rela *, bfd_boolean));
d1185 7
a1191 11
extern const bfd_target *bfd_elf64_object_p
  PARAMS ((bfd *));
extern const bfd_target *bfd_elf64_core_file_p
  PARAMS ((bfd *));
extern char *bfd_elf64_core_file_failing_command
  PARAMS ((bfd *));
extern int bfd_elf64_core_file_failing_signal
  PARAMS ((bfd *));
extern bfd_boolean bfd_elf64_core_file_matches_executable_p
  PARAMS ((bfd *, bfd *));
extern bfd_boolean bfd_elf64_bfd_link_add_symbols
d1193 1
a1193 1
extern bfd_boolean bfd_elf64_bfd_final_link
d1197 1
a1197 1
  PARAMS ((bfd *, const PTR, const PTR, Elf_Internal_Sym *));
d1199 1
a1199 1
  PARAMS ((bfd *, const Elf_Internal_Sym *, PTR, PTR));
d1201 1
a1201 1
  PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
d1203 1
a1203 1
  PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d1205 1
a1205 1
  PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
d1207 1
a1207 1
  PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d1217 2
a1218 3
  PARAMS ((bfd *, asymbol **, bfd_boolean));
extern bfd_boolean bfd_elf64_write_shdrs_and_ehdr
  PARAMS ((bfd *));
d1220 1
a1220 1
  PARAMS ((bfd *, const Elf_Internal_Phdr *, unsigned int));
d1223 3
a1225 3
extern bfd_boolean bfd_elf64_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
extern bfd_boolean bfd_elf64_add_dynamic_entry
d1227 1
a1227 1
extern bfd_boolean bfd_elf64_link_create_dynamic_sections
d1230 1
a1230 1
  PARAMS ((bfd *, asection *, PTR, Elf_Internal_Rela *, bfd_boolean));
d1237 3
a1239 1
extern int elf_link_record_local_dynamic_symbol
a1240 4
#define _bfd_elf32_link_record_local_dynamic_symbol \
  elf_link_record_local_dynamic_symbol
#define _bfd_elf64_link_record_local_dynamic_symbol \
  elf_link_record_local_dynamic_symbol
d1242 1
a1242 2
extern bfd_boolean _bfd_elf_close_and_cleanup
  PARAMS ((bfd *));
d1247 5
a1251 1
extern bfd_boolean _bfd_elf32_gc_sections
d1253 10
a1262 1
extern bfd_boolean _bfd_elf32_gc_common_finalize_got_offsets
d1264 1
a1264 3
extern bfd_boolean _bfd_elf32_gc_common_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
extern bfd_boolean _bfd_elf32_gc_record_vtinherit
d1266 1
a1266 1
extern bfd_boolean _bfd_elf32_gc_record_vtentry
d1269 34
a1302 1
extern bfd_boolean _bfd_elf64_gc_sections
d1304 17
a1320 1
extern bfd_boolean _bfd_elf64_gc_common_finalize_got_offsets
d1322 1
a1322 1
extern bfd_boolean _bfd_elf64_gc_common_final_link
d1324 17
a1340 25
extern bfd_boolean _bfd_elf64_gc_record_vtinherit
  PARAMS ((bfd *, asection *, struct elf_link_hash_entry *, bfd_vma));
extern bfd_boolean _bfd_elf64_gc_record_vtentry
  PARAMS ((bfd *, asection *, struct elf_link_hash_entry *, bfd_vma));

extern bfd_boolean _bfd_elf32_reloc_symbol_deleted_p
  PARAMS ((bfd_vma, PTR));
extern bfd_boolean _bfd_elf64_reloc_symbol_deleted_p
  PARAMS ((bfd_vma, PTR));

/* Exported interface for writing elf corefile notes. */
extern char *elfcore_write_note
  PARAMS ((bfd *, char *, int *, const char *, int, const PTR, int));
extern char *elfcore_write_prpsinfo
  PARAMS ((bfd *, char *, int *, const char *, const char *));
extern char *elfcore_write_prstatus
  PARAMS ((bfd *, char *, int *, long, int, const PTR));
extern char * elfcore_write_pstatus
  PARAMS ((bfd *, char *, int *, long, int, const PTR));
extern char *elfcore_write_prfpreg
  PARAMS ((bfd *, char *, int *, const PTR, int));
extern char *elfcore_write_prxfpreg
  PARAMS ((bfd *, char *, int *, const PTR, int));
extern char *elfcore_write_lwpstatus
  PARAMS ((bfd *, char *, int *, long, int, const PTR));
d1344 1
a1344 2
extern bfd_boolean _sh_elf_set_mach_from_flags
  PARAMS ((bfd *));
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2002, 2003, 2004 Free Software Foundation, Inc.
d36 3
d40 2
a41 2
#if ARCH_SIZE == 64
#define NAME(x, y) x ## 64 ## _ ## y
d43 2
a44 2
#if ARCH_SIZE == 32
#define NAME(x, y) x ## 32 ## _ ## y
d49 1
a49 1
#define NAME(x, y) x ## NOSIZE ## _ ## y
d70 2
a71 2
      void *mips_extr;
      void *any;
d121 5
a210 3
  /* Symbol is referenced with a relocation where C/C++ pointer equality
     matters.  */
#define ELF_LINK_POINTER_EQUALITY_NEEDED 0100000
a212 13
/* Will references to this symbol always reference the symbol
   in this object?  STV_PROTECTED is excluded from the visibility test
   here so that function pointer comparisons work properly.  Since
   function symbols not defined in an app are set to their .plt entry,
   it's necessary for shared libs to also reference the .plt even
   though the symbol is really local to the shared lib.  */
#define SYMBOL_REFERENCES_LOCAL(INFO, H) \
  _bfd_elf_symbol_refs_local_p (H, INFO, 0)

/* Will _calls_ to this symbol always call the version in this object?  */
#define SYMBOL_CALLS_LOCAL(INFO, H) \
  _bfd_elf_symbol_refs_local_p (H, INFO, 1)

d307 8
d360 1
a360 1
  void *stab_info;
d363 1
a363 1
  void *merge_info;
d375 2
a376 3
  /* Cached first output tls section and size of PT_TLS segment.  */
  asection *tls_sec;
  bfd_size_type tls_size;
d394 1
a394 1
    (bfd_boolean (*) (struct bfd_link_hash_entry *, void *)) (func),	\
d402 2
a403 2
#define is_elf_hash_table(htab)					      	\
  (((struct bfd_link_hash_table *) (htab))->type == bfd_link_elf_hash_table)
d431 1
a431 1
  unsigned char arch_size, log_file_align;
d434 3
a436 3
    (bfd *, const Elf_Internal_Phdr *, unsigned int);
  bfd_boolean
    (*write_shdrs_and_ehdr) (bfd *);
d438 1
a438 1
    (bfd *, asection *, void *);
d440 1
a440 1
    (bfd *, const void *, const void *, Elf_Internal_Sym *);
d442 1
a442 1
    (bfd *, const Elf_Internal_Sym *, void *, void *);
d444 1
a444 1
    (bfd *, asection *, asymbol **, bfd_boolean);
d446 1
a446 1
    (bfd *, asymbol **, bfd_boolean);
d448 1
a448 1
    (bfd *, const void *, Elf_Internal_Dyn *);
d450 1
a450 1
    (bfd *, const Elf_Internal_Dyn *, void *);
d456 1
a456 1
    (bfd *, const bfd_byte *, Elf_Internal_Rela *);
d460 1
a460 1
    (bfd *, const Elf_Internal_Rela *, bfd_byte *);
d466 1
a466 1
    (bfd *, const bfd_byte *, Elf_Internal_Rela *);
d470 1
a470 1
    (bfd *, const Elf_Internal_Rela *, bfd_byte *);
a493 1
  int r_sym_shift;
a504 16
/* Mapping of ELF section names and types.  */
struct bfd_elf_special_section
{
  const char *prefix;
  int prefix_length;
  /* 0 means name must match PREFIX exactly.
     -1 means name must start with PREFIX followed by an arbitrary string.
     -2 means name must match PREFIX exactly or consist of PREFIX followed
     by a dot then anything.
     > 0 means name must start with the first PREFIX_LENGTH chars of
     PREFIX and finish with the last SUFFIX_LENGTH chars of PREFIX.  */
  int suffix_length;
  int type;
  int attr;
};

d519 1
a519 1
    (bfd *, arelent *, Elf_Internal_Rela *);
d524 1
a524 1
    (bfd *, arelent *, Elf_Internal_Rela *);
d532 1
a532 1
    (bfd *, asymbol *);
d544 1
a544 1
    (bfd *);
d550 1
a550 1
    (bfd *, asymbol *);
d555 1
a555 1
    (bfd *, elf_symbol_type *, unsigned int);
d560 1
a560 6
    (Elf_Internal_Sym *, int);

  /* Return true if local section symbols should have a non-null st_name.
     NULL implies false.  */
  bfd_boolean (*elf_backend_name_local_section_symbols)
    (bfd *);
d567 1
a567 1
    (bfd *, Elf_Internal_Shdr *);
d572 1
a572 1
    (bfd *, Elf_Internal_Shdr *, const char *);
d577 1
a577 1
    (flagword *, Elf_Internal_Shdr *);
d582 1
a582 1
    (bfd *, Elf_Internal_Phdr *, int);
d588 1
a588 1
    (bfd *, Elf_Internal_Shdr *, asection *);
d595 1
a595 1
    (bfd *, asection *, int *retval);
d606 3
a608 2
    (bfd *abfd, struct bfd_link_info *info, Elf_Internal_Sym *,
     const char **name, flagword *flags, asection **sec, bfd_vma *value);
d613 2
a614 2
    (struct bfd_link_info *info, const char *, Elf_Internal_Sym *,
     asection *, struct elf_link_hash_entry *);
d625 1
a625 1
    (bfd *abfd, struct bfd_link_info *info);
d638 2
a639 2
    (bfd *abfd, struct bfd_link_info *info, asection *o,
     const Elf_Internal_Rela *relocs);
d654 1
a654 1
    (struct bfd_link_info *info, struct elf_link_hash_entry *h);
d661 1
a661 1
    (bfd *output_bfd, struct bfd_link_info *info);
d674 1
a674 1
    (bfd *output_bfd, struct bfd_link_info *info);
d685 1
a685 1
     relocatable output file) adjusting the reloc addend as
d699 1
a699 1
     When generating relocatable output, this function must handle
d705 4
a708 3
    (bfd *output_bfd, struct bfd_link_info *info, bfd *input_bfd,
     asection *input_section, bfd_byte *contents, Elf_Internal_Rela *relocs,
     Elf_Internal_Sym *local_syms, asection **local_sections);
d718 2
a719 2
    (bfd *output_bfd, struct bfd_link_info *info,
     struct elf_link_hash_entry *h, Elf_Internal_Sym *sym);
d726 1
a726 1
    (bfd *output_bfd, struct bfd_link_info *info);
d731 1
a731 1
    (bfd *, struct bfd_link_info *);
d737 1
a737 1
    (bfd *, bfd_boolean linker);
d743 1
a743 1
    (bfd *);
d748 1
a748 1
    (bfd *, struct bfd_link_info *);
d753 2
a754 2
    (asection *sec, struct bfd_link_info *, Elf_Internal_Rela *,
     struct elf_link_hash_entry *h, Elf_Internal_Sym *);
d760 2
a761 2
    (bfd *abfd, struct bfd_link_info *info, asection *o,
     const Elf_Internal_Rela *relocs);
d767 1
a767 1
    (bfd *, struct bfd_link_info *);
d773 1
a773 1
    (bfd *, void *, asymbol *);
d776 1
a776 1
     global symbols converted to locals are emitted into the symtab
d780 2
a781 3
    (bfd *, struct bfd_link_info *, void *,
     bfd_boolean (*) (void *, const char *, Elf_Internal_Sym *, asection *,
		      struct elf_link_hash_entry *));
d789 2
a790 2
    (const struct elf_backend_data *, struct elf_link_hash_entry *,
     struct elf_link_hash_entry *);
d795 1
a795 6
    (struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean);

  /* Merge the backend specific symbol attribute.  */
  void (*elf_backend_merge_symbol_attribute)
    (struct elf_link_hash_entry *, const Elf_Internal_Sym *, bfd_boolean,
     bfd_boolean);
d800 1
a800 1
    (bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *);
d805 1
a805 1
    (asection *, Elf_Internal_Rela *);
d810 1
a810 1
    (bfd *, Elf_Internal_Note *);
d815 1
a815 1
    (bfd *, Elf_Internal_Note *);
d819 1
a819 1
    (bfd *, char *, bfd_vma);
d821 1
a821 1
    (bfd *, void *, bfd_vma);
d825 1
a825 1
    (const Elf_Internal_Rela *);
d830 1
a830 1
    (bfd *, struct elf_reloc_cookie *, struct bfd_link_info *);
d835 1
a835 19
    (asection *);

  /* These functions tell elf-eh-frame whether to attempt to turn
     absolute or lsda encodings into pc-relative ones.  The default
     definition enables these transformations.  */
  bfd_boolean (*elf_backend_can_make_relative_eh_frame)
     (bfd *, struct bfd_link_info *, asection *);
  bfd_boolean (*elf_backend_can_make_lsda_relative_eh_frame)
     (bfd *, struct bfd_link_info *, asection *);

  /* This function returns an encoding after computing the encoded
     value (and storing it in ENCODED) for the given OFFSET into OSEC,
     to be stored in at LOC_OFFSET into the LOC_SEC input section.
     The default definition chooses a 32-bit PC-relative encoding.  */
  bfd_byte (*elf_backend_encode_eh_address)
     (bfd *abfd, struct bfd_link_info *info,
      asection *osec, bfd_vma offset,
      asection *loc_sec, bfd_vma loc_offset,
      bfd_vma *encoded);
d840 1
a840 1
    (bfd *, asection *, bfd_byte *);
d845 1
a845 1
    (bfd *);
d848 1
a848 1
    (unsigned int, bfd_boolean);
a853 6
  /* This function implements `bfd_elf_bfd_from_remote_memory';
     see elf.c, elfcode.h.  */
  bfd *(*elf_backend_bfd_from_remote_memory)
     (bfd *templ, bfd_vma ehdr_vma, bfd_vma *loadbasep,
      int (*target_read_memory) (bfd_vma vma, char *myaddr, int len));

a859 3
  /* An array of target specific special section map.  */
  const struct bfd_elf_special_section *special_sections;

d864 2
a865 2
  /* The size in bytes of the header for the GOT.  This includes the
     so-called reserved entries on some systems.  */
d867 1
d973 1
a973 1
  void *local_dynrel;
d983 1
a983 1
    struct bfd_symbol *id;
d991 1
a991 1
  void *sec_info;
a994 2
#define elf_section_type(sec)  (elf_section_data(sec)->this_hdr.sh_type)
#define elf_section_flags(sec) (elf_section_data(sec)->this_hdr.sh_flags)
d1007 1
a1007 1
  ((const struct elf_backend_data *) (abfd)->xvec->backend_data)
d1009 2
a1010 4
/* This struct is used to pass information to routines called via
   elf_link_hash_traverse which must return failure.  */

struct elf_info_failed
d1012 7
a1018 4
  bfd_boolean failed;
  struct bfd_link_info *info;
  struct bfd_elf_version_tree *verdefs;
};
d1020 1
a1020 2
/* This structure is used to pass information to
   _bfd_elf_link_assign_sym_version.  */
d1022 1
a1022 1
struct elf_assign_sym_version_info
d1024 18
a1041 9
  /* Output BFD.  */
  bfd *output_bfd;
  /* General link information.  */
  struct bfd_link_info *info;
  /* Version tree.  */
  struct bfd_elf_version_tree *verdefs;
  /* Whether we had a failure.  */
  bfd_boolean failed;
};
d1043 2
a1044 2
/* This structure is used to pass information to
   _bfd_elf_link_find_version_dependencies.  */
d1046 1
a1046 1
struct elf_find_verdep_info
d1048 6
a1053 9
  /* Output BFD.  */
  bfd *output_bfd;
  /* General link information.  */
  struct bfd_link_info *info;
  /* The number of dependencies.  */
  unsigned int vers;
  /* Whether we had a failure.  */
  bfd_boolean failed;
};
d1084 6
d1093 3
d1103 4
d1122 4
d1136 15
d1155 1
a1155 1
  void *line_info;
d1167 1
a1167 1
  void *dwarf2_find_line_info;
d1178 2
a1179 2
  Elf_Internal_Shdr **group_sect_ptr;
  int num_group;
a1186 3
  /* Segment flags for the PT_GNU_STACK segment.  */
  unsigned int stack_flags;  

d1193 3
a1201 19

  /* Whether a dyanmic object was specified normally on the linker
     command line, or was specified when --as-needed was in effect,
     or was found via a DT_NEEDED entry.  */
  enum dynamic_lib_link_class dyn_lib_class;

  /* This is set to TRUE if the object was created by the backend
     linker.  */
  bfd_boolean linker;

  /* Irix 5 often screws up the symbol table, sorting local symbols
     after global symbols.  This flag is set if the symbol table in
     this BFD appears to be screwed up.  If it is, we ignore the
     sh_info field in the symbol table header, and always read all the
     symbols.  */
  bfd_boolean bad_symtab;

  /* Used to determine if the e_flags field has been initialized */
  bfd_boolean flags_init;
d1227 1
d1229 1
a1229 1
#define elf_dyn_lib_class(bfd)	(elf_tdata(bfd) -> dyn_lib_class)
d1232 1
d1235 1
a1235 1
  (bfd *, const Elf_External_Verdef *, Elf_Internal_Verdef *);
d1237 1
a1237 1
  (bfd *, const Elf_Internal_Verdef *, Elf_External_Verdef *);
d1239 1
a1239 1
  (bfd *, const Elf_External_Verdaux *, Elf_Internal_Verdaux *);
d1241 1
a1241 1
  (bfd *, const Elf_Internal_Verdaux *, Elf_External_Verdaux *);
d1243 1
a1243 1
  (bfd *, const Elf_External_Verneed *, Elf_Internal_Verneed *);
d1245 1
a1245 1
  (bfd *, const Elf_Internal_Verneed *, Elf_External_Verneed *);
d1247 1
a1247 1
  (bfd *, const Elf_External_Vernaux *, Elf_Internal_Vernaux *);
d1249 1
a1249 1
  (bfd *, const Elf_Internal_Vernaux *, Elf_External_Vernaux *);
d1251 1
a1251 1
  (bfd *, const Elf_External_Versym *, Elf_Internal_Versym *);
d1253 1
a1253 1
  (bfd *, const Elf_Internal_Versym *, Elf_External_Versym *);
d1256 1
a1256 1
  (bfd *, asection *);
d1258 1
a1258 1
  (bfd *, unsigned, unsigned);
d1260 1
a1260 1
  (bfd *, unsigned);
d1262 2
a1263 2
  (bfd *, Elf_Internal_Shdr *, size_t, size_t, Elf_Internal_Sym *, void *,
   Elf_External_Sym_Shndx *);
d1265 1
a1265 1
  (bfd *, Elf_Internal_Sym *);
d1268 1
a1268 1
  (bfd *, bfd *);
d1270 1
a1270 1
  (bfd *, void *);
d1272 1
a1272 1
  (bfd *, void *, asymbol *, bfd_print_symbol_type);
d1275 5
a1279 2
  bfd_elf_string_from_elf_section (abfd, elf_elfheader(abfd)->e_shstrndx, \
				   strindex)
d1282 1
a1282 1
  (bfd *, char *, bfd_vma);
d1284 1
a1284 7
  (bfd *, void *, bfd_vma);

extern bfd_byte _bfd_elf_encode_eh_address
  (bfd *abfd, struct bfd_link_info *info, asection *osec, bfd_vma offset,
   asection *loc_sec, bfd_vma loc_offset, bfd_vma *encoded);
extern bfd_boolean _bfd_elf_can_make_relative
  (bfd *input_bfd, struct bfd_link_info *info, asection *eh_frame_section);
d1287 1
a1287 1
  (const Elf_Internal_Rela *);
d1289 1
a1289 1
  (bfd *, Elf_Internal_Sym *, asection **, Elf_Internal_Rela *);
d1291 1
a1291 1
  (bfd *, Elf_Internal_Sym *, asection **, bfd_vma);
d1293 1
a1293 1
  (bfd *, struct bfd_link_info *, asection *, bfd_vma);
d1296 1
a1296 1
  (const char *);
d1299 1
a1299 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d1301 1
a1301 1
  (bfd *);
d1303 1
a1303 1
  (bfd *);
d1305 1
a1305 1
  (bfd *, char *);
d1307 1
a1307 1
  (bfd *, Elf_Internal_Shdr *, const char *);
d1309 1
a1309 1
  (bfd *, Elf_Internal_Phdr *, int, const char *);
d1311 1
a1311 1
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
d1313 1
a1313 1
  (bfd *);
d1315 2
a1316 2
  (const struct elf_backend_data *, struct elf_link_hash_entry *,
   struct elf_link_hash_entry *);
d1318 1
a1318 1
  (struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean);
d1320 4
a1323 3
  (struct elf_link_hash_table *, bfd *,
   struct bfd_hash_entry *(*)
     (struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d1325 1
a1325 1
  (bfd *);
d1327 1
a1327 1
  (bfd *, struct bfd_link_info *);
d1329 1
a1329 1
  (bfd *, struct bfd_section *);
d1331 1
a1331 1
  (bfd *, asection *, void *);
d1333 1
a1333 1
  (asection *, struct bfd_link_info *);
d1335 1
a1335 1
  (bfd *, asymbol *, bfd *, asymbol *);
d1337 1
a1337 1
  (bfd *, asection *, bfd *, asection *);
d1339 1
a1339 1
  (bfd *);
d1341 1
a1341 1
  (bfd *);
d1343 1
a1343 1
  (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
d1345 3
a1347 3
  (bfd *);
extern long _bfd_elf_canonicalize_symtab
  (bfd *, asymbol **);
d1349 1
a1349 1
  (bfd *);
d1351 1
a1351 1
  (bfd *, asymbol **);
d1353 1
a1353 1
  (bfd *, sec_ptr);
d1355 1
a1355 1
  (bfd *, sec_ptr, arelent **, asymbol **);
d1357 1
a1357 1
  (bfd *);
d1359 1
a1359 1
  (bfd *, arelent **, asymbol **);
d1361 1
a1361 1
  (bfd *);
d1363 1
a1363 1
  (bfd *, asymbol *, symbol_info *);
d1365 1
a1365 1
  (bfd *, const char *);
d1367 1
a1367 1
  (bfd *, asymbol *);
d1369 1
a1369 1
  (bfd *, enum bfd_architecture, unsigned long);
d1371 2
a1372 2
  (bfd *, asection *, asymbol **, bfd_vma, const char **, const char **,
   unsigned int *);
d1376 1
a1376 1
  (bfd *, bfd_boolean);
d1378 1
a1378 1
  (bfd *, asection *);
d1380 1
a1380 3
  (bfd *, Elf_Internal_Shdr *, asection *, bfd_boolean);
extern const struct bfd_elf_special_section *_bfd_elf_get_sec_type_attr
  (bfd *, const char *);
d1384 1
a1384 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d1387 1
a1387 1
  (bfd *, unsigned int shindex);
d1389 1
a1389 1
  (bfd *, Elf_Internal_Phdr *, int);
d1392 1
a1392 1
  (bfd *, asymbol **);
d1395 1
a1395 1
  (bfd *, struct sym_sec_cache *, asection *, unsigned long);
d1397 3
a1399 1
  (bfd *, unsigned int);
d1401 1
a1401 1
  (void);
d1404 1
a1404 1
  (void);
d1406 1
a1406 1
  (struct elf_strtab_hash *);
d1408 1
a1408 1
  (struct elf_strtab_hash *, const char *, bfd_boolean);
d1410 1
a1410 1
  (struct elf_strtab_hash *, bfd_size_type);
d1412 1
a1412 1
  (struct elf_strtab_hash *, bfd_size_type);
d1414 1
a1414 1
  (struct elf_strtab_hash *);
d1416 1
a1416 1
  (struct elf_strtab_hash *);
d1418 1
a1418 1
  (struct elf_strtab_hash *, bfd_size_type);
d1420 1
a1420 1
  (bfd *, struct elf_strtab_hash *);
d1422 1
a1422 1
  (struct elf_strtab_hash *);
d1425 2
a1426 2
  (bfd *, struct bfd_link_info *, asection *,
   bfd_boolean (*) (bfd_vma, void *), struct elf_reloc_cookie *);
d1428 1
a1428 1
  (bfd *, struct bfd_link_info *);
d1430 1
a1430 1
  (bfd *, asection *, bfd_vma);
d1432 1
a1432 1
  (bfd *, struct bfd_link_info *, asection *, bfd_byte *);
d1434 1
a1434 1
  (bfd *, struct bfd_link_info *);
d1436 1
a1436 20
  (struct bfd_link_info *);

extern bfd_boolean _bfd_elf_merge_symbol
  (bfd *, struct bfd_link_info *, const char *, Elf_Internal_Sym *,
   asection **, bfd_vma *, struct elf_link_hash_entry **, bfd_boolean *,
   bfd_boolean *, bfd_boolean *, bfd_boolean *);

extern bfd_boolean _bfd_elf_add_default_symbol
  (bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
   const char *, Elf_Internal_Sym *, asection **, bfd_vma *,
   bfd_boolean *, bfd_boolean);

extern bfd_boolean _bfd_elf_export_symbol
  (struct elf_link_hash_entry *, void *);

extern bfd_boolean _bfd_elf_link_find_version_dependencies
  (struct elf_link_hash_entry *, void *);

extern bfd_boolean _bfd_elf_link_assign_sym_version
  (struct elf_link_hash_entry *, void *);
d1438 2
d1441 1
a1441 1
  (struct bfd_link_info *, bfd *, long);
d1443 1
a1443 1
  (bfd *, struct bfd_link_info *);
d1445 1
a1445 1
  (bfd *);
d1447 1
a1447 1
  (Elf_Internal_Shdr *, file_ptr, bfd_boolean);
d1450 1
a1450 1
  (bfd *, arelent *);
a1451 2
extern bfd_boolean _bfd_elf_link_create_dynamic_sections
  (bfd *, struct bfd_link_info *);
d1453 1
a1453 1
  (bfd *, struct bfd_link_info *);
d1455 1
a1455 1
  (bfd *, struct bfd_link_info *);
d1457 1
a1457 1
  (bfd *, struct bfd_link_info *);
d1460 1
a1460 1
  (bfd *, char *, size_t, ufile_ptr);
d1462 1
a1462 10
  (bfd *, char *, size_t);

extern Elf_Internal_Rela *_bfd_elf_link_read_relocs
  (bfd *, asection *, void *, Elf_Internal_Rela *, bfd_boolean);

extern bfd_boolean _bfd_elf_link_size_reloc_section
  (bfd *, Elf_Internal_Shdr *, asection *);

extern bfd_boolean _bfd_elf_link_output_relocs
  (bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *);
d1464 25
a1488 2
extern bfd_boolean _bfd_elf_fix_symbol_flags
  (struct elf_link_hash_entry *, struct elf_info_failed *);
d1490 2
a1491 11
extern bfd_boolean _bfd_elf_adjust_dynamic_symbol
  (struct elf_link_hash_entry *, void *);

extern bfd_boolean _bfd_elf_link_sec_merge_syms
  (struct elf_link_hash_entry *, void *);

extern bfd_boolean _bfd_elf_dynamic_symbol_p
  (struct elf_link_hash_entry *, struct bfd_link_info *, bfd_boolean);

extern bfd_boolean _bfd_elf_symbol_refs_local_p
  (struct elf_link_hash_entry *, struct bfd_link_info *, bfd_boolean);
d1494 1
a1494 1
  (bfd *);
d1496 1
a1496 1
  (bfd *);
d1498 1
a1498 1
  (bfd *);
d1500 1
a1500 1
  (bfd *);
d1502 6
a1507 1
  (bfd *, bfd *);
d1510 1
a1510 1
  (bfd *, const void *, const void *, Elf_Internal_Sym *);
d1512 1
a1512 1
  (bfd *, const Elf_Internal_Sym *, void *, void *);
d1514 1
a1514 1
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
d1516 1
a1516 1
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
d1518 1
a1518 1
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
d1520 1
a1520 1
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
d1522 1
a1522 1
  (bfd *, const Elf32_External_Phdr *, Elf_Internal_Phdr *);
d1524 1
a1524 1
  (bfd *, const Elf_Internal_Phdr *, Elf32_External_Phdr *);
d1526 1
a1526 1
  (bfd *, const void *, Elf_Internal_Dyn *);
d1528 1
a1528 1
  (bfd *, const Elf_Internal_Dyn *, void *);
d1530 1
a1530 1
  (bfd *, asymbol **, bfd_boolean);
d1532 1
a1532 1
  (bfd *);
d1534 1
a1534 1
  (bfd *, const Elf_Internal_Phdr *, unsigned int);
d1536 1
a1536 1
  (bfd *, asection *, void *);
d1538 7
a1544 1
  (bfd *, asection *, asymbol **, bfd_boolean);
d1547 1
a1547 1
  (bfd *);
d1549 1
a1549 1
  (bfd *);
d1551 1
a1551 1
  (bfd *);
d1553 1
a1553 1
  (bfd *);
d1555 5
a1559 1
  (bfd *, bfd *);
d1562 1
a1562 1
  (bfd *, const void *, const void *, Elf_Internal_Sym *);
d1564 1
a1564 1
  (bfd *, const Elf_Internal_Sym *, void *, void *);
d1566 1
a1566 1
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
d1568 1
a1568 1
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
d1570 1
a1570 1
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
d1572 1
a1572 1
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
d1574 1
a1574 1
  (bfd *, const Elf64_External_Phdr *, Elf_Internal_Phdr *);
d1576 1
a1576 1
  (bfd *, const Elf_Internal_Phdr *, Elf64_External_Phdr *);
d1578 1
a1578 1
  (bfd *, const void *, Elf_Internal_Dyn *);
d1580 1
a1580 1
  (bfd *, const Elf_Internal_Dyn *, void *);
d1582 1
a1582 1
  (bfd *, asymbol **, bfd_boolean);
d1584 1
a1584 1
  (bfd *);
d1586 1
a1586 1
  (bfd *, const Elf_Internal_Phdr *, unsigned int);
d1588 1
a1588 1
  (bfd *, asection *, void *);
d1590 19
a1608 12
  (bfd *, asection *, asymbol **, bfd_boolean);

extern bfd_boolean bfd_elf_link_add_symbols
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_add_dynamic_entry
  (struct bfd_link_info *, bfd_vma, bfd_vma);

extern bfd_boolean bfd_elf_link_record_dynamic_symbol
  (struct bfd_link_info *, struct elf_link_hash_entry *);

extern int bfd_elf_link_record_local_dynamic_symbol
  (struct bfd_link_info *, bfd *, long);
d1611 1
a1611 1
  (bfd *);
d1613 2
a1614 11
  (bfd *, arelent *, struct bfd_symbol *, void *,
   asection *, bfd *, char **);

extern bfd_boolean bfd_elf_final_link
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf_gc_sections
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf_gc_record_vtinherit
  (bfd *, asection *, struct elf_link_hash_entry *, bfd_vma);
d1616 26
a1641 11
extern bfd_boolean bfd_elf_gc_record_vtentry
  (bfd *, asection *, struct elf_link_hash_entry *, bfd_vma);

extern bfd_boolean bfd_elf_gc_common_finalize_got_offsets
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf_gc_common_final_link
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf_reloc_symbol_deleted_p
  (bfd_vma, void *);
d1645 1
a1645 1
  (bfd *, char *, int *, const char *, int, const void *, int);
d1647 1
a1647 1
  (bfd *, char *, int *, const char *, const char *);
d1649 1
a1649 1
  (bfd *, char *, int *, long, int, const void *);
d1651 1
a1651 1
  (bfd *, char *, int *, long, int, const void *);
d1653 1
a1653 1
  (bfd *, char *, int *, const void *, int);
d1655 1
a1655 1
  (bfd *, char *, int *, const void *, int);
d1657 1
a1657 8
  (bfd *, char *, int *, long, int, const void *);

extern bfd *_bfd_elf32_bfd_from_remote_memory
  (bfd *templ, bfd_vma ehdr_vma, bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, char *, int));
extern bfd *_bfd_elf64_bfd_from_remote_memory
  (bfd *templ, bfd_vma ehdr_vma, bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, char *, int));
d1662 1
a1662 70
  (bfd *);

/* This is the condition under which finish_dynamic_symbol will be called.
   If our finish_dynamic_symbol isn't called, we'll need to do something
   about initializing any .plt and .got entries in relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
  ((DYN)								\
   && ((SHARED)								\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

/* This macro is to avoid lots of duplicated code in the body
   of xxx_relocate_section() in the various elfxx-xxxx.c files.  */
#define RELOC_FOR_GLOBAL_SYMBOL(info, input_bfd, input_section, rel,	\
				r_symndx, symtab_hdr, sym_hashes,	\
				h, sec, relocation,			\
				unresolved_reloc, warned)		\
  do									\
    {									\
      /* It seems this can happen with erroneous or unsupported		\
	 input (mixing a.out and elf in an archive, for example.)  */	\
      if (sym_hashes == NULL)						\
	return FALSE;							\
									\
      h = sym_hashes[r_symndx - symtab_hdr->sh_info];			\
									\
      while (h->root.type == bfd_link_hash_indirect			\
	     || h->root.type == bfd_link_hash_warning)			\
	h = (struct elf_link_hash_entry *) h->root.u.i.link;		\
									\
      warned = FALSE;							\
      unresolved_reloc = FALSE;						\
      relocation = 0;							\
      if (h->root.type == bfd_link_hash_defined				\
	  || h->root.type == bfd_link_hash_defweak)			\
	{								\
	  sec = h->root.u.def.section;					\
	  if (sec == NULL						\
	      || sec->output_section == NULL)				\
	    /* Set a flag that will be cleared later if we find a	\
	       relocation value for this symbol.  output_section	\
	       is typically NULL for symbols satisfied by a shared	\
	       library.  */						\
	    unresolved_reloc = TRUE;					\
	  else								\
	    relocation = (h->root.u.def.value				\
			  + sec->output_section->vma			\
			  + sec->output_offset);			\
	}								\
      else if (h->root.type == bfd_link_hash_undefweak)			\
	;								\
      else if (info->unresolved_syms_in_objects == RM_IGNORE		\
	       && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)		\
	;								\
      else								\
	{								\
	  bfd_boolean err;						\
	  err = (info->unresolved_syms_in_objects == RM_GENERATE_ERROR	\
		 || ELF_ST_VISIBILITY (h->other) != STV_DEFAULT);	\
	  if (!info->callbacks->undefined_symbol (info,			\
						  h->root.root.string,	\
						  input_bfd,		\
						  input_section,	\
						  rel->r_offset, err))	\
	    return FALSE;						\
	  warned = TRUE;						\
	}								\
    }									\
  while (0)
@


