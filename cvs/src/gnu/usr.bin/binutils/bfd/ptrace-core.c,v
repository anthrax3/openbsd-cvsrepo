head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.50
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.14
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.12;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.23;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.31;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.22;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.11.23.03.33.24;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.46.52;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.09;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.09;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.06.23;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.11.19.14.12.54;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.45.55;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.27.20;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.19;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.22.33;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* BFD backend for core files which use the ptrace_user structure
   Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
   The structure of this file is based on trad-core.c written by John Gilmore
   of Cygnus Support.
   Modified to work with the ptrace_user structure by Kevin A. Buettner.
   (Longterm it may be better to merge this file with trad-core.c)

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifdef PTRACE_CORE

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"

#include <sys/param.h>
#include <sys/dir.h>
#include <signal.h>
#include <sys/ptrace.h>

struct trad_core_struct
  {
    asection *data_section;
    asection *stack_section;
    asection *reg_section;
    struct ptrace_user u;
  };

#define core_upage(bfd) (&((bfd)->tdata.trad_core_data->u))
#define core_datasec(bfd) ((bfd)->tdata.trad_core_data->data_section)
#define core_stacksec(bfd) ((bfd)->tdata.trad_core_data->stack_section)
#define core_regsec(bfd) ((bfd)->tdata.trad_core_data->reg_section)

/* forward declarations */

const bfd_target *ptrace_unix_core_file_p PARAMS ((bfd *abfd));
char * ptrace_unix_core_file_failing_command PARAMS ((bfd *abfd));
int ptrace_unix_core_file_failing_signal PARAMS ((bfd *abfd));
bfd_boolean ptrace_unix_core_file_matches_executable_p
  PARAMS ((bfd *core_bfd, bfd *exec_bfd));
static void swap_abort PARAMS ((void));

const bfd_target *
ptrace_unix_core_file_p (abfd)
     bfd *abfd;

{
  int val;
  struct ptrace_user u;
  struct trad_core_struct *rawptr;
  bfd_size_type amt;

  val = bfd_bread ((void *)&u, (bfd_size_type) sizeof u, abfd);
  if (val != sizeof u || u.pt_magic != _BCS_PTRACE_MAGIC
      || u.pt_rev != _BCS_PTRACE_REV)
    {
      /* Too small to be a core file */
      bfd_set_error (bfd_error_wrong_format);
      return 0;
    }

  /* OK, we believe you.  You're a core file (sure, sure).  */

  /* Allocate both the upage and the struct core_data at once, so
     a single free() will free them both.  */
  amt = sizeof (struct trad_core_struct);
  rawptr = (struct trad_core_struct *) bfd_zalloc (abfd, amt);

  if (rawptr == NULL)
    return 0;

  abfd->tdata.trad_core_data = rawptr;

  rawptr->u = u; /*Copy the uarea into the tdata part of the bfd */

  /* Create the sections.  */

  core_stacksec (abfd) = bfd_make_section_anyway (abfd, ".stack");
  if (core_stacksec (abfd) == NULL)
    goto fail;
  core_datasec (abfd) = bfd_make_section_anyway (abfd, ".data");
  if (core_datasec (abfd) == NULL)
    goto fail;
  core_regsec (abfd) = bfd_make_section_anyway (abfd, ".reg");
  if (core_regsec (abfd) == NULL)
    goto fail;

  /* FIXME:  Need to worry about shared memory, library data, and library
     text.  I don't think that any of these things are supported on the
     system on which I am developing this for though.  */

  core_stacksec (abfd)->flags = SEC_ALLOC + SEC_LOAD + SEC_HAS_CONTENTS;
  core_datasec (abfd)->flags = SEC_ALLOC + SEC_LOAD + SEC_HAS_CONTENTS;
  core_regsec (abfd)->flags = SEC_HAS_CONTENTS;

  core_datasec (abfd)->_raw_size =  u.pt_dsize;
  core_stacksec (abfd)->_raw_size = u.pt_ssize;
  core_regsec (abfd)->_raw_size = sizeof (u);

  core_datasec (abfd)->vma = u.pt_o_data_start;
  core_stacksec (abfd)->vma = USRSTACK - u.pt_ssize;
  core_regsec (abfd)->vma = 0 - sizeof (u);	/* see trad-core.c */

  core_datasec (abfd)->filepos = (int) u.pt_dataptr;
  core_stacksec (abfd)->filepos = (int) (u.pt_dataptr + u.pt_dsize);
  core_regsec (abfd)->filepos = 0; /* Register segment is ptrace_user */

  /* Align to word at least */
  core_stacksec (abfd)->alignment_power = 2;
  core_datasec (abfd)->alignment_power = 2;
  core_regsec (abfd)->alignment_power = 2;

  return abfd->xvec;

 fail:
  bfd_release (abfd, abfd->tdata.any);
  abfd->tdata.any = NULL;
  bfd_section_list_clear (abfd);
  return NULL;
}

char *
ptrace_unix_core_file_failing_command (abfd)
     bfd *abfd;
{
  char *com = abfd->tdata.trad_core_data->u.pt_comm;
  if (*com)
    return com;
  else
    return 0;
}

int
ptrace_unix_core_file_failing_signal (abfd)
     bfd *abfd;
{
  return abfd->tdata.trad_core_data->u.pt_sigframe.sig_num;
}

bfd_boolean
ptrace_unix_core_file_matches_executable_p  (core_bfd, exec_bfd)
     bfd *core_bfd, *exec_bfd;
{
  /* FIXME: Use pt_timdat field of the ptrace_user structure to match
     the date of the executable */
  return TRUE;
}

/* If somebody calls any byte-swapping routines, shoot them.  */
static void
swap_abort ()
{
  abort (); /* This way doesn't require any declaration for ANSI to fuck up */
}

#define	NO_GET ((bfd_vma (*) (const void *)) swap_abort)
#define	NO_PUT ((void (*) (bfd_vma, void *)) swap_abort)
#define	NO_GETS ((bfd_signed_vma (*) (const void *)) swap_abort)
#define	NO_GET64 ((bfd_uint64_t (*) (const void *)) swap_abort)
#define	NO_PUT64 ((void (*) (bfd_uint64_t, void *)) swap_abort)
#define	NO_GETS64 ((bfd_int64_t (*) (const void *)) swap_abort)

const bfd_target ptrace_core_vec =
  {
    "trad-core",
    bfd_target_unknown_flavour,
    BFD_ENDIAN_UNKNOWN,		/* target byte order */
    BFD_ENDIAN_UNKNOWN,		/* target headers byte order */
    (HAS_RELOC | EXEC_P |	/* object flags */
     HAS_LINENO | HAS_DEBUG |
     HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
    0,			                                   /* symbol prefix */
    ' ',						   /* ar_pad_char */
    16,							   /* ar_max_namelen */
    NO_GET64, NO_GETS64, NO_PUT64,	/* 64 bit data */
    NO_GET, NO_GETS, NO_PUT,		/* 32 bit data */
    NO_GET, NO_GETS, NO_PUT,		/* 16 bit data */
    NO_GET64, NO_GETS64, NO_PUT64,	/* 64 bit hdrs */
    NO_GET, NO_GETS, NO_PUT,		/* 32 bit hdrs */
    NO_GET, NO_GETS, NO_PUT,		/* 16 bit hdrs */

    {				/* bfd_check_format */
      _bfd_dummy_target,		/* unknown format */
      _bfd_dummy_target,		/* object file */
      _bfd_dummy_target,		/* archive */
      ptrace_unix_core_file_p		/* a core file */
    },
    {				/* bfd_set_format */
      bfd_false, bfd_false,
      bfd_false, bfd_false
    },
    {				/* bfd_write_contents */
      bfd_false, bfd_false,
      bfd_false, bfd_false
    },

    BFD_JUMP_TABLE_GENERIC (_bfd_generic),
    BFD_JUMP_TABLE_COPY (_bfd_generic),
    BFD_JUMP_TABLE_CORE (ptrace_unix),
    BFD_JUMP_TABLE_ARCHIVE (_bfd_noarchive),
    BFD_JUMP_TABLE_SYMBOLS (_bfd_nosymbols),
    BFD_JUMP_TABLE_RELOCS (_bfd_norelocs),
    BFD_JUMP_TABLE_WRITE (_bfd_generic),
    BFD_JUMP_TABLE_LINK (_bfd_nolink),
    BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

    NULL,

    (PTR) 0			/* backend_data */
  };

#endif /* PTRACE_CORE */
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2001, 2002
a57 1
/* ARGSUSED */
a147 1
/* ARGSUSED */
a154 1
/* ARGSUSED */
d170 7
a176 4
#define	NO_GET	((bfd_vma (*) PARAMS ((   const bfd_byte *))) swap_abort )
#define	NO_PUT	((void    (*) PARAMS ((bfd_vma, bfd_byte *))) swap_abort )
#define	NO_SIGNED_GET \
  ((bfd_signed_vma (*) PARAMS ((const bfd_byte *))) swap_abort )
d191 6
a196 6
    NO_GET, NO_SIGNED_GET, NO_PUT,	/* 64 bit data */
    NO_GET, NO_SIGNED_GET, NO_PUT,	/* 32 bit data */
    NO_GET, NO_SIGNED_GET, NO_PUT,	/* 16 bit data */
    NO_GET, NO_SIGNED_GET, NO_PUT,	/* 64 bit hdrs */
    NO_GET, NO_SIGNED_GET, NO_PUT,	/* 32 bit hdrs */
    NO_GET, NO_SIGNED_GET, NO_PUT,	/* 16 bit hdrs */
d199 4
a202 4
     _bfd_dummy_target,		/* unknown format */
     _bfd_dummy_target,		/* object file */
     _bfd_dummy_target,		/* archive */
     ptrace_unix_core_file_p	/* a core file */
d205 2
a206 2
     bfd_false, bfd_false,
     bfd_false, bfd_false
d209 2
a210 2
     bfd_false, bfd_false,
     bfd_false, bfd_false
d213 9
a221 9
       BFD_JUMP_TABLE_GENERIC (_bfd_generic),
       BFD_JUMP_TABLE_COPY (_bfd_generic),
       BFD_JUMP_TABLE_CORE (ptrace_unix),
       BFD_JUMP_TABLE_ARCHIVE (_bfd_noarchive),
       BFD_JUMP_TABLE_SYMBOLS (_bfd_nosymbols),
       BFD_JUMP_TABLE_RELOCS (_bfd_norelocs),
       BFD_JUMP_TABLE_WRITE (_bfd_generic),
       BFD_JUMP_TABLE_LINK (_bfd_nolink),
       BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
d226 1
a226 1
};
@


1.5
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2001
d52 5
a56 5
char *		ptrace_unix_core_file_failing_command PARAMS ((bfd *abfd));
int		ptrace_unix_core_file_failing_signal PARAMS ((bfd *abfd));
boolean		ptrace_unix_core_file_matches_executable_p
			 PARAMS ((bfd *core_bfd, bfd *exec_bfd));
static void	swap_abort PARAMS ((void));
d67 1
d69 1
a69 1
  val = bfd_read ((void *)&u, 1, sizeof u, abfd);
d82 2
a83 2
  rawptr = (struct trad_core_struct *)
		bfd_zalloc (abfd, sizeof (struct trad_core_struct));
d92 1
a92 2
  /* Create the sections.  This is raunchy, but bfd_close wants to free
     them separately.  */
d94 1
a94 1
  core_stacksec (abfd) = (asection *) bfd_zalloc (abfd, sizeof (asection));
d96 2
a97 2
    return NULL;
  core_datasec (abfd) = (asection *) bfd_zalloc (abfd, sizeof (asection));
d99 2
a100 2
    return NULL;
  core_regsec (abfd) = (asection *) bfd_zalloc (abfd, sizeof (asection));
d102 1
a102 5
    return NULL;

  core_stacksec (abfd)->name = ".stack";
  core_datasec (abfd)->name = ".data";
  core_regsec (abfd)->name = ".reg";
d129 1
a129 4
  abfd->sections = core_stacksec (abfd);
  core_stacksec (abfd)->next = core_datasec (abfd);
  core_datasec (abfd)->next = core_regsec (abfd);
  abfd->section_count = 3;
d131 5
a135 1
  return abfd->xvec;
d158 1
a158 1
boolean
d164 1
a164 1
  return true;
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright 1993, 94, 95, 96, 1998 Free Software Foundation, Inc.
a35 1

d69 1
a69 1
  if (val != sizeof u || u.pt_magic != _BCS_PTRACE_MAGIC 
d86 1
a86 1
  
d110 1
a110 2
     system on which I am developing this for though. */

d118 1
a118 1
  core_regsec (abfd)->_raw_size = sizeof(u);
d122 1
a122 1
  core_regsec (abfd)->vma = 0 - sizeof(u);	/* see trad-core.c */
d165 1
a165 1
  /* FIXME: Use pt_timdat field of the ptrace_user structure to match 
d172 1
a172 1
swap_abort()
d174 1
a174 1
  abort(); /* This way doesn't require any declaration for ANSI to fuck up */
d215 1
a215 1
    
d227 1
a227 1
    
@


1.3
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 1
a2 1
   Copyright 1993, 1994 Free Software Foundation, Inc.
a29 2
#include <stdio.h>
#include <sys/types.h>
a32 2
#include <errno.h>
#include <unistd.h>
d227 2
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d60 1
d176 1
a176 1
void
@


1.1
log
@Initial revision
@
text
@d87 1
a87 2
  if (rawptr == NULL) {
    bfd_set_error (bfd_error_no_memory);
a88 1
  }
d98 2
a99 6
  if (core_stacksec (abfd) == NULL) {
  loser:
    bfd_set_error (bfd_error_no_memory);
    free ((void *)rawptr);
    return 0;
  }
d101 2
a102 5
  if (core_datasec (abfd) == NULL) {
  loser1:
    free ((void *)core_stacksec (abfd));
    goto loser;
  }
d104 2
a105 4
  if (core_regsec (abfd) == NULL) {
    free ((void *)core_datasec (abfd));
    goto loser1;
  }
d189 2
a190 2
    true,			/* target byte order */
    true,			/* target headers byte order */
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d87 2
a88 1
  if (rawptr == NULL)
d90 1
d100 6
a105 2
  if (core_stacksec (abfd) == NULL)
    return NULL;
d107 5
a111 2
  if (core_datasec (abfd) == NULL)
    return NULL;
d113 4
a116 2
  if (core_regsec (abfd) == NULL)
    return NULL;
d200 2
a201 2
    BFD_ENDIAN_UNKNOWN,		/* target byte order */
    BFD_ENDIAN_UNKNOWN,		/* target headers byte order */
@


1.1.1.3
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a59 1
static void	swap_abort PARAMS ((void));
d175 1
a175 1
static void
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1993, 94, 95, 96, 1998 Free Software Foundation, Inc.
d30 2
d35 2
a230 2
    NULL,
    
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2001
   Free Software Foundation, Inc.
d35 1
d69 1
a69 1
  if (val != sizeof u || u.pt_magic != _BCS_PTRACE_MAGIC
d86 1
a86 1

d110 2
a111 1
     system on which I am developing this for though.  */
d119 1
a119 1
  core_regsec (abfd)->_raw_size = sizeof (u);
d123 1
a123 1
  core_regsec (abfd)->vma = 0 - sizeof (u);	/* see trad-core.c */
d166 1
a166 1
  /* FIXME: Use pt_timdat field of the ptrace_user structure to match
d173 1
a173 1
swap_abort ()
d175 1
a175 1
  abort (); /* This way doesn't require any declaration for ANSI to fuck up */
d216 1
a216 1

d228 1
a228 1

@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2001, 2002
d52 5
a56 5
char * ptrace_unix_core_file_failing_command PARAMS ((bfd *abfd));
int ptrace_unix_core_file_failing_signal PARAMS ((bfd *abfd));
bfd_boolean ptrace_unix_core_file_matches_executable_p
  PARAMS ((bfd *core_bfd, bfd *exec_bfd));
static void swap_abort PARAMS ((void));
a66 1
  bfd_size_type amt;
d68 1
a68 1
  val = bfd_bread ((void *)&u, (bfd_size_type) sizeof u, abfd);
d81 2
a82 2
  amt = sizeof (struct trad_core_struct);
  rawptr = (struct trad_core_struct *) bfd_zalloc (abfd, amt);
d91 2
a92 1
  /* Create the sections.  */
d94 1
a94 1
  core_stacksec (abfd) = bfd_make_section_anyway (abfd, ".stack");
d96 2
a97 2
    goto fail;
  core_datasec (abfd) = bfd_make_section_anyway (abfd, ".data");
d99 2
a100 2
    goto fail;
  core_regsec (abfd) = bfd_make_section_anyway (abfd, ".reg");
d102 5
a106 1
    goto fail;
d133 5
a138 6

 fail:
  bfd_release (abfd, abfd->tdata.any);
  abfd->tdata.any = NULL;
  bfd_section_list_clear (abfd);
  return NULL;
d161 1
a161 1
bfd_boolean
d167 1
a167 1
  return TRUE;
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2001, 2002, 2003, 2004
d58 1
d149 1
d157 1
d173 4
a176 7

#define	NO_GET ((bfd_vma (*) (const void *)) swap_abort)
#define	NO_PUT ((void (*) (bfd_vma, void *)) swap_abort)
#define	NO_GETS ((bfd_signed_vma (*) (const void *)) swap_abort)
#define	NO_GET64 ((bfd_uint64_t (*) (const void *)) swap_abort)
#define	NO_PUT64 ((void (*) (bfd_uint64_t, void *)) swap_abort)
#define	NO_GETS64 ((bfd_int64_t (*) (const void *)) swap_abort)
d191 6
a196 6
    NO_GET64, NO_GETS64, NO_PUT64,	/* 64 bit data */
    NO_GET, NO_GETS, NO_PUT,		/* 32 bit data */
    NO_GET, NO_GETS, NO_PUT,		/* 16 bit data */
    NO_GET64, NO_GETS64, NO_PUT64,	/* 64 bit hdrs */
    NO_GET, NO_GETS, NO_PUT,		/* 32 bit hdrs */
    NO_GET, NO_GETS, NO_PUT,		/* 16 bit hdrs */
d199 4
a202 4
      _bfd_dummy_target,		/* unknown format */
      _bfd_dummy_target,		/* object file */
      _bfd_dummy_target,		/* archive */
      ptrace_unix_core_file_p		/* a core file */
d205 2
a206 2
      bfd_false, bfd_false,
      bfd_false, bfd_false
d209 2
a210 2
      bfd_false, bfd_false,
      bfd_false, bfd_false
d213 9
a221 9
    BFD_JUMP_TABLE_GENERIC (_bfd_generic),
    BFD_JUMP_TABLE_COPY (_bfd_generic),
    BFD_JUMP_TABLE_CORE (ptrace_unix),
    BFD_JUMP_TABLE_ARCHIVE (_bfd_noarchive),
    BFD_JUMP_TABLE_SYMBOLS (_bfd_nosymbols),
    BFD_JUMP_TABLE_RELOCS (_bfd_norelocs),
    BFD_JUMP_TABLE_WRITE (_bfd_generic),
    BFD_JUMP_TABLE_LINK (_bfd_nolink),
    BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
d226 1
a226 1
  };
@


