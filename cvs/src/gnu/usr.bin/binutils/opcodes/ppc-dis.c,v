head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.54
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.52
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.48
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.44
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.46
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.38
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.42
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.40
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.36
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.34
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.32
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.30
	OPENBSD_5_0:1.5.0.28
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.26
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.24
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.20
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.22
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.18
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.16
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.5
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.2
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.11.02.20.45.55;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.17.21.54.55;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.44;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.19.13.01;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.05;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.05;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.47.59;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.58.23;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.46;	author drahn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.11.02.20.23.14;	author miod;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* ppc-dis.c -- Disassemble PowerPC instructions
   Copyright 1994, 1995, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
   Written by Ian Lance Taylor, Cygnus Support

This file is part of GDB, GAS, and the GNU binutils.

GDB, GAS, and the GNU binutils are free software; you can redistribute
them and/or modify them under the terms of the GNU General Public
License as published by the Free Software Foundation; either version
2, or (at your option) any later version.

GDB, GAS, and the GNU binutils are distributed in the hope that they
will be useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this file; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include <stdio.h>
#include "sysdep.h"
#include "dis-asm.h"
#include "opcode/ppc.h"

/* This file provides several disassembler functions, all of which use
   the disassembler interface defined in dis-asm.h.  Several functions
   are provided because this file handles disassembly for the PowerPC
   in both big and little endian mode and also for the POWER (RS/6000)
   chip.  */

static int print_insn_powerpc (bfd_vma, struct disassemble_info *, int, int);

struct dis_private {
  /* Stash the result of parsing disassembler_options here.  */
  int dialect;
};

/* Determine which set of machines to disassemble for.  PPC403/601 or
   BookE.  For convenience, also disassemble instructions supported
   by the AltiVec vector unit.  */

static int
powerpc_dialect (struct disassemble_info *info)
{
  int dialect = PPC_OPCODE_PPC | PPC_OPCODE_ALTIVEC;

  if (BFD_DEFAULT_TARGET_SIZE == 64)
    dialect |= PPC_OPCODE_64;

  if (info->disassembler_options
      && strstr (info->disassembler_options, "booke") != NULL)
    dialect |= PPC_OPCODE_BOOKE | PPC_OPCODE_BOOKE64;
  else if ((info->mach == bfd_mach_ppc_e500)
	   || (info->disassembler_options
	       && strstr (info->disassembler_options, "e500") != NULL))
    {
      dialect |= PPC_OPCODE_BOOKE
	| PPC_OPCODE_SPE | PPC_OPCODE_ISEL
	| PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
	| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK
	| PPC_OPCODE_RFMCI;
      /* efs* and AltiVec conflict.  */
      dialect &= ~PPC_OPCODE_ALTIVEC;
    }
  else if (info->disassembler_options
	   && strstr (info->disassembler_options, "efs") != NULL)
    {
      dialect |= PPC_OPCODE_EFS;
      /* efs* and AltiVec conflict.  */
      dialect &= ~PPC_OPCODE_ALTIVEC;
    }
  else
    dialect |= (PPC_OPCODE_403 | PPC_OPCODE_601 | PPC_OPCODE_CLASSIC
		| PPC_OPCODE_COMMON);

  if (info->disassembler_options
      && strstr (info->disassembler_options, "power4") != NULL)
    dialect |= PPC_OPCODE_POWER4;

  if (info->disassembler_options
      && strstr (info->disassembler_options, "any") != NULL)
    dialect |= PPC_OPCODE_ANY;

  if (info->disassembler_options)
    {
      if (strstr (info->disassembler_options, "32") != NULL)
	dialect &= ~PPC_OPCODE_64;
      else if (strstr (info->disassembler_options, "64") != NULL)
	dialect |= PPC_OPCODE_64;
    }

  ((struct dis_private *) &info->private_data)->dialect = dialect;
  return dialect;
}

/* Print a big endian PowerPC instruction.  */

int
print_insn_big_powerpc (bfd_vma memaddr, struct disassemble_info *info)
{
  int dialect = ((struct dis_private *) &info->private_data)->dialect;
  return print_insn_powerpc (memaddr, info, 1, dialect);
}

/* Print a little endian PowerPC instruction.  */

int
print_insn_little_powerpc (bfd_vma memaddr, struct disassemble_info *info)
{
  int dialect = ((struct dis_private *) &info->private_data)->dialect;
  return print_insn_powerpc (memaddr, info, 0, dialect);
}

/* Print a POWER (RS/6000) instruction.  */

int
print_insn_rs6000 (bfd_vma memaddr, struct disassemble_info *info)
{
  return print_insn_powerpc (memaddr, info, 1, PPC_OPCODE_POWER);
}

/* Print a PowerPC or POWER instruction.  */

static int
print_insn_powerpc (bfd_vma memaddr,
		    struct disassemble_info *info,
		    int bigendian,
		    int dialect)
{
  bfd_byte buffer[4];
  int status;
  unsigned long insn;
  const struct powerpc_opcode *opcode;
  const struct powerpc_opcode *opcode_end;
  unsigned long op;

  if (dialect == 0)
    dialect = powerpc_dialect (info);

  status = (*info->read_memory_func) (memaddr, buffer, 4, info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, memaddr, info);
      return -1;
    }

  if (bigendian)
    insn = bfd_getb32 (buffer);
  else
    insn = bfd_getl32 (buffer);

  /* Get the major opcode of the instruction.  */
  op = PPC_OP (insn);

  /* Find the first match in the opcode table.  We could speed this up
     a bit by doing a binary search on the major opcode.  */
  opcode_end = powerpc_opcodes + powerpc_num_opcodes;
 again:
  for (opcode = powerpc_opcodes; opcode < opcode_end; opcode++)
    {
      unsigned long table_op;
      const unsigned char *opindex;
      const struct powerpc_operand *operand;
      int invalid;
      int need_comma;
      int need_paren;

      table_op = PPC_OP (opcode->opcode);
      if (op < table_op)
	break;
      if (op > table_op)
	continue;

      if ((insn & opcode->mask) != opcode->opcode
	  || (opcode->flags & dialect) == 0)
	continue;

      /* Make two passes over the operands.  First see if any of them
	 have extraction functions, and, if they do, make sure the
	 instruction is valid.  */
      invalid = 0;
      for (opindex = opcode->operands; *opindex != 0; opindex++)
	{
	  operand = powerpc_operands + *opindex;
	  if (operand->extract)
	    (*operand->extract) (insn, dialect, &invalid);
	}
      if (invalid)
	continue;

      /* The instruction is valid.  */
      if (opcode->operands[0] != 0)
	(*info->fprintf_func) (info->stream, "%-7s ", opcode->name);
      else
	(*info->fprintf_func) (info->stream, "%s", opcode->name);

      /* Now extract and print the operands.  */
      need_comma = 0;
      need_paren = 0;
      for (opindex = opcode->operands; *opindex != 0; opindex++)
	{
	  long value;

	  operand = powerpc_operands + *opindex;

	  /* Operands that are marked FAKE are simply ignored.  We
	     already made sure that the extract function considered
	     the instruction to be valid.  */
	  if ((operand->flags & PPC_OPERAND_FAKE) != 0)
	    continue;

	  /* Extract the value from the instruction.  */
	  if (operand->extract)
	    value = (*operand->extract) (insn, dialect, &invalid);
	  else
	    {
	      value = (insn >> operand->shift) & ((1 << operand->bits) - 1);
	      if ((operand->flags & PPC_OPERAND_SIGNED) != 0
		  && (value & (1 << (operand->bits - 1))) != 0)
		value -= 1 << operand->bits;
	    }

	  /* If the operand is optional, and the value is zero, don't
	     print anything.  */
	  if ((operand->flags & PPC_OPERAND_OPTIONAL) != 0
	      && (operand->flags & PPC_OPERAND_NEXT) == 0
	      && value == 0)
	    continue;

	  if (need_comma)
	    {
	      (*info->fprintf_func) (info->stream, ",");
	      need_comma = 0;
	    }

	  /* Print the operand as directed by the flags.  */
	  if ((operand->flags & PPC_OPERAND_GPR) != 0
	      || ((operand->flags & PPC_OPERAND_GPR_0) != 0 && value != 0))
	    (*info->fprintf_func) (info->stream, "r%ld", value);
	  else if ((operand->flags & PPC_OPERAND_FPR) != 0)
	    (*info->fprintf_func) (info->stream, "f%ld", value);
	  else if ((operand->flags & PPC_OPERAND_VR) != 0)
	    (*info->fprintf_func) (info->stream, "v%ld", value);
	  else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0)
	    (*info->print_address_func) (memaddr + value, info);
	  else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0)
	    (*info->print_address_func) ((bfd_vma) value & 0xffffffff, info);
	  else if ((operand->flags & PPC_OPERAND_CR) == 0
		   || (dialect & PPC_OPCODE_PPC) == 0)
	    (*info->fprintf_func) (info->stream, "%ld", value);
	  else
	    {
	      if (operand->bits == 3)
		(*info->fprintf_func) (info->stream, "cr%d", value);
	      else
		{
		  static const char *cbnames[4] = { "lt", "gt", "eq", "so" };
		  int cr;
		  int cc;

		  cr = value >> 2;
		  if (cr != 0)
		    (*info->fprintf_func) (info->stream, "4*cr%d+", cr);
		  cc = value & 3;
		  (*info->fprintf_func) (info->stream, "%s", cbnames[cc]);
		}
	    }

	  if (need_paren)
	    {
	      (*info->fprintf_func) (info->stream, ")");
	      need_paren = 0;
	    }

	  if ((operand->flags & PPC_OPERAND_PARENS) == 0)
	    need_comma = 1;
	  else
	    {
	      (*info->fprintf_func) (info->stream, "(");
	      need_paren = 1;
	    }
	}

      /* We have found and printed an instruction; return.  */
      return 4;
    }

  if ((dialect & PPC_OPCODE_ANY) != 0)
    {
      dialect = ~PPC_OPCODE_ANY;
      goto again;
    }

  /* We could not find a match.  */
  (*info->fprintf_func) (info->stream, ".long 0x%lx", insn);

  return 4;
}

void
print_ppc_disassembler_options (FILE *stream)
{
  fprintf (stream, "\n\
The following PPC specific disassembler options are supported for use with\n\
the -M switch:\n");

  fprintf (stream, "  booke|booke32|booke64    Disassemble the BookE instructions\n");
  fprintf (stream, "  e500|e500x2              Disassemble the e500 instructions\n");
  fprintf (stream, "  efs                      Disassemble the EFS instructions\n");
  fprintf (stream, "  power4                   Disassemble the Power4 instructions\n");
  fprintf (stream, "  32                       Do not disassemble 64-bit instructions\n");
  fprintf (stream, "  64                       Allow disassembly of 64-bit instructions\n");
}
@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 2
a3 1
   Copyright 1994, 1995, 2000, 2001, 2002 Free Software Foundation, Inc.
d33 1
a33 2
static int print_insn_powerpc PARAMS ((bfd_vma, struct disassemble_info *,
				       int bigendian, int dialect));
d35 4
a38 1
static int powerpc_dialect PARAMS ((struct disassemble_info *));
d44 2
a45 3
int
powerpc_dialect(info)
     struct disassemble_info *info;
d53 1
a53 3
      && (strcmp (info->disassembler_options, "booke") == 0
	  || strcmp (info->disassembler_options, "booke32") == 0
	  || strcmp (info->disassembler_options, "booke64") == 0))
d55 19
a73 22
  else
    if ((info->mach == bfd_mach_ppc_e500)
	|| (info->disassembler_options
	&& (   strcmp (info->disassembler_options, "e500") == 0
	    || strcmp (info->disassembler_options, "e500x2") == 0)))
      {
	dialect |= PPC_OPCODE_BOOKE
	  | PPC_OPCODE_SPE | PPC_OPCODE_ISEL
	  | PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
	  | PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK
	  | PPC_OPCODE_RFMCI;
	/* efs* and AltiVec conflict.  */
	dialect &= ~PPC_OPCODE_ALTIVEC;
      }
  else
    if (info->disassembler_options
	&& (strcmp (info->disassembler_options, "efs") == 0))
      {
	dialect |= PPC_OPCODE_EFS;
	/* efs* and AltiVec conflict.  */
	dialect &= ~PPC_OPCODE_ALTIVEC;
      }
d79 1
a79 1
      && strcmp (info->disassembler_options, "power4") == 0)
d82 4
d94 1
d101 1
a101 3
print_insn_big_powerpc (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
d103 2
a104 1
  return print_insn_powerpc (memaddr, info, 1, powerpc_dialect(info));
d110 1
a110 3
print_insn_little_powerpc (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
d112 2
a113 1
  return print_insn_powerpc (memaddr, info, 0, powerpc_dialect(info));
d119 1
a119 3
print_insn_rs6000 (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
d127 4
a130 5
print_insn_powerpc (memaddr, info, bigendian, dialect)
     bfd_vma memaddr;
     struct disassemble_info *info;
     int bigendian;
     int dialect;
d139 3
d160 1
a179 3
      if ((dialect & PPC_OPCODE_EFS) && (opcode->flags & PPC_OPCODE_ALTIVEC))
	continue;

a193 1
      (*info->fprintf_func) (info->stream, "%s", opcode->name);
d195 3
a197 1
	(*info->fprintf_func) (info->stream, "\t");
d216 1
a216 1
	    value = (*operand->extract) (insn, dialect, (int *) NULL);
d239 2
a240 1
	  if ((operand->flags & PPC_OPERAND_GPR) != 0)
d290 6
d303 1
a303 1
print_ppc_disassembler_options (FILE * stream)
@


1.3
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 2000 Free Software Foundation, Inc.
d35 62
a96 3
/* Print a big endian PowerPC instruction.  For convenience, also
   disassemble instructions supported by the Motorola PowerPC 601
   and the Altivec vector unit.  */
d103 1
a103 3
  return print_insn_powerpc (memaddr, info, 1,
			     PPC_OPCODE_PPC | PPC_OPCODE_601 |
			     PPC_OPCODE_ALTIVEC);
d106 1
a106 3
/* Print a little endian PowerPC instruction.  For convenience, also
   disassemble instructions supported by the Motorola PowerPC 601
   and the Altivec vector unit.  */
d113 1
a113 3
  return print_insn_powerpc (memaddr, info, 0,
			     PPC_OPCODE_PPC | PPC_OPCODE_601 |
			     PPC_OPCODE_ALTIVEC);
d179 3
d190 1
a190 1
	    (*operand->extract) (insn, &invalid);
d217 1
a217 1
	    value = (*operand->extract) (insn, (int *) NULL);
d265 1
a265 1
		    (*info->fprintf_func) (info->stream, "4*cr%d", cr);
d267 1
a267 6
		  if (cc != 0)
		    {
		      if (cr != 0)
			(*info->fprintf_func) (info->stream, "+");
		      (*info->fprintf_func) (info->stream, "%s", cbnames[cc]);
		    }
d294 15
@


1.2
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright 1994 Free Software Foundation, Inc.
d36 2
a37 1
   disassemble instructions supported by the Motorola PowerPC 601.  */
d45 2
a46 1
			     PPC_OPCODE_PPC | PPC_OPCODE_601);
d50 2
a51 1
   disassemble instructions supported by the Motorola PowerPC 601.  */
d59 2
a60 1
			     PPC_OPCODE_PPC | PPC_OPCODE_601);
d188 2
@


1.1
log
@Initial revision
@
text
@a21 1
#include "ansidecl.h"
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d22 1
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 2000 Free Software Foundation, Inc.
d36 1
a36 2
   disassemble instructions supported by the Motorola PowerPC 601
   and the Altivec vector unit.  */
d44 1
a44 2
			     PPC_OPCODE_PPC | PPC_OPCODE_601 |
			     PPC_OPCODE_ALTIVEC);
d48 1
a48 2
   disassemble instructions supported by the Motorola PowerPC 601
   and the Altivec vector unit.  */
d56 1
a56 2
			     PPC_OPCODE_PPC | PPC_OPCODE_601 |
			     PPC_OPCODE_ALTIVEC);
a183 2
	  else if ((operand->flags & PPC_OPERAND_VR) != 0)
	    (*info->fprintf_func) (info->stream, "v%ld", value);
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 2000, 2001, 2002 Free Software Foundation, Inc.
d35 3
a37 62
static int powerpc_dialect PARAMS ((struct disassemble_info *));

/* Determine which set of machines to disassemble for.  PPC403/601 or
   BookE.  For convenience, also disassemble instructions supported
   by the AltiVec vector unit.  */

int
powerpc_dialect(info)
     struct disassemble_info *info;
{
  int dialect = PPC_OPCODE_PPC | PPC_OPCODE_ALTIVEC;

  if (BFD_DEFAULT_TARGET_SIZE == 64)
    dialect |= PPC_OPCODE_64;

  if (info->disassembler_options
      && (strcmp (info->disassembler_options, "booke") == 0
	  || strcmp (info->disassembler_options, "booke32") == 0
	  || strcmp (info->disassembler_options, "booke64") == 0))
    dialect |= PPC_OPCODE_BOOKE | PPC_OPCODE_BOOKE64;
  else
    if ((info->mach == bfd_mach_ppc_e500)
	|| (info->disassembler_options
	&& (   strcmp (info->disassembler_options, "e500") == 0
	    || strcmp (info->disassembler_options, "e500x2") == 0)))
      {
	dialect |= PPC_OPCODE_BOOKE
	  | PPC_OPCODE_SPE | PPC_OPCODE_ISEL
	  | PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
	  | PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK
	  | PPC_OPCODE_RFMCI;
	/* efs* and AltiVec conflict.  */
	dialect &= ~PPC_OPCODE_ALTIVEC;
      }
  else
    if (info->disassembler_options
	&& (strcmp (info->disassembler_options, "efs") == 0))
      {
	dialect |= PPC_OPCODE_EFS;
	/* efs* and AltiVec conflict.  */
	dialect &= ~PPC_OPCODE_ALTIVEC;
      }
  else
    dialect |= (PPC_OPCODE_403 | PPC_OPCODE_601 | PPC_OPCODE_CLASSIC
		| PPC_OPCODE_COMMON);

  if (info->disassembler_options
      && strcmp (info->disassembler_options, "power4") == 0)
    dialect |= PPC_OPCODE_POWER4;

  if (info->disassembler_options)
    {
      if (strstr (info->disassembler_options, "32") != NULL)
	dialect &= ~PPC_OPCODE_64;
      else if (strstr (info->disassembler_options, "64") != NULL)
	dialect |= PPC_OPCODE_64;
    }

  return dialect;
}

/* Print a big endian PowerPC instruction.  */
d44 3
a46 1
  return print_insn_powerpc (memaddr, info, 1, powerpc_dialect(info));
d49 3
a51 1
/* Print a little endian PowerPC instruction.  */
d58 3
a60 1
  return print_insn_powerpc (memaddr, info, 0, powerpc_dialect(info));
a125 3
      if ((dialect & PPC_OPCODE_EFS) && (opcode->flags & PPC_OPCODE_ALTIVEC))
	continue;

d134 1
a134 1
	    (*operand->extract) (insn, dialect, &invalid);
d161 1
a161 1
	    value = (*operand->extract) (insn, dialect, (int *) NULL);
d209 1
a209 1
		    (*info->fprintf_func) (info->stream, "4*cr%d+", cr);
d211 6
a216 1
		  (*info->fprintf_func) (info->stream, "%s", cbnames[cc]);
a242 15
}

void
print_ppc_disassembler_options (FILE * stream)
{
  fprintf (stream, "\n\
The following PPC specific disassembler options are supported for use with\n\
the -M switch:\n");

  fprintf (stream, "  booke|booke32|booke64    Disassemble the BookE instructions\n");
  fprintf (stream, "  e500|e500x2              Disassemble the e500 instructions\n");
  fprintf (stream, "  efs                      Disassemble the EFS instructions\n");
  fprintf (stream, "  power4                   Disassemble the Power4 instructions\n");
  fprintf (stream, "  32                       Do not disassemble 64-bit instructions\n");
  fprintf (stream, "  64                       Allow disassembly of 64-bit instructions\n");
@


1.1.1.5
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d32 2
a33 1
static int print_insn_powerpc (bfd_vma, struct disassemble_info *, int, int);
d35 1
a35 4
struct dis_private {
  /* Stash the result of parsing disassembler_options here.  */
  int dialect;
};
d41 3
a43 2
static int
powerpc_dialect (struct disassemble_info *info)
d51 3
a53 1
      && strstr (info->disassembler_options, "booke") != NULL)
d55 22
a76 19
  else if ((info->mach == bfd_mach_ppc_e500)
	   || (info->disassembler_options
	       && strstr (info->disassembler_options, "e500") != NULL))
    {
      dialect |= PPC_OPCODE_BOOKE
	| PPC_OPCODE_SPE | PPC_OPCODE_ISEL
	| PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
	| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK
	| PPC_OPCODE_RFMCI;
      /* efs* and AltiVec conflict.  */
      dialect &= ~PPC_OPCODE_ALTIVEC;
    }
  else if (info->disassembler_options
	   && strstr (info->disassembler_options, "efs") != NULL)
    {
      dialect |= PPC_OPCODE_EFS;
      /* efs* and AltiVec conflict.  */
      dialect &= ~PPC_OPCODE_ALTIVEC;
    }
d82 1
a82 1
      && strstr (info->disassembler_options, "power4") != NULL)
a84 4
  if (info->disassembler_options
      && strstr (info->disassembler_options, "any") != NULL)
    dialect |= PPC_OPCODE_ANY;

a92 1
  ((struct dis_private *) &info->private_data)->dialect = dialect;
d99 3
a101 1
print_insn_big_powerpc (bfd_vma memaddr, struct disassemble_info *info)
d103 1
a103 2
  int dialect = ((struct dis_private *) &info->private_data)->dialect;
  return print_insn_powerpc (memaddr, info, 1, dialect);
d109 3
a111 1
print_insn_little_powerpc (bfd_vma memaddr, struct disassemble_info *info)
d113 1
a113 2
  int dialect = ((struct dis_private *) &info->private_data)->dialect;
  return print_insn_powerpc (memaddr, info, 0, dialect);
d119 3
a121 1
print_insn_rs6000 (bfd_vma memaddr, struct disassemble_info *info)
d129 5
a133 4
print_insn_powerpc (bfd_vma memaddr,
		    struct disassemble_info *info,
		    int bigendian,
		    int dialect)
a141 3
  if (dialect == 0)
    dialect = powerpc_dialect (info);

a159 1
 again:
d179 3
d196 1
d198 1
a198 3
	(*info->fprintf_func) (info->stream, "%-7s ", opcode->name);
      else
	(*info->fprintf_func) (info->stream, "%s", opcode->name);
d217 1
a217 1
	    value = (*operand->extract) (insn, dialect, &invalid);
d240 1
a240 2
	  if ((operand->flags & PPC_OPERAND_GPR) != 0
	      || ((operand->flags & PPC_OPERAND_GPR_0) != 0 && value != 0))
a289 6
  if ((dialect & PPC_OPCODE_ANY) != 0)
    {
      dialect = ~PPC_OPCODE_ANY;
      goto again;
    }

d297 1
a297 1
print_ppc_disassembler_options (FILE *stream)
@


