head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.5.0.52
	OPENBSD_6_1_BASE:1.1.1.5
	OPENBSD_6_0:1.1.1.5.0.48
	OPENBSD_6_0_BASE:1.1.1.5
	OPENBSD_5_9:1.1.1.5.0.44
	OPENBSD_5_9_BASE:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.46
	OPENBSD_5_8_BASE:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.38
	OPENBSD_5_7_BASE:1.1.1.5
	OPENBSD_5_6:1.1.1.5.0.42
	OPENBSD_5_6_BASE:1.1.1.5
	OPENBSD_5_5:1.1.1.5.0.40
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.36
	OPENBSD_5_4_BASE:1.1.1.5
	OPENBSD_5_3:1.1.1.5.0.34
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.32
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.30
	OPENBSD_5_0:1.1.1.5.0.28
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.26
	OPENBSD_4_9_BASE:1.1.1.5
	OPENBSD_4_8:1.1.1.5.0.24
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.20
	OPENBSD_4_7_BASE:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.22
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.18
	OPENBSD_4_5_BASE:1.1.1.5
	OPENBSD_4_4:1.1.1.5.0.16
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.14
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.12
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.10
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.8
	OPENBSD_4_0_BASE:1.1.1.5
	OPENBSD_3_9:1.1.1.5.0.6
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.4
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.2
	OPENBSD_3_7_BASE:1.1.1.5
	BINUTILS_2_15:1.1.1.5
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.1.1.3.0.8
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.6
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.4
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.2
	OPENBSD_3_2_BASE:1.1.1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.1.1.2.0.8
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.6
	OPENBSD_3_0_BASE:1.1.1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.1.1.2.0.4
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.2
	OPENBSD_2_8_BASE:1.1.1.2
	BINUTILS-2_10:1.1.1.2
	FSF:1.1.1
	OPENBSD_2_7:1.1.1.1.0.14
	OPENBSD_2_7_BASE:1.1.1.1
	new-binutils:1.1.1.1.0.12
	OPENBSD_2_6:1.1.1.1.0.10
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.8
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.6
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.4
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.2
	OPENBSD_2_2_BASE:1.1.1.1
	BINUTILS-2_8_1:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	97.05.29.09.27.47;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.29.09.27.47;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.47.50;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.55.25;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.42;	author drahn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.11.02.20.23.07;	author miod;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* CGEN generic assembler support code.

Copyright (C) 1996, 1997 Free Software Foundation, Inc.

This file is part of the GNU Binutils and GDB, the GNU debugger.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "sysdep.h"
#include <stdio.h>
#include "ansidecl.h"
#include "libiberty.h"
#include "bfd.h"
#include "opcode/cgen.h"

/* Operand parsing callback.  */
const char * (*cgen_parse_operand_fn)
     PARAMS ((enum cgen_parse_operand_type, const char **, int, int,
	      enum cgen_parse_operand_result *, bfd_vma *));

/* This is not published as part of the public interface so we don't
   declare this in cgen.h.  */
extern CGEN_OPCODE_DATA *cgen_current_opcode_data;

/* Assembler instruction hash table.  */
static CGEN_INSN_LIST **asm_hash_table;

/* Called once at startup and whenever machine/endian change.  */

void
cgen_asm_init ()
{
  if (asm_hash_table)
    {
      free (asm_hash_table);
      asm_hash_table = NULL;
    }
}

/* Called whenever starting to parse an insn.  */

void
cgen_init_parse_operand ()
{
  /* This tells the callback to re-initialize.  */
  (void) (*cgen_parse_operand_fn) (CGEN_PARSE_OPERAND_INIT, NULL, 0, 0,
				   NULL, NULL);
}

/* Build the assembler instruction hash table.  */

static void
build_asm_hash_table ()
{
  int i;
  unsigned int hash;
  int count = cgen_insn_count ();
  CGEN_OPCODE_DATA *data = cgen_current_opcode_data;
  CGEN_INSN_TABLE *insn_table = data->insn_table;
  unsigned int hash_size = insn_table->asm_hash_table_size;
  const CGEN_INSN *insn;
  CGEN_INSN_LIST *insn_lists,*new_insns;

  /* The space allocated for the hash table consists of two parts:
     the hash table and the hash lists.  */

  asm_hash_table = (CGEN_INSN_LIST **)
    xmalloc (hash_size * sizeof (CGEN_INSN_LIST *)
	     + count * sizeof (CGEN_INSN_LIST));
  memset (asm_hash_table, 0,
	  hash_size * sizeof (CGEN_INSN_LIST *)
	  + count * sizeof (CGEN_INSN_LIST));
  insn_lists = (CGEN_INSN_LIST *) (asm_hash_table + hash_size);

  /* Add compiled in insns.
     The table is scanned backwards as later additions are inserted in
     front of earlier ones and we want earlier ones to be prefered.
     We stop at the first one as it is a reserved entry.  */

  for (insn = insn_table->init_entries + insn_table->num_init_entries - 1;
       insn > insn_table->init_entries;
       --insn, ++insn_lists)
    {
      hash = (*insn_table->asm_hash) (insn->syntax.mnemonic);
      insn_lists->next = asm_hash_table[hash];
      insn_lists->insn = insn;
      asm_hash_table[hash] = insn_lists;
    }

  /* Add runtime added insns.
     ??? Currently later added insns will be prefered over earlier ones.
     Not sure this is a bug or not.  */
  for (new_insns = insn_table->new_entries;
       new_insns != NULL;
       new_insns = new_insns->next, ++insn_lists)
    {
      hash = (*insn_table->asm_hash) (new_insns->insn->syntax.mnemonic);
      insn_lists->next = asm_hash_table[hash];
      insn_lists->insn = new_insns->insn;
      asm_hash_table[hash] = insn_lists;
    }
}

/* Return the first entry in the hash list for INSN.  */

CGEN_INSN_LIST *
cgen_asm_lookup_insn (insn)
     const char *insn;
{
  unsigned int hash;

  if (asm_hash_table == NULL)
    build_asm_hash_table ();

  hash = (*cgen_current_opcode_data->insn_table->asm_hash) (insn);
  return asm_hash_table[hash];
}

/* Keyword parser.
   The result is NULL upon success or an error message.
   If successful, *STRP is updated to point passed the keyword.

   ??? At present we have a static notion of how to pick out a keyword.
   Later we can allow a target to customize this if necessary [say by
   recording something in the keyword table].  */

const char *
cgen_parse_keyword (strp, keyword_table, valuep)
     const char **strp;
     struct cgen_keyword *keyword_table;
     long *valuep;
{
  const struct cgen_keyword_entry *ke;
  char buf[256];
  const char *p;

  p = *strp;

  /* Allow any first character.  */
  if (*p)
    ++p;

  /* Now allow letters, digits, and _.  */
  while (isalnum (*p) || *p == '_')
    ++p;

  if (p - *strp > 255)
    return "unrecognized keyword/register name";

  memcpy (buf, *strp, p - *strp);
  buf[p - *strp] = 0;

  ke = cgen_keyword_lookup_name (keyword_table, buf);

  if (ke != NULL)
    {
      *valuep = ke->value;
      *strp = p;
      return NULL;
    }

  return "unrecognized keyword/register name";
}

/* Signed integer parser.  */

const char *
cgen_parse_signed_integer (strp, opindex, min, max, valuep)
     const char **strp;
     int opindex;
     long min, max;
     long *valuep;
{
  long value;
  enum cgen_parse_operand_result result;
  const char *errmsg;

  errmsg = (*cgen_parse_operand_fn) (CGEN_PARSE_OPERAND_INTEGER, strp,
				     opindex, BFD_RELOC_NONE,
				     &result, &value);
  /* FIXME: Examine `result'.  */
  if (!errmsg)
    {
      if (value < min || value > max)
	return "integer operand out of range";
      *valuep = value;
    }
  return errmsg;
}

/* Unsigned integer parser.  */

const char *
cgen_parse_unsigned_integer (strp, opindex, min, max, valuep)
     const char **strp;
     int opindex;
     unsigned long min, max;
     unsigned long *valuep;
{
  unsigned long value;
  enum cgen_parse_operand_result result;
  const char *errmsg;

  errmsg = (*cgen_parse_operand_fn) (CGEN_PARSE_OPERAND_INTEGER, strp,
				     opindex, BFD_RELOC_NONE,
				     &result, &value);
  /* FIXME: Examine `result'.  */
  if (!errmsg)
    {
      if (value < min || value > max)
	return "integer operand out of range";
      *valuep = value;
    }
  return errmsg;
}

/* Address parser.  */

const char *
cgen_parse_address (strp, opindex, opinfo, valuep)
     const char **strp;
     int opindex;
     int opinfo;
     long *valuep;
{
  long value;
  enum cgen_parse_operand_result result;
  const char *errmsg;

  errmsg = (*cgen_parse_operand_fn) (CGEN_PARSE_OPERAND_ADDRESS, strp,
				     opindex, opinfo,
				     &result, &value);
  /* FIXME: Examine `result'.  */
  if (!errmsg)
    {
      *valuep = value;
    }
  return errmsg;
}

/* Signed integer validation routine.  */

const char *
cgen_validate_signed_integer (value, min, max)
     long value, min, max;
{
  if (value < min || value > max)
    {
      const char *err =
	"operand out of range (%ld not between %ld and %ld)";
      static char buf[100];

      sprintf (buf, err, value, min, max);
      return buf;
    }

  return NULL;
}

/* Unsigned integer validation routine.
   Supplying `min' here may seem unnecessary, but we also want to handle
   cases where min != 0 (and max > LONG_MAX).  */

const char *
cgen_validate_unsigned_integer (value, min, max)
     unsigned long value, min, max;
{
  if (value < min || value > max)
    {
      const char *err =
	"operand out of range (%lu not between %lu and %lu)";
      static char buf[100];

      sprintf (buf, err, value, min, max);
      return buf;
    }

  return NULL;
}
@


1.1.1.1
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d3 1
a3 1
   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
d5 1
a5 1
   This file is part of the GNU Binutils and GDB, the GNU debugger.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License along
   with this program; if not, write to the Free Software Foundation, Inc.,
   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a22 1
#include <ctype.h>
a25 1
#include "symcat.h"
a26 1
#include "opintl.h"
d28 13
a40 1
/* Set the cgen_parse_operand_fn callback.  */
d43 1
a43 3
cgen_set_parse_operand_fn (cd, fn)
     CGEN_CPU_DESC cd;
     cgen_parse_operand_fn fn;
d45 5
a49 1
  cd->parse_operand_fn = fn;
d55 1
a55 2
cgen_init_parse_operand (cd)
     CGEN_CPU_DESC cd;
d58 2
a59 69
  (void) (* cd->parse_operand_fn)
    (cd, CGEN_PARSE_OPERAND_INIT, NULL, 0, 0, NULL, NULL);
}

/* Subroutine of build_asm_hash_table to add INSNS to the hash table.

   COUNT is the number of elements in INSNS.
   ENTSIZE is sizeof (CGEN_IBASE) for the target.
   ??? No longer used but leave in for now.
   HTABLE points to the hash table.
   HENTBUF is a pointer to sufficiently large buffer of hash entries.
   The result is a pointer to the next entry to use.

   The table is scanned backwards as additions are made to the front of the
   list and we want earlier ones to be prefered.  */

static CGEN_INSN_LIST *
hash_insn_array (cd, insns, count, entsize, htable, hentbuf)
     CGEN_CPU_DESC cd;
     const CGEN_INSN *insns;
     int count;
     int entsize;
     CGEN_INSN_LIST **htable;
     CGEN_INSN_LIST *hentbuf;
{
  int i;

  for (i = count - 1; i >= 0; --i, ++hentbuf)
    {
      unsigned int hash;
      const CGEN_INSN *insn = &insns[i];

      if (! (* cd->asm_hash_p) (insn))
	continue;
      hash = (* cd->asm_hash) (CGEN_INSN_MNEMONIC (insn));
      hentbuf->next = htable[hash];
      hentbuf->insn = insn;
      htable[hash] = hentbuf;
    }

  return hentbuf;
}

/* Subroutine of build_asm_hash_table to add INSNS to the hash table.
   This function is identical to hash_insn_array except the insns are
   in a list.  */

static CGEN_INSN_LIST *
hash_insn_list (cd, insns, htable, hentbuf)
     CGEN_CPU_DESC cd;
     const CGEN_INSN_LIST *insns;
     CGEN_INSN_LIST **htable;
     CGEN_INSN_LIST *hentbuf;
{
  const CGEN_INSN_LIST *ilist;

  for (ilist = insns; ilist != NULL; ilist = ilist->next, ++ hentbuf)
    {
      unsigned int hash;

      if (! (* cd->asm_hash_p) (ilist->insn))
	continue;
      hash = (* cd->asm_hash) (CGEN_INSN_MNEMONIC (ilist->insn));
      hentbuf->next = htable[hash];
      hentbuf->insn = ilist->insn;
      htable[hash] = hentbuf;
    }

  return hentbuf;
d65 1
a65 2
build_asm_hash_table (cd)
     CGEN_CPU_DESC cd;
d67 8
a74 7
  int count = cgen_insn_count (cd) + cgen_macro_insn_count (cd);
  CGEN_INSN_TABLE *insn_table = &cd->insn_table;
  CGEN_INSN_TABLE *macro_insn_table = &cd->macro_insn_table;
  unsigned int hash_size = cd->asm_hash_size;
  CGEN_INSN_LIST *hash_entry_buf;
  CGEN_INSN_LIST **asm_hash_table;
  CGEN_INSN_LIST *asm_hash_table_entries;
d80 6
a85 4
    xmalloc (hash_size * sizeof (CGEN_INSN_LIST *));
  memset (asm_hash_table, 0, hash_size * sizeof (CGEN_INSN_LIST *));
  asm_hash_table_entries = hash_entry_buf = (CGEN_INSN_LIST *)
    xmalloc (count * sizeof (CGEN_INSN_LIST));
d88 13
a100 16
     Don't include the first one as it is a reserved entry.  */
  /* ??? It was the end of all hash chains, and also the special
     "invalid insn" marker.  May be able to do it differently now.  */

  hash_entry_buf = hash_insn_array (cd,
				    insn_table->init_entries + 1,
				    insn_table->num_init_entries - 1,
				    insn_table->entry_size,
				    asm_hash_table, hash_entry_buf);

  /* Add compiled in macro-insns.  */

  hash_entry_buf = hash_insn_array (cd, macro_insn_table->init_entries,
				    macro_insn_table->num_init_entries,
				    macro_insn_table->entry_size,
				    asm_hash_table, hash_entry_buf);
d103 11
a113 12
     Later added insns will be prefered over earlier ones.  */

  hash_entry_buf = hash_insn_list (cd, insn_table->new_entries,
				   asm_hash_table, hash_entry_buf);

  /* Add runtime added macro-insns.  */

  hash_insn_list (cd, macro_insn_table->new_entries,
		  asm_hash_table, hash_entry_buf);

  cd->asm_hash_table = asm_hash_table;
  cd->asm_hash_table_entries = asm_hash_table_entries;
d119 1
a119 2
cgen_asm_lookup_insn (cd, insn)
     CGEN_CPU_DESC cd;
d124 2
a125 2
  if (cd->asm_hash_table == NULL)
    build_asm_hash_table (cd);
d127 2
a128 2
  hash = (* cd->asm_hash) (insn);
  return cd->asm_hash_table[hash];
d140 1
a140 2
cgen_parse_keyword (cd, strp, keyword_table, valuep)
     CGEN_CPU_DESC cd;
d142 1
a142 1
     CGEN_KEYWORD *keyword_table;
d145 1
a145 1
  const CGEN_KEYWORD_ENTRY *ke;
d147 1
a147 1
  const char *p,*start;
d149 1
a149 1
  p = start = *strp;
d151 1
a151 3
  /* Allow any first character.
     Note that this allows recognizing ",a" for the annul flag in sparc
     even though "," is subsequently not a valid keyword char.  */
d156 1
a156 2
  while (((p - start) < (int) sizeof (buf))
	 && (isalnum ((unsigned char) *p) || *p == '_'))
d159 2
a160 2
  if (p - start >= (int) sizeof (buf))
    return _("unrecognized keyword/register name");
d162 2
a163 2
  memcpy (buf, start, p - start);
  buf[p - start] = 0;
d170 1
a170 3
      /* Don't advance pointer if we recognized the null keyword.  */
      if (ke->name[0] != 0)
	*strp = p;
d177 1
a177 4
/* Parse a small signed integer parser.
   ??? VALUEP is not a bfd_vma * on purpose, though this is confusing.
   Note that if the caller expects a bfd_vma result, it should call
   cgen_parse_address.  */
d180 1
a180 2
cgen_parse_signed_integer (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
d183 1
d186 1
a186 1
  bfd_vma value;
d190 3
a192 3
  errmsg = (* cd->parse_operand_fn)
    (cd, CGEN_PARSE_OPERAND_INTEGER, strp, opindex, BFD_RELOC_NONE,
     &result, &value);
d195 5
a199 1
    *valuep = value;
d203 1
a203 4
/* Parse a small unsigned integer parser.
   ??? VALUEP is not a bfd_vma * on purpose, though this is confusing.
   Note that if the caller expects a bfd_vma result, it should call
   cgen_parse_address.  */
d206 1
a206 2
cgen_parse_unsigned_integer (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
d209 1
d212 1
a212 1
  bfd_vma value;
d216 3
a218 3
  errmsg = (* cd->parse_operand_fn)
    (cd, CGEN_PARSE_OPERAND_INTEGER, strp, opindex, BFD_RELOC_NONE,
     &result, &value);
d221 5
a225 1
    *valuep = value;
d232 1
a232 2
cgen_parse_address (cd, strp, opindex, opinfo, resultp, valuep)
     CGEN_CPU_DESC cd;
d236 1
a236 2
     enum cgen_parse_operand_result *resultp;
     bfd_vma *valuep;
d238 2
a239 2
  bfd_vma value;
  enum cgen_parse_operand_result result_type;
d242 3
a244 3
  errmsg = (* cd->parse_operand_fn)
    (cd, CGEN_PARSE_OPERAND_ADDRESS, strp, opindex, opinfo,
     &result_type, &value);
a247 2
      if (resultp != NULL)
	*resultp = result_type;
d261 2
d265 1
a265 3
      /* xgettext:c-format */
      sprintf (buf, _("operand out of range (%ld not between %ld and %ld)"),
		      value, min, max);
d282 2
d286 1
a286 3
      /* xgettext:c-format */
      sprintf (buf, _("operand out of range (%lu not between %lu and %lu)"),
	       value, min, max);
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d69 1
a69 1
     int entsize ATTRIBUTE_UNUSED;
d201 1
a201 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d23 1
a25 1
#include "safe-ctype.h"
a30 4
static CGEN_INSN_LIST *  hash_insn_array      PARAMS ((CGEN_CPU_DESC, const CGEN_INSN *, int, int, CGEN_INSN_LIST **, CGEN_INSN_LIST *));
static CGEN_INSN_LIST *  hash_insn_list       PARAMS ((CGEN_CPU_DESC, const CGEN_INSN_LIST *, CGEN_INSN_LIST **, CGEN_INSN_LIST *));
static void              build_asm_hash_table PARAMS ((CGEN_CPU_DESC));

a209 3
  if (keyword_table->name_hash_table == NULL)
    (void) cgen_keyword_search_init (keyword_table, NULL);

d212 3
a214 3
  /* Allow any first character.  This is to make life easier for
     the fairly common case of suffixes, eg. 'ld.b.w', where the first
     character of the suffix ('.') is special.  */
d217 2
a218 2
  
  /* Allow letters, digits, and any special characters.  */
d220 1
a220 4
	 && *p
	 && (ISALNUM (*p)
	     || *p == '_'
	     || strchr (keyword_table->nonalpha_chars, *p)))
d224 4
a227 10
    {
      /* All non-empty CGEN keywords can fit into BUF.  The only thing
	 we can match here is the empty keyword.  */
      buf[0] = 0;
    }
  else
    {
      memcpy (buf, start, p - start);
      buf[p - start] = 0;
    }
@


1.1.1.5
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d31 3
a33 3
static CGEN_INSN_LIST *  hash_insn_array      (CGEN_CPU_DESC, const CGEN_INSN *, int, int, CGEN_INSN_LIST **, CGEN_INSN_LIST *);
static CGEN_INSN_LIST *  hash_insn_list       (CGEN_CPU_DESC, const CGEN_INSN_LIST *, CGEN_INSN_LIST **, CGEN_INSN_LIST *);
static void              build_asm_hash_table (CGEN_CPU_DESC);
d38 3
a40 1
cgen_set_parse_operand_fn (CGEN_CPU_DESC cd, cgen_parse_operand_fn fn)
d48 2
a49 1
cgen_init_parse_operand (CGEN_CPU_DESC cd)
d69 7
a75 6
hash_insn_array (CGEN_CPU_DESC cd,
		 const CGEN_INSN *insns,
		 int count,
		 int entsize ATTRIBUTE_UNUSED,
		 CGEN_INSN_LIST **htable,
		 CGEN_INSN_LIST *hentbuf)
d100 5
a104 4
hash_insn_list (CGEN_CPU_DESC cd,
		const CGEN_INSN_LIST *insns,
		CGEN_INSN_LIST **htable,
		CGEN_INSN_LIST *hentbuf)
d126 2
a127 1
build_asm_hash_table (CGEN_CPU_DESC cd)
d182 3
a184 1
cgen_asm_lookup_insn (CGEN_CPU_DESC cd, const char *insn)
d204 5
a208 4
cgen_parse_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		    const char **strp,
		    CGEN_KEYWORD *keyword_table,
		    long *valuep)
d265 5
a269 4
cgen_parse_signed_integer (CGEN_CPU_DESC cd,
			   const char **strp,
			   int opindex,
			   long *valuep)
d290 5
a294 4
cgen_parse_unsigned_integer (CGEN_CPU_DESC cd,
			     const char **strp,
			     int opindex,
			     unsigned long *valuep)
d312 7
a318 6
cgen_parse_address (CGEN_CPU_DESC cd,
		    const char **strp,
		    int opindex,
		    int opinfo,
		    enum cgen_parse_operand_result *resultp,
		    bfd_vma *valuep)
d340 2
a341 1
cgen_validate_signed_integer (long value, long min, long max)
d361 2
a362 3
cgen_validate_unsigned_integer (unsigned long value,
				unsigned long min,
				unsigned long max)
@


