head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.5
	OPENBSD_6_1:1.1.1.5.0.52
	OPENBSD_6_1_BASE:1.1.1.5
	OPENBSD_6_0:1.1.1.5.0.48
	OPENBSD_6_0_BASE:1.1.1.5
	OPENBSD_5_9:1.1.1.5.0.44
	OPENBSD_5_9_BASE:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.46
	OPENBSD_5_8_BASE:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.38
	OPENBSD_5_7_BASE:1.1.1.5
	OPENBSD_5_6:1.1.1.5.0.42
	OPENBSD_5_6_BASE:1.1.1.5
	OPENBSD_5_5:1.1.1.5.0.40
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.36
	OPENBSD_5_4_BASE:1.1.1.5
	OPENBSD_5_3:1.1.1.5.0.34
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.32
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.30
	OPENBSD_5_0:1.1.1.5.0.28
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.26
	OPENBSD_4_9_BASE:1.1.1.5
	OPENBSD_4_8:1.1.1.5.0.24
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.20
	OPENBSD_4_7_BASE:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.22
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.18
	OPENBSD_4_5_BASE:1.1.1.5
	OPENBSD_4_4:1.1.1.5.0.16
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.14
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.12
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.10
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.8
	OPENBSD_4_0_BASE:1.1.1.5
	OPENBSD_3_9:1.1.1.5.0.6
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.4
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.2
	OPENBSD_3_7_BASE:1.1.1.5
	BINUTILS_2_15:1.1.1.5
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.1.1.3.0.8
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.6
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.4
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.2
	OPENBSD_3_2_BASE:1.1.1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.1.1.2.0.8
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.6
	OPENBSD_3_0_BASE:1.1.1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.1.1.2.0.4
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.2
	OPENBSD_2_8_BASE:1.1.1.2
	BINUTILS-2_10:1.1.1.2
	FSF:1.1.1
	OPENBSD_2_7:1.1.1.1.0.14
	OPENBSD_2_7_BASE:1.1.1.1
	new-binutils:1.1.1.1.0.12
	OPENBSD_2_6:1.1.1.1.0.10
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.8
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.6
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.4
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.2
	OPENBSD_2_2_BASE:1.1.1.1
	BINUTILS-2_8_1:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	97.05.29.09.27.47;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.29.09.27.47;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.47.50;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.55.28;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.43;	author drahn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.11.02.20.23.08;	author miod;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* CGEN generic disassembler support code.

Copyright (C) 1996, 1997 Free Software Foundation, Inc.

This file is part of the GNU Binutils and GDB, the GNU debugger.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "sysdep.h"
#include <stdio.h>
#include "ansidecl.h"
#include "libiberty.h"
#include "bfd.h"
#include "opcode/cgen.h"

/* This is not published as part of the public interface so we don't
   declare this in cgen.h.  */
extern CGEN_OPCODE_DATA *cgen_current_opcode_data;

/* Disassembler instruction hash table.  */
static CGEN_INSN_LIST **dis_hash_table;

void
cgen_dis_init ()
{
  if (dis_hash_table)
    {
      free (dis_hash_table);
      dis_hash_table = NULL;
    }
}

/* Build the disassembler instruction hash table.  */

static void
build_dis_hash_table ()
{
  int i;
  int big_p = cgen_current_endian == CGEN_ENDIAN_BIG;
  unsigned int hash;
  char buf[4];
  unsigned long value;
  int count = cgen_insn_count ();
  CGEN_OPCODE_DATA *data = cgen_current_opcode_data;
  CGEN_INSN_TABLE *insn_table = data->insn_table;
  unsigned int hash_size = insn_table->dis_hash_table_size;
  const CGEN_INSN *insn;
  CGEN_INSN_LIST *insn_lists,*new_insns;

  /* The space allocated for the hash table consists of two parts:
     the hash table and the hash lists.  */

  dis_hash_table = (CGEN_INSN_LIST **)
    xmalloc (hash_size * sizeof (CGEN_INSN_LIST *)
	     + count * sizeof (CGEN_INSN_LIST));
  memset (dis_hash_table, 0,
	  hash_size * sizeof (CGEN_INSN_LIST *)
	  + count * sizeof (CGEN_INSN_LIST));
  insn_lists = (CGEN_INSN_LIST *) (dis_hash_table + hash_size);

  /* Add compiled in insns.
     The table is scanned backwards as later additions are inserted in
     front of earlier ones and we want earlier ones to be prefered.
     We stop at the first one as it is a reserved entry.  */

  for (insn = insn_table->init_entries + insn_table->num_init_entries - 1;
       insn > insn_table->init_entries;
       --insn, ++insn_lists)
    {
      /* We don't know whether the target uses the buffer or the base insn
	 to hash on, so set both up.  */
      value = insn->syntax.value;
      switch (CGEN_INSN_BITSIZE (insn))
	{
	case 8:
	  buf[0] = value;
	  break;
	case 16:
	  if (big_p)
	    bfd_putb16 ((bfd_vma) value, buf);
	  else
	    bfd_putl16 ((bfd_vma) value, buf);
	  break;
	case 32:
	  if (big_p)
	    bfd_putb32 ((bfd_vma) value, buf);
	  else
	    bfd_putl32 ((bfd_vma) value, buf);
	  break;
	default:
	  abort ();
	}
      hash = (*insn_table->dis_hash) (buf, value);
      insn_lists->next = dis_hash_table[hash];
      insn_lists->insn = insn;
      dis_hash_table[hash] = insn_lists;
    }

  /* Add runtime added insns.
     ??? Currently later added insns will be prefered over earlier ones.
     Not sure this is a bug or not.  */
  for (new_insns = insn_table->new_entries;
       new_insns != NULL;
       new_insns = new_insns->next, ++insn_lists)
    {
      /* We don't know whether the target uses the buffer or the base insn
	 to hash on, so set both up.  */
      value = new_insns->insn->syntax.value;
      switch (CGEN_INSN_BITSIZE (new_insns->insn))
	{
	case 8:
	  buf[0] = value;
	  break;
	case 16:
	  if (big_p)
	    bfd_putb16 ((bfd_vma) value, buf);
	  else
	    bfd_putl16 ((bfd_vma) value, buf);
	  break;
	case 32:
	  if (big_p)
	    bfd_putb32 ((bfd_vma) value, buf);
	  else
	    bfd_putl32 ((bfd_vma) value, buf);
	  break;
	default:
	  abort ();
	}
      hash = (*insn_table->dis_hash) (buf, value);
      insn_lists->next = dis_hash_table[hash];
      insn_lists->insn = new_insns->insn;
      dis_hash_table[hash] = insn_lists;
    }
}

/* Return the first entry in the hash list for INSN.  */

CGEN_INSN_LIST *
cgen_dis_lookup_insn (buf, value)
     const char *buf;
     unsigned long value;
{
  unsigned int hash;

  if (dis_hash_table == NULL)
    build_dis_hash_table ();

  hash = (*cgen_current_opcode_data->insn_table->dis_hash) (buf, value);
  return dis_hash_table[hash];
}
@


1.1.1.1
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d3 1
a3 1
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d5 1
a5 1
   This file is part of the GNU Binutils and GDB, the GNU debugger.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License along
   with this program; if not, write to the Free Software Foundation, Inc.,
   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a25 1
#include "symcat.h"
d28 3
a30 1
/* Subroutine of build_dis_hash_table to add INSNS to the hash table.
d32 17
a48 18
   COUNT is the number of elements in INSNS.
   ENTSIZE is sizeof (CGEN_IBASE) for the target.
   ??? No longer used but leave in for now.
   HTABLE points to the hash table.
   HENTBUF is a pointer to sufficiently large buffer of hash entries.
   The result is a pointer to the next entry to use.

   The table is scanned backwards as additions are made to the front of the
   list and we want earlier ones to be prefered.  */

static CGEN_INSN_LIST *
hash_insn_array (cd, insns, count, entsize, htable, hentbuf)
     CGEN_CPU_DESC cd;
     const CGEN_INSN * insns;
     int count;
     int entsize;
     CGEN_INSN_LIST ** htable;
     CGEN_INSN_LIST * hentbuf;
a49 1
  int big_p = CGEN_CPU_ENDIAN (cd) == CGEN_ENDIAN_BIG;
d51 10
d62 2
a63 6
  for (i = count - 1; i >= 0; --i, ++hentbuf)
    {
      unsigned int hash;
      char buf [4];
      unsigned long value;
      const CGEN_INSN *insn = &insns[i];
d65 7
a71 2
      if (! (* cd->dis_hash_p) (insn))
	continue;
d73 9
d84 2
a85 3

      value = CGEN_INSN_BASE_VALUE (insn);
      switch (CGEN_INSN_MASK_BITSIZE (insn))
d105 4
a108 5

      hash = (* cd->dis_hash) (buf, value);
      hentbuf->next = htable[hash];
      hentbuf->insn = insn;
      htable[hash] = hentbuf;
d111 6
a116 18
  return hentbuf;
}

/* Subroutine of build_dis_hash_table to add INSNS to the hash table.
   This function is identical to hash_insn_array except the insns are
   in a list.  */

static CGEN_INSN_LIST *
hash_insn_list (cd, insns, htable, hentbuf)
     CGEN_CPU_DESC cd;
     const CGEN_INSN_LIST *insns;
     CGEN_INSN_LIST **htable;
     CGEN_INSN_LIST *hentbuf;
{
  int big_p = CGEN_CPU_ENDIAN (cd) == CGEN_ENDIAN_BIG;
  const CGEN_INSN_LIST *ilist;

  for (ilist = insns; ilist != NULL; ilist = ilist->next, ++ hentbuf)
a117 7
      unsigned int hash;
      char buf[4];
      unsigned long value;

      if (! (* cd->dis_hash_p) (ilist->insn))
	continue;

d120 2
a121 3

      value = CGEN_INSN_BASE_VALUE (ilist->insn);
      switch (CGEN_INSN_MASK_BITSIZE (ilist->insn))
d141 4
a144 5

      hash = (* cd->dis_hash) (buf, value);
      hentbuf->next = htable [hash];
      hentbuf->insn = ilist->insn;
      htable [hash] = hentbuf;
a145 58

  return hentbuf;
}

/* Build the disassembler instruction hash table.  */

static void
build_dis_hash_table (cd)
     CGEN_CPU_DESC cd;
{
  int count = cgen_insn_count (cd) + cgen_macro_insn_count (cd);
  CGEN_INSN_TABLE *insn_table = & cd->insn_table;
  CGEN_INSN_TABLE *macro_insn_table = & cd->macro_insn_table;
  unsigned int hash_size = cd->dis_hash_size;
  CGEN_INSN_LIST *hash_entry_buf;
  CGEN_INSN_LIST **dis_hash_table;
  CGEN_INSN_LIST *dis_hash_table_entries;

  /* The space allocated for the hash table consists of two parts:
     the hash table and the hash lists.  */

  dis_hash_table = (CGEN_INSN_LIST **)
    xmalloc (hash_size * sizeof (CGEN_INSN_LIST *));
  memset (dis_hash_table, 0, hash_size * sizeof (CGEN_INSN_LIST *));
  dis_hash_table_entries = hash_entry_buf = (CGEN_INSN_LIST *)
    xmalloc (count * sizeof (CGEN_INSN_LIST));

  /* Add compiled in insns.
     Don't include the first one as it is a reserved entry.  */
  /* ??? It was the end of all hash chains, and also the special
     "invalid insn" marker.  May be able to do it differently now.  */

  hash_entry_buf = hash_insn_array (cd,
				    insn_table->init_entries + 1,
				    insn_table->num_init_entries - 1,
				    insn_table->entry_size,
				    dis_hash_table, hash_entry_buf);

  /* Add compiled in macro-insns.  */

  hash_entry_buf = hash_insn_array (cd, macro_insn_table->init_entries,
				    macro_insn_table->num_init_entries,
				    macro_insn_table->entry_size,
				    dis_hash_table, hash_entry_buf);

  /* Add runtime added insns.
     Later added insns will be prefered over earlier ones.  */

  hash_entry_buf = hash_insn_list (cd, insn_table->new_entries,
				   dis_hash_table, hash_entry_buf);

  /* Add runtime added macro-insns.  */

  hash_insn_list (cd, macro_insn_table->new_entries,
		  dis_hash_table, hash_entry_buf);

  cd->dis_hash_table = dis_hash_table;
  cd->dis_hash_table_entries = dis_hash_table_entries;
d151 3
a153 4
cgen_dis_lookup_insn (cd, buf, value)
     CGEN_CPU_DESC cd;
     const char * buf;
     CGEN_INSN_INT value;
d157 2
a158 4
  if (cd->dis_hash_table == NULL)
    build_dis_hash_table (cd);

  hash = (* cd->dis_hash) (buf, value);
d160 2
a161 1
  return cd->dis_hash_table[hash];
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d3 1
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d46 1
a46 1
     int entsize ATTRIBUTE_UNUSED;
d67 21
a87 4
      bfd_put_bits ((bfd_vma) value,
		    buf,
		    CGEN_INSN_MASK_BITSIZE (insn),
		    big_p);
d124 21
a144 4
      bfd_put_bits((bfd_vma) value,
		   buf,
		   CGEN_INSN_MASK_BITSIZE (ilist->insn),
		   big_p);
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
a29 60
static CGEN_INSN_LIST *  hash_insn_array      PARAMS ((CGEN_CPU_DESC, const CGEN_INSN *, int, int, CGEN_INSN_LIST **, CGEN_INSN_LIST *));
static CGEN_INSN_LIST *  hash_insn_list       PARAMS ((CGEN_CPU_DESC, const CGEN_INSN_LIST *, CGEN_INSN_LIST **, CGEN_INSN_LIST *));
static void              build_dis_hash_table PARAMS ((CGEN_CPU_DESC));
static int		 count_decodable_bits PARAMS ((const CGEN_INSN *));
static void		 add_insn_to_hash_chain PARAMS ((CGEN_INSN_LIST *,
							 const CGEN_INSN *,
							 CGEN_INSN_LIST **,
							 unsigned int));

/* Return the number of decodable bits in this insn.  */
static int
count_decodable_bits (insn)
  const CGEN_INSN *insn;
{
  unsigned mask = CGEN_INSN_BASE_MASK (insn);
  int bits = 0;
  int m;
  for (m = 1; m != 0; m <<= 1)
    {
      if (mask & m)
	++bits;
    }
  return bits;
}

/* Add an instruction to the hash chain.  */     
static void
add_insn_to_hash_chain (hentbuf, insn, htable, hash)
     CGEN_INSN_LIST *hentbuf;
     const CGEN_INSN *insn;
     CGEN_INSN_LIST **htable;
     unsigned int hash;
{
  CGEN_INSN_LIST *current_buf;
  CGEN_INSN_LIST *previous_buf;
  int insn_decodable_bits;

  /* Add insns sorted by the number of decodable bits, in decreasing order.
     This ensures that any insn which is a special case of another will be
     checked first.  */
  insn_decodable_bits = count_decodable_bits (insn);
  previous_buf = NULL;
  for (current_buf = htable[hash]; current_buf != NULL;
       current_buf = current_buf->next)
    {
      int current_decodable_bits = count_decodable_bits (current_buf->insn);
      if (insn_decodable_bits >= current_decodable_bits)
	break;
      previous_buf = current_buf;
    }

  /* Now insert the new insn.  */
  hentbuf->insn = insn;
  hentbuf->next = current_buf;
  if (previous_buf == NULL)
    htable[hash] = hentbuf;
  else
    previous_buf->next = hentbuf;
}

d73 3
a75 1
      add_insn_to_hash_chain (hentbuf, insn, htable, hash);
d113 3
a115 1
      add_insn_to_hash_chain (hentbuf, ilist->insn, htable, hash);
@


1.1.1.5
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d30 8
a37 8
static CGEN_INSN_LIST *  hash_insn_array        (CGEN_CPU_DESC, const CGEN_INSN *, int, int, CGEN_INSN_LIST **, CGEN_INSN_LIST *);
static CGEN_INSN_LIST *  hash_insn_list         (CGEN_CPU_DESC, const CGEN_INSN_LIST *, CGEN_INSN_LIST **, CGEN_INSN_LIST *);
static void              build_dis_hash_table   (CGEN_CPU_DESC);
static int		 count_decodable_bits   (const CGEN_INSN *);
static void		 add_insn_to_hash_chain (CGEN_INSN_LIST *,
						 const CGEN_INSN *,
						 CGEN_INSN_LIST **,
						 unsigned int);
d41 2
a42 1
count_decodable_bits (const CGEN_INSN *insn)
d57 5
a61 4
add_insn_to_hash_chain (CGEN_INSN_LIST *hentbuf,
			const CGEN_INSN *insn,
			CGEN_INSN_LIST **htable,
			unsigned int hash)
d103 7
a109 6
hash_insn_array (CGEN_CPU_DESC cd,
		 const CGEN_INSN * insns,
		 int count,
		 int entsize ATTRIBUTE_UNUSED,
		 CGEN_INSN_LIST ** htable,
		 CGEN_INSN_LIST * hentbuf)
d144 5
a148 4
hash_insn_list (CGEN_CPU_DESC cd,
		const CGEN_INSN_LIST *insns,
		CGEN_INSN_LIST **htable,
		CGEN_INSN_LIST *hentbuf)
d180 2
a181 1
build_dis_hash_table (CGEN_CPU_DESC cd)
d236 4
a239 1
cgen_dis_lookup_insn (CGEN_CPU_DESC cd, const char * buf, CGEN_INSN_INT value)
@


