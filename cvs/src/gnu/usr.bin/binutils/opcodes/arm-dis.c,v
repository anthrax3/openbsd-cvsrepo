head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.48
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.44
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.46
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.38
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.42
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.40
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.11.02.20.45.53;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.17.21.54.54;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.44;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.12.58;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.09.04.19.10.46;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.08.58;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.08.58;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.09.04.17.48.50;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.27.46;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.47.50;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.55.21;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.42;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.23.07;	author miod;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* Instruction printing code for the ARM
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
   Contributed by Richard Earnshaw (rwe@@pegasus.esprit.ec.org)
   Modification by James G. Smith (jsmith@@cygnus.co.uk)

   This file is part of libopcodes.

   This program is free software; you can redistribute it and/or modify it under
   the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "sysdep.h"
#include "dis-asm.h"
#define DEFINE_TABLE
#include "arm-opc.h"
#include "coff/internal.h"
#include "libcoff.h"
#include "opintl.h"
#include "safe-ctype.h"

/* FIXME: This shouldn't be done here.  */
#include "elf-bfd.h"
#include "elf/internal.h"
#include "elf/arm.h"

#ifndef streq
#define streq(a,b)	(strcmp ((a), (b)) == 0)
#endif

#ifndef strneq
#define strneq(a,b,n)	(strncmp ((a), (b), (n)) == 0)
#endif

#ifndef NUM_ELEM
#define NUM_ELEM(a)     (sizeof (a) / sizeof (a)[0])
#endif

static char * arm_conditional[] =
{"eq", "ne", "cs", "cc", "mi", "pl", "vs", "vc",
 "hi", "ls", "ge", "lt", "gt", "le", "", "nv"};

typedef struct
{
  const char * name;
  const char * description;
  const char * reg_names[16];
}
arm_regname;

static arm_regname regnames[] =
{
  { "raw" , "Select raw register names",
    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"}},
  { "gcc",  "Select register names used by GCC",
    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "sl",  "fp",  "ip",  "sp",  "lr",  "pc" }},
  { "std",  "Select register names used in ARM's ISA documentation",
    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11", "r12", "sp",  "lr",  "pc" }},
  { "apcs", "Select register names used in the APCS",
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "v4", "v5", "v6", "sl",  "fp",  "ip",  "sp",  "lr",  "pc" }},
  { "atpcs", "Select register names used in the ATPCS",
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "v4", "v5", "v6", "v7",  "v8",  "IP",  "SP",  "LR",  "PC" }},
  { "special-atpcs", "Select special register names used in the ATPCS",
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "WR", "v5", "SB", "SL",  "FP",  "IP",  "SP",  "LR",  "PC" }},
  { "iwmmxt_regnames", "Select register names used on the Intel Wireless MMX technology coprocessor",
    { "wr0", "wr1", "wr2", "wr3", "wr4", "wr5", "wr6", "wr7", "wr8", "wr9", "wr10", "wr11", "wr12", "wr13", "wr14", "wr15"}},
  { "iwmmxt_Cregnames", "Select control register names used on the Intel Wireless MMX technology coprocessor",
    {"wcid", "wcon", "wcssf", "wcasf", "reserved", "reserved", "reserved", "reserved", "wcgr0", "wcgr1", "wcgr2", "wcgr3", "reserved", "reserved", "reserved", "reserved"}}
};

static char * iwmmxt_wwnames[] =
{"b", "h", "w", "d"};

static char * iwmmxt_wwssnames[] =
{"b", "bus", "b", "bss",
 "h", "hus", "h", "hss",
 "w", "wus", "w", "wss",
 "d", "dus", "d", "dss"
};

/* Default to GCC register name set.  */
static unsigned int regname_selected = 1;

#define NUM_ARM_REGNAMES  NUM_ELEM (regnames)
#define arm_regnames      regnames[regname_selected].reg_names

static bfd_boolean force_thumb = FALSE;

static char * arm_fp_const[] =
{"0.0", "1.0", "2.0", "3.0", "4.0", "5.0", "0.5", "10.0"};

static char * arm_shift[] =
{"lsl", "lsr", "asr", "ror"};

/* Forward declarations.  */
static void arm_decode_shift
  PARAMS ((long, fprintf_ftype, void *));
static int  print_insn_arm
  PARAMS ((bfd_vma, struct disassemble_info *, long));
static int  print_insn_thumb
  PARAMS ((bfd_vma, struct disassemble_info *, long));
static void parse_disassembler_options
  PARAMS ((char *));
static int  print_insn
  PARAMS ((bfd_vma, struct disassemble_info *, bfd_boolean));
static int set_iwmmxt_regnames
  PARAMS ((void));

int get_arm_regname_num_options
  PARAMS ((void));
int set_arm_regname_option
  PARAMS ((int));
int get_arm_regnames
  PARAMS ((int, const char **, const char **, const char ***));

/* Functions.  */
int
get_arm_regname_num_options ()
{
  return NUM_ARM_REGNAMES;
}

int
set_arm_regname_option (option)
     int option;
{
  int old = regname_selected;
  regname_selected = option;
  return old;
}

int
get_arm_regnames (option, setname, setdescription, register_names)
     int option;
     const char **setname;
     const char **setdescription;
     const char ***register_names;
{
  *setname = regnames[option].name;
  *setdescription = regnames[option].description;
  *register_names = regnames[option].reg_names;
  return 16;
}

static void
arm_decode_shift (given, func, stream)
     long given;
     fprintf_ftype func;
     void * stream;
{
  func (stream, "%s", arm_regnames[given & 0xf]);

  if ((given & 0xff0) != 0)
    {
      if ((given & 0x10) == 0)
	{
	  int amount = (given & 0xf80) >> 7;
	  int shift = (given & 0x60) >> 5;

	  if (amount == 0)
	    {
	      if (shift == 3)
		{
		  func (stream, ", rrx");
		  return;
		}

	      amount = 32;
	    }

	  func (stream, ", %s #%d", arm_shift[shift], amount);
	}
      else
	func (stream, ", %s %s", arm_shift[(given & 0x60) >> 5],
	      arm_regnames[(given & 0xf00) >> 8]);
    }
}

static int
set_iwmmxt_regnames ()
{
  const char * setname;
  const char * setdesc;
  const char ** regnames;
  int iwmmxt_regnames = 0;
  int num_regnames = get_arm_regname_num_options ();

  get_arm_regnames (iwmmxt_regnames, &setname,
		    &setdesc, &regnames);
  while ((strcmp ("iwmmxt_regnames", setname))
	 && (iwmmxt_regnames < num_regnames))
    get_arm_regnames (++iwmmxt_regnames, &setname, &setdesc, &regnames);

  return iwmmxt_regnames;
}
			  
/* Print one instruction from PC on INFO->STREAM.
   Return the size of the instruction (always 4 on ARM). */

static int
print_insn_arm (pc, info, given)
     bfd_vma pc;
     struct disassemble_info *info;
     long given;
{
  const struct arm_opcode *insn;
  void *stream = info->stream;
  fprintf_ftype func   = info->fprintf_func;
  static int iwmmxt_regnames = 0;

  for (insn = arm_opcodes; insn->assembler; insn++)
    {
      if (insn->value == FIRST_IWMMXT_INSN
	  && info->mach != bfd_mach_arm_XScale
	  && info->mach != bfd_mach_arm_iWMMXt)
	insn = insn + IWMMXT_INSN_COUNT;

      if ((given & insn->mask) == insn->value)
	{
	  char * c;

	  for (c = insn->assembler; *c; c++)
	    {
	      if (*c == '%')
		{
		  switch (*++c)
		    {
		    case '%':
		      func (stream, "%%");
		      break;

		    case 'a':
		      if (((given & 0x000f0000) == 0x000f0000)
			  && ((given & 0x02000000) == 0))
			{
			  int offset = given & 0xfff;

			  func (stream, "[pc");

			  if (given & 0x01000000)
			    {
			      if ((given & 0x00800000) == 0)
				offset = - offset;

			      /* Pre-indexed.  */
			      func (stream, ", #%d]", offset);

			      offset += pc + 8;

			      /* Cope with the possibility of write-back
				 being used.  Probably a very dangerous thing
				 for the programmer to do, but who are we to
				 argue ?  */
			      if (given & 0x00200000)
				func (stream, "!");
			    }
			  else
			    {
			      /* Post indexed.  */
			      func (stream, "], #%d", offset);

			      /* ie ignore the offset.  */
			      offset = pc + 8;
			    }

			  func (stream, "\t; ");
			  info->print_address_func (offset, info);
			}
		      else
			{
			  func (stream, "[%s",
				arm_regnames[(given >> 16) & 0xf]);
			  if ((given & 0x01000000) != 0)
			    {
			      if ((given & 0x02000000) == 0)
				{
				  int offset = given & 0xfff;
				  if (offset)
				    func (stream, ", #%s%d",
					  (((given & 0x00800000) == 0)
					   ? "-" : ""), offset);
				}
			      else
				{
				  func (stream, ", %s",
					(((given & 0x00800000) == 0)
					 ? "-" : ""));
				  arm_decode_shift (given, func, stream);
				}

			      func (stream, "]%s",
				    ((given & 0x00200000) != 0) ? "!" : "");
			    }
			  else
			    {
			      if ((given & 0x02000000) == 0)
				{
				  int offset = given & 0xfff;
				  if (offset)
				    func (stream, "], #%s%d",
					  (((given & 0x00800000) == 0)
					   ? "-" : ""), offset);
				  else
				    func (stream, "]");
				}
			      else
				{
				  func (stream, "], %s",
					(((given & 0x00800000) == 0)
					 ? "-" : ""));
				  arm_decode_shift (given, func, stream);
				}
			    }
			}
		      break;

		    case 's':
                      if ((given & 0x004f0000) == 0x004f0000)
			{
                          /* PC relative with immediate offset.  */
			  int offset = ((given & 0xf00) >> 4) | (given & 0xf);

			  if ((given & 0x00800000) == 0)
			    offset = -offset;

			  func (stream, "[pc, #%d]\t; ", offset);

			  (*info->print_address_func)
			    (offset + pc + 8, info);
			}
		      else
			{
			  func (stream, "[%s",
				arm_regnames[(given >> 16) & 0xf]);
			  if ((given & 0x01000000) != 0)
			    {
                              /* Pre-indexed.  */
			      if ((given & 0x00400000) == 0x00400000)
				{
                                  /* Immediate.  */
                                  int offset = ((given & 0xf00) >> 4) | (given & 0xf);
				  if (offset)
				    func (stream, ", #%s%d",
					  (((given & 0x00800000) == 0)
					   ? "-" : ""), offset);
				}
			      else
				{
                                  /* Register.  */
				  func (stream, ", %s%s",
					(((given & 0x00800000) == 0)
					 ? "-" : ""),
                                        arm_regnames[given & 0xf]);
				}

			      func (stream, "]%s",
				    ((given & 0x00200000) != 0) ? "!" : "");
			    }
			  else
			    {
                              /* Post-indexed.  */
			      if ((given & 0x00400000) == 0x00400000)
				{
                                  /* Immediate.  */
                                  int offset = ((given & 0xf00) >> 4) | (given & 0xf);
				  if (offset)
				    func (stream, "], #%s%d",
					  (((given & 0x00800000) == 0)
					   ? "-" : ""), offset);
				  else
				    func (stream, "]");
				}
			      else
				{
                                  /* Register.  */
				  func (stream, "], %s%s",
					(((given & 0x00800000) == 0)
					 ? "-" : ""),
                                        arm_regnames[given & 0xf]);
				}
			    }
			}
		      break;

		    case 'b':
		      (*info->print_address_func)
			(BDISP (given) * 4 + pc + 8, info);
		      break;

		    case 'c':
		      func (stream, "%s",
			    arm_conditional [(given >> 28) & 0xf]);
		      break;

		    case 'm':
		      {
			int started = 0;
			int reg;

			func (stream, "{");
			for (reg = 0; reg < 16; reg++)
			  if ((given & (1 << reg)) != 0)
			    {
			      if (started)
				func (stream, ", ");
			      started = 1;
			      func (stream, "%s", arm_regnames[reg]);
			    }
			func (stream, "}");
		      }
		      break;

		    case 'o':
		      if ((given & 0x02000000) != 0)
			{
			  int rotate = (given & 0xf00) >> 7;
			  int immed = (given & 0xff);
			  immed = (((immed << (32 - rotate))
				    | (immed >> rotate)) & 0xffffffff);
			  func (stream, "#%d\t; 0x%x", immed, immed);
			}
		      else
			arm_decode_shift (given, func, stream);
		      break;

		    case 'p':
		      if ((given & 0x0000f000) == 0x0000f000)
			func (stream, "p");
		      break;

		    case 't':
		      if ((given & 0x01200000) == 0x00200000)
			func (stream, "t");
		      break;

		    case 'A':
		      func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);

		      if ((given & (1 << 24)) != 0)
			{
			  int offset = given & 0xff;

			  if (offset)
			    func (stream, ", #%s%d]%s",
				  ((given & 0x00800000) == 0 ? "-" : ""),
				  offset * 4,
				  ((given & 0x00200000) != 0 ? "!" : ""));
			  else
			    func (stream, "]");
			}
		      else
			{
			  int offset = given & 0xff;

			  func (stream, "]");

			  if (given & (1 << 21))
			    {
			      if (offset)
				func (stream, ", #%s%d",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * 4);
			    }
			  else
			    func (stream, ", {%d}", offset);
			}
		      break;

		    case 'B':
		      /* Print ARM V5 BLX(1) address: pc+25 bits.  */
		      {
			bfd_vma address;
			bfd_vma offset = 0;

			if (given & 0x00800000)
			  /* Is signed, hi bits should be ones.  */
			  offset = (-1) ^ 0x00ffffff;

			/* Offset is (SignExtend(offset field)<<2).  */
			offset += given & 0x00ffffff;
			offset <<= 2;
			address = offset + pc + 8;

			if (given & 0x01000000)
			  /* H bit allows addressing to 2-byte boundaries.  */
			  address += 2;

		        info->print_address_func (address, info);
		      }
		      break;

		    case 'I':
		      /* Print a Cirrus/DSP shift immediate.  */
		      /* Immediates are 7bit signed ints with bits 0..3 in
			 bits 0..3 of opcode and bits 4..6 in bits 5..7
			 of opcode.  */
		      {
			int imm;

			imm = (given & 0xf) | ((given & 0xe0) >> 1);

			/* Is ``imm'' a negative number?  */
			if (imm & 0x40)
			  imm |= (-1 << 7);

			func (stream, "%d", imm);
		      }

		      break;

		    case 'C':
		      func (stream, "_");
		      if (given & 0x80000)
			func (stream, "f");
		      if (given & 0x40000)
			func (stream, "s");
		      if (given & 0x20000)
			func (stream, "x");
		      if (given & 0x10000)
			func (stream, "c");
		      break;

		    case 'F':
		      switch (given & 0x00408000)
			{
			case 0:
			  func (stream, "4");
			  break;
			case 0x8000:
			  func (stream, "1");
			  break;
			case 0x00400000:
			  func (stream, "2");
			  break;
			default:
			  func (stream, "3");
			}
		      break;

		    case 'P':
		      switch (given & 0x00080080)
			{
			case 0:
			  func (stream, "s");
			  break;
			case 0x80:
			  func (stream, "d");
			  break;
			case 0x00080000:
			  func (stream, "e");
			  break;
			default:
			  func (stream, _("<illegal precision>"));
			  break;
			}
		      break;
		    case 'Q':
		      switch (given & 0x00408000)
			{
			case 0:
			  func (stream, "s");
			  break;
			case 0x8000:
			  func (stream, "d");
			  break;
			case 0x00400000:
			  func (stream, "e");
			  break;
			default:
			  func (stream, "p");
			  break;
			}
		      break;
		    case 'R':
		      switch (given & 0x60)
			{
			case 0:
			  break;
			case 0x20:
			  func (stream, "p");
			  break;
			case 0x40:
			  func (stream, "m");
			  break;
			default:
			  func (stream, "z");
			  break;
			}
		      break;

		    case '0': case '1': case '2': case '3': case '4':
		    case '5': case '6': case '7': case '8': case '9':
		      {
			int bitstart = *c++ - '0';
			int bitend = 0;
			while (*c >= '0' && *c <= '9')
			  bitstart = (bitstart * 10) + *c++ - '0';

			switch (*c)
			  {
			  case '-':
			    c++;

			    while (*c >= '0' && *c <= '9')
			      bitend = (bitend * 10) + *c++ - '0';

			    if (!bitend)
			      abort ();

			    switch (*c)
			      {
			      case 'r':
				{
				  long reg;

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;

				  func (stream, "%s", arm_regnames[reg]);
				}
				break;
			      case 'd':
				{
				  long reg;

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;

				  func (stream, "%d", reg);
				}
				break;
			      case 'W':
				{
				  long reg;
				  
				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  
				  func (stream, "%d", reg + 1);
				}
				break;
			      case 'x':
				{
				  long reg;

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;

				  func (stream, "0x%08x", reg);

				  /* Some SWI instructions have special
				     meanings.  */
				  if ((given & 0x0fffffff) == 0x0FF00000)
				    func (stream, "\t; IMB");
				  else if ((given & 0x0fffffff) == 0x0FF00001)
				    func (stream, "\t; IMBRange");
				}
				break;
			      case 'X':
				{
				  long reg;

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;

				  func (stream, "%01x", reg & 0xf);
				}
				break;
			      case 'f':
				{
				  long reg;

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;

				  if (reg > 7)
				    func (stream, "#%s",
					  arm_fp_const[reg & 7]);
				  else
				    func (stream, "f%d", reg);
				}
				break;

			      case 'w':
				{
				  long reg;

				  if (bitstart != bitend)
				    {
				      reg = given >> bitstart;
				      reg &= (2 << (bitend - bitstart)) - 1;
				      if (bitend - bitstart == 1)
					func (stream, "%s", iwmmxt_wwnames[reg]);
				      else
					func (stream, "%s", iwmmxt_wwssnames[reg]);
				    }
				  else
				    {
				      reg = (((given >> 8)  & 0x1) |
					     ((given >> 22) & 0x1));
				      func (stream, "%s", iwmmxt_wwnames[reg]);
				    }
				}
				break;

			      case 'g':
				{
				  long reg;
				  int current_regnames;

				  if (! iwmmxt_regnames)
				    iwmmxt_regnames = set_iwmmxt_regnames ();
				  current_regnames = set_arm_regname_option
				    (iwmmxt_regnames);

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  func (stream, "%s", arm_regnames[reg]);
				  set_arm_regname_option (current_regnames);
				}
				break;

			      case 'G':
				{
				  long reg;
				  int current_regnames;

				  if (! iwmmxt_regnames)
				    iwmmxt_regnames = set_iwmmxt_regnames ();
				  current_regnames = set_arm_regname_option
				    (iwmmxt_regnames + 1);

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  func (stream, "%s", arm_regnames[reg]);
				  set_arm_regname_option (current_regnames);
				}
				break;

			      default:
				abort ();
			      }
			    break;

			  case 'y':
			  case 'z':
			    {
			      int single = *c == 'y';
			      int regno;

			      switch (bitstart)
				{
				case 4: /* Sm pair */
				  func (stream, "{");
				  /* Fall through.  */
				case 0: /* Sm, Dm */
				  regno = given & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 5) & 1;
				    }
				  break;

				case 1: /* Sd, Dd */
				  regno = (given >> 12) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 22) & 1;
				    }
				  break;

				case 2: /* Sn, Dn */
				  regno = (given >> 16) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 7) & 1;
				    }
				  break;

				case 3: /* List */
				  func (stream, "{");
				  regno = (given >> 12) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 22) & 1;
				    }
				  break;


				default:
				  abort ();
				}

			      func (stream, "%c%d", single ? 's' : 'd', regno);

			      if (bitstart == 3)
				{
				  int count = given & 0xff;

				  if (single == 0)
				    count >>= 1;

				  if (--count)
				    {
				      func (stream, "-%c%d",
					    single ? 's' : 'd',
					    regno + count);
				    }

				  func (stream, "}");
				}
			      else if (bitstart == 4)
				func (stream, ", %c%d}", single ? 's' : 'd',
				      regno + 1);

			      break;
			    }

			  case '`':
			    c++;
			    if ((given & (1 << bitstart)) == 0)
			      func (stream, "%c", *c);
			    break;
			  case '\'':
			    c++;
			    if ((given & (1 << bitstart)) != 0)
			      func (stream, "%c", *c);
			    break;
			  case '?':
			    ++c;
			    if ((given & (1 << bitstart)) != 0)
			      func (stream, "%c", *c++);
			    else
			      func (stream, "%c", *++c);
			    break;
			  default:
			    abort ();
			  }
			break;

		      case 'L':
			switch (given & 0x00400100)
			  {
			  case 0x00000000: func (stream, "b"); break;
			  case 0x00400000: func (stream, "h"); break;
			  case 0x00000100: func (stream, "w"); break;
			  case 0x00400100: func (stream, "d"); break;
			  default:
			    break;
			  }
			break;

		      case 'Z':
			{
			  int value;
			  /* given (20, 23) | given (0, 3) */
			  value = ((given >> 16) & 0xf0) | (given & 0xf);
			  func (stream, "%d", value);
			}
			break;

		      case 'l':
			/* This is like the 'A' operator, except that if
			   the width field "M" is zero, then the offset is
			   *not* multiplied by four.  */
			{
			  int offset = given & 0xff;
			  int multiplier = (given & 0x00000100) ? 4 : 1;

			  func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);

			  if (offset)
			    {
			      if ((given & 0x01000000) != 0)
				func (stream, ", #%s%d]%s",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier,
				      ((given & 0x00200000) != 0 ? "!" : ""));
			      else
				func (stream, "], #%s%d",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier);
			    }
			  else
			    func (stream, "]");
			}
			break;

		      default:
			abort ();
		      }
		    }
		}
	      else
		func (stream, "%c", *c);
	    }
	  return 4;
	}
    }
  abort ();
}

/* Print one instruction from PC on INFO->STREAM.
   Return the size of the instruction. */

static int
print_insn_thumb (pc, info, given)
     bfd_vma pc;
     struct disassemble_info *info;
     long given;
{
  const struct thumb_opcode *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;

  for (insn = thumb_opcodes; insn->assembler; insn++)
    {
      if ((given & insn->mask) == insn->value)
        {
          char * c = insn->assembler;

          /* Special processing for Thumb 2 instruction BL sequence:  */
          if (!*c) /* Check for empty (not NULL) assembler string.  */
            {
	      long offset;

	      info->bytes_per_chunk = 4;
	      info->bytes_per_line  = 4;

	      offset = BDISP23 (given);
	      offset = offset * 2 + pc + 4;

	      if ((given & 0x10000000) == 0)
		{
		  func (stream, "blx\t");
		  offset &= 0xfffffffc;
		}
	      else
		func (stream, "bl\t");

	      info->print_address_func (offset, info);
              return 4;
            }
          else
            {
	      info->bytes_per_chunk = 2;
	      info->bytes_per_line  = 4;

              given &= 0xffff;

              for (; *c; c++)
                {
                  if (*c == '%')
                    {
                      int domaskpc = 0;
                      int domasklr = 0;

                      switch (*++c)
                        {
                        case '%':
                          func (stream, "%%");
                          break;

                        case 'S':
                          {
                            long reg;

                            reg = (given >> 3) & 0x7;
                            if (given & (1 << 6))
                              reg += 8;

                            func (stream, "%s", arm_regnames[reg]);
                          }
                          break;

                        case 'D':
                          {
                            long reg;

                            reg = given & 0x7;
                            if (given & (1 << 7))
                             reg += 8;

                            func (stream, "%s", arm_regnames[reg]);
                          }
                          break;

                        case 'T':
                          func (stream, "%s",
                                arm_conditional [(given >> 8) & 0xf]);
                          break;

                        case 'N':
                          if (given & (1 << 8))
                            domasklr = 1;
                          /* Fall through.  */
                        case 'O':
                          if (*c == 'O' && (given & (1 << 8)))
                            domaskpc = 1;
                          /* Fall through.  */
                        case 'M':
                          {
                            int started = 0;
                            int reg;

                            func (stream, "{");

                            /* It would be nice if we could spot
                               ranges, and generate the rS-rE format: */
                            for (reg = 0; (reg < 8); reg++)
                              if ((given & (1 << reg)) != 0)
                                {
                                  if (started)
                                    func (stream, ", ");
                                  started = 1;
                                  func (stream, "%s", arm_regnames[reg]);
                                }

                            if (domasklr)
                              {
                                if (started)
                                  func (stream, ", ");
                                started = 1;
                                func (stream, arm_regnames[14] /* "lr" */);
                              }

                            if (domaskpc)
                              {
                                if (started)
                                  func (stream, ", ");
                                func (stream, arm_regnames[15] /* "pc" */);
                              }

                            func (stream, "}");
                          }
                          break;


                        case '0': case '1': case '2': case '3': case '4':
                        case '5': case '6': case '7': case '8': case '9':
                          {
                            int bitstart = *c++ - '0';
                            int bitend = 0;

                            while (*c >= '0' && *c <= '9')
                              bitstart = (bitstart * 10) + *c++ - '0';

                            switch (*c)
                              {
                              case '-':
                                {
                                  long reg;

                                  c++;
                                  while (*c >= '0' && *c <= '9')
                                    bitend = (bitend * 10) + *c++ - '0';
                                  if (!bitend)
                                    abort ();
                                  reg = given >> bitstart;
                                  reg &= (2 << (bitend - bitstart)) - 1;
                                  switch (*c)
                                    {
                                    case 'r':
                                      func (stream, "%s", arm_regnames[reg]);
                                      break;

                                    case 'd':
                                      func (stream, "%d", reg);
                                      break;

                                    case 'H':
                                      func (stream, "%d", reg << 1);
                                      break;

                                    case 'W':
                                      func (stream, "%d", reg << 2);
                                      break;

                                    case 'a':
				      /* PC-relative address -- the bottom two
					 bits of the address are dropped
					 before the calculation.  */
                                      info->print_address_func
					(((pc + 4) & ~3) + (reg << 2), info);
                                      break;

                                    case 'x':
                                      func (stream, "0x%04x", reg);
                                      break;

                                    case 'I':
                                      reg = ((reg ^ (1 << bitend)) - (1 << bitend));
                                      func (stream, "%d", reg);
                                      break;

                                    case 'B':
                                      reg = ((reg ^ (1 << bitend)) - (1 << bitend));
                                      (*info->print_address_func)
                                        (reg * 2 + pc + 4, info);
                                      break;

                                    default:
                                      abort ();
                                    }
                                }
                                break;

                              case '\'':
                                c++;
                                if ((given & (1 << bitstart)) != 0)
                                  func (stream, "%c", *c);
                                break;

                              case '?':
                                ++c;
                                if ((given & (1 << bitstart)) != 0)
                                  func (stream, "%c", *c++);
                                else
                                  func (stream, "%c", *++c);
                                break;

                              default:
                                 abort ();
                              }
                          }
                          break;

                        default:
                          abort ();
                        }
                    }
                  else
                    func (stream, "%c", *c);
                }
             }
          return 2;
       }
    }

  /* No match.  */
  abort ();
}

/* Disallow mapping symbols ($a, $b, $d, $t etc) from
   being displayed in symbol relative addresses.  */

bfd_boolean
arm_symbol_is_valid (asymbol * sym,
		     struct disassemble_info * info ATTRIBUTE_UNUSED)
{
  const char * name;
  
  if (sym == NULL)
    return FALSE;

  name = bfd_asymbol_name (sym);

  return (name && *name != '$');
}

/* Parse an individual disassembler option.  */

void
parse_arm_disassembler_option (option)
     char * option;
{
  if (option == NULL)
    return;

  if (strneq (option, "reg-names-", 10))
    {
      int i;

      option += 10;

      for (i = NUM_ARM_REGNAMES; i--;)
	if (strneq (option, regnames[i].name, strlen (regnames[i].name)))
	  {
	    regname_selected = i;
	    break;
	  }

      if (i < 0)
	/* XXX - should break 'option' at following delimiter.  */
	fprintf (stderr, _("Unrecognised register name set: %s\n"), option);
    }
  else if (strneq (option, "force-thumb", 11))
    force_thumb = 1;
  else if (strneq (option, "no-force-thumb", 14))
    force_thumb = 0;
  else
    /* XXX - should break 'option' at following delimiter.  */
    fprintf (stderr, _("Unrecognised disassembler option: %s\n"), option);

  return;
}

/* Parse the string of disassembler options, spliting it at whitespaces
   or commas.  (Whitespace separators supported for backwards compatibility).  */

static void
parse_disassembler_options (options)
     char * options;
{
  if (options == NULL)
    return;

  while (*options)
    {
      parse_arm_disassembler_option (options);

      /* Skip forward to next seperator.  */
      while ((*options) && (! ISSPACE (*options)) && (*options != ','))
	++ options;
      /* Skip forward past seperators.  */
      while (ISSPACE (*options) || (*options == ','))
	++ options;      
    }
}

/* NOTE: There are no checks in these routines that
   the relevant number of data bytes exist.  */

static int
print_insn (pc, info, little)
     bfd_vma pc;
     struct disassemble_info * info;
     bfd_boolean little;
{
  unsigned char      b[4];
  long               given;
  int                status;
  int                is_thumb;

  if (info->disassembler_options)
    {
      parse_disassembler_options (info->disassembler_options);

      /* To avoid repeated parsing of these options, we remove them here.  */
      info->disassembler_options = NULL;
    }

  is_thumb = force_thumb;

  if (!is_thumb && info->symbols != NULL)
    {
      if (bfd_asymbol_flavour (*info->symbols) == bfd_target_coff_flavour)
	{
	  coff_symbol_type * cs;

	  cs = coffsymbol (*info->symbols);
	  is_thumb = (   cs->native->u.syment.n_sclass == C_THUMBEXT
		      || cs->native->u.syment.n_sclass == C_THUMBSTAT
		      || cs->native->u.syment.n_sclass == C_THUMBLABEL
		      || cs->native->u.syment.n_sclass == C_THUMBEXTFUNC
		      || cs->native->u.syment.n_sclass == C_THUMBSTATFUNC);
	}
      else if (bfd_asymbol_flavour (*info->symbols) == bfd_target_elf_flavour)
	{
	  elf_symbol_type *  es;
	  unsigned int       type;

	  es = *(elf_symbol_type **)(info->symbols);
	  type = ELF_ST_TYPE (es->internal_elf_sym.st_info);

	  is_thumb = (type == STT_ARM_TFUNC) || (type == STT_ARM_16BIT);
	}
    }

  info->bytes_per_chunk = 4;
  info->display_endian  = little ? BFD_ENDIAN_LITTLE : BFD_ENDIAN_BIG;

  if (little)
    {
      status = info->read_memory_func (pc, (bfd_byte *) &b[0], 4, info);
      if (status != 0 && is_thumb)
	{
	  info->bytes_per_chunk = 2;

	  status = info->read_memory_func (pc, (bfd_byte *) b, 2, info);
	  b[3] = b[2] = 0;
	}

      if (status != 0)
	{
	  info->memory_error_func (status, pc, info);
	  return -1;
	}

      given = (b[0]) | (b[1] << 8) | (b[2] << 16) | (b[3] << 24);
    }
  else
    {
      status = info->read_memory_func
	(pc & ~ 0x3, (bfd_byte *) &b[0], 4, info);
      if (status != 0)
	{
	  info->memory_error_func (status, pc, info);
	  return -1;
	}

      if (is_thumb)
	{
	  if (pc & 0x2)
	    {
	      given = (b[2] << 8) | b[3];

	      status = info->read_memory_func
		((pc + 4) & ~ 0x3, (bfd_byte *) b, 4, info);
	      if (status != 0)
		{
		  info->memory_error_func (status, pc + 4, info);
		  return -1;
		}

	      given |= (b[0] << 24) | (b[1] << 16);
	    }
	  else
	    given = (b[0] << 8) | b[1] | (b[2] << 24) | (b[3] << 16);
	}
      else
	given = (b[0] << 24) | (b[1] << 16) | (b[2] << 8) | (b[3]);
    }

  if (info->flags & INSN_HAS_RELOC)
    /* If the instruction has a reloc associated with it, then
       the offset field in the instruction will actually be the
       addend for the reloc.  (We are using REL type relocs).
       In such cases, we can ignore the pc when computing
       addresses, since the addend is not currently pc-relative.  */
    pc = 0;

  if (is_thumb)
    status = print_insn_thumb (pc, info, given);
  else
    status = print_insn_arm (pc, info, given);

  return status;
}

int
print_insn_big_arm (pc, info)
     bfd_vma pc;
     struct disassemble_info * info;
{
  return print_insn (pc, info, FALSE);
}

int
print_insn_little_arm (pc, info)
     bfd_vma pc;
     struct disassemble_info * info;
{
  return print_insn (pc, info, TRUE);
}

void
print_arm_disassembler_options (FILE * stream)
{
  int i;

  fprintf (stream, _("\n\
The following ARM specific disassembler options are supported for use with\n\
the -M switch:\n"));

  for (i = NUM_ARM_REGNAMES; i--;)
    fprintf (stream, "  reg-names-%s %*c%s\n",
	     regnames[i].name,
	     (int)(14 - strlen (regnames[i].name)), ' ',
	     regnames[i].description);

  fprintf (stream, "  force-thumb              Assume all insns are Thumb insns\n");
  fprintf (stream, "  no-force-thumb           Examine preceeding label to determine an insn's type\n\n");
}
@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d30 1
d289 1
a289 1
				    func (stream, ", %s#%d",
d310 1
a310 1
				    func (stream, "], %s#%d",
d353 1
a353 1
				    func (stream, ", %s#%d",
d377 1
a377 1
				    func (stream, "], %s#%d",
d448 2
a449 1
		      if ((given & 0x01000000) != 0)
d452 1
d454 1
a454 1
			    func (stream, ", %s#%d]%s",
d464 10
a473 4
			  if (offset)
			    func (stream, "], %s#%d",
				  ((given & 0x00800000) == 0 ? "-" : ""),
				  offset * 4);
d475 1
a475 1
			    func (stream, "]");
d642 10
d889 1
a889 1
				func (stream, ", %s#%d]%s",
d894 1
a894 1
				func (stream, "], %s#%d",
d1158 17
d1191 1
a1191 1
	if (streq (option, regnames[i].name))
d1198 1
d1201 1
a1201 1
  else if (streq (option, "force-thumb"))
d1203 1
a1203 1
  else if (streq (option, "no-force-thumb"))
d1206 1
d1212 2
a1213 1
/* Parse the string of disassembler options, spliting it at whitespaces.  */
a1218 2
  char * space;

d1222 1
a1222 1
  do
d1224 1
a1224 1
      space = strchr (options, ' ');
d1226 6
a1231 9
      if (space)
	{
	  * space = '\0';
	  parse_arm_disassembler_option (options);
	  * space = ' ';
	  options = space + 1;
	}
      else
	parse_arm_disassembler_option (options);
a1232 1
  while (space);
@


1.4
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d7 1
a7 1
This file is part of libopcodes. 
d9 13
a21 13
This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version. 

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
more details. 

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 1
a31 1
/* FIXME: This shouldn't be done here */
d73 15
a87 1
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "WR", "v5", "SB", "SL",  "FP",  "IP",  "SP",  "LR",  "PC" }}
d96 1
a96 1
static boolean force_thumb = false;
d101 1
a101 1
static char * arm_shift[] = 
d105 19
a123 10
static void arm_decode_shift PARAMS ((long, fprintf_ftype, void *));
static int  print_insn_arm   PARAMS ((bfd_vma, struct disassemble_info *, long));
static int  print_insn_thumb PARAMS ((bfd_vma, struct disassemble_info *, long));
static void parse_disassembler_options PARAMS ((char *));
static int  print_insn       PARAMS ((bfd_vma, struct disassemble_info *, boolean));
int get_arm_regname_num_options (void);
int set_arm_regname_option (int option);
int get_arm_regnames (int option, const char **setname,
		      const char **setdescription,
		      const char ***register_names);
d125 1
a125 1
/* Functions. */
d127 1
a127 1
get_arm_regname_num_options (void)
d133 2
a134 1
set_arm_regname_option (int option)
d142 5
a146 3
get_arm_regnames (int option, const char **setname,
		  const char **setdescription,
                  const char ***register_names)
d161 1
a161 1
  
d168 1
a168 1
	  
d176 1
a176 1
	      
d179 1
a179 1
	  
d188 18
d208 1
d211 3
a213 3
     bfd_vma                   pc;
     struct disassemble_info * info;
     long                      given;
d215 4
a218 3
  struct arm_opcode *  insn;
  void *               stream = info->stream;
  fprintf_ftype        func   = info->fprintf_func;
d222 5
d230 1
a230 1
	  
d246 1
a246 1
			  
d248 1
a248 1
 
d253 3
a255 3
			  
			      /* pre-indexed */
			      func (stream, ", #%x]", offset);
d269 1
a269 1
			      func (stream, "], #%x", offset);
d271 2
a272 1
			      offset = pc + 8;  /* ie ignore the offset.  */
d274 1
a274 1
			  
d280 1
a280 1
			  func (stream, "[%s", 
d300 1
a300 1
			      func (stream, "]%s", 
d312 1
a312 1
				  else 
d318 1
a318 1
					(((given & 0x00800000) == 0) 
d331 1
a331 1
			  
d334 3
a336 3
			  
			  func (stream, "[pc, #%x]\t; ", offset);
			  
d342 1
a342 1
			  func (stream, "[%s", 
d365 1
a365 1
			      func (stream, "]%s", 
d379 1
a379 1
				  else 
d393 1
a393 1
			  
a444 7
		    case 'h':
		      if ((given & 0x00000020) == 0x00000020)
			func (stream, "h");
                      else
                        func (stream, "b");
		      break;

d475 1
a475 1
			
d484 1
a484 1
			
d493 19
d540 1
a540 1
			
d592 1
a592 1
		    case '0': case '1': case '2': case '3': case '4': 
d604 1
a604 1
			    
d607 1
a607 1
			    
d610 1
a610 1
			    
d616 1
a616 1
				  
d619 1
a619 1
				  
d626 1
a626 1
				  
d629 1
a629 1
				  
d636 1
a636 1
				  
d639 1
a639 1
				  
d641 1
a641 1
				  
d653 1
a653 1
				  
d656 1
a656 1
				  
d663 1
a663 1
				  
d666 1
a666 1
				  
d674 57
d735 79
a813 1
			    
d836 48
d900 1
d903 3
a905 3
     bfd_vma                   pc;
     struct disassemble_info * info;
     long                      given;
d907 3
a909 3
  struct thumb_opcode * insn;
  void *                stream = info->stream;
  fprintf_ftype         func = info->fprintf_func;
d920 2
d924 4
a927 1
	      
d929 4
a932 1
                 func (stream, "blx\t");
d934 3
a936 3
                func (stream, "bl\t");
		
              info->print_address_func (BDISP23 (given) * 2 + pc + 4, info);
d943 1
a943 1
	  	      
d945 1
a945 1
	      
d952 1
a952 1
		      
d962 1
a962 1
			    
d966 1
a966 1
			    
d974 1
a974 1
			    
d978 1
a978 1
			    
d1000 1
a1000 1
			    
d1002 1
a1002 1
			    
d1034 1
a1034 1
                        case '0': case '1': case '2': case '3': case '4': 
d1039 1
a1039 1
			    
d1048 1
a1048 1
				  
d1140 1
d1147 1
a1147 1
      
d1151 1
a1151 1
	
d1160 1
a1160 1
      
d1170 1
a1170 1
  
d1175 1
d1181 1
a1181 1
  
d1204 1
d1209 1
a1209 1
     boolean little;
d1219 1
a1219 1
      
d1223 1
a1223 1
  
d1225 1
a1225 1
  
d1231 1
a1231 1
	  
d1243 1
a1243 1
	  
d1246 1
a1246 1
	  
d1250 1
a1250 1
  
d1260 1
a1260 1
	  
d1264 1
a1264 1
      
d1270 1
a1270 1
      
d1282 1
a1282 1
      
d1288 1
a1288 1
	      
d1296 1
a1296 1
	      
d1305 1
a1305 1
  
d1313 1
a1313 1
  
d1327 1
a1327 1
  return print_insn (pc, info, false);
d1335 1
a1335 1
  return print_insn (pc, info, true);
d1346 1
a1346 1
  
d1350 1
a1350 1
	     14 - strlen (regnames[i].name), ' ',
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1994, 95, 96, 97, 98, 99, 2000 Free Software Foundation, Inc. 
d64 2
d76 1
a76 1
/* Default to standard register name set.  */
d425 23
d449 9
a457 21
		      switch (given & 0x000f0000)
			{
			default:
			  func (stream, "_???");
			  break;
			case 0x90000:
			  func (stream, "_all");
			  break;
			case 0x10000:
			  func (stream, "_c");
			  break;
			case 0x20000:
			  func (stream, "_x");
			  break;
			case 0x40000:
			  func (stream, "_s");
			  break;
			case 0x80000:
			  func (stream, "_f");
			  break;
			}
d675 3
d1046 8
@


1.2
log
@Merge the Cygnus 960904 sources
@
text
@d2 1
a2 1
   Copyright (C) 1994 Free Software Foundation, Inc. 
d4 1
d18 3
a20 4
You should have received a copy of the GNU General Public License along with
This program; if not, write to the Free Software Foundation, Inc., 675
 Mass Ave, Boston, MA 02111-1307, USA.  
*/
d22 1
d26 20
d47 1
a47 2

static char *arm_conditional[] =
d51 27
a77 3
static char *arm_regnames[] =
{"r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
 "r8", "r9", "sl", "fp", "ip", "sp", "lr", "pc"};
d79 3
a81 1
static char *arm_fp_const[] =
d84 1
a84 1
static char *arm_shift[] = 
d86 38
d129 1
a129 1
     void *stream;
d132 1
d139 1
d147 1
d150 2
a151 1
	  func (stream, ", %s #%x", arm_shift[shift], amount);
a160 1

d163 3
a165 3
     bfd_vma         pc;
     struct disassemble_info *info;
     long given;
d167 3
a169 5
  struct arm_opcode *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;

  func (stream, "%08x\t", given);
d175 2
a176 1
	  char *c;
d192 30
a221 4
			  if ((given & 0x00800000) == 0)
			    offset = -offset;
			  (*info->print_address_func)
			    (offset + pc + 8, info);
d233 1
a233 1
				    func (stream, ", %s#%x",
d254 1
a254 1
				    func (stream, "], %s#%x",
d274 1
a274 1
                          /* PC relative with immediate offset */
d276 1
d279 3
d291 1
a291 1
                              /* pre-indexed */
d294 1
a294 1
                                  /* immediate */
d297 1
a297 1
				    func (stream, ", %s#%x",
d303 1
a303 1
                                  /* register */
d315 1
a315 1
                              /* post-indexed */
d318 1
a318 1
                                  /* immediate */
d321 1
a321 1
				    func (stream, "], %s#%x",
d329 1
a329 1
                                  /* register */
d372 3
a374 3
			  func (stream, "#%x",
				((immed << (32 - rotate))
				 | (immed >> rotate)) & 0xffffffff);
d403 1
a403 1
			    func (stream, ", %s#%x]%s",
d414 1
a414 1
			    func (stream, "], %s#%x",
d423 1
a423 1
		      switch (given & 0x00090000)
d425 1
a425 1
			case 0:
d428 3
d432 7
a438 1
			  func (stream, "_ctl");
d441 1
a441 1
			  func (stream, "_flg");
d476 1
a476 1
			  func (stream, "<illegal precision>");
d526 1
d529 1
d532 1
d538 1
d541 1
d548 1
d551 1
d558 1
d561 1
d563 17
d585 1
d588 1
d600 1
d637 294
a930 2
int
print_insn_big_arm (pc, info)
d932 2
a933 1
     struct disassemble_info *info;
d935 4
a938 3
  unsigned char b[4];
  long given;
  int status;
d940 1
a940 2
  status = (*info->read_memory_func) (pc, (bfd_byte *) &b[0], 4, info);
  if (status != 0)
d942 4
a945 2
      (*info->memory_error_func) (status, pc, info);
      return -1;
d947 87
d1035 2
a1036 1
  given = (b[0] << 24) | (b[1] << 16) | (b[2] << 8) | (b[3]);
d1038 6
a1043 1
  return print_insn_arm (pc, info, given);
d1049 1
a1049 1
     struct disassemble_info *info;
d1051 2
a1052 3
  unsigned char b[4];
  long given;
  int status;
d1054 4
a1057 6
  status = (*info->read_memory_func) (pc, (bfd_byte *) &b[0], 4, info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, pc, info);
      return -1;
    }
d1059 9
a1067 1
  given = (b[0]) | (b[1] << 8) | (b[2] << 16) | (b[3] << 24);
d1069 2
a1070 1
  return print_insn_arm (pc, info, given);
@


1.1
log
@Initial revision
@
text
@d158 64
d272 7
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a157 64

		    case 's':
                      if ((given & 0x004f0000) == 0x004f0000)
			{
                          /* PC relative with immediate offset */
			  int offset = ((given & 0xf00) >> 4) | (given & 0xf);
			  if ((given & 0x00800000) == 0)
			    offset = -offset;
			  (*info->print_address_func)
			    (offset + pc + 8, info);
			}
		      else
			{
			  func (stream, "[%s", 
				arm_regnames[(given >> 16) & 0xf]);
			  if ((given & 0x01000000) != 0)
			    {
                              /* pre-indexed */
			      if ((given & 0x00400000) == 0x00400000)
				{
                                  /* immediate */
                                  int offset = ((given & 0xf00) >> 4) | (given & 0xf);
				  if (offset)
				    func (stream, ", %s#%x",
					  (((given & 0x00800000) == 0)
					   ? "-" : ""), offset);
				}
			      else
				{
                                  /* register */
				  func (stream, ", %s%s",
					(((given & 0x00800000) == 0)
					 ? "-" : ""),
                                        arm_regnames[given & 0xf]);
				}

			      func (stream, "]%s", 
				    ((given & 0x00200000) != 0) ? "!" : "");
			    }
			  else
			    {
                              /* post-indexed */
			      if ((given & 0x00400000) == 0x00400000)
				{
                                  /* immediate */
                                  int offset = ((given & 0xf00) >> 4) | (given & 0xf);
				  if (offset)
				    func (stream, "], %s#%x",
					  (((given & 0x00800000) == 0)
					   ? "-" : ""), offset);
				  else 
				    func (stream, "]");
				}
			      else
				{
                                  /* register */
				  func (stream, "], %s%s",
					(((given & 0x00800000) == 0)
					 ? "-" : ""),
                                        arm_regnames[given & 0xf]);
				}
			    }
			}
		      break;
a207 7
		      break;

		    case 'h':
		      if ((given & 0x00000020) == 0x00000020)
			func (stream, "h");
                      else
                        func (stream, "b");
@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 96, 1997 Free Software Foundation, Inc. 
d17 4
a20 3
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d84 2
a491 3
  info->bytes_per_chunk = 4;
  info->display_endian = BFD_ENDIAN_BIG;

a511 3

  info->bytes_per_chunk = 4;
  info->display_endian = BFD_ENDIAN_LITTLE;
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 96, 97, 98, 99, 2000 Free Software Foundation, Inc. 
a3 1
   Modification by James G. Smith (jsmith@@cygnus.co.uk)
a20 1
#include "sysdep.h"
a23 20
#include "coff/internal.h"
#include "libcoff.h"
#include "opintl.h"

/* FIXME: This shouldn't be done here */
#include "elf-bfd.h"
#include "elf/internal.h"
#include "elf/arm.h"

#ifndef streq
#define streq(a,b)	(strcmp ((a), (b)) == 0)
#endif

#ifndef strneq
#define strneq(a,b,n)	(strncmp ((a), (b), (n)) == 0)
#endif

#ifndef NUM_ELEM
#define NUM_ELEM(a)     (sizeof (a) / sizeof (a)[0])
#endif
d25 2
a26 1
static char * arm_conditional[] =
d30 3
a32 27
typedef struct
{
  const char * name;
  const char * description;
  const char * reg_names[16];
}
arm_regname;

static arm_regname regnames[] =
{
  { "raw" , "Select raw register names",
    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"}},
  { "std",  "Select register names used in ARM's ISA documentation",
    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11", "r12", "sp",  "lr",  "pc" }},
  { "apcs", "Select register names used in the APCS",
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "v4", "v5", "v6", "sl",  "fp",  "ip",  "sp",  "lr",  "pc" }},
  { "atpcs", "Select register names used in the ATPCS",
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "v4", "v5", "v6", "v7",  "v8",  "IP",  "SP",  "LR",  "PC" }},
  { "special-atpcs", "Select special register names used in the ATPCS",
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "WR", "v5", "SB", "SL",  "FP",  "IP",  "SP",  "LR",  "PC" }}
};

/* Default to standard register name set.  */
static unsigned int regname_selected = 1;

#define NUM_ARM_REGNAMES  NUM_ELEM (regnames)
#define arm_regnames      regnames[regname_selected].reg_names
d34 1
a34 3
static boolean force_thumb = false;

static char * arm_fp_const[] =
d37 1
a37 1
static char * arm_shift[] = 
a38 38

/* Forward declarations.  */
static void arm_decode_shift PARAMS ((long, fprintf_ftype, void *));
static int  print_insn_arm   PARAMS ((bfd_vma, struct disassemble_info *, long));
static int  print_insn_thumb PARAMS ((bfd_vma, struct disassemble_info *, long));
static void parse_disassembler_options PARAMS ((char *));
static int  print_insn       PARAMS ((bfd_vma, struct disassemble_info *, boolean));
int get_arm_regname_num_options (void);
int set_arm_regname_option (int option);
int get_arm_regnames (int option, const char **setname,
		      const char **setdescription,
		      const char ***register_names);

/* Functions. */
int
get_arm_regname_num_options (void)
{
  return NUM_ARM_REGNAMES;
}

int
set_arm_regname_option (int option)
{
  int old = regname_selected;
  regname_selected = option;
  return old;
}

int
get_arm_regnames (int option, const char **setname,
		  const char **setdescription,
                  const char ***register_names)
{
  *setname = regnames[option].name;
  *setdescription = regnames[option].description;
  *register_names = regnames[option].reg_names;
  return 16;
}
d44 1
a44 1
     void * stream;
a46 1
  
a52 1
	  
a59 1
	      
d62 1
a62 2
	  
	  func (stream, ", %s #%d", arm_shift[shift], amount);
d72 1
d75 3
a77 3
     bfd_vma                   pc;
     struct disassemble_info * info;
     long                      given;
d79 3
a81 3
  struct arm_opcode *  insn;
  void *               stream = info->stream;
  fprintf_ftype        func   = info->fprintf_func;
d87 1
a87 2
	  char * c;
	  
d103 4
a106 30
			  
			  func (stream, "[pc");
 
			  if (given & 0x01000000)
			    {
			      if ((given & 0x00800000) == 0)
				offset = - offset;
			  
			      /* pre-indexed */
			      func (stream, ", #%x]", offset);

			      offset += pc + 8;

			      /* Cope with the possibility of write-back
				 being used.  Probably a very dangerous thing
				 for the programmer to do, but who are we to
				 argue ?  */
			      if (given & 0x00200000)
				func (stream, "!");
			    }
			  else
			    {
			      /* Post indexed.  */
			      func (stream, "], #%x", offset);

			      offset = pc + 8;  /* ie ignore the offset.  */
			    }
			  
			  func (stream, "\t; ");
			  info->print_address_func (offset, info);
d118 1
a118 1
				    func (stream, ", %s#%d",
d139 1
a139 1
				    func (stream, "], %s#%d",
d159 1
a159 1
                          /* PC relative with immediate offset.  */
a160 1
			  
a162 3
			  
			  func (stream, "[pc, #%x]\t; ", offset);
			  
d172 1
a172 1
                              /* Pre-indexed.  */
d175 1
a175 1
                                  /* Immediate.  */
d178 1
a178 1
				    func (stream, ", %s#%d",
d184 1
a184 1
                                  /* Register.  */
d196 1
a196 1
                              /* Post-indexed.  */
d199 1
a199 1
                                  /* Immediate.  */
d202 1
a202 1
				    func (stream, "], %s#%d",
d210 1
a210 1
                                  /* Register.  */
d253 3
a255 3
			  immed = (((immed << (32 - rotate))
				    | (immed >> rotate)) & 0xffffffff);
			  func (stream, "#%d\t; 0x%x", immed, immed);
d284 1
a284 1
			    func (stream, ", %s#%d]%s",
d295 1
a295 1
			    func (stream, "], %s#%d",
d304 1
a304 1
		      switch (given & 0x000f0000)
d306 1
a306 1
			default:
a308 3
			case 0x90000:
			  func (stream, "_all");
			  break;
d310 1
a310 7
			  func (stream, "_c");
			  break;
			case 0x20000:
			  func (stream, "_x");
			  break;
			case 0x40000:
			  func (stream, "_s");
d313 1
a313 1
			  func (stream, "_f");
d348 1
a348 1
			  func (stream, _("<illegal precision>"));
a397 1
			    
a399 1
			    
a401 1
			    
a406 1
				  
a408 1
				  
a414 1
				  
a416 1
				  
a422 1
				  
a424 1
				  
a425 17
				  
				  /* Some SWI instructions have special
				     meanings.  */
				  if ((given & 0x0fffffff) == 0x0FF00000)
				    func (stream, "\t; IMB");
				  else if ((given & 0x0fffffff) == 0x0FF00001)
				    func (stream, "\t; IMBRange");
				}
				break;
			      case 'X':
				{
				  long reg;
				  
				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  
				  func (stream, "%01x", reg & 0xf);
a430 1
				  
a432 1
				  
a443 1
			    
d480 4
a483 7
/* Print one instruction from PC on INFO->STREAM.
   Return the size of the instruction. */
static int
print_insn_thumb (pc, info, given)
     bfd_vma                   pc;
     struct disassemble_info * info;
     long                      given;
d485 3
a487 3
  struct thumb_opcode * insn;
  void *                stream = info->stream;
  fprintf_ftype         func = info->fprintf_func;
d489 2
a490 5
  for (insn = thumb_opcodes; insn->assembler; insn++)
    {
      if ((given & insn->mask) == insn->value)
        {
          char * c = insn->assembler;
d492 2
a493 220
          /* Special processing for Thumb 2 instruction BL sequence:  */
          if (!*c) /* Check for empty (not NULL) assembler string.  */
            {
	      info->bytes_per_chunk = 4;
	      info->bytes_per_line  = 4;
	      
                func (stream, "bl\t");
		
              info->print_address_func (BDISP23 (given) * 2 + pc + 4, info);
              return 4;
            }
          else
            {
	      info->bytes_per_chunk = 2;
	      info->bytes_per_line  = 4;
	  	      
              given &= 0xffff;
	      
              for (; *c; c++)
                {
                  if (*c == '%')
                    {
                      int domaskpc = 0;
                      int domasklr = 0;
		      
                      switch (*++c)
                        {
                        case '%':
                          func (stream, "%%");
                          break;

                        case 'S':
                          {
                            long reg;
			    
                            reg = (given >> 3) & 0x7;
                            if (given & (1 << 6))
                              reg += 8;
			    
                            func (stream, "%s", arm_regnames[reg]);
                          }
                          break;

                        case 'D':
                          {
                            long reg;
			    
                            reg = given & 0x7;
                            if (given & (1 << 7))
                             reg += 8;
			    
                            func (stream, "%s", arm_regnames[reg]);
                          }
                          break;

                        case 'T':
                          func (stream, "%s",
                                arm_conditional [(given >> 8) & 0xf]);
                          break;

                        case 'N':
                          if (given & (1 << 8))
                            domasklr = 1;
                          /* Fall through.  */
                        case 'O':
                          if (*c == 'O' && (given & (1 << 8)))
                            domaskpc = 1;
                          /* Fall through.  */
                        case 'M':
                          {
                            int started = 0;
                            int reg;
			    
                            func (stream, "{");
			    
                            /* It would be nice if we could spot
                               ranges, and generate the rS-rE format: */
                            for (reg = 0; (reg < 8); reg++)
                              if ((given & (1 << reg)) != 0)
                                {
                                  if (started)
                                    func (stream, ", ");
                                  started = 1;
                                  func (stream, "%s", arm_regnames[reg]);
                                }

                            if (domasklr)
                              {
                                if (started)
                                  func (stream, ", ");
                                started = 1;
                                func (stream, arm_regnames[14] /* "lr" */);
                              }

                            if (domaskpc)
                              {
                                if (started)
                                  func (stream, ", ");
                                func (stream, arm_regnames[15] /* "pc" */);
                              }

                            func (stream, "}");
                          }
                          break;


                        case '0': case '1': case '2': case '3': case '4': 
                        case '5': case '6': case '7': case '8': case '9':
                          {
                            int bitstart = *c++ - '0';
                            int bitend = 0;
			    
                            while (*c >= '0' && *c <= '9')
                              bitstart = (bitstart * 10) + *c++ - '0';

                            switch (*c)
                              {
                              case '-':
                                {
                                  long reg;
				  
                                  c++;
                                  while (*c >= '0' && *c <= '9')
                                    bitend = (bitend * 10) + *c++ - '0';
                                  if (!bitend)
                                    abort ();
                                  reg = given >> bitstart;
                                  reg &= (2 << (bitend - bitstart)) - 1;
                                  switch (*c)
                                    {
                                    case 'r':
                                      func (stream, "%s", arm_regnames[reg]);
                                      break;

                                    case 'd':
                                      func (stream, "%d", reg);
                                      break;

                                    case 'H':
                                      func (stream, "%d", reg << 1);
                                      break;

                                    case 'W':
                                      func (stream, "%d", reg << 2);
                                      break;

                                    case 'a':
				      /* PC-relative address -- the bottom two
					 bits of the address are dropped
					 before the calculation.  */
                                      info->print_address_func
					(((pc + 4) & ~3) + (reg << 2), info);
                                      break;

                                    case 'x':
                                      func (stream, "0x%04x", reg);
                                      break;

                                    case 'I':
                                      reg = ((reg ^ (1 << bitend)) - (1 << bitend));
                                      func (stream, "%d", reg);
                                      break;

                                    case 'B':
                                      reg = ((reg ^ (1 << bitend)) - (1 << bitend));
                                      (*info->print_address_func)
                                        (reg * 2 + pc + 4, info);
                                      break;

                                    default:
                                      abort ();
                                    }
                                }
                                break;

                              case '\'':
                                c++;
                                if ((given & (1 << bitstart)) != 0)
                                  func (stream, "%c", *c);
                                break;

                              case '?':
                                ++c;
                                if ((given & (1 << bitstart)) != 0)
                                  func (stream, "%c", *c++);
                                else
                                  func (stream, "%c", *++c);
                                break;

                              default:
                                 abort ();
                              }
                          }
                          break;

                        default:
                          abort ();
                        }
                    }
                  else
                    func (stream, "%c", *c);
                }
             }
          return 2;
       }
    }

  /* No match.  */
  abort ();
}

/* Parse an individual disassembler option.  */
void
parse_arm_disassembler_option (option)
     char * option;
{
  if (option == NULL)
    return;
      
  if (strneq (option, "reg-names-", 10))
d495 2
a496 13
      int i;
	
      option += 10;

      for (i = NUM_ARM_REGNAMES; i--;)
	if (streq (option, regnames[i].name))
	  {
	    regname_selected = i;
	    break;
	  }
      
      if (i < 0)
	fprintf (stderr, _("Unrecognised register name set: %s\n"), option);
a497 9
  else if (streq (option, "force-thumb"))
    force_thumb = 1;
  else if (streq (option, "no-force-thumb"))
    force_thumb = 0;
  else
    fprintf (stderr, _("Unrecognised disassembler option: %s\n"), option);
  
  return;
}
d499 1
a499 13
/* Parse the string of disassembler options, spliting it at whitespaces.  */
static void
parse_disassembler_options (options)
     char * options;
{
  char * space;
  
  if (options == NULL)
    return;

  do
    {
      space = strchr (options, ' ');
d501 1
a501 11
      if (space)
	{
	  * space = '\0';
	  parse_arm_disassembler_option (options);
	  * space = ' ';
	  options = space + 1;
	}
      else
	parse_arm_disassembler_option (options);
    }
  while (space);
d504 2
a505 4
/* NOTE: There are no checks in these routines that
   the relevant number of data bytes exist.  */
static int
print_insn (pc, info, little)
d507 1
a507 2
     struct disassemble_info * info;
     boolean little;
d509 3
a511 4
  unsigned char      b[4];
  long               given;
  int                status;
  int                is_thumb;
a512 35
  if (info->disassembler_options)
    {
      parse_disassembler_options (info->disassembler_options);
      
      /* To avoid repeated parsing of these options, we remove them here.  */
      info->disassembler_options = NULL;
    }
  
  is_thumb = force_thumb;
  
  if (!is_thumb && info->symbols != NULL)
    {
      if (bfd_asymbol_flavour (*info->symbols) == bfd_target_coff_flavour)
	{
	  coff_symbol_type * cs;
	  
	  cs = coffsymbol (*info->symbols);
	  is_thumb = (   cs->native->u.syment.n_sclass == C_THUMBEXT
		      || cs->native->u.syment.n_sclass == C_THUMBSTAT
		      || cs->native->u.syment.n_sclass == C_THUMBLABEL
		      || cs->native->u.syment.n_sclass == C_THUMBEXTFUNC
		      || cs->native->u.syment.n_sclass == C_THUMBSTATFUNC);
	}
      else if (bfd_asymbol_flavour (*info->symbols) == bfd_target_elf_flavour)
	{
	  elf_symbol_type *  es;
	  unsigned int       type;
	  
	  es = *(elf_symbol_type **)(info->symbols);
	  type = ELF_ST_TYPE (es->internal_elf_sym.st_info);
	  
	  is_thumb = (type == STT_ARM_TFUNC) || (type == STT_ARM_16BIT);
	}
    }
  
d514 1
a514 1
  info->display_endian  = little ? BFD_ENDIAN_LITTLE : BFD_ENDIAN_BIG;
d516 2
a517 1
  if (little)
d519 2
a520 48
      status = info->read_memory_func (pc, (bfd_byte *) &b[0], 4, info);
      if (status != 0 && is_thumb)
	{
	  info->bytes_per_chunk = 2;
	  
	  status = info->read_memory_func (pc, (bfd_byte *) b, 2, info);
	  b[3] = b[2] = 0;
	}
      
      if (status != 0)
	{
	  info->memory_error_func (status, pc, info);
	  return -1;
	}
      
      given = (b[0]) | (b[1] << 8) | (b[2] << 16) | (b[3] << 24);
    }
  else
    {
      status = info->read_memory_func
	(pc & ~ 0x3, (bfd_byte *) &b[0], 4, info);
      if (status != 0)
	{
	  info->memory_error_func (status, pc, info);
	  return -1;
	}
      
      if (is_thumb)
	{
	  if (pc & 0x2)
	    {
	      given = (b[2] << 8) | b[3];
	      
	      status = info->read_memory_func
		((pc + 4) & ~ 0x3, (bfd_byte *) b, 4, info);
	      if (status != 0)
		{
		  info->memory_error_func (status, pc + 4, info);
		  return -1;
		}
	      
	      given |= (b[0] << 24) | (b[1] << 16);
	    }
	  else
	    given = (b[0] << 8) | b[1] | (b[2] << 24) | (b[3] << 16);
	}
      else
	given = (b[0] << 24) | (b[1] << 16) | (b[2] << 8) | (b[3]);
a521 29
  
  if (is_thumb)
    status = print_insn_thumb (pc, info, given);
  else
    status = print_insn_arm (pc, info, given);

  return status;
}

int
print_insn_big_arm (pc, info)
     bfd_vma pc;
     struct disassemble_info * info;
{
  return print_insn (pc, info, false);
}

int
print_insn_little_arm (pc, info)
     bfd_vma pc;
     struct disassemble_info * info;
{
  return print_insn (pc, info, true);
}

void
print_arm_disassembler_options (FILE * stream)
{
  int i;
d523 1
a523 9
  fprintf (stream, _("\n\
The following ARM specific disassembler options are supported for use with\n\
the -M switch:\n"));
  
  for (i = NUM_ARM_REGNAMES; i--;)
    fprintf (stream, "  reg-names-%s %*c%s\n",
	     regnames[i].name,
	     14 - strlen (regnames[i].name), ' ',
	     regnames[i].description);
d525 1
a525 2
  fprintf (stream, "  force-thumb              Assume all insns are Thumb insns\n");
  fprintf (stream, "  no-force-thumb           Examine preceeding label to determine an insn's type\n\n");
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
a62 2
  { "gcc",  "Select register names used by GCC",
    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "sl",  "fp",  "ip",  "sp",  "lr",  "pc" }},
d73 1
a73 1
/* Default to GCC register name set.  */
a421 23
		    case 'B':
		      /* Print ARM V5 BLX(1) address: pc+25 bits.  */
		      {
			bfd_vma address;
			bfd_vma offset = 0;
			
			if (given & 0x00800000)
			  /* Is signed, hi bits should be ones.  */
			  offset = (-1) ^ 0x00ffffff;

			/* Offset is (SignExtend(offset field)<<2).  */
			offset += given & 0x00ffffff;
			offset <<= 2;
			address = offset + pc + 8;
			
			if (given & 0x01000000)
			  /* H bit allows addressing to 2-byte boundaries.  */
			  address += 2;

		        info->print_address_func (address, info);
		      }
		      break;

d423 21
a443 9
		      func (stream, "_");
		      if (given & 0x80000)
			func (stream, "f");
		      if (given & 0x40000)
			func (stream, "s");
		      if (given & 0x20000)
			func (stream, "x");
		      if (given & 0x10000)
			func (stream, "c");
a660 3
	      if ((given & 0x10000000) == 0)
                 func (stream, "blx\t");
	      else
a1028 8
  
  if (info->flags & INSN_HAS_RELOC)
    /* If the instruction has a reloc associated with it, then
       the offset field in the instruction will actually be the
       addend for the reloc.  (We are using REL type relocs).
       In such cases, we can ignore the pc when computing
       addresses, since the addend is not currently pc-relative.  */
    pc = 0;
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d7 1
a7 1
   This file is part of libopcodes.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify it under
   the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 1
a31 1
/* FIXME: This shouldn't be done here.  */
d73 1
a73 15
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "WR", "v5", "SB", "SL",  "FP",  "IP",  "SP",  "LR",  "PC" }},
  { "iwmmxt_regnames", "Select register names used on the Intel Wireless MMX technology coprocessor",
    { "wr0", "wr1", "wr2", "wr3", "wr4", "wr5", "wr6", "wr7", "wr8", "wr9", "wr10", "wr11", "wr12", "wr13", "wr14", "wr15"}},
  { "iwmmxt_Cregnames", "Select control register names used on the Intel Wireless MMX technology coprocessor",
    {"wcid", "wcon", "wcssf", "wcasf", "reserved", "reserved", "reserved", "reserved", "wcgr0", "wcgr1", "wcgr2", "wcgr3", "reserved", "reserved", "reserved", "reserved"}}
};

static char * iwmmxt_wwnames[] =
{"b", "h", "w", "d"};

static char * iwmmxt_wwssnames[] =
{"b", "bus", "b", "bss",
 "h", "hus", "h", "hss",
 "w", "wus", "w", "wss",
 "d", "dus", "d", "dss"
d82 1
a82 1
static bfd_boolean force_thumb = FALSE;
d87 1
a87 1
static char * arm_shift[] =
d91 10
a100 19
static void arm_decode_shift
  PARAMS ((long, fprintf_ftype, void *));
static int  print_insn_arm
  PARAMS ((bfd_vma, struct disassemble_info *, long));
static int  print_insn_thumb
  PARAMS ((bfd_vma, struct disassemble_info *, long));
static void parse_disassembler_options
  PARAMS ((char *));
static int  print_insn
  PARAMS ((bfd_vma, struct disassemble_info *, bfd_boolean));
static int set_iwmmxt_regnames
  PARAMS ((void));

int get_arm_regname_num_options
  PARAMS ((void));
int set_arm_regname_option
  PARAMS ((int));
int get_arm_regnames
  PARAMS ((int, const char **, const char **, const char ***));
d102 1
a102 1
/* Functions.  */
d104 1
a104 1
get_arm_regname_num_options ()
d110 1
a110 2
set_arm_regname_option (option)
     int option;
d118 3
a120 5
get_arm_regnames (option, setname, setdescription, register_names)
     int option;
     const char **setname;
     const char **setdescription;
     const char ***register_names;
d135 1
a135 1

d142 1
a142 1

d150 1
a150 1

d153 1
a153 1

a161 18
static int
set_iwmmxt_regnames ()
{
  const char * setname;
  const char * setdesc;
  const char ** regnames;
  int iwmmxt_regnames = 0;
  int num_regnames = get_arm_regname_num_options ();

  get_arm_regnames (iwmmxt_regnames, &setname,
		    &setdesc, &regnames);
  while ((strcmp ("iwmmxt_regnames", setname))
	 && (iwmmxt_regnames < num_regnames))
    get_arm_regnames (++iwmmxt_regnames, &setname, &setdesc, &regnames);

  return iwmmxt_regnames;
}
			  
a163 1

d166 3
a168 3
     bfd_vma pc;
     struct disassemble_info *info;
     long given;
d170 3
a172 4
  const struct arm_opcode *insn;
  void *stream = info->stream;
  fprintf_ftype func   = info->fprintf_func;
  static int iwmmxt_regnames = 0;
a175 5
      if (insn->value == FIRST_IWMMXT_INSN
	  && info->mach != bfd_mach_arm_XScale
	  && info->mach != bfd_mach_arm_iWMMXt)
	insn = insn + IWMMXT_INSN_COUNT;

d179 1
a179 1

d195 1
a195 1

d197 1
a197 1

d202 3
a204 3

			      /* Pre-indexed.  */
			      func (stream, ", #%d]", offset);
d218 1
a218 1
			      func (stream, "], #%d", offset);
d220 1
a220 2
			      /* ie ignore the offset.  */
			      offset = pc + 8;
d222 1
a222 1

d228 1
a228 1
			  func (stream, "[%s",
d248 1
a248 1
			      func (stream, "]%s",
d260 1
a260 1
				  else
d266 1
a266 1
					(((given & 0x00800000) == 0)
d279 1
a279 1

d282 3
a284 3

			  func (stream, "[pc, #%d]\t; ", offset);

d290 1
a290 1
			  func (stream, "[%s",
d313 1
a313 1
			      func (stream, "]%s",
d327 1
a327 1
				  else
d341 1
a341 1

d393 7
d430 1
a430 1

d439 1
a439 1

a447 19
		    case 'I':
		      /* Print a Cirrus/DSP shift immediate.  */
		      /* Immediates are 7bit signed ints with bits 0..3 in
			 bits 0..3 of opcode and bits 4..6 in bits 5..7
			 of opcode.  */
		      {
			int imm;

			imm = (given & 0xf) | ((given & 0xe0) >> 1);

			/* Is ``imm'' a negative number?  */
			if (imm & 0x40)
			  imm |= (-1 << 7);

			func (stream, "%d", imm);
		      }

		      break;

d476 1
a476 1

d528 1
a528 1
		    case '0': case '1': case '2': case '3': case '4':
d540 1
a540 1

d543 1
a543 1

d546 1
a546 1

d552 1
a552 1

d555 1
a555 1

d562 1
a562 1

d565 1
a565 1

d572 1
a572 1

d575 1
a575 1

d577 1
a577 1

d589 1
a589 1

d592 1
a592 1

d599 1
a599 1

d602 1
a602 1

a609 57

			      case 'w':
				{
				  long reg;

				  if (bitstart != bitend)
				    {
				      reg = given >> bitstart;
				      reg &= (2 << (bitend - bitstart)) - 1;
				      if (bitend - bitstart == 1)
					func (stream, "%s", iwmmxt_wwnames[reg]);
				      else
					func (stream, "%s", iwmmxt_wwssnames[reg]);
				    }
				  else
				    {
				      reg = (((given >> 8)  & 0x1) |
					     ((given >> 22) & 0x1));
				      func (stream, "%s", iwmmxt_wwnames[reg]);
				    }
				}
				break;

			      case 'g':
				{
				  long reg;
				  int current_regnames;

				  if (! iwmmxt_regnames)
				    iwmmxt_regnames = set_iwmmxt_regnames ();
				  current_regnames = set_arm_regname_option
				    (iwmmxt_regnames);

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  func (stream, "%s", arm_regnames[reg]);
				  set_arm_regname_option (current_regnames);
				}
				break;

			      case 'G':
				{
				  long reg;
				  int current_regnames;

				  if (! iwmmxt_regnames)
				    iwmmxt_regnames = set_iwmmxt_regnames ();
				  current_regnames = set_arm_regname_option
				    (iwmmxt_regnames + 1);

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  func (stream, "%s", arm_regnames[reg]);
				  set_arm_regname_option (current_regnames);
				}
				break;

d614 1
a614 79

			  case 'y':
			  case 'z':
			    {
			      int single = *c == 'y';
			      int regno;

			      switch (bitstart)
				{
				case 4: /* Sm pair */
				  func (stream, "{");
				  /* Fall through.  */
				case 0: /* Sm, Dm */
				  regno = given & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 5) & 1;
				    }
				  break;

				case 1: /* Sd, Dd */
				  regno = (given >> 12) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 22) & 1;
				    }
				  break;

				case 2: /* Sn, Dn */
				  regno = (given >> 16) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 7) & 1;
				    }
				  break;

				case 3: /* List */
				  func (stream, "{");
				  regno = (given >> 12) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 22) & 1;
				    }
				  break;


				default:
				  abort ();
				}

			      func (stream, "%c%d", single ? 's' : 'd', regno);

			      if (bitstart == 3)
				{
				  int count = given & 0xff;

				  if (single == 0)
				    count >>= 1;

				  if (--count)
				    {
				      func (stream, "-%c%d",
					    single ? 's' : 'd',
					    regno + count);
				    }

				  func (stream, "}");
				}
			      else if (bitstart == 4)
				func (stream, ", %c%d}", single ? 's' : 'd',
				      regno + 1);

			      break;
			    }

a636 48
		      case 'L':
			switch (given & 0x00400100)
			  {
			  case 0x00000000: func (stream, "b"); break;
			  case 0x00400000: func (stream, "h"); break;
			  case 0x00000100: func (stream, "w"); break;
			  case 0x00400100: func (stream, "d"); break;
			  default:
			    break;
			  }
			break;

		      case 'Z':
			{
			  int value;
			  /* given (20, 23) | given (0, 3) */
			  value = ((given >> 16) & 0xf0) | (given & 0xf);
			  func (stream, "%d", value);
			}
			break;

		      case 'l':
			/* This is like the 'A' operator, except that if
			   the width field "M" is zero, then the offset is
			   *not* multiplied by four.  */
			{
			  int offset = given & 0xff;
			  int multiplier = (given & 0x00000100) ? 4 : 1;

			  func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);

			  if (offset)
			    {
			      if ((given & 0x01000000) != 0)
				func (stream, ", %s#%d]%s",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier,
				      ((given & 0x00200000) != 0 ? "!" : ""));
			      else
				func (stream, "], %s#%d",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier);
			    }
			  else
			    func (stream, "]");
			}
			break;

a652 1

d655 3
a657 3
     bfd_vma pc;
     struct disassemble_info *info;
     long given;
d659 3
a661 3
  const struct thumb_opcode *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;
a671 2
	      long offset;

d674 1
a674 4

	      offset = BDISP23 (given);
	      offset = offset * 2 + pc + 4;

d676 1
a676 4
		{
		  func (stream, "blx\t");
		  offset &= 0xfffffffc;
		}
d678 3
a680 3
		func (stream, "bl\t");

	      info->print_address_func (offset, info);
d687 1
a687 1

d689 1
a689 1

d696 1
a696 1

d706 1
a706 1

d710 1
a710 1

d718 1
a718 1

d722 1
a722 1

d744 1
a744 1

d746 1
a746 1

d778 1
a778 1
                        case '0': case '1': case '2': case '3': case '4':
d783 1
a783 1

d792 1
a792 1

a883 1

d890 1
a890 1

d894 1
a894 1

d903 1
a903 1

d913 1
a913 1

a917 1

d923 1
a923 1

a945 1

d950 1
a950 1
     bfd_boolean little;
d960 1
a960 1

d964 1
a964 1

d966 1
a966 1

d972 1
a972 1

d984 1
a984 1

d987 1
a987 1

d991 1
a991 1

d1001 1
a1001 1

d1005 1
a1005 1

d1011 1
a1011 1

d1023 1
a1023 1

d1029 1
a1029 1

d1037 1
a1037 1

d1046 1
a1046 1

d1054 1
a1054 1

d1068 1
a1068 1
  return print_insn (pc, info, FALSE);
d1076 1
a1076 1
  return print_insn (pc, info, TRUE);
d1087 1
a1087 1

d1091 1
a1091 1
	     (int)(14 - strlen (regnames[i].name)), ' ',
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@a29 1
#include "safe-ctype.h"
d288 1
a288 1
				    func (stream, ", #%s%d",
d309 1
a309 1
				    func (stream, "], #%s%d",
d352 1
a352 1
				    func (stream, ", #%s%d",
d376 1
a376 1
				    func (stream, "], #%s%d",
d447 1
a447 2

		      if ((given & (1 << 24)) != 0)
a449 1

d451 1
a451 1
			    func (stream, ", #%s%d]%s",
d461 4
a464 10

			  func (stream, "]");

			  if (given & (1 << 21))
			    {
			      if (offset)
				func (stream, ", #%s%d",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * 4);
			    }
d466 1
a466 1
			    func (stream, ", {%d}", offset);
a632 10
			      case 'W':
				{
				  long reg;
				  
				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  
				  func (stream, "%d", reg + 1);
				}
				break;
d870 1
a870 1
				func (stream, ", #%s%d]%s",
d875 1
a875 1
				func (stream, "], #%s%d",
a1138 17
/* Disallow mapping symbols ($a, $b, $d, $t etc) from
   being displayed in symbol relative addresses.  */

bfd_boolean
arm_symbol_is_valid (asymbol * sym,
		     struct disassemble_info * info ATTRIBUTE_UNUSED)
{
  const char * name;
  
  if (sym == NULL)
    return FALSE;

  name = bfd_asymbol_name (sym);

  return (name && *name != '$');
}

d1155 1
a1155 1
	if (strneq (option, regnames[i].name, strlen (regnames[i].name)))
a1161 1
	/* XXX - should break 'option' at following delimiter.  */
d1164 1
a1164 1
  else if (strneq (option, "force-thumb", 11))
d1166 1
a1166 1
  else if (strneq (option, "no-force-thumb", 14))
a1168 1
    /* XXX - should break 'option' at following delimiter.  */
d1174 1
a1174 2
/* Parse the string of disassembler options, spliting it at whitespaces
   or commas.  (Whitespace separators supported for backwards compatibility).  */
d1180 2
d1185 1
a1185 1
  while (*options)
d1187 1
a1187 1
      parse_arm_disassembler_option (options);
d1189 9
a1197 6
      /* Skip forward to next seperator.  */
      while ((*options) && (! ISSPACE (*options)) && (*options != ','))
	++ options;
      /* Skip forward past seperators.  */
      while (ISSPACE (*options) || (*options == ','))
	++ options;      
d1199 1
@


