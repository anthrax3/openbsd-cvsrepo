head	1.5;
access;
symbols
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.52
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.48
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.44
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.46
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.38
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.42
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.40
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.36
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.34
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.32
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.30
	OPENBSD_5_0:1.5.0.28
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.26
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.24
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.20
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.22
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.18
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.16
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.6
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.5
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.4
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.3
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.3
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.2
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.11.02.20.45.54;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.17.21.54.55;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.44;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.19.13.00;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.02;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.02;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.05.29.09.27.55;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.09.12.14.47.56;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.05.13.13.58.01;	author fgsch;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.05.17.20.42.45;	author drahn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.11.02.20.23.13;	author miod;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* Print Motorola 68k instructions.
   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   This file is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "sysdep.h"
#include "dis-asm.h"
#include "floatformat.h"
#include "libiberty.h"
#include "opintl.h"

#include "opcode/m68k.h"

/* Local function prototypes */

static int
fetch_data PARAMS ((struct disassemble_info *, bfd_byte *));

static void
dummy_print_address PARAMS ((bfd_vma, struct disassemble_info *));

static int
fetch_arg PARAMS ((unsigned char *, int, int, disassemble_info *));

static void
print_base PARAMS ((int, bfd_vma, disassemble_info *));

static unsigned char *
print_indexed PARAMS ((int, unsigned char *, bfd_vma, disassemble_info *));

static int
print_insn_arg PARAMS ((const char *, unsigned char *, unsigned char *,
			bfd_vma, disassemble_info *));

const char * const fpcr_names[] = {
    "", "%fpiar", "%fpsr", "%fpiar/%fpsr", "%fpcr",
    "%fpiar/%fpcr", "%fpsr/%fpcr", "%fpiar/%fpsr/%fpcr"
};

static char *const reg_names[] = {
    "%d0", "%d1", "%d2", "%d3", "%d4", "%d5", "%d6", "%d7",
    "%a0", "%a1", "%a2", "%a3", "%a4", "%a5", "%fp", "%sp",
    "%ps", "%pc"
};

/* Sign-extend an (unsigned char). */
#if __STDC__ == 1
#define COERCE_SIGNED_CHAR(ch) ((signed char) (ch))
#else
#define COERCE_SIGNED_CHAR(ch) ((int) (((ch) ^ 0x80) & 0xFF) - 128)
#endif

/* Get a 1 byte signed integer.  */
#define NEXTBYTE(p)  (p += 2, FETCH_DATA (info, p), COERCE_SIGNED_CHAR(p[-1]))

/* Get a 2 byte signed integer.  */
#define COERCE16(x) ((int) (((x) ^ 0x8000) - 0x8000))
#define NEXTWORD(p)  \
  (p += 2, FETCH_DATA (info, p), \
   COERCE16 ((p[-2] << 8) + p[-1]))

/* Get a 4 byte signed integer.  */
#define COERCE32(x) ((bfd_signed_vma) ((x) ^ 0x80000000) - 0x80000000)
#define NEXTLONG(p)  \
  (p += 4, FETCH_DATA (info, p), \
   (COERCE32 ((((((p[-4] << 8) + p[-3]) << 8) + p[-2]) << 8) + p[-1])))

/* Get a 4 byte unsigned integer.  */
#define NEXTULONG(p)  \
  (p += 4, FETCH_DATA (info, p), \
   (unsigned int) ((((((p[-4] << 8) + p[-3]) << 8) + p[-2]) << 8) + p[-1]))

/* Get a single precision float.  */
#define NEXTSINGLE(val, p) \
  (p += 4, FETCH_DATA (info, p), \
   floatformat_to_double (&floatformat_ieee_single_big, (char *) p - 4, &val))

/* Get a double precision float.  */
#define NEXTDOUBLE(val, p) \
  (p += 8, FETCH_DATA (info, p), \
   floatformat_to_double (&floatformat_ieee_double_big, (char *) p - 8, &val))

/* Get an extended precision float.  */
#define NEXTEXTEND(val, p) \
  (p += 12, FETCH_DATA (info, p), \
   floatformat_to_double (&floatformat_m68881_ext, (char *) p - 12, &val))

/* Need a function to convert from packed to double
   precision.   Actually, it's easier to print a
   packed number than a double anyway, so maybe
   there should be a special case to handle this... */
#define NEXTPACKED(p) \
  (p += 12, FETCH_DATA (info, p), 0.0)

/* Maximum length of an instruction.  */
#define MAXLEN 22

#include <setjmp.h>

struct private {
  /* Points to first byte not fetched.  */
  bfd_byte *max_fetched;
  bfd_byte the_buffer[MAXLEN];
  bfd_vma insn_start;
  jmp_buf bailout;
};

/* Make sure that bytes from INFO->PRIVATE_DATA->BUFFER (inclusive)
   to ADDR (exclusive) are valid.  Returns 1 for success, longjmps
   on error.  */
#define FETCH_DATA(info, addr) \
  ((addr) <= ((struct private *) (info->private_data))->max_fetched \
   ? 1 : fetch_data ((info), (addr)))

static int
fetch_data (info, addr)
     struct disassemble_info *info;
     bfd_byte *addr;
{
  int status;
  struct private *priv = (struct private *)info->private_data;
  bfd_vma start = priv->insn_start + (priv->max_fetched - priv->the_buffer);

  status = (*info->read_memory_func) (start,
				      priv->max_fetched,
				      addr - priv->max_fetched,
				      info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, start, info);
      longjmp (priv->bailout, 1);
    }
  else
    priv->max_fetched = addr;
  return 1;
}

/* This function is used to print to the bit-bucket. */
static int
#ifdef __STDC__
dummy_printer (FILE *file ATTRIBUTE_UNUSED,
	       const char *format ATTRIBUTE_UNUSED, ...)
#else
dummy_printer (file)
     FILE *file ATTRIBUTE_UNUSED;
#endif
{
  return 0;
}

static void
dummy_print_address (vma, info)
     bfd_vma vma ATTRIBUTE_UNUSED;
     struct disassemble_info *info ATTRIBUTE_UNUSED;
{
}

/* Print the m68k instruction at address MEMADDR in debugged memory,
   on INFO->STREAM.  Returns length of the instruction, in bytes.  */

int
print_insn_m68k (memaddr, info)
     bfd_vma memaddr;
     disassemble_info *info;
{
  register int i;
  register unsigned char *p;
  unsigned char *save_p;
  register const char *d;
  register unsigned long bestmask;
  const struct m68k_opcode *best;
  unsigned int arch_mask;
  struct private priv;
  bfd_byte *buffer = priv.the_buffer;
  fprintf_ftype save_printer = info->fprintf_func;
  void (*save_print_address) PARAMS ((bfd_vma, struct disassemble_info *))
    = info->print_address_func;
  int major_opcode;
  static int numopcodes[16];
  static const struct m68k_opcode **opcodes[16];

  if (!opcodes[0])
    {
      /* Speed up the matching by sorting the opcode table on the upper
	 four bits of the opcode.  */
      const struct m68k_opcode **opc_pointer[16];

      /* First count how many opcodes are in each of the sixteen buckets.  */
      for (i = 0; i < m68k_numopcodes; i++)
	numopcodes[(m68k_opcodes[i].opcode >> 28) & 15]++;

      /* Then create a sorted table of pointers that point into the
	 unsorted table.  */
      opc_pointer[0] = ((const struct m68k_opcode **)
			xmalloc (sizeof (struct m68k_opcode *)
				 * m68k_numopcodes));
      opcodes[0] = opc_pointer[0];
      for (i = 1; i < 16; i++)
	{
	  opc_pointer[i] = opc_pointer[i - 1] + numopcodes[i - 1];
	  opcodes[i] = opc_pointer[i];
	}

      for (i = 0; i < m68k_numopcodes; i++)
	*opc_pointer[(m68k_opcodes[i].opcode >> 28) & 15]++ = &m68k_opcodes[i];

    }

  info->private_data = (PTR) &priv;
  /* Tell objdump to use two bytes per chunk and six bytes per line for
     displaying raw data.  */
  info->bytes_per_chunk = 2;
  info->bytes_per_line = 6;
  info->display_endian = BFD_ENDIAN_BIG;
  priv.max_fetched = priv.the_buffer;
  priv.insn_start = memaddr;
  if (setjmp (priv.bailout) != 0)
    /* Error return.  */
    return -1;

  best = NULL;
  switch (info->mach)
    {
    default:
    case 0:
      arch_mask = (unsigned int) -1;
      break;
    case bfd_mach_m68000:
      arch_mask = m68000;
      break;
    case bfd_mach_m68008:
      arch_mask = m68008;
      break;
    case bfd_mach_m68010:
      arch_mask = m68010;
      break;
    case bfd_mach_m68020:
      arch_mask = m68020;
      break;
    case bfd_mach_m68030:
      arch_mask = m68030;
      break;
    case bfd_mach_m68040:
      arch_mask = m68040;
      break;
    case bfd_mach_m68060:
      arch_mask = m68060;
      break;
    case bfd_mach_mcf5200:
      arch_mask = mcf5200;
      break;
    case bfd_mach_mcf528x:
      arch_mask = mcf528x;
      break;
    case bfd_mach_mcf5206e:
      arch_mask = mcf5206e;
      break;
    case bfd_mach_mcf5307:
      arch_mask = mcf5307;
      break;
    case bfd_mach_mcf5407:
      arch_mask = mcf5407;
      break;
    }

  arch_mask |= m68881 | m68851;

  bestmask = 0;
  FETCH_DATA (info, buffer + 2);
  major_opcode = (buffer[0] >> 4) & 15;
  for (i = 0; i < numopcodes[major_opcode]; i++)
    {
      const struct m68k_opcode *opc = opcodes[major_opcode][i];
      unsigned long opcode = opc->opcode;
      unsigned long match = opc->match;

      if (((0xff & buffer[0] & (match >> 24)) == (0xff & (opcode >> 24)))
	  && ((0xff & buffer[1] & (match >> 16)) == (0xff & (opcode >> 16)))
	  /* Only fetch the next two bytes if we need to.  */
	  && (((0xffff & match) == 0)
	      ||
	      (FETCH_DATA (info, buffer + 4)
	       && ((0xff & buffer[2] & (match >> 8)) == (0xff & (opcode >> 8)))
	       && ((0xff & buffer[3] & match) == (0xff & opcode)))
	      )
	  && (opc->arch & arch_mask) != 0)
	{
	  /* Don't use for printout the variants of divul and divsl
	     that have the same register number in two places.
	     The more general variants will match instead.  */
	  for (d = opc->args; *d; d += 2)
	    if (d[1] == 'D')
	      break;

	  /* Don't use for printout the variants of most floating
	     point coprocessor instructions which use the same
	     register number in two places, as above. */
	  if (*d == '\0')
	    for (d = opc->args; *d; d += 2)
	      if (d[1] == 't')
		break;

	  /* Don't match fmovel with more than one register; wait for
             fmoveml.  */
	  if (*d == '\0')
	    {
	      for (d = opc->args; *d; d += 2)
		{
		  if (d[0] == 's' && d[1] == '8')
		    {
		      int val;

		      val = fetch_arg (buffer, d[1], 3, info);
		      if ((val & (val - 1)) != 0)
			break;
		    }
		}
	    }

	  if (*d == '\0' && match > bestmask)
	    {
	      best = opc;
	      bestmask = match;
	    }
	}
    }

  if (best == NULL)
    goto invalid;

  /* Point at first word of argument data,
     and at descriptor for first argument.  */
  p = buffer + 2;

  /* Figure out how long the fixed-size portion of the instruction is.
     The only place this is stored in the opcode table is
     in the arguments--look for arguments which specify fields in the 2nd
     or 3rd words of the instruction.  */
  for (d = best->args; *d; d += 2)
    {
      /* I don't think it is necessary to be checking d[0] here; I suspect
	 all this could be moved to the case statement below.  */
      if (d[0] == '#')
	{
	  if (d[1] == 'l' && p - buffer < 6)
	    p = buffer + 6;
	  else if (p - buffer < 4 && d[1] != 'C' && d[1] != '8')
	    p = buffer + 4;
	}
      if ((d[0] == 'L' || d[0] == 'l') && d[1] == 'w' && p - buffer < 4)
	p = buffer + 4;
      switch (d[1])
	{
	case '1':
	case '2':
	case '3':
	case '7':
	case '8':
	case '9':
	case 'i':
	  if (p - buffer < 4)
	    p = buffer + 4;
	  break;
	case '4':
	case '5':
	case '6':
	  if (p - buffer < 6)
	    p = buffer + 6;
	  break;
	default:
	  break;
	}
    }

  /* pflusha is an exceptions.  It takes no arguments but is two words
     long.  Recognize it by looking at the lower 16 bits of the mask.  */
  if (p - buffer < 4 && (best->match & 0xFFFF) != 0)
    p = buffer + 4;

  /* lpstop is another exception.  It takes a one word argument but is
     three words long.  */
  if (p - buffer < 6
      && (best->match & 0xffff) == 0xffff
      && best->args[0] == '#'
      && best->args[1] == 'w')
    {
      /* Copy the one word argument into the usual location for a one
	 word argument, to simplify printing it.  We can get away with
	 this because we know exactly what the second word is, and we
	 aren't going to print anything based on it.  */
      p = buffer + 6;
      FETCH_DATA (info, p);
      buffer[2] = buffer[4];
      buffer[3] = buffer[5];
    }

  FETCH_DATA (info, p);

  d = best->args;

  /* We scan the operands twice.  The first time we don't print anything,
     but look for errors. */

  save_p = p;
  info->print_address_func = dummy_print_address;
  info->fprintf_func = (fprintf_ftype) dummy_printer;
  for (; *d; d += 2)
    {
      int eaten = print_insn_arg (d, buffer, p, memaddr + (p - buffer), info);
      if (eaten >= 0)
	p += eaten;
      else if (eaten == -1)
	goto invalid;
      else
	{
	  (*info->fprintf_func) (info->stream,
				 /* xgettext:c-format */
				 _("<internal error in opcode table: %s %s>\n"),
				 best->name,
				 best->args);
	  goto invalid;
	}

    }
  p = save_p;
  info->fprintf_func = save_printer;
  info->print_address_func = save_print_address;

  d = best->args;

  (*info->fprintf_func) (info->stream, "%s", best->name);

  if (*d)
    (*info->fprintf_func) (info->stream, " ");

  while (*d)
    {
      p += print_insn_arg (d, buffer, p, memaddr + (p - buffer), info);
      d += 2;
      if (*d && *(d - 2) != 'I' && *d != 'k')
	(*info->fprintf_func) (info->stream, ",");
    }
  return p - buffer;

 invalid:
  /* Handle undefined instructions.  */
  info->fprintf_func = save_printer;
  info->print_address_func = save_print_address;
  (*info->fprintf_func) (info->stream, "0%o",
			 (buffer[0] << 8) + buffer[1]);
  return 2;
}

/* Returns number of bytes "eaten" by the operand, or
   return -1 if an invalid operand was found, or -2 if
   an opcode tabe error was found. */

static int
print_insn_arg (d, buffer, p0, addr, info)
     const char *d;
     unsigned char *buffer;
     unsigned char *p0;
     bfd_vma addr;		/* PC for this arg to be relative to */
     disassemble_info *info;
{
  register int val = 0;
  register int place = d[1];
  register unsigned char *p = p0;
  int regno;
  register const char *regname;
  register unsigned char *p1;
  double flval;
  int flt_p;
  bfd_signed_vma disp;
  unsigned int uval;

  switch (*d)
    {
    case 'c':		/* cache identifier */
      {
        static char *const cacheFieldName[] = { "nc", "dc", "ic", "bc" };
        val = fetch_arg (buffer, place, 2, info);
        (*info->fprintf_func) (info->stream, cacheFieldName[val]);
        break;
      }

    case 'a':		/* address register indirect only. Cf. case '+'. */
      {
        (*info->fprintf_func)
	  (info->stream,
	   "%s@@",
	   reg_names[fetch_arg (buffer, place, 3, info) + 8]);
        break;
      }

    case '_':		/* 32-bit absolute address for move16. */
      {
        uval = NEXTULONG (p);
	(*info->print_address_func) (uval, info);
        break;
      }

    case 'C':
      (*info->fprintf_func) (info->stream, "%%ccr");
      break;

    case 'S':
      (*info->fprintf_func) (info->stream, "%%sr");
      break;

    case 'U':
      (*info->fprintf_func) (info->stream, "%%usp");
      break;

    case 'E':
      (*info->fprintf_func) (info->stream, "%%acc");
      break;

    case 'G':
      (*info->fprintf_func) (info->stream, "%%macsr");
      break;

    case 'H':
      (*info->fprintf_func) (info->stream, "%%mask");
      break;

    case 'J':
      {
	/* FIXME: There's a problem here, different m68k processors call the
	   same address different names. This table can't get it right
	   because it doesn't know which processor it's disassembling for.  */
	static const struct { char *name; int value; } names[]
	  = {{"%sfc", 0x000}, {"%dfc", 0x001}, {"%cacr", 0x002},
	     {"%tc",  0x003}, {"%itt0",0x004}, {"%itt1", 0x005},
             {"%dtt0",0x006}, {"%dtt1",0x007}, {"%buscr",0x008},
	     {"%usp", 0x800}, {"%vbr", 0x801}, {"%caar", 0x802},
	     {"%msp", 0x803}, {"%isp", 0x804},
	     {"%flashbar", 0xc04}, {"%rambar", 0xc05}, /* mcf528x added these.  */

	     /* Should we be calling this psr like we do in case 'Y'?  */
	     {"%mmusr",0x805},

             {"%urp", 0x806}, {"%srp", 0x807}, {"%pcr", 0x808}};

	val = fetch_arg (buffer, place, 12, info);
	for (regno = sizeof names / sizeof names[0] - 1; regno >= 0; regno--)
	  if (names[regno].value == val)
	    {
	      (*info->fprintf_func) (info->stream, "%s", names[regno].name);
	      break;
	    }
	if (regno < 0)
	  (*info->fprintf_func) (info->stream, "%d", val);
      }
      break;

    case 'Q':
      val = fetch_arg (buffer, place, 3, info);
      /* 0 means 8, except for the bkpt instruction... */
      if (val == 0 && d[1] != 's')
	val = 8;
      (*info->fprintf_func) (info->stream, "#%d", val);
      break;

    case 'x':
      val = fetch_arg (buffer, place, 3, info);
      /* 0 means -1.  */
      if (val == 0)
	val = -1;
      (*info->fprintf_func) (info->stream, "#%d", val);
      break;

    case 'M':
      if (place == 'h')
	{
	  static char *const scalefactor_name[] = { "<<", ">>" };
	  val = fetch_arg (buffer, place, 1, info);
	  (*info->fprintf_func) (info->stream, scalefactor_name[val]);
	}
      else
	{
	  val = fetch_arg (buffer, place, 8, info);
	  if (val & 0x80)
	    val = val - 0x100;
	  (*info->fprintf_func) (info->stream, "#%d", val);
	}
      break;

    case 'T':
      val = fetch_arg (buffer, place, 4, info);
      (*info->fprintf_func) (info->stream, "#%d", val);
      break;

    case 'D':
      (*info->fprintf_func) (info->stream, "%s",
			     reg_names[fetch_arg (buffer, place, 3, info)]);
      break;

    case 'A':
      (*info->fprintf_func)
	(info->stream, "%s",
	 reg_names[fetch_arg (buffer, place, 3, info) + 010]);
      break;

    case 'R':
      (*info->fprintf_func)
	(info->stream, "%s",
	 reg_names[fetch_arg (buffer, place, 4, info)]);
      break;

    case 'r':
      regno = fetch_arg (buffer, place, 4, info);
      if (regno > 7)
	(*info->fprintf_func) (info->stream, "%s@@", reg_names[regno]);
      else
	(*info->fprintf_func) (info->stream, "@@(%s)", reg_names[regno]);
      break;

    case 'F':
      (*info->fprintf_func)
	(info->stream, "%%fp%d",
	 fetch_arg (buffer, place, 3, info));
      break;

    case 'O':
      val = fetch_arg (buffer, place, 6, info);
      if (val & 0x20)
	(*info->fprintf_func) (info->stream, "%s", reg_names[val & 7]);
      else
	(*info->fprintf_func) (info->stream, "%d", val);
      break;

    case '+':
      (*info->fprintf_func)
	(info->stream, "%s@@+",
	 reg_names[fetch_arg (buffer, place, 3, info) + 8]);
      break;

    case '-':
      (*info->fprintf_func)
	(info->stream, "%s@@-",
	 reg_names[fetch_arg (buffer, place, 3, info) + 8]);
      break;

    case 'k':
      if (place == 'k')
	(*info->fprintf_func)
	  (info->stream, "{%s}",
	   reg_names[fetch_arg (buffer, place, 3, info)]);
      else if (place == 'C')
	{
	  val = fetch_arg (buffer, place, 7, info);
	  if (val > 63)		/* This is a signed constant. */
	    val -= 128;
	  (*info->fprintf_func) (info->stream, "{#%d}", val);
	}
      else
	return -2;
      break;

    case '#':
    case '^':
      p1 = buffer + (*d == '#' ? 2 : 4);
      if (place == 's')
	val = fetch_arg (buffer, place, 4, info);
      else if (place == 'C')
	val = fetch_arg (buffer, place, 7, info);
      else if (place == '8')
	val = fetch_arg (buffer, place, 3, info);
      else if (place == '3')
	val = fetch_arg (buffer, place, 8, info);
      else if (place == 'b')
	val = NEXTBYTE (p1);
      else if (place == 'w' || place == 'W')
	val = NEXTWORD (p1);
      else if (place == 'l')
	val = NEXTLONG (p1);
      else
	return -2;
      (*info->fprintf_func) (info->stream, "#%d", val);
      break;

    case 'B':
      if (place == 'b')
	disp = NEXTBYTE (p);
      else if (place == 'B')
	disp = COERCE_SIGNED_CHAR (buffer[1]);
      else if (place == 'w' || place == 'W')
	disp = NEXTWORD (p);
      else if (place == 'l' || place == 'L' || place == 'C')
	disp = NEXTLONG (p);
      else if (place == 'g')
	{
	  disp = NEXTBYTE (buffer);
	  if (disp == 0)
	    disp = NEXTWORD (p);
	  else if (disp == -1)
	    disp = NEXTLONG (p);
	}
      else if (place == 'c')
	{
	  if (buffer[1] & 0x40)		/* If bit six is one, long offset */
	    disp = NEXTLONG (p);
	  else
	    disp = NEXTWORD (p);
	}
      else
	return -2;

      (*info->print_address_func) (addr + disp, info);
      break;

    case 'd':
      val = NEXTWORD (p);
      (*info->fprintf_func)
	(info->stream, "%s@@(%d)",
	 reg_names[fetch_arg (buffer, place, 3, info) + 8], val);
      break;

    case 's':
      (*info->fprintf_func) (info->stream, "%s",
			     fpcr_names[fetch_arg (buffer, place, 3, info)]);
      break;

    case 'I':
      /* Get coprocessor ID... */
      val = fetch_arg (buffer, 'd', 3, info);

      if (val != 1)				/* Unusual coprocessor ID? */
	(*info->fprintf_func) (info->stream, "(cpid=%d) ", val);
      break;

    case '*':
    case '~':
    case '%':
    case ';':
    case '@@':
    case '!':
    case '$':
    case '?':
    case '/':
    case '&':
    case '|':
    case '<':
    case '>':
    case 'm':
    case 'n':
    case 'o':
    case 'p':
    case 'q':
    case 'v':
    case 'b':
    case 'w':
    case 'y':
    case 'z':
      if (place == 'd')
	{
	  val = fetch_arg (buffer, 'x', 6, info);
	  val = ((val & 7) << 3) + ((val >> 3) & 7);
	}
      else
	val = fetch_arg (buffer, 's', 6, info);

      /* Get register number assuming address register.  */
      regno = (val & 7) + 8;
      regname = reg_names[regno];
      switch (val >> 3)
	{
	case 0:
	  (*info->fprintf_func) (info->stream, "%s", reg_names[val]);
	  break;

	case 1:
	  (*info->fprintf_func) (info->stream, "%s", regname);
	  break;

	case 2:
	  (*info->fprintf_func) (info->stream, "%s@@", regname);
	  break;

	case 3:
	  (*info->fprintf_func) (info->stream, "%s@@+", regname);
	  break;

	case 4:
	  (*info->fprintf_func) (info->stream, "%s@@-", regname);
	  break;

	case 5:
	  val = NEXTWORD (p);
	  (*info->fprintf_func) (info->stream, "%s@@(%d)", regname, val);
	  break;

	case 6:
	  p = print_indexed (regno, p, addr, info);
	  break;

	case 7:
	  switch (val & 7)
	    {
	    case 0:
	      val = NEXTWORD (p);
	      (*info->print_address_func) (val, info);
	      break;

	    case 1:
	      uval = NEXTULONG (p);
	      (*info->print_address_func) (uval, info);
	      break;

	    case 2:
	      val = NEXTWORD (p);
	      (*info->fprintf_func) (info->stream, "%%pc@@(");
	      (*info->print_address_func) (addr + val, info);
	      (*info->fprintf_func) (info->stream, ")");
	      break;

	    case 3:
	      p = print_indexed (-1, p, addr, info);
	      break;

	    case 4:
	      flt_p = 1;	/* Assume it's a float... */
	      switch (place)
	      {
		case 'b':
		  val = NEXTBYTE (p);
		  flt_p = 0;
		  break;

		case 'w':
		  val = NEXTWORD (p);
		  flt_p = 0;
		  break;

		case 'l':
		  val = NEXTLONG (p);
		  flt_p = 0;
		  break;

		case 'f':
		  NEXTSINGLE (flval, p);
		  break;

		case 'F':
		  NEXTDOUBLE (flval, p);
		  break;

		case 'x':
		  NEXTEXTEND (flval, p);
		  break;

		case 'p':
		  flval = NEXTPACKED (p);
		  break;

		default:
		  return -1;
	      }
	      if (flt_p)	/* Print a float? */
		(*info->fprintf_func) (info->stream, "#%g", flval);
	      else
		(*info->fprintf_func) (info->stream, "#%d", val);
	      break;

	    default:
	      return -1;
	    }
	}
      break;

    case 'L':
    case 'l':
	if (place == 'w')
	  {
	    char doneany;
	    p1 = buffer + 2;
	    val = NEXTWORD (p1);
	    /* Move the pointer ahead if this point is farther ahead
	       than the last.  */
	    p = p1 > p ? p1 : p;
	    if (val == 0)
	      {
		(*info->fprintf_func) (info->stream, "#0");
		break;
	      }
	    if (*d == 'l')
	      {
		register int newval = 0;
		for (regno = 0; regno < 16; ++regno)
		  if (val & (0x8000 >> regno))
		    newval |= 1 << regno;
		val = newval;
	      }
	    val &= 0xffff;
	    doneany = 0;
	    for (regno = 0; regno < 16; ++regno)
	      if (val & (1 << regno))
		{
		  int first_regno;
		  if (doneany)
		    (*info->fprintf_func) (info->stream, "/");
		  doneany = 1;
		  (*info->fprintf_func) (info->stream, "%s", reg_names[regno]);
		  first_regno = regno;
		  while (val & (1 << (regno + 1)))
		    ++regno;
		  if (regno > first_regno)
		    (*info->fprintf_func) (info->stream, "-%s",
					   reg_names[regno]);
		}
	  }
	else if (place == '3')
	  {
	    /* `fmovem' insn.  */
	    char doneany;
	    val = fetch_arg (buffer, place, 8, info);
	    if (val == 0)
	      {
		(*info->fprintf_func) (info->stream, "#0");
		break;
	      }
	    if (*d == 'l')
	      {
		register int newval = 0;
		for (regno = 0; regno < 8; ++regno)
		  if (val & (0x80 >> regno))
		    newval |= 1 << regno;
		val = newval;
	      }
	    val &= 0xff;
	    doneany = 0;
	    for (regno = 0; regno < 8; ++regno)
	      if (val & (1 << regno))
		{
		  int first_regno;
		  if (doneany)
		    (*info->fprintf_func) (info->stream, "/");
		  doneany = 1;
		  (*info->fprintf_func) (info->stream, "%%fp%d", regno);
		  first_regno = regno;
		  while (val & (1 << (regno + 1)))
		    ++regno;
		  if (regno > first_regno)
		    (*info->fprintf_func) (info->stream, "-%%fp%d", regno);
		}
	  }
	else if (place == '8')
	  {
	    /* fmoveml for FP status registers */
	    (*info->fprintf_func) (info->stream, "%s",
				   fpcr_names[fetch_arg (buffer, place, 3,
							 info)]);
	  }
	else
	  return -2;
      break;

    case 'X':
      place = '8';
    case 'Y':
    case 'Z':
    case 'W':
    case '0':
    case '1':
    case '2':
    case '3':
      {
	int val = fetch_arg (buffer, place, 5, info);
	char *name = 0;
	switch (val)
	  {
	  case 2: name = "%tt0"; break;
	  case 3: name = "%tt1"; break;
	  case 0x10: name = "%tc"; break;
	  case 0x11: name = "%drp"; break;
	  case 0x12: name = "%srp"; break;
	  case 0x13: name = "%crp"; break;
	  case 0x14: name = "%cal"; break;
	  case 0x15: name = "%val"; break;
	  case 0x16: name = "%scc"; break;
	  case 0x17: name = "%ac"; break;
 	  case 0x18: name = "%psr"; break;
	  case 0x19: name = "%pcsr"; break;
	  case 0x1c:
	  case 0x1d:
	    {
	      int break_reg = ((buffer[3] >> 2) & 7);
	      (*info->fprintf_func)
		(info->stream, val == 0x1c ? "%%bad%d" : "%%bac%d",
		 break_reg);
	    }
	    break;
	  default:
	    (*info->fprintf_func) (info->stream, "<mmu register %d>", val);
	  }
	if (name)
	  (*info->fprintf_func) (info->stream, "%s", name);
      }
      break;

    case 'f':
      {
	int fc = fetch_arg (buffer, place, 5, info);
	if (fc == 1)
	  (*info->fprintf_func) (info->stream, "%%dfc");
	else if (fc == 0)
	  (*info->fprintf_func) (info->stream, "%%sfc");
	else
	  /* xgettext:c-format */
	  (*info->fprintf_func) (info->stream, _("<function code %d>"), fc);
      }
      break;

    case 'V':
      (*info->fprintf_func) (info->stream, "%%val");
      break;

    case 't':
      {
	int level = fetch_arg (buffer, place, 3, info);
	(*info->fprintf_func) (info->stream, "%d", level);
      }
      break;

    case 'u':
      {
	short is_upper = 0;
	int reg = fetch_arg (buffer, place, 5, info);

	if (reg & 0x10)
	  {
	    is_upper = 1;
	    reg &= 0xf;
	  }
	(*info->fprintf_func) (info->stream, "%s%s",
			       reg_names[reg],
			       is_upper ? "u" : "l");
      }
      break;

    default:
      return -2;
    }

  return p - p0;
}

/* Fetch BITS bits from a position in the instruction specified by CODE.
   CODE is a "place to put an argument", or 'x' for a destination
   that is a general address (mode and register).
   BUFFER contains the instruction.  */

static int
fetch_arg (buffer, code, bits, info)
     unsigned char *buffer;
     int code;
     int bits;
     disassemble_info *info;
{
  register int val = 0;
  switch (code)
    {
    case 's':
      val = buffer[1];
      break;

    case 'd':			/* Destination, for register or quick.  */
      val = (buffer[0] << 8) + buffer[1];
      val >>= 9;
      break;

    case 'x':			/* Destination, for general arg */
      val = (buffer[0] << 8) + buffer[1];
      val >>= 6;
      break;

    case 'k':
      FETCH_DATA (info, buffer + 3);
      val = (buffer[3] >> 4);
      break;

    case 'C':
      FETCH_DATA (info, buffer + 3);
      val = buffer[3];
      break;

    case '1':
      FETCH_DATA (info, buffer + 3);
      val = (buffer[2] << 8) + buffer[3];
      val >>= 12;
      break;

    case '2':
      FETCH_DATA (info, buffer + 3);
      val = (buffer[2] << 8) + buffer[3];
      val >>= 6;
      break;

    case '3':
    case 'j':
      FETCH_DATA (info, buffer + 3);
      val = (buffer[2] << 8) + buffer[3];
      break;

    case '4':
      FETCH_DATA (info, buffer + 5);
      val = (buffer[4] << 8) + buffer[5];
      val >>= 12;
      break;

    case '5':
      FETCH_DATA (info, buffer + 5);
      val = (buffer[4] << 8) + buffer[5];
      val >>= 6;
      break;

    case '6':
      FETCH_DATA (info, buffer + 5);
      val = (buffer[4] << 8) + buffer[5];
      break;

    case '7':
      FETCH_DATA (info, buffer + 3);
      val = (buffer[2] << 8) + buffer[3];
      val >>= 7;
      break;

    case '8':
      FETCH_DATA (info, buffer + 3);
      val = (buffer[2] << 8) + buffer[3];
      val >>= 10;
      break;

    case '9':
      FETCH_DATA (info, buffer + 3);
      val = (buffer[2] << 8) + buffer[3];
      val >>= 5;
      break;

    case 'e':
      val = (buffer[1] >> 6);
      break;

    case 'm':
      val = (buffer[1] & 0x40 ? 0x8 : 0)
	| ((buffer[0] >> 1) & 0x7)
	| (buffer[3] & 0x80 ? 0x10 : 0);
      break;

    case 'n':
      val = (buffer[1] & 0x40 ? 0x8 : 0) | ((buffer[0] >> 1) & 0x7);
      break;

    case 'o':
      val = (buffer[2] >> 4) | (buffer[3] & 0x80 ? 0x10 : 0);
      break;

    case 'M':
      val = buffer[1] | (buffer[3] & 0x40 ? 0x10 : 0);
      break;

    case 'N':
      val = buffer[3] | (buffer[3] & 0x40 ? 0x10 : 0);
      break;

    case 'h':
      val = buffer[2] >> 2;
      break;

    default:
      abort ();
    }

  switch (bits)
    {
    case 1:
      return val & 1;
    case 2:
      return val & 3;
    case 3:
      return val & 7;
    case 4:
      return val & 017;
    case 5:
      return val & 037;
    case 6:
      return val & 077;
    case 7:
      return val & 0177;
    case 8:
      return val & 0377;
    case 12:
      return val & 07777;
    default:
      abort ();
    }
}

/* Print an indexed argument.  The base register is BASEREG (-1 for pc).
   P points to extension word, in buffer.
   ADDR is the nominal core address of that extension word.  */

static unsigned char *
print_indexed (basereg, p, addr, info)
     int basereg;
     unsigned char *p;
     bfd_vma addr;
     disassemble_info *info;
{
  register int word;
  static char *const scales[] = { "", ":2", ":4", ":8" };
  bfd_vma base_disp;
  bfd_vma outer_disp;
  char buf[40];
  char vmabuf[50];

  word = NEXTWORD (p);

  /* Generate the text for the index register.
     Where this will be output is not yet determined.  */
  sprintf (buf, "%s:%c%s",
	   reg_names[(word >> 12) & 0xf],
	   (word & 0x800) ? 'l' : 'w',
	   scales[(word >> 9) & 3]);

  /* Handle the 68000 style of indexing.  */

  if ((word & 0x100) == 0)
    {
      base_disp = word & 0xff;
      if ((base_disp & 0x80) != 0)
	base_disp -= 0x100;
      if (basereg == -1)
	base_disp += addr;
      print_base (basereg, base_disp, info);
      (*info->fprintf_func) (info->stream, ",%s)", buf);
      return p;
    }

  /* Handle the generalized kind.  */
  /* First, compute the displacement to add to the base register.  */

  if (word & 0200)
    {
      if (basereg == -1)
	basereg = -3;
      else
	basereg = -2;
    }
  if (word & 0100)
    buf[0] = '\0';
  base_disp = 0;
  switch ((word >> 4) & 3)
    {
    case 2:
      base_disp = NEXTWORD (p);
      break;
    case 3:
      base_disp = NEXTLONG (p);
    }
  if (basereg == -1)
    base_disp += addr;

  /* Handle single-level case (not indirect) */

  if ((word & 7) == 0)
    {
      print_base (basereg, base_disp, info);
      if (buf[0] != '\0')
	(*info->fprintf_func) (info->stream, ",%s", buf);
      (*info->fprintf_func) (info->stream, ")");
      return p;
    }

  /* Two level.  Compute displacement to add after indirection.  */

  outer_disp = 0;
  switch (word & 3)
    {
    case 2:
      outer_disp = NEXTWORD (p);
      break;
    case 3:
      outer_disp = NEXTLONG (p);
    }

  print_base (basereg, base_disp, info);
  if ((word & 4) == 0 && buf[0] != '\0')
    {
      (*info->fprintf_func) (info->stream, ",%s", buf);
      buf[0] = '\0';
    }
  sprintf_vma (vmabuf, outer_disp);
  (*info->fprintf_func) (info->stream, ")@@(%s", vmabuf);
  if (buf[0] != '\0')
    (*info->fprintf_func) (info->stream, ",%s", buf);
  (*info->fprintf_func) (info->stream, ")");

  return p;
}

/* Print a base register REGNO and displacement DISP, on INFO->STREAM.
   REGNO = -1 for pc, -2 for none (suppressed).  */

static void
print_base (regno, disp, info)
     int regno;
     bfd_vma disp;
     disassemble_info *info;
{
  if (regno == -1)
    {
      (*info->fprintf_func) (info->stream, "%%pc@@(");
      (*info->print_address_func) (disp, info);
    }
  else
    {
      char buf[50];

      if (regno == -2)
	(*info->fprintf_func) (info->stream, "@@(");
      else if (regno == -3)
	(*info->fprintf_func) (info->stream, "%%zpc@@(");
      else
	(*info->fprintf_func) (info->stream, "%s@@(", reg_names[regno]);

      sprintf_vma (buf, disp);
      (*info->fprintf_func) (info->stream, "%s", buf);
    }
}
@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002
d6 13
a18 13
This file is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d266 3
d348 1
a348 1
  
d412 1
a412 1
  
d415 1
a415 1
  /* We can the operands twice.  The first time we don't print anything,
d543 3
d552 1
d579 8
d742 1
a742 1
      
d766 4
a769 1

d1044 1
a1044 1
	
d1055 1
a1055 1
	
d1142 1
a1142 1
      
d1159 1
a1159 1
    case 'm': 
d1165 1
a1165 1
    case 'n': 
@


1.3
log
@resolve conflicts.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001
d23 1
a23 1
#include <libiberty.h>
d40 1
a40 1
print_base PARAMS ((int, bfd_vma, disassemble_info*));
d49 1
a49 2
CONST char * CONST fpcr_names[] =
  {
d52 1
a52 1
  };
d54 1
a54 2
static char *const reg_names[] =
  {
d58 1
a58 1
  };
d62 1
a62 1
#define COERCE_SIGNED_CHAR(ch) ((signed char)(ch))
d64 1
a64 1
#define COERCE_SIGNED_CHAR(ch) ((int)(((ch) ^ 0x80) & 0xFF) - 128)
a107 1

d114 1
a114 2
struct private
{
d126 1
a126 1
  ((addr) <= ((struct private *)(info->private_data))->max_fetched \
d155 2
a156 2
dummy_printer (FILE * file ATTRIBUTE_UNUSED,
	       const char * format ATTRIBUTE_UNUSED, ...)
d158 2
a159 1
dummy_printer (file) FILE *file ATTRIBUTE_UNUSED;
d161 3
a163 1
 { return 0; }
d190 1
a190 1
  void (*save_print_address) PARAMS((bfd_vma, struct disassemble_info*))
d358 1
a358 1
	  else if (p - buffer < 4 && d[1] != 'C' && d[1] != '8' )
d417 2
a418 2
  info->fprintf_func = (fprintf_ftype)dummy_printer;
  for ( ; *d; d += 2)
d427 5
a431 5
	  (*info->fprintf_func)(info->stream,
				/* xgettext:c-format */
				_("<internal error in opcode table: %s %s>\n"),
				best->name,
				best->args);
d481 1
a481 1
  register CONST char *regname;
d503 1
a503 1
	   reg_names [fetch_arg (buffer, place, 3, info) + 8]);
d627 1
a627 1
	(*info->fprintf_func) (info->stream, "%s", reg_names [val & 7]);
d652 1
a652 1
	  if ( val > 63 )		/* This is a signed constant. */
d686 1
a686 1
	disp = COERCE_SIGNED_CHAR(buffer[1]);
d820 1
a820 1
	      switch( place )
d838 1
a838 1
		  NEXTSINGLE(flval, p);
d842 1
a842 1
		  NEXTDOUBLE(flval, p);
d846 1
a846 1
		  NEXTEXTEND(flval, p);
d850 1
a850 1
		  flval = NEXTPACKED(p);
d856 1
a856 1
	      if ( flt_p )	/* Print a float? */
d1208 1
a1208 1
  static char *const scales[] = {"", ":2", ":4", ":8"};
@


1.2
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright 1986, 87, 89, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d49 12
a60 8
CONST char * CONST fpcr_names[] = {
  "", "%fpiar", "%fpsr", "%fpiar/%fpsr", "%fpcr",
  "%fpiar/%fpcr", "%fpsr/%fpcr", "%fpiar/%fpsr/%fpcr"};

static char *const reg_names[] = {
  "%d0", "%d1", "%d2", "%d3", "%d4", "%d5", "%d6", "%d7",
  "%a0", "%a1", "%a2", "%a3", "%a4", "%a5", "%fp", "%sp",
  "%ps", "%pc"};
d159 2
a160 1
dummy_printer (FILE * file, const char * format, ...)
d162 1
a162 1
dummy_printer (file) FILE *file;
d168 2
a169 2
     bfd_vma vma;
     struct disassemble_info *info;
d186 1
a186 1
  const struct m68k_opcode *best = 0;
d236 1
d264 12
d340 1
a340 1
  if (best == 0)
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
   Copyright 1986, 1987, 1989, 1991, 1992, 1993 Free Software Foundation, Inc.
d19 1
d22 2
d30 6
d74 1
a74 1
#define COERCE32(x) ((int) (((x) ^ 0x80000000) - 0x80000000))
d79 4
a82 8
/* NEXTSINGLE and NEXTDOUBLE handle alignment problems, but not
 * byte-swapping or other float format differences.  FIXME! */

union number {
    double d;
    float f;
    char c[10];
};
d84 1
d86 2
a87 4
  { unsigned int i; union number u;\
    FETCH_DATA (info, p + sizeof (float));\
    for (i = 0; i < sizeof(float); i++) u.c[i] = *p++; \
    val = u.f; }
d89 1
d91 2
a92 4
  { unsigned int i; union number u;\
    FETCH_DATA (info, p + sizeof (double));\
    for (i = 0; i < sizeof(double); i++) u.c[i] = *p++; \
    val = u.d; }
d94 4
a97 3
/* Need a function to convert from extended to double precision... */
#define NEXTEXTEND(p) \
  (p += 12, FETCH_DATA (info, p), 0.0)
d160 1
a160 1
void
d181 1
d187 30
d219 5
d230 31
d263 2
a264 1
  for (i = 0; i < m68k_numopcodes; i++)
d266 1
a266 1
      const struct m68k_opcode *opc = &m68k_opcodes[i];
d278 2
a279 1
	      ))
d367 3
a369 3
  /* Some opcodes like pflusha and lpstop are exceptions; they take no
     arguments but are two words long.  Recognize them by looking at
     the lower 16 bits of the mask.  */
d372 18
a389 1
  
d402 1
a402 1
      int eaten = print_insn_arg (d, buffer, p, memaddr + p - buffer, info);
d410 2
a411 1
				"<internal error in opcode table: %s %s>\n",
d431 1
a431 1
      p += print_insn_arg (d, buffer, p, memaddr + p - buffer, info);
d467 2
d491 2
a492 2
        val = NEXTLONG (p);
	(*info->print_address_func) (val, info);
d508 12
d527 1
a527 1
	     {"%msp", 0x803}, {"%ibsp", 0x804},
d555 13
a567 4
      val = fetch_arg (buffer, place, 8, info);
      if (val & 0x80)
	val = val - 0x100;
      (*info->fprintf_func) (info->stream, "#%d", val);
d666 1
a666 1
	val = NEXTBYTE (p);
d668 1
a668 1
	val = COERCE_SIGNED_CHAR(buffer[1]);
d670 1
a670 1
	val = NEXTWORD (p);
d672 1
a672 1
	val = NEXTLONG (p);
d675 5
a679 5
	  val = NEXTBYTE (buffer);
	  if (val == 0)
	    val = NEXTWORD (p);
	  else if (val == -1)
	    val = NEXTLONG (p);
d684 1
a684 1
	    val = NEXTLONG (p);
d686 1
a686 1
	    val = NEXTWORD (p);
d691 1
a691 1
      (*info->print_address_func) (addr + val, info);
d698 1
a698 1
	 reg_names[fetch_arg (buffer, place, 3, info)], val);
a723 1
    case '`':
d725 8
d785 2
a786 2
	      val = NEXTLONG (p);
	      (*info->print_address_func) (val, info);
d791 1
d793 1
d828 1
a828 4
		  FETCH_DATA (info, p + 12);
		  floatformat_to_double (&floatformat_m68881_ext,
					 (char *) p, &flval);
		  p += 12;
d988 2
a989 1
	  (*info->fprintf_func) (info->stream, "<function code %d>", fc);
d1004 16
d1123 26
d1155 2
d1209 3
a1211 3
      word &= 0xff;
      if ((word & 0x80) != 0)
	word -= 0x100;
d1213 2
a1214 2
	word += addr;
      print_base (basereg, word, info);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 2
   Copyright 1986, 87, 89, 91, 92, 93, 94, 95, 96, 1997
   Free Software Foundation, Inc.
a19 1
#include <libiberty.h>
a25 6
fetch_data PARAMS ((struct disassemble_info *, bfd_byte *));

static void
dummy_print_address PARAMS ((bfd_vma, struct disassemble_info *));

static int
d69 9
a77 1
/* Get a single precision float.  */
d79 4
a82 2
  (p += 4, FETCH_DATA (info, p), \
   floatformat_to_double (&floatformat_ieee_single_big, (char *) p - 4, &val))
a83 1
/* Get a double precision float.  */
d85 4
a88 2
  (p += 8, FETCH_DATA (info, p), \
   floatformat_to_double (&floatformat_ieee_double_big, (char *) p - 8, &val))
d90 3
a92 4
/* Get an extended precision float.  */
#define NEXTEXTEND(val, p) \
  (p += 12, FETCH_DATA (info, p), \
   floatformat_to_double (&floatformat_m68881_ext, (char *) p - 12, &val))
d155 1
a155 1
static void
a180 30
  int major_opcode;
  static int numopcodes[16];
  static const struct m68k_opcode **opcodes[16];

  if (!opcodes[0])
    {
      /* Speed up the matching by sorting the opcode table on the upper
	 four bits of the opcode.  */
      const struct m68k_opcode **opc_pointer[16];

      /* First count how many opcodes are in each of the sixteen buckets.  */
      for (i = 0; i < m68k_numopcodes; i++)
	numopcodes[(m68k_opcodes[i].opcode >> 28) & 15]++;

      /* Then create a sorted table of pointers that point into the
	 unsorted table.  */
      opc_pointer[0] = ((const struct m68k_opcode **)
			xmalloc (sizeof (struct m68k_opcode *)
				 * m68k_numopcodes));
      opcodes[0] = opc_pointer[0];
      for (i = 1; i < 16; i++)
	{
	  opc_pointer[i] = opc_pointer[i - 1] + numopcodes[i - 1];
	  opcodes[i] = opc_pointer[i];
	}

      for (i = 0; i < m68k_numopcodes; i++)
	*opc_pointer[(m68k_opcodes[i].opcode >> 28) & 15]++ = &m68k_opcodes[i];

    }
a182 5
  /* Tell objdump to use two bytes per chunk and six bytes per line for
     displaying raw data.  */
  info->bytes_per_chunk = 2;
  info->bytes_per_line = 6;
  info->display_endian = BFD_ENDIAN_BIG;
d191 1
a191 2
  major_opcode = (buffer[0] >> 4) & 15;
  for (i = 0; i < numopcodes[major_opcode]; i++)
d193 1
a193 1
      const struct m68k_opcode *opc = opcodes[major_opcode][i];
d421 1
a421 1
	     {"%msp", 0x803}, {"%isp", 0x804},
d583 1
a583 1
	 reg_names[fetch_arg (buffer, place, 3, info) + 8], val);
a610 2
    case '<':
    case '>':
d704 4
a707 1
		  NEXTEXTEND(flval, p);
@


1.1.1.3
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1986, 87, 89, 91, 92, 93, 94, 95, 96, 97, 98, 1999
a18 1
#include "sysdep.h"
a21 1
#include "opintl.h"
d72 1
a72 1
#define COERCE32(x) ((bfd_signed_vma) ((x) ^ 0x80000000) - 0x80000000)
a76 5
/* Get a 4 byte unsigned integer.  */
#define NEXTULONG(p)  \
  (p += 4, FETCH_DATA (info, p), \
   (unsigned int) ((((((p[-4] << 8) + p[-3]) << 8) + p[-2]) << 8) + p[-1]))

a173 1
  unsigned int arch_mask;
a221 31
  switch (info->mach)
    {
    default:
    case 0:
      arch_mask = (unsigned int) -1;
      break;
    case bfd_mach_m68000:
      arch_mask = m68000;
      break;
    case bfd_mach_m68008:
      arch_mask = m68008;
      break;
    case bfd_mach_m68010:
      arch_mask = m68010;
      break;
    case bfd_mach_m68020:
      arch_mask = m68020;
      break;
    case bfd_mach_m68030:
      arch_mask = m68030;
      break;
    case bfd_mach_m68040:
      arch_mask = m68040;
      break;
    case bfd_mach_m68060:
      arch_mask = m68060;
      break;
    }

  arch_mask |= m68881 | m68851;

d239 1
a239 2
	      )
	  && (opc->arch & arch_mask) != 0)
d327 3
a329 3

  /* pflusha is an exceptions.  It takes no arguments but is two words
     long.  Recognize it by looking at the lower 16 bits of the mask.  */
d332 1
a332 18

  /* lpstop is another exception.  It takes a one word argument but is
     three words long.  */
  if (p - buffer < 6
      && (best->match & 0xffff) == 0xffff
      && best->args[0] == '#'
      && best->args[1] == 'w')
    {
      /* Copy the one word argument into the usual location for a one
	 word argument, to simplify printing it.  We can get away with
	 this because we know exactly what the second word is, and we
	 aren't going to print anything based on it.  */
      p = buffer + 6;
      FETCH_DATA (info, p);
      buffer[2] = buffer[4];
      buffer[3] = buffer[5];
    }

d345 1
a345 1
      int eaten = print_insn_arg (d, buffer, p, memaddr + (p - buffer), info);
d353 1
a353 2
				/* xgettext:c-format */
				_("<internal error in opcode table: %s %s>\n"),
d373 1
a373 1
      p += print_insn_arg (d, buffer, p, memaddr + (p - buffer), info);
a408 2
  bfd_signed_vma disp;
  unsigned int uval;
d431 2
a432 2
        uval = NEXTULONG (p);
	(*info->print_address_func) (uval, info);
a447 12
    case 'E':
      (*info->fprintf_func) (info->stream, "%%acc");
      break;

    case 'G':
      (*info->fprintf_func) (info->stream, "%%macsr");
      break;

    case 'H':
      (*info->fprintf_func) (info->stream, "%%mask");
      break;

d483 4
a486 13
      if (place == 'h')
	{
	  static char *const scalefactor_name[] = { "<<", ">>" };
	  val = fetch_arg (buffer, place, 1, info);
	  (*info->fprintf_func) (info->stream, scalefactor_name[val]);
	}
      else
	{
	  val = fetch_arg (buffer, place, 8, info);
	  if (val & 0x80)
	    val = val - 0x100;
	  (*info->fprintf_func) (info->stream, "#%d", val);
	}
d585 1
a585 1
	disp = NEXTBYTE (p);
d587 1
a587 1
	disp = COERCE_SIGNED_CHAR(buffer[1]);
d589 1
a589 1
	disp = NEXTWORD (p);
d591 1
a591 1
	disp = NEXTLONG (p);
d594 5
a598 5
	  disp = NEXTBYTE (buffer);
	  if (disp == 0)
	    disp = NEXTWORD (p);
	  else if (disp == -1)
	    disp = NEXTLONG (p);
d603 1
a603 1
	    disp = NEXTLONG (p);
d605 1
a605 1
	    disp = NEXTWORD (p);
d610 1
a610 1
      (*info->print_address_func) (addr + disp, info);
d643 1
a646 6
    case 'm':
    case 'n':
    case 'o':
    case 'p':
    case 'q':
    case 'v':
d699 2
a700 2
	      uval = NEXTULONG (p);
	      (*info->print_address_func) (uval, info);
a704 1
	      (*info->fprintf_func) (info->stream, "%%pc@@(");
a705 1
	      (*info->fprintf_func) (info->stream, ")");
d900 1
a900 2
	  /* xgettext:c-format */
	  (*info->fprintf_func) (info->stream, _("<function code %d>"), fc);
a914 16
    case 'u':
      {
	short is_upper = 0;
	int reg = fetch_arg (buffer, place, 5, info);
	
	if (reg & 0x10)
	  {
	    is_upper = 1;
	    reg &= 0xf;
	  }
	(*info->fprintf_func) (info->stream, "%s%s",
			       reg_names[reg],
			       is_upper ? "u" : "l");
      }
      break;
	
a1017 26
    case 'm': 
      val = (buffer[1] & 0x40 ? 0x8 : 0)
	| ((buffer[0] >> 1) & 0x7)
	| (buffer[3] & 0x80 ? 0x10 : 0);
      break;

    case 'n': 
      val = (buffer[1] & 0x40 ? 0x8 : 0) | ((buffer[0] >> 1) & 0x7);
      break;

    case 'o':
      val = (buffer[2] >> 4) | (buffer[3] & 0x80 ? 0x10 : 0);
      break;

    case 'M':
      val = buffer[1] | (buffer[3] & 0x40 ? 0x10 : 0);
      break;

    case 'N':
      val = buffer[3] | (buffer[3] & 0x40 ? 0x10 : 0);
      break;

    case 'h':
      val = buffer[2] >> 2;
      break;

a1023 2
    case 1:
      return val & 1;
d1076 3
a1078 3
      base_disp = word & 0xff;
      if ((base_disp & 0x80) != 0)
	base_disp -= 0x100;
d1080 2
a1081 2
	base_disp += addr;
      print_base (basereg, base_disp, info);
@


1.1.1.4
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2001
d48 8
a55 12
CONST char * CONST fpcr_names[] =
  {
    "", "%fpiar", "%fpsr", "%fpiar/%fpsr", "%fpcr",
    "%fpiar/%fpcr", "%fpsr/%fpcr", "%fpiar/%fpsr/%fpcr"
  };

static char *const reg_names[] =
  {
    "%d0", "%d1", "%d2", "%d3", "%d4", "%d5", "%d6", "%d7",
    "%a0", "%a1", "%a2", "%a3", "%a4", "%a5", "%fp", "%sp",
    "%ps", "%pc"
  };
d154 1
a154 2
dummy_printer (FILE * file ATTRIBUTE_UNUSED,
	       const char * format ATTRIBUTE_UNUSED, ...)
d156 1
a156 1
dummy_printer (file) FILE *file ATTRIBUTE_UNUSED;
d162 2
a163 2
     bfd_vma vma ATTRIBUTE_UNUSED;
     struct disassemble_info *info ATTRIBUTE_UNUSED;
d180 1
a180 1
  const struct m68k_opcode *best;
a229 1
  best = NULL;
a256 12
    case bfd_mach_mcf5200:
      arch_mask = mcf5200;
      break;
    case bfd_mach_mcf5206e:
      arch_mask = mcf5206e;
      break;
    case bfd_mach_mcf5307:
      arch_mask = mcf5307;
      break;
    case bfd_mach_mcf5407:
      arch_mask = mcf5407;
      break;
d321 1
a321 1
  if (best == NULL)
@


1.1.1.5
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002
d23 1
a23 1
#include "libiberty.h"
d40 1
a40 1
print_base PARAMS ((int, bfd_vma, disassemble_info *));
d49 2
a50 1
const char * const fpcr_names[] = {
d53 1
a53 1
};
d55 2
a56 1
static char *const reg_names[] = {
d60 1
a60 1
};
d64 1
a64 1
#define COERCE_SIGNED_CHAR(ch) ((signed char) (ch))
d66 1
a66 1
#define COERCE_SIGNED_CHAR(ch) ((int) (((ch) ^ 0x80) & 0xFF) - 128)
d110 1
d117 2
a118 1
struct private {
d130 1
a130 1
  ((addr) <= ((struct private *) (info->private_data))->max_fetched \
d159 2
a160 2
dummy_printer (FILE *file ATTRIBUTE_UNUSED,
	       const char *format ATTRIBUTE_UNUSED, ...)
d162 1
a162 2
dummy_printer (file)
     FILE *file ATTRIBUTE_UNUSED;
d164 1
a164 3
{
  return 0;
}
d191 1
a191 1
  void (*save_print_address) PARAMS ((bfd_vma, struct disassemble_info *))
d359 1
a359 1
	  else if (p - buffer < 4 && d[1] != 'C' && d[1] != '8')
d418 2
a419 2
  info->fprintf_func = (fprintf_ftype) dummy_printer;
  for (; *d; d += 2)
d428 5
a432 5
	  (*info->fprintf_func) (info->stream,
				 /* xgettext:c-format */
				 _("<internal error in opcode table: %s %s>\n"),
				 best->name,
				 best->args);
d482 1
a482 1
  register const char *regname;
d504 1
a504 1
	   reg_names[fetch_arg (buffer, place, 3, info) + 8]);
d628 1
a628 1
	(*info->fprintf_func) (info->stream, "%s", reg_names[val & 7]);
d653 1
a653 1
	  if (val > 63)		/* This is a signed constant. */
d687 1
a687 1
	disp = COERCE_SIGNED_CHAR (buffer[1]);
d821 1
a821 1
	      switch (place)
d839 1
a839 1
		  NEXTSINGLE (flval, p);
d843 1
a843 1
		  NEXTDOUBLE (flval, p);
d847 1
a847 1
		  NEXTEXTEND (flval, p);
d851 1
a851 1
		  flval = NEXTPACKED (p);
d857 1
a857 1
	      if (flt_p)	/* Print a float? */
d1209 1
a1209 1
  static char *const scales[] = { "", ":2", ":4", ":8" };
@


1.1.1.6
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003
d6 13
a18 13
   This file is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a265 3
    case bfd_mach_mcf528x:
      arch_mask = mcf528x;
      break;
d345 1
a345 1

d409 1
a409 1

d412 1
a412 1
  /* We scan the operands twice.  The first time we don't print anything,
a539 3
	/* FIXME: There's a problem here, different m68k processors call the
	   same address different names. This table can't get it right
	   because it doesn't know which processor it's disassembling for.  */
a545 1
	     {"%flashbar", 0xc04}, {"%rambar", 0xc05}, /* mcf528x added these.  */
a571 8
    case 'x':
      val = fetch_arg (buffer, place, 3, info);
      /* 0 means -1.  */
      if (val == 0)
	val = -1;
      (*info->fprintf_func) (info->stream, "#%d", val);
      break;

d727 1
a727 1

d751 1
a751 4
    case 'b':
    case 'w':
    case 'y':
    case 'z':
d1026 1
a1026 1

d1037 1
a1037 1

d1124 1
a1124 1

d1141 1
a1141 1
    case 'm':
d1147 1
a1147 1
    case 'n':
@


