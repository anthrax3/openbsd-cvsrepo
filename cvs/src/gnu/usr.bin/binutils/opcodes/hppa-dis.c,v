head	1.4;
access;
symbols
	OPENBSD_6_1:1.4.0.52
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.50
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.46
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.48
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.40
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.44
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.42
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.38
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.36
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.34
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.32
	OPENBSD_5_0:1.4.0.30
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.28
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.26
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.22
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.24
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	BINUTILS_2_15:1.1.1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.2
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.05.17.21.54.55;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.44;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.19.12.59;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.01;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.01;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.47.53;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.56.31;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.44;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@/* Disassembler for the PA-RISC. Somewhat derived from sparc-pinsn.c.
   Copyright 1989, 1990, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2003
   Free Software Foundation, Inc.

   Contributed by the Center for Software Science at the
   University of Utah (pa-gdb-bugs@@cs.utah.edu).

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "sysdep.h"
#include "dis-asm.h"
#include "libhppa.h"
#include "opcode/hppa.h"

/* Integer register names, indexed by the numbers which appear in the
   opcodes.  */
static const char *const reg_names[] =
 {"flags", "r1", "rp", "r3", "r4", "r5", "r6", "r7", "r8", "r9",
  "r10", "r11", "r12", "r13", "r14", "r15", "r16", "r17", "r18", "r19",
  "r20", "r21", "r22", "r23", "r24", "r25", "r26", "dp", "ret0", "ret1",
  "sp", "r31"};

/* Floating point register names, indexed by the numbers which appear in the
   opcodes.  */
static const char *const fp_reg_names[] =
 {"fpsr", "fpe2", "fpe4", "fpe6",
  "fr4", "fr5", "fr6", "fr7", "fr8",
  "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
  "fr16", "fr17", "fr18", "fr19", "fr20", "fr21", "fr22", "fr23",
  "fr24", "fr25", "fr26", "fr27", "fr28", "fr29", "fr30", "fr31"};

typedef unsigned int CORE_ADDR;

/* Get at various relevent fields of an instruction word.  */

#define MASK_5 0x1f
#define MASK_10 0x3ff
#define MASK_11 0x7ff
#define MASK_14 0x3fff
#define MASK_16 0xffff
#define MASK_21 0x1fffff

/* These macros get bit fields using HP's numbering (MSB = 0) */

#define GET_FIELD(X, FROM, TO) \
  ((X) >> (31 - (TO)) & ((1 << ((TO) - (FROM) + 1)) - 1))

#define GET_BIT(X, WHICH) \
  GET_FIELD (X, WHICH, WHICH)

/* Some of these have been converted to 2-d arrays because they
   consume less storage this way.  If the maintenance becomes a
   problem, convert them back to const 1-d pointer arrays.  */
static const char *const control_reg[] = {
  "rctr", "cr1", "cr2", "cr3", "cr4", "cr5", "cr6", "cr7",
  "pidr1", "pidr2", "ccr", "sar", "pidr3", "pidr4",
  "iva", "eiem", "itmr", "pcsq", "pcoq", "iir", "isr",
  "ior", "ipsw", "eirr", "tr0", "tr1", "tr2", "tr3",
  "tr4", "tr5", "tr6", "tr7"
};

static const char *const compare_cond_names[] = {
  "", ",=", ",<", ",<=", ",<<", ",<<=", ",sv", ",od",
  ",tr", ",<>", ",>=", ",>", ",>>=", ",>>", ",nsv", ",ev"
};
static const char *const compare_cond_64_names[] = {
  "", ",*=", ",*<", ",*<=", ",*<<", ",*<<=", ",*sv", ",*od",
  ",*tr", ",*<>", ",*>=", ",*>", ",*>>=", ",*>>", ",*nsv", ",*ev"
};
static const char *const cmpib_cond_64_names[] = {
  ",*<<", ",*=", ",*<", ",*<=", ",*>>=", ",*<>", ",*>=", ",*>"
};
static const char *const add_cond_names[] = {
  "", ",=", ",<", ",<=", ",nuv", ",znv", ",sv", ",od",
  ",tr", ",<>", ",>=", ",>", ",uv", ",vnz", ",nsv", ",ev"
};
static const char *const add_cond_64_names[] = {
  "", ",*=", ",*<", ",*<=", ",*nuv", ",*znv", ",*sv", ",*od",
  ",*tr", ",*<>", ",*>=", ",*>", ",*uv", ",*vnz", ",*nsv", ",*ev"
};
static const char *const wide_add_cond_names[] = {
  "", ",=", ",<", ",<=", ",nuv", ",*=", ",*<", ",*<=",
  ",tr", ",<>", ",>=", ",>", ",uv", ",*<>", ",*>=", ",*>"
};
static const char *const logical_cond_names[] = {
  "", ",=", ",<", ",<=", 0, 0, 0, ",od",
  ",tr", ",<>", ",>=", ",>", 0, 0, 0, ",ev"};
static const char *const logical_cond_64_names[] = {
  "", ",*=", ",*<", ",*<=", 0, 0, 0, ",*od",
  ",*tr", ",*<>", ",*>=", ",*>", 0, 0, 0, ",*ev"};
static const char *const unit_cond_names[] = {
  "", ",swz", ",sbz", ",shz", ",sdc", ",swc", ",sbc", ",shc",
  ",tr", ",nwz", ",nbz", ",nhz", ",ndc", ",nwc", ",nbc", ",nhc"
};
static const char *const unit_cond_64_names[] = {
  "", ",*swz", ",*sbz", ",*shz", ",*sdc", ",*swc", ",*sbc", ",*shc",
  ",*tr", ",*nwz", ",*nbz", ",*nhz", ",*ndc", ",*nwc", ",*nbc", ",*nhc"
};
static const char *const shift_cond_names[] = {
  "", ",=", ",<", ",od", ",tr", ",<>", ",>=", ",ev"
};
static const char *const shift_cond_64_names[] = {
  "", ",*=", ",*<", ",*od", ",*tr", ",*<>", ",*>=", ",*ev"
};
static const char *const bb_cond_64_names[] = {
  ",*<", ",*>="
};
static const char *const index_compl_names[] = {"", ",m", ",s", ",sm"};
static const char *const short_ldst_compl_names[] = {"", ",ma", "", ",mb"};
static const char *const short_bytes_compl_names[] = {
  "", ",b,m", ",e", ",e,m"
};
static const char *const float_format_names[] = {",sgl", ",dbl", "", ",quad"};
static const char *const fcnv_fixed_names[] = {",w", ",dw", "", ",qw"};
static const char *const fcnv_ufixed_names[] = {",uw", ",udw", "", ",uqw"};
static const char *const float_comp_names[] =
{
  ",false?", ",false", ",?", ",!<=>", ",=", ",=t", ",?=", ",!<>",
  ",!?>=", ",<", ",?<", ",!>=", ",!?>", ",<=", ",?<=", ",!>",
  ",!?<=", ",>", ",?>", ",!<=", ",!?<", ",>=", ",?>=", ",!<",
  ",!?=", ",<>", ",!=", ",!=t", ",!?", ",<=>", ",true?", ",true"
};
static const char *const signed_unsigned_names[] = {",u", ",s"};
static const char *const mix_half_names[] = {",l", ",r"};
static const char *const saturation_names[] = {",us", ",ss", 0, ""};
static const char *const read_write_names[] = {",r", ",w"};
static const char *const add_compl_names[] = { 0, "", ",l", ",tsv" };

/* For a bunch of different instructions form an index into a
   completer name table.  */
#define GET_COMPL(insn) (GET_FIELD (insn, 26, 26) | \
			 GET_FIELD (insn, 18, 18) << 1)

#define GET_COND(insn) (GET_FIELD ((insn), 16, 18) + \
			(GET_FIELD ((insn), 19, 19) ? 8 : 0))

static void fput_reg PARAMS ((unsigned int, disassemble_info *));
static void fput_fp_reg PARAMS ((unsigned int, disassemble_info *));
static void fput_fp_reg_r PARAMS ((unsigned int, disassemble_info *));
static void fput_creg PARAMS ((unsigned int, disassemble_info *));
static void fput_const PARAMS ((unsigned int, disassemble_info *));
static int extract_3 PARAMS ((unsigned int));
static int extract_5_load PARAMS ((unsigned int));
static int extract_5_store PARAMS ((unsigned int));
static unsigned extract_5r_store PARAMS ((unsigned int));
static unsigned extract_5R_store PARAMS ((unsigned int));
static unsigned extract_10U_store PARAMS ((unsigned int));
static unsigned extract_5Q_store PARAMS ((unsigned int));
static int extract_11 PARAMS ((unsigned int));
static int extract_14 PARAMS ((unsigned int));
static int extract_16 PARAMS ((unsigned int));
static int extract_21 PARAMS ((unsigned int));
static int extract_12 PARAMS ((unsigned int));
static int extract_17 PARAMS ((unsigned int));
static int extract_22 PARAMS ((unsigned int));

/* Utility function to print registers.  Put these first, so gcc's function
   inlining can do its stuff.  */

#define fputs_filtered(STR,F)	(*info->fprintf_func) (info->stream, "%s", STR)

static void
fput_reg (reg, info)
     unsigned reg;
     disassemble_info *info;
{
  (*info->fprintf_func) (info->stream, reg ? reg_names[reg] : "r0");
}

static void
fput_fp_reg (reg, info)
     unsigned reg;
     disassemble_info *info;
{
  (*info->fprintf_func) (info->stream, reg ? fp_reg_names[reg] : "fr0");
}

static void
fput_fp_reg_r (reg, info)
     unsigned reg;
     disassemble_info *info;
{
  /* Special case floating point exception registers.  */
  if (reg < 4)
    (*info->fprintf_func) (info->stream, "fpe%d", reg * 2 + 1);
  else
    (*info->fprintf_func) (info->stream, "%sR",
			   reg ? fp_reg_names[reg] : "fr0");
}

static void
fput_creg (reg, info)
     unsigned reg;
     disassemble_info *info;
{
  (*info->fprintf_func) (info->stream, control_reg[reg]);
}

/* Print constants with sign.  */

static void
fput_const (num, info)
     unsigned num;
     disassemble_info *info;
{
  if ((int)num < 0)
    (*info->fprintf_func) (info->stream, "-%x", -(int)num);
  else
    (*info->fprintf_func) (info->stream, "%x", num);
}

/* Routines to extract various sized constants out of hppa
   instructions.  */

/* Extract a 3-bit space register number from a be, ble, mtsp or mfsp.  */
static int
extract_3 (word)
     unsigned word;
{
  return GET_FIELD (word, 18, 18) << 2 | GET_FIELD (word, 16, 17);
}

static int
extract_5_load (word)
     unsigned word;
{
  return low_sign_extend (word >> 16 & MASK_5, 5);
}

/* Extract the immediate field from a st{bhw}s instruction.  */
static int
extract_5_store (word)
     unsigned word;
{
  return low_sign_extend (word & MASK_5, 5);
}

/* Extract the immediate field from a break instruction.  */
static unsigned
extract_5r_store (word)
     unsigned word;
{
  return (word & MASK_5);
}

/* Extract the immediate field from a {sr}sm instruction.  */
static unsigned
extract_5R_store (word)
     unsigned word;
{
  return (word >> 16 & MASK_5);
}

/* Extract the 10 bit immediate field from a {sr}sm instruction.  */
static unsigned
extract_10U_store (word)
     unsigned word;
{
  return (word >> 16 & MASK_10);
}

/* Extract the immediate field from a bb instruction.  */
static unsigned
extract_5Q_store (word)
     unsigned word;
{
  return (word >> 21 & MASK_5);
}

/* Extract an 11 bit immediate field.  */
static int
extract_11 (word)
     unsigned word;
{
  return low_sign_extend (word & MASK_11, 11);
}

/* Extract a 14 bit immediate field.  */
static int
extract_14 (word)
     unsigned word;
{
  return low_sign_extend (word & MASK_14, 14);
}

/* Extract a 16 bit immediate field (PA2.0 wide only).  */
static int
extract_16 (word)
     unsigned word;
{
  int m15, m0, m1;
  m0 = GET_BIT (word, 16);
  m1 = GET_BIT (word, 17);
  m15 = GET_BIT (word, 31);
  word = (word >> 1) & 0x1fff;
  word = word | (m15 << 15) | ((m15 ^ m0) << 14) | ((m15 ^ m1) << 13);
  return sign_extend (word, 16);
}

/* Extract a 21 bit constant.  */

static int
extract_21 (word)
     unsigned word;
{
  int val;

  word &= MASK_21;
  word <<= 11;
  val = GET_FIELD (word, 20, 20);
  val <<= 11;
  val |= GET_FIELD (word, 9, 19);
  val <<= 2;
  val |= GET_FIELD (word, 5, 6);
  val <<= 5;
  val |= GET_FIELD (word, 0, 4);
  val <<= 2;
  val |= GET_FIELD (word, 7, 8);
  return sign_extend (val, 21) << 11;
}

/* Extract a 12 bit constant from branch instructions.  */

static int
extract_12 (word)
     unsigned word;
{
  return sign_extend (GET_FIELD (word, 19, 28) |
		      GET_FIELD (word, 29, 29) << 10 |
		      (word & 0x1) << 11, 12) << 2;
}

/* Extract a 17 bit constant from branch instructions, returning the
   19 bit signed value.  */

static int
extract_17 (word)
     unsigned word;
{
  return sign_extend (GET_FIELD (word, 19, 28) |
		      GET_FIELD (word, 29, 29) << 10 |
		      GET_FIELD (word, 11, 15) << 11 |
		      (word & 0x1) << 16, 17) << 2;
}

static int
extract_22 (word)
     unsigned word;
{
  return sign_extend (GET_FIELD (word, 19, 28) |
		      GET_FIELD (word, 29, 29) << 10 |
		      GET_FIELD (word, 11, 15) << 11 |
		      GET_FIELD (word, 6, 10) << 16 |
		      (word & 0x1) << 21, 22) << 2;
}

/* Print one instruction.  */
int
print_insn_hppa (memaddr, info)
     bfd_vma memaddr;
     disassemble_info *info;
{
  bfd_byte buffer[4];
  unsigned int insn, i;

  {
    int status =
      (*info->read_memory_func) (memaddr, buffer, sizeof (buffer), info);
    if (status != 0)
      {
	(*info->memory_error_func) (status, memaddr, info);
	return -1;
      }
  }

  insn = bfd_getb32 (buffer);

  for (i = 0; i < NUMOPCODES; ++i)
    {
      const struct pa_opcode *opcode = &pa_opcodes[i];
      if ((insn & opcode->mask) == opcode->match)
	{
	  register const char *s;
#ifndef BFD64
	  if (opcode->arch == pa20w)
	    continue;
#endif
	  (*info->fprintf_func) (info->stream, "%s", opcode->name);

	  if (!strchr ("cfCY?-+nHNZFIuv{", opcode->args[0]))
	    (*info->fprintf_func) (info->stream, " ");
	  for (s = opcode->args; *s != '\0'; ++s)
	    {
	      switch (*s)
		{
		case 'x':
		  fput_reg (GET_FIELD (insn, 11, 15), info);
		  break;
		case 'a':
		case 'b':
		  fput_reg (GET_FIELD (insn, 6, 10), info);
		  break;
		case '^':
		  fput_creg (GET_FIELD (insn, 6, 10), info);
		  break;
		case 't':
		  fput_reg (GET_FIELD (insn, 27, 31), info);
		  break;

		  /* Handle floating point registers.  */
		case 'f':
		  switch (*++s)
		    {
		    case 't':
		      fput_fp_reg (GET_FIELD (insn, 27, 31), info);
		      break;
		    case 'T':
		      if (GET_FIELD (insn, 25, 25))
			fput_fp_reg_r (GET_FIELD (insn, 27, 31), info);
		      else
			fput_fp_reg (GET_FIELD (insn, 27, 31), info);
		      break;
		    case 'a':
		      if (GET_FIELD (insn, 25, 25))
			fput_fp_reg_r (GET_FIELD (insn, 6, 10), info);
		      else
			fput_fp_reg (GET_FIELD (insn, 6, 10), info);
		      break;

		      /* 'fA' will not generate a space before the regsiter
			 name.  Normally that is fine.  Except that it
			 causes problems with xmpyu which has no FP format
			 completer.  */
		    case 'X':
		      fputs_filtered (" ", info);
		      /* FALLTHRU */

		    case 'A':
		      if (GET_FIELD (insn, 24, 24))
			fput_fp_reg_r (GET_FIELD (insn, 6, 10), info);
		      else
			fput_fp_reg (GET_FIELD (insn, 6, 10), info);
		      break;
		    case 'b':
		      if (GET_FIELD (insn, 25, 25))
			fput_fp_reg_r (GET_FIELD (insn, 11, 15), info);
		      else
			fput_fp_reg (GET_FIELD (insn, 11, 15), info);
		      break;
		    case 'B':
		      if (GET_FIELD (insn, 19, 19))
			fput_fp_reg_r (GET_FIELD (insn, 11, 15), info);
		      else
			fput_fp_reg (GET_FIELD (insn, 11, 15), info);
		      break;
		    case 'C':
		      {
			int reg = GET_FIELD (insn, 21, 22);
			reg |= GET_FIELD (insn, 16, 18) << 2;
			if (GET_FIELD (insn, 23, 23) != 0)
			  fput_fp_reg_r (reg, info);
			else
			  fput_fp_reg (reg, info);
			break;
		      }
		    case 'i':
		      {
			int reg = GET_FIELD (insn, 6, 10);

			reg |= (GET_FIELD (insn, 26, 26) << 4);
			fput_fp_reg (reg, info);
			break;
		      }
		    case 'j':
		      {
			int reg = GET_FIELD (insn, 11, 15);

			reg |= (GET_FIELD (insn, 26, 26) << 4);
			fput_fp_reg (reg, info);
			break;
		      }
		    case 'k':
		      {
			int reg = GET_FIELD (insn, 27, 31);

			reg |= (GET_FIELD (insn, 26, 26) << 4);
			fput_fp_reg (reg, info);
			break;
		      }
		    case 'l':
		      {
			int reg = GET_FIELD (insn, 21, 25);

			reg |= (GET_FIELD (insn, 26, 26) << 4);
			fput_fp_reg (reg, info);
			break;
		      }
		    case 'm':
		      {
			int reg = GET_FIELD (insn, 16, 20);

			reg |= (GET_FIELD (insn, 26, 26) << 4);
			fput_fp_reg (reg, info);
			break;
		      }

		      /* 'fe' will not generate a space before the register
			 name.  Normally that is fine.  Except that it
			 causes problems with fstw fe,y(b) which has no FP
			 format completer.  */
		    case 'E':
		      fputs_filtered (" ", info);
		      /* FALLTHRU */

		    case 'e':
		      if (GET_FIELD (insn, 30, 30))
			fput_fp_reg_r (GET_FIELD (insn, 11, 15), info);
		      else
			fput_fp_reg (GET_FIELD (insn, 11, 15), info);
		      break;
		    case 'x':
		      fput_fp_reg (GET_FIELD (insn, 11, 15), info);
		      break;
		    }
		  break;

		case '5':
		  fput_const (extract_5_load (insn), info);
		  break;
		case 's':
		  {
		    int space = GET_FIELD (insn, 16, 17);
		    /* Zero means implicit addressing, not use of sr0.  */
		    if (space != 0)
		      (*info->fprintf_func) (info->stream, "sr%d", space);
		  }
		  break;

		case 'S':
		  (*info->fprintf_func) (info->stream, "sr%d",
					 extract_3 (insn));
		  break;

		  /* Handle completers.  */
		case 'c':
		  switch (*++s)
		    {
		    case 'x':
		      (*info->fprintf_func)
			(info->stream, "%s",
			 index_compl_names[GET_COMPL (insn)]);
		      break;
		    case 'X':
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 index_compl_names[GET_COMPL (insn)]);
		      break;
		    case 'm':
		      (*info->fprintf_func)
			(info->stream, "%s",
			 short_ldst_compl_names[GET_COMPL (insn)]);
		      break;
		    case 'M':
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 short_ldst_compl_names[GET_COMPL (insn)]);
		      break;
		    case 'A':
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 short_bytes_compl_names[GET_COMPL (insn)]);
		      break;
		    case 's':
		      (*info->fprintf_func)
			(info->stream, "%s",
			 short_bytes_compl_names[GET_COMPL (insn)]);
		      break;
		    case 'c':
		    case 'C':
		      switch (GET_FIELD (insn, 20, 21))
			{
			case 1:
			  (*info->fprintf_func) (info->stream, ",bc ");
			  break;
			case 2:
			  (*info->fprintf_func) (info->stream, ",sl ");
			  break;
			default:
			  (*info->fprintf_func) (info->stream, " ");
			}
		      break;
		    case 'd':
		      switch (GET_FIELD (insn, 20, 21))
			{
			case 1:
			  (*info->fprintf_func) (info->stream, ",co ");
			  break;
			default:
			  (*info->fprintf_func) (info->stream, " ");
			}
		      break;
		    case 'o':
		      (*info->fprintf_func) (info->stream, ",o");
		      break;
		    case 'g':
		      (*info->fprintf_func) (info->stream, ",gate");
		      break;
		    case 'p':
		      (*info->fprintf_func) (info->stream, ",l,push");
		      break;
		    case 'P':
		      (*info->fprintf_func) (info->stream, ",pop");
		      break;
		    case 'l':
		    case 'L':
		      (*info->fprintf_func) (info->stream, ",l");
		      break;
		    case 'w':
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 read_write_names[GET_FIELD (insn, 25, 25)]);
		      break;
		    case 'W':
		      (*info->fprintf_func) (info->stream, ",w");
		      break;
		    case 'r':
		      if (GET_FIELD (insn, 23, 26) == 5)
			(*info->fprintf_func) (info->stream, ",r");
		      break;
		    case 'Z':
		      if (GET_FIELD (insn, 26, 26))
			(*info->fprintf_func) (info->stream, ",m ");
		      else
			(*info->fprintf_func) (info->stream, " ");
		      break;
		    case 'i':
		      if (GET_FIELD (insn, 25, 25))
			(*info->fprintf_func) (info->stream, ",i");
		      break;
		    case 'z':
		      if (!GET_FIELD (insn, 21, 21))
			(*info->fprintf_func) (info->stream, ",z");
		      break;
		    case 'a':
		      (*info->fprintf_func)
			(info->stream, "%s",
			 add_compl_names[GET_FIELD (insn, 20, 21)]);
		      break;
		    case 'Y':
		      (*info->fprintf_func)
			(info->stream, ",dc%s",
			 add_compl_names[GET_FIELD (insn, 20, 21)]);
		      break;
		    case 'y':
		      (*info->fprintf_func)
			(info->stream, ",c%s",
			 add_compl_names[GET_FIELD (insn, 20, 21)]);
		      break;
		    case 'v':
		      if (GET_FIELD (insn, 20, 20))
			(*info->fprintf_func) (info->stream, ",tsv");
		      break;
		    case 't':
		      (*info->fprintf_func) (info->stream, ",tc");
		      if (GET_FIELD (insn, 20, 20))
			(*info->fprintf_func) (info->stream, ",tsv");
		      break;
		    case 'B':
		      (*info->fprintf_func) (info->stream, ",db");
		      if (GET_FIELD (insn, 20, 20))
			(*info->fprintf_func) (info->stream, ",tsv");
		      break;
		    case 'b':
		      (*info->fprintf_func) (info->stream, ",b");
		      if (GET_FIELD (insn, 20, 20))
			(*info->fprintf_func) (info->stream, ",tsv");
		      break;
		    case 'T':
		      if (GET_FIELD (insn, 25, 25))
			(*info->fprintf_func) (info->stream, ",tc");
		      break;
		    case 'S':
		      /* EXTRD/W has a following condition.  */
		      if (*(s + 1) == '?')
			(*info->fprintf_func)
			  (info->stream, "%s",
			   signed_unsigned_names[GET_FIELD (insn, 21, 21)]);
		      else
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   signed_unsigned_names[GET_FIELD (insn, 21, 21)]);
		      break;
		    case 'h':
		      (*info->fprintf_func)
			(info->stream, "%s",
			 mix_half_names[GET_FIELD (insn, 17, 17)]);
		      break;
		    case 'H':
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 saturation_names[GET_FIELD (insn, 24, 25)]);
		      break;
		    case '*':
		      (*info->fprintf_func)
			(info->stream, ",%d%d%d%d ",
			 GET_FIELD (insn, 17, 18), GET_FIELD (insn, 20, 21),
			 GET_FIELD (insn, 22, 23), GET_FIELD (insn, 24, 25));
		      break;

		    case 'q':
		      {
			int m, a;

			m = GET_FIELD (insn, 28, 28);
			a = GET_FIELD (insn, 29, 29);

			if (m && !a)
			  fputs_filtered (",ma ", info);
			else if (m && a)
			  fputs_filtered (",mb ", info);
			else
			  fputs_filtered (" ", info);
			break;
		      }

		    case 'J':
		      {
			int opc = GET_FIELD (insn, 0, 5);

			if (opc == 0x16 || opc == 0x1e)
			  {
			    if (GET_FIELD (insn, 29, 29) == 0)
			      fputs_filtered (",ma ", info);
			    else
			      fputs_filtered (",mb ", info);
			  }
			else
			  fputs_filtered (" ", info);
			break;
		      }

		    case 'e':
		      {
			int opc = GET_FIELD (insn, 0, 5);

			if (opc == 0x13 || opc == 0x1b)
			  {
			    if (GET_FIELD (insn, 18, 18) == 1)
			      fputs_filtered (",mb ", info);
			    else
			      fputs_filtered (",ma ", info);
			  }
			else if (opc == 0x17 || opc == 0x1f)
			  {
			    if (GET_FIELD (insn, 31, 31) == 1)
			      fputs_filtered (",ma ", info);
			    else
			      fputs_filtered (",mb ", info);
			  }
			else
			  fputs_filtered (" ", info);

			break;
		      }
		    }
		  break;

		  /* Handle conditions.  */
		case '?':
		  {
		    s++;
		    switch (*s)
		      {
		      case 'f':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   float_comp_names[GET_FIELD (insn, 27, 31)]);
			break;

			/* these four conditions are for the set of instructions
			   which distinguish true/false conditions by opcode
			   rather than by the 'f' bit (sigh): comb, comib,
			   addb, addib */
		      case 't':
			fputs_filtered
			  (compare_cond_names[GET_FIELD (insn, 16, 18)], info);
			break;
		      case 'n':
			fputs_filtered
			  (compare_cond_names[GET_FIELD (insn, 16, 18)
					      + GET_FIELD (insn, 4, 4) * 8],
			   info);
			break;
		      case 'N':
			fputs_filtered
			  (compare_cond_64_names[GET_FIELD (insn, 16, 18)
						 + GET_FIELD (insn, 2, 2) * 8],
			   info);
			break;
		      case 'Q':
			fputs_filtered
			  (cmpib_cond_64_names[GET_FIELD (insn, 16, 18)],
			   info);
			break;
		      case '@@':
			fputs_filtered
			  (add_cond_names[GET_FIELD (insn, 16, 18)
					  + GET_FIELD (insn, 4, 4) * 8],
			   info);
			break;
		      case 's':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   compare_cond_names[GET_COND (insn)]);
			break;
		      case 'S':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   compare_cond_64_names[GET_COND (insn)]);
			break;
		      case 'a':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   add_cond_names[GET_COND (insn)]);
			break;
		      case 'A':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   add_cond_64_names[GET_COND (insn)]);
			break;
		      case 'd':
			(*info->fprintf_func)
			  (info->stream, "%s",
			   add_cond_names[GET_FIELD (insn, 16, 18)]);
			break;

		      case 'W':
			(*info->fprintf_func)
			  (info->stream, "%s",
			   wide_add_cond_names[GET_FIELD (insn, 16, 18) +
					       GET_FIELD (insn, 4, 4) * 8]);
			break;

		      case 'l':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   logical_cond_names[GET_COND (insn)]);
			break;
		      case 'L':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   logical_cond_64_names[GET_COND (insn)]);
			break;
		      case 'u':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   unit_cond_names[GET_COND (insn)]);
			break;
		      case 'U':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   unit_cond_64_names[GET_COND (insn)]);
			break;
		      case 'y':
		      case 'x':
		      case 'b':
			(*info->fprintf_func)
			  (info->stream, "%s",
			   shift_cond_names[GET_FIELD (insn, 16, 18)]);

			/* If the next character in args is 'n', it will handle
			   putting out the space.  */
			if (s[1] != 'n')
			  (*info->fprintf_func) (info->stream, " ");
			break;
		      case 'X':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   shift_cond_64_names[GET_FIELD (insn, 16, 18)]);
			break;
		      case 'B':
			(*info->fprintf_func)
			  (info->stream, "%s",
			   bb_cond_64_names[GET_FIELD (insn, 16, 16)]);

			/* If the next character in args is 'n', it will handle
			   putting out the space.  */
			if (s[1] != 'n')
			  (*info->fprintf_func) (info->stream, " ");
			break;
		      }
		    break;
		  }

		case 'V':
		  fput_const (extract_5_store (insn), info);
		  break;
		case 'r':
		  fput_const (extract_5r_store (insn), info);
		  break;
		case 'R':
		  fput_const (extract_5R_store (insn), info);
		  break;
		case 'U':
		  fput_const (extract_10U_store (insn), info);
		  break;
		case 'B':
		case 'Q':
		  fput_const (extract_5Q_store (insn), info);
		  break;
		case 'i':
		  fput_const (extract_11 (insn), info);
		  break;
		case 'j':
		  fput_const (extract_14 (insn), info);
		  break;
		case 'k':
		  fput_const (extract_21 (insn), info);
		  break;
		case '<':
		case 'l':
		  /* 16-bit long disp., PA2.0 wide only.  */
		  fput_const (extract_16 (insn), info);
		  break;
		case 'n':
		  if (insn & 0x2)
		    (*info->fprintf_func) (info->stream, ",n ");
		  else
		    (*info->fprintf_func) (info->stream, " ");
		  break;
		case 'N':
		  if ((insn & 0x20) && s[1])
		    (*info->fprintf_func) (info->stream, ",n ");
		  else if (insn & 0x20)
		    (*info->fprintf_func) (info->stream, ",n");
		  else if (s[1])
		    (*info->fprintf_func) (info->stream, " ");
		  break;
		case 'w':
		  (*info->print_address_func)
		    (memaddr + 8 + extract_12 (insn), info);
		  break;
		case 'W':
		  /* 17 bit PC-relative branch.  */
		  (*info->print_address_func)
		    ((memaddr + 8 + extract_17 (insn)), info);
		  break;
		case 'z':
		  /* 17 bit displacement.  This is an offset from a register
		     so it gets disasssembled as just a number, not any sort
		     of address.  */
		  fput_const (extract_17 (insn), info);
		  break;

		case 'Z':
		  /* addil %r1 implicit output.  */
		  (*info->fprintf_func) (info->stream, "%%r1");
		  break;

		case 'Y':
		  /* be,l %sr0,%r31 implicit output.  */
		  (*info->fprintf_func) (info->stream, "%%sr0,%%r31");
		  break;

		case '@@':
		  (*info->fprintf_func) (info->stream, "0");
		  break;

		case '.':
		  (*info->fprintf_func) (info->stream, "%d",
					 GET_FIELD (insn, 24, 25));
		  break;
		case '*':
		  (*info->fprintf_func) (info->stream, "%d",
					 GET_FIELD (insn, 22, 25));
		  break;
		case '!':
		  (*info->fprintf_func) (info->stream, "%%sar");
		  break;
		case 'p':
		  (*info->fprintf_func) (info->stream, "%d",
					 31 - GET_FIELD (insn, 22, 26));
		  break;
		case '~':
		  {
		    int num;
		    num = GET_FIELD (insn, 20, 20) << 5;
		    num |= GET_FIELD (insn, 22, 26);
		    (*info->fprintf_func) (info->stream, "%d", 63 - num);
		    break;
		  }
		case 'P':
		  (*info->fprintf_func) (info->stream, "%d",
					 GET_FIELD (insn, 22, 26));
		  break;
		case 'q':
		  {
		    int num;
		    num = GET_FIELD (insn, 20, 20) << 5;
		    num |= GET_FIELD (insn, 22, 26);
		    (*info->fprintf_func) (info->stream, "%d", num);
		    break;
		  }
		case 'T':
		  (*info->fprintf_func) (info->stream, "%d",
					 32 - GET_FIELD (insn, 27, 31));
		  break;
		case '%':
		  {
		    int num;
		    num = (GET_FIELD (insn, 23, 23) + 1) * 32;
		    num -= GET_FIELD (insn, 27, 31);
		    (*info->fprintf_func) (info->stream, "%d", num);
		    break;
		  }
		case '|':
		  {
		    int num;
		    num = (GET_FIELD (insn, 19, 19) + 1) * 32;
		    num -= GET_FIELD (insn, 27, 31);
		    (*info->fprintf_func) (info->stream, "%d", num);
		    break;
		  }
		case '$':
		  fput_const (GET_FIELD (insn, 20, 28), info);
		  break;
		case 'A':
		  fput_const (GET_FIELD (insn, 6, 18), info);
		  break;
		case 'D':
		  fput_const (GET_FIELD (insn, 6, 31), info);
		  break;
		case 'v':
		  (*info->fprintf_func) (info->stream, ",%d",
					 GET_FIELD (insn, 23, 25));
		  break;
		case 'O':
		  fput_const ((GET_FIELD (insn, 6,20) << 5 |
			       GET_FIELD (insn, 27, 31)), info);
		  break;
		case 'o':
		  fput_const (GET_FIELD (insn, 6, 20), info);
		  break;
		case '2':
		  fput_const ((GET_FIELD (insn, 6, 22) << 5 |
			       GET_FIELD (insn, 27, 31)), info);
		  break;
		case '1':
		  fput_const ((GET_FIELD (insn, 11, 20) << 5 |
			       GET_FIELD (insn, 27, 31)), info);
		  break;
		case '0':
		  fput_const ((GET_FIELD (insn, 16, 20) << 5 |
			       GET_FIELD (insn, 27, 31)), info);
		  break;
		case 'u':
		  (*info->fprintf_func) (info->stream, ",%d",
					 GET_FIELD (insn, 23, 25));
		  break;
		case 'F':
		  /* if no destination completer and not before a completer
		     for fcmp, need a space here */
		  if (s[1] == 'G' || s[1] == '?')
		    fputs_filtered
		      (float_format_names[GET_FIELD (insn, 19, 20)], info);
		  else
		    (*info->fprintf_func)
		      (info->stream, "%s ",
		       float_format_names[GET_FIELD (insn, 19, 20)]);
		  break;
		case 'G':
		  (*info->fprintf_func)
		    (info->stream, "%s ",
		     float_format_names[GET_FIELD (insn, 17, 18)]);
		  break;
		case 'H':
		  if (GET_FIELD (insn, 26, 26) == 1)
		    (*info->fprintf_func) (info->stream, "%s ",
					   float_format_names[0]);
		  else
		    (*info->fprintf_func) (info->stream, "%s ",
					   float_format_names[1]);
		  break;
		case 'I':
		  /* if no destination completer and not before a completer
		     for fcmp, need a space here */
		  if (s[1] == '?')
		    fputs_filtered
		      (float_format_names[GET_FIELD (insn, 20, 20)], info);
		  else
		    (*info->fprintf_func)
		      (info->stream, "%s ",
		       float_format_names[GET_FIELD (insn, 20, 20)]);
		  break;

		case 'J':
		  fput_const (extract_14 (insn), info);
		  break;

		case '#':
		  {
		    int sign = GET_FIELD (insn, 31, 31);
		    int imm10 = GET_FIELD (insn, 18, 27);
		    int disp;

		    if (sign)
		      disp = (-1 << 10) | imm10;
		    else
		      disp = imm10;

		    disp <<= 3;
		    fput_const (disp, info);
		    break;
		  }
		case 'K':
		case 'd':
		  {
		    int sign = GET_FIELD (insn, 31, 31);
		    int imm11 = GET_FIELD (insn, 18, 28);
		    int disp;

		    if (sign)
		      disp = (-1 << 11) | imm11;
		    else
		      disp = imm11;

		    disp <<= 2;
		    fput_const (disp, info);
		    break;
		  }

		case '>':
		case 'y':
		  {
		    /* 16-bit long disp., PA2.0 wide only.  */
		    int disp = extract_16 (insn);
		    disp &= ~3;
		    fput_const (disp, info);
		    break;
		  }

		case '&':
		  {
		    /* 16-bit long disp., PA2.0 wide only.  */
		    int disp = extract_16 (insn);
		    disp &= ~7;
		    fput_const (disp, info);
		    break;
		  }

		case '_':
		  break; /* Dealt with by '{' */

		case '{':
		  {
		    int sub = GET_FIELD (insn, 14, 16);
		    int df = GET_FIELD (insn, 17, 18);
		    int sf = GET_FIELD (insn, 19, 20);
		    const char * const * source = float_format_names;
		    const char * const * dest = float_format_names;
		    char *t = "";
		    if (sub == 4)
		      {
			fputs_filtered (",UND ", info);
			break;
		      }
		    if ((sub & 3) == 3)
		      t = ",t";
		    if ((sub & 3) == 1)
		      source = sub & 4 ? fcnv_ufixed_names : fcnv_fixed_names;
		    if (sub & 2)
		      dest = sub & 4 ? fcnv_ufixed_names : fcnv_fixed_names;

		    (*info->fprintf_func) (info->stream, "%s%s%s ",
					   t, source[sf], dest[df]);
		    break;
		  }

		case 'm':
		  {
		    int y = GET_FIELD (insn, 16, 18);

		    if (y != 1)
		      fput_const ((y ^ 1) - 1, info);
		  }
		  break;

		case 'h':
		  {
		    int cbit;

		    cbit = GET_FIELD (insn, 16, 18);

		    if (cbit > 0)
		      (*info->fprintf_func) (info->stream, ",%d", cbit - 1);
		    break;
		  }

		case '=':
		  {
		    int cond = GET_FIELD (insn, 27, 31);

		    if (cond == 0)
		      fputs_filtered (" ", info);
		    else if (cond == 1)
		      fputs_filtered ("acc ", info);
		    else if (cond == 2)
		      fputs_filtered ("rej ", info);
		    else if (cond == 5)
		      fputs_filtered ("acc8 ", info);
		    else if (cond == 6)
		      fputs_filtered ("rej8 ", info);
		    else if (cond == 9)
		      fputs_filtered ("acc6 ", info);
		    else if (cond == 13)
		      fputs_filtered ("acc4 ", info);
		    else if (cond == 17)
		      fputs_filtered ("acc2 ", info);
		    break;
		  }

		case 'X':
		  (*info->print_address_func)
		    (memaddr + 8 + extract_22 (insn), info);
		  break;
		case 'L':
		  fputs_filtered (",%r2", info);
		  break;
		default:
		  (*info->fprintf_func) (info->stream, "%c", *s);
		  break;
		}
	    }
	  return sizeof(insn);
	}
    }
  (*info->fprintf_func) (info->stream, "#%8x", insn);
  return sizeof(insn);
}
@


1.3
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1989, 1990, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001
d29 1
a29 1
static const char *const reg_names[] = 
d37 4
a40 4
static const char *const fp_reg_names[] = 
 {"fpsr", "fpe2", "fpe4", "fpe6", 
  "fr4", "fr5", "fr6", "fr7", "fr8", 
  "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15", 
d126 2
d141 1
a141 1
/* For a bunch of different instructions form an index into a 
d199 2
a200 2
    (*info->fprintf_func) (info->stream, "%sR", reg ? fp_reg_names[reg] 
						    : "fr0");
d341 2
a342 2
                      GET_FIELD (word, 29, 29) << 10 |
                      (word & 0x1) << 11, 12) << 2;
d353 3
a355 3
                      GET_FIELD (word, 29, 29) << 10 |
                      GET_FIELD (word, 11, 15) << 11 |
                      (word & 0x1) << 16, 17) << 2;
d363 4
a366 4
                      GET_FIELD (word, 29, 29) << 10 |
                      GET_FIELD (word, 11, 15) << 11 |
                      GET_FIELD (word, 6, 10) << 16 |
                      (word & 0x1) << 21, 22) << 2;
d402 1
a402 1
	  if (!strchr ("cfCY?-+nHNZFIuv", opcode->args[0]))
d422 1
a422 1
		/* Handle floating point registers.  */
d442 4
a445 4
		    /* 'fA' will not generate a space before the regsiter
			name.  Normally that is fine.  Except that it
			causes problems with xmpyu which has no FP format
			completer.  */
d448 1
a448 2

		    /* FALLTHRU */
a454 1
		      
d519 4
a522 4
		    /* 'fe' will not generate a space before the register
			name.  Normally that is fine.  Except that it
			causes problems with fstw fe,y(b) which has no FP
			format completer.  */
d525 1
a525 2

		    /* FALLTHRU */
d543 6
a548 2
		  (*info->fprintf_func) (info->stream,
					 "sr%d", GET_FIELD (insn, 16, 17));
d552 2
a553 1
		  (*info->fprintf_func) (info->stream, "sr%d", extract_3 (insn));
d556 1
a556 1
		/* Handle completers.  */
d561 8
a568 2
		      (*info->fprintf_func) (info->stream, "%s ",
					     index_compl_names[GET_COMPL (insn)]);
d571 13
a583 2
		      (*info->fprintf_func) (info->stream, "%s ",
					     short_ldst_compl_names[GET_COMPL (insn)]);
d586 3
a588 2
		      (*info->fprintf_func) (info->stream, "%s ",
					     short_bytes_compl_names[GET_COMPL (insn)]);
d631 3
a633 2
		      (*info->fprintf_func) (info->stream, "%s ",
					     read_write_names[GET_FIELD (insn, 25, 25)]);
d658 2
a659 2
			(info->stream, "%s", add_compl_names[GET_FIELD
							    (insn, 20, 21)]);
d663 2
a664 2
			(info->stream, ",dc%s", add_compl_names[GET_FIELD
							       (insn, 20, 21)]);
d668 2
a669 2
			(info->stream, ",c%s", add_compl_names[GET_FIELD
							      (insn, 20, 21)]);
d698 2
a699 2
			  (info->stream, "%s", signed_unsigned_names[GET_FIELD
								    (insn, 21, 21)]);
d702 2
a703 2
			  (info->stream, "%s ", signed_unsigned_names[GET_FIELD
								     (insn, 21, 21)]);
d707 2
a708 2
			  (info->stream, "%s", mix_half_names[GET_FIELD
							     (insn, 17, 17)]);
d712 2
a713 2
			  (info->stream, "%s", saturation_names[GET_FIELD
							       (insn, 24, 25)]);
d717 3
a719 3
			  (info->stream, ",%d%d%d%d ",
			   GET_FIELD (insn, 17, 18), GET_FIELD (insn, 20, 21),
			   GET_FIELD (insn, 22, 23), GET_FIELD (insn, 24, 25));
d780 1
a780 1
		/* Handle conditions.  */
d787 3
a789 3
			(*info->fprintf_func) (info->stream, "%s ",
					       float_comp_names[GET_FIELD
							       (insn, 27, 31)]);
d792 1
a792 1
		      /* these four conditions are for the set of instructions
d797 2
a798 2
			fputs_filtered (compare_cond_names[GET_FIELD (insn, 16, 18)],
					info);
d801 4
a804 2
			fputs_filtered (compare_cond_names[GET_FIELD (insn, 16, 18)
					+ GET_FIELD (insn, 4, 4) * 8], info);
d807 4
a810 2
			fputs_filtered (compare_cond_64_names[GET_FIELD (insn, 16, 18)
					+ GET_FIELD (insn, 2, 2) * 8], info);
d813 3
a815 2
			fputs_filtered (cmpib_cond_64_names[GET_FIELD (insn, 16, 18)],
					info);
d818 4
a821 2
			fputs_filtered (add_cond_names[GET_FIELD (insn, 16, 18)
					+ GET_FIELD (insn, 4, 4) * 8], info);
d824 3
a826 2
			(*info->fprintf_func) (info->stream, "%s ",
					       compare_cond_names[GET_COND (insn)]);
d829 3
a831 2
			(*info->fprintf_func) (info->stream, "%s ",
					       compare_cond_64_names[GET_COND (insn)]);
d834 3
a836 2
			(*info->fprintf_func) (info->stream, "%s ",
					       add_cond_names[GET_COND (insn)]);
d839 3
a841 2
			(*info->fprintf_func) (info->stream, "%s ",
					       add_cond_64_names[GET_COND (insn)]);
d844 3
a846 2
			(*info->fprintf_func) (info->stream, "%s",
					       add_cond_names[GET_FIELD (insn, 16, 18)]);
d850 1
a850 1
			(*info->fprintf_func) 
d852 2
a853 2
			   wide_add_cond_names[GET_FIELD (insn, 16, 18) + 
					      GET_FIELD (insn, 4, 4) * 8]);
d857 3
a859 2
			(*info->fprintf_func) (info->stream, "%s ",
					       logical_cond_names[GET_COND (insn)]);
d862 3
a864 2
			(*info->fprintf_func) (info->stream, "%s ",
					       logical_cond_64_names[GET_COND (insn)]);
d867 3
a869 2
			(*info->fprintf_func) (info->stream, "%s ",
					       unit_cond_names[GET_COND (insn)]);
d872 3
a874 2
			(*info->fprintf_func) (info->stream, "%s ",
					       unit_cond_64_names[GET_COND (insn)]);
d889 3
a891 2
			(*info->fprintf_func) (info->stream, "%s ",
					       shift_cond_64_names[GET_FIELD (insn, 16, 18)]);
d952 2
a953 2
		  (*info->print_address_func) (memaddr + 8 + extract_12 (insn),
					       info);
d957 2
a958 3
		  (*info->print_address_func) ((memaddr + 8 
						+ extract_17 (insn)),
					       info);
d976 1
a976 1
		  
d983 1
a983 1
				    GET_FIELD (insn, 24, 25));
d987 1
a987 1
				    GET_FIELD (insn, 22, 25));
d994 1
a994 1
				    31 - GET_FIELD (insn, 22, 26));
d1006 1
a1006 1
				    GET_FIELD (insn, 22, 26));
d1018 1
a1018 1
				    32 - GET_FIELD (insn, 27, 31));
d1046 2
a1047 1
		  (*info->fprintf_func) (info->stream, ",%d", GET_FIELD (insn, 23, 25));
d1069 2
a1070 1
		  (*info->fprintf_func) (info->stream, ",%d", GET_FIELD (insn, 23, 25));
d1076 2
a1077 2
		    fputs_filtered (float_format_names[GET_FIELD (insn, 19, 20)],
				    info);
d1079 3
a1081 3
		    (*info->fprintf_func) (info->stream, "%s ",
					   float_format_names[GET_FIELD
							      (insn, 19, 20)]);
d1084 3
a1086 3
		  (*info->fprintf_func) (info->stream, "%s ",
				    float_format_names[GET_FIELD (insn,
								  17, 18)]);
d1091 1
a1091 1
				    float_format_names[0]);
d1094 1
a1094 1
				    float_format_names[1]);
d1100 2
a1101 2
		    fputs_filtered (float_format_names[GET_FIELD (insn, 20, 20)],
				    info);
d1103 3
a1105 3
		    (*info->fprintf_func) (info->stream, "%s ",
					   float_format_names[GET_FIELD
							      (insn, 20, 20)]);
d1108 3
a1110 3
                case 'J':
                  fput_const (extract_14 (insn), info);
                  break;
d1127 1
a1127 1
                case 'K':
a1162 1
		/* ?!? FIXME */
d1164 2
d1167 23
a1189 2
		  fputs_filtered ("Disassembler botch.\n", info);
		  break;
d1235 2
a1236 3
		  (*info->print_address_func) ((memaddr + 8 
						+ extract_22 (insn)),
					       info);
@


1.2
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright 1989, 1990, 1992, 1993 Free Software Foundation, Inc.
d46 1
a46 1
/* Get at various relevent fields of an instruction word. */
d52 1
d55 1
a55 1
/* This macro gets bit fields using HP's numbering (MSB = 0) */
d60 3
d140 1
a140 1
   completer name table. */
d147 20
d209 1
a209 1
/* print constants with sign */
d223 1
a223 1
   instructions. */
d225 1
a225 1
/* extract a 3-bit space register number from a be, ble, mtsp or mfsp */
d240 1
a240 1
/* extract the immediate field from a st{bhw}s instruction */
d248 1
a248 1
/* extract the immediate field from a break instruction */
d256 1
a256 1
/* extract the immediate field from a {sr}sm instruction */
d264 1
a264 1
/* extract the 10 bit immediate field from a {sr}sm instruction */
d272 1
a272 1
/* extract the immediate field from a bb instruction */
d280 1
a280 1
/* extract an 11 bit immediate field */
d288 1
a288 1
/* extract a 14 bit immediate field */
d296 15
a310 1
/* extract a 21 bit constant */
d332 1
a332 1
/* extract a 12 bit constant from branch instructions */
d343 2
a344 2
/* extract a 17 bit constant from branch instructions, returning the
   19 bit signed value. */
d394 4
a397 1
	  
d518 10
d529 1
a529 1
		      if (GET_FIELD (insn, 25, 25))
d534 3
a536 1

d717 1
a717 1
			int opcode = GET_FIELD (insn, 0, 5);
d719 1
a719 1
			if (opcode == 0x16 || opcode == 0x1e)
d733 1
a733 1
			int opcode = GET_FIELD (insn, 0, 5);
d735 1
a735 1
			if (opcode == 0x13 || opcode == 0x1b)
d742 1
a742 1
			else if (opcode == 0x17 || opcode == 0x1f)
d892 5
d1099 19
@


1.1
log
@Initial revision
@
text
@a20 1
#include <ansidecl.h>
d48 1
d61 1
a61 1
static const char control_reg[][6] = {
d69 22
a90 9
static const char compare_cond_names[][5] = {
  "", ",=", ",<", ",<=", ",<<", ",<<=", ",sv",
  ",od", ",tr", ",<>", ",>=", ",>", ",>>=",
  ",>>", ",nsv", ",ev"
};
static const char add_cond_names[][5] = {
  "", ",=", ",<", ",<=", ",nuv", ",znv", ",sv",
  ",od", ",tr", ",<>", ",>=", ",>", ",uv",
  ",vnz", ",nsv", ",ev"
d95 3
d99 2
a100 2
  "", 0, ",sbz", ",shz", ",sdc", 0, ",sbc", ",shc",
  ",tr", 0, ",nbz", ",nhz", ",ndc", 0, ",nbc", ",nhc"
d102 5
a106 1
static const char shift_cond_names[][4] = {
d109 8
a116 2
static const char index_compl_names[][4] = {"", ",m", ",s", ",sm"};
static const char short_ldst_compl_names[][4] = {"", ",ma", "", ",mb"};
d121 1
a121 1
static const char float_comp_names[][8] =
d128 5
d239 8
d317 11
d358 1
a358 1
	  if (!strchr ("cfCY<?!@@-+&U>~nHNZFIMadu|", opcode->args[0]))
d367 1
a367 6
		case 'X':
                  if (GET_FIELD (insn, 25, 25))
		      fput_fp_reg_r (GET_FIELD (insn, 11, 15), info);
		  else
		      fput_fp_reg (GET_FIELD (insn, 11, 15), info);
		  break;
a373 6
		case 'E':
                  if (GET_FIELD (insn, 25, 25))
		      fput_fp_reg_r (GET_FIELD (insn, 6, 10), info);
		  else
		      fput_fp_reg (GET_FIELD (insn, 6, 10), info);
		  break;
d377 6
a382 4
		case 'v':
                  if (GET_FIELD (insn, 25, 25))
		      fput_fp_reg_r (GET_FIELD (insn, 27, 31), info);
		  else
d384 100
a484 38
		case 'y':
		  fput_fp_reg (GET_FIELD (insn, 27, 31), info);
		  break;
		case '4':
		  {
		    int reg = GET_FIELD (insn, 6, 10);

		    reg |= (GET_FIELD (insn, 26, 26) << 4);
		    fput_fp_reg (reg, info);
		    break;
		  }
		case '6':
		  {
		    int reg = GET_FIELD (insn, 11, 15);

		    reg |= (GET_FIELD (insn, 26, 26) << 4);
		    fput_fp_reg (reg, info);
		    break;
		  }
		case '7':
		  {
		    int reg = GET_FIELD (insn, 27, 31);

		    reg |= (GET_FIELD (insn, 26, 26) << 4);
		    fput_fp_reg (reg, info);
		    break;
		  }
		case '8':
		  {
		    int reg = GET_FIELD (insn, 16, 20);

		    reg |= (GET_FIELD (insn, 26, 26) << 4);
		    fput_fp_reg (reg, info);
		    break;
		  }
		case '9':
		  {
		    int reg = GET_FIELD (insn, 21, 25);
a485 4
		    reg |= (GET_FIELD (insn, 26, 26) << 4);
		    fput_fp_reg (reg, info);
		    break;
		  }
d493 1
d497 2
d500 201
a700 17
		  (*info->fprintf_func) (info->stream, "%s ",
				    index_compl_names[GET_COMPL (insn)]);
		  break;
		case 'C':
		  (*info->fprintf_func) (info->stream, "%s ",
				    short_ldst_compl_names[GET_COMPL (insn)]);
		  break;
		case 'Y':
		  (*info->fprintf_func) (info->stream, "%s ",
				    short_bytes_compl_names[GET_COMPL (insn)]);
		  break;
		/* these four conditions are for the set of instructions
		   which distinguish true/false conditions by opcode rather
		   than by the 'f' bit (sigh): comb, comib, addb, addib */
		case '<':
		  fputs_filtered (compare_cond_names[GET_FIELD (insn, 16, 18)],
				  info);
d702 2
d705 107
a811 19
		  fputs_filtered (compare_cond_names[GET_FIELD (insn, 16, 18)
				  + GET_FIELD (insn, 4, 4) * 8], info);
		  break;
		case '@@':
		  fputs_filtered (add_cond_names[GET_FIELD (insn, 16, 18)
				  + GET_FIELD (insn, 4, 4) * 8], info);
		  break;
		case 'a':
		  (*info->fprintf_func) (info->stream, "%s ",
					 compare_cond_names[GET_COND (insn)]);
		  break;
		case 'd':
		  (*info->fprintf_func) (info->stream, "%s ",
					 add_cond_names[GET_COND (insn)]);
		  break;
		case '!':
		  (*info->fprintf_func) (info->stream, "%s",
				    add_cond_names[GET_FIELD (insn, 16, 18)]);
		  break;
a812 20
		case '&':
		  (*info->fprintf_func) (info->stream, "%s ",
				    logical_cond_names[GET_COND (insn)]);
		  break;
		case 'U':
		  (*info->fprintf_func) (info->stream, "%s ",
				    unit_cond_names[GET_COND (insn)]);
		  break;
		case '|':
		case '>':
		case '~':
		  (*info->fprintf_func)
		    (info->stream, "%s",
		     shift_cond_names[GET_FIELD (insn, 16, 18)]);

		  /* If the next character in args is 'n', it will handle
		     putting out the space.  */
		  if (s[1] != 'n')
		    (*info->fprintf_func) (info->stream, " ");
		  break;
d822 4
d868 26
d898 8
d910 8
d922 19
a943 6
		case 'Z':
		  if (GET_FIELD (insn, 26, 26))
		    (*info->fprintf_func) (info->stream, ",m ");
		  else
		    (*info->fprintf_func) (info->stream, " ");
		  break;
d947 1
a947 1
		case 'f':
d975 1
a975 1
		  if (GET_FIELD (insn, 21, 22) == 1 || s[1] == 'M')
d999 1
a999 1
		  if (GET_FIELD (insn, 21, 22) == 1 || s[1] == 'M')
d1007 50
a1056 6
		case 'J':
                  if (GET_FIELD (insn, 24, 24))
		      fput_fp_reg_r (GET_FIELD (insn, 6, 10), info);
		  else
		      fput_fp_reg (GET_FIELD (insn, 6, 10), info);
		      
d1058 39
a1096 5
		case 'K':
                  if (GET_FIELD (insn, 19, 19))
		      fput_fp_reg_r (GET_FIELD (insn, 11, 15), info);
		  else
		      fput_fp_reg (GET_FIELD (insn, 11, 15), info);
d1098 2
a1099 4
		case 'M':
		    (*info->fprintf_func) (info->stream, "%s ",
					   float_comp_names[GET_FIELD
							      (insn, 27, 31)]);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d21 1
a48 1
#define MASK_10 0x3ff
d61 1
a61 1
static const char *const control_reg[] = {
d69 9
a77 22
static const char *const compare_cond_names[] = {
  "", ",=", ",<", ",<=", ",<<", ",<<=", ",sv", ",od",
  ",tr", ",<>", ",>=", ",>", ",>>=", ",>>", ",nsv", ",ev"
};
static const char *const compare_cond_64_names[] = {
  "", ",*=", ",*<", ",*<=", ",*<<", ",*<<=", ",*sv", ",*od",
  ",*tr", ",*<>", ",*>=", ",*>", ",*>>=", ",*>>", ",*nsv", ",*ev"
};
static const char *const cmpib_cond_64_names[] = {
  ",*<<", ",*=", ",*<", ",*<=", ",*>>=", ",*<>", ",*>=", ",*>"
};
static const char *const add_cond_names[] = {
  "", ",=", ",<", ",<=", ",nuv", ",znv", ",sv", ",od",
  ",tr", ",<>", ",>=", ",>", ",uv", ",vnz", ",nsv", ",ev"
};
static const char *const add_cond_64_names[] = {
  "", ",*=", ",*<", ",*<=", ",*nuv", ",*znv", ",*sv", ",*od",
  ",*tr", ",*<>", ",*>=", ",*>", ",*uv", ",*vnz", ",*nsv", ",*ev"
};
static const char *const wide_add_cond_names[] = {
  "", ",=", ",<", ",<=", ",nuv", ",*=", ",*<", ",*<=",
  ",tr", ",<>", ",>=", ",>", ",uv", ",*<>", ",*>=", ",*>"
a81 3
static const char *const logical_cond_64_names[] = {
  "", ",*=", ",*<", ",*<=", 0, 0, 0, ",*od",
  ",*tr", ",*<>", ",*>=", ",*>", 0, 0, 0, ",*ev"};
d83 2
a84 2
  "", ",swz", ",sbz", ",shz", ",sdc", ",swc", ",sbc", ",shc",
  ",tr", ",nwz", ",nbz", ",nhz", ",ndc", ",nwc", ",nbc", ",nhc"
d86 1
a86 5
static const char *const unit_cond_64_names[] = {
  "", ",*swz", ",*sbz", ",*shz", ",*sdc", ",*swc", ",*sbc", ",*shc",
  ",*tr", ",*nwz", ",*nbz", ",*nhz", ",*ndc", ",*nwc", ",*nbc", ",*nhc"
};
static const char *const shift_cond_names[] = {
d89 2
a90 8
static const char *const shift_cond_64_names[] = {
  "", ",*=", ",*<", ",*od", ",*tr", ",*<>", ",*>=", ",*ev"
};
static const char *const bb_cond_64_names[] = {
  ",*<", ",*>="
};
static const char *const index_compl_names[] = {"", ",m", ",s", ",sm"};
static const char *const short_ldst_compl_names[] = {"", ",ma", "", ",mb"};
d95 1
a95 1
static const char *const float_comp_names[] =
a101 5
static const char *const signed_unsigned_names[] = {",u", ",s"};
static const char *const mix_half_names[] = {",l", ",r"};
static const char *const saturation_names[] = {",us", ",ss", 0, ""};
static const char *const read_write_names[] = {",r", ",w"};
static const char *const add_compl_names[] = { 0, "", ",l", ",tsv" };
a207 8
/* extract the 10 bit immediate field from a {sr}sm instruction */
static unsigned
extract_10U_store (word)
     unsigned word;
{
  return (word >> 16 & MASK_10);
}

a277 11
static int
extract_22 (word)
     unsigned word;
{
  return sign_extend (GET_FIELD (word, 19, 28) |
                      GET_FIELD (word, 29, 29) << 10 |
                      GET_FIELD (word, 11, 15) << 11 |
                      GET_FIELD (word, 6, 10) << 16 |
                      (word & 0x1) << 21, 22) << 2;
}

d308 1
a308 1
	  if (!strchr ("cfCY?-+nHNZFIuv", opcode->args[0]))
d317 6
a322 1
		case 'a':
d329 6
d338 28
d367 7
a373 104
		/* Handle floating point registers.  */
		case 'f':
		  switch (*++s)
		    {
		    case 't':
		      fput_fp_reg (GET_FIELD (insn, 27, 31), info);
		      break;
		    case 'T':
		      if (GET_FIELD (insn, 25, 25))
			fput_fp_reg_r (GET_FIELD (insn, 27, 31), info);
		      else
			fput_fp_reg (GET_FIELD (insn, 27, 31), info);
		      break;
		    case 'a':
		      if (GET_FIELD (insn, 25, 25))
			fput_fp_reg_r (GET_FIELD (insn, 6, 10), info);
		      else
			fput_fp_reg (GET_FIELD (insn, 6, 10), info);
		      break;

		    /* 'fA' will not generate a space before the regsiter
			name.  Normally that is fine.  Except that it
			causes problems with xmpyu which has no FP format
			completer.  */
		    case 'X':
		      fputs_filtered (" ", info);

		    /* FALLTHRU */

		    case 'A':
		      if (GET_FIELD (insn, 24, 24))
			fput_fp_reg_r (GET_FIELD (insn, 6, 10), info);
		      else
			fput_fp_reg (GET_FIELD (insn, 6, 10), info);
		      
		      break;
		    case 'b':
		      if (GET_FIELD (insn, 25, 25))
			fput_fp_reg_r (GET_FIELD (insn, 11, 15), info);
		      else
			fput_fp_reg (GET_FIELD (insn, 11, 15), info);
		      break;
		    case 'B':
		      if (GET_FIELD (insn, 19, 19))
			fput_fp_reg_r (GET_FIELD (insn, 11, 15), info);
		      else
			fput_fp_reg (GET_FIELD (insn, 11, 15), info);
		      break;
		    case 'C':
		      {
			int reg = GET_FIELD (insn, 21, 22);
			reg |= GET_FIELD (insn, 16, 18) << 2;
			if (GET_FIELD (insn, 23, 23) != 0)
			  fput_fp_reg_r (reg, info);
			else
			  fput_fp_reg (reg, info);
			break;
		      }
		    case 'i':
		      {
			int reg = GET_FIELD (insn, 6, 10);

			reg |= (GET_FIELD (insn, 26, 26) << 4);
			fput_fp_reg (reg, info);
			break;
		      }
		    case 'j':
		      {
			int reg = GET_FIELD (insn, 11, 15);

			reg |= (GET_FIELD (insn, 26, 26) << 4);
			fput_fp_reg (reg, info);
			break;
		      }
		    case 'k':
		      {
			int reg = GET_FIELD (insn, 27, 31);

			reg |= (GET_FIELD (insn, 26, 26) << 4);
			fput_fp_reg (reg, info);
			break;
		      }
		    case 'l':
		      {
			int reg = GET_FIELD (insn, 21, 25);

			reg |= (GET_FIELD (insn, 26, 26) << 4);
			fput_fp_reg (reg, info);
			break;
		      }
		    case 'm':
		      {
			int reg = GET_FIELD (insn, 16, 20);

			reg |= (GET_FIELD (insn, 26, 26) << 4);
			fput_fp_reg (reg, info);
			break;
		      }
		    case 'e':
		      if (GET_FIELD (insn, 25, 25))
			fput_fp_reg_r (GET_FIELD (insn, 11, 15), info);
		      else
			fput_fp_reg (GET_FIELD (insn, 11, 15), info);
		      break;
d375 7
a381 2
		    }
		  break;
d383 4
a393 1

a396 2

		/* Handle completers.  */
d398 17
a414 201
		  switch (*++s)
		    {
		    case 'x':
		      (*info->fprintf_func) (info->stream, "%s ",
					     index_compl_names[GET_COMPL (insn)]);
		      break;
		    case 'm':
		      (*info->fprintf_func) (info->stream, "%s ",
					     short_ldst_compl_names[GET_COMPL (insn)]);
		      break;
		    case 's':
		      (*info->fprintf_func) (info->stream, "%s ",
					     short_bytes_compl_names[GET_COMPL (insn)]);
		      break;
		    case 'c':
		    case 'C':
		      switch (GET_FIELD (insn, 20, 21))
			{
			case 1:
			  (*info->fprintf_func) (info->stream, ",bc ");
			  break;
			case 2:
			  (*info->fprintf_func) (info->stream, ",sl ");
			  break;
			default:
			  (*info->fprintf_func) (info->stream, " ");
			}
		      break;
		    case 'd':
		      switch (GET_FIELD (insn, 20, 21))
			{
			case 1:
			  (*info->fprintf_func) (info->stream, ",co ");
			  break;
			default:
			  (*info->fprintf_func) (info->stream, " ");
			}
		      break;
		    case 'o':
		      (*info->fprintf_func) (info->stream, ",o");
		      break;
		    case 'g':
		      (*info->fprintf_func) (info->stream, ",gate");
		      break;
		    case 'p':
		      (*info->fprintf_func) (info->stream, ",l,push");
		      break;
		    case 'P':
		      (*info->fprintf_func) (info->stream, ",pop");
		      break;
		    case 'l':
		    case 'L':
		      (*info->fprintf_func) (info->stream, ",l");
		      break;
		    case 'w':
		      (*info->fprintf_func) (info->stream, "%s ",
					     read_write_names[GET_FIELD (insn, 25, 25)]);
		      break;
		    case 'W':
		      (*info->fprintf_func) (info->stream, ",w");
		      break;
		    case 'r':
		      if (GET_FIELD (insn, 23, 26) == 5)
			(*info->fprintf_func) (info->stream, ",r");
		      break;
		    case 'Z':
		      if (GET_FIELD (insn, 26, 26))
			(*info->fprintf_func) (info->stream, ",m ");
		      else
			(*info->fprintf_func) (info->stream, " ");
		      break;
		    case 'i':
		      if (GET_FIELD (insn, 25, 25))
			(*info->fprintf_func) (info->stream, ",i");
		      break;
		    case 'z':
		      if (!GET_FIELD (insn, 21, 21))
			(*info->fprintf_func) (info->stream, ",z");
		      break;
		    case 'a':
		      (*info->fprintf_func)
			(info->stream, "%s", add_compl_names[GET_FIELD
							    (insn, 20, 21)]);
		      break;
		    case 'Y':
		      (*info->fprintf_func)
			(info->stream, ",dc%s", add_compl_names[GET_FIELD
							       (insn, 20, 21)]);
		      break;
		    case 'y':
		      (*info->fprintf_func)
			(info->stream, ",c%s", add_compl_names[GET_FIELD
							      (insn, 20, 21)]);
		      break;
		    case 'v':
		      if (GET_FIELD (insn, 20, 20))
			(*info->fprintf_func) (info->stream, ",tsv");
		      break;
		    case 't':
		      (*info->fprintf_func) (info->stream, ",tc");
		      if (GET_FIELD (insn, 20, 20))
			(*info->fprintf_func) (info->stream, ",tsv");
		      break;
		    case 'B':
		      (*info->fprintf_func) (info->stream, ",db");
		      if (GET_FIELD (insn, 20, 20))
			(*info->fprintf_func) (info->stream, ",tsv");
		      break;
		    case 'b':
		      (*info->fprintf_func) (info->stream, ",b");
		      if (GET_FIELD (insn, 20, 20))
			(*info->fprintf_func) (info->stream, ",tsv");
		      break;
		    case 'T':
		      if (GET_FIELD (insn, 25, 25))
			(*info->fprintf_func) (info->stream, ",tc");
		      break;
		    case 'S':
		      /* EXTRD/W has a following condition.  */
		      if (*(s + 1) == '?')
			(*info->fprintf_func)
			  (info->stream, "%s", signed_unsigned_names[GET_FIELD
								    (insn, 21, 21)]);
		      else
			(*info->fprintf_func)
			  (info->stream, "%s ", signed_unsigned_names[GET_FIELD
								     (insn, 21, 21)]);
		      break;
		    case 'h':
		      (*info->fprintf_func)
			  (info->stream, "%s", mix_half_names[GET_FIELD
							     (insn, 17, 17)]);
		      break;
		    case 'H':
		      (*info->fprintf_func)
			  (info->stream, "%s", saturation_names[GET_FIELD
							       (insn, 24, 25)]);
		      break;
		    case '*':
		      (*info->fprintf_func)
			  (info->stream, ",%d%d%d%d ",
			   GET_FIELD (insn, 17, 18), GET_FIELD (insn, 20, 21),
			   GET_FIELD (insn, 22, 23), GET_FIELD (insn, 24, 25));
		      break;

		    case 'q':
		      {
			int m, a;

			m = GET_FIELD (insn, 28, 28);
			a = GET_FIELD (insn, 29, 29);

			if (m && !a)
			  fputs_filtered (",ma ", info);
			else if (m && a)
			  fputs_filtered (",mb ", info);
			else
			  fputs_filtered (" ", info);
			break;
		      }

		    case 'J':
		      {
			int opcode = GET_FIELD (insn, 0, 5);

			if (opcode == 0x16 || opcode == 0x1e)
			  {
			    if (GET_FIELD (insn, 29, 29) == 0)
			      fputs_filtered (",ma ", info);
			    else
			      fputs_filtered (",mb ", info);
			  }
			else
			  fputs_filtered (" ", info);
			break;
		      }

		    case 'e':
		      {
			int opcode = GET_FIELD (insn, 0, 5);

			if (opcode == 0x13 || opcode == 0x1b)
			  {
			    if (GET_FIELD (insn, 18, 18) == 1)
			      fputs_filtered (",mb ", info);
			    else
			      fputs_filtered (",ma ", info);
			  }
			else if (opcode == 0x17 || opcode == 0x1f)
			  {
			    if (GET_FIELD (insn, 31, 31) == 1)
			      fputs_filtered (",ma ", info);
			    else
			      fputs_filtered (",mb ", info);
			  }
			else
			  fputs_filtered (" ", info);

			break;
		      }
		    }
a415 2

		/* Handle conditions.  */
d417 19
a435 107
		  {
		    s++;
		    switch (*s)
		      {
		      case 'f':
			(*info->fprintf_func) (info->stream, "%s ",
					       float_comp_names[GET_FIELD
							       (insn, 27, 31)]);
			break;

		      /* these four conditions are for the set of instructions
			   which distinguish true/false conditions by opcode
			   rather than by the 'f' bit (sigh): comb, comib,
			   addb, addib */
		      case 't':
			fputs_filtered (compare_cond_names[GET_FIELD (insn, 16, 18)],
					info);
			break;
		      case 'n':
			fputs_filtered (compare_cond_names[GET_FIELD (insn, 16, 18)
					+ GET_FIELD (insn, 4, 4) * 8], info);
			break;
		      case 'N':
			fputs_filtered (compare_cond_64_names[GET_FIELD (insn, 16, 18)
					+ GET_FIELD (insn, 2, 2) * 8], info);
			break;
		      case 'Q':
			fputs_filtered (cmpib_cond_64_names[GET_FIELD (insn, 16, 18)],
					info);
			break;
		      case '@@':
			fputs_filtered (add_cond_names[GET_FIELD (insn, 16, 18)
					+ GET_FIELD (insn, 4, 4) * 8], info);
			break;
		      case 's':
			(*info->fprintf_func) (info->stream, "%s ",
					       compare_cond_names[GET_COND (insn)]);
			break;
		      case 'S':
			(*info->fprintf_func) (info->stream, "%s ",
					       compare_cond_64_names[GET_COND (insn)]);
			break;
		      case 'a':
			(*info->fprintf_func) (info->stream, "%s ",
					       add_cond_names[GET_COND (insn)]);
			break;
		      case 'A':
			(*info->fprintf_func) (info->stream, "%s ",
					       add_cond_64_names[GET_COND (insn)]);
			break;
		      case 'd':
			(*info->fprintf_func) (info->stream, "%s",
					       add_cond_names[GET_FIELD (insn, 16, 18)]);
			break;

		      case 'W':
			(*info->fprintf_func) 
			  (info->stream, "%s",
			   wide_add_cond_names[GET_FIELD (insn, 16, 18) + 
					      GET_FIELD (insn, 4, 4) * 8]);
			break;

		      case 'l':
			(*info->fprintf_func) (info->stream, "%s ",
					       logical_cond_names[GET_COND (insn)]);
			break;
		      case 'L':
			(*info->fprintf_func) (info->stream, "%s ",
					       logical_cond_64_names[GET_COND (insn)]);
			break;
		      case 'u':
			(*info->fprintf_func) (info->stream, "%s ",
					       unit_cond_names[GET_COND (insn)]);
			break;
		      case 'U':
			(*info->fprintf_func) (info->stream, "%s ",
					       unit_cond_64_names[GET_COND (insn)]);
			break;
		      case 'y':
		      case 'x':
		      case 'b':
			(*info->fprintf_func)
			  (info->stream, "%s",
			   shift_cond_names[GET_FIELD (insn, 16, 18)]);

			/* If the next character in args is 'n', it will handle
			   putting out the space.  */
			if (s[1] != 'n')
			  (*info->fprintf_func) (info->stream, " ");
			break;
		      case 'X':
			(*info->fprintf_func) (info->stream, "%s ",
					       shift_cond_64_names[GET_FIELD (insn, 16, 18)]);
			break;
		      case 'B':
			(*info->fprintf_func)
			  (info->stream, "%s",
			   bb_cond_64_names[GET_FIELD (insn, 16, 16)]);

			/* If the next character in args is 'n', it will handle
			   putting out the space.  */
			if (s[1] != 'n')
			  (*info->fprintf_func) (info->stream, " ");
			break;
		      }
		    break;
		  }
d437 20
a465 4
		case 'U':
		  fput_const (extract_10U_store (insn), info);
		  break;
		case 'B':
a507 26

		case 'Z':
		  /* addil %r1 implicit output.  */
		  (*info->fprintf_func) (info->stream, "%%r1");
		  break;

		case 'Y':
		  /* be,l %sr0,%r31 implicit output.  */
		  (*info->fprintf_func) (info->stream, "%%sr0,%%r31");
		  break;
		  
		case '@@':
		  (*info->fprintf_func) (info->stream, "0");
		  break;

		case '.':
		  (*info->fprintf_func) (info->stream, "%d",
				    GET_FIELD (insn, 24, 25));
		  break;
		case '*':
		  (*info->fprintf_func) (info->stream, "%d",
				    GET_FIELD (insn, 22, 25));
		  break;
		case '!':
		  (*info->fprintf_func) (info->stream, "%%sar");
		  break;
a511 8
		case '~':
		  {
		    int num;
		    num = GET_FIELD (insn, 20, 20) << 5;
		    num |= GET_FIELD (insn, 22, 26);
		    (*info->fprintf_func) (info->stream, "%d", 63 - num);
		    break;
		  }
a515 8
		case 'q':
		  {
		    int num;
		    num = GET_FIELD (insn, 20, 20) << 5;
		    num |= GET_FIELD (insn, 22, 26);
		    (*info->fprintf_func) (info->stream, "%d", num);
		    break;
		  }
a519 19
		case '%':
		  {
		    int num;
		    num = (GET_FIELD (insn, 23, 23) + 1) * 32;
		    num -= GET_FIELD (insn, 27, 31);
		    (*info->fprintf_func) (info->stream, "%d", num);
		    break;
		  }
		case '|':
		  {
		    int num;
		    num = (GET_FIELD (insn, 19, 19) + 1) * 32;
		    num -= GET_FIELD (insn, 27, 31);
		    (*info->fprintf_func) (info->stream, "%d", num);
		    break;
		  }
		case '$':
		  fput_const (GET_FIELD (insn, 20, 28), info);
		  break;
d523 6
d532 1
a532 1
		case 'v':
d560 1
a560 1
		  if (s[1] == 'G' || s[1] == '?')
d584 1
a584 1
		  if (s[1] == '?')
d592 6
a597 41

                case 'J':
                  fput_const (extract_14 (insn), info);
                  break;

		case '#':
		  {
		    int sign = GET_FIELD (insn, 31, 31);
		    int imm10 = GET_FIELD (insn, 18, 27);
		    int disp;

		    if (sign)
		      disp = (-1 << 10) | imm10;
		    else
		      disp = imm10;

		    disp <<= 3;
		    fput_const (disp, info);
		    break;
		  }
                case 'K':
		case 'd':
		  {
		    int sign = GET_FIELD (insn, 31, 31);
		    int imm11 = GET_FIELD (insn, 18, 28);
		    int disp;

		    if (sign)
		      disp = (-1 << 11) | imm11;
		    else
		      disp = imm11;

		    disp <<= 2;
		    fput_const (disp, info);
		    break;
		  }

		/* ?!? FIXME */
		case '_':
		case '{':
		  fputs_filtered ("Disassembler botch.\n", info);
d599 5
a603 8

		case 'm':
		  {
		    int y = GET_FIELD (insn, 16, 18);

		    if (y != 1)
		      fput_const ((y ^ 1) - 1, info);
		  }
d605 4
a608 42

		case 'h':
		  {
		    int cbit;

		    cbit = GET_FIELD (insn, 16, 18);

		    if (cbit > 0)
		      (*info->fprintf_func) (info->stream, ",%d", cbit - 1);
		    break;
		  }

		case '=':
		  {
		    int cond = GET_FIELD (insn, 27, 31);

		    if (cond == 0)
		      fputs_filtered (" ", info);
		    else if (cond == 1)
		      fputs_filtered ("acc ", info);
		    else if (cond == 2)
		      fputs_filtered ("rej ", info);
		    else if (cond == 5)
		      fputs_filtered ("acc8 ", info);
		    else if (cond == 6)
		      fputs_filtered ("rej8 ", info);
		    else if (cond == 9)
		      fputs_filtered ("acc6 ", info);
		    else if (cond == 13)
		      fputs_filtered ("acc4 ", info);
		    else if (cond == 17)
		      fputs_filtered ("acc2 ", info);
		    break;
		  }

		case 'X':
		  (*info->print_address_func) ((memaddr + 8 
						+ extract_22 (insn)),
					       info);
		  break;
		case 'L':
		  fputs_filtered (",%r2", info);
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1989, 1990, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d45 1
a45 1
/* Get at various relevent fields of an instruction word.  */
a50 1
#define MASK_16 0xffff
d53 1
a53 1
/* These macros get bit fields using HP's numbering (MSB = 0) */
a57 3
#define GET_BIT(X, WHICH) \
  GET_FIELD (X, WHICH, WHICH)

d135 1
a135 1
   completer name table.  */
a141 20
static void fput_reg PARAMS ((unsigned int, disassemble_info *));
static void fput_fp_reg PARAMS ((unsigned int, disassemble_info *));
static void fput_fp_reg_r PARAMS ((unsigned int, disassemble_info *));
static void fput_creg PARAMS ((unsigned int, disassemble_info *));
static void fput_const PARAMS ((unsigned int, disassemble_info *));
static int extract_3 PARAMS ((unsigned int));
static int extract_5_load PARAMS ((unsigned int));
static int extract_5_store PARAMS ((unsigned int));
static unsigned extract_5r_store PARAMS ((unsigned int));
static unsigned extract_5R_store PARAMS ((unsigned int));
static unsigned extract_10U_store PARAMS ((unsigned int));
static unsigned extract_5Q_store PARAMS ((unsigned int));
static int extract_11 PARAMS ((unsigned int));
static int extract_14 PARAMS ((unsigned int));
static int extract_16 PARAMS ((unsigned int));
static int extract_21 PARAMS ((unsigned int));
static int extract_12 PARAMS ((unsigned int));
static int extract_17 PARAMS ((unsigned int));
static int extract_22 PARAMS ((unsigned int));

d184 1
a184 1
/* Print constants with sign.  */
d198 1
a198 1
   instructions.  */
d200 1
a200 1
/* Extract a 3-bit space register number from a be, ble, mtsp or mfsp.  */
d215 1
a215 1
/* Extract the immediate field from a st{bhw}s instruction.  */
d223 1
a223 1
/* Extract the immediate field from a break instruction.  */
d231 1
a231 1
/* Extract the immediate field from a {sr}sm instruction.  */
d239 1
a239 1
/* Extract the 10 bit immediate field from a {sr}sm instruction.  */
d247 1
a247 1
/* Extract the immediate field from a bb instruction.  */
d255 1
a255 1
/* Extract an 11 bit immediate field.  */
d263 1
a263 1
/* Extract a 14 bit immediate field.  */
d271 1
a271 15
/* Extract a 16 bit immediate field (PA2.0 wide only).  */
static int
extract_16 (word)
     unsigned word;
{
  int m15, m0, m1;
  m0 = GET_BIT (word, 16);
  m1 = GET_BIT (word, 17);
  m15 = GET_BIT (word, 31);
  word = (word >> 1) & 0x1fff;
  word = word | (m15 << 15) | ((m15 ^ m0) << 14) | ((m15 ^ m1) << 13);
  return sign_extend (word, 16);
}

/* Extract a 21 bit constant.  */
d293 1
a293 1
/* Extract a 12 bit constant from branch instructions.  */
d304 2
a305 2
/* Extract a 17 bit constant from branch instructions, returning the
   19 bit signed value.  */
d355 1
a355 4
#ifndef BFD64
	  if (opcode->arch == pa20w)
	    continue;
#endif
a475 10

		    /* 'fe' will not generate a space before the register
			name.  Normally that is fine.  Except that it
			causes problems with fstw fe,y(b) which has no FP
			format completer.  */
		    case 'E':
		      fputs_filtered (" ", info);

		    /* FALLTHRU */

d477 1
a477 1
		      if (GET_FIELD (insn, 30, 30))
d482 1
a482 3
		    case 'x':
		      fput_fp_reg (GET_FIELD (insn, 11, 15), info);
		      break;
d663 1
a663 1
			int opc = GET_FIELD (insn, 0, 5);
d665 1
a665 1
			if (opc == 0x16 || opc == 0x1e)
d679 1
a679 1
			int opc = GET_FIELD (insn, 0, 5);
d681 1
a681 1
			if (opc == 0x13 || opc == 0x1b)
d688 1
a688 1
			else if (opc == 0x17 || opc == 0x1f)
a837 5
		case '<':
		case 'l':
		  /* 16-bit long disp., PA2.0 wide only.  */
		  fput_const (extract_16 (insn), info);
		  break;
a1039 19
		    fput_const (disp, info);
		    break;
		  }

		case '>':
		case 'y':
		  {
		    /* 16-bit long disp., PA2.0 wide only.  */
		    int disp = extract_16 (insn);
		    disp &= ~3;
		    fput_const (disp, info);
		    break;
		  }

		case '&':
		  {
		    /* 16-bit long disp., PA2.0 wide only.  */
		    int disp = extract_16 (insn);
		    disp &= ~7;
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1989, 1990, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2003
d29 1
a29 1
static const char *const reg_names[] =
d37 4
a40 4
static const char *const fp_reg_names[] =
 {"fpsr", "fpe2", "fpe4", "fpe6",
  "fr4", "fr5", "fr6", "fr7", "fr8",
  "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
a125 2
static const char *const fcnv_fixed_names[] = {",w", ",dw", "", ",qw"};
static const char *const fcnv_ufixed_names[] = {",uw", ",udw", "", ",uqw"};
d139 1
a139 1
/* For a bunch of different instructions form an index into a
d197 2
a198 2
    (*info->fprintf_func) (info->stream, "%sR",
			   reg ? fp_reg_names[reg] : "fr0");
d339 2
a340 2
		      GET_FIELD (word, 29, 29) << 10 |
		      (word & 0x1) << 11, 12) << 2;
d351 3
a353 3
		      GET_FIELD (word, 29, 29) << 10 |
		      GET_FIELD (word, 11, 15) << 11 |
		      (word & 0x1) << 16, 17) << 2;
d361 4
a364 4
		      GET_FIELD (word, 29, 29) << 10 |
		      GET_FIELD (word, 11, 15) << 11 |
		      GET_FIELD (word, 6, 10) << 16 |
		      (word & 0x1) << 21, 22) << 2;
d400 1
a400 1
	  if (!strchr ("cfCY?-+nHNZFIuv{", opcode->args[0]))
d420 1
a420 1
		  /* Handle floating point registers.  */
d440 4
a443 4
		      /* 'fA' will not generate a space before the regsiter
			 name.  Normally that is fine.  Except that it
			 causes problems with xmpyu which has no FP format
			 completer.  */
d446 2
a447 1
		      /* FALLTHRU */
d454 1
d519 4
a522 4
		      /* 'fe' will not generate a space before the register
			 name.  Normally that is fine.  Except that it
			 causes problems with fstw fe,y(b) which has no FP
			 format completer.  */
d525 2
a526 1
		      /* FALLTHRU */
d544 2
a545 6
		  {
		    int space = GET_FIELD (insn, 16, 17);
		    /* Zero means implicit addressing, not use of sr0.  */
		    if (space != 0)
		      (*info->fprintf_func) (info->stream, "sr%d", space);
		  }
d549 1
a549 2
		  (*info->fprintf_func) (info->stream, "sr%d",
					 extract_3 (insn));
d552 1
a552 1
		  /* Handle completers.  */
d557 2
a558 8
		      (*info->fprintf_func)
			(info->stream, "%s",
			 index_compl_names[GET_COMPL (insn)]);
		      break;
		    case 'X':
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 index_compl_names[GET_COMPL (insn)]);
d561 2
a562 13
		      (*info->fprintf_func)
			(info->stream, "%s",
			 short_ldst_compl_names[GET_COMPL (insn)]);
		      break;
		    case 'M':
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 short_ldst_compl_names[GET_COMPL (insn)]);
		      break;
		    case 'A':
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 short_bytes_compl_names[GET_COMPL (insn)]);
d565 2
a566 3
		      (*info->fprintf_func)
			(info->stream, "%s",
			 short_bytes_compl_names[GET_COMPL (insn)]);
d609 2
a610 3
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 read_write_names[GET_FIELD (insn, 25, 25)]);
d635 2
a636 2
			(info->stream, "%s",
			 add_compl_names[GET_FIELD (insn, 20, 21)]);
d640 2
a641 2
			(info->stream, ",dc%s",
			 add_compl_names[GET_FIELD (insn, 20, 21)]);
d645 2
a646 2
			(info->stream, ",c%s",
			 add_compl_names[GET_FIELD (insn, 20, 21)]);
d675 2
a676 2
			  (info->stream, "%s",
			   signed_unsigned_names[GET_FIELD (insn, 21, 21)]);
d679 2
a680 2
			  (info->stream, "%s ",
			   signed_unsigned_names[GET_FIELD (insn, 21, 21)]);
d684 2
a685 2
			(info->stream, "%s",
			 mix_half_names[GET_FIELD (insn, 17, 17)]);
d689 2
a690 2
			(info->stream, "%s ",
			 saturation_names[GET_FIELD (insn, 24, 25)]);
d694 3
a696 3
			(info->stream, ",%d%d%d%d ",
			 GET_FIELD (insn, 17, 18), GET_FIELD (insn, 20, 21),
			 GET_FIELD (insn, 22, 23), GET_FIELD (insn, 24, 25));
d757 1
a757 1
		  /* Handle conditions.  */
d764 3
a766 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   float_comp_names[GET_FIELD (insn, 27, 31)]);
d769 1
a769 1
			/* these four conditions are for the set of instructions
d774 2
a775 2
			fputs_filtered
			  (compare_cond_names[GET_FIELD (insn, 16, 18)], info);
d778 2
a779 4
			fputs_filtered
			  (compare_cond_names[GET_FIELD (insn, 16, 18)
					      + GET_FIELD (insn, 4, 4) * 8],
			   info);
d782 2
a783 4
			fputs_filtered
			  (compare_cond_64_names[GET_FIELD (insn, 16, 18)
						 + GET_FIELD (insn, 2, 2) * 8],
			   info);
d786 2
a787 3
			fputs_filtered
			  (cmpib_cond_64_names[GET_FIELD (insn, 16, 18)],
			   info);
d790 2
a791 4
			fputs_filtered
			  (add_cond_names[GET_FIELD (insn, 16, 18)
					  + GET_FIELD (insn, 4, 4) * 8],
			   info);
d794 2
a795 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   compare_cond_names[GET_COND (insn)]);
d798 2
a799 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   compare_cond_64_names[GET_COND (insn)]);
d802 2
a803 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   add_cond_names[GET_COND (insn)]);
d806 2
a807 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   add_cond_64_names[GET_COND (insn)]);
d810 2
a811 3
			(*info->fprintf_func)
			  (info->stream, "%s",
			   add_cond_names[GET_FIELD (insn, 16, 18)]);
d815 1
a815 1
			(*info->fprintf_func)
d817 2
a818 2
			   wide_add_cond_names[GET_FIELD (insn, 16, 18) +
					       GET_FIELD (insn, 4, 4) * 8]);
d822 2
a823 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   logical_cond_names[GET_COND (insn)]);
d826 2
a827 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   logical_cond_64_names[GET_COND (insn)]);
d830 2
a831 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   unit_cond_names[GET_COND (insn)]);
d834 2
a835 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   unit_cond_64_names[GET_COND (insn)]);
d850 2
a851 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   shift_cond_64_names[GET_FIELD (insn, 16, 18)]);
d912 2
a913 2
		  (*info->print_address_func)
		    (memaddr + 8 + extract_12 (insn), info);
d917 3
a919 2
		  (*info->print_address_func)
		    ((memaddr + 8 + extract_17 (insn)), info);
d937 1
a937 1

d944 1
a944 1
					 GET_FIELD (insn, 24, 25));
d948 1
a948 1
					 GET_FIELD (insn, 22, 25));
d955 1
a955 1
					 31 - GET_FIELD (insn, 22, 26));
d967 1
a967 1
					 GET_FIELD (insn, 22, 26));
d979 1
a979 1
					 32 - GET_FIELD (insn, 27, 31));
d1007 1
a1007 2
		  (*info->fprintf_func) (info->stream, ",%d",
					 GET_FIELD (insn, 23, 25));
d1029 1
a1029 2
		  (*info->fprintf_func) (info->stream, ",%d",
					 GET_FIELD (insn, 23, 25));
d1035 2
a1036 2
		    fputs_filtered
		      (float_format_names[GET_FIELD (insn, 19, 20)], info);
d1038 3
a1040 3
		    (*info->fprintf_func)
		      (info->stream, "%s ",
		       float_format_names[GET_FIELD (insn, 19, 20)]);
d1043 3
a1045 3
		  (*info->fprintf_func)
		    (info->stream, "%s ",
		     float_format_names[GET_FIELD (insn, 17, 18)]);
d1050 1
a1050 1
					   float_format_names[0]);
d1053 1
a1053 1
					   float_format_names[1]);
d1059 2
a1060 2
		    fputs_filtered
		      (float_format_names[GET_FIELD (insn, 20, 20)], info);
d1062 3
a1064 3
		    (*info->fprintf_func)
		      (info->stream, "%s ",
		       float_format_names[GET_FIELD (insn, 20, 20)]);
d1067 3
a1069 3
		case 'J':
		  fput_const (extract_14 (insn), info);
		  break;
d1086 1
a1086 1
		case 'K':
d1122 1
a1123 2
		  break; /* Dealt with by '{' */

d1125 2
a1126 23
		  {
		    int sub = GET_FIELD (insn, 14, 16);
		    int df = GET_FIELD (insn, 17, 18);
		    int sf = GET_FIELD (insn, 19, 20);
		    const char * const * source = float_format_names;
		    const char * const * dest = float_format_names;
		    char *t = "";
		    if (sub == 4)
		      {
			fputs_filtered (",UND ", info);
			break;
		      }
		    if ((sub & 3) == 3)
		      t = ",t";
		    if ((sub & 3) == 1)
		      source = sub & 4 ? fcnv_ufixed_names : fcnv_fixed_names;
		    if (sub & 2)
		      dest = sub & 4 ? fcnv_ufixed_names : fcnv_fixed_names;

		    (*info->fprintf_func) (info->stream, "%s%s%s ",
					   t, source[sf], dest[df]);
		    break;
		  }
d1172 3
a1174 2
		  (*info->print_address_func)
		    (memaddr + 8 + extract_22 (insn), info);
@


