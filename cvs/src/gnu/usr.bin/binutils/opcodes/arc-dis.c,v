head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.3.0.52
	OPENBSD_6_1_BASE:1.1.1.3
	OPENBSD_6_0:1.1.1.3.0.50
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.46
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.48
	OPENBSD_5_8_BASE:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.40
	OPENBSD_5_7_BASE:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.44
	OPENBSD_5_6_BASE:1.1.1.3
	OPENBSD_5_5:1.1.1.3.0.42
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.38
	OPENBSD_5_4_BASE:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.36
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.34
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.32
	OPENBSD_5_0:1.1.1.3.0.30
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.28
	OPENBSD_4_9_BASE:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.26
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.22
	OPENBSD_4_7_BASE:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.24
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.20
	OPENBSD_4_5_BASE:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.18
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.16
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.14
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.12
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.10
	OPENBSD_4_0_BASE:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	BINUTILS_2_15:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	BINUTILS-2_14:1.1.1.3
	OPENBSD_3_5:1.1.1.2.0.8
	OPENBSD_3_5_BASE:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.6
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.4
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.2
	OPENBSD_3_2_BASE:1.1.1.2
	binutils-2_11_2:1.1.1.2
	OPENBSD_3_1:1.1.1.1.0.8
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.6
	OPENBSD_3_0_BASE:1.1.1.1
	BINUTILS-2_10_1:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.4
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.2
	OPENBSD_2_8_BASE:1.1.1.1
	BINUTILS-2_10:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2000.09.12.14.47.49;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.09.12.14.47.49;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.05.13.13.55.14;	author fgsch;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.05.17.20.42.42;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* Instruction printing code for the ARC.
   Copyright (C) 1994, 1995, 1997, 1998 Free Software Foundation, Inc. 
   Contributed by Doug Evans (dje@@cygnus.com).

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "sysdep.h"
#include "dis-asm.h"
#include "opcode/arc.h"
#include "elf-bfd.h"
#include "elf/arc.h"
#include "opintl.h"

static int print_insn_arc_base_little PARAMS ((bfd_vma, disassemble_info *));
static int print_insn_arc_base_big PARAMS ((bfd_vma, disassemble_info *));

static int print_insn PARAMS ((bfd_vma, disassemble_info *, int, int));

/* Print one instruction from PC on INFO->STREAM.
   Return the size of the instruction (4 or 8 for the ARC). */

static int
print_insn (pc, info, mach, big_p)
     bfd_vma pc;
     disassemble_info *info;
     int mach;
     int big_p;
{
  const struct arc_opcode *opcode;
  bfd_byte buffer[4];
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;
  int status;
  /* First element is insn, second element is limm (if present).  */
  arc_insn insn[2];
  int got_limm_p = 0;
  static int initialized = 0;
  static int current_mach = 0;

  if (!initialized || mach != current_mach)
    {
      initialized = 1;
      current_mach = arc_get_opcode_mach (mach, big_p);
      arc_opcode_init_tables (current_mach);
    }

  status = (*info->read_memory_func) (pc, buffer, 4, info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, pc, info);
      return -1;
    }
  if (big_p)
    insn[0] = bfd_getb32 (buffer);
  else
    insn[0] = bfd_getl32 (buffer);

  (*func) (stream, "%08lx\t", insn[0]);

  /* The instructions are stored in lists hashed by the insn code
     (though we needn't care how they're hashed).  */

  opcode = arc_opcode_lookup_dis (insn[0]);
  for ( ; opcode != NULL; opcode = ARC_OPCODE_NEXT_DIS (opcode))
    {
      char *syn;
      int mods,invalid;
      long value;
      const struct arc_operand *operand;
      const struct arc_operand_value *opval;

      /* Basic bit mask must be correct.  */
      if ((insn[0] & opcode->mask) != opcode->value)
	continue;

      /* Supported by this cpu?  */
      if (! arc_opcode_supported (opcode))
	continue;

      /* Make two passes over the operands.  First see if any of them
	 have extraction functions, and, if they do, make sure the
	 instruction is valid.  */

      arc_opcode_init_extract ();
      invalid = 0;

      /* ??? Granted, this is slower than the `ppc' way.  Maybe when this is
	 done it'll be clear what the right way to do this is.  */
      /* Instructions like "add.f r0,r1,1" are tricky because the ".f" gets
	 printed first, but we don't know how to print it until we've processed
	 the regs.  Since we're scanning all the args before printing the insn
	 anyways, it's actually quite easy.  */

      for (syn = opcode->syntax; *syn; ++syn)
	{
	  int c;

	  if (*syn != '%' || *++syn == '%')
	    continue;
	  mods = 0;
	  c = *syn;
	  while (ARC_MOD_P (arc_operands[arc_operand_map[c]].flags))
	    {
	      mods |= arc_operands[arc_operand_map[c]].flags & ARC_MOD_BITS;
	      ++syn;
	      c = *syn;
	    }
	  operand = arc_operands + arc_operand_map[c];
	  if (operand->extract)
	    (*operand->extract) (insn, operand, mods,
				 (const struct arc_operand_value **) NULL,
				 &invalid);
	}
      if (invalid)
	continue;

      /* The instruction is valid.  */

      /* If we have an insn with a limm, fetch it now.  Scanning the insns
	 twice lets us do this.  */
      if (arc_opcode_limm_p (NULL))
	{
	  status = (*info->read_memory_func) (pc + 4, buffer, 4, info);
	  if (status != 0)
	    {
	      (*info->memory_error_func) (status, pc, info);
	      return -1;
	    }
	  if (big_p)
	    insn[1] = bfd_getb32 (buffer);
	  else
	    insn[1] = bfd_getl32 (buffer);
	  got_limm_p = 1;
	}

      for (syn = opcode->syntax; *syn; ++syn)
	{
	  int c;

	  if (*syn != '%' || *++syn == '%')
	    {
	      (*func) (stream, "%c", *syn);
	      continue;
	    }

	  /* We have an operand.  Fetch any special modifiers.  */
	  mods = 0;
	  c = *syn;
	  while (ARC_MOD_P (arc_operands[arc_operand_map[c]].flags))
	    {
	      mods |= arc_operands[arc_operand_map[c]].flags & ARC_MOD_BITS;
	      ++syn;
	      c = *syn;
	    }
	  operand = arc_operands + arc_operand_map[c];

	  /* Extract the value from the instruction.  */
	  opval = NULL;
	  if (operand->extract)
	    {
	      value = (*operand->extract) (insn, operand, mods,
					   &opval, (int *) NULL);
	    }
	  else
	    {
	      value = (insn[0] >> operand->shift) & ((1 << operand->bits) - 1);
	      if ((operand->flags & ARC_OPERAND_SIGNED)
		  && (value & (1 << (operand->bits - 1))))
		value -= 1 << operand->bits;

	      /* If this is a suffix operand, set `opval'.  */
	      if (operand->flags & ARC_OPERAND_SUFFIX)
		opval = arc_opcode_lookup_suffix (operand, value);
	    }

	  /* Print the operand as directed by the flags.  */
	  if (operand->flags & ARC_OPERAND_FAKE)
	    ; /* nothing to do (??? at least not yet) */
	  else if (operand->flags & ARC_OPERAND_SUFFIX)
	    {
	      /* Default suffixes aren't printed.  Fortunately, they all have
		 zero values.  Also, zero values for boolean suffixes are
		 represented by the absence of text.  */

	      if (value != 0)
		{
		  /* ??? OPVAL should have a value.  If it doesn't just cope
		     as we want disassembly to be reasonably robust.
		     Also remember that several condition code values (16-31)
		     aren't defined yet.  For these cases just print the
		     number suitably decorated.  */
		  if (opval)
		    (*func) (stream, "%s%s",
			     mods & ARC_MOD_DOT ? "." : "",
			     opval->name);
		  else
		    (*func) (stream, "%s%c%d",
			     mods & ARC_MOD_DOT ? "." : "",
			     operand->fmt, value);
		}
	    }
	  else if (operand->flags & ARC_OPERAND_RELATIVE_BRANCH)
	    (*info->print_address_func) (pc + 4 + value, info);
	  /* ??? Not all cases of this are currently caught.  */
	  else if (operand->flags & ARC_OPERAND_ABSOLUTE_BRANCH)
	    (*info->print_address_func) ((bfd_vma) value & 0xffffffff, info);
	  else if (operand->flags & ARC_OPERAND_ADDRESS)
	    (*info->print_address_func) ((bfd_vma) value & 0xffffffff, info);
	  else if (opval)
	    /* Note that this case catches both normal and auxiliary regs.  */
	    (*func) (stream, "%s", opval->name);
	  else
	    (*func) (stream, "%ld", value);
	}

      /* We have found and printed an instruction; return.  */
      return got_limm_p ? 8 : 4;
    }

  (*func) (stream, _("*unknown*"));
  return 4;
}

/* Given MACH, one of bfd_mach_arc_xxx, return the print_insn function to use.
   This does things a non-standard way (the "standard" way would be to copy
   this code into disassemble.c).  Since there are more than a couple of
   variants, hiding all this crud here seems cleaner.  */

disassembler_ftype
arc_get_disassembler (mach, big_p)
     int mach;
     int big_p;
{
  switch (mach)
    {
    case bfd_mach_arc_base:
      return big_p ? print_insn_arc_base_big : print_insn_arc_base_little;
    }
  return print_insn_arc_base_little;
}

static int
print_insn_arc_base_little (pc, info)
     bfd_vma pc;
     disassemble_info *info;
{
  return print_insn (pc, info, bfd_mach_arc_base, 0);
}

static int
print_insn_arc_base_big (pc, info)
     bfd_vma pc;
     disassemble_info *info;
{
  return print_insn (pc, info, bfd_mach_arc_base, 1);
}
@


1.1.1.1
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@@


1.1.1.2
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1997, 1998, 2000, 2001
   Free Software Foundation, Inc.
d5 13
a17 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d19 1
a19 2
#include <ansidecl.h>
#include <libiberty.h>
a23 1
#include <string.h>
d26 2
a27 129
#include <ctype.h>
#include <stdarg.h>
#include "arc-dis.h"
#include "arc-ext.h"

#ifndef dbg
#define dbg (0)
#endif

#define BIT(word,n) 	((word) & (1 << n))
#define BITS(word,s,e)  (((word) << (31 - e)) >> (s + (31 - e))) 
#define OPCODE(word) 	(BITS ((word), 27, 31))
#define FIELDA(word) 	(BITS ((word), 21, 26))
#define FIELDB(word) 	(BITS ((word), 15, 20))
#define FIELDC(word) 	(BITS ((word),  9, 14))

/* FIELD D is signed in all of its uses, so we make sure argument is
   treated as signed for bit shifting purposes:  */
#define FIELDD(word) 	(BITS (((signed int)word), 0, 8))

#define PUT_NEXT_WORD_IN(a)							\
  do										\
    {										\
      if (is_limm == 1 && !NEXT_WORD (1))					\
        mwerror (state, _("Illegal limm reference in last instruction!\n"));	\
        a = state->words[1];							\
    }										\
  while (0)

#define CHECK_FLAG_COND_NULLIFY()				\
  do								\
    {								\
      if (is_shimm == 0)					\
        {							\
          flag = BIT (state->words[0], 8);			\
          state->nullifyMode = BITS (state->words[0], 5, 6);	\
          cond = BITS (state->words[0], 0, 4);			\
        }							\
    }								\
  while (0)

#define CHECK_COND()				\
  do						\
    {						\
      if (is_shimm == 0)			\
        cond = BITS (state->words[0], 0, 4);	\
    }						\
  while (0)

#define CHECK_FIELD(field)			\
  do						\
    {						\
      if (field == 62)				\
        {					\
          is_limm++;				\
	  field##isReg = 0;			\
	  PUT_NEXT_WORD_IN (field);		\
	  limm_value = field;			\
	}					\
      else if (field > 60)			\
        {					\
	  field##isReg = 0;			\
	  is_shimm++;				\
	  flag = (field == 61);			\
	  field = FIELDD (state->words[0]);	\
	}					\
    }						\
  while (0)

#define CHECK_FIELD_A()				\
  do						\
    {						\
      fieldA = FIELDA(state->words[0]);		\
      if (fieldA > 60)				\
        {					\
	  fieldAisReg = 0;			\
	  fieldA = 0;				\
	}					\
    }						\
  while (0)

#define CHECK_FIELD_B()				\
  do						\
    {						\
      fieldB = FIELDB (state->words[0]);	\
      CHECK_FIELD (fieldB);			\
    }						\
  while (0)

#define CHECK_FIELD_C()				\
  do						\
    {						\
      fieldC = FIELDC (state->words[0]);	\
      CHECK_FIELD (fieldC);			\
    }						\
  while (0)

#define IS_SMALL(x) (((field##x) < 256) && ((field##x) > -257))
#define IS_REG(x)   (field##x##isReg)
#define WRITE_FORMAT_LB_Rx_RB(x)     WRITE_FORMAT(x,"[","]","","")
#define WRITE_FORMAT_x_COMMA_LB(x)   WRITE_FORMAT(x,"",",[","",",[")
#define WRITE_FORMAT_COMMA_x_RB(x)   WRITE_FORMAT(x,",","]",",","]")
#define WRITE_FORMAT_x_RB(x)         WRITE_FORMAT(x,"","]","","]")
#define WRITE_FORMAT_COMMA_x(x)      WRITE_FORMAT(x,",","",",","")
#define WRITE_FORMAT_x_COMMA(x)      WRITE_FORMAT(x,"",",","",",")
#define WRITE_FORMAT_x(x)            WRITE_FORMAT(x,"","","","")
#define WRITE_FORMAT(x,cb1,ca1,cb,ca) strcat (formatString,		\
				     (IS_REG (x) ? cb1"%r"ca1 :		\
				      usesAuxReg ? cb"%a"ca :		\
				      IS_SMALL (x) ? cb"%d"ca : cb"%h"ca))
#define WRITE_FORMAT_RB() 	strcat (formatString, "]")
#define WRITE_COMMENT(str)	(state->comm[state->commNum++] = (str))
#define WRITE_NOP_COMMENT() 	if (!fieldAisReg && !flag) WRITE_COMMENT ("nop");

#define NEXT_WORD(x) 	(offset += 4, state->words[x])

#define add_target(x) 	(state->targets[state->tcnt++] = (x))

static char comment_prefix[] = "\t; ";

static const char *
core_reg_name (state, val)
     struct arcDisState * state;
     int                  val; 
{
  if (state->coreRegName)
    return (*state->coreRegName)(state->_this, val);
  return 0;
}
d29 1
a29 9
static const char *
aux_reg_name (state, val)
     struct arcDisState * state;
     int                  val; 
{
  if (state->auxRegName)
    return (*state->auxRegName)(state->_this, val);
  return 0;
}
d31 2
a32 9
static const char *
cond_code_name (state, val)
     struct arcDisState * state;
     int                  val; 
{
  if (state->condCodeName)
    return (*state->condCodeName)(state->_this, val);
  return 0;
}
d34 6
a39 6
static const char *
instruction_name (state, op1, op2, flags)
     struct arcDisState * state;
     int    op1;
     int    op2;
     int *  flags; 
d41 10
a50 4
  if (state->instName)
    return (*state->instName)(state->_this, op1, op2, flags);
  return 0;
}
d52 1
a52 18
static void
mwerror (state, msg)
     struct arcDisState * state;
     const char * msg; 
{
  if (state->err != 0)
    (*state->err)(state->_this, (msg));
}

static const char *
post_address (state, addr)
     struct arcDisState * state;
     int addr; 
{
  static char id[3 * ARRAY_SIZE (state->addresses)];
  int j, i = state->acnt;

  if (i < ((int) ARRAY_SIZE (state->addresses)))
d54 3
a56 8
      state->addresses[i] = addr;
      ++state->acnt;
      j = i*3;
      id[j+0] = '@@';
      id[j+1] = '0'+i;
      id[j+2] = 0;
      
      return id + j;
a57 2
  return "";
}
d59 2
a60 186
static void 
my_sprintf (
	    struct arcDisState * state,
	    char * buf,
	    const char * format,
	    ...)
{
  char *bp; 
  const char *p;
  int size, leading_zero, regMap[2];
  long auxNum;
  va_list ap;
  
  va_start (ap, format);
  
  bp = buf; 
  *bp = 0;
  p = format;
  auxNum = -1;
  regMap[0] = 0;
  regMap[1] = 0;
  
  while (1) 
    switch (*p++)
      {
    case 0:
      goto DOCOMM; /* (return)  */
      default: 
	*bp++ = p[-1]; 
	break;
      case '%':
	size = 0;
	leading_zero = 0;
      RETRY: ;
	switch (*p++) 
	  {
	  case '0':
	  case '1':
	  case '2':
	  case '3':
	  case '4':
	  case '5':
	  case '6':
	  case '7':
	  case '8':
	  case '9':
	    {
	      /* size.  */
	      size = p[-1] - '0';
	      if (size == 0)
		leading_zero = 1; /* e.g. %08x  */
	      while (*p >= '0' && *p <= '9')
		{
		  size = size * 10 + *p - '0';
		  p++;
		}
	      goto RETRY;
	    }
#define inc_bp() bp = bp + strlen (bp)

	  case 'h': 
	    {
	      unsigned u = va_arg (ap, int);

	      /* Hex.  We can change the format to 0x%08x in
		 one place, here, if we wish.
		 We add underscores for easy reading.  */
	      if (u > 65536) 
		sprintf (bp, "0x%x_%04x", u >> 16, u & 0xffff);
	      else 
		sprintf (bp, "0x%x", u);
	      inc_bp ();
	    } 
	    break;
	  case 'X': case 'x': 
	    {
	      int val = va_arg (ap, int);

	      if (size != 0) 
		if (leading_zero)
		  sprintf (bp, "%0*x", size, val);
		else
		  sprintf (bp, "%*x", size, val);
	      else
		sprintf (bp, "%x", val);
	      inc_bp ();
	    }
	    break;
	  case 'd': 
	    {
	      int val = va_arg (ap, int);
	    
	      if (size != 0)
		sprintf (bp, "%*d", size, val);
	      else
		sprintf (bp, "%d", val);
	      inc_bp ();
	    }
	    break;
	  case 'r': 
	    {
	      /* Register.  */
	      int val = va_arg (ap, int);
	    
#define REG2NAME(num, name) case num: sprintf (bp, ""name); \
  regMap[(num < 32) ? 0 : 1] |= 1 << (num - ((num < 32) ? 0 : 32)); break;
	      
	      switch (val) 
		{
		  REG2NAME (26, "gp");
		  REG2NAME (27, "fp");
		  REG2NAME (28, "sp");
		  REG2NAME (29, "ilink1");
		  REG2NAME (30, "ilink2");
		  REG2NAME (31, "blink");
		  REG2NAME (60, "lp_count");
		default:
		  {
		    const char * ext;

		    ext = core_reg_name (state, val);
		    if (ext)
		      sprintf (bp, "%s", ext);
		    else
		      sprintf (bp,"r%d",val);
		  }
		  break;
		}
	      inc_bp ();
	    } break;
	  
	  case 'a': 
	    {
	      /* Aux Register.  */
	      int val = va_arg (ap, int);

#define AUXREG2NAME(num, name) case num: sprintf (bp,name); break;

	      switch (val) 
		{
		  AUXREG2NAME (0x0, "status");
		  AUXREG2NAME (0x1, "semaphore");
		  AUXREG2NAME (0x2, "lp_start");
		  AUXREG2NAME (0x3, "lp_end");
		  AUXREG2NAME (0x4, "identity");
		  AUXREG2NAME (0x5, "debug");
		default:
		  {
		    const char *ext;

		    ext = aux_reg_name (state, val);
		    if (ext)
		      sprintf (bp, "%s", ext);
		    else
		      my_sprintf (state, bp, "%h", val);
		  }
		  break;
		}
	      inc_bp ();
	    }
	    break;
	    
	  case 's': 
	    {
	      sprintf (bp, "%s", va_arg (ap, char *));
	      inc_bp ();
	    }
	    break;
	    
	  default:
	    fprintf (stderr, "?? format %c\n", p[-1]);
	    break;
	  }
      }

 DOCOMM: *bp = 0;
}

static void 
write_comments_(state, shimm, is_limm, limm_value)
     struct arcDisState * state;
     int shimm;
     int is_limm;
     long limm_value;
{
  if (state->commentBuffer != 0) 
d62 2
a63 17
      int i;

      if (is_limm) 
	{
	  const char *name = post_address (state, limm_value + shimm);

	  if (*name != 0)
	    WRITE_COMMENT (name);
	}
      for (i = 0; i < state->commNum; i++) 
	{
	  if (i == 0)
	    strcpy (state->commentBuffer, comment_prefix);
	  else
	    strcat (state->commentBuffer, ", ");	
	  strncat (state->commentBuffer, state->comm[i], sizeof (state->commentBuffer));
	}
d65 4
a68 35
}

#define write_comments2(x) write_comments_(state, x, is_limm, limm_value)
#define write_comments() write_comments2(0)

static const char *condName[] = {
  /* 0..15.  */
  ""   , "z"  , "nz" , "p"  , "n"  , "c"  , "nc" , "v"  , 
  "nv" , "gt" , "ge" , "lt" , "le" , "hi" , "ls" , "pnz"
};

static void 
write_instr_name_(state, instrName, cond, condCodeIsPartOfName, flag, signExtend, addrWriteBack, directMem)
     struct arcDisState * state;
     const char * instrName;
     int cond;
     int condCodeIsPartOfName;
     int flag;
     int signExtend;
     int addrWriteBack;
     int directMem;
{
  strcpy (state->instrBuffer, instrName);

  if (cond > 0) 
    {
      const char *cc = 0;

      if (!condCodeIsPartOfName)
	strcat (state->instrBuffer, ".");

      if (cond < 16)
	cc = condName[cond];
      else
	cc = cond_code_name (state, cond);
d70 1
a70 5
      if (!cc)
	cc = "???";

      strcat (state->instrBuffer, cc);
    }
d72 2
a73 2
  if (flag)
    strcat (state->instrBuffer, ".f");
d75 2
a76 1
  switch (state->nullifyMode) 
d78 56
a133 127
    case BR_exec_always:
      strcat (state->instrBuffer, ".d");
      break;
    case BR_exec_when_jump:
      strcat (state->instrBuffer, ".jd");
      break;
    }

  if (signExtend)
    strcat (state->instrBuffer, ".x");

  if (addrWriteBack)
    strcat (state->instrBuffer, ".a");

  if (directMem)
    strcat (state->instrBuffer, ".di");
}

#define write_instr_name()						\
  do									\
    {									\
      write_instr_name_(state, instrName,cond, condCodeIsPartOfName,	\
			flag, signExtend, addrWriteBack, directMem);	\
      formatString[0] = '\0';						\
    }									\
  while (0)

enum { 
  op_LD0 = 0, op_LD1 = 1, op_ST  = 2, op_3   = 3, 
  op_BC  = 4, op_BLC = 5, op_LPC = 6, op_JC  = 7,
  op_ADD = 8, op_ADC = 9, op_SUB = 10, op_SBC = 11, 
  op_AND = 12, op_OR  = 13, op_BIC = 14, op_XOR = 15
};

extern disassemble_info tm_print_insn_info;

static int 
dsmOneArcInst (addr, state)
     bfd_vma              addr;
     struct arcDisState * state;
{
  int condCodeIsPartOfName = 0;
  int decodingClass;
  const char * instrName;
  int repeatsOp = 0;
  int fieldAisReg = 1;
  int fieldBisReg = 1;
  int fieldCisReg = 1;
  int fieldA;
  int fieldB;
  int fieldC = 0;
  int flag = 0;
  int cond = 0;
  int is_shimm = 0;
  int is_limm = 0;
  long limm_value = 0;
  int signExtend = 0;
  int addrWriteBack = 0;
  int directMem = 0;
  int is_linked = 0;
  int offset = 0;
  int usesAuxReg = 0;
  int flags;
  int ignoreFirstOpd;
  char formatString[60];
  
  state->instructionLen = 4;
  state->nullifyMode = BR_exec_when_no_jump;
  state->opWidth = 12;
  state->isBranch = 0;
  
  state->_mem_load = 0;
  state->_ea_present = 0;
  state->_load_len = 0;
  state->ea_reg1 = no_reg;
  state->ea_reg2 = no_reg;
  state->_offset = 0;
  
  if (! NEXT_WORD (0))
    return 0;
  
  state->_opcode = OPCODE (state->words[0]);
  instrName = 0;
  decodingClass = 0; /* default!  */
  repeatsOp = 0;
  condCodeIsPartOfName=0;
  state->commNum = 0;
  state->tcnt = 0;
  state->acnt = 0;
  state->flow = noflow;
  ignoreFirstOpd = 0;

  if (state->commentBuffer)
    state->commentBuffer[0] = '\0';

  switch (state->_opcode) 
    {
    case op_LD0: 
      switch (BITS (state->words[0],1,2)) 
	{
	case 0:
	  instrName = "ld";
	  state->_load_len = 4;
	  break;
	case 1:
	  instrName = "ldb";
	  state->_load_len = 1;
	  break;
	case 2:
	  instrName = "ldw";
	  state->_load_len = 2;
	  break;
	default:
	  instrName = "??? (0[3])"; 
	  state->flow = invalid_instr;
	  break;
	}
      decodingClass = 5; 
      break;
    
    case op_LD1: 
      if (BIT (state->words[0],13)) 
	{
	  instrName = "lr"; 
	  decodingClass = 10;
	}
      else 
d135 2
a136 1
	  switch (BITS (state->words[0],10,11)) 
d138 2
a139 16
	    case 0:
	      instrName = "ld";
	      state->_load_len = 4;
	      break;
	    case 1:
	      instrName = "ldb";
	      state->_load_len = 1;
	      break;
	    case 2:
	      instrName = "ldw";
	      state->_load_len = 2;
	      break;
	    default:
	      instrName = "??? (1[3])"; 
	      state->flow = invalid_instr;
	      break;
d141 5
a145 1
	  decodingClass = 6;
d147 2
a148 4
      break;
      
    case op_ST:
      if (BIT (state->words[0],25)) 
d150 3
a152 6
	  instrName = "sr";
	  decodingClass = 8;
	}
      else 
	{
	  switch (BITS (state->words[0],22,23)) 
d154 2
a155 13
	    case 0:
	      instrName = "st";
	      break;
	    case 1:
	      instrName = "stb";
	      break;
	    case 2:
	      instrName = "stw";
	      break;
	    default:
	      instrName = "??? (2[3])"; 
	      state->flow = invalid_instr;
	      break;
a156 75
	  decodingClass = 7;
	}
      break;
      
    case op_3:
      decodingClass = 1;  /* default for opcode 3...  */
      switch (FIELDC (state->words[0])) 
	{
	case  0:
	  instrName = "flag"; 
	  decodingClass = 2;
	  break;
	case  1:
	  instrName = "asr";
	  break;
	case  2:
	  instrName = "lsr";
	  break;
	case  3:
	  instrName = "ror";
	  break;
	case  4:
	  instrName = "rrc";
	  break;
	case  5:
	  instrName = "sexb";
	  break;
	case  6:
	  instrName = "sexw";
	  break;
	case  7:
	  instrName = "extb";
	  break;
	case  8:
	  instrName = "extw";
	  break;
	case  0x3f: 
	  {
	    decodingClass = 9;
	    switch( FIELDD (state->words[0]) ) 
	      {
	      case 0:
		instrName = "brk";
		break;
	      case 1:
		instrName = "sleep";
		break;
	      case 2:
		instrName = "swi";
		break;
	      default:
		instrName = "???";
		state->flow=invalid_instr;
		break;
	      }
	  }
	  break;
	  
	  /* ARC Extension Library Instructions
	     NOTE: We assume that extension codes are these instrs.  */
	default:
	  instrName = instruction_name (state,
					state->_opcode,
					FIELDC (state->words[0]),
					& flags);
	  if (!instrName)
	    {
	      instrName = "???";
	      state->flow = invalid_instr;
	    }
	  if (flags & IGNORE_FIRST_OPD)
	    ignoreFirstOpd = 1;
	  break;
	}
      break;
d158 4
a161 17
    case op_BC:
      instrName = "b";  
    case op_BLC:
      if (!instrName)
	instrName = "bl"; 
    case op_LPC:
      if (!instrName)
	instrName = "lp"; 
    case op_JC:
      if (!instrName)
	{
	  if (BITS (state->words[0],9,9)) 
	    {
	      instrName = "jl";  
	      is_linked = 1;
	    }
	  else 
d163 3
a165 2
	      instrName = "j";  
	      is_linked = 0;
d167 1
a167 11
	}
      condCodeIsPartOfName = 1;
      decodingClass = ((state->_opcode == op_JC) ? 4 : 3);
      state->isBranch = 1;
      break;
    
    case op_ADD:
    case op_ADC:
    case op_AND:
      repeatsOp = (FIELDC (state->words[0]) == FIELDB (state->words[0]));
      decodingClass = 0;
d169 3
a171 255
      switch (state->_opcode) 
	{
	case op_ADD:
	  instrName = (repeatsOp ? "asl" : "add");
	  break;
	case op_ADC:
	  instrName = (repeatsOp ? "rlc" : "adc");
	  break;
	case op_AND:
	  instrName = (repeatsOp ? "mov" : "and");
	  break;
	}
      break;
      
    case op_SUB: instrName = "sub";
      break;
    case op_SBC: instrName = "sbc";
      break;
    case op_OR:  instrName = "or";
      break;
    case op_BIC: instrName = "bic";
      break;

    case op_XOR:
      if (state->words[0] == 0x7fffffff)
	{
	  /* nop encoded as xor -1, -1, -1  */
	  instrName = "nop";
	  decodingClass = 9;
	}
      else 
	instrName = "xor";
      break;
      
    default:
      instrName = instruction_name (state,state->_opcode,0,&flags);
      /* if (instrName) printf("FLAGS=0x%x\n", flags);  */
      if (!instrName)
	{
	  instrName = "???";
	  state->flow=invalid_instr;
	}
      if (flags & IGNORE_FIRST_OPD)
	ignoreFirstOpd = 1;
      break;
    }
  
  fieldAisReg = fieldBisReg = fieldCisReg = 1; /* Assume regs for now.  */
  flag = cond = is_shimm = is_limm = 0;
  state->nullifyMode = BR_exec_when_no_jump;	/* 0  */
  signExtend = addrWriteBack = directMem = 0;
  usesAuxReg = 0;
  
  switch (decodingClass) 
    {
    case 0:
      CHECK_FIELD_A ();
      CHECK_FIELD_B ();
      if (!repeatsOp)
	CHECK_FIELD_C ();
      CHECK_FLAG_COND_NULLIFY ();
      
      write_instr_name ();
      if (!ignoreFirstOpd) 
	{
	  WRITE_FORMAT_x (A);
	  WRITE_FORMAT_COMMA_x (B);
	  if (!repeatsOp)
	    WRITE_FORMAT_COMMA_x (C);
	  WRITE_NOP_COMMENT ();
	  my_sprintf (state, state->operandBuffer, formatString, fieldA, fieldB, fieldC);
	}
      else 
	{
	  WRITE_FORMAT_x (B);
	  if (!repeatsOp)
	    WRITE_FORMAT_COMMA_x (C);
	  my_sprintf (state, state->operandBuffer, formatString, fieldB, fieldC);
	}
      write_comments ();
      break;
      
    case 1:
      CHECK_FIELD_A ();
      CHECK_FIELD_B ();
      CHECK_FLAG_COND_NULLIFY ();
      
      write_instr_name ();
      if (!ignoreFirstOpd) 
	{
	  WRITE_FORMAT_x (A);
	  WRITE_FORMAT_COMMA_x (B);
	  WRITE_NOP_COMMENT ();
	  my_sprintf (state, state->operandBuffer, formatString, fieldA, fieldB); 
	}
      else 
	{
	  WRITE_FORMAT_x (B);
	  my_sprintf (state, state->operandBuffer, formatString, fieldB); 
	}
      write_comments ();
      break;
      
    case 2:
      CHECK_FIELD_B ();
      CHECK_FLAG_COND_NULLIFY ();
      flag = 0; /* this is the FLAG instruction -- it's redundant  */
      
      write_instr_name ();
      WRITE_FORMAT_x (B);
      my_sprintf (state, state->operandBuffer, formatString, fieldB);
      write_comments ();
      break;
      
    case 3:
      fieldA = BITS (state->words[0],7,26) << 2;
      fieldA = (fieldA << 10) >> 10; /* make it signed  */
      fieldA += addr + 4;
      CHECK_FLAG_COND_NULLIFY ();
      flag = 0;
      
      write_instr_name ();
      /* This address could be a label we know. Convert it.  */
      if (state->_opcode != op_LPC /* LP  */) 
	{
	add_target (fieldA); /* For debugger.  */
	state->flow = state->_opcode == op_BLC /* BL  */
	  ? direct_call
	  : direct_jump;
	/* indirect calls are achieved by "lr blink,[status];
	   lr dest<- func addr; j [dest]"  */
	}           		
      
      strcat (formatString, "%s"); /* address/label name */
      my_sprintf (state, state->operandBuffer, formatString, post_address (state, fieldA));
      write_comments ();
      break;
      
    case 4:
      /* For op_JC -- jump to address specified.
	 Also covers jump and link--bit 9 of the instr. word
	 selects whether linked, thus "is_linked" is set above.  */
      fieldA = 0;
      CHECK_FIELD_B ();
      CHECK_FLAG_COND_NULLIFY ();
      
      if (!fieldBisReg) 
	{
	  fieldAisReg = 0;
	  fieldA = (fieldB >> 25) & 0x7F; /* flags */
	  fieldB = (fieldB & 0xFFFFFF) << 2;
	  state->flow = is_linked ? direct_call : direct_jump;
	  add_target (fieldB);
	  /* screwy JLcc requires .jd mode to execute correctly
	   * but we pretend it is .nd (no delay slot).  */
	  if (is_linked && state->nullifyMode == BR_exec_when_jump)
	    state->nullifyMode = BR_exec_when_no_jump;
	}
      else 
	{
	  state->flow = is_linked ? indirect_call : indirect_jump;
	  /* We should also treat this as indirect call if NOT linked
	   * but the preceding instruction was a "lr blink,[status]"
	   * and we have a delay slot with "add blink,blink,2".
	   * For now we can't detect such.  */
	  state->register_for_indirect_jump = fieldB;
	}
      
      write_instr_name ();
      strcat (formatString, 
	      IS_REG (B) ? "[%r]" : "%s"); /* address/label name  */
      if (fieldA != 0) 
	{
	  fieldAisReg = 0;
	  WRITE_FORMAT_COMMA_x (A);
	}
      if (IS_REG (B))
	my_sprintf (state, state->operandBuffer, formatString, fieldB, fieldA);
      else
	my_sprintf (state, state->operandBuffer, formatString, 
		    post_address (state, fieldB), fieldA);
      write_comments ();
      break;
      
    case 5:
      /* LD instruction.
	 B and C can be regs, or one (both?) can be limm.  */
      CHECK_FIELD_A ();
      CHECK_FIELD_B ();
      CHECK_FIELD_C ();
      if (dbg)
	printf ("5:b reg %d %d c reg %d %d  \n",
		fieldBisReg,fieldB,fieldCisReg,fieldC);
      state->_offset = 0;
      state->_ea_present = 1;
      if (fieldBisReg)
	state->ea_reg1 = fieldB;
      else
	state->_offset += fieldB;
      if (fieldCisReg)
	state->ea_reg2 = fieldC;
      else
	state->_offset += fieldC;
      state->_mem_load = 1;
      
      directMem     = BIT (state->words[0],5);
      addrWriteBack = BIT (state->words[0],3);
      signExtend    = BIT (state->words[0],0);
      
      write_instr_name ();
      WRITE_FORMAT_x_COMMA_LB(A);
      if (fieldBisReg || fieldB != 0)
	WRITE_FORMAT_x_COMMA (B);
      else
	fieldB = fieldC;
      
      WRITE_FORMAT_x_RB (C);
      my_sprintf (state, state->operandBuffer, formatString, fieldA, fieldB, fieldC);
      write_comments ();
      break;
      
    case 6:
      /* LD instruction.  */
      CHECK_FIELD_B ();
      CHECK_FIELD_A ();
      fieldC = FIELDD (state->words[0]);
      
      if (dbg)
	printf ("6:b reg %d %d c 0x%x  \n",
		fieldBisReg, fieldB, fieldC);
      state->_ea_present = 1;
      state->_offset = fieldC;
      state->_mem_load = 1;
      if (fieldBisReg)
	state->ea_reg1 = fieldB;
      /* field B is either a shimm (same as fieldC) or limm (different!)
	 Say ea is not present, so only one of us will do the name lookup.  */
      else
	state->_offset += fieldB, state->_ea_present = 0;
      
      directMem     = BIT (state->words[0],14);
      addrWriteBack = BIT (state->words[0],12);
      signExtend    = BIT (state->words[0],9);
      
      write_instr_name ();
      WRITE_FORMAT_x_COMMA_LB (A);
      if (!fieldBisReg) 
	{
	  fieldB = state->_offset;
	  WRITE_FORMAT_x_RB (B);
	}
      else 
	{
	  WRITE_FORMAT_x (B);
	  if (fieldC != 0 && !BIT (state->words[0],13)) 
d173 2
a174 2
	      fieldCisReg = 0;
	      WRITE_FORMAT_COMMA_x_RB (C);
a176 40
	    WRITE_FORMAT_RB ();
	}
      my_sprintf (state, state->operandBuffer, formatString, fieldA, fieldB, fieldC);
      write_comments ();
      break;
      
    case 7:
      /* ST instruction.  */
      CHECK_FIELD_B();
      CHECK_FIELD_C();
      fieldA = FIELDD(state->words[0]); /* shimm  */
      
      /* [B,A offset]  */
      if (dbg) printf("7:b reg %d %x off %x\n",
				 fieldBisReg,fieldB,fieldA);
      state->_ea_present = 1;
      state->_offset = fieldA;
      if (fieldBisReg)
	state->ea_reg1 = fieldB;
      /* field B is either a shimm (same as fieldA) or limm (different!) 
	 Say ea is not present, so only one of us will do the name lookup.
	 (for is_limm we do the name translation here).  */
      else 
	state->_offset += fieldB, state->_ea_present = 0;
      
      directMem     = BIT(state->words[0],26);
      addrWriteBack = BIT(state->words[0],24);
      
      write_instr_name();
      WRITE_FORMAT_x_COMMA_LB(C);
	    
      if (!fieldBisReg) 
	{
	  fieldB = state->_offset;
	  WRITE_FORMAT_x_RB(B);
	}
      else 
	{
	  WRITE_FORMAT_x(B);
	  if (fieldBisReg && fieldA != 0) 
d178 35
a212 2
	      fieldAisReg = 0;
	      WRITE_FORMAT_COMMA_x_RB(A);
d214 10
d225 1
a225 1
	    WRITE_FORMAT_RB();
d227 3
a229 47
      my_sprintf (state, state->operandBuffer, formatString, fieldC, fieldB, fieldA);
      write_comments2(fieldA);
      break;
    case 8:
      /* SR instruction  */
      CHECK_FIELD_B();
      CHECK_FIELD_C();
      
      write_instr_name();
      WRITE_FORMAT_x_COMMA_LB(C);
      /* Try to print B as an aux reg if it is not a core reg.  */
      usesAuxReg = 1;
      WRITE_FORMAT_x(B);
      WRITE_FORMAT_RB();
      my_sprintf (state, state->operandBuffer, formatString, fieldC, fieldB);
      write_comments();
      break;
      
    case 9:
      write_instr_name();
      state->operandBuffer[0] = '\0';
      break;
      
    case 10:
      /* LR instruction */
      CHECK_FIELD_A();
      CHECK_FIELD_B();
      
      write_instr_name();
      WRITE_FORMAT_x_COMMA_LB(A);
      /* Try to print B as an aux reg if it is not a core reg. */
      usesAuxReg = 1;
      WRITE_FORMAT_x(B);
      WRITE_FORMAT_RB();
      my_sprintf (state, state->operandBuffer, formatString, fieldA, fieldB);
      write_comments();
      break;
      
    case 11:
      CHECK_COND();
      write_instr_name();
      state->operandBuffer[0] = '\0';
      break;
      
    default:
      mwerror (state, "Bad decoding class in ARC disassembler");
      break;
a230 5
  
  state->_cond = cond;
  return state->instructionLen = offset;
}

d232 2
a233 7
/* Returns the name the user specified core extension register.  */
static const char *
_coreRegName(arg, regval)
     void * arg ATTRIBUTE_UNUSED;
     int regval;
{
  return arcExtMap_coreRegName (regval);
d236 4
a239 6
/* Returns the name the user specified AUX extension register.  */
static const char *
_auxRegName(void *_this ATTRIBUTE_UNUSED, int regval)
{
    return arcExtMap_auxRegName(regval);
}
d241 4
a244 4

/* Returns the name the user specified condition code name.  */
static const char *
_condCodeName(void *_this ATTRIBUTE_UNUSED, int regval)
d246 6
a251 1
    return arcExtMap_condCodeName(regval);
d254 4
a257 3
/* Returns the name the user specified extension instruction.  */
static const char *
_instName (void *_this ATTRIBUTE_UNUSED, int majop, int minop, int *flags)
d259 1
a259 1
    return arcExtMap_instName(majop, minop, flags);
a261 2
/* Decode an instruction returning the size of the instruction
   in bytes or zero if unrecognized.  */
d263 3
a265 64
decodeInstr (address, info)
     bfd_vma            address; /* Address of this instruction.  */
     disassemble_info * info;
{
  int status;
  bfd_byte buffer[4];
  struct arcDisState s;	/* ARC Disassembler state  */
  void *stream = info->stream; /* output stream  */
  fprintf_ftype func = info->fprintf_func; 
  int bytes;
  
  memset (&s, 0, sizeof(struct arcDisState));
  
  /* read first instruction  */
  status = (*info->read_memory_func) (address, buffer, 4, info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, address, info);
      return 0;
    }
  if (info->endian == BFD_ENDIAN_LITTLE)
    s.words[0] = bfd_getl32(buffer);
  else
    s.words[0] = bfd_getb32(buffer);
  /* always read second word in case of limm  */

  /* we ignore the result since last insn may not have a limm  */
  status = (*info->read_memory_func) (address + 4, buffer, 4, info);
  if (info->endian == BFD_ENDIAN_LITTLE)
    s.words[1] = bfd_getl32(buffer);
  else
    s.words[1] = bfd_getb32(buffer);

  s._this = &s;
  s.coreRegName = _coreRegName;
  s.auxRegName = _auxRegName;
  s.condCodeName = _condCodeName;
  s.instName = _instName;

  /* disassemble  */
  bytes = dsmOneArcInst(address, (void *)&s);

  /* display the disassembly instruction  */
  (*func) (stream, "%08x ", s.words[0]);
  (*func) (stream, "    ");
  
  (*func) (stream, "%-10s ", s.instrBuffer);
  
  if (__TRANSLATION_REQUIRED(s))
    {
      bfd_vma addr = s.addresses[s.operandBuffer[1] - '0'];
      (*info->print_address_func) ((bfd_vma) addr, info);
      (*func) (stream, "\n");
    }
  else
    (*func) (stream, "%s",s.operandBuffer);
  return s.instructionLen;
}

/* Return the print_insn function to use.
   Side effect: load (possibly empty) extension section  */

disassembler_ftype
arc_get_disassembler (void *ptr)
d267 1
a267 3
  if (ptr)
    build_ARC_extmap (ptr);
  return decodeInstr;
@


1.1.1.3
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002
d20 2
a21 2
#include "ansidecl.h"
#include "libiberty.h"
d29 1
d38 6
a43 6
#define BIT(word,n)	((word) & (1 << n))
#define BITS(word,s,e)  (((word) << (31 - e)) >> (s + (31 - e)))
#define OPCODE(word)	(BITS ((word), 27, 31))
#define FIELDA(word)	(BITS ((word), 21, 26))
#define FIELDB(word)	(BITS ((word), 15, 20))
#define FIELDC(word)	(BITS ((word),  9, 14))
d47 1
a47 1
#define FIELDD(word)	(BITS (((signed int)word), 0, 8))
d49 7
a55 7
#define PUT_NEXT_WORD_IN(a)						\
  do									\
    {									\
      if (is_limm == 1 && !NEXT_WORD (1))				\
        mwerror (state, _("Illegal limm reference in last instruction!\n")); \
      a = state->words[1];						\
    }									\
d101 1
a101 1
      fieldA = FIELDA (state->words[0]);	\
d139 1
a139 1
#define WRITE_FORMAT_RB()	strcat (formatString, "]")
d141 1
a141 1
#define WRITE_NOP_COMMENT()	if (!fieldAisReg && !flag) WRITE_COMMENT ("nop");
d143 1
a143 1
#define NEXT_WORD(x)	(offset += 4, state->words[x])
d145 1
a145 1
#define add_target(x)	(state->targets[state->tcnt++] = (x))
a148 15
static const char *core_reg_name PARAMS ((struct arcDisState *, int));
static const char *aux_reg_name PARAMS ((struct arcDisState *, int));
static const char *cond_code_name PARAMS ((struct arcDisState *, int));
static const char *instruction_name
  PARAMS ((struct arcDisState *, int, int, int *));
static void mwerror PARAMS ((struct arcDisState *, const char *));
static const char *post_address PARAMS ((struct arcDisState *, int));
static void write_comments_
  PARAMS ((struct arcDisState *, int, int, long int));
static void write_instr_name_
  PARAMS ((struct arcDisState *, const char *, int, int, int, int, int, int));
static int dsmOneArcInst PARAMS ((bfd_vma, struct arcDisState *));
static const char *_coreRegName PARAMS ((void *, int));
static int decodeInstr PARAMS ((bfd_vma, disassemble_info *));

d152 1
a152 1
     int                  val;
d162 1
a162 1
     int                  val;
d172 1
a172 1
     int                  val;
d184 1
a184 1
     int *  flags;
d194 1
a194 1
     const char * msg;
d203 1
a203 1
     int addr;
d216 1
a216 1

d222 6
a227 6
static void my_sprintf PARAMS ((struct arcDisState *, char *, const char *,
				...));

static void
my_sprintf VPARAMS ((struct arcDisState *state, char *buf, const char *format,
		     ...))
d229 1
a229 1
  char *bp;
d233 5
a237 7

  VA_OPEN (ap, format);
  VA_FIXEDARG (ap, struct arcDisState *, state);
  VA_FIXEDARG (ap, char *, buf);
  VA_FIXEDARG (ap, const char *, format);

  bp = buf;
d243 2
a244 2

  while (1)
d247 4
a250 4
      case 0:
	goto DOCOMM; /* (return)  */
      default:
	*bp++ = p[-1];
d256 1
a256 1
	switch (*p++)
d282 1
a282 1
	  case 'h':
d289 1
a289 1
	      if (u > 65536)
d291 1
a291 1
	      else
d294 1
a294 1
	    }
d296 1
a296 1
	  case 'X': case 'x':
d300 1
a300 1
	      if (size != 0)
d310 1
a310 1
	  case 'd':
d313 1
a313 1

d321 1
a321 1
	  case 'r':
d325 1
a325 1

d328 2
a329 2

	      switch (val)
d352 2
a353 2

	  case 'a':
d360 1
a360 1
	      switch (val)
d383 2
a384 2

	  case 's':
d390 1
a390 1

a397 1
  VA_CLOSE (ap);
d400 1
a400 1
static void
d407 1
a407 1
  if (state->commentBuffer != 0)
d411 1
a411 1
      if (is_limm)
d418 1
a418 1
      for (i = 0; i < state->commNum; i++)
d423 2
a424 3
	    strcat (state->commentBuffer, ", ");
	  strncat (state->commentBuffer, state->comm[i],
		   sizeof (state->commentBuffer));
d434 1
a434 1
  ""   , "z"  , "nz" , "p"  , "n"  , "c"  , "nc" , "v"  ,
d438 1
a438 1
static void
d451 1
a451 1
  if (cond > 0)
d472 1
a472 1
  switch (state->nullifyMode)
d501 2
a502 2
enum {
  op_LD0 = 0, op_LD1 = 1, op_ST  = 2, op_3   = 3,
d504 1
a504 1
  op_ADD = 8, op_ADC = 9, op_SUB = 10, op_SBC = 11,
d510 1
a510 1
static int
d539 1
a539 1

d544 1
a544 1

d551 1
a551 1

d554 1
a554 1

d569 1
a569 1
  switch (state->_opcode)
d571 2
a572 2
    case op_LD0:
      switch (BITS (state->words[0],1,2))
d587 1
a587 1
	  instrName = "??? (0[3])";
d591 1
a591 1
      decodingClass = 5;
d593 3
a595 3

    case op_LD1:
      if (BIT (state->words[0],13))
d597 1
a597 1
	  instrName = "lr";
d600 1
a600 1
      else
d602 1
a602 1
	  switch (BITS (state->words[0],10,11))
d617 1
a617 1
	      instrName = "??? (1[3])";
d624 1
a624 1

d626 1
a626 1
      if (BIT (state->words[0],25))
d631 1
a631 1
      else
d633 1
a633 1
	  switch (BITS (state->words[0],22,23))
d645 1
a645 1
	      instrName = "??? (2[3])";
d652 1
a652 1

d655 1
a655 1
      switch (FIELDC (state->words[0]))
d658 1
a658 1
	  instrName = "flag";
d685 1
a685 1
	case  0x3f:
d688 1
a688 1
	    switch( FIELDD (state->words[0]) )
d706 1
a706 1

d713 1
a713 1
					&flags);
d726 1
a726 1
      instrName = "b";
d729 1
a729 1
	instrName = "bl";
d732 1
a732 1
	instrName = "lp";
d736 1
a736 1
	  if (BITS (state->words[0],9,9))
d738 1
a738 1
	      instrName = "jl";
d741 1
a741 1
	  else
d743 1
a743 1
	      instrName = "j";
d751 1
a751 1

d758 1
a758 1
      switch (state->_opcode)
d771 1
a771 1

d788 1
a788 1
      else
d791 1
a791 1

d804 1
a804 1

d810 2
a811 2

  switch (decodingClass)
d819 1
a819 1

d821 1
a821 1
      if (!ignoreFirstOpd)
d828 1
a828 2
	  my_sprintf (state, state->operandBuffer, formatString,
		      fieldA, fieldB, fieldC);
d830 1
a830 1
      else
d835 1
a835 2
	  my_sprintf (state, state->operandBuffer, formatString,
		      fieldB, fieldC);
d839 1
a839 1

d844 1
a844 1

d846 1
a846 1
      if (!ignoreFirstOpd)
d851 1
a851 2
	  my_sprintf (state, state->operandBuffer, formatString,
		      fieldA, fieldB);
d853 1
a853 1
      else
d856 1
a856 1
	  my_sprintf (state, state->operandBuffer, formatString, fieldB);
d860 1
a860 1

d865 1
a865 1

d871 1
a871 1

d878 1
a878 1

d881 1
a881 1
      if (state->_opcode != op_LPC /* LP  */)
d883 8
a890 8
	  add_target (fieldA); /* For debugger.  */
	  state->flow = state->_opcode == op_BLC /* BL  */
	    ? direct_call
	    : direct_jump;
	  /* indirect calls are achieved by "lr blink,[status];
	     lr dest<- func addr; j [dest]"  */
	}

d892 1
a892 2
      my_sprintf (state, state->operandBuffer, formatString,
		  post_address (state, fieldA));
d895 1
a895 1

d903 2
a904 2

      if (!fieldBisReg)
d916 1
a916 1
      else
d925 1
a925 1

d927 1
a927 1
      strcat (formatString,
d929 1
a929 1
      if (fieldA != 0)
d937 1
a937 1
	my_sprintf (state, state->operandBuffer, formatString,
d941 1
a941 1

d962 1
a962 1

d966 1
a966 1

d973 1
a973 1

d975 1
a975 2
      my_sprintf (state, state->operandBuffer, formatString,
		  fieldA, fieldB, fieldC);
d978 1
a978 1

d984 1
a984 1

d997 1
a997 1

d1001 1
a1001 1

d1004 1
a1004 1
      if (!fieldBisReg)
d1009 1
a1009 1
      else
d1012 1
a1012 1
	  if (fieldC != 0 && !BIT (state->words[0],13))
d1020 1
a1020 2
      my_sprintf (state, state->operandBuffer, formatString,
		  fieldA, fieldB, fieldC);
d1023 1
a1023 1

d1029 1
a1029 1

d1032 1
a1032 1
		      fieldBisReg,fieldB,fieldA);
d1037 1
a1037 1
      /* field B is either a shimm (same as fieldA) or limm (different!)
d1040 1
a1040 1
      else
d1042 1
a1042 1

d1045 1
a1045 1

d1048 2
a1049 2

      if (!fieldBisReg)
d1054 1
a1054 1
      else
d1057 1
a1057 1
	  if (fieldBisReg && fieldA != 0)
d1065 1
a1065 2
      my_sprintf (state, state->operandBuffer, formatString,
		  fieldC, fieldB, fieldA);
d1072 1
a1072 1

d1082 1
a1082 1

d1087 1
a1087 1

d1092 1
a1092 1

d1102 1
a1102 1

d1108 1
a1108 1

d1113 1
a1113 1

d1132 1
a1132 1
  return arcExtMap_auxRegName(regval);
d1140 1
a1140 1
  return arcExtMap_condCodeName(regval);
d1147 1
a1147 1
  return arcExtMap_instName(majop, minop, flags);
d1161 1
a1161 1
  fprintf_ftype func = info->fprintf_func;
d1163 1
a1163 1

d1165 1
a1165 1

d1198 1
a1198 1

d1200 1
a1200 1

@


