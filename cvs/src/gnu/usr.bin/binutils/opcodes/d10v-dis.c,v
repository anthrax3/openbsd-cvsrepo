head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.4.0.54
	OPENBSD_6_1_BASE:1.1.1.4
	OPENBSD_6_0:1.1.1.4.0.50
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.46
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.48
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.40
	OPENBSD_5_7_BASE:1.1.1.4
	OPENBSD_5_6:1.1.1.4.0.44
	OPENBSD_5_6_BASE:1.1.1.4
	OPENBSD_5_5:1.1.1.4.0.42
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.38
	OPENBSD_5_4_BASE:1.1.1.4
	OPENBSD_5_3:1.1.1.4.0.36
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.34
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.32
	OPENBSD_5_0:1.1.1.4.0.30
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.28
	OPENBSD_4_9_BASE:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.26
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.22
	OPENBSD_4_7_BASE:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.24
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.20
	OPENBSD_4_5_BASE:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.18
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.16
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.14
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.12
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.10
	OPENBSD_4_0_BASE:1.1.1.4
	OPENBSD_3_9:1.1.1.4.0.8
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.6
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.4
	OPENBSD_3_7_BASE:1.1.1.4
	BINUTILS_2_15:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.1.1.3.0.8
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.6
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.4
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.2
	OPENBSD_3_2_BASE:1.1.1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.1.1.2.0.8
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.6
	OPENBSD_3_0_BASE:1.1.1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.1.1.2.0.4
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.2
	OPENBSD_2_8_BASE:1.1.1.2
	BINUTILS-2_10:1.1.1.2
	FSF:1.1.1
	OPENBSD_2_7:1.1.1.1.0.14
	OPENBSD_2_7_BASE:1.1.1.1
	new-binutils:1.1.1.1.0.12
	OPENBSD_2_6:1.1.1.1.0.10
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.8
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.6
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.4
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.2
	OPENBSD_2_2_BASE:1.1.1.1
	BINUTILS-2_8_1:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	97.05.29.09.27.50;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.29.09.27.50;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.47.51;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.55.49;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.43;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* Disassemble D10V instructions.
   Copyright (C) 1996, 1997 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */


#include <stdio.h>

#include "ansidecl.h"
#include "opcode/d10v.h" 
#include "dis-asm.h"

/* the PC wraps at 18 bits, except for the segment number */
/* so use this mask to keep the parts we want */
#define PC_MASK	0x03003FFF

static void dis_2_short PARAMS ((unsigned long insn, bfd_vma memaddr, 
				 struct disassemble_info *info, int order));
static void dis_long PARAMS ((unsigned long insn, bfd_vma memaddr, 
			      struct disassemble_info *info));

int 
print_insn_d10v (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
{
  int status;
  bfd_byte buffer[4];
  unsigned long insn;

  status = (*info->read_memory_func) (memaddr, buffer, 4, info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, memaddr, info);
      return -1;
    }
  insn = bfd_getb32 (buffer);

  status = insn & FM11;
  switch (status) {
  case 0:
    dis_2_short (insn, memaddr, info, 2);
    break;
  case FM01:
    dis_2_short (insn, memaddr, info, 0);
    break;
  case FM10:
    dis_2_short (insn, memaddr, info, 1);
    break;
  case FM11:
    dis_long (insn, memaddr, info);
    break;
  }
  return 4;
}

static void
print_operand (oper, insn, op, memaddr, info)
     struct d10v_operand *oper;
     unsigned long insn;
     struct d10v_opcode *op;
     bfd_vma memaddr;
     struct disassemble_info *info;
{
  int num, shift;

  if (oper->flags == OPERAND_ATMINUS)
    {
      (*info->fprintf_func) (info->stream, "@@-");   
      return;
    }
  if (oper->flags == OPERAND_MINUS)
    {
      (*info->fprintf_func) (info->stream, "-");   
      return;
    }
  if (oper->flags == OPERAND_PLUS)
    {
      (*info->fprintf_func) (info->stream, "+");   
      return;
    }
  if (oper->flags == OPERAND_ATSIGN)
    {
      (*info->fprintf_func) (info->stream, "@@");   
      return;
    }
  if (oper->flags == OPERAND_ATPAR)
    {
      (*info->fprintf_func) (info->stream, "@@(");   
      return;
    }

  shift = oper->shift;

  /* the LONG_L format shifts registers over by 15 */
  if (op->format == LONG_L && (oper->flags & OPERAND_REG))
    shift += 15;

  num = (insn >> shift) & (0x7FFFFFFF >> (31 - oper->bits));

  if (oper->flags & OPERAND_REG)
    {
      int i;
      int match=0;
      num += oper->flags & (OPERAND_ACC|OPERAND_FLAG|OPERAND_CONTROL);
      for (i = 0; i < d10v_reg_name_cnt(); i++)
	{
	  if (num == d10v_predefined_registers[i].value)
	    {
	      if (d10v_predefined_registers[i].pname)
		(*info->fprintf_func) (info->stream, "%s",d10v_predefined_registers[i].pname);
	      else
		(*info->fprintf_func) (info->stream, "%s",d10v_predefined_registers[i].name);
	      match=1;
	      break;
	    }
	}
      if (match == 0)
	{
	  /* this would only get executed if a register was not in the 
	     register table */
	  if (oper->flags & OPERAND_ACC)
	    (*info->fprintf_func) (info->stream, "a");
	  else if (oper->flags & OPERAND_CONTROL)
	    (*info->fprintf_func) (info->stream, "cr");
	  else if(oper->flags & OPERAND_REG)
	    (*info->fprintf_func) (info->stream, "r");
	  (*info->fprintf_func) (info->stream, "%d",num);
	}
    }
  else
    {
      /* addresses are right-shifted by 2 */
      if (oper->flags & OPERAND_ADDR)
	{
	  long max;
	  int neg=0;
	  max = (1 << (oper->bits - 1));
	  if (num & max)
	    {
	      num = -num & ((1 << oper->bits)-1);
	      neg = 1;
	    }
	  num = num<<2;
	  if (neg)
	    (*info->print_address_func) ((memaddr - num) & PC_MASK, info);
	  else
	    (*info->print_address_func) ((memaddr + num) & PC_MASK, info);
	}
      else
	{
	  if (oper->flags & OPERAND_SIGNED)
	    {
	      int max = (1 << (oper->bits - 1));
	      if (num & max)
		{
		  num = -num & ((1 << oper->bits)-1);
		  (*info->fprintf_func) (info->stream, "-");
		}
	    }
	  (*info->fprintf_func) (info->stream, "0x%x",num);
	}
    }
}


static void
dis_long (insn, memaddr, info)
     unsigned long insn;
     bfd_vma memaddr;
     struct disassemble_info *info;
{
  int i;
  char buf[32];
  struct d10v_opcode *op = (struct d10v_opcode *)d10v_opcodes;
  struct d10v_operand *oper;
  int need_paren = 0;
  int match = 0;

  while (op->name)
    {
      if ((op->format & LONG_OPCODE) && ((op->mask & insn) == op->opcode))
	{
	  match = 1;
	  (*info->fprintf_func) (info->stream, "%s\t", op->name);   
	  for ( i=0; op->operands[i]; i++)
	    {
	      oper = (struct d10v_operand *)&d10v_operands[op->operands[i]];
	      if (oper->flags == OPERAND_ATPAR)
		need_paren = 1;
	      print_operand (oper, insn, op, memaddr, info);
	      if (op->operands[i+1] && oper->bits &&
		  d10v_operands[op->operands[i+1]].flags != OPERAND_PLUS &&
		  d10v_operands[op->operands[i+1]].flags != OPERAND_MINUS)
		(*info->fprintf_func) (info->stream, ", ");   
	    }
	  break;
	}
      op++;
    }

  if (!match)
    (*info->fprintf_func) (info->stream, ".long\t0x%08x",insn);   

  if (need_paren)
    (*info->fprintf_func) (info->stream, ")");   
}

static void
dis_2_short (insn, memaddr, info, order)
     unsigned long insn;
     bfd_vma memaddr;
     struct disassemble_info *info;
     int order;
{
  int i,j;
  char astr[2][32];
  unsigned int ins[2];
  struct d10v_opcode *op;
  char buf[32];
  int match, num_match=0;
  struct d10v_operand *oper;
  int need_paren = 0;

  ins[0] = (insn & 0x3FFFFFFF) >> 15;
  ins[1] = insn & 0x00007FFF;

  for(j=0;j<2;j++)
    {
      op = (struct d10v_opcode *)d10v_opcodes;
      match=0;
      while (op->name)
	{
	  if ((op->format & SHORT_OPCODE) && ((op->mask & ins[j]) == op->opcode))
	    {
	      (*info->fprintf_func) (info->stream, "%s\t",op->name);   
	      for (i=0; op->operands[i]; i++)
		{
		  oper = (struct d10v_operand *)&d10v_operands[op->operands[i]];
		  if (oper->flags == OPERAND_ATPAR)
		    need_paren = 1;
		  print_operand (oper, ins[j], op, memaddr, info);
		  if (op->operands[i+1] && oper->bits && 
		  d10v_operands[op->operands[i+1]].flags != OPERAND_PLUS &&
		  d10v_operands[op->operands[i+1]].flags != OPERAND_MINUS)
		    (*info->fprintf_func) (info->stream, ", ");   
		}
	      match = 1;
	      num_match++;
	      break;
	    }
	  op++;
	}
      if (!match)
	(*info->fprintf_func) (info->stream, "unknown");   

      switch (order)
	{
	case 0:
	  (*info->fprintf_func) (info->stream, "\t->\t");   
	  order = -1;
	  break;
	case 1:
	  (*info->fprintf_func) (info->stream, "\t<-\t");   
	  order = -1;
	  break;
	case 2:
	  (*info->fprintf_func) (info->stream, "\t||\t");   
	  order = -1;
	  break;
	default:
	  break;
	}
    }

  if (num_match == 0)
    (*info->fprintf_func) (info->stream, ".long\t0x%08x",insn);   

  if (need_paren)
    (*info->fprintf_func) (info->stream, ")");   
}
@


1.1.1.1
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
d21 1
a21 1
#include "sysdep.h"
d27 1
a27 1
#define PC_MASK	0x0303FFFF
d117 1
a117 4
      num += (oper->flags
	      & (OPERAND_GPR|OPERAND_FFLAG|OPERAND_CFLAG|OPERAND_CONTROL));
      if (oper->flags & (OPERAND_ACC0|OPERAND_ACC1))
	num += num ? OPERAND_ACC1 : OPERAND_ACC0;
d134 1
a134 1
	  if (oper->flags & (OPERAND_ACC0|OPERAND_ACC1))
d157 2
a158 2
	  if (info->flags & INSN_HAS_RELOC)
	    (*info->print_address_func) (num & PC_MASK, info);
d160 1
a160 6
	    {
	      if (neg)
		(*info->print_address_func) ((memaddr - num) & PC_MASK, info);
	      else
		(*info->print_address_func) ((memaddr + num) & PC_MASK, info);
	    }
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
d18 1
d22 1
a22 1
#include "opcode/d10v.h"
d25 2
a26 2
/* The PC wraps at 18 bits, except for the segment number,
   so use this mask to keep the parts we want.  */
d29 1
a29 1
static void dis_2_short PARAMS ((unsigned long insn, bfd_vma memaddr,
d31 1
a31 1
static void dis_long PARAMS ((unsigned long insn, bfd_vma memaddr,
a32 3
static void print_operand
  PARAMS ((struct d10v_operand *, long unsigned int, struct d10v_opcode *,
	   bfd_vma, struct disassemble_info *));
d34 1
a34 1
int
d52 14
a65 15
  switch (status)
    {
    case 0:
      dis_2_short (insn, memaddr, info, 2);
      break;
    case FM01:
      dis_2_short (insn, memaddr, info, 0);
      break;
    case FM10:
      dis_2_short (insn, memaddr, info, 1);
      break;
    case FM11:
      dis_long (insn, memaddr, info);
      break;
    }
d81 1
a81 1
      (*info->fprintf_func) (info->stream, "@@-");
d86 1
a86 1
      (*info->fprintf_func) (info->stream, "-");
d91 1
a91 1
      (*info->fprintf_func) (info->stream, "+");
d96 1
a96 1
      (*info->fprintf_func) (info->stream, "@@");
d101 1
a101 1
      (*info->fprintf_func) (info->stream, "@@(");
d107 1
a107 1
  /* The LONG_L format shifts registers over by 15.  */
d116 1
a116 1
      int match = 0;
d118 2
a119 2
	      & (OPERAND_GPR | OPERAND_FFLAG | OPERAND_CFLAG | OPERAND_CONTROL));
      if (oper->flags & (OPERAND_ACC0 | OPERAND_ACC1))
d121 1
a121 1
      for (i = 0; i < d10v_reg_name_cnt (); i++)
d123 1
a123 1
	  if (num == (d10v_predefined_registers[i].value & ~ OPERAND_SP))
d126 1
a126 2
		(*info->fprintf_func) (info->stream, "%s",
				       d10v_predefined_registers[i].pname);
d128 2
a129 3
		(*info->fprintf_func) (info->stream, "%s",
				       d10v_predefined_registers[i].name);
	      match = 1;
d135 3
a137 3
	  /* This would only get executed if a register was not in the
	     register table.  */
	  if (oper->flags & (OPERAND_ACC0 | OPERAND_ACC1))
d141 1
a141 1
	  else if (oper->flags & OPERAND_REG)
d143 1
a143 1
	  (*info->fprintf_func) (info->stream, "%d", num & REGISTER_MASK);
d148 1
a148 1
      /* Addresses are right-shifted by 2.  */
d152 1
a152 1
	  int neg = 0;
d156 1
a156 1
	      num = -num & ((1 << oper->bits) - 1);
d159 1
a159 1
	  num = num << 2;
d177 1
a177 1
		  num = -num & ((1 << oper->bits) - 1);
d181 1
a181 1
	  (*info->fprintf_func) (info->stream, "0x%x", num);
d186 1
d194 2
a195 1
  struct d10v_opcode *op = (struct d10v_opcode *) d10v_opcodes;
d202 1
a202 1
      if ((op->format & LONG_OPCODE) && ((op->mask & insn) == (unsigned long) op->opcode))
d205 2
a206 2
	  (*info->fprintf_func) (info->stream, "%s\t", op->name);
	  for (i = 0; op->operands[i]; i++)
d208 1
a208 1
	      oper = (struct d10v_operand *) &d10v_operands[op->operands[i]];
d212 4
a215 4
	      if (op->operands[i + 1] && oper->bits
		  && d10v_operands[op->operands[i + 1]].flags != OPERAND_PLUS
		  && d10v_operands[op->operands[i + 1]].flags != OPERAND_MINUS)
		(*info->fprintf_func) (info->stream, ", ");
d223 1
a223 1
    (*info->fprintf_func) (info->stream, ".long\t0x%08x", insn);
d226 1
a226 1
    (*info->fprintf_func) (info->stream, ")");
d236 2
a237 1
  int i, j;
d240 2
a241 1
  int match, num_match = 0;
d248 1
a248 1
  for (j = 0; j < 2; j++)
d250 2
a251 2
      op = (struct d10v_opcode *) d10v_opcodes;
      match = 0;
d254 1
a254 2
	  if ((op->format & SHORT_OPCODE)
	      && ((op->mask & ins[j]) == (unsigned long) op->opcode))
d256 2
a257 2
	      (*info->fprintf_func) (info->stream, "%s\t", op->name);
	      for (i = 0; op->operands[i]; i++)
d259 1
a259 1
		  oper = (struct d10v_operand *) &d10v_operands[op->operands[i]];
d263 4
a266 4
		  if (op->operands[i + 1] && oper->bits
		      && d10v_operands[op->operands[i + 1]].flags != OPERAND_PLUS
		      && d10v_operands[op->operands[i + 1]].flags != OPERAND_MINUS)
		    (*info->fprintf_func) (info->stream, ", ");
d275 1
a275 1
	(*info->fprintf_func) (info->stream, "unknown");
d280 1
a280 1
	  (*info->fprintf_func) (info->stream, "\t->\t");
d284 1
a284 1
	  (*info->fprintf_func) (info->stream, "\t<-\t");
d288 1
a288 1
	  (*info->fprintf_func) (info->stream, "\t||\t");
d297 1
a297 1
    (*info->fprintf_func) (info->stream, ".long\t0x%08x", insn);
d300 1
a300 1
    (*info->fprintf_func) (info->stream, ")");
@


