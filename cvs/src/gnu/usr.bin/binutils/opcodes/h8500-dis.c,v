head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.52
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.54
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.50
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.46
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.48
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.40
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.44
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.42
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.38
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.36
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.34
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.32
	OPENBSD_5_0:1.4.0.30
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.28
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.26
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.22
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.24
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	BINUTILS_2_15:1.1.1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.2
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.05.17.21.54.54;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.44;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.19.12.59;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.00;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.00;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.47.52;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.56.07;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.44;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@/* Disassemble h8500 instructions.
   Copyright 1993, 1998, 2000, 2001, 2002 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include <stdio.h>

#define DISASSEMBLER_TABLE
#define DEFINE_TABLE

#include "sysdep.h"
#include "h8500-opc.h"
#include "dis-asm.h"
#include "opintl.h"

/* Maximum length of an instruction.  */
#define MAXLEN 8

#include <setjmp.h>

static int fetch_data PARAMS ((struct disassemble_info *, bfd_byte *));

struct private
{
  /* Points to first byte not fetched.  */
  bfd_byte *max_fetched;
  bfd_byte the_buffer[MAXLEN];
  bfd_vma insn_start;
  jmp_buf bailout;
};

/* Make sure that bytes from INFO->PRIVATE_DATA->BUFFER (inclusive)
   to ADDR (exclusive) are valid.  Returns 1 for success, longjmps
   on error.  */
#define FETCH_DATA(info, addr) \
  ((addr) <= ((struct private *)(info->private_data))->max_fetched \
   ? 1 : fetch_data ((info), (addr)))

static int
fetch_data (info, addr)
     struct disassemble_info *info;
     bfd_byte *addr;
{
  int status;
  struct private *priv = (struct private *) info->private_data;
  bfd_vma start = priv->insn_start + (priv->max_fetched - priv->the_buffer);

  status = (*info->read_memory_func) (start,
				      priv->max_fetched,
				      addr - priv->max_fetched,
				      info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, start, info);
      longjmp (priv->bailout, 1);
    }
  else
    priv->max_fetched = addr;
  return 1;
}

static char *crname[] = { "sr", "ccr", "*", "br", "ep", "dp", "*", "tp" };

int
print_insn_h8500 (addr, info)
     bfd_vma addr;
     disassemble_info *info;
{
  const h8500_opcode_info *opcode;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;

  struct private priv;
  bfd_byte *buffer = priv.the_buffer;

  info->private_data = (PTR) & priv;
  priv.max_fetched = priv.the_buffer;
  priv.insn_start = addr;
  if (setjmp (priv.bailout) != 0)
    /* Error return.  */
    return -1;

  if (0)
    {
      static int one;

      if (!one)
	{
	  one = 1;
	  for (opcode = h8500_table; opcode->name; opcode++)
	    {
	      if ((opcode->bytes[0].contents & 0x8) == 0)
		printf ("%s\n", opcode->name);
	    }
	}
    }

  /* Run down the table to find the one which matches.  */
  for (opcode = h8500_table; opcode->name; opcode++)
    {
      int byte;
      int rn = 0;
      int rd = 0;
      int rs = 0;
      int disp = 0;
      int abs = 0;
      int imm = 0;
      int pcrel = 0;
      int qim = 0;
      int i;
      int cr = 0;

      for (byte = 0; byte < opcode->length; byte++)
	{
	  FETCH_DATA (info, buffer + byte + 1);
	  if ((buffer[byte] & opcode->bytes[byte].mask)
	      != (opcode->bytes[byte].contents))
	    {
	      goto next;
	    }
	  else
	    {
	      /* Extract any info parts.  */
	      switch (opcode->bytes[byte].insert)
		{
		case 0:
		case FP:
		  break;
		default:
		  /* xgettext:c-format */
		  func (stream, _("can't cope with insert %d\n"),
			opcode->bytes[byte].insert);
		  break;
		case RN:
		  rn = buffer[byte] & 0x7;
		  break;
		case RS:
		  rs = buffer[byte] & 0x7;
		  break;
		case CRB:
		  cr = buffer[byte] & 0x7;
		  if (cr == 0)
		    goto next;
		  break;
		case CRW:
		  cr = buffer[byte] & 0x7;
		  if (cr != 0)
		    goto next;
		  break;
		case DISP16:
		  FETCH_DATA (info, buffer + byte + 2);
		  disp = (buffer[byte] << 8) | (buffer[byte + 1]);
		  break;
		case FPIND_D8:
		case DISP8:
		  disp = ((char) (buffer[byte]));
		  break;
		case RD:
		case RDIND:
		  rd = buffer[byte] & 0x7;
		  break;
		case ABS24:
		  FETCH_DATA (info, buffer + byte + 3);
		  abs =
		    (buffer[byte] << 16)
		    | (buffer[byte + 1] << 8)
		    | (buffer[byte + 2]);
		  break;
		case ABS16:
		  FETCH_DATA (info, buffer + byte + 2);
		  abs = (buffer[byte] << 8) | (buffer[byte + 1]);
		  break;
		case ABS8:
		  abs = (buffer[byte]);
		  break;
		case IMM16:
		  FETCH_DATA (info, buffer + byte + 2);
		  imm = (buffer[byte] << 8) | (buffer[byte + 1]);
		  break;
		case IMM4:
		  imm = (buffer[byte]) & 0xf;
		  break;
		case IMM8:
		case RLIST:
		  imm = (buffer[byte]);
		  break;
		case PCREL16:
		  FETCH_DATA (info, buffer + byte + 2);
		  pcrel = (buffer[byte] << 8) | (buffer[byte + 1]);
		  break;
		case PCREL8:
		  pcrel = (buffer[byte]);
		  break;
		case QIM:
		  switch (buffer[byte] & 0x7)
		    {
		    case 0:
		      qim = 1;
		      break;
		    case 1:
		      qim = 2;
		      break;
		    case 4:
		      qim = -1;
		      break;
		    case 5:
		      qim = -2;
		      break;
		    }
		  break;

		}
	    }
	}
      /* We get here when all the masks have passed so we can output
	 the operands.  */
      FETCH_DATA (info, buffer + opcode->length);
      for (i = 0; i < opcode->length; i++)
	{
	  (func) (stream, "%02x ", buffer[i]);
	}
      for (; i < 6; i++)
	{
	  (func) (stream, "   ");
	}
      (func) (stream, "%s\t", opcode->name);
      for (i = 0; i < opcode->nargs; i++)
	{
	  if (i)
	    (func) (stream, ",");
	  switch (opcode->arg_type[i])
	    {
	    case FP:
	      func (stream, "fp");
	      break;
	    case RNIND_D16:
	      func (stream, "@@(0x%x:16,r%d)", disp, rn);
	      break;
	    case RNIND_D8:
	      func (stream, "@@(0x%x:8 (%d),r%d)", disp & 0xff, disp, rn);
	      break;
	    case RDIND_D16:
	      func (stream, "@@(0x%x:16,r%d)", disp, rd);
	      break;
	    case RDIND_D8:
	      func (stream, "@@(0x%x:8 (%d), r%d)", disp & 0xff, disp, rd);
	      break;
	    case FPIND_D8:
	      func (stream, "@@(0x%x:8 (%d), fp)", disp & 0xff, disp, rn);
	      break;
	    case CRB:
	    case CRW:
	      func (stream, "%s", crname[cr]);
	      break;
	    case RN:
	      func (stream, "r%d", rn);
	      break;
	    case RD:
	      func (stream, "r%d", rd);
	      break;
	    case RS:
	      func (stream, "r%d", rs);
	      break;
	    case RNDEC:
	      func (stream, "@@-r%d", rn);
	      break;
	    case RNINC:
	      func (stream, "@@r%d+", rn);
	      break;
	    case RNIND:
	      func (stream, "@@r%d", rn);
	      break;
	    case RDIND:
	      func (stream, "@@r%d", rd);
	      break;
	    case SPINC:
	      func (stream, "@@sp+");
	      break;
	    case SPDEC:
	      func (stream, "@@-sp");
	      break;
	    case ABS24:
	      func (stream, "@@0x%0x:24", abs);
	      break;
	    case ABS16:
	      func (stream, "@@0x%0x:16", abs & 0xffff);
	      break;
	    case ABS8:
	      func (stream, "@@0x%0x:8", abs & 0xff);
	      break;
	    case IMM16:
	      func (stream, "#0x%0x:16", imm & 0xffff);
	      break;
	    case RLIST:
	      {
		int i;
		int nc = 0;
		func (stream, "(");
		for (i = 0; i < 8; i++)
		  {
		    if (imm & (1 << i))
		      {
			func (stream, "r%d", i);
			if (nc)
			  func (stream, ",");
			nc = 1;
		      }
		  }
		func (stream, ")");
	      }
	      break;
	    case IMM8:
	      func (stream, "#0x%0x:8", imm & 0xff);
	      break;
	    case PCREL16:
	      func (stream, "0x%0x:16",
		    (pcrel + addr + opcode->length) & 0xffff);
	      break;
	    case PCREL8:
	      func (stream, "#0x%0x:8",
		    ((char) pcrel + addr + opcode->length) & 0xffff);
	      break;
	    case QIM:
	      func (stream, "#%d:q", qim);
	      break;
	    case IMM4:
	      func (stream, "#%d:4", imm);
	      break;
	    }
	}
      return opcode->length;
    next:
      ;
    }

  /* Couldn't understand anything.  */
  /* xgettext:c-format */
  func (stream, _("%02x\t\t*unknown*"), buffer[0]);
  return 1;
}
@


1.3
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1993, 1998, 2000 Free Software Foundation, Inc.
d33 2
d81 1
a81 1
  h8500_opcode_info *opcode;
@


1.2
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 1998 Free Software Foundation, Inc.
d72 1
a72 2
static char *crname[] =
{"sr", "ccr", "*", "br", "ep", "dp", "*", "tp"};
d93 3
a95 12
if (0)  {
    static    int one;
    if (!one ) 
      {
	one = 1;
	for (opcode = h8500_table; opcode->name; opcode++)
	  {
	    if ((opcode->bytes[0].contents & 0x8) == 0)
	      printf("%s\n", opcode->name);
	  }
      }
  }
d97 10
d108 1
a108 1
  /* Run down the table to find the one which matches */
d122 1
d133 1
a133 1
	      /* extract any info parts */
d225 2
a226 2
      /* We get here when all the masks have passed so we can output the
	 operands*/
d326 2
a327 1
	      func (stream, "0x%0x:16", (pcrel + addr + opcode->length) & 0xffff);
d342 2
a343 1
    next:;
d346 1
a346 1
  /* Couldn't understand anything */
a349 1

@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1993 Free Software Foundation, Inc.
d23 1
d26 1
d112 8
a119 8
      int rn;
      int rd;
      int rs;
      int disp;
      int abs;
      int imm;
      int pcrel;
      int qim;
d121 1
a121 1
      int cr;
d139 2
a140 1
		  func (stream, "can't cope with insert %d\n",
d344 2
a345 1
  func (stream, "%02x\t\t*unknown*", buffer[0]);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 1998 Free Software Foundation, Inc.
a22 1
#include "sysdep.h"
a24 1
#include "opintl.h"
d110 8
a117 8
      int rn = 0;
      int rd = 0;
      int rs = 0;
      int disp = 0;
      int abs = 0;
      int imm = 0;
      int pcrel = 0;
      int qim = 0;
d119 1
a119 1
      int cr = 0;
d137 1
a137 2
		  /* xgettext:c-format */
		  func (stream, _("can't cope with insert %d\n"),
d341 1
a341 2
  /* xgettext:c-format */
  func (stream, _("%02x\t\t*unknown*"), buffer[0]);
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1993, 1998, 2000 Free Software Foundation, Inc.
d72 2
a73 1
static char *crname[] = { "sr", "ccr", "*", "br", "ep", "dp", "*", "tp" };
d94 12
a105 3
  if (0)
    {
      static int one;
a106 10
      if (!one)
	{
	  one = 1;
	  for (opcode = h8500_table; opcode->name; opcode++)
	    {
	      if ((opcode->bytes[0].contents & 0x8) == 0)
		printf ("%s\n", opcode->name);
	    }
	}
    }
d108 1
a108 1
  /* Run down the table to find the one which matches.  */
a121 1

d132 1
a132 1
	      /* Extract any info parts.  */
d224 2
a225 2
      /* We get here when all the masks have passed so we can output
	 the operands.  */
d325 1
a325 2
	      func (stream, "0x%0x:16",
		    (pcrel + addr + opcode->length) & 0xffff);
d340 1
a340 2
    next:
      ;
d343 1
a343 1
  /* Couldn't understand anything.  */
d347 1
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1993, 1998, 2000, 2001, 2002 Free Software Foundation, Inc.
a32 2
static int fetch_data PARAMS ((struct disassemble_info *, bfd_byte *));

d79 1
a79 1
  const h8500_opcode_info *opcode;
@


