head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.52
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.50
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.46
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.48
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.40
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.44
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.42
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.38
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.36
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.34
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.32
	OPENBSD_5_0:1.7.0.30
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.28
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.26
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.22
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.24
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.20
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.18
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.16
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.14
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.12
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.10
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.8
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.05.17.21.54.54;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.44;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.12.58;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.53.11;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.10.45;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.55.35;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.08.58;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.08.58;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.04.08;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.48.48;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.39.35;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.47.49;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.55.07;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.42;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@/* alpha-dis.c -- Disassemble Alpha AXP instructions
   Copyright 1996, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
   Contributed by Richard Henderson <rth@@tamu.edu>,
   patterned after the PPC opcode handling written by Ian Lance Taylor.

This file is part of GDB, GAS, and the GNU binutils.

GDB, GAS, and the GNU binutils are free software; you can redistribute
them and/or modify them under the terms of the GNU General Public
License as published by the Free Software Foundation; either version
2, or (at your option) any later version.

GDB, GAS, and the GNU binutils are distributed in the hope that they
will be useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this file; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */

#include <stdio.h>
#include "sysdep.h"
#include "dis-asm.h"
#include "opcode/alpha.h"

/* OSF register names.  */

static const char * const osf_regnames[64] = {
  "v0", "t0", "t1", "t2", "t3", "t4", "t5", "t6",
  "t7", "s0", "s1", "s2", "s3", "s4", "s5", "fp",
  "a0", "a1", "a2", "a3", "a4", "a5", "t8", "t9",
  "t10", "t11", "ra", "t12", "at", "gp", "sp", "zero",
  "$f0", "$f1", "$f2", "$f3", "$f4", "$f5", "$f6", "$f7",
  "$f8", "$f9", "$f10", "$f11", "$f12", "$f13", "$f14", "$f15",
  "$f16", "$f17", "$f18", "$f19", "$f20", "$f21", "$f22", "$f23",
  "$f24", "$f25", "$f26", "$f27", "$f28", "$f29", "$f30", "$f31"
};

/* VMS register names.  */

static const char * const vms_regnames[64] = {
  "R0", "R1", "R2", "R3", "R4", "R5", "R6", "R7",
  "R8", "R9", "R10", "R11", "R12", "R13", "R14", "R15",
  "R16", "R17", "R18", "R19", "R20", "R21", "R22", "R23",
  "R24", "AI", "RA", "PV", "AT", "FP", "SP", "RZ",
  "F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7",
  "F8", "F9", "F10", "F11", "F12", "F13", "F14", "F15",
  "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23",
  "F24", "F25", "F26", "F27", "F28", "F29", "F30", "FZ"
};

/* Disassemble Alpha instructions.  */

int
print_insn_alpha (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
{
  static const struct alpha_opcode *opcode_index[AXP_NOPS+1];
  const char * const * regnames;
  const struct alpha_opcode *opcode, *opcode_end;
  const unsigned char *opindex;
  unsigned insn, op, isa_mask;
  int need_comma;

  /* Initialize the majorop table the first time through */
  if (!opcode_index[0])
    {
      opcode = alpha_opcodes;
      opcode_end = opcode + alpha_num_opcodes;

      for (op = 0; op < AXP_NOPS; ++op)
	{
	  opcode_index[op] = opcode;
	  while (opcode < opcode_end && op == AXP_OP (opcode->opcode))
	    ++opcode;
	}
      opcode_index[op] = opcode;
    }

  if (info->flavour == bfd_target_evax_flavour)
    regnames = vms_regnames;
  else
    regnames = osf_regnames;

  isa_mask = AXP_OPCODE_NOPAL;
  switch (info->mach)
    {
    case bfd_mach_alpha_ev4:
      isa_mask |= AXP_OPCODE_EV4;
      break;
    case bfd_mach_alpha_ev5:
      isa_mask |= AXP_OPCODE_EV5;
      break;
    case bfd_mach_alpha_ev6:
      isa_mask |= AXP_OPCODE_EV6;
      break;
    }

  /* Read the insn into a host word */
  {
    bfd_byte buffer[4];
    int status = (*info->read_memory_func) (memaddr, buffer, 4, info);
    if (status != 0)
      {
	(*info->memory_error_func) (status, memaddr, info);
	return -1;
      }
    insn = bfd_getl32 (buffer);
  }

  /* Get the major opcode of the instruction.  */
  op = AXP_OP (insn);

  /* Find the first match in the opcode table.  */
  opcode_end = opcode_index[op + 1];
  for (opcode = opcode_index[op]; opcode < opcode_end; ++opcode)
    {
      if ((insn ^ opcode->opcode) & opcode->mask)
	continue;

      if (!(opcode->flags & isa_mask))
	continue;

      /* Make two passes over the operands.  First see if any of them
	 have extraction functions, and, if they do, make sure the
	 instruction is valid.  */
      {
	int invalid = 0;
	for (opindex = opcode->operands; *opindex != 0; opindex++)
	  {
	    const struct alpha_operand *operand = alpha_operands + *opindex;
	    if (operand->extract)
	      (*operand->extract) (insn, &invalid);
	  }
	if (invalid)
	  continue;
      }

      /* The instruction is valid.  */
      goto found;
    }

  /* No instruction found */
  (*info->fprintf_func) (info->stream, ".long %#08x", insn);

  return 4;

found:
  (*info->fprintf_func) (info->stream, "%s", opcode->name);
  if (opcode->operands[0] != 0)
    (*info->fprintf_func) (info->stream, "\t");

  /* Now extract and print the operands.  */
  need_comma = 0;
  for (opindex = opcode->operands; *opindex != 0; opindex++)
    {
      const struct alpha_operand *operand = alpha_operands + *opindex;
      int value;

      /* Operands that are marked FAKE are simply ignored.  We
	 already made sure that the extract function considered
	 the instruction to be valid.  */
      if ((operand->flags & AXP_OPERAND_FAKE) != 0)
	continue;

      /* Extract the value from the instruction.  */
      if (operand->extract)
	value = (*operand->extract) (insn, (int *) NULL);
      else
	{
	  value = (insn >> operand->shift) & ((1 << operand->bits) - 1);
	  if (operand->flags & AXP_OPERAND_SIGNED)
	    {
	      int signbit = 1 << (operand->bits - 1);
	      value = (value ^ signbit) - signbit;
	    }
	}

      if (need_comma &&
	  ((operand->flags & (AXP_OPERAND_PARENS | AXP_OPERAND_COMMA))
	   != AXP_OPERAND_PARENS))
	{
	  (*info->fprintf_func) (info->stream, ",");
	}
      if (operand->flags & AXP_OPERAND_PARENS)
	(*info->fprintf_func) (info->stream, "(");

      /* Print the operand as directed by the flags.  */
      if (operand->flags & AXP_OPERAND_IR)
	(*info->fprintf_func) (info->stream, "%s", regnames[value]);
      else if (operand->flags & AXP_OPERAND_FPR)
	(*info->fprintf_func) (info->stream, "%s", regnames[value + 32]);
      else if (operand->flags & AXP_OPERAND_RELATIVE)
	(*info->print_address_func) (memaddr + 4 + value, info);
      else if (operand->flags & AXP_OPERAND_SIGNED)
	(*info->fprintf_func) (info->stream, "%d", value);
      else
	(*info->fprintf_func) (info->stream, "%#x", value);

      if (operand->flags & AXP_OPERAND_PARENS)
	(*info->fprintf_func) (info->stream, ")");
      need_comma = 1;
    }

  return 4;
}
@


1.6
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1996, 1998, 1999, 2000 Free Software Foundation, Inc.
d30 1
a30 2
static const char * const osf_regnames[64] =
{
d43 1
a43 2
static const char * const vms_regnames[64] =
{
d75 3
a77 3
        {
          opcode_index[op] = opcode;
          while (opcode < opcode_end && op == AXP_OP (opcode->opcode))
d79 1
a79 1
        }
d108 2
a109 2
        (*info->memory_error_func) (status, memaddr, info);
        return -1;
d118 1
a118 1
  opcode_end = opcode_index[op+1];
d121 1
a121 1
      if ((insn & opcode->mask) != opcode->opcode)
d131 2
a132 2
        int invalid = 0;
        for (opindex = opcode->operands; *opindex != 0; opindex++)
d134 1
a134 1
            const struct alpha_operand *operand = alpha_operands + *opindex;
d138 1
a138 1
        if (invalid)
d148 1
a148 1
    
d183 1
a183 1
	  ((operand->flags & (AXP_OPERAND_PARENS|AXP_OPERAND_COMMA))
d195 1
a195 1
	(*info->fprintf_func) (info->stream, "%s", regnames[value+32]);
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright 1996, 1999 Free Software Foundation, Inc.
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 1
a2 1
   Copyright 1996 Free Software Foundation, Inc.
a22 1
#include <stdlib.h>
a23 1
#include "ansidecl.h"
d67 1
a67 1
  unsigned insn, op;
d90 14
d126 1
a126 1
      if (!(opcode->flags & AXP_OPCODE_NOPAL))
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d114 1
a114 1
      if (!(opcode->flags & AXP_OPCODE_ALL))
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d1 42
a42 22
/* Instruction printing code for the Alpha
   Copyright (C) 1993, 1995 Free Software Foundation, Inc.
   Contributed by Cygnus Support.

Written by Steve Chamberlain (sac@@cygnus.com)

This file is part of libopcodes.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License along with
This program; if not, write to the Free Software Foundation, Inc., 675
 Mass Ave, Boston, MA 02111-1307, USA.
*/
d44 1
a44 3
#include "dis-asm.h"
#define DEFINE_TABLE
#include "alpha-opc.h"
d46 11
d58 1
a58 2
/* Print one instruction from PC on INFO->STREAM.
   Return the size of the instruction (always 4 on alpha). */
d61 2
a62 2
print_insn_alpha(pc, info)
     bfd_vma pc;
d65 6
a70 16
  alpha_insn	*insn;
  unsigned char	b[4];
  void		*stream = info->stream;
  fprintf_ftype	func = info->fprintf_func;
  unsigned long	given;
  int		status ;
  int found = 0;

  status = (*info->read_memory_func) (pc, (bfd_byte *) &b[0], 4, info);
  if (status != 0) {
    (*info->memory_error_func) (status, pc, info);
    return -1;
  }
  given = (b[0]) | (b[1] << 8) | (b[2] << 16) | (b[3] << 24);

  func (stream, "\t%08x\t", given);
d72 2
a73 3
  for (insn = alpha_insn_set;
       insn->name && !found;
       insn++)
d75 2
a76 14
      switch (insn->type)
	{
	case MEMORY_FORMAT_CODE:
	  if ((insn->i & MEMORY_FORMAT_MASK)
	      ==(given & MEMORY_FORMAT_MASK))
	    {
	      func (stream, "%s\t%s, %d(%s)",
		    insn->name,
		    alpha_regs[RA(given)],
		    OPCODE (given) == 9 ? DISP(given) * 65536 : DISP(given),
		    alpha_regs[RB(given)]);
	      found = 1;
	    }
	  break;
d78 8
d87 16
a102 22
	case MEMORY_FUNCTION_FORMAT_CODE:
	  if ((insn->i & MEMORY_FUNCTION_FORMAT_MASK)
	      ==(given & MEMORY_FUNCTION_FORMAT_MASK))
	    {
	      switch (given & 0xffff)
		{
		case 0x8000: /* fetch */
		case 0xa000: /* fetch_m */
		  func (stream, "%s\t(%s)", insn->name, alpha_regs[RB(given)]);
		  break;

		case 0xc000: /* rpcc */
		  func (stream, "%s\t%s", insn->name, alpha_regs[RA(given)]);
		  break;

		default:
		  func (stream, "%s", insn->name);
		  break;
		}
	      found = 1;
	    }
	  break;
d104 2
a105 13
	case BRANCH_FORMAT_CODE:
	  if ((insn->i & BRANCH_FORMAT_MASK)
	      == (given & BRANCH_FORMAT_MASK))
	    {
	      if (RA(given) == 31)
		func (stream, "%s\t ", insn->name);
	      else
		func (stream, "%s\t%s, ", insn->name,
		      alpha_regs[RA(given)]);
	      (*info->print_address_func) (BDISP(given) * 4 + pc + 4, info);
	      found = 1;
	    }
	  break;
d107 6
a112 23
	case MEMORY_BRANCH_FORMAT_CODE:
	  if ((insn->i & MEMORY_BRANCH_FORMAT_MASK)
	      == (given & MEMORY_BRANCH_FORMAT_MASK))
	    {
	      if (given & (1<<15))
		{
		  func (stream, "%s\t%s, (%s), %d", insn->name,
			alpha_regs[RA(given)],
			alpha_regs[RB(given)],
			JUMP_HINT(given));
		}
	      else
		{
		  /* The displacement is a hint only, do not put out
		     a symbolic address.  */
		  func (stream, "%s\t%s, (%s), 0x%lx", insn->name,
			alpha_regs[RA(given)],
			alpha_regs[RB(given)],
			JDISP(given) * 4 + pc + 4);
		}
	      found = 1;
	    }
	  break;
d114 2
a115 87
	case OPERATE_FORMAT_CODE:
	  if ((insn->i & OPERATE_FORMAT_MASK)
	      == (given & OPERATE_FORMAT_MASK))
	    {
	      int opcode = OPCODE(given);
	      int optype = OP_OPTYPE(given);
	      if (OP_OPTYPE(insn->i) == optype)
		{
		  int ra;
		  ra = RA(given);

		  if (OP_IS_CONSTANT(given))
		    {
		      if ((opcode == 0x11) && (optype == 0x20)
			  && (ra == 31))	  /* bis R31, lit, Ry */
			{
			  func (stream, "mov\t0x%x, %s",
				LITERAL(given), alpha_regs[RC(given)] );
			}
		      else
			{
#if GNU_ASMCODE
			  func (stream, "%s\t%s, 0x%x, %s", insn->name,
				alpha_regs[RA(given)],
				LITERAL(given),
				alpha_regs[RC(given)]);
#else
			  func (stream, "%s\t%s, #%d, %s", insn->name,
				alpha_regs[RA(given)],
				LITERAL(given),
				alpha_regs[RC(given)]);
			}
#endif
		  } else {		/* not constant */
		    int rb, rc;
		    rb = RB(given); rc = RC(given);
		    switch ((opcode << 8) | optype)
		      {
		      case 0x1009:			/* subl */
			if (ra == 31)
			  {
			    func (stream, "negl\t%s, %s",
				  alpha_regs[rb], alpha_regs[rc]);
			    found = 1;
			  }
			break;
		      case 0x1029:			/* subq */
			if (ra == 31)
			  {
			    func (stream, "negq\t%s, %s",
				  alpha_regs[rb], alpha_regs[rc]);
			    found = 1;
			  }
			break;
		      case 0x1120:			/* bis */
			if (ra == 31)
			  {
			    if (ra == rb)		/* ra=R31, rb=R31 */
			      {
				if (rc == 31)
				  func (stream, "nop");
				else
				  func (stream, "clr\t%s", alpha_regs[rc]);
			      }
			    else
			      func (stream, "mov\t%s, %s",
				    alpha_regs[rb], alpha_regs[rc]);
			  }
			else
			  func (stream, "or\t%s, %s, %s",
				alpha_regs[ra], alpha_regs[rb],
				alpha_regs[rc]);
			found = 1;
			break;

		      default:
			break;

		      }

		    if (!found)
		      func (stream, "%s\t%s, %s, %s", insn->name,
			    alpha_regs[ra], alpha_regs[rb], alpha_regs[rc]);
		  }
		  found = 1;
		}
	    }
d117 14
a130 1
	  break;
d132 3
a134 37
	case FLOAT_FORMAT_CODE:
	  if ((insn->i & FLOAT_FORMAT_MASK)
	      == (given & FLOAT_FORMAT_MASK))
	    {
	      int ra, rb, rc;
	      ra = RA(given); rb = RB(given); rc = RC(given);
	      switch (OP_OPTYPE(given))
		{
		case 0x20:		/* cpys */
		  if (ra == 31)
		    {
		      if (rb == 31)
			{
			  if (rc == 31)
			    func (stream, "fnop");
			  else
			    func (stream, "fclr\tf%d", rc);
			}
		      else
			func (stream, "fabs\tf%d, f%d", rb, rc);
		      found = 1;
		    }
		  else if (ra == rb)
		    {
		      func (stream, "fmov\tf%d, f%d", rb, rc);
		      found = 1;
		    }
		  break;
		case 0x21:		/* cpysn */
		  if (ra == rb)
		    {
		      func (stream, "fneg\tf%d, f%d", rb, rc);
		      found = 1;
		    }
		default:
		  ;
	        }
d136 16
a151 2
	      if (!found)
	        func (stream, "%s\tf%d, f%d, f%d", insn->name, ra, rb, rc);
d153 13
a165 6
	      found = 1;
	    }

	  break;
	case PAL_FORMAT_CODE:
	  if (insn->i == given)
d167 2
a168 2
	      func (stream, "call_pal %s", insn->name);
	      found = 1;
d170 1
d172 5
a176 24
	  break;
	case FLOAT_MEMORY_FORMAT_CODE:
	  if ((insn->i & MEMORY_FORMAT_MASK)
	      ==(given & MEMORY_FORMAT_MASK))
	    {
	      func (stream, "%s\tf%d, %d(%s)",
		      insn->name,
		      RA(given),
		      OPCODE (given) == 9 ? DISP(given) * 65536 : DISP(given),
		      alpha_regs[RB(given)]);
	      found = 1;
	    }
	  break;
	case FLOAT_BRANCH_FORMAT_CODE:
	  if ((insn->i & BRANCH_FORMAT_MASK)
	      == (given & BRANCH_FORMAT_MASK))
	    {
	      func (stream, "%s\tf%d, ",
		    insn->name,
		    RA(given));
	      (*info->print_address_func) (BDISP(given) * 4 + pc + 4, info);
	      found = 1;
	    }
	  break;
d178 18
a196 30

  if (!found)
    switch (OPCODE (given))
      {
      case 0x00:
	func (stream, "call_pal 0x%x", given);
	break;
      case 0x19:
      case 0x1b:
      case 0x1d:
      case 0x1e:
      case 0x1f:
	func (stream, "PAL%X 0x%x", OPCODE (given), given & 0x3ffffff);
	break;
      case 0x01:
      case 0x02:
      case 0x03:
      case 0x04:
      case 0x05:
      case 0x06:
      case 0x07:
      case 0x0a:
      case 0x0c:
      case 0x0d:
      case 0x0e:
      case 0x14:
      case 0x1c:
	func (stream, "OPC%02X 0x%x", OPCODE (given), given & 0x3ffffff);
	break;
      }
@


1.1
log
@Initial revision
@
text
@d139 1
d148 2
a149 2
		      if ((optype == 0x20)	/* bis R31, lit, Ry */
			  && (ra == 31))
d171 1
a171 1
		    switch(optype)
d173 1
a173 1
		      case 0x09:			/* subl */
d181 1
a181 1
		      case 0x29:			/* subq */
d189 1
a189 1
		      case 0x20:			/* bis */
d205 2
a206 1
				alpha_regs[ra], alpha_regs[rb], alpha_regs[rc]);
d226 2
a227 2
	  if ((insn->i & OPERATE_FORMAT_MASK)
	      == (given & OPERATE_FORMAT_MASK))
d236 1
a236 1
		      if (ra == rb)
d244 1
a244 1
			func (stream, "fmov\tf%d, f%d", rb, rc);
d247 1
a247 1
		  else
d249 2
a250 4
		      if (ra == 31) {
			func (stream, "fabs\tf%d, f%d", rb, rc);
			found = 1;
		      }
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@a138 1
	      int opcode = OPCODE(given);
d147 2
a148 2
		      if ((opcode == 0x11) && (optype == 0x20)
			  && (ra == 31))	  /* bis R31, lit, Ry */
d170 1
a170 1
		    switch ((opcode << 8) | optype)
d172 1
a172 1
		      case 0x1009:			/* subl */
d180 1
a180 1
		      case 0x1029:			/* subq */
d188 1
a188 1
		      case 0x1120:			/* bis */
d204 1
a204 2
				alpha_regs[ra], alpha_regs[rb],
				alpha_regs[rc]);
d224 2
a225 2
	  if ((insn->i & FLOAT_FORMAT_MASK)
	      == (given & FLOAT_FORMAT_MASK))
d234 1
a234 1
		      if (rb == 31)
d242 1
a242 1
			func (stream, "fabs\tf%d, f%d", rb, rc);
d245 1
a245 1
		  else if (ra == rb)
d247 4
a250 2
		      func (stream, "fmov\tf%d, f%d", rb, rc);
		      found = 1;
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d1 23
a23 26
/* alpha-dis.c -- Disassemble Alpha AXP instructions
   Copyright 1996 Free Software Foundation, Inc.
   Contributed by Richard Henderson <rth@@tamu.edu>,
   patterned after the PPC opcode handling written by Ian Lance Taylor.

This file is part of GDB, GAS, and the GNU binutils.

GDB, GAS, and the GNU binutils are free software; you can redistribute
them and/or modify them under the terms of the GNU General Public
License as published by the Free Software Foundation; either version
2, or (at your option) any later version.

GDB, GAS, and the GNU binutils are distributed in the hope that they
will be useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this file; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */

#include <stdlib.h>
#include <stdio.h>
#include "ansidecl.h"
#include "sysdep.h"
d25 2
a26 17
#include "opcode/alpha.h"

/* OSF register names.  */

static const char * const osf_regnames[64] =
{
  "v0", "t0", "t1", "t2", "t3", "t4", "t5", "t6",
  "t7", "s0", "s1", "s2", "s3", "s4", "s5", "fp",
  "a0", "a1", "a2", "a3", "a4", "a5", "t8", "t9",
  "t10", "t11", "ra", "t12", "at", "gp", "sp", "zero",
  "$f0", "$f1", "$f2", "$f3", "$f4", "$f5", "$f6", "$f7",
  "$f8", "$f9", "$f10", "$f11", "$f12", "$f13", "$f14", "$f15",
  "$f16", "$f17", "$f18", "$f19", "$f20", "$f21", "$f22", "$f23",
  "$f24", "$f25", "$f26", "$f27", "$f28", "$f29", "$f30", "$f31"
};

/* VMS register names.  */
a27 11
static const char * const vms_regnames[64] =
{
  "R0", "R1", "R2", "R3", "R4", "R5", "R6", "R7",
  "R8", "R9", "R10", "R11", "R12", "R13", "R14", "R15",
  "R16", "R17", "R18", "R19", "R20", "R21", "R22", "R23",
  "R24", "AI", "RA", "PV", "AT", "FP", "SP", "RZ",
  "F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7",
  "F8", "F9", "F10", "F11", "F12", "F13", "F14", "F15",
  "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23",
  "F24", "F25", "F26", "F27", "F28", "F29", "F30", "FZ"
};
d29 2
a30 1
/* Disassemble Alpha instructions.  */
d33 2
a34 2
print_insn_alpha (memaddr, info)
     bfd_vma memaddr;
d37 16
a52 6
  static const struct alpha_opcode *opcode_index[AXP_NOPS+1];
  const char * const * regnames;
  const struct alpha_opcode *opcode, *opcode_end;
  const unsigned char *opindex;
  unsigned insn, op;
  int need_comma;
d54 3
a56 2
  /* Initialize the majorop table the first time through */
  if (!opcode_index[0])
d58 14
a71 2
      opcode = alpha_opcodes;
      opcode_end = opcode + alpha_num_opcodes;
a72 8
      for (op = 0; op < AXP_NOPS; ++op)
        {
          opcode_index[op] = opcode;
          while (opcode < opcode_end && op == AXP_OP (opcode->opcode))
	    ++opcode;
        }
      opcode_index[op] = opcode;
    }
d74 36
a109 16
  if (info->flavour == bfd_target_evax_flavour)
    regnames = vms_regnames;
  else
    regnames = osf_regnames;

  /* Read the insn into a host word */
  {
    bfd_byte buffer[4];
    int status = (*info->read_memory_func) (memaddr, buffer, 4, info);
    if (status != 0)
      {
        (*info->memory_error_func) (status, memaddr, info);
        return -1;
      }
    insn = bfd_getl32 (buffer);
  }
d111 23
a133 2
  /* Get the major opcode of the instruction.  */
  op = AXP_OP (insn);
d135 87
a221 6
  /* Find the first match in the opcode table.  */
  opcode_end = opcode_index[op+1];
  for (opcode = opcode_index[op]; opcode < opcode_end; ++opcode)
    {
      if ((insn & opcode->mask) != opcode->opcode)
	continue;
d223 1
a223 2
      if (!(opcode->flags & AXP_OPCODE_ALL))
	continue;
d225 37
a261 14
      /* Make two passes over the operands.  First see if any of them
	 have extraction functions, and, if they do, make sure the
	 instruction is valid.  */
      {
        int invalid = 0;
        for (opindex = opcode->operands; *opindex != 0; opindex++)
	  {
            const struct alpha_operand *operand = alpha_operands + *opindex;
	    if (operand->extract)
	      (*operand->extract) (insn, &invalid);
	  }
        if (invalid)
	  continue;
      }
d263 2
a264 3
      /* The instruction is valid.  */
      goto found;
    }
d266 2
a267 16
  /* No instruction found */
  (*info->fprintf_func) (info->stream, ".long %#08x", insn);
    
  return 4;

found:
  (*info->fprintf_func) (info->stream, "%s", opcode->name);
  if (opcode->operands[0] != 0)
    (*info->fprintf_func) (info->stream, "\t");

  /* Now extract and print the operands.  */
  need_comma = 0;
  for (opindex = opcode->operands; *opindex != 0; opindex++)
    {
      const struct alpha_operand *operand = alpha_operands + *opindex;
      int value;
d269 3
a271 13
      /* Operands that are marked FAKE are simply ignored.  We
	 already made sure that the extract function considered
	 the instruction to be valid.  */
      if ((operand->flags & AXP_OPERAND_FAKE) != 0)
	continue;

      /* Extract the value from the instruction.  */
      if (operand->extract)
	value = (*operand->extract) (insn, (int *) NULL);
      else
	{
	  value = (insn >> operand->shift) & ((1 << operand->bits) - 1);
	  if (operand->flags & AXP_OPERAND_SIGNED)
d273 2
a274 2
	      int signbit = 1 << (operand->bits - 1);
	      value = (value ^ signbit) - signbit;
a275 1
	}
d277 24
a300 5
      if (need_comma &&
	  ((operand->flags & (AXP_OPERAND_PARENS|AXP_OPERAND_COMMA))
	   != AXP_OPERAND_PARENS))
	{
	  (*info->fprintf_func) (info->stream, ",");
d302 1
a302 2
      if (operand->flags & AXP_OPERAND_PARENS)
	(*info->fprintf_func) (info->stream, "(");
d304 29
a332 16
      /* Print the operand as directed by the flags.  */
      if (operand->flags & AXP_OPERAND_IR)
	(*info->fprintf_func) (info->stream, "%s", regnames[value]);
      else if (operand->flags & AXP_OPERAND_FPR)
	(*info->fprintf_func) (info->stream, "%s", regnames[value+32]);
      else if (operand->flags & AXP_OPERAND_RELATIVE)
	(*info->print_address_func) (memaddr + 4 + value, info);
      else if (operand->flags & AXP_OPERAND_SIGNED)
	(*info->fprintf_func) (info->stream, "%d", value);
      else
	(*info->fprintf_func) (info->stream, "%#x", value);

      if (operand->flags & AXP_OPERAND_PARENS)
	(*info->fprintf_func) (info->stream, ")");
      need_comma = 1;
    }
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d114 1
a114 1
      if (!(opcode->flags & AXP_OPCODE_NOPAL))
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1996, 1999 Free Software Foundation, Inc.
d23 1
d25 1
d69 1
a69 1
  unsigned insn, op, isa_mask;
a91 14
  isa_mask = AXP_OPCODE_NOPAL;
  switch (info->mach)
    {
    case bfd_mach_alpha_ev4:
      isa_mask |= AXP_OPCODE_EV4;
      break;
    case bfd_mach_alpha_ev5:
      isa_mask |= AXP_OPCODE_EV5;
      break;
    case bfd_mach_alpha_ev6:
      isa_mask |= AXP_OPCODE_EV6;
      break;
    }

d114 1
a114 1
      if (!(opcode->flags & isa_mask))
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1996, 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1996, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d30 2
a31 1
static const char * const osf_regnames[64] = {
d44 2
a45 1
static const char * const vms_regnames[64] = {
d77 3
a79 3
	{
	  opcode_index[op] = opcode;
	  while (opcode < opcode_end && op == AXP_OP (opcode->opcode))
d81 1
a81 1
	}
d110 2
a111 2
	(*info->memory_error_func) (status, memaddr, info);
	return -1;
d120 1
a120 1
  opcode_end = opcode_index[op + 1];
d123 1
a123 1
      if ((insn ^ opcode->opcode) & opcode->mask)
d133 2
a134 2
	int invalid = 0;
	for (opindex = opcode->operands; *opindex != 0; opindex++)
d136 1
a136 1
	    const struct alpha_operand *operand = alpha_operands + *opindex;
d140 1
a140 1
	if (invalid)
d150 1
a150 1

d185 1
a185 1
	  ((operand->flags & (AXP_OPERAND_PARENS | AXP_OPERAND_COMMA))
d197 1
a197 1
	(*info->fprintf_func) (info->stream, "%s", regnames[value + 32]);
@


