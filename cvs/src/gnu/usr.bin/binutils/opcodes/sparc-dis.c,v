head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.50
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.52
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.11.02.20.45.56;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.55;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.23.07.28.50;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.44;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.13.02;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.11.09;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.55.53;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.06;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.06;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.04.24;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.49.07;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.27.45;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.48.00;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.58.41;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.46;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.23.16;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* Print SPARC instructions.
   Copyright 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2002, 2003, 2004 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include <stdio.h>

#include "sysdep.h"
#include "opcode/sparc.h"
#include "dis-asm.h"
#include "libiberty.h"
#include "opintl.h"

/* Bitmask of v9 architectures.  */
#define MASK_V9 ((1 << SPARC_OPCODE_ARCH_V9) \
		 | (1 << SPARC_OPCODE_ARCH_V9A) \
		 | (1 << SPARC_OPCODE_ARCH_V9B))
/* 1 if INSN is for v9 only.  */
#define V9_ONLY_P(insn) (! ((insn)->architecture & ~MASK_V9))
/* 1 if INSN is for v9.  */
#define V9_P(insn) (((insn)->architecture & MASK_V9) != 0)

/* The sorted opcode table.  */
static const struct sparc_opcode **sorted_opcodes;

/* For faster lookup, after insns are sorted they are hashed.  */
/* ??? I think there is room for even more improvement.  */

#define HASH_SIZE 256
/* It is important that we only look at insn code bits as that is how the
   opcode table is hashed.  OPCODE_BITS is a table of valid bits for each
   of the main types (0,1,2,3).  */
static int opcode_bits[4] = { 0x01c00000, 0x0, 0x01f80000, 0x01f80000 };
#define HASH_INSN(INSN) \
  ((((INSN) >> 24) & 0xc0) | (((INSN) & opcode_bits[((INSN) >> 30) & 3]) >> 19))
struct opcode_hash
{
  struct opcode_hash *next;
  const struct sparc_opcode *opcode;
};
static struct opcode_hash *opcode_hash_table[HASH_SIZE];

static void build_hash_table
  PARAMS ((const struct sparc_opcode **, struct opcode_hash **, int));
static int is_delayed_branch PARAMS ((unsigned long));
static int compare_opcodes PARAMS ((const PTR, const PTR));
static int compute_arch_mask PARAMS ((unsigned long));

/* Sign-extend a value which is N bits long.  */
#define	SEX(value, bits) \
	((((int)(value)) << ((8 * sizeof (int)) - bits))	\
			 >> ((8 * sizeof (int)) - bits) )

static  char *reg_names[] =
{ "g0", "g1", "g2", "g3", "g4", "g5", "g6", "g7",	
  "o0", "o1", "o2", "o3", "o4", "o5", "sp", "o7",	
  "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7",	
  "i0", "i1", "i2", "i3", "i4", "i5", "fp", "i7",	
  "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",	
  "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",	
  "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
  "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",
  "f32", "f33", "f34", "f35", "f36", "f37", "f38", "f39",	
  "f40", "f41", "f42", "f43", "f44", "f45", "f46", "f47",	
  "f48", "f49", "f50", "f51", "f52", "f53", "f54", "f55",
  "f56", "f57", "f58", "f59", "f60", "f61", "f62", "f63",
/* psr, wim, tbr, fpsr, cpsr are v8 only.  */
  "y", "psr", "wim", "tbr", "pc", "npc", "fpsr", "cpsr"
};

#define	freg_names	(&reg_names[4 * 8])

/* These are ordered according to there register number in
   rdpr and wrpr insns.  */
static char *v9_priv_reg_names[] =
{
  "tpc", "tnpc", "tstate", "tt", "tick", "tba", "pstate", "tl",
  "pil", "cwp", "cansave", "canrestore", "cleanwin", "otherwin",
  "wstate", "fq"
  /* "ver" - special cased */
};

/* These are ordered according to there register number in
   rd and wr insns (-16).  */
static char *v9a_asr_reg_names[] =
{
  "pcr", "pic", "dcr", "gsr", "set_softint", "clear_softint",
  "softint", "tick_cmpr", "sys_tick", "sys_tick_cmpr"
};

/* Macros used to extract instruction fields.  Not all fields have
   macros defined here, only those which are actually used.  */

#define X_RD(i) (((i) >> 25) & 0x1f)
#define X_RS1(i) (((i) >> 14) & 0x1f)
#define X_LDST_I(i) (((i) >> 13) & 1)
#define X_ASI(i) (((i) >> 5) & 0xff)
#define X_RS2(i) (((i) >> 0) & 0x1f)
#define X_IMM(i,n) (((i) >> 0) & ((1 << (n)) - 1))
#define X_SIMM(i,n) SEX (X_IMM ((i), (n)), (n))
#define X_DISP22(i) (((i) >> 0) & 0x3fffff)
#define X_IMM22(i) X_DISP22 (i)
#define X_DISP30(i) (((i) >> 0) & 0x3fffffff)

/* These are for v9.  */
#define X_DISP16(i) (((((i) >> 20) & 3) << 14) | (((i) >> 0) & 0x3fff))
#define X_DISP19(i) (((i) >> 0) & 0x7ffff)
#define X_MEMBAR(i) ((i) & 0x7f)

/* Here is the union which was used to extract instruction fields
   before the shift and mask macros were written.

   union sparc_insn
     {
       unsigned long int code;
       struct
	 {
	   unsigned int anop:2;
	   #define	op	ldst.anop
	   unsigned int anrd:5;
	   #define	rd	ldst.anrd
	   unsigned int op3:6;
	   unsigned int anrs1:5;
	   #define	rs1	ldst.anrs1
	   unsigned int i:1;
	   unsigned int anasi:8;
	   #define	asi	ldst.anasi
	   unsigned int anrs2:5;
	   #define	rs2	ldst.anrs2
	   #define	shcnt	rs2
	 } ldst;
       struct
	 {
	   unsigned int anop:2, anrd:5, op3:6, anrs1:5, i:1;
	   unsigned int IMM13:13;
	   #define	imm13	IMM13.IMM13
	 } IMM13;
       struct
	 {
	   unsigned int anop:2;
	   unsigned int a:1;
	   unsigned int cond:4;
	   unsigned int op2:3;
	   unsigned int DISP22:22;
	   #define	disp22	branch.DISP22
	   #define	imm22	disp22
	 } branch;
       struct
	 {
	   unsigned int anop:2;
	   unsigned int a:1;
	   unsigned int z:1;
	   unsigned int rcond:3;
	   unsigned int op2:3;
	   unsigned int DISP16HI:2;
	   unsigned int p:1;
	   unsigned int _rs1:5;
	   unsigned int DISP16LO:14;
	 } branch16;
       struct
	 {
	   unsigned int anop:2;
	   unsigned int adisp30:30;
	   #define	disp30	call.adisp30
	 } call;
     };

   */

/* Nonzero if INSN is the opcode for a delayed branch.  */
static int
is_delayed_branch (insn)
     unsigned long insn;
{
  struct opcode_hash *op;

  for (op = opcode_hash_table[HASH_INSN (insn)]; op; op = op->next)
    {
      const struct sparc_opcode *opcode = op->opcode;
      if ((opcode->match & insn) == opcode->match
	  && (opcode->lose & insn) == 0)
	return (opcode->flags & F_DELAYED);
    }
  return 0;
}

/* extern void qsort (); */

/* Records current mask of SPARC_OPCODE_ARCH_FOO values, used to pass value
   to compare_opcodes.  */
static unsigned int current_arch_mask;

/* Print one instruction from MEMADDR on INFO->STREAM.

   We suffix the instruction with a comment that gives the absolute
   address involved, as well as its symbolic form, if the instruction
   is preceded by a findable `sethi' and it either adds an immediate
   displacement to that register, or it is an `add' or `or' instruction
   on that register.  */

int
print_insn_sparc (memaddr, info)
     bfd_vma memaddr;
     disassemble_info *info;
{
  FILE *stream = info->stream;
  bfd_byte buffer[4];
  unsigned long insn;
  register struct opcode_hash *op;
  /* Nonzero of opcode table has been initialized.  */
  static int opcodes_initialized = 0;
  /* bfd mach number of last call.  */
  static unsigned long current_mach = 0;
  bfd_vma (*getword) (const void *);

  if (!opcodes_initialized
      || info->mach != current_mach)
    {
      int i;

      current_arch_mask = compute_arch_mask (info->mach);

      if (!opcodes_initialized)
	sorted_opcodes = (const struct sparc_opcode **)
	  xmalloc (sparc_num_opcodes * sizeof (struct sparc_opcode *));
      /* Reset the sorted table so we can resort it.  */
      for (i = 0; i < sparc_num_opcodes; ++i)
	sorted_opcodes[i] = &sparc_opcodes[i];
      qsort ((char *) sorted_opcodes, sparc_num_opcodes,
	     sizeof (sorted_opcodes[0]), compare_opcodes);

      build_hash_table (sorted_opcodes, opcode_hash_table, sparc_num_opcodes);
      current_mach = info->mach;
      opcodes_initialized = 1;
    }

  {
    int status =
      (*info->read_memory_func) (memaddr, buffer, sizeof (buffer), info);
    if (status != 0)
      {
	(*info->memory_error_func) (status, memaddr, info);
	return -1;
      }
  }

  /* On SPARClite variants such as DANlite (sparc86x), instructions
     are always big-endian even when the machine is in little-endian mode.  */
  if (info->endian == BFD_ENDIAN_BIG || info->mach == bfd_mach_sparc_sparclite)
    getword = bfd_getb32;
  else
    getword = bfd_getl32;

  insn = getword (buffer);

  info->insn_info_valid = 1;			/* We do return this info.  */
  info->insn_type = dis_nonbranch;		/* Assume non branch insn.  */
  info->branch_delay_insns = 0;			/* Assume no delay.  */
  info->target = 0;				/* Assume no target known.  */

  for (op = opcode_hash_table[HASH_INSN (insn)]; op; op = op->next)
    {
      const struct sparc_opcode *opcode = op->opcode;

      /* If the insn isn't supported by the current architecture, skip it.  */
      if (! (opcode->architecture & current_arch_mask))
	continue;

      if ((opcode->match & insn) == opcode->match
	  && (opcode->lose & insn) == 0)
	{
	  /* Nonzero means that we have found an instruction which has
	     the effect of adding or or'ing the imm13 field to rs1.  */
	  int imm_added_to_rs1 = 0;
	  int imm_ored_to_rs1 = 0;

	  /* Nonzero means that we have found a plus sign in the args
	     field of the opcode table.  */
	  int found_plus = 0;
	  
	  /* Nonzero means we have an annulled branch.  */
	  int is_annulled = 0;

	  /* Do we have an `add' or `or' instruction combining an
             immediate with rs1?  */
	  if (opcode->match == 0x80102000) /* or */
	    imm_ored_to_rs1 = 1;
	  if (opcode->match == 0x80002000) /* add */
	    imm_added_to_rs1 = 1;

	  if (X_RS1 (insn) != X_RD (insn)
	      && strchr (opcode->args, 'r') != 0)
	      /* Can't do simple format if source and dest are different.  */
	      continue;
	  if (X_RS2 (insn) != X_RD (insn)
	      && strchr (opcode->args, 'O') != 0)
	      /* Can't do simple format if source and dest are different.  */
	      continue;

	  (*info->fprintf_func) (stream, opcode->name);

	  {
	    register const char *s;

	    if (opcode->args[0] != ',')
	      (*info->fprintf_func) (stream, " ");

	    for (s = opcode->args; *s != '\0'; ++s)
	      {
		while (*s == ',')
		  {
		    (*info->fprintf_func) (stream, ",");
		    ++s;
		    switch (*s)
		      {
		      case 'a':
			(*info->fprintf_func) (stream, "a");
			is_annulled = 1;
			++s;
			continue;
		      case 'N':
			(*info->fprintf_func) (stream, "pn");
			++s;
			continue;

		      case 'T':
			(*info->fprintf_func) (stream, "pt");
			++s;
			continue;

		      default:
			break;
		      }
		  }

		(*info->fprintf_func) (stream, " ");
			
		switch (*s)
		  {
		  case '+':
		    found_plus = 1;

		    /* note fall-through */
		  default:
		    (*info->fprintf_func) (stream, "%c", *s);
		    break;

		  case '#':
		    (*info->fprintf_func) (stream, "0");
		    break;

#define	reg(n)	(*info->fprintf_func) (stream, "%%%s", reg_names[n])
		  case '1':
		  case 'r':
		    reg (X_RS1 (insn));
		    break;

		  case '2':
		  case 'O':
		    reg (X_RS2 (insn));
		    break;

		  case 'd':
		    reg (X_RD (insn));
		    break;
#undef	reg

#define	freg(n)		(*info->fprintf_func) (stream, "%%%s", freg_names[n])
#define	fregx(n)	(*info->fprintf_func) (stream, "%%%s", freg_names[((n) & ~1) | (((n) & 1) << 5)])
		  case 'e':
		    freg (X_RS1 (insn));
		    break;
		  case 'v':	/* double/even */
		  case 'V':	/* quad/multiple of 4 */
		    fregx (X_RS1 (insn));
		    break;

		  case 'f':
		    freg (X_RS2 (insn));
		    break;
		  case 'B':	/* double/even */
		  case 'R':	/* quad/multiple of 4 */
		    fregx (X_RS2 (insn));
		    break;

		  case 'g':
		    freg (X_RD (insn));
		    break;
		  case 'H':	/* double/even */
		  case 'J':	/* quad/multiple of 4 */
		    fregx (X_RD (insn));
		    break;
#undef	freg
#undef	fregx

#define	creg(n)	(*info->fprintf_func) (stream, "%%c%u", (unsigned int) (n))
		  case 'b':
		    creg (X_RS1 (insn));
		    break;

		  case 'c':
		    creg (X_RS2 (insn));
		    break;

		  case 'D':
		    creg (X_RD (insn));
		    break;
#undef	creg

		  case 'h':
		    (*info->fprintf_func) (stream, "%%hi(%#x)",
					   ((unsigned) 0xFFFFFFFF
					    & ((int) X_IMM22 (insn) << 10)));
		    break;

		  case 'i':	/* 13 bit immediate */
		  case 'I':	/* 11 bit immediate */
		  case 'j':	/* 10 bit immediate */
		    {
		      int imm;

		      if (*s == 'i')
		        imm = X_SIMM (insn, 13);
		      else if (*s == 'I')
			imm = X_SIMM (insn, 11);
		      else
			imm = X_SIMM (insn, 10);

		      /* Check to see whether we have a 1+i, and take
			 note of that fact.

			 Note: because of the way we sort the table,
			 we will be matching 1+i rather than i+1,
			 so it is OK to assume that i is after +,
			 not before it.  */
		      if (found_plus)
			imm_added_to_rs1 = 1;
		      
		      if (imm <= 9)
			(*info->fprintf_func) (stream, "%d", imm);
		      else
			(*info->fprintf_func) (stream, "%#x", imm);
		    }
		    break;

		  case 'X':	/* 5 bit unsigned immediate */
		  case 'Y':	/* 6 bit unsigned immediate */
		    {
		      int imm = X_IMM (insn, *s == 'X' ? 5 : 6);

		      if (imm <= 9)
			(info->fprintf_func) (stream, "%d", imm);
		      else
			(info->fprintf_func) (stream, "%#x", (unsigned) imm);
		    }
		    break;

		  case '3':
		    (info->fprintf_func) (stream, "%d", X_IMM (insn, 3));
		    break;

		  case 'K':
		    {
		      int mask = X_MEMBAR (insn);
		      int bit = 0x40, printed_one = 0;
		      const char *name;

		      if (mask == 0)
			(info->fprintf_func) (stream, "0");
		      else
			while (bit)
			  {
			    if (mask & bit)
			      {
				if (printed_one)
				  (info->fprintf_func) (stream, "|");
				name = sparc_decode_membar (bit);
				(info->fprintf_func) (stream, "%s", name);
				printed_one = 1;
			      }
			    bit >>= 1;
			  }
		      break;
		    }

		  case 'k':
		    info->target = memaddr + SEX (X_DISP16 (insn), 16) * 4;
		    (*info->print_address_func) (info->target, info);
		    break;

		  case 'G':
		    info->target = memaddr + SEX (X_DISP19 (insn), 19) * 4;
		    (*info->print_address_func) (info->target, info);
		    break;

		  case '6':
		  case '7':
		  case '8':
		  case '9':
		    (*info->fprintf_func) (stream, "%%fcc%c", *s - '6' + '0');
		    break;

		  case 'z':
		    (*info->fprintf_func) (stream, "%%icc");
		    break;

		  case 'Z':
		    (*info->fprintf_func) (stream, "%%xcc");
		    break;

		  case 'E':
		    (*info->fprintf_func) (stream, "%%ccr");
		    break;

		  case 's':
		    (*info->fprintf_func) (stream, "%%fprs");
		    break;

		  case 'o':
		    (*info->fprintf_func) (stream, "%%asi");
		    break;
		    
		  case 'W':
		    (*info->fprintf_func) (stream, "%%tick");
		    break;

		  case 'P':
		    (*info->fprintf_func) (stream, "%%pc");
		    break;

		  case '?':
		    if (X_RS1 (insn) == 31)
		      (*info->fprintf_func) (stream, "%%ver");
		    else if ((unsigned) X_RS1 (insn) < 16)
		      (*info->fprintf_func) (stream, "%%%s",
					     v9_priv_reg_names[X_RS1 (insn)]);
		    else
		      (*info->fprintf_func) (stream, "%%reserved");
		    break;

		  case '!':
		    if ((unsigned) X_RD (insn) < 15)
		      (*info->fprintf_func) (stream, "%%%s",
					     v9_priv_reg_names[X_RD (insn)]);
		    else
		      (*info->fprintf_func) (stream, "%%reserved");
		    break;

		  case '/':
		    if (X_RS1 (insn) < 16 || X_RS1 (insn) > 25)
		      (*info->fprintf_func) (stream, "%%reserved");
		    else
		      (*info->fprintf_func) (stream, "%%%s",
					     v9a_asr_reg_names[X_RS1 (insn)-16]);
		    break;

		  case '_':
		    if (X_RD (insn) < 16 || X_RD (insn) > 25)
		      (*info->fprintf_func) (stream, "%%reserved");
		    else
		      (*info->fprintf_func) (stream, "%%%s",
					     v9a_asr_reg_names[X_RD (insn)-16]);
		    break;

		  case '*':
		    {
		      const char *name = sparc_decode_prefetch (X_RD (insn));

		      if (name)
			(*info->fprintf_func) (stream, "%s", name);
		      else
			(*info->fprintf_func) (stream, "%d", X_RD (insn));
		      break;
		    }
		    
		  case 'M':
		    (*info->fprintf_func) (stream, "%%asr%d", X_RS1 (insn));
		    break;
		    
		  case 'm':
		    (*info->fprintf_func) (stream, "%%asr%d", X_RD (insn));
		    break;
		    
		  case 'L':
		    info->target = memaddr + SEX (X_DISP30 (insn), 30) * 4;
		    (*info->print_address_func) (info->target, info);
		    break;

		  case 'n':
		    (*info->fprintf_func)
		      (stream, "%#x", SEX (X_DISP22 (insn), 22));
		    break;

		  case 'l':
		    info->target = memaddr + SEX (X_DISP22 (insn), 22) * 4;
		    (*info->print_address_func) (info->target, info);
		    break;

		  case 'A':
		    {
		      const char *name = sparc_decode_asi (X_ASI (insn));

		      if (name)
			(*info->fprintf_func) (stream, "%s", name);
		      else
			(*info->fprintf_func) (stream, "(%d)", X_ASI (insn));
		      break;
		    }

		  case 'C':
		    (*info->fprintf_func) (stream, "%%csr");
		    break;

		  case 'F':
		    (*info->fprintf_func) (stream, "%%fsr");
		    break;

		  case 'p':
		    (*info->fprintf_func) (stream, "%%psr");
		    break;

		  case 'q':
		    (*info->fprintf_func) (stream, "%%fq");
		    break;

		  case 'Q':
		    (*info->fprintf_func) (stream, "%%cq");
		    break;

		  case 't':
		    (*info->fprintf_func) (stream, "%%tbr");
		    break;

		  case 'w':
		    (*info->fprintf_func) (stream, "%%wim");
		    break;

		  case 'x':
		    (*info->fprintf_func) (stream, "%d",
					   ((X_LDST_I (insn) << 8)
					    + X_ASI (insn)));
		    break;

		  case 'y':
		    (*info->fprintf_func) (stream, "%%y");
		    break;

		  case 'u':
		  case 'U':
		    {
		      int val = *s == 'U' ? X_RS1 (insn) : X_RD (insn);
		      const char *name = sparc_decode_sparclet_cpreg (val);

		      if (name)
			(*info->fprintf_func) (stream, "%s", name);
		      else
			(*info->fprintf_func) (stream, "%%cpreg(%d)", val);
		      break;
		    }
		  }
	      }
	  }

	  /* If we are adding or or'ing something to rs1, then
	     check to see whether the previous instruction was
	     a sethi to the same register as in the sethi.
	     If so, attempt to print the result of the add or
	     or (in this context add and or do the same thing)
	     and its symbolic value.  */
	  if (imm_ored_to_rs1 || imm_added_to_rs1)
	    {
	      unsigned long prev_insn;
	      int errcode;

	      if (memaddr >= 4)
		errcode =
		  (*info->read_memory_func)
		  (memaddr - 4, buffer, sizeof (buffer), info);
	      else
		errcode = 1;

	      prev_insn = getword (buffer);

	      if (errcode == 0)
		{
		  /* If it is a delayed branch, we need to look at the
		     instruction before the delayed branch.  This handles
		     sequences such as:

		     sethi %o1, %hi(_foo), %o1
		     call _printf
		     or %o1, %lo(_foo), %o1  */

		  if (is_delayed_branch (prev_insn))
		    {
		      if (memaddr >= 8)
			errcode = (*info->read_memory_func)
			  (memaddr - 8, buffer, sizeof (buffer), info);
		      else
			errcode = 1;

		      prev_insn = getword (buffer);
		    }
		}

	      /* If there was a problem reading memory, then assume
		 the previous instruction was not sethi.  */
	      if (errcode == 0)
		{
		  /* Is it sethi to the same register?  */
		  if ((prev_insn & 0xc1c00000) == 0x01000000
		      && X_RD (prev_insn) == X_RS1 (insn))
		    {
		      (*info->fprintf_func) (stream, "\t! ");
		      info->target = 
			((unsigned) 0xFFFFFFFF
			 & ((int) X_IMM22 (prev_insn) << 10));
		      if (imm_added_to_rs1)
			info->target += X_SIMM (insn, 13);
		      else
			info->target |= X_SIMM (insn, 13);
		      (*info->print_address_func) (info->target, info);
		      info->insn_type = dis_dref;
		      info->data_size = 4;  /* FIXME!!! */
		    }
		}
	    }

	  if (opcode->flags & (F_UNBR|F_CONDBR|F_JSR))
	    {
		/* FIXME -- check is_annulled flag */
	      if (opcode->flags & F_UNBR)
		info->insn_type = dis_branch;
	      if (opcode->flags & F_CONDBR)
		info->insn_type = dis_condbranch;
	      if (opcode->flags & F_JSR)
		info->insn_type = dis_jsr;
	      if (opcode->flags & F_DELAYED)
		info->branch_delay_insns = 1;
	    }

	  return sizeof (buffer);
	}
    }

  info->insn_type = dis_noninsn;	/* Mark as non-valid instruction.  */
  (*info->fprintf_func) (stream, _("unknown"));
  return sizeof (buffer);
}

/* Given BFD mach number, return a mask of SPARC_OPCODE_ARCH_FOO values.  */

static int
compute_arch_mask (mach)
     unsigned long mach;
{
  switch (mach)
    {
    case 0 :
    case bfd_mach_sparc :
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V8);
    case bfd_mach_sparc_sparclet :
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_SPARCLET);
    case bfd_mach_sparc_sparclite :
    case bfd_mach_sparc_sparclite_le :
      /* sparclites insns are recognized by default (because that's how
	 they've always been treated, for better or worse).  Kludge this by
	 indicating generic v8 is also selected.  */
      return (SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_SPARCLITE)
	      | SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V8));
    case bfd_mach_sparc_v8plus :
    case bfd_mach_sparc_v9 :
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V9);
    case bfd_mach_sparc_v8plusa :
    case bfd_mach_sparc_v9a :
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V9A);
    case bfd_mach_sparc_v8plusb :
    case bfd_mach_sparc_v9b :
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V9B);
    }
  abort ();
}

/* Compare opcodes A and B.  */

static int
compare_opcodes (a, b)
     const PTR a;
     const PTR b;
{
  struct sparc_opcode *op0 = * (struct sparc_opcode **) a;
  struct sparc_opcode *op1 = * (struct sparc_opcode **) b;
  unsigned long int match0 = op0->match, match1 = op1->match;
  unsigned long int lose0 = op0->lose, lose1 = op1->lose;
  register unsigned int i;

  /* If one (and only one) insn isn't supported by the current architecture,
     prefer the one that is.  If neither are supported, but they're both for
     the same architecture, continue processing.  Otherwise (both unsupported
     and for different architectures), prefer lower numbered arch's (fudged
     by comparing the bitmasks).  */
  if (op0->architecture & current_arch_mask)
    {
      if (! (op1->architecture & current_arch_mask))
	return -1;
    }
  else
    {
      if (op1->architecture & current_arch_mask)
	return 1;
      else if (op0->architecture != op1->architecture)
	return op0->architecture - op1->architecture;
    }

  /* If a bit is set in both match and lose, there is something
     wrong with the opcode table.  */
  if (match0 & lose0)
    {
      fprintf
	(stderr,
	 /* xgettext:c-format */
	 _("Internal error:  bad sparc-opcode.h: \"%s\", %#.8lx, %#.8lx\n"),
	 op0->name, match0, lose0);
      op0->lose &= ~op0->match;
      lose0 = op0->lose;
    }

  if (match1 & lose1)
    {
      fprintf
	(stderr,
	 /* xgettext:c-format */
	 _("Internal error: bad sparc-opcode.h: \"%s\", %#.8lx, %#.8lx\n"),
	 op1->name, match1, lose1);
      op1->lose &= ~op1->match;
      lose1 = op1->lose;
    }

  /* Because the bits that are variable in one opcode are constant in
     another, it is important to order the opcodes in the right order.  */
  for (i = 0; i < 32; ++i)
    {
      unsigned long int x = 1 << i;
      int x0 = (match0 & x) != 0;
      int x1 = (match1 & x) != 0;

      if (x0 != x1)
	return x1 - x0;
    }

  for (i = 0; i < 32; ++i)
    {
      unsigned long int x = 1 << i;
      int x0 = (lose0 & x) != 0;
      int x1 = (lose1 & x) != 0;

      if (x0 != x1)
	return x1 - x0;
    }

  /* They are functionally equal.  So as long as the opcode table is
     valid, we can put whichever one first we want, on aesthetic grounds.  */

  /* Our first aesthetic ground is that aliases defer to real insns.  */
  {
    int alias_diff = (op0->flags & F_ALIAS) - (op1->flags & F_ALIAS);
    if (alias_diff != 0)
      /* Put the one that isn't an alias first.  */
      return alias_diff;
  }

  /* Except for aliases, two "identical" instructions had
     better have the same opcode.  This is a sanity check on the table.  */
  i = strcmp (op0->name, op1->name);
  if (i)
    {
      if (op0->flags & F_ALIAS) /* If they're both aliases, be arbitrary. */
	return i;
      else
	fprintf (stderr,
		 /* xgettext:c-format */
		 _("Internal error: bad sparc-opcode.h: \"%s\" == \"%s\"\n"),
		 op0->name, op1->name);
    }

  /* Fewer arguments are preferred.  */
  {
    int length_diff = strlen (op0->args) - strlen (op1->args);
    if (length_diff != 0)
      /* Put the one with fewer arguments first.  */
      return length_diff;
  }

  /* Put 1+i before i+1.  */
  {
    char *p0 = (char *) strchr (op0->args, '+');
    char *p1 = (char *) strchr (op1->args, '+');

    if (p0 && p1)
      {
	/* There is a plus in both operands.  Note that a plus
	   sign cannot be the first character in args,
	   so the following [-1]'s are valid.  */
	if (p0[-1] == 'i' && p1[1] == 'i')
	  /* op0 is i+1 and op1 is 1+i, so op1 goes first.  */
	  return 1;
	if (p0[1] == 'i' && p1[-1] == 'i')
	  /* op0 is 1+i and op1 is i+1, so op0 goes first.  */
	  return -1;
      }
  }

  /* Put 1,i before i,1.  */
  {
    int i0 = strncmp (op0->args, "i,1", 3) == 0;
    int i1 = strncmp (op1->args, "i,1", 3) == 0;

    if (i0 ^ i1)
      return i0 - i1;
  }

  /* They are, as far as we can tell, identical.
     Since qsort may have rearranged the table partially, there is
     no way to tell which one was first in the opcode table as
     written, so just say there are equal.  */
  /* ??? This is no longer true now that we sort a vector of pointers,
     not the table itself.  */
  return 0;
}

/* Build a hash table from the opcode table.
   OPCODE_TABLE is a sorted list of pointers into the opcode table.  */

static void
build_hash_table (opcode_table, hash_table, num_opcodes)
     const struct sparc_opcode **opcode_table;
     struct opcode_hash **hash_table;
     int num_opcodes;
{
  register int i;
  int hash_count[HASH_SIZE];
  static struct opcode_hash *hash_buf = NULL;

  /* Start at the end of the table and work backwards so that each
     chain is sorted.  */

  memset (hash_table, 0, HASH_SIZE * sizeof (hash_table[0]));
  memset (hash_count, 0, HASH_SIZE * sizeof (hash_count[0]));
  if (hash_buf != NULL)
    free (hash_buf);
  hash_buf = (struct opcode_hash *) xmalloc (sizeof (struct opcode_hash) * num_opcodes);
  for (i = num_opcodes - 1; i >= 0; --i)
    {
      register int hash = HASH_INSN (opcode_table[i]->match);
      register struct opcode_hash *h = &hash_buf[i];
      h->next = hash_table[hash];
      h->opcode = opcode_table[i];
      hash_table[hash] = h;
      ++hash_count[hash];
    }

#if 0 /* for debugging */
  {
    int min_count = num_opcodes, max_count = 0;
    int total;

    for (i = 0; i < HASH_SIZE; ++i)
      {
        if (hash_count[i] < min_count)
	  min_count = hash_count[i];
	if (hash_count[i] > max_count)
	  max_count = hash_count[i];
	total += hash_count[i];
      }

    printf ("Opcode hash table stats: min %d, max %d, ave %f\n",
	    min_count, max_count, (double) total / HASH_SIZE);
  }
#endif
}
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2000, 2002, 2003 Free Software Foundation, Inc.
d227 1
a227 1
  bfd_vma (*getword) PARAMS ((const unsigned char *));
@


1.6
log
@fix a seg fault issue with objdump on sparc64.

From: binutils CVS HEAD branch, based on rev 1.8
Reported by: Daniel Lucq <daniel at lucq dot org>

ok miod@@
@
text
@d3 1
a3 1
   2000 Free Software Foundation, Inc.
d5 13
a17 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d49 2
a50 1
struct opcode_hash {
d192 1
a192 1
      CONST struct sparc_opcode *opcode = op->opcode;
d261 1
a261 1
     are always big-endian even when the machine is in little-endian mode. */
d269 4
a272 4
  info->insn_info_valid = 1;			/* We do return this info */
  info->insn_type = dis_nonbranch;		/* Assume non branch insn */
  info->branch_delay_insns = 0;			/* Assume no delay */
  info->target = 0;				/* Assume no target known */
d276 1
a276 1
      CONST struct sparc_opcode *opcode = op->opcode;
d316 1
a316 1
	    register CONST char *s;
d320 1
d327 21
a347 20
		    switch (*s) {
		    case 'a':
		      (*info->fprintf_func) (stream, "a");
		      is_annulled = 1;
		      ++s;
		      continue;
		    case 'N':
		      (*info->fprintf_func) (stream, "pn");
		      ++s;
		      continue;

		    case 'T':
		      (*info->fprintf_func) (stream, "pt");
		      ++s;
		      continue;

		    default:
		      break;
		    }		/* switch on arg */
		  }		/* while there are comma started args */
d425 1
a425 1
					   (0xFFFFFFFF
d701 1
a701 1
		     sequences such as
d705 1
a705 2
		     or %o1, %lo(_foo), %o1
		     */
d729 2
a730 1
			(0xFFFFFFFF & (int) X_IMM22 (prev_insn) << 10);
d759 1
a759 1
  info->insn_type = dis_noninsn;	/* Mark as non-valid instruction */
@


1.5
log
@resolve conflicts.
@
text
@d685 3
a687 2
	      errcode =
		(*info->read_memory_func)
d689 3
d707 6
a712 2
		      errcode = (*info->read_memory_func)
			(memaddr - 8, buffer, sizeof (buffer), info);
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1989, 91-97, 1998 Free Software Foundation, Inc.
d29 2
a30 1
		 | (1 << SPARC_OPCODE_ARCH_V9A))
d100 1
a100 1
  "softint", "tick_cmpr"
d468 4
d560 1
a560 1
		    if (X_RS1 (insn) < 16 || X_RS1 (insn) > 23)
d568 1
a568 1
		    if (X_RD (insn) < 16 || X_RD (insn) > 23)
d779 3
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2 1
a2 1
   Copyright (C) 1989, 91-93, 1995, 1996 Free Software Foundation, Inc.
d18 3
a20 1
#include "ansidecl.h"
d24 1
a24 1
#include <string.h>
d34 3
d49 1
a49 1
  struct sparc_opcode *opcode;
d52 6
a57 1
static void build_hash_table ();
d93 8
a197 1
static int compare_opcodes ();
a201 1
static int compute_arch_mask ();
d224 1
d229 2
d232 11
a242 3
      qsort ((char *) sparc_opcodes, sparc_num_opcodes,
	     sizeof (sparc_opcodes[0]), compare_opcodes);
      build_hash_table (sparc_opcodes, opcode_hash_table, sparc_num_opcodes);
d257 4
a260 2
  if (info->endian == BFD_ENDIAN_BIG)
    insn = bfd_getb32 (buffer);
d262 3
a264 1
    insn = bfd_getl32 (buffer);
d285 1
d296 3
a298 2
	  if (opcode->match == 0x80102000 || opcode->match == 0x80002000)
	  /*			  (or)				 (add)  */
d470 1
a470 1
		      char *name;
d526 1
a526 1

d553 16
d571 1
a571 1
		      char *name = sparc_decode_prefetch (X_RD (insn));
d579 1
a579 1

d605 1
a605 1
		      char *name = sparc_decode_asi (X_ASI (insn));
d656 1
a656 1
		      char *name = sparc_decode_sparclet_cpreg (val);
d674 1
a674 1
	  if (imm_added_to_rs1)
d682 1
a682 4
	      if (info->endian == BFD_ENDIAN_BIG)
		prev_insn = bfd_getb32 (buffer);
	      else
		prev_insn = bfd_getl32 (buffer);
d699 1
a699 4
		      if (info->endian == BFD_ENDIAN_BIG)
			prev_insn = bfd_getb32 (buffer);
		      else
			prev_insn = bfd_getl32 (buffer);
d713 5
a717 2
			(0xFFFFFFFF & (int) X_IMM22 (prev_insn) << 10)
			| X_SIMM (insn, 13);
d743 1
a743 1
  (*info->fprintf_func) (stream, "unknown");
d761 1
d781 2
a782 1
     char *a, *b;
d784 2
a785 2
  struct sparc_opcode *op0 = (struct sparc_opcode *) a;
  struct sparc_opcode *op1 = (struct sparc_opcode *) b;
d812 5
a816 2
      fprintf (stderr, "Internal error:  bad sparc-opcode.h: \"%s\", %#.8lx, %#.8lx\n",
	       op0->name, match0, lose0);
d823 5
a827 2
      fprintf (stderr, "Internal error: bad sparc-opcode.h: \"%s\", %#.8lx, %#.8lx\n",
	       op1->name, match1, lose1);
d874 2
a875 1
		 "Internal error: bad sparc-opcode.h: \"%s\" == \"%s\"\n",
d889 2
a890 2
    char *p0 = (char *) strchr(op0->args, '+');
    char *p1 = (char *) strchr(op1->args, '+');
d919 2
d924 2
a925 1
/* Build a hash table from the opcode table.  */
d928 2
a929 2
build_hash_table (table, hash_table, num_opcodes)
     struct sparc_opcode *table;
d947 1
a947 1
      register int hash = HASH_INSN (sparc_opcodes[i].match);
d950 1
a950 1
      h->opcode = &sparc_opcodes[i];
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@a202 1
  register unsigned int i;
d230 4
a233 1
  insn = bfd_getb32 (buffer);
d262 3
a264 3
	  /* Do we have an `add' or `or' instruction where rs1 is the same
	     as rsd, and which has the i bit set?  */
	  if ((opcode->match == 0x80102000 || opcode->match == 0x80002000)
a265 1
	      && X_RS1 (insn) == X_RD (insn))
d633 4
a636 1
	      prev_insn = bfd_getb32 (buffer);
d653 4
a656 1
		      prev_insn = bfd_getb32 (buffer);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1989, 1991, 1992, 1993, 1995 Free Software Foundation, Inc.
d24 8
d91 2
a92 1
#define X_IMM13(i) (((i) >> 0) & 0x1fff)
a178 3
/* Nonzero of opcode table has been initialized.  */
static int opcodes_initialized = 0;

d182 5
d195 2
a196 2
static int
print_insn (memaddr, info, sparc64_p)
a198 1
     int sparc64_p;
d205 4
d210 2
a211 1
  if (!opcodes_initialized)
d213 2
a214 1
      qsort ((char *) sparc_opcodes, NUMOPCODES,
d216 2
a217 1
      build_hash_table (sparc_opcodes, opcode_hash_table, NUMOPCODES);
d242 2
a243 8
      /* If the current architecture isn't sparc64, skip sparc64 insns.  */
      if (!sparc64_p
	  && opcode->architecture == v9)
	continue;

      /* If the current architecture is sparc64, skip sparc32 only insns.  */
      if (sparc64_p
	  && (opcode->flags & F_NOTV9))
d271 4
d333 1
d390 3
a392 1
		  case 'i':
d394 8
a401 1
		      int imm = SEX (X_IMM13 (insn), 13);
d420 2
a421 2
		  case 'I':	/* 11 bit immediate.  */
		  case 'j':	/* 10 bit immediate.  */
d423 1
a423 6
		      int imm;

		      if (*s == 'I')
			imm = SEX (X_IMM13 (insn), 11);
		      else
			imm = SEX (X_IMM13 (insn), 10);
a424 10
		      /* Check to see whether we have a 1+i, and take
			 note of that fact.
			 
			 Note: because of the way we sort the table,
			 we will be matching 1+i rather than i+1,
			 so it is OK to assume that i is after +,
			 not before it.  */
		      if (found_plus)
			imm_added_to_rs1 = 1;
		      
d601 13
d664 1
a664 1
			| SEX (X_IMM13 (insn), 13);
d690 1
a690 1
  (*info->fprintf_func) (stream, "%#8x", insn);
d694 29
d735 18
a792 4
  /* Put non-sparc64 insns ahead of sparc64 ones.  */
  if ((op0->architecture == v9) != (op1->architecture == v9))
    return (op0->architecture == v9) - (op1->architecture == v9);

d808 1
d810 1
a810 1
	  return i;
d812 4
a815 3
	  fprintf (stderr,
		   "Internal error: bad sparc-opcode.h: \"%s\" == \"%s\"\n",
		   op0->name, op1->name);
a907 16
}

int
print_insn_sparc (memaddr, info)
     bfd_vma memaddr;
     disassemble_info *info;
{
  return print_insn (memaddr, info, 0);
}

int
print_insn_sparc64 (memaddr, info)
     bfd_vma memaddr;
     disassemble_info *info;
{
  return print_insn (memaddr, info, 1);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright (C) 1989, 91-93, 1995, 1996 Free Software Foundation, Inc.
a23 8
/* Bitmask of v9 architectures.  */
#define MASK_V9 ((1 << SPARC_OPCODE_ARCH_V9) \
		 | (1 << SPARC_OPCODE_ARCH_V9A))
/* 1 if INSN is for v9 only.  */
#define V9_ONLY_P(insn) (! ((insn)->architecture & ~MASK_V9))
/* 1 if INSN is for v9.  */
#define V9_P(insn) (((insn)->architecture & MASK_V9) != 0)

d83 1
a83 2
#define X_IMM(i,n) (((i) >> 0) & ((1 << (n)) - 1))
#define X_SIMM(i,n) SEX (X_IMM ((i), (n)), (n))
d170 3
a175 5
/* Records current mask of SPARC_OPCODE_ARCH_FOO values, used to pass value
   to compare_opcodes.  */
static unsigned int current_arch_mask;
static int compute_arch_mask ();

d184 2
a185 2
int
print_insn_sparc (memaddr, info)
d188 1
a194 4
  /* Nonzero of opcode table has been initialized.  */
  static int opcodes_initialized = 0;
  /* bfd mach number of last call.  */
  static unsigned long current_mach = 0;
d196 1
a196 2
  if (!opcodes_initialized
      || info->mach != current_mach)
d198 1
a198 2
      current_arch_mask = compute_arch_mask (info->mach);
      qsort ((char *) sparc_opcodes, sparc_num_opcodes,
d200 1
a200 2
      build_hash_table (sparc_opcodes, opcode_hash_table, sparc_num_opcodes);
      current_mach = info->mach;
d225 8
a232 2
      /* If the insn isn't supported by the current architecture, skip it.  */
      if (! (opcode->architecture & current_arch_mask))
a259 4
	  if (X_RS2 (insn) != X_RD (insn)
	      && strchr (opcode->args, 'O') != 0)
	      /* Can't do simple format if source and dest are different.  */
	      continue;
a317 1
		  case 'O':
d374 1
a374 3
		  case 'i':	/* 13 bit immediate */
		  case 'I':	/* 11 bit immediate */
		  case 'j':	/* 10 bit immediate */
d376 1
a376 8
		      int imm;

		      if (*s == 'i')
		        imm = X_SIMM (insn, 13);
		      else if (*s == 'I')
			imm = X_SIMM (insn, 11);
		      else
			imm = X_SIMM (insn, 10);
d395 2
a396 2
		  case 'X':	/* 5 bit unsigned immediate */
		  case 'Y':	/* 6 bit unsigned immediate */
d398 6
a403 1
		      int imm = X_IMM (insn, *s == 'X' ? 5 : 6);
d405 10
a590 13

		  case 'u':
		  case 'U':
		    {
		      int val = *s == 'U' ? X_RS1 (insn) : X_RD (insn);
		      char *name = sparc_decode_sparclet_cpreg (val);

		      if (name)
			(*info->fprintf_func) (stream, "%s", name);
		      else
			(*info->fprintf_func) (stream, "%%cpreg(%d)", val);
		      break;
		    }
d641 1
a641 1
			| X_SIMM (insn, 13);
d667 1
a667 1
  (*info->fprintf_func) (stream, "unknown");
a670 29
/* Given BFD mach number, return a mask of SPARC_OPCODE_ARCH_FOO values.  */

static int
compute_arch_mask (mach)
     unsigned long mach;
{
  switch (mach)
    {
    case 0 :
    case bfd_mach_sparc :
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V8);
    case bfd_mach_sparc_sparclet :
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_SPARCLET);
    case bfd_mach_sparc_sparclite :
      /* sparclites insns are recognized by default (because that's how
	 they've always been treated, for better or worse).  Kludge this by
	 indicating generic v8 is also selected.  */
      return (SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_SPARCLITE)
	      | SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V8));
    case bfd_mach_sparc_v8plus :
    case bfd_mach_sparc_v9 :
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V9);
    case bfd_mach_sparc_v8plusa :
    case bfd_mach_sparc_v9a :
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V9A);
    }
  abort ();
}

a682 18
  /* If one (and only one) insn isn't supported by the current architecture,
     prefer the one that is.  If neither are supported, but they're both for
     the same architecture, continue processing.  Otherwise (both unsupported
     and for different architectures), prefer lower numbered arch's (fudged
     by comparing the bitmasks).  */
  if (op0->architecture & current_arch_mask)
    {
      if (! (op1->architecture & current_arch_mask))
	return -1;
    }
  else
    {
      if (op1->architecture & current_arch_mask)
	return 1;
      else if (op0->architecture != op1->architecture)
	return op0->architecture - op1->architecture;
    }

d723 4
a741 1
    {
d743 1
a743 1
	return i;
d745 3
a747 4
	fprintf (stderr,
		 "Internal error: bad sparc-opcode.h: \"%s\" == \"%s\"\n",
		 op0->name, op1->name);
    }
d840 16
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d203 1
d231 1
a231 4
  if (info->endian == BFD_ENDIAN_BIG)
    insn = bfd_getb32 (buffer);
  else
    insn = bfd_getl32 (buffer);
d260 3
a262 3
	  /* Do we have an `add' or `or' instruction combining an
             immediate with rs1?  */
	  if (opcode->match == 0x80102000 || opcode->match == 0x80002000)
d264 1
d632 1
a632 4
	      if (info->endian == BFD_ENDIAN_BIG)
		prev_insn = bfd_getb32 (buffer);
	      else
		prev_insn = bfd_getl32 (buffer);
d649 1
a649 4
		      if (info->endian == BFD_ENDIAN_BIG)
			prev_insn = bfd_getb32 (buffer);
		      else
			prev_insn = bfd_getl32 (buffer);
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1989, 91-94, 1995, 1996, 1997 Free Software Foundation, Inc.
a17 2
#include <stdio.h>

a18 1
#include "sysdep.h"
d22 1
d47 1
a47 6

static void build_hash_table
  PARAMS ((struct sparc_opcode *, struct opcode_hash **, int));
static int is_delayed_branch PARAMS ((unsigned long));
static int compare_opcodes PARAMS ((const PTR, const PTR));
static int compute_arch_mask PARAMS ((unsigned long));
d180 1
d185 1
d437 1
a437 1
		      const char *name;
d522 1
a522 1
		      const char *name = sparc_decode_prefetch (X_RD (insn));
d556 1
a556 1
		      const char *name = sparc_decode_asi (X_ASI (insn));
d607 1
a607 1
		      const char *name = sparc_decode_sparclet_cpreg (val);
d734 1
a734 2
     const PTR a;
     const PTR b;
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1989, 91-97, 1998 Free Software Foundation, Inc.
d20 1
a24 1
#include "opintl.h"
a33 3
/* The sorted opcode table.  */
static const struct sparc_opcode **sorted_opcodes;

d46 1
a46 1
  const struct sparc_opcode *opcode;
d51 1
a51 1
  PARAMS ((const struct sparc_opcode **, struct opcode_hash **, int));
a89 8
/* These are ordered according to there register number in
   rd and wr insns (-16).  */
static char *v9a_asr_reg_names[] =
{
  "pcr", "pic", "dcr", "gsr", "set_softint", "clear_softint",
  "softint", "tick_cmpr"
};

a212 1
  bfd_vma (*getword) PARAMS ((const unsigned char *));
a216 2
      int i;

d218 3
a220 11

      if (!opcodes_initialized)
	sorted_opcodes = (const struct sparc_opcode **)
	  xmalloc (sparc_num_opcodes * sizeof (struct sparc_opcode *));
      /* Reset the sorted table so we can resort it.  */
      for (i = 0; i < sparc_num_opcodes; ++i)
	sorted_opcodes[i] = &sparc_opcodes[i];
      qsort ((char *) sorted_opcodes, sparc_num_opcodes,
	     sizeof (sorted_opcodes[0]), compare_opcodes);

      build_hash_table (sorted_opcodes, opcode_hash_table, sparc_num_opcodes);
d235 2
a236 4
  /* On SPARClite variants such as DANlite (sparc86x), instructions
     are always big-endian even when the machine is in little-endian mode. */
  if (info->endian == BFD_ENDIAN_BIG || info->mach == bfd_mach_sparc_sparclite)
    getword = bfd_getb32;
d238 1
a238 3
    getword = bfd_getl32;

  insn = getword (buffer);
a258 1
	  int imm_ored_to_rs1 = 0;
d269 2
a270 3
	  if (opcode->match == 0x80102000) /* or */
	    imm_ored_to_rs1 = 1;
	  if (opcode->match == 0x80002000) /* add */
d498 1
a498 1
		    
a524 16
		  case '/':
		    if (X_RS1 (insn) < 16 || X_RS1 (insn) > 23)
		      (*info->fprintf_func) (stream, "%%reserved");
		    else
		      (*info->fprintf_func) (stream, "%%%s",
					     v9a_asr_reg_names[X_RS1 (insn)-16]);
		    break;

		  case '_':
		    if (X_RD (insn) < 16 || X_RD (insn) > 23)
		      (*info->fprintf_func) (stream, "%%reserved");
		    else
		      (*info->fprintf_func) (stream, "%%%s",
					     v9a_asr_reg_names[X_RD (insn)-16]);
		    break;

d535 1
a535 1
		    
d630 1
a630 1
	  if (imm_ored_to_rs1 || imm_added_to_rs1)
d638 4
a641 1
	      prev_insn = getword (buffer);
d658 4
a661 1
		      prev_insn = getword (buffer);
d675 2
a676 5
			(0xFFFFFFFF & (int) X_IMM22 (prev_insn) << 10);
		      if (imm_added_to_rs1)
			info->target += X_SIMM (insn, 13);
		      else
			info->target |= X_SIMM (insn, 13);
d702 1
a702 1
  (*info->fprintf_func) (stream, _("unknown"));
a719 1
    case bfd_mach_sparc_sparclite_le :
d742 2
a743 2
  struct sparc_opcode *op0 = * (struct sparc_opcode **) a;
  struct sparc_opcode *op1 = * (struct sparc_opcode **) b;
d770 2
a771 5
      fprintf
	(stderr,
	 /* xgettext:c-format */
	 _("Internal error:  bad sparc-opcode.h: \"%s\", %#.8lx, %#.8lx\n"),
	 op0->name, match0, lose0);
d778 2
a779 5
      fprintf
	(stderr,
	 /* xgettext:c-format */
	 _("Internal error: bad sparc-opcode.h: \"%s\", %#.8lx, %#.8lx\n"),
	 op1->name, match1, lose1);
d826 1
a826 2
		 /* xgettext:c-format */
		 _("Internal error: bad sparc-opcode.h: \"%s\" == \"%s\"\n"),
d840 2
a841 2
    char *p0 = (char *) strchr (op0->args, '+');
    char *p1 = (char *) strchr (op1->args, '+');
a869 2
  /* ??? This is no longer true now that we sort a vector of pointers,
     not the table itself.  */
d873 1
a873 2
/* Build a hash table from the opcode table.
   OPCODE_TABLE is a sorted list of pointers into the opcode table.  */
d876 2
a877 2
build_hash_table (opcode_table, hash_table, num_opcodes)
     const struct sparc_opcode **opcode_table;
d895 1
a895 1
      register int hash = HASH_INSN (opcode_table[i]->match);
d898 1
a898 1
      h->opcode = opcode_table[i];
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000 Free Software Foundation, Inc.
d28 1
a28 2
		 | (1 << SPARC_OPCODE_ARCH_V9A) \
		 | (1 << SPARC_OPCODE_ARCH_V9B))
d98 1
a98 1
  "softint", "tick_cmpr", "sys_tick", "sys_tick_cmpr"
a465 4
		  case '3':
		    (info->fprintf_func) (stream, "%d", X_IMM (insn, 3));
		    break;

d554 1
a554 1
		    if (X_RS1 (insn) < 16 || X_RS1 (insn) > 25)
d562 1
a562 1
		    if (X_RD (insn) < 16 || X_RD (insn) > 25)
a772 3
    case bfd_mach_sparc_v8plusb :
    case bfd_mach_sparc_v9b :
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V9B);
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2000, 2002, 2003 Free Software Foundation, Inc.
d5 13
a17 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d49 1
a49 2
struct opcode_hash
{
d191 1
a191 1
      const struct sparc_opcode *opcode = op->opcode;
d260 1
a260 1
     are always big-endian even when the machine is in little-endian mode.  */
d268 4
a271 4
  info->insn_info_valid = 1;			/* We do return this info.  */
  info->insn_type = dis_nonbranch;		/* Assume non branch insn.  */
  info->branch_delay_insns = 0;			/* Assume no delay.  */
  info->target = 0;				/* Assume no target known.  */
d275 1
a275 1
      const struct sparc_opcode *opcode = op->opcode;
d315 1
a315 1
	    register const char *s;
a318 1

d325 20
a344 21
		    switch (*s)
		      {
		      case 'a':
			(*info->fprintf_func) (stream, "a");
			is_annulled = 1;
			++s;
			continue;
		      case 'N':
			(*info->fprintf_func) (stream, "pn");
			++s;
			continue;

		      case 'T':
			(*info->fprintf_func) (stream, "pt");
			++s;
			continue;

		      default:
			break;
		      }
		  }
d422 1
a422 1
					   ((unsigned) 0xFFFFFFFF
d685 2
a686 3
	      if (memaddr >= 4)
		errcode =
		  (*info->read_memory_func)
a687 3
	      else
		errcode = 1;

d694 1
a694 1
		     sequences such as:
d698 2
a699 1
		     or %o1, %lo(_foo), %o1  */
d703 2
a704 6
		      if (memaddr >= 8)
			errcode = (*info->read_memory_func)
			  (memaddr - 8, buffer, sizeof (buffer), info);
		      else
			errcode = 1;

d719 1
a719 2
			((unsigned) 0xFFFFFFFF
			 & ((int) X_IMM22 (prev_insn) << 10));
d748 1
a748 1
  info->insn_type = dis_noninsn;	/* Mark as non-valid instruction.  */
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2000, 2002, 2003, 2004 Free Software Foundation, Inc.
d227 1
a227 1
  bfd_vma (*getword) (const void *);
@


