head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.54
	OPENBSD_6_1_BASE:1.1.1.3
	OPENBSD_6_0:1.1.1.3.0.50
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.46
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.48
	OPENBSD_5_8_BASE:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.40
	OPENBSD_5_7_BASE:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.44
	OPENBSD_5_6_BASE:1.1.1.3
	OPENBSD_5_5:1.1.1.3.0.42
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.38
	OPENBSD_5_4_BASE:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.36
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.34
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.32
	OPENBSD_5_0:1.1.1.3.0.30
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.28
	OPENBSD_4_9_BASE:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.26
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.22
	OPENBSD_4_7_BASE:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.24
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.20
	OPENBSD_4_5_BASE:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.18
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.16
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.14
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.12
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.10
	OPENBSD_4_0_BASE:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	BINUTILS_2_15:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	BINUTILS-2_14:1.1.1.3
	OPENBSD_3_5:1.1.1.2.0.8
	OPENBSD_3_5_BASE:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.6
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.4
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.2
	OPENBSD_3_2_BASE:1.1.1.2
	binutils-2_11_2:1.1.1.2
	OPENBSD_3_1:1.1.1.1.0.8
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.6
	OPENBSD_3_0_BASE:1.1.1.1
	BINUTILS-2_10_1:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.4
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.2
	OPENBSD_2_8_BASE:1.1.1.1
	BINUTILS-2_10:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2000.09.12.14.47.50;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.09.12.14.47.50;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.05.13.13.55.23;	author fgsch;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.05.17.20.42.42;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* Disassemble AVR instructions.
   Copyright (C) 1999, 2000 Free Software Foundation, Inc.

   Contributed by Denis Chertykov <denisc@@overta.ru>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */


#include "sysdep.h"
#include "dis-asm.h"
#include "opintl.h"

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned long u32;

#define IFMASK(a,b)     ((opcode & (a)) == (b))

static char* SREG_flags = "CZNVSHTI";
static char* sect94[] = {"COM","NEG","SWAP","INC","NULL","ASR","LSR","ROR",
			 0,0,"DEC",0,0,0,0,0};
static char* sect98[] = {"CBI","SBIC","SBI","SBIS"};
static char* branchs[] = {
  "BRCS","BREQ","BRMI","BRVS",
  "BRLT","BRHS","BRTS","BRIE",
  "BRCC","BRNE","BRPL","BRVC",
  "BRGE","BRHC","BRTC","BRID"
};

static char* last4[] = {"BLD","BST","SBRC","SBRS"};


static void dispLDD PARAMS ((u16, char *));

static void
dispLDD (opcode, dest)
     u16 opcode;
     char *dest;
{
  opcode = (((opcode & 0x2000) >> 8) | ((opcode & 0x0c00) >> 7)
	    | (opcode & 7));
  sprintf(dest, "%d", opcode);
}


static void regPP PARAMS ((u16, char *));

static void
regPP (opcode, dest)
     u16 opcode;
     char *dest;
{
  opcode = ((opcode & 0x0600) >> 5) | (opcode & 0xf);
  sprintf(dest, "0x%02X", opcode);
}


static void reg50 PARAMS ((u16, char *));

static void
reg50 (opcode, dest)
     u16 opcode;
     char *dest;
{
  opcode = (opcode & 0x01f0) >> 4;
  sprintf(dest, "R%d", opcode);
}


static void reg104 PARAMS ((u16, char *));

static void
reg104 (opcode, dest)
     u16 opcode;
     char *dest;
{
  opcode = (opcode & 0xf) | ((opcode & 0x0200) >> 5);
  sprintf(dest, "R%d", opcode);
}


static void reg40 PARAMS ((u16, char *));

static void
reg40 (opcode, dest)
     u16 opcode;
     char *dest;
{
  opcode = (opcode & 0xf0) >> 4;
  sprintf(dest, "R%d", opcode + 16);
}


static void reg20w PARAMS ((u16, char *));

static void
reg20w (opcode, dest)
     u16 opcode;
     char *dest;
{
  opcode = (opcode & 0x30) >> 4;
  sprintf(dest, "R%d", 24 + opcode * 2);
}


static void lit404 PARAMS ((u16, char *));

static void
lit404 (opcode, dest)
     u16 opcode;
     char *dest;
{
  opcode = ((opcode & 0xf00) >> 4) | (opcode & 0xf);
  sprintf(dest, "0x%02X", opcode);
}


static void lit204 PARAMS ((u16, char *));

static void
lit204 (opcode, dest)
     u16 opcode;
     char *dest;
{
  opcode = ((opcode & 0xc0) >> 2) | (opcode & 0xf);
  sprintf(dest, "0x%02X", opcode);
}


static void add0fff PARAMS ((u16, char *, int));

static void
add0fff (op, dest, pc)
     u16 op;
     char *dest;
     int pc;
{
  int rel_addr = (((op & 0xfff) ^ 0x800) - 0x800) * 2;
  sprintf(dest, ".%+-8d ; 0x%06X", rel_addr, pc + 2 + rel_addr);
}


static void add03f8 PARAMS ((u16, char *, int));

static void
add03f8 (op, dest, pc)
     u16 op;
     char *dest;
     int pc;
{
  int rel_addr = ((((op >> 3) & 0x7f) ^ 0x40) - 0x40) * 2;
  sprintf(dest, ".%+-8d ; 0x%06X", rel_addr, pc + 2 + rel_addr);
}


static u16 avrdis_opcode PARAMS ((bfd_vma, disassemble_info *));

static u16
avrdis_opcode (addr, info)
     bfd_vma addr;
     disassemble_info *info;
{
  bfd_byte buffer[2];
  int status;
  status = info->read_memory_func(addr, buffer, 2, info);
  if (status != 0)
    {
      info->memory_error_func(status, addr, info);
      return -1;
    }
  return bfd_getl16 (buffer);
}


int
print_insn_avr(addr, info)
     bfd_vma addr;
     disassemble_info *info;
{
  char rr[200];
  char rd[200];
  u16 opcode;
  void *stream = info->stream;
  fprintf_ftype prin = info->fprintf_func;
  int cmd_len = 2;

  opcode = avrdis_opcode (addr, info);

  if (IFMASK(0xd000, 0x8000))
    {
      char letter;
      reg50(opcode, rd);
      dispLDD(opcode, rr);
      if (opcode & 8)
	letter = 'Y';
      else
	letter = 'Z';
      if (opcode & 0x0200)
	(*prin) (stream, "    STD     %c+%s,%s", letter, rr, rd);
      else
	(*prin) (stream, "    LDD     %s,%c+%s", rd, letter, rr);
    }
  else
    {
      switch (opcode & 0xf000)
        {
        case 0x0000:
	  {
	    reg50(opcode, rd);
	    reg104(opcode, rr);
	    switch (opcode & 0x0c00)
	      {
	      case 0x0000:
		(*prin) (stream, "    NOP");
		break;
	      case 0x0400:
		(*prin) (stream, "    CPC     %s,%s", rd, rr);
		break;
	      case 0x0800:
		(*prin) (stream, "    SBC     %s,%s", rd, rr);
		break;
	      case 0x0c00:
		(*prin) (stream, "    ADD     %s,%s", rd, rr);
		break;
	      }
	  }
	  break;
        case 0x1000:
	  {
	    reg50(opcode, rd);
	    reg104(opcode, rr);
	    switch (opcode & 0x0c00)
	      {
	      case 0x0000:
		(*prin) (stream, "    CPSE    %s,%s", rd, rr);
		break;
	      case 0x0400:
		(*prin) (stream, "    CP      %s,%s", rd, rr);
		break;
	      case 0x0800:
		(*prin) (stream, "    SUB     %s,%s", rd, rr);
		break;
	      case 0x0c00:
		(*prin) (stream, "    ADC     %s,%s", rd, rr);
		break;
	      }
	  }
	  break;
        case 0x2000:
	  {
	    reg50(opcode, rd);
	    reg104(opcode, rr);
	    switch (opcode & 0x0c00)
	      {
	      case 0x0000:
		(*prin) (stream, "    AND     %s,%s", rd, rr);
		break;
	      case 0x0400:
		(*prin) (stream, "    EOR     %s,%s", rd, rr);
		break;
	      case 0x0800:
		(*prin) (stream, "    OR      %s,%s", rd, rr);
		break;
	      case 0x0c00:
		(*prin) (stream, "    MOV     %s,%s", rd, rr);
		break;
	      }
	  }
	  break;
        case 0x3000:
	  {
	    reg40(opcode, rd);
	    lit404(opcode, rr);
	    (*prin) (stream, "    CPI     %s,%s", rd, rr);
	  }
	  break;
        case 0x4000:
	  {
	    reg40(opcode, rd);
	    lit404(opcode, rr);
	    (*prin) (stream, "    SBCI    %s,%s", rd, rr);
	  }
	  break;
        case 0x5000:
	  {
	    reg40(opcode, rd);
	    lit404(opcode, rr);
	    (*prin) (stream, "    SUBI    %s,%s", rd, rr);
	  }
	  break;
        case 0x6000:
	  {
	    reg40(opcode, rd);
	    lit404(opcode, rr);
	    (*prin) (stream, "    ORI     %s,%s", rd, rr);
	  }
	  break;
        case 0x7000:
	  {
	    reg40(opcode, rd);
	    lit404(opcode, rr);
	    (*prin) (stream, "    ANDI    %s,%s", rd, rr);
	  }
	  break;
        case 0x9000:
	  {
	    switch (opcode & 0x0e00)
	      {
	      case 0x0000:
		{
		  reg50(opcode, rd);
		  switch (opcode & 0xf)
		    {
		    case 0x0:
		      {
			(*prin) (stream, "    LDS     %s,0x%04X", rd,
				 avrdis_opcode(addr + 2, info));
			cmd_len = 4;
		      }
		      break;
		    case 0x1:
		      (*prin) (stream, "    LD      %s,Z+", rd);
		      break;
		    case 0x2:
		      (*prin) (stream, "    LD      %s,-Z", rd);
		      break;
		    case 0x9:
		      (*prin) (stream, "    LD      %s,Y+", rd);
		      break;
		    case 0xa:
		      (*prin) (stream, "    LD      %s,-Y", rd);
		      break;
		    case 0xc:
		      (*prin) (stream, "    LD      %s,X", rd);
		      break;
		    case 0xd:
		      (*prin) (stream, "    LD      %s,X+", rd);
		      break;
		    case 0xe:
		      (*prin) (stream, "    LD      %s,-X", rd);
		      break;
		    case 0xf:
		      (*prin) (stream, "    POP     %s", rd);
		      break;
		    default:
		      (*prin) (stream, "    ????");
		      break;
		    }
		}
		break;
	      case 0x0200:
		{
		  reg50(opcode, rd);
		  switch (opcode & 0xf)
		    {
		    case 0x0:
		      {
			(*prin) (stream, "    STS     0x%04X,%s",
				 avrdis_opcode(addr + 2, info), rd);
			cmd_len = 4;
		      }
		      break;
		    case 0x1:
		      (*prin) (stream, "    ST      Z+,%s", rd);
		      break;
		    case 0x2:
		      (*prin) (stream, "    ST      -Z,%s", rd);
		      break;
		    case 0x9:
		      (*prin) (stream, "    ST      Y+,%s", rd);
		      break;
		    case 0xa:
		      (*prin) (stream, "    ST      -Y,%s", rd);
		      break;
		    case 0xc:
		      (*prin) (stream, "    ST      X,%s", rd);
		      break;
		    case 0xd:
		      (*prin) (stream, "    ST      X+,%s", rd);
		      break;
		    case 0xe:
		      (*prin) (stream, "    ST      -X,%s", rd);
		      break;
		    case 0xf:
		      (*prin) (stream, "    PUSH    %s", rd);
		      break;
		    default:
		      (*prin) (stream, "    ????");
		      break;
		    }
		}
		break;
	      case 0x0400:
		{
		  if (IFMASK(0x020c, 0x000c))
		    {
		      u32 k = ((opcode & 0x01f0) >> 3) | (opcode & 1);
		      k = (k << 16) | avrdis_opcode(addr + 2, info);
		      if (opcode & 0x0002)
			(*prin) (stream, "    CALL    0x%06X", k*2);
		      else
			(*prin) (stream, "    JMP     0x%06X", k*2);
		      cmd_len = 4;
		    }
		  else if (IFMASK(0x010f, 0x0008))
		    {
		      int sf = (opcode & 0x70) >> 4;
		      if (opcode & 0x0080)
			(*prin) (stream, "    CL%c", SREG_flags[sf]);
		      else
			(*prin) (stream, "    SE%c", SREG_flags[sf]);
		    }
		  else if (IFMASK(0x000f, 0x0009))
		    {
		      if (opcode & 0x0100)
			(*prin) (stream, "    ICALL");
		      else
			(*prin) (stream, "    IJMP");
		    }
		  else if (IFMASK(0x010f, 0x0108))
		    {
		      if (IFMASK(0x0090, 0x0000))
			(*prin) (stream, "    RET");
		      else if (IFMASK(0x0090, 0x0010))
			(*prin) (stream, "    RETI");
		      else if (IFMASK(0x00e0, 0x0080))
			(*prin) (stream, "    SLEEP");
		      else if (IFMASK(0x00e0, 0x00a0))
			(*prin) (stream, "    WDR");
		      else if (IFMASK(0x00f0, 0x00c0))
			(*prin) (stream, "    LPM");
		      else if (IFMASK(0x00f0, 0x00d0))
			(*prin) (stream, "    ELPM");
		      else
			(*prin) (stream, "    ????");
		    }
		  else
		    {
		      const char* p;
		      reg50(opcode, rd);
		      p = sect94[opcode & 0xf];
		      if (!p)
			p = "????";
		      (*prin) (stream, "    %-8s%s", p, rd);
		    }
		}
		break;
	      case 0x0600:
		{
		  if (opcode & 0x0200)
		    {
		      lit204(opcode, rd);
		      reg20w(opcode, rr);
		      if (opcode & 0x0100)
			(*prin) (stream, "    SBIW    %s,%s", rr, rd);
		      else
			(*prin) (stream, "    ADIW    %s,%s", rr, rd);
		    }
		}
		break;
	      case 0x0800:
	      case 0x0a00:
		{
		  (*prin) (stream, "    %-8s0x%02X,%d",
			   sect98[(opcode & 0x0300) >> 8],
			   (opcode & 0xf8) >> 3,
			   opcode & 7);
		}
		break;
	      default:
		{
		  reg50(opcode, rd);
		  reg104(opcode, rr);
		  (*prin) (stream, "    MUL     %s,%s", rd, rr);
		}
	      }
	  }
	  break;
        case 0xb000:
	  {
	    reg50(opcode, rd);
	    regPP(opcode, rr);
	    if (opcode & 0x0800)
	      (*prin) (stream, "    OUT     %s,%s", rr, rd);
	    else
	      (*prin) (stream, "    IN      %s,%s", rd, rr);
	  }
	  break;
        case 0xc000:
	  {
	    add0fff(opcode, rd, addr);
	    (*prin) (stream, "    RJMP    %s", rd);
	  }
	  break;
        case 0xd000:
	  {
	    add0fff(opcode, rd, addr);
	    (*prin) (stream, "    RCALL   %s", rd);
	  }
	  break;
        case 0xe000:
	  {
	    reg40(opcode, rd);
	    lit404(opcode, rr);
	    (*prin) (stream, "    LDI     %s,%s", rd, rr);
	  }
	  break;
        case 0xf000:
	  {
	    if (opcode & 0x0800)
	      {
		reg50(opcode, rd);
		(*prin) (stream, "    %-8s%s,%d",
			 last4[(opcode & 0x0600) >> 9],
			 rd, opcode & 7);
	      }
	    else
	      {
		char* p;
		add03f8(opcode, rd, addr);
		p = branchs[((opcode & 0x0400) >> 7) | (opcode & 7)];
		(*prin) (stream, "    %-8s%s", p, rd);
	      }
	  }
	  break;
        }
    }
  return cmd_len;
}
@


1.1.1.1
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@@


1.1.1.2
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
d20 1
a20 1
#include <assert.h>
d25 58
d84 4
a87 1
struct avr_opcodes_s
d89 16
a104 8
  char *name;
  char *constraints;
  char *opcode;
  int insn_size;		/* in words */
  int isa;
  unsigned int bin_opcode;
  unsigned int bin_mask;
};
d106 1
a106 2
#define AVR_INSN(NAME, CONSTR, OPCODE, SIZE, ISA, BIN) \
{#NAME, CONSTR, OPCODE, SIZE, ISA, BIN, 0},
d108 4
a111 1
struct avr_opcodes_s avr_opcodes[] =
d113 4
a116 3
  #include "opcode/avr.h"
  {NULL, NULL, NULL, 0, 0, 0, 0}
};
d118 1
a118 2
static int avr_operand PARAMS ((unsigned int, unsigned int,
				unsigned int, int, char *, char *, int));
d120 4
a123 9
static int
avr_operand (insn, insn2, pc, constraint, buf, comment, regs)
     unsigned int insn;
     unsigned int insn2;
     unsigned int pc;
     int constraint;
     char *buf;
     char *comment;
     int regs;
d125 4
a128 1
  int ok = 1;
d130 10
a139 29
  switch (constraint)
    {
      /* Any register operand.  */
    case 'r':
      if (regs)
	insn = (insn & 0xf) | ((insn & 0x0200) >> 5); /* source register */
      else
	insn = (insn & 0x01f0) >> 4; /* destination register */
      
      sprintf (buf, "r%d", insn);
      break;

    case 'd':
      if (regs)
	sprintf (buf, "r%d", 16 + (insn & 0xf));
      else
	sprintf (buf, "r%d", 16 + ((insn & 0xf0) >> 4));
      break;
      
    case 'w':
      sprintf (buf, "r%d", 24 + ((insn & 0x30) >> 3));
      break;
      
    case 'a':
      if (regs)
	sprintf (buf, "r%d", 16 + (insn & 7));
      else
	sprintf (buf, "r%d", 16 + ((insn >> 4) & 7));
      break;
a140 6
    case 'v':
      if (regs)
	sprintf (buf, "r%d", (insn & 0xf) * 2);
      else
	sprintf (buf, "r%d", ((insn & 0xf0) >> 3));
      break;
d142 1
a142 133
    case 'e':
      {
	char *xyz;

	switch (insn & 0x100f)
	  {
	    case 0x0000: xyz = "Z";  break;
	    case 0x1001: xyz = "Z+"; break;
	    case 0x1002: xyz = "-Z"; break;
	    case 0x0008: xyz = "Y";  break;
	    case 0x1009: xyz = "Y+"; break;
	    case 0x100a: xyz = "-Y"; break;
	    case 0x100c: xyz = "X";  break;
	    case 0x100d: xyz = "X+"; break;
	    case 0x100e: xyz = "-X"; break;
	    default: xyz = "??"; ok = 0;
	  }
	sprintf (buf, xyz);

	if (AVR_UNDEF_P (insn))
	  sprintf (comment, _("undefined"));
      }
      break;

    case 'z':
      *buf++ = 'Z';
      if (insn & 0x1)
	*buf++ = '+';
      *buf = '\0';
      if (AVR_UNDEF_P (insn))
	sprintf (comment, _("undefined"));
      break;

    case 'b':
      {
	unsigned int x;
	
	x = (insn & 7);
	x |= (insn >> 7) & (3 << 3);
	x |= (insn >> 8) & (1 << 5);
	
	if (insn & 0x8)
	  *buf++ = 'Y';
	else
	  *buf++ = 'Z';
	sprintf (buf, "+%d", x);
	sprintf (comment, "0x%02x", x);
      }
      break;
      
    case 'h':
      sprintf (buf, "0x%x",
	       ((((insn & 1) | ((insn & 0x1f0) >> 3)) << 16) | insn2) * 2);
      break;
      
    case 'L':
      {
	int rel_addr = (((insn & 0xfff) ^ 0x800) - 0x800) * 2;
	sprintf (buf, ".%+-8d", rel_addr);
	sprintf (comment, "0x%x", pc + 2 + rel_addr);
      }
      break;

    case 'l':
      {
	int rel_addr = ((((insn >> 3) & 0x7f) ^ 0x40) - 0x40) * 2;
	sprintf (buf, ".%+-8d", rel_addr);
	sprintf (comment, "0x%x", pc + 2 + rel_addr);
      }
      break;

    case 'i':
      sprintf (buf, "0x%04X", insn2);
      break;
      
    case 'M':
      sprintf (buf, "0x%02X", ((insn & 0xf00) >> 4) | (insn & 0xf));
      sprintf (comment, "%d", ((insn & 0xf00) >> 4) | (insn & 0xf));
      break;

    case 'n':
      sprintf (buf, "??");
      fprintf (stderr, _("Internal disassembler error"));
      ok = 0;
      break;
      
    case 'K':
      {
	unsigned int x;

	x = (insn & 0xf) | ((insn >> 2) & 0x30);
	sprintf (buf, "0x%02x", x);
	sprintf (comment, "%d", x);
      }
      break;
      
    case 's':
      sprintf (buf, "%d", insn & 7);
      break;
      
    case 'S':
      sprintf (buf, "%d", (insn >> 4) & 7);
      break;
      
    case 'P':
      {
	unsigned int x;
	x = (insn & 0xf);
	x |= (insn >> 5) & 0x30;
	sprintf (buf, "0x%02x", x);
	sprintf (comment, "%d", x);
      }
      break;

    case 'p':
      {
	unsigned int x;
	
	x = (insn >> 3) & 0x1f;
	sprintf (buf, "0x%02x", x);
	sprintf (comment, "%d", x);
      }
      break;
      
    case '?':
      *buf = '\0';
      break;
      
    default:
      sprintf (buf, "??");
      fprintf (stderr, _("unknown constraint `%c'"), constraint);
      ok = 0;
    }
d144 8
a151 1
    return ok;
a153 1
static unsigned short avrdis_opcode PARAMS ((bfd_vma, disassemble_info *));
d155 16
a170 1
static unsigned short
d192 3
a194 2
  unsigned int insn, insn2;
  struct avr_opcodes_s *opcode;
a196 1
  static int initialized;
a197 2
  int ok = 0;
  char op1[20], op2[20], comment1[40], comment2[40];
d199 1
a199 22
  if (!initialized)
    {
      initialized = 1;
      
      for (opcode = avr_opcodes; opcode->name; opcode++)
	{
	  char * s;
	  unsigned int bin = 0;
	  unsigned int mask = 0;
	
	  for (s = opcode->opcode; *s; ++s)
	    {
	      bin <<= 1;
	      mask <<= 1;
	      bin |= (*s == '1');
	      mask |= (*s == '1' || *s == '0');
	    }
	  assert (s - opcode->opcode == 16);
	  assert (opcode->bin_opcode == bin);
	  opcode->bin_mask = mask;
	}
    }
d201 1
a201 3
  insn = avrdis_opcode (addr, info);
  
  for (opcode = avr_opcodes; opcode->name; opcode++)
d203 11
a213 2
      if ((insn & opcode->bin_mask) == opcode->bin_opcode)
	break;
d215 1
a215 13
  
  /* Special case: disassemble `ldd r,b+0' as `ld r,b', and
     `std b+0,r' as `st b,r' (next entry in the table).  */

  if (AVR_DISP0_P (insn))
    opcode++;

  op1[0] = 0;
  op2[0] = 0;
  comment1[0] = 0;
  comment2[0] = 0;

  if (opcode->name)
d217 322
a538 30
      char *op = opcode->constraints;

      insn2 = 0;
      ok = 1;

      if (opcode->insn_size > 1)
	{
	  insn2 = avrdis_opcode (addr + 2, info);
	  cmd_len = 4;
	}

      if (*op && *op != '?')
	{
	  int regs = REGISTER_P (*op);

	  ok = avr_operand (insn, insn2, addr, *op, op1, comment1, 0);

	  if (ok && *(++op) == ',')
	    ok = avr_operand (insn, insn2, addr, *(++op), op2,
			      *comment1 ? comment2 : comment1, regs);
	}
    }

  if (!ok)
    {
      /* Unknown opcode, or invalid combination of operands.  */
      sprintf (op1, "0x%04x", insn);
      op2[0] = 0;
      sprintf (comment1, "????");
      comment2[0] = 0;
a539 15

  (*prin) (stream, "%s", ok ? opcode->name : ".word");

  if (*op1)
    (*prin) (stream, "\t%s", op1);

  if (*op2)
    (*prin) (stream, ", %s", op2);

  if (*comment1)
    (*prin) (stream, "\t; %s", comment1);

  if (*comment2)
    (*prin) (stream, " %s", comment2);

@


1.1.1.3
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d24 1
a24 1
#include "libiberty.h"
d34 1
d38 1
a38 1
{#NAME, CONSTR, OPCODE, SIZE, ISA, BIN},
d40 1
a40 1
const struct avr_opcodes_s avr_opcodes[] =
d43 1
a43 1
  {NULL, NULL, NULL, 0, 0, 0}
d260 1
a260 2
  const struct avr_opcodes_s *opcode;
  static unsigned int *maskptr;
a262 1
  static unsigned int *avr_bin_masks;
d270 1
a270 3
      unsigned int nopcodes;

      nopcodes = sizeof (avr_opcodes) / sizeof (struct avr_opcodes_s);
d272 1
a272 6
      avr_bin_masks = (unsigned int *)
	xmalloc (nopcodes * sizeof (unsigned int));

      for (opcode = avr_opcodes, maskptr = avr_bin_masks;
	   opcode->name;
	   opcode++, maskptr++)
d287 1
a287 1
	  *maskptr = mask;
a288 2

      initialized = 1;
d293 1
a293 3
  for (opcode = avr_opcodes, maskptr = avr_bin_masks;
       opcode->name;
       opcode++, maskptr++)
d295 1
a295 1
      if ((insn & *maskptr) == opcode->bin_opcode)
@


