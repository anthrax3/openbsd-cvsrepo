head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.12
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.8
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.4
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.4
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.13.0.10
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.8
	OPENBSD_5_0:1.13.0.6
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.20
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.22
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.18
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.16
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.14
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.12
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.10
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2014.08.20.04.12.30;	author guenther;	state Exp;
branches;
next	1.16;
commitid	OTi3HeoDEQqq42tB;

1.16
date	2014.02.09.22.42.27;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2012.10.18.00.54.12;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2012.09.07.22.33.01;	author naddy;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.11.10.50.48;	author thib;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.20.22.42.17;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.02.20.45.54;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.26.00.08.10;	author tom;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.16.18.20.55;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.17.21.54.55;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.03.09.31.19;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.44;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.13.00;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.53.14;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.10.56;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.55.43;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.02;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.02;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.04.15;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.48.57;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.39.41;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.27.53;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.47.54;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.56.44;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.44;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.23.10;	author miod;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Backport support for i386/amd64 'rdtscp' instruction from binutils-2.17

Request and testing by krw@@
@
text
@/* Print i386 instructions for GDB, the GNU debugger.
   Copyright 1988, 1989, 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/*
 * 80386 instruction printer by Pace Willisson (pace@@prep.ai.mit.edu)
 * July 1988
 *  modified by John Hassey (hassey@@dg-rtp.dg.com)
 *  x86-64 support added by Jan Hubicka (jh@@suse.cz)
 *  VIA PadLock support by Michal Ludvig (mludvig@@suse.cz)
 */

/*
 * The main tables describing the instructions is essentially a copy
 * of the "Opcode Map" chapter (Appendix A) of the Intel 80386
 * Programmers Manual.  Usually, there is a capital letter, followed
 * by a small letter.  The capital letter tell the addressing mode,
 * and the small letter tells about the operand size.  Refer to
 * the Intel manual for details.
 */

#include "dis-asm.h"
#include "sysdep.h"
#include "opintl.h"

#define MAXLEN 20

#include <setjmp.h>

#ifndef UNIXWARE_COMPAT
/* Set non-zero for broken, compatible instructions.  Set to zero for
   non-broken opcodes.  */
#define UNIXWARE_COMPAT 1
#endif

static int fetch_data (struct disassemble_info *, bfd_byte *);
static void ckprefix (void);
static const char *prefix_name (int, int);
static int print_insn (bfd_vma, disassemble_info *);
static void dofloat (int);
static void OP_ST (int, int);
static void OP_STi (int, int);
static int putop (const char *, int);
static void oappend (const char *);
static void append_seg (void);
static void OP_indirE (int, int);
static void print_operand_value (char *, int, bfd_vma);
static void OP_E (int, int);
static void OP_G (int, int);
static bfd_vma get64 (void);
static bfd_signed_vma get32 (void);
static bfd_signed_vma get32s (void);
static int get16 (void);
static void set_op (bfd_vma, int);
static void OP_REG (int, int);
static void OP_IMREG (int, int);
static void OP_I (int, int);
static void OP_I64 (int, int);
static void OP_sI (int, int);
static void OP_J (int, int);
static void OP_SEG (int, int);
static void OP_DIR (int, int);
static void OP_OFF (int, int);
static void OP_OFF64 (int, int);
static void ptr_reg (int, int);
static void OP_ESreg (int, int);
static void OP_DSreg (int, int);
static void OP_C (int, int);
static void OP_D (int, int);
static void OP_T (int, int);
static void OP_Rd (int, int);
static void OP_MMX (int, int);
static void OP_XMM (int, int);
static void OP_EM (int, int);
static void OP_EX (int, int);
static void OP_MS (int, int);
static void OP_XS (int, int);
static void OP_M (int, int);
static void OP_0fae (int, int);
static void NOP_Fixup (int, int);
static void OP_3DNowSuffix (int, int);
static void OP_xcrypt2 (int, int);
static void OP_xcrypt (int, int);
static void OP_SIMD_Suffix (int, int);
static void SIMD_Fixup (int, int);
static void PNI_Fixup (int, int);
static void XCR_Fixup (int, int);
static void INVLPG_Fixup (int, int);
static void OP_0f38 (int, int);
static void OP_0f3a (int, int);
static void BadOp (void);

struct dis_private {
  /* Points to first byte not fetched.  */
  bfd_byte *max_fetched;
  bfd_byte the_buffer[MAXLEN];
  bfd_vma insn_start;
  int orig_sizeflag;
  jmp_buf bailout;
};

/* The opcode for the fwait instruction, which we treat as a prefix
   when we can.  */
#define FWAIT_OPCODE (0x9b)

/* Set to 1 for 64bit mode disassembly.  */
static int mode_64bit;

/* Flags for the prefixes for the current instruction.  See below.  */
static int prefixes;

/* REX prefix the current instruction.  See below.  */
static int rex;
/* Bits of REX we've already used.  */
static int rex_used;
#define REX_MODE64	8
#define REX_EXTX	4
#define REX_EXTY	2
#define REX_EXTZ	1
/* Mark parts used in the REX prefix.  When we are testing for
   empty prefix (for 8bit register REX extension), just mask it
   out.  Otherwise test for REX bit is excuse for existence of REX
   only in case value is nonzero.  */
#define USED_REX(value)					\
  {							\
    if (value)						\
      rex_used |= (rex & value) ? (value) | 0x40 : 0;	\
    else						\
      rex_used |= 0x40;					\
  }

/* Flags for prefixes which we somehow handled when printing the
   current instruction.  */
static int used_prefixes;

/* Flags stored in PREFIXES.  */
#define PREFIX_REPZ 1
#define PREFIX_REPNZ 2
#define PREFIX_LOCK 4
#define PREFIX_CS 8
#define PREFIX_SS 0x10
#define PREFIX_DS 0x20
#define PREFIX_ES 0x40
#define PREFIX_FS 0x80
#define PREFIX_GS 0x100
#define PREFIX_DATA 0x200
#define PREFIX_ADDR 0x400
#define PREFIX_FWAIT 0x800

/* Make sure that bytes from INFO->PRIVATE_DATA->BUFFER (inclusive)
   to ADDR (exclusive) are valid.  Returns 1 for success, longjmps
   on error.  */
#define FETCH_DATA(info, addr) \
  ((addr) <= ((struct dis_private *) (info->private_data))->max_fetched \
   ? 1 : fetch_data ((info), (addr)))

static int
fetch_data (struct disassemble_info *info, bfd_byte *addr)
{
  int status;
  struct dis_private *priv = (struct dis_private *) info->private_data;
  bfd_vma start = priv->insn_start + (priv->max_fetched - priv->the_buffer);

  status = (*info->read_memory_func) (start,
				      priv->max_fetched,
				      addr - priv->max_fetched,
				      info);
  if (status != 0)
    {
      /* If we did manage to read at least one byte, then
	 print_insn_i386 will do something sensible.  Otherwise, print
	 an error.  We do that here because this is where we know
	 STATUS.  */
      if (priv->max_fetched == priv->the_buffer)
	(*info->memory_error_func) (status, start, info);
      longjmp (priv->bailout, 1);
    }
  else
    priv->max_fetched = addr;
  return 1;
}

#define XX NULL, 0

#define Eb OP_E, b_mode
#define Ev OP_E, v_mode
#define Ed OP_E, d_mode
#define Edq OP_E, dq_mode
#define indirEb OP_indirE, b_mode
#define indirEv OP_indirE, v_mode
#define Ew OP_E, w_mode
#define Ma OP_E, v_mode
#define M OP_M, 0		/* lea, lgdt, etc. */
#define Mp OP_M, 0		/* 32 or 48 bit memory operand for LDS, LES etc */
#define Gb OP_G, b_mode
#define Gv OP_G, v_mode
#define Gd OP_G, d_mode
#define Gw OP_G, w_mode
#define Rd OP_Rd, d_mode
#define Rm OP_Rd, m_mode
#define Ib OP_I, b_mode
#define sIb OP_sI, b_mode	/* sign extened byte */
#define Iv OP_I, v_mode
#define Iq OP_I, q_mode
#define Iv64 OP_I64, v_mode
#define Iw OP_I, w_mode
#define Jb OP_J, b_mode
#define Jv OP_J, v_mode
#define Cm OP_C, m_mode
#define Dm OP_D, m_mode
#define Td OP_T, d_mode

#define RMeAX OP_REG, eAX_reg
#define RMeBX OP_REG, eBX_reg
#define RMeCX OP_REG, eCX_reg
#define RMeDX OP_REG, eDX_reg
#define RMeSP OP_REG, eSP_reg
#define RMeBP OP_REG, eBP_reg
#define RMeSI OP_REG, eSI_reg
#define RMeDI OP_REG, eDI_reg
#define RMrAX OP_REG, rAX_reg
#define RMrBX OP_REG, rBX_reg
#define RMrCX OP_REG, rCX_reg
#define RMrDX OP_REG, rDX_reg
#define RMrSP OP_REG, rSP_reg
#define RMrBP OP_REG, rBP_reg
#define RMrSI OP_REG, rSI_reg
#define RMrDI OP_REG, rDI_reg
#define RMAL OP_REG, al_reg
#define RMAL OP_REG, al_reg
#define RMCL OP_REG, cl_reg
#define RMDL OP_REG, dl_reg
#define RMBL OP_REG, bl_reg
#define RMAH OP_REG, ah_reg
#define RMCH OP_REG, ch_reg
#define RMDH OP_REG, dh_reg
#define RMBH OP_REG, bh_reg
#define RMAX OP_REG, ax_reg
#define RMDX OP_REG, dx_reg

#define eAX OP_IMREG, eAX_reg
#define eBX OP_IMREG, eBX_reg
#define eCX OP_IMREG, eCX_reg
#define eDX OP_IMREG, eDX_reg
#define eSP OP_IMREG, eSP_reg
#define eBP OP_IMREG, eBP_reg
#define eSI OP_IMREG, eSI_reg
#define eDI OP_IMREG, eDI_reg
#define AL OP_IMREG, al_reg
#define AL OP_IMREG, al_reg
#define CL OP_IMREG, cl_reg
#define DL OP_IMREG, dl_reg
#define BL OP_IMREG, bl_reg
#define AH OP_IMREG, ah_reg
#define CH OP_IMREG, ch_reg
#define DH OP_IMREG, dh_reg
#define BH OP_IMREG, bh_reg
#define AX OP_IMREG, ax_reg
#define DX OP_IMREG, dx_reg
#define indirDX OP_IMREG, indir_dx_reg

#define Sw OP_SEG, w_mode
#define Ap OP_DIR, 0
#define Ob OP_OFF, b_mode
#define Ob64 OP_OFF64, b_mode
#define Ov OP_OFF, v_mode
#define Ov64 OP_OFF64, v_mode
#define Xb OP_DSreg, eSI_reg
#define Xv OP_DSreg, eSI_reg
#define Yb OP_ESreg, eDI_reg
#define Yv OP_ESreg, eDI_reg
#define DSBX OP_DSreg, eBX_reg

#define es OP_REG, es_reg
#define ss OP_REG, ss_reg
#define cs OP_REG, cs_reg
#define ds OP_REG, ds_reg
#define fs OP_REG, fs_reg
#define gs OP_REG, gs_reg

#define MX OP_MMX, 0
#define XM OP_XMM, 0
#define EM OP_EM, v_mode
#define EX OP_EX, v_mode
#define MS OP_MS, v_mode
#define XS OP_XS, v_mode
#define OPSUF OP_3DNowSuffix, 0
#define OPXCRYPT OP_xcrypt, 0
#define OPXCRYPT2 OP_xcrypt2, 0
#define OPSIMD OP_SIMD_Suffix, 0
#define OP0F38 OP_0f38, 0
#define OP0F3A OP_0f3a, 0

#define cond_jump_flag NULL, cond_jump_mode
#define loop_jcxz_flag NULL, loop_jcxz_mode

/* bits in sizeflag */
#define SUFFIX_ALWAYS 4
#define AFLAG 2
#define DFLAG 1

#define b_mode 1  /* byte operand */
#define v_mode 2  /* operand size depends on prefixes */
#define w_mode 3  /* word operand */
#define d_mode 4  /* double word operand  */
#define q_mode 5  /* quad word operand */
#define x_mode 6
#define m_mode 7  /* d_mode in 32bit, q_mode in 64bit mode.  */
#define cond_jump_mode 8
#define loop_jcxz_mode 9
#define dq_mode 10 /* operand size depends on REX prefixes.  */

#define es_reg 100
#define cs_reg 101
#define ss_reg 102
#define ds_reg 103
#define fs_reg 104
#define gs_reg 105

#define eAX_reg 108
#define eCX_reg 109
#define eDX_reg 110
#define eBX_reg 111
#define eSP_reg 112
#define eBP_reg 113
#define eSI_reg 114
#define eDI_reg 115

#define al_reg 116
#define cl_reg 117
#define dl_reg 118
#define bl_reg 119
#define ah_reg 120
#define ch_reg 121
#define dh_reg 122
#define bh_reg 123

#define ax_reg 124
#define cx_reg 125
#define dx_reg 126
#define bx_reg 127
#define sp_reg 128
#define bp_reg 129
#define si_reg 130
#define di_reg 131

#define rAX_reg 132
#define rCX_reg 133
#define rDX_reg 134
#define rBX_reg 135
#define rSP_reg 136
#define rBP_reg 137
#define rSI_reg 138
#define rDI_reg 139

#define indir_dx_reg 150

#define FLOATCODE 1
#define USE_GROUPS 2
#define USE_PREFIX_USER_TABLE 3
#define X86_64_SPECIAL 4

#define FLOAT	  NULL, NULL, FLOATCODE, NULL, 0, NULL, 0

#define GRP1b	  NULL, NULL, USE_GROUPS, NULL,  0, NULL, 0
#define GRP1S	  NULL, NULL, USE_GROUPS, NULL,  1, NULL, 0
#define GRP1Ss	  NULL, NULL, USE_GROUPS, NULL,  2, NULL, 0
#define GRP2b	  NULL, NULL, USE_GROUPS, NULL,  3, NULL, 0
#define GRP2S	  NULL, NULL, USE_GROUPS, NULL,  4, NULL, 0
#define GRP2b_one NULL, NULL, USE_GROUPS, NULL,  5, NULL, 0
#define GRP2S_one NULL, NULL, USE_GROUPS, NULL,  6, NULL, 0
#define GRP2b_cl  NULL, NULL, USE_GROUPS, NULL,  7, NULL, 0
#define GRP2S_cl  NULL, NULL, USE_GROUPS, NULL,  8, NULL, 0
#define GRP3b	  NULL, NULL, USE_GROUPS, NULL,  9, NULL, 0
#define GRP3S	  NULL, NULL, USE_GROUPS, NULL, 10, NULL, 0
#define GRP4	  NULL, NULL, USE_GROUPS, NULL, 11, NULL, 0
#define GRP5	  NULL, NULL, USE_GROUPS, NULL, 12, NULL, 0
#define GRP6	  NULL, NULL, USE_GROUPS, NULL, 13, NULL, 0
#define GRP7	  NULL, NULL, USE_GROUPS, NULL, 14, NULL, 0
#define GRP8	  NULL, NULL, USE_GROUPS, NULL, 15, NULL, 0
#define GRP9	  NULL, NULL, USE_GROUPS, NULL, 16, NULL, 0
#define GRP10	  NULL, NULL, USE_GROUPS, NULL, 17, NULL, 0
#define GRP11	  NULL, NULL, USE_GROUPS, NULL, 18, NULL, 0
#define GRP12	  NULL, NULL, USE_GROUPS, NULL, 19, NULL, 0
#define GRP13	  NULL, NULL, USE_GROUPS, NULL, 20, NULL, 0
#define GRP14	  NULL, NULL, USE_GROUPS, NULL, 21, NULL, 0
#define GRPAMD	  NULL, NULL, USE_GROUPS, NULL, 22, NULL, 0

#define PREGRP0   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  0, NULL, 0
#define PREGRP1   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  1, NULL, 0
#define PREGRP2   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  2, NULL, 0
#define PREGRP3   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  3, NULL, 0
#define PREGRP4   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  4, NULL, 0
#define PREGRP5   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  5, NULL, 0
#define PREGRP6   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  6, NULL, 0
#define PREGRP7   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  7, NULL, 0
#define PREGRP8   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  8, NULL, 0
#define PREGRP9   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  9, NULL, 0
#define PREGRP10  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 10, NULL, 0
#define PREGRP11  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 11, NULL, 0
#define PREGRP12  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 12, NULL, 0
#define PREGRP13  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 13, NULL, 0
#define PREGRP14  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 14, NULL, 0
#define PREGRP15  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 15, NULL, 0
#define PREGRP16  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 16, NULL, 0
#define PREGRP17  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 17, NULL, 0
#define PREGRP18  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 18, NULL, 0
#define PREGRP19  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 19, NULL, 0
#define PREGRP20  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 20, NULL, 0
#define PREGRP21  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 21, NULL, 0
#define PREGRP22  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 22, NULL, 0
#define PREGRP23  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 23, NULL, 0
#define PREGRP24  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 24, NULL, 0
#define PREGRP25  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 25, NULL, 0
#define PREGRP26  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 26, NULL, 0
#define PREGRP27  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 27, NULL, 0
#define PREGRP28  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 28, NULL, 0
#define PREGRP29  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 29, NULL, 0
#define PREGRP30  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 30, NULL, 0
#define PREGRP31  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 31, NULL, 0
#define PREGRP32  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 32, NULL, 0

#define X86_64_0  NULL, NULL, X86_64_SPECIAL, NULL,  0, NULL, 0

typedef void (*op_rtn) (int bytemode, int sizeflag);

struct dis386 {
  const char *name;
  op_rtn op1;
  int bytemode1;
  op_rtn op2;
  int bytemode2;
  op_rtn op3;
  int bytemode3;
};

/* Upper case letters in the instruction names here are macros.
   'A' => print 'b' if no register operands or suffix_always is true
   'B' => print 'b' if suffix_always is true
   'E' => print 'e' if 32-bit form of jcxz
   'F' => print 'w' or 'l' depending on address size prefix (loop insns)
   'H' => print ",pt" or ",pn" branch hint
   'L' => print 'l' if suffix_always is true
   'N' => print 'n' if instruction has no wait "prefix"
   'O' => print 'd', or 'o'
   'P' => print 'w', 'l' or 'q' if instruction has an operand size prefix,
   .      or suffix_always is true.  print 'q' if rex prefix is present.
   'Q' => print 'w', 'l' or 'q' if no register operands or suffix_always
   .      is true
   'R' => print 'w', 'l' or 'q' ("wd" or "dq" in intel mode)
   'S' => print 'w', 'l' or 'q' if suffix_always is true
   'T' => print 'q' in 64bit mode and behave as 'P' otherwise
   'U' => print 'q' in 64bit mode and behave as 'Q' otherwise
   'X' => print 's', 'd' depending on data16 prefix (for XMM)
   'W' => print 'b' or 'w' ("w" or "de" in intel mode)
   'Y' => 'q' if instruction has an REX 64bit overwrite prefix

   Many of the above letters print nothing in Intel mode.  See "putop"
   for the details.

   Braces '{' and '}', and vertical bars '|', indicate alternative
   mnemonic strings for AT&T, Intel, X86_64 AT&T, and X86_64 Intel
   modes.  In cases where there are only two alternatives, the X86_64
   instruction is reserved, and "(bad)" is printed.
*/

static const struct dis386 dis386[] = {
  /* 00 */
  { "addB",		Eb, Gb, XX },
  { "addS",		Ev, Gv, XX },
  { "addB",		Gb, Eb, XX },
  { "addS",		Gv, Ev, XX },
  { "addB",		AL, Ib, XX },
  { "addS",		eAX, Iv, XX },
  { "push{T|}",		es, XX, XX },
  { "pop{T|}",		es, XX, XX },
  /* 08 */
  { "orB",		Eb, Gb, XX },
  { "orS",		Ev, Gv, XX },
  { "orB",		Gb, Eb, XX },
  { "orS",		Gv, Ev, XX },
  { "orB",		AL, Ib, XX },
  { "orS",		eAX, Iv, XX },
  { "push{T|}",		cs, XX, XX },
  { "(bad)",		XX, XX, XX },	/* 0x0f extended opcode escape */
  /* 10 */
  { "adcB",		Eb, Gb, XX },
  { "adcS",		Ev, Gv, XX },
  { "adcB",		Gb, Eb, XX },
  { "adcS",		Gv, Ev, XX },
  { "adcB",		AL, Ib, XX },
  { "adcS",		eAX, Iv, XX },
  { "push{T|}",		ss, XX, XX },
  { "popT|}",		ss, XX, XX },
  /* 18 */
  { "sbbB",		Eb, Gb, XX },
  { "sbbS",		Ev, Gv, XX },
  { "sbbB",		Gb, Eb, XX },
  { "sbbS",		Gv, Ev, XX },
  { "sbbB",		AL, Ib, XX },
  { "sbbS",		eAX, Iv, XX },
  { "push{T|}",		ds, XX, XX },
  { "pop{T|}",		ds, XX, XX },
  /* 20 */
  { "andB",		Eb, Gb, XX },
  { "andS",		Ev, Gv, XX },
  { "andB",		Gb, Eb, XX },
  { "andS",		Gv, Ev, XX },
  { "andB",		AL, Ib, XX },
  { "andS",		eAX, Iv, XX },
  { "(bad)",		XX, XX, XX },	/* SEG ES prefix */
  { "daa{|}",		XX, XX, XX },
  /* 28 */
  { "subB",		Eb, Gb, XX },
  { "subS",		Ev, Gv, XX },
  { "subB",		Gb, Eb, XX },
  { "subS",		Gv, Ev, XX },
  { "subB",		AL, Ib, XX },
  { "subS",		eAX, Iv, XX },
  { "(bad)",		XX, XX, XX },	/* SEG CS prefix */
  { "das{|}",		XX, XX, XX },
  /* 30 */
  { "xorB",		Eb, Gb, XX },
  { "xorS",		Ev, Gv, XX },
  { "xorB",		Gb, Eb, XX },
  { "xorS",		Gv, Ev, XX },
  { "xorB",		AL, Ib, XX },
  { "xorS",		eAX, Iv, XX },
  { "(bad)",		XX, XX, XX },	/* SEG SS prefix */
  { "aaa{|}",		XX, XX, XX },
  /* 38 */
  { "cmpB",		Eb, Gb, XX },
  { "cmpS",		Ev, Gv, XX },
  { "cmpB",		Gb, Eb, XX },
  { "cmpS",		Gv, Ev, XX },
  { "cmpB",		AL, Ib, XX },
  { "cmpS",		eAX, Iv, XX },
  { "(bad)",		XX, XX, XX },	/* SEG DS prefix */
  { "aas{|}",		XX, XX, XX },
  /* 40 */
  { "inc{S|}",		RMeAX, XX, XX },
  { "inc{S|}",		RMeCX, XX, XX },
  { "inc{S|}",		RMeDX, XX, XX },
  { "inc{S|}",		RMeBX, XX, XX },
  { "inc{S|}",		RMeSP, XX, XX },
  { "inc{S|}",		RMeBP, XX, XX },
  { "inc{S|}",		RMeSI, XX, XX },
  { "inc{S|}",		RMeDI, XX, XX },
  /* 48 */
  { "dec{S|}",		RMeAX, XX, XX },
  { "dec{S|}",		RMeCX, XX, XX },
  { "dec{S|}",		RMeDX, XX, XX },
  { "dec{S|}",		RMeBX, XX, XX },
  { "dec{S|}",		RMeSP, XX, XX },
  { "dec{S|}",		RMeBP, XX, XX },
  { "dec{S|}",		RMeSI, XX, XX },
  { "dec{S|}",		RMeDI, XX, XX },
  /* 50 */
  { "pushS",		RMrAX, XX, XX },
  { "pushS",		RMrCX, XX, XX },
  { "pushS",		RMrDX, XX, XX },
  { "pushS",		RMrBX, XX, XX },
  { "pushS",		RMrSP, XX, XX },
  { "pushS",		RMrBP, XX, XX },
  { "pushS",		RMrSI, XX, XX },
  { "pushS",		RMrDI, XX, XX },
  /* 58 */
  { "popS",		RMrAX, XX, XX },
  { "popS",		RMrCX, XX, XX },
  { "popS",		RMrDX, XX, XX },
  { "popS",		RMrBX, XX, XX },
  { "popS",		RMrSP, XX, XX },
  { "popS",		RMrBP, XX, XX },
  { "popS",		RMrSI, XX, XX },
  { "popS",		RMrDI, XX, XX },
  /* 60 */
  { "pusha{P|}",	XX, XX, XX },
  { "popa{P|}",		XX, XX, XX },
  { "bound{S|}",	Gv, Ma, XX },
  { X86_64_0 },
  { "(bad)",		XX, XX, XX },	/* seg fs */
  { "(bad)",		XX, XX, XX },	/* seg gs */
  { "(bad)",		XX, XX, XX },	/* op size prefix */
  { "(bad)",		XX, XX, XX },	/* adr size prefix */
  /* 68 */
  { "pushT",		Iq, XX, XX },
  { "imulS",		Gv, Ev, Iv },
  { "pushT",		sIb, XX, XX },
  { "imulS",		Gv, Ev, sIb },
  { "ins{b||b|}",	Yb, indirDX, XX },
  { "ins{R||R|}",	Yv, indirDX, XX },
  { "outs{b||b|}",	indirDX, Xb, XX },
  { "outs{R||R|}",	indirDX, Xv, XX },
  /* 70 */
  { "joH",		Jb, XX, cond_jump_flag },
  { "jnoH",		Jb, XX, cond_jump_flag },
  { "jbH",		Jb, XX, cond_jump_flag },
  { "jaeH",		Jb, XX, cond_jump_flag },
  { "jeH",		Jb, XX, cond_jump_flag },
  { "jneH",		Jb, XX, cond_jump_flag },
  { "jbeH",		Jb, XX, cond_jump_flag },
  { "jaH",		Jb, XX, cond_jump_flag },
  /* 78 */
  { "jsH",		Jb, XX, cond_jump_flag },
  { "jnsH",		Jb, XX, cond_jump_flag },
  { "jpH",		Jb, XX, cond_jump_flag },
  { "jnpH",		Jb, XX, cond_jump_flag },
  { "jlH",		Jb, XX, cond_jump_flag },
  { "jgeH",		Jb, XX, cond_jump_flag },
  { "jleH",		Jb, XX, cond_jump_flag },
  { "jgH",		Jb, XX, cond_jump_flag },
  /* 80 */
  { GRP1b },
  { GRP1S },
  { "(bad)",		XX, XX, XX },
  { GRP1Ss },
  { "testB",		Eb, Gb, XX },
  { "testS",		Ev, Gv, XX },
  { "xchgB",		Eb, Gb, XX },
  { "xchgS",		Ev, Gv, XX },
  /* 88 */
  { "movB",		Eb, Gb, XX },
  { "movS",		Ev, Gv, XX },
  { "movB",		Gb, Eb, XX },
  { "movS",		Gv, Ev, XX },
  { "movQ",		Ev, Sw, XX },
  { "leaS",		Gv, M, XX },
  { "movQ",		Sw, Ev, XX },
  { "popU",		Ev, XX, XX },
  /* 90 */
  { "nop",		NOP_Fixup, 0, XX, XX },
  { "xchgS",		RMeCX, eAX, XX },
  { "xchgS",		RMeDX, eAX, XX },
  { "xchgS",		RMeBX, eAX, XX },
  { "xchgS",		RMeSP, eAX, XX },
  { "xchgS",		RMeBP, eAX, XX },
  { "xchgS",		RMeSI, eAX, XX },
  { "xchgS",		RMeDI, eAX, XX },
  /* 98 */
  { "cW{tR||tR|}",	XX, XX, XX },
  { "cR{tO||tO|}",	XX, XX, XX },
  { "lcall{T|}",	Ap, XX, XX },
  { "(bad)",		XX, XX, XX },	/* fwait */
  { "pushfT",		XX, XX, XX },
  { "popfT",		XX, XX, XX },
  { "sahf{|}",		XX, XX, XX },
  { "lahf{|}",		XX, XX, XX },
  /* a0 */
  { "movB",		AL, Ob64, XX },
  { "movS",		eAX, Ov64, XX },
  { "movB",		Ob64, AL, XX },
  { "movS",		Ov64, eAX, XX },
  { "movs{b||b|}",	Yb, Xb, XX },
  { "movs{R||R|}",	Yv, Xv, XX },
  { "cmps{b||b|}",	Xb, Yb, XX },
  { "cmps{R||R|}",	Xv, Yv, XX },
  /* a8 */
  { "testB",		AL, Ib, XX },
  { "testS",		eAX, Iv, XX },
  { "stosB",		Yb, AL, XX },
  { "stosS",		Yv, eAX, XX },
  { "lodsB",		AL, Xb, XX },
  { "lodsS",		eAX, Xv, XX },
  { "scasB",		AL, Yb, XX },
  { "scasS",		eAX, Yv, XX },
  /* b0 */
  { "movB",		RMAL, Ib, XX },
  { "movB",		RMCL, Ib, XX },
  { "movB",		RMDL, Ib, XX },
  { "movB",		RMBL, Ib, XX },
  { "movB",		RMAH, Ib, XX },
  { "movB",		RMCH, Ib, XX },
  { "movB",		RMDH, Ib, XX },
  { "movB",		RMBH, Ib, XX },
  /* b8 */
  { "movS",		RMeAX, Iv64, XX },
  { "movS",		RMeCX, Iv64, XX },
  { "movS",		RMeDX, Iv64, XX },
  { "movS",		RMeBX, Iv64, XX },
  { "movS",		RMeSP, Iv64, XX },
  { "movS",		RMeBP, Iv64, XX },
  { "movS",		RMeSI, Iv64, XX },
  { "movS",		RMeDI, Iv64, XX },
  /* c0 */
  { GRP2b },
  { GRP2S },
  { "retT",		Iw, XX, XX },
  { "retT",		XX, XX, XX },
  { "les{S|}",		Gv, Mp, XX },
  { "ldsS",		Gv, Mp, XX },
  { "movA",		Eb, Ib, XX },
  { "movQ",		Ev, Iv, XX },
  /* c8 */
  { "enterT",		Iw, Ib, XX },
  { "leaveT",		XX, XX, XX },
  { "lretP",		Iw, XX, XX },
  { "lretP",		XX, XX, XX },
  { "int3",		XX, XX, XX },
  { "int",		Ib, XX, XX },
  { "into{|}",		XX, XX, XX },
  { "iretP",		XX, XX, XX },
  /* d0 */
  { GRP2b_one },
  { GRP2S_one },
  { GRP2b_cl },
  { GRP2S_cl },
  { "aam{|}",		sIb, XX, XX },
  { "aad{|}",		sIb, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "xlat",		DSBX, XX, XX },
  /* d8 */
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  /* e0 */
  { "loopneFH",		Jb, XX, loop_jcxz_flag },
  { "loopeFH",		Jb, XX, loop_jcxz_flag },
  { "loopFH",		Jb, XX, loop_jcxz_flag },
  { "jEcxzH",		Jb, XX, loop_jcxz_flag },
  { "inB",		AL, Ib, XX },
  { "inS",		eAX, Ib, XX },
  { "outB",		Ib, AL, XX },
  { "outS",		Ib, eAX, XX },
  /* e8 */
  { "callT",		Jv, XX, XX },
  { "jmpT",		Jv, XX, XX },
  { "ljmp{T|}",		Ap, XX, XX },
  { "jmp",		Jb, XX, XX },
  { "inB",		AL, indirDX, XX },
  { "inS",		eAX, indirDX, XX },
  { "outB",		indirDX, AL, XX },
  { "outS",		indirDX, eAX, XX },
  /* f0 */
  { "(bad)",		XX, XX, XX },	/* lock prefix */
  { "icebp",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },	/* repne */
  { "(bad)",		XX, XX, XX },	/* repz */
  { "hlt",		XX, XX, XX },
  { "cmc",		XX, XX, XX },
  { GRP3b },
  { GRP3S },
  /* f8 */
  { "clc",		XX, XX, XX },
  { "stc",		XX, XX, XX },
  { "cli",		XX, XX, XX },
  { "sti",		XX, XX, XX },
  { "cld",		XX, XX, XX },
  { "std",		XX, XX, XX },
  { GRP4 },
  { GRP5 },
};

static const struct dis386 dis386_twobyte[] = {
  /* 00 */
  { GRP6 },
  { GRP7 },
  { "larS",		Gv, Ew, XX },
  { "lslS",		Gv, Ew, XX },
  { "(bad)",		XX, XX, XX },
  { "syscall",		XX, XX, XX },
  { "clts",		XX, XX, XX },
  { "sysretP",		XX, XX, XX },
  /* 08 */
  { "invd",		XX, XX, XX },
  { "wbinvd",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "ud2a",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { GRPAMD },
  { "femms",		XX, XX, XX },
  { "",			MX, EM, OPSUF }, /* See OP_3DNowSuffix.  */
  /* 10 */
  { PREGRP8 },
  { PREGRP9 },
  { PREGRP30 },
  { "movlpX",		EX, XM, SIMD_Fixup, 'h' },
  { "unpcklpX",		XM, EX, XX },
  { "unpckhpX",		XM, EX, XX },
  { PREGRP31 },
  { "movhpX",		EX, XM, SIMD_Fixup, 'l' },
  /* 18 */
  { GRP14 },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  /* 20 */
  { "movL",		Rm, Cm, XX },
  { "movL",		Rm, Dm, XX },
  { "movL",		Cm, Rm, XX },
  { "movL",		Dm, Rm, XX },
  { "movL",		Rd, Td, XX },
  { "(bad)",		XX, XX, XX },
  { "movL",		Td, Rd, XX },
  { "(bad)",		XX, XX, XX },
  /* 28 */
  { "movapX",		XM, EX, XX },
  { "movapX",		EX, XM, XX },
  { PREGRP2 },
  { "movntpX",		Ev, XM, XX },
  { PREGRP4 },
  { PREGRP3 },
  { "ucomisX",		XM,EX, XX },
  { "comisX",		XM,EX, XX },
  /* 30 */
  { "wrmsr",		XX, XX, XX },
  { "rdtsc",		XX, XX, XX },
  { "rdmsr",		XX, XX, XX },
  { "rdpmc",		XX, XX, XX },
  { "sysenter",		XX, XX, XX },
  { "sysexit",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  /* 38 */
  { "",			OP0F38, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "",			OP0F3A, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  /* 40 */
  { "cmovo",		Gv, Ev, XX },
  { "cmovno",		Gv, Ev, XX },
  { "cmovb",		Gv, Ev, XX },
  { "cmovae",		Gv, Ev, XX },
  { "cmove",		Gv, Ev, XX },
  { "cmovne",		Gv, Ev, XX },
  { "cmovbe",		Gv, Ev, XX },
  { "cmova",		Gv, Ev, XX },
  /* 48 */
  { "cmovs",		Gv, Ev, XX },
  { "cmovns",		Gv, Ev, XX },
  { "cmovp",		Gv, Ev, XX },
  { "cmovnp",		Gv, Ev, XX },
  { "cmovl",		Gv, Ev, XX },
  { "cmovge",		Gv, Ev, XX },
  { "cmovle",		Gv, Ev, XX },
  { "cmovg",		Gv, Ev, XX },
  /* 50 */
  { "movmskpX",		Gd, XS, XX },
  { PREGRP13 },
  { PREGRP12 },
  { PREGRP11 },
  { "andpX",		XM, EX, XX },
  { "andnpX",		XM, EX, XX },
  { "orpX",		XM, EX, XX },
  { "xorpX",		XM, EX, XX },
  /* 58 */
  { PREGRP0 },
  { PREGRP10 },
  { PREGRP17 },
  { PREGRP16 },
  { PREGRP14 },
  { PREGRP7 },
  { PREGRP5 },
  { PREGRP6 },
  /* 60 */
  { "punpcklbw",	MX, EM, XX },
  { "punpcklwd",	MX, EM, XX },
  { "punpckldq",	MX, EM, XX },
  { "packsswb",		MX, EM, XX },
  { "pcmpgtb",		MX, EM, XX },
  { "pcmpgtw",		MX, EM, XX },
  { "pcmpgtd",		MX, EM, XX },
  { "packuswb",		MX, EM, XX },
  /* 68 */
  { "punpckhbw",	MX, EM, XX },
  { "punpckhwd",	MX, EM, XX },
  { "punpckhdq",	MX, EM, XX },
  { "packssdw",		MX, EM, XX },
  { PREGRP26 },
  { PREGRP24 },
  { "movd",		MX, Edq, XX },
  { PREGRP19 },
  /* 70 */
  { PREGRP22 },
  { GRP10 },
  { GRP11 },
  { GRP12 },
  { "pcmpeqb",		MX, EM, XX },
  { "pcmpeqw",		MX, EM, XX },
  { "pcmpeqd",		MX, EM, XX },
  { "emms",		XX, XX, XX },
  /* 78 */
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { PREGRP28 },
  { PREGRP29 },
  { PREGRP23 },
  { PREGRP20 },
  /* 80 */
  { "joH",		Jv, XX, cond_jump_flag },
  { "jnoH",		Jv, XX, cond_jump_flag },
  { "jbH",		Jv, XX, cond_jump_flag },
  { "jaeH",		Jv, XX, cond_jump_flag },
  { "jeH",		Jv, XX, cond_jump_flag },
  { "jneH",		Jv, XX, cond_jump_flag },
  { "jbeH",		Jv, XX, cond_jump_flag },
  { "jaH",		Jv, XX, cond_jump_flag },
  /* 88 */
  { "jsH",		Jv, XX, cond_jump_flag },
  { "jnsH",		Jv, XX, cond_jump_flag },
  { "jpH",		Jv, XX, cond_jump_flag },
  { "jnpH",		Jv, XX, cond_jump_flag },
  { "jlH",		Jv, XX, cond_jump_flag },
  { "jgeH",		Jv, XX, cond_jump_flag },
  { "jleH",		Jv, XX, cond_jump_flag },
  { "jgH",		Jv, XX, cond_jump_flag },
  /* 90 */
  { "seto",		Eb, XX, XX },
  { "setno",		Eb, XX, XX },
  { "setb",		Eb, XX, XX },
  { "setae",		Eb, XX, XX },
  { "sete",		Eb, XX, XX },
  { "setne",		Eb, XX, XX },
  { "setbe",		Eb, XX, XX },
  { "seta",		Eb, XX, XX },
  /* 98 */
  { "sets",		Eb, XX, XX },
  { "setns",		Eb, XX, XX },
  { "setp",		Eb, XX, XX },
  { "setnp",		Eb, XX, XX },
  { "setl",		Eb, XX, XX },
  { "setge",		Eb, XX, XX },
  { "setle",		Eb, XX, XX },
  { "setg",		Eb, XX, XX },
  /* a0 */
  { "pushT",		fs, XX, XX },
  { "popT",		fs, XX, XX },
  { "cpuid",		XX, XX, XX },
  { "btS",		Ev, Gv, XX },
  { "shldS",		Ev, Gv, Ib },
  { "shldS",		Ev, Gv, CL },
  { "",			OPXCRYPT2, XX, XX },
  { "",			OPXCRYPT, XX, XX },
  /* a8 */
  { "pushT",		gs, XX, XX },
  { "popT",		gs, XX, XX },
  { "rsm",		XX, XX, XX },
  { "btsS",		Ev, Gv, XX },
  { "shrdS",		Ev, Gv, Ib },
  { "shrdS",		Ev, Gv, CL },
  { GRP13 },
  { "imulS",		Gv, Ev, XX },
  /* b0 */
  { "cmpxchgB",		Eb, Gb, XX },
  { "cmpxchgS",		Ev, Gv, XX },
  { "lssS",		Gv, Mp, XX },
  { "btrS",		Ev, Gv, XX },
  { "lfsS",		Gv, Mp, XX },
  { "lgsS",		Gv, Mp, XX },
  { "movz{bR|x|bR|x}",	Gv, Eb, XX },
  { "movz{wR|x|wR|x}",	Gv, Ew, XX }, /* yes, there really is movzww ! */
  /* b8 */
  { "(bad)",		XX, XX, XX },
  { "ud2b",		XX, XX, XX },
  { GRP8 },
  { "btcS",		Ev, Gv, XX },
  { "bsfS",		Gv, Ev, XX },
  { "bsrS",		Gv, Ev, XX },
  { "movs{bR|x|bR|x}",	Gv, Eb, XX },
  { "movs{wR|x|wR|x}",	Gv, Ew, XX }, /* yes, there really is movsww ! */
  /* c0 */
  { "xaddB",		Eb, Gb, XX },
  { "xaddS",		Ev, Gv, XX },
  { PREGRP1 },
  { "movntiS",		Ev, Gv, XX },
  { "pinsrw",		MX, Ed, Ib },
  { "pextrw",		Gd, MS, Ib },
  { "shufpX",		XM, EX, Ib },
  { GRP9 },
  /* c8 */
  { "bswap",		RMeAX, XX, XX },
  { "bswap",		RMeCX, XX, XX },
  { "bswap",		RMeDX, XX, XX },
  { "bswap",		RMeBX, XX, XX },
  { "bswap",		RMeSP, XX, XX },
  { "bswap",		RMeBP, XX, XX },
  { "bswap",		RMeSI, XX, XX },
  { "bswap",		RMeDI, XX, XX },
  /* d0 */
  { PREGRP27 },
  { "psrlw",		MX, EM, XX },
  { "psrld",		MX, EM, XX },
  { "psrlq",		MX, EM, XX },
  { "paddq",		MX, EM, XX },
  { "pmullw",		MX, EM, XX },
  { PREGRP21 },
  { "pmovmskb",		Gd, MS, XX },
  /* d8 */
  { "psubusb",		MX, EM, XX },
  { "psubusw",		MX, EM, XX },
  { "pminub",		MX, EM, XX },
  { "pand",		MX, EM, XX },
  { "paddusb",		MX, EM, XX },
  { "paddusw",		MX, EM, XX },
  { "pmaxub",		MX, EM, XX },
  { "pandn",		MX, EM, XX },
  /* e0 */
  { "pavgb",		MX, EM, XX },
  { "psraw",		MX, EM, XX },
  { "psrad",		MX, EM, XX },
  { "pavgw",		MX, EM, XX },
  { "pmulhuw",		MX, EM, XX },
  { "pmulhw",		MX, EM, XX },
  { PREGRP15 },
  { PREGRP25 },
  /* e8 */
  { "psubsb",		MX, EM, XX },
  { "psubsw",		MX, EM, XX },
  { "pminsw",		MX, EM, XX },
  { "por",		MX, EM, XX },
  { "paddsb",		MX, EM, XX },
  { "paddsw",		MX, EM, XX },
  { "pmaxsw",		MX, EM, XX },
  { "pxor",		MX, EM, XX },
  /* f0 */
  { PREGRP32 },
  { "psllw",		MX, EM, XX },
  { "pslld",		MX, EM, XX },
  { "psllq",		MX, EM, XX },
  { "pmuludq",		MX, EM, XX },
  { "pmaddwd",		MX, EM, XX },
  { "psadbw",		MX, EM, XX },
  { PREGRP18 },
  /* f8 */
  { "psubb",		MX, EM, XX },
  { "psubw",		MX, EM, XX },
  { "psubd",		MX, EM, XX },
  { "psubq",		MX, EM, XX },
  { "paddb",		MX, EM, XX },
  { "paddw",		MX, EM, XX },
  { "paddd",		MX, EM, XX },
  { "(bad)",		XX, XX, XX }
};

static const unsigned char onebyte_has_modrm[256] = {
  /*       0 1 2 3 4 5 6 7 8 9 a b c d e f        */
  /*       -------------------------------        */
  /* 00 */ 1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0, /* 00 */
  /* 10 */ 1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0, /* 10 */
  /* 20 */ 1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0, /* 20 */
  /* 30 */ 1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0, /* 30 */
  /* 40 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 40 */
  /* 50 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 50 */
  /* 60 */ 0,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0, /* 60 */
  /* 70 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 70 */
  /* 80 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 80 */
  /* 90 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 90 */
  /* a0 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* a0 */
  /* b0 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* b0 */
  /* c0 */ 1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0, /* c0 */
  /* d0 */ 1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1, /* d0 */
  /* e0 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* e0 */
  /* f0 */ 0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1  /* f0 */
  /*       -------------------------------        */
  /*       0 1 2 3 4 5 6 7 8 9 a b c d e f        */
};

static const unsigned char twobyte_has_modrm[256] = {
  /*       0 1 2 3 4 5 6 7 8 9 a b c d e f        */
  /*       -------------------------------        */
  /* 00 */ 1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,1, /* 0f */
  /* 10 */ 1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0, /* 1f */
  /* 20 */ 1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1, /* 2f */
  /* 30 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 3f */
  /* 40 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 4f */
  /* 50 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 5f */
  /* 60 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 6f */
  /* 70 */ 1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1, /* 7f */
  /* 80 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 8f */
  /* 90 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 9f */
  /* a0 */ 0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1, /* af */
  /* b0 */ 1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1, /* bf */
  /* c0 */ 1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0, /* cf */
  /* d0 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* df */
  /* e0 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ef */
  /* f0 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0  /* ff */
  /*       -------------------------------        */
  /*       0 1 2 3 4 5 6 7 8 9 a b c d e f        */
};

static const unsigned char twobyte_uses_SSE_prefix[256] = {
  /*       0 1 2 3 4 5 6 7 8 9 a b c d e f        */
  /*       -------------------------------        */
  /* 00 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 0f */
  /* 10 */ 1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0, /* 1f */
  /* 20 */ 0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0, /* 2f */
  /* 30 */ 0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0, /* 3f */
  /* 40 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 4f */
  /* 50 */ 0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1, /* 5f */
  /* 60 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1, /* 6f */
  /* 70 */ 1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1, /* 7f */
  /* 80 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 8f */
  /* 90 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 9f */
  /* a0 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* af */
  /* b0 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* bf */
  /* c0 */ 0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0, /* cf */
  /* d0 */ 1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0, /* df */
  /* e0 */ 0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0, /* ef */
  /* f0 */ 1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0  /* ff */
  /*       -------------------------------        */
  /*       0 1 2 3 4 5 6 7 8 9 a b c d e f        */
};

static char obuf[100];
static char *obufp;
static char scratchbuf[100];
static unsigned char *start_codep;
static unsigned char *insn_codep;
static unsigned char *codep;
static disassemble_info *the_info;
static int mod;
static int rm;
static int reg;
static unsigned char need_modrm;

/* If we are accessing mod/rm/reg without need_modrm set, then the
   values are stale.  Hitting this abort likely indicates that you
   need to update onebyte_has_modrm or twobyte_has_modrm.  */
#define MODRM_CHECK  if (!need_modrm) abort ()

static const char **names64;
static const char **names32;
static const char **names16;
static const char **names8;
static const char **names8rex;
static const char **names_seg;
static const char **index16;

static const char *intel_names64[] = {
  "rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi",
  "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
};
static const char *intel_names32[] = {
  "eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi",
  "r8d", "r9d", "r10d", "r11d", "r12d", "r13d", "r14d", "r15d"
};
static const char *intel_names16[] = {
  "ax", "cx", "dx", "bx", "sp", "bp", "si", "di",
  "r8w", "r9w", "r10w", "r11w", "r12w", "r13w", "r14w", "r15w"
};
static const char *intel_names8[] = {
  "al", "cl", "dl", "bl", "ah", "ch", "dh", "bh",
};
static const char *intel_names8rex[] = {
  "al", "cl", "dl", "bl", "spl", "bpl", "sil", "dil",
  "r8b", "r9b", "r10b", "r11b", "r12b", "r13b", "r14b", "r15b"
};
static const char *intel_names_seg[] = {
  "es", "cs", "ss", "ds", "fs", "gs", "?", "?",
};
static const char *intel_index16[] = {
  "bx+si", "bx+di", "bp+si", "bp+di", "si", "di", "bp", "bx"
};

static const char *att_names64[] = {
  "%rax", "%rcx", "%rdx", "%rbx", "%rsp", "%rbp", "%rsi", "%rdi",
  "%r8", "%r9", "%r10", "%r11", "%r12", "%r13", "%r14", "%r15"
};
static const char *att_names32[] = {
  "%eax", "%ecx", "%edx", "%ebx", "%esp", "%ebp", "%esi", "%edi",
  "%r8d", "%r9d", "%r10d", "%r11d", "%r12d", "%r13d", "%r14d", "%r15d"
};
static const char *att_names16[] = {
  "%ax", "%cx", "%dx", "%bx", "%sp", "%bp", "%si", "%di",
  "%r8w", "%r9w", "%r10w", "%r11w", "%r12w", "%r13w", "%r14w", "%r15w"
};
static const char *att_names8[] = {
  "%al", "%cl", "%dl", "%bl", "%ah", "%ch", "%dh", "%bh",
};
static const char *att_names8rex[] = {
  "%al", "%cl", "%dl", "%bl", "%spl", "%bpl", "%sil", "%dil",
  "%r8b", "%r9b", "%r10b", "%r11b", "%r12b", "%r13b", "%r14b", "%r15b"
};
static const char *att_names_seg[] = {
  "%es", "%cs", "%ss", "%ds", "%fs", "%gs", "%?", "%?",
};
static const char *att_index16[] = {
  "%bx,%si", "%bx,%di", "%bp,%si", "%bp,%di", "%si", "%di", "%bp", "%bx"
};

static const struct dis386 grps[][8] = {
  /* GRP1b */
  {
    { "addA",	Eb, Ib, XX },
    { "orA",	Eb, Ib, XX },
    { "adcA",	Eb, Ib, XX },
    { "sbbA",	Eb, Ib, XX },
    { "andA",	Eb, Ib, XX },
    { "subA",	Eb, Ib, XX },
    { "xorA",	Eb, Ib, XX },
    { "cmpA",	Eb, Ib, XX }
  },
  /* GRP1S */
  {
    { "addQ",	Ev, Iv, XX },
    { "orQ",	Ev, Iv, XX },
    { "adcQ",	Ev, Iv, XX },
    { "sbbQ",	Ev, Iv, XX },
    { "andQ",	Ev, Iv, XX },
    { "subQ",	Ev, Iv, XX },
    { "xorQ",	Ev, Iv, XX },
    { "cmpQ",	Ev, Iv, XX }
  },
  /* GRP1Ss */
  {
    { "addQ",	Ev, sIb, XX },
    { "orQ",	Ev, sIb, XX },
    { "adcQ",	Ev, sIb, XX },
    { "sbbQ",	Ev, sIb, XX },
    { "andQ",	Ev, sIb, XX },
    { "subQ",	Ev, sIb, XX },
    { "xorQ",	Ev, sIb, XX },
    { "cmpQ",	Ev, sIb, XX }
  },
  /* GRP2b */
  {
    { "rolA",	Eb, Ib, XX },
    { "rorA",	Eb, Ib, XX },
    { "rclA",	Eb, Ib, XX },
    { "rcrA",	Eb, Ib, XX },
    { "shlA",	Eb, Ib, XX },
    { "shrA",	Eb, Ib, XX },
    { "(bad)",	XX, XX, XX },
    { "sarA",	Eb, Ib, XX },
  },
  /* GRP2S */
  {
    { "rolQ",	Ev, Ib, XX },
    { "rorQ",	Ev, Ib, XX },
    { "rclQ",	Ev, Ib, XX },
    { "rcrQ",	Ev, Ib, XX },
    { "shlQ",	Ev, Ib, XX },
    { "shrQ",	Ev, Ib, XX },
    { "(bad)",	XX, XX, XX },
    { "sarQ",	Ev, Ib, XX },
  },
  /* GRP2b_one */
  {
    { "rolA",	Eb, XX, XX },
    { "rorA",	Eb, XX, XX },
    { "rclA",	Eb, XX, XX },
    { "rcrA",	Eb, XX, XX },
    { "shlA",	Eb, XX, XX },
    { "shrA",	Eb, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "sarA",	Eb, XX, XX },
  },
  /* GRP2S_one */
  {
    { "rolQ",	Ev, XX, XX },
    { "rorQ",	Ev, XX, XX },
    { "rclQ",	Ev, XX, XX },
    { "rcrQ",	Ev, XX, XX },
    { "shlQ",	Ev, XX, XX },
    { "shrQ",	Ev, XX, XX },
    { "(bad)",	XX, XX, XX},
    { "sarQ",	Ev, XX, XX },
  },
  /* GRP2b_cl */
  {
    { "rolA",	Eb, CL, XX },
    { "rorA",	Eb, CL, XX },
    { "rclA",	Eb, CL, XX },
    { "rcrA",	Eb, CL, XX },
    { "shlA",	Eb, CL, XX },
    { "shrA",	Eb, CL, XX },
    { "(bad)",	XX, XX, XX },
    { "sarA",	Eb, CL, XX },
  },
  /* GRP2S_cl */
  {
    { "rolQ",	Ev, CL, XX },
    { "rorQ",	Ev, CL, XX },
    { "rclQ",	Ev, CL, XX },
    { "rcrQ",	Ev, CL, XX },
    { "shlQ",	Ev, CL, XX },
    { "shrQ",	Ev, CL, XX },
    { "(bad)",	XX, XX, XX },
    { "sarQ",	Ev, CL, XX }
  },
  /* GRP3b */
  {
    { "testA",	Eb, Ib, XX },
    { "(bad)",	Eb, XX, XX },
    { "notA",	Eb, XX, XX },
    { "negA",	Eb, XX, XX },
    { "mulA",	Eb, XX, XX },	/* Don't print the implicit %al register,  */
    { "imulA",	Eb, XX, XX },	/* to distinguish these opcodes from other */
    { "divA",	Eb, XX, XX },	/* mul/imul opcodes.  Do the same for div  */
    { "idivA",	Eb, XX, XX }	/* and idiv for consistency.		   */
  },
  /* GRP3S */
  {
    { "testQ",	Ev, Iv, XX },
    { "(bad)",	XX, XX, XX },
    { "notQ",	Ev, XX, XX },
    { "negQ",	Ev, XX, XX },
    { "mulQ",	Ev, XX, XX },	/* Don't print the implicit register.  */
    { "imulQ",	Ev, XX, XX },
    { "divQ",	Ev, XX, XX },
    { "idivQ",	Ev, XX, XX },
  },
  /* GRP4 */
  {
    { "incA",	Eb, XX, XX },
    { "decA",	Eb, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
  },
  /* GRP5 */
  {
    { "incQ",	Ev, XX, XX },
    { "decQ",	Ev, XX, XX },
    { "callT",	indirEv, XX, XX },
    { "lcallT",	indirEv, XX, XX },
    { "jmpT",	indirEv, XX, XX },
    { "ljmpT",	indirEv, XX, XX },
    { "pushU",	Ev, XX, XX },
    { "(bad)",	XX, XX, XX },
  },
  /* GRP6 */
  {
    { "sldtQ",	Ev, XX, XX },
    { "strQ",	Ev, XX, XX },
    { "lldt",	Ew, XX, XX },
    { "ltr",	Ew, XX, XX },
    { "verr",	Ew, XX, XX },
    { "verw",	Ew, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX }
  },
  /* GRP7 */
  {
    { "sgdtQ",	 M, XX, XX },
    { "sidtQ", PNI_Fixup, 0, XX, XX },
    { "lgdtQ", XCR_Fixup, 0, XX, XX },
    { "lidtQ",	 M, XX, XX },
    { "smswQ",	Ev, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "lmsw",	Ew, XX, XX },
    { "invlpg",	INVLPG_Fixup, w_mode, XX, XX },
  },
  /* GRP8 */
  {
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "btQ",	Ev, Ib, XX },
    { "btsQ",	Ev, Ib, XX },
    { "btrQ",	Ev, Ib, XX },
    { "btcQ",	Ev, Ib, XX },
  },
  /* GRP9 */
  {
    { "(bad)",	XX, XX, XX },
    { "cmpxchg8b", Ev, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "rdrand",	Ev, XX, XX },
    { "(bad)",	XX, XX, XX },
  },
  /* GRP10 */
  {
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "psrlw",	MS, Ib, XX },
    { "(bad)",	XX, XX, XX },
    { "psraw",	MS, Ib, XX },
    { "(bad)",	XX, XX, XX },
    { "psllw",	MS, Ib, XX },
    { "(bad)",	XX, XX, XX },
  },
  /* GRP11 */
  {
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "psrld",	MS, Ib, XX },
    { "(bad)",	XX, XX, XX },
    { "psrad",	MS, Ib, XX },
    { "(bad)",	XX, XX, XX },
    { "pslld",	MS, Ib, XX },
    { "(bad)",	XX, XX, XX },
  },
  /* GRP12 */
  {
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "psrlq",	MS, Ib, XX },
    { "psrldq",	MS, Ib, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "psllq",	MS, Ib, XX },
    { "pslldq",	MS, Ib, XX },
  },
  /* GRP13 */
  {
    { "fxsave", Ev, XX, XX },
    { "fxrstor", Ev, XX, XX },
    { "ldmxcsr", Ev, XX, XX },
    { "stmxcsr", Ev, XX, XX },
    { "xsave",	Ev, XX, XX },
    { "xrstor", OP_0fae, v_mode, XX, XX },
    { "xsaveopt", OP_0fae, v_mode, XX, XX },
    { "clflush", OP_0fae, v_mode, XX, XX },
  },
  /* GRP14 */
  {
    { "prefetchnta", Ev, XX, XX },
    { "prefetcht0", Ev, XX, XX },
    { "prefetcht1", Ev, XX, XX },
    { "prefetcht2", Ev, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
  },
  /* GRPAMD */
  {
    { "prefetch", Eb, XX, XX },
    { "prefetchw", Eb, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
  },
};

static const struct dis386 prefix_user_table[][4] = {
  /* PREGRP0 */
  {
    { "addps", XM, EX, XX },
    { "addss", XM, EX, XX },
    { "addpd", XM, EX, XX },
    { "addsd", XM, EX, XX },
  },
  /* PREGRP1 */
  {
    { "", XM, EX, OPSIMD },	/* See OP_SIMD_SUFFIX.  */
    { "", XM, EX, OPSIMD },
    { "", XM, EX, OPSIMD },
    { "", XM, EX, OPSIMD },
  },
  /* PREGRP2 */
  {
    { "cvtpi2ps", XM, EM, XX },
    { "cvtsi2ssY", XM, Ev, XX },
    { "cvtpi2pd", XM, EM, XX },
    { "cvtsi2sdY", XM, Ev, XX },
  },
  /* PREGRP3 */
  {
    { "cvtps2pi", MX, EX, XX },
    { "cvtss2siY", Gv, EX, XX },
    { "cvtpd2pi", MX, EX, XX },
    { "cvtsd2siY", Gv, EX, XX },
  },
  /* PREGRP4 */
  {
    { "cvttps2pi", MX, EX, XX },
    { "cvttss2siY", Gv, EX, XX },
    { "cvttpd2pi", MX, EX, XX },
    { "cvttsd2siY", Gv, EX, XX },
  },
  /* PREGRP5 */
  {
    { "divps", XM, EX, XX },
    { "divss", XM, EX, XX },
    { "divpd", XM, EX, XX },
    { "divsd", XM, EX, XX },
  },
  /* PREGRP6 */
  {
    { "maxps", XM, EX, XX },
    { "maxss", XM, EX, XX },
    { "maxpd", XM, EX, XX },
    { "maxsd", XM, EX, XX },
  },
  /* PREGRP7 */
  {
    { "minps", XM, EX, XX },
    { "minss", XM, EX, XX },
    { "minpd", XM, EX, XX },
    { "minsd", XM, EX, XX },
  },
  /* PREGRP8 */
  {
    { "movups", XM, EX, XX },
    { "movss", XM, EX, XX },
    { "movupd", XM, EX, XX },
    { "movsd", XM, EX, XX },
  },
  /* PREGRP9 */
  {
    { "movups", EX, XM, XX },
    { "movss", EX, XM, XX },
    { "movupd", EX, XM, XX },
    { "movsd", EX, XM, XX },
  },
  /* PREGRP10 */
  {
    { "mulps", XM, EX, XX },
    { "mulss", XM, EX, XX },
    { "mulpd", XM, EX, XX },
    { "mulsd", XM, EX, XX },
  },
  /* PREGRP11 */
  {
    { "rcpps", XM, EX, XX },
    { "rcpss", XM, EX, XX },
    { "(bad)", XM, EX, XX },
    { "(bad)", XM, EX, XX },
  },
  /* PREGRP12 */
  {
    { "rsqrtps", XM, EX, XX },
    { "rsqrtss", XM, EX, XX },
    { "(bad)", XM, EX, XX },
    { "(bad)", XM, EX, XX },
  },
  /* PREGRP13 */
  {
    { "sqrtps", XM, EX, XX },
    { "sqrtss", XM, EX, XX },
    { "sqrtpd", XM, EX, XX },
    { "sqrtsd", XM, EX, XX },
  },
  /* PREGRP14 */
  {
    { "subps", XM, EX, XX },
    { "subss", XM, EX, XX },
    { "subpd", XM, EX, XX },
    { "subsd", XM, EX, XX },
  },
  /* PREGRP15 */
  {
    { "(bad)", XM, EX, XX },
    { "cvtdq2pd", XM, EX, XX },
    { "cvttpd2dq", XM, EX, XX },
    { "cvtpd2dq", XM, EX, XX },
  },
  /* PREGRP16 */
  {
    { "cvtdq2ps", XM, EX, XX },
    { "cvttps2dq",XM, EX, XX },
    { "cvtps2dq",XM, EX, XX },
    { "(bad)", XM, EX, XX },
  },
  /* PREGRP17 */
  {
    { "cvtps2pd", XM, EX, XX },
    { "cvtss2sd", XM, EX, XX },
    { "cvtpd2ps", XM, EX, XX },
    { "cvtsd2ss", XM, EX, XX },
  },
  /* PREGRP18 */
  {
    { "maskmovq", MX, MS, XX },
    { "(bad)", XM, EX, XX },
    { "maskmovdqu", XM, EX, XX },
    { "(bad)", XM, EX, XX },
  },
  /* PREGRP19 */
  {
    { "movq", MX, EM, XX },
    { "movdqu", XM, EX, XX },
    { "movdqa", XM, EX, XX },
    { "(bad)", XM, EX, XX },
  },
  /* PREGRP20 */
  {
    { "movq", EM, MX, XX },
    { "movdqu", EX, XM, XX },
    { "movdqa", EX, XM, XX },
    { "(bad)", EX, XM, XX },
  },
  /* PREGRP21 */
  {
    { "(bad)", EX, XM, XX },
    { "movq2dq", XM, MS, XX },
    { "movq", EX, XM, XX },
    { "movdq2q", MX, XS, XX },
  },
  /* PREGRP22 */
  {
    { "pshufw", MX, EM, Ib },
    { "pshufhw", XM, EX, Ib },
    { "pshufd", XM, EX, Ib },
    { "pshuflw", XM, EX, Ib },
  },
  /* PREGRP23 */
  {
    { "movd", Edq, MX, XX },
    { "movq", XM, EX, XX },
    { "movd", Edq, XM, XX },
    { "(bad)", Ed, XM, XX },
  },
  /* PREGRP24 */
  {
    { "(bad)", MX, EX, XX },
    { "(bad)", XM, EX, XX },
    { "punpckhqdq", XM, EX, XX },
    { "(bad)", XM, EX, XX },
  },
  /* PREGRP25 */
  {
  { "movntq", Ev, MX, XX },
  { "(bad)", Ev, XM, XX },
  { "movntdq", Ev, XM, XX },
  { "(bad)", Ev, XM, XX },
  },
  /* PREGRP26 */
  {
    { "(bad)", MX, EX, XX },
    { "(bad)", XM, EX, XX },
    { "punpcklqdq", XM, EX, XX },
    { "(bad)", XM, EX, XX },
  },
  /* PREGRP27 */
  {
    { "(bad)", MX, EX, XX },
    { "(bad)", XM, EX, XX },
    { "addsubpd", XM, EX, XX },
    { "addsubps", XM, EX, XX },
  },
  /* PREGRP28 */
  {
    { "(bad)", MX, EX, XX },
    { "(bad)", XM, EX, XX },
    { "haddpd", XM, EX, XX },
    { "haddps", XM, EX, XX },
  },
  /* PREGRP29 */
  {
    { "(bad)", MX, EX, XX },
    { "(bad)", XM, EX, XX },
    { "hsubpd", XM, EX, XX },
    { "hsubps", XM, EX, XX },
  },
  /* PREGRP30 */
  {
    { "movlpX", XM, EX, SIMD_Fixup, 'h' }, /* really only 2 operands */
    { "movsldup", XM, EX, XX },
    { "movlpd", XM, EX, XX },
    { "movddup", XM, EX, XX },
  },
  /* PREGRP31 */
  {
    { "movhpX", XM, EX, SIMD_Fixup, 'l' },
    { "movshdup", XM, EX, XX },
    { "movhpd", XM, EX, XX },
    { "(bad)", XM, EX, XX },
  },
  /* PREGRP32 */
  {
    { "(bad)", XM, EX, XX },
    { "(bad)", XM, EX, XX },
    { "(bad)", XM, EX, XX },
    { "lddqu", XM, M, XX },
  },
};

static const struct dis386 x86_64_table[][2] = {
  {
    { "arpl", Ew, Gw, XX },
    { "movs{||lq|xd}", Gv, Ed, XX },
  },
};

#define INTERNAL_DISASSEMBLER_ERROR _("<internal disassembler error>")

static void
ckprefix (void)
{
  int newrex;
  rex = 0;
  prefixes = 0;
  used_prefixes = 0;
  rex_used = 0;
  while (1)
    {
      FETCH_DATA (the_info, codep + 1);
      newrex = 0;
      switch (*codep)
	{
	/* REX prefixes family.  */
	case 0x40:
	case 0x41:
	case 0x42:
	case 0x43:
	case 0x44:
	case 0x45:
	case 0x46:
	case 0x47:
	case 0x48:
	case 0x49:
	case 0x4a:
	case 0x4b:
	case 0x4c:
	case 0x4d:
	case 0x4e:
	case 0x4f:
	    if (mode_64bit)
	      newrex = *codep;
	    else
	      return;
	  break;
	case 0xf3:
	  prefixes |= PREFIX_REPZ;
	  break;
	case 0xf2:
	  prefixes |= PREFIX_REPNZ;
	  break;
	case 0xf0:
	  prefixes |= PREFIX_LOCK;
	  break;
	case 0x2e:
	  prefixes |= PREFIX_CS;
	  break;
	case 0x36:
	  prefixes |= PREFIX_SS;
	  break;
	case 0x3e:
	  prefixes |= PREFIX_DS;
	  break;
	case 0x26:
	  prefixes |= PREFIX_ES;
	  break;
	case 0x64:
	  prefixes |= PREFIX_FS;
	  break;
	case 0x65:
	  prefixes |= PREFIX_GS;
	  break;
	case 0x66:
	  prefixes |= PREFIX_DATA;
	  break;
	case 0x67:
	  prefixes |= PREFIX_ADDR;
	  break;
	case FWAIT_OPCODE:
	  /* fwait is really an instruction.  If there are prefixes
	     before the fwait, they belong to the fwait, *not* to the
	     following instruction.  */
	  if (prefixes)
	    {
	      prefixes |= PREFIX_FWAIT;
	      codep++;
	      return;
	    }
	  prefixes = PREFIX_FWAIT;
	  break;
	default:
	  return;
	}
      /* Rex is ignored when followed by another prefix.  */
      if (rex)
	{
	  oappend (prefix_name (rex, 0));
	  oappend (" ");
	}
      rex = newrex;
      codep++;
    }
}

/* Return the name of the prefix byte PREF, or NULL if PREF is not a
   prefix byte.  */

static const char *
prefix_name (int pref, int sizeflag)
{
  switch (pref)
    {
    /* REX prefixes family.  */
    case 0x40:
      return "rex";
    case 0x41:
      return "rexZ";
    case 0x42:
      return "rexY";
    case 0x43:
      return "rexYZ";
    case 0x44:
      return "rexX";
    case 0x45:
      return "rexXZ";
    case 0x46:
      return "rexXY";
    case 0x47:
      return "rexXYZ";
    case 0x48:
      return "rex64";
    case 0x49:
      return "rex64Z";
    case 0x4a:
      return "rex64Y";
    case 0x4b:
      return "rex64YZ";
    case 0x4c:
      return "rex64X";
    case 0x4d:
      return "rex64XZ";
    case 0x4e:
      return "rex64XY";
    case 0x4f:
      return "rex64XYZ";
    case 0xf3:
      return "repz";
    case 0xf2:
      return "repnz";
    case 0xf0:
      return "lock";
    case 0x2e:
      return "cs";
    case 0x36:
      return "ss";
    case 0x3e:
      return "ds";
    case 0x26:
      return "es";
    case 0x64:
      return "fs";
    case 0x65:
      return "gs";
    case 0x66:
      return (sizeflag & DFLAG) ? "data16" : "data32";
    case 0x67:
      if (mode_64bit)
	return (sizeflag & AFLAG) ? "addr32" : "addr64";
      else
	return ((sizeflag & AFLAG) && !mode_64bit) ? "addr16" : "addr32";
    case FWAIT_OPCODE:
      return "fwait";
    default:
      return NULL;
    }
}

static char op1out[100], op2out[100], op3out[100];
static int op_ad, op_index[3];
static bfd_vma op_address[3];
static bfd_vma op_riprel[3];
static bfd_vma start_pc;

/*
 *   On the 386's of 1988, the maximum length of an instruction is 15 bytes.
 *   (see topic "Redundant prefixes" in the "Differences from 8086"
 *   section of the "Virtual 8086 Mode" chapter.)
 * 'pc' should be the address of this instruction, it will
 *   be used to print the target address if this is a relative jump or call
 * The function returns the length of this instruction in bytes.
 */

static char intel_syntax;
static char open_char;
static char close_char;
static char separator_char;
static char scale_char;

/* Here for backwards compatibility.  When gdb stops using
   print_insn_i386_att and print_insn_i386_intel these functions can
   disappear, and print_insn_i386 be merged into print_insn.  */
int
print_insn_i386_att (bfd_vma pc, disassemble_info *info)
{
  intel_syntax = 0;

  return print_insn (pc, info);
}

int
print_insn_i386_intel (bfd_vma pc, disassemble_info *info)
{
  intel_syntax = 1;

  return print_insn (pc, info);
}

int
print_insn_i386 (bfd_vma pc, disassemble_info *info)
{
  intel_syntax = -1;

  return print_insn (pc, info);
}

static int
print_insn (bfd_vma pc, disassemble_info *info)
{
  const struct dis386 *dp;
  int i;
  int two_source_ops;
  char *first, *second, *third;
  int needcomma;
  unsigned char uses_SSE_prefix;
  int sizeflag;
  const char *p;
  struct dis_private priv;

  mode_64bit = (info->mach == bfd_mach_x86_64_intel_syntax
		|| info->mach == bfd_mach_x86_64);

  if (intel_syntax == (char) -1)
    intel_syntax = (info->mach == bfd_mach_i386_i386_intel_syntax
		    || info->mach == bfd_mach_x86_64_intel_syntax);

  if (info->mach == bfd_mach_i386_i386
      || info->mach == bfd_mach_x86_64
      || info->mach == bfd_mach_i386_i386_intel_syntax
      || info->mach == bfd_mach_x86_64_intel_syntax)
    priv.orig_sizeflag = AFLAG | DFLAG;
  else if (info->mach == bfd_mach_i386_i8086)
    priv.orig_sizeflag = 0;
  else
    abort ();

  for (p = info->disassembler_options; p != NULL; )
    {
      if (strncmp (p, "x86-64", 6) == 0)
	{
	  mode_64bit = 1;
	  priv.orig_sizeflag = AFLAG | DFLAG;
	}
      else if (strncmp (p, "i386", 4) == 0)
	{
	  mode_64bit = 0;
	  priv.orig_sizeflag = AFLAG | DFLAG;
	}
      else if (strncmp (p, "i8086", 5) == 0)
	{
	  mode_64bit = 0;
	  priv.orig_sizeflag = 0;
	}
      else if (strncmp (p, "intel", 5) == 0)
	{
	  intel_syntax = 1;
	}
      else if (strncmp (p, "att", 3) == 0)
	{
	  intel_syntax = 0;
	}
      else if (strncmp (p, "addr", 4) == 0)
	{
	  if (p[4] == '1' && p[5] == '6')
	    priv.orig_sizeflag &= ~AFLAG;
	  else if (p[4] == '3' && p[5] == '2')
	    priv.orig_sizeflag |= AFLAG;
	}
      else if (strncmp (p, "data", 4) == 0)
	{
	  if (p[4] == '1' && p[5] == '6')
	    priv.orig_sizeflag &= ~DFLAG;
	  else if (p[4] == '3' && p[5] == '2')
	    priv.orig_sizeflag |= DFLAG;
	}
      else if (strncmp (p, "suffix", 6) == 0)
	priv.orig_sizeflag |= SUFFIX_ALWAYS;

      p = strchr (p, ',');
      if (p != NULL)
	p++;
    }

  if (intel_syntax)
    {
      names64 = intel_names64;
      names32 = intel_names32;
      names16 = intel_names16;
      names8 = intel_names8;
      names8rex = intel_names8rex;
      names_seg = intel_names_seg;
      index16 = intel_index16;
      open_char = '[';
      close_char = ']';
      separator_char = '+';
      scale_char = '*';
    }
  else
    {
      names64 = att_names64;
      names32 = att_names32;
      names16 = att_names16;
      names8 = att_names8;
      names8rex = att_names8rex;
      names_seg = att_names_seg;
      index16 = att_index16;
      open_char = '(';
      close_char =  ')';
      separator_char = ',';
      scale_char = ',';
    }

  /* The output looks better if we put 7 bytes on a line, since that
     puts most long word instructions on a single line.  */
  info->bytes_per_line = 7;

  info->private_data = &priv;
  priv.max_fetched = priv.the_buffer;
  priv.insn_start = pc;

  obuf[0] = 0;
  op1out[0] = 0;
  op2out[0] = 0;
  op3out[0] = 0;

  op_index[0] = op_index[1] = op_index[2] = -1;

  the_info = info;
  start_pc = pc;
  start_codep = priv.the_buffer;
  codep = priv.the_buffer;

  if (setjmp (priv.bailout) != 0)
    {
      const char *name;

      /* Getting here means we tried for data but didn't get it.  That
	 means we have an incomplete instruction of some sort.  Just
	 print the first byte as a prefix or a .byte pseudo-op.  */
      if (codep > priv.the_buffer)
	{
	  name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);
	  if (name != NULL)
	    (*info->fprintf_func) (info->stream, "%s", name);
	  else
	    {
	      /* Just print the first byte as a .byte instruction.  */
	      (*info->fprintf_func) (info->stream, ".byte 0x%x",
				     (unsigned int) priv.the_buffer[0]);
	    }

	  return 1;
	}

      return -1;
    }

  obufp = obuf;
  ckprefix ();

  insn_codep = codep;
  sizeflag = priv.orig_sizeflag;

  FETCH_DATA (info, codep + 1);
  two_source_ops = (*codep == 0x62) || (*codep == 0xc8);

  if ((prefixes & PREFIX_FWAIT)
      && ((*codep < 0xd8) || (*codep > 0xdf)))
    {
      const char *name;

      /* fwait not followed by floating point instruction.  Print the
	 first prefix, which is probably fwait itself.  */
      name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);
      if (name == NULL)
	name = INTERNAL_DISASSEMBLER_ERROR;
      (*info->fprintf_func) (info->stream, "%s", name);
      return 1;
    }

  if (*codep == 0x0f)
    {
      FETCH_DATA (info, codep + 2);
      dp = &dis386_twobyte[*++codep];
      need_modrm = twobyte_has_modrm[*codep];
      uses_SSE_prefix = twobyte_uses_SSE_prefix[*codep];
    }
  else
    {
      dp = &dis386[*codep];
      need_modrm = onebyte_has_modrm[*codep];
      uses_SSE_prefix = 0;
    }
  codep++;

  if (!uses_SSE_prefix && (prefixes & PREFIX_REPZ))
    {
      oappend ("repz ");
      used_prefixes |= PREFIX_REPZ;
    }
  if (!uses_SSE_prefix && (prefixes & PREFIX_REPNZ))
    {
      oappend ("repnz ");
      used_prefixes |= PREFIX_REPNZ;
    }
  if (prefixes & PREFIX_LOCK)
    {
      oappend ("lock ");
      used_prefixes |= PREFIX_LOCK;
    }

  if (prefixes & PREFIX_ADDR)
    {
      sizeflag ^= AFLAG;
      if (dp->bytemode3 != loop_jcxz_mode || intel_syntax)
	{
	  if ((sizeflag & AFLAG) || mode_64bit)
	    oappend ("addr32 ");
	  else
	    oappend ("addr16 ");
	  used_prefixes |= PREFIX_ADDR;
	}
    }

  if (!uses_SSE_prefix && (prefixes & PREFIX_DATA))
    {
      sizeflag ^= DFLAG;
      if (dp->bytemode3 == cond_jump_mode
	  && dp->bytemode1 == v_mode
	  && !intel_syntax)
	{
	  if (sizeflag & DFLAG)
	    oappend ("data32 ");
	  else
	    oappend ("data16 ");
	  used_prefixes |= PREFIX_DATA;
	}
    }

  if (need_modrm)
    {
      FETCH_DATA (info, codep + 1);
      mod = (*codep >> 6) & 3;
      reg = (*codep >> 3) & 7;
      rm = *codep & 7;
    }

  if (dp->name == NULL && dp->bytemode1 == FLOATCODE)
    {
      dofloat (sizeflag);
    }
  else
    {
      int index;
      if (dp->name == NULL)
	{
	  switch (dp->bytemode1)
	    {
	    case USE_GROUPS:
	      dp = &grps[dp->bytemode2][reg];
	      break;

	    case USE_PREFIX_USER_TABLE:
	      index = 0;
	      used_prefixes |= (prefixes & PREFIX_REPZ);
	      if (prefixes & PREFIX_REPZ)
		index = 1;
	      else
		{
		  used_prefixes |= (prefixes & PREFIX_DATA);
		  if (prefixes & PREFIX_DATA)
		    index = 2;
		  else
		    {
		      used_prefixes |= (prefixes & PREFIX_REPNZ);
		      if (prefixes & PREFIX_REPNZ)
			index = 3;
		    }
		}
	      dp = &prefix_user_table[dp->bytemode2][index];
	      break;

	    case X86_64_SPECIAL:
	      dp = &x86_64_table[dp->bytemode2][mode_64bit];
	      break;

	    default:
	      oappend (INTERNAL_DISASSEMBLER_ERROR);
	      break;
	    }
	}

      if (putop (dp->name, sizeflag) == 0)
	{
	  obufp = op1out;
	  op_ad = 2;
	  if (dp->op1)
	    (*dp->op1) (dp->bytemode1, sizeflag);

	  obufp = op2out;
	  op_ad = 1;
	  if (dp->op2)
	    (*dp->op2) (dp->bytemode2, sizeflag);

	  obufp = op3out;
	  op_ad = 0;
	  if (dp->op3)
	    (*dp->op3) (dp->bytemode3, sizeflag);
	}
    }

  /* See if any prefixes were not used.  If so, print the first one
     separately.  If we don't do this, we'll wind up printing an
     instruction stream which does not precisely correspond to the
     bytes we are disassembling.  */
  if ((prefixes & ~used_prefixes) != 0)
    {
      const char *name;

      name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);
      if (name == NULL)
	name = INTERNAL_DISASSEMBLER_ERROR;
      (*info->fprintf_func) (info->stream, "%s", name);
      return 1;
    }
  if (rex & ~rex_used)
    {
      const char *name;
      name = prefix_name (rex | 0x40, priv.orig_sizeflag);
      if (name == NULL)
	name = INTERNAL_DISASSEMBLER_ERROR;
      (*info->fprintf_func) (info->stream, "%s ", name);
    }

  obufp = obuf + strlen (obuf);
  for (i = strlen (obuf); i < 6; i++)
    oappend (" ");
  oappend (" ");
  (*info->fprintf_func) (info->stream, "%s", obuf);

  /* The enter and bound instructions are printed with operands in the same
     order as the intel book; everything else is printed in reverse order.  */
  if (intel_syntax || two_source_ops)
    {
      first = op1out;
      second = op2out;
      third = op3out;
      op_ad = op_index[0];
      op_index[0] = op_index[2];
      op_index[2] = op_ad;
    }
  else
    {
      first = op3out;
      second = op2out;
      third = op1out;
    }
  needcomma = 0;
  if (*first)
    {
      if (op_index[0] != -1 && !op_riprel[0])
	(*info->print_address_func) ((bfd_vma) op_address[op_index[0]], info);
      else
	(*info->fprintf_func) (info->stream, "%s", first);
      needcomma = 1;
    }
  if (*second)
    {
      if (needcomma)
	(*info->fprintf_func) (info->stream, ",");
      if (op_index[1] != -1 && !op_riprel[1])
	(*info->print_address_func) ((bfd_vma) op_address[op_index[1]], info);
      else
	(*info->fprintf_func) (info->stream, "%s", second);
      needcomma = 1;
    }
  if (*third)
    {
      if (needcomma)
	(*info->fprintf_func) (info->stream, ",");
      if (op_index[2] != -1 && !op_riprel[2])
	(*info->print_address_func) ((bfd_vma) op_address[op_index[2]], info);
      else
	(*info->fprintf_func) (info->stream, "%s", third);
    }
  for (i = 0; i < 3; i++)
    if (op_index[i] != -1 && op_riprel[i])
      {
	(*info->fprintf_func) (info->stream, "        # ");
	(*info->print_address_func) ((bfd_vma) (start_pc + codep - start_codep
						+ op_address[op_index[i]]), info);
      }
  return codep - priv.the_buffer;
}

static const char *float_mem[] = {
  /* d8 */
  "fadd{s||s|}",
  "fmul{s||s|}",
  "fcom{s||s|}",
  "fcomp{s||s|}",
  "fsub{s||s|}",
  "fsubr{s||s|}",
  "fdiv{s||s|}",
  "fdivr{s||s|}",
  /* d9 */
  "fld{s||s|}",
  "(bad)",
  "fst{s||s|}",
  "fstp{s||s|}",
  "fldenv",
  "fldcw",
  "fNstenv",
  "fNstcw",
  /* da */
  "fiadd{l||l|}",
  "fimul{l||l|}",
  "ficom{l||l|}",
  "ficomp{l||l|}",
  "fisub{l||l|}",
  "fisubr{l||l|}",
  "fidiv{l||l|}",
  "fidivr{l||l|}",
  /* db */
  "fild{l||l|}",
  "fisttp{l||l|}",
  "fist{l||l|}",
  "fistp{l||l|}",
  "(bad)",
  "fld{t||t|}",
  "(bad)",
  "fstp{t||t|}",
  /* dc */
  "fadd{l||l|}",
  "fmul{l||l|}",
  "fcom{l||l|}",
  "fcomp{l||l|}",
  "fsub{l||l|}",
  "fsubr{l||l|}",
  "fdiv{l||l|}",
  "fdivr{l||l|}",
  /* dd */
  "fld{l||l|}",
  "fisttpll",
  "fst{l||l|}",
  "fstp{l||l|}",
  "frstor",
  "(bad)",
  "fNsave",
  "fNstsw",
  /* de */
  "fiadd",
  "fimul",
  "ficom",
  "ficomp",
  "fisub",
  "fisubr",
  "fidiv",
  "fidivr",
  /* df */
  "fild",
  "fisttp",
  "fist",
  "fistp",
  "fbld",
  "fild{ll||ll|}",
  "fbstp",
  "fistpll",
};

#define ST OP_ST, 0
#define STi OP_STi, 0

#define FGRPd9_2 NULL, NULL, 0, NULL, 0, NULL, 0
#define FGRPd9_4 NULL, NULL, 1, NULL, 0, NULL, 0
#define FGRPd9_5 NULL, NULL, 2, NULL, 0, NULL, 0
#define FGRPd9_6 NULL, NULL, 3, NULL, 0, NULL, 0
#define FGRPd9_7 NULL, NULL, 4, NULL, 0, NULL, 0
#define FGRPda_5 NULL, NULL, 5, NULL, 0, NULL, 0
#define FGRPdb_4 NULL, NULL, 6, NULL, 0, NULL, 0
#define FGRPde_3 NULL, NULL, 7, NULL, 0, NULL, 0
#define FGRPdf_4 NULL, NULL, 8, NULL, 0, NULL, 0

static const struct dis386 float_reg[][8] = {
  /* d8 */
  {
    { "fadd",	ST, STi, XX },
    { "fmul",	ST, STi, XX },
    { "fcom",	STi, XX, XX },
    { "fcomp",	STi, XX, XX },
    { "fsub",	ST, STi, XX },
    { "fsubr",	ST, STi, XX },
    { "fdiv",	ST, STi, XX },
    { "fdivr",	ST, STi, XX },
  },
  /* d9 */
  {
    { "fld",	STi, XX, XX },
    { "fxch",	STi, XX, XX },
    { FGRPd9_2 },
    { "(bad)",	XX, XX, XX },
    { FGRPd9_4 },
    { FGRPd9_5 },
    { FGRPd9_6 },
    { FGRPd9_7 },
  },
  /* da */
  {
    { "fcmovb",	ST, STi, XX },
    { "fcmove",	ST, STi, XX },
    { "fcmovbe",ST, STi, XX },
    { "fcmovu",	ST, STi, XX },
    { "(bad)",	XX, XX, XX },
    { FGRPda_5 },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
  },
  /* db */
  {
    { "fcmovnb",ST, STi, XX },
    { "fcmovne",ST, STi, XX },
    { "fcmovnbe",ST, STi, XX },
    { "fcmovnu",ST, STi, XX },
    { FGRPdb_4 },
    { "fucomi",	ST, STi, XX },
    { "fcomi",	ST, STi, XX },
    { "(bad)",	XX, XX, XX },
  },
  /* dc */
  {
    { "fadd",	STi, ST, XX },
    { "fmul",	STi, ST, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
#if UNIXWARE_COMPAT
    { "fsub",	STi, ST, XX },
    { "fsubr",	STi, ST, XX },
    { "fdiv",	STi, ST, XX },
    { "fdivr",	STi, ST, XX },
#else
    { "fsubr",	STi, ST, XX },
    { "fsub",	STi, ST, XX },
    { "fdivr",	STi, ST, XX },
    { "fdiv",	STi, ST, XX },
#endif
  },
  /* dd */
  {
    { "ffree",	STi, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "fst",	STi, XX, XX },
    { "fstp",	STi, XX, XX },
    { "fucom",	STi, XX, XX },
    { "fucomp",	STi, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
  },
  /* de */
  {
    { "faddp",	STi, ST, XX },
    { "fmulp",	STi, ST, XX },
    { "(bad)",	XX, XX, XX },
    { FGRPde_3 },
#if UNIXWARE_COMPAT
    { "fsubp",	STi, ST, XX },
    { "fsubrp",	STi, ST, XX },
    { "fdivp",	STi, ST, XX },
    { "fdivrp",	STi, ST, XX },
#else
    { "fsubrp",	STi, ST, XX },
    { "fsubp",	STi, ST, XX },
    { "fdivrp",	STi, ST, XX },
    { "fdivp",	STi, ST, XX },
#endif
  },
  /* df */
  {
    { "ffreep",	STi, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { FGRPdf_4 },
    { "fucomip",ST, STi, XX },
    { "fcomip", ST, STi, XX },
    { "(bad)",	XX, XX, XX },
  },
};

static char *fgrps[][8] = {
  /* d9_2  0 */
  {
    "fnop","(bad)","(bad)","(bad)","(bad)","(bad)","(bad)","(bad)",
  },

  /* d9_4  1 */
  {
    "fchs","fabs","(bad)","(bad)","ftst","fxam","(bad)","(bad)",
  },

  /* d9_5  2 */
  {
    "fld1","fldl2t","fldl2e","fldpi","fldlg2","fldln2","fldz","(bad)",
  },

  /* d9_6  3 */
  {
    "f2xm1","fyl2x","fptan","fpatan","fxtract","fprem1","fdecstp","fincstp",
  },

  /* d9_7  4 */
  {
    "fprem","fyl2xp1","fsqrt","fsincos","frndint","fscale","fsin","fcos",
  },

  /* da_5  5 */
  {
    "(bad)","fucompp","(bad)","(bad)","(bad)","(bad)","(bad)","(bad)",
  },

  /* db_4  6 */
  {
    "feni(287 only)","fdisi(287 only)","fNclex","fNinit",
    "fNsetpm(287 only)","(bad)","(bad)","(bad)",
  },

  /* de_3  7 */
  {
    "(bad)","fcompp","(bad)","(bad)","(bad)","(bad)","(bad)","(bad)",
  },

  /* df_4  8 */
  {
    "fNstsw","(bad)","(bad)","(bad)","(bad)","(bad)","(bad)","(bad)",
  },
};

static void
dofloat (int sizeflag)
{
  const struct dis386 *dp;
  unsigned char floatop;

  floatop = codep[-1];

  if (mod != 3)
    {
      putop (float_mem[(floatop - 0xd8) * 8 + reg], sizeflag);
      obufp = op1out;
      if (floatop == 0xdb)
	OP_E (x_mode, sizeflag);
      else if (floatop == 0xdd)
	OP_E (d_mode, sizeflag);
      else
	OP_E (v_mode, sizeflag);
      return;
    }
  /* Skip mod/rm byte.  */
  MODRM_CHECK;
  codep++;

  dp = &float_reg[floatop - 0xd8][reg];
  if (dp->name == NULL)
    {
      putop (fgrps[dp->bytemode1][rm], sizeflag);

      /* Instruction fnstsw is only one with strange arg.  */
      if (floatop == 0xdf && codep[-1] == 0xe0)
	strcpy (op1out, names16[0]);
    }
  else
    {
      putop (dp->name, sizeflag);

      obufp = op1out;
      if (dp->op1)
	(*dp->op1) (dp->bytemode1, sizeflag);
      obufp = op2out;
      if (dp->op2)
	(*dp->op2) (dp->bytemode2, sizeflag);
    }
}

static void
OP_ST (int bytemode ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
{
  oappend ("%st");
}

static void
OP_STi (int bytemode ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
{
  sprintf (scratchbuf, "%%st(%d)", rm);
  oappend (scratchbuf + intel_syntax);
}

/* Capital letters in template are macros.  */
static int
putop (const char *template, int sizeflag)
{
  const char *p;
  int alt;

  for (p = template; *p; p++)
    {
      switch (*p)
	{
	default:
	  *obufp++ = *p;
	  break;
	case '{':
	  alt = 0;
	  if (intel_syntax)
	    alt += 1;
	  if (mode_64bit)
	    alt += 2;
	  while (alt != 0)
	    {
	      while (*++p != '|')
		{
		  if (*p == '}')
		    {
		      /* Alternative not valid.  */
		      strcpy (obuf, "(bad)");
		      obufp = obuf + 5;
		      return 1;
		    }
		  else if (*p == '\0')
		    abort ();
		}
	      alt--;
	    }
	  break;
	case '|':
	  while (*++p != '}')
	    {
	      if (*p == '\0')
		abort ();
	    }
	  break;
	case '}':
	  break;
	case 'A':
	  if (intel_syntax)
	    break;
	  if (mod != 3 || (sizeflag & SUFFIX_ALWAYS))
	    *obufp++ = 'b';
	  break;
	case 'B':
	  if (intel_syntax)
	    break;
	  if (sizeflag & SUFFIX_ALWAYS)
	    *obufp++ = 'b';
	  break;
	case 'E':		/* For jcxz/jecxz */
	  if (mode_64bit)
	    {
	      if (sizeflag & AFLAG)
		*obufp++ = 'r';
	      else
		*obufp++ = 'e';
	    }
	  else
	    if (sizeflag & AFLAG)
	      *obufp++ = 'e';
	  used_prefixes |= (prefixes & PREFIX_ADDR);
	  break;
	case 'F':
	  if (intel_syntax)
	    break;
	  if ((prefixes & PREFIX_ADDR) || (sizeflag & SUFFIX_ALWAYS))
	    {
	      if (sizeflag & AFLAG)
		*obufp++ = mode_64bit ? 'q' : 'l';
	      else
		*obufp++ = mode_64bit ? 'l' : 'w';
	      used_prefixes |= (prefixes & PREFIX_ADDR);
	    }
	  break;
	case 'H':
	  if (intel_syntax)
	    break;
	  if ((prefixes & (PREFIX_CS | PREFIX_DS)) == PREFIX_CS
	      || (prefixes & (PREFIX_CS | PREFIX_DS)) == PREFIX_DS)
	    {
	      used_prefixes |= prefixes & (PREFIX_CS | PREFIX_DS);
	      *obufp++ = ',';
	      *obufp++ = 'p';
	      if (prefixes & PREFIX_DS)
		*obufp++ = 't';
	      else
		*obufp++ = 'n';
	    }
	  break;
	case 'L':
	  if (intel_syntax)
	    break;
	  if (sizeflag & SUFFIX_ALWAYS)
	    *obufp++ = 'l';
	  break;
	case 'N':
	  if ((prefixes & PREFIX_FWAIT) == 0)
	    *obufp++ = 'n';
	  else
	    used_prefixes |= PREFIX_FWAIT;
	  break;
	case 'O':
	  USED_REX (REX_MODE64);
	  if (rex & REX_MODE64)
	    *obufp++ = 'o';
	  else
	    *obufp++ = 'd';
	  break;
	case 'T':
	  if (intel_syntax)
	    break;
	  if (mode_64bit)
	    {
	      *obufp++ = 'q';
	      break;
	    }
	  /* Fall through.  */
	case 'P':
	  if (intel_syntax)
	    break;
	  if ((prefixes & PREFIX_DATA)
	      || (rex & REX_MODE64)
	      || (sizeflag & SUFFIX_ALWAYS))
	    {
	      USED_REX (REX_MODE64);
	      if (rex & REX_MODE64)
		*obufp++ = 'q';
	      else
		{
		   if (sizeflag & DFLAG)
		      *obufp++ = 'l';
		   else
		     *obufp++ = 'w';
		   used_prefixes |= (prefixes & PREFIX_DATA);
		}
	    }
	  break;
	case 'U':
	  if (intel_syntax)
	    break;
	  if (mode_64bit)
	    {
	      *obufp++ = 'q';
	      break;
	    }
	  /* Fall through.  */
	case 'Q':
	  if (intel_syntax)
	    break;
	  USED_REX (REX_MODE64);
	  if (mod != 3 || (sizeflag & SUFFIX_ALWAYS))
	    {
	      if (rex & REX_MODE64)
		*obufp++ = 'q';
	      else
		{
		  if (sizeflag & DFLAG)
		    *obufp++ = 'l';
		  else
		    *obufp++ = 'w';
		  used_prefixes |= (prefixes & PREFIX_DATA);
		}
	    }
	  break;
	case 'R':
	  USED_REX (REX_MODE64);
	  if (intel_syntax)
	    {
	      if (rex & REX_MODE64)
		{
		  *obufp++ = 'q';
		  *obufp++ = 't';
		}
	      else if (sizeflag & DFLAG)
		{
		  *obufp++ = 'd';
		  *obufp++ = 'q';
		}
	      else
		{
		  *obufp++ = 'w';
		  *obufp++ = 'd';
		}
	    }
	  else
	    {
	      if (rex & REX_MODE64)
		*obufp++ = 'q';
	      else if (sizeflag & DFLAG)
		*obufp++ = 'l';
	      else
		*obufp++ = 'w';
	    }
	  if (!(rex & REX_MODE64))
	    used_prefixes |= (prefixes & PREFIX_DATA);
	  break;
	case 'S':
	  if (intel_syntax)
	    break;
	  if (sizeflag & SUFFIX_ALWAYS)
	    {
	      if (rex & REX_MODE64)
		*obufp++ = 'q';
	      else
		{
		  if (sizeflag & DFLAG)
		    *obufp++ = 'l';
		  else
		    *obufp++ = 'w';
		  used_prefixes |= (prefixes & PREFIX_DATA);
		}
	    }
	  break;
	case 'X':
	  if (prefixes & PREFIX_DATA)
	    *obufp++ = 'd';
	  else
	    *obufp++ = 's';
	  used_prefixes |= (prefixes & PREFIX_DATA);
	  break;
	case 'Y':
	  if (intel_syntax)
	    break;
	  if (rex & REX_MODE64)
	    {
	      USED_REX (REX_MODE64);
	      *obufp++ = 'q';
	    }
	  break;
	  /* implicit operand size 'l' for i386 or 'q' for x86-64 */
	case 'W':
	  /* operand size flag for cwtl, cbtw */
	  USED_REX (0);
	  if (rex)
	    *obufp++ = 'l';
	  else if (sizeflag & DFLAG)
	    *obufp++ = 'w';
	  else
	    *obufp++ = 'b';
	  if (intel_syntax)
	    {
	      if (rex)
		{
		  *obufp++ = 'q';
		  *obufp++ = 'e';
		}
	      if (sizeflag & DFLAG)
		{
		  *obufp++ = 'd';
		  *obufp++ = 'e';
		}
	      else
		{
		  *obufp++ = 'w';
		}
	    }
	  if (!rex)
	    used_prefixes |= (prefixes & PREFIX_DATA);
	  break;
	}
    }
  *obufp = 0;
  return 0;
}

static void
oappend (const char *s)
{
  strcpy (obufp, s);
  obufp += strlen (s);
}

static void
append_seg (void)
{
  if (prefixes & PREFIX_CS)
    {
      used_prefixes |= PREFIX_CS;
      oappend ("%cs:" + intel_syntax);
    }
  if (prefixes & PREFIX_DS)
    {
      used_prefixes |= PREFIX_DS;
      oappend ("%ds:" + intel_syntax);
    }
  if (prefixes & PREFIX_SS)
    {
      used_prefixes |= PREFIX_SS;
      oappend ("%ss:" + intel_syntax);
    }
  if (prefixes & PREFIX_ES)
    {
      used_prefixes |= PREFIX_ES;
      oappend ("%es:" + intel_syntax);
    }
  if (prefixes & PREFIX_FS)
    {
      used_prefixes |= PREFIX_FS;
      oappend ("%fs:" + intel_syntax);
    }
  if (prefixes & PREFIX_GS)
    {
      used_prefixes |= PREFIX_GS;
      oappend ("%gs:" + intel_syntax);
    }
}

static void
OP_indirE (int bytemode, int sizeflag)
{
  if (!intel_syntax)
    oappend ("*");
  OP_E (bytemode, sizeflag);
}

static void
print_operand_value (char *buf, int hex, bfd_vma disp)
{
  if (mode_64bit)
    {
      if (hex)
	{
	  char tmp[30];
	  int i;
	  buf[0] = '0';
	  buf[1] = 'x';
	  sprintf_vma (tmp, disp);
	  for (i = 0; tmp[i] == '0' && tmp[i + 1]; i++);
	  strcpy (buf + 2, tmp + i);
	}
      else
	{
	  bfd_signed_vma v = disp;
	  char tmp[30];
	  int i;
	  if (v < 0)
	    {
	      *(buf++) = '-';
	      v = -disp;
	      /* Check for possible overflow on 0x8000000000000000.  */
	      if (v < 0)
		{
		  strcpy (buf, "9223372036854775808");
		  return;
		}
	    }
	  if (!v)
	    {
	      strcpy (buf, "0");
	      return;
	    }

	  i = 0;
	  tmp[29] = 0;
	  while (v)
	    {
	      tmp[28 - i] = (v % 10) + '0';
	      v /= 10;
	      i++;
	    }
	  strcpy (buf, tmp + 29 - i);
	}
    }
  else
    {
      if (hex)
	sprintf (buf, "0x%x", (unsigned int) disp);
      else
	sprintf (buf, "%d", (int) disp);
    }
}

static void
OP_E (int bytemode, int sizeflag)
{
  bfd_vma disp;
  int add = 0;
  int riprel = 0;
  USED_REX (REX_EXTZ);
  if (rex & REX_EXTZ)
    add += 8;

  /* Skip mod/rm byte.  */
  MODRM_CHECK;
  codep++;

  if (mod == 3)
    {
      switch (bytemode)
	{
	case b_mode:
	  USED_REX (0);
	  if (rex)
	    oappend (names8rex[rm + add]);
	  else
	    oappend (names8[rm + add]);
	  break;
	case w_mode:
	  oappend (names16[rm + add]);
	  break;
	case d_mode:
	  oappend (names32[rm + add]);
	  break;
	case q_mode:
	  oappend (names64[rm + add]);
	  break;
	case m_mode:
	  if (mode_64bit)
	    oappend (names64[rm + add]);
	  else
	    oappend (names32[rm + add]);
	  break;
	case v_mode:
	case dq_mode:
	  USED_REX (REX_MODE64);
	  if (rex & REX_MODE64)
	    oappend (names64[rm + add]);
	  else if ((sizeflag & DFLAG) || bytemode == dq_mode)
	    oappend (names32[rm + add]);
	  else
	    oappend (names16[rm + add]);
	  used_prefixes |= (prefixes & PREFIX_DATA);
	  break;
	case 0:
	  break;
	default:
	  oappend (INTERNAL_DISASSEMBLER_ERROR);
	  break;
	}
      return;
    }

  disp = 0;
  append_seg ();

  if ((sizeflag & AFLAG) || mode_64bit) /* 32 bit address mode */
    {
      int havesib;
      int havebase;
      int base;
      int index = 0;
      int scale = 0;

      havesib = 0;
      havebase = 1;
      base = rm;

      if (base == 4)
	{
	  havesib = 1;
	  FETCH_DATA (the_info, codep + 1);
	  scale = (*codep >> 6) & 3;
	  index = (*codep >> 3) & 7;
	  base = *codep & 7;
	  USED_REX (REX_EXTY);
	  USED_REX (REX_EXTZ);
	  if (rex & REX_EXTY)
	    index += 8;
	  if (rex & REX_EXTZ)
	    base += 8;
	  codep++;
	}

      switch (mod)
	{
	case 0:
	  if ((base & 7) == 5)
	    {
	      havebase = 0;
	      if (mode_64bit && !havesib && (sizeflag & AFLAG))
		riprel = 1;
	      disp = get32s ();
	    }
	  break;
	case 1:
	  FETCH_DATA (the_info, codep + 1);
	  disp = *codep++;
	  if ((disp & 0x80) != 0)
	    disp -= 0x100;
	  break;
	case 2:
	  disp = get32s ();
	  break;
	}

      if (!intel_syntax)
	if (mod != 0 || (base & 7) == 5)
	  {
	    print_operand_value (scratchbuf, !riprel, disp);
	    oappend (scratchbuf);
	    if (riprel)
	      {
		set_op (disp, 1);
		oappend ("(%rip)");
	      }
	  }

      if (havebase || (havesib && (index != 4 || scale != 0)))
	{
	  if (intel_syntax)
	    {
	      switch (bytemode)
		{
		case b_mode:
		  oappend ("BYTE PTR ");
		  break;
		case w_mode:
		  oappend ("WORD PTR ");
		  break;
		case v_mode:
		  oappend ("DWORD PTR ");
		  break;
		case d_mode:
		  oappend ("QWORD PTR ");
		  break;
		case m_mode:
		  if (mode_64bit)
		    oappend ("DWORD PTR ");
		  else
		    oappend ("QWORD PTR ");
		  break;
		case x_mode:
		  oappend ("XWORD PTR ");
		  break;
		default:
		  break;
		}
	     }
	  *obufp++ = open_char;
	  if (intel_syntax && riprel)
	    oappend ("rip + ");
	  *obufp = '\0';
	  USED_REX (REX_EXTZ);
	  if (!havesib && (rex & REX_EXTZ))
	    base += 8;
	  if (havebase)
	    oappend (mode_64bit && (sizeflag & AFLAG)
		     ? names64[base] : names32[base]);
	  if (havesib)
	    {
	      if (index != 4)
		{
		  if (intel_syntax)
		    {
		      if (havebase)
			{
			  *obufp++ = separator_char;
			  *obufp = '\0';
			}
		      sprintf (scratchbuf, "%s",
			       mode_64bit && (sizeflag & AFLAG)
			       ? names64[index] : names32[index]);
		    }
		  else
		    sprintf (scratchbuf, ",%s",
			     mode_64bit && (sizeflag & AFLAG)
			     ? names64[index] : names32[index]);
		  oappend (scratchbuf);
		}
	      if (scale != 0 || (!intel_syntax && index != 4))
		{
		  *obufp++ = scale_char;
		  *obufp = '\0';
		  sprintf (scratchbuf, "%d", 1 << scale);
		  oappend (scratchbuf);
		}
	    }
	  if (intel_syntax)
	    if (mod != 0 || (base & 7) == 5)
	      {
		/* Don't print zero displacements.  */
		if (disp != 0)
		  {
		    if ((bfd_signed_vma) disp > 0)
		      {
			*obufp++ = '+';
			*obufp = '\0';
		      }

		    print_operand_value (scratchbuf, 0, disp);
		    oappend (scratchbuf);
		  }
	      }

	  *obufp++ = close_char;
	  *obufp = '\0';
	}
      else if (intel_syntax)
	{
	  if (mod != 0 || (base & 7) == 5)
	    {
	      if (prefixes & (PREFIX_CS | PREFIX_SS | PREFIX_DS
			      | PREFIX_ES | PREFIX_FS | PREFIX_GS))
		;
	      else
		{
		  oappend (names_seg[ds_reg - es_reg]);
		  oappend (":");
		}
	      print_operand_value (scratchbuf, 1, disp);
	      oappend (scratchbuf);
	    }
	}
    }
  else
    { /* 16 bit address mode */
      switch (mod)
	{
	case 0:
	  if ((rm & 7) == 6)
	    {
	      disp = get16 ();
	      if ((disp & 0x8000) != 0)
		disp -= 0x10000;
	    }
	  break;
	case 1:
	  FETCH_DATA (the_info, codep + 1);
	  disp = *codep++;
	  if ((disp & 0x80) != 0)
	    disp -= 0x100;
	  break;
	case 2:
	  disp = get16 ();
	  if ((disp & 0x8000) != 0)
	    disp -= 0x10000;
	  break;
	}

      if (!intel_syntax)
	if (mod != 0 || (rm & 7) == 6)
	  {
	    print_operand_value (scratchbuf, 0, disp);
	    oappend (scratchbuf);
	  }

      if (mod != 0 || (rm & 7) != 6)
	{
	  *obufp++ = open_char;
	  *obufp = '\0';
	  oappend (index16[rm + add]);
	  *obufp++ = close_char;
	  *obufp = '\0';
	}
    }
}

static void
OP_G (int bytemode, int sizeflag)
{
  int add = 0;
  USED_REX (REX_EXTX);
  if (rex & REX_EXTX)
    add += 8;
  switch (bytemode)
    {
    case b_mode:
      USED_REX (0);
      if (rex)
	oappend (names8rex[reg + add]);
      else
	oappend (names8[reg + add]);
      break;
    case w_mode:
      oappend (names16[reg + add]);
      break;
    case d_mode:
      oappend (names32[reg + add]);
      break;
    case q_mode:
      oappend (names64[reg + add]);
      break;
    case v_mode:
      USED_REX (REX_MODE64);
      if (rex & REX_MODE64)
	oappend (names64[reg + add]);
      else if (sizeflag & DFLAG)
	oappend (names32[reg + add]);
      else
	oappend (names16[reg + add]);
      used_prefixes |= (prefixes & PREFIX_DATA);
      break;
    default:
      oappend (INTERNAL_DISASSEMBLER_ERROR);
      break;
    }
}

static bfd_vma
get64 (void)
{
  bfd_vma x;
#ifdef BFD64
  unsigned int a;
  unsigned int b;

  FETCH_DATA (the_info, codep + 8);
  a = *codep++ & 0xff;
  a |= (*codep++ & 0xff) << 8;
  a |= (*codep++ & 0xff) << 16;
  a |= (*codep++ & 0xff) << 24;
  b = *codep++ & 0xff;
  b |= (*codep++ & 0xff) << 8;
  b |= (*codep++ & 0xff) << 16;
  b |= (*codep++ & 0xff) << 24;
  x = a + ((bfd_vma) b << 32);
#else
  abort ();
  x = 0;
#endif
  return x;
}

static bfd_signed_vma
get32 (void)
{
  bfd_signed_vma x = 0;

  FETCH_DATA (the_info, codep + 4);
  x = *codep++ & (bfd_signed_vma) 0xff;
  x |= (*codep++ & (bfd_signed_vma) 0xff) << 8;
  x |= (*codep++ & (bfd_signed_vma) 0xff) << 16;
  x |= (*codep++ & (bfd_signed_vma) 0xff) << 24;
  return x;
}

static bfd_signed_vma
get32s (void)
{
  bfd_signed_vma x = 0;

  FETCH_DATA (the_info, codep + 4);
  x = *codep++ & (bfd_signed_vma) 0xff;
  x |= (*codep++ & (bfd_signed_vma) 0xff) << 8;
  x |= (*codep++ & (bfd_signed_vma) 0xff) << 16;
  x |= (*codep++ & (bfd_signed_vma) 0xff) << 24;

  x = (x ^ ((bfd_signed_vma) 1 << 31)) - ((bfd_signed_vma) 1 << 31);

  return x;
}

static int
get16 (void)
{
  int x = 0;

  FETCH_DATA (the_info, codep + 2);
  x = *codep++ & 0xff;
  x |= (*codep++ & 0xff) << 8;
  return x;
}

static void
set_op (bfd_vma op, int riprel)
{
  op_index[op_ad] = op_ad;
  if (mode_64bit)
    {
      op_address[op_ad] = op;
      op_riprel[op_ad] = riprel;
    }
  else
    {
      /* Mask to get a 32-bit address.  */
      op_address[op_ad] = op & 0xffffffff;
      op_riprel[op_ad] = riprel & 0xffffffff;
    }
}

static void
OP_REG (int code, int sizeflag)
{
  const char *s;
  int add = 0;
  USED_REX (REX_EXTZ);
  if (rex & REX_EXTZ)
    add = 8;

  switch (code)
    {
    case indir_dx_reg:
      if (intel_syntax)
	s = "[dx]";
      else
	s = "(%dx)";
      break;
    case ax_reg: case cx_reg: case dx_reg: case bx_reg:
    case sp_reg: case bp_reg: case si_reg: case di_reg:
      s = names16[code - ax_reg + add];
      break;
    case es_reg: case ss_reg: case cs_reg:
    case ds_reg: case fs_reg: case gs_reg:
      s = names_seg[code - es_reg + add];
      break;
    case al_reg: case ah_reg: case cl_reg: case ch_reg:
    case dl_reg: case dh_reg: case bl_reg: case bh_reg:
      USED_REX (0);
      if (rex)
	s = names8rex[code - al_reg + add];
      else
	s = names8[code - al_reg];
      break;
    case rAX_reg: case rCX_reg: case rDX_reg: case rBX_reg:
    case rSP_reg: case rBP_reg: case rSI_reg: case rDI_reg:
      if (mode_64bit)
	{
	  s = names64[code - rAX_reg + add];
	  break;
	}
      code += eAX_reg - rAX_reg;
      /* Fall through.  */
    case eAX_reg: case eCX_reg: case eDX_reg: case eBX_reg:
    case eSP_reg: case eBP_reg: case eSI_reg: case eDI_reg:
      USED_REX (REX_MODE64);
      if (rex & REX_MODE64)
	s = names64[code - eAX_reg + add];
      else if (sizeflag & DFLAG)
	s = names32[code - eAX_reg + add];
      else
	s = names16[code - eAX_reg + add];
      used_prefixes |= (prefixes & PREFIX_DATA);
      break;
    default:
      s = INTERNAL_DISASSEMBLER_ERROR;
      break;
    }
  oappend (s);
}

static void
OP_IMREG (int code, int sizeflag)
{
  const char *s;

  switch (code)
    {
    case indir_dx_reg:
      if (intel_syntax)
	s = "[dx]";
      else
	s = "(%dx)";
      break;
    case ax_reg: case cx_reg: case dx_reg: case bx_reg:
    case sp_reg: case bp_reg: case si_reg: case di_reg:
      s = names16[code - ax_reg];
      break;
    case es_reg: case ss_reg: case cs_reg:
    case ds_reg: case fs_reg: case gs_reg:
      s = names_seg[code - es_reg];
      break;
    case al_reg: case ah_reg: case cl_reg: case ch_reg:
    case dl_reg: case dh_reg: case bl_reg: case bh_reg:
      USED_REX (0);
      if (rex)
	s = names8rex[code - al_reg];
      else
	s = names8[code - al_reg];
      break;
    case eAX_reg: case eCX_reg: case eDX_reg: case eBX_reg:
    case eSP_reg: case eBP_reg: case eSI_reg: case eDI_reg:
      USED_REX (REX_MODE64);
      if (rex & REX_MODE64)
	s = names64[code - eAX_reg];
      else if (sizeflag & DFLAG)
	s = names32[code - eAX_reg];
      else
	s = names16[code - eAX_reg];
      used_prefixes |= (prefixes & PREFIX_DATA);
      break;
    default:
      s = INTERNAL_DISASSEMBLER_ERROR;
      break;
    }
  oappend (s);
}

static void
OP_I (int bytemode, int sizeflag)
{
  bfd_signed_vma op;
  bfd_signed_vma mask = -1;

  switch (bytemode)
    {
    case b_mode:
      FETCH_DATA (the_info, codep + 1);
      op = *codep++;
      mask = 0xff;
      break;
    case q_mode:
      if (mode_64bit)
	{
	  op = get32s ();
	  break;
	}
      /* Fall through.  */
    case v_mode:
      USED_REX (REX_MODE64);
      if (rex & REX_MODE64)
	op = get32s ();
      else if (sizeflag & DFLAG)
	{
	  op = get32 ();
	  mask = 0xffffffff;
	}
      else
	{
	  op = get16 ();
	  mask = 0xfffff;
	}
      used_prefixes |= (prefixes & PREFIX_DATA);
      break;
    case w_mode:
      mask = 0xfffff;
      op = get16 ();
      break;
    default:
      oappend (INTERNAL_DISASSEMBLER_ERROR);
      return;
    }

  op &= mask;
  scratchbuf[0] = '$';
  print_operand_value (scratchbuf + 1, 1, op);
  oappend (scratchbuf + intel_syntax);
  scratchbuf[0] = '\0';
}

static void
OP_I64 (int bytemode, int sizeflag)
{
  bfd_signed_vma op;
  bfd_signed_vma mask = -1;

  if (!mode_64bit)
    {
      OP_I (bytemode, sizeflag);
      return;
    }

  switch (bytemode)
    {
    case b_mode:
      FETCH_DATA (the_info, codep + 1);
      op = *codep++;
      mask = 0xff;
      break;
    case v_mode:
      USED_REX (REX_MODE64);
      if (rex & REX_MODE64)
	op = get64 ();
      else if (sizeflag & DFLAG)
	{
	  op = get32 ();
	  mask = 0xffffffff;
	}
      else
	{
	  op = get16 ();
	  mask = 0xfffff;
	}
      used_prefixes |= (prefixes & PREFIX_DATA);
      break;
    case w_mode:
      mask = 0xfffff;
      op = get16 ();
      break;
    default:
      oappend (INTERNAL_DISASSEMBLER_ERROR);
      return;
    }

  op &= mask;
  scratchbuf[0] = '$';
  print_operand_value (scratchbuf + 1, 1, op);
  oappend (scratchbuf + intel_syntax);
  scratchbuf[0] = '\0';
}

static void
OP_sI (int bytemode, int sizeflag)
{
  bfd_signed_vma op;
  bfd_signed_vma mask = -1;

  switch (bytemode)
    {
    case b_mode:
      FETCH_DATA (the_info, codep + 1);
      op = *codep++;
      if ((op & 0x80) != 0)
	op -= 0x100;
      mask = 0xffffffff;
      break;
    case v_mode:
      USED_REX (REX_MODE64);
      if (rex & REX_MODE64)
	op = get32s ();
      else if (sizeflag & DFLAG)
	{
	  op = get32s ();
	  mask = 0xffffffff;
	}
      else
	{
	  mask = 0xffffffff;
	  op = get16 ();
	  if ((op & 0x8000) != 0)
	    op -= 0x10000;
	}
      used_prefixes |= (prefixes & PREFIX_DATA);
      break;
    case w_mode:
      op = get16 ();
      mask = 0xffffffff;
      if ((op & 0x8000) != 0)
	op -= 0x10000;
      break;
    default:
      oappend (INTERNAL_DISASSEMBLER_ERROR);
      return;
    }

  scratchbuf[0] = '$';
  print_operand_value (scratchbuf + 1, 1, op);
  oappend (scratchbuf + intel_syntax);
}

static void
OP_J (int bytemode, int sizeflag)
{
  bfd_vma disp;
  bfd_vma mask = -1;

  switch (bytemode)
    {
    case b_mode:
      FETCH_DATA (the_info, codep + 1);
      disp = *codep++;
      if ((disp & 0x80) != 0)
	disp -= 0x100;
      break;
    case v_mode:
      if (sizeflag & DFLAG)
	disp = get32s ();
      else
	{
	  disp = get16 ();
	  /* For some reason, a data16 prefix on a jump instruction
	     means that the pc is masked to 16 bits after the
	     displacement is added!  */
	  mask = 0xffff;
	}
      break;
    default:
      oappend (INTERNAL_DISASSEMBLER_ERROR);
      return;
    }
  disp = (start_pc + codep - start_codep + disp) & mask;
  set_op (disp, 0);
  print_operand_value (scratchbuf, 1, disp);
  oappend (scratchbuf);
}

static void
OP_SEG (int dummy ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
{
  oappend (names_seg[reg]);
}

static void
OP_DIR (int dummy ATTRIBUTE_UNUSED, int sizeflag)
{
  int seg, offset;

  if (sizeflag & DFLAG)
    {
      offset = get32 ();
      seg = get16 ();
    }
  else
    {
      offset = get16 ();
      seg = get16 ();
    }
  used_prefixes |= (prefixes & PREFIX_DATA);
  if (intel_syntax)
    sprintf (scratchbuf, "0x%x,0x%x", seg, offset);
  else
    sprintf (scratchbuf, "$0x%x,$0x%x", seg, offset);
  oappend (scratchbuf);
}

static void
OP_OFF (int bytemode ATTRIBUTE_UNUSED, int sizeflag)
{
  bfd_vma off;

  append_seg ();

  if ((sizeflag & AFLAG) || mode_64bit)
    off = get32 ();
  else
    off = get16 ();

  if (intel_syntax)
    {
      if (!(prefixes & (PREFIX_CS | PREFIX_SS | PREFIX_DS
			| PREFIX_ES | PREFIX_FS | PREFIX_GS)))
	{
	  oappend (names_seg[ds_reg - es_reg]);
	  oappend (":");
	}
    }
  print_operand_value (scratchbuf, 1, off);
  oappend (scratchbuf);
}

static void
OP_OFF64 (int bytemode ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
{
  bfd_vma off;

  if (!mode_64bit)
    {
      OP_OFF (bytemode, sizeflag);
      return;
    }

  append_seg ();

  off = get64 ();

  if (intel_syntax)
    {
      if (!(prefixes & (PREFIX_CS | PREFIX_SS | PREFIX_DS
			| PREFIX_ES | PREFIX_FS | PREFIX_GS)))
	{
	  oappend (names_seg[ds_reg - es_reg]);
	  oappend (":");
	}
    }
  print_operand_value (scratchbuf, 1, off);
  oappend (scratchbuf);
}

static void
ptr_reg (int code, int sizeflag)
{
  const char *s;
  if (intel_syntax)
    oappend ("[");
  else
    oappend ("(");

  USED_REX (REX_MODE64);
  if (rex & REX_MODE64)
    {
      if (!(sizeflag & AFLAG))
	s = names32[code - eAX_reg];
      else
	s = names64[code - eAX_reg];
    }
  else if (sizeflag & AFLAG)
    s = names32[code - eAX_reg];
  else
    s = names16[code - eAX_reg];
  oappend (s);
  if (intel_syntax)
    oappend ("]");
  else
    oappend (")");
}

static void
OP_ESreg (int code, int sizeflag)
{
  oappend ("%es:" + intel_syntax);
  ptr_reg (code, sizeflag);
}

static void
OP_DSreg (int code, int sizeflag)
{
  if ((prefixes
       & (PREFIX_CS
	  | PREFIX_DS
	  | PREFIX_SS
	  | PREFIX_ES
	  | PREFIX_FS
	  | PREFIX_GS)) == 0)
    prefixes |= PREFIX_DS;
  append_seg ();
  ptr_reg (code, sizeflag);
}

static void
OP_C (int dummy ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
{
  int add = 0;
  USED_REX (REX_EXTX);
  if (rex & REX_EXTX)
    add = 8;
  sprintf (scratchbuf, "%%cr%d", reg + add);
  oappend (scratchbuf + intel_syntax);
}

static void
OP_D (int dummy ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
{
  int add = 0;
  USED_REX (REX_EXTX);
  if (rex & REX_EXTX)
    add = 8;
  if (intel_syntax)
    sprintf (scratchbuf, "db%d", reg + add);
  else
    sprintf (scratchbuf, "%%db%d", reg + add);
  oappend (scratchbuf);
}

static void
OP_T (int dummy ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
{
  sprintf (scratchbuf, "%%tr%d", reg);
  oappend (scratchbuf + intel_syntax);
}

static void
OP_Rd (int bytemode, int sizeflag)
{
  if (mod == 3)
    OP_E (bytemode, sizeflag);
  else
    BadOp ();
}

static void
OP_MMX (int bytemode ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
{
  int add = 0;
  USED_REX (REX_EXTX);
  if (rex & REX_EXTX)
    add = 8;
  used_prefixes |= (prefixes & PREFIX_DATA);
  if (prefixes & PREFIX_DATA)
    sprintf (scratchbuf, "%%xmm%d", reg + add);
  else
    sprintf (scratchbuf, "%%mm%d", reg + add);
  oappend (scratchbuf + intel_syntax);
}

static void
OP_XMM (int bytemode ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
{
  int add = 0;
  USED_REX (REX_EXTX);
  if (rex & REX_EXTX)
    add = 8;
  sprintf (scratchbuf, "%%xmm%d", reg + add);
  oappend (scratchbuf + intel_syntax);
}

static void
OP_EM (int bytemode, int sizeflag)
{
  int add = 0;
  if (mod != 3)
    {
      OP_E (bytemode, sizeflag);
      return;
    }
  USED_REX (REX_EXTZ);
  if (rex & REX_EXTZ)
    add = 8;

  /* Skip mod/rm byte.  */
  MODRM_CHECK;
  codep++;
  used_prefixes |= (prefixes & PREFIX_DATA);
  if (prefixes & PREFIX_DATA)
    sprintf (scratchbuf, "%%xmm%d", rm + add);
  else
    sprintf (scratchbuf, "%%mm%d", rm + add);
  oappend (scratchbuf + intel_syntax);
}

static void
OP_EX (int bytemode, int sizeflag)
{
  int add = 0;
  if (mod != 3)
    {
      OP_E (bytemode, sizeflag);
      return;
    }
  USED_REX (REX_EXTZ);
  if (rex & REX_EXTZ)
    add = 8;

  /* Skip mod/rm byte.  */
  MODRM_CHECK;
  codep++;
  sprintf (scratchbuf, "%%xmm%d", rm + add);
  oappend (scratchbuf + intel_syntax);
}

static void
OP_MS (int bytemode, int sizeflag)
{
  if (mod == 3)
    OP_EM (bytemode, sizeflag);
  else
    BadOp ();
}

static void
OP_XS (int bytemode, int sizeflag)
{
  if (mod == 3)
    OP_EX (bytemode, sizeflag);
  else
    BadOp ();
}

static void
OP_M (int bytemode, int sizeflag)
{
  if (mod == 3)
    BadOp ();	/* bad lea,lds,les,lfs,lgs,lss modrm */
  else
    OP_E (bytemode, sizeflag);
}

static void
OP_0fae (int bytemode, int sizeflag)
{
  if (mod == 3)
    {
      if (reg == 7)
	strcpy (obuf + strlen (obuf) - sizeof ("clflush") + 1, "sfence");
      else if (reg == 6)
	strcpy (obuf + strlen (obuf) - sizeof ("xsaveopt") + 1, "mfence");
      else if (reg == 5)
	strcpy (obuf + strlen (obuf) - sizeof ("xrstor") + 1, "lfence");
      bytemode = 0;

      if (reg < 5 || rm != 0)
	{
	  BadOp ();	/* bad sfence, mfence, or lfence */
	  return;
	}
    }
  else if (reg < 5)
    {
      BadOp ();		/* bad sfence, mfence, or lfence */
      return;
    }

  OP_E (bytemode, sizeflag);
}

static void
NOP_Fixup (int bytemode ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
{
  /* NOP with REPZ prefix is called PAUSE.  */
  if (prefixes == PREFIX_REPZ)
    strcpy (obuf, "pause");
}

static const char *const Suffix3DNow[] = {
/* 00 */	NULL,		NULL,		NULL,		NULL,
/* 04 */	NULL,		NULL,		NULL,		NULL,
/* 08 */	NULL,		NULL,		NULL,		NULL,
/* 0C */	"pi2fw",	"pi2fd",	NULL,		NULL,
/* 10 */	NULL,		NULL,		NULL,		NULL,
/* 14 */	NULL,		NULL,		NULL,		NULL,
/* 18 */	NULL,		NULL,		NULL,		NULL,
/* 1C */	"pf2iw",	"pf2id",	NULL,		NULL,
/* 20 */	NULL,		NULL,		NULL,		NULL,
/* 24 */	NULL,		NULL,		NULL,		NULL,
/* 28 */	NULL,		NULL,		NULL,		NULL,
/* 2C */	NULL,		NULL,		NULL,		NULL,
/* 30 */	NULL,		NULL,		NULL,		NULL,
/* 34 */	NULL,		NULL,		NULL,		NULL,
/* 38 */	NULL,		NULL,		NULL,		NULL,
/* 3C */	NULL,		NULL,		NULL,		NULL,
/* 40 */	NULL,		NULL,		NULL,		NULL,
/* 44 */	NULL,		NULL,		NULL,		NULL,
/* 48 */	NULL,		NULL,		NULL,		NULL,
/* 4C */	NULL,		NULL,		NULL,		NULL,
/* 50 */	NULL,		NULL,		NULL,		NULL,
/* 54 */	NULL,		NULL,		NULL,		NULL,
/* 58 */	NULL,		NULL,		NULL,		NULL,
/* 5C */	NULL,		NULL,		NULL,		NULL,
/* 60 */	NULL,		NULL,		NULL,		NULL,
/* 64 */	NULL,		NULL,		NULL,		NULL,
/* 68 */	NULL,		NULL,		NULL,		NULL,
/* 6C */	NULL,		NULL,		NULL,		NULL,
/* 70 */	NULL,		NULL,		NULL,		NULL,
/* 74 */	NULL,		NULL,		NULL,		NULL,
/* 78 */	NULL,		NULL,		NULL,		NULL,
/* 7C */	NULL,		NULL,		NULL,		NULL,
/* 80 */	NULL,		NULL,		NULL,		NULL,
/* 84 */	NULL,		NULL,		NULL,		NULL,
/* 88 */	NULL,		NULL,		"pfnacc",	NULL,
/* 8C */	NULL,		NULL,		"pfpnacc",	NULL,
/* 90 */	"pfcmpge",	NULL,		NULL,		NULL,
/* 94 */	"pfmin",	NULL,		"pfrcp",	"pfrsqrt",
/* 98 */	NULL,		NULL,		"pfsub",	NULL,
/* 9C */	NULL,		NULL,		"pfadd",	NULL,
/* A0 */	"pfcmpgt",	NULL,		NULL,		NULL,
/* A4 */	"pfmax",	NULL,		"pfrcpit1",	"pfrsqit1",
/* A8 */	NULL,		NULL,		"pfsubr",	NULL,
/* AC */	NULL,		NULL,		"pfacc",	NULL,
/* B0 */	"pfcmpeq",	NULL,		NULL,		NULL,
/* B4 */	"pfmul",	NULL,		"pfrcpit2",	"pfmulhrw",
/* B8 */	NULL,		NULL,		NULL,		"pswapd",
/* BC */	NULL,		NULL,		NULL,		"pavgusb",
/* C0 */	NULL,		NULL,		NULL,		NULL,
/* C4 */	NULL,		NULL,		NULL,		NULL,
/* C8 */	NULL,		NULL,		NULL,		NULL,
/* CC */	NULL,		NULL,		NULL,		NULL,
/* D0 */	NULL,		NULL,		NULL,		NULL,
/* D4 */	NULL,		NULL,		NULL,		NULL,
/* D8 */	NULL,		NULL,		NULL,		NULL,
/* DC */	NULL,		NULL,		NULL,		NULL,
/* E0 */	NULL,		NULL,		NULL,		NULL,
/* E4 */	NULL,		NULL,		NULL,		NULL,
/* E8 */	NULL,		NULL,		NULL,		NULL,
/* EC */	NULL,		NULL,		NULL,		NULL,
/* F0 */	NULL,		NULL,		NULL,		NULL,
/* F4 */	NULL,		NULL,		NULL,		NULL,
/* F8 */	NULL,		NULL,		NULL,		NULL,
/* FC */	NULL,		NULL,		NULL,		NULL,
};

static void
OP_3DNowSuffix (int bytemode ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
{
  const char *mnemonic;

  FETCH_DATA (the_info, codep + 1);
  /* AMD 3DNow! instructions are specified by an opcode suffix in the
     place where an 8-bit immediate would normally go.  ie. the last
     byte of the instruction.  */
  obufp = obuf + strlen (obuf);
  mnemonic = Suffix3DNow[*codep++ & 0xff];
  if (mnemonic)
    oappend (mnemonic);
  else
    {
      /* Since a variable sized modrm/sib chunk is between the start
	 of the opcode (0x0f0f) and the opcode suffix, we need to do
	 all the modrm processing first, and don't know until now that
	 we have a bad opcode.  This necessitates some cleaning up.  */
      op1out[0] = '\0';
      op2out[0] = '\0';
      BadOp ();
    }
}

static const char *simd_cmp_op[] = {
  "eq",
  "lt",
  "le",
  "unord",
  "neq",
  "nlt",
  "nle",
  "ord"
};

static void
OP_SIMD_Suffix (int bytemode ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
{
  unsigned int cmp_type;

  FETCH_DATA (the_info, codep + 1);
  obufp = obuf + strlen (obuf);
  cmp_type = *codep++ & 0xff;
  if (cmp_type < 8)
    {
      char suffix1 = 'p', suffix2 = 's';
      used_prefixes |= (prefixes & PREFIX_REPZ);
      if (prefixes & PREFIX_REPZ)
	suffix1 = 's';
      else
	{
	  used_prefixes |= (prefixes & PREFIX_DATA);
	  if (prefixes & PREFIX_DATA)
	    suffix2 = 'd';
	  else
	    {
	      used_prefixes |= (prefixes & PREFIX_REPNZ);
	      if (prefixes & PREFIX_REPNZ)
		suffix1 = 's', suffix2 = 'd';
	    }
	}
      sprintf (scratchbuf, "cmp%s%c%c",
	       simd_cmp_op[cmp_type], suffix1, suffix2);
      used_prefixes |= (prefixes & PREFIX_REPZ);
      oappend (scratchbuf);
    }
  else
    {
      /* We have a bad extension byte.  Clean up.  */
      op1out[0] = '\0';
      op2out[0] = '\0';
      BadOp ();
    }
}

static void
SIMD_Fixup (int extrachar, int sizeflag ATTRIBUTE_UNUSED)
{
  /* Change movlps/movhps to movhlps/movlhps for 2 register operand
     forms of these instructions.  */
  if (mod == 3)
    {
      char *p = obuf + strlen (obuf);
      *(p + 1) = '\0';
      *p       = *(p - 1);
      *(p - 1) = *(p - 2);
      *(p - 2) = *(p - 3);
      *(p - 3) = extrachar;
    }
}

static void
PNI_Fixup (int extrachar ATTRIBUTE_UNUSED, int sizeflag)
{
  if (mod == 3 && reg == 1 && rm <= 1)
    {
      char *p = obuf + strlen (obuf);

      /* Override "sidt".  */
      if (rm)
	{
	  /* mwait %eax,%ecx  */
	  strcpy (p - 4, "mwait   %eax,%ecx");
	}
      else
	{
	  /* monitor %eax,%ecx,%edx"  */
	  strcpy (p - 4, "monitor %eax,%ecx,%edx");
	}

      codep++;
    }
  else if (mod == 3 && reg == 1 && rm <= 3)
    {
      size_t olen = strlen (obuf);
      char *p = obuf + olen - 4;
      if (*codep == 0xca)
        strcpy (p, "clac");
      else if (*codep == 0xcb)
        strcpy (p, "stac");
      codep++;
    }
  else
    OP_E (0, sizeflag);
}

static void
XCR_Fixup (int extrachar ATTRIBUTE_UNUSED, int sizeflag)
{
  if (mod == 3 && reg == 2 && rm <= 1)
    {
      char *p = obuf + strlen (obuf);

      /* Override "lgdt".  */
      if (rm)
	{
	  strcpy (p - 4, "xsetbv");
	}
      else
	{
	  strcpy (p - 4, "xgetbv");
	}

      codep++;
    }
  else
    OP_M (0, sizeflag);
}

static void
INVLPG_Fixup (int bytemode, int sizeflag)
{
  const char *alt;

  switch (*codep)
    {
    case 0xf8:
      alt = "swapgs";
      break;
    case 0xf9:
      alt = "rdtscp";
      break;
    default:
      OP_M (bytemode, sizeflag);
      return;
    }
  /* Override "invlpg".  */
  strcpy (obuf + strlen (obuf) - 6, alt);
  codep++;
}

static struct {
     unsigned char opc;
     char *name;
} xcrypt[] = {
  {  0xc0, "xstore-rng" },
  {  0xc8, "xcrypt-ecb" },
  {  0xd0, "xcrypt-cbc" },
  {  0xd8, "xcrypt-ctr" },
  {  0xe0, "xcrypt-cfb" },
  {  0xe8, "xcrypt-ofb" },
};

static struct {
     unsigned char opc;
     char *name;
} xcrypt2[] = {
  {  0xc0, "montmul" },
  {  0xc8, "xsha1" },
  {  0xd0, "xsha256" },
};

static void
OP_xcrypt (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
{
  const char *mnemonic = NULL;
  unsigned int i;

  FETCH_DATA (the_info, codep + 1);
  /* VIA C3 xcrypt-* & xmove-* instructions are specified by an opcode
     suffix in the place where an 8-bit immediate would normally go.
     ie. the last byte of the instruction.  */
  obufp = obuf + strlen(obuf);

  for (i = 0; i < sizeof(xcrypt) / sizeof(xcrypt[0]); i++)
    if (xcrypt[i].opc == (*codep & 0xff))
      mnemonic = xcrypt[i].name;
  codep++;
  if (mnemonic)
    oappend (mnemonic);
  else
    BadOp();
}

static void
OP_xcrypt2 (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
{
  const char *mnemonic = NULL;
  unsigned int i;

  FETCH_DATA (the_info, codep + 1);
  /* VIA C3 xcrypt2 instructions are specified by an opcode
     suffix in the place where an 8-bit immediate would normally go.
     ie. the last byte of the instruction.  */
  obufp = obuf + strlen(obuf);

  for (i = 0; i < sizeof(xcrypt2) / sizeof(xcrypt2[0]); i++)
    if (xcrypt2[i].opc == (*codep & 0xff))
      mnemonic = xcrypt2[i].name;
  codep++;
  if (mnemonic)
    oappend (mnemonic);
  else
    BadOp();
 }

static struct {
     unsigned char opc;
     char *name;
} aes[] = {
  {  0x00, "pshufb" },
  {  0xdb, "aesimc" },
  {  0xdc, "aesenc" },
  {  0xde, "aesdec" },
  {  0xdd, "aesenclast" },
  {  0xdf, "aesdeclast" }
};

#define XMM_DST(rex, modrm) \
	(((((rex) & ~0x40) & 0x4) ? 8 : 0) | (((modrm) & ~0xc0) >> 3))
#define XMM_SRC(rex, modrm) \
	(((((rex) & ~0x40) & 0x1) ? 8 : 0) | (((modrm) & ~0xc0) & 7))

static void
OP_0f38 (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
{
  const char *mnemonic = NULL;
  unsigned int i;

  FETCH_DATA (the_info, codep + 1);
  obufp = obuf + strlen (obuf);

  for (i = 0; i < sizeof(aes) / sizeof(aes[0]); i++)
    if (aes[i].opc == (*codep & 0xff))
      mnemonic = aes[i].name;

  codep++;
  if (mnemonic)
   {
     oappend (mnemonic);

     FETCH_DATA (the_info, codep + 1);
     sprintf (scratchbuf, " %%xmm%d", XMM_SRC (rex, *codep));
     oappend (scratchbuf);
     sprintf (scratchbuf, ",%%xmm%d", XMM_DST (rex, *codep));
     oappend (scratchbuf);

     codep++;
     used_prefixes |= (prefixes & PREFIX_DATA);
     USED_REX(rex);
   }
  else
    BadOp();
}

static struct {
     unsigned char opc;
     char *name;
} pclmul[] = {
  {  0x00, "pclmullqlqdq" },
  {  0x01, "pclmulhqlqdq" },
  {  0x10, "pclmullqhqdq" },
  {  0x11, "pclmulhqhqdq" },
};

static void
OP_0f3a (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
{
  const char *mnemonic = NULL;
  unsigned int i, xmms;
  unsigned char op, imm;

  FETCH_DATA (the_info, codep + 1);
  obufp = obuf + strlen (obuf);

  op = *codep;
  codep++;

  FETCH_DATA (the_info, codep + 1);

  /* save xmm pair */
  xmms = XMM_DST (rex, *codep) << 8;
  xmms |= XMM_SRC (rex, *codep);
  codep++;

  /* save immediate field */
  FETCH_DATA (the_info, codep + 2);
  imm = *codep;
  codep++;

  if (op != 0x44 && op != 0xdf)
   {
     BadOp();
     return;
   }

  switch (op)
   {
   case 0x44:
     for (i = 0; i < sizeof(pclmul) / sizeof(pclmul[0]); i++)
       if (pclmul[i].opc == imm)
	 mnemonic = pclmul[i].name;

     if (!mnemonic)
      {
	oappend ("pclmulqdq");
        sprintf (scratchbuf, " $%#x,", imm);
        oappend (scratchbuf);
      }
     else
      {
	oappend (mnemonic);
	oappend (" ");
      }
     break;
   case 0xdf:
     oappend ("aeskeygenassist ");
     sprintf (scratchbuf, " $%#x,", imm);
     oappend (scratchbuf);
     break;
   }

   sprintf (scratchbuf, "%%xmm%d,", xmms & 0xff);
   oappend (scratchbuf);
   sprintf (scratchbuf, "%%xmm%d", xmms >> 8);
   oappend (scratchbuf);

   used_prefixes |= (prefixes & PREFIX_DATA);
   USED_REX(rex);
}

static void
BadOp (void)
{
  /* Throw away prefixes and 1st. opcode byte.  */
  codep = insn_codep + 1;
  oappend ("(bad)");
}
@


1.16
log
@Add support for i386 XSAVE family of instructions: xgetbv, xsetbv, xsave,
xrstor, and xsaveopt.

based on kettenis's original that did xgetbv and xsetbv
ok kettenis@@
@
text
@d4215 3
a4217 1
  if (*codep == 0xf8)
d4219 9
a4227 5
      char *p = obuf + strlen (obuf);

      /* Override "invlpg".  */
      strcpy (p - 6, "swapgs");
      codep++;
d4229 3
a4231 2
  else
    OP_E (bytemode, sizeflag);
@


1.15
log
@Add support for stac/clac instructions to manipulate the flag
that controls the behaviour of Intel's Supervisor Mode Access Prevention
(SMAP) feature.

'looks correct' miod@@ ok deraadt@@
@
text
@d103 1
d1370 1
a1370 1
    { "lgdtQ",	 M, XX, XX },
d1438 4
a1441 4
    { "(bad)",	XX, XX, XX },
    { "lfence", OP_0fae, 0, XX, XX },
    { "mfence", OP_0fae, 0, XX, XX },
    { "clflush", OP_0fae, 0, XX, XX },
d3966 5
d3978 1
a3978 1
  else if (reg != 7)
d3980 1
a3980 1
      BadOp ();		/* bad clflush */
d4187 23
@


1.14
log
@disassemble the rdrand instruction on i386/amd64
@
text
@d4151 1
a4151 1
  if (mod == 3 && reg == 1)
d4167 10
@


1.13
log
@Add support for Intel AES-NI and the CLMUL_ instructions, plus a few others
that are needed to omplement accelerated AES (and AES-GCM mode) on newer
Intel cores.

Diff from Mike Belopuhov.

no objections/ok miod@@
@
text
@d1395 1
a1395 1
    { "(bad)",	XX, XX, XX },
@


1.12
log
@Fix i386 disassembler.
ok hshoexer@@, it's my fault initially miod@@
@
text
@d104 2
d306 2
d838 1
d840 1
a840 2
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
d1116 1
a1116 1
  /* 30 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 3f */
d4256 129
@


1.11
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@a956 1
  { "(bad)",		XX, XX, XX },
@


1.10
log
@Fix merge error

ok drahn@@
@
text
@d3 1
a3 1
   2001, 2002, 2003 Free Software Foundation, Inc.
d26 1
d52 53
a104 48
static int fetch_data PARAMS ((struct disassemble_info *, bfd_byte *));
static void ckprefix PARAMS ((void));
static const char *prefix_name PARAMS ((int, int));
static int print_insn PARAMS ((bfd_vma, disassemble_info *));
static void dofloat PARAMS ((int));
static void OP_ST PARAMS ((int, int));
static void OP_STi  PARAMS ((int, int));
static int putop PARAMS ((const char *, int));
static void oappend PARAMS ((const char *));
static void append_seg PARAMS ((void));
static void OP_indirE PARAMS ((int, int));
static void print_operand_value PARAMS ((char *, int, bfd_vma));
static void OP_E PARAMS ((int, int));
static void OP_G PARAMS ((int, int));
static bfd_vma get64 PARAMS ((void));
static bfd_signed_vma get32 PARAMS ((void));
static bfd_signed_vma get32s PARAMS ((void));
static int get16 PARAMS ((void));
static void set_op PARAMS ((bfd_vma, int));
static void OP_REG PARAMS ((int, int));
static void OP_IMREG PARAMS ((int, int));
static void OP_I PARAMS ((int, int));
static void OP_I64 PARAMS ((int, int));
static void OP_sI PARAMS ((int, int));
static void OP_J PARAMS ((int, int));
static void OP_SEG PARAMS ((int, int));
static void OP_DIR PARAMS ((int, int));
static void OP_OFF PARAMS ((int, int));
static void OP_OFF64 PARAMS ((int, int));
static void ptr_reg PARAMS ((int, int));
static void OP_ESreg PARAMS ((int, int));
static void OP_DSreg PARAMS ((int, int));
static void OP_C PARAMS ((int, int));
static void OP_D PARAMS ((int, int));
static void OP_T PARAMS ((int, int));
static void OP_Rd PARAMS ((int, int));
static void OP_MMX PARAMS ((int, int));
static void OP_XMM PARAMS ((int, int));
static void OP_EM PARAMS ((int, int));
static void OP_EX PARAMS ((int, int));
static void OP_MS PARAMS ((int, int));
static void OP_XS PARAMS ((int, int));
static void OP_3DNowSuffix PARAMS ((int, int));
static void OP_xcrypt2 PARAMS ((int, int));
static void OP_xcrypt PARAMS ((int, int));
static void OP_SIMD_Suffix PARAMS ((int, int));
static void SIMD_Fixup PARAMS ((int, int));
static void BadOp PARAMS ((void));
d171 1
a171 3
fetch_data (info, addr)
     struct disassemble_info *info;
     bfd_byte *addr;
d206 2
a207 2
#define M OP_E, 0		/* lea, lgdt, etc. */
#define Mp OP_E, 0		/* 32 or 48 bit memory operand for LDS, LES etc */
a299 1
#define None OP_E, 0
d427 6
d436 1
a436 1
typedef void (*op_rtn) PARAMS ((int bytemode, int sizeflag));
d642 1
a642 2
  { "nop",		XX, XX, XX },
  /* FIXME: NOP with REPz prefix is called PAUSE.  */
d791 1
a791 1
  { "movlpX",		XM, EX, SIMD_Fixup, 'h' }, /* really only 2 operands */
d795 1
a795 1
  { "movhpX",		XM, EX, SIMD_Fixup, 'l' },
d910 2
a911 2
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
d957 1
d1006 1
a1006 1
  { "(bad)",		XX, XX, XX },
d1042 1
a1042 1
  { "(bad)",		XX, XX, XX },
d1094 1
a1094 1
  /* 70 */ 1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1, /* 7f */
d1097 1
a1097 1
  /* a0 */ 0,0,0,1,1,1,0,0,0,0,0,1,1,1,1,1, /* af */
d1100 1
a1100 1
  /* d0 */ 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* df */
d1102 1
a1102 1
  /* f0 */ 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0  /* ff */
d1111 1
a1111 1
  /* 10 */ 1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 1f */
d1117 1
a1117 1
  /* 70 */ 1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1, /* 7f */
d1123 1
a1123 1
  /* d0 */ 0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0, /* df */
d1125 1
a1125 1
  /* f0 */ 0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0  /* ff */
d1365 1
a1365 1
    { "sidtQ",	 M, XX, XX },
d1371 1
a1371 1
    { "invlpg",	Ew, XX, XX },
d1435 3
a1437 4
    { "lfence", None, XX, XX },
    { "mfence", None, XX, XX },
    { "sfence", None, XX, XX },
    /* FIXME: the sfence with memory operand is clflush!  */
d1460 1
a1460 1
  }
d1653 42
d1707 1
a1707 1
ckprefix ()
d1805 1
a1805 3
prefix_name (pref, sizeflag)
     int pref;
     int sizeflag;
d1899 1
a1899 3
print_insn_i386_att (pc, info)
     bfd_vma pc;
     disassemble_info *info;
d1907 1
a1907 3
print_insn_i386_intel (pc, info)
     bfd_vma pc;
     disassemble_info *info;
d1915 1
a1915 3
print_insn_i386 (pc, info)
     bfd_vma pc;
     disassemble_info *info;
d1923 1
a1923 3
print_insn (pc, info)
     bfd_vma pc;
     disassemble_info *info;
d2032 1
a2032 1
  info->private_data = (PTR) &priv;
d2341 1
a2341 1
  "(bad)",
d2359 1
a2359 1
  "(bad)",
d2377 1
a2377 1
  "(bad)",
d2553 1
a2553 2
dofloat (sizeflag)
     int sizeflag;
d2599 1
a2599 3
OP_ST (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
d2605 1
a2605 3
OP_STi (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
d2613 1
a2613 3
putop (template, sizeflag)
     const char *template;
     int sizeflag;
d2886 1
a2886 2
oappend (s)
     const char *s;
d2893 1
a2893 1
append_seg ()
d2928 1
a2928 3
OP_indirE (bytemode, sizeflag)
     int bytemode;
     int sizeflag;
d2936 1
a2936 4
print_operand_value (buf, hex, disp)
  char *buf;
  int hex;
  bfd_vma disp;
d2993 1
a2993 3
OP_E (bytemode, sizeflag)
     int bytemode;
     int sizeflag;
a3043 4
	  if (!(codep[-2] == 0xAE && codep[-1] == 0xF8 /* sfence */)
	      && !(codep[-2] == 0xAE && codep[-1] == 0xF0 /* mfence */)
	      && !(codep[-2] == 0xAE && codep[-1] == 0xe8 /* lfence */))
	    BadOp ();	/* bad sfence,lea,lds,les,lfs,lgs,lss modrm */
d3179 1
a3179 5
	      if (!intel_syntax
		  || (intel_syntax
		      && bytemode != b_mode
		      && bytemode != w_mode
		      && bytemode != v_mode))
d3268 1
a3268 3
OP_G (bytemode, sizeflag)
     int bytemode;
     int sizeflag;
d3309 1
a3309 1
get64 ()
d3334 1
a3334 1
get32 ()
d3347 1
a3347 1
get32s ()
d3363 1
a3363 1
get16 ()
d3374 1
a3374 3
set_op (op, riprel)
     bfd_vma op;
     int riprel;
d3391 1
a3391 3
OP_REG (code, sizeflag)
     int code;
     int sizeflag;
d3451 1
a3451 3
OP_IMREG (code, sizeflag)
     int code;
     int sizeflag;
d3498 1
a3498 3
OP_I (bytemode, sizeflag)
     int bytemode;
     int sizeflag;
d3550 1
a3550 3
OP_I64 (bytemode, sizeflag)
     int bytemode;
     int sizeflag;
d3601 1
a3601 3
OP_sI (bytemode, sizeflag)
     int bytemode;
     int sizeflag;
d3650 1
a3650 3
OP_J (bytemode, sizeflag)
     int bytemode;
     int sizeflag;
d3686 1
a3686 3
OP_SEG (dummy, sizeflag)
     int dummy ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
d3692 1
a3692 3
OP_DIR (dummy, sizeflag)
     int dummy ATTRIBUTE_UNUSED;
     int sizeflag;
d3715 1
a3715 3
OP_OFF (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
     int sizeflag;
d3740 1
a3740 3
OP_OFF64 (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
d3768 1
a3768 3
ptr_reg (code, sizeflag)
     int code;
     int sizeflag;
d3796 1
a3796 3
OP_ESreg (code, sizeflag)
     int code;
     int sizeflag;
d3803 1
a3803 3
OP_DSreg (code, sizeflag)
     int code;
     int sizeflag;
d3818 1
a3818 3
OP_C (dummy, sizeflag)
     int dummy ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
d3829 1
a3829 3
OP_D (dummy, sizeflag)
     int dummy ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
d3843 1
a3843 3
OP_T (dummy, sizeflag)
     int dummy ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
d3850 1
a3850 3
OP_Rd (bytemode, sizeflag)
     int bytemode;
     int sizeflag;
d3859 1
a3859 3
OP_MMX (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
d3874 1
a3874 3
OP_XMM (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
d3885 1
a3885 3
OP_EM (bytemode, sizeflag)
     int bytemode;
     int sizeflag;
d3909 1
a3909 3
OP_EX (bytemode, sizeflag)
     int bytemode;
     int sizeflag;
d3929 1
a3929 3
OP_MS (bytemode, sizeflag)
     int bytemode;
     int sizeflag;
d3938 1
a3938 3
OP_XS (bytemode, sizeflag)
     int bytemode;
     int sizeflag;
d3946 31
a3976 11
static struct {
     unsigned char opc;
     char *name;
} xcrypt[] = {
  {  0xc0, "xstore-rng" },
  {  0xc8, "xcrypt-ecb" },
  {  0xd0, "xcrypt-cbc" },
  {  0xd8, "xcrypt-ctr" },
  {  0xe0, "xcrypt-cfb" },
  {  0xe8, "xcrypt-ofb" },
};
d3978 7
a3984 8
static struct {
     unsigned char opc;
     char *name;
} xcrypt2[] = {
  {  0xc0, "montmul" },
  {  0xc8, "xsha1" },
  {  0xd0, "xsha256" },
};
d4054 1
a4054 3
OP_3DNowSuffix (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
a4077 48
static void
OP_xcrypt (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
{
  const char *mnemonic = NULL;
  unsigned int i;

  FETCH_DATA (the_info, codep + 1);
  /* VIA C3 xcrypt-* & xmove-* instructions are specified by an opcode
     suffix in the place where an 8-bit immediate would normally go.
     ie. the last byte of the instruction.  */
  obufp = obuf + strlen(obuf);

  for (i = 0; i < sizeof(xcrypt) / sizeof(xcrypt[0]); i++)
    if (xcrypt[i].opc == (*codep & 0xff))
      mnemonic = xcrypt[i].name;
  codep++;
  if (mnemonic)
    oappend (mnemonic);
  else
    BadOp();
}

static void
OP_xcrypt2 (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
{
  const char *mnemonic = NULL;
  unsigned int i;

  FETCH_DATA (the_info, codep + 1);
  /* VIA C3 xcrypt2 instructions are specified by an opcode
     suffix in the place where an 8-bit immediate would normally go.
     ie. the last byte of the instruction.  */
  obufp = obuf + strlen(obuf);

  for (i = 0; i < sizeof(xcrypt2) / sizeof(xcrypt2[0]); i++)
    if (xcrypt2[i].opc == (*codep & 0xff))
      mnemonic = xcrypt2[i].name;
  codep++;
  if (mnemonic)
    oappend (mnemonic);
  else
    BadOp();
}

d4090 1
a4090 3
OP_SIMD_Suffix (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
d4130 1
a4130 3
SIMD_Fixup (extrachar, sizeflag)
     int extrachar;
     int sizeflag ATTRIBUTE_UNUSED;
d4144 109
@


1.9
log
@grok 4 new instructions which will show up in VIA C3 Esther, which
isn't that far away...  xcrypt-ctr (AES ctr mode), montmul (montgomery
multiply for 800 RSA sign/sec at 1024bit), and xsha1/xsha256 too.
@
text
@a950 1
  { "(bad)",		XX, XX, XX },
@


1.8
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d94 1
d299 1
d949 1
a949 1
  { "(bad)",		XX, XX, XX },
d3987 1
d3992 9
d4112 24
@


1.7
log
@grok VIA C3 xmove-* and xcrypt-* instructions; niklas ok
@
text
@d3 1
a3 2
   2001
   Free Software Foundation, Inc.
d52 46
d99 1
a99 2
struct dis_private
{
d104 1
d160 1
a160 1
  ((addr) <= ((struct dis_private *)(info->private_data))->max_fetched \
d169 1
a169 1
  struct dis_private *priv = (struct dis_private *)info->private_data;
d179 3
a181 3
         print_insn_i386 will do something sensible.  Otherwise, print
         an error.  We do that here because this is where we know
         STATUS.  */
d196 1
d201 1
a201 1
#define M OP_E, 0		/* lea */
a303 1
#if 0 /* leave undefined until someone adds the extra flag to objdump */
a304 1
#endif
a307 49
typedef void (*op_rtn) PARAMS ((int bytemode, int sizeflag));

static void OP_E PARAMS ((int, int));
static void OP_G PARAMS ((int, int));
static void OP_I PARAMS ((int, int));
static void OP_I64 PARAMS ((int, int));
static void OP_OFF PARAMS ((int, int));
static void OP_REG PARAMS ((int, int));
static void OP_IMREG PARAMS ((int, int));
static void OP_OFF64 PARAMS ((int, int));
static void OP_indirE PARAMS ((int, int));
static void OP_sI PARAMS ((int, int));
static void OP_REG PARAMS ((int, int));
static void OP_J PARAMS ((int, int));
static void OP_DIR PARAMS ((int, int));
static void OP_OFF PARAMS ((int, int));
static void OP_ESreg PARAMS ((int, int));
static void OP_DSreg PARAMS ((int, int));
static void OP_SEG PARAMS ((int, int));
static void OP_C PARAMS ((int, int));
static void OP_D PARAMS ((int, int));
static void OP_T PARAMS ((int, int));
static void OP_Rd PARAMS ((int, int));
static void OP_ST PARAMS ((int, int));
static void OP_STi  PARAMS ((int, int));
static void OP_MMX PARAMS ((int, int));
static void OP_XMM PARAMS ((int, int));
static void OP_EM PARAMS ((int, int));
static void OP_EX PARAMS ((int, int));
static void OP_MS PARAMS ((int, int));
static void OP_XS PARAMS ((int, int));
static void OP_3DNowSuffix PARAMS ((int, int));
static void OP_xcrypt PARAMS ((int, int));
static void OP_SIMD_Suffix PARAMS ((int, int));
static void SIMD_Fixup PARAMS ((int, int));

static void append_seg PARAMS ((void));
static void set_op PARAMS ((unsigned int op, int));
static void putop PARAMS ((const char *template, int sizeflag));
static void dofloat PARAMS ((int sizeflag));
static int get16 PARAMS ((void));
static bfd_vma get64 PARAMS ((void));
static bfd_signed_vma get32 PARAMS ((void));
static bfd_signed_vma get32s PARAMS ((void));
static void ckprefix PARAMS ((void));
static const char *prefix_name PARAMS ((int, int));
static void ptr_reg PARAMS ((int, int));
static void BadOp PARAMS ((void));

d317 1
d364 58
a421 2
#define USE_GROUPS 1
#define USE_PREFIX_USER_TABLE 2
d423 1
a423 51
#define GRP1b NULL, NULL, 0, NULL, USE_GROUPS, NULL, 0
#define GRP1S NULL, NULL, 1, NULL, USE_GROUPS, NULL, 0
#define GRP1Ss NULL, NULL, 2, NULL, USE_GROUPS, NULL, 0
#define GRP2b NULL, NULL, 3, NULL, USE_GROUPS, NULL, 0
#define GRP2S NULL, NULL, 4, NULL, USE_GROUPS, NULL, 0
#define GRP2b_one NULL, NULL, 5, NULL, USE_GROUPS, NULL, 0
#define GRP2S_one NULL, NULL, 6, NULL, USE_GROUPS, NULL, 0
#define GRP2b_cl NULL, NULL, 7, NULL, USE_GROUPS, NULL, 0
#define GRP2S_cl NULL, NULL, 8, NULL, USE_GROUPS, NULL, 0
#define GRP3b NULL, NULL, 9, NULL, USE_GROUPS, NULL, 0
#define GRP3S NULL, NULL, 10, NULL, USE_GROUPS, NULL, 0
#define GRP4  NULL, NULL, 11, NULL, USE_GROUPS, NULL, 0
#define GRP5  NULL, NULL, 12, NULL, USE_GROUPS, NULL, 0
#define GRP6  NULL, NULL, 13, NULL, USE_GROUPS, NULL, 0
#define GRP7 NULL, NULL, 14, NULL, USE_GROUPS, NULL, 0
#define GRP8 NULL, NULL, 15, NULL, USE_GROUPS, NULL, 0
#define GRP9 NULL, NULL, 16, NULL, USE_GROUPS, NULL, 0
#define GRP10 NULL, NULL, 17, NULL, USE_GROUPS, NULL, 0
#define GRP11 NULL, NULL, 18, NULL, USE_GROUPS, NULL, 0
#define GRP12 NULL, NULL, 19, NULL, USE_GROUPS, NULL, 0
#define GRP13 NULL, NULL, 20, NULL, USE_GROUPS, NULL, 0
#define GRP14 NULL, NULL, 21, NULL, USE_GROUPS, NULL, 0
#define GRPAMD NULL, NULL, 22, NULL, USE_GROUPS, NULL, 0

#define PREGRP0 NULL, NULL, 0, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP1 NULL, NULL, 1, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP2 NULL, NULL, 2, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP3 NULL, NULL, 3, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP4 NULL, NULL, 4, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP5 NULL, NULL, 5, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP6 NULL, NULL, 6, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP7 NULL, NULL, 7, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP8 NULL, NULL, 8, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP9 NULL, NULL, 9, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP10 NULL, NULL, 10, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP11 NULL, NULL, 11, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP12 NULL, NULL, 12, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP13 NULL, NULL, 13, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP14 NULL, NULL, 14, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP15 NULL, NULL, 15, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP16 NULL, NULL, 16, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP17 NULL, NULL, 17, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP18 NULL, NULL, 18, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP19 NULL, NULL, 19, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP20 NULL, NULL, 20, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP21 NULL, NULL, 21, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP22 NULL, NULL, 22, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP23 NULL, NULL, 23, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP24 NULL, NULL, 24, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP25 NULL, NULL, 25, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP26 NULL, NULL, 26, NULL, USE_PREFIX_USER_TABLE, NULL, 0
d425 1
a425 2
#define FLOATCODE 50
#define FLOAT NULL, NULL, FLOATCODE, NULL, 0, NULL, 0
d442 1
d447 3
a449 4
                              or suffix_always is true
	  print 'q' if rex prefix is present.
   'I' => print 'q' in 64bit mode and behave as 'P' otherwise
   'Q' => print 'w', 'l' or 'q' if no register operands or suffix_always is true
d452 2
a453 1
   'T' => print 'q' in 64bit mode and behave as 'I' otherwise
a456 1
*/
d458 2
a459 291
static const struct dis386 dis386_att[] = {
  /* 00 */
  { "addB",	Eb, Gb, XX },
  { "addS",	Ev, Gv, XX },
  { "addB",	Gb, Eb, XX },
  { "addS",	Gv, Ev, XX },
  { "addB",	AL, Ib, XX },
  { "addS",	eAX, Iv, XX },
  { "pushI",	es, XX, XX },
  { "popI",	es, XX, XX },
  /* 08 */
  { "orB",	Eb, Gb, XX },
  { "orS",	Ev, Gv, XX },
  { "orB",	Gb, Eb, XX },
  { "orS",	Gv, Ev, XX },
  { "orB",	AL, Ib, XX },
  { "orS",	eAX, Iv, XX },
  { "pushI",	cs, XX, XX },
  { "(bad)",	XX, XX, XX },	/* 0x0f extended opcode escape */
  /* 10 */
  { "adcB",	Eb, Gb, XX },
  { "adcS",	Ev, Gv, XX },
  { "adcB",	Gb, Eb, XX },
  { "adcS",	Gv, Ev, XX },
  { "adcB",	AL, Ib, XX },
  { "adcS",	eAX, Iv, XX },
  { "pushI",	ss, XX, XX },
  { "popI",	ss, XX, XX },
  /* 18 */
  { "sbbB",	Eb, Gb, XX },
  { "sbbS",	Ev, Gv, XX },
  { "sbbB",	Gb, Eb, XX },
  { "sbbS",	Gv, Ev, XX },
  { "sbbB",	AL, Ib, XX },
  { "sbbS",	eAX, Iv, XX },
  { "pushI",	ds, XX, XX },
  { "popI",	ds, XX, XX },
  /* 20 */
  { "andB",	Eb, Gb, XX },
  { "andS",	Ev, Gv, XX },
  { "andB",	Gb, Eb, XX },
  { "andS",	Gv, Ev, XX },
  { "andB",	AL, Ib, XX },
  { "andS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG ES prefix */
  { "daa",	XX, XX, XX },
  /* 28 */
  { "subB",	Eb, Gb, XX },
  { "subS",	Ev, Gv, XX },
  { "subB",	Gb, Eb, XX },
  { "subS",	Gv, Ev, XX },
  { "subB",	AL, Ib, XX },
  { "subS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG CS prefix */
  { "das",	XX, XX, XX },
  /* 30 */
  { "xorB",	Eb, Gb, XX },
  { "xorS",	Ev, Gv, XX },
  { "xorB",	Gb, Eb, XX },
  { "xorS",	Gv, Ev, XX },
  { "xorB",	AL, Ib, XX },
  { "xorS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG SS prefix */
  { "aaa",	XX, XX, XX },
  /* 38 */
  { "cmpB",	Eb, Gb, XX },
  { "cmpS",	Ev, Gv, XX },
  { "cmpB",	Gb, Eb, XX },
  { "cmpS",	Gv, Ev, XX },
  { "cmpB",	AL, Ib, XX },
  { "cmpS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG DS prefix */
  { "aas",	XX, XX, XX },
  /* 40 */
  { "incS",	RMeAX, XX, XX },
  { "incS",	RMeCX, XX, XX },
  { "incS",	RMeDX, XX, XX },
  { "incS",	RMeBX, XX, XX },
  { "incS",	RMeSP, XX, XX },
  { "incS",	RMeBP, XX, XX },
  { "incS",	RMeSI, XX, XX },
  { "incS",	RMeDI, XX, XX },
  /* 48 */
  { "decS",	RMeAX, XX, XX },
  { "decS",	RMeCX, XX, XX },
  { "decS",	RMeDX, XX, XX },
  { "decS",	RMeBX, XX, XX },
  { "decS",	RMeSP, XX, XX },
  { "decS",	RMeBP, XX, XX },
  { "decS",	RMeSI, XX, XX },
  { "decS",	RMeDI, XX, XX },
  /* 50 */
  { "pushS",	RMeAX, XX, XX },
  { "pushS",	RMeCX, XX, XX },
  { "pushS",	RMeDX, XX, XX },
  { "pushS",	RMeBX, XX, XX },
  { "pushS",	RMeSP, XX, XX },
  { "pushS",	RMeBP, XX, XX },
  { "pushS",	RMeSI, XX, XX },
  { "pushS",	RMeDI, XX, XX },
  /* 58 */
  { "popS",	RMeAX, XX, XX },
  { "popS",	RMeCX, XX, XX },
  { "popS",	RMeDX, XX, XX },
  { "popS",	RMeBX, XX, XX },
  { "popS",	RMeSP, XX, XX },
  { "popS",	RMeBP, XX, XX },
  { "popS",	RMeSI, XX, XX },
  { "popS",	RMeDI, XX, XX },
  /* 60 */
  { "pushaP",	XX, XX, XX },
  { "popaP",	XX, XX, XX },
  { "boundS",	Gv, Ma, XX },
  { "arpl",	Ew, Gw, XX },
  { "(bad)",	XX, XX, XX },			/* seg fs */
  { "(bad)",	XX, XX, XX },			/* seg gs */
  { "(bad)",	XX, XX, XX },			/* op size prefix */
  { "(bad)",	XX, XX, XX },			/* adr size prefix */
  /* 68 */
  { "pushI",	Iv, XX, XX },		/* 386 book wrong */
  { "imulS",	Gv, Ev, Iv },
  { "pushI",	sIb, XX, XX },	/* push of byte really pushes 2 or 4 bytes */
  { "imulS",	Gv, Ev, sIb },
  { "insb",	Yb, indirDX, XX },
  { "insR",	Yv, indirDX, XX },
  { "outsb",	indirDX, Xb, XX },
  { "outsR",	indirDX, Xv, XX },
  /* 70 */
  { "jo",	Jb, cond_jump_flag, XX },
  { "jno",	Jb, cond_jump_flag, XX },
  { "jb",	Jb, cond_jump_flag, XX },
  { "jae",	Jb, cond_jump_flag, XX },
  { "je",	Jb, cond_jump_flag, XX },
  { "jne",	Jb, cond_jump_flag, XX },
  { "jbe",	Jb, cond_jump_flag, XX },
  { "ja",	Jb, cond_jump_flag, XX },
  /* 78 */
  { "js",	Jb, cond_jump_flag, XX },
  { "jns",	Jb, cond_jump_flag, XX },
  { "jp",	Jb, cond_jump_flag, XX },
  { "jnp",	Jb, cond_jump_flag, XX },
  { "jl",	Jb, cond_jump_flag, XX },
  { "jge",	Jb, cond_jump_flag, XX },
  { "jle",	Jb, cond_jump_flag, XX },
  { "jg",	Jb, cond_jump_flag, XX },
  /* 80 */
  { GRP1b },
  { GRP1S },
  { "(bad)",	XX, XX, XX },
  { GRP1Ss },
  { "testB",	Eb, Gb, XX },
  { "testS",	Ev, Gv, XX },
  { "xchgB",	Eb, Gb, XX },
  { "xchgS",	Ev, Gv, XX },
  /* 88 */
  { "movB",	Eb, Gb, XX },
  { "movS",	Ev, Gv, XX },
  { "movB",	Gb, Eb, XX },
  { "movS",	Gv, Ev, XX },
  { "movQ",	Ev, Sw, XX },
  { "leaS",	Gv, M, XX },
  { "movQ",	Sw, Ev, XX },
  { "popT",	Ev, XX, XX },
  /* 90 */
  { "nop",	XX, XX, XX },
  /* FIXME: NOP with REPz prefix is called PAUSE.  */
  { "xchgS",	RMeCX, eAX, XX },
  { "xchgS",	RMeDX, eAX, XX },
  { "xchgS",	RMeBX, eAX, XX },
  { "xchgS",	RMeSP, eAX, XX },
  { "xchgS",	RMeBP, eAX, XX },
  { "xchgS",	RMeSI, eAX, XX },
  { "xchgS",	RMeDI, eAX, XX },
  /* 98 */
  { "cWtR",	XX, XX, XX },
  { "cRtO",	XX, XX, XX },
  { "lcallI",	Ap, XX, XX },
  { "(bad)",	XX, XX, XX },		/* fwait */
  { "pushfI",	XX, XX, XX },
  { "popfI",	XX, XX, XX },
  { "sahf",	XX, XX, XX },
  { "lahf",	XX, XX, XX },
  /* a0 */
  { "movB",	AL, Ob, XX },
  { "movS",	eAX, Ov, XX },
  { "movB",	Ob, AL, XX },
  { "movS",	Ov, eAX, XX },
  { "movsb",	Yb, Xb, XX },
  { "movsR",	Yv, Xv, XX },
  { "cmpsb",	Xb, Yb, XX },
  { "cmpsR",	Xv, Yv, XX },
  /* a8 */
  { "testB",	AL, Ib, XX },
  { "testS",	eAX, Iv, XX },
  { "stosB",	Yb, AL, XX },
  { "stosS",	Yv, eAX, XX },
  { "lodsB",	AL, Xb, XX },
  { "lodsS",	eAX, Xv, XX },
  { "scasB",	AL, Yb, XX },
  { "scasS",	eAX, Yv, XX },
  /* b0 */
  { "movB",	RMAL, Ib, XX },
  { "movB",	RMCL, Ib, XX },
  { "movB",	RMDL, Ib, XX },
  { "movB",	RMBL, Ib, XX },
  { "movB",	RMAH, Ib, XX },
  { "movB",	RMCH, Ib, XX },
  { "movB",	RMDH, Ib, XX },
  { "movB",	RMBH, Ib, XX },
  /* b8 */
  { "movS",	RMeAX, Iv, XX },
  { "movS",	RMeCX, Iv, XX },
  { "movS",	RMeDX, Iv, XX },
  { "movS",	RMeBX, Iv, XX },
  { "movS",	RMeSP, Iv, XX },
  { "movS",	RMeBP, Iv, XX },
  { "movS",	RMeSI, Iv, XX },
  { "movS",	RMeDI, Iv, XX },
  /* c0 */
  { GRP2b },
  { GRP2S },
  { "retI",	Iw, XX, XX },
  { "retI",	XX, XX, XX },
  { "lesS",	Gv, Mp, XX },
  { "ldsS",	Gv, Mp, XX },
  { "movA",	Eb, Ib, XX },
  { "movQ",	Ev, Iv, XX },
  /* c8 */
  { "enterI",	Iw, Ib, XX },
  { "leaveI",	XX, XX, XX },
  { "lretP",	Iw, XX, XX },
  { "lretP",	XX, XX, XX },
  { "int3",	XX, XX, XX },
  { "int",	Ib, XX, XX },
  { "into",	XX, XX, XX},
  { "iretP",	XX, XX, XX },
  /* d0 */
  { GRP2b_one },
  { GRP2S_one },
  { GRP2b_cl },
  { GRP2S_cl },
  { "aam",	sIb, XX, XX },
  { "aad",	sIb, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "xlat",	DSBX, XX, XX },
  /* d8 */
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  /* e0 */
  { "loopneF",	Jb, loop_jcxz_flag, XX },
  { "loopeF",	Jb, loop_jcxz_flag, XX },
  { "loopF",	Jb, loop_jcxz_flag, XX },
  { "jEcxz",	Jb, loop_jcxz_flag, XX },
  { "inB",	AL, Ib, XX },
  { "inS",	eAX, Ib, XX },
  { "outB",	Ib, AL, XX },
  { "outS",	Ib, eAX, XX },
  /* e8 */
  { "callI",	Jv, XX, XX },
  { "jmpI",	Jv, XX, XX },
  { "ljmpI",	Ap, XX, XX },
  { "jmp",	Jb, XX, XX },
  { "inB",	AL, indirDX, XX },
  { "inS",	eAX, indirDX, XX },
  { "outB",	indirDX, AL, XX },
  { "outS",	indirDX, eAX, XX },
  /* f0 */
  { "(bad)",	XX, XX, XX },			/* lock prefix */
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },			/* repne */
  { "(bad)",	XX, XX, XX },			/* repz */
  { "hlt",	XX, XX, XX },
  { "cmc",	XX, XX, XX },
  { GRP3b },
  { GRP3S },
  /* f8 */
  { "clc",	XX, XX, XX },
  { "stc",	XX, XX, XX },
  { "cli",	XX, XX, XX },
  { "sti",	XX, XX, XX },
  { "cld",	XX, XX, XX },
  { "std",	XX, XX, XX },
  { GRP4 },
  { GRP5 },
};
d461 5
a465 585
static const struct dis386 dis386_intel[] = {
  /* 00 */
  { "add",	Eb, Gb, XX },
  { "add",	Ev, Gv, XX },
  { "add",	Gb, Eb, XX },
  { "add",	Gv, Ev, XX },
  { "add",	AL, Ib, XX },
  { "add",	eAX, Iv, XX },
  { "push",	es, XX, XX },
  { "pop",	es, XX, XX },
  /* 08 */
  { "or",	Eb, Gb, XX },
  { "or",	Ev, Gv, XX },
  { "or",	Gb, Eb, XX },
  { "or",	Gv, Ev, XX },
  { "or",	AL, Ib, XX },
  { "or",	eAX, Iv, XX },
  { "push",	cs, XX, XX },
  { "(bad)",	XX, XX, XX },	/* 0x0f extended opcode escape */
  /* 10 */
  { "adc",	Eb, Gb, XX },
  { "adc",	Ev, Gv, XX },
  { "adc",	Gb, Eb, XX },
  { "adc",	Gv, Ev, XX },
  { "adc",	AL, Ib, XX },
  { "adc",	eAX, Iv, XX },
  { "push",	ss, XX, XX },
  { "pop",	ss, XX, XX },
  /* 18 */
  { "sbb",	Eb, Gb, XX },
  { "sbb",	Ev, Gv, XX },
  { "sbb",	Gb, Eb, XX },
  { "sbb",	Gv, Ev, XX },
  { "sbb",	AL, Ib, XX },
  { "sbb",	eAX, Iv, XX },
  { "push",	ds, XX, XX },
  { "pop",	ds, XX, XX },
  /* 20 */
  { "and",	Eb, Gb, XX },
  { "and",	Ev, Gv, XX },
  { "and",	Gb, Eb, XX },
  { "and",	Gv, Ev, XX },
  { "and",	AL, Ib, XX },
  { "and",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG ES prefix */
  { "daa",	XX, XX, XX },
  /* 28 */
  { "sub",	Eb, Gb, XX },
  { "sub",	Ev, Gv, XX },
  { "sub",	Gb, Eb, XX },
  { "sub",	Gv, Ev, XX },
  { "sub",	AL, Ib, XX },
  { "sub",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG CS prefix */
  { "das",	XX, XX, XX },
  /* 30 */
  { "xor",	Eb, Gb, XX },
  { "xor",	Ev, Gv, XX },
  { "xor",	Gb, Eb, XX },
  { "xor",	Gv, Ev, XX },
  { "xor",	AL, Ib, XX },
  { "xor",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG SS prefix */
  { "aaa",	XX, XX, XX },
  /* 38 */
  { "cmp",	Eb, Gb, XX },
  { "cmp",	Ev, Gv, XX },
  { "cmp",	Gb, Eb, XX },
  { "cmp",	Gv, Ev, XX },
  { "cmp",	AL, Ib, XX },
  { "cmp",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG DS prefix */
  { "aas",	XX, XX, XX },
  /* 40 */
  { "inc",	RMeAX, XX, XX },
  { "inc",	RMeCX, XX, XX },
  { "inc",	RMeDX, XX, XX },
  { "inc",	RMeBX, XX, XX },
  { "inc",	RMeSP, XX, XX },
  { "inc",	RMeBP, XX, XX },
  { "inc",	RMeSI, XX, XX },
  { "inc",	RMeDI, XX, XX },
  /* 48 */
  { "dec",	RMeAX, XX, XX },
  { "dec",	RMeCX, XX, XX },
  { "dec",	RMeDX, XX, XX },
  { "dec",	RMeBX, XX, XX },
  { "dec",	RMeSP, XX, XX },
  { "dec",	RMeBP, XX, XX },
  { "dec",	RMeSI, XX, XX },
  { "dec",	RMeDI, XX, XX },
  /* 50 */
  { "push",	RMeAX, XX, XX },
  { "push",	RMeCX, XX, XX },
  { "push",	RMeDX, XX, XX },
  { "push",	RMeBX, XX, XX },
  { "push",	RMeSP, XX, XX },
  { "push",	RMeBP, XX, XX },
  { "push",	RMeSI, XX, XX },
  { "push",	RMeDI, XX, XX },
  /* 58 */
  { "pop",	RMeAX, XX, XX },
  { "pop",	RMeCX, XX, XX },
  { "pop",	RMeDX, XX, XX },
  { "pop",	RMeBX, XX, XX },
  { "pop",	RMeSP, XX, XX },
  { "pop",	RMeBP, XX, XX },
  { "pop",	RMeSI, XX, XX },
  { "pop",	RMeDI, XX, XX },
  /* 60 */
  { "pusha",	XX, XX, XX },
  { "popa",	XX, XX, XX },
  { "bound",	Gv, Ma, XX },
  { "arpl",	Ew, Gw, XX },
  { "(bad)",	XX, XX, XX },			/* seg fs */
  { "(bad)",	XX, XX, XX },			/* seg gs */
  { "(bad)",	XX, XX, XX },			/* op size prefix */
  { "(bad)",	XX, XX, XX },			/* adr size prefix */
  /* 68 */
  { "push",	Iv, XX, XX },		/* 386 book wrong */
  { "imul",	Gv, Ev, Iv },
  { "push",	sIb, XX, XX },	/* push of byte really pushes 2 or 4 bytes */
  { "imul",	Gv, Ev, sIb },
  { "ins",	Yb, indirDX, XX },
  { "ins",	Yv, indirDX, XX },
  { "outs",	indirDX, Xb, XX },
  { "outs",	indirDX, Xv, XX },
  /* 70 */
  { "jo",	Jb, XX, XX },
  { "jno",	Jb, XX, XX },
  { "jb",	Jb, XX, XX },
  { "jae",	Jb, XX, XX },
  { "je",	Jb, XX, XX },
  { "jne",	Jb, XX, XX },
  { "jbe",	Jb, XX, XX },
  { "ja",	Jb, XX, XX },
  /* 78 */
  { "js",	Jb, XX, XX },
  { "jns",	Jb, XX, XX },
  { "jp",	Jb, XX, XX },
  { "jnp",	Jb, XX, XX },
  { "jl",	Jb, XX, XX },
  { "jge",	Jb, XX, XX },
  { "jle",	Jb, XX, XX },
  { "jg",	Jb, XX, XX },
  /* 80 */
  { GRP1b },
  { GRP1S },
  { "(bad)",	XX, XX, XX },
  { GRP1Ss },
  { "test",	Eb, Gb, XX },
  { "test",	Ev, Gv, XX },
  { "xchg",	Eb, Gb, XX },
  { "xchg",	Ev, Gv, XX },
  /* 88 */
  { "mov",	Eb, Gb, XX },
  { "mov",	Ev, Gv, XX },
  { "mov",	Gb, Eb, XX },
  { "mov",	Gv, Ev, XX },
  { "mov",	Ev, Sw, XX },
  { "lea",	Gv, M, XX },
  { "mov",	Sw, Ev, XX },
  { "pop",	Ev, XX, XX },
  /* 90 */
  { "nop",	XX, XX, XX },
  /* FIXME: NOP with REPz prefix is called PAUSE.  */
  { "xchg",	RMeCX, eAX, XX },
  { "xchg",	RMeDX, eAX, XX },
  { "xchg",	RMeBX, eAX, XX },
  { "xchg",	RMeSP, eAX, XX },
  { "xchg",	RMeBP, eAX, XX },
  { "xchg",	RMeSI, eAX, XX },
  { "xchg",	RMeDI, eAX, XX },
  /* 98 */
  { "cW",	XX, XX, XX },		/* cwde and cbw */
  { "cR",	XX, XX, XX },		/* cdq and cwd */
  { "lcall",	Ap, XX, XX },
  { "(bad)",	XX, XX, XX },		/* fwait */
  { "pushf",	XX, XX, XX },
  { "popf",	XX, XX, XX },
  { "sahf",	XX, XX, XX },
  { "lahf",	XX, XX, XX },
  /* a0 */
  { "mov",	AL, Ob, XX },
  { "mov",	eAX, Ov, XX },
  { "mov",	Ob, AL, XX },
  { "mov",	Ov, eAX, XX },
  { "movs",	Yb, Xb, XX },
  { "movs",	Yv, Xv, XX },
  { "cmps",	Xb, Yb, XX },
  { "cmps",	Xv, Yv, XX },
  /* a8 */
  { "test",	AL, Ib, XX },
  { "test",	eAX, Iv, XX },
  { "stos",	Yb, AL, XX },
  { "stos",	Yv, eAX, XX },
  { "lods",	AL, Xb, XX },
  { "lods",	eAX, Xv, XX },
  { "scas",	AL, Yb, XX },
  { "scas",	eAX, Yv, XX },
  /* b0 */
  { "mov",	RMAL, Ib, XX },
  { "mov",	RMCL, Ib, XX },
  { "mov",	RMDL, Ib, XX },
  { "mov",	RMBL, Ib, XX },
  { "mov",	RMAH, Ib, XX },
  { "mov",	RMCH, Ib, XX },
  { "mov",	RMDH, Ib, XX },
  { "mov",	RMBH, Ib, XX },
  /* b8 */
  { "mov",	RMeAX, Iv, XX },
  { "mov",	RMeCX, Iv, XX },
  { "mov",	RMeDX, Iv, XX },
  { "mov",	RMeBX, Iv, XX },
  { "mov",	RMeSP, Iv, XX },
  { "mov",	RMeBP, Iv, XX },
  { "mov",	RMeSI, Iv, XX },
  { "mov",	RMeDI, Iv, XX },
  /* c0 */
  { GRP2b },
  { GRP2S },
  { "ret",	Iw, XX, XX },
  { "ret",	XX, XX, XX },
  { "les",	Gv, Mp, XX },
  { "lds",	Gv, Mp, XX },
  { "mov",	Eb, Ib, XX },
  { "mov",	Ev, Iv, XX },
  /* c8 */
  { "enter",	Iw, Ib, XX },
  { "leave",	XX, XX, XX },
  { "lret",	Iw, XX, XX },
  { "lret",	XX, XX, XX },
  { "int3",	XX, XX, XX },
  { "int",	Ib, XX, XX },
  { "into",	XX, XX, XX },
  { "iret",	XX, XX, XX },
  /* d0 */
  { GRP2b_one },
  { GRP2S_one },
  { GRP2b_cl },
  { GRP2S_cl },
  { "aam",	sIb, XX, XX },
  { "aad",	sIb, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "xlat",	DSBX, XX, XX },
  /* d8 */
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  /* e0 */
  { "loopne",	Jb, XX, XX },
  { "loope",	Jb, XX, XX },
  { "loop",	Jb, XX, XX },
  { "jEcxz",	Jb, XX, XX },
  { "in",	AL, Ib, XX },
  { "in",	eAX, Ib, XX },
  { "out",	Ib, AL, XX },
  { "out",	Ib, eAX, XX },
  /* e8 */
  { "call",	Jv, XX, XX },
  { "jmp",	Jv, XX, XX },
  { "ljmp",	Ap, XX, XX },
  { "jmp",	Jb, XX, XX },
  { "in",	AL, indirDX, XX },
  { "in",	eAX, indirDX, XX },
  { "out",	indirDX, AL, XX },
  { "out",	indirDX, eAX, XX },
  /* f0 */
  { "(bad)",	XX, XX, XX },			/* lock prefix */
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },			/* repne */
  { "(bad)",	XX, XX, XX },			/* repz */
  { "hlt",	XX, XX, XX },
  { "cmc",	XX, XX, XX },
  { GRP3b },
  { GRP3S },
  /* f8 */
  { "clc",	XX, XX, XX },
  { "stc",	XX, XX, XX },
  { "cli",	XX, XX, XX },
  { "sti",	XX, XX, XX },
  { "cld",	XX, XX, XX },
  { "std",	XX, XX, XX },
  { GRP4 },
  { GRP5 },
};

/* 64bit mode is having some instruction set differences, so separate table is
   needed.  */
static const struct dis386 disx86_64_att[] = {
  /* 00 */
  { "addB",	Eb, Gb, XX },
  { "addS",	Ev, Gv, XX },
  { "addB",	Gb, Eb, XX },
  { "addS",	Gv, Ev, XX },
  { "addB",	AL, Ib, XX },
  { "addS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  /* 08 */
  { "orB",	Eb, Gb, XX },
  { "orS",	Ev, Gv, XX },
  { "orB",	Gb, Eb, XX },
  { "orS",	Gv, Ev, XX },
  { "orB",	AL, Ib, XX },
  { "orS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },	/* 0x0f extended opcode escape */
  /* 10 */
  { "adcB",	Eb, Gb, XX },
  { "adcS",	Ev, Gv, XX },
  { "adcB",	Gb, Eb, XX },
  { "adcS",	Gv, Ev, XX },
  { "adcB",	AL, Ib, XX },
  { "adcS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  /* 18 */
  { "sbbB",	Eb, Gb, XX },
  { "sbbS",	Ev, Gv, XX },
  { "sbbB",	Gb, Eb, XX },
  { "sbbS",	Gv, Ev, XX },
  { "sbbB",	AL, Ib, XX },
  { "sbbS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  /* 20 */
  { "andB",	Eb, Gb, XX },
  { "andS",	Ev, Gv, XX },
  { "andB",	Gb, Eb, XX },
  { "andS",	Gv, Ev, XX },
  { "andB",	AL, Ib, XX },
  { "andS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG ES prefix */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  /* 28 */
  { "subB",	Eb, Gb, XX },
  { "subS",	Ev, Gv, XX },
  { "subB",	Gb, Eb, XX },
  { "subS",	Gv, Ev, XX },
  { "subB",	AL, Ib, XX },
  { "subS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG CS prefix */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  /* 30 */
  { "xorB",	Eb, Gb, XX },
  { "xorS",	Ev, Gv, XX },
  { "xorB",	Gb, Eb, XX },
  { "xorS",	Gv, Ev, XX },
  { "xorB",	AL, Ib, XX },
  { "xorS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG SS prefix */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  /* 38 */
  { "cmpB",	Eb, Gb, XX },
  { "cmpS",	Ev, Gv, XX },
  { "cmpB",	Gb, Eb, XX },
  { "cmpS",	Gv, Ev, XX },
  { "cmpB",	AL, Ib, XX },
  { "cmpS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG DS prefix */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  /* 40 */
  { "(bad)",	XX, XX, XX },			/* REX prefix area.  */
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  /* 48 */
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  /* 50 */
  { "pushI",	RMrAX, XX, XX },
  { "pushI",	RMrCX, XX, XX },
  { "pushI",	RMrDX, XX, XX },
  { "pushI",	RMrBX, XX, XX },
  { "pushI",	RMrSP, XX, XX },
  { "pushI",	RMrBP, XX, XX },
  { "pushI",	RMrSI, XX, XX },
  { "pushI",	RMrDI, XX, XX },
  /* 58 */
  { "popI",	RMrAX, XX, XX },
  { "popI",	RMrCX, XX, XX },
  { "popI",	RMrDX, XX, XX },
  { "popI",	RMrBX, XX, XX },
  { "popI",	RMrSP, XX, XX },
  { "popI",	RMrBP, XX, XX },
  { "popI",	RMrSI, XX, XX },
  { "popI",	RMrDI, XX, XX },
  /* 60 */
  { "(bad)",	XX, XX, XX },   /* reserved.  */
  { "(bad)",	XX, XX, XX },   /* reserved.  */
  { "(bad)",	XX, XX, XX },   /* reserved.  */
  { "movslR",   Gv, Ed, XX },
  { "(bad)",	XX, XX, XX },			/* seg fs */
  { "(bad)",	XX, XX, XX },			/* seg gs */
  { "(bad)",	XX, XX, XX },			/* op size prefix */
  { "(bad)",	XX, XX, XX },			/* adr size prefix */
  /* 68 */
  { "pushI",	Iq, XX, XX },		/* 386 book wrong */
  { "imulS",	Gv, Ev, Iv },
  { "pushI",	sIb, XX, XX },	/* push of byte really pushes 2 or 4 bytes */
  { "imulS",	Gv, Ev, sIb },
  { "insb",	Yb, indirDX, XX },
  { "insR",	Yv, indirDX, XX },
  { "outsb",	indirDX, Xb, XX },
  { "outsR",	indirDX, Xv, XX },
  /* 70 */
  { "jo",	Jb, cond_jump_flag, XX },
  { "jno",	Jb, cond_jump_flag, XX },
  { "jb",	Jb, cond_jump_flag, XX },
  { "jae",	Jb, cond_jump_flag, XX },
  { "je",	Jb, cond_jump_flag, XX },
  { "jne",	Jb, cond_jump_flag, XX },
  { "jbe",	Jb, cond_jump_flag, XX },
  { "ja",	Jb, cond_jump_flag, XX },
  /* 78 */
  { "js",	Jb, cond_jump_flag, XX },
  { "jns",	Jb, cond_jump_flag, XX },
  { "jp",	Jb, cond_jump_flag, XX },
  { "jnp",	Jb, cond_jump_flag, XX },
  { "jl",	Jb, cond_jump_flag, XX },
  { "jge",	Jb, cond_jump_flag, XX },
  { "jle",	Jb, cond_jump_flag, XX },
  { "jg",	Jb, cond_jump_flag, XX },
  /* 80 */
  { GRP1b },
  { GRP1S },
  { "(bad)",	XX, XX, XX },
  { GRP1Ss },
  { "testB",	Eb, Gb, XX },
  { "testS",	Ev, Gv, XX },
  { "xchgB",	Eb, Gb, XX },
  { "xchgS",	Ev, Gv, XX },
  /* 88 */
  { "movB",	Eb, Gb, XX },
  { "movS",	Ev, Gv, XX },
  { "movB",	Gb, Eb, XX },
  { "movS",	Gv, Ev, XX },
  { "movQ",	Ev, Sw, XX },
  { "leaS",	Gv, M, XX },
  { "movQ",	Sw, Ev, XX },
  { "popI",	Ev, XX, XX },
  /* 90 */
  { "nop",	XX, XX, XX },
  /* FIXME: NOP with REPz prefix is called PAUSE.  */
  { "xchgS",	RMeCX, eAX, XX },
  { "xchgS",	RMeDX, eAX, XX },
  { "xchgS",	RMeBX, eAX, XX },
  { "xchgS",	RMeSP, eAX, XX },
  { "xchgS",	RMeBP, eAX, XX },
  { "xchgS",	RMeSI, eAX, XX },
  { "xchgS",	RMeDI, eAX, XX },
  /* 98 */
  { "cWtR",	XX, XX, XX },
  { "cRtO",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },   /* reserved.  */
  { "(bad)",	XX, XX, XX },		/* fwait */
  { "pushfI",	XX, XX, XX },
  { "popfI",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },   /* reserved.  */
  { "(bad)",	XX, XX, XX },   /* reserved.  */
  /* a0 */
  { "movB",	AL, Ob64, XX },
  { "movS",	eAX, Ov64, XX },
  { "movB",	Ob64, AL, XX },
  { "movS",	Ov64, eAX, XX },
  { "movsb",	Yb, Xb, XX },
  { "movsR",	Yv, Xv, XX },
  { "cmpsb",	Xb, Yb, XX },
  { "cmpsR",	Xv, Yv, XX },
  /* a8 */
  { "testB",	AL, Ib, XX },
  { "testS",	eAX, Iv, XX },
  { "stosB",	Yb, AL, XX },
  { "stosS",	Yv, eAX, XX },
  { "lodsB",	AL, Xb, XX },
  { "lodsS",	eAX, Xv, XX },
  { "scasB",	AL, Yb, XX },
  { "scasS",	eAX, Yv, XX },
  /* b0 */
  { "movB",	RMAL, Ib, XX },
  { "movB",	RMCL, Ib, XX },
  { "movB",	RMDL, Ib, XX },
  { "movB",	RMBL, Ib, XX },
  { "movB",	RMAH, Ib, XX },
  { "movB",	RMCH, Ib, XX },
  { "movB",	RMDH, Ib, XX },
  { "movB",	RMBH, Ib, XX },
  /* b8 */
  { "movS",	RMeAX, Iv64, XX },
  { "movS",	RMeCX, Iv64, XX },
  { "movS",	RMeDX, Iv64, XX },
  { "movS",	RMeBX, Iv64, XX },
  { "movS",	RMeSP, Iv64, XX },
  { "movS",	RMeBP, Iv64, XX },
  { "movS",	RMeSI, Iv64, XX },
  { "movS",	RMeDI, Iv64, XX },
  /* c0 */
  { GRP2b },
  { GRP2S },
  { "retI",	Iw, XX, XX },
  { "retI",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },   /* reserved.  */
  { "ldsS",	Gv, Mp, XX },
  { "movA",	Eb, Ib, XX },
  { "movQ",	Ev, Iv, XX },
  /* c8 */
  { "enterI",	Iw, Ib, XX },
  { "leaveI",	XX, XX, XX },
  { "lretP",	Iw, XX, XX },
  { "lretP",	XX, XX, XX },
  { "int3",	XX, XX, XX },
  { "int",	Ib, XX, XX },
  { "(bad)",	XX, XX, XX },   /* reserved.  */
  { "iretP",	XX, XX, XX },
  /* d0 */
  { GRP2b_one },
  { GRP2S_one },
  { GRP2b_cl },
  { GRP2S_cl },
  { "(bad)",	XX, XX, XX },   /* reserved.  */
  { "(bad)",	XX, XX, XX },   /* reserved.  */
  { "(bad)",	XX, XX, XX },   /* reserved.  */
  { "xlat",	DSBX, XX, XX },
  /* d8 */
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  /* e0 */
  { "loopneF",	Jb, loop_jcxz_flag, XX },
  { "loopeF",	Jb, loop_jcxz_flag, XX },
  { "loopF",	Jb, loop_jcxz_flag, XX },
  { "jEcxz",	Jb, loop_jcxz_flag, XX },
  { "inB",	AL, Ib, XX },
  { "inS",	eAX, Ib, XX },
  { "outB",	Ib, AL, XX },
  { "outS",	Ib, eAX, XX },
  /* e8 */
  { "callI",	Jv, XX, XX },
  { "jmpI",	Jv, XX, XX },
  { "(bad)",	XX, XX, XX },   /* reserved.  */
  { "jmp",	Jb, XX, XX },
  { "inB",	AL, indirDX, XX },
  { "inS",	eAX, indirDX, XX },
  { "outB",	indirDX, AL, XX },
  { "outS",	indirDX, eAX, XX },
  /* f0 */
  { "(bad)",	XX, XX, XX },			/* lock prefix */
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },			/* repne */
  { "(bad)",	XX, XX, XX },			/* repz */
  { "hlt",	XX, XX, XX },
  { "cmc",	XX, XX, XX },
  { GRP3b },
  { GRP3S },
  /* f8 */
  { "clc",	XX, XX, XX },
  { "stc",	XX, XX, XX },
  { "cli",	XX, XX, XX },
  { "sti",	XX, XX, XX },
  { "cld",	XX, XX, XX },
  { "std",	XX, XX, XX },
  { GRP4 },
  { GRP5 },
};
d467 1
a467 1
static const struct dis386 dis386_64_intel[] = {
d469 8
a476 8
  { "add",	Eb, Gb, XX },
  { "add",	Ev, Gv, XX },
  { "add",	Gb, Eb, XX },
  { "add",	Gv, Ev, XX },
  { "add",	AL, Ib, XX },
  { "add",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d478 8
a485 8
  { "or",	Eb, Gb, XX },
  { "or",	Ev, Gv, XX },
  { "or",	Gb, Eb, XX },
  { "or",	Gv, Ev, XX },
  { "or",	AL, Ib, XX },
  { "or",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },	/* 0x0f extended opcode escape */
d487 8
a494 8
  { "adc",	Eb, Gb, XX },
  { "adc",	Ev, Gv, XX },
  { "adc",	Gb, Eb, XX },
  { "adc",	Gv, Ev, XX },
  { "adc",	AL, Ib, XX },
  { "adc",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d496 8
a503 8
  { "sbb",	Eb, Gb, XX },
  { "sbb",	Ev, Gv, XX },
  { "sbb",	Gb, Eb, XX },
  { "sbb",	Gv, Ev, XX },
  { "sbb",	AL, Ib, XX },
  { "sbb",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d505 8
a512 8
  { "and",	Eb, Gb, XX },
  { "and",	Ev, Gv, XX },
  { "and",	Gb, Eb, XX },
  { "and",	Gv, Ev, XX },
  { "and",	AL, Ib, XX },
  { "and",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG ES prefix */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d514 8
a521 8
  { "sub",	Eb, Gb, XX },
  { "sub",	Ev, Gv, XX },
  { "sub",	Gb, Eb, XX },
  { "sub",	Gv, Ev, XX },
  { "sub",	AL, Ib, XX },
  { "sub",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG CS prefix */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d523 8
a530 8
  { "xor",	Eb, Gb, XX },
  { "xor",	Ev, Gv, XX },
  { "xor",	Gb, Eb, XX },
  { "xor",	Gv, Ev, XX },
  { "xor",	AL, Ib, XX },
  { "xor",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG SS prefix */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d532 8
a539 8
  { "cmp",	Eb, Gb, XX },
  { "cmp",	Ev, Gv, XX },
  { "cmp",	Gb, Eb, XX },
  { "cmp",	Gv, Ev, XX },
  { "cmp",	AL, Ib, XX },
  { "cmp",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG DS prefix */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d541 8
a548 8
  { "(bad)",	XX, XX, XX },			/* REX prefix area.  */
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
d550 8
a557 8
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
d559 8
a566 8
  { "push",	RMrAX, XX, XX },
  { "push",	RMrCX, XX, XX },
  { "push",	RMrDX, XX, XX },
  { "push",	RMrBX, XX, XX },
  { "push",	RMrSP, XX, XX },
  { "push",	RMrBP, XX, XX },
  { "push",	RMrSI, XX, XX },
  { "push",	RMrDI, XX, XX },
d568 8
a575 8
  { "pop",	RMrAX, XX, XX },
  { "pop",	RMrCX, XX, XX },
  { "pop",	RMrDX, XX, XX },
  { "pop",	RMrBX, XX, XX },
  { "pop",	RMrSP, XX, XX },
  { "pop",	RMrBP, XX, XX },
  { "pop",	RMrSI, XX, XX },
  { "pop",	RMrDI, XX, XX },
d577 8
a584 8
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "movsx",	Gv, Ed, XX },
  { "(bad)",	XX, XX, XX },			/* seg fs */
  { "(bad)",	XX, XX, XX },			/* seg gs */
  { "(bad)",	XX, XX, XX },			/* op size prefix */
  { "(bad)",	XX, XX, XX },			/* adr size prefix */
d586 8
a593 8
  { "push",	Iq, XX, XX },		/* 386 book wrong */
  { "imul",	Gv, Ev, Iv },
  { "push",	sIb, XX, XX },	/* push of byte really pushes 2 or 4 bytes */
  { "imul",	Gv, Ev, sIb },
  { "ins",	Yb, indirDX, XX },
  { "ins",	Yv, indirDX, XX },
  { "outs",	indirDX, Xb, XX },
  { "outs",	indirDX, Xv, XX },
d595 8
a602 8
  { "jo",	Jb, XX, XX },
  { "jno",	Jb, XX, XX },
  { "jb",	Jb, XX, XX },
  { "jae",	Jb, XX, XX },
  { "je",	Jb, XX, XX },
  { "jne",	Jb, XX, XX },
  { "jbe",	Jb, XX, XX },
  { "ja",	Jb, XX, XX },
d604 8
a611 8
  { "js",	Jb, XX, XX },
  { "jns",	Jb, XX, XX },
  { "jp",	Jb, XX, XX },
  { "jnp",	Jb, XX, XX },
  { "jl",	Jb, XX, XX },
  { "jge",	Jb, XX, XX },
  { "jle",	Jb, XX, XX },
  { "jg",	Jb, XX, XX },
d615 1
a615 1
  { "(bad)",	XX, XX, XX },
d617 4
a620 4
  { "test",	Eb, Gb, XX },
  { "test",	Ev, Gv, XX },
  { "xchg",	Eb, Gb, XX },
  { "xchg",	Ev, Gv, XX },
d622 8
a629 8
  { "mov",	Eb, Gb, XX },
  { "mov",	Ev, Gv, XX },
  { "mov",	Gb, Eb, XX },
  { "mov",	Gv, Ev, XX },
  { "mov",	Ev, Sw, XX },
  { "lea",	Gv, M, XX },
  { "mov",	Sw, Ev, XX },
  { "pop",	Ev, XX, XX },
d631 1
a631 1
  { "nop",	XX, XX, XX },
d633 7
a639 7
  { "xchg",	RMeCX, eAX, XX },
  { "xchg",	RMeDX, eAX, XX },
  { "xchg",	RMeBX, eAX, XX },
  { "xchg",	RMeSP, eAX, XX },
  { "xchg",	RMeBP, eAX, XX },
  { "xchg",	RMeSI, eAX, XX },
  { "xchg",	RMeDI, eAX, XX },
d641 8
a648 8
  { "cW",	XX, XX, XX },		/* cwde and cbw */
  { "cR",	XX, XX, XX },		/* cdq and cwd */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },		/* fwait */
  { "pushf",	XX, XX, XX },
  { "popf",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d650 8
a657 8
  { "mov",	AL, Ob, XX },
  { "mov",	eAX, Ov, XX },
  { "mov",	Ob, AL, XX },
  { "mov",	Ov, eAX, XX },
  { "movs",	Yb, Xb, XX },
  { "movs",	Yv, Xv, XX },
  { "cmps",	Xb, Yb, XX },
  { "cmps",	Xv, Yv, XX },
d659 8
a666 8
  { "test",	AL, Ib, XX },
  { "test",	eAX, Iv, XX },
  { "stos",	Yb, AL, XX },
  { "stos",	Yv, eAX, XX },
  { "lods",	AL, Xb, XX },
  { "lods",	eAX, Xv, XX },
  { "scas",	AL, Yb, XX },
  { "scas",	eAX, Yv, XX },
d668 8
a675 8
  { "mov",	RMAL, Ib, XX },
  { "mov",	RMCL, Ib, XX },
  { "mov",	RMDL, Ib, XX },
  { "mov",	RMBL, Ib, XX },
  { "mov",	RMAH, Ib, XX },
  { "mov",	RMCH, Ib, XX },
  { "mov",	RMDH, Ib, XX },
  { "mov",	RMBH, Ib, XX },
d677 8
a684 8
  { "mov",	RMeAX, Iv, XX },
  { "mov",	RMeCX, Iv, XX },
  { "mov",	RMeDX, Iv, XX },
  { "mov",	RMeBX, Iv, XX },
  { "mov",	RMeSP, Iv, XX },
  { "mov",	RMeBP, Iv, XX },
  { "mov",	RMeSI, Iv, XX },
  { "mov",	RMeDI, Iv, XX },
d688 6
a693 6
  { "ret",	Iw, XX, XX },
  { "ret",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "lds",	Gv, Mp, XX },
  { "mov",	Eb, Ib, XX },
  { "mov",	Ev, Iv, XX },
d695 8
a702 8
  { "enter",	Iw, Ib, XX },
  { "leave",	XX, XX, XX },
  { "lret",	Iw, XX, XX },
  { "lret",	XX, XX, XX },
  { "int3",	XX, XX, XX },
  { "int",	Ib, XX, XX },
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "iret",	XX, XX, XX },
d708 4
a711 4
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "xlat",	DSBX, XX, XX },
d722 8
a729 8
  { "loopne",	Jb, XX, XX },
  { "loope",	Jb, XX, XX },
  { "loop",	Jb, XX, XX },
  { "jEcxz",	Jb, XX, XX },
  { "in",	AL, Ib, XX },
  { "in",	eAX, Ib, XX },
  { "out",	Ib, AL, XX },
  { "out",	Ib, eAX, XX },
d731 8
a738 8
  { "call",	Jv, XX, XX },
  { "jmp",	Jv, XX, XX },
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "jmp",	Jb, XX, XX },
  { "in",	AL, indirDX, XX },
  { "in",	eAX, indirDX, XX },
  { "out",	indirDX, AL, XX },
  { "out",	indirDX, eAX, XX },
d740 6
a745 6
  { "(bad)",	XX, XX, XX },			/* lock prefix */
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },			/* repne */
  { "(bad)",	XX, XX, XX },			/* repz */
  { "hlt",	XX, XX, XX },
  { "cmc",	XX, XX, XX },
d749 6
a754 6
  { "clc",	XX, XX, XX },
  { "stc",	XX, XX, XX },
  { "cli",	XX, XX, XX },
  { "sti",	XX, XX, XX },
  { "cld",	XX, XX, XX },
  { "std",	XX, XX, XX },
d759 1
a759 1
static const struct dis386 dis386_twobyte_att[] = {
d763 6
a768 6
  { "larS", Gv, Ew, XX },
  { "lslS", Gv, Ew, XX },
  { "(bad)", XX, XX, XX },
  { "syscall", XX, XX, XX },
  { "clts", XX, XX, XX },
  { "sysretP", XX, XX, XX },
d770 5
a774 5
  { "invd", XX, XX, XX },
  { "wbinvd", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "ud2a", XX, XX, XX },
  { "(bad)", XX, XX, XX },
d776 2
a777 2
  { "femms", XX, XX, XX },
  { "", MX, EM, OPSUF }, /* See OP_3DNowSuffix */
d781 6
a786 6
  { "movlpX", XM, EX, SIMD_Fixup, 'h' },  /* really only 2 operands */
  { "movlpX", EX, XM, SIMD_Fixup, 'h' },
  { "unpcklpX", XM, EX, XX },
  { "unpckhpX", XM, EX, XX },
  { "movhpX", XM, EX, SIMD_Fixup, 'l' },
  { "movhpX", EX, XM, SIMD_Fixup, 'l' },
d789 7
a795 7
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
d797 8
a804 9
  /* these are all backward in appendix A of the intel book */
  { "movL", Rm, Cm, XX },
  { "movL", Rm, Dm, XX },
  { "movL", Cm, Rm, XX },
  { "movL", Dm, Rm, XX },
  { "movL", Rd, Td, XX },
  { "(bad)", XX, XX, XX },
  { "movL", Td, Rd, XX },
  { "(bad)", XX, XX, XX },
d806 2
a807 2
  { "movapX", XM, EX, XX },
  { "movapX", EX, XM, XX },
d809 1
a809 1
  { "movntpX", Ev, XM, XX },
d812 2
a813 2
  { "ucomisX", XM,EX, XX },
  { "comisX", XM,EX, XX },
d815 8
a822 8
  { "wrmsr", XX, XX, XX },
  { "rdtsc", XX, XX, XX },
  { "rdmsr", XX, XX, XX },
  { "rdpmc", XX, XX, XX },
  { "sysenter", XX, XX, XX },
  { "sysexit", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
d824 8
a831 8
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
d833 8
a840 8
  { "cmovo", Gv, Ev, XX },
  { "cmovno", Gv, Ev, XX },
  { "cmovb", Gv, Ev, XX },
  { "cmovae", Gv, Ev, XX },
  { "cmove", Gv, Ev, XX },
  { "cmovne", Gv, Ev, XX },
  { "cmovbe", Gv, Ev, XX },
  { "cmova", Gv, Ev, XX },
d842 8
a849 8
  { "cmovs", Gv, Ev, XX },
  { "cmovns", Gv, Ev, XX },
  { "cmovp", Gv, Ev, XX },
  { "cmovnp", Gv, Ev, XX },
  { "cmovl", Gv, Ev, XX },
  { "cmovge", Gv, Ev, XX },
  { "cmovle", Gv, Ev, XX },
  { "cmovg", Gv, Ev, XX },
d851 1
a851 1
  { "movmskpX", Gd, XS, XX },
d855 4
a858 4
  { "andpX", XM, EX, XX },
  { "andnpX", XM, EX, XX },
  { "orpX", XM, EX, XX },
  { "xorpX", XM, EX, XX },
d869 8
a876 8
  { "punpcklbw", MX, EM, XX },
  { "punpcklwd", MX, EM, XX },
  { "punpckldq", MX, EM, XX },
  { "packsswb", MX, EM, XX },
  { "pcmpgtb", MX, EM, XX },
  { "pcmpgtw", MX, EM, XX },
  { "pcmpgtd", MX, EM, XX },
  { "packuswb", MX, EM, XX },
d878 4
a881 4
  { "punpckhbw", MX, EM, XX },
  { "punpckhwd", MX, EM, XX },
  { "punpckhdq", MX, EM, XX },
  { "packssdw", MX, EM, XX },
d884 1
a884 1
  { "movd", MX, Ed, XX },
d891 4
a894 4
  { "pcmpeqb", MX, EM, XX },
  { "pcmpeqw", MX, EM, XX },
  { "pcmpeqd", MX, EM, XX },
  { "emms", XX, XX, XX },
d896 6
a901 6
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
d905 8
a912 8
  { "jo",  Jv, cond_jump_flag, XX },
  { "jno", Jv, cond_jump_flag, XX },
  { "jb",  Jv, cond_jump_flag, XX },
  { "jae", Jv, cond_jump_flag, XX },
  { "je",  Jv, cond_jump_flag, XX },
  { "jne", Jv, cond_jump_flag, XX },
  { "jbe", Jv, cond_jump_flag, XX },
  { "ja",  Jv, cond_jump_flag, XX },
d914 8
a921 8
  { "js",  Jv, cond_jump_flag, XX },
  { "jns", Jv, cond_jump_flag, XX },
  { "jp",  Jv, cond_jump_flag, XX },
  { "jnp", Jv, cond_jump_flag, XX },
  { "jl",  Jv, cond_jump_flag, XX },
  { "jge", Jv, cond_jump_flag, XX },
  { "jle", Jv, cond_jump_flag, XX },
  { "jg",  Jv, cond_jump_flag, XX },
d923 8
a930 8
  { "seto", Eb, XX, XX },
  { "setno", Eb, XX, XX },
  { "setb", Eb, XX, XX },
  { "setae", Eb, XX, XX },
  { "sete", Eb, XX, XX },
  { "setne", Eb, XX, XX },
  { "setbe", Eb, XX, XX },
  { "seta", Eb, XX, XX },
d932 8
a939 8
  { "sets", Eb, XX, XX },
  { "setns", Eb, XX, XX },
  { "setp", Eb, XX, XX },
  { "setnp", Eb, XX, XX },
  { "setl", Eb, XX, XX },
  { "setge", Eb, XX, XX },
  { "setle", Eb, XX, XX },
  { "setg", Eb, XX, XX },
d941 9
a949 8
  { "pushI", fs, XX, XX },
  { "popI", fs, XX, XX },
  { "cpuid", XX, XX, XX },
  { "btS", Ev, Gv, XX },
  { "shldS", Ev, Gv, Ib },
  { "shldS", Ev, Gv, CL },
  { "(bad)", XX, XX, XX },
  { "", OPXCRYPT, XX, XX },
d951 6
a956 6
  { "pushI", gs, XX, XX },
  { "popI", gs, XX, XX },
  { "rsm", XX, XX, XX },
  { "btsS", Ev, Gv, XX },
  { "shrdS", Ev, Gv, Ib },
  { "shrdS", Ev, Gv, CL },
d958 1
a958 1
  { "imulS", Gv, Ev, XX },
d960 8
a967 8
  { "cmpxchgB", Eb, Gb, XX },
  { "cmpxchgS", Ev, Gv, XX },
  { "lssS", Gv, Mp, XX },
  { "btrS", Ev, Gv, XX },
  { "lfsS", Gv, Mp, XX },
  { "lgsS", Gv, Mp, XX },
  { "movzbR", Gv, Eb, XX },
  { "movzwR", Gv, Ew, XX }, /* yes, there really is movzww ! */
d969 2
a970 2
  { "(bad)", XX, XX, XX },
  { "ud2b", XX, XX, XX },
d972 5
a976 5
  { "btcS", Ev, Gv, XX },
  { "bsfS", Gv, Ev, XX },
  { "bsrS", Gv, Ev, XX },
  { "movsbR", Gv, Eb, XX },
  { "movswR", Gv, Ew, XX }, /* yes, there really is movsww ! */
d978 2
a979 2
  { "xaddB", Eb, Gb, XX },
  { "xaddS", Ev, Gv, XX },
d981 4
a984 4
  { "movntiS", Ev, Gv, XX },
  { "pinsrw", MX, Ed, Ib },
  { "pextrw", Gd, MS, Ib },
  { "shufpX", XM, EX, Ib },
d987 8
a994 8
  { "bswap", RMeAX, XX, XX },	/* bswap doesn't support 16 bit regs */
  { "bswap", RMeCX, XX, XX },
  { "bswap", RMeDX, XX, XX },
  { "bswap", RMeBX, XX, XX },
  { "bswap", RMeSP, XX, XX },
  { "bswap", RMeBP, XX, XX },
  { "bswap", RMeSI, XX, XX },
  { "bswap", RMeDI, XX, XX },
d996 6
a1001 6
  { "(bad)", XX, XX, XX },
  { "psrlw", MX, EM, XX },
  { "psrld", MX, EM, XX },
  { "psrlq", MX, EM, XX },
  { "paddq", MX, EM, XX },
  { "pmullw", MX, EM, XX },
d1003 1
a1003 1
  { "pmovmskb", Gd, MS, XX },
d1005 8
a1012 8
  { "psubusb", MX, EM, XX },
  { "psubusw", MX, EM, XX },
  { "pminub", MX, EM, XX },
  { "pand", MX, EM, XX },
  { "paddusb", MX, EM, XX },
  { "paddusw", MX, EM, XX },
  { "pmaxub", MX, EM, XX },
  { "pandn", MX, EM, XX },
d1014 6
a1019 6
  { "pavgb", MX, EM, XX },
  { "psraw", MX, EM, XX },
  { "psrad", MX, EM, XX },
  { "pavgw", MX, EM, XX },
  { "pmulhuw", MX, EM, XX },
  { "pmulhw", MX, EM, XX },
d1023 8
a1030 8
  { "psubsb", MX, EM, XX },
  { "psubsw", MX, EM, XX },
  { "pminsw", MX, EM, XX },
  { "por", MX, EM, XX },
  { "paddsb", MX, EM, XX },
  { "paddsw", MX, EM, XX },
  { "pmaxsw", MX, EM, XX },
  { "pxor", MX, EM, XX },
d1032 7
a1038 7
  { "(bad)", XX, XX, XX },
  { "psllw", MX, EM, XX },
  { "pslld", MX, EM, XX },
  { "psllq", MX, EM, XX },
  { "pmuludq", MX, EM, XX },
  { "pmaddwd", MX, EM, XX },
  { "psadbw", MX, EM, XX },
d1041 8
a1048 300
  { "psubb", MX, EM, XX },
  { "psubw", MX, EM, XX },
  { "psubd", MX, EM, XX },
  { "psubq", MX, EM, XX },
  { "paddb", MX, EM, XX },
  { "paddw", MX, EM, XX },
  { "paddd", MX, EM, XX },
  { "(bad)", XX, XX, XX }
};

static const struct dis386 dis386_twobyte_intel[] = {
  /* 00 */
  { GRP6 },
  { GRP7 },
  { "lar", Gv, Ew, XX },
  { "lsl", Gv, Ew, XX },
  { "(bad)", XX, XX, XX },
  { "syscall", XX, XX, XX },
  { "clts", XX, XX, XX },
  { "sysretP", XX, XX, XX },
  /* 08 */
  { "invd", XX, XX, XX },
  { "wbinvd", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "ud2a", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { GRPAMD },
  { "femms" , XX, XX, XX},
  { "", MX, EM, OPSUF }, /* See OP_3DNowSuffix */
  /* 10 */
  { PREGRP8 },
  { PREGRP9 },
  { "movlpX", XM, EX, SIMD_Fixup, 'h' },  /* really only 2 operands */
  { "movlpX", EX, XM, SIMD_Fixup, 'h' },
  { "unpcklpX", XM, EX, XX },
  { "unpckhpX", XM, EX, XX },
  { "movhpX", XM, EX, SIMD_Fixup, 'l' },
  { "movhpX", EX, XM, SIMD_Fixup, 'l' },
  /* 18 */
  { GRP14 },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  /* 20 */
  /* these are all backward in appendix A of the intel book */
  { "mov", Rm, Cm, XX },
  { "mov", Rm, Dm, XX },
  { "mov", Cm, Rm, XX },
  { "mov", Dm, Rm, XX },
  { "mov", Rd, Td, XX },
  { "(bad)", XX, XX, XX },
  { "mov", Td, Rd, XX },
  { "(bad)", XX, XX, XX },
  /* 28 */
  { "movapX", XM, EX, XX },
  { "movapX", EX, XM, XX },
  { PREGRP2 },
  { "movntpX", Ev, XM, XX },
  { PREGRP4 },
  { PREGRP3 },
  { "ucomisX", XM,EX, XX },
  { "comisX", XM,EX, XX },
  /* 30 */
  { "wrmsr", XX, XX, XX },
  { "rdtsc", XX, XX, XX },
  { "rdmsr", XX, XX, XX },
  { "rdpmc", XX, XX, XX },
  { "sysenter", XX, XX, XX },
  { "sysexit", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  /* 38 */
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  /* 40 */
  { "cmovo", Gv, Ev, XX },
  { "cmovno", Gv, Ev, XX },
  { "cmovb", Gv, Ev, XX },
  { "cmovae", Gv, Ev, XX },
  { "cmove", Gv, Ev, XX },
  { "cmovne", Gv, Ev, XX },
  { "cmovbe", Gv, Ev, XX },
  { "cmova", Gv, Ev, XX },
  /* 48 */
  { "cmovs", Gv, Ev, XX },
  { "cmovns", Gv, Ev, XX },
  { "cmovp", Gv, Ev, XX },
  { "cmovnp", Gv, Ev, XX },
  { "cmovl", Gv, Ev, XX },
  { "cmovge", Gv, Ev, XX },
  { "cmovle", Gv, Ev, XX },
  { "cmovg", Gv, Ev, XX },
  /* 50 */
  { "movmskpX", Gd, XS, XX },
  { PREGRP13 },
  { PREGRP12 },
  { PREGRP11 },
  { "andpX", XM, EX, XX },
  { "andnpX", XM, EX, XX },
  { "orpX", XM, EX, XX },
  { "xorpX", XM, EX, XX },
  /* 58 */
  { PREGRP0 },
  { PREGRP10 },
  { PREGRP17 },
  { PREGRP16 },
  { PREGRP14 },
  { PREGRP7 },
  { PREGRP5 },
  { PREGRP6 },
  /* 60 */
  { "punpcklbw", MX, EM, XX },
  { "punpcklwd", MX, EM, XX },
  { "punpckldq", MX, EM, XX },
  { "packsswb", MX, EM, XX },
  { "pcmpgtb", MX, EM, XX },
  { "pcmpgtw", MX, EM, XX },
  { "pcmpgtd", MX, EM, XX },
  { "packuswb", MX, EM, XX },
  /* 68 */
  { "punpckhbw", MX, EM, XX },
  { "punpckhwd", MX, EM, XX },
  { "punpckhdq", MX, EM, XX },
  { "packssdw", MX, EM, XX },
  { PREGRP26 },
  { PREGRP24 },
  { "movd", MX, Ed, XX },
  { PREGRP19 },
  /* 70 */
  { PREGRP22 },
  { GRP10 },
  { GRP11 },
  { GRP12 },
  { "pcmpeqb", MX, EM, XX },
  { "pcmpeqw", MX, EM, XX },
  { "pcmpeqd", MX, EM, XX },
  { "emms", XX, XX, XX },
  /* 78 */
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { PREGRP23 },
  { PREGRP20 },
  /* 80 */
  { "jo", Jv, XX, XX },
  { "jno", Jv, XX, XX },
  { "jb", Jv, XX, XX },
  { "jae", Jv, XX, XX },
  { "je", Jv, XX, XX },
  { "jne", Jv, XX, XX },
  { "jbe", Jv, XX, XX },
  { "ja", Jv, XX, XX },
  /* 88 */
  { "js", Jv, XX, XX },
  { "jns", Jv, XX, XX },
  { "jp", Jv, XX, XX },
  { "jnp", Jv, XX, XX },
  { "jl", Jv, XX, XX },
  { "jge", Jv, XX, XX },
  { "jle", Jv, XX, XX },
  { "jg", Jv, XX, XX },
  /* 90 */
  { "seto", Eb, XX, XX },
  { "setno", Eb, XX, XX },
  { "setb", Eb, XX, XX },
  { "setae", Eb, XX, XX },
  { "sete", Eb, XX, XX },
  { "setne", Eb, XX, XX },
  { "setbe", Eb, XX, XX },
  { "seta", Eb, XX, XX },
  /* 98 */
  { "sets", Eb, XX, XX },
  { "setns", Eb, XX, XX },
  { "setp", Eb, XX, XX },
  { "setnp", Eb, XX, XX },
  { "setl", Eb, XX, XX },
  { "setge", Eb, XX, XX },
  { "setle", Eb, XX, XX },
  { "setg", Eb, XX, XX },
  /* a0 */
  { "push", fs, XX, XX },
  { "pop", fs, XX, XX },
  { "cpuid", XX, XX, XX },
  { "bt", Ev, Gv, XX },
  { "shld", Ev, Gv, Ib },
  { "shld", Ev, Gv, CL },
  { "(bad)", XX, XX, XX },
  { "", OPXCRYPT, XX, XX },
  /* a8 */
  { "push", gs, XX, XX },
  { "pop", gs, XX, XX },
  { "rsm" , XX, XX, XX},
  { "bts", Ev, Gv, XX },
  { "shrd", Ev, Gv, Ib },
  { "shrd", Ev, Gv, CL },
  { GRP13 },
  { "imul", Gv, Ev, XX },
  /* b0 */
  { "cmpxchg", Eb, Gb, XX },
  { "cmpxchg", Ev, Gv, XX },
  { "lss", Gv, Mp, XX },
  { "btr", Ev, Gv, XX },
  { "lfs", Gv, Mp, XX },
  { "lgs", Gv, Mp, XX },
  { "movzx", Gv, Eb, XX },
  { "movzx", Gv, Ew, XX },
  /* b8 */
  { "(bad)", XX, XX, XX },
  { "ud2b", XX, XX, XX },
  { GRP8 },
  { "btc", Ev, Gv, XX },
  { "bsf", Gv, Ev, XX },
  { "bsr", Gv, Ev, XX },
  { "movsx", Gv, Eb, XX },
  { "movsx", Gv, Ew, XX },
  /* c0 */
  { "xadd", Eb, Gb, XX },
  { "xadd", Ev, Gv, XX },
  { PREGRP1 },
  { "movnti", Ev, Gv, XX },
  { "pinsrw", MX, Ed, Ib },
  { "pextrw", Gd, MS, Ib },
  { "shufpX", XM, EX, Ib },
  { GRP9 },
  /* c8 */
  { "bswap", RMeAX, XX, XX },	/* bswap doesn't support 16 bit regs */
  { "bswap", RMeCX, XX, XX },
  { "bswap", RMeDX, XX, XX },
  { "bswap", RMeBX, XX, XX },
  { "bswap", RMeSP, XX, XX },
  { "bswap", RMeBP, XX, XX },
  { "bswap", RMeSI, XX, XX },
  { "bswap", RMeDI, XX, XX },
  /* d0 */
  { "(bad)", XX, XX, XX },
  { "psrlw", MX, EM, XX },
  { "psrld", MX, EM, XX },
  { "psrlq", MX, EM, XX },
  { "paddq", MX, EM, XX },
  { "pmullw", MX, EM, XX },
  { PREGRP21 },
  { "pmovmskb", Gd, MS, XX },
  /* d8 */
  { "psubusb", MX, EM, XX },
  { "psubusw", MX, EM, XX },
  { "pminub", MX, EM, XX },
  { "pand", MX, EM, XX },
  { "paddusb", MX, EM, XX },
  { "paddusw", MX, EM, XX },
  { "pmaxub", MX, EM, XX },
  { "pandn", MX, EM, XX },
  /* e0 */
  { "pavgb", MX, EM, XX },
  { "psraw", MX, EM, XX },
  { "psrad", MX, EM, XX },
  { "pavgw", MX, EM, XX },
  { "pmulhuw", MX, EM, XX },
  { "pmulhw", MX, EM, XX },
  { PREGRP15 },
  { PREGRP25 },
  /* e8 */
  { "psubsb", MX, EM, XX },
  { "psubsw", MX, EM, XX },
  { "pminsw", MX, EM, XX },
  { "por", MX, EM, XX },
  { "paddsb", MX, EM, XX },
  { "paddsw", MX, EM, XX },
  { "pmaxsw", MX, EM, XX },
  { "pxor", MX, EM, XX },
  /* f0 */
  { "(bad)", XX, XX, XX },
  { "psllw", MX, EM, XX },
  { "pslld", MX, EM, XX },
  { "psllq", MX, EM, XX },
  { "pmuludq", MX, EM, XX },
  { "pmaddwd", MX, EM, XX },
  { "psadbw", MX, EM, XX },
  { PREGRP18 },
  /* f8 */
  { "psubb", MX, EM, XX },
  { "psubw", MX, EM, XX },
  { "psubd", MX, EM, XX },
  { "psubq", MX, EM, XX },
  { "paddb", MX, EM, XX },
  { "paddw", MX, EM, XX },
  { "paddd", MX, EM, XX },
  { "(bad)", XX, XX, XX }
a1130 1
static void oappend PARAMS ((const char *s));
d1137 36
a1172 2
static const char *names64[] = {
  "%rax","%rcx","%rdx","%rbx", "%rsp","%rbp","%rsi","%rdi",
d1175 2
a1176 2
static const char *names32[] = {
  "%eax","%ecx","%edx","%ebx", "%esp","%ebp","%esi","%edi",
d1179 2
a1180 2
static const char *names16[] = {
  "%ax","%cx","%dx","%bx","%sp","%bp","%si","%di",
d1183 2
a1184 2
static const char *names8[] = {
  "%al","%cl","%dl","%bl","%ah","%ch","%dh","%bh",
d1186 2
a1187 2
static const char *names8rex[] = {
  "%al","%cl","%dl","%bl","%spl", "%bpl", "%sil", "%dil",
d1190 2
a1191 2
static const char *names_seg[] = {
  "%es","%cs","%ss","%ds","%fs","%gs","%?","%?",
d1193 2
a1194 2
static const char *index16[] = {
  "%bx,%si","%bx,%di","%bp,%si","%bp,%di","%si","%di","%bp","%bx"
d1303 4
a1306 4
    { "mulB",	AL, Eb, XX },
    { "imulB",	AL, Eb, XX },
    { "divB",	AL, Eb, XX },
    { "idivB",	AL, Eb, XX }
d1314 4
a1317 4
    { "mulS",	eAX, Ev, XX },
    { "imulS",	eAX, Ev, XX },
    { "divS",	eAX, Ev, XX },
    { "idivS",	eAX, Ev, XX },
d1334 5
a1338 5
    { "callI",	indirEv, XX, XX },
    { "lcallI",	indirEv, XX, XX },
    { "jmpI",	indirEv, XX, XX },
    { "ljmpI",	indirEv, XX, XX },
    { "pushT",	Ev, XX, XX },
d1343 2
a1344 2
    { "sldt",	Ew, XX, XX },
    { "str",	Ew, XX, XX },
d1354 8
a1361 8
    { "sgdt", Ew, XX, XX },
    { "sidt", Ew, XX, XX },
    { "lgdt", Ew, XX, XX },
    { "lidt", Ew, XX, XX },
    { "smsw", Ew, XX, XX },
    { "(bad)", XX, XX, XX },
    { "lmsw", Ew, XX, XX },
    { "invlpg", Ew, XX, XX },
d1428 1
a1428 1
    /* FIXME: the sfence with memory operand is clflush! */
a1451 1

d1464 1
a1464 1
    { "", XM, EX, OPSIMD },	/* See OP_SIMD_SUFFIX */
d1618 1
a1618 1
    { "movd", Ed, MX, XX },
d1620 1
a1620 1
    { "movd", Ed, XM, XX },
d1646 7
d1814 4
a1817 1
      return (sizeflag & AFLAG) ? "addr16" : "addr32";
d1827 2
a1828 2
static unsigned int op_address[3];
static unsigned int op_riprel[3];
a1829 1

a1839 3
static int print_insn_i386
  PARAMS ((bfd_vma pc, disassemble_info *info));

d1846 3
a1854 4
  open_char = '(';
  close_char =  ')';
  separator_char = ',';
  scale_char = ',';
d1856 1
a1856 1
  return print_insn_i386 (pc, info);
a1864 4
  open_char = '[';
  close_char = ']';
  separator_char = '+';
  scale_char = '*';
d1866 11
a1876 1
  return print_insn_i386 (pc, info);
d1880 1
a1880 1
print_insn_i386 (pc, info)
d1890 2
a1891 3
  VOLATILE int sizeflag;
  VOLATILE int orig_sizeflag;

a1892 1
  bfd_byte *inbuf = priv.the_buffer;
d1897 75
a1971 7
  if (info->mach == bfd_mach_i386_i386
      || info->mach == bfd_mach_x86_64
      || info->mach == bfd_mach_i386_i386_intel_syntax
      || info->mach == bfd_mach_x86_64_intel_syntax)
    sizeflag = AFLAG|DFLAG;
  else if (info->mach == bfd_mach_i386_i8086)
    sizeflag = 0;
d1973 13
a1985 2
    abort ();
  orig_sizeflag = sizeflag;
d2004 2
a2005 2
  start_codep = inbuf;
  codep = inbuf;
d2012 3
a2014 3
         means we have an incomplete instruction of some sort.  Just
         print the first byte as a prefix or a .byte pseudo-op.  */
      if (codep > inbuf)
d2016 1
a2016 1
	  name = prefix_name (inbuf[0], orig_sizeflag);
d2023 1
a2023 1
				     (unsigned int) inbuf[0]);
d2036 1
d2047 2
a2048 2
         first prefix, which is probably fwait itself.  */
      name = prefix_name (inbuf[0], orig_sizeflag);
d2058 1
a2058 4
      if (intel_syntax)
        dp = &dis386_twobyte_intel[*++codep];
      else
        dp = &dis386_twobyte_att[*++codep];
d2064 1
a2064 10
      if (intel_syntax)
	if (mode_64bit)
	  dp = &dis386_64_intel[*codep];
	else
	  dp = &dis386_intel[*codep];
      else
	if (mode_64bit)
	  dp = &disx86_64_att[*codep];
	else
	  dp = &dis386_att[*codep];
d2089 1
a2089 1
      if (dp->bytemode2 != loop_jcxz_mode)
d2091 1
a2091 1
	  if (sizeflag & AFLAG)
d2102 3
a2104 1
      if (dp->bytemode2 == cond_jump_mode && dp->bytemode1 == v_mode)
a2113 14
  if (dp->bytemode2 == cond_jump_mode || dp->bytemode2 == loop_jcxz_mode)
    {
      if ((prefixes & (PREFIX_CS | PREFIX_DS)) == PREFIX_CS)
	{
	  oappend ("cs ");
	  used_prefixes |= PREFIX_CS;
	}
      if ((prefixes & (PREFIX_CS | PREFIX_DS)) == PREFIX_DS)
	{
	  oappend ("ds ");
	  used_prefixes |= PREFIX_DS;
	}
    }

d2131 1
a2131 1
	  switch(dp->bytemode2)
d2133 31
a2163 25
	      case USE_GROUPS:
	        dp = &grps[dp->bytemode1][reg];
		break;
	      case USE_PREFIX_USER_TABLE:
		index = 0;
		used_prefixes |= (prefixes & PREFIX_REPZ);
		if (prefixes & PREFIX_REPZ)
		  index = 1;
		else
		  {
		    used_prefixes |= (prefixes & PREFIX_DATA);
		    if (prefixes & PREFIX_DATA)
		      index = 2;
		    else
		      {
			used_prefixes |= (prefixes & PREFIX_REPNZ);
			if (prefixes & PREFIX_REPNZ)
			  index = 3;
		      }
		  }
		dp = &prefix_user_table[dp->bytemode1][index];
		break;
	      default:
		oappend (INTERNAL_DISASSEMBLER_ERROR);
		break;
d2167 17
a2183 16
      putop (dp->name, sizeflag);

      obufp = op1out;
      op_ad = 2;
      if (dp->op1)
	(*dp->op1)(dp->bytemode1, sizeflag);

      obufp = op2out;
      op_ad = 1;
      if (dp->op2)
	(*dp->op2)(dp->bytemode2, sizeflag);

      obufp = op3out;
      op_ad = 0;
      if (dp->op3)
	(*dp->op3)(dp->bytemode3, sizeflag);
d2194 1
a2194 1
      name = prefix_name (inbuf[0], orig_sizeflag);
d2203 1
a2203 1
      name = prefix_name (rex | 0x40, orig_sizeflag);
d2267 1
a2267 1
  return codep - inbuf;
d2270 1
a2270 1
static const char *float_mem_att[] = {
d2272 10
a2281 85
  "fadds",
  "fmuls",
  "fcoms",
  "fcomps",
  "fsubs",
  "fsubrs",
  "fdivs",
  "fdivrs",
  /*  d9 */
  "flds",
  "(bad)",
  "fsts",
  "fstps",
  "fldenv",
  "fldcw",
  "fNstenv",
  "fNstcw",
  /* da */
  "fiaddl",
  "fimull",
  "ficoml",
  "ficompl",
  "fisubl",
  "fisubrl",
  "fidivl",
  "fidivrl",
  /* db */
  "fildl",
  "(bad)",
  "fistl",
  "fistpl",
  "(bad)",
  "fldt",
  "(bad)",
  "fstpt",
  /* dc */
  "faddl",
  "fmull",
  "fcoml",
  "fcompl",
  "fsubl",
  "fsubrl",
  "fdivl",
  "fdivrl",
  /* dd */
  "fldl",
  "(bad)",
  "fstl",
  "fstpl",
  "frstor",
  "(bad)",
  "fNsave",
  "fNstsw",
  /* de */
  "fiadd",
  "fimul",
  "ficom",
  "ficomp",
  "fisub",
  "fisubr",
  "fidiv",
  "fidivr",
  /* df */
  "fild",
  "(bad)",
  "fist",
  "fistp",
  "fbld",
  "fildll",
  "fbstp",
  "fistpll",
};

static const char *float_mem_intel[] = {
  /* d8 */
  "fadd",
  "fmul",
  "fcom",
  "fcomp",
  "fsub",
  "fsubr",
  "fdiv",
  "fdivr",
  /*  d9 */
  "fld",
d2283 2
a2284 2
  "fst",
  "fstp",
d2290 8
a2297 8
  "fiadd",
  "fimul",
  "ficom",
  "ficomp",
  "fisub",
  "fisubr",
  "fidiv",
  "fidivr",
d2299 1
a2299 1
  "fild",
d2301 2
a2302 2
  "fist",
  "fistp",
d2304 1
a2304 1
  "fld",
d2306 1
a2306 1
  "fstp",
d2308 8
a2315 8
  "fadd",
  "fmul",
  "fcom",
  "fcomp",
  "fsub",
  "fsubr",
  "fdiv",
  "fdivr",
d2317 1
a2317 1
  "fld",
d2319 2
a2320 2
  "fst",
  "fstp",
d2340 1
a2340 1
  "fild",
a2462 1

d2522 1
a2522 4
      if (intel_syntax)
        putop (float_mem_intel[(floatop - 0xd8 ) * 8 + reg], sizeflag);
      else
        putop (float_mem_att[(floatop - 0xd8 ) * 8 + reg], sizeflag);
d2525 1
a2525 1
        OP_E (x_mode, sizeflag);
d2527 1
a2527 1
        OP_E (d_mode, sizeflag);
d2529 1
a2529 1
        OP_E (v_mode, sizeflag);
d2532 1
a2532 1
  /* skip mod/rm byte */
d2541 1
a2541 1
      /* instruction fnstsw is only one with strange arg */
d2551 1
a2551 1
	(*dp->op1)(dp->bytemode1, sizeflag);
d2554 1
a2554 1
	(*dp->op2)(dp->bytemode2, sizeflag);
a2557 1
/* ARGSUSED */
d2559 2
a2560 2
OP_ST (ignore, sizeflag)
     int ignore ATTRIBUTE_UNUSED;
a2565 1
/* ARGSUSED */
d2567 2
a2568 2
OP_STi (ignore, sizeflag)
     int ignore ATTRIBUTE_UNUSED;
d2572 1
a2572 1
  oappend (scratchbuf);
d2575 2
a2576 3

/* capital letters in template are macros */
static void
d2582 1
d2591 32
d2624 3
a2626 7
          if (intel_syntax)
            break;
	  if (mod != 3
#ifdef SUFFIX_ALWAYS
	      || (sizeflag & SUFFIX_ALWAYS)
#endif
	      )
d2630 2
a2631 3
          if (intel_syntax)
            break;
#ifdef SUFFIX_ALWAYS
a2633 1
#endif
d2636 10
a2645 2
	  if (sizeflag & AFLAG)
	    *obufp++ = 'e';
d2649 3
a2651 5
	  if ((prefixes & PREFIX_ADDR)
#ifdef SUFFIX_ALWAYS
	      || (sizeflag & SUFFIX_ALWAYS)
#endif
	      )
d2654 1
a2654 1
		*obufp++ = 'l';
d2656 1
a2656 1
		*obufp++ = 'w';
d2660 5
a2664 6
	case 'I':
          if (intel_syntax)
            break;
	  if (mode_64bit)
	    *obufp++ = 'q';
	  else
d2666 7
a2672 12
	      if ((prefixes & PREFIX_DATA)
#ifdef SUFFIX_ALWAYS
		  || (sizeflag & SUFFIX_ALWAYS)
#endif
		  )
		{
		  if (sizeflag & DFLAG)
		    *obufp++ = 'l';
		  else
		    *obufp++ = 'w';
		  used_prefixes |= (prefixes & PREFIX_DATA);
	      }
d2676 2
a2677 3
          if (intel_syntax)
            break;
#ifdef SUFFIX_ALWAYS
a2679 1
#endif
d2690 1
a2690 1
	      *obufp++ = 'o';
d2694 9
d2704 2
a2705 2
          if (intel_syntax)
            break;
d2708 1
a2708 4
#ifdef SUFFIX_ALWAYS
	      || (sizeflag & SUFFIX_ALWAYS)
#endif
	      )
d2723 9
d2733 2
a2734 2
          if (intel_syntax)
            break;
d2736 1
a2736 5
	  if (mod != 3
#ifdef SUFFIX_ALWAYS
	      || (sizeflag & SUFFIX_ALWAYS)
#endif
	      )
d2752 1
a2752 1
          if (intel_syntax)
d2783 2
a2784 3
          if (intel_syntax)
            break;
#ifdef SUFFIX_ALWAYS
a2797 19
#endif
	  break;
	case 'T':
          if (intel_syntax)
            break;
	  if (mode_64bit)
	    *obufp++ = 'q';
	  else if (mod != 3
#ifdef SUFFIX_ALWAYS
		   || (sizeflag & SUFFIX_ALWAYS)
#endif
		  )
	    {
	      if (sizeflag & DFLAG)
		*obufp++ = 'l';
	      else
		*obufp++ = 'w';
	      used_prefixes |= (prefixes & PREFIX_DATA);
	    }
d2804 1
a2804 1
          used_prefixes |= (prefixes & PREFIX_DATA);
d2807 2
a2808 2
          if (intel_syntax)
            break;
d2825 1
a2825 1
          if (intel_syntax)
d2848 1
a2863 1
      oappend ("%cs:");
d2865 1
a2868 1
      oappend ("%ds:");
d2870 1
a2873 1
      oappend ("%ss:");
d2875 1
a2878 1
      oappend ("%es:");
d2880 1
a2883 1
      oappend ("%fs:");
d2885 1
a2888 1
      oappend ("%gs:");
d2890 1
d2919 1
a2919 1
	  for (i = 0; tmp[i] == '0' && tmp[i+1]; i++);
d2931 1
a2931 1
	      /* Check for possible overflow on 0x8000000000000000 */
d2948 1
a2948 1
	      tmp[28-i] = (v % 10) + '0';
d2976 1
a2976 1
  /* skip mod/rm byte */
d3007 1
d3011 1
a3011 1
	  else if (sizeflag & DFLAG)
d3018 1
a3018 1
	  if ( !(codep[-2] == 0xAE && codep[-1] == 0xF8 /* sfence */)
d3021 1
a3021 1
	    BadOp();	/* bad sfence,lea,lds,les,lfs,lgs,lss modrm */
d3033 1
a3033 1
  if (sizeflag & AFLAG) /* 32 bit address mode */
d3067 1
a3067 1
	      if (mode_64bit && !havesib)
d3084 2
a3085 2
        if (mod != 0 || (base & 7) == 5)
          {
d3087 1
a3087 1
            oappend (scratchbuf);
d3093 1
a3093 1
          }
d3097 17
a3113 17
          if (intel_syntax)
            {
              switch (bytemode)
                {
                case b_mode:
                  oappend ("BYTE PTR ");
                  break;
                case w_mode:
                  oappend ("WORD PTR ");
                  break;
                case v_mode:
                  oappend ("DWORD PTR ");
                  break;
                case d_mode:
                  oappend ("QWORD PTR ");
                  break;
                case m_mode:
d3119 7
a3125 7
                case x_mode:
                  oappend ("XWORD PTR ");
                  break;
                default:
                  break;
                }
             }
d3129 1
a3129 1
          *obufp = '\0';
d3134 2
a3135 1
	    oappend (mode_64bit ? names64[base] : names32[base]);
d3140 26
a3165 11
                  if (intel_syntax)
                    {
                      if (havebase)
                        {
                          *obufp++ = separator_char;
                          *obufp = '\0';
                        }
                      sprintf (scratchbuf, "%s", mode_64bit ? names64[index] : names32[index]);
                    }
                  else
		    sprintf (scratchbuf, ",%s", mode_64bit ? names64[index] : names32[index]);
a3167 11
              if (!intel_syntax
                  || (intel_syntax
                      && bytemode != b_mode
                      && bytemode != w_mode
                      && bytemode != v_mode))
                {
                  *obufp++ = scale_char;
                  *obufp = '\0';
	          sprintf (scratchbuf, "%d", 1 << scale);
	          oappend (scratchbuf);
                }
d3169 12
a3180 6
          if (intel_syntax)
            if (mod != 0 || (base & 7) == 5)
              {
                /* Don't print zero displacements */
                if (disp != 0)
                  {
d3182 3
a3184 3
                    oappend (scratchbuf);
                  }
              }
d3187 1
a3187 1
          *obufp = '\0';
d3190 3
a3192 3
        {
          if (mod != 0 || (base & 7) == 5)
            {
d3198 1
a3198 1
		  oappend (names_seg[3]);
d3202 3
a3204 3
              oappend (scratchbuf);
            }
        }
d3232 2
a3233 2
        if (mod != 0 || (rm & 7) == 6)
          {
d3235 2
a3236 2
            oappend (scratchbuf);
          }
d3241 1
a3241 1
          *obufp = '\0';
d3243 2
a3244 2
          *obufp++ = close_char;
          *obufp = '\0';
d3295 4
a3298 3
  unsigned int a = 0;
  unsigned int b = 0;
  bfd_vma x = 0;
a3299 1
#ifdef BFD64
d3305 1
a3305 1
  b |= (*codep++ & 0xff);
d3311 2
a3312 1
  abort();
d3359 1
a3359 1
     unsigned int op;
d3363 11
a3373 2
  op_address[op_ad] = op;
  op_riprel[op_ad] = riprel;
d3390 4
a3393 1
      s = "(%dx)";
d3411 9
a3430 4
    case rAX_reg: case rCX_reg: case rDX_reg: case rBX_reg:
    case rSP_reg: case rBP_reg: case rSI_reg: case rDI_reg:
      s = names64[code - rAX_reg + add];
      break;
d3448 4
a3451 1
      s = "(%dx)";
d3503 6
a3508 2
      op = get32s ();
      break;
d3536 2
a3537 2
  print_operand_value (scratchbuf + !intel_syntax, 1, op);
  oappend (scratchbuf);
d3549 6
d3589 2
a3590 2
  print_operand_value (scratchbuf + !intel_syntax, 1, op);
  oappend (scratchbuf);
d3623 1
a3623 1
	  op = get16();
d3642 1
a3642 1
  oappend (scratchbuf);
d3651 1
a3651 1
  int mask = -1;
d3667 1
a3667 1
	  /* for some reason, a data16 prefix on a jump instruction
a3682 1
/* ARGSUSED */
d3688 1
a3688 5
  static char *sreg[] = {
    "%es","%cs","%ss","%ds","%fs","%gs","%?","%?",
  };

  oappend (sreg[reg]);
a3690 1
/* ARGSUSED */
d3709 4
a3712 1
  sprintf (scratchbuf, "$0x%x,$0x%x", seg, offset);
a3715 1
/* ARGSUSED */
d3717 2
a3718 2
OP_OFF (ignored, sizeflag)
     int ignored ATTRIBUTE_UNUSED;
d3725 1
a3725 1
  if (sizeflag & AFLAG)
d3733 1
a3733 1
		        | PREFIX_ES | PREFIX_FS | PREFIX_GS)))
d3735 1
a3735 1
	  oappend (names_seg[3]);
d3742 1
a3742 1
/* ARGSUSED */
d3744 2
a3745 2
OP_OFF64 (ignored, sizeflag)
     int ignored ATTRIBUTE_UNUSED;
d3750 6
d3758 1
a3758 1
  off = get64();
d3763 1
a3763 1
		        | PREFIX_ES | PREFIX_FS | PREFIX_GS)))
d3765 1
a3765 1
	  oappend (names_seg[3]);
d3779 5
a3783 1
  oappend ("(");
d3786 6
a3791 1
    s = names64[code - eAX_reg];
d3797 4
a3800 1
  oappend (")");
d3808 1
a3808 1
  oappend ("%es:");
d3825 1
a3825 1
  append_seg();
a3828 1
/* ARGSUSED */
d3838 2
a3839 2
  sprintf (scratchbuf, "%%cr%d", reg+add);
  oappend (scratchbuf);
a3841 1
/* ARGSUSED */
d3851 4
a3854 1
  sprintf (scratchbuf, "%%db%d", reg+add);
a3857 1
/* ARGSUSED */
d3864 1
a3864 1
  oappend (scratchbuf);
d3875 1
a3875 1
    BadOp();
d3879 2
a3880 2
OP_MMX (ignore, sizeflag)
     int ignore ATTRIBUTE_UNUSED;
d3892 1
a3892 1
  oappend (scratchbuf);
d3905 1
a3905 1
  oappend (scratchbuf);
d3923 1
a3923 1
  /* skip mod/rm byte */
d3931 1
a3931 1
  oappend (scratchbuf);
d3949 1
a3949 1
  /* skip mod/rm byte */
d3953 1
a3953 1
  oappend (scratchbuf);
d3964 1
a3964 1
    BadOp();
d3975 1
a3975 1
    BadOp();
d3989 1
a3989 1
static const char *Suffix3DNow[] = {
d4067 1
a4067 1
  obufp = obuf + strlen(obuf);
d4079 1
a4079 1
      BadOp();
d4107 1
a4107 1
static const char *simd_cmp_op [] = {
d4126 1
a4126 1
  obufp = obuf + strlen(obuf);
d4156 1
a4156 1
      BadOp();
d4169 6
a4174 6
      char *p = obuf + strlen(obuf);
      *(p+1) = '\0';
      *p     = *(p-1);
      *(p-1) = *(p-2);
      *(p-2) = *(p-3);
      *(p-3) = extrachar;
d4178 2
a4179 1
static void BadOp (void)
d4181 2
a4182 1
  codep = insn_codep + 1;	/* throw away prefixes and 1st. opcode byte */
@


1.6
log
@resolve conflicts.
@
text
@d251 1
d296 1
d1817 1
a1817 1
  { "(bad)", XX, XX, XX },
d2109 1
a2109 1
  { "(bad)", XX, XX, XX },
d5042 11
d5147 23
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1988, 89, 91, 93, 94, 95, 96, 97, 98, 1999
d26 1
d67 3
d73 20
a148 2
#define indirEb OP_indirE, b_mode
#define Gb OP_G, b_mode
d151 1
d157 1
d159 1
d162 1
d166 2
d171 2
a172 2
#define Cd OP_C, d_mode
#define Dd OP_D, d_mode
d175 48
a222 19
#define eAX OP_REG, eAX_reg
#define eBX OP_REG, eBX_reg
#define eCX OP_REG, eCX_reg
#define eDX OP_REG, eDX_reg
#define eSP OP_REG, eSP_reg
#define eBP OP_REG, eBP_reg
#define eSI OP_REG, eSI_reg
#define eDI OP_REG, eDI_reg
#define AL OP_REG, al_reg
#define CL OP_REG, cl_reg
#define DL OP_REG, dl_reg
#define BL OP_REG, bl_reg
#define AH OP_REG, ah_reg
#define CH OP_REG, ch_reg
#define DH OP_REG, dh_reg
#define BH OP_REG, bh_reg
#define AX OP_REG, ax_reg
#define DX OP_REG, dx_reg
#define indirDX OP_REG, indir_dx_reg
d227 1
d229 1
d248 1
d253 3
d268 5
d293 1
d299 1
a299 1
static void set_op PARAMS ((unsigned int op));
d303 3
a305 1
static int get32 PARAMS ((void));
d311 9
a319 5
#define b_mode 1
#define v_mode 2
#define w_mode 3
#define d_mode 4
#define x_mode 5
d355 9
d374 663
a1036 46
#define GRP2b_one NULL, NULL, 5, NULL, USE_GROUPS, NULL, 0
#define GRP2S_one NULL, NULL, 6, NULL, USE_GROUPS, NULL, 0
#define GRP2b_cl NULL, NULL, 7, NULL, USE_GROUPS, NULL, 0
#define GRP2S_cl NULL, NULL, 8, NULL, USE_GROUPS, NULL, 0
#define GRP3b NULL, NULL, 9, NULL, USE_GROUPS, NULL, 0
#define GRP3S NULL, NULL, 10, NULL, USE_GROUPS, NULL, 0
#define GRP4  NULL, NULL, 11, NULL, USE_GROUPS, NULL, 0
#define GRP5  NULL, NULL, 12, NULL, USE_GROUPS, NULL, 0
#define GRP6  NULL, NULL, 13, NULL, USE_GROUPS, NULL, 0
#define GRP7 NULL, NULL, 14, NULL, USE_GROUPS, NULL, 0
#define GRP8 NULL, NULL, 15, NULL, USE_GROUPS, NULL, 0
#define GRP9 NULL, NULL, 16, NULL, USE_GROUPS, NULL, 0
#define GRP10 NULL, NULL, 17, NULL, USE_GROUPS, NULL, 0
#define GRP11 NULL, NULL, 18, NULL, USE_GROUPS, NULL, 0
#define GRP12 NULL, NULL, 19, NULL, USE_GROUPS, NULL, 0
#define GRP13 NULL, NULL, 20, NULL, USE_GROUPS, NULL, 0
#define GRP14 NULL, NULL, 21, NULL, USE_GROUPS, NULL, 0
#define GRPAMD NULL, NULL, 22, NULL, USE_GROUPS, NULL, 0

#define PREGRP0 NULL, NULL, 0, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP1 NULL, NULL, 1, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP2 NULL, NULL, 2, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP3 NULL, NULL, 3, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP4 NULL, NULL, 4, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP5 NULL, NULL, 5, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP6 NULL, NULL, 6, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP7 NULL, NULL, 7, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP8 NULL, NULL, 8, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP9 NULL, NULL, 9, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP10 NULL, NULL, 10, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP11 NULL, NULL, 11, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP12 NULL, NULL, 12, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP13 NULL, NULL, 13, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP14 NULL, NULL, 14, NULL, USE_PREFIX_USER_TABLE, NULL, 0

#define FLOATCODE 50
#define FLOAT NULL, NULL, FLOATCODE, NULL, 0, NULL, 0

struct dis386 {
  const char *name;
  op_rtn op1;
  int bytemode1;
  op_rtn op2;
  int bytemode2;
  op_rtn op3;
  int bytemode3;
d1039 3
a1041 15
/* Upper case letters in the instruction names here are macros.
   'A' => print 'b' if no register operands or suffix_always is true
   'B' => print 'b' if suffix_always is true
   'E' => print 'e' if 32-bit form of jcxz
   'L' => print 'l' if suffix_always is true
   'N' => print 'n' if instruction has no wait "prefix"
   'P' => print 'w' or 'l' if instruction has an operand size prefix,
                              or suffix_always is true
   'Q' => print 'w' or 'l' if no register operands or suffix_always is true
   'R' => print 'w' or 'l' ("wd" or "dq" in intel mode)
   'S' => print 'w' or 'l' if suffix_always is true
   'W' => print 'b' or 'w' ("w" or "de" in intel mode)
*/

static const struct dis386 dis386_att[] = {
d1049 2
a1050 2
  { "pushP",	es, XX, XX },
  { "popP",	es, XX, XX },
d1058 1
a1058 1
  { "pushP",	cs, XX, XX },
d1067 2
a1068 2
  { "pushP",	ss, XX, XX },
  { "popP",	ss, XX, XX },
d1076 2
a1077 2
  { "pushP",	ds, XX, XX },
  { "popP",	ds, XX, XX },
d1086 1
a1086 1
  { "daa",	XX, XX, XX },
d1095 1
a1095 1
  { "das",	XX, XX, XX },
d1104 1
a1104 1
  { "aaa",	XX, XX, XX },
d1113 1
a1113 1
  { "aas",	XX, XX, XX },
d1115 8
a1122 8
  { "incS",	eAX, XX, XX },
  { "incS",	eCX, XX, XX },
  { "incS",	eDX, XX, XX },
  { "incS",	eBX, XX, XX },
  { "incS",	eSP, XX, XX },
  { "incS",	eBP, XX, XX },
  { "incS",	eSI, XX, XX },
  { "incS",	eDI, XX, XX },
d1124 8
a1131 8
  { "decS",	eAX, XX, XX },
  { "decS",	eCX, XX, XX },
  { "decS",	eDX, XX, XX },
  { "decS",	eBX, XX, XX },
  { "decS",	eSP, XX, XX },
  { "decS",	eBP, XX, XX },
  { "decS",	eSI, XX, XX },
  { "decS",	eDI, XX, XX },
d1133 8
a1140 8
  { "pushS",	eAX, XX, XX },
  { "pushS",	eCX, XX, XX },
  { "pushS",	eDX, XX, XX },
  { "pushS",	eBX, XX, XX },
  { "pushS",	eSP, XX, XX },
  { "pushS",	eBP, XX, XX },
  { "pushS",	eSI, XX, XX },
  { "pushS",	eDI, XX, XX },
d1142 8
a1149 8
  { "popS",	eAX, XX, XX },
  { "popS",	eCX, XX, XX },
  { "popS",	eDX, XX, XX },
  { "popS",	eBX, XX, XX },
  { "popS",	eSP, XX, XX },
  { "popS",	eBP, XX, XX },
  { "popS",	eSI, XX, XX },
  { "popS",	eDI, XX, XX },
d1151 4
a1154 4
  { "pushaP",	XX, XX, XX },
  { "popaP",	XX, XX, XX },
  { "boundS",	Gv, Ma, XX },
  { "arpl",	Ew, Gw, XX },
d1160 1
a1160 1
  { "pushP",	Iv, XX, XX },		/* 386 book wrong */
d1162 1
a1162 1
  { "pushP",	sIb, XX, XX },	/* push of byte really pushes 2 or 4 bytes */
d1169 8
a1176 8
  { "jo",	Jb, XX, XX },
  { "jno",	Jb, XX, XX },
  { "jb",	Jb, XX, XX },
  { "jae",	Jb, XX, XX },
  { "je",	Jb, XX, XX },
  { "jne",	Jb, XX, XX },
  { "jbe",	Jb, XX, XX },
  { "ja",	Jb, XX, XX },
d1178 8
a1185 8
  { "js",	Jb, XX, XX },
  { "jns",	Jb, XX, XX },
  { "jp",	Jb, XX, XX },
  { "jnp",	Jb, XX, XX },
  { "jl",	Jb, XX, XX },
  { "jge",	Jb, XX, XX },
  { "jle",	Jb, XX, XX },
  { "jg",	Jb, XX, XX },
d1203 1
a1203 1
  { "popQ",	Ev, XX, XX },
d1206 8
a1213 7
  { "xchgS",	eCX, eAX, XX },
  { "xchgS",	eDX, eAX, XX },
  { "xchgS",	eBX, eAX, XX },
  { "xchgS",	eSP, eAX, XX },
  { "xchgS",	eBP, eAX, XX },
  { "xchgS",	eSI, eAX, XX },
  { "xchgS",	eDI, eAX, XX },
d1216 2
a1217 2
  { "cRtd",	XX, XX, XX },
  { "lcallP",	Ap, XX, XX },
d1219 4
a1222 4
  { "pushfP",	XX, XX, XX },
  { "popfP",	XX, XX, XX },
  { "sahf",	XX, XX, XX },
  { "lahf",	XX, XX, XX },
d1224 4
a1227 4
  { "movB",	AL, Ob, XX },
  { "movS",	eAX, Ov, XX },
  { "movB",	Ob, AL, XX },
  { "movS",	Ov, eAX, XX },
d1242 8
a1249 8
  { "movB",	AL, Ib, XX },
  { "movB",	CL, Ib, XX },
  { "movB",	DL, Ib, XX },
  { "movB",	BL, Ib, XX },
  { "movB",	AH, Ib, XX },
  { "movB",	CH, Ib, XX },
  { "movB",	DH, Ib, XX },
  { "movB",	BH, Ib, XX },
d1251 8
a1258 8
  { "movS",	eAX, Iv, XX },
  { "movS",	eCX, Iv, XX },
  { "movS",	eDX, Iv, XX },
  { "movS",	eBX, Iv, XX },
  { "movS",	eSP, Iv, XX },
  { "movS",	eBP, Iv, XX },
  { "movS",	eSI, Iv, XX },
  { "movS",	eDI, Iv, XX },
d1262 3
a1264 3
  { "retP",	Iw, XX, XX },
  { "retP",	XX, XX, XX },
  { "lesS",	Gv, Mp, XX },
d1269 2
a1270 2
  { "enterP",	Iw, Ib, XX },
  { "leaveP",	XX, XX, XX },
d1275 1
a1275 1
  { "into",	XX, XX, XX},
d1282 3
a1284 3
  { "aam",	sIb, XX, XX },
  { "aad",	sIb, XX, XX },
  { "(bad)",	XX, XX, XX },
d1296 4
a1299 4
  { "loopne",	Jb, XX, XX },
  { "loope",	Jb, XX, XX },
  { "loop",	Jb, XX, XX },
  { "jEcxz",	Jb, XX, XX },
d1305 3
a1307 3
  { "callP",	Jv, XX, XX },
  { "jmpP",	Jv, XX, XX },
  { "ljmpP",	Ap, XX, XX },
d1333 1
a1333 1
static const struct dis386 dis386_intel[] = {
d1341 2
a1342 2
  { "push",	es, XX, XX },
  { "pop",	es, XX, XX },
d1350 1
a1350 1
  { "push",	cs, XX, XX },
d1359 2
a1360 2
  { "push",	ss, XX, XX },
  { "pop",	ss, XX, XX },
d1368 2
a1369 2
  { "push",	ds, XX, XX },
  { "pop",	ds, XX, XX },
d1378 1
a1378 1
  { "daa",	XX, XX, XX },
d1387 1
a1387 1
  { "das",	XX, XX, XX },
d1396 1
a1396 1
  { "aaa",	XX, XX, XX },
d1405 1
a1405 1
  { "aas",	XX, XX, XX },
d1407 8
a1414 8
  { "inc",	eAX, XX, XX },
  { "inc",	eCX, XX, XX },
  { "inc",	eDX, XX, XX },
  { "inc",	eBX, XX, XX },
  { "inc",	eSP, XX, XX },
  { "inc",	eBP, XX, XX },
  { "inc",	eSI, XX, XX },
  { "inc",	eDI, XX, XX },
d1416 8
a1423 8
  { "dec",	eAX, XX, XX },
  { "dec",	eCX, XX, XX },
  { "dec",	eDX, XX, XX },
  { "dec",	eBX, XX, XX },
  { "dec",	eSP, XX, XX },
  { "dec",	eBP, XX, XX },
  { "dec",	eSI, XX, XX },
  { "dec",	eDI, XX, XX },
d1425 8
a1432 8
  { "push",	eAX, XX, XX },
  { "push",	eCX, XX, XX },
  { "push",	eDX, XX, XX },
  { "push",	eBX, XX, XX },
  { "push",	eSP, XX, XX },
  { "push",	eBP, XX, XX },
  { "push",	eSI, XX, XX },
  { "push",	eDI, XX, XX },
d1434 8
a1441 8
  { "pop",	eAX, XX, XX },
  { "pop",	eCX, XX, XX },
  { "pop",	eDX, XX, XX },
  { "pop",	eBX, XX, XX },
  { "pop",	eSP, XX, XX },
  { "pop",	eBP, XX, XX },
  { "pop",	eSI, XX, XX },
  { "pop",	eDI, XX, XX },
d1443 4
a1446 4
  { "pusha",	XX, XX, XX },
  { "popa",	XX, XX, XX },
  { "bound",	Gv, Ma, XX },
  { "arpl",	Ew, Gw, XX },
d1452 1
a1452 1
  { "push",	Iv, XX, XX },		/* 386 book wrong */
d1498 8
a1505 7
  { "xchg",	eCX, eAX, XX },
  { "xchg",	eDX, eAX, XX },
  { "xchg",	eBX, eAX, XX },
  { "xchg",	eSP, eAX, XX },
  { "xchg",	eBP, eAX, XX },
  { "xchg",	eSI, eAX, XX },
  { "xchg",	eDI, eAX, XX },
d1509 1
a1509 1
  { "lcall",	Ap, XX, XX },
d1513 2
a1514 2
  { "sahf",	XX, XX, XX },
  { "lahf",	XX, XX, XX },
d1534 8
a1541 8
  { "mov",	AL, Ib, XX },
  { "mov",	CL, Ib, XX },
  { "mov",	DL, Ib, XX },
  { "mov",	BL, Ib, XX },
  { "mov",	AH, Ib, XX },
  { "mov",	CH, Ib, XX },
  { "mov",	DH, Ib, XX },
  { "mov",	BH, Ib, XX },
d1543 8
a1550 8
  { "mov",	eAX, Iv, XX },
  { "mov",	eCX, Iv, XX },
  { "mov",	eDX, Iv, XX },
  { "mov",	eBX, Iv, XX },
  { "mov",	eSP, Iv, XX },
  { "mov",	eBP, Iv, XX },
  { "mov",	eSI, Iv, XX },
  { "mov",	eDI, Iv, XX },
d1556 1
a1556 1
  { "les",	Gv, Mp, XX },
d1567 1
a1567 1
  { "into",	XX, XX, XX },
d1574 3
a1576 3
  { "aam",	sIb, XX, XX },
  { "aad",	sIb, XX, XX },
  { "(bad)",	XX, XX, XX },
d1599 1
a1599 1
  { "ljmp",	Ap, XX, XX },
d1632 1
a1632 1
  { "(bad)", XX, XX, XX },
d1634 1
a1634 1
  { "(bad)", XX, XX, XX },
d1647 6
a1652 6
  { "movlps", XM, EX, SIMD_Fixup, 'h' },  /* really only 2 operands */
  { "movlps", EX, XM, SIMD_Fixup, 'h' },
  { "unpcklps", XM, EX, XX },
  { "unpckhps", XM, EX, XX },
  { "movhps", XM, EX, SIMD_Fixup, 'l' },
  { "movhps", EX, XM, SIMD_Fixup, 'l' },
d1664 4
a1667 4
  { "movL", Rd, Cd, XX },
  { "movL", Rd, Dd, XX },
  { "movL", Cd, Rd, XX },
  { "movL", Dd, Rd, XX },
d1673 2
a1674 2
  { "movaps", XM, EX, XX },
  { "movaps", EX, XM, XX },
d1676 1
a1676 1
  { "movntps", Ev, XM, XX },
d1679 2
a1680 2
  { "ucomiss", XM, EX, XX },
  { "comiss", XM, EX, XX },
d1718 1
a1718 1
  { "movmskps", Gv, EX, XX },
d1722 4
a1725 4
  { "andps", XM, EX, XX },
  { "andnps", XM, EX, XX },
  { "orps", XM, EX, XX },
  { "xorps", XM, EX, XX },
d1729 2
a1730 2
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
d1749 2
a1750 2
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
d1752 1
a1752 1
  { "movq", MX, EM, XX },
d1754 1
a1754 1
  { "pshufw", MX, EM, Ib },
d1769 2
a1770 2
  { "movd", Ed, MX, XX },
  { "movq", EM, MX, XX },
d1772 8
a1779 8
  { "jo", Jv, XX, XX },
  { "jno", Jv, XX, XX },
  { "jb", Jv, XX, XX },
  { "jae", Jv, XX, XX },
  { "je", Jv, XX, XX },
  { "jne", Jv, XX, XX },
  { "jbe", Jv, XX, XX },
  { "ja", Jv, XX, XX },
d1781 8
a1788 8
  { "js", Jv, XX, XX },
  { "jns", Jv, XX, XX },
  { "jp", Jv, XX, XX },
  { "jnp", Jv, XX, XX },
  { "jl", Jv, XX, XX },
  { "jge", Jv, XX, XX },
  { "jle", Jv, XX, XX },
  { "jg", Jv, XX, XX },
d1808 2
a1809 2
  { "pushP", fs, XX, XX },
  { "popP", fs, XX, XX },
d1817 2
a1818 2
  { "pushP", gs, XX, XX },
  { "popP", gs, XX, XX },
d1847 4
a1850 4
  { "(bad)", XX, XX, XX },
  { "pinsrw", MX, Ev, Ib },
  { "pextrw", Ev, MX, Ib },
  { "shufps", XM, EX, Ib },
d1853 8
a1860 8
  { "bswap", eAX, XX, XX },	/* bswap doesn't support 16 bit regs */
  { "bswap", eCX, XX, XX },
  { "bswap", eDX, XX, XX },
  { "bswap", eBX, XX, XX },
  { "bswap", eSP, XX, XX },
  { "bswap", eBP, XX, XX },
  { "bswap", eSI, XX, XX },
  { "bswap", eDI, XX, XX },
d1866 1
a1866 1
  { "(bad)", XX, XX, XX },
d1868 2
a1869 2
  { "(bad)", XX, XX, XX },
  { "pmovmskb", Ev, MX, XX },
d1886 2
a1887 2
  { "(bad)", XX, XX, XX },
  { "movntq", Ev, MX, XX },
d1902 1
a1902 1
  { "(bad)", XX, XX, XX },
d1905 1
a1905 1
  { "maskmovq", MX, EM, XX },
d1910 1
a1910 1
  { "(bad)", XX, XX, XX },
d1924 1
a1924 1
  { "(bad)", XX, XX, XX },
d1926 1
a1926 1
  { "(bad)", XX, XX, XX },
d1939 6
a1944 6
  { "movlps", XM, EX, SIMD_Fixup, 'h' },  /* really only 2 operands */
  { "movlps", EX, XM, SIMD_Fixup, 'h' },
  { "unpcklps", XM, EX, XX },
  { "unpckhps", XM, EX, XX },
  { "movhps", XM, EX, SIMD_Fixup, 'l' },
  { "movhps", EX, XM, SIMD_Fixup, 'l' },
d1956 4
a1959 4
  { "mov", Rd, Cd, XX },
  { "mov", Rd, Dd, XX },
  { "mov", Cd, Rd, XX },
  { "mov", Dd, Rd, XX },
d1965 2
a1966 2
  { "movaps", XM, EX, XX },
  { "movaps", EX, XM, XX },
d1968 1
a1968 1
  { "movntps", Ev, XM, XX },
d1971 2
a1972 2
  { "ucomiss", XM, EX, XX },
  { "comiss", XM, EX, XX },
d2010 1
a2010 1
  { "movmskps", Gv, EX, XX },
d2014 4
a2017 4
  { "andps", XM, EX, XX },
  { "andnps", XM, EX, XX },
  { "orps", XM, EX, XX },
  { "xorps", XM, EX, XX },
d2021 2
a2022 2
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
d2041 2
a2042 2
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
d2044 1
a2044 1
  { "movq", MX, EM, XX },
d2046 1
a2046 1
  { "pshufw", MX, EM, Ib },
d2061 2
a2062 2
  { "movd", Ed, MX, XX },
  { "movq", EM, MX, XX },
d2139 4
a2142 4
  { "(bad)", XX, XX, XX },
  { "pinsrw", MX, Ev, Ib },
  { "pextrw", Ev, MX, Ib },
  { "shufps", XM, EX, Ib },
d2145 8
a2152 8
  { "bswap", eAX, XX, XX },	/* bswap doesn't support 16 bit regs */
  { "bswap", eCX, XX, XX },
  { "bswap", eDX, XX, XX },
  { "bswap", eBX, XX, XX },
  { "bswap", eSP, XX, XX },
  { "bswap", eBP, XX, XX },
  { "bswap", eSI, XX, XX },
  { "bswap", eDI, XX, XX },
d2158 1
a2158 1
  { "(bad)", XX, XX, XX },
d2160 2
a2161 2
  { "(bad)", XX, XX, XX },
  { "pmovmskb", Ev, MX, XX },
d2178 2
a2179 2
  { "(bad)", XX, XX, XX },
  { "movntq", Ev, MX, XX },
d2194 1
a2194 1
  { "(bad)", XX, XX, XX },
d2197 1
a2197 1
  { "maskmovq", MX, EM, XX },
d2202 1
a2202 1
  { "(bad)", XX, XX, XX },
d2237 1
a2237 1
  /* 20 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 2f */
d2240 2
a2241 2
  /* 50 */ 1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1, /* 5f */
  /* 60 */ 1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1, /* 6f */
d2245 1
a2245 1
  /* a0 */ 0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1, /* af */
d2248 3
a2250 3
  /* d0 */ 0,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1, /* df */
  /* e0 */ 1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1, /* ef */
  /* f0 */ 0,1,1,1,0,1,1,1,1,1,1,0,1,1,1,0  /* ff */
d2255 1
a2255 1
static const unsigned char twobyte_uses_f3_prefix[256] = {
d2263 3
a2265 3
  /* 50 */ 0,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1, /* 5f */
  /* 60 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 6f */
  /* 70 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 7f */
d2271 3
a2273 3
  /* d0 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* df */
  /* e0 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* ef */
  /* f0 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  /* ff */
d2288 1
d2291 10
a2300 1
static const char *names32[]={
d2302 1
d2306 1
d2311 4
d2459 5
a2463 5
    { "callP",	indirEv, XX, XX },
    { "lcallP",	indirEv, XX, XX },
    { "jmpP",	indirEv, XX, XX },
    { "ljmpP",	indirEv, XX, XX },
    { "pushQ",	Ev, XX, XX },
d2537 1
a2537 1
    { "(bad)",	XX, XX, XX },
d2541 1
a2541 1
    { "(bad)",	XX, XX, XX },
d2550 2
a2551 2
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
d2553 1
d2580 1
a2580 1
static const struct dis386 prefix_user_table[][2] = {
d2585 2
d2592 2
d2598 3
a2600 1
    { "cvtsi2ss", XM, Ev, XX },
d2605 3
a2607 1
    { "cvtss2si", Gv, EX, XX },
d2612 3
a2614 1
    { "cvttss2si", Gv, EX, XX },
d2620 2
d2627 2
d2634 2
d2641 2
d2648 2
d2655 2
d2662 2
d2669 2
d2676 2
d2683 87
a2769 1
  }
d2777 2
d2781 1
d2785 1
d2788 22
d2858 7
d2879 33
d2944 2
a2945 1
static unsigned int start_pc;
d3004 1
a3004 2
  unsigned char need_modrm;
  unsigned char uses_f3_prefix;
d3011 3
d3015 3
a3017 1
      || info->mach == bfd_mach_i386_i386_intel_syntax)
d3070 1
a3077 2
  obufp = obuf;

d3100 1
a3100 1
      uses_f3_prefix = twobyte_uses_f3_prefix[*codep];
d3105 4
a3108 1
        dp = &dis386_intel[*codep];
d3110 4
a3113 1
        dp = &dis386_att[*codep];
d3115 1
a3115 1
      uses_f3_prefix = 0;
d3119 1
a3119 1
  if (!uses_f3_prefix && (prefixes & PREFIX_REPZ))
d3124 1
a3124 1
  if (prefixes & PREFIX_REPNZ)
d3135 25
a3159 2
  if (prefixes & PREFIX_DATA)
    sizeflag ^= DFLAG;
d3161 1
a3161 1
  if (prefixes & PREFIX_ADDR)
d3163 10
a3172 6
      sizeflag ^= AFLAG;
      if (sizeflag & AFLAG)
        oappend ("addr32 ");
      else
	oappend ("addr16 ");
      used_prefixes |= PREFIX_ADDR;
d3189 1
d3198 1
a3198 1
		dp = &prefix_user_table[dp->bytemode1][prefixes & PREFIX_REPZ ? 1 : 0];
d3200 15
d3254 8
d3289 1
a3289 1
      if (op_index[0] != -1)
d3299 1
a3299 1
      if (op_index[1] != -1)
d3309 1
a3309 1
      if (op_index[2] != -1)
d3314 7
d3581 1
a3581 1
    { "(bad)",	XX, XX, XX },
d3665 2
d3747 36
d3798 7
d3809 1
d3815 3
a3817 2
	      if (sizeflag & DFLAG)
		*obufp++ = 'l';
d3819 7
a3825 2
		*obufp++ = 'w';
	      used_prefixes |= (prefixes & PREFIX_DATA);
d3831 1
d3838 2
a3839 2
	      if (sizeflag & DFLAG)
		*obufp++ = 'l';
d3841 7
a3847 2
		*obufp++ = 'w';
	      used_prefixes |= (prefixes & PREFIX_DATA);
d3851 1
d3854 6
a3859 1
	      if (sizeflag & DFLAG)
d3872 3
a3874 1
	      if (sizeflag & DFLAG)
d3879 2
a3880 1
	  used_prefixes |= (prefixes & PREFIX_DATA);
d3888 24
a3917 1
#endif
d3919 17
d3938 4
a3941 1
	  if (sizeflag & DFLAG)
d3947 5
d3962 2
a3963 1
	  used_prefixes |= (prefixes & PREFIX_DATA);
d4024 60
d4088 6
a4093 1
  int disp;
d4096 1
d4104 5
a4108 1
	  oappend (names8[rm]);
d4111 1
a4111 1
	  oappend (names16[rm]);
d4114 10
a4123 1
	  oappend (names32[rm]);
d4126 5
a4130 2
	  if (sizeflag & DFLAG)
	    oappend (names32[rm]);
d4132 1
a4132 1
	    oappend (names16[rm]);
d4136 3
a4138 1
	  if ( !(codep[-2] == 0xAE && codep[-1] == 0xF8 /* sfence */))
d4170 6
d4182 1
a4182 1
	  if (base == 5)
d4185 3
a4187 1
	      disp = get32 ();
d4197 1
a4197 1
	  disp = get32 ();
d4202 1
a4202 1
        if (mod != 0 || base == 5)
d4204 1
a4204 1
            sprintf (scratchbuf, "0x%x", disp);
d4206 5
d4220 1
a4220 1
                  oappend("BYTE PTR ");
d4223 1
a4223 1
                  oappend("WORD PTR ");
d4226 1
a4226 1
                  oappend("DWORD PTR ");
d4229 1
a4229 1
                  oappend("QWORD PTR ");
d4231 6
d4238 1
a4238 1
                  oappend("XWORD PTR ");
d4245 2
d4248 3
d4252 1
a4252 1
	    oappend (names32[base]);
d4264 1
a4264 1
                      sprintf (scratchbuf, "%s", names32[index]);
d4267 1
a4267 1
		    sprintf (scratchbuf, ",%s", names32[index]);
d4283 1
a4283 1
            if (mod != 0 || base == 5)
d4286 1
a4286 1
                if (disp > 0)
d4288 1
a4288 6
                    sprintf (scratchbuf, "+%d", disp);
                    oappend (scratchbuf);
                  }
                else if (disp < 0)
                  {
                    sprintf (scratchbuf, "%d", disp);
d4298 1
a4298 1
          if (mod != 0 || base == 5)
d4308 1
a4308 1
              sprintf (scratchbuf, "0x%x", disp);
d4318 1
a4318 1
	  if (rm == 6)
d4339 1
a4339 1
        if (mod != 0 || rm == 6)
d4341 1
a4341 1
            sprintf (scratchbuf, "%d", disp);
d4345 1
a4345 1
      if (mod != 0 || rm != 6)
d4349 1
a4349 1
	  oappend (index16[rm]);
d4361 4
d4368 5
a4372 1
      oappend (names8[reg]);
d4375 1
a4375 1
      oappend (names16[reg]);
d4378 4
a4381 1
      oappend (names32[reg]);
d4384 5
a4388 2
      if (sizeflag & DFLAG)
	oappend (names32[reg]);
d4390 1
a4390 1
	oappend (names16[reg]);
d4399 25
a4423 1
static int
d4426 14
a4439 1
  int x = 0;
d4442 7
a4448 4
  x = *codep++ & 0xff;
  x |= (*codep++ & 0xff) << 8;
  x |= (*codep++ & 0xff) << 16;
  x |= (*codep++ & 0xff) << 24;
d4464 1
a4464 1
set_op (op)
d4466 1
d4470 1
d4479 54
d4549 5
a4553 1
      s = names8[code - al_reg];
d4557 4
a4560 1
      if (sizeflag & DFLAG)
d4578 52
a4629 1
  int op;
d4635 2
a4636 1
      op = *codep++ & 0xff;
d4639 8
a4646 2
      if (sizeflag & DFLAG)
	op = get32 ();
d4648 4
a4651 1
	op = get16 ();
d4655 1
d4663 3
a4665 4
  if (intel_syntax)
    sprintf (scratchbuf, "0x%x", op);
  else
    sprintf (scratchbuf, "$0x%x", op);
d4675 2
a4676 1
  int op;
d4685 1
d4688 8
a4695 2
      if (sizeflag & DFLAG)
	op = get32 ();
d4698 1
d4707 1
d4715 3
a4717 4
  if (intel_syntax)
    sprintf (scratchbuf, "%d", op);
  else
    sprintf (scratchbuf, "$0x%x", op);
d4726 1
a4726 1
  int disp;
d4739 1
a4739 1
	disp = get32 ();
a4747 1
      used_prefixes |= (prefixes & PREFIX_DATA);
d4754 2
a4755 2
  set_op (disp);
  sprintf (scratchbuf, "0x%x", disp);
d4797 2
a4798 2
OP_OFF (ignore, sizeflag)
     int ignore ATTRIBUTE_UNUSED;
d4801 1
a4801 1
  int off;
d4819 25
a4843 1
  sprintf (scratchbuf, "0x%x", off);
d4854 4
a4857 1
  if (sizeflag & AFLAG)
d4897 5
a4901 1
  sprintf (scratchbuf, "%%cr%d", reg);
d4911 5
a4915 1
  sprintf (scratchbuf, "%%db%d", reg);
d4945 9
a4953 1
  sprintf (scratchbuf, "%%mm%d", reg);
d4962 5
a4966 1
  sprintf (scratchbuf, "%%xmm%d", reg);
d4975 1
d4981 3
d4985 2
d4988 5
a4992 1
  sprintf (scratchbuf, "%%mm%d", rm);
d5001 1
d5007 3
d5011 2
d5014 1
a5014 1
  sprintf (scratchbuf, "%%xmm%d", rm);
d5029 11
d5158 18
a5175 3
      sprintf (scratchbuf, "cmp%s%cs",
	       simd_cmp_op[cmp_type],
	       prefixes & PREFIX_REPZ ? 's' : 'p');
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright (C) 1988, 89, 91, 93, 94, 95, 1996 Free Software Foundation, Inc.
d32 1
a32 1
 * and the small letter tells about the operand size.  Refer to 
d38 1
d44 8
d61 25
d108 6
a113 1
      (*info->memory_error_func) (status, start, info);
d121 2
d127 1
d131 2
a132 2
#define M OP_E, 0
#define Mp OP_E, 0		/* ? */
d135 1
a135 2
#define Rw OP_rm, w_mode
#define Rd OP_rm, d_mode
a141 3
#if 0
#define ONE OP_ONE, 0
#endif
d167 1
a167 2
#define Ap OP_DIR, lptr
#define Av OP_DIR, v_mode
d170 5
a174 4
#define Xb OP_DSSI, b_mode
#define Xv OP_DSSI, v_mode
#define Yb OP_ESDI, b_mode
#define Yv OP_ESDI, v_mode
d183 15
a197 1
typedef int (*op_rtn) PARAMS ((int bytemode, int aflag, int dflag));
d199 1
a199 21
static int OP_E PARAMS ((int, int, int));
static int OP_G PARAMS ((int, int, int));
static int OP_I PARAMS ((int, int, int));
static int OP_indirE PARAMS ((int, int, int));
static int OP_sI PARAMS ((int, int, int));
static int OP_REG PARAMS ((int, int, int));
static int OP_J PARAMS ((int, int, int));
static int OP_DIR PARAMS ((int, int, int));
static int OP_OFF PARAMS ((int, int, int));
static int OP_ESDI PARAMS ((int, int, int));
static int OP_DSSI PARAMS ((int, int, int));
static int OP_SEG PARAMS ((int, int, int));
static int OP_C PARAMS ((int, int, int));
static int OP_D PARAMS ((int, int, int));
static int OP_T PARAMS ((int, int, int));
static int OP_rm PARAMS ((int, int, int));
static int OP_ST PARAMS ((int, int, int));
static int OP_STi  PARAMS ((int, int, int));
#if 0
static int OP_ONE PARAMS ((int, int, int));
#endif
d201 31
a231 4
static void append_prefix PARAMS ((void));
static void set_op PARAMS ((int op));
static void putop PARAMS ((char *template, int aflag, int dflag));
static void dofloat PARAMS ((int aflag, int dflag));
d235 3
d243 1
a250 8
#define eAX_reg 107
#define eCX_reg 108
#define eDX_reg 109
#define eBX_reg 110
#define eSP_reg 111
#define eBP_reg 112
#define eSI_reg 113
#define eDI_reg 114
d252 8
a259 1
#define lptr 115
d281 42
a322 17
#define GRP1b NULL, NULL, 0
#define GRP1S NULL, NULL, 1
#define GRP1Ss NULL, NULL, 2
#define GRP2b NULL, NULL, 3
#define GRP2S NULL, NULL, 4
#define GRP2b_one NULL, NULL, 5
#define GRP2S_one NULL, NULL, 6
#define GRP2b_cl NULL, NULL, 7
#define GRP2S_cl NULL, NULL, 8
#define GRP3b NULL, NULL, 9
#define GRP3S NULL, NULL, 10
#define GRP4  NULL, NULL, 11
#define GRP5  NULL, NULL, 12
#define GRP6  NULL, NULL, 13
#define GRP7 NULL, NULL, 14
#define GRP8 NULL, NULL, 15
#define GRP9 NULL, NULL, 16
d325 1
a325 1
#define FLOAT NULL, NULL, FLOATCODE
d328 1
a328 1
  char *name;
d337 15
a351 1
static struct dis386 dis386[] = {
d353 8
a360 8
  { "addb",	Eb, Gb },
  { "addS",	Ev, Gv },
  { "addb",	Gb, Eb },
  { "addS",	Gv, Ev },
  { "addb",	AL, Ib },
  { "addS",	eAX, Iv },
  { "pushl",	es },
  { "popl",	es },
d362 8
a369 8
  { "orb",	Eb, Gb },
  { "orS",	Ev, Gv },
  { "orb",	Gb, Eb },
  { "orS",	Gv, Ev },
  { "orb",	AL, Ib },
  { "orS",	eAX, Iv },
  { "pushl",	cs },
  { "(bad)" },	/* 0x0f extended opcode escape */
d371 8
a378 8
  { "adcb",	Eb, Gb },
  { "adcS",	Ev, Gv },
  { "adcb",	Gb, Eb },
  { "adcS",	Gv, Ev },
  { "adcb",	AL, Ib },
  { "adcS",	eAX, Iv },
  { "pushl",	ss },
  { "popl",	ss },
d380 8
a387 8
  { "sbbb",	Eb, Gb },
  { "sbbS",	Ev, Gv },
  { "sbbb",	Gb, Eb },
  { "sbbS",	Gv, Ev },
  { "sbbb",	AL, Ib },
  { "sbbS",	eAX, Iv },
  { "pushl",	ds },
  { "popl",	ds },
d389 8
a396 8
  { "andb",	Eb, Gb },
  { "andS",	Ev, Gv },
  { "andb",	Gb, Eb },
  { "andS",	Gv, Ev },
  { "andb",	AL, Ib },
  { "andS",	eAX, Iv },
  { "(bad)" },			/* SEG ES prefix */
  { "daa" },
d398 8
a405 8
  { "subb",	Eb, Gb },
  { "subS",	Ev, Gv },
  { "subb",	Gb, Eb },
  { "subS",	Gv, Ev },
  { "subb",	AL, Ib },
  { "subS",	eAX, Iv },
  { "(bad)" },			/* SEG CS prefix */
  { "das" },
d407 8
a414 8
  { "xorb",	Eb, Gb },
  { "xorS",	Ev, Gv },
  { "xorb",	Gb, Eb },
  { "xorS",	Gv, Ev },
  { "xorb",	AL, Ib },
  { "xorS",	eAX, Iv },
  { "(bad)" },			/* SEG SS prefix */
  { "aaa" },
d416 8
a423 8
  { "cmpb",	Eb, Gb },
  { "cmpS",	Ev, Gv },
  { "cmpb",	Gb, Eb },
  { "cmpS",	Gv, Ev },
  { "cmpb",	AL, Ib },
  { "cmpS",	eAX, Iv },
  { "(bad)" },			/* SEG DS prefix */
  { "aas" },
d425 8
a432 8
  { "incS",	eAX },
  { "incS",	eCX },
  { "incS",	eDX },
  { "incS",	eBX },
  { "incS",	eSP },
  { "incS",	eBP },
  { "incS",	eSI },
  { "incS",	eDI },
d434 8
a441 8
  { "decS",	eAX },
  { "decS",	eCX },
  { "decS",	eDX },
  { "decS",	eBX },
  { "decS",	eSP },
  { "decS",	eBP },
  { "decS",	eSI },
  { "decS",	eDI },
d443 8
a450 8
  { "pushS",	eAX },
  { "pushS",	eCX },
  { "pushS",	eDX },
  { "pushS",	eBX },
  { "pushS",	eSP },
  { "pushS",	eBP },
  { "pushS",	eSI },
  { "pushS",	eDI },
d452 8
a459 8
  { "popS",	eAX },
  { "popS",	eCX },
  { "popS",	eDX },
  { "popS",	eBX },
  { "popS",	eSP },
  { "popS",	eBP },
  { "popS",	eSI },
  { "popS",	eDI },
d461 8
a468 8
  { "pusha" },
  { "popa" },
  { "boundS",	Gv, Ma },
  { "arpl",	Ew, Gw },
  { "(bad)" },			/* seg fs */
  { "(bad)" },			/* seg gs */
  { "(bad)" },			/* op size prefix */
  { "(bad)" },			/* adr size prefix */
d470 1
a470 1
  { "pushS",	Iv },		/* 386 book wrong */
d472 297
a768 6
  { "pushl",	sIb },		/* push of byte really pushes 4 bytes */
  { "imulS",	Gv, Ev, Ib },
  { "insb",	Yb, indirDX },
  { "insS",	Yv, indirDX },
  { "outsb",	indirDX, Xb },
  { "outsS",	indirDX, Xv },
d770 8
a777 8
  { "jo",	Jb },
  { "jno",	Jb },
  { "jb",	Jb },
  { "jae",	Jb },
  { "je",	Jb },
  { "jne",	Jb },
  { "jbe",	Jb },
  { "ja",	Jb },
d779 8
a786 8
  { "js",	Jb },
  { "jns",	Jb },
  { "jp",	Jb },
  { "jnp",	Jb },
  { "jl",	Jb },
  { "jnl",	Jb },
  { "jle",	Jb },
  { "jg",	Jb },
d790 1
a790 1
  { "(bad)" },
d792 4
a795 4
  { "testb",	Eb, Gb },
  { "testS",	Ev, Gv },
  { "xchgb",	Eb, Gb },
  { "xchgS",	Ev, Gv },
d797 8
a804 8
  { "movb",	Eb, Gb },
  { "movS",	Ev, Gv },
  { "movb",	Gb, Eb },
  { "movS",	Gv, Ev },
  { "movw",	Ew, Sw },
  { "leaS",	Gv, M },
  { "movw",	Sw, Ew },
  { "popS",	Ev },
d806 8
a813 8
  { "nop" },
  { "xchgS",	eCX, eAX },
  { "xchgS",	eDX, eAX },
  { "xchgS",	eBX, eAX },
  { "xchgS",	eSP, eAX },
  { "xchgS",	eBP, eAX },
  { "xchgS",	eSI, eAX },
  { "xchgS",	eDI, eAX },
d815 8
a822 8
  { "cwtl" },
  { "cltd" },
  { "lcall",	Ap },
  { "(bad)" },		/* fwait */
  { "pushf" },
  { "popf" },
  { "sahf" },
  { "lahf" },
d824 8
a831 8
  { "movb",	AL, Ob },
  { "movS",	eAX, Ov },
  { "movb",	Ob, AL },
  { "movS",	Ov, eAX },
  { "movsb",	Yb, Xb },
  { "movsS",	Yv, Xv },
  { "cmpsb",	Yb, Xb },
  { "cmpsS",	Yv, Xv },
d833 8
a840 8
  { "testb",	AL, Ib },
  { "testS",	eAX, Iv },
  { "stosb",	Yb, AL },
  { "stosS",	Yv, eAX },
  { "lodsb",	AL, Xb },
  { "lodsS",	eAX, Xv },
  { "scasb",	AL, Yb },
  { "scasS",	eAX, Yv },
d842 8
a849 8
  { "movb",	AL, Ib },
  { "movb",	CL, Ib },
  { "movb",	DL, Ib },
  { "movb",	BL, Ib },
  { "movb",	AH, Ib },
  { "movb",	CH, Ib },
  { "movb",	DH, Ib },
  { "movb",	BH, Ib },
d851 8
a858 8
  { "movS",	eAX, Iv },
  { "movS",	eCX, Iv },
  { "movS",	eDX, Iv },
  { "movS",	eBX, Iv },
  { "movS",	eSP, Iv },
  { "movS",	eBP, Iv },
  { "movS",	eSI, Iv },
  { "movS",	eDI, Iv },
d862 6
a867 6
  { "ret",	Iw },
  { "ret" },
  { "lesS",	Gv, Mp },
  { "ldsS",	Gv, Mp },
  { "movb",	Eb, Ib },
  { "movS",	Ev, Iv },
d869 8
a876 8
  { "enter",	Iw, Ib },
  { "leave" },
  { "lret",	Iw },
  { "lret" },
  { "int3" },
  { "int",	Ib },
  { "into" },
  { "iret" },
d882 4
a885 4
  { "aam",	Ib },
  { "aad",	Ib },
  { "(bad)" },
  { "xlat" },
d896 8
a903 8
  { "loopne",	Jb },
  { "loope",	Jb },
  { "loop",	Jb },
  { "jCcxz",	Jb },
  { "inb",	AL, Ib },
  { "inS",	eAX, Ib },
  { "outb",	Ib, AL },
  { "outS",	Ib, eAX },
d905 8
a912 8
  { "call",	Av },
  { "jmp",	Jv },
  { "ljmp",	Ap },
  { "jmp",	Jb },
  { "inb",	AL, indirDX },
  { "inS",	eAX, indirDX },
  { "outb",	indirDX, AL },
  { "outS",	indirDX, eAX },
d914 6
a919 6
  { "(bad)" },			/* lock prefix */
  { "(bad)" },
  { "(bad)" },			/* repne */
  { "(bad)" },			/* repz */
  { "hlt" },
  { "cmc" },
d923 6
a928 6
  { "clc" },
  { "stc" },
  { "cli" },
  { "sti" },
  { "cld" },
  { "std" },
d933 1
a933 1
static struct dis386 dis386_twobyte[] = {
d937 6
a942 6
  { "larS", Gv, Ew },
  { "lslS", Gv, Ew },  
  { "(bad)" },
  { "(bad)" },
  { "clts" },
  { "(bad)" },  
d944 8
a951 4
  { "invd" },
  { "wbinvd" },
  { "(bad)" },  { "ud2a" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d953 8
a960 2
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d962 8
a969 2
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d972 8
a979 8
  { "movl", Rd, Cd },
  { "movl", Rd, Dd },
  { "movl", Cd, Rd },
  { "movl", Dd, Rd },  
  { "movl", Rd, Td },
  { "(bad)" },
  { "movl", Td, Rd },
  { "(bad)" },  
d981 8
a988 2
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d990 8
a997 2
  { "wrmsr" },  { "rdtsc" },  { "rdmsr" },  { "rdpmc" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d999 8
a1006 2
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d1008 8
a1015 2
  { "cmovo", Gv,Ev }, { "cmovno", Gv,Ev }, { "cmovb", Gv,Ev }, { "cmovae", Gv,Ev },
  { "cmove", Gv,Ev }, { "cmovne", Gv,Ev }, { "cmovbe", Gv,Ev }, { "cmova", Gv,Ev },
d1017 8
a1024 2
  { "cmovs", Gv,Ev }, { "cmovns", Gv,Ev }, { "cmovp", Gv,Ev }, { "cmovnp", Gv,Ev },
  { "cmovl", Gv,Ev }, { "cmovge", Gv,Ev }, { "cmovle", Gv,Ev }, { "cmovg", Gv,Ev },  
d1026 8
a1033 2
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d1035 8
a1042 2
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d1044 8
a1051 2
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d1053 8
a1060 2
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d1062 8
a1069 2
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d1071 8
a1078 2
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d1080 8
a1087 8
  { "jo", Jv },
  { "jno", Jv },
  { "jb", Jv },
  { "jae", Jv },  
  { "je", Jv },
  { "jne", Jv },
  { "jbe", Jv },
  { "ja", Jv },  
d1089 8
a1096 8
  { "js", Jv },
  { "jns", Jv },
  { "jp", Jv },
  { "jnp", Jv },  
  { "jl", Jv },
  { "jge", Jv },
  { "jle", Jv },
  { "jg", Jv },  
d1098 8
a1105 8
  { "seto", Eb },
  { "setno", Eb },
  { "setb", Eb },
  { "setae", Eb },
  { "sete", Eb },
  { "setne", Eb },
  { "setbe", Eb },
  { "seta", Eb },
d1107 8
a1114 8
  { "sets", Eb },
  { "setns", Eb },
  { "setp", Eb },
  { "setnp", Eb },
  { "setl", Eb },
  { "setge", Eb },
  { "setle", Eb },
  { "setg", Eb },  
d1116 4
a1119 4
  { "pushl", fs },
  { "popl", fs },
  { "cpuid" },
  { "btS", Ev, Gv },  
d1122 2
a1123 2
  { "(bad)" },
  { "(bad)" },  
d1125 4
a1128 4
  { "pushl", gs },
  { "popl", gs },
  { "rsm" },
  { "btsS", Ev, Gv },  
d1131 294
a1424 2
  { "(bad)" },
  { "imulS", Gv, Ev },  
d1426 8
a1433 8
  { "cmpxchgb", Eb, Gb },
  { "cmpxchgS", Ev, Gv },
  { "lssS", Gv, Mp },	/* 386 lists only Mp */
  { "btrS", Ev, Gv },  
  { "lfsS", Gv, Mp },	/* 386 lists only Mp */
  { "lgsS", Gv, Mp },	/* 386 lists only Mp */
  { "movzbS", Gv, Eb },
  { "movzwS", Gv, Ew },  
d1435 2
a1436 2
  { "ud2b" },
  { "(bad)" },
d1438 5
a1442 5
  { "btcS", Ev, Gv },  
  { "bsfS", Gv, Ev },
  { "bsrS", Gv, Ev },
  { "movsbS", Gv, Eb },
  { "movswS", Gv, Ew },  
d1444 8
a1451 8
  { "xaddb", Eb, Gb },
  { "xaddS", Ev, Gv },
  { "(bad)" },
  { "(bad)" },  
  { "(bad)" },
  { "(bad)" },
  { "(bad)" },
  { GRP9 },  
d1453 8
a1460 8
  { "bswap", eAX },
  { "bswap", eCX },
  { "bswap", eDX },
  { "bswap", eBX },
  { "bswap", eSP },
  { "bswap", eBP },
  { "bswap", eSI },
  { "bswap", eDI },
d1462 8
a1469 2
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d1471 8
a1478 2
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d1480 8
a1487 2
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d1489 8
a1496 2
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d1498 8
a1505 2
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d1507 8
a1514 2
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d1518 20
a1537 16
  1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,
  1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,
  1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,
  1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,
  1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1
d1541 43
a1583 16
  1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,
  1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
d1590 1
d1596 1
a1596 1
static void oappend PARAMS ((char *s));
d1598 1
a1598 1
static char *names32[]={
d1601 1
a1601 1
static char *names16[] = {
d1604 1
a1604 1
static char *names8[] = {
d1607 1
a1607 1
static char *names_seg[] = {
d1610 2
a1611 2
static char *index16[] = {
  "bx+si","bx+di","bp+si","bp+di","si","di","bp","bx"
d1614 1
a1614 1
static struct dis386 grps[][8] = {
d1617 8
a1624 8
    { "addb",	Eb, Ib },
    { "orb",	Eb, Ib },
    { "adcb",	Eb, Ib },
    { "sbbb",	Eb, Ib },
    { "andb",	Eb, Ib },
    { "subb",	Eb, Ib },
    { "xorb",	Eb, Ib },
    { "cmpb",	Eb, Ib }
d1628 8
a1635 8
    { "addS",	Ev, Iv },
    { "orS",	Ev, Iv },
    { "adcS",	Ev, Iv },
    { "sbbS",	Ev, Iv },
    { "andS",	Ev, Iv },
    { "subS",	Ev, Iv },
    { "xorS",	Ev, Iv },
    { "cmpS",	Ev, Iv }
d1639 8
a1646 8
    { "addS",	Ev, sIb },
    { "orS",	Ev, sIb },
    { "adcS",	Ev, sIb },
    { "sbbS",	Ev, sIb },
    { "andS",	Ev, sIb },
    { "subS",	Ev, sIb },
    { "xorS",	Ev, sIb },
    { "cmpS",	Ev, sIb }
d1650 8
a1657 8
    { "rolb",	Eb, Ib },
    { "rorb",	Eb, Ib },
    { "rclb",	Eb, Ib },
    { "rcrb",	Eb, Ib },
    { "shlb",	Eb, Ib },
    { "shrb",	Eb, Ib },
    { "(bad)" },
    { "sarb",	Eb, Ib },
d1661 8
a1668 8
    { "rolS",	Ev, Ib },
    { "rorS",	Ev, Ib },
    { "rclS",	Ev, Ib },
    { "rcrS",	Ev, Ib },
    { "shlS",	Ev, Ib },
    { "shrS",	Ev, Ib },
    { "(bad)" },
    { "sarS",	Ev, Ib },
d1672 8
a1679 8
    { "rolb",	Eb },
    { "rorb",	Eb },
    { "rclb",	Eb },
    { "rcrb",	Eb },
    { "shlb",	Eb },
    { "shrb",	Eb },
    { "(bad)" },
    { "sarb",	Eb },
d1683 8
a1690 8
    { "rolS",	Ev },
    { "rorS",	Ev },
    { "rclS",	Ev },
    { "rcrS",	Ev },
    { "shlS",	Ev },
    { "shrS",	Ev },
    { "(bad)" },
    { "sarS",	Ev },
d1694 8
a1701 8
    { "rolb",	Eb, CL },
    { "rorb",	Eb, CL },
    { "rclb",	Eb, CL },
    { "rcrb",	Eb, CL },
    { "shlb",	Eb, CL },
    { "shrb",	Eb, CL },
    { "(bad)" },
    { "sarb",	Eb, CL },
d1705 8
a1712 8
    { "rolS",	Ev, CL },
    { "rorS",	Ev, CL },
    { "rclS",	Ev, CL },
    { "rcrS",	Ev, CL },
    { "shlS",	Ev, CL },
    { "shrS",	Ev, CL },
    { "(bad)" },
    { "sarS",	Ev, CL }
d1716 8
a1723 8
    { "testb",	Eb, Ib },
    { "(bad)",	Eb },
    { "notb",	Eb },
    { "negb",	Eb },
    { "mulb",	AL, Eb },
    { "imulb",	AL, Eb },
    { "divb",	AL, Eb },
    { "idivb",	AL, Eb }
d1727 8
a1734 8
    { "testS",	Ev, Iv },
    { "(bad)" },
    { "notS",	Ev },
    { "negS",	Ev },
    { "mulS",	eAX, Ev },
    { "imulS",	eAX, Ev },
    { "divS",	eAX, Ev },
    { "idivS",	eAX, Ev },
d1738 8
a1745 8
    { "incb", Eb },
    { "decb", Eb },
    { "(bad)" },
    { "(bad)" },
    { "(bad)" },
    { "(bad)" },
    { "(bad)" },
    { "(bad)" },
d1749 8
a1756 8
    { "incS",	Ev },
    { "decS",	Ev },
    { "call",	indirEv },
    { "lcall",	indirEv },
    { "jmp",	indirEv },
    { "ljmp",	indirEv },
    { "pushS",	Ev },
    { "(bad)" },
d1760 8
a1767 8
    { "sldt",	Ew },
    { "str",	Ew },
    { "lldt",	Ew },
    { "ltr",	Ew },
    { "verr",	Ew },
    { "verw",	Ew },
    { "(bad)" },
    { "(bad)" }
d1771 8
a1778 8
    { "sgdt", Ew },
    { "sidt", Ew },
    { "lgdt", Ew },
    { "lidt", Ew },
    { "smsw", Ew },
    { "(bad)" },
    { "lmsw", Ew },
    { "invlpg", Ew },
d1782 8
a1789 8
    { "(bad)" },
    { "(bad)" },
    { "(bad)" },
    { "(bad)" },
    { "btS",	Ev, Ib },
    { "btsS",	Ev, Ib },
    { "btrS",	Ev, Ib },
    { "btcS",	Ev, Ib },
d1793 74
a1866 8
    { "(bad)" },
    { "cmpxchg8b", Ev },
    { "(bad)" },
    { "(bad)" },
    { "(bad)" },
    { "(bad)" },
    { "(bad)" },
    { "(bad)" },
d1868 1
d1871 77
a1947 12
#define PREFIX_REPZ 1
#define PREFIX_REPNZ 2
#define PREFIX_LOCK 4
#define PREFIX_CS 8
#define PREFIX_SS 0x10
#define PREFIX_DS 0x20
#define PREFIX_ES 0x40
#define PREFIX_FS 0x80
#define PREFIX_GS 0x100
#define PREFIX_DATA 0x200
#define PREFIX_ADR 0x400
#define PREFIX_FWAIT 0x800
d1949 1
a1949 1
static int prefixes;
d1955 1
d1992 1
a1992 1
	  prefixes |= PREFIX_ADR;
d1994 11
a2004 2
	case 0x9b:
	  prefixes |= PREFIX_FWAIT;
d2013 39
d2053 3
a2055 2
static int op_address[3], op_ad, op_index[3];
static int start_pc;
d2067 9
a2075 2
int print_insn_x86 PARAMS ((bfd_vma pc, disassemble_info *info, int aflag,
			    int dflag));
d2077 1
a2077 1
print_insn_i386 (pc, info)
d2081 7
a2087 6
  if (info->mach == bfd_mach_i386_i386)
    return print_insn_x86 (pc, info, 1, 1);
  else if (info->mach == bfd_mach_i386_i8086)
    return print_insn_x86 (pc, info, 0, 0);
  else
    abort ();
d2091 15
a2105 1
print_insn_x86 (pc, info, aflag, dflag)
d2109 1
a2109 1
  struct dis386 *dp;
d2111 1
a2111 1
  int enter_instruction;
d2115 3
d2122 12
a2133 3
  /* The output looks better if we put 5 bytes on a line, since that
     puts long word instructions on a single line.  */
  info->bytes_per_line = 5;
a2137 3
  if (setjmp (priv.bailout) != 0)
    /* Error return.  */
    return -1;
d2150 26
a2175 1
  
d2178 2
d2181 2
a2182 5
  if (*codep == 0xc8)
    enter_instruction = 1;
  else
    enter_instruction = 0;
  
d2184 1
a2184 8
  
  if (prefixes & PREFIX_REPZ)
    oappend ("repz ");
  if (prefixes & PREFIX_REPNZ)
    oappend ("repnz ");
  if (prefixes & PREFIX_LOCK)
    oappend ("lock ");
  
d2188 9
a2196 3
      /* fwait not followed by floating point instruction */
      (*info->fprintf_func) (info->stream, "fwait");
      return (1);
d2198 1
a2198 10
  
  if (prefixes & PREFIX_DATA)
    dflag ^= 1;
  
  if (prefixes & PREFIX_ADR)
    {
      aflag ^= 1;
      oappend ("addr16 ");
    }
  
d2202 4
a2205 1
      dp = &dis386_twobyte[*++codep];
d2207 1
d2211 4
a2214 1
      dp = &dis386[*codep];
d2216 1
d2220 29
d2259 1
a2259 1
      dofloat (aflag, dflag);
d2264 18
a2281 4
	dp = &grps[dp->bytemode1][reg];
      
      putop (dp->name, aflag, dflag);
      
d2285 2
a2286 2
	(*dp->op1)(dp->bytemode1, aflag, dflag);
      
d2290 2
a2291 2
	(*dp->op2)(dp->bytemode2, aflag, dflag);
      
d2295 16
a2310 1
	(*dp->op3)(dp->bytemode3, aflag, dflag);
d2312 1
a2312 1
  
d2318 4
a2321 6
  
  /* enter instruction is printed with operands in the
   * same order as the intel book; everything else
   * is printed in reverse order 
   */
  if (enter_instruction)
d2340 1
a2340 1
	(*info->print_address_func) (op_address[op_index[0]], info);
d2350 1
a2350 1
	(*info->print_address_func) (op_address[op_index[1]], info);
d2360 1
a2360 1
	(*info->print_address_func) (op_address[op_index[2]], info);
d2364 1
a2364 1
  return (codep - inbuf);
d2367 1
a2367 1
static char *float_mem[] = {
d2442 89
a2530 14
#define ST OP_ST, 0
#define STi OP_STi, 0

#define FGRPd9_2 NULL, NULL, 0
#define FGRPd9_4 NULL, NULL, 1
#define FGRPd9_5 NULL, NULL, 2
#define FGRPd9_6 NULL, NULL, 3
#define FGRPd9_7 NULL, NULL, 4
#define FGRPda_5 NULL, NULL, 5
#define FGRPdb_4 NULL, NULL, 6
#define FGRPde_3 NULL, NULL, 7
#define FGRPdf_4 NULL, NULL, 8

static struct dis386 float_reg[][8] = {
d2533 8
a2540 8
    { "fadd",	ST, STi },
    { "fmul",	ST, STi },
    { "fcom",	STi },
    { "fcomp",	STi },
    { "fsub",	ST, STi },
    { "fsubr",	ST, STi },
    { "fdiv",	ST, STi },
    { "fdivr",	ST, STi },
d2544 2
a2545 2
    { "fld",	STi },
    { "fxch",	STi },
d2547 1
a2547 1
    { "(bad)" },
d2555 5
a2559 5
    { "fcmovb",	ST, STi },
    { "fcmove",	ST, STi },
    { "fcmovbe",ST, STi },
    { "fcmovu",	ST, STi },
    { "(bad)" },
d2561 2
a2562 2
    { "(bad)" },
    { "(bad)" },
d2566 4
a2569 4
    { "fcmovnb",ST, STi },
    { "fcmovne",ST, STi },
    { "fcmovnbe",ST, STi },
    { "fcmovnu",ST, STi },
d2571 3
a2573 3
    { "fucomi",	ST, STi },
    { "fcomi",	ST, STi },
    { "(bad)" },
d2577 15
a2591 8
    { "fadd",	STi, ST },
    { "fmul",	STi, ST },
    { "(bad)" },
    { "(bad)" },
    { "fsub",	STi, ST },
    { "fsubr",	STi, ST },
    { "fdiv",	STi, ST },
    { "fdivr",	STi, ST },
d2595 8
a2602 8
    { "ffree",	STi },
    { "(bad)" },
    { "fst",	STi },
    { "fstp",	STi },
    { "fucom",	STi },
    { "fucomp",	STi },
    { "(bad)" },
    { "(bad)" },
d2606 3
a2608 3
    { "faddp",	STi, ST },
    { "fmulp",	STi, ST },
    { "(bad)" },
d2610 11
a2620 4
    { "fsubp",	STi, ST },
    { "fsubrp",	STi, ST },
    { "fdivp",	STi, ST },
    { "fdivrp",	STi, ST },
d2624 4
a2627 4
    { "(bad)" },
    { "(bad)" },
    { "(bad)" },
    { "(bad)" },
d2629 3
a2631 3
    { "fucomip",ST, STi },
    { "fcomip", ST, STi },
    { "(bad)" },
d2685 2
a2686 3
dofloat (aflag, dflag)
     int aflag;
     int dflag;
d2688 1
a2688 1
  struct dis386 *dp;
d2690 1
a2690 1
  
d2692 1
a2692 1
  
d2695 4
a2698 1
      putop (float_mem[(floatop - 0xd8) * 8 + reg], aflag, dflag);
d2700 6
a2705 1
      OP_E (v_mode, aflag, dflag);
d2709 1
a2709 1
  
d2713 2
a2714 1
      putop (fgrps[dp->bytemode1][rm], aflag, dflag);
d2716 2
a2717 4
      if (floatop == 0xdf
	  && FETCH_DATA (the_info, codep + 1)
	  && *codep == 0xe0)
	strcpy (op1out, "%eax");
d2721 2
a2722 1
      putop (dp->name, aflag, dflag);
d2725 1
a2725 1
	(*dp->op1)(dp->bytemode1, aflag, dflag);
d2728 1
a2728 1
	(*dp->op2)(dp->bytemode2, aflag, dflag);
d2733 4
a2736 5
static int
OP_ST (ignore, aflag, dflag)
     int ignore;
     int aflag;
     int dflag;
a2738 1
  return (0);
d2742 4
a2745 5
static int
OP_STi (ignore, aflag, dflag)
     int ignore;
     int aflag;
     int dflag;
a2748 1
  return (0);
d2754 3
a2756 4
putop (template, aflag, dflag)
     char *template;
     int aflag;
     int dflag;
d2758 2
a2759 2
  char *p;
  
d2767 20
a2786 2
	case 'C':		/* For jcxz/jecxz */
	  if (aflag)
d2789 8
d2800 57
d2859 17
a2875 3
	  /* operand size flag */
	  if (dflag)
	    *obufp++ = 'l';
d2877 14
a2890 1
	    *obufp++ = 'w';
d2899 1
a2899 1
     char *s;
a2902 1
  *obufp = 0;
d2906 1
a2906 1
append_prefix ()
d2909 4
a2912 1
    oappend ("%cs:");
d2914 4
a2917 1
    oappend ("%ds:");
d2919 4
a2922 1
    oappend ("%ss:");
d2924 4
a2927 1
    oappend ("%es:");
d2929 4
a2932 1
    oappend ("%fs:");
d2934 4
a2937 1
    oappend ("%gs:");
d2940 2
a2941 2
static int
OP_indirE (bytemode, aflag, dflag)
d2943 1
a2943 2
     int aflag;
     int dflag;
d2945 3
a2947 2
  oappend ("*");
  return OP_E (bytemode, aflag, dflag);
d2950 2
a2951 2
static int
OP_E (bytemode, aflag, dflag)
d2953 1
a2953 2
     int aflag;
     int dflag;
d2970 3
d2974 1
a2974 1
	  if (dflag)
d2978 5
d2985 1
a2985 1
	  oappend ("<bad dis table>");
d2988 1
a2988 1
      return 0;
d2992 1
a2992 1
  append_prefix ();
d2994 1
a2994 1
  if (aflag) /* 32 bit address mode */
d2999 2
a3000 2
      int index;
      int scale;
d3027 3
a3029 1
	  disp = *(char *)codep++;
d3036 6
a3041 5
      if (mod != 0 || base == 5)
	{
	  sprintf (scratchbuf, "0x%x", disp);
	  oappend (scratchbuf);
	}
d3045 25
a3069 1
	  oappend ("(");
d3076 11
a3086 1
		  sprintf (scratchbuf, ",%s", names32[index]);
d3089 11
a3099 2
	      sprintf (scratchbuf, ",%d", 1 << scale);
	      oappend (scratchbuf);
d3101 18
a3118 1
	  oappend (")");
d3120 16
d3143 5
a3147 1
	    disp = (short) get16 ();
d3151 3
a3153 1
	  disp = *(char *)codep++;
d3156 3
a3158 1
	  disp = (short) get16 ();
d3162 6
a3167 5
      if (mod != 0 || rm == 6)
	{
	  sprintf (scratchbuf, "0x%x", disp);
	  oappend (scratchbuf);
	}
d3171 2
a3172 1
	  oappend ("(");
d3174 2
a3175 1
	  oappend (")");
a3177 1
  return 0;
d3180 2
a3181 2
static int
OP_G (bytemode, aflag, dflag)
d3183 1
a3183 2
     int aflag;
     int dflag;
d3185 1
a3185 1
  switch (bytemode) 
d3197 1
a3197 1
      if (dflag)
d3201 1
d3204 1
a3204 1
      oappend ("<internal disassembler error>");
a3206 1
  return (0);
d3219 1
a3219 1
  return (x);
d3230 1
a3230 1
  return (x);
d3235 1
a3235 1
     int op;
d3241 2
a3242 2
static int
OP_REG (code, aflag, dflag)
d3244 1
a3244 2
     int aflag;
     int dflag;
d3246 22
a3267 20
  char *s;
  
  switch (code) 
    {
    case indir_dx_reg: s = "(%dx)"; break;
	case ax_reg: case cx_reg: case dx_reg: case bx_reg:
	case sp_reg: case bp_reg: case si_reg: case di_reg:
		s = names16[code - ax_reg];
		break;
	case es_reg: case ss_reg: case cs_reg:
	case ds_reg: case fs_reg: case gs_reg:
		s = names_seg[code - es_reg];
		break;
	case al_reg: case ah_reg: case cl_reg: case ch_reg:
	case dl_reg: case dh_reg: case bl_reg: case bh_reg:
		s = names8[code - al_reg];
		break;
	case eAX_reg: case eCX_reg: case eDX_reg: case eBX_reg:
	case eSP_reg: case eBP_reg: case eSI_reg: case eDI_reg:
      if (dflag)
d3271 1
d3274 1
a3274 1
      s = "<internal disassembler error>";
a3277 1
  return (0);
d3280 2
a3281 2
static int
OP_I (bytemode, aflag, dflag)
d3283 1
a3283 2
     int aflag;
     int dflag;
d3286 2
a3287 2
  
  switch (bytemode) 
d3294 1
a3294 1
      if (dflag)
d3298 1
d3304 2
a3305 2
      oappend ("<internal disassembler error>");
      return (0);
d3307 5
a3311 1
  sprintf (scratchbuf, "$0x%x", op);
d3313 1
a3313 1
  return (0);
d3316 2
a3317 2
static int
OP_sI (bytemode, aflag, dflag)
d3319 1
a3319 2
     int aflag;
     int dflag;
d3322 2
a3323 2
  
  switch (bytemode) 
d3327 3
a3329 1
      op = *(char *)codep++;
d3332 1
a3332 1
      if (dflag)
d3335 6
a3340 1
	op = (short)get16();
d3343 3
a3345 1
      op = (short)get16 ();
d3348 2
a3349 2
      oappend ("<internal disassembler error>");
      return (0);
d3351 4
a3354 1
  sprintf (scratchbuf, "$0x%x", op);
a3355 1
  return (0);
d3358 2
a3359 2
static int
OP_J (bytemode, aflag, dflag)
d3361 1
a3361 2
     int aflag;
     int dflag;
d3365 2
a3366 2
  
  switch (bytemode) 
d3370 3
a3372 1
      disp = *(char *)codep++;
d3375 1
a3375 1
      if (dflag)
d3379 1
a3379 1
	  disp = (short)get16 ();
d3385 1
d3388 2
a3389 2
      oappend ("<internal disassembler error>");
      return (0);
a3394 1
  return (0);
d3398 4
a3401 5
static int
OP_SEG (dummy, aflag, dflag)
     int dummy;
     int aflag;
     int dflag;
a3407 1
  return (0);
d3410 5
a3414 5
static int
OP_DIR (size, aflag, dflag)
     int size;
     int aflag;
     int dflag;
d3417 2
a3418 2
  
  switch (size) 
d3420 7
a3426 28
    case lptr:
      if (aflag) 
	{
	  offset = get32 ();
	  seg = get16 ();
	} 
      else 
	{
	  offset = get16 ();
	  seg = get16 ();
	}
      sprintf (scratchbuf, "0x%x,0x%x", seg, offset);
      oappend (scratchbuf);
      break;
    case v_mode:
      if (aflag)
	offset = get32 ();
      else
	offset = (short)get16 ();
      
      offset = start_pc + codep - start_codep + offset;
      set_op (offset);
      sprintf (scratchbuf, "0x%x", offset);
      oappend (scratchbuf);
      break;
    default:
      oappend ("<internal disassembler error>");
      break;
d3428 3
a3430 1
  return (0);
d3434 4
a3437 5
static int
OP_OFF (bytemode, aflag, dflag)
     int bytemode;
     int aflag;
     int dflag;
d3441 1
a3441 1
  append_prefix ();
d3443 1
a3443 1
  if (aflag)
d3447 10
a3456 1
  
a3458 1
  return (0);
d3461 4
a3464 6
/* ARGSUSED */
static int
OP_ESDI (dummy, aflag, dflag)
     int dummy;
     int aflag;
     int dflag;
d3466 7
a3472 2
  oappend ("%es:(");
  oappend (aflag ? "%edi" : "%di");
a3473 1
  return (0);
d3476 4
a3479 6
/* ARGSUSED */
static int
OP_DSSI (dummy, aflag, dflag)
     int dummy;
     int aflag;
     int dflag;
d3481 2
a3482 4
  oappend ("%ds:(");
  oappend (aflag ? "%esi" : "%si");
  oappend (")");
  return (0);
d3485 4
a3488 9
#if 0
/* Not used.  */

/* ARGSUSED */
static int
OP_ONE (dummy, aflag, dflag)
     int dummy;
     int aflag;
     int dflag;
d3490 10
a3499 2
  oappend ("1");
  return (0);
a3501 2
#endif

d3503 4
a3506 5
static int
OP_C (dummy, aflag, dflag)
     int dummy;
     int aflag;
     int dflag;
a3507 1
  codep++; /* skip mod/rm */
a3509 1
  return (0);
d3513 4
a3516 5
static int
OP_D (dummy, aflag, dflag)
     int dummy;
     int aflag;
     int dflag;
a3517 1
  codep++; /* skip mod/rm */
a3519 1
  return (0);
d3523 4
a3526 5
static int
OP_T (dummy, aflag, dflag)
     int dummy;
     int aflag;
     int dflag;
a3527 1
  codep++; /* skip mod/rm */
a3529 1
  return (0);
d3532 63
a3594 2
static int
OP_rm (bytemode, aflag, dflag)
d3596 145
a3740 2
     int aflag;
     int dflag;
d3742 3
a3744 1
  switch (bytemode) 
d3746 6
a3751 6
    case d_mode:
      oappend (names32[rm]);
      break;
    case w_mode:
      oappend (names16[rm]);
      break;
d3753 6
a3758 1
  return (0);
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d144 1
a144 1
typedef int op_rtn PARAMS ((int bytemode, int aflag, int dflag));
d146 18
a163 3
static op_rtn OP_E, OP_G, OP_I, OP_indirE, OP_sI, OP_REG, OP_J, OP_DIR, OP_OFF;
static op_rtn OP_ESDI, OP_DSSI, OP_SEG, OP_C, OP_D, OP_T, OP_rm, OP_ST;
static op_rtn OP_STi;
d165 1
a165 1
static op_rtn OP_ONE;
d241 1
a241 1
  op_rtn *op1;
d243 1
a243 1
  op_rtn *op2;
d245 1
a245 1
  op_rtn *op3;
d1079 4
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d100 1
d102 1
d144 1
a144 4
int OP_E(), OP_indirE(), OP_G(), OP_I(), OP_sI(), OP_REG();
int OP_J(), OP_SEG();
int OP_DIR(), OP_OFF(), OP_DSSI(), OP_ESDI(), OP_ONE(), OP_C();
int OP_D(), OP_T(), OP_rm();
d146 14
a159 2
static void dofloat (), putop (), append_prefix (), set_op ();
static int get16 (), get32 ();
d226 1
a226 1
  int (*op1)();
d228 1
a228 1
  int (*op2)();
d230 1
a230 1
  int (*op3)();
d234 1
a234 1
struct dis386 dis386[] = {
d525 1
a525 1
struct dis386 dis386_twobyte[] = {
d746 1
a746 1
static void oappend ();
d764 1
a764 1
struct dis386 grps[][8] = {
a1020 3
static int dflag;
static int aflag;		

d1035 2
d1042 13
a1108 4
  /* these would be initialized to 0 if disassembling for 8086 or 286 */
  dflag = 1;
  aflag = 1;
  
d1141 1
a1141 1
      dofloat ();
d1148 1
a1148 1
      putop (dp->name);
d1153 1
a1153 1
	(*dp->op1)(dp->bytemode1);
d1158 1
a1158 1
	(*dp->op2)(dp->bytemode2);
d1163 1
a1163 1
	(*dp->op3)(dp->bytemode3);
d1222 1
a1222 1
char *float_mem[] = {
a1298 1
int OP_ST(), OP_STi();
d1310 1
a1310 1
struct dis386 float_reg[][8] = {
d1402 1
a1402 1
char *fgrps[][8] = {
d1451 3
a1453 1
dofloat ()
d1462 1
a1462 1
      putop (float_mem[(floatop - 0xd8) * 8 + reg]);
d1464 1
a1464 1
      OP_E (v_mode);
d1472 1
a1472 1
      putop (fgrps[dp->bytemode1][rm]);
d1481 1
a1481 1
      putop (dp->name);
d1484 1
a1484 1
	(*dp->op1)(dp->bytemode1);
d1487 1
a1487 1
	(*dp->op2)(dp->bytemode2);
d1492 2
a1493 2
int
OP_ST (ignore)
d1495 2
d1503 2
a1504 2
int
OP_STi (ignore)
d1506 2
d1517 1
a1517 1
putop (template)
d1519 2
d1577 2
a1578 2
int
OP_indirE (bytemode)
d1580 2
d1584 1
a1584 1
  return OP_E (bytemode);
d1587 2
a1588 2
int
OP_E (bytemode)
d1590 2
d1721 2
a1722 2
int
OP_G (bytemode)
d1724 2
d1783 2
a1784 2
int
OP_REG (code)
d1786 2
d1821 2
a1822 2
int
OP_I (bytemode)
d1824 2
d1853 2
a1854 2
int
OP_sI (bytemode)
d1856 2
d1885 2
a1886 2
int
OP_J (bytemode)
d1888 2
d1924 2
a1925 2
int
OP_SEG (dummy)
d1927 2
d1938 2
a1939 2
int
OP_DIR (size)
d1941 2
d1981 2
a1982 2
int
OP_OFF (bytemode)
d1984 2
d2002 5
a2006 3
int
OP_ESDI (dummy)
    int dummy;
d2015 5
a2019 3
int
OP_DSSI (dummy)
    int dummy;
d2027 3
d2031 5
a2035 3
int
OP_ONE (dummy)
    int dummy;
d2041 2
d2044 5
a2048 3
int
OP_C (dummy)
    int dummy;
d2057 5
a2061 3
int
OP_D (dummy)
    int dummy;
d2070 2
a2071 2
int
OP_T (dummy)
d2073 2
d2082 2
a2083 2
int
OP_rm (bytemode)
d2085 2
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1988, 1989, 1991, 1993, 1994, 1995 Free Software Foundation, Inc.
d351 1
a351 1
  { "jo",		Jb },
d353 1
a353 1
  { "jb",		Jb },
d355 1
a355 1
  { "je",		Jb },
d358 1
a358 1
  { "ja",		Jb },
d360 1
a360 1
  { "js",		Jb },
d362 1
a362 1
  { "jp",		Jb },
d364 1
a364 1
  { "jl",		Jb },
d367 1
a367 1
  { "jg",		Jb },
d527 1
a527 1
  { "(bad)" },  { "(bad)" },  
d549 1
a549 1
  { "wrmsr" },  { "rdtsc" },  { "rdmsr" },  { "(bad)" },  
d555 2
a556 2
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d558 2
a559 2
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
  { "(bad)" },  { "(bad)" },  { "(bad)" },  { "(bad)" },  
d642 1
a642 1
  { "(bad)" },
d688 38
d749 3
d1037 2
a1038 1
  
d1103 1
d1106 4
a1109 1
    dp = &dis386[*codep];
d1112 7
a1118 9
  /* Fetch the mod/reg/rm byte.  FIXME: We should be only fetching
     this if we need it.  As it is, this code loses if there is a
     one-byte instruction (without a mod/reg/rm byte) at the end of
     the address space.  */

  FETCH_DATA (info, codep + 1);
  mod = (*codep >> 6) & 3;
  reg = (*codep >> 3) & 7;
  rm = *codep & 7;
d1317 4
a1320 4
    { "(bad)" },
    { "(bad)" },
    { "(bad)" },
    { "(bad)" },
d1328 4
a1331 4
    { "(bad)" },
    { "(bad)" },
    { "(bad)" },
    { "(bad)" },
d1333 2
a1334 2
    { "(bad)" },
    { "(bad)" },
d1377 2
a1378 2
    { "(bad)" },
    { "(bad)" },
d1506 1
a1506 1
	  if (aflag == 0)
d1556 1
a1556 2
  OP_E (bytemode);
  return (0);
d1564 1
a1564 6
  int havesib;
  int base;
  int index;
  int scale;
  int havebase;
  
d1567 1
a1567 5
  
  havesib = 0;
  havebase = 0;
  disp = 0;
  
d1588 1
a1588 1
      return (0);
d1590 2
a1591 1
  
d1593 2
a1594 1
  if (rm == 4)
d1596 7
a1602 1
      havesib = 1;
d1604 13
a1616 11
      FETCH_DATA (the_info, codep + 1);
      scale = (*codep >> 6) & 3;
      index = (*codep >> 3) & 7;
      base = *codep & 7;
      codep++;
    }
  
  switch (mod)
    {
    case 0:
      switch (rm)
d1618 10
a1627 6
	case 4:
	  /* implies havesib and havebase */
	  if (base == 5) {
	    havebase = 0;
	    disp = get32 ();
	  }
d1629 1
a1629 1
	case 5:
a1631 4
	default:
	  havebase = 1;
	  base = rm;
	  break;
d1633 2
a1634 5
      break;
    case 1:
      FETCH_DATA (the_info, codep + 1);
      disp = *(char *)codep++;
      if (rm != 4)
d1636 2
a1637 2
	  havebase = 1;
	  base = rm;
d1639 2
a1640 4
      break;
    case 2:
      disp = get32 ();
      if (rm != 4)
d1642 14
a1655 2
	  havebase = 1;
	  base = rm;
a1656 1
      break;
d1658 18
a1675 13
  
  if (mod != 0 || rm == 5 || (havesib && base == 5))
    {
      sprintf (scratchbuf, "0x%x", disp);
      oappend (scratchbuf);
    }
  
  if (havebase || havesib) 
    {
      oappend ("(");
      if (havebase)
	oappend (names32[base]);
      if (havesib) 
d1677 1
a1677 6
	  if (index != 4) 
	    {
	      sprintf (scratchbuf, ",%s", names32[index]);
	      oappend (scratchbuf);
	    }
	  sprintf (scratchbuf, ",%d", 1 << scale);
d1680 7
a1686 1
      oappend (")");
d1688 1
a1688 1
  return (0);
d1942 3
a1944 1
  
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@d2 1
a2 1
   Copyright (C) 1988, 89, 91, 93, 94, 95, 1996 Free Software Foundation, Inc.
d351 1
a351 1
  { "jo",	Jb },
d353 1
a353 1
  { "jb",	Jb },
d355 1
a355 1
  { "je",	Jb },
d358 1
a358 1
  { "ja",	Jb },
d360 1
a360 1
  { "js",	Jb },
d362 1
a362 1
  { "jp",	Jb },
d364 1
a364 1
  { "jl",	Jb },
d367 1
a367 1
  { "jg",	Jb },
d527 1
a527 1
  { "(bad)" },  { "ud2a" },  
d549 1
a549 1
  { "wrmsr" },  { "rdtsc" },  { "rdmsr" },  { "rdpmc" },  
d555 2
a556 2
  { "cmovo", Gv,Ev }, { "cmovno", Gv,Ev }, { "cmovb", Gv,Ev }, { "cmovae", Gv,Ev },
  { "cmove", Gv,Ev }, { "cmovne", Gv,Ev }, { "cmovbe", Gv,Ev }, { "cmova", Gv,Ev },
d558 2
a559 2
  { "cmovs", Gv,Ev }, { "cmovns", Gv,Ev }, { "cmovp", Gv,Ev }, { "cmovnp", Gv,Ev },
  { "cmovl", Gv,Ev }, { "cmovge", Gv,Ev }, { "cmovle", Gv,Ev }, { "cmovg", Gv,Ev },  
d642 1
a642 1
  { "ud2b" },
a687 38
static const unsigned char onebyte_has_modrm[256] = {
  1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,
  1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,
  1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,
  1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,
  1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1
};

static const unsigned char twobyte_has_modrm[256] = {
  1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,
  1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};

a710 3
static char *index16[] = {
  "bx+si","bx+di","bp+si","bp+di","si","di","bp","bx"
};
d996 1
a996 2
  unsigned char need_modrm;

a1060 1
      need_modrm = twobyte_has_modrm[*codep];
d1063 1
a1063 4
    {
      dp = &dis386[*codep];
      need_modrm = onebyte_has_modrm[*codep];
    }
d1066 9
a1074 7
  if (need_modrm)
    {
      FETCH_DATA (info, codep + 1);
      mod = (*codep >> 6) & 3;
      reg = (*codep >> 3) & 7;
      rm = *codep & 7;
    }
d1273 4
a1276 4
    { "fcmovb",	ST, STi },
    { "fcmove",	ST, STi },
    { "fcmovbe",ST, STi },
    { "fcmovu",	ST, STi },
d1284 4
a1287 4
    { "fcmovnb",ST, STi },
    { "fcmovne",ST, STi },
    { "fcmovnbe",ST, STi },
    { "fcmovnu",ST, STi },
d1289 2
a1290 2
    { "fucomi",	ST, STi },
    { "fcomi",	ST, STi },
d1333 2
a1334 2
    { "fucomip",ST, STi },
    { "fcomip", ST, STi },
d1462 1
a1462 1
	  if (aflag)
d1512 2
a1513 1
  return OP_E (bytemode);
d1521 6
a1526 1

d1529 5
a1533 1

d1554 1
a1554 1
      return 0;
d1556 1
a1556 2

  disp = 0;
d1558 1
a1558 2

  if (aflag) /* 32 bit address mode */
d1560 1
a1560 7
      int havesib;
      int havebase;
      int base;
      int index;
      int scale;

      havesib = 0;
d1562 11
a1572 13
      base = rm;

      if (base == 4)
	{
	  havesib = 1;
	  FETCH_DATA (the_info, codep + 1);
	  scale = (*codep >> 6) & 3;
	  index = (*codep >> 3) & 7;
	  base = *codep & 7;
	  codep++;
	}

      switch (mod)
d1574 6
a1579 6
	case 0:
	  if (base == 5)
	    {
	      havebase = 0;
	      disp = get32 ();
	    }
d1581 2
a1582 3
	case 1:
	  FETCH_DATA (the_info, codep + 1);
	  disp = *(char *)codep++;
d1584 3
a1586 2
	case 2:
	  disp = get32 ();
d1589 13
a1601 2

      if (mod != 0 || base == 5)
d1603 2
a1604 2
	  sprintf (scratchbuf, "0x%x", disp);
	  oappend (scratchbuf);
d1606 15
a1620 2

      if (havebase || (havesib && (index != 4 || scale != 0)))
d1622 1
a1622 4
	  oappend ("(");
	  if (havebase)
	    oappend (names32[base]);
	  if (havesib)
d1624 1
a1624 6
	      if (index != 4)
		{
		  sprintf (scratchbuf, ",%s", names32[index]);
		  oappend (scratchbuf);
		}
	      sprintf (scratchbuf, ",%d", 1 << scale);
d1627 1
a1627 23
	  oappend (")");
	}
    }
  else
    { /* 16 bit address mode */
      switch (mod)
	{
	case 0:
	  if (rm == 6)
	    disp = (short) get16 ();
	  break;
	case 1:
	  FETCH_DATA (the_info, codep + 1);
	  disp = *(char *)codep++;
	  break;
	case 2:
	  disp = (short) get16 ();
	  break;
	}

      if (mod != 0 || rm == 6)
	{
	  sprintf (scratchbuf, "0x%x", disp);
d1630 1
a1630 7

      if (mod != 0 || rm != 6)
	{
	  oappend ("(");
	  oappend (index16[rm]);
	  oappend (")");
	}
d1632 1
a1632 1
  return 0;
d1886 1
a1886 3

  append_prefix ();

@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a99 1
#if 0
a100 1
#endif
d142 4
a145 1
typedef int op_rtn PARAMS ((int bytemode, int aflag, int dflag));
d147 2
a148 14
static op_rtn OP_E, OP_G, OP_I, OP_indirE, OP_sI, OP_REG, OP_J, OP_DIR, OP_OFF;
static op_rtn OP_ESDI, OP_DSSI, OP_SEG, OP_C, OP_D, OP_T, OP_rm, OP_ST;
static op_rtn OP_STi;
#if 0
static op_rtn OP_ONE;
#endif

static void append_prefix PARAMS ((void));
static void set_op PARAMS ((int op));
static void putop PARAMS ((char *template, int aflag, int dflag));
static void dofloat PARAMS ((int aflag, int dflag));
static int get16 PARAMS ((void));
static int get32 PARAMS ((void));
static void ckprefix PARAMS ((void));
d215 1
a215 1
  op_rtn *op1;
d217 1
a217 1
  op_rtn *op2;
d219 1
a219 1
  op_rtn *op3;
d223 1
a223 1
static struct dis386 dis386[] = {
d514 1
a514 1
static struct dis386 dis386_twobyte[] = {
d735 1
a735 1
static void oappend PARAMS ((char *s));
d753 1
a753 1
static struct dis386 grps[][8] = {
d1010 3
a1026 2
int print_insn_x86 PARAMS ((bfd_vma pc, disassemble_info *info, int aflag,
			    int dflag));
a1031 13
  if (info->mach == bfd_mach_i386_i386)
    return print_insn_x86 (pc, info, 1, 1);
  else if (info->mach == bfd_mach_i386_i8086)
    return print_insn_x86 (pc, info, 0, 0);
  else
    abort ();
}

int
print_insn_x86 (pc, info, aflag, dflag)
     bfd_vma pc;
     disassemble_info *info;
{
d1086 4
d1122 1
a1122 1
      dofloat (aflag, dflag);
d1129 1
a1129 1
      putop (dp->name, aflag, dflag);
d1134 1
a1134 1
	(*dp->op1)(dp->bytemode1, aflag, dflag);
d1139 1
a1139 1
	(*dp->op2)(dp->bytemode2, aflag, dflag);
d1144 1
a1144 1
	(*dp->op3)(dp->bytemode3, aflag, dflag);
d1203 1
a1203 1
static char *float_mem[] = {
d1280 1
d1292 1
a1292 1
static struct dis386 float_reg[][8] = {
d1384 1
a1384 1
static char *fgrps[][8] = {
d1433 1
a1433 3
dofloat (aflag, dflag)
     int aflag;
     int dflag;
d1442 1
a1442 1
      putop (float_mem[(floatop - 0xd8) * 8 + reg], aflag, dflag);
d1444 1
a1444 1
      OP_E (v_mode, aflag, dflag);
d1452 1
a1452 1
      putop (fgrps[dp->bytemode1][rm], aflag, dflag);
d1461 1
a1461 1
      putop (dp->name, aflag, dflag);
d1464 1
a1464 1
	(*dp->op1)(dp->bytemode1, aflag, dflag);
d1467 1
a1467 1
	(*dp->op2)(dp->bytemode2, aflag, dflag);
d1472 2
a1473 2
static int
OP_ST (ignore, aflag, dflag)
a1474 2
     int aflag;
     int dflag;
d1481 2
a1482 2
static int
OP_STi (ignore, aflag, dflag)
a1483 2
     int aflag;
     int dflag;
d1493 1
a1493 1
putop (template, aflag, dflag)
a1494 2
     int aflag;
     int dflag;
d1551 2
a1552 2
static int
OP_indirE (bytemode, aflag, dflag)
a1553 2
     int aflag;
     int dflag;
d1556 1
a1556 1
  return OP_E (bytemode, aflag, dflag);
d1559 2
a1560 2
static int
OP_E (bytemode, aflag, dflag)
a1561 2
     int aflag;
     int dflag;
d1691 2
a1692 2
static int
OP_G (bytemode, aflag, dflag)
a1693 2
     int aflag;
     int dflag;
d1751 2
a1752 2
static int
OP_REG (code, aflag, dflag)
a1753 2
     int aflag;
     int dflag;
d1787 2
a1788 2
static int
OP_I (bytemode, aflag, dflag)
a1789 2
     int aflag;
     int dflag;
d1817 2
a1818 2
static int
OP_sI (bytemode, aflag, dflag)
a1819 2
     int aflag;
     int dflag;
d1847 2
a1848 2
static int
OP_J (bytemode, aflag, dflag)
a1849 2
     int aflag;
     int dflag;
d1884 2
a1885 2
static int
OP_SEG (dummy, aflag, dflag)
a1886 2
     int aflag;
     int dflag;
d1896 2
a1897 2
static int
OP_DIR (size, aflag, dflag)
a1898 2
     int aflag;
     int dflag;
d1937 2
a1938 2
static int
OP_OFF (bytemode, aflag, dflag)
a1939 2
     int aflag;
     int dflag;
d1956 3
a1958 5
static int
OP_ESDI (dummy, aflag, dflag)
     int dummy;
     int aflag;
     int dflag;
d1967 3
a1969 5
static int
OP_DSSI (dummy, aflag, dflag)
     int dummy;
     int aflag;
     int dflag;
a1976 3
#if 0
/* Not used.  */

d1978 3
a1980 5
static int
OP_ONE (dummy, aflag, dflag)
     int dummy;
     int aflag;
     int dflag;
a1985 2
#endif

d1987 3
a1989 5
static int
OP_C (dummy, aflag, dflag)
     int dummy;
     int aflag;
     int dflag;
d1998 3
a2000 5
static int
OP_D (dummy, aflag, dflag)
     int dummy;
     int aflag;
     int dflag;
d2009 2
a2010 2
static int
OP_T (dummy, aflag, dflag)
a2011 2
     int aflag;
     int dflag;
d2019 2
a2020 2
static int
OP_rm (bytemode, aflag, dflag)
a2021 2
     int aflag;
     int dflag;
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d144 1
a144 1
typedef int (*op_rtn) PARAMS ((int bytemode, int aflag, int dflag));
d146 3
a148 18
static int OP_E PARAMS ((int, int, int));
static int OP_G PARAMS ((int, int, int));
static int OP_I PARAMS ((int, int, int));
static int OP_indirE PARAMS ((int, int, int));
static int OP_sI PARAMS ((int, int, int));
static int OP_REG PARAMS ((int, int, int));
static int OP_J PARAMS ((int, int, int));
static int OP_DIR PARAMS ((int, int, int));
static int OP_OFF PARAMS ((int, int, int));
static int OP_ESDI PARAMS ((int, int, int));
static int OP_DSSI PARAMS ((int, int, int));
static int OP_SEG PARAMS ((int, int, int));
static int OP_C PARAMS ((int, int, int));
static int OP_D PARAMS ((int, int, int));
static int OP_T PARAMS ((int, int, int));
static int OP_rm PARAMS ((int, int, int));
static int OP_ST PARAMS ((int, int, int));
static int OP_STi  PARAMS ((int, int, int));
d150 1
a150 1
static int OP_ONE PARAMS ((int, int, int));
d226 1
a226 1
  op_rtn op1;
d228 1
a228 1
  op_rtn op2;
d230 1
a230 1
  op_rtn op3;
a1063 4

  /* The output looks better if we put 5 bytes on a line, since that
     puts long word instructions on a single line.  */
  info->bytes_per_line = 5;
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 2
   Copyright (C) 1988, 89, 91, 93, 94, 95, 96, 1997
   Free Software Foundation, Inc.
a41 2
static int fetch_data PARAMS ((struct disassemble_info *, bfd_byte *));

a143 4
#define MX OP_MMX, 0
#define EM OP_EM, v_mode
#define MS OP_MS, b_mode

a166 3
static int OP_MMX PARAMS ((int, int, int));
static int OP_EM PARAMS ((int, int, int));
static int OP_MS PARAMS ((int, int, int));
a234 3
#define GRP10 NULL, NULL, 17
#define GRP11 NULL, NULL, 18
#define GRP12 NULL, NULL, 19
d593 2
a594 8
  { "punpcklbw", MX, EM },
  { "punpcklwd", MX, EM },
  { "punpckldq", MX, EM },
  { "packsswb", MX, EM },
  { "pcmpgtb", MX, EM },
  { "pcmpgtw", MX, EM },
  { "pcmpgtd", MX, EM },
  { "packuswb", MX, EM },
d596 2
a597 7
  { "punpckhbw", MX, EM },
  { "punpckhwd", MX, EM },
  { "punpckhdq", MX, EM },
  { "packssdw", MX, EM },
  { "(bad)" },  { "(bad)" },
  { "movd", MX, Ev },
  { "movq", MX, EM },
d599 2
a600 8
  { "(bad)" },
  { GRP10 },
  { GRP11 },
  { GRP12 },
  { "pcmpeqb", MX, EM },
  { "pcmpeqw", MX, EM },
  { "pcmpeqd", MX, EM },
  { "emms" },
d603 1
a603 3
  { "(bad)" },  { "(bad)" },
  { "movd", Ev, MX },
  { "movq", EM, MX },
d695 2
a696 7
  { "(bad)" },
  { "psrlw", MX, EM },
  { "psrld", MX, EM },
  { "psrlq", MX, EM },
  { "(bad)" },
  { "pmullw", MX, EM },
  { "(bad)" },  { "(bad)" },  
d698 2
a699 8
  { "psubusb", MX, EM },
  { "psubusw", MX, EM },
  { "pand", MX, EM },
  { "(bad)" },
  { "paddusb", MX, EM },
  { "paddusw", MX, EM },
  { "(bad)" },
  { "pand", MX, EM },
d701 2
a702 7
  { "(bad)" },
  { "psraw", MX, EM },
  { "psrad", MX, EM },
  { "(bad)" },
  { "(bad)" },
  { "pmulhw", MX, EM },
  { "(bad)" },  { "(bad)" },  
d704 2
a705 8
  { "psubsb", MX, EM },
  { "psubsw", MX, EM },
  { "(bad)" },
  { "por", MX, EM },
  { "paddsb", MX, EM },
  { "paddsw", MX, EM },
  { "(bad)" },
  { "pxor", MX, EM },
d707 2
a708 7
  { "(bad)" },
  { "psllw", MX, EM },
  { "pslld", MX, EM },
  { "psllq", MX, EM },
  { "(bad)" },
  { "pmaddwd", MX, EM },
  { "(bad)" },  { "(bad)" },  
d710 2
a711 8
  { "psubb", MX, EM },
  { "psubw", MX, EM },
  { "psubd", MX, EM },
  { "(bad)" },  
  { "paddb", MX, EM },
  { "paddw", MX, EM },
  { "paddd", MX, EM },
  { "(bad)" }
d734 16
a749 16
  /* 00 */ 1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0, /* 0f */
  /* 10 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 1f */
  /* 20 */ 1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0, /* 2f */
  /* 30 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 3f */
  /* 40 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 4f */
  /* 50 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 5f */
  /* 60 */ 1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1, /* 6f */
  /* 70 */ 0,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1, /* 7f */
  /* 80 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 8f */
  /* 90 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 9f */
  /* a0 */ 0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1, /* af */
  /* b0 */ 1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1, /* bf */
  /* c0 */ 1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0, /* cf */
  /* d0 */ 0,1,1,1,0,1,0,0,1,1,1,0,1,1,0,1, /* df */
  /* e0 */ 0,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1, /* ef */
  /* f0 */ 0,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0  /* ff */
a965 33
  },
  /* GRP10 */
  {
    { "(bad)" },
    { "(bad)" },
    { "psrlw", MS, Ib },
    { "(bad)" },
    { "psraw", MS, Ib },
    { "(bad)" },
    { "psllw", MS, Ib },
    { "(bad)" },
  },
  /* GRP11 */
  {
    { "(bad)" },
    { "(bad)" },
    { "psrld", MS, Ib },
    { "(bad)" },
    { "psrad", MS, Ib },
    { "(bad)" },
    { "pslld", MS, Ib },
    { "(bad)" },
  },
  /* GRP12 */
  {
    { "(bad)" },
    { "(bad)" },
    { "psrlq", MS, Ib },
    { "(bad)" },
    { "(bad)" },
    { "(bad)" },
    { "psllq", MS, Ib },
    { "(bad)" },
a2116 38
}

static int
OP_MMX (bytemode, aflag, dflag)
     int bytemode;
     int aflag;
     int dflag;
{
  sprintf (scratchbuf, "%%mm%d", reg);
  oappend (scratchbuf);
  return 0;
}

static int
OP_EM (bytemode, aflag, dflag)
     int bytemode;
     int aflag;
     int dflag;
{
  if (mod != 3)
    return OP_E (bytemode, aflag, dflag);

  codep++;
  sprintf (scratchbuf, "%%mm%d", rm);
  oappend (scratchbuf);
  return 0;
}

static int
OP_MS (bytemode, aflag, dflag)
     int bytemode;
     int aflag;
     int dflag;
{
  ++codep;
  sprintf (scratchbuf, "%%mm%d", rm);
  oappend (scratchbuf);
  return 0;
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1988, 89, 91, 93, 94, 95, 96, 97, 98, 1999
d32 1
a32 1
 * and the small letter tells about the operand size.  Refer to
a37 1
#include "opintl.h"
a42 6
#ifndef UNIXWARE_COMPAT
/* Set non-zero for broken, compatible instructions.  Set to zero for
   non-broken opcodes.  */
#define UNIXWARE_COMPAT 1
#endif

a53 25
/* The opcode for the fwait instruction, which we treat as a prefix
   when we can.  */
#define FWAIT_OPCODE (0x9b)

/* Flags for the prefixes for the current instruction.  See below.  */
static int prefixes;

/* Flags for prefixes which we somehow handled when printing the
   current instruction.  */
static int used_prefixes;

/* Flags stored in PREFIXES.  */
#define PREFIX_REPZ 1
#define PREFIX_REPNZ 2
#define PREFIX_LOCK 4
#define PREFIX_CS 8
#define PREFIX_SS 0x10
#define PREFIX_DS 0x20
#define PREFIX_ES 0x40
#define PREFIX_FS 0x80
#define PREFIX_GS 0x100
#define PREFIX_DATA 0x200
#define PREFIX_ADDR 0x400
#define PREFIX_FWAIT 0x800

d76 1
a76 6
      /* If we did manage to read at least one byte, then
         print_insn_i386 will do something sensible.  Otherwise, print
         an error.  We do that here because this is where we know
         STATUS.  */
      if (priv->max_fetched == priv->the_buffer)
	(*info->memory_error_func) (status, start, info);
a83 2
#define XX NULL, 0

a87 1
#define Ed OP_E, d_mode
d91 2
a92 2
#define M OP_E, 0		/* lea */
#define Mp OP_E, 0		/* 32 or 48 bit memory operand for LDS, LES etc */
d95 2
a96 1
#define Rd OP_Rd, d_mode
d103 3
d131 2
a132 1
#define Ap OP_DIR, 0
d135 4
a138 5
#define Xb OP_DSreg, eSI_reg
#define Xv OP_DSreg, eSI_reg
#define Yb OP_ESreg, eDI_reg
#define Yv OP_ESreg, eDI_reg
#define DSBX OP_DSreg, eBX_reg
a147 1
#define XM OP_XMM, 0
d149 1
a149 12
#define EX OP_EX, v_mode
#define MS OP_MS, v_mode
#define None OP_E, 0
#define OPSUF OP_3DNowSuffix, 0
#define OPSIMD OP_SIMD_Suffix, 0

/* bits in sizeflag */
#if 0 /* leave undefined until someone adds the extra flag to objdump */
#define SUFFIX_ALWAYS 4
#endif
#define AFLAG 2
#define DFLAG 1
d151 1
a151 1
typedef void (*op_rtn) PARAMS ((int bytemode, int sizeflag));
d153 29
a181 31
static void OP_E PARAMS ((int, int));
static void OP_G PARAMS ((int, int));
static void OP_I PARAMS ((int, int));
static void OP_indirE PARAMS ((int, int));
static void OP_sI PARAMS ((int, int));
static void OP_REG PARAMS ((int, int));
static void OP_J PARAMS ((int, int));
static void OP_DIR PARAMS ((int, int));
static void OP_OFF PARAMS ((int, int));
static void OP_ESreg PARAMS ((int, int));
static void OP_DSreg PARAMS ((int, int));
static void OP_SEG PARAMS ((int, int));
static void OP_C PARAMS ((int, int));
static void OP_D PARAMS ((int, int));
static void OP_T PARAMS ((int, int));
static void OP_Rd PARAMS ((int, int));
static void OP_ST PARAMS ((int, int));
static void OP_STi  PARAMS ((int, int));
static void OP_MMX PARAMS ((int, int));
static void OP_XMM PARAMS ((int, int));
static void OP_EM PARAMS ((int, int));
static void OP_EX PARAMS ((int, int));
static void OP_MS PARAMS ((int, int));
static void OP_3DNowSuffix PARAMS ((int, int));
static void OP_SIMD_Suffix PARAMS ((int, int));
static void SIMD_Fixup PARAMS ((int, int));

static void append_seg PARAMS ((void));
static void set_op PARAMS ((unsigned int op));
static void putop PARAMS ((const char *template, int sizeflag));
static void dofloat PARAMS ((int sizeflag));
a184 3
static const char *prefix_name PARAMS ((int, int));
static void ptr_reg PARAMS ((int, int));
static void BadOp PARAMS ((void));
a189 1
#define x_mode 5
d197 8
d206 1
a206 8
#define eAX_reg 108
#define eCX_reg 109
#define eDX_reg 110
#define eBX_reg 111
#define eSP_reg 112
#define eBP_reg 113
#define eSI_reg 114
#define eDI_reg 115
d228 20
a247 42
#define USE_GROUPS 1
#define USE_PREFIX_USER_TABLE 2

#define GRP1b NULL, NULL, 0, NULL, USE_GROUPS, NULL, 0
#define GRP1S NULL, NULL, 1, NULL, USE_GROUPS, NULL, 0
#define GRP1Ss NULL, NULL, 2, NULL, USE_GROUPS, NULL, 0
#define GRP2b NULL, NULL, 3, NULL, USE_GROUPS, NULL, 0
#define GRP2S NULL, NULL, 4, NULL, USE_GROUPS, NULL, 0
#define GRP2b_one NULL, NULL, 5, NULL, USE_GROUPS, NULL, 0
#define GRP2S_one NULL, NULL, 6, NULL, USE_GROUPS, NULL, 0
#define GRP2b_cl NULL, NULL, 7, NULL, USE_GROUPS, NULL, 0
#define GRP2S_cl NULL, NULL, 8, NULL, USE_GROUPS, NULL, 0
#define GRP3b NULL, NULL, 9, NULL, USE_GROUPS, NULL, 0
#define GRP3S NULL, NULL, 10, NULL, USE_GROUPS, NULL, 0
#define GRP4  NULL, NULL, 11, NULL, USE_GROUPS, NULL, 0
#define GRP5  NULL, NULL, 12, NULL, USE_GROUPS, NULL, 0
#define GRP6  NULL, NULL, 13, NULL, USE_GROUPS, NULL, 0
#define GRP7 NULL, NULL, 14, NULL, USE_GROUPS, NULL, 0
#define GRP8 NULL, NULL, 15, NULL, USE_GROUPS, NULL, 0
#define GRP9 NULL, NULL, 16, NULL, USE_GROUPS, NULL, 0
#define GRP10 NULL, NULL, 17, NULL, USE_GROUPS, NULL, 0
#define GRP11 NULL, NULL, 18, NULL, USE_GROUPS, NULL, 0
#define GRP12 NULL, NULL, 19, NULL, USE_GROUPS, NULL, 0
#define GRP13 NULL, NULL, 20, NULL, USE_GROUPS, NULL, 0
#define GRP14 NULL, NULL, 21, NULL, USE_GROUPS, NULL, 0
#define GRPAMD NULL, NULL, 22, NULL, USE_GROUPS, NULL, 0

#define PREGRP0 NULL, NULL, 0, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP1 NULL, NULL, 1, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP2 NULL, NULL, 2, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP3 NULL, NULL, 3, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP4 NULL, NULL, 4, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP5 NULL, NULL, 5, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP6 NULL, NULL, 6, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP7 NULL, NULL, 7, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP8 NULL, NULL, 8, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP9 NULL, NULL, 9, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP10 NULL, NULL, 10, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP11 NULL, NULL, 11, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP12 NULL, NULL, 12, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP13 NULL, NULL, 13, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP14 NULL, NULL, 14, NULL, USE_PREFIX_USER_TABLE, NULL, 0
d250 1
a250 1
#define FLOAT NULL, NULL, FLOATCODE, NULL, 0, NULL, 0
d253 1
a253 1
  const char *name;
d262 1
a262 15
/* Upper case letters in the instruction names here are macros.
   'A' => print 'b' if no register operands or suffix_always is true
   'B' => print 'b' if suffix_always is true
   'E' => print 'e' if 32-bit form of jcxz
   'L' => print 'l' if suffix_always is true
   'N' => print 'n' if instruction has no wait "prefix"
   'P' => print 'w' or 'l' if instruction has an operand size prefix,
                              or suffix_always is true
   'Q' => print 'w' or 'l' if no register operands or suffix_always is true
   'R' => print 'w' or 'l' ("wd" or "dq" in intel mode)
   'S' => print 'w' or 'l' if suffix_always is true
   'W' => print 'b' or 'w' ("w" or "de" in intel mode)
*/

static const struct dis386 dis386_att[] = {
d264 8
a271 8
  { "addB",	Eb, Gb, XX },
  { "addS",	Ev, Gv, XX },
  { "addB",	Gb, Eb, XX },
  { "addS",	Gv, Ev, XX },
  { "addB",	AL, Ib, XX },
  { "addS",	eAX, Iv, XX },
  { "pushP",	es, XX, XX },
  { "popP",	es, XX, XX },
d273 8
a280 8
  { "orB",	Eb, Gb, XX },
  { "orS",	Ev, Gv, XX },
  { "orB",	Gb, Eb, XX },
  { "orS",	Gv, Ev, XX },
  { "orB",	AL, Ib, XX },
  { "orS",	eAX, Iv, XX },
  { "pushP",	cs, XX, XX },
  { "(bad)",	XX, XX, XX },	/* 0x0f extended opcode escape */
d282 8
a289 8
  { "adcB",	Eb, Gb, XX },
  { "adcS",	Ev, Gv, XX },
  { "adcB",	Gb, Eb, XX },
  { "adcS",	Gv, Ev, XX },
  { "adcB",	AL, Ib, XX },
  { "adcS",	eAX, Iv, XX },
  { "pushP",	ss, XX, XX },
  { "popP",	ss, XX, XX },
d291 8
a298 8
  { "sbbB",	Eb, Gb, XX },
  { "sbbS",	Ev, Gv, XX },
  { "sbbB",	Gb, Eb, XX },
  { "sbbS",	Gv, Ev, XX },
  { "sbbB",	AL, Ib, XX },
  { "sbbS",	eAX, Iv, XX },
  { "pushP",	ds, XX, XX },
  { "popP",	ds, XX, XX },
d300 8
a307 8
  { "andB",	Eb, Gb, XX },
  { "andS",	Ev, Gv, XX },
  { "andB",	Gb, Eb, XX },
  { "andS",	Gv, Ev, XX },
  { "andB",	AL, Ib, XX },
  { "andS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG ES prefix */
  { "daa",	XX, XX, XX },
d309 8
a316 8
  { "subB",	Eb, Gb, XX },
  { "subS",	Ev, Gv, XX },
  { "subB",	Gb, Eb, XX },
  { "subS",	Gv, Ev, XX },
  { "subB",	AL, Ib, XX },
  { "subS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG CS prefix */
  { "das",	XX, XX, XX },
d318 8
a325 8
  { "xorB",	Eb, Gb, XX },
  { "xorS",	Ev, Gv, XX },
  { "xorB",	Gb, Eb, XX },
  { "xorS",	Gv, Ev, XX },
  { "xorB",	AL, Ib, XX },
  { "xorS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG SS prefix */
  { "aaa",	XX, XX, XX },
d327 8
a334 8
  { "cmpB",	Eb, Gb, XX },
  { "cmpS",	Ev, Gv, XX },
  { "cmpB",	Gb, Eb, XX },
  { "cmpS",	Gv, Ev, XX },
  { "cmpB",	AL, Ib, XX },
  { "cmpS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG DS prefix */
  { "aas",	XX, XX, XX },
d336 8
a343 8
  { "incS",	eAX, XX, XX },
  { "incS",	eCX, XX, XX },
  { "incS",	eDX, XX, XX },
  { "incS",	eBX, XX, XX },
  { "incS",	eSP, XX, XX },
  { "incS",	eBP, XX, XX },
  { "incS",	eSI, XX, XX },
  { "incS",	eDI, XX, XX },
d345 8
a352 8
  { "decS",	eAX, XX, XX },
  { "decS",	eCX, XX, XX },
  { "decS",	eDX, XX, XX },
  { "decS",	eBX, XX, XX },
  { "decS",	eSP, XX, XX },
  { "decS",	eBP, XX, XX },
  { "decS",	eSI, XX, XX },
  { "decS",	eDI, XX, XX },
d354 8
a361 8
  { "pushS",	eAX, XX, XX },
  { "pushS",	eCX, XX, XX },
  { "pushS",	eDX, XX, XX },
  { "pushS",	eBX, XX, XX },
  { "pushS",	eSP, XX, XX },
  { "pushS",	eBP, XX, XX },
  { "pushS",	eSI, XX, XX },
  { "pushS",	eDI, XX, XX },
d363 8
a370 8
  { "popS",	eAX, XX, XX },
  { "popS",	eCX, XX, XX },
  { "popS",	eDX, XX, XX },
  { "popS",	eBX, XX, XX },
  { "popS",	eSP, XX, XX },
  { "popS",	eBP, XX, XX },
  { "popS",	eSI, XX, XX },
  { "popS",	eDI, XX, XX },
d372 8
a379 8
  { "pushaP",	XX, XX, XX },
  { "popaP",	XX, XX, XX },
  { "boundS",	Gv, Ma, XX },
  { "arpl",	Ew, Gw, XX },
  { "(bad)",	XX, XX, XX },			/* seg fs */
  { "(bad)",	XX, XX, XX },			/* seg gs */
  { "(bad)",	XX, XX, XX },			/* op size prefix */
  { "(bad)",	XX, XX, XX },			/* adr size prefix */
d381 1
a381 1
  { "pushP",	Iv, XX, XX },		/* 386 book wrong */
d383 6
a388 297
  { "pushP",	sIb, XX, XX },	/* push of byte really pushes 2 or 4 bytes */
  { "imulS",	Gv, Ev, sIb },
  { "insb",	Yb, indirDX, XX },
  { "insR",	Yv, indirDX, XX },
  { "outsb",	indirDX, Xb, XX },
  { "outsR",	indirDX, Xv, XX },
  /* 70 */
  { "jo",	Jb, XX, XX },
  { "jno",	Jb, XX, XX },
  { "jb",	Jb, XX, XX },
  { "jae",	Jb, XX, XX },
  { "je",	Jb, XX, XX },
  { "jne",	Jb, XX, XX },
  { "jbe",	Jb, XX, XX },
  { "ja",	Jb, XX, XX },
  /* 78 */
  { "js",	Jb, XX, XX },
  { "jns",	Jb, XX, XX },
  { "jp",	Jb, XX, XX },
  { "jnp",	Jb, XX, XX },
  { "jl",	Jb, XX, XX },
  { "jge",	Jb, XX, XX },
  { "jle",	Jb, XX, XX },
  { "jg",	Jb, XX, XX },
  /* 80 */
  { GRP1b },
  { GRP1S },
  { "(bad)",	XX, XX, XX },
  { GRP1Ss },
  { "testB",	Eb, Gb, XX },
  { "testS",	Ev, Gv, XX },
  { "xchgB",	Eb, Gb, XX },
  { "xchgS",	Ev, Gv, XX },
  /* 88 */
  { "movB",	Eb, Gb, XX },
  { "movS",	Ev, Gv, XX },
  { "movB",	Gb, Eb, XX },
  { "movS",	Gv, Ev, XX },
  { "movQ",	Ev, Sw, XX },
  { "leaS",	Gv, M, XX },
  { "movQ",	Sw, Ev, XX },
  { "popQ",	Ev, XX, XX },
  /* 90 */
  { "nop",	XX, XX, XX },
  { "xchgS",	eCX, eAX, XX },
  { "xchgS",	eDX, eAX, XX },
  { "xchgS",	eBX, eAX, XX },
  { "xchgS",	eSP, eAX, XX },
  { "xchgS",	eBP, eAX, XX },
  { "xchgS",	eSI, eAX, XX },
  { "xchgS",	eDI, eAX, XX },
  /* 98 */
  { "cWtR",	XX, XX, XX },
  { "cRtd",	XX, XX, XX },
  { "lcallP",	Ap, XX, XX },
  { "(bad)",	XX, XX, XX },		/* fwait */
  { "pushfP",	XX, XX, XX },
  { "popfP",	XX, XX, XX },
  { "sahf",	XX, XX, XX },
  { "lahf",	XX, XX, XX },
  /* a0 */
  { "movB",	AL, Ob, XX },
  { "movS",	eAX, Ov, XX },
  { "movB",	Ob, AL, XX },
  { "movS",	Ov, eAX, XX },
  { "movsb",	Yb, Xb, XX },
  { "movsR",	Yv, Xv, XX },
  { "cmpsb",	Xb, Yb, XX },
  { "cmpsR",	Xv, Yv, XX },
  /* a8 */
  { "testB",	AL, Ib, XX },
  { "testS",	eAX, Iv, XX },
  { "stosB",	Yb, AL, XX },
  { "stosS",	Yv, eAX, XX },
  { "lodsB",	AL, Xb, XX },
  { "lodsS",	eAX, Xv, XX },
  { "scasB",	AL, Yb, XX },
  { "scasS",	eAX, Yv, XX },
  /* b0 */
  { "movB",	AL, Ib, XX },
  { "movB",	CL, Ib, XX },
  { "movB",	DL, Ib, XX },
  { "movB",	BL, Ib, XX },
  { "movB",	AH, Ib, XX },
  { "movB",	CH, Ib, XX },
  { "movB",	DH, Ib, XX },
  { "movB",	BH, Ib, XX },
  /* b8 */
  { "movS",	eAX, Iv, XX },
  { "movS",	eCX, Iv, XX },
  { "movS",	eDX, Iv, XX },
  { "movS",	eBX, Iv, XX },
  { "movS",	eSP, Iv, XX },
  { "movS",	eBP, Iv, XX },
  { "movS",	eSI, Iv, XX },
  { "movS",	eDI, Iv, XX },
  /* c0 */
  { GRP2b },
  { GRP2S },
  { "retP",	Iw, XX, XX },
  { "retP",	XX, XX, XX },
  { "lesS",	Gv, Mp, XX },
  { "ldsS",	Gv, Mp, XX },
  { "movA",	Eb, Ib, XX },
  { "movQ",	Ev, Iv, XX },
  /* c8 */
  { "enterP",	Iw, Ib, XX },
  { "leaveP",	XX, XX, XX },
  { "lretP",	Iw, XX, XX },
  { "lretP",	XX, XX, XX },
  { "int3",	XX, XX, XX },
  { "int",	Ib, XX, XX },
  { "into",	XX, XX, XX},
  { "iretP",	XX, XX, XX },
  /* d0 */
  { GRP2b_one },
  { GRP2S_one },
  { GRP2b_cl },
  { GRP2S_cl },
  { "aam",	sIb, XX, XX },
  { "aad",	sIb, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "xlat",	DSBX, XX, XX },
  /* d8 */
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  /* e0 */
  { "loopne",	Jb, XX, XX },
  { "loope",	Jb, XX, XX },
  { "loop",	Jb, XX, XX },
  { "jEcxz",	Jb, XX, XX },
  { "inB",	AL, Ib, XX },
  { "inS",	eAX, Ib, XX },
  { "outB",	Ib, AL, XX },
  { "outS",	Ib, eAX, XX },
  /* e8 */
  { "callP",	Jv, XX, XX },
  { "jmpP",	Jv, XX, XX },
  { "ljmpP",	Ap, XX, XX },
  { "jmp",	Jb, XX, XX },
  { "inB",	AL, indirDX, XX },
  { "inS",	eAX, indirDX, XX },
  { "outB",	indirDX, AL, XX },
  { "outS",	indirDX, eAX, XX },
  /* f0 */
  { "(bad)",	XX, XX, XX },			/* lock prefix */
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },			/* repne */
  { "(bad)",	XX, XX, XX },			/* repz */
  { "hlt",	XX, XX, XX },
  { "cmc",	XX, XX, XX },
  { GRP3b },
  { GRP3S },
  /* f8 */
  { "clc",	XX, XX, XX },
  { "stc",	XX, XX, XX },
  { "cli",	XX, XX, XX },
  { "sti",	XX, XX, XX },
  { "cld",	XX, XX, XX },
  { "std",	XX, XX, XX },
  { GRP4 },
  { GRP5 },
};

static const struct dis386 dis386_intel[] = {
  /* 00 */
  { "add",	Eb, Gb, XX },
  { "add",	Ev, Gv, XX },
  { "add",	Gb, Eb, XX },
  { "add",	Gv, Ev, XX },
  { "add",	AL, Ib, XX },
  { "add",	eAX, Iv, XX },
  { "push",	es, XX, XX },
  { "pop",	es, XX, XX },
  /* 08 */
  { "or",	Eb, Gb, XX },
  { "or",	Ev, Gv, XX },
  { "or",	Gb, Eb, XX },
  { "or",	Gv, Ev, XX },
  { "or",	AL, Ib, XX },
  { "or",	eAX, Iv, XX },
  { "push",	cs, XX, XX },
  { "(bad)",	XX, XX, XX },	/* 0x0f extended opcode escape */
  /* 10 */
  { "adc",	Eb, Gb, XX },
  { "adc",	Ev, Gv, XX },
  { "adc",	Gb, Eb, XX },
  { "adc",	Gv, Ev, XX },
  { "adc",	AL, Ib, XX },
  { "adc",	eAX, Iv, XX },
  { "push",	ss, XX, XX },
  { "pop",	ss, XX, XX },
  /* 18 */
  { "sbb",	Eb, Gb, XX },
  { "sbb",	Ev, Gv, XX },
  { "sbb",	Gb, Eb, XX },
  { "sbb",	Gv, Ev, XX },
  { "sbb",	AL, Ib, XX },
  { "sbb",	eAX, Iv, XX },
  { "push",	ds, XX, XX },
  { "pop",	ds, XX, XX },
  /* 20 */
  { "and",	Eb, Gb, XX },
  { "and",	Ev, Gv, XX },
  { "and",	Gb, Eb, XX },
  { "and",	Gv, Ev, XX },
  { "and",	AL, Ib, XX },
  { "and",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG ES prefix */
  { "daa",	XX, XX, XX },
  /* 28 */
  { "sub",	Eb, Gb, XX },
  { "sub",	Ev, Gv, XX },
  { "sub",	Gb, Eb, XX },
  { "sub",	Gv, Ev, XX },
  { "sub",	AL, Ib, XX },
  { "sub",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG CS prefix */
  { "das",	XX, XX, XX },
  /* 30 */
  { "xor",	Eb, Gb, XX },
  { "xor",	Ev, Gv, XX },
  { "xor",	Gb, Eb, XX },
  { "xor",	Gv, Ev, XX },
  { "xor",	AL, Ib, XX },
  { "xor",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG SS prefix */
  { "aaa",	XX, XX, XX },
  /* 38 */
  { "cmp",	Eb, Gb, XX },
  { "cmp",	Ev, Gv, XX },
  { "cmp",	Gb, Eb, XX },
  { "cmp",	Gv, Ev, XX },
  { "cmp",	AL, Ib, XX },
  { "cmp",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG DS prefix */
  { "aas",	XX, XX, XX },
  /* 40 */
  { "inc",	eAX, XX, XX },
  { "inc",	eCX, XX, XX },
  { "inc",	eDX, XX, XX },
  { "inc",	eBX, XX, XX },
  { "inc",	eSP, XX, XX },
  { "inc",	eBP, XX, XX },
  { "inc",	eSI, XX, XX },
  { "inc",	eDI, XX, XX },
  /* 48 */
  { "dec",	eAX, XX, XX },
  { "dec",	eCX, XX, XX },
  { "dec",	eDX, XX, XX },
  { "dec",	eBX, XX, XX },
  { "dec",	eSP, XX, XX },
  { "dec",	eBP, XX, XX },
  { "dec",	eSI, XX, XX },
  { "dec",	eDI, XX, XX },
  /* 50 */
  { "push",	eAX, XX, XX },
  { "push",	eCX, XX, XX },
  { "push",	eDX, XX, XX },
  { "push",	eBX, XX, XX },
  { "push",	eSP, XX, XX },
  { "push",	eBP, XX, XX },
  { "push",	eSI, XX, XX },
  { "push",	eDI, XX, XX },
  /* 58 */
  { "pop",	eAX, XX, XX },
  { "pop",	eCX, XX, XX },
  { "pop",	eDX, XX, XX },
  { "pop",	eBX, XX, XX },
  { "pop",	eSP, XX, XX },
  { "pop",	eBP, XX, XX },
  { "pop",	eSI, XX, XX },
  { "pop",	eDI, XX, XX },
  /* 60 */
  { "pusha",	XX, XX, XX },
  { "popa",	XX, XX, XX },
  { "bound",	Gv, Ma, XX },
  { "arpl",	Ew, Gw, XX },
  { "(bad)",	XX, XX, XX },			/* seg fs */
  { "(bad)",	XX, XX, XX },			/* seg gs */
  { "(bad)",	XX, XX, XX },			/* op size prefix */
  { "(bad)",	XX, XX, XX },			/* adr size prefix */
  /* 68 */
  { "push",	Iv, XX, XX },		/* 386 book wrong */
  { "imul",	Gv, Ev, Iv },
  { "push",	sIb, XX, XX },	/* push of byte really pushes 2 or 4 bytes */
  { "imul",	Gv, Ev, sIb },
  { "ins",	Yb, indirDX, XX },
  { "ins",	Yv, indirDX, XX },
  { "outs",	indirDX, Xb, XX },
  { "outs",	indirDX, Xv, XX },
d390 8
a397 8
  { "jo",	Jb, XX, XX },
  { "jno",	Jb, XX, XX },
  { "jb",	Jb, XX, XX },
  { "jae",	Jb, XX, XX },
  { "je",	Jb, XX, XX },
  { "jne",	Jb, XX, XX },
  { "jbe",	Jb, XX, XX },
  { "ja",	Jb, XX, XX },
d399 8
a406 8
  { "js",	Jb, XX, XX },
  { "jns",	Jb, XX, XX },
  { "jp",	Jb, XX, XX },
  { "jnp",	Jb, XX, XX },
  { "jl",	Jb, XX, XX },
  { "jge",	Jb, XX, XX },
  { "jle",	Jb, XX, XX },
  { "jg",	Jb, XX, XX },
d410 1
a410 1
  { "(bad)",	XX, XX, XX },
d412 4
a415 4
  { "test",	Eb, Gb, XX },
  { "test",	Ev, Gv, XX },
  { "xchg",	Eb, Gb, XX },
  { "xchg",	Ev, Gv, XX },
d417 8
a424 8
  { "mov",	Eb, Gb, XX },
  { "mov",	Ev, Gv, XX },
  { "mov",	Gb, Eb, XX },
  { "mov",	Gv, Ev, XX },
  { "mov",	Ev, Sw, XX },
  { "lea",	Gv, M, XX },
  { "mov",	Sw, Ev, XX },
  { "pop",	Ev, XX, XX },
d426 8
a433 8
  { "nop",	XX, XX, XX },
  { "xchg",	eCX, eAX, XX },
  { "xchg",	eDX, eAX, XX },
  { "xchg",	eBX, eAX, XX },
  { "xchg",	eSP, eAX, XX },
  { "xchg",	eBP, eAX, XX },
  { "xchg",	eSI, eAX, XX },
  { "xchg",	eDI, eAX, XX },
d435 8
a442 8
  { "cW",	XX, XX, XX },		/* cwde and cbw */
  { "cR",	XX, XX, XX },		/* cdq and cwd */
  { "lcall",	Ap, XX, XX },
  { "(bad)",	XX, XX, XX },		/* fwait */
  { "pushf",	XX, XX, XX },
  { "popf",	XX, XX, XX },
  { "sahf",	XX, XX, XX },
  { "lahf",	XX, XX, XX },
d444 8
a451 8
  { "mov",	AL, Ob, XX },
  { "mov",	eAX, Ov, XX },
  { "mov",	Ob, AL, XX },
  { "mov",	Ov, eAX, XX },
  { "movs",	Yb, Xb, XX },
  { "movs",	Yv, Xv, XX },
  { "cmps",	Xb, Yb, XX },
  { "cmps",	Xv, Yv, XX },
d453 8
a460 8
  { "test",	AL, Ib, XX },
  { "test",	eAX, Iv, XX },
  { "stos",	Yb, AL, XX },
  { "stos",	Yv, eAX, XX },
  { "lods",	AL, Xb, XX },
  { "lods",	eAX, Xv, XX },
  { "scas",	AL, Yb, XX },
  { "scas",	eAX, Yv, XX },
d462 8
a469 8
  { "mov",	AL, Ib, XX },
  { "mov",	CL, Ib, XX },
  { "mov",	DL, Ib, XX },
  { "mov",	BL, Ib, XX },
  { "mov",	AH, Ib, XX },
  { "mov",	CH, Ib, XX },
  { "mov",	DH, Ib, XX },
  { "mov",	BH, Ib, XX },
d471 8
a478 8
  { "mov",	eAX, Iv, XX },
  { "mov",	eCX, Iv, XX },
  { "mov",	eDX, Iv, XX },
  { "mov",	eBX, Iv, XX },
  { "mov",	eSP, Iv, XX },
  { "mov",	eBP, Iv, XX },
  { "mov",	eSI, Iv, XX },
  { "mov",	eDI, Iv, XX },
d482 6
a487 6
  { "ret",	Iw, XX, XX },
  { "ret",	XX, XX, XX },
  { "les",	Gv, Mp, XX },
  { "lds",	Gv, Mp, XX },
  { "mov",	Eb, Ib, XX },
  { "mov",	Ev, Iv, XX },
d489 8
a496 8
  { "enter",	Iw, Ib, XX },
  { "leave",	XX, XX, XX },
  { "lret",	Iw, XX, XX },
  { "lret",	XX, XX, XX },
  { "int3",	XX, XX, XX },
  { "int",	Ib, XX, XX },
  { "into",	XX, XX, XX },
  { "iret",	XX, XX, XX },
d502 4
a505 4
  { "aam",	sIb, XX, XX },
  { "aad",	sIb, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "xlat",	DSBX, XX, XX },
d516 8
a523 8
  { "loopne",	Jb, XX, XX },
  { "loope",	Jb, XX, XX },
  { "loop",	Jb, XX, XX },
  { "jEcxz",	Jb, XX, XX },
  { "in",	AL, Ib, XX },
  { "in",	eAX, Ib, XX },
  { "out",	Ib, AL, XX },
  { "out",	Ib, eAX, XX },
d525 8
a532 8
  { "call",	Jv, XX, XX },
  { "jmp",	Jv, XX, XX },
  { "ljmp",	Ap, XX, XX },
  { "jmp",	Jb, XX, XX },
  { "in",	AL, indirDX, XX },
  { "in",	eAX, indirDX, XX },
  { "out",	indirDX, AL, XX },
  { "out",	indirDX, eAX, XX },
d534 6
a539 6
  { "(bad)",	XX, XX, XX },			/* lock prefix */
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },			/* repne */
  { "(bad)",	XX, XX, XX },			/* repz */
  { "hlt",	XX, XX, XX },
  { "cmc",	XX, XX, XX },
d543 6
a548 6
  { "clc",	XX, XX, XX },
  { "stc",	XX, XX, XX },
  { "cli",	XX, XX, XX },
  { "sti",	XX, XX, XX },
  { "cld",	XX, XX, XX },
  { "std",	XX, XX, XX },
d553 1
a553 1
static const struct dis386 dis386_twobyte_att[] = {
d557 6
a562 6
  { "larS", Gv, Ew, XX },
  { "lslS", Gv, Ew, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "clts", XX, XX, XX },
  { "(bad)", XX, XX, XX },
d564 4
a567 8
  { "invd", XX, XX, XX },
  { "wbinvd", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "ud2a", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { GRPAMD },
  { "femms", XX, XX, XX },
  { "", MX, EM, OPSUF }, /* See OP_3DNowSuffix */
d569 2
a570 8
  { PREGRP8 },
  { PREGRP9 },
  { "movlps", XM, EX, SIMD_Fixup, 'h' },  /* really only 2 operands */
  { "movlps", EX, XM, SIMD_Fixup, 'h' },
  { "unpcklps", XM, EX, XX },
  { "unpckhps", XM, EX, XX },
  { "movhps", XM, EX, SIMD_Fixup, 'l' },
  { "movhps", EX, XM, SIMD_Fixup, 'l' },
d572 2
a573 8
  { GRP14 },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
d576 8
a583 8
  { "movL", Rd, Cd, XX },
  { "movL", Rd, Dd, XX },
  { "movL", Cd, Rd, XX },
  { "movL", Dd, Rd, XX },
  { "movL", Rd, Td, XX },
  { "(bad)", XX, XX, XX },
  { "movL", Td, Rd, XX },
  { "(bad)", XX, XX, XX },
d585 2
a586 8
  { "movaps", XM, EX, XX },
  { "movaps", EX, XM, XX },
  { PREGRP2 },
  { "movntps", Ev, XM, XX },
  { PREGRP4 },
  { PREGRP3 },
  { "ucomiss", XM, EX, XX },
  { "comiss", XM, EX, XX },
d588 2
a589 8
  { "wrmsr", XX, XX, XX },
  { "rdtsc", XX, XX, XX },
  { "rdmsr", XX, XX, XX },
  { "rdpmc", XX, XX, XX },
  { "sysenter", XX, XX, XX },
  { "sysexit", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
d591 2
a592 8
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
d594 2
a595 8
  { "cmovo", Gv, Ev, XX },
  { "cmovno", Gv, Ev, XX },
  { "cmovb", Gv, Ev, XX },
  { "cmovae", Gv, Ev, XX },
  { "cmove", Gv, Ev, XX },
  { "cmovne", Gv, Ev, XX },
  { "cmovbe", Gv, Ev, XX },
  { "cmova", Gv, Ev, XX },
d597 2
a598 8
  { "cmovs", Gv, Ev, XX },
  { "cmovns", Gv, Ev, XX },
  { "cmovp", Gv, Ev, XX },
  { "cmovnp", Gv, Ev, XX },
  { "cmovl", Gv, Ev, XX },
  { "cmovge", Gv, Ev, XX },
  { "cmovle", Gv, Ev, XX },
  { "cmovg", Gv, Ev, XX },
d600 2
a601 8
  { "movmskps", Gv, EX, XX },
  { PREGRP13 },
  { PREGRP12 },
  { PREGRP11 },
  { "andps", XM, EX, XX },
  { "andnps", XM, EX, XX },
  { "orps", XM, EX, XX },
  { "xorps", XM, EX, XX },
d603 2
a604 8
  { PREGRP0 },
  { PREGRP10 },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { PREGRP14 },
  { PREGRP7 },
  { PREGRP5 },
  { PREGRP6 },
d606 8
a613 8
  { "punpcklbw", MX, EM, XX },
  { "punpcklwd", MX, EM, XX },
  { "punpckldq", MX, EM, XX },
  { "packsswb", MX, EM, XX },
  { "pcmpgtb", MX, EM, XX },
  { "pcmpgtw", MX, EM, XX },
  { "pcmpgtd", MX, EM, XX },
  { "packuswb", MX, EM, XX },
d615 7
a621 8
  { "punpckhbw", MX, EM, XX },
  { "punpckhwd", MX, EM, XX },
  { "punpckhdq", MX, EM, XX },
  { "packssdw", MX, EM, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "movd", MX, Ed, XX },
  { "movq", MX, EM, XX },
d623 1
a623 1
  { "pshufw", MX, EM, Ib },
d627 4
a630 4
  { "pcmpeqb", MX, EM, XX },
  { "pcmpeqw", MX, EM, XX },
  { "pcmpeqd", MX, EM, XX },
  { "emms", XX, XX, XX },
d632 4
a635 8
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "movd", Ed, MX, XX },
  { "movq", EM, MX, XX },
d637 8
a644 8
  { "jo", Jv, XX, XX },
  { "jno", Jv, XX, XX },
  { "jb", Jv, XX, XX },
  { "jae", Jv, XX, XX },
  { "je", Jv, XX, XX },
  { "jne", Jv, XX, XX },
  { "jbe", Jv, XX, XX },
  { "ja", Jv, XX, XX },
d646 8
a653 8
  { "js", Jv, XX, XX },
  { "jns", Jv, XX, XX },
  { "jp", Jv, XX, XX },
  { "jnp", Jv, XX, XX },
  { "jl", Jv, XX, XX },
  { "jge", Jv, XX, XX },
  { "jle", Jv, XX, XX },
  { "jg", Jv, XX, XX },
d655 8
a662 8
  { "seto", Eb, XX, XX },
  { "setno", Eb, XX, XX },
  { "setb", Eb, XX, XX },
  { "setae", Eb, XX, XX },
  { "sete", Eb, XX, XX },
  { "setne", Eb, XX, XX },
  { "setbe", Eb, XX, XX },
  { "seta", Eb, XX, XX },
d664 8
a671 8
  { "sets", Eb, XX, XX },
  { "setns", Eb, XX, XX },
  { "setp", Eb, XX, XX },
  { "setnp", Eb, XX, XX },
  { "setl", Eb, XX, XX },
  { "setge", Eb, XX, XX },
  { "setle", Eb, XX, XX },
  { "setg", Eb, XX, XX },
d673 4
a676 4
  { "pushP", fs, XX, XX },
  { "popP", fs, XX, XX },
  { "cpuid", XX, XX, XX },
  { "btS", Ev, Gv, XX },
d679 2
a680 2
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
d682 4
a685 4
  { "pushP", gs, XX, XX },
  { "popP", gs, XX, XX },
  { "rsm", XX, XX, XX },
  { "btsS", Ev, Gv, XX },
d688 2
a689 294
  { GRP13 },
  { "imulS", Gv, Ev, XX },
  /* b0 */
  { "cmpxchgB", Eb, Gb, XX },
  { "cmpxchgS", Ev, Gv, XX },
  { "lssS", Gv, Mp, XX },
  { "btrS", Ev, Gv, XX },
  { "lfsS", Gv, Mp, XX },
  { "lgsS", Gv, Mp, XX },
  { "movzbR", Gv, Eb, XX },
  { "movzwR", Gv, Ew, XX }, /* yes, there really is movzww ! */
  /* b8 */
  { "(bad)", XX, XX, XX },
  { "ud2b", XX, XX, XX },
  { GRP8 },
  { "btcS", Ev, Gv, XX },
  { "bsfS", Gv, Ev, XX },
  { "bsrS", Gv, Ev, XX },
  { "movsbR", Gv, Eb, XX },
  { "movswR", Gv, Ew, XX }, /* yes, there really is movsww ! */
  /* c0 */
  { "xaddB", Eb, Gb, XX },
  { "xaddS", Ev, Gv, XX },
  { PREGRP1 },
  { "(bad)", XX, XX, XX },
  { "pinsrw", MX, Ev, Ib },
  { "pextrw", Ev, MX, Ib },
  { "shufps", XM, EX, Ib },
  { GRP9 },
  /* c8 */
  { "bswap", eAX, XX, XX },	/* bswap doesn't support 16 bit regs */
  { "bswap", eCX, XX, XX },
  { "bswap", eDX, XX, XX },
  { "bswap", eBX, XX, XX },
  { "bswap", eSP, XX, XX },
  { "bswap", eBP, XX, XX },
  { "bswap", eSI, XX, XX },
  { "bswap", eDI, XX, XX },
  /* d0 */
  { "(bad)", XX, XX, XX },
  { "psrlw", MX, EM, XX },
  { "psrld", MX, EM, XX },
  { "psrlq", MX, EM, XX },
  { "(bad)", XX, XX, XX },
  { "pmullw", MX, EM, XX },
  { "(bad)", XX, XX, XX },
  { "pmovmskb", Ev, MX, XX },
  /* d8 */
  { "psubusb", MX, EM, XX },
  { "psubusw", MX, EM, XX },
  { "pminub", MX, EM, XX },
  { "pand", MX, EM, XX },
  { "paddusb", MX, EM, XX },
  { "paddusw", MX, EM, XX },
  { "pmaxub", MX, EM, XX },
  { "pandn", MX, EM, XX },
  /* e0 */
  { "pavgb", MX, EM, XX },
  { "psraw", MX, EM, XX },
  { "psrad", MX, EM, XX },
  { "pavgw", MX, EM, XX },
  { "pmulhuw", MX, EM, XX },
  { "pmulhw", MX, EM, XX },
  { "(bad)", XX, XX, XX },
  { "movntq", Ev, MX, XX },
  /* e8 */
  { "psubsb", MX, EM, XX },
  { "psubsw", MX, EM, XX },
  { "pminsw", MX, EM, XX },
  { "por", MX, EM, XX },
  { "paddsb", MX, EM, XX },
  { "paddsw", MX, EM, XX },
  { "pmaxsw", MX, EM, XX },
  { "pxor", MX, EM, XX },
  /* f0 */
  { "(bad)", XX, XX, XX },
  { "psllw", MX, EM, XX },
  { "pslld", MX, EM, XX },
  { "psllq", MX, EM, XX },
  { "(bad)", XX, XX, XX },
  { "pmaddwd", MX, EM, XX },
  { "psadbw", MX, EM, XX },
  { "maskmovq", MX, EM, XX },
  /* f8 */
  { "psubb", MX, EM, XX },
  { "psubw", MX, EM, XX },
  { "psubd", MX, EM, XX },
  { "(bad)", XX, XX, XX },
  { "paddb", MX, EM, XX },
  { "paddw", MX, EM, XX },
  { "paddd", MX, EM, XX },
  { "(bad)", XX, XX, XX }
};

static const struct dis386 dis386_twobyte_intel[] = {
  /* 00 */
  { GRP6 },
  { GRP7 },
  { "lar", Gv, Ew, XX },
  { "lsl", Gv, Ew, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "clts", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  /* 08 */
  { "invd", XX, XX, XX },
  { "wbinvd", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "ud2a", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { GRPAMD },
  { "femms" , XX, XX, XX},
  { "", MX, EM, OPSUF }, /* See OP_3DNowSuffix */
  /* 10 */
  { PREGRP8 },
  { PREGRP9 },
  { "movlps", XM, EX, SIMD_Fixup, 'h' },  /* really only 2 operands */
  { "movlps", EX, XM, SIMD_Fixup, 'h' },
  { "unpcklps", XM, EX, XX },
  { "unpckhps", XM, EX, XX },
  { "movhps", XM, EX, SIMD_Fixup, 'l' },
  { "movhps", EX, XM, SIMD_Fixup, 'l' },
  /* 18 */
  { GRP14 },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  /* 20 */
  /* these are all backward in appendix A of the intel book */
  { "mov", Rd, Cd, XX },
  { "mov", Rd, Dd, XX },
  { "mov", Cd, Rd, XX },
  { "mov", Dd, Rd, XX },
  { "mov", Rd, Td, XX },
  { "(bad)", XX, XX, XX },
  { "mov", Td, Rd, XX },
  { "(bad)", XX, XX, XX },
  /* 28 */
  { "movaps", XM, EX, XX },
  { "movaps", EX, XM, XX },
  { PREGRP2 },
  { "movntps", Ev, XM, XX },
  { PREGRP4 },
  { PREGRP3 },
  { "ucomiss", XM, EX, XX },
  { "comiss", XM, EX, XX },
  /* 30 */
  { "wrmsr", XX, XX, XX },
  { "rdtsc", XX, XX, XX },
  { "rdmsr", XX, XX, XX },
  { "rdpmc", XX, XX, XX },
  { "sysenter", XX, XX, XX },
  { "sysexit", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  /* 38 */
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  /* 40 */
  { "cmovo", Gv, Ev, XX },
  { "cmovno", Gv, Ev, XX },
  { "cmovb", Gv, Ev, XX },
  { "cmovae", Gv, Ev, XX },
  { "cmove", Gv, Ev, XX },
  { "cmovne", Gv, Ev, XX },
  { "cmovbe", Gv, Ev, XX },
  { "cmova", Gv, Ev, XX },
  /* 48 */
  { "cmovs", Gv, Ev, XX },
  { "cmovns", Gv, Ev, XX },
  { "cmovp", Gv, Ev, XX },
  { "cmovnp", Gv, Ev, XX },
  { "cmovl", Gv, Ev, XX },
  { "cmovge", Gv, Ev, XX },
  { "cmovle", Gv, Ev, XX },
  { "cmovg", Gv, Ev, XX },
  /* 50 */
  { "movmskps", Gv, EX, XX },
  { PREGRP13 },
  { PREGRP12 },
  { PREGRP11 },
  { "andps", XM, EX, XX },
  { "andnps", XM, EX, XX },
  { "orps", XM, EX, XX },
  { "xorps", XM, EX, XX },
  /* 58 */
  { PREGRP0 },
  { PREGRP10 },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { PREGRP14 },
  { PREGRP7 },
  { PREGRP5 },
  { PREGRP6 },
  /* 60 */
  { "punpcklbw", MX, EM, XX },
  { "punpcklwd", MX, EM, XX },
  { "punpckldq", MX, EM, XX },
  { "packsswb", MX, EM, XX },
  { "pcmpgtb", MX, EM, XX },
  { "pcmpgtw", MX, EM, XX },
  { "pcmpgtd", MX, EM, XX },
  { "packuswb", MX, EM, XX },
  /* 68 */
  { "punpckhbw", MX, EM, XX },
  { "punpckhwd", MX, EM, XX },
  { "punpckhdq", MX, EM, XX },
  { "packssdw", MX, EM, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "movd", MX, Ed, XX },
  { "movq", MX, EM, XX },
  /* 70 */
  { "pshufw", MX, EM, Ib },
  { GRP10 },
  { GRP11 },
  { GRP12 },
  { "pcmpeqb", MX, EM, XX },
  { "pcmpeqw", MX, EM, XX },
  { "pcmpeqd", MX, EM, XX },
  { "emms", XX, XX, XX },
  /* 78 */
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  { "movd", Ed, MX, XX },
  { "movq", EM, MX, XX },
  /* 80 */
  { "jo", Jv, XX, XX },
  { "jno", Jv, XX, XX },
  { "jb", Jv, XX, XX },
  { "jae", Jv, XX, XX },
  { "je", Jv, XX, XX },
  { "jne", Jv, XX, XX },
  { "jbe", Jv, XX, XX },
  { "ja", Jv, XX, XX },
  /* 88 */
  { "js", Jv, XX, XX },
  { "jns", Jv, XX, XX },
  { "jp", Jv, XX, XX },
  { "jnp", Jv, XX, XX },
  { "jl", Jv, XX, XX },
  { "jge", Jv, XX, XX },
  { "jle", Jv, XX, XX },
  { "jg", Jv, XX, XX },
  /* 90 */
  { "seto", Eb, XX, XX },
  { "setno", Eb, XX, XX },
  { "setb", Eb, XX, XX },
  { "setae", Eb, XX, XX },
  { "sete", Eb, XX, XX },
  { "setne", Eb, XX, XX },
  { "setbe", Eb, XX, XX },
  { "seta", Eb, XX, XX },
  /* 98 */
  { "sets", Eb, XX, XX },
  { "setns", Eb, XX, XX },
  { "setp", Eb, XX, XX },
  { "setnp", Eb, XX, XX },
  { "setl", Eb, XX, XX },
  { "setge", Eb, XX, XX },
  { "setle", Eb, XX, XX },
  { "setg", Eb, XX, XX },
  /* a0 */
  { "push", fs, XX, XX },
  { "pop", fs, XX, XX },
  { "cpuid", XX, XX, XX },
  { "bt", Ev, Gv, XX },
  { "shld", Ev, Gv, Ib },
  { "shld", Ev, Gv, CL },
  { "(bad)", XX, XX, XX },
  { "(bad)", XX, XX, XX },
  /* a8 */
  { "push", gs, XX, XX },
  { "pop", gs, XX, XX },
  { "rsm" , XX, XX, XX},
  { "bts", Ev, Gv, XX },
  { "shrd", Ev, Gv, Ib },
  { "shrd", Ev, Gv, CL },
  { GRP13 },
  { "imul", Gv, Ev, XX },
d691 8
a698 8
  { "cmpxchg", Eb, Gb, XX },
  { "cmpxchg", Ev, Gv, XX },
  { "lss", Gv, Mp, XX },
  { "btr", Ev, Gv, XX },
  { "lfs", Gv, Mp, XX },
  { "lgs", Gv, Mp, XX },
  { "movzx", Gv, Eb, XX },
  { "movzx", Gv, Ew, XX },
d700 2
a701 2
  { "(bad)", XX, XX, XX },
  { "ud2b", XX, XX, XX },
d703 5
a707 5
  { "btc", Ev, Gv, XX },
  { "bsf", Gv, Ev, XX },
  { "bsr", Gv, Ev, XX },
  { "movsx", Gv, Eb, XX },
  { "movsx", Gv, Ew, XX },
d709 8
a716 8
  { "xadd", Eb, Gb, XX },
  { "xadd", Ev, Gv, XX },
  { PREGRP1 },
  { "(bad)", XX, XX, XX },
  { "pinsrw", MX, Ev, Ib },
  { "pextrw", Ev, MX, Ib },
  { "shufps", XM, EX, Ib },
  { GRP9 },
d718 8
a725 8
  { "bswap", eAX, XX, XX },	/* bswap doesn't support 16 bit regs */
  { "bswap", eCX, XX, XX },
  { "bswap", eDX, XX, XX },
  { "bswap", eBX, XX, XX },
  { "bswap", eSP, XX, XX },
  { "bswap", eBP, XX, XX },
  { "bswap", eSI, XX, XX },
  { "bswap", eDI, XX, XX },
d727 7
a733 8
  { "(bad)", XX, XX, XX },
  { "psrlw", MX, EM, XX },
  { "psrld", MX, EM, XX },
  { "psrlq", MX, EM, XX },
  { "(bad)", XX, XX, XX },
  { "pmullw", MX, EM, XX },
  { "(bad)", XX, XX, XX },
  { "pmovmskb", Ev, MX, XX },
d735 8
a742 8
  { "psubusb", MX, EM, XX },
  { "psubusw", MX, EM, XX },
  { "pminub", MX, EM, XX },
  { "pand", MX, EM, XX },
  { "paddusb", MX, EM, XX },
  { "paddusw", MX, EM, XX },
  { "pmaxub", MX, EM, XX },
  { "pandn", MX, EM, XX },
d744 7
a750 8
  { "pavgb", MX, EM, XX },
  { "psraw", MX, EM, XX },
  { "psrad", MX, EM, XX },
  { "pavgw", MX, EM, XX },
  { "pmulhuw", MX, EM, XX },
  { "pmulhw", MX, EM, XX },
  { "(bad)", XX, XX, XX },
  { "movntq", Ev, MX, XX },
d752 8
a759 8
  { "psubsb", MX, EM, XX },
  { "psubsw", MX, EM, XX },
  { "pminsw", MX, EM, XX },
  { "por", MX, EM, XX },
  { "paddsb", MX, EM, XX },
  { "paddsw", MX, EM, XX },
  { "pmaxsw", MX, EM, XX },
  { "pxor", MX, EM, XX },
d761 7
a767 8
  { "(bad)", XX, XX, XX },
  { "psllw", MX, EM, XX },
  { "pslld", MX, EM, XX },
  { "psllq", MX, EM, XX },
  { "(bad)", XX, XX, XX },
  { "pmaddwd", MX, EM, XX },
  { "psadbw", MX, EM, XX },
  { "maskmovq", MX, EM, XX },
d769 8
a776 8
  { "psubb", MX, EM, XX },
  { "psubw", MX, EM, XX },
  { "psubd", MX, EM, XX },
  { "(bad)", XX, XX, XX },
  { "paddb", MX, EM, XX },
  { "paddw", MX, EM, XX },
  { "paddd", MX, EM, XX },
  { "(bad)", XX, XX, XX }
d780 16
a795 20
  /*       0 1 2 3 4 5 6 7 8 9 a b c d e f        */
  /*       -------------------------------        */
  /* 00 */ 1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0, /* 00 */
  /* 10 */ 1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0, /* 10 */
  /* 20 */ 1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0, /* 20 */
  /* 30 */ 1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0, /* 30 */
  /* 40 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 40 */
  /* 50 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 50 */
  /* 60 */ 0,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0, /* 60 */
  /* 70 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 70 */
  /* 80 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 80 */
  /* 90 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 90 */
  /* a0 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* a0 */
  /* b0 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* b0 */
  /* c0 */ 1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0, /* c0 */
  /* d0 */ 1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1, /* d0 */
  /* e0 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* e0 */
  /* f0 */ 0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1  /* f0 */
  /*       -------------------------------        */
  /*       0 1 2 3 4 5 6 7 8 9 a b c d e f        */
d799 3
a801 5
  /*       0 1 2 3 4 5 6 7 8 9 a b c d e f        */
  /*       -------------------------------        */
  /* 00 */ 1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,1, /* 0f */
  /* 10 */ 1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0, /* 1f */
  /* 20 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 2f */
d804 1
a804 1
  /* 50 */ 1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1, /* 5f */
d806 1
a806 1
  /* 70 */ 1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1, /* 7f */
d812 3
a814 28
  /* d0 */ 0,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1, /* df */
  /* e0 */ 1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1, /* ef */
  /* f0 */ 0,1,1,1,0,1,1,1,1,1,1,0,1,1,1,0  /* ff */
  /*       -------------------------------        */
  /*       0 1 2 3 4 5 6 7 8 9 a b c d e f        */
};

static const unsigned char twobyte_uses_f3_prefix[256] = {
  /*       0 1 2 3 4 5 6 7 8 9 a b c d e f        */
  /*       -------------------------------        */
  /* 00 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 0f */
  /* 10 */ 1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 1f */
  /* 20 */ 0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0, /* 2f */
  /* 30 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 3f */
  /* 40 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 4f */
  /* 50 */ 0,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1, /* 5f */
  /* 60 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 6f */
  /* 70 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 7f */
  /* 80 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 8f */
  /* 90 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 9f */
  /* a0 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* af */
  /* b0 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* bf */
  /* c0 */ 0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0, /* cf */
  /* d0 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* df */
  /* e0 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* ef */
  /* f0 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  /* ff */
  /*       -------------------------------        */
  /*       0 1 2 3 4 5 6 7 8 9 a b c d e f        */
a820 1
static unsigned char *insn_codep;
d826 1
a826 1
static void oappend PARAMS ((const char *s));
d828 1
a828 1
static const char *names32[]={
d831 1
a831 1
static const char *names16[] = {
d834 1
a834 1
static const char *names8[] = {
d837 1
a837 1
static const char *names_seg[] = {
d840 2
a841 2
static const char *index16[] = {
  "%bx,%si","%bx,%di","%bp,%si","%bp,%di","%si","%di","%bp","%bx"
d844 1
a844 1
static const struct dis386 grps[][8] = {
d847 8
a854 8
    { "addA",	Eb, Ib, XX },
    { "orA",	Eb, Ib, XX },
    { "adcA",	Eb, Ib, XX },
    { "sbbA",	Eb, Ib, XX },
    { "andA",	Eb, Ib, XX },
    { "subA",	Eb, Ib, XX },
    { "xorA",	Eb, Ib, XX },
    { "cmpA",	Eb, Ib, XX }
d858 8
a865 8
    { "addQ",	Ev, Iv, XX },
    { "orQ",	Ev, Iv, XX },
    { "adcQ",	Ev, Iv, XX },
    { "sbbQ",	Ev, Iv, XX },
    { "andQ",	Ev, Iv, XX },
    { "subQ",	Ev, Iv, XX },
    { "xorQ",	Ev, Iv, XX },
    { "cmpQ",	Ev, Iv, XX }
d869 8
a876 8
    { "addQ",	Ev, sIb, XX },
    { "orQ",	Ev, sIb, XX },
    { "adcQ",	Ev, sIb, XX },
    { "sbbQ",	Ev, sIb, XX },
    { "andQ",	Ev, sIb, XX },
    { "subQ",	Ev, sIb, XX },
    { "xorQ",	Ev, sIb, XX },
    { "cmpQ",	Ev, sIb, XX }
d880 8
a887 8
    { "rolA",	Eb, Ib, XX },
    { "rorA",	Eb, Ib, XX },
    { "rclA",	Eb, Ib, XX },
    { "rcrA",	Eb, Ib, XX },
    { "shlA",	Eb, Ib, XX },
    { "shrA",	Eb, Ib, XX },
    { "(bad)",	XX, XX, XX },
    { "sarA",	Eb, Ib, XX },
d891 8
a898 8
    { "rolQ",	Ev, Ib, XX },
    { "rorQ",	Ev, Ib, XX },
    { "rclQ",	Ev, Ib, XX },
    { "rcrQ",	Ev, Ib, XX },
    { "shlQ",	Ev, Ib, XX },
    { "shrQ",	Ev, Ib, XX },
    { "(bad)",	XX, XX, XX },
    { "sarQ",	Ev, Ib, XX },
d902 8
a909 8
    { "rolA",	Eb, XX, XX },
    { "rorA",	Eb, XX, XX },
    { "rclA",	Eb, XX, XX },
    { "rcrA",	Eb, XX, XX },
    { "shlA",	Eb, XX, XX },
    { "shrA",	Eb, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "sarA",	Eb, XX, XX },
d913 8
a920 8
    { "rolQ",	Ev, XX, XX },
    { "rorQ",	Ev, XX, XX },
    { "rclQ",	Ev, XX, XX },
    { "rcrQ",	Ev, XX, XX },
    { "shlQ",	Ev, XX, XX },
    { "shrQ",	Ev, XX, XX },
    { "(bad)",	XX, XX, XX},
    { "sarQ",	Ev, XX, XX },
d924 8
a931 8
    { "rolA",	Eb, CL, XX },
    { "rorA",	Eb, CL, XX },
    { "rclA",	Eb, CL, XX },
    { "rcrA",	Eb, CL, XX },
    { "shlA",	Eb, CL, XX },
    { "shrA",	Eb, CL, XX },
    { "(bad)",	XX, XX, XX },
    { "sarA",	Eb, CL, XX },
d935 8
a942 8
    { "rolQ",	Ev, CL, XX },
    { "rorQ",	Ev, CL, XX },
    { "rclQ",	Ev, CL, XX },
    { "rcrQ",	Ev, CL, XX },
    { "shlQ",	Ev, CL, XX },
    { "shrQ",	Ev, CL, XX },
    { "(bad)",	XX, XX, XX },
    { "sarQ",	Ev, CL, XX }
d946 8
a953 8
    { "testA",	Eb, Ib, XX },
    { "(bad)",	Eb, XX, XX },
    { "notA",	Eb, XX, XX },
    { "negA",	Eb, XX, XX },
    { "mulB",	AL, Eb, XX },
    { "imulB",	AL, Eb, XX },
    { "divB",	AL, Eb, XX },
    { "idivB",	AL, Eb, XX }
d957 8
a964 8
    { "testQ",	Ev, Iv, XX },
    { "(bad)",	XX, XX, XX },
    { "notQ",	Ev, XX, XX },
    { "negQ",	Ev, XX, XX },
    { "mulS",	eAX, Ev, XX },
    { "imulS",	eAX, Ev, XX },
    { "divS",	eAX, Ev, XX },
    { "idivS",	eAX, Ev, XX },
d968 8
a975 8
    { "incA",	Eb, XX, XX },
    { "decA",	Eb, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
d979 8
a986 8
    { "incQ",	Ev, XX, XX },
    { "decQ",	Ev, XX, XX },
    { "callP",	indirEv, XX, XX },
    { "lcallP",	indirEv, XX, XX },
    { "jmpP",	indirEv, XX, XX },
    { "ljmpP",	indirEv, XX, XX },
    { "pushQ",	Ev, XX, XX },
    { "(bad)",	XX, XX, XX },
d990 8
a997 8
    { "sldt",	Ew, XX, XX },
    { "str",	Ew, XX, XX },
    { "lldt",	Ew, XX, XX },
    { "ltr",	Ew, XX, XX },
    { "verr",	Ew, XX, XX },
    { "verw",	Ew, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX }
d1001 8
a1008 8
    { "sgdt", Ew, XX, XX },
    { "sidt", Ew, XX, XX },
    { "lgdt", Ew, XX, XX },
    { "lidt", Ew, XX, XX },
    { "smsw", Ew, XX, XX },
    { "(bad)", XX, XX, XX },
    { "lmsw", Ew, XX, XX },
    { "invlpg", Ew, XX, XX },
d1012 8
a1019 8
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "btQ",	Ev, Ib, XX },
    { "btsQ",	Ev, Ib, XX },
    { "btrQ",	Ev, Ib, XX },
    { "btcQ",	Ev, Ib, XX },
d1023 8
a1030 8
    { "(bad)",	XX, XX, XX },
    { "cmpxchg8b", Ev, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
d1034 8
a1041 8
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "psrlw",	MS, Ib, XX },
    { "(bad)",	XX, XX, XX },
    { "psraw",	MS, Ib, XX },
    { "(bad)",	XX, XX, XX },
    { "psllw",	MS, Ib, XX },
    { "(bad)",	XX, XX, XX },
d1045 8
a1052 8
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "psrld",	MS, Ib, XX },
    { "(bad)",	XX, XX, XX },
    { "psrad",	MS, Ib, XX },
    { "(bad)",	XX, XX, XX },
    { "pslld",	MS, Ib, XX },
    { "(bad)",	XX, XX, XX },
d1056 8
a1063 41
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "psrlq",	MS, Ib, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "psllq",	MS, Ib, XX },
    { "(bad)",	XX, XX, XX },
  },
  /* GRP13 */
  {
    { "fxsave", Ev, XX, XX },
    { "fxrstor", Ev, XX, XX },
    { "ldmxcsr", Ev, XX, XX },
    { "stmxcsr", Ev, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "sfence", None, XX, XX },
  },
  /* GRP14 */
  {
    { "prefetchnta", Ev, XX, XX },
    { "prefetcht0", Ev, XX, XX },
    { "prefetcht1", Ev, XX, XX },
    { "prefetcht2", Ev, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
  },
  /* GRPAMD */
  {
    { "prefetch", Eb, XX, XX },
    { "prefetchw", Eb, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
a1064 1

d1067 12
a1078 77
static const struct dis386 prefix_user_table[][2] = {
  /* PREGRP0 */
  {
    { "addps", XM, EX, XX },
    { "addss", XM, EX, XX },
  },
  /* PREGRP1 */
  {
    { "", XM, EX, OPSIMD },	/* See OP_SIMD_SUFFIX */
    { "", XM, EX, OPSIMD },
  },
  /* PREGRP2 */
  {
    { "cvtpi2ps", XM, EM, XX },
    { "cvtsi2ss", XM, Ev, XX },
  },
  /* PREGRP3 */
  {
    { "cvtps2pi", MX, EX, XX },
    { "cvtss2si", Gv, EX, XX },
  },
  /* PREGRP4 */
  {
    { "cvttps2pi", MX, EX, XX },
    { "cvttss2si", Gv, EX, XX },
  },
  /* PREGRP5 */
  {
    { "divps", XM, EX, XX },
    { "divss", XM, EX, XX },
  },
  /* PREGRP6 */
  {
    { "maxps", XM, EX, XX },
    { "maxss", XM, EX, XX },
  },
  /* PREGRP7 */
  {
    { "minps", XM, EX, XX },
    { "minss", XM, EX, XX },
  },
  /* PREGRP8 */
  {
    { "movups", XM, EX, XX },
    { "movss", XM, EX, XX },
  },
  /* PREGRP9 */
  {
    { "movups", EX, XM, XX },
    { "movss", EX, XM, XX },
  },
  /* PREGRP10 */
  {
    { "mulps", XM, EX, XX },
    { "mulss", XM, EX, XX },
  },
  /* PREGRP11 */
  {
    { "rcpps", XM, EX, XX },
    { "rcpss", XM, EX, XX },
  },
  /* PREGRP12 */
  {
    { "rsqrtps", XM, EX, XX },
    { "rsqrtss", XM, EX, XX },
  },
  /* PREGRP13 */
  {
    { "sqrtps", XM, EX, XX },
    { "sqrtss", XM, EX, XX },
  },
  /* PREGRP14 */
  {
    { "subps", XM, EX, XX },
    { "subss", XM, EX, XX },
  }
};
d1080 1
a1080 1
#define INTERNAL_DISASSEMBLER_ERROR _("<internal disassembler error>")
a1085 1
  used_prefixes = 0;
d1122 1
a1122 1
	  prefixes |= PREFIX_ADDR;
d1124 2
a1125 11
	case FWAIT_OPCODE:
	  /* fwait is really an instruction.  If there are prefixes
	     before the fwait, they belong to the fwait, *not* to the
	     following instruction.  */
	  if (prefixes)
	    {
	      prefixes |= PREFIX_FWAIT;
	      codep++;
	      return;
	    }
	  prefixes = PREFIX_FWAIT;
a1133 39
/* Return the name of the prefix byte PREF, or NULL if PREF is not a
   prefix byte.  */

static const char *
prefix_name (pref, sizeflag)
     int pref;
     int sizeflag;
{
  switch (pref)
    {
    case 0xf3:
      return "repz";
    case 0xf2:
      return "repnz";
    case 0xf0:
      return "lock";
    case 0x2e:
      return "cs";
    case 0x36:
      return "ss";
    case 0x3e:
      return "ds";
    case 0x26:
      return "es";
    case 0x64:
      return "fs";
    case 0x65:
      return "gs";
    case 0x66:
      return (sizeflag & DFLAG) ? "data16" : "data32";
    case 0x67:
      return (sizeflag & AFLAG) ? "addr16" : "addr32";
    case FWAIT_OPCODE:
      return "fwait";
    default:
      return NULL;
    }
}

d1135 2
a1136 3
static int op_ad, op_index[3];
static unsigned int op_address[3];
static unsigned int start_pc;
d1148 2
a1149 9
static int print_insn_i386
  PARAMS ((bfd_vma pc, disassemble_info *info));

static char intel_syntax;
static char open_char;
static char close_char;
static char separator_char;
static char scale_char;

d1151 1
a1151 1
print_insn_i386_att (pc, info)
d1155 6
a1160 7
  intel_syntax = 0;
  open_char = '(';
  close_char =  ')';
  separator_char = ',';
  scale_char = ',';

  return print_insn_i386 (pc, info);
d1164 1
a1164 15
print_insn_i386_intel (pc, info)
     bfd_vma pc;
     disassemble_info *info;
{
  intel_syntax = 1;
  open_char = '[';
  close_char = ']';
  separator_char = '+';
  scale_char = '*';

  return print_insn_i386 (pc, info);
}

static int
print_insn_i386 (pc, info)
d1168 1
a1168 1
  const struct dis386 *dp;
d1170 1
a1170 1
  int two_source_ops;
a1173 3
  unsigned char uses_f3_prefix;
  VOLATILE int sizeflag;
  VOLATILE int orig_sizeflag;
d1178 3
a1180 12
  if (info->mach == bfd_mach_i386_i386
      || info->mach == bfd_mach_i386_i386_intel_syntax)
    sizeflag = AFLAG|DFLAG;
  else if (info->mach == bfd_mach_i386_i8086)
    sizeflag = 0;
  else
    abort ();
  orig_sizeflag = sizeflag;

  /* The output looks better if we put 7 bytes on a line, since that
     puts most long word instructions on a single line.  */
  info->bytes_per_line = 7;
d1185 3
d1200 1
a1200 26

  if (setjmp (priv.bailout) != 0)
    {
      const char *name;

      /* Getting here means we tried for data but didn't get it.  That
         means we have an incomplete instruction of some sort.  Just
         print the first byte as a prefix or a .byte pseudo-op.  */
      if (codep > inbuf)
	{
	  name = prefix_name (inbuf[0], orig_sizeflag);
	  if (name != NULL)
	    (*info->fprintf_func) (info->stream, "%s", name);
	  else
	    {
	      /* Just print the first byte as a .byte instruction.  */
	      (*info->fprintf_func) (info->stream, ".byte 0x%x",
				     (unsigned int) inbuf[0]);
	    }

	  return 1;
	}

      return -1;
    }

a1202 2
  insn_codep = codep;

d1204 5
a1208 2
  two_source_ops = (*codep == 0x62) || (*codep == 0xc8);

d1210 8
a1217 1

d1221 12
a1232 9
      const char *name;

      /* fwait not followed by floating point instruction.  Print the
         first prefix, which is probably fwait itself.  */
      name = prefix_name (inbuf[0], orig_sizeflag);
      if (name == NULL)
	name = INTERNAL_DISASSEMBLER_ERROR;
      (*info->fprintf_func) (info->stream, "%s", name);
      return 1;
d1234 1
a1234 1

d1238 1
a1238 4
      if (intel_syntax)
        dp = &dis386_twobyte_intel[*++codep];
      else
        dp = &dis386_twobyte_att[*++codep];
a1239 1
      uses_f3_prefix = twobyte_uses_f3_prefix[*codep];
d1243 1
a1243 4
      if (intel_syntax)
        dp = &dis386_intel[*codep];
      else
        dp = &dis386_att[*codep];
a1244 1
      uses_f3_prefix = 0;
a1247 29
  if (!uses_f3_prefix && (prefixes & PREFIX_REPZ))
    {
      oappend ("repz ");
      used_prefixes |= PREFIX_REPZ;
    }
  if (prefixes & PREFIX_REPNZ)
    {
      oappend ("repnz ");
      used_prefixes |= PREFIX_REPNZ;
    }
  if (prefixes & PREFIX_LOCK)
    {
      oappend ("lock ");
      used_prefixes |= PREFIX_LOCK;
    }

  if (prefixes & PREFIX_DATA)
    sizeflag ^= DFLAG;

  if (prefixes & PREFIX_ADDR)
    {
      sizeflag ^= AFLAG;
      if (sizeflag & AFLAG)
        oappend ("addr32 ");
      else
	oappend ("addr16 ");
      used_prefixes |= PREFIX_ADDR;
    }

d1258 1
a1258 1
      dofloat (sizeflag);
d1263 4
a1266 18
	{
	  switch(dp->bytemode2)
	    {
	      case USE_GROUPS:
	        dp = &grps[dp->bytemode1][reg];
		break;
	      case USE_PREFIX_USER_TABLE:
		dp = &prefix_user_table[dp->bytemode1][prefixes & PREFIX_REPZ ? 1 : 0];
		used_prefixes |= (prefixes & PREFIX_REPZ);
		break;
	      default:
		oappend (INTERNAL_DISASSEMBLER_ERROR);
		break;
	    }
	}

      putop (dp->name, sizeflag);

d1270 2
a1271 2
	(*dp->op1)(dp->bytemode1, sizeflag);

d1275 2
a1276 2
	(*dp->op2)(dp->bytemode2, sizeflag);

d1280 1
a1280 16
	(*dp->op3)(dp->bytemode3, sizeflag);
    }

  /* See if any prefixes were not used.  If so, print the first one
     separately.  If we don't do this, we'll wind up printing an
     instruction stream which does not precisely correspond to the
     bytes we are disassembling.  */
  if ((prefixes & ~used_prefixes) != 0)
    {
      const char *name;

      name = prefix_name (inbuf[0], orig_sizeflag);
      if (name == NULL)
	name = INTERNAL_DISASSEMBLER_ERROR;
      (*info->fprintf_func) (info->stream, "%s", name);
      return 1;
d1282 1
a1282 1

d1288 6
a1293 4

  /* The enter and bound instructions are printed with operands in the same
     order as the intel book; everything else is printed in reverse order.  */
  if (intel_syntax || two_source_ops)
d1312 1
a1312 1
	(*info->print_address_func) ((bfd_vma) op_address[op_index[0]], info);
d1322 1
a1322 1
	(*info->print_address_func) ((bfd_vma) op_address[op_index[1]], info);
d1332 1
a1332 1
	(*info->print_address_func) ((bfd_vma) op_address[op_index[2]], info);
d1336 1
a1336 1
  return codep - inbuf;
d1339 1
a1339 1
static const char *float_mem_att[] = {
d1414 14
a1427 1
static const char *float_mem_intel[] = {
d1429 9
a1437 97
  "fadd",
  "fmul",
  "fcom",
  "fcomp",
  "fsub",
  "fsubr",
  "fdiv",
  "fdivr",
  /*  d9 */
  "fld",
  "(bad)",
  "fst",
  "fstp",
  "fldenv",
  "fldcw",
  "fNstenv",
  "fNstcw",
  /* da */
  "fiadd",
  "fimul",
  "ficom",
  "ficomp",
  "fisub",
  "fisubr",
  "fidiv",
  "fidivr",
  /* db */
  "fild",
  "(bad)",
  "fist",
  "fistp",
  "(bad)",
  "fld",
  "(bad)",
  "fstp",
  /* dc */
  "fadd",
  "fmul",
  "fcom",
  "fcomp",
  "fsub",
  "fsubr",
  "fdiv",
  "fdivr",
  /* dd */
  "fld",
  "(bad)",
  "fst",
  "fstp",
  "frstor",
  "(bad)",
  "fNsave",
  "fNstsw",
  /* de */
  "fiadd",
  "fimul",
  "ficom",
  "ficomp",
  "fisub",
  "fisubr",
  "fidiv",
  "fidivr",
  /* df */
  "fild",
  "(bad)",
  "fist",
  "fistp",
  "fbld",
  "fild",
  "fbstp",
  "fistpll",
};

#define ST OP_ST, 0
#define STi OP_STi, 0

#define FGRPd9_2 NULL, NULL, 0, NULL, 0, NULL, 0
#define FGRPd9_4 NULL, NULL, 1, NULL, 0, NULL, 0
#define FGRPd9_5 NULL, NULL, 2, NULL, 0, NULL, 0
#define FGRPd9_6 NULL, NULL, 3, NULL, 0, NULL, 0
#define FGRPd9_7 NULL, NULL, 4, NULL, 0, NULL, 0
#define FGRPda_5 NULL, NULL, 5, NULL, 0, NULL, 0
#define FGRPdb_4 NULL, NULL, 6, NULL, 0, NULL, 0
#define FGRPde_3 NULL, NULL, 7, NULL, 0, NULL, 0
#define FGRPdf_4 NULL, NULL, 8, NULL, 0, NULL, 0

static const struct dis386 float_reg[][8] = {
  /* d8 */
  {
    { "fadd",	ST, STi, XX },
    { "fmul",	ST, STi, XX },
    { "fcom",	STi, XX, XX },
    { "fcomp",	STi, XX, XX },
    { "fsub",	ST, STi, XX },
    { "fsubr",	ST, STi, XX },
    { "fdiv",	ST, STi, XX },
    { "fdivr",	ST, STi, XX },
d1441 2
a1442 2
    { "fld",	STi, XX, XX },
    { "fxch",	STi, XX, XX },
d1444 1
a1444 1
    { "(bad)",	XX, XX, XX },
d1452 5
a1456 5
    { "fcmovb",	ST, STi, XX },
    { "fcmove",	ST, STi, XX },
    { "fcmovbe",ST, STi, XX },
    { "fcmovu",	ST, STi, XX },
    { "(bad)",	XX, XX, XX },
d1458 2
a1459 2
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
d1463 4
a1466 4
    { "fcmovnb",ST, STi, XX },
    { "fcmovne",ST, STi, XX },
    { "fcmovnbe",ST, STi, XX },
    { "fcmovnu",ST, STi, XX },
d1468 3
a1470 3
    { "fucomi",	ST, STi, XX },
    { "fcomi",	ST, STi, XX },
    { "(bad)",	XX, XX, XX },
d1474 8
a1481 15
    { "fadd",	STi, ST, XX },
    { "fmul",	STi, ST, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
#if UNIXWARE_COMPAT
    { "fsub",	STi, ST, XX },
    { "fsubr",	STi, ST, XX },
    { "fdiv",	STi, ST, XX },
    { "fdivr",	STi, ST, XX },
#else
    { "fsubr",	STi, ST, XX },
    { "fsub",	STi, ST, XX },
    { "fdivr",	STi, ST, XX },
    { "fdiv",	STi, ST, XX },
#endif
d1485 8
a1492 8
    { "ffree",	STi, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "fst",	STi, XX, XX },
    { "fstp",	STi, XX, XX },
    { "fucom",	STi, XX, XX },
    { "fucomp",	STi, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
d1496 3
a1498 3
    { "faddp",	STi, ST, XX },
    { "fmulp",	STi, ST, XX },
    { "(bad)",	XX, XX, XX },
d1500 4
a1503 11
#if UNIXWARE_COMPAT
    { "fsubp",	STi, ST, XX },
    { "fsubrp",	STi, ST, XX },
    { "fdivp",	STi, ST, XX },
    { "fdivrp",	STi, ST, XX },
#else
    { "fsubrp",	STi, ST, XX },
    { "fsubp",	STi, ST, XX },
    { "fdivrp",	STi, ST, XX },
    { "fdivp",	STi, ST, XX },
#endif
d1507 4
a1510 4
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "(bad)",	XX, XX, XX },
d1512 3
a1514 3
    { "fucomip",ST, STi, XX },
    { "fcomip", ST, STi, XX },
    { "(bad)",	XX, XX, XX },
d1568 3
a1570 2
dofloat (sizeflag)
     int sizeflag;
d1572 1
a1572 1
  const struct dis386 *dp;
d1574 1
a1574 1

d1576 1
a1576 1

d1579 1
a1579 4
      if (intel_syntax)
        putop (float_mem_intel[(floatop - 0xd8 ) * 8 + reg], sizeflag);
      else
        putop (float_mem_att[(floatop - 0xd8 ) * 8 + reg], sizeflag);
d1581 1
a1581 6
      if (floatop == 0xdb)
        OP_E (x_mode, sizeflag);
      else if (floatop == 0xdd)
        OP_E (d_mode, sizeflag);
      else
        OP_E (v_mode, sizeflag);
d1585 1
a1585 1

d1589 1
a1589 2
      putop (fgrps[dp->bytemode1][rm], sizeflag);

d1591 4
a1594 2
      if (floatop == 0xdf && codep[-1] == 0xe0)
	strcpy (op1out, names16[0]);
d1598 1
a1598 2
      putop (dp->name, sizeflag);

d1601 1
a1601 1
	(*dp->op1)(dp->bytemode1, sizeflag);
d1604 1
a1604 1
	(*dp->op2)(dp->bytemode2, sizeflag);
d1609 5
a1613 4
static void
OP_ST (ignore, sizeflag)
     int ignore ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
d1616 1
d1620 5
a1624 4
static void
OP_STi (ignore, sizeflag)
     int ignore ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
d1628 1
d1634 4
a1637 3
putop (template, sizeflag)
     const char *template;
     int sizeflag;
d1639 2
a1640 2
  const char *p;

d1648 2
a1649 20
	case 'A':
          if (intel_syntax)
            break;
	  if (mod != 3
#ifdef SUFFIX_ALWAYS
	      || (sizeflag & SUFFIX_ALWAYS)
#endif
	      )
	    *obufp++ = 'b';
	  break;
	case 'B':
          if (intel_syntax)
            break;
#ifdef SUFFIX_ALWAYS
	  if (sizeflag & SUFFIX_ALWAYS)
	    *obufp++ = 'b';
#endif
	  break;
	case 'E':		/* For jcxz/jecxz */
	  if (sizeflag & AFLAG)
a1651 8
	case 'L':
          if (intel_syntax)
            break;
#ifdef SUFFIX_ALWAYS
	  if (sizeflag & SUFFIX_ALWAYS)
	    *obufp++ = 'l';
#endif
	  break;
a1654 2
	  else
	    used_prefixes |= PREFIX_FWAIT;
d1656 4
a1659 46
	case 'P':
          if (intel_syntax)
            break;
	  if ((prefixes & PREFIX_DATA)
#ifdef SUFFIX_ALWAYS
	      || (sizeflag & SUFFIX_ALWAYS)
#endif
	      )
	    {
	      if (sizeflag & DFLAG)
		*obufp++ = 'l';
	      else
		*obufp++ = 'w';
	      used_prefixes |= (prefixes & PREFIX_DATA);
	    }
	  break;
	case 'Q':
          if (intel_syntax)
            break;
	  if (mod != 3
#ifdef SUFFIX_ALWAYS
	      || (sizeflag & SUFFIX_ALWAYS)
#endif
	      )
	    {
	      if (sizeflag & DFLAG)
		*obufp++ = 'l';
	      else
		*obufp++ = 'w';
	      used_prefixes |= (prefixes & PREFIX_DATA);
	    }
	  break;
	case 'R':
          if (intel_syntax)
	    {
	      if (sizeflag & DFLAG)
		{
		  *obufp++ = 'd';
		  *obufp++ = 'q';
		}
	      else
		{
		  *obufp++ = 'w';
		  *obufp++ = 'd';
		}
	    }
a1660 25
	    {
	      if (sizeflag & DFLAG)
		*obufp++ = 'l';
	      else
		*obufp++ = 'w';
	    }
	  used_prefixes |= (prefixes & PREFIX_DATA);
	  break;
	case 'S':
          if (intel_syntax)
            break;
#ifdef SUFFIX_ALWAYS
	  if (sizeflag & SUFFIX_ALWAYS)
	    {
	      if (sizeflag & DFLAG)
		*obufp++ = 'l';
	      else
		*obufp++ = 'w';
	      used_prefixes |= (prefixes & PREFIX_DATA);
	    }
#endif
	  break;
	case 'W':
	  /* operand size flag for cwtl, cbtw */
	  if (sizeflag & DFLAG)
a1661 15
	  else
	    *obufp++ = 'b';
          if (intel_syntax)
	    {
	      if (sizeflag & DFLAG)
		{
		  *obufp++ = 'd';
		  *obufp++ = 'e';
		}
	      else
		{
		  *obufp++ = 'w';
		}
	    }
	  used_prefixes |= (prefixes & PREFIX_DATA);
d1670 1
a1670 1
     const char *s;
d1674 1
d1678 1
a1678 1
append_seg ()
d1681 1
a1681 4
    {
      oappend ("%cs:");
      used_prefixes |= PREFIX_CS;
    }
d1683 1
a1683 4
    {
      oappend ("%ds:");
      used_prefixes |= PREFIX_DS;
    }
d1685 1
a1685 4
    {
      oappend ("%ss:");
      used_prefixes |= PREFIX_SS;
    }
d1687 1
a1687 4
    {
      oappend ("%es:");
      used_prefixes |= PREFIX_ES;
    }
d1689 1
a1689 4
    {
      oappend ("%fs:");
      used_prefixes |= PREFIX_FS;
    }
d1691 1
a1691 4
    {
      oappend ("%gs:");
      used_prefixes |= PREFIX_GS;
    }
d1694 2
a1695 2
static void
OP_indirE (bytemode, sizeflag)
d1697 2
a1698 1
     int sizeflag;
d1700 2
a1701 3
  if (!intel_syntax)
    oappend ("*");
  OP_E (bytemode, sizeflag);
d1704 2
a1705 2
static void
OP_E (bytemode, sizeflag)
d1707 2
a1708 1
     int sizeflag;
a1724 3
	case d_mode:
	  oappend (names32[rm]);
	  break;
d1726 1
a1726 1
	  if (sizeflag & DFLAG)
a1729 5
	  used_prefixes |= (prefixes & PREFIX_DATA);
	  break;
	case 0:
	  if ( !(codep[-2] == 0xAE && codep[-1] == 0xF8 /* sfence */))
	    BadOp();	/* bad sfence,lea,lds,les,lfs,lgs,lss modrm */
d1732 1
a1732 1
	  oappend (INTERNAL_DISASSEMBLER_ERROR);
d1735 1
a1735 1
      return;
d1739 1
a1739 1
  append_seg ();
d1741 1
a1741 1
  if (sizeflag & AFLAG) /* 32 bit address mode */
d1746 2
a1747 2
      int index = 0;
      int scale = 0;
d1774 1
a1774 3
	  disp = *codep++;
	  if ((disp & 0x80) != 0)
	    disp -= 0x100;
d1781 5
a1785 6
      if (!intel_syntax)
        if (mod != 0 || base == 5)
          {
            sprintf (scratchbuf, "0x%x", disp);
            oappend (scratchbuf);
          }
d1789 1
a1789 25
          if (intel_syntax)
            {
              switch (bytemode)
                {
                case b_mode:
                  oappend("BYTE PTR ");
                  break;
                case w_mode:
                  oappend("WORD PTR ");
                  break;
                case v_mode:
                  oappend("DWORD PTR ");
                  break;
                case d_mode:
                  oappend("QWORD PTR ");
                  break;
                case x_mode:
                  oappend("XWORD PTR ");
                  break;
                default:
                  break;
                }
             }
	  *obufp++ = open_char;
          *obufp = '\0';
d1796 1
a1796 11
                  if (intel_syntax)
                    {
                      if (havebase)
                        {
                          *obufp++ = separator_char;
                          *obufp = '\0';
                        }
                      sprintf (scratchbuf, "%s", names32[index]);
                    }
                  else
		    sprintf (scratchbuf, ",%s", names32[index]);
d1799 2
a1800 11
              if (!intel_syntax
                  || (intel_syntax
                      && bytemode != b_mode
                      && bytemode != w_mode
                      && bytemode != v_mode))
                {
                  *obufp++ = scale_char;
                  *obufp = '\0';
	          sprintf (scratchbuf, "%d", 1 << scale);
	          oappend (scratchbuf);
                }
d1802 1
a1802 18
          if (intel_syntax)
            if (mod != 0 || base == 5)
              {
                /* Don't print zero displacements */
                if (disp > 0)
                  {
                    sprintf (scratchbuf, "+%d", disp);
                    oappend (scratchbuf);
                  }
                else if (disp < 0)
                  {
                    sprintf (scratchbuf, "%d", disp);
                    oappend (scratchbuf);
                  }
              }

	  *obufp++ = close_char;
          *obufp = '\0';
a1803 16
      else if (intel_syntax)
        {
          if (mod != 0 || base == 5)
            {
	      if (prefixes & (PREFIX_CS | PREFIX_SS | PREFIX_DS
			      | PREFIX_ES | PREFIX_FS | PREFIX_GS))
		;
	      else
		{
		  oappend (names_seg[3]);
		  oappend (":");
		}
              sprintf (scratchbuf, "0x%x", disp);
              oappend (scratchbuf);
            }
        }
d1811 1
a1811 5
	    {
	      disp = get16 ();
	      if ((disp & 0x8000) != 0)
		disp -= 0x10000;
	    }
d1815 1
a1815 3
	  disp = *codep++;
	  if ((disp & 0x80) != 0)
	    disp -= 0x100;
d1818 1
a1818 3
	  disp = get16 ();
	  if ((disp & 0x8000) != 0)
	    disp -= 0x10000;
d1822 5
a1826 6
      if (!intel_syntax)
        if (mod != 0 || rm == 6)
          {
            sprintf (scratchbuf, "%d", disp);
            oappend (scratchbuf);
          }
d1830 1
a1830 2
	  *obufp++ = open_char;
          *obufp = '\0';
d1832 1
a1832 2
          *obufp++ = close_char;
          *obufp = '\0';
d1835 1
d1838 2
a1839 2
static void
OP_G (bytemode, sizeflag)
d1841 2
a1842 1
     int sizeflag;
d1844 1
a1844 1
  switch (bytemode)
d1856 1
a1856 1
      if (sizeflag & DFLAG)
a1859 1
      used_prefixes |= (prefixes & PREFIX_DATA);
d1862 1
a1862 1
      oappend (INTERNAL_DISASSEMBLER_ERROR);
d1865 1
d1878 1
a1878 1
  return x;
d1889 1
a1889 1
  return x;
d1894 1
a1894 1
     unsigned int op;
d1900 2
a1901 2
static void
OP_REG (code, sizeflag)
d1903 2
a1904 1
     int sizeflag;
d1906 20
a1925 22
  const char *s;

  switch (code)
    {
    case indir_dx_reg:
      s = "(%dx)";
      break;
    case ax_reg: case cx_reg: case dx_reg: case bx_reg:
    case sp_reg: case bp_reg: case si_reg: case di_reg:
      s = names16[code - ax_reg];
      break;
    case es_reg: case ss_reg: case cs_reg:
    case ds_reg: case fs_reg: case gs_reg:
      s = names_seg[code - es_reg];
      break;
    case al_reg: case ah_reg: case cl_reg: case ch_reg:
    case dl_reg: case dh_reg: case bl_reg: case bh_reg:
      s = names8[code - al_reg];
      break;
    case eAX_reg: case eCX_reg: case eDX_reg: case eBX_reg:
    case eSP_reg: case eBP_reg: case eSI_reg: case eDI_reg:
      if (sizeflag & DFLAG)
a1928 1
      used_prefixes |= (prefixes & PREFIX_DATA);
d1931 1
a1931 1
      s = INTERNAL_DISASSEMBLER_ERROR;
d1935 1
d1938 2
a1939 2
static void
OP_I (bytemode, sizeflag)
d1941 2
a1942 1
     int sizeflag;
d1945 2
a1946 2

  switch (bytemode)
d1953 1
a1953 1
      if (sizeflag & DFLAG)
a1956 1
      used_prefixes |= (prefixes & PREFIX_DATA);
d1962 2
a1963 2
      oappend (INTERNAL_DISASSEMBLER_ERROR);
      return;
d1965 1
a1965 5

  if (intel_syntax)
    sprintf (scratchbuf, "0x%x", op);
  else
    sprintf (scratchbuf, "$0x%x", op);
d1967 1
a1967 1
  scratchbuf[0] = '\0';
d1970 2
a1971 2
static void
OP_sI (bytemode, sizeflag)
d1973 2
a1974 1
     int sizeflag;
d1977 2
a1978 2

  switch (bytemode)
d1982 1
a1982 3
      op = *codep++;
      if ((op & 0x80) != 0)
	op -= 0x100;
d1985 1
a1985 1
      if (sizeflag & DFLAG)
d1988 1
a1988 6
	{
	  op = get16();
	  if ((op & 0x8000) != 0)
	    op -= 0x10000;
	}
      used_prefixes |= (prefixes & PREFIX_DATA);
d1991 1
a1991 3
      op = get16 ();
      if ((op & 0x8000) != 0)
	op -= 0x10000;
d1994 2
a1995 2
      oappend (INTERNAL_DISASSEMBLER_ERROR);
      return;
d1997 1
a1997 4
  if (intel_syntax)
    sprintf (scratchbuf, "%d", op);
  else
    sprintf (scratchbuf, "$0x%x", op);
d1999 1
d2002 2
a2003 2
static void
OP_J (bytemode, sizeflag)
d2005 2
a2006 1
     int sizeflag;
d2010 2
a2011 2

  switch (bytemode)
d2015 1
a2015 3
      disp = *codep++;
      if ((disp & 0x80) != 0)
	disp -= 0x100;
d2018 1
a2018 1
      if (sizeflag & DFLAG)
d2022 1
a2022 1
	  disp = get16 ();
a2027 1
      used_prefixes |= (prefixes & PREFIX_DATA);
d2030 2
a2031 2
      oappend (INTERNAL_DISASSEMBLER_ERROR);
      return;
d2037 1
d2041 5
a2045 4
static void
OP_SEG (dummy, sizeflag)
     int dummy ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
d2052 1
d2055 5
a2059 5
/* ARGSUSED */
static void
OP_DIR (dummy, sizeflag)
     int dummy ATTRIBUTE_UNUSED;
     int sizeflag;
d2062 2
a2063 2

  if (sizeflag & DFLAG)
d2065 28
a2092 2
      offset = get32 ();
      seg = get16 ();
d2094 1
a2094 8
  else
    {
      offset = get16 ();
      seg = get16 ();
    }
  used_prefixes |= (prefixes & PREFIX_DATA);
  sprintf (scratchbuf, "$0x%x,$0x%x", seg, offset);
  oappend (scratchbuf);
d2098 5
a2102 4
static void
OP_OFF (ignore, sizeflag)
     int ignore ATTRIBUTE_UNUSED;
     int sizeflag;
d2106 1
a2106 1
  append_seg ();
d2108 1
a2108 1
  if (sizeflag & AFLAG)
d2112 1
a2112 10

  if (intel_syntax)
    {
      if (!(prefixes & (PREFIX_CS | PREFIX_SS | PREFIX_DS
		        | PREFIX_ES | PREFIX_FS | PREFIX_GS)))
	{
	  oappend (names_seg[3]);
	  oappend (":");
	}
    }
d2115 1
d2118 6
a2123 4
static void
ptr_reg (code, sizeflag)
     int code;
     int sizeflag;
d2125 2
a2126 7
  const char *s;
  oappend ("(");
  if (sizeflag & AFLAG)
    s = names32[code - eAX_reg];
  else
    s = names16[code - eAX_reg];
  oappend (s);
d2128 1
d2131 6
a2136 4
static void
OP_ESreg (code, sizeflag)
     int code;
     int sizeflag;
d2138 4
a2141 2
  oappend ("%es:");
  ptr_reg (code, sizeflag);
d2144 9
a2152 4
static void
OP_DSreg (code, sizeflag)
     int code;
     int sizeflag;
d2154 2
a2155 10
  if ((prefixes
       & (PREFIX_CS
	  | PREFIX_DS
	  | PREFIX_SS
	  | PREFIX_ES
	  | PREFIX_FS
	  | PREFIX_GS)) == 0)
    prefixes |= PREFIX_DS;
  append_seg();
  ptr_reg (code, sizeflag);
d2158 2
d2161 5
a2165 4
static void
OP_C (dummy, sizeflag)
     int dummy ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
d2167 1
d2170 1
d2174 5
a2178 4
static void
OP_D (dummy, sizeflag)
     int dummy ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
d2180 1
d2183 1
d2187 5
a2191 4
static void
OP_T (dummy, sizeflag)
     int dummy ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
d2193 1
d2196 1
d2199 2
a2200 2
static void
OP_Rd (bytemode, sizeflag)
d2202 2
a2203 1
     int sizeflag;
d2205 10
a2214 4
  if (mod == 3)
    OP_E (bytemode, sizeflag);
  else
    BadOp();
d2217 5
a2221 4
static void
OP_MMX (ignore, sizeflag)
     int ignore ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
d2225 1
d2228 2
a2229 11
static void
OP_XMM (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
{
  sprintf (scratchbuf, "%%xmm%d", reg);
  oappend (scratchbuf);
}

static void
OP_EM (bytemode, sizeflag)
d2231 2
a2232 1
     int sizeflag;
d2235 1
a2235 4
    {
      OP_E (bytemode, sizeflag);
      return;
    }
d2240 1
d2243 2
a2244 2
static void
OP_EX (bytemode, sizeflag)
d2246 2
a2247 1
     int sizeflag;
d2249 2
a2250 8
  if (mod != 3)
    {
      OP_E (bytemode, sizeflag);
      return;
    }

  codep++;
  sprintf (scratchbuf, "%%xmm%d", rm);
d2252 1
a2252 168
}

static void
OP_MS (bytemode, sizeflag)
     int bytemode;
     int sizeflag;
{
  if (mod == 3)
    OP_EM (bytemode, sizeflag);
  else
    BadOp();
}

static const char *Suffix3DNow[] = {
/* 00 */	NULL,		NULL,		NULL,		NULL,
/* 04 */	NULL,		NULL,		NULL,		NULL,
/* 08 */	NULL,		NULL,		NULL,		NULL,
/* 0C */	"pi2fw",	"pi2fd",	NULL,		NULL,
/* 10 */	NULL,		NULL,		NULL,		NULL,
/* 14 */	NULL,		NULL,		NULL,		NULL,
/* 18 */	NULL,		NULL,		NULL,		NULL,
/* 1C */	"pf2iw",	"pf2id",	NULL,		NULL,
/* 20 */	NULL,		NULL,		NULL,		NULL,
/* 24 */	NULL,		NULL,		NULL,		NULL,
/* 28 */	NULL,		NULL,		NULL,		NULL,
/* 2C */	NULL,		NULL,		NULL,		NULL,
/* 30 */	NULL,		NULL,		NULL,		NULL,
/* 34 */	NULL,		NULL,		NULL,		NULL,
/* 38 */	NULL,		NULL,		NULL,		NULL,
/* 3C */	NULL,		NULL,		NULL,		NULL,
/* 40 */	NULL,		NULL,		NULL,		NULL,
/* 44 */	NULL,		NULL,		NULL,		NULL,
/* 48 */	NULL,		NULL,		NULL,		NULL,
/* 4C */	NULL,		NULL,		NULL,		NULL,
/* 50 */	NULL,		NULL,		NULL,		NULL,
/* 54 */	NULL,		NULL,		NULL,		NULL,
/* 58 */	NULL,		NULL,		NULL,		NULL,
/* 5C */	NULL,		NULL,		NULL,		NULL,
/* 60 */	NULL,		NULL,		NULL,		NULL,
/* 64 */	NULL,		NULL,		NULL,		NULL,
/* 68 */	NULL,		NULL,		NULL,		NULL,
/* 6C */	NULL,		NULL,		NULL,		NULL,
/* 70 */	NULL,		NULL,		NULL,		NULL,
/* 74 */	NULL,		NULL,		NULL,		NULL,
/* 78 */	NULL,		NULL,		NULL,		NULL,
/* 7C */	NULL,		NULL,		NULL,		NULL,
/* 80 */	NULL,		NULL,		NULL,		NULL,
/* 84 */	NULL,		NULL,		NULL,		NULL,
/* 88 */	NULL,		NULL,		"pfnacc",	NULL,
/* 8C */	NULL,		NULL,		"pfpnacc",	NULL,
/* 90 */	"pfcmpge",	NULL,		NULL,		NULL,
/* 94 */	"pfmin",	NULL,		"pfrcp",	"pfrsqrt",
/* 98 */	NULL,		NULL,		"pfsub",	NULL,
/* 9C */	NULL,		NULL,		"pfadd",	NULL,
/* A0 */	"pfcmpgt",	NULL,		NULL,		NULL,
/* A4 */	"pfmax",	NULL,		"pfrcpit1",	"pfrsqit1",
/* A8 */	NULL,		NULL,		"pfsubr",	NULL,
/* AC */	NULL,		NULL,		"pfacc",	NULL,
/* B0 */	"pfcmpeq",	NULL,		NULL,		NULL,
/* B4 */	"pfmul",	NULL,		"pfrcpit2",	"pfmulhrw",
/* B8 */	NULL,		NULL,		NULL,		"pswapd",
/* BC */	NULL,		NULL,		NULL,		"pavgusb",
/* C0 */	NULL,		NULL,		NULL,		NULL,
/* C4 */	NULL,		NULL,		NULL,		NULL,
/* C8 */	NULL,		NULL,		NULL,		NULL,
/* CC */	NULL,		NULL,		NULL,		NULL,
/* D0 */	NULL,		NULL,		NULL,		NULL,
/* D4 */	NULL,		NULL,		NULL,		NULL,
/* D8 */	NULL,		NULL,		NULL,		NULL,
/* DC */	NULL,		NULL,		NULL,		NULL,
/* E0 */	NULL,		NULL,		NULL,		NULL,
/* E4 */	NULL,		NULL,		NULL,		NULL,
/* E8 */	NULL,		NULL,		NULL,		NULL,
/* EC */	NULL,		NULL,		NULL,		NULL,
/* F0 */	NULL,		NULL,		NULL,		NULL,
/* F4 */	NULL,		NULL,		NULL,		NULL,
/* F8 */	NULL,		NULL,		NULL,		NULL,
/* FC */	NULL,		NULL,		NULL,		NULL,
};

static void
OP_3DNowSuffix (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
{
  const char *mnemonic;

  FETCH_DATA (the_info, codep + 1);
  /* AMD 3DNow! instructions are specified by an opcode suffix in the
     place where an 8-bit immediate would normally go.  ie. the last
     byte of the instruction.  */
  obufp = obuf + strlen(obuf);
  mnemonic = Suffix3DNow[*codep++ & 0xff];
  if (mnemonic)
    oappend (mnemonic);
  else
    {
      /* Since a variable sized modrm/sib chunk is between the start
	 of the opcode (0x0f0f) and the opcode suffix, we need to do
	 all the modrm processing first, and don't know until now that
	 we have a bad opcode.  This necessitates some cleaning up.  */
      op1out[0] = '\0';
      op2out[0] = '\0';
      BadOp();
    }
}


static const char *simd_cmp_op [] = {
  "eq",
  "lt",
  "le",
  "unord",
  "neq",
  "nlt",
  "nle",
  "ord"
};

static void
OP_SIMD_Suffix (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
{
  unsigned int cmp_type;

  FETCH_DATA (the_info, codep + 1);
  obufp = obuf + strlen(obuf);
  cmp_type = *codep++ & 0xff;
  if (cmp_type < 8)
    {
      sprintf (scratchbuf, "cmp%s%cs",
	       simd_cmp_op[cmp_type],
	       prefixes & PREFIX_REPZ ? 's' : 'p');
      used_prefixes |= (prefixes & PREFIX_REPZ);
      oappend (scratchbuf);
    }
  else
    {
      /* We have a bad extension byte.  Clean up.  */
      op1out[0] = '\0';
      op2out[0] = '\0';
      BadOp();
    }
}

static void
SIMD_Fixup (extrachar, sizeflag)
     int extrachar;
     int sizeflag ATTRIBUTE_UNUSED;
{
  /* Change movlps/movhps to movhlps/movlhps for 2 register operand
     forms of these instructions.  */
  if (mod == 3)
    {
      char *p = obuf + strlen(obuf);
      *(p+1) = '\0';
      *p     = *(p-1);
      *(p-1) = *(p-2);
      *(p-2) = *(p-3);
      *(p-3) = extrachar;
    }
}

static void BadOp (void)
{
  codep = insn_codep + 1;	/* throw away prefixes and 1st. opcode byte */
  oappend ("(bad)");
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1988, 1989, 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2001
a24 1
 *  x86-64 support added by Jan Hubicka (jh@@suse.cz)
a64 3
/* Set to 1 for 64bit mode disassembly.  */
static int mode_64bit;

a67 20
/* REX prefix the current instruction.  See below.  */
static int rex;
/* Bits of REX we've already used.  */
static int rex_used;
#define REX_MODE64	8
#define REX_EXTX	4
#define REX_EXTY	2
#define REX_EXTZ	1
/* Mark parts used in the REX prefix.  When we are testing for
   empty prefix (for 8bit register REX extension), just mask it
   out.  Otherwise test for REX bit is excuse for existence of REX
   only in case value is nonzero.  */
#define USED_REX(value)					\
  {							\
    if (value)						\
      rex_used |= (rex & value) ? (value) | 0x40 : 0;	\
    else						\
      rex_used |= 0x40;					\
  }

d124 2
a127 1
#define indirEb OP_indirE, b_mode
a132 1
#define Gb OP_G, b_mode
a133 1
#define Gd OP_G, d_mode
a135 1
#define Rm OP_Rd, m_mode
a138 2
#define Iq OP_I, q_mode
#define Iv64 OP_I64, v_mode
d142 2
a143 2
#define Cm OP_C, m_mode
#define Dm OP_D, m_mode
d146 19
a164 48
#define RMeAX OP_REG, eAX_reg
#define RMeBX OP_REG, eBX_reg
#define RMeCX OP_REG, eCX_reg
#define RMeDX OP_REG, eDX_reg
#define RMeSP OP_REG, eSP_reg
#define RMeBP OP_REG, eBP_reg
#define RMeSI OP_REG, eSI_reg
#define RMeDI OP_REG, eDI_reg
#define RMrAX OP_REG, rAX_reg
#define RMrBX OP_REG, rBX_reg
#define RMrCX OP_REG, rCX_reg
#define RMrDX OP_REG, rDX_reg
#define RMrSP OP_REG, rSP_reg
#define RMrBP OP_REG, rBP_reg
#define RMrSI OP_REG, rSI_reg
#define RMrDI OP_REG, rDI_reg
#define RMAL OP_REG, al_reg
#define RMAL OP_REG, al_reg
#define RMCL OP_REG, cl_reg
#define RMDL OP_REG, dl_reg
#define RMBL OP_REG, bl_reg
#define RMAH OP_REG, ah_reg
#define RMCH OP_REG, ch_reg
#define RMDH OP_REG, dh_reg
#define RMBH OP_REG, bh_reg
#define RMAX OP_REG, ax_reg
#define RMDX OP_REG, dx_reg

#define eAX OP_IMREG, eAX_reg
#define eBX OP_IMREG, eBX_reg
#define eCX OP_IMREG, eCX_reg
#define eDX OP_IMREG, eDX_reg
#define eSP OP_IMREG, eSP_reg
#define eBP OP_IMREG, eBP_reg
#define eSI OP_IMREG, eSI_reg
#define eDI OP_IMREG, eDI_reg
#define AL OP_IMREG, al_reg
#define AL OP_IMREG, al_reg
#define CL OP_IMREG, cl_reg
#define DL OP_IMREG, dl_reg
#define BL OP_IMREG, bl_reg
#define AH OP_IMREG, ah_reg
#define CH OP_IMREG, ch_reg
#define DH OP_IMREG, dh_reg
#define BH OP_IMREG, bh_reg
#define AX OP_IMREG, ax_reg
#define DX OP_IMREG, dx_reg
#define indirDX OP_IMREG, indir_dx_reg
a168 1
#define Ob64 OP_OFF64, b_mode
a169 1
#define Ov64 OP_OFF64, v_mode
a187 1
#define XS OP_XS, v_mode
a191 3
#define cond_jump_flag NULL, cond_jump_mode
#define loop_jcxz_flag NULL, loop_jcxz_mode

a203 5
static void OP_I64 PARAMS ((int, int));
static void OP_OFF PARAMS ((int, int));
static void OP_REG PARAMS ((int, int));
static void OP_IMREG PARAMS ((int, int));
static void OP_OFF64 PARAMS ((int, int));
a223 1
static void OP_XS PARAMS ((int, int));
d229 1
a229 1
static void set_op PARAMS ((unsigned int op, int));
d233 1
a233 3
static bfd_vma get64 PARAMS ((void));
static bfd_signed_vma get32 PARAMS ((void));
static bfd_signed_vma get32s PARAMS ((void));
d239 5
a243 9
#define b_mode 1  /* byte operand */
#define v_mode 2  /* operand size depends on prefixes */
#define w_mode 3  /* word operand */
#define d_mode 4  /* double word operand  */
#define q_mode 5  /* quad word operand */
#define x_mode 6
#define m_mode 7  /* d_mode in 32bit, q_mode in 64bit mode.  */
#define cond_jump_mode 8
#define loop_jcxz_mode 9
a278 9
#define rAX_reg 132
#define rCX_reg 133
#define rDX_reg 134
#define rBX_reg 135
#define rSP_reg 136
#define rBP_reg 137
#define rSI_reg 138
#define rDI_reg 139

a322 12
#define PREGRP15 NULL, NULL, 15, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP16 NULL, NULL, 16, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP17 NULL, NULL, 17, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP18 NULL, NULL, 18, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP19 NULL, NULL, 19, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP20 NULL, NULL, 20, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP21 NULL, NULL, 21, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP22 NULL, NULL, 22, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP23 NULL, NULL, 23, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP24 NULL, NULL, 24, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP25 NULL, NULL, 25, NULL, USE_PREFIX_USER_TABLE, NULL, 0
#define PREGRP26 NULL, NULL, 26, NULL, USE_PREFIX_USER_TABLE, NULL, 0
d337 15
a351 608
/* Upper case letters in the instruction names here are macros.
   'A' => print 'b' if no register operands or suffix_always is true
   'B' => print 'b' if suffix_always is true
   'E' => print 'e' if 32-bit form of jcxz
   'F' => print 'w' or 'l' depending on address size prefix (loop insns)
   'L' => print 'l' if suffix_always is true
   'N' => print 'n' if instruction has no wait "prefix"
   'O' => print 'd', or 'o'
   'P' => print 'w', 'l' or 'q' if instruction has an operand size prefix,
                              or suffix_always is true
	  print 'q' if rex prefix is present.
   'I' => print 'q' in 64bit mode and behave as 'P' otherwise
   'Q' => print 'w', 'l' or 'q' if no register operands or suffix_always is true
   'R' => print 'w', 'l' or 'q' ("wd" or "dq" in intel mode)
   'S' => print 'w', 'l' or 'q' if suffix_always is true
   'T' => print 'q' in 64bit mode and behave as 'I' otherwise
   'X' => print 's', 'd' depending on data16 prefix (for XMM)
   'W' => print 'b' or 'w' ("w" or "de" in intel mode)
   'Y' => 'q' if instruction has an REX 64bit overwrite prefix
*/

static const struct dis386 dis386_att[] = {
  /* 00 */
  { "addB",	Eb, Gb, XX },
  { "addS",	Ev, Gv, XX },
  { "addB",	Gb, Eb, XX },
  { "addS",	Gv, Ev, XX },
  { "addB",	AL, Ib, XX },
  { "addS",	eAX, Iv, XX },
  { "pushI",	es, XX, XX },
  { "popI",	es, XX, XX },
  /* 08 */
  { "orB",	Eb, Gb, XX },
  { "orS",	Ev, Gv, XX },
  { "orB",	Gb, Eb, XX },
  { "orS",	Gv, Ev, XX },
  { "orB",	AL, Ib, XX },
  { "orS",	eAX, Iv, XX },
  { "pushI",	cs, XX, XX },
  { "(bad)",	XX, XX, XX },	/* 0x0f extended opcode escape */
  /* 10 */
  { "adcB",	Eb, Gb, XX },
  { "adcS",	Ev, Gv, XX },
  { "adcB",	Gb, Eb, XX },
  { "adcS",	Gv, Ev, XX },
  { "adcB",	AL, Ib, XX },
  { "adcS",	eAX, Iv, XX },
  { "pushI",	ss, XX, XX },
  { "popI",	ss, XX, XX },
  /* 18 */
  { "sbbB",	Eb, Gb, XX },
  { "sbbS",	Ev, Gv, XX },
  { "sbbB",	Gb, Eb, XX },
  { "sbbS",	Gv, Ev, XX },
  { "sbbB",	AL, Ib, XX },
  { "sbbS",	eAX, Iv, XX },
  { "pushI",	ds, XX, XX },
  { "popI",	ds, XX, XX },
  /* 20 */
  { "andB",	Eb, Gb, XX },
  { "andS",	Ev, Gv, XX },
  { "andB",	Gb, Eb, XX },
  { "andS",	Gv, Ev, XX },
  { "andB",	AL, Ib, XX },
  { "andS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG ES prefix */
  { "daa",	XX, XX, XX },
  /* 28 */
  { "subB",	Eb, Gb, XX },
  { "subS",	Ev, Gv, XX },
  { "subB",	Gb, Eb, XX },
  { "subS",	Gv, Ev, XX },
  { "subB",	AL, Ib, XX },
  { "subS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG CS prefix */
  { "das",	XX, XX, XX },
  /* 30 */
  { "xorB",	Eb, Gb, XX },
  { "xorS",	Ev, Gv, XX },
  { "xorB",	Gb, Eb, XX },
  { "xorS",	Gv, Ev, XX },
  { "xorB",	AL, Ib, XX },
  { "xorS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG SS prefix */
  { "aaa",	XX, XX, XX },
  /* 38 */
  { "cmpB",	Eb, Gb, XX },
  { "cmpS",	Ev, Gv, XX },
  { "cmpB",	Gb, Eb, XX },
  { "cmpS",	Gv, Ev, XX },
  { "cmpB",	AL, Ib, XX },
  { "cmpS",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG DS prefix */
  { "aas",	XX, XX, XX },
  /* 40 */
  { "incS",	RMeAX, XX, XX },
  { "incS",	RMeCX, XX, XX },
  { "incS",	RMeDX, XX, XX },
  { "incS",	RMeBX, XX, XX },
  { "incS",	RMeSP, XX, XX },
  { "incS",	RMeBP, XX, XX },
  { "incS",	RMeSI, XX, XX },
  { "incS",	RMeDI, XX, XX },
  /* 48 */
  { "decS",	RMeAX, XX, XX },
  { "decS",	RMeCX, XX, XX },
  { "decS",	RMeDX, XX, XX },
  { "decS",	RMeBX, XX, XX },
  { "decS",	RMeSP, XX, XX },
  { "decS",	RMeBP, XX, XX },
  { "decS",	RMeSI, XX, XX },
  { "decS",	RMeDI, XX, XX },
  /* 50 */
  { "pushS",	RMeAX, XX, XX },
  { "pushS",	RMeCX, XX, XX },
  { "pushS",	RMeDX, XX, XX },
  { "pushS",	RMeBX, XX, XX },
  { "pushS",	RMeSP, XX, XX },
  { "pushS",	RMeBP, XX, XX },
  { "pushS",	RMeSI, XX, XX },
  { "pushS",	RMeDI, XX, XX },
  /* 58 */
  { "popS",	RMeAX, XX, XX },
  { "popS",	RMeCX, XX, XX },
  { "popS",	RMeDX, XX, XX },
  { "popS",	RMeBX, XX, XX },
  { "popS",	RMeSP, XX, XX },
  { "popS",	RMeBP, XX, XX },
  { "popS",	RMeSI, XX, XX },
  { "popS",	RMeDI, XX, XX },
  /* 60 */
  { "pushaP",	XX, XX, XX },
  { "popaP",	XX, XX, XX },
  { "boundS",	Gv, Ma, XX },
  { "arpl",	Ew, Gw, XX },
  { "(bad)",	XX, XX, XX },			/* seg fs */
  { "(bad)",	XX, XX, XX },			/* seg gs */
  { "(bad)",	XX, XX, XX },			/* op size prefix */
  { "(bad)",	XX, XX, XX },			/* adr size prefix */
  /* 68 */
  { "pushI",	Iv, XX, XX },		/* 386 book wrong */
  { "imulS",	Gv, Ev, Iv },
  { "pushI",	sIb, XX, XX },	/* push of byte really pushes 2 or 4 bytes */
  { "imulS",	Gv, Ev, sIb },
  { "insb",	Yb, indirDX, XX },
  { "insR",	Yv, indirDX, XX },
  { "outsb",	indirDX, Xb, XX },
  { "outsR",	indirDX, Xv, XX },
  /* 70 */
  { "jo",	Jb, cond_jump_flag, XX },
  { "jno",	Jb, cond_jump_flag, XX },
  { "jb",	Jb, cond_jump_flag, XX },
  { "jae",	Jb, cond_jump_flag, XX },
  { "je",	Jb, cond_jump_flag, XX },
  { "jne",	Jb, cond_jump_flag, XX },
  { "jbe",	Jb, cond_jump_flag, XX },
  { "ja",	Jb, cond_jump_flag, XX },
  /* 78 */
  { "js",	Jb, cond_jump_flag, XX },
  { "jns",	Jb, cond_jump_flag, XX },
  { "jp",	Jb, cond_jump_flag, XX },
  { "jnp",	Jb, cond_jump_flag, XX },
  { "jl",	Jb, cond_jump_flag, XX },
  { "jge",	Jb, cond_jump_flag, XX },
  { "jle",	Jb, cond_jump_flag, XX },
  { "jg",	Jb, cond_jump_flag, XX },
  /* 80 */
  { GRP1b },
  { GRP1S },
  { "(bad)",	XX, XX, XX },
  { GRP1Ss },
  { "testB",	Eb, Gb, XX },
  { "testS",	Ev, Gv, XX },
  { "xchgB",	Eb, Gb, XX },
  { "xchgS",	Ev, Gv, XX },
  /* 88 */
  { "movB",	Eb, Gb, XX },
  { "movS",	Ev, Gv, XX },
  { "movB",	Gb, Eb, XX },
  { "movS",	Gv, Ev, XX },
  { "movQ",	Ev, Sw, XX },
  { "leaS",	Gv, M, XX },
  { "movQ",	Sw, Ev, XX },
  { "popT",	Ev, XX, XX },
  /* 90 */
  { "nop",	XX, XX, XX },
  /* FIXME: NOP with REPz prefix is called PAUSE.  */
  { "xchgS",	RMeCX, eAX, XX },
  { "xchgS",	RMeDX, eAX, XX },
  { "xchgS",	RMeBX, eAX, XX },
  { "xchgS",	RMeSP, eAX, XX },
  { "xchgS",	RMeBP, eAX, XX },
  { "xchgS",	RMeSI, eAX, XX },
  { "xchgS",	RMeDI, eAX, XX },
  /* 98 */
  { "cWtR",	XX, XX, XX },
  { "cRtO",	XX, XX, XX },
  { "lcallI",	Ap, XX, XX },
  { "(bad)",	XX, XX, XX },		/* fwait */
  { "pushfI",	XX, XX, XX },
  { "popfI",	XX, XX, XX },
  { "sahf",	XX, XX, XX },
  { "lahf",	XX, XX, XX },
  /* a0 */
  { "movB",	AL, Ob, XX },
  { "movS",	eAX, Ov, XX },
  { "movB",	Ob, AL, XX },
  { "movS",	Ov, eAX, XX },
  { "movsb",	Yb, Xb, XX },
  { "movsR",	Yv, Xv, XX },
  { "cmpsb",	Xb, Yb, XX },
  { "cmpsR",	Xv, Yv, XX },
  /* a8 */
  { "testB",	AL, Ib, XX },
  { "testS",	eAX, Iv, XX },
  { "stosB",	Yb, AL, XX },
  { "stosS",	Yv, eAX, XX },
  { "lodsB",	AL, Xb, XX },
  { "lodsS",	eAX, Xv, XX },
  { "scasB",	AL, Yb, XX },
  { "scasS",	eAX, Yv, XX },
  /* b0 */
  { "movB",	RMAL, Ib, XX },
  { "movB",	RMCL, Ib, XX },
  { "movB",	RMDL, Ib, XX },
  { "movB",	RMBL, Ib, XX },
  { "movB",	RMAH, Ib, XX },
  { "movB",	RMCH, Ib, XX },
  { "movB",	RMDH, Ib, XX },
  { "movB",	RMBH, Ib, XX },
  /* b8 */
  { "movS",	RMeAX, Iv, XX },
  { "movS",	RMeCX, Iv, XX },
  { "movS",	RMeDX, Iv, XX },
  { "movS",	RMeBX, Iv, XX },
  { "movS",	RMeSP, Iv, XX },
  { "movS",	RMeBP, Iv, XX },
  { "movS",	RMeSI, Iv, XX },
  { "movS",	RMeDI, Iv, XX },
  /* c0 */
  { GRP2b },
  { GRP2S },
  { "retI",	Iw, XX, XX },
  { "retI",	XX, XX, XX },
  { "lesS",	Gv, Mp, XX },
  { "ldsS",	Gv, Mp, XX },
  { "movA",	Eb, Ib, XX },
  { "movQ",	Ev, Iv, XX },
  /* c8 */
  { "enterI",	Iw, Ib, XX },
  { "leaveI",	XX, XX, XX },
  { "lretP",	Iw, XX, XX },
  { "lretP",	XX, XX, XX },
  { "int3",	XX, XX, XX },
  { "int",	Ib, XX, XX },
  { "into",	XX, XX, XX},
  { "iretP",	XX, XX, XX },
  /* d0 */
  { GRP2b_one },
  { GRP2S_one },
  { GRP2b_cl },
  { GRP2S_cl },
  { "aam",	sIb, XX, XX },
  { "aad",	sIb, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "xlat",	DSBX, XX, XX },
  /* d8 */
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  /* e0 */
  { "loopneF",	Jb, loop_jcxz_flag, XX },
  { "loopeF",	Jb, loop_jcxz_flag, XX },
  { "loopF",	Jb, loop_jcxz_flag, XX },
  { "jEcxz",	Jb, loop_jcxz_flag, XX },
  { "inB",	AL, Ib, XX },
  { "inS",	eAX, Ib, XX },
  { "outB",	Ib, AL, XX },
  { "outS",	Ib, eAX, XX },
  /* e8 */
  { "callI",	Jv, XX, XX },
  { "jmpI",	Jv, XX, XX },
  { "ljmpI",	Ap, XX, XX },
  { "jmp",	Jb, XX, XX },
  { "inB",	AL, indirDX, XX },
  { "inS",	eAX, indirDX, XX },
  { "outB",	indirDX, AL, XX },
  { "outS",	indirDX, eAX, XX },
  /* f0 */
  { "(bad)",	XX, XX, XX },			/* lock prefix */
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },			/* repne */
  { "(bad)",	XX, XX, XX },			/* repz */
  { "hlt",	XX, XX, XX },
  { "cmc",	XX, XX, XX },
  { GRP3b },
  { GRP3S },
  /* f8 */
  { "clc",	XX, XX, XX },
  { "stc",	XX, XX, XX },
  { "cli",	XX, XX, XX },
  { "sti",	XX, XX, XX },
  { "cld",	XX, XX, XX },
  { "std",	XX, XX, XX },
  { GRP4 },
  { GRP5 },
};

static const struct dis386 dis386_intel[] = {
  /* 00 */
  { "add",	Eb, Gb, XX },
  { "add",	Ev, Gv, XX },
  { "add",	Gb, Eb, XX },
  { "add",	Gv, Ev, XX },
  { "add",	AL, Ib, XX },
  { "add",	eAX, Iv, XX },
  { "push",	es, XX, XX },
  { "pop",	es, XX, XX },
  /* 08 */
  { "or",	Eb, Gb, XX },
  { "or",	Ev, Gv, XX },
  { "or",	Gb, Eb, XX },
  { "or",	Gv, Ev, XX },
  { "or",	AL, Ib, XX },
  { "or",	eAX, Iv, XX },
  { "push",	cs, XX, XX },
  { "(bad)",	XX, XX, XX },	/* 0x0f extended opcode escape */
  /* 10 */
  { "adc",	Eb, Gb, XX },
  { "adc",	Ev, Gv, XX },
  { "adc",	Gb, Eb, XX },
  { "adc",	Gv, Ev, XX },
  { "adc",	AL, Ib, XX },
  { "adc",	eAX, Iv, XX },
  { "push",	ss, XX, XX },
  { "pop",	ss, XX, XX },
  /* 18 */
  { "sbb",	Eb, Gb, XX },
  { "sbb",	Ev, Gv, XX },
  { "sbb",	Gb, Eb, XX },
  { "sbb",	Gv, Ev, XX },
  { "sbb",	AL, Ib, XX },
  { "sbb",	eAX, Iv, XX },
  { "push",	ds, XX, XX },
  { "pop",	ds, XX, XX },
  /* 20 */
  { "and",	Eb, Gb, XX },
  { "and",	Ev, Gv, XX },
  { "and",	Gb, Eb, XX },
  { "and",	Gv, Ev, XX },
  { "and",	AL, Ib, XX },
  { "and",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG ES prefix */
  { "daa",	XX, XX, XX },
  /* 28 */
  { "sub",	Eb, Gb, XX },
  { "sub",	Ev, Gv, XX },
  { "sub",	Gb, Eb, XX },
  { "sub",	Gv, Ev, XX },
  { "sub",	AL, Ib, XX },
  { "sub",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG CS prefix */
  { "das",	XX, XX, XX },
  /* 30 */
  { "xor",	Eb, Gb, XX },
  { "xor",	Ev, Gv, XX },
  { "xor",	Gb, Eb, XX },
  { "xor",	Gv, Ev, XX },
  { "xor",	AL, Ib, XX },
  { "xor",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG SS prefix */
  { "aaa",	XX, XX, XX },
  /* 38 */
  { "cmp",	Eb, Gb, XX },
  { "cmp",	Ev, Gv, XX },
  { "cmp",	Gb, Eb, XX },
  { "cmp",	Gv, Ev, XX },
  { "cmp",	AL, Ib, XX },
  { "cmp",	eAX, Iv, XX },
  { "(bad)",	XX, XX, XX },			/* SEG DS prefix */
  { "aas",	XX, XX, XX },
  /* 40 */
  { "inc",	RMeAX, XX, XX },
  { "inc",	RMeCX, XX, XX },
  { "inc",	RMeDX, XX, XX },
  { "inc",	RMeBX, XX, XX },
  { "inc",	RMeSP, XX, XX },
  { "inc",	RMeBP, XX, XX },
  { "inc",	RMeSI, XX, XX },
  { "inc",	RMeDI, XX, XX },
  /* 48 */
  { "dec",	RMeAX, XX, XX },
  { "dec",	RMeCX, XX, XX },
  { "dec",	RMeDX, XX, XX },
  { "dec",	RMeBX, XX, XX },
  { "dec",	RMeSP, XX, XX },
  { "dec",	RMeBP, XX, XX },
  { "dec",	RMeSI, XX, XX },
  { "dec",	RMeDI, XX, XX },
  /* 50 */
  { "push",	RMeAX, XX, XX },
  { "push",	RMeCX, XX, XX },
  { "push",	RMeDX, XX, XX },
  { "push",	RMeBX, XX, XX },
  { "push",	RMeSP, XX, XX },
  { "push",	RMeBP, XX, XX },
  { "push",	RMeSI, XX, XX },
  { "push",	RMeDI, XX, XX },
  /* 58 */
  { "pop",	RMeAX, XX, XX },
  { "pop",	RMeCX, XX, XX },
  { "pop",	RMeDX, XX, XX },
  { "pop",	RMeBX, XX, XX },
  { "pop",	RMeSP, XX, XX },
  { "pop",	RMeBP, XX, XX },
  { "pop",	RMeSI, XX, XX },
  { "pop",	RMeDI, XX, XX },
  /* 60 */
  { "pusha",	XX, XX, XX },
  { "popa",	XX, XX, XX },
  { "bound",	Gv, Ma, XX },
  { "arpl",	Ew, Gw, XX },
  { "(bad)",	XX, XX, XX },			/* seg fs */
  { "(bad)",	XX, XX, XX },			/* seg gs */
  { "(bad)",	XX, XX, XX },			/* op size prefix */
  { "(bad)",	XX, XX, XX },			/* adr size prefix */
  /* 68 */
  { "push",	Iv, XX, XX },		/* 386 book wrong */
  { "imul",	Gv, Ev, Iv },
  { "push",	sIb, XX, XX },	/* push of byte really pushes 2 or 4 bytes */
  { "imul",	Gv, Ev, sIb },
  { "ins",	Yb, indirDX, XX },
  { "ins",	Yv, indirDX, XX },
  { "outs",	indirDX, Xb, XX },
  { "outs",	indirDX, Xv, XX },
  /* 70 */
  { "jo",	Jb, XX, XX },
  { "jno",	Jb, XX, XX },
  { "jb",	Jb, XX, XX },
  { "jae",	Jb, XX, XX },
  { "je",	Jb, XX, XX },
  { "jne",	Jb, XX, XX },
  { "jbe",	Jb, XX, XX },
  { "ja",	Jb, XX, XX },
  /* 78 */
  { "js",	Jb, XX, XX },
  { "jns",	Jb, XX, XX },
  { "jp",	Jb, XX, XX },
  { "jnp",	Jb, XX, XX },
  { "jl",	Jb, XX, XX },
  { "jge",	Jb, XX, XX },
  { "jle",	Jb, XX, XX },
  { "jg",	Jb, XX, XX },
  /* 80 */
  { GRP1b },
  { GRP1S },
  { "(bad)",	XX, XX, XX },
  { GRP1Ss },
  { "test",	Eb, Gb, XX },
  { "test",	Ev, Gv, XX },
  { "xchg",	Eb, Gb, XX },
  { "xchg",	Ev, Gv, XX },
  /* 88 */
  { "mov",	Eb, Gb, XX },
  { "mov",	Ev, Gv, XX },
  { "mov",	Gb, Eb, XX },
  { "mov",	Gv, Ev, XX },
  { "mov",	Ev, Sw, XX },
  { "lea",	Gv, M, XX },
  { "mov",	Sw, Ev, XX },
  { "pop",	Ev, XX, XX },
  /* 90 */
  { "nop",	XX, XX, XX },
  /* FIXME: NOP with REPz prefix is called PAUSE.  */
  { "xchg",	RMeCX, eAX, XX },
  { "xchg",	RMeDX, eAX, XX },
  { "xchg",	RMeBX, eAX, XX },
  { "xchg",	RMeSP, eAX, XX },
  { "xchg",	RMeBP, eAX, XX },
  { "xchg",	RMeSI, eAX, XX },
  { "xchg",	RMeDI, eAX, XX },
  /* 98 */
  { "cW",	XX, XX, XX },		/* cwde and cbw */
  { "cR",	XX, XX, XX },		/* cdq and cwd */
  { "lcall",	Ap, XX, XX },
  { "(bad)",	XX, XX, XX },		/* fwait */
  { "pushf",	XX, XX, XX },
  { "popf",	XX, XX, XX },
  { "sahf",	XX, XX, XX },
  { "lahf",	XX, XX, XX },
  /* a0 */
  { "mov",	AL, Ob, XX },
  { "mov",	eAX, Ov, XX },
  { "mov",	Ob, AL, XX },
  { "mov",	Ov, eAX, XX },
  { "movs",	Yb, Xb, XX },
  { "movs",	Yv, Xv, XX },
  { "cmps",	Xb, Yb, XX },
  { "cmps",	Xv, Yv, XX },
  /* a8 */
  { "test",	AL, Ib, XX },
  { "test",	eAX, Iv, XX },
  { "stos",	Yb, AL, XX },
  { "stos",	Yv, eAX, XX },
  { "lods",	AL, Xb, XX },
  { "lods",	eAX, Xv, XX },
  { "scas",	AL, Yb, XX },
  { "scas",	eAX, Yv, XX },
  /* b0 */
  { "mov",	RMAL, Ib, XX },
  { "mov",	RMCL, Ib, XX },
  { "mov",	RMDL, Ib, XX },
  { "mov",	RMBL, Ib, XX },
  { "mov",	RMAH, Ib, XX },
  { "mov",	RMCH, Ib, XX },
  { "mov",	RMDH, Ib, XX },
  { "mov",	RMBH, Ib, XX },
  /* b8 */
  { "mov",	RMeAX, Iv, XX },
  { "mov",	RMeCX, Iv, XX },
  { "mov",	RMeDX, Iv, XX },
  { "mov",	RMeBX, Iv, XX },
  { "mov",	RMeSP, Iv, XX },
  { "mov",	RMeBP, Iv, XX },
  { "mov",	RMeSI, Iv, XX },
  { "mov",	RMeDI, Iv, XX },
  /* c0 */
  { GRP2b },
  { GRP2S },
  { "ret",	Iw, XX, XX },
  { "ret",	XX, XX, XX },
  { "les",	Gv, Mp, XX },
  { "lds",	Gv, Mp, XX },
  { "mov",	Eb, Ib, XX },
  { "mov",	Ev, Iv, XX },
  /* c8 */
  { "enter",	Iw, Ib, XX },
  { "leave",	XX, XX, XX },
  { "lret",	Iw, XX, XX },
  { "lret",	XX, XX, XX },
  { "int3",	XX, XX, XX },
  { "int",	Ib, XX, XX },
  { "into",	XX, XX, XX },
  { "iret",	XX, XX, XX },
  /* d0 */
  { GRP2b_one },
  { GRP2S_one },
  { GRP2b_cl },
  { GRP2S_cl },
  { "aam",	sIb, XX, XX },
  { "aad",	sIb, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "xlat",	DSBX, XX, XX },
  /* d8 */
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  { FLOAT },
  /* e0 */
  { "loopne",	Jb, XX, XX },
  { "loope",	Jb, XX, XX },
  { "loop",	Jb, XX, XX },
  { "jEcxz",	Jb, XX, XX },
  { "in",	AL, Ib, XX },
  { "in",	eAX, Ib, XX },
  { "out",	Ib, AL, XX },
  { "out",	Ib, eAX, XX },
  /* e8 */
  { "call",	Jv, XX, XX },
  { "jmp",	Jv, XX, XX },
  { "ljmp",	Ap, XX, XX },
  { "jmp",	Jb, XX, XX },
  { "in",	AL, indirDX, XX },
  { "in",	eAX, indirDX, XX },
  { "out",	indirDX, AL, XX },
  { "out",	indirDX, eAX, XX },
  /* f0 */
  { "(bad)",	XX, XX, XX },			/* lock prefix */
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },			/* repne */
  { "(bad)",	XX, XX, XX },			/* repz */
  { "hlt",	XX, XX, XX },
  { "cmc",	XX, XX, XX },
  { GRP3b },
  { GRP3S },
  /* f8 */
  { "clc",	XX, XX, XX },
  { "stc",	XX, XX, XX },
  { "cli",	XX, XX, XX },
  { "sti",	XX, XX, XX },
  { "cld",	XX, XX, XX },
  { "std",	XX, XX, XX },
  { GRP4 },
  { GRP5 },
};

/* 64bit mode is having some instruction set differences, so separate table is
   needed.  */
static const struct dis386 disx86_64_att[] = {
d359 2
a360 2
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d368 1
a368 1
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d377 2
a378 2
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d386 2
a387 2
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d396 1
a396 1
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d405 1
a405 1
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d414 1
a414 1
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d423 1
a423 1
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d425 8
a432 8
  { "(bad)",	XX, XX, XX },			/* REX prefix area.  */
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
d434 8
a441 8
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
d443 8
a450 8
  { "pushI",	RMrAX, XX, XX },
  { "pushI",	RMrCX, XX, XX },
  { "pushI",	RMrDX, XX, XX },
  { "pushI",	RMrBX, XX, XX },
  { "pushI",	RMrSP, XX, XX },
  { "pushI",	RMrBP, XX, XX },
  { "pushI",	RMrSI, XX, XX },
  { "pushI",	RMrDI, XX, XX },
d452 8
a459 8
  { "popI",	RMrAX, XX, XX },
  { "popI",	RMrCX, XX, XX },
  { "popI",	RMrDX, XX, XX },
  { "popI",	RMrBX, XX, XX },
  { "popI",	RMrSP, XX, XX },
  { "popI",	RMrBP, XX, XX },
  { "popI",	RMrSI, XX, XX },
  { "popI",	RMrDI, XX, XX },
d461 4
a464 4
  { "(bad)",	XX, XX, XX },   /* reserved.  */
  { "(bad)",	XX, XX, XX },   /* reserved.  */
  { "(bad)",	XX, XX, XX },   /* reserved.  */
  { "movslR",   Gv, Ed, XX },
d470 1
a470 1
  { "pushI",	Iq, XX, XX },		/* 386 book wrong */
d472 1
a472 1
  { "pushI",	sIb, XX, XX },	/* push of byte really pushes 2 or 4 bytes */
d479 8
a486 8
  { "jo",	Jb, cond_jump_flag, XX },
  { "jno",	Jb, cond_jump_flag, XX },
  { "jb",	Jb, cond_jump_flag, XX },
  { "jae",	Jb, cond_jump_flag, XX },
  { "je",	Jb, cond_jump_flag, XX },
  { "jne",	Jb, cond_jump_flag, XX },
  { "jbe",	Jb, cond_jump_flag, XX },
  { "ja",	Jb, cond_jump_flag, XX },
d488 8
a495 8
  { "js",	Jb, cond_jump_flag, XX },
  { "jns",	Jb, cond_jump_flag, XX },
  { "jp",	Jb, cond_jump_flag, XX },
  { "jnp",	Jb, cond_jump_flag, XX },
  { "jl",	Jb, cond_jump_flag, XX },
  { "jge",	Jb, cond_jump_flag, XX },
  { "jle",	Jb, cond_jump_flag, XX },
  { "jg",	Jb, cond_jump_flag, XX },
d513 1
a513 1
  { "popI",	Ev, XX, XX },
d516 7
a522 8
  /* FIXME: NOP with REPz prefix is called PAUSE.  */
  { "xchgS",	RMeCX, eAX, XX },
  { "xchgS",	RMeDX, eAX, XX },
  { "xchgS",	RMeBX, eAX, XX },
  { "xchgS",	RMeSP, eAX, XX },
  { "xchgS",	RMeBP, eAX, XX },
  { "xchgS",	RMeSI, eAX, XX },
  { "xchgS",	RMeDI, eAX, XX },
d525 2
a526 2
  { "cRtO",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },   /* reserved.  */
d528 4
a531 4
  { "pushfI",	XX, XX, XX },
  { "popfI",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },   /* reserved.  */
  { "(bad)",	XX, XX, XX },   /* reserved.  */
d533 4
a536 4
  { "movB",	AL, Ob64, XX },
  { "movS",	eAX, Ov64, XX },
  { "movB",	Ob64, AL, XX },
  { "movS",	Ov64, eAX, XX },
d551 8
a558 8
  { "movB",	RMAL, Ib, XX },
  { "movB",	RMCL, Ib, XX },
  { "movB",	RMDL, Ib, XX },
  { "movB",	RMBL, Ib, XX },
  { "movB",	RMAH, Ib, XX },
  { "movB",	RMCH, Ib, XX },
  { "movB",	RMDH, Ib, XX },
  { "movB",	RMBH, Ib, XX },
d560 8
a567 8
  { "movS",	RMeAX, Iv64, XX },
  { "movS",	RMeCX, Iv64, XX },
  { "movS",	RMeDX, Iv64, XX },
  { "movS",	RMeBX, Iv64, XX },
  { "movS",	RMeSP, Iv64, XX },
  { "movS",	RMeBP, Iv64, XX },
  { "movS",	RMeSI, Iv64, XX },
  { "movS",	RMeDI, Iv64, XX },
d571 3
a573 3
  { "retI",	Iw, XX, XX },
  { "retI",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },   /* reserved.  */
d578 2
a579 2
  { "enterI",	Iw, Ib, XX },
  { "leaveI",	XX, XX, XX },
d584 1
a584 1
  { "(bad)",	XX, XX, XX },   /* reserved.  */
d591 3
a593 3
  { "(bad)",	XX, XX, XX },   /* reserved.  */
  { "(bad)",	XX, XX, XX },   /* reserved.  */
  { "(bad)",	XX, XX, XX },   /* reserved.  */
d605 4
a608 4
  { "loopneF",	Jb, loop_jcxz_flag, XX },
  { "loopeF",	Jb, loop_jcxz_flag, XX },
  { "loopF",	Jb, loop_jcxz_flag, XX },
  { "jEcxz",	Jb, loop_jcxz_flag, XX },
d614 3
a616 3
  { "callI",	Jv, XX, XX },
  { "jmpI",	Jv, XX, XX },
  { "(bad)",	XX, XX, XX },   /* reserved.  */
d642 1
a642 1
static const struct dis386 dis386_64_intel[] = {
d650 2
a651 2
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d659 1
a659 1
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d668 2
a669 2
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d677 2
a678 2
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d687 1
a687 1
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d696 1
a696 1
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d705 1
a705 1
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d714 1
a714 1
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d716 8
a723 8
  { "(bad)",	XX, XX, XX },			/* REX prefix area.  */
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
d725 8
a732 8
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
  { "(bad)",	XX, XX, XX },
d734 8
a741 8
  { "push",	RMrAX, XX, XX },
  { "push",	RMrCX, XX, XX },
  { "push",	RMrDX, XX, XX },
  { "push",	RMrBX, XX, XX },
  { "push",	RMrSP, XX, XX },
  { "push",	RMrBP, XX, XX },
  { "push",	RMrSI, XX, XX },
  { "push",	RMrDI, XX, XX },
d743 8
a750 8
  { "pop",	RMrAX, XX, XX },
  { "pop",	RMrCX, XX, XX },
  { "pop",	RMrDX, XX, XX },
  { "pop",	RMrBX, XX, XX },
  { "pop",	RMrSP, XX, XX },
  { "pop",	RMrBP, XX, XX },
  { "pop",	RMrSI, XX, XX },
  { "pop",	RMrDI, XX, XX },
d752 4
a755 4
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "movsx",	Gv, Ed, XX },
d761 1
a761 1
  { "push",	Iq, XX, XX },		/* 386 book wrong */
d807 7
a813 8
  /* FIXME: NOP with REPz prefix is called PAUSE.  */
  { "xchg",	RMeCX, eAX, XX },
  { "xchg",	RMeDX, eAX, XX },
  { "xchg",	RMeBX, eAX, XX },
  { "xchg",	RMeSP, eAX, XX },
  { "xchg",	RMeBP, eAX, XX },
  { "xchg",	RMeSI, eAX, XX },
  { "xchg",	RMeDI, eAX, XX },
d817 1
a817 1
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d821 2
a822 2
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d842 8
a849 8
  { "mov",	RMAL, Ib, XX },
  { "mov",	RMCL, Ib, XX },
  { "mov",	RMDL, Ib, XX },
  { "mov",	RMBL, Ib, XX },
  { "mov",	RMAH, Ib, XX },
  { "mov",	RMCH, Ib, XX },
  { "mov",	RMDH, Ib, XX },
  { "mov",	RMBH, Ib, XX },
d851 8
a858 8
  { "mov",	RMeAX, Iv, XX },
  { "mov",	RMeCX, Iv, XX },
  { "mov",	RMeDX, Iv, XX },
  { "mov",	RMeBX, Iv, XX },
  { "mov",	RMeSP, Iv, XX },
  { "mov",	RMeBP, Iv, XX },
  { "mov",	RMeSI, Iv, XX },
  { "mov",	RMeDI, Iv, XX },
d864 1
a864 1
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d875 1
a875 1
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d882 3
a884 3
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d907 1
a907 1
  { "(bad)",	XX, XX, XX },   /* Reserved.  */
d940 1
a940 1
  { "syscall", XX, XX, XX },
d942 1
a942 1
  { "sysretP", XX, XX, XX },
d955 6
a960 6
  { "movlpX", XM, EX, SIMD_Fixup, 'h' },  /* really only 2 operands */
  { "movlpX", EX, XM, SIMD_Fixup, 'h' },
  { "unpcklpX", XM, EX, XX },
  { "unpckhpX", XM, EX, XX },
  { "movhpX", XM, EX, SIMD_Fixup, 'l' },
  { "movhpX", EX, XM, SIMD_Fixup, 'l' },
d972 4
a975 4
  { "movL", Rm, Cm, XX },
  { "movL", Rm, Dm, XX },
  { "movL", Cm, Rm, XX },
  { "movL", Dm, Rm, XX },
d981 2
a982 2
  { "movapX", XM, EX, XX },
  { "movapX", EX, XM, XX },
d984 1
a984 1
  { "movntpX", Ev, XM, XX },
d987 2
a988 2
  { "ucomisX", XM,EX, XX },
  { "comisX", XM,EX, XX },
d1026 1
a1026 1
  { "movmskpX", Gd, XS, XX },
d1030 4
a1033 4
  { "andpX", XM, EX, XX },
  { "andnpX", XM, EX, XX },
  { "orpX", XM, EX, XX },
  { "xorpX", XM, EX, XX },
d1037 2
a1038 2
  { PREGRP17 },
  { PREGRP16 },
d1057 2
a1058 2
  { PREGRP26 },
  { PREGRP24 },
d1060 1
a1060 1
  { PREGRP19 },
d1062 1
a1062 1
  { PREGRP22 },
d1077 2
a1078 2
  { PREGRP23 },
  { PREGRP20 },
d1080 8
a1087 8
  { "jo",  Jv, cond_jump_flag, XX },
  { "jno", Jv, cond_jump_flag, XX },
  { "jb",  Jv, cond_jump_flag, XX },
  { "jae", Jv, cond_jump_flag, XX },
  { "je",  Jv, cond_jump_flag, XX },
  { "jne", Jv, cond_jump_flag, XX },
  { "jbe", Jv, cond_jump_flag, XX },
  { "ja",  Jv, cond_jump_flag, XX },
d1089 8
a1096 8
  { "js",  Jv, cond_jump_flag, XX },
  { "jns", Jv, cond_jump_flag, XX },
  { "jp",  Jv, cond_jump_flag, XX },
  { "jnp", Jv, cond_jump_flag, XX },
  { "jl",  Jv, cond_jump_flag, XX },
  { "jge", Jv, cond_jump_flag, XX },
  { "jle", Jv, cond_jump_flag, XX },
  { "jg",  Jv, cond_jump_flag, XX },
d1116 2
a1117 2
  { "pushI", fs, XX, XX },
  { "popI", fs, XX, XX },
d1125 2
a1126 2
  { "pushI", gs, XX, XX },
  { "popI", gs, XX, XX },
d1155 4
a1158 4
  { "movntiS", Ev, Gv, XX },
  { "pinsrw", MX, Ed, Ib },
  { "pextrw", Gd, MS, Ib },
  { "shufpX", XM, EX, Ib },
d1161 8
a1168 8
  { "bswap", RMeAX, XX, XX },	/* bswap doesn't support 16 bit regs */
  { "bswap", RMeCX, XX, XX },
  { "bswap", RMeDX, XX, XX },
  { "bswap", RMeBX, XX, XX },
  { "bswap", RMeSP, XX, XX },
  { "bswap", RMeBP, XX, XX },
  { "bswap", RMeSI, XX, XX },
  { "bswap", RMeDI, XX, XX },
d1174 1
a1174 1
  { "paddq", MX, EM, XX },
d1176 2
a1177 2
  { PREGRP21 },
  { "pmovmskb", Gd, MS, XX },
d1194 2
a1195 2
  { PREGRP15 },
  { PREGRP25 },
d1210 1
a1210 1
  { "pmuludq", MX, EM, XX },
d1213 1
a1213 1
  { PREGRP18 },
d1218 1
a1218 1
  { "psubq", MX, EM, XX },
d1232 1
a1232 1
  { "syscall", XX, XX, XX },
d1234 1
a1234 1
  { "sysretP", XX, XX, XX },
d1247 6
a1252 6
  { "movlpX", XM, EX, SIMD_Fixup, 'h' },  /* really only 2 operands */
  { "movlpX", EX, XM, SIMD_Fixup, 'h' },
  { "unpcklpX", XM, EX, XX },
  { "unpckhpX", XM, EX, XX },
  { "movhpX", XM, EX, SIMD_Fixup, 'l' },
  { "movhpX", EX, XM, SIMD_Fixup, 'l' },
d1264 4
a1267 4
  { "mov", Rm, Cm, XX },
  { "mov", Rm, Dm, XX },
  { "mov", Cm, Rm, XX },
  { "mov", Dm, Rm, XX },
d1273 2
a1274 2
  { "movapX", XM, EX, XX },
  { "movapX", EX, XM, XX },
d1276 1
a1276 1
  { "movntpX", Ev, XM, XX },
d1279 2
a1280 2
  { "ucomisX", XM,EX, XX },
  { "comisX", XM,EX, XX },
d1318 1
a1318 1
  { "movmskpX", Gd, XS, XX },
d1322 4
a1325 4
  { "andpX", XM, EX, XX },
  { "andnpX", XM, EX, XX },
  { "orpX", XM, EX, XX },
  { "xorpX", XM, EX, XX },
d1329 2
a1330 2
  { PREGRP17 },
  { PREGRP16 },
d1349 2
a1350 2
  { PREGRP26 },
  { PREGRP24 },
d1352 1
a1352 1
  { PREGRP19 },
d1354 1
a1354 1
  { PREGRP22 },
d1369 2
a1370 2
  { PREGRP23 },
  { PREGRP20 },
d1447 4
a1450 4
  { "movnti", Ev, Gv, XX },
  { "pinsrw", MX, Ed, Ib },
  { "pextrw", Gd, MS, Ib },
  { "shufpX", XM, EX, Ib },
d1453 8
a1460 8
  { "bswap", RMeAX, XX, XX },	/* bswap doesn't support 16 bit regs */
  { "bswap", RMeCX, XX, XX },
  { "bswap", RMeDX, XX, XX },
  { "bswap", RMeBX, XX, XX },
  { "bswap", RMeSP, XX, XX },
  { "bswap", RMeBP, XX, XX },
  { "bswap", RMeSI, XX, XX },
  { "bswap", RMeDI, XX, XX },
d1466 1
a1466 1
  { "paddq", MX, EM, XX },
d1468 2
a1469 2
  { PREGRP21 },
  { "pmovmskb", Gd, MS, XX },
d1486 2
a1487 2
  { PREGRP15 },
  { PREGRP25 },
d1502 1
a1502 1
  { "pmuludq", MX, EM, XX },
d1505 1
a1505 1
  { PREGRP18 },
d1510 1
a1510 1
  { "psubq", MX, EM, XX },
d1545 1
a1545 1
  /* 20 */ 1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1, /* 2f */
d1548 2
a1549 2
  /* 50 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 5f */
  /* 60 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 6f */
d1553 1
a1553 1
  /* a0 */ 0,0,0,1,1,1,0,0,0,0,0,1,1,1,1,1, /* af */
d1556 3
a1558 3
  /* d0 */ 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* df */
  /* e0 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ef */
  /* f0 */ 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0  /* ff */
d1563 1
a1563 1
static const unsigned char twobyte_uses_SSE_prefix[256] = {
d1571 3
a1573 3
  /* 50 */ 0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1, /* 5f */
  /* 60 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1, /* 6f */
  /* 70 */ 1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1, /* 7f */
d1579 3
a1581 3
  /* d0 */ 0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0, /* df */
  /* e0 */ 0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0, /* ef */
  /* f0 */ 0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0  /* ff */
a1595 1
static unsigned char need_modrm;
d1598 1
a1598 10
/* If we are accessing mod/rm/reg without need_modrm set, then the
   values are stale.  Hitting this abort likely indicates that you
   need to update onebyte_has_modrm or twobyte_has_modrm.  */
#define MODRM_CHECK  if (!need_modrm) abort ()

static const char *names64[] = {
  "%rax","%rcx","%rdx","%rbx", "%rsp","%rbp","%rsi","%rdi",
  "%r8", "%r9", "%r10", "%r11", "%r12", "%r13", "%r14", "%r15"
};
static const char *names32[] = {
a1599 1
  "%r8d", "%r9d", "%r10d", "%r11d", "%r12d", "%r13d", "%r14d", "%r15d"
a1602 1
  "%r8w", "%r9w", "%r10w", "%r11w", "%r12w", "%r13w", "%r14w", "%r15w"
a1606 4
static const char *names8rex[] = {
  "%al","%cl","%dl","%bl","%spl", "%bpl", "%sil", "%dil",
  "%r8b", "%r9b", "%r10b", "%r11b", "%r12b", "%r13b", "%r14b", "%r15b"
};
d1751 5
a1755 5
    { "callI",	indirEv, XX, XX },
    { "lcallI",	indirEv, XX, XX },
    { "jmpI",	indirEv, XX, XX },
    { "ljmpI",	indirEv, XX, XX },
    { "pushT",	Ev, XX, XX },
d1829 1
a1829 1
    { "psrldq",	MS, Ib, XX },
d1833 1
a1833 1
    { "pslldq",	MS, Ib, XX },
d1842 2
a1843 2
    { "lfence", None, XX, XX },
    { "mfence", None, XX, XX },
a1844 1
    /* FIXME: the sfence with memory operand is clflush! */
d1871 1
a1871 1
static const struct dis386 prefix_user_table[][4] = {
a1875 2
    { "addpd", XM, EX, XX },
    { "addsd", XM, EX, XX },
a1880 2
    { "", XM, EX, OPSIMD },
    { "", XM, EX, OPSIMD },
d1885 1
a1885 3
    { "cvtsi2ssY", XM, Ev, XX },
    { "cvtpi2pd", XM, EM, XX },
    { "cvtsi2sdY", XM, Ev, XX },
d1890 1
a1890 3
    { "cvtss2siY", Gv, EX, XX },
    { "cvtpd2pi", MX, EX, XX },
    { "cvtsd2siY", Gv, EX, XX },
d1895 1
a1895 3
    { "cvttss2siY", Gv, EX, XX },
    { "cvttpd2pi", MX, EX, XX },
    { "cvttsd2siY", Gv, EX, XX },
a1900 2
    { "divpd", XM, EX, XX },
    { "divsd", XM, EX, XX },
a1905 2
    { "maxpd", XM, EX, XX },
    { "maxsd", XM, EX, XX },
a1910 2
    { "minpd", XM, EX, XX },
    { "minsd", XM, EX, XX },
a1915 2
    { "movupd", XM, EX, XX },
    { "movsd", XM, EX, XX },
a1920 2
    { "movupd", EX, XM, XX },
    { "movsd", EX, XM, XX },
a1925 2
    { "mulpd", XM, EX, XX },
    { "mulsd", XM, EX, XX },
a1930 2
    { "(bad)", XM, EX, XX },
    { "(bad)", XM, EX, XX },
a1935 2
    { "(bad)", XM, EX, XX },
    { "(bad)", XM, EX, XX },
a1940 2
    { "sqrtpd", XM, EX, XX },
    { "sqrtsd", XM, EX, XX },
d1946 1
a1946 87
    { "subpd", XM, EX, XX },
    { "subsd", XM, EX, XX },
  },
  /* PREGRP15 */
  {
    { "(bad)", XM, EX, XX },
    { "cvtdq2pd", XM, EX, XX },
    { "cvttpd2dq", XM, EX, XX },
    { "cvtpd2dq", XM, EX, XX },
  },
  /* PREGRP16 */
  {
    { "cvtdq2ps", XM, EX, XX },
    { "cvttps2dq",XM, EX, XX },
    { "cvtps2dq",XM, EX, XX },
    { "(bad)", XM, EX, XX },
  },
  /* PREGRP17 */
  {
    { "cvtps2pd", XM, EX, XX },
    { "cvtss2sd", XM, EX, XX },
    { "cvtpd2ps", XM, EX, XX },
    { "cvtsd2ss", XM, EX, XX },
  },
  /* PREGRP18 */
  {
    { "maskmovq", MX, MS, XX },
    { "(bad)", XM, EX, XX },
    { "maskmovdqu", XM, EX, XX },
    { "(bad)", XM, EX, XX },
  },
  /* PREGRP19 */
  {
    { "movq", MX, EM, XX },
    { "movdqu", XM, EX, XX },
    { "movdqa", XM, EX, XX },
    { "(bad)", XM, EX, XX },
  },
  /* PREGRP20 */
  {
    { "movq", EM, MX, XX },
    { "movdqu", EX, XM, XX },
    { "movdqa", EX, XM, XX },
    { "(bad)", EX, XM, XX },
  },
  /* PREGRP21 */
  {
    { "(bad)", EX, XM, XX },
    { "movq2dq", XM, MS, XX },
    { "movq", EX, XM, XX },
    { "movdq2q", MX, XS, XX },
  },
  /* PREGRP22 */
  {
    { "pshufw", MX, EM, Ib },
    { "pshufhw", XM, EX, Ib },
    { "pshufd", XM, EX, Ib },
    { "pshuflw", XM, EX, Ib },
  },
  /* PREGRP23 */
  {
    { "movd", Ed, MX, XX },
    { "movq", XM, EX, XX },
    { "movd", Ed, XM, XX },
    { "(bad)", Ed, XM, XX },
  },
  /* PREGRP24 */
  {
    { "(bad)", MX, EX, XX },
    { "(bad)", XM, EX, XX },
    { "punpckhqdq", XM, EX, XX },
    { "(bad)", XM, EX, XX },
  },
  /* PREGRP25 */
  {
  { "movntq", Ev, MX, XX },
  { "(bad)", Ev, XM, XX },
  { "movntdq", Ev, XM, XX },
  { "(bad)", Ev, XM, XX },
  },
  /* PREGRP26 */
  {
    { "(bad)", MX, EX, XX },
    { "(bad)", XM, EX, XX },
    { "punpcklqdq", XM, EX, XX },
    { "(bad)", XM, EX, XX },
  },
a1953 2
  int newrex;
  rex = 0;
a1955 1
  rex_used = 0;
a1958 1
      newrex = 0;
a1960 22
	/* REX prefixes family.  */
	case 0x40:
	case 0x41:
	case 0x42:
	case 0x43:
	case 0x44:
	case 0x45:
	case 0x46:
	case 0x47:
	case 0x48:
	case 0x49:
	case 0x4a:
	case 0x4b:
	case 0x4c:
	case 0x4d:
	case 0x4e:
	case 0x4f:
	    if (mode_64bit)
	      newrex = *codep;
	    else
	      return;
	  break;
a2008 7
      /* Rex is ignored when followed by another prefix.  */
      if (rex)
	{
	  oappend (prefix_name (rex, 0));
	  oappend (" ");
	}
      rex = newrex;
a2022 33
    /* REX prefixes family.  */
    case 0x40:
      return "rex";
    case 0x41:
      return "rexZ";
    case 0x42:
      return "rexY";
    case 0x43:
      return "rexYZ";
    case 0x44:
      return "rexX";
    case 0x45:
      return "rexXZ";
    case 0x46:
      return "rexXY";
    case 0x47:
      return "rexXYZ";
    case 0x48:
      return "rex64";
    case 0x49:
      return "rex64Z";
    case 0x4a:
      return "rex64Y";
    case 0x4b:
      return "rex64YZ";
    case 0x4c:
      return "rex64X";
    case 0x4d:
      return "rex64XZ";
    case 0x4e:
      return "rex64XY";
    case 0x4f:
      return "rex64XYZ";
d2055 1
a2055 2
static unsigned int op_riprel[3];
static bfd_vma start_pc;
d2114 2
a2115 1
  unsigned char uses_SSE_prefix;
a2121 3
  mode_64bit = (info->mach == bfd_mach_x86_64_intel_syntax
		|| info->mach == bfd_mach_x86_64);

d2123 1
a2123 3
      || info->mach == bfd_mach_x86_64
      || info->mach == bfd_mach_i386_i386_intel_syntax
      || info->mach == bfd_mach_x86_64_intel_syntax)
a2175 1
  obufp = obuf;
d2183 2
d2207 1
a2207 1
      uses_SSE_prefix = twobyte_uses_SSE_prefix[*codep];
d2212 1
a2212 4
	if (mode_64bit)
	  dp = &dis386_64_intel[*codep];
	else
	  dp = &dis386_intel[*codep];
d2214 1
a2214 4
	if (mode_64bit)
	  dp = &disx86_64_att[*codep];
	else
	  dp = &dis386_att[*codep];
d2216 1
a2216 1
      uses_SSE_prefix = 0;
d2220 1
a2220 1
  if (!uses_SSE_prefix && (prefixes & PREFIX_REPZ))
d2225 1
a2225 1
  if (!uses_SSE_prefix && (prefixes & PREFIX_REPNZ))
d2236 3
d2242 5
a2246 35
      if (dp->bytemode2 != loop_jcxz_mode)
	{
	  if (sizeflag & AFLAG)
	    oappend ("addr32 ");
	  else
	    oappend ("addr16 ");
	  used_prefixes |= PREFIX_ADDR;
	}
    }

  if (!uses_SSE_prefix && (prefixes & PREFIX_DATA))
    {
      sizeflag ^= DFLAG;
      if (dp->bytemode2 == cond_jump_mode && dp->bytemode1 == v_mode)
	{
	  if (sizeflag & DFLAG)
	    oappend ("data32 ");
	  else
	    oappend ("data16 ");
	  used_prefixes |= PREFIX_DATA;
	}
    }

  if (dp->bytemode2 == cond_jump_mode || dp->bytemode2 == loop_jcxz_mode)
    {
      if ((prefixes & (PREFIX_CS | PREFIX_DS)) == PREFIX_CS)
	{
	  oappend ("cs ");
	  used_prefixes |= PREFIX_CS;
	}
      if ((prefixes & (PREFIX_CS | PREFIX_DS)) == PREFIX_DS)
	{
	  oappend ("ds ");
	  used_prefixes |= PREFIX_DS;
	}
a2262 1
      int index;
d2271 1
a2271 1
		index = 0;
a2272 15
		if (prefixes & PREFIX_REPZ)
		  index = 1;
		else
		  {
		    used_prefixes |= (prefixes & PREFIX_DATA);
		    if (prefixes & PREFIX_DATA)
		      index = 2;
		    else
		      {
			used_prefixes |= (prefixes & PREFIX_REPNZ);
			if (prefixes & PREFIX_REPNZ)
			  index = 3;
		      }
		  }
		dp = &prefix_user_table[dp->bytemode1][index];
a2311 8
  if (rex & ~rex_used)
    {
      const char *name;
      name = prefix_name (rex | 0x40, orig_sizeflag);
      if (name == NULL)
	name = INTERNAL_DISASSEMBLER_ERROR;
      (*info->fprintf_func) (info->stream, "%s ", name);
    }
d2339 1
a2339 1
      if (op_index[0] != -1 && !op_riprel[0])
d2349 1
a2349 1
      if (op_index[1] != -1 && !op_riprel[1])
d2359 1
a2359 1
      if (op_index[2] != -1 && !op_riprel[2])
a2363 7
  for (i = 0; i < 3; i++)
    if (op_index[i] != -1 && op_riprel[i])
      {
	(*info->fprintf_func) (info->stream, "        # ");
	(*info->print_address_func) ((bfd_vma) (start_pc + codep - start_codep
						+ op_address[op_index[i]]), info);
      }
d2624 1
a2624 1
    { "ffreep",	STi, XX, XX },
a2707 2
  /* skip mod/rm byte */
  MODRM_CHECK;
a2787 36
	  used_prefixes |= (prefixes & PREFIX_ADDR);
	  break;
	case 'F':
	  if ((prefixes & PREFIX_ADDR)
#ifdef SUFFIX_ALWAYS
	      || (sizeflag & SUFFIX_ALWAYS)
#endif
	      )
	    {
	      if (sizeflag & AFLAG)
		*obufp++ = 'l';
	      else
		*obufp++ = 'w';
	      used_prefixes |= (prefixes & PREFIX_ADDR);
	    }
	  break;
	case 'I':
          if (intel_syntax)
            break;
	  if (mode_64bit)
	    *obufp++ = 'q';
	  else
	    {
	      if ((prefixes & PREFIX_DATA)
#ifdef SUFFIX_ALWAYS
		  || (sizeflag & SUFFIX_ALWAYS)
#endif
		  )
		{
		  if (sizeflag & DFLAG)
		    *obufp++ = 'l';
		  else
		    *obufp++ = 'w';
		  used_prefixes |= (prefixes & PREFIX_DATA);
	      }
	    }
a2802 7
	case 'O':
	  USED_REX (REX_MODE64);
	  if (rex & REX_MODE64)
	      *obufp++ = 'o';
	  else
	    *obufp++ = 'd';
	  break;
a2806 1
	      || (rex & REX_MODE64)
d2812 2
a2813 3
	      USED_REX (REX_MODE64);
	      if (rex & REX_MODE64)
		*obufp++ = 'q';
d2815 2
a2816 7
		{
		   if (sizeflag & DFLAG)
		      *obufp++ = 'l';
		   else
		     *obufp++ = 'w';
		   used_prefixes |= (prefixes & PREFIX_DATA);
		}
a2821 1
	  USED_REX (REX_MODE64);
d2828 2
a2829 2
	      if (rex & REX_MODE64)
		*obufp++ = 'q';
d2831 2
a2832 7
		{
		  if (sizeflag & DFLAG)
		    *obufp++ = 'l';
		  else
		    *obufp++ = 'w';
		  used_prefixes |= (prefixes & PREFIX_DATA);
		}
a2835 1
	  USED_REX (REX_MODE64);
d2838 1
a2838 6
	      if (rex & REX_MODE64)
		{
		  *obufp++ = 'q';
		  *obufp++ = 't';
		}
	      else if (sizeflag & DFLAG)
d2851 1
a2851 3
	      if (rex & REX_MODE64)
		*obufp++ = 'q';
	      else if (sizeflag & DFLAG)
d2856 1
a2856 2
	  if (!(rex & REX_MODE64))
	    used_prefixes |= (prefixes & PREFIX_DATA);
a2863 24
	      if (rex & REX_MODE64)
		*obufp++ = 'q';
	      else
		{
		  if (sizeflag & DFLAG)
		    *obufp++ = 'l';
		  else
		    *obufp++ = 'w';
		  used_prefixes |= (prefixes & PREFIX_DATA);
		}
	    }
#endif
	  break;
	case 'T':
          if (intel_syntax)
            break;
	  if (mode_64bit)
	    *obufp++ = 'q';
	  else if (mod != 3
#ifdef SUFFIX_ALWAYS
		   || (sizeflag & SUFFIX_ALWAYS)
#endif
		  )
	    {
d2870 1
a2871 17
	case 'X':
	  if (prefixes & PREFIX_DATA)
	    *obufp++ = 'd';
	  else
	    *obufp++ = 's';
          used_prefixes |= (prefixes & PREFIX_DATA);
	  break;
	case 'Y':
          if (intel_syntax)
            break;
	  if (rex & REX_MODE64)
	    {
	      USED_REX (REX_MODE64);
	      *obufp++ = 'q';
	    }
	  break;
	  /* implicit operand size 'l' for i386 or 'q' for x86-64 */
d2874 1
a2874 4
	  USED_REX (0);
	  if (rex)
	    *obufp++ = 'l';
	  else if (sizeflag & DFLAG)
a2879 5
	      if (rex)
		{
		  *obufp++ = 'q';
		  *obufp++ = 'e';
		}
d2890 1
a2890 2
	  if (!rex)
	    used_prefixes |= (prefixes & PREFIX_DATA);
a2950 60
print_operand_value (buf, hex, disp)
  char *buf;
  int hex;
  bfd_vma disp;
{
  if (mode_64bit)
    {
      if (hex)
	{
	  char tmp[30];
	  int i;
	  buf[0] = '0';
	  buf[1] = 'x';
	  sprintf_vma (tmp, disp);
	  for (i = 0; tmp[i] == '0' && tmp[i+1]; i++);
	  strcpy (buf + 2, tmp + i);
	}
      else
	{
	  bfd_signed_vma v = disp;
	  char tmp[30];
	  int i;
	  if (v < 0)
	    {
	      *(buf++) = '-';
	      v = -disp;
	      /* Check for possible overflow on 0x8000000000000000 */
	      if (v < 0)
		{
		  strcpy (buf, "9223372036854775808");
		  return;
		}
	    }
	  if (!v)
	    {
	      strcpy (buf, "0");
	      return;
	    }

	  i = 0;
	  tmp[29] = 0;
	  while (v)
	    {
	      tmp[28-i] = (v % 10) + '0';
	      v /= 10;
	      i++;
	    }
	  strcpy (buf, tmp + 29 - i);
	}
    }
  else
    {
      if (hex)
	sprintf (buf, "0x%x", (unsigned int) disp);
      else
	sprintf (buf, "%d", (int) disp);
    }
}

static void
d2955 1
a2955 6
  bfd_vma disp;
  int add = 0;
  int riprel = 0;
  USED_REX (REX_EXTZ);
  if (rex & REX_EXTZ)
    add += 8;
a2957 1
  MODRM_CHECK;
d2965 1
a2965 5
	  USED_REX (0);
	  if (rex)
	    oappend (names8rex[rm + add]);
	  else
	    oappend (names8[rm + add]);
d2968 1
a2968 1
	  oappend (names16[rm + add]);
d2971 1
a2971 10
	  oappend (names32[rm + add]);
	  break;
	case q_mode:
	  oappend (names64[rm + add]);
	  break;
	case m_mode:
	  if (mode_64bit)
	    oappend (names64[rm + add]);
	  else
	    oappend (names32[rm + add]);
d2974 2
a2975 5
	  USED_REX (REX_MODE64);
	  if (rex & REX_MODE64)
	    oappend (names64[rm + add]);
	  else if (sizeflag & DFLAG)
	    oappend (names32[rm + add]);
d2977 1
a2977 1
	    oappend (names16[rm + add]);
d2981 1
a2981 3
	  if ( !(codep[-2] == 0xAE && codep[-1] == 0xF8 /* sfence */)
	      && !(codep[-2] == 0xAE && codep[-1] == 0xF0 /* mfence */)
	      && !(codep[-2] == 0xAE && codep[-1] == 0xe8 /* lfence */))
a3012 6
	  USED_REX (REX_EXTY);
	  USED_REX (REX_EXTZ);
	  if (rex & REX_EXTY)
	    index += 8;
	  if (rex & REX_EXTZ)
	    base += 8;
d3019 1
a3019 1
	  if ((base & 7) == 5)
d3022 1
a3022 3
	      if (mode_64bit && !havesib)
		riprel = 1;
	      disp = get32s ();
d3032 1
a3032 1
	  disp = get32s ();
d3037 1
a3037 1
        if (mod != 0 || (base & 7) == 5)
d3039 1
a3039 1
	    print_operand_value (scratchbuf, !riprel, disp);
a3040 5
	    if (riprel)
	      {
		set_op (disp, 1);
		oappend ("(%rip)");
	      }
d3050 1
a3050 1
                  oappend ("BYTE PTR ");
d3053 1
a3053 1
                  oappend ("WORD PTR ");
d3056 1
a3056 1
                  oappend ("DWORD PTR ");
d3059 1
a3059 1
                  oappend ("QWORD PTR ");
a3060 6
                case m_mode:
		  if (mode_64bit)
		    oappend ("DWORD PTR ");
		  else
		    oappend ("QWORD PTR ");
		  break;
d3062 1
a3062 1
                  oappend ("XWORD PTR ");
a3068 2
	  if (intel_syntax && riprel)
	    oappend ("rip + ");
a3069 3
	  USED_REX (REX_EXTZ);
	  if (!havesib && (rex & REX_EXTZ))
	    base += 8;
d3071 1
a3071 1
	    oappend (mode_64bit ? names64[base] : names32[base]);
d3083 1
a3083 1
                      sprintf (scratchbuf, "%s", mode_64bit ? names64[index] : names32[index]);
d3086 1
a3086 1
		    sprintf (scratchbuf, ",%s", mode_64bit ? names64[index] : names32[index]);
d3102 1
a3102 1
            if (mod != 0 || (base & 7) == 5)
d3105 1
a3105 1
                if (disp != 0)
d3107 6
a3112 1
		    print_operand_value (scratchbuf, 0, disp);
d3122 1
a3122 1
          if (mod != 0 || (base & 7) == 5)
d3132 1
a3132 1
	      print_operand_value (scratchbuf, 1, disp);
d3142 1
a3142 1
	  if ((rm & 7) == 6)
d3163 1
a3163 1
        if (mod != 0 || (rm & 7) == 6)
d3165 1
a3165 1
	    print_operand_value (scratchbuf, 0, disp);
d3169 1
a3169 1
      if (mod != 0 || (rm & 7) != 6)
d3173 1
a3173 1
	  oappend (index16[rm + add]);
a3184 4
  int add = 0;
  USED_REX (REX_EXTX);
  if (rex & REX_EXTX)
    add += 8;
d3188 1
a3188 5
      USED_REX (0);
      if (rex)
	oappend (names8rex[reg + add]);
      else
	oappend (names8[reg + add]);
d3191 1
a3191 1
      oappend (names16[reg + add]);
d3194 1
a3194 4
      oappend (names32[reg + add]);
      break;
    case q_mode:
      oappend (names64[reg + add]);
d3197 2
a3198 5
      USED_REX (REX_MODE64);
      if (rex & REX_MODE64)
	oappend (names64[reg + add]);
      else if (sizeflag & DFLAG)
	oappend (names32[reg + add]);
d3200 1
a3200 1
	oappend (names16[reg + add]);
d3209 1
a3209 25
static bfd_vma
get64 ()
{
  unsigned int a = 0;
  unsigned int b = 0;
  bfd_vma x = 0;

#ifdef BFD64
  FETCH_DATA (the_info, codep + 8);
  a = *codep++ & 0xff;
  a |= (*codep++ & 0xff) << 8;
  a |= (*codep++ & 0xff) << 16;
  a |= (*codep++ & 0xff) << 24;
  b |= (*codep++ & 0xff);
  b |= (*codep++ & 0xff) << 8;
  b |= (*codep++ & 0xff) << 16;
  b |= (*codep++ & 0xff) << 24;
  x = a + ((bfd_vma) b << 32);
#else
  abort();
#endif
  return x;
}

static bfd_signed_vma
d3212 1
a3212 1
  bfd_signed_vma x = 0;
d3215 4
a3218 20
  x = *codep++ & (bfd_signed_vma) 0xff;
  x |= (*codep++ & (bfd_signed_vma) 0xff) << 8;
  x |= (*codep++ & (bfd_signed_vma) 0xff) << 16;
  x |= (*codep++ & (bfd_signed_vma) 0xff) << 24;
  return x;
}

static bfd_signed_vma
get32s ()
{
  bfd_signed_vma x = 0;

  FETCH_DATA (the_info, codep + 4);
  x = *codep++ & (bfd_signed_vma) 0xff;
  x |= (*codep++ & (bfd_signed_vma) 0xff) << 8;
  x |= (*codep++ & (bfd_signed_vma) 0xff) << 16;
  x |= (*codep++ & (bfd_signed_vma) 0xff) << 24;

  x = (x ^ ((bfd_signed_vma) 1 << 31)) - ((bfd_signed_vma) 1 << 31);

d3234 1
a3234 1
set_op (op, riprel)
a3235 1
     int riprel;
a3238 1
  op_riprel[op_ad] = riprel;
a3246 54
  int add = 0;
  USED_REX (REX_EXTZ);
  if (rex & REX_EXTZ)
    add = 8;

  switch (code)
    {
    case indir_dx_reg:
      s = "(%dx)";
      break;
    case ax_reg: case cx_reg: case dx_reg: case bx_reg:
    case sp_reg: case bp_reg: case si_reg: case di_reg:
      s = names16[code - ax_reg + add];
      break;
    case es_reg: case ss_reg: case cs_reg:
    case ds_reg: case fs_reg: case gs_reg:
      s = names_seg[code - es_reg + add];
      break;
    case al_reg: case ah_reg: case cl_reg: case ch_reg:
    case dl_reg: case dh_reg: case bl_reg: case bh_reg:
      USED_REX (0);
      if (rex)
	s = names8rex[code - al_reg + add];
      else
	s = names8[code - al_reg];
      break;
    case eAX_reg: case eCX_reg: case eDX_reg: case eBX_reg:
    case eSP_reg: case eBP_reg: case eSI_reg: case eDI_reg:
      USED_REX (REX_MODE64);
      if (rex & REX_MODE64)
	s = names64[code - eAX_reg + add];
      else if (sizeflag & DFLAG)
	s = names32[code - eAX_reg + add];
      else
	s = names16[code - eAX_reg + add];
      used_prefixes |= (prefixes & PREFIX_DATA);
      break;
    case rAX_reg: case rCX_reg: case rDX_reg: case rBX_reg:
    case rSP_reg: case rBP_reg: case rSI_reg: case rDI_reg:
      s = names64[code - rAX_reg + add];
      break;
    default:
      s = INTERNAL_DISASSEMBLER_ERROR;
      break;
    }
  oappend (s);
}

static void
OP_IMREG (code, sizeflag)
     int code;
     int sizeflag;
{
  const char *s;
d3263 1
a3263 5
      USED_REX (0);
      if (rex)
	s = names8rex[code - al_reg];
      else
	s = names8[code - al_reg];
d3267 1
a3267 4
      USED_REX (REX_MODE64);
      if (rex & REX_MODE64)
	s = names64[code - eAX_reg];
      else if (sizeflag & DFLAG)
d3285 1
a3285 2
  bfd_signed_vma op;
  bfd_signed_vma mask = -1;
d3291 1
a3291 5
      op = *codep++;
      mask = 0xff;
      break;
    case q_mode:
      op = get32s ();
d3294 2
a3295 8
      USED_REX (REX_MODE64);
      if (rex & REX_MODE64)
	op = get32s ();
      else if (sizeflag & DFLAG)
	{
	  op = get32 ();
	  mask = 0xffffffff;
	}
d3297 1
a3297 4
	{
	  op = get16 ();
	  mask = 0xfffff;
	}
a3300 1
      mask = 0xfffff;
d3308 4
a3311 50
  op &= mask;
  scratchbuf[0] = '$';
  print_operand_value (scratchbuf + !intel_syntax, 1, op);
  oappend (scratchbuf);
  scratchbuf[0] = '\0';
}

static void
OP_I64 (bytemode, sizeflag)
     int bytemode;
     int sizeflag;
{
  bfd_signed_vma op;
  bfd_signed_vma mask = -1;

  switch (bytemode)
    {
    case b_mode:
      FETCH_DATA (the_info, codep + 1);
      op = *codep++;
      mask = 0xff;
      break;
    case v_mode:
      USED_REX (REX_MODE64);
      if (rex & REX_MODE64)
	op = get64 ();
      else if (sizeflag & DFLAG)
	{
	  op = get32 ();
	  mask = 0xffffffff;
	}
      else
	{
	  op = get16 ();
	  mask = 0xfffff;
	}
      used_prefixes |= (prefixes & PREFIX_DATA);
      break;
    case w_mode:
      mask = 0xfffff;
      op = get16 ();
      break;
    default:
      oappend (INTERNAL_DISASSEMBLER_ERROR);
      return;
    }

  op &= mask;
  scratchbuf[0] = '$';
  print_operand_value (scratchbuf + !intel_syntax, 1, op);
d3321 1
a3321 2
  bfd_signed_vma op;
  bfd_signed_vma mask = -1;
a3329 1
      mask = 0xffffffff;
d3332 2
a3333 8
      USED_REX (REX_MODE64);
      if (rex & REX_MODE64)
	op = get32s ();
      else if (sizeflag & DFLAG)
	{
	  op = get32s ();
	  mask = 0xffffffff;
	}
a3335 1
	  mask = 0xffffffff;
a3343 1
      mask = 0xffffffff;
d3351 4
a3354 3

  scratchbuf[0] = '$';
  print_operand_value (scratchbuf + 1, 1, op);
d3363 1
a3363 1
  bfd_vma disp;
d3376 1
a3376 1
	disp = get32s ();
d3385 1
d3392 2
a3393 2
  set_op (disp, 0);
  print_operand_value (scratchbuf, 1, disp);
d3435 2
a3436 2
OP_OFF (ignored, sizeflag)
     int ignored ATTRIBUTE_UNUSED;
d3439 1
a3439 1
  bfd_vma off;
d3457 1
a3457 25
  print_operand_value (scratchbuf, 1, off);
  oappend (scratchbuf);
}
/* ARGSUSED */
static void
OP_OFF64 (ignored, sizeflag)
     int ignored ATTRIBUTE_UNUSED;
     int sizeflag ATTRIBUTE_UNUSED;
{
  bfd_vma off;

  append_seg ();

  off = get64();

  if (intel_syntax)
    {
      if (!(prefixes & (PREFIX_CS | PREFIX_SS | PREFIX_DS
		        | PREFIX_ES | PREFIX_FS | PREFIX_GS)))
	{
	  oappend (names_seg[3]);
	  oappend (":");
	}
    }
  print_operand_value (scratchbuf, 1, off);
d3468 1
a3468 4
  USED_REX (REX_MODE64);
  if (rex & REX_MODE64)
    s = names64[code - eAX_reg];
  else if (sizeflag & AFLAG)
d3508 1
a3508 5
  int add = 0;
  USED_REX (REX_EXTX);
  if (rex & REX_EXTX)
    add = 8;
  sprintf (scratchbuf, "%%cr%d", reg+add);
d3518 1
a3518 5
  int add = 0;
  USED_REX (REX_EXTX);
  if (rex & REX_EXTX)
    add = 8;
  sprintf (scratchbuf, "%%db%d", reg+add);
d3548 1
a3548 9
  int add = 0;
  USED_REX (REX_EXTX);
  if (rex & REX_EXTX)
    add = 8;
  used_prefixes |= (prefixes & PREFIX_DATA);
  if (prefixes & PREFIX_DATA)
    sprintf (scratchbuf, "%%xmm%d", reg + add);
  else
    sprintf (scratchbuf, "%%mm%d", reg + add);
d3557 1
a3557 5
  int add = 0;
  USED_REX (REX_EXTX);
  if (rex & REX_EXTX)
    add = 8;
  sprintf (scratchbuf, "%%xmm%d", reg + add);
a3565 1
  int add = 0;
a3570 3
  USED_REX (REX_EXTZ);
  if (rex & REX_EXTZ)
    add = 8;
a3571 2
  /* skip mod/rm byte */
  MODRM_CHECK;
d3573 1
a3573 5
  used_prefixes |= (prefixes & PREFIX_DATA);
  if (prefixes & PREFIX_DATA)
    sprintf (scratchbuf, "%%xmm%d", rm + add);
  else
    sprintf (scratchbuf, "%%mm%d", rm + add);
a3581 1
  int add = 0;
a3586 3
  USED_REX (REX_EXTZ);
  if (rex & REX_EXTZ)
    add = 8;
a3587 2
  /* skip mod/rm byte */
  MODRM_CHECK;
d3589 1
a3589 1
  sprintf (scratchbuf, "%%xmm%d", rm + add);
a3603 11
static void
OP_XS (bytemode, sizeflag)
     int bytemode;
     int sizeflag;
{
  if (mod == 3)
    OP_EX (bytemode, sizeflag);
  else
    BadOp();
}

d3722 3
a3724 18
      char suffix1 = 'p', suffix2 = 's';
      used_prefixes |= (prefixes & PREFIX_REPZ);
      if (prefixes & PREFIX_REPZ)
	suffix1 = 's';
      else
	{
	  used_prefixes |= (prefixes & PREFIX_DATA);
	  if (prefixes & PREFIX_DATA)
	    suffix2 = 'd';
	  else
	    {
	      used_prefixes |= (prefixes & PREFIX_REPNZ);
	      if (prefixes & PREFIX_REPNZ)
		suffix1 = 's', suffix2 = 'd';
	    }
	}
      sprintf (scratchbuf, "cmp%s%c%c",
	       simd_cmp_op[cmp_type], suffix1, suffix2);
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 2
a4 1
   2001, 2002, 2003 Free Software Foundation, Inc.
a52 45
static void ckprefix PARAMS ((void));
static const char *prefix_name PARAMS ((int, int));
static int print_insn PARAMS ((bfd_vma, disassemble_info *));
static void dofloat PARAMS ((int));
static void OP_ST PARAMS ((int, int));
static void OP_STi  PARAMS ((int, int));
static int putop PARAMS ((const char *, int));
static void oappend PARAMS ((const char *));
static void append_seg PARAMS ((void));
static void OP_indirE PARAMS ((int, int));
static void print_operand_value PARAMS ((char *, int, bfd_vma));
static void OP_E PARAMS ((int, int));
static void OP_G PARAMS ((int, int));
static bfd_vma get64 PARAMS ((void));
static bfd_signed_vma get32 PARAMS ((void));
static bfd_signed_vma get32s PARAMS ((void));
static int get16 PARAMS ((void));
static void set_op PARAMS ((bfd_vma, int));
static void OP_REG PARAMS ((int, int));
static void OP_IMREG PARAMS ((int, int));
static void OP_I PARAMS ((int, int));
static void OP_I64 PARAMS ((int, int));
static void OP_sI PARAMS ((int, int));
static void OP_J PARAMS ((int, int));
static void OP_SEG PARAMS ((int, int));
static void OP_DIR PARAMS ((int, int));
static void OP_OFF PARAMS ((int, int));
static void OP_OFF64 PARAMS ((int, int));
static void ptr_reg PARAMS ((int, int));
static void OP_ESreg PARAMS ((int, int));
static void OP_DSreg PARAMS ((int, int));
static void OP_C PARAMS ((int, int));
static void OP_D PARAMS ((int, int));
static void OP_T PARAMS ((int, int));
static void OP_Rd PARAMS ((int, int));
static void OP_MMX PARAMS ((int, int));
static void OP_XMM PARAMS ((int, int));
static void OP_EM PARAMS ((int, int));
static void OP_EX PARAMS ((int, int));
static void OP_MS PARAMS ((int, int));
static void OP_XS PARAMS ((int, int));
static void OP_3DNowSuffix PARAMS ((int, int));
static void OP_SIMD_Suffix PARAMS ((int, int));
static void SIMD_Fixup PARAMS ((int, int));
static void BadOp PARAMS ((void));
d54 2
a55 1
struct dis_private {
a59 1
  int orig_sizeflag;
d115 1
a115 1
  ((addr) <= ((struct dis_private *) (info->private_data))->max_fetched \
d124 1
a124 1
  struct dis_private *priv = (struct dis_private *) info->private_data;
d134 3
a136 3
	 print_insn_i386 will do something sensible.  Otherwise, print
	 an error.  We do that here because this is where we know
	 STATUS.  */
a150 1
#define Edq OP_E, dq_mode
d155 1
a155 1
#define M OP_E, 0		/* lea, lgdt, etc. */
d257 1
d259 1
d263 48
a319 1
#define dq_mode 10 /* operand size depends on REX prefixes.  */
d366 2
a367 58
#define FLOATCODE 1
#define USE_GROUPS 2
#define USE_PREFIX_USER_TABLE 3
#define X86_64_SPECIAL 4

#define FLOAT	  NULL, NULL, FLOATCODE, NULL, 0, NULL, 0

#define GRP1b	  NULL, NULL, USE_GROUPS, NULL,  0, NULL, 0
#define GRP1S	  NULL, NULL, USE_GROUPS, NULL,  1, NULL, 0
#define GRP1Ss	  NULL, NULL, USE_GROUPS, NULL,  2, NULL, 0
#define GRP2b	  NULL, NULL, USE_GROUPS, NULL,  3, NULL, 0
#define GRP2S	  NULL, NULL, USE_GROUPS, NULL,  4, NULL, 0
#define GRP2b_one NULL, NULL, USE_GROUPS, NULL,  5, NULL, 0
#define GRP2S_one NULL, NULL, USE_GROUPS, NULL,  6, NULL, 0
#define GRP2b_cl  NULL, NULL, USE_GROUPS, NULL,  7, NULL, 0
#define GRP2S_cl  NULL, NULL, USE_GROUPS, NULL,  8, NULL, 0
#define GRP3b	  NULL, NULL, USE_GROUPS, NULL,  9, NULL, 0
#define GRP3S	  NULL, NULL, USE_GROUPS, NULL, 10, NULL, 0
#define GRP4	  NULL, NULL, USE_GROUPS, NULL, 11, NULL, 0
#define GRP5	  NULL, NULL, USE_GROUPS, NULL, 12, NULL, 0
#define GRP6	  NULL, NULL, USE_GROUPS, NULL, 13, NULL, 0
#define GRP7	  NULL, NULL, USE_GROUPS, NULL, 14, NULL, 0
#define GRP8	  NULL, NULL, USE_GROUPS, NULL, 15, NULL, 0
#define GRP9	  NULL, NULL, USE_GROUPS, NULL, 16, NULL, 0
#define GRP10	  NULL, NULL, USE_GROUPS, NULL, 17, NULL, 0
#define GRP11	  NULL, NULL, USE_GROUPS, NULL, 18, NULL, 0
#define GRP12	  NULL, NULL, USE_GROUPS, NULL, 19, NULL, 0
#define GRP13	  NULL, NULL, USE_GROUPS, NULL, 20, NULL, 0
#define GRP14	  NULL, NULL, USE_GROUPS, NULL, 21, NULL, 0
#define GRPAMD	  NULL, NULL, USE_GROUPS, NULL, 22, NULL, 0

#define PREGRP0   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  0, NULL, 0
#define PREGRP1   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  1, NULL, 0
#define PREGRP2   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  2, NULL, 0
#define PREGRP3   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  3, NULL, 0
#define PREGRP4   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  4, NULL, 0
#define PREGRP5   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  5, NULL, 0
#define PREGRP6   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  6, NULL, 0
#define PREGRP7   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  7, NULL, 0
#define PREGRP8   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  8, NULL, 0
#define PREGRP9   NULL, NULL, USE_PREFIX_USER_TABLE, NULL,  9, NULL, 0
#define PREGRP10  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 10, NULL, 0
#define PREGRP11  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 11, NULL, 0
#define PREGRP12  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 12, NULL, 0
#define PREGRP13  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 13, NULL, 0
#define PREGRP14  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 14, NULL, 0
#define PREGRP15  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 15, NULL, 0
#define PREGRP16  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 16, NULL, 0
#define PREGRP17  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 17, NULL, 0
#define PREGRP18  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 18, NULL, 0
#define PREGRP19  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 19, NULL, 0
#define PREGRP20  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 20, NULL, 0
#define PREGRP21  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 21, NULL, 0
#define PREGRP22  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 22, NULL, 0
#define PREGRP23  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 23, NULL, 0
#define PREGRP24  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 24, NULL, 0
#define PREGRP25  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 25, NULL, 0
#define PREGRP26  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 26, NULL, 0
d369 51
a419 1
#define X86_64_0  NULL, NULL, X86_64_SPECIAL, NULL,  0, NULL, 0
d421 2
a422 1
typedef void (*op_rtn) PARAMS ((int bytemode, int sizeflag));
a438 1
   'H' => print ",pt" or ",pn" branch hint
d443 4
a446 3
   .      or suffix_always is true.  print 'q' if rex prefix is present.
   'Q' => print 'w', 'l' or 'q' if no register operands or suffix_always
   .      is true
d449 1
a449 2
   'T' => print 'q' in 64bit mode and behave as 'P' otherwise
   'U' => print 'q' in 64bit mode and behave as 'Q' otherwise
d453 1
d455 291
a745 2
   Many of the above letters print nothing in Intel mode.  See "putop"
   for the details.
d747 585
a1331 5
   Braces '{' and '}', and vertical bars '|', indicate alternative
   mnemonic strings for AT&T, Intel, X86_64 AT&T, and X86_64 Intel
   modes.  In cases where there are only two alternatives, the X86_64
   instruction is reserved, and "(bad)" is printed.
*/
d1333 1
a1333 1
static const struct dis386 dis386[] = {
d1335 8
a1342 8
  { "addB",		Eb, Gb, XX },
  { "addS",		Ev, Gv, XX },
  { "addB",		Gb, Eb, XX },
  { "addS",		Gv, Ev, XX },
  { "addB",		AL, Ib, XX },
  { "addS",		eAX, Iv, XX },
  { "push{T|}",		es, XX, XX },
  { "pop{T|}",		es, XX, XX },
d1344 8
a1351 8
  { "orB",		Eb, Gb, XX },
  { "orS",		Ev, Gv, XX },
  { "orB",		Gb, Eb, XX },
  { "orS",		Gv, Ev, XX },
  { "orB",		AL, Ib, XX },
  { "orS",		eAX, Iv, XX },
  { "push{T|}",		cs, XX, XX },
  { "(bad)",		XX, XX, XX },	/* 0x0f extended opcode escape */
d1353 8
a1360 8
  { "adcB",		Eb, Gb, XX },
  { "adcS",		Ev, Gv, XX },
  { "adcB",		Gb, Eb, XX },
  { "adcS",		Gv, Ev, XX },
  { "adcB",		AL, Ib, XX },
  { "adcS",		eAX, Iv, XX },
  { "push{T|}",		ss, XX, XX },
  { "popT|}",		ss, XX, XX },
d1362 8
a1369 8
  { "sbbB",		Eb, Gb, XX },
  { "sbbS",		Ev, Gv, XX },
  { "sbbB",		Gb, Eb, XX },
  { "sbbS",		Gv, Ev, XX },
  { "sbbB",		AL, Ib, XX },
  { "sbbS",		eAX, Iv, XX },
  { "push{T|}",		ds, XX, XX },
  { "pop{T|}",		ds, XX, XX },
d1371 8
a1378 8
  { "andB",		Eb, Gb, XX },
  { "andS",		Ev, Gv, XX },
  { "andB",		Gb, Eb, XX },
  { "andS",		Gv, Ev, XX },
  { "andB",		AL, Ib, XX },
  { "andS",		eAX, Iv, XX },
  { "(bad)",		XX, XX, XX },	/* SEG ES prefix */
  { "daa{|}",		XX, XX, XX },
d1380 8
a1387 8
  { "subB",		Eb, Gb, XX },
  { "subS",		Ev, Gv, XX },
  { "subB",		Gb, Eb, XX },
  { "subS",		Gv, Ev, XX },
  { "subB",		AL, Ib, XX },
  { "subS",		eAX, Iv, XX },
  { "(bad)",		XX, XX, XX },	/* SEG CS prefix */
  { "das{|}",		XX, XX, XX },
d1389 8
a1396 8
  { "xorB",		Eb, Gb, XX },
  { "xorS",		Ev, Gv, XX },
  { "xorB",		Gb, Eb, XX },
  { "xorS",		Gv, Ev, XX },
  { "xorB",		AL, Ib, XX },
  { "xorS",		eAX, Iv, XX },
  { "(bad)",		XX, XX, XX },	/* SEG SS prefix */
  { "aaa{|}",		XX, XX, XX },
d1398 8
a1405 8
  { "cmpB",		Eb, Gb, XX },
  { "cmpS",		Ev, Gv, XX },
  { "cmpB",		Gb, Eb, XX },
  { "cmpS",		Gv, Ev, XX },
  { "cmpB",		AL, Ib, XX },
  { "cmpS",		eAX, Iv, XX },
  { "(bad)",		XX, XX, XX },	/* SEG DS prefix */
  { "aas{|}",		XX, XX, XX },
d1407 8
a1414 8
  { "inc{S|}",		RMeAX, XX, XX },
  { "inc{S|}",		RMeCX, XX, XX },
  { "inc{S|}",		RMeDX, XX, XX },
  { "inc{S|}",		RMeBX, XX, XX },
  { "inc{S|}",		RMeSP, XX, XX },
  { "inc{S|}",		RMeBP, XX, XX },
  { "inc{S|}",		RMeSI, XX, XX },
  { "inc{S|}",		RMeDI, XX, XX },
d1416 8
a1423 8
  { "dec{S|}",		RMeAX, XX, XX },
  { "dec{S|}",		RMeCX, XX, XX },
  { "dec{S|}",		RMeDX, XX, XX },
  { "dec{S|}",		RMeBX, XX, XX },
  { "dec{S|}",		RMeSP, XX, XX },
  { "dec{S|}",		RMeBP, XX, XX },
  { "dec{S|}",		RMeSI, XX, XX },
  { "dec{S|}",		RMeDI, XX, XX },
d1425 8
a1432 8
  { "pushS",		RMrAX, XX, XX },
  { "pushS",		RMrCX, XX, XX },
  { "pushS",		RMrDX, XX, XX },
  { "pushS",		RMrBX, XX, XX },
  { "pushS",		RMrSP, XX, XX },
  { "pushS",		RMrBP, XX, XX },
  { "pushS",		RMrSI, XX, XX },
  { "pushS",		RMrDI, XX, XX },
d1434 8
a1441 8
  { "popS",		RMrAX, XX, XX },
  { "popS",		RMrCX, XX, XX },
  { "popS",		RMrDX, XX, XX },
  { "popS",		RMrBX, XX, XX },
  { "popS",		RMrSP, XX, XX },
  { "popS",		RMrBP, XX, XX },
  { "popS",		RMrSI, XX, XX },
  { "popS",		RMrDI, XX, XX },
d1443 8
a1450 8
  { "pusha{P|}",	XX, XX, XX },
  { "popa{P|}",		XX, XX, XX },
  { "bound{S|}",	Gv, Ma, XX },
  { X86_64_0 },
  { "(bad)",		XX, XX, XX },	/* seg fs */
  { "(bad)",		XX, XX, XX },	/* seg gs */
  { "(bad)",		XX, XX, XX },	/* op size prefix */
  { "(bad)",		XX, XX, XX },	/* adr size prefix */
d1452 8
a1459 8
  { "pushT",		Iq, XX, XX },
  { "imulS",		Gv, Ev, Iv },
  { "pushT",		sIb, XX, XX },
  { "imulS",		Gv, Ev, sIb },
  { "ins{b||b|}",	Yb, indirDX, XX },
  { "ins{R||R|}",	Yv, indirDX, XX },
  { "outs{b||b|}",	indirDX, Xb, XX },
  { "outs{R||R|}",	indirDX, Xv, XX },
d1461 8
a1468 8
  { "joH",		Jb, XX, cond_jump_flag },
  { "jnoH",		Jb, XX, cond_jump_flag },
  { "jbH",		Jb, XX, cond_jump_flag },
  { "jaeH",		Jb, XX, cond_jump_flag },
  { "jeH",		Jb, XX, cond_jump_flag },
  { "jneH",		Jb, XX, cond_jump_flag },
  { "jbeH",		Jb, XX, cond_jump_flag },
  { "jaH",		Jb, XX, cond_jump_flag },
d1470 8
a1477 8
  { "jsH",		Jb, XX, cond_jump_flag },
  { "jnsH",		Jb, XX, cond_jump_flag },
  { "jpH",		Jb, XX, cond_jump_flag },
  { "jnpH",		Jb, XX, cond_jump_flag },
  { "jlH",		Jb, XX, cond_jump_flag },
  { "jgeH",		Jb, XX, cond_jump_flag },
  { "jleH",		Jb, XX, cond_jump_flag },
  { "jgH",		Jb, XX, cond_jump_flag },
d1481 1
a1481 1
  { "(bad)",		XX, XX, XX },
d1483 4
a1486 4
  { "testB",		Eb, Gb, XX },
  { "testS",		Ev, Gv, XX },
  { "xchgB",		Eb, Gb, XX },
  { "xchgS",		Ev, Gv, XX },
d1488 8
a1495 8
  { "movB",		Eb, Gb, XX },
  { "movS",		Ev, Gv, XX },
  { "movB",		Gb, Eb, XX },
  { "movS",		Gv, Ev, XX },
  { "movQ",		Ev, Sw, XX },
  { "leaS",		Gv, M, XX },
  { "movQ",		Sw, Ev, XX },
  { "popU",		Ev, XX, XX },
d1497 1
a1497 1
  { "nop",		XX, XX, XX },
d1499 7
a1505 7
  { "xchgS",		RMeCX, eAX, XX },
  { "xchgS",		RMeDX, eAX, XX },
  { "xchgS",		RMeBX, eAX, XX },
  { "xchgS",		RMeSP, eAX, XX },
  { "xchgS",		RMeBP, eAX, XX },
  { "xchgS",		RMeSI, eAX, XX },
  { "xchgS",		RMeDI, eAX, XX },
d1507 8
a1514 8
  { "cW{tR||tR|}",	XX, XX, XX },
  { "cR{tO||tO|}",	XX, XX, XX },
  { "lcall{T|}",	Ap, XX, XX },
  { "(bad)",		XX, XX, XX },	/* fwait */
  { "pushfT",		XX, XX, XX },
  { "popfT",		XX, XX, XX },
  { "sahf{|}",		XX, XX, XX },
  { "lahf{|}",		XX, XX, XX },
d1516 8
a1523 8
  { "movB",		AL, Ob64, XX },
  { "movS",		eAX, Ov64, XX },
  { "movB",		Ob64, AL, XX },
  { "movS",		Ov64, eAX, XX },
  { "movs{b||b|}",	Yb, Xb, XX },
  { "movs{R||R|}",	Yv, Xv, XX },
  { "cmps{b||b|}",	Xb, Yb, XX },
  { "cmps{R||R|}",	Xv, Yv, XX },
d1525 8
a1532 8
  { "testB",		AL, Ib, XX },
  { "testS",		eAX, Iv, XX },
  { "stosB",		Yb, AL, XX },
  { "stosS",		Yv, eAX, XX },
  { "lodsB",		AL, Xb, XX },
  { "lodsS",		eAX, Xv, XX },
  { "scasB",		AL, Yb, XX },
  { "scasS",		eAX, Yv, XX },
d1534 8
a1541 8
  { "movB",		RMAL, Ib, XX },
  { "movB",		RMCL, Ib, XX },
  { "movB",		RMDL, Ib, XX },
  { "movB",		RMBL, Ib, XX },
  { "movB",		RMAH, Ib, XX },
  { "movB",		RMCH, Ib, XX },
  { "movB",		RMDH, Ib, XX },
  { "movB",		RMBH, Ib, XX },
d1543 8
a1550 8
  { "movS",		RMeAX, Iv64, XX },
  { "movS",		RMeCX, Iv64, XX },
  { "movS",		RMeDX, Iv64, XX },
  { "movS",		RMeBX, Iv64, XX },
  { "movS",		RMeSP, Iv64, XX },
  { "movS",		RMeBP, Iv64, XX },
  { "movS",		RMeSI, Iv64, XX },
  { "movS",		RMeDI, Iv64, XX },
d1554 6
a1559 6
  { "retT",		Iw, XX, XX },
  { "retT",		XX, XX, XX },
  { "les{S|}",		Gv, Mp, XX },
  { "ldsS",		Gv, Mp, XX },
  { "movA",		Eb, Ib, XX },
  { "movQ",		Ev, Iv, XX },
d1561 8
a1568 8
  { "enterT",		Iw, Ib, XX },
  { "leaveT",		XX, XX, XX },
  { "lretP",		Iw, XX, XX },
  { "lretP",		XX, XX, XX },
  { "int3",		XX, XX, XX },
  { "int",		Ib, XX, XX },
  { "into{|}",		XX, XX, XX },
  { "iretP",		XX, XX, XX },
d1574 4
a1577 4
  { "aam{|}",		sIb, XX, XX },
  { "aad{|}",		sIb, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "xlat",		DSBX, XX, XX },
d1588 8
a1595 8
  { "loopneFH",		Jb, XX, loop_jcxz_flag },
  { "loopeFH",		Jb, XX, loop_jcxz_flag },
  { "loopFH",		Jb, XX, loop_jcxz_flag },
  { "jEcxzH",		Jb, XX, loop_jcxz_flag },
  { "inB",		AL, Ib, XX },
  { "inS",		eAX, Ib, XX },
  { "outB",		Ib, AL, XX },
  { "outS",		Ib, eAX, XX },
d1597 8
a1604 8
  { "callT",		Jv, XX, XX },
  { "jmpT",		Jv, XX, XX },
  { "ljmp{T|}",		Ap, XX, XX },
  { "jmp",		Jb, XX, XX },
  { "inB",		AL, indirDX, XX },
  { "inS",		eAX, indirDX, XX },
  { "outB",		indirDX, AL, XX },
  { "outS",		indirDX, eAX, XX },
d1606 6
a1611 6
  { "(bad)",		XX, XX, XX },	/* lock prefix */
  { "icebp",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },	/* repne */
  { "(bad)",		XX, XX, XX },	/* repz */
  { "hlt",		XX, XX, XX },
  { "cmc",		XX, XX, XX },
d1615 6
a1620 6
  { "clc",		XX, XX, XX },
  { "stc",		XX, XX, XX },
  { "cli",		XX, XX, XX },
  { "sti",		XX, XX, XX },
  { "cld",		XX, XX, XX },
  { "std",		XX, XX, XX },
d1625 293
a1917 1
static const struct dis386 dis386_twobyte[] = {
d1921 6
a1926 6
  { "larS",		Gv, Ew, XX },
  { "lslS",		Gv, Ew, XX },
  { "(bad)",		XX, XX, XX },
  { "syscall",		XX, XX, XX },
  { "clts",		XX, XX, XX },
  { "sysretP",		XX, XX, XX },
d1928 5
a1932 5
  { "invd",		XX, XX, XX },
  { "wbinvd",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "ud2a",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
d1934 2
a1935 2
  { "femms",		XX, XX, XX },
  { "",			MX, EM, OPSUF }, /* See OP_3DNowSuffix.  */
d1939 6
a1944 6
  { "movlpX",		XM, EX, SIMD_Fixup, 'h' }, /* really only 2 operands */
  { "movlpX",		EX, XM, SIMD_Fixup, 'h' },
  { "unpcklpX",		XM, EX, XX },
  { "unpckhpX",		XM, EX, XX },
  { "movhpX",		XM, EX, SIMD_Fixup, 'l' },
  { "movhpX",		EX, XM, SIMD_Fixup, 'l' },
d1947 7
a1953 7
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
d1955 9
a1963 8
  { "movL",		Rm, Cm, XX },
  { "movL",		Rm, Dm, XX },
  { "movL",		Cm, Rm, XX },
  { "movL",		Dm, Rm, XX },
  { "movL",		Rd, Td, XX },
  { "(bad)",		XX, XX, XX },
  { "movL",		Td, Rd, XX },
  { "(bad)",		XX, XX, XX },
d1965 2
a1966 2
  { "movapX",		XM, EX, XX },
  { "movapX",		EX, XM, XX },
d1968 1
a1968 1
  { "movntpX",		Ev, XM, XX },
d1971 2
a1972 2
  { "ucomisX",		XM,EX, XX },
  { "comisX",		XM,EX, XX },
d1974 8
a1981 8
  { "wrmsr",		XX, XX, XX },
  { "rdtsc",		XX, XX, XX },
  { "rdmsr",		XX, XX, XX },
  { "rdpmc",		XX, XX, XX },
  { "sysenter",		XX, XX, XX },
  { "sysexit",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
d1983 8
a1990 8
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
d1992 8
a1999 8
  { "cmovo",		Gv, Ev, XX },
  { "cmovno",		Gv, Ev, XX },
  { "cmovb",		Gv, Ev, XX },
  { "cmovae",		Gv, Ev, XX },
  { "cmove",		Gv, Ev, XX },
  { "cmovne",		Gv, Ev, XX },
  { "cmovbe",		Gv, Ev, XX },
  { "cmova",		Gv, Ev, XX },
d2001 8
a2008 8
  { "cmovs",		Gv, Ev, XX },
  { "cmovns",		Gv, Ev, XX },
  { "cmovp",		Gv, Ev, XX },
  { "cmovnp",		Gv, Ev, XX },
  { "cmovl",		Gv, Ev, XX },
  { "cmovge",		Gv, Ev, XX },
  { "cmovle",		Gv, Ev, XX },
  { "cmovg",		Gv, Ev, XX },
d2010 1
a2010 1
  { "movmskpX",		Gd, XS, XX },
d2014 4
a2017 4
  { "andpX",		XM, EX, XX },
  { "andnpX",		XM, EX, XX },
  { "orpX",		XM, EX, XX },
  { "xorpX",		XM, EX, XX },
d2028 8
a2035 8
  { "punpcklbw",	MX, EM, XX },
  { "punpcklwd",	MX, EM, XX },
  { "punpckldq",	MX, EM, XX },
  { "packsswb",		MX, EM, XX },
  { "pcmpgtb",		MX, EM, XX },
  { "pcmpgtw",		MX, EM, XX },
  { "pcmpgtd",		MX, EM, XX },
  { "packuswb",		MX, EM, XX },
d2037 4
a2040 4
  { "punpckhbw",	MX, EM, XX },
  { "punpckhwd",	MX, EM, XX },
  { "punpckhdq",	MX, EM, XX },
  { "packssdw",		MX, EM, XX },
d2043 1
a2043 1
  { "movd",		MX, Edq, XX },
d2050 4
a2053 4
  { "pcmpeqb",		MX, EM, XX },
  { "pcmpeqw",		MX, EM, XX },
  { "pcmpeqd",		MX, EM, XX },
  { "emms",		XX, XX, XX },
d2055 6
a2060 6
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
d2064 8
a2071 8
  { "joH",		Jv, XX, cond_jump_flag },
  { "jnoH",		Jv, XX, cond_jump_flag },
  { "jbH",		Jv, XX, cond_jump_flag },
  { "jaeH",		Jv, XX, cond_jump_flag },
  { "jeH",		Jv, XX, cond_jump_flag },
  { "jneH",		Jv, XX, cond_jump_flag },
  { "jbeH",		Jv, XX, cond_jump_flag },
  { "jaH",		Jv, XX, cond_jump_flag },
d2073 8
a2080 8
  { "jsH",		Jv, XX, cond_jump_flag },
  { "jnsH",		Jv, XX, cond_jump_flag },
  { "jpH",		Jv, XX, cond_jump_flag },
  { "jnpH",		Jv, XX, cond_jump_flag },
  { "jlH",		Jv, XX, cond_jump_flag },
  { "jgeH",		Jv, XX, cond_jump_flag },
  { "jleH",		Jv, XX, cond_jump_flag },
  { "jgH",		Jv, XX, cond_jump_flag },
d2082 8
a2089 8
  { "seto",		Eb, XX, XX },
  { "setno",		Eb, XX, XX },
  { "setb",		Eb, XX, XX },
  { "setae",		Eb, XX, XX },
  { "sete",		Eb, XX, XX },
  { "setne",		Eb, XX, XX },
  { "setbe",		Eb, XX, XX },
  { "seta",		Eb, XX, XX },
d2091 8
a2098 8
  { "sets",		Eb, XX, XX },
  { "setns",		Eb, XX, XX },
  { "setp",		Eb, XX, XX },
  { "setnp",		Eb, XX, XX },
  { "setl",		Eb, XX, XX },
  { "setge",		Eb, XX, XX },
  { "setle",		Eb, XX, XX },
  { "setg",		Eb, XX, XX },
d2100 8
a2107 8
  { "pushT",		fs, XX, XX },
  { "popT",		fs, XX, XX },
  { "cpuid",		XX, XX, XX },
  { "btS",		Ev, Gv, XX },
  { "shldS",		Ev, Gv, Ib },
  { "shldS",		Ev, Gv, CL },
  { "(bad)",		XX, XX, XX },
  { "(bad)",		XX, XX, XX },
d2109 6
a2114 6
  { "pushT",		gs, XX, XX },
  { "popT",		gs, XX, XX },
  { "rsm",		XX, XX, XX },
  { "btsS",		Ev, Gv, XX },
  { "shrdS",		Ev, Gv, Ib },
  { "shrdS",		Ev, Gv, CL },
d2116 1
a2116 1
  { "imulS",		Gv, Ev, XX },
d2118 8
a2125 8
  { "cmpxchgB",		Eb, Gb, XX },
  { "cmpxchgS",		Ev, Gv, XX },
  { "lssS",		Gv, Mp, XX },
  { "btrS",		Ev, Gv, XX },
  { "lfsS",		Gv, Mp, XX },
  { "lgsS",		Gv, Mp, XX },
  { "movz{bR|x|bR|x}",	Gv, Eb, XX },
  { "movz{wR|x|wR|x}",	Gv, Ew, XX }, /* yes, there really is movzww ! */
d2127 2
a2128 2
  { "(bad)",		XX, XX, XX },
  { "ud2b",		XX, XX, XX },
d2130 5
a2134 5
  { "btcS",		Ev, Gv, XX },
  { "bsfS",		Gv, Ev, XX },
  { "bsrS",		Gv, Ev, XX },
  { "movs{bR|x|bR|x}",	Gv, Eb, XX },
  { "movs{wR|x|wR|x}",	Gv, Ew, XX }, /* yes, there really is movsww ! */
d2136 2
a2137 2
  { "xaddB",		Eb, Gb, XX },
  { "xaddS",		Ev, Gv, XX },
d2139 4
a2142 4
  { "movntiS",		Ev, Gv, XX },
  { "pinsrw",		MX, Ed, Ib },
  { "pextrw",		Gd, MS, Ib },
  { "shufpX",		XM, EX, Ib },
d2145 8
a2152 8
  { "bswap",		RMeAX, XX, XX },
  { "bswap",		RMeCX, XX, XX },
  { "bswap",		RMeDX, XX, XX },
  { "bswap",		RMeBX, XX, XX },
  { "bswap",		RMeSP, XX, XX },
  { "bswap",		RMeBP, XX, XX },
  { "bswap",		RMeSI, XX, XX },
  { "bswap",		RMeDI, XX, XX },
d2154 6
a2159 6
  { "(bad)",		XX, XX, XX },
  { "psrlw",		MX, EM, XX },
  { "psrld",		MX, EM, XX },
  { "psrlq",		MX, EM, XX },
  { "paddq",		MX, EM, XX },
  { "pmullw",		MX, EM, XX },
d2161 1
a2161 1
  { "pmovmskb",		Gd, MS, XX },
d2163 8
a2170 8
  { "psubusb",		MX, EM, XX },
  { "psubusw",		MX, EM, XX },
  { "pminub",		MX, EM, XX },
  { "pand",		MX, EM, XX },
  { "paddusb",		MX, EM, XX },
  { "paddusw",		MX, EM, XX },
  { "pmaxub",		MX, EM, XX },
  { "pandn",		MX, EM, XX },
d2172 6
a2177 6
  { "pavgb",		MX, EM, XX },
  { "psraw",		MX, EM, XX },
  { "psrad",		MX, EM, XX },
  { "pavgw",		MX, EM, XX },
  { "pmulhuw",		MX, EM, XX },
  { "pmulhw",		MX, EM, XX },
d2181 8
a2188 8
  { "psubsb",		MX, EM, XX },
  { "psubsw",		MX, EM, XX },
  { "pminsw",		MX, EM, XX },
  { "por",		MX, EM, XX },
  { "paddsb",		MX, EM, XX },
  { "paddsw",		MX, EM, XX },
  { "pmaxsw",		MX, EM, XX },
  { "pxor",		MX, EM, XX },
d2190 7
a2196 7
  { "(bad)",		XX, XX, XX },
  { "psllw",		MX, EM, XX },
  { "pslld",		MX, EM, XX },
  { "psllq",		MX, EM, XX },
  { "pmuludq",		MX, EM, XX },
  { "pmaddwd",		MX, EM, XX },
  { "psadbw",		MX, EM, XX },
d2199 8
a2206 8
  { "psubb",		MX, EM, XX },
  { "psubw",		MX, EM, XX },
  { "psubd",		MX, EM, XX },
  { "psubq",		MX, EM, XX },
  { "paddb",		MX, EM, XX },
  { "paddw",		MX, EM, XX },
  { "paddd",		MX, EM, XX },
  { "(bad)",		XX, XX, XX }
d2289 1
d2296 2
a2297 36
static const char **names64;
static const char **names32;
static const char **names16;
static const char **names8;
static const char **names8rex;
static const char **names_seg;
static const char **index16;

static const char *intel_names64[] = {
  "rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi",
  "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
};
static const char *intel_names32[] = {
  "eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi",
  "r8d", "r9d", "r10d", "r11d", "r12d", "r13d", "r14d", "r15d"
};
static const char *intel_names16[] = {
  "ax", "cx", "dx", "bx", "sp", "bp", "si", "di",
  "r8w", "r9w", "r10w", "r11w", "r12w", "r13w", "r14w", "r15w"
};
static const char *intel_names8[] = {
  "al", "cl", "dl", "bl", "ah", "ch", "dh", "bh",
};
static const char *intel_names8rex[] = {
  "al", "cl", "dl", "bl", "spl", "bpl", "sil", "dil",
  "r8b", "r9b", "r10b", "r11b", "r12b", "r13b", "r14b", "r15b"
};
static const char *intel_names_seg[] = {
  "es", "cs", "ss", "ds", "fs", "gs", "?", "?",
};
static const char *intel_index16[] = {
  "bx+si", "bx+di", "bp+si", "bp+di", "si", "di", "bp", "bx"
};

static const char *att_names64[] = {
  "%rax", "%rcx", "%rdx", "%rbx", "%rsp", "%rbp", "%rsi", "%rdi",
d2300 2
a2301 2
static const char *att_names32[] = {
  "%eax", "%ecx", "%edx", "%ebx", "%esp", "%ebp", "%esi", "%edi",
d2304 2
a2305 2
static const char *att_names16[] = {
  "%ax", "%cx", "%dx", "%bx", "%sp", "%bp", "%si", "%di",
d2308 2
a2309 2
static const char *att_names8[] = {
  "%al", "%cl", "%dl", "%bl", "%ah", "%ch", "%dh", "%bh",
d2311 2
a2312 2
static const char *att_names8rex[] = {
  "%al", "%cl", "%dl", "%bl", "%spl", "%bpl", "%sil", "%dil",
d2315 2
a2316 2
static const char *att_names_seg[] = {
  "%es", "%cs", "%ss", "%ds", "%fs", "%gs", "%?", "%?",
d2318 2
a2319 2
static const char *att_index16[] = {
  "%bx,%si", "%bx,%di", "%bp,%si", "%bp,%di", "%si", "%di", "%bp", "%bx"
d2428 4
a2431 4
    { "mulA",	Eb, XX, XX },	/* Don't print the implicit %al register,  */
    { "imulA",	Eb, XX, XX },	/* to distinguish these opcodes from other */
    { "divA",	Eb, XX, XX },	/* mul/imul opcodes.  Do the same for div  */
    { "idivA",	Eb, XX, XX }	/* and idiv for consistency.		   */
d2439 4
a2442 4
    { "mulQ",	Ev, XX, XX },	/* Don't print the implicit register.  */
    { "imulQ",	Ev, XX, XX },
    { "divQ",	Ev, XX, XX },
    { "idivQ",	Ev, XX, XX },
d2459 5
a2463 5
    { "callT",	indirEv, XX, XX },
    { "lcallT",	indirEv, XX, XX },
    { "jmpT",	indirEv, XX, XX },
    { "ljmpT",	indirEv, XX, XX },
    { "pushU",	Ev, XX, XX },
d2468 2
a2469 2
    { "sldtQ",	Ev, XX, XX },
    { "strQ",	Ev, XX, XX },
d2479 8
a2486 8
    { "sgdtQ",	 M, XX, XX },
    { "sidtQ",	 M, XX, XX },
    { "lgdtQ",	 M, XX, XX },
    { "lidtQ",	 M, XX, XX },
    { "smswQ",	Ev, XX, XX },
    { "(bad)",	XX, XX, XX },
    { "lmsw",	Ew, XX, XX },
    { "invlpg",	Ew, XX, XX },
d2553 1
a2553 1
    /* FIXME: the sfence with memory operand is clflush!  */
d2577 1
d2590 1
a2590 1
    { "", XM, EX, OPSIMD },	/* See OP_SIMD_SUFFIX.  */
d2744 1
a2744 1
    { "movd", Edq, MX, XX },
d2746 1
a2746 1
    { "movd", Edq, XM, XX },
a2771 7
static const struct dis386 x86_64_table[][2] = {
  {
    { "arpl", Ew, Gw, XX },
    { "movs{||lq|xd}", Gv, Ed, XX },
  },
};

d2933 1
a2933 4
      if (mode_64bit)
	return (sizeflag & AFLAG) ? "addr32" : "addr64";
      else
	return ((sizeflag & AFLAG) && !mode_64bit) ? "addr16" : "addr32";
d2943 2
a2944 2
static bfd_vma op_address[3];
static bfd_vma op_riprel[3];
d2946 1
d2957 3
a2965 3
/* Here for backwards compatibility.  When gdb stops using
   print_insn_i386_att and print_insn_i386_intel these functions can
   disappear, and print_insn_i386 be merged into print_insn.  */
d2972 4
d2977 1
a2977 1
  return print_insn (pc, info);
d2986 4
d2991 1
a2991 1
  return print_insn (pc, info);
d2994 1
a2994 1
int
a2998 10
  intel_syntax = -1;

  return print_insn (pc, info);
}

static int
print_insn (pc, info)
     bfd_vma pc;
     disassemble_info *info;
{
d3005 3
a3007 2
  int sizeflag;
  const char *p;
d3009 1
d3011 2
a3012 63
  mode_64bit = (info->mach == bfd_mach_x86_64_intel_syntax
		|| info->mach == bfd_mach_x86_64);

  if (intel_syntax == (char) -1)
    intel_syntax = (info->mach == bfd_mach_i386_i386_intel_syntax
		    || info->mach == bfd_mach_x86_64_intel_syntax);

  if (info->mach == bfd_mach_i386_i386
      || info->mach == bfd_mach_x86_64
      || info->mach == bfd_mach_i386_i386_intel_syntax
      || info->mach == bfd_mach_x86_64_intel_syntax)
    priv.orig_sizeflag = AFLAG | DFLAG;
  else if (info->mach == bfd_mach_i386_i8086)
    priv.orig_sizeflag = 0;
  else
    abort ();

  for (p = info->disassembler_options; p != NULL; )
    {
      if (strncmp (p, "x86-64", 6) == 0)
	{
	  mode_64bit = 1;
	  priv.orig_sizeflag = AFLAG | DFLAG;
	}
      else if (strncmp (p, "i386", 4) == 0)
	{
	  mode_64bit = 0;
	  priv.orig_sizeflag = AFLAG | DFLAG;
	}
      else if (strncmp (p, "i8086", 5) == 0)
	{
	  mode_64bit = 0;
	  priv.orig_sizeflag = 0;
	}
      else if (strncmp (p, "intel", 5) == 0)
	{
	  intel_syntax = 1;
	}
      else if (strncmp (p, "att", 3) == 0)
	{
	  intel_syntax = 0;
	}
      else if (strncmp (p, "addr", 4) == 0)
	{
	  if (p[4] == '1' && p[5] == '6')
	    priv.orig_sizeflag &= ~AFLAG;
	  else if (p[4] == '3' && p[5] == '2')
	    priv.orig_sizeflag |= AFLAG;
	}
      else if (strncmp (p, "data", 4) == 0)
	{
	  if (p[4] == '1' && p[5] == '6')
	    priv.orig_sizeflag &= ~DFLAG;
	  else if (p[4] == '3' && p[5] == '2')
	    priv.orig_sizeflag |= DFLAG;
	}
      else if (strncmp (p, "suffix", 6) == 0)
	priv.orig_sizeflag |= SUFFIX_ALWAYS;

      p = strchr (p, ',');
      if (p != NULL)
	p++;
    }
d3014 7
a3020 14
  if (intel_syntax)
    {
      names64 = intel_names64;
      names32 = intel_names32;
      names16 = intel_names16;
      names8 = intel_names8;
      names8rex = intel_names8rex;
      names_seg = intel_names_seg;
      index16 = intel_index16;
      open_char = '[';
      close_char = ']';
      separator_char = '+';
      scale_char = '*';
    }
d3022 2
a3023 13
    {
      names64 = att_names64;
      names32 = att_names32;
      names16 = att_names16;
      names8 = att_names8;
      names8rex = att_names8rex;
      names_seg = att_names_seg;
      index16 = att_index16;
      open_char = '(';
      close_char =  ')';
      separator_char = ',';
      scale_char = ',';
    }
d3042 2
a3043 2
  start_codep = priv.the_buffer;
  codep = priv.the_buffer;
d3050 3
a3052 3
	 means we have an incomplete instruction of some sort.  Just
	 print the first byte as a prefix or a .byte pseudo-op.  */
      if (codep > priv.the_buffer)
d3054 1
a3054 1
	  name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);
d3061 1
a3061 1
				     (unsigned int) priv.the_buffer[0]);
a3073 1
  sizeflag = priv.orig_sizeflag;
d3084 2
a3085 2
	 first prefix, which is probably fwait itself.  */
      name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);
d3095 4
a3098 1
      dp = &dis386_twobyte[*++codep];
d3104 10
a3113 1
      dp = &dis386[*codep];
d3138 1
a3138 1
      if (dp->bytemode3 != loop_jcxz_mode || intel_syntax)
d3140 1
a3140 1
	  if ((sizeflag & AFLAG) || mode_64bit)
d3151 1
a3151 3
      if (dp->bytemode3 == cond_jump_mode
	  && dp->bytemode1 == v_mode
	  && !intel_syntax)
d3161 14
d3192 1
a3192 1
	  switch (dp->bytemode1)
d3194 25
a3218 31
	    case USE_GROUPS:
	      dp = &grps[dp->bytemode2][reg];
	      break;

	    case USE_PREFIX_USER_TABLE:
	      index = 0;
	      used_prefixes |= (prefixes & PREFIX_REPZ);
	      if (prefixes & PREFIX_REPZ)
		index = 1;
	      else
		{
		  used_prefixes |= (prefixes & PREFIX_DATA);
		  if (prefixes & PREFIX_DATA)
		    index = 2;
		  else
		    {
		      used_prefixes |= (prefixes & PREFIX_REPNZ);
		      if (prefixes & PREFIX_REPNZ)
			index = 3;
		    }
		}
	      dp = &prefix_user_table[dp->bytemode2][index];
	      break;

	    case X86_64_SPECIAL:
	      dp = &x86_64_table[dp->bytemode2][mode_64bit];
	      break;

	    default:
	      oappend (INTERNAL_DISASSEMBLER_ERROR);
	      break;
d3222 16
a3237 17
      if (putop (dp->name, sizeflag) == 0)
	{
	  obufp = op1out;
	  op_ad = 2;
	  if (dp->op1)
	    (*dp->op1) (dp->bytemode1, sizeflag);

	  obufp = op2out;
	  op_ad = 1;
	  if (dp->op2)
	    (*dp->op2) (dp->bytemode2, sizeflag);

	  obufp = op3out;
	  op_ad = 0;
	  if (dp->op3)
	    (*dp->op3) (dp->bytemode3, sizeflag);
	}
d3248 1
a3248 1
      name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);
d3257 1
a3257 1
      name = prefix_name (rex | 0x40, priv.orig_sizeflag);
d3321 1
a3321 1
  return codep - priv.the_buffer;
d3324 76
a3399 1
static const char *float_mem[] = {
d3401 10
a3410 10
  "fadd{s||s|}",
  "fmul{s||s|}",
  "fcom{s||s|}",
  "fcomp{s||s|}",
  "fsub{s||s|}",
  "fsubr{s||s|}",
  "fdiv{s||s|}",
  "fdivr{s||s|}",
  /* d9 */
  "fld{s||s|}",
d3412 2
a3413 2
  "fst{s||s|}",
  "fstp{s||s|}",
d3419 8
a3426 8
  "fiadd{l||l|}",
  "fimul{l||l|}",
  "ficom{l||l|}",
  "ficomp{l||l|}",
  "fisub{l||l|}",
  "fisubr{l||l|}",
  "fidiv{l||l|}",
  "fidivr{l||l|}",
d3428 1
a3428 1
  "fild{l||l|}",
d3430 2
a3431 2
  "fist{l||l|}",
  "fistp{l||l|}",
d3433 1
a3433 1
  "fld{t||t|}",
d3435 1
a3435 1
  "fstp{t||t|}",
d3437 8
a3444 8
  "fadd{l||l|}",
  "fmul{l||l|}",
  "fcom{l||l|}",
  "fcomp{l||l|}",
  "fsub{l||l|}",
  "fsubr{l||l|}",
  "fdiv{l||l|}",
  "fdivr{l||l|}",
d3446 1
a3446 1
  "fld{l||l|}",
d3448 2
a3449 2
  "fst{l||l|}",
  "fstp{l||l|}",
d3469 1
a3469 1
  "fild{ll||ll|}",
d3592 1
d3652 4
a3655 1
      putop (float_mem[(floatop - 0xd8) * 8 + reg], sizeflag);
d3658 1
a3658 1
	OP_E (x_mode, sizeflag);
d3660 1
a3660 1
	OP_E (d_mode, sizeflag);
d3662 1
a3662 1
	OP_E (v_mode, sizeflag);
d3665 1
a3665 1
  /* Skip mod/rm byte.  */
d3674 1
a3674 1
      /* Instruction fnstsw is only one with strange arg.  */
d3684 1
a3684 1
	(*dp->op1) (dp->bytemode1, sizeflag);
d3687 1
a3687 1
	(*dp->op2) (dp->bytemode2, sizeflag);
d3691 1
d3693 2
a3694 2
OP_ST (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
d3700 1
d3702 2
a3703 2
OP_STi (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
d3707 1
a3707 1
  oappend (scratchbuf + intel_syntax);
d3710 3
a3712 2
/* Capital letters in template are macros.  */
static int
a3717 1
  int alt;
a3725 32
	case '{':
	  alt = 0;
	  if (intel_syntax)
	    alt += 1;
	  if (mode_64bit)
	    alt += 2;
	  while (alt != 0)
	    {
	      while (*++p != '|')
		{
		  if (*p == '}')
		    {
		      /* Alternative not valid.  */
		      strcpy (obuf, "(bad)");
		      obufp = obuf + 5;
		      return 1;
		    }
		  else if (*p == '\0')
		    abort ();
		}
	      alt--;
	    }
	  break;
	case '|':
	  while (*++p != '}')
	    {
	      if (*p == '\0')
		abort ();
	    }
	  break;
	case '}':
	  break;
d3727 7
a3733 3
	  if (intel_syntax)
	    break;
	  if (mod != 3 || (sizeflag & SUFFIX_ALWAYS))
d3737 3
a3739 2
	  if (intel_syntax)
	    break;
d3742 1
d3745 2
a3746 10
	  if (mode_64bit)
	    {
	      if (sizeflag & AFLAG)
		*obufp++ = 'r';
	      else
		*obufp++ = 'e';
	    }
	  else
	    if (sizeflag & AFLAG)
	      *obufp++ = 'e';
d3750 5
a3754 3
	  if (intel_syntax)
	    break;
	  if ((prefixes & PREFIX_ADDR) || (sizeflag & SUFFIX_ALWAYS))
d3757 1
a3757 1
		*obufp++ = mode_64bit ? 'q' : 'l';
d3759 1
a3759 1
		*obufp++ = mode_64bit ? 'l' : 'w';
d3763 6
a3768 5
	case 'H':
	  if (intel_syntax)
	    break;
	  if ((prefixes & (PREFIX_CS | PREFIX_DS)) == PREFIX_CS
	      || (prefixes & (PREFIX_CS | PREFIX_DS)) == PREFIX_DS)
d3770 12
a3781 7
	      used_prefixes |= prefixes & (PREFIX_CS | PREFIX_DS);
	      *obufp++ = ',';
	      *obufp++ = 'p';
	      if (prefixes & PREFIX_DS)
		*obufp++ = 't';
	      else
		*obufp++ = 'n';
d3785 3
a3787 2
	  if (intel_syntax)
	    break;
d3790 1
d3801 1
a3801 1
	    *obufp++ = 'o';
a3804 9
	case 'T':
	  if (intel_syntax)
	    break;
	  if (mode_64bit)
	    {
	      *obufp++ = 'q';
	      break;
	    }
	  /* Fall through.  */
d3806 2
a3807 2
	  if (intel_syntax)
	    break;
d3810 4
a3813 1
	      || (sizeflag & SUFFIX_ALWAYS))
a3827 9
	case 'U':
	  if (intel_syntax)
	    break;
	  if (mode_64bit)
	    {
	      *obufp++ = 'q';
	      break;
	    }
	  /* Fall through.  */
d3829 2
a3830 2
	  if (intel_syntax)
	    break;
d3832 5
a3836 1
	  if (mod != 3 || (sizeflag & SUFFIX_ALWAYS))
d3852 1
a3852 1
	  if (intel_syntax)
d3883 3
a3885 2
	  if (intel_syntax)
	    break;
d3899 19
d3924 1
a3924 1
	  used_prefixes |= (prefixes & PREFIX_DATA);
d3927 2
a3928 2
	  if (intel_syntax)
	    break;
d3945 1
a3945 1
	  if (intel_syntax)
a3967 1
  return 0;
d3983 1
a3984 1
      oappend ("%cs:" + intel_syntax);
d3988 1
a3989 1
      oappend ("%ds:" + intel_syntax);
d3993 1
a3994 1
      oappend ("%ss:" + intel_syntax);
d3998 1
a3999 1
      oappend ("%es:" + intel_syntax);
d4003 1
a4004 1
      oappend ("%fs:" + intel_syntax);
d4008 1
a4009 1
      oappend ("%gs:" + intel_syntax);
d4038 1
a4038 1
	  for (i = 0; tmp[i] == '0' && tmp[i + 1]; i++);
d4050 1
a4050 1
	      /* Check for possible overflow on 0x8000000000000000.  */
d4067 1
a4067 1
	      tmp[28 - i] = (v % 10) + '0';
d4095 1
a4095 1
  /* Skip mod/rm byte.  */
a4125 1
	case dq_mode:
d4129 1
a4129 1
	  else if ((sizeflag & DFLAG) || bytemode == dq_mode)
d4136 1
a4136 1
	  if (!(codep[-2] == 0xAE && codep[-1] == 0xF8 /* sfence */)
d4139 1
a4139 1
	    BadOp ();	/* bad sfence,lea,lds,les,lfs,lgs,lss modrm */
d4151 1
a4151 1
  if ((sizeflag & AFLAG) || mode_64bit) /* 32 bit address mode */
d4185 1
a4185 1
	      if (mode_64bit && !havesib && (sizeflag & AFLAG))
d4202 2
a4203 2
	if (mod != 0 || (base & 7) == 5)
	  {
d4205 1
a4205 1
	    oappend (scratchbuf);
d4211 1
a4211 1
	  }
d4215 17
a4231 17
	  if (intel_syntax)
	    {
	      switch (bytemode)
		{
		case b_mode:
		  oappend ("BYTE PTR ");
		  break;
		case w_mode:
		  oappend ("WORD PTR ");
		  break;
		case v_mode:
		  oappend ("DWORD PTR ");
		  break;
		case d_mode:
		  oappend ("QWORD PTR ");
		  break;
		case m_mode:
d4237 7
a4243 7
		case x_mode:
		  oappend ("XWORD PTR ");
		  break;
		default:
		  break;
		}
	     }
d4247 1
a4247 1
	  *obufp = '\0';
d4252 1
a4252 2
	    oappend (mode_64bit && (sizeflag & AFLAG)
		     ? names64[base] : names32[base]);
d4257 11
a4267 26
		  if (intel_syntax)
		    {
		      if (havebase)
			{
			  *obufp++ = separator_char;
			  *obufp = '\0';
			}
		      sprintf (scratchbuf, "%s",
			       mode_64bit && (sizeflag & AFLAG)
			       ? names64[index] : names32[index]);
		    }
		  else
		    sprintf (scratchbuf, ",%s",
			     mode_64bit && (sizeflag & AFLAG)
			     ? names64[index] : names32[index]);
		  oappend (scratchbuf);
		}
	      if (!intel_syntax
		  || (intel_syntax
		      && bytemode != b_mode
		      && bytemode != w_mode
		      && bytemode != v_mode))
		{
		  *obufp++ = scale_char;
		  *obufp = '\0';
		  sprintf (scratchbuf, "%d", 1 << scale);
d4270 11
d4282 6
a4287 12
	  if (intel_syntax)
	    if (mod != 0 || (base & 7) == 5)
	      {
		/* Don't print zero displacements.  */
		if (disp != 0)
		  {
		    if ((bfd_signed_vma) disp > 0)
		      {
			*obufp++ = '+';
			*obufp = '\0';
		      }

d4289 3
a4291 3
		    oappend (scratchbuf);
		  }
	      }
d4294 1
a4294 1
	  *obufp = '\0';
d4297 3
a4299 3
	{
	  if (mod != 0 || (base & 7) == 5)
	    {
d4305 1
a4305 1
		  oappend (names_seg[ds_reg - es_reg]);
d4309 3
a4311 3
	      oappend (scratchbuf);
	    }
	}
d4339 2
a4340 2
	if (mod != 0 || (rm & 7) == 6)
	  {
d4342 2
a4343 2
	    oappend (scratchbuf);
	  }
d4348 1
a4348 1
	  *obufp = '\0';
d4350 2
a4351 2
	  *obufp++ = close_char;
	  *obufp = '\0';
d4402 4
a4405 1
  bfd_vma x;
a4406 3
  unsigned int a;
  unsigned int b;

d4412 1
a4412 1
  b = *codep++ & 0xff;
d4418 1
a4418 2
  abort ();
  x = 0;
d4465 1
a4465 1
     bfd_vma op;
d4469 2
a4470 11
  if (mode_64bit)
    {
      op_address[op_ad] = op;
      op_riprel[op_ad] = riprel;
    }
  else
    {
      /* Mask to get a 32-bit address.  */
      op_address[op_ad] = op & 0xffffffff;
      op_riprel[op_ad] = riprel & 0xffffffff;
    }
d4487 1
a4487 4
      if (intel_syntax)
	s = "[dx]";
      else
	s = "(%dx)";
a4504 9
    case rAX_reg: case rCX_reg: case rDX_reg: case rBX_reg:
    case rSP_reg: case rBP_reg: case rSI_reg: case rDI_reg:
      if (mode_64bit)
	{
	  s = names64[code - rAX_reg + add];
	  break;
	}
      code += eAX_reg - rAX_reg;
      /* Fall through.  */
d4516 4
d4537 1
a4537 4
      if (intel_syntax)
	s = "[dx]";
      else
	s = "(%dx)";
d4589 2
a4590 6
      if (mode_64bit)
	{
	  op = get32s ();
	  break;
	}
      /* Fall through.  */
d4618 2
a4619 2
  print_operand_value (scratchbuf + 1, 1, op);
  oappend (scratchbuf + intel_syntax);
a4630 6
  if (!mode_64bit)
    {
      OP_I (bytemode, sizeflag);
      return;
    }

d4665 2
a4666 2
  print_operand_value (scratchbuf + 1, 1, op);
  oappend (scratchbuf + intel_syntax);
d4699 1
a4699 1
	  op = get16 ();
d4718 1
a4718 1
  oappend (scratchbuf + intel_syntax);
d4727 1
a4727 1
  bfd_vma mask = -1;
d4743 1
a4743 1
	  /* For some reason, a data16 prefix on a jump instruction
d4759 1
d4765 5
a4769 1
  oappend (names_seg[reg]);
d4772 1
d4791 1
a4791 4
  if (intel_syntax)
    sprintf (scratchbuf, "0x%x,0x%x", seg, offset);
  else
    sprintf (scratchbuf, "$0x%x,$0x%x", seg, offset);
d4795 1
d4797 2
a4798 2
OP_OFF (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
d4805 1
a4805 1
  if ((sizeflag & AFLAG) || mode_64bit)
d4813 1
a4813 1
			| PREFIX_ES | PREFIX_FS | PREFIX_GS)))
d4815 1
a4815 1
	  oappend (names_seg[ds_reg - es_reg]);
d4822 1
a4822 1

d4824 2
a4825 2
OP_OFF64 (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
a4829 6
  if (!mode_64bit)
    {
      OP_OFF (bytemode, sizeflag);
      return;
    }

d4832 1
a4832 1
  off = get64 ();
d4837 1
a4837 1
			| PREFIX_ES | PREFIX_FS | PREFIX_GS)))
d4839 1
a4839 1
	  oappend (names_seg[ds_reg - es_reg]);
d4853 1
a4853 5
  if (intel_syntax)
    oappend ("[");
  else
    oappend ("(");

d4856 1
a4856 6
    {
      if (!(sizeflag & AFLAG))
	s = names32[code - eAX_reg];
      else
	s = names64[code - eAX_reg];
    }
d4862 1
a4862 4
  if (intel_syntax)
    oappend ("]");
  else
    oappend (")");
d4870 1
a4870 1
  oappend ("%es:" + intel_syntax);
d4887 1
a4887 1
  append_seg ();
d4891 1
d4901 2
a4902 2
  sprintf (scratchbuf, "%%cr%d", reg + add);
  oappend (scratchbuf + intel_syntax);
d4905 1
d4915 1
a4915 4
  if (intel_syntax)
    sprintf (scratchbuf, "db%d", reg + add);
  else
    sprintf (scratchbuf, "%%db%d", reg + add);
d4919 1
d4926 1
a4926 1
  oappend (scratchbuf + intel_syntax);
d4937 1
a4937 1
    BadOp ();
d4941 2
a4942 2
OP_MMX (bytemode, sizeflag)
     int bytemode ATTRIBUTE_UNUSED;
d4954 1
a4954 1
  oappend (scratchbuf + intel_syntax);
d4967 1
a4967 1
  oappend (scratchbuf + intel_syntax);
d4985 1
a4985 1
  /* Skip mod/rm byte.  */
d4993 1
a4993 1
  oappend (scratchbuf + intel_syntax);
d5011 1
a5011 1
  /* Skip mod/rm byte.  */
d5015 1
a5015 1
  oappend (scratchbuf + intel_syntax);
d5026 1
a5026 1
    BadOp ();
d5037 1
a5037 1
    BadOp ();
d5040 1
a5040 1
static const char *const Suffix3DNow[] = {
d5118 1
a5118 1
  obufp = obuf + strlen (obuf);
d5130 1
a5130 1
      BadOp ();
d5134 2
a5135 1
static const char *simd_cmp_op[] = {
d5154 1
a5154 1
  obufp = obuf + strlen (obuf);
d5184 1
a5184 1
      BadOp ();
d5197 6
a5202 6
      char *p = obuf + strlen (obuf);
      *(p + 1) = '\0';
      *p       = *(p - 1);
      *(p - 1) = *(p - 2);
      *(p - 2) = *(p - 3);
      *(p - 3) = extrachar;
d5206 1
a5206 2
static void
BadOp (void)
d5208 1
a5208 2
  /* Throw away prefixes and 1st. opcode byte.  */
  codep = insn_codep + 1;
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
a25 1
 *  VIA PadLock support by Michal Ludvig (mludvig@@suse.cz)
d51 46
a96 52
static int fetch_data (struct disassemble_info *, bfd_byte *);
static void ckprefix (void);
static const char *prefix_name (int, int);
static int print_insn (bfd_vma, disassemble_info *);
static void dofloat (int);
static void OP_ST (int, int);
static void OP_STi (int, int);
static int putop (const char *, int);
static void oappend (const char *);
static void append_seg (void);
static void OP_indirE (int, int);
static void print_operand_value (char *, int, bfd_vma);
static void OP_E (int, int);
static void OP_G (int, int);
static bfd_vma get64 (void);
static bfd_signed_vma get32 (void);
static bfd_signed_vma get32s (void);
static int get16 (void);
static void set_op (bfd_vma, int);
static void OP_REG (int, int);
static void OP_IMREG (int, int);
static void OP_I (int, int);
static void OP_I64 (int, int);
static void OP_sI (int, int);
static void OP_J (int, int);
static void OP_SEG (int, int);
static void OP_DIR (int, int);
static void OP_OFF (int, int);
static void OP_OFF64 (int, int);
static void ptr_reg (int, int);
static void OP_ESreg (int, int);
static void OP_DSreg (int, int);
static void OP_C (int, int);
static void OP_D (int, int);
static void OP_T (int, int);
static void OP_Rd (int, int);
static void OP_MMX (int, int);
static void OP_XMM (int, int);
static void OP_EM (int, int);
static void OP_EX (int, int);
static void OP_MS (int, int);
static void OP_XS (int, int);
static void OP_M (int, int);
static void OP_0fae (int, int);
static void OP_0f07 (int, int);
static void NOP_Fixup (int, int);
static void OP_3DNowSuffix (int, int);
static void OP_SIMD_Suffix (int, int);
static void SIMD_Fixup (int, int);
static void PNI_Fixup (int, int);
static void INVLPG_Fixup (int, int);
static void BadOp (void);
d163 3
a165 1
fetch_data (struct disassemble_info *info, bfd_byte *addr)
d200 2
a201 2
#define M OP_M, 0		/* lea, lgdt, etc. */
#define Mp OP_M, 0		/* 32 or 48 bit memory operand for LDS, LES etc */
d294 1
a391 1
#define GRPPADLCK NULL, NULL, USE_GROUPS, NULL, 23, NULL, 0
a419 6
#define PREGRP27  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 27, NULL, 0
#define PREGRP28  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 28, NULL, 0
#define PREGRP29  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 29, NULL, 0
#define PREGRP30  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 30, NULL, 0
#define PREGRP31  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 31, NULL, 0
#define PREGRP32  NULL, NULL, USE_PREFIX_USER_TABLE, NULL, 32, NULL, 0
d423 1
a423 1
typedef void (*op_rtn) (int bytemode, int sizeflag);
d629 2
a630 1
  { "nop",		NOP_Fixup, 0, XX, XX },
d779 1
a779 1
  { PREGRP30 },
d783 1
a783 1
  { PREGRP31 },
d898 2
a899 2
  { PREGRP28 },
  { PREGRP29 },
d946 1
a946 1
  { GRPPADLCK },
d993 1
a993 1
  { PREGRP27 },
d1029 1
a1029 1
  { PREGRP32 },
d1081 1
a1081 1
  /* 70 */ 1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1, /* 7f */
d1084 1
a1084 1
  /* a0 */ 0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1, /* af */
d1087 1
a1087 1
  /* d0 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* df */
d1089 1
a1089 1
  /* f0 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0  /* ff */
d1098 1
a1098 1
  /* 10 */ 1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0, /* 1f */
d1104 1
a1104 1
  /* 70 */ 1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1, /* 7f */
d1110 1
a1110 1
  /* d0 */ 1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0, /* df */
d1112 1
a1112 1
  /* f0 */ 1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0  /* ff */
d1352 1
a1352 1
    { "sidtQ", PNI_Fixup, 0, XX, XX },
d1358 1
a1358 1
    { "invlpg",	INVLPG_Fixup, w_mode, XX, XX },
d1422 4
a1425 3
    { "lfence", OP_0fae, 0, XX, XX },
    { "mfence", OP_0fae, 0, XX, XX },
    { "clflush", OP_0fae, 0, XX, XX },
a1447 11
  },
  /* GRPPADLCK */
  {
    { "xstorerng", OP_0f07, 0, XX, XX },
    { "xcryptecb", OP_0f07, 0, XX, XX },
    { "xcryptcbc", OP_0f07, 0, XX, XX },
    { "(bad)",	   OP_0f07, 0, XX, XX },
    { "xcryptcfb", OP_0f07, 0, XX, XX },
    { "xcryptofb", OP_0f07, 0, XX, XX },
    { "(bad)",	   OP_0f07, 0, XX, XX },
    { "(bad)",	   OP_0f07, 0, XX, XX },
a1640 42
  /* PREGRP27 */
  {
    { "(bad)", MX, EX, XX },
    { "(bad)", XM, EX, XX },
    { "addsubpd", XM, EX, XX },
    { "addsubps", XM, EX, XX },
  },
  /* PREGRP28 */
  {
    { "(bad)", MX, EX, XX },
    { "(bad)", XM, EX, XX },
    { "haddpd", XM, EX, XX },
    { "haddps", XM, EX, XX },
  },
  /* PREGRP29 */
  {
    { "(bad)", MX, EX, XX },
    { "(bad)", XM, EX, XX },
    { "hsubpd", XM, EX, XX },
    { "hsubps", XM, EX, XX },
  },
  /* PREGRP30 */
  {
    { "movlpX", XM, EX, SIMD_Fixup, 'h' }, /* really only 2 operands */
    { "movsldup", XM, EX, XX },
    { "movlpd", XM, EX, XX },
    { "movddup", XM, EX, XX },
  },
  /* PREGRP31 */
  {
    { "movhpX", XM, EX, SIMD_Fixup, 'l' },
    { "movshdup", XM, EX, XX },
    { "movhpd", XM, EX, XX },
    { "(bad)", XM, EX, XX },
  },
  /* PREGRP32 */
  {
    { "(bad)", XM, EX, XX },
    { "(bad)", XM, EX, XX },
    { "(bad)", XM, EX, XX },
    { "lddqu", XM, M, XX },
  },
d1653 1
a1653 1
ckprefix (void)
d1751 3
a1753 1
prefix_name (int pref, int sizeflag)
d1847 3
a1849 1
print_insn_i386_att (bfd_vma pc, disassemble_info *info)
d1857 3
a1859 1
print_insn_i386_intel (bfd_vma pc, disassemble_info *info)
d1867 3
a1869 1
print_insn_i386 (bfd_vma pc, disassemble_info *info)
d1877 3
a1879 1
print_insn (bfd_vma pc, disassemble_info *info)
d1988 1
a1988 1
  info->private_data = &priv;
d2297 1
a2297 1
  "fisttp{l||l|}",
d2315 1
a2315 1
  "fisttpll",
d2333 1
a2333 1
  "fisttp",
d2509 2
a2510 1
dofloat (int sizeflag)
d2556 3
a2558 1
OP_ST (int bytemode ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
d2564 3
a2566 1
OP_STi (int bytemode ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
d2574 3
a2576 1
putop (const char *template, int sizeflag)
d2849 2
a2850 1
oappend (const char *s)
d2857 1
a2857 1
append_seg (void)
d2892 3
a2894 1
OP_indirE (int bytemode, int sizeflag)
d2902 4
a2905 1
print_operand_value (char *buf, int hex, bfd_vma disp)
d2962 3
a2964 1
OP_E (int bytemode, int sizeflag)
d3015 4
d3154 5
a3158 1
	      if (scale != 0 || (!intel_syntax && index != 4))
d3247 3
a3249 1
OP_G (int bytemode, int sizeflag)
d3290 1
a3290 1
get64 (void)
d3315 1
a3315 1
get32 (void)
d3328 1
a3328 1
get32s (void)
d3344 1
a3344 1
get16 (void)
d3355 3
a3357 1
set_op (bfd_vma op, int riprel)
d3374 3
a3376 1
OP_REG (int code, int sizeflag)
d3436 3
a3438 1
OP_IMREG (int code, int sizeflag)
d3485 3
a3487 1
OP_I (int bytemode, int sizeflag)
d3539 3
a3541 1
OP_I64 (int bytemode, int sizeflag)
d3592 3
a3594 1
OP_sI (int bytemode, int sizeflag)
d3643 3
a3645 1
OP_J (int bytemode, int sizeflag)
d3681 3
a3683 1
OP_SEG (int dummy ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
d3689 3
a3691 1
OP_DIR (int dummy ATTRIBUTE_UNUSED, int sizeflag)
d3714 3
a3716 1
OP_OFF (int bytemode ATTRIBUTE_UNUSED, int sizeflag)
d3741 3
a3743 1
OP_OFF64 (int bytemode ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
d3771 3
a3773 1
ptr_reg (int code, int sizeflag)
d3801 3
a3803 1
OP_ESreg (int code, int sizeflag)
d3810 3
a3812 1
OP_DSreg (int code, int sizeflag)
d3827 3
a3829 1
OP_C (int dummy ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
d3840 3
a3842 1
OP_D (int dummy ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
d3856 3
a3858 1
OP_T (int dummy ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
d3865 3
a3867 1
OP_Rd (int bytemode, int sizeflag)
d3876 3
a3878 1
OP_MMX (int bytemode ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
d3893 3
a3895 1
OP_XMM (int bytemode ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
d3906 3
a3908 1
OP_EM (int bytemode, int sizeflag)
d3932 3
a3934 1
OP_EX (int bytemode, int sizeflag)
d3954 3
a3956 1
OP_MS (int bytemode, int sizeflag)
d3965 3
a3967 1
OP_XS (int bytemode, int sizeflag)
a3974 49
static void
OP_M (int bytemode, int sizeflag)
{
  if (mod == 3)
    BadOp ();	/* bad lea,lds,les,lfs,lgs,lss modrm */
  else
    OP_E (bytemode, sizeflag);
}

static void
OP_0f07 (int bytemode, int sizeflag)
{
  if (mod != 3 || rm != 0)
    BadOp ();
  else
    OP_E (bytemode, sizeflag);
}

static void
OP_0fae (int bytemode, int sizeflag)
{
  if (mod == 3)
    {
      if (reg == 7)
	strcpy (obuf + strlen (obuf) - sizeof ("clflush") + 1, "sfence");

      if (reg < 5 || rm != 0)
	{
	  BadOp ();	/* bad sfence, mfence, or lfence */
	  return;
	}
    }
  else if (reg != 7)
    {
      BadOp ();		/* bad clflush */
      return;
    }

  OP_E (bytemode, sizeflag);
}

static void
NOP_Fixup (int bytemode ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
{
  /* NOP with REPZ prefix is called PAUSE.  */
  if (prefixes == PREFIX_REPZ)
    strcpy (obuf, "pause");
}

d4043 3
a4045 1
OP_3DNowSuffix (int bytemode ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
d4081 3
a4083 1
OP_SIMD_Suffix (int bytemode ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
d4123 3
a4125 1
SIMD_Fixup (int extrachar, int sizeflag ATTRIBUTE_UNUSED)
a4137 40
}

static void
PNI_Fixup (int extrachar ATTRIBUTE_UNUSED, int sizeflag)
{
  if (mod == 3 && reg == 1)
    {
      char *p = obuf + strlen (obuf);

      /* Override "sidt".  */
      if (rm)
	{
	  /* mwait %eax,%ecx  */
	  strcpy (p - 4, "mwait   %eax,%ecx");
	}
      else
	{
	  /* monitor %eax,%ecx,%edx"  */
	  strcpy (p - 4, "monitor %eax,%ecx,%edx");
	}

      codep++;
    }
  else
    OP_E (0, sizeflag);
}

static void
INVLPG_Fixup (int bytemode, int sizeflag)
{
  if (*codep == 0xf8)
    {
      char *p = obuf + strlen (obuf);

      /* Override "invlpg".  */
      strcpy (p - 6, "swapgs");
      codep++;
    }
  else
    OP_E (bytemode, sizeflag);
@


