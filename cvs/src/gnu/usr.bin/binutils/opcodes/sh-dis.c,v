head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.48
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.44
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.46
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.38
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.42
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.40
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BINUTILS_2_15:1.1.1.6
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.5
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.4
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.3
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.11.02.20.45.56;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.17.21.54.55;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.44;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.13.01;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.55.51;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.05;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.05;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.04.23;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.09.12.14.48.00;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.05.13.13.58.36;	author fgsch;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.05.17.20.42.46;	author drahn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.11.02.20.23.15;	author miod;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* Disassemble SH instructions.
   Copyright 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include <stdio.h>
#include "sysdep.h"
#define STATIC_TABLE
#define DEFINE_TABLE

#include "sh-opc.h"
#include "dis-asm.h"

#ifdef ARCH_all
#define INCLUDE_SHMEDIA
#endif

static void print_movxy
  PARAMS ((const sh_opcode_info *, int, int, fprintf_ftype, void *));
static void print_insn_ddt PARAMS ((int, struct disassemble_info *));
static void print_dsp_reg PARAMS ((int, fprintf_ftype, void *));
static void print_insn_ppi PARAMS ((int, struct disassemble_info *));

static void
print_movxy (op, rn, rm, fprintf_fn, stream)
     const sh_opcode_info *op;
     int rn, rm;
     fprintf_ftype fprintf_fn;
     void *stream;
{
  int n;

  fprintf_fn (stream, "%s\t", op->name);
  for (n = 0; n < 2; n++)
    {
      switch (op->arg[n])
	{
	case A_IND_N:
	case AX_IND_N:
	case AXY_IND_N:
	case AY_IND_N:
	case AYX_IND_N:
	  fprintf_fn (stream, "@@r%d", rn);
	  break;
	case A_INC_N:
	case AX_INC_N:
	case AXY_INC_N:
	case AY_INC_N:
	case AYX_INC_N:
	  fprintf_fn (stream, "@@r%d+", rn);
	  break;
	case AX_PMOD_N:
	case AXY_PMOD_N:
	  fprintf_fn (stream, "@@r%d+r8", rn);
	  break;
	case AY_PMOD_N:
	case AYX_PMOD_N:
	  fprintf_fn (stream, "@@r%d+r9", rn);
	  break;
	case DSP_REG_A_M:
	  fprintf_fn (stream, "a%c", '0' + rm);
	  break;
	case DSP_REG_X:
	  fprintf_fn (stream, "x%c", '0' + rm);
	  break;
	case DSP_REG_Y:
	  fprintf_fn (stream, "y%c", '0' + rm);
	  break;
	case DSP_REG_AX:
	  fprintf_fn (stream, "%c%c",
		      (rm & 1) ? 'x' : 'a',
		      (rm & 2) ? '1' : '0');
	  break;
	case DSP_REG_XY:
	  fprintf_fn (stream, "%c%c",
		      (rm & 1) ? 'y' : 'x',
		      (rm & 2) ? '1' : '0');
	  break;
	case DSP_REG_AY:
	  fprintf_fn (stream, "%c%c",
		      (rm & 2) ? 'y' : 'a',
		      (rm & 1) ? '1' : '0');
	  break;
	case DSP_REG_YX:
	  fprintf_fn (stream, "%c%c",
		      (rm & 2) ? 'x' : 'y',
		      (rm & 1) ? '1' : '0');
	  break;
	default:
	  abort ();
	}
      if (n == 0)
	fprintf_fn (stream, ",");
    }
}

/* Print a double data transfer insn.  INSN is just the lower three
   nibbles of the insn, i.e. field a and the bit that indicates if
   a parallel processing insn follows.
   Return nonzero if a field b of a parallel processing insns follows.  */

static void
print_insn_ddt (insn, info)
     int insn;
     struct disassemble_info *info;
{
  fprintf_ftype fprintf_fn = info->fprintf_func;
  void *stream = info->stream;

  /* If this is just a nop, make sure to emit something.  */
  if (insn == 0x000)
    fprintf_fn (stream, "nopx\tnopy");

  /* If a parallel processing insn was printed before,
     and we got a non-nop, emit a tab.  */
  if ((insn & 0x800) && (insn & 0x3ff))
    fprintf_fn (stream, "\t");

  /* Check if either the x or y part is invalid.  */
  if (((insn & 0xc) == 0 && (insn & 0x2a0))
      || ((insn & 3) == 0 && (insn & 0x150)))
    if (info->mach != bfd_mach_sh_dsp
        && info->mach != bfd_mach_sh3_dsp)
      {
	static const sh_opcode_info *first_movx, *first_movy;
	const sh_opcode_info *op;
	int is_movy;

	if (! first_movx)
	  {
	    for (first_movx = sh_table; first_movx->nibbles[1] != MOVX_NOPY;)
	      first_movx++;
	    for (first_movy = first_movx; first_movy->nibbles[1] != MOVY_NOPX;)
	      first_movy++;
	  }

	is_movy = ((insn & 3) != 0);

	if (is_movy)
	  op = first_movy;
	else
	  op = first_movx;

	while (op->nibbles[2] != (unsigned) ((insn >> 4) & 3)
	       || op->nibbles[3] != (unsigned) (insn & 0xf))
	  op++;
	
	print_movxy (op,
		     (4 * ((insn & (is_movy ? 0x200 : 0x100)) == 0)
		      + 2 * is_movy
		      + 1 * ((insn & (is_movy ? 0x100 : 0x200)) != 0)),
		     (insn >> 6) & 3,
		     fprintf_fn, stream);
      }
    else
      fprintf_fn (stream, ".word 0x%x", insn);
  else
    {
      static const sh_opcode_info *first_movx, *first_movy;
      const sh_opcode_info *opx, *opy;
      unsigned int insn_x, insn_y;

      if (! first_movx)
	{
	  for (first_movx = sh_table; first_movx->nibbles[1] != MOVX;)
	    first_movx++;
	  for (first_movy = first_movx; first_movy->nibbles[1] != MOVY;)
	    first_movy++;
	}
      insn_x = (insn >> 2) & 0xb;
      if (insn_x)
	{
	  for (opx = first_movx; opx->nibbles[2] != insn_x;)
	    opx++;
	  print_movxy (opx, ((insn >> 9) & 1) + 4, (insn >> 7) & 1,
		       fprintf_fn, stream);
	}
      insn_y = (insn & 3) | ((insn >> 1) & 8);
      if (insn_y)
	{
	  if (insn_x)
	    fprintf_fn (stream, "\t");
	  for (opy = first_movy; opy->nibbles[2] != insn_y;)
	    opy++;
	  print_movxy (opy, ((insn >> 8) & 1) + 6, (insn >> 6) & 1,
		       fprintf_fn, stream);
	}
    }
}

static void
print_dsp_reg (rm, fprintf_fn, stream)
     int rm;
     fprintf_ftype fprintf_fn;
     void *stream;
{
  switch (rm)
    {
    case A_A1_NUM:
      fprintf_fn (stream, "a1");
      break;
    case A_A0_NUM:
      fprintf_fn (stream, "a0");
      break;
    case A_X0_NUM:
      fprintf_fn (stream, "x0");
      break;
    case A_X1_NUM:
      fprintf_fn (stream, "x1");
      break;
    case A_Y0_NUM:
      fprintf_fn (stream, "y0");
      break;
    case A_Y1_NUM:
      fprintf_fn (stream, "y1");
      break;
    case A_M0_NUM:
      fprintf_fn (stream, "m0");
      break;
    case A_A1G_NUM:
      fprintf_fn (stream, "a1g");
      break;
    case A_M1_NUM:
      fprintf_fn (stream, "m1");
      break;
    case A_A0G_NUM:
      fprintf_fn (stream, "a0g");
      break;
    default:
      fprintf_fn (stream, "0x%x", rm);
      break;
    }
}

static void
print_insn_ppi (field_b, info)
     int field_b;
     struct disassemble_info *info;
{
  static char *sx_tab[] = { "x0", "x1", "a0", "a1" };
  static char *sy_tab[] = { "y0", "y1", "m0", "m1" };
  fprintf_ftype fprintf_fn = info->fprintf_func;
  void *stream = info->stream;
  unsigned int nib1, nib2, nib3;
  unsigned int altnib1, nib4;
  char *dc = NULL;
  const sh_opcode_info *op;

  if ((field_b & 0xe800) == 0)
    {
      fprintf_fn (stream, "psh%c\t#%d,",
		  field_b & 0x1000 ? 'a' : 'l',
		  (field_b >> 4) & 127);
      print_dsp_reg (field_b & 0xf, fprintf_fn, stream);
      return;
    }
  if ((field_b & 0xc000) == 0x4000 && (field_b & 0x3000) != 0x1000)
    {
      static char *du_tab[] = { "x0", "y0", "a0", "a1" };
      static char *se_tab[] = { "x0", "x1", "y0", "a1" };
      static char *sf_tab[] = { "y0", "y1", "x0", "a1" };
      static char *sg_tab[] = { "m0", "m1", "a0", "a1" };

      if (field_b & 0x2000)
	{
	  fprintf_fn (stream, "p%s %s,%s,%s\t",
		      (field_b & 0x1000) ? "add" : "sub",
		      sx_tab[(field_b >> 6) & 3],
		      sy_tab[(field_b >> 4) & 3],
		      du_tab[(field_b >> 0) & 3]);
	}
      else if ((field_b & 0xf0) == 0x10
	       && info->mach != bfd_mach_sh_dsp
	       && info->mach != bfd_mach_sh3_dsp)
	{
	  fprintf_fn (stream, "pclr %s \t", du_tab[(field_b >> 0) & 3]);
	}
      else if ((field_b & 0xf3) != 0)
	{
	  fprintf_fn (stream, ".word 0x%x\t", field_b);
	}
      fprintf_fn (stream, "pmuls%c%s,%s,%s",
		  field_b & 0x2000 ? ' ' : '\t',
		  se_tab[(field_b >> 10) & 3],
		  sf_tab[(field_b >>  8) & 3],
		  sg_tab[(field_b >>  2) & 3]);
      return;
    }

  nib1 = PPIC;
  nib2 = field_b >> 12 & 0xf;
  nib3 = field_b >> 8 & 0xf;
  nib4 = field_b >> 4 & 0xf;
  switch (nib3 & 0x3)
    {
    case 0:
      dc = "";
      nib1 = PPI3;
      break;
    case 1:
      dc = "";
      break;
    case 2:
      dc = "dct ";
      nib3 -= 1;
      break;
    case 3:
      dc = "dcf ";
      nib3 -= 2;
      break;
    }
  if (nib1 == PPI3)
    altnib1 = PPI3NC;
  else
    altnib1 = nib1;
  for (op = sh_table; op->name; op++)
    {
      if ((op->nibbles[1] == nib1 || op->nibbles[1] == altnib1)
	  && op->nibbles[2] == nib2
	  && op->nibbles[3] == nib3)
	{
	  int n;

	  switch (op->nibbles[4])
	    {
	    case HEX_0:
	      break;
	    case HEX_XX00:
	      if ((nib4 & 3) != 0)
		continue;
	      break;
	    case HEX_1:
	      if ((nib4 & 3) != 1)
		continue;
	      break;
	    case HEX_00YY:
	      if ((nib4 & 0xc) != 0)
		continue;
	      break;
	    case HEX_4:
	      if ((nib4 & 0xc) != 4)
		continue;
	      break;
	    default:
	      abort ();
	    }
	  fprintf_fn (stream, "%s%s\t", dc, op->name);
	  for (n = 0; n < 3 && op->arg[n] != A_END; n++)
	    {
	      if (n && op->arg[1] != A_END)
		fprintf_fn (stream, ",");
	      switch (op->arg[n])
		{
		case DSP_REG_N:
		  print_dsp_reg (field_b & 0xf, fprintf_fn, stream);
		  break;
		case DSP_REG_X:
		  fprintf_fn (stream, sx_tab[(field_b >> 6) & 3]);
		  break;
		case DSP_REG_Y:
		  fprintf_fn (stream, sy_tab[(field_b >> 4) & 3]);
		  break;
		case A_MACH:
		  fprintf_fn (stream, "mach");
		  break;
		case A_MACL:
		  fprintf_fn (stream, "macl");
		  break;
		default:
		  abort ();
		}
	    }
	  return;
	}
    }
  /* Not found.  */
  fprintf_fn (stream, ".word 0x%x", field_b);
}

int
print_insn_sh (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
{
  fprintf_ftype fprintf_fn = info->fprintf_func;
  void *stream = info->stream;
  unsigned char insn[4];
  unsigned char nibs[4];
  int status;
  bfd_vma relmask = ~(bfd_vma) 0;
  const sh_opcode_info *op;
  int target_arch;

  switch (info->mach)
    {
    case bfd_mach_sh:
      target_arch = arch_sh1;
      /* SH coff object files lack information about the machine type, so
         we end up with bfd_mach_sh unless it was set explicitly (which
	 could have happended if this is a call from gdb or the simulator.)  */
      if (info->symbols
	  && bfd_asymbol_flavour(*info->symbols) == bfd_target_coff_flavour)
	target_arch = arch_sh4;
      break;
    case bfd_mach_sh2:
      target_arch = arch_sh2;
      break;
    case bfd_mach_sh2e:
      target_arch = arch_sh2e;
      break;
    case bfd_mach_sh_dsp:
      target_arch = arch_sh_dsp;
      break;
    case bfd_mach_sh3:
      target_arch = arch_sh3;
      break;
    case bfd_mach_sh3_dsp:
      target_arch = arch_sh3_dsp;
      break;
    case bfd_mach_sh3e:
      target_arch = arch_sh3e;
      break;
    case bfd_mach_sh4:
    case bfd_mach_sh4_nofpu:
      target_arch = arch_sh4;
      break;
    case bfd_mach_sh4a:
    case bfd_mach_sh4a_nofpu:
      target_arch = arch_sh4a;
      break;
    case bfd_mach_sh4al_dsp:
      target_arch = arch_sh4al_dsp;
      break;
    case bfd_mach_sh5:
#ifdef INCLUDE_SHMEDIA
      status = print_insn_sh64 (memaddr, info);
      if (status != -2)
	return status;
#endif
      /* When we get here for sh64, it's because we want to disassemble
	 SHcompact, i.e. arch_sh4.  */
      target_arch = arch_sh4;
      break;
    default:
      abort ();
    }

  status = info->read_memory_func (memaddr, insn, 2, info);

  if (status != 0)
    {
      info->memory_error_func (status, memaddr, info);
      return -1;
    }

  if (info->endian == BFD_ENDIAN_LITTLE)
    {
      nibs[0] = (insn[1] >> 4) & 0xf;
      nibs[1] = insn[1] & 0xf;

      nibs[2] = (insn[0] >> 4) & 0xf;
      nibs[3] = insn[0] & 0xf;
    }
  else
    {
      nibs[0] = (insn[0] >> 4) & 0xf;
      nibs[1] = insn[0] & 0xf;

      nibs[2] = (insn[1] >> 4) & 0xf;
      nibs[3] = insn[1] & 0xf;
    }

  if (nibs[0] == 0xf && (nibs[1] & 4) == 0 && target_arch & arch_sh_dsp_up)
    {
      if (nibs[1] & 8)
	{
	  int field_b;

	  status = info->read_memory_func (memaddr + 2, insn, 2, info);

	  if (status != 0)
	    {
	      info->memory_error_func (status, memaddr + 2, info);
	      return -1;
	    }

	  if (info->endian == BFD_ENDIAN_LITTLE)
	    field_b = insn[1] << 8 | insn[0];
	  else
	    field_b = insn[0] << 8 | insn[1];

	  print_insn_ppi (field_b, info);
	  print_insn_ddt ((nibs[1] << 8) | (nibs[2] << 4) | nibs[3], info);
	  return 4;
	}
      print_insn_ddt ((nibs[1] << 8) | (nibs[2] << 4) | nibs[3], info);
      return 2;
    }
  for (op = sh_table; op->name; op++)
    {
      int n;
      int imm = 0;
      int rn = 0;
      int rm = 0;
      int rb = 0;
      int disp_pc;
      bfd_vma disp_pc_addr = 0;

      if ((op->arch & target_arch) == 0)
	goto fail;
      for (n = 0; n < 4; n++)
	{
	  int i = op->nibbles[n];

	  if (i < 16)
	    {
	      if (nibs[n] == i)
		continue;
	      goto fail;
	    }
	  switch (i)
	    {
	    case BRANCH_8:
	      imm = (nibs[2] << 4) | (nibs[3]);
	      if (imm & 0x80)
		imm |= ~0xff;
	      imm = ((char) imm) * 2 + 4;
	      goto ok;
	    case BRANCH_12:
	      imm = ((nibs[1]) << 8) | (nibs[2] << 4) | (nibs[3]);
	      if (imm & 0x800)
		imm |= ~0xfff;
	      imm = imm * 2 + 4;
	      goto ok;
	    case IMM0_4:
	    case IMM1_4:
	      imm = nibs[3];
	      goto ok;
	    case IMM0_4BY2:
	    case IMM1_4BY2:
	      imm = nibs[3] << 1;
	      goto ok;
	    case IMM0_4BY4:
	    case IMM1_4BY4:
	      imm = nibs[3] << 2;
	      goto ok;
	    case IMM0_8:
	    case IMM1_8:
	      imm = (nibs[2] << 4) | nibs[3];
	      goto ok;
	    case PCRELIMM_8BY2:
	      imm = ((nibs[2] << 4) | nibs[3]) << 1;
	      relmask = ~(bfd_vma) 1;
	      goto ok;
	    case PCRELIMM_8BY4:
	      imm = ((nibs[2] << 4) | nibs[3]) << 2;
	      relmask = ~(bfd_vma) 3;
	      goto ok;
	    case IMM0_8BY2:
	    case IMM1_8BY2:
	      imm = ((nibs[2] << 4) | nibs[3]) << 1;
	      goto ok;
	    case IMM0_8BY4:
	    case IMM1_8BY4:
	      imm = ((nibs[2] << 4) | nibs[3]) << 2;
	      goto ok;
	    case REG_N_D:
	      if ((nibs[n] & 1) != 0)
		goto fail;
	      /* fall through */
	    case REG_N:
	      rn = nibs[n];
	      break;
	    case REG_M:
	      rm = nibs[n];
	      break;
	    case REG_N_B01:
	      if ((nibs[n] & 0x3) != 1 /* binary 01 */)
		goto fail;
	      rn = (nibs[n] & 0xc) >> 2;
	      break;
	    case REG_NM:
	      rn = (nibs[n] & 0xc) >> 2;
	      rm = (nibs[n] & 0x3);
	      break;
	    case REG_B:
	      rb = nibs[n] & 0x07;
	      break;
	    case SDT_REG_N:
	      /* sh-dsp: single data transfer.  */
	      rn = nibs[n];
	      if ((rn & 0xc) != 4)
		goto fail;
	      rn = rn & 0x3;
	      rn |= (!(rn & 2)) << 2;
	      break;
	    case PPI:
	    case REPEAT:
	      goto fail;
	    default:
	      abort ();
	    }
	}

    ok:
      fprintf_fn (stream, "%s\t", op->name);
      disp_pc = 0;
      for (n = 0; n < 3 && op->arg[n] != A_END; n++)
	{
	  if (n && op->arg[1] != A_END)
	    fprintf_fn (stream, ",");
	  switch (op->arg[n])
	    {
	    case A_IMM:
	      fprintf_fn (stream, "#%d", (char) (imm));
	      break;
	    case A_R0:
	      fprintf_fn (stream, "r0");
	      break;
	    case A_REG_N:
	      fprintf_fn (stream, "r%d", rn);
	      break;
	    case A_INC_N:
	    case AS_INC_N:
	      fprintf_fn (stream, "@@r%d+", rn);
	      break;
	    case A_DEC_N:
	    case AS_DEC_N:
	      fprintf_fn (stream, "@@-r%d", rn);
	      break;
	    case A_IND_N:
	    case AS_IND_N:
	      fprintf_fn (stream, "@@r%d", rn);
	      break;
	    case A_DISP_REG_N:
	      fprintf_fn (stream, "@@(%d,r%d)", imm, rn);
	      break;
	    case AS_PMOD_N:
	      fprintf_fn (stream, "@@r%d+r8", rn);
	      break;
	    case A_REG_M:
	      fprintf_fn (stream, "r%d", rm);
	      break;
	    case A_INC_M:
	      fprintf_fn (stream, "@@r%d+", rm);
	      break;
	    case A_DEC_M:
	      fprintf_fn (stream, "@@-r%d", rm);
	      break;
	    case A_IND_M:
	      fprintf_fn (stream, "@@r%d", rm);
	      break;
	    case A_DISP_REG_M:
	      fprintf_fn (stream, "@@(%d,r%d)", imm, rm);
	      break;
	    case A_REG_B:
	      fprintf_fn (stream, "r%d_bank", rb);
	      break;
	    case A_DISP_PC:
	      disp_pc = 1;
	      disp_pc_addr = imm + 4 + (memaddr & relmask);
	      (*info->print_address_func) (disp_pc_addr, info);
	      break;
	    case A_IND_R0_REG_N:
	      fprintf_fn (stream, "@@(r0,r%d)", rn);
	      break;
	    case A_IND_R0_REG_M:
	      fprintf_fn (stream, "@@(r0,r%d)", rm);
	      break;
	    case A_DISP_GBR:
	      fprintf_fn (stream, "@@(%d,gbr)", imm);
	      break;
	    case A_R0_GBR:
	      fprintf_fn (stream, "@@(r0,gbr)");
	      break;
	    case A_BDISP12:
	    case A_BDISP8:
	      (*info->print_address_func) (imm + memaddr, info);
	      break;
	    case A_SR:
	      fprintf_fn (stream, "sr");
	      break;
	    case A_GBR:
	      fprintf_fn (stream, "gbr");
	      break;
	    case A_VBR:
	      fprintf_fn (stream, "vbr");
	      break;
	    case A_DSR:
	      fprintf_fn (stream, "dsr");
	      break;
	    case A_MOD:
	      fprintf_fn (stream, "mod");
	      break;
	    case A_RE:
	      fprintf_fn (stream, "re");
	      break;
	    case A_RS:
	      fprintf_fn (stream, "rs");
	      break;
	    case A_A0:
	      fprintf_fn (stream, "a0");
	      break;
	    case A_X0:
	      fprintf_fn (stream, "x0");
	      break;
	    case A_X1:
	      fprintf_fn (stream, "x1");
	      break;
	    case A_Y0:
	      fprintf_fn (stream, "y0");
	      break;
	    case A_Y1:
	      fprintf_fn (stream, "y1");
	      break;
	    case DSP_REG_M:
	      print_dsp_reg (rm, fprintf_fn, stream);
	      break;
	    case A_SSR:
	      fprintf_fn (stream, "ssr");
	      break;
	    case A_SPC:
	      fprintf_fn (stream, "spc");
	      break;
	    case A_MACH:
	      fprintf_fn (stream, "mach");
	      break;
	    case A_MACL:
	      fprintf_fn (stream, "macl");
	      break;
	    case A_PR:
	      fprintf_fn (stream, "pr");
	      break;
	    case A_SGR:
	      fprintf_fn (stream, "sgr");
	      break;
	    case A_DBR:
	      fprintf_fn (stream, "dbr");
	      break;
	    case F_REG_N:
	      fprintf_fn (stream, "fr%d", rn);
	      break;
	    case F_REG_M:
	      fprintf_fn (stream, "fr%d", rm);
	      break;
	    case DX_REG_N:
	      if (rn & 1)
		{
		  fprintf_fn (stream, "xd%d", rn & ~1);
		  break;
		}
	    case D_REG_N:
	      fprintf_fn (stream, "dr%d", rn);
	      break;
	    case DX_REG_M:
	      if (rm & 1)
		{
		  fprintf_fn (stream, "xd%d", rm & ~1);
		  break;
		}
	    case D_REG_M:
	      fprintf_fn (stream, "dr%d", rm);
	      break;
	    case FPSCR_M:
	    case FPSCR_N:
	      fprintf_fn (stream, "fpscr");
	      break;
	    case FPUL_M:
	    case FPUL_N:
	      fprintf_fn (stream, "fpul");
	      break;
	    case F_FR0:
	      fprintf_fn (stream, "fr0");
	      break;
	    case V_REG_N:
	      fprintf_fn (stream, "fv%d", rn * 4);
	      break;
	    case V_REG_M:
	      fprintf_fn (stream, "fv%d", rm * 4);
	      break;
	    case XMTRX_M4:
	      fprintf_fn (stream, "xmtrx");
	      break;
	    default:
	      abort ();
	    }
	}

#if 0
      /* This code prints instructions in delay slots on the same line
         as the instruction which needs the delay slots.  This can be
         confusing, since other disassembler don't work this way, and
         it means that the instructions are not all in a line.  So I
         disabled it.  Ian.  */
      if (!(info->flags & 1)
	  && (op->name[0] == 'j'
	      || (op->name[0] == 'b'
		  && (op->name[1] == 'r'
		      || op->name[1] == 's'))
	      || (op->name[0] == 'r' && op->name[1] == 't')
	      || (op->name[0] == 'b' && op->name[2] == '.')))
	{
	  info->flags |= 1;
	  fprintf_fn (stream, "\t(slot ");
	  print_insn_sh (memaddr + 2, info);
	  info->flags &= ~1;
	  fprintf_fn (stream, ")");
	  return 4;
	}
#endif

      if (disp_pc && strcmp (op->name, "mova") != 0)
	{
	  int size;
	  bfd_byte bytes[4];

	  if (relmask == ~(bfd_vma) 1)
	    size = 2;
	  else
	    size = 4;
	  status = info->read_memory_func (disp_pc_addr, bytes, size, info);
	  if (status == 0)
	    {
	      unsigned int val;

	      if (size == 2)
		{
		  if (info->endian == BFD_ENDIAN_LITTLE)
		    val = bfd_getl16 (bytes);
		  else
		    val = bfd_getb16 (bytes);
		}
	      else
		{
		  if (info->endian == BFD_ENDIAN_LITTLE)
		    val = bfd_getl32 (bytes);
		  else
		    val = bfd_getb32 (bytes);
		}
	      fprintf_fn (stream, "\t! 0x%x", val);
	    }
	}

      return 2;
    fail:
      ;

    }
  fprintf_fn (stream, ".word 0x%x%x%x%x", nibs[0], nibs[1], nibs[2], nibs[3]);
  return 2;
}
@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d52 4
d59 4
d65 2
a66 1
	case A_PMOD_N:
d69 2
a70 1
	case A_PMODY_N:
d73 1
a73 1
	case DSP_REG_M:
d82 20
d135 35
a169 1
    fprintf_fn (stream, ".word 0x%x", insn);
d258 1
d285 10
d306 1
d325 4
d331 1
a331 1
      if (op->nibbles[1] == nib1
d337 23
d400 1
a400 1
  unsigned char insn[2];
d437 1
d440 7
d580 4
d590 5
d637 1
d641 1
d645 1
d651 1
a651 1
	    case A_PMOD_N:
@


1.4
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1998, 2000
d5 13
a17 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d27 9
a35 1
#define LITTLE_BIT 2
d39 1
a39 1
     sh_opcode_info *op;
d108 2
a109 2
      static sh_opcode_info *first_movx, *first_movy;
      sh_opcode_info *opx, *opy;
d195 1
a195 1
  sh_opcode_info *op;
d290 2
a291 2
static int
print_insn_shx (memaddr, info)
d301 1
a301 1
  sh_opcode_info *op;
d308 6
d318 3
d336 10
d358 1
a358 1
  if (info->flags & LITTLE_BIT)
d389 1
a389 1
	  if (info->flags & LITTLE_BIT)
d488 1
a488 1
	      rn |= (rn & 2) << 1;
d695 1
a695 1
	  print_insn_shx (memaddr + 2, info);
d718 1
a718 1
		  if ((info->flags & LITTLE_BIT) != 0)
d725 1
a725 1
		  if ((info->flags & LITTLE_BIT) != 0)
a740 24
}

int
print_insn_shl (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
{
  int r;

  info->flags = LITTLE_BIT;
  r = print_insn_shx (memaddr, info);
  return r;
}

int
print_insn_sh (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
{
  int r;

  info->flags = 0;
  r = print_insn_shx (memaddr, info);
  return r;
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1993, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.
d19 1
a20 1
#include <stdio.h>
d38 1
a38 1
  fprintf_fn (stream,"%s\t", op->name);
d44 1
a44 1
	  fprintf_fn (stream, "@@r%d", rn);	
d47 1
a47 1
	  fprintf_fn (stream, "@@r%d+", rn);	
d50 1
a50 1
	  fprintf_fn (stream, "@@r%d+r8", rn);	
d53 1
a53 1
	  fprintf_fn (stream, "@@r%d+r9", rn);	
d68 1
a68 1
	fprintf_fn (stream, ",");	
d76 1
d102 1
a102 1
      int insn_x, insn_y;
d106 1
a106 1
	  for (first_movx = sh_table; first_movx->nibbles[1] != MOVX; )
d108 1
a108 1
	  for (first_movy = first_movx; first_movy->nibbles[1] != MOVY; )
d114 2
a115 1
	  for (opx = first_movx; opx->nibbles[2] != insn_x; ) opx++;
d124 2
a125 1
	  for (opy = first_movy; opy->nibbles[2] != insn_y; ) opy++;
d181 2
a182 2
  static char *sx_tab[] = {"x0","x1","a0","a1"};
  static char *sy_tab[] = {"y0","y1","m0","m1"};
d185 2
a186 2
  int nib1, nib2, nib3;
  char *dc;
d199 4
a202 4
      static char *du_tab[] = {"x0","y0","a0","a1"};
      static char *se_tab[] = {"x0","x1","y0","a1"};
      static char *sf_tab[] = {"y0","y1","x0","a1"};
      static char *sg_tab[] = {"m0","m1","a0","a1"};
d250 1
a250 1
	  for (n = 0; n < 3 && op->arg[n] != A_END; n++) 
d254 1
a254 1
	      switch (op->arg[n]) 
d269 1
a269 1
		  fprintf_fn (stream ,"macl");
d282 1
a282 1
static int 
d292 1
a292 1
  bfd_vma relmask = ~ (bfd_vma) 0;
d325 1
a325 1
  if (status != 0) 
d331 1
a331 1
  if (info->flags & LITTLE_BIT) 
d339 1
a339 1
  else 
d356 1
a356 1
	  if (status != 0) 
d362 1
a362 1
	  if (info->flags & LITTLE_BIT) 
d374 1
a374 1
  for (op = sh_table; op->name; op++) 
d390 1
a390 1
	  if (i < 16) 
d399 1
a399 1
	      imm = (nibs[2] << 4) | (nibs[3]);	  
d402 1
a402 1
	      imm = ((char)imm) * 2 + 4 ;
d410 2
a411 1
	    case IMM_4:
d414 7
a420 5
	    case IMM_4BY2:
	      imm = nibs[3] <<1;
	      goto ok;
	    case IMM_4BY4:
	      imm = nibs[3] <<2;
d422 2
a423 1
	    case IMM_8:
d427 2
a428 2
	      imm = ((nibs[2] << 4) | nibs[3]) <<1;
	      relmask = ~ (bfd_vma) 1;
d431 2
a432 5
	      imm = ((nibs[2] << 4) | nibs[3]) <<2;
	      relmask = ~ (bfd_vma) 3;
	      goto ok;
	    case IMM_8BY2:
	      imm = ((nibs[2] << 4) | nibs[3]) <<1;
d434 7
a440 8
	    case IMM_8BY4:
	      imm = ((nibs[2] << 4) | nibs[3]) <<2;
	      goto ok;
	    case DISP_8:
	      imm = (nibs[2] << 4) | (nibs[3]);	  
	      goto ok;
	    case DISP_4:
	      imm = nibs[3];
d454 1
a454 1
	      break;	
d464 1
d467 1
a467 1
	      abort();
d472 1
a472 1
      fprintf_fn (stream,"%s\t", op->name);
d474 1
a474 1
      for (n = 0; n < 3 && op->arg[n] != A_END; n++) 
d478 1
a478 1
	  switch (op->arg[n]) 
d481 1
a481 1
	      fprintf_fn (stream, "#%d", (char)(imm));
d490 1
a490 1
	      fprintf_fn (stream, "@@r%d+", rn);	
d493 1
a493 1
	      fprintf_fn (stream, "@@-r%d", rn);	
d496 1
a496 1
	      fprintf_fn (stream, "@@r%d", rn);	
d499 1
a499 1
	      fprintf_fn (stream, "@@(%d,r%d)", imm, rn);	
d502 1
a502 1
	      fprintf_fn (stream, "@@r%d+r8", rn);	
d508 1
a508 1
	      fprintf_fn (stream, "@@r%d+", rm);	
d511 1
a511 1
	      fprintf_fn (stream, "@@-r%d", rm);	
d514 1
a514 1
	      fprintf_fn (stream, "@@r%d", rm);	
d517 1
a517 1
	      fprintf_fn (stream, "@@(%d,r%d)", imm, rm);	
d529 1
a529 1
	      break; 
d532 1
a532 1
	      break; 
d534 1
a534 1
	      fprintf_fn (stream, "@@(%d,gbr)",imm);
d592 1
a592 1
	      fprintf_fn (stream ,"macl");
a614 1
	    d_reg_n:
d639 1
a639 1
	      fprintf_fn (stream, "fv%d", rn*4);
d642 1
a642 1
	      fprintf_fn (stream, "fv%d", rm*4);
d648 1
a648 1
	      abort();
d661 1
a661 1
		  && (op->name[1] == 'r' 
d680 1
a680 1
	  if (relmask == ~ (bfd_vma) 1)
d716 1
a716 1
int 
d728 1
a728 1
int 
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 1
a2 1
   Copyright (C) 1993, 1995 Free Software Foundation, Inc.
d18 1
d28 250
d279 1
a279 1
print_insn_shx(memaddr, info)
d283 1
a283 1
  fprintf_ftype fprintf = info->fprintf_func;
d285 2
a286 2
  unsigned  char insn[2];
  unsigned  char nibs[4];
d288 1
a288 1
  int relmask = ~0;
d290 30
a319 2
  
  status = info->read_memory_func(memaddr, insn, 2, info);
d323 1
a323 1
      info->memory_error_func(status, memaddr, info);
a326 2


d344 26
d373 92
a464 76
      int imm;
      int rn;
      int rm;
      int rb;

      for (n = 0; n < 4; n++) {
	int i = op->nibbles[n];
	if (i < 16) 
	  {
	    if (nibs[n] == i) continue;
	    goto fail;
	  }
	switch (i)
	  {
	  case BRANCH_8:
	    imm = (nibs[2] << 4) | (nibs[3]);	  
	    if (imm & 0x80)
	      imm |= ~0xff;
	    imm = ((char)imm) * 2 + 4 ;
	    goto ok;

	  case BRANCH_12:
	    imm = ((nibs[1]) << 8) | (nibs[2] << 4) | (nibs[3]);
	    if (imm & 0x800)
	      imm |= ~0xfff;
	    imm = imm * 2 + 4;
	    goto ok;
	  case IMM_4:
	    imm = nibs[3];
	    goto ok;
	  case IMM_4BY2:
	    imm = nibs[3] <<1;
	    goto ok;
	  case IMM_4BY4:
	    imm = nibs[3] <<2;
	    goto ok;

	    
	  case IMM_8:
	    imm = (nibs[2] << 4) | nibs[3];
	    goto ok;
	  case PCRELIMM_8BY2:
	    imm = ((nibs[2] << 4) | nibs[3]) <<1;
	    relmask  = ~1;
	    
	    goto ok;

	  case PCRELIMM_8BY4:
	    imm = ((nibs[2] << 4) | nibs[3]) <<2;
	    relmask  = ~3;	    
	    goto ok;
	    
	  case IMM_8BY2:
	    imm = ((nibs[2] << 4) | nibs[3]) <<1;
	    goto ok;
	  case IMM_8BY4:
	    imm = ((nibs[2] << 4) | nibs[3]) <<2;
	    goto ok;
	  case DISP_8:
	    imm = (nibs[2] << 4) | (nibs[3]);	  
	    goto ok;
	  case DISP_4:
	    imm = nibs[3];
	    goto ok;
	  case REG_N:
	    rn = nibs[n];
	    break;
	  case REG_M:
	    rm = nibs[n];
	    break;
          case REG_B:
            rb = nibs[n] & 0x07;
            break;	
	  default:
	    abort();
	  }
a465 1
      }
d467 2
a468 1
      fprintf(stream,"%s\t", op->name);
d472 1
a472 1
	    fprintf(stream,",");
d476 1
a476 1
	      fprintf(stream,"#%d", (char)(imm));
d479 1
a479 1
	      fprintf(stream,"r0");
d482 1
a482 1
	      fprintf(stream,"r%d", rn);
d485 1
a485 1
	      fprintf(stream,"@@r%d+", rn);	
d488 1
a488 1
	      fprintf(stream,"@@-r%d", rn);	
d491 1
a491 1
	      fprintf(stream,"@@r%d", rn);	
d494 4
a497 1
	      fprintf(stream,"@@(%d,r%d)",imm, rn);	
d500 1
a500 1
	      fprintf(stream,"r%d", rm);
d503 1
a503 1
	      fprintf(stream,"@@r%d+", rm);	
d506 1
a506 1
	      fprintf(stream,"@@-r%d", rm);	
d509 1
a509 1
	      fprintf(stream,"@@r%d", rm);	
d512 1
a512 1
	      fprintf(stream,"@@(%d,r%d)",imm, rm);	
d514 2
a515 2
            case A_REG_B:
              fprintf(stream,"r%d_bank", rb);
d518 3
a520 1
	      fprintf(stream,"0x%0x", imm+ 4+(memaddr&relmask));
d523 1
a523 1
	      fprintf(stream,"@@(r0,r%d)", rn);
d526 1
a526 1
	      fprintf(stream,"@@(r0,r%d)", rm);
d529 1
a529 1
	      fprintf(stream,"@@(%d,gbr)",imm);
d532 1
a532 1
	      fprintf(stream,"@@(r0,gbr)");
d539 1
a539 1
	      fprintf(stream,"sr");
d542 1
a542 1
	      fprintf(stream,"gbr");
d545 31
a575 1
	      fprintf(stream,"vbr");
d578 1
a578 1
	      fprintf(stream,"ssr");
d581 1
a581 1
	      fprintf(stream,"spc");
d584 1
a584 1
	      fprintf(stream,"mach");
d587 1
a587 1
	      fprintf(stream,"macl");
d590 7
a596 1
	      fprintf(stream,"pr");
d599 1
a599 1
	      fprintf(stream,"fr%d", rn);
d602 20
a621 1
	      fprintf(stream,"fr%d", rm);
d625 1
a625 1
	      fprintf(stream,"fpscr");
d629 1
a629 1
	      fprintf(stream,"fpul");
d632 10
a641 1
	      fprintf(stream,"fr0");
a645 1
	
d647 7
d663 2
a664 1
	  fprintf(stream,"\t(slot ");  print_insn_shx(memaddr +2, info);
d666 1
a666 1
	  fprintf(stream,")");
d669 34
a702 1
      
d708 1
a708 1
  fprintf(stream,".word 0x%x%x%x%x", nibs[0], nibs[1], nibs[2], nibs[3]);
a711 1

d713 1
a713 1
print_insn_shl(memaddr, info)
d718 1
d720 1
a720 1
  r =print_insn_shx (memaddr, info);
d725 1
a725 1
print_insn_sh(memaddr, info)
d730 1
d732 1
a732 1
  r =print_insn_shx (memaddr, info);
@


1.1
log
@Initial revision
@
text
@d73 2
d140 3
d192 3
d223 6
d237 17
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@a72 2
      int rb;

a137 3
          case REG_B:
            rb = nibs[n] & 0x07;
            break;	
a186 3
            case A_REG_B:
              fprintf(stream,"r%d_bank", rb);
	      break;
a214 6
	    case A_SSR:
	      fprintf(stream,"ssr");
	      break;
	    case A_SPC:
	      fprintf(stream,"spc");
	      break;
a222 17
	      break;
	    case F_REG_N:
	      fprintf(stream,"fr%d", rn);
	      break;
	    case F_REG_M:
	      fprintf(stream,"fr%d", rm);
	      break;
	    case FPSCR_M:
	    case FPSCR_N:
	      fprintf(stream,"fpscr");
	      break;
	    case FPUL_M:
	    case FPUL_N:
	      fprintf(stream,"fpul");
	      break;
	    case F_FR0:
	      fprintf(stream,"fr0");
@


1.1.1.3
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.
a17 1
#include "sysdep.h"
a26 250
static void
print_movxy (op, rn, rm, fprintf_fn, stream)
     sh_opcode_info *op;
     int rn, rm;
     fprintf_ftype fprintf_fn;
     void *stream;
{
  int n;

  fprintf_fn (stream,"%s\t", op->name);
  for (n = 0; n < 2; n++)
    {
      switch (op->arg[n])
	{
	case A_IND_N:
	  fprintf_fn (stream, "@@r%d", rn);	
	  break;
	case A_INC_N:
	  fprintf_fn (stream, "@@r%d+", rn);	
	  break;
	case A_PMOD_N:
	  fprintf_fn (stream, "@@r%d+r8", rn);	
	  break;
	case A_PMODY_N:
	  fprintf_fn (stream, "@@r%d+r9", rn);	
	  break;
	case DSP_REG_M:
	  fprintf_fn (stream, "a%c", '0' + rm);
	  break;
	case DSP_REG_X:
	  fprintf_fn (stream, "x%c", '0' + rm);
	  break;
	case DSP_REG_Y:
	  fprintf_fn (stream, "y%c", '0' + rm);
	  break;
	default:
	  abort ();
	}
      if (n == 0)
	fprintf_fn (stream, ",");	
    }
}

/* Print a double data transfer insn.  INSN is just the lower three
   nibbles of the insn, i.e. field a and the bit that indicates if
   a parallel processing insn follows.
   Return nonzero if a field b of a parallel processing insns follows.  */
static void
print_insn_ddt (insn, info)
     int insn;
     struct disassemble_info *info;
{
  fprintf_ftype fprintf_fn = info->fprintf_func;
  void *stream = info->stream;

  /* If this is just a nop, make sure to emit something.  */
  if (insn == 0x000)
    fprintf_fn (stream, "nopx\tnopy");

  /* If a parallel processing insn was printed before,
     and we got a non-nop, emit a tab.  */
  if ((insn & 0x800) && (insn & 0x3ff))
    fprintf_fn (stream, "\t");

  /* Check if either the x or y part is invalid.  */
  if (((insn & 0xc) == 0 && (insn & 0x2a0))
      || ((insn & 3) == 0 && (insn & 0x150)))
    fprintf_fn (stream, ".word 0x%x", insn);
  else
    {
      static sh_opcode_info *first_movx, *first_movy;
      sh_opcode_info *opx, *opy;
      int insn_x, insn_y;

      if (! first_movx)
	{
	  for (first_movx = sh_table; first_movx->nibbles[1] != MOVX; )
	    first_movx++;
	  for (first_movy = first_movx; first_movy->nibbles[1] != MOVY; )
	    first_movy++;
	}
      insn_x = (insn >> 2) & 0xb;
      if (insn_x)
	{
	  for (opx = first_movx; opx->nibbles[2] != insn_x; ) opx++;
	  print_movxy (opx, ((insn >> 9) & 1) + 4, (insn >> 7) & 1,
		       fprintf_fn, stream);
	}
      insn_y = (insn & 3) | ((insn >> 1) & 8);
      if (insn_y)
	{
	  if (insn_x)
	    fprintf_fn (stream, "\t");
	  for (opy = first_movy; opy->nibbles[2] != insn_y; ) opy++;
	  print_movxy (opy, ((insn >> 8) & 1) + 6, (insn >> 6) & 1,
		       fprintf_fn, stream);
	}
    }
}

static void
print_dsp_reg (rm, fprintf_fn, stream)
     int rm;
     fprintf_ftype fprintf_fn;
     void *stream;
{
  switch (rm)
    {
    case A_A1_NUM:
      fprintf_fn (stream, "a1");
      break;
    case A_A0_NUM:
      fprintf_fn (stream, "a0");
      break;
    case A_X0_NUM:
      fprintf_fn (stream, "x0");
      break;
    case A_X1_NUM:
      fprintf_fn (stream, "x1");
      break;
    case A_Y0_NUM:
      fprintf_fn (stream, "y0");
      break;
    case A_Y1_NUM:
      fprintf_fn (stream, "y1");
      break;
    case A_M0_NUM:
      fprintf_fn (stream, "m0");
      break;
    case A_A1G_NUM:
      fprintf_fn (stream, "a1g");
      break;
    case A_M1_NUM:
      fprintf_fn (stream, "m1");
      break;
    case A_A0G_NUM:
      fprintf_fn (stream, "a0g");
      break;
    default:
      fprintf_fn (stream, "0x%x", rm);
      break;
    }
}

static void
print_insn_ppi (field_b, info)
     int field_b;
     struct disassemble_info *info;
{
  static char *sx_tab[] = {"x0","x1","a0","a1"};
  static char *sy_tab[] = {"y0","y1","m0","m1"};
  fprintf_ftype fprintf_fn = info->fprintf_func;
  void *stream = info->stream;
  int nib1, nib2, nib3;
  char *dc;
  sh_opcode_info *op;

  if ((field_b & 0xe800) == 0)
    {
      fprintf_fn (stream, "psh%c\t#%d,",
		  field_b & 0x1000 ? 'a' : 'l',
		  (field_b >> 4) & 127);
      print_dsp_reg (field_b & 0xf, fprintf_fn, stream);
      return;
    }
  if ((field_b & 0xc000) == 0x4000 && (field_b & 0x3000) != 0x1000)
    {
      static char *du_tab[] = {"x0","y0","a0","a1"};
      static char *se_tab[] = {"x0","x1","y0","a1"};
      static char *sf_tab[] = {"y0","y1","x0","a1"};
      static char *sg_tab[] = {"m0","m1","a0","a1"};

      if (field_b & 0x2000)
	{
	  fprintf_fn (stream, "p%s %s,%s,%s\t",
		      (field_b & 0x1000) ? "add" : "sub",
		      sx_tab[(field_b >> 6) & 3],
		      sy_tab[(field_b >> 4) & 3],
		      du_tab[(field_b >> 0) & 3]);
	}
      fprintf_fn (stream, "pmuls%c%s,%s,%s",
		  field_b & 0x2000 ? ' ' : '\t',
		  se_tab[(field_b >> 10) & 3],
		  sf_tab[(field_b >>  8) & 3],
		  sg_tab[(field_b >>  2) & 3]);
      return;
    }

  nib1 = PPIC;
  nib2 = field_b >> 12 & 0xf;
  nib3 = field_b >> 8 & 0xf;
  switch (nib3 & 0x3)
    {
    case 0:
      dc = "";
      nib1 = PPI3;
      break;
    case 1:
      dc = "";
      break;
    case 2:
      dc = "dct ";
      nib3 -= 1;
      break;
    case 3:
      dc = "dcf ";
      nib3 -= 2;
      break;
    }
  for (op = sh_table; op->name; op++)
    {
      if (op->nibbles[1] == nib1
	  && op->nibbles[2] == nib2
	  && op->nibbles[3] == nib3)
	{
	  int n;

	  fprintf_fn (stream, "%s%s\t", dc, op->name);
	  for (n = 0; n < 3 && op->arg[n] != A_END; n++) 
	    {
	      if (n && op->arg[1] != A_END)
		fprintf_fn (stream, ",");
	      switch (op->arg[n]) 
		{
		case DSP_REG_N:
		  print_dsp_reg (field_b & 0xf, fprintf_fn, stream);
		  break;
		case DSP_REG_X:
		  fprintf_fn (stream, sx_tab[(field_b >> 6) & 3]);
		  break;
		case DSP_REG_Y:
		  fprintf_fn (stream, sy_tab[(field_b >> 4) & 3]);
		  break;
		case A_MACH:
		  fprintf_fn (stream, "mach");
		  break;
		case A_MACL:
		  fprintf_fn (stream ,"macl");
		  break;
		default:
		  abort ();
		}
	    }
	  return;
	}
    }
  /* Not found.  */
  fprintf_fn (stream, ".word 0x%x", field_b);
}

d28 1
a28 1
print_insn_shx (memaddr, info)
d32 1
a32 1
  fprintf_ftype fprintf_fn = info->fprintf_func;
d34 2
a35 2
  unsigned char insn[2];
  unsigned char nibs[4];
d37 1
a37 1
  bfd_vma relmask = ~ (bfd_vma) 0;
d39 2
a40 1
  int target_arch;
d42 1
a42 1
  switch (info->mach)
d44 2
a45 23
    case bfd_mach_sh:
      target_arch = arch_sh1;
      break;
    case bfd_mach_sh2:
      target_arch = arch_sh2;
      break;
    case bfd_mach_sh_dsp:
      target_arch = arch_sh_dsp;
      break;
    case bfd_mach_sh3:
      target_arch = arch_sh3;
      break;
    case bfd_mach_sh3_dsp:
      target_arch = arch_sh3_dsp;
      break;
    case bfd_mach_sh3e:
      target_arch = arch_sh3e;
      break;
    case bfd_mach_sh4:
      target_arch = arch_sh4;
      break;
    default:
      abort ();
a47 1
  status = info->read_memory_func (memaddr, insn, 2, info);
a48 5
  if (status != 0) 
    {
      info->memory_error_func (status, memaddr, info);
      return -1;
    }
a66 26
  if (nibs[0] == 0xf && (nibs[1] & 4) == 0 && target_arch & arch_sh_dsp_up)
    {
      if (nibs[1] & 8)
	{
	  int field_b;

	  status = info->read_memory_func (memaddr + 2, insn, 2, info);

	  if (status != 0) 
	    {
	      info->memory_error_func (status, memaddr + 2, info);
	      return -1;
	    }

	  if (info->flags & LITTLE_BIT) 
	    field_b = insn[1] << 8 | insn[0];
	  else
	    field_b = insn[0] << 8 | insn[1];

	  print_insn_ppi (field_b, info);
	  print_insn_ddt ((nibs[1] << 8) | (nibs[2] << 4) | nibs[3], info);
	  return 4;
	}
      print_insn_ddt ((nibs[1] << 8) | (nibs[2] << 4) | nibs[3], info);
      return 2;
    }
d70 76
a145 92
      int imm = 0;
      int rn = 0;
      int rm = 0;
      int rb = 0;
      int disp_pc;
      bfd_vma disp_pc_addr = 0;

      if ((op->arch & target_arch) == 0)
	goto fail;
      for (n = 0; n < 4; n++)
	{
	  int i = op->nibbles[n];

	  if (i < 16) 
	    {
	      if (nibs[n] == i)
		continue;
	      goto fail;
	    }
	  switch (i)
	    {
	    case BRANCH_8:
	      imm = (nibs[2] << 4) | (nibs[3]);	  
	      if (imm & 0x80)
		imm |= ~0xff;
	      imm = ((char)imm) * 2 + 4 ;
	      goto ok;
	    case BRANCH_12:
	      imm = ((nibs[1]) << 8) | (nibs[2] << 4) | (nibs[3]);
	      if (imm & 0x800)
		imm |= ~0xfff;
	      imm = imm * 2 + 4;
	      goto ok;
	    case IMM_4:
	      imm = nibs[3];
	      goto ok;
	    case IMM_4BY2:
	      imm = nibs[3] <<1;
	      goto ok;
	    case IMM_4BY4:
	      imm = nibs[3] <<2;
	      goto ok;
	    case IMM_8:
	      imm = (nibs[2] << 4) | nibs[3];
	      goto ok;
	    case PCRELIMM_8BY2:
	      imm = ((nibs[2] << 4) | nibs[3]) <<1;
	      relmask = ~ (bfd_vma) 1;
	      goto ok;
	    case PCRELIMM_8BY4:
	      imm = ((nibs[2] << 4) | nibs[3]) <<2;
	      relmask = ~ (bfd_vma) 3;
	      goto ok;
	    case IMM_8BY2:
	      imm = ((nibs[2] << 4) | nibs[3]) <<1;
	      goto ok;
	    case IMM_8BY4:
	      imm = ((nibs[2] << 4) | nibs[3]) <<2;
	      goto ok;
	    case DISP_8:
	      imm = (nibs[2] << 4) | (nibs[3]);	  
	      goto ok;
	    case DISP_4:
	      imm = nibs[3];
	      goto ok;
	    case REG_N:
	      rn = nibs[n];
	      break;
	    case REG_M:
	      rm = nibs[n];
	      break;
	    case REG_NM:
	      rn = (nibs[n] & 0xc) >> 2;
	      rm = (nibs[n] & 0x3);
	      break;
	    case REG_B:
	      rb = nibs[n] & 0x07;
	      break;	
	    case SDT_REG_N:
	      /* sh-dsp: single data transfer.  */
	      rn = nibs[n];
	      if ((rn & 0xc) != 4)
		goto fail;
	      rn = rn & 0x3;
	      rn |= (rn & 2) << 1;
	      break;
	    case PPI:
	      goto fail;
	    default:
	      abort();
	    }
	}
d147 1
d149 1
a149 2
      fprintf_fn (stream,"%s\t", op->name);
      disp_pc = 0;
d153 1
a153 1
	    fprintf_fn (stream, ",");
d157 1
a157 1
	      fprintf_fn (stream, "#%d", (char)(imm));
d160 1
a160 1
	      fprintf_fn (stream, "r0");
d163 1
a163 1
	      fprintf_fn (stream, "r%d", rn);
d166 1
a166 1
	      fprintf_fn (stream, "@@r%d+", rn);	
d169 1
a169 1
	      fprintf_fn (stream, "@@-r%d", rn);	
d172 1
a172 1
	      fprintf_fn (stream, "@@r%d", rn);	
d175 1
a175 4
	      fprintf_fn (stream, "@@(%d,r%d)", imm, rn);	
	      break;
	    case A_PMOD_N:
	      fprintf_fn (stream, "@@r%d+r8", rn);	
d178 1
a178 1
	      fprintf_fn (stream, "r%d", rm);
d181 1
a181 1
	      fprintf_fn (stream, "@@r%d+", rm);	
d184 1
a184 1
	      fprintf_fn (stream, "@@-r%d", rm);	
d187 1
a187 1
	      fprintf_fn (stream, "@@r%d", rm);	
d190 1
a190 1
	      fprintf_fn (stream, "@@(%d,r%d)", imm, rm);	
d192 2
a193 2
	    case A_REG_B:
	      fprintf_fn (stream, "r%d_bank", rb);
d196 1
a196 3
	      disp_pc = 1;
	      disp_pc_addr = imm + 4 + (memaddr & relmask);
	      (*info->print_address_func) (disp_pc_addr, info);
d199 1
a199 1
	      fprintf_fn (stream, "@@(r0,r%d)", rn);
d202 1
a202 1
	      fprintf_fn (stream, "@@(r0,r%d)", rm);
d205 1
a205 1
	      fprintf_fn (stream, "@@(%d,gbr)",imm);
d208 1
a208 1
	      fprintf_fn (stream, "@@(r0,gbr)");
d215 1
a215 1
	      fprintf_fn (stream, "sr");
d218 1
a218 1
	      fprintf_fn (stream, "gbr");
d221 1
a221 31
	      fprintf_fn (stream, "vbr");
	      break;
	    case A_DSR:
	      fprintf_fn (stream, "dsr");
	      break;
	    case A_MOD:
	      fprintf_fn (stream, "mod");
	      break;
	    case A_RE:
	      fprintf_fn (stream, "re");
	      break;
	    case A_RS:
	      fprintf_fn (stream, "rs");
	      break;
	    case A_A0:
	      fprintf_fn (stream, "a0");
	      break;
	    case A_X0:
	      fprintf_fn (stream, "x0");
	      break;
	    case A_X1:
	      fprintf_fn (stream, "x1");
	      break;
	    case A_Y0:
	      fprintf_fn (stream, "y0");
	      break;
	    case A_Y1:
	      fprintf_fn (stream, "y1");
	      break;
	    case DSP_REG_M:
	      print_dsp_reg (rm, fprintf_fn, stream);
d224 1
a224 1
	      fprintf_fn (stream, "ssr");
d227 1
a227 1
	      fprintf_fn (stream, "spc");
d230 1
a230 1
	      fprintf_fn (stream, "mach");
d233 1
a233 1
	      fprintf_fn (stream ,"macl");
d236 1
a236 7
	      fprintf_fn (stream, "pr");
	      break;
	    case A_SGR:
	      fprintf_fn (stream, "sgr");
	      break;
	    case A_DBR:
	      fprintf_fn (stream, "dbr");
d239 1
a239 1
	      fprintf_fn (stream, "fr%d", rn);
d242 1
a242 20
	      fprintf_fn (stream, "fr%d", rm);
	      break;
	    case DX_REG_N:
	      if (rn & 1)
		{
		  fprintf_fn (stream, "xd%d", rn & ~1);
		  break;
		}
	    d_reg_n:
	    case D_REG_N:
	      fprintf_fn (stream, "dr%d", rn);
	      break;
	    case DX_REG_M:
	      if (rm & 1)
		{
		  fprintf_fn (stream, "xd%d", rm & ~1);
		  break;
		}
	    case D_REG_M:
	      fprintf_fn (stream, "dr%d", rm);
d246 1
a246 1
	      fprintf_fn (stream, "fpscr");
d250 1
a250 1
	      fprintf_fn (stream, "fpul");
d253 1
a253 10
	      fprintf_fn (stream, "fr0");
	      break;
	    case V_REG_N:
	      fprintf_fn (stream, "fv%d", rn*4);
	      break;
	    case V_REG_M:
	      fprintf_fn (stream, "fv%d", rm*4);
	      break;
	    case XMTRX_M4:
	      fprintf_fn (stream, "xmtrx");
d258 1
a259 7

#if 0
      /* This code prints instructions in delay slots on the same line
         as the instruction which needs the delay slots.  This can be
         confusing, since other disassembler don't work this way, and
         it means that the instructions are not all in a line.  So I
         disabled it.  Ian.  */
d269 1
a269 2
	  fprintf_fn (stream, "\t(slot ");
	  print_insn_shx (memaddr + 2, info);
d271 1
a271 1
	  fprintf_fn (stream, ")");
d274 1
a274 34
#endif

      if (disp_pc && strcmp (op->name, "mova") != 0)
	{
	  int size;
	  bfd_byte bytes[4];

	  if (relmask == ~ (bfd_vma) 1)
	    size = 2;
	  else
	    size = 4;
	  status = info->read_memory_func (disp_pc_addr, bytes, size, info);
	  if (status == 0)
	    {
	      unsigned int val;

	      if (size == 2)
		{
		  if ((info->flags & LITTLE_BIT) != 0)
		    val = bfd_getl16 (bytes);
		  else
		    val = bfd_getb16 (bytes);
		}
	      else
		{
		  if ((info->flags & LITTLE_BIT) != 0)
		    val = bfd_getl32 (bytes);
		  else
		    val = bfd_getb32 (bytes);
		}
	      fprintf_fn (stream, "\t! 0x%x", val);
	    }
	}

d280 1
a280 1
  fprintf_fn (stream, ".word 0x%x%x%x%x", nibs[0], nibs[1], nibs[2], nibs[3]);
d284 1
d286 1
a286 1
print_insn_shl (memaddr, info)
a290 1

d292 1
a292 1
  r = print_insn_shx (memaddr, info);
d297 1
a297 1
print_insn_sh (memaddr, info)
a301 1

d303 1
a303 1
  r = print_insn_shx (memaddr, info);
@


1.1.1.4
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1993, 1994, 1995, 1997, 1998, 2000
   Free Software Foundation, Inc.
d18 1
a19 1
#include "sysdep.h"
d37 1
a37 1
  fprintf_fn (stream, "%s\t", op->name);
d43 1
a43 1
	  fprintf_fn (stream, "@@r%d", rn);
d46 1
a46 1
	  fprintf_fn (stream, "@@r%d+", rn);
d49 1
a49 1
	  fprintf_fn (stream, "@@r%d+r8", rn);
d52 1
a52 1
	  fprintf_fn (stream, "@@r%d+r9", rn);
d67 1
a67 1
	fprintf_fn (stream, ",");
a74 1

d100 1
a100 1
      unsigned int insn_x, insn_y;
d104 1
a104 1
	  for (first_movx = sh_table; first_movx->nibbles[1] != MOVX;)
d106 1
a106 1
	  for (first_movy = first_movx; first_movy->nibbles[1] != MOVY;)
d112 1
a112 2
	  for (opx = first_movx; opx->nibbles[2] != insn_x;)
	    opx++;
d121 1
a121 2
	  for (opy = first_movy; opy->nibbles[2] != insn_y;)
	    opy++;
d177 2
a178 2
  static char *sx_tab[] = { "x0", "x1", "a0", "a1" };
  static char *sy_tab[] = { "y0", "y1", "m0", "m1" };
d181 2
a182 2
  unsigned int nib1, nib2, nib3;
  char *dc = NULL;
d195 4
a198 4
      static char *du_tab[] = { "x0", "y0", "a0", "a1" };
      static char *se_tab[] = { "x0", "x1", "y0", "a1" };
      static char *sf_tab[] = { "y0", "y1", "x0", "a1" };
      static char *sg_tab[] = { "m0", "m1", "a0", "a1" };
d246 1
a246 1
	  for (n = 0; n < 3 && op->arg[n] != A_END; n++)
d250 1
a250 1
	      switch (op->arg[n])
d265 1
a265 1
		  fprintf_fn (stream, "macl");
d278 1
a278 1
static int
d288 1
a288 1
  bfd_vma relmask = ~(bfd_vma) 0;
d321 1
a321 1
  if (status != 0)
d327 1
a327 1
  if (info->flags & LITTLE_BIT)
d335 1
a335 1
  else
d352 1
a352 1
	  if (status != 0)
d358 1
a358 1
	  if (info->flags & LITTLE_BIT)
d370 1
a370 1
  for (op = sh_table; op->name; op++)
d386 1
a386 1
	  if (i < 16)
d395 1
a395 1
	      imm = (nibs[2] << 4) | (nibs[3]);
d398 1
a398 1
	      imm = ((char) imm) * 2 + 4;
d406 1
a406 2
	    case IMM0_4:
	    case IMM1_4:
d409 5
a413 7
	    case IMM0_4BY2:
	    case IMM1_4BY2:
	      imm = nibs[3] << 1;
	      goto ok;
	    case IMM0_4BY4:
	    case IMM1_4BY4:
	      imm = nibs[3] << 2;
d415 1
a415 2
	    case IMM0_8:
	    case IMM1_8:
d419 2
a420 2
	      imm = ((nibs[2] << 4) | nibs[3]) << 1;
	      relmask = ~(bfd_vma) 1;
d423 5
a427 2
	      imm = ((nibs[2] << 4) | nibs[3]) << 2;
	      relmask = ~(bfd_vma) 3;
d429 8
a436 7
	    case IMM0_8BY2:
	    case IMM1_8BY2:
	      imm = ((nibs[2] << 4) | nibs[3]) << 1;
	      goto ok;
	    case IMM0_8BY4:
	    case IMM1_8BY4:
	      imm = ((nibs[2] << 4) | nibs[3]) << 2;
d450 1
a450 1
	      break;
a459 1
	    case REPEAT:
d462 1
a462 1
	      abort ();
d467 1
a467 1
      fprintf_fn (stream, "%s\t", op->name);
d469 1
a469 1
      for (n = 0; n < 3 && op->arg[n] != A_END; n++)
d473 1
a473 1
	  switch (op->arg[n])
d476 1
a476 1
	      fprintf_fn (stream, "#%d", (char) (imm));
d485 1
a485 1
	      fprintf_fn (stream, "@@r%d+", rn);
d488 1
a488 1
	      fprintf_fn (stream, "@@-r%d", rn);
d491 1
a491 1
	      fprintf_fn (stream, "@@r%d", rn);
d494 1
a494 1
	      fprintf_fn (stream, "@@(%d,r%d)", imm, rn);
d497 1
a497 1
	      fprintf_fn (stream, "@@r%d+r8", rn);
d503 1
a503 1
	      fprintf_fn (stream, "@@r%d+", rm);
d506 1
a506 1
	      fprintf_fn (stream, "@@-r%d", rm);
d509 1
a509 1
	      fprintf_fn (stream, "@@r%d", rm);
d512 1
a512 1
	      fprintf_fn (stream, "@@(%d,r%d)", imm, rm);
d524 1
a524 1
	      break;
d527 1
a527 1
	      break;
d529 1
a529 1
	      fprintf_fn (stream, "@@(%d,gbr)", imm);
d587 1
a587 1
	      fprintf_fn (stream, "macl");
d610 1
d635 1
a635 1
	      fprintf_fn (stream, "fv%d", rn * 4);
d638 1
a638 1
	      fprintf_fn (stream, "fv%d", rm * 4);
d644 1
a644 1
	      abort ();
d657 1
a657 1
		  && (op->name[1] == 'r'
d676 1
a676 1
	  if (relmask == ~(bfd_vma) 1)
d712 1
a712 1
int
d724 1
a724 1
int
@


1.1.1.5
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003
d5 13
a17 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d27 1
a27 9
#ifdef ARCH_all
#define INCLUDE_SHMEDIA
#endif

static void print_movxy
  PARAMS ((const sh_opcode_info *, int, int, fprintf_ftype, void *));
static void print_insn_ddt PARAMS ((int, struct disassemble_info *));
static void print_dsp_reg PARAMS ((int, fprintf_ftype, void *));
static void print_insn_ppi PARAMS ((int, struct disassemble_info *));
d31 1
a31 1
     const sh_opcode_info *op;
d100 2
a101 2
      static const sh_opcode_info *first_movx, *first_movy;
      const sh_opcode_info *opx, *opy;
d187 1
a187 1
  const sh_opcode_info *op;
d282 2
a283 2
int
print_insn_sh (memaddr, info)
d293 1
a293 1
  const sh_opcode_info *op;
a299 6
      /* SH coff object files lack information about the machine type, so
         we end up with bfd_mach_sh unless it was set explicitly (which
	 could have happended if this is a call from gdb or the simulator.)  */
      if (info->symbols
	  && bfd_asymbol_flavour(*info->symbols) == bfd_target_coff_flavour)
	target_arch = arch_sh4;
a303 3
    case bfd_mach_sh2e:
      target_arch = arch_sh2e;
      break;
a318 10
    case bfd_mach_sh5:
#ifdef INCLUDE_SHMEDIA
      status = print_insn_sh64 (memaddr, info);
      if (status != -2)
	return status;
#endif
      /* When we get here for sh64, it's because we want to disassemble
	 SHcompact, i.e. arch_sh4.  */
      target_arch = arch_sh4;
      break;
d331 1
a331 1
  if (info->endian == BFD_ENDIAN_LITTLE)
d362 1
a362 1
	  if (info->endian == BFD_ENDIAN_LITTLE)
d461 1
a461 1
	      rn |= (!(rn & 2)) << 2;
d668 1
a668 1
	  print_insn_sh (memaddr + 2, info);
d691 1
a691 1
		  if (info->endian == BFD_ENDIAN_LITTLE)
d698 1
a698 1
		  if (info->endian == BFD_ENDIAN_LITTLE)
d714 24
@


1.1.1.6
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@a51 4
	case AX_IND_N:
	case AXY_IND_N:
	case AY_IND_N:
	case AYX_IND_N:
a54 4
	case AX_INC_N:
	case AXY_INC_N:
	case AY_INC_N:
	case AYX_INC_N:
d57 1
a57 2
	case AX_PMOD_N:
	case AXY_PMOD_N:
d60 1
a60 2
	case AY_PMOD_N:
	case AYX_PMOD_N:
d63 1
a63 1
	case DSP_REG_A_M:
a71 20
	case DSP_REG_AX:
	  fprintf_fn (stream, "%c%c",
		      (rm & 1) ? 'x' : 'a',
		      (rm & 2) ? '1' : '0');
	  break;
	case DSP_REG_XY:
	  fprintf_fn (stream, "%c%c",
		      (rm & 1) ? 'y' : 'x',
		      (rm & 2) ? '1' : '0');
	  break;
	case DSP_REG_AY:
	  fprintf_fn (stream, "%c%c",
		      (rm & 2) ? 'y' : 'a',
		      (rm & 1) ? '1' : '0');
	  break;
	case DSP_REG_YX:
	  fprintf_fn (stream, "%c%c",
		      (rm & 2) ? 'x' : 'y',
		      (rm & 1) ? '1' : '0');
	  break;
d105 1
a105 35
    if (info->mach != bfd_mach_sh_dsp
        && info->mach != bfd_mach_sh3_dsp)
      {
	static const sh_opcode_info *first_movx, *first_movy;
	const sh_opcode_info *op;
	int is_movy;

	if (! first_movx)
	  {
	    for (first_movx = sh_table; first_movx->nibbles[1] != MOVX_NOPY;)
	      first_movx++;
	    for (first_movy = first_movx; first_movy->nibbles[1] != MOVY_NOPX;)
	      first_movy++;
	  }

	is_movy = ((insn & 3) != 0);

	if (is_movy)
	  op = first_movy;
	else
	  op = first_movx;

	while (op->nibbles[2] != (unsigned) ((insn >> 4) & 3)
	       || op->nibbles[3] != (unsigned) (insn & 0xf))
	  op++;
	
	print_movxy (op,
		     (4 * ((insn & (is_movy ? 0x200 : 0x100)) == 0)
		      + 2 * is_movy
		      + 1 * ((insn & (is_movy ? 0x100 : 0x200)) != 0)),
		     (insn >> 6) & 3,
		     fprintf_fn, stream);
      }
    else
      fprintf_fn (stream, ".word 0x%x", insn);
a193 1
  unsigned int altnib1, nib4;
a219 10
      else if ((field_b & 0xf0) == 0x10
	       && info->mach != bfd_mach_sh_dsp
	       && info->mach != bfd_mach_sh3_dsp)
	{
	  fprintf_fn (stream, "pclr %s \t", du_tab[(field_b >> 0) & 3]);
	}
      else if ((field_b & 0xf3) != 0)
	{
	  fprintf_fn (stream, ".word 0x%x\t", field_b);
	}
a230 1
  nib4 = field_b >> 4 & 0xf;
a248 4
  if (nib1 == PPI3)
    altnib1 = PPI3NC;
  else
    altnib1 = nib1;
d251 1
a251 1
      if ((op->nibbles[1] == nib1 || op->nibbles[1] == altnib1)
a256 23
	  switch (op->nibbles[4])
	    {
	    case HEX_0:
	      break;
	    case HEX_XX00:
	      if ((nib4 & 3) != 0)
		continue;
	      break;
	    case HEX_1:
	      if ((nib4 & 3) != 1)
		continue;
	      break;
	    case HEX_00YY:
	      if ((nib4 & 0xc) != 0)
		continue;
	      break;
	    case HEX_4:
	      if ((nib4 & 0xc) != 4)
		continue;
	      break;
	    default:
	      abort ();
	    }
d297 1
a297 1
  unsigned char insn[4];
a333 1
    case bfd_mach_sh4_nofpu:
a335 7
    case bfd_mach_sh4a:
    case bfd_mach_sh4a_nofpu:
      target_arch = arch_sh4a;
      break;
    case bfd_mach_sh4al_dsp:
      target_arch = arch_sh4al_dsp;
      break;
a468 4
	    case REG_N_D:
	      if ((nibs[n] & 1) != 0)
		goto fail;
	      /* fall through */
a474 5
	    case REG_N_B01:
	      if ((nibs[n] & 0x3) != 1 /* binary 01 */)
		goto fail;
	      rn = (nibs[n] & 0xc) >> 2;
	      break;
a516 1
	    case AS_INC_N:
a519 1
	    case AS_DEC_N:
a522 1
	    case AS_IND_N:
d528 1
a528 1
	    case AS_PMOD_N:
@


