head	1.7;
access;
symbols
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.54;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.54;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.44;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.12.59;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.10.54;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.55.42;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.00;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.00;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.04.13;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.48.54;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.47.52;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.56.07;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.44;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.23.10;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* Disassemble h8300 instructions.
   Copyright 1993, 1994, 1996, 1998, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#define DEFINE_TABLE

#include "sysdep.h"
#define h8_opcodes h8ops
#include "opcode/h8300.h"
#include "dis-asm.h"
#include "opintl.h"
#include "libiberty.h"

struct h8_instruction
{
  int length;
  const struct h8_opcode *opcode;
};

struct h8_instruction *h8_instructions;

static void bfd_h8_disassemble_init PARAMS ((void));
static void print_one_arg PARAMS ((disassemble_info *, bfd_vma, op_type,
				   int, int, int, int, const char **, int));
static unsigned int bfd_h8_disassemble PARAMS ((bfd_vma, 
						disassemble_info *, 
						int));
static void extract_immediate PARAMS ((FILE *, 
				       op_type, int, 
				       unsigned char *,
				       int *, int *,
				       const struct h8_opcode *));

/* Run through the opcodes and sort them into order to make them easy
   to disassemble.  */

static void
bfd_h8_disassemble_init ()
{
  unsigned int i;
  unsigned int nopcodes;
  const struct h8_opcode *p;
  struct h8_instruction *pi;

  nopcodes = sizeof (h8_opcodes) / sizeof (struct h8_opcode);

  h8_instructions = (struct h8_instruction *)
    xmalloc (nopcodes * sizeof (struct h8_instruction));

  for (p = h8_opcodes, pi = h8_instructions; p->name; p++, pi++)
    {
      int n1 = 0;
      int n2 = 0;

      if ((int) p->data.nib[0] < 16)
	n1 = (int) p->data.nib[0];
      else
	n1 = 0;

      if ((int) p->data.nib[1] < 16)
	n2 = (int) p->data.nib[1];
      else
	n2 = 0;

      /* Just make sure there are an even number of nibbles in it, and
	 that the count is the same as the length.  */
      for (i = 0; p->data.nib[i] != (op_type) E; i++)
	;

      if (i & 1)
	{
	  fprintf (stderr, "Internal error, h8_disassemble_init.\n");
	  abort ();
	}

      pi->length = i / 2;
      pi->opcode = p;
    }

  /* Add entry for the NULL vector terminator.  */
  pi->length = 0;
  pi->opcode = p;
}

static void
extract_immediate (stream, looking_for, thisnib, data, cst, len, q)
     FILE *stream;
     op_type looking_for;
     int thisnib;
     unsigned char *data;
     int *cst, *len;
     const struct h8_opcode *q;
{
  switch (looking_for & SIZE)
    {
    case L_2:
      *len = 2;
      *cst = thisnib & 3;

      /* DISP2 special treatment.  */
      if ((looking_for & MODE) == DISP)
	{
	  if (OP_KIND (q->how) == O_MOVAB ||
	      OP_KIND (q->how) == O_MOVAW ||
	      OP_KIND (q->how) == O_MOVAL)
	    {
	      /* Handling for mova insn.  */
	      switch (q->args.nib[0] & MODE) {
	      case INDEXB:
	      default:
		break;
	      case INDEXW:
		*cst *= 2;
		break;
	      case INDEXL:
		*cst *= 4;
		break;
	      }
	    }
	  else
	    {
	      /* Handling for non-mova insn.  */
	      switch (OP_SIZE (q->how)) {
	      default: break;
	      case SW:
		*cst *= 2;
		break;
	      case SL:
		*cst *= 4;
		break;
	      }
	    }
	}
      break;
    case L_8:
      *len = 8;
      *cst = data[0];
      break;
    case L_16:
    case L_16U:
      *len = 16;
      *cst = (data[0] << 8) + data [1];
#if 0
      if ((looking_for & SIZE) == L_16)
	*cst = (short) *cst;	/* sign extend */
#endif
      break;
    case L_32:
      *len = 32;
      *cst = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3];
      break;
    default:
      *len = 0;
      *cst = 0;
      fprintf (stream, "DISP bad size\n");
      break;
    }
}

static const char *regnames[] =
{
  "r0h", "r1h", "r2h", "r3h", "r4h", "r5h", "r6h", "r7h",
  "r0l", "r1l", "r2l", "r3l", "r4l", "r5l", "r6l", "r7l"
};
static const char *wregnames[] =
{
  "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
  "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7"
};
static const char *lregnames[] =
{
  "er0", "er1", "er2", "er3", "er4", "er5", "er6", "er7",
  "er0", "er1", "er2", "er3", "er4", "er5", "er6", "er7"
};
static const char *cregnames[] =
{
  "ccr", "exr", "mach", "macl", "", "", "vbr", "sbr"
};

static void
print_one_arg (info, addr, x, cst, cstlen, rdisp_n, rn, pregnames, len)
     disassemble_info *info;
     bfd_vma addr;
     op_type x;
     int cst, cstlen, rdisp_n, rn;
     const char **pregnames;
     int len;
{
  void *stream = info->stream;
  fprintf_ftype outfn = info->fprintf_func;

  if ((x & SIZE) == L_3 ||
      (x & SIZE) == L_3NZ)
    {
      outfn (stream, "#0x%x", (unsigned) cst);
    }
  else if ((x & MODE) == IMM)
    {
      outfn (stream, "#0x%x", (unsigned) cst);
    }
  else if ((x & MODE) == DBIT  ||
	   (x & MODE) == KBIT)
    {
      outfn (stream, "#%d", (unsigned) cst);
    }
  else if ((x & MODE) == CONST_2)
    outfn (stream, "#2");
  else if ((x & MODE) == CONST_4)
    outfn (stream, "#4");
  else if ((x & MODE) == CONST_8)
    outfn (stream, "#8");
  else if ((x & MODE) == CONST_16)
    outfn (stream, "#16");
  else if ((x & MODE) == REG)
    {
      switch (x & SIZE)
	{
	case L_8:
	  outfn (stream, "%s", regnames[rn]);
	  break;
	case L_16:
	case L_16U:
	  outfn (stream, "%s", wregnames[rn]);
	  break;
	case L_P:
	case L_32:
	  outfn (stream, "%s", lregnames[rn]);
	  break;
	}
    }
  else if ((x & MODE) == LOWREG)
    {
      switch (x & SIZE)
	{
	case L_8:
	  /* Always take low half of reg.  */
	  outfn (stream, "%s.b", regnames[rn < 8 ? rn + 8 : rn]);
	  break;
	case L_16:
	case L_16U:
	  /* Always take low half of reg.  */
	  outfn (stream, "%s.w", wregnames[rn < 8 ? rn : rn - 8]);
	  break;
	case L_P:
	case L_32:
	  outfn (stream, "%s.l", lregnames[rn]);
	  break;
	}
    }
  else if ((x & MODE) == POSTINC)
    {
      outfn (stream, "@@%s+", pregnames[rn]);
    }
  else if ((x & MODE) == POSTDEC)
    {
      outfn (stream, "@@%s-", pregnames[rn]);
    }
  else if ((x & MODE) == PREINC)
    {
      outfn (stream, "@@+%s", pregnames[rn]);
    }
  else if ((x & MODE) == PREDEC)
    {
      outfn (stream, "@@-%s", pregnames[rn]);
    }
  else if ((x & MODE) == IND)
    {
      outfn (stream, "@@%s", pregnames[rn]);
    }
  else if ((x & MODE) == ABS || (x & ABSJMP))
    {
      outfn (stream, "@@0x%x:%d", (unsigned) cst, cstlen);
    }
  else if ((x & MODE) == MEMIND)
    {
      outfn (stream, "@@@@%d (0x%x)", cst, cst);
    }
  else if ((x & MODE) == VECIND)
    {
      /* FIXME Multiplier should be 2 or 4, depending on processor mode,
	 by which is meant "normal" vs. "middle", "advanced", "maximum".  */

      int offset = (cst + 0x80) * 4;
      outfn (stream, "@@@@%d (0x%x)", offset, offset);
    }
  else if ((x & MODE) == PCREL)
    {
      if ((x & SIZE) == L_16 ||
	  (x & SIZE) == L_16U)
	{
	  outfn (stream, ".%s%d (0x%x)",
		   (short) cst > 0 ? "+" : "",
		   (short) cst, 
		   addr + (short) cst + len);
	}
      else
	{
	  outfn (stream, ".%s%d (0x%x)",
		   (char) cst > 0 ? "+" : "",
		   (char) cst, 
		   addr + (char) cst + len);
	}
    }
  else if ((x & MODE) == DISP)
    {
      outfn (stream, "@@(0x%x:%d,%s)", cst, cstlen, 
	       pregnames[rdisp_n]);
    }
  else if ((x & MODE) == INDEXB)
    {
      /* Always take low half of reg.  */
      outfn (stream, "@@(0x%x:%d,%s.b)", cst, cstlen, 
	     regnames[rdisp_n < 8 ? rdisp_n + 8 : rdisp_n]);
    }
  else if ((x & MODE) == INDEXW)
    {
      /* Always take low half of reg.  */
      outfn (stream, "@@(0x%x:%d,%s.w)", cst, cstlen, 
	       wregnames[rdisp_n < 8 ? rdisp_n : rdisp_n - 8]);
    }
  else if ((x & MODE) == INDEXL)
    {
      outfn (stream, "@@(0x%x:%d,%s.l)", cst, cstlen, 
	       lregnames[rdisp_n]);
    }
  else if (x & CTRL)
    {
      outfn (stream, cregnames[rn]);
    }
  else if ((x & MODE) == CCR)
    {
      outfn (stream, "ccr");
    }
  else if ((x & MODE) == EXR)
    {
      outfn (stream, "exr");
    }
  else if ((x & MODE) == MACREG)
    {
      outfn (stream, "mac%c", cst ? 'l' : 'h');
    }
  else
    /* xgettext:c-format */
    outfn (stream, _("Hmmmm 0x%x"), x);
}

static unsigned int
bfd_h8_disassemble (addr, info, mach)
     bfd_vma addr;
     disassemble_info *info;
     int mach;
{
  /* Find the first entry in the table for this opcode.  */
  int regno[3] = { 0, 0, 0 };
  int dispregno[3] = { 0, 0, 0 };
  int cst[3] = { 0, 0, 0 };
  int cstlen[3] = { 0, 0, 0 };
  static bfd_boolean init = 0;
  const struct h8_instruction *qi;
  char const **pregnames = mach != 0 ? lregnames : wregnames;
  int status;
  unsigned int l;
  unsigned char data[MAX_CODE_NIBBLES];
  void *stream = info->stream;
  fprintf_ftype outfn = info->fprintf_func;

  if (!init)
    {
      bfd_h8_disassemble_init ();
      init = 1;
    }

  status = info->read_memory_func (addr, data, 2, info);
  if (status != 0)
    {
      info->memory_error_func (status, addr, info);
      return -1;
    }

  for (l = 2; status == 0 && l < sizeof (data) / 2; l += 2)
    status = info->read_memory_func (addr + l, data + l, 2, info);

  /* Find the exact opcode/arg combo.  */
  for (qi = h8_instructions; qi->opcode->name; qi++)
    {
      const struct h8_opcode *q = qi->opcode;
      op_type *nib = q->data.nib;
      unsigned int len = 0;

      while (1)
	{
	  op_type looking_for = *nib;
	  int thisnib = data[len / 2];
	  int opnr;

	  thisnib = (len & 1) ? (thisnib & 0xf) : ((thisnib / 16) & 0xf);
	  opnr = ((looking_for & OP3) == OP3 ? 2
		  : (looking_for & DST) == DST ? 1 : 0);

	  if (looking_for < 16 && looking_for >= 0)
	    {
	      if (looking_for != thisnib)
		goto fail;
	    }
	  else
	    {
	      if ((int) looking_for & (int) B31)
		{
		  if (!((thisnib & 0x8) != 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B31);
		  thisnib &= 0x7;
		}
	      else if ((int) looking_for & (int) B30)
		{
		  if (!((thisnib & 0x8) == 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B30);
		}

	      if ((int) looking_for & (int) B21)
		{
		  if (!((thisnib & 0x4) != 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B21);
		  thisnib &= 0xb;
		}
	      else if ((int) looking_for & (int) B20)
		{
		  if (!((thisnib & 0x4) == 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B20);
		}
	      if ((int) looking_for & (int) B11)
		{
		  if (!((thisnib & 0x2) != 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B11);
		  thisnib &= 0xd;
		}
	      else if ((int) looking_for & (int) B10)
		{
		  if (!((thisnib & 0x2) == 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B10);
		}

	      if ((int) looking_for & (int) B01)
		{
		  if (!((thisnib & 0x1) != 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B01);
		  thisnib &= 0xe;
		}
	      else if ((int) looking_for & (int) B00)
		{
		  if (!((thisnib & 0x1) == 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B00);
		}

	      if (looking_for & IGNORE)
		{
		  /* Hitachi has declared that IGNORE must be zero.  */
		  if (thisnib != 0)
		    goto fail;
		}
	      else if ((looking_for & MODE) == DATA)
		{
		  ;			/* Skip embedded data.  */
		}
	      else if ((looking_for & MODE) == DBIT)
		{
		  /* Exclude adds/subs by looking at bit 0 and 2, and
                     make sure the operand size, either w or l,
                     matches by looking at bit 1.  */
		  if ((looking_for & 7) != (thisnib & 7))
		    goto fail;

		  cst[opnr] = (thisnib & 0x8) ? 2 : 1;
		}
	      else if ((looking_for & MODE) == DISP  ||
		       (looking_for & MODE) == ABS   ||
		       (looking_for & MODE) == PCREL ||
		       (looking_for & MODE) == INDEXB ||
		       (looking_for & MODE) == INDEXW ||
		       (looking_for & MODE) == INDEXL)
		{
		  extract_immediate (stream, looking_for, thisnib, 
				     data + len / 2, cst + opnr, 
				     cstlen + opnr, q);
		  /* Even address == bra, odd == bra/s.  */
		  if (q->how == O (O_BRAS, SB))
		    cst[opnr] -= 1;
		}
	      else if ((looking_for & MODE) == REG     ||
		       (looking_for & MODE) == LOWREG  ||
		       (looking_for & MODE) == IND     ||
		       (looking_for & MODE) == PREINC  ||
		       (looking_for & MODE) == POSTINC ||
		       (looking_for & MODE) == PREDEC  ||
		       (looking_for & MODE) == POSTDEC)
		{
		  regno[opnr] = thisnib;
		}
	      else if (looking_for & CTRL)	/* Control Register */
		{
		  thisnib &= 7;
		  if (((looking_for & MODE) == CCR  && (thisnib != C_CCR))  ||
		      ((looking_for & MODE) == EXR  && (thisnib != C_EXR))  ||
		      ((looking_for & MODE) == MACH && (thisnib != C_MACH)) ||
		      ((looking_for & MODE) == MACL && (thisnib != C_MACL)) ||
		      ((looking_for & MODE) == VBR  && (thisnib != C_VBR))  ||
		      ((looking_for & MODE) == SBR  && (thisnib != C_SBR)))
		    goto fail;
		  if (((looking_for & MODE) == CCR_EXR && 
		       (thisnib != C_CCR && thisnib != C_EXR)) ||
		      ((looking_for & MODE) == VBR_SBR && 
		       (thisnib != C_VBR && thisnib != C_SBR)) ||
		      ((looking_for & MODE) == MACREG && 
		       (thisnib != C_MACH && thisnib != C_MACL)))
		    goto fail;
		  if (((looking_for & MODE) == CC_EX_VB_SB && 
		       (thisnib != C_CCR && thisnib != C_EXR &&
			thisnib != C_VBR && thisnib != C_SBR)))
		    goto fail;

		  regno[opnr] = thisnib;
		}
	      else if ((looking_for & SIZE) == L_5)
		{
		  cst[opnr] = data[len / 2] & 31;
		  cstlen[opnr] = 5;
		}
	      else if ((looking_for & SIZE) == L_4)
		{
		  cst[opnr] = thisnib;
		  cstlen[opnr] = 4;
		}
	      else if ((looking_for & SIZE) == L_16 ||
		       (looking_for & SIZE) == L_16U)
		{
		  cst[opnr] = (data[len / 2]) * 256 + data[(len + 2) / 2];
		  cstlen[opnr] = 16;
		}
	      else if ((looking_for & MODE) == MEMIND)
		{
		  cst[opnr] = data[1];
		}
	      else if ((looking_for & MODE) == VECIND)
		{
		  cst[opnr] = data[1] & 0x7f;
		}
	      else if ((looking_for & SIZE) == L_32)
		{
		  int i = len / 2;

		  cst[opnr] = ((data[i] << 24) 
			       | (data[i + 1] << 16) 
			       | (data[i + 2] << 8)
			       | (data[i + 3]));

		  cstlen[opnr] = 32;
		}
	      else if ((looking_for & SIZE) == L_24)
		{
		  int i = len / 2;

		  cst[opnr] = 
		    (data[i] << 16) | (data[i + 1] << 8) | (data[i + 2]);
		  cstlen[opnr] = 24;
		}
	      else if (looking_for & IGNORE)
		{
		  ;
		}
	      else if (looking_for & DISPREG)
		{
		  dispregno[opnr] = thisnib & 7;
		}
	      else if ((looking_for & MODE) == KBIT)
		{
		  switch (thisnib)
		    {
		    case 9:
		      cst[opnr] = 4;
		      break;
		    case 8:
		      cst[opnr] = 2;
		      break;
		    case 0:
		      cst[opnr] = 1;
		      break;
		    default:
		      goto fail;
		    }
		}
	      else if ((looking_for & SIZE) == L_8)
		{
		  cstlen[opnr] = 8;
		  cst[opnr] = data[len / 2];
		}
	      else if ((looking_for & SIZE) == L_3 ||
		       (looking_for & SIZE) == L_3NZ)
		{
		  cst[opnr] = thisnib & 0x7;
		  if (cst[opnr] == 0 && (looking_for & SIZE) == L_3NZ)
		    goto fail;
		}
	      else if ((looking_for & SIZE) == L_2)
		{
		  cstlen[opnr] = 2;
		  cst[opnr] = thisnib & 0x3;
		}
	      else if ((looking_for & MODE) == MACREG)
		{
		  cst[opnr] = (thisnib == 3);
		}
	      else if (looking_for == (op_type) E)
		{
		  int i;

		  for (i = 0; i < qi->length; i++)
		    outfn (stream, "%02x ", data[i]);

		  for (; i < 6; i++)
		    outfn (stream, "   ");

		  outfn (stream, "%s\t", q->name);

		  /* Gross.  Disgusting.  */
		  if (strcmp (q->name, "ldm.l") == 0)
		    {
		      int count, high;

		      count = (data[1] / 16) & 0x3;
		      high = regno[1];

		      outfn (stream, "@@sp+,er%d-er%d", high - count, high);
		      return qi->length;
		    }

		  if (strcmp (q->name, "stm.l") == 0)
		    {
		      int count, low;

		      count = (data[1] / 16) & 0x3;
		      low = regno[0];

		      outfn (stream, "er%d-er%d,@@-sp", low, low + count);
		      return qi->length;
		    }
		  if (strcmp (q->name, "rte/l") == 0
		      || strcmp (q->name, "rts/l") == 0)
		    {
		      if (regno[0] == 0)
			outfn (stream, "er%d", regno[1]);
		      else
			{
			  outfn (stream, "er%d-er%d", regno[1] - regno[0],
				 regno[1]);
			}
		      return qi->length;
		    }
		  if (strncmp (q->name, "mova", 4) == 0)
		    {
		      op_type *args = q->args.nib;

		      if (args[1] == (op_type) E)
			{
			  /* Short form.  */
			  print_one_arg (info, addr, args[0], cst[0], 
					 cstlen[0], dispregno[0], regno[0], 
					 pregnames, qi->length);
			  outfn (stream, ",er%d", dispregno[0]);
			}
		      else
			{
			  outfn (stream, "@@(0x%x:%d,", cst[0], cstlen[0]);
			  print_one_arg (info, addr, args[1], cst[1], 
					 cstlen[1], dispregno[1], regno[1], 
					 pregnames, qi->length);
			  outfn (stream, ".%c),",
				 (args[0] & MODE) == INDEXB ? 'b' : 'w');
			  print_one_arg (info, addr, args[2], cst[2], 
					 cstlen[2], dispregno[2], regno[2], 
					 pregnames, qi->length);
			}
		      return qi->length;
		    }
		  /* Fill in the args.  */
		  {
		    op_type *args = q->args.nib;
		    int hadone = 0;
		    int nargs;

		    for (nargs = 0; 
			 nargs < 3 && args[nargs] != (op_type) E; 
			 nargs++)
		      {
			int x = args[nargs];

			if (hadone)
			  outfn (stream, ",");

			print_one_arg (info, addr, x,
				       cst[nargs], cstlen[nargs],
				       dispregno[nargs], regno[nargs],
				       pregnames, qi->length);

			hadone = 1;
		      }
		  }

		  return qi->length;
		}
	      else
		/* xgettext:c-format */
		outfn (stream, _("Don't understand 0x%x \n"), looking_for);
	    }

	  len++;
	  nib++;
	}

    fail:
      ;
    }

  /* Fell off the end.  */
  outfn (stream, "%02x %02x        .word\tH'%x,H'%x",
	   data[0], data[1],
	   data[0], data[1]);
  return 2;
}

int
print_insn_h8300 (addr, info)
     bfd_vma addr;
     disassemble_info *info;
{
  return bfd_h8_disassemble (addr, info, 0);
}

int
print_insn_h8300h (addr, info)
     bfd_vma addr;
     disassemble_info *info;
{
  return bfd_h8_disassemble (addr, info, 1);
}

int
print_insn_h8300s (addr, info)
     bfd_vma addr;
     disassemble_info *info;
{
  return bfd_h8_disassemble (addr, info, 2);
}
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1996, 1998, 2000, 2001, 2002
d37 10
a46 2
static unsigned int bfd_h8_disassemble
  PARAMS ((bfd_vma, disassemble_info *, int));
d50 1
d81 1
a81 1
      for (i = 0; p->data.nib[i] != E; i++)
d85 4
a88 1
	abort ();
d99 262
d362 1
a362 1
bfd_h8_disassemble (addr, info, mode)
d365 1
a365 1
     int mode;
d368 4
a371 21
  static const char *regnames[] =
    {
      "r0h", "r1h", "r2h", "r3h", "r4h", "r5h", "r6h", "r7h",
      "r0l", "r1l", "r2l", "r3l", "r4l", "r5l", "r6l", "r7l"
    };
  static const char *wregnames[] =
    {
      "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
      "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7"
    };
  static const char *lregnames[] =
    {
      "er0", "er1", "er2", "er3", "er4", "er5", "er6", "er7",
      "er0", "er1", "er2", "er3", "er4", "er5", "er6", "er7"
    };
  int rs = 0;
  int rd = 0;
  int rdisp = 0;
  int abs = 0;
  int bit = 0;
  int plen = 0;
d374 1
a374 1
  char const **pregnames = mode != 0 ? lregnames : wregnames;
d376 2
a377 2
  int l;
  unsigned char data[20];
d379 1
a379 1
  fprintf_ftype fprintf = info->fprintf_func;
d394 1
a394 1
  for (l = 2; status == 0 && l < 10; l += 2)
d407 2
a408 1
	  int thisnib = data[len >> 1];
d410 3
a412 1
	  thisnib = (len & 1) ? (thisnib & 0xf) : ((thisnib >> 4) & 0xf);
d423 1
a423 1
		  if (!(((int) thisnib & 0x8) != 0))
d427 8
d437 16
a452 1
	      if ((int) looking_for & (int) B30)
d454 1
a454 1
		  if (!(((int) thisnib & 0x8) == 0))
d457 25
a481 1
		  looking_for = (op_type) ((int) looking_for & ~(int) B30);
d484 11
a494 1
	      if (looking_for & DBIT)
d502 54
a555 1
		  abs = (thisnib & 0x8) ? 2 : 1;
d557 1
a557 1
	      else if (looking_for & (REG | IND | INC | DEC))
d559 2
a560 4
		  if (looking_for & SRC)
		    rs = thisnib;
		  else
		    rd = thisnib;
d562 2
a563 1
	      else if (looking_for & L_16)
d565 2
a566 2
		  abs = (data[len >> 1]) * 256 + data[(len + 2) >> 1];
		  plen = 16;
d568 1
a568 1
	      else if (looking_for & ABSJMP)
d570 1
a570 1
		  abs = (data[1] << 16) | (data[2] << 8) | (data[3]);
d572 1
a572 1
	      else if (looking_for & MEMIND)
d574 1
a574 1
		  abs = data[1];
d576 1
a576 1
	      else if (looking_for & L_32)
d578 1
a578 1
		  int i = len >> 1;
d580 4
a583 4
		  abs = (data[i] << 24)
		    | (data[i + 1] << 16)
		    | (data[i + 2] << 8)
		    | (data[i + 3]);
d585 1
a585 1
		  plen = 32;
d587 1
a587 1
	      else if (looking_for & L_24)
d589 1
a589 1
		  int i = len >> 1;
d591 3
a593 2
		  abs = (data[i] << 16) | (data[i + 1] << 8) | (data[i + 2]);
		  plen = 24;
d601 1
a601 1
		  rdisp = thisnib;
d603 1
a603 1
	      else if (looking_for & KBIT)
d608 1
a608 1
		      abs = 4;
d611 1
a611 1
		      abs = 2;
d614 1
a614 1
		      abs = 1;
d620 1
a620 1
	      else if (looking_for & L_8)
d622 2
a623 2
		  plen = 8;
		  abs = data[len >> 1];
d625 2
a626 1
	      else if (looking_for & L_3)
d628 3
a630 1
		  bit = thisnib & 0x7;
d632 1
a632 1
	      else if (looking_for & L_2)
d634 2
a635 2
		  plen = 2;
		  abs = thisnib & 0x3;
d637 1
a637 1
	      else if (looking_for & MACREG)
d639 1
a639 1
		  abs = (thisnib == 3);
d641 1
a641 1
	      else if (looking_for == E)
d646 1
a646 1
		    fprintf (stream, "%02x ", data[i]);
d649 1
a649 1
		    fprintf (stream, "   ");
d651 1
a651 1
		  fprintf (stream, "%s\t", q->name);
d658 2
a659 2
		      count = (data[1] >> 4) & 0x3;
		      high = data[3] & 0x7;
d661 1
a661 1
		      fprintf (stream, "@@sp+,er%d-er%d", high - count, high);
d669 2
a670 2
		      count = (data[1] >> 4) & 0x3;
		      low = data[3] & 0x7;
d672 13
a684 1
		      fprintf (stream, "er%d-er%d,@@-sp", low, low + count);
d687 3
d691 22
d717 1
d719 3
a721 1
		    while (*args != E)
d723 1
a723 1
			int x = *args;
d726 1
a726 1
			  fprintf (stream, ",");
d728 4
a731 93
			if (x & L_3)
			  {
			    fprintf (stream, "#0x%x", (unsigned) bit);
			  }
			else if (x & (IMM | KBIT | DBIT))
			  {
			    /* Bletch.  For shal #2,er0 and friends.  */
			    if (*(args + 1) & SRC_IN_DST)
			      abs = 2;

			    fprintf (stream, "#0x%x", (unsigned) abs);
			  }
			else if (x & REG)
			  {
			    int rn = (x & DST) ? rd : rs;

			    switch (x & SIZE)
			      {
			      case L_8:
				fprintf (stream, "%s", regnames[rn]);
				break;
			      case L_16:
				fprintf (stream, "%s", wregnames[rn]);
				break;
			      case L_P:
			      case L_32:
				fprintf (stream, "%s", lregnames[rn]);
				break;
			      }
			  }
			else if (x & MACREG)
			  {
			    fprintf (stream, "mac%c", abs ? 'l' : 'h');
			  }
			else if (x & INC)
			  {
			    fprintf (stream, "@@%s+", pregnames[rs]);
			  }
			else if (x & DEC)
			  {
			    fprintf (stream, "@@-%s", pregnames[rd]);
			  }
			else if (x & IND)
			  {
			    int rn = (x & DST) ? rd : rs;
			    fprintf (stream, "@@%s", pregnames[rn]);
			  }
			else if (x & ABS8MEM)
			  {
			    fprintf (stream, "@@0x%x:8", (unsigned) abs);
			  }
			else if (x & (ABS | ABSJMP))
			  {
			    fprintf (stream, "@@0x%x:%d", (unsigned) abs, plen);
			  }
			else if (x & MEMIND)
			  {
			    fprintf (stream, "@@@@%d (%x)", abs, abs);
			  }
			else if (x & PCREL)
			  {
			    if (x & L_16)
			      {
				abs += 2;
				fprintf (stream,
					 ".%s%d (%x)",
					 (short) abs > 0 ? "+" : "",
					 (short) abs, addr + (short) abs + 2);
			      }
			    else
			      {
				fprintf (stream,
					 ".%s%d (%x)",
					 (char) abs > 0 ? "+" : "",
					 (char) abs, addr + (char) abs + 2);
			      }
			  }
			else if (x & DISP)
			  {
			    fprintf (stream, "@@(0x%x:%d,%s)",
				     abs, plen, pregnames[rdisp]);
			  }
			else if (x & CCR)
			  {
			    fprintf (stream, "ccr");
			  }
			else if (x & EXR)
			  {
			    fprintf (stream, "exr");
			  }
			else
			  /* xgettext:c-format */
			  fprintf (stream, _("Hmmmm %x"), x);
a733 1
			args++;
d741 1
a741 1
		fprintf (stream, _("Don't understand %x \n"), looking_for);
d753 1
a753 1
  fprintf (stream, "%02x %02x        .word\tH'%x,H'%x",
@


1.5
log
@resolve conflicts.
@
text
@d2 2
a3 1
   Copyright 1993, 1994, 1996, 1998, 2000 Free Software Foundation, Inc.
d26 13
d46 5
a50 1
  struct h8_opcode *p;
d52 4
a55 1
  for (p = h8_opcodes; p->name; p++)
d78 2
a79 1
      p->length = i / 2;
d81 4
d87 1
a87 1
unsigned int
d94 1
a94 1
  static CONST char *regnames[] =
d99 1
a99 1
  static CONST char *wregnames[] =
d104 1
a104 1
  static CONST char *lregnames[] =
d115 3
a117 3
  static boolean init = 0;
  struct h8_opcode *q;
  char CONST **pregnames = mode != 0 ? lregnames : wregnames;
d141 1
a141 1
  for (q = h8_opcodes; q->name; q++)
d143 1
d272 1
a272 1
		  for (i = 0; i < q->length; i++)
d289 1
a289 1
		      return q->length;
d300 1
a300 1
		      return q->length;
d414 1
a414 1
		  return q->length;
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1993, 1998 Free Software Foundation, Inc.
a25 1

d27 1
a27 2
   to disassemble
 */
a31 2


d40 1
a40 3
	{
	  n1 = (int) p->data.nib[0];
	}
d43 1
d45 1
a45 3
	{
	  n2 = (int) p->data.nib[1];
	}
d50 1
a50 1
	 that the count is the same s the length */
d52 2
a53 1
	/*EMPTY*/ ;
d56 1
a58 1

a60 1

d67 1
a67 1
  /* Find the first entry in the table for this opcode */
d71 2
a72 2
      "r0l", "r1l", "r2l", "r3l", "r4l", "r5l", "r6l", "r7l"};
  
d77 1
a77 2
      };
  
d82 1
a82 3
      }
  ;

d90 1
a90 1
  struct h8_opcode *q = h8_opcodes;
d94 1
a94 2
  
  unsigned char data[20];  
d104 2
a105 2
  status = info->read_memory_func(addr, data, 2, info);
  if (status != 0) 
d107 1
a107 1
      info->memory_error_func(status, addr, info);
a109 6
  for (l = 2; status == 0 && l < 10; l+=2)
    {
      status = info->read_memory_func(addr+l, data+l, 2, info);
    }
  
  
d111 5
a115 2
  /* Find the exact opcode/arg combo */
  while (q->name)
d117 1
a117 1
      op_type *nib;
a119 2
      nib = q->data.nib;
      
d124 1
a124 1
	  
d126 2
a127 2
	  
	  if (looking_for < 16 && looking_for >=0) 
d129 1
a129 2
	      
	      if (looking_for != thisnib) 
d132 1
a132 2
	  
	  else 
a133 1
	      
d136 1
a136 1
		  if (! (((int) thisnib & 0x8) != 0)) 
d138 1
d141 1
d144 1
a144 1
		  if (!(((int) thisnib & 0x8) == 0)) 
d146 1
d152 6
a157 1
		  if ((looking_for & 5) != (thisnib &5)) goto fail;
d159 2
a160 3
		}		  
	      
	      else  if (looking_for & (REG | IND|INC|DEC))
d163 1
a163 3
		    {
		      rs = thisnib;
		    }
d165 1
a165 3
		    {
		      rd = thisnib;
		    }
a170 1
	      
d172 1
a172 1
	      else if(looking_for & ABSJMP)
d174 1
a174 4
		  abs =
		    (data[1] << 16)
		      | (data[2] << 8)
			| (data[3]);
d176 1
a176 1
	      else if(looking_for & MEMIND)
d183 1
d186 2
a187 2
		      | (data[i + 2] << 8)
			| (data[i+ 3]);
d189 1
a189 2
		  plen =32;
	      
d194 3
a196 2
		  abs = (data[i] << 16) | (data[i + 1] << 8)|  (data[i+2]);
		  plen =24;
d200 1
a200 1
		  
d208 1
a208 1
		  switch (thisnib) 
d225 1
a225 1
		  plen = 8;		  
d243 4
d248 2
a249 2
		  {
		    int i;
a250 9
		    for (i = 0; i < q->length; i++)
		      {
			fprintf (stream, "%02x ", data[i]);
		      }
		    for (; i < 6; i++)
		      {
			fprintf (stream, "   ");
		      }
		  }
d276 1
a276 1
		  /* Fill in the args */
a280 1

d284 1
a287 1

d292 1
a292 1
			else if (x & (IMM|KBIT|DBIT))
d295 1
a295 1
			    if (*(args+1) & SRC_IN_DST)
d303 1
a315 1
		    
a329 1

a334 1

d339 1
a339 2

			else if (x & (ABS|ABSJMP))
a342 1

a346 1

d349 1
a349 1
			    if (x & L_16) 
d351 12
a362 3
				abs  +=2;
				fprintf (stream, ".%s%d (%x)", (short) abs > 0 ? "+" : "", (short) abs,
					 addr + (short) abs + 2);
a363 4
			    else {
			      fprintf (stream, ".%s%d (%x)", (char) abs > 0 ? "+" : "", (char) abs,
				       addr + (char) abs + 2);
			    }
d367 2
a368 1
			    fprintf (stream, "@@(0x%x:%d,%s)", abs,plen, pregnames[rdisp]);
a369 1

d381 1
d386 1
a388 2

      
d390 2
a391 4
		{
		  /* xgettext:c-format */
		  fprintf (stream, _("Don't understand %x \n"), looking_for);
		}
d393 1
a393 1
	  
d397 1
a397 1
      
d399 1
a399 1
      q++;
d402 1
a402 1
  /* Fell of the end */
d409 1
a409 1
int 
d411 2
a412 2
bfd_vma addr; 
disassemble_info *info;
d414 1
a414 1
  return bfd_h8_disassemble (addr, info , 0);
d417 1
a417 1
int 
d419 2
a420 2
bfd_vma addr;
disassemble_info *info;
d422 1
a422 1
  return bfd_h8_disassemble (addr, info , 1);
d425 1
a425 1
int 
d427 2
a428 2
bfd_vma addr;
disassemble_info *info;
d430 1
a430 1
  return bfd_h8_disassemble (addr, info , 2);
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2 1
a2 1
   Copyright (C) 1993 Free Software Foundation, Inc.
d20 1
d24 1
d214 1
a214 2
		  abs = (data[i] << 16) | (data[i + 1] << 8)|  (data[i+
								     2]);
a402 1

d404 2
a405 1
			  fprintf (stream, "Hmmmm %x", x);
d416 2
a417 1
		  fprintf (stream, "Dont understand %x \n", looking_for);
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d67 1
a67 1
bfd_h8_disassemble (addr, info, hmode)
d70 1
a70 1
     int hmode;
d99 1
a99 1
  char CONST **pregnames = hmode ? lregnames : wregnames;
d237 2
d248 1
a248 2
		  plen = 3;
		  bit = thisnib;
d253 5
a257 1
		  abs = thisnib;
d275 24
d318 4
d342 4
a345 1

d361 6
a366 1
			else if (x & (ABS|ABSJMP|ABS8MEM))
a395 1

d398 4
d442 1
a442 1
 int 
d450 7
@


1.1
log
@Initial revision
@
text
@d95 1
d247 1
a247 1
		  abs = thisnib;
d283 5
a287 1
			if (x & (IMM|KBIT|DBIT))
a288 1
			
d325 1
a325 1
			else if (x & (ABS|ABSJMP|ABSMOV))
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@a94 1
  int bit = 0;
d246 1
a246 1
		  bit = thisnib;
d282 1
a282 5
			if (x & L_3)
			  {
			    fprintf (stream, "#0x%x", (unsigned) bit);
			  }
			else if (x & (IMM|KBIT|DBIT))
d284 1
d321 1
a321 1
			else if (x & (ABS|ABSJMP|ABS8MEM))
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d67 1
a67 1
bfd_h8_disassemble (addr, info, mode)
d70 1
a70 1
     int mode;
d99 1
a99 1
  char CONST **pregnames = mode != 0 ? lregnames : wregnames;
a236 2
		    default:
		      goto fail;
d246 2
a247 1
		  bit = thisnib & 0x7;
d252 1
a252 5
		  abs = thisnib & 0x3;
		}
	      else if (looking_for & MACREG)
		{
		  abs = (thisnib == 3);
a269 24

		  /* Gross.  Disgusting.  */
		  if (strcmp (q->name, "ldm.l") == 0)
		    {
		      int count, high;

		      count = (data[1] >> 4) & 0x3;
		      high = data[3] & 0x7;

		      fprintf (stream, "@@sp+,er%d-er%d", high - count, high);
		      return q->length;
		    }

		  if (strcmp (q->name, "stm.l") == 0)
		    {
		      int count, low;

		      count = (data[1] >> 4) & 0x3;
		      low = data[3] & 0x7;

		      fprintf (stream, "er%d-er%d,@@-sp", low, low + count);
		      return q->length;
		    }

a288 4
			    /* Bletch.  For shal #2,er0 and friends.  */
			    if (*(args+1) & SRC_IN_DST)
			      abs = 2;

d309 1
a309 4
			else if (x & MACREG)
			  {
			    fprintf (stream, "mac%c", abs ? 'l' : 'h');
			  }
d325 1
a325 6
			else if (x & ABS8MEM)
			  {
			    fprintf (stream, "@@0x%x:8", (unsigned) abs);
			  }

			else if (x & (ABS|ABSJMP))
d355 1
a357 4
			else if (x & EXR)
			  {
			    fprintf (stream, "exr");
			  }
d398 1
a398 1
int 
a405 7
int 
print_insn_h8300s (addr, info)
bfd_vma addr;
disassemble_info *info;
{
  return bfd_h8_disassemble (addr, info , 2);
}
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1993, 1998 Free Software Foundation, Inc.
a19 1
#include "sysdep.h"
a22 1
#include "opintl.h"
d212 2
a213 1
		  abs = (data[i] << 16) | (data[i + 1] << 8)|  (data[i+2]);
d402 1
d404 1
a404 2
			  /* xgettext:c-format */
			  fprintf (stream, _("Hmmmm %x"), x);
d415 1
a415 2
		  /* xgettext:c-format */
		  fprintf (stream, _("Don't understand %x \n"), looking_for);
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1996, 1998, 2000 Free Software Foundation, Inc.
d26 1
d28 2
a29 1
   to disassemble.  */
d34 2
d44 3
a46 1
	n1 = (int) p->data.nib[0];
a48 1

d50 3
a52 1
	n2 = (int) p->data.nib[1];
d57 1
a57 1
	 that the count is the same as the length.  */
d59 1
a59 2
	;

a61 1

d64 1
d67 1
d74 1
a74 1
  /* Find the first entry in the table for this opcode.  */
d78 2
a79 2
      "r0l", "r1l", "r2l", "r3l", "r4l", "r5l", "r6l", "r7l"
    };
d84 2
a85 1
    };
d90 3
a92 1
    };
d100 1
a100 1
  struct h8_opcode *q;
d104 2
a105 1
  unsigned char data[20];
d115 2
a116 2
  status = info->read_memory_func (addr, data, 2, info);
  if (status != 0)
d118 1
a118 1
      info->memory_error_func (status, addr, info);
d121 6
d128 2
a129 5
  for (l = 2; status == 0 && l < 10; l += 2)
    status = info->read_memory_func (addr + l, data + l, 2, info);

  /* Find the exact opcode/arg combo.  */
  for (q = h8_opcodes; q->name; q++)
d131 1
a131 1
      op_type *nib = q->data.nib;
d134 2
d140 1
a140 1

d142 2
a143 2

	  if (looking_for < 16 && looking_for >= 0)
d145 2
a146 1
	      if (looking_for != thisnib)
d149 2
a150 1
	  else
d152 1
d155 1
a155 1
		  if (!(((int) thisnib & 0x8) != 0))
a156 1

a158 1

d161 1
a161 1
		  if (!(((int) thisnib & 0x8) == 0))
a162 1

d168 1
a168 6
		  /* Exclude adds/subs by looking at bit 0 and 2, and
                     make sure the operand size, either w or l,
                     matches by looking at bit 1.  */
		  if ((looking_for & 7) != (thisnib & 7))
		    goto fail;

d170 3
a172 2
		}
	      else if (looking_for & (REG | IND | INC | DEC))
d175 3
a177 1
		    rs = thisnib;
d179 3
a181 1
		    rd = thisnib;
d187 1
d189 1
a189 1
	      else if (looking_for & ABSJMP)
d191 4
a194 1
		  abs = (data[1] << 16) | (data[2] << 8) | (data[3]);
d196 1
a196 1
	      else if (looking_for & MEMIND)
a202 1

d205 2
a206 2
		    | (data[i + 2] << 8)
		    | (data[i + 3]);
d208 2
a209 1
		  plen = 32;
d214 2
a215 3

		  abs = (data[i] << 16) | (data[i + 1] << 8) | (data[i + 2]);
		  plen = 24;
d219 1
a219 1
		  ;
d227 1
a227 1
		  switch (thisnib)
d244 1
a244 1
		  plen = 8;
a261 1
		  int i;
d263 2
a264 5
		  for (i = 0; i < q->length; i++)
		    fprintf (stream, "%02x ", data[i]);

		  for (; i < 6; i++)
		    fprintf (stream, "   ");
d266 9
d300 1
a300 1
		  /* Fill in the args.  */
d305 1
a308 1

d312 1
d317 1
a317 1
			else if (x & (IMM | KBIT | DBIT))
d320 1
a320 1
			    if (*(args + 1) & SRC_IN_DST)
a327 1

d340 1
d355 1
d361 1
d366 2
a367 1
			else if (x & (ABS | ABSJMP))
d371 1
d376 1
d379 1
a379 1
			    if (x & L_16)
d381 3
a383 12
				abs += 2;
				fprintf (stream,
					 ".%s%d (%x)",
					 (short) abs > 0 ? "+" : "",
					 (short) abs, addr + (short) abs + 2);
			      }
			    else
			      {
				fprintf (stream,
					 ".%s%d (%x)",
					 (char) abs > 0 ? "+" : "",
					 (char) abs, addr + (char) abs + 2);
d385 4
d392 1
a392 2
			    fprintf (stream, "@@(0x%x:%d,%s)",
				     abs, plen, pregnames[rdisp]);
d394 1
a405 1

a409 1

d412 2
d415 4
a418 2
		/* xgettext:c-format */
		fprintf (stream, _("Don't understand %x \n"), looking_for);
d420 1
a420 1

d424 1
a424 1

d426 1
a426 1
      ;
d429 1
a429 1
  /* Fell off the end.  */
d436 1
a436 1
int
d438 2
a439 2
     bfd_vma addr;
     disassemble_info *info;
d441 1
a441 1
  return bfd_h8_disassemble (addr, info, 0);
d444 1
a444 1
int
d446 2
a447 2
     bfd_vma addr;
     disassemble_info *info;
d449 1
a449 1
  return bfd_h8_disassemble (addr, info, 1);
d452 1
a452 1
int
d454 2
a455 2
     bfd_vma addr;
     disassemble_info *info;
d457 1
a457 1
  return bfd_h8_disassemble (addr, info, 2);
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 2
   Copyright 1993, 1994, 1996, 1998, 2000, 2001, 2002
   Free Software Foundation, Inc.
a24 13
#include "libiberty.h"

struct h8_instruction
{
  int length;
  const struct h8_opcode *opcode;
};

struct h8_instruction *h8_instructions;

static void bfd_h8_disassemble_init PARAMS ((void));
static unsigned int bfd_h8_disassemble
  PARAMS ((bfd_vma, disassemble_info *, int));
d32 1
a32 5
  unsigned int nopcodes;
  const struct h8_opcode *p;
  struct h8_instruction *pi;

  nopcodes = sizeof (h8_opcodes) / sizeof (struct h8_opcode);
d34 1
a34 4
  h8_instructions = (struct h8_instruction *)
    xmalloc (nopcodes * sizeof (struct h8_instruction));

  for (p = h8_opcodes, pi = h8_instructions; p->name; p++, pi++)
d57 1
a57 2
      pi->length = i / 2;
      pi->opcode = p;
a58 4

  /* Add entry for the NULL vector terminator.  */
  pi->length = 0;
  pi->opcode = p;
d61 1
a61 1
static unsigned int
d68 1
a68 1
  static const char *regnames[] =
d73 1
a73 1
  static const char *wregnames[] =
d78 1
a78 1
  static const char *lregnames[] =
d89 3
a91 3
  static bfd_boolean init = 0;
  const struct h8_instruction *qi;
  char const **pregnames = mode != 0 ? lregnames : wregnames;
d115 1
a115 1
  for (qi = h8_instructions; qi->opcode->name; qi++)
a116 1
      const struct h8_opcode *q = qi->opcode;
d245 1
a245 1
		  for (i = 0; i < qi->length; i++)
d262 1
a262 1
		      return qi->length;
d273 1
a273 1
		      return qi->length;
d387 1
a387 1
		  return qi->length;
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1996, 1998, 2000, 2001, 2002, 2003
d37 2
a38 10
static void print_one_arg PARAMS ((disassemble_info *, bfd_vma, op_type,
				   int, int, int, int, const char **, int));
static unsigned int bfd_h8_disassemble PARAMS ((bfd_vma, 
						disassemble_info *, 
						int));
static void extract_immediate PARAMS ((FILE *, 
				       op_type, int, 
				       unsigned char *,
				       int *, int *,
				       const struct h8_opcode *));
a41 1

d72 1
a72 1
      for (i = 0; p->data.nib[i] != (op_type) E; i++)
d76 1
a76 4
	{
	  fprintf (stderr, "Internal error, h8_disassemble_init.\n");
	  abort ();
	}
a86 262
static void
extract_immediate (stream, looking_for, thisnib, data, cst, len, q)
     FILE *stream;
     op_type looking_for;
     int thisnib;
     unsigned char *data;
     int *cst, *len;
     const struct h8_opcode *q;
{
  switch (looking_for & SIZE)
    {
    case L_2:
      *len = 2;
      *cst = thisnib & 3;

      /* DISP2 special treatment.  */
      if ((looking_for & MODE) == DISP)
	{
	  if (OP_KIND (q->how) == O_MOVAB ||
	      OP_KIND (q->how) == O_MOVAW ||
	      OP_KIND (q->how) == O_MOVAL)
	    {
	      /* Handling for mova insn.  */
	      switch (q->args.nib[0] & MODE) {
	      case INDEXB:
	      default:
		break;
	      case INDEXW:
		*cst *= 2;
		break;
	      case INDEXL:
		*cst *= 4;
		break;
	      }
	    }
	  else
	    {
	      /* Handling for non-mova insn.  */
	      switch (OP_SIZE (q->how)) {
	      default: break;
	      case SW:
		*cst *= 2;
		break;
	      case SL:
		*cst *= 4;
		break;
	      }
	    }
	}
      break;
    case L_8:
      *len = 8;
      *cst = data[0];
      break;
    case L_16:
    case L_16U:
      *len = 16;
      *cst = (data[0] << 8) + data [1];
#if 0
      if ((looking_for & SIZE) == L_16)
	*cst = (short) *cst;	/* sign extend */
#endif
      break;
    case L_32:
      *len = 32;
      *cst = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3];
      break;
    default:
      *len = 0;
      *cst = 0;
      fprintf (stream, "DISP bad size\n");
      break;
    }
}

static const char *regnames[] =
{
  "r0h", "r1h", "r2h", "r3h", "r4h", "r5h", "r6h", "r7h",
  "r0l", "r1l", "r2l", "r3l", "r4l", "r5l", "r6l", "r7l"
};
static const char *wregnames[] =
{
  "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
  "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7"
};
static const char *lregnames[] =
{
  "er0", "er1", "er2", "er3", "er4", "er5", "er6", "er7",
  "er0", "er1", "er2", "er3", "er4", "er5", "er6", "er7"
};
static const char *cregnames[] =
{
  "ccr", "exr", "mach", "macl", "", "", "vbr", "sbr"
};

static void
print_one_arg (info, addr, x, cst, cstlen, rdisp_n, rn, pregnames, len)
     disassemble_info *info;
     bfd_vma addr;
     op_type x;
     int cst, cstlen, rdisp_n, rn;
     const char **pregnames;
     int len;
{
  void *stream = info->stream;
  fprintf_ftype outfn = info->fprintf_func;

  if ((x & SIZE) == L_3 ||
      (x & SIZE) == L_3NZ)
    {
      outfn (stream, "#0x%x", (unsigned) cst);
    }
  else if ((x & MODE) == IMM)
    {
      outfn (stream, "#0x%x", (unsigned) cst);
    }
  else if ((x & MODE) == DBIT  ||
	   (x & MODE) == KBIT)
    {
      outfn (stream, "#%d", (unsigned) cst);
    }
  else if ((x & MODE) == CONST_2)
    outfn (stream, "#2");
  else if ((x & MODE) == CONST_4)
    outfn (stream, "#4");
  else if ((x & MODE) == CONST_8)
    outfn (stream, "#8");
  else if ((x & MODE) == CONST_16)
    outfn (stream, "#16");
  else if ((x & MODE) == REG)
    {
      switch (x & SIZE)
	{
	case L_8:
	  outfn (stream, "%s", regnames[rn]);
	  break;
	case L_16:
	case L_16U:
	  outfn (stream, "%s", wregnames[rn]);
	  break;
	case L_P:
	case L_32:
	  outfn (stream, "%s", lregnames[rn]);
	  break;
	}
    }
  else if ((x & MODE) == LOWREG)
    {
      switch (x & SIZE)
	{
	case L_8:
	  /* Always take low half of reg.  */
	  outfn (stream, "%s.b", regnames[rn < 8 ? rn + 8 : rn]);
	  break;
	case L_16:
	case L_16U:
	  /* Always take low half of reg.  */
	  outfn (stream, "%s.w", wregnames[rn < 8 ? rn : rn - 8]);
	  break;
	case L_P:
	case L_32:
	  outfn (stream, "%s.l", lregnames[rn]);
	  break;
	}
    }
  else if ((x & MODE) == POSTINC)
    {
      outfn (stream, "@@%s+", pregnames[rn]);
    }
  else if ((x & MODE) == POSTDEC)
    {
      outfn (stream, "@@%s-", pregnames[rn]);
    }
  else if ((x & MODE) == PREINC)
    {
      outfn (stream, "@@+%s", pregnames[rn]);
    }
  else if ((x & MODE) == PREDEC)
    {
      outfn (stream, "@@-%s", pregnames[rn]);
    }
  else if ((x & MODE) == IND)
    {
      outfn (stream, "@@%s", pregnames[rn]);
    }
  else if ((x & MODE) == ABS || (x & ABSJMP))
    {
      outfn (stream, "@@0x%x:%d", (unsigned) cst, cstlen);
    }
  else if ((x & MODE) == MEMIND)
    {
      outfn (stream, "@@@@%d (0x%x)", cst, cst);
    }
  else if ((x & MODE) == VECIND)
    {
      /* FIXME Multiplier should be 2 or 4, depending on processor mode,
	 by which is meant "normal" vs. "middle", "advanced", "maximum".  */

      int offset = (cst + 0x80) * 4;
      outfn (stream, "@@@@%d (0x%x)", offset, offset);
    }
  else if ((x & MODE) == PCREL)
    {
      if ((x & SIZE) == L_16 ||
	  (x & SIZE) == L_16U)
	{
	  outfn (stream, ".%s%d (0x%x)",
		   (short) cst > 0 ? "+" : "",
		   (short) cst, 
		   addr + (short) cst + len);
	}
      else
	{
	  outfn (stream, ".%s%d (0x%x)",
		   (char) cst > 0 ? "+" : "",
		   (char) cst, 
		   addr + (char) cst + len);
	}
    }
  else if ((x & MODE) == DISP)
    {
      outfn (stream, "@@(0x%x:%d,%s)", cst, cstlen, 
	       pregnames[rdisp_n]);
    }
  else if ((x & MODE) == INDEXB)
    {
      /* Always take low half of reg.  */
      outfn (stream, "@@(0x%x:%d,%s.b)", cst, cstlen, 
	     regnames[rdisp_n < 8 ? rdisp_n + 8 : rdisp_n]);
    }
  else if ((x & MODE) == INDEXW)
    {
      /* Always take low half of reg.  */
      outfn (stream, "@@(0x%x:%d,%s.w)", cst, cstlen, 
	       wregnames[rdisp_n < 8 ? rdisp_n : rdisp_n - 8]);
    }
  else if ((x & MODE) == INDEXL)
    {
      outfn (stream, "@@(0x%x:%d,%s.l)", cst, cstlen, 
	       lregnames[rdisp_n]);
    }
  else if (x & CTRL)
    {
      outfn (stream, cregnames[rn]);
    }
  else if ((x & MODE) == CCR)
    {
      outfn (stream, "ccr");
    }
  else if ((x & MODE) == EXR)
    {
      outfn (stream, "exr");
    }
  else if ((x & MODE) == MACREG)
    {
      outfn (stream, "mac%c", cst ? 'l' : 'h');
    }
  else
    /* xgettext:c-format */
    outfn (stream, _("Hmmmm 0x%x"), x);
}

d88 1
a88 1
bfd_h8_disassemble (addr, info, mach)
d91 1
a91 1
     int mach;
d94 21
a114 4
  int regno[3] = { 0, 0, 0 };
  int dispregno[3] = { 0, 0, 0 };
  int cst[3] = { 0, 0, 0 };
  int cstlen[3] = { 0, 0, 0 };
d117 1
a117 1
  char const **pregnames = mach != 0 ? lregnames : wregnames;
d119 2
a120 2
  unsigned int l;
  unsigned char data[MAX_CODE_NIBBLES];
d122 1
a122 1
  fprintf_ftype outfn = info->fprintf_func;
d137 1
a137 1
  for (l = 2; status == 0 && l < sizeof (data) / 2; l += 2)
d150 1
a150 2
	  int thisnib = data[len / 2];
	  int opnr;
d152 1
a152 3
	  thisnib = (len & 1) ? (thisnib & 0xf) : ((thisnib / 16) & 0xf);
	  opnr = ((looking_for & OP3) == OP3 ? 2
		  : (looking_for & DST) == DST ? 1 : 0);
d163 1
a163 1
		  if (!((thisnib & 0x8) != 0))
a166 1
		  thisnib &= 0x7;
d168 2
a169 1
	      else if ((int) looking_for & (int) B30)
d171 1
a171 1
		  if (!((thisnib & 0x8) == 0))
d177 1
a177 58
	      if ((int) looking_for & (int) B21)
		{
		  if (!((thisnib & 0x4) != 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B21);
		  thisnib &= 0xb;
		}
	      else if ((int) looking_for & (int) B20)
		{
		  if (!((thisnib & 0x4) == 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B20);
		}
	      if ((int) looking_for & (int) B11)
		{
		  if (!((thisnib & 0x2) != 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B11);
		  thisnib &= 0xd;
		}
	      else if ((int) looking_for & (int) B10)
		{
		  if (!((thisnib & 0x2) == 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B10);
		}

	      if ((int) looking_for & (int) B01)
		{
		  if (!((thisnib & 0x1) != 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B01);
		  thisnib &= 0xe;
		}
	      else if ((int) looking_for & (int) B00)
		{
		  if (!((thisnib & 0x1) == 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B00);
		}

	      if (looking_for & IGNORE)
		{
		  /* Hitachi has declared that IGNORE must be zero.  */
		  if (thisnib != 0)
		    goto fail;
		}
	      else if ((looking_for & MODE) == DATA)
		{
		  ;			/* Skip embedded data.  */
		}
	      else if ((looking_for & MODE) == DBIT)
d185 1
a185 54
		  cst[opnr] = (thisnib & 0x8) ? 2 : 1;
		}
	      else if ((looking_for & MODE) == DISP  ||
		       (looking_for & MODE) == ABS   ||
		       (looking_for & MODE) == PCREL ||
		       (looking_for & MODE) == INDEXB ||
		       (looking_for & MODE) == INDEXW ||
		       (looking_for & MODE) == INDEXL)
		{
		  extract_immediate (stream, looking_for, thisnib, 
				     data + len / 2, cst + opnr, 
				     cstlen + opnr, q);
		  /* Even address == bra, odd == bra/s.  */
		  if (q->how == O (O_BRAS, SB))
		    cst[opnr] -= 1;
		}
	      else if ((looking_for & MODE) == REG     ||
		       (looking_for & MODE) == LOWREG  ||
		       (looking_for & MODE) == IND     ||
		       (looking_for & MODE) == PREINC  ||
		       (looking_for & MODE) == POSTINC ||
		       (looking_for & MODE) == PREDEC  ||
		       (looking_for & MODE) == POSTDEC)
		{
		  regno[opnr] = thisnib;
		}
	      else if (looking_for & CTRL)	/* Control Register */
		{
		  thisnib &= 7;
		  if (((looking_for & MODE) == CCR  && (thisnib != C_CCR))  ||
		      ((looking_for & MODE) == EXR  && (thisnib != C_EXR))  ||
		      ((looking_for & MODE) == MACH && (thisnib != C_MACH)) ||
		      ((looking_for & MODE) == MACL && (thisnib != C_MACL)) ||
		      ((looking_for & MODE) == VBR  && (thisnib != C_VBR))  ||
		      ((looking_for & MODE) == SBR  && (thisnib != C_SBR)))
		    goto fail;
		  if (((looking_for & MODE) == CCR_EXR && 
		       (thisnib != C_CCR && thisnib != C_EXR)) ||
		      ((looking_for & MODE) == VBR_SBR && 
		       (thisnib != C_VBR && thisnib != C_SBR)) ||
		      ((looking_for & MODE) == MACREG && 
		       (thisnib != C_MACH && thisnib != C_MACL)))
		    goto fail;
		  if (((looking_for & MODE) == CC_EX_VB_SB && 
		       (thisnib != C_CCR && thisnib != C_EXR &&
			thisnib != C_VBR && thisnib != C_SBR)))
		    goto fail;

		  regno[opnr] = thisnib;
		}
	      else if ((looking_for & SIZE) == L_5)
		{
		  cst[opnr] = data[len / 2] & 31;
		  cstlen[opnr] = 5;
d187 1
a187 1
	      else if ((looking_for & SIZE) == L_4)
d189 4
a192 2
		  cst[opnr] = thisnib;
		  cstlen[opnr] = 4;
d194 1
a194 2
	      else if ((looking_for & SIZE) == L_16 ||
		       (looking_for & SIZE) == L_16U)
d196 2
a197 2
		  cst[opnr] = (data[len / 2]) * 256 + data[(len + 2) / 2];
		  cstlen[opnr] = 16;
d199 1
a199 1
	      else if ((looking_for & MODE) == MEMIND)
d201 1
a201 1
		  cst[opnr] = data[1];
d203 1
a203 1
	      else if ((looking_for & MODE) == VECIND)
d205 1
a205 1
		  cst[opnr] = data[1] & 0x7f;
d207 1
a207 1
	      else if ((looking_for & SIZE) == L_32)
d209 1
a209 1
		  int i = len / 2;
d211 4
a214 4
		  cst[opnr] = ((data[i] << 24) 
			       | (data[i + 1] << 16) 
			       | (data[i + 2] << 8)
			       | (data[i + 3]));
d216 1
a216 1
		  cstlen[opnr] = 32;
d218 1
a218 1
	      else if ((looking_for & SIZE) == L_24)
d220 1
a220 1
		  int i = len / 2;
d222 2
a223 3
		  cst[opnr] = 
		    (data[i] << 16) | (data[i + 1] << 8) | (data[i + 2]);
		  cstlen[opnr] = 24;
d231 1
a231 1
		  dispregno[opnr] = thisnib & 7;
d233 1
a233 1
	      else if ((looking_for & MODE) == KBIT)
d238 1
a238 1
		      cst[opnr] = 4;
d241 1
a241 1
		      cst[opnr] = 2;
d244 1
a244 1
		      cst[opnr] = 1;
d250 1
a250 1
	      else if ((looking_for & SIZE) == L_8)
d252 2
a253 2
		  cstlen[opnr] = 8;
		  cst[opnr] = data[len / 2];
d255 1
a255 2
	      else if ((looking_for & SIZE) == L_3 ||
		       (looking_for & SIZE) == L_3NZ)
d257 1
a257 3
		  cst[opnr] = thisnib & 0x7;
		  if (cst[opnr] == 0 && (looking_for & SIZE) == L_3NZ)
		    goto fail;
d259 1
a259 1
	      else if ((looking_for & SIZE) == L_2)
d261 2
a262 2
		  cstlen[opnr] = 2;
		  cst[opnr] = thisnib & 0x3;
d264 1
a264 1
	      else if ((looking_for & MODE) == MACREG)
d266 1
a266 1
		  cst[opnr] = (thisnib == 3);
d268 1
a268 1
	      else if (looking_for == (op_type) E)
d273 1
a273 1
		    outfn (stream, "%02x ", data[i]);
d276 1
a276 1
		    outfn (stream, "   ");
d278 1
a278 1
		  outfn (stream, "%s\t", q->name);
d285 2
a286 2
		      count = (data[1] / 16) & 0x3;
		      high = regno[1];
d288 1
a288 1
		      outfn (stream, "@@sp+,er%d-er%d", high - count, high);
d296 2
a297 2
		      count = (data[1] / 16) & 0x3;
		      low = regno[0];
d299 1
a299 13
		      outfn (stream, "er%d-er%d,@@-sp", low, low + count);
		      return qi->length;
		    }
		  if (strcmp (q->name, "rte/l") == 0
		      || strcmp (q->name, "rts/l") == 0)
		    {
		      if (regno[0] == 0)
			outfn (stream, "er%d", regno[1]);
		      else
			{
			  outfn (stream, "er%d-er%d", regno[1] - regno[0],
				 regno[1]);
			}
a301 3
		  if (strncmp (q->name, "mova", 4) == 0)
		    {
		      op_type *args = q->args.nib;
a302 22
		      if (args[1] == (op_type) E)
			{
			  /* Short form.  */
			  print_one_arg (info, addr, args[0], cst[0], 
					 cstlen[0], dispregno[0], regno[0], 
					 pregnames, qi->length);
			  outfn (stream, ",er%d", dispregno[0]);
			}
		      else
			{
			  outfn (stream, "@@(0x%x:%d,", cst[0], cstlen[0]);
			  print_one_arg (info, addr, args[1], cst[1], 
					 cstlen[1], dispregno[1], regno[1], 
					 pregnames, qi->length);
			  outfn (stream, ".%c),",
				 (args[0] & MODE) == INDEXB ? 'b' : 'w');
			  print_one_arg (info, addr, args[2], cst[2], 
					 cstlen[2], dispregno[2], regno[2], 
					 pregnames, qi->length);
			}
		      return qi->length;
		    }
a306 1
		    int nargs;
d308 1
a308 3
		    for (nargs = 0; 
			 nargs < 3 && args[nargs] != (op_type) E; 
			 nargs++)
d310 1
a310 1
			int x = args[nargs];
d313 1
a313 1
			  outfn (stream, ",");
d315 93
a407 4
			print_one_arg (info, addr, x,
				       cst[nargs], cstlen[nargs],
				       dispregno[nargs], regno[nargs],
				       pregnames, qi->length);
d410 1
d418 1
a418 1
		outfn (stream, _("Don't understand 0x%x \n"), looking_for);
d430 1
a430 1
  outfn (stream, "%02x %02x        .word\tH'%x,H'%x",
@


