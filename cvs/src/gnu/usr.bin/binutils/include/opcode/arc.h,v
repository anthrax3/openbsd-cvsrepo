head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.4
	OPENBSD_6_1:1.1.1.4.0.52
	OPENBSD_6_1_BASE:1.1.1.4
	OPENBSD_6_0:1.1.1.4.0.48
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.44
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.46
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.38
	OPENBSD_5_7_BASE:1.1.1.4
	OPENBSD_5_6:1.1.1.4.0.42
	OPENBSD_5_6_BASE:1.1.1.4
	OPENBSD_5_5:1.1.1.4.0.40
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.36
	OPENBSD_5_4_BASE:1.1.1.4
	OPENBSD_5_3:1.1.1.4.0.34
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.32
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.30
	OPENBSD_5_0:1.1.1.4.0.28
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.26
	OPENBSD_4_9_BASE:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.24
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.20
	OPENBSD_4_7_BASE:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.22
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.18
	OPENBSD_4_5_BASE:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.16
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.14
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.12
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.10
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.8
	OPENBSD_4_0_BASE:1.1.1.4
	OPENBSD_3_9:1.1.1.4.0.6
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.4
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.2
	OPENBSD_3_7_BASE:1.1.1.4
	BINUTILS_2_15:1.1.1.4
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	BINUTILS-2_14:1.1.1.3
	OPENBSD_3_5:1.1.1.2.0.8
	OPENBSD_3_5_BASE:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.6
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.4
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.2
	OPENBSD_3_2_BASE:1.1.1.2
	binutils-2_11_2:1.1.1.2
	OPENBSD_3_1:1.1.1.1.0.8
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.6
	OPENBSD_3_0_BASE:1.1.1.1
	BINUTILS-2_10_1:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.4
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.2
	OPENBSD_2_8_BASE:1.1.1.1
	BINUTILS-2_10:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2000.09.12.14.47.44;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.09.12.14.47.44;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.05.13.13.53.54;	author fgsch;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.05.17.20.42.38;	author drahn;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.11.02.20.23.04;	author miod;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* Opcode table for the ARC.
   Copyright 1994, 1995, 1997 Free Software Foundation, Inc.
   Contributed by Doug Evans (dje@@cygnus.com).

This file is part of GAS, the GNU Assembler, GDB, the GNU debugger, and
the GNU Binutils.

GAS/GDB is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GAS/GDB is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GAS or GDB; see the file COPYING.	If not, write to
the Free Software Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */

/* List of the various cpu types.
   The tables currently use bit masks to say whether the instruction or
   whatever is supported by a particular cpu.  This lets us have one entry
   apply to several cpus.

   This duplicates bfd_mach_arc_xxx.  For now I wish to isolate this from bfd
   and bfd from this.  Also note that these numbers are bit values as we want
   to allow for things available on more than one ARC (but not necessarily all
   ARCs).  */

/* The `base' cpu must be 0 (table entries are omitted for the base cpu).
   The cpu type is treated independently of endianness.
   The complete `mach' number includes endianness.
   These values are internal to opcodes/bfd/binutils/gas.  */
#define ARC_MACH_BASE 0
#define ARC_MACH_UNUSED1 1
#define ARC_MACH_UNUSED2 2
#define ARC_MACH_UNUSED4 4
/* Additional cpu values can be inserted here and ARC_MACH_BIG moved down.  */
#define ARC_MACH_BIG 8

/* Mask of number of bits necessary to record cpu type.  */
#define ARC_MACH_CPU_MASK 7
/* Mask of number of bits necessary to record cpu type + endianness.  */
#define ARC_MACH_MASK 15

/* Type to denote an ARC instruction (at least a 32 bit unsigned int).  */
typedef unsigned int arc_insn;

struct arc_opcode {
  char *syntax;			/* syntax of insn */
  unsigned long mask, value;	/* recognize insn if (op&mask)==value */
  int flags;			/* various flag bits */

/* Values for `flags'.  */

/* Return CPU number, given flag bits.  */
#define ARC_OPCODE_CPU(bits) ((bits) & ARC_MACH_CPU_MASK)
/* Return MACH number, given flag bits.  */
#define ARC_OPCODE_MACH(bits) ((bits) & ARC_MACH_MASK)
/* First opcode flag bit available after machine mask.  */
#define ARC_OPCODE_FLAG_START ((ARC_MACH_MASK + 1) << 0)
/* This insn is a conditional branch.  */
#define ARC_OPCODE_COND_BRANCH (ARC_OPCODE_FLAG_START)

  /* These values are used to optimize assembly and disassembly.  Each insn is
     on a list of related insns (same first letter for assembly, same insn code
     for disassembly).  */
  struct arc_opcode *next_asm;	/* Next instruction to try during assembly.  */
  struct arc_opcode *next_dis;	/* Next instruction to try during disassembly.  */

  /* Macros to create the hash values for the lists.  */
#define ARC_HASH_OPCODE(string) \
  ((string)[0] >= 'a' && (string)[0] <= 'z' ? (string)[0] - 'a' : 26)
#define ARC_HASH_ICODE(insn) \
  ((unsigned int) (insn) >> 27)

  /* Macros to access `next_asm', `next_dis' so users needn't care about the
     underlying mechanism.  */
#define ARC_OPCODE_NEXT_ASM(op) ((op)->next_asm)
#define ARC_OPCODE_NEXT_DIS(op) ((op)->next_dis)
};

struct arc_operand_value {
  char *name;			/* eg: "eq" */
  short value;			/* eg: 1 */
  unsigned char type;		/* index into `arc_operands' */
  unsigned char flags;		/* various flag bits */

/* Values for `flags'.  */

/* Return CPU number, given flag bits.  */
#define ARC_OPVAL_CPU(bits) ((bits) & ARC_MACH_CPU_MASK)
/* Return MACH number, given flag bits.  */
#define ARC_OPVAL_MACH(bits) ((bits) & ARC_MACH_MASK)
};

struct arc_operand {
  /* One of the insn format chars.  */
  unsigned char fmt;

  /* The number of bits in the operand (may be unused for a modifier).  */
  unsigned char bits;

  /* How far the operand is left shifted in the instruction, or
     the modifier's flag bit (may be unused for a modifier.  */
  unsigned char shift;

  /* Various flag bits.  */
  int flags;

/* Values for `flags'.  */

/* This operand is a suffix to the opcode.  */
#define ARC_OPERAND_SUFFIX 1

/* This operand is a relative branch displacement.  The disassembler
   prints these symbolically if possible.  */
#define ARC_OPERAND_RELATIVE_BRANCH 2

/* This operand is an absolute branch address.  The disassembler
   prints these symbolically if possible.  */
#define ARC_OPERAND_ABSOLUTE_BRANCH 4

/* This operand is an address.  The disassembler
   prints these symbolically if possible.  */
#define ARC_OPERAND_ADDRESS 8

/* This operand is a long immediate value.  */
#define ARC_OPERAND_LIMM 0x10

/* This operand takes signed values.  */
#define ARC_OPERAND_SIGNED 0x20

/* This operand takes signed values, but also accepts a full positive
   range of values.  That is, if bits is 16, it takes any value from
   -0x8000 to 0xffff.  */
#define ARC_OPERAND_SIGNOPT 0x40

/* This operand should be regarded as a negative number for the
   purposes of overflow checking (i.e., the normal most negative
   number is disallowed and one more than the normal most positive
   number is allowed).  This flag will only be set for a signed
   operand.  */
#define ARC_OPERAND_NEGATIVE 0x80

/* This operand doesn't really exist.  The program uses these operands
   in special ways.  */
#define ARC_OPERAND_FAKE 0x100

/* Modifier values.  */
/* A dot is required before a suffix.  Eg: .le  */
#define ARC_MOD_DOT 0x1000

/* A normal register is allowed (not used, but here for completeness).  */
#define ARC_MOD_REG 0x2000

/* An auxiliary register name is expected.  */
#define ARC_MOD_AUXREG 0x4000

/* Sum of all ARC_MOD_XXX bits.  */
#define ARC_MOD_BITS 0x7000

/* Non-zero if the operand type is really a modifier.  */
#define ARC_MOD_P(X) ((X) & ARC_MOD_BITS)

  /* Insertion function.  This is used by the assembler.  To insert an
     operand value into an instruction, check this field.

     If it is NULL, execute
         i |= (p & ((1 << o->bits) - 1)) << o->shift;
     (I is the instruction which we are filling in, O is a pointer to
     this structure, and OP is the opcode value; this assumes twos
     complement arithmetic).

     If this field is not NULL, then simply call it with the
     instruction and the operand value.  It will return the new value
     of the instruction.  If the ERRMSG argument is not NULL, then if
     the operand value is illegal, *ERRMSG will be set to a warning
     string (the operand will be inserted in any case).  If the
     operand value is legal, *ERRMSG will be unchanged.

     REG is non-NULL when inserting a register value.  */

  arc_insn (*insert) PARAMS ((arc_insn insn,
			      const struct arc_operand *operand, int mods,
			      const struct arc_operand_value *reg, long value,
			      const char **errmsg));

  /* Extraction function.  This is used by the disassembler.  To
     extract this operand type from an instruction, check this field.

     If it is NULL, compute
         op = ((i) >> o->shift) & ((1 << o->bits) - 1);
	 if ((o->flags & ARC_OPERAND_SIGNED) != 0
	     && (op & (1 << (o->bits - 1))) != 0)
	   op -= 1 << o->bits;
     (I is the instruction, O is a pointer to this structure, and OP
     is the result; this assumes twos complement arithmetic).

     If this field is not NULL, then simply call it with the
     instruction value.  It will return the value of the operand.  If
     the INVALID argument is not NULL, *INVALID will be set to
     non-zero if this operand type can not actually be extracted from
     this operand (i.e., the instruction does not match).  If the
     operand is valid, *INVALID will not be changed.

     INSN is a pointer to an array of two `arc_insn's.  The first element is
     the insn, the second is the limm if present.

     Operands that have a printable form like registers and suffixes have
     their struct arc_operand_value pointer stored in OPVAL.  */

  long (*extract) PARAMS ((arc_insn *insn,
			   const struct arc_operand *operand,
			   int mods, const struct arc_operand_value **opval,
			   int *invalid));
};

/* Bits that say what version of cpu we have.
   These should be passed to arc_init_opcode_tables.
   At present, all there is is the cpu type.  */

/* CPU number, given value passed to `arc_init_opcode_tables'.  */
#define ARC_HAVE_CPU(bits) ((bits) & ARC_MACH_CPU_MASK)
/* MACH number, given value passed to `arc_init_opcode_tables'.  */
#define ARC_HAVE_MACH(bits) ((bits) & ARC_MACH_MASK)

/* Special register values:  */
#define ARC_REG_SHIMM_UPDATE 61
#define ARC_REG_SHIMM 63
#define ARC_REG_LIMM 62

/* Non-zero if REG is a constant marker.  */
#define ARC_REG_CONSTANT_P(REG) ((REG) >= 61)

/* Positions and masks of various fields:  */
#define ARC_SHIFT_REGA 21
#define ARC_SHIFT_REGB 15
#define ARC_SHIFT_REGC 9
#define ARC_MASK_REG 63

/* Delay slot types.  */
#define ARC_DELAY_NONE 0	/* no delay slot */
#define ARC_DELAY_NORMAL 1	/* delay slot in both cases */
#define ARC_DELAY_JUMP 2	/* delay slot only if branch taken */

/* Non-zero if X will fit in a signed 9 bit field.  */
#define ARC_SHIMM_CONST_P(x) ((long) (x) >= -256 && (long) (x) <= 255)

extern const struct arc_operand arc_operands[];
extern const int arc_operand_count;
extern /*const*/ struct arc_opcode arc_opcodes[];
extern const int arc_opcodes_count;
extern const struct arc_operand_value arc_suffixes[];
extern const int arc_suffixes_count;
extern const struct arc_operand_value arc_reg_names[];
extern const int arc_reg_names_count;
extern unsigned char arc_operand_map[];

/* Utility fns in arc-opc.c.  */
int arc_get_opcode_mach PARAMS ((int, int));
/* `arc_opcode_init_tables' must be called before `arc_xxx_supported'.  */
void arc_opcode_init_tables PARAMS ((int));
void arc_opcode_init_insert PARAMS ((void));
void arc_opcode_init_extract PARAMS ((void));
const struct arc_opcode *arc_opcode_lookup_asm PARAMS ((const char *));
const struct arc_opcode *arc_opcode_lookup_dis PARAMS ((unsigned int));
int arc_opcode_limm_p PARAMS ((long *));
const struct arc_operand_value *arc_opcode_lookup_suffix PARAMS ((const struct arc_operand *type, int value));
int arc_opcode_supported PARAMS ((const struct arc_opcode *));
int arc_opval_supported PARAMS ((const struct arc_operand_value *));
@


1.1.1.1
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@@


1.1.1.2
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 2001 Free Software Foundation, Inc.
d5 2
a6 16
   This file is part of GAS, the GNU Assembler, GDB, the GNU debugger, and
   the GNU Binutils.

   GAS/GDB is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS/GDB is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS or GDB; see the file COPYING.	If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d8 14
d28 8
a35 2
   The `base' cpu must be 0. The cpu type is treated independently of
   endianness. The complete `mach' number includes endianness.
d37 4
a40 5
#define ARC_MACH_5 0
#define ARC_MACH_6 1
#define ARC_MACH_7 2
#define ARC_MACH_8 4

d42 1
a42 1
#define ARC_MACH_BIG 16
d45 1
a45 2
#define ARC_MACH_CPU_MASK (ARC_MACH_BIG - 1)

d47 1
a47 1
#define ARC_MACH_MASK ((ARC_MACH_BIG << 1) - 1)
a49 1

d53 3
a55 3
  char *syntax;              /* syntax of insn  */
  unsigned long mask, value; /* recognize insn if (op&mask) == value  */
  int flags;                 /* various flag bits  */
a60 1

a62 1

d64 1
a64 2
#define ARC_OPCODE_FLAG_START (ARC_MACH_MASK + 1)

a66 16
#define SYNTAX_3OP             (ARC_OPCODE_COND_BRANCH << 1)
#define SYNTAX_LENGTH          (SYNTAX_3OP                 )
#define SYNTAX_2OP             (SYNTAX_3OP             << 1)
#define OP1_MUST_BE_IMM        (SYNTAX_2OP             << 1)
#define OP1_IMM_IMPLIED        (OP1_MUST_BE_IMM        << 1)
#define SYNTAX_VALID           (OP1_IMM_IMPLIED        << 1)

#define I(x) (((x) & 31) << 27)
#define A(x) (((x) & ARC_MASK_REG) << ARC_SHIFT_REGA)
#define B(x) (((x) & ARC_MASK_REG) << ARC_SHIFT_REGB)
#define C(x) (((x) & ARC_MASK_REG) << ARC_SHIFT_REGC)
#define R(x,b,m) (((x) & (m)) << (b)) /* value X, mask M, at bit B */

/* These values are used to optimize assembly and disassembly.  Each insn
   is on a list of related insns (same first letter for assembly, same
   insn code for disassembly).  */
d68 5
a72 2
  struct arc_opcode *next_asm;	/* Next instr to try during assembly.  */
  struct arc_opcode *next_dis;	/* Next instr to try during disassembly.  */
d74 1
a74 1
/* Macros to create the hash values for the lists.  */
d80 2
a81 2
 /* Macros to access `next_asm', `next_dis' so users needn't care about the
    underlying mechanism.  */
a85 4
/* this is an "insert at front" linked list per Metaware spec
   that new definitions override older ones.  */
struct arc_opcode *arc_ext_opcodes;

d87 4
a90 4
  char *name;          /* eg: "eq"  */
  short value;         /* eg: 1  */
  unsigned char type;  /* index into `arc_operands'  */
  unsigned char flags; /* various flag bits  */
a99 5
struct arc_ext_operand_value {
  struct arc_ext_operand_value *next;
  struct arc_operand_value operand;
} *arc_ext_operands;

d101 1
a101 1
/* One of the insn format chars.  */
d104 1
a104 1
/* The number of bits in the operand (may be unused for a modifier).  */
d107 2
a108 2
/* How far the operand is left shifted in the instruction, or
   the modifier's flag bit (may be unused for a modifier.  */
d111 1
a111 1
/* Various flag bits.  */
a152 13
/* separate flags operand for j and jl instructions  */
#define ARC_OPERAND_JUMPFLAGS 0x200

/* allow warnings and errors to be issued after call to insert_xxxxxx  */
#define ARC_OPERAND_WARN  0x400
#define ARC_OPERAND_ERROR 0x800

/* this is a load operand */
#define ARC_OPERAND_LOAD  0x8000

/* this is a store operand */
#define ARC_OPERAND_STORE 0x10000

d169 15
a183 20
/* enforce read/write only register restrictions  */
#define ARC_REGISTER_READONLY    0x01
#define ARC_REGISTER_WRITEONLY   0x02
#define ARC_REGISTER_NOSHORT_CUT 0x04

/* Insertion function.  This is used by the assembler.  To insert an
   operand value into an instruction, check this field.

   If it is NULL, execute
   i |= (p & ((1 << o->bits) - 1)) << o->shift;
   (I is the instruction which we are filling in, O is a pointer to
   this structure, and OP is the opcode value; this assumes twos
   complement arithmetic).
   
   If this field is not NULL, then simply call it with the
   instruction and the operand value.  It will return the new value
   of the instruction.  If the ERRMSG argument is not NULL, then if
   the operand value is illegal, *ERRMSG will be set to a warning
   string (the operand will be inserted in any case).  If the
   operand value is legal, *ERRMSG will be unchanged.
d185 1
a185 1
   REG is non-NULL when inserting a register value.  */
d192 2
a193 17
/* Extraction function.  This is used by the disassembler.  To
   extract this operand type from an instruction, check this field.
   
   If it is NULL, compute
     op = ((i) >> o->shift) & ((1 << o->bits) - 1);
     if ((o->flags & ARC_OPERAND_SIGNED) != 0
          && (op & (1 << (o->bits - 1))) != 0)
       op -= 1 << o->bits;
   (I is the instruction, O is a pointer to this structure, and OP
   is the result; this assumes twos complement arithmetic).
   
   If this field is not NULL, then simply call it with the
   instruction value.  It will return the value of the operand.  If
   the INVALID argument is not NULL, *INVALID will be set to
   non-zero if this operand type can not actually be extracted from
   this operand (i.e., the instruction does not match).  If the
   operand is valid, *INVALID will not be changed.
d195 14
a208 2
   INSN is a pointer to an array of two `arc_insn's.  The first element is
   the insn, the second is the limm if present.
d210 5
a214 2
   Operands that have a printable form like registers and suffixes have
   their struct arc_operand_value pointer stored in OPVAL.  */
d222 3
a224 2
/* Bits that say what version of cpu we have. These should be passed to
   arc_init_opcode_tables. At present, all there is is the cpu type.  */
d246 3
a248 3
#define ARC_DELAY_NONE 0   /* no delay slot */
#define ARC_DELAY_NORMAL 1 /* delay slot in both cases */
#define ARC_DELAY_JUMP 2   /* delay slot only if branch taken */
d255 1
a255 1
extern struct arc_opcode arc_opcodes[];
a264 1

d272 1
a272 2
const struct arc_operand_value *arc_opcode_lookup_suffix
  PARAMS ((const struct arc_operand *type, int value));
@


1.1.1.3
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d101 1
a101 1
extern struct arc_opcode *arc_ext_opcodes;
d120 1
a120 3
};

extern struct arc_ext_operand_value *arc_ext_operands;
a315 6
int arc_limm_fixup_adjust PARAMS ((arc_insn));
int arc_insn_is_j PARAMS ((arc_insn));
int arc_insn_not_jl PARAMS ((arc_insn));
int arc_operand_type PARAMS ((int));
struct arc_operand_value *get_ext_suffix PARAMS ((char *));
int arc_get_noshortcut_flag PARAMS ((void));
@


1.1.1.4
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1997, 2001, 2002, 2003
   Free Software Foundation, Inc.
d20 1
a20 2
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,
   MA 02111-1307, USA.  */
d229 4
a232 3
  arc_insn (*insert)
    (arc_insn insn, const struct arc_operand *operand, int mods,
     const struct arc_operand_value *reg, long value, const char **errmsg);
d258 4
a261 3
  long (*extract)
    (arc_insn *insn, const struct arc_operand *operand, int mods,
     const struct arc_operand_value **opval, int *invalid);
d305 1
a305 1
int arc_get_opcode_mach (int, int);
d308 6
a313 6
void arc_opcode_init_tables (int);
void arc_opcode_init_insert (void);
void arc_opcode_init_extract (void);
const struct arc_opcode *arc_opcode_lookup_asm (const char *);
const struct arc_opcode *arc_opcode_lookup_dis (unsigned int);
int arc_opcode_limm_p (long *);
d315 9
a323 9
  (const struct arc_operand *type, int value);
int arc_opcode_supported (const struct arc_opcode *);
int arc_opval_supported (const struct arc_operand_value *);
int arc_limm_fixup_adjust (arc_insn);
int arc_insn_is_j (arc_insn);
int arc_insn_not_jl (arc_insn);
int arc_operand_type (int);
struct arc_operand_value *get_ext_suffix (char *);
int arc_get_noshortcut_flag (void);
@


