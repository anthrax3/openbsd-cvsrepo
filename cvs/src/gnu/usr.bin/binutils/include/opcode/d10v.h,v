head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.5.0.54
	OPENBSD_6_2_BASE:1.1.1.5
	OPENBSD_6_1:1.1.1.5.0.52
	OPENBSD_6_1_BASE:1.1.1.5
	OPENBSD_6_0:1.1.1.5.0.48
	OPENBSD_6_0_BASE:1.1.1.5
	OPENBSD_5_9:1.1.1.5.0.44
	OPENBSD_5_9_BASE:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.46
	OPENBSD_5_8_BASE:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.38
	OPENBSD_5_7_BASE:1.1.1.5
	OPENBSD_5_6:1.1.1.5.0.42
	OPENBSD_5_6_BASE:1.1.1.5
	OPENBSD_5_5:1.1.1.5.0.40
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.36
	OPENBSD_5_4_BASE:1.1.1.5
	OPENBSD_5_3:1.1.1.5.0.34
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.32
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.30
	OPENBSD_5_0:1.1.1.5.0.28
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.26
	OPENBSD_4_9_BASE:1.1.1.5
	OPENBSD_4_8:1.1.1.5.0.24
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.20
	OPENBSD_4_7_BASE:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.22
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.18
	OPENBSD_4_5_BASE:1.1.1.5
	OPENBSD_4_4:1.1.1.5.0.16
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.14
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.12
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.10
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.8
	OPENBSD_4_0_BASE:1.1.1.5
	OPENBSD_3_9:1.1.1.5.0.6
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.4
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.2
	OPENBSD_3_7_BASE:1.1.1.5
	BINUTILS_2_15:1.1.1.5
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.1.1.3.0.8
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.6
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.4
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.2
	OPENBSD_3_2_BASE:1.1.1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.1.1.2.0.8
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.6
	OPENBSD_3_0_BASE:1.1.1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.1.1.2.0.4
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.2
	OPENBSD_2_8_BASE:1.1.1.2
	BINUTILS-2_10:1.1.1.2
	FSF:1.1.1
	OPENBSD_2_7:1.1.1.1.0.14
	OPENBSD_2_7_BASE:1.1.1.1
	new-binutils:1.1.1.1.0.12
	OPENBSD_2_6:1.1.1.1.0.10
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.8
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.6
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.4
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.2
	OPENBSD_2_2_BASE:1.1.1.1
	BINUTILS-2_8_1:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	97.05.29.09.27.01;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.29.09.27.01;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.47.45;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.54.04;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.39;	author drahn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.11.02.20.23.04;	author miod;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* d10v.h -- Header file for D10V opcode table
   Copyright 1996 Free Software Foundation, Inc.
   Written by Martin Hunt (hunt@@cygnus.com), Cygnus Support

This file is part of GDB, GAS, and the GNU binutils.

GDB, GAS, and the GNU binutils are free software; you can redistribute
them and/or modify them under the terms of the GNU General Public
License as published by the Free Software Foundation; either version
1, or (at your option) any later version.

GDB, GAS, and the GNU binutils are distributed in the hope that they
will be useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this file; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifndef D10V_H
#define D10V_H

/* Format Specifier */
#define FM00	0
#define FM01	0x40000000
#define FM10	0x80000000
#define FM11	0xC0000000

#define NOP 0x5e00
#define OPCODE_DIVS	0x14002800

/* The opcode table is an array of struct d10v_opcode.  */

struct d10v_opcode
{
  /* The opcode name.  */
  const char *name;

  /* the opcode format */
  int format;

  /* These numbers were picked so we can do if( i & SHORT_OPCODE) */
#define SHORT_OPCODE 1
#define LONG_OPCODE  8
#define SHORT_2	     1		/* short with 2 operands */
#define SHORT_B	     3		/* short with 8-bit branch */
#define LONG_B	     8		/* long with 16-bit branch */
#define LONG_L       10		/* long with 3 operands */
#define LONG_R       12		/* reserved */

  /* just a placeholder for variable-length instructions */
  /* for example, "bra" will be a fake for "bra.s" and bra.l" */
  /* which will immediately follow in the opcode table.  */
#define OPCODE_FAKE  32

  /* the number of cycles */
  int cycles;

  /* the execution unit(s) used */
  int unit;
#define EITHER	0
#define IU	1
#define MU	2
#define BOTH	3

  /* execution type; parallel or sequential */
  /* this field is used to decide if two instructions */
  /* can be executed in parallel */
  int exec_type;
#define PARONLY 1	/* parallel only */
#define SEQ	2	/* must be sequential */
#define PAR	4	/* may be parallel */
#define BRANCH_LINK 8	/* subroutine call.  must be aligned */
#define RMEM     16	/* reads memory */
#define WMEM     32	/* writes memory */
#define RF0      64	/* reads f0 */
#define WF0     128	/* modifies f0 */
#define WCAR    256	/* write Carry */
#define BRANCH  512	/* branch, no link */

  /* the opcode */
  long opcode;

  /* mask.  if( (i & mask) == opcode ) then match */
  long mask;

  /* An array of operand codes.  Each code is an index into the
     operand table.  They appear in the order which the operands must
     appear in assembly code, and are terminated by a zero.  */
  unsigned char operands[6];
};

/* The table itself is sorted by major opcode number, and is otherwise
   in the order in which the disassembler should consider
   instructions.  */
extern const struct d10v_opcode d10v_opcodes[];
extern const int d10v_num_opcodes;

/* The operands table is an array of struct d10v_operand.  */
struct d10v_operand
{
  /* The number of bits in the operand.  */
  int bits;

  /* How far the operand is left shifted in the instruction.  */
  int shift;

  /* One bit syntax flags.  */
  int flags;
};

/* Elements in the table are retrieved by indexing with values from
   the operands field of the d10v_opcodes table.  */

extern const struct d10v_operand d10v_operands[];

/* Values defined for the flags field of a struct d10v_operand.  */

/* the operand must be an even number */
#define OPERAND_EVEN	(1)

/* the operand must be an odd number */
#define OPERAND_ODD	(2)	

/* this is the destination register; it will be modified */
/* this is used by the optimizer */
#define OPERAND_DEST	(4)

/* number or symbol */
#define OPERAND_NUM	(8)

/* address or label */
#define OPERAND_ADDR	(0x10)

/* register */
#define OPERAND_REG	(0x20)

/* postincrement +  */
#define OPERAND_PLUS	(0x40)

/* postdecrement -  */
#define OPERAND_MINUS	(0x80)

/* @@  */
#define OPERAND_ATSIGN	(0x100)

/* @@(  */
#define OPERAND_ATPAR	(0x200)

/* accumulator */
#define OPERAND_ACC	(0x400)

/* flag register */
#define OPERAND_FLAG	(0x800)

/* control register  */
#define OPERAND_CONTROL	(0x1000)

/* predecrement mode '@@-sp'  */
#define OPERAND_ATMINUS	(0x2000)

/* signed number */
#define OPERAND_SIGNED	(0x4000)

/* special accumulator shifts need a 4-bit number */
/* 1 <= x <= 16 */
#define OPERAND_SHIFT	(0x8000)

/* Structure to hold information about predefined registers.  */
struct pd_reg
{
  char *name;		/* name to recognize */
  char *pname;		/* name to print for this register */
  int value;
};

extern const struct pd_reg d10v_predefined_registers[];
int d10v_reg_name_cnt();

/* an expressionS only has one register type, so we fake it */
/* by setting high bits to indicate type */
#define REGISTER_MASK	0xFF

#endif /* D10V_H */
@


1.1.1.1
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998 Free Software Foundation, Inc.
d151 2
a152 2
/* accumulator 0 */
#define OPERAND_ACC0	(0x400)
d154 2
a155 8
/* accumulator 1 */
#define OPERAND_ACC1	(0x800)

/* f0 / f1 flag register */
#define OPERAND_FFLAG	(0x1000)

/* c flag register */
#define OPERAND_CFLAG	(0x2000)
d158 1
a158 1
#define OPERAND_CONTROL	(0x4000)
d161 1
a161 1
#define OPERAND_ATMINUS	(0x8000)
d164 1
a164 1
#define OPERAND_SIGNED	(0x10000)
d168 1
a168 8
#define OPERAND_SHIFT	(0x20000)

/* general purpose register */
#define OPERAND_GPR	(0x40000)

/* special imm3 values with range restricted to -2 <= imm3 <= 3 */
/* needed for rac/rachi */
#define RESTRICTED_NUM3	(0x80000)
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
a80 1
#define ALONE  1024	/* short but pack with a NOP if on asm line alone */
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
a183 8
/* Pre-decrement is only supported for SP.  */
#define OPERAND_SP      (0x100000)

/* Post-decrement is not supported for SP.  Like OPERAND_EVEN, and
   unlike OPERAND_SP, this flag doesn't prevent the instruction from
   matching, it only fails validation later on.  */
#define OPERAND_NOSP    (0x200000)

d193 1
a193 1
int d10v_reg_name_cnt PARAMS ((void));
@


1.1.1.5
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2003
   Free Software Foundation, Inc.
d201 1
a201 1
int d10v_reg_name_cnt (void);
@


