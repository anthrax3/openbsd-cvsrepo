head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.64
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.62
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.58
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.54
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.56
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.48
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.52
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.50
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.46
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.44
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.42
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.40
	OPENBSD_5_0:1.3.0.38
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.36
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.34
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.30
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.32
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.28
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.26
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.24
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.22
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.20
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.18
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.16
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.14
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.12
	OPENBSD_3_7_BASE:1.3
	BINUTILS_2_15:1.1.1.3
	OPENBSD_3_6:1.3.0.10
	OPENBSD_3_6_BASE:1.3
	BINUTILS-2_14:1.1.1.3
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.2
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2002.05.13.17.07.41;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.19.12.37;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.08.23;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.08.23;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.47.41;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.53.35;	author fgsch;	state Exp;
branches;
next	;


desc
@@


1.3
log
@resolve conflicts.
@
text
@/* HPPA ELF support for BFD.
   Copyright 1993, 1994, 1995, 1998, 1999, 2000
   Free Software Foundation, Inc.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* This file holds definitions specific to the HPPA ELF ABI.  Note
   that most of this is not actually implemented by BFD.  */

#ifndef _ELF_HPPA_H
#define _ELF_HPPA_H

/* Processor specific flags for the ELF header e_flags field.  */

/* Trap null address dereferences.  */
#define EF_PARISC_TRAPNIL	0x00010000

/* .PARISC.archext section is present.  */
#define EF_PARISC_EXT		0x00020000

/* Program expects little-endian mode.  */
#define EF_PARISC_LSB		0x00040000

/* Program expects wide mode.  */
#define EF_PARISC_WIDE		0x00080000

/* Do not allow kernel-assisted branch prediction.  */
#define EF_PARISC_NO_KABP	0x00100000

/* Allow lazy swap for dynamically allocated program segments.  */
#define EF_PARISC_LAZYSWAP	0x00400000

/* Architecture version */
#define EF_PARISC_ARCH		0x0000ffff

#define EFA_PARISC_1_0			0x020b
#define EFA_PARISC_1_1			0x0210
#define EFA_PARISC_2_0			0x0214

/* Special section indices.  */
/* A symbol that has been declared as a tentative definition in an ANSI C
   compilation.  */
#define SHN_PARISC_ANSI_COMMON 	0xff00

/* A symbol that has been declared as a common block using the
   huge memory model.  */
#define SHN_PARISC_HUGE_COMMON	0xff01

/* Processor specific section types.  */

/* Section contains product specific extension bits.  */
#define SHT_PARISC_EXT		0x70000000

/* Section contains unwind table entries.  */
#define SHT_PARISC_UNWIND	0x70000001

/* Section contains debug information for optimized code.  */
#define SHT_PARISC_DOC		0x70000002

/* Section contains code annotations.  */
#define SHT_PARISC_ANNOT	0x70000003

/* These are strictly for compatibility with the older elf32-hppa
   implementation.  Hopefully we can eliminate them in the future.  */
/* Optional section holding argument location/relocation info.  */
#define SHT_PARISC_SYMEXTN    SHT_LOPROC+8

/* Option section for linker stubs.  */
#define SHT_PARISC_STUBS      SHT_LOPROC+9

/* Processor specific section flags.  */

/* Section contains code compiled for static branch prediction.  */
#define SHF_PARISC_SBP		0x80000000

/* Section should be allocated from from GP.  */
#define SHF_PARISC_HUGE		0x40000000

/* Section should go near GP.  */
#define SHF_PARISC_SHORT	0x20000000


/* Identifies the entry point of a millicode routine.  */
#define STT_PARISC_MILLI	13

/* ELF/HPPA relocation types */

/* Note: PA-ELF is defined to use only RELA relocations.  */
#include "elf/reloc-macros.h"

START_RELOC_NUMBERS (elf_hppa_reloc_type)
RELOC_NUMBER (R_PARISC_NONE,	         0) /* No reloc */

/*		Data / Inst. Format	   Relocation Expression	  */

RELOC_NUMBER (R_PARISC_DIR32,	   	 1)
/*		32-bit word            	   symbol + addend    		  */

RELOC_NUMBER (R_PARISC_DIR21L,	   	 2)
/*		long immediate (7)	   LR(symbol, addend) 		  */

RELOC_NUMBER (R_PARISC_DIR17R,	   	 3)
/*		branch external (19)	   RR(symbol, addend) 		  */

RELOC_NUMBER (R_PARISC_DIR17F,	   	 4)
/*		branch external (19)	   symbol + addend    		  */

RELOC_NUMBER (R_PARISC_DIR14R,	   	 6)
/*		load/store (1)		   RR(symbol, addend) 		  */

RELOC_NUMBER (R_PARISC_DIR14F,	   	 7)
/*		load/store (1)		   symbol, addend 		  */

/* PC-relative relocation types
   Typically used for calls.
   Note PCREL17C and PCREL17F differ only in overflow handling.
   PCREL17C never reports a relocation error.

   When supporting argument relocations, function calls must be
   accompanied by parameter relocation information.  This information is
   carried in the ten high-order bits of the addend field.  The remaining
   22 bits of of the addend field are sign-extended to form the Addend.

   Note the code to build argument relocations depends on the
   addend being zero.  A consequence of this limitation is GAS
   can not perform relocation reductions for function symbols.  */

RELOC_NUMBER (R_PARISC_PCREL12F,  	 8)
/*		op & branch (17)	   symbol - PC - 8 + addend    	  */

RELOC_NUMBER (R_PARISC_PCREL32,   	 9)
/*		32-bit word		   symbol - PC - 8 + addend    	  */

RELOC_NUMBER (R_PARISC_PCREL21L,  	10)
/*		long immediate (7)	   L(symbol - PC - 8 + addend) 	  */

RELOC_NUMBER (R_PARISC_PCREL17R,  	11)
/*		branch external (19)	   R(symbol - PC - 8 + addend) 	  */

RELOC_NUMBER (R_PARISC_PCREL17F,  	12)
/*		branch (20)		   symbol - PC - 8 + addend    	  */

RELOC_NUMBER (R_PARISC_PCREL17C,  	13)
/*		branch (20)		   symbol - PC - 8 + addend    	  */

RELOC_NUMBER (R_PARISC_PCREL14R,  	14)
/*		load/store (1)		   R(symbol - PC - 8 + addend) 	  */

RELOC_NUMBER (R_PARISC_PCREL14F,  	15)
/*		load/store (1)             symbol - PC - 8 + addend    	  */


/* DP-relative relocation types.  */
RELOC_NUMBER (R_PARISC_DPREL21L,  	18)
/*		long immediate (7)         LR(symbol - GP, addend)  	  */

RELOC_NUMBER (R_PARISC_DPREL14WR, 	19)
/*		load/store mod. comp. (2)  RR(symbol - GP, addend)  	  */

RELOC_NUMBER (R_PARISC_DPREL14DR, 	20)
/*		load/store doubleword (3)  RR(symbol - GP, addend)  	  */

RELOC_NUMBER (R_PARISC_DPREL14R,  	22)
/*		load/store (1)             RR(symbol - GP, addend)  	  */

RELOC_NUMBER (R_PARISC_DPREL14F,  	23)
/*		load/store (1)             symbol - GP + addend     	  */


/* Data linkage table (DLT) relocation types

   SOM DLT_REL fixup requests are used to for static data references
   from position-independent code within shared libraries.  They are
   similar to the GOT relocation types in some SVR4 implementations.  */

RELOC_NUMBER (R_PARISC_DLTREL21L,     	26)
/*		long immediate (7)         LR(symbol - GP, addend) 	  */

RELOC_NUMBER (R_PARISC_DLTREL14R,     	30)
/*		load/store (1)             RR(symbol - GP, addend) 	  */

RELOC_NUMBER (R_PARISC_DLTREL14F,     	31)
/*		load/store (1)             symbol - GP + addend    	  */


/* DLT indirect relocation types  */
RELOC_NUMBER (R_PARISC_DLTIND21L,     	34)
/*		long immediate (7)         L(ltoff(symbol + addend)) 	  */

RELOC_NUMBER (R_PARISC_DLTIND14R,     	38)
/*		load/store (1)             R(ltoff(symbol + addend)) 	  */

RELOC_NUMBER (R_PARISC_DLTIND14F,     	39)
/*		load/store (1)             ltoff(symbol + addend)    	  */


/* Base relative relocation types.  Ugh.  These imply lots of state */
RELOC_NUMBER (R_PARISC_SETBASE,       	40)
/*		none                       no reloc; base := sym     	  */

RELOC_NUMBER (R_PARISC_SECREL32,      	41)
/*		32-bit word                symbol - SECT + addend    	  */

RELOC_NUMBER (R_PARISC_BASEREL21L,    	42)
/*		long immediate (7)         LR(symbol - base, addend) 	  */

RELOC_NUMBER (R_PARISC_BASEREL17R,    	43)
/*		branch external (19)       RR(symbol - base, addend) 	  */

RELOC_NUMBER (R_PARISC_BASEREL17F,    	44)
/*		branch external (19)       symbol - base + addend    	  */

RELOC_NUMBER (R_PARISC_BASEREL14R,    	46)
/*		load/store (1)             RR(symbol - base, addend) 	  */

RELOC_NUMBER (R_PARISC_BASEREL14F,    	47)
/*		load/store (1)             symbol - base, addend     	  */


/* Segment relative relocation types.  */
RELOC_NUMBER (R_PARISC_SEGBASE,       	48)
/*		none                       no relocation; SB := sym  	  */

RELOC_NUMBER (R_PARISC_SEGREL32,      	49)
/*		32-bit word                symbol - SB + addend 	  */
  

/* Offsets from the PLT.  */  
RELOC_NUMBER (R_PARISC_PLTOFF21L,     	50)
/*		long immediate (7)         LR(pltoff(symbol), addend) 	  */

RELOC_NUMBER (R_PARISC_PLTOFF14R,     	54)
/*		load/store (1)             RR(pltoff(symbol), addend) 	  */

RELOC_NUMBER (R_PARISC_PLTOFF14F,     	55)
/*		load/store (1)             pltoff(symbol) + addend    	  */


RELOC_NUMBER (R_PARISC_LTOFF_FPTR32,  	57)
/*		32-bit word                ltoff(fptr(symbol+addend))     */

RELOC_NUMBER (R_PARISC_LTOFF_FPTR21L, 	58)
/*		long immediate (7)         L(ltoff(fptr(symbol+addend)))  */

RELOC_NUMBER (R_PARISC_LTOFF_FPTR14R, 	62)
/*		load/store (1)             R(ltoff(fptr(symbol+addend)))  */


RELOC_NUMBER (R_PARISC_FPTR64,        	64)
/*		64-bit doubleword          fptr(symbol+addend) 		  */


/* Plabel relocation types.  */	 
RELOC_NUMBER (R_PARISC_PLABEL32,      	65)
/*		32-bit word	  	   fptr(symbol) 		  */

RELOC_NUMBER (R_PARISC_PLABEL21L,     	66)
/*		long immediate (7)         L(fptr(symbol))		  */

RELOC_NUMBER (R_PARISC_PLABEL14R,     	70)
/*		load/store (1)             R(fptr(symbol))		  */

  
/* PCREL relocations.  */  
RELOC_NUMBER (R_PARISC_PCREL64,       	72)
/*		64-bit doubleword          symbol - PC - 8 + addend       */

RELOC_NUMBER (R_PARISC_PCREL22C,      	73)
/*		branch & link (21)         symbol - PC - 8 + addend       */

RELOC_NUMBER (R_PARISC_PCREL22F,      	74)
/*		branch & link (21)         symbol - PC - 8 + addend       */

RELOC_NUMBER (R_PARISC_PCREL14WR,     	75)
/*		load/store mod. comp. (2)  R(symbol - PC - 8 + addend)    */

RELOC_NUMBER (R_PARISC_PCREL14DR,     	76)
/*		load/store doubleword (3)  R(symbol - PC - 8 + addend)    */

RELOC_NUMBER (R_PARISC_PCREL16F,      	77)
/*		load/store (1)             symbol - PC - 8 + addend       */

RELOC_NUMBER (R_PARISC_PCREL16WF,     	78)
/*		load/store mod. comp. (2)  symbol - PC - 8 + addend       */

RELOC_NUMBER (R_PARISC_PCREL16DF,     	79)
/*		load/store doubleword (3)  symbol - PC - 8 + addend       */


RELOC_NUMBER (R_PARISC_DIR64,         	80)
/*		64-bit doubleword          symbol + addend    		  */

RELOC_NUMBER (R_PARISC_DIR64WR,       	81)
/*		64-bit doubleword          RR(symbol, addend) 		  */

RELOC_NUMBER (R_PARISC_DIR64DR,       	82)
/*		64-bit doubleword          RR(symbol, addend) 		  */

RELOC_NUMBER (R_PARISC_DIR14WR,       	83)
/*		load/store mod. comp. (2)  RR(symbol, addend) 		  */

RELOC_NUMBER (R_PARISC_DIR14DR,       	84)
/*		load/store doubleword (3)  RR(symbol, addend) 		  */

RELOC_NUMBER (R_PARISC_DIR16F,        	85)
/*		load/store (1)             symbol + addend    		  */

RELOC_NUMBER (R_PARISC_DIR16WF,       	86)
/*		load/store mod. comp. (2)  symbol + addend    		  */

RELOC_NUMBER (R_PARISC_DIR16DF,       	87)
/*		load/store doubleword (3)  symbol + addend    		  */
  
RELOC_NUMBER (R_PARISC_GPREL64,       	88)
/*		64-bit doubleword          symbol - GP + addend 	  */
  
RELOC_NUMBER (R_PARISC_DLTREL14WR,    	91)
/*		load/store mod. comp. (2)  RR(symbol - GP, addend) 	  */

RELOC_NUMBER (R_PARISC_DLTREL14DR,    	92)
/*		load/store doubleword (3)  RR(symbol - GP, addend) 	  */

RELOC_NUMBER (R_PARISC_GPREL16F,      	93)
/*		load/store (1)             symbol - GP + addend    	  */

RELOC_NUMBER (R_PARISC_GPREL16WF,     	94)
/*		load/store mod. comp. (2)  symbol - GP + addend    	  */

RELOC_NUMBER (R_PARISC_GPREL16DF,     	95)
/*		load/store doubleword (3)  symbol - GP + addend    	  */


RELOC_NUMBER (R_PARISC_LTOFF64,      	96)
/*		64-bit doubleword          ltoff(symbol + addend)    	  */

RELOC_NUMBER (R_PARISC_DLTIND14WR,   	99)
/*		load/store mod. comp. (2)  R(ltoff(symbol + addend)) 	  */

RELOC_NUMBER (R_PARISC_DLTIND14DR,     100)
/*		load/store doubleword (3)  R(ltoff(symbol + addend)) 	  */

RELOC_NUMBER (R_PARISC_LTOFF16F,       101)
/*		load/store (1)             ltoff(symbol + addend)    	  */

RELOC_NUMBER (R_PARISC_LTOFF16WF,      102)
/*		load/store mod. comp. (2)  ltoff(symbol + addend)    	  */

RELOC_NUMBER (R_PARISC_LTOFF16DF,      103)
/*		load/store doubleword (3)  ltoff(symbol + addend)    	  */


RELOC_NUMBER (R_PARISC_SECREL64,       104)
/*		64-bit doubleword          symbol - SECT + addend 	  */

RELOC_NUMBER (R_PARISC_BASEREL14WR,    107)
/*		load/store mod. comp. (2)  RR(symbol - base, addend) 	  */

RELOC_NUMBER (R_PARISC_BASEREL14DR,    108)
/*		load/store doubleword (3)  RR(symbol - base, addend) 	  */


RELOC_NUMBER (R_PARISC_SEGREL64,       112)
/*		64-bit doubleword          symbol - SB + addend 	  */
  
RELOC_NUMBER (R_PARISC_PLTOFF14WR,     115)
/*		load/store mod. comp. (2)  RR(pltoff(symbol), addend) 	  */

RELOC_NUMBER (R_PARISC_PLTOFF14DR,     116)    
/*		load/store doubleword (3)  RR(pltoff(symbol), addend) 	  */

RELOC_NUMBER (R_PARISC_PLTOFF16F,      117)    
/*		load/store (1)             pltoff(symbol) + addend    	  */

RELOC_NUMBER (R_PARISC_PLTOFF16WF,     118)    
/*		load/store mod. comp. (2)  pltoff(symbol) + addend    	  */

RELOC_NUMBER (R_PARISC_PLTOFF16DF,     119)    
/*		load/store doubleword (3)  pltoff(symbol) + addend    	  */


RELOC_NUMBER (R_PARISC_LTOFF_FPTR64,   120)
/*		64-bit doubleword          ltoff(fptr(symbol+addend))     */

RELOC_NUMBER (R_PARISC_LTOFF_FPTR14WR, 123)
/*		load/store mod. comp. (2)  R(ltoff(fptr(symbol+addend)))  */

RELOC_NUMBER (R_PARISC_LTOFF_FPTR14DR, 124)
/*		load/store doubleword (3)  R(ltoff(fptr(symbol+addend)))  */

RELOC_NUMBER (R_PARISC_LTOFF_FPTR16F,  125)
/*		load/store (1)             ltoff(fptr(symbol+addend))     */

RELOC_NUMBER (R_PARISC_LTOFF_FPTR16WF, 126)
/*		load/store mod. comp. (2)  ltoff(fptr(symbol+addend))     */

RELOC_NUMBER (R_PARISC_LTOFF_FPTR16DF, 127)
/*		load/store doubleword (3)  ltoff(fptr(symbol+addend))     */


RELOC_NUMBER (R_PARISC_COPY, 	       128)
/*		data                       Dynamic relocations only 	  */

RELOC_NUMBER (R_PARISC_IPLT, 	       129)
/*		plt                                                 	  */

RELOC_NUMBER (R_PARISC_EPLT, 	       130)
/*		plt                                                 	  */


RELOC_NUMBER (R_PARISC_TPREL32,        153)
/*		32-bit word                symbol - TP + addend    	  */

RELOC_NUMBER (R_PARISC_TPREL21L,       154)
/*		long immediate (7)         LR(symbol - TP, addend) 	  */

RELOC_NUMBER (R_PARISC_TPREL14R,       158)
/*		load/store (1)             RR(symbol - TP, addend) 	  */


RELOC_NUMBER (R_PARISC_LTOFF_TP21L,    162)
/*		long immediate (7)         L(ltoff(symbol - TP + addend)) */

RELOC_NUMBER (R_PARISC_LTOFF_TP14R,    166)
/*		load/store (1)             R(ltoff(symbol - TP + addend)) */

RELOC_NUMBER (R_PARISC_LTOFF_TP14F,    167)
/*		load/store (1)             ltoff(symbol - TP + addend)    */


RELOC_NUMBER (R_PARISC_TPREL64,        216)
/*		64-bit word                symbol - TP + addend        	  */

RELOC_NUMBER (R_PARISC_TPREL14WR,      219)    	  
/*		load/store mod. comp. (2)  RR(symbol - TP, addend)     	  */

RELOC_NUMBER (R_PARISC_TPREL14DR,      220)    	  
/*		load/store doubleword (3)  RR(symbol - TP, addend)     	  */

RELOC_NUMBER (R_PARISC_TPREL16F,       221)    	  
/*		load/store (1)             symbol - TP + addend        	  */

RELOC_NUMBER (R_PARISC_TPREL16WF,      222)    	  
/*		load/store mod. comp. (2)  symbol - TP + addend        	  */

RELOC_NUMBER (R_PARISC_TPREL16DF,      223)    	  
/*		load/store doubleword (3)  symbol - TP + addend        	  */


RELOC_NUMBER (R_PARISC_LTOFF_TP64,     224)
/*		64-bit doubleword          ltoff(symbol - TP + addend)    */

RELOC_NUMBER (R_PARISC_LTOFF_TP14WR,   227)
/*		load/store mod. comp. (2)  R(ltoff(symbol - TP + addend)) */

RELOC_NUMBER (R_PARISC_LTOFF_TP14DR,   228)
/*		load/store doubleword (3)  R(ltoff(symbol - TP + addend)) */

RELOC_NUMBER (R_PARISC_LTOFF_TP16F,    229)
/*		load/store (1)             ltoff(symbol - TP + addend)    */

RELOC_NUMBER (R_PARISC_LTOFF_TP16WF,   230)
/*		load/store mod. comp. (2)  ltoff(symbol - TP + addend)    */

RELOC_NUMBER (R_PARISC_LTOFF_TP16DF,   231)
/*		load/store doubleword (3)  ltoff(symbol - TP + addend)    */

RELOC_NUMBER (R_PARISC_GNU_VTENTRY,    232)
RELOC_NUMBER (R_PARISC_GNU_VTINHERIT,  233)

END_RELOC_NUMBERS (R_PARISC_UNIMPLEMENTED)

#ifndef RELOC_MACROS_GEN_FUNC
typedef enum elf_hppa_reloc_type elf_hppa_reloc_type;
#endif

#define PT_PARISC_ARCHEXT	0x70000000
#define PT_PARISC_UNWIND	0x70000001
#define PF_PARISC_SBP		0x08000000
#define PF_HP_PAGE_SIZE		0x00100000
#define PF_HP_FAR_SHARED	0x00200000
#define PF_HP_NEAR_SHARED	0x00400000
#define PF_HP_CODE		0x01000000
#define PF_HP_MODIFY		0x02000000
#define PF_HP_LAZYSWAP		0x04000000
#define PF_HP_SBP		0x08000000


/* Processor specific dynamic array tags.  */

/* Arggh.  HP's tools define these symbols based on the
   old value of DT_LOOS.  So we must do the same to be
   compatible.  */
#define DT_HP_LOAD_MAP		(OLD_DT_LOOS + 0x0)
#define DT_HP_DLD_FLAGS		(OLD_DT_LOOS + 0x1)
#define DT_HP_DLD_HOOK		(OLD_DT_LOOS + 0x2)
#define DT_HP_UX10_INIT		(OLD_DT_LOOS + 0x3)
#define DT_HP_UX10_INITSZ	(OLD_DT_LOOS + 0x4)
#define DT_HP_PREINIT		(OLD_DT_LOOS + 0x5)
#define DT_HP_PREINITSZ		(OLD_DT_LOOS + 0x6)
#define DT_HP_NEEDED		(OLD_DT_LOOS + 0x7)
#define DT_HP_TIME_STAMP	(OLD_DT_LOOS + 0x8)
#define DT_HP_CHECKSUM		(OLD_DT_LOOS + 0x9)
#define DT_HP_GST_SIZE		(OLD_DT_LOOS + 0xa)
#define DT_HP_GST_VERSION	(OLD_DT_LOOS + 0xb)
#define DT_HP_GST_HASHVAL	(OLD_DT_LOOS + 0xc)

/* Values for DT_HP_DLD_FLAGS.  */
#define DT_HP_DEBUG_PRIVATE		0x0001 /* Map text private */
#define DT_HP_DEBUG_CALLBACK		0x0002 /* Callback */
#define DT_HP_DEBUG_CALLBACK_BOR	0x0004 /* BOR callback */
#define DT_HP_NO_ENVVAR			0x0008 /* No env var */
#define DT_HP_BIND_NOW			0x0010 /* Bind now */
#define DT_HP_BIND_NONFATAL		0x0020 /* Bind non-fatal */
#define DT_HP_BIND_VERBOSE		0x0040 /* Bind verbose */
#define DT_HP_BIND_RESTRICTED		0x0080 /* Bind restricted */
#define DT_HP_BIND_SYMBOLIC		0x0100 /* Bind symbolic */
#define DT_HP_RPATH_FIRST		0x0200 /* RPATH first */
#define DT_HP_BIND_DEPTH_FIRST		0x0400 /* Bind depth-first */

/* Program header extensions.  */
#define PT_HP_TLS		(PT_LOOS + 0x0)
#define PT_HP_CORE_NONE		(PT_LOOS + 0x1)
#define PT_HP_CORE_VERSION	(PT_LOOS + 0x2)
#define PT_HP_CORE_KERNEL	(PT_LOOS + 0x3)
#define PT_HP_CORE_COMM		(PT_LOOS + 0x4)
#define PT_HP_CORE_PROC		(PT_LOOS + 0x5)
#define PT_HP_CORE_LOADABLE	(PT_LOOS + 0x6)
#define PT_HP_CORE_STACK	(PT_LOOS + 0x7)
#define PT_HP_CORE_SHM		(PT_LOOS + 0x8)
#define PT_HP_CORE_MMF		(PT_LOOS + 0x9)
#define PT_HP_PARALLEL		(PT_LOOS + 0x10)
#define PT_HP_FASTBIND		(PT_LOOS + 0x11)

/* Additional symbol types.  */
#define STT_HP_OPAQUE		(STT_LOOS + 0x1)
#define STT_HP_STUB		(STT_LOOS + 0x2)

#endif /* _ELF_HPPA_H */
@


1.2
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1993, 1994, 1999 Free Software Foundation, Inc.
d106 1
a106 1
     RELOC_NUMBER (R_PARISC_NONE,      0)	/* No reloc */
d108 1
a108 1
     /* These relocation types do simple base + offset relocations.  */
d110 375
a484 163
     RELOC_NUMBER (R_PARISC_DIR32,  1)
     RELOC_NUMBER (R_PARISC_DIR21L, 2)
     RELOC_NUMBER (R_PARISC_DIR17R, 3)
     RELOC_NUMBER (R_PARISC_DIR17F, 4)
     RELOC_NUMBER (R_PARISC_DIR14R, 6)

    /* PC-relative relocation types
       Typically used for calls.
       Note PCREL17C and PCREL17F differ only in overflow handling.
       PCREL17C never reports a relocation error.

       When supporting argument relocations, function calls must be
       accompanied by parameter relocation information.  This information is
       carried in the ten high-order bits of the addend field.  The remaining
       22 bits of of the addend field are sign-extended to form the Addend.

       Note the code to build argument relocations depends on the
       addend being zero.  A consequence of this limitation is GAS
       can not perform relocation reductions for function symbols.  */

    RELOC_NUMBER (R_PARISC_PCREL32, 9)
    RELOC_NUMBER (R_PARISC_PCREL21L, 10)
    RELOC_NUMBER (R_PARISC_PCREL17R, 11)
    RELOC_NUMBER (R_PARISC_PCREL17F, 12)
    RELOC_NUMBER (R_PARISC_PCREL17C, 13)
    RELOC_NUMBER (R_PARISC_PCREL14R, 14)
    RELOC_NUMBER (R_PARISC_PCREL14F, 15)

    /* DP-relative relocation types.  */
    RELOC_NUMBER (R_PARISC_DPREL21L, 18)
    RELOC_NUMBER (R_PARISC_DPREL14WR, 19)
    RELOC_NUMBER (R_PARISC_DPREL14DR, 20)
    RELOC_NUMBER (R_PARISC_DPREL14R, 22)
    RELOC_NUMBER (R_PARISC_DPREL14F, 23)

    /* Data linkage table (DLT) relocation types

       SOM DLT_REL fixup requests are used to for static data references
       from position-independent code within shared libraries.  They are
       similar to the GOT relocation types in some SVR4 implementations.  */

    RELOC_NUMBER (R_PARISC_DLTREL21L, 26)
    RELOC_NUMBER (R_PARISC_DLTREL14R, 30)
    RELOC_NUMBER (R_PARISC_DLTREL14F, 31)

    /* DLT indirect relocation types  */
    RELOC_NUMBER (R_PARISC_DLTIND21L, 34)
    RELOC_NUMBER (R_PARISC_DLTIND14R, 38)
    RELOC_NUMBER (R_PARISC_DLTIND14F, 39)

    /* Base relative relocation types.  Ugh.  These imply lots of state */
    RELOC_NUMBER (R_PARISC_SETBASE, 40)
    RELOC_NUMBER (R_PARISC_SECREL32, 41)
    RELOC_NUMBER (R_PARISC_BASEREL21L, 42)
    RELOC_NUMBER (R_PARISC_BASEREL17R, 43)
    RELOC_NUMBER (R_PARISC_BASEREL17F, 44)
    RELOC_NUMBER (R_PARISC_BASEREL14R, 46)
    RELOC_NUMBER (R_PARISC_BASEREL14F, 47)

    /* Segment relative relocation types.  */
    RELOC_NUMBER (R_PARISC_SEGBASE, 48)
    RELOC_NUMBER (R_PARISC_SEGREL32, 49)

    /* Offsets from the PLT.  */
    RELOC_NUMBER (R_PARISC_PLTOFF21L, 50)
    RELOC_NUMBER (R_PARISC_PLTOFF14R, 54)
    RELOC_NUMBER (R_PARISC_PLTOFF14F, 55)

    RELOC_NUMBER (R_PARISC_LTOFF_FPTR32, 57)
    RELOC_NUMBER (R_PARISC_LTOFF_FPTR21L, 58)
    RELOC_NUMBER (R_PARISC_LTOFF_FPTR14R, 62)

    RELOC_NUMBER (R_PARISC_FPTR64, 64)

    /* Plabel relocation types.  */
    RELOC_NUMBER (R_PARISC_PLABEL32, 65)
    RELOC_NUMBER (R_PARISC_PLABEL21L, 66)
    RELOC_NUMBER (R_PARISC_PLABEL14R, 70)

    /* PCREL relocations.  */
    RELOC_NUMBER (R_PARISC_PCREL64, 72)
    RELOC_NUMBER (R_PARISC_PCREL22C, 73)
    RELOC_NUMBER (R_PARISC_PCREL22F, 74)
    RELOC_NUMBER (R_PARISC_PCREL14WR, 75)
    RELOC_NUMBER (R_PARISC_PCREL14DR, 76)
    RELOC_NUMBER (R_PARISC_PCREL16F, 77)
    RELOC_NUMBER (R_PARISC_PCREL16WF, 78)
    RELOC_NUMBER (R_PARISC_PCREL16DF, 79)


    RELOC_NUMBER (R_PARISC_DIR64, 80)
    RELOC_NUMBER (R_PARISC_DIR64WR, 81)
    RELOC_NUMBER (R_PARISC_DIR64DR, 82)
    RELOC_NUMBER (R_PARISC_DIR14WR, 83)
    RELOC_NUMBER (R_PARISC_DIR14DR, 84)
    RELOC_NUMBER (R_PARISC_DIR16F, 85)
    RELOC_NUMBER (R_PARISC_DIR16WF, 86)
    RELOC_NUMBER (R_PARISC_DIR16DF, 87)

    RELOC_NUMBER (R_PARISC_GPREL64, 88)

    RELOC_NUMBER (R_PARISC_DLTREL14WR, 91)
    RELOC_NUMBER (R_PARISC_DLTREL14DR, 92)
    RELOC_NUMBER (R_PARISC_GPREL16F, 93)
    RELOC_NUMBER (R_PARISC_GPREL16WF, 94)
    RELOC_NUMBER (R_PARISC_GPREL16DF, 95)


    RELOC_NUMBER (R_PARISC_LTOFF64, 96)
    RELOC_NUMBER (R_PARISC_DLTIND14WR, 99)
    RELOC_NUMBER (R_PARISC_DLTIND14DR, 100)
    RELOC_NUMBER (R_PARISC_LTOFF16F, 101)
    RELOC_NUMBER (R_PARISC_LTOFF16WF, 102)
    RELOC_NUMBER (R_PARISC_LTOFF16DF, 103)

    RELOC_NUMBER (R_PARISC_SECREL64, 104)

    RELOC_NUMBER (R_PARISC_BASEREL14WR, 107)
    RELOC_NUMBER (R_PARISC_BASEREL14DR, 108)

    RELOC_NUMBER (R_PARISC_SEGREL64, 112)

    RELOC_NUMBER (R_PARISC_PLTOFF14WR, 115)
    RELOC_NUMBER (R_PARISC_PLTOFF14DR, 116)
    RELOC_NUMBER (R_PARISC_PLTOFF16F, 117)
    RELOC_NUMBER (R_PARISC_PLTOFF16WF, 118)
    RELOC_NUMBER (R_PARISC_PLTOFF16DF, 119)

    RELOC_NUMBER (R_PARISC_LTOFF_FPTR64, 120)
    RELOC_NUMBER (R_PARISC_LTOFF_FPTR14WR, 123)
    RELOC_NUMBER (R_PARISC_LTOFF_FPTR14DR, 124)
    RELOC_NUMBER (R_PARISC_LTOFF_FPTR16F, 125)
    RELOC_NUMBER (R_PARISC_LTOFF_FPTR16WF, 126)
    RELOC_NUMBER (R_PARISC_LTOFF_FPTR16DF, 127)


    RELOC_NUMBER (R_PARISC_COPY, 128)
    RELOC_NUMBER (R_PARISC_IPLT, 129)
    RELOC_NUMBER (R_PARISC_EPLT, 130)

    RELOC_NUMBER (R_PARISC_TPREL32, 153)
    RELOC_NUMBER (R_PARISC_TPREL21L, 154)
    RELOC_NUMBER (R_PARISC_TPREL14R, 158)

    RELOC_NUMBER (R_PARISC_LTOFF_TP21L, 162)
    RELOC_NUMBER (R_PARISC_LTOFF_TP14R, 166)
    RELOC_NUMBER (R_PARISC_LTOFF_TP14F, 167)

    RELOC_NUMBER (R_PARISC_TPREL64, 216)
    RELOC_NUMBER (R_PARISC_TPREL14WR, 219)
    RELOC_NUMBER (R_PARISC_TPREL14DR, 220)
    RELOC_NUMBER (R_PARISC_TPREL16F, 221)
    RELOC_NUMBER (R_PARISC_TPREL16WF, 222)
    RELOC_NUMBER (R_PARISC_TPREL16DF, 223)

    RELOC_NUMBER (R_PARISC_LTOFF_TP64, 224)
    RELOC_NUMBER (R_PARISC_LTOFF_TP14WR, 227)
    RELOC_NUMBER (R_PARISC_LTOFF_TP14DR, 228)
    RELOC_NUMBER (R_PARISC_LTOFF_TP16F, 229)
    RELOC_NUMBER (R_PARISC_LTOFF_TP16WF, 230)
    RELOC_NUMBER (R_PARISC_LTOFF_TP16DF, 231)
    EMPTY_RELOC (R_PARISC_UNIMPLEMENTED)
END_RELOC_NUMBERS
d504 16
a519 13
#define DT_HP_LOAD_MAP		(DT_LOOS + 0x0)
#define DT_HP_DLD_FLAGS		(DT_LOOS + 0x1)
#define DT_HP_DLD_HOOK		(DT_LOOS + 0x2)
#define DT_HP_UX10_INIT		(DT_LOOS + 0x3)
#define DT_HP_UX10_INITSZ	(DT_LOOS + 0x4)
#define DT_HP_PREINIT		(DT_LOOS + 0x5)
#define DT_HP_PREINITSZ		(DT_LOOS + 0x6)
#define DT_HP_NEEDED		(DT_LOOS + 0x7)
#define DT_HP_TIME_STAMP	(DT_LOOS + 0x8)
#define DT_HP_CHECKSUM		(DT_LOOS + 0x9)
#define DT_HP_GST_SIZE		(DT_LOOS + 0xa)
#define DT_HP_GST_VERSION	(DT_LOOS + 0xb)
#define DT_HP_GST_HASHVAL	(DT_LOOS + 0xc)
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1993, 1994 Free Software Foundation, Inc.
d28 8
a35 8
/* Target processor IDs to be placed in the low 16 bits of the flags
   field.  Note these names are shared with SOM, and therefore do not
   follow ELF naming conventions.  */

/* PA 1.0 big endian.  */
#ifndef CPU_PA_RISC1_0
#define CPU_PA_RISC1_0		0x0000020b
#endif
d37 2
a38 4
/* PA 1.1 big endian.  */
#ifndef CPU_PA_RISC1_1
#define CPU_PA_RISC1_1		0x00000210
#endif
d40 2
a41 2
/* PA 1.0 little endian (unsupported) is 0x0000028b.  */
/* PA 1.1 little endian (unsupported) is 0x00000290.  */
d43 2
a44 2
/* Trap null address dereferences.  */
#define ELF_PARISC_TRAPNIL	0x00010000
d46 2
a47 2
/* .PARISC.archext section is present.  */
#define EF_PARISC_EXT		0x00020000
d49 3
a51 1
/* Processor specific section types.  */
d53 4
a56 3
/* Holds the global offset table, a table of pointers to external
   data.  */
#define SHT_PARISC_GOT		SHT_LOPROC+0
d58 3
a60 3
/* Nonloadable section containing information in architecture
   extensions used by the code.  */
#define SHT_PARISC_ARCH		SHT_LOPROC+1
d62 1
a62 2
/* Section in which $global$ is defined.  */
#define SHT_PARISC_GLOBAL	SHT_LOPROC+2
d64 2
a65 2
/* Section holding millicode routines (mul, div, rem, dyncall, etc.  */
#define SHT_PARISC_MILLI	SHT_LOPROC+3
d67 2
a68 2
/* Section holding unwind information for use by debuggers.  */
#define SHT_PARISC_UNWIND	SHT_LOPROC+4
d70 2
a71 2
/* Section holding the procedure linkage table.  */
#define SHT_PARISC_PLT		SHT_LOPROC+5
d73 2
a74 3
/* Short initialized and uninitialized data.  */
#define SHT_PARISC_SDATA	SHT_LOPROC+6
#define SHT_PARISC_SBSS		SHT_LOPROC+7
d76 2
d79 1
a79 1
#define SHT_PARISC_SYMEXTN	SHT_LOPROC+8
d82 1
a82 1
#define SHT_PARISC_STUBS	SHT_LOPROC+9
d86 5
a90 3
/* This section is near the global data pointer and thus allows short
   addressing modes to be used.  */
#define SHF_PARISC_SHORT        0x20000000
d92 184
a275 1
/* Processor specific symbol types.  */
d277 58
a334 2
/* Millicode function entry point.  */
#define STT_PARISC_MILLICODE	STT_LOPROC+0
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1993, 1994, 1999 Free Software Foundation, Inc.
d28 17
d46 1
a46 1
#define EF_PARISC_TRAPNIL	0x00010000
d51 1
a51 5
/* Program expects little-endian mode.  */
#define EF_PARISC_LSB		0x00040000

/* Program expects wide mode.  */
#define EF_PARISC_WIDE		0x00080000
d53 3
a55 2
/* Do not allow kernel-assisted branch prediction.  */
#define EF_PARISC_NO_KABP	0x00100000
d57 3
a59 2
/* Allow lazy swap for dynamically allocated program segments.  */
#define EF_PARISC_LAZYSWAP	0x00400000
d61 2
a62 2
/* Architecture version */
#define EF_PARISC_ARCH		0x0000ffff
d64 2
a65 3
#define EFA_PARISC_1_0			0x020b
#define EFA_PARISC_1_1			0x0210
#define EFA_PARISC_2_0			0x0214
d67 2
a68 4
/* Special section indices.  */
/* A symbol that has been declared as a tentative definition in an ANSI C
   compilation.  */
#define SHN_PARISC_ANSI_COMMON 	0xff00
d70 2
a71 5
/* A symbol that has been declared as a common block using the
   huge memory model.  */
#define SHN_PARISC_HUGE_COMMON	0xff01

/* Processor specific section types.  */
d73 3
a75 2
/* Section contains product specific extension bits.  */
#define SHT_PARISC_EXT		0x70000000
a76 11
/* Section contains unwind table entries.  */
#define SHT_PARISC_UNWIND	0x70000001

/* Section contains debug information for optimized code.  */
#define SHT_PARISC_DOC		0x70000002

/* Section contains code annotations.  */
#define SHT_PARISC_ANNOT	0x70000003

/* These are strictly for compatibility with the older elf32-hppa
   implementation.  Hopefully we can eliminate them in the future.  */
d78 1
a78 1
#define SHT_PARISC_SYMEXTN    SHT_LOPROC+8
d81 1
a81 1
#define SHT_PARISC_STUBS      SHT_LOPROC+9
d85 3
a87 5
/* Section contains code compiled for static branch prediction.  */
#define SHF_PARISC_SBP		0x80000000

/* Section should be allocated from from GP.  */
#define SHF_PARISC_HUGE		0x40000000
d89 1
a89 184
/* Section should go near GP.  */
#define SHF_PARISC_SHORT	0x20000000


/* Identifies the entry point of a millicode routine.  */
#define STT_PARISC_MILLI	13

/* ELF/HPPA relocation types */

/* Note: PA-ELF is defined to use only RELA relocations.  */
#include "elf/reloc-macros.h"

START_RELOC_NUMBERS (elf_hppa_reloc_type)
     RELOC_NUMBER (R_PARISC_NONE,      0)	/* No reloc */

     /* These relocation types do simple base + offset relocations.  */

     RELOC_NUMBER (R_PARISC_DIR32,  1)
     RELOC_NUMBER (R_PARISC_DIR21L, 2)
     RELOC_NUMBER (R_PARISC_DIR17R, 3)
     RELOC_NUMBER (R_PARISC_DIR17F, 4)
     RELOC_NUMBER (R_PARISC_DIR14R, 6)

    /* PC-relative relocation types
       Typically used for calls.
       Note PCREL17C and PCREL17F differ only in overflow handling.
       PCREL17C never reports a relocation error.

       When supporting argument relocations, function calls must be
       accompanied by parameter relocation information.  This information is
       carried in the ten high-order bits of the addend field.  The remaining
       22 bits of of the addend field are sign-extended to form the Addend.

       Note the code to build argument relocations depends on the
       addend being zero.  A consequence of this limitation is GAS
       can not perform relocation reductions for function symbols.  */

    RELOC_NUMBER (R_PARISC_PCREL32, 9)
    RELOC_NUMBER (R_PARISC_PCREL21L, 10)
    RELOC_NUMBER (R_PARISC_PCREL17R, 11)
    RELOC_NUMBER (R_PARISC_PCREL17F, 12)
    RELOC_NUMBER (R_PARISC_PCREL17C, 13)
    RELOC_NUMBER (R_PARISC_PCREL14R, 14)
    RELOC_NUMBER (R_PARISC_PCREL14F, 15)

    /* DP-relative relocation types.  */
    RELOC_NUMBER (R_PARISC_DPREL21L, 18)
    RELOC_NUMBER (R_PARISC_DPREL14WR, 19)
    RELOC_NUMBER (R_PARISC_DPREL14DR, 20)
    RELOC_NUMBER (R_PARISC_DPREL14R, 22)
    RELOC_NUMBER (R_PARISC_DPREL14F, 23)

    /* Data linkage table (DLT) relocation types

       SOM DLT_REL fixup requests are used to for static data references
       from position-independent code within shared libraries.  They are
       similar to the GOT relocation types in some SVR4 implementations.  */

    RELOC_NUMBER (R_PARISC_DLTREL21L, 26)
    RELOC_NUMBER (R_PARISC_DLTREL14R, 30)
    RELOC_NUMBER (R_PARISC_DLTREL14F, 31)

    /* DLT indirect relocation types  */
    RELOC_NUMBER (R_PARISC_DLTIND21L, 34)
    RELOC_NUMBER (R_PARISC_DLTIND14R, 38)
    RELOC_NUMBER (R_PARISC_DLTIND14F, 39)

    /* Base relative relocation types.  Ugh.  These imply lots of state */
    RELOC_NUMBER (R_PARISC_SETBASE, 40)
    RELOC_NUMBER (R_PARISC_SECREL32, 41)
    RELOC_NUMBER (R_PARISC_BASEREL21L, 42)
    RELOC_NUMBER (R_PARISC_BASEREL17R, 43)
    RELOC_NUMBER (R_PARISC_BASEREL17F, 44)
    RELOC_NUMBER (R_PARISC_BASEREL14R, 46)
    RELOC_NUMBER (R_PARISC_BASEREL14F, 47)

    /* Segment relative relocation types.  */
    RELOC_NUMBER (R_PARISC_SEGBASE, 48)
    RELOC_NUMBER (R_PARISC_SEGREL32, 49)

    /* Offsets from the PLT.  */
    RELOC_NUMBER (R_PARISC_PLTOFF21L, 50)
    RELOC_NUMBER (R_PARISC_PLTOFF14R, 54)
    RELOC_NUMBER (R_PARISC_PLTOFF14F, 55)

    RELOC_NUMBER (R_PARISC_LTOFF_FPTR32, 57)
    RELOC_NUMBER (R_PARISC_LTOFF_FPTR21L, 58)
    RELOC_NUMBER (R_PARISC_LTOFF_FPTR14R, 62)

    RELOC_NUMBER (R_PARISC_FPTR64, 64)

    /* Plabel relocation types.  */
    RELOC_NUMBER (R_PARISC_PLABEL32, 65)
    RELOC_NUMBER (R_PARISC_PLABEL21L, 66)
    RELOC_NUMBER (R_PARISC_PLABEL14R, 70)

    /* PCREL relocations.  */
    RELOC_NUMBER (R_PARISC_PCREL64, 72)
    RELOC_NUMBER (R_PARISC_PCREL22C, 73)
    RELOC_NUMBER (R_PARISC_PCREL22F, 74)
    RELOC_NUMBER (R_PARISC_PCREL14WR, 75)
    RELOC_NUMBER (R_PARISC_PCREL14DR, 76)
    RELOC_NUMBER (R_PARISC_PCREL16F, 77)
    RELOC_NUMBER (R_PARISC_PCREL16WF, 78)
    RELOC_NUMBER (R_PARISC_PCREL16DF, 79)


    RELOC_NUMBER (R_PARISC_DIR64, 80)
    RELOC_NUMBER (R_PARISC_DIR64WR, 81)
    RELOC_NUMBER (R_PARISC_DIR64DR, 82)
    RELOC_NUMBER (R_PARISC_DIR14WR, 83)
    RELOC_NUMBER (R_PARISC_DIR14DR, 84)
    RELOC_NUMBER (R_PARISC_DIR16F, 85)
    RELOC_NUMBER (R_PARISC_DIR16WF, 86)
    RELOC_NUMBER (R_PARISC_DIR16DF, 87)

    RELOC_NUMBER (R_PARISC_GPREL64, 88)

    RELOC_NUMBER (R_PARISC_DLTREL14WR, 91)
    RELOC_NUMBER (R_PARISC_DLTREL14DR, 92)
    RELOC_NUMBER (R_PARISC_GPREL16F, 93)
    RELOC_NUMBER (R_PARISC_GPREL16WF, 94)
    RELOC_NUMBER (R_PARISC_GPREL16DF, 95)


    RELOC_NUMBER (R_PARISC_LTOFF64, 96)
    RELOC_NUMBER (R_PARISC_DLTIND14WR, 99)
    RELOC_NUMBER (R_PARISC_DLTIND14DR, 100)
    RELOC_NUMBER (R_PARISC_LTOFF16F, 101)
    RELOC_NUMBER (R_PARISC_LTOFF16WF, 102)
    RELOC_NUMBER (R_PARISC_LTOFF16DF, 103)

    RELOC_NUMBER (R_PARISC_SECREL64, 104)

    RELOC_NUMBER (R_PARISC_BASEREL14WR, 107)
    RELOC_NUMBER (R_PARISC_BASEREL14DR, 108)

    RELOC_NUMBER (R_PARISC_SEGREL64, 112)

    RELOC_NUMBER (R_PARISC_PLTOFF14WR, 115)
    RELOC_NUMBER (R_PARISC_PLTOFF14DR, 116)
    RELOC_NUMBER (R_PARISC_PLTOFF16F, 117)
    RELOC_NUMBER (R_PARISC_PLTOFF16WF, 118)
    RELOC_NUMBER (R_PARISC_PLTOFF16DF, 119)

    RELOC_NUMBER (R_PARISC_LTOFF_FPTR64, 120)
    RELOC_NUMBER (R_PARISC_LTOFF_FPTR14WR, 123)
    RELOC_NUMBER (R_PARISC_LTOFF_FPTR14DR, 124)
    RELOC_NUMBER (R_PARISC_LTOFF_FPTR16F, 125)
    RELOC_NUMBER (R_PARISC_LTOFF_FPTR16WF, 126)
    RELOC_NUMBER (R_PARISC_LTOFF_FPTR16DF, 127)


    RELOC_NUMBER (R_PARISC_COPY, 128)
    RELOC_NUMBER (R_PARISC_IPLT, 129)
    RELOC_NUMBER (R_PARISC_EPLT, 130)

    RELOC_NUMBER (R_PARISC_TPREL32, 153)
    RELOC_NUMBER (R_PARISC_TPREL21L, 154)
    RELOC_NUMBER (R_PARISC_TPREL14R, 158)

    RELOC_NUMBER (R_PARISC_LTOFF_TP21L, 162)
    RELOC_NUMBER (R_PARISC_LTOFF_TP14R, 166)
    RELOC_NUMBER (R_PARISC_LTOFF_TP14F, 167)

    RELOC_NUMBER (R_PARISC_TPREL64, 216)
    RELOC_NUMBER (R_PARISC_TPREL14WR, 219)
    RELOC_NUMBER (R_PARISC_TPREL14DR, 220)
    RELOC_NUMBER (R_PARISC_TPREL16F, 221)
    RELOC_NUMBER (R_PARISC_TPREL16WF, 222)
    RELOC_NUMBER (R_PARISC_TPREL16DF, 223)

    RELOC_NUMBER (R_PARISC_LTOFF_TP64, 224)
    RELOC_NUMBER (R_PARISC_LTOFF_TP14WR, 227)
    RELOC_NUMBER (R_PARISC_LTOFF_TP14DR, 228)
    RELOC_NUMBER (R_PARISC_LTOFF_TP16F, 229)
    RELOC_NUMBER (R_PARISC_LTOFF_TP16WF, 230)
    RELOC_NUMBER (R_PARISC_LTOFF_TP16DF, 231)
    EMPTY_RELOC (R_PARISC_UNIMPLEMENTED)
END_RELOC_NUMBERS

#ifndef RELOC_MACROS_GEN_FUNC
typedef enum elf_hppa_reloc_type elf_hppa_reloc_type;
#endif
d91 2
a92 58
#define PT_PARISC_ARCHEXT	0x70000000
#define PT_PARISC_UNWIND	0x70000001
#define PF_PARISC_SBP		0x08000000
#define PF_HP_PAGE_SIZE		0x00100000
#define PF_HP_FAR_SHARED	0x00200000
#define PF_HP_NEAR_SHARED	0x00400000
#define PF_HP_CODE		0x01000000
#define PF_HP_MODIFY		0x02000000
#define PF_HP_LAZYSWAP		0x04000000
#define PF_HP_SBP		0x08000000


/* Processor specific dynamic array tags.  */

#define DT_HP_LOAD_MAP		(DT_LOOS + 0x0)
#define DT_HP_DLD_FLAGS		(DT_LOOS + 0x1)
#define DT_HP_DLD_HOOK		(DT_LOOS + 0x2)
#define DT_HP_UX10_INIT		(DT_LOOS + 0x3)
#define DT_HP_UX10_INITSZ	(DT_LOOS + 0x4)
#define DT_HP_PREINIT		(DT_LOOS + 0x5)
#define DT_HP_PREINITSZ		(DT_LOOS + 0x6)
#define DT_HP_NEEDED		(DT_LOOS + 0x7)
#define DT_HP_TIME_STAMP	(DT_LOOS + 0x8)
#define DT_HP_CHECKSUM		(DT_LOOS + 0x9)
#define DT_HP_GST_SIZE		(DT_LOOS + 0xa)
#define DT_HP_GST_VERSION	(DT_LOOS + 0xb)
#define DT_HP_GST_HASHVAL	(DT_LOOS + 0xc)

/* Values for DT_HP_DLD_FLAGS.  */
#define DT_HP_DEBUG_PRIVATE		0x0001 /* Map text private */
#define DT_HP_DEBUG_CALLBACK		0x0002 /* Callback */
#define DT_HP_DEBUG_CALLBACK_BOR	0x0004 /* BOR callback */
#define DT_HP_NO_ENVVAR			0x0008 /* No env var */
#define DT_HP_BIND_NOW			0x0010 /* Bind now */
#define DT_HP_BIND_NONFATAL		0x0020 /* Bind non-fatal */
#define DT_HP_BIND_VERBOSE		0x0040 /* Bind verbose */
#define DT_HP_BIND_RESTRICTED		0x0080 /* Bind restricted */
#define DT_HP_BIND_SYMBOLIC		0x0100 /* Bind symbolic */
#define DT_HP_RPATH_FIRST		0x0200 /* RPATH first */
#define DT_HP_BIND_DEPTH_FIRST		0x0400 /* Bind depth-first */

/* Program header extensions.  */
#define PT_HP_TLS		(PT_LOOS + 0x0)
#define PT_HP_CORE_NONE		(PT_LOOS + 0x1)
#define PT_HP_CORE_VERSION	(PT_LOOS + 0x2)
#define PT_HP_CORE_KERNEL	(PT_LOOS + 0x3)
#define PT_HP_CORE_COMM		(PT_LOOS + 0x4)
#define PT_HP_CORE_PROC		(PT_LOOS + 0x5)
#define PT_HP_CORE_LOADABLE	(PT_LOOS + 0x6)
#define PT_HP_CORE_STACK	(PT_LOOS + 0x7)
#define PT_HP_CORE_SHM		(PT_LOOS + 0x8)
#define PT_HP_CORE_MMF		(PT_LOOS + 0x9)
#define PT_HP_PARALLEL		(PT_LOOS + 0x10)
#define PT_HP_FASTBIND		(PT_LOOS + 0x11)

/* Additional symbol types.  */
#define STT_HP_OPAQUE		(STT_LOOS + 0x1)
#define STT_HP_STUB		(STT_LOOS + 0x2)
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1993, 1994, 1995, 1998, 1999, 2000
   Free Software Foundation, Inc.
d105 1
a105 1
RELOC_NUMBER (R_PARISC_NONE,	         0) /* No reloc */
d107 1
a107 1
/*		Data / Inst. Format	   Relocation Expression	  */
d109 163
a271 375
RELOC_NUMBER (R_PARISC_DIR32,	   	 1)
/*		32-bit word            	   symbol + addend    		  */

RELOC_NUMBER (R_PARISC_DIR21L,	   	 2)
/*		long immediate (7)	   LR(symbol, addend) 		  */

RELOC_NUMBER (R_PARISC_DIR17R,	   	 3)
/*		branch external (19)	   RR(symbol, addend) 		  */

RELOC_NUMBER (R_PARISC_DIR17F,	   	 4)
/*		branch external (19)	   symbol + addend    		  */

RELOC_NUMBER (R_PARISC_DIR14R,	   	 6)
/*		load/store (1)		   RR(symbol, addend) 		  */

RELOC_NUMBER (R_PARISC_DIR14F,	   	 7)
/*		load/store (1)		   symbol, addend 		  */

/* PC-relative relocation types
   Typically used for calls.
   Note PCREL17C and PCREL17F differ only in overflow handling.
   PCREL17C never reports a relocation error.

   When supporting argument relocations, function calls must be
   accompanied by parameter relocation information.  This information is
   carried in the ten high-order bits of the addend field.  The remaining
   22 bits of of the addend field are sign-extended to form the Addend.

   Note the code to build argument relocations depends on the
   addend being zero.  A consequence of this limitation is GAS
   can not perform relocation reductions for function symbols.  */

RELOC_NUMBER (R_PARISC_PCREL12F,  	 8)
/*		op & branch (17)	   symbol - PC - 8 + addend    	  */

RELOC_NUMBER (R_PARISC_PCREL32,   	 9)
/*		32-bit word		   symbol - PC - 8 + addend    	  */

RELOC_NUMBER (R_PARISC_PCREL21L,  	10)
/*		long immediate (7)	   L(symbol - PC - 8 + addend) 	  */

RELOC_NUMBER (R_PARISC_PCREL17R,  	11)
/*		branch external (19)	   R(symbol - PC - 8 + addend) 	  */

RELOC_NUMBER (R_PARISC_PCREL17F,  	12)
/*		branch (20)		   symbol - PC - 8 + addend    	  */

RELOC_NUMBER (R_PARISC_PCREL17C,  	13)
/*		branch (20)		   symbol - PC - 8 + addend    	  */

RELOC_NUMBER (R_PARISC_PCREL14R,  	14)
/*		load/store (1)		   R(symbol - PC - 8 + addend) 	  */

RELOC_NUMBER (R_PARISC_PCREL14F,  	15)
/*		load/store (1)             symbol - PC - 8 + addend    	  */


/* DP-relative relocation types.  */
RELOC_NUMBER (R_PARISC_DPREL21L,  	18)
/*		long immediate (7)         LR(symbol - GP, addend)  	  */

RELOC_NUMBER (R_PARISC_DPREL14WR, 	19)
/*		load/store mod. comp. (2)  RR(symbol - GP, addend)  	  */

RELOC_NUMBER (R_PARISC_DPREL14DR, 	20)
/*		load/store doubleword (3)  RR(symbol - GP, addend)  	  */

RELOC_NUMBER (R_PARISC_DPREL14R,  	22)
/*		load/store (1)             RR(symbol - GP, addend)  	  */

RELOC_NUMBER (R_PARISC_DPREL14F,  	23)
/*		load/store (1)             symbol - GP + addend     	  */


/* Data linkage table (DLT) relocation types

   SOM DLT_REL fixup requests are used to for static data references
   from position-independent code within shared libraries.  They are
   similar to the GOT relocation types in some SVR4 implementations.  */

RELOC_NUMBER (R_PARISC_DLTREL21L,     	26)
/*		long immediate (7)         LR(symbol - GP, addend) 	  */

RELOC_NUMBER (R_PARISC_DLTREL14R,     	30)
/*		load/store (1)             RR(symbol - GP, addend) 	  */

RELOC_NUMBER (R_PARISC_DLTREL14F,     	31)
/*		load/store (1)             symbol - GP + addend    	  */


/* DLT indirect relocation types  */
RELOC_NUMBER (R_PARISC_DLTIND21L,     	34)
/*		long immediate (7)         L(ltoff(symbol + addend)) 	  */

RELOC_NUMBER (R_PARISC_DLTIND14R,     	38)
/*		load/store (1)             R(ltoff(symbol + addend)) 	  */

RELOC_NUMBER (R_PARISC_DLTIND14F,     	39)
/*		load/store (1)             ltoff(symbol + addend)    	  */


/* Base relative relocation types.  Ugh.  These imply lots of state */
RELOC_NUMBER (R_PARISC_SETBASE,       	40)
/*		none                       no reloc; base := sym     	  */

RELOC_NUMBER (R_PARISC_SECREL32,      	41)
/*		32-bit word                symbol - SECT + addend    	  */

RELOC_NUMBER (R_PARISC_BASEREL21L,    	42)
/*		long immediate (7)         LR(symbol - base, addend) 	  */

RELOC_NUMBER (R_PARISC_BASEREL17R,    	43)
/*		branch external (19)       RR(symbol - base, addend) 	  */

RELOC_NUMBER (R_PARISC_BASEREL17F,    	44)
/*		branch external (19)       symbol - base + addend    	  */

RELOC_NUMBER (R_PARISC_BASEREL14R,    	46)
/*		load/store (1)             RR(symbol - base, addend) 	  */

RELOC_NUMBER (R_PARISC_BASEREL14F,    	47)
/*		load/store (1)             symbol - base, addend     	  */


/* Segment relative relocation types.  */
RELOC_NUMBER (R_PARISC_SEGBASE,       	48)
/*		none                       no relocation; SB := sym  	  */

RELOC_NUMBER (R_PARISC_SEGREL32,      	49)
/*		32-bit word                symbol - SB + addend 	  */
  

/* Offsets from the PLT.  */  
RELOC_NUMBER (R_PARISC_PLTOFF21L,     	50)
/*		long immediate (7)         LR(pltoff(symbol), addend) 	  */

RELOC_NUMBER (R_PARISC_PLTOFF14R,     	54)
/*		load/store (1)             RR(pltoff(symbol), addend) 	  */

RELOC_NUMBER (R_PARISC_PLTOFF14F,     	55)
/*		load/store (1)             pltoff(symbol) + addend    	  */


RELOC_NUMBER (R_PARISC_LTOFF_FPTR32,  	57)
/*		32-bit word                ltoff(fptr(symbol+addend))     */

RELOC_NUMBER (R_PARISC_LTOFF_FPTR21L, 	58)
/*		long immediate (7)         L(ltoff(fptr(symbol+addend)))  */

RELOC_NUMBER (R_PARISC_LTOFF_FPTR14R, 	62)
/*		load/store (1)             R(ltoff(fptr(symbol+addend)))  */


RELOC_NUMBER (R_PARISC_FPTR64,        	64)
/*		64-bit doubleword          fptr(symbol+addend) 		  */


/* Plabel relocation types.  */	 
RELOC_NUMBER (R_PARISC_PLABEL32,      	65)
/*		32-bit word	  	   fptr(symbol) 		  */

RELOC_NUMBER (R_PARISC_PLABEL21L,     	66)
/*		long immediate (7)         L(fptr(symbol))		  */

RELOC_NUMBER (R_PARISC_PLABEL14R,     	70)
/*		load/store (1)             R(fptr(symbol))		  */

  
/* PCREL relocations.  */  
RELOC_NUMBER (R_PARISC_PCREL64,       	72)
/*		64-bit doubleword          symbol - PC - 8 + addend       */

RELOC_NUMBER (R_PARISC_PCREL22C,      	73)
/*		branch & link (21)         symbol - PC - 8 + addend       */

RELOC_NUMBER (R_PARISC_PCREL22F,      	74)
/*		branch & link (21)         symbol - PC - 8 + addend       */

RELOC_NUMBER (R_PARISC_PCREL14WR,     	75)
/*		load/store mod. comp. (2)  R(symbol - PC - 8 + addend)    */

RELOC_NUMBER (R_PARISC_PCREL14DR,     	76)
/*		load/store doubleword (3)  R(symbol - PC - 8 + addend)    */

RELOC_NUMBER (R_PARISC_PCREL16F,      	77)
/*		load/store (1)             symbol - PC - 8 + addend       */

RELOC_NUMBER (R_PARISC_PCREL16WF,     	78)
/*		load/store mod. comp. (2)  symbol - PC - 8 + addend       */

RELOC_NUMBER (R_PARISC_PCREL16DF,     	79)
/*		load/store doubleword (3)  symbol - PC - 8 + addend       */


RELOC_NUMBER (R_PARISC_DIR64,         	80)
/*		64-bit doubleword          symbol + addend    		  */

RELOC_NUMBER (R_PARISC_DIR64WR,       	81)
/*		64-bit doubleword          RR(symbol, addend) 		  */

RELOC_NUMBER (R_PARISC_DIR64DR,       	82)
/*		64-bit doubleword          RR(symbol, addend) 		  */

RELOC_NUMBER (R_PARISC_DIR14WR,       	83)
/*		load/store mod. comp. (2)  RR(symbol, addend) 		  */

RELOC_NUMBER (R_PARISC_DIR14DR,       	84)
/*		load/store doubleword (3)  RR(symbol, addend) 		  */

RELOC_NUMBER (R_PARISC_DIR16F,        	85)
/*		load/store (1)             symbol + addend    		  */

RELOC_NUMBER (R_PARISC_DIR16WF,       	86)
/*		load/store mod. comp. (2)  symbol + addend    		  */

RELOC_NUMBER (R_PARISC_DIR16DF,       	87)
/*		load/store doubleword (3)  symbol + addend    		  */
  
RELOC_NUMBER (R_PARISC_GPREL64,       	88)
/*		64-bit doubleword          symbol - GP + addend 	  */
  
RELOC_NUMBER (R_PARISC_DLTREL14WR,    	91)
/*		load/store mod. comp. (2)  RR(symbol - GP, addend) 	  */

RELOC_NUMBER (R_PARISC_DLTREL14DR,    	92)
/*		load/store doubleword (3)  RR(symbol - GP, addend) 	  */

RELOC_NUMBER (R_PARISC_GPREL16F,      	93)
/*		load/store (1)             symbol - GP + addend    	  */

RELOC_NUMBER (R_PARISC_GPREL16WF,     	94)
/*		load/store mod. comp. (2)  symbol - GP + addend    	  */

RELOC_NUMBER (R_PARISC_GPREL16DF,     	95)
/*		load/store doubleword (3)  symbol - GP + addend    	  */


RELOC_NUMBER (R_PARISC_LTOFF64,      	96)
/*		64-bit doubleword          ltoff(symbol + addend)    	  */

RELOC_NUMBER (R_PARISC_DLTIND14WR,   	99)
/*		load/store mod. comp. (2)  R(ltoff(symbol + addend)) 	  */

RELOC_NUMBER (R_PARISC_DLTIND14DR,     100)
/*		load/store doubleword (3)  R(ltoff(symbol + addend)) 	  */

RELOC_NUMBER (R_PARISC_LTOFF16F,       101)
/*		load/store (1)             ltoff(symbol + addend)    	  */

RELOC_NUMBER (R_PARISC_LTOFF16WF,      102)
/*		load/store mod. comp. (2)  ltoff(symbol + addend)    	  */

RELOC_NUMBER (R_PARISC_LTOFF16DF,      103)
/*		load/store doubleword (3)  ltoff(symbol + addend)    	  */


RELOC_NUMBER (R_PARISC_SECREL64,       104)
/*		64-bit doubleword          symbol - SECT + addend 	  */

RELOC_NUMBER (R_PARISC_BASEREL14WR,    107)
/*		load/store mod. comp. (2)  RR(symbol - base, addend) 	  */

RELOC_NUMBER (R_PARISC_BASEREL14DR,    108)
/*		load/store doubleword (3)  RR(symbol - base, addend) 	  */


RELOC_NUMBER (R_PARISC_SEGREL64,       112)
/*		64-bit doubleword          symbol - SB + addend 	  */
  
RELOC_NUMBER (R_PARISC_PLTOFF14WR,     115)
/*		load/store mod. comp. (2)  RR(pltoff(symbol), addend) 	  */

RELOC_NUMBER (R_PARISC_PLTOFF14DR,     116)    
/*		load/store doubleword (3)  RR(pltoff(symbol), addend) 	  */

RELOC_NUMBER (R_PARISC_PLTOFF16F,      117)    
/*		load/store (1)             pltoff(symbol) + addend    	  */

RELOC_NUMBER (R_PARISC_PLTOFF16WF,     118)    
/*		load/store mod. comp. (2)  pltoff(symbol) + addend    	  */

RELOC_NUMBER (R_PARISC_PLTOFF16DF,     119)    
/*		load/store doubleword (3)  pltoff(symbol) + addend    	  */


RELOC_NUMBER (R_PARISC_LTOFF_FPTR64,   120)
/*		64-bit doubleword          ltoff(fptr(symbol+addend))     */

RELOC_NUMBER (R_PARISC_LTOFF_FPTR14WR, 123)
/*		load/store mod. comp. (2)  R(ltoff(fptr(symbol+addend)))  */

RELOC_NUMBER (R_PARISC_LTOFF_FPTR14DR, 124)
/*		load/store doubleword (3)  R(ltoff(fptr(symbol+addend)))  */

RELOC_NUMBER (R_PARISC_LTOFF_FPTR16F,  125)
/*		load/store (1)             ltoff(fptr(symbol+addend))     */

RELOC_NUMBER (R_PARISC_LTOFF_FPTR16WF, 126)
/*		load/store mod. comp. (2)  ltoff(fptr(symbol+addend))     */

RELOC_NUMBER (R_PARISC_LTOFF_FPTR16DF, 127)
/*		load/store doubleword (3)  ltoff(fptr(symbol+addend))     */


RELOC_NUMBER (R_PARISC_COPY, 	       128)
/*		data                       Dynamic relocations only 	  */

RELOC_NUMBER (R_PARISC_IPLT, 	       129)
/*		plt                                                 	  */

RELOC_NUMBER (R_PARISC_EPLT, 	       130)
/*		plt                                                 	  */


RELOC_NUMBER (R_PARISC_TPREL32,        153)
/*		32-bit word                symbol - TP + addend    	  */

RELOC_NUMBER (R_PARISC_TPREL21L,       154)
/*		long immediate (7)         LR(symbol - TP, addend) 	  */

RELOC_NUMBER (R_PARISC_TPREL14R,       158)
/*		load/store (1)             RR(symbol - TP, addend) 	  */


RELOC_NUMBER (R_PARISC_LTOFF_TP21L,    162)
/*		long immediate (7)         L(ltoff(symbol - TP + addend)) */

RELOC_NUMBER (R_PARISC_LTOFF_TP14R,    166)
/*		load/store (1)             R(ltoff(symbol - TP + addend)) */

RELOC_NUMBER (R_PARISC_LTOFF_TP14F,    167)
/*		load/store (1)             ltoff(symbol - TP + addend)    */


RELOC_NUMBER (R_PARISC_TPREL64,        216)
/*		64-bit word                symbol - TP + addend        	  */

RELOC_NUMBER (R_PARISC_TPREL14WR,      219)    	  
/*		load/store mod. comp. (2)  RR(symbol - TP, addend)     	  */

RELOC_NUMBER (R_PARISC_TPREL14DR,      220)    	  
/*		load/store doubleword (3)  RR(symbol - TP, addend)     	  */

RELOC_NUMBER (R_PARISC_TPREL16F,       221)    	  
/*		load/store (1)             symbol - TP + addend        	  */

RELOC_NUMBER (R_PARISC_TPREL16WF,      222)    	  
/*		load/store mod. comp. (2)  symbol - TP + addend        	  */

RELOC_NUMBER (R_PARISC_TPREL16DF,      223)    	  
/*		load/store doubleword (3)  symbol - TP + addend        	  */


RELOC_NUMBER (R_PARISC_LTOFF_TP64,     224)
/*		64-bit doubleword          ltoff(symbol - TP + addend)    */

RELOC_NUMBER (R_PARISC_LTOFF_TP14WR,   227)
/*		load/store mod. comp. (2)  R(ltoff(symbol - TP + addend)) */

RELOC_NUMBER (R_PARISC_LTOFF_TP14DR,   228)
/*		load/store doubleword (3)  R(ltoff(symbol - TP + addend)) */

RELOC_NUMBER (R_PARISC_LTOFF_TP16F,    229)
/*		load/store (1)             ltoff(symbol - TP + addend)    */

RELOC_NUMBER (R_PARISC_LTOFF_TP16WF,   230)
/*		load/store mod. comp. (2)  ltoff(symbol - TP + addend)    */

RELOC_NUMBER (R_PARISC_LTOFF_TP16DF,   231)
/*		load/store doubleword (3)  ltoff(symbol - TP + addend)    */

RELOC_NUMBER (R_PARISC_GNU_VTENTRY,    232)
RELOC_NUMBER (R_PARISC_GNU_VTINHERIT,  233)

END_RELOC_NUMBERS (R_PARISC_UNIMPLEMENTED)
d291 13
a303 16
/* Arggh.  HP's tools define these symbols based on the
   old value of DT_LOOS.  So we must do the same to be
   compatible.  */
#define DT_HP_LOAD_MAP		(OLD_DT_LOOS + 0x0)
#define DT_HP_DLD_FLAGS		(OLD_DT_LOOS + 0x1)
#define DT_HP_DLD_HOOK		(OLD_DT_LOOS + 0x2)
#define DT_HP_UX10_INIT		(OLD_DT_LOOS + 0x3)
#define DT_HP_UX10_INITSZ	(OLD_DT_LOOS + 0x4)
#define DT_HP_PREINIT		(OLD_DT_LOOS + 0x5)
#define DT_HP_PREINITSZ		(OLD_DT_LOOS + 0x6)
#define DT_HP_NEEDED		(OLD_DT_LOOS + 0x7)
#define DT_HP_TIME_STAMP	(OLD_DT_LOOS + 0x8)
#define DT_HP_CHECKSUM		(OLD_DT_LOOS + 0x9)
#define DT_HP_GST_SIZE		(OLD_DT_LOOS + 0xa)
#define DT_HP_GST_VERSION	(OLD_DT_LOOS + 0xb)
#define DT_HP_GST_HASHVAL	(OLD_DT_LOOS + 0xc)
@


