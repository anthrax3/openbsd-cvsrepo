head	1.7;
access;
symbols
	OPENBSD_6_0:1.7.0.50
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.46
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.48
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.40
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.44
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.42
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.38
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.36
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.34
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.32
	OPENBSD_5_0:1.7.0.30
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.28
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.26
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.22
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.24
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.20
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.18
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.16
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.14
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.12
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.10
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.8
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS-960607:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.05.17.21.54.49;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.40;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.22.26.08;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.12.36;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.08.18;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.53.42;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.08.20;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.08.20;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.07.11.07.35;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.41.50;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.26.52;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.47.39;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.53.19;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.37;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@/* coff information for Renesas SH
   
   Copyright 2001, 2003 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifdef COFF_WITH_PE
#define L_LNNO_SIZE 2
#else
#define L_LNNO_SIZE 4
#endif
#define INCLUDE_COMDAT_FIELDS_IN_AUXENT
#include "coff/external.h"

#define	SH_ARCH_MAGIC_BIG	0x0500
#define	SH_ARCH_MAGIC_LITTLE	0x0550  /* Little endian SH */
#define SH_ARCH_MAGIC_WINCE	0x01a2  /* Windows CE - little endian */
#define SH_PE_MAGIC		0x010b

#define SHBADMAG(x) \
 (((x).f_magic != SH_ARCH_MAGIC_BIG) && \
  ((x).f_magic != SH_ARCH_MAGIC_WINCE) && \
  ((x).f_magic != SH_ARCH_MAGIC_LITTLE))

/* Define some NT default values.  */
/*  #define NT_IMAGE_BASE        0x400000 moved to internal.h */
#define NT_SECTION_ALIGNMENT 0x1000
#define NT_FILE_ALIGNMENT    0x200
#define NT_DEF_RESERVE       0x100000
#define NT_DEF_COMMIT        0x1000

/********************** RELOCATION DIRECTIVES **********************/

/* The external reloc has an offset field, because some of the reloc
   types on the h8 don't have room in the instruction for the entire
   offset - eg the strange jump and high page addressing modes.  */

#ifndef COFF_WITH_PE
struct external_reloc
{
  char r_vaddr[4];
  char r_symndx[4];
  char r_offset[4];
  char r_type[2];
  char r_stuff[2];
};
#else
struct external_reloc
{
  char r_vaddr[4];
  char r_symndx[4];
  char r_type[2];
};
#endif

#define RELOC struct external_reloc
#ifdef COFF_WITH_PE
#define RELSZ 10
#else
#define RELSZ 16
#endif

/* SH relocation types.  Not all of these are actually used.  */

#define R_SH_UNUSED	0		/* only used internally */
#define R_SH_IMM32CE	2		/* 32 bit immediate for WinCE */
#define R_SH_PCREL8 	3		/*  8 bit pcrel 	*/
#define R_SH_PCREL16 	4		/* 16 bit pcrel 	*/
#define R_SH_HIGH8  	5		/* high 8 bits of 24 bit address */
#define R_SH_LOW16 	7		/* low 16 bits of 24 bit immediate */
#define R_SH_IMM24	6		/* 24 bit immediate */
#define R_SH_PCDISP8BY4	9  		/* PC rel 8 bits *4 +ve */
#define R_SH_PCDISP8BY2	10  		/* PC rel 8 bits *2 +ve */
#define R_SH_PCDISP8    11  		/* 8 bit branch */
#define R_SH_PCDISP     12  		/* 12 bit branch */
#define R_SH_IMM32      14    		/* 32 bit immediate */
#define R_SH_IMM8   	16		/* 8 bit immediate */
#define R_SH_IMAGEBASE	16		/* Windows CE */
#define R_SH_IMM8BY2    17		/* 8 bit immediate *2 */
#define R_SH_IMM8BY4    18		/* 8 bit immediate *4 */
#define R_SH_IMM4   	19		/* 4 bit immediate */
#define R_SH_IMM4BY2    20		/* 4 bit immediate *2 */
#define R_SH_IMM4BY4    21		/* 4 bit immediate *4 */
#define R_SH_PCRELIMM8BY2   22		/* PC rel 8 bits *2 unsigned */
#define R_SH_PCRELIMM8BY4   23		/* PC rel 8 bits *4 unsigned */
#define R_SH_IMM16      24    		/* 16 bit immediate */

/* The switch table reloc types are used for relaxing.  They are
   generated for expressions such as
     .word L1 - L2
   The r_offset field holds the difference between the reloc address
   and L2.  */
#define R_SH_SWITCH8	33		/* 8 bit switch table entry */
#define R_SH_SWITCH16	25		/* 16 bit switch table entry */
#define R_SH_SWITCH32	26		/* 32 bit switch table entry */

/* The USES reloc type is used for relaxing.  The compiler will
   generate .uses pseudo-ops when it finds a function call which it
   can relax.  The r_offset field of the USES reloc holds the PC
   relative offset to the instruction which loads the register used in
   the function call.  */
#define R_SH_USES	27		/* .uses pseudo-op */

/* The COUNT reloc type is used for relaxing.  The assembler will
   generate COUNT relocs for addresses referred to by the register
   loads associated with USES relocs.  The r_offset field of the COUNT
   reloc holds the number of times the address is referenced in the
   object file.  */
#define R_SH_COUNT	28		/* Count of constant pool uses */

/* The ALIGN reloc type is used for relaxing.  The r_offset field is
   the power of two to which subsequent portions of the object file
   must be aligned.  */
#define R_SH_ALIGN	29		/* .align pseudo-op */

/* The CODE and DATA reloc types are used for aligning load and store
   instructions.  The assembler will generate a CODE reloc before a
   block of instructions.  It will generate a DATA reloc before data.
   A section should be processed assuming it contains data, unless a
   CODE reloc is seen.  The only relevant pieces of information in the
   CODE and DATA relocs are the section and the address.  The symbol
   and offset are meaningless.  */
#define R_SH_CODE	30		/* start of code */
#define R_SH_DATA	31		/* start of data */

/* The LABEL reloc type is used for aligning load and store
   instructions.  The assembler will generate a LABEL reloc for each
   label within a block of instructions.  This permits the linker to
   avoid swapping instructions which are the targets of branches.  */
#define R_SH_LABEL	32		/* label */

/* NB: R_SH_SWITCH8 is 33 */

#define R_SH_LOOP_START	34
#define R_SH_LOOP_END	35
@


1.6
log
@resolve conflicts.
@
text
@d1 1
a1 1
/* coff information for Hitachi SH
d3 1
a3 1
   Copyright 2001 Free Software Foundation, Inc.
d19 7
a25 13
/********************** FILE HEADER **********************/

struct external_filehdr {
	char f_magic[2];	/* magic number			*/
	char f_nscns[2];	/* number of sections		*/
	char f_timdat[4];	/* time & date stamp		*/
	char f_symptr[4];	/* file pointer to symtab	*/
	char f_nsyms[4];	/* number of symtab entries	*/
	char f_opthdr[2];	/* sizeof(optional hdr)		*/
	char f_flags[2];	/* flags			*/
};


a31 1

d33 3
a35 29
 (((x).f_magic!=SH_ARCH_MAGIC_BIG) && \
  ((x).f_magic!=SH_ARCH_MAGIC_WINCE) && \
  ((x).f_magic!=SH_ARCH_MAGIC_LITTLE))

#define	FILHDR	struct external_filehdr
#define	FILHSZ	20


/********************** AOUT "OPTIONAL HEADER" **********************/


typedef struct 
{
  char 	magic[2];		/* type of file				*/
  char	vstamp[2];		/* version stamp			*/
  char	tsize[4];		/* text size in bytes, padded to FW bdry*/
  char	dsize[4];		/* initialized data "  "		*/
  char	bsize[4];		/* uninitialized data "   "		*/
  char	entry[4];		/* entry pt.				*/
  char 	text_start[4];		/* base of text used for this file */
  char 	data_start[4];		/* base of data used for this file */
}
AOUTHDR;


#define AOUTHDRSZ 28
#define AOUTSZ 28


a43 147
/********************** SECTION HEADER **********************/


struct external_scnhdr {
	char		s_name[8];	/* section name			*/
	char		s_paddr[4];	/* physical address, aliased s_nlib */
	char		s_vaddr[4];	/* virtual address		*/
	char		s_size[4];	/* section size			*/
	char		s_scnptr[4];	/* file ptr to raw data for section */
	char		s_relptr[4];	/* file ptr to relocation	*/
	char		s_lnnoptr[4];	/* file ptr to line numbers	*/
	char		s_nreloc[2];	/* number of relocation entries	*/
	char		s_nlnno[2];	/* number of line number entries*/
	char		s_flags[4];	/* flags			*/
};

/*
 * names of "special" sections
 */
#define _TEXT	".text"
#define _DATA	".data"
#define _BSS	".bss"


#define	SCNHDR	struct external_scnhdr
#define	SCNHSZ	40


/********************** LINE NUMBERS **********************/

/* 1 line number entry for every "breakpointable" source line in a section.
 * Line numbers are grouped on a per function basis; first entry in a function
 * grouping will have l_lnno = 0 and in place of physical address will be the
 * symbol table index of the function name.
 */
struct external_lineno {
	union {
		char l_symndx[4];	/* function name symbol index, iff l_lnno == 0*/
		char l_paddr[4];	/* (physical) address of line number	*/
	} l_addr;
#ifdef COFF_WITH_PE
	char l_lnno[2];	/* line number		*/
#else
	char l_lnno[4];	/* line number		*/
#endif
};

#define GET_LINENO_LNNO(abfd, ext) bfd_h_get_32(abfd, (bfd_byte *) (ext->l_lnno));
#define PUT_LINENO_LNNO(abfd,val, ext) bfd_h_put_32(abfd,val,  (bfd_byte *) (ext->l_lnno));

#define	LINENO	struct external_lineno
#ifdef COFF_WITH_PE
#define	LINESZ	6
#undef GET_LINENO_LNNO
#define GET_LINENO_LNNO(abfd, ext) bfd_h_get_16(abfd, (bfd_byte *) (ext->l_lnno));
#undef PUT_LINENO_LNNO
#define PUT_LINENO_LNNO(abfd,val, ext) bfd_h_put_16(abfd,val,  (bfd_byte *) (ext->l_lnno));
#else
#define	LINESZ	8
#endif


/********************** SYMBOLS **********************/

#define E_SYMNMLEN	8	/* # characters in a symbol name	*/
#define E_FILNMLEN	14	/* # characters in a file name		*/
#define E_DIMNUM	4	/* # array dimensions in auxiliary entry */

struct external_syment 
{
  union {
    char e_name[E_SYMNMLEN];
    struct {
      char e_zeroes[4];
      char e_offset[4];
    } e;
  } e;
  char e_value[4];
  char e_scnum[2];
  char e_type[2];
  char e_sclass[1];
  char e_numaux[1];
};



#define N_BTMASK	(017)
#define N_TMASK		(060)
#define N_BTSHFT	(4)
#define N_TSHIFT	(2)
  

union external_auxent {
	struct {
		char x_tagndx[4];	/* str, un, or enum tag indx */
		union {
			struct {
			    char  x_lnno[2]; /* declaration line number */
			    char  x_size[2]; /* str/union/array size */
			} x_lnsz;
			char x_fsize[4];	/* size of function */
		} x_misc;
		union {
			struct {		/* if ISFCN, tag, or .bb */
			    char x_lnnoptr[4];	/* ptr to fcn line # */
			    char x_endndx[4];	/* entry ndx past block end */
			} x_fcn;
			struct {		/* if ISARY, up to 4 dimen. */
			    char x_dimen[E_DIMNUM][2];
			} x_ary;
		} x_fcnary;
		char x_tvndx[2];		/* tv index */
	} x_sym;

	union {
		char x_fname[E_FILNMLEN];
		struct {
			char x_zeroes[4];
			char x_offset[4];
		} x_n;
	} x_file;

	struct {
		char x_scnlen[4];			/* section length */
		char x_nreloc[2];	/* # relocation entries */
		char x_nlinno[2];	/* # line numbers */
		char x_checksum[4];	/* section COMDAT checksum */
		char x_associated[2];	/* COMDAT associated section index */
		char x_comdat[1];	/* COMDAT selection number */
	} x_scn;

        struct {
		char x_tvfill[4];	/* tv fill value */
		char x_tvlen[2];	/* length of .tv */
		char x_tvran[2][2];	/* tv range */
	} x_tv;		/* info about .tv section (in auxent of symbol .tv)) */


};

#define	SYMENT	struct external_syment
#define	SYMESZ	18	
#define	AUXENT	union external_auxent
#define	AUXESZ	18



d48 1
a48 1
   offset - eg the strange jump and high page addressing modes */
d51 2
a52 1
struct external_reloc {
d60 2
a61 1
struct external_reloc {
a66 1

@


1.5
log
@Resolve other problems that dumb cvs can't find out by itself.

(trivial part done, `interesting' patches remain)
@
text
@d1 17
a17 1
/*** coff information for Hitachi SH */
d324 3
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d270 1
a270 1
#define R_SH_SWITCH32	26		/* 16 bit switch table entry */
d282 1
a282 1
   reloc holds the number of times the address is references in the
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d19 2
d25 1
d54 6
d101 3
d105 1
d112 7
d120 1
d187 3
d214 1
d222 7
d232 3
d236 1
d241 1
d253 1
d268 1
d306 2
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d26 1
a26 1
#define	FILHSZ	sizeof(FILHDR)
d46 2
a47 2
#define AOUTHDRSZ (sizeof(AOUTHDR))
#define AOUTSZ (sizeof(AOUTHDR))
d77 1
a77 1
#define	SCNHSZ	sizeof(SCNHDR)
d99 1
a99 1
#define	LINESZ	sizeof(LINENO) 
@


1.1
log
@Initial revision
@
text
@d252 9
d262 5
a266 1

@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@(Correct) Import of Cygnus binutils snapshot taken 960607
@
text
@a251 9
/* The CODE and DATA reloc types are used for aligning load and store
   instructions.  The assembler will generate a CODE reloc before a
   block of instructions.  It will generate a DATA reloc before data.
   A section should be processed assuming it contains data, unless a
   CODE reloc is seen.  The only relevant pieces of information in the
   CODE and DATA relocs are the section and the address.  The symbol
   and offset are meaningless.  */
#define R_SH_CODE	30		/* start of code */
#define R_SH_DATA	31		/* start of data */
d253 1
a253 5
/* The LABEL reloc type is used for aligning load and store
   instructions.  The assembler will generate a LABEL reloc for each
   label within a block of instructions.  This permits the linker to
   avoid swapping instructions which are the targets of branches.  */
#define R_SH_LABEL	32		/* label */
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d26 1
a26 1
#define	FILHSZ	20
d46 2
a47 2
#define AOUTHDRSZ 28
#define AOUTSZ 28
d77 1
a77 1
#define	SCNHSZ	40
d99 1
a99 1
#define	LINESZ	8
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d231 1
a231 1
#define R_SH_SWITCH32	26		/* 32 bit switch table entry */
d243 1
a243 1
   reloc holds the number of times the address is referenced in the
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@a18 2
#define SH_ARCH_MAGIC_WINCE	0x01a2  /* Windows CE - little endian */
#define SH_PE_MAGIC		0x010b
a22 1
  ((x).f_magic!=SH_ARCH_MAGIC_WINCE) && \
a50 6
/* Define some NT default values.  */
/*  #define NT_IMAGE_BASE        0x400000 moved to internal.h */
#define NT_SECTION_ALIGNMENT 0x1000
#define NT_FILE_ALIGNMENT    0x200
#define NT_DEF_RESERVE       0x100000
#define NT_DEF_COMMIT        0x1000
a91 3
#ifdef COFF_WITH_PE
	char l_lnno[2];	/* line number		*/
#else
a92 1
#endif
a98 7
#ifdef COFF_WITH_PE
#define	LINESZ	6
#undef GET_LINENO_LNNO
#define GET_LINENO_LNNO(abfd, ext) bfd_h_get_16(abfd, (bfd_byte *) (ext->l_lnno));
#undef PUT_LINENO_LNNO
#define PUT_LINENO_LNNO(abfd,val, ext) bfd_h_put_16(abfd,val,  (bfd_byte *) (ext->l_lnno));
#else
a99 1
#endif
a165 3
		char x_checksum[4];	/* section COMDAT checksum */
		char x_associated[2];	/* COMDAT associated section index */
		char x_comdat[1];	/* COMDAT selection number */
a189 1
#ifndef COFF_WITH_PE
a196 7
#else
struct external_reloc {
  char r_vaddr[4];
  char r_symndx[4];
  char r_type[2];
};
#endif
a199 3
#ifdef COFF_WITH_PE
#define RELSZ 10
#else
a200 1
#endif
a204 1
#define R_SH_IMM32CE	2		/* 32 bit immediate for WinCE */
a215 1
#define R_SH_IMAGEBASE	16		/* Windows CE */
a229 1
#define R_SH_SWITCH8	33		/* 8 bit switch table entry */
a266 2

/* NB: R_SH_SWITCH8 is 33 */
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d1 1
a1 17
/* coff information for Hitachi SH
   
   Copyright 2001 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a307 3

#define R_SH_LOOP_START	34
#define R_SH_LOOP_END	35
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d1 1
a1 1
/* coff information for Renesas SH
d3 1
a3 1
   Copyright 2001, 2003 Free Software Foundation, Inc.
d19 13
a31 7
#ifdef COFF_WITH_PE
#define L_LNNO_SIZE 2
#else
#define L_LNNO_SIZE 4
#endif
#define INCLUDE_COMDAT_FIELDS_IN_AUXENT
#include "coff/external.h"
d38 1
d40 29
a68 3
 (((x).f_magic != SH_ARCH_MAGIC_BIG) && \
  ((x).f_magic != SH_ARCH_MAGIC_WINCE) && \
  ((x).f_magic != SH_ARCH_MAGIC_LITTLE))
d77 147
d228 1
a228 1
   offset - eg the strange jump and high page addressing modes.  */
d231 1
a231 2
struct external_reloc
{
d239 1
a239 2
struct external_reloc
{
d245 1
@


