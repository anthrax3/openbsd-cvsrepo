head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.62
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.58
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.54
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.56
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.48
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.52
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.50
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.46
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.44
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.42
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.40
	OPENBSD_5_0:1.2.0.38
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.36
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.34
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.30
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.32
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.28
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.26
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.24
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.22
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.20
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.18
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.16
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.14
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.12
	OPENBSD_3_7_BASE:1.2
	BINUTILS_2_15:1.1.1.2
	OPENBSD_3_6:1.2.0.10
	OPENBSD_3_6_BASE:1.2
	BINUTILS-2_14:1.1.1.2
	OPENBSD_3_5:1.2.0.8
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.6
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	binutils-2_11_2:1.1.1.2
	OPENBSD_3_1:1.1.0.26
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.24
	OPENBSD_3_0_BASE:1.1
	BINUTILS-2_10_1:1.1.1.1
	OPENBSD_2_9:1.1.0.22
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_8:1.1.0.20
	OPENBSD_2_8_BASE:1.1
	BINUTILS-2_10:1.1.1.1
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS-960607:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2002.05.13.17.07.40;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.08.13;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.08.13;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.05.13.13.52.53;	author fgsch;	state Exp;
branches;
next	;


desc
@@


1.2
log
@resolve conflicts.
@
text
@/* os9k.h  -  OS-9000 i386 module header definitions
   Copyright 2000 Free Software Foundation, Inc.

This file is part of GNU CC.
   
GNU CC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU CC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU CC; see the file COPYING.  If not, write to
the Free Software Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */

#if !defined(_MODULE_H)
#define _MODULE_H

#define _MPF386

/* Size of common header less parity field.  */
#define N_M_PARITY  (sizeof(mh_com)-sizeof(unisgned short))
#define OLD_M_PARITY 46
#define M_PARITY N_M_PARITY

#ifdef _MPF68K
#define MODSYNC 0x4afc		/* Module header sync code for 680x0 processors.  */
#endif

#ifdef _MPF386
#define MODSYNC 0x4afc		/* Module header sync code for 80386 processors.  */
#endif

#define MODREV	1		/* Module format revision 1.  */
#define CRCCON	0x800063	/* CRC polynomial constant.  */

/* Module access permission values.  */
#define MP_OWNER_READ	0x0001
#define MP_OWNER_WRITE	0x0002
#define MP_OWNER_EXEC	0x0004
#define MP_GROUP_READ	0x0010
#define MP_GROUP_WRITE	0x0020
#define MP_GROUP_EXEC	0x0040
#define MP_WORLD_READ	0x0100
#define MP_WORLD_WRITE	0x0200
#define MP_WORLD_EXEC	0x0400
#define MP_WORLD_ACCESS	0x0777
#define MP_OWNER_MASK	0x000f
#define MP_GROUP_MASK	0x00f0
#define MP_WORLD_MASK	0x0f00
#define MP_SYSTM_MASK	0xf000

/* Module Type/Language values.  */
#define MT_ANY		0
#define MT_PROGRAM	0x0001
#define MT_SUBROUT	0x0002
#define MT_MULTI	0x0003
#define MT_DATA		0x0004
#define MT_TRAPLIB	0x000b
#define MT_SYSTEM	0x000c
#define MT_FILEMAN	0x000d
#define MT_DEVDRVR	0x000e 
#define MT_DEVDESC	0x000f
#define MT_MASK		0xff00

#define ML_ANY		0
#define ML_OBJECT	1
#define ML_ICODE	2
#define ML_PCODE	3
#define ML_CCODE	4
#define ML_CBLCODE	5
#define ML_FRTNCODE	6
#define ML_MASK		0x00ff

#define mktypelang(type, lang)	(((type) << 8) | (lang))

/* Module Attribute values.  */
#define MA_REENT	0x80
#define MA_GHOST	0x40
#define MA_SUPER	0x20
#define MA_MASK		0xff00
#define MR_MASK		0x00ff

#define mkattrevs(attr, revs)	(((attr) << 8) | (revs))

#define m_user 		m_owner.grp_usr.usr
#define m_group 	m_owner.grp_usr.grp
#define m_group_user	m_owner.group_user

/* Macro definitions for accessing module header fields.  */
#define MODNAME(mod) ((u_char*)((u_char*)mod + ((Mh_com)mod)->m_name))
#if 0
/* Appears not to be used, and the u_int32 typedef is gone (because it
   conflicted with a Mach header.  */
#define MODSIZE(mod) ((u_int32)((Mh_com)mod)->m_size)
#endif /* 0 */
#define MHCOM_BYTES_SIZE 80
#define N_BADMAG(a) (((a).a_info) != MODSYNC)

typedef struct mh_com
{
  /* Sync bytes ($4afc).  */
  unsigned char m_sync[2];
  unsigned char m_sysrev[2];	/* System revision check value.  */
  unsigned char m_size[4];	/* Module size.  */
  unsigned char m_owner[4];	/* Group/user id.  */
  unsigned char m_name[4];	/* Offset to module name.  */
  unsigned char m_access[2];	/* Access permissions.  */
  unsigned char m_tylan[2];	/* Type/lang.  */
  unsigned char m_attrev[2];	/* Rev/attr.  */
  unsigned char m_edit[2];	/* Edition.  */
  unsigned char m_needs[4];	/* Module hardware requirements flags. (reserved).  */
  unsigned char m_usage[4];	/* Comment string offset.  */
  unsigned char m_symbol[4];	/* Symbol table offset.  */
  unsigned char m_exec[4];	/* Offset to execution entry point.  */
  unsigned char m_excpt[4];	/* Offset to exception entry point.  */
  unsigned char m_data[4];	/* Data storage requirement.  */
  unsigned char m_stack[4];	/* Stack size.  */
  unsigned char m_idata[4];	/* Offset to initialized data.  */
  unsigned char m_idref[4];	/* Offset to data reference lists.  */
  unsigned char m_init[4];	/* Initialization routine offset.  */
  unsigned char m_term[4];	/* Termination routine offset.  */
  unsigned char m_ident[2];	/* Ident code for ident program.  */
  char          m_spare[8];	/* Reserved bytes.  */
  unsigned char m_parity[2]; 	/* Header parity.  */
} mh_com,*Mh_com;

/* Executable memory module.  */
typedef mh_com *Mh_exec,mh_exec;

/* Data memory module.  */
typedef mh_com *Mh_data,mh_data;

/* File manager memory module.  */
typedef mh_com *Mh_fman,mh_fman;

/* Device driver module.  */
typedef mh_com *Mh_drvr,mh_drvr;

/* Trap handler module.  */
typedef	mh_com mh_trap, *Mh_trap;

/* Device descriptor module.  */
typedef	mh_com *Mh_dev,mh_dev;

/* Configuration module.  */
typedef mh_com *Mh_config, mh_config;

#if 0 

#if !defined(_MODDIR_H)
/* Go get _os_fmod (and others).  */
#include <moddir.h>
#endif

error_code _os_crc (void *, u_int32, int *);
error_code _os_datmod (char *, u_int32, u_int16 *, u_int16 *, u_int32, void **, mh_data **);
error_code _os_get_moddir (void *, u_int32 *);
error_code _os_initdata (mh_com *, void *);
error_code _os_link (char **, mh_com **, void **, u_int16 *, u_int16 *);
error_code _os_linkm (mh_com *, void **, u_int16 *, u_int16 *);
error_code _os_load (char *, mh_com **, void **, u_int32, u_int16 *, u_int16 *, u_int32);
error_code _os_mkmodule (char *, u_int32, u_int16 *, u_int16 *, u_int32, void **, mh_com **, u_int32);
error_code _os_modaddr (void *, mh_com **);
error_code _os_setcrc (mh_com *);
error_code _os_slink (u_int32, char *, void **, void **, mh_com **);
error_code _os_slinkm (u_int32, mh_com *, void **, void **);
error_code _os_unlink (mh_com *);
error_code _os_unload (char *, u_int32);
error_code _os_tlink (u_int32, char *, void **, mh_trap **, void *, u_int32);
error_code _os_tlinkm (u_int32, mh_com *, void **, void *, u_int32);
error_code _os_iodel (mh_com *);
error_code _os_vmodul (mh_com *, mh_com *, u_int32);
#endif /* 0 */

#endif
@


1.1
log
@Initial revision
@
text
@d1 20
a23 1
/* OS-9000 i386 module header definitions */
d26 1
a26 1
/* sizeof common header less parity field */
d32 1
a32 1
#define MODSYNC 0x4afd      /* module header sync code for 680x0 processors */
d36 1
a36 1
#define MODSYNC 0x4afc      /* module header sync code for 80386 processors */
d39 2
a40 2
#define MODREV	1			/* module format revision 1 */
#define CRCCON	0x800fe3	/* crc polynomial constant */
d42 1
a42 1
/* Module access permission values */
d58 1
a58 1
/* Module Type/Language values */
d80 1
a80 1
#define mktypelang(type,lang)	(((type)<<8)|(lang))
d82 1
a82 1
/* Module Attribute values */
d89 1
a89 1
#define mkattrevs(attr, revs)	(((attr)<<8)|(revs))
d91 3
a93 3
#define m_user m_owner.grp_usr.usr
#define m_group m_owner.grp_usr.grp
#define m_group_user m_owner.group_user
d95 1
a95 1
/* macro definitions for accessing module header fields */
d105 3
a107 2
typedef struct mh_com {
  /* sync bytes ($4afc).  */
d109 22
a130 30
  unsigned char m_sysrev[2];		/* system revision check value */
  unsigned char
    m_size[4];			/* module size */
  unsigned char
    m_owner[4];		/* group/user id */
  unsigned char
    m_name[4];			/* offset to module name */
  unsigned char
    m_access[2],		/* access permissions */
    m_tylan[2],		/* type/lang */
    m_attrev[2],		/* rev/attr */
    m_edit[2];			/* edition */
  unsigned char
    m_needs[4],		/* module hardware requirements flags. (reserved) */
    m_usage[4],		/* comment string offset */
    m_symbol[4],		/* symbol table offset */
    m_exec[4],			/* offset to execution entry point */
    m_excpt[4],		/* offset to exception entry point */
    m_data[4],			/* data storage requirement */
    m_stack[4],		/* stack size */
    m_idata[4],		/* offset to initialized data */
    m_idref[4],		/* offset to data reference lists */
    m_init[4],			/* initialization routine offset */
    m_term[4];			/* termination routine offset */
  unsigned char
    m_ident[2];		/* ident code for ident program */
  char
    m_spare[8];	/* reserved bytes */
  unsigned char
    m_parity[2]; 		/* header parity */
d133 1
a133 1
/* Executable memory module */
d136 1
a136 1
/* Data memory module */
d139 1
a139 1
/* File manager memory module */
d142 1
a142 1
/* device driver module */
d145 1
a145 1
/* trap handler module */
d148 1
a148 1
/* Device descriptor module */
d151 1
a151 1
/* Configuration module */
d157 1
a157 1
/* go get _os_fmod (and others) */
d161 18
a178 18
error_code _os_crc(void *, u_int32, int *);
error_code _os_datmod(char *, u_int32, u_int16 *, u_int16 *, u_int32, void **, mh_data **);
error_code _os_get_moddir(void *, u_int32 *);
error_code _os_initdata(mh_com *, void *);
error_code _os_link(char **, mh_com **, void **, u_int16 *, u_int16 *);
error_code _os_linkm(mh_com *, void **, u_int16 *, u_int16 *);
error_code _os_load(char *, mh_com **, void **, u_int32, u_int16 *, u_int16 *, u_int32);
error_code _os_mkmodule(char *, u_int32, u_int16 *, u_int16 *, u_int32, void **, mh_com **, u_int32);
error_code _os_modaddr(void *, mh_com **);
error_code _os_setcrc(mh_com *);
error_code _os_slink(u_int32, char *, void **, void **, mh_com **);
error_code _os_slinkm(u_int32, mh_com *, void **, void **);
error_code _os_unlink(mh_com *);
error_code _os_unload(char *, u_int32);
error_code _os_tlink(u_int32, char *, void **, mh_trap **, void *, u_int32);
error_code _os_tlinkm(u_int32, mh_com *, void **, void *, u_int32);
error_code _os_iodel(mh_com *);
error_code _os_vmodul(mh_com *, mh_com *, u_int32);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@a0 20
/* os9k.h  -  OS-9000 i386 module header definitions
   Copyright 2000 Free Software Foundation, Inc.

This file is part of GNU CC.
   
GNU CC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU CC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU CC; see the file COPYING.  If not, write to
the Free Software Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */

d4 1
d7 1
a7 1
/* Size of common header less parity field.  */
d13 1
a13 1
#define MODSYNC 0x4afc		/* Module header sync code for 680x0 processors.  */
d17 1
a17 1
#define MODSYNC 0x4afc		/* Module header sync code for 80386 processors.  */
d20 2
a21 2
#define MODREV	1		/* Module format revision 1.  */
#define CRCCON	0x800063	/* CRC polynomial constant.  */
d23 1
a23 1
/* Module access permission values.  */
d39 1
a39 1
/* Module Type/Language values.  */
d61 1
a61 1
#define mktypelang(type, lang)	(((type) << 8) | (lang))
d63 1
a63 1
/* Module Attribute values.  */
d70 1
a70 1
#define mkattrevs(attr, revs)	(((attr) << 8) | (revs))
d72 3
a74 3
#define m_user 		m_owner.grp_usr.usr
#define m_group 	m_owner.grp_usr.grp
#define m_group_user	m_owner.group_user
d76 1
a76 1
/* Macro definitions for accessing module header fields.  */
d86 2
a87 3
typedef struct mh_com
{
  /* Sync bytes ($4afc).  */
d89 30
a118 22
  unsigned char m_sysrev[2];	/* System revision check value.  */
  unsigned char m_size[4];	/* Module size.  */
  unsigned char m_owner[4];	/* Group/user id.  */
  unsigned char m_name[4];	/* Offset to module name.  */
  unsigned char m_access[2];	/* Access permissions.  */
  unsigned char m_tylan[2];	/* Type/lang.  */
  unsigned char m_attrev[2];	/* Rev/attr.  */
  unsigned char m_edit[2];	/* Edition.  */
  unsigned char m_needs[4];	/* Module hardware requirements flags. (reserved).  */
  unsigned char m_usage[4];	/* Comment string offset.  */
  unsigned char m_symbol[4];	/* Symbol table offset.  */
  unsigned char m_exec[4];	/* Offset to execution entry point.  */
  unsigned char m_excpt[4];	/* Offset to exception entry point.  */
  unsigned char m_data[4];	/* Data storage requirement.  */
  unsigned char m_stack[4];	/* Stack size.  */
  unsigned char m_idata[4];	/* Offset to initialized data.  */
  unsigned char m_idref[4];	/* Offset to data reference lists.  */
  unsigned char m_init[4];	/* Initialization routine offset.  */
  unsigned char m_term[4];	/* Termination routine offset.  */
  unsigned char m_ident[2];	/* Ident code for ident program.  */
  char          m_spare[8];	/* Reserved bytes.  */
  unsigned char m_parity[2]; 	/* Header parity.  */
d121 1
a121 1
/* Executable memory module.  */
d124 1
a124 1
/* Data memory module.  */
d127 1
a127 1
/* File manager memory module.  */
d130 1
a130 1
/* Device driver module.  */
d133 1
a133 1
/* Trap handler module.  */
d136 1
a136 1
/* Device descriptor module.  */
d139 1
a139 1
/* Configuration module.  */
d145 1
a145 1
/* Go get _os_fmod (and others).  */
d149 18
a166 18
error_code _os_crc (void *, u_int32, int *);
error_code _os_datmod (char *, u_int32, u_int16 *, u_int16 *, u_int32, void **, mh_data **);
error_code _os_get_moddir (void *, u_int32 *);
error_code _os_initdata (mh_com *, void *);
error_code _os_link (char **, mh_com **, void **, u_int16 *, u_int16 *);
error_code _os_linkm (mh_com *, void **, u_int16 *, u_int16 *);
error_code _os_load (char *, mh_com **, void **, u_int32, u_int16 *, u_int16 *, u_int32);
error_code _os_mkmodule (char *, u_int32, u_int16 *, u_int16 *, u_int32, void **, mh_com **, u_int32);
error_code _os_modaddr (void *, mh_com **);
error_code _os_setcrc (mh_com *);
error_code _os_slink (u_int32, char *, void **, void **, mh_com **);
error_code _os_slinkm (u_int32, mh_com *, void **, void **);
error_code _os_unlink (mh_com *);
error_code _os_unload (char *, u_int32);
error_code _os_tlink (u_int32, char *, void **, mh_trap **, void *, u_int32);
error_code _os_tlinkm (u_int32, mh_com *, void **, void *, u_int32);
error_code _os_iodel (mh_com *);
error_code _os_vmodul (mh_com *, mh_com *, u_int32);
@

