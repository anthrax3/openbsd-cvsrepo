head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.50
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.52
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.48
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.44
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.46
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.38
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.42
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.40
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.36
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.34
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.32
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.30
	OPENBSD_5_0:1.4.0.28
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.26
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.24
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2004.12.27.14.00.40;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.21.20.23.11;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.39.01;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.19.42;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.12.31;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.06.36;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.19.42;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@/* Remote debugging interface for Renesas E7000 ICE, for GDB

   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004 Free Software Foundation, Inc.

   Contributed by Cygnus Support. 

   Written by Steve Chamberlain for Cygnus Support.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* The E7000 is an in-circuit emulator for the Renesas H8/300-H and
   Renesas-SH processor.  It has serial port and a lan port.  

   The monitor command set makes it difficult to load large ammounts of
   data over the lan without using ftp - so try not to issue load
   commands when communicating over ethernet; use the ftpload command.

   The monitor pauses for a second when dumping srecords to the serial
   line too, so we use a slower per byte mechanism but without the
   startup overhead.  Even so, it's pretty slow... */

#include "defs.h"
#include "gdbcore.h"
#include "gdbarch.h"
#include "inferior.h"
#include "target.h"
#include "value.h"
#include "command.h"
#include "gdb_string.h"
#include "gdbcmd.h"
#include <sys/types.h>
#include "serial.h"
#include "remote-utils.h"
#include "symfile.h"
#include "regcache.h"
#include <time.h>
#include <ctype.h>


#if 1
#define HARD_BREAKPOINTS	/* Now handled by set option. */
#define BC_BREAKPOINTS use_hard_breakpoints
#endif

#define CTRLC 0x03
#define ENQ  0x05
#define ACK  0x06
#define CTRLZ 0x1a

/* This file is used by 2 different targets, sh-elf and h8300. The
   h8300 is not multiarched and doesn't use the registers defined in
   tm-sh.h. To avoid using a macro GDB_TARGET_IS_SH, we do runtime check
   of the target, which requires that these namse below are always
   defined also in the h8300 case. */

#if !defined (PR_REGNUM)
#define PR_REGNUM 	-1
#endif
#if !defined (GBR_REGNUM)
#define GBR_REGNUM 	-1
#endif
#if !defined (VBR_REGNUM)
#define VBR_REGNUM 	-1
#endif
#if !defined (MACH_REGNUM)
#define MACH_REGNUM 	-1
#endif
#if !defined (MACL_REGNUM)
#define MACL_REGNUM 	-1
#endif
#if !defined (SR_REGNUM)
#define SR_REGNUM 	-1
#endif

extern void report_transfer_performance (unsigned long, time_t, time_t);

extern char *sh_processor_type;

/* Local function declarations.  */

static void e7000_close (int);

static void e7000_fetch_register (int);

static void e7000_store_register (int);

static void e7000_command (char *, int);

static void e7000_login_command (char *, int);

static void e7000_ftp_command (char *, int);

static void e7000_drain_command (char *, int);

static void expect (char *);

static void expect_full_prompt (void);

static void expect_prompt (void);

static int e7000_parse_device (char *args, char *dev_name, int baudrate);
/* Variables. */

static struct serial *e7000_desc;

/* Allow user to chose between using hardware breakpoints or memory. */
static int use_hard_breakpoints = 0;	/* use sw breakpoints by default */

/* Nonzero if using the tcp serial driver.  */

static int using_tcp;		/* direct tcp connection to target */
static int using_tcp_remote;	/* indirect connection to target 
				   via tcp to controller */

/* Nonzero if using the pc isa card.  */

static int using_pc;

extern struct target_ops e7000_ops;	/* Forward declaration */

char *ENQSTRING = "\005";

/* Nonzero if some routine (as opposed to the user) wants echoing.
   FIXME: Do this reentrantly with an extra parameter.  */

static int echo;

static int ctrl_c;

static int timeout = 20;

/* Send data to e7000debug.  */

static void
puts_e7000debug (char *buf)
{
  if (!e7000_desc)
    error ("Use \"target e7000 ...\" first.");

  if (remote_debug)
    printf_unfiltered ("Sending %s\n", buf);

  if (serial_write (e7000_desc, buf, strlen (buf)))
    fprintf_unfiltered (gdb_stderr, "serial_write failed: %s\n", safe_strerror (errno));

  /* And expect to see it echoed, unless using the pc interface */
#if 0
  if (!using_pc)
#endif
    expect (buf);
}

static void
putchar_e7000 (int x)
{
  char b[1];

  b[0] = x;
  serial_write (e7000_desc, b, 1);
}

static void
write_e7000 (char *s)
{
  serial_write (e7000_desc, s, strlen (s));
}

static int
normal (int x)
{
  if (x == '\n')
    return '\r';
  return x;
}

/* Read a character from the remote system, doing all the fancy timeout
   stuff.  Handles serial errors and EOF.  If TIMEOUT == 0, and no chars,
   returns -1, else returns next char.  Discards chars > 127.  */

static int
readchar (int timeout)
{
  int c;

  do
    {
      c = serial_readchar (e7000_desc, timeout);
    }
  while (c > 127);

  if (c == SERIAL_TIMEOUT)
    {
      if (timeout == 0)
	return -1;
      echo = 0;
      error ("Timeout reading from remote system.");
    }
  else if (c < 0)
    error ("Serial communication error");

  if (remote_debug)
    {
      putchar_unfiltered (c);
      gdb_flush (gdb_stdout);
    }

  return normal (c);
}

#if 0
char *
tl (int x)
{
  static char b[8][10];
  static int p;

  p++;
  p &= 7;
  if (x >= ' ')
    {
      b[p][0] = x;
      b[p][1] = 0;
    }
  else
    {
      sprintf (b[p], "<%d>", x);
    }

  return b[p];
}
#endif

/* Scan input from the remote system, until STRING is found.  If
   DISCARD is non-zero, then discard non-matching input, else print it
   out.  Let the user break out immediately.  */

static void
expect (char *string)
{
  char *p = string;
  int c;
  int nl = 0;

  while (1)
    {
      c = readchar (timeout);

      if (echo)
	{
	  if (c == '\r' || c == '\n')
	    {
	      if (!nl)
		putchar_unfiltered ('\n');
	      nl = 1;
	    }
	  else
	    {
	      nl = 0;
	      putchar_unfiltered (c);
	    }
	  gdb_flush (gdb_stdout);
	}
      if (normal (c) == normal (*p++))
	{
	  if (*p == '\0')
	    return;
	}
      else
	{
	  p = string;

	  if (normal (c) == normal (string[0]))
	    p++;
	}
    }
}

/* Keep discarding input until we see the e7000 prompt.

   The convention for dealing with the prompt is that you
   o give your command
   o *then* wait for the prompt.

   Thus the last thing that a procedure does with the serial line will
   be an expect_prompt().  Exception: e7000_resume does not wait for
   the prompt, because the terminal is being handed over to the
   inferior.  However, the next thing which happens after that is a
   e7000_wait which does wait for the prompt.  Note that this includes
   abnormal exit, e.g. error().  This is necessary to prevent getting
   into states from which we can't recover.  */

static void
expect_prompt (void)
{
  expect (":");
}

static void
expect_full_prompt (void)
{
  expect ("\r:");
}

static int
convert_hex_digit (int ch)
{
  if (ch >= '0' && ch <= '9')
    return ch - '0';
  else if (ch >= 'A' && ch <= 'F')
    return ch - 'A' + 10;
  else if (ch >= 'a' && ch <= 'f')
    return ch - 'a' + 10;
  return -1;
}

static int
get_hex (int *start)
{
  int value = convert_hex_digit (*start);
  int try;

  *start = readchar (timeout);
  while ((try = convert_hex_digit (*start)) >= 0)
    {
      value <<= 4;
      value += try;
      *start = readchar (timeout);
    }
  return value;
}

#if 0
/* Get N 32-bit words from remote, each preceded by a space, and put
   them in registers starting at REGNO.  */

static void
get_hex_regs (int n, int regno)
{
  long val;
  int i;

  for (i = 0; i < n; i++)
    {
      int j;

      val = 0;
      for (j = 0; j < 8; j++)
	val = (val << 4) + get_hex_digit (j == 0);
      regcache_raw_supply (current_regcache, regno++, (char *) &val);
    }
}
#endif

/* This is called not only when we first attach, but also when the
   user types "run" after having attached.  */

static void
e7000_create_inferior (char *execfile, char *args, char **env,
		       int from_tty)
{
  int entry_pt;

  if (args && *args)
    error ("Can't pass arguments to remote E7000DEBUG process");

  if (execfile == 0 || exec_bfd == 0)
    error ("No executable file specified");

  entry_pt = (int) bfd_get_start_address (exec_bfd);

#ifdef CREATE_INFERIOR_HOOK
  CREATE_INFERIOR_HOOK (0);	/* No process-ID */
#endif

  /* The "process" (board) is already stopped awaiting our commands, and
     the program is already downloaded.  We just set its PC and go.  */

  clear_proceed_status ();

  /* Tell wait_for_inferior that we've started a new process.  */
  init_wait_for_inferior ();

  /* Set up the "saved terminal modes" of the inferior
     based on what modes we are starting it with.  */
  target_terminal_init ();

  /* Install inferior's terminal modes.  */
  target_terminal_inferior ();

  /* insert_step_breakpoint ();  FIXME, do we need this?  */
  proceed ((CORE_ADDR) entry_pt, -1, 0);	/* Let 'er rip... */
}

/* Open a connection to a remote debugger.  NAME is the filename used
   for communication.  */

static int baudrate = 9600;
static char dev_name[100];

static char *machine = "";
static char *user = "";
static char *passwd = "";
static char *dir = "";

/* Grab the next token and buy some space for it */

static char *
next (char **ptr)
{
  char *p = *ptr;
  char *s;
  char *r;
  int l = 0;

  while (*p && *p == ' ')
    p++;
  s = p;
  while (*p && (*p != ' ' && *p != '\t'))
    {
      l++;
      p++;
    }
  r = xmalloc (l + 1);
  memcpy (r, s, l);
  r[l] = 0;
  *ptr = p;
  return r;
}

static void
e7000_login_command (char *args, int from_tty)
{
  if (args)
    {
      machine = next (&args);
      user = next (&args);
      passwd = next (&args);
      dir = next (&args);
      if (from_tty)
	{
	  printf_unfiltered ("Set info to %s %s %s %s\n", machine, user, passwd, dir);
	}
    }
  else
    {
      error ("Syntax is ftplogin <machine> <user> <passwd> <directory>");
    }
}

/* Start an ftp transfer from the E7000 to a host */

static void
e7000_ftp_command (char *args, int from_tty)
{
  /* FIXME: arbitrary limit on machine names and such.  */
  char buf[200];

  int oldtimeout = timeout;
  timeout = remote_timeout;

  sprintf (buf, "ftp %s\r", machine);
  puts_e7000debug (buf);
  expect (" Username : ");
  sprintf (buf, "%s\r", user);
  puts_e7000debug (buf);
  expect (" Password : ");
  write_e7000 (passwd);
  write_e7000 ("\r");
  expect ("success\r");
  expect ("FTP>");
  sprintf (buf, "cd %s\r", dir);
  puts_e7000debug (buf);
  expect ("FTP>");
  sprintf (buf, "ll 0;s:%s\r", args);
  puts_e7000debug (buf);
  expect ("FTP>");
  puts_e7000debug ("bye\r");
  expect (":");
  timeout = oldtimeout;
}

static int
e7000_parse_device (char *args, char *dev_name, int baudrate)
{
  char junk[128];
  int n = 0;
  if (args && strcasecmp (args, "pc") == 0)
    {
      strcpy (dev_name, args);
      using_pc = 1;
    }
  else
    {
      /* FIXME! temp hack to allow use with port master -
         target tcp_remote <device> */
      if (args && strncmp (args, "tcp", 10) == 0)
	{
	  char com_type[128];
	  n = sscanf (args, " %s %s %d %s", com_type, dev_name, &baudrate, junk);
	  using_tcp_remote = 1;
	  n--;
	}
      else if (args)
	{
	  n = sscanf (args, " %s %d %s", dev_name, &baudrate, junk);
	}

      if (n != 1 && n != 2)
	{
	  error ("Bad arguments.  Usage:\ttarget e7000 <device> <speed>\n\
or \t\ttarget e7000 <host>[:<port>]\n\
or \t\ttarget e7000 tcp_remote <host>[:<port>]\n\
or \t\ttarget e7000 pc\n");
	}

#if !defined(__GO32__) && !defined(_WIN32) && !defined(__CYGWIN__)
      /* FIXME!  test for ':' is ambiguous */
      if (n == 1 && strchr (dev_name, ':') == 0)
	{
	  /* Default to normal telnet port */
	  /* serial_open will use this to determine tcp communication */
	  strcat (dev_name, ":23");
	}
#endif
      if (!using_tcp_remote && strchr (dev_name, ':'))
	using_tcp = 1;
    }

  return n;
}

/* Stub for catch_errors.  */

static int
e7000_start_remote (void *dummy)
{
  int loop;
  int sync;
  int try;
  int quit_trying;

  immediate_quit++;		/* Allow user to interrupt it */

  /* Hello?  Are you there?  */
  sync = 0;
  loop = 0;
  try = 0;
  quit_trying = 20;
  putchar_e7000 (CTRLC);
  while (!sync && ++try <= quit_trying)
    {
      int c;

      printf_unfiltered ("[waiting for e7000...]\n");

      write_e7000 ("\r");
      c = readchar (1);

      /* FIXME!  this didn't seem right->  while (c != SERIAL_TIMEOUT)
       * we get stuck in this loop ...
       * We may never timeout, and never sync up :-(
       */
      while (!sync && c != -1)
	{
	  /* Dont echo cr's */
	  if (c != '\r')
	    {
	      putchar_unfiltered (c);
	      gdb_flush (gdb_stdout);
	    }
	  /* Shouldn't we either break here, or check for sync in inner loop? */
	  if (c == ':')
	    sync = 1;

	  if (loop++ == 20)
	    {
	      putchar_e7000 (CTRLC);
	      loop = 0;
	    }

	  QUIT;

	  if (quit_flag)
	    {
	      putchar_e7000 (CTRLC);
	      /* Was-> quit_flag = 0; */
	      c = -1;
	      quit_trying = try + 1;	/* we don't want to try anymore */
	    }
	  else
	    {
	      c = readchar (1);
	    }
	}
    }

  if (!sync)
    {
      fprintf_unfiltered (gdb_stderr, "Giving up after %d tries...\n", try);
      error ("Unable to synchronize with target.\n");
    }

  puts_e7000debug ("\r");
  expect_prompt ();
  puts_e7000debug ("b -\r");	/* Clear breakpoints */
  expect_prompt ();

  immediate_quit--;

/* This is really the job of start_remote however, that makes an assumption
   that the target is about to print out a status message of some sort.  That
   doesn't happen here. */

  flush_cached_frames ();
  registers_changed ();
  stop_pc = read_pc ();
  print_stack_frame (get_selected_frame (), 0, SRC_AND_LOC);

  return 1;
}

static void
e7000_open (char *args, int from_tty)
{
  int n;

  target_preopen (from_tty);

  n = e7000_parse_device (args, dev_name, baudrate);

  push_target (&e7000_ops);

  e7000_desc = serial_open (dev_name);

  if (!e7000_desc)
    perror_with_name (dev_name);

  if (serial_setbaudrate (e7000_desc, baudrate))
    {
      serial_close (e7000_desc);
      perror_with_name (dev_name);
    }
  serial_raw (e7000_desc);

  /* Start the remote connection; if error (0), discard this target.
     In particular, if the user quits, be sure to discard it
     (we'd be in an inconsistent state otherwise).  */
  if (!catch_errors (e7000_start_remote, (char *) 0,
       "Couldn't establish connection to remote target\n", RETURN_MASK_ALL))
    if (from_tty)
      printf_filtered ("Remote target %s connected to %s\n", target_shortname,
		       dev_name);
}

/* Close out all files and local state before this target loses control. */

static void
e7000_close (int quitting)
{
  if (e7000_desc)
    {
      serial_close (e7000_desc);
      e7000_desc = 0;
    }
}

/* Terminate the open connection to the remote debugger.  Use this
   when you want to detach and do something else with your gdb.  */

static void
e7000_detach (char *arg, int from_tty)
{
  pop_target ();		/* calls e7000_close to do the real work */
  if (from_tty)
    printf_unfiltered ("Ending remote %s debugging\n", target_shortname);
}

/* Tell the remote machine to resume.  */

static void
e7000_resume (ptid_t ptid, int step, enum target_signal sigal)
{
  if (step)
    puts_e7000debug ("S\r");
  else
    puts_e7000debug ("G\r");
}

/* Read the remote registers into the block REGS.  

   For the H8/300 a register dump looks like:

   PC=00021A  CCR=80:I*******
   ER0 - ER3  0000000A 0000002E 0000002E 00000000
   ER4 - ER7  00000000 00000000 00000000 00FFEFF6
   000218           MOV.B     R1L,R2L
   STEP NORMAL END or
   BREAK POINT
 */

char *want_h8300h = "PC=%p CCR=%c\n\
 ER0 - ER3  %0 %1 %2 %3\n\
 ER4 - ER7  %4 %5 %6 %7\n";

char *want_nopc_h8300h = "%p CCR=%c\n\
 ER0 - ER3  %0 %1 %2 %3\n\
 ER4 - ER7  %4 %5 %6 %7";

char *want_h8300s = "PC=%p CCR=%c\n\
 MACH=\n\
 ER0 - ER3  %0 %1 %2 %3\n\
 ER4 - ER7  %4 %5 %6 %7\n";

char *want_nopc_h8300s = "%p CCR=%c EXR=%9\n\
 ER0 - ER3  %0 %1 %2 %3\n\
 ER4 - ER7  %4 %5 %6 %7";

char *want_sh = "PC=%16 SR=%22\n\
PR=%17 GBR=%18 VBR=%19\n\
MACH=%20 MACL=%21\n\
R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\
R8-15 %8 %9 %10 %11 %12 %13 %14 %15\n";

char *want_nopc_sh = "%16 SR=%22\n\
 PR=%17 GBR=%18 VBR=%19\n\
 MACH=%20 MACL=%21\n\
 R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\
 R8-15 %8 %9 %10 %11 %12 %13 %14 %15";

char *want_sh3 = "PC=%16 SR=%22\n\
PR=%17 GBR=%18 VBR=%19\n\
MACH=%20 MACL=%21 SSR=%23 SPC=%24\n\
R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\
R8-15 %8 %9 %10 %11 %12 %13 %14 %15\n\
R0_BANK0-R3_BANK0 %25 %26 %27 %28\n\
R4_BANK0-R7_BANK0 %29 %30 %31 %32\n\
R0_BANK1-R3_BANK1 %33 %34 %35 %36\n\
R4_BANK1-R7_BANK1 %37 %38 %39 %40";

char *want_nopc_sh3 = "%16 SR=%22\n\
 PR=%17 GBR=%18 VBR=%19\n\
 MACH=%20 MACL=%21 SSR=%22 SPC=%23\n\
 R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\
 R8-15 %8 %9 %10 %11 %12 %13 %14 %15\n\
 R0_BANK0-R3_BANK0 %25 %26 %27 %28\n\
 R4_BANK0-R7_BANK0 %29 %30 %31 %32\n\
 R0_BANK1-R3_BANK1 %33 %34 %35 %36\n\
 R4_BANK1-R7_BANK1 %37 %38 %39 %40";

static int
gch (void)
{
  return readchar (timeout);
}

static unsigned int
gbyte (void)
{
  int high = convert_hex_digit (gch ());
  int low = convert_hex_digit (gch ());

  return (high << 4) + low;
}

static void
fetch_regs_from_dump (int (*nextchar) (), char *want)
{
  int regno;
  char buf[MAX_REGISTER_SIZE];

  int thischar = nextchar ();

  if (want == NULL)
    internal_error (__FILE__, __LINE__, "Register set not selected.");

  while (*want)
    {
      switch (*want)
	{
	case '\n':
	  /* Skip to end of line and then eat all new line type stuff */
	  while (thischar != '\n' && thischar != '\r')
	    thischar = nextchar ();
	  while (thischar == '\n' || thischar == '\r')
	    thischar = nextchar ();
	  want++;
	  break;

	case ' ':
	  while (thischar == ' '
		 || thischar == '\t'
		 || thischar == '\r'
		 || thischar == '\n')
	    thischar = nextchar ();
	  want++;
	  break;

	default:
	  if (*want == thischar)
	    {
	      want++;
	      if (*want)
		thischar = nextchar ();

	    }
	  else if (thischar == ' ' || thischar == '\n' || thischar == '\r')
	    {
	      thischar = nextchar ();
	    }
	  else
	    {
	      error ("out of sync in fetch registers wanted <%s>, got <%c 0x%x>",
		     want, thischar, thischar);
	    }

	  break;
	case '%':
	  /* Got a register command */
	  want++;
	  switch (*want)
	    {
#ifdef PC_REGNUM
	    case 'p':
	      regno = PC_REGNUM;
	      want++;
	      break;
#endif
#ifdef CCR_REGNUM
	    case 'c':
	      regno = CCR_REGNUM;
	      want++;
	      break;
#endif
#ifdef SP_REGNUM
	    case 's':
	      regno = SP_REGNUM;
	      want++;
	      break;
#endif
#ifdef DEPRECATED_FP_REGNUM
	    case 'f':
	      regno = DEPRECATED_FP_REGNUM;
	      want++;
	      break;
#endif

	    default:
	      if (isdigit (want[0]))
		{
		  if (isdigit (want[1]))
		    {
		      regno = (want[0] - '0') * 10 + want[1] - '0';
		      want += 2;
		    }
		  else
		    {
		      regno = want[0] - '0';
		      want++;
		    }
		}

	      else
		internal_error (__FILE__, __LINE__, "failed internal consistency check");
	    }
	  store_signed_integer (buf,
				register_size (current_gdbarch, regno),
				(LONGEST) get_hex (&thischar));
	  regcache_raw_supply (current_regcache, regno, buf);
	  break;
	}
    }
}

static void
e7000_fetch_registers (void)
{
  int regno;
  char *wanted = NULL;

  puts_e7000debug ("R\r");

  if (TARGET_ARCHITECTURE->arch == bfd_arch_sh)
    {
      wanted = want_sh;
      switch (TARGET_ARCHITECTURE->mach)
	{
	case bfd_mach_sh3:
	case bfd_mach_sh3e:
	case bfd_mach_sh4:
	  wanted = want_sh3;
	}
    }
  if (TARGET_ARCHITECTURE->arch == bfd_arch_h8300)
    {
      wanted = want_h8300h;
      switch (TARGET_ARCHITECTURE->mach)
	{
	case bfd_mach_h8300s:
	case bfd_mach_h8300sn:
	case bfd_mach_h8300sx:
	case bfd_mach_h8300sxn:
	  wanted = want_h8300s;
	}
    }

  fetch_regs_from_dump (gch, wanted);

  /* And supply the extra ones the simulator uses */
  for (regno = NUM_REALREGS; regno < NUM_REGS; regno++)
    {
      int buf = 0;

      regcache_raw_supply (current_regcache, regno, (char *) (&buf));
    }
}

/* Fetch register REGNO, or all registers if REGNO is -1.  Returns
   errno value.  */

static void
e7000_fetch_register (int regno)
{
  e7000_fetch_registers ();
}

/* Store the remote registers from the contents of the block REGS.  */

static void
e7000_store_registers (void)
{
  int regno;

  for (regno = 0; regno < NUM_REALREGS; regno++)
    e7000_store_register (regno);

  registers_changed ();
}

/* Store register REGNO, or all if REGNO == 0.  Return errno value.  */

static void
e7000_store_register (int regno)
{
  char buf[200];

  if (regno == -1)
    {
      e7000_store_registers ();
      return;
    }

  if (TARGET_ARCHITECTURE->arch == bfd_arch_h8300)
    {
      if (regno <= 7)
	{
	  sprintf (buf, ".ER%d %s\r", regno, phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}
      else if (regno == PC_REGNUM)
	{
	  sprintf (buf, ".PC %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}
#ifdef CCR_REGNUM
      else if (regno == CCR_REGNUM)
	{
	  sprintf (buf, ".CCR %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}
#endif
    }

  else if (TARGET_ARCHITECTURE->arch == bfd_arch_sh)
    {
      if (regno == PC_REGNUM)
	{
	  sprintf (buf, ".PC %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}

      else if (regno == SR_REGNUM)
	{
	  sprintf (buf, ".SR %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}

      else if (regno ==  PR_REGNUM)
	{
	  sprintf (buf, ".PR %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}

      else if (regno == GBR_REGNUM)
	{
	  sprintf (buf, ".GBR %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}

      else if (regno == VBR_REGNUM)
	{
	  sprintf (buf, ".VBR %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}

      else if (regno == MACH_REGNUM)
	{
	  sprintf (buf, ".MACH %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}

      else if (regno == MACL_REGNUM)
	{
	  sprintf (buf, ".MACL %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}
      else
	{
	  sprintf (buf, ".R%d %s\r", regno, phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}
    }

  expect_prompt ();
}

/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On machines
   which store all the registers in one fell swoop, this makes sure
   that registers contains all the registers from the program being
   debugged.  */

static void
e7000_prepare_to_store (void)
{
  /* Do nothing, since we can store individual regs */
}

static void
e7000_files_info (struct target_ops *ops)
{
  printf_unfiltered ("\tAttached to %s at %d baud.\n", dev_name, baudrate);
}

static int
stickbyte (char *where, unsigned int what)
{
  static CONST char digs[] = "0123456789ABCDEF";

  where[0] = digs[(what >> 4) & 0xf];
  where[1] = digs[(what & 0xf) & 0xf];

  return what;
}

/* Write a small ammount of memory. */

static int
write_small (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  int i;
  char buf[200];

  for (i = 0; i < len; i++)
    {
      if (((memaddr + i) & 3) == 0 && (i + 3 < len))
	{
	  /* Can be done with a long word */
	  sprintf (buf, "m %s %x%02x%02x%02x;l\r",
		   paddr_nz (memaddr + i),
		   myaddr[i], myaddr[i + 1], myaddr[i + 2], myaddr[i + 3]);
	  puts_e7000debug (buf);
	  i += 3;
	}
      else
	{
	  sprintf (buf, "m %s %x\r", paddr_nz (memaddr + i), myaddr[i]);
	  puts_e7000debug (buf);
	}
    }

  expect_prompt ();

  return len;
}

/* Write a large ammount of memory, this only works with the serial
   mode enabled.  Command is sent as

   il ;s:s\r     ->
   <- il ;s:s\r
   <-   ENQ
   ACK          ->
   <- LO s\r
   Srecords...
   ^Z           ->
   <-   ENQ
   ACK          ->  
   <-   :       
 */

static int
write_large (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  int i;
#define maxstride  128
  int stride;

  puts_e7000debug ("IL ;S:FK\r");
  expect (ENQSTRING);
  putchar_e7000 (ACK);
  expect ("LO FK\r");

  for (i = 0; i < len; i += stride)
    {
      char compose[maxstride * 2 + 50];
      int address = i + memaddr;
      int j;
      int check_sum;
      int where = 0;
      int alen;

      stride = len - i;
      if (stride > maxstride)
	stride = maxstride;

      compose[where++] = 'S';
      check_sum = 0;
      if (address >= 0xffffff)
	alen = 4;
      else if (address >= 0xffff)
	alen = 3;
      else
	alen = 2;
      /* Insert type. */
      compose[where++] = alen - 1 + '0';
      /* Insert length. */
      check_sum += stickbyte (compose + where, alen + stride + 1);
      where += 2;
      while (alen > 0)
	{
	  alen--;
	  check_sum += stickbyte (compose + where, address >> (8 * (alen)));
	  where += 2;
	}

      for (j = 0; j < stride; j++)
	{
	  check_sum += stickbyte (compose + where, myaddr[i + j]);
	  where += 2;
	}
      stickbyte (compose + where, ~check_sum);
      where += 2;
      compose[where++] = '\r';
      compose[where++] = '\n';
      compose[where++] = 0;

      serial_write (e7000_desc, compose, where);
      j = readchar (0);
      if (j == -1)
	{
	  /* This is ok - nothing there */
	}
      else if (j == ENQ)
	{
	  /* Hmm, it's trying to tell us something */
	  expect (":");
	  error ("Error writing memory");
	}
      else
	{
	  printf_unfiltered ("@@%d}@@", j);
	  while ((j = readchar (0)) > 0)
	    {
	      printf_unfiltered ("@@{%d}@@", j);
	    }
	}
    }

  /* Send the trailer record */
  write_e7000 ("S70500000000FA\r");
  putchar_e7000 (CTRLZ);
  expect (ENQSTRING);
  putchar_e7000 (ACK);
  expect (":");

  return len;
}

/* Copy LEN bytes of data from debugger memory at MYADDR to inferior's
   memory at MEMADDR.  Returns length moved.

   Can't use the Srecord load over ethernet, so don't use fast method
   then.  */

static int
e7000_write_inferior_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  if (len < 16 || using_tcp || using_pc)
    return write_small (memaddr, myaddr, len);
  else
    return write_large (memaddr, myaddr, len);
}

/* Read LEN bytes from inferior memory at MEMADDR.  Put the result
   at debugger address MYADDR.  Returns length moved. 

   Small transactions we send
   m <addr>;l
   and receive
   00000000 12345678 ?
 */

static int
e7000_read_inferior_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  int count;
  int c;
  int i;
  char buf[200];
  /* Starting address of this pass.  */

/*  printf("READ INF %x %x %d\n", memaddr, myaddr, len); */
  if (((memaddr - 1) + len) < memaddr)
    {
      errno = EIO;
      return 0;
    }

  sprintf (buf, "m %s;l\r", paddr_nz (memaddr));
  puts_e7000debug (buf);

  for (count = 0; count < len; count += 4)
    {
      /* Suck away the address */
      c = gch ();
      while (c != ' ')
	c = gch ();
      c = gch ();
      if (c == '*')
	{			/* Some kind of error */
	  puts_e7000debug (".\r");	/* Some errors leave us in memory input mode */
	  expect_full_prompt ();
	  return -1;
	}
      while (c != ' ')
	c = gch ();

      /* Now read in the data */
      for (i = 0; i < 4; i++)
	{
	  int b = gbyte ();
	  if (count + i < len)
	    {
	      myaddr[count + i] = b;
	    }
	}

      /* Skip the trailing ? and send a . to end and a cr for more */
      gch ();
      gch ();
      if (count + 4 >= len)
	puts_e7000debug (".\r");
      else
	puts_e7000debug ("\r");

    }
  expect_prompt ();
  return len;
}



/*
   For large transfers we used to send


   d <addr> <endaddr>\r

   and receive
   <ADDRESS>           <    D   A   T   A    >               <   ASCII CODE   >
   00000000 5F FD FD FF DF 7F DF FF  01 00 01 00 02 00 08 04  "_..............."
   00000010 FF D7 FF 7F D7 F1 7F FF  00 05 00 00 08 00 40 00  "..............@@."
   00000020 7F FD FF F7 7F FF FF F7  00 00 00 00 00 00 00 00  "................"

   A cost in chars for each transaction of 80 + 5*n-bytes. 

   Large transactions could be done with the srecord load code, but
   there is a pause for a second before dumping starts, which slows the
   average rate down!
 */

static int
e7000_read_inferior_memory_large (CORE_ADDR memaddr, unsigned char *myaddr,
				  int len)
{
  int count;
  int c;
  char buf[200];

  /* Starting address of this pass.  */

  if (((memaddr - 1) + len) < memaddr)
    {
      errno = EIO;
      return 0;
    }

  sprintf (buf, "d %s %s\r", paddr_nz (memaddr), paddr_nz (memaddr + len - 1));
  puts_e7000debug (buf);

  count = 0;
  c = gch ();

  /* skip down to the first ">" */
  while (c != '>')
    c = gch ();
  /* now skip to the end of that line */
  while (c != '\r')
    c = gch ();
  c = gch ();

  while (count < len)
    {
      /* get rid of any white space before the address */
      while (c <= ' ')
	c = gch ();

      /* Skip the address */
      get_hex (&c);

      /* read in the bytes on the line */
      while (c != '"' && count < len)
	{
	  if (c == ' ')
	    c = gch ();
	  else
	    {
	      myaddr[count++] = get_hex (&c);
	    }
	}
      /* throw out the rest of the line */
      while (c != '\r')
	c = gch ();
    }

  /* wait for the ":" prompt */
  while (c != ':')
    c = gch ();

  return len;
}

#if 0

static int
fast_but_for_the_pause_e7000_read_inferior_memory (CORE_ADDR memaddr,
						   char *myaddr, int len)
{
  int loop;
  int c;
  char buf[200];

  if (((memaddr - 1) + len) < memaddr)
    {
      errno = EIO;
      return 0;
    }

  sprintf (buf, "is %x@@%x:s\r", memaddr, len);
  puts_e7000debug (buf);
  gch ();
  c = gch ();
  if (c != ENQ)
    {
      /* Got an error */
      error ("Memory read error");
    }
  putchar_e7000 (ACK);
  expect ("SV s");
  loop = 1;
  while (loop)
    {
      int type;
      int length;
      int addr;
      int i;

      c = gch ();
      switch (c)
	{
	case ENQ:		/* ENQ, at the end */
	  loop = 0;
	  break;
	case 'S':
	  /* Start of an Srecord */
	  type = gch ();
	  length = gbyte ();
	  switch (type)
	    {
	    case '7':		/* Termination record, ignore */
	    case '0':
	    case '8':
	    case '9':
	      /* Header record - ignore it */
	      while (length--)
		{
		  gbyte ();
		}
	      break;
	    case '1':
	    case '2':
	    case '3':
	      {
		int alen;

		alen = type - '0' + 1;
		addr = 0;
		while (alen--)
		  {
		    addr = (addr << 8) + gbyte ();
		    length--;
		  }

		for (i = 0; i < length - 1; i++)
		  myaddr[i + addr - memaddr] = gbyte ();

		gbyte ();	/* Ignore checksum */
	      }
	    }
	}
    }

  putchar_e7000 (ACK);
  expect ("TOP ADDRESS =");
  expect ("END ADDRESS =");
  expect (":");

  return len;
}

#endif

/* Transfer LEN bytes between GDB address MYADDR and target address
   MEMADDR.  If WRITE is non-zero, transfer them to the target,
   otherwise transfer them from the target.  TARGET is unused.

   Returns the number of bytes transferred. */

static int
e7000_xfer_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len,
			    int write, struct mem_attrib *attrib,
			    struct target_ops *target)
{
  if (write)
    return e7000_write_inferior_memory (memaddr, myaddr, len);
  else if (len < 16)
    return e7000_read_inferior_memory (memaddr, myaddr, len);
  else
    return e7000_read_inferior_memory_large (memaddr, myaddr, len);
}

static void
e7000_kill (void)
{
}

static void
e7000_load (char *args, int from_tty)
{
  struct cleanup *old_chain;
  asection *section;
  bfd *pbfd;
  bfd_vma entry;
#define WRITESIZE 0x1000
  char buf[2 + 4 + 4 + WRITESIZE];	/* `DT' + <addr> + <len> + <data> */
  char *filename;
  int quiet;
  int nostart;
  time_t start_time, end_time;	/* Start and end times of download */
  unsigned long data_count;	/* Number of bytes transferred to memory */
  int oldtimeout = timeout;

  timeout = remote_timeout;


  /* FIXME! change test to test for type of download */
  if (!using_tcp)
    {
      generic_load (args, from_tty);
      return;
    }

  /* for direct tcp connections, we can do a fast binary download */
  buf[0] = 'D';
  buf[1] = 'T';
  quiet = 0;
  nostart = 0;
  filename = NULL;

  while (*args != '\000')
    {
      char *arg;

      while (isspace (*args))
	args++;

      arg = args;

      while ((*args != '\000') && !isspace (*args))
	args++;

      if (*args != '\000')
	*args++ = '\000';

      if (*arg != '-')
	filename = arg;
      else if (strncmp (arg, "-quiet", strlen (arg)) == 0)
	quiet = 1;
      else if (strncmp (arg, "-nostart", strlen (arg)) == 0)
	nostart = 1;
      else
	error ("unknown option `%s'", arg);
    }

  if (!filename)
    filename = get_exec_file (1);

  pbfd = bfd_openr (filename, gnutarget);
  if (pbfd == NULL)
    {
      perror_with_name (filename);
      return;
    }
  old_chain = make_cleanup_bfd_close (pbfd);

  if (!bfd_check_format (pbfd, bfd_object))
    error ("\"%s\" is not an object file: %s", filename,
	   bfd_errmsg (bfd_get_error ()));

  start_time = time (NULL);
  data_count = 0;

  puts_e7000debug ("mw\r");

  expect ("\nOK");

  for (section = pbfd->sections; section; section = section->next)
    {
      if (bfd_get_section_flags (pbfd, section) & SEC_LOAD)
	{
	  bfd_vma section_address;
	  bfd_size_type section_size;
	  file_ptr fptr;

	  section_address = bfd_get_section_vma (pbfd, section);
	  section_size = bfd_get_section_size (section);

	  if (!quiet)
	    printf_filtered ("[Loading section %s at 0x%s (%s bytes)]\n",
			     bfd_get_section_name (pbfd, section),
			     paddr_nz (section_address),
			     paddr_u (section_size));

	  fptr = 0;

	  data_count += section_size;

	  while (section_size > 0)
	    {
	      int count;
	      static char inds[] = "|/-\\";
	      static int k = 0;

	      QUIT;

	      count = min (section_size, WRITESIZE);

	      buf[2] = section_address >> 24;
	      buf[3] = section_address >> 16;
	      buf[4] = section_address >> 8;
	      buf[5] = section_address;

	      buf[6] = count >> 24;
	      buf[7] = count >> 16;
	      buf[8] = count >> 8;
	      buf[9] = count;

	      bfd_get_section_contents (pbfd, section, buf + 10, fptr, count);

	      if (serial_write (e7000_desc, buf, count + 10))
		fprintf_unfiltered (gdb_stderr,
				    "e7000_load: serial_write failed: %s\n",
				    safe_strerror (errno));

	      expect ("OK");

	      if (!quiet)
		{
		  printf_unfiltered ("\r%c", inds[k++ % 4]);
		  gdb_flush (gdb_stdout);
		}

	      section_address += count;
	      fptr += count;
	      section_size -= count;
	    }
	}
    }

  write_e7000 ("ED");

  expect_prompt ();

  end_time = time (NULL);

/* Finally, make the PC point at the start address */

  if (exec_bfd)
    write_pc (bfd_get_start_address (exec_bfd));

  inferior_ptid = null_ptid;	/* No process now */

/* This is necessary because many things were based on the PC at the time that
   we attached to the monitor, which is no longer valid now that we have loaded
   new code (and just changed the PC).  Another way to do this might be to call
   normal_stop, except that the stack may not be valid, and things would get
   horribly confused... */

  clear_symtab_users ();

  if (!nostart)
    {
      entry = bfd_get_start_address (pbfd);

      if (!quiet)
	printf_unfiltered ("[Starting %s at 0x%s]\n", filename, paddr_nz (entry));

/*      start_routine (entry); */
    }

  report_transfer_performance (data_count, start_time, end_time);

  do_cleanups (old_chain);
  timeout = oldtimeout;
}

/* Clean up when a program exits.

   The program actually lives on in the remote processor's RAM, and may be
   run again without a download.  Don't leave it full of breakpoint
   instructions.  */

static void
e7000_mourn_inferior (void)
{
  remove_breakpoints ();
  unpush_target (&e7000_ops);
  generic_mourn_inferior ();	/* Do all the proper things now */
}

#define MAX_BREAKPOINTS 200
#ifdef  HARD_BREAKPOINTS
#define MAX_E7000DEBUG_BREAKPOINTS (BC_BREAKPOINTS ? 5 :  MAX_BREAKPOINTS)
#else
#define MAX_E7000DEBUG_BREAKPOINTS MAX_BREAKPOINTS
#endif

/* Since we can change to soft breakpoints dynamically, we must define 
   more than enough.  Was breakaddr[MAX_E7000DEBUG_BREAKPOINTS]. */
static CORE_ADDR breakaddr[MAX_BREAKPOINTS] =
{0};

static int
e7000_insert_breakpoint (CORE_ADDR addr, char *shadow)
{
  int i;
  char buf[200];
#if 0
  static char nop[2] = NOP;
#endif

  for (i = 0; i <= MAX_E7000DEBUG_BREAKPOINTS; i++)
    if (breakaddr[i] == 0)
      {
	breakaddr[i] = addr;
	/* Save old contents, and insert a nop in the space */
#ifdef HARD_BREAKPOINTS
	if (BC_BREAKPOINTS)
	  {
	    sprintf (buf, "BC%d A=%s\r", i + 1, paddr_nz (addr));
	    puts_e7000debug (buf);
	  }
	else
	  {
	    sprintf (buf, "B %s\r", paddr_nz (addr));
	    puts_e7000debug (buf);
	  }
#else
#if 0
	e7000_read_inferior_memory (addr, shadow, 2);
	e7000_write_inferior_memory (addr, nop, 2);
#endif

	sprintf (buf, "B %x\r", addr);
	puts_e7000debug (buf);
#endif
	expect_prompt ();
	return 0;
      }

  error ("Too many breakpoints ( > %d) for the E7000\n",
	 MAX_E7000DEBUG_BREAKPOINTS);
  return 1;
}

static int
e7000_remove_breakpoint (CORE_ADDR addr, char *shadow)
{
  int i;
  char buf[200];

  for (i = 0; i < MAX_E7000DEBUG_BREAKPOINTS; i++)
    if (breakaddr[i] == addr)
      {
	breakaddr[i] = 0;
#ifdef HARD_BREAKPOINTS
	if (BC_BREAKPOINTS)
	  {
	    sprintf (buf, "BC%d - \r", i + 1);
	    puts_e7000debug (buf);
	  }
	else
	  {
	    sprintf (buf, "B - %s\r", paddr_nz (addr));
	    puts_e7000debug (buf);
	  }
	expect_prompt ();
#else
	sprintf (buf, "B - %s\r", paddr_nz (addr));
	puts_e7000debug (buf);
	expect_prompt ();

#if 0
	/* Replace the insn under the break */
	e7000_write_inferior_memory (addr, shadow, 2);
#endif
#endif

	return 0;
      }
 
  warning ("Can't find breakpoint associated with 0x%s\n", paddr_nz (addr));
  return 1;
}

/* Put a command string, in args, out to STDBUG.  Output from STDBUG
   is placed on the users terminal until the prompt is seen. */

static void
e7000_command (char *args, int fromtty)
{
  /* FIXME: arbitrary limit on length of args.  */
  char buf[200];

  echo = 0;

  if (!e7000_desc)
    error ("e7000 target not open.");
  if (!args)
    {
      puts_e7000debug ("\r");
    }
  else
    {
      sprintf (buf, "%s\r", args);
      puts_e7000debug (buf);
    }

  echo++;
  ctrl_c = 2;
  expect_full_prompt ();
  echo--;
  ctrl_c = 0;
  printf_unfiltered ("\n");

  /* Who knows what the command did... */
  registers_changed ();
}


static void
e7000_drain_command (char *args, int fromtty)
{
  int c;

  puts_e7000debug ("end\r");
  putchar_e7000 (CTRLC);

  while ((c = readchar (1)) != -1)
    {
      if (quit_flag)
	{
	  putchar_e7000 (CTRLC);
	  quit_flag = 0;
	}
      if (c > ' ' && c < 127)
	printf_unfiltered ("%c", c & 0xff);
      else
	printf_unfiltered ("<%x>", c & 0xff);
    }
}

#define NITEMS 7

static int
why_stop (void)
{
  static char *strings[NITEMS] =
  {
    "STEP NORMAL",
    "BREAK POINT",
    "BREAK KEY",
    "BREAK CONDI",
    "CYCLE ACCESS",
    "ILLEGAL INSTRUCTION",
    "WRITE PROTECT",
  };
  char *p[NITEMS];
  int c;
  int i;

  for (i = 0; i < NITEMS; ++i)
    p[i] = strings[i];

  c = gch ();
  while (1)
    {
      for (i = 0; i < NITEMS; i++)
	{
	  if (c == *(p[i]))
	    {
	      p[i]++;
	      if (*(p[i]) == 0)
		{
		  /* found one of the choices */
		  return i;
		}
	    }
	  else
	    p[i] = strings[i];
	}

      c = gch ();
    }
}

/* Suck characters, if a string match, then return the strings index
   otherwise echo them.  */

static int
expect_n (char **strings)
{
  char *(ptr[10]);
  int n;
  int c;
  char saveaway[100];
  char *buffer = saveaway;
  /* Count number of expect strings  */

  for (n = 0; strings[n]; n++)
    {
      ptr[n] = strings[n];
    }

  while (1)
    {
      int i;
      int gotone = 0;

      c = readchar (1);
      if (c == -1)
	{
	  printf_unfiltered ("[waiting for e7000...]\n");
	}
#ifdef __GO32__
      if (kbhit ())
	{
	  int k = getkey ();

	  if (k == 1)
	    quit_flag = 1;
	}
#endif
      if (quit_flag)
	{
	  putchar_e7000 (CTRLC);	/* interrupt the running program */
	  quit_flag = 0;
	}

      for (i = 0; i < n; i++)
	{
	  if (c == ptr[i][0])
	    {
	      ptr[i]++;
	      if (ptr[i][0] == 0)
		{
		  /* Gone all the way */
		  return i;
		}
	      gotone = 1;
	    }
	  else
	    {
	      ptr[i] = strings[i];
	    }
	}

      if (gotone)
	{
	  /* Save it up incase we find that there was no match */
	  *buffer++ = c;
	}
      else
	{
	  if (buffer != saveaway)
	    {
	      *buffer++ = 0;
	      printf_unfiltered ("%s", buffer);
	      buffer = saveaway;
	    }
	  if (c != -1)
	    {
	      putchar_unfiltered (c);
	      gdb_flush (gdb_stdout);
	    }
	}
    }
}

/* We subtract two from the pc here rather than use
   DECR_PC_AFTER_BREAK since the e7000 doesn't always add two to the
   pc, and the simulators never do. */

static void
sub2_from_pc (void)
{
  char buf[4];
  char buf2[200];

  store_signed_integer (buf,
			register_size (current_gdbarch, PC_REGNUM),
			read_register (PC_REGNUM) - 2);
  regcache_raw_supply (current_regcache, PC_REGNUM, buf);
  sprintf (buf2, ".PC %s\r", phex_nz (read_register (PC_REGNUM), 0));
  puts_e7000debug (buf2);
}

#define WAS_SLEEP 0
#define WAS_INT 1
#define WAS_RUNNING 2
#define WAS_OTHER 3

static char *estrings[] =
{
  "** SLEEP",
  "BREAK !",
  "** PC",
  "PC",
  NULL
};

/* Wait until the remote machine stops, then return, storing status in
   STATUS just as `wait' would.  */

static ptid_t
e7000_wait (ptid_t ptid, struct target_waitstatus *status)
{
  int stop_reason;
  int regno;
  int running_count = 0;
  int had_sleep = 0;
  int loop = 1;
  char *wanted_nopc = NULL;

  /* Then echo chars until PC= string seen */
  gch ();			/* Drop cr */
  gch ();			/* and space */

  while (loop)
    {
      switch (expect_n (estrings))
	{
	case WAS_OTHER:
	  /* how did this happen ? */
	  loop = 0;
	  break;
	case WAS_SLEEP:
	  had_sleep = 1;
	  putchar_e7000 (CTRLC);
	  loop = 0;
	  break;
	case WAS_INT:
	  loop = 0;
	  break;
	case WAS_RUNNING:
	  running_count++;
	  if (running_count == 20)
	    {
	      printf_unfiltered ("[running...]\n");
	      running_count = 0;
	    }
	  break;
	default:
	  /* error? */
	  break;
	}
    }

  /* Skip till the PC= */
  expect ("=");

  if (TARGET_ARCHITECTURE->arch == bfd_arch_sh)
    {
      wanted_nopc = want_nopc_sh;
      switch (TARGET_ARCHITECTURE->mach)
	{
	case bfd_mach_sh3:
	case bfd_mach_sh3e:
	case bfd_mach_sh4:
	  wanted_nopc = want_nopc_sh3;
	}
    }
  if (TARGET_ARCHITECTURE->arch == bfd_arch_h8300)
    {
      wanted_nopc = want_nopc_h8300h;
      switch (TARGET_ARCHITECTURE->mach)
	{
	case bfd_mach_h8300s:
	case bfd_mach_h8300sn:
	case bfd_mach_h8300sx:
	case bfd_mach_h8300sxn:
	  wanted_nopc = want_nopc_h8300s;
	}
    }
  fetch_regs_from_dump (gch, wanted_nopc);

  /* And supply the extra ones the simulator uses */
  for (regno = NUM_REALREGS; regno < NUM_REGS; regno++)
    {
      int buf = 0;
      regcache_raw_supply (current_regcache, regno, (char *) &buf);
    }

  stop_reason = why_stop ();
  expect_full_prompt ();

  status->kind = TARGET_WAITKIND_STOPPED;
  status->value.sig = TARGET_SIGNAL_TRAP;

  switch (stop_reason)
    {
    case 1:			/* Breakpoint */
      write_pc (read_pc ());	/* PC is always off by 2 for breakpoints */
      status->value.sig = TARGET_SIGNAL_TRAP;
      break;
    case 0:			/* Single step */
      status->value.sig = TARGET_SIGNAL_TRAP;
      break;
    case 2:			/* Interrupt */
      if (had_sleep)
	{
	  status->value.sig = TARGET_SIGNAL_TRAP;
	  sub2_from_pc ();
	}
      else
	{
	  status->value.sig = TARGET_SIGNAL_INT;
	}
      break;
    case 3:
      break;
    case 4:
      printf_unfiltered ("a cycle address error?\n");
      status->value.sig = TARGET_SIGNAL_UNKNOWN;
      break;
    case 5:
      status->value.sig = TARGET_SIGNAL_ILL;
      break;
    case 6:
      status->value.sig = TARGET_SIGNAL_SEGV;
      break;
    case 7:			/* Anything else (NITEMS + 1) */
      printf_unfiltered ("a write protect error?\n");
      status->value.sig = TARGET_SIGNAL_UNKNOWN;
      break;
    default:
      /* Get the user's attention - this should never happen. */
      internal_error (__FILE__, __LINE__, "failed internal consistency check");
    }

  return inferior_ptid;
}

/* Stop the running program.  */

static void
e7000_stop (void)
{
  /* Sending a ^C is supposed to stop the running program.  */
  putchar_e7000 (CTRLC);
}

/* Define the target subroutine names. */

struct target_ops e7000_ops;

static void
init_e7000_ops (void)
{
  e7000_ops.to_shortname = "e7000";
  e7000_ops.to_longname = "Remote Renesas e7000 target";
  e7000_ops.to_doc = "Use a remote Renesas e7000 ICE connected by a serial line;\n\
or a network connection.\n\
Arguments are the name of the device for the serial line,\n\
the speed to connect at in bits per second.\n\
eg\n\
target e7000 /dev/ttya 9600\n\
target e7000 foobar";
  e7000_ops.to_open = e7000_open;
  e7000_ops.to_close = e7000_close;
  e7000_ops.to_detach = e7000_detach;
  e7000_ops.to_resume = e7000_resume;
  e7000_ops.to_wait = e7000_wait;
  e7000_ops.to_fetch_registers = e7000_fetch_register;
  e7000_ops.to_store_registers = e7000_store_register;
  e7000_ops.to_prepare_to_store = e7000_prepare_to_store;
  e7000_ops.deprecated_xfer_memory = e7000_xfer_inferior_memory;
  e7000_ops.to_files_info = e7000_files_info;
  e7000_ops.to_insert_breakpoint = e7000_insert_breakpoint;
  e7000_ops.to_remove_breakpoint = e7000_remove_breakpoint;
  e7000_ops.to_kill = e7000_kill;
  e7000_ops.to_load = e7000_load;
  e7000_ops.to_create_inferior = e7000_create_inferior;
  e7000_ops.to_mourn_inferior = e7000_mourn_inferior;
  e7000_ops.to_stop = e7000_stop;
  e7000_ops.to_stratum = process_stratum;
  e7000_ops.to_has_all_memory = 1;
  e7000_ops.to_has_memory = 1;
  e7000_ops.to_has_stack = 1;
  e7000_ops.to_has_registers = 1;
  e7000_ops.to_has_execution = 1;
  e7000_ops.to_magic = OPS_MAGIC;
};

extern initialize_file_ftype _initialize_remote_e7000; /* -Wmissing-prototypes */

void
_initialize_remote_e7000 (void)
{
  init_e7000_ops ();
  add_target (&e7000_ops);

  add_com ("e7000", class_obscure, e7000_command,
	   "Send a command to the e7000 monitor.");

  add_com ("ftplogin", class_obscure, e7000_login_command,
	   "Login to machine and change to directory.");

  add_com ("ftpload", class_obscure, e7000_ftp_command,
	   "Fetch and load a file from previously described place.");

  add_com ("drain", class_obscure, e7000_drain_command,
	   "Drain pending e7000 text buffers.");

  deprecated_add_show_from_set
    (add_set_cmd ("usehardbreakpoints", no_class,
		  var_integer, (char *) &use_hard_breakpoints, "\
Set use of hardware breakpoints for all breakpoints.\n", &setlist),
     &showlist);
}
@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@d4 1
a4 1
   2002, 2003 Free Software Foundation, Inc.
d365 1
a365 1
      supply_register (regno++, (char *) &val);
d374 2
a375 1
e7000_create_inferior (char *execfile, char *args, char **env)
d633 1
a633 1
  print_stack_frame (get_selected_frame (), -1, 1);
d882 1
a882 1
				DEPRECATED_REGISTER_RAW_SIZE (regno),
d884 1
a884 1
	  supply_register (regno, buf);
d929 1
a929 1
      supply_register (regno, (char *) (&buf));
d1572 1
a1572 1
	  section_size = bfd_get_section_size_before_reloc (section);
d1967 1
a1967 1
			DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM),
d1969 1
a1969 1
  supply_register (PC_REGNUM, buf);
d2067 1
a2067 1
      supply_register (regno, (char *) &buf);
d2153 1
a2153 1
  e7000_ops.to_xfer_memory = e7000_xfer_inferior_memory;
d2191 5
a2195 4
  add_show_from_set (add_set_cmd ("usehardbreakpoints", no_class,
				var_integer, (char *) &use_hard_breakpoints,
	"Set use of hardware breakpoints for all breakpoints.\n", &setlist),
		     &showlist);
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d1 5
a5 2
/* Remote debugging interface for Hitachi E7000 ICE, for GDB
   Copyright 1993, 1994, 1996 Free Software Foundation, Inc.
d24 2
a25 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d27 2
a28 2
/* The E7000 is an in-circuit emulator for the Hitachi H8/300-H and
   Hitachi-SH processor.  It has serial port and a lan port.  
d40 1
a42 1
#include "wait.h"
a44 1
#include <signal.h>
d51 1
d53 2
d66 26
a91 2
extern void report_transfer_performance PARAMS ((unsigned long,
						 time_t, time_t));
d97 1
a97 1
static void e7000_close PARAMS ((int));
d99 1
a99 1
static void e7000_fetch_register PARAMS ((int));
d101 1
a101 1
static void e7000_store_register PARAMS ((int));
d103 1
a103 1
static void e7000_command PARAMS ((char *, int));
d105 1
a105 1
static void e7000_login_command PARAMS ((char *, int));
d107 1
a107 1
static void e7000_ftp_command PARAMS ((char *, int));
d109 1
a109 1
static void e7000_drain_command PARAMS ((char *, int));
d111 1
a111 1
static void expect PARAMS ((char *));
d113 1
a113 1
static void expect_full_prompt PARAMS ((void));
d115 1
a115 1
static void expect_prompt PARAMS ((void));
d117 1
d120 1
a120 1
static serial_t e7000_desc;
d123 1
a123 1
static int use_hard_breakpoints = 0; /* use sw breakpoints by default */
d127 1
a127 1
static int using_tcp;	/* direct tcp connection to target */
d151 1
a151 2
puts_e7000debug (buf)
     char *buf;
d157 1
a157 1
    printf("Sending %s\n", buf);
d159 2
a160 2
  if (SERIAL_WRITE (e7000_desc, buf, strlen (buf)))
    fprintf (stderr, "SERIAL_WRITE failed: %s\n", safe_strerror (errno));
d170 1
a170 2
putchar_e7000 (x)
     int x;
d175 1
a175 1
  SERIAL_WRITE (e7000_desc, b, 1);
d179 1
a179 2
write_e7000 (s)
     char *s;
d181 1
a181 1
  SERIAL_WRITE (e7000_desc, s, strlen (s));
d185 1
a185 2
normal (x)
     int x;
d193 2
a194 1
   stuff.  */
d197 1
a197 2
readchar (timeout)
     int timeout;
d203 1
a203 1
      c = SERIAL_READCHAR (e7000_desc, timeout);
d214 4
a217 1
  if (remote_debug) 
d219 2
a220 2
      putchar (c);
      fflush (stdout);
d228 1
a228 1
tl (x)
d235 2
a236 2
  if (x >= ' ') 
    { 
d242 1
a242 1
      sprintf(b[p], "<%d>", x);
d254 1
a254 2
expect (string)
     char *string;
d263 2
a264 19
      notice_quit ();
      if (quit_flag == 1) 
	{
	  if (ctrl_c)
	    {
	      putchar_e7000(CTRLC);
	      --ctrl_c;
	    }
	  else 
	    {
	      quit ();
	    }
	}
      
      if (c == SERIAL_ERROR)
	{
	  error ("Serial communication error");
	}
      if (echo || remote_debug)
d269 1
a269 1
		putchar ('\n');
d275 1
a275 1
	      putchar (c);
d277 1
a277 1
	  fflush (stdout);
d309 1
a309 1
expect_prompt ()
d315 1
a315 1
expect_full_prompt ()
d321 1
a321 2
convert_hex_digit (ch)
     int ch;
d333 1
a333 2
get_hex (start)
     int *start;
d353 1
a353 3
get_hex_regs (n, regno)
     int n;
     int regno;
d374 1
a374 4
e7000_create_inferior (execfile, args, env)
     char *execfile;
     char *args;
     char **env;
d382 1
a382 1
    error ("No exec file specified");
d423 1
a423 2
next (ptr)
     char **ptr;
d446 1
a446 3
e7000_login_command (args, from_tty)
     char *args;
     int from_tty;
d456 1
a456 1
	  printf ("Set info to %s %s %s %s\n", machine, user, passwd, dir);
d468 1
a468 3
e7000_ftp_command (args, from_tty)
     char *args;
     int from_tty;
d497 2
a498 6
static int 
e7000_parse_device(args,dev_name,serial_flag,baudrate) 
    char *args;
    char *dev_name;
    int serial_flag;
    int baudrate;
d507 1
a507 1
  else 
d510 3
a512 3
	     target tcp_remote <device> */
      if (args && strncmp (args, "tcp_remote", 10) == 0) 
        {
d515 1
a515 1
	  using_tcp_remote=1;
d517 2
a518 2
        }
      else if (args) 
d531 1
a531 1
#if !defined(__GO32__) && !defined(_WIN32)
d541 1
a541 1
        using_tcp = 1;
d547 4
a550 4
static void
e7000_open (args, from_tty)
     char *args;
     int from_tty;
a551 1
  int n;
d554 2
a555 5
  int serial_flag;

  target_preopen (from_tty);

  n = e7000_parse_device(args,dev_name,serial_flag,baudrate);
d557 1
a557 9
  push_target (&e7000_ops);

  e7000_desc = SERIAL_OPEN (dev_name);

  if (!e7000_desc)
    perror_with_name (dev_name);

  SERIAL_SETBAUDRATE (e7000_desc, baudrate);
  SERIAL_RAW (e7000_desc);
d561 3
a563 1
  loop =  0;
d565 1
a565 1
  while (!sync)
d569 1
a569 2
      if (from_tty)
	printf_unfiltered ("[waiting for e7000...]\n");
d572 7
a578 2
      c = SERIAL_READCHAR (e7000_desc, 1);
      while (c != SERIAL_TIMEOUT)
d581 1
a581 1
	  if (from_tty && c != '\r')
d583 2
a584 2
	      putchar (c);
	      fflush (stdout);
d586 1
d590 1
a590 1
	  if (loop++ == 20) 
d596 1
a596 2
	  QUIT ;

d601 7
a607 1
	      quit_flag = 0;
a608 1
	  c = SERIAL_READCHAR (e7000_desc, 1);
d611 7
d619 9
d629 18
a646 1
  expect_prompt ();
d648 1
a648 1
  puts_e7000debug ("b -\r");
d650 2
a651 1
  expect_prompt ();
d653 6
a658 3
  if (from_tty)
    printf_filtered ("Remote target %s connected to %s\n", target_shortname,
		     dev_name);
d660 8
a667 3
#ifdef GDB_TARGET_IS_H8300
  h8300hmode = 1;
#endif
d673 1
a673 2
e7000_close (quitting)
     int quitting;
d677 1
a677 1
      SERIAL_CLOSE (e7000_desc);
d686 1
a686 2
e7000_detach (from_tty)
     int from_tty;
d690 1
a690 1
    printf ("Ending remote %s debugging\n", target_shortname);
d696 1
a696 2
e7000_resume (pid, step, sig)
     int pid, step, sig;
d714 1
a714 3
   */

#ifdef GDB_TARGET_IS_H8300
d716 1
a716 1
char *want = "PC=%p CCR=%c\n\
d720 1
a720 1
char *want_nopc = "%p CCR=%c\n\
d724 4
a727 1
#endif
d729 3
a731 1
#ifdef GDB_TARGET_IS_SH
d733 1
a733 1
char *want = "PC=%16 SR=%22\n\
d739 1
a739 1
char *want_nopc = "%16 SR=%22\n\
d755 1
a755 1
char *want_sh3_nopc = "%16 SR=%22\n\
a764 2
#endif

d766 1
a766 1
gch ()
d768 1
a768 10
  int c = readchar (timeout);

  if (remote_debug)
    {
      if (c >= ' ')
	printf ("%c", c);
      else if (c == '\n')
	printf ("\n");
    }
  return c;
d772 1
a772 1
gbyte ()
d780 2
a781 4
void
fetch_regs_from_dump (nextchar, want)
     int (*nextchar)();
     char *want;
d784 1
a784 1
  char buf[MAX_REGISTER_RAW_SIZE];
d788 3
d797 1
a797 1
	  while (thischar != '\n' && thischar != '\r') 
d799 1
a799 1
	  while (thischar == '\n' || thischar == '\r') 
d812 1
a812 1
	  
d819 1
a819 1
	      
d825 6
a830 5
	  else {
	    error ("out of sync in fetch registers wanted <%s>, got <%c 0x%x>",
		   want, thischar, thischar);
	  }
    
d855 1
a855 1
#ifdef FP_REGNUM
d857 1
a857 1
	      regno = FP_REGNUM;
d863 1
a863 1
	      if (isdigit (want[0])) 
d870 1
a870 1
		  else 
d876 1
a876 1
	      
d878 1
a878 1
		abort ();
d881 2
a882 2
				REGISTER_RAW_SIZE(regno),
				(LONGEST) get_hex (&thischar, nextchar));
d890 1
a890 1
e7000_fetch_registers ()
d893 1
d897 23
a919 8
#ifdef GDB_TARGET_IS_SH
  if  ((sh_processor_type != NULL) && (*(sh_processor_type+2) == '3')) 
     fetch_regs_from_dump (gch, want_sh3);
  else
     fetch_regs_from_dump (gch, want);
#else
  fetch_regs_from_dump (gch, want);
#endif
d921 1
d936 1
a936 2
e7000_fetch_register (regno)
     int regno;
d944 1
a944 1
e7000_store_registers ()
d957 1
a957 2
e7000_store_register (regno)
     int regno;
d967 1
a967 2
#ifdef GDB_TARGET_IS_H8300
  if (regno <= 7)
d969 17
a985 2
      sprintf (buf, ".ER%d %x\r", regno, read_register (regno));
      puts_e7000debug (buf);
a986 11
  else if (regno == PC_REGNUM)
    {
      sprintf (buf, ".PC %x\r", read_register (regno));
      puts_e7000debug (buf);
    }
  else if (regno == CCR_REGNUM)
    {
      sprintf (buf, ".CCR %x\r", read_register (regno));
      puts_e7000debug (buf);
    }
#endif /* GDB_TARGET_IS_H8300 */
d988 1
a988 2
#ifdef  GDB_TARGET_IS_SH
  switch (regno)
d990 5
a994 4
    default:
      sprintf (buf, ".R%d %x\r", regno, read_register (regno));
      puts_e7000debug (buf);
      break;
d996 5
a1000 4
    case PC_REGNUM:
      sprintf (buf, ".PC %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;
d1002 5
a1006 4
    case SR_REGNUM:
      sprintf (buf, ".SR %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;
d1008 5
a1012 4
    case PR_REGNUM:
      sprintf (buf, ".PR %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;
d1014 5
a1018 4
    case GBR_REGNUM:
      sprintf (buf, ".GBR %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;
d1020 5
a1024 4
    case VBR_REGNUM:
      sprintf (buf, ".VBR %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;
d1026 10
a1035 9
    case MACH_REGNUM:
      sprintf (buf, ".MACH %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;

    case MACL_REGNUM:
      sprintf (buf, ".MACL %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;
a1037 2
#endif /* GDB_TARGET_IS_SH */

d1048 1
a1048 1
e7000_prepare_to_store ()
d1054 1
a1054 1
e7000_files_info ()
d1056 1
a1056 1
  printf ("\tAttached to %s at %d baud.\n", dev_name, baudrate);
d1060 1
a1060 3
stickbyte (where, what)
     char *where;
     unsigned int what;
d1073 1
a1073 4
write_small (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
d1083 2
a1084 2
	  sprintf (buf, "m %x %x%02x%02x%02x;l\r",
		   memaddr + i,
d1091 1
a1091 1
	  sprintf (buf, "m %x %x\r", memaddr + i, myaddr[i]);
d1104 11
a1114 11
	il ;s:s\r	 ->
			<- il ;s:s\r
			<-  	ENQ
	ACK		->
			<- LO s\r
	Srecords...
	^Z		->
			<-	ENQ
	ACK		->  
			<-	:   	
  */
d1117 1
a1117 4
write_large (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
d1172 3
a1174 3
      SERIAL_WRITE (e7000_desc, compose, where);
      j = SERIAL_READCHAR (e7000_desc, 0);
      if (j == SERIAL_TIMEOUT)
d1186 2
a1187 2
	  printf ("@@%d}@@", j);
	  while ((j = SERIAL_READCHAR(e7000_desc,0)) > 0) 
d1189 1
a1189 1
	      printf ("@@{%d}@@",j);
d1211 1
a1211 4
e7000_write_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
d1222 4
a1225 4
  Small transactions we send
  m <addr>;l
  and receive
    00000000 12345678 ?
d1229 1
a1229 4
e7000_read_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
d1237 1
a1237 1
/*  printf("READ INF %x %x %d\n", memaddr, myaddr, len);*/
d1244 1
a1244 1
  sprintf (buf, "m %x;l\r", memaddr);
d1247 1
a1247 1
  for (count = 0; count < len; count += 4) 
d1250 1
a1250 1
      c = gch ();	
d1252 1
a1252 1
	c = gch ();	
d1254 1
a1254 1
      if (c == '*') 
d1256 2
a1257 1
	  expect_prompt();
d1261 1
a1261 1
	c = gch ();	
d1264 1
a1264 1
      for (i = 0; i < 4; i++) 
d1266 5
a1270 4
	  int b = gbyte();
	  if (count + i < len) {
	    myaddr[count + i] = b;
	  }
d1274 1
a1274 1
      gch ();	
d1277 1
a1277 1
	puts_e7000debug(".\r");
d1279 1
a1279 1
	puts_e7000debug("\r");
d1282 1
a1282 1
  expect_prompt();
d1289 1
a1289 1
  For large transfers we used to send
d1292 1
a1292 1
  d <addr> <endaddr>\r
d1294 1
a1294 1
  and receive
d1300 1
a1300 1
  A cost in chars for each transaction of 80 + 5*n-bytes. 
d1302 4
a1305 4
  Large transactions could be done with the srecord load code, but
  there is a pause for a second before dumping starts, which slows the
  average rate down!
*/
d1308 2
a1309 4
e7000_read_inferior_memory_large (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
d1323 1
a1323 1
  sprintf (buf, "d %x %x\r", memaddr, memaddr + len - 1);
d1328 1
a1328 1
  
d1330 1
a1330 1
  while( c != '>' )
d1333 1
a1333 1
  while( c != '\r' )
d1357 1
a1357 1
      while( c != '\r' )
d1371 2
a1372 4
fast_but_for_the_pause_e7000_read_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d1458 6
d1465 3
a1467 6
e7000_xfer_inferior_memory (memaddr, myaddr, len, write, target)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
     int write;
     struct target_ops *target;	/* ignored */
d1470 5
a1474 6
    return e7000_write_inferior_memory( memaddr, myaddr, len);
  else 
    if( len < 16 )
      return e7000_read_inferior_memory( memaddr, myaddr, len);
    else
      return e7000_read_inferior_memory_large( memaddr, myaddr, len);
d1478 1
a1478 3
e7000_kill (args, from_tty)
     char *args;
     int from_tty;
d1483 1
a1483 3
e7000_load (args, from_tty)
     char *args;
     int from_tty;
a1488 1
  int i;
d1490 1
a1490 1
  char buf[2 + 4 + 4 + WRITESIZE]; /* `DT' + <addr> + <len> + <data> */
d1496 1
a1496 1
  int oldtimeout = timeout;	
d1519 2
a1520 1
      while (isspace (*args)) args++;
d1524 2
a1525 1
      while ((*args != '\000') && !isspace (*args)) args++;
d1549 1
a1549 1
  old_chain = make_cleanup (bfd_close, pbfd);
d1551 1
a1551 1
  if (!bfd_check_format (pbfd, bfd_object)) 
d1562 1
a1562 1
  for (section = pbfd->sections; section; section = section->next) 
d1574 1
a1574 1
	    printf_filtered ("[Loading section %s at 0x%x (%d bytes)]\n",
d1576 2
a1577 2
			     section_address,
			     section_size);
d1580 1
a1580 1
	  
d1605 1
a1605 1
	      if (SERIAL_WRITE (e7000_desc, buf, count + 10))
d1607 2
a1608 2
				    "e7000_load: SERIAL_WRITE failed: %s\n",
				    safe_strerror(errno));
d1636 1
a1636 1
  inferior_pid = 0;		/* No process now */
d1651 1
a1651 1
	printf_unfiltered ("[Starting %s at 0x%x]\n", filename, entry);
d1653 1
a1653 1
/*      start_routine (entry);*/
d1669 1
a1669 1
e7000_mourn_inferior ()
a1682 2
extern int memory_breakpoint_size;

d1685 2
a1686 1
static CORE_ADDR breakaddr[MAX_BREAKPOINTS] = {0};
d1689 1
a1689 3
e7000_insert_breakpoint (addr, shadow)
     CORE_ADDR addr;
     unsigned char *shadow;
d1693 1
d1695 1
d1703 1
a1703 1
	if (BC_BREAKPOINTS) 
d1705 1
a1705 1
	    sprintf (buf, "BC%d A=%x\r", i+1, addr);
d1708 1
a1708 1
	else 
d1710 1
a1710 1
	    sprintf (buf, "B %x\r", addr);
d1732 1
a1732 3
e7000_remove_breakpoint (addr, shadow)
     CORE_ADDR addr;
     unsigned char *shadow;
d1742 1
a1742 1
	if (BC_BREAKPOINTS) 
d1744 1
a1744 1
	    sprintf (buf, "BC%d - \r",  i+1);
d1747 1
a1747 1
	else 
d1749 1
a1749 1
	    sprintf (buf, "B - %x\r",  addr);
d1754 1
a1754 1
	sprintf (buf, "B - %x\r", addr);
d1766 2
a1767 2

  warning ("Can't find breakpoint associated with 0x%x\n", addr);
d1775 1
a1775 3
e7000_command (args, fromtty)
     char *args;
     int fromtty;
d1807 1
a1807 4
e7000_drain_command (args, fromtty)
     char *args;
     int fromtty;

d1811 1
a1811 1
  puts_e7000debug("end\r");
d1814 1
a1814 1
  while ((c = SERIAL_READCHAR (e7000_desc, 1) != SERIAL_TIMEOUT))
d1818 1
a1818 1
	  putchar_e7000(CTRLC);
d1822 1
a1822 1
	printf ("%c", c & 0xff);
d1824 1
a1824 1
	printf ("<%x>", c & 0xff);
d1831 1
a1831 1
why_stop ()
d1833 2
a1834 1
  static  char *strings[NITEMS] = {
d1849 1
a1849 1
  
d1855 1
a1855 1
	  if (c == *(p[i])) 
d1858 2
a1859 2
	      if (*(p[i]) == 0) 
		{ 
d1875 2
a1876 3
int
expect_n (strings)
char **strings;
d1879 1
a1879 1
  int n; 
d1885 1
a1885 1
  for (n = 0; strings[n]; n++) 
d1895 2
a1896 2
      c = SERIAL_READCHAR (e7000_desc, 1);
      if (c == SERIAL_TIMEOUT)
d1903 1
a1903 1
	  int k = getkey();
d1917 1
a1917 1
	  if (c == ptr[i][0]) 
d1932 1
a1932 1
    
d1936 1
a1936 1
	  *buffer ++ = c;
d1940 1
a1940 1
	  if (buffer != saveaway) 
d1943 1
a1943 1
	      printf ("%s", buffer);
d1946 1
a1946 1
	  if (c != SERIAL_TIMEOUT)
d1948 2
a1949 2
	      putchar (c);
	      fflush (stdout);
d1960 1
a1960 1
sub2_from_pc ()
d1966 2
a1967 2
			REGISTER_RAW_SIZE(PC_REGNUM), 
			read_register (PC_REGNUM) -2);
d1969 1
a1969 1
  sprintf (buf2, ".PC %x\r", read_register (PC_REGNUM));
d1978 2
a1979 1
static char *estrings[] = {
d1990 2
a1991 4
static int
e7000_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
d1998 1
d2007 1
a2007 1
	{	 
d2037 24
a2060 8
#ifdef GDB_TARGET_IS_SH
  if  ((sh_processor_type != NULL) && (*(sh_processor_type+2) == '3')) 
     fetch_regs_from_dump (gch, want_sh3_nopc);
  else
     fetch_regs_from_dump (gch, want_nopc);
#else
  fetch_regs_from_dump (gch, want_nopc);
#endif
d2078 2
a2079 2
      write_pc (read_pc ()); /* PC is always off by 2 for breakpoints */
      status->value.sig = TARGET_SIGNAL_TRAP;      
d2082 1
a2082 1
      status->value.sig = TARGET_SIGNAL_TRAP;      
d2087 1
a2087 1
	  status->value.sig = TARGET_SIGNAL_TRAP;      
d2092 1
a2092 1
	  status->value.sig = TARGET_SIGNAL_INT;      
d2099 1
a2099 1
      status->value.sig = TARGET_SIGNAL_UNKNOWN;      
d2102 1
a2102 1
      status->value.sig = TARGET_SIGNAL_ILL;      
d2105 1
a2105 1
      status->value.sig = TARGET_SIGNAL_SEGV;      
d2109 1
a2109 1
      status->value.sig = TARGET_SIGNAL_UNKNOWN;      
d2113 1
a2113 1
      abort ();
d2116 1
a2116 1
  return 0;
d2122 1
a2122 1
e7000_stop ()  
d2130 4
a2133 1
struct target_ops e7000_ops =
d2135 3
a2137 3
  "e7000",
  "Remote Hitachi e7000 target",
  "Use a remote Hitachi e7000 ICE connected by a serial line,\n\
d2143 25
a2167 38
target e7000 foobar",
  e7000_open,			/* to_open */
  e7000_close,			/* to_close */
  0,				/* to_attach */
  e7000_detach,			/* to_detach */
  e7000_resume,			/* to_resume */
  e7000_wait,			/* to_wait */
  e7000_fetch_register,		/* to_fetch_registers */
  e7000_store_register,		/* to_store_registers */
  e7000_prepare_to_store,	/* to_prepare_to_store */
  e7000_xfer_inferior_memory,	/* to_xfer_memory */
  e7000_files_info,		/* to_files_info */
  e7000_insert_breakpoint,	/* to_insert_breakpoint */
  e7000_remove_breakpoint,	/* to_remove_breakpoint */
  0,				/* to_terminal_init */
  0,				/* to_terminal_inferior */
  0,				/* to_terminal_ours_for_output */
  0,				/* to_terminal_ours */
  0,				/* to_terminal_info */
  e7000_kill,			/* to_kill */
  e7000_load,			/* to_load */
  0,				/* to_lookup_symbol */
  e7000_create_inferior,	/* to_create_inferior */
  e7000_mourn_inferior,		/* to_mourn_inferior */
  0,				/* to_can_run */
  0,				/* to_notice_signals */
  0,				/* to_thread_alive */
  e7000_stop,			/* to_stop */
  process_stratum,		/* to_stratum */
  0,				/* next (unused) */
  1,				/* to_has_all_memory */
  1,				/* to_has_memory */
  1,				/* to_has_stack */
  1,				/* to_has_registers */
  1,				/* to_has_execution */
  0,				/* to_sections */
  0,				/* to_sections_end */
  OPS_MAGIC,			/* Always the last thing */
d2170 2
d2173 1
a2173 1
_initialize_remote_e7000 ()
d2175 1
d2178 1
a2178 1
  add_com ("e7000 <command>", class_obscure, e7000_command,
d2181 1
a2181 1
  add_com ("ftplogin <machine> <name> <passwd> <dir>", class_obscure, e7000_login_command,
d2184 1
a2184 1
  add_com ("ftpload <file>", class_obscure, e7000_ftp_command,
d2191 2
a2192 2
				  var_integer, (char *)&use_hard_breakpoints,
				  "Set use of hardware breakpoints for all breakpoints.\n", &setlist),
@


1.1
log
@file remote-e7000.c was initially added on branch CYGNUS.
@
text
@d1 2160
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 2194
/* Remote debugging interface for Renesas E7000 ICE, for GDB

   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003 Free Software Foundation, Inc.

   Contributed by Cygnus Support. 

   Written by Steve Chamberlain for Cygnus Support.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* The E7000 is an in-circuit emulator for the Renesas H8/300-H and
   Renesas-SH processor.  It has serial port and a lan port.  

   The monitor command set makes it difficult to load large ammounts of
   data over the lan without using ftp - so try not to issue load
   commands when communicating over ethernet; use the ftpload command.

   The monitor pauses for a second when dumping srecords to the serial
   line too, so we use a slower per byte mechanism but without the
   startup overhead.  Even so, it's pretty slow... */

#include "defs.h"
#include "gdbcore.h"
#include "gdbarch.h"
#include "inferior.h"
#include "target.h"
#include "value.h"
#include "command.h"
#include "gdb_string.h"
#include "gdbcmd.h"
#include <sys/types.h>
#include "serial.h"
#include "remote-utils.h"
#include "symfile.h"
#include "regcache.h"
#include <time.h>
#include <ctype.h>


#if 1
#define HARD_BREAKPOINTS	/* Now handled by set option. */
#define BC_BREAKPOINTS use_hard_breakpoints
#endif

#define CTRLC 0x03
#define ENQ  0x05
#define ACK  0x06
#define CTRLZ 0x1a

/* This file is used by 2 different targets, sh-elf and h8300. The
   h8300 is not multiarched and doesn't use the registers defined in
   tm-sh.h. To avoid using a macro GDB_TARGET_IS_SH, we do runtime check
   of the target, which requires that these namse below are always
   defined also in the h8300 case. */

#if !defined (PR_REGNUM)
#define PR_REGNUM 	-1
#endif
#if !defined (GBR_REGNUM)
#define GBR_REGNUM 	-1
#endif
#if !defined (VBR_REGNUM)
#define VBR_REGNUM 	-1
#endif
#if !defined (MACH_REGNUM)
#define MACH_REGNUM 	-1
#endif
#if !defined (MACL_REGNUM)
#define MACL_REGNUM 	-1
#endif
#if !defined (SR_REGNUM)
#define SR_REGNUM 	-1
#endif

extern void report_transfer_performance (unsigned long, time_t, time_t);

extern char *sh_processor_type;

/* Local function declarations.  */

static void e7000_close (int);

static void e7000_fetch_register (int);

static void e7000_store_register (int);

static void e7000_command (char *, int);

static void e7000_login_command (char *, int);

static void e7000_ftp_command (char *, int);

static void e7000_drain_command (char *, int);

static void expect (char *);

static void expect_full_prompt (void);

static void expect_prompt (void);

static int e7000_parse_device (char *args, char *dev_name, int baudrate);
/* Variables. */

static struct serial *e7000_desc;

/* Allow user to chose between using hardware breakpoints or memory. */
static int use_hard_breakpoints = 0;	/* use sw breakpoints by default */

/* Nonzero if using the tcp serial driver.  */

static int using_tcp;		/* direct tcp connection to target */
static int using_tcp_remote;	/* indirect connection to target 
				   via tcp to controller */

/* Nonzero if using the pc isa card.  */

static int using_pc;

extern struct target_ops e7000_ops;	/* Forward declaration */

char *ENQSTRING = "\005";

/* Nonzero if some routine (as opposed to the user) wants echoing.
   FIXME: Do this reentrantly with an extra parameter.  */

static int echo;

static int ctrl_c;

static int timeout = 20;

/* Send data to e7000debug.  */

static void
puts_e7000debug (char *buf)
{
  if (!e7000_desc)
    error ("Use \"target e7000 ...\" first.");

  if (remote_debug)
    printf_unfiltered ("Sending %s\n", buf);

  if (serial_write (e7000_desc, buf, strlen (buf)))
    fprintf_unfiltered (gdb_stderr, "serial_write failed: %s\n", safe_strerror (errno));

  /* And expect to see it echoed, unless using the pc interface */
#if 0
  if (!using_pc)
#endif
    expect (buf);
}

static void
putchar_e7000 (int x)
{
  char b[1];

  b[0] = x;
  serial_write (e7000_desc, b, 1);
}

static void
write_e7000 (char *s)
{
  serial_write (e7000_desc, s, strlen (s));
}

static int
normal (int x)
{
  if (x == '\n')
    return '\r';
  return x;
}

/* Read a character from the remote system, doing all the fancy timeout
   stuff.  Handles serial errors and EOF.  If TIMEOUT == 0, and no chars,
   returns -1, else returns next char.  Discards chars > 127.  */

static int
readchar (int timeout)
{
  int c;

  do
    {
      c = serial_readchar (e7000_desc, timeout);
    }
  while (c > 127);

  if (c == SERIAL_TIMEOUT)
    {
      if (timeout == 0)
	return -1;
      echo = 0;
      error ("Timeout reading from remote system.");
    }
  else if (c < 0)
    error ("Serial communication error");

  if (remote_debug)
    {
      putchar_unfiltered (c);
      gdb_flush (gdb_stdout);
    }

  return normal (c);
}

#if 0
char *
tl (int x)
{
  static char b[8][10];
  static int p;

  p++;
  p &= 7;
  if (x >= ' ')
    {
      b[p][0] = x;
      b[p][1] = 0;
    }
  else
    {
      sprintf (b[p], "<%d>", x);
    }

  return b[p];
}
#endif

/* Scan input from the remote system, until STRING is found.  If
   DISCARD is non-zero, then discard non-matching input, else print it
   out.  Let the user break out immediately.  */

static void
expect (char *string)
{
  char *p = string;
  int c;
  int nl = 0;

  while (1)
    {
      c = readchar (timeout);

      if (echo)
	{
	  if (c == '\r' || c == '\n')
	    {
	      if (!nl)
		putchar_unfiltered ('\n');
	      nl = 1;
	    }
	  else
	    {
	      nl = 0;
	      putchar_unfiltered (c);
	    }
	  gdb_flush (gdb_stdout);
	}
      if (normal (c) == normal (*p++))
	{
	  if (*p == '\0')
	    return;
	}
      else
	{
	  p = string;

	  if (normal (c) == normal (string[0]))
	    p++;
	}
    }
}

/* Keep discarding input until we see the e7000 prompt.

   The convention for dealing with the prompt is that you
   o give your command
   o *then* wait for the prompt.

   Thus the last thing that a procedure does with the serial line will
   be an expect_prompt().  Exception: e7000_resume does not wait for
   the prompt, because the terminal is being handed over to the
   inferior.  However, the next thing which happens after that is a
   e7000_wait which does wait for the prompt.  Note that this includes
   abnormal exit, e.g. error().  This is necessary to prevent getting
   into states from which we can't recover.  */

static void
expect_prompt (void)
{
  expect (":");
}

static void
expect_full_prompt (void)
{
  expect ("\r:");
}

static int
convert_hex_digit (int ch)
{
  if (ch >= '0' && ch <= '9')
    return ch - '0';
  else if (ch >= 'A' && ch <= 'F')
    return ch - 'A' + 10;
  else if (ch >= 'a' && ch <= 'f')
    return ch - 'a' + 10;
  return -1;
}

static int
get_hex (int *start)
{
  int value = convert_hex_digit (*start);
  int try;

  *start = readchar (timeout);
  while ((try = convert_hex_digit (*start)) >= 0)
    {
      value <<= 4;
      value += try;
      *start = readchar (timeout);
    }
  return value;
}

#if 0
/* Get N 32-bit words from remote, each preceded by a space, and put
   them in registers starting at REGNO.  */

static void
get_hex_regs (int n, int regno)
{
  long val;
  int i;

  for (i = 0; i < n; i++)
    {
      int j;

      val = 0;
      for (j = 0; j < 8; j++)
	val = (val << 4) + get_hex_digit (j == 0);
      supply_register (regno++, (char *) &val);
    }
}
#endif

/* This is called not only when we first attach, but also when the
   user types "run" after having attached.  */

static void
e7000_create_inferior (char *execfile, char *args, char **env)
{
  int entry_pt;

  if (args && *args)
    error ("Can't pass arguments to remote E7000DEBUG process");

  if (execfile == 0 || exec_bfd == 0)
    error ("No executable file specified");

  entry_pt = (int) bfd_get_start_address (exec_bfd);

#ifdef CREATE_INFERIOR_HOOK
  CREATE_INFERIOR_HOOK (0);	/* No process-ID */
#endif

  /* The "process" (board) is already stopped awaiting our commands, and
     the program is already downloaded.  We just set its PC and go.  */

  clear_proceed_status ();

  /* Tell wait_for_inferior that we've started a new process.  */
  init_wait_for_inferior ();

  /* Set up the "saved terminal modes" of the inferior
     based on what modes we are starting it with.  */
  target_terminal_init ();

  /* Install inferior's terminal modes.  */
  target_terminal_inferior ();

  /* insert_step_breakpoint ();  FIXME, do we need this?  */
  proceed ((CORE_ADDR) entry_pt, -1, 0);	/* Let 'er rip... */
}

/* Open a connection to a remote debugger.  NAME is the filename used
   for communication.  */

static int baudrate = 9600;
static char dev_name[100];

static char *machine = "";
static char *user = "";
static char *passwd = "";
static char *dir = "";

/* Grab the next token and buy some space for it */

static char *
next (char **ptr)
{
  char *p = *ptr;
  char *s;
  char *r;
  int l = 0;

  while (*p && *p == ' ')
    p++;
  s = p;
  while (*p && (*p != ' ' && *p != '\t'))
    {
      l++;
      p++;
    }
  r = xmalloc (l + 1);
  memcpy (r, s, l);
  r[l] = 0;
  *ptr = p;
  return r;
}

static void
e7000_login_command (char *args, int from_tty)
{
  if (args)
    {
      machine = next (&args);
      user = next (&args);
      passwd = next (&args);
      dir = next (&args);
      if (from_tty)
	{
	  printf_unfiltered ("Set info to %s %s %s %s\n", machine, user, passwd, dir);
	}
    }
  else
    {
      error ("Syntax is ftplogin <machine> <user> <passwd> <directory>");
    }
}

/* Start an ftp transfer from the E7000 to a host */

static void
e7000_ftp_command (char *args, int from_tty)
{
  /* FIXME: arbitrary limit on machine names and such.  */
  char buf[200];

  int oldtimeout = timeout;
  timeout = remote_timeout;

  sprintf (buf, "ftp %s\r", machine);
  puts_e7000debug (buf);
  expect (" Username : ");
  sprintf (buf, "%s\r", user);
  puts_e7000debug (buf);
  expect (" Password : ");
  write_e7000 (passwd);
  write_e7000 ("\r");
  expect ("success\r");
  expect ("FTP>");
  sprintf (buf, "cd %s\r", dir);
  puts_e7000debug (buf);
  expect ("FTP>");
  sprintf (buf, "ll 0;s:%s\r", args);
  puts_e7000debug (buf);
  expect ("FTP>");
  puts_e7000debug ("bye\r");
  expect (":");
  timeout = oldtimeout;
}

static int
e7000_parse_device (char *args, char *dev_name, int baudrate)
{
  char junk[128];
  int n = 0;
  if (args && strcasecmp (args, "pc") == 0)
    {
      strcpy (dev_name, args);
      using_pc = 1;
    }
  else
    {
      /* FIXME! temp hack to allow use with port master -
         target tcp_remote <device> */
      if (args && strncmp (args, "tcp", 10) == 0)
	{
	  char com_type[128];
	  n = sscanf (args, " %s %s %d %s", com_type, dev_name, &baudrate, junk);
	  using_tcp_remote = 1;
	  n--;
	}
      else if (args)
	{
	  n = sscanf (args, " %s %d %s", dev_name, &baudrate, junk);
	}

      if (n != 1 && n != 2)
	{
	  error ("Bad arguments.  Usage:\ttarget e7000 <device> <speed>\n\
or \t\ttarget e7000 <host>[:<port>]\n\
or \t\ttarget e7000 tcp_remote <host>[:<port>]\n\
or \t\ttarget e7000 pc\n");
	}

#if !defined(__GO32__) && !defined(_WIN32) && !defined(__CYGWIN__)
      /* FIXME!  test for ':' is ambiguous */
      if (n == 1 && strchr (dev_name, ':') == 0)
	{
	  /* Default to normal telnet port */
	  /* serial_open will use this to determine tcp communication */
	  strcat (dev_name, ":23");
	}
#endif
      if (!using_tcp_remote && strchr (dev_name, ':'))
	using_tcp = 1;
    }

  return n;
}

/* Stub for catch_errors.  */

static int
e7000_start_remote (void *dummy)
{
  int loop;
  int sync;
  int try;
  int quit_trying;

  immediate_quit++;		/* Allow user to interrupt it */

  /* Hello?  Are you there?  */
  sync = 0;
  loop = 0;
  try = 0;
  quit_trying = 20;
  putchar_e7000 (CTRLC);
  while (!sync && ++try <= quit_trying)
    {
      int c;

      printf_unfiltered ("[waiting for e7000...]\n");

      write_e7000 ("\r");
      c = readchar (1);

      /* FIXME!  this didn't seem right->  while (c != SERIAL_TIMEOUT)
       * we get stuck in this loop ...
       * We may never timeout, and never sync up :-(
       */
      while (!sync && c != -1)
	{
	  /* Dont echo cr's */
	  if (c != '\r')
	    {
	      putchar_unfiltered (c);
	      gdb_flush (gdb_stdout);
	    }
	  /* Shouldn't we either break here, or check for sync in inner loop? */
	  if (c == ':')
	    sync = 1;

	  if (loop++ == 20)
	    {
	      putchar_e7000 (CTRLC);
	      loop = 0;
	    }

	  QUIT;

	  if (quit_flag)
	    {
	      putchar_e7000 (CTRLC);
	      /* Was-> quit_flag = 0; */
	      c = -1;
	      quit_trying = try + 1;	/* we don't want to try anymore */
	    }
	  else
	    {
	      c = readchar (1);
	    }
	}
    }

  if (!sync)
    {
      fprintf_unfiltered (gdb_stderr, "Giving up after %d tries...\n", try);
      error ("Unable to synchronize with target.\n");
    }

  puts_e7000debug ("\r");
  expect_prompt ();
  puts_e7000debug ("b -\r");	/* Clear breakpoints */
  expect_prompt ();

  immediate_quit--;

/* This is really the job of start_remote however, that makes an assumption
   that the target is about to print out a status message of some sort.  That
   doesn't happen here. */

  flush_cached_frames ();
  registers_changed ();
  stop_pc = read_pc ();
  print_stack_frame (get_selected_frame (), -1, 1);

  return 1;
}

static void
e7000_open (char *args, int from_tty)
{
  int n;

  target_preopen (from_tty);

  n = e7000_parse_device (args, dev_name, baudrate);

  push_target (&e7000_ops);

  e7000_desc = serial_open (dev_name);

  if (!e7000_desc)
    perror_with_name (dev_name);

  if (serial_setbaudrate (e7000_desc, baudrate))
    {
      serial_close (e7000_desc);
      perror_with_name (dev_name);
    }
  serial_raw (e7000_desc);

  /* Start the remote connection; if error (0), discard this target.
     In particular, if the user quits, be sure to discard it
     (we'd be in an inconsistent state otherwise).  */
  if (!catch_errors (e7000_start_remote, (char *) 0,
       "Couldn't establish connection to remote target\n", RETURN_MASK_ALL))
    if (from_tty)
      printf_filtered ("Remote target %s connected to %s\n", target_shortname,
		       dev_name);
}

/* Close out all files and local state before this target loses control. */

static void
e7000_close (int quitting)
{
  if (e7000_desc)
    {
      serial_close (e7000_desc);
      e7000_desc = 0;
    }
}

/* Terminate the open connection to the remote debugger.  Use this
   when you want to detach and do something else with your gdb.  */

static void
e7000_detach (char *arg, int from_tty)
{
  pop_target ();		/* calls e7000_close to do the real work */
  if (from_tty)
    printf_unfiltered ("Ending remote %s debugging\n", target_shortname);
}

/* Tell the remote machine to resume.  */

static void
e7000_resume (ptid_t ptid, int step, enum target_signal sigal)
{
  if (step)
    puts_e7000debug ("S\r");
  else
    puts_e7000debug ("G\r");
}

/* Read the remote registers into the block REGS.  

   For the H8/300 a register dump looks like:

   PC=00021A  CCR=80:I*******
   ER0 - ER3  0000000A 0000002E 0000002E 00000000
   ER4 - ER7  00000000 00000000 00000000 00FFEFF6
   000218           MOV.B     R1L,R2L
   STEP NORMAL END or
   BREAK POINT
 */

char *want_h8300h = "PC=%p CCR=%c\n\
 ER0 - ER3  %0 %1 %2 %3\n\
 ER4 - ER7  %4 %5 %6 %7\n";

char *want_nopc_h8300h = "%p CCR=%c\n\
 ER0 - ER3  %0 %1 %2 %3\n\
 ER4 - ER7  %4 %5 %6 %7";

char *want_h8300s = "PC=%p CCR=%c\n\
 MACH=\n\
 ER0 - ER3  %0 %1 %2 %3\n\
 ER4 - ER7  %4 %5 %6 %7\n";

char *want_nopc_h8300s = "%p CCR=%c EXR=%9\n\
 ER0 - ER3  %0 %1 %2 %3\n\
 ER4 - ER7  %4 %5 %6 %7";

char *want_sh = "PC=%16 SR=%22\n\
PR=%17 GBR=%18 VBR=%19\n\
MACH=%20 MACL=%21\n\
R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\
R8-15 %8 %9 %10 %11 %12 %13 %14 %15\n";

char *want_nopc_sh = "%16 SR=%22\n\
 PR=%17 GBR=%18 VBR=%19\n\
 MACH=%20 MACL=%21\n\
 R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\
 R8-15 %8 %9 %10 %11 %12 %13 %14 %15";

char *want_sh3 = "PC=%16 SR=%22\n\
PR=%17 GBR=%18 VBR=%19\n\
MACH=%20 MACL=%21 SSR=%23 SPC=%24\n\
R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\
R8-15 %8 %9 %10 %11 %12 %13 %14 %15\n\
R0_BANK0-R3_BANK0 %25 %26 %27 %28\n\
R4_BANK0-R7_BANK0 %29 %30 %31 %32\n\
R0_BANK1-R3_BANK1 %33 %34 %35 %36\n\
R4_BANK1-R7_BANK1 %37 %38 %39 %40";

char *want_nopc_sh3 = "%16 SR=%22\n\
 PR=%17 GBR=%18 VBR=%19\n\
 MACH=%20 MACL=%21 SSR=%22 SPC=%23\n\
 R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\
 R8-15 %8 %9 %10 %11 %12 %13 %14 %15\n\
 R0_BANK0-R3_BANK0 %25 %26 %27 %28\n\
 R4_BANK0-R7_BANK0 %29 %30 %31 %32\n\
 R0_BANK1-R3_BANK1 %33 %34 %35 %36\n\
 R4_BANK1-R7_BANK1 %37 %38 %39 %40";

static int
gch (void)
{
  return readchar (timeout);
}

static unsigned int
gbyte (void)
{
  int high = convert_hex_digit (gch ());
  int low = convert_hex_digit (gch ());

  return (high << 4) + low;
}

static void
fetch_regs_from_dump (int (*nextchar) (), char *want)
{
  int regno;
  char buf[MAX_REGISTER_SIZE];

  int thischar = nextchar ();

  if (want == NULL)
    internal_error (__FILE__, __LINE__, "Register set not selected.");

  while (*want)
    {
      switch (*want)
	{
	case '\n':
	  /* Skip to end of line and then eat all new line type stuff */
	  while (thischar != '\n' && thischar != '\r')
	    thischar = nextchar ();
	  while (thischar == '\n' || thischar == '\r')
	    thischar = nextchar ();
	  want++;
	  break;

	case ' ':
	  while (thischar == ' '
		 || thischar == '\t'
		 || thischar == '\r'
		 || thischar == '\n')
	    thischar = nextchar ();
	  want++;
	  break;

	default:
	  if (*want == thischar)
	    {
	      want++;
	      if (*want)
		thischar = nextchar ();

	    }
	  else if (thischar == ' ' || thischar == '\n' || thischar == '\r')
	    {
	      thischar = nextchar ();
	    }
	  else
	    {
	      error ("out of sync in fetch registers wanted <%s>, got <%c 0x%x>",
		     want, thischar, thischar);
	    }

	  break;
	case '%':
	  /* Got a register command */
	  want++;
	  switch (*want)
	    {
#ifdef PC_REGNUM
	    case 'p':
	      regno = PC_REGNUM;
	      want++;
	      break;
#endif
#ifdef CCR_REGNUM
	    case 'c':
	      regno = CCR_REGNUM;
	      want++;
	      break;
#endif
#ifdef SP_REGNUM
	    case 's':
	      regno = SP_REGNUM;
	      want++;
	      break;
#endif
#ifdef DEPRECATED_FP_REGNUM
	    case 'f':
	      regno = DEPRECATED_FP_REGNUM;
	      want++;
	      break;
#endif

	    default:
	      if (isdigit (want[0]))
		{
		  if (isdigit (want[1]))
		    {
		      regno = (want[0] - '0') * 10 + want[1] - '0';
		      want += 2;
		    }
		  else
		    {
		      regno = want[0] - '0';
		      want++;
		    }
		}

	      else
		internal_error (__FILE__, __LINE__, "failed internal consistency check");
	    }
	  store_signed_integer (buf,
				DEPRECATED_REGISTER_RAW_SIZE (regno),
				(LONGEST) get_hex (&thischar));
	  supply_register (regno, buf);
	  break;
	}
    }
}

static void
e7000_fetch_registers (void)
{
  int regno;
  char *wanted = NULL;

  puts_e7000debug ("R\r");

  if (TARGET_ARCHITECTURE->arch == bfd_arch_sh)
    {
      wanted = want_sh;
      switch (TARGET_ARCHITECTURE->mach)
	{
	case bfd_mach_sh3:
	case bfd_mach_sh3e:
	case bfd_mach_sh4:
	  wanted = want_sh3;
	}
    }
  if (TARGET_ARCHITECTURE->arch == bfd_arch_h8300)
    {
      wanted = want_h8300h;
      switch (TARGET_ARCHITECTURE->mach)
	{
	case bfd_mach_h8300s:
	case bfd_mach_h8300sn:
	case bfd_mach_h8300sx:
	case bfd_mach_h8300sxn:
	  wanted = want_h8300s;
	}
    }

  fetch_regs_from_dump (gch, wanted);

  /* And supply the extra ones the simulator uses */
  for (regno = NUM_REALREGS; regno < NUM_REGS; regno++)
    {
      int buf = 0;

      supply_register (regno, (char *) (&buf));
    }
}

/* Fetch register REGNO, or all registers if REGNO is -1.  Returns
   errno value.  */

static void
e7000_fetch_register (int regno)
{
  e7000_fetch_registers ();
}

/* Store the remote registers from the contents of the block REGS.  */

static void
e7000_store_registers (void)
{
  int regno;

  for (regno = 0; regno < NUM_REALREGS; regno++)
    e7000_store_register (regno);

  registers_changed ();
}

/* Store register REGNO, or all if REGNO == 0.  Return errno value.  */

static void
e7000_store_register (int regno)
{
  char buf[200];

  if (regno == -1)
    {
      e7000_store_registers ();
      return;
    }

  if (TARGET_ARCHITECTURE->arch == bfd_arch_h8300)
    {
      if (regno <= 7)
	{
	  sprintf (buf, ".ER%d %s\r", regno, phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}
      else if (regno == PC_REGNUM)
	{
	  sprintf (buf, ".PC %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}
#ifdef CCR_REGNUM
      else if (regno == CCR_REGNUM)
	{
	  sprintf (buf, ".CCR %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}
#endif
    }

  else if (TARGET_ARCHITECTURE->arch == bfd_arch_sh)
    {
      if (regno == PC_REGNUM)
	{
	  sprintf (buf, ".PC %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}

      else if (regno == SR_REGNUM)
	{
	  sprintf (buf, ".SR %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}

      else if (regno ==  PR_REGNUM)
	{
	  sprintf (buf, ".PR %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}

      else if (regno == GBR_REGNUM)
	{
	  sprintf (buf, ".GBR %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}

      else if (regno == VBR_REGNUM)
	{
	  sprintf (buf, ".VBR %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}

      else if (regno == MACH_REGNUM)
	{
	  sprintf (buf, ".MACH %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}

      else if (regno == MACL_REGNUM)
	{
	  sprintf (buf, ".MACL %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}
      else
	{
	  sprintf (buf, ".R%d %s\r", regno, phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}
    }

  expect_prompt ();
}

/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On machines
   which store all the registers in one fell swoop, this makes sure
   that registers contains all the registers from the program being
   debugged.  */

static void
e7000_prepare_to_store (void)
{
  /* Do nothing, since we can store individual regs */
}

static void
e7000_files_info (struct target_ops *ops)
{
  printf_unfiltered ("\tAttached to %s at %d baud.\n", dev_name, baudrate);
}

static int
stickbyte (char *where, unsigned int what)
{
  static CONST char digs[] = "0123456789ABCDEF";

  where[0] = digs[(what >> 4) & 0xf];
  where[1] = digs[(what & 0xf) & 0xf];

  return what;
}

/* Write a small ammount of memory. */

static int
write_small (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  int i;
  char buf[200];

  for (i = 0; i < len; i++)
    {
      if (((memaddr + i) & 3) == 0 && (i + 3 < len))
	{
	  /* Can be done with a long word */
	  sprintf (buf, "m %s %x%02x%02x%02x;l\r",
		   paddr_nz (memaddr + i),
		   myaddr[i], myaddr[i + 1], myaddr[i + 2], myaddr[i + 3]);
	  puts_e7000debug (buf);
	  i += 3;
	}
      else
	{
	  sprintf (buf, "m %s %x\r", paddr_nz (memaddr + i), myaddr[i]);
	  puts_e7000debug (buf);
	}
    }

  expect_prompt ();

  return len;
}

/* Write a large ammount of memory, this only works with the serial
   mode enabled.  Command is sent as

   il ;s:s\r     ->
   <- il ;s:s\r
   <-   ENQ
   ACK          ->
   <- LO s\r
   Srecords...
   ^Z           ->
   <-   ENQ
   ACK          ->  
   <-   :       
 */

static int
write_large (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  int i;
#define maxstride  128
  int stride;

  puts_e7000debug ("IL ;S:FK\r");
  expect (ENQSTRING);
  putchar_e7000 (ACK);
  expect ("LO FK\r");

  for (i = 0; i < len; i += stride)
    {
      char compose[maxstride * 2 + 50];
      int address = i + memaddr;
      int j;
      int check_sum;
      int where = 0;
      int alen;

      stride = len - i;
      if (stride > maxstride)
	stride = maxstride;

      compose[where++] = 'S';
      check_sum = 0;
      if (address >= 0xffffff)
	alen = 4;
      else if (address >= 0xffff)
	alen = 3;
      else
	alen = 2;
      /* Insert type. */
      compose[where++] = alen - 1 + '0';
      /* Insert length. */
      check_sum += stickbyte (compose + where, alen + stride + 1);
      where += 2;
      while (alen > 0)
	{
	  alen--;
	  check_sum += stickbyte (compose + where, address >> (8 * (alen)));
	  where += 2;
	}

      for (j = 0; j < stride; j++)
	{
	  check_sum += stickbyte (compose + where, myaddr[i + j]);
	  where += 2;
	}
      stickbyte (compose + where, ~check_sum);
      where += 2;
      compose[where++] = '\r';
      compose[where++] = '\n';
      compose[where++] = 0;

      serial_write (e7000_desc, compose, where);
      j = readchar (0);
      if (j == -1)
	{
	  /* This is ok - nothing there */
	}
      else if (j == ENQ)
	{
	  /* Hmm, it's trying to tell us something */
	  expect (":");
	  error ("Error writing memory");
	}
      else
	{
	  printf_unfiltered ("@@%d}@@", j);
	  while ((j = readchar (0)) > 0)
	    {
	      printf_unfiltered ("@@{%d}@@", j);
	    }
	}
    }

  /* Send the trailer record */
  write_e7000 ("S70500000000FA\r");
  putchar_e7000 (CTRLZ);
  expect (ENQSTRING);
  putchar_e7000 (ACK);
  expect (":");

  return len;
}

/* Copy LEN bytes of data from debugger memory at MYADDR to inferior's
   memory at MEMADDR.  Returns length moved.

   Can't use the Srecord load over ethernet, so don't use fast method
   then.  */

static int
e7000_write_inferior_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  if (len < 16 || using_tcp || using_pc)
    return write_small (memaddr, myaddr, len);
  else
    return write_large (memaddr, myaddr, len);
}

/* Read LEN bytes from inferior memory at MEMADDR.  Put the result
   at debugger address MYADDR.  Returns length moved. 

   Small transactions we send
   m <addr>;l
   and receive
   00000000 12345678 ?
 */

static int
e7000_read_inferior_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  int count;
  int c;
  int i;
  char buf[200];
  /* Starting address of this pass.  */

/*  printf("READ INF %x %x %d\n", memaddr, myaddr, len); */
  if (((memaddr - 1) + len) < memaddr)
    {
      errno = EIO;
      return 0;
    }

  sprintf (buf, "m %s;l\r", paddr_nz (memaddr));
  puts_e7000debug (buf);

  for (count = 0; count < len; count += 4)
    {
      /* Suck away the address */
      c = gch ();
      while (c != ' ')
	c = gch ();
      c = gch ();
      if (c == '*')
	{			/* Some kind of error */
	  puts_e7000debug (".\r");	/* Some errors leave us in memory input mode */
	  expect_full_prompt ();
	  return -1;
	}
      while (c != ' ')
	c = gch ();

      /* Now read in the data */
      for (i = 0; i < 4; i++)
	{
	  int b = gbyte ();
	  if (count + i < len)
	    {
	      myaddr[count + i] = b;
	    }
	}

      /* Skip the trailing ? and send a . to end and a cr for more */
      gch ();
      gch ();
      if (count + 4 >= len)
	puts_e7000debug (".\r");
      else
	puts_e7000debug ("\r");

    }
  expect_prompt ();
  return len;
}



/*
   For large transfers we used to send


   d <addr> <endaddr>\r

   and receive
   <ADDRESS>           <    D   A   T   A    >               <   ASCII CODE   >
   00000000 5F FD FD FF DF 7F DF FF  01 00 01 00 02 00 08 04  "_..............."
   00000010 FF D7 FF 7F D7 F1 7F FF  00 05 00 00 08 00 40 00  "..............@@."
   00000020 7F FD FF F7 7F FF FF F7  00 00 00 00 00 00 00 00  "................"

   A cost in chars for each transaction of 80 + 5*n-bytes. 

   Large transactions could be done with the srecord load code, but
   there is a pause for a second before dumping starts, which slows the
   average rate down!
 */

static int
e7000_read_inferior_memory_large (CORE_ADDR memaddr, unsigned char *myaddr,
				  int len)
{
  int count;
  int c;
  char buf[200];

  /* Starting address of this pass.  */

  if (((memaddr - 1) + len) < memaddr)
    {
      errno = EIO;
      return 0;
    }

  sprintf (buf, "d %s %s\r", paddr_nz (memaddr), paddr_nz (memaddr + len - 1));
  puts_e7000debug (buf);

  count = 0;
  c = gch ();

  /* skip down to the first ">" */
  while (c != '>')
    c = gch ();
  /* now skip to the end of that line */
  while (c != '\r')
    c = gch ();
  c = gch ();

  while (count < len)
    {
      /* get rid of any white space before the address */
      while (c <= ' ')
	c = gch ();

      /* Skip the address */
      get_hex (&c);

      /* read in the bytes on the line */
      while (c != '"' && count < len)
	{
	  if (c == ' ')
	    c = gch ();
	  else
	    {
	      myaddr[count++] = get_hex (&c);
	    }
	}
      /* throw out the rest of the line */
      while (c != '\r')
	c = gch ();
    }

  /* wait for the ":" prompt */
  while (c != ':')
    c = gch ();

  return len;
}

#if 0

static int
fast_but_for_the_pause_e7000_read_inferior_memory (CORE_ADDR memaddr,
						   char *myaddr, int len)
{
  int loop;
  int c;
  char buf[200];

  if (((memaddr - 1) + len) < memaddr)
    {
      errno = EIO;
      return 0;
    }

  sprintf (buf, "is %x@@%x:s\r", memaddr, len);
  puts_e7000debug (buf);
  gch ();
  c = gch ();
  if (c != ENQ)
    {
      /* Got an error */
      error ("Memory read error");
    }
  putchar_e7000 (ACK);
  expect ("SV s");
  loop = 1;
  while (loop)
    {
      int type;
      int length;
      int addr;
      int i;

      c = gch ();
      switch (c)
	{
	case ENQ:		/* ENQ, at the end */
	  loop = 0;
	  break;
	case 'S':
	  /* Start of an Srecord */
	  type = gch ();
	  length = gbyte ();
	  switch (type)
	    {
	    case '7':		/* Termination record, ignore */
	    case '0':
	    case '8':
	    case '9':
	      /* Header record - ignore it */
	      while (length--)
		{
		  gbyte ();
		}
	      break;
	    case '1':
	    case '2':
	    case '3':
	      {
		int alen;

		alen = type - '0' + 1;
		addr = 0;
		while (alen--)
		  {
		    addr = (addr << 8) + gbyte ();
		    length--;
		  }

		for (i = 0; i < length - 1; i++)
		  myaddr[i + addr - memaddr] = gbyte ();

		gbyte ();	/* Ignore checksum */
	      }
	    }
	}
    }

  putchar_e7000 (ACK);
  expect ("TOP ADDRESS =");
  expect ("END ADDRESS =");
  expect (":");

  return len;
}

#endif

/* Transfer LEN bytes between GDB address MYADDR and target address
   MEMADDR.  If WRITE is non-zero, transfer them to the target,
   otherwise transfer them from the target.  TARGET is unused.

   Returns the number of bytes transferred. */

static int
e7000_xfer_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len,
			    int write, struct mem_attrib *attrib,
			    struct target_ops *target)
{
  if (write)
    return e7000_write_inferior_memory (memaddr, myaddr, len);
  else if (len < 16)
    return e7000_read_inferior_memory (memaddr, myaddr, len);
  else
    return e7000_read_inferior_memory_large (memaddr, myaddr, len);
}

static void
e7000_kill (void)
{
}

static void
e7000_load (char *args, int from_tty)
{
  struct cleanup *old_chain;
  asection *section;
  bfd *pbfd;
  bfd_vma entry;
#define WRITESIZE 0x1000
  char buf[2 + 4 + 4 + WRITESIZE];	/* `DT' + <addr> + <len> + <data> */
  char *filename;
  int quiet;
  int nostart;
  time_t start_time, end_time;	/* Start and end times of download */
  unsigned long data_count;	/* Number of bytes transferred to memory */
  int oldtimeout = timeout;

  timeout = remote_timeout;


  /* FIXME! change test to test for type of download */
  if (!using_tcp)
    {
      generic_load (args, from_tty);
      return;
    }

  /* for direct tcp connections, we can do a fast binary download */
  buf[0] = 'D';
  buf[1] = 'T';
  quiet = 0;
  nostart = 0;
  filename = NULL;

  while (*args != '\000')
    {
      char *arg;

      while (isspace (*args))
	args++;

      arg = args;

      while ((*args != '\000') && !isspace (*args))
	args++;

      if (*args != '\000')
	*args++ = '\000';

      if (*arg != '-')
	filename = arg;
      else if (strncmp (arg, "-quiet", strlen (arg)) == 0)
	quiet = 1;
      else if (strncmp (arg, "-nostart", strlen (arg)) == 0)
	nostart = 1;
      else
	error ("unknown option `%s'", arg);
    }

  if (!filename)
    filename = get_exec_file (1);

  pbfd = bfd_openr (filename, gnutarget);
  if (pbfd == NULL)
    {
      perror_with_name (filename);
      return;
    }
  old_chain = make_cleanup_bfd_close (pbfd);

  if (!bfd_check_format (pbfd, bfd_object))
    error ("\"%s\" is not an object file: %s", filename,
	   bfd_errmsg (bfd_get_error ()));

  start_time = time (NULL);
  data_count = 0;

  puts_e7000debug ("mw\r");

  expect ("\nOK");

  for (section = pbfd->sections; section; section = section->next)
    {
      if (bfd_get_section_flags (pbfd, section) & SEC_LOAD)
	{
	  bfd_vma section_address;
	  bfd_size_type section_size;
	  file_ptr fptr;

	  section_address = bfd_get_section_vma (pbfd, section);
	  section_size = bfd_get_section_size_before_reloc (section);

	  if (!quiet)
	    printf_filtered ("[Loading section %s at 0x%s (%s bytes)]\n",
			     bfd_get_section_name (pbfd, section),
			     paddr_nz (section_address),
			     paddr_u (section_size));

	  fptr = 0;

	  data_count += section_size;

	  while (section_size > 0)
	    {
	      int count;
	      static char inds[] = "|/-\\";
	      static int k = 0;

	      QUIT;

	      count = min (section_size, WRITESIZE);

	      buf[2] = section_address >> 24;
	      buf[3] = section_address >> 16;
	      buf[4] = section_address >> 8;
	      buf[5] = section_address;

	      buf[6] = count >> 24;
	      buf[7] = count >> 16;
	      buf[8] = count >> 8;
	      buf[9] = count;

	      bfd_get_section_contents (pbfd, section, buf + 10, fptr, count);

	      if (serial_write (e7000_desc, buf, count + 10))
		fprintf_unfiltered (gdb_stderr,
				    "e7000_load: serial_write failed: %s\n",
				    safe_strerror (errno));

	      expect ("OK");

	      if (!quiet)
		{
		  printf_unfiltered ("\r%c", inds[k++ % 4]);
		  gdb_flush (gdb_stdout);
		}

	      section_address += count;
	      fptr += count;
	      section_size -= count;
	    }
	}
    }

  write_e7000 ("ED");

  expect_prompt ();

  end_time = time (NULL);

/* Finally, make the PC point at the start address */

  if (exec_bfd)
    write_pc (bfd_get_start_address (exec_bfd));

  inferior_ptid = null_ptid;	/* No process now */

/* This is necessary because many things were based on the PC at the time that
   we attached to the monitor, which is no longer valid now that we have loaded
   new code (and just changed the PC).  Another way to do this might be to call
   normal_stop, except that the stack may not be valid, and things would get
   horribly confused... */

  clear_symtab_users ();

  if (!nostart)
    {
      entry = bfd_get_start_address (pbfd);

      if (!quiet)
	printf_unfiltered ("[Starting %s at 0x%s]\n", filename, paddr_nz (entry));

/*      start_routine (entry); */
    }

  report_transfer_performance (data_count, start_time, end_time);

  do_cleanups (old_chain);
  timeout = oldtimeout;
}

/* Clean up when a program exits.

   The program actually lives on in the remote processor's RAM, and may be
   run again without a download.  Don't leave it full of breakpoint
   instructions.  */

static void
e7000_mourn_inferior (void)
{
  remove_breakpoints ();
  unpush_target (&e7000_ops);
  generic_mourn_inferior ();	/* Do all the proper things now */
}

#define MAX_BREAKPOINTS 200
#ifdef  HARD_BREAKPOINTS
#define MAX_E7000DEBUG_BREAKPOINTS (BC_BREAKPOINTS ? 5 :  MAX_BREAKPOINTS)
#else
#define MAX_E7000DEBUG_BREAKPOINTS MAX_BREAKPOINTS
#endif

/* Since we can change to soft breakpoints dynamically, we must define 
   more than enough.  Was breakaddr[MAX_E7000DEBUG_BREAKPOINTS]. */
static CORE_ADDR breakaddr[MAX_BREAKPOINTS] =
{0};

static int
e7000_insert_breakpoint (CORE_ADDR addr, char *shadow)
{
  int i;
  char buf[200];
#if 0
  static char nop[2] = NOP;
#endif

  for (i = 0; i <= MAX_E7000DEBUG_BREAKPOINTS; i++)
    if (breakaddr[i] == 0)
      {
	breakaddr[i] = addr;
	/* Save old contents, and insert a nop in the space */
#ifdef HARD_BREAKPOINTS
	if (BC_BREAKPOINTS)
	  {
	    sprintf (buf, "BC%d A=%s\r", i + 1, paddr_nz (addr));
	    puts_e7000debug (buf);
	  }
	else
	  {
	    sprintf (buf, "B %s\r", paddr_nz (addr));
	    puts_e7000debug (buf);
	  }
#else
#if 0
	e7000_read_inferior_memory (addr, shadow, 2);
	e7000_write_inferior_memory (addr, nop, 2);
#endif

	sprintf (buf, "B %x\r", addr);
	puts_e7000debug (buf);
#endif
	expect_prompt ();
	return 0;
      }

  error ("Too many breakpoints ( > %d) for the E7000\n",
	 MAX_E7000DEBUG_BREAKPOINTS);
  return 1;
}

static int
e7000_remove_breakpoint (CORE_ADDR addr, char *shadow)
{
  int i;
  char buf[200];

  for (i = 0; i < MAX_E7000DEBUG_BREAKPOINTS; i++)
    if (breakaddr[i] == addr)
      {
	breakaddr[i] = 0;
#ifdef HARD_BREAKPOINTS
	if (BC_BREAKPOINTS)
	  {
	    sprintf (buf, "BC%d - \r", i + 1);
	    puts_e7000debug (buf);
	  }
	else
	  {
	    sprintf (buf, "B - %s\r", paddr_nz (addr));
	    puts_e7000debug (buf);
	  }
	expect_prompt ();
#else
	sprintf (buf, "B - %s\r", paddr_nz (addr));
	puts_e7000debug (buf);
	expect_prompt ();

#if 0
	/* Replace the insn under the break */
	e7000_write_inferior_memory (addr, shadow, 2);
#endif
#endif

	return 0;
      }
 
  warning ("Can't find breakpoint associated with 0x%s\n", paddr_nz (addr));
  return 1;
}

/* Put a command string, in args, out to STDBUG.  Output from STDBUG
   is placed on the users terminal until the prompt is seen. */

static void
e7000_command (char *args, int fromtty)
{
  /* FIXME: arbitrary limit on length of args.  */
  char buf[200];

  echo = 0;

  if (!e7000_desc)
    error ("e7000 target not open.");
  if (!args)
    {
      puts_e7000debug ("\r");
    }
  else
    {
      sprintf (buf, "%s\r", args);
      puts_e7000debug (buf);
    }

  echo++;
  ctrl_c = 2;
  expect_full_prompt ();
  echo--;
  ctrl_c = 0;
  printf_unfiltered ("\n");

  /* Who knows what the command did... */
  registers_changed ();
}


static void
e7000_drain_command (char *args, int fromtty)
{
  int c;

  puts_e7000debug ("end\r");
  putchar_e7000 (CTRLC);

  while ((c = readchar (1)) != -1)
    {
      if (quit_flag)
	{
	  putchar_e7000 (CTRLC);
	  quit_flag = 0;
	}
      if (c > ' ' && c < 127)
	printf_unfiltered ("%c", c & 0xff);
      else
	printf_unfiltered ("<%x>", c & 0xff);
    }
}

#define NITEMS 7

static int
why_stop (void)
{
  static char *strings[NITEMS] =
  {
    "STEP NORMAL",
    "BREAK POINT",
    "BREAK KEY",
    "BREAK CONDI",
    "CYCLE ACCESS",
    "ILLEGAL INSTRUCTION",
    "WRITE PROTECT",
  };
  char *p[NITEMS];
  int c;
  int i;

  for (i = 0; i < NITEMS; ++i)
    p[i] = strings[i];

  c = gch ();
  while (1)
    {
      for (i = 0; i < NITEMS; i++)
	{
	  if (c == *(p[i]))
	    {
	      p[i]++;
	      if (*(p[i]) == 0)
		{
		  /* found one of the choices */
		  return i;
		}
	    }
	  else
	    p[i] = strings[i];
	}

      c = gch ();
    }
}

/* Suck characters, if a string match, then return the strings index
   otherwise echo them.  */

static int
expect_n (char **strings)
{
  char *(ptr[10]);
  int n;
  int c;
  char saveaway[100];
  char *buffer = saveaway;
  /* Count number of expect strings  */

  for (n = 0; strings[n]; n++)
    {
      ptr[n] = strings[n];
    }

  while (1)
    {
      int i;
      int gotone = 0;

      c = readchar (1);
      if (c == -1)
	{
	  printf_unfiltered ("[waiting for e7000...]\n");
	}
#ifdef __GO32__
      if (kbhit ())
	{
	  int k = getkey ();

	  if (k == 1)
	    quit_flag = 1;
	}
#endif
      if (quit_flag)
	{
	  putchar_e7000 (CTRLC);	/* interrupt the running program */
	  quit_flag = 0;
	}

      for (i = 0; i < n; i++)
	{
	  if (c == ptr[i][0])
	    {
	      ptr[i]++;
	      if (ptr[i][0] == 0)
		{
		  /* Gone all the way */
		  return i;
		}
	      gotone = 1;
	    }
	  else
	    {
	      ptr[i] = strings[i];
	    }
	}

      if (gotone)
	{
	  /* Save it up incase we find that there was no match */
	  *buffer++ = c;
	}
      else
	{
	  if (buffer != saveaway)
	    {
	      *buffer++ = 0;
	      printf_unfiltered ("%s", buffer);
	      buffer = saveaway;
	    }
	  if (c != -1)
	    {
	      putchar_unfiltered (c);
	      gdb_flush (gdb_stdout);
	    }
	}
    }
}

/* We subtract two from the pc here rather than use
   DECR_PC_AFTER_BREAK since the e7000 doesn't always add two to the
   pc, and the simulators never do. */

static void
sub2_from_pc (void)
{
  char buf[4];
  char buf2[200];

  store_signed_integer (buf,
			DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM),
			read_register (PC_REGNUM) - 2);
  supply_register (PC_REGNUM, buf);
  sprintf (buf2, ".PC %s\r", phex_nz (read_register (PC_REGNUM), 0));
  puts_e7000debug (buf2);
}

#define WAS_SLEEP 0
#define WAS_INT 1
#define WAS_RUNNING 2
#define WAS_OTHER 3

static char *estrings[] =
{
  "** SLEEP",
  "BREAK !",
  "** PC",
  "PC",
  NULL
};

/* Wait until the remote machine stops, then return, storing status in
   STATUS just as `wait' would.  */

static ptid_t
e7000_wait (ptid_t ptid, struct target_waitstatus *status)
{
  int stop_reason;
  int regno;
  int running_count = 0;
  int had_sleep = 0;
  int loop = 1;
  char *wanted_nopc = NULL;

  /* Then echo chars until PC= string seen */
  gch ();			/* Drop cr */
  gch ();			/* and space */

  while (loop)
    {
      switch (expect_n (estrings))
	{
	case WAS_OTHER:
	  /* how did this happen ? */
	  loop = 0;
	  break;
	case WAS_SLEEP:
	  had_sleep = 1;
	  putchar_e7000 (CTRLC);
	  loop = 0;
	  break;
	case WAS_INT:
	  loop = 0;
	  break;
	case WAS_RUNNING:
	  running_count++;
	  if (running_count == 20)
	    {
	      printf_unfiltered ("[running...]\n");
	      running_count = 0;
	    }
	  break;
	default:
	  /* error? */
	  break;
	}
    }

  /* Skip till the PC= */
  expect ("=");

  if (TARGET_ARCHITECTURE->arch == bfd_arch_sh)
    {
      wanted_nopc = want_nopc_sh;
      switch (TARGET_ARCHITECTURE->mach)
	{
	case bfd_mach_sh3:
	case bfd_mach_sh3e:
	case bfd_mach_sh4:
	  wanted_nopc = want_nopc_sh3;
	}
    }
  if (TARGET_ARCHITECTURE->arch == bfd_arch_h8300)
    {
      wanted_nopc = want_nopc_h8300h;
      switch (TARGET_ARCHITECTURE->mach)
	{
	case bfd_mach_h8300s:
	case bfd_mach_h8300sn:
	case bfd_mach_h8300sx:
	case bfd_mach_h8300sxn:
	  wanted_nopc = want_nopc_h8300s;
	}
    }
  fetch_regs_from_dump (gch, wanted_nopc);

  /* And supply the extra ones the simulator uses */
  for (regno = NUM_REALREGS; regno < NUM_REGS; regno++)
    {
      int buf = 0;
      supply_register (regno, (char *) &buf);
    }

  stop_reason = why_stop ();
  expect_full_prompt ();

  status->kind = TARGET_WAITKIND_STOPPED;
  status->value.sig = TARGET_SIGNAL_TRAP;

  switch (stop_reason)
    {
    case 1:			/* Breakpoint */
      write_pc (read_pc ());	/* PC is always off by 2 for breakpoints */
      status->value.sig = TARGET_SIGNAL_TRAP;
      break;
    case 0:			/* Single step */
      status->value.sig = TARGET_SIGNAL_TRAP;
      break;
    case 2:			/* Interrupt */
      if (had_sleep)
	{
	  status->value.sig = TARGET_SIGNAL_TRAP;
	  sub2_from_pc ();
	}
      else
	{
	  status->value.sig = TARGET_SIGNAL_INT;
	}
      break;
    case 3:
      break;
    case 4:
      printf_unfiltered ("a cycle address error?\n");
      status->value.sig = TARGET_SIGNAL_UNKNOWN;
      break;
    case 5:
      status->value.sig = TARGET_SIGNAL_ILL;
      break;
    case 6:
      status->value.sig = TARGET_SIGNAL_SEGV;
      break;
    case 7:			/* Anything else (NITEMS + 1) */
      printf_unfiltered ("a write protect error?\n");
      status->value.sig = TARGET_SIGNAL_UNKNOWN;
      break;
    default:
      /* Get the user's attention - this should never happen. */
      internal_error (__FILE__, __LINE__, "failed internal consistency check");
    }

  return inferior_ptid;
}

/* Stop the running program.  */

static void
e7000_stop (void)
{
  /* Sending a ^C is supposed to stop the running program.  */
  putchar_e7000 (CTRLC);
}

/* Define the target subroutine names. */

struct target_ops e7000_ops;

static void
init_e7000_ops (void)
{
  e7000_ops.to_shortname = "e7000";
  e7000_ops.to_longname = "Remote Renesas e7000 target";
  e7000_ops.to_doc = "Use a remote Renesas e7000 ICE connected by a serial line;\n\
or a network connection.\n\
Arguments are the name of the device for the serial line,\n\
the speed to connect at in bits per second.\n\
eg\n\
target e7000 /dev/ttya 9600\n\
target e7000 foobar";
  e7000_ops.to_open = e7000_open;
  e7000_ops.to_close = e7000_close;
  e7000_ops.to_detach = e7000_detach;
  e7000_ops.to_resume = e7000_resume;
  e7000_ops.to_wait = e7000_wait;
  e7000_ops.to_fetch_registers = e7000_fetch_register;
  e7000_ops.to_store_registers = e7000_store_register;
  e7000_ops.to_prepare_to_store = e7000_prepare_to_store;
  e7000_ops.to_xfer_memory = e7000_xfer_inferior_memory;
  e7000_ops.to_files_info = e7000_files_info;
  e7000_ops.to_insert_breakpoint = e7000_insert_breakpoint;
  e7000_ops.to_remove_breakpoint = e7000_remove_breakpoint;
  e7000_ops.to_kill = e7000_kill;
  e7000_ops.to_load = e7000_load;
  e7000_ops.to_create_inferior = e7000_create_inferior;
  e7000_ops.to_mourn_inferior = e7000_mourn_inferior;
  e7000_ops.to_stop = e7000_stop;
  e7000_ops.to_stratum = process_stratum;
  e7000_ops.to_has_all_memory = 1;
  e7000_ops.to_has_memory = 1;
  e7000_ops.to_has_stack = 1;
  e7000_ops.to_has_registers = 1;
  e7000_ops.to_has_execution = 1;
  e7000_ops.to_magic = OPS_MAGIC;
};

extern initialize_file_ftype _initialize_remote_e7000; /* -Wmissing-prototypes */

void
_initialize_remote_e7000 (void)
{
  init_e7000_ops ();
  add_target (&e7000_ops);

  add_com ("e7000", class_obscure, e7000_command,
	   "Send a command to the e7000 monitor.");

  add_com ("ftplogin", class_obscure, e7000_login_command,
	   "Login to machine and change to directory.");

  add_com ("ftpload", class_obscure, e7000_ftp_command,
	   "Fetch and load a file from previously described place.");

  add_com ("drain", class_obscure, e7000_drain_command,
	   "Drain pending e7000 text buffers.");

  add_show_from_set (add_set_cmd ("usehardbreakpoints", no_class,
				var_integer, (char *) &use_hard_breakpoints,
	"Set use of hardware breakpoints for all breakpoints.\n", &setlist),
		     &showlist);
}
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d4 1
a4 1
   2002, 2003, 2004 Free Software Foundation, Inc.
d365 1
a365 1
      regcache_raw_supply (current_regcache, regno++, (char *) &val);
d374 1
a374 2
e7000_create_inferior (char *execfile, char *args, char **env,
		       int from_tty)
d632 1
a632 1
  print_stack_frame (get_selected_frame (), 0, SRC_AND_LOC);
d881 1
a881 1
				register_size (current_gdbarch, regno),
d883 1
a883 1
	  regcache_raw_supply (current_regcache, regno, buf);
d928 1
a928 1
      regcache_raw_supply (current_regcache, regno, (char *) (&buf));
d1571 1
a1571 1
	  section_size = bfd_get_section_size (section);
d1966 1
a1966 1
			register_size (current_gdbarch, PC_REGNUM),
d1968 1
a1968 1
  regcache_raw_supply (current_regcache, PC_REGNUM, buf);
d2066 1
a2066 1
      regcache_raw_supply (current_regcache, regno, (char *) &buf);
d2152 1
a2152 1
  e7000_ops.deprecated_xfer_memory = e7000_xfer_inferior_memory;
d2190 4
a2193 5
  deprecated_add_show_from_set
    (add_set_cmd ("usehardbreakpoints", no_class,
		  var_integer, (char *) &use_hard_breakpoints, "\
Set use of hardware breakpoints for all breakpoints.\n", &setlist),
     &showlist);
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 2160
/* Remote debugging interface for Hitachi E7000 ICE, for GDB
   Copyright 1993, 1994, 1996 Free Software Foundation, Inc.
   Contributed by Cygnus Support. 

   Written by Steve Chamberlain for Cygnus Support.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* The E7000 is an in-circuit emulator for the Hitachi H8/300-H and
   Hitachi-SH processor.  It has serial port and a lan port.  

   The monitor command set makes it difficult to load large ammounts of
   data over the lan without using ftp - so try not to issue load
   commands when communicating over ethernet; use the ftpload command.

   The monitor pauses for a second when dumping srecords to the serial
   line too, so we use a slower per byte mechanism but without the
   startup overhead.  Even so, it's pretty slow... */

#include "defs.h"
#include "gdbcore.h"
#include "inferior.h"
#include "target.h"
#include "wait.h"
#include "value.h"
#include "command.h"
#include <signal.h>
#include "gdb_string.h"
#include "gdbcmd.h"
#include <sys/types.h>
#include "serial.h"
#include "remote-utils.h"
#include "symfile.h"
#include <time.h>

#if 1
#define HARD_BREAKPOINTS	/* Now handled by set option. */
#define BC_BREAKPOINTS use_hard_breakpoints
#endif

#define CTRLC 0x03
#define ENQ  0x05
#define ACK  0x06
#define CTRLZ 0x1a

extern void report_transfer_performance PARAMS ((unsigned long,
						 time_t, time_t));

extern char *sh_processor_type;

/* Local function declarations.  */

static void e7000_close PARAMS ((int));

static void e7000_fetch_register PARAMS ((int));

static void e7000_store_register PARAMS ((int));

static void e7000_command PARAMS ((char *, int));

static void e7000_login_command PARAMS ((char *, int));

static void e7000_ftp_command PARAMS ((char *, int));

static void e7000_drain_command PARAMS ((char *, int));

static void expect PARAMS ((char *));

static void expect_full_prompt PARAMS ((void));

static void expect_prompt PARAMS ((void));

/* Variables. */

static serial_t e7000_desc;

/* Allow user to chose between using hardware breakpoints or memory. */
static int use_hard_breakpoints = 0; /* use sw breakpoints by default */

/* Nonzero if using the tcp serial driver.  */

static int using_tcp;	/* direct tcp connection to target */
static int using_tcp_remote;	/* indirect connection to target 
				   via tcp to controller */

/* Nonzero if using the pc isa card.  */

static int using_pc;

extern struct target_ops e7000_ops;	/* Forward declaration */

char *ENQSTRING = "\005";

/* Nonzero if some routine (as opposed to the user) wants echoing.
   FIXME: Do this reentrantly with an extra parameter.  */

static int echo;

static int ctrl_c;

static int timeout = 20;

/* Send data to e7000debug.  */

static void
puts_e7000debug (buf)
     char *buf;
{
  if (!e7000_desc)
    error ("Use \"target e7000 ...\" first.");

  if (remote_debug)
    printf("Sending %s\n", buf);

  if (SERIAL_WRITE (e7000_desc, buf, strlen (buf)))
    fprintf (stderr, "SERIAL_WRITE failed: %s\n", safe_strerror (errno));

  /* And expect to see it echoed, unless using the pc interface */
#if 0
  if (!using_pc)
#endif
    expect (buf);
}

static void
putchar_e7000 (x)
     int x;
{
  char b[1];

  b[0] = x;
  SERIAL_WRITE (e7000_desc, b, 1);
}

static void
write_e7000 (s)
     char *s;
{
  SERIAL_WRITE (e7000_desc, s, strlen (s));
}

static int
normal (x)
     int x;
{
  if (x == '\n')
    return '\r';
  return x;
}

/* Read a character from the remote system, doing all the fancy timeout
   stuff.  */

static int
readchar (timeout)
     int timeout;
{
  int c;

  do
    {
      c = SERIAL_READCHAR (e7000_desc, timeout);
    }
  while (c > 127);

  if (c == SERIAL_TIMEOUT)
    {
      if (timeout == 0)
	return -1;
      echo = 0;
      error ("Timeout reading from remote system.");
    }
  if (remote_debug) 
    {
      putchar (c);
      fflush (stdout);
    }

  return normal (c);
}

#if 0
char *
tl (x)
{
  static char b[8][10];
  static int p;

  p++;
  p &= 7;
  if (x >= ' ') 
    { 
      b[p][0] = x;
      b[p][1] = 0;
    }
  else
    {
      sprintf(b[p], "<%d>", x);
    }

  return b[p];
}
#endif

/* Scan input from the remote system, until STRING is found.  If
   DISCARD is non-zero, then discard non-matching input, else print it
   out.  Let the user break out immediately.  */

static void
expect (string)
     char *string;
{
  char *p = string;
  int c;
  int nl = 0;

  while (1)
    {
      c = readchar (timeout);
      notice_quit ();
      if (quit_flag == 1) 
	{
	  if (ctrl_c)
	    {
	      putchar_e7000(CTRLC);
	      --ctrl_c;
	    }
	  else 
	    {
	      quit ();
	    }
	}
      
      if (c == SERIAL_ERROR)
	{
	  error ("Serial communication error");
	}
      if (echo || remote_debug)
	{
	  if (c == '\r' || c == '\n')
	    {
	      if (!nl)
		putchar ('\n');
	      nl = 1;
	    }
	  else
	    {
	      nl = 0;
	      putchar (c);
	    }
	  fflush (stdout);
	}
      if (normal (c) == normal (*p++))
	{
	  if (*p == '\0')
	    return;
	}
      else
	{
	  p = string;

	  if (normal (c) == normal (string[0]))
	    p++;
	}
    }
}

/* Keep discarding input until we see the e7000 prompt.

   The convention for dealing with the prompt is that you
   o give your command
   o *then* wait for the prompt.

   Thus the last thing that a procedure does with the serial line will
   be an expect_prompt().  Exception: e7000_resume does not wait for
   the prompt, because the terminal is being handed over to the
   inferior.  However, the next thing which happens after that is a
   e7000_wait which does wait for the prompt.  Note that this includes
   abnormal exit, e.g. error().  This is necessary to prevent getting
   into states from which we can't recover.  */

static void
expect_prompt ()
{
  expect (":");
}

static void
expect_full_prompt ()
{
  expect ("\r:");
}

static int
convert_hex_digit (ch)
     int ch;
{
  if (ch >= '0' && ch <= '9')
    return ch - '0';
  else if (ch >= 'A' && ch <= 'F')
    return ch - 'A' + 10;
  else if (ch >= 'a' && ch <= 'f')
    return ch - 'a' + 10;
  return -1;
}

static int
get_hex (start)
     int *start;
{
  int value = convert_hex_digit (*start);
  int try;

  *start = readchar (timeout);
  while ((try = convert_hex_digit (*start)) >= 0)
    {
      value <<= 4;
      value += try;
      *start = readchar (timeout);
    }
  return value;
}

#if 0
/* Get N 32-bit words from remote, each preceded by a space, and put
   them in registers starting at REGNO.  */

static void
get_hex_regs (n, regno)
     int n;
     int regno;
{
  long val;
  int i;

  for (i = 0; i < n; i++)
    {
      int j;

      val = 0;
      for (j = 0; j < 8; j++)
	val = (val << 4) + get_hex_digit (j == 0);
      supply_register (regno++, (char *) &val);
    }
}
#endif

/* This is called not only when we first attach, but also when the
   user types "run" after having attached.  */

static void
e7000_create_inferior (execfile, args, env)
     char *execfile;
     char *args;
     char **env;
{
  int entry_pt;

  if (args && *args)
    error ("Can't pass arguments to remote E7000DEBUG process");

  if (execfile == 0 || exec_bfd == 0)
    error ("No exec file specified");

  entry_pt = (int) bfd_get_start_address (exec_bfd);

#ifdef CREATE_INFERIOR_HOOK
  CREATE_INFERIOR_HOOK (0);	/* No process-ID */
#endif

  /* The "process" (board) is already stopped awaiting our commands, and
     the program is already downloaded.  We just set its PC and go.  */

  clear_proceed_status ();

  /* Tell wait_for_inferior that we've started a new process.  */
  init_wait_for_inferior ();

  /* Set up the "saved terminal modes" of the inferior
     based on what modes we are starting it with.  */
  target_terminal_init ();

  /* Install inferior's terminal modes.  */
  target_terminal_inferior ();

  /* insert_step_breakpoint ();  FIXME, do we need this?  */
  proceed ((CORE_ADDR) entry_pt, -1, 0);	/* Let 'er rip... */
}

/* Open a connection to a remote debugger.  NAME is the filename used
   for communication.  */

static int baudrate = 9600;
static char dev_name[100];

static char *machine = "";
static char *user = "";
static char *passwd = "";
static char *dir = "";

/* Grab the next token and buy some space for it */

static char *
next (ptr)
     char **ptr;
{
  char *p = *ptr;
  char *s;
  char *r;
  int l = 0;

  while (*p && *p == ' ')
    p++;
  s = p;
  while (*p && (*p != ' ' && *p != '\t'))
    {
      l++;
      p++;
    }
  r = xmalloc (l + 1);
  memcpy (r, s, l);
  r[l] = 0;
  *ptr = p;
  return r;
}

static void
e7000_login_command (args, from_tty)
     char *args;
     int from_tty;
{
  if (args)
    {
      machine = next (&args);
      user = next (&args);
      passwd = next (&args);
      dir = next (&args);
      if (from_tty)
	{
	  printf ("Set info to %s %s %s %s\n", machine, user, passwd, dir);
	}
    }
  else
    {
      error ("Syntax is ftplogin <machine> <user> <passwd> <directory>");
    }
}

/* Start an ftp transfer from the E7000 to a host */

static void
e7000_ftp_command (args, from_tty)
     char *args;
     int from_tty;
{
  /* FIXME: arbitrary limit on machine names and such.  */
  char buf[200];

  int oldtimeout = timeout;
  timeout = remote_timeout;

  sprintf (buf, "ftp %s\r", machine);
  puts_e7000debug (buf);
  expect (" Username : ");
  sprintf (buf, "%s\r", user);
  puts_e7000debug (buf);
  expect (" Password : ");
  write_e7000 (passwd);
  write_e7000 ("\r");
  expect ("success\r");
  expect ("FTP>");
  sprintf (buf, "cd %s\r", dir);
  puts_e7000debug (buf);
  expect ("FTP>");
  sprintf (buf, "ll 0;s:%s\r", args);
  puts_e7000debug (buf);
  expect ("FTP>");
  puts_e7000debug ("bye\r");
  expect (":");
  timeout = oldtimeout;
}

static int 
e7000_parse_device(args,dev_name,serial_flag,baudrate) 
    char *args;
    char *dev_name;
    int serial_flag;
    int baudrate;
{
  char junk[128];
  int n = 0;
  if (args && strcasecmp (args, "pc") == 0)
    {
      strcpy (dev_name, args);
      using_pc = 1;
    }
  else 
    {
      /* FIXME! temp hack to allow use with port master -
	     target tcp_remote <device> */
      if (args && strncmp (args, "tcp_remote", 10) == 0) 
        {
	  char com_type[128];
	  n = sscanf (args, " %s %s %d %s", com_type, dev_name, &baudrate, junk);
	  using_tcp_remote=1;
	  n--;
        }
      else if (args) 
	{
	  n = sscanf (args, " %s %d %s", dev_name, &baudrate, junk);
	}

      if (n != 1 && n != 2)
	{
	  error ("Bad arguments.  Usage:\ttarget e7000 <device> <speed>\n\
or \t\ttarget e7000 <host>[:<port>]\n\
or \t\ttarget e7000 tcp_remote <host>[:<port>]\n\
or \t\ttarget e7000 pc\n");
	}

#if !defined(__GO32__) && !defined(_WIN32)
      /* FIXME!  test for ':' is ambiguous */
      if (n == 1 && strchr (dev_name, ':') == 0)
	{
	  /* Default to normal telnet port */
	  /* serial_open will use this to determine tcp communication */
	  strcat (dev_name, ":23");
	}
#endif
      if (!using_tcp_remote && strchr (dev_name, ':'))
        using_tcp = 1;
    }

  return n;
}

static void
e7000_open (args, from_tty)
     char *args;
     int from_tty;
{
  int n;
  int loop;
  int sync;
  int serial_flag;

  target_preopen (from_tty);

  n = e7000_parse_device(args,dev_name,serial_flag,baudrate);

  push_target (&e7000_ops);

  e7000_desc = SERIAL_OPEN (dev_name);

  if (!e7000_desc)
    perror_with_name (dev_name);

  SERIAL_SETBAUDRATE (e7000_desc, baudrate);
  SERIAL_RAW (e7000_desc);

  /* Hello?  Are you there?  */
  sync = 0;
  loop =  0;
  putchar_e7000 (CTRLC);
  while (!sync)
    {
      int c;

      if (from_tty)
	printf_unfiltered ("[waiting for e7000...]\n");

      write_e7000 ("\r");
      c = SERIAL_READCHAR (e7000_desc, 1);
      while (c != SERIAL_TIMEOUT)
	{
	  /* Dont echo cr's */
	  if (from_tty && c != '\r')
	    {
	      putchar (c);
	      fflush (stdout);
	    }
	  if (c == ':')
	    sync = 1;

	  if (loop++ == 20) 
	    {
	      putchar_e7000 (CTRLC);
	      loop = 0;
	    }

	  QUIT ;


	  if (quit_flag)
	    {
	      putchar_e7000 (CTRLC);
	      quit_flag = 0;
	    }
	  c = SERIAL_READCHAR (e7000_desc, 1);
	}
    }
  puts_e7000debug ("\r");

  expect_prompt ();

  puts_e7000debug ("b -\r");

  expect_prompt ();

  if (from_tty)
    printf_filtered ("Remote target %s connected to %s\n", target_shortname,
		     dev_name);

#ifdef GDB_TARGET_IS_H8300
  h8300hmode = 1;
#endif
}

/* Close out all files and local state before this target loses control. */

static void
e7000_close (quitting)
     int quitting;
{
  if (e7000_desc)
    {
      SERIAL_CLOSE (e7000_desc);
      e7000_desc = 0;
    }
}

/* Terminate the open connection to the remote debugger.  Use this
   when you want to detach and do something else with your gdb.  */

static void
e7000_detach (from_tty)
     int from_tty;
{
  pop_target ();		/* calls e7000_close to do the real work */
  if (from_tty)
    printf ("Ending remote %s debugging\n", target_shortname);
}

/* Tell the remote machine to resume.  */

static void
e7000_resume (pid, step, sig)
     int pid, step, sig;
{
  if (step)
    puts_e7000debug ("S\r");
  else
    puts_e7000debug ("G\r");
}

/* Read the remote registers into the block REGS.  

   For the H8/300 a register dump looks like:

   PC=00021A  CCR=80:I*******
   ER0 - ER3  0000000A 0000002E 0000002E 00000000
   ER4 - ER7  00000000 00000000 00000000 00FFEFF6
   000218           MOV.B     R1L,R2L
   STEP NORMAL END or
   BREAK POINT
   */

#ifdef GDB_TARGET_IS_H8300

char *want = "PC=%p CCR=%c\n\
 ER0 - ER3  %0 %1 %2 %3\n\
 ER4 - ER7  %4 %5 %6 %7\n";

char *want_nopc = "%p CCR=%c\n\
 ER0 - ER3  %0 %1 %2 %3\n\
 ER4 - ER7  %4 %5 %6 %7";

#endif

#ifdef GDB_TARGET_IS_SH

char *want = "PC=%16 SR=%22\n\
PR=%17 GBR=%18 VBR=%19\n\
MACH=%20 MACL=%21\n\
R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\
R8-15 %8 %9 %10 %11 %12 %13 %14 %15\n";

char *want_nopc = "%16 SR=%22\n\
 PR=%17 GBR=%18 VBR=%19\n\
 MACH=%20 MACL=%21\n\
 R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\
 R8-15 %8 %9 %10 %11 %12 %13 %14 %15";

char *want_sh3 = "PC=%16 SR=%22\n\
PR=%17 GBR=%18 VBR=%19\n\
MACH=%20 MACL=%21 SSR=%23 SPC=%24\n\
R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\
R8-15 %8 %9 %10 %11 %12 %13 %14 %15\n\
R0_BANK0-R3_BANK0 %25 %26 %27 %28\n\
R4_BANK0-R7_BANK0 %29 %30 %31 %32\n\
R0_BANK1-R3_BANK1 %33 %34 %35 %36\n\
R4_BANK1-R7_BANK1 %37 %38 %39 %40";

char *want_sh3_nopc = "%16 SR=%22\n\
 PR=%17 GBR=%18 VBR=%19\n\
 MACH=%20 MACL=%21 SSR=%22 SPC=%23\n\
 R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\
 R8-15 %8 %9 %10 %11 %12 %13 %14 %15\n\
 R0_BANK0-R3_BANK0 %25 %26 %27 %28\n\
 R4_BANK0-R7_BANK0 %29 %30 %31 %32\n\
 R0_BANK1-R3_BANK1 %33 %34 %35 %36\n\
 R4_BANK1-R7_BANK1 %37 %38 %39 %40";

#endif

static int
gch ()
{
  int c = readchar (timeout);

  if (remote_debug)
    {
      if (c >= ' ')
	printf ("%c", c);
      else if (c == '\n')
	printf ("\n");
    }
  return c;
}

static unsigned int
gbyte ()
{
  int high = convert_hex_digit (gch ());
  int low = convert_hex_digit (gch ());

  return (high << 4) + low;
}

void
fetch_regs_from_dump (nextchar, want)
     int (*nextchar)();
     char *want;
{
  int regno;
  char buf[MAX_REGISTER_RAW_SIZE];

  int thischar = nextchar ();

  while (*want)
    {
      switch (*want)
	{
	case '\n':
	  /* Skip to end of line and then eat all new line type stuff */
	  while (thischar != '\n' && thischar != '\r') 
	    thischar = nextchar ();
	  while (thischar == '\n' || thischar == '\r') 
	    thischar = nextchar ();
	  want++;
	  break;

	case ' ':
	  while (thischar == ' '
		 || thischar == '\t'
		 || thischar == '\r'
		 || thischar == '\n')
	    thischar = nextchar ();
	  want++;
	  break;
	  
	default:
	  if (*want == thischar)
	    {
	      want++;
	      if (*want)
		thischar = nextchar ();
	      
	    }
	  else if (thischar == ' ' || thischar == '\n' || thischar == '\r')
	    {
	      thischar = nextchar ();
	    }
	  else {
	    error ("out of sync in fetch registers wanted <%s>, got <%c 0x%x>",
		   want, thischar, thischar);
	  }
    
	  break;
	case '%':
	  /* Got a register command */
	  want++;
	  switch (*want)
	    {
#ifdef PC_REGNUM
	    case 'p':
	      regno = PC_REGNUM;
	      want++;
	      break;
#endif
#ifdef CCR_REGNUM
	    case 'c':
	      regno = CCR_REGNUM;
	      want++;
	      break;
#endif
#ifdef SP_REGNUM
	    case 's':
	      regno = SP_REGNUM;
	      want++;
	      break;
#endif
#ifdef FP_REGNUM
	    case 'f':
	      regno = FP_REGNUM;
	      want++;
	      break;
#endif

	    default:
	      if (isdigit (want[0])) 
		{
		  if (isdigit (want[1]))
		    {
		      regno = (want[0] - '0') * 10 + want[1] - '0';
		      want += 2;
		    }
		  else 
		    {
		      regno = want[0] - '0';
		      want++;
		    }
		}
	      
	      else
		abort ();
	    }
	  store_signed_integer (buf,
				REGISTER_RAW_SIZE(regno),
				(LONGEST) get_hex (&thischar, nextchar));
	  supply_register (regno, buf);
	  break;
	}
    }
}

static void
e7000_fetch_registers ()
{
  int regno;

  puts_e7000debug ("R\r");

#ifdef GDB_TARGET_IS_SH
  if  ((sh_processor_type != NULL) && (*(sh_processor_type+2) == '3')) 
     fetch_regs_from_dump (gch, want_sh3);
  else
     fetch_regs_from_dump (gch, want);
#else
  fetch_regs_from_dump (gch, want);
#endif


  /* And supply the extra ones the simulator uses */
  for (regno = NUM_REALREGS; regno < NUM_REGS; regno++)
    {
      int buf = 0;

      supply_register (regno, (char *) (&buf));
    }
}

/* Fetch register REGNO, or all registers if REGNO is -1.  Returns
   errno value.  */

static void
e7000_fetch_register (regno)
     int regno;
{
  e7000_fetch_registers ();
}

/* Store the remote registers from the contents of the block REGS.  */

static void
e7000_store_registers ()
{
  int regno;

  for (regno = 0; regno < NUM_REALREGS; regno++)
    e7000_store_register (regno);

  registers_changed ();
}

/* Store register REGNO, or all if REGNO == 0.  Return errno value.  */

static void
e7000_store_register (regno)
     int regno;
{
  char buf[200];

  if (regno == -1)
    {
      e7000_store_registers ();
      return;
    }

#ifdef GDB_TARGET_IS_H8300
  if (regno <= 7)
    {
      sprintf (buf, ".ER%d %x\r", regno, read_register (regno));
      puts_e7000debug (buf);
    }
  else if (regno == PC_REGNUM)
    {
      sprintf (buf, ".PC %x\r", read_register (regno));
      puts_e7000debug (buf);
    }
  else if (regno == CCR_REGNUM)
    {
      sprintf (buf, ".CCR %x\r", read_register (regno));
      puts_e7000debug (buf);
    }
#endif /* GDB_TARGET_IS_H8300 */

#ifdef  GDB_TARGET_IS_SH
  switch (regno)
    {
    default:
      sprintf (buf, ".R%d %x\r", regno, read_register (regno));
      puts_e7000debug (buf);
      break;

    case PC_REGNUM:
      sprintf (buf, ".PC %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;

    case SR_REGNUM:
      sprintf (buf, ".SR %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;

    case PR_REGNUM:
      sprintf (buf, ".PR %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;

    case GBR_REGNUM:
      sprintf (buf, ".GBR %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;

    case VBR_REGNUM:
      sprintf (buf, ".VBR %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;

    case MACH_REGNUM:
      sprintf (buf, ".MACH %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;

    case MACL_REGNUM:
      sprintf (buf, ".MACL %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;
    }

#endif /* GDB_TARGET_IS_SH */

  expect_prompt ();
}

/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On machines
   which store all the registers in one fell swoop, this makes sure
   that registers contains all the registers from the program being
   debugged.  */

static void
e7000_prepare_to_store ()
{
  /* Do nothing, since we can store individual regs */
}

static void
e7000_files_info ()
{
  printf ("\tAttached to %s at %d baud.\n", dev_name, baudrate);
}

static int
stickbyte (where, what)
     char *where;
     unsigned int what;
{
  static CONST char digs[] = "0123456789ABCDEF";

  where[0] = digs[(what >> 4) & 0xf];
  where[1] = digs[(what & 0xf) & 0xf];

  return what;
}

/* Write a small ammount of memory. */

static int
write_small (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
{
  int i;
  char buf[200];

  for (i = 0; i < len; i++)
    {
      if (((memaddr + i) & 3) == 0 && (i + 3 < len))
	{
	  /* Can be done with a long word */
	  sprintf (buf, "m %x %x%02x%02x%02x;l\r",
		   memaddr + i,
		   myaddr[i], myaddr[i + 1], myaddr[i + 2], myaddr[i + 3]);
	  puts_e7000debug (buf);
	  i += 3;
	}
      else
	{
	  sprintf (buf, "m %x %x\r", memaddr + i, myaddr[i]);
	  puts_e7000debug (buf);
	}
    }

  expect_prompt ();

  return len;
}

/* Write a large ammount of memory, this only works with the serial
   mode enabled.  Command is sent as

	il ;s:s\r	 ->
			<- il ;s:s\r
			<-  	ENQ
	ACK		->
			<- LO s\r
	Srecords...
	^Z		->
			<-	ENQ
	ACK		->  
			<-	:   	
  */

static int
write_large (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
{
  int i;
#define maxstride  128
  int stride;

  puts_e7000debug ("IL ;S:FK\r");
  expect (ENQSTRING);
  putchar_e7000 (ACK);
  expect ("LO FK\r");

  for (i = 0; i < len; i += stride)
    {
      char compose[maxstride * 2 + 50];
      int address = i + memaddr;
      int j;
      int check_sum;
      int where = 0;
      int alen;

      stride = len - i;
      if (stride > maxstride)
	stride = maxstride;

      compose[where++] = 'S';
      check_sum = 0;
      if (address >= 0xffffff)
	alen = 4;
      else if (address >= 0xffff)
	alen = 3;
      else
	alen = 2;
      /* Insert type. */
      compose[where++] = alen - 1 + '0';
      /* Insert length. */
      check_sum += stickbyte (compose + where, alen + stride + 1);
      where += 2;
      while (alen > 0)
	{
	  alen--;
	  check_sum += stickbyte (compose + where, address >> (8 * (alen)));
	  where += 2;
	}

      for (j = 0; j < stride; j++)
	{
	  check_sum += stickbyte (compose + where, myaddr[i + j]);
	  where += 2;
	}
      stickbyte (compose + where, ~check_sum);
      where += 2;
      compose[where++] = '\r';
      compose[where++] = '\n';
      compose[where++] = 0;

      SERIAL_WRITE (e7000_desc, compose, where);
      j = SERIAL_READCHAR (e7000_desc, 0);
      if (j == SERIAL_TIMEOUT)
	{
	  /* This is ok - nothing there */
	}
      else if (j == ENQ)
	{
	  /* Hmm, it's trying to tell us something */
	  expect (":");
	  error ("Error writing memory");
	}
      else
	{
	  printf ("@@%d}@@", j);
	  while ((j = SERIAL_READCHAR(e7000_desc,0)) > 0) 
	    {
	      printf ("@@{%d}@@",j);
	    }
	}
    }

  /* Send the trailer record */
  write_e7000 ("S70500000000FA\r");
  putchar_e7000 (CTRLZ);
  expect (ENQSTRING);
  putchar_e7000 (ACK);
  expect (":");

  return len;
}

/* Copy LEN bytes of data from debugger memory at MYADDR to inferior's
   memory at MEMADDR.  Returns length moved.

   Can't use the Srecord load over ethernet, so don't use fast method
   then.  */

static int
e7000_write_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
{
  if (len < 16 || using_tcp || using_pc)
    return write_small (memaddr, myaddr, len);
  else
    return write_large (memaddr, myaddr, len);
}

/* Read LEN bytes from inferior memory at MEMADDR.  Put the result
   at debugger address MYADDR.  Returns length moved. 

  Small transactions we send
  m <addr>;l
  and receive
    00000000 12345678 ?
 */

static int
e7000_read_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
{
  int count;
  int c;
  int i;
  char buf[200];
  /* Starting address of this pass.  */

/*  printf("READ INF %x %x %d\n", memaddr, myaddr, len);*/
  if (((memaddr - 1) + len) < memaddr)
    {
      errno = EIO;
      return 0;
    }

  sprintf (buf, "m %x;l\r", memaddr);
  puts_e7000debug (buf);

  for (count = 0; count < len; count += 4) 
    {
      /* Suck away the address */
      c = gch ();	
      while (c != ' ')
	c = gch ();	
      c = gch ();
      if (c == '*') 
	{			/* Some kind of error */
	  expect_prompt();
	  return -1;
	}
      while (c != ' ')
	c = gch ();	

      /* Now read in the data */
      for (i = 0; i < 4; i++) 
	{
	  int b = gbyte();
	  if (count + i < len) {
	    myaddr[count + i] = b;
	  }
	}

      /* Skip the trailing ? and send a . to end and a cr for more */
      gch ();	
      gch ();
      if (count + 4 >= len)
	puts_e7000debug(".\r");
      else
	puts_e7000debug("\r");

    }
  expect_prompt();
  return len;
}



/*
  For large transfers we used to send


  d <addr> <endaddr>\r

  and receive
   <ADDRESS>           <    D   A   T   A    >               <   ASCII CODE   >
   00000000 5F FD FD FF DF 7F DF FF  01 00 01 00 02 00 08 04  "_..............."
   00000010 FF D7 FF 7F D7 F1 7F FF  00 05 00 00 08 00 40 00  "..............@@."
   00000020 7F FD FF F7 7F FF FF F7  00 00 00 00 00 00 00 00  "................"

  A cost in chars for each transaction of 80 + 5*n-bytes. 

  Large transactions could be done with the srecord load code, but
  there is a pause for a second before dumping starts, which slows the
  average rate down!
*/

static int
e7000_read_inferior_memory_large (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
{
  int count;
  int c;
  char buf[200];

  /* Starting address of this pass.  */

  if (((memaddr - 1) + len) < memaddr)
    {
      errno = EIO;
      return 0;
    }

  sprintf (buf, "d %x %x\r", memaddr, memaddr + len - 1);
  puts_e7000debug (buf);

  count = 0;
  c = gch ();
  
  /* skip down to the first ">" */
  while( c != '>' )
    c = gch ();
  /* now skip to the end of that line */
  while( c != '\r' )
    c = gch ();
  c = gch ();

  while (count < len)
    {
      /* get rid of any white space before the address */
      while (c <= ' ')
	c = gch ();

      /* Skip the address */
      get_hex (&c);

      /* read in the bytes on the line */
      while (c != '"' && count < len)
	{
	  if (c == ' ')
	    c = gch ();
	  else
	    {
	      myaddr[count++] = get_hex (&c);
	    }
	}
      /* throw out the rest of the line */
      while( c != '\r' )
	c = gch ();
    }

  /* wait for the ":" prompt */
  while (c != ':')
    c = gch ();

  return len;
}

#if 0

static int
fast_but_for_the_pause_e7000_read_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
{
  int loop;
  int c;
  char buf[200];

  if (((memaddr - 1) + len) < memaddr)
    {
      errno = EIO;
      return 0;
    }

  sprintf (buf, "is %x@@%x:s\r", memaddr, len);
  puts_e7000debug (buf);
  gch ();
  c = gch ();
  if (c != ENQ)
    {
      /* Got an error */
      error ("Memory read error");
    }
  putchar_e7000 (ACK);
  expect ("SV s");
  loop = 1;
  while (loop)
    {
      int type;
      int length;
      int addr;
      int i;

      c = gch ();
      switch (c)
	{
	case ENQ:		/* ENQ, at the end */
	  loop = 0;
	  break;
	case 'S':
	  /* Start of an Srecord */
	  type = gch ();
	  length = gbyte ();
	  switch (type)
	    {
	    case '7':		/* Termination record, ignore */
	    case '0':
	    case '8':
	    case '9':
	      /* Header record - ignore it */
	      while (length--)
		{
		  gbyte ();
		}
	      break;
	    case '1':
	    case '2':
	    case '3':
	      {
		int alen;

		alen = type - '0' + 1;
		addr = 0;
		while (alen--)
		  {
		    addr = (addr << 8) + gbyte ();
		    length--;
		  }

		for (i = 0; i < length - 1; i++)
		  myaddr[i + addr - memaddr] = gbyte ();

		gbyte ();	/* Ignore checksum */
	      }
	    }
	}
    }

  putchar_e7000 (ACK);
  expect ("TOP ADDRESS =");
  expect ("END ADDRESS =");
  expect (":");

  return len;
}

#endif

static int
e7000_xfer_inferior_memory (memaddr, myaddr, len, write, target)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
     int write;
     struct target_ops *target;	/* ignored */
{
  if (write)
    return e7000_write_inferior_memory( memaddr, myaddr, len);
  else 
    if( len < 16 )
      return e7000_read_inferior_memory( memaddr, myaddr, len);
    else
      return e7000_read_inferior_memory_large( memaddr, myaddr, len);
}

static void
e7000_kill (args, from_tty)
     char *args;
     int from_tty;
{
}

static void
e7000_load (args, from_tty)
     char *args;
     int from_tty;
{
  struct cleanup *old_chain;
  asection *section;
  bfd *pbfd;
  bfd_vma entry;
  int i;
#define WRITESIZE 0x1000
  char buf[2 + 4 + 4 + WRITESIZE]; /* `DT' + <addr> + <len> + <data> */
  char *filename;
  int quiet;
  int nostart;
  time_t start_time, end_time;	/* Start and end times of download */
  unsigned long data_count;	/* Number of bytes transferred to memory */
  int oldtimeout = timeout;	

  timeout = remote_timeout;


  /* FIXME! change test to test for type of download */
  if (!using_tcp)
    {
      generic_load (args, from_tty);
      return;
    }

  /* for direct tcp connections, we can do a fast binary download */
  buf[0] = 'D';
  buf[1] = 'T';
  quiet = 0;
  nostart = 0;
  filename = NULL;

  while (*args != '\000')
    {
      char *arg;

      while (isspace (*args)) args++;

      arg = args;

      while ((*args != '\000') && !isspace (*args)) args++;

      if (*args != '\000')
	*args++ = '\000';

      if (*arg != '-')
	filename = arg;
      else if (strncmp (arg, "-quiet", strlen (arg)) == 0)
	quiet = 1;
      else if (strncmp (arg, "-nostart", strlen (arg)) == 0)
	nostart = 1;
      else
	error ("unknown option `%s'", arg);
    }

  if (!filename)
    filename = get_exec_file (1);

  pbfd = bfd_openr (filename, gnutarget);
  if (pbfd == NULL)
    {
      perror_with_name (filename);
      return;
    }
  old_chain = make_cleanup (bfd_close, pbfd);

  if (!bfd_check_format (pbfd, bfd_object)) 
    error ("\"%s\" is not an object file: %s", filename,
	   bfd_errmsg (bfd_get_error ()));

  start_time = time (NULL);
  data_count = 0;

  puts_e7000debug ("mw\r");

  expect ("\nOK");

  for (section = pbfd->sections; section; section = section->next) 
    {
      if (bfd_get_section_flags (pbfd, section) & SEC_LOAD)
	{
	  bfd_vma section_address;
	  bfd_size_type section_size;
	  file_ptr fptr;

	  section_address = bfd_get_section_vma (pbfd, section);
	  section_size = bfd_get_section_size_before_reloc (section);

	  if (!quiet)
	    printf_filtered ("[Loading section %s at 0x%x (%d bytes)]\n",
			     bfd_get_section_name (pbfd, section),
			     section_address,
			     section_size);

	  fptr = 0;
	  
	  data_count += section_size;

	  while (section_size > 0)
	    {
	      int count;
	      static char inds[] = "|/-\\";
	      static int k = 0;

	      QUIT;

	      count = min (section_size, WRITESIZE);

	      buf[2] = section_address >> 24;
	      buf[3] = section_address >> 16;
	      buf[4] = section_address >> 8;
	      buf[5] = section_address;

	      buf[6] = count >> 24;
	      buf[7] = count >> 16;
	      buf[8] = count >> 8;
	      buf[9] = count;

	      bfd_get_section_contents (pbfd, section, buf + 10, fptr, count);

	      if (SERIAL_WRITE (e7000_desc, buf, count + 10))
		fprintf_unfiltered (gdb_stderr,
				    "e7000_load: SERIAL_WRITE failed: %s\n",
				    safe_strerror(errno));

	      expect ("OK");

	      if (!quiet)
		{
		  printf_unfiltered ("\r%c", inds[k++ % 4]);
		  gdb_flush (gdb_stdout);
		}

	      section_address += count;
	      fptr += count;
	      section_size -= count;
	    }
	}
    }

  write_e7000 ("ED");

  expect_prompt ();

  end_time = time (NULL);

/* Finally, make the PC point at the start address */

  if (exec_bfd)
    write_pc (bfd_get_start_address (exec_bfd));

  inferior_pid = 0;		/* No process now */

/* This is necessary because many things were based on the PC at the time that
   we attached to the monitor, which is no longer valid now that we have loaded
   new code (and just changed the PC).  Another way to do this might be to call
   normal_stop, except that the stack may not be valid, and things would get
   horribly confused... */

  clear_symtab_users ();

  if (!nostart)
    {
      entry = bfd_get_start_address (pbfd);

      if (!quiet)
	printf_unfiltered ("[Starting %s at 0x%x]\n", filename, entry);

/*      start_routine (entry);*/
    }

  report_transfer_performance (data_count, start_time, end_time);

  do_cleanups (old_chain);
  timeout = oldtimeout;
}

/* Clean up when a program exits.

   The program actually lives on in the remote processor's RAM, and may be
   run again without a download.  Don't leave it full of breakpoint
   instructions.  */

static void
e7000_mourn_inferior ()
{
  remove_breakpoints ();
  unpush_target (&e7000_ops);
  generic_mourn_inferior ();	/* Do all the proper things now */
}

#define MAX_BREAKPOINTS 200
#ifdef  HARD_BREAKPOINTS
#define MAX_E7000DEBUG_BREAKPOINTS (BC_BREAKPOINTS ? 5 :  MAX_BREAKPOINTS)
#else
#define MAX_E7000DEBUG_BREAKPOINTS MAX_BREAKPOINTS
#endif

extern int memory_breakpoint_size;

/* Since we can change to soft breakpoints dynamically, we must define 
   more than enough.  Was breakaddr[MAX_E7000DEBUG_BREAKPOINTS]. */
static CORE_ADDR breakaddr[MAX_BREAKPOINTS] = {0};

static int
e7000_insert_breakpoint (addr, shadow)
     CORE_ADDR addr;
     unsigned char *shadow;
{
  int i;
  char buf[200];
  static char nop[2] = NOP;

  for (i = 0; i <= MAX_E7000DEBUG_BREAKPOINTS; i++)
    if (breakaddr[i] == 0)
      {
	breakaddr[i] = addr;
	/* Save old contents, and insert a nop in the space */
#ifdef HARD_BREAKPOINTS
	if (BC_BREAKPOINTS) 
	  {
	    sprintf (buf, "BC%d A=%x\r", i+1, addr);
	    puts_e7000debug (buf);
	  }
	else 
	  {
	    sprintf (buf, "B %x\r", addr);
	    puts_e7000debug (buf);
	  }
#else
#if 0
	e7000_read_inferior_memory (addr, shadow, 2);
	e7000_write_inferior_memory (addr, nop, 2);
#endif

	sprintf (buf, "B %x\r", addr);
	puts_e7000debug (buf);
#endif
	expect_prompt ();
	return 0;
      }

  error ("Too many breakpoints ( > %d) for the E7000\n",
	 MAX_E7000DEBUG_BREAKPOINTS);
  return 1;
}

static int
e7000_remove_breakpoint (addr, shadow)
     CORE_ADDR addr;
     unsigned char *shadow;
{
  int i;
  char buf[200];

  for (i = 0; i < MAX_E7000DEBUG_BREAKPOINTS; i++)
    if (breakaddr[i] == addr)
      {
	breakaddr[i] = 0;
#ifdef HARD_BREAKPOINTS
	if (BC_BREAKPOINTS) 
	  {
	    sprintf (buf, "BC%d - \r",  i+1);
	    puts_e7000debug (buf);
	  }
	else 
	  {
	    sprintf (buf, "B - %x\r",  addr);
	    puts_e7000debug (buf);
	  }
	expect_prompt ();
#else
	sprintf (buf, "B - %x\r", addr);
	puts_e7000debug (buf);
	expect_prompt ();

#if 0
	/* Replace the insn under the break */
	e7000_write_inferior_memory (addr, shadow, 2);
#endif
#endif

	return 0;
      }

  warning ("Can't find breakpoint associated with 0x%x\n", addr);
  return 1;
}

/* Put a command string, in args, out to STDBUG.  Output from STDBUG
   is placed on the users terminal until the prompt is seen. */

static void
e7000_command (args, fromtty)
     char *args;
     int fromtty;
{
  /* FIXME: arbitrary limit on length of args.  */
  char buf[200];

  echo = 0;

  if (!e7000_desc)
    error ("e7000 target not open.");
  if (!args)
    {
      puts_e7000debug ("\r");
    }
  else
    {
      sprintf (buf, "%s\r", args);
      puts_e7000debug (buf);
    }

  echo++;
  ctrl_c = 2;
  expect_full_prompt ();
  echo--;
  ctrl_c = 0;
  printf_unfiltered ("\n");

  /* Who knows what the command did... */
  registers_changed ();
}


static void
e7000_drain_command (args, fromtty)
     char *args;
     int fromtty;

{
  int c;

  puts_e7000debug("end\r");
  putchar_e7000 (CTRLC);

  while ((c = SERIAL_READCHAR (e7000_desc, 1) != SERIAL_TIMEOUT))
    {
      if (quit_flag)
	{
	  putchar_e7000(CTRLC);
	  quit_flag = 0;
	}
      if (c > ' ' && c < 127)
	printf ("%c", c & 0xff);
      else
	printf ("<%x>", c & 0xff);
    }
}

#define NITEMS 7

static int
why_stop ()
{
  static  char *strings[NITEMS] = {
    "STEP NORMAL",
    "BREAK POINT",
    "BREAK KEY",
    "BREAK CONDI",
    "CYCLE ACCESS",
    "ILLEGAL INSTRUCTION",
    "WRITE PROTECT",
  };
  char *p[NITEMS];
  int c;
  int i;

  for (i = 0; i < NITEMS; ++i)
    p[i] = strings[i];
  
  c = gch ();
  while (1)
    {
      for (i = 0; i < NITEMS; i++)
	{
	  if (c == *(p[i])) 
	    {
	      p[i]++;
	      if (*(p[i]) == 0) 
		{ 
		  /* found one of the choices */
		  return i;
		}
	    }
	  else
	    p[i] = strings[i];
	}

      c = gch ();
    }
}

/* Suck characters, if a string match, then return the strings index
   otherwise echo them.  */

int
expect_n (strings)
char **strings;
{
  char *(ptr[10]);
  int n; 
  int c;
  char saveaway[100];
  char *buffer = saveaway;
  /* Count number of expect strings  */

  for (n = 0; strings[n]; n++) 
    {
      ptr[n] = strings[n];
    }

  while (1)
    {
      int i;
      int gotone = 0;

      c = SERIAL_READCHAR (e7000_desc, 1);
      if (c == SERIAL_TIMEOUT)
	{
	  printf_unfiltered ("[waiting for e7000...]\n");
	}
#ifdef __GO32__
      if (kbhit ())
	{
	  int k = getkey();

	  if (k == 1)
	    quit_flag = 1;
	}
#endif
      if (quit_flag)
	{
	  putchar_e7000 (CTRLC);	/* interrupt the running program */
	  quit_flag = 0;
	}

      for (i = 0; i < n; i++)
	{
	  if (c == ptr[i][0]) 
	    {
	      ptr[i]++;
	      if (ptr[i][0] == 0)
		{
		  /* Gone all the way */
		  return i;
		}
	      gotone = 1;
	    }
	  else
	    {
	      ptr[i] = strings[i];
	    }
	}
    
      if (gotone)
	{
	  /* Save it up incase we find that there was no match */
	  *buffer ++ = c;
	}
      else
	{
	  if (buffer != saveaway) 
	    {
	      *buffer++ = 0;
	      printf ("%s", buffer);
	      buffer = saveaway;
	    }
	  if (c != SERIAL_TIMEOUT)
	    {
	      putchar (c);
	      fflush (stdout);
	    }
	}
    }
}

/* We subtract two from the pc here rather than use
   DECR_PC_AFTER_BREAK since the e7000 doesn't always add two to the
   pc, and the simulators never do. */

static void
sub2_from_pc ()
{
  char buf[4];
  char buf2[200];

  store_signed_integer (buf,
			REGISTER_RAW_SIZE(PC_REGNUM), 
			read_register (PC_REGNUM) -2);
  supply_register (PC_REGNUM, buf);
  sprintf (buf2, ".PC %x\r", read_register (PC_REGNUM));
  puts_e7000debug (buf2);
}

#define WAS_SLEEP 0
#define WAS_INT 1
#define WAS_RUNNING 2
#define WAS_OTHER 3

static char *estrings[] = {
  "** SLEEP",
  "BREAK !",
  "** PC",
  "PC",
  NULL
};

/* Wait until the remote machine stops, then return, storing status in
   STATUS just as `wait' would.  */

static int
e7000_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
{
  int stop_reason;
  int regno;
  int running_count = 0;
  int had_sleep = 0;
  int loop = 1;

  /* Then echo chars until PC= string seen */
  gch ();			/* Drop cr */
  gch ();			/* and space */

  while (loop)
    {
      switch (expect_n (estrings))
	{	 
	case WAS_OTHER:
	  /* how did this happen ? */
	  loop = 0;
	  break;
	case WAS_SLEEP:
	  had_sleep = 1;
	  putchar_e7000 (CTRLC);
	  loop = 0;
	  break;
	case WAS_INT:
	  loop = 0;
	  break;
	case WAS_RUNNING:
	  running_count++;
	  if (running_count == 20)
	    {
	      printf_unfiltered ("[running...]\n");
	      running_count = 0;
	    }
	  break;
	default:
	  /* error? */
	  break;
	}
    }

  /* Skip till the PC= */
  expect ("=");

#ifdef GDB_TARGET_IS_SH
  if  ((sh_processor_type != NULL) && (*(sh_processor_type+2) == '3')) 
     fetch_regs_from_dump (gch, want_sh3_nopc);
  else
     fetch_regs_from_dump (gch, want_nopc);
#else
  fetch_regs_from_dump (gch, want_nopc);
#endif

  /* And supply the extra ones the simulator uses */
  for (regno = NUM_REALREGS; regno < NUM_REGS; regno++)
    {
      int buf = 0;
      supply_register (regno, (char *) &buf);
    }

  stop_reason = why_stop ();
  expect_full_prompt ();

  status->kind = TARGET_WAITKIND_STOPPED;
  status->value.sig = TARGET_SIGNAL_TRAP;

  switch (stop_reason)
    {
    case 1:			/* Breakpoint */
      write_pc (read_pc ()); /* PC is always off by 2 for breakpoints */
      status->value.sig = TARGET_SIGNAL_TRAP;      
      break;
    case 0:			/* Single step */
      status->value.sig = TARGET_SIGNAL_TRAP;      
      break;
    case 2:			/* Interrupt */
      if (had_sleep)
	{
	  status->value.sig = TARGET_SIGNAL_TRAP;      
	  sub2_from_pc ();
	}
      else
	{
	  status->value.sig = TARGET_SIGNAL_INT;      
	}
      break;
    case 3:
      break;
    case 4:
      printf_unfiltered ("a cycle address error?\n");
      status->value.sig = TARGET_SIGNAL_UNKNOWN;      
      break;
    case 5:
      status->value.sig = TARGET_SIGNAL_ILL;      
      break;
    case 6:
      status->value.sig = TARGET_SIGNAL_SEGV;      
      break;
    case 7:			/* Anything else (NITEMS + 1) */
      printf_unfiltered ("a write protect error?\n");
      status->value.sig = TARGET_SIGNAL_UNKNOWN;      
      break;
    default:
      /* Get the user's attention - this should never happen. */
      abort ();
    }

  return 0;
}

/* Stop the running program.  */

static void
e7000_stop ()  
{
  /* Sending a ^C is supposed to stop the running program.  */
  putchar_e7000 (CTRLC);
}

/* Define the target subroutine names. */

struct target_ops e7000_ops =
{
  "e7000",
  "Remote Hitachi e7000 target",
  "Use a remote Hitachi e7000 ICE connected by a serial line,\n\
or a network connection.\n\
Arguments are the name of the device for the serial line,\n\
the speed to connect at in bits per second.\n\
eg\n\
target e7000 /dev/ttya 9600\n\
target e7000 foobar",
  e7000_open,			/* to_open */
  e7000_close,			/* to_close */
  0,				/* to_attach */
  e7000_detach,			/* to_detach */
  e7000_resume,			/* to_resume */
  e7000_wait,			/* to_wait */
  e7000_fetch_register,		/* to_fetch_registers */
  e7000_store_register,		/* to_store_registers */
  e7000_prepare_to_store,	/* to_prepare_to_store */
  e7000_xfer_inferior_memory,	/* to_xfer_memory */
  e7000_files_info,		/* to_files_info */
  e7000_insert_breakpoint,	/* to_insert_breakpoint */
  e7000_remove_breakpoint,	/* to_remove_breakpoint */
  0,				/* to_terminal_init */
  0,				/* to_terminal_inferior */
  0,				/* to_terminal_ours_for_output */
  0,				/* to_terminal_ours */
  0,				/* to_terminal_info */
  e7000_kill,			/* to_kill */
  e7000_load,			/* to_load */
  0,				/* to_lookup_symbol */
  e7000_create_inferior,	/* to_create_inferior */
  e7000_mourn_inferior,		/* to_mourn_inferior */
  0,				/* to_can_run */
  0,				/* to_notice_signals */
  0,				/* to_thread_alive */
  e7000_stop,			/* to_stop */
  process_stratum,		/* to_stratum */
  0,				/* next (unused) */
  1,				/* to_has_all_memory */
  1,				/* to_has_memory */
  1,				/* to_has_stack */
  1,				/* to_has_registers */
  1,				/* to_has_execution */
  0,				/* to_sections */
  0,				/* to_sections_end */
  OPS_MAGIC,			/* Always the last thing */
};

void
_initialize_remote_e7000 ()
{
  add_target (&e7000_ops);

  add_com ("e7000 <command>", class_obscure, e7000_command,
	   "Send a command to the e7000 monitor.");

  add_com ("ftplogin <machine> <name> <passwd> <dir>", class_obscure, e7000_login_command,
	   "Login to machine and change to directory.");

  add_com ("ftpload <file>", class_obscure, e7000_ftp_command,
	   "Fetch and load a file from previously described place.");

  add_com ("drain", class_obscure, e7000_drain_command,
	   "Drain pending e7000 text buffers.");

  add_show_from_set (add_set_cmd ("usehardbreakpoints", no_class,
				  var_integer, (char *)&use_hard_breakpoints,
				  "Set use of hardware breakpoints for all breakpoints.\n", &setlist),
		     &showlist);
}
@
