head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.50
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.48
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.44
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.46
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.38
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.42
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.40
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.36
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.34
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.32
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.30
	OPENBSD_5_0:1.5.0.28
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.26
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.24
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.20
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.22
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.18
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.16
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.5
date	2004.12.27.21.03.54;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.27.14.00.33;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.21.20.23.04;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.36.50;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.16.55;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.09.18;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.11.06;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.16.56;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Add add_setshow_enum_cmd.
@
text
@/* Header file for command-reading library command.c.

   Copyright 1986, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1999,
   2000, 2002, 2004 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#if !defined (COMMAND_H)
#define COMMAND_H 1

/* Command classes are top-level categories into which commands are broken
   down for "help" purposes.  
   Notes on classes: class_alias is for alias commands which are not
   abbreviations of the original command.  class-pseudo is for
   commands which are not really commands nor help topics ("stop").  */

enum command_class
{
  /* Special args to help_list */
  class_deprecated, all_classes = -2, all_commands = -1,
  /* Classes of commands */
  no_class = -1, class_run = 0, class_vars, class_stack,
  class_files, class_support, class_info, class_breakpoint, class_trace,
  class_alias, class_obscure, class_user, class_maintenance,
  class_pseudo, class_tui, class_xdb
};

/* FIXME: cagney/2002-03-17: Once cmd_type() has been removed, ``enum
   cmd_types'' can be moved from "command.h" to "cli-decode.h".  */
/* Not a set/show command.  Note that some commands which begin with
   "set" or "show" might be in this category, if their syntax does
   not fall into one of the following categories.  */
typedef enum cmd_types
  {
    not_set_cmd,
    set_cmd,
    show_cmd
  }
cmd_types;

/* Types of "set" or "show" command.  */
typedef enum var_types
  {
    /* "on" or "off".  *VAR is an integer which is nonzero for on,
       zero for off.  */
    var_boolean,

    /* "on" / "true" / "enable" or "off" / "false" / "disable" or
       "auto.  *VAR is an ``enum auto_boolean''.  NOTE: In general a
       custom show command will need to be implemented - one that for
       "auto" prints both the "auto" and the current auto-selected
       value. */
    var_auto_boolean,

    /* Unsigned Integer.  *VAR is an unsigned int.  The user can type 0
       to mean "unlimited", which is stored in *VAR as UINT_MAX.  */
    var_uinteger,

    /* Like var_uinteger but signed.  *VAR is an int.  The user can type 0
       to mean "unlimited", which is stored in *VAR as INT_MAX.  */
    var_integer,

    /* String which the user enters with escapes (e.g. the user types \n and
       it is a real newline in the stored string).
       *VAR is a malloc'd string, or NULL if the string is empty.  */
    var_string,
    /* String which stores what the user types verbatim.
       *VAR is a malloc'd string, or NULL if the string is empty.  */
    var_string_noescape,
    /* String which stores a filename.
       *VAR is a malloc'd string, or NULL if the string is empty.  */
    var_filename,
    /* ZeroableInteger.  *VAR is an int.  Like Unsigned Integer except
       that zero really means zero.  */
    var_zinteger,
    /* Enumerated type.  Can only have one of the specified values.  *VAR is a
       char pointer to the name of the element that we find.  */
    var_enum
  }
var_types;

/* This structure records one command'd definition.  */
struct cmd_list_element;

/* Forward-declarations of the entry-points of cli/cli-decode.c.  */

extern struct cmd_list_element *add_cmd (char *, enum command_class,
					 void (*fun) (char *, int), char *,
					 struct cmd_list_element **);

extern struct cmd_list_element *add_alias_cmd (char *, char *,
					       enum command_class, int,
					       struct cmd_list_element **);

extern struct cmd_list_element *add_prefix_cmd (char *, enum command_class,
						void (*fun) (char *, int),
						char *,
						struct cmd_list_element **,
						char *, int,
						struct cmd_list_element **);

extern struct cmd_list_element *add_abbrev_prefix_cmd (char *,
						       enum command_class,
						       void (*fun) (char *,
								    int),
						       char *,
						       struct cmd_list_element
						       **, char *, int,
						       struct cmd_list_element
						       **);

/* Set the commands corresponding callback.  */

typedef void cmd_cfunc_ftype (char *args, int from_tty);
extern void set_cmd_cfunc (struct cmd_list_element *cmd,
			   cmd_cfunc_ftype *cfunc);

typedef void cmd_sfunc_ftype (char *args, int from_tty,
			      struct cmd_list_element *c);
extern void set_cmd_sfunc (struct cmd_list_element *cmd,
			   cmd_sfunc_ftype *sfunc);

extern void set_cmd_completer (struct cmd_list_element *cmd,
			       char **(*completer) (char *text, char *word));

/* HACK: cagney/2002-02-23: Code, mostly in tracepoints.c, grubs
   around in cmd objects to test the value of the commands sfunc().  */
extern int cmd_cfunc_eq (struct cmd_list_element *cmd,
			 void (*cfunc) (char *args, int from_tty));

/* Each command object has a local context attached to it. .  */
extern void set_cmd_context (struct cmd_list_element *cmd, void *context);
extern void *get_cmd_context (struct cmd_list_element *cmd);


/* Execute CMD's pre/post hook.  Throw an error if the command fails.
   If already executing this pre/post hook, or there is no pre/post
   hook, the call is silently ignored.  */
extern void execute_cmd_pre_hook (struct cmd_list_element *cmd);
extern void execute_cmd_post_hook (struct cmd_list_element *cmd);

/* Return the type of the command.  */
/* NOTE: cagney/2002-03-17: The deprecated_add_show_from_set()
   function clones the set command passed as a parameter.  The clone
   operation will include (BUG?) any ``set'' command callback, if
   present.  Commands like ``info set'' call all the ``show'' command
   callbacks.  Unfortunately, for ``show'' commands cloned from
   ``set'', this includes callbacks belonging to ``set'' commands.
   Making this worse, this only occures if
   deprecated_add_show_from_set() is called after add_cmd_sfunc()
   (BUG?).  */
extern enum cmd_types cmd_type (struct cmd_list_element *cmd);


extern struct cmd_list_element *lookup_cmd (char **,
					    struct cmd_list_element *, char *,
					    int, int);

extern struct cmd_list_element *lookup_cmd_1 (char **,
					      struct cmd_list_element *,
					      struct cmd_list_element **,
					      int);

extern struct cmd_list_element *
  deprecate_cmd (struct cmd_list_element *, char * );

extern void
  deprecated_cmd_warning (char **);

extern int
  lookup_cmd_composition (char *text,
                        struct cmd_list_element **alias,
                        struct cmd_list_element **prefix_cmd,
                        struct cmd_list_element **cmd);

extern struct cmd_list_element *add_com (char *, enum command_class,
					 void (*fun) (char *, int), char *);

extern struct cmd_list_element *add_com_alias (char *, char *,
					       enum command_class, int);

extern struct cmd_list_element *add_info (char *, void (*fun) (char *, int),
					  char *);

extern struct cmd_list_element *add_info_alias (char *, char *, int);

extern char **complete_on_cmdlist (struct cmd_list_element *, char *, char *);

extern char **complete_on_enum (const char *enumlist[], char *, char *);

extern void delete_cmd (char *, struct cmd_list_element **);

extern void help_cmd (char *, struct ui_file *);

extern void help_list (struct cmd_list_element *, char *,
		       enum command_class, struct ui_file *);

extern void help_cmd_list (struct cmd_list_element *, enum command_class,
			   char *, int, struct ui_file *);

extern struct cmd_list_element *add_set_cmd (char *name, enum
					     command_class class,
					     var_types var_type, void *var,
					     char *doc,
					     struct cmd_list_element **list);

extern struct cmd_list_element *add_set_enum_cmd (char *name,
						  enum command_class class,
						  const char *enumlist[],
						  const char **var,
						  char *doc,
						  struct cmd_list_element **list);
extern void add_setshow_enum_cmd (char *name,
				  enum command_class class,
				  const char *enumlist[],
				  const char **var,
				  const char *set_doc,
				  const char *show_doc,
				  const char *help_doc,
				  const char *print,
				  cmd_sfunc_ftype *set_func,
				  cmd_sfunc_ftype *show_func,
				  struct cmd_list_element **set_list,
				  struct cmd_list_element **show_list);

extern void add_setshow_auto_boolean_cmd (char *name,
					  enum command_class class,
					  enum auto_boolean *var,
					  const char *set_doc,
					  const char *show_doc,
					  const char *help_doc,
					  const char *print,
					  cmd_sfunc_ftype *set_func,
					  cmd_sfunc_ftype *show_func,
					  struct cmd_list_element **set_list,
					  struct cmd_list_element **show_list);

extern void add_setshow_boolean_cmd (char *name,
				     enum command_class class,
				     int *var,
				     const char *set_doc, const char *show_doc,
				     const char *help_doc, const char *print,
				     cmd_sfunc_ftype *set_func,
				     cmd_sfunc_ftype *show_func,
				     struct cmd_list_element **set_list,
				     struct cmd_list_element **show_list);

extern void add_setshow_filename_cmd (char *name,
				      enum command_class class,
				      char **var,
				      const char *set_doc,
				      const char *show_doc,
				      const char *help_doc,
				      const char *print,
				      cmd_sfunc_ftype *set_func,
				      cmd_sfunc_ftype *show_func,
				      struct cmd_list_element **set_list,
				      struct cmd_list_element **show_list);

extern void add_setshow_string_cmd (char *name,
				    enum command_class class,
				    char **var,
				    const char *set_doc,
				    const char *show_doc,
				    const char *help_doc,
				    const char *print,
				    cmd_sfunc_ftype *set_func,
				    cmd_sfunc_ftype *show_func,
				    struct cmd_list_element **set_list,
				    struct cmd_list_element **show_list);

extern void add_setshow_uinteger_cmd (char *name,
				      enum command_class class,
				      unsigned int *var,
				      const char *set_doc,
				      const char *show_doc,
				      const char *help_doc,
				      const char *print,
				      cmd_sfunc_ftype *set_func,
				      cmd_sfunc_ftype *show_func,
				      struct cmd_list_element **set_list,
				      struct cmd_list_element **show_list);

extern void add_setshow_zinteger_cmd (char *name,
				      enum command_class class,
				      int *var,
				      const char *set_doc,
				      const char *show_doc,
				      const char *help_doc,
				      const char *print,
				      cmd_sfunc_ftype *set_func,
				      cmd_sfunc_ftype *show_func,
				      struct cmd_list_element **set_list,
				      struct cmd_list_element **show_list);

extern struct cmd_list_element *deprecated_add_show_from_set (struct cmd_list_element *,
							      struct cmd_list_element **);

/* Do a "show" command for each thing on a command list.  */

extern void cmd_show_list (struct cmd_list_element *, int, char *);

extern NORETURN void error_no_arg (char *) ATTR_NORETURN;

extern void dont_repeat (void);

/* Used to mark commands that don't do anything.  If we just leave the
   function field NULL, the command is interpreted as a help topic, or
   as a class of commands.  */

extern void not_just_help_class_command (char *, int);

/* check function pointer */
extern int cmd_func_p (struct cmd_list_element *cmd);

/* call the command function */
extern void cmd_func (struct cmd_list_element *cmd, char *args, int from_tty);

#endif /* !defined (COMMAND_H) */
@


1.4
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@d226 12
@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@d4 1
a4 1
   2000, 2002 Free Software Foundation, Inc.
d156 9
a164 8
/* NOTE: cagney/2002-03-17: The add_show_from_set() function clones
   the set command passed as a parameter.  The clone operation will
   include (BUG?) any ``set'' command callback, if present.  Commands
   like ``info set'' call all the ``show'' command callbacks.
   Unfortunately, for ``show'' commands cloned from ``set'', this
   includes callbacks belonging to ``set'' commands.  Making this
   worse, this only occures if add_show_from_set() is called after
   add_cmd_sfunc() (BUG?).  */
a213 20
extern void add_setshow_cmd (char *name,
			     enum command_class class,
			     var_types var_type, void *var,
			     char *set_doc, char *show_doc,
			     cmd_sfunc_ftype *set_func,
			     cmd_sfunc_ftype *show_func,
			     struct cmd_list_element **set_list,
			     struct cmd_list_element **show_list);

extern void add_setshow_cmd_full (char *name,
				  enum command_class class,
				  var_types var_type, void *var,
				  char *set_doc, char *show_doc,
				  cmd_sfunc_ftype *set_func,
				  cmd_sfunc_ftype *show_func,
				  struct cmd_list_element **set_list,
				  struct cmd_list_element **show_list,
				  struct cmd_list_element **set_result,
				  struct cmd_list_element **show_result);

d230 4
a233 1
					  char *set_doc, char *show_doc,
d242 2
a243 2
				     char *set_doc,
				     char *show_doc,
d249 24
d276 16
a291 2
				      char *set_doc,
				      char *show_doc,
d297 2
a298 3
extern struct cmd_list_element *add_show_from_set (struct cmd_list_element *,
						   struct cmd_list_element
						   **);
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@a1 1
   Copyright (C) 1986, 1989, 1990 Free Software Foundation, Inc.
d3 17
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d24 19
d46 7
a52 5
typedef enum cmd_types {
  not_set_cmd,
  set_cmd,
  show_cmd
} cmd_types;
d55 39
a93 29
typedef enum var_types {
  /* "on" or "off".  *VAR is an integer which is nonzero for on,
     zero for off.  */
  var_boolean,
  /* Unsigned Integer.  *VAR is an unsigned int.  The user can type 0
     to mean "unlimited", which is stored in *VAR as UINT_MAX.  */
  var_uinteger,

  /* Like var_uinteger but signed.  *VAR is an int.  The user can type 0
     to mean "unlimited", which is stored in *VAR as INT_MAX.  */
  var_integer,

  /* String which the user enters with escapes (e.g. the user types \n and
     it is a real newline in the stored string).
     *VAR is a malloc'd string, or NULL if the string is empty.  */
  var_string,
  /* String which stores what the user types verbatim.
     *VAR is a malloc'd string, or NULL if the string is empty.  */
  var_string_noescape,
  /* String which stores a filename.
     *VAR is a malloc'd string, or NULL if the string is empty.  */
  var_filename,
  /* ZeroableInteger.  *VAR is an int.  Like Unsigned Integer except
     that zero really means zero.  */
  var_zinteger,
  /* Enumerated type.  Can only have one of the specified values.  *VAR is a
     char pointer to the name of the element that we find.  */
  var_enum
} var_types;
d96 1
d98 1
a98 111
struct cmd_list_element
  {
    /* Points to next command in this list.  */
    struct cmd_list_element *next;

    /* Name of this command.  */
    char *name;

    /* Command class; class values are chosen by application program.  */
    enum command_class class;

    /* Function definition of this command.
       NO_FUNCTION for command class names and for help topics that
       are not really commands.  */
    union
      {
	/* If type is not_set_cmd, call it like this:  */
	void (*cfunc) PARAMS ((char *args, int from_tty));

	/* If type is cmd_set or show_cmd, first set the variables, and
	   then call this.  */
	void (*sfunc) PARAMS ((char *args, int from_tty,
			       struct cmd_list_element *c));
      } function;
#   define NO_FUNCTION ((void (*) PARAMS((char *args, int from_tty))) 0)

    /* Documentation of this command (or help topic).
       First line is brief documentation; remaining lines form, with it,
       the full documentation.  First line should end with a period.
       Entire string should also end with a period, not a newline.  */
    char *doc;

    /* Hook for another command to be executed before this command.  */
    struct cmd_list_element *hook;

    /* Nonzero identifies a prefix command.  For them, the address
       of the variable containing the list of subcommands.  */
    struct cmd_list_element **prefixlist;

    /* For prefix commands only:
       String containing prefix commands to get here: this one
       plus any others needed to get to it.  Should end in a space.
       It is used before the word "command" in describing the
       commands reached through this prefix.  */
    char *prefixname;

    /* For prefix commands only:
       nonzero means do not get an error if subcommand is not
       recognized; call the prefix's own function in that case.  */
    char allow_unknown;

    /* Nonzero says this is an abbreviation, and should not
       be mentioned in lists of commands.
       This allows "br<tab>" to complete to "break", which it
       otherwise wouldn't.  */
    char abbrev_flag;

    /* Completion routine for this command.  TEXT is the text beyond
       what was matched for the command itself (leading whitespace is
       skipped).  It stops where we are supposed to stop completing
       (rl_point) and is '\0' terminated.

       Return value is a malloc'd vector of pointers to possible completions
       terminated with NULL.  If there are no completions, returning a pointer
       to a NULL would work but returning NULL itself is also valid.
       WORD points in the same buffer as TEXT, and completions should be
       returned relative to this position.  For example, suppose TEXT is "foo"
       and we want to complete to "foobar".  If WORD is "oo", return
       "oobar"; if WORD is "baz/foo", return "baz/foobar".  */
    char ** (*completer) PARAMS ((char *text, char *word));

    /* Type of "set" or "show" command (or SET_NOT_SET if not "set"
       or "show").  */
    cmd_types type;

    /* Pointer to variable affected by "set" and "show".  Doesn't matter
       if type is not_set.  */
    char *var;

    /* What kind of variable is *VAR?  */
    var_types var_type;

    /* Pointer to NULL terminated list of enumerated values (like argv).  */
    char **enums;

    /* Pointer to command strings of user-defined commands */
    struct command_line *user_commands;

    /* Pointer to command that is hooked by this one,
       so the hook can be removed when this one is deleted.  */
    struct cmd_list_element *hookee;

    /* Pointer to command that is aliased by this one, so the
       aliased command can be located in case it has been hooked.  */
    struct cmd_list_element *cmd_pointer;
  };

/* Forward-declarations of the entry-points of command.c.  */

extern struct cmd_list_element *
add_cmd PARAMS ((char *, enum command_class, void (*fun) (char *, int),
		 char *, struct cmd_list_element **));

extern struct cmd_list_element *
add_alias_cmd PARAMS ((char *, char *, enum command_class, int,
		       struct cmd_list_element **));

extern struct cmd_list_element *
add_prefix_cmd PARAMS ((char *, enum command_class, void (*fun) (char *, int),
			char *, struct cmd_list_element **, char *, int,
			struct cmd_list_element **));
d100 75
a174 8
extern struct cmd_list_element *
add_abbrev_prefix_cmd PARAMS ((char *, enum command_class,
			       void (*fun) (char *, int), char *,
			       struct cmd_list_element **, char *, int,
			       struct cmd_list_element **));

extern struct cmd_list_element *
lookup_cmd PARAMS ((char **, struct cmd_list_element *, char *, int, int));
d177 1
a177 12
lookup_cmd_1 PARAMS ((char **, struct cmd_list_element *,
		      struct cmd_list_element **, int));

extern void
add_com PARAMS ((char *, enum command_class, void (*fun)(char *, int),
		 char *));

extern void
add_com_alias PARAMS ((char *, char *, enum command_class, int));

extern void
add_info PARAMS ((char *, void (*fun) (char *, int), char *));
d180 1
a180 1
add_info_alias PARAMS ((char *, char *, int));
d182 96
a277 39
extern char **
complete_on_cmdlist PARAMS ((struct cmd_list_element *, char *, char *));

extern char **
complete_on_enum PARAMS ((char **enumlist, char *, char *));

extern void
delete_cmd PARAMS ((char *, struct cmd_list_element **));

extern void
help_cmd PARAMS ((char *, GDB_FILE *));

extern void
help_list PARAMS ((struct cmd_list_element *, char *, enum command_class,
		   GDB_FILE *));

extern void
help_cmd_list PARAMS ((struct cmd_list_element *, enum command_class, char *,
		       int, GDB_FILE *));

extern struct cmd_list_element *
add_set_cmd PARAMS ((char *, enum command_class, var_types, char *, char *,
		     struct cmd_list_element **));

extern struct cmd_list_element *
add_set_enum_cmd PARAMS ((char *name, enum command_class, char *list[],
			  char *var, char *doc, struct cmd_list_element **c));

extern struct cmd_list_element *
add_show_from_set PARAMS ((struct cmd_list_element *,
			   struct cmd_list_element **));

/* Do a "set" or "show" command.  ARG is NULL if no argument, or the text
   of the argument, and FROM_TTY is nonzero if this command is being entered
   directly by the user (i.e. these are just like any other
   command).  C is the command list element for the command.  */

extern void
do_setshow_command PARAMS ((char *, int, struct cmd_list_element *));
d281 1
a281 2
extern void
cmd_show_list PARAMS ((struct cmd_list_element *, int, char *));
d283 1
a283 2
extern void
error_no_arg PARAMS ((char *));
d285 1
a285 2
extern void
dont_repeat PARAMS ((void));
d291 7
a297 2
extern void
not_just_help_class_command PARAMS ((char *, int));
@


1.1
log
@file command.h was initially added on branch CYGNUS.
@
text
@d1 259
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 299
/* Header file for command-reading library command.c.

   Copyright 1986, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1999,
   2000, 2002 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#if !defined (COMMAND_H)
#define COMMAND_H 1

/* Command classes are top-level categories into which commands are broken
   down for "help" purposes.  
   Notes on classes: class_alias is for alias commands which are not
   abbreviations of the original command.  class-pseudo is for
   commands which are not really commands nor help topics ("stop").  */

enum command_class
{
  /* Special args to help_list */
  class_deprecated, all_classes = -2, all_commands = -1,
  /* Classes of commands */
  no_class = -1, class_run = 0, class_vars, class_stack,
  class_files, class_support, class_info, class_breakpoint, class_trace,
  class_alias, class_obscure, class_user, class_maintenance,
  class_pseudo, class_tui, class_xdb
};

/* FIXME: cagney/2002-03-17: Once cmd_type() has been removed, ``enum
   cmd_types'' can be moved from "command.h" to "cli-decode.h".  */
/* Not a set/show command.  Note that some commands which begin with
   "set" or "show" might be in this category, if their syntax does
   not fall into one of the following categories.  */
typedef enum cmd_types
  {
    not_set_cmd,
    set_cmd,
    show_cmd
  }
cmd_types;

/* Types of "set" or "show" command.  */
typedef enum var_types
  {
    /* "on" or "off".  *VAR is an integer which is nonzero for on,
       zero for off.  */
    var_boolean,

    /* "on" / "true" / "enable" or "off" / "false" / "disable" or
       "auto.  *VAR is an ``enum auto_boolean''.  NOTE: In general a
       custom show command will need to be implemented - one that for
       "auto" prints both the "auto" and the current auto-selected
       value. */
    var_auto_boolean,

    /* Unsigned Integer.  *VAR is an unsigned int.  The user can type 0
       to mean "unlimited", which is stored in *VAR as UINT_MAX.  */
    var_uinteger,

    /* Like var_uinteger but signed.  *VAR is an int.  The user can type 0
       to mean "unlimited", which is stored in *VAR as INT_MAX.  */
    var_integer,

    /* String which the user enters with escapes (e.g. the user types \n and
       it is a real newline in the stored string).
       *VAR is a malloc'd string, or NULL if the string is empty.  */
    var_string,
    /* String which stores what the user types verbatim.
       *VAR is a malloc'd string, or NULL if the string is empty.  */
    var_string_noescape,
    /* String which stores a filename.
       *VAR is a malloc'd string, or NULL if the string is empty.  */
    var_filename,
    /* ZeroableInteger.  *VAR is an int.  Like Unsigned Integer except
       that zero really means zero.  */
    var_zinteger,
    /* Enumerated type.  Can only have one of the specified values.  *VAR is a
       char pointer to the name of the element that we find.  */
    var_enum
  }
var_types;

/* This structure records one command'd definition.  */
struct cmd_list_element;

/* Forward-declarations of the entry-points of cli/cli-decode.c.  */

extern struct cmd_list_element *add_cmd (char *, enum command_class,
					 void (*fun) (char *, int), char *,
					 struct cmd_list_element **);

extern struct cmd_list_element *add_alias_cmd (char *, char *,
					       enum command_class, int,
					       struct cmd_list_element **);

extern struct cmd_list_element *add_prefix_cmd (char *, enum command_class,
						void (*fun) (char *, int),
						char *,
						struct cmd_list_element **,
						char *, int,
						struct cmd_list_element **);

extern struct cmd_list_element *add_abbrev_prefix_cmd (char *,
						       enum command_class,
						       void (*fun) (char *,
								    int),
						       char *,
						       struct cmd_list_element
						       **, char *, int,
						       struct cmd_list_element
						       **);

/* Set the commands corresponding callback.  */

typedef void cmd_cfunc_ftype (char *args, int from_tty);
extern void set_cmd_cfunc (struct cmd_list_element *cmd,
			   cmd_cfunc_ftype *cfunc);

typedef void cmd_sfunc_ftype (char *args, int from_tty,
			      struct cmd_list_element *c);
extern void set_cmd_sfunc (struct cmd_list_element *cmd,
			   cmd_sfunc_ftype *sfunc);

extern void set_cmd_completer (struct cmd_list_element *cmd,
			       char **(*completer) (char *text, char *word));

/* HACK: cagney/2002-02-23: Code, mostly in tracepoints.c, grubs
   around in cmd objects to test the value of the commands sfunc().  */
extern int cmd_cfunc_eq (struct cmd_list_element *cmd,
			 void (*cfunc) (char *args, int from_tty));

/* Each command object has a local context attached to it. .  */
extern void set_cmd_context (struct cmd_list_element *cmd, void *context);
extern void *get_cmd_context (struct cmd_list_element *cmd);


/* Execute CMD's pre/post hook.  Throw an error if the command fails.
   If already executing this pre/post hook, or there is no pre/post
   hook, the call is silently ignored.  */
extern void execute_cmd_pre_hook (struct cmd_list_element *cmd);
extern void execute_cmd_post_hook (struct cmd_list_element *cmd);

/* Return the type of the command.  */
/* NOTE: cagney/2002-03-17: The add_show_from_set() function clones
   the set command passed as a parameter.  The clone operation will
   include (BUG?) any ``set'' command callback, if present.  Commands
   like ``info set'' call all the ``show'' command callbacks.
   Unfortunately, for ``show'' commands cloned from ``set'', this
   includes callbacks belonging to ``set'' commands.  Making this
   worse, this only occures if add_show_from_set() is called after
   add_cmd_sfunc() (BUG?).  */
extern enum cmd_types cmd_type (struct cmd_list_element *cmd);


extern struct cmd_list_element *lookup_cmd (char **,
					    struct cmd_list_element *, char *,
					    int, int);

extern struct cmd_list_element *lookup_cmd_1 (char **,
					      struct cmd_list_element *,
					      struct cmd_list_element **,
					      int);

extern struct cmd_list_element *
  deprecate_cmd (struct cmd_list_element *, char * );

extern void
  deprecated_cmd_warning (char **);

extern int
  lookup_cmd_composition (char *text,
                        struct cmd_list_element **alias,
                        struct cmd_list_element **prefix_cmd,
                        struct cmd_list_element **cmd);

extern struct cmd_list_element *add_com (char *, enum command_class,
					 void (*fun) (char *, int), char *);

extern struct cmd_list_element *add_com_alias (char *, char *,
					       enum command_class, int);

extern struct cmd_list_element *add_info (char *, void (*fun) (char *, int),
					  char *);

extern struct cmd_list_element *add_info_alias (char *, char *, int);

extern char **complete_on_cmdlist (struct cmd_list_element *, char *, char *);

extern char **complete_on_enum (const char *enumlist[], char *, char *);

extern void delete_cmd (char *, struct cmd_list_element **);

extern void help_cmd (char *, struct ui_file *);

extern void help_list (struct cmd_list_element *, char *,
		       enum command_class, struct ui_file *);

extern void help_cmd_list (struct cmd_list_element *, enum command_class,
			   char *, int, struct ui_file *);

extern void add_setshow_cmd (char *name,
			     enum command_class class,
			     var_types var_type, void *var,
			     char *set_doc, char *show_doc,
			     cmd_sfunc_ftype *set_func,
			     cmd_sfunc_ftype *show_func,
			     struct cmd_list_element **set_list,
			     struct cmd_list_element **show_list);

extern void add_setshow_cmd_full (char *name,
				  enum command_class class,
				  var_types var_type, void *var,
				  char *set_doc, char *show_doc,
				  cmd_sfunc_ftype *set_func,
				  cmd_sfunc_ftype *show_func,
				  struct cmd_list_element **set_list,
				  struct cmd_list_element **show_list,
				  struct cmd_list_element **set_result,
				  struct cmd_list_element **show_result);

extern struct cmd_list_element *add_set_cmd (char *name, enum
					     command_class class,
					     var_types var_type, void *var,
					     char *doc,
					     struct cmd_list_element **list);

extern struct cmd_list_element *add_set_enum_cmd (char *name,
						  enum command_class class,
						  const char *enumlist[],
						  const char **var,
						  char *doc,
						  struct cmd_list_element **list);

extern void add_setshow_auto_boolean_cmd (char *name,
					  enum command_class class,
					  enum auto_boolean *var,
					  char *set_doc, char *show_doc,
					  cmd_sfunc_ftype *set_func,
					  cmd_sfunc_ftype *show_func,
					  struct cmd_list_element **set_list,
					  struct cmd_list_element **show_list);

extern void add_setshow_boolean_cmd (char *name,
				     enum command_class class,
				     int *var,
				     char *set_doc,
				     char *show_doc,
				     cmd_sfunc_ftype *set_func,
				     cmd_sfunc_ftype *show_func,
				     struct cmd_list_element **set_list,
				     struct cmd_list_element **show_list);

extern void add_setshow_uinteger_cmd (char *name,
				      enum command_class class,
				      unsigned int *var,
				      char *set_doc,
				      char *show_doc,
				      cmd_sfunc_ftype *set_func,
				      cmd_sfunc_ftype *show_func,
				      struct cmd_list_element **set_list,
				      struct cmd_list_element **show_list);

extern struct cmd_list_element *add_show_from_set (struct cmd_list_element *,
						   struct cmd_list_element
						   **);

/* Do a "show" command for each thing on a command list.  */

extern void cmd_show_list (struct cmd_list_element *, int, char *);

extern NORETURN void error_no_arg (char *) ATTR_NORETURN;

extern void dont_repeat (void);

/* Used to mark commands that don't do anything.  If we just leave the
   function field NULL, the command is interpreted as a help topic, or
   as a class of commands.  */

extern void not_just_help_class_command (char *, int);

/* check function pointer */
extern int cmd_func_p (struct cmd_list_element *cmd);

/* call the command function */
extern void cmd_func (struct cmd_list_element *cmd, char *args, int from_tty);

#endif /* !defined (COMMAND_H) */
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d4 1
a4 1
   2000, 2002, 2004 Free Software Foundation, Inc.
d156 8
a163 9
/* NOTE: cagney/2002-03-17: The deprecated_add_show_from_set()
   function clones the set command passed as a parameter.  The clone
   operation will include (BUG?) any ``set'' command callback, if
   present.  Commands like ``info set'' call all the ``show'' command
   callbacks.  Unfortunately, for ``show'' commands cloned from
   ``set'', this includes callbacks belonging to ``set'' commands.
   Making this worse, this only occures if
   deprecated_add_show_from_set() is called after add_cmd_sfunc()
   (BUG?).  */
d213 20
d249 1
a249 4
					  const char *set_doc,
					  const char *show_doc,
					  const char *help_doc,
					  const char *print,
d258 2
a259 2
				     const char *set_doc, const char *show_doc,
				     const char *help_doc, const char *print,
a264 24
extern void add_setshow_filename_cmd (char *name,
				      enum command_class class,
				      char **var,
				      const char *set_doc,
				      const char *show_doc,
				      const char *help_doc,
				      const char *print,
				      cmd_sfunc_ftype *set_func,
				      cmd_sfunc_ftype *show_func,
				      struct cmd_list_element **set_list,
				      struct cmd_list_element **show_list);

extern void add_setshow_string_cmd (char *name,
				    enum command_class class,
				    char **var,
				    const char *set_doc,
				    const char *show_doc,
				    const char *help_doc,
				    const char *print,
				    cmd_sfunc_ftype *set_func,
				    cmd_sfunc_ftype *show_func,
				    struct cmd_list_element **set_list,
				    struct cmd_list_element **show_list);

d268 2
a269 16
				      const char *set_doc,
				      const char *show_doc,
				      const char *help_doc,
				      const char *print,
				      cmd_sfunc_ftype *set_func,
				      cmd_sfunc_ftype *show_func,
				      struct cmd_list_element **set_list,
				      struct cmd_list_element **show_list);

extern void add_setshow_zinteger_cmd (char *name,
				      enum command_class class,
				      int *var,
				      const char *set_doc,
				      const char *show_doc,
				      const char *help_doc,
				      const char *print,
d275 3
a277 2
extern struct cmd_list_element *deprecated_add_show_from_set (struct cmd_list_element *,
							      struct cmd_list_element **);
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 259
/* Header file for command-reading library command.c.
   Copyright (C) 1986, 1989, 1990 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#if !defined (COMMAND_H)
#define COMMAND_H 1

/* Not a set/show command.  Note that some commands which begin with
   "set" or "show" might be in this category, if their syntax does
   not fall into one of the following categories.  */
typedef enum cmd_types {
  not_set_cmd,
  set_cmd,
  show_cmd
} cmd_types;

/* Types of "set" or "show" command.  */
typedef enum var_types {
  /* "on" or "off".  *VAR is an integer which is nonzero for on,
     zero for off.  */
  var_boolean,
  /* Unsigned Integer.  *VAR is an unsigned int.  The user can type 0
     to mean "unlimited", which is stored in *VAR as UINT_MAX.  */
  var_uinteger,

  /* Like var_uinteger but signed.  *VAR is an int.  The user can type 0
     to mean "unlimited", which is stored in *VAR as INT_MAX.  */
  var_integer,

  /* String which the user enters with escapes (e.g. the user types \n and
     it is a real newline in the stored string).
     *VAR is a malloc'd string, or NULL if the string is empty.  */
  var_string,
  /* String which stores what the user types verbatim.
     *VAR is a malloc'd string, or NULL if the string is empty.  */
  var_string_noescape,
  /* String which stores a filename.
     *VAR is a malloc'd string, or NULL if the string is empty.  */
  var_filename,
  /* ZeroableInteger.  *VAR is an int.  Like Unsigned Integer except
     that zero really means zero.  */
  var_zinteger,
  /* Enumerated type.  Can only have one of the specified values.  *VAR is a
     char pointer to the name of the element that we find.  */
  var_enum
} var_types;

/* This structure records one command'd definition.  */

struct cmd_list_element
  {
    /* Points to next command in this list.  */
    struct cmd_list_element *next;

    /* Name of this command.  */
    char *name;

    /* Command class; class values are chosen by application program.  */
    enum command_class class;

    /* Function definition of this command.
       NO_FUNCTION for command class names and for help topics that
       are not really commands.  */
    union
      {
	/* If type is not_set_cmd, call it like this:  */
	void (*cfunc) PARAMS ((char *args, int from_tty));

	/* If type is cmd_set or show_cmd, first set the variables, and
	   then call this.  */
	void (*sfunc) PARAMS ((char *args, int from_tty,
			       struct cmd_list_element *c));
      } function;
#   define NO_FUNCTION ((void (*) PARAMS((char *args, int from_tty))) 0)

    /* Documentation of this command (or help topic).
       First line is brief documentation; remaining lines form, with it,
       the full documentation.  First line should end with a period.
       Entire string should also end with a period, not a newline.  */
    char *doc;

    /* Hook for another command to be executed before this command.  */
    struct cmd_list_element *hook;

    /* Nonzero identifies a prefix command.  For them, the address
       of the variable containing the list of subcommands.  */
    struct cmd_list_element **prefixlist;

    /* For prefix commands only:
       String containing prefix commands to get here: this one
       plus any others needed to get to it.  Should end in a space.
       It is used before the word "command" in describing the
       commands reached through this prefix.  */
    char *prefixname;

    /* For prefix commands only:
       nonzero means do not get an error if subcommand is not
       recognized; call the prefix's own function in that case.  */
    char allow_unknown;

    /* Nonzero says this is an abbreviation, and should not
       be mentioned in lists of commands.
       This allows "br<tab>" to complete to "break", which it
       otherwise wouldn't.  */
    char abbrev_flag;

    /* Completion routine for this command.  TEXT is the text beyond
       what was matched for the command itself (leading whitespace is
       skipped).  It stops where we are supposed to stop completing
       (rl_point) and is '\0' terminated.

       Return value is a malloc'd vector of pointers to possible completions
       terminated with NULL.  If there are no completions, returning a pointer
       to a NULL would work but returning NULL itself is also valid.
       WORD points in the same buffer as TEXT, and completions should be
       returned relative to this position.  For example, suppose TEXT is "foo"
       and we want to complete to "foobar".  If WORD is "oo", return
       "oobar"; if WORD is "baz/foo", return "baz/foobar".  */
    char ** (*completer) PARAMS ((char *text, char *word));

    /* Type of "set" or "show" command (or SET_NOT_SET if not "set"
       or "show").  */
    cmd_types type;

    /* Pointer to variable affected by "set" and "show".  Doesn't matter
       if type is not_set.  */
    char *var;

    /* What kind of variable is *VAR?  */
    var_types var_type;

    /* Pointer to NULL terminated list of enumerated values (like argv).  */
    char **enums;

    /* Pointer to command strings of user-defined commands */
    struct command_line *user_commands;

    /* Pointer to command that is hooked by this one,
       so the hook can be removed when this one is deleted.  */
    struct cmd_list_element *hookee;

    /* Pointer to command that is aliased by this one, so the
       aliased command can be located in case it has been hooked.  */
    struct cmd_list_element *cmd_pointer;
  };

/* Forward-declarations of the entry-points of command.c.  */

extern struct cmd_list_element *
add_cmd PARAMS ((char *, enum command_class, void (*fun) (char *, int),
		 char *, struct cmd_list_element **));

extern struct cmd_list_element *
add_alias_cmd PARAMS ((char *, char *, enum command_class, int,
		       struct cmd_list_element **));

extern struct cmd_list_element *
add_prefix_cmd PARAMS ((char *, enum command_class, void (*fun) (char *, int),
			char *, struct cmd_list_element **, char *, int,
			struct cmd_list_element **));

extern struct cmd_list_element *
add_abbrev_prefix_cmd PARAMS ((char *, enum command_class,
			       void (*fun) (char *, int), char *,
			       struct cmd_list_element **, char *, int,
			       struct cmd_list_element **));

extern struct cmd_list_element *
lookup_cmd PARAMS ((char **, struct cmd_list_element *, char *, int, int));

extern struct cmd_list_element *
lookup_cmd_1 PARAMS ((char **, struct cmd_list_element *,
		      struct cmd_list_element **, int));

extern void
add_com PARAMS ((char *, enum command_class, void (*fun)(char *, int),
		 char *));

extern void
add_com_alias PARAMS ((char *, char *, enum command_class, int));

extern void
add_info PARAMS ((char *, void (*fun) (char *, int), char *));

extern void
add_info_alias PARAMS ((char *, char *, int));

extern char **
complete_on_cmdlist PARAMS ((struct cmd_list_element *, char *, char *));

extern char **
complete_on_enum PARAMS ((char **enumlist, char *, char *));

extern void
delete_cmd PARAMS ((char *, struct cmd_list_element **));

extern void
help_cmd PARAMS ((char *, GDB_FILE *));

extern void
help_list PARAMS ((struct cmd_list_element *, char *, enum command_class,
		   GDB_FILE *));

extern void
help_cmd_list PARAMS ((struct cmd_list_element *, enum command_class, char *,
		       int, GDB_FILE *));

extern struct cmd_list_element *
add_set_cmd PARAMS ((char *, enum command_class, var_types, char *, char *,
		     struct cmd_list_element **));

extern struct cmd_list_element *
add_set_enum_cmd PARAMS ((char *name, enum command_class, char *list[],
			  char *var, char *doc, struct cmd_list_element **c));

extern struct cmd_list_element *
add_show_from_set PARAMS ((struct cmd_list_element *,
			   struct cmd_list_element **));

/* Do a "set" or "show" command.  ARG is NULL if no argument, or the text
   of the argument, and FROM_TTY is nonzero if this command is being entered
   directly by the user (i.e. these are just like any other
   command).  C is the command list element for the command.  */

extern void
do_setshow_command PARAMS ((char *, int, struct cmd_list_element *));

/* Do a "show" command for each thing on a command list.  */

extern void
cmd_show_list PARAMS ((struct cmd_list_element *, int, char *));

extern void
error_no_arg PARAMS ((char *));

extern void
dont_repeat PARAMS ((void));

/* Used to mark commands that don't do anything.  If we just leave the
   function field NULL, the command is interpreted as a help topic, or
   as a class of commands.  */

extern void
not_just_help_class_command PARAMS ((char *, int));

#endif /* !defined (COMMAND_H) */
@
