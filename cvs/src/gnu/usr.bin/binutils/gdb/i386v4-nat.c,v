head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.54
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.52
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.48
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.44
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.46
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.38
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.42
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.40
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.36
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.34
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.32
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.30
	OPENBSD_5_0:1.4.0.28
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.26
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.24
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2004.12.27.14.00.37;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.21.20.23.08;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.38.02;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.18.27;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.11.10;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.09.26;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.18.28;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@/* Native-dependent code for Unix SVR4 running on i386's.

   Copyright 1988, 1989, 1991, 1992, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2004
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "value.h"
#include "inferior.h"
#include "regcache.h"

#ifdef HAVE_SYS_REG_H
#include <sys/reg.h>
#endif

#include "i386-tdep.h"
#include "i387-tdep.h"

#ifdef HAVE_SYS_PROCFS_H

#include <sys/procfs.h>

/* Prototypes for supply_gregset etc. */
#include "gregset.h"

/* The `/proc' interface divides the target machine's register set up
   into two different sets, the general purpose register set (gregset)
   and the floating-point register set (fpregset).  For each set,
   there is an ioctl to get the current register set and another ioctl
   to set the current values.

   The actual structure passed through the ioctl interface is, of
   course, naturally machine dependent, and is different for each set
   of registers.  For the i386 for example, the general-purpose
   register set is typically defined by:

   typedef int gregset_t[19];           (in <sys/regset.h>)

   #define GS   0                       (in <sys/reg.h>)
   #define FS   1
   ...
   #define UESP 17
   #define SS   18

   and the floating-point set by:

   typedef struct fpregset   {
           union {
                   struct fpchip_state            // fp extension state //
                   {
                           int     state[27];     // 287/387 saved state //
                           int     status;        // status word saved at //
                                                  // exception //
                   } fpchip_state;
                   struct fp_emul_space           // for emulators //
                   {
                           char    fp_emul[246];
                           char    fp_epad[2];
                   } fp_emul_space;
                   int     f_fpregs[62];          // union of the above //
           } fp_reg_set;
           long            f_wregs[33];           // saved weitek state //
   } fpregset_t;

   Incidentally fpchip_state contains the FPU state in the same format
   as used by the "fsave" instruction, and that's the only thing we
   support here.  I don't know how the emulator stores it state.  The
   Weitek stuff definitely isn't supported.

   The routines defined here, provide the packing and unpacking of
   gregset_t and fpregset_t formatted data.  */

#ifdef HAVE_GREGSET_T

/* Mapping between the general-purpose registers in `/proc'
   format and GDB's register array layout.  */
static int regmap[] =
{
  EAX, ECX, EDX, EBX,
  UESP, EBP, ESI, EDI,
  EIP, EFL, CS, SS,
  DS, ES, FS, GS
};

/* Fill GDB's register array with the general-purpose register values
   in *GREGSETP.  */

void
supply_gregset (gregset_t *gregsetp)
{
  greg_t *regp = (greg_t *) gregsetp;
  int regnum;

  for (regnum = 0; regnum < I386_NUM_GREGS; regnum++)
    regcache_raw_supply (current_regcache, regnum, regp + regmap[regnum]);
}

/* Fill register REGNUM (if it is a general-purpose register) in
   *GREGSETPS with the value in GDB's register array.  If REGNUM is -1,
   do this for all registers.  */

void
fill_gregset (gregset_t *gregsetp, int regnum)
{
  greg_t *regp = (greg_t *) gregsetp;
  int i;

  for (i = 0; i < I386_NUM_GREGS; i++)
    if (regnum == -1 || regnum == i)
      regcache_raw_collect (current_regcache, i, regp + regmap[i]);
}

#endif /* HAVE_GREGSET_T */

#ifdef HAVE_FPREGSET_T

/* Fill GDB's register array with the floating-point register values in
   *FPREGSETP.  */

void
supply_fpregset (fpregset_t *fpregsetp)
{
  if (FP0_REGNUM == 0)
    return;

  i387_supply_fsave (current_regcache, -1, fpregsetp);
}

/* Fill register REGNO (if it is a floating-point register) in
   *FPREGSETP with the value in GDB's register array.  If REGNO is -1,
   do this for all registers.  */

void
fill_fpregset (fpregset_t *fpregsetp, int regno)
{
  if (FP0_REGNUM == 0)
    return;

  i387_fill_fsave ((char *) fpregsetp, regno);
}

#endif /* HAVE_FPREGSET_T */

#endif /* HAVE_SYS_PROCFS_H */
@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@d1 2
a2 1
/* Native-dependent code for SVR4 Unix running on i386's.
d4 1
a4 1
   2001, 2002
d99 1
a99 1
  DS, ES, FS, GS,
d109 1
a109 1
  int i;
d111 2
a112 2
  for (i = 0; i < I386_NUM_GREGS; i++)
    supply_register (i, (char *) (regp + regmap[i]));
d115 2
a116 2
/* Fill register REGNO (if it is a general-purpose register) in
   *GREGSETPS with the value in GDB's register array.  If REGNO is -1,
d120 1
a120 1
fill_gregset (gregset_t *gregsetp, int regno)
d126 2
a127 2
    if (regno == -1 || regno == i)
      regcache_collect (i, regp + regmap[i]);
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d1 21
a21 2
/* Native-dependent code for SVR4 Unix running on i386's, for GDB.
   Copyright 1988, 1989, 1991, 1992, 1996 Free Software Foundation, Inc.
d23 8
a30 15
This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d32 2
a33 1
#include "defs.h"
d39 2
a40 38
/*  The /proc interface divides the target machine's register set up into
    two different sets, the general register set (gregset) and the floating
    point register set (fpregset).  For each set, there is an ioctl to get
    the current register set and another ioctl to set the current values.

    The actual structure passed through the ioctl interface is, of course,
    naturally machine dependent, and is different for each set of registers.
    For the i386 for example, the general register set is typically defined
    by:

	typedef int gregset_t[19];		(in <sys/regset.h>)

	#define GS	0			(in <sys/reg.h>)
	#define FS	1
	...
	#define UESP	17
	#define SS	18

    and the floating point set by:

	typedef struct fpregset
	  {
	    union
	      {
		struct fpchip_state	// fp extension state //
		{
		  int state[27];	// 287/387 saved state //
		  int status;		// status word saved at exception //
		} fpchip_state;
		struct fp_emul_space	// for emulators //
		{
		  char fp_emul[246];
		  char fp_epad[2];
		} fp_emul_space;
		int f_fpregs[62];	// union of the above //
	      } fp_reg_set;
	    long f_wregs[33];		// saved weitek state //
	} fpregset_t;
d42 43
a84 2
    These routines provide the packing and unpacking of gregset_t and
    fpregset_t formatted data.
d86 2
a87 1
 */
d91 3
a93 3
/* This is a duplicate of the table in i386-xdep.c. */

static int regmap[] = 
d101 2
a102 10

/*  FIXME:  These routine absolutely depends upon (NUM_REGS - NUM_FREGS)
    being less than or equal to the number of registers that can be stored
    in a gregset_t.  Note that with the current scheme there will typically
    be more registers actually stored in a gregset_t that what we know
    about.  This is bogus and should be fixed. */

/*  Given a pointer to a general register set in /proc format (gregset_t *),
    unpack the register contents and supply them as gdb's idea of the current
    register values. */
d105 1
a105 2
supply_gregset (gregsetp)
     gregset_t *gregsetp;
d107 5
a111 8
  register int regi;
  register greg_t *regp = (greg_t *) gregsetp;
  extern int regmap[];

  for (regi = 0 ; regi < (NUM_REGS - NUM_FREGS) ; regi++)
    {
      supply_register (regi, (char *) (regp + regmap[regi]));
    }
d114 4
d119 1
a119 3
fill_gregset (gregsetp, regno)
     gregset_t *gregsetp;
     int regno;
d121 6
a126 12
  int regi;
  register greg_t *regp = (greg_t *) gregsetp;
  extern char registers[];
  extern int regmap[];

  for (regi = 0 ; regi < (NUM_REGS - NUM_FREGS) ; regi++)
    {
      if ((regno == -1) || (regno == regi))
	{
	  *(regp + regmap[regi]) = *(int *) &registers[REGISTER_BYTE (regi)];
	}
    }
d129 1
a129 1
#endif	/* HAVE_GREGSET_T */
d131 1
a131 1
#if defined (FP0_REGNUM) && defined (HAVE_FPREGSET_T)
d133 2
a134 3
/*  Given a pointer to a floating point register set in /proc format
    (fpregset_t *), unpack the register contents and supply them as gdb's
    idea of the current floating point register values. */
d136 2
a137 3
void 
supply_fpregset (fpregsetp)
     fpregset_t *fpregsetp;
d139 4
a142 3
  register int regi;
  
  /* FIXME: see m68k-tdep.c for an example, for the m68k. */
d145 3
a147 4
/*  Given a pointer to a floating point register set in /proc format
    (fpregset_t *), update the register specified by REGNO from gdb's idea
    of the current floating point register set.  If REGNO is -1, update
    them all. */
d150 1
a150 3
fill_fpregset (fpregsetp, regno)
     fpregset_t *fpregsetp;
     int regno;
d152 2
a153 4
  int regi;
  char *to;
  char *from;
  extern char registers[];
d155 1
a155 1
  /* FIXME: see m68k-tdep.c for an example, for the m68k. */
d158 1
a158 1
#endif	/* defined (FP0_REGNUM) && defined (HAVE_FPREGSET_T) */
d160 1
a160 1
#endif	/* HAVE_SYS_PROCFS_H */
@


1.1
log
@file i386v4-nat.c was initially added on branch CYGNUS.
@
text
@d1 163
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 160
/* Native-dependent code for SVR4 Unix running on i386's.
   Copyright 1988, 1989, 1991, 1992, 1996, 1997, 1998, 1999, 2000,
   2001, 2002
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "value.h"
#include "inferior.h"
#include "regcache.h"

#ifdef HAVE_SYS_REG_H
#include <sys/reg.h>
#endif

#include "i386-tdep.h"
#include "i387-tdep.h"

#ifdef HAVE_SYS_PROCFS_H

#include <sys/procfs.h>

/* Prototypes for supply_gregset etc. */
#include "gregset.h"

/* The `/proc' interface divides the target machine's register set up
   into two different sets, the general purpose register set (gregset)
   and the floating-point register set (fpregset).  For each set,
   there is an ioctl to get the current register set and another ioctl
   to set the current values.

   The actual structure passed through the ioctl interface is, of
   course, naturally machine dependent, and is different for each set
   of registers.  For the i386 for example, the general-purpose
   register set is typically defined by:

   typedef int gregset_t[19];           (in <sys/regset.h>)

   #define GS   0                       (in <sys/reg.h>)
   #define FS   1
   ...
   #define UESP 17
   #define SS   18

   and the floating-point set by:

   typedef struct fpregset   {
           union {
                   struct fpchip_state            // fp extension state //
                   {
                           int     state[27];     // 287/387 saved state //
                           int     status;        // status word saved at //
                                                  // exception //
                   } fpchip_state;
                   struct fp_emul_space           // for emulators //
                   {
                           char    fp_emul[246];
                           char    fp_epad[2];
                   } fp_emul_space;
                   int     f_fpregs[62];          // union of the above //
           } fp_reg_set;
           long            f_wregs[33];           // saved weitek state //
   } fpregset_t;

   Incidentally fpchip_state contains the FPU state in the same format
   as used by the "fsave" instruction, and that's the only thing we
   support here.  I don't know how the emulator stores it state.  The
   Weitek stuff definitely isn't supported.

   The routines defined here, provide the packing and unpacking of
   gregset_t and fpregset_t formatted data.  */

#ifdef HAVE_GREGSET_T

/* Mapping between the general-purpose registers in `/proc'
   format and GDB's register array layout.  */
static int regmap[] =
{
  EAX, ECX, EDX, EBX,
  UESP, EBP, ESI, EDI,
  EIP, EFL, CS, SS,
  DS, ES, FS, GS,
};

/* Fill GDB's register array with the general-purpose register values
   in *GREGSETP.  */

void
supply_gregset (gregset_t *gregsetp)
{
  greg_t *regp = (greg_t *) gregsetp;
  int i;

  for (i = 0; i < I386_NUM_GREGS; i++)
    supply_register (i, (char *) (regp + regmap[i]));
}

/* Fill register REGNO (if it is a general-purpose register) in
   *GREGSETPS with the value in GDB's register array.  If REGNO is -1,
   do this for all registers.  */

void
fill_gregset (gregset_t *gregsetp, int regno)
{
  greg_t *regp = (greg_t *) gregsetp;
  int i;

  for (i = 0; i < I386_NUM_GREGS; i++)
    if (regno == -1 || regno == i)
      regcache_collect (i, regp + regmap[i]);
}

#endif /* HAVE_GREGSET_T */

#ifdef HAVE_FPREGSET_T

/* Fill GDB's register array with the floating-point register values in
   *FPREGSETP.  */

void
supply_fpregset (fpregset_t *fpregsetp)
{
  if (FP0_REGNUM == 0)
    return;

  i387_supply_fsave (current_regcache, -1, fpregsetp);
}

/* Fill register REGNO (if it is a floating-point register) in
   *FPREGSETP with the value in GDB's register array.  If REGNO is -1,
   do this for all registers.  */

void
fill_fpregset (fpregset_t *fpregsetp, int regno)
{
  if (FP0_REGNUM == 0)
    return;

  i387_fill_fsave ((char *) fpregsetp, regno);
}

#endif /* HAVE_FPREGSET_T */

#endif /* HAVE_SYS_PROCFS_H */
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d1 1
a1 2
/* Native-dependent code for Unix SVR4 running on i386's.

d3 1
a3 1
   2001, 2002, 2004
d98 1
a98 1
  DS, ES, FS, GS
d108 1
a108 1
  int regnum;
d110 2
a111 2
  for (regnum = 0; regnum < I386_NUM_GREGS; regnum++)
    regcache_raw_supply (current_regcache, regnum, regp + regmap[regnum]);
d114 2
a115 2
/* Fill register REGNUM (if it is a general-purpose register) in
   *GREGSETPS with the value in GDB's register array.  If REGNUM is -1,
d119 1
a119 1
fill_gregset (gregset_t *gregsetp, int regnum)
d125 2
a126 2
    if (regnum == -1 || regnum == i)
      regcache_raw_collect (current_regcache, i, regp + regmap[i]);
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 163
/* Native-dependent code for SVR4 Unix running on i386's, for GDB.
   Copyright 1988, 1989, 1991, 1992, 1996 Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "defs.h"

#ifdef HAVE_SYS_PROCFS_H

#include <sys/procfs.h>

/*  The /proc interface divides the target machine's register set up into
    two different sets, the general register set (gregset) and the floating
    point register set (fpregset).  For each set, there is an ioctl to get
    the current register set and another ioctl to set the current values.

    The actual structure passed through the ioctl interface is, of course,
    naturally machine dependent, and is different for each set of registers.
    For the i386 for example, the general register set is typically defined
    by:

	typedef int gregset_t[19];		(in <sys/regset.h>)

	#define GS	0			(in <sys/reg.h>)
	#define FS	1
	...
	#define UESP	17
	#define SS	18

    and the floating point set by:

	typedef struct fpregset
	  {
	    union
	      {
		struct fpchip_state	// fp extension state //
		{
		  int state[27];	// 287/387 saved state //
		  int status;		// status word saved at exception //
		} fpchip_state;
		struct fp_emul_space	// for emulators //
		{
		  char fp_emul[246];
		  char fp_epad[2];
		} fp_emul_space;
		int f_fpregs[62];	// union of the above //
	      } fp_reg_set;
	    long f_wregs[33];		// saved weitek state //
	} fpregset_t;

    These routines provide the packing and unpacking of gregset_t and
    fpregset_t formatted data.

 */

#ifdef HAVE_GREGSET_T

/* This is a duplicate of the table in i386-xdep.c. */

static int regmap[] = 
{
  EAX, ECX, EDX, EBX,
  UESP, EBP, ESI, EDI,
  EIP, EFL, CS, SS,
  DS, ES, FS, GS,
};


/*  FIXME:  These routine absolutely depends upon (NUM_REGS - NUM_FREGS)
    being less than or equal to the number of registers that can be stored
    in a gregset_t.  Note that with the current scheme there will typically
    be more registers actually stored in a gregset_t that what we know
    about.  This is bogus and should be fixed. */

/*  Given a pointer to a general register set in /proc format (gregset_t *),
    unpack the register contents and supply them as gdb's idea of the current
    register values. */

void
supply_gregset (gregsetp)
     gregset_t *gregsetp;
{
  register int regi;
  register greg_t *regp = (greg_t *) gregsetp;
  extern int regmap[];

  for (regi = 0 ; regi < (NUM_REGS - NUM_FREGS) ; regi++)
    {
      supply_register (regi, (char *) (regp + regmap[regi]));
    }
}

void
fill_gregset (gregsetp, regno)
     gregset_t *gregsetp;
     int regno;
{
  int regi;
  register greg_t *regp = (greg_t *) gregsetp;
  extern char registers[];
  extern int regmap[];

  for (regi = 0 ; regi < (NUM_REGS - NUM_FREGS) ; regi++)
    {
      if ((regno == -1) || (regno == regi))
	{
	  *(regp + regmap[regi]) = *(int *) &registers[REGISTER_BYTE (regi)];
	}
    }
}

#endif	/* HAVE_GREGSET_T */

#if defined (FP0_REGNUM) && defined (HAVE_FPREGSET_T)

/*  Given a pointer to a floating point register set in /proc format
    (fpregset_t *), unpack the register contents and supply them as gdb's
    idea of the current floating point register values. */

void 
supply_fpregset (fpregsetp)
     fpregset_t *fpregsetp;
{
  register int regi;
  
  /* FIXME: see m68k-tdep.c for an example, for the m68k. */
}

/*  Given a pointer to a floating point register set in /proc format
    (fpregset_t *), update the register specified by REGNO from gdb's idea
    of the current floating point register set.  If REGNO is -1, update
    them all. */

void
fill_fpregset (fpregsetp, regno)
     fpregset_t *fpregsetp;
     int regno;
{
  int regi;
  char *to;
  char *from;
  extern char registers[];

  /* FIXME: see m68k-tdep.c for an example, for the m68k. */
}

#endif	/* defined (FP0_REGNUM) && defined (HAVE_FPREGSET_T) */

#endif	/* HAVE_SYS_PROCFS_H */
@
