head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.48
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.44
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.46
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.38
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.42
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.40
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.36
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.34
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.32
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.30
	OPENBSD_5_0:1.4.0.28
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.26
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.24
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2004.12.27.14.00.43;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.21.20.23.14;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.40.03;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.20.56;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.13.26;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.09.49;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.20.57;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@/* Definitions for reading symbol files into GDB.

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#if !defined (SYMFILE_H)
#define SYMFILE_H

/* This file requires that you first include "bfd.h".  */

/* Opaque declarations.  */
struct section_table;
struct objfile;
struct obstack;
struct block;

/* Partial symbols are stored in the psymbol_cache and pointers to
   them are kept in a dynamically grown array that is obtained from
   malloc and grown as necessary via realloc.  Each objfile typically
   has two of these, one for global symbols and one for static
   symbols.  Although this adds a level of indirection for storing or
   accessing the partial symbols, it allows us to throw away duplicate
   psymbols and set all pointers to the single saved instance.  */

struct psymbol_allocation_list
{

  /* Pointer to beginning of dynamically allocated array of pointers
     to partial symbols.  The array is dynamically expanded as
     necessary to accommodate more pointers.  */

  struct partial_symbol **list;

  /* Pointer to next available slot in which to store a pointer to a
     partial symbol.  */

  struct partial_symbol **next;

  /* Number of allocated pointer slots in current dynamic array (not
     the number of bytes of storage).  The "next" pointer will always
     point somewhere between list[0] and list[size], and when at
     list[size] the array will be expanded on the next attempt to
     store a pointer.  */

  int size;
};

/* Define an array of addresses to accommodate non-contiguous dynamic
   loading of modules.  This is for use when entering commands, so we
   can keep track of the section names until we read the file and can
   map them to bfd sections.  This structure is also used by solib.c
   to communicate the section addresses in shared objects to
   symbol_file_add ().  */

struct section_addr_info
{
  /* The number of sections for which address information is
     available.  */
  size_t num_sections;
  /* Sections whose names are file format dependent. */
  struct other_sections
  {
    CORE_ADDR addr;
    char *name;
    int sectindex;
  } other[1];
};

/* Structure to keep track of symbol reading functions for various
   object file types.  */

struct sym_fns
{

  /* BFD flavour that we handle, or (as a special kludge, see
     xcoffread.c, (enum bfd_flavour)-1 for xcoff).  */

  enum bfd_flavour sym_flavour;

  /* Initializes anything that is global to the entire symbol table.
     It is called during symbol_file_add, when we begin debugging an
     entirely new program.  */

  void (*sym_new_init) (struct objfile *);

  /* Reads any initial information from a symbol file, and initializes
     the struct sym_fns SF in preparation for sym_read().  It is
     called every time we read a symbol file for any reason.  */

  void (*sym_init) (struct objfile *);

  /* sym_read (objfile, mainline) Reads a symbol file into a psymtab
     (or possibly a symtab).  OBJFILE is the objfile struct for the
     file we are reading.  MAINLINE is 1 if this is the main symbol
     table being read, and 0 if a secondary symbol file (e.g. shared
     library or dynamically loaded file) is being read.  */

  void (*sym_read) (struct objfile *, int);

  /* Called when we are finished with an objfile.  Should do all
     cleanup that is specific to the object file format for the
     particular objfile.  */

  void (*sym_finish) (struct objfile *);

  /* This function produces a file-dependent section_offsets
     structure, allocated in the objfile's storage, and based on the
     parameter.  The parameter is currently a CORE_ADDR (FIXME!) for
     backward compatibility with the higher levels of GDB.  It should
     probably be changed to a string, where NULL means the default,
     and others are parsed in a file dependent way.  */

  void (*sym_offsets) (struct objfile *, struct section_addr_info *);

  /* Finds the next struct sym_fns.  They are allocated and
     initialized in whatever module implements the functions pointed
     to; an initializer calls add_symtab_fns to add them to the global
     chain.  */

  struct sym_fns *next;

};

/* The default version of sym_fns.sym_offsets for readers that don't
   do anything special.  */

extern void default_symfile_offsets (struct objfile *objfile,
				     struct section_addr_info *);


extern void extend_psymbol_list (struct psymbol_allocation_list *,
				 struct objfile *);

/* Add any kind of symbol to a psymbol_allocation_list.  */

/* #include "demangle.h" */

extern const
struct partial_symbol *add_psymbol_to_list (char *, int, domain_enum,
					    enum address_class,
					    struct psymbol_allocation_list *,
					    long, CORE_ADDR,
					    enum language, struct objfile *);

extern void add_psymbol_with_dem_name_to_list (char *, int, char *, int,
					       domain_enum,
					       enum address_class,
					       struct psymbol_allocation_list
					       *, long, CORE_ADDR,
					       enum language,
					       struct objfile *);


extern void init_psymbol_list (struct objfile *, int);

extern void sort_pst_symbols (struct partial_symtab *);

extern struct symtab *allocate_symtab (char *, struct objfile *);

extern int free_named_symtabs (char *);

extern void fill_in_vptr_fieldno (struct type *);

extern void add_symtab_fns (struct sym_fns *);

extern void syms_from_objfile (struct objfile *,
			       struct section_addr_info *,
			       struct section_offsets *, int, int, int);

extern void new_symfile_objfile (struct objfile *, int, int);

extern struct objfile *symbol_file_add (char *, int,
					struct section_addr_info *, int, int);

extern struct objfile *symbol_file_add_from_bfd (bfd *, int,
                                                 struct section_addr_info *,
                                                 int, int);

/* Create a new section_addr_info, with room for NUM_SECTIONS.  */

extern struct section_addr_info *alloc_section_addr_info (size_t
							  num_sections);

/* Return a freshly allocated copy of ADDRS.  The section names, if
   any, are also freshly allocated copies of those in ADDRS.  */
extern struct section_addr_info *(copy_section_addr_info 
                                  (struct section_addr_info *addrs));

/* Build (allocate and populate) a section_addr_info struct from an
   existing section table.  */

extern struct section_addr_info
  *build_section_addr_info_from_section_table (const struct section_table
					       *start,
					       const struct section_table
					       *end);

/* Free all memory allocated by
   build_section_addr_info_from_section_table.  */

extern void free_section_addr_info (struct section_addr_info *);


extern struct partial_symtab *start_psymtab_common (struct objfile *,
						    struct section_offsets *,
						    char *, CORE_ADDR,
						    struct partial_symbol **,
						    struct partial_symbol **);

/* Make a copy of the string at PTR with SIZE characters in the symbol
   obstack (and add a null character at the end in the copy).  Returns
   the address of the copy.  */

extern char *obsavestring (const char *, int, struct obstack *);

/* Concatenate strings S1, S2 and S3; return the new string.  Space is
   found in the OBSTACKP  */

extern char *obconcat (struct obstack *obstackp, const char *, const char *,
		       const char *);

			/*   Variables   */

/* If non-zero, shared library symbols will be added automatically
   when the inferior is created, new libraries are loaded, or when
   attaching to the inferior.  This is almost always what users will
   want to have happen; but for very large programs, the startup time
   will be excessive, and so if this is a problem, the user can clear
   this flag and then add the shared library symbols as needed.  Note
   that there is a potential for confusion, since if the shared
   library symbols are not loaded, commands like "info fun" will *not*
   report all the functions that are actually present.  */

extern int auto_solib_add;

/* For systems that support it, a threshold size in megabytes.  If
   automatically adding a new library's symbol table to those already
   known to the debugger would cause the total shared library symbol
   size to exceed this threshhold, then the shlib's symbols are not
   added.  The threshold is ignored if the user explicitly asks for a
   shlib to be added, such as when using the "sharedlibrary" command.  */

extern int auto_solib_limit;

/* From symfile.c */

extern struct partial_symtab *allocate_psymtab (char *, struct objfile *);

extern void discard_psymtab (struct partial_symtab *);

extern void find_lowest_section (bfd *, asection *, void *);

extern bfd *symfile_bfd_open (char *);

extern int get_section_index (struct objfile *, char *);

/* Utility functions for overlay sections: */
extern enum overlay_debugging_state
{
  ovly_off,
  ovly_on,
  ovly_auto
} overlay_debugging;
extern int overlay_cache_invalid;

/* Return the "mapped" overlay section containing the PC.  */
extern asection *find_pc_mapped_section (CORE_ADDR);

/* Return any overlay section containing the PC (even in its LMA
   region).  */
extern asection *find_pc_overlay (CORE_ADDR);

/* Return true if the section is an overlay.  */
extern int section_is_overlay (asection *);

/* Return true if the overlay section is currently "mapped".  */
extern int section_is_mapped (asection *);

/* Return true if pc belongs to section's VMA.  */
extern CORE_ADDR pc_in_mapped_range (CORE_ADDR, asection *);

/* Return true if pc belongs to section's LMA.  */
extern CORE_ADDR pc_in_unmapped_range (CORE_ADDR, asection *);

/* Map an address from a section's LMA to its VMA.  */
extern CORE_ADDR overlay_mapped_address (CORE_ADDR, asection *);

/* Map an address from a section's VMA to its LMA.  */
extern CORE_ADDR overlay_unmapped_address (CORE_ADDR, asection *);

/* Convert an address in an overlay section (force into VMA range).  */
extern CORE_ADDR symbol_overlayed_address (CORE_ADDR, asection *);

/* Load symbols from a file.  */
extern void symbol_file_add_main (char *args, int from_tty);

/* Clear GDB symbol tables.  */
extern void symbol_file_clear (int from_tty);

extern bfd_byte *symfile_relocate_debug_section (bfd *abfd, asection *sectp,
						 bfd_byte * buf);

/* From dwarfread.c */

extern void dwarf_build_psymtabs (struct objfile *, int, file_ptr,
				  unsigned int, file_ptr, unsigned int);

/* From dwarf2read.c */

extern int dwarf2_has_info (struct objfile *);

extern void dwarf2_build_psymtabs (struct objfile *, int);
extern void dwarf2_build_frame_info (struct objfile *);

/* From mdebugread.c */

/* Hack to force structures to exist before use in parameter list.  */
struct ecoff_debug_hack
{
  struct ecoff_debug_swap *a;
  struct ecoff_debug_info *b;
};

extern void mdebug_build_psymtabs (struct objfile *,
				   const struct ecoff_debug_swap *,
				   struct ecoff_debug_info *);

extern void elfmdebug_build_psymtabs (struct objfile *,
				      const struct ecoff_debug_swap *,
				      asection *);

#endif /* !defined(SYMFILE_H) */
@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@d192 4
d201 5
d327 1
a327 1
extern int dwarf2_has_info (bfd *abfd);
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@a1 2
   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996
   Free Software Foundation, Inc.
d3 2
a4 1
This file is part of GDB.
d6 16
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d28 20
a47 13
/* Partial symbols are stored in the psymbol_cache and pointers to them
   are kept in a dynamically grown array that is obtained from malloc and
   grown as necessary via realloc.  Each objfile typically has two of these,
   one for global symbols and one for static symbols.  Although this adds
   a level of indirection for storing or accessing the partial symbols,
   it allows us to throw away duplicate psymbols and set all pointers
   to the single saved instance. */

struct psymbol_allocation_list {

  /* Pointer to beginning of dynamically allocated array of pointers to
   partial symbols.  The array is dynamically expanded as necessary to
   accommodate more pointers. */
d51 2
a52 2
  /* Pointer to next available slot in which to store a pointer to a partial
     symbol. */
d56 5
a60 4
  /* Number of allocated pointer slots in current dynamic array (not the
     number of bytes of storage).  The "next" pointer will always point
     somewhere between list[0] and list[size], and when at list[size] the
     array will be expanded on the next attempt to store a pointer. */
d65 21
d89 2
a90 1
struct sym_fns {
d92 2
a93 2
  /* BFD flavour that we handle, or (as a special kludge, see xcoffread.c,
     (enum bfd_flavour)-1 for xcoff).  */
d97 39
a135 42
  /* Initializes anything that is global to the entire symbol table.  It is
     called during symbol_file_add, when we begin debugging an entirely new
     program. */

  void (*sym_new_init) PARAMS ((struct objfile *));

  /* Reads any initial information from a symbol file, and initializes the
     struct sym_fns SF in preparation for sym_read().  It is called every
     time we read a symbol file for any reason. */

  void (*sym_init) PARAMS ((struct objfile *));

  /* sym_read (objfile, addr, mainline)
     Reads a symbol file into a psymtab (or possibly a symtab).
     OBJFILE is the objfile struct for the file we are reading.
     SECTION_OFFSETS
     are the offset between the file's specified section addresses and
     their true addresses in memory.
     MAINLINE is 1 if this is the
     main symbol table being read, and 0 if a secondary
     symbol file (e.g. shared library or dynamically loaded file)
     is being read.  */

  void (*sym_read) PARAMS ((struct objfile *, struct section_offsets *, int));

  /* Called when we are finished with an objfile.  Should do all cleanup
     that is specific to the object file format for the particular objfile. */
 
  void (*sym_finish) PARAMS ((struct objfile *));

  /* This function produces a file-dependent section_offsets structure,
     allocated in the objfile's storage, and based on the parameter.
     The parameter is currently a CORE_ADDR (FIXME!) for backward compatibility
     with the higher levels of GDB.  It should probably be changed to
     a string, where NULL means the default, and others are parsed in a file
     dependent way.  The result of this function is handed in to sym_read.  */

  struct section_offsets *(*sym_offsets) PARAMS ((struct objfile *, CORE_ADDR));

  /* Finds the next struct sym_fns.  They are allocated and initialized
     in whatever module implements the functions pointed to; an 
     initializer calls add_symtab_fns to add them to the global chain.  */
d144 2
a145 2
extern struct section_offsets *
default_symfile_offsets PARAMS ((struct objfile *objfile, CORE_ADDR addr));
d148 2
a149 3
extern void
extend_psymbol_list PARAMS ((struct psymbol_allocation_list *,
			     struct objfile *));
d151 1
a151 1
/* Add any kind of symbol to a psymbol_allocation_list. */
d155 17
a171 4
extern void
add_psymbol_to_list PARAMS ((char *, int, namespace_enum, enum address_class,
			     struct psymbol_allocation_list *, long, CORE_ADDR,
			     enum language, struct objfile *));
d173 1
a173 1
extern void init_psymbol_list PARAMS ((struct objfile *, int));
d175 1
a175 2
extern void
sort_pst_symbols PARAMS ((struct partial_symtab *));
d177 1
a177 2
extern struct symtab *
allocate_symtab PARAMS ((char *, struct objfile *));
d179 1
a179 2
extern int
free_named_symtabs PARAMS ((char *));
d181 1
a181 2
extern void
fill_in_vptr_fieldno PARAMS ((struct type *));
d183 3
a185 2
extern void
add_symtab_fns PARAMS ((struct sym_fns *));
d187 1
a187 2
extern void
init_entry_point_info PARAMS ((struct objfile *));
d189 2
a190 2
extern void
syms_from_objfile PARAMS ((struct objfile *, CORE_ADDR, int, int));
d192 1
a192 2
extern void
new_symfile_objfile PARAMS ((struct objfile *, int, int));
d194 2
a195 5
extern struct partial_symtab *
start_psymtab_common PARAMS ((struct objfile *, struct section_offsets *,
			      char *, CORE_ADDR,
			      struct partial_symbol **,
			      struct partial_symbol **));
d197 2
a198 1
/* Sorting your symbols for fast lookup or alphabetical printing.  */
d200 5
a204 2
extern void
sort_block_syms PARAMS ((struct block *));
d206 2
a207 2
extern void
sort_symtab_syms PARAMS ((struct symtab *));
d209 1
a209 3
/* Make a copy of the string at PTR with SIZE characters in the symbol obstack
   (and add a null character at the end in the copy).
   Returns the address of the copy.  */
a210 2
extern char *
obsavestring PARAMS ((char *, int, struct obstack *));
d212 5
a216 2
/* Concatenate strings S1, S2 and S3; return the new string.
   Space is found in the symbol_obstack.  */
d218 11
a228 3
extern char *
obconcat PARAMS ((struct obstack *obstackp, const char *, const char *,
		  const char *));
d232 9
a240 1
/* whether to auto load solibs at startup time:  0/1. */
d244 9
d255 37
a291 2
extern CORE_ADDR
entry_point_address PARAMS ((void));
d293 2
a294 2
extern struct partial_symtab *
allocate_psymtab PARAMS ((char *, struct objfile *));
d296 2
a297 1
extern void find_lowest_section PARAMS ((bfd *, asection *, PTR));
d299 11
a309 2
/* Remote targets may wish to use this as their load function.  */
extern void generic_load PARAMS ((char *name, int from_tty));
d313 2
a314 3
extern void
dwarf_build_psymtabs PARAMS ((struct objfile *, struct section_offsets *, int,
			      file_ptr, unsigned int, file_ptr, unsigned int));
d318 4
a321 1
extern int dwarf2_has_info PARAMS ((bfd *abfd));
a322 3
extern void dwarf2_build_psymtabs PARAMS ((struct objfile *,
					   struct section_offsets *,
					   int));
a330 11
extern void
mdebug_build_psymtabs PARAMS ((struct objfile *,
			       const struct ecoff_debug_swap *,
			       struct ecoff_debug_info *,
			       struct section_offsets *));

extern void
elfmdebug_build_psymtabs PARAMS ((struct objfile *,
				  const struct ecoff_debug_swap *,
				  asection *,
				  struct section_offsets *));
d332 9
a340 1
#endif	/* !defined(SYMFILE_H) */
@


1.1
log
@file symfile.h was initially added on branch CYGNUS.
@
text
@d1 238
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 340
/* Definitions for reading symbol files into GDB.

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#if !defined (SYMFILE_H)
#define SYMFILE_H

/* This file requires that you first include "bfd.h".  */

/* Opaque declarations.  */
struct section_table;
struct objfile;
struct obstack;
struct block;

/* Partial symbols are stored in the psymbol_cache and pointers to
   them are kept in a dynamically grown array that is obtained from
   malloc and grown as necessary via realloc.  Each objfile typically
   has two of these, one for global symbols and one for static
   symbols.  Although this adds a level of indirection for storing or
   accessing the partial symbols, it allows us to throw away duplicate
   psymbols and set all pointers to the single saved instance.  */

struct psymbol_allocation_list
{

  /* Pointer to beginning of dynamically allocated array of pointers
     to partial symbols.  The array is dynamically expanded as
     necessary to accommodate more pointers.  */

  struct partial_symbol **list;

  /* Pointer to next available slot in which to store a pointer to a
     partial symbol.  */

  struct partial_symbol **next;

  /* Number of allocated pointer slots in current dynamic array (not
     the number of bytes of storage).  The "next" pointer will always
     point somewhere between list[0] and list[size], and when at
     list[size] the array will be expanded on the next attempt to
     store a pointer.  */

  int size;
};

/* Define an array of addresses to accommodate non-contiguous dynamic
   loading of modules.  This is for use when entering commands, so we
   can keep track of the section names until we read the file and can
   map them to bfd sections.  This structure is also used by solib.c
   to communicate the section addresses in shared objects to
   symbol_file_add ().  */

struct section_addr_info
{
  /* The number of sections for which address information is
     available.  */
  size_t num_sections;
  /* Sections whose names are file format dependent. */
  struct other_sections
  {
    CORE_ADDR addr;
    char *name;
    int sectindex;
  } other[1];
};

/* Structure to keep track of symbol reading functions for various
   object file types.  */

struct sym_fns
{

  /* BFD flavour that we handle, or (as a special kludge, see
     xcoffread.c, (enum bfd_flavour)-1 for xcoff).  */

  enum bfd_flavour sym_flavour;

  /* Initializes anything that is global to the entire symbol table.
     It is called during symbol_file_add, when we begin debugging an
     entirely new program.  */

  void (*sym_new_init) (struct objfile *);

  /* Reads any initial information from a symbol file, and initializes
     the struct sym_fns SF in preparation for sym_read().  It is
     called every time we read a symbol file for any reason.  */

  void (*sym_init) (struct objfile *);

  /* sym_read (objfile, mainline) Reads a symbol file into a psymtab
     (or possibly a symtab).  OBJFILE is the objfile struct for the
     file we are reading.  MAINLINE is 1 if this is the main symbol
     table being read, and 0 if a secondary symbol file (e.g. shared
     library or dynamically loaded file) is being read.  */

  void (*sym_read) (struct objfile *, int);

  /* Called when we are finished with an objfile.  Should do all
     cleanup that is specific to the object file format for the
     particular objfile.  */

  void (*sym_finish) (struct objfile *);

  /* This function produces a file-dependent section_offsets
     structure, allocated in the objfile's storage, and based on the
     parameter.  The parameter is currently a CORE_ADDR (FIXME!) for
     backward compatibility with the higher levels of GDB.  It should
     probably be changed to a string, where NULL means the default,
     and others are parsed in a file dependent way.  */

  void (*sym_offsets) (struct objfile *, struct section_addr_info *);

  /* Finds the next struct sym_fns.  They are allocated and
     initialized in whatever module implements the functions pointed
     to; an initializer calls add_symtab_fns to add them to the global
     chain.  */

  struct sym_fns *next;

};

/* The default version of sym_fns.sym_offsets for readers that don't
   do anything special.  */

extern void default_symfile_offsets (struct objfile *objfile,
				     struct section_addr_info *);


extern void extend_psymbol_list (struct psymbol_allocation_list *,
				 struct objfile *);

/* Add any kind of symbol to a psymbol_allocation_list.  */

/* #include "demangle.h" */

extern const
struct partial_symbol *add_psymbol_to_list (char *, int, domain_enum,
					    enum address_class,
					    struct psymbol_allocation_list *,
					    long, CORE_ADDR,
					    enum language, struct objfile *);

extern void add_psymbol_with_dem_name_to_list (char *, int, char *, int,
					       domain_enum,
					       enum address_class,
					       struct psymbol_allocation_list
					       *, long, CORE_ADDR,
					       enum language,
					       struct objfile *);


extern void init_psymbol_list (struct objfile *, int);

extern void sort_pst_symbols (struct partial_symtab *);

extern struct symtab *allocate_symtab (char *, struct objfile *);

extern int free_named_symtabs (char *);

extern void fill_in_vptr_fieldno (struct type *);

extern void add_symtab_fns (struct sym_fns *);

extern void syms_from_objfile (struct objfile *,
			       struct section_addr_info *,
			       struct section_offsets *, int, int, int);

extern void new_symfile_objfile (struct objfile *, int, int);

extern struct objfile *symbol_file_add (char *, int,
					struct section_addr_info *, int, int);

/* Create a new section_addr_info, with room for NUM_SECTIONS.  */

extern struct section_addr_info *alloc_section_addr_info (size_t
							  num_sections);

/* Build (allocate and populate) a section_addr_info struct from an
   existing section table.  */

extern struct section_addr_info
  *build_section_addr_info_from_section_table (const struct section_table
					       *start,
					       const struct section_table
					       *end);

/* Free all memory allocated by
   build_section_addr_info_from_section_table.  */

extern void free_section_addr_info (struct section_addr_info *);


extern struct partial_symtab *start_psymtab_common (struct objfile *,
						    struct section_offsets *,
						    char *, CORE_ADDR,
						    struct partial_symbol **,
						    struct partial_symbol **);

/* Make a copy of the string at PTR with SIZE characters in the symbol
   obstack (and add a null character at the end in the copy).  Returns
   the address of the copy.  */

extern char *obsavestring (const char *, int, struct obstack *);

/* Concatenate strings S1, S2 and S3; return the new string.  Space is
   found in the OBSTACKP  */

extern char *obconcat (struct obstack *obstackp, const char *, const char *,
		       const char *);

			/*   Variables   */

/* If non-zero, shared library symbols will be added automatically
   when the inferior is created, new libraries are loaded, or when
   attaching to the inferior.  This is almost always what users will
   want to have happen; but for very large programs, the startup time
   will be excessive, and so if this is a problem, the user can clear
   this flag and then add the shared library symbols as needed.  Note
   that there is a potential for confusion, since if the shared
   library symbols are not loaded, commands like "info fun" will *not*
   report all the functions that are actually present.  */

extern int auto_solib_add;

/* For systems that support it, a threshold size in megabytes.  If
   automatically adding a new library's symbol table to those already
   known to the debugger would cause the total shared library symbol
   size to exceed this threshhold, then the shlib's symbols are not
   added.  The threshold is ignored if the user explicitly asks for a
   shlib to be added, such as when using the "sharedlibrary" command.  */

extern int auto_solib_limit;

/* From symfile.c */

extern struct partial_symtab *allocate_psymtab (char *, struct objfile *);

extern void discard_psymtab (struct partial_symtab *);

extern void find_lowest_section (bfd *, asection *, void *);

extern bfd *symfile_bfd_open (char *);

extern int get_section_index (struct objfile *, char *);

/* Utility functions for overlay sections: */
extern enum overlay_debugging_state
{
  ovly_off,
  ovly_on,
  ovly_auto
} overlay_debugging;
extern int overlay_cache_invalid;

/* Return the "mapped" overlay section containing the PC.  */
extern asection *find_pc_mapped_section (CORE_ADDR);

/* Return any overlay section containing the PC (even in its LMA
   region).  */
extern asection *find_pc_overlay (CORE_ADDR);

/* Return true if the section is an overlay.  */
extern int section_is_overlay (asection *);

/* Return true if the overlay section is currently "mapped".  */
extern int section_is_mapped (asection *);

/* Return true if pc belongs to section's VMA.  */
extern CORE_ADDR pc_in_mapped_range (CORE_ADDR, asection *);

/* Return true if pc belongs to section's LMA.  */
extern CORE_ADDR pc_in_unmapped_range (CORE_ADDR, asection *);

/* Map an address from a section's LMA to its VMA.  */
extern CORE_ADDR overlay_mapped_address (CORE_ADDR, asection *);

/* Map an address from a section's VMA to its LMA.  */
extern CORE_ADDR overlay_unmapped_address (CORE_ADDR, asection *);

/* Convert an address in an overlay section (force into VMA range).  */
extern CORE_ADDR symbol_overlayed_address (CORE_ADDR, asection *);

/* Load symbols from a file.  */
extern void symbol_file_add_main (char *args, int from_tty);

/* Clear GDB symbol tables.  */
extern void symbol_file_clear (int from_tty);

extern bfd_byte *symfile_relocate_debug_section (bfd *abfd, asection *sectp,
						 bfd_byte * buf);

/* From dwarfread.c */

extern void dwarf_build_psymtabs (struct objfile *, int, file_ptr,
				  unsigned int, file_ptr, unsigned int);

/* From dwarf2read.c */

extern int dwarf2_has_info (bfd *abfd);

extern void dwarf2_build_psymtabs (struct objfile *, int);
extern void dwarf2_build_frame_info (struct objfile *);

/* From mdebugread.c */

/* Hack to force structures to exist before use in parameter list.  */
struct ecoff_debug_hack
{
  struct ecoff_debug_swap *a;
  struct ecoff_debug_info *b;
};

extern void mdebug_build_psymtabs (struct objfile *,
				   const struct ecoff_debug_swap *,
				   struct ecoff_debug_info *);

extern void elfmdebug_build_psymtabs (struct objfile *,
				      const struct ecoff_debug_swap *,
				      asection *);

#endif /* !defined(SYMFILE_H) */
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@a191 4
extern struct objfile *symbol_file_add_from_bfd (bfd *, int,
                                                 struct section_addr_info *,
                                                 int, int);

a196 5
/* Return a freshly allocated copy of ADDRS.  The section names, if
   any, are also freshly allocated copies of those in ADDRS.  */
extern struct section_addr_info *(copy_section_addr_info 
                                  (struct section_addr_info *addrs));

d318 1
a318 1
extern int dwarf2_has_info (struct objfile *);
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 238
/* Definitions for reading symbol files into GDB.
   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996
   Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#if !defined (SYMFILE_H)
#define SYMFILE_H

/* This file requires that you first include "bfd.h".  */

/* Partial symbols are stored in the psymbol_cache and pointers to them
   are kept in a dynamically grown array that is obtained from malloc and
   grown as necessary via realloc.  Each objfile typically has two of these,
   one for global symbols and one for static symbols.  Although this adds
   a level of indirection for storing or accessing the partial symbols,
   it allows us to throw away duplicate psymbols and set all pointers
   to the single saved instance. */

struct psymbol_allocation_list {

  /* Pointer to beginning of dynamically allocated array of pointers to
   partial symbols.  The array is dynamically expanded as necessary to
   accommodate more pointers. */

  struct partial_symbol **list;

  /* Pointer to next available slot in which to store a pointer to a partial
     symbol. */

  struct partial_symbol **next;

  /* Number of allocated pointer slots in current dynamic array (not the
     number of bytes of storage).  The "next" pointer will always point
     somewhere between list[0] and list[size], and when at list[size] the
     array will be expanded on the next attempt to store a pointer. */

  int size;
};

/* Structure to keep track of symbol reading functions for various
   object file types.  */

struct sym_fns {

  /* BFD flavour that we handle, or (as a special kludge, see xcoffread.c,
     (enum bfd_flavour)-1 for xcoff).  */

  enum bfd_flavour sym_flavour;

  /* Initializes anything that is global to the entire symbol table.  It is
     called during symbol_file_add, when we begin debugging an entirely new
     program. */

  void (*sym_new_init) PARAMS ((struct objfile *));

  /* Reads any initial information from a symbol file, and initializes the
     struct sym_fns SF in preparation for sym_read().  It is called every
     time we read a symbol file for any reason. */

  void (*sym_init) PARAMS ((struct objfile *));

  /* sym_read (objfile, addr, mainline)
     Reads a symbol file into a psymtab (or possibly a symtab).
     OBJFILE is the objfile struct for the file we are reading.
     SECTION_OFFSETS
     are the offset between the file's specified section addresses and
     their true addresses in memory.
     MAINLINE is 1 if this is the
     main symbol table being read, and 0 if a secondary
     symbol file (e.g. shared library or dynamically loaded file)
     is being read.  */

  void (*sym_read) PARAMS ((struct objfile *, struct section_offsets *, int));

  /* Called when we are finished with an objfile.  Should do all cleanup
     that is specific to the object file format for the particular objfile. */
 
  void (*sym_finish) PARAMS ((struct objfile *));

  /* This function produces a file-dependent section_offsets structure,
     allocated in the objfile's storage, and based on the parameter.
     The parameter is currently a CORE_ADDR (FIXME!) for backward compatibility
     with the higher levels of GDB.  It should probably be changed to
     a string, where NULL means the default, and others are parsed in a file
     dependent way.  The result of this function is handed in to sym_read.  */

  struct section_offsets *(*sym_offsets) PARAMS ((struct objfile *, CORE_ADDR));

  /* Finds the next struct sym_fns.  They are allocated and initialized
     in whatever module implements the functions pointed to; an 
     initializer calls add_symtab_fns to add them to the global chain.  */

  struct sym_fns *next;

};

/* The default version of sym_fns.sym_offsets for readers that don't
   do anything special.  */

extern struct section_offsets *
default_symfile_offsets PARAMS ((struct objfile *objfile, CORE_ADDR addr));


extern void
extend_psymbol_list PARAMS ((struct psymbol_allocation_list *,
			     struct objfile *));

/* Add any kind of symbol to a psymbol_allocation_list. */

/* #include "demangle.h" */

extern void
add_psymbol_to_list PARAMS ((char *, int, namespace_enum, enum address_class,
			     struct psymbol_allocation_list *, long, CORE_ADDR,
			     enum language, struct objfile *));

extern void init_psymbol_list PARAMS ((struct objfile *, int));

extern void
sort_pst_symbols PARAMS ((struct partial_symtab *));

extern struct symtab *
allocate_symtab PARAMS ((char *, struct objfile *));

extern int
free_named_symtabs PARAMS ((char *));

extern void
fill_in_vptr_fieldno PARAMS ((struct type *));

extern void
add_symtab_fns PARAMS ((struct sym_fns *));

extern void
init_entry_point_info PARAMS ((struct objfile *));

extern void
syms_from_objfile PARAMS ((struct objfile *, CORE_ADDR, int, int));

extern void
new_symfile_objfile PARAMS ((struct objfile *, int, int));

extern struct partial_symtab *
start_psymtab_common PARAMS ((struct objfile *, struct section_offsets *,
			      char *, CORE_ADDR,
			      struct partial_symbol **,
			      struct partial_symbol **));

/* Sorting your symbols for fast lookup or alphabetical printing.  */

extern void
sort_block_syms PARAMS ((struct block *));

extern void
sort_symtab_syms PARAMS ((struct symtab *));

/* Make a copy of the string at PTR with SIZE characters in the symbol obstack
   (and add a null character at the end in the copy).
   Returns the address of the copy.  */

extern char *
obsavestring PARAMS ((char *, int, struct obstack *));

/* Concatenate strings S1, S2 and S3; return the new string.
   Space is found in the symbol_obstack.  */

extern char *
obconcat PARAMS ((struct obstack *obstackp, const char *, const char *,
		  const char *));

			/*   Variables   */

/* whether to auto load solibs at startup time:  0/1. */

extern int auto_solib_add;

/* From symfile.c */

extern CORE_ADDR
entry_point_address PARAMS ((void));

extern struct partial_symtab *
allocate_psymtab PARAMS ((char *, struct objfile *));

extern void find_lowest_section PARAMS ((bfd *, asection *, PTR));

/* Remote targets may wish to use this as their load function.  */
extern void generic_load PARAMS ((char *name, int from_tty));

/* From dwarfread.c */

extern void
dwarf_build_psymtabs PARAMS ((struct objfile *, struct section_offsets *, int,
			      file_ptr, unsigned int, file_ptr, unsigned int));

/* From dwarf2read.c */

extern int dwarf2_has_info PARAMS ((bfd *abfd));

extern void dwarf2_build_psymtabs PARAMS ((struct objfile *,
					   struct section_offsets *,
					   int));
/* From mdebugread.c */

/* Hack to force structures to exist before use in parameter list.  */
struct ecoff_debug_hack
{
  struct ecoff_debug_swap *a;
  struct ecoff_debug_info *b;
};
extern void
mdebug_build_psymtabs PARAMS ((struct objfile *,
			       const struct ecoff_debug_swap *,
			       struct ecoff_debug_info *,
			       struct section_offsets *));

extern void
elfmdebug_build_psymtabs PARAMS ((struct objfile *,
				  const struct ecoff_debug_swap *,
				  asection *,
				  struct section_offsets *));

#endif	/* !defined(SYMFILE_H) */
@
