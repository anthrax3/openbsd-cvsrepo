head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.50
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.48
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.44
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.46
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.38
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.42
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.40
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.36
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.34
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.32
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.30
	OPENBSD_5_0:1.5.0.28
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.26
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.24
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.20
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.22
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.18
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.16
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.5
date	2004.12.27.14.00.43;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.21.20.23.15;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.06.13.19.04;	author otto;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.40.10;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.21.04;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.13.33;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.05.55;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.21.05;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@/* Select target systems and architectures at runtime for GDB.

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.

   Contributed by Cygnus Support.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include <errno.h>
#include "gdb_string.h"
#include "target.h"
#include "gdbcmd.h"
#include "symtab.h"
#include "inferior.h"
#include "bfd.h"
#include "symfile.h"
#include "objfiles.h"
#include "gdb_wait.h"
#include "dcache.h"
#include <signal.h>
#include "regcache.h"
#include "gdb_assert.h"
#include "gdbcore.h"

static void target_info (char *, int);

static void maybe_kill_then_attach (char *, int);

static void kill_or_be_killed (int);

static void default_terminal_info (char *, int);

static int default_region_size_ok_for_hw_watchpoint (int);

static int nosymbol (char *, CORE_ADDR *);

static void tcomplain (void);

static int nomemory (CORE_ADDR, char *, int, int, struct target_ops *);

static int return_zero (void);

static int return_one (void);

static int return_minus_one (void);

void target_ignore (void);

static void target_command (char *, int);

static struct target_ops *find_default_run_target (char *);

static void nosupport_runtime (void);

static LONGEST default_xfer_partial (struct target_ops *ops,
				     enum target_object object,
				     const char *annex, void *readbuf,
				     const void *writebuf,
				     ULONGEST offset, LONGEST len);

/* Transfer LEN bytes between target address MEMADDR and GDB address
   MYADDR.  Returns 0 for success, errno code for failure (which
   includes partial transfers -- if you want a more useful response to
   partial transfers, try either target_read_memory_partial or
   target_write_memory_partial).  */

static int target_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len,
			       int write);

static void init_dummy_target (void);

static struct target_ops debug_target;

static void debug_to_open (char *, int);

static void debug_to_close (int);

static void debug_to_attach (char *, int);

static void debug_to_detach (char *, int);

static void debug_to_disconnect (char *, int);

static void debug_to_resume (ptid_t, int, enum target_signal);

static ptid_t debug_to_wait (ptid_t, struct target_waitstatus *);

static void debug_to_fetch_registers (int);

static void debug_to_store_registers (int);

static void debug_to_prepare_to_store (void);

static int deprecated_debug_xfer_memory (CORE_ADDR, char *, int, int,
					 struct mem_attrib *,
					 struct target_ops *);

static void debug_to_files_info (struct target_ops *);

static int debug_to_insert_breakpoint (CORE_ADDR, char *);

static int debug_to_remove_breakpoint (CORE_ADDR, char *);

static int debug_to_can_use_hw_breakpoint (int, int, int);

static int debug_to_insert_hw_breakpoint (CORE_ADDR, char *);

static int debug_to_remove_hw_breakpoint (CORE_ADDR, char *);

static int debug_to_insert_watchpoint (CORE_ADDR, int, int);

static int debug_to_remove_watchpoint (CORE_ADDR, int, int);

static int debug_to_stopped_by_watchpoint (void);

static int debug_to_stopped_data_address (struct target_ops *, CORE_ADDR *);

static int debug_to_region_size_ok_for_hw_watchpoint (int);

static void debug_to_terminal_init (void);

static void debug_to_terminal_inferior (void);

static void debug_to_terminal_ours_for_output (void);

static void debug_to_terminal_save_ours (void);

static void debug_to_terminal_ours (void);

static void debug_to_terminal_info (char *, int);

static void debug_to_kill (void);

static void debug_to_load (char *, int);

static int debug_to_lookup_symbol (char *, CORE_ADDR *);

static void debug_to_mourn_inferior (void);

static int debug_to_can_run (void);

static void debug_to_notice_signals (ptid_t);

static int debug_to_thread_alive (ptid_t);

static void debug_to_stop (void);

/* NOTE: cagney/2004-09-29: Many targets reference this variable in
   wierd and mysterious ways.  Putting the variable here lets those
   wierd and mysterious ways keep building while they are being
   converted to the inferior inheritance structure.  */
struct target_ops deprecated_child_ops;

/* Pointer to array of target architecture structures; the size of the
   array; the current index into the array; the allocated size of the 
   array.  */
struct target_ops **target_structs;
unsigned target_struct_size;
unsigned target_struct_index;
unsigned target_struct_allocsize;
#define	DEFAULT_ALLOCSIZE	10

/* The initial current target, so that there is always a semi-valid
   current target.  */

static struct target_ops dummy_target;

/* Top of target stack.  */

static struct target_ops *target_stack;

/* The target structure we are currently using to talk to a process
   or file or whatever "inferior" we have.  */

struct target_ops current_target;

/* Command list for target.  */

static struct cmd_list_element *targetlist = NULL;

/* Nonzero if we are debugging an attached outside process
   rather than an inferior.  */

int attach_flag;

/* Non-zero if we want to see trace of target level stuff.  */

static int targetdebug = 0;

static void setup_target_debug (void);

DCACHE *target_dcache;

/* The user just typed 'target' without the name of a target.  */

static void
target_command (char *arg, int from_tty)
{
  fputs_filtered ("Argument required (target name).  Try `help target'\n",
		  gdb_stdout);
}

/* Add a possible target architecture to the list.  */

void
add_target (struct target_ops *t)
{
  /* Provide default values for all "must have" methods.  */
  if (t->to_xfer_partial == NULL)
    t->to_xfer_partial = default_xfer_partial;

  if (!target_structs)
    {
      target_struct_allocsize = DEFAULT_ALLOCSIZE;
      target_structs = (struct target_ops **) xmalloc
	(target_struct_allocsize * sizeof (*target_structs));
    }
  if (target_struct_size >= target_struct_allocsize)
    {
      target_struct_allocsize *= 2;
      target_structs = (struct target_ops **)
	xrealloc ((char *) target_structs,
		  target_struct_allocsize * sizeof (*target_structs));
    }
  target_structs[target_struct_size++] = t;

  if (targetlist == NULL)
    add_prefix_cmd ("target", class_run, target_command,
		    "Connect to a target machine or process.\n\
The first argument is the type or protocol of the target machine.\n\
Remaining arguments are interpreted by the target protocol.  For more\n\
information on the arguments for a particular protocol, type\n\
`help target ' followed by the protocol name.",
		    &targetlist, "target ", 0, &cmdlist);
  add_cmd (t->to_shortname, no_class, t->to_open, t->to_doc, &targetlist);
}

/* Stub functions */

void
target_ignore (void)
{
}

void
target_load (char *arg, int from_tty)
{
  dcache_invalidate (target_dcache);
  (*current_target.to_load) (arg, from_tty);
}

static int
nomemory (CORE_ADDR memaddr, char *myaddr, int len, int write,
	  struct target_ops *t)
{
  errno = EIO;			/* Can't read/write this location */
  return 0;			/* No bytes handled */
}

static void
tcomplain (void)
{
  error ("You can't do that when your target is `%s'",
	 current_target.to_shortname);
}

void
noprocess (void)
{
  error ("You can't do that without a process to debug.");
}

static int
nosymbol (char *name, CORE_ADDR *addrp)
{
  return 1;			/* Symbol does not exist in target env */
}

static void
nosupport_runtime (void)
{
  if (ptid_equal (inferior_ptid, null_ptid))
    noprocess ();
  else
    error ("No run-time support for this");
}


static void
default_terminal_info (char *args, int from_tty)
{
  printf_unfiltered ("No saved terminal information.\n");
}

/* This is the default target_create_inferior and target_attach function.
   If the current target is executing, it asks whether to kill it off.
   If this function returns without calling error(), it has killed off
   the target, and the operation should be attempted.  */

static void
kill_or_be_killed (int from_tty)
{
  if (target_has_execution)
    {
      printf_unfiltered ("You are already running a program:\n");
      target_files_info ();
      if (query ("Kill it? "))
	{
	  target_kill ();
	  if (target_has_execution)
	    error ("Killing the program did not help.");
	  return;
	}
      else
	{
	  error ("Program not killed.");
	}
    }
  tcomplain ();
}

static void
maybe_kill_then_attach (char *args, int from_tty)
{
  kill_or_be_killed (from_tty);
  target_attach (args, from_tty);
}

static void
maybe_kill_then_create_inferior (char *exec, char *args, char **env,
				 int from_tty)
{
  kill_or_be_killed (0);
  target_create_inferior (exec, args, env, from_tty);
}

/* Go through the target stack from top to bottom, copying over zero
   entries in current_target, then filling in still empty entries.  In
   effect, we are doing class inheritance through the pushed target
   vectors.

   NOTE: cagney/2003-10-17: The problem with this inheritance, as it
   is currently implemented, is that it discards any knowledge of
   which target an inherited method originally belonged to.
   Consequently, new new target methods should instead explicitly and
   locally search the target stack for the target that can handle the
   request.  */

static void
update_current_target (void)
{
  struct target_ops *t;

  /* First, reset curren'ts contents.  */
  memset (&current_target, 0, sizeof (current_target));

#define INHERIT(FIELD, TARGET) \
      if (!current_target.FIELD) \
	current_target.FIELD = (TARGET)->FIELD

  for (t = target_stack; t; t = t->beneath)
    {
      INHERIT (to_shortname, t);
      INHERIT (to_longname, t);
      INHERIT (to_doc, t);
      INHERIT (to_open, t);
      INHERIT (to_close, t);
      INHERIT (to_attach, t);
      INHERIT (to_post_attach, t);
      INHERIT (to_detach, t);
      INHERIT (to_disconnect, t);
      INHERIT (to_resume, t);
      INHERIT (to_wait, t);
      INHERIT (to_fetch_registers, t);
      INHERIT (to_store_registers, t);
      INHERIT (to_prepare_to_store, t);
      INHERIT (deprecated_xfer_memory, t);
      INHERIT (to_files_info, t);
      INHERIT (to_insert_breakpoint, t);
      INHERIT (to_remove_breakpoint, t);
      INHERIT (to_can_use_hw_breakpoint, t);
      INHERIT (to_insert_hw_breakpoint, t);
      INHERIT (to_remove_hw_breakpoint, t);
      INHERIT (to_insert_watchpoint, t);
      INHERIT (to_remove_watchpoint, t);
      INHERIT (to_stopped_data_address, t);
      INHERIT (to_stopped_by_watchpoint, t);
      INHERIT (to_have_continuable_watchpoint, t);
      INHERIT (to_region_size_ok_for_hw_watchpoint, t);
      INHERIT (to_terminal_init, t);
      INHERIT (to_terminal_inferior, t);
      INHERIT (to_terminal_ours_for_output, t);
      INHERIT (to_terminal_ours, t);
      INHERIT (to_terminal_save_ours, t);
      INHERIT (to_terminal_info, t);
      INHERIT (to_kill, t);
      INHERIT (to_load, t);
      INHERIT (to_lookup_symbol, t);
      INHERIT (to_create_inferior, t);
      INHERIT (to_post_startup_inferior, t);
      INHERIT (to_acknowledge_created_inferior, t);
      INHERIT (to_insert_fork_catchpoint, t);
      INHERIT (to_remove_fork_catchpoint, t);
      INHERIT (to_insert_vfork_catchpoint, t);
      INHERIT (to_remove_vfork_catchpoint, t);
      INHERIT (to_follow_fork, t);
      INHERIT (to_insert_exec_catchpoint, t);
      INHERIT (to_remove_exec_catchpoint, t);
      INHERIT (to_reported_exec_events_per_exec_call, t);
      INHERIT (to_has_exited, t);
      INHERIT (to_mourn_inferior, t);
      INHERIT (to_can_run, t);
      INHERIT (to_notice_signals, t);
      INHERIT (to_thread_alive, t);
      INHERIT (to_find_new_threads, t);
      INHERIT (to_pid_to_str, t);
      INHERIT (to_extra_thread_info, t);
      INHERIT (to_stop, t);
      /* Do not inherit to_xfer_partial.  */
      INHERIT (to_rcmd, t);
      INHERIT (to_enable_exception_callback, t);
      INHERIT (to_get_current_exception_event, t);
      INHERIT (to_pid_to_exec_file, t);
      INHERIT (to_stratum, t);
      INHERIT (to_has_all_memory, t);
      INHERIT (to_has_memory, t);
      INHERIT (to_has_stack, t);
      INHERIT (to_has_registers, t);
      INHERIT (to_has_execution, t);
      INHERIT (to_has_thread_control, t);
      INHERIT (to_sections, t);
      INHERIT (to_sections_end, t);
      INHERIT (to_can_async_p, t);
      INHERIT (to_is_async_p, t);
      INHERIT (to_async, t);
      INHERIT (to_async_mask_value, t);
      INHERIT (to_find_memory_regions, t);
      INHERIT (to_make_corefile_notes, t);
      INHERIT (to_get_thread_local_address, t);
      INHERIT (to_magic, t);
    }
#undef INHERIT

  /* Clean up a target struct so it no longer has any zero pointers in
     it.  Some entries are defaulted to a method that print an error,
     others are hard-wired to a standard recursive default.  */

#define de_fault(field, value) \
  if (!current_target.field)               \
    current_target.field = value

  de_fault (to_open, 
	    (void (*) (char *, int)) 
	    tcomplain);
  de_fault (to_close, 
	    (void (*) (int)) 
	    target_ignore);
  de_fault (to_attach, 
	    maybe_kill_then_attach);
  de_fault (to_post_attach, 
	    (void (*) (int)) 
	    target_ignore);
  de_fault (to_detach, 
	    (void (*) (char *, int)) 
	    target_ignore);
  de_fault (to_disconnect, 
	    (void (*) (char *, int)) 
	    tcomplain);
  de_fault (to_resume, 
	    (void (*) (ptid_t, int, enum target_signal)) 
	    noprocess);
  de_fault (to_wait, 
	    (ptid_t (*) (ptid_t, struct target_waitstatus *)) 
	    noprocess);
  de_fault (to_fetch_registers, 
	    (void (*) (int)) 
	    target_ignore);
  de_fault (to_store_registers, 
	    (void (*) (int)) 
	    noprocess);
  de_fault (to_prepare_to_store, 
	    (void (*) (void)) 
	    noprocess);
  de_fault (deprecated_xfer_memory, 
	    (int (*) (CORE_ADDR, char *, int, int, struct mem_attrib *, struct target_ops *)) 
	    nomemory);
  de_fault (to_files_info, 
	    (void (*) (struct target_ops *)) 
	    target_ignore);
  de_fault (to_insert_breakpoint, 
	    memory_insert_breakpoint);
  de_fault (to_remove_breakpoint, 
	    memory_remove_breakpoint);
  de_fault (to_can_use_hw_breakpoint,
	    (int (*) (int, int, int))
	    return_zero);
  de_fault (to_insert_hw_breakpoint,
	    (int (*) (CORE_ADDR, char *))
	    return_minus_one);
  de_fault (to_remove_hw_breakpoint,
	    (int (*) (CORE_ADDR, char *))
	    return_minus_one);
  de_fault (to_insert_watchpoint,
	    (int (*) (CORE_ADDR, int, int))
	    return_minus_one);
  de_fault (to_remove_watchpoint,
	    (int (*) (CORE_ADDR, int, int))
	    return_minus_one);
  de_fault (to_stopped_by_watchpoint,
	    (int (*) (void))
	    return_zero);
  de_fault (to_stopped_data_address,
	    (int (*) (struct target_ops *, CORE_ADDR *))
	    return_zero);
  de_fault (to_region_size_ok_for_hw_watchpoint,
	    default_region_size_ok_for_hw_watchpoint);
  de_fault (to_terminal_init, 
	    (void (*) (void)) 
	    target_ignore);
  de_fault (to_terminal_inferior, 
	    (void (*) (void)) 
	    target_ignore);
  de_fault (to_terminal_ours_for_output, 
	    (void (*) (void)) 
	    target_ignore);
  de_fault (to_terminal_ours, 
	    (void (*) (void)) 
	    target_ignore);
  de_fault (to_terminal_save_ours, 
	    (void (*) (void)) 
	    target_ignore);
  de_fault (to_terminal_info, 
	    default_terminal_info);
  de_fault (to_kill, 
	    (void (*) (void)) 
	    noprocess);
  de_fault (to_load, 
	    (void (*) (char *, int)) 
	    tcomplain);
  de_fault (to_lookup_symbol, 
	    (int (*) (char *, CORE_ADDR *)) 
	    nosymbol);
  de_fault (to_create_inferior, 
	    maybe_kill_then_create_inferior);
  de_fault (to_post_startup_inferior, 
	    (void (*) (ptid_t)) 
	    target_ignore);
  de_fault (to_acknowledge_created_inferior, 
	    (void (*) (int)) 
	    target_ignore);
  de_fault (to_insert_fork_catchpoint, 
	    (int (*) (int)) 
	    tcomplain);
  de_fault (to_remove_fork_catchpoint, 
	    (int (*) (int)) 
	    tcomplain);
  de_fault (to_insert_vfork_catchpoint, 
	    (int (*) (int)) 
	    tcomplain);
  de_fault (to_remove_vfork_catchpoint, 
	    (int (*) (int)) 
	    tcomplain);
  de_fault (to_follow_fork,
	    (int (*) (int)) 
	    target_ignore);
  de_fault (to_insert_exec_catchpoint, 
	    (int (*) (int)) 
	    tcomplain);
  de_fault (to_remove_exec_catchpoint, 
	    (int (*) (int)) 
	    tcomplain);
  de_fault (to_reported_exec_events_per_exec_call, 
	    (int (*) (void)) 
	    return_one);
  de_fault (to_has_exited, 
	    (int (*) (int, int, int *)) 
	    return_zero);
  de_fault (to_mourn_inferior, 
	    (void (*) (void)) 
	    noprocess);
  de_fault (to_can_run, 
	    return_zero);
  de_fault (to_notice_signals, 
	    (void (*) (ptid_t)) 
	    target_ignore);
  de_fault (to_thread_alive, 
	    (int (*) (ptid_t)) 
	    return_zero);
  de_fault (to_find_new_threads, 
	    (void (*) (void)) 
	    target_ignore);
  de_fault (to_extra_thread_info, 
	    (char *(*) (struct thread_info *)) 
	    return_zero);
  de_fault (to_stop, 
	    (void (*) (void)) 
	    target_ignore);
  current_target.to_xfer_partial = default_xfer_partial;
  de_fault (to_rcmd, 
	    (void (*) (char *, struct ui_file *)) 
	    tcomplain);
  de_fault (to_enable_exception_callback, 
	    (struct symtab_and_line * (*) (enum exception_event_kind, int)) 
	    nosupport_runtime);
  de_fault (to_get_current_exception_event, 
	    (struct exception_event_record * (*) (void)) 
	    nosupport_runtime);
  de_fault (to_pid_to_exec_file, 
	    (char *(*) (int)) 
	    return_zero);
  de_fault (to_can_async_p, 
	    (int (*) (void)) 
	    return_zero);
  de_fault (to_is_async_p, 
	    (int (*) (void)) 
	    return_zero);
  de_fault (to_async, 
	    (void (*) (void (*) (enum inferior_event_type, void*), void*)) 
	    tcomplain);
#undef de_fault

  /* Finally, position the target-stack beneath the squashed
     "current_target".  That way code looking for a non-inherited
     target method can quickly and simply find it.  */
  current_target.beneath = target_stack;
}

/* Push a new target type into the stack of the existing target accessors,
   possibly superseding some of the existing accessors.

   Result is zero if the pushed target ended up on top of the stack,
   nonzero if at least one target is on top of it.

   Rather than allow an empty stack, we always have the dummy target at
   the bottom stratum, so we can call the function vectors without
   checking them.  */

int
push_target (struct target_ops *t)
{
  struct target_ops **cur;

  /* Check magic number.  If wrong, it probably means someone changed
     the struct definition, but not all the places that initialize one.  */
  if (t->to_magic != OPS_MAGIC)
    {
      fprintf_unfiltered (gdb_stderr,
			  "Magic number of %s target struct wrong\n",
			  t->to_shortname);
      internal_error (__FILE__, __LINE__, "failed internal consistency check");
    }

  /* Find the proper stratum to install this target in.  */
  for (cur = &target_stack; (*cur) != NULL; cur = &(*cur)->beneath)
    {
      if ((int) (t->to_stratum) >= (int) (*cur)->to_stratum)
	break;
    }

  /* If there's already targets at this stratum, remove them.  */
  /* FIXME: cagney/2003-10-15: I think this should be poping all
     targets to CUR, and not just those at this stratum level.  */
  while ((*cur) != NULL && t->to_stratum == (*cur)->to_stratum)
    {
      /* There's already something at this stratum level.  Close it,
         and un-hook it from the stack.  */
      struct target_ops *tmp = (*cur);
      (*cur) = (*cur)->beneath;
      tmp->beneath = NULL;
      target_close (tmp, 0);
    }

  /* We have removed all targets in our stratum, now add the new one.  */
  t->beneath = (*cur);
  (*cur) = t;

  update_current_target ();

  if (targetdebug)
    setup_target_debug ();

  /* Not on top?  */
  return (t != target_stack);
}

/* Remove a target_ops vector from the stack, wherever it may be. 
   Return how many times it was removed (0 or 1).  */

int
unpush_target (struct target_ops *t)
{
  struct target_ops **cur;
  struct target_ops *tmp;

  /* Look for the specified target.  Note that we assume that a target
     can only occur once in the target stack. */

  for (cur = &target_stack; (*cur) != NULL; cur = &(*cur)->beneath)
    {
      if ((*cur) == t)
	break;
    }

  if ((*cur) == NULL)
    return 0;			/* Didn't find target_ops, quit now */

  /* NOTE: cagney/2003-12-06: In '94 the close call was made
     unconditional by moving it to before the above check that the
     target was in the target stack (something about "Change the way
     pushing and popping of targets work to support target overlays
     and inheritance").  This doesn't make much sense - only open
     targets should be closed.  */
  target_close (t, 0);

  /* Unchain the target */
  tmp = (*cur);
  (*cur) = (*cur)->beneath;
  tmp->beneath = NULL;

  update_current_target ();

  return 1;
}

void
pop_target (void)
{
  target_close (&current_target, 0);	/* Let it clean up */
  if (unpush_target (target_stack) == 1)
    return;

  fprintf_unfiltered (gdb_stderr,
		      "pop_target couldn't find target %s\n",
		      current_target.to_shortname);
  internal_error (__FILE__, __LINE__, "failed internal consistency check");
}

#undef	MIN
#define MIN(A, B) (((A) <= (B)) ? (A) : (B))

/* target_read_string -- read a null terminated string, up to LEN bytes,
   from MEMADDR in target.  Set *ERRNOP to the errno code, or 0 if successful.
   Set *STRING to a pointer to malloc'd memory containing the data; the caller
   is responsible for freeing it.  Return the number of bytes successfully
   read.  */

int
target_read_string (CORE_ADDR memaddr, char **string, int len, int *errnop)
{
  int tlen, origlen, offset, i;
  char buf[4];
  int errcode = 0;
  char *buffer;
  int buffer_allocated;
  char *bufptr;
  unsigned int nbytes_read = 0;

  /* Small for testing.  */
  buffer_allocated = 4;
  buffer = xmalloc (buffer_allocated);
  bufptr = buffer;

  origlen = len;

  while (len > 0)
    {
      tlen = MIN (len, 4 - (memaddr & 3));
      offset = memaddr & 3;

      errcode = target_read_memory (memaddr & ~3, buf, 4);
      if (errcode != 0)
	{
	  /* The transfer request might have crossed the boundary to an
	     unallocated region of memory. Retry the transfer, requesting
	     a single byte.  */
	  tlen = 1;
	  offset = 0;
	  errcode = target_read_memory (memaddr, buf, 1);
	  if (errcode != 0)
	    goto done;
	}

      if (bufptr - buffer + tlen > buffer_allocated)
	{
	  unsigned int bytes;
	  bytes = bufptr - buffer;
	  buffer_allocated *= 2;
	  buffer = xrealloc (buffer, buffer_allocated);
	  bufptr = buffer + bytes;
	}

      for (i = 0; i < tlen; i++)
	{
	  *bufptr++ = buf[i + offset];
	  if (buf[i + offset] == '\000')
	    {
	      nbytes_read += i + 1;
	      goto done;
	    }
	}

      memaddr += tlen;
      len -= tlen;
      nbytes_read += tlen;
    }
done:
  if (errnop != NULL)
    *errnop = errcode;
  if (string != NULL)
    *string = buffer;
  return nbytes_read;
}

/* Find a section containing ADDR.  */
struct section_table *
target_section_by_addr (struct target_ops *target, CORE_ADDR addr)
{
  struct section_table *secp;
  for (secp = target->to_sections;
       secp < target->to_sections_end;
       secp++)
    {
      if (addr >= secp->addr && addr < secp->endaddr)
	return secp;
    }
  return NULL;
}

/* Return non-zero when the target vector has supplied an xfer_partial
   method and it, rather than xfer_memory, should be used.  */
static int
target_xfer_partial_p (void)
{
  return (target_stack != NULL
	  && target_stack->to_xfer_partial != default_xfer_partial);
}

static LONGEST
target_xfer_partial (struct target_ops *ops,
		     enum target_object object, const char *annex,
		     void *readbuf, const void *writebuf,
		     ULONGEST offset, LONGEST len)
{
  LONGEST retval;

  gdb_assert (ops->to_xfer_partial != NULL);
  retval = ops->to_xfer_partial (ops, object, annex, readbuf, writebuf,
				 offset, len);
  if (targetdebug)
    {
      const unsigned char *myaddr = NULL;

      fprintf_unfiltered (gdb_stdlog,
			  "%s:target_xfer_partial (%d, %s, 0x%lx,  0x%lx,  0x%s, %s) = %s",
			  ops->to_shortname,
			  (int) object,
			  (annex ? annex : "(null)"),
			  (long) readbuf, (long) writebuf,
			  paddr_nz (offset), paddr_d (len), paddr_d (retval));

      if (readbuf)
	myaddr = readbuf;
      if (writebuf)
	myaddr = writebuf;
      if (retval > 0 && myaddr != NULL)
	{
	  int i;
	  
	  fputs_unfiltered (", bytes =", gdb_stdlog);
	  for (i = 0; i < retval; i++)
	    {
	      if ((((long) &(myaddr[i])) & 0xf) == 0)
		{
		  if (targetdebug < 2 && i > 0)
		    {
		      fprintf_unfiltered (gdb_stdlog, " ...");
		      break;
		    }
		  fprintf_unfiltered (gdb_stdlog, "\n");
		}
	      
	      fprintf_unfiltered (gdb_stdlog, " %02x", myaddr[i] & 0xff);
	    }
	}
      
      fputc_unfiltered ('\n', gdb_stdlog);
    }
  return retval;
}

/* Attempt a transfer all LEN bytes starting at OFFSET between the
   inferior's KIND:ANNEX space and GDB's READBUF/WRITEBUF buffer.  If
   the transfer succeeds, return zero, otherwize the host ERRNO is
   returned.

   The inferior is formed from several layers.  In the case of
   corefiles, inf-corefile is layered above inf-exec and a request for
   text (corefiles do not include text pages) will be first sent to
   the core-stratum, fail, and then sent to the object-file where it
   will succeed.

   NOTE: cagney/2004-09-30:

   The old code tried to use four separate mechanisms for mapping an
   object:offset:len tuple onto an inferior and its address space: the
   target stack; the inferior's TO_SECTIONS; solib's SO_LIST;
   overlays.

   This is stupid.

   The code below is instead using a single mechanism (currently
   strata).  If that mechanism proves insufficient then re-factor it
   implementing another singluar mechanism (for instance, a generic
   object:annex onto inferior:object:annex say).  */

static LONGEST
xfer_using_stratum (enum target_object object, const char *annex,
		    ULONGEST offset, LONGEST len, void *readbuf,
		    const void *writebuf)
{
  LONGEST xfered;
  struct target_ops *target;

  /* Always successful.  */
  if (len == 0)
    return 0;
  /* Never successful.  */
  if (target_stack == NULL)
    return EIO;

  target = target_stack;
  while (1)
    {
      xfered = target_xfer_partial (target, object, annex,
				    readbuf, writebuf, offset, len);
      if (xfered > 0)
	{
	  /* The partial xfer succeeded, update the counts, check that
	     the xfer hasn't finished and if it hasn't set things up
	     for the next round.  */
	  len -= xfered;
	  if (len <= 0)
	    return 0;
	  offset += xfered;
	  if (readbuf != NULL)
	    readbuf = (bfd_byte *) readbuf + xfered;
	  if (writebuf != NULL)
	    writebuf = (bfd_byte *) writebuf + xfered;
	  target = target_stack;
	}
      else if (xfered < 0)
	{
	  /* Something totally screwed up, abandon the attempt to
	     xfer.  */
	  if (errno)
	    return errno;
	  else
	    return EIO;
	}
      else
	{
	  /* This "stratum" didn't work, try the next one down.  */
	  target = target->beneath;
	  if (target == NULL)
	    return EIO;
	}
    }
}

/* Read LEN bytes of target memory at address MEMADDR, placing the results in
   GDB's memory at MYADDR.  Returns either 0 for success or an errno value
   if any error occurs.

   If an error occurs, no guarantee is made about the contents of the data at
   MYADDR.  In particular, the caller should not depend upon partial reads
   filling the buffer with good data.  There is no way for the caller to know
   how much good data might have been transfered anyway.  Callers that can
   deal with partial reads should call target_read_memory_partial. */

int
target_read_memory (CORE_ADDR memaddr, char *myaddr, int len)
{
  if (target_xfer_partial_p ())
    return xfer_using_stratum (TARGET_OBJECT_MEMORY, NULL,
			       memaddr, len, myaddr, NULL);
  else
    return target_xfer_memory (memaddr, myaddr, len, 0);
}

int
target_write_memory (CORE_ADDR memaddr, char *myaddr, int len)
{
  if (target_xfer_partial_p ())
    return xfer_using_stratum (TARGET_OBJECT_MEMORY, NULL,
			       memaddr, len, NULL, myaddr);
  else
    return target_xfer_memory (memaddr, myaddr, len, 1);
}

#ifndef target_stopped_data_address_p
int
target_stopped_data_address_p (struct target_ops *target)
{
  if (target->to_stopped_data_address
      == (int (*) (struct target_ops *, CORE_ADDR *)) return_zero)
    return 0;
  if (target->to_stopped_data_address == debug_to_stopped_data_address
      && (debug_target.to_stopped_data_address
	  == (int (*) (struct target_ops *, CORE_ADDR *)) return_zero))
    return 0;
  return 1;
}
#endif

static int trust_readonly = 0;

/* Move memory to or from the targets.  The top target gets priority;
   if it cannot handle it, it is offered to the next one down, etc.

   Result is -1 on error, or the number of bytes transfered.  */

int
do_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		struct mem_attrib *attrib)
{
  int res;
  int done = 0;
  struct target_ops *t;

  /* Zero length requests are ok and require no work.  */
  if (len == 0)
    return 0;

  /* deprecated_xfer_memory is not guaranteed to set errno, even when
     it returns 0.  */
  errno = 0;

  if (!write && trust_readonly)
    {
      struct section_table *secp;
      /* User-settable option, "trust-readonly-sections".  If true,
         then memory from any SEC_READONLY bfd section may be read
         directly from the bfd file.  */
      secp = target_section_by_addr (&current_target, memaddr);
      if (secp != NULL
	  && (bfd_get_section_flags (secp->bfd, secp->the_bfd_section)
	      & SEC_READONLY))
	return xfer_memory (memaddr, myaddr, len, 0, attrib, &current_target);
    }

  /* The quick case is that the top target can handle the transfer.  */
  res = current_target.deprecated_xfer_memory
    (memaddr, myaddr, len, write, attrib, &current_target);

  /* If res <= 0 then we call it again in the loop.  Ah well. */
  if (res <= 0)
    {
      for (t = target_stack; t != NULL; t = t->beneath)
	{
	  if (!t->to_has_memory)
	    continue;

	  res = t->deprecated_xfer_memory (memaddr, myaddr, len, write, attrib, t);
	  if (res > 0)
	    break;		/* Handled all or part of xfer */
	  if (t->to_has_all_memory)
	    break;
	}

      if (res <= 0)
	return -1;
    }

  return res;
}


/* Perform a memory transfer.  Iterate until the entire region has
   been transfered.

   Result is 0 or errno value.  */

static int
target_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write)
{
  int res;
  int reg_len;
  struct mem_region *region;

  /* Zero length requests are ok and require no work.  */
  if (len == 0)
    {
      return 0;
    }

  while (len > 0)
    {
      region = lookup_mem_region(memaddr);
      if (memaddr + len < region->hi)
	reg_len = len;
      else
	reg_len = region->hi - memaddr;

      switch (region->attrib.mode)
	{
	case MEM_RO:
	  if (write)
	    return EIO;
	  break;
	  
	case MEM_WO:
	  if (!write)
	    return EIO;
	  break;
	}

      while (reg_len > 0)
	{
	  if (region->attrib.cache)
	    res = dcache_xfer_memory (target_dcache, memaddr, myaddr,
				     reg_len, write);
	  else
	    res = do_xfer_memory (memaddr, myaddr, reg_len, write,
				 &region->attrib);
	      
	  if (res <= 0)
	    {
	      /* If this address is for nonexistent memory, read zeros
		 if reading, or do nothing if writing.  Return
		 error. */
	      if (!write)
		memset (myaddr, 0, len);
	      if (errno == 0)
		return EIO;
	      else
		return errno;
	    }

	  memaddr += res;
	  myaddr  += res;
	  len     -= res;
	  reg_len -= res;
	}
    }
  
  return 0;			/* We managed to cover it all somehow. */
}


/* Perform a partial memory transfer.

   Result is -1 on error, or the number of bytes transfered.  */

static int
target_xfer_memory_partial (CORE_ADDR memaddr, char *myaddr, int len,
			    int write_p, int *err)
{
  int res;
  int reg_len;
  struct mem_region *region;

  /* Zero length requests are ok and require no work.  */
  if (len == 0)
    {
      *err = 0;
      return 0;
    }

  region = lookup_mem_region(memaddr);
  if (memaddr + len < region->hi)
    reg_len = len;
  else
    reg_len = region->hi - memaddr;

  switch (region->attrib.mode)
    {
    case MEM_RO:
      if (write_p)
	{
	  *err = EIO;
	  return -1;
	}
      break;

    case MEM_WO:
      if (write_p)
	{
	  *err = EIO;
	  return -1;
	}
      break;
    }

  if (region->attrib.cache)
    res = dcache_xfer_memory (target_dcache, memaddr, myaddr,
			      reg_len, write_p);
  else
    res = do_xfer_memory (memaddr, myaddr, reg_len, write_p,
			  &region->attrib);
      
  if (res <= 0)
    {
      if (errno != 0)
	*err = errno;
      else
	*err = EIO;

        return -1;
    }

  *err = 0;
  return res;
}

int
target_read_memory_partial (CORE_ADDR memaddr, char *buf, int len, int *err)
{
  if (target_xfer_partial_p ())
    return target_xfer_partial (target_stack, TARGET_OBJECT_MEMORY, NULL,
				buf, NULL, memaddr, len);
  else
    return target_xfer_memory_partial (memaddr, buf, len, 0, err);
}

int
target_write_memory_partial (CORE_ADDR memaddr, char *buf, int len, int *err)
{
  if (target_xfer_partial_p ())
    return target_xfer_partial (target_stack, TARGET_OBJECT_MEMORY, NULL,
				NULL, buf, memaddr, len);
  else
    return target_xfer_memory_partial (memaddr, buf, len, 1, err);
}

/* More generic transfers.  */

static LONGEST
default_xfer_partial (struct target_ops *ops, enum target_object object,
		      const char *annex, void *readbuf, 
		      const void *writebuf, ULONGEST offset, LONGEST len)
{
  if (object == TARGET_OBJECT_MEMORY
      && ops->deprecated_xfer_memory != NULL)
    /* If available, fall back to the target's
       "deprecated_xfer_memory" method.  */
    {
      int xfered = -1;
      errno = 0;
      if (writebuf != NULL)
	{
	  void *buffer = xmalloc (len);
	  struct cleanup *cleanup = make_cleanup (xfree, buffer);
	  memcpy (buffer, writebuf, len);
	  xfered = ops->deprecated_xfer_memory (offset, buffer, len,
						1/*write*/, NULL, ops);
	  do_cleanups (cleanup);
	}
      if (readbuf != NULL)
	xfered = ops->deprecated_xfer_memory (offset, readbuf, len, 0/*read*/,
					      NULL, ops);
      if (xfered > 0)
	return xfered;
      else if (xfered == 0 && errno == 0)
	/* "deprecated_xfer_memory" uses 0, cross checked against
           ERRNO as one indication of an error.  */
	return 0;
      else
	return -1;
    }
  else if (ops->beneath != NULL)
    return target_xfer_partial (ops->beneath, object, annex,
				readbuf, writebuf, offset, len);
  else
    return -1;
}

/* Target vector read/write partial wrapper functions.

   NOTE: cagney/2003-10-21: I wonder if having "to_xfer_partial
   (inbuf, outbuf)", instead of separate read/write methods, make life
   easier.  */

LONGEST
target_read_partial (struct target_ops *ops,
		     enum target_object object,
		     const char *annex, void *buf,
		     ULONGEST offset, LONGEST len)
{
  return target_xfer_partial (ops, object, annex, buf, NULL, offset, len);
}

LONGEST
target_write_partial (struct target_ops *ops,
		      enum target_object object,
		      const char *annex, const void *buf,
		      ULONGEST offset, LONGEST len)
{
  return target_xfer_partial (ops, object, annex, NULL, buf, offset, len);
}

/* Wrappers to perform the full transfer.  */
LONGEST
target_read (struct target_ops *ops,
	     enum target_object object,
	     const char *annex, void *buf,
	     ULONGEST offset, LONGEST len)
{
  LONGEST xfered = 0;
  while (xfered < len)
    {
      LONGEST xfer = target_read_partial (ops, object, annex,
					  (bfd_byte *) buf + xfered,
					  offset + xfered, len - xfered);
      /* Call an observer, notifying them of the xfer progress?  */
      if (xfer <= 0)
	/* Call memory_error?  */
	return -1;
      xfered += xfer;
      QUIT;
    }
  return len;
}

LONGEST
target_write (struct target_ops *ops,
	      enum target_object object,
	      const char *annex, const void *buf,
	      ULONGEST offset, LONGEST len)
{
  LONGEST xfered = 0;
  while (xfered < len)
    {
      LONGEST xfer = target_write_partial (ops, object, annex,
					   (bfd_byte *) buf + xfered,
					   offset + xfered, len - xfered);
      /* Call an observer, notifying them of the xfer progress?  */
      if (xfer <= 0)
	/* Call memory_error?  */
	return -1;
      xfered += xfer;
      QUIT;
    }
  return len;
}

/* Memory transfer methods.  */

void
get_target_memory (struct target_ops *ops, CORE_ADDR addr, void *buf,
		   LONGEST len)
{
  if (target_read (ops, TARGET_OBJECT_MEMORY, NULL, buf, addr, len)
      != len)
    memory_error (EIO, addr);
}

ULONGEST
get_target_memory_unsigned (struct target_ops *ops,
			    CORE_ADDR addr, int len)
{
  char buf[sizeof (ULONGEST)];

  gdb_assert (len <= sizeof (buf));
  get_target_memory (ops, addr, buf, len);
  return extract_unsigned_integer (buf, len);
}

static void
target_info (char *args, int from_tty)
{
  struct target_ops *t;
  int has_all_mem = 0;

  if (symfile_objfile != NULL)
    printf_unfiltered ("Symbols from \"%s\".\n", symfile_objfile->name);

  for (t = target_stack; t != NULL; t = t->beneath)
    {
      if (!t->to_has_memory)
	continue;

      if ((int) (t->to_stratum) <= (int) dummy_stratum)
	continue;
      if (has_all_mem)
	printf_unfiltered ("\tWhile running this, GDB does not access memory from...\n");
      printf_unfiltered ("%s:\n", t->to_longname);
      (t->to_files_info) (t);
      has_all_mem = t->to_has_all_memory;
    }
}

/* This is to be called by the open routine before it does
   anything.  */

void
target_preopen (int from_tty)
{
  dont_repeat ();

  if (target_has_execution)
    {
      if (!from_tty
          || query ("A program is being debugged already.  Kill it? "))
	target_kill ();
      else
	error ("Program not killed.");
    }

  /* Calling target_kill may remove the target from the stack.  But if
     it doesn't (which seems like a win for UDI), remove it now.  */

  if (target_has_execution)
    pop_target ();
}

/* Detach a target after doing deferred register stores.  */

void
target_detach (char *args, int from_tty)
{
  (current_target.to_detach) (args, from_tty);
}

void
target_disconnect (char *args, int from_tty)
{
  (current_target.to_disconnect) (args, from_tty);
}

void
target_link (char *modname, CORE_ADDR *t_reloc)
{
  if (DEPRECATED_STREQ (current_target.to_shortname, "rombug"))
    {
      (current_target.to_lookup_symbol) (modname, t_reloc);
      if (*t_reloc == 0)
	error ("Unable to link to %s and get relocation in rombug", modname);
    }
  else
    *t_reloc = (CORE_ADDR) -1;
}

int
target_async_mask (int mask)
{
  int saved_async_masked_status = target_async_mask_value;
  target_async_mask_value = mask;
  return saved_async_masked_status;
}

/* Look through the list of possible targets for a target that can
   execute a run or attach command without any other data.  This is
   used to locate the default process stratum.

   Result is always valid (error() is called for errors).  */

static struct target_ops *
find_default_run_target (char *do_mesg)
{
  struct target_ops **t;
  struct target_ops *runable = NULL;
  int count;

  count = 0;

  for (t = target_structs; t < target_structs + target_struct_size;
       ++t)
    {
      if ((*t)->to_can_run && target_can_run (*t))
	{
	  runable = *t;
	  ++count;
	}
    }

  if (count != 1)
    error ("Don't know how to %s.  Try \"help target\".", do_mesg);

  return runable;
}

void
find_default_attach (char *args, int from_tty)
{
  struct target_ops *t;

  t = find_default_run_target ("attach");
  (t->to_attach) (args, from_tty);
  return;
}

void
find_default_create_inferior (char *exec_file, char *allargs, char **env,
			      int from_tty)
{
  struct target_ops *t;

  t = find_default_run_target ("run");
  (t->to_create_inferior) (exec_file, allargs, env, from_tty);
  return;
}

static int
default_region_size_ok_for_hw_watchpoint (int byte_count)
{
  return (byte_count <= TYPE_LENGTH (builtin_type_void_data_ptr));
}

static int
return_zero (void)
{
  return 0;
}

static int
return_one (void)
{
  return 1;
}

static int
return_minus_one (void)
{
  return -1;
}

/*
 * Resize the to_sections pointer.  Also make sure that anyone that
 * was holding on to an old value of it gets updated.
 * Returns the old size.
 */

int
target_resize_to_sections (struct target_ops *target, int num_added)
{
  struct target_ops **t;
  struct section_table *old_value;
  int old_count;

  old_value = target->to_sections;

  if (target->to_sections)
    {
      old_count = target->to_sections_end - target->to_sections;
      target->to_sections = (struct section_table *)
	xrealloc ((char *) target->to_sections,
		  (sizeof (struct section_table)) * (num_added + old_count));
    }
  else
    {
      old_count = 0;
      target->to_sections = (struct section_table *)
	xmalloc ((sizeof (struct section_table)) * num_added);
    }
  target->to_sections_end = target->to_sections + (num_added + old_count);

  /* Check to see if anyone else was pointing to this structure.
     If old_value was null, then no one was. */
     
  if (old_value)
    {
      for (t = target_structs; t < target_structs + target_struct_size;
	   ++t)
	{
	  if ((*t)->to_sections == old_value)
	    {
	      (*t)->to_sections = target->to_sections;
	      (*t)->to_sections_end = target->to_sections_end;
	    }
	}
      /* There is a flattened view of the target stack in current_target,
	 so its to_sections pointer might also need updating. */
      if (current_target.to_sections == old_value)
	{
	  current_target.to_sections = target->to_sections;
	  current_target.to_sections_end = target->to_sections_end;
	}
    }
  
  return old_count;

}

/* Remove all target sections taken from ABFD.

   Scan the current target stack for targets whose section tables
   refer to sections from BFD, and remove those sections.  We use this
   when we notice that the inferior has unloaded a shared object, for
   example.  */
void
remove_target_sections (bfd *abfd)
{
  struct target_ops **t;

  for (t = target_structs; t < target_structs + target_struct_size; t++)
    {
      struct section_table *src, *dest;

      dest = (*t)->to_sections;
      for (src = (*t)->to_sections; src < (*t)->to_sections_end; src++)
	if (src->bfd != abfd)
	  {
	    /* Keep this section.  */
	    if (dest < src) *dest = *src;
	    dest++;
	  }

      /* If we've dropped any sections, resize the section table.  */
      if (dest < src)
	target_resize_to_sections (*t, dest - src);
    }
}




/* Find a single runnable target in the stack and return it.  If for
   some reason there is more than one, return NULL.  */

struct target_ops *
find_run_target (void)
{
  struct target_ops **t;
  struct target_ops *runable = NULL;
  int count;

  count = 0;

  for (t = target_structs; t < target_structs + target_struct_size; ++t)
    {
      if ((*t)->to_can_run && target_can_run (*t))
	{
	  runable = *t;
	  ++count;
	}
    }

  return (count == 1 ? runable : NULL);
}

/* Find a single core_stratum target in the list of targets and return it.
   If for some reason there is more than one, return NULL.  */

struct target_ops *
find_core_target (void)
{
  struct target_ops **t;
  struct target_ops *runable = NULL;
  int count;

  count = 0;

  for (t = target_structs; t < target_structs + target_struct_size;
       ++t)
    {
      if ((*t)->to_stratum == core_stratum)
	{
	  runable = *t;
	  ++count;
	}
    }

  return (count == 1 ? runable : NULL);
}

/*
 * Find the next target down the stack from the specified target.
 */

struct target_ops *
find_target_beneath (struct target_ops *t)
{
  return t->beneath;
}


/* The inferior process has died.  Long live the inferior!  */

void
generic_mourn_inferior (void)
{
  extern int show_breakpoint_hit_counts;

  inferior_ptid = null_ptid;
  attach_flag = 0;
  breakpoint_init_inferior (inf_exited);
  registers_changed ();

  reopen_exec_file ();
  reinit_frame_cache ();

  /* It is confusing to the user for ignore counts to stick around
     from previous runs of the inferior.  So clear them.  */
  /* However, it is more confusing for the ignore counts to disappear when
     using hit counts.  So don't clear them if we're counting hits.  */
  if (!show_breakpoint_hit_counts)
    breakpoint_clear_ignore_counts ();

  if (deprecated_detach_hook)
    deprecated_detach_hook ();
}

/* Helper function for child_wait and the Lynx derivatives of child_wait.
   HOSTSTATUS is the waitstatus from wait() or the equivalent; store our
   translation of that in OURSTATUS.  */
void
store_waitstatus (struct target_waitstatus *ourstatus, int hoststatus)
{
#ifdef CHILD_SPECIAL_WAITSTATUS
  /* CHILD_SPECIAL_WAITSTATUS should return nonzero and set *OURSTATUS
     if it wants to deal with hoststatus.  */
  if (CHILD_SPECIAL_WAITSTATUS (ourstatus, hoststatus))
    return;
#endif

  if (WIFEXITED (hoststatus))
    {
      ourstatus->kind = TARGET_WAITKIND_EXITED;
      ourstatus->value.integer = WEXITSTATUS (hoststatus);
    }
  else if (!WIFSTOPPED (hoststatus))
    {
      ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
      ourstatus->value.sig = target_signal_from_host (WTERMSIG (hoststatus));
    }
  else
    {
      ourstatus->kind = TARGET_WAITKIND_STOPPED;
      ourstatus->value.sig = target_signal_from_host (WSTOPSIG (hoststatus));
    }
}

/* Returns zero to leave the inferior alone, one to interrupt it.  */
int (*target_activity_function) (void);
int target_activity_fd;

/* Convert a normal process ID to a string.  Returns the string in a static
   buffer.  */

char *
normal_pid_to_str (ptid_t ptid)
{
  static char buf[30];

  sprintf (buf, "process %d", PIDGET (ptid));
  return buf;
}

/* Error-catcher for target_find_memory_regions */
static int dummy_find_memory_regions (int (*ignore1) (), void *ignore2)
{
  error ("No target.");
  return 0;
}

/* Error-catcher for target_make_corefile_notes */
static char * dummy_make_corefile_notes (bfd *ignore1, int *ignore2)
{
  error ("No target.");
  return NULL;
}

/* Set up the handful of non-empty slots needed by the dummy target
   vector.  */

static void
init_dummy_target (void)
{
  dummy_target.to_shortname = "None";
  dummy_target.to_longname = "None";
  dummy_target.to_doc = "";
  dummy_target.to_attach = find_default_attach;
  dummy_target.to_create_inferior = find_default_create_inferior;
  dummy_target.to_pid_to_str = normal_pid_to_str;
  dummy_target.to_stratum = dummy_stratum;
  dummy_target.to_find_memory_regions = dummy_find_memory_regions;
  dummy_target.to_make_corefile_notes = dummy_make_corefile_notes;
  dummy_target.to_xfer_partial = default_xfer_partial;
  dummy_target.to_magic = OPS_MAGIC;
}

static void
debug_to_open (char *args, int from_tty)
{
  debug_target.to_open (args, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_open (%s, %d)\n", args, from_tty);
}

static void
debug_to_close (int quitting)
{
  target_close (&debug_target, quitting);
  fprintf_unfiltered (gdb_stdlog, "target_close (%d)\n", quitting);
}

void
target_close (struct target_ops *targ, int quitting)
{
  if (targ->to_xclose != NULL)
    targ->to_xclose (targ, quitting);
  else if (targ->to_close != NULL)
    targ->to_close (quitting);
}

static void
debug_to_attach (char *args, int from_tty)
{
  debug_target.to_attach (args, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_attach (%s, %d)\n", args, from_tty);
}


static void
debug_to_post_attach (int pid)
{
  debug_target.to_post_attach (pid);

  fprintf_unfiltered (gdb_stdlog, "target_post_attach (%d)\n", pid);
}

static void
debug_to_detach (char *args, int from_tty)
{
  debug_target.to_detach (args, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_detach (%s, %d)\n", args, from_tty);
}

static void
debug_to_disconnect (char *args, int from_tty)
{
  debug_target.to_disconnect (args, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_disconnect (%s, %d)\n",
		      args, from_tty);
}

static void
debug_to_resume (ptid_t ptid, int step, enum target_signal siggnal)
{
  debug_target.to_resume (ptid, step, siggnal);

  fprintf_unfiltered (gdb_stdlog, "target_resume (%d, %s, %s)\n", PIDGET (ptid),
		      step ? "step" : "continue",
		      target_signal_to_name (siggnal));
}

static ptid_t
debug_to_wait (ptid_t ptid, struct target_waitstatus *status)
{
  ptid_t retval;

  retval = debug_target.to_wait (ptid, status);

  fprintf_unfiltered (gdb_stdlog,
		      "target_wait (%d, status) = %d,   ", PIDGET (ptid),
		      PIDGET (retval));
  fprintf_unfiltered (gdb_stdlog, "status->kind = ");
  switch (status->kind)
    {
    case TARGET_WAITKIND_EXITED:
      fprintf_unfiltered (gdb_stdlog, "exited, status = %d\n",
			  status->value.integer);
      break;
    case TARGET_WAITKIND_STOPPED:
      fprintf_unfiltered (gdb_stdlog, "stopped, signal = %s\n",
			  target_signal_to_name (status->value.sig));
      break;
    case TARGET_WAITKIND_SIGNALLED:
      fprintf_unfiltered (gdb_stdlog, "signalled, signal = %s\n",
			  target_signal_to_name (status->value.sig));
      break;
    case TARGET_WAITKIND_LOADED:
      fprintf_unfiltered (gdb_stdlog, "loaded\n");
      break;
    case TARGET_WAITKIND_FORKED:
      fprintf_unfiltered (gdb_stdlog, "forked\n");
      break;
    case TARGET_WAITKIND_VFORKED:
      fprintf_unfiltered (gdb_stdlog, "vforked\n");
      break;
    case TARGET_WAITKIND_EXECD:
      fprintf_unfiltered (gdb_stdlog, "execd\n");
      break;
    case TARGET_WAITKIND_SPURIOUS:
      fprintf_unfiltered (gdb_stdlog, "spurious\n");
      break;
    default:
      fprintf_unfiltered (gdb_stdlog, "unknown???\n");
      break;
    }

  return retval;
}

static void
debug_print_register (const char * func, int regno)
{
  fprintf_unfiltered (gdb_stdlog, "%s ", func);
  if (regno >= 0 && regno < NUM_REGS + NUM_PSEUDO_REGS
      && REGISTER_NAME (regno) != NULL && REGISTER_NAME (regno)[0] != '\0')
    fprintf_unfiltered (gdb_stdlog, "(%s)", REGISTER_NAME (regno));
  else
    fprintf_unfiltered (gdb_stdlog, "(%d)", regno);
  if (regno >= 0)
    {
      int i;
      unsigned char buf[MAX_REGISTER_SIZE];
      deprecated_read_register_gen (regno, buf);
      fprintf_unfiltered (gdb_stdlog, " = ");
      for (i = 0; i < register_size (current_gdbarch, regno); i++)
	{
	  fprintf_unfiltered (gdb_stdlog, "%02x", buf[i]);
	}
      if (register_size (current_gdbarch, regno) <= sizeof (LONGEST))
	{
	  fprintf_unfiltered (gdb_stdlog, " 0x%s %s",
			      paddr_nz (read_register (regno)),
			      paddr_d (read_register (regno)));
	}
    }
  fprintf_unfiltered (gdb_stdlog, "\n");
}

static void
debug_to_fetch_registers (int regno)
{
  debug_target.to_fetch_registers (regno);
  debug_print_register ("target_fetch_registers", regno);
}

static void
debug_to_store_registers (int regno)
{
  debug_target.to_store_registers (regno);
  debug_print_register ("target_store_registers", regno);
  fprintf_unfiltered (gdb_stdlog, "\n");
}

static void
debug_to_prepare_to_store (void)
{
  debug_target.to_prepare_to_store ();

  fprintf_unfiltered (gdb_stdlog, "target_prepare_to_store ()\n");
}

static int
deprecated_debug_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len,
			      int write, struct mem_attrib *attrib,
			      struct target_ops *target)
{
  int retval;

  retval = debug_target.deprecated_xfer_memory (memaddr, myaddr, len, write,
						attrib, target);

  fprintf_unfiltered (gdb_stdlog,
		      "target_xfer_memory (0x%x, xxx, %d, %s, xxx) = %d",
		      (unsigned int) memaddr,	/* possable truncate long long */
		      len, write ? "write" : "read", retval);

  if (retval > 0)
    {
      int i;

      fputs_unfiltered (", bytes =", gdb_stdlog);
      for (i = 0; i < retval; i++)
	{
	  if ((((long) &(myaddr[i])) & 0xf) == 0)
	    {
	      if (targetdebug < 2 && i > 0)
		{
		  fprintf_unfiltered (gdb_stdlog, " ...");
		  break;
		}
	      fprintf_unfiltered (gdb_stdlog, "\n");
	    }
	  
	  fprintf_unfiltered (gdb_stdlog, " %02x", myaddr[i] & 0xff);
	}
    }

  fputc_unfiltered ('\n', gdb_stdlog);

  return retval;
}

static void
debug_to_files_info (struct target_ops *target)
{
  debug_target.to_files_info (target);

  fprintf_unfiltered (gdb_stdlog, "target_files_info (xxx)\n");
}

static int
debug_to_insert_breakpoint (CORE_ADDR addr, char *save)
{
  int retval;

  retval = debug_target.to_insert_breakpoint (addr, save);

  fprintf_unfiltered (gdb_stdlog,
		      "target_insert_breakpoint (0x%lx, xxx) = %ld\n",
		      (unsigned long) addr,
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_remove_breakpoint (CORE_ADDR addr, char *save)
{
  int retval;

  retval = debug_target.to_remove_breakpoint (addr, save);

  fprintf_unfiltered (gdb_stdlog,
		      "target_remove_breakpoint (0x%lx, xxx) = %ld\n",
		      (unsigned long) addr,
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_can_use_hw_breakpoint (int type, int cnt, int from_tty)
{
  int retval;

  retval = debug_target.to_can_use_hw_breakpoint (type, cnt, from_tty);

  fprintf_unfiltered (gdb_stdlog,
		      "target_can_use_hw_breakpoint (%ld, %ld, %ld) = %ld\n",
		      (unsigned long) type,
		      (unsigned long) cnt,
		      (unsigned long) from_tty,
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_region_size_ok_for_hw_watchpoint (int byte_count)
{
  CORE_ADDR retval;

  retval = debug_target.to_region_size_ok_for_hw_watchpoint (byte_count);

  fprintf_unfiltered (gdb_stdlog,
		      "TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT (%ld) = 0x%lx\n",
		      (unsigned long) byte_count,
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_stopped_by_watchpoint (void)
{
  int retval;

  retval = debug_target.to_stopped_by_watchpoint ();

  fprintf_unfiltered (gdb_stdlog,
		      "STOPPED_BY_WATCHPOINT () = %ld\n",
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_stopped_data_address (struct target_ops *target, CORE_ADDR *addr)
{
  int retval;

  retval = debug_target.to_stopped_data_address (target, addr);

  fprintf_unfiltered (gdb_stdlog,
		      "target_stopped_data_address ([0x%lx]) = %ld\n",
		      (unsigned long)*addr,
		      (unsigned long)retval);
  return retval;
}

static int
debug_to_insert_hw_breakpoint (CORE_ADDR addr, char *save)
{
  int retval;

  retval = debug_target.to_insert_hw_breakpoint (addr, save);

  fprintf_unfiltered (gdb_stdlog,
		      "target_insert_hw_breakpoint (0x%lx, xxx) = %ld\n",
		      (unsigned long) addr,
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_remove_hw_breakpoint (CORE_ADDR addr, char *save)
{
  int retval;

  retval = debug_target.to_remove_hw_breakpoint (addr, save);

  fprintf_unfiltered (gdb_stdlog,
		      "target_remove_hw_breakpoint (0x%lx, xxx) = %ld\n",
		      (unsigned long) addr,
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_insert_watchpoint (CORE_ADDR addr, int len, int type)
{
  int retval;

  retval = debug_target.to_insert_watchpoint (addr, len, type);

  fprintf_unfiltered (gdb_stdlog,
		      "target_insert_watchpoint (0x%lx, %d, %d) = %ld\n",
		      (unsigned long) addr, len, type, (unsigned long) retval);
  return retval;
}

static int
debug_to_remove_watchpoint (CORE_ADDR addr, int len, int type)
{
  int retval;

  retval = debug_target.to_insert_watchpoint (addr, len, type);

  fprintf_unfiltered (gdb_stdlog,
		      "target_insert_watchpoint (0x%lx, %d, %d) = %ld\n",
		      (unsigned long) addr, len, type, (unsigned long) retval);
  return retval;
}

static void
debug_to_terminal_init (void)
{
  debug_target.to_terminal_init ();

  fprintf_unfiltered (gdb_stdlog, "target_terminal_init ()\n");
}

static void
debug_to_terminal_inferior (void)
{
  debug_target.to_terminal_inferior ();

  fprintf_unfiltered (gdb_stdlog, "target_terminal_inferior ()\n");
}

static void
debug_to_terminal_ours_for_output (void)
{
  debug_target.to_terminal_ours_for_output ();

  fprintf_unfiltered (gdb_stdlog, "target_terminal_ours_for_output ()\n");
}

static void
debug_to_terminal_ours (void)
{
  debug_target.to_terminal_ours ();

  fprintf_unfiltered (gdb_stdlog, "target_terminal_ours ()\n");
}

static void
debug_to_terminal_save_ours (void)
{
  debug_target.to_terminal_save_ours ();

  fprintf_unfiltered (gdb_stdlog, "target_terminal_save_ours ()\n");
}

static void
debug_to_terminal_info (char *arg, int from_tty)
{
  debug_target.to_terminal_info (arg, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_terminal_info (%s, %d)\n", arg,
		      from_tty);
}

static void
debug_to_kill (void)
{
  debug_target.to_kill ();

  fprintf_unfiltered (gdb_stdlog, "target_kill ()\n");
}

static void
debug_to_load (char *args, int from_tty)
{
  debug_target.to_load (args, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_load (%s, %d)\n", args, from_tty);
}

static int
debug_to_lookup_symbol (char *name, CORE_ADDR *addrp)
{
  int retval;

  retval = debug_target.to_lookup_symbol (name, addrp);

  fprintf_unfiltered (gdb_stdlog, "target_lookup_symbol (%s, xxx)\n", name);

  return retval;
}

static void
debug_to_create_inferior (char *exec_file, char *args, char **env,
			  int from_tty)
{
  debug_target.to_create_inferior (exec_file, args, env, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_create_inferior (%s, %s, xxx, %d)\n",
		      exec_file, args, from_tty);
}

static void
debug_to_post_startup_inferior (ptid_t ptid)
{
  debug_target.to_post_startup_inferior (ptid);

  fprintf_unfiltered (gdb_stdlog, "target_post_startup_inferior (%d)\n",
		      PIDGET (ptid));
}

static void
debug_to_acknowledge_created_inferior (int pid)
{
  debug_target.to_acknowledge_created_inferior (pid);

  fprintf_unfiltered (gdb_stdlog, "target_acknowledge_created_inferior (%d)\n",
		      pid);
}

static int
debug_to_insert_fork_catchpoint (int pid)
{
  int retval;

  retval = debug_target.to_insert_fork_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_insert_fork_catchpoint (%d) = %d\n",
		      pid, retval);

  return retval;
}

static int
debug_to_remove_fork_catchpoint (int pid)
{
  int retval;

  retval = debug_target.to_remove_fork_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_remove_fork_catchpoint (%d) = %d\n",
		      pid, retval);

  return retval;
}

static int
debug_to_insert_vfork_catchpoint (int pid)
{
  int retval;

  retval = debug_target.to_insert_vfork_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_insert_vfork_catchpoint (%d)= %d\n",
		      pid, retval);

  return retval;
}

static int
debug_to_remove_vfork_catchpoint (int pid)
{
  int retval;

  retval = debug_target.to_remove_vfork_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_remove_vfork_catchpoint (%d) = %d\n",
		      pid, retval);

  return retval;
}

static int
debug_to_follow_fork (int follow_child)
{
  int retval =  debug_target.to_follow_fork (follow_child);

  fprintf_unfiltered (gdb_stdlog, "target_follow_fork (%d) = %d\n",
		      follow_child, retval);

  return retval;
}

static int
debug_to_insert_exec_catchpoint (int pid)
{
  int retval;

  retval = debug_target.to_insert_exec_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_insert_exec_catchpoint (%d) = %d\n",
		      pid, retval);

  return retval;
}

static int
debug_to_remove_exec_catchpoint (int pid)
{
  int retval;

  retval = debug_target.to_remove_exec_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_remove_exec_catchpoint (%d) = %d\n",
		      pid, retval);

  return retval;
}

static int
debug_to_reported_exec_events_per_exec_call (void)
{
  int reported_exec_events;

  reported_exec_events = debug_target.to_reported_exec_events_per_exec_call ();

  fprintf_unfiltered (gdb_stdlog,
		      "target_reported_exec_events_per_exec_call () = %d\n",
		      reported_exec_events);

  return reported_exec_events;
}

static int
debug_to_has_exited (int pid, int wait_status, int *exit_status)
{
  int has_exited;

  has_exited = debug_target.to_has_exited (pid, wait_status, exit_status);

  fprintf_unfiltered (gdb_stdlog, "target_has_exited (%d, %d, %d) = %d\n",
		      pid, wait_status, *exit_status, has_exited);

  return has_exited;
}

static void
debug_to_mourn_inferior (void)
{
  debug_target.to_mourn_inferior ();

  fprintf_unfiltered (gdb_stdlog, "target_mourn_inferior ()\n");
}

static int
debug_to_can_run (void)
{
  int retval;

  retval = debug_target.to_can_run ();

  fprintf_unfiltered (gdb_stdlog, "target_can_run () = %d\n", retval);

  return retval;
}

static void
debug_to_notice_signals (ptid_t ptid)
{
  debug_target.to_notice_signals (ptid);

  fprintf_unfiltered (gdb_stdlog, "target_notice_signals (%d)\n",
                      PIDGET (ptid));
}

static int
debug_to_thread_alive (ptid_t ptid)
{
  int retval;

  retval = debug_target.to_thread_alive (ptid);

  fprintf_unfiltered (gdb_stdlog, "target_thread_alive (%d) = %d\n",
		      PIDGET (ptid), retval);

  return retval;
}

static void
debug_to_find_new_threads (void)
{
  debug_target.to_find_new_threads ();

  fputs_unfiltered ("target_find_new_threads ()\n", gdb_stdlog);
}

static void
debug_to_stop (void)
{
  debug_target.to_stop ();

  fprintf_unfiltered (gdb_stdlog, "target_stop ()\n");
}

static void
debug_to_rcmd (char *command,
	       struct ui_file *outbuf)
{
  debug_target.to_rcmd (command, outbuf);
  fprintf_unfiltered (gdb_stdlog, "target_rcmd (%s, ...)\n", command);
}

static struct symtab_and_line *
debug_to_enable_exception_callback (enum exception_event_kind kind, int enable)
{
  struct symtab_and_line *result;
  result = debug_target.to_enable_exception_callback (kind, enable);
  fprintf_unfiltered (gdb_stdlog,
		      "target get_exception_callback_sal (%d, %d)\n",
		      kind, enable);
  return result;
}

static struct exception_event_record *
debug_to_get_current_exception_event (void)
{
  struct exception_event_record *result;
  result = debug_target.to_get_current_exception_event ();
  fprintf_unfiltered (gdb_stdlog, "target get_current_exception_event ()\n");
  return result;
}

static char *
debug_to_pid_to_exec_file (int pid)
{
  char *exec_file;

  exec_file = debug_target.to_pid_to_exec_file (pid);

  fprintf_unfiltered (gdb_stdlog, "target_pid_to_exec_file (%d) = %s\n",
		      pid, exec_file);

  return exec_file;
}

static void
setup_target_debug (void)
{
  memcpy (&debug_target, &current_target, sizeof debug_target);

  current_target.to_open = debug_to_open;
  current_target.to_close = debug_to_close;
  current_target.to_attach = debug_to_attach;
  current_target.to_post_attach = debug_to_post_attach;
  current_target.to_detach = debug_to_detach;
  current_target.to_disconnect = debug_to_disconnect;
  current_target.to_resume = debug_to_resume;
  current_target.to_wait = debug_to_wait;
  current_target.to_fetch_registers = debug_to_fetch_registers;
  current_target.to_store_registers = debug_to_store_registers;
  current_target.to_prepare_to_store = debug_to_prepare_to_store;
  current_target.deprecated_xfer_memory = deprecated_debug_xfer_memory;
  current_target.to_files_info = debug_to_files_info;
  current_target.to_insert_breakpoint = debug_to_insert_breakpoint;
  current_target.to_remove_breakpoint = debug_to_remove_breakpoint;
  current_target.to_can_use_hw_breakpoint = debug_to_can_use_hw_breakpoint;
  current_target.to_insert_hw_breakpoint = debug_to_insert_hw_breakpoint;
  current_target.to_remove_hw_breakpoint = debug_to_remove_hw_breakpoint;
  current_target.to_insert_watchpoint = debug_to_insert_watchpoint;
  current_target.to_remove_watchpoint = debug_to_remove_watchpoint;
  current_target.to_stopped_by_watchpoint = debug_to_stopped_by_watchpoint;
  current_target.to_stopped_data_address = debug_to_stopped_data_address;
  current_target.to_region_size_ok_for_hw_watchpoint = debug_to_region_size_ok_for_hw_watchpoint;
  current_target.to_terminal_init = debug_to_terminal_init;
  current_target.to_terminal_inferior = debug_to_terminal_inferior;
  current_target.to_terminal_ours_for_output = debug_to_terminal_ours_for_output;
  current_target.to_terminal_ours = debug_to_terminal_ours;
  current_target.to_terminal_save_ours = debug_to_terminal_save_ours;
  current_target.to_terminal_info = debug_to_terminal_info;
  current_target.to_kill = debug_to_kill;
  current_target.to_load = debug_to_load;
  current_target.to_lookup_symbol = debug_to_lookup_symbol;
  current_target.to_create_inferior = debug_to_create_inferior;
  current_target.to_post_startup_inferior = debug_to_post_startup_inferior;
  current_target.to_acknowledge_created_inferior = debug_to_acknowledge_created_inferior;
  current_target.to_insert_fork_catchpoint = debug_to_insert_fork_catchpoint;
  current_target.to_remove_fork_catchpoint = debug_to_remove_fork_catchpoint;
  current_target.to_insert_vfork_catchpoint = debug_to_insert_vfork_catchpoint;
  current_target.to_remove_vfork_catchpoint = debug_to_remove_vfork_catchpoint;
  current_target.to_follow_fork = debug_to_follow_fork;
  current_target.to_insert_exec_catchpoint = debug_to_insert_exec_catchpoint;
  current_target.to_remove_exec_catchpoint = debug_to_remove_exec_catchpoint;
  current_target.to_reported_exec_events_per_exec_call = debug_to_reported_exec_events_per_exec_call;
  current_target.to_has_exited = debug_to_has_exited;
  current_target.to_mourn_inferior = debug_to_mourn_inferior;
  current_target.to_can_run = debug_to_can_run;
  current_target.to_notice_signals = debug_to_notice_signals;
  current_target.to_thread_alive = debug_to_thread_alive;
  current_target.to_find_new_threads = debug_to_find_new_threads;
  current_target.to_stop = debug_to_stop;
  current_target.to_rcmd = debug_to_rcmd;
  current_target.to_enable_exception_callback = debug_to_enable_exception_callback;
  current_target.to_get_current_exception_event = debug_to_get_current_exception_event;
  current_target.to_pid_to_exec_file = debug_to_pid_to_exec_file;

}


static char targ_desc[] =
"Names of targets and files being debugged.\n\
Shows the entire stack of targets currently in use (including the exec-file,\n\
core-file, and process, if any), as well as the symbol file name.";

static void
do_monitor_command (char *cmd,
		 int from_tty)
{
  if ((current_target.to_rcmd
       == (void (*) (char *, struct ui_file *)) tcomplain)
      || (current_target.to_rcmd == debug_to_rcmd
	  && (debug_target.to_rcmd
	      == (void (*) (char *, struct ui_file *)) tcomplain)))
    {
      error ("\"monitor\" command not supported by this target.\n");
    }
  target_rcmd (cmd, gdb_stdtarg);
}

void
initialize_targets (void)
{
  init_dummy_target ();
  push_target (&dummy_target);

  add_info ("target", target_info, targ_desc);
  add_info ("files", target_info, targ_desc);

  deprecated_add_show_from_set 
    (add_set_cmd ("target", class_maintenance, var_zinteger,
		  (char *) &targetdebug,
		  "Set target debugging.\n\
When non-zero, target debugging is enabled.  Higher numbers are more\n\
verbose.  Changes do not take effect until the next \"run\" or \"target\"\n\
command.", &setdebuglist),
     &showdebuglist);

  add_setshow_boolean_cmd ("trust-readonly-sections", class_support, 
			   &trust_readonly, "\
Set mode for reading from readonly sections.", "\
Show mode for reading from readonly sections.", "\
When this mode is on, memory reads from readonly sections (such as .text)\n\
will be read from the object file instead of from the target.  This will\n\
result in significant performance improvement for remote targets.", "\
Mode for reading from readonly sections is %s.",
			   NULL, NULL,
			   &setlist, &showlist);

  add_com ("monitor", class_obscure, do_monitor_command,
	   "Send a command to the remote monitor (remote targets only).");

  target_dcache = dcache_init ();
}
@


1.4
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@a43 2
static void maybe_kill_then_create_inferior (char *, char *, char **);

d89 2
d111 3
a113 2
static int debug_to_xfer_memory (CORE_ADDR, char *, int, int,
				 struct mem_attrib *, struct target_ops *);
d133 1
a133 1
static CORE_ADDR debug_to_stopped_data_address (void);
a154 2
static void debug_to_create_inferior (char *, char *, char **);

d165 6
d347 2
a348 1
maybe_kill_then_create_inferior (char *exec, char *args, char **env)
d351 1
a351 1
  target_create_inferior (exec, args, env);
a390 1
      INHERIT (to_post_wait, t);
d394 1
a394 1
      INHERIT (to_xfer_memory, t);
a491 3
  de_fault (to_post_wait, 
	    (void (*) (ptid_t, int)) 
	    target_ignore);
d501 1
a501 1
  de_fault (to_xfer_memory, 
d530 1
a530 1
	    (CORE_ADDR (*) (void))
d787 1
a787 1
      errcode = target_xfer_memory (memaddr & ~3, buf, 4, 0);
d795 1
a795 1
	  errcode = target_xfer_memory (memaddr, buf, 1, 0);
d846 141
d1000 5
a1004 1
  return target_xfer_memory (memaddr, myaddr, len, 0);
d1010 19
a1028 1
  return target_xfer_memory (memaddr, myaddr, len, 1);
d1030 1
d1051 2
a1052 2
  /* to_xfer_memory is not guaranteed to set errno, even when it returns
     0.  */
d1069 1
a1069 1
  res = current_target.to_xfer_memory
d1080 1
a1080 1
	  res = t->to_xfer_memory (memaddr, myaddr, len, write, attrib, t);
d1235 5
a1239 1
  return target_xfer_memory_partial (memaddr, buf, len, 0, err);
d1245 5
a1249 1
  return target_xfer_memory_partial (memaddr, buf, len, 1, err);
d1260 3
a1262 3
      && ops->to_xfer_memory != NULL)
    /* If available, fall back to the target's "to_xfer_memory"
       method.  */
d1271 2
a1272 2
	  xfered = ops->to_xfer_memory (offset, buffer, len, 1/*write*/, NULL,
					ops);
d1276 2
a1277 2
	xfered = ops->to_xfer_memory (offset, readbuf, len, 0/*read*/, NULL,
				      ops);
d1281 2
a1282 2
	/* "to_xfer_memory" uses 0, cross checked against ERRNO as one
           indication of an error.  */
d1288 2
a1289 2
    return ops->beneath->to_xfer_partial (ops->beneath, object, annex,
					  readbuf, writebuf, offset, len);
d1306 1
a1306 2
  gdb_assert (ops->to_xfer_partial != NULL);
  return ops->to_xfer_partial (ops, object, annex, buf, NULL, offset, len);
d1315 1
a1315 2
  gdb_assert (ops->to_xfer_partial != NULL);
  return ops->to_xfer_partial (ops, object, annex, NULL, buf, offset, len);
a1393 5
#ifdef FILES_INFO_HOOK
  if (FILES_INFO_HOOK ())
    return;
#endif

a1437 4
  /* Handle any optimized stores to the inferior.  */
#ifdef DO_DEFERRED_STORES
  DO_DEFERRED_STORES;
#endif
a1443 4
  /* Handle any optimized stores to the inferior.  */
#ifdef DO_DEFERRED_STORES
  DO_DEFERRED_STORES;
#endif
d1510 2
a1511 1
find_default_create_inferior (char *exec_file, char *allargs, char **env)
d1516 1
a1516 1
  (t->to_create_inferior) (exec_file, allargs, env);
d1588 7
a1705 5
#ifdef CLEAR_DEFERRED_STORES
  /* Delete any pending stores to the inferior... */
  CLEAR_DEFERRED_STORES;
#endif

d1716 2
a1717 2
  if (detach_hook)
    detach_hook ();
a1798 3

static struct target_ops debug_target;

a1915 9
debug_to_post_wait (ptid_t ptid, int status)
{
  debug_target.to_post_wait (ptid, status);

  fprintf_unfiltered (gdb_stdlog, "target_post_wait (%d, %d)\n",
		      PIDGET (ptid), status);
}

static void
d1930 1
a1930 1
      for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i++)
d1934 1
a1934 1
      if (DEPRECATED_REGISTER_RAW_SIZE (regno) <= sizeof (LONGEST))
d1968 3
a1970 3
debug_to_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		      struct mem_attrib *attrib,
		      struct target_ops *target)
d1974 2
a1975 2
  retval = debug_target.to_xfer_memory (memaddr, myaddr, len, write,
					attrib, target);
a1981 2


d1990 9
a1998 1
	    fprintf_unfiltered (gdb_stdlog, "\n");
d2087 2
a2088 2
static CORE_ADDR
debug_to_stopped_data_address (void)
d2090 1
a2090 1
  CORE_ADDR retval;
d2092 1
a2092 1
  retval = debug_target.to_stopped_data_address ();
d2095 3
a2097 2
		      "target_stopped_data_address () = 0x%lx\n",
		      (unsigned long) retval);
d2233 2
a2234 1
debug_to_create_inferior (char *exec_file, char *args, char **env)
d2236 1
a2236 1
  debug_target.to_create_inferior (exec_file, args, env);
d2238 2
a2239 2
  fprintf_unfiltered (gdb_stdlog, "target_create_inferior (%s, %s, xxx)\n",
		      exec_file, args);
a2433 19
static LONGEST
debug_to_xfer_partial (struct target_ops *ops, enum target_object object,
		       const char *annex, void *readbuf, const void *writebuf,
		       ULONGEST offset, LONGEST len)
{
  LONGEST retval;

  retval = debug_target.to_xfer_partial (&debug_target, object, annex,
					 readbuf, writebuf, offset, len);

  fprintf_unfiltered (gdb_stdlog,
		      "target_xfer_partial (%d, %s, 0x%lx,  0x%lx,  0x%s, %s) = %s\n",
		      (int) object, (annex ? annex : "(null)"),
		      (long) readbuf, (long) writebuf, paddr_nz (offset),
		      paddr_d (len), paddr_d (retval));

  return retval;
}

a2487 1
  current_target.to_post_wait = debug_to_post_wait;
d2491 1
a2491 1
  current_target.to_xfer_memory = debug_to_xfer_memory;
a2529 1
  current_target.to_xfer_partial = debug_to_xfer_partial;
d2567 1
a2567 1
  add_show_from_set 
d2571 3
a2573 1
When non-zero, target debugging is enabled.", &setdebuglist),
d2578 2
a2579 1
Set mode for reading from readonly sections.\n\
d2583 1
a2583 1
Show mode for reading from readonly sections.\n",
@


1.3
log
@Teach gdb about the existence of SIGINFO. Fixes PR 3173.

"Works for me" todd@@ ok mickey@@ fgsch@@
@
text
@d2 4
a5 1
   Copyright 1990, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
d8 1
a8 1
This file is part of GDB.
d10 14
a23 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a26 1
#include <ctype.h>
d35 2
a36 1
#include "wait.h"
d38 31
d70 1
a70 1
extern int errno;
d72 7
a78 2
static void
target_info PARAMS ((char *, int));
d80 5
a84 2
static void
cleanup_target PARAMS ((struct target_ops *));
d86 2
a87 2
static void
maybe_kill_then_create_inferior PARAMS ((char *, char *, char **));
d89 1
a89 2
static void
maybe_kill_then_attach PARAMS ((char *, int));
d91 1
a91 2
static void
kill_or_be_killed PARAMS ((int));
d93 1
a93 2
static void
default_terminal_info PARAMS ((char *, int));
d95 1
a95 2
static int
nosymbol PARAMS ((char *, CORE_ADDR *));
d97 1
a97 2
static void
tcomplain PARAMS ((void));
d99 1
a99 2
static int
nomemory PARAMS ((CORE_ADDR, char *, int, int, struct target_ops *));
d101 1
a101 2
static int
return_zero PARAMS ((void));
d103 1
a103 2
static void
ignore PARAMS ((void));
d105 1
a105 2
static void
target_command PARAMS ((char *, int));
d107 1
a107 2
static struct target_ops *
find_default_run_target PARAMS ((char *));
d109 1
a109 2
static void
update_current_target PARAMS ((void));
d111 2
a112 2
static void
debug_to_open PARAMS ((char *, int));
d114 1
a114 2
static void
debug_to_close PARAMS ((int));
d116 1
a116 2
static void
debug_to_attach PARAMS ((char *, int));
d118 1
a118 2
static void
debug_to_detach PARAMS ((char *, int));
d120 1
a120 2
static void
debug_to_resume PARAMS ((int, int, enum target_signal));
d122 1
a122 2
static int
debug_to_wait PARAMS ((int, struct target_waitstatus *));
d124 1
a124 2
static void
debug_to_fetch_registers PARAMS ((int));
d126 1
a126 2
static void
debug_to_store_registers PARAMS ((int));
d128 1
a128 2
static void
debug_to_prepare_to_store PARAMS ((void));
d130 1
a130 2
static int
debug_to_xfer_memory PARAMS ((CORE_ADDR, char *, int, int, struct target_ops *));
d132 1
a132 2
static void
debug_to_files_info PARAMS ((struct target_ops *));
d134 1
a134 2
static int
debug_to_insert_breakpoint PARAMS ((CORE_ADDR, char *));
d136 1
a136 2
static int
debug_to_remove_breakpoint PARAMS ((CORE_ADDR, char *));
d138 1
a138 2
static void
debug_to_terminal_init PARAMS ((void));
d140 1
a140 2
static void
debug_to_terminal_inferior PARAMS ((void));
d142 1
a142 2
static void
debug_to_terminal_ours_for_output PARAMS ((void));
d144 1
a144 2
static void
debug_to_terminal_ours PARAMS ((void));
d146 1
a146 2
static void
debug_to_terminal_info PARAMS ((char *, int));
d148 1
a148 2
static void
debug_to_kill PARAMS ((void));
d150 1
a150 2
static void
debug_to_load PARAMS ((char *, int));
d152 1
a152 2
static int
debug_to_lookup_symbol PARAMS ((char *, CORE_ADDR *));
d154 1
a154 2
static void
debug_to_create_inferior PARAMS ((char *, char *, char **));
d156 1
a156 2
static void
debug_to_mourn_inferior PARAMS ((void));
d158 1
a158 2
static int
debug_to_can_run PARAMS ((void));
d160 1
a160 2
static void
debug_to_notice_signals PARAMS ((int));
d162 1
a162 2
static int
debug_to_thread_alive PARAMS ((int));
d164 1
a164 2
static void
debug_to_stop PARAMS ((void));
d178 1
a178 42
struct target_ops dummy_target = {
  "None",			/* to_shortname */
  "None",			/* to_longname */
  "",				/* to_doc */
  0,				/* to_open */
  0,				/* to_close */
  find_default_attach,		/* to_attach */
  0,				/* to_detach */
  0,				/* to_resume */
  0,				/* to_wait */
  0,				/* to_fetch_registers */
  0,				/* to_store_registers */
  0,				/* to_prepare_to_store */
  0,				/* to_xfer_memory */
  0,				/* to_files_info */
  0,				/* to_insert_breakpoint */
  0,				/* to_remove_breakpoint */
  0,				/* to_terminal_init */
  0,				/* to_terminal_inferior */
  0,				/* to_terminal_ours_for_output */
  0,				/* to_terminal_ours */
  0,				/* to_terminal_info */
  0,				/* to_kill */
  0,				/* to_load */
  0,				/* to_lookup_symbol */
  find_default_create_inferior,	/* to_create_inferior */
  0,				/* to_mourn_inferior */
  0,				/* to_can_run */
  0,				/* to_notice_signals */
  0,				/* to_thread_alive */
  0,				/* to_stop */
  dummy_stratum,		/* to_stratum */
  0,				/* to_next */
  0,				/* to_next */
  0,				/* to_has_all_memory */
  0,				/* to_has_memory */
  0,				/* to_has_registers */
  0,				/* to_has_execution */
  0,				/* to_sections */
  0,				/* to_sections_end */
  OPS_MAGIC,			/* to_magic */
};
d182 1
a182 1
struct target_stack_item *target_stack;
a197 1
#ifdef MAINTENANCE_CMDS
d202 1
a202 1
static void setup_target_debug PARAMS ((void));
d204 1
a204 1
#endif
a207 1
/* ARGSUSED */
d209 1
a209 3
target_command (arg, from_tty)
     char *arg;
     int from_tty;
d218 1
a218 2
add_target (t)
     struct target_ops *t;
d220 4
d234 2
a235 2
	  xrealloc ((char *) target_structs, 
		    target_struct_allocsize * sizeof (*target_structs));
a237 1
/*  cleanup_target (t);*/
d252 7
a258 2
static void
ignore ()
d260 2
a263 1
/* ARGSUSED */
d265 2
a266 6
nomemory (memaddr, myaddr, len, write, t)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
     struct target_ops *t;
d268 2
a269 2
  errno = EIO;		/* Can't read/write this location */
  return 0;		/* No bytes handled */
d273 1
a273 1
tcomplain ()
d280 1
a280 1
noprocess ()
d282 1
a282 1
  error ("You can't do that without a process to debug");
a284 1
/* ARGSUSED */
d286 7
a292 3
nosymbol (name, addrp)
     char *name;
     CORE_ADDR *addrp;
d294 4
a297 1
  return 1;		/* Symbol does not exist in target env */
d300 1
a300 1
/* ARGSUSED */
d302 1
a302 3
default_terminal_info (args, from_tty)
     char *args;
     int from_tty;
d304 1
a304 1
  printf_unfiltered("No saved terminal information.\n");
d313 1
a313 2
kill_or_be_killed (from_tty)
     int from_tty;
d319 11
a329 8
      if (query ("Kill it? ")) {
	target_kill ();
	if (target_has_execution)
	  error ("Killing the program did not help.");
	return;
      } else {
	error ("Program not killed.");
      }
d331 1
a331 1
  tcomplain();
d335 1
a335 3
maybe_kill_then_attach (args, from_tty)
     char *args;
     int from_tty;
d342 1
a342 4
maybe_kill_then_create_inferior (exec, args, env)
     char *exec;
     char *args;
     char **env;
d348 11
a358 47
/* Clean up a target struct so it no longer has any zero pointers in it.
   We default entries, at least to stubs that print error messages.  */

static void
cleanup_target (t)
     struct target_ops *t;
{

#define de_fault(field, value) \
  if (!t->field)	t->field = value

  /*        FIELD			DEFAULT VALUE        */

  de_fault (to_open, 			(void (*) PARAMS((char *, int))) tcomplain);
  de_fault (to_close, 			(void (*) PARAMS((int))) ignore);
  de_fault (to_attach, 			maybe_kill_then_attach);
  de_fault (to_detach, 			(void (*) PARAMS((char *, int))) ignore);
  de_fault (to_resume, 			(void (*) PARAMS((int, int, enum target_signal))) noprocess);
  de_fault (to_wait, 			(int (*) PARAMS((int, struct target_waitstatus *))) noprocess);
  de_fault (to_fetch_registers, 	(void (*) PARAMS((int))) ignore);
  de_fault (to_store_registers,		(void (*) PARAMS((int))) noprocess);
  de_fault (to_prepare_to_store,	(void (*) PARAMS((void))) noprocess);
  de_fault (to_xfer_memory,		(int (*) PARAMS((CORE_ADDR, char *, int, int, struct target_ops *))) nomemory);
  de_fault (to_files_info,		(void (*) PARAMS((struct target_ops *))) ignore);
  de_fault (to_insert_breakpoint,	memory_insert_breakpoint);
  de_fault (to_remove_breakpoint,	memory_remove_breakpoint);
  de_fault (to_terminal_init,		(void (*) PARAMS((void))) ignore);
  de_fault (to_terminal_inferior,	(void (*) PARAMS ((void))) ignore);
  de_fault (to_terminal_ours_for_output,(void (*) PARAMS ((void))) ignore);
  de_fault (to_terminal_ours,		(void (*) PARAMS ((void))) ignore);
  de_fault (to_terminal_info,		default_terminal_info);
  de_fault (to_kill,			(void (*) PARAMS((void))) noprocess);
  de_fault (to_load,			(void (*) PARAMS((char *, int))) tcomplain);
  de_fault (to_lookup_symbol,		(int (*) PARAMS ((char *, CORE_ADDR *))) nosymbol);
  de_fault (to_create_inferior,		maybe_kill_then_create_inferior);
  de_fault (to_mourn_inferior,		(void (*) PARAMS((void))) noprocess);
  de_fault (to_can_run,			return_zero);
  de_fault (to_notice_signals,		(void (*) PARAMS((int))) ignore);
  de_fault (to_thread_alive,		(int (*) PARAMS((int))) ignore);
  de_fault (to_stop,			(void (*) PARAMS((void))) ignore);

#undef de_fault
}

/* Go through the target stack from top to bottom, copying over zero entries in
   current_target.  In effect, we are doing class inheritance through the
   pushed target vectors.  */
d361 1
a361 1
update_current_target ()
a362 1
  struct target_stack_item *item;
d365 2
a366 6
  /* First, reset current_target */
  memset (&current_target, 0, sizeof current_target);

  for (item = target_stack; item; item = item->next)
    {
      t = item->target_ops;
d370 1
a370 1
	current_target.FIELD = TARGET->FIELD
d372 2
d380 1
d382 1
d385 1
d393 9
d406 1
d412 11
d427 3
d431 5
a436 1
      INHERIT (DONT_USE, t);
d442 1
d445 7
d453 6
d460 181
a640 2
#undef INHERIT
    }
d654 1
a654 2
push_target (t)
     struct target_ops *t;
d656 1
a656 1
  struct target_stack_item *cur, *prev, *tmp;
d662 4
a665 4
      fprintf_unfiltered(gdb_stderr,
			 "Magic number of %s target struct wrong\n", 
			 t->to_shortname);
      abort();
d668 2
a669 3
  /* Find the proper stratum to install this target in. */

  for (prev = NULL, cur = target_stack; cur; prev = cur, cur = cur->next)
d671 1
a671 1
      if ((int)(t->to_stratum) >= (int)(cur->target_ops->to_stratum))
d675 12
a686 16
  /* If there's already targets at this stratum, remove them. */

  if (cur)
    while (t->to_stratum == cur->target_ops->to_stratum)
      {
	/* There's already something on this stratum.  Close it off.  */
	if (cur->target_ops->to_close)
	  (cur->target_ops->to_close) (0);
	if (prev)
	  prev->next = cur->next; /* Unchain old target_ops */
	else
	  target_stack = cur->next; /* Unchain first on list */
	tmp = cur->next;
	free (cur);
	cur = tmp;
      }
d689 2
a690 10

  tmp = (struct target_stack_item *)
    xmalloc (sizeof (struct target_stack_item));
  tmp->next = cur;
  tmp->target_ops = t;

  if (prev)
    prev->next = tmp;
  else
    target_stack = tmp;
a693 3
  cleanup_target (&current_target); /* Fill in the gaps */

#ifdef MAINTENANCE_CMDS
a695 1
#endif
d697 2
a698 1
  return prev != 0;
d705 1
a705 2
unpush_target (t)
     struct target_ops *t;
d707 2
a708 4
  struct target_stack_item *cur, *prev;

  if (t->to_close)
    t->to_close (0);		/* Let it clean up */
d713 5
a717 3
  for (cur = target_stack, prev = NULL; cur; prev = cur, cur = cur->next)
    if (cur->target_ops == t)
      break;
d719 1
a719 1
  if (!cur)
d722 8
d731 3
a733 7

  if (!prev)
    target_stack = cur->next;
  else
    prev->next = cur->next;

  free (cur);			/* Release the target_stack_item */
a735 1
  cleanup_target (&current_target);
d741 1
a741 1
pop_target ()
d743 2
a744 2
  (current_target.to_close)(0);	/* Let it clean up */
  if (unpush_target (target_stack->target_ops) == 1)
d747 4
a750 4
  fprintf_unfiltered(gdb_stderr,
		     "pop_target couldn't find target %s\n", 
		     current_target.to_shortname);
  abort();
d763 1
a763 5
target_read_string (memaddr, string, len, errnop)
     CORE_ADDR memaddr;
     char **string;
     int len;
     int *errnop;
d787 10
a796 1
	goto done;
d821 1
a821 1
 done:
d829 15
d855 1
a855 4
target_read_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
a859 42
/* Read LEN bytes of target memory at address MEMADDR, placing the results
   in GDB's memory at MYADDR.  Returns a count of the bytes actually read,
   and optionally an errno value in the location pointed to by ERRNOPTR
   if ERRNOPTR is non-null. */

int
target_read_memory_partial (memaddr, myaddr, len, errnoptr)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int *errnoptr;
{
  int nread;	/* Number of bytes actually read. */
  int errcode;	/* Error from last read. */

  /* First try a complete read. */
  errcode = target_xfer_memory (memaddr, myaddr, len, 0);
  if (errcode == 0)
    {
      /* Got it all. */
      nread = len;
    }
  else
    {
      /* Loop, reading one byte at a time until we get as much as we can. */
      for (errcode = 0, nread = 0; len > 0 && errcode == 0; nread++, len--)
	{
	  errcode = target_xfer_memory (memaddr++, myaddr++, 1, 0);
	}
      /* If an error, the last read was unsuccessful, so adjust count. */
      if (errcode != 0)
	{
	  nread--;
	}
    }
  if (errnoptr != NULL)
    {
      *errnoptr = errcode;
    }
  return (nread);
}

d861 1
a861 4
target_write_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
a864 8
 
/* Move memory to or from the targets.  Iterate until all of it has
   been moved, if necessary.  The top target gets priority; anything
   it doesn't want, is offered to the next one down, etc.  Note the
   business with curlen:  if an early target says "no, but I have a
   boundary overlapping this xfer" then we shorten what we offer to
   the subsequent targets so the early guy will get a chance at the
   tail before the subsequent ones do. 
d866 6
a871 1
   Result is 0 or errno value.  */
d874 2
a875 5
target_xfer_memory (memaddr, myaddr, len, write)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
a876 1
  int curlen;
d878 1
d880 4
a883 1
  struct target_stack_item *item;
d889 14
a902 1
  /* The quick case is that the top target does it all.  */
d904 1
a904 3
			(memaddr, myaddr, len, write, &current_target);
  if (res == len)
    return 0;
d906 2
a907 5
  if (res > 0)
    goto bump;
  /* If res <= 0 then we call it again in the loop.  Ah well.  */

  for (; len > 0;)
d909 1
a909 2
      curlen = len;		/* Want to do it all */
      for (item = target_stack; item; item = item->next)
a910 1
	  t = item->target_ops;
d914 1
a914 1
	  res = t->to_xfer_memory (memaddr, myaddr, curlen, write, t);
d922 34
d957 6
a962 2
	  /* If this address is for nonexistent memory,
	     read zeros if reading, or do nothing if writing.  Return error. */
a963 2
	    memset (myaddr, 0, len);
	  if (errno == 0)
d965 8
d974 20
a993 1
	    return errno;
a994 4
bump:
      memaddr += res;
      myaddr  += res;
      len     -= res;
d996 1
d1001 7
a1007 5
/* ARGSUSED */
static void
target_info (args, from_tty)
     char *args;
     int from_tty;
d1009 10
a1018 6
  struct target_ops *t;
  struct target_stack_item *item;
  int has_all_mem = 0;
  
  if (symfile_objfile != NULL)
    printf_unfiltered ("Symbols from \"%s\".\n", symfile_objfile->name);
d1020 5
a1024 4
#ifdef FILES_INFO_HOOK
  if (FILES_INFO_HOOK ())
    return;
#endif
d1026 1
a1026 1
  for (item = target_stack; item; item = item->next)
d1028 16
a1043 1
      t = item->target_ops;
d1045 13
a1057 2
      if (!t->to_has_memory)
	continue;
d1059 1
a1059 7
      if ((int)(t->to_stratum) <= (int)dummy_stratum)
	continue;
      if (has_all_mem)
	printf_unfiltered("\tWhile running this, GDB does not access memory from...\n");
      printf_unfiltered("%s:\n", t->to_longname);
      (t->to_files_info)(t);
      has_all_mem = t->to_has_all_memory;
d1061 3
d1066 5
a1070 2
/* This is to be called by the open routine before it does
   anything.  */
d1072 2
a1073 3
void
target_preopen (from_tty)
     int from_tty;
d1075 4
a1078 1
  dont_repeat();
d1080 30
a1109 4
  if (target_has_execution)
    {   
      if (query ("A program is being debugged already.  Kill it? "))
        target_kill ();
d1111 1
a1111 1
        error ("Program not killed.");
d1113 8
d1122 3
a1124 2
  /* Calling target_kill may remove the target from the stack.  But if
     it doesn't (which seems like a win for UDI), remove it now.  */
d1126 8
a1133 2
  if (target_has_execution)
    pop_target ();
d1136 9
a1144 1
/* Detach a target after doing deferred register stores.  */
d1146 6
a1151 4
void
target_detach (args, from_tty)
     char *args;
     int from_tty;
d1153 14
a1166 5
  /* Handle any optimized stores to the inferior.  */
#ifdef DO_DEFERRED_STORES
  DO_DEFERRED_STORES;
#endif
  (current_target.to_detach) (args, from_tty);
d1169 5
a1173 4
void
target_link (modname, t_reloc)
     char *modname;
     CORE_ADDR *t_reloc;
d1175 2
a1176 1
  if (STREQ(current_target.to_shortname, "rombug"))
d1178 9
a1186 3
      (current_target.to_lookup_symbol) (modname, t_reloc);
      if (*t_reloc == 0)
      error("Unable to link to %s and get relocation in rombug", modname);
d1188 1
a1188 2
  else
    *t_reloc = (CORE_ADDR)-1;
d1191 121
a1311 3
/* Look through the list of possible targets for a target that can
   execute a run or attach command without any other data.  This is
   used to locate the default process stratum.
d1316 1
a1316 2
find_default_run_target (do_mesg)
     char *do_mesg;
d1327 1
a1327 1
      if ((*t)->to_can_run && target_can_run(*t))
d1341 1
a1341 3
find_default_attach (args, from_tty)
     char *args;
     int from_tty;
d1345 1
a1345 1
  t = find_default_run_target("attach");
d1351 1
a1351 4
find_default_create_inferior (exec_file, allargs, env)
     char *exec_file;
     char *allargs;
     char **env;
d1355 1
a1355 1
  t = find_default_run_target("run");
d1361 7
a1367 1
return_zero ()
d1372 122
d1495 1
a1495 1
find_core_target ()
d1500 1
a1500 1
  
d1502 1
a1502 1
  
d1512 12
a1523 2
  
  return(count == 1 ? runable : NULL);
d1525 1
d1530 1
a1530 1
generic_mourn_inferior ()
d1534 1
a1534 1
  inferior_pid = 0;
d1536 1
a1536 1
  breakpoint_init_inferior ();
a1552 495
}

/* This table must match in order and size the signals in enum target_signal
   in target.h.  */
static struct {
  char *name;
  char *string;
  } signals [] =
{
  {"0", "Signal 0"},
  {"SIGHUP", "Hangup"},
  {"SIGINT", "Interrupt"},
  {"SIGQUIT", "Quit"},
  {"SIGILL", "Illegal instruction"},
  {"SIGTRAP", "Trace/breakpoint trap"},
  {"SIGABRT", "Aborted"},
  {"SIGEMT", "Emulation trap"},
  {"SIGFPE", "Arithmetic exception"},
  {"SIGKILL", "Killed"},
  {"SIGBUS", "Bus error"},
  {"SIGSEGV", "Segmentation fault"},
  {"SIGSYS", "Bad system call"},
  {"SIGPIPE", "Broken pipe"},
  {"SIGALRM", "Alarm clock"},
  {"SIGTERM", "Terminated"},
  {"SIGURG", "Urgent I/O condition"},
  {"SIGSTOP", "Stopped (signal)"},
  {"SIGTSTP", "Stopped (user)"},
  {"SIGCONT", "Continued"},
  {"SIGCHLD", "Child status changed"},
  {"SIGTTIN", "Stopped (tty input)"},
  {"SIGTTOU", "Stopped (tty output)"},
  {"SIGIO", "I/O possible"},
  {"SIGXCPU", "CPU time limit exceeded"},
  {"SIGXFSZ", "File size limit exceeded"},
  {"SIGVTALRM", "Virtual timer expired"},
  {"SIGPROF", "Profiling timer expired"},
  {"SIGWINCH", "Window size changed"},
#if defined(SIGINFO)
  {"SIGINFO", "Information request"},
#else
  {"SIGLOST", "Resource lost"},
#endif
  {"SIGUSR1", "User defined signal 1"},
  {"SIGUSR2", "User defined signal 2"},
  {"SIGPWR", "Power fail/restart"},
  {"SIGPOLL", "Pollable event occurred"},
  {"SIGWIND", "SIGWIND"},
  {"SIGPHONE", "SIGPHONE"},
  {"SIGWAITING", "Process's LWPs are blocked"},
  {"SIGLWP", "Signal LWP"},
  {"SIGDANGER", "Swap space dangerously low"},
  {"SIGGRANT", "Monitor mode granted"},
  {"SIGRETRACT", "Need to relinguish monitor mode"},
  {"SIGMSG", "Monitor mode data available"},
  {"SIGSOUND", "Sound completed"},
  {"SIGSAK", "Secure attention"},
  {"SIGPRIO", "SIGPRIO"},
  {"SIG33", "Real-time event 33"},
  {"SIG34", "Real-time event 34"},
  {"SIG35", "Real-time event 35"},
  {"SIG36", "Real-time event 36"},
  {"SIG37", "Real-time event 37"},
  {"SIG38", "Real-time event 38"},
  {"SIG39", "Real-time event 39"},
  {"SIG40", "Real-time event 40"},
  {"SIG41", "Real-time event 41"},
  {"SIG42", "Real-time event 42"},
  {"SIG43", "Real-time event 43"},
  {"SIG44", "Real-time event 44"},
  {"SIG45", "Real-time event 45"},
  {"SIG46", "Real-time event 46"},
  {"SIG47", "Real-time event 47"},
  {"SIG48", "Real-time event 48"},
  {"SIG49", "Real-time event 49"},
  {"SIG50", "Real-time event 50"},
  {"SIG51", "Real-time event 51"},
  {"SIG52", "Real-time event 52"},
  {"SIG53", "Real-time event 53"},
  {"SIG54", "Real-time event 54"},
  {"SIG55", "Real-time event 55"},
  {"SIG56", "Real-time event 56"},
  {"SIG57", "Real-time event 57"},
  {"SIG58", "Real-time event 58"},
  {"SIG59", "Real-time event 59"},
  {"SIG60", "Real-time event 60"},
  {"SIG61", "Real-time event 61"},
  {"SIG62", "Real-time event 62"},
  {"SIG63", "Real-time event 63"},

  /* Mach exceptions */
  {"EXC_BAD_ACCESS", "Could not access memory"},
  {"EXC_BAD_INSTRUCTION", "Illegal instruction/operand"},
  {"EXC_ARITHMETIC", "Arithmetic exception"},
  {"EXC_EMULATION", "Emulation instruction"},
  {"EXC_SOFTWARE", "Software generated exception"},
  {"EXC_BREAKPOINT", "Breakpoint"},

  {NULL, "Unknown signal"},
  {NULL, "Internal error: printing TARGET_SIGNAL_DEFAULT"},

  /* Last entry, used to check whether the table is the right size.  */
  {NULL, "TARGET_SIGNAL_MAGIC"}
};

/* Return the string for a signal.  */
char *
target_signal_to_string (sig)
     enum target_signal sig;
{
  return signals[sig].string;
}

/* Return the name for a signal.  */
char *
target_signal_to_name (sig)
     enum target_signal sig;
{
  if (sig == TARGET_SIGNAL_UNKNOWN)
    /* I think the code which prints this will always print it along with
       the string, so no need to be verbose.  */
    return "?";
  return signals[sig].name;
}

/* Given a name, return its signal.  */
enum target_signal
target_signal_from_name (name)
     char *name;
{
  enum target_signal sig;

  /* It's possible we also should allow "SIGCLD" as well as "SIGCHLD"
     for TARGET_SIGNAL_SIGCHLD.  SIGIOT, on the other hand, is more
     questionable; seems like by now people should call it SIGABRT
     instead.  */

  /* This ugly cast brought to you by the native VAX compiler.  */
  for (sig = TARGET_SIGNAL_HUP;
       signals[sig].name != NULL;
       sig = (enum target_signal)((int)sig + 1))
    if (STREQ (name, signals[sig].name))
      return sig;
  return TARGET_SIGNAL_UNKNOWN;
}

/* The following functions are to help certain targets deal
   with the signal/waitstatus stuff.  They could just as well be in
   a file called native-utils.c or unixwaitstatus-utils.c or whatever.  */

/* Convert host signal to our signals.  */
enum target_signal
target_signal_from_host (hostsig)
     int hostsig;
{
  /* A switch statement would make sense but would require special kludges
     to deal with the cases where more than one signal has the same number.  */

  if (hostsig == 0) return TARGET_SIGNAL_0;

#if defined (SIGHUP)
  if (hostsig == SIGHUP) return TARGET_SIGNAL_HUP;
#endif
#if defined (SIGINT)
  if (hostsig == SIGINT) return TARGET_SIGNAL_INT;
#endif
#if defined (SIGQUIT)
  if (hostsig == SIGQUIT) return TARGET_SIGNAL_QUIT;
#endif
#if defined (SIGILL)
  if (hostsig == SIGILL) return TARGET_SIGNAL_ILL;
#endif
#if defined (SIGTRAP)
  if (hostsig == SIGTRAP) return TARGET_SIGNAL_TRAP;
#endif
#if defined (SIGABRT)
  if (hostsig == SIGABRT) return TARGET_SIGNAL_ABRT;
#endif
#if defined (SIGEMT)
  if (hostsig == SIGEMT) return TARGET_SIGNAL_EMT;
#endif
#if defined (SIGFPE)
  if (hostsig == SIGFPE) return TARGET_SIGNAL_FPE;
#endif
#if defined (SIGKILL)
  if (hostsig == SIGKILL) return TARGET_SIGNAL_KILL;
#endif
#if defined (SIGBUS)
  if (hostsig == SIGBUS) return TARGET_SIGNAL_BUS;
#endif
#if defined (SIGSEGV)
  if (hostsig == SIGSEGV) return TARGET_SIGNAL_SEGV;
#endif
#if defined (SIGSYS)
  if (hostsig == SIGSYS) return TARGET_SIGNAL_SYS;
#endif
#if defined (SIGPIPE)
  if (hostsig == SIGPIPE) return TARGET_SIGNAL_PIPE;
#endif
#if defined (SIGALRM)
  if (hostsig == SIGALRM) return TARGET_SIGNAL_ALRM;
#endif
#if defined (SIGTERM)
  if (hostsig == SIGTERM) return TARGET_SIGNAL_TERM;
#endif
#if defined (SIGUSR1)
  if (hostsig == SIGUSR1) return TARGET_SIGNAL_USR1;
#endif
#if defined (SIGUSR2)
  if (hostsig == SIGUSR2) return TARGET_SIGNAL_USR2;
#endif
#if defined (SIGCLD)
  if (hostsig == SIGCLD) return TARGET_SIGNAL_CHLD;
#endif
#if defined (SIGCHLD)
  if (hostsig == SIGCHLD) return TARGET_SIGNAL_CHLD;
#endif
#if defined (SIGPWR)
  if (hostsig == SIGPWR) return TARGET_SIGNAL_PWR;
#endif
#if defined (SIGWINCH)
  if (hostsig == SIGWINCH) return TARGET_SIGNAL_WINCH;
#endif
#if defined (SIGINFO)
  if (hostsig == SIGINFO) return TARGET_SIGNAL_INFO;
#endif
#if defined (SIGURG)
  if (hostsig == SIGURG) return TARGET_SIGNAL_URG;
#endif
#if defined (SIGIO)
  if (hostsig == SIGIO) return TARGET_SIGNAL_IO;
#endif
#if defined (SIGPOLL)
  if (hostsig == SIGPOLL) return TARGET_SIGNAL_POLL;
#endif
#if defined (SIGSTOP)
  if (hostsig == SIGSTOP) return TARGET_SIGNAL_STOP;
#endif
#if defined (SIGTSTP)
  if (hostsig == SIGTSTP) return TARGET_SIGNAL_TSTP;
#endif
#if defined (SIGCONT)
  if (hostsig == SIGCONT) return TARGET_SIGNAL_CONT;
#endif
#if defined (SIGTTIN)
  if (hostsig == SIGTTIN) return TARGET_SIGNAL_TTIN;
#endif
#if defined (SIGTTOU)
  if (hostsig == SIGTTOU) return TARGET_SIGNAL_TTOU;
#endif
#if defined (SIGVTALRM)
  if (hostsig == SIGVTALRM) return TARGET_SIGNAL_VTALRM;
#endif
#if defined (SIGPROF)
  if (hostsig == SIGPROF) return TARGET_SIGNAL_PROF;
#endif
#if defined (SIGXCPU)
  if (hostsig == SIGXCPU) return TARGET_SIGNAL_XCPU;
#endif
#if defined (SIGXFSZ)
  if (hostsig == SIGXFSZ) return TARGET_SIGNAL_XFSZ;
#endif
#if defined (SIGWIND)
  if (hostsig == SIGWIND) return TARGET_SIGNAL_WIND;
#endif
#if defined (SIGPHONE)
  if (hostsig == SIGPHONE) return TARGET_SIGNAL_PHONE;
#endif
#if defined (SIGLOST)
  if (hostsig == SIGLOST) return TARGET_SIGNAL_LOST;
#endif
#if defined (SIGWAITING)
  if (hostsig == SIGWAITING) return TARGET_SIGNAL_WAITING;
#endif
#if defined (SIGLWP)
  if (hostsig == SIGLWP) return TARGET_SIGNAL_LWP;
#endif
#if defined (SIGDANGER)
  if (hostsig == SIGDANGER) return TARGET_SIGNAL_DANGER;
#endif
#if defined (SIGGRANT)
  if (hostsig == SIGGRANT) return TARGET_SIGNAL_GRANT;
#endif
#if defined (SIGRETRACT)
  if (hostsig == SIGRETRACT) return TARGET_SIGNAL_RETRACT;
#endif
#if defined (SIGMSG)
  if (hostsig == SIGMSG) return TARGET_SIGNAL_MSG;
#endif
#if defined (SIGSOUND)
  if (hostsig == SIGSOUND) return TARGET_SIGNAL_SOUND;
#endif
#if defined (SIGSAK)
  if (hostsig == SIGSAK) return TARGET_SIGNAL_SAK;
#endif
#if defined (SIGPRIO)
  if (hostsig == SIGPRIO) return TARGET_SIGNAL_PRIO;
#endif

  /* Mach exceptions.  Assumes that the values for EXC_ are positive! */
#if defined (EXC_BAD_ACCESS) && defined (_NSIG)
  if (hostsig == _NSIG + EXC_BAD_ACCESS) return TARGET_EXC_BAD_ACCESS;
#endif
#if defined (EXC_BAD_INSTRUCTION) && defined (_NSIG)
  if (hostsig == _NSIG + EXC_BAD_INSTRUCTION) return TARGET_EXC_BAD_INSTRUCTION;
#endif
#if defined (EXC_ARITHMETIC) && defined (_NSIG)
  if (hostsig == _NSIG + EXC_ARITHMETIC) return TARGET_EXC_ARITHMETIC;
#endif
#if defined (EXC_EMULATION) && defined (_NSIG)
  if (hostsig == _NSIG + EXC_EMULATION) return TARGET_EXC_EMULATION;
#endif
#if defined (EXC_SOFTWARE) && defined (_NSIG)
  if (hostsig == _NSIG + EXC_SOFTWARE) return TARGET_EXC_SOFTWARE;
#endif
#if defined (EXC_BREAKPOINT) && defined (_NSIG)
  if (hostsig == _NSIG + EXC_BREAKPOINT) return TARGET_EXC_BREAKPOINT;
#endif

#if defined (REALTIME_LO)
  if (hostsig >= REALTIME_LO && hostsig < REALTIME_HI)
    return (enum target_signal)
      (hostsig - 33 + (int) TARGET_SIGNAL_REALTIME_33);
#endif
  return TARGET_SIGNAL_UNKNOWN;
}

int
target_signal_to_host (oursig)
     enum target_signal oursig;
{
  switch (oursig)
    {
    case TARGET_SIGNAL_0: return 0;

#if defined (SIGHUP)
    case TARGET_SIGNAL_HUP: return SIGHUP;
#endif
#if defined (SIGINT)
    case TARGET_SIGNAL_INT: return SIGINT;
#endif
#if defined (SIGQUIT)
    case TARGET_SIGNAL_QUIT: return SIGQUIT;
#endif
#if defined (SIGILL)
    case TARGET_SIGNAL_ILL: return SIGILL;
#endif
#if defined (SIGTRAP)
    case TARGET_SIGNAL_TRAP: return SIGTRAP;
#endif
#if defined (SIGABRT)
    case TARGET_SIGNAL_ABRT: return SIGABRT;
#endif
#if defined (SIGEMT)
    case TARGET_SIGNAL_EMT: return SIGEMT;
#endif
#if defined (SIGFPE)
    case TARGET_SIGNAL_FPE: return SIGFPE;
#endif
#if defined (SIGKILL)
    case TARGET_SIGNAL_KILL: return SIGKILL;
#endif
#if defined (SIGBUS)
    case TARGET_SIGNAL_BUS: return SIGBUS;
#endif
#if defined (SIGSEGV)
    case TARGET_SIGNAL_SEGV: return SIGSEGV;
#endif
#if defined (SIGSYS)
    case TARGET_SIGNAL_SYS: return SIGSYS;
#endif
#if defined (SIGPIPE)
    case TARGET_SIGNAL_PIPE: return SIGPIPE;
#endif
#if defined (SIGALRM)
    case TARGET_SIGNAL_ALRM: return SIGALRM;
#endif
#if defined (SIGTERM)
    case TARGET_SIGNAL_TERM: return SIGTERM;
#endif
#if defined (SIGUSR1)
    case TARGET_SIGNAL_USR1: return SIGUSR1;
#endif
#if defined (SIGUSR2)
    case TARGET_SIGNAL_USR2: return SIGUSR2;
#endif
#if defined (SIGCHLD) || defined (SIGCLD)
    case TARGET_SIGNAL_CHLD: 
#if defined (SIGCHLD)
      return SIGCHLD;
#else
      return SIGCLD;
#endif
#endif /* SIGCLD or SIGCHLD */
#if defined (SIGPWR)
    case TARGET_SIGNAL_PWR: return SIGPWR;
#endif
#if defined (SIGWINCH)
    case TARGET_SIGNAL_WINCH: return SIGWINCH;
#endif
#if defined (SIGURG)
    case TARGET_SIGNAL_URG: return SIGURG;
#endif
#if defined (SIGIO)
    case TARGET_SIGNAL_IO: return SIGIO;
#endif
#if defined (SIGPOLL)
    case TARGET_SIGNAL_POLL: return SIGPOLL;
#endif
#if defined (SIGSTOP)
    case TARGET_SIGNAL_STOP: return SIGSTOP;
#endif
#if defined (SIGTSTP)
    case TARGET_SIGNAL_TSTP: return SIGTSTP;
#endif
#if defined (SIGCONT)
    case TARGET_SIGNAL_CONT: return SIGCONT;
#endif
#if defined (SIGTTIN)
    case TARGET_SIGNAL_TTIN: return SIGTTIN;
#endif
#if defined (SIGTTOU)
    case TARGET_SIGNAL_TTOU: return SIGTTOU;
#endif
#if defined (SIGVTALRM)
    case TARGET_SIGNAL_VTALRM: return SIGVTALRM;
#endif
#if defined (SIGPROF)
    case TARGET_SIGNAL_PROF: return SIGPROF;
#endif
#if defined (SIGXCPU)
    case TARGET_SIGNAL_XCPU: return SIGXCPU;
#endif
#if defined (SIGXFSZ)
    case TARGET_SIGNAL_XFSZ: return SIGXFSZ;
#endif
#if defined (SIGWIND)
    case TARGET_SIGNAL_WIND: return SIGWIND;
#endif
#if defined (SIGPHONE)
    case TARGET_SIGNAL_PHONE: return SIGPHONE;
#endif
#if defined (SIGLOST)
    case TARGET_SIGNAL_LOST: return SIGLOST;
#endif
#if defined (SIGINFO)
    case TARGET_SIGNAL_INFO: return SIGINFO;
#endif
#if defined (SIGWAITING)
    case TARGET_SIGNAL_WAITING: return SIGWAITING;
#endif
#if defined (SIGLWP)
    case TARGET_SIGNAL_LWP: return SIGLWP;
#endif
#if defined (SIGDANGER)
    case TARGET_SIGNAL_DANGER: return SIGDANGER;
#endif
#if defined (SIGGRANT)
    case TARGET_SIGNAL_GRANT: return SIGGRANT;
#endif
#if defined (SIGRETRACT)
    case TARGET_SIGNAL_RETRACT: return SIGRETRACT;
#endif
#if defined (SIGMSG)
    case TARGET_SIGNAL_MSG: return SIGMSG;
#endif
#if defined (SIGSOUND)
    case TARGET_SIGNAL_SOUND: return SIGSOUND;
#endif
#if defined (SIGSAK)
    case TARGET_SIGNAL_SAK: return SIGSAK;
#endif
#if defined (SIGPRIO)
    case TARGET_SIGNAL_PRIO: return SIGPRIO;
#endif

      /* Mach exceptions.  Assumes that the values for EXC_ are positive! */
#if defined (EXC_BAD_ACCESS) && defined (_NSIG)
    case TARGET_EXC_BAD_ACCESS: return _NSIG + EXC_BAD_ACCESS;
#endif
#if defined (EXC_BAD_INSTRUCTION) && defined (_NSIG)
    case TARGET_EXC_BAD_INSTRUCTION: return _NSIG + EXC_BAD_INSTRUCTION;
#endif
#if defined (EXC_ARITHMETIC) && defined (_NSIG)
    case TARGET_EXC_ARITHMETIC: return _NSIG + EXC_ARITHMETIC;
#endif
#if defined (EXC_EMULATION) && defined (_NSIG)
    case TARGET_EXC_EMULATION: return _NSIG + EXC_EMULATION;
#endif
#if defined (EXC_SOFTWARE) && defined (_NSIG)
    case TARGET_EXC_SOFTWARE: return _NSIG + EXC_SOFTWARE;
#endif
#if defined (EXC_BREAKPOINT) && defined (_NSIG)
    case TARGET_EXC_BREAKPOINT: return _NSIG + EXC_BREAKPOINT;
#endif
d1554 2
a1555 17
    default:
#if defined (REALTIME_LO)
      if (oursig >= TARGET_SIGNAL_REALTIME_33
	  && oursig <= TARGET_SIGNAL_REALTIME_63)
	{
	  int retsig =
	    (int)oursig - (int)TARGET_SIGNAL_REALTIME_33 + REALTIME_LO;
	  if (retsig < REALTIME_HI)
	    return retsig;
	}
#endif
      /* The user might be trying to do "signal SIGSAK" where this system
	 doesn't have SIGSAK.  */
      warning ("Signal %s does not exist on this system.\n",
	       target_signal_to_name (oursig));
      return 0;
    }
d1557 1
a1557 1

d1562 1
a1562 3
store_waitstatus (ourstatus, hoststatus)
     struct target_waitstatus *ourstatus;
     int hoststatus;
a1587 18
/* In some circumstances we allow a command to specify a numeric
   signal.  The idea is to keep these circumstances limited so that
   users (and scripts) develop portable habits.  For comparison,
   POSIX.2 `kill' requires that 1,2,3,6,9,14, and 15 work (and using a
   numeric signal at all is obscelescent.  We are slightly more
   lenient and allow 1-15 which should match host signal numbers on
   most systems.  Use of symbolic signal names is strongly encouraged.  */

enum target_signal
target_signal_from_command (num)
     int num;
{
  if (num >= 1 && num <= 15)
    return (enum target_signal)num;
  error ("Only signals 1-15 are valid as numeric signals.\n\
Use \"info signals\" for a list of symbolic signals.");
}

d1589 1
a1589 1
int (*target_activity_function) PARAMS ((void));
d1596 1
a1596 2
normal_pid_to_str (pid)
     int pid;
d1600 17
a1616 4
  if (STREQ (current_target.to_shortname, "remote"))
    sprintf (buf, "thread %d", pid);
  else
    sprintf (buf, "process %d", pid);
d1618 17
a1634 1
  return buf;
d1637 1
a1637 1
#ifdef MAINTENANCE_CMDS
d1641 1
a1641 3
debug_to_open (args, from_tty)
     char *args;
     int from_tty;
d1645 1
a1645 1
  fprintf_unfiltered (stderr, "target_open (%s, %d)\n", args, from_tty);
d1649 1
a1649 2
debug_to_close (quitting)
     int quitting;
d1651 3
a1653 1
  debug_target.to_close (quitting);
d1655 7
a1661 1
  fprintf_unfiltered (stderr, "target_close (%d)\n", quitting);
d1665 1
a1665 3
debug_to_attach (args, from_tty)
     char *args;
     int from_tty;
d1669 10
a1678 1
  fprintf_unfiltered (stderr, "target_attach (%s, %d)\n", args, from_tty);
d1682 1
a1682 3
debug_to_detach (args, from_tty)
     char *args;
     int from_tty;
d1686 10
a1695 1
  fprintf_unfiltered (stderr, "target_detach (%s, %d)\n", args, from_tty);
d1699 1
a1699 4
debug_to_resume (pid, step, siggnal)
     int pid;
     int step;
     enum target_signal siggnal;
d1701 1
a1701 1
  debug_target.to_resume (pid, step, siggnal);
d1703 1
a1703 1
  fprintf_unfiltered (stderr, "target_resume (%d, %s, %s)\n", pid,
d1708 2
a1709 4
static int
debug_to_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
d1711 1
a1711 1
  int retval;
d1713 1
a1713 1
  retval = debug_target.to_wait (pid, status);
d1715 4
a1718 2
  fprintf_unfiltered (stderr, "target_wait (%d, status) = %d,   ", pid, retval);
  fprintf_unfiltered (stderr, "status->kind = ");
d1722 2
a1723 1
      fprintf_unfiltered (stderr, "exited, status = %d\n", status->value.integer);
d1726 1
a1726 1
      fprintf_unfiltered (stderr, "stopped, signal = %s\n",
d1730 1
a1730 1
      fprintf_unfiltered (stderr, "signalled, signal = %s\n",
d1734 10
a1743 1
      fprintf_unfiltered (stderr, "loaded\n");
d1746 1
a1746 1
      fprintf_unfiltered (stderr, "spurious\n");
d1749 1
a1749 1
      fprintf_unfiltered (stderr, "unknown???\n");
d1757 39
a1795 2
debug_to_fetch_registers (regno)
     int regno;
d1798 1
a1798 7

  fprintf_unfiltered (stderr, "target_fetch_registers (%s)",
		      regno != -1 ? reg_names[regno] : "-1");
  if (regno != -1)
    fprintf_unfiltered (stderr, " = 0x%x %d", read_register (regno),
			read_register (regno));
  fprintf_unfiltered (stderr, "\n");
d1802 1
a1802 2
debug_to_store_registers (regno)
     int regno;
d1805 2
a1806 7

  if (regno >= 0 && regno < NUM_REGS)
    fprintf_unfiltered (stderr, "target_store_registers (%s) = 0x%x %d\n",
			reg_names[regno], read_register (regno),
			read_register (regno));
  else
    fprintf_unfiltered (stderr, "target_store_registers (%d)\n", regno);
d1810 1
a1810 1
debug_to_prepare_to_store ()
d1814 1
a1814 1
  fprintf_unfiltered (stderr, "target_prepare_to_store ()\n");
d1818 3
a1820 6
debug_to_xfer_memory (memaddr, myaddr, len, write, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
     struct target_ops *target;
d1824 2
a1825 1
  retval = debug_target.to_xfer_memory (memaddr, myaddr, len, write, target);
d1827 1
a1827 1
  fprintf_unfiltered (stderr,
d1829 4
a1832 1
		      memaddr, len, write ? "write" : "read", retval);
d1838 1
a1838 1
      fputs_unfiltered (", bytes =", gdb_stderr);
d1842 2
a1843 2
	    fprintf_unfiltered (stderr, "\n");
	  fprintf_unfiltered (stderr, " %02x", myaddr[i] & 0xff);
d1847 1
a1847 1
  fputc_unfiltered ('\n', gdb_stderr);
d1853 1
a1853 2
debug_to_files_info (target)
     struct target_ops *target;
d1857 1
a1857 1
  fprintf_unfiltered (stderr, "target_files_info (xxx)\n");
d1861 1
a1861 3
debug_to_insert_breakpoint (addr, save)
     CORE_ADDR addr;
     char *save;
d1867 4
a1870 2
  fprintf_unfiltered (stderr, "target_insert_breakpoint (0x%x, xxx) = %d\n",
		      addr, retval);
d1875 1
a1875 3
debug_to_remove_breakpoint (addr, save)
     CORE_ADDR addr;
     char *save;
d1881 114
a1994 2
  fprintf_unfiltered (stderr, "target_remove_breakpoint (0x%x, xxx) = %d\n",
		      addr, retval);
d1999 1
a1999 1
debug_to_terminal_init ()
d2003 1
a2003 1
  fprintf_unfiltered (stderr, "target_terminal_init ()\n");
d2007 1
a2007 1
debug_to_terminal_inferior ()
d2011 1
a2011 1
  fprintf_unfiltered (stderr, "target_terminal_inferior ()\n");
d2015 1
a2015 1
debug_to_terminal_ours_for_output ()
d2019 1
a2019 1
  fprintf_unfiltered (stderr, "target_terminal_ours_for_output ()\n");
d2023 1
a2023 1
debug_to_terminal_ours ()
d2027 1
a2027 1
  fprintf_unfiltered (stderr, "target_terminal_ours ()\n");
d2031 9
a2039 3
debug_to_terminal_info (arg, from_tty)
     char *arg;
     int from_tty;
d2043 1
a2043 1
  fprintf_unfiltered (stderr, "target_terminal_info (%s, %d)\n", arg,
d2048 1
a2048 1
debug_to_kill ()
d2052 1
a2052 1
  fprintf_unfiltered (stderr, "target_kill ()\n");
d2056 1
a2056 3
debug_to_load (args, from_tty)
     char *args;
     int from_tty;
d2060 1
a2060 1
  fprintf_unfiltered (stderr, "target_load (%s, %d)\n", args, from_tty);
d2064 1
a2064 3
debug_to_lookup_symbol (name, addrp)
     char *name;
     CORE_ADDR *addrp;
d2070 1
a2070 1
  fprintf_unfiltered (stderr, "target_lookup_symbol (%s, xxx)\n", name);
d2076 1
a2076 4
debug_to_create_inferior (exec_file, args, env)
     char *exec_file;
     char *args;
     char **env;
d2080 1
a2080 1
  fprintf_unfiltered (stderr, "target_create_inferior (%s, %s, xxx)\n",
d2085 135
a2219 1
debug_to_mourn_inferior ()
d2223 1
a2223 1
  fprintf_unfiltered (stderr, "target_mourn_inferior ()\n");
d2227 1
a2227 1
debug_to_can_run ()
d2233 1
a2233 1
  fprintf_unfiltered (stderr, "target_can_run () = %d\n", retval);
d2239 1
a2239 2
debug_to_notice_signals (pid)
     int pid;
d2241 1
a2241 1
  debug_target.to_notice_signals (pid);
d2243 2
a2244 1
  fprintf_unfiltered (stderr, "target_notice_signals (%d)\n", pid);
d2248 1
a2248 2
debug_to_thread_alive (pid)
     int pid;
d2252 1
a2252 1
  retval = debug_target.to_thread_alive (pid);
d2254 2
a2255 1
  fprintf_unfiltered (stderr, "target_thread_alive (%d) = %d\n", pid, retval);
d2261 9
a2269 1
debug_to_stop ()
d2273 61
a2333 1
  fprintf_unfiltered (stderr, "target_stop ()\n");
d2337 1
a2337 1
setup_target_debug ()
d2344 1
d2346 1
d2349 1
d2357 8
d2369 1
d2375 11
d2390 1
d2392 6
a2398 1
#endif /* MAINTENANCE_CMDS */
d2400 3
a2402 2
static char targ_desc[] = 
    "Names of targets and files being debugged.\n\
d2406 15
d2422 1
a2422 1
initialize_targets ()
d2424 1
d2430 19
a2448 8
#ifdef MAINTENANCE_CMDS
  add_show_from_set (
     add_set_cmd ("targetdebug", class_maintenance, var_zinteger,
		  (char *)&targetdebug,
		 "Set target debugging.\n\
When non-zero, target debugging is enabled.", &setlist),
		     &showlist);
#endif
d2450 1
a2450 2
  if (!STREQ (signals[TARGET_SIGNAL_LAST].string, "TARGET_SIGNAL_MAGIC"))
    abort ();
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d1067 3
d1071 1
d1252 3
d1473 3
@


1.1
log
@file target.c was initially added on branch CYGNUS.
@
text
@d1 2001
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 2451
/* Select target systems and architectures at runtime for GDB.

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.

   Contributed by Cygnus Support.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include <errno.h>
#include "gdb_string.h"
#include "target.h"
#include "gdbcmd.h"
#include "symtab.h"
#include "inferior.h"
#include "bfd.h"
#include "symfile.h"
#include "objfiles.h"
#include "gdb_wait.h"
#include "dcache.h"
#include <signal.h>
#include "regcache.h"
#include "gdb_assert.h"
#include "gdbcore.h"

static void target_info (char *, int);

static void maybe_kill_then_create_inferior (char *, char *, char **);

static void maybe_kill_then_attach (char *, int);

static void kill_or_be_killed (int);

static void default_terminal_info (char *, int);

static int default_region_size_ok_for_hw_watchpoint (int);

static int nosymbol (char *, CORE_ADDR *);

static void tcomplain (void);

static int nomemory (CORE_ADDR, char *, int, int, struct target_ops *);

static int return_zero (void);

static int return_one (void);

static int return_minus_one (void);

void target_ignore (void);

static void target_command (char *, int);

static struct target_ops *find_default_run_target (char *);

static void nosupport_runtime (void);

static LONGEST default_xfer_partial (struct target_ops *ops,
				     enum target_object object,
				     const char *annex, void *readbuf,
				     const void *writebuf,
				     ULONGEST offset, LONGEST len);

/* Transfer LEN bytes between target address MEMADDR and GDB address
   MYADDR.  Returns 0 for success, errno code for failure (which
   includes partial transfers -- if you want a more useful response to
   partial transfers, try either target_read_memory_partial or
   target_write_memory_partial).  */

static int target_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len,
			       int write);

static void init_dummy_target (void);

static void debug_to_open (char *, int);

static void debug_to_close (int);

static void debug_to_attach (char *, int);

static void debug_to_detach (char *, int);

static void debug_to_disconnect (char *, int);

static void debug_to_resume (ptid_t, int, enum target_signal);

static ptid_t debug_to_wait (ptid_t, struct target_waitstatus *);

static void debug_to_fetch_registers (int);

static void debug_to_store_registers (int);

static void debug_to_prepare_to_store (void);

static int debug_to_xfer_memory (CORE_ADDR, char *, int, int,
				 struct mem_attrib *, struct target_ops *);

static void debug_to_files_info (struct target_ops *);

static int debug_to_insert_breakpoint (CORE_ADDR, char *);

static int debug_to_remove_breakpoint (CORE_ADDR, char *);

static int debug_to_can_use_hw_breakpoint (int, int, int);

static int debug_to_insert_hw_breakpoint (CORE_ADDR, char *);

static int debug_to_remove_hw_breakpoint (CORE_ADDR, char *);

static int debug_to_insert_watchpoint (CORE_ADDR, int, int);

static int debug_to_remove_watchpoint (CORE_ADDR, int, int);

static int debug_to_stopped_by_watchpoint (void);

static CORE_ADDR debug_to_stopped_data_address (void);

static int debug_to_region_size_ok_for_hw_watchpoint (int);

static void debug_to_terminal_init (void);

static void debug_to_terminal_inferior (void);

static void debug_to_terminal_ours_for_output (void);

static void debug_to_terminal_save_ours (void);

static void debug_to_terminal_ours (void);

static void debug_to_terminal_info (char *, int);

static void debug_to_kill (void);

static void debug_to_load (char *, int);

static int debug_to_lookup_symbol (char *, CORE_ADDR *);

static void debug_to_create_inferior (char *, char *, char **);

static void debug_to_mourn_inferior (void);

static int debug_to_can_run (void);

static void debug_to_notice_signals (ptid_t);

static int debug_to_thread_alive (ptid_t);

static void debug_to_stop (void);

/* Pointer to array of target architecture structures; the size of the
   array; the current index into the array; the allocated size of the 
   array.  */
struct target_ops **target_structs;
unsigned target_struct_size;
unsigned target_struct_index;
unsigned target_struct_allocsize;
#define	DEFAULT_ALLOCSIZE	10

/* The initial current target, so that there is always a semi-valid
   current target.  */

static struct target_ops dummy_target;

/* Top of target stack.  */

static struct target_ops *target_stack;

/* The target structure we are currently using to talk to a process
   or file or whatever "inferior" we have.  */

struct target_ops current_target;

/* Command list for target.  */

static struct cmd_list_element *targetlist = NULL;

/* Nonzero if we are debugging an attached outside process
   rather than an inferior.  */

int attach_flag;

/* Non-zero if we want to see trace of target level stuff.  */

static int targetdebug = 0;

static void setup_target_debug (void);

DCACHE *target_dcache;

/* The user just typed 'target' without the name of a target.  */

static void
target_command (char *arg, int from_tty)
{
  fputs_filtered ("Argument required (target name).  Try `help target'\n",
		  gdb_stdout);
}

/* Add a possible target architecture to the list.  */

void
add_target (struct target_ops *t)
{
  /* Provide default values for all "must have" methods.  */
  if (t->to_xfer_partial == NULL)
    t->to_xfer_partial = default_xfer_partial;

  if (!target_structs)
    {
      target_struct_allocsize = DEFAULT_ALLOCSIZE;
      target_structs = (struct target_ops **) xmalloc
	(target_struct_allocsize * sizeof (*target_structs));
    }
  if (target_struct_size >= target_struct_allocsize)
    {
      target_struct_allocsize *= 2;
      target_structs = (struct target_ops **)
	xrealloc ((char *) target_structs,
		  target_struct_allocsize * sizeof (*target_structs));
    }
  target_structs[target_struct_size++] = t;

  if (targetlist == NULL)
    add_prefix_cmd ("target", class_run, target_command,
		    "Connect to a target machine or process.\n\
The first argument is the type or protocol of the target machine.\n\
Remaining arguments are interpreted by the target protocol.  For more\n\
information on the arguments for a particular protocol, type\n\
`help target ' followed by the protocol name.",
		    &targetlist, "target ", 0, &cmdlist);
  add_cmd (t->to_shortname, no_class, t->to_open, t->to_doc, &targetlist);
}

/* Stub functions */

void
target_ignore (void)
{
}

void
target_load (char *arg, int from_tty)
{
  dcache_invalidate (target_dcache);
  (*current_target.to_load) (arg, from_tty);
}

static int
nomemory (CORE_ADDR memaddr, char *myaddr, int len, int write,
	  struct target_ops *t)
{
  errno = EIO;			/* Can't read/write this location */
  return 0;			/* No bytes handled */
}

static void
tcomplain (void)
{
  error ("You can't do that when your target is `%s'",
	 current_target.to_shortname);
}

void
noprocess (void)
{
  error ("You can't do that without a process to debug.");
}

static int
nosymbol (char *name, CORE_ADDR *addrp)
{
  return 1;			/* Symbol does not exist in target env */
}

static void
nosupport_runtime (void)
{
  if (ptid_equal (inferior_ptid, null_ptid))
    noprocess ();
  else
    error ("No run-time support for this");
}


static void
default_terminal_info (char *args, int from_tty)
{
  printf_unfiltered ("No saved terminal information.\n");
}

/* This is the default target_create_inferior and target_attach function.
   If the current target is executing, it asks whether to kill it off.
   If this function returns without calling error(), it has killed off
   the target, and the operation should be attempted.  */

static void
kill_or_be_killed (int from_tty)
{
  if (target_has_execution)
    {
      printf_unfiltered ("You are already running a program:\n");
      target_files_info ();
      if (query ("Kill it? "))
	{
	  target_kill ();
	  if (target_has_execution)
	    error ("Killing the program did not help.");
	  return;
	}
      else
	{
	  error ("Program not killed.");
	}
    }
  tcomplain ();
}

static void
maybe_kill_then_attach (char *args, int from_tty)
{
  kill_or_be_killed (from_tty);
  target_attach (args, from_tty);
}

static void
maybe_kill_then_create_inferior (char *exec, char *args, char **env)
{
  kill_or_be_killed (0);
  target_create_inferior (exec, args, env);
}

/* Go through the target stack from top to bottom, copying over zero
   entries in current_target, then filling in still empty entries.  In
   effect, we are doing class inheritance through the pushed target
   vectors.

   NOTE: cagney/2003-10-17: The problem with this inheritance, as it
   is currently implemented, is that it discards any knowledge of
   which target an inherited method originally belonged to.
   Consequently, new new target methods should instead explicitly and
   locally search the target stack for the target that can handle the
   request.  */

static void
update_current_target (void)
{
  struct target_ops *t;

  /* First, reset curren'ts contents.  */
  memset (&current_target, 0, sizeof (current_target));

#define INHERIT(FIELD, TARGET) \
      if (!current_target.FIELD) \
	current_target.FIELD = (TARGET)->FIELD

  for (t = target_stack; t; t = t->beneath)
    {
      INHERIT (to_shortname, t);
      INHERIT (to_longname, t);
      INHERIT (to_doc, t);
      INHERIT (to_open, t);
      INHERIT (to_close, t);
      INHERIT (to_attach, t);
      INHERIT (to_post_attach, t);
      INHERIT (to_detach, t);
      INHERIT (to_disconnect, t);
      INHERIT (to_resume, t);
      INHERIT (to_wait, t);
      INHERIT (to_post_wait, t);
      INHERIT (to_fetch_registers, t);
      INHERIT (to_store_registers, t);
      INHERIT (to_prepare_to_store, t);
      INHERIT (to_xfer_memory, t);
      INHERIT (to_files_info, t);
      INHERIT (to_insert_breakpoint, t);
      INHERIT (to_remove_breakpoint, t);
      INHERIT (to_can_use_hw_breakpoint, t);
      INHERIT (to_insert_hw_breakpoint, t);
      INHERIT (to_remove_hw_breakpoint, t);
      INHERIT (to_insert_watchpoint, t);
      INHERIT (to_remove_watchpoint, t);
      INHERIT (to_stopped_data_address, t);
      INHERIT (to_stopped_by_watchpoint, t);
      INHERIT (to_have_continuable_watchpoint, t);
      INHERIT (to_region_size_ok_for_hw_watchpoint, t);
      INHERIT (to_terminal_init, t);
      INHERIT (to_terminal_inferior, t);
      INHERIT (to_terminal_ours_for_output, t);
      INHERIT (to_terminal_ours, t);
      INHERIT (to_terminal_save_ours, t);
      INHERIT (to_terminal_info, t);
      INHERIT (to_kill, t);
      INHERIT (to_load, t);
      INHERIT (to_lookup_symbol, t);
      INHERIT (to_create_inferior, t);
      INHERIT (to_post_startup_inferior, t);
      INHERIT (to_acknowledge_created_inferior, t);
      INHERIT (to_insert_fork_catchpoint, t);
      INHERIT (to_remove_fork_catchpoint, t);
      INHERIT (to_insert_vfork_catchpoint, t);
      INHERIT (to_remove_vfork_catchpoint, t);
      INHERIT (to_follow_fork, t);
      INHERIT (to_insert_exec_catchpoint, t);
      INHERIT (to_remove_exec_catchpoint, t);
      INHERIT (to_reported_exec_events_per_exec_call, t);
      INHERIT (to_has_exited, t);
      INHERIT (to_mourn_inferior, t);
      INHERIT (to_can_run, t);
      INHERIT (to_notice_signals, t);
      INHERIT (to_thread_alive, t);
      INHERIT (to_find_new_threads, t);
      INHERIT (to_pid_to_str, t);
      INHERIT (to_extra_thread_info, t);
      INHERIT (to_stop, t);
      /* Do not inherit to_xfer_partial.  */
      INHERIT (to_rcmd, t);
      INHERIT (to_enable_exception_callback, t);
      INHERIT (to_get_current_exception_event, t);
      INHERIT (to_pid_to_exec_file, t);
      INHERIT (to_stratum, t);
      INHERIT (to_has_all_memory, t);
      INHERIT (to_has_memory, t);
      INHERIT (to_has_stack, t);
      INHERIT (to_has_registers, t);
      INHERIT (to_has_execution, t);
      INHERIT (to_has_thread_control, t);
      INHERIT (to_sections, t);
      INHERIT (to_sections_end, t);
      INHERIT (to_can_async_p, t);
      INHERIT (to_is_async_p, t);
      INHERIT (to_async, t);
      INHERIT (to_async_mask_value, t);
      INHERIT (to_find_memory_regions, t);
      INHERIT (to_make_corefile_notes, t);
      INHERIT (to_get_thread_local_address, t);
      INHERIT (to_magic, t);
    }
#undef INHERIT

  /* Clean up a target struct so it no longer has any zero pointers in
     it.  Some entries are defaulted to a method that print an error,
     others are hard-wired to a standard recursive default.  */

#define de_fault(field, value) \
  if (!current_target.field)               \
    current_target.field = value

  de_fault (to_open, 
	    (void (*) (char *, int)) 
	    tcomplain);
  de_fault (to_close, 
	    (void (*) (int)) 
	    target_ignore);
  de_fault (to_attach, 
	    maybe_kill_then_attach);
  de_fault (to_post_attach, 
	    (void (*) (int)) 
	    target_ignore);
  de_fault (to_detach, 
	    (void (*) (char *, int)) 
	    target_ignore);
  de_fault (to_disconnect, 
	    (void (*) (char *, int)) 
	    tcomplain);
  de_fault (to_resume, 
	    (void (*) (ptid_t, int, enum target_signal)) 
	    noprocess);
  de_fault (to_wait, 
	    (ptid_t (*) (ptid_t, struct target_waitstatus *)) 
	    noprocess);
  de_fault (to_post_wait, 
	    (void (*) (ptid_t, int)) 
	    target_ignore);
  de_fault (to_fetch_registers, 
	    (void (*) (int)) 
	    target_ignore);
  de_fault (to_store_registers, 
	    (void (*) (int)) 
	    noprocess);
  de_fault (to_prepare_to_store, 
	    (void (*) (void)) 
	    noprocess);
  de_fault (to_xfer_memory, 
	    (int (*) (CORE_ADDR, char *, int, int, struct mem_attrib *, struct target_ops *)) 
	    nomemory);
  de_fault (to_files_info, 
	    (void (*) (struct target_ops *)) 
	    target_ignore);
  de_fault (to_insert_breakpoint, 
	    memory_insert_breakpoint);
  de_fault (to_remove_breakpoint, 
	    memory_remove_breakpoint);
  de_fault (to_can_use_hw_breakpoint,
	    (int (*) (int, int, int))
	    return_zero);
  de_fault (to_insert_hw_breakpoint,
	    (int (*) (CORE_ADDR, char *))
	    return_minus_one);
  de_fault (to_remove_hw_breakpoint,
	    (int (*) (CORE_ADDR, char *))
	    return_minus_one);
  de_fault (to_insert_watchpoint,
	    (int (*) (CORE_ADDR, int, int))
	    return_minus_one);
  de_fault (to_remove_watchpoint,
	    (int (*) (CORE_ADDR, int, int))
	    return_minus_one);
  de_fault (to_stopped_by_watchpoint,
	    (int (*) (void))
	    return_zero);
  de_fault (to_stopped_data_address,
	    (CORE_ADDR (*) (void))
	    return_zero);
  de_fault (to_region_size_ok_for_hw_watchpoint,
	    default_region_size_ok_for_hw_watchpoint);
  de_fault (to_terminal_init, 
	    (void (*) (void)) 
	    target_ignore);
  de_fault (to_terminal_inferior, 
	    (void (*) (void)) 
	    target_ignore);
  de_fault (to_terminal_ours_for_output, 
	    (void (*) (void)) 
	    target_ignore);
  de_fault (to_terminal_ours, 
	    (void (*) (void)) 
	    target_ignore);
  de_fault (to_terminal_save_ours, 
	    (void (*) (void)) 
	    target_ignore);
  de_fault (to_terminal_info, 
	    default_terminal_info);
  de_fault (to_kill, 
	    (void (*) (void)) 
	    noprocess);
  de_fault (to_load, 
	    (void (*) (char *, int)) 
	    tcomplain);
  de_fault (to_lookup_symbol, 
	    (int (*) (char *, CORE_ADDR *)) 
	    nosymbol);
  de_fault (to_create_inferior, 
	    maybe_kill_then_create_inferior);
  de_fault (to_post_startup_inferior, 
	    (void (*) (ptid_t)) 
	    target_ignore);
  de_fault (to_acknowledge_created_inferior, 
	    (void (*) (int)) 
	    target_ignore);
  de_fault (to_insert_fork_catchpoint, 
	    (int (*) (int)) 
	    tcomplain);
  de_fault (to_remove_fork_catchpoint, 
	    (int (*) (int)) 
	    tcomplain);
  de_fault (to_insert_vfork_catchpoint, 
	    (int (*) (int)) 
	    tcomplain);
  de_fault (to_remove_vfork_catchpoint, 
	    (int (*) (int)) 
	    tcomplain);
  de_fault (to_follow_fork,
	    (int (*) (int)) 
	    target_ignore);
  de_fault (to_insert_exec_catchpoint, 
	    (int (*) (int)) 
	    tcomplain);
  de_fault (to_remove_exec_catchpoint, 
	    (int (*) (int)) 
	    tcomplain);
  de_fault (to_reported_exec_events_per_exec_call, 
	    (int (*) (void)) 
	    return_one);
  de_fault (to_has_exited, 
	    (int (*) (int, int, int *)) 
	    return_zero);
  de_fault (to_mourn_inferior, 
	    (void (*) (void)) 
	    noprocess);
  de_fault (to_can_run, 
	    return_zero);
  de_fault (to_notice_signals, 
	    (void (*) (ptid_t)) 
	    target_ignore);
  de_fault (to_thread_alive, 
	    (int (*) (ptid_t)) 
	    return_zero);
  de_fault (to_find_new_threads, 
	    (void (*) (void)) 
	    target_ignore);
  de_fault (to_extra_thread_info, 
	    (char *(*) (struct thread_info *)) 
	    return_zero);
  de_fault (to_stop, 
	    (void (*) (void)) 
	    target_ignore);
  current_target.to_xfer_partial = default_xfer_partial;
  de_fault (to_rcmd, 
	    (void (*) (char *, struct ui_file *)) 
	    tcomplain);
  de_fault (to_enable_exception_callback, 
	    (struct symtab_and_line * (*) (enum exception_event_kind, int)) 
	    nosupport_runtime);
  de_fault (to_get_current_exception_event, 
	    (struct exception_event_record * (*) (void)) 
	    nosupport_runtime);
  de_fault (to_pid_to_exec_file, 
	    (char *(*) (int)) 
	    return_zero);
  de_fault (to_can_async_p, 
	    (int (*) (void)) 
	    return_zero);
  de_fault (to_is_async_p, 
	    (int (*) (void)) 
	    return_zero);
  de_fault (to_async, 
	    (void (*) (void (*) (enum inferior_event_type, void*), void*)) 
	    tcomplain);
#undef de_fault

  /* Finally, position the target-stack beneath the squashed
     "current_target".  That way code looking for a non-inherited
     target method can quickly and simply find it.  */
  current_target.beneath = target_stack;
}

/* Push a new target type into the stack of the existing target accessors,
   possibly superseding some of the existing accessors.

   Result is zero if the pushed target ended up on top of the stack,
   nonzero if at least one target is on top of it.

   Rather than allow an empty stack, we always have the dummy target at
   the bottom stratum, so we can call the function vectors without
   checking them.  */

int
push_target (struct target_ops *t)
{
  struct target_ops **cur;

  /* Check magic number.  If wrong, it probably means someone changed
     the struct definition, but not all the places that initialize one.  */
  if (t->to_magic != OPS_MAGIC)
    {
      fprintf_unfiltered (gdb_stderr,
			  "Magic number of %s target struct wrong\n",
			  t->to_shortname);
      internal_error (__FILE__, __LINE__, "failed internal consistency check");
    }

  /* Find the proper stratum to install this target in.  */
  for (cur = &target_stack; (*cur) != NULL; cur = &(*cur)->beneath)
    {
      if ((int) (t->to_stratum) >= (int) (*cur)->to_stratum)
	break;
    }

  /* If there's already targets at this stratum, remove them.  */
  /* FIXME: cagney/2003-10-15: I think this should be poping all
     targets to CUR, and not just those at this stratum level.  */
  while ((*cur) != NULL && t->to_stratum == (*cur)->to_stratum)
    {
      /* There's already something at this stratum level.  Close it,
         and un-hook it from the stack.  */
      struct target_ops *tmp = (*cur);
      (*cur) = (*cur)->beneath;
      tmp->beneath = NULL;
      target_close (tmp, 0);
    }

  /* We have removed all targets in our stratum, now add the new one.  */
  t->beneath = (*cur);
  (*cur) = t;

  update_current_target ();

  if (targetdebug)
    setup_target_debug ();

  /* Not on top?  */
  return (t != target_stack);
}

/* Remove a target_ops vector from the stack, wherever it may be. 
   Return how many times it was removed (0 or 1).  */

int
unpush_target (struct target_ops *t)
{
  struct target_ops **cur;
  struct target_ops *tmp;

  /* Look for the specified target.  Note that we assume that a target
     can only occur once in the target stack. */

  for (cur = &target_stack; (*cur) != NULL; cur = &(*cur)->beneath)
    {
      if ((*cur) == t)
	break;
    }

  if ((*cur) == NULL)
    return 0;			/* Didn't find target_ops, quit now */

  /* NOTE: cagney/2003-12-06: In '94 the close call was made
     unconditional by moving it to before the above check that the
     target was in the target stack (something about "Change the way
     pushing and popping of targets work to support target overlays
     and inheritance").  This doesn't make much sense - only open
     targets should be closed.  */
  target_close (t, 0);

  /* Unchain the target */
  tmp = (*cur);
  (*cur) = (*cur)->beneath;
  tmp->beneath = NULL;

  update_current_target ();

  return 1;
}

void
pop_target (void)
{
  target_close (&current_target, 0);	/* Let it clean up */
  if (unpush_target (target_stack) == 1)
    return;

  fprintf_unfiltered (gdb_stderr,
		      "pop_target couldn't find target %s\n",
		      current_target.to_shortname);
  internal_error (__FILE__, __LINE__, "failed internal consistency check");
}

#undef	MIN
#define MIN(A, B) (((A) <= (B)) ? (A) : (B))

/* target_read_string -- read a null terminated string, up to LEN bytes,
   from MEMADDR in target.  Set *ERRNOP to the errno code, or 0 if successful.
   Set *STRING to a pointer to malloc'd memory containing the data; the caller
   is responsible for freeing it.  Return the number of bytes successfully
   read.  */

int
target_read_string (CORE_ADDR memaddr, char **string, int len, int *errnop)
{
  int tlen, origlen, offset, i;
  char buf[4];
  int errcode = 0;
  char *buffer;
  int buffer_allocated;
  char *bufptr;
  unsigned int nbytes_read = 0;

  /* Small for testing.  */
  buffer_allocated = 4;
  buffer = xmalloc (buffer_allocated);
  bufptr = buffer;

  origlen = len;

  while (len > 0)
    {
      tlen = MIN (len, 4 - (memaddr & 3));
      offset = memaddr & 3;

      errcode = target_xfer_memory (memaddr & ~3, buf, 4, 0);
      if (errcode != 0)
	{
	  /* The transfer request might have crossed the boundary to an
	     unallocated region of memory. Retry the transfer, requesting
	     a single byte.  */
	  tlen = 1;
	  offset = 0;
	  errcode = target_xfer_memory (memaddr, buf, 1, 0);
	  if (errcode != 0)
	    goto done;
	}

      if (bufptr - buffer + tlen > buffer_allocated)
	{
	  unsigned int bytes;
	  bytes = bufptr - buffer;
	  buffer_allocated *= 2;
	  buffer = xrealloc (buffer, buffer_allocated);
	  bufptr = buffer + bytes;
	}

      for (i = 0; i < tlen; i++)
	{
	  *bufptr++ = buf[i + offset];
	  if (buf[i + offset] == '\000')
	    {
	      nbytes_read += i + 1;
	      goto done;
	    }
	}

      memaddr += tlen;
      len -= tlen;
      nbytes_read += tlen;
    }
done:
  if (errnop != NULL)
    *errnop = errcode;
  if (string != NULL)
    *string = buffer;
  return nbytes_read;
}

/* Find a section containing ADDR.  */
struct section_table *
target_section_by_addr (struct target_ops *target, CORE_ADDR addr)
{
  struct section_table *secp;
  for (secp = target->to_sections;
       secp < target->to_sections_end;
       secp++)
    {
      if (addr >= secp->addr && addr < secp->endaddr)
	return secp;
    }
  return NULL;
}

/* Read LEN bytes of target memory at address MEMADDR, placing the results in
   GDB's memory at MYADDR.  Returns either 0 for success or an errno value
   if any error occurs.

   If an error occurs, no guarantee is made about the contents of the data at
   MYADDR.  In particular, the caller should not depend upon partial reads
   filling the buffer with good data.  There is no way for the caller to know
   how much good data might have been transfered anyway.  Callers that can
   deal with partial reads should call target_read_memory_partial. */

int
target_read_memory (CORE_ADDR memaddr, char *myaddr, int len)
{
  return target_xfer_memory (memaddr, myaddr, len, 0);
}

int
target_write_memory (CORE_ADDR memaddr, char *myaddr, int len)
{
  return target_xfer_memory (memaddr, myaddr, len, 1);
}

static int trust_readonly = 0;

/* Move memory to or from the targets.  The top target gets priority;
   if it cannot handle it, it is offered to the next one down, etc.

   Result is -1 on error, or the number of bytes transfered.  */

int
do_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		struct mem_attrib *attrib)
{
  int res;
  int done = 0;
  struct target_ops *t;

  /* Zero length requests are ok and require no work.  */
  if (len == 0)
    return 0;

  /* to_xfer_memory is not guaranteed to set errno, even when it returns
     0.  */
  errno = 0;

  if (!write && trust_readonly)
    {
      struct section_table *secp;
      /* User-settable option, "trust-readonly-sections".  If true,
         then memory from any SEC_READONLY bfd section may be read
         directly from the bfd file.  */
      secp = target_section_by_addr (&current_target, memaddr);
      if (secp != NULL
	  && (bfd_get_section_flags (secp->bfd, secp->the_bfd_section)
	      & SEC_READONLY))
	return xfer_memory (memaddr, myaddr, len, 0, attrib, &current_target);
    }

  /* The quick case is that the top target can handle the transfer.  */
  res = current_target.to_xfer_memory
    (memaddr, myaddr, len, write, attrib, &current_target);

  /* If res <= 0 then we call it again in the loop.  Ah well. */
  if (res <= 0)
    {
      for (t = target_stack; t != NULL; t = t->beneath)
	{
	  if (!t->to_has_memory)
	    continue;

	  res = t->to_xfer_memory (memaddr, myaddr, len, write, attrib, t);
	  if (res > 0)
	    break;		/* Handled all or part of xfer */
	  if (t->to_has_all_memory)
	    break;
	}

      if (res <= 0)
	return -1;
    }

  return res;
}


/* Perform a memory transfer.  Iterate until the entire region has
   been transfered.

   Result is 0 or errno value.  */

static int
target_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write)
{
  int res;
  int reg_len;
  struct mem_region *region;

  /* Zero length requests are ok and require no work.  */
  if (len == 0)
    {
      return 0;
    }

  while (len > 0)
    {
      region = lookup_mem_region(memaddr);
      if (memaddr + len < region->hi)
	reg_len = len;
      else
	reg_len = region->hi - memaddr;

      switch (region->attrib.mode)
	{
	case MEM_RO:
	  if (write)
	    return EIO;
	  break;
	  
	case MEM_WO:
	  if (!write)
	    return EIO;
	  break;
	}

      while (reg_len > 0)
	{
	  if (region->attrib.cache)
	    res = dcache_xfer_memory (target_dcache, memaddr, myaddr,
				     reg_len, write);
	  else
	    res = do_xfer_memory (memaddr, myaddr, reg_len, write,
				 &region->attrib);
	      
	  if (res <= 0)
	    {
	      /* If this address is for nonexistent memory, read zeros
		 if reading, or do nothing if writing.  Return
		 error. */
	      if (!write)
		memset (myaddr, 0, len);
	      if (errno == 0)
		return EIO;
	      else
		return errno;
	    }

	  memaddr += res;
	  myaddr  += res;
	  len     -= res;
	  reg_len -= res;
	}
    }
  
  return 0;			/* We managed to cover it all somehow. */
}


/* Perform a partial memory transfer.

   Result is -1 on error, or the number of bytes transfered.  */

static int
target_xfer_memory_partial (CORE_ADDR memaddr, char *myaddr, int len,
			    int write_p, int *err)
{
  int res;
  int reg_len;
  struct mem_region *region;

  /* Zero length requests are ok and require no work.  */
  if (len == 0)
    {
      *err = 0;
      return 0;
    }

  region = lookup_mem_region(memaddr);
  if (memaddr + len < region->hi)
    reg_len = len;
  else
    reg_len = region->hi - memaddr;

  switch (region->attrib.mode)
    {
    case MEM_RO:
      if (write_p)
	{
	  *err = EIO;
	  return -1;
	}
      break;

    case MEM_WO:
      if (write_p)
	{
	  *err = EIO;
	  return -1;
	}
      break;
    }

  if (region->attrib.cache)
    res = dcache_xfer_memory (target_dcache, memaddr, myaddr,
			      reg_len, write_p);
  else
    res = do_xfer_memory (memaddr, myaddr, reg_len, write_p,
			  &region->attrib);
      
  if (res <= 0)
    {
      if (errno != 0)
	*err = errno;
      else
	*err = EIO;

        return -1;
    }

  *err = 0;
  return res;
}

int
target_read_memory_partial (CORE_ADDR memaddr, char *buf, int len, int *err)
{
  return target_xfer_memory_partial (memaddr, buf, len, 0, err);
}

int
target_write_memory_partial (CORE_ADDR memaddr, char *buf, int len, int *err)
{
  return target_xfer_memory_partial (memaddr, buf, len, 1, err);
}

/* More generic transfers.  */

static LONGEST
default_xfer_partial (struct target_ops *ops, enum target_object object,
		      const char *annex, void *readbuf, 
		      const void *writebuf, ULONGEST offset, LONGEST len)
{
  if (object == TARGET_OBJECT_MEMORY
      && ops->to_xfer_memory != NULL)
    /* If available, fall back to the target's "to_xfer_memory"
       method.  */
    {
      int xfered = -1;
      errno = 0;
      if (writebuf != NULL)
	{
	  void *buffer = xmalloc (len);
	  struct cleanup *cleanup = make_cleanup (xfree, buffer);
	  memcpy (buffer, writebuf, len);
	  xfered = ops->to_xfer_memory (offset, buffer, len, 1/*write*/, NULL,
					ops);
	  do_cleanups (cleanup);
	}
      if (readbuf != NULL)
	xfered = ops->to_xfer_memory (offset, readbuf, len, 0/*read*/, NULL,
				      ops);
      if (xfered > 0)
	return xfered;
      else if (xfered == 0 && errno == 0)
	/* "to_xfer_memory" uses 0, cross checked against ERRNO as one
           indication of an error.  */
	return 0;
      else
	return -1;
    }
  else if (ops->beneath != NULL)
    return ops->beneath->to_xfer_partial (ops->beneath, object, annex,
					  readbuf, writebuf, offset, len);
  else
    return -1;
}

/* Target vector read/write partial wrapper functions.

   NOTE: cagney/2003-10-21: I wonder if having "to_xfer_partial
   (inbuf, outbuf)", instead of separate read/write methods, make life
   easier.  */

LONGEST
target_read_partial (struct target_ops *ops,
		     enum target_object object,
		     const char *annex, void *buf,
		     ULONGEST offset, LONGEST len)
{
  gdb_assert (ops->to_xfer_partial != NULL);
  return ops->to_xfer_partial (ops, object, annex, buf, NULL, offset, len);
}

LONGEST
target_write_partial (struct target_ops *ops,
		      enum target_object object,
		      const char *annex, const void *buf,
		      ULONGEST offset, LONGEST len)
{
  gdb_assert (ops->to_xfer_partial != NULL);
  return ops->to_xfer_partial (ops, object, annex, NULL, buf, offset, len);
}

/* Wrappers to perform the full transfer.  */
LONGEST
target_read (struct target_ops *ops,
	     enum target_object object,
	     const char *annex, void *buf,
	     ULONGEST offset, LONGEST len)
{
  LONGEST xfered = 0;
  while (xfered < len)
    {
      LONGEST xfer = target_read_partial (ops, object, annex,
					  (bfd_byte *) buf + xfered,
					  offset + xfered, len - xfered);
      /* Call an observer, notifying them of the xfer progress?  */
      if (xfer <= 0)
	/* Call memory_error?  */
	return -1;
      xfered += xfer;
      QUIT;
    }
  return len;
}

LONGEST
target_write (struct target_ops *ops,
	      enum target_object object,
	      const char *annex, const void *buf,
	      ULONGEST offset, LONGEST len)
{
  LONGEST xfered = 0;
  while (xfered < len)
    {
      LONGEST xfer = target_write_partial (ops, object, annex,
					   (bfd_byte *) buf + xfered,
					   offset + xfered, len - xfered);
      /* Call an observer, notifying them of the xfer progress?  */
      if (xfer <= 0)
	/* Call memory_error?  */
	return -1;
      xfered += xfer;
      QUIT;
    }
  return len;
}

/* Memory transfer methods.  */

void
get_target_memory (struct target_ops *ops, CORE_ADDR addr, void *buf,
		   LONGEST len)
{
  if (target_read (ops, TARGET_OBJECT_MEMORY, NULL, buf, addr, len)
      != len)
    memory_error (EIO, addr);
}

ULONGEST
get_target_memory_unsigned (struct target_ops *ops,
			    CORE_ADDR addr, int len)
{
  char buf[sizeof (ULONGEST)];

  gdb_assert (len <= sizeof (buf));
  get_target_memory (ops, addr, buf, len);
  return extract_unsigned_integer (buf, len);
}

static void
target_info (char *args, int from_tty)
{
  struct target_ops *t;
  int has_all_mem = 0;

  if (symfile_objfile != NULL)
    printf_unfiltered ("Symbols from \"%s\".\n", symfile_objfile->name);

#ifdef FILES_INFO_HOOK
  if (FILES_INFO_HOOK ())
    return;
#endif

  for (t = target_stack; t != NULL; t = t->beneath)
    {
      if (!t->to_has_memory)
	continue;

      if ((int) (t->to_stratum) <= (int) dummy_stratum)
	continue;
      if (has_all_mem)
	printf_unfiltered ("\tWhile running this, GDB does not access memory from...\n");
      printf_unfiltered ("%s:\n", t->to_longname);
      (t->to_files_info) (t);
      has_all_mem = t->to_has_all_memory;
    }
}

/* This is to be called by the open routine before it does
   anything.  */

void
target_preopen (int from_tty)
{
  dont_repeat ();

  if (target_has_execution)
    {
      if (!from_tty
          || query ("A program is being debugged already.  Kill it? "))
	target_kill ();
      else
	error ("Program not killed.");
    }

  /* Calling target_kill may remove the target from the stack.  But if
     it doesn't (which seems like a win for UDI), remove it now.  */

  if (target_has_execution)
    pop_target ();
}

/* Detach a target after doing deferred register stores.  */

void
target_detach (char *args, int from_tty)
{
  /* Handle any optimized stores to the inferior.  */
#ifdef DO_DEFERRED_STORES
  DO_DEFERRED_STORES;
#endif
  (current_target.to_detach) (args, from_tty);
}

void
target_disconnect (char *args, int from_tty)
{
  /* Handle any optimized stores to the inferior.  */
#ifdef DO_DEFERRED_STORES
  DO_DEFERRED_STORES;
#endif
  (current_target.to_disconnect) (args, from_tty);
}

void
target_link (char *modname, CORE_ADDR *t_reloc)
{
  if (DEPRECATED_STREQ (current_target.to_shortname, "rombug"))
    {
      (current_target.to_lookup_symbol) (modname, t_reloc);
      if (*t_reloc == 0)
	error ("Unable to link to %s and get relocation in rombug", modname);
    }
  else
    *t_reloc = (CORE_ADDR) -1;
}

int
target_async_mask (int mask)
{
  int saved_async_masked_status = target_async_mask_value;
  target_async_mask_value = mask;
  return saved_async_masked_status;
}

/* Look through the list of possible targets for a target that can
   execute a run or attach command without any other data.  This is
   used to locate the default process stratum.

   Result is always valid (error() is called for errors).  */

static struct target_ops *
find_default_run_target (char *do_mesg)
{
  struct target_ops **t;
  struct target_ops *runable = NULL;
  int count;

  count = 0;

  for (t = target_structs; t < target_structs + target_struct_size;
       ++t)
    {
      if ((*t)->to_can_run && target_can_run (*t))
	{
	  runable = *t;
	  ++count;
	}
    }

  if (count != 1)
    error ("Don't know how to %s.  Try \"help target\".", do_mesg);

  return runable;
}

void
find_default_attach (char *args, int from_tty)
{
  struct target_ops *t;

  t = find_default_run_target ("attach");
  (t->to_attach) (args, from_tty);
  return;
}

void
find_default_create_inferior (char *exec_file, char *allargs, char **env)
{
  struct target_ops *t;

  t = find_default_run_target ("run");
  (t->to_create_inferior) (exec_file, allargs, env);
  return;
}

static int
default_region_size_ok_for_hw_watchpoint (int byte_count)
{
  return (byte_count <= TYPE_LENGTH (builtin_type_void_data_ptr));
}

static int
return_zero (void)
{
  return 0;
}

static int
return_one (void)
{
  return 1;
}

static int
return_minus_one (void)
{
  return -1;
}

/*
 * Resize the to_sections pointer.  Also make sure that anyone that
 * was holding on to an old value of it gets updated.
 * Returns the old size.
 */

int
target_resize_to_sections (struct target_ops *target, int num_added)
{
  struct target_ops **t;
  struct section_table *old_value;
  int old_count;

  old_value = target->to_sections;

  if (target->to_sections)
    {
      old_count = target->to_sections_end - target->to_sections;
      target->to_sections = (struct section_table *)
	xrealloc ((char *) target->to_sections,
		  (sizeof (struct section_table)) * (num_added + old_count));
    }
  else
    {
      old_count = 0;
      target->to_sections = (struct section_table *)
	xmalloc ((sizeof (struct section_table)) * num_added);
    }
  target->to_sections_end = target->to_sections + (num_added + old_count);

  /* Check to see if anyone else was pointing to this structure.
     If old_value was null, then no one was. */
     
  if (old_value)
    {
      for (t = target_structs; t < target_structs + target_struct_size;
	   ++t)
	{
	  if ((*t)->to_sections == old_value)
	    {
	      (*t)->to_sections = target->to_sections;
	      (*t)->to_sections_end = target->to_sections_end;
	    }
	}
    }
  
  return old_count;

}

/* Remove all target sections taken from ABFD.

   Scan the current target stack for targets whose section tables
   refer to sections from BFD, and remove those sections.  We use this
   when we notice that the inferior has unloaded a shared object, for
   example.  */
void
remove_target_sections (bfd *abfd)
{
  struct target_ops **t;

  for (t = target_structs; t < target_structs + target_struct_size; t++)
    {
      struct section_table *src, *dest;

      dest = (*t)->to_sections;
      for (src = (*t)->to_sections; src < (*t)->to_sections_end; src++)
	if (src->bfd != abfd)
	  {
	    /* Keep this section.  */
	    if (dest < src) *dest = *src;
	    dest++;
	  }

      /* If we've dropped any sections, resize the section table.  */
      if (dest < src)
	target_resize_to_sections (*t, dest - src);
    }
}




/* Find a single runnable target in the stack and return it.  If for
   some reason there is more than one, return NULL.  */

struct target_ops *
find_run_target (void)
{
  struct target_ops **t;
  struct target_ops *runable = NULL;
  int count;

  count = 0;

  for (t = target_structs; t < target_structs + target_struct_size; ++t)
    {
      if ((*t)->to_can_run && target_can_run (*t))
	{
	  runable = *t;
	  ++count;
	}
    }

  return (count == 1 ? runable : NULL);
}

/* Find a single core_stratum target in the list of targets and return it.
   If for some reason there is more than one, return NULL.  */

struct target_ops *
find_core_target (void)
{
  struct target_ops **t;
  struct target_ops *runable = NULL;
  int count;

  count = 0;

  for (t = target_structs; t < target_structs + target_struct_size;
       ++t)
    {
      if ((*t)->to_stratum == core_stratum)
	{
	  runable = *t;
	  ++count;
	}
    }

  return (count == 1 ? runable : NULL);
}

/*
 * Find the next target down the stack from the specified target.
 */

struct target_ops *
find_target_beneath (struct target_ops *t)
{
  return t->beneath;
}


/* The inferior process has died.  Long live the inferior!  */

void
generic_mourn_inferior (void)
{
  extern int show_breakpoint_hit_counts;

  inferior_ptid = null_ptid;
  attach_flag = 0;
  breakpoint_init_inferior (inf_exited);
  registers_changed ();

#ifdef CLEAR_DEFERRED_STORES
  /* Delete any pending stores to the inferior... */
  CLEAR_DEFERRED_STORES;
#endif

  reopen_exec_file ();
  reinit_frame_cache ();

  /* It is confusing to the user for ignore counts to stick around
     from previous runs of the inferior.  So clear them.  */
  /* However, it is more confusing for the ignore counts to disappear when
     using hit counts.  So don't clear them if we're counting hits.  */
  if (!show_breakpoint_hit_counts)
    breakpoint_clear_ignore_counts ();

  if (detach_hook)
    detach_hook ();
}

/* Helper function for child_wait and the Lynx derivatives of child_wait.
   HOSTSTATUS is the waitstatus from wait() or the equivalent; store our
   translation of that in OURSTATUS.  */
void
store_waitstatus (struct target_waitstatus *ourstatus, int hoststatus)
{
#ifdef CHILD_SPECIAL_WAITSTATUS
  /* CHILD_SPECIAL_WAITSTATUS should return nonzero and set *OURSTATUS
     if it wants to deal with hoststatus.  */
  if (CHILD_SPECIAL_WAITSTATUS (ourstatus, hoststatus))
    return;
#endif

  if (WIFEXITED (hoststatus))
    {
      ourstatus->kind = TARGET_WAITKIND_EXITED;
      ourstatus->value.integer = WEXITSTATUS (hoststatus);
    }
  else if (!WIFSTOPPED (hoststatus))
    {
      ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
      ourstatus->value.sig = target_signal_from_host (WTERMSIG (hoststatus));
    }
  else
    {
      ourstatus->kind = TARGET_WAITKIND_STOPPED;
      ourstatus->value.sig = target_signal_from_host (WSTOPSIG (hoststatus));
    }
}

/* Returns zero to leave the inferior alone, one to interrupt it.  */
int (*target_activity_function) (void);
int target_activity_fd;

/* Convert a normal process ID to a string.  Returns the string in a static
   buffer.  */

char *
normal_pid_to_str (ptid_t ptid)
{
  static char buf[30];

  sprintf (buf, "process %d", PIDGET (ptid));
  return buf;
}

/* Error-catcher for target_find_memory_regions */
static int dummy_find_memory_regions (int (*ignore1) (), void *ignore2)
{
  error ("No target.");
  return 0;
}

/* Error-catcher for target_make_corefile_notes */
static char * dummy_make_corefile_notes (bfd *ignore1, int *ignore2)
{
  error ("No target.");
  return NULL;
}

/* Set up the handful of non-empty slots needed by the dummy target
   vector.  */

static void
init_dummy_target (void)
{
  dummy_target.to_shortname = "None";
  dummy_target.to_longname = "None";
  dummy_target.to_doc = "";
  dummy_target.to_attach = find_default_attach;
  dummy_target.to_create_inferior = find_default_create_inferior;
  dummy_target.to_pid_to_str = normal_pid_to_str;
  dummy_target.to_stratum = dummy_stratum;
  dummy_target.to_find_memory_regions = dummy_find_memory_regions;
  dummy_target.to_make_corefile_notes = dummy_make_corefile_notes;
  dummy_target.to_xfer_partial = default_xfer_partial;
  dummy_target.to_magic = OPS_MAGIC;
}


static struct target_ops debug_target;

static void
debug_to_open (char *args, int from_tty)
{
  debug_target.to_open (args, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_open (%s, %d)\n", args, from_tty);
}

static void
debug_to_close (int quitting)
{
  target_close (&debug_target, quitting);
  fprintf_unfiltered (gdb_stdlog, "target_close (%d)\n", quitting);
}

void
target_close (struct target_ops *targ, int quitting)
{
  if (targ->to_xclose != NULL)
    targ->to_xclose (targ, quitting);
  else if (targ->to_close != NULL)
    targ->to_close (quitting);
}

static void
debug_to_attach (char *args, int from_tty)
{
  debug_target.to_attach (args, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_attach (%s, %d)\n", args, from_tty);
}


static void
debug_to_post_attach (int pid)
{
  debug_target.to_post_attach (pid);

  fprintf_unfiltered (gdb_stdlog, "target_post_attach (%d)\n", pid);
}

static void
debug_to_detach (char *args, int from_tty)
{
  debug_target.to_detach (args, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_detach (%s, %d)\n", args, from_tty);
}

static void
debug_to_disconnect (char *args, int from_tty)
{
  debug_target.to_disconnect (args, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_disconnect (%s, %d)\n",
		      args, from_tty);
}

static void
debug_to_resume (ptid_t ptid, int step, enum target_signal siggnal)
{
  debug_target.to_resume (ptid, step, siggnal);

  fprintf_unfiltered (gdb_stdlog, "target_resume (%d, %s, %s)\n", PIDGET (ptid),
		      step ? "step" : "continue",
		      target_signal_to_name (siggnal));
}

static ptid_t
debug_to_wait (ptid_t ptid, struct target_waitstatus *status)
{
  ptid_t retval;

  retval = debug_target.to_wait (ptid, status);

  fprintf_unfiltered (gdb_stdlog,
		      "target_wait (%d, status) = %d,   ", PIDGET (ptid),
		      PIDGET (retval));
  fprintf_unfiltered (gdb_stdlog, "status->kind = ");
  switch (status->kind)
    {
    case TARGET_WAITKIND_EXITED:
      fprintf_unfiltered (gdb_stdlog, "exited, status = %d\n",
			  status->value.integer);
      break;
    case TARGET_WAITKIND_STOPPED:
      fprintf_unfiltered (gdb_stdlog, "stopped, signal = %s\n",
			  target_signal_to_name (status->value.sig));
      break;
    case TARGET_WAITKIND_SIGNALLED:
      fprintf_unfiltered (gdb_stdlog, "signalled, signal = %s\n",
			  target_signal_to_name (status->value.sig));
      break;
    case TARGET_WAITKIND_LOADED:
      fprintf_unfiltered (gdb_stdlog, "loaded\n");
      break;
    case TARGET_WAITKIND_FORKED:
      fprintf_unfiltered (gdb_stdlog, "forked\n");
      break;
    case TARGET_WAITKIND_VFORKED:
      fprintf_unfiltered (gdb_stdlog, "vforked\n");
      break;
    case TARGET_WAITKIND_EXECD:
      fprintf_unfiltered (gdb_stdlog, "execd\n");
      break;
    case TARGET_WAITKIND_SPURIOUS:
      fprintf_unfiltered (gdb_stdlog, "spurious\n");
      break;
    default:
      fprintf_unfiltered (gdb_stdlog, "unknown???\n");
      break;
    }

  return retval;
}

static void
debug_to_post_wait (ptid_t ptid, int status)
{
  debug_target.to_post_wait (ptid, status);

  fprintf_unfiltered (gdb_stdlog, "target_post_wait (%d, %d)\n",
		      PIDGET (ptid), status);
}

static void
debug_print_register (const char * func, int regno)
{
  fprintf_unfiltered (gdb_stdlog, "%s ", func);
  if (regno >= 0 && regno < NUM_REGS + NUM_PSEUDO_REGS
      && REGISTER_NAME (regno) != NULL && REGISTER_NAME (regno)[0] != '\0')
    fprintf_unfiltered (gdb_stdlog, "(%s)", REGISTER_NAME (regno));
  else
    fprintf_unfiltered (gdb_stdlog, "(%d)", regno);
  if (regno >= 0)
    {
      int i;
      unsigned char buf[MAX_REGISTER_SIZE];
      deprecated_read_register_gen (regno, buf);
      fprintf_unfiltered (gdb_stdlog, " = ");
      for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i++)
	{
	  fprintf_unfiltered (gdb_stdlog, "%02x", buf[i]);
	}
      if (DEPRECATED_REGISTER_RAW_SIZE (regno) <= sizeof (LONGEST))
	{
	  fprintf_unfiltered (gdb_stdlog, " 0x%s %s",
			      paddr_nz (read_register (regno)),
			      paddr_d (read_register (regno)));
	}
    }
  fprintf_unfiltered (gdb_stdlog, "\n");
}

static void
debug_to_fetch_registers (int regno)
{
  debug_target.to_fetch_registers (regno);
  debug_print_register ("target_fetch_registers", regno);
}

static void
debug_to_store_registers (int regno)
{
  debug_target.to_store_registers (regno);
  debug_print_register ("target_store_registers", regno);
  fprintf_unfiltered (gdb_stdlog, "\n");
}

static void
debug_to_prepare_to_store (void)
{
  debug_target.to_prepare_to_store ();

  fprintf_unfiltered (gdb_stdlog, "target_prepare_to_store ()\n");
}

static int
debug_to_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		      struct mem_attrib *attrib,
		      struct target_ops *target)
{
  int retval;

  retval = debug_target.to_xfer_memory (memaddr, myaddr, len, write,
					attrib, target);

  fprintf_unfiltered (gdb_stdlog,
		      "target_xfer_memory (0x%x, xxx, %d, %s, xxx) = %d",
		      (unsigned int) memaddr,	/* possable truncate long long */
		      len, write ? "write" : "read", retval);



  if (retval > 0)
    {
      int i;

      fputs_unfiltered (", bytes =", gdb_stdlog);
      for (i = 0; i < retval; i++)
	{
	  if ((((long) &(myaddr[i])) & 0xf) == 0)
	    fprintf_unfiltered (gdb_stdlog, "\n");
	  fprintf_unfiltered (gdb_stdlog, " %02x", myaddr[i] & 0xff);
	}
    }

  fputc_unfiltered ('\n', gdb_stdlog);

  return retval;
}

static void
debug_to_files_info (struct target_ops *target)
{
  debug_target.to_files_info (target);

  fprintf_unfiltered (gdb_stdlog, "target_files_info (xxx)\n");
}

static int
debug_to_insert_breakpoint (CORE_ADDR addr, char *save)
{
  int retval;

  retval = debug_target.to_insert_breakpoint (addr, save);

  fprintf_unfiltered (gdb_stdlog,
		      "target_insert_breakpoint (0x%lx, xxx) = %ld\n",
		      (unsigned long) addr,
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_remove_breakpoint (CORE_ADDR addr, char *save)
{
  int retval;

  retval = debug_target.to_remove_breakpoint (addr, save);

  fprintf_unfiltered (gdb_stdlog,
		      "target_remove_breakpoint (0x%lx, xxx) = %ld\n",
		      (unsigned long) addr,
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_can_use_hw_breakpoint (int type, int cnt, int from_tty)
{
  int retval;

  retval = debug_target.to_can_use_hw_breakpoint (type, cnt, from_tty);

  fprintf_unfiltered (gdb_stdlog,
		      "target_can_use_hw_breakpoint (%ld, %ld, %ld) = %ld\n",
		      (unsigned long) type,
		      (unsigned long) cnt,
		      (unsigned long) from_tty,
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_region_size_ok_for_hw_watchpoint (int byte_count)
{
  CORE_ADDR retval;

  retval = debug_target.to_region_size_ok_for_hw_watchpoint (byte_count);

  fprintf_unfiltered (gdb_stdlog,
		      "TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT (%ld) = 0x%lx\n",
		      (unsigned long) byte_count,
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_stopped_by_watchpoint (void)
{
  int retval;

  retval = debug_target.to_stopped_by_watchpoint ();

  fprintf_unfiltered (gdb_stdlog,
		      "STOPPED_BY_WATCHPOINT () = %ld\n",
		      (unsigned long) retval);
  return retval;
}

static CORE_ADDR
debug_to_stopped_data_address (void)
{
  CORE_ADDR retval;

  retval = debug_target.to_stopped_data_address ();

  fprintf_unfiltered (gdb_stdlog,
		      "target_stopped_data_address () = 0x%lx\n",
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_insert_hw_breakpoint (CORE_ADDR addr, char *save)
{
  int retval;

  retval = debug_target.to_insert_hw_breakpoint (addr, save);

  fprintf_unfiltered (gdb_stdlog,
		      "target_insert_hw_breakpoint (0x%lx, xxx) = %ld\n",
		      (unsigned long) addr,
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_remove_hw_breakpoint (CORE_ADDR addr, char *save)
{
  int retval;

  retval = debug_target.to_remove_hw_breakpoint (addr, save);

  fprintf_unfiltered (gdb_stdlog,
		      "target_remove_hw_breakpoint (0x%lx, xxx) = %ld\n",
		      (unsigned long) addr,
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_insert_watchpoint (CORE_ADDR addr, int len, int type)
{
  int retval;

  retval = debug_target.to_insert_watchpoint (addr, len, type);

  fprintf_unfiltered (gdb_stdlog,
		      "target_insert_watchpoint (0x%lx, %d, %d) = %ld\n",
		      (unsigned long) addr, len, type, (unsigned long) retval);
  return retval;
}

static int
debug_to_remove_watchpoint (CORE_ADDR addr, int len, int type)
{
  int retval;

  retval = debug_target.to_insert_watchpoint (addr, len, type);

  fprintf_unfiltered (gdb_stdlog,
		      "target_insert_watchpoint (0x%lx, %d, %d) = %ld\n",
		      (unsigned long) addr, len, type, (unsigned long) retval);
  return retval;
}

static void
debug_to_terminal_init (void)
{
  debug_target.to_terminal_init ();

  fprintf_unfiltered (gdb_stdlog, "target_terminal_init ()\n");
}

static void
debug_to_terminal_inferior (void)
{
  debug_target.to_terminal_inferior ();

  fprintf_unfiltered (gdb_stdlog, "target_terminal_inferior ()\n");
}

static void
debug_to_terminal_ours_for_output (void)
{
  debug_target.to_terminal_ours_for_output ();

  fprintf_unfiltered (gdb_stdlog, "target_terminal_ours_for_output ()\n");
}

static void
debug_to_terminal_ours (void)
{
  debug_target.to_terminal_ours ();

  fprintf_unfiltered (gdb_stdlog, "target_terminal_ours ()\n");
}

static void
debug_to_terminal_save_ours (void)
{
  debug_target.to_terminal_save_ours ();

  fprintf_unfiltered (gdb_stdlog, "target_terminal_save_ours ()\n");
}

static void
debug_to_terminal_info (char *arg, int from_tty)
{
  debug_target.to_terminal_info (arg, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_terminal_info (%s, %d)\n", arg,
		      from_tty);
}

static void
debug_to_kill (void)
{
  debug_target.to_kill ();

  fprintf_unfiltered (gdb_stdlog, "target_kill ()\n");
}

static void
debug_to_load (char *args, int from_tty)
{
  debug_target.to_load (args, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_load (%s, %d)\n", args, from_tty);
}

static int
debug_to_lookup_symbol (char *name, CORE_ADDR *addrp)
{
  int retval;

  retval = debug_target.to_lookup_symbol (name, addrp);

  fprintf_unfiltered (gdb_stdlog, "target_lookup_symbol (%s, xxx)\n", name);

  return retval;
}

static void
debug_to_create_inferior (char *exec_file, char *args, char **env)
{
  debug_target.to_create_inferior (exec_file, args, env);

  fprintf_unfiltered (gdb_stdlog, "target_create_inferior (%s, %s, xxx)\n",
		      exec_file, args);
}

static void
debug_to_post_startup_inferior (ptid_t ptid)
{
  debug_target.to_post_startup_inferior (ptid);

  fprintf_unfiltered (gdb_stdlog, "target_post_startup_inferior (%d)\n",
		      PIDGET (ptid));
}

static void
debug_to_acknowledge_created_inferior (int pid)
{
  debug_target.to_acknowledge_created_inferior (pid);

  fprintf_unfiltered (gdb_stdlog, "target_acknowledge_created_inferior (%d)\n",
		      pid);
}

static int
debug_to_insert_fork_catchpoint (int pid)
{
  int retval;

  retval = debug_target.to_insert_fork_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_insert_fork_catchpoint (%d) = %d\n",
		      pid, retval);

  return retval;
}

static int
debug_to_remove_fork_catchpoint (int pid)
{
  int retval;

  retval = debug_target.to_remove_fork_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_remove_fork_catchpoint (%d) = %d\n",
		      pid, retval);

  return retval;
}

static int
debug_to_insert_vfork_catchpoint (int pid)
{
  int retval;

  retval = debug_target.to_insert_vfork_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_insert_vfork_catchpoint (%d)= %d\n",
		      pid, retval);

  return retval;
}

static int
debug_to_remove_vfork_catchpoint (int pid)
{
  int retval;

  retval = debug_target.to_remove_vfork_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_remove_vfork_catchpoint (%d) = %d\n",
		      pid, retval);

  return retval;
}

static int
debug_to_follow_fork (int follow_child)
{
  int retval =  debug_target.to_follow_fork (follow_child);

  fprintf_unfiltered (gdb_stdlog, "target_follow_fork (%d) = %d\n",
		      follow_child, retval);

  return retval;
}

static int
debug_to_insert_exec_catchpoint (int pid)
{
  int retval;

  retval = debug_target.to_insert_exec_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_insert_exec_catchpoint (%d) = %d\n",
		      pid, retval);

  return retval;
}

static int
debug_to_remove_exec_catchpoint (int pid)
{
  int retval;

  retval = debug_target.to_remove_exec_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_remove_exec_catchpoint (%d) = %d\n",
		      pid, retval);

  return retval;
}

static int
debug_to_reported_exec_events_per_exec_call (void)
{
  int reported_exec_events;

  reported_exec_events = debug_target.to_reported_exec_events_per_exec_call ();

  fprintf_unfiltered (gdb_stdlog,
		      "target_reported_exec_events_per_exec_call () = %d\n",
		      reported_exec_events);

  return reported_exec_events;
}

static int
debug_to_has_exited (int pid, int wait_status, int *exit_status)
{
  int has_exited;

  has_exited = debug_target.to_has_exited (pid, wait_status, exit_status);

  fprintf_unfiltered (gdb_stdlog, "target_has_exited (%d, %d, %d) = %d\n",
		      pid, wait_status, *exit_status, has_exited);

  return has_exited;
}

static void
debug_to_mourn_inferior (void)
{
  debug_target.to_mourn_inferior ();

  fprintf_unfiltered (gdb_stdlog, "target_mourn_inferior ()\n");
}

static int
debug_to_can_run (void)
{
  int retval;

  retval = debug_target.to_can_run ();

  fprintf_unfiltered (gdb_stdlog, "target_can_run () = %d\n", retval);

  return retval;
}

static void
debug_to_notice_signals (ptid_t ptid)
{
  debug_target.to_notice_signals (ptid);

  fprintf_unfiltered (gdb_stdlog, "target_notice_signals (%d)\n",
                      PIDGET (ptid));
}

static int
debug_to_thread_alive (ptid_t ptid)
{
  int retval;

  retval = debug_target.to_thread_alive (ptid);

  fprintf_unfiltered (gdb_stdlog, "target_thread_alive (%d) = %d\n",
		      PIDGET (ptid), retval);

  return retval;
}

static void
debug_to_find_new_threads (void)
{
  debug_target.to_find_new_threads ();

  fputs_unfiltered ("target_find_new_threads ()\n", gdb_stdlog);
}

static void
debug_to_stop (void)
{
  debug_target.to_stop ();

  fprintf_unfiltered (gdb_stdlog, "target_stop ()\n");
}

static LONGEST
debug_to_xfer_partial (struct target_ops *ops, enum target_object object,
		       const char *annex, void *readbuf, const void *writebuf,
		       ULONGEST offset, LONGEST len)
{
  LONGEST retval;

  retval = debug_target.to_xfer_partial (&debug_target, object, annex,
					 readbuf, writebuf, offset, len);

  fprintf_unfiltered (gdb_stdlog,
		      "target_xfer_partial (%d, %s, 0x%lx,  0x%lx,  0x%s, %s) = %s\n",
		      (int) object, (annex ? annex : "(null)"),
		      (long) readbuf, (long) writebuf, paddr_nz (offset),
		      paddr_d (len), paddr_d (retval));

  return retval;
}

static void
debug_to_rcmd (char *command,
	       struct ui_file *outbuf)
{
  debug_target.to_rcmd (command, outbuf);
  fprintf_unfiltered (gdb_stdlog, "target_rcmd (%s, ...)\n", command);
}

static struct symtab_and_line *
debug_to_enable_exception_callback (enum exception_event_kind kind, int enable)
{
  struct symtab_and_line *result;
  result = debug_target.to_enable_exception_callback (kind, enable);
  fprintf_unfiltered (gdb_stdlog,
		      "target get_exception_callback_sal (%d, %d)\n",
		      kind, enable);
  return result;
}

static struct exception_event_record *
debug_to_get_current_exception_event (void)
{
  struct exception_event_record *result;
  result = debug_target.to_get_current_exception_event ();
  fprintf_unfiltered (gdb_stdlog, "target get_current_exception_event ()\n");
  return result;
}

static char *
debug_to_pid_to_exec_file (int pid)
{
  char *exec_file;

  exec_file = debug_target.to_pid_to_exec_file (pid);

  fprintf_unfiltered (gdb_stdlog, "target_pid_to_exec_file (%d) = %s\n",
		      pid, exec_file);

  return exec_file;
}

static void
setup_target_debug (void)
{
  memcpy (&debug_target, &current_target, sizeof debug_target);

  current_target.to_open = debug_to_open;
  current_target.to_close = debug_to_close;
  current_target.to_attach = debug_to_attach;
  current_target.to_post_attach = debug_to_post_attach;
  current_target.to_detach = debug_to_detach;
  current_target.to_disconnect = debug_to_disconnect;
  current_target.to_resume = debug_to_resume;
  current_target.to_wait = debug_to_wait;
  current_target.to_post_wait = debug_to_post_wait;
  current_target.to_fetch_registers = debug_to_fetch_registers;
  current_target.to_store_registers = debug_to_store_registers;
  current_target.to_prepare_to_store = debug_to_prepare_to_store;
  current_target.to_xfer_memory = debug_to_xfer_memory;
  current_target.to_files_info = debug_to_files_info;
  current_target.to_insert_breakpoint = debug_to_insert_breakpoint;
  current_target.to_remove_breakpoint = debug_to_remove_breakpoint;
  current_target.to_can_use_hw_breakpoint = debug_to_can_use_hw_breakpoint;
  current_target.to_insert_hw_breakpoint = debug_to_insert_hw_breakpoint;
  current_target.to_remove_hw_breakpoint = debug_to_remove_hw_breakpoint;
  current_target.to_insert_watchpoint = debug_to_insert_watchpoint;
  current_target.to_remove_watchpoint = debug_to_remove_watchpoint;
  current_target.to_stopped_by_watchpoint = debug_to_stopped_by_watchpoint;
  current_target.to_stopped_data_address = debug_to_stopped_data_address;
  current_target.to_region_size_ok_for_hw_watchpoint = debug_to_region_size_ok_for_hw_watchpoint;
  current_target.to_terminal_init = debug_to_terminal_init;
  current_target.to_terminal_inferior = debug_to_terminal_inferior;
  current_target.to_terminal_ours_for_output = debug_to_terminal_ours_for_output;
  current_target.to_terminal_ours = debug_to_terminal_ours;
  current_target.to_terminal_save_ours = debug_to_terminal_save_ours;
  current_target.to_terminal_info = debug_to_terminal_info;
  current_target.to_kill = debug_to_kill;
  current_target.to_load = debug_to_load;
  current_target.to_lookup_symbol = debug_to_lookup_symbol;
  current_target.to_create_inferior = debug_to_create_inferior;
  current_target.to_post_startup_inferior = debug_to_post_startup_inferior;
  current_target.to_acknowledge_created_inferior = debug_to_acknowledge_created_inferior;
  current_target.to_insert_fork_catchpoint = debug_to_insert_fork_catchpoint;
  current_target.to_remove_fork_catchpoint = debug_to_remove_fork_catchpoint;
  current_target.to_insert_vfork_catchpoint = debug_to_insert_vfork_catchpoint;
  current_target.to_remove_vfork_catchpoint = debug_to_remove_vfork_catchpoint;
  current_target.to_follow_fork = debug_to_follow_fork;
  current_target.to_insert_exec_catchpoint = debug_to_insert_exec_catchpoint;
  current_target.to_remove_exec_catchpoint = debug_to_remove_exec_catchpoint;
  current_target.to_reported_exec_events_per_exec_call = debug_to_reported_exec_events_per_exec_call;
  current_target.to_has_exited = debug_to_has_exited;
  current_target.to_mourn_inferior = debug_to_mourn_inferior;
  current_target.to_can_run = debug_to_can_run;
  current_target.to_notice_signals = debug_to_notice_signals;
  current_target.to_thread_alive = debug_to_thread_alive;
  current_target.to_find_new_threads = debug_to_find_new_threads;
  current_target.to_stop = debug_to_stop;
  current_target.to_xfer_partial = debug_to_xfer_partial;
  current_target.to_rcmd = debug_to_rcmd;
  current_target.to_enable_exception_callback = debug_to_enable_exception_callback;
  current_target.to_get_current_exception_event = debug_to_get_current_exception_event;
  current_target.to_pid_to_exec_file = debug_to_pid_to_exec_file;

}


static char targ_desc[] =
"Names of targets and files being debugged.\n\
Shows the entire stack of targets currently in use (including the exec-file,\n\
core-file, and process, if any), as well as the symbol file name.";

static void
do_monitor_command (char *cmd,
		 int from_tty)
{
  if ((current_target.to_rcmd
       == (void (*) (char *, struct ui_file *)) tcomplain)
      || (current_target.to_rcmd == debug_to_rcmd
	  && (debug_target.to_rcmd
	      == (void (*) (char *, struct ui_file *)) tcomplain)))
    {
      error ("\"monitor\" command not supported by this target.\n");
    }
  target_rcmd (cmd, gdb_stdtarg);
}

void
initialize_targets (void)
{
  init_dummy_target ();
  push_target (&dummy_target);

  add_info ("target", target_info, targ_desc);
  add_info ("files", target_info, targ_desc);

  add_show_from_set 
    (add_set_cmd ("target", class_maintenance, var_zinteger,
		  (char *) &targetdebug,
		  "Set target debugging.\n\
When non-zero, target debugging is enabled.", &setdebuglist),
     &showdebuglist);

  add_setshow_boolean_cmd ("trust-readonly-sections", class_support, 
			   &trust_readonly, "\
Set mode for reading from readonly sections.\n\
When this mode is on, memory reads from readonly sections (such as .text)\n\
will be read from the object file instead of from the target.  This will\n\
result in significant performance improvement for remote targets.", "\
Show mode for reading from readonly sections.\n",
			   NULL, NULL,
			   &setlist, &showlist);

  add_com ("monitor", class_obscure, do_monitor_command,
	   "Send a command to the remote monitor (remote targets only).");

  target_dcache = dcache_init ();
}
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d44 2
a90 2
static struct target_ops debug_target;

d111 2
a112 3
static int deprecated_debug_xfer_memory (CORE_ADDR, char *, int, int,
					 struct mem_attrib *,
					 struct target_ops *);
d132 1
a132 1
static int debug_to_stopped_data_address (struct target_ops *, CORE_ADDR *);
d154 2
a165 6
/* NOTE: cagney/2004-09-29: Many targets reference this variable in
   wierd and mysterious ways.  Putting the variable here lets those
   wierd and mysterious ways keep building while they are being
   converted to the inferior inheritance structure.  */
struct target_ops deprecated_child_ops;

d342 1
a342 2
maybe_kill_then_create_inferior (char *exec, char *args, char **env,
				 int from_tty)
d345 1
a345 1
  target_create_inferior (exec, args, env, from_tty);
d385 1
d389 1
a389 1
      INHERIT (deprecated_xfer_memory, t);
d487 3
d499 1
a499 1
  de_fault (deprecated_xfer_memory, 
d528 1
a528 1
	    (int (*) (struct target_ops *, CORE_ADDR *))
d785 1
a785 1
      errcode = target_read_memory (memaddr & ~3, buf, 4);
d793 1
a793 1
	  errcode = target_read_memory (memaddr, buf, 1);
a843 141
/* Return non-zero when the target vector has supplied an xfer_partial
   method and it, rather than xfer_memory, should be used.  */
static int
target_xfer_partial_p (void)
{
  return (target_stack != NULL
	  && target_stack->to_xfer_partial != default_xfer_partial);
}

static LONGEST
target_xfer_partial (struct target_ops *ops,
		     enum target_object object, const char *annex,
		     void *readbuf, const void *writebuf,
		     ULONGEST offset, LONGEST len)
{
  LONGEST retval;

  gdb_assert (ops->to_xfer_partial != NULL);
  retval = ops->to_xfer_partial (ops, object, annex, readbuf, writebuf,
				 offset, len);
  if (targetdebug)
    {
      const unsigned char *myaddr = NULL;

      fprintf_unfiltered (gdb_stdlog,
			  "%s:target_xfer_partial (%d, %s, 0x%lx,  0x%lx,  0x%s, %s) = %s",
			  ops->to_shortname,
			  (int) object,
			  (annex ? annex : "(null)"),
			  (long) readbuf, (long) writebuf,
			  paddr_nz (offset), paddr_d (len), paddr_d (retval));

      if (readbuf)
	myaddr = readbuf;
      if (writebuf)
	myaddr = writebuf;
      if (retval > 0 && myaddr != NULL)
	{
	  int i;
	  
	  fputs_unfiltered (", bytes =", gdb_stdlog);
	  for (i = 0; i < retval; i++)
	    {
	      if ((((long) &(myaddr[i])) & 0xf) == 0)
		{
		  if (targetdebug < 2 && i > 0)
		    {
		      fprintf_unfiltered (gdb_stdlog, " ...");
		      break;
		    }
		  fprintf_unfiltered (gdb_stdlog, "\n");
		}
	      
	      fprintf_unfiltered (gdb_stdlog, " %02x", myaddr[i] & 0xff);
	    }
	}
      
      fputc_unfiltered ('\n', gdb_stdlog);
    }
  return retval;
}

/* Attempt a transfer all LEN bytes starting at OFFSET between the
   inferior's KIND:ANNEX space and GDB's READBUF/WRITEBUF buffer.  If
   the transfer succeeds, return zero, otherwize the host ERRNO is
   returned.

   The inferior is formed from several layers.  In the case of
   corefiles, inf-corefile is layered above inf-exec and a request for
   text (corefiles do not include text pages) will be first sent to
   the core-stratum, fail, and then sent to the object-file where it
   will succeed.

   NOTE: cagney/2004-09-30:

   The old code tried to use four separate mechanisms for mapping an
   object:offset:len tuple onto an inferior and its address space: the
   target stack; the inferior's TO_SECTIONS; solib's SO_LIST;
   overlays.

   This is stupid.

   The code below is instead using a single mechanism (currently
   strata).  If that mechanism proves insufficient then re-factor it
   implementing another singluar mechanism (for instance, a generic
   object:annex onto inferior:object:annex say).  */

static LONGEST
xfer_using_stratum (enum target_object object, const char *annex,
		    ULONGEST offset, LONGEST len, void *readbuf,
		    const void *writebuf)
{
  LONGEST xfered;
  struct target_ops *target;

  /* Always successful.  */
  if (len == 0)
    return 0;
  /* Never successful.  */
  if (target_stack == NULL)
    return EIO;

  target = target_stack;
  while (1)
    {
      xfered = target_xfer_partial (target, object, annex,
				    readbuf, writebuf, offset, len);
      if (xfered > 0)
	{
	  /* The partial xfer succeeded, update the counts, check that
	     the xfer hasn't finished and if it hasn't set things up
	     for the next round.  */
	  len -= xfered;
	  if (len <= 0)
	    return 0;
	  offset += xfered;
	  if (readbuf != NULL)
	    readbuf = (bfd_byte *) readbuf + xfered;
	  if (writebuf != NULL)
	    writebuf = (bfd_byte *) writebuf + xfered;
	  target = target_stack;
	}
      else if (xfered < 0)
	{
	  /* Something totally screwed up, abandon the attempt to
	     xfer.  */
	  if (errno)
	    return errno;
	  else
	    return EIO;
	}
      else
	{
	  /* This "stratum" didn't work, try the next one down.  */
	  target = target->beneath;
	  if (target == NULL)
	    return EIO;
	}
    }
}

d857 1
a857 5
  if (target_xfer_partial_p ())
    return xfer_using_stratum (TARGET_OBJECT_MEMORY, NULL,
			       memaddr, len, myaddr, NULL);
  else
    return target_xfer_memory (memaddr, myaddr, len, 0);
d863 1
a863 19
  if (target_xfer_partial_p ())
    return xfer_using_stratum (TARGET_OBJECT_MEMORY, NULL,
			       memaddr, len, NULL, myaddr);
  else
    return target_xfer_memory (memaddr, myaddr, len, 1);
}

#ifndef target_stopped_data_address_p
int
target_stopped_data_address_p (struct target_ops *target)
{
  if (target->to_stopped_data_address
      == (int (*) (struct target_ops *, CORE_ADDR *)) return_zero)
    return 0;
  if (target->to_stopped_data_address == debug_to_stopped_data_address
      && (debug_target.to_stopped_data_address
	  == (int (*) (struct target_ops *, CORE_ADDR *)) return_zero))
    return 0;
  return 1;
a864 1
#endif
d885 2
a886 2
  /* deprecated_xfer_memory is not guaranteed to set errno, even when
     it returns 0.  */
d903 1
a903 1
  res = current_target.deprecated_xfer_memory
d914 1
a914 1
	  res = t->deprecated_xfer_memory (memaddr, myaddr, len, write, attrib, t);
d1069 1
a1069 5
  if (target_xfer_partial_p ())
    return target_xfer_partial (target_stack, TARGET_OBJECT_MEMORY, NULL,
				buf, NULL, memaddr, len);
  else
    return target_xfer_memory_partial (memaddr, buf, len, 0, err);
d1075 1
a1075 5
  if (target_xfer_partial_p ())
    return target_xfer_partial (target_stack, TARGET_OBJECT_MEMORY, NULL,
				NULL, buf, memaddr, len);
  else
    return target_xfer_memory_partial (memaddr, buf, len, 1, err);
d1086 3
a1088 3
      && ops->deprecated_xfer_memory != NULL)
    /* If available, fall back to the target's
       "deprecated_xfer_memory" method.  */
d1097 2
a1098 2
	  xfered = ops->deprecated_xfer_memory (offset, buffer, len,
						1/*write*/, NULL, ops);
d1102 2
a1103 2
	xfered = ops->deprecated_xfer_memory (offset, readbuf, len, 0/*read*/,
					      NULL, ops);
d1107 2
a1108 2
	/* "deprecated_xfer_memory" uses 0, cross checked against
           ERRNO as one indication of an error.  */
d1114 2
a1115 2
    return target_xfer_partial (ops->beneath, object, annex,
				readbuf, writebuf, offset, len);
d1132 2
a1133 1
  return target_xfer_partial (ops, object, annex, buf, NULL, offset, len);
d1142 2
a1143 1
  return target_xfer_partial (ops, object, annex, NULL, buf, offset, len);
d1222 5
d1271 4
d1281 4
d1351 1
a1351 2
find_default_create_inferior (char *exec_file, char *allargs, char **env,
			      int from_tty)
d1356 1
a1356 1
  (t->to_create_inferior) (exec_file, allargs, env, from_tty);
a1427 7
      /* There is a flattened view of the target stack in current_target,
	 so its to_sections pointer might also need updating. */
      if (current_target.to_sections == old_value)
	{
	  current_target.to_sections = target->to_sections;
	  current_target.to_sections_end = target->to_sections_end;
	}
d1539 5
d1554 2
a1555 2
  if (deprecated_detach_hook)
    deprecated_detach_hook ();
d1637 3
d1757 9
d1780 1
a1780 1
      for (i = 0; i < register_size (current_gdbarch, regno); i++)
d1784 1
a1784 1
      if (register_size (current_gdbarch, regno) <= sizeof (LONGEST))
d1818 3
a1820 3
deprecated_debug_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len,
			      int write, struct mem_attrib *attrib,
			      struct target_ops *target)
d1824 2
a1825 2
  retval = debug_target.deprecated_xfer_memory (memaddr, myaddr, len, write,
						attrib, target);
d1832 2
d1842 1
a1842 9
	    {
	      if (targetdebug < 2 && i > 0)
		{
		  fprintf_unfiltered (gdb_stdlog, " ...");
		  break;
		}
	      fprintf_unfiltered (gdb_stdlog, "\n");
	    }
	  
d1931 2
a1932 2
static int
debug_to_stopped_data_address (struct target_ops *target, CORE_ADDR *addr)
d1934 1
a1934 1
  int retval;
d1936 1
a1936 1
  retval = debug_target.to_stopped_data_address (target, addr);
d1939 2
a1940 3
		      "target_stopped_data_address ([0x%lx]) = %ld\n",
		      (unsigned long)*addr,
		      (unsigned long)retval);
d2076 1
a2076 2
debug_to_create_inferior (char *exec_file, char *args, char **env,
			  int from_tty)
d2078 1
a2078 1
  debug_target.to_create_inferior (exec_file, args, env, from_tty);
d2080 2
a2081 2
  fprintf_unfiltered (gdb_stdlog, "target_create_inferior (%s, %s, xxx, %d)\n",
		      exec_file, args, from_tty);
d2276 19
d2349 1
d2353 1
a2353 1
  current_target.deprecated_xfer_memory = deprecated_debug_xfer_memory;
d2392 1
d2430 1
a2430 1
  deprecated_add_show_from_set 
d2434 1
a2434 3
When non-zero, target debugging is enabled.  Higher numbers are more\n\
verbose.  Changes do not take effect until the next \"run\" or \"target\"\n\
command.", &setdebuglist),
d2439 1
a2439 2
Set mode for reading from readonly sections.", "\
Show mode for reading from readonly sections.", "\
d2443 1
a2443 1
Mode for reading from readonly sections is %s.",
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 2001
/* Select target systems and architectures at runtime for GDB.
   Copyright 1990, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
   Contributed by Cygnus Support.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include <errno.h>
#include <ctype.h>
#include "gdb_string.h"
#include "target.h"
#include "gdbcmd.h"
#include "symtab.h"
#include "inferior.h"
#include "bfd.h"
#include "symfile.h"
#include "objfiles.h"
#include "wait.h"
#include <signal.h>

extern int errno;

static void
target_info PARAMS ((char *, int));

static void
cleanup_target PARAMS ((struct target_ops *));

static void
maybe_kill_then_create_inferior PARAMS ((char *, char *, char **));

static void
maybe_kill_then_attach PARAMS ((char *, int));

static void
kill_or_be_killed PARAMS ((int));

static void
default_terminal_info PARAMS ((char *, int));

static int
nosymbol PARAMS ((char *, CORE_ADDR *));

static void
tcomplain PARAMS ((void));

static int
nomemory PARAMS ((CORE_ADDR, char *, int, int, struct target_ops *));

static int
return_zero PARAMS ((void));

static void
ignore PARAMS ((void));

static void
target_command PARAMS ((char *, int));

static struct target_ops *
find_default_run_target PARAMS ((char *));

static void
update_current_target PARAMS ((void));

static void
debug_to_open PARAMS ((char *, int));

static void
debug_to_close PARAMS ((int));

static void
debug_to_attach PARAMS ((char *, int));

static void
debug_to_detach PARAMS ((char *, int));

static void
debug_to_resume PARAMS ((int, int, enum target_signal));

static int
debug_to_wait PARAMS ((int, struct target_waitstatus *));

static void
debug_to_fetch_registers PARAMS ((int));

static void
debug_to_store_registers PARAMS ((int));

static void
debug_to_prepare_to_store PARAMS ((void));

static int
debug_to_xfer_memory PARAMS ((CORE_ADDR, char *, int, int, struct target_ops *));

static void
debug_to_files_info PARAMS ((struct target_ops *));

static int
debug_to_insert_breakpoint PARAMS ((CORE_ADDR, char *));

static int
debug_to_remove_breakpoint PARAMS ((CORE_ADDR, char *));

static void
debug_to_terminal_init PARAMS ((void));

static void
debug_to_terminal_inferior PARAMS ((void));

static void
debug_to_terminal_ours_for_output PARAMS ((void));

static void
debug_to_terminal_ours PARAMS ((void));

static void
debug_to_terminal_info PARAMS ((char *, int));

static void
debug_to_kill PARAMS ((void));

static void
debug_to_load PARAMS ((char *, int));

static int
debug_to_lookup_symbol PARAMS ((char *, CORE_ADDR *));

static void
debug_to_create_inferior PARAMS ((char *, char *, char **));

static void
debug_to_mourn_inferior PARAMS ((void));

static int
debug_to_can_run PARAMS ((void));

static void
debug_to_notice_signals PARAMS ((int));

static int
debug_to_thread_alive PARAMS ((int));

static void
debug_to_stop PARAMS ((void));

/* Pointer to array of target architecture structures; the size of the
   array; the current index into the array; the allocated size of the 
   array.  */
struct target_ops **target_structs;
unsigned target_struct_size;
unsigned target_struct_index;
unsigned target_struct_allocsize;
#define	DEFAULT_ALLOCSIZE	10

/* The initial current target, so that there is always a semi-valid
   current target.  */

struct target_ops dummy_target = {
  "None",			/* to_shortname */
  "None",			/* to_longname */
  "",				/* to_doc */
  0,				/* to_open */
  0,				/* to_close */
  find_default_attach,		/* to_attach */
  0,				/* to_detach */
  0,				/* to_resume */
  0,				/* to_wait */
  0,				/* to_fetch_registers */
  0,				/* to_store_registers */
  0,				/* to_prepare_to_store */
  0,				/* to_xfer_memory */
  0,				/* to_files_info */
  0,				/* to_insert_breakpoint */
  0,				/* to_remove_breakpoint */
  0,				/* to_terminal_init */
  0,				/* to_terminal_inferior */
  0,				/* to_terminal_ours_for_output */
  0,				/* to_terminal_ours */
  0,				/* to_terminal_info */
  0,				/* to_kill */
  0,				/* to_load */
  0,				/* to_lookup_symbol */
  find_default_create_inferior,	/* to_create_inferior */
  0,				/* to_mourn_inferior */
  0,				/* to_can_run */
  0,				/* to_notice_signals */
  0,				/* to_thread_alive */
  0,				/* to_stop */
  dummy_stratum,		/* to_stratum */
  0,				/* to_next */
  0,				/* to_next */
  0,				/* to_has_all_memory */
  0,				/* to_has_memory */
  0,				/* to_has_registers */
  0,				/* to_has_execution */
  0,				/* to_sections */
  0,				/* to_sections_end */
  OPS_MAGIC,			/* to_magic */
};

/* Top of target stack.  */

struct target_stack_item *target_stack;

/* The target structure we are currently using to talk to a process
   or file or whatever "inferior" we have.  */

struct target_ops current_target;

/* Command list for target.  */

static struct cmd_list_element *targetlist = NULL;

/* Nonzero if we are debugging an attached outside process
   rather than an inferior.  */

int attach_flag;

#ifdef MAINTENANCE_CMDS
/* Non-zero if we want to see trace of target level stuff.  */

static int targetdebug = 0;

static void setup_target_debug PARAMS ((void));

#endif

/* The user just typed 'target' without the name of a target.  */

/* ARGSUSED */
static void
target_command (arg, from_tty)
     char *arg;
     int from_tty;
{
  fputs_filtered ("Argument required (target name).  Try `help target'\n",
		  gdb_stdout);
}

/* Add a possible target architecture to the list.  */

void
add_target (t)
     struct target_ops *t;
{
  if (!target_structs)
    {
      target_struct_allocsize = DEFAULT_ALLOCSIZE;
      target_structs = (struct target_ops **) xmalloc
	(target_struct_allocsize * sizeof (*target_structs));
    }
  if (target_struct_size >= target_struct_allocsize)
    {
      target_struct_allocsize *= 2;
      target_structs = (struct target_ops **)
	  xrealloc ((char *) target_structs, 
		    target_struct_allocsize * sizeof (*target_structs));
    }
  target_structs[target_struct_size++] = t;
/*  cleanup_target (t);*/

  if (targetlist == NULL)
    add_prefix_cmd ("target", class_run, target_command,
		    "Connect to a target machine or process.\n\
The first argument is the type or protocol of the target machine.\n\
Remaining arguments are interpreted by the target protocol.  For more\n\
information on the arguments for a particular protocol, type\n\
`help target ' followed by the protocol name.",
		    &targetlist, "target ", 0, &cmdlist);
  add_cmd (t->to_shortname, no_class, t->to_open, t->to_doc, &targetlist);
}

/* Stub functions */

static void
ignore ()
{
}

/* ARGSUSED */
static int
nomemory (memaddr, myaddr, len, write, t)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
     struct target_ops *t;
{
  errno = EIO;		/* Can't read/write this location */
  return 0;		/* No bytes handled */
}

static void
tcomplain ()
{
  error ("You can't do that when your target is `%s'",
	 current_target.to_shortname);
}

void
noprocess ()
{
  error ("You can't do that without a process to debug");
}

/* ARGSUSED */
static int
nosymbol (name, addrp)
     char *name;
     CORE_ADDR *addrp;
{
  return 1;		/* Symbol does not exist in target env */
}

/* ARGSUSED */
static void
default_terminal_info (args, from_tty)
     char *args;
     int from_tty;
{
  printf_unfiltered("No saved terminal information.\n");
}

/* This is the default target_create_inferior and target_attach function.
   If the current target is executing, it asks whether to kill it off.
   If this function returns without calling error(), it has killed off
   the target, and the operation should be attempted.  */

static void
kill_or_be_killed (from_tty)
     int from_tty;
{
  if (target_has_execution)
    {
      printf_unfiltered ("You are already running a program:\n");
      target_files_info ();
      if (query ("Kill it? ")) {
	target_kill ();
	if (target_has_execution)
	  error ("Killing the program did not help.");
	return;
      } else {
	error ("Program not killed.");
      }
    }
  tcomplain();
}

static void
maybe_kill_then_attach (args, from_tty)
     char *args;
     int from_tty;
{
  kill_or_be_killed (from_tty);
  target_attach (args, from_tty);
}

static void
maybe_kill_then_create_inferior (exec, args, env)
     char *exec;
     char *args;
     char **env;
{
  kill_or_be_killed (0);
  target_create_inferior (exec, args, env);
}

/* Clean up a target struct so it no longer has any zero pointers in it.
   We default entries, at least to stubs that print error messages.  */

static void
cleanup_target (t)
     struct target_ops *t;
{

#define de_fault(field, value) \
  if (!t->field)	t->field = value

  /*        FIELD			DEFAULT VALUE        */

  de_fault (to_open, 			(void (*) PARAMS((char *, int))) tcomplain);
  de_fault (to_close, 			(void (*) PARAMS((int))) ignore);
  de_fault (to_attach, 			maybe_kill_then_attach);
  de_fault (to_detach, 			(void (*) PARAMS((char *, int))) ignore);
  de_fault (to_resume, 			(void (*) PARAMS((int, int, enum target_signal))) noprocess);
  de_fault (to_wait, 			(int (*) PARAMS((int, struct target_waitstatus *))) noprocess);
  de_fault (to_fetch_registers, 	(void (*) PARAMS((int))) ignore);
  de_fault (to_store_registers,		(void (*) PARAMS((int))) noprocess);
  de_fault (to_prepare_to_store,	(void (*) PARAMS((void))) noprocess);
  de_fault (to_xfer_memory,		(int (*) PARAMS((CORE_ADDR, char *, int, int, struct target_ops *))) nomemory);
  de_fault (to_files_info,		(void (*) PARAMS((struct target_ops *))) ignore);
  de_fault (to_insert_breakpoint,	memory_insert_breakpoint);
  de_fault (to_remove_breakpoint,	memory_remove_breakpoint);
  de_fault (to_terminal_init,		(void (*) PARAMS((void))) ignore);
  de_fault (to_terminal_inferior,	(void (*) PARAMS ((void))) ignore);
  de_fault (to_terminal_ours_for_output,(void (*) PARAMS ((void))) ignore);
  de_fault (to_terminal_ours,		(void (*) PARAMS ((void))) ignore);
  de_fault (to_terminal_info,		default_terminal_info);
  de_fault (to_kill,			(void (*) PARAMS((void))) noprocess);
  de_fault (to_load,			(void (*) PARAMS((char *, int))) tcomplain);
  de_fault (to_lookup_symbol,		(int (*) PARAMS ((char *, CORE_ADDR *))) nosymbol);
  de_fault (to_create_inferior,		maybe_kill_then_create_inferior);
  de_fault (to_mourn_inferior,		(void (*) PARAMS((void))) noprocess);
  de_fault (to_can_run,			return_zero);
  de_fault (to_notice_signals,		(void (*) PARAMS((int))) ignore);
  de_fault (to_thread_alive,		(int (*) PARAMS((int))) ignore);
  de_fault (to_stop,			(void (*) PARAMS((void))) ignore);

#undef de_fault
}

/* Go through the target stack from top to bottom, copying over zero entries in
   current_target.  In effect, we are doing class inheritance through the
   pushed target vectors.  */

static void
update_current_target ()
{
  struct target_stack_item *item;
  struct target_ops *t;

  /* First, reset current_target */
  memset (&current_target, 0, sizeof current_target);

  for (item = target_stack; item; item = item->next)
    {
      t = item->target_ops;

#define INHERIT(FIELD, TARGET) \
      if (!current_target.FIELD) \
	current_target.FIELD = TARGET->FIELD

      INHERIT (to_shortname, t);
      INHERIT (to_longname, t);
      INHERIT (to_doc, t);
      INHERIT (to_open, t);
      INHERIT (to_close, t);
      INHERIT (to_attach, t);
      INHERIT (to_detach, t);
      INHERIT (to_resume, t);
      INHERIT (to_wait, t);
      INHERIT (to_fetch_registers, t);
      INHERIT (to_store_registers, t);
      INHERIT (to_prepare_to_store, t);
      INHERIT (to_xfer_memory, t);
      INHERIT (to_files_info, t);
      INHERIT (to_insert_breakpoint, t);
      INHERIT (to_remove_breakpoint, t);
      INHERIT (to_terminal_init, t);
      INHERIT (to_terminal_inferior, t);
      INHERIT (to_terminal_ours_for_output, t);
      INHERIT (to_terminal_ours, t);
      INHERIT (to_terminal_info, t);
      INHERIT (to_kill, t);
      INHERIT (to_load, t);
      INHERIT (to_lookup_symbol, t);
      INHERIT (to_create_inferior, t);
      INHERIT (to_mourn_inferior, t);
      INHERIT (to_can_run, t);
      INHERIT (to_notice_signals, t);
      INHERIT (to_thread_alive, t);
      INHERIT (to_stop, t);
      INHERIT (to_stratum, t);
      INHERIT (DONT_USE, t);
      INHERIT (to_has_all_memory, t);
      INHERIT (to_has_memory, t);
      INHERIT (to_has_stack, t);
      INHERIT (to_has_registers, t);
      INHERIT (to_has_execution, t);
      INHERIT (to_sections, t);
      INHERIT (to_sections_end, t);
      INHERIT (to_magic, t);

#undef INHERIT
    }
}

/* Push a new target type into the stack of the existing target accessors,
   possibly superseding some of the existing accessors.

   Result is zero if the pushed target ended up on top of the stack,
   nonzero if at least one target is on top of it.

   Rather than allow an empty stack, we always have the dummy target at
   the bottom stratum, so we can call the function vectors without
   checking them.  */

int
push_target (t)
     struct target_ops *t;
{
  struct target_stack_item *cur, *prev, *tmp;

  /* Check magic number.  If wrong, it probably means someone changed
     the struct definition, but not all the places that initialize one.  */
  if (t->to_magic != OPS_MAGIC)
    {
      fprintf_unfiltered(gdb_stderr,
			 "Magic number of %s target struct wrong\n", 
			 t->to_shortname);
      abort();
    }

  /* Find the proper stratum to install this target in. */

  for (prev = NULL, cur = target_stack; cur; prev = cur, cur = cur->next)
    {
      if ((int)(t->to_stratum) >= (int)(cur->target_ops->to_stratum))
	break;
    }

  /* If there's already targets at this stratum, remove them. */

  if (cur)
    while (t->to_stratum == cur->target_ops->to_stratum)
      {
	/* There's already something on this stratum.  Close it off.  */
	if (cur->target_ops->to_close)
	  (cur->target_ops->to_close) (0);
	if (prev)
	  prev->next = cur->next; /* Unchain old target_ops */
	else
	  target_stack = cur->next; /* Unchain first on list */
	tmp = cur->next;
	free (cur);
	cur = tmp;
      }

  /* We have removed all targets in our stratum, now add the new one.  */

  tmp = (struct target_stack_item *)
    xmalloc (sizeof (struct target_stack_item));
  tmp->next = cur;
  tmp->target_ops = t;

  if (prev)
    prev->next = tmp;
  else
    target_stack = tmp;

  update_current_target ();

  cleanup_target (&current_target); /* Fill in the gaps */

#ifdef MAINTENANCE_CMDS
  if (targetdebug)
    setup_target_debug ();
#endif

  return prev != 0;
}

/* Remove a target_ops vector from the stack, wherever it may be. 
   Return how many times it was removed (0 or 1).  */

int
unpush_target (t)
     struct target_ops *t;
{
  struct target_stack_item *cur, *prev;

  if (t->to_close)
    t->to_close (0);		/* Let it clean up */

  /* Look for the specified target.  Note that we assume that a target
     can only occur once in the target stack. */

  for (cur = target_stack, prev = NULL; cur; prev = cur, cur = cur->next)
    if (cur->target_ops == t)
      break;

  if (!cur)
    return 0;			/* Didn't find target_ops, quit now */

  /* Unchain the target */

  if (!prev)
    target_stack = cur->next;
  else
    prev->next = cur->next;

  free (cur);			/* Release the target_stack_item */

  update_current_target ();
  cleanup_target (&current_target);

  return 1;
}

void
pop_target ()
{
  (current_target.to_close)(0);	/* Let it clean up */
  if (unpush_target (target_stack->target_ops) == 1)
    return;

  fprintf_unfiltered(gdb_stderr,
		     "pop_target couldn't find target %s\n", 
		     current_target.to_shortname);
  abort();
}

#undef	MIN
#define MIN(A, B) (((A) <= (B)) ? (A) : (B))

/* target_read_string -- read a null terminated string, up to LEN bytes,
   from MEMADDR in target.  Set *ERRNOP to the errno code, or 0 if successful.
   Set *STRING to a pointer to malloc'd memory containing the data; the caller
   is responsible for freeing it.  Return the number of bytes successfully
   read.  */

int
target_read_string (memaddr, string, len, errnop)
     CORE_ADDR memaddr;
     char **string;
     int len;
     int *errnop;
{
  int tlen, origlen, offset, i;
  char buf[4];
  int errcode = 0;
  char *buffer;
  int buffer_allocated;
  char *bufptr;
  unsigned int nbytes_read = 0;

  /* Small for testing.  */
  buffer_allocated = 4;
  buffer = xmalloc (buffer_allocated);
  bufptr = buffer;

  origlen = len;

  while (len > 0)
    {
      tlen = MIN (len, 4 - (memaddr & 3));
      offset = memaddr & 3;

      errcode = target_xfer_memory (memaddr & ~3, buf, 4, 0);
      if (errcode != 0)
	goto done;

      if (bufptr - buffer + tlen > buffer_allocated)
	{
	  unsigned int bytes;
	  bytes = bufptr - buffer;
	  buffer_allocated *= 2;
	  buffer = xrealloc (buffer, buffer_allocated);
	  bufptr = buffer + bytes;
	}

      for (i = 0; i < tlen; i++)
	{
	  *bufptr++ = buf[i + offset];
	  if (buf[i + offset] == '\000')
	    {
	      nbytes_read += i + 1;
	      goto done;
	    }
	}

      memaddr += tlen;
      len -= tlen;
      nbytes_read += tlen;
    }
 done:
  if (errnop != NULL)
    *errnop = errcode;
  if (string != NULL)
    *string = buffer;
  return nbytes_read;
}

/* Read LEN bytes of target memory at address MEMADDR, placing the results in
   GDB's memory at MYADDR.  Returns either 0 for success or an errno value
   if any error occurs.

   If an error occurs, no guarantee is made about the contents of the data at
   MYADDR.  In particular, the caller should not depend upon partial reads
   filling the buffer with good data.  There is no way for the caller to know
   how much good data might have been transfered anyway.  Callers that can
   deal with partial reads should call target_read_memory_partial. */

int
target_read_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
{
  return target_xfer_memory (memaddr, myaddr, len, 0);
}

/* Read LEN bytes of target memory at address MEMADDR, placing the results
   in GDB's memory at MYADDR.  Returns a count of the bytes actually read,
   and optionally an errno value in the location pointed to by ERRNOPTR
   if ERRNOPTR is non-null. */

int
target_read_memory_partial (memaddr, myaddr, len, errnoptr)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int *errnoptr;
{
  int nread;	/* Number of bytes actually read. */
  int errcode;	/* Error from last read. */

  /* First try a complete read. */
  errcode = target_xfer_memory (memaddr, myaddr, len, 0);
  if (errcode == 0)
    {
      /* Got it all. */
      nread = len;
    }
  else
    {
      /* Loop, reading one byte at a time until we get as much as we can. */
      for (errcode = 0, nread = 0; len > 0 && errcode == 0; nread++, len--)
	{
	  errcode = target_xfer_memory (memaddr++, myaddr++, 1, 0);
	}
      /* If an error, the last read was unsuccessful, so adjust count. */
      if (errcode != 0)
	{
	  nread--;
	}
    }
  if (errnoptr != NULL)
    {
      *errnoptr = errcode;
    }
  return (nread);
}

int
target_write_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
{
  return target_xfer_memory (memaddr, myaddr, len, 1);
}
 
/* Move memory to or from the targets.  Iterate until all of it has
   been moved, if necessary.  The top target gets priority; anything
   it doesn't want, is offered to the next one down, etc.  Note the
   business with curlen:  if an early target says "no, but I have a
   boundary overlapping this xfer" then we shorten what we offer to
   the subsequent targets so the early guy will get a chance at the
   tail before the subsequent ones do. 

   Result is 0 or errno value.  */

int
target_xfer_memory (memaddr, myaddr, len, write)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
{
  int curlen;
  int res;
  struct target_ops *t;
  struct target_stack_item *item;

  /* to_xfer_memory is not guaranteed to set errno, even when it returns
     0.  */
  errno = 0;

  /* The quick case is that the top target does it all.  */
  res = current_target.to_xfer_memory
			(memaddr, myaddr, len, write, &current_target);
  if (res == len)
    return 0;

  if (res > 0)
    goto bump;
  /* If res <= 0 then we call it again in the loop.  Ah well.  */

  for (; len > 0;)
    {
      curlen = len;		/* Want to do it all */
      for (item = target_stack; item; item = item->next)
	{
	  t = item->target_ops;
	  if (!t->to_has_memory)
	    continue;

	  res = t->to_xfer_memory (memaddr, myaddr, curlen, write, t);
	  if (res > 0)
	    break;		/* Handled all or part of xfer */
	  if (t->to_has_all_memory)
	    break;
	}

      if (res <= 0)
	{
	  /* If this address is for nonexistent memory,
	     read zeros if reading, or do nothing if writing.  Return error. */
	  if (!write)
	    memset (myaddr, 0, len);
	  if (errno == 0)
	    return EIO;
	  else
	    return errno;
	}
bump:
      memaddr += res;
      myaddr  += res;
      len     -= res;
    }
  return 0;			/* We managed to cover it all somehow. */
}


/* ARGSUSED */
static void
target_info (args, from_tty)
     char *args;
     int from_tty;
{
  struct target_ops *t;
  struct target_stack_item *item;
  int has_all_mem = 0;
  
  if (symfile_objfile != NULL)
    printf_unfiltered ("Symbols from \"%s\".\n", symfile_objfile->name);

#ifdef FILES_INFO_HOOK
  if (FILES_INFO_HOOK ())
    return;
#endif

  for (item = target_stack; item; item = item->next)
    {
      t = item->target_ops;

      if (!t->to_has_memory)
	continue;

      if ((int)(t->to_stratum) <= (int)dummy_stratum)
	continue;
      if (has_all_mem)
	printf_unfiltered("\tWhile running this, GDB does not access memory from...\n");
      printf_unfiltered("%s:\n", t->to_longname);
      (t->to_files_info)(t);
      has_all_mem = t->to_has_all_memory;
    }
}

/* This is to be called by the open routine before it does
   anything.  */

void
target_preopen (from_tty)
     int from_tty;
{
  dont_repeat();

  if (target_has_execution)
    {   
      if (query ("A program is being debugged already.  Kill it? "))
        target_kill ();
      else
        error ("Program not killed.");
    }

  /* Calling target_kill may remove the target from the stack.  But if
     it doesn't (which seems like a win for UDI), remove it now.  */

  if (target_has_execution)
    pop_target ();
}

/* Detach a target after doing deferred register stores.  */

void
target_detach (args, from_tty)
     char *args;
     int from_tty;
{
  /* Handle any optimized stores to the inferior.  */
#ifdef DO_DEFERRED_STORES
  DO_DEFERRED_STORES;
#endif
  (current_target.to_detach) (args, from_tty);
}

void
target_link (modname, t_reloc)
     char *modname;
     CORE_ADDR *t_reloc;
{
  if (STREQ(current_target.to_shortname, "rombug"))
    {
      (current_target.to_lookup_symbol) (modname, t_reloc);
      if (*t_reloc == 0)
      error("Unable to link to %s and get relocation in rombug", modname);
    }
  else
    *t_reloc = (CORE_ADDR)-1;
}

/* Look through the list of possible targets for a target that can
   execute a run or attach command without any other data.  This is
   used to locate the default process stratum.

   Result is always valid (error() is called for errors).  */

static struct target_ops *
find_default_run_target (do_mesg)
     char *do_mesg;
{
  struct target_ops **t;
  struct target_ops *runable = NULL;
  int count;

  count = 0;

  for (t = target_structs; t < target_structs + target_struct_size;
       ++t)
    {
      if ((*t)->to_can_run && target_can_run(*t))
	{
	  runable = *t;
	  ++count;
	}
    }

  if (count != 1)
    error ("Don't know how to %s.  Try \"help target\".", do_mesg);

  return runable;
}

void
find_default_attach (args, from_tty)
     char *args;
     int from_tty;
{
  struct target_ops *t;

  t = find_default_run_target("attach");
  (t->to_attach) (args, from_tty);
  return;
}

void
find_default_create_inferior (exec_file, allargs, env)
     char *exec_file;
     char *allargs;
     char **env;
{
  struct target_ops *t;

  t = find_default_run_target("run");
  (t->to_create_inferior) (exec_file, allargs, env);
  return;
}

static int
return_zero ()
{
  return 0;
}

struct target_ops *
find_core_target ()
{
  struct target_ops **t;
  struct target_ops *runable = NULL;
  int count;
  
  count = 0;
  
  for (t = target_structs; t < target_structs + target_struct_size;
       ++t)
    {
      if ((*t)->to_stratum == core_stratum)
	{
	  runable = *t;
	  ++count;
	}
    }
  
  return(count == 1 ? runable : NULL);
}

/* The inferior process has died.  Long live the inferior!  */

void
generic_mourn_inferior ()
{
  extern int show_breakpoint_hit_counts;

  inferior_pid = 0;
  attach_flag = 0;
  breakpoint_init_inferior ();
  registers_changed ();

#ifdef CLEAR_DEFERRED_STORES
  /* Delete any pending stores to the inferior... */
  CLEAR_DEFERRED_STORES;
#endif

  reopen_exec_file ();
  reinit_frame_cache ();

  /* It is confusing to the user for ignore counts to stick around
     from previous runs of the inferior.  So clear them.  */
  /* However, it is more confusing for the ignore counts to disappear when
     using hit counts.  So don't clear them if we're counting hits.  */
  if (!show_breakpoint_hit_counts)
    breakpoint_clear_ignore_counts ();
}

/* This table must match in order and size the signals in enum target_signal
   in target.h.  */
static struct {
  char *name;
  char *string;
  } signals [] =
{
  {"0", "Signal 0"},
  {"SIGHUP", "Hangup"},
  {"SIGINT", "Interrupt"},
  {"SIGQUIT", "Quit"},
  {"SIGILL", "Illegal instruction"},
  {"SIGTRAP", "Trace/breakpoint trap"},
  {"SIGABRT", "Aborted"},
  {"SIGEMT", "Emulation trap"},
  {"SIGFPE", "Arithmetic exception"},
  {"SIGKILL", "Killed"},
  {"SIGBUS", "Bus error"},
  {"SIGSEGV", "Segmentation fault"},
  {"SIGSYS", "Bad system call"},
  {"SIGPIPE", "Broken pipe"},
  {"SIGALRM", "Alarm clock"},
  {"SIGTERM", "Terminated"},
  {"SIGURG", "Urgent I/O condition"},
  {"SIGSTOP", "Stopped (signal)"},
  {"SIGTSTP", "Stopped (user)"},
  {"SIGCONT", "Continued"},
  {"SIGCHLD", "Child status changed"},
  {"SIGTTIN", "Stopped (tty input)"},
  {"SIGTTOU", "Stopped (tty output)"},
  {"SIGIO", "I/O possible"},
  {"SIGXCPU", "CPU time limit exceeded"},
  {"SIGXFSZ", "File size limit exceeded"},
  {"SIGVTALRM", "Virtual timer expired"},
  {"SIGPROF", "Profiling timer expired"},
  {"SIGWINCH", "Window size changed"},
  {"SIGLOST", "Resource lost"},
  {"SIGUSR1", "User defined signal 1"},
  {"SIGUSR2", "User defined signal 2"},
  {"SIGPWR", "Power fail/restart"},
  {"SIGPOLL", "Pollable event occurred"},
  {"SIGWIND", "SIGWIND"},
  {"SIGPHONE", "SIGPHONE"},
  {"SIGWAITING", "Process's LWPs are blocked"},
  {"SIGLWP", "Signal LWP"},
  {"SIGDANGER", "Swap space dangerously low"},
  {"SIGGRANT", "Monitor mode granted"},
  {"SIGRETRACT", "Need to relinguish monitor mode"},
  {"SIGMSG", "Monitor mode data available"},
  {"SIGSOUND", "Sound completed"},
  {"SIGSAK", "Secure attention"},
  {"SIGPRIO", "SIGPRIO"},
  {"SIG33", "Real-time event 33"},
  {"SIG34", "Real-time event 34"},
  {"SIG35", "Real-time event 35"},
  {"SIG36", "Real-time event 36"},
  {"SIG37", "Real-time event 37"},
  {"SIG38", "Real-time event 38"},
  {"SIG39", "Real-time event 39"},
  {"SIG40", "Real-time event 40"},
  {"SIG41", "Real-time event 41"},
  {"SIG42", "Real-time event 42"},
  {"SIG43", "Real-time event 43"},
  {"SIG44", "Real-time event 44"},
  {"SIG45", "Real-time event 45"},
  {"SIG46", "Real-time event 46"},
  {"SIG47", "Real-time event 47"},
  {"SIG48", "Real-time event 48"},
  {"SIG49", "Real-time event 49"},
  {"SIG50", "Real-time event 50"},
  {"SIG51", "Real-time event 51"},
  {"SIG52", "Real-time event 52"},
  {"SIG53", "Real-time event 53"},
  {"SIG54", "Real-time event 54"},
  {"SIG55", "Real-time event 55"},
  {"SIG56", "Real-time event 56"},
  {"SIG57", "Real-time event 57"},
  {"SIG58", "Real-time event 58"},
  {"SIG59", "Real-time event 59"},
  {"SIG60", "Real-time event 60"},
  {"SIG61", "Real-time event 61"},
  {"SIG62", "Real-time event 62"},
  {"SIG63", "Real-time event 63"},

  /* Mach exceptions */
  {"EXC_BAD_ACCESS", "Could not access memory"},
  {"EXC_BAD_INSTRUCTION", "Illegal instruction/operand"},
  {"EXC_ARITHMETIC", "Arithmetic exception"},
  {"EXC_EMULATION", "Emulation instruction"},
  {"EXC_SOFTWARE", "Software generated exception"},
  {"EXC_BREAKPOINT", "Breakpoint"},

  {NULL, "Unknown signal"},
  {NULL, "Internal error: printing TARGET_SIGNAL_DEFAULT"},

  /* Last entry, used to check whether the table is the right size.  */
  {NULL, "TARGET_SIGNAL_MAGIC"}
};

/* Return the string for a signal.  */
char *
target_signal_to_string (sig)
     enum target_signal sig;
{
  return signals[sig].string;
}

/* Return the name for a signal.  */
char *
target_signal_to_name (sig)
     enum target_signal sig;
{
  if (sig == TARGET_SIGNAL_UNKNOWN)
    /* I think the code which prints this will always print it along with
       the string, so no need to be verbose.  */
    return "?";
  return signals[sig].name;
}

/* Given a name, return its signal.  */
enum target_signal
target_signal_from_name (name)
     char *name;
{
  enum target_signal sig;

  /* It's possible we also should allow "SIGCLD" as well as "SIGCHLD"
     for TARGET_SIGNAL_SIGCHLD.  SIGIOT, on the other hand, is more
     questionable; seems like by now people should call it SIGABRT
     instead.  */

  /* This ugly cast brought to you by the native VAX compiler.  */
  for (sig = TARGET_SIGNAL_HUP;
       signals[sig].name != NULL;
       sig = (enum target_signal)((int)sig + 1))
    if (STREQ (name, signals[sig].name))
      return sig;
  return TARGET_SIGNAL_UNKNOWN;
}

/* The following functions are to help certain targets deal
   with the signal/waitstatus stuff.  They could just as well be in
   a file called native-utils.c or unixwaitstatus-utils.c or whatever.  */

/* Convert host signal to our signals.  */
enum target_signal
target_signal_from_host (hostsig)
     int hostsig;
{
  /* A switch statement would make sense but would require special kludges
     to deal with the cases where more than one signal has the same number.  */

  if (hostsig == 0) return TARGET_SIGNAL_0;

#if defined (SIGHUP)
  if (hostsig == SIGHUP) return TARGET_SIGNAL_HUP;
#endif
#if defined (SIGINT)
  if (hostsig == SIGINT) return TARGET_SIGNAL_INT;
#endif
#if defined (SIGQUIT)
  if (hostsig == SIGQUIT) return TARGET_SIGNAL_QUIT;
#endif
#if defined (SIGILL)
  if (hostsig == SIGILL) return TARGET_SIGNAL_ILL;
#endif
#if defined (SIGTRAP)
  if (hostsig == SIGTRAP) return TARGET_SIGNAL_TRAP;
#endif
#if defined (SIGABRT)
  if (hostsig == SIGABRT) return TARGET_SIGNAL_ABRT;
#endif
#if defined (SIGEMT)
  if (hostsig == SIGEMT) return TARGET_SIGNAL_EMT;
#endif
#if defined (SIGFPE)
  if (hostsig == SIGFPE) return TARGET_SIGNAL_FPE;
#endif
#if defined (SIGKILL)
  if (hostsig == SIGKILL) return TARGET_SIGNAL_KILL;
#endif
#if defined (SIGBUS)
  if (hostsig == SIGBUS) return TARGET_SIGNAL_BUS;
#endif
#if defined (SIGSEGV)
  if (hostsig == SIGSEGV) return TARGET_SIGNAL_SEGV;
#endif
#if defined (SIGSYS)
  if (hostsig == SIGSYS) return TARGET_SIGNAL_SYS;
#endif
#if defined (SIGPIPE)
  if (hostsig == SIGPIPE) return TARGET_SIGNAL_PIPE;
#endif
#if defined (SIGALRM)
  if (hostsig == SIGALRM) return TARGET_SIGNAL_ALRM;
#endif
#if defined (SIGTERM)
  if (hostsig == SIGTERM) return TARGET_SIGNAL_TERM;
#endif
#if defined (SIGUSR1)
  if (hostsig == SIGUSR1) return TARGET_SIGNAL_USR1;
#endif
#if defined (SIGUSR2)
  if (hostsig == SIGUSR2) return TARGET_SIGNAL_USR2;
#endif
#if defined (SIGCLD)
  if (hostsig == SIGCLD) return TARGET_SIGNAL_CHLD;
#endif
#if defined (SIGCHLD)
  if (hostsig == SIGCHLD) return TARGET_SIGNAL_CHLD;
#endif
#if defined (SIGPWR)
  if (hostsig == SIGPWR) return TARGET_SIGNAL_PWR;
#endif
#if defined (SIGWINCH)
  if (hostsig == SIGWINCH) return TARGET_SIGNAL_WINCH;
#endif
#if defined (SIGURG)
  if (hostsig == SIGURG) return TARGET_SIGNAL_URG;
#endif
#if defined (SIGIO)
  if (hostsig == SIGIO) return TARGET_SIGNAL_IO;
#endif
#if defined (SIGPOLL)
  if (hostsig == SIGPOLL) return TARGET_SIGNAL_POLL;
#endif
#if defined (SIGSTOP)
  if (hostsig == SIGSTOP) return TARGET_SIGNAL_STOP;
#endif
#if defined (SIGTSTP)
  if (hostsig == SIGTSTP) return TARGET_SIGNAL_TSTP;
#endif
#if defined (SIGCONT)
  if (hostsig == SIGCONT) return TARGET_SIGNAL_CONT;
#endif
#if defined (SIGTTIN)
  if (hostsig == SIGTTIN) return TARGET_SIGNAL_TTIN;
#endif
#if defined (SIGTTOU)
  if (hostsig == SIGTTOU) return TARGET_SIGNAL_TTOU;
#endif
#if defined (SIGVTALRM)
  if (hostsig == SIGVTALRM) return TARGET_SIGNAL_VTALRM;
#endif
#if defined (SIGPROF)
  if (hostsig == SIGPROF) return TARGET_SIGNAL_PROF;
#endif
#if defined (SIGXCPU)
  if (hostsig == SIGXCPU) return TARGET_SIGNAL_XCPU;
#endif
#if defined (SIGXFSZ)
  if (hostsig == SIGXFSZ) return TARGET_SIGNAL_XFSZ;
#endif
#if defined (SIGWIND)
  if (hostsig == SIGWIND) return TARGET_SIGNAL_WIND;
#endif
#if defined (SIGPHONE)
  if (hostsig == SIGPHONE) return TARGET_SIGNAL_PHONE;
#endif
#if defined (SIGLOST)
  if (hostsig == SIGLOST) return TARGET_SIGNAL_LOST;
#endif
#if defined (SIGWAITING)
  if (hostsig == SIGWAITING) return TARGET_SIGNAL_WAITING;
#endif
#if defined (SIGLWP)
  if (hostsig == SIGLWP) return TARGET_SIGNAL_LWP;
#endif
#if defined (SIGDANGER)
  if (hostsig == SIGDANGER) return TARGET_SIGNAL_DANGER;
#endif
#if defined (SIGGRANT)
  if (hostsig == SIGGRANT) return TARGET_SIGNAL_GRANT;
#endif
#if defined (SIGRETRACT)
  if (hostsig == SIGRETRACT) return TARGET_SIGNAL_RETRACT;
#endif
#if defined (SIGMSG)
  if (hostsig == SIGMSG) return TARGET_SIGNAL_MSG;
#endif
#if defined (SIGSOUND)
  if (hostsig == SIGSOUND) return TARGET_SIGNAL_SOUND;
#endif
#if defined (SIGSAK)
  if (hostsig == SIGSAK) return TARGET_SIGNAL_SAK;
#endif
#if defined (SIGPRIO)
  if (hostsig == SIGPRIO) return TARGET_SIGNAL_PRIO;
#endif

  /* Mach exceptions.  Assumes that the values for EXC_ are positive! */
#if defined (EXC_BAD_ACCESS) && defined (_NSIG)
  if (hostsig == _NSIG + EXC_BAD_ACCESS) return TARGET_EXC_BAD_ACCESS;
#endif
#if defined (EXC_BAD_INSTRUCTION) && defined (_NSIG)
  if (hostsig == _NSIG + EXC_BAD_INSTRUCTION) return TARGET_EXC_BAD_INSTRUCTION;
#endif
#if defined (EXC_ARITHMETIC) && defined (_NSIG)
  if (hostsig == _NSIG + EXC_ARITHMETIC) return TARGET_EXC_ARITHMETIC;
#endif
#if defined (EXC_EMULATION) && defined (_NSIG)
  if (hostsig == _NSIG + EXC_EMULATION) return TARGET_EXC_EMULATION;
#endif
#if defined (EXC_SOFTWARE) && defined (_NSIG)
  if (hostsig == _NSIG + EXC_SOFTWARE) return TARGET_EXC_SOFTWARE;
#endif
#if defined (EXC_BREAKPOINT) && defined (_NSIG)
  if (hostsig == _NSIG + EXC_BREAKPOINT) return TARGET_EXC_BREAKPOINT;
#endif

#if defined (REALTIME_LO)
  if (hostsig >= REALTIME_LO && hostsig < REALTIME_HI)
    return (enum target_signal)
      (hostsig - 33 + (int) TARGET_SIGNAL_REALTIME_33);
#endif
  return TARGET_SIGNAL_UNKNOWN;
}

int
target_signal_to_host (oursig)
     enum target_signal oursig;
{
  switch (oursig)
    {
    case TARGET_SIGNAL_0: return 0;

#if defined (SIGHUP)
    case TARGET_SIGNAL_HUP: return SIGHUP;
#endif
#if defined (SIGINT)
    case TARGET_SIGNAL_INT: return SIGINT;
#endif
#if defined (SIGQUIT)
    case TARGET_SIGNAL_QUIT: return SIGQUIT;
#endif
#if defined (SIGILL)
    case TARGET_SIGNAL_ILL: return SIGILL;
#endif
#if defined (SIGTRAP)
    case TARGET_SIGNAL_TRAP: return SIGTRAP;
#endif
#if defined (SIGABRT)
    case TARGET_SIGNAL_ABRT: return SIGABRT;
#endif
#if defined (SIGEMT)
    case TARGET_SIGNAL_EMT: return SIGEMT;
#endif
#if defined (SIGFPE)
    case TARGET_SIGNAL_FPE: return SIGFPE;
#endif
#if defined (SIGKILL)
    case TARGET_SIGNAL_KILL: return SIGKILL;
#endif
#if defined (SIGBUS)
    case TARGET_SIGNAL_BUS: return SIGBUS;
#endif
#if defined (SIGSEGV)
    case TARGET_SIGNAL_SEGV: return SIGSEGV;
#endif
#if defined (SIGSYS)
    case TARGET_SIGNAL_SYS: return SIGSYS;
#endif
#if defined (SIGPIPE)
    case TARGET_SIGNAL_PIPE: return SIGPIPE;
#endif
#if defined (SIGALRM)
    case TARGET_SIGNAL_ALRM: return SIGALRM;
#endif
#if defined (SIGTERM)
    case TARGET_SIGNAL_TERM: return SIGTERM;
#endif
#if defined (SIGUSR1)
    case TARGET_SIGNAL_USR1: return SIGUSR1;
#endif
#if defined (SIGUSR2)
    case TARGET_SIGNAL_USR2: return SIGUSR2;
#endif
#if defined (SIGCHLD) || defined (SIGCLD)
    case TARGET_SIGNAL_CHLD: 
#if defined (SIGCHLD)
      return SIGCHLD;
#else
      return SIGCLD;
#endif
#endif /* SIGCLD or SIGCHLD */
#if defined (SIGPWR)
    case TARGET_SIGNAL_PWR: return SIGPWR;
#endif
#if defined (SIGWINCH)
    case TARGET_SIGNAL_WINCH: return SIGWINCH;
#endif
#if defined (SIGURG)
    case TARGET_SIGNAL_URG: return SIGURG;
#endif
#if defined (SIGIO)
    case TARGET_SIGNAL_IO: return SIGIO;
#endif
#if defined (SIGPOLL)
    case TARGET_SIGNAL_POLL: return SIGPOLL;
#endif
#if defined (SIGSTOP)
    case TARGET_SIGNAL_STOP: return SIGSTOP;
#endif
#if defined (SIGTSTP)
    case TARGET_SIGNAL_TSTP: return SIGTSTP;
#endif
#if defined (SIGCONT)
    case TARGET_SIGNAL_CONT: return SIGCONT;
#endif
#if defined (SIGTTIN)
    case TARGET_SIGNAL_TTIN: return SIGTTIN;
#endif
#if defined (SIGTTOU)
    case TARGET_SIGNAL_TTOU: return SIGTTOU;
#endif
#if defined (SIGVTALRM)
    case TARGET_SIGNAL_VTALRM: return SIGVTALRM;
#endif
#if defined (SIGPROF)
    case TARGET_SIGNAL_PROF: return SIGPROF;
#endif
#if defined (SIGXCPU)
    case TARGET_SIGNAL_XCPU: return SIGXCPU;
#endif
#if defined (SIGXFSZ)
    case TARGET_SIGNAL_XFSZ: return SIGXFSZ;
#endif
#if defined (SIGWIND)
    case TARGET_SIGNAL_WIND: return SIGWIND;
#endif
#if defined (SIGPHONE)
    case TARGET_SIGNAL_PHONE: return SIGPHONE;
#endif
#if defined (SIGLOST)
    case TARGET_SIGNAL_LOST: return SIGLOST;
#endif
#if defined (SIGWAITING)
    case TARGET_SIGNAL_WAITING: return SIGWAITING;
#endif
#if defined (SIGLWP)
    case TARGET_SIGNAL_LWP: return SIGLWP;
#endif
#if defined (SIGDANGER)
    case TARGET_SIGNAL_DANGER: return SIGDANGER;
#endif
#if defined (SIGGRANT)
    case TARGET_SIGNAL_GRANT: return SIGGRANT;
#endif
#if defined (SIGRETRACT)
    case TARGET_SIGNAL_RETRACT: return SIGRETRACT;
#endif
#if defined (SIGMSG)
    case TARGET_SIGNAL_MSG: return SIGMSG;
#endif
#if defined (SIGSOUND)
    case TARGET_SIGNAL_SOUND: return SIGSOUND;
#endif
#if defined (SIGSAK)
    case TARGET_SIGNAL_SAK: return SIGSAK;
#endif
#if defined (SIGPRIO)
    case TARGET_SIGNAL_PRIO: return SIGPRIO;
#endif

      /* Mach exceptions.  Assumes that the values for EXC_ are positive! */
#if defined (EXC_BAD_ACCESS) && defined (_NSIG)
    case TARGET_EXC_BAD_ACCESS: return _NSIG + EXC_BAD_ACCESS;
#endif
#if defined (EXC_BAD_INSTRUCTION) && defined (_NSIG)
    case TARGET_EXC_BAD_INSTRUCTION: return _NSIG + EXC_BAD_INSTRUCTION;
#endif
#if defined (EXC_ARITHMETIC) && defined (_NSIG)
    case TARGET_EXC_ARITHMETIC: return _NSIG + EXC_ARITHMETIC;
#endif
#if defined (EXC_EMULATION) && defined (_NSIG)
    case TARGET_EXC_EMULATION: return _NSIG + EXC_EMULATION;
#endif
#if defined (EXC_SOFTWARE) && defined (_NSIG)
    case TARGET_EXC_SOFTWARE: return _NSIG + EXC_SOFTWARE;
#endif
#if defined (EXC_BREAKPOINT) && defined (_NSIG)
    case TARGET_EXC_BREAKPOINT: return _NSIG + EXC_BREAKPOINT;
#endif

    default:
#if defined (REALTIME_LO)
      if (oursig >= TARGET_SIGNAL_REALTIME_33
	  && oursig <= TARGET_SIGNAL_REALTIME_63)
	{
	  int retsig =
	    (int)oursig - (int)TARGET_SIGNAL_REALTIME_33 + REALTIME_LO;
	  if (retsig < REALTIME_HI)
	    return retsig;
	}
#endif
      /* The user might be trying to do "signal SIGSAK" where this system
	 doesn't have SIGSAK.  */
      warning ("Signal %s does not exist on this system.\n",
	       target_signal_to_name (oursig));
      return 0;
    }
}

/* Helper function for child_wait and the Lynx derivatives of child_wait.
   HOSTSTATUS is the waitstatus from wait() or the equivalent; store our
   translation of that in OURSTATUS.  */
void
store_waitstatus (ourstatus, hoststatus)
     struct target_waitstatus *ourstatus;
     int hoststatus;
{
#ifdef CHILD_SPECIAL_WAITSTATUS
  /* CHILD_SPECIAL_WAITSTATUS should return nonzero and set *OURSTATUS
     if it wants to deal with hoststatus.  */
  if (CHILD_SPECIAL_WAITSTATUS (ourstatus, hoststatus))
    return;
#endif

  if (WIFEXITED (hoststatus))
    {
      ourstatus->kind = TARGET_WAITKIND_EXITED;
      ourstatus->value.integer = WEXITSTATUS (hoststatus);
    }
  else if (!WIFSTOPPED (hoststatus))
    {
      ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
      ourstatus->value.sig = target_signal_from_host (WTERMSIG (hoststatus));
    }
  else
    {
      ourstatus->kind = TARGET_WAITKIND_STOPPED;
      ourstatus->value.sig = target_signal_from_host (WSTOPSIG (hoststatus));
    }
}

/* In some circumstances we allow a command to specify a numeric
   signal.  The idea is to keep these circumstances limited so that
   users (and scripts) develop portable habits.  For comparison,
   POSIX.2 `kill' requires that 1,2,3,6,9,14, and 15 work (and using a
   numeric signal at all is obscelescent.  We are slightly more
   lenient and allow 1-15 which should match host signal numbers on
   most systems.  Use of symbolic signal names is strongly encouraged.  */

enum target_signal
target_signal_from_command (num)
     int num;
{
  if (num >= 1 && num <= 15)
    return (enum target_signal)num;
  error ("Only signals 1-15 are valid as numeric signals.\n\
Use \"info signals\" for a list of symbolic signals.");
}

/* Returns zero to leave the inferior alone, one to interrupt it.  */
int (*target_activity_function) PARAMS ((void));
int target_activity_fd;

/* Convert a normal process ID to a string.  Returns the string in a static
   buffer.  */

char *
normal_pid_to_str (pid)
     int pid;
{
  static char buf[30];

  if (STREQ (current_target.to_shortname, "remote"))
    sprintf (buf, "thread %d", pid);
  else
    sprintf (buf, "process %d", pid);

  return buf;
}

#ifdef MAINTENANCE_CMDS
static struct target_ops debug_target;

static void
debug_to_open (args, from_tty)
     char *args;
     int from_tty;
{
  debug_target.to_open (args, from_tty);

  fprintf_unfiltered (stderr, "target_open (%s, %d)\n", args, from_tty);
}

static void
debug_to_close (quitting)
     int quitting;
{
  debug_target.to_close (quitting);

  fprintf_unfiltered (stderr, "target_close (%d)\n", quitting);
}

static void
debug_to_attach (args, from_tty)
     char *args;
     int from_tty;
{
  debug_target.to_attach (args, from_tty);

  fprintf_unfiltered (stderr, "target_attach (%s, %d)\n", args, from_tty);
}

static void
debug_to_detach (args, from_tty)
     char *args;
     int from_tty;
{
  debug_target.to_detach (args, from_tty);

  fprintf_unfiltered (stderr, "target_detach (%s, %d)\n", args, from_tty);
}

static void
debug_to_resume (pid, step, siggnal)
     int pid;
     int step;
     enum target_signal siggnal;
{
  debug_target.to_resume (pid, step, siggnal);

  fprintf_unfiltered (stderr, "target_resume (%d, %s, %s)\n", pid,
		      step ? "step" : "continue",
		      target_signal_to_name (siggnal));
}

static int
debug_to_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
{
  int retval;

  retval = debug_target.to_wait (pid, status);

  fprintf_unfiltered (stderr, "target_wait (%d, status) = %d,   ", pid, retval);
  fprintf_unfiltered (stderr, "status->kind = ");
  switch (status->kind)
    {
    case TARGET_WAITKIND_EXITED:
      fprintf_unfiltered (stderr, "exited, status = %d\n", status->value.integer);
      break;
    case TARGET_WAITKIND_STOPPED:
      fprintf_unfiltered (stderr, "stopped, signal = %s\n",
			  target_signal_to_name (status->value.sig));
      break;
    case TARGET_WAITKIND_SIGNALLED:
      fprintf_unfiltered (stderr, "signalled, signal = %s\n",
			  target_signal_to_name (status->value.sig));
      break;
    case TARGET_WAITKIND_LOADED:
      fprintf_unfiltered (stderr, "loaded\n");
      break;
    case TARGET_WAITKIND_SPURIOUS:
      fprintf_unfiltered (stderr, "spurious\n");
      break;
    default:
      fprintf_unfiltered (stderr, "unknown???\n");
      break;
    }

  return retval;
}

static void
debug_to_fetch_registers (regno)
     int regno;
{
  debug_target.to_fetch_registers (regno);

  fprintf_unfiltered (stderr, "target_fetch_registers (%s)",
		      regno != -1 ? reg_names[regno] : "-1");
  if (regno != -1)
    fprintf_unfiltered (stderr, " = 0x%x %d", read_register (regno),
			read_register (regno));
  fprintf_unfiltered (stderr, "\n");
}

static void
debug_to_store_registers (regno)
     int regno;
{
  debug_target.to_store_registers (regno);

  if (regno >= 0 && regno < NUM_REGS)
    fprintf_unfiltered (stderr, "target_store_registers (%s) = 0x%x %d\n",
			reg_names[regno], read_register (regno),
			read_register (regno));
  else
    fprintf_unfiltered (stderr, "target_store_registers (%d)\n", regno);
}

static void
debug_to_prepare_to_store ()
{
  debug_target.to_prepare_to_store ();

  fprintf_unfiltered (stderr, "target_prepare_to_store ()\n");
}

static int
debug_to_xfer_memory (memaddr, myaddr, len, write, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
     struct target_ops *target;
{
  int retval;

  retval = debug_target.to_xfer_memory (memaddr, myaddr, len, write, target);

  fprintf_unfiltered (stderr,
		      "target_xfer_memory (0x%x, xxx, %d, %s, xxx) = %d",
		      memaddr, len, write ? "write" : "read", retval);

  if (retval > 0)
    {
      int i;

      fputs_unfiltered (", bytes =", gdb_stderr);
      for (i = 0; i < retval; i++)
	{
	  if ((((long) &(myaddr[i])) & 0xf) == 0)
	    fprintf_unfiltered (stderr, "\n");
	  fprintf_unfiltered (stderr, " %02x", myaddr[i] & 0xff);
	}
    }

  fputc_unfiltered ('\n', gdb_stderr);

  return retval;
}

static void
debug_to_files_info (target)
     struct target_ops *target;
{
  debug_target.to_files_info (target);

  fprintf_unfiltered (stderr, "target_files_info (xxx)\n");
}

static int
debug_to_insert_breakpoint (addr, save)
     CORE_ADDR addr;
     char *save;
{
  int retval;

  retval = debug_target.to_insert_breakpoint (addr, save);

  fprintf_unfiltered (stderr, "target_insert_breakpoint (0x%x, xxx) = %d\n",
		      addr, retval);
  return retval;
}

static int
debug_to_remove_breakpoint (addr, save)
     CORE_ADDR addr;
     char *save;
{
  int retval;

  retval = debug_target.to_remove_breakpoint (addr, save);

  fprintf_unfiltered (stderr, "target_remove_breakpoint (0x%x, xxx) = %d\n",
		      addr, retval);
  return retval;
}

static void
debug_to_terminal_init ()
{
  debug_target.to_terminal_init ();

  fprintf_unfiltered (stderr, "target_terminal_init ()\n");
}

static void
debug_to_terminal_inferior ()
{
  debug_target.to_terminal_inferior ();

  fprintf_unfiltered (stderr, "target_terminal_inferior ()\n");
}

static void
debug_to_terminal_ours_for_output ()
{
  debug_target.to_terminal_ours_for_output ();

  fprintf_unfiltered (stderr, "target_terminal_ours_for_output ()\n");
}

static void
debug_to_terminal_ours ()
{
  debug_target.to_terminal_ours ();

  fprintf_unfiltered (stderr, "target_terminal_ours ()\n");
}

static void
debug_to_terminal_info (arg, from_tty)
     char *arg;
     int from_tty;
{
  debug_target.to_terminal_info (arg, from_tty);

  fprintf_unfiltered (stderr, "target_terminal_info (%s, %d)\n", arg,
		      from_tty);
}

static void
debug_to_kill ()
{
  debug_target.to_kill ();

  fprintf_unfiltered (stderr, "target_kill ()\n");
}

static void
debug_to_load (args, from_tty)
     char *args;
     int from_tty;
{
  debug_target.to_load (args, from_tty);

  fprintf_unfiltered (stderr, "target_load (%s, %d)\n", args, from_tty);
}

static int
debug_to_lookup_symbol (name, addrp)
     char *name;
     CORE_ADDR *addrp;
{
  int retval;

  retval = debug_target.to_lookup_symbol (name, addrp);

  fprintf_unfiltered (stderr, "target_lookup_symbol (%s, xxx)\n", name);

  return retval;
}

static void
debug_to_create_inferior (exec_file, args, env)
     char *exec_file;
     char *args;
     char **env;
{
  debug_target.to_create_inferior (exec_file, args, env);

  fprintf_unfiltered (stderr, "target_create_inferior (%s, %s, xxx)\n",
		      exec_file, args);
}

static void
debug_to_mourn_inferior ()
{
  debug_target.to_mourn_inferior ();

  fprintf_unfiltered (stderr, "target_mourn_inferior ()\n");
}

static int
debug_to_can_run ()
{
  int retval;

  retval = debug_target.to_can_run ();

  fprintf_unfiltered (stderr, "target_can_run () = %d\n", retval);

  return retval;
}

static void
debug_to_notice_signals (pid)
     int pid;
{
  debug_target.to_notice_signals (pid);

  fprintf_unfiltered (stderr, "target_notice_signals (%d)\n", pid);
}

static int
debug_to_thread_alive (pid)
     int pid;
{
  int retval;

  retval = debug_target.to_thread_alive (pid);

  fprintf_unfiltered (stderr, "target_thread_alive (%d) = %d\n", pid, retval);

  return retval;
}

static void
debug_to_stop ()
{
  debug_target.to_stop ();

  fprintf_unfiltered (stderr, "target_stop ()\n");
}

static void
setup_target_debug ()
{
  memcpy (&debug_target, &current_target, sizeof debug_target);

  current_target.to_open = debug_to_open;
  current_target.to_close = debug_to_close;
  current_target.to_attach = debug_to_attach;
  current_target.to_detach = debug_to_detach;
  current_target.to_resume = debug_to_resume;
  current_target.to_wait = debug_to_wait;
  current_target.to_fetch_registers = debug_to_fetch_registers;
  current_target.to_store_registers = debug_to_store_registers;
  current_target.to_prepare_to_store = debug_to_prepare_to_store;
  current_target.to_xfer_memory = debug_to_xfer_memory;
  current_target.to_files_info = debug_to_files_info;
  current_target.to_insert_breakpoint = debug_to_insert_breakpoint;
  current_target.to_remove_breakpoint = debug_to_remove_breakpoint;
  current_target.to_terminal_init = debug_to_terminal_init;
  current_target.to_terminal_inferior = debug_to_terminal_inferior;
  current_target.to_terminal_ours_for_output = debug_to_terminal_ours_for_output;
  current_target.to_terminal_ours = debug_to_terminal_ours;
  current_target.to_terminal_info = debug_to_terminal_info;
  current_target.to_kill = debug_to_kill;
  current_target.to_load = debug_to_load;
  current_target.to_lookup_symbol = debug_to_lookup_symbol;
  current_target.to_create_inferior = debug_to_create_inferior;
  current_target.to_mourn_inferior = debug_to_mourn_inferior;
  current_target.to_can_run = debug_to_can_run;
  current_target.to_notice_signals = debug_to_notice_signals;
  current_target.to_thread_alive = debug_to_thread_alive;
  current_target.to_stop = debug_to_stop;
}
#endif /* MAINTENANCE_CMDS */

static char targ_desc[] = 
    "Names of targets and files being debugged.\n\
Shows the entire stack of targets currently in use (including the exec-file,\n\
core-file, and process, if any), as well as the symbol file name.";

void
initialize_targets ()
{
  push_target (&dummy_target);

  add_info ("target", target_info, targ_desc);
  add_info ("files", target_info, targ_desc);

#ifdef MAINTENANCE_CMDS
  add_show_from_set (
     add_set_cmd ("targetdebug", class_maintenance, var_zinteger,
		  (char *)&targetdebug,
		 "Set target debugging.\n\
When non-zero, target debugging is enabled.", &setlist),
		     &showlist);
#endif

  if (!STREQ (signals[TARGET_SIGNAL_LAST].string, "TARGET_SIGNAL_MAGIC"))
    abort ();
}
@
