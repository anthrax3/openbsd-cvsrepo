head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.22
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.18
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.14
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.16
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.8
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.12
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.10
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.6
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.4
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.14
	OPENBSD_5_0:1.7.0.12
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.10
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.8
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.5.0.2
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	GDB_6_3:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.1.0.26
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.24
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_3:1.1.0.22
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.20
	OPENBSD_3_2_BASE:1.1
	OPENBSD_3_1:1.1.0.18
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.16
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9:1.1.0.14
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_8:1.1.0.12
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.10
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.8
	OPENBSD_2_6:1.1.0.6
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.4
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2012.04.18.19.53.49;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2012.04.08.20.06.49;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.30.09.42.17;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.16.20.50.57;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.20.18.09.04;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2005.07.14.18.54.54;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.27.14.00.40;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.21.20.23.11;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	98.08.07.02.02.32;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.12.27.13.06.05;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Enable multi-threaded debugging on powerpc.
@
text
@/* Native-dependent code for OpenBSD/powerpc.

   Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "defs.h"
#include "gdbcore.h"
#include "inferior.h"
#include "regcache.h"

#include "gdb_assert.h"
#include <stddef.h>
#include <sys/types.h>
#include <sys/ptrace.h>
#include <sys/signal.h>
#include <machine/frame.h>
#include <machine/pcb.h>
#include <machine/reg.h>

#include "obsd-nat.h"
#include "ppc-tdep.h"
#include "ppcobsd-tdep.h"
#include "inf-ptrace.h"
#include "bsd-kvm.h"

/* OpenBSD/powerpc didn't have PT_GETFPREGS/PT_SETFPREGS until release
   4.0.  On older releases the floating-point registers are handled by
   PT_GETREGS/PT_SETREGS, but fpscr wasn't available..  */

#ifdef PT_GETFPREGS

/* Returns true if PT_GETFPREGS fetches this register.  */

static int
getfpregs_supplies (int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  /* FIXME: jimb/2004-05-05: Some PPC variants don't have floating
     point registers.  Traditionally, GDB's register set has still
     listed the floating point registers for such machines, so this
     code is harmless.  However, the new E500 port actually omits the
     floating point registers entirely from the register set --- they
     don't even have register numbers assigned to them.

     It's not clear to me how best to update this code, so this assert
     will alert the first person to encounter the NetBSD/E500
     combination to the problem.  */
  gdb_assert (ppc_floating_point_unit_p (current_gdbarch));

  return ((regnum >= tdep->ppc_fp0_regnum
           && regnum < tdep->ppc_fp0_regnum + ppc_num_fprs)
	  || regnum == tdep->ppc_fpscr_regnum);
}

#endif /* PT_GETFPREGS */

/* Fetch register REGNUM from the inferior.  If REGNUM is -1, do this
   for all registers.  */

static void
ppcobsd_fetch_registers (int regnum)
{
  struct reg regs;
  int pid;

  /* Cater for systems like OpenBSD, that implement threads as
     separate processes.  */
  pid = ptid_get_lwp (inferior_ptid);
  if (pid == 0)
    pid = ptid_get_pid (inferior_ptid);

  if (ptrace (PT_GETREGS, pid, (PTRACE_TYPE_ARG3) &regs, 0) == -1)
    perror_with_name (_("Couldn't get registers"));

  ppc_supply_gregset (&ppcobsd_gregset, current_regcache, -1,
		      &regs, sizeof regs);
#ifndef PT_GETFPREGS
  ppc_supply_fpregset (&ppcobsd_gregset, current_regcache, -1,
		       &regs, sizeof regs);
#endif

#ifdef PT_GETFPREGS
  if (regnum == -1 || getfpregs_supplies (regnum))
    {
      struct fpreg fpregs;

      if (ptrace (PT_GETFPREGS, pid, (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)
	perror_with_name (_("Couldn't get floating point status"));

      ppc_supply_fpregset (&ppcobsd_fpregset, current_regcache, -1,
			   &fpregs, sizeof fpregs);
    }
#endif
}

/* Store register REGNUM back into the inferior.  If REGNUM is -1, do
   this for all registers.  */

static void
ppcobsd_store_registers (int regnum)
{
  struct reg regs;
  int pid;

  /* Cater for systems like OpenBSD, that implement threads as
     separate processes.  */
  pid = ptid_get_lwp (inferior_ptid);
  if (pid == 0)
    pid = ptid_get_pid (inferior_ptid);

  if (ptrace (PT_GETREGS, pid, (PTRACE_TYPE_ARG3) &regs, 0) == -1)
    perror_with_name (_("Couldn't get registers"));

  ppc_collect_gregset (&ppcobsd_gregset, current_regcache,
		       regnum, &regs, sizeof regs);
#ifndef PT_GETFPREGS
  ppc_collect_fpregset (&ppcobsd_gregset, current_regcache,
			regnum, &regs, sizeof regs);
#endif

  if (ptrace (PT_SETREGS, pid, (PTRACE_TYPE_ARG3) &regs, 0) == -1)
    perror_with_name (_("Couldn't write registers"));

#ifdef PT_GETFPREGS
  if (regnum == -1 || getfpregs_supplies (regnum))
    {
      struct fpreg fpregs;

      if (ptrace (PT_GETFPREGS, pid, (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)
	perror_with_name (_("Couldn't get floating point status"));

      ppc_collect_fpregset (&ppcobsd_fpregset, current_regcache,
			    regnum, &fpregs, sizeof fpregs);

      if (ptrace (PT_SETFPREGS, pid, (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)
	perror_with_name (_("Couldn't write floating point status"));
    }
#endif
}


static int
ppcobsd_supply_pcb (struct regcache *regcache, struct pcb *pcb)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
  struct switchframe sf;
  struct callframe cf;
  int i, regnum;

  /* The following is true for OpenBSD 3.7:

     The pcb contains %r1 (the stack pointer) at the point of the
     context switch in cpu_switch().  At that point we have a stack
     frame as described by `struct switchframe', and below that a call
     frame as described by `struct callframe'.  From this information
     we reconstruct the register state as it would look when we are in
     cpu_switch().  */

  /* The stack pointer shouldn't be zero.  */
  if (pcb->pcb_sp == 0)
    return 0;

  read_memory (pcb->pcb_sp, (char *)&sf, sizeof sf);
  regcache_raw_supply (regcache, tdep->ppc_cr_regnum, &sf.cr);
  regcache_raw_supply (regcache, tdep->ppc_gp0_regnum + 2, &sf.fixreg2);
  for (i = 0, regnum = tdep->ppc_gp0_regnum + 13; i < 19; i++, regnum++)
    regcache_raw_supply (regcache, regnum, &sf.fixreg[i]);

  read_memory (sf.sp, (char *)&cf, sizeof cf);
  regcache_raw_supply (regcache, SP_REGNUM, &cf.sp);
  regcache_raw_supply (regcache, tdep->ppc_gp0_regnum + 30, &cf.r30);
  regcache_raw_supply (regcache, tdep->ppc_gp0_regnum + 31, &cf.r31);

  read_memory (cf.sp, (char *)&cf, sizeof cf);
  regcache_raw_supply (regcache, PC_REGNUM, &cf.lr);

  return 1;
}


/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_ppcobsd_nat (void);

void
_initialize_ppcobsd_nat (void)
{
  struct target_ops *t;

  /* Add in local overrides.  */
  t = inf_ptrace_target ();
  t->to_fetch_registers = ppcobsd_fetch_registers;
  t->to_store_registers = ppcobsd_store_registers;
  t->to_pid_to_str = obsd_pid_to_str;
  t->to_find_new_threads = obsd_find_new_threads;
  t->to_wait = obsd_wait;
  add_target (t);

  /* General-purpose registers.  */
  ppcobsd_reg_offsets.r0_offset = offsetof (struct reg, gpr);
  ppcobsd_reg_offsets.pc_offset = offsetof (struct reg, pc);
  ppcobsd_reg_offsets.ps_offset = offsetof (struct reg, ps);
  ppcobsd_reg_offsets.cr_offset = offsetof (struct reg, cnd);
  ppcobsd_reg_offsets.lr_offset = offsetof (struct reg, lr);
  ppcobsd_reg_offsets.ctr_offset = offsetof (struct reg, cnt);
  ppcobsd_reg_offsets.xer_offset = offsetof (struct reg, xer);
  ppcobsd_reg_offsets.mq_offset = offsetof (struct reg, mq);

  /* Floating-point registers.  */
  ppcobsd_reg_offsets.f0_offset = offsetof (struct reg, fpr);
  ppcobsd_reg_offsets.fpscr_offset = -1;
#ifdef PT_GETFPREGS
  ppcobsd_fpreg_offsets.f0_offset = offsetof (struct fpreg, fpr);
  ppcobsd_fpreg_offsets.fpscr_offset = offsetof (struct fpreg, fpscr);
#endif

  /* AltiVec registers.  */
  ppcobsd_reg_offsets.vr0_offset = offsetof (struct vreg, vreg);
  ppcobsd_reg_offsets.vscr_offset = offsetof (struct vreg, vscr);
  ppcobsd_reg_offsets.vrsave_offset = offsetof (struct vreg, vrsave);

  /* Support debugging kernel virtual memory images.  */
  bsd_kvm_add_target (ppcobsd_supply_pcb);
}
@


1.8
log
@Minimal threads debug support for powerpc.
@
text
@d212 1
@


1.7
log
@Turns out we need to look one frame deeper to find the saved return address
from a pcb when debugging a kernel.  Make sure we provide the matching stack
pointer too to avoid duplicating the first frame.  Makes "target kvm" much
more useful on powerpc.
@
text
@d36 1
d81 1
d83 7
a89 2
  if (ptrace (PT_GETREGS, PIDGET (inferior_ptid),
	      (PTRACE_TYPE_ARG3) &regs, 0) == -1)
d104 1
a104 2
      if (ptrace (PT_GETFPREGS, PIDGET (inferior_ptid),
		  (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)
d120 7
d128 1
a128 2
  if (ptrace (PT_GETREGS, PIDGET (inferior_ptid),
	      (PTRACE_TYPE_ARG3) &regs, 0) == -1)
d138 1
a138 2
  if (ptrace (PT_SETREGS, PIDGET (inferior_ptid),
	      (PTRACE_TYPE_ARG3) &regs, 0) == -1)
d146 1
a146 2
      if (ptrace (PT_GETFPREGS, PIDGET (inferior_ptid),
		  (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)
d152 1
a152 2
      if (ptrace (PT_SETFPREGS, PIDGET (inferior_ptid),
		  (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)
d210 2
@


1.6
log
@Bring over upstream changes that fix backtraces through signal handlers and
make us use PT_{GET|SET}FPREGS.
@
text
@a171 1
  regcache_raw_supply (regcache, SP_REGNUM, &sf.sp);
d178 1
a178 1
  regcache_raw_supply (regcache, PC_REGNUM, &cf.lr);
d181 3
@


1.5
log
@Cut powerpc over to inf-ptrace.c, making fork following work.
@
text
@d3 1
a3 1
   Copyright 2004, 2005 Free Software Foundation, Inc.
d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d27 1
d41 31
a71 2
/* OpenBSD/powerpc doesn't have PT_GETFPREGS/PT_SETFPREGS like
   NetBSD/powerpc and FreeBSD/powerpc.  */
d85 20
a104 2
  ppcobsd_supply_gregset (&ppcobsd_gregset, current_regcache, -1,
			  &regs, sizeof regs);
d119 6
a124 2
  ppcobsd_collect_gregset (&ppcobsd_gregset, current_regcache,
			   regnum, &regs, sizeof regs);
d129 18
d214 4
@


1.4
log
@Add support "target kvm" on powerpc.
@
text
@d3 1
a3 1
   Copyright 2004 Free Software Foundation, Inc.
d37 1
d46 2
a47 2
void
fetch_inferior_registers (int regnum)
d53 1
a53 1
    perror_with_name ("Couldn't get registers");
d62 2
a63 2
void
store_inferior_registers (int regnum)
d69 1
a69 1
    perror_with_name ("Couldn't get registers");
d76 1
a76 1
    perror_with_name ("Couldn't write registers");
d123 8
@


1.3
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@d23 1
d30 3
d37 1
d79 37
d140 3
@


1.2
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@a21 2
#include "nm-bsd.h"

d31 1
d33 3
a35 1

d46 1
a46 1
	      (PTRACE_ARG3_TYPE) &regs, 0) == -1)
d62 1
a62 1
	      (PTRACE_ARG3_TYPE) &regs, 0) == -1)
d69 1
a69 1
	      (PTRACE_ARG3_TYPE) &regs, 0) == -1)
@


1.1
log
@Support pieces for gdb to work on the powerpc port.
@
text
@d1 1
a1 2
/* Functions specific to running gdb native on a Powerpc System.
   Copyright (C) 1993, Free Software Foundation, Inc.
d3 1
a3 1
This file is part of GDB.
d5 1
a5 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d7 22
a30 5
#include <sys/param.h>
#include <sys/signal.h>	/* for MAXSIG in sys/user.h */
#include <sys/types.h>	/* for ushort in sys/dir.h */
#include <sys/dir.h>	/* for struct direct in sys/user.h */
#include <sys/user.h>
a31 4
#include "defs.h"
#include "inferior.h"
#include "target.h"
#include "gdbcore.h"
d33 2
a34 1
#include <nlist.h>
d36 2
a37 3
#if !defined (offsetof)
#define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)
#endif
d40 1
a40 2
fetch_inferior_registers (regno)
     int regno;
d42 1
a42 1
  struct reg inferior_registers;
d44 3
a46 3
/* 
 * this gets fp and gpr?
 */
d48 3
a50 4
  ptrace (PT_GETREGS, inferior_pid,
	  (PTRACE_ARG3_TYPE) &inferior_registers, 0);
  memcpy (&registers, &inferior_registers,
	  sizeof(inferior_registers));
d52 2
a53 3

  registers_fetched ();
}
d56 1
a56 2
store_inferior_registers (regno)
     int regno;
d58 1
a58 1
  struct reg inferior_registers;
d60 12
d73 2
a74 4
  memcpy (&inferior_registers, &registers,
	  sizeof(inferior_registers));
  ptrace (PT_SETREGS, inferior_pid,
	  (PTRACE_ARG3_TYPE) &inferior_registers, 0);
d76 2
a77 8
}
/* Return the address in the core dump or inferior of register REGNO.
   BLOCKEND is the address of the end of the user structure.  */

CORE_ADDR
register_addr (regno, blockend)
     int	regno;
     CORE_ADDR	blockend;
d79 18
a96 24
	int ppcreg[] = 
	{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* fp 0-15 */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* fp 16-31 */
	   36,    37,   33,    32,    35,    34 ,   0 };
	/* "pc", "ps", "cnd", "lr", "cnt", "xer", "mq" */
	/*
	32 lr
	33 cr
	34 xer
	35 ctr
	36 srr0
	37 srr1
	*/
  if (regno < NUM_REGS) {
    return (blockend + REGISTER_BYTE(regno));
  } else
    {
      fprintf_unfiltered (gdb_stderr, "\
Internal error: invalid register number %d in REGISTER_U_ADDR\n",
	       regno);
      return blockend;
    }
@


1.1.1.1
log
@GDB 6.3 (excluding .info files)
@
text
@d1 2
a2 1
/* Native-dependent code for OpenBSD/powerpc.
d4 1
a4 1
   Copyright 2004 Free Software Foundation, Inc.
d6 13
a18 1
   This file is part of GDB.
a19 20
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "inferior.h"
#include "regcache.h"

#include <stddef.h>
d22 5
d28 4
d33 1
a33 5
#include "ppc-tdep.h"
#include "ppcobsd-tdep.h"

/* OpenBSD/powerpc doesn't have PT_GETFPREGS/PT_SETFPREGS like
   NetBSD/powerpc and FreeBSD/powerpc.  */
d35 3
a37 2
/* Fetch register REGNUM from the inferior.  If REGNUM is -1, do this
   for all registers.  */
d40 2
a41 1
fetch_inferior_registers (int regnum)
d43 1
a43 1
  struct reg regs;
d45 3
a47 3
  if (ptrace (PT_GETREGS, PIDGET (inferior_ptid),
	      (PTRACE_TYPE_ARG3) &regs, 0) == -1)
    perror_with_name ("Couldn't get registers");
d49 7
a55 2
  ppcobsd_supply_gregset (&ppcobsd_gregset, current_regcache, -1,
			  &regs, sizeof regs);
a57 3
/* Store register REGNUM back into the inferior.  If REGNUM is -1, do
   this for all registers.  */

d59 2
a60 1
store_inferior_registers (int regnum)
d62 7
a68 1
  struct reg regs;
a69 10
  if (ptrace (PT_GETREGS, PIDGET (inferior_ptid),
	      (PTRACE_TYPE_ARG3) &regs, 0) == -1)
    perror_with_name ("Couldn't get registers");

  ppcobsd_collect_gregset (&ppcobsd_gregset, current_regcache,
			   regnum, &regs, sizeof regs);

  if (ptrace (PT_SETREGS, PIDGET (inferior_ptid),
	      (PTRACE_TYPE_ARG3) &regs, 0) == -1)
    perror_with_name ("Couldn't write registers");
d71 2
a72 4


/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_ppcobsd_nat (void);
d74 4
a77 2
void
_initialize_ppcobsd_nat (void)
d79 24
a102 18
  /* General-purpose registers.  */
  ppcobsd_reg_offsets.r0_offset = offsetof (struct reg, gpr);
  ppcobsd_reg_offsets.pc_offset = offsetof (struct reg, pc);
  ppcobsd_reg_offsets.ps_offset = offsetof (struct reg, ps);
  ppcobsd_reg_offsets.cr_offset = offsetof (struct reg, cnd);
  ppcobsd_reg_offsets.lr_offset = offsetof (struct reg, lr);
  ppcobsd_reg_offsets.ctr_offset = offsetof (struct reg, cnt);
  ppcobsd_reg_offsets.xer_offset = offsetof (struct reg, xer);
  ppcobsd_reg_offsets.mq_offset = offsetof (struct reg, mq);

  /* Floating-point registers.  */
  ppcobsd_reg_offsets.f0_offset = offsetof (struct reg, fpr);
  ppcobsd_reg_offsets.fpscr_offset = -1;

  /* AltiVec registers.  */
  ppcobsd_reg_offsets.vr0_offset = offsetof (struct vreg, vreg);
  ppcobsd_reg_offsets.vscr_offset = offsetof (struct vreg, vscr);
  ppcobsd_reg_offsets.vrsave_offset = offsetof (struct vreg, vrsave);
@


