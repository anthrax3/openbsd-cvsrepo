head	1.4;
access;
symbols
	OPENBSD_6_1:1.4.0.50
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.48
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.44
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.46
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.38
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.42
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.40
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.36
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.34
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.32
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.30
	OPENBSD_5_0:1.4.0.28
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.26
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.24
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2004.12.27.14.00.44;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.21.20.23.16;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.40.31;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.21.30;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.14.01;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.08.42;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.21.30;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@/* Shared library support for RS/6000 (xcoff) object files, for GDB.
   Copyright 1991, 1992, 1995, 1996, 1999, 2000, 2001
   Free Software Foundation, Inc.
   Contributed by IBM Corporation.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "bfd.h"
#include "xcoffsolib.h"
#include "inferior.h"
#include "gdbcmd.h"
#include "symfile.h"
#include "frame.h"
#include "gdb_regex.h"


/* If ADDR lies in a shared library, return its name.
   Note that returned name points to static data whose content is overwritten
   by each call.  */

char *
xcoff_solib_address (CORE_ADDR addr)
{
  static char *buffer = NULL;
  struct vmap *vp = vmap;

  /* The first vmap entry is for the exec file.  */

  if (vp == NULL)
    return NULL;
  for (vp = vp->nxt; vp; vp = vp->nxt)
    if (vp->tstart <= addr && addr < vp->tend)
      {
	xfree (buffer);
	buffer = xstrprintf ("%s%s%s%s",
			     vp->name,
			     *vp->member ? "(" : "",
			     vp->member,
			     *vp->member ? ")" : "");
	return buffer;
      }
  return NULL;
}

static void solib_info (char *, int);
static void sharedlibrary_command (char *pattern, int from_tty);

static void
solib_info (char *args, int from_tty)
{
  struct vmap *vp = vmap;

  /* Check for new shared libraries loaded with load ().  */
  if (! ptid_equal (inferior_ptid, null_ptid))
    xcoff_relocate_symtab (PIDGET (inferior_ptid));

  if (vp == NULL || vp->nxt == NULL)
    {
      printf_unfiltered ("No shared libraries loaded at this time.\n");
      return;
    }

  /* Skip over the first vmap, it is the main program, always loaded.  */
  vp = vp->nxt;

  printf_unfiltered ("\
Text Range		Data Range		Syms	Shared Object Library\n");

  for (; vp != NULL; vp = vp->nxt)
    {
      printf_unfiltered ("0x%s-0x%s	0x%s-0x%s	%s	%s%s%s%s\n",
			 paddr (vp->tstart),paddr (vp->tend),
			 paddr (vp->dstart), paddr (vp->dend),
			 vp->loaded ? "Yes" : "No ",
			 vp->name,
			 *vp->member ? "(" : "",
			 vp->member,
			 *vp->member ? ")" : "");
    }
}

static void
sharedlibrary_command (char *pattern, int from_tty)
{
  dont_repeat ();

  /* Check for new shared libraries loaded with load ().  */
  if (! ptid_equal (inferior_ptid, null_ptid))
    xcoff_relocate_symtab (PIDGET (inferior_ptid));

  if (pattern)
    {
      char *re_err = re_comp (pattern);

      if (re_err)
	error ("Invalid regexp: %s", re_err);
    }

  /* Walk the list of currently loaded shared libraries, and read
     symbols for any that match the pattern --- or any whose symbols
     aren't already loaded, if no pattern was given.  */
  {
    int any_matches = 0;
    int loaded_any_symbols = 0;
    struct vmap *vp = vmap;

    if (!vp)
      return;

    /* skip over the first vmap, it is the main program, always loaded. */
    for (vp = vp->nxt; vp; vp = vp->nxt)
      if (! pattern
	    || re_exec (vp->name)
	    || (*vp->member && re_exec (vp->member)))
	{
	  any_matches = 1;

	  if (vp->loaded)
	    {
	      if (from_tty)
		printf_unfiltered ("Symbols already loaded for %s\n",
				   vp->name);
	    }
	  else
	    {
	      if (vmap_add_symbols (vp))
		loaded_any_symbols = 1;
	    }
	}

    if (from_tty && pattern && ! any_matches)
      printf_unfiltered
	("No loaded shared libraries match the pattern `%s'.\n", pattern);

    if (loaded_any_symbols)
      {
	/* Getting new symbols may change our opinion about what is
	   frameless.  */
	reinit_frame_cache ();
      }
  }
}

/* LOCAL FUNCTION

   no_shared_libraries -- handle command to explicitly discard symbols
   from shared libraries.

   DESCRIPTION

   Implements the command "nosharedlibrary", which discards symbols
   that have been auto-loaded from shared libraries.  Symbols from
   shared libraries that were added by explicit request of the user
   are not discarded.  Also called from remote.c.  */

void
no_shared_libraries (char *ignored, int from_tty)
{
  /* FIXME */
}

void
_initialize_xcoffsolib (void)
{
  add_com ("sharedlibrary", class_files, sharedlibrary_command,
	   "Load shared object library symbols for files matching REGEXP.");
  add_info ("sharedlibrary", solib_info,
	    "Status of loaded shared object libraries");

  deprecated_add_show_from_set
    (add_set_cmd ("auto-solib-add", class_support, var_boolean,
		  (char *) &auto_solib_add,
		  "Set autoloading of shared library symbols.\n\
If \"on\", symbols from all shared object libraries will be loaded\n\
automatically when the inferior begins execution, when the dynamic linker\n\
informs gdb that a new library has been loaded, or when attaching to the\n\
inferior.  Otherwise, symbols must be loaded manually, using `sharedlibrary'.",
		  &setlist),
     &showlist);
}
@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@d51 5
a55 5
	xasprintf (&buffer, "%s%s%s%s",
			    vp->name,
			    *vp->member ? "(" : "",
			    vp->member,
			    *vp->member ? ")" : "");
d186 1
a186 1
  add_show_from_set
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright 1991, 1992 Free Software Foundation.
d6 1
a6 1
This file is part of GDB.
d8 14
a21 18
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#if 0
#include <sys/types.h>
#include <sys/ldr.h>
#endif
d27 4
a30 1
#include "command.h"
a31 3
/* Hook to relocate symbols at runtime.  If gdb is build natively, this
   hook is initialized in by rs6000-nat.c.  If not, it is currently left
   NULL and never called. */
d33 3
a35 1
void (*xcoff_relocate_symtab_hook) PARAMS ((unsigned int)) = NULL;
d37 4
a40 15
#ifdef SOLIB_SYMBOLS_MANUAL

extern struct symtab *current_source_symtab;
extern int	      current_source_line;

/* The real work of adding a shared library file to the symtab and
   the section list.  */

void
solib_add (arg_string, from_tty, target)
     char *arg_string;
     int from_tty;
     struct target_ops *target;
{	
  char *val;
a41 14
  struct objfile *obj;
  struct symtab *saved_symtab;
  int saved_line;

  int loaded = 0;			/* true if any shared obj loaded */
  int matched = 0;			/* true if any shared obj matched */

  if (arg_string == 0)
      re_comp (".");
  else if (val = (char *) re_comp (arg_string)) {
      error ("Invalid regexp: %s", val);
  }
  if (!vp || !vp->nxt)
    return;
d43 1
a43 5
  /* save current symbol table and line number, in case they get changed
     in symbol loading process. */
 
  saved_symtab = current_source_symtab;
  saved_line = current_source_line;
d45 12
a56 18
  /* skip over the first vmap, it is the main program, always loaded. */
  vp = vp->nxt;

  for (; vp; vp = vp->nxt) {

    if (re_exec (vp->name) || (*vp->member && re_exec (vp->member))) {

      matched = 1;

      /* if already loaded, continue with the next one. */
      if (vp->loaded) {
	
	printf_unfiltered ("%s%s%s%s: already loaded.\n",
	  *vp->member ? "(" : "",
	  vp->member,
	  *vp->member ? ") " : "",
	  vp->name);
	continue;
d58 1
a58 38

      printf_unfiltered ("Loading  %s%s%s%s...",
	  *vp->member ? "(" : "",
	  vp->member,
	  *vp->member ? ") " : "",
	  vp->name);
      gdb_flush (gdb_stdout);

      /* This is gross and doesn't work.  If this code is re-enabled,
	 just stick a objfile member into the struct vmap; that's the
	 way solib.c (for SunOS/SVR4) does it.  */
	obj = lookup_objfile_bfd (vp->bfd);
	if (!obj) {
	  warning ("\nObj structure for the shared object not found. Loading failed.");
	  continue;
	}

	syms_from_objfile (obj, 0, 0, 0);
	new_symfile_objfile (obj, 0, 0);
	vmap_symtab (vp, 0, 0);
	printf_unfiltered ("Done.\n");
	loaded = vp->loaded = 1;
    }
  }
  /* if any shared object is loaded, then misc_func_vector needs sorting. */
  if (loaded) {
#if 0
    sort_misc_function_vector ();
#endif
    current_source_symtab = saved_symtab;
    current_source_line = saved_line;

    /* Getting new symbols might change our opinion about what is frameless.
       Is this correct?? FIXME. */
/*    reinit_frame_cache(); */
  }
  else if (!matched)
    printf_unfiltered ("No matching shared object found.\n");
a59 1
#endif /* SOLIB_SYMBOLS_MANUAL */
d61 2
a62 25
/* Return the module name of a given text address. Note that returned buffer
   is not persistent. */

char *
pc_load_segment_name (addr)
CORE_ADDR addr;
{
   static char buffer [BUFSIZ];
   struct vmap *vp = vmap;

   buffer [0] = buffer [1] = '\0';
   for (; vp; vp = vp->nxt)
     if (vp->tstart <= addr && addr < vp->tend) {
	if (*vp->member) {
	  buffer [0] = '(';
	  strcat (&buffer[1], vp->member);
	  strcat (buffer, ")");
	}
	strcat (buffer, vp->name);
	return buffer;
     }
   return "(unknown load module)";
}

static void solib_info PARAMS ((char *, int));
d65 1
a65 3
solib_info (args, from_tty)
     char *args;
     int from_tty;
d70 2
a71 2
  if (xcoff_relocate_symtab_hook != NULL)
    (*xcoff_relocate_symtab_hook) (inferior_pid);
d75 1
a75 1
      printf_unfiltered ("No shared libraries loaded at this time.\n");	
d87 3
a89 3
      printf_unfiltered ("0x%08x-0x%08x	0x%08x-0x%08x	%s	%s%s%s%s\n",
			 vp->tstart, vp->tend,
			 vp->dstart, vp->dend,
d91 1
d94 1
a94 2
			 *vp->member ? ") " : "",
			 vp->name);
d98 2
a99 4
void
sharedlibrary_command (args, from_tty)
     char *args;
     int from_tty;
d104 57
a160 2
  if (xcoff_relocate_symtab_hook != NULL)
    (*xcoff_relocate_symtab_hook) (inferior_pid);
d162 14
a175 3
#ifdef SOLIB_SYMBOLS_MANUAL
  solib_add (args, from_tty, (struct target_ops *)0);
#endif /* SOLIB_SYMBOLS_MANUAL */
d179 1
a179 1
_initialize_solib()
d183 1
a183 1
  add_info ("sharedlibrary", solib_info, 
d185 11
@


1.1
log
@file xcoffsolib.c was initially added on branch CYGNUS.
@
text
@d1 220
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 196
/* Shared library support for RS/6000 (xcoff) object files, for GDB.
   Copyright 1991, 1992, 1995, 1996, 1999, 2000, 2001
   Free Software Foundation, Inc.
   Contributed by IBM Corporation.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "bfd.h"
#include "xcoffsolib.h"
#include "inferior.h"
#include "gdbcmd.h"
#include "symfile.h"
#include "frame.h"
#include "gdb_regex.h"


/* If ADDR lies in a shared library, return its name.
   Note that returned name points to static data whose content is overwritten
   by each call.  */

char *
xcoff_solib_address (CORE_ADDR addr)
{
  static char *buffer = NULL;
  struct vmap *vp = vmap;

  /* The first vmap entry is for the exec file.  */

  if (vp == NULL)
    return NULL;
  for (vp = vp->nxt; vp; vp = vp->nxt)
    if (vp->tstart <= addr && addr < vp->tend)
      {
	xfree (buffer);
	xasprintf (&buffer, "%s%s%s%s",
			    vp->name,
			    *vp->member ? "(" : "",
			    vp->member,
			    *vp->member ? ")" : "");
	return buffer;
      }
  return NULL;
}

static void solib_info (char *, int);
static void sharedlibrary_command (char *pattern, int from_tty);

static void
solib_info (char *args, int from_tty)
{
  struct vmap *vp = vmap;

  /* Check for new shared libraries loaded with load ().  */
  if (! ptid_equal (inferior_ptid, null_ptid))
    xcoff_relocate_symtab (PIDGET (inferior_ptid));

  if (vp == NULL || vp->nxt == NULL)
    {
      printf_unfiltered ("No shared libraries loaded at this time.\n");
      return;
    }

  /* Skip over the first vmap, it is the main program, always loaded.  */
  vp = vp->nxt;

  printf_unfiltered ("\
Text Range		Data Range		Syms	Shared Object Library\n");

  for (; vp != NULL; vp = vp->nxt)
    {
      printf_unfiltered ("0x%s-0x%s	0x%s-0x%s	%s	%s%s%s%s\n",
			 paddr (vp->tstart),paddr (vp->tend),
			 paddr (vp->dstart), paddr (vp->dend),
			 vp->loaded ? "Yes" : "No ",
			 vp->name,
			 *vp->member ? "(" : "",
			 vp->member,
			 *vp->member ? ")" : "");
    }
}

static void
sharedlibrary_command (char *pattern, int from_tty)
{
  dont_repeat ();

  /* Check for new shared libraries loaded with load ().  */
  if (! ptid_equal (inferior_ptid, null_ptid))
    xcoff_relocate_symtab (PIDGET (inferior_ptid));

  if (pattern)
    {
      char *re_err = re_comp (pattern);

      if (re_err)
	error ("Invalid regexp: %s", re_err);
    }

  /* Walk the list of currently loaded shared libraries, and read
     symbols for any that match the pattern --- or any whose symbols
     aren't already loaded, if no pattern was given.  */
  {
    int any_matches = 0;
    int loaded_any_symbols = 0;
    struct vmap *vp = vmap;

    if (!vp)
      return;

    /* skip over the first vmap, it is the main program, always loaded. */
    for (vp = vp->nxt; vp; vp = vp->nxt)
      if (! pattern
	    || re_exec (vp->name)
	    || (*vp->member && re_exec (vp->member)))
	{
	  any_matches = 1;

	  if (vp->loaded)
	    {
	      if (from_tty)
		printf_unfiltered ("Symbols already loaded for %s\n",
				   vp->name);
	    }
	  else
	    {
	      if (vmap_add_symbols (vp))
		loaded_any_symbols = 1;
	    }
	}

    if (from_tty && pattern && ! any_matches)
      printf_unfiltered
	("No loaded shared libraries match the pattern `%s'.\n", pattern);

    if (loaded_any_symbols)
      {
	/* Getting new symbols may change our opinion about what is
	   frameless.  */
	reinit_frame_cache ();
      }
  }
}

/* LOCAL FUNCTION

   no_shared_libraries -- handle command to explicitly discard symbols
   from shared libraries.

   DESCRIPTION

   Implements the command "nosharedlibrary", which discards symbols
   that have been auto-loaded from shared libraries.  Symbols from
   shared libraries that were added by explicit request of the user
   are not discarded.  Also called from remote.c.  */

void
no_shared_libraries (char *ignored, int from_tty)
{
  /* FIXME */
}

void
_initialize_xcoffsolib (void)
{
  add_com ("sharedlibrary", class_files, sharedlibrary_command,
	   "Load shared object library symbols for files matching REGEXP.");
  add_info ("sharedlibrary", solib_info,
	    "Status of loaded shared object libraries");

  add_show_from_set
    (add_set_cmd ("auto-solib-add", class_support, var_boolean,
		  (char *) &auto_solib_add,
		  "Set autoloading of shared library symbols.\n\
If \"on\", symbols from all shared object libraries will be loaded\n\
automatically when the inferior begins execution, when the dynamic linker\n\
informs gdb that a new library has been loaded, or when attaching to the\n\
inferior.  Otherwise, symbols must be loaded manually, using `sharedlibrary'.",
		  &setlist),
     &showlist);
}
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d51 5
a55 5
	buffer = xstrprintf ("%s%s%s%s",
			     vp->name,
			     *vp->member ? "(" : "",
			     vp->member,
			     *vp->member ? ")" : "");
d186 1
a186 1
  deprecated_add_show_from_set
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 220
/* Shared library support for RS/6000 (xcoff) object files, for GDB.
   Copyright 1991, 1992 Free Software Foundation.
   Contributed by IBM Corporation.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#if 0
#include <sys/types.h>
#include <sys/ldr.h>
#endif

#include "defs.h"
#include "bfd.h"
#include "xcoffsolib.h"
#include "inferior.h"
#include "command.h"

/* Hook to relocate symbols at runtime.  If gdb is build natively, this
   hook is initialized in by rs6000-nat.c.  If not, it is currently left
   NULL and never called. */

void (*xcoff_relocate_symtab_hook) PARAMS ((unsigned int)) = NULL;

#ifdef SOLIB_SYMBOLS_MANUAL

extern struct symtab *current_source_symtab;
extern int	      current_source_line;

/* The real work of adding a shared library file to the symtab and
   the section list.  */

void
solib_add (arg_string, from_tty, target)
     char *arg_string;
     int from_tty;
     struct target_ops *target;
{	
  char *val;
  struct vmap *vp = vmap;
  struct objfile *obj;
  struct symtab *saved_symtab;
  int saved_line;

  int loaded = 0;			/* true if any shared obj loaded */
  int matched = 0;			/* true if any shared obj matched */

  if (arg_string == 0)
      re_comp (".");
  else if (val = (char *) re_comp (arg_string)) {
      error ("Invalid regexp: %s", val);
  }
  if (!vp || !vp->nxt)
    return;

  /* save current symbol table and line number, in case they get changed
     in symbol loading process. */
 
  saved_symtab = current_source_symtab;
  saved_line = current_source_line;

  /* skip over the first vmap, it is the main program, always loaded. */
  vp = vp->nxt;

  for (; vp; vp = vp->nxt) {

    if (re_exec (vp->name) || (*vp->member && re_exec (vp->member))) {

      matched = 1;

      /* if already loaded, continue with the next one. */
      if (vp->loaded) {
	
	printf_unfiltered ("%s%s%s%s: already loaded.\n",
	  *vp->member ? "(" : "",
	  vp->member,
	  *vp->member ? ") " : "",
	  vp->name);
	continue;
      }

      printf_unfiltered ("Loading  %s%s%s%s...",
	  *vp->member ? "(" : "",
	  vp->member,
	  *vp->member ? ") " : "",
	  vp->name);
      gdb_flush (gdb_stdout);

      /* This is gross and doesn't work.  If this code is re-enabled,
	 just stick a objfile member into the struct vmap; that's the
	 way solib.c (for SunOS/SVR4) does it.  */
	obj = lookup_objfile_bfd (vp->bfd);
	if (!obj) {
	  warning ("\nObj structure for the shared object not found. Loading failed.");
	  continue;
	}

	syms_from_objfile (obj, 0, 0, 0);
	new_symfile_objfile (obj, 0, 0);
	vmap_symtab (vp, 0, 0);
	printf_unfiltered ("Done.\n");
	loaded = vp->loaded = 1;
    }
  }
  /* if any shared object is loaded, then misc_func_vector needs sorting. */
  if (loaded) {
#if 0
    sort_misc_function_vector ();
#endif
    current_source_symtab = saved_symtab;
    current_source_line = saved_line;

    /* Getting new symbols might change our opinion about what is frameless.
       Is this correct?? FIXME. */
/*    reinit_frame_cache(); */
  }
  else if (!matched)
    printf_unfiltered ("No matching shared object found.\n");
}
#endif /* SOLIB_SYMBOLS_MANUAL */

/* Return the module name of a given text address. Note that returned buffer
   is not persistent. */

char *
pc_load_segment_name (addr)
CORE_ADDR addr;
{
   static char buffer [BUFSIZ];
   struct vmap *vp = vmap;

   buffer [0] = buffer [1] = '\0';
   for (; vp; vp = vp->nxt)
     if (vp->tstart <= addr && addr < vp->tend) {
	if (*vp->member) {
	  buffer [0] = '(';
	  strcat (&buffer[1], vp->member);
	  strcat (buffer, ")");
	}
	strcat (buffer, vp->name);
	return buffer;
     }
   return "(unknown load module)";
}

static void solib_info PARAMS ((char *, int));

static void
solib_info (args, from_tty)
     char *args;
     int from_tty;
{
  struct vmap *vp = vmap;

  /* Check for new shared libraries loaded with load ().  */
  if (xcoff_relocate_symtab_hook != NULL)
    (*xcoff_relocate_symtab_hook) (inferior_pid);

  if (vp == NULL || vp->nxt == NULL)
    {
      printf_unfiltered ("No shared libraries loaded at this time.\n");	
      return;
    }

  /* Skip over the first vmap, it is the main program, always loaded.  */
  vp = vp->nxt;

  printf_unfiltered ("\
Text Range		Data Range		Syms	Shared Object Library\n");

  for (; vp != NULL; vp = vp->nxt)
    {
      printf_unfiltered ("0x%08x-0x%08x	0x%08x-0x%08x	%s	%s%s%s%s\n",
			 vp->tstart, vp->tend,
			 vp->dstart, vp->dend,
			 vp->loaded ? "Yes" : "No ",
			 *vp->member ? "(" : "",
			 vp->member,
			 *vp->member ? ") " : "",
			 vp->name);
    }
}

void
sharedlibrary_command (args, from_tty)
     char *args;
     int from_tty;
{
  dont_repeat ();

  /* Check for new shared libraries loaded with load ().  */
  if (xcoff_relocate_symtab_hook != NULL)
    (*xcoff_relocate_symtab_hook) (inferior_pid);

#ifdef SOLIB_SYMBOLS_MANUAL
  solib_add (args, from_tty, (struct target_ops *)0);
#endif /* SOLIB_SYMBOLS_MANUAL */
}

void
_initialize_solib()
{
  add_com ("sharedlibrary", class_files, sharedlibrary_command,
	   "Load shared object library symbols for files matching REGEXP.");
  add_info ("sharedlibrary", solib_info, 
	    "Status of loaded shared object libraries");
}
@
