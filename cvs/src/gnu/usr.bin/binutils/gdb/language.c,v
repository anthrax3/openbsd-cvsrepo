head	1.4;
access;
symbols
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.52
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.48
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.44
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.46
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.38
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.42
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.40
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.36
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.34
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.32
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.30
	OPENBSD_5_0:1.4.0.28
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.26
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.24
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2004.12.27.14.00.37;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.21.20.23.09;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.38.13;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.18.40;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.11.31;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.11.14;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.18.41;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@/* Multiple source language support for GDB.

   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.

   Contributed by the Department of Computer Science at the State University
   of New York at Buffalo.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* This file contains functions that return things that are specific
   to languages.  Each function should examine current_language if necessary,
   and return the appropriate result. */

/* FIXME:  Most of these would be better organized as macros which
   return data out of a "language-specific" struct pointer that is set
   whenever the working language changes.  That would be a lot faster.  */

#include "defs.h"
#include <ctype.h>
#include "gdb_string.h"

#include "symtab.h"
#include "gdbtypes.h"
#include "value.h"
#include "gdbcmd.h"
#include "expression.h"
#include "language.h"
#include "target.h"
#include "parser-defs.h"
#include "jv-lang.h"
#include "demangle.h"

extern void _initialize_language (void);

static void show_language_command (char *, int);

static void set_language_command (char *, int);

static void show_type_command (char *, int);

static void set_type_command (char *, int);

static void show_range_command (char *, int);

static void set_range_command (char *, int);

static void show_case_command (char *, int);

static void set_case_command (char *, int);

static void set_case_str (void);

static void set_range_str (void);

static void set_type_str (void);

static void set_lang_str (void);

static void unk_lang_error (char *);

static int unk_lang_parser (void);

static void show_check (char *, int);

static void set_check (char *, int);

static void set_type_range_case (void);

static void unk_lang_emit_char (int c, struct ui_file *stream, int quoter);

static void unk_lang_printchar (int c, struct ui_file *stream);

static void unk_lang_printstr (struct ui_file * stream, char *string,
			       unsigned int length, int width,
			       int force_ellipses);

static struct type *unk_lang_create_fundamental_type (struct objfile *, int);

static void unk_lang_print_type (struct type *, char *, struct ui_file *,
				 int, int);

static int unk_lang_val_print (struct type *, char *, int, CORE_ADDR,
			       struct ui_file *, int, int, int,
			       enum val_prettyprint);

static int unk_lang_value_print (struct value *, struct ui_file *, int, enum val_prettyprint);

static CORE_ADDR unk_lang_trampoline (CORE_ADDR pc);

/* Forward declaration */
extern const struct language_defn unknown_language_defn;

/* The current (default at startup) state of type and range checking.
   (If the modes are set to "auto", though, these are changed based
   on the default language at startup, and then again based on the
   language of the first source file.  */

enum range_mode range_mode = range_mode_auto;
enum range_check range_check = range_check_off;
enum type_mode type_mode = type_mode_auto;
enum type_check type_check = type_check_off;
enum case_mode case_mode = case_mode_auto;
enum case_sensitivity case_sensitivity = case_sensitive_on;

/* The current language and language_mode (see language.h) */

const struct language_defn *current_language = &unknown_language_defn;
enum language_mode language_mode = language_mode_auto;

/* The language that the user expects to be typing in (the language
   of main(), or the last language we notified them about, or C).  */

const struct language_defn *expected_language;

/* The list of supported languages.  The list itself is malloc'd.  */

static const struct language_defn **languages;
static unsigned languages_size;
static unsigned languages_allocsize;
#define	DEFAULT_ALLOCSIZE 4

/* The "set language/type/range" commands all put stuff in these
   buffers.  This is to make them work as set/show commands.  The
   user's string is copied here, then the set_* commands look at
   them and update them to something that looks nice when it is
   printed out. */

static char *language;
static char *type;
static char *range;
static char *case_sensitive;

/* Warning issued when current_language and the language of the current
   frame do not match. */
char lang_frame_mismatch_warn[] =
"Warning: the current language does not match this frame.";

/* This page contains the functions corresponding to GDB commands
   and their helpers. */

/* Show command.  Display a warning if the language set
   does not match the frame. */
static void
show_language_command (char *ignore, int from_tty)
{
  enum language flang;		/* The language of the current frame */

  flang = get_frame_language ();
  if (flang != language_unknown &&
      language_mode == language_mode_manual &&
      current_language->la_language != flang)
    printf_filtered ("%s\n", lang_frame_mismatch_warn);
}

/* Set command.  Change the current working language. */
static void
set_language_command (char *ignore, int from_tty)
{
  int i;
  enum language flang;
  char *err_lang;

  if (!language || !language[0])
    {
      printf_unfiltered ("The currently understood settings are:\n\n");
      printf_unfiltered ("local or auto    Automatic setting based on source file\n");

      for (i = 0; i < languages_size; ++i)
	{
	  /* Already dealt with these above.  */
	  if (languages[i]->la_language == language_unknown
	      || languages[i]->la_language == language_auto)
	    continue;

	  /* FIXME for now assume that the human-readable name is just
	     a capitalization of the internal name.  */
	  printf_unfiltered ("%-16s Use the %c%s language\n",
			     languages[i]->la_name,
	  /* Capitalize first letter of language
	     name.  */
			     toupper (languages[i]->la_name[0]),
			     languages[i]->la_name + 1);
	}
      /* Restore the silly string. */
      set_language (current_language->la_language);
      return;
    }

  /* Search the list of languages for a match.  */
  for (i = 0; i < languages_size; i++)
    {
      if (strcmp (languages[i]->la_name, language) == 0)
	{
	  /* Found it!  Go into manual mode, and use this language.  */
	  if (languages[i]->la_language == language_auto)
	    {
	      /* Enter auto mode.  Set to the current frame's language, if known.  */
	      language_mode = language_mode_auto;
	      flang = get_frame_language ();
	      if (flang != language_unknown)
		set_language (flang);
	      expected_language = current_language;
	      return;
	    }
	  else
	    {
	      /* Enter manual mode.  Set the specified language.  */
	      language_mode = language_mode_manual;
	      current_language = languages[i];
	      set_type_range_case ();
	      set_lang_str ();
	      expected_language = current_language;
	      return;
	    }
	}
    }

  /* Reset the language (esp. the global string "language") to the 
     correct values. */
  err_lang = savestring (language, strlen (language));
  make_cleanup (xfree, err_lang);	/* Free it after error */
  set_language (current_language->la_language);
  error ("Unknown language `%s'.", err_lang);
}

/* Show command.  Display a warning if the type setting does
   not match the current language. */
static void
show_type_command (char *ignore, int from_tty)
{
  if (type_check != current_language->la_type_check)
    printf_unfiltered (
			"Warning: the current type check setting does not match the language.\n");
}

/* Set command.  Change the setting for type checking. */
static void
set_type_command (char *ignore, int from_tty)
{
  if (strcmp (type, "on") == 0)
    {
      type_check = type_check_on;
      type_mode = type_mode_manual;
    }
  else if (strcmp (type, "warn") == 0)
    {
      type_check = type_check_warn;
      type_mode = type_mode_manual;
    }
  else if (strcmp (type, "off") == 0)
    {
      type_check = type_check_off;
      type_mode = type_mode_manual;
    }
  else if (strcmp (type, "auto") == 0)
    {
      type_mode = type_mode_auto;
      set_type_range_case ();
      /* Avoid hitting the set_type_str call below.  We
         did it in set_type_range_case. */
      return;
    }
  else
    {
      warning ("Unrecognized type check setting: \"%s\"", type);
    }
  set_type_str ();
  show_type_command ((char *) NULL, from_tty);
}

/* Show command.  Display a warning if the range setting does
   not match the current language. */
static void
show_range_command (char *ignore, int from_tty)
{

  if (range_check != current_language->la_range_check)
    printf_unfiltered (
			"Warning: the current range check setting does not match the language.\n");
}

/* Set command.  Change the setting for range checking. */
static void
set_range_command (char *ignore, int from_tty)
{
  if (strcmp (range, "on") == 0)
    {
      range_check = range_check_on;
      range_mode = range_mode_manual;
    }
  else if (strcmp (range, "warn") == 0)
    {
      range_check = range_check_warn;
      range_mode = range_mode_manual;
    }
  else if (strcmp (range, "off") == 0)
    {
      range_check = range_check_off;
      range_mode = range_mode_manual;
    }
  else if (strcmp (range, "auto") == 0)
    {
      range_mode = range_mode_auto;
      set_type_range_case ();
      /* Avoid hitting the set_range_str call below.  We
         did it in set_type_range_case. */
      return;
    }
  else
    {
      warning ("Unrecognized range check setting: \"%s\"", range);
    }
  set_range_str ();
  show_range_command ((char *) 0, from_tty);
}

/* Show command.  Display a warning if the case sensitivity setting does
   not match the current language. */
static void
show_case_command (char *ignore, int from_tty)
{
   if (case_sensitivity != current_language->la_case_sensitivity)
      printf_unfiltered(
"Warning: the current case sensitivity setting does not match the language.\n");
}

/* Set command.  Change the setting for case sensitivity. */
static void
set_case_command (char *ignore, int from_tty)
{
   if (DEPRECATED_STREQ (case_sensitive, "on"))
   {
      case_sensitivity = case_sensitive_on;
      case_mode = case_mode_manual;
   }
   else if (DEPRECATED_STREQ (case_sensitive, "off"))
   {
      case_sensitivity = case_sensitive_off;
      case_mode = case_mode_manual;
   }
   else if (DEPRECATED_STREQ (case_sensitive, "auto"))
   {
      case_mode = case_mode_auto;
      set_type_range_case ();
      /* Avoid hitting the set_case_str call below.  We
         did it in set_type_range_case. */
      return;
   }
   else
   {
      warning ("Unrecognized case-sensitive setting: \"%s\"", case_sensitive);
   }
   set_case_str();
   show_case_command ((char *) NULL, from_tty);
}

/* Set the status of range and type checking and case sensitivity based on
   the current modes and the current language.
   If SHOW is non-zero, then print out the current language,
   type and range checking status. */
static void
set_type_range_case (void)
{

  if (range_mode == range_mode_auto)
    range_check = current_language->la_range_check;

  if (type_mode == type_mode_auto)
    type_check = current_language->la_type_check;

  if (case_mode == case_mode_auto)
    case_sensitivity = current_language->la_case_sensitivity;

  set_type_str ();
  set_range_str ();
  set_case_str ();
}

/* Set current language to (enum language) LANG.  Returns previous language. */

enum language
set_language (enum language lang)
{
  int i;
  enum language prev_language;

  prev_language = current_language->la_language;

  for (i = 0; i < languages_size; i++)
    {
      if (languages[i]->la_language == lang)
	{
	  current_language = languages[i];
	  set_type_range_case ();
	  set_lang_str ();
	  break;
	}
    }

  return prev_language;
}

/* This page contains functions that update the global vars
   language, type and range. */
static void
set_lang_str (void)
{
  char *prefix = "";

  if (language)
    xfree (language);
  if (language_mode == language_mode_auto)
    prefix = "auto; currently ";

  language = concat (prefix, current_language->la_name, NULL);
}

static void
set_type_str (void)
{
  char *tmp = NULL, *prefix = "";

  if (type)
    xfree (type);
  if (type_mode == type_mode_auto)
    prefix = "auto; currently ";

  switch (type_check)
    {
    case type_check_on:
      tmp = "on";
      break;
    case type_check_off:
      tmp = "off";
      break;
    case type_check_warn:
      tmp = "warn";
      break;
    default:
      error ("Unrecognized type check setting.");
    }

  type = concat (prefix, tmp, NULL);
}

static void
set_range_str (void)
{
  char *tmp, *pref = "";

  if (range_mode == range_mode_auto)
    pref = "auto; currently ";

  switch (range_check)
    {
    case range_check_on:
      tmp = "on";
      break;
    case range_check_off:
      tmp = "off";
      break;
    case range_check_warn:
      tmp = "warn";
      break;
    default:
      error ("Unrecognized range check setting.");
    }

  if (range)
    xfree (range);
  range = concat (pref, tmp, NULL);
}

static void
set_case_str (void)
{
   char *tmp = NULL, *prefix = "";

   if (case_mode==case_mode_auto)
      prefix = "auto; currently ";

   switch (case_sensitivity)
   {
   case case_sensitive_on:
     tmp = "on";
     break;
   case case_sensitive_off:
     tmp = "off";
     break;
   default:
     error ("Unrecognized case-sensitive setting.");
   }

   xfree (case_sensitive);
   case_sensitive = concat (prefix, tmp, NULL);
}

/* Print out the current language settings: language, range and
   type checking.  If QUIETLY, print only what has changed.  */

void
language_info (int quietly)
{
  if (quietly && expected_language == current_language)
    return;

  expected_language = current_language;
  printf_unfiltered ("Current language:  %s\n", language);
  show_language_command ((char *) 0, 1);

  if (!quietly)
    {
      printf_unfiltered ("Type checking:     %s\n", type);
      show_type_command ((char *) 0, 1);
      printf_unfiltered ("Range checking:    %s\n", range);
      show_range_command ((char *) 0, 1);
      printf_unfiltered ("Case sensitivity:  %s\n", case_sensitive);
      show_case_command ((char *) 0, 1);
    }
}

/* Return the result of a binary operation. */

#if 0				/* Currently unused */

struct type *
binop_result_type (struct value *v1, struct value *v2)
{
  int size, uns;
  struct type *t1 = check_typedef (VALUE_TYPE (v1));
  struct type *t2 = check_typedef (VALUE_TYPE (v2));

  int l1 = TYPE_LENGTH (t1);
  int l2 = TYPE_LENGTH (t2);

  switch (current_language->la_language)
    {
    case language_c:
    case language_cplus:
    case language_objc:
      if (TYPE_CODE (t1) == TYPE_CODE_FLT)
	return TYPE_CODE (t2) == TYPE_CODE_FLT && l2 > l1 ?
	  VALUE_TYPE (v2) : VALUE_TYPE (v1);
      else if (TYPE_CODE (t2) == TYPE_CODE_FLT)
	return TYPE_CODE (t1) == TYPE_CODE_FLT && l1 > l2 ?
	  VALUE_TYPE (v1) : VALUE_TYPE (v2);
      else if (TYPE_UNSIGNED (t1) && l1 > l2)
	return VALUE_TYPE (v1);
      else if (TYPE_UNSIGNED (t2) && l2 > l1)
	return VALUE_TYPE (v2);
      else			/* Both are signed.  Result is the longer type */
	return l1 > l2 ? VALUE_TYPE (v1) : VALUE_TYPE (v2);
      break;
    case language_m2:
      /* If we are doing type-checking, l1 should equal l2, so this is
         not needed. */
      return l1 > l2 ? VALUE_TYPE (v1) : VALUE_TYPE (v2);
      break;
    }
  internal_error (__FILE__, __LINE__, "failed internal consistency check");
  return (struct type *) 0;	/* For lint */
}

#endif /* 0 */
#if 0
/* This page contains functions that are used in type/range checking.
   They all return zero if the type/range check fails.

   It is hoped that these will make extending GDB to parse different
   languages a little easier.  These are primarily used in eval.c when
   evaluating expressions and making sure that their types are correct.
   Instead of having a mess of conjucted/disjuncted expressions in an "if",
   the ideas of type can be wrapped up in the following functions.

   Note that some of them are not currently dependent upon which language
   is currently being parsed.  For example, floats are the same in
   C and Modula-2 (ie. the only floating point type has TYPE_CODE of
   TYPE_CODE_FLT), while booleans are different. */

/* Returns non-zero if its argument is a simple type.  This is the same for
   both Modula-2 and for C.  In the C case, TYPE_CODE_CHAR will never occur,
   and thus will never cause the failure of the test. */
int
simple_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_FLT:
    case TYPE_CODE_RANGE:
    case TYPE_CODE_BOOL:
      return 1;

    default:
      return 0;
    }
}

/* Returns non-zero if its argument is of an ordered type.
   An ordered type is one in which the elements can be tested for the
   properties of "greater than", "less than", etc, or for which the
   operations "increment" or "decrement" make sense. */
int
ordered_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_FLT:
    case TYPE_CODE_RANGE:
      return 1;

    default:
      return 0;
    }
}

/* Returns non-zero if the two types are the same */
int
same_type (struct type *arg1, struct type *arg2)
{
  CHECK_TYPEDEF (type);
  if (structured_type (arg1) ? !structured_type (arg2) : structured_type (arg2))
    /* One is structured and one isn't */
    return 0;
  else if (structured_type (arg1) && structured_type (arg2))
    return arg1 == arg2;
  else if (numeric_type (arg1) && numeric_type (arg2))
    return (TYPE_CODE (arg2) == TYPE_CODE (arg1)) &&
      (TYPE_UNSIGNED (arg1) == TYPE_UNSIGNED (arg2))
      ? 1 : 0;
  else
    return arg1 == arg2;
}

/* Returns non-zero if the type is integral */
int
integral_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (current_language->la_language)
    {
    case language_c:
    case language_cplus:
    case language_objc:
      return (TYPE_CODE (type) != TYPE_CODE_INT) &&
	(TYPE_CODE (type) != TYPE_CODE_ENUM) ? 0 : 1;
    case language_m2:
    case language_pascal:
      return TYPE_CODE (type) != TYPE_CODE_INT ? 0 : 1;
    default:
      error ("Language not supported.");
    }
}

/* Returns non-zero if the value is numeric */
int
numeric_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_FLT:
      return 1;

    default:
      return 0;
    }
}

/* Returns non-zero if the value is a character type */
int
character_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (current_language->la_language)
    {
    case language_m2:
    case language_pascal:
      return TYPE_CODE (type) != TYPE_CODE_CHAR ? 0 : 1;

    case language_c:
    case language_cplus:
    case language_objc:
      return (TYPE_CODE (type) == TYPE_CODE_INT) &&
	TYPE_LENGTH (type) == sizeof (char)
      ? 1 : 0;
    default:
      return (0);
    }
}

/* Returns non-zero if the value is a string type */
int
string_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (current_language->la_language)
    {
    case language_m2:
    case language_pascal:
      return TYPE_CODE (type) != TYPE_CODE_STRING ? 0 : 1;

    case language_c:
    case language_cplus:
    case language_objc:
      /* C does not have distinct string type. */
      return (0);
    default:
      return (0);
    }
}

/* Returns non-zero if the value is a boolean type */
int
boolean_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  if (TYPE_CODE (type) == TYPE_CODE_BOOL)
    return 1;
  switch (current_language->la_language)
    {
    case language_c:
    case language_cplus:
    case language_objc:
      /* Might be more cleanly handled by having a
         TYPE_CODE_INT_NOT_BOOL for (the deleted) CHILL and such
         languages, or a TYPE_CODE_INT_OR_BOOL for C.  */
      if (TYPE_CODE (type) == TYPE_CODE_INT)
	return 1;
    default:
      break;
    }
  return 0;
}

/* Returns non-zero if the value is a floating-point type */
int
float_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  return TYPE_CODE (type) == TYPE_CODE_FLT;
}

/* Returns non-zero if the value is a pointer type */
int
pointer_type (struct type *type)
{
  return TYPE_CODE (type) == TYPE_CODE_PTR ||
    TYPE_CODE (type) == TYPE_CODE_REF;
}

/* Returns non-zero if the value is a structured type */
int
structured_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (current_language->la_language)
    {
    case language_c:
    case language_cplus:
    case language_objc:
      return (TYPE_CODE (type) == TYPE_CODE_STRUCT) ||
	(TYPE_CODE (type) == TYPE_CODE_UNION) ||
	(TYPE_CODE (type) == TYPE_CODE_ARRAY);
   case language_pascal:
      return (TYPE_CODE(type) == TYPE_CODE_STRUCT) ||
	 (TYPE_CODE(type) == TYPE_CODE_UNION) ||
	 (TYPE_CODE(type) == TYPE_CODE_SET) ||
	    (TYPE_CODE(type) == TYPE_CODE_ARRAY);
    case language_m2:
      return (TYPE_CODE (type) == TYPE_CODE_STRUCT) ||
	(TYPE_CODE (type) == TYPE_CODE_SET) ||
	(TYPE_CODE (type) == TYPE_CODE_ARRAY);
    default:
      return (0);
    }
}
#endif

struct type *
lang_bool_type (void)
{
  struct symbol *sym;
  struct type *type;
  switch (current_language->la_language)
    {
    case language_fortran:
      sym = lookup_symbol ("logical", NULL, VAR_DOMAIN, NULL, NULL);
      if (sym)
	{
	  type = SYMBOL_TYPE (sym);
	  if (type && TYPE_CODE (type) == TYPE_CODE_BOOL)
	    return type;
	}
      return builtin_type_f_logical_s2;
    case language_cplus:
    case language_pascal:
      if (current_language->la_language==language_cplus)
        {sym = lookup_symbol ("bool", NULL, VAR_DOMAIN, NULL, NULL);}
      else
        {sym = lookup_symbol ("boolean", NULL, VAR_DOMAIN, NULL, NULL);}
      if (sym)
	{
	  type = SYMBOL_TYPE (sym);
	  if (type && TYPE_CODE (type) == TYPE_CODE_BOOL)
	    return type;
	}
      return builtin_type_bool;
    case language_java:
      sym = lookup_symbol ("boolean", NULL, VAR_DOMAIN, NULL, NULL);
      if (sym)
	{
	  type = SYMBOL_TYPE (sym);
	  if (type && TYPE_CODE (type) == TYPE_CODE_BOOL)
	    return type;
	}
      return java_boolean_type;
    default:
      return builtin_type_int;
    }
}

/* This page contains functions that return info about
   (struct value) values used in GDB. */

/* Returns non-zero if the value VAL represents a true value. */
int
value_true (struct value *val)
{
  /* It is possible that we should have some sort of error if a non-boolean
     value is used in this context.  Possibly dependent on some kind of
     "boolean-checking" option like range checking.  But it should probably
     not depend on the language except insofar as is necessary to identify
     a "boolean" value (i.e. in C using a float, pointer, etc., as a boolean
     should be an error, probably).  */
  return !value_logical_not (val);
}

/* This page contains functions for the printing out of
   error messages that occur during type- and range-
   checking. */

/* These are called when a language fails a type- or range-check.  The
   first argument should be a printf()-style format string, and the
   rest of the arguments should be its arguments.  If
   [type|range]_check is [type|range]_check_on, an error is printed;
   if [type|range]_check_warn, a warning; otherwise just the
   message. */

void
type_error (const char *string,...)
{
  va_list args;
  va_start (args, string);

  switch (type_check)
    {
    case type_check_warn:
      vwarning (string, args);
      break;
    case type_check_on:
      verror (string, args);
      break;
    case type_check_off:
      /* FIXME: cagney/2002-01-30: Should this function print anything
         when type error is off?  */
      vfprintf_filtered (gdb_stderr, string, args);
      fprintf_filtered (gdb_stderr, "\n");
      break;
    default:
      internal_error (__FILE__, __LINE__, "bad switch");
    }
  va_end (args);
}

void
range_error (const char *string,...)
{
  va_list args;
  va_start (args, string);

  switch (range_check)
    {
    case range_check_warn:
      vwarning (string, args);
      break;
    case range_check_on:
      verror (string, args);
      break;
    case range_check_off:
      /* FIXME: cagney/2002-01-30: Should this function print anything
         when range error is off?  */
      vfprintf_filtered (gdb_stderr, string, args);
      fprintf_filtered (gdb_stderr, "\n");
      break;
    default:
      internal_error (__FILE__, __LINE__, "bad switch");
    }
  va_end (args);
}


/* This page contains miscellaneous functions */

/* Return the language enum for a given language string. */

enum language
language_enum (char *str)
{
  int i;

  for (i = 0; i < languages_size; i++)
    if (DEPRECATED_STREQ (languages[i]->la_name, str))
      return languages[i]->la_language;

  return language_unknown;
}

/* Return the language struct for a given language enum. */

const struct language_defn *
language_def (enum language lang)
{
  int i;

  for (i = 0; i < languages_size; i++)
    {
      if (languages[i]->la_language == lang)
	{
	  return languages[i];
	}
    }
  return NULL;
}

/* Return the language as a string */
char *
language_str (enum language lang)
{
  int i;

  for (i = 0; i < languages_size; i++)
    {
      if (languages[i]->la_language == lang)
	{
	  return languages[i]->la_name;
	}
    }
  return "Unknown";
}

static void
set_check (char *ignore, int from_tty)
{
  printf_unfiltered (
     "\"set check\" must be followed by the name of a check subcommand.\n");
  help_list (setchecklist, "set check ", -1, gdb_stdout);
}

static void
show_check (char *ignore, int from_tty)
{
  cmd_show_list (showchecklist, from_tty, "");
}

/* Add a language to the set of known languages.  */

void
add_language (const struct language_defn *lang)
{
  if (lang->la_magic != LANG_MAGIC)
    {
      fprintf_unfiltered (gdb_stderr, "Magic number of %s language struct wrong\n",
			  lang->la_name);
      internal_error (__FILE__, __LINE__, "failed internal consistency check");
    }

  if (!languages)
    {
      languages_allocsize = DEFAULT_ALLOCSIZE;
      languages = (const struct language_defn **) xmalloc
	(languages_allocsize * sizeof (*languages));
    }
  if (languages_size >= languages_allocsize)
    {
      languages_allocsize *= 2;
      languages = (const struct language_defn **) xrealloc ((char *) languages,
				 languages_allocsize * sizeof (*languages));
    }
  languages[languages_size++] = lang;
}

/* Iterate through all registered languages looking for and calling
   any non-NULL struct language_defn.skip_trampoline() functions.
   Return the result from the first that returns non-zero, or 0 if all
   `fail'.  */
CORE_ADDR 
skip_language_trampoline (CORE_ADDR pc)
{
  int i;

  for (i = 0; i < languages_size; i++)
    {
      if (languages[i]->skip_trampoline)
	{
	  CORE_ADDR real_pc = (languages[i]->skip_trampoline) (pc);
	  if (real_pc)
	    return real_pc;
	}
    }

  return 0;
}

/* Return demangled language symbol, or NULL.  
   FIXME: Options are only useful for certain languages and ignored
   by others, so it would be better to remove them here and have a
   more flexible demangler for the languages that need it.  
   FIXME: Sometimes the demangler is invoked when we don't know the
   language, so we can't use this everywhere.  */
char *
language_demangle (const struct language_defn *current_language, 
				const char *mangled, int options)
{
  if (current_language != NULL && current_language->la_demangle)
    return current_language->la_demangle (mangled, options);
  return NULL;
}

/* Return class name from physname or NULL.  */
char *
language_class_name_from_physname (const struct language_defn *current_language,
				   const char *physname)
{
  if (current_language != NULL && current_language->la_class_name_from_physname)
    return current_language->la_class_name_from_physname (physname);
  return NULL;
}

/* Return the default string containing the list of characters
   delimiting words.  This is a reasonable default value that
   most languages should be able to use.  */

char *
default_word_break_characters (void)
{
  return " \t\n!@@#$%^&*()+=|~`}{[]\"';:?/>.<,-";
}

/* Define the language that is no language.  */

static int
unk_lang_parser (void)
{
  return 1;
}

static void
unk_lang_error (char *msg)
{
  error ("Attempted to parse an expression with unknown language");
}

static void
unk_lang_emit_char (int c, struct ui_file *stream, int quoter)
{
  error ("internal error - unimplemented function unk_lang_emit_char called.");
}

static void
unk_lang_printchar (int c, struct ui_file *stream)
{
  error ("internal error - unimplemented function unk_lang_printchar called.");
}

static void
unk_lang_printstr (struct ui_file *stream, char *string, unsigned int length,
		   int width, int force_ellipses)
{
  error ("internal error - unimplemented function unk_lang_printstr called.");
}

static struct type *
unk_lang_create_fundamental_type (struct objfile *objfile, int typeid)
{
  error ("internal error - unimplemented function unk_lang_create_fundamental_type called.");
}

static void
unk_lang_print_type (struct type *type, char *varstring, struct ui_file *stream,
		     int show, int level)
{
  error ("internal error - unimplemented function unk_lang_print_type called.");
}

static int
unk_lang_val_print (struct type *type, char *valaddr, int embedded_offset,
		    CORE_ADDR address, struct ui_file *stream, int format,
		    int deref_ref, int recurse, enum val_prettyprint pretty)
{
  error ("internal error - unimplemented function unk_lang_val_print called.");
}

static int
unk_lang_value_print (struct value *val, struct ui_file *stream, int format,
		      enum val_prettyprint pretty)
{
  error ("internal error - unimplemented function unk_lang_value_print called.");
}

static CORE_ADDR unk_lang_trampoline (CORE_ADDR pc)
{
  return 0;
}

/* Unknown languages just use the cplus demangler.  */
static char *unk_lang_demangle (const char *mangled, int options)
{
  return cplus_demangle (mangled, options);
}

static char *unk_lang_class_name (const char *mangled)
{
  return NULL;
}

static const struct op_print unk_op_print_tab[] =
{
  {NULL, OP_NULL, PREC_NULL, 0}
};

static void
unknown_language_arch_info (struct gdbarch *gdbarch,
			    struct language_arch_info *lai)
{
  lai->string_char_type = builtin_type (gdbarch)->builtin_char;
  lai->primitive_type_vector = GDBARCH_OBSTACK_CALLOC (gdbarch, 1,
						       struct type *);
}

const struct language_defn unknown_language_defn =
{
  "unknown",
  language_unknown,
  NULL,
  range_check_off,
  type_check_off,
  array_row_major,
  case_sensitive_on,
  &exp_descriptor_standard,
  unk_lang_parser,
  unk_lang_error,
  null_post_parser,
  unk_lang_printchar,		/* Print character constant */
  unk_lang_printstr,
  unk_lang_emit_char,
  unk_lang_create_fundamental_type,
  unk_lang_print_type,		/* Print a type using appropriate syntax */
  unk_lang_val_print,		/* Print a value using appropriate syntax */
  unk_lang_value_print,		/* Print a top-level value */
  unk_lang_trampoline,		/* Language specific skip_trampoline */
  value_of_this,		/* value_of_this */
  basic_lookup_symbol_nonlocal, /* lookup_symbol_nonlocal */
  basic_lookup_transparent_type,/* lookup_transparent_type */
  unk_lang_demangle,		/* Language specific symbol demangler */
  unk_lang_class_name,		/* Language specific class_name_from_physname */
  unk_op_print_tab,		/* expression operators for printing */
  1,				/* c-style arrays */
  0,				/* String lower bound */
  NULL,
  default_word_break_characters,
  unknown_language_arch_info,	/* la_language_arch_info.  */
  LANG_MAGIC
};

/* These two structs define fake entries for the "local" and "auto" options. */
const struct language_defn auto_language_defn =
{
  "auto",
  language_auto,
  NULL,
  range_check_off,
  type_check_off,
  array_row_major,
  case_sensitive_on,
  &exp_descriptor_standard,
  unk_lang_parser,
  unk_lang_error,
  null_post_parser,
  unk_lang_printchar,		/* Print character constant */
  unk_lang_printstr,
  unk_lang_emit_char,
  unk_lang_create_fundamental_type,
  unk_lang_print_type,		/* Print a type using appropriate syntax */
  unk_lang_val_print,		/* Print a value using appropriate syntax */
  unk_lang_value_print,		/* Print a top-level value */
  unk_lang_trampoline,		/* Language specific skip_trampoline */
  value_of_this,		/* value_of_this */
  basic_lookup_symbol_nonlocal,	/* lookup_symbol_nonlocal */
  basic_lookup_transparent_type,/* lookup_transparent_type */
  unk_lang_demangle,		/* Language specific symbol demangler */
  unk_lang_class_name,		/* Language specific class_name_from_physname */
  unk_op_print_tab,		/* expression operators for printing */
  1,				/* c-style arrays */
  0,				/* String lower bound */
  NULL,
  default_word_break_characters,
  unknown_language_arch_info,	/* la_language_arch_info.  */
  LANG_MAGIC
};

const struct language_defn local_language_defn =
{
  "local",
  language_auto,
  NULL,
  range_check_off,
  type_check_off,
  case_sensitive_on,
  array_row_major,
  &exp_descriptor_standard,
  unk_lang_parser,
  unk_lang_error,
  null_post_parser,
  unk_lang_printchar,		/* Print character constant */
  unk_lang_printstr,
  unk_lang_emit_char,
  unk_lang_create_fundamental_type,
  unk_lang_print_type,		/* Print a type using appropriate syntax */
  unk_lang_val_print,		/* Print a value using appropriate syntax */
  unk_lang_value_print,		/* Print a top-level value */
  unk_lang_trampoline,		/* Language specific skip_trampoline */
  value_of_this,		/* value_of_this */
  basic_lookup_symbol_nonlocal,	/* lookup_symbol_nonlocal */
  basic_lookup_transparent_type,/* lookup_transparent_type */
  unk_lang_demangle,		/* Language specific symbol demangler */
  unk_lang_class_name,		/* Language specific class_name_from_physname */
  unk_op_print_tab,		/* expression operators for printing */
  1,				/* c-style arrays */
  0,				/* String lower bound */
  NULL,
  default_word_break_characters,
  unknown_language_arch_info,	/* la_language_arch_info.  */
  LANG_MAGIC
};

/* Per-architecture language information.  */

static struct gdbarch_data *language_gdbarch_data;

struct language_gdbarch
{
  /* A vector of per-language per-architecture info.  Indexed by "enum
     language".  */
  struct language_arch_info arch_info[nr_languages];
};

static void *
language_gdbarch_post_init (struct gdbarch *gdbarch)
{
  struct language_gdbarch *l;
  int i;

  l = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct language_gdbarch);
  for (i = 0; i < languages_size; i++)
    {
      if (languages[i] != NULL
	  && languages[i]->la_language_arch_info != NULL)
	languages[i]->la_language_arch_info
	  (gdbarch, l->arch_info + languages[i]->la_language);
    }
  return l;
}

struct type *
language_string_char_type (const struct language_defn *la,
			   struct gdbarch *gdbarch)
{
  struct language_gdbarch *ld = gdbarch_data (gdbarch,
					      language_gdbarch_data);
  if (ld->arch_info[la->la_language].string_char_type != NULL)
    return ld->arch_info[la->la_language].string_char_type;
  else
    return (*la->string_char_type);
}

struct type *
language_lookup_primitive_type_by_name (const struct language_defn *la,
					struct gdbarch *gdbarch,
					const char *name)
{
  struct language_gdbarch *ld = gdbarch_data (gdbarch,
					      language_gdbarch_data);
  if (ld->arch_info[la->la_language].primitive_type_vector != NULL)
    {
      struct type *const *p;
      for (p = ld->arch_info[la->la_language].primitive_type_vector;
	   (*p) != NULL;
	   p++)
	{
	  if (strcmp (TYPE_NAME (*p), name) == 0)
	    return (*p);
	}
    }
  else
    {
      struct type **const *p;
      for (p = current_language->la_builtin_type_vector; *p != NULL; p++)
	{
	  if (strcmp (TYPE_NAME (**p), name) == 0)
	    return (**p);
	}
    }
  return (NULL);
}

/* Initialize the language routines */

void
_initialize_language (void)
{
  struct cmd_list_element *set, *show;

  language_gdbarch_data
    = gdbarch_data_register_post_init (language_gdbarch_post_init);

  /* GDB commands for language specific stuff */

  set = add_set_cmd ("language", class_support, var_string_noescape,
		     (char *) &language,
		     "Set the current source language.",
		     &setlist);
  show = deprecated_add_show_from_set (set, &showlist);
  set_cmd_cfunc (set, set_language_command);
  set_cmd_cfunc (show, show_language_command);

  add_prefix_cmd ("check", no_class, set_check,
		  "Set the status of the type/range checker.",
		  &setchecklist, "set check ", 0, &setlist);
  add_alias_cmd ("c", "check", no_class, 1, &setlist);
  add_alias_cmd ("ch", "check", no_class, 1, &setlist);

  add_prefix_cmd ("check", no_class, show_check,
		  "Show the status of the type/range checker.",
		  &showchecklist, "show check ", 0, &showlist);
  add_alias_cmd ("c", "check", no_class, 1, &showlist);
  add_alias_cmd ("ch", "check", no_class, 1, &showlist);

  set = add_set_cmd ("type", class_support, var_string_noescape,
		     (char *) &type,
		     "Set type checking.  (on/warn/off/auto)",
		     &setchecklist);
  show = deprecated_add_show_from_set (set, &showchecklist);
  set_cmd_cfunc (set, set_type_command);
  set_cmd_cfunc (show, show_type_command);

  set = add_set_cmd ("range", class_support, var_string_noescape,
		     (char *) &range,
		     "Set range checking.  (on/warn/off/auto)",
		     &setchecklist);
  show = deprecated_add_show_from_set (set, &showchecklist);
  set_cmd_cfunc (set, set_range_command);
  set_cmd_cfunc (show, show_range_command);

  set = add_set_cmd ("case-sensitive", class_support, var_string_noescape,
                     (char *) &case_sensitive,
                     "Set case sensitivity in name search.  (on/off/auto)\n\
For Fortran the default is off; for other languages the default is on.",
                     &setlist);
  show = deprecated_add_show_from_set (set, &showlist);
  set_cmd_cfunc (set, set_case_command);
  set_cmd_cfunc (show, show_case_command);

  add_language (&unknown_language_defn);
  add_language (&local_language_defn);
  add_language (&auto_language_defn);

  language = savestring ("auto", strlen ("auto"));
  type = savestring ("auto", strlen ("auto"));
  range = savestring ("auto", strlen ("auto"));
  case_sensitive = savestring ("auto",strlen ("auto"));

  /* Have the above take effect */
  set_language (language_auto);
}
@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@a580 125


/* This page contains functions that return format strings for
   printf for printing out numbers in different formats */

/* Returns the appropriate printf format for hexadecimal
   numbers. */
char *
local_hex_format_custom (char *pre)
{
  static char form[50];

  strcpy (form, local_hex_format_prefix ());
  strcat (form, "%");
  strcat (form, pre);
  strcat (form, local_hex_format_specifier ());
  strcat (form, local_hex_format_suffix ());
  return form;
}

/* Converts a LONGEST to custom hexadecimal and stores it in a static
   string.  Returns a pointer to this string. */
char *
local_hex_string (LONGEST num)
{
  return local_hex_string_custom (num, "l");
}

/* Converts a LONGEST number to custom hexadecimal and stores it in a static
   string.  Returns a pointer to this string. Note that the width parameter
   should end with "l", e.g. "08l" as with calls to local_hex_string_custom */

char *
local_hex_string_custom (LONGEST num, char *width)
{
#define RESULT_BUF_LEN 50
  static char res2[RESULT_BUF_LEN];
  char format[RESULT_BUF_LEN];
  int field_width;
  int num_len;
  int num_pad_chars;
  char *pad_char;		/* string with one character */
  int pad_on_left;
  char *parse_ptr;
  char temp_nbr_buf[RESULT_BUF_LEN];

  /* Use phex_nz to print the number into a string, then
     build the result string from local_hex_format_prefix, padding and 
     the hex representation as indicated by "width".  */
  strcpy (temp_nbr_buf, phex_nz (num, sizeof (num)));
  /* parse width */
  parse_ptr = width;
  pad_on_left = 1;
  pad_char = " ";
  if (*parse_ptr == '-')
    {
      parse_ptr++;
      pad_on_left = 0;
    }
  if (*parse_ptr == '0')
    {
      parse_ptr++;
      if (pad_on_left)
	pad_char = "0";		/* If padding is on the right, it is blank */
    }
  field_width = atoi (parse_ptr);
  num_len = strlen (temp_nbr_buf);
  num_pad_chars = field_width - strlen (temp_nbr_buf);	/* possibly negative */

  if (strlen (local_hex_format_prefix ()) + num_len + num_pad_chars
      >= RESULT_BUF_LEN)		/* paranoia */
    internal_error (__FILE__, __LINE__,
		    "local_hex_string_custom: insufficient space to store result");

  strcpy (res2, local_hex_format_prefix ());
  if (pad_on_left)
    {
      while (num_pad_chars > 0)
	{
	  strcat (res2, pad_char);
	  num_pad_chars--;
	}
    }
  strcat (res2, temp_nbr_buf);
  if (!pad_on_left)
    {
      while (num_pad_chars > 0)
	{
	  strcat (res2, pad_char);
	  num_pad_chars--;
	}
    }
  return res2;

}				/* local_hex_string_custom */

/* Returns the appropriate printf format for octal
   numbers. */
char *
local_octal_format_custom (char *pre)
{
  static char form[50];

  strcpy (form, local_octal_format_prefix ());
  strcat (form, "%");
  strcat (form, pre);
  strcat (form, local_octal_format_specifier ());
  strcat (form, local_octal_format_suffix ());
  return form;
}

/* Returns the appropriate printf format for decimal numbers. */
char *
local_decimal_format_custom (char *pre)
{
  static char form[50];

  strcpy (form, local_decimal_format_prefix ());
  strcat (form, "%");
  strcat (form, pre);
  strcat (form, local_decimal_format_specifier ());
  strcat (form, local_decimal_format_suffix ());
  return form;
}

d1054 10
d1146 4
a1150 4
static struct type **const (unknown_builtin_types[]) =
{
  0
};
d1156 9
d1169 1
a1169 1
  &unknown_builtin_types[0],
d1172 1
d1177 1
d1190 1
a1190 4
  {"", "", "", ""},		/* Binary format info */
  {"0%lo", "0", "o", ""},	/* Octal format info */
  {"%ld", "", "d", ""},		/* Decimal format info */
  {"0x%lx", "0x", "x", ""},	/* Hex format info */
d1194 1
a1194 1
  &builtin_type_char,		/* Type of string elements */
d1196 1
d1205 1
a1205 1
  &unknown_builtin_types[0],
d1208 1
d1213 1
d1226 1
a1226 4
  {"", "", "", ""},		/* Binary format info */
  {"0%lo", "0", "o", ""},	/* Octal format info */
  {"%ld", "", "d", ""},		/* Decimal format info */
  {"0x%lx", "0x", "x", ""},	/* Hex format info */
d1230 1
a1230 1
  &builtin_type_char,		/* Type of string elements */
d1232 1
d1240 1
a1240 1
  &unknown_builtin_types[0],
d1244 1
d1248 1
d1261 1
a1261 4
  {"", "", "", ""},		/* Binary format info */
  {"0%lo", "0", "o", ""},	/* Octal format info */
  {"%ld", "", "d", ""},		/* Decimal format info */
  {"0x%lx", "0x", "x", ""},	/* Hex format info */
d1265 1
a1265 1
  &builtin_type_char,		/* Type of string elements */
d1267 1
d1271 70
d1348 3
d1357 1
a1357 1
  show = add_show_from_set (set, &showlist);
d1377 1
a1377 1
  show = add_show_from_set (set, &showchecklist);
d1385 1
a1385 1
  show = add_show_from_set (set, &showchecklist);
d1394 1
a1394 1
  show = add_show_from_set (set, &showlist);
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 4
a5 1
   Copyright 1991, 1992 Free Software Foundation, Inc.
d9 1
a9 1
This file is part of GDB.
d11 14
a24 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a36 5
#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif
a41 1
#include "frame.h"
d46 8
d55 7
a61 2
static void
show_language_command PARAMS ((char *, int));
d63 1
a63 2
static void
set_language_command PARAMS ((char *, int));
d65 1
a65 2
static void
show_type_command PARAMS ((char *, int));
d67 1
a67 2
static void
set_type_command PARAMS ((char *, int));
d69 1
a69 2
static void
show_range_command PARAMS ((char *, int));
d71 1
a71 2
static void
set_range_command PARAMS ((char *, int));
d73 1
a73 2
static void
set_range_str PARAMS ((void));
d75 1
a75 2
static void
set_type_str PARAMS ((void));
d77 1
a77 2
static void
set_lang_str PARAMS ((void));
d79 1
a79 2
static void
unk_lang_error PARAMS ((char *));
d81 1
a81 2
static int
unk_lang_parser PARAMS ((void));
d83 1
a83 2
static void
show_check PARAMS ((char *, int));
d85 1
a85 2
static void
set_check PARAMS ((char *, int));
d87 1
a87 2
static void
set_type_range PARAMS ((void));
d89 3
a91 2
static void
unk_lang_printchar PARAMS ((int, GDB_FILE *));
d93 1
a93 2
static void
unk_lang_printstr PARAMS ((GDB_FILE *, char *, unsigned int, int));
d95 2
a96 2
static struct type *
unk_lang_create_fundamental_type PARAMS ((struct objfile *, int));
d98 3
a100 2
static void
unk_lang_print_type PARAMS ((struct type *, char *, GDB_FILE *, int, int));
d102 1
a102 3
static int
unk_lang_val_print PARAMS ((struct type *, char *, CORE_ADDR, GDB_FILE *,
			    int, int, int, enum val_prettyprint));
d104 1
a104 2
static int
unk_lang_value_print PARAMS ((value_ptr, GDB_FILE *, int, enum val_prettyprint));
d108 1
a108 2
extern char *warning_pre_print;
  
d110 3
a112 3
    (If the modes are set to "auto", though, these are changed based
    on the default language at startup, and then again based on the
    language of the first source file.  */
d118 2
d147 1
d152 1
a152 2
	"Warning: the current language does not match this frame.";

d160 1
a160 3
show_language_command (ignore, from_tty)
   char *ignore;
   int from_tty;
d162 1
a162 1
   enum language flang;		/* The language of the current frame */
d164 2
a165 2
   flang = get_frame_language();
   if (flang != language_unknown &&
d168 1
a168 1
      printf_filtered("%s\n",lang_frame_mismatch_warn);
d173 1
a173 3
set_language_command (ignore, from_tty)
   char *ignore;
   int from_tty;
d181 1
a181 1
      printf_unfiltered("The currently understood settings are:\n\n");
d195 2
a196 2
			     /* Capitalize first letter of language
				name.  */
d201 1
a201 1
      set_language(current_language->la_language);
d206 26
a231 20
  for (i = 0; i < languages_size; i++) {
    if (STREQ (languages[i]->la_name, language)) {
      /* Found it!  Go into manual mode, and use this language.  */
      if (languages[i]->la_language == language_auto) {
	/* Enter auto mode.  Set to the current frame's language, if known.  */
	language_mode = language_mode_auto;
  	flang = get_frame_language();
	if (flang!=language_unknown)
	  set_language(flang);
	expected_language = current_language;
	return;
      } else {
	/* Enter manual mode.  Set the specified language.  */
	language_mode = language_mode_manual;
	current_language = languages[i];
	set_type_range ();
	set_lang_str();
	expected_language = current_language;
	return;
      }
a232 1
  }
d236 4
a239 4
  err_lang=savestring(language,strlen(language));
  make_cleanup (free, err_lang);	/* Free it after error */
  set_language(current_language->la_language);
  error ("Unknown language `%s'.",err_lang);
d245 1
a245 3
show_type_command(ignore, from_tty)
   char *ignore;
   int from_tty;
d247 3
a249 3
   if (type_check != current_language->la_type_check)
      printf_unfiltered(
"Warning: the current type check setting does not match the language.\n");
d254 1
a254 3
set_type_command(ignore, from_tty)
   char *ignore;
   int from_tty;
d256 2
a257 2
   if (STREQ(type,"on"))
   {
d260 3
a262 3
   }
   else if (STREQ(type,"warn"))
   {
d265 3
a267 3
   }
   else if (STREQ(type,"off"))
   {
d270 3
a272 3
   }
   else if (STREQ(type,"auto"))
   {
d274 1
a274 1
      set_type_range();
d276 1
a276 1
         did it in set_type_range. */
d278 7
a284 3
   }
   set_type_str();
   show_type_command((char *)NULL, from_tty);
d290 1
a290 3
show_range_command(ignore, from_tty)
   char *ignore;
   int from_tty;
d293 3
a295 3
   if (range_check != current_language->la_range_check)
      printf_unfiltered(
"Warning: the current range check setting does not match the language.\n");
d300 1
a300 3
set_range_command(ignore, from_tty)
   char *ignore;
   int from_tty;
d302 2
a303 2
   if (STREQ(range,"on"))
   {
d306 3
a308 3
   }
   else if (STREQ(range,"warn"))
   {
d311 40
d352 1
a352 1
   else if (STREQ(range,"off"))
d354 2
a355 2
      range_check = range_check_off;
      range_mode = range_mode_manual;
d357 1
a357 1
   else if (STREQ(range,"auto"))
d359 4
a362 4
      range_mode = range_mode_auto;
      set_type_range();
      /* Avoid hitting the set_range_str call below.  We
	 did it in set_type_range. */
d365 6
a370 2
   set_range_str();
   show_range_command((char *)0, from_tty);
d373 1
a373 1
/* Set the status of range and type checking based on
d378 1
a378 1
set_type_range()
d387 6
a392 2
  set_type_str();
  set_range_str();
d395 1
a395 1
/* Set current language to (enum language) LANG.  */
d397 2
a398 3
void
set_language(lang)
   enum language lang;
d401 1
d403 11
a413 6
  for (i = 0; i < languages_size; i++) {
    if (languages[i]->la_language == lang) {
      current_language = languages[i];
      set_type_range ();
      set_lang_str();
      break;
d415 2
a416 1
  }
d422 1
a422 1
set_lang_str()
d424 1
a424 1
   char *prefix = "";
d426 4
a429 3
   free (language);
   if (language_mode == language_mode_auto)
      prefix = "auto; currently ";
d431 1
a431 1
   language = concat(prefix, current_language->la_name, NULL);
d435 1
a435 1
set_type_str()
d437 1
a437 1
   char *tmp, *prefix = "";
d439 4
a442 3
   free (type);
   if (type_mode==type_mode_auto)
      prefix = "auto; currently ";
d444 3
a446 3
   switch(type_check)
   {
   case type_check_on:
d449 1
a449 1
   case type_check_off:
d452 1
a452 1
   case type_check_warn:
d455 1
a455 1
      default:
d457 1
a457 1
   }
d459 1
a459 1
   type = concat(prefix,tmp,NULL);
d463 1
a463 1
set_range_str()
d465 1
a465 1
   char *tmp, *pref = "";
d467 2
a468 3
   free (range);
   if (range_mode==range_mode_auto)
      pref = "auto; currently ";
d470 3
a472 3
   switch(range_check)
   {
   case range_check_on:
d475 1
a475 1
   case range_check_off:
d478 1
a478 1
   case range_check_warn:
d481 1
a481 1
      default:
d483 25
d510 2
a511 1
   range = concat(pref,tmp,NULL);
a513 1

d518 1
a518 2
language_info (quietly)
     int quietly;
d524 2
a525 2
  printf_unfiltered("Current language:  %s\n",language);
  show_language_command((char *)0, 1);
d529 6
a534 4
       printf_unfiltered("Type checking:     %s\n",type);
       show_type_command((char *)0, 1);
       printf_unfiltered("Range checking:    %s\n",range);
       show_range_command((char *)0, 1);
d540 1
a540 1
#if 0	/* Currently unused */
d543 1
a543 2
binop_result_type (v1, v2)
   value_ptr v1, v2;
d545 3
a547 3
   int size,uns;
   struct type *t1 = check_typedef (VALUE_TYPE (v1));
   struct type *t2 = check_typedef (VALUE_TYPE (v2));
d549 2
a550 2
   int l1 = TYPE_LENGTH (t1);
   int l2 = TYPE_LENGTH (t2);
d552 17
a568 16
   switch(current_language->la_language)
   {
   case language_c:
   case language_cplus:
      if (TYPE_CODE (t1)==TYPE_CODE_FLT)
	 return TYPE_CODE(t2) == TYPE_CODE_FLT && l2 > l1 ?
	    VALUE_TYPE(v2) : VALUE_TYPE(v1);
      else if (TYPE_CODE(t2)==TYPE_CODE_FLT)
	 return TYPE_CODE(t1)) == TYPE_CODE_FLT && l1 > l2 ?
	    VALUE_TYPE(v1) : VALUE_TYPE(v2);
      else if (TYPE_UNSIGNED(t1) && l1 > l2)
	 return VALUE_TYPE(v1);
      else if (TYPE_UNSIGNED(t2) && l2 > l1)
	 return VALUE_TYPE(v2);
      else  /* Both are signed.  Result is the longer type */
	 return l1 > l2 ? VALUE_TYPE(v1) : VALUE_TYPE(v2);
d570 1
a570 1
   case language_m2:
d572 2
a573 2
	 not needed. */
      return l1 > l2 ? VALUE_TYPE(v1) : VALUE_TYPE(v2);
d575 3
a577 5
   case language_chill:
      error ("Missing Chill support in function binop_result_check.");/*FIXME*/
   }
   abort();
   return (struct type *)0;	/* For lint */
d580 2
a581 1
#endif	/* 0 */
a582 1

d589 1
a589 2
local_hex_format_custom(pre)
   char *pre;
d591 1
a591 1
   static char form[50];
d593 6
a598 6
   strcpy (form, local_hex_format_prefix ());
   strcat (form, "%");
   strcat (form, pre);
   strcat (form, local_hex_format_specifier ());
   strcat (form, local_hex_format_suffix ());
   return form;
d601 1
a601 1
/* Converts a number to hexadecimal and stores it in a static
d604 1
a604 2
local_hex_string (num)
   unsigned long num;
d606 2
a607 1
   static char res[50];
d609 3
a611 3
   sprintf (res, local_hex_format(), num);
   return res;
}
a612 2
/* Converts a number to custom hexadecimal and stores it in a static
   string.  Returns a pointer to this string. */
d614 1
a614 3
local_hex_string_custom(num,pre)
   unsigned long num;
   char *pre;
d616 38
a653 1
   static char res[50];
d655 21
a675 3
   sprintf (res, local_hex_format_custom(pre), num);
   return res;
}
d680 1
a680 2
local_octal_format_custom(pre)
   char *pre;
d682 1
a682 1
   static char form[50];
d684 6
a689 6
   strcpy (form, local_octal_format_prefix ());
   strcat (form, "%");
   strcat (form, pre);
   strcat (form, local_octal_format_specifier ());
   strcat (form, local_octal_format_suffix ());
   return form;
d694 1
a694 2
local_decimal_format_custom(pre)
   char *pre;
d696 1
a696 1
   static char form[50];
d698 6
a703 6
   strcpy (form, local_decimal_format_prefix ());
   strcat (form, "%");
   strcat (form, pre);
   strcat (form, local_decimal_format_specifier ());
   strcat (form, local_decimal_format_suffix ());
   return form;
d725 1
a725 2
simple_type(type)
    struct type *type;
d728 9
a736 8
  switch (TYPE_CODE (type)) {
  case TYPE_CODE_INT:
  case TYPE_CODE_CHAR:
  case TYPE_CODE_ENUM:
  case TYPE_CODE_FLT:
  case TYPE_CODE_RANGE:
  case TYPE_CODE_BOOL:
    return 1;
d738 3
a740 3
  default:
    return 0;
  }
d748 1
a748 2
ordered_type (type)
   struct type *type;
d751 8
a758 7
  switch (TYPE_CODE (type)) {
  case TYPE_CODE_INT:
  case TYPE_CODE_CHAR:
  case TYPE_CODE_ENUM:
  case TYPE_CODE_FLT:
  case TYPE_CODE_RANGE:
    return 1;
d760 3
a762 3
  default:
    return 0;
  }
d767 1
a767 2
same_type (arg1, arg2)
   struct type *arg1, *arg2;
d770 11
a780 11
   if (structured_type(arg1) ? !structured_type(arg2) : structured_type(arg2))
      /* One is structured and one isn't */
      return 0;
   else if (structured_type(arg1) && structured_type(arg2))
      return arg1 == arg2;
   else if (numeric_type(arg1) && numeric_type(arg2))
      return (TYPE_CODE(arg2) == TYPE_CODE(arg1)) &&
	 (TYPE_UNSIGNED(arg1) == TYPE_UNSIGNED(arg2))
	    ? 1 : 0;
   else
      return arg1==arg2;
d785 1
a785 2
integral_type (type)
   struct type *type;
d788 11
a798 11
   switch(current_language->la_language)
   {
   case language_c:
   case language_cplus:
      return (TYPE_CODE(type) != TYPE_CODE_INT) &&
	 (TYPE_CODE(type) != TYPE_CODE_ENUM) ? 0 : 1;
   case language_m2:
      return TYPE_CODE(type) != TYPE_CODE_INT ? 0 : 1;
   case language_chill:
      error ("Missing Chill support in function integral_type.");  /*FIXME*/
   default:
d800 1
a800 1
   }
d805 1
a805 2
numeric_type (type)
   struct type *type;
d808 5
a812 4
  switch (TYPE_CODE (type)) {
  case TYPE_CODE_INT:
  case TYPE_CODE_FLT:
    return 1;
d814 3
a816 3
  default:
    return 0;
  }
d821 1
a821 2
character_type (type)
   struct type *type;
d824 13
a836 12
  switch(current_language->la_language)
   {
   case language_chill:
   case language_m2:
      return TYPE_CODE(type) != TYPE_CODE_CHAR ? 0 : 1;

   case language_c:
   case language_cplus:
      return (TYPE_CODE(type) == TYPE_CODE_INT) &&
	 TYPE_LENGTH(type) == sizeof(char)
	 ? 1 : 0;
   default:
d838 1
a838 1
   }
d843 1
a843 2
string_type (type)
   struct type *type;
d846 5
a850 5
  switch(current_language->la_language)
   {
   case language_chill:
   case language_m2:
      return TYPE_CODE(type) != TYPE_CODE_STRING ? 0 : 1;
d852 3
a854 2
   case language_c:
   case language_cplus:
d857 1
a857 1
   default:
d859 1
a859 1
   }
d864 1
a864 2
boolean_type (type)
   struct type *type;
d869 1
a869 1
  switch(current_language->la_language)
d873 4
a876 2
      /* Might be more cleanly handled by having a TYPE_CODE_INT_NOT_BOOL
	 for CHILL and such languages, or a TYPE_CODE_INT_OR_BOOL for C.  */
d879 1
a879 1
   default:
d881 1
a881 1
   }
d887 1
a887 2
float_type (type)
   struct type *type;
d890 1
a890 1
  return TYPE_CODE(type) == TYPE_CODE_FLT;
d895 1
a895 2
pointer_type(type)
   struct type *type;
d897 2
a898 2
   return TYPE_CODE(type) == TYPE_CODE_PTR ||
      TYPE_CODE(type) == TYPE_CODE_REF;
d903 1
a903 2
structured_type(type)
   struct type *type;
d906 9
a914 4
   switch(current_language->la_language)
   {
   case language_c:
   case language_cplus:
a916 3
	    (TYPE_CODE(type) == TYPE_CODE_ARRAY);
   case language_m2:
      return (TYPE_CODE(type) == TYPE_CODE_STRUCT) ||
d919 5
a923 3
   case language_chill:
      error ("Missing Chill support in function structured_type.");  /*FIXME*/
   default:
d925 1
a925 1
   }
d930 1
a930 1
lang_bool_type ()
d934 1
a934 1
  switch(current_language->la_language)
a935 2
    case language_chill:
      return builtin_type_chill_bool;
d937 1
a937 1
      sym = lookup_symbol ("logical", NULL, VAR_NAMESPACE, NULL, NULL);
d946 5
a950 1
      sym = lookup_symbol ("bool", NULL, VAR_NAMESPACE, NULL, NULL);
d957 10
a966 1
      /* ... else fall through ... */
d977 1
a977 2
value_true (val)
     value_ptr val;
d988 3
a990 2
/* Returns non-zero if the operator OP is defined on
   the values ARG1 and ARG2. */
d992 6
a997 1
#if 0	/* Currently unused */
d1000 1
a1000 3
binop_type_check(arg1,arg2,op)
   value_ptr arg1,arg2;
   int op;
d1002 2
a1003 1
   struct type *t1, *t2;
d1005 4
a1008 27
   /* If we're not checking types, always return success. */
   if (!STRICT_TYPE)
      return;

   t1=VALUE_TYPE(arg1);
   if (arg2 != NULL)
      t2=VALUE_TYPE(arg2);
   else
      t2=NULL;

   switch(op)
   {
   case BINOP_ADD:
   case BINOP_SUB:
      if ((numeric_type(t1) && pointer_type(t2)) ||
	 (pointer_type(t1) && numeric_type(t2)))
      {
	 warning ("combining pointer and integer.\n");
	 break;
      }
   case BINOP_MUL:
   case BINOP_LSH:
   case BINOP_RSH:
      if (!numeric_type(t1) || !numeric_type(t2))
	 type_op_error ("Arguments to %s must be numbers.",op);
      else if (!same_type(t1,t2))
	 type_op_error ("Arguments to %s must be of the same type.",op);
d1010 2
a1011 5

   case BINOP_LOGICAL_AND:
   case BINOP_LOGICAL_OR:
      if (!boolean_type(t1) || !boolean_type(t2))
	 type_op_error ("Arguments to %s must be of boolean type.",op);
d1013 5
a1017 15

   case BINOP_EQUAL:
      if ((pointer_type(t1) && !(pointer_type(t2) || integral_type(t2))) ||
	 (pointer_type(t2) && !(pointer_type(t1) || integral_type(t1))))
	 type_op_error ("A pointer can only be compared to an integer or pointer.",op);
      else if ((pointer_type(t1) && integral_type(t2)) ||
	 (integral_type(t1) && pointer_type(t2)))
      {
	 warning ("combining integer and pointer.\n");
	 break;
      }
      else if (!simple_type(t1) || !simple_type(t2))
	 type_op_error ("Arguments to %s must be of simple type.",op);
      else if (!same_type(t1,t2))
	 type_op_error ("Arguments to %s must be of the same type.",op);
d1019 5
d1025 5
a1029 5
   case BINOP_REM:
   case BINOP_MOD:
      if (!integral_type(t1) || !integral_type(t2))
	 type_op_error ("Arguments to %s must be of integral type.",op);
      break;
d1031 4
a1034 8
   case BINOP_LESS:
   case BINOP_GTR:
   case BINOP_LEQ:
   case BINOP_GEQ:
      if (!ordered_type(t1) || !ordered_type(t2))
	 type_op_error ("Arguments to %s must be of ordered type.",op);
      else if (!same_type(t1,t2))
	 type_op_error ("Arguments to %s must be of the same type.",op);
d1036 2
a1037 13

   case BINOP_ASSIGN:
      if (pointer_type(t1) && !integral_type(t2))
	 type_op_error ("A pointer can only be assigned an integer.",op);
      else if (pointer_type(t1) && integral_type(t2))
      {
	 warning ("combining integer and pointer.");
	 break;
      }
      else if (!simple_type(t1) || !simple_type(t2))
	 type_op_error ("Arguments to %s must be of simple type.",op);
      else if (!same_type(t1,t2))
	 type_op_error ("Arguments to %s must be of the same type.",op);
d1039 5
a1043 6

    case BINOP_CONCAT:
      /* FIXME:  Needs to handle bitstrings as well. */
      if (!(string_type(t1) || character_type(t1) || integral_type(t1))
	  || !(string_type(t2) || character_type(t2) || integral_type(t2)))
	  type_op_error ("Arguments to %s must be strings or characters.", op);
d1045 4
a1048 72

   /* Unary checks -- arg2 is null */

   case UNOP_LOGICAL_NOT:
      if (!boolean_type(t1))
	 type_op_error ("Argument to %s must be of boolean type.",op);
      break;

   case UNOP_PLUS:
   case UNOP_NEG:
      if (!numeric_type(t1))
	 type_op_error ("Argument to %s must be of numeric type.",op);
      break;

   case UNOP_IND:
      if (integral_type(t1))
      {
	 warning ("combining pointer and integer.\n");
	 break;
      }
      else if (!pointer_type(t1))
	 type_op_error ("Argument to %s must be a pointer.",op);
      break;

   case UNOP_PREINCREMENT:
   case UNOP_POSTINCREMENT:
   case UNOP_PREDECREMENT:
   case UNOP_POSTDECREMENT:
      if (!ordered_type(t1))
	 type_op_error ("Argument to %s must be of an ordered type.",op);
      break;

   default:
      /* Ok.  The following operators have different meanings in
	 different languages. */
      switch(current_language->la_language)
      {
#ifdef _LANG_c
      case language_c:
      case language_cplus:
	 switch(op)
	 {
	 case BINOP_DIV:
	    if (!numeric_type(t1) || !numeric_type(t2))
	       type_op_error ("Arguments to %s must be numbers.",op);
	    break;
	 }
	 break;
#endif

#ifdef _LANG_m2
      case language_m2:
	 switch(op)
	 {
	 case BINOP_DIV:
	    if (!float_type(t1) || !float_type(t2))
	       type_op_error ("Arguments to %s must be floating point numbers.",op);
	    break;
	 case BINOP_INTDIV:
	    if (!integral_type(t1) || !integral_type(t2))
	       type_op_error ("Arguments to %s must be of integral type.",op);
	    break;
	 }
#endif

#ifdef _LANG_chill
       case language_chill:
	 error ("Missing Chill support in function binop_type_check.");/*FIXME*/
#endif

      }
   }
a1049 3

#endif	/* 0 */

a1050 3
/* This page contains functions for the printing out of
   error messages that occur during type- and range-
   checking. */
d1052 1
a1052 17
/* Prints the format string FMT with the operator as a string
   corresponding to the opcode OP.  If FATAL is non-zero, then
   this is an error and error () is called.  Otherwise, it is
   a warning and printf() is called. */
void
op_error (fmt,op,fatal)
   char *fmt;
   enum exp_opcode op;
   int fatal;
{
   if (fatal)
      error (fmt,op_string(op));
   else
   {
      warning (fmt,op_string(op));
   }
}
d1054 1
a1054 6
/* These are called when a language fails a type- or range-check.
   The first argument should be a printf()-style format string, and
   the rest of the arguments should be its arguments.  If
   [type|range]_check is [type|range]_check_on, then return_to_top_level()
   is called in the style of error ().  Otherwise, the message is prefixed
   by the value of warning_pre_print and we do not return to the top level. */
d1056 2
a1057 7
void
#ifdef ANSI_PROTOTYPES
type_error (char *string, ...)
#else
type_error (va_alist)
     va_dcl
#endif
d1059 1
a1059 37
   va_list args;
#ifdef ANSI_PROTOTYPES
   va_start (args, string);
#else
   char *string;
   va_start (args);
   string = va_arg (args, char *);
#endif

   if (type_check == type_check_warn)
     fprintf_filtered (gdb_stderr, warning_pre_print);
   else
     error_begin ();

   vfprintf_filtered (gdb_stderr, string, args);
   fprintf_filtered (gdb_stderr, "\n");
   va_end (args);
   if (type_check == type_check_on)
     return_to_top_level (RETURN_ERROR);
}

void
#ifdef ANSI_PROTOTYPES
range_error (char *string, ...)
#else
range_error (va_alist)
     va_dcl
#endif
{
   va_list args;
#ifdef ANSI_PROTOTYPES
   va_start (args, string);
#else
   char *string;
   va_start (args);
   string = va_arg (args, char *);
#endif
d1061 3
a1063 4
   if (range_check == range_check_warn)
     fprintf_filtered (gdb_stderr, warning_pre_print);
   else
     error_begin ();
d1065 1
a1065 5
   vfprintf_filtered (gdb_stderr, string, args);
   fprintf_filtered (gdb_stderr, "\n");
   va_end (args);
   if (range_check == range_check_on)
     return_to_top_level (RETURN_ERROR);
a1067 3

/* This page contains miscellaneous functions */

d1071 1
a1071 2
language_def(lang)
   enum language lang;
d1075 6
a1080 3
  for (i = 0; i < languages_size; i++) {
    if (languages[i]->la_language == lang) {
      return languages[i];
a1081 1
  }
d1087 1
a1087 2
language_str(lang)
   enum language lang;
d1091 6
a1096 3
  for (i = 0; i < languages_size; i++) {
    if (languages[i]->la_language == lang) {
      return languages[i]->la_name;
a1097 1
  }
d1102 5
a1106 7
set_check (ignore, from_tty)
   char *ignore;
   int from_tty;
{
   printf_unfiltered(
"\"set check\" must be followed by the name of a check subcommand.\n");
   help_list(setchecklist, "set check ", -1, gdb_stdout);
d1110 1
a1110 3
show_check (ignore, from_tty)
   char *ignore;
   int from_tty;
d1112 1
a1112 1
   cmd_show_list(showchecklist, from_tty, "");
d1118 1
a1118 2
add_language (lang)
     const struct language_defn *lang;
d1122 3
a1124 3
      fprintf_unfiltered(gdb_stderr, "Magic number of %s language struct wrong\n",
	lang->la_name);
      abort();
d1137 1
a1137 1
	languages_allocsize * sizeof (*languages));
d1142 47
d1192 1
a1192 1
unk_lang_parser ()
d1198 1
a1198 2
unk_lang_error (msg)
     char *msg;
d1204 7
a1210 3
unk_lang_printchar (c, stream)
     register int c;
     GDB_FILE *stream;
d1216 2
a1217 5
unk_lang_printstr (stream, string, length, force_ellipses)
     GDB_FILE *stream;
     char *string;
     unsigned int length;
     int force_ellipses;
d1223 1
a1223 3
unk_lang_create_fundamental_type (objfile, typeid)
     struct objfile *objfile;
     int typeid;
d1229 2
a1230 6
unk_lang_print_type (type, varstring, stream, show, level)
     struct type *type;
     char *varstring;
     GDB_FILE *stream;
     int show;
     int level;
d1236 3
a1238 10
unk_lang_val_print (type, valaddr, address, stream, format, deref_ref,
		    recurse, pretty)
     struct type *type;
     char *valaddr;
     CORE_ADDR address;
     GDB_FILE *stream;
     int format;
     int deref_ref;
     int recurse;
     enum val_prettyprint pretty;
d1244 2
a1245 5
unk_lang_value_print (val, stream, format, pretty)
     value_ptr val;
     GDB_FILE *stream;
     int format;
     enum val_prettyprint pretty;
d1250 19
a1268 3
static struct type ** CONST_PTR (unknown_builtin_types[]) = { 0 };
static const struct op_print unk_op_print_tab[] = {
    {NULL, OP_NULL, PREC_NULL, 0}
d1271 2
a1272 1
const struct language_defn unknown_language_defn = {
d1278 2
a1281 1
  evaluate_subexp_standard,
d1284 1
d1289 9
a1297 4
  {"",      "",    "",   ""},	/* Binary format info */
  {"0%lo",   "0",   "o",  ""},	/* Octal format info */
  {"%ld",    "",    "d",  ""},	/* Decimal format info */
  {"0x%lx",  "0x",  "x",  ""},	/* Hex format info */
d1301 2
a1302 1
  &builtin_type_char,		/* Type of string elements */ 
d1307 2
a1308 1
const struct language_defn auto_language_defn = {
d1314 2
a1317 1
  evaluate_subexp_standard,
d1320 1
d1325 9
a1333 4
  {"",      "",    "",   ""},	/* Binary format info */
  {"0%lo",   "0",   "o",  ""},	/* Octal format info */
  {"%ld",    "",    "d",  ""},	/* Decimal format info */
  {"0x%lx",  "0x",  "x",  ""},	/* Hex format info */
d1337 2
a1338 1
  &builtin_type_char,		/* Type of string elements */ 
d1342 2
a1343 1
const struct language_defn local_language_defn = {
d1349 2
a1352 1
  evaluate_subexp_standard,
d1355 1
d1360 9
a1368 4
  {"",      "",    "",   ""},	/* Binary format info */
  {"0%lo",   "0",   "o",  ""},	/* Octal format info */
  {"%ld",    "",    "d",  ""},	/* Decimal format info */
  {"0x%lx",  "0x",  "x",  ""},	/* Hex format info */
d1372 2
a1373 1
  &builtin_type_char,		/* Type of string elements */ 
d1380 1
a1380 1
_initialize_language()
d1382 3
a1384 1
   struct cmd_list_element *set, *show;
d1386 53
a1438 1
   /* GDB commands for language specific stuff */
d1440 2
a1441 49
   set = add_set_cmd ("language", class_support, var_string_noescape,
		      (char *)&language,
		      "Set the current source language.",
		      &setlist);
   show = add_show_from_set (set, &showlist);
   set->function.cfunc = set_language_command;
   show->function.cfunc = show_language_command;

   add_prefix_cmd ("check", no_class, set_check,
		   "Set the status of the type/range checker",
		   &setchecklist, "set check ", 0, &setlist);
   add_alias_cmd ("c", "check", no_class, 1, &setlist);
   add_alias_cmd ("ch", "check", no_class, 1, &setlist);

   add_prefix_cmd ("check", no_class, show_check,
		   "Show the status of the type/range checker",
		   &showchecklist, "show check ", 0, &showlist);
   add_alias_cmd ("c", "check", no_class, 1, &showlist);
   add_alias_cmd ("ch", "check", no_class, 1, &showlist);

   set = add_set_cmd ("type", class_support, var_string_noescape,
		      (char *)&type,
		      "Set type checking.  (on/warn/off/auto)",
		      &setchecklist);
   show = add_show_from_set (set, &showchecklist);
   set->function.cfunc = set_type_command;
   show->function.cfunc = show_type_command;

   set = add_set_cmd ("range", class_support, var_string_noescape,
		      (char *)&range,
		      "Set range checking.  (on/warn/off/auto)",
		      &setchecklist);
   show = add_show_from_set (set, &showchecklist);
   set->function.cfunc = set_range_command;
   show->function.cfunc = show_range_command;

   add_language (&unknown_language_defn);
   add_language (&local_language_defn);
   add_language (&auto_language_defn);

   language = savestring ("auto",strlen("auto"));
   range = savestring ("auto",strlen("auto"));
   type = savestring ("auto",strlen("auto"));

   /* Have the above take effect */

   set_language_command (language, 0);
   set_type_command (NULL, 0);
   set_range_command (NULL, 0);
@


1.1
log
@file language.c was initially added on branch CYGNUS.
@
text
@d1 1419
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 1442
/* Multiple source language support for GDB.

   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.

   Contributed by the Department of Computer Science at the State University
   of New York at Buffalo.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* This file contains functions that return things that are specific
   to languages.  Each function should examine current_language if necessary,
   and return the appropriate result. */

/* FIXME:  Most of these would be better organized as macros which
   return data out of a "language-specific" struct pointer that is set
   whenever the working language changes.  That would be a lot faster.  */

#include "defs.h"
#include <ctype.h>
#include "gdb_string.h"

#include "symtab.h"
#include "gdbtypes.h"
#include "value.h"
#include "gdbcmd.h"
#include "expression.h"
#include "language.h"
#include "target.h"
#include "parser-defs.h"
#include "jv-lang.h"
#include "demangle.h"

extern void _initialize_language (void);

static void show_language_command (char *, int);

static void set_language_command (char *, int);

static void show_type_command (char *, int);

static void set_type_command (char *, int);

static void show_range_command (char *, int);

static void set_range_command (char *, int);

static void show_case_command (char *, int);

static void set_case_command (char *, int);

static void set_case_str (void);

static void set_range_str (void);

static void set_type_str (void);

static void set_lang_str (void);

static void unk_lang_error (char *);

static int unk_lang_parser (void);

static void show_check (char *, int);

static void set_check (char *, int);

static void set_type_range_case (void);

static void unk_lang_emit_char (int c, struct ui_file *stream, int quoter);

static void unk_lang_printchar (int c, struct ui_file *stream);

static void unk_lang_printstr (struct ui_file * stream, char *string,
			       unsigned int length, int width,
			       int force_ellipses);

static struct type *unk_lang_create_fundamental_type (struct objfile *, int);

static void unk_lang_print_type (struct type *, char *, struct ui_file *,
				 int, int);

static int unk_lang_val_print (struct type *, char *, int, CORE_ADDR,
			       struct ui_file *, int, int, int,
			       enum val_prettyprint);

static int unk_lang_value_print (struct value *, struct ui_file *, int, enum val_prettyprint);

static CORE_ADDR unk_lang_trampoline (CORE_ADDR pc);

/* Forward declaration */
extern const struct language_defn unknown_language_defn;

/* The current (default at startup) state of type and range checking.
   (If the modes are set to "auto", though, these are changed based
   on the default language at startup, and then again based on the
   language of the first source file.  */

enum range_mode range_mode = range_mode_auto;
enum range_check range_check = range_check_off;
enum type_mode type_mode = type_mode_auto;
enum type_check type_check = type_check_off;
enum case_mode case_mode = case_mode_auto;
enum case_sensitivity case_sensitivity = case_sensitive_on;

/* The current language and language_mode (see language.h) */

const struct language_defn *current_language = &unknown_language_defn;
enum language_mode language_mode = language_mode_auto;

/* The language that the user expects to be typing in (the language
   of main(), or the last language we notified them about, or C).  */

const struct language_defn *expected_language;

/* The list of supported languages.  The list itself is malloc'd.  */

static const struct language_defn **languages;
static unsigned languages_size;
static unsigned languages_allocsize;
#define	DEFAULT_ALLOCSIZE 4

/* The "set language/type/range" commands all put stuff in these
   buffers.  This is to make them work as set/show commands.  The
   user's string is copied here, then the set_* commands look at
   them and update them to something that looks nice when it is
   printed out. */

static char *language;
static char *type;
static char *range;
static char *case_sensitive;

/* Warning issued when current_language and the language of the current
   frame do not match. */
char lang_frame_mismatch_warn[] =
"Warning: the current language does not match this frame.";

/* This page contains the functions corresponding to GDB commands
   and their helpers. */

/* Show command.  Display a warning if the language set
   does not match the frame. */
static void
show_language_command (char *ignore, int from_tty)
{
  enum language flang;		/* The language of the current frame */

  flang = get_frame_language ();
  if (flang != language_unknown &&
      language_mode == language_mode_manual &&
      current_language->la_language != flang)
    printf_filtered ("%s\n", lang_frame_mismatch_warn);
}

/* Set command.  Change the current working language. */
static void
set_language_command (char *ignore, int from_tty)
{
  int i;
  enum language flang;
  char *err_lang;

  if (!language || !language[0])
    {
      printf_unfiltered ("The currently understood settings are:\n\n");
      printf_unfiltered ("local or auto    Automatic setting based on source file\n");

      for (i = 0; i < languages_size; ++i)
	{
	  /* Already dealt with these above.  */
	  if (languages[i]->la_language == language_unknown
	      || languages[i]->la_language == language_auto)
	    continue;

	  /* FIXME for now assume that the human-readable name is just
	     a capitalization of the internal name.  */
	  printf_unfiltered ("%-16s Use the %c%s language\n",
			     languages[i]->la_name,
	  /* Capitalize first letter of language
	     name.  */
			     toupper (languages[i]->la_name[0]),
			     languages[i]->la_name + 1);
	}
      /* Restore the silly string. */
      set_language (current_language->la_language);
      return;
    }

  /* Search the list of languages for a match.  */
  for (i = 0; i < languages_size; i++)
    {
      if (strcmp (languages[i]->la_name, language) == 0)
	{
	  /* Found it!  Go into manual mode, and use this language.  */
	  if (languages[i]->la_language == language_auto)
	    {
	      /* Enter auto mode.  Set to the current frame's language, if known.  */
	      language_mode = language_mode_auto;
	      flang = get_frame_language ();
	      if (flang != language_unknown)
		set_language (flang);
	      expected_language = current_language;
	      return;
	    }
	  else
	    {
	      /* Enter manual mode.  Set the specified language.  */
	      language_mode = language_mode_manual;
	      current_language = languages[i];
	      set_type_range_case ();
	      set_lang_str ();
	      expected_language = current_language;
	      return;
	    }
	}
    }

  /* Reset the language (esp. the global string "language") to the 
     correct values. */
  err_lang = savestring (language, strlen (language));
  make_cleanup (xfree, err_lang);	/* Free it after error */
  set_language (current_language->la_language);
  error ("Unknown language `%s'.", err_lang);
}

/* Show command.  Display a warning if the type setting does
   not match the current language. */
static void
show_type_command (char *ignore, int from_tty)
{
  if (type_check != current_language->la_type_check)
    printf_unfiltered (
			"Warning: the current type check setting does not match the language.\n");
}

/* Set command.  Change the setting for type checking. */
static void
set_type_command (char *ignore, int from_tty)
{
  if (strcmp (type, "on") == 0)
    {
      type_check = type_check_on;
      type_mode = type_mode_manual;
    }
  else if (strcmp (type, "warn") == 0)
    {
      type_check = type_check_warn;
      type_mode = type_mode_manual;
    }
  else if (strcmp (type, "off") == 0)
    {
      type_check = type_check_off;
      type_mode = type_mode_manual;
    }
  else if (strcmp (type, "auto") == 0)
    {
      type_mode = type_mode_auto;
      set_type_range_case ();
      /* Avoid hitting the set_type_str call below.  We
         did it in set_type_range_case. */
      return;
    }
  else
    {
      warning ("Unrecognized type check setting: \"%s\"", type);
    }
  set_type_str ();
  show_type_command ((char *) NULL, from_tty);
}

/* Show command.  Display a warning if the range setting does
   not match the current language. */
static void
show_range_command (char *ignore, int from_tty)
{

  if (range_check != current_language->la_range_check)
    printf_unfiltered (
			"Warning: the current range check setting does not match the language.\n");
}

/* Set command.  Change the setting for range checking. */
static void
set_range_command (char *ignore, int from_tty)
{
  if (strcmp (range, "on") == 0)
    {
      range_check = range_check_on;
      range_mode = range_mode_manual;
    }
  else if (strcmp (range, "warn") == 0)
    {
      range_check = range_check_warn;
      range_mode = range_mode_manual;
    }
  else if (strcmp (range, "off") == 0)
    {
      range_check = range_check_off;
      range_mode = range_mode_manual;
    }
  else if (strcmp (range, "auto") == 0)
    {
      range_mode = range_mode_auto;
      set_type_range_case ();
      /* Avoid hitting the set_range_str call below.  We
         did it in set_type_range_case. */
      return;
    }
  else
    {
      warning ("Unrecognized range check setting: \"%s\"", range);
    }
  set_range_str ();
  show_range_command ((char *) 0, from_tty);
}

/* Show command.  Display a warning if the case sensitivity setting does
   not match the current language. */
static void
show_case_command (char *ignore, int from_tty)
{
   if (case_sensitivity != current_language->la_case_sensitivity)
      printf_unfiltered(
"Warning: the current case sensitivity setting does not match the language.\n");
}

/* Set command.  Change the setting for case sensitivity. */
static void
set_case_command (char *ignore, int from_tty)
{
   if (DEPRECATED_STREQ (case_sensitive, "on"))
   {
      case_sensitivity = case_sensitive_on;
      case_mode = case_mode_manual;
   }
   else if (DEPRECATED_STREQ (case_sensitive, "off"))
   {
      case_sensitivity = case_sensitive_off;
      case_mode = case_mode_manual;
   }
   else if (DEPRECATED_STREQ (case_sensitive, "auto"))
   {
      case_mode = case_mode_auto;
      set_type_range_case ();
      /* Avoid hitting the set_case_str call below.  We
         did it in set_type_range_case. */
      return;
   }
   else
   {
      warning ("Unrecognized case-sensitive setting: \"%s\"", case_sensitive);
   }
   set_case_str();
   show_case_command ((char *) NULL, from_tty);
}

/* Set the status of range and type checking and case sensitivity based on
   the current modes and the current language.
   If SHOW is non-zero, then print out the current language,
   type and range checking status. */
static void
set_type_range_case (void)
{

  if (range_mode == range_mode_auto)
    range_check = current_language->la_range_check;

  if (type_mode == type_mode_auto)
    type_check = current_language->la_type_check;

  if (case_mode == case_mode_auto)
    case_sensitivity = current_language->la_case_sensitivity;

  set_type_str ();
  set_range_str ();
  set_case_str ();
}

/* Set current language to (enum language) LANG.  Returns previous language. */

enum language
set_language (enum language lang)
{
  int i;
  enum language prev_language;

  prev_language = current_language->la_language;

  for (i = 0; i < languages_size; i++)
    {
      if (languages[i]->la_language == lang)
	{
	  current_language = languages[i];
	  set_type_range_case ();
	  set_lang_str ();
	  break;
	}
    }

  return prev_language;
}

/* This page contains functions that update the global vars
   language, type and range. */
static void
set_lang_str (void)
{
  char *prefix = "";

  if (language)
    xfree (language);
  if (language_mode == language_mode_auto)
    prefix = "auto; currently ";

  language = concat (prefix, current_language->la_name, NULL);
}

static void
set_type_str (void)
{
  char *tmp = NULL, *prefix = "";

  if (type)
    xfree (type);
  if (type_mode == type_mode_auto)
    prefix = "auto; currently ";

  switch (type_check)
    {
    case type_check_on:
      tmp = "on";
      break;
    case type_check_off:
      tmp = "off";
      break;
    case type_check_warn:
      tmp = "warn";
      break;
    default:
      error ("Unrecognized type check setting.");
    }

  type = concat (prefix, tmp, NULL);
}

static void
set_range_str (void)
{
  char *tmp, *pref = "";

  if (range_mode == range_mode_auto)
    pref = "auto; currently ";

  switch (range_check)
    {
    case range_check_on:
      tmp = "on";
      break;
    case range_check_off:
      tmp = "off";
      break;
    case range_check_warn:
      tmp = "warn";
      break;
    default:
      error ("Unrecognized range check setting.");
    }

  if (range)
    xfree (range);
  range = concat (pref, tmp, NULL);
}

static void
set_case_str (void)
{
   char *tmp = NULL, *prefix = "";

   if (case_mode==case_mode_auto)
      prefix = "auto; currently ";

   switch (case_sensitivity)
   {
   case case_sensitive_on:
     tmp = "on";
     break;
   case case_sensitive_off:
     tmp = "off";
     break;
   default:
     error ("Unrecognized case-sensitive setting.");
   }

   xfree (case_sensitive);
   case_sensitive = concat (prefix, tmp, NULL);
}

/* Print out the current language settings: language, range and
   type checking.  If QUIETLY, print only what has changed.  */

void
language_info (int quietly)
{
  if (quietly && expected_language == current_language)
    return;

  expected_language = current_language;
  printf_unfiltered ("Current language:  %s\n", language);
  show_language_command ((char *) 0, 1);

  if (!quietly)
    {
      printf_unfiltered ("Type checking:     %s\n", type);
      show_type_command ((char *) 0, 1);
      printf_unfiltered ("Range checking:    %s\n", range);
      show_range_command ((char *) 0, 1);
      printf_unfiltered ("Case sensitivity:  %s\n", case_sensitive);
      show_case_command ((char *) 0, 1);
    }
}

/* Return the result of a binary operation. */

#if 0				/* Currently unused */

struct type *
binop_result_type (struct value *v1, struct value *v2)
{
  int size, uns;
  struct type *t1 = check_typedef (VALUE_TYPE (v1));
  struct type *t2 = check_typedef (VALUE_TYPE (v2));

  int l1 = TYPE_LENGTH (t1);
  int l2 = TYPE_LENGTH (t2);

  switch (current_language->la_language)
    {
    case language_c:
    case language_cplus:
    case language_objc:
      if (TYPE_CODE (t1) == TYPE_CODE_FLT)
	return TYPE_CODE (t2) == TYPE_CODE_FLT && l2 > l1 ?
	  VALUE_TYPE (v2) : VALUE_TYPE (v1);
      else if (TYPE_CODE (t2) == TYPE_CODE_FLT)
	return TYPE_CODE (t1) == TYPE_CODE_FLT && l1 > l2 ?
	  VALUE_TYPE (v1) : VALUE_TYPE (v2);
      else if (TYPE_UNSIGNED (t1) && l1 > l2)
	return VALUE_TYPE (v1);
      else if (TYPE_UNSIGNED (t2) && l2 > l1)
	return VALUE_TYPE (v2);
      else			/* Both are signed.  Result is the longer type */
	return l1 > l2 ? VALUE_TYPE (v1) : VALUE_TYPE (v2);
      break;
    case language_m2:
      /* If we are doing type-checking, l1 should equal l2, so this is
         not needed. */
      return l1 > l2 ? VALUE_TYPE (v1) : VALUE_TYPE (v2);
      break;
    }
  internal_error (__FILE__, __LINE__, "failed internal consistency check");
  return (struct type *) 0;	/* For lint */
}

#endif /* 0 */


/* This page contains functions that return format strings for
   printf for printing out numbers in different formats */

/* Returns the appropriate printf format for hexadecimal
   numbers. */
char *
local_hex_format_custom (char *pre)
{
  static char form[50];

  strcpy (form, local_hex_format_prefix ());
  strcat (form, "%");
  strcat (form, pre);
  strcat (form, local_hex_format_specifier ());
  strcat (form, local_hex_format_suffix ());
  return form;
}

/* Converts a LONGEST to custom hexadecimal and stores it in a static
   string.  Returns a pointer to this string. */
char *
local_hex_string (LONGEST num)
{
  return local_hex_string_custom (num, "l");
}

/* Converts a LONGEST number to custom hexadecimal and stores it in a static
   string.  Returns a pointer to this string. Note that the width parameter
   should end with "l", e.g. "08l" as with calls to local_hex_string_custom */

char *
local_hex_string_custom (LONGEST num, char *width)
{
#define RESULT_BUF_LEN 50
  static char res2[RESULT_BUF_LEN];
  char format[RESULT_BUF_LEN];
  int field_width;
  int num_len;
  int num_pad_chars;
  char *pad_char;		/* string with one character */
  int pad_on_left;
  char *parse_ptr;
  char temp_nbr_buf[RESULT_BUF_LEN];

  /* Use phex_nz to print the number into a string, then
     build the result string from local_hex_format_prefix, padding and 
     the hex representation as indicated by "width".  */
  strcpy (temp_nbr_buf, phex_nz (num, sizeof (num)));
  /* parse width */
  parse_ptr = width;
  pad_on_left = 1;
  pad_char = " ";
  if (*parse_ptr == '-')
    {
      parse_ptr++;
      pad_on_left = 0;
    }
  if (*parse_ptr == '0')
    {
      parse_ptr++;
      if (pad_on_left)
	pad_char = "0";		/* If padding is on the right, it is blank */
    }
  field_width = atoi (parse_ptr);
  num_len = strlen (temp_nbr_buf);
  num_pad_chars = field_width - strlen (temp_nbr_buf);	/* possibly negative */

  if (strlen (local_hex_format_prefix ()) + num_len + num_pad_chars
      >= RESULT_BUF_LEN)		/* paranoia */
    internal_error (__FILE__, __LINE__,
		    "local_hex_string_custom: insufficient space to store result");

  strcpy (res2, local_hex_format_prefix ());
  if (pad_on_left)
    {
      while (num_pad_chars > 0)
	{
	  strcat (res2, pad_char);
	  num_pad_chars--;
	}
    }
  strcat (res2, temp_nbr_buf);
  if (!pad_on_left)
    {
      while (num_pad_chars > 0)
	{
	  strcat (res2, pad_char);
	  num_pad_chars--;
	}
    }
  return res2;

}				/* local_hex_string_custom */

/* Returns the appropriate printf format for octal
   numbers. */
char *
local_octal_format_custom (char *pre)
{
  static char form[50];

  strcpy (form, local_octal_format_prefix ());
  strcat (form, "%");
  strcat (form, pre);
  strcat (form, local_octal_format_specifier ());
  strcat (form, local_octal_format_suffix ());
  return form;
}

/* Returns the appropriate printf format for decimal numbers. */
char *
local_decimal_format_custom (char *pre)
{
  static char form[50];

  strcpy (form, local_decimal_format_prefix ());
  strcat (form, "%");
  strcat (form, pre);
  strcat (form, local_decimal_format_specifier ());
  strcat (form, local_decimal_format_suffix ());
  return form;
}

#if 0
/* This page contains functions that are used in type/range checking.
   They all return zero if the type/range check fails.

   It is hoped that these will make extending GDB to parse different
   languages a little easier.  These are primarily used in eval.c when
   evaluating expressions and making sure that their types are correct.
   Instead of having a mess of conjucted/disjuncted expressions in an "if",
   the ideas of type can be wrapped up in the following functions.

   Note that some of them are not currently dependent upon which language
   is currently being parsed.  For example, floats are the same in
   C and Modula-2 (ie. the only floating point type has TYPE_CODE of
   TYPE_CODE_FLT), while booleans are different. */

/* Returns non-zero if its argument is a simple type.  This is the same for
   both Modula-2 and for C.  In the C case, TYPE_CODE_CHAR will never occur,
   and thus will never cause the failure of the test. */
int
simple_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_FLT:
    case TYPE_CODE_RANGE:
    case TYPE_CODE_BOOL:
      return 1;

    default:
      return 0;
    }
}

/* Returns non-zero if its argument is of an ordered type.
   An ordered type is one in which the elements can be tested for the
   properties of "greater than", "less than", etc, or for which the
   operations "increment" or "decrement" make sense. */
int
ordered_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_FLT:
    case TYPE_CODE_RANGE:
      return 1;

    default:
      return 0;
    }
}

/* Returns non-zero if the two types are the same */
int
same_type (struct type *arg1, struct type *arg2)
{
  CHECK_TYPEDEF (type);
  if (structured_type (arg1) ? !structured_type (arg2) : structured_type (arg2))
    /* One is structured and one isn't */
    return 0;
  else if (structured_type (arg1) && structured_type (arg2))
    return arg1 == arg2;
  else if (numeric_type (arg1) && numeric_type (arg2))
    return (TYPE_CODE (arg2) == TYPE_CODE (arg1)) &&
      (TYPE_UNSIGNED (arg1) == TYPE_UNSIGNED (arg2))
      ? 1 : 0;
  else
    return arg1 == arg2;
}

/* Returns non-zero if the type is integral */
int
integral_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (current_language->la_language)
    {
    case language_c:
    case language_cplus:
    case language_objc:
      return (TYPE_CODE (type) != TYPE_CODE_INT) &&
	(TYPE_CODE (type) != TYPE_CODE_ENUM) ? 0 : 1;
    case language_m2:
    case language_pascal:
      return TYPE_CODE (type) != TYPE_CODE_INT ? 0 : 1;
    default:
      error ("Language not supported.");
    }
}

/* Returns non-zero if the value is numeric */
int
numeric_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_FLT:
      return 1;

    default:
      return 0;
    }
}

/* Returns non-zero if the value is a character type */
int
character_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (current_language->la_language)
    {
    case language_m2:
    case language_pascal:
      return TYPE_CODE (type) != TYPE_CODE_CHAR ? 0 : 1;

    case language_c:
    case language_cplus:
    case language_objc:
      return (TYPE_CODE (type) == TYPE_CODE_INT) &&
	TYPE_LENGTH (type) == sizeof (char)
      ? 1 : 0;
    default:
      return (0);
    }
}

/* Returns non-zero if the value is a string type */
int
string_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (current_language->la_language)
    {
    case language_m2:
    case language_pascal:
      return TYPE_CODE (type) != TYPE_CODE_STRING ? 0 : 1;

    case language_c:
    case language_cplus:
    case language_objc:
      /* C does not have distinct string type. */
      return (0);
    default:
      return (0);
    }
}

/* Returns non-zero if the value is a boolean type */
int
boolean_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  if (TYPE_CODE (type) == TYPE_CODE_BOOL)
    return 1;
  switch (current_language->la_language)
    {
    case language_c:
    case language_cplus:
    case language_objc:
      /* Might be more cleanly handled by having a
         TYPE_CODE_INT_NOT_BOOL for (the deleted) CHILL and such
         languages, or a TYPE_CODE_INT_OR_BOOL for C.  */
      if (TYPE_CODE (type) == TYPE_CODE_INT)
	return 1;
    default:
      break;
    }
  return 0;
}

/* Returns non-zero if the value is a floating-point type */
int
float_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  return TYPE_CODE (type) == TYPE_CODE_FLT;
}

/* Returns non-zero if the value is a pointer type */
int
pointer_type (struct type *type)
{
  return TYPE_CODE (type) == TYPE_CODE_PTR ||
    TYPE_CODE (type) == TYPE_CODE_REF;
}

/* Returns non-zero if the value is a structured type */
int
structured_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  switch (current_language->la_language)
    {
    case language_c:
    case language_cplus:
    case language_objc:
      return (TYPE_CODE (type) == TYPE_CODE_STRUCT) ||
	(TYPE_CODE (type) == TYPE_CODE_UNION) ||
	(TYPE_CODE (type) == TYPE_CODE_ARRAY);
   case language_pascal:
      return (TYPE_CODE(type) == TYPE_CODE_STRUCT) ||
	 (TYPE_CODE(type) == TYPE_CODE_UNION) ||
	 (TYPE_CODE(type) == TYPE_CODE_SET) ||
	    (TYPE_CODE(type) == TYPE_CODE_ARRAY);
    case language_m2:
      return (TYPE_CODE (type) == TYPE_CODE_STRUCT) ||
	(TYPE_CODE (type) == TYPE_CODE_SET) ||
	(TYPE_CODE (type) == TYPE_CODE_ARRAY);
    default:
      return (0);
    }
}
#endif

struct type *
lang_bool_type (void)
{
  struct symbol *sym;
  struct type *type;
  switch (current_language->la_language)
    {
    case language_fortran:
      sym = lookup_symbol ("logical", NULL, VAR_DOMAIN, NULL, NULL);
      if (sym)
	{
	  type = SYMBOL_TYPE (sym);
	  if (type && TYPE_CODE (type) == TYPE_CODE_BOOL)
	    return type;
	}
      return builtin_type_f_logical_s2;
    case language_cplus:
    case language_pascal:
      if (current_language->la_language==language_cplus)
        {sym = lookup_symbol ("bool", NULL, VAR_DOMAIN, NULL, NULL);}
      else
        {sym = lookup_symbol ("boolean", NULL, VAR_DOMAIN, NULL, NULL);}
      if (sym)
	{
	  type = SYMBOL_TYPE (sym);
	  if (type && TYPE_CODE (type) == TYPE_CODE_BOOL)
	    return type;
	}
      return builtin_type_bool;
    case language_java:
      sym = lookup_symbol ("boolean", NULL, VAR_DOMAIN, NULL, NULL);
      if (sym)
	{
	  type = SYMBOL_TYPE (sym);
	  if (type && TYPE_CODE (type) == TYPE_CODE_BOOL)
	    return type;
	}
      return java_boolean_type;
    default:
      return builtin_type_int;
    }
}

/* This page contains functions that return info about
   (struct value) values used in GDB. */

/* Returns non-zero if the value VAL represents a true value. */
int
value_true (struct value *val)
{
  /* It is possible that we should have some sort of error if a non-boolean
     value is used in this context.  Possibly dependent on some kind of
     "boolean-checking" option like range checking.  But it should probably
     not depend on the language except insofar as is necessary to identify
     a "boolean" value (i.e. in C using a float, pointer, etc., as a boolean
     should be an error, probably).  */
  return !value_logical_not (val);
}

/* This page contains functions for the printing out of
   error messages that occur during type- and range-
   checking. */

/* These are called when a language fails a type- or range-check.  The
   first argument should be a printf()-style format string, and the
   rest of the arguments should be its arguments.  If
   [type|range]_check is [type|range]_check_on, an error is printed;
   if [type|range]_check_warn, a warning; otherwise just the
   message. */

void
type_error (const char *string,...)
{
  va_list args;
  va_start (args, string);

  switch (type_check)
    {
    case type_check_warn:
      vwarning (string, args);
      break;
    case type_check_on:
      verror (string, args);
      break;
    case type_check_off:
      /* FIXME: cagney/2002-01-30: Should this function print anything
         when type error is off?  */
      vfprintf_filtered (gdb_stderr, string, args);
      fprintf_filtered (gdb_stderr, "\n");
      break;
    default:
      internal_error (__FILE__, __LINE__, "bad switch");
    }
  va_end (args);
}

void
range_error (const char *string,...)
{
  va_list args;
  va_start (args, string);

  switch (range_check)
    {
    case range_check_warn:
      vwarning (string, args);
      break;
    case range_check_on:
      verror (string, args);
      break;
    case range_check_off:
      /* FIXME: cagney/2002-01-30: Should this function print anything
         when range error is off?  */
      vfprintf_filtered (gdb_stderr, string, args);
      fprintf_filtered (gdb_stderr, "\n");
      break;
    default:
      internal_error (__FILE__, __LINE__, "bad switch");
    }
  va_end (args);
}


/* This page contains miscellaneous functions */

/* Return the language enum for a given language string. */

enum language
language_enum (char *str)
{
  int i;

  for (i = 0; i < languages_size; i++)
    if (DEPRECATED_STREQ (languages[i]->la_name, str))
      return languages[i]->la_language;

  return language_unknown;
}

/* Return the language struct for a given language enum. */

const struct language_defn *
language_def (enum language lang)
{
  int i;

  for (i = 0; i < languages_size; i++)
    {
      if (languages[i]->la_language == lang)
	{
	  return languages[i];
	}
    }
  return NULL;
}

/* Return the language as a string */
char *
language_str (enum language lang)
{
  int i;

  for (i = 0; i < languages_size; i++)
    {
      if (languages[i]->la_language == lang)
	{
	  return languages[i]->la_name;
	}
    }
  return "Unknown";
}

static void
set_check (char *ignore, int from_tty)
{
  printf_unfiltered (
     "\"set check\" must be followed by the name of a check subcommand.\n");
  help_list (setchecklist, "set check ", -1, gdb_stdout);
}

static void
show_check (char *ignore, int from_tty)
{
  cmd_show_list (showchecklist, from_tty, "");
}

/* Add a language to the set of known languages.  */

void
add_language (const struct language_defn *lang)
{
  if (lang->la_magic != LANG_MAGIC)
    {
      fprintf_unfiltered (gdb_stderr, "Magic number of %s language struct wrong\n",
			  lang->la_name);
      internal_error (__FILE__, __LINE__, "failed internal consistency check");
    }

  if (!languages)
    {
      languages_allocsize = DEFAULT_ALLOCSIZE;
      languages = (const struct language_defn **) xmalloc
	(languages_allocsize * sizeof (*languages));
    }
  if (languages_size >= languages_allocsize)
    {
      languages_allocsize *= 2;
      languages = (const struct language_defn **) xrealloc ((char *) languages,
				 languages_allocsize * sizeof (*languages));
    }
  languages[languages_size++] = lang;
}

/* Iterate through all registered languages looking for and calling
   any non-NULL struct language_defn.skip_trampoline() functions.
   Return the result from the first that returns non-zero, or 0 if all
   `fail'.  */
CORE_ADDR 
skip_language_trampoline (CORE_ADDR pc)
{
  int i;

  for (i = 0; i < languages_size; i++)
    {
      if (languages[i]->skip_trampoline)
	{
	  CORE_ADDR real_pc = (languages[i]->skip_trampoline) (pc);
	  if (real_pc)
	    return real_pc;
	}
    }

  return 0;
}

/* Return demangled language symbol, or NULL.  
   FIXME: Options are only useful for certain languages and ignored
   by others, so it would be better to remove them here and have a
   more flexible demangler for the languages that need it.  
   FIXME: Sometimes the demangler is invoked when we don't know the
   language, so we can't use this everywhere.  */
char *
language_demangle (const struct language_defn *current_language, 
				const char *mangled, int options)
{
  if (current_language != NULL && current_language->la_demangle)
    return current_language->la_demangle (mangled, options);
  return NULL;
}

/* Return the default string containing the list of characters
   delimiting words.  This is a reasonable default value that
   most languages should be able to use.  */

char *
default_word_break_characters (void)
{
  return " \t\n!@@#$%^&*()+=|~`}{[]\"';:?/>.<,-";
}

/* Define the language that is no language.  */

static int
unk_lang_parser (void)
{
  return 1;
}

static void
unk_lang_error (char *msg)
{
  error ("Attempted to parse an expression with unknown language");
}

static void
unk_lang_emit_char (int c, struct ui_file *stream, int quoter)
{
  error ("internal error - unimplemented function unk_lang_emit_char called.");
}

static void
unk_lang_printchar (int c, struct ui_file *stream)
{
  error ("internal error - unimplemented function unk_lang_printchar called.");
}

static void
unk_lang_printstr (struct ui_file *stream, char *string, unsigned int length,
		   int width, int force_ellipses)
{
  error ("internal error - unimplemented function unk_lang_printstr called.");
}

static struct type *
unk_lang_create_fundamental_type (struct objfile *objfile, int typeid)
{
  error ("internal error - unimplemented function unk_lang_create_fundamental_type called.");
}

static void
unk_lang_print_type (struct type *type, char *varstring, struct ui_file *stream,
		     int show, int level)
{
  error ("internal error - unimplemented function unk_lang_print_type called.");
}

static int
unk_lang_val_print (struct type *type, char *valaddr, int embedded_offset,
		    CORE_ADDR address, struct ui_file *stream, int format,
		    int deref_ref, int recurse, enum val_prettyprint pretty)
{
  error ("internal error - unimplemented function unk_lang_val_print called.");
}

static int
unk_lang_value_print (struct value *val, struct ui_file *stream, int format,
		      enum val_prettyprint pretty)
{
  error ("internal error - unimplemented function unk_lang_value_print called.");
}

static CORE_ADDR unk_lang_trampoline (CORE_ADDR pc)
{
  return 0;
}

/* Unknown languages just use the cplus demangler.  */
static char *unk_lang_demangle (const char *mangled, int options)
{
  return cplus_demangle (mangled, options);
}


static struct type **const (unknown_builtin_types[]) =
{
  0
};
static const struct op_print unk_op_print_tab[] =
{
  {NULL, OP_NULL, PREC_NULL, 0}
};

const struct language_defn unknown_language_defn =
{
  "unknown",
  language_unknown,
  &unknown_builtin_types[0],
  range_check_off,
  type_check_off,
  case_sensitive_on,
  &exp_descriptor_standard,
  unk_lang_parser,
  unk_lang_error,
  unk_lang_printchar,		/* Print character constant */
  unk_lang_printstr,
  unk_lang_emit_char,
  unk_lang_create_fundamental_type,
  unk_lang_print_type,		/* Print a type using appropriate syntax */
  unk_lang_val_print,		/* Print a value using appropriate syntax */
  unk_lang_value_print,		/* Print a top-level value */
  unk_lang_trampoline,		/* Language specific skip_trampoline */
  value_of_this,		/* value_of_this */
  basic_lookup_symbol_nonlocal, /* lookup_symbol_nonlocal */
  basic_lookup_transparent_type,/* lookup_transparent_type */
  unk_lang_demangle,		/* Language specific symbol demangler */
  {"", "", "", ""},		/* Binary format info */
  {"0%lo", "0", "o", ""},	/* Octal format info */
  {"%ld", "", "d", ""},		/* Decimal format info */
  {"0x%lx", "0x", "x", ""},	/* Hex format info */
  unk_op_print_tab,		/* expression operators for printing */
  1,				/* c-style arrays */
  0,				/* String lower bound */
  &builtin_type_char,		/* Type of string elements */
  default_word_break_characters,
  LANG_MAGIC
};

/* These two structs define fake entries for the "local" and "auto" options. */
const struct language_defn auto_language_defn =
{
  "auto",
  language_auto,
  &unknown_builtin_types[0],
  range_check_off,
  type_check_off,
  case_sensitive_on,
  &exp_descriptor_standard,
  unk_lang_parser,
  unk_lang_error,
  unk_lang_printchar,		/* Print character constant */
  unk_lang_printstr,
  unk_lang_emit_char,
  unk_lang_create_fundamental_type,
  unk_lang_print_type,		/* Print a type using appropriate syntax */
  unk_lang_val_print,		/* Print a value using appropriate syntax */
  unk_lang_value_print,		/* Print a top-level value */
  unk_lang_trampoline,		/* Language specific skip_trampoline */
  value_of_this,		/* value_of_this */
  basic_lookup_symbol_nonlocal,	/* lookup_symbol_nonlocal */
  basic_lookup_transparent_type,/* lookup_transparent_type */
  unk_lang_demangle,		/* Language specific symbol demangler */
  {"", "", "", ""},		/* Binary format info */
  {"0%lo", "0", "o", ""},	/* Octal format info */
  {"%ld", "", "d", ""},		/* Decimal format info */
  {"0x%lx", "0x", "x", ""},	/* Hex format info */
  unk_op_print_tab,		/* expression operators for printing */
  1,				/* c-style arrays */
  0,				/* String lower bound */
  &builtin_type_char,		/* Type of string elements */
  default_word_break_characters,
  LANG_MAGIC
};

const struct language_defn local_language_defn =
{
  "local",
  language_auto,
  &unknown_builtin_types[0],
  range_check_off,
  type_check_off,
  case_sensitive_on,
  &exp_descriptor_standard,
  unk_lang_parser,
  unk_lang_error,
  unk_lang_printchar,		/* Print character constant */
  unk_lang_printstr,
  unk_lang_emit_char,
  unk_lang_create_fundamental_type,
  unk_lang_print_type,		/* Print a type using appropriate syntax */
  unk_lang_val_print,		/* Print a value using appropriate syntax */
  unk_lang_value_print,		/* Print a top-level value */
  unk_lang_trampoline,		/* Language specific skip_trampoline */
  value_of_this,		/* value_of_this */
  basic_lookup_symbol_nonlocal,	/* lookup_symbol_nonlocal */
  basic_lookup_transparent_type,/* lookup_transparent_type */
  unk_lang_demangle,		/* Language specific symbol demangler */
  {"", "", "", ""},		/* Binary format info */
  {"0%lo", "0", "o", ""},	/* Octal format info */
  {"%ld", "", "d", ""},		/* Decimal format info */
  {"0x%lx", "0x", "x", ""},	/* Hex format info */
  unk_op_print_tab,		/* expression operators for printing */
  1,				/* c-style arrays */
  0,				/* String lower bound */
  &builtin_type_char,		/* Type of string elements */
  default_word_break_characters,
  LANG_MAGIC
};

/* Initialize the language routines */

void
_initialize_language (void)
{
  struct cmd_list_element *set, *show;

  /* GDB commands for language specific stuff */

  set = add_set_cmd ("language", class_support, var_string_noescape,
		     (char *) &language,
		     "Set the current source language.",
		     &setlist);
  show = add_show_from_set (set, &showlist);
  set_cmd_cfunc (set, set_language_command);
  set_cmd_cfunc (show, show_language_command);

  add_prefix_cmd ("check", no_class, set_check,
		  "Set the status of the type/range checker.",
		  &setchecklist, "set check ", 0, &setlist);
  add_alias_cmd ("c", "check", no_class, 1, &setlist);
  add_alias_cmd ("ch", "check", no_class, 1, &setlist);

  add_prefix_cmd ("check", no_class, show_check,
		  "Show the status of the type/range checker.",
		  &showchecklist, "show check ", 0, &showlist);
  add_alias_cmd ("c", "check", no_class, 1, &showlist);
  add_alias_cmd ("ch", "check", no_class, 1, &showlist);

  set = add_set_cmd ("type", class_support, var_string_noescape,
		     (char *) &type,
		     "Set type checking.  (on/warn/off/auto)",
		     &setchecklist);
  show = add_show_from_set (set, &showchecklist);
  set_cmd_cfunc (set, set_type_command);
  set_cmd_cfunc (show, show_type_command);

  set = add_set_cmd ("range", class_support, var_string_noescape,
		     (char *) &range,
		     "Set range checking.  (on/warn/off/auto)",
		     &setchecklist);
  show = add_show_from_set (set, &showchecklist);
  set_cmd_cfunc (set, set_range_command);
  set_cmd_cfunc (show, show_range_command);

  set = add_set_cmd ("case-sensitive", class_support, var_string_noescape,
                     (char *) &case_sensitive,
                     "Set case sensitivity in name search.  (on/off/auto)\n\
For Fortran the default is off; for other languages the default is on.",
                     &setlist);
  show = add_show_from_set (set, &showlist);
  set_cmd_cfunc (set, set_case_command);
  set_cmd_cfunc (show, show_case_command);

  add_language (&unknown_language_defn);
  add_language (&local_language_defn);
  add_language (&auto_language_defn);

  language = savestring ("auto", strlen ("auto"));
  type = savestring ("auto", strlen ("auto"));
  range = savestring ("auto", strlen ("auto"));
  case_sensitive = savestring ("auto",strlen ("auto"));

  /* Have the above take effect */
  set_language (language_auto);
}
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d581 125
a1178 10
/* Return class name from physname or NULL.  */
char *
language_class_name_from_physname (const struct language_defn *current_language,
				   const char *physname)
{
  if (current_language != NULL && current_language->la_class_name_from_physname)
    return current_language->la_class_name_from_physname (physname);
  return NULL;
}

d1261 2
a1262 1
static char *unk_lang_class_name (const char *mangled)
d1264 2
a1265 3
  return NULL;
}

a1270 9
static void
unknown_language_arch_info (struct gdbarch *gdbarch,
			    struct language_arch_info *lai)
{
  lai->string_char_type = builtin_type (gdbarch)->builtin_char;
  lai->primitive_type_vector = GDBARCH_OBSTACK_CALLOC (gdbarch, 1,
						       struct type *);
}

d1275 1
a1275 1
  NULL,
a1277 1
  array_row_major,
a1281 1
  null_post_parser,
d1294 4
a1297 1
  unk_lang_class_name,		/* Language specific class_name_from_physname */
d1301 1
a1301 1
  NULL,
a1302 1
  unknown_language_arch_info,	/* la_language_arch_info.  */
d1311 1
a1311 1
  NULL,
a1313 1
  array_row_major,
a1317 1
  null_post_parser,
d1330 4
a1333 1
  unk_lang_class_name,		/* Language specific class_name_from_physname */
d1337 1
a1337 1
  NULL,
a1338 1
  unknown_language_arch_info,	/* la_language_arch_info.  */
d1346 1
a1346 1
  NULL,
a1349 1
  array_row_major,
a1352 1
  null_post_parser,
d1365 4
a1368 1
  unk_lang_class_name,		/* Language specific class_name_from_physname */
d1372 1
a1372 1
  NULL,
a1373 1
  unknown_language_arch_info,	/* la_language_arch_info.  */
a1376 70
/* Per-architecture language information.  */

static struct gdbarch_data *language_gdbarch_data;

struct language_gdbarch
{
  /* A vector of per-language per-architecture info.  Indexed by "enum
     language".  */
  struct language_arch_info arch_info[nr_languages];
};

static void *
language_gdbarch_post_init (struct gdbarch *gdbarch)
{
  struct language_gdbarch *l;
  int i;

  l = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct language_gdbarch);
  for (i = 0; i < languages_size; i++)
    {
      if (languages[i] != NULL
	  && languages[i]->la_language_arch_info != NULL)
	languages[i]->la_language_arch_info
	  (gdbarch, l->arch_info + languages[i]->la_language);
    }
  return l;
}

struct type *
language_string_char_type (const struct language_defn *la,
			   struct gdbarch *gdbarch)
{
  struct language_gdbarch *ld = gdbarch_data (gdbarch,
					      language_gdbarch_data);
  if (ld->arch_info[la->la_language].string_char_type != NULL)
    return ld->arch_info[la->la_language].string_char_type;
  else
    return (*la->string_char_type);
}

struct type *
language_lookup_primitive_type_by_name (const struct language_defn *la,
					struct gdbarch *gdbarch,
					const char *name)
{
  struct language_gdbarch *ld = gdbarch_data (gdbarch,
					      language_gdbarch_data);
  if (ld->arch_info[la->la_language].primitive_type_vector != NULL)
    {
      struct type *const *p;
      for (p = ld->arch_info[la->la_language].primitive_type_vector;
	   (*p) != NULL;
	   p++)
	{
	  if (strcmp (TYPE_NAME (*p), name) == 0)
	    return (*p);
	}
    }
  else
    {
      struct type **const *p;
      for (p = current_language->la_builtin_type_vector; *p != NULL; p++)
	{
	  if (strcmp (TYPE_NAME (**p), name) == 0)
	    return (**p);
	}
    }
  return (NULL);
}

a1383 3
  language_gdbarch_data
    = gdbarch_data_register_post_init (language_gdbarch_post_init);

d1390 1
a1390 1
  show = deprecated_add_show_from_set (set, &showlist);
d1410 1
a1410 1
  show = deprecated_add_show_from_set (set, &showchecklist);
d1418 1
a1418 1
  show = deprecated_add_show_from_set (set, &showchecklist);
d1427 1
a1427 1
  show = deprecated_add_show_from_set (set, &showlist);
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 1419
/* Multiple source language support for GDB.
   Copyright 1991, 1992 Free Software Foundation, Inc.
   Contributed by the Department of Computer Science at the State University
   of New York at Buffalo.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* This file contains functions that return things that are specific
   to languages.  Each function should examine current_language if necessary,
   and return the appropriate result. */

/* FIXME:  Most of these would be better organized as macros which
   return data out of a "language-specific" struct pointer that is set
   whenever the working language changes.  That would be a lot faster.  */

#include "defs.h"
#include <ctype.h>
#include "gdb_string.h"
#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif

#include "symtab.h"
#include "gdbtypes.h"
#include "value.h"
#include "gdbcmd.h"
#include "frame.h"
#include "expression.h"
#include "language.h"
#include "target.h"
#include "parser-defs.h"

static void
show_language_command PARAMS ((char *, int));

static void
set_language_command PARAMS ((char *, int));

static void
show_type_command PARAMS ((char *, int));

static void
set_type_command PARAMS ((char *, int));

static void
show_range_command PARAMS ((char *, int));

static void
set_range_command PARAMS ((char *, int));

static void
set_range_str PARAMS ((void));

static void
set_type_str PARAMS ((void));

static void
set_lang_str PARAMS ((void));

static void
unk_lang_error PARAMS ((char *));

static int
unk_lang_parser PARAMS ((void));

static void
show_check PARAMS ((char *, int));

static void
set_check PARAMS ((char *, int));

static void
set_type_range PARAMS ((void));

static void
unk_lang_printchar PARAMS ((int, GDB_FILE *));

static void
unk_lang_printstr PARAMS ((GDB_FILE *, char *, unsigned int, int));

static struct type *
unk_lang_create_fundamental_type PARAMS ((struct objfile *, int));

static void
unk_lang_print_type PARAMS ((struct type *, char *, GDB_FILE *, int, int));

static int
unk_lang_val_print PARAMS ((struct type *, char *, CORE_ADDR, GDB_FILE *,
			    int, int, int, enum val_prettyprint));

static int
unk_lang_value_print PARAMS ((value_ptr, GDB_FILE *, int, enum val_prettyprint));

/* Forward declaration */
extern const struct language_defn unknown_language_defn;
extern char *warning_pre_print;
  
/* The current (default at startup) state of type and range checking.
    (If the modes are set to "auto", though, these are changed based
    on the default language at startup, and then again based on the
    language of the first source file.  */

enum range_mode range_mode = range_mode_auto;
enum range_check range_check = range_check_off;
enum type_mode type_mode = type_mode_auto;
enum type_check type_check = type_check_off;

/* The current language and language_mode (see language.h) */

const struct language_defn *current_language = &unknown_language_defn;
enum language_mode language_mode = language_mode_auto;

/* The language that the user expects to be typing in (the language
   of main(), or the last language we notified them about, or C).  */

const struct language_defn *expected_language;

/* The list of supported languages.  The list itself is malloc'd.  */

static const struct language_defn **languages;
static unsigned languages_size;
static unsigned languages_allocsize;
#define	DEFAULT_ALLOCSIZE 4

/* The "set language/type/range" commands all put stuff in these
   buffers.  This is to make them work as set/show commands.  The
   user's string is copied here, then the set_* commands look at
   them and update them to something that looks nice when it is
   printed out. */

static char *language;
static char *type;
static char *range;

/* Warning issued when current_language and the language of the current
   frame do not match. */
char lang_frame_mismatch_warn[] =
	"Warning: the current language does not match this frame.";


/* This page contains the functions corresponding to GDB commands
   and their helpers. */

/* Show command.  Display a warning if the language set
   does not match the frame. */
static void
show_language_command (ignore, from_tty)
   char *ignore;
   int from_tty;
{
   enum language flang;		/* The language of the current frame */

   flang = get_frame_language();
   if (flang != language_unknown &&
      language_mode == language_mode_manual &&
      current_language->la_language != flang)
      printf_filtered("%s\n",lang_frame_mismatch_warn);
}

/* Set command.  Change the current working language. */
static void
set_language_command (ignore, from_tty)
   char *ignore;
   int from_tty;
{
  int i;
  enum language flang;
  char *err_lang;

  if (!language || !language[0])
    {
      printf_unfiltered("The currently understood settings are:\n\n");
      printf_unfiltered ("local or auto    Automatic setting based on source file\n");

      for (i = 0; i < languages_size; ++i)
	{
	  /* Already dealt with these above.  */
	  if (languages[i]->la_language == language_unknown
	      || languages[i]->la_language == language_auto)
	    continue;

	  /* FIXME for now assume that the human-readable name is just
	     a capitalization of the internal name.  */
	  printf_unfiltered ("%-16s Use the %c%s language\n",
			     languages[i]->la_name,
			     /* Capitalize first letter of language
				name.  */
			     toupper (languages[i]->la_name[0]),
			     languages[i]->la_name + 1);
	}
      /* Restore the silly string. */
      set_language(current_language->la_language);
      return;
    }

  /* Search the list of languages for a match.  */
  for (i = 0; i < languages_size; i++) {
    if (STREQ (languages[i]->la_name, language)) {
      /* Found it!  Go into manual mode, and use this language.  */
      if (languages[i]->la_language == language_auto) {
	/* Enter auto mode.  Set to the current frame's language, if known.  */
	language_mode = language_mode_auto;
  	flang = get_frame_language();
	if (flang!=language_unknown)
	  set_language(flang);
	expected_language = current_language;
	return;
      } else {
	/* Enter manual mode.  Set the specified language.  */
	language_mode = language_mode_manual;
	current_language = languages[i];
	set_type_range ();
	set_lang_str();
	expected_language = current_language;
	return;
      }
    }
  }

  /* Reset the language (esp. the global string "language") to the 
     correct values. */
  err_lang=savestring(language,strlen(language));
  make_cleanup (free, err_lang);	/* Free it after error */
  set_language(current_language->la_language);
  error ("Unknown language `%s'.",err_lang);
}

/* Show command.  Display a warning if the type setting does
   not match the current language. */
static void
show_type_command(ignore, from_tty)
   char *ignore;
   int from_tty;
{
   if (type_check != current_language->la_type_check)
      printf_unfiltered(
"Warning: the current type check setting does not match the language.\n");
}

/* Set command.  Change the setting for type checking. */
static void
set_type_command(ignore, from_tty)
   char *ignore;
   int from_tty;
{
   if (STREQ(type,"on"))
   {
      type_check = type_check_on;
      type_mode = type_mode_manual;
   }
   else if (STREQ(type,"warn"))
   {
      type_check = type_check_warn;
      type_mode = type_mode_manual;
   }
   else if (STREQ(type,"off"))
   {
      type_check = type_check_off;
      type_mode = type_mode_manual;
   }
   else if (STREQ(type,"auto"))
   {
      type_mode = type_mode_auto;
      set_type_range();
      /* Avoid hitting the set_type_str call below.  We
         did it in set_type_range. */
      return;
   }
   set_type_str();
   show_type_command((char *)NULL, from_tty);
}

/* Show command.  Display a warning if the range setting does
   not match the current language. */
static void
show_range_command(ignore, from_tty)
   char *ignore;
   int from_tty;
{

   if (range_check != current_language->la_range_check)
      printf_unfiltered(
"Warning: the current range check setting does not match the language.\n");
}

/* Set command.  Change the setting for range checking. */
static void
set_range_command(ignore, from_tty)
   char *ignore;
   int from_tty;
{
   if (STREQ(range,"on"))
   {
      range_check = range_check_on;
      range_mode = range_mode_manual;
   }
   else if (STREQ(range,"warn"))
   {
      range_check = range_check_warn;
      range_mode = range_mode_manual;
   }
   else if (STREQ(range,"off"))
   {
      range_check = range_check_off;
      range_mode = range_mode_manual;
   }
   else if (STREQ(range,"auto"))
   {
      range_mode = range_mode_auto;
      set_type_range();
      /* Avoid hitting the set_range_str call below.  We
	 did it in set_type_range. */
      return;
   }
   set_range_str();
   show_range_command((char *)0, from_tty);
}

/* Set the status of range and type checking based on
   the current modes and the current language.
   If SHOW is non-zero, then print out the current language,
   type and range checking status. */
static void
set_type_range()
{

  if (range_mode == range_mode_auto)
    range_check = current_language->la_range_check;

  if (type_mode == type_mode_auto)
    type_check = current_language->la_type_check;

  set_type_str();
  set_range_str();
}

/* Set current language to (enum language) LANG.  */

void
set_language(lang)
   enum language lang;
{
  int i;

  for (i = 0; i < languages_size; i++) {
    if (languages[i]->la_language == lang) {
      current_language = languages[i];
      set_type_range ();
      set_lang_str();
      break;
    }
  }
}

/* This page contains functions that update the global vars
   language, type and range. */
static void
set_lang_str()
{
   char *prefix = "";

   free (language);
   if (language_mode == language_mode_auto)
      prefix = "auto; currently ";

   language = concat(prefix, current_language->la_name, NULL);
}

static void
set_type_str()
{
   char *tmp, *prefix = "";

   free (type);
   if (type_mode==type_mode_auto)
      prefix = "auto; currently ";

   switch(type_check)
   {
   case type_check_on:
      tmp = "on";
      break;
   case type_check_off:
      tmp = "off";
      break;
   case type_check_warn:
      tmp = "warn";
      break;
      default:
      error ("Unrecognized type check setting.");
   }

   type = concat(prefix,tmp,NULL);
}

static void
set_range_str()
{
   char *tmp, *pref = "";

   free (range);
   if (range_mode==range_mode_auto)
      pref = "auto; currently ";

   switch(range_check)
   {
   case range_check_on:
      tmp = "on";
      break;
   case range_check_off:
      tmp = "off";
      break;
   case range_check_warn:
      tmp = "warn";
      break;
      default:
      error ("Unrecognized range check setting.");
   }

   range = concat(pref,tmp,NULL);
}


/* Print out the current language settings: language, range and
   type checking.  If QUIETLY, print only what has changed.  */

void
language_info (quietly)
     int quietly;
{
  if (quietly && expected_language == current_language)
    return;

  expected_language = current_language;
  printf_unfiltered("Current language:  %s\n",language);
  show_language_command((char *)0, 1);

  if (!quietly)
    {
       printf_unfiltered("Type checking:     %s\n",type);
       show_type_command((char *)0, 1);
       printf_unfiltered("Range checking:    %s\n",range);
       show_range_command((char *)0, 1);
    }
}

/* Return the result of a binary operation. */

#if 0	/* Currently unused */

struct type *
binop_result_type (v1, v2)
   value_ptr v1, v2;
{
   int size,uns;
   struct type *t1 = check_typedef (VALUE_TYPE (v1));
   struct type *t2 = check_typedef (VALUE_TYPE (v2));

   int l1 = TYPE_LENGTH (t1);
   int l2 = TYPE_LENGTH (t2);

   switch(current_language->la_language)
   {
   case language_c:
   case language_cplus:
      if (TYPE_CODE (t1)==TYPE_CODE_FLT)
	 return TYPE_CODE(t2) == TYPE_CODE_FLT && l2 > l1 ?
	    VALUE_TYPE(v2) : VALUE_TYPE(v1);
      else if (TYPE_CODE(t2)==TYPE_CODE_FLT)
	 return TYPE_CODE(t1)) == TYPE_CODE_FLT && l1 > l2 ?
	    VALUE_TYPE(v1) : VALUE_TYPE(v2);
      else if (TYPE_UNSIGNED(t1) && l1 > l2)
	 return VALUE_TYPE(v1);
      else if (TYPE_UNSIGNED(t2) && l2 > l1)
	 return VALUE_TYPE(v2);
      else  /* Both are signed.  Result is the longer type */
	 return l1 > l2 ? VALUE_TYPE(v1) : VALUE_TYPE(v2);
      break;
   case language_m2:
      /* If we are doing type-checking, l1 should equal l2, so this is
	 not needed. */
      return l1 > l2 ? VALUE_TYPE(v1) : VALUE_TYPE(v2);
      break;
   case language_chill:
      error ("Missing Chill support in function binop_result_check.");/*FIXME*/
   }
   abort();
   return (struct type *)0;	/* For lint */
}

#endif	/* 0 */


/* This page contains functions that return format strings for
   printf for printing out numbers in different formats */

/* Returns the appropriate printf format for hexadecimal
   numbers. */
char *
local_hex_format_custom(pre)
   char *pre;
{
   static char form[50];

   strcpy (form, local_hex_format_prefix ());
   strcat (form, "%");
   strcat (form, pre);
   strcat (form, local_hex_format_specifier ());
   strcat (form, local_hex_format_suffix ());
   return form;
}

/* Converts a number to hexadecimal and stores it in a static
   string.  Returns a pointer to this string. */
char *
local_hex_string (num)
   unsigned long num;
{
   static char res[50];

   sprintf (res, local_hex_format(), num);
   return res;
}

/* Converts a number to custom hexadecimal and stores it in a static
   string.  Returns a pointer to this string. */
char *
local_hex_string_custom(num,pre)
   unsigned long num;
   char *pre;
{
   static char res[50];

   sprintf (res, local_hex_format_custom(pre), num);
   return res;
}

/* Returns the appropriate printf format for octal
   numbers. */
char *
local_octal_format_custom(pre)
   char *pre;
{
   static char form[50];

   strcpy (form, local_octal_format_prefix ());
   strcat (form, "%");
   strcat (form, pre);
   strcat (form, local_octal_format_specifier ());
   strcat (form, local_octal_format_suffix ());
   return form;
}

/* Returns the appropriate printf format for decimal numbers. */
char *
local_decimal_format_custom(pre)
   char *pre;
{
   static char form[50];

   strcpy (form, local_decimal_format_prefix ());
   strcat (form, "%");
   strcat (form, pre);
   strcat (form, local_decimal_format_specifier ());
   strcat (form, local_decimal_format_suffix ());
   return form;
}

#if 0
/* This page contains functions that are used in type/range checking.
   They all return zero if the type/range check fails.

   It is hoped that these will make extending GDB to parse different
   languages a little easier.  These are primarily used in eval.c when
   evaluating expressions and making sure that their types are correct.
   Instead of having a mess of conjucted/disjuncted expressions in an "if",
   the ideas of type can be wrapped up in the following functions.

   Note that some of them are not currently dependent upon which language
   is currently being parsed.  For example, floats are the same in
   C and Modula-2 (ie. the only floating point type has TYPE_CODE of
   TYPE_CODE_FLT), while booleans are different. */

/* Returns non-zero if its argument is a simple type.  This is the same for
   both Modula-2 and for C.  In the C case, TYPE_CODE_CHAR will never occur,
   and thus will never cause the failure of the test. */
int
simple_type(type)
    struct type *type;
{
  CHECK_TYPEDEF (type);
  switch (TYPE_CODE (type)) {
  case TYPE_CODE_INT:
  case TYPE_CODE_CHAR:
  case TYPE_CODE_ENUM:
  case TYPE_CODE_FLT:
  case TYPE_CODE_RANGE:
  case TYPE_CODE_BOOL:
    return 1;

  default:
    return 0;
  }
}

/* Returns non-zero if its argument is of an ordered type.
   An ordered type is one in which the elements can be tested for the
   properties of "greater than", "less than", etc, or for which the
   operations "increment" or "decrement" make sense. */
int
ordered_type (type)
   struct type *type;
{
  CHECK_TYPEDEF (type);
  switch (TYPE_CODE (type)) {
  case TYPE_CODE_INT:
  case TYPE_CODE_CHAR:
  case TYPE_CODE_ENUM:
  case TYPE_CODE_FLT:
  case TYPE_CODE_RANGE:
    return 1;

  default:
    return 0;
  }
}

/* Returns non-zero if the two types are the same */
int
same_type (arg1, arg2)
   struct type *arg1, *arg2;
{
  CHECK_TYPEDEF (type);
   if (structured_type(arg1) ? !structured_type(arg2) : structured_type(arg2))
      /* One is structured and one isn't */
      return 0;
   else if (structured_type(arg1) && structured_type(arg2))
      return arg1 == arg2;
   else if (numeric_type(arg1) && numeric_type(arg2))
      return (TYPE_CODE(arg2) == TYPE_CODE(arg1)) &&
	 (TYPE_UNSIGNED(arg1) == TYPE_UNSIGNED(arg2))
	    ? 1 : 0;
   else
      return arg1==arg2;
}

/* Returns non-zero if the type is integral */
int
integral_type (type)
   struct type *type;
{
  CHECK_TYPEDEF (type);
   switch(current_language->la_language)
   {
   case language_c:
   case language_cplus:
      return (TYPE_CODE(type) != TYPE_CODE_INT) &&
	 (TYPE_CODE(type) != TYPE_CODE_ENUM) ? 0 : 1;
   case language_m2:
      return TYPE_CODE(type) != TYPE_CODE_INT ? 0 : 1;
   case language_chill:
      error ("Missing Chill support in function integral_type.");  /*FIXME*/
   default:
      error ("Language not supported.");
   }
}

/* Returns non-zero if the value is numeric */
int
numeric_type (type)
   struct type *type;
{
  CHECK_TYPEDEF (type);
  switch (TYPE_CODE (type)) {
  case TYPE_CODE_INT:
  case TYPE_CODE_FLT:
    return 1;

  default:
    return 0;
  }
}

/* Returns non-zero if the value is a character type */
int
character_type (type)
   struct type *type;
{
  CHECK_TYPEDEF (type);
  switch(current_language->la_language)
   {
   case language_chill:
   case language_m2:
      return TYPE_CODE(type) != TYPE_CODE_CHAR ? 0 : 1;

   case language_c:
   case language_cplus:
      return (TYPE_CODE(type) == TYPE_CODE_INT) &&
	 TYPE_LENGTH(type) == sizeof(char)
	 ? 1 : 0;
   default:
      return (0);
   }
}

/* Returns non-zero if the value is a string type */
int
string_type (type)
   struct type *type;
{
  CHECK_TYPEDEF (type);
  switch(current_language->la_language)
   {
   case language_chill:
   case language_m2:
      return TYPE_CODE(type) != TYPE_CODE_STRING ? 0 : 1;

   case language_c:
   case language_cplus:
      /* C does not have distinct string type. */
      return (0);
   default:
      return (0);
   }
}

/* Returns non-zero if the value is a boolean type */
int
boolean_type (type)
   struct type *type;
{
  CHECK_TYPEDEF (type);
  if (TYPE_CODE (type) == TYPE_CODE_BOOL)
    return 1;
  switch(current_language->la_language)
    {
    case language_c:
    case language_cplus:
      /* Might be more cleanly handled by having a TYPE_CODE_INT_NOT_BOOL
	 for CHILL and such languages, or a TYPE_CODE_INT_OR_BOOL for C.  */
      if (TYPE_CODE (type) == TYPE_CODE_INT)
	return 1;
   default:
      break;
   }
  return 0;
}

/* Returns non-zero if the value is a floating-point type */
int
float_type (type)
   struct type *type;
{
  CHECK_TYPEDEF (type);
  return TYPE_CODE(type) == TYPE_CODE_FLT;
}

/* Returns non-zero if the value is a pointer type */
int
pointer_type(type)
   struct type *type;
{
   return TYPE_CODE(type) == TYPE_CODE_PTR ||
      TYPE_CODE(type) == TYPE_CODE_REF;
}

/* Returns non-zero if the value is a structured type */
int
structured_type(type)
   struct type *type;
{
  CHECK_TYPEDEF (type);
   switch(current_language->la_language)
   {
   case language_c:
   case language_cplus:
      return (TYPE_CODE(type) == TYPE_CODE_STRUCT) ||
	 (TYPE_CODE(type) == TYPE_CODE_UNION) ||
	    (TYPE_CODE(type) == TYPE_CODE_ARRAY);
   case language_m2:
      return (TYPE_CODE(type) == TYPE_CODE_STRUCT) ||
	 (TYPE_CODE(type) == TYPE_CODE_SET) ||
	    (TYPE_CODE(type) == TYPE_CODE_ARRAY);
   case language_chill:
      error ("Missing Chill support in function structured_type.");  /*FIXME*/
   default:
      return (0);
   }
}
#endif

struct type *
lang_bool_type ()
{
  struct symbol *sym;
  struct type *type;
  switch(current_language->la_language)
    {
    case language_chill:
      return builtin_type_chill_bool;
    case language_fortran:
      sym = lookup_symbol ("logical", NULL, VAR_NAMESPACE, NULL, NULL);
      if (sym)
	{
	  type = SYMBOL_TYPE (sym);
	  if (type && TYPE_CODE (type) == TYPE_CODE_BOOL)
	    return type;
	}
      return builtin_type_f_logical_s2;
    case language_cplus:
      sym = lookup_symbol ("bool", NULL, VAR_NAMESPACE, NULL, NULL);
      if (sym)
	{
	  type = SYMBOL_TYPE (sym);
	  if (type && TYPE_CODE (type) == TYPE_CODE_BOOL)
	    return type;
	}
      /* ... else fall through ... */
    default:
      return builtin_type_int;
    }
}

/* This page contains functions that return info about
   (struct value) values used in GDB. */

/* Returns non-zero if the value VAL represents a true value. */
int
value_true (val)
     value_ptr val;
{
  /* It is possible that we should have some sort of error if a non-boolean
     value is used in this context.  Possibly dependent on some kind of
     "boolean-checking" option like range checking.  But it should probably
     not depend on the language except insofar as is necessary to identify
     a "boolean" value (i.e. in C using a float, pointer, etc., as a boolean
     should be an error, probably).  */
  return !value_logical_not (val);
}

/* Returns non-zero if the operator OP is defined on
   the values ARG1 and ARG2. */

#if 0	/* Currently unused */

void
binop_type_check(arg1,arg2,op)
   value_ptr arg1,arg2;
   int op;
{
   struct type *t1, *t2;

   /* If we're not checking types, always return success. */
   if (!STRICT_TYPE)
      return;

   t1=VALUE_TYPE(arg1);
   if (arg2 != NULL)
      t2=VALUE_TYPE(arg2);
   else
      t2=NULL;

   switch(op)
   {
   case BINOP_ADD:
   case BINOP_SUB:
      if ((numeric_type(t1) && pointer_type(t2)) ||
	 (pointer_type(t1) && numeric_type(t2)))
      {
	 warning ("combining pointer and integer.\n");
	 break;
      }
   case BINOP_MUL:
   case BINOP_LSH:
   case BINOP_RSH:
      if (!numeric_type(t1) || !numeric_type(t2))
	 type_op_error ("Arguments to %s must be numbers.",op);
      else if (!same_type(t1,t2))
	 type_op_error ("Arguments to %s must be of the same type.",op);
      break;

   case BINOP_LOGICAL_AND:
   case BINOP_LOGICAL_OR:
      if (!boolean_type(t1) || !boolean_type(t2))
	 type_op_error ("Arguments to %s must be of boolean type.",op);
      break;

   case BINOP_EQUAL:
      if ((pointer_type(t1) && !(pointer_type(t2) || integral_type(t2))) ||
	 (pointer_type(t2) && !(pointer_type(t1) || integral_type(t1))))
	 type_op_error ("A pointer can only be compared to an integer or pointer.",op);
      else if ((pointer_type(t1) && integral_type(t2)) ||
	 (integral_type(t1) && pointer_type(t2)))
      {
	 warning ("combining integer and pointer.\n");
	 break;
      }
      else if (!simple_type(t1) || !simple_type(t2))
	 type_op_error ("Arguments to %s must be of simple type.",op);
      else if (!same_type(t1,t2))
	 type_op_error ("Arguments to %s must be of the same type.",op);
      break;

   case BINOP_REM:
   case BINOP_MOD:
      if (!integral_type(t1) || !integral_type(t2))
	 type_op_error ("Arguments to %s must be of integral type.",op);
      break;

   case BINOP_LESS:
   case BINOP_GTR:
   case BINOP_LEQ:
   case BINOP_GEQ:
      if (!ordered_type(t1) || !ordered_type(t2))
	 type_op_error ("Arguments to %s must be of ordered type.",op);
      else if (!same_type(t1,t2))
	 type_op_error ("Arguments to %s must be of the same type.",op);
      break;

   case BINOP_ASSIGN:
      if (pointer_type(t1) && !integral_type(t2))
	 type_op_error ("A pointer can only be assigned an integer.",op);
      else if (pointer_type(t1) && integral_type(t2))
      {
	 warning ("combining integer and pointer.");
	 break;
      }
      else if (!simple_type(t1) || !simple_type(t2))
	 type_op_error ("Arguments to %s must be of simple type.",op);
      else if (!same_type(t1,t2))
	 type_op_error ("Arguments to %s must be of the same type.",op);
      break;

    case BINOP_CONCAT:
      /* FIXME:  Needs to handle bitstrings as well. */
      if (!(string_type(t1) || character_type(t1) || integral_type(t1))
	  || !(string_type(t2) || character_type(t2) || integral_type(t2)))
	  type_op_error ("Arguments to %s must be strings or characters.", op);
      break;

   /* Unary checks -- arg2 is null */

   case UNOP_LOGICAL_NOT:
      if (!boolean_type(t1))
	 type_op_error ("Argument to %s must be of boolean type.",op);
      break;

   case UNOP_PLUS:
   case UNOP_NEG:
      if (!numeric_type(t1))
	 type_op_error ("Argument to %s must be of numeric type.",op);
      break;

   case UNOP_IND:
      if (integral_type(t1))
      {
	 warning ("combining pointer and integer.\n");
	 break;
      }
      else if (!pointer_type(t1))
	 type_op_error ("Argument to %s must be a pointer.",op);
      break;

   case UNOP_PREINCREMENT:
   case UNOP_POSTINCREMENT:
   case UNOP_PREDECREMENT:
   case UNOP_POSTDECREMENT:
      if (!ordered_type(t1))
	 type_op_error ("Argument to %s must be of an ordered type.",op);
      break;

   default:
      /* Ok.  The following operators have different meanings in
	 different languages. */
      switch(current_language->la_language)
      {
#ifdef _LANG_c
      case language_c:
      case language_cplus:
	 switch(op)
	 {
	 case BINOP_DIV:
	    if (!numeric_type(t1) || !numeric_type(t2))
	       type_op_error ("Arguments to %s must be numbers.",op);
	    break;
	 }
	 break;
#endif

#ifdef _LANG_m2
      case language_m2:
	 switch(op)
	 {
	 case BINOP_DIV:
	    if (!float_type(t1) || !float_type(t2))
	       type_op_error ("Arguments to %s must be floating point numbers.",op);
	    break;
	 case BINOP_INTDIV:
	    if (!integral_type(t1) || !integral_type(t2))
	       type_op_error ("Arguments to %s must be of integral type.",op);
	    break;
	 }
#endif

#ifdef _LANG_chill
       case language_chill:
	 error ("Missing Chill support in function binop_type_check.");/*FIXME*/
#endif

      }
   }
}

#endif	/* 0 */


/* This page contains functions for the printing out of
   error messages that occur during type- and range-
   checking. */

/* Prints the format string FMT with the operator as a string
   corresponding to the opcode OP.  If FATAL is non-zero, then
   this is an error and error () is called.  Otherwise, it is
   a warning and printf() is called. */
void
op_error (fmt,op,fatal)
   char *fmt;
   enum exp_opcode op;
   int fatal;
{
   if (fatal)
      error (fmt,op_string(op));
   else
   {
      warning (fmt,op_string(op));
   }
}

/* These are called when a language fails a type- or range-check.
   The first argument should be a printf()-style format string, and
   the rest of the arguments should be its arguments.  If
   [type|range]_check is [type|range]_check_on, then return_to_top_level()
   is called in the style of error ().  Otherwise, the message is prefixed
   by the value of warning_pre_print and we do not return to the top level. */

void
#ifdef ANSI_PROTOTYPES
type_error (char *string, ...)
#else
type_error (va_alist)
     va_dcl
#endif
{
   va_list args;
#ifdef ANSI_PROTOTYPES
   va_start (args, string);
#else
   char *string;
   va_start (args);
   string = va_arg (args, char *);
#endif

   if (type_check == type_check_warn)
     fprintf_filtered (gdb_stderr, warning_pre_print);
   else
     error_begin ();

   vfprintf_filtered (gdb_stderr, string, args);
   fprintf_filtered (gdb_stderr, "\n");
   va_end (args);
   if (type_check == type_check_on)
     return_to_top_level (RETURN_ERROR);
}

void
#ifdef ANSI_PROTOTYPES
range_error (char *string, ...)
#else
range_error (va_alist)
     va_dcl
#endif
{
   va_list args;
#ifdef ANSI_PROTOTYPES
   va_start (args, string);
#else
   char *string;
   va_start (args);
   string = va_arg (args, char *);
#endif

   if (range_check == range_check_warn)
     fprintf_filtered (gdb_stderr, warning_pre_print);
   else
     error_begin ();

   vfprintf_filtered (gdb_stderr, string, args);
   fprintf_filtered (gdb_stderr, "\n");
   va_end (args);
   if (range_check == range_check_on)
     return_to_top_level (RETURN_ERROR);
}


/* This page contains miscellaneous functions */

/* Return the language struct for a given language enum. */

const struct language_defn *
language_def(lang)
   enum language lang;
{
  int i;

  for (i = 0; i < languages_size; i++) {
    if (languages[i]->la_language == lang) {
      return languages[i];
    }
  }
  return NULL;
}

/* Return the language as a string */
char *
language_str(lang)
   enum language lang;
{
  int i;

  for (i = 0; i < languages_size; i++) {
    if (languages[i]->la_language == lang) {
      return languages[i]->la_name;
    }
  }
  return "Unknown";
}

static void
set_check (ignore, from_tty)
   char *ignore;
   int from_tty;
{
   printf_unfiltered(
"\"set check\" must be followed by the name of a check subcommand.\n");
   help_list(setchecklist, "set check ", -1, gdb_stdout);
}

static void
show_check (ignore, from_tty)
   char *ignore;
   int from_tty;
{
   cmd_show_list(showchecklist, from_tty, "");
}

/* Add a language to the set of known languages.  */

void
add_language (lang)
     const struct language_defn *lang;
{
  if (lang->la_magic != LANG_MAGIC)
    {
      fprintf_unfiltered(gdb_stderr, "Magic number of %s language struct wrong\n",
	lang->la_name);
      abort();
    }

  if (!languages)
    {
      languages_allocsize = DEFAULT_ALLOCSIZE;
      languages = (const struct language_defn **) xmalloc
	(languages_allocsize * sizeof (*languages));
    }
  if (languages_size >= languages_allocsize)
    {
      languages_allocsize *= 2;
      languages = (const struct language_defn **) xrealloc ((char *) languages,
	languages_allocsize * sizeof (*languages));
    }
  languages[languages_size++] = lang;
}

/* Define the language that is no language.  */

static int
unk_lang_parser ()
{
  return 1;
}

static void
unk_lang_error (msg)
     char *msg;
{
  error ("Attempted to parse an expression with unknown language");
}

static void
unk_lang_printchar (c, stream)
     register int c;
     GDB_FILE *stream;
{
  error ("internal error - unimplemented function unk_lang_printchar called.");
}

static void
unk_lang_printstr (stream, string, length, force_ellipses)
     GDB_FILE *stream;
     char *string;
     unsigned int length;
     int force_ellipses;
{
  error ("internal error - unimplemented function unk_lang_printstr called.");
}

static struct type *
unk_lang_create_fundamental_type (objfile, typeid)
     struct objfile *objfile;
     int typeid;
{
  error ("internal error - unimplemented function unk_lang_create_fundamental_type called.");
}

static void
unk_lang_print_type (type, varstring, stream, show, level)
     struct type *type;
     char *varstring;
     GDB_FILE *stream;
     int show;
     int level;
{
  error ("internal error - unimplemented function unk_lang_print_type called.");
}

static int
unk_lang_val_print (type, valaddr, address, stream, format, deref_ref,
		    recurse, pretty)
     struct type *type;
     char *valaddr;
     CORE_ADDR address;
     GDB_FILE *stream;
     int format;
     int deref_ref;
     int recurse;
     enum val_prettyprint pretty;
{
  error ("internal error - unimplemented function unk_lang_val_print called.");
}

static int
unk_lang_value_print (val, stream, format, pretty)
     value_ptr val;
     GDB_FILE *stream;
     int format;
     enum val_prettyprint pretty;
{
  error ("internal error - unimplemented function unk_lang_value_print called.");
}

static struct type ** CONST_PTR (unknown_builtin_types[]) = { 0 };
static const struct op_print unk_op_print_tab[] = {
    {NULL, OP_NULL, PREC_NULL, 0}
};

const struct language_defn unknown_language_defn = {
  "unknown",
  language_unknown,
  &unknown_builtin_types[0],
  range_check_off,
  type_check_off,
  unk_lang_parser,
  unk_lang_error,
  evaluate_subexp_standard,
  unk_lang_printchar,		/* Print character constant */
  unk_lang_printstr,
  unk_lang_create_fundamental_type,
  unk_lang_print_type,		/* Print a type using appropriate syntax */
  unk_lang_val_print,		/* Print a value using appropriate syntax */
  unk_lang_value_print,		/* Print a top-level value */
  {"",      "",    "",   ""},	/* Binary format info */
  {"0%lo",   "0",   "o",  ""},	/* Octal format info */
  {"%ld",    "",    "d",  ""},	/* Decimal format info */
  {"0x%lx",  "0x",  "x",  ""},	/* Hex format info */
  unk_op_print_tab,		/* expression operators for printing */
  1,				/* c-style arrays */
  0,				/* String lower bound */
  &builtin_type_char,		/* Type of string elements */ 
  LANG_MAGIC
};

/* These two structs define fake entries for the "local" and "auto" options. */
const struct language_defn auto_language_defn = {
  "auto",
  language_auto,
  &unknown_builtin_types[0],
  range_check_off,
  type_check_off,
  unk_lang_parser,
  unk_lang_error,
  evaluate_subexp_standard,
  unk_lang_printchar,		/* Print character constant */
  unk_lang_printstr,
  unk_lang_create_fundamental_type,
  unk_lang_print_type,		/* Print a type using appropriate syntax */
  unk_lang_val_print,		/* Print a value using appropriate syntax */
  unk_lang_value_print,		/* Print a top-level value */
  {"",      "",    "",   ""},	/* Binary format info */
  {"0%lo",   "0",   "o",  ""},	/* Octal format info */
  {"%ld",    "",    "d",  ""},	/* Decimal format info */
  {"0x%lx",  "0x",  "x",  ""},	/* Hex format info */
  unk_op_print_tab,		/* expression operators for printing */
  1,				/* c-style arrays */
  0,				/* String lower bound */
  &builtin_type_char,		/* Type of string elements */ 
  LANG_MAGIC
};

const struct language_defn local_language_defn = {
  "local",
  language_auto,
  &unknown_builtin_types[0],
  range_check_off,
  type_check_off,
  unk_lang_parser,
  unk_lang_error,
  evaluate_subexp_standard,
  unk_lang_printchar,		/* Print character constant */
  unk_lang_printstr,
  unk_lang_create_fundamental_type,
  unk_lang_print_type,		/* Print a type using appropriate syntax */
  unk_lang_val_print,		/* Print a value using appropriate syntax */
  unk_lang_value_print,		/* Print a top-level value */
  {"",      "",    "",   ""},	/* Binary format info */
  {"0%lo",   "0",   "o",  ""},	/* Octal format info */
  {"%ld",    "",    "d",  ""},	/* Decimal format info */
  {"0x%lx",  "0x",  "x",  ""},	/* Hex format info */
  unk_op_print_tab,		/* expression operators for printing */
  1,				/* c-style arrays */
  0,				/* String lower bound */
  &builtin_type_char,		/* Type of string elements */ 
  LANG_MAGIC
};

/* Initialize the language routines */

void
_initialize_language()
{
   struct cmd_list_element *set, *show;

   /* GDB commands for language specific stuff */

   set = add_set_cmd ("language", class_support, var_string_noescape,
		      (char *)&language,
		      "Set the current source language.",
		      &setlist);
   show = add_show_from_set (set, &showlist);
   set->function.cfunc = set_language_command;
   show->function.cfunc = show_language_command;

   add_prefix_cmd ("check", no_class, set_check,
		   "Set the status of the type/range checker",
		   &setchecklist, "set check ", 0, &setlist);
   add_alias_cmd ("c", "check", no_class, 1, &setlist);
   add_alias_cmd ("ch", "check", no_class, 1, &setlist);

   add_prefix_cmd ("check", no_class, show_check,
		   "Show the status of the type/range checker",
		   &showchecklist, "show check ", 0, &showlist);
   add_alias_cmd ("c", "check", no_class, 1, &showlist);
   add_alias_cmd ("ch", "check", no_class, 1, &showlist);

   set = add_set_cmd ("type", class_support, var_string_noescape,
		      (char *)&type,
		      "Set type checking.  (on/warn/off/auto)",
		      &setchecklist);
   show = add_show_from_set (set, &showchecklist);
   set->function.cfunc = set_type_command;
   show->function.cfunc = show_type_command;

   set = add_set_cmd ("range", class_support, var_string_noescape,
		      (char *)&range,
		      "Set range checking.  (on/warn/off/auto)",
		      &setchecklist);
   show = add_show_from_set (set, &showchecklist);
   set->function.cfunc = set_range_command;
   show->function.cfunc = show_range_command;

   add_language (&unknown_language_defn);
   add_language (&local_language_defn);
   add_language (&auto_language_defn);

   language = savestring ("auto",strlen("auto"));
   range = savestring ("auto",strlen("auto"));
   type = savestring ("auto",strlen("auto"));

   /* Have the above take effect */

   set_language_command (language, 0);
   set_type_command (NULL, 0);
   set_range_command (NULL, 0);
}
@
