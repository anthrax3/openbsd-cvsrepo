head	1.3;
access;
symbols
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.50
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.46
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.48
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.40
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.44
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.42
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.38
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.36
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.34
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.32
	OPENBSD_5_0:1.3.0.30
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.28
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.26
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.22
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.24
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.20
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.18
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.16
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.14
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.12
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.10
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	GDB_6_3:1.1.1.1
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.3
date	2004.05.21.20.23.14;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.39.56;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.20.48;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.13.20;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.20.48;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@/* Include file for stabs debugging format support functions.
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

struct objfile;

/* Definitions, prototypes, etc for stabs debugging format support
   functions.

   Variables declared in this file can be defined by #define-ing
   the name EXTERN to null.  It is used to declare variables that
   are normally extern, but which get defined in a single module
   using this technique.  */

#ifndef EXTERN
#define	EXTERN extern
#endif

/* Hash table of global symbols whose values are not known yet.
   They are chained thru the SYMBOL_VALUE_CHAIN, since we don't
   have the correct data for that slot yet.

   The use of the LOC_BLOCK code in this chain is nonstandard--
   it refers to a FORTRAN common block rather than the usual meaning, and
   the such LOC_BLOCK symbols use their fields in nonstandard ways.  */

EXTERN struct symbol *global_sym_chain[HASHSIZE];

extern void common_block_start (char *, struct objfile *);
extern void common_block_end (struct objfile *);

/* Kludge for xcoffread.c */

struct pending_stabs
  {
    int count;
    int length;
    char *stab[1];
  };

EXTERN struct pending_stabs *global_stabs;

/* The type code that process_one_symbol saw on its previous invocation.
   Used to detect pairs of N_SO symbols. */

EXTERN int previous_stab_code;

/* Support for Sun changes to dbx symbol format */

/* For each identified header file, we have a table of types defined
   in that header file.

   header_files maps header file names to their type tables.
   It is a vector of n_header_files elements.
   Each element describes one header file.
   It contains a vector of types.

   Sometimes it can happen that the same header file produces
   different results when included in different places.
   This can result from conditionals or from different
   things done before including the file.
   When this happens, there are multiple entries for the file in this table,
   one entry for each distinct set of results.
   The entries are distinguished by the INSTANCE field.
   The INSTANCE field appears in the N_BINCL and N_EXCL symbol table and is
   used to match header-file references to their corresponding data.  */

struct header_file
  {

    /* Name of header file */

    char *name;

    /* Numeric code distinguishing instances of one header file that produced
       different results when included.  It comes from the N_BINCL or N_EXCL. */

    int instance;

    /* Pointer to vector of types */

    struct type **vector;

    /* Allocated length (# elts) of that vector */

    int length;

  };

/* The table of header_files of this OBJFILE. */
#define HEADER_FILES(OBJFILE) (DBX_SYMFILE_INFO (OBJFILE)->header_files)

/* The actual length of HEADER_FILES. */
#define N_HEADER_FILES(OBJFILE) (DBX_SYMFILE_INFO (OBJFILE)->n_header_files)

/* The allocated lengh of HEADER_FILES. */
#define N_ALLOCATED_HEADER_FILES(OBJFILE) \
  (DBX_SYMFILE_INFO (OBJFILE)->n_allocated_header_files)

/* Within each object file, various header files are assigned numbers.
   A type is defined or referred to with a pair of numbers
   (FILENUM,TYPENUM) where FILENUM is the number of the header file
   and TYPENUM is the number within that header file.
   TYPENUM is the index within the vector of types for that header file.

   FILENUM == 0 is special; it refers to the main source of the object file,
   and not to any header file.  FILENUM != 1 is interpreted by looking it up
   in the following table, which contains indices in header_files.  */

EXTERN int *this_object_header_files;

EXTERN int n_this_object_header_files;

EXTERN int n_allocated_this_object_header_files;

extern void cleanup_undefined_types (void);

extern long read_number (char **, int);

extern struct symbol *define_symbol (CORE_ADDR, char *, int, int,
				     struct objfile *);

extern void stabsread_init (void);

extern void stabsread_new_init (void);

extern void start_stabs (void);

extern void end_stabs (void);

extern void finish_global_stabs (struct objfile *objfile);

/* COFF files can have multiple .stab sections, if they are linked
   using --split-by-reloc.  This linked list is used to pass the
   information into the functions in dbxread.c.  */
struct stab_section_list
  {
    /* Next in list.  */
    struct stab_section_list *next;

    /* Stab section.  */
    asection *section;
  };

/* Functions exported by dbxread.c.  These are not in stabsread.c because
   they are only used by some stabs readers.  */

extern struct partial_symtab *end_psymtab (struct partial_symtab *pst,
					   char **include_list,
					   int num_includes,
					   int capping_symbol_offset,
					   CORE_ADDR capping_text,
					   struct partial_symtab
					   **dependency_list,
					   int number_dependencies,
					   int textlow_not_set);

extern void process_one_symbol (int, int, CORE_ADDR, char *,
				struct section_offsets *, struct objfile *);

extern void elfstab_build_psymtabs (struct objfile *objfile,
				    int mainline,
				    asection *stabsect,
				    file_ptr stabstroffset,
				    unsigned int stabstrsize);

extern void coffstab_build_psymtabs
  (struct objfile *objfile,
   int mainline,
   CORE_ADDR textaddr, unsigned int textsize,
   struct stab_section_list *stabs,
   file_ptr stabstroffset, unsigned int stabstrsize);

extern void stabsect_build_psymtabs
  (struct objfile *objfile,
   int mainline, char *stab_name, char *stabstr_name, char *text_name);

extern void elfstab_offset_sections (struct objfile *,
				     struct partial_symtab *);
extern int symbol_reference_defined (char **);

extern void ref_add (int, struct symbol *, char *, CORE_ADDR);

extern struct symbol *ref_search (int);

extern void free_header_files (void);

extern void init_header_files (void);

#undef EXTERN
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright 1986-1991, 1992, 1993 Free Software Foundation, Inc.
d5 1
a5 1
This file is part of GDB.
d7 16
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a35 6
/* Convert stab register number (from `r' declaration) to a gdb REGNUM.  */

#ifndef STAB_REG_TO_REGNUM
#define STAB_REG_TO_REGNUM(VALUE) (VALUE)
#endif

d46 2
a47 2
extern void common_block_start PARAMS ((char *, struct objfile *));
extern void common_block_end PARAMS ((struct objfile *));
d52 5
a56 5
{
  int count;
  int length;
  char *stab[1];
};
d86 1
a86 1
{
d88 1
a88 3
  /* Name of header file */
  
  char *name;
d90 1
a90 2
  /* Numeric code distinguishing instances of one header file that produced
     different results when included.  It comes from the N_BINCL or N_EXCL. */
d92 2
a93 1
  int instance;
d95 1
a95 1
  /* Pointer to vector of types */
d97 1
a97 1
  struct type **vector;
d99 1
a99 1
  /* Allocated length (# elts) of that vector */
d101 1
a101 1
  int length;
d103 3
a105 1
};
d133 1
a133 8
extern struct complaint unknown_symtype_complaint;
extern struct complaint unknown_symchar_complaint;

extern struct type *
read_type PARAMS ((char **, struct objfile *));

extern void
cleanup_undefined_types PARAMS ((void));
d135 1
a135 2
extern struct type **
dbx_lookup_type PARAMS ((int [2]));
d137 2
a138 2
extern long
read_number PARAMS ((char **, int));
d140 1
a140 2
extern void
add_undefined_type PARAMS ((struct type *));
d142 1
a142 2
extern struct symbol *
define_symbol PARAMS ((CORE_ADDR, char *, int, int, struct objfile *));
d144 1
a144 2
extern void
stabsread_init PARAMS ((void));
d146 1
a146 2
extern void
stabsread_new_init PARAMS ((void));
d148 1
a148 14
extern void
start_stabs PARAMS ((void));

extern void
end_stabs PARAMS ((void));

extern void
finish_global_stabs PARAMS ((struct objfile *objfile));

extern void 
resolve_cfront_continuation PARAMS((struct objfile * objfile, 
		struct symbol * sym, char * p));

EXTERN int os9k_stabs;
d154 7
a160 7
{
  /* Next in list.  */
  struct stab_section_list *next;

  /* Stab section.  */
  asection *section;
};
d165 18
a182 26
extern struct partial_symtab *
start_psymtab PARAMS ((struct objfile *, struct section_offsets *, char *,
		       CORE_ADDR, int, struct partial_symbol **,
		       struct partial_symbol **));

extern struct partial_symtab *
end_psymtab PARAMS ((struct partial_symtab *pst,
		     char **include_list,
		     int num_includes,
		     int capping_symbol_offset,
		     CORE_ADDR capping_text,
		     struct partial_symtab **dependency_list,
		     int number_dependencies,
		     int textlow_not_set));

extern void
process_one_symbol PARAMS ((int, int, CORE_ADDR, char *,
			    struct section_offsets *, struct objfile *));

extern void elfstab_build_psymtabs
  PARAMS ((struct objfile *objfile,
	   struct section_offsets *section_offsets,
	   int mainline,
	   file_ptr staboff, unsigned int stabsize,
	   file_ptr stabstroffset,
	   unsigned int stabstrsize));
d185 5
a189 7
  PARAMS ((struct objfile *objfile,
	   struct section_offsets *section_offsets,
	   int mainline,
	   CORE_ADDR textaddr, unsigned int textsize,
	   struct stab_section_list *stabs,
	   file_ptr stabstroffset,
	   unsigned int stabstrsize));
d192 10
a201 6
  PARAMS ((struct objfile *objfile,
	   struct section_offsets *section_offsets,
	   int mainline,
	   char *stab_name,
	   char *stabstr_name,
	   char *text_name));
d203 1
a203 2
extern void elfstab_offset_sections PARAMS ((struct objfile *,
					     struct partial_symtab *));
d205 1
a205 1
extern void process_later PARAMS ((struct symbol *, char *));
@


1.1
log
@file stabsread.h was initially added on branch CYGNUS.
@
text
@d1 241
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 207
/* Include file for stabs debugging format support functions.
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

struct objfile;

/* Definitions, prototypes, etc for stabs debugging format support
   functions.

   Variables declared in this file can be defined by #define-ing
   the name EXTERN to null.  It is used to declare variables that
   are normally extern, but which get defined in a single module
   using this technique.  */

#ifndef EXTERN
#define	EXTERN extern
#endif

/* Hash table of global symbols whose values are not known yet.
   They are chained thru the SYMBOL_VALUE_CHAIN, since we don't
   have the correct data for that slot yet.

   The use of the LOC_BLOCK code in this chain is nonstandard--
   it refers to a FORTRAN common block rather than the usual meaning, and
   the such LOC_BLOCK symbols use their fields in nonstandard ways.  */

EXTERN struct symbol *global_sym_chain[HASHSIZE];

extern void common_block_start (char *, struct objfile *);
extern void common_block_end (struct objfile *);

/* Kludge for xcoffread.c */

struct pending_stabs
  {
    int count;
    int length;
    char *stab[1];
  };

EXTERN struct pending_stabs *global_stabs;

/* The type code that process_one_symbol saw on its previous invocation.
   Used to detect pairs of N_SO symbols. */

EXTERN int previous_stab_code;

/* Support for Sun changes to dbx symbol format */

/* For each identified header file, we have a table of types defined
   in that header file.

   header_files maps header file names to their type tables.
   It is a vector of n_header_files elements.
   Each element describes one header file.
   It contains a vector of types.

   Sometimes it can happen that the same header file produces
   different results when included in different places.
   This can result from conditionals or from different
   things done before including the file.
   When this happens, there are multiple entries for the file in this table,
   one entry for each distinct set of results.
   The entries are distinguished by the INSTANCE field.
   The INSTANCE field appears in the N_BINCL and N_EXCL symbol table and is
   used to match header-file references to their corresponding data.  */

struct header_file
  {

    /* Name of header file */

    char *name;

    /* Numeric code distinguishing instances of one header file that produced
       different results when included.  It comes from the N_BINCL or N_EXCL. */

    int instance;

    /* Pointer to vector of types */

    struct type **vector;

    /* Allocated length (# elts) of that vector */

    int length;

  };

/* The table of header_files of this OBJFILE. */
#define HEADER_FILES(OBJFILE) (DBX_SYMFILE_INFO (OBJFILE)->header_files)

/* The actual length of HEADER_FILES. */
#define N_HEADER_FILES(OBJFILE) (DBX_SYMFILE_INFO (OBJFILE)->n_header_files)

/* The allocated lengh of HEADER_FILES. */
#define N_ALLOCATED_HEADER_FILES(OBJFILE) \
  (DBX_SYMFILE_INFO (OBJFILE)->n_allocated_header_files)

/* Within each object file, various header files are assigned numbers.
   A type is defined or referred to with a pair of numbers
   (FILENUM,TYPENUM) where FILENUM is the number of the header file
   and TYPENUM is the number within that header file.
   TYPENUM is the index within the vector of types for that header file.

   FILENUM == 0 is special; it refers to the main source of the object file,
   and not to any header file.  FILENUM != 1 is interpreted by looking it up
   in the following table, which contains indices in header_files.  */

EXTERN int *this_object_header_files;

EXTERN int n_this_object_header_files;

EXTERN int n_allocated_this_object_header_files;

extern void cleanup_undefined_types (void);

extern long read_number (char **, int);

extern struct symbol *define_symbol (CORE_ADDR, char *, int, int,
				     struct objfile *);

extern void stabsread_init (void);

extern void stabsread_new_init (void);

extern void start_stabs (void);

extern void end_stabs (void);

extern void finish_global_stabs (struct objfile *objfile);

/* COFF files can have multiple .stab sections, if they are linked
   using --split-by-reloc.  This linked list is used to pass the
   information into the functions in dbxread.c.  */
struct stab_section_list
  {
    /* Next in list.  */
    struct stab_section_list *next;

    /* Stab section.  */
    asection *section;
  };

/* Functions exported by dbxread.c.  These are not in stabsread.c because
   they are only used by some stabs readers.  */

extern struct partial_symtab *end_psymtab (struct partial_symtab *pst,
					   char **include_list,
					   int num_includes,
					   int capping_symbol_offset,
					   CORE_ADDR capping_text,
					   struct partial_symtab
					   **dependency_list,
					   int number_dependencies,
					   int textlow_not_set);

extern void process_one_symbol (int, int, CORE_ADDR, char *,
				struct section_offsets *, struct objfile *);

extern void elfstab_build_psymtabs (struct objfile *objfile,
				    int mainline,
				    asection *stabsect,
				    file_ptr stabstroffset,
				    unsigned int stabstrsize);

extern void coffstab_build_psymtabs
  (struct objfile *objfile,
   int mainline,
   CORE_ADDR textaddr, unsigned int textsize,
   struct stab_section_list *stabs,
   file_ptr stabstroffset, unsigned int stabstrsize);

extern void stabsect_build_psymtabs
  (struct objfile *objfile,
   int mainline, char *stab_name, char *stabstr_name, char *text_name);

extern void elfstab_offset_sections (struct objfile *,
				     struct partial_symtab *);
extern int symbol_reference_defined (char **);

extern void ref_add (int, struct symbol *, char *, CORE_ADDR);

extern struct symbol *ref_search (int);

extern void free_header_files (void);

extern void init_header_files (void);

#undef EXTERN
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 241
/* Include file for stabs debugging format support functions.
   Copyright 1986-1991, 1992, 1993 Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* Definitions, prototypes, etc for stabs debugging format support
   functions.

   Variables declared in this file can be defined by #define-ing
   the name EXTERN to null.  It is used to declare variables that
   are normally extern, but which get defined in a single module
   using this technique.  */

#ifndef EXTERN
#define	EXTERN extern
#endif

/* Convert stab register number (from `r' declaration) to a gdb REGNUM.  */

#ifndef STAB_REG_TO_REGNUM
#define STAB_REG_TO_REGNUM(VALUE) (VALUE)
#endif

/* Hash table of global symbols whose values are not known yet.
   They are chained thru the SYMBOL_VALUE_CHAIN, since we don't
   have the correct data for that slot yet.

   The use of the LOC_BLOCK code in this chain is nonstandard--
   it refers to a FORTRAN common block rather than the usual meaning, and
   the such LOC_BLOCK symbols use their fields in nonstandard ways.  */

EXTERN struct symbol *global_sym_chain[HASHSIZE];

extern void common_block_start PARAMS ((char *, struct objfile *));
extern void common_block_end PARAMS ((struct objfile *));

/* Kludge for xcoffread.c */

struct pending_stabs
{
  int count;
  int length;
  char *stab[1];
};

EXTERN struct pending_stabs *global_stabs;

/* The type code that process_one_symbol saw on its previous invocation.
   Used to detect pairs of N_SO symbols. */

EXTERN int previous_stab_code;

/* Support for Sun changes to dbx symbol format */

/* For each identified header file, we have a table of types defined
   in that header file.

   header_files maps header file names to their type tables.
   It is a vector of n_header_files elements.
   Each element describes one header file.
   It contains a vector of types.

   Sometimes it can happen that the same header file produces
   different results when included in different places.
   This can result from conditionals or from different
   things done before including the file.
   When this happens, there are multiple entries for the file in this table,
   one entry for each distinct set of results.
   The entries are distinguished by the INSTANCE field.
   The INSTANCE field appears in the N_BINCL and N_EXCL symbol table and is
   used to match header-file references to their corresponding data.  */

struct header_file
{

  /* Name of header file */
  
  char *name;

  /* Numeric code distinguishing instances of one header file that produced
     different results when included.  It comes from the N_BINCL or N_EXCL. */

  int instance;

  /* Pointer to vector of types */

  struct type **vector;

  /* Allocated length (# elts) of that vector */

  int length;

};

/* The table of header_files of this OBJFILE. */
#define HEADER_FILES(OBJFILE) (DBX_SYMFILE_INFO (OBJFILE)->header_files)

/* The actual length of HEADER_FILES. */
#define N_HEADER_FILES(OBJFILE) (DBX_SYMFILE_INFO (OBJFILE)->n_header_files)

/* The allocated lengh of HEADER_FILES. */
#define N_ALLOCATED_HEADER_FILES(OBJFILE) \
  (DBX_SYMFILE_INFO (OBJFILE)->n_allocated_header_files)

/* Within each object file, various header files are assigned numbers.
   A type is defined or referred to with a pair of numbers
   (FILENUM,TYPENUM) where FILENUM is the number of the header file
   and TYPENUM is the number within that header file.
   TYPENUM is the index within the vector of types for that header file.

   FILENUM == 0 is special; it refers to the main source of the object file,
   and not to any header file.  FILENUM != 1 is interpreted by looking it up
   in the following table, which contains indices in header_files.  */

EXTERN int *this_object_header_files;

EXTERN int n_this_object_header_files;

EXTERN int n_allocated_this_object_header_files;

extern struct complaint unknown_symtype_complaint;
extern struct complaint unknown_symchar_complaint;

extern struct type *
read_type PARAMS ((char **, struct objfile *));

extern void
cleanup_undefined_types PARAMS ((void));

extern struct type **
dbx_lookup_type PARAMS ((int [2]));

extern long
read_number PARAMS ((char **, int));

extern void
add_undefined_type PARAMS ((struct type *));

extern struct symbol *
define_symbol PARAMS ((CORE_ADDR, char *, int, int, struct objfile *));

extern void
stabsread_init PARAMS ((void));

extern void
stabsread_new_init PARAMS ((void));

extern void
start_stabs PARAMS ((void));

extern void
end_stabs PARAMS ((void));

extern void
finish_global_stabs PARAMS ((struct objfile *objfile));

extern void 
resolve_cfront_continuation PARAMS((struct objfile * objfile, 
		struct symbol * sym, char * p));

EXTERN int os9k_stabs;

/* COFF files can have multiple .stab sections, if they are linked
   using --split-by-reloc.  This linked list is used to pass the
   information into the functions in dbxread.c.  */
struct stab_section_list
{
  /* Next in list.  */
  struct stab_section_list *next;

  /* Stab section.  */
  asection *section;
};

/* Functions exported by dbxread.c.  These are not in stabsread.c because
   they are only used by some stabs readers.  */

extern struct partial_symtab *
start_psymtab PARAMS ((struct objfile *, struct section_offsets *, char *,
		       CORE_ADDR, int, struct partial_symbol **,
		       struct partial_symbol **));

extern struct partial_symtab *
end_psymtab PARAMS ((struct partial_symtab *pst,
		     char **include_list,
		     int num_includes,
		     int capping_symbol_offset,
		     CORE_ADDR capping_text,
		     struct partial_symtab **dependency_list,
		     int number_dependencies,
		     int textlow_not_set));

extern void
process_one_symbol PARAMS ((int, int, CORE_ADDR, char *,
			    struct section_offsets *, struct objfile *));

extern void elfstab_build_psymtabs
  PARAMS ((struct objfile *objfile,
	   struct section_offsets *section_offsets,
	   int mainline,
	   file_ptr staboff, unsigned int stabsize,
	   file_ptr stabstroffset,
	   unsigned int stabstrsize));

extern void coffstab_build_psymtabs
  PARAMS ((struct objfile *objfile,
	   struct section_offsets *section_offsets,
	   int mainline,
	   CORE_ADDR textaddr, unsigned int textsize,
	   struct stab_section_list *stabs,
	   file_ptr stabstroffset,
	   unsigned int stabstrsize));

extern void stabsect_build_psymtabs
  PARAMS ((struct objfile *objfile,
	   struct section_offsets *section_offsets,
	   int mainline,
	   char *stab_name,
	   char *stabstr_name,
	   char *text_name));

extern void elfstab_offset_sections PARAMS ((struct objfile *,
					     struct partial_symtab *));

extern void process_later PARAMS ((struct symbol *, char *));

#undef EXTERN
@
