head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.48
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.44
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.46
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.38
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.42
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.40
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.36
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.34
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.32
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.30
	OPENBSD_5_0:1.4.0.28
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.26
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.24
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2004.12.27.14.00.37;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.21.20.23.08;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.38.06;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.18.31;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.11.17;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.06.39;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.18.32;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@/* Variables that describe the inferior process running under GDB:
   Where it is, why it stopped, and how to step it.

   Copyright 1986, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1998, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#if !defined (INFERIOR_H)
#define INFERIOR_H 1

struct target_waitstatus;
struct frame_info;
struct ui_file;
struct type;
struct gdbarch;
struct regcache;

/* For bpstat.  */
#include "breakpoint.h"

/* For enum target_signal.  */
#include "target.h"

/* For struct frame_id.  */
#include "frame.h"

/* Structure in which to save the status of the inferior.  Create/Save
   through "save_inferior_status", restore through
   "restore_inferior_status".

   This pair of routines should be called around any transfer of
   control to the inferior which you don't want showing up in your
   control variables.  */

struct inferior_status;

extern struct inferior_status *save_inferior_status (int);

extern void restore_inferior_status (struct inferior_status *);

extern struct cleanup *make_cleanup_restore_inferior_status (struct inferior_status *);

extern void discard_inferior_status (struct inferior_status *);

extern void write_inferior_status_register (struct inferior_status
					    *inf_status, int regno,
					    LONGEST val);

/* The -1 ptid, often used to indicate either an error condition
   or a "don't care" condition, i.e, "run all threads."  */
extern ptid_t minus_one_ptid;

/* The null or zero ptid, often used to indicate no process. */
extern ptid_t null_ptid;

/* Attempt to find and return an existing ptid with the given PID, LWP,
   and TID components.  If none exists, create a new one and return
   that.  */
ptid_t ptid_build (int pid, long lwp, long tid);

/* Find/Create a ptid from just a pid. */
ptid_t pid_to_ptid (int pid);

/* Fetch the pid (process id) component from a ptid. */
int ptid_get_pid (ptid_t ptid);

/* Fetch the lwp (lightweight process) component from a ptid. */
long ptid_get_lwp (ptid_t ptid);

/* Fetch the tid (thread id) component from a ptid. */
long ptid_get_tid (ptid_t ptid);

/* Compare two ptids to see if they are equal */
extern int ptid_equal (ptid_t p1, ptid_t p2);

/* Save value of inferior_ptid so that it may be restored by
   a later call to do_cleanups().  Returns the struct cleanup
   pointer needed for later doing the cleanup.  */
extern struct cleanup * save_inferior_ptid (void);

extern void set_sigint_trap (void);

extern void clear_sigint_trap (void);

extern void set_sigio_trap (void);

extern void clear_sigio_trap (void);

/* File name for default use for standard in/out in the inferior.  */

extern char *inferior_io_terminal;

/* Collected pid, tid, etc. of the debugged inferior.  When there's
   no inferior, PIDGET (inferior_ptid) will be 0. */

extern ptid_t inferior_ptid;

/* Is the inferior running right now, as a result of a 'run&',
   'continue&' etc command? This is used in asycn gdb to determine
   whether a command that the user enters while the target is running
   is allowed or not. */
extern int target_executing;

/* Are we simulating synchronous execution? This is used in async gdb
   to implement the 'run', 'continue' etc commands, which will not
   redisplay the prompt until the execution is actually over. */
extern int sync_execution;

/* This is only valid when inferior_ptid is non-zero.

   If this is 0, then exec events should be noticed and responded to
   by the debugger (i.e., be reported to the user).

   If this is > 0, then that many subsequent exec events should be
   ignored (i.e., not be reported to the user).
 */
extern int inferior_ignoring_startup_exec_events;

/* This is only valid when inferior_ignoring_startup_exec_events is
   zero.

   Some targets (stupidly) report more than one exec event per actual
   call to an event() system call.  If only the last such exec event
   need actually be noticed and responded to by the debugger (i.e.,
   be reported to the user), then this is the number of "leading"
   exec events which should be ignored.
 */
extern int inferior_ignoring_leading_exec_events;

/* Inferior environment. */

extern struct environ *inferior_environ;

extern void clear_proceed_status (void);

extern void proceed (CORE_ADDR, enum target_signal, int);

/* When set, stop the 'step' command if we enter a function which has
   no line number information.  The normal behavior is that we step
   over such function.  */
extern int step_stop_if_no_debug;

extern void kill_inferior (void);

extern void generic_mourn_inferior (void);

extern void terminal_save_ours (void);

extern void terminal_ours (void);

extern CORE_ADDR read_pc (void);

extern CORE_ADDR read_pc_pid (ptid_t);

extern void write_pc (CORE_ADDR);

extern void write_pc_pid (CORE_ADDR, ptid_t);

extern void generic_target_write_pc (CORE_ADDR, ptid_t);

extern CORE_ADDR read_sp (void);

extern CORE_ADDR unsigned_pointer_to_address (struct type *type, const void *buf);

extern void unsigned_address_to_pointer (struct type *type, void *buf,
					 CORE_ADDR addr);
extern CORE_ADDR signed_pointer_to_address (struct type *type,
					    const void *buf);
extern void address_to_signed_pointer (struct type *type, void *buf,
				       CORE_ADDR addr);

extern void wait_for_inferior (void);

extern void fetch_inferior_event (void *);

extern void init_wait_for_inferior (void);

extern void close_exec_file (void);

extern void reopen_exec_file (void);

/* The `resume' routine should only be called in special circumstances.
   Normally, use `proceed', which handles a lot of bookkeeping.  */

extern void resume (int, enum target_signal);

/* From misc files */

extern void default_print_registers_info (struct gdbarch *gdbarch,
					  struct ui_file *file,
					  struct frame_info *frame,
					  int regnum, int all);

extern void store_inferior_registers (int);

extern void fetch_inferior_registers (int);

extern void solib_create_inferior_hook (void);

extern void child_terminal_info (char *, int);

extern void term_info (char *, int);

extern void terminal_ours_for_output (void);

extern void terminal_inferior (void);

extern void terminal_init_inferior (void);

extern void terminal_init_inferior_with_pgrp (int pgrp);

/* From infptrace.c or infttrace.c */

extern int attach (int);

extern void detach (int);

/* PTRACE method of waiting for inferior process.  */
int ptrace_wait (ptid_t, int *);

extern void child_resume (ptid_t, int, enum target_signal);

#ifndef PTRACE_ARG3_TYPE
#define PTRACE_ARG3_TYPE PTRACE_TYPE_ARG3
#endif

extern int call_ptrace (int, int, PTRACE_ARG3_TYPE, int);

extern void pre_fork_inferior (void);

/* From procfs.c */

extern int proc_iterate_over_mappings (int (*)(int, CORE_ADDR));

extern ptid_t procfs_first_available (void);

/* From fork-child.c */

extern void fork_inferior (char *, char *, char **,
			   void (*)(void),
			   void (*)(int), void (*)(void), char *);


extern void startup_inferior (int);

extern char *construct_inferior_arguments (struct gdbarch *, int, char **);

/* From inflow.c */

extern void new_tty_prefork (char *);

extern int gdb_has_a_terminal (void);

/* From infrun.c */

extern void start_remote (void);

extern void normal_stop (void);

extern int signal_stop_state (int);

extern int signal_print_state (int);

extern int signal_pass_state (int);

extern int signal_stop_update (int, int);

extern int signal_print_update (int, int);

extern int signal_pass_update (int, int);

extern void get_last_target_status(ptid_t *ptid,
                                   struct target_waitstatus *status);

extern void follow_inferior_reset_breakpoints (void);

/* From infcmd.c */

extern void tty_command (char *, int);

extern void attach_command (char *, int);

extern char *get_inferior_args (void);

extern char *set_inferior_args (char *);

extern void set_inferior_args_vector (int, char **);

extern void registers_info (char *, int);

extern void nexti_command (char *, int);

extern void stepi_command (char *, int);

extern void continue_command (char *, int);

extern void interrupt_target_command (char *args, int from_tty);

/* Last signal that the inferior received (why it stopped).  */

extern enum target_signal stop_signal;

/* Address at which inferior stopped.  */

extern CORE_ADDR stop_pc;

/* Chain containing status of breakpoint(s) that we have stopped at.  */

extern bpstat stop_bpstat;

/* Flag indicating that a command has proceeded the inferior past the
   current breakpoint.  */

extern int breakpoint_proceeded;

/* Nonzero if stopped due to a step command.  */

extern int stop_step;

/* Nonzero if stopped due to completion of a stack dummy routine.  */

extern int stop_stack_dummy;

/* Nonzero if program stopped due to a random (unexpected) signal in
   inferior process.  */

extern int stopped_by_random_signal;

/* Range to single step within.
   If this is nonzero, respond to a single-step signal
   by continuing to step if the pc is in this range.

   If step_range_start and step_range_end are both 1, it means to step for
   a single instruction (FIXME: it might clean up wait_for_inferior in a
   minor way if this were changed to the address of the instruction and
   that address plus one.  But maybe not.).  */

extern CORE_ADDR step_range_start;	/* Inclusive */
extern CORE_ADDR step_range_end;	/* Exclusive */

/* Stack frame address as of when stepping command was issued.
   This is how we know when we step into a subroutine call,
   and how to set the frame for the breakpoint used to step out.  */

extern struct frame_id step_frame_id;

/* 1 means step over all subroutine calls.
   -1 means step over calls to undebuggable functions.  */

enum step_over_calls_kind
  {
    STEP_OVER_NONE,
    STEP_OVER_ALL,
    STEP_OVER_UNDEBUGGABLE
  };

extern enum step_over_calls_kind step_over_calls;

/* If stepping, nonzero means step count is > 1
   so don't print frame next time inferior stops
   if it stops due to stepping.  */

extern int step_multi;

/* Nonzero means expecting a trap and caller will handle it
   themselves.  It is used when running in the shell before the child
   program has been exec'd; and when running some kinds of remote
   stuff (FIXME?).  */

/* It is also used after attach, due to attaching to a process. This
   is a bit trickier.  When doing an attach, the kernel stops the
   debuggee with a SIGSTOP.  On newer GNU/Linux kernels (>= 2.5.61)
   the handling of SIGSTOP for a ptraced process has changed. Earlier
   versions of the kernel would ignore these SIGSTOPs, while now
   SIGSTOP is treated like any other signal, i.e. it is not muffled.
   
   If the gdb user does a 'continue' after the 'attach', gdb passes
   the global variable stop_signal (which stores the signal from the
   attach, SIGSTOP) to the ptrace(PTRACE_CONT,...)  call.  This is
   problematic, because the kernel doesn't ignore such SIGSTOP
   now. I.e. it is reported back to gdb, which in turn presents it
   back to the user.
 
   To avoid the problem, we use STOP_QUIETLY_NO_SIGSTOP, which allows
   gdb to clear the value of stop_signal after the attach, so that it
   is not passed back down to the kernel.  */

enum stop_kind
  {
    NO_STOP_QUIETLY = 0,
    STOP_QUIETLY,
    STOP_QUIETLY_NO_SIGSTOP
  };

extern enum stop_kind stop_soon;

/* Nonzero if proceed is being used for a "finish" command or a similar
   situation when stop_registers should be saved.  */

extern int proceed_to_finish;

/* Save register contents here when about to pop a stack dummy frame,
   if-and-only-if proceed_to_finish is set.
   Thus this contains the return value from the called function (assuming
   values are returned in a register).  */

extern struct regcache *stop_registers;

/* Nonzero if the child process in inferior_ptid was attached rather
   than forked.  */

extern int attach_flag;

/* Possible values for CALL_DUMMY_LOCATION.  */
#define ON_STACK 1
#define AT_ENTRY_POINT 4
#define AT_SYMBOL 5

/* If STARTUP_WITH_SHELL is set, GDB's "run"
   will attempts to start up the debugee under a shell.
   This is in order for argument-expansion to occur. E.g.,
   (gdb) run *
   The "*" gets expanded by the shell into a list of files.
   While this is a nice feature, it turns out to interact badly
   with some of the catch-fork/catch-exec features we have added.
   In particular, if the shell does any fork/exec's before
   the exec of the target program, that can confuse GDB.
   To disable this feature, set STARTUP_WITH_SHELL to 0.
   To enable this feature, set STARTUP_WITH_SHELL to 1.
   The catch-exec traps expected during start-up will
   be 1 if target is not started up with a shell, 2 if it is.
   - RT
   If you disable this, you need to decrement
   START_INFERIOR_TRAPS_EXPECTED in tm.h. */
#define STARTUP_WITH_SHELL 1
#if !defined(START_INFERIOR_TRAPS_EXPECTED)
#define START_INFERIOR_TRAPS_EXPECTED	2
#endif
#endif /* !defined (INFERIOR_H) */
@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@a178 4
extern void deprecated_write_sp (CORE_ADDR);

extern CORE_ADDR deprecated_read_fp (void);

d240 1
a240 1
#define PTRACE_ARG3_TYPE int	/* Correct definition for most systems. */
a362 4
/* Our notion of the current stack pointer.  */

extern CORE_ADDR step_sp;

a433 32

/* FIXME: cagney/2000-04-17: gdbarch should manage this.  The default
   shouldn't be necessary. */

#if !defined PUSH_DUMMY_FRAME
#define PUSH_DUMMY_FRAME (internal_error (__FILE__, __LINE__, "PUSH_DUMMY_FRAME"), 0)
#endif

#if !defined STORE_STRUCT_RETURN
#define STORE_STRUCT_RETURN(a1,a2) (internal_error (__FILE__, __LINE__, "STORE_STRUCT_RETURN"), 0)
#endif


/* Are we in a call dummy? */

/* NOTE: cagney/2002-11-24: Targets need to both switch to generic
   dummy frames, and use generic_pc_in_call_dummy().  The generic
   version should be able to handle all cases since that code works by
   saving the address of the dummy's breakpoint (where ever it is).  */

extern int deprecated_pc_in_call_dummy_on_stack (CORE_ADDR pc,
						 CORE_ADDR sp,
						 CORE_ADDR frame_address);

/* NOTE: cagney/2002-11-24: Targets need to both switch to generic
   dummy frames, and use generic_pc_in_call_dummy().  The generic
   version should be able to handle all cases since that code works by
   saving the address of the dummy's breakpoint (where ever it is).  */

extern int deprecated_pc_in_call_dummy_at_entry_point (CORE_ADDR pc,
						       CORE_ADDR sp,
						       CORE_ADDR frame_address);
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@a2 1
   Copyright 1986, 1989, 1992, 1996 Free Software Foundation, Inc.
d4 2
a5 1
This file is part of GDB.
d7 16
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d27 7
d40 4
a43 1
/* Structure in which to save the status of the inferior.  Save
d46 1
d51 25
a75 32
struct inferior_status {
  enum target_signal stop_signal;
  CORE_ADDR stop_pc;
  bpstat stop_bpstat;
  int stop_step;
  int stop_stack_dummy;
  int stopped_by_random_signal;
  int trap_expected;
  CORE_ADDR step_range_start;
  CORE_ADDR step_range_end;
  CORE_ADDR step_frame_address;
  int step_over_calls;
  CORE_ADDR step_resume_break_address;
  int stop_after_trap;
  int stop_soon_quietly;
  CORE_ADDR selected_frame_address;
  int selected_level;
  char stop_registers[REGISTER_BYTES];

  /* These are here because if call_function_by_hand has written some
     registers and then decides to call error(), we better not have changed
     any registers.  */
  char registers[REGISTER_BYTES];

  int breakpoint_proceeded;
  int restore_stack_info;
  int proceed_to_finish;
};

/* This macro gives the number of registers actually in use by the
   inferior.  This may be less than the total number of registers,
   perhaps depending on the actual CPU in use or program being run.  */
d77 11
a87 3
#ifndef ARCH_NUM_REGS
#define ARCH_NUM_REGS NUM_REGS
#endif
d89 2
a90 1
extern void save_inferior_status PARAMS ((struct inferior_status *, int));
d92 4
a95 1
extern void restore_inferior_status PARAMS ((struct inferior_status *));
d97 1
a97 1
extern void set_sigint_trap PARAMS ((void));
d99 1
a99 1
extern void clear_sigint_trap PARAMS ((void));
d101 1
a101 1
extern void set_sigio_trap PARAMS ((void));
d103 1
a103 1
extern void clear_sigio_trap PARAMS ((void));
d109 4
a112 1
/* Pid of our debugged inferior, or 0 if no inferior now.  */
d114 31
a144 1
extern int inferior_pid;
d150 1
a150 1
/* Character array containing an image of the inferior programs' registers.  */
d152 1
a152 1
extern char registers[];
d154 4
a157 2
/* Array of validity bits (one per register).  Nonzero at position XXX_REGNUM
   means that `registers' contains a valid copy of inferior register XXX.  */
d159 1
a159 1
extern char register_valid[NUM_REGS];
d161 1
a161 1
extern void clear_proceed_status PARAMS ((void));
d163 1
a163 1
extern void proceed PARAMS ((CORE_ADDR, enum target_signal, int));
d165 1
a165 1
extern void kill_inferior PARAMS ((void));
d167 1
a167 1
extern void generic_mourn_inferior PARAMS ((void));
d169 1
a169 1
extern void terminal_ours PARAMS ((void));
d171 1
a171 1
extern int run_stack_dummy PARAMS ((CORE_ADDR, char [REGISTER_BYTES]));
d173 1
a173 1
extern CORE_ADDR read_pc PARAMS ((void));
d175 1
a175 1
extern CORE_ADDR read_pc_pid PARAMS ((int));
d177 1
a177 1
extern void write_pc PARAMS ((CORE_ADDR));
d179 1
a179 1
extern void write_pc_pid PARAMS ((CORE_ADDR, int));
d181 1
a181 1
extern CORE_ADDR read_sp PARAMS ((void));
d183 1
a183 1
extern void write_sp PARAMS ((CORE_ADDR));
d185 6
a190 1
extern CORE_ADDR read_fp PARAMS ((void));
d192 1
a192 1
extern void write_fp PARAMS ((CORE_ADDR));
d194 1
a194 1
extern void wait_for_inferior PARAMS ((void));
d196 1
a196 1
extern void init_wait_for_inferior PARAMS ((void));
d198 1
a198 1
extern void close_exec_file PARAMS ((void));
d200 1
a200 1
extern void reopen_exec_file PARAMS ((void));
d205 1
a205 1
extern void resume PARAMS ((int, enum target_signal));
d209 6
a214 1
extern void store_inferior_registers PARAMS ((int));
d216 1
a216 1
extern void fetch_inferior_registers PARAMS ((int));
d218 1
a218 1
extern void  solib_create_inferior_hook PARAMS ((void));
d220 1
a220 1
extern void child_terminal_info PARAMS ((char *, int));
d222 1
a222 1
extern void term_info PARAMS ((char *, int));
d224 1
a224 1
extern void terminal_ours_for_output PARAMS ((void));
d226 1
a226 1
extern void terminal_inferior PARAMS ((void));
d228 1
a228 1
extern void terminal_init_inferior PARAMS ((void));
d230 1
a230 1
extern void terminal_init_inferior_with_pgrp PARAMS ((int pgrp));
d232 1
a232 1
/* From infptrace.c */
d234 1
a234 1
extern int attach PARAMS ((int));
d236 1
a236 1
void detach PARAMS ((int));
d238 4
a241 1
extern void child_resume PARAMS ((int, int, enum target_signal));
d247 3
a249 1
extern int call_ptrace PARAMS ((int, int, PTRACE_ARG3_TYPE, int));
d253 3
a255 1
extern int proc_iterate_over_mappings PARAMS ((int (*) (int, CORE_ADDR)));
d259 6
a264 3
extern void fork_inferior PARAMS ((char *, char *, char **,
				   void (*) (void),
				   int (*) (int), char *));
d266 1
a266 1
extern void startup_inferior PARAMS ((int));
d270 1
a270 1
extern void new_tty_prefork PARAMS ((char *));
d272 1
a272 1
extern int gdb_has_a_terminal PARAMS ((void));
d276 1
a276 1
extern void start_remote PARAMS ((void));
d278 1
a278 1
extern void normal_stop PARAMS ((void));
d280 1
a280 1
extern int signal_stop_state PARAMS ((int));
d282 1
a282 1
extern int signal_print_state PARAMS ((int));
d284 12
a295 1
extern int signal_pass_state PARAMS ((int));
d299 15
a313 1
extern void tty_command PARAMS ((char *, int));
d315 3
a317 1
extern void attach_command PARAMS ((char *, int));
d358 2
a359 2
extern CORE_ADDR step_range_start; /* Inclusive */
extern CORE_ADDR step_range_end; /* Exclusive */
d365 1
a365 1
extern CORE_ADDR step_frame_address;
d374 8
a381 1
extern int step_over_calls;
d389 29
a417 4
/* Nonzero means expecting a trap and caller will handle it themselves.
   It is used after attach, due to attaching to a process;
   when running in the shell before the child program has been exec'd;
   and when running some kinds of remote stuff (FIXME?).  */
d419 1
a419 1
extern int stop_soon_quietly;
d431 1
a431 1
extern char stop_registers[REGISTER_BYTES];
d433 1
a433 1
/* Nonzero if the child process in inferior_pid was attached rather
a437 23
/* Sigtramp is a routine that the kernel calls (which then calls the
   signal handler).  On most machines it is a library routine that
   is linked into the executable.

   This macro, given a program counter value and the name of the
   function in which that PC resides (which can be null if the
   name is not known), returns nonzero if the PC and name show
   that we are in sigtramp.

   On most machines just see if the name is sigtramp (and if we have
   no name, assume we are not in sigtramp).  */
#if !defined (IN_SIGTRAMP)
#  if defined (SIGTRAMP_START)
#    define IN_SIGTRAMP(pc, name) \
       ((pc) >= SIGTRAMP_START(pc)   \
        && (pc) < SIGTRAMP_END(pc) \
        )
#  else
#    define IN_SIGTRAMP(pc, name) \
       (name && STREQ ("_sigtramp", name))
#  endif
#endif

a439 2
#define BEFORE_TEXT_END 2
#define AFTER_TEXT_END 3
d441 4
d446 3
a448 51
#if !defined (CALL_DUMMY_LOCATION)
#define CALL_DUMMY_LOCATION ON_STACK
#endif /* No CALL_DUMMY_LOCATION.  */

/* Are we in a call dummy?  The code below which allows DECR_PC_AFTER_BREAK
   below is for infrun.c, which may give the macro a pc without that
   subtracted out.  */
#if !defined (PC_IN_CALL_DUMMY)
#if CALL_DUMMY_LOCATION == BEFORE_TEXT_END
extern CORE_ADDR text_end;
#define PC_IN_CALL_DUMMY(pc, sp, frame_address) \
  ((pc) >= text_end - CALL_DUMMY_LENGTH         \
   && (pc) <= text_end + DECR_PC_AFTER_BREAK)
#endif /* Before text_end.  */

#if CALL_DUMMY_LOCATION == AFTER_TEXT_END
extern CORE_ADDR text_end;
#define PC_IN_CALL_DUMMY(pc, sp, frame_address) \
  ((pc) >= text_end   \
   && (pc) <= text_end + CALL_DUMMY_LENGTH + DECR_PC_AFTER_BREAK)
#endif /* After text_end.  */

#if CALL_DUMMY_LOCATION == ON_STACK
/* Is the PC in a call dummy?  SP and FRAME_ADDRESS are the bottom and
   top of the stack frame which we are checking, where "bottom" and
   "top" refer to some section of memory which contains the code for
   the call dummy.  Calls to this macro assume that the contents of
   SP_REGNUM and FP_REGNUM (or the saved values thereof), respectively,
   are the things to pass.

   This won't work on the 29k, where SP_REGNUM and FP_REGNUM don't
   have that meaning, but the 29k doesn't use ON_STACK.  This could be
   fixed by generalizing this scheme, perhaps by passing in a frame
   and adding a few fields, at least on machines which need them for
   PC_IN_CALL_DUMMY.

   Something simpler, like checking for the stack segment, doesn't work,
   since various programs (threads implementations, gcc nested function
   stubs, etc) may either allocate stack frames in another segment, or
   allocate other kinds of code on the stack.  */

#define PC_IN_CALL_DUMMY(pc, sp, frame_address) \
  ((sp) INNER_THAN (pc) && (frame_address != 0) && (pc) INNER_THAN (frame_address))
#endif /* On stack.  */

#if CALL_DUMMY_LOCATION == AT_ENTRY_POINT
#define PC_IN_CALL_DUMMY(pc, sp, frame_address)			\
  ((pc) >= CALL_DUMMY_ADDRESS ()				\
   && (pc) <= (CALL_DUMMY_ADDRESS () + DECR_PC_AFTER_BREAK))
#endif /* At entry point.  */
#endif /* No PC_IN_CALL_DUMMY.  */
d450 46
a495 1
#endif	/* !defined (INFERIOR_H) */
@


1.1
log
@file inferior.h was initially added on branch CYGNUS.
@
text
@d1 386
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 495
/* Variables that describe the inferior process running under GDB:
   Where it is, why it stopped, and how to step it.

   Copyright 1986, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1998, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#if !defined (INFERIOR_H)
#define INFERIOR_H 1

struct target_waitstatus;
struct frame_info;
struct ui_file;
struct type;
struct gdbarch;
struct regcache;

/* For bpstat.  */
#include "breakpoint.h"

/* For enum target_signal.  */
#include "target.h"

/* For struct frame_id.  */
#include "frame.h"

/* Structure in which to save the status of the inferior.  Create/Save
   through "save_inferior_status", restore through
   "restore_inferior_status".

   This pair of routines should be called around any transfer of
   control to the inferior which you don't want showing up in your
   control variables.  */

struct inferior_status;

extern struct inferior_status *save_inferior_status (int);

extern void restore_inferior_status (struct inferior_status *);

extern struct cleanup *make_cleanup_restore_inferior_status (struct inferior_status *);

extern void discard_inferior_status (struct inferior_status *);

extern void write_inferior_status_register (struct inferior_status
					    *inf_status, int regno,
					    LONGEST val);

/* The -1 ptid, often used to indicate either an error condition
   or a "don't care" condition, i.e, "run all threads."  */
extern ptid_t minus_one_ptid;

/* The null or zero ptid, often used to indicate no process. */
extern ptid_t null_ptid;

/* Attempt to find and return an existing ptid with the given PID, LWP,
   and TID components.  If none exists, create a new one and return
   that.  */
ptid_t ptid_build (int pid, long lwp, long tid);

/* Find/Create a ptid from just a pid. */
ptid_t pid_to_ptid (int pid);

/* Fetch the pid (process id) component from a ptid. */
int ptid_get_pid (ptid_t ptid);

/* Fetch the lwp (lightweight process) component from a ptid. */
long ptid_get_lwp (ptid_t ptid);

/* Fetch the tid (thread id) component from a ptid. */
long ptid_get_tid (ptid_t ptid);

/* Compare two ptids to see if they are equal */
extern int ptid_equal (ptid_t p1, ptid_t p2);

/* Save value of inferior_ptid so that it may be restored by
   a later call to do_cleanups().  Returns the struct cleanup
   pointer needed for later doing the cleanup.  */
extern struct cleanup * save_inferior_ptid (void);

extern void set_sigint_trap (void);

extern void clear_sigint_trap (void);

extern void set_sigio_trap (void);

extern void clear_sigio_trap (void);

/* File name for default use for standard in/out in the inferior.  */

extern char *inferior_io_terminal;

/* Collected pid, tid, etc. of the debugged inferior.  When there's
   no inferior, PIDGET (inferior_ptid) will be 0. */

extern ptid_t inferior_ptid;

/* Is the inferior running right now, as a result of a 'run&',
   'continue&' etc command? This is used in asycn gdb to determine
   whether a command that the user enters while the target is running
   is allowed or not. */
extern int target_executing;

/* Are we simulating synchronous execution? This is used in async gdb
   to implement the 'run', 'continue' etc commands, which will not
   redisplay the prompt until the execution is actually over. */
extern int sync_execution;

/* This is only valid when inferior_ptid is non-zero.

   If this is 0, then exec events should be noticed and responded to
   by the debugger (i.e., be reported to the user).

   If this is > 0, then that many subsequent exec events should be
   ignored (i.e., not be reported to the user).
 */
extern int inferior_ignoring_startup_exec_events;

/* This is only valid when inferior_ignoring_startup_exec_events is
   zero.

   Some targets (stupidly) report more than one exec event per actual
   call to an event() system call.  If only the last such exec event
   need actually be noticed and responded to by the debugger (i.e.,
   be reported to the user), then this is the number of "leading"
   exec events which should be ignored.
 */
extern int inferior_ignoring_leading_exec_events;

/* Inferior environment. */

extern struct environ *inferior_environ;

extern void clear_proceed_status (void);

extern void proceed (CORE_ADDR, enum target_signal, int);

/* When set, stop the 'step' command if we enter a function which has
   no line number information.  The normal behavior is that we step
   over such function.  */
extern int step_stop_if_no_debug;

extern void kill_inferior (void);

extern void generic_mourn_inferior (void);

extern void terminal_save_ours (void);

extern void terminal_ours (void);

extern CORE_ADDR read_pc (void);

extern CORE_ADDR read_pc_pid (ptid_t);

extern void write_pc (CORE_ADDR);

extern void write_pc_pid (CORE_ADDR, ptid_t);

extern void generic_target_write_pc (CORE_ADDR, ptid_t);

extern CORE_ADDR read_sp (void);

extern void deprecated_write_sp (CORE_ADDR);

extern CORE_ADDR deprecated_read_fp (void);

extern CORE_ADDR unsigned_pointer_to_address (struct type *type, const void *buf);

extern void unsigned_address_to_pointer (struct type *type, void *buf,
					 CORE_ADDR addr);
extern CORE_ADDR signed_pointer_to_address (struct type *type,
					    const void *buf);
extern void address_to_signed_pointer (struct type *type, void *buf,
				       CORE_ADDR addr);

extern void wait_for_inferior (void);

extern void fetch_inferior_event (void *);

extern void init_wait_for_inferior (void);

extern void close_exec_file (void);

extern void reopen_exec_file (void);

/* The `resume' routine should only be called in special circumstances.
   Normally, use `proceed', which handles a lot of bookkeeping.  */

extern void resume (int, enum target_signal);

/* From misc files */

extern void default_print_registers_info (struct gdbarch *gdbarch,
					  struct ui_file *file,
					  struct frame_info *frame,
					  int regnum, int all);

extern void store_inferior_registers (int);

extern void fetch_inferior_registers (int);

extern void solib_create_inferior_hook (void);

extern void child_terminal_info (char *, int);

extern void term_info (char *, int);

extern void terminal_ours_for_output (void);

extern void terminal_inferior (void);

extern void terminal_init_inferior (void);

extern void terminal_init_inferior_with_pgrp (int pgrp);

/* From infptrace.c or infttrace.c */

extern int attach (int);

extern void detach (int);

/* PTRACE method of waiting for inferior process.  */
int ptrace_wait (ptid_t, int *);

extern void child_resume (ptid_t, int, enum target_signal);

#ifndef PTRACE_ARG3_TYPE
#define PTRACE_ARG3_TYPE int	/* Correct definition for most systems. */
#endif

extern int call_ptrace (int, int, PTRACE_ARG3_TYPE, int);

extern void pre_fork_inferior (void);

/* From procfs.c */

extern int proc_iterate_over_mappings (int (*)(int, CORE_ADDR));

extern ptid_t procfs_first_available (void);

/* From fork-child.c */

extern void fork_inferior (char *, char *, char **,
			   void (*)(void),
			   void (*)(int), void (*)(void), char *);


extern void startup_inferior (int);

extern char *construct_inferior_arguments (struct gdbarch *, int, char **);

/* From inflow.c */

extern void new_tty_prefork (char *);

extern int gdb_has_a_terminal (void);

/* From infrun.c */

extern void start_remote (void);

extern void normal_stop (void);

extern int signal_stop_state (int);

extern int signal_print_state (int);

extern int signal_pass_state (int);

extern int signal_stop_update (int, int);

extern int signal_print_update (int, int);

extern int signal_pass_update (int, int);

extern void get_last_target_status(ptid_t *ptid,
                                   struct target_waitstatus *status);

extern void follow_inferior_reset_breakpoints (void);

/* From infcmd.c */

extern void tty_command (char *, int);

extern void attach_command (char *, int);

extern char *get_inferior_args (void);

extern char *set_inferior_args (char *);

extern void set_inferior_args_vector (int, char **);

extern void registers_info (char *, int);

extern void nexti_command (char *, int);

extern void stepi_command (char *, int);

extern void continue_command (char *, int);

extern void interrupt_target_command (char *args, int from_tty);

/* Last signal that the inferior received (why it stopped).  */

extern enum target_signal stop_signal;

/* Address at which inferior stopped.  */

extern CORE_ADDR stop_pc;

/* Chain containing status of breakpoint(s) that we have stopped at.  */

extern bpstat stop_bpstat;

/* Flag indicating that a command has proceeded the inferior past the
   current breakpoint.  */

extern int breakpoint_proceeded;

/* Nonzero if stopped due to a step command.  */

extern int stop_step;

/* Nonzero if stopped due to completion of a stack dummy routine.  */

extern int stop_stack_dummy;

/* Nonzero if program stopped due to a random (unexpected) signal in
   inferior process.  */

extern int stopped_by_random_signal;

/* Range to single step within.
   If this is nonzero, respond to a single-step signal
   by continuing to step if the pc is in this range.

   If step_range_start and step_range_end are both 1, it means to step for
   a single instruction (FIXME: it might clean up wait_for_inferior in a
   minor way if this were changed to the address of the instruction and
   that address plus one.  But maybe not.).  */

extern CORE_ADDR step_range_start;	/* Inclusive */
extern CORE_ADDR step_range_end;	/* Exclusive */

/* Stack frame address as of when stepping command was issued.
   This is how we know when we step into a subroutine call,
   and how to set the frame for the breakpoint used to step out.  */

extern struct frame_id step_frame_id;

/* Our notion of the current stack pointer.  */

extern CORE_ADDR step_sp;

/* 1 means step over all subroutine calls.
   -1 means step over calls to undebuggable functions.  */

enum step_over_calls_kind
  {
    STEP_OVER_NONE,
    STEP_OVER_ALL,
    STEP_OVER_UNDEBUGGABLE
  };

extern enum step_over_calls_kind step_over_calls;

/* If stepping, nonzero means step count is > 1
   so don't print frame next time inferior stops
   if it stops due to stepping.  */

extern int step_multi;

/* Nonzero means expecting a trap and caller will handle it
   themselves.  It is used when running in the shell before the child
   program has been exec'd; and when running some kinds of remote
   stuff (FIXME?).  */

/* It is also used after attach, due to attaching to a process. This
   is a bit trickier.  When doing an attach, the kernel stops the
   debuggee with a SIGSTOP.  On newer GNU/Linux kernels (>= 2.5.61)
   the handling of SIGSTOP for a ptraced process has changed. Earlier
   versions of the kernel would ignore these SIGSTOPs, while now
   SIGSTOP is treated like any other signal, i.e. it is not muffled.
   
   If the gdb user does a 'continue' after the 'attach', gdb passes
   the global variable stop_signal (which stores the signal from the
   attach, SIGSTOP) to the ptrace(PTRACE_CONT,...)  call.  This is
   problematic, because the kernel doesn't ignore such SIGSTOP
   now. I.e. it is reported back to gdb, which in turn presents it
   back to the user.
 
   To avoid the problem, we use STOP_QUIETLY_NO_SIGSTOP, which allows
   gdb to clear the value of stop_signal after the attach, so that it
   is not passed back down to the kernel.  */

enum stop_kind
  {
    NO_STOP_QUIETLY = 0,
    STOP_QUIETLY,
    STOP_QUIETLY_NO_SIGSTOP
  };

extern enum stop_kind stop_soon;

/* Nonzero if proceed is being used for a "finish" command or a similar
   situation when stop_registers should be saved.  */

extern int proceed_to_finish;

/* Save register contents here when about to pop a stack dummy frame,
   if-and-only-if proceed_to_finish is set.
   Thus this contains the return value from the called function (assuming
   values are returned in a register).  */

extern struct regcache *stop_registers;

/* Nonzero if the child process in inferior_ptid was attached rather
   than forked.  */

extern int attach_flag;

/* Possible values for CALL_DUMMY_LOCATION.  */
#define ON_STACK 1
#define AT_ENTRY_POINT 4
#define AT_SYMBOL 5

/* FIXME: cagney/2000-04-17: gdbarch should manage this.  The default
   shouldn't be necessary. */

#if !defined PUSH_DUMMY_FRAME
#define PUSH_DUMMY_FRAME (internal_error (__FILE__, __LINE__, "PUSH_DUMMY_FRAME"), 0)
#endif

#if !defined STORE_STRUCT_RETURN
#define STORE_STRUCT_RETURN(a1,a2) (internal_error (__FILE__, __LINE__, "STORE_STRUCT_RETURN"), 0)
#endif


/* Are we in a call dummy? */

/* NOTE: cagney/2002-11-24: Targets need to both switch to generic
   dummy frames, and use generic_pc_in_call_dummy().  The generic
   version should be able to handle all cases since that code works by
   saving the address of the dummy's breakpoint (where ever it is).  */

extern int deprecated_pc_in_call_dummy_on_stack (CORE_ADDR pc,
						 CORE_ADDR sp,
						 CORE_ADDR frame_address);

/* NOTE: cagney/2002-11-24: Targets need to both switch to generic
   dummy frames, and use generic_pc_in_call_dummy().  The generic
   version should be able to handle all cases since that code works by
   saving the address of the dummy's breakpoint (where ever it is).  */

extern int deprecated_pc_in_call_dummy_at_entry_point (CORE_ADDR pc,
						       CORE_ADDR sp,
						       CORE_ADDR frame_address);

/* If STARTUP_WITH_SHELL is set, GDB's "run"
   will attempts to start up the debugee under a shell.
   This is in order for argument-expansion to occur. E.g.,
   (gdb) run *
   The "*" gets expanded by the shell into a list of files.
   While this is a nice feature, it turns out to interact badly
   with some of the catch-fork/catch-exec features we have added.
   In particular, if the shell does any fork/exec's before
   the exec of the target program, that can confuse GDB.
   To disable this feature, set STARTUP_WITH_SHELL to 0.
   To enable this feature, set STARTUP_WITH_SHELL to 1.
   The catch-exec traps expected during start-up will
   be 1 if target is not started up with a shell, 2 if it is.
   - RT
   If you disable this, you need to decrement
   START_INFERIOR_TRAPS_EXPECTED in tm.h. */
#define STARTUP_WITH_SHELL 1
#if !defined(START_INFERIOR_TRAPS_EXPECTED)
#define START_INFERIOR_TRAPS_EXPECTED	2
#endif
#endif /* !defined (INFERIOR_H) */
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d179 4
d244 1
a244 1
#define PTRACE_ARG3_TYPE PTRACE_TYPE_ARG3
d367 4
d442 32
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 386
/* Variables that describe the inferior process running under GDB:
   Where it is, why it stopped, and how to step it.
   Copyright 1986, 1989, 1992, 1996 Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#if !defined (INFERIOR_H)
#define INFERIOR_H 1

/* For bpstat.  */
#include "breakpoint.h"

/* For enum target_signal.  */
#include "target.h"

/* Structure in which to save the status of the inferior.  Save
   through "save_inferior_status", restore through
   "restore_inferior_status".
   This pair of routines should be called around any transfer of
   control to the inferior which you don't want showing up in your
   control variables.  */

struct inferior_status {
  enum target_signal stop_signal;
  CORE_ADDR stop_pc;
  bpstat stop_bpstat;
  int stop_step;
  int stop_stack_dummy;
  int stopped_by_random_signal;
  int trap_expected;
  CORE_ADDR step_range_start;
  CORE_ADDR step_range_end;
  CORE_ADDR step_frame_address;
  int step_over_calls;
  CORE_ADDR step_resume_break_address;
  int stop_after_trap;
  int stop_soon_quietly;
  CORE_ADDR selected_frame_address;
  int selected_level;
  char stop_registers[REGISTER_BYTES];

  /* These are here because if call_function_by_hand has written some
     registers and then decides to call error(), we better not have changed
     any registers.  */
  char registers[REGISTER_BYTES];

  int breakpoint_proceeded;
  int restore_stack_info;
  int proceed_to_finish;
};

/* This macro gives the number of registers actually in use by the
   inferior.  This may be less than the total number of registers,
   perhaps depending on the actual CPU in use or program being run.  */

#ifndef ARCH_NUM_REGS
#define ARCH_NUM_REGS NUM_REGS
#endif

extern void save_inferior_status PARAMS ((struct inferior_status *, int));

extern void restore_inferior_status PARAMS ((struct inferior_status *));

extern void set_sigint_trap PARAMS ((void));

extern void clear_sigint_trap PARAMS ((void));

extern void set_sigio_trap PARAMS ((void));

extern void clear_sigio_trap PARAMS ((void));

/* File name for default use for standard in/out in the inferior.  */

extern char *inferior_io_terminal;

/* Pid of our debugged inferior, or 0 if no inferior now.  */

extern int inferior_pid;

/* Inferior environment. */

extern struct environ *inferior_environ;

/* Character array containing an image of the inferior programs' registers.  */

extern char registers[];

/* Array of validity bits (one per register).  Nonzero at position XXX_REGNUM
   means that `registers' contains a valid copy of inferior register XXX.  */

extern char register_valid[NUM_REGS];

extern void clear_proceed_status PARAMS ((void));

extern void proceed PARAMS ((CORE_ADDR, enum target_signal, int));

extern void kill_inferior PARAMS ((void));

extern void generic_mourn_inferior PARAMS ((void));

extern void terminal_ours PARAMS ((void));

extern int run_stack_dummy PARAMS ((CORE_ADDR, char [REGISTER_BYTES]));

extern CORE_ADDR read_pc PARAMS ((void));

extern CORE_ADDR read_pc_pid PARAMS ((int));

extern void write_pc PARAMS ((CORE_ADDR));

extern void write_pc_pid PARAMS ((CORE_ADDR, int));

extern CORE_ADDR read_sp PARAMS ((void));

extern void write_sp PARAMS ((CORE_ADDR));

extern CORE_ADDR read_fp PARAMS ((void));

extern void write_fp PARAMS ((CORE_ADDR));

extern void wait_for_inferior PARAMS ((void));

extern void init_wait_for_inferior PARAMS ((void));

extern void close_exec_file PARAMS ((void));

extern void reopen_exec_file PARAMS ((void));

/* The `resume' routine should only be called in special circumstances.
   Normally, use `proceed', which handles a lot of bookkeeping.  */

extern void resume PARAMS ((int, enum target_signal));

/* From misc files */

extern void store_inferior_registers PARAMS ((int));

extern void fetch_inferior_registers PARAMS ((int));

extern void  solib_create_inferior_hook PARAMS ((void));

extern void child_terminal_info PARAMS ((char *, int));

extern void term_info PARAMS ((char *, int));

extern void terminal_ours_for_output PARAMS ((void));

extern void terminal_inferior PARAMS ((void));

extern void terminal_init_inferior PARAMS ((void));

extern void terminal_init_inferior_with_pgrp PARAMS ((int pgrp));

/* From infptrace.c */

extern int attach PARAMS ((int));

void detach PARAMS ((int));

extern void child_resume PARAMS ((int, int, enum target_signal));

#ifndef PTRACE_ARG3_TYPE
#define PTRACE_ARG3_TYPE int	/* Correct definition for most systems. */
#endif

extern int call_ptrace PARAMS ((int, int, PTRACE_ARG3_TYPE, int));

/* From procfs.c */

extern int proc_iterate_over_mappings PARAMS ((int (*) (int, CORE_ADDR)));

/* From fork-child.c */

extern void fork_inferior PARAMS ((char *, char *, char **,
				   void (*) (void),
				   int (*) (int), char *));

extern void startup_inferior PARAMS ((int));

/* From inflow.c */

extern void new_tty_prefork PARAMS ((char *));

extern int gdb_has_a_terminal PARAMS ((void));

/* From infrun.c */

extern void start_remote PARAMS ((void));

extern void normal_stop PARAMS ((void));

extern int signal_stop_state PARAMS ((int));

extern int signal_print_state PARAMS ((int));

extern int signal_pass_state PARAMS ((int));

/* From infcmd.c */

extern void tty_command PARAMS ((char *, int));

extern void attach_command PARAMS ((char *, int));

/* Last signal that the inferior received (why it stopped).  */

extern enum target_signal stop_signal;

/* Address at which inferior stopped.  */

extern CORE_ADDR stop_pc;

/* Chain containing status of breakpoint(s) that we have stopped at.  */

extern bpstat stop_bpstat;

/* Flag indicating that a command has proceeded the inferior past the
   current breakpoint.  */

extern int breakpoint_proceeded;

/* Nonzero if stopped due to a step command.  */

extern int stop_step;

/* Nonzero if stopped due to completion of a stack dummy routine.  */

extern int stop_stack_dummy;

/* Nonzero if program stopped due to a random (unexpected) signal in
   inferior process.  */

extern int stopped_by_random_signal;

/* Range to single step within.
   If this is nonzero, respond to a single-step signal
   by continuing to step if the pc is in this range.

   If step_range_start and step_range_end are both 1, it means to step for
   a single instruction (FIXME: it might clean up wait_for_inferior in a
   minor way if this were changed to the address of the instruction and
   that address plus one.  But maybe not.).  */

extern CORE_ADDR step_range_start; /* Inclusive */
extern CORE_ADDR step_range_end; /* Exclusive */

/* Stack frame address as of when stepping command was issued.
   This is how we know when we step into a subroutine call,
   and how to set the frame for the breakpoint used to step out.  */

extern CORE_ADDR step_frame_address;

/* Our notion of the current stack pointer.  */

extern CORE_ADDR step_sp;

/* 1 means step over all subroutine calls.
   -1 means step over calls to undebuggable functions.  */

extern int step_over_calls;

/* If stepping, nonzero means step count is > 1
   so don't print frame next time inferior stops
   if it stops due to stepping.  */

extern int step_multi;

/* Nonzero means expecting a trap and caller will handle it themselves.
   It is used after attach, due to attaching to a process;
   when running in the shell before the child program has been exec'd;
   and when running some kinds of remote stuff (FIXME?).  */

extern int stop_soon_quietly;

/* Nonzero if proceed is being used for a "finish" command or a similar
   situation when stop_registers should be saved.  */

extern int proceed_to_finish;

/* Save register contents here when about to pop a stack dummy frame,
   if-and-only-if proceed_to_finish is set.
   Thus this contains the return value from the called function (assuming
   values are returned in a register).  */

extern char stop_registers[REGISTER_BYTES];

/* Nonzero if the child process in inferior_pid was attached rather
   than forked.  */

extern int attach_flag;

/* Sigtramp is a routine that the kernel calls (which then calls the
   signal handler).  On most machines it is a library routine that
   is linked into the executable.

   This macro, given a program counter value and the name of the
   function in which that PC resides (which can be null if the
   name is not known), returns nonzero if the PC and name show
   that we are in sigtramp.

   On most machines just see if the name is sigtramp (and if we have
   no name, assume we are not in sigtramp).  */
#if !defined (IN_SIGTRAMP)
#  if defined (SIGTRAMP_START)
#    define IN_SIGTRAMP(pc, name) \
       ((pc) >= SIGTRAMP_START(pc)   \
        && (pc) < SIGTRAMP_END(pc) \
        )
#  else
#    define IN_SIGTRAMP(pc, name) \
       (name && STREQ ("_sigtramp", name))
#  endif
#endif

/* Possible values for CALL_DUMMY_LOCATION.  */
#define ON_STACK 1
#define BEFORE_TEXT_END 2
#define AFTER_TEXT_END 3
#define AT_ENTRY_POINT 4

#if !defined (CALL_DUMMY_LOCATION)
#define CALL_DUMMY_LOCATION ON_STACK
#endif /* No CALL_DUMMY_LOCATION.  */

/* Are we in a call dummy?  The code below which allows DECR_PC_AFTER_BREAK
   below is for infrun.c, which may give the macro a pc without that
   subtracted out.  */
#if !defined (PC_IN_CALL_DUMMY)
#if CALL_DUMMY_LOCATION == BEFORE_TEXT_END
extern CORE_ADDR text_end;
#define PC_IN_CALL_DUMMY(pc, sp, frame_address) \
  ((pc) >= text_end - CALL_DUMMY_LENGTH         \
   && (pc) <= text_end + DECR_PC_AFTER_BREAK)
#endif /* Before text_end.  */

#if CALL_DUMMY_LOCATION == AFTER_TEXT_END
extern CORE_ADDR text_end;
#define PC_IN_CALL_DUMMY(pc, sp, frame_address) \
  ((pc) >= text_end   \
   && (pc) <= text_end + CALL_DUMMY_LENGTH + DECR_PC_AFTER_BREAK)
#endif /* After text_end.  */

#if CALL_DUMMY_LOCATION == ON_STACK
/* Is the PC in a call dummy?  SP and FRAME_ADDRESS are the bottom and
   top of the stack frame which we are checking, where "bottom" and
   "top" refer to some section of memory which contains the code for
   the call dummy.  Calls to this macro assume that the contents of
   SP_REGNUM and FP_REGNUM (or the saved values thereof), respectively,
   are the things to pass.

   This won't work on the 29k, where SP_REGNUM and FP_REGNUM don't
   have that meaning, but the 29k doesn't use ON_STACK.  This could be
   fixed by generalizing this scheme, perhaps by passing in a frame
   and adding a few fields, at least on machines which need them for
   PC_IN_CALL_DUMMY.

   Something simpler, like checking for the stack segment, doesn't work,
   since various programs (threads implementations, gcc nested function
   stubs, etc) may either allocate stack frames in another segment, or
   allocate other kinds of code on the stack.  */

#define PC_IN_CALL_DUMMY(pc, sp, frame_address) \
  ((sp) INNER_THAN (pc) && (frame_address != 0) && (pc) INNER_THAN (frame_address))
#endif /* On stack.  */

#if CALL_DUMMY_LOCATION == AT_ENTRY_POINT
#define PC_IN_CALL_DUMMY(pc, sp, frame_address)			\
  ((pc) >= CALL_DUMMY_ADDRESS ()				\
   && (pc) <= (CALL_DUMMY_ADDRESS () + DECR_PC_AFTER_BREAK))
#endif /* At entry point.  */
#endif /* No PC_IN_CALL_DUMMY.  */

#endif	/* !defined (INFERIOR_H) */
@
