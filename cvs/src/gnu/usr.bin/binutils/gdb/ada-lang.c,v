head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.2.0.54
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.52
	OPENBSD_6_1_BASE:1.1.1.2
	OPENBSD_6_0:1.1.1.2.0.48
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.44
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.46
	OPENBSD_5_8_BASE:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.38
	OPENBSD_5_7_BASE:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.42
	OPENBSD_5_6_BASE:1.1.1.2
	OPENBSD_5_5:1.1.1.2.0.40
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.36
	OPENBSD_5_4_BASE:1.1.1.2
	OPENBSD_5_3:1.1.1.2.0.34
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.32
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.30
	OPENBSD_5_0:1.1.1.2.0.28
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.26
	OPENBSD_4_9_BASE:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.24
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.20
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.22
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.18
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.16
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.14
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.12
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.10
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.8
	OPENBSD_4_0_BASE:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.6
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.4
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.2
	OPENBSD_3_7_BASE:1.1.1.2
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.1.1.1.0.2
	OPENBSD_3_6_BASE:1.1.1.1
	GDB_6_1:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2004.05.21.19.08.43;	author kettenis;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.05.21.19.08.43;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.08.52;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* Ada language support routines for GDB, the GNU debugger.  Copyright
   1992, 1993, 1994, 1997, 1998, 1999, 2000, 2003, 2004
   Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include <stdio.h>
#include "gdb_string.h"
#include <ctype.h>
#include <stdarg.h>
#include "demangle.h"
#include "defs.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "gdbcmd.h"
#include "expression.h"
#include "parser-defs.h"
#include "language.h"
#include "c-lang.h"
#include "inferior.h"
#include "symfile.h"
#include "objfiles.h"
#include "breakpoint.h"
#include "gdbcore.h"
#include "ada-lang.h"
#include "ui-out.h"
#include "block.h"
#include "infcall.h"
#include "dictionary.h"

struct cleanup *unresolved_names;

void extract_string (CORE_ADDR addr, char *buf);

static struct type *ada_create_fundamental_type (struct objfile *, int);

static void modify_general_field (char *, LONGEST, int, int);

static struct type *desc_base_type (struct type *);

static struct type *desc_bounds_type (struct type *);

static struct value *desc_bounds (struct value *);

static int fat_pntr_bounds_bitpos (struct type *);

static int fat_pntr_bounds_bitsize (struct type *);

static struct type *desc_data_type (struct type *);

static struct value *desc_data (struct value *);

static int fat_pntr_data_bitpos (struct type *);

static int fat_pntr_data_bitsize (struct type *);

static struct value *desc_one_bound (struct value *, int, int);

static int desc_bound_bitpos (struct type *, int, int);

static int desc_bound_bitsize (struct type *, int, int);

static struct type *desc_index_type (struct type *, int);

static int desc_arity (struct type *);

static int ada_type_match (struct type *, struct type *, int);

static int ada_args_match (struct symbol *, struct value **, int);

static struct value *place_on_stack (struct value *, CORE_ADDR *);

static struct value *convert_actual (struct value *, struct type *,
				     CORE_ADDR *);

static struct value *make_array_descriptor (struct type *, struct value *,
					    CORE_ADDR *);

static void ada_add_block_symbols (struct block *, const char *,
				   domain_enum, struct objfile *, int);

static void fill_in_ada_prototype (struct symbol *);

static int is_nonfunction (struct symbol **, int);

static void add_defn_to_vec (struct symbol *, struct block *);

static struct partial_symbol *ada_lookup_partial_symbol (struct partial_symtab
							 *, const char *, int,
							 domain_enum, int);

static struct symtab *symtab_for_sym (struct symbol *);

static struct value *ada_resolve_subexp (struct expression **, int *, int,
					 struct type *);

static void replace_operator_with_call (struct expression **, int, int, int,
					struct symbol *, struct block *);

static int possible_user_operator_p (enum exp_opcode, struct value **);

static const char *ada_op_name (enum exp_opcode);

static int numeric_type_p (struct type *);

static int integer_type_p (struct type *);

static int scalar_type_p (struct type *);

static int discrete_type_p (struct type *);

static char *extended_canonical_line_spec (struct symtab_and_line,
					   const char *);

static struct value *evaluate_subexp (struct type *, struct expression *,
				      int *, enum noside);

static struct value *evaluate_subexp_type (struct expression *, int *);

static struct type *ada_create_fundamental_type (struct objfile *, int);

static int is_dynamic_field (struct type *, int);

static struct type *to_fixed_variant_branch_type (struct type *, char *,
						  CORE_ADDR, struct value *);

static struct type *to_fixed_range_type (char *, struct value *,
					 struct objfile *);

static struct type *to_static_fixed_type (struct type *);

static struct value *unwrap_value (struct value *);

static struct type *packed_array_type (struct type *, long *);

static struct type *decode_packed_array_type (struct type *);

static struct value *decode_packed_array (struct value *);

static struct value *value_subscript_packed (struct value *, int,
					     struct value **);

static struct value *coerce_unspec_val_to_type (struct value *, long,
						struct type *);

static struct value *get_var_value (char *, char *);

static int lesseq_defined_than (struct symbol *, struct symbol *);

static int equiv_types (struct type *, struct type *);

static int is_name_suffix (const char *);

static int wild_match (const char *, int, const char *);

static struct symtabs_and_lines find_sal_from_funcs_and_line (const char *,
							      int,
							      struct symbol
							      **, int);

static int find_line_in_linetable (struct linetable *, int, struct symbol **,
				   int, int *);

static int find_next_line_in_linetable (struct linetable *, int, int, int);

static struct symtabs_and_lines all_sals_for_line (const char *, int,
						   char ***);

static void read_all_symtabs (const char *);

static int is_plausible_func_for_line (struct symbol *, int);

static struct value *ada_coerce_ref (struct value *);

static struct value *value_pos_atr (struct value *);

static struct value *value_val_atr (struct type *, struct value *);

static struct symbol *standard_lookup (const char *, domain_enum);

extern void markTimeStart (int index);
extern void markTimeStop (int index);



/* Maximum-sized dynamic type. */
static unsigned int varsize_limit;

static const char *ada_completer_word_break_characters =
  " \t\n!@@#$%^&*()+=|~`}{[]\";:?/,-";

/* The name of the symbol to use to get the name of the main subprogram */
#define ADA_MAIN_PROGRAM_SYMBOL_NAME "__gnat_ada_main_program_name"

				/* Utilities */

/* extract_string
 *
 * read the string located at ADDR from the inferior and store the
 * result into BUF
 */
void
extract_string (CORE_ADDR addr, char *buf)
{
  int char_index = 0;

  /* Loop, reading one byte at a time, until we reach the '\000' 
     end-of-string marker */
  do
    {
      target_read_memory (addr + char_index * sizeof (char),
			  buf + char_index * sizeof (char), sizeof (char));
      char_index++;
    }
  while (buf[char_index - 1] != '\000');
}

/* Assuming *OLD_VECT points to an array of *SIZE objects of size
   ELEMENT_SIZE, grow it to contain at least MIN_SIZE objects,
   updating *OLD_VECT and *SIZE as necessary. */

void
grow_vect (void **old_vect, size_t * size, size_t min_size, int element_size)
{
  if (*size < min_size)
    {
      *size *= 2;
      if (*size < min_size)
	*size = min_size;
      *old_vect = xrealloc (*old_vect, *size * element_size);
    }
}

/* True (non-zero) iff TARGET matches FIELD_NAME up to any trailing
   suffix of FIELD_NAME beginning "___" */

static int
field_name_match (const char *field_name, const char *target)
{
  int len = strlen (target);
  return
    DEPRECATED_STREQN (field_name, target, len)
    && (field_name[len] == '\0'
	|| (DEPRECATED_STREQN (field_name + len, "___", 3)
	    && !DEPRECATED_STREQ (field_name + strlen (field_name) - 6, "___XVN")));
}


/* The length of the prefix of NAME prior to any "___" suffix. */

int
ada_name_prefix_len (const char *name)
{
  if (name == NULL)
    return 0;
  else
    {
      const char *p = strstr (name, "___");
      if (p == NULL)
	return strlen (name);
      else
	return p - name;
    }
}

/* SUFFIX is a suffix of STR. False if STR is null. */
static int
is_suffix (const char *str, const char *suffix)
{
  int len1, len2;
  if (str == NULL)
    return 0;
  len1 = strlen (str);
  len2 = strlen (suffix);
  return (len1 >= len2 && DEPRECATED_STREQ (str + len1 - len2, suffix));
}

/* Create a value of type TYPE whose contents come from VALADDR, if it
 * is non-null, and whose memory address (in the inferior) is
 * ADDRESS. */
struct value *
value_from_contents_and_address (struct type *type, char *valaddr,
				 CORE_ADDR address)
{
  struct value *v = allocate_value (type);
  if (valaddr == NULL)
    VALUE_LAZY (v) = 1;
  else
    memcpy (VALUE_CONTENTS_RAW (v), valaddr, TYPE_LENGTH (type));
  VALUE_ADDRESS (v) = address;
  if (address != 0)
    VALUE_LVAL (v) = lval_memory;
  return v;
}

/* The contents of value VAL, beginning at offset OFFSET, treated as a
   value of type TYPE.  The result is an lval in memory if VAL is. */

static struct value *
coerce_unspec_val_to_type (struct value *val, long offset, struct type *type)
{
  CHECK_TYPEDEF (type);
  if (VALUE_LVAL (val) == lval_memory)
    return value_at_lazy (type,
			  VALUE_ADDRESS (val) + VALUE_OFFSET (val) + offset,
			  NULL);
  else
    {
      struct value *result = allocate_value (type);
      VALUE_LVAL (result) = not_lval;
      if (VALUE_ADDRESS (val) == 0)
	memcpy (VALUE_CONTENTS_RAW (result), VALUE_CONTENTS (val) + offset,
		TYPE_LENGTH (type) > TYPE_LENGTH (VALUE_TYPE (val))
		? TYPE_LENGTH (VALUE_TYPE (val)) : TYPE_LENGTH (type));
      else
	{
	  VALUE_ADDRESS (result) =
	    VALUE_ADDRESS (val) + VALUE_OFFSET (val) + offset;
	  VALUE_LAZY (result) = 1;
	}
      return result;
    }
}

static char *
cond_offset_host (char *valaddr, long offset)
{
  if (valaddr == NULL)
    return NULL;
  else
    return valaddr + offset;
}

static CORE_ADDR
cond_offset_target (CORE_ADDR address, long offset)
{
  if (address == 0)
    return 0;
  else
    return address + offset;
}

/* Perform execute_command on the result of concatenating all
   arguments up to NULL. */
static void
do_command (const char *arg, ...)
{
  int len;
  char *cmd;
  const char *s;
  va_list ap;

  va_start (ap, arg);
  len = 0;
  s = arg;
  cmd = "";
  for (; s != NULL; s = va_arg (ap, const char *))
    {
      char *cmd1;
      len += strlen (s);
      cmd1 = alloca (len + 1);
      strcpy (cmd1, cmd);
      strcat (cmd1, s);
      cmd = cmd1;
    }
  va_end (ap);
  execute_command (cmd, 0);
}


				/* Language Selection */

/* If the main program is in Ada, return language_ada, otherwise return LANG
   (the main program is in Ada iif the adainit symbol is found).

   MAIN_PST is not used. */

enum language
ada_update_initial_language (enum language lang,
			     struct partial_symtab *main_pst)
{
  if (lookup_minimal_symbol ("adainit", (const char *) NULL,
			     (struct objfile *) NULL) != NULL)
    /*    return language_ada; */
    /* FIXME: language_ada should be defined in defs.h */
    return language_unknown;

  return lang;
}


				/* Symbols */

/* Table of Ada operators and their GNAT-mangled names.  Last entry is pair 
   of NULLs. */

const struct ada_opname_map ada_opname_table[] = {
  {"Oadd", "\"+\"", BINOP_ADD},
  {"Osubtract", "\"-\"", BINOP_SUB},
  {"Omultiply", "\"*\"", BINOP_MUL},
  {"Odivide", "\"/\"", BINOP_DIV},
  {"Omod", "\"mod\"", BINOP_MOD},
  {"Orem", "\"rem\"", BINOP_REM},
  {"Oexpon", "\"**\"", BINOP_EXP},
  {"Olt", "\"<\"", BINOP_LESS},
  {"Ole", "\"<=\"", BINOP_LEQ},
  {"Ogt", "\">\"", BINOP_GTR},
  {"Oge", "\">=\"", BINOP_GEQ},
  {"Oeq", "\"=\"", BINOP_EQUAL},
  {"One", "\"/=\"", BINOP_NOTEQUAL},
  {"Oand", "\"and\"", BINOP_BITWISE_AND},
  {"Oor", "\"or\"", BINOP_BITWISE_IOR},
  {"Oxor", "\"xor\"", BINOP_BITWISE_XOR},
  {"Oconcat", "\"&\"", BINOP_CONCAT},
  {"Oabs", "\"abs\"", UNOP_ABS},
  {"Onot", "\"not\"", UNOP_LOGICAL_NOT},
  {"Oadd", "\"+\"", UNOP_PLUS},
  {"Osubtract", "\"-\"", UNOP_NEG},
  {NULL, NULL}
};

/* True if STR should be suppressed in info listings. */
static int
is_suppressed_name (const char *str)
{
  if (DEPRECATED_STREQN (str, "_ada_", 5))
    str += 5;
  if (str[0] == '_' || str[0] == '\000')
    return 1;
  else
    {
      const char *p;
      const char *suffix = strstr (str, "___");
      if (suffix != NULL && suffix[3] != 'X')
	return 1;
      if (suffix == NULL)
	suffix = str + strlen (str);
      for (p = suffix - 1; p != str; p -= 1)
	if (isupper (*p))
	  {
	    int i;
	    if (p[0] == 'X' && p[-1] != '_')
	      goto OK;
	    if (*p != 'O')
	      return 1;
	    for (i = 0; ada_opname_table[i].mangled != NULL; i += 1)
	      if (DEPRECATED_STREQN (ada_opname_table[i].mangled, p,
			  strlen (ada_opname_table[i].mangled)))
		goto OK;
	    return 1;
	  OK:;
	  }
      return 0;
    }
}

/* The "mangled" form of DEMANGLED, according to GNAT conventions.
 * The result is valid until the next call to ada_mangle. */
char *
ada_mangle (const char *demangled)
{
  static char *mangling_buffer = NULL;
  static size_t mangling_buffer_size = 0;
  const char *p;
  int k;

  if (demangled == NULL)
    return NULL;

  GROW_VECT (mangling_buffer, mangling_buffer_size,
	     2 * strlen (demangled) + 10);

  k = 0;
  for (p = demangled; *p != '\0'; p += 1)
    {
      if (*p == '.')
	{
	  mangling_buffer[k] = mangling_buffer[k + 1] = '_';
	  k += 2;
	}
      else if (*p == '"')
	{
	  const struct ada_opname_map *mapping;

	  for (mapping = ada_opname_table;
	       mapping->mangled != NULL &&
	       !DEPRECATED_STREQN (mapping->demangled, p, strlen (mapping->demangled));
	       p += 1)
	    ;
	  if (mapping->mangled == NULL)
	    error ("invalid Ada operator name: %s", p);
	  strcpy (mangling_buffer + k, mapping->mangled);
	  k += strlen (mapping->mangled);
	  break;
	}
      else
	{
	  mangling_buffer[k] = *p;
	  k += 1;
	}
    }

  mangling_buffer[k] = '\0';
  return mangling_buffer;
}

/* Return NAME folded to lower case, or, if surrounded by single
 * quotes, unfolded, but with the quotes stripped away.  Result good
 * to next call. */
char *
ada_fold_name (const char *name)
{
  static char *fold_buffer = NULL;
  static size_t fold_buffer_size = 0;

  int len = strlen (name);
  GROW_VECT (fold_buffer, fold_buffer_size, len + 1);

  if (name[0] == '\'')
    {
      strncpy (fold_buffer, name + 1, len - 2);
      fold_buffer[len - 2] = '\000';
    }
  else
    {
      int i;
      for (i = 0; i <= len; i += 1)
	fold_buffer[i] = tolower (name[i]);
    }

  return fold_buffer;
}

/* Demangle: 
     1. Discard final __{DIGIT}+ or ${DIGIT}+
     2. Convert other instances of embedded "__" to `.'.
     3. Discard leading _ada_.
     4. Convert operator names to the appropriate quoted symbols.
     5. Remove everything after first ___ if it is followed by 
        'X'.
     6. Replace TK__ with __, and a trailing B or TKB with nothing.
     7. Put symbols that should be suppressed in <...> brackets.
     8. Remove trailing X[bn]* suffix (indicating names in package bodies).
   The resulting string is valid until the next call of ada_demangle.
  */

char *
ada_demangle (const char *mangled)
{
  int i, j;
  int len0;
  const char *p;
  char *demangled;
  int at_start_name;
  static char *demangling_buffer = NULL;
  static size_t demangling_buffer_size = 0;

  if (DEPRECATED_STREQN (mangled, "_ada_", 5))
    mangled += 5;

  if (mangled[0] == '_' || mangled[0] == '<')
    goto Suppress;

  p = strstr (mangled, "___");
  if (p == NULL)
    len0 = strlen (mangled);
  else
    {
      if (p[3] == 'X')
	len0 = p - mangled;
      else
	goto Suppress;
    }
  if (len0 > 3 && DEPRECATED_STREQ (mangled + len0 - 3, "TKB"))
    len0 -= 3;
  if (len0 > 1 && DEPRECATED_STREQ (mangled + len0 - 1, "B"))
    len0 -= 1;

  /* Make demangled big enough for possible expansion by operator name. */
  GROW_VECT (demangling_buffer, demangling_buffer_size, 2 * len0 + 1);
  demangled = demangling_buffer;

  if (isdigit (mangled[len0 - 1]))
    {
      for (i = len0 - 2; i >= 0 && isdigit (mangled[i]); i -= 1)
	;
      if (i > 1 && mangled[i] == '_' && mangled[i - 1] == '_')
	len0 = i - 1;
      else if (mangled[i] == '$')
	len0 = i;
    }

  for (i = 0, j = 0; i < len0 && !isalpha (mangled[i]); i += 1, j += 1)
    demangled[j] = mangled[i];

  at_start_name = 1;
  while (i < len0)
    {
      if (at_start_name && mangled[i] == 'O')
	{
	  int k;
	  for (k = 0; ada_opname_table[k].mangled != NULL; k += 1)
	    {
	      int op_len = strlen (ada_opname_table[k].mangled);
	      if (DEPRECATED_STREQN
		  (ada_opname_table[k].mangled + 1, mangled + i + 1,
		   op_len - 1) && !isalnum (mangled[i + op_len]))
		{
		  strcpy (demangled + j, ada_opname_table[k].demangled);
		  at_start_name = 0;
		  i += op_len;
		  j += strlen (ada_opname_table[k].demangled);
		  break;
		}
	    }
	  if (ada_opname_table[k].mangled != NULL)
	    continue;
	}
      at_start_name = 0;

      if (i < len0 - 4 && DEPRECATED_STREQN (mangled + i, "TK__", 4))
	i += 2;
      if (mangled[i] == 'X' && i != 0 && isalnum (mangled[i - 1]))
	{
	  do
	    i += 1;
	  while (i < len0 && (mangled[i] == 'b' || mangled[i] == 'n'));
	  if (i < len0)
	    goto Suppress;
	}
      else if (i < len0 - 2 && mangled[i] == '_' && mangled[i + 1] == '_')
	{
	  demangled[j] = '.';
	  at_start_name = 1;
	  i += 2;
	  j += 1;
	}
      else
	{
	  demangled[j] = mangled[i];
	  i += 1;
	  j += 1;
	}
    }
  demangled[j] = '\000';

  for (i = 0; demangled[i] != '\0'; i += 1)
    if (isupper (demangled[i]) || demangled[i] == ' ')
      goto Suppress;

  return demangled;

Suppress:
  GROW_VECT (demangling_buffer, demangling_buffer_size, strlen (mangled) + 3);
  demangled = demangling_buffer;
  if (mangled[0] == '<')
    strcpy (demangled, mangled);
  else
    sprintf (demangled, "<%s>", mangled);
  return demangled;

}

/* Returns non-zero iff SYM_NAME matches NAME, ignoring any trailing
 * suffixes that encode debugging information or leading _ada_ on
 * SYM_NAME (see is_name_suffix commentary for the debugging
 * information that is ignored).  If WILD, then NAME need only match a
 * suffix of SYM_NAME minus the same suffixes. Also returns 0 if
 * either argument is NULL. */

int
ada_match_name (const char *sym_name, const char *name, int wild)
{
  if (sym_name == NULL || name == NULL)
    return 0;
  else if (wild)
    return wild_match (name, strlen (name), sym_name);
  else
    {
      int len_name = strlen (name);
      return (DEPRECATED_STREQN (sym_name, name, len_name)
	      && is_name_suffix (sym_name + len_name))
	|| (DEPRECATED_STREQN (sym_name, "_ada_", 5)
	    && DEPRECATED_STREQN (sym_name + 5, name, len_name)
	    && is_name_suffix (sym_name + len_name + 5));
    }
}

/* True (non-zero) iff in Ada mode, the symbol SYM should be
   suppressed in info listings. */

int
ada_suppress_symbol_printing (struct symbol *sym)
{
  if (SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN)
    return 1;
  else
    return is_suppressed_name (DEPRECATED_SYMBOL_NAME (sym));
}


				/* Arrays */

/* Names of MAX_ADA_DIMENS bounds in P_BOUNDS fields of 
   array descriptors.  */

static char *bound_name[] = {
  "LB0", "UB0", "LB1", "UB1", "LB2", "UB2", "LB3", "UB3",
  "LB4", "UB4", "LB5", "UB5", "LB6", "UB6", "LB7", "UB7"
};

/* Maximum number of array dimensions we are prepared to handle.  */

#define MAX_ADA_DIMENS (sizeof(bound_name) / (2*sizeof(char*)))

/* Like modify_field, but allows bitpos > wordlength. */

static void
modify_general_field (char *addr, LONGEST fieldval, int bitpos, int bitsize)
{
  modify_field (addr + sizeof (LONGEST) * bitpos / (8 * sizeof (LONGEST)),
		fieldval, bitpos % (8 * sizeof (LONGEST)), bitsize);
}


/* The desc_* routines return primitive portions of array descriptors 
   (fat pointers). */

/* The descriptor or array type, if any, indicated by TYPE; removes
   level of indirection, if needed. */
static struct type *
desc_base_type (struct type *type)
{
  if (type == NULL)
    return NULL;
  CHECK_TYPEDEF (type);
  if (type != NULL && TYPE_CODE (type) == TYPE_CODE_PTR)
    return check_typedef (TYPE_TARGET_TYPE (type));
  else
    return type;
}

/* True iff TYPE indicates a "thin" array pointer type. */
static int
is_thin_pntr (struct type *type)
{
  return
    is_suffix (ada_type_name (desc_base_type (type)), "___XUT")
    || is_suffix (ada_type_name (desc_base_type (type)), "___XUT___XVE");
}

/* The descriptor type for thin pointer type TYPE. */
static struct type *
thin_descriptor_type (struct type *type)
{
  struct type *base_type = desc_base_type (type);
  if (base_type == NULL)
    return NULL;
  if (is_suffix (ada_type_name (base_type), "___XVE"))
    return base_type;
  else
    {
      struct type *alt_type = ada_find_parallel_type (base_type, "___XVE");
      if (alt_type == NULL)
	return base_type;
      else
	return alt_type;
    }
}

/* A pointer to the array data for thin-pointer value VAL. */
static struct value *
thin_data_pntr (struct value *val)
{
  struct type *type = VALUE_TYPE (val);
  if (TYPE_CODE (type) == TYPE_CODE_PTR)
    return value_cast (desc_data_type (thin_descriptor_type (type)),
		       value_copy (val));
  else
    return value_from_longest (desc_data_type (thin_descriptor_type (type)),
			       VALUE_ADDRESS (val) + VALUE_OFFSET (val));
}

/* True iff TYPE indicates a "thick" array pointer type. */
static int
is_thick_pntr (struct type *type)
{
  type = desc_base_type (type);
  return (type != NULL && TYPE_CODE (type) == TYPE_CODE_STRUCT
	  && lookup_struct_elt_type (type, "P_BOUNDS", 1) != NULL);
}

/* If TYPE is the type of an array descriptor (fat or thin pointer) or a 
   pointer to one, the type of its bounds data; otherwise, NULL. */
static struct type *
desc_bounds_type (struct type *type)
{
  struct type *r;

  type = desc_base_type (type);

  if (type == NULL)
    return NULL;
  else if (is_thin_pntr (type))
    {
      type = thin_descriptor_type (type);
      if (type == NULL)
	return NULL;
      r = lookup_struct_elt_type (type, "BOUNDS", 1);
      if (r != NULL)
	return check_typedef (r);
    }
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT)
    {
      r = lookup_struct_elt_type (type, "P_BOUNDS", 1);
      if (r != NULL)
	return check_typedef (TYPE_TARGET_TYPE (check_typedef (r)));
    }
  return NULL;
}

/* If ARR is an array descriptor (fat or thin pointer), or pointer to
   one, a pointer to its bounds data.   Otherwise NULL. */
static struct value *
desc_bounds (struct value *arr)
{
  struct type *type = check_typedef (VALUE_TYPE (arr));
  if (is_thin_pntr (type))
    {
      struct type *bounds_type =
	desc_bounds_type (thin_descriptor_type (type));
      LONGEST addr;

      if (desc_bounds_type == NULL)
	error ("Bad GNAT array descriptor");

      /* NOTE: The following calculation is not really kosher, but
         since desc_type is an XVE-encoded type (and shouldn't be),
         the correct calculation is a real pain. FIXME (and fix GCC). */
      if (TYPE_CODE (type) == TYPE_CODE_PTR)
	addr = value_as_long (arr);
      else
	addr = VALUE_ADDRESS (arr) + VALUE_OFFSET (arr);

      return
	value_from_longest (lookup_pointer_type (bounds_type),
			    addr - TYPE_LENGTH (bounds_type));
    }

  else if (is_thick_pntr (type))
    return value_struct_elt (&arr, NULL, "P_BOUNDS", NULL,
			     "Bad GNAT array descriptor");
  else
    return NULL;
}

/* If TYPE is the type of an array-descriptor (fat pointer), the bit
   position of the field containing the address of the bounds data. */
static int
fat_pntr_bounds_bitpos (struct type *type)
{
  return TYPE_FIELD_BITPOS (desc_base_type (type), 1);
}

/* If TYPE is the type of an array-descriptor (fat pointer), the bit
   size of the field containing the address of the bounds data. */
static int
fat_pntr_bounds_bitsize (struct type *type)
{
  type = desc_base_type (type);

  if (TYPE_FIELD_BITSIZE (type, 1) > 0)
    return TYPE_FIELD_BITSIZE (type, 1);
  else
    return 8 * TYPE_LENGTH (check_typedef (TYPE_FIELD_TYPE (type, 1)));
}

/* If TYPE is the type of an array descriptor (fat or thin pointer) or a 
   pointer to one, the type of its array data (a
   pointer-to-array-with-no-bounds type); otherwise,  NULL.  Use
   ada_type_of_array to get an array type with bounds data. */
static struct type *
desc_data_type (struct type *type)
{
  type = desc_base_type (type);

  /* NOTE: The following is bogus; see comment in desc_bounds. */
  if (is_thin_pntr (type))
    return lookup_pointer_type
      (desc_base_type (TYPE_FIELD_TYPE (thin_descriptor_type (type), 1)));
  else if (is_thick_pntr (type))
    return lookup_struct_elt_type (type, "P_ARRAY", 1);
  else
    return NULL;
}

/* If ARR is an array descriptor (fat or thin pointer), a pointer to
   its array data.  */
static struct value *
desc_data (struct value *arr)
{
  struct type *type = VALUE_TYPE (arr);
  if (is_thin_pntr (type))
    return thin_data_pntr (arr);
  else if (is_thick_pntr (type))
    return value_struct_elt (&arr, NULL, "P_ARRAY", NULL,
			     "Bad GNAT array descriptor");
  else
    return NULL;
}


/* If TYPE is the type of an array-descriptor (fat pointer), the bit
   position of the field containing the address of the data. */
static int
fat_pntr_data_bitpos (struct type *type)
{
  return TYPE_FIELD_BITPOS (desc_base_type (type), 0);
}

/* If TYPE is the type of an array-descriptor (fat pointer), the bit
   size of the field containing the address of the data. */
static int
fat_pntr_data_bitsize (struct type *type)
{
  type = desc_base_type (type);

  if (TYPE_FIELD_BITSIZE (type, 0) > 0)
    return TYPE_FIELD_BITSIZE (type, 0);
  else
    return TARGET_CHAR_BIT * TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0));
}

/* If BOUNDS is an array-bounds structure (or pointer to one), return 
   the Ith lower bound stored in it, if WHICH is 0, and the Ith upper
   bound, if WHICH is 1.  The first bound is I=1. */
static struct value *
desc_one_bound (struct value *bounds, int i, int which)
{
  return value_struct_elt (&bounds, NULL, bound_name[2 * i + which - 2], NULL,
			   "Bad GNAT array descriptor bounds");
}

/* If BOUNDS is an array-bounds structure type, return the bit position
   of the Ith lower bound stored in it, if WHICH is 0, and the Ith upper
   bound, if WHICH is 1.  The first bound is I=1. */
static int
desc_bound_bitpos (struct type *type, int i, int which)
{
  return TYPE_FIELD_BITPOS (desc_base_type (type), 2 * i + which - 2);
}

/* If BOUNDS is an array-bounds structure type, return the bit field size
   of the Ith lower bound stored in it, if WHICH is 0, and the Ith upper
   bound, if WHICH is 1.  The first bound is I=1. */
static int
desc_bound_bitsize (struct type *type, int i, int which)
{
  type = desc_base_type (type);

  if (TYPE_FIELD_BITSIZE (type, 2 * i + which - 2) > 0)
    return TYPE_FIELD_BITSIZE (type, 2 * i + which - 2);
  else
    return 8 * TYPE_LENGTH (TYPE_FIELD_TYPE (type, 2 * i + which - 2));
}

/* If TYPE is the type of an array-bounds structure, the type of its
   Ith bound (numbering from 1). Otherwise, NULL. */
static struct type *
desc_index_type (struct type *type, int i)
{
  type = desc_base_type (type);

  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)
    return lookup_struct_elt_type (type, bound_name[2 * i - 2], 1);
  else
    return NULL;
}

/* The number of index positions in the array-bounds type TYPE.  0
   if TYPE is NULL. */
static int
desc_arity (struct type *type)
{
  type = desc_base_type (type);

  if (type != NULL)
    return TYPE_NFIELDS (type) / 2;
  return 0;
}


/* Non-zero iff type is a simple array type (or pointer to one). */
int
ada_is_simple_array (struct type *type)
{
  if (type == NULL)
    return 0;
  CHECK_TYPEDEF (type);
  return (TYPE_CODE (type) == TYPE_CODE_ARRAY
	  || (TYPE_CODE (type) == TYPE_CODE_PTR
	      && TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_ARRAY));
}

/* Non-zero iff type belongs to a GNAT array descriptor. */
int
ada_is_array_descriptor (struct type *type)
{
  struct type *data_type = desc_data_type (type);

  if (type == NULL)
    return 0;
  CHECK_TYPEDEF (type);
  return
    data_type != NULL
    && ((TYPE_CODE (data_type) == TYPE_CODE_PTR
	 && TYPE_TARGET_TYPE (data_type) != NULL
	 && TYPE_CODE (TYPE_TARGET_TYPE (data_type)) == TYPE_CODE_ARRAY)
	||
	TYPE_CODE (data_type) == TYPE_CODE_ARRAY)
    && desc_arity (desc_bounds_type (type)) > 0;
}

/* Non-zero iff type is a partially mal-formed GNAT array
   descriptor.  (FIXME: This is to compensate for some problems with 
   debugging output from GNAT.  Re-examine periodically to see if it
   is still needed. */
int
ada_is_bogus_array_descriptor (struct type *type)
{
  return
    type != NULL
    && TYPE_CODE (type) == TYPE_CODE_STRUCT
    && (lookup_struct_elt_type (type, "P_BOUNDS", 1) != NULL
	|| lookup_struct_elt_type (type, "P_ARRAY", 1) != NULL)
    && !ada_is_array_descriptor (type);
}


/* If ARR has a record type in the form of a standard GNAT array descriptor, 
   (fat pointer) returns the type of the array data described---specifically,
   a pointer-to-array type.  If BOUNDS is non-zero, the bounds data are filled 
   in from the descriptor; otherwise, they are left unspecified.  If
   the ARR denotes a null array descriptor and BOUNDS is non-zero, 
   returns NULL.  The result is simply the type of ARR if ARR is not 
   a descriptor.  */
struct type *
ada_type_of_array (struct value *arr, int bounds)
{
  if (ada_is_packed_array_type (VALUE_TYPE (arr)))
    return decode_packed_array_type (VALUE_TYPE (arr));

  if (!ada_is_array_descriptor (VALUE_TYPE (arr)))
    return VALUE_TYPE (arr);

  if (!bounds)
    return
      check_typedef (TYPE_TARGET_TYPE (desc_data_type (VALUE_TYPE (arr))));
  else
    {
      struct type *elt_type;
      int arity;
      struct value *descriptor;
      struct objfile *objf = TYPE_OBJFILE (VALUE_TYPE (arr));

      elt_type = ada_array_element_type (VALUE_TYPE (arr), -1);
      arity = ada_array_arity (VALUE_TYPE (arr));

      if (elt_type == NULL || arity == 0)
	return check_typedef (VALUE_TYPE (arr));

      descriptor = desc_bounds (arr);
      if (value_as_long (descriptor) == 0)
	return NULL;
      while (arity > 0)
	{
	  struct type *range_type = alloc_type (objf);
	  struct type *array_type = alloc_type (objf);
	  struct value *low = desc_one_bound (descriptor, arity, 0);
	  struct value *high = desc_one_bound (descriptor, arity, 1);
	  arity -= 1;

	  create_range_type (range_type, VALUE_TYPE (low),
			     (int) value_as_long (low),
			     (int) value_as_long (high));
	  elt_type = create_array_type (array_type, elt_type, range_type);
	}

      return lookup_pointer_type (elt_type);
    }
}

/* If ARR does not represent an array, returns ARR unchanged.
   Otherwise, returns either a standard GDB array with bounds set 
   appropriately or, if ARR is a non-null fat pointer, a pointer to a standard 
   GDB array.  Returns NULL if ARR is a null fat pointer. */
struct value *
ada_coerce_to_simple_array_ptr (struct value *arr)
{
  if (ada_is_array_descriptor (VALUE_TYPE (arr)))
    {
      struct type *arrType = ada_type_of_array (arr, 1);
      if (arrType == NULL)
	return NULL;
      return value_cast (arrType, value_copy (desc_data (arr)));
    }
  else if (ada_is_packed_array_type (VALUE_TYPE (arr)))
    return decode_packed_array (arr);
  else
    return arr;
}

/* If ARR does not represent an array, returns ARR unchanged.
   Otherwise, returns a standard GDB array describing ARR (which may
   be ARR itself if it already is in the proper form). */
struct value *
ada_coerce_to_simple_array (struct value *arr)
{
  if (ada_is_array_descriptor (VALUE_TYPE (arr)))
    {
      struct value *arrVal = ada_coerce_to_simple_array_ptr (arr);
      if (arrVal == NULL)
	error ("Bounds unavailable for null array pointer.");
      return value_ind (arrVal);
    }
  else if (ada_is_packed_array_type (VALUE_TYPE (arr)))
    return decode_packed_array (arr);
  else
    return arr;
}

/* If TYPE represents a GNAT array type, return it translated to an
   ordinary GDB array type (possibly with BITSIZE fields indicating
   packing). For other types, is the identity. */
struct type *
ada_coerce_to_simple_array_type (struct type *type)
{
  struct value *mark = value_mark ();
  struct value *dummy = value_from_longest (builtin_type_long, 0);
  struct type *result;
  VALUE_TYPE (dummy) = type;
  result = ada_type_of_array (dummy, 0);
  value_free_to_mark (dummy);
  return result;
}

/* Non-zero iff TYPE represents a standard GNAT packed-array type. */
int
ada_is_packed_array_type (struct type *type)
{
  if (type == NULL)
    return 0;
  CHECK_TYPEDEF (type);
  return
    ada_type_name (type) != NULL
    && strstr (ada_type_name (type), "___XP") != NULL;
}

/* Given that TYPE is a standard GDB array type with all bounds filled
   in, and that the element size of its ultimate scalar constituents
   (that is, either its elements, or, if it is an array of arrays, its
   elements' elements, etc.) is *ELT_BITS, return an identical type,
   but with the bit sizes of its elements (and those of any
   constituent arrays) recorded in the BITSIZE components of its
   TYPE_FIELD_BITSIZE values, and with *ELT_BITS set to its total size 
   in bits. */
static struct type *
packed_array_type (struct type *type, long *elt_bits)
{
  struct type *new_elt_type;
  struct type *new_type;
  LONGEST low_bound, high_bound;

  CHECK_TYPEDEF (type);
  if (TYPE_CODE (type) != TYPE_CODE_ARRAY)
    return type;

  new_type = alloc_type (TYPE_OBJFILE (type));
  new_elt_type = packed_array_type (check_typedef (TYPE_TARGET_TYPE (type)),
				    elt_bits);
  create_array_type (new_type, new_elt_type, TYPE_FIELD_TYPE (type, 0));
  TYPE_FIELD_BITSIZE (new_type, 0) = *elt_bits;
  TYPE_NAME (new_type) = ada_type_name (type);

  if (get_discrete_bounds (TYPE_FIELD_TYPE (type, 0),
			   &low_bound, &high_bound) < 0)
    low_bound = high_bound = 0;
  if (high_bound < low_bound)
    *elt_bits = TYPE_LENGTH (new_type) = 0;
  else
    {
      *elt_bits *= (high_bound - low_bound + 1);
      TYPE_LENGTH (new_type) =
	(*elt_bits + HOST_CHAR_BIT - 1) / HOST_CHAR_BIT;
    }

  /*  TYPE_FLAGS (new_type) |= TYPE_FLAG_FIXED_INSTANCE; */
  /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
  return new_type;
}

/* The array type encoded by TYPE, where ada_is_packed_array_type (TYPE).
 */
static struct type *
decode_packed_array_type (struct type *type)
{
  struct symbol **syms;
  struct block **blocks;
  const char *raw_name = ada_type_name (check_typedef (type));
  char *name = (char *) alloca (strlen (raw_name) + 1);
  char *tail = strstr (raw_name, "___XP");
  struct type *shadow_type;
  long bits;
  int i, n;

  memcpy (name, raw_name, tail - raw_name);
  name[tail - raw_name] = '\000';

  /* NOTE: Use ada_lookup_symbol_list because of bug in some versions
   * of gcc (Solaris, e.g.). FIXME when compiler is fixed. */
  n = ada_lookup_symbol_list (name, get_selected_block (NULL),
			      VAR_DOMAIN, &syms, &blocks);
  for (i = 0; i < n; i += 1)
    if (syms[i] != NULL && SYMBOL_CLASS (syms[i]) == LOC_TYPEDEF
	&& DEPRECATED_STREQ (name, ada_type_name (SYMBOL_TYPE (syms[i]))))
      break;
  if (i >= n)
    {
      warning ("could not find bounds information on packed array");
      return NULL;
    }
  shadow_type = SYMBOL_TYPE (syms[i]);

  if (TYPE_CODE (shadow_type) != TYPE_CODE_ARRAY)
    {
      warning ("could not understand bounds information on packed array");
      return NULL;
    }

  if (sscanf (tail + sizeof ("___XP") - 1, "%ld", &bits) != 1)
    {
      warning ("could not understand bit size information on packed array");
      return NULL;
    }

  return packed_array_type (shadow_type, &bits);
}

/* Given that ARR is a struct value* indicating a GNAT packed array,
   returns a simple array that denotes that array.  Its type is a
   standard GDB array type except that the BITSIZEs of the array
   target types are set to the number of bits in each element, and the
   type length is set appropriately. */

static struct value *
decode_packed_array (struct value *arr)
{
  struct type *type = decode_packed_array_type (VALUE_TYPE (arr));

  if (type == NULL)
    {
      error ("can't unpack array");
      return NULL;
    }
  else
    return coerce_unspec_val_to_type (arr, 0, type);
}


/* The value of the element of packed array ARR at the ARITY indices
   given in IND.   ARR must be a simple array. */

static struct value *
value_subscript_packed (struct value *arr, int arity, struct value **ind)
{
  int i;
  int bits, elt_off, bit_off;
  long elt_total_bit_offset;
  struct type *elt_type;
  struct value *v;

  bits = 0;
  elt_total_bit_offset = 0;
  elt_type = check_typedef (VALUE_TYPE (arr));
  for (i = 0; i < arity; i += 1)
    {
      if (TYPE_CODE (elt_type) != TYPE_CODE_ARRAY
	  || TYPE_FIELD_BITSIZE (elt_type, 0) == 0)
	error
	  ("attempt to do packed indexing of something other than a packed array");
      else
	{
	  struct type *range_type = TYPE_INDEX_TYPE (elt_type);
	  LONGEST lowerbound, upperbound;
	  LONGEST idx;

	  if (get_discrete_bounds (range_type, &lowerbound, &upperbound) < 0)
	    {
	      warning ("don't know bounds of array");
	      lowerbound = upperbound = 0;
	    }

	  idx = value_as_long (value_pos_atr (ind[i]));
	  if (idx < lowerbound || idx > upperbound)
	    warning ("packed array index %ld out of bounds", (long) idx);
	  bits = TYPE_FIELD_BITSIZE (elt_type, 0);
	  elt_total_bit_offset += (idx - lowerbound) * bits;
	  elt_type = check_typedef (TYPE_TARGET_TYPE (elt_type));
	}
    }
  elt_off = elt_total_bit_offset / HOST_CHAR_BIT;
  bit_off = elt_total_bit_offset % HOST_CHAR_BIT;

  v = ada_value_primitive_packed_val (arr, NULL, elt_off, bit_off,
				      bits, elt_type);
  if (VALUE_LVAL (arr) == lval_internalvar)
    VALUE_LVAL (v) = lval_internalvar_component;
  else
    VALUE_LVAL (v) = VALUE_LVAL (arr);
  return v;
}

/* Non-zero iff TYPE includes negative integer values. */

static int
has_negatives (struct type *type)
{
  switch (TYPE_CODE (type))
    {
    default:
      return 0;
    case TYPE_CODE_INT:
      return !TYPE_UNSIGNED (type);
    case TYPE_CODE_RANGE:
      return TYPE_LOW_BOUND (type) < 0;
    }
}


/* Create a new value of type TYPE from the contents of OBJ starting
   at byte OFFSET, and bit offset BIT_OFFSET within that byte,
   proceeding for BIT_SIZE bits.  If OBJ is an lval in memory, then
   assigning through the result will set the field fetched from. OBJ
   may also be NULL, in which case, VALADDR+OFFSET must address the
   start of storage containing the packed value.  The value returned 
   in this case is never an lval.   
   Assumes 0 <= BIT_OFFSET < HOST_CHAR_BIT. */

struct value *
ada_value_primitive_packed_val (struct value *obj, char *valaddr, long offset,
				int bit_offset, int bit_size,
				struct type *type)
{
  struct value *v;
  int src,			/* Index into the source area. */
    targ,			/* Index into the target area. */
    i, srcBitsLeft,		/* Number of source bits left to move. */
    nsrc, ntarg,		/* Number of source and target bytes. */
    unusedLS,			/* Number of bits in next significant
				 * byte of source that are unused. */
    accumSize;			/* Number of meaningful bits in accum */
  unsigned char *bytes;		/* First byte containing data to unpack. */
  unsigned char *unpacked;
  unsigned long accum;		/* Staging area for bits being transferred */
  unsigned char sign;
  int len = (bit_size + bit_offset + HOST_CHAR_BIT - 1) / 8;
  /* Transmit bytes from least to most significant; delta is the
   * direction the indices move. */
  int delta = BITS_BIG_ENDIAN ? -1 : 1;

  CHECK_TYPEDEF (type);

  if (obj == NULL)
    {
      v = allocate_value (type);
      bytes = (unsigned char *) (valaddr + offset);
    }
  else if (VALUE_LAZY (obj))
    {
      v = value_at (type,
		    VALUE_ADDRESS (obj) + VALUE_OFFSET (obj) + offset, NULL);
      bytes = (unsigned char *) alloca (len);
      read_memory (VALUE_ADDRESS (v), bytes, len);
    }
  else
    {
      v = allocate_value (type);
      bytes = (unsigned char *) VALUE_CONTENTS (obj) + offset;
    }

  if (obj != NULL)
    {
      VALUE_LVAL (v) = VALUE_LVAL (obj);
      if (VALUE_LVAL (obj) == lval_internalvar)
	VALUE_LVAL (v) = lval_internalvar_component;
      VALUE_ADDRESS (v) = VALUE_ADDRESS (obj) + VALUE_OFFSET (obj) + offset;
      VALUE_BITPOS (v) = bit_offset + VALUE_BITPOS (obj);
      VALUE_BITSIZE (v) = bit_size;
      if (VALUE_BITPOS (v) >= HOST_CHAR_BIT)
	{
	  VALUE_ADDRESS (v) += 1;
	  VALUE_BITPOS (v) -= HOST_CHAR_BIT;
	}
    }
  else
    VALUE_BITSIZE (v) = bit_size;
  unpacked = (unsigned char *) VALUE_CONTENTS (v);

  srcBitsLeft = bit_size;
  nsrc = len;
  ntarg = TYPE_LENGTH (type);
  sign = 0;
  if (bit_size == 0)
    {
      memset (unpacked, 0, TYPE_LENGTH (type));
      return v;
    }
  else if (BITS_BIG_ENDIAN)
    {
      src = len - 1;
      if (has_negatives (type) &&
	  ((bytes[0] << bit_offset) & (1 << (HOST_CHAR_BIT - 1))))
	sign = ~0;

      unusedLS =
	(HOST_CHAR_BIT - (bit_size + bit_offset) % HOST_CHAR_BIT)
	% HOST_CHAR_BIT;

      switch (TYPE_CODE (type))
	{
	case TYPE_CODE_ARRAY:
	case TYPE_CODE_UNION:
	case TYPE_CODE_STRUCT:
	  /* Non-scalar values must be aligned at a byte boundary. */
	  accumSize =
	    (HOST_CHAR_BIT - bit_size % HOST_CHAR_BIT) % HOST_CHAR_BIT;
	  /* And are placed at the beginning (most-significant) bytes
	   * of the target. */
	  targ = src;
	  break;
	default:
	  accumSize = 0;
	  targ = TYPE_LENGTH (type) - 1;
	  break;
	}
    }
  else
    {
      int sign_bit_offset = (bit_size + bit_offset - 1) % 8;

      src = targ = 0;
      unusedLS = bit_offset;
      accumSize = 0;

      if (has_negatives (type) && (bytes[len - 1] & (1 << sign_bit_offset)))
	sign = ~0;
    }

  accum = 0;
  while (nsrc > 0)
    {
      /* Mask for removing bits of the next source byte that are not
       * part of the value. */
      unsigned int unusedMSMask =
	(1 << (srcBitsLeft >= HOST_CHAR_BIT ? HOST_CHAR_BIT : srcBitsLeft)) -
	1;
      /* Sign-extend bits for this byte. */
      unsigned int signMask = sign & ~unusedMSMask;
      accum |=
	(((bytes[src] >> unusedLS) & unusedMSMask) | signMask) << accumSize;
      accumSize += HOST_CHAR_BIT - unusedLS;
      if (accumSize >= HOST_CHAR_BIT)
	{
	  unpacked[targ] = accum & ~(~0L << HOST_CHAR_BIT);
	  accumSize -= HOST_CHAR_BIT;
	  accum >>= HOST_CHAR_BIT;
	  ntarg -= 1;
	  targ += delta;
	}
      srcBitsLeft -= HOST_CHAR_BIT - unusedLS;
      unusedLS = 0;
      nsrc -= 1;
      src += delta;
    }
  while (ntarg > 0)
    {
      accum |= sign << accumSize;
      unpacked[targ] = accum & ~(~0L << HOST_CHAR_BIT);
      accumSize -= HOST_CHAR_BIT;
      accum >>= HOST_CHAR_BIT;
      ntarg -= 1;
      targ += delta;
    }

  return v;
}

/* Move N bits from SOURCE, starting at bit offset SRC_OFFSET to
   TARGET, starting at bit offset TARG_OFFSET.  SOURCE and TARGET must
   not overlap. */
static void
move_bits (char *target, int targ_offset, char *source, int src_offset, int n)
{
  unsigned int accum, mask;
  int accum_bits, chunk_size;

  target += targ_offset / HOST_CHAR_BIT;
  targ_offset %= HOST_CHAR_BIT;
  source += src_offset / HOST_CHAR_BIT;
  src_offset %= HOST_CHAR_BIT;
  if (BITS_BIG_ENDIAN)
    {
      accum = (unsigned char) *source;
      source += 1;
      accum_bits = HOST_CHAR_BIT - src_offset;

      while (n > 0)
	{
	  int unused_right;
	  accum = (accum << HOST_CHAR_BIT) + (unsigned char) *source;
	  accum_bits += HOST_CHAR_BIT;
	  source += 1;
	  chunk_size = HOST_CHAR_BIT - targ_offset;
	  if (chunk_size > n)
	    chunk_size = n;
	  unused_right = HOST_CHAR_BIT - (chunk_size + targ_offset);
	  mask = ((1 << chunk_size) - 1) << unused_right;
	  *target =
	    (*target & ~mask)
	    | ((accum >> (accum_bits - chunk_size - unused_right)) & mask);
	  n -= chunk_size;
	  accum_bits -= chunk_size;
	  target += 1;
	  targ_offset = 0;
	}
    }
  else
    {
      accum = (unsigned char) *source >> src_offset;
      source += 1;
      accum_bits = HOST_CHAR_BIT - src_offset;

      while (n > 0)
	{
	  accum = accum + ((unsigned char) *source << accum_bits);
	  accum_bits += HOST_CHAR_BIT;
	  source += 1;
	  chunk_size = HOST_CHAR_BIT - targ_offset;
	  if (chunk_size > n)
	    chunk_size = n;
	  mask = ((1 << chunk_size) - 1) << targ_offset;
	  *target = (*target & ~mask) | ((accum << targ_offset) & mask);
	  n -= chunk_size;
	  accum_bits -= chunk_size;
	  accum >>= chunk_size;
	  target += 1;
	  targ_offset = 0;
	}
    }
}


/* Store the contents of FROMVAL into the location of TOVAL.
   Return a new value with the location of TOVAL and contents of
   FROMVAL.   Handles assignment into packed fields that have
   floating-point or non-scalar types. */

static struct value *
ada_value_assign (struct value *toval, struct value *fromval)
{
  struct type *type = VALUE_TYPE (toval);
  int bits = VALUE_BITSIZE (toval);

  if (!toval->modifiable)
    error ("Left operand of assignment is not a modifiable lvalue.");

  COERCE_REF (toval);

  if (VALUE_LVAL (toval) == lval_memory
      && bits > 0
      && (TYPE_CODE (type) == TYPE_CODE_FLT
	  || TYPE_CODE (type) == TYPE_CODE_STRUCT))
    {
      int len =
	(VALUE_BITPOS (toval) + bits + HOST_CHAR_BIT - 1) / HOST_CHAR_BIT;
      char *buffer = (char *) alloca (len);
      struct value *val;

      if (TYPE_CODE (type) == TYPE_CODE_FLT)
	fromval = value_cast (type, fromval);

      read_memory (VALUE_ADDRESS (toval) + VALUE_OFFSET (toval), buffer, len);
      if (BITS_BIG_ENDIAN)
	move_bits (buffer, VALUE_BITPOS (toval),
		   VALUE_CONTENTS (fromval),
		   TYPE_LENGTH (VALUE_TYPE (fromval)) * TARGET_CHAR_BIT -
		   bits, bits);
      else
	move_bits (buffer, VALUE_BITPOS (toval), VALUE_CONTENTS (fromval),
		   0, bits);
      write_memory (VALUE_ADDRESS (toval) + VALUE_OFFSET (toval), buffer,
		    len);

      val = value_copy (toval);
      memcpy (VALUE_CONTENTS_RAW (val), VALUE_CONTENTS (fromval),
	      TYPE_LENGTH (type));
      VALUE_TYPE (val) = type;

      return val;
    }

  return value_assign (toval, fromval);
}


/* The value of the element of array ARR at the ARITY indices given in IND. 
   ARR may be either a simple array, GNAT array descriptor, or pointer 
   thereto.  */

struct value *
ada_value_subscript (struct value *arr, int arity, struct value **ind)
{
  int k;
  struct value *elt;
  struct type *elt_type;

  elt = ada_coerce_to_simple_array (arr);

  elt_type = check_typedef (VALUE_TYPE (elt));
  if (TYPE_CODE (elt_type) == TYPE_CODE_ARRAY
      && TYPE_FIELD_BITSIZE (elt_type, 0) > 0)
    return value_subscript_packed (elt, arity, ind);

  for (k = 0; k < arity; k += 1)
    {
      if (TYPE_CODE (elt_type) != TYPE_CODE_ARRAY)
	error ("too many subscripts (%d expected)", k);
      elt = value_subscript (elt, value_pos_atr (ind[k]));
    }
  return elt;
}

/* Assuming ARR is a pointer to a standard GDB array of type TYPE, the
   value of the element of *ARR at the ARITY indices given in
   IND. Does not read the entire array into memory. */

struct value *
ada_value_ptr_subscript (struct value *arr, struct type *type, int arity,
			 struct value **ind)
{
  int k;

  for (k = 0; k < arity; k += 1)
    {
      LONGEST lwb, upb;
      struct value *idx;

      if (TYPE_CODE (type) != TYPE_CODE_ARRAY)
	error ("too many subscripts (%d expected)", k);
      arr = value_cast (lookup_pointer_type (TYPE_TARGET_TYPE (type)),
			value_copy (arr));
      get_discrete_bounds (TYPE_INDEX_TYPE (type), &lwb, &upb);
      if (lwb == 0)
	idx = ind[k];
      else
	idx = value_sub (ind[k], value_from_longest (builtin_type_int, lwb));
      arr = value_add (arr, idx);
      type = TYPE_TARGET_TYPE (type);
    }

  return value_ind (arr);
}

/* If type is a record type in the form of a standard GNAT array
   descriptor, returns the number of dimensions for type.  If arr is a
   simple array, returns the number of "array of"s that prefix its
   type designation. Otherwise, returns 0. */

int
ada_array_arity (struct type *type)
{
  int arity;

  if (type == NULL)
    return 0;

  type = desc_base_type (type);

  arity = 0;
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)
    return desc_arity (desc_bounds_type (type));
  else
    while (TYPE_CODE (type) == TYPE_CODE_ARRAY)
      {
	arity += 1;
	type = check_typedef (TYPE_TARGET_TYPE (type));
      }

  return arity;
}

/* If TYPE is a record type in the form of a standard GNAT array
   descriptor or a simple array type, returns the element type for
   TYPE after indexing by NINDICES indices, or by all indices if
   NINDICES is -1. Otherwise, returns NULL. */

struct type *
ada_array_element_type (struct type *type, int nindices)
{
  type = desc_base_type (type);

  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)
    {
      int k;
      struct type *p_array_type;

      p_array_type = desc_data_type (type);

      k = ada_array_arity (type);
      if (k == 0)
	return NULL;

      /* Initially p_array_type = elt_type(*)[]...(k times)...[] */
      if (nindices >= 0 && k > nindices)
	k = nindices;
      p_array_type = TYPE_TARGET_TYPE (p_array_type);
      while (k > 0 && p_array_type != NULL)
	{
	  p_array_type = check_typedef (TYPE_TARGET_TYPE (p_array_type));
	  k -= 1;
	}
      return p_array_type;
    }
  else if (TYPE_CODE (type) == TYPE_CODE_ARRAY)
    {
      while (nindices != 0 && TYPE_CODE (type) == TYPE_CODE_ARRAY)
	{
	  type = TYPE_TARGET_TYPE (type);
	  nindices -= 1;
	}
      return type;
    }

  return NULL;
}

/* The type of nth index in arrays of given type (n numbering from 1).  Does 
   not examine memory. */

struct type *
ada_index_type (struct type *type, int n)
{
  type = desc_base_type (type);

  if (n > ada_array_arity (type))
    return NULL;

  if (ada_is_simple_array (type))
    {
      int i;

      for (i = 1; i < n; i += 1)
	type = TYPE_TARGET_TYPE (type);

      return TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, 0));
    }
  else
    return desc_index_type (desc_bounds_type (type), n);
}

/* Given that arr is an array type, returns the lower bound of the
   Nth index (numbering from 1) if WHICH is 0, and the upper bound if
   WHICH is 1. This returns bounds 0 .. -1 if ARR_TYPE is an
   array-descriptor type.  If TYPEP is non-null, *TYPEP is set to the 
   bounds type.  It works for other arrays with bounds supplied by 
   run-time quantities other than discriminants. */

LONGEST
ada_array_bound_from_type (struct type * arr_type, int n, int which,
			   struct type ** typep)
{
  struct type *type;
  struct type *index_type_desc;

  if (ada_is_packed_array_type (arr_type))
    arr_type = decode_packed_array_type (arr_type);

  if (arr_type == NULL || !ada_is_simple_array (arr_type))
    {
      if (typep != NULL)
	*typep = builtin_type_int;
      return (LONGEST) - which;
    }

  if (TYPE_CODE (arr_type) == TYPE_CODE_PTR)
    type = TYPE_TARGET_TYPE (arr_type);
  else
    type = arr_type;

  index_type_desc = ada_find_parallel_type (type, "___XA");
  if (index_type_desc == NULL)
    {
      struct type *range_type;
      struct type *index_type;

      while (n > 1)
	{
	  type = TYPE_TARGET_TYPE (type);
	  n -= 1;
	}

      range_type = TYPE_INDEX_TYPE (type);
      index_type = TYPE_TARGET_TYPE (range_type);
      if (TYPE_CODE (index_type) == TYPE_CODE_UNDEF)
	index_type = builtin_type_long;
      if (typep != NULL)
	*typep = index_type;
      return
	(LONGEST) (which == 0
		   ? TYPE_LOW_BOUND (range_type)
		   : TYPE_HIGH_BOUND (range_type));
    }
  else
    {
      struct type *index_type =
	to_fixed_range_type (TYPE_FIELD_NAME (index_type_desc, n - 1),
			     NULL, TYPE_OBJFILE (arr_type));
      if (typep != NULL)
	*typep = TYPE_TARGET_TYPE (index_type);
      return
	(LONGEST) (which == 0
		   ? TYPE_LOW_BOUND (index_type)
		   : TYPE_HIGH_BOUND (index_type));
    }
}

/* Given that arr is an array value, returns the lower bound of the
   nth index (numbering from 1) if which is 0, and the upper bound if
   which is 1. This routine will also work for arrays with bounds
   supplied by run-time quantities other than discriminants. */

struct value *
ada_array_bound (struct value *arr, int n, int which)
{
  struct type *arr_type = VALUE_TYPE (arr);

  if (ada_is_packed_array_type (arr_type))
    return ada_array_bound (decode_packed_array (arr), n, which);
  else if (ada_is_simple_array (arr_type))
    {
      struct type *type;
      LONGEST v = ada_array_bound_from_type (arr_type, n, which, &type);
      return value_from_longest (type, v);
    }
  else
    return desc_one_bound (desc_bounds (arr), n, which);
}

/* Given that arr is an array value, returns the length of the
   nth index.  This routine will also work for arrays with bounds
   supplied by run-time quantities other than discriminants. Does not
   work for arrays indexed by enumeration types with representation
   clauses at the moment. */

struct value *
ada_array_length (struct value *arr, int n)
{
  struct type *arr_type = check_typedef (VALUE_TYPE (arr));
  struct type *index_type_desc;

  if (ada_is_packed_array_type (arr_type))
    return ada_array_length (decode_packed_array (arr), n);

  if (ada_is_simple_array (arr_type))
    {
      struct type *type;
      LONGEST v =
	ada_array_bound_from_type (arr_type, n, 1, &type) -
	ada_array_bound_from_type (arr_type, n, 0, NULL) + 1;
      return value_from_longest (type, v);
    }
  else
    return
      value_from_longest (builtin_type_ada_int,
			  value_as_long (desc_one_bound (desc_bounds (arr),
							 n, 1))
			  - value_as_long (desc_one_bound (desc_bounds (arr),
							   n, 0)) + 1);
}


				/* Name resolution */

/* The "demangled" name for the user-definable Ada operator corresponding
   to op. */

static const char *
ada_op_name (enum exp_opcode op)
{
  int i;

  for (i = 0; ada_opname_table[i].mangled != NULL; i += 1)
    {
      if (ada_opname_table[i].op == op)
	return ada_opname_table[i].demangled;
    }
  error ("Could not find operator name for opcode");
}


/* Same as evaluate_type (*EXP), but resolves ambiguous symbol 
   references (OP_UNRESOLVED_VALUES) and converts operators that are 
   user-defined into appropriate function calls.  If CONTEXT_TYPE is 
   non-null, it provides a preferred result type [at the moment, only
   type void has any effect---causing procedures to be preferred over
   functions in calls].  A null CONTEXT_TYPE indicates that a non-void
   return type is preferred.  The variable unresolved_names contains a list
   of character strings referenced by expout that should be freed.  
   May change (expand) *EXP.  */

void
ada_resolve (struct expression **expp, struct type *context_type)
{
  int pc;
  pc = 0;
  ada_resolve_subexp (expp, &pc, 1, context_type);
}

/* Resolve the operator of the subexpression beginning at 
   position *POS of *EXPP. "Resolving" consists of replacing
   OP_UNRESOLVED_VALUE with an appropriate OP_VAR_VALUE, replacing
   built-in operators with function calls to user-defined operators,
   where appropriate, and (when DEPROCEDURE_P is non-zero), converting
   function-valued variables into parameterless calls.  May expand
   EXP. The CONTEXT_TYPE functions as in ada_resolve, above. */

static struct value *
ada_resolve_subexp (struct expression **expp, int *pos, int deprocedure_p,
		    struct type *context_type)
{
  int pc = *pos;
  int i;
  struct expression *exp;	/* Convenience: == *expp */
  enum exp_opcode op = (*expp)->elts[pc].opcode;
  struct value **argvec;	/* Vector of operand types (alloca'ed). */
  int nargs;			/* Number of operands */

  argvec = NULL;
  nargs = 0;
  exp = *expp;

  /* Pass one: resolve operands, saving their types and updating *pos. */
  switch (op)
    {
    case OP_VAR_VALUE:
      /*    case OP_UNRESOLVED_VALUE: */
      /* FIXME:  OP_UNRESOLVED_VALUE should be defined in expression.h */
      *pos += 4;
      break;

    case OP_FUNCALL:
      nargs = longest_to_int (exp->elts[pc + 1].longconst) + 1;
      /* FIXME:  OP_UNRESOLVED_VALUE should be defined in expression.h */
      /*      if (exp->elts[pc+3].opcode == OP_UNRESOLVED_VALUE)        
         {
         *pos += 7;

         argvec = (struct value* *) alloca (sizeof (struct value*) * (nargs + 1));
         for (i = 0; i < nargs-1; i += 1)
         argvec[i] = ada_resolve_subexp (expp, pos, 1, NULL);
         argvec[i] = NULL;
         }
         else
         {
         *pos += 3;
         ada_resolve_subexp (expp, pos, 0, NULL);
         for (i = 1; i < nargs; i += 1)
         ada_resolve_subexp (expp, pos, 1, NULL);
         }
       */
      exp = *expp;
      break;

      /* FIXME:  UNOP_QUAL should be defined in expression.h */
      /*    case UNOP_QUAL:
         nargs = 1;
         *pos += 3;
         ada_resolve_subexp (expp, pos, 1, exp->elts[pc + 1].type);
         exp = *expp;
         break;
       */
      /* FIXME:  OP_ATTRIBUTE should be defined in expression.h */
      /*    case OP_ATTRIBUTE:
         nargs = longest_to_int (exp->elts[pc + 1].longconst) + 1;
         *pos += 4;
         for (i = 0; i < nargs; i += 1)
         ada_resolve_subexp (expp, pos, 1, NULL);
         exp = *expp;
         break;
       */
    case UNOP_ADDR:
      nargs = 1;
      *pos += 1;
      ada_resolve_subexp (expp, pos, 0, NULL);
      exp = *expp;
      break;

    case BINOP_ASSIGN:
      {
	struct value *arg1;
	nargs = 2;
	*pos += 1;
	arg1 = ada_resolve_subexp (expp, pos, 0, NULL);
	if (arg1 == NULL)
	  ada_resolve_subexp (expp, pos, 1, NULL);
	else
	  ada_resolve_subexp (expp, pos, 1, VALUE_TYPE (arg1));
	break;
      }

    default:
      switch (op)
	{
	default:
	  error ("Unexpected operator during name resolution");
	case UNOP_CAST:
	  /*    case UNOP_MBR:
	     nargs = 1;
	     *pos += 3;
	     break;
	   */
	case BINOP_ADD:
	case BINOP_SUB:
	case BINOP_MUL:
	case BINOP_DIV:
	case BINOP_REM:
	case BINOP_MOD:
	case BINOP_EXP:
	case BINOP_CONCAT:
	case BINOP_LOGICAL_AND:
	case BINOP_LOGICAL_OR:
	case BINOP_BITWISE_AND:
	case BINOP_BITWISE_IOR:
	case BINOP_BITWISE_XOR:

	case BINOP_EQUAL:
	case BINOP_NOTEQUAL:
	case BINOP_LESS:
	case BINOP_GTR:
	case BINOP_LEQ:
	case BINOP_GEQ:

	case BINOP_REPEAT:
	case BINOP_SUBSCRIPT:
	case BINOP_COMMA:
	  nargs = 2;
	  *pos += 1;
	  break;

	case UNOP_NEG:
	case UNOP_PLUS:
	case UNOP_LOGICAL_NOT:
	case UNOP_ABS:
	case UNOP_IND:
	  nargs = 1;
	  *pos += 1;
	  break;

	case OP_LONG:
	case OP_DOUBLE:
	case OP_VAR_VALUE:
	  *pos += 4;
	  break;

	case OP_TYPE:
	case OP_BOOL:
	case OP_LAST:
	case OP_REGISTER:
	case OP_INTERNALVAR:
	  *pos += 3;
	  break;

	case UNOP_MEMVAL:
	  *pos += 3;
	  nargs = 1;
	  break;

	case STRUCTOP_STRUCT:
	case STRUCTOP_PTR:
	  nargs = 1;
	  *pos += 4 + BYTES_TO_EXP_ELEM (exp->elts[pc + 1].longconst + 1);
	  break;

	case OP_ARRAY:
	  *pos += 4;
	  nargs = longest_to_int (exp->elts[pc + 2].longconst) + 1;
	  nargs -= longest_to_int (exp->elts[pc + 1].longconst);
	  /* A null array contains one dummy element to give the type. */
	  /*      if (nargs == 0)
	     nargs = 1;
	     break; */

	case TERNOP_SLICE:
	  /* FIXME: TERNOP_MBR should be defined in expression.h */
	  /*    case TERNOP_MBR:
	     *pos += 1;
	     nargs = 3;
	     break;
	   */
	  /* FIXME: BINOP_MBR should be defined in expression.h */
	  /*    case BINOP_MBR:
	     *pos += 3;
	     nargs = 2;
	     break; */
	}

      argvec =
	(struct value * *) alloca (sizeof (struct value *) * (nargs + 1));
      for (i = 0; i < nargs; i += 1)
	argvec[i] = ada_resolve_subexp (expp, pos, 1, NULL);
      argvec[i] = NULL;
      exp = *expp;
      break;
    }

  /* Pass two: perform any resolution on principal operator. */
  switch (op)
    {
    default:
      break;

      /* FIXME:  OP_UNRESOLVED_VALUE should be defined in expression.h */
      /*    case OP_UNRESOLVED_VALUE:
         {
         struct symbol** candidate_syms;
         struct block** candidate_blocks;
         int n_candidates;

         n_candidates = ada_lookup_symbol_list (exp->elts[pc + 2].name,
         exp->elts[pc + 1].block,
         VAR_DOMAIN,
         &candidate_syms,
         &candidate_blocks);

         if (n_candidates > 1) 
         { */
      /* Types tend to get re-introduced locally, so if there
         are any local symbols that are not types, first filter
   out all types. *//*
   int j;
   for (j = 0; j < n_candidates; j += 1) 
   switch (SYMBOL_CLASS (candidate_syms[j])) 
   {
   case LOC_REGISTER:
   case LOC_ARG:
   case LOC_REF_ARG:
   case LOC_REGPARM:
   case LOC_REGPARM_ADDR:
   case LOC_LOCAL:
   case LOC_LOCAL_ARG:
   case LOC_BASEREG:
   case LOC_BASEREG_ARG:
   case LOC_COMPUTED:
   case LOC_COMPUTED_ARG:
   goto FoundNonType;
   default:
   break;
   }
   FoundNonType:
   if (j < n_candidates) 
   {
   j = 0;
   while (j < n_candidates) 
   {
   if (SYMBOL_CLASS (candidate_syms[j]) == LOC_TYPEDEF)
   {
   candidate_syms[j] = candidate_syms[n_candidates-1];
   candidate_blocks[j] = candidate_blocks[n_candidates-1];
   n_candidates -= 1;
   }
   else
   j += 1;
   }
   }
   }

   if (n_candidates == 0)
   error ("No definition found for %s", 
   ada_demangle (exp->elts[pc + 2].name));
   else if (n_candidates == 1)
   i = 0;
   else if (deprocedure_p 
   && ! is_nonfunction (candidate_syms, n_candidates))
   {
   i = ada_resolve_function (candidate_syms, candidate_blocks,
   n_candidates, NULL, 0,
   exp->elts[pc + 2].name, context_type);
   if (i < 0) 
   error ("Could not find a match for %s", 
   ada_demangle (exp->elts[pc + 2].name));
   }
   else 
   {
   printf_filtered ("Multiple matches for %s\n", 
   ada_demangle (exp->elts[pc+2].name));
   user_select_syms (candidate_syms, candidate_blocks, 
   n_candidates, 1);
   i = 0;
   }

   exp->elts[pc].opcode = exp->elts[pc + 3].opcode = OP_VAR_VALUE;
   exp->elts[pc + 1].block = candidate_blocks[i];
   exp->elts[pc + 2].symbol = candidate_syms[i];
   if (innermost_block == NULL ||
   contained_in (candidate_blocks[i], innermost_block))
   innermost_block = candidate_blocks[i];
   } */
      /* FALL THROUGH */

    case OP_VAR_VALUE:
      if (deprocedure_p &&
	  TYPE_CODE (SYMBOL_TYPE (exp->elts[pc + 2].symbol)) ==
	  TYPE_CODE_FUNC)
	{
	  replace_operator_with_call (expp, pc, 0, 0,
				      exp->elts[pc + 2].symbol,
				      exp->elts[pc + 1].block);
	  exp = *expp;
	}
      break;

    case OP_FUNCALL:
      {
	/* FIXME:  OP_UNRESOLVED_VALUE should be defined in expression.h */
	/*      if (exp->elts[pc+3].opcode == OP_UNRESOLVED_VALUE)      
	   {
	   struct symbol** candidate_syms;
	   struct block** candidate_blocks;
	   int n_candidates;

	   n_candidates = ada_lookup_symbol_list (exp->elts[pc + 5].name,
	   exp->elts[pc + 4].block,
	   VAR_DOMAIN,
	   &candidate_syms,
	   &candidate_blocks);
	   if (n_candidates == 1)
	   i = 0;
	   else
	   {
	   i = ada_resolve_function (candidate_syms, candidate_blocks,
	   n_candidates, argvec, nargs-1,
	   exp->elts[pc + 5].name, context_type);
	   if (i < 0) 
	   error ("Could not find a match for %s", 
	   ada_demangle (exp->elts[pc + 5].name));
	   }

	   exp->elts[pc + 3].opcode = exp->elts[pc + 6].opcode = OP_VAR_VALUE;
	   exp->elts[pc + 4].block = candidate_blocks[i];
	   exp->elts[pc + 5].symbol = candidate_syms[i];
	   if (innermost_block == NULL ||
	   contained_in (candidate_blocks[i], innermost_block))
	   innermost_block = candidate_blocks[i];
	   } */

      }
      break;
    case BINOP_ADD:
    case BINOP_SUB:
    case BINOP_MUL:
    case BINOP_DIV:
    case BINOP_REM:
    case BINOP_MOD:
    case BINOP_CONCAT:
    case BINOP_BITWISE_AND:
    case BINOP_BITWISE_IOR:
    case BINOP_BITWISE_XOR:
    case BINOP_EQUAL:
    case BINOP_NOTEQUAL:
    case BINOP_LESS:
    case BINOP_GTR:
    case BINOP_LEQ:
    case BINOP_GEQ:
    case BINOP_EXP:
    case UNOP_NEG:
    case UNOP_PLUS:
    case UNOP_LOGICAL_NOT:
    case UNOP_ABS:
      if (possible_user_operator_p (op, argvec))
	{
	  struct symbol **candidate_syms;
	  struct block **candidate_blocks;
	  int n_candidates;

	  n_candidates =
	    ada_lookup_symbol_list (ada_mangle (ada_op_name (op)),
				    (struct block *) NULL, VAR_DOMAIN,
				    &candidate_syms, &candidate_blocks);
	  i =
	    ada_resolve_function (candidate_syms, candidate_blocks,
				  n_candidates, argvec, nargs,
				  ada_op_name (op), NULL);
	  if (i < 0)
	    break;

	  replace_operator_with_call (expp, pc, nargs, 1,
				      candidate_syms[i], candidate_blocks[i]);
	  exp = *expp;
	}
      break;
    }

  *pos = pc;
  return evaluate_subexp_type (exp, pos);
}

/* Return non-zero if formal type FTYPE matches actual type ATYPE.  If
   MAY_DEREF is non-zero, the formal may be a pointer and the actual 
   a non-pointer. */
/* The term "match" here is rather loose.  The match is heuristic and
   liberal.  FIXME: TOO liberal, in fact. */

static int
ada_type_match (struct type *ftype, struct type *atype, int may_deref)
{
  CHECK_TYPEDEF (ftype);
  CHECK_TYPEDEF (atype);

  if (TYPE_CODE (ftype) == TYPE_CODE_REF)
    ftype = TYPE_TARGET_TYPE (ftype);
  if (TYPE_CODE (atype) == TYPE_CODE_REF)
    atype = TYPE_TARGET_TYPE (atype);

  if (TYPE_CODE (ftype) == TYPE_CODE_VOID
      || TYPE_CODE (atype) == TYPE_CODE_VOID)
    return 1;

  switch (TYPE_CODE (ftype))
    {
    default:
      return 1;
    case TYPE_CODE_PTR:
      if (TYPE_CODE (atype) == TYPE_CODE_PTR)
	return ada_type_match (TYPE_TARGET_TYPE (ftype),
			       TYPE_TARGET_TYPE (atype), 0);
      else
	return (may_deref &&
		ada_type_match (TYPE_TARGET_TYPE (ftype), atype, 0));
    case TYPE_CODE_INT:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_RANGE:
      switch (TYPE_CODE (atype))
	{
	case TYPE_CODE_INT:
	case TYPE_CODE_ENUM:
	case TYPE_CODE_RANGE:
	  return 1;
	default:
	  return 0;
	}

    case TYPE_CODE_ARRAY:
      return (TYPE_CODE (atype) == TYPE_CODE_ARRAY
	      || ada_is_array_descriptor (atype));

    case TYPE_CODE_STRUCT:
      if (ada_is_array_descriptor (ftype))
	return (TYPE_CODE (atype) == TYPE_CODE_ARRAY
		|| ada_is_array_descriptor (atype));
      else
	return (TYPE_CODE (atype) == TYPE_CODE_STRUCT
		&& !ada_is_array_descriptor (atype));

    case TYPE_CODE_UNION:
    case TYPE_CODE_FLT:
      return (TYPE_CODE (atype) == TYPE_CODE (ftype));
    }
}

/* Return non-zero if the formals of FUNC "sufficiently match" the
   vector of actual argument types ACTUALS of size N_ACTUALS.  FUNC
   may also be an enumeral, in which case it is treated as a 0-
   argument function. */

static int
ada_args_match (struct symbol *func, struct value **actuals, int n_actuals)
{
  int i;
  struct type *func_type = SYMBOL_TYPE (func);

  if (SYMBOL_CLASS (func) == LOC_CONST &&
      TYPE_CODE (func_type) == TYPE_CODE_ENUM)
    return (n_actuals == 0);
  else if (func_type == NULL || TYPE_CODE (func_type) != TYPE_CODE_FUNC)
    return 0;

  if (TYPE_NFIELDS (func_type) != n_actuals)
    return 0;

  for (i = 0; i < n_actuals; i += 1)
    {
      struct type *ftype = check_typedef (TYPE_FIELD_TYPE (func_type, i));
      struct type *atype = check_typedef (VALUE_TYPE (actuals[i]));

      if (!ada_type_match (TYPE_FIELD_TYPE (func_type, i),
			   VALUE_TYPE (actuals[i]), 1))
	return 0;
    }
  return 1;
}

/* False iff function type FUNC_TYPE definitely does not produce a value
   compatible with type CONTEXT_TYPE.  Conservatively returns 1 if
   FUNC_TYPE is not a valid function type with a non-null return type
   or an enumerated type.  A null CONTEXT_TYPE indicates any non-void type.  */

static int
return_match (struct type *func_type, struct type *context_type)
{
  struct type *return_type;

  if (func_type == NULL)
    return 1;

  /* FIXME: base_type should be declared in gdbtypes.h, implemented in valarith.c */
  /*  if (TYPE_CODE (func_type) == TYPE_CODE_FUNC)
     return_type = base_type (TYPE_TARGET_TYPE (func_type));
     else 
     return_type = base_type (func_type); */
  if (return_type == NULL)
    return 1;

  /* FIXME: base_type should be declared in gdbtypes.h, implemented in valarith.c */
  /*  context_type = base_type (context_type); */

  if (TYPE_CODE (return_type) == TYPE_CODE_ENUM)
    return context_type == NULL || return_type == context_type;
  else if (context_type == NULL)
    return TYPE_CODE (return_type) != TYPE_CODE_VOID;
  else
    return TYPE_CODE (return_type) == TYPE_CODE (context_type);
}


/* Return the index in SYMS[0..NSYMS-1] of symbol for the 
   function (if any) that matches the types of the NARGS arguments in
   ARGS.  If CONTEXT_TYPE is non-null, and there is at least one match
   that returns type CONTEXT_TYPE, then eliminate other matches.  If
   CONTEXT_TYPE is null, prefer a non-void-returning function.
   Asks the user if there is more than one match remaining.  Returns -1
   if there is no such symbol or none is selected.  NAME is used
   solely for messages.   May re-arrange and modify SYMS in
   the process; the index returned is for the modified vector.  BLOCKS
   is modified in parallel to SYMS. */

int
ada_resolve_function (struct symbol *syms[], struct block *blocks[],
		      int nsyms, struct value **args, int nargs,
		      const char *name, struct type *context_type)
{
  int k;
  int m;			/* Number of hits */
  struct type *fallback;
  struct type *return_type;

  return_type = context_type;
  if (context_type == NULL)
    fallback = builtin_type_void;
  else
    fallback = NULL;

  m = 0;
  while (1)
    {
      for (k = 0; k < nsyms; k += 1)
	{
	  struct type *type = check_typedef (SYMBOL_TYPE (syms[k]));

	  if (ada_args_match (syms[k], args, nargs)
	      && return_match (SYMBOL_TYPE (syms[k]), return_type))
	    {
	      syms[m] = syms[k];
	      if (blocks != NULL)
		blocks[m] = blocks[k];
	      m += 1;
	    }
	}
      if (m > 0 || return_type == fallback)
	break;
      else
	return_type = fallback;
    }

  if (m == 0)
    return -1;
  else if (m > 1)
    {
      printf_filtered ("Multiple matches for %s\n", name);
      user_select_syms (syms, blocks, m, 1);
      return 0;
    }
  return 0;
}

/* Returns true (non-zero) iff demangled name N0 should appear before N1 */
/* in a listing of choices during disambiguation (see sort_choices, below). */
/* The idea is that overloadings of a subprogram name from the */
/* same package should sort in their source order.  We settle for ordering */
/* such symbols by their trailing number (__N  or $N). */
static int
mangled_ordered_before (char *N0, char *N1)
{
  if (N1 == NULL)
    return 0;
  else if (N0 == NULL)
    return 1;
  else
    {
      int k0, k1;
      for (k0 = strlen (N0) - 1; k0 > 0 && isdigit (N0[k0]); k0 -= 1)
	;
      for (k1 = strlen (N1) - 1; k1 > 0 && isdigit (N1[k1]); k1 -= 1)
	;
      if ((N0[k0] == '_' || N0[k0] == '$') && N0[k0 + 1] != '\000'
	  && (N1[k1] == '_' || N1[k1] == '$') && N1[k1 + 1] != '\000')
	{
	  int n0, n1;
	  n0 = k0;
	  while (N0[n0] == '_' && n0 > 0 && N0[n0 - 1] == '_')
	    n0 -= 1;
	  n1 = k1;
	  while (N1[n1] == '_' && n1 > 0 && N1[n1 - 1] == '_')
	    n1 -= 1;
	  if (n0 == n1 && DEPRECATED_STREQN (N0, N1, n0))
	    return (atoi (N0 + k0 + 1) < atoi (N1 + k1 + 1));
	}
      return (strcmp (N0, N1) < 0);
    }
}

/* Sort SYMS[0..NSYMS-1] to put the choices in a canonical order by their */
/* mangled names, rearranging BLOCKS[0..NSYMS-1] according to the same */
/* permutation. */
static void
sort_choices (struct symbol *syms[], struct block *blocks[], int nsyms)
{
  int i, j;
  for (i = 1; i < nsyms; i += 1)
    {
      struct symbol *sym = syms[i];
      struct block *block = blocks[i];
      int j;

      for (j = i - 1; j >= 0; j -= 1)
	{
	  if (mangled_ordered_before (DEPRECATED_SYMBOL_NAME (syms[j]),
				      DEPRECATED_SYMBOL_NAME (sym)))
	    break;
	  syms[j + 1] = syms[j];
	  blocks[j + 1] = blocks[j];
	}
      syms[j + 1] = sym;
      blocks[j + 1] = block;
    }
}

/* Given a list of NSYMS symbols in SYMS and corresponding blocks in */
/* BLOCKS, select up to MAX_RESULTS>0 by asking the user (if */
/* necessary), returning the number selected, and setting the first */
/* elements of SYMS and BLOCKS to the selected symbols and */
/* corresponding blocks.  Error if no symbols selected.   BLOCKS may */
/* be NULL, in which case it is ignored. */

/* NOTE: Adapted from decode_line_2 in symtab.c, with which it ought
   to be re-integrated one of these days. */

int
user_select_syms (struct symbol *syms[], struct block *blocks[], int nsyms,
		  int max_results)
{
  int i;
  int *chosen = (int *) alloca (sizeof (int) * nsyms);
  int n_chosen;
  int first_choice = (max_results == 1) ? 1 : 2;

  if (max_results < 1)
    error ("Request to select 0 symbols!");
  if (nsyms <= 1)
    return nsyms;

  printf_unfiltered ("[0] cancel\n");
  if (max_results > 1)
    printf_unfiltered ("[1] all\n");

  sort_choices (syms, blocks, nsyms);

  for (i = 0; i < nsyms; i += 1)
    {
      if (syms[i] == NULL)
	continue;

      if (SYMBOL_CLASS (syms[i]) == LOC_BLOCK)
	{
	  struct symtab_and_line sal = find_function_start_sal (syms[i], 1);
	  printf_unfiltered ("[%d] %s at %s:%d\n",
			     i + first_choice,
			     SYMBOL_PRINT_NAME (syms[i]),
			     sal.symtab == NULL
			     ? "<no source file available>"
			     : sal.symtab->filename, sal.line);
	  continue;
	}
      else
	{
	  int is_enumeral =
	    (SYMBOL_CLASS (syms[i]) == LOC_CONST
	     && SYMBOL_TYPE (syms[i]) != NULL
	     && TYPE_CODE (SYMBOL_TYPE (syms[i])) == TYPE_CODE_ENUM);
	  struct symtab *symtab = symtab_for_sym (syms[i]);

	  if (SYMBOL_LINE (syms[i]) != 0 && symtab != NULL)
	    printf_unfiltered ("[%d] %s at %s:%d\n",
			       i + first_choice,
			       SYMBOL_PRINT_NAME (syms[i]),
			       symtab->filename, SYMBOL_LINE (syms[i]));
	  else if (is_enumeral && TYPE_NAME (SYMBOL_TYPE (syms[i])) != NULL)
	    {
	      printf_unfiltered ("[%d] ", i + first_choice);
	      ada_print_type (SYMBOL_TYPE (syms[i]), NULL, gdb_stdout, -1, 0);
	      printf_unfiltered ("'(%s) (enumeral)\n",
				 SYMBOL_PRINT_NAME (syms[i]));
	    }
	  else if (symtab != NULL)
	    printf_unfiltered (is_enumeral
			       ? "[%d] %s in %s (enumeral)\n"
			       : "[%d] %s at %s:?\n",
			       i + first_choice,
			       SYMBOL_PRINT_NAME (syms[i]),
			       symtab->filename);
	  else
	    printf_unfiltered (is_enumeral
			       ? "[%d] %s (enumeral)\n"
			       : "[%d] %s at ?\n",
			       i + first_choice,
			       SYMBOL_PRINT_NAME (syms[i]));
	}
    }

  n_chosen = get_selections (chosen, nsyms, max_results, max_results > 1,
			     "overload-choice");

  for (i = 0; i < n_chosen; i += 1)
    {
      syms[i] = syms[chosen[i]];
      if (blocks != NULL)
	blocks[i] = blocks[chosen[i]];
    }

  return n_chosen;
}

/* Read and validate a set of numeric choices from the user in the
   range 0 .. N_CHOICES-1. Place the results in increasing
   order in CHOICES[0 .. N-1], and return N.

   The user types choices as a sequence of numbers on one line
   separated by blanks, encoding them as follows:

     + A choice of 0 means to cancel the selection, throwing an error.  
     + If IS_ALL_CHOICE, a choice of 1 selects the entire set 0 .. N_CHOICES-1.
     + The user chooses k by typing k+IS_ALL_CHOICE+1.

   The user is not allowed to choose more than MAX_RESULTS values. 

   ANNOTATION_SUFFIX, if present, is used to annotate the input
   prompts (for use with the -f switch). */

int
get_selections (int *choices, int n_choices, int max_results,
		int is_all_choice, char *annotation_suffix)
{
  int i;
  char *args;
  const char *prompt;
  int n_chosen;
  int first_choice = is_all_choice ? 2 : 1;

  prompt = getenv ("PS2");
  if (prompt == NULL)
    prompt = ">";

  printf_unfiltered ("%s ", prompt);
  gdb_flush (gdb_stdout);

  args = command_line_input ((char *) NULL, 0, annotation_suffix);

  if (args == NULL)
    error_no_arg ("one or more choice numbers");

  n_chosen = 0;

  /* Set choices[0 .. n_chosen-1] to the users' choices in ascending 
     order, as given in args.   Choices are validated. */
  while (1)
    {
      char *args2;
      int choice, j;

      while (isspace (*args))
	args += 1;
      if (*args == '\0' && n_chosen == 0)
	error_no_arg ("one or more choice numbers");
      else if (*args == '\0')
	break;

      choice = strtol (args, &args2, 10);
      if (args == args2 || choice < 0
	  || choice > n_choices + first_choice - 1)
	error ("Argument must be choice number");
      args = args2;

      if (choice == 0)
	error ("cancelled");

      if (choice < first_choice)
	{
	  n_chosen = n_choices;
	  for (j = 0; j < n_choices; j += 1)
	    choices[j] = j;
	  break;
	}
      choice -= first_choice;

      for (j = n_chosen - 1; j >= 0 && choice < choices[j]; j -= 1)
	{
	}

      if (j < 0 || choice != choices[j])
	{
	  int k;
	  for (k = n_chosen - 1; k > j; k -= 1)
	    choices[k + 1] = choices[k];
	  choices[j + 1] = choice;
	  n_chosen += 1;
	}
    }

  if (n_chosen > max_results)
    error ("Select no more than %d of the above", max_results);

  return n_chosen;
}

/* Replace the operator of length OPLEN at position PC in *EXPP with a call */
/* on the function identified by SYM and BLOCK, and taking NARGS */
/* arguments.  Update *EXPP as needed to hold more space. */

static void
replace_operator_with_call (struct expression **expp, int pc, int nargs,
			    int oplen, struct symbol *sym,
			    struct block *block)
{
  /* A new expression, with 6 more elements (3 for funcall, 4 for function
     symbol, -oplen for operator being replaced). */
  struct expression *newexp = (struct expression *)
    xmalloc (sizeof (struct expression)
	     + EXP_ELEM_TO_BYTES ((*expp)->nelts + 7 - oplen));
  struct expression *exp = *expp;

  newexp->nelts = exp->nelts + 7 - oplen;
  newexp->language_defn = exp->language_defn;
  memcpy (newexp->elts, exp->elts, EXP_ELEM_TO_BYTES (pc));
  memcpy (newexp->elts + pc + 7, exp->elts + pc + oplen,
	  EXP_ELEM_TO_BYTES (exp->nelts - pc - oplen));

  newexp->elts[pc].opcode = newexp->elts[pc + 2].opcode = OP_FUNCALL;
  newexp->elts[pc + 1].longconst = (LONGEST) nargs;

  newexp->elts[pc + 3].opcode = newexp->elts[pc + 6].opcode = OP_VAR_VALUE;
  newexp->elts[pc + 4].block = block;
  newexp->elts[pc + 5].symbol = sym;

  *expp = newexp;
  xfree (exp);
}

/* Type-class predicates */

/* True iff TYPE is numeric (i.e., an INT, RANGE (of numeric type), or */
/* FLOAT.) */

static int
numeric_type_p (struct type *type)
{
  if (type == NULL)
    return 0;
  else
    {
      switch (TYPE_CODE (type))
	{
	case TYPE_CODE_INT:
	case TYPE_CODE_FLT:
	  return 1;
	case TYPE_CODE_RANGE:
	  return (type == TYPE_TARGET_TYPE (type)
		  || numeric_type_p (TYPE_TARGET_TYPE (type)));
	default:
	  return 0;
	}
    }
}

/* True iff TYPE is integral (an INT or RANGE of INTs). */

static int
integer_type_p (struct type *type)
{
  if (type == NULL)
    return 0;
  else
    {
      switch (TYPE_CODE (type))
	{
	case TYPE_CODE_INT:
	  return 1;
	case TYPE_CODE_RANGE:
	  return (type == TYPE_TARGET_TYPE (type)
		  || integer_type_p (TYPE_TARGET_TYPE (type)));
	default:
	  return 0;
	}
    }
}

/* True iff TYPE is scalar (INT, RANGE, FLOAT, ENUM). */

static int
scalar_type_p (struct type *type)
{
  if (type == NULL)
    return 0;
  else
    {
      switch (TYPE_CODE (type))
	{
	case TYPE_CODE_INT:
	case TYPE_CODE_RANGE:
	case TYPE_CODE_ENUM:
	case TYPE_CODE_FLT:
	  return 1;
	default:
	  return 0;
	}
    }
}

/* True iff TYPE is discrete (INT, RANGE, ENUM). */

static int
discrete_type_p (struct type *type)
{
  if (type == NULL)
    return 0;
  else
    {
      switch (TYPE_CODE (type))
	{
	case TYPE_CODE_INT:
	case TYPE_CODE_RANGE:
	case TYPE_CODE_ENUM:
	  return 1;
	default:
	  return 0;
	}
    }
}

/* Returns non-zero if OP with operatands in the vector ARGS could be
   a user-defined function. Errs on the side of pre-defined operators
   (i.e., result 0). */

static int
possible_user_operator_p (enum exp_opcode op, struct value *args[])
{
  struct type *type0 = check_typedef (VALUE_TYPE (args[0]));
  struct type *type1 =
    (args[1] == NULL) ? NULL : check_typedef (VALUE_TYPE (args[1]));

  switch (op)
    {
    default:
      return 0;

    case BINOP_ADD:
    case BINOP_SUB:
    case BINOP_MUL:
    case BINOP_DIV:
      return (!(numeric_type_p (type0) && numeric_type_p (type1)));

    case BINOP_REM:
    case BINOP_MOD:
    case BINOP_BITWISE_AND:
    case BINOP_BITWISE_IOR:
    case BINOP_BITWISE_XOR:
      return (!(integer_type_p (type0) && integer_type_p (type1)));

    case BINOP_EQUAL:
    case BINOP_NOTEQUAL:
    case BINOP_LESS:
    case BINOP_GTR:
    case BINOP_LEQ:
    case BINOP_GEQ:
      return (!(scalar_type_p (type0) && scalar_type_p (type1)));

    case BINOP_CONCAT:
      return ((TYPE_CODE (type0) != TYPE_CODE_ARRAY &&
	       (TYPE_CODE (type0) != TYPE_CODE_PTR ||
		TYPE_CODE (TYPE_TARGET_TYPE (type0))
		!= TYPE_CODE_ARRAY))
	      || (TYPE_CODE (type1) != TYPE_CODE_ARRAY &&
		  (TYPE_CODE (type1) != TYPE_CODE_PTR ||
		   TYPE_CODE (TYPE_TARGET_TYPE (type1)) != TYPE_CODE_ARRAY)));

    case BINOP_EXP:
      return (!(numeric_type_p (type0) && integer_type_p (type1)));

    case UNOP_NEG:
    case UNOP_PLUS:
    case UNOP_LOGICAL_NOT:
    case UNOP_ABS:
      return (!numeric_type_p (type0));

    }
}

				/* Renaming */

/** NOTE: In the following, we assume that a renaming type's name may
 *  have an ___XD suffix.  It would be nice if this went away at some
 *  point. */

/* If TYPE encodes a renaming, returns the renaming suffix, which
 * is XR for an object renaming, XRP for a procedure renaming, XRE for
 * an exception renaming, and XRS for a subprogram renaming.  Returns
 * NULL if NAME encodes none of these. */
const char *
ada_renaming_type (struct type *type)
{
  if (type != NULL && TYPE_CODE (type) == TYPE_CODE_ENUM)
    {
      const char *name = type_name_no_tag (type);
      const char *suffix = (name == NULL) ? NULL : strstr (name, "___XR");
      if (suffix == NULL
	  || (suffix[5] != '\000' && strchr ("PES_", suffix[5]) == NULL))
	return NULL;
      else
	return suffix + 3;
    }
  else
    return NULL;
}

/* Return non-zero iff SYM encodes an object renaming. */
int
ada_is_object_renaming (struct symbol *sym)
{
  const char *renaming_type = ada_renaming_type (SYMBOL_TYPE (sym));
  return renaming_type != NULL
    && (renaming_type[2] == '\0' || renaming_type[2] == '_');
}

/* Assuming that SYM encodes a non-object renaming, returns the original
 * name of the renamed entity.   The name is good until the end of
 * parsing. */
const char *
ada_simple_renamed_entity (struct symbol *sym)
{
  struct type *type;
  const char *raw_name;
  int len;
  char *result;

  type = SYMBOL_TYPE (sym);
  if (type == NULL || TYPE_NFIELDS (type) < 1)
    error ("Improperly encoded renaming.");

  raw_name = TYPE_FIELD_NAME (type, 0);
  len = (raw_name == NULL ? 0 : strlen (raw_name)) - 5;
  if (len <= 0)
    error ("Improperly encoded renaming.");

  result = xmalloc (len + 1);
  /* FIXME: add_name_string_cleanup should be defined in parse.c */
  /*  add_name_string_cleanup (result); */
  strncpy (result, raw_name, len);
  result[len] = '\000';
  return result;
}


				/* Evaluation: Function Calls */

/* Copy VAL onto the stack, using and updating *SP as the stack 
   pointer. Return VAL as an lvalue. */

static struct value *
place_on_stack (struct value *val, CORE_ADDR *sp)
{
  CORE_ADDR old_sp = *sp;

#ifdef DEPRECATED_STACK_ALIGN
  *sp = push_bytes (*sp, VALUE_CONTENTS_RAW (val),
		    DEPRECATED_STACK_ALIGN (TYPE_LENGTH
				 (check_typedef (VALUE_TYPE (val)))));
#else
  *sp = push_bytes (*sp, VALUE_CONTENTS_RAW (val),
		    TYPE_LENGTH (check_typedef (VALUE_TYPE (val))));
#endif

  VALUE_LVAL (val) = lval_memory;
  if (INNER_THAN (1, 2))
    VALUE_ADDRESS (val) = *sp;
  else
    VALUE_ADDRESS (val) = old_sp;

  return val;
}

/* Return the value ACTUAL, converted to be an appropriate value for a
   formal of type FORMAL_TYPE.  Use *SP as a stack pointer for
   allocating any necessary descriptors (fat pointers), or copies of
   values not residing in memory, updating it as needed. */

static struct value *
convert_actual (struct value *actual, struct type *formal_type0,
		CORE_ADDR *sp)
{
  struct type *actual_type = check_typedef (VALUE_TYPE (actual));
  struct type *formal_type = check_typedef (formal_type0);
  struct type *formal_target =
    TYPE_CODE (formal_type) == TYPE_CODE_PTR
    ? check_typedef (TYPE_TARGET_TYPE (formal_type)) : formal_type;
  struct type *actual_target =
    TYPE_CODE (actual_type) == TYPE_CODE_PTR
    ? check_typedef (TYPE_TARGET_TYPE (actual_type)) : actual_type;

  if (ada_is_array_descriptor (formal_target)
      && TYPE_CODE (actual_target) == TYPE_CODE_ARRAY)
    return make_array_descriptor (formal_type, actual, sp);
  else if (TYPE_CODE (formal_type) == TYPE_CODE_PTR)
    {
      if (TYPE_CODE (formal_target) == TYPE_CODE_ARRAY
	  && ada_is_array_descriptor (actual_target))
	return desc_data (actual);
      else if (TYPE_CODE (actual_type) != TYPE_CODE_PTR)
	{
	  if (VALUE_LVAL (actual) != lval_memory)
	    {
	      struct value *val;
	      actual_type = check_typedef (VALUE_TYPE (actual));
	      val = allocate_value (actual_type);
	      memcpy ((char *) VALUE_CONTENTS_RAW (val),
		      (char *) VALUE_CONTENTS (actual),
		      TYPE_LENGTH (actual_type));
	      actual = place_on_stack (val, sp);
	    }
	  return value_addr (actual);
	}
    }
  else if (TYPE_CODE (actual_type) == TYPE_CODE_PTR)
    return ada_value_ind (actual);

  return actual;
}


/* Push a descriptor of type TYPE for array value ARR on the stack at 
   *SP, updating *SP to reflect the new descriptor.  Return either 
   an lvalue representing the new descriptor, or (if TYPE is a pointer-
   to-descriptor type rather than a descriptor type), a struct value*
   representing a pointer to this descriptor. */

static struct value *
make_array_descriptor (struct type *type, struct value *arr, CORE_ADDR *sp)
{
  struct type *bounds_type = desc_bounds_type (type);
  struct type *desc_type = desc_base_type (type);
  struct value *descriptor = allocate_value (desc_type);
  struct value *bounds = allocate_value (bounds_type);
  CORE_ADDR bounds_addr;
  int i;

  for (i = ada_array_arity (check_typedef (VALUE_TYPE (arr))); i > 0; i -= 1)
    {
      modify_general_field (VALUE_CONTENTS (bounds),
			    value_as_long (ada_array_bound (arr, i, 0)),
			    desc_bound_bitpos (bounds_type, i, 0),
			    desc_bound_bitsize (bounds_type, i, 0));
      modify_general_field (VALUE_CONTENTS (bounds),
			    value_as_long (ada_array_bound (arr, i, 1)),
			    desc_bound_bitpos (bounds_type, i, 1),
			    desc_bound_bitsize (bounds_type, i, 1));
    }

  bounds = place_on_stack (bounds, sp);

  modify_general_field (VALUE_CONTENTS (descriptor),
			arr,
			fat_pntr_data_bitpos (desc_type),
			fat_pntr_data_bitsize (desc_type));
  modify_general_field (VALUE_CONTENTS (descriptor),
			VALUE_ADDRESS (bounds),
			fat_pntr_bounds_bitpos (desc_type),
			fat_pntr_bounds_bitsize (desc_type));

  descriptor = place_on_stack (descriptor, sp);

  if (TYPE_CODE (type) == TYPE_CODE_PTR)
    return value_addr (descriptor);
  else
    return descriptor;
}


/* Assuming a dummy frame has been established on the target, perform any 
   conversions needed for calling function FUNC on the NARGS actual
   parameters in ARGS, other than standard C conversions.   Does
   nothing if FUNC does not have Ada-style prototype data, or if NARGS
   does not match the number of arguments expected.   Use *SP as a
   stack pointer for additional data that must be pushed, updating its
   value as needed. */

void
ada_convert_actuals (struct value *func, int nargs, struct value *args[],
		     CORE_ADDR *sp)
{
  int i;

  if (TYPE_NFIELDS (VALUE_TYPE (func)) == 0
      || nargs != TYPE_NFIELDS (VALUE_TYPE (func)))
    return;

  for (i = 0; i < nargs; i += 1)
    args[i] =
      convert_actual (args[i], TYPE_FIELD_TYPE (VALUE_TYPE (func), i), sp);
}


				/* Symbol Lookup */


/* The vectors of symbols and blocks ultimately returned from */
/* ada_lookup_symbol_list. */

/* Current size of defn_symbols and defn_blocks */
static size_t defn_vector_size = 0;

/* Current number of symbols found. */
static int ndefns = 0;

static struct symbol **defn_symbols = NULL;
static struct block **defn_blocks = NULL;

/* Return the result of a standard (literal, C-like) lookup of NAME in 
 * given DOMAIN. */

static struct symbol *
standard_lookup (const char *name, domain_enum domain)
{
  struct symbol *sym;
  sym = lookup_symbol (name, (struct block *) NULL, domain, 0, NULL);
  return sym;
}


/* Non-zero iff there is at least one non-function/non-enumeral symbol */
/* in SYMS[0..N-1].  We treat enumerals as functions, since they */
/* contend in overloading in the same way. */
static int
is_nonfunction (struct symbol *syms[], int n)
{
  int i;

  for (i = 0; i < n; i += 1)
    if (TYPE_CODE (SYMBOL_TYPE (syms[i])) != TYPE_CODE_FUNC
	&& TYPE_CODE (SYMBOL_TYPE (syms[i])) != TYPE_CODE_ENUM)
      return 1;

  return 0;
}

/* If true (non-zero), then TYPE0 and TYPE1 represent equivalent
   struct types.  Otherwise, they may not. */

static int
equiv_types (struct type *type0, struct type *type1)
{
  if (type0 == type1)
    return 1;
  if (type0 == NULL || type1 == NULL
      || TYPE_CODE (type0) != TYPE_CODE (type1))
    return 0;
  if ((TYPE_CODE (type0) == TYPE_CODE_STRUCT
       || TYPE_CODE (type0) == TYPE_CODE_ENUM)
      && ada_type_name (type0) != NULL && ada_type_name (type1) != NULL
      && DEPRECATED_STREQ (ada_type_name (type0), ada_type_name (type1)))
    return 1;

  return 0;
}

/* True iff SYM0 represents the same entity as SYM1, or one that is
   no more defined than that of SYM1. */

static int
lesseq_defined_than (struct symbol *sym0, struct symbol *sym1)
{
  if (sym0 == sym1)
    return 1;
  if (SYMBOL_DOMAIN (sym0) != SYMBOL_DOMAIN (sym1)
      || SYMBOL_CLASS (sym0) != SYMBOL_CLASS (sym1))
    return 0;

  switch (SYMBOL_CLASS (sym0))
    {
    case LOC_UNDEF:
      return 1;
    case LOC_TYPEDEF:
      {
	struct type *type0 = SYMBOL_TYPE (sym0);
	struct type *type1 = SYMBOL_TYPE (sym1);
	char *name0 = DEPRECATED_SYMBOL_NAME (sym0);
	char *name1 = DEPRECATED_SYMBOL_NAME (sym1);
	int len0 = strlen (name0);
	return
	  TYPE_CODE (type0) == TYPE_CODE (type1)
	  && (equiv_types (type0, type1)
	      || (len0 < strlen (name1) && DEPRECATED_STREQN (name0, name1, len0)
		  && DEPRECATED_STREQN (name1 + len0, "___XV", 5)));
      }
    case LOC_CONST:
      return SYMBOL_VALUE (sym0) == SYMBOL_VALUE (sym1)
	&& equiv_types (SYMBOL_TYPE (sym0), SYMBOL_TYPE (sym1));
    default:
      return 0;
    }
}

/* Append SYM to the end of defn_symbols, and BLOCK to the end of
   defn_blocks, updating ndefns, and expanding defn_symbols and
   defn_blocks as needed.   Do not include SYM if it is a duplicate.  */

static void
add_defn_to_vec (struct symbol *sym, struct block *block)
{
  int i;
  size_t tmp;

  if (SYMBOL_TYPE (sym) != NULL)
    CHECK_TYPEDEF (SYMBOL_TYPE (sym));
  for (i = 0; i < ndefns; i += 1)
    {
      if (lesseq_defined_than (sym, defn_symbols[i]))
	return;
      else if (lesseq_defined_than (defn_symbols[i], sym))
	{
	  defn_symbols[i] = sym;
	  defn_blocks[i] = block;
	  return;
	}
    }

  tmp = defn_vector_size;
  GROW_VECT (defn_symbols, tmp, ndefns + 2);
  GROW_VECT (defn_blocks, defn_vector_size, ndefns + 2);

  defn_symbols[ndefns] = sym;
  defn_blocks[ndefns] = block;
  ndefns += 1;
}

/* Look, in partial_symtab PST, for symbol NAME in given domain.
   Check the global symbols if GLOBAL, the static symbols if not.  Do
   wild-card match if WILD. */

static struct partial_symbol *
ada_lookup_partial_symbol (struct partial_symtab *pst, const char *name,
			   int global, domain_enum domain, int wild)
{
  struct partial_symbol **start;
  int name_len = strlen (name);
  int length = (global ? pst->n_global_syms : pst->n_static_syms);
  int i;

  if (length == 0)
    {
      return (NULL);
    }

  start = (global ?
	   pst->objfile->global_psymbols.list + pst->globals_offset :
	   pst->objfile->static_psymbols.list + pst->statics_offset);

  if (wild)
    {
      for (i = 0; i < length; i += 1)
	{
	  struct partial_symbol *psym = start[i];

	  if (SYMBOL_DOMAIN (psym) == domain &&
	      wild_match (name, name_len, DEPRECATED_SYMBOL_NAME (psym)))
	    return psym;
	}
      return NULL;
    }
  else
    {
      if (global)
	{
	  int U;
	  i = 0;
	  U = length - 1;
	  while (U - i > 4)
	    {
	      int M = (U + i) >> 1;
	      struct partial_symbol *psym = start[M];
	      if (DEPRECATED_SYMBOL_NAME (psym)[0] < name[0])
		i = M + 1;
	      else if (DEPRECATED_SYMBOL_NAME (psym)[0] > name[0])
		U = M - 1;
	      else if (strcmp (DEPRECATED_SYMBOL_NAME (psym), name) < 0)
		i = M + 1;
	      else
		U = M;
	    }
	}
      else
	i = 0;

      while (i < length)
	{
	  struct partial_symbol *psym = start[i];

	  if (SYMBOL_DOMAIN (psym) == domain)
	    {
	      int cmp = strncmp (name, DEPRECATED_SYMBOL_NAME (psym), name_len);

	      if (cmp < 0)
		{
		  if (global)
		    break;
		}
	      else if (cmp == 0
		       && is_name_suffix (DEPRECATED_SYMBOL_NAME (psym) + name_len))
		return psym;
	    }
	  i += 1;
	}

      if (global)
	{
	  int U;
	  i = 0;
	  U = length - 1;
	  while (U - i > 4)
	    {
	      int M = (U + i) >> 1;
	      struct partial_symbol *psym = start[M];
	      if (DEPRECATED_SYMBOL_NAME (psym)[0] < '_')
		i = M + 1;
	      else if (DEPRECATED_SYMBOL_NAME (psym)[0] > '_')
		U = M - 1;
	      else if (strcmp (DEPRECATED_SYMBOL_NAME (psym), "_ada_") < 0)
		i = M + 1;
	      else
		U = M;
	    }
	}
      else
	i = 0;

      while (i < length)
	{
	  struct partial_symbol *psym = start[i];

	  if (SYMBOL_DOMAIN (psym) == domain)
	    {
	      int cmp;

	      cmp = (int) '_' - (int) DEPRECATED_SYMBOL_NAME (psym)[0];
	      if (cmp == 0)
		{
		  cmp = strncmp ("_ada_", DEPRECATED_SYMBOL_NAME (psym), 5);
		  if (cmp == 0)
		    cmp = strncmp (name, DEPRECATED_SYMBOL_NAME (psym) + 5, name_len);
		}

	      if (cmp < 0)
		{
		  if (global)
		    break;
		}
	      else if (cmp == 0
		       && is_name_suffix (DEPRECATED_SYMBOL_NAME (psym) + name_len + 5))
		return psym;
	    }
	  i += 1;
	}

    }
  return NULL;
}


/* Find a symbol table containing symbol SYM or NULL if none.  */
static struct symtab *
symtab_for_sym (struct symbol *sym)
{
  struct symtab *s;
  struct objfile *objfile;
  struct block *b;
  struct symbol *tmp_sym;
  struct dict_iterator iter;
  int j;

  ALL_SYMTABS (objfile, s)
  {
    switch (SYMBOL_CLASS (sym))
      {
      case LOC_CONST:
      case LOC_STATIC:
      case LOC_TYPEDEF:
      case LOC_REGISTER:
      case LOC_LABEL:
      case LOC_BLOCK:
      case LOC_CONST_BYTES:
	b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
	ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
	  return s;
	b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
	ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
	  return s;
	break;
      default:
	break;
      }
    switch (SYMBOL_CLASS (sym))
      {
      case LOC_REGISTER:
      case LOC_ARG:
      case LOC_REF_ARG:
      case LOC_REGPARM:
      case LOC_REGPARM_ADDR:
      case LOC_LOCAL:
      case LOC_TYPEDEF:
      case LOC_LOCAL_ARG:
      case LOC_BASEREG:
      case LOC_BASEREG_ARG:
      case LOC_COMPUTED:
      case LOC_COMPUTED_ARG:
	for (j = FIRST_LOCAL_BLOCK;
	     j < BLOCKVECTOR_NBLOCKS (BLOCKVECTOR (s)); j += 1)
	  {
	    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), j);
	    ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
	      return s;
	  }
	break;
      default:
	break;
      }
  }
  return NULL;
}

/* Return a minimal symbol matching NAME according to Ada demangling 
   rules. Returns NULL if there is no such minimal symbol. */

struct minimal_symbol *
ada_lookup_minimal_symbol (const char *name)
{
  struct objfile *objfile;
  struct minimal_symbol *msymbol;
  int wild_match = (strstr (name, "__") == NULL);

  ALL_MSYMBOLS (objfile, msymbol)
  {
    if (ada_match_name (DEPRECATED_SYMBOL_NAME (msymbol), name, wild_match)
	&& MSYMBOL_TYPE (msymbol) != mst_solib_trampoline)
      return msymbol;
  }

  return NULL;
}

/* For all subprograms that statically enclose the subprogram of the
 * selected frame, add symbols matching identifier NAME in DOMAIN
 * and their blocks to vectors *defn_symbols and *defn_blocks, as for
 * ada_add_block_symbols (q.v.).   If WILD, treat as NAME with a
 * wildcard prefix.  At the moment, this function uses a heuristic to
 * find the frames of enclosing subprograms: it treats the
 * pointer-sized value at location 0 from the local-variable base of a
 * frame as a static link, and then searches up the call stack for a
 * frame with that same local-variable base. */
static void
add_symbols_from_enclosing_procs (const char *name, domain_enum domain,
				  int wild_match)
{
#ifdef i386
  static struct symbol static_link_sym;
  static struct symbol *static_link;

  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);
  struct frame_info *frame;
  struct frame_info *target_frame;

  if (static_link == NULL)
    {
      /* Initialize the local variable symbol that stands for the
       * static link (when it exists). */
      static_link = &static_link_sym;
      DEPRECATED_SYMBOL_NAME (static_link) = "";
      SYMBOL_LANGUAGE (static_link) = language_unknown;
      SYMBOL_CLASS (static_link) = LOC_LOCAL;
      SYMBOL_DOMAIN (static_link) = VAR_DOMAIN;
      SYMBOL_TYPE (static_link) = lookup_pointer_type (builtin_type_void);
      SYMBOL_VALUE (static_link) =
	-(long) TYPE_LENGTH (SYMBOL_TYPE (static_link));
    }

  frame = deprecated_selected_frame;
  while (frame != NULL && ndefns == 0)
    {
      struct block *block;
      struct value *target_link_val = read_var_value (static_link, frame);
      CORE_ADDR target_link;

      if (target_link_val == NULL)
	break;
      QUIT;

      target_link = target_link_val;
      do
	{
	  QUIT;
	  frame = get_prev_frame (frame);
	}
      while (frame != NULL && DEPRECATED_FRAME_LOCALS_ADDRESS (frame) != target_link);

      if (frame == NULL)
	break;

      block = get_frame_block (frame, 0);
      while (block != NULL && block_function (block) != NULL && ndefns == 0)
	{
	  ada_add_block_symbols (block, name, domain, NULL, wild_match);

	  block = BLOCK_SUPERBLOCK (block);
	}
    }

  do_cleanups (old_chain);
#endif
}

/* True if TYPE is definitely an artificial type supplied to a symbol
 * for which no debugging information was given in the symbol file. */
static int
is_nondebugging_type (struct type *type)
{
  char *name = ada_type_name (type);
  return (name != NULL && DEPRECATED_STREQ (name, "<variable, no debug info>"));
}

/* Remove any non-debugging symbols in SYMS[0 .. NSYMS-1] that definitely 
 * duplicate other symbols in the list.  (The only case I know of where
 * this happens is when object files containing stabs-in-ecoff are
 * linked with files containing ordinary ecoff debugging symbols (or no
 * debugging symbols)). Modifies SYMS to squeeze out deleted symbols,
 * and applies the same modification to BLOCKS to maintain the
 * correspondence between SYMS[i] and BLOCKS[i].  Returns the number
 * of symbols in the modified list. */
static int
remove_extra_symbols (struct symbol **syms, struct block **blocks, int nsyms)
{
  int i, j;

  i = 0;
  while (i < nsyms)
    {
      if (DEPRECATED_SYMBOL_NAME (syms[i]) != NULL
	  && SYMBOL_CLASS (syms[i]) == LOC_STATIC
	  && is_nondebugging_type (SYMBOL_TYPE (syms[i])))
	{
	  for (j = 0; j < nsyms; j += 1)
	    {
	      if (i != j
		  && DEPRECATED_SYMBOL_NAME (syms[j]) != NULL
		  && DEPRECATED_STREQ (DEPRECATED_SYMBOL_NAME (syms[i]), DEPRECATED_SYMBOL_NAME (syms[j]))
		  && SYMBOL_CLASS (syms[i]) == SYMBOL_CLASS (syms[j])
		  && SYMBOL_VALUE_ADDRESS (syms[i])
		  == SYMBOL_VALUE_ADDRESS (syms[j]))
		{
		  int k;
		  for (k = i + 1; k < nsyms; k += 1)
		    {
		      syms[k - 1] = syms[k];
		      blocks[k - 1] = blocks[k];
		    }
		  nsyms -= 1;
		  goto NextSymbol;
		}
	    }
	}
      i += 1;
    NextSymbol:
      ;
    }
  return nsyms;
}

/* Find symbols in DOMAIN matching NAME, in BLOCK0 and enclosing 
   scope and in global scopes, returning the number of matches.  Sets 
   *SYMS to point to a vector of matching symbols, with *BLOCKS
   pointing to the vector of corresponding blocks in which those
   symbols reside.  These two vectors are transient---good only to the
   next call of ada_lookup_symbol_list.  Any non-function/non-enumeral symbol
   match within the nest of blocks whose innermost member is BLOCK0,
   is the outermost match returned (no other matches in that or
   enclosing blocks is returned).  If there are any matches in or
   surrounding BLOCK0, then these alone are returned. */

int
ada_lookup_symbol_list (const char *name, struct block *block0,
			domain_enum domain, struct symbol ***syms,
			struct block ***blocks)
{
  struct symbol *sym;
  struct symtab *s;
  struct partial_symtab *ps;
  struct blockvector *bv;
  struct objfile *objfile;
  struct block *b;
  struct block *block;
  struct minimal_symbol *msymbol;
  int wild_match = (strstr (name, "__") == NULL);
  int cacheIfUnique;

#ifdef TIMING
  markTimeStart (0);
#endif

  ndefns = 0;
  cacheIfUnique = 0;

  /* Search specified block and its superiors.  */

  block = block0;
  while (block != NULL)
    {
      ada_add_block_symbols (block, name, domain, NULL, wild_match);

      /* If we found a non-function match, assume that's the one. */
      if (is_nonfunction (defn_symbols, ndefns))
	goto done;

      block = BLOCK_SUPERBLOCK (block);
    }

  /* If we found ANY matches in the specified BLOCK, we're done. */

  if (ndefns > 0)
    goto done;

  cacheIfUnique = 1;

  /* Now add symbols from all global blocks: symbol tables, minimal symbol
     tables, and psymtab's */

  ALL_SYMTABS (objfile, s)
  {
    QUIT;
    if (!s->primary)
      continue;
    bv = BLOCKVECTOR (s);
    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
    ada_add_block_symbols (block, name, domain, objfile, wild_match);
  }

  if (domain == VAR_DOMAIN)
    {
      ALL_MSYMBOLS (objfile, msymbol)
      {
	if (ada_match_name (DEPRECATED_SYMBOL_NAME (msymbol), name, wild_match))
	  {
	    switch (MSYMBOL_TYPE (msymbol))
	      {
	      case mst_solib_trampoline:
		break;
	      default:
		s = find_pc_symtab (SYMBOL_VALUE_ADDRESS (msymbol));
		if (s != NULL)
		  {
		    int old_ndefns = ndefns;
		    QUIT;
		    bv = BLOCKVECTOR (s);
		    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
		    ada_add_block_symbols (block,
					   DEPRECATED_SYMBOL_NAME (msymbol),
					   domain, objfile, wild_match);
		    if (ndefns == old_ndefns)
		      {
			block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
			ada_add_block_symbols (block,
					       DEPRECATED_SYMBOL_NAME (msymbol),
					       domain, objfile,
					       wild_match);
		      }
		  }
	      }
	  }
      }
    }

  ALL_PSYMTABS (objfile, ps)
  {
    QUIT;
    if (!ps->readin
	&& ada_lookup_partial_symbol (ps, name, 1, domain, wild_match))
      {
	s = PSYMTAB_TO_SYMTAB (ps);
	if (!s->primary)
	  continue;
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	ada_add_block_symbols (block, name, domain, objfile, wild_match);
      }
  }

  /* Now add symbols from all per-file blocks if we've gotten no hits.  
     (Not strictly correct, but perhaps better than an error).
     Do the symtabs first, then check the psymtabs */

  if (ndefns == 0)
    {

      ALL_SYMTABS (objfile, s)
      {
	QUIT;
	if (!s->primary)
	  continue;
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	ada_add_block_symbols (block, name, domain, objfile, wild_match);
      }

      ALL_PSYMTABS (objfile, ps)
      {
	QUIT;
	if (!ps->readin
	    && ada_lookup_partial_symbol (ps, name, 0, domain, wild_match))
	  {
	    s = PSYMTAB_TO_SYMTAB (ps);
	    bv = BLOCKVECTOR (s);
	    if (!s->primary)
	      continue;
	    block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	    ada_add_block_symbols (block, name, domain,
				   objfile, wild_match);
	  }
      }
    }

  /* Finally, we try to find NAME as a local symbol in some lexically
     enclosing block.  We do this last, expecting this case to be
     rare. */
  if (ndefns == 0)
    {
      add_symbols_from_enclosing_procs (name, domain, wild_match);
      if (ndefns > 0)
	goto done;
    }

done:
  ndefns = remove_extra_symbols (defn_symbols, defn_blocks, ndefns);


  *syms = defn_symbols;
  *blocks = defn_blocks;
#ifdef TIMING
  markTimeStop (0);
#endif
  return ndefns;
}

/* Return a symbol in DOMAIN matching NAME, in BLOCK0 and enclosing 
 * scope and in global scopes, or NULL if none.  NAME is folded to
 * lower case first, unless it is surrounded in single quotes. 
 * Otherwise, the result is as for ada_lookup_symbol_list, but is 
 * disambiguated by user query if needed. */

struct symbol *
ada_lookup_symbol (const char *name, struct block *block0,
		   domain_enum domain)
{
  struct symbol **candidate_syms;
  struct block **candidate_blocks;
  int n_candidates;

  n_candidates = ada_lookup_symbol_list (name,
					 block0, domain,
					 &candidate_syms, &candidate_blocks);

  if (n_candidates == 0)
    return NULL;
  else if (n_candidates != 1)
    user_select_syms (candidate_syms, candidate_blocks, n_candidates, 1);

  return candidate_syms[0];
}


/* True iff STR is a possible encoded suffix of a normal Ada name 
 * that is to be ignored for matching purposes.  Suffixes of parallel
 * names (e.g., XVE) are not included here.  Currently, the possible suffixes 
 * are given by the regular expression:
 *        (X[nb]*)?(__[0-9]+|\$[0-9]+|___(LJM|X([FDBUP].*|R[^T]?)))?$
 * 
 */
static int
is_name_suffix (const char *str)
{
  int k;
  if (str[0] == 'X')
    {
      str += 1;
      while (str[0] != '_' && str[0] != '\0')
	{
	  if (str[0] != 'n' && str[0] != 'b')
	    return 0;
	  str += 1;
	}
    }
  if (str[0] == '\000')
    return 1;
  if (str[0] == '_')
    {
      if (str[1] != '_' || str[2] == '\000')
	return 0;
      if (str[2] == '_')
	{
	  if (DEPRECATED_STREQ (str + 3, "LJM"))
	    return 1;
	  if (str[3] != 'X')
	    return 0;
	  if (str[4] == 'F' || str[4] == 'D' || str[4] == 'B' ||
	      str[4] == 'U' || str[4] == 'P')
	    return 1;
	  if (str[4] == 'R' && str[5] != 'T')
	    return 1;
	  return 0;
	}
      for (k = 2; str[k] != '\0'; k += 1)
	if (!isdigit (str[k]))
	  return 0;
      return 1;
    }
  if (str[0] == '$' && str[1] != '\000')
    {
      for (k = 1; str[k] != '\0'; k += 1)
	if (!isdigit (str[k]))
	  return 0;
      return 1;
    }
  return 0;
}

/* True if NAME represents a name of the form A1.A2....An, n>=1 and 
 * PATN[0..PATN_LEN-1] = Ak.Ak+1.....An for some k >= 1.  Ignores
 * informational suffixes of NAME (i.e., for which is_name_suffix is
 * true). */
static int
wild_match (const char *patn, int patn_len, const char *name)
{
  int name_len;
  int s, e;

  name_len = strlen (name);
  if (name_len >= patn_len + 5 && DEPRECATED_STREQN (name, "_ada_", 5)
      && DEPRECATED_STREQN (patn, name + 5, patn_len)
      && is_name_suffix (name + patn_len + 5))
    return 1;

  while (name_len >= patn_len)
    {
      if (DEPRECATED_STREQN (patn, name, patn_len) && is_name_suffix (name + patn_len))
	return 1;
      do
	{
	  name += 1;
	  name_len -= 1;
	}
      while (name_len > 0
	     && name[0] != '.' && (name[0] != '_' || name[1] != '_'));
      if (name_len <= 0)
	return 0;
      if (name[0] == '_')
	{
	  if (!islower (name[2]))
	    return 0;
	  name += 2;
	  name_len -= 2;
	}
      else
	{
	  if (!islower (name[1]))
	    return 0;
	  name += 1;
	  name_len -= 1;
	}
    }

  return 0;
}


/* Add symbols from BLOCK matching identifier NAME in DOMAIN to 
   vector *defn_symbols, updating *defn_symbols (if necessary), *SZ (the size of
   the vector *defn_symbols), and *ndefns (the number of symbols
   currently stored in *defn_symbols).  If WILD, treat as NAME with a
   wildcard prefix. OBJFILE is the section containing BLOCK. */

static void
ada_add_block_symbols (struct block *block, const char *name,
		       domain_enum domain, struct objfile *objfile,
		       int wild)
{
  struct dict_iterator iter;
  int name_len = strlen (name);
  /* A matching argument symbol, if any. */
  struct symbol *arg_sym;
  /* Set true when we find a matching non-argument symbol */
  int found_sym;
  struct symbol *sym;

  arg_sym = NULL;
  found_sym = 0;
  if (wild)
    {
      struct symbol *sym;
      ALL_BLOCK_SYMBOLS (block, iter, sym)
      {
	if (SYMBOL_DOMAIN (sym) == domain &&
	    wild_match (name, name_len, DEPRECATED_SYMBOL_NAME (sym)))
	  {
	    switch (SYMBOL_CLASS (sym))
	      {
	      case LOC_ARG:
	      case LOC_LOCAL_ARG:
	      case LOC_REF_ARG:
	      case LOC_REGPARM:
	      case LOC_REGPARM_ADDR:
	      case LOC_BASEREG_ARG:
	      case LOC_COMPUTED_ARG:
		arg_sym = sym;
		break;
	      case LOC_UNRESOLVED:
		continue;
	      default:
		found_sym = 1;
		fill_in_ada_prototype (sym);
		add_defn_to_vec (fixup_symbol_section (sym, objfile), block);
		break;
	      }
	  }
      }
    }
  else
    {
      ALL_BLOCK_SYMBOLS (block, iter, sym)
	  {
	    if (SYMBOL_DOMAIN (sym) == domain)
	      {
		int cmp = strncmp (name, DEPRECATED_SYMBOL_NAME (sym), name_len);

		if (cmp == 0
		    && is_name_suffix (DEPRECATED_SYMBOL_NAME (sym) + name_len))
		  {
		    switch (SYMBOL_CLASS (sym))
		      {
		      case LOC_ARG:
		      case LOC_LOCAL_ARG:
		      case LOC_REF_ARG:
		      case LOC_REGPARM:
		      case LOC_REGPARM_ADDR:
		      case LOC_BASEREG_ARG:
		      case LOC_COMPUTED_ARG:
			arg_sym = sym;
			break;
		      case LOC_UNRESOLVED:
			break;
		      default:
			found_sym = 1;
			fill_in_ada_prototype (sym);
			add_defn_to_vec (fixup_symbol_section (sym, objfile),
					 block);
			break;
		      }
		  }
	      }
	  }
    }

  if (!found_sym && arg_sym != NULL)
    {
      fill_in_ada_prototype (arg_sym);
      add_defn_to_vec (fixup_symbol_section (arg_sym, objfile), block);
    }

  if (!wild)
    {
      arg_sym = NULL;
      found_sym = 0;

      ALL_BLOCK_SYMBOLS (block, iter, sym)
	  {
	    if (SYMBOL_DOMAIN (sym) == domain)
	      {
		int cmp;

		cmp = (int) '_' - (int) DEPRECATED_SYMBOL_NAME (sym)[0];
		if (cmp == 0)
		  {
		    cmp = strncmp ("_ada_", DEPRECATED_SYMBOL_NAME (sym), 5);
		    if (cmp == 0)
		      cmp = strncmp (name, DEPRECATED_SYMBOL_NAME (sym) + 5, name_len);
		  }

		if (cmp == 0
		    && is_name_suffix (DEPRECATED_SYMBOL_NAME (sym) + name_len + 5))
		  {
		    switch (SYMBOL_CLASS (sym))
		      {
		      case LOC_ARG:
		      case LOC_LOCAL_ARG:
		      case LOC_REF_ARG:
		      case LOC_REGPARM:
		      case LOC_REGPARM_ADDR:
		      case LOC_BASEREG_ARG:
		      case LOC_COMPUTED_ARG:
			arg_sym = sym;
			break;
		      case LOC_UNRESOLVED:
			break;
		      default:
			found_sym = 1;
			fill_in_ada_prototype (sym);
			add_defn_to_vec (fixup_symbol_section (sym, objfile),
					 block);
			break;
		      }
		  }
	      }
	  }

      /* NOTE: This really shouldn't be needed for _ada_ symbols.
         They aren't parameters, right? */
      if (!found_sym && arg_sym != NULL)
	{
	  fill_in_ada_prototype (arg_sym);
	  add_defn_to_vec (fixup_symbol_section (arg_sym, objfile), block);
	}
    }
}


				/* Function Types */

/* Assuming that SYM is the symbol for a function, fill in its type 
   with prototype information, if it is not already there.  */

static void
fill_in_ada_prototype (struct symbol *func)
{
  struct block *b;
  int nargs, nsyms;
  struct dict_iterator iter;
  struct type *ftype;
  struct type *rtype;
  size_t max_fields;
  struct symbol *sym;

  if (func == NULL
      || TYPE_CODE (SYMBOL_TYPE (func)) != TYPE_CODE_FUNC
      || TYPE_FIELDS (SYMBOL_TYPE (func)) != NULL)
    return;

  /* We make each function type unique, so that each may have its own */
  /* parameter types.  This particular way of doing so wastes space: */
  /* it would be nicer to build the argument types while the original */
  /* function type is being built (FIXME). */
  rtype = check_typedef (TYPE_TARGET_TYPE (SYMBOL_TYPE (func)));
  ftype = alloc_type (TYPE_OBJFILE (SYMBOL_TYPE (func)));
  make_function_type (rtype, &ftype);
  SYMBOL_TYPE (func) = ftype;

  b = SYMBOL_BLOCK_VALUE (func);

  nargs = 0;
  max_fields = 8;
  TYPE_FIELDS (ftype) =
    (struct field *) xmalloc (sizeof (struct field) * max_fields);
  ALL_BLOCK_SYMBOLS (b, iter, sym)
  {
    GROW_VECT (TYPE_FIELDS (ftype), max_fields, nargs + 1);

    switch (SYMBOL_CLASS (sym))
      {
      case LOC_REF_ARG:
      case LOC_REGPARM_ADDR:
	TYPE_FIELD_BITPOS (ftype, nargs) = nargs;
	TYPE_FIELD_BITSIZE (ftype, nargs) = 0;
	TYPE_FIELD_STATIC_KIND (ftype, nargs) = 0;
	TYPE_FIELD_TYPE (ftype, nargs) =
	  lookup_pointer_type (check_typedef (SYMBOL_TYPE (sym)));
	TYPE_FIELD_NAME (ftype, nargs) = DEPRECATED_SYMBOL_NAME (sym);
	nargs += 1;

	break;

      case LOC_ARG:
      case LOC_REGPARM:
      case LOC_LOCAL_ARG:
      case LOC_BASEREG_ARG:
      case LOC_COMPUTED_ARG:
	TYPE_FIELD_BITPOS (ftype, nargs) = nargs;
	TYPE_FIELD_BITSIZE (ftype, nargs) = 0;
	TYPE_FIELD_STATIC_KIND (ftype, nargs) = 0;
	TYPE_FIELD_TYPE (ftype, nargs) = check_typedef (SYMBOL_TYPE (sym));
	TYPE_FIELD_NAME (ftype, nargs) = DEPRECATED_SYMBOL_NAME (sym);
	nargs += 1;

	break;

      default:
	break;
      }
  }

  /* Re-allocate fields vector; if there are no fields, make the */
  /* fields pointer non-null anyway, to mark that this function type */
  /* has been filled in. */

  TYPE_NFIELDS (ftype) = nargs;
  if (nargs == 0)
    {
      static struct field dummy_field = { 0, 0, 0, 0 };
      xfree (TYPE_FIELDS (ftype));
      TYPE_FIELDS (ftype) = &dummy_field;
    }
  else
    {
      struct field *fields =
	(struct field *) TYPE_ALLOC (ftype, nargs * sizeof (struct field));
      memcpy ((char *) fields,
	      (char *) TYPE_FIELDS (ftype), nargs * sizeof (struct field));
      xfree (TYPE_FIELDS (ftype));
      TYPE_FIELDS (ftype) = fields;
    }
}


				/* Breakpoint-related */

char no_symtab_msg[] =
  "No symbol table is loaded.  Use the \"file\" command.";

/* Assuming that LINE is pointing at the beginning of an argument to
   'break', return a pointer to the delimiter for the initial segment
   of that name.  This is the first ':', ' ', or end of LINE. 
*/
char *
ada_start_decode_line_1 (char *line)
{
  /* [NOTE: strpbrk would be more elegant, but I am reluctant to be
     the first to use such a library function in GDB code.] */
  char *p;
  for (p = line; *p != '\000' && *p != ' ' && *p != ':'; p += 1)
    ;
  return p;
}

/* *SPEC points to a function and line number spec (as in a break
   command), following any initial file name specification.

   Return all symbol table/line specfications (sals) consistent with the
   information in *SPEC and FILE_TABLE in the
   following sense: 
     + FILE_TABLE is null, or the sal refers to a line in the file
       named by FILE_TABLE.
     + If *SPEC points to an argument with a trailing ':LINENUM',
       then the sal refers to that line (or one following it as closely as 
       possible).
     + If *SPEC does not start with '*', the sal is in a function with 
       that name.

   Returns with 0 elements if no matching non-minimal symbols found.

   If *SPEC begins with a function name of the form <NAME>, then NAME
   is taken as a literal name; otherwise the function name is subject
   to the usual mangling.

   *SPEC is updated to point after the function/line number specification.

   FUNFIRSTLINE is non-zero if we desire the first line of real code
   in each function (this is ignored in the presence of a LINENUM spec.).

   If CANONICAL is non-NULL, and if any of the sals require a
   'canonical line spec', then *CANONICAL is set to point to an array
   of strings, corresponding to and equal in length to the returned
   list of sals, such that (*CANONICAL)[i] is non-null and contains a 
   canonical line spec for the ith returned sal, if needed.  If no 
   canonical line specs are required and CANONICAL is non-null, 
   *CANONICAL is set to NULL.

   A 'canonical line spec' is simply a name (in the format of the
   breakpoint command) that uniquely identifies a breakpoint position,
   with no further contextual information or user selection.  It is
   needed whenever the file name, function name, and line number
   information supplied is insufficient for this unique
   identification.  Currently overloaded functions, the name '*', 
   or static functions without a filename yield a canonical line spec.
   The array and the line spec strings are allocated on the heap; it
   is the caller's responsibility to free them.   */

struct symtabs_and_lines
ada_finish_decode_line_1 (char **spec, struct symtab *file_table,
			  int funfirstline, char ***canonical)
{
  struct symbol **symbols;
  struct block **blocks;
  struct block *block;
  int n_matches, i, line_num;
  struct symtabs_and_lines selected;
  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);
  char *name;

  int len;
  char *lower_name;
  char *unquoted_name;

  if (file_table == NULL)
    block = get_selected_block (NULL);
  else
    block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (file_table), STATIC_BLOCK);

  if (canonical != NULL)
    *canonical = (char **) NULL;

  name = *spec;
  if (**spec == '*')
    *spec += 1;
  else
    {
      while (**spec != '\000' &&
	     !strchr (ada_completer_word_break_characters, **spec))
	*spec += 1;
    }
  len = *spec - name;

  line_num = -1;
  if (file_table != NULL && (*spec)[0] == ':' && isdigit ((*spec)[1]))
    {
      line_num = strtol (*spec + 1, spec, 10);
      while (**spec == ' ' || **spec == '\t')
	*spec += 1;
    }

  if (name[0] == '*')
    {
      if (line_num == -1)
	error ("Wild-card function with no line number or file name.");

      return all_sals_for_line (file_table->filename, line_num, canonical);
    }

  if (name[0] == '\'')
    {
      name += 1;
      len -= 2;
    }

  if (name[0] == '<')
    {
      unquoted_name = (char *) alloca (len - 1);
      memcpy (unquoted_name, name + 1, len - 2);
      unquoted_name[len - 2] = '\000';
      lower_name = NULL;
    }
  else
    {
      unquoted_name = (char *) alloca (len + 1);
      memcpy (unquoted_name, name, len);
      unquoted_name[len] = '\000';
      lower_name = (char *) alloca (len + 1);
      for (i = 0; i < len; i += 1)
	lower_name[i] = tolower (name[i]);
      lower_name[len] = '\000';
    }

  n_matches = 0;
  if (lower_name != NULL)
    n_matches = ada_lookup_symbol_list (ada_mangle (lower_name), block,
					VAR_DOMAIN, &symbols, &blocks);
  if (n_matches == 0)
    n_matches = ada_lookup_symbol_list (unquoted_name, block,
					VAR_DOMAIN, &symbols, &blocks);
  if (n_matches == 0 && line_num >= 0)
    error ("No line number information found for %s.", unquoted_name);
  else if (n_matches == 0)
    {
#ifdef HPPA_COMPILER_BUG
      /* FIXME: See comment in symtab.c::decode_line_1 */
#undef volatile
      volatile struct symtab_and_line val;
#define volatile		/*nothing */
#else
      struct symtab_and_line val;
#endif
      struct minimal_symbol *msymbol;

      init_sal (&val);

      msymbol = NULL;
      if (lower_name != NULL)
	msymbol = ada_lookup_minimal_symbol (ada_mangle (lower_name));
      if (msymbol == NULL)
	msymbol = ada_lookup_minimal_symbol (unquoted_name);
      if (msymbol != NULL)
	{
	  val.pc = SYMBOL_VALUE_ADDRESS (msymbol);
	  val.section = SYMBOL_BFD_SECTION (msymbol);
	  if (funfirstline)
	    {
	      val.pc += FUNCTION_START_OFFSET;
	      SKIP_PROLOGUE (val.pc);
	    }
	  selected.sals = (struct symtab_and_line *)
	    xmalloc (sizeof (struct symtab_and_line));
	  selected.sals[0] = val;
	  selected.nelts = 1;
	  return selected;
	}

      if (!have_full_symbols () &&
	  !have_partial_symbols () && !have_minimal_symbols ())
	error (no_symtab_msg);

      error ("Function \"%s\" not defined.", unquoted_name);
      return selected;		/* for lint */
    }

  if (line_num >= 0)
    {
      return
	find_sal_from_funcs_and_line (file_table->filename, line_num,
				      symbols, n_matches);
    }
  else
    {
      selected.nelts =
	user_select_syms (symbols, blocks, n_matches, n_matches);
    }

  selected.sals = (struct symtab_and_line *)
    xmalloc (sizeof (struct symtab_and_line) * selected.nelts);
  memset (selected.sals, 0, selected.nelts * sizeof (selected.sals[i]));
  make_cleanup (xfree, selected.sals);

  i = 0;
  while (i < selected.nelts)
    {
      if (SYMBOL_CLASS (symbols[i]) == LOC_BLOCK)
	selected.sals[i] = find_function_start_sal (symbols[i], funfirstline);
      else if (SYMBOL_LINE (symbols[i]) != 0)
	{
	  selected.sals[i].symtab = symtab_for_sym (symbols[i]);
	  selected.sals[i].line = SYMBOL_LINE (symbols[i]);
	}
      else if (line_num >= 0)
	{
	  /* Ignore this choice */
	  symbols[i] = symbols[selected.nelts - 1];
	  blocks[i] = blocks[selected.nelts - 1];
	  selected.nelts -= 1;
	  continue;
	}
      else
	error ("Line number not known for symbol \"%s\"", unquoted_name);
      i += 1;
    }

  if (canonical != NULL && (line_num >= 0 || n_matches > 1))
    {
      *canonical = (char **) xmalloc (sizeof (char *) * selected.nelts);
      for (i = 0; i < selected.nelts; i += 1)
	(*canonical)[i] =
	  extended_canonical_line_spec (selected.sals[i],
					SYMBOL_PRINT_NAME (symbols[i]));
    }

  discard_cleanups (old_chain);
  return selected;
}

/* The (single) sal corresponding to line LINE_NUM in a symbol table
   with file name FILENAME that occurs in one of the functions listed 
   in SYMBOLS[0 .. NSYMS-1]. */
static struct symtabs_and_lines
find_sal_from_funcs_and_line (const char *filename, int line_num,
			      struct symbol **symbols, int nsyms)
{
  struct symtabs_and_lines sals;
  int best_index, best;
  struct linetable *best_linetable;
  struct objfile *objfile;
  struct symtab *s;
  struct symtab *best_symtab;

  read_all_symtabs (filename);

  best_index = 0;
  best_linetable = NULL;
  best_symtab = NULL;
  best = 0;
  ALL_SYMTABS (objfile, s)
  {
    struct linetable *l;
    int ind, exact;

    QUIT;

    if (!DEPRECATED_STREQ (filename, s->filename))
      continue;
    l = LINETABLE (s);
    ind = find_line_in_linetable (l, line_num, symbols, nsyms, &exact);
    if (ind >= 0)
      {
	if (exact)
	  {
	    best_index = ind;
	    best_linetable = l;
	    best_symtab = s;
	    goto done;
	  }
	if (best == 0 || l->item[ind].line < best)
	  {
	    best = l->item[ind].line;
	    best_index = ind;
	    best_linetable = l;
	    best_symtab = s;
	  }
      }
  }

  if (best == 0)
    error ("Line number not found in designated function.");

done:

  sals.nelts = 1;
  sals.sals = (struct symtab_and_line *) xmalloc (sizeof (sals.sals[0]));

  init_sal (&sals.sals[0]);

  sals.sals[0].line = best_linetable->item[best_index].line;
  sals.sals[0].pc = best_linetable->item[best_index].pc;
  sals.sals[0].symtab = best_symtab;

  return sals;
}

/* Return the index in LINETABLE of the best match for LINE_NUM whose
   pc falls within one of the functions denoted by SYMBOLS[0..NSYMS-1].  
   Set *EXACTP to the 1 if the match is exact, and 0 otherwise. */
static int
find_line_in_linetable (struct linetable *linetable, int line_num,
			struct symbol **symbols, int nsyms, int *exactp)
{
  int i, len, best_index, best;

  if (line_num <= 0 || linetable == NULL)
    return -1;

  len = linetable->nitems;
  for (i = 0, best_index = -1, best = 0; i < len; i += 1)
    {
      int k;
      struct linetable_entry *item = &(linetable->item[i]);

      for (k = 0; k < nsyms; k += 1)
	{
	  if (symbols[k] != NULL && SYMBOL_CLASS (symbols[k]) == LOC_BLOCK
	      && item->pc >= BLOCK_START (SYMBOL_BLOCK_VALUE (symbols[k]))
	      && item->pc < BLOCK_END (SYMBOL_BLOCK_VALUE (symbols[k])))
	    goto candidate;
	}
      continue;

    candidate:

      if (item->line == line_num)
	{
	  *exactp = 1;
	  return i;
	}

      if (item->line > line_num && (best == 0 || item->line < best))
	{
	  best = item->line;
	  best_index = i;
	}
    }

  *exactp = 0;
  return best_index;
}

/* Find the smallest k >= LINE_NUM such that k is a line number in
   LINETABLE, and k falls strictly within a named function that begins at
   or before LINE_NUM.  Return -1 if there is no such k. */
static int
nearest_line_number_in_linetable (struct linetable *linetable, int line_num)
{
  int i, len, best;

  if (line_num <= 0 || linetable == NULL || linetable->nitems == 0)
    return -1;
  len = linetable->nitems;

  i = 0;
  best = INT_MAX;
  while (i < len)
    {
      int k;
      struct linetable_entry *item = &(linetable->item[i]);

      if (item->line >= line_num && item->line < best)
	{
	  char *func_name;
	  CORE_ADDR start, end;

	  func_name = NULL;
	  find_pc_partial_function (item->pc, &func_name, &start, &end);

	  if (func_name != NULL && item->pc < end)
	    {
	      if (item->line == line_num)
		return line_num;
	      else
		{
		  struct symbol *sym =
		    standard_lookup (func_name, VAR_DOMAIN);
		  if (is_plausible_func_for_line (sym, line_num))
		    best = item->line;
		  else
		    {
		      do
			i += 1;
		      while (i < len && linetable->item[i].pc < end);
		      continue;
		    }
		}
	    }
	}

      i += 1;
    }

  return (best == INT_MAX) ? -1 : best;
}


/* Return the next higher index, k, into LINETABLE such that k > IND, 
   entry k in LINETABLE has a line number equal to LINE_NUM, k
   corresponds to a PC that is in a function different from that 
   corresponding to IND, and falls strictly within a named function
   that begins at a line at or preceding STARTING_LINE.  
   Return -1 if there is no such k.  
   IND == -1 corresponds to no function. */

static int
find_next_line_in_linetable (struct linetable *linetable, int line_num,
			     int starting_line, int ind)
{
  int i, len;

  if (line_num <= 0 || linetable == NULL || ind >= linetable->nitems)
    return -1;
  len = linetable->nitems;

  if (ind >= 0)
    {
      CORE_ADDR start, end;

      if (find_pc_partial_function (linetable->item[ind].pc,
				    (char **) NULL, &start, &end))
	{
	  while (ind < len && linetable->item[ind].pc < end)
	    ind += 1;
	}
      else
	ind += 1;
    }
  else
    ind = 0;

  i = ind;
  while (i < len)
    {
      int k;
      struct linetable_entry *item = &(linetable->item[i]);

      if (item->line >= line_num)
	{
	  char *func_name;
	  CORE_ADDR start, end;

	  func_name = NULL;
	  find_pc_partial_function (item->pc, &func_name, &start, &end);

	  if (func_name != NULL && item->pc < end)
	    {
	      if (item->line == line_num)
		{
		  struct symbol *sym =
		    standard_lookup (func_name, VAR_DOMAIN);
		  if (is_plausible_func_for_line (sym, starting_line))
		    return i;
		  else
		    {
		      while ((i + 1) < len && linetable->item[i + 1].pc < end)
			i += 1;
		    }
		}
	    }
	}
      i += 1;
    }

  return -1;
}

/* True iff function symbol SYM starts somewhere at or before line #
   LINE_NUM. */
static int
is_plausible_func_for_line (struct symbol *sym, int line_num)
{
  struct symtab_and_line start_sal;

  if (sym == NULL)
    return 0;

  start_sal = find_function_start_sal (sym, 0);

  return (start_sal.line != 0 && line_num >= start_sal.line);
}

static void
debug_print_lines (struct linetable *lt)
{
  int i;

  if (lt == NULL)
    return;

  fprintf (stderr, "\t");
  for (i = 0; i < lt->nitems; i += 1)
    fprintf (stderr, "(%d->%p) ", lt->item[i].line, (void *) lt->item[i].pc);
  fprintf (stderr, "\n");
}

static void
debug_print_block (struct block *b)
{
  struct dict_iterator iter;
  struct symbol *sym;

  fprintf (stderr, "Block: %p; [0x%lx, 0x%lx]",
	   b, BLOCK_START (b), BLOCK_END (b));
  if (BLOCK_FUNCTION (b) != NULL)
    fprintf (stderr, " Function: %s", DEPRECATED_SYMBOL_NAME (BLOCK_FUNCTION (b)));
  fprintf (stderr, "\n");
  fprintf (stderr, "\t    Superblock: %p\n", BLOCK_SUPERBLOCK (b));
  fprintf (stderr, "\t    Symbols:");
  ALL_BLOCK_SYMBOLS (b, iter, sym)
  {
    fprintf (stderr, " %s", DEPRECATED_SYMBOL_NAME (sym));
  }
  fprintf (stderr, "\n");
}

static void
debug_print_blocks (struct blockvector *bv)
{
  int i;

  if (bv == NULL)
    return;
  for (i = 0; i < BLOCKVECTOR_NBLOCKS (bv); i += 1)
    {
      fprintf (stderr, "%6d. ", i);
      debug_print_block (BLOCKVECTOR_BLOCK (bv, i));
    }
}

static void
debug_print_symtab (struct symtab *s)
{
  fprintf (stderr, "Symtab %p\n    File: %s; Dir: %s\n", s,
	   s->filename, s->dirname);
  fprintf (stderr, "    Blockvector: %p, Primary: %d\n",
	   BLOCKVECTOR (s), s->primary);
  debug_print_blocks (BLOCKVECTOR (s));
  fprintf (stderr, "    Line table: %p\n", LINETABLE (s));
  debug_print_lines (LINETABLE (s));
}

/* Read in all symbol tables corresponding to partial symbol tables
   with file name FILENAME. */
static void
read_all_symtabs (const char *filename)
{
  struct partial_symtab *ps;
  struct objfile *objfile;

  ALL_PSYMTABS (objfile, ps)
  {
    QUIT;

    if (DEPRECATED_STREQ (filename, ps->filename))
      PSYMTAB_TO_SYMTAB (ps);
  }
}

/* All sals corresponding to line LINE_NUM in a symbol table from file
   FILENAME, as filtered by the user.  If CANONICAL is not null, set
   it to a corresponding array of canonical line specs. */
static struct symtabs_and_lines
all_sals_for_line (const char *filename, int line_num, char ***canonical)
{
  struct symtabs_and_lines result;
  struct objfile *objfile;
  struct symtab *s;
  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);
  size_t len;

  read_all_symtabs (filename);

  result.sals =
    (struct symtab_and_line *) xmalloc (4 * sizeof (result.sals[0]));
  result.nelts = 0;
  len = 4;
  make_cleanup (free_current_contents, &result.sals);

  ALL_SYMTABS (objfile, s)
  {
    int ind, target_line_num;

    QUIT;

    if (!DEPRECATED_STREQ (s->filename, filename))
      continue;

    target_line_num =
      nearest_line_number_in_linetable (LINETABLE (s), line_num);
    if (target_line_num == -1)
      continue;

    ind = -1;
    while (1)
      {
	ind =
	  find_next_line_in_linetable (LINETABLE (s),
				       target_line_num, line_num, ind);

	if (ind < 0)
	  break;

	GROW_VECT (result.sals, len, result.nelts + 1);
	init_sal (&result.sals[result.nelts]);
	result.sals[result.nelts].line = LINETABLE (s)->item[ind].line;
	result.sals[result.nelts].pc = LINETABLE (s)->item[ind].pc;
	result.sals[result.nelts].symtab = s;
	result.nelts += 1;
      }
  }

  if (canonical != NULL || result.nelts > 1)
    {
      int k;
      char **func_names = (char **) alloca (result.nelts * sizeof (char *));
      int first_choice = (result.nelts > 1) ? 2 : 1;
      int n;
      int *choices = (int *) alloca (result.nelts * sizeof (int));

      for (k = 0; k < result.nelts; k += 1)
	{
	  find_pc_partial_function (result.sals[k].pc, &func_names[k],
				    (CORE_ADDR *) NULL, (CORE_ADDR *) NULL);
	  if (func_names[k] == NULL)
	    error ("Could not find function for one or more breakpoints.");
	}

      if (result.nelts > 1)
	{
	  printf_unfiltered ("[0] cancel\n");
	  if (result.nelts > 1)
	    printf_unfiltered ("[1] all\n");
	  for (k = 0; k < result.nelts; k += 1)
	    printf_unfiltered ("[%d] %s\n", k + first_choice,
			       ada_demangle (func_names[k]));

	  n = get_selections (choices, result.nelts, result.nelts,
			      result.nelts > 1, "instance-choice");

	  for (k = 0; k < n; k += 1)
	    {
	      result.sals[k] = result.sals[choices[k]];
	      func_names[k] = func_names[choices[k]];
	    }
	  result.nelts = n;
	}

      if (canonical != NULL)
	{
	  *canonical = (char **) xmalloc (result.nelts * sizeof (char **));
	  make_cleanup (xfree, *canonical);
	  for (k = 0; k < result.nelts; k += 1)
	    {
	      (*canonical)[k] =
		extended_canonical_line_spec (result.sals[k], func_names[k]);
	      if ((*canonical)[k] == NULL)
		error ("Could not locate one or more breakpoints.");
	      make_cleanup (xfree, (*canonical)[k]);
	    }
	}
    }

  discard_cleanups (old_chain);
  return result;
}


/* A canonical line specification of the form FILE:NAME:LINENUM for
   symbol table and line data SAL.  NULL if insufficient
   information. The caller is responsible for releasing any space
   allocated. */

static char *
extended_canonical_line_spec (struct symtab_and_line sal, const char *name)
{
  char *r;

  if (sal.symtab == NULL || sal.symtab->filename == NULL || sal.line <= 0)
    return NULL;

  r = (char *) xmalloc (strlen (name) + strlen (sal.symtab->filename)
			+ sizeof (sal.line) * 3 + 3);
  sprintf (r, "%s:'%s':%d", sal.symtab->filename, name, sal.line);
  return r;
}

#if 0
int begin_bnum = -1;
#endif
int begin_annotate_level = 0;

static void
begin_cleanup (void *dummy)
{
  begin_annotate_level = 0;
}

static void
begin_command (char *args, int from_tty)
{
  struct minimal_symbol *msym;
  CORE_ADDR main_program_name_addr;
  char main_program_name[1024];
  struct cleanup *old_chain = make_cleanup (begin_cleanup, NULL);
  begin_annotate_level = 2;

  /* Check that there is a program to debug */
  if (!have_full_symbols () && !have_partial_symbols ())
    error ("No symbol table is loaded.  Use the \"file\" command.");

  /* Check that we are debugging an Ada program */
  /*  if (ada_update_initial_language (language_unknown, NULL) != language_ada)
     error ("Cannot find the Ada initialization procedure.  Is this an Ada main program?");
   */
  /* FIXME: language_ada should be defined in defs.h */

  /* Get the address of the name of the main procedure */
  msym = lookup_minimal_symbol (ADA_MAIN_PROGRAM_SYMBOL_NAME, NULL, NULL);

  if (msym != NULL)
    {
      main_program_name_addr = SYMBOL_VALUE_ADDRESS (msym);
      if (main_program_name_addr == 0)
	error ("Invalid address for Ada main program name.");

      /* Read the name of the main procedure */
      extract_string (main_program_name_addr, main_program_name);

      /* Put a temporary breakpoint in the Ada main program and run */
      do_command ("tbreak ", main_program_name, 0);
      do_command ("run ", args, 0);
    }
  else
    {
      /* If we could not find the symbol containing the name of the
         main program, that means that the compiler that was used to build
         was not recent enough. In that case, we fallback to the previous
         mechanism, which is a little bit less reliable, but has proved to work
         in most cases. The only cases where it will fail is when the user
         has set some breakpoints which will be hit before the end of the
         begin command processing (eg in the initialization code).

         The begining of the main Ada subprogram is located by breaking
         on the adainit procedure. Since we know that the binder generates
         the call to this procedure exactly 2 calls before the call to the
         Ada main subprogram, it is then easy to put a breakpoint on this
         Ada main subprogram once we hit adainit.
       */
      do_command ("tbreak adainit", 0);
      do_command ("run ", args, 0);
      do_command ("up", 0);
      do_command ("tbreak +2", 0);
      do_command ("continue", 0);
      do_command ("step", 0);
    }

  do_cleanups (old_chain);
}

int
is_ada_runtime_file (char *filename)
{
  return (DEPRECATED_STREQN (filename, "s-", 2) ||
	  DEPRECATED_STREQN (filename, "a-", 2) ||
	  DEPRECATED_STREQN (filename, "g-", 2) || DEPRECATED_STREQN (filename, "i-", 2));
}

/* find the first frame that contains debugging information and that is not
   part of the Ada run-time, starting from fi and moving upward. */

int
find_printable_frame (struct frame_info *fi, int level)
{
  struct symtab_and_line sal;

  for (; fi != NULL; level += 1, fi = get_prev_frame (fi))
    {
      find_frame_sal (fi, &sal);
      if (sal.symtab && !is_ada_runtime_file (sal.symtab->filename))
	{
#if defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET)
	  /* libpthread.so contains some debugging information that prevents us
	     from finding the right frame */

	  if (sal.symtab->objfile &&
	      DEPRECATED_STREQ (sal.symtab->objfile->name, "/usr/shlib/libpthread.so"))
	    continue;
#endif
	  deprecated_selected_frame = fi;
	  break;
	}
    }

  return level;
}

void
ada_report_exception_break (struct breakpoint *b)
{
  /* FIXME: break_on_exception should be defined in breakpoint.h */
  /*  if (b->break_on_exception == 1)
     {
     /* Assume that cond has 16 elements, the 15th
   being the exception *//*
   if (b->cond && b->cond->nelts == 16)
   {
   ui_out_text (uiout, "on ");
   ui_out_field_string (uiout, "exception",
   SYMBOL_NAME (b->cond->elts[14].symbol));
   }
   else
   ui_out_text (uiout, "on all exceptions");
   }
   else if (b->break_on_exception == 2)
   ui_out_text (uiout, "on unhandled exception");
   else if (b->break_on_exception == 3)
   ui_out_text (uiout, "on assert failure");
   #else
   if (b->break_on_exception == 1)
   { */
  /* Assume that cond has 16 elements, the 15th
   being the exception *//*
   if (b->cond && b->cond->nelts == 16)
   {
   fputs_filtered ("on ", gdb_stdout);
   fputs_filtered (SYMBOL_NAME
   (b->cond->elts[14].symbol), gdb_stdout);
   }
   else
   fputs_filtered ("on all exceptions", gdb_stdout);
   }
   else if (b->break_on_exception == 2)
   fputs_filtered ("on unhandled exception", gdb_stdout);
   else if (b->break_on_exception == 3)
   fputs_filtered ("on assert failure", gdb_stdout);
 */
}

int
ada_is_exception_sym (struct symbol *sym)
{
  char *type_name = type_name_no_tag (SYMBOL_TYPE (sym));

  return (SYMBOL_CLASS (sym) != LOC_TYPEDEF
	  && SYMBOL_CLASS (sym) != LOC_BLOCK
	  && SYMBOL_CLASS (sym) != LOC_CONST
	  && type_name != NULL && DEPRECATED_STREQ (type_name, "exception"));
}

int
ada_maybe_exception_partial_symbol (struct partial_symbol *sym)
{
  return (SYMBOL_CLASS (sym) != LOC_TYPEDEF
	  && SYMBOL_CLASS (sym) != LOC_BLOCK
	  && SYMBOL_CLASS (sym) != LOC_CONST);
}

/* If ARG points to an Ada exception or assert breakpoint, rewrite
   into equivalent form.  Return resulting argument string. Set
   *BREAK_ON_EXCEPTIONP to 1 for ordinary break on exception, 2 for
   break on unhandled, 3 for assert, 0 otherwise. */
char *
ada_breakpoint_rewrite (char *arg, int *break_on_exceptionp)
{
  if (arg == NULL)
    return arg;
  *break_on_exceptionp = 0;
  /* FIXME: language_ada should be defined in defs.h */
  /*  if (current_language->la_language == language_ada
     && DEPRECATED_STREQN (arg, "exception", 9) &&
     (arg[9] == ' ' || arg[9] == '\t' || arg[9] == '\0'))
     {
     char *tok, *end_tok;
     int toklen;

     *break_on_exceptionp = 1;

     tok = arg+9;
     while (*tok == ' ' || *tok == '\t')
     tok += 1;

     end_tok = tok;

     while (*end_tok != ' ' && *end_tok != '\t' && *end_tok != '\000')
     end_tok += 1;

     toklen = end_tok - tok;

     arg = (char*) xmalloc (sizeof ("__gnat_raise_nodefer_with_msg if "
     "long_integer(e) = long_integer(&)")
     + toklen + 1);
     make_cleanup (xfree, arg);
     if (toklen == 0)
     strcpy (arg, "__gnat_raise_nodefer_with_msg");
     else if (DEPRECATED_STREQN (tok, "unhandled", toklen))
     {
     *break_on_exceptionp = 2;
     strcpy (arg, "__gnat_unhandled_exception");
     }
     else
     {
     sprintf (arg, "__gnat_raise_nodefer_with_msg if "
     "long_integer(e) = long_integer(&%.*s)", 
     toklen, tok);
     }
     }
     else if (current_language->la_language == language_ada
     && DEPRECATED_STREQN (arg, "assert", 6) &&
     (arg[6] == ' ' || arg[6] == '\t' || arg[6] == '\0'))
     {
     char *tok = arg + 6;

     *break_on_exceptionp = 3;

     arg = (char*) 
     xmalloc (sizeof ("system__assertions__raise_assert_failure")
     + strlen (tok) + 1);
     make_cleanup (xfree, arg);
     sprintf (arg, "system__assertions__raise_assert_failure%s", tok);
     }
   */
  return arg;
}


				/* Field Access */

/* True if field number FIELD_NUM in struct or union type TYPE is supposed
   to be invisible to users. */

int
ada_is_ignored_field (struct type *type, int field_num)
{
  if (field_num < 0 || field_num > TYPE_NFIELDS (type))
    return 1;
  else
    {
      const char *name = TYPE_FIELD_NAME (type, field_num);
      return (name == NULL
	      || (name[0] == '_' && !DEPRECATED_STREQN (name, "_parent", 7)));
    }
}

/* True iff structure type TYPE has a tag field. */

int
ada_is_tagged_type (struct type *type)
{
  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_STRUCT)
    return 0;

  return (ada_lookup_struct_elt_type (type, "_tag", 1, NULL) != NULL);
}

/* The type of the tag on VAL. */

struct type *
ada_tag_type (struct value *val)
{
  return ada_lookup_struct_elt_type (VALUE_TYPE (val), "_tag", 0, NULL);
}

/* The value of the tag on VAL. */

struct value *
ada_value_tag (struct value *val)
{
  return ada_value_struct_elt (val, "_tag", "record");
}

/* The parent type of TYPE, or NULL if none. */

struct type *
ada_parent_type (struct type *type)
{
  int i;

  CHECK_TYPEDEF (type);

  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_STRUCT)
    return NULL;

  for (i = 0; i < TYPE_NFIELDS (type); i += 1)
    if (ada_is_parent_field (type, i))
      return check_typedef (TYPE_FIELD_TYPE (type, i));

  return NULL;
}

/* True iff field number FIELD_NUM of structure type TYPE contains the 
   parent-type (inherited) fields of a derived type.  Assumes TYPE is 
   a structure type with at least FIELD_NUM+1 fields. */

int
ada_is_parent_field (struct type *type, int field_num)
{
  const char *name = TYPE_FIELD_NAME (check_typedef (type), field_num);
  return (name != NULL &&
	  (DEPRECATED_STREQN (name, "PARENT", 6) || DEPRECATED_STREQN (name, "_parent", 7)));
}

/* True iff field number FIELD_NUM of structure type TYPE is a 
   transparent wrapper field (which should be silently traversed when doing
   field selection and flattened when printing).  Assumes TYPE is a 
   structure type with at least FIELD_NUM+1 fields.  Such fields are always
   structures. */

int
ada_is_wrapper_field (struct type *type, int field_num)
{
  const char *name = TYPE_FIELD_NAME (type, field_num);
  return (name != NULL
	  && (DEPRECATED_STREQN (name, "PARENT", 6) || DEPRECATED_STREQ (name, "REP")
	      || DEPRECATED_STREQN (name, "_parent", 7)
	      || name[0] == 'S' || name[0] == 'R' || name[0] == 'O'));
}

/* True iff field number FIELD_NUM of structure or union type TYPE 
   is a variant wrapper.  Assumes TYPE is a structure type with at least 
   FIELD_NUM+1 fields. */

int
ada_is_variant_part (struct type *type, int field_num)
{
  struct type *field_type = TYPE_FIELD_TYPE (type, field_num);
  return (TYPE_CODE (field_type) == TYPE_CODE_UNION
	  || (is_dynamic_field (type, field_num)
	      && TYPE_CODE (TYPE_TARGET_TYPE (field_type)) ==
	      TYPE_CODE_UNION));
}

/* Assuming that VAR_TYPE is a variant wrapper (type of the variant part)
   whose discriminants are contained in the record type OUTER_TYPE, 
   returns the type of the controlling discriminant for the variant.  */

struct type *
ada_variant_discrim_type (struct type *var_type, struct type *outer_type)
{
  char *name = ada_variant_discrim_name (var_type);
  struct type *type = ada_lookup_struct_elt_type (outer_type, name, 1, NULL);
  if (type == NULL)
    return builtin_type_int;
  else
    return type;
}

/* Assuming that TYPE is the type of a variant wrapper, and FIELD_NUM is a 
   valid field number within it, returns 1 iff field FIELD_NUM of TYPE
   represents a 'when others' clause; otherwise 0. */

int
ada_is_others_clause (struct type *type, int field_num)
{
  const char *name = TYPE_FIELD_NAME (type, field_num);
  return (name != NULL && name[0] == 'O');
}

/* Assuming that TYPE0 is the type of the variant part of a record,
   returns the name of the discriminant controlling the variant.  The
   value is valid until the next call to ada_variant_discrim_name. */

char *
ada_variant_discrim_name (struct type *type0)
{
  static char *result = NULL;
  static size_t result_len = 0;
  struct type *type;
  const char *name;
  const char *discrim_end;
  const char *discrim_start;

  if (TYPE_CODE (type0) == TYPE_CODE_PTR)
    type = TYPE_TARGET_TYPE (type0);
  else
    type = type0;

  name = ada_type_name (type);

  if (name == NULL || name[0] == '\000')
    return "";

  for (discrim_end = name + strlen (name) - 6; discrim_end != name;
       discrim_end -= 1)
    {
      if (DEPRECATED_STREQN (discrim_end, "___XVN", 6))
	break;
    }
  if (discrim_end == name)
    return "";

  for (discrim_start = discrim_end; discrim_start != name + 3;
       discrim_start -= 1)
    {
      if (discrim_start == name + 1)
	return "";
      if ((discrim_start > name + 3 && DEPRECATED_STREQN (discrim_start - 3, "___", 3))
	  || discrim_start[-1] == '.')
	break;
    }

  GROW_VECT (result, result_len, discrim_end - discrim_start + 1);
  strncpy (result, discrim_start, discrim_end - discrim_start);
  result[discrim_end - discrim_start] = '\0';
  return result;
}

/* Scan STR for a subtype-encoded number, beginning at position K. Put the 
   position of the character just past the number scanned in *NEW_K, 
   if NEW_K!=NULL. Put the scanned number in *R, if R!=NULL.  Return 1 
   if there was a valid number at the given position, and 0 otherwise.  A 
   "subtype-encoded" number consists of the absolute value in decimal, 
   followed by the letter 'm' to indicate a negative number.  Assumes 0m 
   does not occur. */

int
ada_scan_number (const char str[], int k, LONGEST * R, int *new_k)
{
  ULONGEST RU;

  if (!isdigit (str[k]))
    return 0;

  /* Do it the hard way so as not to make any assumption about 
     the relationship of unsigned long (%lu scan format code) and
     LONGEST. */
  RU = 0;
  while (isdigit (str[k]))
    {
      RU = RU * 10 + (str[k] - '0');
      k += 1;
    }

  if (str[k] == 'm')
    {
      if (R != NULL)
	*R = (-(LONGEST) (RU - 1)) - 1;
      k += 1;
    }
  else if (R != NULL)
    *R = (LONGEST) RU;

  /* NOTE on the above: Technically, C does not say what the results of 
     - (LONGEST) RU or (LONGEST) -RU are for RU == largest positive
     number representable as a LONGEST (although either would probably work
     in most implementations).  When RU>0, the locution in the then branch
     above is always equivalent to the negative of RU. */

  if (new_k != NULL)
    *new_k = k;
  return 1;
}

/* Assuming that TYPE is a variant part wrapper type (a VARIANTS field), 
   and FIELD_NUM is a valid field number within it, returns 1 iff VAL is 
   in the range encoded by field FIELD_NUM of TYPE; otherwise 0. */

int
ada_in_variant (LONGEST val, struct type *type, int field_num)
{
  const char *name = TYPE_FIELD_NAME (type, field_num);
  int p;

  p = 0;
  while (1)
    {
      switch (name[p])
	{
	case '\0':
	  return 0;
	case 'S':
	  {
	    LONGEST W;
	    if (!ada_scan_number (name, p + 1, &W, &p))
	      return 0;
	    if (val == W)
	      return 1;
	    break;
	  }
	case 'R':
	  {
	    LONGEST L, U;
	    if (!ada_scan_number (name, p + 1, &L, &p)
		|| name[p] != 'T' || !ada_scan_number (name, p + 1, &U, &p))
	      return 0;
	    if (val >= L && val <= U)
	      return 1;
	    break;
	  }
	case 'O':
	  return 1;
	default:
	  return 0;
	}
    }
}

/* Given a value ARG1 (offset by OFFSET bytes)
   of a struct or union type ARG_TYPE,
   extract and return the value of one of its (non-static) fields.
   FIELDNO says which field.   Differs from value_primitive_field only
   in that it can handle packed values of arbitrary type. */

struct value *
ada_value_primitive_field (struct value *arg1, int offset, int fieldno,
			   struct type *arg_type)
{
  struct value *v;
  struct type *type;

  CHECK_TYPEDEF (arg_type);
  type = TYPE_FIELD_TYPE (arg_type, fieldno);

  /* Handle packed fields */

  if (TYPE_FIELD_BITSIZE (arg_type, fieldno) != 0)
    {
      int bit_pos = TYPE_FIELD_BITPOS (arg_type, fieldno);
      int bit_size = TYPE_FIELD_BITSIZE (arg_type, fieldno);

      return ada_value_primitive_packed_val (arg1, VALUE_CONTENTS (arg1),
					     offset + bit_pos / 8,
					     bit_pos % 8, bit_size, type);
    }
  else
    return value_primitive_field (arg1, offset, fieldno, arg_type);
}


/* Look for a field NAME in ARG. Adjust the address of ARG by OFFSET bytes,
   and search in it assuming it has (class) type TYPE.
   If found, return value, else return NULL.

   Searches recursively through wrapper fields (e.g., '_parent'). */

struct value *
ada_search_struct_field (char *name, struct value *arg, int offset,
			 struct type *type)
{
  int i;
  CHECK_TYPEDEF (type);

  for (i = TYPE_NFIELDS (type) - 1; i >= 0; i -= 1)
    {
      char *t_field_name = TYPE_FIELD_NAME (type, i);

      if (t_field_name == NULL)
	continue;

      else if (field_name_match (t_field_name, name))
	return ada_value_primitive_field (arg, offset, i, type);

      else if (ada_is_wrapper_field (type, i))
	{
	  struct value *v = ada_search_struct_field (name, arg,
						     offset +
						     TYPE_FIELD_BITPOS (type,
									i) /
						     8,
						     TYPE_FIELD_TYPE (type,
								      i));
	  if (v != NULL)
	    return v;
	}

      else if (ada_is_variant_part (type, i))
	{
	  int j;
	  struct type *field_type = check_typedef (TYPE_FIELD_TYPE (type, i));
	  int var_offset = offset + TYPE_FIELD_BITPOS (type, i) / 8;

	  for (j = TYPE_NFIELDS (field_type) - 1; j >= 0; j -= 1)
	    {
	      struct value *v = ada_search_struct_field (name, arg,
							 var_offset
							 +
							 TYPE_FIELD_BITPOS
							 (field_type, j) / 8,
							 TYPE_FIELD_TYPE
							 (field_type, j));
	      if (v != NULL)
		return v;
	    }
	}
    }
  return NULL;
}

/* Given ARG, a value of type (pointer to a)* structure/union,
   extract the component named NAME from the ultimate target structure/union
   and return it as a value with its appropriate type.

   The routine searches for NAME among all members of the structure itself 
   and (recursively) among all members of any wrapper members 
   (e.g., '_parent').

   ERR is a name (for use in error messages) that identifies the class 
   of entity that ARG is supposed to be. */

struct value *
ada_value_struct_elt (struct value *arg, char *name, char *err)
{
  struct type *t;
  struct value *v;

  arg = ada_coerce_ref (arg);
  t = check_typedef (VALUE_TYPE (arg));

  /* Follow pointers until we get to a non-pointer.  */

  while (TYPE_CODE (t) == TYPE_CODE_PTR || TYPE_CODE (t) == TYPE_CODE_REF)
    {
      arg = ada_value_ind (arg);
      t = check_typedef (VALUE_TYPE (arg));
    }

  if (TYPE_CODE (t) != TYPE_CODE_STRUCT && TYPE_CODE (t) != TYPE_CODE_UNION)
    error ("Attempt to extract a component of a value that is not a %s.",
	   err);

  v = ada_search_struct_field (name, arg, 0, t);
  if (v == NULL)
    error ("There is no member named %s.", name);

  return v;
}

/* Given a type TYPE, look up the type of the component of type named NAME.
   If DISPP is non-null, add its byte displacement from the beginning of a 
   structure (pointed to by a value) of type TYPE to *DISPP (does not 
   work for packed fields).

   Matches any field whose name has NAME as a prefix, possibly
   followed by "___". 

   TYPE can be either a struct or union, or a pointer or reference to 
   a struct or union.  If it is a pointer or reference, its target 
   type is automatically used.

   Looks recursively into variant clauses and parent types.

   If NOERR is nonzero, return NULL if NAME is not suitably defined. */

struct type *
ada_lookup_struct_elt_type (struct type *type, char *name, int noerr,
			    int *dispp)
{
  int i;

  if (name == NULL)
    goto BadName;

  while (1)
    {
      CHECK_TYPEDEF (type);
      if (TYPE_CODE (type) != TYPE_CODE_PTR
	  && TYPE_CODE (type) != TYPE_CODE_REF)
	break;
      type = TYPE_TARGET_TYPE (type);
    }

  if (TYPE_CODE (type) != TYPE_CODE_STRUCT &&
      TYPE_CODE (type) != TYPE_CODE_UNION)
    {
      target_terminal_ours ();
      gdb_flush (gdb_stdout);
      fprintf_unfiltered (gdb_stderr, "Type ");
      type_print (type, "", gdb_stderr, -1);
      error (" is not a structure or union type");
    }

  type = to_static_fixed_type (type);

  for (i = 0; i < TYPE_NFIELDS (type); i += 1)
    {
      char *t_field_name = TYPE_FIELD_NAME (type, i);
      struct type *t;
      int disp;

      if (t_field_name == NULL)
	continue;

      else if (field_name_match (t_field_name, name))
	{
	  if (dispp != NULL)
	    *dispp += TYPE_FIELD_BITPOS (type, i) / 8;
	  return check_typedef (TYPE_FIELD_TYPE (type, i));
	}

      else if (ada_is_wrapper_field (type, i))
	{
	  disp = 0;
	  t = ada_lookup_struct_elt_type (TYPE_FIELD_TYPE (type, i), name,
					  1, &disp);
	  if (t != NULL)
	    {
	      if (dispp != NULL)
		*dispp += disp + TYPE_FIELD_BITPOS (type, i) / 8;
	      return t;
	    }
	}

      else if (ada_is_variant_part (type, i))
	{
	  int j;
	  struct type *field_type = check_typedef (TYPE_FIELD_TYPE (type, i));

	  for (j = TYPE_NFIELDS (field_type) - 1; j >= 0; j -= 1)
	    {
	      disp = 0;
	      t = ada_lookup_struct_elt_type (TYPE_FIELD_TYPE (field_type, j),
					      name, 1, &disp);
	      if (t != NULL)
		{
		  if (dispp != NULL)
		    *dispp += disp + TYPE_FIELD_BITPOS (type, i) / 8;
		  return t;
		}
	    }
	}

    }

BadName:
  if (!noerr)
    {
      target_terminal_ours ();
      gdb_flush (gdb_stdout);
      fprintf_unfiltered (gdb_stderr, "Type ");
      type_print (type, "", gdb_stderr, -1);
      fprintf_unfiltered (gdb_stderr, " has no component named ");
      error ("%s", name == NULL ? "<null>" : name);
    }

  return NULL;
}

/* Assuming that VAR_TYPE is the type of a variant part of a record (a union),
   within a value of type OUTER_TYPE that is stored in GDB at
   OUTER_VALADDR, determine which variant clause (field number in VAR_TYPE, 
   numbering from 0) is applicable.  Returns -1 if none are. */

int
ada_which_variant_applies (struct type *var_type, struct type *outer_type,
			   char *outer_valaddr)
{
  int others_clause;
  int i;
  int disp;
  struct type *discrim_type;
  char *discrim_name = ada_variant_discrim_name (var_type);
  LONGEST discrim_val;

  disp = 0;
  discrim_type =
    ada_lookup_struct_elt_type (outer_type, discrim_name, 1, &disp);
  if (discrim_type == NULL)
    return -1;
  discrim_val = unpack_long (discrim_type, outer_valaddr + disp);

  others_clause = -1;
  for (i = 0; i < TYPE_NFIELDS (var_type); i += 1)
    {
      if (ada_is_others_clause (var_type, i))
	others_clause = i;
      else if (ada_in_variant (discrim_val, var_type, i))
	return i;
    }

  return others_clause;
}



				/* Dynamic-Sized Records */

/* Strategy: The type ostensibly attached to a value with dynamic size
   (i.e., a size that is not statically recorded in the debugging
   data) does not accurately reflect the size or layout of the value.
   Our strategy is to convert these values to values with accurate,
   conventional types that are constructed on the fly. */

/* There is a subtle and tricky problem here.  In general, we cannot
   determine the size of dynamic records without its data.  However,
   the 'struct value' data structure, which GDB uses to represent
   quantities in the inferior process (the target), requires the size
   of the type at the time of its allocation in order to reserve space
   for GDB's internal copy of the data.  That's why the
   'to_fixed_xxx_type' routines take (target) addresses as parameters,
   rather than struct value*s.  

   However, GDB's internal history variables ($1, $2, etc.) are
   struct value*s containing internal copies of the data that are not, in
   general, the same as the data at their corresponding addresses in
   the target.  Fortunately, the types we give to these values are all
   conventional, fixed-size types (as per the strategy described
   above), so that we don't usually have to perform the
   'to_fixed_xxx_type' conversions to look at their values.
   Unfortunately, there is one exception: if one of the internal
   history variables is an array whose elements are unconstrained
   records, then we will need to create distinct fixed types for each
   element selected.  */

/* The upshot of all of this is that many routines take a (type, host
   address, target address) triple as arguments to represent a value.
   The host address, if non-null, is supposed to contain an internal
   copy of the relevant data; otherwise, the program is to consult the
   target at the target address. */

/* Assuming that VAL0 represents a pointer value, the result of
   dereferencing it.  Differs from value_ind in its treatment of
   dynamic-sized types. */

struct value *
ada_value_ind (struct value *val0)
{
  struct value *val = unwrap_value (value_ind (val0));
  return ada_to_fixed_value (VALUE_TYPE (val), 0,
			     VALUE_ADDRESS (val) + VALUE_OFFSET (val), val);
}

/* The value resulting from dereferencing any "reference to"
 * qualifiers on VAL0. */
static struct value *
ada_coerce_ref (struct value *val0)
{
  if (TYPE_CODE (VALUE_TYPE (val0)) == TYPE_CODE_REF)
    {
      struct value *val = val0;
      COERCE_REF (val);
      val = unwrap_value (val);
      return ada_to_fixed_value (VALUE_TYPE (val), 0,
				 VALUE_ADDRESS (val) + VALUE_OFFSET (val),
				 val);
    }
  else
    return val0;
}

/* Return OFF rounded upward if necessary to a multiple of
   ALIGNMENT (a power of 2). */

static unsigned int
align_value (unsigned int off, unsigned int alignment)
{
  return (off + alignment - 1) & ~(alignment - 1);
}

/* Return the additional bit offset required by field F of template
   type TYPE. */

static unsigned int
field_offset (struct type *type, int f)
{
  int n = TYPE_FIELD_BITPOS (type, f);
  /* Kludge (temporary?) to fix problem with dwarf output. */
  if (n < 0)
    return (unsigned int) n & 0xffff;
  else
    return n;
}


/* Return the bit alignment required for field #F of template type TYPE. */

static unsigned int
field_alignment (struct type *type, int f)
{
  const char *name = TYPE_FIELD_NAME (type, f);
  int len = (name == NULL) ? 0 : strlen (name);
  int align_offset;

  if (len < 8 || !isdigit (name[len - 1]))
    return TARGET_CHAR_BIT;

  if (isdigit (name[len - 2]))
    align_offset = len - 2;
  else
    align_offset = len - 1;

  if (align_offset < 7 || !DEPRECATED_STREQN ("___XV", name + align_offset - 6, 5))
    return TARGET_CHAR_BIT;

  return atoi (name + align_offset) * TARGET_CHAR_BIT;
}

/* Find a type named NAME.  Ignores ambiguity.  */
struct type *
ada_find_any_type (const char *name)
{
  struct symbol *sym;

  sym = standard_lookup (name, VAR_DOMAIN);
  if (sym != NULL && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
    return SYMBOL_TYPE (sym);

  sym = standard_lookup (name, STRUCT_DOMAIN);
  if (sym != NULL)
    return SYMBOL_TYPE (sym);

  return NULL;
}

/* Because of GNAT encoding conventions, several GDB symbols may match a
   given type name. If the type denoted by TYPE0 is to be preferred to
   that of TYPE1 for purposes of type printing, return non-zero;
   otherwise return 0. */
int
ada_prefer_type (struct type *type0, struct type *type1)
{
  if (type1 == NULL)
    return 1;
  else if (type0 == NULL)
    return 0;
  else if (TYPE_CODE (type1) == TYPE_CODE_VOID)
    return 1;
  else if (TYPE_CODE (type0) == TYPE_CODE_VOID)
    return 0;
  else if (ada_is_packed_array_type (type0))
    return 1;
  else if (ada_is_array_descriptor (type0)
	   && !ada_is_array_descriptor (type1))
    return 1;
  else if (ada_renaming_type (type0) != NULL
	   && ada_renaming_type (type1) == NULL)
    return 1;
  return 0;
}

/* The name of TYPE, which is either its TYPE_NAME, or, if that is
   null, its TYPE_TAG_NAME.  Null if TYPE is null. */
char *
ada_type_name (struct type *type)
{
  if (type == NULL)
    return NULL;
  else if (TYPE_NAME (type) != NULL)
    return TYPE_NAME (type);
  else
    return TYPE_TAG_NAME (type);
}

/* Find a parallel type to TYPE whose name is formed by appending
   SUFFIX to the name of TYPE. */

struct type *
ada_find_parallel_type (struct type *type, const char *suffix)
{
  static char *name;
  static size_t name_len = 0;
  struct symbol **syms;
  struct block **blocks;
  int nsyms;
  int len;
  char *typename = ada_type_name (type);

  if (typename == NULL)
    return NULL;

  len = strlen (typename);

  GROW_VECT (name, name_len, len + strlen (suffix) + 1);

  strcpy (name, typename);
  strcpy (name + len, suffix);

  return ada_find_any_type (name);
}


/* If TYPE is a variable-size record type, return the corresponding template
   type describing its fields.  Otherwise, return NULL. */

static struct type *
dynamic_template_type (struct type *type)
{
  CHECK_TYPEDEF (type);

  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_STRUCT
      || ada_type_name (type) == NULL)
    return NULL;
  else
    {
      int len = strlen (ada_type_name (type));
      if (len > 6 && DEPRECATED_STREQ (ada_type_name (type) + len - 6, "___XVE"))
	return type;
      else
	return ada_find_parallel_type (type, "___XVE");
    }
}

/* Assuming that TEMPL_TYPE is a union or struct type, returns
   non-zero iff field FIELD_NUM of TEMPL_TYPE has dynamic size. */

static int
is_dynamic_field (struct type *templ_type, int field_num)
{
  const char *name = TYPE_FIELD_NAME (templ_type, field_num);
  return name != NULL
    && TYPE_CODE (TYPE_FIELD_TYPE (templ_type, field_num)) == TYPE_CODE_PTR
    && strstr (name, "___XVL") != NULL;
}

/* Assuming that TYPE is a struct type, returns non-zero iff TYPE
   contains a variant part. */

static int
contains_variant_part (struct type *type)
{
  int f;

  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_STRUCT
      || TYPE_NFIELDS (type) <= 0)
    return 0;
  return ada_is_variant_part (type, TYPE_NFIELDS (type) - 1);
}

/* A record type with no fields, . */
static struct type *
empty_record (struct objfile *objfile)
{
  struct type *type = alloc_type (objfile);
  TYPE_CODE (type) = TYPE_CODE_STRUCT;
  TYPE_NFIELDS (type) = 0;
  TYPE_FIELDS (type) = NULL;
  TYPE_NAME (type) = "<empty>";
  TYPE_TAG_NAME (type) = NULL;
  TYPE_FLAGS (type) = 0;
  TYPE_LENGTH (type) = 0;
  return type;
}

/* An ordinary record type (with fixed-length fields) that describes
   the value of type TYPE at VALADDR or ADDRESS (see comments at 
   the beginning of this section) VAL according to GNAT conventions.  
   DVAL0 should describe the (portion of a) record that contains any 
   necessary discriminants.  It should be NULL if VALUE_TYPE (VAL) is
   an outer-level type (i.e., as opposed to a branch of a variant.)  A
   variant field (unless unchecked) is replaced by a particular branch
   of the variant. */
/* NOTE: Limitations: For now, we assume that dynamic fields and
 * variants occupy whole numbers of bytes.  However, they need not be
 * byte-aligned.  */

static struct type *
template_to_fixed_record_type (struct type *type, char *valaddr,
			       CORE_ADDR address, struct value *dval0)
{
  struct value *mark = value_mark ();
  struct value *dval;
  struct type *rtype;
  int nfields, bit_len;
  long off;
  int f;

  nfields = TYPE_NFIELDS (type);
  rtype = alloc_type (TYPE_OBJFILE (type));
  TYPE_CODE (rtype) = TYPE_CODE_STRUCT;
  INIT_CPLUS_SPECIFIC (rtype);
  TYPE_NFIELDS (rtype) = nfields;
  TYPE_FIELDS (rtype) = (struct field *)
    TYPE_ALLOC (rtype, nfields * sizeof (struct field));
  memset (TYPE_FIELDS (rtype), 0, sizeof (struct field) * nfields);
  TYPE_NAME (rtype) = ada_type_name (type);
  TYPE_TAG_NAME (rtype) = NULL;
  /* FIXME: TYPE_FLAG_FIXED_INSTANCE should be defined in
     gdbtypes.h */
  /*  TYPE_FLAGS (rtype) |= TYPE_FLAG_FIXED_INSTANCE; */

  off = 0;
  bit_len = 0;
  for (f = 0; f < nfields; f += 1)
    {
      int fld_bit_len, bit_incr;
      off =
	align_value (off,
		     field_alignment (type, f)) + TYPE_FIELD_BITPOS (type, f);
      /* NOTE: used to use field_offset above, but that causes
       * problems with really negative bit positions.  So, let's
       * rediscover why we needed field_offset and fix it properly. */
      TYPE_FIELD_BITPOS (rtype, f) = off;
      TYPE_FIELD_BITSIZE (rtype, f) = 0;
      TYPE_FIELD_STATIC_KIND (rtype, f) = 0;

      if (ada_is_variant_part (type, f))
	{
	  struct type *branch_type;

	  if (dval0 == NULL)
	    dval = value_from_contents_and_address (rtype, valaddr, address);
	  else
	    dval = dval0;

	  branch_type =
	    to_fixed_variant_branch_type
	    (TYPE_FIELD_TYPE (type, f),
	     cond_offset_host (valaddr, off / TARGET_CHAR_BIT),
	     cond_offset_target (address, off / TARGET_CHAR_BIT), dval);
	  if (branch_type == NULL)
	    TYPE_NFIELDS (rtype) -= 1;
	  else
	    {
	      TYPE_FIELD_TYPE (rtype, f) = branch_type;
	      TYPE_FIELD_NAME (rtype, f) = "S";
	    }
	  bit_incr = 0;
	  fld_bit_len =
	    TYPE_LENGTH (TYPE_FIELD_TYPE (rtype, f)) * TARGET_CHAR_BIT;
	}
      else if (is_dynamic_field (type, f))
	{
	  if (dval0 == NULL)
	    dval = value_from_contents_and_address (rtype, valaddr, address);
	  else
	    dval = dval0;

	  TYPE_FIELD_TYPE (rtype, f) =
	    ada_to_fixed_type
	    (ada_get_base_type
	     (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, f))),
	     cond_offset_host (valaddr, off / TARGET_CHAR_BIT),
	     cond_offset_target (address, off / TARGET_CHAR_BIT), dval);
	  TYPE_FIELD_NAME (rtype, f) = TYPE_FIELD_NAME (type, f);
	  bit_incr = fld_bit_len =
	    TYPE_LENGTH (TYPE_FIELD_TYPE (rtype, f)) * TARGET_CHAR_BIT;
	}
      else
	{
	  TYPE_FIELD_TYPE (rtype, f) = TYPE_FIELD_TYPE (type, f);
	  TYPE_FIELD_NAME (rtype, f) = TYPE_FIELD_NAME (type, f);
	  if (TYPE_FIELD_BITSIZE (type, f) > 0)
	    bit_incr = fld_bit_len =
	      TYPE_FIELD_BITSIZE (rtype, f) = TYPE_FIELD_BITSIZE (type, f);
	  else
	    bit_incr = fld_bit_len =
	      TYPE_LENGTH (TYPE_FIELD_TYPE (type, f)) * TARGET_CHAR_BIT;
	}
      if (off + fld_bit_len > bit_len)
	bit_len = off + fld_bit_len;
      off += bit_incr;
      TYPE_LENGTH (rtype) = bit_len / TARGET_CHAR_BIT;
    }
  TYPE_LENGTH (rtype) = align_value (TYPE_LENGTH (rtype), TYPE_LENGTH (type));

  value_free_to_mark (mark);
  if (TYPE_LENGTH (rtype) > varsize_limit)
    error ("record type with dynamic size is larger than varsize-limit");
  return rtype;
}

/* As for template_to_fixed_record_type, but uses no run-time values.
   As a result, this type can only be approximate, but that's OK,
   since it is used only for type determinations.   Works on both
   structs and unions.
   Representation note: to save space, we memoize the result of this
   function in the TYPE_TARGET_TYPE of the template type. */

static struct type *
template_to_static_fixed_type (struct type *templ_type)
{
  struct type *type;
  int nfields;
  int f;

  if (TYPE_TARGET_TYPE (templ_type) != NULL)
    return TYPE_TARGET_TYPE (templ_type);

  nfields = TYPE_NFIELDS (templ_type);
  TYPE_TARGET_TYPE (templ_type) = type =
    alloc_type (TYPE_OBJFILE (templ_type));
  TYPE_CODE (type) = TYPE_CODE (templ_type);
  INIT_CPLUS_SPECIFIC (type);
  TYPE_NFIELDS (type) = nfields;
  TYPE_FIELDS (type) = (struct field *)
    TYPE_ALLOC (type, nfields * sizeof (struct field));
  memset (TYPE_FIELDS (type), 0, sizeof (struct field) * nfields);
  TYPE_NAME (type) = ada_type_name (templ_type);
  TYPE_TAG_NAME (type) = NULL;
  /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
  /*  TYPE_FLAGS (type) |= TYPE_FLAG_FIXED_INSTANCE; */
  TYPE_LENGTH (type) = 0;

  for (f = 0; f < nfields; f += 1)
    {
      TYPE_FIELD_BITPOS (type, f) = 0;
      TYPE_FIELD_BITSIZE (type, f) = 0;
      TYPE_FIELD_STATIC_KIND (type, f) = 0;

      if (is_dynamic_field (templ_type, f))
	{
	  TYPE_FIELD_TYPE (type, f) =
	    to_static_fixed_type (TYPE_TARGET_TYPE
				  (TYPE_FIELD_TYPE (templ_type, f)));
	  TYPE_FIELD_NAME (type, f) = TYPE_FIELD_NAME (templ_type, f);
	}
      else
	{
	  TYPE_FIELD_TYPE (type, f) =
	    check_typedef (TYPE_FIELD_TYPE (templ_type, f));
	  TYPE_FIELD_NAME (type, f) = TYPE_FIELD_NAME (templ_type, f);
	}
    }

  return type;
}

/* A revision of TYPE0 -- a non-dynamic-sized record with a variant
   part -- in which the variant part is replaced with the appropriate
   branch. */
static struct type *
to_record_with_fixed_variant_part (struct type *type, char *valaddr,
				   CORE_ADDR address, struct value *dval)
{
  struct value *mark = value_mark ();
  struct type *rtype;
  struct type *branch_type;
  int nfields = TYPE_NFIELDS (type);

  if (dval == NULL)
    return type;

  rtype = alloc_type (TYPE_OBJFILE (type));
  TYPE_CODE (rtype) = TYPE_CODE_STRUCT;
  INIT_CPLUS_SPECIFIC (type);
  TYPE_NFIELDS (rtype) = TYPE_NFIELDS (type);
  TYPE_FIELDS (rtype) =
    (struct field *) TYPE_ALLOC (rtype, nfields * sizeof (struct field));
  memcpy (TYPE_FIELDS (rtype), TYPE_FIELDS (type),
	  sizeof (struct field) * nfields);
  TYPE_NAME (rtype) = ada_type_name (type);
  TYPE_TAG_NAME (rtype) = NULL;
  /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
  /*  TYPE_FLAGS (rtype) |= TYPE_FLAG_FIXED_INSTANCE; */
  TYPE_LENGTH (rtype) = TYPE_LENGTH (type);

  branch_type =
    to_fixed_variant_branch_type
    (TYPE_FIELD_TYPE (type, nfields - 1),
     cond_offset_host (valaddr,
		       TYPE_FIELD_BITPOS (type,
					  nfields - 1) / TARGET_CHAR_BIT),
     cond_offset_target (address,
			 TYPE_FIELD_BITPOS (type,
					    nfields - 1) / TARGET_CHAR_BIT),
     dval);
  if (branch_type == NULL)
    {
      TYPE_NFIELDS (rtype) -= 1;
      TYPE_LENGTH (rtype) -=
	TYPE_LENGTH (TYPE_FIELD_TYPE (type, nfields - 1));
    }
  else
    {
      TYPE_FIELD_TYPE (rtype, nfields - 1) = branch_type;
      TYPE_FIELD_NAME (rtype, nfields - 1) = "S";
      TYPE_FIELD_BITSIZE (rtype, nfields - 1) = 0;
      TYPE_FIELD_STATIC_KIND (rtype, nfields - 1) = 0;
      TYPE_LENGTH (rtype) += TYPE_LENGTH (branch_type);
      -TYPE_LENGTH (TYPE_FIELD_TYPE (type, nfields - 1));
    }

  return rtype;
}

/* An ordinary record type (with fixed-length fields) that describes
   the value at (TYPE0, VALADDR, ADDRESS) [see explanation at
   beginning of this section].   Any necessary discriminants' values
   should be in DVAL, a record value; it should be NULL if the object
   at ADDR itself contains any necessary  discriminant values.  A
   variant field (unless unchecked) is replaced by a particular branch
   of the variant. */

static struct type *
to_fixed_record_type (struct type *type0, char *valaddr, CORE_ADDR address,
		      struct value *dval)
{
  struct type *templ_type;

  /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
  /*  if (TYPE_FLAGS (type0) & TYPE_FLAG_FIXED_INSTANCE)
     return type0;
   */
  templ_type = dynamic_template_type (type0);

  if (templ_type != NULL)
    return template_to_fixed_record_type (templ_type, valaddr, address, dval);
  else if (contains_variant_part (type0))
    return to_record_with_fixed_variant_part (type0, valaddr, address, dval);
  else
    {
      /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
      /*      TYPE_FLAGS (type0) |= TYPE_FLAG_FIXED_INSTANCE; */
      return type0;
    }

}

/* An ordinary record type (with fixed-length fields) that describes
   the value at (VAR_TYPE0, VALADDR, ADDRESS), where VAR_TYPE0 is a
   union type.  Any necessary discriminants' values should be in DVAL,
   a record value.  That is, this routine selects the appropriate
   branch of the union at ADDR according to the discriminant value
   indicated in the union's type name. */

static struct type *
to_fixed_variant_branch_type (struct type *var_type0, char *valaddr,
			      CORE_ADDR address, struct value *dval)
{
  int which;
  struct type *templ_type;
  struct type *var_type;

  if (TYPE_CODE (var_type0) == TYPE_CODE_PTR)
    var_type = TYPE_TARGET_TYPE (var_type0);
  else
    var_type = var_type0;

  templ_type = ada_find_parallel_type (var_type, "___XVU");

  if (templ_type != NULL)
    var_type = templ_type;

  which =
    ada_which_variant_applies (var_type,
			       VALUE_TYPE (dval), VALUE_CONTENTS (dval));

  if (which < 0)
    return empty_record (TYPE_OBJFILE (var_type));
  else if (is_dynamic_field (var_type, which))
    return
      to_fixed_record_type
      (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (var_type, which)),
       valaddr, address, dval);
  else if (contains_variant_part (TYPE_FIELD_TYPE (var_type, which)))
    return
      to_fixed_record_type
      (TYPE_FIELD_TYPE (var_type, which), valaddr, address, dval);
  else
    return TYPE_FIELD_TYPE (var_type, which);
}

/* Assuming that TYPE0 is an array type describing the type of a value
   at ADDR, and that DVAL describes a record containing any
   discriminants used in TYPE0, returns a type for the value that
   contains no dynamic components (that is, no components whose sizes
   are determined by run-time quantities).  Unless IGNORE_TOO_BIG is
   true, gives an error message if the resulting type's size is over
   varsize_limit.
*/

static struct type *
to_fixed_array_type (struct type *type0, struct value *dval,
		     int ignore_too_big)
{
  struct type *index_type_desc;
  struct type *result;

  /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
/*  if (ada_is_packed_array_type (type0)  /* revisit? *//*
   || (TYPE_FLAGS (type0) & TYPE_FLAG_FIXED_INSTANCE))
   return type0; */

  index_type_desc = ada_find_parallel_type (type0, "___XA");
  if (index_type_desc == NULL)
    {
      struct type *elt_type0 = check_typedef (TYPE_TARGET_TYPE (type0));
      /* NOTE: elt_type---the fixed version of elt_type0---should never
       * depend on the contents of the array in properly constructed
       * debugging data. */
      struct type *elt_type = ada_to_fixed_type (elt_type0, 0, 0, dval);

      if (elt_type0 == elt_type)
	result = type0;
      else
	result = create_array_type (alloc_type (TYPE_OBJFILE (type0)),
				    elt_type, TYPE_INDEX_TYPE (type0));
    }
  else
    {
      int i;
      struct type *elt_type0;

      elt_type0 = type0;
      for (i = TYPE_NFIELDS (index_type_desc); i > 0; i -= 1)
	elt_type0 = TYPE_TARGET_TYPE (elt_type0);

      /* NOTE: result---the fixed version of elt_type0---should never
       * depend on the contents of the array in properly constructed
       * debugging data. */
      result = ada_to_fixed_type (check_typedef (elt_type0), 0, 0, dval);
      for (i = TYPE_NFIELDS (index_type_desc) - 1; i >= 0; i -= 1)
	{
	  struct type *range_type =
	    to_fixed_range_type (TYPE_FIELD_NAME (index_type_desc, i),
				 dval, TYPE_OBJFILE (type0));
	  result = create_array_type (alloc_type (TYPE_OBJFILE (type0)),
				      result, range_type);
	}
      if (!ignore_too_big && TYPE_LENGTH (result) > varsize_limit)
	error ("array type with dynamic size is larger than varsize-limit");
    }

/* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
/*  TYPE_FLAGS (result) |= TYPE_FLAG_FIXED_INSTANCE; */
  return result;
}


/* A standard type (containing no dynamically sized components)
   corresponding to TYPE for the value (TYPE, VALADDR, ADDRESS)
   DVAL describes a record containing any discriminants used in TYPE0,
   and may be NULL if there are none. */

struct type *
ada_to_fixed_type (struct type *type, char *valaddr, CORE_ADDR address,
		   struct value *dval)
{
  CHECK_TYPEDEF (type);
  switch (TYPE_CODE (type))
    {
    default:
      return type;
    case TYPE_CODE_STRUCT:
      return to_fixed_record_type (type, valaddr, address, NULL);
    case TYPE_CODE_ARRAY:
      return to_fixed_array_type (type, dval, 0);
    case TYPE_CODE_UNION:
      if (dval == NULL)
	return type;
      else
	return to_fixed_variant_branch_type (type, valaddr, address, dval);
    }
}

/* A standard (static-sized) type corresponding as well as possible to
   TYPE0, but based on no runtime data. */

static struct type *
to_static_fixed_type (struct type *type0)
{
  struct type *type;

  if (type0 == NULL)
    return NULL;

  /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
  /*  if (TYPE_FLAGS (type0) & TYPE_FLAG_FIXED_INSTANCE)
     return type0;
   */
  CHECK_TYPEDEF (type0);

  switch (TYPE_CODE (type0))
    {
    default:
      return type0;
    case TYPE_CODE_STRUCT:
      type = dynamic_template_type (type0);
      if (type != NULL)
	return template_to_static_fixed_type (type);
      return type0;
    case TYPE_CODE_UNION:
      type = ada_find_parallel_type (type0, "___XVU");
      if (type != NULL)
	return template_to_static_fixed_type (type);
      return type0;
    }
}

/* A static approximation of TYPE with all type wrappers removed. */
static struct type *
static_unwrap_type (struct type *type)
{
  if (ada_is_aligner_type (type))
    {
      struct type *type1 = TYPE_FIELD_TYPE (check_typedef (type), 0);
      if (ada_type_name (type1) == NULL)
	TYPE_NAME (type1) = ada_type_name (type);

      return static_unwrap_type (type1);
    }
  else
    {
      struct type *raw_real_type = ada_get_base_type (type);
      if (raw_real_type == type)
	return type;
      else
	return to_static_fixed_type (raw_real_type);
    }
}

/* In some cases, incomplete and private types require
   cross-references that are not resolved as records (for example, 
      type Foo;
      type FooP is access Foo;
      V: FooP;
      type Foo is array ...;
   ). In these cases, since there is no mechanism for producing 
   cross-references to such types, we instead substitute for FooP a
   stub enumeration type that is nowhere resolved, and whose tag is
   the name of the actual type.  Call these types "non-record stubs". */

/* A type equivalent to TYPE that is not a non-record stub, if one
   exists, otherwise TYPE. */
struct type *
ada_completed_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_ENUM
      || (TYPE_FLAGS (type) & TYPE_FLAG_STUB) == 0
      || TYPE_TAG_NAME (type) == NULL)
    return type;
  else
    {
      char *name = TYPE_TAG_NAME (type);
      struct type *type1 = ada_find_any_type (name);
      return (type1 == NULL) ? type : type1;
    }
}

/* A value representing the data at VALADDR/ADDRESS as described by
   type TYPE0, but with a standard (static-sized) type that correctly
   describes it.  If VAL0 is not NULL and TYPE0 already is a standard
   type, then return VAL0 [this feature is simply to avoid redundant
   creation of struct values]. */

struct value *
ada_to_fixed_value (struct type *type0, char *valaddr, CORE_ADDR address,
		    struct value *val0)
{
  struct type *type = ada_to_fixed_type (type0, valaddr, address, NULL);
  if (type == type0 && val0 != NULL)
    return val0;
  else
    return value_from_contents_and_address (type, valaddr, address);
}

/* A value representing VAL, but with a standard (static-sized) type 
   chosen to approximate the real type of VAL as well as possible, but
   without consulting any runtime values.  For Ada dynamic-sized
   types, therefore, the type of the result is likely to be inaccurate. */

struct value *
ada_to_static_fixed_value (struct value *val)
{
  struct type *type =
    to_static_fixed_type (static_unwrap_type (VALUE_TYPE (val)));
  if (type == VALUE_TYPE (val))
    return val;
  else
    return coerce_unspec_val_to_type (val, 0, type);
}





/* Attributes */

/* Table mapping attribute numbers to names */
/* NOTE: Keep up to date with enum ada_attribute definition in ada-lang.h */

static const char *attribute_names[] = {
  "<?>",

  "first",
  "last",
  "length",
  "image",
  "img",
  "max",
  "min",
  "pos" "tag",
  "val",

  0
};

const char *
ada_attribute_name (int n)
{
  if (n > 0 && n < (int) ATR_END)
    return attribute_names[n];
  else
    return attribute_names[0];
}

/* Evaluate the 'POS attribute applied to ARG. */

static struct value *
value_pos_atr (struct value *arg)
{
  struct type *type = VALUE_TYPE (arg);

  if (!discrete_type_p (type))
    error ("'POS only defined on discrete types");

  if (TYPE_CODE (type) == TYPE_CODE_ENUM)
    {
      int i;
      LONGEST v = value_as_long (arg);

      for (i = 0; i < TYPE_NFIELDS (type); i += 1)
	{
	  if (v == TYPE_FIELD_BITPOS (type, i))
	    return value_from_longest (builtin_type_ada_int, i);
	}
      error ("enumeration value is invalid: can't find 'POS");
    }
  else
    return value_from_longest (builtin_type_ada_int, value_as_long (arg));
}

/* Evaluate the TYPE'VAL attribute applied to ARG. */

static struct value *
value_val_atr (struct type *type, struct value *arg)
{
  if (!discrete_type_p (type))
    error ("'VAL only defined on discrete types");
  if (!integer_type_p (VALUE_TYPE (arg)))
    error ("'VAL requires integral argument");

  if (TYPE_CODE (type) == TYPE_CODE_ENUM)
    {
      long pos = value_as_long (arg);
      if (pos < 0 || pos >= TYPE_NFIELDS (type))
	error ("argument to 'VAL out of range");
      return value_from_longest (type, TYPE_FIELD_BITPOS (type, pos));
    }
  else
    return value_from_longest (type, value_as_long (arg));
}


				/* Evaluation */

/* True if TYPE appears to be an Ada character type.  
 * [At the moment, this is true only for Character and Wide_Character;
 * It is a heuristic test that could stand improvement]. */

int
ada_is_character_type (struct type *type)
{
  const char *name = ada_type_name (type);
  return
    name != NULL
    && (TYPE_CODE (type) == TYPE_CODE_CHAR
	|| TYPE_CODE (type) == TYPE_CODE_INT
	|| TYPE_CODE (type) == TYPE_CODE_RANGE)
    && (DEPRECATED_STREQ (name, "character") || DEPRECATED_STREQ (name, "wide_character")
	|| DEPRECATED_STREQ (name, "unsigned char"));
}

/* True if TYPE appears to be an Ada string type. */

int
ada_is_string_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  if (type != NULL
      && TYPE_CODE (type) != TYPE_CODE_PTR
      && (ada_is_simple_array (type) || ada_is_array_descriptor (type))
      && ada_array_arity (type) == 1)
    {
      struct type *elttype = ada_array_element_type (type, 1);

      return ada_is_character_type (elttype);
    }
  else
    return 0;
}


/* True if TYPE is a struct type introduced by the compiler to force the
   alignment of a value.  Such types have a single field with a
   distinctive name. */

int
ada_is_aligner_type (struct type *type)
{
  CHECK_TYPEDEF (type);
  return (TYPE_CODE (type) == TYPE_CODE_STRUCT
	  && TYPE_NFIELDS (type) == 1
	  && DEPRECATED_STREQ (TYPE_FIELD_NAME (type, 0), "F"));
}

/* If there is an ___XVS-convention type parallel to SUBTYPE, return
   the parallel type. */

struct type *
ada_get_base_type (struct type *raw_type)
{
  struct type *real_type_namer;
  struct type *raw_real_type;
  struct type *real_type;

  if (raw_type == NULL || TYPE_CODE (raw_type) != TYPE_CODE_STRUCT)
    return raw_type;

  real_type_namer = ada_find_parallel_type (raw_type, "___XVS");
  if (real_type_namer == NULL
      || TYPE_CODE (real_type_namer) != TYPE_CODE_STRUCT
      || TYPE_NFIELDS (real_type_namer) != 1)
    return raw_type;

  raw_real_type = ada_find_any_type (TYPE_FIELD_NAME (real_type_namer, 0));
  if (raw_real_type == NULL)
    return raw_type;
  else
    return raw_real_type;
}

/* The type of value designated by TYPE, with all aligners removed. */

struct type *
ada_aligned_type (struct type *type)
{
  if (ada_is_aligner_type (type))
    return ada_aligned_type (TYPE_FIELD_TYPE (type, 0));
  else
    return ada_get_base_type (type);
}


/* The address of the aligned value in an object at address VALADDR
   having type TYPE.  Assumes ada_is_aligner_type (TYPE). */

char *
ada_aligned_value_addr (struct type *type, char *valaddr)
{
  if (ada_is_aligner_type (type))
    return ada_aligned_value_addr (TYPE_FIELD_TYPE (type, 0),
				   valaddr +
				   TYPE_FIELD_BITPOS (type,
						      0) / TARGET_CHAR_BIT);
  else
    return valaddr;
}

/* The printed representation of an enumeration literal with encoded
   name NAME. The value is good to the next call of ada_enum_name. */
const char *
ada_enum_name (const char *name)
{
  char *tmp;

  while (1)
    {
      if ((tmp = strstr (name, "__")) != NULL)
	name = tmp + 2;
      else if ((tmp = strchr (name, '.')) != NULL)
	name = tmp + 1;
      else
	break;
    }

  if (name[0] == 'Q')
    {
      static char result[16];
      int v;
      if (name[1] == 'U' || name[1] == 'W')
	{
	  if (sscanf (name + 2, "%x", &v) != 1)
	    return name;
	}
      else
	return name;

      if (isascii (v) && isprint (v))
	sprintf (result, "'%c'", v);
      else if (name[1] == 'U')
	sprintf (result, "[\"%02x\"]", v);
      else
	sprintf (result, "[\"%04x\"]", v);

      return result;
    }
  else
    return name;
}

static struct value *
evaluate_subexp (struct type *expect_type, struct expression *exp, int *pos,
		 enum noside noside)
{
  return (*exp->language_defn->evaluate_exp) (expect_type, exp, pos, noside);
}

/* Evaluate the subexpression of EXP starting at *POS as for
   evaluate_type, updating *POS to point just past the evaluated
   expression. */

static struct value *
evaluate_subexp_type (struct expression *exp, int *pos)
{
  return (*exp->language_defn->evaluate_exp)
    (NULL_TYPE, exp, pos, EVAL_AVOID_SIDE_EFFECTS);
}

/* If VAL is wrapped in an aligner or subtype wrapper, return the
   value it wraps. */

static struct value *
unwrap_value (struct value *val)
{
  struct type *type = check_typedef (VALUE_TYPE (val));
  if (ada_is_aligner_type (type))
    {
      struct value *v = value_struct_elt (&val, NULL, "F",
					  NULL, "internal structure");
      struct type *val_type = check_typedef (VALUE_TYPE (v));
      if (ada_type_name (val_type) == NULL)
	TYPE_NAME (val_type) = ada_type_name (type);

      return unwrap_value (v);
    }
  else
    {
      struct type *raw_real_type =
	ada_completed_type (ada_get_base_type (type));

      if (type == raw_real_type)
	return val;

      return
	coerce_unspec_val_to_type
	(val, 0, ada_to_fixed_type (raw_real_type, 0,
				    VALUE_ADDRESS (val) + VALUE_OFFSET (val),
				    NULL));
    }
}

static struct value *
cast_to_fixed (struct type *type, struct value *arg)
{
  LONGEST val;

  if (type == VALUE_TYPE (arg))
    return arg;
  else if (ada_is_fixed_point_type (VALUE_TYPE (arg)))
    val = ada_float_to_fixed (type,
			      ada_fixed_to_float (VALUE_TYPE (arg),
						  value_as_long (arg)));
  else
    {
      DOUBLEST argd =
	value_as_double (value_cast (builtin_type_double, value_copy (arg)));
      val = ada_float_to_fixed (type, argd);
    }

  return value_from_longest (type, val);
}

static struct value *
cast_from_fixed_to_double (struct value *arg)
{
  DOUBLEST val = ada_fixed_to_float (VALUE_TYPE (arg),
				     value_as_long (arg));
  return value_from_double (builtin_type_double, val);
}

/* Coerce VAL as necessary for assignment to an lval of type TYPE, and 
 * return the converted value. */
static struct value *
coerce_for_assign (struct type *type, struct value *val)
{
  struct type *type2 = VALUE_TYPE (val);
  if (type == type2)
    return val;

  CHECK_TYPEDEF (type2);
  CHECK_TYPEDEF (type);

  if (TYPE_CODE (type2) == TYPE_CODE_PTR
      && TYPE_CODE (type) == TYPE_CODE_ARRAY)
    {
      val = ada_value_ind (val);
      type2 = VALUE_TYPE (val);
    }

  if (TYPE_CODE (type2) == TYPE_CODE_ARRAY
      && TYPE_CODE (type) == TYPE_CODE_ARRAY)
    {
      if (TYPE_LENGTH (type2) != TYPE_LENGTH (type)
	  || TYPE_LENGTH (TYPE_TARGET_TYPE (type2))
	  != TYPE_LENGTH (TYPE_TARGET_TYPE (type2)))
	error ("Incompatible types in assignment");
      VALUE_TYPE (val) = type;
    }
  return val;
}

struct value *
ada_evaluate_subexp (struct type *expect_type, struct expression *exp,
		     int *pos, enum noside noside)
{
  enum exp_opcode op;
  enum ada_attribute atr;
  int tem, tem2, tem3;
  int pc;
  struct value *arg1 = NULL, *arg2 = NULL, *arg3;
  struct type *type;
  int nargs;
  struct value **argvec;

  pc = *pos;
  *pos += 1;
  op = exp->elts[pc].opcode;

  switch (op)
    {
    default:
      *pos -= 1;
      return
	unwrap_value (evaluate_subexp_standard
		      (expect_type, exp, pos, noside));

    case UNOP_CAST:
      (*pos) += 2;
      type = exp->elts[pc + 1].type;
      arg1 = evaluate_subexp (type, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (type != check_typedef (VALUE_TYPE (arg1)))
	{
	  if (ada_is_fixed_point_type (type))
	    arg1 = cast_to_fixed (type, arg1);
	  else if (ada_is_fixed_point_type (VALUE_TYPE (arg1)))
	    arg1 = value_cast (type, cast_from_fixed_to_double (arg1));
	  else if (VALUE_LVAL (arg1) == lval_memory)
	    {
	      /* This is in case of the really obscure (and undocumented,
	         but apparently expected) case of (Foo) Bar.all, where Bar 
	         is an integer constant and Foo is a dynamic-sized type.
	         If we don't do this, ARG1 will simply be relabeled with
	         TYPE. */
	      if (noside == EVAL_AVOID_SIDE_EFFECTS)
		return value_zero (to_static_fixed_type (type), not_lval);
	      arg1 =
		ada_to_fixed_value
		(type, 0, VALUE_ADDRESS (arg1) + VALUE_OFFSET (arg1), 0);
	    }
	  else
	    arg1 = value_cast (type, arg1);
	}
      return arg1;

      /* FIXME:  UNOP_QUAL should be defined in expression.h */
      /*    case UNOP_QUAL:
         (*pos) += 2;
         type = exp->elts[pc + 1].type;
         return ada_evaluate_subexp (type, exp, pos, noside);
       */
    case BINOP_ASSIGN:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (VALUE_TYPE (arg1), exp, pos, noside);
      if (noside == EVAL_SKIP || noside == EVAL_AVOID_SIDE_EFFECTS)
	return arg1;
      if (binop_user_defined_p (op, arg1, arg2))
	return value_x_binop (arg1, arg2, op, OP_NULL, EVAL_NORMAL);
      else
	{
	  if (ada_is_fixed_point_type (VALUE_TYPE (arg1)))
	    arg2 = cast_to_fixed (VALUE_TYPE (arg1), arg2);
	  else if (ada_is_fixed_point_type (VALUE_TYPE (arg2)))
	    error
	      ("Fixed-point values must be assigned to fixed-point variables");
	  else
	    arg2 = coerce_for_assign (VALUE_TYPE (arg1), arg2);
	  return ada_value_assign (arg1, arg2);
	}

    case BINOP_ADD:
      arg1 = evaluate_subexp_with_coercion (exp, pos, noside);
      arg2 = evaluate_subexp_with_coercion (exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (binop_user_defined_p (op, arg1, arg2))
	return value_x_binop (arg1, arg2, op, OP_NULL, EVAL_NORMAL);
      else
	{
	  if ((ada_is_fixed_point_type (VALUE_TYPE (arg1))
	       || ada_is_fixed_point_type (VALUE_TYPE (arg2)))
	      && VALUE_TYPE (arg1) != VALUE_TYPE (arg2))
	    error
	      ("Operands of fixed-point addition must have the same type");
	  return value_cast (VALUE_TYPE (arg1), value_add (arg1, arg2));
	}

    case BINOP_SUB:
      arg1 = evaluate_subexp_with_coercion (exp, pos, noside);
      arg2 = evaluate_subexp_with_coercion (exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (binop_user_defined_p (op, arg1, arg2))
	return value_x_binop (arg1, arg2, op, OP_NULL, EVAL_NORMAL);
      else
	{
	  if ((ada_is_fixed_point_type (VALUE_TYPE (arg1))
	       || ada_is_fixed_point_type (VALUE_TYPE (arg2)))
	      && VALUE_TYPE (arg1) != VALUE_TYPE (arg2))
	    error
	      ("Operands of fixed-point subtraction must have the same type");
	  return value_cast (VALUE_TYPE (arg1), value_sub (arg1, arg2));
	}

    case BINOP_MUL:
    case BINOP_DIV:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (binop_user_defined_p (op, arg1, arg2))
	return value_x_binop (arg1, arg2, op, OP_NULL, EVAL_NORMAL);
      else
	if (noside == EVAL_AVOID_SIDE_EFFECTS
	    && (op == BINOP_DIV || op == BINOP_REM || op == BINOP_MOD))
	return value_zero (VALUE_TYPE (arg1), not_lval);
      else
	{
	  if (ada_is_fixed_point_type (VALUE_TYPE (arg1)))
	    arg1 = cast_from_fixed_to_double (arg1);
	  if (ada_is_fixed_point_type (VALUE_TYPE (arg2)))
	    arg2 = cast_from_fixed_to_double (arg2);
	  return value_binop (arg1, arg2, op);
	}

    case UNOP_NEG:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (unop_user_defined_p (op, arg1))
	return value_x_unop (arg1, op, EVAL_NORMAL);
      else if (ada_is_fixed_point_type (VALUE_TYPE (arg1)))
	return value_cast (VALUE_TYPE (arg1), value_neg (arg1));
      else
	return value_neg (arg1);

      /* FIXME:  OP_UNRESOLVED_VALUE should be defined in expression.h */
      /*    case OP_UNRESOLVED_VALUE:
         /* Only encountered when an unresolved symbol occurs in a
         context other than a function call, in which case, it is
   illegal. *//*
   (*pos) += 3;
   if (noside == EVAL_SKIP)
   goto nosideret;
   else 
   error ("Unexpected unresolved symbol, %s, during evaluation",
   ada_demangle (exp->elts[pc + 2].name));
 */
    case OP_VAR_VALUE:
      *pos -= 1;
      if (noside == EVAL_SKIP)
	{
	  *pos += 4;
	  goto nosideret;
	}
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
	{
	  *pos += 4;
	  return value_zero
	    (to_static_fixed_type
	     (static_unwrap_type (SYMBOL_TYPE (exp->elts[pc + 2].symbol))),
	     not_lval);
	}
      else
	{
	  arg1 =
	    unwrap_value (evaluate_subexp_standard
			  (expect_type, exp, pos, noside));
	  return ada_to_fixed_value (VALUE_TYPE (arg1), 0,
				     VALUE_ADDRESS (arg1) +
				     VALUE_OFFSET (arg1), arg1);
	}

    case OP_ARRAY:
      (*pos) += 3;
      tem2 = longest_to_int (exp->elts[pc + 1].longconst);
      tem3 = longest_to_int (exp->elts[pc + 2].longconst);
      nargs = tem3 - tem2 + 1;
      type = expect_type ? check_typedef (expect_type) : NULL_TYPE;

      argvec =
	(struct value * *) alloca (sizeof (struct value *) * (nargs + 1));
      for (tem = 0; tem == 0 || tem < nargs; tem += 1)
	/* At least one element gets inserted for the type */
	{
	  /* Ensure that array expressions are coerced into pointer objects. */
	  argvec[tem] = evaluate_subexp_with_coercion (exp, pos, noside);
	}
      if (noside == EVAL_SKIP)
	goto nosideret;
      return value_array (tem2, tem3, argvec);

    case OP_FUNCALL:
      (*pos) += 2;

      /* Allocate arg vector, including space for the function to be
         called in argvec[0] and a terminating NULL */
      nargs = longest_to_int (exp->elts[pc + 1].longconst);
      argvec =
	(struct value * *) alloca (sizeof (struct value *) * (nargs + 2));

      /* FIXME: OP_UNRESOLVED_VALUE should be defined in expression.h */
      /* FIXME: name should be defined in expresion.h */
      /*      if (exp->elts[*pos].opcode == OP_UNRESOLVED_VALUE)
         error ("Unexpected unresolved symbol, %s, during evaluation",
         ada_demangle (exp->elts[pc + 5].name));
       */
      if (0)
	{
	  error ("unexpected code path, FIXME");
	}
      else
	{
	  for (tem = 0; tem <= nargs; tem += 1)
	    argvec[tem] = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	  argvec[tem] = 0;

	  if (noside == EVAL_SKIP)
	    goto nosideret;
	}

      if (TYPE_CODE (VALUE_TYPE (argvec[0])) == TYPE_CODE_REF)
	argvec[0] = value_addr (argvec[0]);

      if (ada_is_packed_array_type (VALUE_TYPE (argvec[0])))
	argvec[0] = ada_coerce_to_simple_array (argvec[0]);

      type = check_typedef (VALUE_TYPE (argvec[0]));
      if (TYPE_CODE (type) == TYPE_CODE_PTR)
	{
	  switch (TYPE_CODE (check_typedef (TYPE_TARGET_TYPE (type))))
	    {
	    case TYPE_CODE_FUNC:
	      type = check_typedef (TYPE_TARGET_TYPE (type));
	      break;
	    case TYPE_CODE_ARRAY:
	      break;
	    case TYPE_CODE_STRUCT:
	      if (noside != EVAL_AVOID_SIDE_EFFECTS)
		argvec[0] = ada_value_ind (argvec[0]);
	      type = check_typedef (TYPE_TARGET_TYPE (type));
	      break;
	    default:
	      error ("cannot subscript or call something of type `%s'",
		     ada_type_name (VALUE_TYPE (argvec[0])));
	      break;
	    }
	}

      switch (TYPE_CODE (type))
	{
	case TYPE_CODE_FUNC:
	  if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    return allocate_value (TYPE_TARGET_TYPE (type));
	  return call_function_by_hand (argvec[0], nargs, argvec + 1);
	case TYPE_CODE_STRUCT:
	  {
	    int arity = ada_array_arity (type);
	    type = ada_array_element_type (type, nargs);
	    if (type == NULL)
	      error ("cannot subscript or call a record");
	    if (arity != nargs)
	      error ("wrong number of subscripts; expecting %d", arity);
	    if (noside == EVAL_AVOID_SIDE_EFFECTS)
	      return allocate_value (ada_aligned_type (type));
	    return
	      unwrap_value (ada_value_subscript
			    (argvec[0], nargs, argvec + 1));
	  }
	case TYPE_CODE_ARRAY:
	  if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    {
	      type = ada_array_element_type (type, nargs);
	      if (type == NULL)
		error ("element type of array unknown");
	      else
		return allocate_value (ada_aligned_type (type));
	    }
	  return
	    unwrap_value (ada_value_subscript
			  (ada_coerce_to_simple_array (argvec[0]),
			   nargs, argvec + 1));
	case TYPE_CODE_PTR:	/* Pointer to array */
	  type = to_fixed_array_type (TYPE_TARGET_TYPE (type), NULL, 1);
	  if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    {
	      type = ada_array_element_type (type, nargs);
	      if (type == NULL)
		error ("element type of array unknown");
	      else
		return allocate_value (ada_aligned_type (type));
	    }
	  return
	    unwrap_value (ada_value_ptr_subscript (argvec[0], type,
						   nargs, argvec + 1));

	default:
	  error ("Internal error in evaluate_subexp");
	}

    case TERNOP_SLICE:
      {
	struct value *array = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	int lowbound
	  = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
	int upper
	  = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
	if (noside == EVAL_SKIP)
	  goto nosideret;

	/* If this is a reference to an array, then dereference it */
	if (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_REF
	    && TYPE_TARGET_TYPE (VALUE_TYPE (array)) != NULL
	    && TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (array))) ==
	    TYPE_CODE_ARRAY
	    && !ada_is_array_descriptor (check_typedef (VALUE_TYPE (array))))
	  {
	    array = ada_coerce_ref (array);
	  }

	if (noside == EVAL_AVOID_SIDE_EFFECTS &&
	    ada_is_array_descriptor (check_typedef (VALUE_TYPE (array))))
	  {
	    /* Try to dereference the array, in case it is an access to array */
	    struct type *arrType = ada_type_of_array (array, 0);
	    if (arrType != NULL)
	      array = value_at_lazy (arrType, 0, NULL);
	  }
	if (ada_is_array_descriptor (VALUE_TYPE (array)))
	  array = ada_coerce_to_simple_array (array);

	/* If at this point we have a pointer to an array, it means that
	   it is a pointer to a simple (non-ada) array. We just then
	   dereference it */
	if (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_PTR
	    && TYPE_TARGET_TYPE (VALUE_TYPE (array)) != NULL
	    && TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (array))) ==
	    TYPE_CODE_ARRAY)
	  {
	    array = ada_value_ind (array);
	  }

	if (noside == EVAL_AVOID_SIDE_EFFECTS)
	  /* The following will get the bounds wrong, but only in contexts
	     where the value is not being requested (FIXME?). */
	  return array;
	else
	  return value_slice (array, lowbound, upper - lowbound + 1);
      }

      /* FIXME: UNOP_MBR should be defined in expression.h */
      /*    case UNOP_MBR:
         (*pos) += 2;
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         type = exp->elts[pc + 1].type;

         if (noside == EVAL_SKIP)
         goto nosideret;

         switch (TYPE_CODE (type)) 
         {
         default:
         warning ("Membership test incompletely implemented; always returns true");
         return value_from_longest (builtin_type_int, (LONGEST) 1);

         case TYPE_CODE_RANGE:
         arg2 = value_from_longest (builtin_type_int, 
         (LONGEST) TYPE_LOW_BOUND (type));
         arg3 = value_from_longest (builtin_type_int, 
         (LONGEST) TYPE_HIGH_BOUND (type));
         return 
         value_from_longest (builtin_type_int,
         (value_less (arg1,arg3) 
         || value_equal (arg1,arg3))
         && (value_less (arg2,arg1)
         || value_equal (arg2,arg1)));
         }
       */
      /* FIXME: BINOP_MBR should be defined in expression.h */
      /*    case BINOP_MBR:
         (*pos) += 2;
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

         if (noside == EVAL_SKIP)
         goto nosideret;

         if (noside == EVAL_AVOID_SIDE_EFFECTS)
         return value_zero (builtin_type_int, not_lval);

         tem = longest_to_int (exp->elts[pc + 1].longconst);

         if (tem < 1 || tem > ada_array_arity (VALUE_TYPE (arg2)))
         error ("invalid dimension number to '%s", "range");

         arg3 = ada_array_bound (arg2, tem, 1);
         arg2 = ada_array_bound (arg2, tem, 0);

         return 
         value_from_longest (builtin_type_int,
         (value_less (arg1,arg3) 
         || value_equal (arg1,arg3))
         && (value_less (arg2,arg1)
         || value_equal (arg2,arg1)));
       */
      /* FIXME: TERNOP_MBR should be defined in expression.h */
      /*    case TERNOP_MBR:
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         arg3 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

         if (noside == EVAL_SKIP)
         goto nosideret;

         return 
         value_from_longest (builtin_type_int,
         (value_less (arg1,arg3) 
         || value_equal (arg1,arg3))
         && (value_less (arg2,arg1)
         || value_equal (arg2,arg1)));
       */
      /* FIXME: OP_ATTRIBUTE should be defined in expression.h */
      /*    case OP_ATTRIBUTE:
         *pos += 3;
         atr = (enum ada_attribute) longest_to_int (exp->elts[pc + 2].longconst);
         switch (atr) 
         {
         default:
         error ("unexpected attribute encountered");

         case ATR_FIRST:
         case ATR_LAST:
         case ATR_LENGTH:
         {
         struct type* type_arg;
         if (exp->elts[*pos].opcode == OP_TYPE)
         {
         evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
         arg1 = NULL;
         type_arg = exp->elts[pc + 5].type;
         }
         else
         {
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         type_arg = NULL;
         }

         if (exp->elts[*pos].opcode != OP_LONG) 
         error ("illegal operand to '%s", ada_attribute_name (atr));
         tem = longest_to_int (exp->elts[*pos+2].longconst);
         *pos += 4;

         if (noside == EVAL_SKIP)
         goto nosideret;

         if (type_arg == NULL)
         {
         arg1 = ada_coerce_ref (arg1);

         if (ada_is_packed_array_type (VALUE_TYPE (arg1)))
         arg1 = ada_coerce_to_simple_array (arg1);

         if (tem < 1 || tem > ada_array_arity (VALUE_TYPE (arg1)))
         error ("invalid dimension number to '%s", 
         ada_attribute_name (atr));

         if (noside == EVAL_AVOID_SIDE_EFFECTS)
         {
         type = ada_index_type (VALUE_TYPE (arg1), tem);
         if (type == NULL) 
         error ("attempt to take bound of something that is not an array");
         return allocate_value (type);
         }

         switch (atr) 
         {
         default: 
         error ("unexpected attribute encountered");
         case ATR_FIRST:
         return ada_array_bound (arg1, tem, 0);
         case ATR_LAST:
         return ada_array_bound (arg1, tem, 1);
         case ATR_LENGTH:
         return ada_array_length (arg1, tem);
         }
         }
         else if (TYPE_CODE (type_arg) == TYPE_CODE_RANGE
         || TYPE_CODE (type_arg) == TYPE_CODE_INT) 
         {
         struct type* range_type;
         char* name = ada_type_name (type_arg);
         if (name == NULL)
         {
         if (TYPE_CODE (type_arg) == TYPE_CODE_RANGE) 
         range_type = type_arg;
         else
         error ("unimplemented type attribute");
         }
         else 
         range_type = 
         to_fixed_range_type (name, NULL, TYPE_OBJFILE (type_arg));
         switch (atr) 
         {
         default: 
         error ("unexpected attribute encountered");
         case ATR_FIRST:
         return value_from_longest (TYPE_TARGET_TYPE (range_type),
         TYPE_LOW_BOUND (range_type));
         case ATR_LAST:
         return value_from_longest (TYPE_TARGET_TYPE (range_type),
         TYPE_HIGH_BOUND (range_type));
         }
         }              
         else if (TYPE_CODE (type_arg) == TYPE_CODE_ENUM)
         {
         switch (atr) 
         {
         default: 
         error ("unexpected attribute encountered");
         case ATR_FIRST:
         return value_from_longest 
         (type_arg, TYPE_FIELD_BITPOS (type_arg, 0));
         case ATR_LAST:
         return value_from_longest 
         (type_arg, 
         TYPE_FIELD_BITPOS (type_arg,
         TYPE_NFIELDS (type_arg) - 1));
         }
         }
         else if (TYPE_CODE (type_arg) == TYPE_CODE_FLT)
         error ("unimplemented type attribute");
         else 
         {
         LONGEST low, high;

         if (ada_is_packed_array_type (type_arg))
         type_arg = decode_packed_array_type (type_arg);

         if (tem < 1 || tem > ada_array_arity (type_arg))
         error ("invalid dimension number to '%s", 
         ada_attribute_name (atr));

         if (noside == EVAL_AVOID_SIDE_EFFECTS)
         {
         type = ada_index_type (type_arg, tem);
         if (type == NULL) 
         error ("attempt to take bound of something that is not an array");
         return allocate_value (type);
         }

         switch (atr) 
         {
         default: 
         error ("unexpected attribute encountered");
         case ATR_FIRST:
         low = ada_array_bound_from_type (type_arg, tem, 0, &type);
         return value_from_longest (type, low);
         case ATR_LAST:
         high = ada_array_bound_from_type (type_arg, tem, 1, &type);
         return value_from_longest (type, high);
         case ATR_LENGTH:
         low = ada_array_bound_from_type (type_arg, tem, 0, &type);
         high = ada_array_bound_from_type (type_arg, tem, 1, NULL);
         return value_from_longest (type, high-low+1);
         }
         }
         }

         case ATR_TAG:
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         if (noside == EVAL_SKIP)
         goto nosideret;

         if (noside == EVAL_AVOID_SIDE_EFFECTS)
         return         
         value_zero (ada_tag_type (arg1), not_lval);

         return ada_value_tag (arg1);

         case ATR_MIN:
         case ATR_MAX:
         evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         if (noside == EVAL_SKIP)
         goto nosideret;
         else if (noside == EVAL_AVOID_SIDE_EFFECTS)
         return value_zero (VALUE_TYPE (arg1), not_lval);
         else
         return value_binop (arg1, arg2, 
         atr == ATR_MIN ? BINOP_MIN : BINOP_MAX);

         case ATR_MODULUS:
         {
         struct type* type_arg = exp->elts[pc + 5].type;
         evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
         *pos += 4;

         if (noside == EVAL_SKIP)
         goto nosideret;

         if (! ada_is_modular_type (type_arg))
         error ("'modulus must be applied to modular type");

         return value_from_longest (TYPE_TARGET_TYPE (type_arg),
         ada_modulus (type_arg));
         }


         case ATR_POS:
         evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         if (noside == EVAL_SKIP)
         goto nosideret;
         else if (noside == EVAL_AVOID_SIDE_EFFECTS)
         return value_zero (builtin_type_ada_int, not_lval);
         else 
         return value_pos_atr (arg1);

         case ATR_SIZE:
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         if (noside == EVAL_SKIP)
         goto nosideret;
         else if (noside == EVAL_AVOID_SIDE_EFFECTS)
         return value_zero (builtin_type_ada_int, not_lval);
         else
         return value_from_longest (builtin_type_ada_int,
         TARGET_CHAR_BIT 
         * TYPE_LENGTH (VALUE_TYPE (arg1)));

         case ATR_VAL:
         evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         type = exp->elts[pc + 5].type;
         if (noside == EVAL_SKIP)
         goto nosideret;
         else if (noside == EVAL_AVOID_SIDE_EFFECTS)
         return value_zero (type, not_lval);
         else 
         return value_val_atr (type, arg1);
         } */
    case BINOP_EXP:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (binop_user_defined_p (op, arg1, arg2))
	return unwrap_value (value_x_binop (arg1, arg2, op, OP_NULL,
					    EVAL_NORMAL));
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
	return value_zero (VALUE_TYPE (arg1), not_lval);
      else
	return value_binop (arg1, arg2, op);

    case UNOP_PLUS:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (unop_user_defined_p (op, arg1))
	return unwrap_value (value_x_unop (arg1, op, EVAL_NORMAL));
      else
	return arg1;

    case UNOP_ABS:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (value_less (arg1, value_zero (VALUE_TYPE (arg1), not_lval)))
	return value_neg (arg1);
      else
	return arg1;

    case UNOP_IND:
      if (expect_type && TYPE_CODE (expect_type) == TYPE_CODE_PTR)
	expect_type = TYPE_TARGET_TYPE (check_typedef (expect_type));
      arg1 = evaluate_subexp (expect_type, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      type = check_typedef (VALUE_TYPE (arg1));
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	{
	  if (ada_is_array_descriptor (type))
	    /* GDB allows dereferencing GNAT array descriptors. */
	    {
	      struct type *arrType = ada_type_of_array (arg1, 0);
	      if (arrType == NULL)
		error ("Attempt to dereference null array pointer.");
	      return value_at_lazy (arrType, 0, NULL);
	    }
	  else if (TYPE_CODE (type) == TYPE_CODE_PTR
		   || TYPE_CODE (type) == TYPE_CODE_REF
		   /* In C you can dereference an array to get the 1st elt.  */
		   || TYPE_CODE (type) == TYPE_CODE_ARRAY)
	    return
	      value_zero
	      (to_static_fixed_type
	       (ada_aligned_type (check_typedef (TYPE_TARGET_TYPE (type)))),
	       lval_memory);
	  else if (TYPE_CODE (type) == TYPE_CODE_INT)
	    /* GDB allows dereferencing an int.  */
	    return value_zero (builtin_type_int, lval_memory);
	  else
	    error ("Attempt to take contents of a non-pointer value.");
	}
      arg1 = ada_coerce_ref (arg1);
      type = check_typedef (VALUE_TYPE (arg1));

      if (ada_is_array_descriptor (type))
	/* GDB allows dereferencing GNAT array descriptors. */
	return ada_coerce_to_simple_array (arg1);
      else
	return ada_value_ind (arg1);

    case STRUCTOP_STRUCT:
      tem = longest_to_int (exp->elts[pc + 1].longconst);
      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	return value_zero (ada_aligned_type
			   (ada_lookup_struct_elt_type (VALUE_TYPE (arg1),
							&exp->elts[pc +
								   2].string,
							0, NULL)),
			   lval_memory);
      else
	return unwrap_value (ada_value_struct_elt (arg1,
						   &exp->elts[pc + 2].string,
						   "record"));
    case OP_TYPE:
      /* The value is not supposed to be used. This is here to make it
         easier to accommodate expressions that contain types. */
      (*pos) += 2;
      if (noside == EVAL_SKIP)
	goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
	return allocate_value (builtin_type_void);
      else
	error ("Attempt to use a type name as an expression");

    case STRUCTOP_PTR:
      tem = longest_to_int (exp->elts[pc + 1].longconst);
      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	return value_zero (ada_aligned_type
			   (ada_lookup_struct_elt_type (VALUE_TYPE (arg1),
							&exp->elts[pc +
								   2].string,
							0, NULL)),
			   lval_memory);
      else
	return unwrap_value (ada_value_struct_elt (arg1,
						   &exp->elts[pc + 2].string,
						   "record access"));
    }

nosideret:
  return value_from_longest (builtin_type_long, (LONGEST) 1);
}


				/* Fixed point */

/* If TYPE encodes an Ada fixed-point type, return the suffix of the
   type name that encodes the 'small and 'delta information.
   Otherwise, return NULL. */

static const char *
fixed_type_info (struct type *type)
{
  const char *name = ada_type_name (type);
  enum type_code code = (type == NULL) ? TYPE_CODE_UNDEF : TYPE_CODE (type);

  if ((code == TYPE_CODE_INT || code == TYPE_CODE_RANGE) && name != NULL)
    {
      const char *tail = strstr (name, "___XF_");
      if (tail == NULL)
	return NULL;
      else
	return tail + 5;
    }
  else if (code == TYPE_CODE_RANGE && TYPE_TARGET_TYPE (type) != type)
    return fixed_type_info (TYPE_TARGET_TYPE (type));
  else
    return NULL;
}

/* Returns non-zero iff TYPE represents an Ada fixed-point type. */

int
ada_is_fixed_point_type (struct type *type)
{
  return fixed_type_info (type) != NULL;
}

/* Assuming that TYPE is the representation of an Ada fixed-point
   type, return its delta, or -1 if the type is malformed and the
   delta cannot be determined. */

DOUBLEST
ada_delta (struct type *type)
{
  const char *encoding = fixed_type_info (type);
  long num, den;

  if (sscanf (encoding, "_%ld_%ld", &num, &den) < 2)
    return -1.0;
  else
    return (DOUBLEST) num / (DOUBLEST) den;
}

/* Assuming that ada_is_fixed_point_type (TYPE), return the scaling
   factor ('SMALL value) associated with the type. */

static DOUBLEST
scaling_factor (struct type *type)
{
  const char *encoding = fixed_type_info (type);
  unsigned long num0, den0, num1, den1;
  int n;

  n = sscanf (encoding, "_%lu_%lu_%lu_%lu", &num0, &den0, &num1, &den1);

  if (n < 2)
    return 1.0;
  else if (n == 4)
    return (DOUBLEST) num1 / (DOUBLEST) den1;
  else
    return (DOUBLEST) num0 / (DOUBLEST) den0;
}


/* Assuming that X is the representation of a value of fixed-point
   type TYPE, return its floating-point equivalent. */

DOUBLEST
ada_fixed_to_float (struct type *type, LONGEST x)
{
  return (DOUBLEST) x *scaling_factor (type);
}

/* The representation of a fixed-point value of type TYPE 
   corresponding to the value X. */

LONGEST
ada_float_to_fixed (struct type *type, DOUBLEST x)
{
  return (LONGEST) (x / scaling_factor (type) + 0.5);
}


				/* VAX floating formats */

/* Non-zero iff TYPE represents one of the special VAX floating-point
   types. */
int
ada_is_vax_floating_type (struct type *type)
{
  int name_len =
    (ada_type_name (type) == NULL) ? 0 : strlen (ada_type_name (type));
  return
    name_len > 6
    && (TYPE_CODE (type) == TYPE_CODE_INT
	|| TYPE_CODE (type) == TYPE_CODE_RANGE)
    && DEPRECATED_STREQN (ada_type_name (type) + name_len - 6, "___XF", 5);
}

/* The type of special VAX floating-point type this is, assuming
   ada_is_vax_floating_point */
int
ada_vax_float_type_suffix (struct type *type)
{
  return ada_type_name (type)[strlen (ada_type_name (type)) - 1];
}

/* A value representing the special debugging function that outputs 
   VAX floating-point values of the type represented by TYPE.  Assumes
   ada_is_vax_floating_type (TYPE). */
struct value *
ada_vax_float_print_function (struct type *type)
{
  switch (ada_vax_float_type_suffix (type))
    {
    case 'F':
      return get_var_value ("DEBUG_STRING_F", 0);
    case 'D':
      return get_var_value ("DEBUG_STRING_D", 0);
    case 'G':
      return get_var_value ("DEBUG_STRING_G", 0);
    default:
      error ("invalid VAX floating-point type");
    }
}


				/* Range types */

/* Scan STR beginning at position K for a discriminant name, and
   return the value of that discriminant field of DVAL in *PX.  If
   PNEW_K is not null, put the position of the character beyond the
   name scanned in *PNEW_K.  Return 1 if successful; return 0 and do
   not alter *PX and *PNEW_K if unsuccessful. */

static int
scan_discrim_bound (char *str, int k, struct value *dval, LONGEST * px,
		    int *pnew_k)
{
  static char *bound_buffer = NULL;
  static size_t bound_buffer_len = 0;
  char *bound;
  char *pend;
  struct value *bound_val;

  if (dval == NULL || str == NULL || str[k] == '\0')
    return 0;

  pend = strstr (str + k, "__");
  if (pend == NULL)
    {
      bound = str + k;
      k += strlen (bound);
    }
  else
    {
      GROW_VECT (bound_buffer, bound_buffer_len, pend - (str + k) + 1);
      bound = bound_buffer;
      strncpy (bound_buffer, str + k, pend - (str + k));
      bound[pend - (str + k)] = '\0';
      k = pend - str;
    }

  bound_val = ada_search_struct_field (bound, dval, 0, VALUE_TYPE (dval));
  if (bound_val == NULL)
    return 0;

  *px = value_as_long (bound_val);
  if (pnew_k != NULL)
    *pnew_k = k;
  return 1;
}

/* Value of variable named NAME in the current environment.  If
   no such variable found, then if ERR_MSG is null, returns 0, and
   otherwise causes an error with message ERR_MSG. */
static struct value *
get_var_value (char *name, char *err_msg)
{
  struct symbol **syms;
  struct block **blocks;
  int nsyms;

  nsyms =
    ada_lookup_symbol_list (name, get_selected_block (NULL), VAR_DOMAIN,
			    &syms, &blocks);

  if (nsyms != 1)
    {
      if (err_msg == NULL)
	return 0;
      else
	error ("%s", err_msg);
    }

  return value_of_variable (syms[0], blocks[0]);
}

/* Value of integer variable named NAME in the current environment.  If
   no such variable found, then if ERR_MSG is null, returns 0, and sets
   *FLAG to 0.  If successful, sets *FLAG to 1. */
LONGEST
get_int_var_value (char *name, char *err_msg, int *flag)
{
  struct value *var_val = get_var_value (name, err_msg);

  if (var_val == 0)
    {
      if (flag != NULL)
	*flag = 0;
      return 0;
    }
  else
    {
      if (flag != NULL)
	*flag = 1;
      return value_as_long (var_val);
    }
}


/* Return a range type whose base type is that of the range type named
   NAME in the current environment, and whose bounds are calculated
   from NAME according to the GNAT range encoding conventions. 
   Extract discriminant values, if needed, from DVAL.  If a new type
   must be created, allocate in OBJFILE's space.  The bounds
   information, in general, is encoded in NAME, the base type given in
   the named range type. */

static struct type *
to_fixed_range_type (char *name, struct value *dval, struct objfile *objfile)
{
  struct type *raw_type = ada_find_any_type (name);
  struct type *base_type;
  LONGEST low, high;
  char *subtype_info;

  if (raw_type == NULL)
    base_type = builtin_type_int;
  else if (TYPE_CODE (raw_type) == TYPE_CODE_RANGE)
    base_type = TYPE_TARGET_TYPE (raw_type);
  else
    base_type = raw_type;

  subtype_info = strstr (name, "___XD");
  if (subtype_info == NULL)
    return raw_type;
  else
    {
      static char *name_buf = NULL;
      static size_t name_len = 0;
      int prefix_len = subtype_info - name;
      LONGEST L, U;
      struct type *type;
      char *bounds_str;
      int n;

      GROW_VECT (name_buf, name_len, prefix_len + 5);
      strncpy (name_buf, name, prefix_len);
      name_buf[prefix_len] = '\0';

      subtype_info += 5;
      bounds_str = strchr (subtype_info, '_');
      n = 1;

      if (*subtype_info == 'L')
	{
	  if (!ada_scan_number (bounds_str, n, &L, &n)
	      && !scan_discrim_bound (bounds_str, n, dval, &L, &n))
	    return raw_type;
	  if (bounds_str[n] == '_')
	    n += 2;
	  else if (bounds_str[n] == '.')	/* FIXME? SGI Workshop kludge. */
	    n += 1;
	  subtype_info += 1;
	}
      else
	{
	  strcpy (name_buf + prefix_len, "___L");
	  L = get_int_var_value (name_buf, "Index bound unknown.", NULL);
	}

      if (*subtype_info == 'U')
	{
	  if (!ada_scan_number (bounds_str, n, &U, &n)
	      && !scan_discrim_bound (bounds_str, n, dval, &U, &n))
	    return raw_type;
	}
      else
	{
	  strcpy (name_buf + prefix_len, "___U");
	  U = get_int_var_value (name_buf, "Index bound unknown.", NULL);
	}

      if (objfile == NULL)
	objfile = TYPE_OBJFILE (base_type);
      type = create_range_type (alloc_type (objfile), base_type, L, U);
      TYPE_NAME (type) = name;
      return type;
    }
}

/* True iff NAME is the name of a range type. */
int
ada_is_range_type_name (const char *name)
{
  return (name != NULL && strstr (name, "___XD"));
}


				/* Modular types */

/* True iff TYPE is an Ada modular type. */
int
ada_is_modular_type (struct type *type)
{
  /* FIXME: base_type should be declared in gdbtypes.h, implemented in
     valarith.c */
  struct type *subranged_type;	/* = base_type (type); */

  return (subranged_type != NULL && TYPE_CODE (type) == TYPE_CODE_RANGE
	  && TYPE_CODE (subranged_type) != TYPE_CODE_ENUM
	  && TYPE_UNSIGNED (subranged_type));
}

/* Assuming ada_is_modular_type (TYPE), the modulus of TYPE. */
LONGEST
ada_modulus (struct type * type)
{
  return TYPE_HIGH_BOUND (type) + 1;
}



				/* Operators */

/* Table mapping opcodes into strings for printing operators
   and precedences of the operators.  */

static const struct op_print ada_op_print_tab[] = {
  {":=", BINOP_ASSIGN, PREC_ASSIGN, 1},
  {"or else", BINOP_LOGICAL_OR, PREC_LOGICAL_OR, 0},
  {"and then", BINOP_LOGICAL_AND, PREC_LOGICAL_AND, 0},
  {"or", BINOP_BITWISE_IOR, PREC_BITWISE_IOR, 0},
  {"xor", BINOP_BITWISE_XOR, PREC_BITWISE_XOR, 0},
  {"and", BINOP_BITWISE_AND, PREC_BITWISE_AND, 0},
  {"=", BINOP_EQUAL, PREC_EQUAL, 0},
  {"/=", BINOP_NOTEQUAL, PREC_EQUAL, 0},
  {"<=", BINOP_LEQ, PREC_ORDER, 0},
  {">=", BINOP_GEQ, PREC_ORDER, 0},
  {">", BINOP_GTR, PREC_ORDER, 0},
  {"<", BINOP_LESS, PREC_ORDER, 0},
  {">>", BINOP_RSH, PREC_SHIFT, 0},
  {"<<", BINOP_LSH, PREC_SHIFT, 0},
  {"+", BINOP_ADD, PREC_ADD, 0},
  {"-", BINOP_SUB, PREC_ADD, 0},
  {"&", BINOP_CONCAT, PREC_ADD, 0},
  {"*", BINOP_MUL, PREC_MUL, 0},
  {"/", BINOP_DIV, PREC_MUL, 0},
  {"rem", BINOP_REM, PREC_MUL, 0},
  {"mod", BINOP_MOD, PREC_MUL, 0},
  {"**", BINOP_EXP, PREC_REPEAT, 0},
  {"@@", BINOP_REPEAT, PREC_REPEAT, 0},
  {"-", UNOP_NEG, PREC_PREFIX, 0},
  {"+", UNOP_PLUS, PREC_PREFIX, 0},
  {"not ", UNOP_LOGICAL_NOT, PREC_PREFIX, 0},
  {"not ", UNOP_COMPLEMENT, PREC_PREFIX, 0},
  {"abs ", UNOP_ABS, PREC_PREFIX, 0},
  {".all", UNOP_IND, PREC_SUFFIX, 1},	/* FIXME: postfix .ALL */
  {"'access", UNOP_ADDR, PREC_SUFFIX, 1},	/* FIXME: postfix 'ACCESS */
  {NULL, 0, 0, 0}
};

			/* Assorted Types and Interfaces */

struct type *builtin_type_ada_int;
struct type *builtin_type_ada_short;
struct type *builtin_type_ada_long;
struct type *builtin_type_ada_long_long;
struct type *builtin_type_ada_char;
struct type *builtin_type_ada_float;
struct type *builtin_type_ada_double;
struct type *builtin_type_ada_long_double;
struct type *builtin_type_ada_natural;
struct type *builtin_type_ada_positive;
struct type *builtin_type_ada_system_address;

struct type **const (ada_builtin_types[]) =
{

  &builtin_type_ada_int,
    &builtin_type_ada_long,
    &builtin_type_ada_short,
    &builtin_type_ada_char,
    &builtin_type_ada_float,
    &builtin_type_ada_double,
    &builtin_type_ada_long_long,
    &builtin_type_ada_long_double,
    &builtin_type_ada_natural, &builtin_type_ada_positive,
    /* The following types are carried over from C for convenience. */
&builtin_type_int,
    &builtin_type_long,
    &builtin_type_short,
    &builtin_type_char,
    &builtin_type_float,
    &builtin_type_double,
    &builtin_type_long_long,
    &builtin_type_void,
    &builtin_type_signed_char,
    &builtin_type_unsigned_char,
    &builtin_type_unsigned_short,
    &builtin_type_unsigned_int,
    &builtin_type_unsigned_long,
    &builtin_type_unsigned_long_long,
    &builtin_type_long_double,
    &builtin_type_complex, &builtin_type_double_complex, 0};

/* Not really used, but needed in the ada_language_defn. */
static void
emit_char (int c, struct ui_file *stream, int quoter)
{
  ada_emit_char (c, stream, quoter, 1);
}

const struct language_defn ada_language_defn = {
  "ada",			/* Language name */
  /*  language_ada, */
  language_unknown,
  /* FIXME: language_ada should be defined in defs.h */
  ada_builtin_types,
  range_check_off,
  type_check_off,
  case_sensitive_on,		/* Yes, Ada is case-insensitive, but
				 * that's not quite what this means. */
  ada_parse,
  ada_error,
  ada_evaluate_subexp,
  ada_printchar,		/* Print a character constant */
  ada_printstr,			/* Function to print string constant */
  emit_char,			/* Function to print single char (not used) */
  ada_create_fundamental_type,	/* Create fundamental type in this language */
  ada_print_type,		/* Print a type using appropriate syntax */
  ada_val_print,		/* Print a value using appropriate syntax */
  ada_value_print,		/* Print a top-level value */
  NULL,				/* Language specific skip_trampoline */
  value_of_this,		/* value_of_this */
  basic_lookup_symbol_nonlocal,	/* lookup_symbol_nonlocal  */
  basic_lookup_transparent_type,/* lookup_transparent_type */
  NULL,				/* Language specific symbol demangler */
  {"", "", "", ""},		/* Binary format info */
#if 0
  {"8#%lo#", "8#", "o", "#"},	/* Octal format info */
  {"%ld", "", "d", ""},		/* Decimal format info */
  {"16#%lx#", "16#", "x", "#"},	/* Hex format info */
#else
  /* Copied from c-lang.c. */
  {"0%lo", "0", "o", ""},	/* Octal format info */
  {"%ld", "", "d", ""},		/* Decimal format info */
  {"0x%lx", "0x", "x", ""},	/* Hex format info */
#endif
  ada_op_print_tab,		/* expression operators for printing */
  1,				/* c-style arrays (FIXME?) */
  0,				/* String lower bound (FIXME?) */
  &builtin_type_ada_char,
  default_word_break_characters,
  LANG_MAGIC
};

void
_initialize_ada_language (void)
{
  builtin_type_ada_int =
    init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
	       0, "integer", (struct objfile *) NULL);
  builtin_type_ada_long =
    init_type (TYPE_CODE_INT, TARGET_LONG_BIT / TARGET_CHAR_BIT,
	       0, "long_integer", (struct objfile *) NULL);
  builtin_type_ada_short =
    init_type (TYPE_CODE_INT, TARGET_SHORT_BIT / TARGET_CHAR_BIT,
	       0, "short_integer", (struct objfile *) NULL);
  builtin_type_ada_char =
    init_type (TYPE_CODE_INT, TARGET_CHAR_BIT / TARGET_CHAR_BIT,
	       0, "character", (struct objfile *) NULL);
  builtin_type_ada_float =
    init_type (TYPE_CODE_FLT, TARGET_FLOAT_BIT / TARGET_CHAR_BIT,
	       0, "float", (struct objfile *) NULL);
  builtin_type_ada_double =
    init_type (TYPE_CODE_FLT, TARGET_DOUBLE_BIT / TARGET_CHAR_BIT,
	       0, "long_float", (struct objfile *) NULL);
  builtin_type_ada_long_long =
    init_type (TYPE_CODE_INT, TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
	       0, "long_long_integer", (struct objfile *) NULL);
  builtin_type_ada_long_double =
    init_type (TYPE_CODE_FLT, TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT,
	       0, "long_long_float", (struct objfile *) NULL);
  builtin_type_ada_natural =
    init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
	       0, "natural", (struct objfile *) NULL);
  builtin_type_ada_positive =
    init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
	       0, "positive", (struct objfile *) NULL);


  builtin_type_ada_system_address =
    lookup_pointer_type (init_type (TYPE_CODE_VOID, 1, 0, "void",
				    (struct objfile *) NULL));
  TYPE_NAME (builtin_type_ada_system_address) = "system__address";

  add_language (&ada_language_defn);

  add_show_from_set
    (add_set_cmd ("varsize-limit", class_support, var_uinteger,
		  (char *) &varsize_limit,
		  "Set maximum bytes in dynamic-sized object.",
		  &setlist), &showlist);
  varsize_limit = 65536;

  add_com ("begin", class_breakpoint, begin_command,
	   "Start the debugged program, stopping at the beginning of the\n\
main program.  You may specify command-line arguments to give it, as for\n\
the \"run\" command (q.v.).");
}


/* Create a fundamental Ada type using default reasonable for the current
   target machine.

   Some object/debugging file formats (DWARF version 1, COFF, etc) do not
   define fundamental types such as "int" or "double".  Others (stabs or
   DWARF version 2, etc) do define fundamental types.  For the formats which
   don't provide fundamental types, gdb can create such types using this
   function.

   FIXME:  Some compilers distinguish explicitly signed integral types
   (signed short, signed int, signed long) from "regular" integral types
   (short, int, long) in the debugging information.  There is some dis-
   agreement as to how useful this feature is.  In particular, gcc does
   not support this.  Also, only some debugging formats allow the
   distinction to be passed on to a debugger.  For now, we always just
   use "short", "int", or "long" as the type name, for both the implicit
   and explicitly signed types.  This also makes life easier for the
   gdb test suite since we don't have to account for the differences
   in output depending upon what the compiler and debugging format
   support.  We will probably have to re-examine the issue when gdb
   starts taking it's fundamental type information directly from the
   debugging information supplied by the compiler.  fnf@@cygnus.com */

static struct type *
ada_create_fundamental_type (struct objfile *objfile, int typeid)
{
  struct type *type = NULL;

  switch (typeid)
    {
    default:
      /* FIXME:  For now, if we are asked to produce a type not in this
         language, create the equivalent of a C integer type with the
         name "<?type?>".  When all the dust settles from the type
         reconstruction work, this should probably become an error. */
      type = init_type (TYPE_CODE_INT,
			TARGET_INT_BIT / TARGET_CHAR_BIT,
			0, "<?type?>", objfile);
      warning ("internal error: no Ada fundamental type %d", typeid);
      break;
    case FT_VOID:
      type = init_type (TYPE_CODE_VOID,
			TARGET_CHAR_BIT / TARGET_CHAR_BIT,
			0, "void", objfile);
      break;
    case FT_CHAR:
      type = init_type (TYPE_CODE_INT,
			TARGET_CHAR_BIT / TARGET_CHAR_BIT,
			0, "character", objfile);
      break;
    case FT_SIGNED_CHAR:
      type = init_type (TYPE_CODE_INT,
			TARGET_CHAR_BIT / TARGET_CHAR_BIT,
			0, "signed char", objfile);
      break;
    case FT_UNSIGNED_CHAR:
      type = init_type (TYPE_CODE_INT,
			TARGET_CHAR_BIT / TARGET_CHAR_BIT,
			TYPE_FLAG_UNSIGNED, "unsigned char", objfile);
      break;
    case FT_SHORT:
      type = init_type (TYPE_CODE_INT,
			TARGET_SHORT_BIT / TARGET_CHAR_BIT,
			0, "short_integer", objfile);
      break;
    case FT_SIGNED_SHORT:
      type = init_type (TYPE_CODE_INT,
			TARGET_SHORT_BIT / TARGET_CHAR_BIT,
			0, "short_integer", objfile);
      break;
    case FT_UNSIGNED_SHORT:
      type = init_type (TYPE_CODE_INT,
			TARGET_SHORT_BIT / TARGET_CHAR_BIT,
			TYPE_FLAG_UNSIGNED, "unsigned short", objfile);
      break;
    case FT_INTEGER:
      type = init_type (TYPE_CODE_INT,
			TARGET_INT_BIT / TARGET_CHAR_BIT,
			0, "integer", objfile);
      break;
    case FT_SIGNED_INTEGER:
      type = init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT, 0, "integer", objfile);	/* FIXME -fnf */
      break;
    case FT_UNSIGNED_INTEGER:
      type = init_type (TYPE_CODE_INT,
			TARGET_INT_BIT / TARGET_CHAR_BIT,
			TYPE_FLAG_UNSIGNED, "unsigned int", objfile);
      break;
    case FT_LONG:
      type = init_type (TYPE_CODE_INT,
			TARGET_LONG_BIT / TARGET_CHAR_BIT,
			0, "long_integer", objfile);
      break;
    case FT_SIGNED_LONG:
      type = init_type (TYPE_CODE_INT,
			TARGET_LONG_BIT / TARGET_CHAR_BIT,
			0, "long_integer", objfile);
      break;
    case FT_UNSIGNED_LONG:
      type = init_type (TYPE_CODE_INT,
			TARGET_LONG_BIT / TARGET_CHAR_BIT,
			TYPE_FLAG_UNSIGNED, "unsigned long", objfile);
      break;
    case FT_LONG_LONG:
      type = init_type (TYPE_CODE_INT,
			TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
			0, "long_long_integer", objfile);
      break;
    case FT_SIGNED_LONG_LONG:
      type = init_type (TYPE_CODE_INT,
			TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
			0, "long_long_integer", objfile);
      break;
    case FT_UNSIGNED_LONG_LONG:
      type = init_type (TYPE_CODE_INT,
			TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
			TYPE_FLAG_UNSIGNED, "unsigned long long", objfile);
      break;
    case FT_FLOAT:
      type = init_type (TYPE_CODE_FLT,
			TARGET_FLOAT_BIT / TARGET_CHAR_BIT,
			0, "float", objfile);
      break;
    case FT_DBL_PREC_FLOAT:
      type = init_type (TYPE_CODE_FLT,
			TARGET_DOUBLE_BIT / TARGET_CHAR_BIT,
			0, "long_float", objfile);
      break;
    case FT_EXT_PREC_FLOAT:
      type = init_type (TYPE_CODE_FLT,
			TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT,
			0, "long_long_float", objfile);
      break;
    }
  return (type);
}

void
ada_dump_symtab (struct symtab *s)
{
  int i;
  fprintf (stderr, "New symtab: [\n");
  fprintf (stderr, "  Name: %s/%s;\n",
	   s->dirname ? s->dirname : "?", s->filename ? s->filename : "?");
  fprintf (stderr, "  Format: %s;\n", s->debugformat);
  if (s->linetable != NULL)
    {
      fprintf (stderr, "  Line table (section %d):\n", s->block_line_section);
      for (i = 0; i < s->linetable->nitems; i += 1)
	{
	  struct linetable_entry *e = s->linetable->item + i;
	  fprintf (stderr, "    %4ld: %8lx\n", (long) e->line, (long) e->pc);
	}
    }
  fprintf (stderr, "]\n");
}
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d2 1
a2 1
   1992, 1993, 1994, 1997, 1998, 1999, 2000, 2003, 2004.
a20 2

#include "defs.h"
d26 1
a26 2
#include "gdb_regex.h"
#include "frame.h"
a38 2
#include "hashtab.h"
#include "gdb_obstack.h"
a39 3
#include "completer.h"
#include "gdb_stat.h"
#ifdef UI_OUT
a40 1
#endif
d45 1
a45 12
#ifndef ADA_RETAIN_DOTS
#define ADA_RETAIN_DOTS 0
#endif

/* Define whether or not the C operator '/' truncates towards zero for
   differently signed operands (truncation direction is undefined in C). 
   Copied from valarith.c.  */

#ifndef TRUNCATION_TOWARDS_ZERO
#define TRUNCATION_TOWARDS_ZERO ((-5 / 2) == -2)
#endif

d47 1
a47 1
static void extract_string (CORE_ADDR addr, char *buf);
d85 1
a85 1
static struct value *ensure_lval (struct value *, CORE_ADDR *);
d88 1
a88 1
                                     CORE_ADDR *);
d91 1
a91 6
                                            CORE_ADDR *);

static void ada_add_block_symbols (struct obstack *,
                                   struct block *, const char *,
                                   domain_enum, struct objfile *,
                                   struct symtab *, int);
d93 2
a94 1
static int is_nonfunction (struct ada_symbol_info *, int);
d96 1
a96 2
static void add_defn_to_vec (struct obstack *, struct symbol *,
                             struct block *, struct symtab *);
d98 1
a98 1
static int num_defns_collected (struct obstack *);
d100 1
a100 1
static struct ada_symbol_info *defns_collected (struct obstack *, int);
d103 2
a104 2
                                                         *, const char *, int,
                                                         domain_enum, int);
d108 2
a109 2
static struct value *resolve_subexp (struct expression **, int *, int,
                                     struct type *);
d112 1
a112 1
                                        struct symbol *, struct block *);
d116 1
a116 3
static char *ada_op_name (enum exp_opcode);

static const char *ada_decoded_op_name (enum exp_opcode);
d126 2
a127 2
static struct type *ada_lookup_struct_elt_type (struct type *, char *,
                                                int, int, int *);
d130 1
a130 1
                                      int *, enum noside);
d134 2
d139 1
a139 3
                                                  CORE_ADDR, struct value *);

static struct type *to_fixed_array_type (struct type *, struct value *, int);
d142 1
a142 1
                                         struct objfile *);
d155 1
a155 1
                                             struct value **);
d157 2
a158 2
static struct value *coerce_unspec_val_to_type (struct value *,
                                                struct type *);
d170 4
a173 3
static struct value *ada_coerce_ref (struct value *);

static LONGEST pos_atr (struct value *);
d175 2
a176 1
static struct value *value_pos_atr (struct value *);
d178 1
a178 1
static struct value *value_val_atr (struct type *, struct value *);
d180 2
a181 2
static struct symbol *standard_lookup (const char *, const struct block *,
                                       domain_enum);
d183 1
a183 2
static struct value *ada_search_struct_field (char *, struct value *, int,
                                              struct type *);
d185 1
a185 2
static struct value *ada_value_primitive_field (struct value *, int, int,
                                                struct type *);
d187 1
a187 2
static int find_struct_field (char *, struct type *, int,
                              struct type **, int *, int *, int *);
d189 1
a189 2
static struct value *ada_to_fixed_value_create (struct type *, CORE_ADDR,
                                                struct value *);
d191 1
a191 9
static struct value *ada_to_fixed_value (struct value *);

static int ada_resolve_function (struct ada_symbol_info *, int,
                                 struct value **, int, const char *,
                                 struct type *);

static struct value *ada_coerce_to_simple_array (struct value *);

static int ada_is_direct_array_type (struct type *);
d193 1
a193 2
static void ada_language_arch_info (struct gdbarch *,
				    struct language_arch_info *);
d195 2
a196 1
static void check_size (const struct type *);
d200 1
a200 1
/* Maximum-sized dynamic type.  */
d203 1
a203 6
/* FIXME: brobecker/2003-09-17: No longer a const because it is
   returned by a function that does not return a const char *.  */
static char *ada_completer_word_break_characters =
#ifdef VMS
  " \t\n!@@#%^&*()+=|~`}{[]\";:?/,-";
#else
a204 1
#endif
d206 2
a207 33
/* The name of the symbol to use to get the name of the main subprogram.  */
static const char ADA_MAIN_PROGRAM_SYMBOL_NAME[]
  = "__gnat_ada_main_program_name";

/* The name of the runtime function called when an exception is raised.  */
static const char raise_sym_name[] = "__gnat_raise_nodefer_with_msg";

/* The name of the runtime function called when an unhandled exception
   is raised.  */
static const char raise_unhandled_sym_name[] = "__gnat_unhandled_exception";

/* The name of the runtime function called when an assert failure is
   raised.  */
static const char raise_assert_sym_name[] =
  "system__assertions__raise_assert_failure";

/* When GDB stops on an unhandled exception, GDB will go up the stack until
   if finds a frame corresponding to this function, in order to extract the
   name of the exception that has been raised from one of the parameters.  */
static const char process_raise_exception_name[] =
  "ada__exceptions__process_raise_exception";

/* A string that reflects the longest exception expression rewrite,
   aside from the exception name.  */
static const char longest_exception_template[] =
  "'__gnat_raise_nodefer_with_msg' if long_integer(e) = long_integer(&)";

/* Limit on the number of warnings to raise per expression evaluation.  */
static int warning_limit = 2;

/* Number of warning messages issued; reset to 0 by cleanups after
   expression evaluation.  */
static int warnings_issued = 0;
d209 1
a209 3
static const char *known_runtime_file_name_patterns[] = {
  ADA_KNOWN_RUNTIME_FILE_NAME_PATTERNS NULL
};
d211 6
a216 20
static const char *known_auxiliary_function_name_patterns[] = {
  ADA_KNOWN_AUXILIARY_FUNCTION_NAME_PATTERNS NULL
};

/* Space for allocating results of ada_lookup_symbol_list.  */
static struct obstack symbol_list_obstack;

                        /* Utilities */


static char *
ada_get_gdb_completer_word_break_characters (void)
{
  return ada_completer_word_break_characters;
}

/* Read the string located at ADDR from the inferior and store the
   result into BUF.  */

static void
d221 2
a222 2
  /* Loop, reading one byte at a time, until we reach the '\000'
     end-of-string marker.  */
d226 1
a226 1
                          buf + char_index * sizeof (char), sizeof (char));
d234 1
a234 1
   updating *OLD_VECT and *SIZE as necessary.  */
d243 1
a243 1
        *size = min_size;
d249 1
a249 1
   suffix of FIELD_NAME beginning "___".  */
d256 4
a259 5
    (strncmp (field_name, target, len) == 0
     && (field_name[len] == '\0'
         || (strncmp (field_name + len, "___", 3) == 0
             && strcmp (field_name + strlen (field_name) - 6,
                        "___XVN") != 0)));
d263 1
a263 24
/* Assuming TYPE is a TYPE_CODE_STRUCT, find the field whose name matches
   FIELD_NAME, and return its index.  This function also handles fields
   whose name have ___ suffixes because the compiler sometimes alters
   their name by adding such a suffix to represent fields with certain
   constraints.  If the field could not be found, return a negative
   number if MAYBE_MISSING is set.  Otherwise raise an error.  */

int
ada_get_field_index (const struct type *type, const char *field_name,
                     int maybe_missing)
{
  int fieldno;
  for (fieldno = 0; fieldno < TYPE_NFIELDS (type); fieldno++)
    if (field_name_match (TYPE_FIELD_NAME (type, fieldno), field_name))
      return fieldno;

  if (!maybe_missing)
    error ("Unable to find field %s in struct %s.  Aborting",
           field_name, TYPE_NAME (type));

  return -1;
}

/* The length of the prefix of NAME prior to any "___" suffix.  */
d274 1
a274 1
        return strlen (name);
d276 1
a276 1
        return p - name;
d280 1
a280 3
/* Return non-zero if SUFFIX is a suffix of STR.
   Return zero if STR is null.  */

d289 1
a289 1
  return (len1 >= len2 && strcmp (str + len1 - len2, suffix) == 0);
d293 2
a294 3
   is non-null, and whose memory address (in the inferior) is
   ADDRESS.  */

d297 1
a297 1
                                 CORE_ADDR address)
d310 2
a311 2
/* The contents of value VAL, treated as a value of type TYPE.  The
   result is an lval in memory if VAL is.  */
d314 1
a314 1
coerce_unspec_val_to_type (struct value *val, struct type *type)
d316 5
a320 3
  type = ada_check_typedef (type);
  if (VALUE_TYPE (val) == type)
    return val;
d323 6
a328 14
      struct value *result;

      /* Make sure that the object size is not unreasonable before
         trying to allocate some memory for it.  */
      check_size (type);

      result = allocate_value (type);
      VALUE_LVAL (result) = VALUE_LVAL (val);
      VALUE_BITSIZE (result) = VALUE_BITSIZE (val);
      VALUE_BITPOS (result) = VALUE_BITPOS (val);
      VALUE_ADDRESS (result) = VALUE_ADDRESS (val) + VALUE_OFFSET (val);
      if (VALUE_LAZY (val)
          || TYPE_LENGTH (type) > TYPE_LENGTH (VALUE_TYPE (val)))
        VALUE_LAZY (result) = 1;
d330 5
a334 2
        memcpy (VALUE_CONTENTS_RAW (result), VALUE_CONTENTS (val),
                TYPE_LENGTH (type));
d357 2
a358 9
/* Issue a warning (as for the definition of warning in utils.c, but
   with exactly one argument rather than ...), unless the limit on the
   number of warnings has passed during the evaluation of the current
   expression.  */

/* FIXME: cagney/2004-10-10: This function is mimicking the behavior
   provided by "complaint".  */
static void lim_warning (const char *format, ...) ATTR_FORMAT (printf, 1, 2);

d360 1
a360 1
lim_warning (const char *format, ...)
d362 17
a378 119
  va_list args;
  va_start (args, format);

  warnings_issued += 1;
  if (warnings_issued <= warning_limit)
    vwarning (format, args);

  va_end (args);
}

/* Issue an error if the size of an object of type T is unreasonable,
   i.e. if it would be a bad idea to allocate a value of this type in
   GDB.  */

static void
check_size (const struct type *type)
{
  if (TYPE_LENGTH (type) > varsize_limit)
    error ("object size is larger than varsize-limit");
}


/* Note: would have used MAX_OF_TYPE and MIN_OF_TYPE macros from
   gdbtypes.h, but some of the necessary definitions in that file
   seem to have gone missing. */

/* Maximum value of a SIZE-byte signed integer type. */
static LONGEST
max_of_size (int size)
{
  LONGEST top_bit = (LONGEST) 1 << (size * 8 - 2);
  return top_bit | (top_bit - 1);
}

/* Minimum value of a SIZE-byte signed integer type. */
static LONGEST
min_of_size (int size)
{
  return -max_of_size (size) - 1;
}

/* Maximum value of a SIZE-byte unsigned integer type. */
static ULONGEST
umax_of_size (int size)
{
  ULONGEST top_bit = (ULONGEST) 1 << (size * 8 - 1);
  return top_bit | (top_bit - 1);
}

/* Maximum value of integral type T, as a signed quantity. */
static LONGEST
max_of_type (struct type *t)
{
  if (TYPE_UNSIGNED (t))
    return (LONGEST) umax_of_size (TYPE_LENGTH (t));
  else
    return max_of_size (TYPE_LENGTH (t));
}

/* Minimum value of integral type T, as a signed quantity. */
static LONGEST
min_of_type (struct type *t)
{
  if (TYPE_UNSIGNED (t)) 
    return 0;
  else
    return min_of_size (TYPE_LENGTH (t));
}

/* The largest value in the domain of TYPE, a discrete type, as an integer.  */
static struct value *
discrete_type_high_bound (struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_RANGE:
      return value_from_longest (TYPE_TARGET_TYPE (type),
                                 TYPE_HIGH_BOUND (type));
    case TYPE_CODE_ENUM:
      return
        value_from_longest (type,
                            TYPE_FIELD_BITPOS (type,
                                               TYPE_NFIELDS (type) - 1));
    case TYPE_CODE_INT:
      return value_from_longest (type, max_of_type (type));
    default:
      error ("Unexpected type in discrete_type_high_bound.");
    }
}

/* The largest value in the domain of TYPE, a discrete type, as an integer.  */
static struct value *
discrete_type_low_bound (struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_RANGE:
      return value_from_longest (TYPE_TARGET_TYPE (type),
                                 TYPE_LOW_BOUND (type));
    case TYPE_CODE_ENUM:
      return value_from_longest (type, TYPE_FIELD_BITPOS (type, 0));
    case TYPE_CODE_INT:
      return value_from_longest (type, min_of_type (type));
    default:
      error ("Unexpected type in discrete_type_low_bound.");
    }
}

/* The identity on non-range types.  For range types, the underlying
   non-range scalar type.  */

static struct type *
base_type (struct type *type)
{
  while (type != NULL && TYPE_CODE (type) == TYPE_CODE_RANGE)
    {
      if (type == TYPE_TARGET_TYPE (type) || TYPE_TARGET_TYPE (type) == NULL)
        return type;
      type = TYPE_TARGET_TYPE (type);
d380 2
a381 1
  return type;
d385 1
a385 1
                                /* Language Selection */
d390 1
a390 1
   MAIN_PST is not used.  */
d394 1
a394 1
                             struct partial_symtab *main_pst)
d397 4
a400 2
                             (struct objfile *) NULL) != NULL)
    return language_ada;
d404 1
d406 1
a406 33
/* If the main procedure is written in Ada, then return its name.
   The result is good until the next call.  Return NULL if the main
   procedure doesn't appear to be in Ada.  */

char *
ada_main_name (void)
{
  struct minimal_symbol *msym;
  CORE_ADDR main_program_name_addr;
  static char main_program_name[1024];

  /* For Ada, the name of the main procedure is stored in a specific
     string constant, generated by the binder.  Look for that symbol,
     extract its address, and then read that string.  If we didn't find
     that string, then most probably the main procedure is not written
     in Ada.  */
  msym = lookup_minimal_symbol (ADA_MAIN_PROGRAM_SYMBOL_NAME, NULL, NULL);

  if (msym != NULL)
    {
      main_program_name_addr = SYMBOL_VALUE_ADDRESS (msym);
      if (main_program_name_addr == 0)
        error ("Invalid address for Ada main program name.");

      extract_string (main_program_name_addr, main_program_name);
      return main_program_name;
    }

  /* The main procedure doesn't seem to be in Ada.  */
  return NULL;
}

                                /* Symbols */
d408 2
a409 2
/* Table of Ada operators and their GNAT-encoded names.  Last entry is pair
   of NULLs.  */
d436 1
a436 2
/* Return non-zero if STR should be suppressed in info listings.  */

d440 1
a440 1
  if (strncmp (str, "_ada_", 5) == 0)
d449 1
a449 1
        return 1;
d451 1
a451 1
        suffix = str + strlen (str);
d453 14
a466 14
        if (isupper (*p))
          {
            int i;
            if (p[0] == 'X' && p[-1] != '_')
              goto OK;
            if (*p != 'O')
              return 1;
            for (i = 0; ada_opname_table[i].encoded != NULL; i += 1)
              if (strncmp (ada_opname_table[i].encoded, p,
                           strlen (ada_opname_table[i].encoded)) == 0)
                goto OK;
            return 1;
          OK:;
          }
d471 2
a472 3
/* The "encoded" form of DECODED, according to GNAT conventions.
   The result is valid until the next call to ada_encode.  */

d474 1
a474 1
ada_encode (const char *decoded)
d476 2
a477 2
  static char *encoding_buffer = NULL;
  static size_t encoding_buffer_size = 0;
d481 1
a481 1
  if (decoded == NULL)
d484 2
a485 2
  GROW_VECT (encoding_buffer, encoding_buffer_size,
             2 * strlen (decoded) + 10);
d488 1
a488 1
  for (p = decoded; *p != '\0'; p += 1)
d490 5
a494 5
      if (!ADA_RETAIN_DOTS && *p == '.')
        {
          encoding_buffer[k] = encoding_buffer[k + 1] = '_';
          k += 2;
        }
d496 2
a497 2
        {
          const struct ada_opname_map *mapping;
d499 16
a514 16
          for (mapping = ada_opname_table;
               mapping->encoded != NULL
               && strncmp (mapping->decoded, p,
                           strlen (mapping->decoded)) != 0; mapping += 1)
            ;
          if (mapping->encoded == NULL)
            error ("invalid Ada operator name: %s", p);
          strcpy (encoding_buffer + k, mapping->encoded);
          k += strlen (mapping->encoded);
          break;
        }
      else
        {
          encoding_buffer[k] = *p;
          k += 1;
        }
d517 2
a518 2
  encoding_buffer[k] = '\0';
  return encoding_buffer;
d522 2
a523 3
   quotes, unfolded, but with the quotes stripped away.  Result good
   to next call.  */

d542 1
a542 1
        fold_buffer[i] = tolower (name[i]);
d548 2
a549 5
/* decode:
     0. Discard trailing .{DIGIT}+ or trailing ___{DIGIT}+
        These are suffixes introduced by GNAT5 to nested subprogram
        names, and do not serve any purpose for the debugger.
     1. Discard final __{DIGIT}+ or $({DIGIT}+(__{DIGIT}+)*)
d553 1
a553 1
     5. Remove everything after first ___ if it is followed by
d558 2
d561 2
a562 6
   The resulting string is valid until the next call of ada_decode.
   If the string is unchanged by demangling, the original string pointer
   is returned.  */

const char *
ada_decode (const char *encoded)
d567 1
a567 1
  char *decoded;
d569 2
a570 2
  static char *decoding_buffer = NULL;
  static size_t decoding_buffer_size = 0;
d572 2
a573 2
  if (strncmp (encoded, "_ada_", 5) == 0)
    encoded += 5;
d575 1
a575 1
  if (encoded[0] == '_' || encoded[0] == '<')
d578 4
a581 19
  /* Remove trailing .{DIGIT}+ or ___{DIGIT}+.  */
  len0 = strlen (encoded);
  if (len0 > 1 && isdigit (encoded[len0 - 1]))
    {
      i = len0 - 2;
      while (i > 0 && isdigit (encoded[i]))
        i--;
      if (i >= 0 && encoded[i] == '.')
        len0 = i;
      else if (i >= 2 && strncmp (encoded + i - 2, "___", 3) == 0)
        len0 = i - 2;
    }

  /* Remove the ___X.* suffix if present.  Do not forget to verify that
     the suffix is located before the current "end" of ENCODED.  We want
     to avoid re-matching parts of ENCODED that have previously been
     marked as discarded (by decrementing LEN0).  */
  p = strstr (encoded, "___");
  if (p != NULL && p - encoded < len0 - 3)
d584 1
a584 1
        len0 = p - encoded;
d586 1
a586 1
        goto Suppress;
d588 1
a588 2

  if (len0 > 3 && strncmp (encoded + len0 - 3, "TKB", 3) == 0)
d590 1
a590 2

  if (len0 > 1 && strncmp (encoded + len0 - 1, "B", 1) == 0)
d593 12
a604 14
  /* Make decoded big enough for possible expansion by operator name.  */
  GROW_VECT (decoding_buffer, decoding_buffer_size, 2 * len0 + 1);
  decoded = decoding_buffer;

  if (len0 > 1 && isdigit (encoded[len0 - 1]))
    {
      i = len0 - 2;
      while ((i >= 0 && isdigit (encoded[i]))
             || (i >= 1 && encoded[i] == '_' && isdigit (encoded[i - 1])))
        i -= 1;
      if (i > 1 && encoded[i] == '_' && encoded[i - 1] == '_')
        len0 = i - 1;
      else if (encoded[i] == '$')
        len0 = i;
d607 2
a608 2
  for (i = 0, j = 0; i < len0 && !isalpha (encoded[i]); i += 1, j += 1)
    decoded[j] = encoded[i];
d613 20
a632 20
      if (at_start_name && encoded[i] == 'O')
        {
          int k;
          for (k = 0; ada_opname_table[k].encoded != NULL; k += 1)
            {
              int op_len = strlen (ada_opname_table[k].encoded);
              if ((strncmp (ada_opname_table[k].encoded + 1, encoded + i + 1,
                            op_len - 1) == 0)
                  && !isalnum (encoded[i + op_len]))
                {
                  strcpy (decoded + j, ada_opname_table[k].decoded);
                  at_start_name = 0;
                  i += op_len;
                  j += strlen (ada_opname_table[k].decoded);
                  break;
                }
            }
          if (ada_opname_table[k].encoded != NULL)
            continue;
        }
d635 23
a657 24
      if (i < len0 - 4 && strncmp (encoded + i, "TK__", 4) == 0)
        i += 2;
      if (encoded[i] == 'X' && i != 0 && isalnum (encoded[i - 1]))
        {
          do
            i += 1;
          while (i < len0 && (encoded[i] == 'b' || encoded[i] == 'n'));
          if (i < len0)
            goto Suppress;
        }
      else if (!ADA_RETAIN_DOTS
               && i < len0 - 2 && encoded[i] == '_' && encoded[i + 1] == '_')
        {
          decoded[j] = '.';
          at_start_name = 1;
          i += 2;
          j += 1;
        }
      else
        {
          decoded[j] = encoded[i];
          i += 1;
          j += 1;
        }
d659 1
a659 1
  decoded[j] = '\000';
d661 2
a662 2
  for (i = 0; decoded[i] != '\0'; i += 1)
    if (isupper (decoded[i]) || decoded[i] == ' ')
d665 1
a665 4
  if (strcmp (decoded, encoded) == 0)
    return encoded;
  else
    return decoded;
d668 7
a674 69
  GROW_VECT (decoding_buffer, decoding_buffer_size, strlen (encoded) + 3);
  decoded = decoding_buffer;
  if (encoded[0] == '<')
    strcpy (decoded, encoded);
  else
    sprintf (decoded, "<%s>", encoded);
  return decoded;

}

/* Table for keeping permanent unique copies of decoded names.  Once
   allocated, names in this table are never released.  While this is a
   storage leak, it should not be significant unless there are massive
   changes in the set of decoded names in successive versions of a 
   symbol table loaded during a single session.  */
static struct htab *decoded_names_store;

/* Returns the decoded name of GSYMBOL, as for ada_decode, caching it
   in the language-specific part of GSYMBOL, if it has not been
   previously computed.  Tries to save the decoded name in the same
   obstack as GSYMBOL, if possible, and otherwise on the heap (so that,
   in any case, the decoded symbol has a lifetime at least that of
   GSYMBOL).  
   The GSYMBOL parameter is "mutable" in the C++ sense: logically
   const, but nevertheless modified to a semantically equivalent form
   when a decoded name is cached in it.
*/

char *
ada_decode_symbol (const struct general_symbol_info *gsymbol)
{
  char **resultp =
    (char **) &gsymbol->language_specific.cplus_specific.demangled_name;
  if (*resultp == NULL)
    {
      const char *decoded = ada_decode (gsymbol->name);
      if (gsymbol->bfd_section != NULL)
        {
          bfd *obfd = gsymbol->bfd_section->owner;
          if (obfd != NULL)
            {
              struct objfile *objf;
              ALL_OBJFILES (objf)
              {
                if (obfd == objf->obfd)
                  {
                    *resultp = obsavestring (decoded, strlen (decoded),
                                             &objf->objfile_obstack);
                    break;
                  }
              }
            }
        }
      /* Sometimes, we can't find a corresponding objfile, in which
         case, we put the result on the heap.  Since we only decode
         when needed, we hope this usually does not cause a
         significant memory leak (FIXME).  */
      if (*resultp == NULL)
        {
          char **slot = (char **) htab_find_slot (decoded_names_store,
                                                  decoded, INSERT);
          if (*slot == NULL)
            *slot = xstrdup (decoded);
          *resultp = *slot;
        }
    }

  return *resultp;
}
a675 4
char *
ada_la_decode (const char *encoded, int options)
{
  return xstrdup (ada_decode (encoded));
d679 5
a683 5
   suffixes that encode debugging information or leading _ada_ on
   SYM_NAME (see is_name_suffix commentary for the debugging
   information that is ignored).  If WILD, then NAME need only match a
   suffix of SYM_NAME minus the same suffixes.  Also returns 0 if
   either argument is NULL.  */
d695 5
a699 5
      return (strncmp (sym_name, name, len_name) == 0
              && is_name_suffix (sym_name + len_name))
        || (strncmp (sym_name, "_ada_", 5) == 0
            && strncmp (sym_name + 5, name, len_name) == 0
            && is_name_suffix (sym_name + len_name + 5));
d703 2
a704 2
/* True (non-zero) iff, in Ada mode, the symbol SYM should be
   suppressed in info listings.  */
d712 1
a712 1
    return is_suppressed_name (SYMBOL_LINKAGE_NAME (sym));
d716 1
a716 1
                                /* Arrays */
d718 2
a719 1
/* Names of MAX_ADA_DIMENS bounds in P_BOUNDS fields of array descriptors.  */
d728 1
a728 1
#define MAX_ADA_DIMENS (sizeof(bound_name) / (2*sizeof(char *)))
d730 1
a730 1
/* Like modify_field, but allows bitpos > wordlength.  */
d735 2
a736 1
  modify_field (addr + bitpos / 8, fieldval, bitpos % 8, bitsize);
d740 2
a741 2
/* The desc_* routines return primitive portions of array descriptors
   (fat pointers).  */
d744 1
a744 2
   level of indirection, if needed.  */

d750 3
a752 5
  type = ada_check_typedef (type);
  if (type != NULL
      && (TYPE_CODE (type) == TYPE_CODE_PTR
          || TYPE_CODE (type) == TYPE_CODE_REF))
    return ada_check_typedef (TYPE_TARGET_TYPE (type));
d757 1
a757 2
/* True iff TYPE indicates a "thin" array pointer type.  */

d766 1
a766 2
/* The descriptor type for thin pointer type TYPE.  */

d779 1
a779 1
        return base_type;
d781 1
a781 1
        return alt_type;
d785 1
a785 2
/* A pointer to the array data for thin-pointer value VAL.  */

d792 1
a792 1
                       value_copy (val));
d795 1
a795 1
                               VALUE_ADDRESS (val) + VALUE_OFFSET (val));
d798 1
a798 2
/* True iff TYPE indicates a "thick" array pointer type.  */

d804 1
a804 1
          && lookup_struct_elt_type (type, "P_BOUNDS", 1) != NULL);
d807 2
a808 3
/* If TYPE is the type of an array descriptor (fat or thin pointer) or a
   pointer to one, the type of its bounds data; otherwise, NULL.  */

d822 1
a822 1
        return NULL;
d825 1
a825 1
        return ada_check_typedef (r);
d831 1
a831 1
        return ada_check_typedef (TYPE_TARGET_TYPE (ada_check_typedef (r)));
d837 1
a837 2
   one, a pointer to its bounds data.   Otherwise NULL.  */

d841 1
a841 1
  struct type *type = ada_check_typedef (VALUE_TYPE (arr));
d845 1
a845 1
        desc_bounds_type (thin_descriptor_type (type));
d849 1
a849 1
        error ("Bad GNAT array descriptor");
d853 1
a853 1
         the correct calculation is a real pain.  FIXME (and fix GCC).  */
d855 1
a855 1
        addr = value_as_long (arr);
d857 1
a857 1
        addr = VALUE_ADDRESS (arr) + VALUE_OFFSET (arr);
d860 2
a861 2
        value_from_longest (lookup_pointer_type (bounds_type),
                            addr - TYPE_LENGTH (bounds_type));
d866 1
a866 1
                             "Bad GNAT array descriptor");
d871 2
a872 3
/* If TYPE is the type of an array-descriptor (fat pointer),  the bit
   position of the field containing the address of the bounds data.  */

d880 1
a880 2
   size of the field containing the address of the bounds data.  */

d889 1
a889 1
    return 8 * TYPE_LENGTH (ada_check_typedef (TYPE_FIELD_TYPE (type, 1)));
d892 1
a892 1
/* If TYPE is the type of an array descriptor (fat or thin pointer) or a
d894 2
a895 3
   pointer-to-array-with-no-bounds type); otherwise, NULL.  Use
   ada_type_of_array to get an array type with bounds data.  */

d901 1
a901 1
  /* NOTE: The following is bogus; see comment in desc_bounds.  */
a912 1

d921 1
a921 1
                             "Bad GNAT array descriptor");
d928 1
a928 2
   position of the field containing the address of the data.  */

d936 1
a936 2
   size of the field containing the address of the data.  */

d948 1
a948 1
/* If BOUNDS is an array-bounds structure (or pointer to one), return
d950 1
a950 2
   bound, if WHICH is 1.  The first bound is I=1.  */

d955 1
a955 1
                           "Bad GNAT array descriptor bounds");
d960 1
a960 2
   bound, if WHICH is 1.  The first bound is I=1.  */

d969 1
a969 2
   bound, if WHICH is 1.  The first bound is I=1.  */

d982 1
a982 2
   Ith bound (numbering from 1).  Otherwise, NULL.  */

d994 2
a995 3
/* The number of index positions in the array-bounds type TYPE.
   Return 0 if TYPE is NULL.  */

a1005 15
/* Non-zero iff TYPE is a simple array type (not a pointer to one) or 
   an array descriptor type (representing an unconstrained array
   type).  */

static int
ada_is_direct_array_type (struct type *type)
{
  if (type == NULL)
    return 0;
  type = ada_check_typedef (type);
  return (TYPE_CODE (type) == TYPE_CODE_ARRAY
          || ada_is_array_descriptor_type (type));
}

/* Non-zero iff TYPE is a simple array type or pointer to one.  */
d1007 1
d1009 1
a1009 1
ada_is_simple_array_type (struct type *type)
d1013 1
a1013 1
  type = ada_check_typedef (type);
d1015 2
a1016 2
          || (TYPE_CODE (type) == TYPE_CODE_PTR
              && TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_ARRAY));
d1019 1
a1019 2
/* Non-zero iff TYPE belongs to a GNAT array descriptor.  */

d1021 1
a1021 1
ada_is_array_descriptor_type (struct type *type)
d1027 1
a1027 1
  type = ada_check_typedef (type);
d1031 4
a1034 3
         && TYPE_TARGET_TYPE (data_type) != NULL
         && TYPE_CODE (TYPE_TARGET_TYPE (data_type)) == TYPE_CODE_ARRAY)
        || TYPE_CODE (data_type) == TYPE_CODE_ARRAY)
d1039 1
a1039 1
   descriptor.  FIXME: This is to compensate for some problems with
d1041 1
a1041 2
   is still needed.  */

d1049 2
a1050 2
        || lookup_struct_elt_type (type, "P_ARRAY", 1) != NULL)
    && !ada_is_array_descriptor_type (type);
d1054 1
a1054 1
/* If ARR has a record type in the form of a standard GNAT array descriptor,
d1056 1
a1056 1
   a pointer-to-array type.  If BOUNDS is non-zero, the bounds data are filled
d1058 2
a1059 2
   the ARR denotes a null array descriptor and BOUNDS is non-zero,
   returns NULL.  The result is simply the type of ARR if ARR is not
d1067 1
a1067 1
  if (!ada_is_array_descriptor_type (VALUE_TYPE (arr)))
d1072 1
a1072 1
      ada_check_typedef (TYPE_TARGET_TYPE (desc_data_type (VALUE_TYPE (arr))));
d1084 1
a1084 1
        return ada_check_typedef (VALUE_TYPE (arr));
d1088 1
a1088 1
        return NULL;
d1090 12
a1101 12
        {
          struct type *range_type = alloc_type (objf);
          struct type *array_type = alloc_type (objf);
          struct value *low = desc_one_bound (descriptor, arity, 0);
          struct value *high = desc_one_bound (descriptor, arity, 1);
          arity -= 1;

          create_range_type (range_type, VALUE_TYPE (low),
                             (int) value_as_long (low),
                             (int) value_as_long (high));
          elt_type = create_array_type (array_type, elt_type, range_type);
        }
d1108 3
a1110 4
   Otherwise, returns either a standard GDB array with bounds set
   appropriately or, if ARR is a non-null fat pointer, a pointer to a standard
   GDB array.  Returns NULL if ARR is a null fat pointer.  */

d1114 1
a1114 1
  if (ada_is_array_descriptor_type (VALUE_TYPE (arr)))
d1118 1
a1118 1
        return NULL;
d1129 2
a1130 3
   be ARR itself if it already is in the proper form).  */

static struct value *
d1133 1
a1133 1
  if (ada_is_array_descriptor_type (VALUE_TYPE (arr)))
d1137 1
a1137 1
        error ("Bounds unavailable for null array pointer.");
d1148 1
a1148 2
   packing).  For other types, is the identity.  */

d1157 1
a1157 1
  value_free_to_mark (mark);
d1161 1
a1161 2
/* Non-zero iff TYPE represents a standard GNAT packed-array type.  */

d1167 1
a1167 2
  type = desc_base_type (type);
  type = ada_check_typedef (type);
d1179 2
a1180 3
   TYPE_FIELD_BITSIZE values, and with *ELT_BITS set to its total size
   in bits.  */

d1188 1
a1188 1
  type = ada_check_typedef (type);
d1193 2
a1194 2
  new_elt_type = packed_array_type (ada_check_typedef (TYPE_TARGET_TYPE (type)),
                                    elt_bits);
d1200 1
a1200 1
                           &low_bound, &high_bound) < 0)
d1208 1
a1208 1
        (*elt_bits + HOST_CHAR_BIT - 1) / HOST_CHAR_BIT;
d1211 2
a1212 1
  TYPE_FLAGS (new_type) |= TYPE_FLAG_FIXED_INSTANCE;
d1216 2
a1217 2
/* The array type encoded by TYPE, where ada_is_packed_array_type (TYPE).  */

d1221 1
a1221 1
  struct symbol *sym;
d1223 1
a1223 1
  const char *raw_name = ada_type_name (ada_check_typedef (type));
a1229 2
  type = desc_base_type (type);

d1233 9
a1241 2
  sym = standard_lookup (name, get_selected_block (0), VAR_DOMAIN);
  if (sym == NULL || SYMBOL_TYPE (sym) == NULL)
d1243 1
a1243 1
      lim_warning ("could not find bounds information on packed array");
d1246 1
a1246 1
  shadow_type = SYMBOL_TYPE (sym);
d1250 1
a1250 1
      lim_warning ("could not understand bounds information on packed array");
d1256 1
a1256 2
      lim_warning
	("could not understand bit size information on packed array");
d1263 1
a1263 1
/* Given that ARR is a struct value *indicating a GNAT packed array,
d1267 1
a1267 1
   type length is set appropriately.  */
d1272 1
a1272 5
  struct type *type;

  arr = ada_coerce_ref (arr);
  if (TYPE_CODE (VALUE_TYPE (arr)) == TYPE_CODE_PTR)
    arr = ada_value_ind (arr);
a1273 1
  type = decode_packed_array_type (VALUE_TYPE (arr));
d1279 2
a1280 26

  if (BITS_BIG_ENDIAN && ada_is_modular_type (VALUE_TYPE (arr)))
    {
       /* This is a (right-justified) modular type representing a packed
 	 array with no wrapper.  In order to interpret the value through
 	 the (left-justified) packed array type we just built, we must
 	 first left-justify it.  */
      int bit_size, bit_pos;
      ULONGEST mod;

      mod = ada_modulus (VALUE_TYPE (arr)) - 1;
      bit_size = 0;
      while (mod > 0)
	{
	  bit_size += 1;
	  mod >>= 1;
	}
      bit_pos = HOST_CHAR_BIT * TYPE_LENGTH (VALUE_TYPE (arr)) - bit_size;
      arr = ada_value_primitive_packed_val (arr, NULL,
					    bit_pos / HOST_CHAR_BIT,
					    bit_pos % HOST_CHAR_BIT,
					    bit_size,
					    type);
    }

  return coerce_unspec_val_to_type (arr, type);
d1285 1
a1285 1
   given in IND.   ARR must be a simple array.  */
d1298 1
a1298 1
  elt_type = ada_check_typedef (VALUE_TYPE (arr));
d1302 22
a1323 22
          || TYPE_FIELD_BITSIZE (elt_type, 0) == 0)
        error
          ("attempt to do packed indexing of something other than a packed array");
      else
        {
          struct type *range_type = TYPE_INDEX_TYPE (elt_type);
          LONGEST lowerbound, upperbound;
          LONGEST idx;

          if (get_discrete_bounds (range_type, &lowerbound, &upperbound) < 0)
            {
              lim_warning ("don't know bounds of array");
              lowerbound = upperbound = 0;
            }

          idx = value_as_long (value_pos_atr (ind[i]));
          if (idx < lowerbound || idx > upperbound)
            lim_warning ("packed array index %ld out of bounds", (long) idx);
          bits = TYPE_FIELD_BITSIZE (elt_type, 0);
          elt_total_bit_offset += (idx - lowerbound) * bits;
          elt_type = ada_check_typedef (TYPE_TARGET_TYPE (elt_type));
        }
d1329 1
a1329 1
                                      bits, elt_type);
d1337 1
a1337 1
/* Non-zero iff TYPE includes negative integer values.  */
d1357 5
a1361 5
   assigning through the result will set the field fetched from.  
   VALADDR is ignored unless OBJ is NULL, in which case,
   VALADDR+OFFSET must address the start of storage containing the 
   packed value.  The value returned  in this case is never an lval.
   Assumes 0 <= BIT_OFFSET < HOST_CHAR_BIT.  */
d1365 2
a1366 2
                                int bit_offset, int bit_size,
                                struct type *type)
d1369 8
a1376 8
  int src,                      /* Index into the source area */
    targ,                       /* Index into the target area */
    srcBitsLeft,                /* Number of source bits left to move */
    nsrc, ntarg,                /* Number of source and target bytes */
    unusedLS,                   /* Number of bits in next significant
                                   byte of source that are unused */
    accumSize;                  /* Number of meaningful bits in accum */
  unsigned char *bytes;         /* First byte containing data to unpack */
d1378 1
a1378 1
  unsigned long accum;          /* Staging area for bits being transferred */
d1381 2
a1382 2
  /* Transmit bytes from least to most significant; delta is the direction
     the indices move.  */
d1385 1
a1385 1
  type = ada_check_typedef (type);
d1395 1
a1395 1
                    VALUE_ADDRESS (obj) + VALUE_OFFSET (obj) + offset, NULL);
d1409 1
a1409 1
        VALUE_LVAL (v) = lval_internalvar_component;
d1414 4
a1417 4
        {
          VALUE_ADDRESS (v) += 1;
          VALUE_BITPOS (v) -= HOST_CHAR_BIT;
        }
d1435 3
a1437 3
      if (has_negatives (type)
          && ((bytes[0] << bit_offset) & (1 << (HOST_CHAR_BIT - 1))))
        sign = ~0;
d1440 2
a1441 2
        (HOST_CHAR_BIT - (bit_size + bit_offset) % HOST_CHAR_BIT)
        % HOST_CHAR_BIT;
d1444 16
a1459 16
        {
        case TYPE_CODE_ARRAY:
        case TYPE_CODE_UNION:
        case TYPE_CODE_STRUCT:
          /* Non-scalar values must be aligned at a byte boundary...  */
          accumSize =
            (HOST_CHAR_BIT - bit_size % HOST_CHAR_BIT) % HOST_CHAR_BIT;
          /* ... And are placed at the beginning (most-significant) bytes
             of the target.  */
          targ = src;
          break;
        default:
          accumSize = 0;
          targ = TYPE_LENGTH (type) - 1;
          break;
        }
d1470 1
a1470 1
        sign = ~0;
d1477 1
a1477 1
         part of the value.  */
d1479 3
a1481 3
        (1 << (srcBitsLeft >= HOST_CHAR_BIT ? HOST_CHAR_BIT : srcBitsLeft)) -
        1;
      /* Sign-extend bits for this byte.  */
d1484 1
a1484 1
        (((bytes[src] >> unusedLS) & unusedMSMask) | signMask) << accumSize;
d1487 7
a1493 7
        {
          unpacked[targ] = accum & ~(~0L << HOST_CHAR_BIT);
          accumSize -= HOST_CHAR_BIT;
          accum >>= HOST_CHAR_BIT;
          ntarg -= 1;
          targ += delta;
        }
d1514 1
a1514 1
   not overlap.  */
d1532 18
a1549 18
        {
          int unused_right;
          accum = (accum << HOST_CHAR_BIT) + (unsigned char) *source;
          accum_bits += HOST_CHAR_BIT;
          source += 1;
          chunk_size = HOST_CHAR_BIT - targ_offset;
          if (chunk_size > n)
            chunk_size = n;
          unused_right = HOST_CHAR_BIT - (chunk_size + targ_offset);
          mask = ((1 << chunk_size) - 1) << unused_right;
          *target =
            (*target & ~mask)
            | ((accum >> (accum_bits - chunk_size - unused_right)) & mask);
          n -= chunk_size;
          accum_bits -= chunk_size;
          target += 1;
          targ_offset = 0;
        }
d1558 15
a1572 15
        {
          accum = accum + ((unsigned char) *source << accum_bits);
          accum_bits += HOST_CHAR_BIT;
          source += 1;
          chunk_size = HOST_CHAR_BIT - targ_offset;
          if (chunk_size > n)
            chunk_size = n;
          mask = ((1 << chunk_size) - 1) << targ_offset;
          *target = (*target & ~mask) | ((accum << targ_offset) & mask);
          n -= chunk_size;
          accum_bits -= chunk_size;
          accum >>= chunk_size;
          target += 1;
          targ_offset = 0;
        }
d1580 1
a1580 1
   floating-point or non-scalar types.  */
d1596 1
a1596 1
          || TYPE_CODE (type) == TYPE_CODE_STRUCT))
d1599 1
a1599 1
        (VALUE_BITPOS (toval) + bits + HOST_CHAR_BIT - 1) / HOST_CHAR_BIT;
d1604 1
a1604 1
        fromval = value_cast (type, fromval);
d1608 4
a1611 4
        move_bits (buffer, VALUE_BITPOS (toval),
                   VALUE_CONTENTS (fromval),
                   TYPE_LENGTH (VALUE_TYPE (fromval)) * TARGET_CHAR_BIT -
                   bits, bits);
d1613 2
a1614 2
        move_bits (buffer, VALUE_BITPOS (toval), VALUE_CONTENTS (fromval),
                   0, bits);
d1616 1
a1616 1
                    len);
d1620 1
a1620 1
              TYPE_LENGTH (type));
d1630 2
a1631 2
/* The value of the element of array ARR at the ARITY indices given in IND.
   ARR may be either a simple array, GNAT array descriptor, or pointer
d1643 1
a1643 1
  elt_type = ada_check_typedef (VALUE_TYPE (elt));
d1651 1
a1651 1
        error ("too many subscripts (%d expected)", k);
d1659 1
a1659 1
   IND.  Does not read the entire array into memory.  */
d1663 1
a1663 1
                         struct value **ind)
d1673 1
a1673 1
        error ("too many subscripts (%d expected)", k);
d1675 1
a1675 1
                        value_copy (arr));
d1677 4
a1680 3
      idx = value_pos_atr (ind[k]);
      if (lwb != 0)
        idx = value_sub (idx, value_from_longest (builtin_type_int, lwb));
d1688 7
a1694 7
/* Given that ARRAY_PTR is a pointer or reference to an array of type TYPE (the
   actual type of ARRAY_PTR is ignored), returns a reference to
   the Ada slice of HIGH-LOW+1 elements starting at index LOW.  The lower
   bound of this array is LOW, as per Ada rules. */
static struct value *
ada_value_slice_ptr (struct value *array_ptr, struct type *type,
                     int low, int high)
d1696 1
a1696 32
  CORE_ADDR base = value_as_address (array_ptr)
    + ((low - TYPE_LOW_BOUND (TYPE_INDEX_TYPE (type)))
       * TYPE_LENGTH (TYPE_TARGET_TYPE (type)));
  struct type *index_type =
    create_range_type (NULL, TYPE_TARGET_TYPE (TYPE_INDEX_TYPE (type)),
                       low, high);
  struct type *slice_type =
    create_array_type (NULL, TYPE_TARGET_TYPE (type), index_type);
  return value_from_pointer (lookup_reference_type (slice_type), base);
}


static struct value *
ada_value_slice (struct value *array, int low, int high)
{
  struct type *type = VALUE_TYPE (array);
  struct type *index_type =
    create_range_type (NULL, TYPE_INDEX_TYPE (type), low, high);
  struct type *slice_type =
    create_array_type (NULL, TYPE_TARGET_TYPE (type), index_type);
  return value_cast (slice_type, value_slice (array, low, high - low + 1));
}

/* If type is a record type in the form of a standard GNAT array
   descriptor, returns the number of dimensions for type.  If arr is a
   simple array, returns the number of "array of"s that prefix its
   type designation.  Otherwise, returns 0.  */

int
ada_array_arity (struct type *type)
{
  int arity;
d1709 2
a1710 2
        arity += 1;
        type = ada_check_typedef (TYPE_TARGET_TYPE (type));
d1719 1
a1719 1
   NINDICES is -1.  Otherwise, returns NULL.  */
d1735 1
a1735 1
        return NULL;
d1737 1
a1737 1
      /* Initially p_array_type = elt_type(*)[]...(k times)...[].  */
d1739 1
a1739 1
        k = nindices;
d1742 4
a1745 4
        {
          p_array_type = ada_check_typedef (TYPE_TARGET_TYPE (p_array_type));
          k -= 1;
        }
d1751 4
a1754 4
        {
          type = TYPE_TARGET_TYPE (type);
          nindices -= 1;
        }
d1761 2
a1762 2
/* The type of nth index in arrays of given type (n numbering from 1).
   Does not examine memory.  */
a1766 2
  struct type *result_type;

d1772 1
a1772 1
  if (ada_is_simple_array_type (type))
d1777 1
a1777 7
        type = TYPE_TARGET_TYPE (type);
      result_type = TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, 0));
      /* FIXME: The stabs type r(0,0);bound;bound in an array type
         has a target type of TYPE_CODE_UNDEF.  We compensate here, but
         perhaps stabsread.c would make more sense.  */
      if (result_type == NULL || TYPE_CODE (result_type) == TYPE_CODE_UNDEF)
        result_type = builtin_type_int;
d1779 1
a1779 1
      return result_type;
d1787 4
a1790 4
   WHICH is 1.  This returns bounds 0 .. -1 if ARR_TYPE is an
   array-descriptor type.  If TYPEP is non-null, *TYPEP is set to the
   bounds type.  It works for other arrays with bounds supplied by
   run-time quantities other than discriminants.  */
d1794 1
a1794 1
                           struct type ** typep)
d1802 1
a1802 1
  if (arr_type == NULL || !ada_is_simple_array_type (arr_type))
d1805 1
a1805 1
        *typep = builtin_type_int;
d1821 4
a1824 4
        {
          type = TYPE_TARGET_TYPE (type);
          n -= 1;
        }
d1829 1
a1829 1
        index_type = builtin_type_long;
d1831 1
a1831 1
        *typep = index_type;
d1833 3
a1835 3
        (LONGEST) (which == 0
                   ? TYPE_LOW_BOUND (range_type)
                   : TYPE_HIGH_BOUND (range_type));
d1840 2
a1841 2
        to_fixed_range_type (TYPE_FIELD_NAME (index_type_desc, n - 1),
                             NULL, TYPE_OBJFILE (arr_type));
d1843 1
a1843 1
        *typep = TYPE_TARGET_TYPE (index_type);
d1845 3
a1847 3
        (LONGEST) (which == 0
                   ? TYPE_LOW_BOUND (index_type)
                   : TYPE_HIGH_BOUND (index_type));
d1853 2
a1854 2
   which is 1.  This routine will also work for arrays with bounds
   supplied by run-time quantities other than discriminants.  */
d1863 1
a1863 1
  else if (ada_is_simple_array_type (arr_type))
d1875 3
a1877 3
   supplied by run-time quantities other than discriminants.
   Does not work for arrays indexed by enumeration types with representation
   clauses at the moment.  */
d1882 2
a1883 1
  struct type *arr_type = ada_check_typedef (VALUE_TYPE (arr));
d1888 1
a1888 1
  if (ada_is_simple_array_type (arr_type))
d1892 2
a1893 2
        ada_array_bound_from_type (arr_type, n, 1, &type) -
        ada_array_bound_from_type (arr_type, n, 0, NULL) + 1;
d1898 5
a1902 18
      value_from_longest (builtin_type_int,
                          value_as_long (desc_one_bound (desc_bounds (arr),
                                                         n, 1))
                          - value_as_long (desc_one_bound (desc_bounds (arr),
                                                           n, 0)) + 1);
}

/* An empty array whose type is that of ARR_TYPE (an array type),
   with bounds LOW to LOW-1.  */

static struct value *
empty_array (struct type *arr_type, int low)
{
  struct type *index_type =
    create_range_type (NULL, TYPE_TARGET_TYPE (TYPE_INDEX_TYPE (arr_type)),
                       low, low - 1);
  struct type *elt_type = ada_array_element_type (arr_type, 1);
  return allocate_value (create_array_type (NULL, elt_type, index_type));
d1906 1
a1906 1
                                /* Name resolution */
d1908 2
a1909 2
/* The "decoded" name for the user-definable Ada operator corresponding
   to OP.  */
d1912 1
a1912 1
ada_decoded_op_name (enum exp_opcode op)
d1916 1
a1916 1
  for (i = 0; ada_opname_table[i].encoded != NULL; i += 1)
d1919 1
a1919 1
        return ada_opname_table[i].decoded;
d1925 3
a1927 4
/* Same as evaluate_type (*EXP), but resolves ambiguous symbol
   references (marked by OP_VAR_VALUE nodes in which the symbol has an
   undefined namespace) and converts operators that are
   user-defined into appropriate function calls.  If CONTEXT_TYPE is
d1931 3
a1933 1
   return type is preferred.  May change (expand) *EXP.  */
d1935 2
a1936 2
static void
resolve (struct expression **expp, int void_context_p)
d1940 1
a1940 1
  resolve_subexp (expp, &pc, 1, void_context_p ? builtin_type_void : NULL);
d1943 7
a1949 8
/* Resolve the operator of the subexpression beginning at
   position *POS of *EXPP.  "Resolving" consists of replacing
   the symbols that have undefined namespaces in OP_VAR_VALUE nodes
   with their resolutions, replacing built-in operators with
   function calls to user-defined operators, where appropriate, and,
   when DEPROCEDURE_P is non-zero, converting function-valued variables
   into parameterless calls.  May expand *EXPP.  The CONTEXT_TYPE functions
   are as in ada_resolve, above.  */
d1952 2
a1953 2
resolve_subexp (struct expression **expp, int *pos, int deprocedure_p,
                struct type *context_type)
d1957 1
a1957 1
  struct expression *exp;       /* Convenience: == *expp.  */
d1959 2
a1960 2
  struct value **argvec;        /* Vector of operand types (alloca'ed).  */
  int nargs;                    /* Number of operands.  */
d1966 1
a1966 1
  /* Pass one: resolve operands, saving their types and updating *pos.  */
d1969 4
a1972 15
    case OP_FUNCALL:
      if (exp->elts[pc + 3].opcode == OP_VAR_VALUE
          && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)
        *pos += 7;
      else
        {
          *pos += 3;
          resolve_subexp (expp, pos, 0, NULL);
        }
      nargs = longest_to_int (exp->elts[pc + 1].longconst);
      break;

    case UNOP_QUAL:
      *pos += 3;
      resolve_subexp (expp, pos, 1, exp->elts[pc + 1].type);
d1975 40
a2015 11
      *pos += 1;
      resolve_subexp (expp, pos, 0, NULL);
      break;

    case OP_ATR_MODULUS:
      *pos += 4;
      break;

    case OP_ATR_SIZE:
    case OP_ATR_TAG:
      *pos += 1;
a2016 13
      break;

    case OP_ATR_FIRST:
    case OP_ATR_LAST:
    case OP_ATR_LENGTH:
    case OP_ATR_POS:
    case OP_ATR_VAL:
      *pos += 1;
      nargs = 2;
      break;

    case OP_ATR_MIN:
    case OP_ATR_MAX:
d2018 2
a2019 1
      nargs = 3;
d2024 9
a2032 9
        struct value *arg1;

        *pos += 1;
        arg1 = resolve_subexp (expp, pos, 0, NULL);
        if (arg1 == NULL)
          resolve_subexp (expp, pos, 1, NULL);
        else
          resolve_subexp (expp, pos, 1, VALUE_TYPE (arg1));
        break;
d2035 95
a2129 5
    case UNOP_CAST:
    case UNOP_IN_RANGE:
      *pos += 3;
      nargs = 1;
      break;
d2131 6
a2136 54
    case BINOP_ADD:
    case BINOP_SUB:
    case BINOP_MUL:
    case BINOP_DIV:
    case BINOP_REM:
    case BINOP_MOD:
    case BINOP_EXP:
    case BINOP_CONCAT:
    case BINOP_LOGICAL_AND:
    case BINOP_LOGICAL_OR:
    case BINOP_BITWISE_AND:
    case BINOP_BITWISE_IOR:
    case BINOP_BITWISE_XOR:

    case BINOP_EQUAL:
    case BINOP_NOTEQUAL:
    case BINOP_LESS:
    case BINOP_GTR:
    case BINOP_LEQ:
    case BINOP_GEQ:

    case BINOP_REPEAT:
    case BINOP_SUBSCRIPT:
    case BINOP_COMMA:
      *pos += 1;
      nargs = 2;
      break;

    case UNOP_NEG:
    case UNOP_PLUS:
    case UNOP_LOGICAL_NOT:
    case UNOP_ABS:
    case UNOP_IND:
      *pos += 1;
      nargs = 1;
      break;

    case OP_LONG:
    case OP_DOUBLE:
    case OP_VAR_VALUE:
      *pos += 4;
      break;

    case OP_TYPE:
    case OP_BOOL:
    case OP_LAST:
    case OP_REGISTER:
    case OP_INTERNALVAR:
      *pos += 3;
      break;

    case UNOP_MEMVAL:
      *pos += 3;
      nargs = 1;
a2137 25

    case STRUCTOP_STRUCT:
      *pos += 4 + BYTES_TO_EXP_ELEM (exp->elts[pc + 1].longconst + 1);
      nargs = 1;
      break;

    case OP_STRING:
      (*pos) += 3 
        + BYTES_TO_EXP_ELEM (longest_to_int (exp->elts[pc + 1].longconst) 
                             + 1);
      break;

    case TERNOP_SLICE:
    case TERNOP_IN_RANGE:
      *pos += 1;
      nargs = 3;
      break;

    case BINOP_IN_BOUNDS:
      *pos += 3;
      nargs = 2;
      break;

    default:
      error ("Unexpected operator during name resolution");
d2140 1
a2140 7
  argvec = (struct value * *) alloca (sizeof (struct value *) * (nargs + 1));
  for (i = 0; i < nargs; i += 1)
    argvec[i] = resolve_subexp (expp, pos, 1, NULL);
  argvec[i] = NULL;
  exp = *expp;

  /* Pass two: perform any resolution on principal operator.  */
d2146 88
d2235 9
a2243 92
      if (SYMBOL_DOMAIN (exp->elts[pc + 2].symbol) == UNDEF_DOMAIN)
        {
          struct ada_symbol_info *candidates;
          int n_candidates;

          n_candidates =
            ada_lookup_symbol_list (SYMBOL_LINKAGE_NAME
                                    (exp->elts[pc + 2].symbol),
                                    exp->elts[pc + 1].block, VAR_DOMAIN,
                                    &candidates);

          if (n_candidates > 1)
            {
              /* Types tend to get re-introduced locally, so if there
                 are any local symbols that are not types, first filter
                 out all types.  */
              int j;
              for (j = 0; j < n_candidates; j += 1)
                switch (SYMBOL_CLASS (candidates[j].sym))
                  {
                  case LOC_REGISTER:
                  case LOC_ARG:
                  case LOC_REF_ARG:
                  case LOC_REGPARM:
                  case LOC_REGPARM_ADDR:
                  case LOC_LOCAL:
                  case LOC_LOCAL_ARG:
                  case LOC_BASEREG:
                  case LOC_BASEREG_ARG:
                  case LOC_COMPUTED:
                  case LOC_COMPUTED_ARG:
                    goto FoundNonType;
                  default:
                    break;
                  }
            FoundNonType:
              if (j < n_candidates)
                {
                  j = 0;
                  while (j < n_candidates)
                    {
                      if (SYMBOL_CLASS (candidates[j].sym) == LOC_TYPEDEF)
                        {
                          candidates[j] = candidates[n_candidates - 1];
                          n_candidates -= 1;
                        }
                      else
                        j += 1;
                    }
                }
            }

          if (n_candidates == 0)
            error ("No definition found for %s",
                   SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));
          else if (n_candidates == 1)
            i = 0;
          else if (deprocedure_p
                   && !is_nonfunction (candidates, n_candidates))
            {
              i = ada_resolve_function
                (candidates, n_candidates, NULL, 0,
                 SYMBOL_LINKAGE_NAME (exp->elts[pc + 2].symbol),
                 context_type);
              if (i < 0)
                error ("Could not find a match for %s",
                       SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));
            }
          else
            {
              printf_filtered ("Multiple matches for %s\n",
                               SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));
              user_select_syms (candidates, n_candidates, 1);
              i = 0;
            }

          exp->elts[pc + 1].block = candidates[i].block;
          exp->elts[pc + 2].symbol = candidates[i].sym;
          if (innermost_block == NULL
              || contained_in (candidates[i].block, innermost_block))
            innermost_block = candidates[i].block;
        }

      if (deprocedure_p
          && (TYPE_CODE (SYMBOL_TYPE (exp->elts[pc + 2].symbol))
              == TYPE_CODE_FUNC))
        {
          replace_operator_with_call (expp, pc, 0, 0,
                                      exp->elts[pc + 2].symbol,
                                      exp->elts[pc + 1].block);
          exp = *expp;
        }
d2248 32
a2279 31
        if (exp->elts[pc + 3].opcode == OP_VAR_VALUE
            && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)
          {
            struct ada_symbol_info *candidates;
            int n_candidates;

            n_candidates =
              ada_lookup_symbol_list (SYMBOL_LINKAGE_NAME
                                      (exp->elts[pc + 5].symbol),
                                      exp->elts[pc + 4].block, VAR_DOMAIN,
                                      &candidates);
            if (n_candidates == 1)
              i = 0;
            else
              {
                i = ada_resolve_function
                  (candidates, n_candidates,
                   argvec, nargs,
                   SYMBOL_LINKAGE_NAME (exp->elts[pc + 5].symbol),
                   context_type);
                if (i < 0)
                  error ("Could not find a match for %s",
                         SYMBOL_PRINT_NAME (exp->elts[pc + 5].symbol));
              }

            exp->elts[pc + 4].block = candidates[i].block;
            exp->elts[pc + 5].symbol = candidates[i].sym;
            if (innermost_block == NULL
                || contained_in (candidates[i].block, innermost_block))
              innermost_block = candidates[i].block;
          }
d2304 20
a2323 17
        {
          struct ada_symbol_info *candidates;
          int n_candidates;

          n_candidates =
            ada_lookup_symbol_list (ada_encode (ada_decoded_op_name (op)),
                                    (struct block *) NULL, VAR_DOMAIN,
                                    &candidates);
          i = ada_resolve_function (candidates, n_candidates, argvec, nargs,
                                    ada_decoded_op_name (op), NULL);
          if (i < 0)
            break;

          replace_operator_with_call (expp, pc, nargs, 1,
                                      candidates[i].sym, candidates[i].block);
          exp = *expp;
        }
a2324 3

    case OP_TYPE:
      return NULL;
d2332 2
a2333 3
   MAY_DEREF is non-zero, the formal may be a pointer and the actual
   a non-pointer.   A type of 'void' (which is never a valid expression type)
   by convention matches anything. */
d2335 1
a2335 1
   liberal.  FIXME: TOO liberal, in fact.  */
d2340 2
a2341 2
  ftype = ada_check_typedef (ftype);
  atype = ada_check_typedef (atype);
d2358 2
a2359 2
        return ada_type_match (TYPE_TARGET_TYPE (ftype),
                               TYPE_TARGET_TYPE (atype), 0);
d2361 2
a2362 2
        return (may_deref
                && ada_type_match (TYPE_TARGET_TYPE (ftype), atype, 0));
d2367 8
a2374 8
        {
        case TYPE_CODE_INT:
        case TYPE_CODE_ENUM:
        case TYPE_CODE_RANGE:
          return 1;
        default:
          return 0;
        }
d2378 1
a2378 1
              || ada_is_array_descriptor_type (atype));
d2381 3
a2383 3
      if (ada_is_array_descriptor_type (ftype))
        return (TYPE_CODE (atype) == TYPE_CODE_ARRAY
                || ada_is_array_descriptor_type (atype));
d2385 2
a2386 2
        return (TYPE_CODE (atype) == TYPE_CODE_STRUCT
                && !ada_is_array_descriptor_type (atype));
d2397 1
a2397 1
   argument function.  */
d2405 2
a2406 2
  if (SYMBOL_CLASS (func) == LOC_CONST
      && TYPE_CODE (func_type) == TYPE_CODE_ENUM)
d2416 6
a2421 10
      if (actuals[i] == NULL)
        return 0;
      else
        {
          struct type *ftype = ada_check_typedef (TYPE_FIELD_TYPE (func_type, i));
          struct type *atype = ada_check_typedef (VALUE_TYPE (actuals[i]));

          if (!ada_type_match (ftype, atype, 1))
            return 0;
        }
d2439 5
a2443 4
  if (TYPE_CODE (func_type) == TYPE_CODE_FUNC)
    return_type = base_type (TYPE_TARGET_TYPE (func_type));
  else
    return_type = base_type (func_type);
d2447 2
a2448 1
  context_type = base_type (context_type);
d2459 1
a2459 1
/* Returns the index in SYMS[0..NSYMS-1] that contains  the symbol for the
d2461 3
a2463 5
   ARGS.  If CONTEXT_TYPE is non-null and there is at least one match
   that returns that type, then eliminate matches that don't.  If
   CONTEXT_TYPE is void and there is at least one match that does not
   return void, eliminate all matches that do.

d2466 3
a2468 2
   solely for messages.  May re-arrange and modify SYMS in
   the process; the index returned is for the modified vector.  */
d2470 4
a2473 4
static int
ada_resolve_function (struct ada_symbol_info syms[],
                      int nsyms, struct value **args, int nargs,
                      const char *name, struct type *context_type)
d2476 1
a2476 1
  int m;                        /* Number of hits */
d2490 2
a2491 2
        {
          struct type *type = ada_check_typedef (SYMBOL_TYPE (syms[k].sym));
d2493 9
a2501 7
          if (ada_args_match (syms[k].sym, args, nargs)
              && return_match (type, return_type))
            {
              syms[m] = syms[k];
              m += 1;
            }
        }
d2503 1
a2503 1
        break;
d2505 1
a2505 1
        return_type = fallback;
d2513 1
a2513 1
      user_select_syms (syms, m, 1);
d2519 5
a2523 6
/* Returns true (non-zero) iff decoded name N0 should appear before N1
   in a listing of choices during disambiguation (see sort_choices, below).
   The idea is that overloadings of a subprogram name from the
   same package should sort in their source order.  We settle for ordering
   such symbols by their trailing number (__N  or $N).  */

d2525 1
a2525 1
encoded_ordered_before (char *N0, char *N1)
d2535 1
a2535 1
        ;
d2537 1
a2537 1
        ;
d2539 12
a2550 12
          && (N1[k1] == '_' || N1[k1] == '$') && N1[k1 + 1] != '\000')
        {
          int n0, n1;
          n0 = k0;
          while (N0[n0] == '_' && n0 > 0 && N0[n0 - 1] == '_')
            n0 -= 1;
          n1 = k1;
          while (N1[n1] == '_' && n1 > 0 && N1[n1 - 1] == '_')
            n1 -= 1;
          if (n0 == n1 && strncmp (N0, N1, n0) == 0)
            return (atoi (N0 + k0 + 1) < atoi (N1 + k1 + 1));
        }
d2555 3
a2557 3
/* Sort SYMS[0..NSYMS-1] to put the choices in a canonical order by the
   encoded names.  */

d2559 1
a2559 1
sort_choices (struct ada_symbol_info syms[], int nsyms)
d2561 1
a2561 1
  int i;
d2564 2
a2565 1
      struct ada_symbol_info sym = syms[i];
d2569 7
a2575 6
        {
          if (encoded_ordered_before (SYMBOL_LINKAGE_NAME (syms[j].sym),
                                      SYMBOL_LINKAGE_NAME (sym.sym)))
            break;
          syms[j + 1] = syms[j];
        }
d2577 1
d2581 6
a2586 4
/* Given a list of NSYMS symbols in SYMS, select up to MAX_RESULTS>0 
   by asking the user (if necessary), returning the number selected, 
   and setting the first elements of SYMS items.  Error if no symbols
   selected.  */
d2589 1
a2589 1
   to be re-integrated one of these days.  */
d2592 2
a2593 1
user_select_syms (struct ada_symbol_info *syms, int nsyms, int max_results)
d2609 1
a2609 1
  sort_choices (syms, nsyms);
d2613 2
a2614 2
      if (syms[i].sym == NULL)
        continue;
d2616 45
a2660 47
      if (SYMBOL_CLASS (syms[i].sym) == LOC_BLOCK)
        {
          struct symtab_and_line sal =
            find_function_start_sal (syms[i].sym, 1);
          printf_unfiltered ("[%d] %s at %s:%d\n", i + first_choice,
                             SYMBOL_PRINT_NAME (syms[i].sym),
                             (sal.symtab == NULL
                              ? "<no source file available>"
                              : sal.symtab->filename), sal.line);
          continue;
        }
      else
        {
          int is_enumeral =
            (SYMBOL_CLASS (syms[i].sym) == LOC_CONST
             && SYMBOL_TYPE (syms[i].sym) != NULL
             && TYPE_CODE (SYMBOL_TYPE (syms[i].sym)) == TYPE_CODE_ENUM);
          struct symtab *symtab = symtab_for_sym (syms[i].sym);

          if (SYMBOL_LINE (syms[i].sym) != 0 && symtab != NULL)
            printf_unfiltered ("[%d] %s at %s:%d\n",
                               i + first_choice,
                               SYMBOL_PRINT_NAME (syms[i].sym),
                               symtab->filename, SYMBOL_LINE (syms[i].sym));
          else if (is_enumeral
                   && TYPE_NAME (SYMBOL_TYPE (syms[i].sym)) != NULL)
            {
              printf_unfiltered ("[%d] ", i + first_choice);
              ada_print_type (SYMBOL_TYPE (syms[i].sym), NULL,
                              gdb_stdout, -1, 0);
              printf_unfiltered ("'(%s) (enumeral)\n",
                                 SYMBOL_PRINT_NAME (syms[i].sym));
            }
          else if (symtab != NULL)
            printf_unfiltered (is_enumeral
                               ? "[%d] %s in %s (enumeral)\n"
                               : "[%d] %s at %s:?\n",
                               i + first_choice,
                               SYMBOL_PRINT_NAME (syms[i].sym),
                               symtab->filename);
          else
            printf_unfiltered (is_enumeral
                               ? "[%d] %s (enumeral)\n"
                               : "[%d] %s at ?\n",
                               i + first_choice,
                               SYMBOL_PRINT_NAME (syms[i].sym));
        }
d2664 1
a2664 1
                             "overload-choice");
d2667 5
a2671 1
    syms[i] = syms[chosen[i]];
d2677 1
a2677 1
   range 0 .. N_CHOICES-1.  Place the results in increasing
d2683 1
a2683 1
     + A choice of 0 means to cancel the selection, throwing an error.
d2687 1
a2687 1
   The user is not allowed to choose more than MAX_RESULTS values.
d2690 1
a2690 1
   prompts (for use with the -f switch).  */
d2694 1
a2694 1
                int is_all_choice, char *annotation_suffix)
d2696 1
d2716 2
a2717 2
  /* Set choices[0 .. n_chosen-1] to the users' choices in ascending
     order, as given in args.  Choices are validated.  */
d2724 1
a2724 1
        args += 1;
d2726 1
a2726 1
        error_no_arg ("one or more choice numbers");
d2728 1
a2728 1
        break;
d2732 2
a2733 2
          || choice > n_choices + first_choice - 1)
        error ("Argument must be choice number");
d2737 1
a2737 1
        error ("cancelled");
d2740 6
a2745 6
        {
          n_chosen = n_choices;
          for (j = 0; j < n_choices; j += 1)
            choices[j] = j;
          break;
        }
d2749 2
a2750 2
        {
        }
d2753 7
a2759 7
        {
          int k;
          for (k = n_chosen - 1; k > j; k -= 1)
            choices[k + 1] = choices[k];
          choices[j + 1] = choice;
          n_chosen += 1;
        }
d2768 3
a2770 3
/* Replace the operator of length OPLEN at position PC in *EXPP with a call
   on the function identified by SYM and BLOCK, and taking NARGS
   arguments.  Update *EXPP as needed to hold more space.  */
d2774 2
a2775 2
                            int oplen, struct symbol *sym,
                            struct block *block)
d2778 1
a2778 1
     symbol, -oplen for operator being replaced).  */
d2781 1
a2781 1
             + EXP_ELEM_TO_BYTES ((*expp)->nelts + 7 - oplen));
d2788 1
a2788 1
          EXP_ELEM_TO_BYTES (exp->nelts - pc - oplen));
d2803 2
a2804 2
/* True iff TYPE is numeric (i.e., an INT, RANGE (of numeric type),
   or FLOAT).  */
d2814 10
a2823 10
        {
        case TYPE_CODE_INT:
        case TYPE_CODE_FLT:
          return 1;
        case TYPE_CODE_RANGE:
          return (type == TYPE_TARGET_TYPE (type)
                  || numeric_type_p (TYPE_TARGET_TYPE (type)));
        default:
          return 0;
        }
d2827 1
a2827 1
/* True iff TYPE is integral (an INT or RANGE of INTs).  */
d2837 9
a2845 9
        {
        case TYPE_CODE_INT:
          return 1;
        case TYPE_CODE_RANGE:
          return (type == TYPE_TARGET_TYPE (type)
                  || integer_type_p (TYPE_TARGET_TYPE (type)));
        default:
          return 0;
        }
d2849 1
a2849 1
/* True iff TYPE is scalar (INT, RANGE, FLOAT, ENUM).  */
d2859 9
a2867 9
        {
        case TYPE_CODE_INT:
        case TYPE_CODE_RANGE:
        case TYPE_CODE_ENUM:
        case TYPE_CODE_FLT:
          return 1;
        default:
          return 0;
        }
d2871 1
a2871 1
/* True iff TYPE is discrete (INT, RANGE, ENUM).  */
d2881 8
a2888 8
        {
        case TYPE_CODE_INT:
        case TYPE_CODE_RANGE:
        case TYPE_CODE_ENUM:
          return 1;
        default:
          return 0;
        }
d2892 3
a2894 3
/* Returns non-zero if OP with operands in the vector ARGS could be
   a user-defined function.  Errs on the side of pre-defined operators
   (i.e., result 0).  */
d2899 1
a2899 2
  struct type *type0 =
    (args[0] == NULL) ? NULL : ada_check_typedef (VALUE_TYPE (args[0]));
d2901 1
a2901 4
    (args[1] == NULL) ? NULL : ada_check_typedef (VALUE_TYPE (args[1]));

  if (type0 == NULL)
    return 0;
d2930 7
a2936 8
      return
        ((TYPE_CODE (type0) != TYPE_CODE_ARRAY
          && (TYPE_CODE (type0) != TYPE_CODE_PTR
              || TYPE_CODE (TYPE_TARGET_TYPE (type0)) != TYPE_CODE_ARRAY))
         || (TYPE_CODE (type1) != TYPE_CODE_ARRAY
             && (TYPE_CODE (type1) != TYPE_CODE_PTR
                 || (TYPE_CODE (TYPE_TARGET_TYPE (type1)) 
		     != TYPE_CODE_ARRAY))));
d2950 1
a2950 1
                                /* Renaming */
d2952 3
a2954 3
/* NOTE: In the following, we assume that a renaming type's name may
   have an ___XD suffix.  It would be nice if this went away at some
   point.  */
d2957 3
a2959 4
   is XR for an object renaming, XRP for a procedure renaming, XRE for
   an exception renaming, and XRS for a subprogram renaming.  Returns
   NULL if NAME encodes none of these.  */

d2968 2
a2969 2
          || (suffix[5] != '\000' && strchr ("PES_", suffix[5]) == NULL))
        return NULL;
d2971 1
a2971 1
        return suffix + 3;
d2977 1
a2977 2
/* Return non-zero iff SYM encodes an object renaming.  */

d2987 3
a2989 4
   name of the renamed entity.  The name is good until the end of
   parsing.  */

char *
d3007 2
d3015 1
a3015 1
                                /* Evaluation: Function Calls */
d3017 2
a3018 4
/* Return an lvalue containing the value VAL.  This is the identity on
   lvalues, and otherwise has the side-effect of pushing a copy of VAL 
   on the stack, using and updating *SP as the stack pointer, and 
   returning an lvalue whose VALUE_ADDRESS points to the copy.  */
d3021 1
a3021 1
ensure_lval (struct value *val, CORE_ADDR *sp)
d3023 1
a3023 3
  if (! VALUE_LVAL (val))
    {
      int len = TYPE_LENGTH (ada_check_typedef (VALUE_TYPE (val)));
d3025 8
a3032 23
      /* The following is taken from the structure-return code in
	 call_function_by_hand. FIXME: Therefore, some refactoring seems 
	 indicated. */
      if (INNER_THAN (1, 2))
	{
	  /* Stack grows downward.  Align SP and VALUE_ADDRESS (val) after
	     reserving sufficient space. */
	  *sp -= len;
	  if (gdbarch_frame_align_p (current_gdbarch))
	    *sp = gdbarch_frame_align (current_gdbarch, *sp);
	  VALUE_ADDRESS (val) = *sp;
	}
      else
	{
	  /* Stack grows upward.  Align the frame, allocate space, and
	     then again, re-align the frame. */
	  if (gdbarch_frame_align_p (current_gdbarch))
	    *sp = gdbarch_frame_align (current_gdbarch, *sp);
	  VALUE_ADDRESS (val) = *sp;
	  *sp += len;
	  if (gdbarch_frame_align_p (current_gdbarch))
	    *sp = gdbarch_frame_align (current_gdbarch, *sp);
	}
d3034 5
a3038 2
      write_memory (VALUE_ADDRESS (val), VALUE_CONTENTS_RAW (val), len);
    }
d3046 1
a3046 1
   values not residing in memory, updating it as needed.  */
d3050 1
a3050 1
                CORE_ADDR *sp)
d3052 2
a3053 2
  struct type *actual_type = ada_check_typedef (VALUE_TYPE (actual));
  struct type *formal_type = ada_check_typedef (formal_type0);
d3056 1
a3056 1
    ? ada_check_typedef (TYPE_TARGET_TYPE (formal_type)) : formal_type;
d3059 1
a3059 1
    ? ada_check_typedef (TYPE_TARGET_TYPE (actual_type)) : actual_type;
d3061 1
a3061 1
  if (ada_is_array_descriptor_type (formal_target)
d3067 2
a3068 2
          && ada_is_array_descriptor_type (actual_target))
        return desc_data (actual);
d3070 13
a3082 13
        {
          if (VALUE_LVAL (actual) != lval_memory)
            {
              struct value *val;
              actual_type = ada_check_typedef (VALUE_TYPE (actual));
              val = allocate_value (actual_type);
              memcpy ((char *) VALUE_CONTENTS_RAW (val),
                      (char *) VALUE_CONTENTS (actual),
                      TYPE_LENGTH (actual_type));
              actual = ensure_lval (val, sp);
            }
          return value_addr (actual);
        }
d3091 2
a3092 2
/* Push a descriptor of type TYPE for array value ARR on the stack at
   *SP, updating *SP to reflect the new descriptor.  Return either
d3094 2
a3095 2
   to-descriptor type rather than a descriptor type), a struct value *
   representing a pointer to this descriptor.  */
d3104 1
d3107 1
a3107 1
  for (i = ada_array_arity (ada_check_typedef (VALUE_TYPE (arr))); i > 0; i -= 1)
d3110 3
a3112 3
                            value_as_long (ada_array_bound (arr, i, 0)),
                            desc_bound_bitpos (bounds_type, i, 0),
                            desc_bound_bitsize (bounds_type, i, 0));
d3114 3
a3116 3
                            value_as_long (ada_array_bound (arr, i, 1)),
                            desc_bound_bitpos (bounds_type, i, 1),
                            desc_bound_bitsize (bounds_type, i, 1));
d3119 1
a3119 1
  bounds = ensure_lval (bounds, sp);
d3122 3
a3124 4
                        VALUE_ADDRESS (ensure_lval (arr, sp)),
                        fat_pntr_data_bitpos (desc_type),
                        fat_pntr_data_bitsize (desc_type));

d3126 3
a3128 3
                        VALUE_ADDRESS (bounds),
                        fat_pntr_bounds_bitpos (desc_type),
                        fat_pntr_bounds_bitsize (desc_type));
d3130 1
a3130 1
  descriptor = ensure_lval (descriptor, sp);
d3139 1
a3139 1
/* Assuming a dummy frame has been established on the target, perform any
d3141 1
a3141 1
   parameters in ARGS, other than standard C conversions.  Does
d3143 1
a3143 1
   does not match the number of arguments expected.  Use *SP as a
d3145 1
a3145 1
   value as needed.  */
d3149 1
a3149 1
                     CORE_ADDR *sp)
a3161 2
/* Dummy definitions for an experimental caching module that is not
 * used in the public sources. */
d3163 11
a3173 7
static int
lookup_cached_symbol (const char *name, domain_enum namespace,
                      struct symbol **sym, struct block **block,
                      struct symtab **symtab)
{
  return 0;
}
d3175 2
a3176 7
static void
cache_symbol (const char *name, domain_enum namespace, struct symbol *sym,
              struct block *block, struct symtab *symtab)
{
}

                                /* Symbol Lookup */
d3178 2
a3179 2
/* Return the result of a standard (literal, C-like) lookup of NAME in
   given DOMAIN, visible from lexical block BLOCK.  */
d3182 1
a3182 2
standard_lookup (const char *name, const struct block *block,
                 domain_enum domain)
d3185 1
a3185 7
  struct symtab *symtab;

  if (lookup_cached_symbol (name, domain, &sym, NULL, NULL))
    return sym;
  sym =
    lookup_symbol_in_language (name, block, domain, language_c, 0, &symtab);
  cache_symbol (name, domain, sym, block_found, symtab);
d3190 3
a3192 3
/* Non-zero iff there is at least one non-function/non-enumeral symbol
   in the symbol fields of SYMS[0..N-1].  We treat enumerals as functions, 
   since they contend in overloading in the same way.  */
d3194 1
a3194 1
is_nonfunction (struct ada_symbol_info syms[], int n)
d3199 2
a3200 3
    if (TYPE_CODE (SYMBOL_TYPE (syms[i].sym)) != TYPE_CODE_FUNC
        && (TYPE_CODE (SYMBOL_TYPE (syms[i].sym)) != TYPE_CODE_ENUM
            || SYMBOL_CLASS (syms[i].sym) != LOC_CONST))
d3207 1
a3207 1
   struct types.  Otherwise, they may not.  */
d3220 1
a3220 1
      && strcmp (ada_type_name (type0), ada_type_name (type1)) == 0)
d3227 1
a3227 1
   no more defined than that of SYM1.  */
d3244 10
a3253 10
        struct type *type0 = SYMBOL_TYPE (sym0);
        struct type *type1 = SYMBOL_TYPE (sym1);
        char *name0 = SYMBOL_LINKAGE_NAME (sym0);
        char *name1 = SYMBOL_LINKAGE_NAME (sym1);
        int len0 = strlen (name0);
        return
          TYPE_CODE (type0) == TYPE_CODE (type1)
          && (equiv_types (type0, type1)
              || (len0 < strlen (name1) && strncmp (name0, name1, len0) == 0
                  && strncmp (name1 + len0, "___XV", 5) == 0));
d3257 1
a3257 1
        && equiv_types (SYMBOL_TYPE (sym0), SYMBOL_TYPE (sym1));
d3263 3
a3265 2
/* Append (SYM,BLOCK,SYMTAB) to the end of the array of struct ada_symbol_info
   records in OBSTACKP.  Do nothing if SYM is a duplicate.  */
d3268 1
a3268 3
add_defn_to_vec (struct obstack *obstackp,
                 struct symbol *sym,
                 struct block *block, struct symtab *symtab)
a3271 1
  struct ada_symbol_info *prevDefns = defns_collected (obstackp, 0);
d3274 2
a3275 2
    SYMBOL_TYPE (sym) = ada_check_typedef (SYMBOL_TYPE (sym));
  for (i = num_defns_collected (obstackp) - 1; i >= 0; i -= 1)
d3277 8
a3284 9
      if (lesseq_defined_than (sym, prevDefns[i].sym))
        return;
      else if (lesseq_defined_than (prevDefns[i].sym, sym))
        {
          prevDefns[i].sym = sym;
          prevDefns[i].block = block;
          prevDefns[i].symtab = symtab;
          return;
        }
d3287 7
a3293 30
  {
    struct ada_symbol_info info;

    info.sym = sym;
    info.block = block;
    info.symtab = symtab;
    obstack_grow (obstackp, &info, sizeof (struct ada_symbol_info));
  }
}

/* Number of ada_symbol_info structures currently collected in 
   current vector in *OBSTACKP.  */

static int
num_defns_collected (struct obstack *obstackp)
{
  return obstack_object_size (obstackp) / sizeof (struct ada_symbol_info);
}

/* Vector of ada_symbol_info structures currently collected in current 
   vector in *OBSTACKP.  If FINISH, close off the vector and return
   its final address.  */

static struct ada_symbol_info *
defns_collected (struct obstack *obstackp, int finish)
{
  if (finish)
    return obstack_finish (obstackp);
  else
    return (struct ada_symbol_info *) obstack_base (obstackp);
d3296 3
a3298 3
/* Look, in partial_symtab PST, for symbol NAME in given namespace.
   Check the global symbols if GLOBAL, the static symbols if not.
   Do wild-card match if WILD.  */
d3302 1
a3302 1
                           int global, domain_enum namespace, int wild)
d3315 2
a3316 2
           pst->objfile->global_psymbols.list + pst->globals_offset :
           pst->objfile->static_psymbols.list + pst->statics_offset);
d3321 2
a3322 2
        {
          struct partial_symbol *psym = start[i];
d3324 4
a3327 4
          if (SYMBOL_DOMAIN (psym) == namespace
              && wild_match (name, name_len, SYMBOL_LINKAGE_NAME (psym)))
            return psym;
        }
d3333 18
a3350 18
        {
          int U;
          i = 0;
          U = length - 1;
          while (U - i > 4)
            {
              int M = (U + i) >> 1;
              struct partial_symbol *psym = start[M];
              if (SYMBOL_LINKAGE_NAME (psym)[0] < name[0])
                i = M + 1;
              else if (SYMBOL_LINKAGE_NAME (psym)[0] > name[0])
                U = M - 1;
              else if (strcmp (SYMBOL_LINKAGE_NAME (psym), name) < 0)
                i = M + 1;
              else
                U = M;
            }
        }
d3352 1
a3352 1
        i = 0;
d3355 2
a3356 2
        {
          struct partial_symbol *psym = start[i];
d3358 15
a3372 16
          if (SYMBOL_DOMAIN (psym) == namespace)
            {
              int cmp = strncmp (name, SYMBOL_LINKAGE_NAME (psym), name_len);

              if (cmp < 0)
                {
                  if (global)
                    break;
                }
              else if (cmp == 0
                       && is_name_suffix (SYMBOL_LINKAGE_NAME (psym)
                                          + name_len))
                return psym;
            }
          i += 1;
        }
d3375 18
a3392 18
        {
          int U;
          i = 0;
          U = length - 1;
          while (U - i > 4)
            {
              int M = (U + i) >> 1;
              struct partial_symbol *psym = start[M];
              if (SYMBOL_LINKAGE_NAME (psym)[0] < '_')
                i = M + 1;
              else if (SYMBOL_LINKAGE_NAME (psym)[0] > '_')
                U = M - 1;
              else if (strcmp (SYMBOL_LINKAGE_NAME (psym), "_ada_") < 0)
                i = M + 1;
              else
                U = M;
            }
        }
d3394 1
a3394 1
        i = 0;
d3397 26
a3422 2
        {
          struct partial_symbol *psym = start[i];
a3423 25
          if (SYMBOL_DOMAIN (psym) == namespace)
            {
              int cmp;

              cmp = (int) '_' - (int) SYMBOL_LINKAGE_NAME (psym)[0];
              if (cmp == 0)
                {
                  cmp = strncmp ("_ada_", SYMBOL_LINKAGE_NAME (psym), 5);
                  if (cmp == 0)
                    cmp = strncmp (name, SYMBOL_LINKAGE_NAME (psym) + 5,
                                   name_len);
                }

              if (cmp < 0)
                {
                  if (global)
                    break;
                }
              else if (cmp == 0
                       && is_name_suffix (SYMBOL_LINKAGE_NAME (psym)
                                          + name_len + 5))
                return psym;
            }
          i += 1;
        }
d3428 1
a3429 1

d3451 7
a3457 7
        b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
        ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
          return s;
        b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
        ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
          return s;
        break;
d3459 1
a3459 1
        break;
d3475 8
a3482 8
        for (j = FIRST_LOCAL_BLOCK;
             j < BLOCKVECTOR_NBLOCKS (BLOCKVECTOR (s)); j += 1)
          {
            b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), j);
            ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
              return s;
          }
        break;
d3484 1
a3484 1
        break;
d3490 2
a3491 4
/* Return a minimal symbol matching NAME according to Ada decoding
   rules.  Returns NULL if there is no such minimal symbol.  Names 
   prefixed with "standard__" are handled specially: "standard__" is 
   first stripped off, and only static and global symbols are searched.  */
d3494 1
a3494 1
ada_lookup_simple_minsym (const char *name)
d3498 1
a3498 9
  int wild_match;

  if (strncmp (name, "standard__", sizeof ("standard__") - 1) == 0)
    {
      name += sizeof ("standard__") - 1;
      wild_match = 0;
    }
  else
    wild_match = (strstr (name, "__") == NULL);
d3502 2
a3503 2
    if (ada_match_name (SYMBOL_LINKAGE_NAME (msymbol), name, wild_match)
        && MSYMBOL_TYPE (msymbol) != mst_solib_trampoline)
d3511 8
a3518 5
   selected frame, add symbols matching identifier NAME in DOMAIN
   and their blocks to the list of data in OBSTACKP, as for
   ada_add_block_symbols (q.v.).   If WILD, treat as NAME with a
   wildcard prefix.  */

d3520 2
a3521 3
add_symbols_from_enclosing_procs (struct obstack *obstackp,
                                  const char *name, domain_enum namespace,
                                  int wild_match)
d3523 40
a3562 1
}
d3564 2
a3565 1
/* FIXME: The next two routines belong in symtab.c */
d3567 4
a3570 5
static void
restore_language (void *lang)
{
  set_language ((enum language) lang);
}
d3572 3
a3574 2
/* As for lookup_symbol, but performed as if the current language 
   were LANG. */
a3575 10
struct symbol *
lookup_symbol_in_language (const char *name, const struct block *block,
                           domain_enum domain, enum language lang,
                           int *is_a_field_of_this, struct symtab **symtab)
{
  struct cleanup *old_chain
    = make_cleanup (restore_language, (void *) current_language->la_language);
  struct symbol *result;
  set_language (lang);
  result = lookup_symbol (name, block, domain, is_a_field_of_this, symtab);
d3577 1
a3577 1
  return result;
d3581 1
a3581 2
   for which no debugging information was given in the symbol file.  */

d3586 1
a3586 1
  return (name != NULL && strcmp (name, "<variable, no debug info>") == 0);
d3589 8
a3596 7
/* Remove any non-debugging symbols in SYMS[0 .. NSYMS-1] that definitely
   duplicate other symbols in the list (The only case I know of where
   this happens is when object files containing stabs-in-ecoff are
   linked with files containing ordinary ecoff debugging symbols (or no
   debugging symbols)).  Modifies SYMS to squeeze out deleted entries.
   Returns the number of items in the modified list.  */

d3598 1
a3598 1
remove_extra_symbols (struct ada_symbol_info *syms, int nsyms)
d3605 24
a3628 22
      if (SYMBOL_LINKAGE_NAME (syms[i].sym) != NULL
          && SYMBOL_CLASS (syms[i].sym) == LOC_STATIC
          && is_nondebugging_type (SYMBOL_TYPE (syms[i].sym)))
        {
          for (j = 0; j < nsyms; j += 1)
            {
              if (i != j
                  && SYMBOL_LINKAGE_NAME (syms[j].sym) != NULL
                  && strcmp (SYMBOL_LINKAGE_NAME (syms[i].sym),
                             SYMBOL_LINKAGE_NAME (syms[j].sym)) == 0
                  && SYMBOL_CLASS (syms[i].sym) == SYMBOL_CLASS (syms[j].sym)
                  && SYMBOL_VALUE_ADDRESS (syms[i].sym)
                  == SYMBOL_VALUE_ADDRESS (syms[j].sym))
                {
                  int k;
                  for (k = i + 1; k < nsyms; k += 1)
                    syms[k - 1] = syms[k];
                  nsyms -= 1;
                  goto NextSymbol;
                }
            }
        }
d3636 10
a3645 4
/* Given a type that corresponds to a renaming entity, use the type name
   to extract the scope (package name or function name, fully qualified,
   and following the GNAT encoding convention) where this renaming has been
   defined.  The string returned needs to be deallocated after use.  */
d3647 4
a3650 2
static char *
xget_renaming_scope (struct type *renaming_type)
d3652 17
a3668 10
  /* The renaming types adhere to the following convention:
     <scope>__<rename>___<XR extension>. 
     So, to extract the scope, we search for the "___XR" extension,
     and then backtrack until we find the first "__".  */

  const char *name = type_name_no_tag (renaming_type);
  char *suffix = strstr (name, "___XR");
  char *last;
  int scope_len;
  char *scope;
d3670 6
a3675 2
  /* Now, backtrack a bit until we find the first "__".  Start looking
     at suffix - 3, as the <rename> part is at least one character long.  */
d3677 132
a3808 3
  for (last = suffix - 3; last > name; last--)
    if (last[0] == '_' && last[1] == '_')
      break;
d3810 5
a3814 1
  /* Make a copy of scope and return it.  */
d3816 7
a3822 2
  scope_len = last - name;
  scope = (char *) xmalloc ((scope_len + 1) * sizeof (char));
d3824 3
a3826 2
  strncpy (scope, name, scope_len);
  scope[scope_len] = '\0';
d3828 6
a3833 1
  return scope;
a3835 1
/* Return nonzero if NAME corresponds to a package name.  */
d3837 7
d3845 1
a3845 1
is_package_name (const char *name)
d3847 44
a3890 12
  /* Here, We take advantage of the fact that no symbols are generated
     for packages, while symbols are generated for each function.
     So the condition for NAME represent a package becomes equivalent
     to NAME not existing in our list of symbols.  There is only one
     small complication with library-level functions (see below).  */

  char *fun_name;

  /* If it is a function that has not been defined at library level,
     then we should be able to look it up in the symbols.  */
  if (standard_lookup (name, NULL, VAR_DOMAIN) != NULL)
    return 0;
d3892 9
a3900 2
  /* Library-level function names start with "_ada_".  See if function
     "_ada_" followed by NAME can be found.  */
d3902 5
a3906 4
  /* Do a quick check that NAME does not contain "__", since library-level
     functions names can not contain "__" in them.  */
  if (strstr (name, "__") != NULL)
    return 0;
d3908 28
a3935 1
  fun_name = xstrprintf ("_ada_%s", name);
d3937 1
a3937 1
  return (standard_lookup (fun_name, NULL, VAR_DOMAIN) == NULL);
a3939 2
/* Return nonzero if SYM corresponds to a renaming entity that is
   visible from FUNCTION_NAME.  */
d3941 10
a3950 2
static int
renaming_is_visible (const struct symbol *sym, char *function_name)
d3952 75
a4026 1
  char *scope = xget_renaming_scope (SYMBOL_TYPE (sym));
d4028 5
a4032 1
  make_cleanup (xfree, scope);
d4034 56
a4089 3
  /* If the rename has been defined in a package, then it is visible.  */
  if (is_package_name (scope))
    return 1;
d4091 1
a4091 2
  /* Check that the rename is in the current function scope by checking
     that its name starts with SCOPE.  */
d4093 2
a4094 39
  /* If the function name starts with "_ada_", it means that it is
     a library-level function.  Strip this prefix before doing the
     comparison, as the encoding for the renaming does not contain
     this prefix.  */
  if (strncmp (function_name, "_ada_", 5) == 0)
    function_name += 5;

  return (strncmp (function_name, scope, strlen (scope)) == 0);
}

/* Iterates over the SYMS list and remove any entry that corresponds to
   a renaming entity that is not visible from the function associated
   with CURRENT_BLOCK. 
   
   Rationale:
   GNAT emits a type following a specified encoding for each renaming
   entity.  Unfortunately, STABS currently does not support the definition
   of types that are local to a given lexical block, so all renamings types
   are emitted at library level.  As a consequence, if an application
   contains two renaming entities using the same name, and a user tries to
   print the value of one of these entities, the result of the ada symbol
   lookup will also contain the wrong renaming type.

   This function partially covers for this limitation by attempting to
   remove from the SYMS list renaming symbols that should be visible
   from CURRENT_BLOCK.  However, there does not seem be a 100% reliable
   method with the current information available.  The implementation
   below has a couple of limitations (FIXME: brobecker-2003-05-12):  
   
      - When the user tries to print a rename in a function while there
        is another rename entity defined in a package:  Normally, the
        rename in the function has precedence over the rename in the
        package, so the latter should be removed from the list.  This is
        currently not the case.
        
      - This function will incorrectly remove valid renames if
        the CURRENT_BLOCK corresponds to a function which symbol name
        has been changed by an "Export" pragma.  As a consequence,
        the user will be unable to print such rename entities.  */
d4096 2
a4097 3
static int
remove_out_of_scope_renamings (struct ada_symbol_info *syms,
                               int nsyms, struct block *current_block)
d4099 43
a4141 3
  struct symbol *current_function;
  char *current_function_name;
  int i;
d4143 1
a4143 2
  /* Extract the function name associated to CURRENT_BLOCK.
     Abort if unable to do so.  */
d4145 11
a4155 2
  if (current_block == NULL)
    return nsyms;
d4157 1
a4157 3
  current_function = block_function (current_block);
  if (current_function == NULL)
    return nsyms;
d4159 4
a4162 3
  current_function_name = SYMBOL_LINKAGE_NAME (current_function);
  if (current_function_name == NULL)
    return nsyms;
d4164 3
a4166 3
  /* Check each of the symbols, and remove it from the list if it is
     a type corresponding to a renaming that is out of the scope of
     the current block.  */
d4168 8
a4175 2
  i = 0;
  while (i < nsyms)
d4177 6
a4182 10
      if (ada_is_object_renaming (syms[i].sym)
          && !renaming_is_visible (syms[i].sym, current_function_name))
        {
          int j;
          for (j = i + 1; j < nsyms; j++)
            syms[j - 1] = syms[j];
          nsyms -= 1;
        }
      else
        i += 1;
d4184 2
d4187 1
a4187 2
  return nsyms;
}
d4189 2
a4190 13
/* Find symbols in DOMAIN matching NAME0, in BLOCK0 and enclosing
   scope and in global scopes, returning the number of matches.  Sets
   *RESULTS to point to a vector of (SYM,BLOCK,SYMTAB) triples,
   indicating the symbols found and the blocks and symbol tables (if
   any) in which they were found.  This vector are transient---good only to 
   the next call of ada_lookup_symbol_list.  Any non-function/non-enumeral 
   symbol match within the nest of blocks whose innermost member is BLOCK0,
   is the one match returned (no other matches in that or
     enclosing blocks is returned).  If there are any matches in or
   surrounding BLOCK0, then these alone are returned.  Otherwise, the
   search extends to global and file-scope (static) symbol tables.
   Names prefixed with "standard__" are handled specially: "standard__" 
   is first stripped off, and only static and global symbols are searched.  */
d4192 61
a4252 4
int
ada_lookup_symbol_list (const char *name0, const struct block *block0,
                        domain_enum namespace,
                        struct ada_symbol_info **results)
d4254 2
a4255 5
  struct symbol *sym;
  struct symtab *s;
  struct partial_symtab *ps;
  struct blockvector *bv;
  struct objfile *objfile;
d4257 27
a4283 6
  const char *name;
  struct minimal_symbol *msymbol;
  int wild_match;
  int cacheIfUnique;
  int block_depth;
  int ndefns;
d4285 7
a4291 2
  obstack_free (&symbol_list_obstack, NULL);
  obstack_init (&symbol_list_obstack);
d4293 4
a4296 1
  cacheIfUnique = 0;
d4298 2
a4299 1
  /* Search specified block and its superiors.  */
d4301 4
a4304 10
  wild_match = (strstr (name0, "__") == NULL);
  name = name0;
  block = (struct block *) block0;      /* FIXME: No cast ought to be
                                           needed, but adding const will
                                           have a cascade effect.  */
  if (strncmp (name0, "standard__", sizeof ("standard__") - 1) == 0)
    {
      wild_match = 0;
      block = NULL;
      name = name0 + sizeof ("standard__") - 1;
d4307 8
a4314 2
  block_depth = 0;
  while (block != NULL)
d4316 31
a4346 8
      block_depth += 1;
      ada_add_block_symbols (&symbol_list_obstack, block, name,
                             namespace, NULL, NULL, wild_match);

      /* If we found a non-function match, assume that's the one.  */
      if (is_nonfunction (defns_collected (&symbol_list_obstack, 0),
                          num_defns_collected (&symbol_list_obstack)))
        goto done;
d4348 27
a4374 1
      block = BLOCK_SUPERBLOCK (block);
d4377 11
a4387 5
  /* If no luck so far, try to find NAME as a local symbol in some lexically
     enclosing subprogram.  */
  if (num_defns_collected (&symbol_list_obstack) == 0 && block_depth > 2)
    add_symbols_from_enclosing_procs (&symbol_list_obstack,
                                      name, namespace, wild_match);
d4389 4
a4392 1
  /* If we found ANY matches among non-global symbols, we're done.  */
d4394 22
a4415 2
  if (num_defns_collected (&symbol_list_obstack) > 0)
    goto done;
d4417 1
a4417 2
  cacheIfUnique = 1;
  if (lookup_cached_symbol (name0, namespace, &sym, &block, &s))
d4419 5
a4423 3
      if (sym != NULL)
        add_defn_to_vec (&symbol_list_obstack, sym, block, s);
      goto done;
d4426 19
a4444 2
  /* Now add symbols from all global blocks: symbol tables, minimal symbol
     tables, and psymtab's.  */
d4446 4
d4452 3
d4456 66
a4521 1
    if (!s->primary)
d4523 190
a4712 4
    bv = BLOCKVECTOR (s);
    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
    ada_add_block_symbols (&symbol_list_obstack, block, name, namespace,
                           objfile, s, wild_match);
d4714 7
d4722 3
a4724 1
  if (namespace == VAR_DOMAIN)
d4726 2
a4727 32
      ALL_MSYMBOLS (objfile, msymbol)
      {
        if (ada_match_name (SYMBOL_LINKAGE_NAME (msymbol), name, wild_match))
          {
            switch (MSYMBOL_TYPE (msymbol))
              {
              case mst_solib_trampoline:
                break;
              default:
                s = find_pc_symtab (SYMBOL_VALUE_ADDRESS (msymbol));
                if (s != NULL)
                  {
                    int ndefns0 = num_defns_collected (&symbol_list_obstack);
                    QUIT;
                    bv = BLOCKVECTOR (s);
                    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
                    ada_add_block_symbols (&symbol_list_obstack, block,
                                           SYMBOL_LINKAGE_NAME (msymbol),
                                           namespace, objfile, s, wild_match);

                    if (num_defns_collected (&symbol_list_obstack) == ndefns0)
                      {
                        block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
                        ada_add_block_symbols (&symbol_list_obstack, block,
                                               SYMBOL_LINKAGE_NAME (msymbol),
                                               namespace, objfile, s,
                                               wild_match);
                      }
                  }
              }
          }
      }
d4729 21
d4754 3
a4756 11
    if (!ps->readin
        && ada_lookup_partial_symbol (ps, name, 1, namespace, wild_match))
      {
        s = PSYMTAB_TO_SYMTAB (ps);
        if (!s->primary)
          continue;
        bv = BLOCKVECTOR (s);
        block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
        ada_add_block_symbols (&symbol_list_obstack, block, name,
                               namespace, objfile, s, wild_match);
      }
d4758 1
d4760 25
a4784 3
  /* Now add symbols from all per-file blocks if we've gotten no hits
     (Not strictly correct, but perhaps better than an error).
     Do the symtabs first, then check the psymtabs.  */
d4786 2
a4787 2
  if (num_defns_collected (&symbol_list_obstack) == 0)
    {
d4789 4
a4792 10
      ALL_SYMTABS (objfile, s)
      {
        QUIT;
        if (!s->primary)
          continue;
        bv = BLOCKVECTOR (s);
        block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
        ada_add_block_symbols (&symbol_list_obstack, block, name, namespace,
                               objfile, s, wild_match);
      }
d4794 2
a4795 1
      ALL_PSYMTABS (objfile, ps)
d4797 13
a4809 12
        QUIT;
        if (!ps->readin
            && ada_lookup_partial_symbol (ps, name, 0, namespace, wild_match))
          {
            s = PSYMTAB_TO_SYMTAB (ps);
            bv = BLOCKVECTOR (s);
            if (!s->primary)
              continue;
            block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
            ada_add_block_symbols (&symbol_list_obstack, block, name,
                                   namespace, objfile, s, wild_match);
          }
d4811 1
a4811 1
    }
d4813 7
a4819 3
done:
  ndefns = num_defns_collected (&symbol_list_obstack);
  *results = defns_collected (&symbol_list_obstack, 1);
d4821 7
a4827 1
  ndefns = remove_extra_symbols (*results, ndefns);
d4829 19
a4847 2
  if (ndefns == 0)
    cache_symbol (name0, namespace, NULL, NULL, NULL);
d4849 14
a4862 3
  if (ndefns == 1 && cacheIfUnique)
    cache_symbol (name0, namespace, (*results)[0].sym, (*results)[0].block,
                  (*results)[0].symtab);
d4864 3
a4866 2
  ndefns = remove_out_of_scope_renamings (*results, ndefns,
                                          (struct block *) block0);
a4867 2
  return ndefns;
}
d4869 4
a4872 7
/* Return a symbol in DOMAIN matching NAME, in BLOCK0 and enclosing
   scope and in global scopes, or NULL if none.  NAME is folded and
   encoded first.  Otherwise, the result is as for ada_lookup_symbol_list,
   choosing the first symbol if there are multiple choices.  
   *IS_A_FIELD_OF_THIS is set to 0 and *SYMTAB is set to the symbol
   table in which the symbol was found (in both cases, these
   assignments occur only if the pointers are non-null).  */
d4874 2
a4875 4
struct symbol *
ada_lookup_symbol (const char *name, const struct block *block0,
                   domain_enum namespace, int *is_a_field_of_this,
                   struct symtab **symtab)
d4877 1
a4877 5
  struct ada_symbol_info *candidates;
  int n_candidates;

  n_candidates = ada_lookup_symbol_list (ada_encode (ada_fold_name (name)),
                                         block0, namespace, &candidates);
d4879 1
a4879 1
  if (n_candidates == 0)
d4882 5
a4886 2
  if (is_a_field_of_this != NULL)
    *is_a_field_of_this = 0;
d4888 4
a4891 28
  if (symtab != NULL)
    {
      *symtab = candidates[0].symtab;
      if (*symtab == NULL && candidates[0].block != NULL)
        {
          struct objfile *objfile;
          struct symtab *s;
          struct block *b;
          struct blockvector *bv;

          /* Search the list of symtabs for one which contains the
             address of the start of this block.  */
          ALL_SYMTABS (objfile, s)
          {
            bv = BLOCKVECTOR (s);
            b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
            if (BLOCK_START (b) <= BLOCK_START (candidates[0].block)
                && BLOCK_END (b) > BLOCK_START (candidates[0].block))
              {
                *symtab = s;
                return fixup_symbol_section (candidates[0].sym, objfile);
              }
            return fixup_symbol_section (candidates[0].sym, NULL);
          }
        }
    }
  return candidates[0].sym;
}
d4893 4
a4896 10
static struct symbol *
ada_lookup_symbol_nonlocal (const char *name,
                            const char *linkage_name,
                            const struct block *block,
                            const domain_enum domain, struct symtab **symtab)
{
  if (linkage_name == NULL)
    linkage_name = name;
  return ada_lookup_symbol (linkage_name, block_static_block (block), domain,
                            NULL, symtab);
d4899 2
a4900 14

/* True iff STR is a possible encoded suffix of a normal Ada name
   that is to be ignored for matching purposes.  Suffixes of parallel
   names (e.g., XVE) are not included here.  Currently, the possible suffixes
   are given by either of the regular expression:

   (__[0-9]+)?\.[0-9]+  [nested subprogram suffix, on platforms such 
                         as GNU/Linux]
   ___[0-9]+            [nested subprogram suffix, on platforms such as HP/UX]
   (X[nb]*)?((\$|__)[0-9](_?[0-9]+)|___(JM|LJM|X([FDBUP].*|R[^T]?)))?$
 */

static int
is_name_suffix (const char *str)
d4902 15
a4916 3
  int k;
  const char *matching;
  const int len = strlen (str);
d4918 2
a4919 10
  /* (__[0-9]+)?\.[0-9]+ */
  matching = str;
  if (len > 3 && str[0] == '_' && str[1] == '_' && isdigit (str[2]))
    {
      matching += 3;
      while (isdigit (matching[0]))
        matching += 1;
      if (matching[0] == '\0')
        return 1;
    }
d4921 1
a4921 1
  if (matching[0] == '.')
d4923 3
a4925 6
      matching += 1;
      while (isdigit (matching[0]))
        matching += 1;
      if (matching[0] == '\0')
        return 1;
    }
d4927 2
a4928 9
  /* ___[0-9]+ */
  if (len > 3 && str[0] == '_' && str[1] == '_' && str[2] == '_')
    {
      matching = str + 3;
      while (isdigit (matching[0]))
        matching += 1;
      if (matching[0] == '\0')
        return 1;
    }
d4930 3
a4932 14
  /* ??? We should not modify STR directly, as we are doing below.  This
     is fine in this case, but may become problematic later if we find
     that this alternative did not work, and want to try matching
     another one from the begining of STR.  Since we modified it, we
     won't be able to find the begining of the string anymore!  */
  if (str[0] == 'X')
    {
      str += 1;
      while (str[0] != '_' && str[0] != '\0')
        {
          if (str[0] != 'n' && str[0] != 'b')
            return 0;
          str += 1;
        }
d4934 1
a4934 3
  if (str[0] == '\000')
    return 1;
  if (str[0] == '_')
d4936 20
a4955 28
      if (str[1] != '_' || str[2] == '\000')
        return 0;
      if (str[2] == '_')
        {
          if (strcmp (str + 3, "JM") == 0)
            return 1;
          /* FIXME: brobecker/2004-09-30: GNAT will soon stop using
             the LJM suffix in favor of the JM one.  But we will
             still accept LJM as a valid suffix for a reasonable
             amount of time, just to allow ourselves to debug programs
             compiled using an older version of GNAT.  */
          if (strcmp (str + 3, "LJM") == 0)
            return 1;
          if (str[3] != 'X')
            return 0;
          if (str[4] == 'F' || str[4] == 'D' || str[4] == 'B'
              || str[4] == 'U' || str[4] == 'P')
            return 1;
          if (str[4] == 'R' && str[5] != 'T')
            return 1;
          return 0;
        }
      if (!isdigit (str[2]))
        return 0;
      for (k = 3; str[k] != '\0'; k += 1)
        if (!isdigit (str[k]) && str[k] != '_')
          return 0;
      return 1;
d4957 2
a4958 8
  if (str[0] == '$' && isdigit (str[1]))
    {
      for (k = 2; str[k] != '\0'; k += 1)
        if (!isdigit (str[k]) && str[k] != '_')
          return 0;
      return 1;
    }
  return 0;
d4961 2
a4962 13
/* Return nonzero if the given string starts with a dot ('.')
   followed by zero or more digits.  
   
   Note: brobecker/2003-11-10: A forward declaration has not been
   added at the begining of this file yet, because this function
   is only used to work around a problem found during wild matching
   when trying to match minimal symbol names against symbol names
   obtained from dwarf-2 data.  This function is therefore currently
   only used in wild_match() and is likely to be deleted when the
   problem in dwarf-2 is fixed.  */

static int
is_dot_digits_suffix (const char *str)
d4964 3
a4966 7
  if (str[0] != '.')
    return 0;

  str++;
  while (isdigit (str[0]))
    str++;
  return (str[0] == '\0');
d4969 2
a4970 4
/* True if NAME represents a name of the form A1.A2....An, n>=1 and
   PATN[0..PATN_LEN-1] = Ak.Ak+1.....An for some k >= 1.  Ignores
   informational suffixes of NAME (i.e., for which is_name_suffix is
   true).  */
d4972 2
a4973 2
static int
wild_match (const char *patn0, int patn_len, const char *name0)
d4975 1
a4975 52
  int name_len;
  char *name;
  char *patn;

  /* FIXME: brobecker/2003-11-10: For some reason, the symbol name
     stored in the symbol table for nested function names is sometimes
     different from the name of the associated entity stored in
     the dwarf-2 data: This is the case for nested subprograms, where
     the minimal symbol name contains a trailing ".[:digit:]+" suffix,
     while the symbol name from the dwarf-2 data does not.

     Although the DWARF-2 standard documents that entity names stored
     in the dwarf-2 data should be identical to the name as seen in
     the source code, GNAT takes a different approach as we already use
     a special encoding mechanism to convey the information so that
     a C debugger can still use the information generated to debug
     Ada programs.  A corollary is that the symbol names in the dwarf-2
     data should match the names found in the symbol table.  I therefore
     consider this issue as a compiler defect.

     Until the compiler is properly fixed, we work-around the problem
     by ignoring such suffixes during the match.  We do so by making
     a copy of PATN0 and NAME0, and then by stripping such a suffix
     if present.  We then perform the match on the resulting strings.  */
  {
    char *dot;
    name_len = strlen (name0);

    name = (char *) alloca ((name_len + 1) * sizeof (char));
    strcpy (name, name0);
    dot = strrchr (name, '.');
    if (dot != NULL && is_dot_digits_suffix (dot))
      *dot = '\0';

    patn = (char *) alloca ((patn_len + 1) * sizeof (char));
    strncpy (patn, patn0, patn_len);
    patn[patn_len] = '\0';
    dot = strrchr (patn, '.');
    if (dot != NULL && is_dot_digits_suffix (dot))
      {
        *dot = '\0';
        patn_len = dot - patn;
      }
  }

  /* Now perform the wild match.  */

  name_len = strlen (name);
  if (name_len >= patn_len + 5 && strncmp (name, "_ada_", 5) == 0
      && strncmp (patn, name + 5, patn_len) == 0
      && is_name_suffix (name + patn_len + 5))
    return 1;
d4977 1
a4977 1
  while (name_len >= patn_len)
d4979 14
a4992 26
      if (strncmp (patn, name, patn_len) == 0
          && is_name_suffix (name + patn_len))
        return 1;
      do
        {
          name += 1;
          name_len -= 1;
        }
      while (name_len > 0
             && name[0] != '.' && (name[0] != '_' || name[1] != '_'));
      if (name_len <= 0)
        return 0;
      if (name[0] == '_')
        {
          if (!islower (name[2]))
            return 0;
          name += 2;
          name_len -= 2;
        }
      else
        {
          if (!islower (name[1]))
            return 0;
          name += 1;
          name_len -= 1;
        }
d4995 1
a4995 1
  return 0;
d4998 41
d5040 2
a5041 11
/* Add symbols from BLOCK matching identifier NAME in DOMAIN to
   vector *defn_symbols, updating the list of symbols in OBSTACKP 
   (if necessary).  If WILD, treat as NAME with a wildcard prefix. 
   OBJFILE is the section containing BLOCK.
   SYMTAB is recorded with each symbol added.  */

static void
ada_add_block_symbols (struct obstack *obstackp,
                       struct block *block, const char *name,
                       domain_enum domain, struct objfile *objfile,
                       struct symtab *symtab, int wild)
d5043 1
a5043 7
  struct dict_iterator iter;
  int name_len = strlen (name);
  /* A matching argument symbol, if any.  */
  struct symbol *arg_sym;
  /* Set true when we find a matching non-argument symbol.  */
  int found_sym;
  struct symbol *sym;
d5045 5
a5049 67
  arg_sym = NULL;
  found_sym = 0;
  if (wild)
    {
      struct symbol *sym;
      ALL_BLOCK_SYMBOLS (block, iter, sym)
      {
        if (SYMBOL_DOMAIN (sym) == domain
            && wild_match (name, name_len, SYMBOL_LINKAGE_NAME (sym)))
          {
            switch (SYMBOL_CLASS (sym))
              {
              case LOC_ARG:
              case LOC_LOCAL_ARG:
              case LOC_REF_ARG:
              case LOC_REGPARM:
              case LOC_REGPARM_ADDR:
              case LOC_BASEREG_ARG:
              case LOC_COMPUTED_ARG:
                arg_sym = sym;
                break;
              case LOC_UNRESOLVED:
                continue;
              default:
                found_sym = 1;
                add_defn_to_vec (obstackp,
                                 fixup_symbol_section (sym, objfile),
                                 block, symtab);
                break;
              }
          }
      }
    }
  else
    {
      ALL_BLOCK_SYMBOLS (block, iter, sym)
      {
        if (SYMBOL_DOMAIN (sym) == domain)
          {
            int cmp = strncmp (name, SYMBOL_LINKAGE_NAME (sym), name_len);
            if (cmp == 0
                && is_name_suffix (SYMBOL_LINKAGE_NAME (sym) + name_len))
              {
                switch (SYMBOL_CLASS (sym))
                  {
                  case LOC_ARG:
                  case LOC_LOCAL_ARG:
                  case LOC_REF_ARG:
                  case LOC_REGPARM:
                  case LOC_REGPARM_ADDR:
                  case LOC_BASEREG_ARG:
                  case LOC_COMPUTED_ARG:
                    arg_sym = sym;
                    break;
                  case LOC_UNRESOLVED:
                    break;
                  default:
                    found_sym = 1;
                    add_defn_to_vec (obstackp,
                                     fixup_symbol_section (sym, objfile),
                                     block, symtab);
                    break;
                  }
              }
          }
      }
    }
d5051 7
a5057 6
  if (!found_sym && arg_sym != NULL)
    {
      add_defn_to_vec (obstackp,
                       fixup_symbol_section (arg_sym, objfile),
                       block, symtab);
    }
d5059 65
a5123 56
  if (!wild)
    {
      arg_sym = NULL;
      found_sym = 0;

      ALL_BLOCK_SYMBOLS (block, iter, sym)
      {
        if (SYMBOL_DOMAIN (sym) == domain)
          {
            int cmp;

            cmp = (int) '_' - (int) SYMBOL_LINKAGE_NAME (sym)[0];
            if (cmp == 0)
              {
                cmp = strncmp ("_ada_", SYMBOL_LINKAGE_NAME (sym), 5);
                if (cmp == 0)
                  cmp = strncmp (name, SYMBOL_LINKAGE_NAME (sym) + 5,
                                 name_len);
              }

            if (cmp == 0
                && is_name_suffix (SYMBOL_LINKAGE_NAME (sym) + name_len + 5))
              {
                switch (SYMBOL_CLASS (sym))
                  {
                  case LOC_ARG:
                  case LOC_LOCAL_ARG:
                  case LOC_REF_ARG:
                  case LOC_REGPARM:
                  case LOC_REGPARM_ADDR:
                  case LOC_BASEREG_ARG:
                  case LOC_COMPUTED_ARG:
                    arg_sym = sym;
                    break;
                  case LOC_UNRESOLVED:
                    break;
                  default:
                    found_sym = 1;
                    add_defn_to_vec (obstackp,
                                     fixup_symbol_section (sym, objfile),
                                     block, symtab);
                    break;
                  }
              }
          }
      }

      /* NOTE: This really shouldn't be needed for _ada_ symbols.
         They aren't parameters, right?  */
      if (!found_sym && arg_sym != NULL)
        {
          add_defn_to_vec (obstackp,
                           fixup_symbol_section (arg_sym, objfile),
                           block, symtab);
        }
    }
d5126 2
a5127 1
                                /* Field Access */
d5130 1
a5130 1
   to be invisible to users.  */
d5141 1
a5141 1
              || (name[0] == '_' && strncmp (name, "_parent", 7) != 0));
d5145 1
a5145 2
/* True iff TYPE has a tag field.  If REFOK, then TYPE may also be a
   pointer or reference type whose ultimate target has a tag field. */
d5148 1
a5148 1
ada_is_tagged_type (struct type *type, int refok)
d5150 2
a5151 2
  return (ada_lookup_struct_elt_type (type, "_tag", refok, 1, NULL) != NULL);
}
d5153 1
a5153 13
/* True iff TYPE represents the type of X'Tag */

int
ada_is_tag_type (struct type *type)
{
  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_PTR)
    return 0;
  else
    {
      const char *name = ada_type_name (TYPE_TARGET_TYPE (type));
      return (name != NULL
              && strcmp (name, "ada__tags__dispatch_table") == 0);
    }
d5156 1
a5156 1
/* The type of the tag on VAL.  */
d5161 1
a5161 1
  return ada_lookup_struct_elt_type (VALUE_TYPE (val), "_tag", 1, 0, NULL);
d5164 1
a5164 1
/* The value of the tag on VAL.  */
d5172 1
a5172 79
/* The value of the tag on the object of type TYPE whose contents are
   saved at VALADDR, if it is non-null, or is at memory address
   ADDRESS. */

static struct value *
value_tag_from_contents_and_address (struct type *type, char *valaddr,
                                     CORE_ADDR address)
{
  int tag_byte_offset, dummy1, dummy2;
  struct type *tag_type;
  if (find_struct_field ("_tag", type, 0, &tag_type, &tag_byte_offset,
                         &dummy1, &dummy2))
    {
      char *valaddr1 = (valaddr == NULL) ? NULL : valaddr + tag_byte_offset;
      CORE_ADDR address1 = (address == 0) ? 0 : address + tag_byte_offset;

      return value_from_contents_and_address (tag_type, valaddr1, address1);
    }
  return NULL;
}

static struct type *
type_from_tag (struct value *tag)
{
  const char *type_name = ada_tag_name (tag);
  if (type_name != NULL)
    return ada_find_any_type (ada_encode (type_name));
  return NULL;
}

struct tag_args
{
  struct value *tag;
  char *name;
};

/* Wrapper function used by ada_tag_name.  Given a struct tag_args*
   value ARGS, sets ARGS->name to the tag name of ARGS->tag.  
   The value stored in ARGS->name is valid until the next call to 
   ada_tag_name_1.  */

static int
ada_tag_name_1 (void *args0)
{
  struct tag_args *args = (struct tag_args *) args0;
  static char name[1024];
  char *p;
  struct value *val;
  args->name = NULL;
  val = ada_value_struct_elt (args->tag, "tsd", NULL);
  if (val == NULL)
    return 0;
  val = ada_value_struct_elt (val, "expanded_name", NULL);
  if (val == NULL)
    return 0;
  read_memory_string (value_as_address (val), name, sizeof (name) - 1);
  for (p = name; *p != '\0'; p += 1)
    if (isalpha (*p))
      *p = tolower (*p);
  args->name = name;
  return 0;
}

/* The type name of the dynamic type denoted by the 'tag value TAG, as
 * a C string.  */

const char *
ada_tag_name (struct value *tag)
{
  struct tag_args args;
  if (!ada_is_tag_type (VALUE_TYPE (tag)))
    return NULL;
  args.tag = tag;
  args.name = NULL;
  catch_errors (ada_tag_name_1, &args, NULL, RETURN_MASK_ALL);
  return args.name;
}

/* The parent type of TYPE, or NULL if none.  */
d5179 1
a5179 1
  type = ada_check_typedef (type);
d5186 1
a5186 1
      return ada_check_typedef (TYPE_FIELD_TYPE (type, i));
d5191 3
a5193 3
/* True iff field number FIELD_NUM of structure type TYPE contains the
   parent-type (inherited) fields of a derived type.  Assumes TYPE is
   a structure type with at least FIELD_NUM+1 fields.  */
d5198 3
a5200 4
  const char *name = TYPE_FIELD_NAME (ada_check_typedef (type), field_num);
  return (name != NULL
          && (strncmp (name, "PARENT", 6) == 0
              || strncmp (name, "_parent", 7) == 0));
d5203 1
a5203 1
/* True iff field number FIELD_NUM of structure type TYPE is a
d5205 1
a5205 1
   field selection and flattened when printing).  Assumes TYPE is a
d5207 1
a5207 1
   structures.  */
d5214 3
a5216 4
          && (strncmp (name, "PARENT", 6) == 0
              || strcmp (name, "REP") == 0
              || strncmp (name, "_parent", 7) == 0
              || name[0] == 'S' || name[0] == 'R' || name[0] == 'O'));
d5219 3
a5221 3
/* True iff field number FIELD_NUM of structure or union type TYPE
   is a variant wrapper.  Assumes TYPE is a structure type with at least
   FIELD_NUM+1 fields.  */
d5228 3
a5230 3
          || (is_dynamic_field (type, field_num)
              && (TYPE_CODE (TYPE_TARGET_TYPE (field_type)) 
		  == TYPE_CODE_UNION)));
d5234 1
a5234 1
   whose discriminants are contained in the record type OUTER_TYPE,
d5241 1
a5241 2
  struct type *type =
    ada_lookup_struct_elt_type (outer_type, name, 1, 1, NULL);
d5248 1
a5248 1
/* Assuming that TYPE is the type of a variant wrapper, and FIELD_NUM is a
d5250 1
a5250 1
   represents a 'when others' clause; otherwise 0.  */
d5260 2
a5261 2
   returns the name of the discriminant controlling the variant.
   The value is valid until the next call to ada_variant_discrim_name.  */
d5286 2
a5287 2
      if (strncmp (discrim_end, "___XVN", 6) == 0)
        break;
d5296 4
a5299 5
        return "";
      if ((discrim_start > name + 3
           && strncmp (discrim_start - 3, "___", 3) == 0)
          || discrim_start[-1] == '.')
        break;
d5308 7
a5314 7
/* Scan STR for a subtype-encoded number, beginning at position K.
   Put the position of the character just past the number scanned in
   *NEW_K, if NEW_K!=NULL.  Put the scanned number in *R, if R!=NULL.
   Return 1 if there was a valid number at the given position, and 0
   otherwise.  A "subtype-encoded" number consists of the absolute value
   in decimal, followed by the letter 'm' to indicate a negative number.
   Assumes 0m does not occur.  */
d5324 1
a5324 1
  /* Do it the hard way so as not to make any assumption about
d5326 1
a5326 1
     LONGEST.  */
d5337 1
a5337 1
        *R = (-(LONGEST) (RU - 1)) - 1;
d5343 1
a5343 1
  /* NOTE on the above: Technically, C does not say what the results of
d5347 1
a5347 1
     above is always equivalent to the negative of RU.  */
d5354 3
a5356 3
/* Assuming that TYPE is a variant part wrapper type (a VARIANTS field),
   and FIELD_NUM is a valid field number within it, returns 1 iff VAL is
   in the range encoded by field FIELD_NUM of TYPE; otherwise 0.  */
d5368 27
a5394 27
        {
        case '\0':
          return 0;
        case 'S':
          {
            LONGEST W;
            if (!ada_scan_number (name, p + 1, &W, &p))
              return 0;
            if (val == W)
              return 1;
            break;
          }
        case 'R':
          {
            LONGEST L, U;
            if (!ada_scan_number (name, p + 1, &L, &p)
                || name[p] != 'T' || !ada_scan_number (name, p + 1, &U, &p))
              return 0;
            if (val >= L && val <= U)
              return 1;
            break;
          }
        case 'O':
          return 1;
        default:
          return 0;
        }
d5398 5
a5402 6
/* FIXME: Lots of redundancy below.  Try to consolidate. */

/* Given a value ARG1 (offset by OFFSET bytes) of a struct or union type
   ARG_TYPE, extract and return the value of one of its (non-static)
   fields.  FIELDNO says which field.   Differs from value_primitive_field
   only in that it can handle packed values of arbitrary type.  */
d5404 1
a5404 1
static struct value *
d5406 1
a5406 1
                           struct type *arg_type)
d5408 1
d5411 1
a5411 1
  arg_type = ada_check_typedef (arg_type);
d5414 1
a5414 1
  /* Handle packed fields.  */
d5422 2
a5423 2
                                             offset + bit_pos / 8,
                                             bit_pos % 8, bit_size, type);
a5428 62
/* Find field with name NAME in object of type TYPE.  If found, return 1
   after setting *FIELD_TYPE_P to the field's type, *BYTE_OFFSET_P to 
   OFFSET + the byte offset of the field within an object of that type, 
   *BIT_OFFSET_P to the bit offset modulo byte size of the field, and
   *BIT_SIZE_P to its size in bits if the field is packed, and 0 otherwise.
   Looks inside wrappers for the field.  Returns 0 if field not
   found. */
static int
find_struct_field (char *name, struct type *type, int offset,
                   struct type **field_type_p,
                   int *byte_offset_p, int *bit_offset_p, int *bit_size_p)
{
  int i;

  type = ada_check_typedef (type);
  *field_type_p = NULL;
  *byte_offset_p = *bit_offset_p = *bit_size_p = 0;

  for (i = TYPE_NFIELDS (type) - 1; i >= 0; i -= 1)
    {
      int bit_pos = TYPE_FIELD_BITPOS (type, i);
      int fld_offset = offset + bit_pos / 8;
      char *t_field_name = TYPE_FIELD_NAME (type, i);

      if (t_field_name == NULL)
        continue;

      else if (field_name_match (t_field_name, name))
        {
          int bit_size = TYPE_FIELD_BITSIZE (type, i);
          *field_type_p = TYPE_FIELD_TYPE (type, i);
          *byte_offset_p = fld_offset;
          *bit_offset_p = bit_pos % 8;
          *bit_size_p = bit_size;
          return 1;
        }
      else if (ada_is_wrapper_field (type, i))
        {
          if (find_struct_field (name, TYPE_FIELD_TYPE (type, i), fld_offset,
                                 field_type_p, byte_offset_p, bit_offset_p,
                                 bit_size_p))
            return 1;
        }
      else if (ada_is_variant_part (type, i))
        {
          int j;
          struct type *field_type = ada_check_typedef (TYPE_FIELD_TYPE (type, i));

          for (j = TYPE_NFIELDS (field_type) - 1; j >= 0; j -= 1)
            {
              if (find_struct_field (name, TYPE_FIELD_TYPE (field_type, j),
                                     fld_offset
                                     + TYPE_FIELD_BITPOS (field_type, j) / 8,
                                     field_type_p, byte_offset_p,
                                     bit_offset_p, bit_size_p))
                return 1;
            }
        }
    }
  return 0;
}

d5430 1
a5430 2

/* Look for a field NAME in ARG.  Adjust the address of ARG by OFFSET bytes,
d5434 1
a5434 1
   Searches recursively through wrapper fields (e.g., '_parent').  */
d5436 1
a5436 1
static struct value *
d5438 1
a5438 1
                         struct type *type)
d5441 1
a5441 1
  type = ada_check_typedef (type);
d5448 1
a5448 1
        continue;
d5451 1
a5451 1
        return ada_value_primitive_field (arg, offset, i, type);
d5454 11
a5464 8
        {
          struct value *v =     /* Do not let indent join lines here. */
            ada_search_struct_field (name, arg,
                                     offset + TYPE_FIELD_BITPOS (type, i) / 8,
                                     TYPE_FIELD_TYPE (type, i));
          if (v != NULL)
            return v;
        }
d5467 18
a5484 15
        {
          int j;
          struct type *field_type = ada_check_typedef (TYPE_FIELD_TYPE (type, i));
          int var_offset = offset + TYPE_FIELD_BITPOS (type, i) / 8;

          for (j = TYPE_NFIELDS (field_type) - 1; j >= 0; j -= 1)
            {
              struct value *v = ada_search_struct_field /* Force line break.  */
                (name, arg,
                 var_offset + TYPE_FIELD_BITPOS (field_type, j) / 8,
                 TYPE_FIELD_TYPE (field_type, j));
              if (v != NULL)
                return v;
            }
        }
d5489 3
a5491 6
/* Given ARG, a value of type (pointer or reference to a)*
   structure/union, extract the component named NAME from the ultimate
   target structure/union and return it as a value with its
   appropriate type.  If ARG is a pointer or reference and the field
   is not packed, returns a reference to the field, otherwise the
   value of the field (an lvalue if ARG is an lvalue).     
d5493 2
a5494 2
   The routine searches for NAME among all members of the structure itself
   and (recursively) among all members of any wrapper members
d5497 2
a5498 5
   ERR is a name (for use in error messages) that identifies the class
   of entity that ARG is supposed to be.  ERR may be null, indicating
   that on error, the function simply returns NULL, and does not
   throw an error.  (FIXME: True only if ARG is a pointer or reference
   at the moment). */
d5503 1
a5503 1
  struct type *t, *t1;
d5506 9
a5514 81
  v = NULL;
  t1 = t = ada_check_typedef (VALUE_TYPE (arg));
  if (TYPE_CODE (t) == TYPE_CODE_REF)
    {
      t1 = TYPE_TARGET_TYPE (t);
      if (t1 == NULL)
        {
          if (err == NULL)
            return NULL;
          else
            error ("Bad value type in a %s.", err);
        }
      t1 = ada_check_typedef (t1);
      if (TYPE_CODE (t1) == TYPE_CODE_PTR)
        {
          COERCE_REF (arg);
          t = t1;
        }
    }

  while (TYPE_CODE (t) == TYPE_CODE_PTR)
    {
      t1 = TYPE_TARGET_TYPE (t);
      if (t1 == NULL)
        {
          if (err == NULL)
            return NULL;
          else
            error ("Bad value type in a %s.", err);
        }
      t1 = ada_check_typedef (t1);
      if (TYPE_CODE (t1) == TYPE_CODE_PTR)
        {
          arg = value_ind (arg);
          t = t1;
        }
      else
        break;
    }

  if (TYPE_CODE (t1) != TYPE_CODE_STRUCT && TYPE_CODE (t1) != TYPE_CODE_UNION)
    {
      if (err == NULL)
        return NULL;
      else
        error ("Attempt to extract a component of a value that is not a %s.",
               err);
    }

  if (t1 == t)
    v = ada_search_struct_field (name, arg, 0, t);
  else
    {
      int bit_offset, bit_size, byte_offset;
      struct type *field_type;
      CORE_ADDR address;

      if (TYPE_CODE (t) == TYPE_CODE_PTR)
        address = value_as_address (arg);
      else
        address = unpack_pointer (t, VALUE_CONTENTS (arg));

      t1 = ada_to_fixed_type (ada_get_base_type (t1), NULL, address, NULL);
      if (find_struct_field (name, t1, 0,
                             &field_type, &byte_offset, &bit_offset,
                             &bit_size))
        {
          if (bit_size != 0)
            {
              if (TYPE_CODE (t) == TYPE_CODE_REF)
                arg = ada_coerce_ref (arg);
              else
                arg = ada_value_ind (arg);
              v = ada_value_primitive_packed_val (arg, NULL, byte_offset,
                                                  bit_offset, bit_size,
                                                  field_type);
            }
          else
            v = value_from_pointer (lookup_reference_type (field_type),
                                    address + byte_offset);
        }
d5517 6
a5522 1
  if (v == NULL && err != NULL)
d5529 2
a5530 2
   If DISPP is non-null, add its byte displacement from the beginning of a
   structure (pointed to by a value) of type TYPE to *DISPP (does not
d5534 1
a5534 1
   followed by "___".
d5536 3
a5538 3
   TYPE can be either a struct or union. If REFOK, TYPE may also 
   be a (pointer or reference)+ to a struct or union, and the
   ultimate target type will be searched.
d5542 1
a5542 2
   If NOERR is nonzero, return NULL if NAME is not suitably defined or
   TYPE is not a type of the right kind.  */
d5544 3
a5546 3
static struct type *
ada_lookup_struct_elt_type (struct type *type, char *name, int refok,
                            int noerr, int *dispp)
d5553 8
a5560 9
  if (refok && type != NULL)
    while (1)
      {
        type = ada_check_typedef (type);
        if (TYPE_CODE (type) != TYPE_CODE_PTR
            && TYPE_CODE (type) != TYPE_CODE_REF)
          break;
        type = TYPE_TARGET_TYPE (type);
      }
d5562 8
a5569 17
  if (type == NULL
      || (TYPE_CODE (type) != TYPE_CODE_STRUCT
          && TYPE_CODE (type) != TYPE_CODE_UNION))
    {
      if (noerr)
        return NULL;
      else
        {
          target_terminal_ours ();
          gdb_flush (gdb_stdout);
          fprintf_unfiltered (gdb_stderr, "Type ");
          if (type == NULL)
            fprintf_unfiltered (gdb_stderr, "(null)");
          else
            type_print (type, "", gdb_stderr, -1);
          error (" is not a structure or union type");
        }
d5581 1
a5581 1
        continue;
d5584 5
a5588 5
        {
          if (dispp != NULL)
            *dispp += TYPE_FIELD_BITPOS (type, i) / 8;
          return ada_check_typedef (TYPE_FIELD_TYPE (type, i));
        }
d5591 11
a5601 11
        {
          disp = 0;
          t = ada_lookup_struct_elt_type (TYPE_FIELD_TYPE (type, i), name,
                                          0, 1, &disp);
          if (t != NULL)
            {
              if (dispp != NULL)
                *dispp += disp + TYPE_FIELD_BITPOS (type, i) / 8;
              return t;
            }
        }
d5604 17
a5620 17
        {
          int j;
          struct type *field_type = ada_check_typedef (TYPE_FIELD_TYPE (type, i));

          for (j = TYPE_NFIELDS (field_type) - 1; j >= 0; j -= 1)
            {
              disp = 0;
              t = ada_lookup_struct_elt_type (TYPE_FIELD_TYPE (field_type, j),
                                              name, 0, 1, &disp);
              if (t != NULL)
                {
                  if (dispp != NULL)
                    *dispp += disp + TYPE_FIELD_BITPOS (type, i) / 8;
                  return t;
                }
            }
        }
d5640 2
a5641 2
   OUTER_VALADDR, determine which variant clause (field number in VAR_TYPE,
   numbering from 0) is applicable.  Returns -1 if none are.  */
d5645 1
a5645 1
                           char *outer_valaddr)
d5656 1
a5656 1
    ada_lookup_struct_elt_type (outer_type, discrim_name, 1, 1, &disp);
d5665 1
a5665 1
        others_clause = i;
d5667 1
a5667 1
        return i;
d5675 1
a5675 1
                                /* Dynamic-Sized Records */
d5681 1
a5681 1
   conventional types that are constructed on the fly.  */
d5690 1
a5690 1
   rather than struct value*s.
d5708 1
a5708 1
   target at the target address.  */
d5712 1
a5712 1
   dynamic-sized types.  */
d5718 2
a5719 1
  return ada_to_fixed_value (val);
d5723 1
a5723 2
   qualifiers on VAL0.  */

d5732 3
a5734 1
      return ada_to_fixed_value (val);
d5741 1
a5741 1
   ALIGNMENT (a power of 2).  */
d5749 16
a5764 1
/* Return the bit alignment required for field #F of template type TYPE.  */
d5773 2
a5774 2
  if (!isdigit (name[len - 1]))
    return 1;
d5781 1
a5781 1
  if (align_offset < 7 || strncmp ("___XV", name + align_offset - 6, 5) != 0)
d5787 3
a5789 4
/* Find a symbol named NAME.  Ignores ambiguity.  */

struct symbol *
ada_find_any_symbol (const char *name)
d5793 1
a5793 1
  sym = standard_lookup (name, get_selected_block (NULL), VAR_DOMAIN);
d5795 1
a5795 12
    return sym;

  sym = standard_lookup (name, NULL, STRUCT_DOMAIN);
  return sym;
}

/* Find a type named NAME.  Ignores ambiguity.  */

struct type *
ada_find_any_type (const char *name)
{
  struct symbol *sym = ada_find_any_symbol (name);
d5797 1
a5803 43
/* Given a symbol NAME and its associated BLOCK, search all symbols
   for its ___XR counterpart, which is the ``renaming'' symbol
   associated to NAME.  Return this symbol if found, return
   NULL otherwise.  */

struct symbol *
ada_find_renaming_symbol (const char *name, struct block *block)
{
  const struct symbol *function_sym = block_function (block);
  char *rename;

  if (function_sym != NULL)
    {
      /* If the symbol is defined inside a function, NAME is not fully
         qualified.  This means we need to prepend the function name
         as well as adding the ``___XR'' suffix to build the name of
         the associated renaming symbol.  */
      char *function_name = SYMBOL_LINKAGE_NAME (function_sym);
      const int function_name_len = strlen (function_name);
      const int rename_len = function_name_len + 2      /*  "__" */
        + strlen (name) + 6 /* "___XR\0" */ ;

      /* Library-level functions are a special case, as GNAT adds
         a ``_ada_'' prefix to the function name to avoid namespace
         pollution.  However, the renaming symbol themselves do not
         have this prefix, so we need to skip this prefix if present.  */
      if (function_name_len > 5 /* "_ada_" */
          && strstr (function_name, "_ada_") == function_name)
        function_name = function_name + 5;

      rename = (char *) alloca (rename_len * sizeof (char));
      sprintf (rename, "%s__%s___XR", function_name, name);
    }
  else
    {
      const int rename_len = strlen (name) + 6;
      rename = (char *) alloca (rename_len * sizeof (char));
      sprintf (rename, "%s___XR", name);
    }

  return ada_find_any_symbol (rename);
}

d5805 1
a5805 1
   given type name.  If the type denoted by TYPE0 is to be preferred to
d5807 1
a5807 2
   otherwise return 0.  */

a5818 2
  else if (TYPE_NAME (type1) == NULL && TYPE_NAME (type0) != NULL)
    return 1;
d5821 2
a5822 2
  else if (ada_is_array_descriptor_type (type0)
           && !ada_is_array_descriptor_type (type1))
d5825 1
a5825 1
           && ada_renaming_type (type1) == NULL)
d5831 1
a5831 2
   null, its TYPE_TAG_NAME.  Null if TYPE is null.  */

d5844 1
a5844 1
   SUFFIX to the name of TYPE.  */
d5851 3
d5872 1
a5872 1
   type describing its fields.  Otherwise, return NULL.  */
d5877 1
a5877 1
  type = ada_check_typedef (type);
d5885 2
a5886 2
      if (len > 6 && strcmp (ada_type_name (type) + len - 6, "___XVE") == 0)
        return type;
d5888 1
a5888 1
        return ada_find_parallel_type (type, "___XVE");
d5893 1
a5893 1
   non-zero iff field FIELD_NUM of TEMPL_TYPE has dynamic size.  */
d5904 2
a5905 2
/* The index of the variant field of TYPE, or -1 if TYPE does not
   represent a variant record type.  */
d5908 1
a5908 1
variant_field_index (struct type *type)
d5912 4
a5915 9
  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_STRUCT)
    return -1;

  for (f = 0; f < TYPE_NFIELDS (type); f += 1)
    {
      if (ada_is_variant_part (type, f))
        return f;
    }
  return -1;
d5918 1
a5918 2
/* A record type with no fields.  */

d5934 3
a5936 3
   the value of type TYPE at VALADDR or ADDRESS (see comments at
   the beginning of this section) VAL according to GNAT conventions.
   DVAL0 should describe the (portion of a) record that contains any
d5940 4
a5943 1
   of the variant.
d5945 3
a5947 12
   If not KEEP_DYNAMIC_FIELDS, then all fields whose position or
   length are not statically known are discarded.  As a consequence,
   VALADDR, ADDRESS and DVAL0 are ignored.

   NOTE: Limitations: For now, we assume that dynamic fields and
   variants occupy whole numbers of bytes.  However, they need not be
   byte-aligned.  */

struct type *
ada_template_to_fixed_record_type_1 (struct type *type, char *valaddr,
                                     CORE_ADDR address, struct value *dval0,
                                     int keep_dynamic_fields)
a5952 1
  int variant_field;
a5953 1
  int fld_bit_len, bit_incr;
d5956 1
a5956 14
  /* Compute the number of fields in this record type that are going
     to be processed: unless keep_dynamic_fields, this includes only
     fields whose position and length are static will be processed.  */
  if (keep_dynamic_fields)
    nfields = TYPE_NFIELDS (type);
  else
    {
      nfields = 0;
      while (nfields < TYPE_NFIELDS (type)
             && !ada_is_variant_part (type, nfields)
             && !is_dynamic_field (type, nfields))
        nfields++;
    }

d5966 3
a5968 1
  TYPE_FLAGS (rtype) |= TYPE_FLAG_FIXED_INSTANCE;
a5971 2
  variant_field = -1;

d5974 7
a5980 2
      off = align_value (off, field_alignment (type, f))
	+ TYPE_FIELD_BITPOS (type, f);
d5983 1
d5986 24
a6009 4
        {
          variant_field = f;
          fld_bit_len = bit_incr = 0;
        }
d6011 27
a6037 27
        {
          if (dval0 == NULL)
            dval = value_from_contents_and_address (rtype, valaddr, address);
          else
            dval = dval0;

          TYPE_FIELD_TYPE (rtype, f) =
            ada_to_fixed_type
            (ada_get_base_type
             (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, f))),
             cond_offset_host (valaddr, off / TARGET_CHAR_BIT),
             cond_offset_target (address, off / TARGET_CHAR_BIT), dval);
          TYPE_FIELD_NAME (rtype, f) = TYPE_FIELD_NAME (type, f);
          bit_incr = fld_bit_len =
            TYPE_LENGTH (TYPE_FIELD_TYPE (rtype, f)) * TARGET_CHAR_BIT;
        }
      else
        {
          TYPE_FIELD_TYPE (rtype, f) = TYPE_FIELD_TYPE (type, f);
          TYPE_FIELD_NAME (rtype, f) = TYPE_FIELD_NAME (type, f);
          if (TYPE_FIELD_BITSIZE (type, f) > 0)
            bit_incr = fld_bit_len =
              TYPE_FIELD_BITSIZE (rtype, f) = TYPE_FIELD_BITSIZE (type, f);
          else
            bit_incr = fld_bit_len =
              TYPE_LENGTH (TYPE_FIELD_TYPE (type, f)) * TARGET_CHAR_BIT;
        }
d6039 1
a6039 1
        bit_len = off + fld_bit_len;
d6041 1
a6041 60
      TYPE_LENGTH (rtype) =
        align_value (bit_len, TARGET_CHAR_BIT) / TARGET_CHAR_BIT;
    }

  /* We handle the variant part, if any, at the end because of certain
     odd cases in which it is re-ordered so as NOT the last field of
     the record.  This can happen in the presence of representation
     clauses.  */
  if (variant_field >= 0)
    {
      struct type *branch_type;

      off = TYPE_FIELD_BITPOS (rtype, variant_field);

      if (dval0 == NULL)
        dval = value_from_contents_and_address (rtype, valaddr, address);
      else
        dval = dval0;

      branch_type =
        to_fixed_variant_branch_type
        (TYPE_FIELD_TYPE (type, variant_field),
         cond_offset_host (valaddr, off / TARGET_CHAR_BIT),
         cond_offset_target (address, off / TARGET_CHAR_BIT), dval);
      if (branch_type == NULL)
        {
          for (f = variant_field + 1; f < TYPE_NFIELDS (rtype); f += 1)
            TYPE_FIELDS (rtype)[f - 1] = TYPE_FIELDS (rtype)[f];
          TYPE_NFIELDS (rtype) -= 1;
        }
      else
        {
          TYPE_FIELD_TYPE (rtype, variant_field) = branch_type;
          TYPE_FIELD_NAME (rtype, variant_field) = "S";
          fld_bit_len =
            TYPE_LENGTH (TYPE_FIELD_TYPE (rtype, variant_field)) *
            TARGET_CHAR_BIT;
          if (off + fld_bit_len > bit_len)
            bit_len = off + fld_bit_len;
          TYPE_LENGTH (rtype) =
            align_value (bit_len, TARGET_CHAR_BIT) / TARGET_CHAR_BIT;
        }
    }

  /* According to exp_dbug.ads, the size of TYPE for variable-size records
     should contain the alignment of that record, which should be a strictly
     positive value.  If null or negative, then something is wrong, most
     probably in the debug info.  In that case, we don't round up the size
     of the resulting type. If this record is not part of another structure,
     the current RTYPE length might be good enough for our purposes.  */
  if (TYPE_LENGTH (type) <= 0)
    {
      warning ("Invalid type size for `%s' detected: %d.",
               TYPE_NAME (rtype) ? TYPE_NAME (rtype) : "<unnamed>",
               TYPE_LENGTH (type));
    }
  else
    {
      TYPE_LENGTH (rtype) = align_value (TYPE_LENGTH (rtype),
                                         TYPE_LENGTH (type));
d6043 1
d6051 6
a6056 19
/* As for ada_template_to_fixed_record_type_1 with KEEP_DYNAMIC_FIELDS
   of 1.  */

static struct type *
template_to_fixed_record_type (struct type *type, char *valaddr,
                               CORE_ADDR address, struct value *dval0)
{
  return ada_template_to_fixed_record_type_1 (type, valaddr,
                                              address, dval0, 1);
}

/* An ordinary record type in which ___XVL-convention fields and
   ___XVU- and ___XVN-convention field types in TYPE0 are replaced with
   static approximations, containing all possible fields.  Uses
   no runtime values.  Useless for use in values, but that's OK,
   since the results are used only for type determinations.   Works on both
   structs and unions.  Representation note: to save space, we memorize
   the result of this function in the TYPE_TARGET_TYPE of the
   template type.  */
d6059 1
a6059 1
template_to_static_fixed_type (struct type *type0)
d6065 2
a6066 2
  if (TYPE_TARGET_TYPE (type0) != NULL)
    return TYPE_TARGET_TYPE (type0);
d6068 14
a6081 2
  nfields = TYPE_NFIELDS (type0);
  type = type0;
d6085 3
a6087 2
      struct type *field_type = ada_check_typedef (TYPE_FIELD_TYPE (type0, f));
      struct type *new_type;
d6089 7
a6095 2
      if (is_dynamic_field (type0, f))
        new_type = to_static_fixed_type (TYPE_TARGET_TYPE (field_type));
d6097 5
a6101 18
        new_type = to_static_fixed_type (field_type);
      if (type == type0 && new_type != field_type)
        {
          TYPE_TARGET_TYPE (type0) = type = alloc_type (TYPE_OBJFILE (type0));
          TYPE_CODE (type) = TYPE_CODE (type0);
          INIT_CPLUS_SPECIFIC (type);
          TYPE_NFIELDS (type) = nfields;
          TYPE_FIELDS (type) = (struct field *)
            TYPE_ALLOC (type, nfields * sizeof (struct field));
          memcpy (TYPE_FIELDS (type), TYPE_FIELDS (type0),
                  sizeof (struct field) * nfields);
          TYPE_NAME (type) = ada_type_name (type0);
          TYPE_TAG_NAME (type) = NULL;
          TYPE_FLAGS (type) |= TYPE_FLAG_FIXED_INSTANCE;
          TYPE_LENGTH (type) = 0;
        }
      TYPE_FIELD_TYPE (type, f) = new_type;
      TYPE_FIELD_NAME (type, f) = TYPE_FIELD_NAME (type0, f);
d6103 1
d6107 3
a6109 7
/* Given an object of type TYPE whose contents are at VALADDR and
   whose address in memory is ADDRESS, returns a revision of TYPE --
   a non-dynamic-sized record with a variant part -- in which
   the variant part is replaced with the appropriate branch.  Looks
   for discriminant values in DVAL0, which can be NULL if the record
   contains the necessary discriminant values.  */

d6112 1
a6112 1
                                   CORE_ADDR address, struct value *dval0)
a6114 1
  struct value *dval;
a6117 1
  int variant_field = variant_field_index (type);
d6119 1
a6119 1
  if (variant_field == -1)
a6121 5
  if (dval0 == NULL)
    dval = value_from_contents_and_address (type, valaddr, address);
  else
    dval = dval0;

d6124 2
a6125 2
  INIT_CPLUS_SPECIFIC (rtype);
  TYPE_NFIELDS (rtype) = nfields;
d6129 1
a6129 1
          sizeof (struct field) * nfields);
d6132 2
a6133 1
  TYPE_FLAGS (rtype) |= TYPE_FLAG_FIXED_INSTANCE;
d6136 3
a6138 2
  branch_type = to_fixed_variant_branch_type
    (TYPE_FIELD_TYPE (type, variant_field),
d6140 2
a6141 2
                       TYPE_FIELD_BITPOS (type, variant_field)
                       / TARGET_CHAR_BIT),
d6143 3
a6145 2
                         TYPE_FIELD_BITPOS (type, variant_field)
                         / TARGET_CHAR_BIT), dval);
a6147 3
      int f;
      for (f = variant_field + 1; f < nfields; f += 1)
        TYPE_FIELDS (rtype)[f - 1] = TYPE_FIELDS (rtype)[f];
d6149 2
d6154 4
a6157 3
      TYPE_FIELD_TYPE (rtype, variant_field) = branch_type;
      TYPE_FIELD_NAME (rtype, variant_field) = "S";
      TYPE_FIELD_BITSIZE (rtype, variant_field) = 0;
d6159 1
a6160 1
  TYPE_LENGTH (rtype) -= TYPE_LENGTH (TYPE_FIELD_TYPE (type, variant_field));
a6161 1
  value_free_to_mark (mark);
d6168 4
a6171 14
   should be in DVAL, a record value; it may be NULL if the object
   at ADDR itself contains any necessary discriminant values.
   Additionally, VALADDR and ADDRESS may also be NULL if no discriminant
   values from the record are needed.  Except in the case that DVAL,
   VALADDR, and ADDRESS are all 0 or NULL, a variant field (unless
   unchecked) is replaced by a particular branch of the variant.

   NOTE: the case in which DVAL and VALADDR are NULL and ADDRESS is 0
   is questionable and may be removed.  It can arise during the
   processing of an unconstrained-array-of-record type where all the
   variant branches have exactly the same size.  This is because in
   such cases, the compiler does not bother to use the XVS convention
   when encoding the record.  I am currently dubious of this
   shortcut and suspect the compiler should be altered.  FIXME.  */
d6174 2
a6175 2
to_fixed_record_type (struct type *type0, char *valaddr,
                      CORE_ADDR address, struct value *dval)
d6179 4
a6182 3
  if (TYPE_FLAGS (type0) & TYPE_FLAG_FIXED_INSTANCE)
    return type0;

d6187 2
a6188 7
  else if (variant_field_index (type0) >= 0)
    {
      if (dval == NULL && valaddr == NULL && address == 0)
        return type0;
      return to_record_with_fixed_variant_part (type0, valaddr, address,
                                                dval);
    }
d6191 2
a6192 1
      TYPE_FLAGS (type0) |= TYPE_FLAG_FIXED_INSTANCE;
d6203 1
a6203 1
   indicated in the union's type name.  */
d6207 1
a6207 1
                              CORE_ADDR address, struct value *dval)
d6225 1
a6225 1
                               VALUE_TYPE (dval), VALUE_CONTENTS (dval));
d6230 2
a6231 1
    return to_fixed_record_type
d6234 1
a6234 1
  else if (variant_field_index (TYPE_FIELD_TYPE (var_type, which)) >= 0)
d6248 2
a6249 1
   varsize_limit.  */
d6253 1
a6253 1
                     int ignore_too_big)
d6258 4
a6261 3
  if (ada_is_packed_array_type (type0)  /* revisit? */
      || (TYPE_FLAGS (type0) & TYPE_FLAG_FIXED_INSTANCE))
    return type0;
d6266 1
a6266 1
      struct type *elt_type0 = ada_check_typedef (TYPE_TARGET_TYPE (type0));
d6268 2
a6269 2
         depend on the contents of the array in properly constructed
         debugging data.  */
d6273 1
a6273 1
        result = type0;
d6275 2
a6276 2
        result = create_array_type (alloc_type (TYPE_OBJFILE (type0)),
                                    elt_type, TYPE_INDEX_TYPE (type0));
d6285 1
a6285 1
        elt_type0 = TYPE_TARGET_TYPE (elt_type0);
d6288 3
a6290 3
         depend on the contents of the array in properly constructed
         debugging data.  */
      result = ada_to_fixed_type (ada_check_typedef (elt_type0), 0, 0, dval);
d6292 7
a6298 7
        {
          struct type *range_type =
            to_fixed_range_type (TYPE_FIELD_NAME (index_type_desc, i),
                                 dval, TYPE_OBJFILE (type0));
          result = create_array_type (alloc_type (TYPE_OBJFILE (type0)),
                                      result, range_type);
        }
d6300 1
a6300 1
        error ("array type with dynamic size is larger than varsize-limit");
d6303 2
a6304 1
  TYPE_FLAGS (result) |= TYPE_FLAG_FIXED_INSTANCE;
d6312 1
a6312 2
   and may be NULL if there are none, or if the object of type TYPE at
   ADDRESS or in VALADDR contains these discriminants.  */
d6315 2
a6316 2
ada_to_fixed_type (struct type *type, char *valaddr,
                   CORE_ADDR address, struct value *dval)
d6318 1
a6318 1
  type = ada_check_typedef (type);
d6324 1
a6324 13
      {
        struct type *static_type = to_static_fixed_type (type);
        if (ada_is_tagged_type (static_type, 0))
          {
            struct type *real_type =
              type_from_tag (value_tag_from_contents_and_address (static_type,
                                                                  valaddr,
                                                                  address));
            if (real_type != NULL)
              type = real_type;
          }
        return to_fixed_record_type (type, valaddr, address, NULL);
      }
d6326 1
a6326 1
      return to_fixed_array_type (type, dval, 1);
d6329 1
a6329 1
        return type;
d6331 1
a6331 1
        return to_fixed_variant_branch_type (type, valaddr, address, dval);
d6336 1
a6336 1
   TYPE0, but based on no runtime data.  */
d6346 5
a6350 4
  if (TYPE_FLAGS (type0) & TYPE_FLAG_FIXED_INSTANCE)
    return type0;

  type0 = ada_check_typedef (type0);
d6359 2
a6360 3
        return template_to_static_fixed_type (type);
      else
        return template_to_static_fixed_type (type0);
d6364 2
a6365 3
        return template_to_static_fixed_type (type);
      else
        return template_to_static_fixed_type (type0);
d6369 1
a6369 2
/* A static approximation of TYPE with all type wrappers removed.  */

d6375 1
a6375 1
      struct type *type1 = TYPE_FIELD_TYPE (ada_check_typedef (type), 0);
d6377 1
a6377 1
        TYPE_NAME (type1) = ada_type_name (type);
d6385 1
a6385 1
        return type;
d6387 1
a6387 1
        return to_static_fixed_type (raw_real_type);
d6392 1
a6392 1
   cross-references that are not resolved as records (for example,
d6397 1
a6397 1
   ).  In these cases, since there is no mechanism for producing
d6400 1
a6400 1
   the name of the actual type.  Call these types "non-record stubs".  */
d6403 1
a6403 2
   exists, otherwise TYPE.  */

d6405 1
a6405 1
ada_check_typedef (struct type *type)
d6424 1
a6424 1
   creation of struct values].  */
d6426 3
a6428 3
static struct value *
ada_to_fixed_value_create (struct type *type0, CORE_ADDR address,
                           struct value *val0)
d6430 1
a6430 1
  struct type *type = ada_to_fixed_type (type0, 0, address, NULL);
d6434 1
a6434 13
    return value_from_contents_and_address (type, 0, address);
}

/* A value representing VAL, but with a standard (static-sized) type
   that correctly describes it.  Does not necessarily create a new
   value.  */

static struct value *
ada_to_fixed_value (struct value *val)
{
  return ada_to_fixed_value_create (VALUE_TYPE (val),
                                    VALUE_ADDRESS (val) + VALUE_OFFSET (val),
                                    val);
d6437 1
a6437 1
/* A value representing VAL, but with a standard (static-sized) type
d6440 1
a6440 1
   types, therefore, the type of the result is likely to be inaccurate.  */
d6450 1
a6450 1
    return coerce_unspec_val_to_type (val, type);
d6454 3
d6459 2
a6460 2
/* Table mapping attribute numbers to names.
   NOTE: Keep up to date with enum ada_attribute definition in ada-lang.h.  */
d6469 1
d6472 1
a6472 4
  "modulus",
  "pos",
  "size",
  "tag",
d6474 1
d6479 1
a6479 1
ada_attribute_name (enum exp_opcode n)
d6481 2
a6482 2
  if (n >= OP_ATR_FIRST && n <= (int) OP_ATR_VAL)
    return attribute_names[n - OP_ATR_FIRST + 1];
d6487 1
a6487 1
/* Evaluate the 'POS attribute applied to ARG.  */
d6489 2
a6490 2
static LONGEST
pos_atr (struct value *arg)
d6503 4
a6506 4
        {
          if (v == TYPE_FIELD_BITPOS (type, i))
            return i;
        }
d6510 1
a6510 7
    return value_as_long (arg);
}

static struct value *
value_pos_atr (struct value *arg)
{
  return value_from_longest (builtin_type_int, pos_atr (arg));
d6513 1
a6513 1
/* Evaluate the TYPE'VAL attribute applied to ARG.  */
d6527 1
a6527 1
        error ("argument to 'VAL out of range");
d6535 1
a6535 1
                                /* Evaluation */
d6537 3
a6539 3
/* True if TYPE appears to be an Ada character type.
   [At the moment, this is true only for Character and Wide_Character;
   It is a heuristic test that could stand improvement].  */
d6548 4
a6551 5
        || TYPE_CODE (type) == TYPE_CODE_INT
        || TYPE_CODE (type) == TYPE_CODE_RANGE)
    && (strcmp (name, "character") == 0
        || strcmp (name, "wide_character") == 0
        || strcmp (name, "unsigned char") == 0);
d6554 1
a6554 1
/* True if TYPE appears to be an Ada string type.  */
d6559 1
a6559 1
  type = ada_check_typedef (type);
d6562 1
a6562 2
      && (ada_is_simple_array_type (type)
          || ada_is_array_descriptor_type (type))
d6576 1
a6576 1
   distinctive name.  */
d6581 1
a6581 8
  type = ada_check_typedef (type);

  /* If we can find a parallel XVS type, then the XVS type should
     be used instead of this type.  And hence, this is not an aligner
     type.  */
  if (ada_find_parallel_type (type, "___XVS") != NULL)
    return 0;

d6583 2
a6584 2
          && TYPE_NFIELDS (type) == 1
          && strcmp (TYPE_FIELD_NAME (type, 0), "F") == 0);
d6588 1
a6588 1
   the parallel type.  */
d6595 1
d6613 1
a6613 1
/* The type of value designated by TYPE, with all aligners removed.  */
d6626 1
a6626 1
   having type TYPE.  Assumes ada_is_aligner_type (TYPE).  */
d6633 3
a6635 3
                                   valaddr +
                                   TYPE_FIELD_BITPOS (type,
                                                      0) / TARGET_CHAR_BIT);
a6639 2


d6641 1
a6641 1
   name NAME.  The value is good to the next call of ada_enum_name.  */
a6644 2
  static char *result;
  static size_t result_len = 0;
d6647 8
a6654 21
  /* First, unqualify the enumeration name:
     1. Search for the last '.' character.  If we find one, then skip
     all the preceeding characters, the unqualified name starts
     right after that dot.
     2. Otherwise, we may be debugging on a target where the compiler
     translates dots into "__".  Search forward for double underscores,
     but stop searching when we hit an overloading suffix, which is
     of the form "__" followed by digits.  */

  tmp = strrchr (name, '.');
  if (tmp != NULL)
    name = tmp + 1;
  else
    {
      while ((tmp = strstr (name, "__")) != NULL)
        {
          if (isdigit (tmp[2]))
            break;
          else
            name = tmp + 2;
        }
d6659 1
d6662 4
a6665 4
        {
          if (sscanf (name + 2, "%x", &v) != 1)
            return name;
        }
d6667 1
a6667 1
        return name;
a6668 1
      GROW_VECT (result, result_len, 16);
d6670 1
a6670 1
        sprintf (result, "'%c'", v);
d6672 1
a6672 1
        sprintf (result, "[\"%02x\"]", v);
d6674 1
a6674 1
        sprintf (result, "[\"%04x\"]", v);
d6679 1
a6679 14
    {
      tmp = strstr (name, "__");
      if (tmp == NULL)
	tmp = strstr (name, "$");
      if (tmp != NULL)
        {
          GROW_VECT (result, result_len, tmp - name + 1);
          strncpy (result, name, tmp - name);
          result[tmp - name] = '\0';
          return result;
        }

      return name;
    }
d6684 1
a6684 1
                 enum noside noside)
d6686 1
a6686 2
  return (*exp->language_defn->la_exp_desc->evaluate_exp)
    (expect_type, exp, pos, noside);
d6691 1
a6691 1
   expression.  */
d6696 1
a6696 1
  return (*exp->language_defn->la_exp_desc->evaluate_exp)
d6701 1
a6701 1
   value it wraps.  */
d6706 1
a6706 1
  struct type *type = ada_check_typedef (VALUE_TYPE (val));
d6710 2
a6711 2
                                          NULL, "internal structure");
      struct type *val_type = ada_check_typedef (VALUE_TYPE (v));
d6713 1
a6713 1
        TYPE_NAME (val_type) = ada_type_name (type);
d6720 1
a6720 1
        ada_check_typedef (ada_get_base_type (type));
d6723 1
a6723 1
        return val;
d6726 4
a6729 4
        coerce_unspec_val_to_type
        (val, ada_to_fixed_type (raw_real_type, 0,
                                 VALUE_ADDRESS (val) + VALUE_OFFSET (val),
                                 NULL));
d6742 2
a6743 2
                              ada_fixed_to_float (VALUE_TYPE (arg),
                                                  value_as_long (arg)));
d6747 1
a6747 1
        value_as_double (value_cast (builtin_type_double, value_copy (arg)));
d6758 1
a6758 1
                                     value_as_long (arg));
d6762 2
a6763 3
/* Coerce VAL as necessary for assignment to an lval of type TYPE, and
   return the converted value.  */

d6771 2
a6772 2
  type2 = ada_check_typedef (type2);
  type = ada_check_typedef (type);
d6785 3
a6787 3
          || TYPE_LENGTH (TYPE_TARGET_TYPE (type2))
          != TYPE_LENGTH (TYPE_TARGET_TYPE (type2)))
        error ("Incompatible types in assignment");
a6792 79
static struct value *
ada_value_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)
{
  struct value *val;
  struct type *type1, *type2;
  LONGEST v, v1, v2;

  COERCE_REF (arg1);
  COERCE_REF (arg2);
  type1 = base_type (ada_check_typedef (VALUE_TYPE (arg1)));
  type2 = base_type (ada_check_typedef (VALUE_TYPE (arg2)));

  if (TYPE_CODE (type1) != TYPE_CODE_INT
      || TYPE_CODE (type2) != TYPE_CODE_INT)
    return value_binop (arg1, arg2, op);

  switch (op)
    {
    case BINOP_MOD:
    case BINOP_DIV:
    case BINOP_REM:
      break;
    default:
      return value_binop (arg1, arg2, op);
    }

  v2 = value_as_long (arg2);
  if (v2 == 0)
    error ("second operand of %s must not be zero.", op_string (op));

  if (TYPE_UNSIGNED (type1) || op == BINOP_MOD)
    return value_binop (arg1, arg2, op);

  v1 = value_as_long (arg1);
  switch (op)
    {
    case BINOP_DIV:
      v = v1 / v2;
      if (!TRUNCATION_TOWARDS_ZERO && v1 * (v1 % v2) < 0)
        v += v > 0 ? -1 : 1;
      break;
    case BINOP_REM:
      v = v1 % v2;
      if (v * v1 < 0)
        v -= v2;
      break;
    default:
      /* Should not reach this point.  */
      v = 0;
    }

  val = allocate_value (type1);
  store_unsigned_integer (VALUE_CONTENTS_RAW (val),
                          TYPE_LENGTH (VALUE_TYPE (val)), v);
  return val;
}

static int
ada_value_equal (struct value *arg1, struct value *arg2)
{
  if (ada_is_direct_array_type (VALUE_TYPE (arg1))
      || ada_is_direct_array_type (VALUE_TYPE (arg2)))
    {
      arg1 = ada_coerce_to_simple_array (arg1);
      arg2 = ada_coerce_to_simple_array (arg2);
      if (TYPE_CODE (VALUE_TYPE (arg1)) != TYPE_CODE_ARRAY
          || TYPE_CODE (VALUE_TYPE (arg2)) != TYPE_CODE_ARRAY)
        error ("Attempt to compare array with non-array");
      /* FIXME: The following works only for types whose
         representations use all bits (no padding or undefined bits)
         and do not have user-defined equality.  */
      return
        TYPE_LENGTH (VALUE_TYPE (arg1)) == TYPE_LENGTH (VALUE_TYPE (arg2))
        && memcmp (VALUE_CONTENTS (arg1), VALUE_CONTENTS (arg2),
                   TYPE_LENGTH (VALUE_TYPE (arg1))) == 0;
    }
  return value_equal (arg1, arg2);
}

d6795 1
a6795 1
                     int *pos, enum noside noside)
d6798 1
d6815 2
a6816 14
        unwrap_value (evaluate_subexp_standard
                      (expect_type, exp, pos, noside));

    case OP_STRING:
      {
        struct value *result;
        *pos -= 1;
        result = evaluate_subexp_standard (expect_type, exp, pos, noside);
        /* The result type will have code OP_STRING, bashed there from 
           OP_ARRAY.  Bash it back.  */
        if (TYPE_CODE (VALUE_TYPE (result)) == TYPE_CODE_STRING)
          TYPE_CODE (VALUE_TYPE (result)) = TYPE_CODE_ARRAY;
        return result;
      }
d6823 23
a6845 23
        goto nosideret;
      if (type != ada_check_typedef (VALUE_TYPE (arg1)))
        {
          if (ada_is_fixed_point_type (type))
            arg1 = cast_to_fixed (type, arg1);
          else if (ada_is_fixed_point_type (VALUE_TYPE (arg1)))
            arg1 = value_cast (type, cast_from_fixed_to_double (arg1));
          else if (VALUE_LVAL (arg1) == lval_memory)
            {
              /* This is in case of the really obscure (and undocumented,
                 but apparently expected) case of (Foo) Bar.all, where Bar
                 is an integer constant and Foo is a dynamic-sized type.
                 If we don't do this, ARG1 will simply be relabeled with
                 TYPE.  */
              if (noside == EVAL_AVOID_SIDE_EFFECTS)
                return value_zero (to_static_fixed_type (type), not_lval);
              arg1 =
                ada_to_fixed_value_create
                (type, VALUE_ADDRESS (arg1) + VALUE_OFFSET (arg1), 0);
            }
          else
            arg1 = value_cast (type, arg1);
        }
d6848 6
a6853 5
    case UNOP_QUAL:
      (*pos) += 2;
      type = exp->elts[pc + 1].type;
      return ada_evaluate_subexp (type, exp, pos, noside);

d6858 3
a6860 6
        return arg1;
      if (ada_is_fixed_point_type (VALUE_TYPE (arg1)))
        arg2 = cast_to_fixed (VALUE_TYPE (arg1), arg2);
      else if (ada_is_fixed_point_type (VALUE_TYPE (arg2)))
        error
          ("Fixed-point values must be assigned to fixed-point variables");
d6862 10
a6871 2
        arg2 = coerce_for_assign (VALUE_TYPE (arg1), arg2);
      return ada_value_assign (arg1, arg2);
d6877 12
a6888 6
        goto nosideret;
      if ((ada_is_fixed_point_type (VALUE_TYPE (arg1))
           || ada_is_fixed_point_type (VALUE_TYPE (arg2)))
          && VALUE_TYPE (arg1) != VALUE_TYPE (arg2))
        error ("Operands of fixed-point addition must have the same type");
      return value_cast (VALUE_TYPE (arg1), value_add (arg1, arg2));
d6894 12
a6905 6
        goto nosideret;
      if ((ada_is_fixed_point_type (VALUE_TYPE (arg1))
           || ada_is_fixed_point_type (VALUE_TYPE (arg2)))
          && VALUE_TYPE (arg1) != VALUE_TYPE (arg2))
        error ("Operands of fixed-point subtraction must have the same type");
      return value_cast (VALUE_TYPE (arg1), value_sub (arg1, arg2));
d6912 15
a6926 295
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS
               && (op == BINOP_DIV || op == BINOP_REM || op == BINOP_MOD))
        return value_zero (VALUE_TYPE (arg1), not_lval);
      else
        {
          if (ada_is_fixed_point_type (VALUE_TYPE (arg1)))
            arg1 = cast_from_fixed_to_double (arg1);
          if (ada_is_fixed_point_type (VALUE_TYPE (arg2)))
            arg2 = cast_from_fixed_to_double (arg2);
          return ada_value_binop (arg1, arg2, op);
        }

    case BINOP_REM:
    case BINOP_MOD:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS
               && (op == BINOP_DIV || op == BINOP_REM || op == BINOP_MOD))
        return value_zero (VALUE_TYPE (arg1), not_lval);
      else
        return ada_value_binop (arg1, arg2, op);

    case BINOP_EQUAL:
    case BINOP_NOTEQUAL:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (VALUE_TYPE (arg1), exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
        tem = 0;
      else
        tem = ada_value_equal (arg1, arg2);
      if (op == BINOP_NOTEQUAL)
        tem = !tem;
      return value_from_longest (LA_BOOL_TYPE, (LONGEST) tem);

    case UNOP_NEG:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (ada_is_fixed_point_type (VALUE_TYPE (arg1)))
        return value_cast (VALUE_TYPE (arg1), value_neg (arg1));
      else
        return value_neg (arg1);

    case OP_VAR_VALUE:
      *pos -= 1;
      if (noside == EVAL_SKIP)
        {
          *pos += 4;
          goto nosideret;
        }
      else if (SYMBOL_DOMAIN (exp->elts[pc + 2].symbol) == UNDEF_DOMAIN)
        /* Only encountered when an unresolved symbol occurs in a
           context other than a function call, in which case, it is
           illegal.  */
        error ("Unexpected unresolved symbol, %s, during evaluation",
               SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
        {
          *pos += 4;
          return value_zero
            (to_static_fixed_type
             (static_unwrap_type (SYMBOL_TYPE (exp->elts[pc + 2].symbol))),
             not_lval);
        }
      else
        {
          arg1 =
            unwrap_value (evaluate_subexp_standard
                          (expect_type, exp, pos, noside));
          return ada_to_fixed_value (arg1);
        }

    case OP_FUNCALL:
      (*pos) += 2;

      /* Allocate arg vector, including space for the function to be
         called in argvec[0] and a terminating NULL.  */
      nargs = longest_to_int (exp->elts[pc + 1].longconst);
      argvec =
        (struct value **) alloca (sizeof (struct value *) * (nargs + 2));

      if (exp->elts[*pos].opcode == OP_VAR_VALUE
          && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)
        error ("Unexpected unresolved symbol, %s, during evaluation",
               SYMBOL_PRINT_NAME (exp->elts[pc + 5].symbol));
      else
        {
          for (tem = 0; tem <= nargs; tem += 1)
            argvec[tem] = evaluate_subexp (NULL_TYPE, exp, pos, noside);
          argvec[tem] = 0;

          if (noside == EVAL_SKIP)
            goto nosideret;
        }

      if (ada_is_packed_array_type (desc_base_type (VALUE_TYPE (argvec[0]))))
        argvec[0] = ada_coerce_to_simple_array (argvec[0]);
      else if (TYPE_CODE (VALUE_TYPE (argvec[0])) == TYPE_CODE_REF
               || (TYPE_CODE (VALUE_TYPE (argvec[0])) == TYPE_CODE_ARRAY
                   && VALUE_LVAL (argvec[0]) == lval_memory))
        argvec[0] = value_addr (argvec[0]);

      type = ada_check_typedef (VALUE_TYPE (argvec[0]));
      if (TYPE_CODE (type) == TYPE_CODE_PTR)
        {
          switch (TYPE_CODE (ada_check_typedef (TYPE_TARGET_TYPE (type))))
            {
            case TYPE_CODE_FUNC:
              type = ada_check_typedef (TYPE_TARGET_TYPE (type));
              break;
            case TYPE_CODE_ARRAY:
              break;
            case TYPE_CODE_STRUCT:
              if (noside != EVAL_AVOID_SIDE_EFFECTS)
                argvec[0] = ada_value_ind (argvec[0]);
              type = ada_check_typedef (TYPE_TARGET_TYPE (type));
              break;
            default:
              error ("cannot subscript or call something of type `%s'",
                     ada_type_name (VALUE_TYPE (argvec[0])));
              break;
            }
        }

      switch (TYPE_CODE (type))
        {
        case TYPE_CODE_FUNC:
          if (noside == EVAL_AVOID_SIDE_EFFECTS)
            return allocate_value (TYPE_TARGET_TYPE (type));
          return call_function_by_hand (argvec[0], nargs, argvec + 1);
        case TYPE_CODE_STRUCT:
          {
            int arity;

            arity = ada_array_arity (type);
            type = ada_array_element_type (type, nargs);
            if (type == NULL)
              error ("cannot subscript or call a record");
            if (arity != nargs)
              error ("wrong number of subscripts; expecting %d", arity);
            if (noside == EVAL_AVOID_SIDE_EFFECTS)
              return allocate_value (ada_aligned_type (type));
            return
              unwrap_value (ada_value_subscript
                            (argvec[0], nargs, argvec + 1));
          }
        case TYPE_CODE_ARRAY:
          if (noside == EVAL_AVOID_SIDE_EFFECTS)
            {
              type = ada_array_element_type (type, nargs);
              if (type == NULL)
                error ("element type of array unknown");
              else
                return allocate_value (ada_aligned_type (type));
            }
          return
            unwrap_value (ada_value_subscript
                          (ada_coerce_to_simple_array (argvec[0]),
                           nargs, argvec + 1));
        case TYPE_CODE_PTR:     /* Pointer to array */
          type = to_fixed_array_type (TYPE_TARGET_TYPE (type), NULL, 1);
          if (noside == EVAL_AVOID_SIDE_EFFECTS)
            {
              type = ada_array_element_type (type, nargs);
              if (type == NULL)
                error ("element type of array unknown");
              else
                return allocate_value (ada_aligned_type (type));
            }
          return
            unwrap_value (ada_value_ptr_subscript (argvec[0], type,
                                                   nargs, argvec + 1));

        default:
          error ("Attempt to index or call something other than an "
		 "array or function");
        }

    case TERNOP_SLICE:
      {
        struct value *array = evaluate_subexp (NULL_TYPE, exp, pos, noside);
        struct value *low_bound_val =
          evaluate_subexp (NULL_TYPE, exp, pos, noside);
        struct value *high_bound_val =
          evaluate_subexp (NULL_TYPE, exp, pos, noside);
        LONGEST low_bound;
        LONGEST high_bound;
        COERCE_REF (low_bound_val);
        COERCE_REF (high_bound_val);
        low_bound = pos_atr (low_bound_val);
        high_bound = pos_atr (high_bound_val);

        if (noside == EVAL_SKIP)
          goto nosideret;

        /* If this is a reference to an aligner type, then remove all
           the aligners.  */
        if (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_REF
            && ada_is_aligner_type (TYPE_TARGET_TYPE (VALUE_TYPE (array))))
          TYPE_TARGET_TYPE (VALUE_TYPE (array)) =
            ada_aligned_type (TYPE_TARGET_TYPE (VALUE_TYPE (array)));

        if (ada_is_packed_array_type (VALUE_TYPE (array)))
          error ("cannot slice a packed array");

        /* If this is a reference to an array or an array lvalue,
           convert to a pointer.  */
        if (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_REF
            || (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_ARRAY
                && VALUE_LVAL (array) == lval_memory))
          array = value_addr (array);

        if (noside == EVAL_AVOID_SIDE_EFFECTS
            && ada_is_array_descriptor_type (ada_check_typedef
                                             (VALUE_TYPE (array))))
          return empty_array (ada_type_of_array (array, 0), low_bound);

        array = ada_coerce_to_simple_array_ptr (array);

        /* If we have more than one level of pointer indirection,
           dereference the value until we get only one level.  */
        while (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_PTR
               && (TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (array)))
                     == TYPE_CODE_PTR))
          array = value_ind (array);

        /* Make sure we really do have an array type before going further,
           to avoid a SEGV when trying to get the index type or the target
           type later down the road if the debug info generated by
           the compiler is incorrect or incomplete.  */
        if (!ada_is_simple_array_type (VALUE_TYPE (array)))
          error ("cannot take slice of non-array");

        if (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_PTR)
          {
            if (high_bound < low_bound || noside == EVAL_AVOID_SIDE_EFFECTS)
              return empty_array (TYPE_TARGET_TYPE (VALUE_TYPE (array)),
                                  low_bound);
            else
              {
                struct type *arr_type0 =
                  to_fixed_array_type (TYPE_TARGET_TYPE (VALUE_TYPE (array)),
                                       NULL, 1);
                return ada_value_slice_ptr (array, arr_type0,
                                            (int) low_bound, 
					    (int) high_bound);
              }
          }
        else if (noside == EVAL_AVOID_SIDE_EFFECTS)
          return array;
        else if (high_bound < low_bound)
          return empty_array (VALUE_TYPE (array), low_bound);
        else
          return ada_value_slice (array, (int) low_bound, (int) high_bound);
      }

    case UNOP_IN_RANGE:
      (*pos) += 2;
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      type = exp->elts[pc + 1].type;

      if (noside == EVAL_SKIP)
        goto nosideret;

      switch (TYPE_CODE (type))
        {
        default:
          lim_warning ("Membership test incompletely implemented; "
                       "always returns true");
          return value_from_longest (builtin_type_int, (LONGEST) 1);

        case TYPE_CODE_RANGE:
          arg2 = value_from_longest (builtin_type_int, TYPE_LOW_BOUND (type));
          arg3 = value_from_longest (builtin_type_int,
                                     TYPE_HIGH_BOUND (type));
          return
            value_from_longest (builtin_type_int,
                                (value_less (arg1, arg3)
                                 || value_equal (arg1, arg3))
                                && (value_less (arg2, arg1)
                                    || value_equal (arg2, arg1)));
        }

    case BINOP_IN_BOUNDS:
      (*pos) += 2;
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

      if (noside == EVAL_SKIP)
        goto nosideret;
d6928 1
a6928 19
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
        return value_zero (builtin_type_int, not_lval);

      tem = longest_to_int (exp->elts[pc + 1].longconst);

      if (tem < 1 || tem > ada_array_arity (VALUE_TYPE (arg2)))
        error ("invalid dimension number to '%s", "range");

      arg3 = ada_array_bound (arg2, tem, 1);
      arg2 = ada_array_bound (arg2, tem, 0);

      return
        value_from_longest (builtin_type_int,
                            (value_less (arg1, arg3)
                             || value_equal (arg1, arg3))
                            && (value_less (arg2, arg1)
                                || value_equal (arg2, arg1)));

    case TERNOP_IN_RANGE:
d6930 8
a6937 2
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg3 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
d6939 14
d6954 21
a6974 1
        goto nosideret;
d6976 6
a6981 123
      return
        value_from_longest (builtin_type_int,
                            (value_less (arg1, arg3)
                             || value_equal (arg1, arg3))
                            && (value_less (arg2, arg1)
                                || value_equal (arg2, arg1)));

    case OP_ATR_FIRST:
    case OP_ATR_LAST:
    case OP_ATR_LENGTH:
      {
        struct type *type_arg;
        if (exp->elts[*pos].opcode == OP_TYPE)
          {
            evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
            arg1 = NULL;
            type_arg = exp->elts[pc + 2].type;
          }
        else
          {
            arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
            type_arg = NULL;
          }

        if (exp->elts[*pos].opcode != OP_LONG)
          error ("illegal operand to '%s", ada_attribute_name (op));
        tem = longest_to_int (exp->elts[*pos + 2].longconst);
        *pos += 4;

        if (noside == EVAL_SKIP)
          goto nosideret;

        if (type_arg == NULL)
          {
            arg1 = ada_coerce_ref (arg1);

            if (ada_is_packed_array_type (VALUE_TYPE (arg1)))
              arg1 = ada_coerce_to_simple_array (arg1);

            if (tem < 1 || tem > ada_array_arity (VALUE_TYPE (arg1)))
              error ("invalid dimension number to '%s",
                     ada_attribute_name (op));

            if (noside == EVAL_AVOID_SIDE_EFFECTS)
              {
                type = ada_index_type (VALUE_TYPE (arg1), tem);
                if (type == NULL)
                  error
                    ("attempt to take bound of something that is not an array");
                return allocate_value (type);
              }

            switch (op)
              {
              default:          /* Should never happen.  */
                error ("unexpected attribute encountered");
              case OP_ATR_FIRST:
                return ada_array_bound (arg1, tem, 0);
              case OP_ATR_LAST:
                return ada_array_bound (arg1, tem, 1);
              case OP_ATR_LENGTH:
                return ada_array_length (arg1, tem);
              }
          }
        else if (discrete_type_p (type_arg))
          {
            struct type *range_type;
            char *name = ada_type_name (type_arg);
            range_type = NULL;
            if (name != NULL && TYPE_CODE (type_arg) != TYPE_CODE_ENUM)
              range_type =
                to_fixed_range_type (name, NULL, TYPE_OBJFILE (type_arg));
            if (range_type == NULL)
              range_type = type_arg;
            switch (op)
              {
              default:
                error ("unexpected attribute encountered");
              case OP_ATR_FIRST:
                return discrete_type_low_bound (range_type);
              case OP_ATR_LAST:
                return discrete_type_high_bound (range_type);
              case OP_ATR_LENGTH:
                error ("the 'length attribute applies only to array types");
              }
          }
        else if (TYPE_CODE (type_arg) == TYPE_CODE_FLT)
          error ("unimplemented type attribute");
        else
          {
            LONGEST low, high;

            if (ada_is_packed_array_type (type_arg))
              type_arg = decode_packed_array_type (type_arg);

            if (tem < 1 || tem > ada_array_arity (type_arg))
              error ("invalid dimension number to '%s",
                     ada_attribute_name (op));

            type = ada_index_type (type_arg, tem);
            if (type == NULL)
              error
                ("attempt to take bound of something that is not an array");
            if (noside == EVAL_AVOID_SIDE_EFFECTS)
              return allocate_value (type);

            switch (op)
              {
              default:
                error ("unexpected attribute encountered");
              case OP_ATR_FIRST:
                low = ada_array_bound_from_type (type_arg, tem, 0, &type);
                return value_from_longest (type, low);
              case OP_ATR_LAST:
                high = ada_array_bound_from_type (type_arg, tem, 1, &type);
                return value_from_longest (type, high);
              case OP_ATR_LENGTH:
                low = ada_array_bound_from_type (type_arg, tem, 0, &type);
                high = ada_array_bound_from_type (type_arg, tem, 1, NULL);
                return value_from_longest (type, high - low + 1);
              }
          }
      }
d6983 8
a6990 2
    case OP_ATR_TAG:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
d6992 2
a6993 1
        goto nosideret;
d6995 2
a6996 2
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
        return value_zero (ada_tag_type (arg1), not_lval);
d6998 5
a7002 1
      return ada_value_tag (arg1);
d7004 10
a7013 9
    case OP_ATR_MIN:
    case OP_ATR_MAX:
      evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
        return value_zero (VALUE_TYPE (arg1), not_lval);
d7015 4
a7018 2
        return value_binop (arg1, arg2,
                            op == OP_ATR_MIN ? BINOP_MIN : BINOP_MAX);
d7020 3
a7022 4
    case OP_ATR_MODULUS:
      {
        struct type *type_arg = exp->elts[pc + 2].type;
        evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
d7024 2
a7025 2
        if (noside == EVAL_SKIP)
          goto nosideret;
d7027 2
a7028 2
        if (!ada_is_modular_type (type_arg))
          error ("'modulus must be applied to modular type");
d7030 21
a7050 3
        return value_from_longest (TYPE_TARGET_TYPE (type_arg),
                                   ada_modulus (type_arg));
      }
d7052 46
d7099 3
a7101 9
    case OP_ATR_POS:
      evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
        return value_zero (builtin_type_int, not_lval);
      else
        return value_pos_atr (arg1);
d7103 49
a7151 21
    case OP_ATR_SIZE:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
        return value_zero (builtin_type_int, not_lval);
      else
        return value_from_longest (builtin_type_int,
                                   TARGET_CHAR_BIT
                                   * TYPE_LENGTH (VALUE_TYPE (arg1)));

    case OP_ATR_VAL:
      evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      type = exp->elts[pc + 2].type;
      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
        return value_zero (type, not_lval);
      else
        return value_val_atr (type, arg1);
d7153 291
d7448 4
a7451 1
        goto nosideret;
d7453 1
a7453 1
        return value_zero (VALUE_TYPE (arg1), not_lval);
d7455 1
a7455 1
        return value_binop (arg1, arg2, op);
d7460 3
a7462 1
        goto nosideret;
d7464 1
a7464 1
        return arg1;
d7469 1
a7469 1
        goto nosideret;
d7471 1
a7471 1
        return value_neg (arg1);
d7473 1
a7473 1
        return arg1;
d7477 1
a7477 1
        expect_type = TYPE_TARGET_TYPE (ada_check_typedef (expect_type));
d7480 2
a7481 2
        goto nosideret;
      type = ada_check_typedef (VALUE_TYPE (arg1));
d7483 30
a7512 32
        {
          if (ada_is_array_descriptor_type (type))
            /* GDB allows dereferencing GNAT array descriptors.  */
            {
              struct type *arrType = ada_type_of_array (arg1, 0);
              if (arrType == NULL)
                error ("Attempt to dereference null array pointer.");
              return value_at_lazy (arrType, 0, NULL);
            }
          else if (TYPE_CODE (type) == TYPE_CODE_PTR
                   || TYPE_CODE (type) == TYPE_CODE_REF
                   /* In C you can dereference an array to get the 1st elt.  */
                   || TYPE_CODE (type) == TYPE_CODE_ARRAY)
            {
              type = to_static_fixed_type
                (ada_aligned_type
                 (ada_check_typedef (TYPE_TARGET_TYPE (type))));
              check_size (type);
              return value_zero (type, lval_memory);
            }
          else if (TYPE_CODE (type) == TYPE_CODE_INT)
            /* GDB allows dereferencing an int.  */
            return value_zero (builtin_type_int, lval_memory);
          else
            error ("Attempt to take contents of a non-pointer value.");
        }
      arg1 = ada_coerce_ref (arg1);     /* FIXME: What is this for?? */
      type = ada_check_typedef (VALUE_TYPE (arg1));

      if (ada_is_array_descriptor_type (type))
        /* GDB allows dereferencing GNAT array descriptors.  */
        return ada_coerce_to_simple_array (arg1);
d7514 1
a7514 1
        return ada_value_ind (arg1);
d7521 1
a7521 1
        goto nosideret;
d7523 10
a7532 26
        {
          struct type *type1 = VALUE_TYPE (arg1);
          if (ada_is_tagged_type (type1, 1))
            {
              type = ada_lookup_struct_elt_type (type1,
                                                 &exp->elts[pc + 2].string,
                                                 1, 1, NULL);
              if (type == NULL)
                /* In this case, we assume that the field COULD exist
                   in some extension of the type.  Return an object of 
                   "type" void, which will match any formal 
                   (see ada_type_match). */
                return value_zero (builtin_type_void, lval_memory);
            }
          else
            type =
              ada_lookup_struct_elt_type (type1, &exp->elts[pc + 2].string, 1,
                                          0, NULL);

          return value_zero (ada_aligned_type (type), lval_memory);
        }
      else
        return
          ada_to_fixed_value (unwrap_value
                              (ada_value_struct_elt
                               (arg1, &exp->elts[pc + 2].string, "record")));
d7534 2
a7535 2
      /* The value is not supposed to be used.  This is here to make it
         easier to accommodate expressions that contain types.  */
d7538 1
a7538 1
        goto nosideret;
d7540 1
a7540 1
        return allocate_value (builtin_type_void);
d7542 19
a7560 1
        error ("Attempt to use a type name as an expression");
d7568 1
a7568 1
                                /* Fixed point */
d7572 1
a7572 1
   Otherwise, return NULL.  */
d7584 1
a7584 1
        return NULL;
d7586 1
a7586 1
        return tail + 5;
d7594 1
a7594 1
/* Returns non-zero iff TYPE represents an Ada fixed-point type.  */
a7601 9
/* Return non-zero iff TYPE represents a System.Address type.  */

int
ada_is_system_address_type (struct type *type)
{
  return (TYPE_NAME (type)
          && strcmp (TYPE_NAME (type), "system__address") == 0);
}

d7604 1
a7604 1
   delta cannot be determined.  */
d7619 1
a7619 1
   factor ('SMALL value) associated with the type.  */
d7640 1
a7640 1
   type TYPE, return its floating-point equivalent.  */
d7648 2
a7649 2
/* The representation of a fixed-point value of type TYPE
   corresponding to the value X.  */
d7658 1
a7658 1
                                /* VAX floating formats */
d7661 1
a7661 2
   types.  */

d7670 2
a7671 2
        || TYPE_CODE (type) == TYPE_CODE_RANGE)
    && strncmp (ada_type_name (type) + name_len - 6, "___XF", 5) == 0;
d7675 1
a7675 2
   ada_is_vax_floating_point.  */

d7682 1
a7682 1
/* A value representing the special debugging function that outputs
d7684 1
a7684 2
   ada_is_vax_floating_type (TYPE).  */

d7702 1
a7702 1
                                /* Range types */
d7708 1
a7708 1
   not alter *PX and *PNEW_K if unsuccessful.  */
d7712 1
a7712 1
                    int *pnew_k)
d7750 1
a7750 2
   otherwise causes an error with message ERR_MSG.  */

d7754 2
a7755 1
  struct ada_symbol_info *syms;
d7758 3
a7760 2
  nsyms = ada_lookup_symbol_list (name, get_selected_block (0), VAR_DOMAIN,
                                  &syms);
d7765 1
a7765 1
        return 0;
d7767 1
a7767 1
        error ("%s", err_msg);
d7770 1
a7770 1
  return value_of_variable (syms[0].sym, syms[0].block);
d7774 2
a7775 3
   no such variable found, returns 0, and sets *FLAG to 0.  If
   successful, sets *FLAG to 1.  */

d7777 1
a7777 1
get_int_var_value (char *name, int *flag)
d7779 1
a7779 1
  struct value *var_val = get_var_value (name, 0);
d7784 1
a7784 1
        *flag = 0;
d7790 1
a7790 1
        *flag = 1;
d7798 1
a7798 1
   from NAME according to the GNAT range encoding conventions.
d7802 1
a7802 1
   the named range type.  */
d7809 1
d7841 15
a7855 21
        {
          if (!ada_scan_number (bounds_str, n, &L, &n)
              && !scan_discrim_bound (bounds_str, n, dval, &L, &n))
            return raw_type;
          if (bounds_str[n] == '_')
            n += 2;
          else if (bounds_str[n] == '.')        /* FIXME? SGI Workshop kludge.  */
            n += 1;
          subtype_info += 1;
        }
      else
        {
          int ok;
          strcpy (name_buf + prefix_len, "___L");
          L = get_int_var_value (name_buf, &ok);
          if (!ok)
            {
              lim_warning ("Unknown lower bound, using 1.");
              L = 1;
            }
        }
d7858 10
a7867 16
        {
          if (!ada_scan_number (bounds_str, n, &U, &n)
              && !scan_discrim_bound (bounds_str, n, dval, &U, &n))
            return raw_type;
        }
      else
        {
          int ok;
          strcpy (name_buf + prefix_len, "___U");
          U = get_int_var_value (name_buf, &ok);
          if (!ok)
            {
              lim_warning ("Unknown upper bound, using %ld.", (long) L);
              U = L;
            }
        }
d7870 1
a7870 1
        objfile = TYPE_OBJFILE (base_type);
d7877 1
a7877 2
/* True iff NAME is the name of a range type.  */

d7885 1
a7885 3
                                /* Modular types */

/* True iff TYPE is an Ada modular type.  */
d7887 1
d7891 3
a7893 1
  struct type *subranged_type = base_type (type);
d7896 2
a7897 2
          && TYPE_CODE (subranged_type) != TYPE_CODE_ENUM
          && TYPE_UNSIGNED (subranged_type));
d7900 2
a7901 3
/* Assuming ada_is_modular_type (TYPE), the modulus of TYPE.  */

ULONGEST
d7904 1
a7904 1
  return (ULONGEST) TYPE_HIGH_BOUND (type) + 1;
a7906 134
                                /* Operators */
/* Information about operators given special treatment in functions
   below.  */
/* Format: OP_DEFN (<operator>, <operator length>, <# args>, <binop>).  */

#define ADA_OPERATORS \
    OP_DEFN (OP_VAR_VALUE, 4, 0, 0) \
    OP_DEFN (BINOP_IN_BOUNDS, 3, 2, 0) \
    OP_DEFN (TERNOP_IN_RANGE, 1, 3, 0) \
    OP_DEFN (OP_ATR_FIRST, 1, 2, 0) \
    OP_DEFN (OP_ATR_LAST, 1, 2, 0) \
    OP_DEFN (OP_ATR_LENGTH, 1, 2, 0) \
    OP_DEFN (OP_ATR_IMAGE, 1, 2, 0) \
    OP_DEFN (OP_ATR_MAX, 1, 3, 0) \
    OP_DEFN (OP_ATR_MIN, 1, 3, 0) \
    OP_DEFN (OP_ATR_MODULUS, 1, 1, 0) \
    OP_DEFN (OP_ATR_POS, 1, 2, 0) \
    OP_DEFN (OP_ATR_SIZE, 1, 1, 0) \
    OP_DEFN (OP_ATR_TAG, 1, 1, 0) \
    OP_DEFN (OP_ATR_VAL, 1, 2, 0) \
    OP_DEFN (UNOP_QUAL, 3, 1, 0) \
    OP_DEFN (UNOP_IN_RANGE, 3, 1, 0)

static void
ada_operator_length (struct expression *exp, int pc, int *oplenp, int *argsp)
{
  switch (exp->elts[pc - 1].opcode)
    {
    default:
      operator_length_standard (exp, pc, oplenp, argsp);
      break;

#define OP_DEFN(op, len, args, binop) \
    case op: *oplenp = len; *argsp = args; break;
      ADA_OPERATORS;
#undef OP_DEFN
    }
}

static char *
ada_op_name (enum exp_opcode opcode)
{
  switch (opcode)
    {
    default:
      return op_name_standard (opcode);
#define OP_DEFN(op, len, args, binop) case op: return #op;
      ADA_OPERATORS;
#undef OP_DEFN
    }
}

/* As for operator_length, but assumes PC is pointing at the first
   element of the operator, and gives meaningful results only for the 
   Ada-specific operators.  */

static void
ada_forward_operator_length (struct expression *exp, int pc,
                             int *oplenp, int *argsp)
{
  switch (exp->elts[pc].opcode)
    {
    default:
      *oplenp = *argsp = 0;
      break;
#define OP_DEFN(op, len, args, binop) \
    case op: *oplenp = len; *argsp = args; break;
      ADA_OPERATORS;
#undef OP_DEFN
    }
}

static int
ada_dump_subexp_body (struct expression *exp, struct ui_file *stream, int elt)
{
  enum exp_opcode op = exp->elts[elt].opcode;
  int oplen, nargs;
  int pc = elt;
  int i;

  ada_forward_operator_length (exp, elt, &oplen, &nargs);

  switch (op)
    {
      /* Ada attributes ('Foo).  */
    case OP_ATR_FIRST:
    case OP_ATR_LAST:
    case OP_ATR_LENGTH:
    case OP_ATR_IMAGE:
    case OP_ATR_MAX:
    case OP_ATR_MIN:
    case OP_ATR_MODULUS:
    case OP_ATR_POS:
    case OP_ATR_SIZE:
    case OP_ATR_TAG:
    case OP_ATR_VAL:
      break;

    case UNOP_IN_RANGE:
    case UNOP_QUAL:
      fprintf_filtered (stream, "Type @@");
      gdb_print_host_address (exp->elts[pc + 1].type, stream);
      fprintf_filtered (stream, " (");
      type_print (exp->elts[pc + 1].type, NULL, stream, 0);
      fprintf_filtered (stream, ")");
      break;
    case BINOP_IN_BOUNDS:
      fprintf_filtered (stream, " (%d)", (int) exp->elts[pc + 2].longconst);
      break;
    case TERNOP_IN_RANGE:
      break;

    default:
      return dump_subexp_body_standard (exp, stream, elt);
    }

  elt += oplen;
  for (i = 0; i < nargs; i += 1)
    elt = dump_subexp (exp, stream, elt);

  return elt;
}

/* The Ada extension of print_subexp (q.v.).  */

static void
ada_print_subexp (struct expression *exp, int *pos,
                  struct ui_file *stream, enum precedence prec)
{
  int oplen, nargs;
  int pc = *pos;
  enum exp_opcode op = exp->elts[pc].opcode;

  ada_forward_operator_length (exp, pc, &oplen, &nargs);
a7907 5
  switch (op)
    {
    default:
      print_subexp_standard (exp, pos, stream, prec);
      return;
d7909 1
a7909 78
    case OP_VAR_VALUE:
      *pos += oplen;
      fputs_filtered (SYMBOL_NATURAL_NAME (exp->elts[pc + 2].symbol), stream);
      return;

    case BINOP_IN_BOUNDS:
      *pos += oplen;
      print_subexp (exp, pos, stream, PREC_SUFFIX);
      fputs_filtered (" in ", stream);
      print_subexp (exp, pos, stream, PREC_SUFFIX);
      fputs_filtered ("'range", stream);
      if (exp->elts[pc + 1].longconst > 1)
        fprintf_filtered (stream, "(%ld)",
                          (long) exp->elts[pc + 1].longconst);
      return;

    case TERNOP_IN_RANGE:
      *pos += oplen;
      if (prec >= PREC_EQUAL)
        fputs_filtered ("(", stream);
      print_subexp (exp, pos, stream, PREC_SUFFIX);
      fputs_filtered (" in ", stream);
      print_subexp (exp, pos, stream, PREC_EQUAL);
      fputs_filtered (" .. ", stream);
      print_subexp (exp, pos, stream, PREC_EQUAL);
      if (prec >= PREC_EQUAL)
        fputs_filtered (")", stream);
      return;

    case OP_ATR_FIRST:
    case OP_ATR_LAST:
    case OP_ATR_LENGTH:
    case OP_ATR_IMAGE:
    case OP_ATR_MAX:
    case OP_ATR_MIN:
    case OP_ATR_MODULUS:
    case OP_ATR_POS:
    case OP_ATR_SIZE:
    case OP_ATR_TAG:
    case OP_ATR_VAL:
      *pos += oplen;
      if (exp->elts[*pos].opcode == OP_TYPE)
        {
          if (TYPE_CODE (exp->elts[*pos + 1].type) != TYPE_CODE_VOID)
            LA_PRINT_TYPE (exp->elts[*pos + 1].type, "", stream, 0, 0);
          *pos += 3;
        }
      else
        print_subexp (exp, pos, stream, PREC_SUFFIX);
      fprintf_filtered (stream, "'%s", ada_attribute_name (op));
      if (nargs > 1)
        {
          int tem;
          for (tem = 1; tem < nargs; tem += 1)
            {
              fputs_filtered ((tem == 1) ? " (" : ", ", stream);
              print_subexp (exp, pos, stream, PREC_ABOVE_COMMA);
            }
          fputs_filtered (")", stream);
        }
      return;

    case UNOP_QUAL:
      *pos += oplen;
      type_print (exp->elts[pc + 1].type, "", stream, 0);
      fputs_filtered ("'(", stream);
      print_subexp (exp, pos, stream, PREC_PREFIX);
      fputs_filtered (")", stream);
      return;

    case UNOP_IN_RANGE:
      *pos += oplen;
      print_subexp (exp, pos, stream, PREC_SUFFIX);
      fputs_filtered (" in ", stream);
      LA_PRINT_TYPE (exp->elts[pc + 1].type, "", stream, 1, 0);
      return;
    }
}
d7943 2
a7944 3
  {".all", UNOP_IND, PREC_SUFFIX, 1},
  {"'access", UNOP_ADDR, PREC_SUFFIX, 1},
  {"'size", OP_ATR_SIZE, PREC_SUFFIX, 1},
d7948 150
a8097 1
				/* Fundamental Ada Types */
d8133 1
a8133 1
         reconstruction work, this should probably become an error.  */
d8135 2
a8136 2
                        TARGET_INT_BIT / TARGET_CHAR_BIT,
                        0, "<?type?>", objfile);
d8141 2
a8142 2
                        TARGET_CHAR_BIT / TARGET_CHAR_BIT,
                        0, "void", objfile);
d8146 2
a8147 2
                        TARGET_CHAR_BIT / TARGET_CHAR_BIT,
                        0, "character", objfile);
d8151 2
a8152 2
                        TARGET_CHAR_BIT / TARGET_CHAR_BIT,
                        0, "signed char", objfile);
d8156 2
a8157 2
                        TARGET_CHAR_BIT / TARGET_CHAR_BIT,
                        TYPE_FLAG_UNSIGNED, "unsigned char", objfile);
d8161 2
a8162 2
                        TARGET_SHORT_BIT / TARGET_CHAR_BIT,
                        0, "short_integer", objfile);
d8166 2
a8167 2
                        TARGET_SHORT_BIT / TARGET_CHAR_BIT,
                        0, "short_integer", objfile);
d8171 2
a8172 2
                        TARGET_SHORT_BIT / TARGET_CHAR_BIT,
                        TYPE_FLAG_UNSIGNED, "unsigned short", objfile);
d8176 2
a8177 2
                        TARGET_INT_BIT / TARGET_CHAR_BIT,
                        0, "integer", objfile);
d8180 1
a8180 3
      type = init_type (TYPE_CODE_INT, TARGET_INT_BIT /
			TARGET_CHAR_BIT, 
			0, "integer", objfile);        /* FIXME -fnf */
d8184 2
a8185 2
                        TARGET_INT_BIT / TARGET_CHAR_BIT,
                        TYPE_FLAG_UNSIGNED, "unsigned int", objfile);
d8189 2
a8190 2
                        TARGET_LONG_BIT / TARGET_CHAR_BIT,
                        0, "long_integer", objfile);
d8194 2
a8195 2
                        TARGET_LONG_BIT / TARGET_CHAR_BIT,
                        0, "long_integer", objfile);
d8199 2
a8200 2
                        TARGET_LONG_BIT / TARGET_CHAR_BIT,
                        TYPE_FLAG_UNSIGNED, "unsigned long", objfile);
d8204 2
a8205 2
                        TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
                        0, "long_long_integer", objfile);
d8209 2
a8210 2
                        TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
                        0, "long_long_integer", objfile);
d8214 2
a8215 2
                        TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
                        TYPE_FLAG_UNSIGNED, "unsigned long long", objfile);
d8219 2
a8220 2
                        TARGET_FLOAT_BIT / TARGET_CHAR_BIT,
                        0, "float", objfile);
d8224 2
a8225 2
                        TARGET_DOUBLE_BIT / TARGET_CHAR_BIT,
                        0, "long_float", objfile);
d8229 2
a8230 2
                        TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT,
                        0, "long_long_float", objfile);
a8235 124
enum ada_primitive_types {
  ada_primitive_type_int,
  ada_primitive_type_long,
  ada_primitive_type_short,
  ada_primitive_type_char,
  ada_primitive_type_float,
  ada_primitive_type_double,
  ada_primitive_type_void,
  ada_primitive_type_long_long,
  ada_primitive_type_long_double,
  ada_primitive_type_natural,
  ada_primitive_type_positive,
  ada_primitive_type_system_address,
  nr_ada_primitive_types
};

static void
ada_language_arch_info (struct gdbarch *current_gdbarch,
			struct language_arch_info *lai)
{
  const struct builtin_type *builtin = builtin_type (current_gdbarch);
  lai->primitive_type_vector
    = GDBARCH_OBSTACK_CALLOC (current_gdbarch, nr_ada_primitive_types + 1,
			      struct type *);
  lai->primitive_type_vector [ada_primitive_type_int] =
    init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
               0, "integer", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_long] =
    init_type (TYPE_CODE_INT, TARGET_LONG_BIT / TARGET_CHAR_BIT,
               0, "long_integer", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_short] =
    init_type (TYPE_CODE_INT, TARGET_SHORT_BIT / TARGET_CHAR_BIT,
               0, "short_integer", (struct objfile *) NULL);
  lai->string_char_type = 
    lai->primitive_type_vector [ada_primitive_type_char] =
    init_type (TYPE_CODE_INT, TARGET_CHAR_BIT / TARGET_CHAR_BIT,
               0, "character", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_float] =
    init_type (TYPE_CODE_FLT, TARGET_FLOAT_BIT / TARGET_CHAR_BIT,
               0, "float", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_double] =
    init_type (TYPE_CODE_FLT, TARGET_DOUBLE_BIT / TARGET_CHAR_BIT,
               0, "long_float", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_long_long] =
    init_type (TYPE_CODE_INT, TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
               0, "long_long_integer", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_long_double] =
    init_type (TYPE_CODE_FLT, TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT,
               0, "long_long_float", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_natural] =
    init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
               0, "natural", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_positive] =
    init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
               0, "positive", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_void] = builtin->builtin_void;

  lai->primitive_type_vector [ada_primitive_type_system_address] =
    lookup_pointer_type (init_type (TYPE_CODE_VOID, 1, 0, "void",
                                    (struct objfile *) NULL));
  TYPE_NAME (lai->primitive_type_vector [ada_primitive_type_system_address])
    = "system__address";
}

				/* Language vector */

/* Not really used, but needed in the ada_language_defn.  */

static void
emit_char (int c, struct ui_file *stream, int quoter)
{
  ada_emit_char (c, stream, quoter, 1);
}

static int
parse (void)
{
  warnings_issued = 0;
  return ada_parse ();
}

static const struct exp_descriptor ada_exp_descriptor = {
  ada_print_subexp,
  ada_operator_length,
  ada_op_name,
  ada_dump_subexp_body,
  ada_evaluate_subexp
};

const struct language_defn ada_language_defn = {
  "ada",                        /* Language name */
  language_ada,
  NULL,
  range_check_off,
  type_check_off,
  case_sensitive_on,            /* Yes, Ada is case-insensitive, but
                                   that's not quite what this means.  */
  array_row_major,
  &ada_exp_descriptor,
  parse,
  ada_error,
  resolve,
  ada_printchar,                /* Print a character constant */
  ada_printstr,                 /* Function to print string constant */
  emit_char,                    /* Function to print single char (not used) */
  ada_create_fundamental_type,  /* Create fundamental type in this language */
  ada_print_type,               /* Print a type using appropriate syntax */
  ada_val_print,                /* Print a value using appropriate syntax */
  ada_value_print,              /* Print a top-level value */
  NULL,                         /* Language specific skip_trampoline */
  NULL,                         /* value_of_this */
  ada_lookup_symbol_nonlocal,   /* Looking up non-local symbols.  */
  basic_lookup_transparent_type,        /* lookup_transparent_type */
  ada_la_decode,                /* Language specific symbol demangler */
  NULL,                         /* Language specific class_name_from_physname */
  ada_op_print_tab,             /* expression operators for printing */
  0,                            /* c-style arrays */
  1,                            /* String lower bound */
  NULL,
  ada_get_gdb_completer_word_break_characters,
  ada_language_arch_info,
  LANG_MAGIC
};

d8237 1
a8237 1
_initialize_ada_language (void)
d8239 15
a8253 9
  add_language (&ada_language_defn);

  varsize_limit = 65536;

  obstack_init (&symbol_list_obstack);

  decoded_names_store = htab_create_alloc
    (256, htab_hash_string, (int (*)(const void *, const void *)) streq,
     NULL, xcalloc, xfree);
@

