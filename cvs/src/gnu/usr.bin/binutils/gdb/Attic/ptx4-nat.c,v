head	1.3;
access;
symbols
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.3
date	2004.05.21.20.23.11;	author kettenis;	state dead;
branches;
next	1.2;

1.2
date	96.11.23.03.38.56;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.19.35;	author niklas;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	96.11.19.14.19.36;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@/* Native-dependent code for ptx 4.0
   Copyright 1988, 1989, 1991, 1992 Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "inferior.h"
#include "gdbcore.h"
#include <sys/procfs.h>
#include <sys/ptrace.h>
#include <sys/param.h>
#include <fcntl.h>

/*  Given a pointer to a general register set in /proc format (gregset_t *),
    unpack the register contents and supply them as gdb's idea of the current
    register values. */

void
supply_gregset (gregsetp)
     gregset_t *gregsetp;
{
	supply_register(EAX_REGNUM, (char *)&(*gregsetp)[EAX]);
	supply_register(EDX_REGNUM, (char *)&(*gregsetp)[EDX]);
	supply_register(ECX_REGNUM, (char *)&(*gregsetp)[ECX]);
	supply_register(EBX_REGNUM, (char *)&(*gregsetp)[EBX]);
	supply_register(ESI_REGNUM, (char *)&(*gregsetp)[ESI]);
	supply_register(EDI_REGNUM, (char *)&(*gregsetp)[EDI]);
	supply_register(ESP_REGNUM, (char *)&(*gregsetp)[UESP]);
	supply_register(EBP_REGNUM, (char *)&(*gregsetp)[EBP]);
	supply_register(EIP_REGNUM, (char *)&(*gregsetp)[EIP]);
	supply_register(EFLAGS_REGNUM, (char *)&(*gregsetp)[EFL]);
}

void
fill_gregset (gregsetp, regno)
     gregset_t *gregsetp;
     int regno;
{
  int regi;
  extern char registers[];

  for (regi = 0 ; regi < NUM_REGS ; regi++)
    {
      if ((regno == -1) || (regno == regi))
	{
	  (*gregsetp)[regi] = *(greg_t *)&registers[REGISTER_BYTE (regi)];
	}
    }
}

#if defined (FP0_REGNUM)

/*  Given a pointer to a floating point register set in /proc format
    (fpregset_t *), unpack the register contents and supply them as gdb's
    idea of the current floating point register values. */

void 
supply_fpregset (fpregsetp)
     fpregset_t *fpregsetp;
{
  supply_fpu_registers((struct fpusave *)&fpregsetp->fp_reg_set);
  supply_fpa_registers((struct fpasave *)&fpregsetp->f_wregs);
}

/*  Given a pointer to a floating point register set in /proc format
    (fpregset_t *), update the register specified by REGNO from gdb's idea
    of the current floating point register set.  If REGNO is -1, update
    them all. */

void
fill_fpregset (fpregsetp, regno)
     fpregset_t *fpregsetp;
     int regno;
{
  int regi;
  char *to;
  char *from;
  extern char registers[];

  /* FIXME: see m68k-tdep.c for an example, for the m68k. */
}

#endif	/* defined (FP0_REGNUM) */

/*
 * This doesn't quite do the same thing as the procfs.c version, but give
 * it the same name so we don't have to put an ifdef in solib.c.
 */
/* this could use elf_interpreter() from elfread.c */
int
proc_iterate_over_mappings(func)
	int (*func) PARAMS ((int, CORE_ADDR));
{
	vaddr_t curseg, memptr;
	pt_vseg_t pv;
	int rv, cmperr;
	sec_ptr interp_sec;
	char *interp_content;
	int interp_fd, funcstat;
	unsigned int size;
	char buf1[NBPG], buf2[NBPG];

	/*
	 * The following is really vile.  We can get the name of the
	 * shared library from the exec_bfd, and we can get a list of
	 * each virtual memory segment, but there is no simple way to
	 * find the mapped segment from the shared library (ala
	 * procfs's PIOCOPENMEM).  As a pretty nasty kludge, we
	 * compare the virtual memory segment to the contents of the
	 * .interp file.  If they match, we assume that we've got the
	 * right one.
	 */

	/*
	 * TODO: for attach, use XPT_OPENT to get the executable, in
	 * case we're attached without knowning the executable's
	 * filename.
	 */

#ifdef VERBOSE_DEBUG
	printf("proc_iter\n");
#endif
	interp_sec = bfd_get_section_by_name(exec_bfd, ".interp");
	if (!interp_sec) {
		return 0;
	}

	size = bfd_section_size(exec_bfd, interp_sec);
	interp_content = alloca(size);
	if (0 == bfd_get_section_contents(exec_bfd, interp_sec,
		interp_content, (file_ptr)0, size)) {
		return 0;
	}

#ifdef VERBOSE_DEBUG
	printf("proc_iter: \"%s\"\n", interp_content);
#endif
	interp_fd = open(interp_content, O_RDONLY, 0);
	if (-1 == interp_fd) {
		return 0;
	}

	curseg = 0;
	while (1) {
		rv = ptrace(PT_NEXT_VSEG, inferior_pid, &pv, curseg);
#ifdef VERBOSE_DEBUG
		printf("PT_NEXT_VSEG: rv %d errno %d\n", rv, errno);
#endif
		if (-1 == rv)
			break;
		if (0 == rv)
			break;
#ifdef VERBOSE_DEBUG
		printf("pv.pv_start 0x%x pv_size 0x%x pv_prot 0x%x\n",
		       pv.pv_start, pv.pv_size, pv.pv_prot);
#endif
		curseg = pv.pv_start + pv.pv_size;

		rv = lseek(interp_fd, 0, SEEK_SET);
		if (-1 == rv) {
			perror("lseek");
			close(interp_fd);
			return 0;
		}
		for (memptr = pv.pv_start; memptr < pv.pv_start + pv.pv_size;
		     memptr += NBPG) {
#ifdef VERBOSE_DEBUG
			printf("memptr 0x%x\n", memptr);
#endif
			rv = read(interp_fd, buf1, NBPG);
			if (-1 == rv) {
				perror("read");
				close(interp_fd);
				return 0;
			}
			rv = ptrace(PT_RDATA_PAGE, inferior_pid, buf2,
				    memptr);
			if (-1 == rv) {
				perror("ptrace");
				close(interp_fd);
				return 0;
			}
			cmperr = memcmp(buf1, buf2, NBPG);
			if (cmperr)
				break;
		}
		if (0 == cmperr) {
			/* this is it */
			funcstat = (*func)(interp_fd, pv.pv_start);
			break;
		}
	}
	close(interp_fd);
	return 0;
}
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@@


1.1
log
@file ptx4-nat.c was initially added on branch CYGNUS.
@
text
@d1 209
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 209
/* Native-dependent code for ptx 4.0
   Copyright 1988, 1989, 1991, 1992 Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "inferior.h"
#include "gdbcore.h"
#include <sys/procfs.h>
#include <sys/ptrace.h>
#include <sys/param.h>
#include <fcntl.h>

/*  Given a pointer to a general register set in /proc format (gregset_t *),
    unpack the register contents and supply them as gdb's idea of the current
    register values. */

void
supply_gregset (gregsetp)
     gregset_t *gregsetp;
{
	supply_register(EAX_REGNUM, (char *)&(*gregsetp)[EAX]);
	supply_register(EDX_REGNUM, (char *)&(*gregsetp)[EDX]);
	supply_register(ECX_REGNUM, (char *)&(*gregsetp)[ECX]);
	supply_register(EBX_REGNUM, (char *)&(*gregsetp)[EBX]);
	supply_register(ESI_REGNUM, (char *)&(*gregsetp)[ESI]);
	supply_register(EDI_REGNUM, (char *)&(*gregsetp)[EDI]);
	supply_register(ESP_REGNUM, (char *)&(*gregsetp)[UESP]);
	supply_register(EBP_REGNUM, (char *)&(*gregsetp)[EBP]);
	supply_register(EIP_REGNUM, (char *)&(*gregsetp)[EIP]);
	supply_register(EFLAGS_REGNUM, (char *)&(*gregsetp)[EFL]);
}

void
fill_gregset (gregsetp, regno)
     gregset_t *gregsetp;
     int regno;
{
  int regi;
  extern char registers[];

  for (regi = 0 ; regi < NUM_REGS ; regi++)
    {
      if ((regno == -1) || (regno == regi))
	{
	  (*gregsetp)[regi] = *(greg_t *)&registers[REGISTER_BYTE (regi)];
	}
    }
}

#if defined (FP0_REGNUM)

/*  Given a pointer to a floating point register set in /proc format
    (fpregset_t *), unpack the register contents and supply them as gdb's
    idea of the current floating point register values. */

void 
supply_fpregset (fpregsetp)
     fpregset_t *fpregsetp;
{
  supply_fpu_registers((struct fpusave *)&fpregsetp->fp_reg_set);
  supply_fpa_registers((struct fpasave *)&fpregsetp->f_wregs);
}

/*  Given a pointer to a floating point register set in /proc format
    (fpregset_t *), update the register specified by REGNO from gdb's idea
    of the current floating point register set.  If REGNO is -1, update
    them all. */

void
fill_fpregset (fpregsetp, regno)
     fpregset_t *fpregsetp;
     int regno;
{
  int regi;
  char *to;
  char *from;
  extern char registers[];

  /* FIXME: see m68k-tdep.c for an example, for the m68k. */
}

#endif	/* defined (FP0_REGNUM) */

/*
 * This doesn't quite do the same thing as the procfs.c version, but give
 * it the same name so we don't have to put an ifdef in solib.c.
 */
/* this could use elf_interpreter() from elfread.c */
int
proc_iterate_over_mappings(func)
	int (*func) PARAMS ((int, CORE_ADDR));
{
	vaddr_t curseg, memptr;
	pt_vseg_t pv;
	int rv, cmperr;
	sec_ptr interp_sec;
	char *interp_content;
	int interp_fd, funcstat;
	unsigned int size;
	char buf1[NBPG], buf2[NBPG];

	/*
	 * The following is really vile.  We can get the name of the
	 * shared library from the exec_bfd, and we can get a list of
	 * each virtual memory segment, but there is no simple way to
	 * find the mapped segment from the shared library (ala
	 * procfs's PIOCOPENMEM).  As a pretty nasty kludge, we
	 * compare the virtual memory segment to the contents of the
	 * .interp file.  If they match, we assume that we've got the
	 * right one.
	 */

	/*
	 * TODO: for attach, use XPT_OPENT to get the executable, in
	 * case we're attached without knowning the executable's
	 * filename.
	 */

#ifdef VERBOSE_DEBUG
	printf("proc_iter\n");
#endif
	interp_sec = bfd_get_section_by_name(exec_bfd, ".interp");
	if (!interp_sec) {
		return 0;
	}

	size = bfd_section_size(exec_bfd, interp_sec);
	interp_content = alloca(size);
	if (0 == bfd_get_section_contents(exec_bfd, interp_sec,
		interp_content, (file_ptr)0, size)) {
		return 0;
	}

#ifdef VERBOSE_DEBUG
	printf("proc_iter: \"%s\"\n", interp_content);
#endif
	interp_fd = open(interp_content, O_RDONLY, 0);
	if (-1 == interp_fd) {
		return 0;
	}

	curseg = 0;
	while (1) {
		rv = ptrace(PT_NEXT_VSEG, inferior_pid, &pv, curseg);
#ifdef VERBOSE_DEBUG
		printf("PT_NEXT_VSEG: rv %d errno %d\n", rv, errno);
#endif
		if (-1 == rv)
			break;
		if (0 == rv)
			break;
#ifdef VERBOSE_DEBUG
		printf("pv.pv_start 0x%x pv_size 0x%x pv_prot 0x%x\n",
		       pv.pv_start, pv.pv_size, pv.pv_prot);
#endif
		curseg = pv.pv_start + pv.pv_size;

		rv = lseek(interp_fd, 0, SEEK_SET);
		if (-1 == rv) {
			perror("lseek");
			close(interp_fd);
			return 0;
		}
		for (memptr = pv.pv_start; memptr < pv.pv_start + pv.pv_size;
		     memptr += NBPG) {
#ifdef VERBOSE_DEBUG
			printf("memptr 0x%x\n", memptr);
#endif
			rv = read(interp_fd, buf1, NBPG);
			if (-1 == rv) {
				perror("read");
				close(interp_fd);
				return 0;
			}
			rv = ptrace(PT_RDATA_PAGE, inferior_pid, buf2,
				    memptr);
			if (-1 == rv) {
				perror("ptrace");
				close(interp_fd);
				return 0;
			}
			cmperr = memcmp(buf1, buf2, NBPG);
			if (cmperr)
				break;
		}
		if (0 == cmperr) {
			/* this is it */
			funcstat = (*func)(interp_fd, pv.pv_start);
			break;
		}
	}
	close(interp_fd);
	return 0;
}
@
