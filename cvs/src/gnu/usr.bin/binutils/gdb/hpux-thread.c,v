head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.50
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.52
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.48
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.44
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.46
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.38
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.42
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.40
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.36
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.34
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.32
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.30
	OPENBSD_5_0:1.4.0.28
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.26
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.24
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2004.12.27.14.00.36;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.21.20.23.08;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.37.55;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.18.18;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.11.04;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.08.53;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.18.18;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@/* Low level interface for debugging HPUX/DCE threads for GDB, the GNU
   debugger.

   Copyright 1996, 1998, 1999, 2000, 2001, 2004 Free Software
   Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* This module implements a sort of half target that sits between the
   machine-independent parts of GDB and the ptrace interface (infptrace.c) to
   provide access to the HPUX user-mode thread implementation.

   HPUX threads are true user-mode threads, which are invoked via the cma_*
   and pthread_* (DCE and Posix respectivly) interfaces.  These are mostly
   implemented in user-space, with all thread context kept in various
   structures that live in the user's heap.  For the most part, the kernel has
   no knowlege of these threads.

 */

#include "defs.h"

#define _CMA_NOWRAPPERS_

#include <cma_tcb_defs.h>
#include <cma_deb_core.h>
#include "gdbthread.h"
#include "target.h"
#include "inferior.h"
#include "regcache.h"
#include <fcntl.h>
#include "gdb_stat.h"
#include "gdbcore.h"

extern int child_suppress_run;

extern void _initialize_hpux_thread (void);

struct string_map
  {
    int num;
    char *str;
  };

static int hpux_thread_active = 0;

static ptid_t main_ptid;		/* Real process ID */

static CORE_ADDR P_cma__g_known_threads;
static CORE_ADDR P_cma__g_current_thread;

static void hpux_thread_resume (ptid_t ptid, int step,
                                enum target_signal signo);

static void init_hpux_thread_ops (void);

static struct target_ops hpux_thread_ops;

static ptid_t find_active_thread (void);

static int cached_thread;
static cma__t_int_tcb cached_tcb;

static ptid_t
find_active_thread (void)
{
  static cma__t_int_tcb tcb;
  CORE_ADDR tcb_ptr;

  read_memory ((CORE_ADDR) P_cma__g_current_thread,
	       (char *) &tcb_ptr,
	       sizeof tcb_ptr);

  read_memory (tcb_ptr, (char *) &tcb, sizeof tcb);

  return (ptid_build (PIDGET (main_ptid), 0,
                      cma_thread_get_unique (&tcb.prolog.client_thread)));
}

static cma__t_int_tcb *find_tcb (ptid_t ptid);

static cma__t_int_tcb *
find_tcb (ptid_t ptid)
{
  cma__t_known_object queue_header;
  cma__t_queue *queue_ptr;
  int thread = ptid_get_tid (ptid);

  if (thread == cached_thread)
    return &cached_tcb;

  read_memory ((CORE_ADDR) P_cma__g_known_threads,
	       (char *) &queue_header,
	       sizeof queue_header);

  for (queue_ptr = queue_header.queue.flink;
       queue_ptr != (cma__t_queue *) P_cma__g_known_threads;
       queue_ptr = cached_tcb.threads.flink)
    {
      cma__t_int_tcb *tcb_ptr;

      tcb_ptr = cma__base (queue_ptr, threads, cma__t_int_tcb);

      read_memory ((CORE_ADDR) tcb_ptr, (char *) &cached_tcb, sizeof cached_tcb);

      if (cached_tcb.header.type == cma__c_obj_tcb)
	if (cma_thread_get_unique (&cached_tcb.prolog.client_thread) == thread)
	  {
	    cached_thread = thread;
	    return &cached_tcb;
	  }
    }

  error ("Can't find TCB %d", thread);
  return NULL;
}

/* Most target vector functions from here on actually just pass through to
   inftarg.c, as they don't need to do anything specific for threads.  */

static void
hpux_thread_open (char *arg, int from_tty)
{
  deprecated_child_ops.to_open (arg, from_tty);
}

/* Attach to process PID, then initialize for debugging it
   and wait for the trace-trap that results from attaching.  */

static void
hpux_thread_attach (char *args, int from_tty)
{
  deprecated_child_ops.to_attach (args, from_tty);

  /* XXX - might want to iterate over all the threads and register them. */
}

/* Take a program previously attached to and detaches it.
   The program resumes execution and will no longer stop
   on signals, etc.  We'd better not have left any breakpoints
   in the program or it'll die when it hits one.  For this
   to work, it may be necessary for the process to have been
   previously attached.  It *might* work if the program was
   started via the normal ptrace (PTRACE_TRACEME).  */

static void
hpux_thread_detach (char *args, int from_tty)
{
  deprecated_child_ops.to_detach (args, from_tty);
}

/* Resume execution of process PID.  If STEP is nozero, then
   just single step it.  If SIGNAL is nonzero, restart it with that
   signal activated.  We may have to convert pid from a thread-id to an LWP id
   for procfs.  */

static void
hpux_thread_resume (ptid_t ptid, int step, enum target_signal signo)
{
  struct cleanup *old_chain;

  old_chain = save_inferior_ptid ();

  ptid = main_ptid;
  inferior_ptid = main_ptid;

#if 0
  if (pid != -1)
    {
      pid = thread_to_lwp (pid, -2);
      if (pid == -2)		/* Inactive thread */
	error ("This version of Solaris can't start inactive threads.");
    }
#endif

  deprecated_child_ops.to_resume (ptid, step, signo);

  cached_thread = 0;

  do_cleanups (old_chain);
}

/* Wait for any threads to stop.  We may have to convert PID from a thread id
   to a LWP id, and vice versa on the way out.  */

static ptid_t
hpux_thread_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
{
  ptid_t rtnval;
  struct cleanup *old_chain;

  old_chain = save_inferior_ptid ();

  inferior_ptid = main_ptid;

  if (!ptid_equal (ptid, minus_one_ptid))
    ptid = main_ptid;

  rtnval = deprecated_child_ops.to_wait (ptid, ourstatus);

  rtnval = find_active_thread ();

  do_cleanups (old_chain);

  return rtnval;
}

static char regmap[NUM_REGS] =
{
  -2, -1, -1, 0, 4, 8, 12, 16, 20, 24,	/* flags, r1 -> r9 */
  28, 32, 36, 40, 44, 48, 52, 56, 60, -1,	/* r10 -> r19 */
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,	/* r20 -> r29 */

  /* r30, r31, sar, pcoqh, pcsqh, pcoqt, pcsqt, eiem, iir, isr */
  -2, -1, -1, -2, -1, -1, -1, -1, -1, -1,

  /* ior, ipsw, goto, sr4, sr0, sr1, sr2, sr3, sr5, sr6 */
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,

  /* sr7, cr0, cr8, cr9, ccr, cr12, cr13, cr24, cr25, cr26 */
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,

  -1, -1, -1, -1,		/* mpsfu_high, mpsfu_low, mpsfu_ovflo, pad */
  144, -1, -1, -1, -1, -1, -1, -1,	/* fpsr, fpe1 -> fpe7 */
  -1, -1, -1, -1, -1, -1, -1, -1,	/* fr4 -> fr7 */
  -1, -1, -1, -1, -1, -1, -1, -1,	/* fr8 -> fr11 */
  136, -1, 128, -1, 120, -1, 112, -1,	/* fr12 -> fr15 */
  104, -1, 96, -1, 88, -1, 80, -1,	/* fr16 -> fr19 */
  72, -1, 64, -1, -1, -1, -1, -1,	/* fr20 -> fr23 */
  -1, -1, -1, -1, -1, -1, -1, -1,	/* fr24 -> fr27 */
  -1, -1, -1, -1, -1, -1, -1, -1,	/* fr28 -> fr31 */
};

static void
hpux_thread_fetch_registers (int regno)
{
  cma__t_int_tcb tcb, *tcb_ptr;
  struct cleanup *old_chain;
  int i;
  int first_regno, last_regno;

  tcb_ptr = find_tcb (inferior_ptid);

  old_chain = save_inferior_ptid ();

  inferior_ptid = main_ptid;

  if (tcb_ptr->state == cma__c_state_running)
    {
      deprecated_child_ops.to_fetch_registers (regno);

      do_cleanups (old_chain);

      return;
    }

  if (regno == -1)
    {
      first_regno = 0;
      last_regno = NUM_REGS - 1;
    }
  else
    {
      first_regno = regno;
      last_regno = regno;
    }

  for (regno = first_regno; regno <= last_regno; regno++)
    {
      if (regmap[regno] == -1)
	deprecated_child_ops.to_fetch_registers (regno);
      else
	{
	  unsigned char buf[MAX_REGISTER_SIZE];
	  CORE_ADDR sp;

	  sp = (CORE_ADDR) tcb_ptr->static_ctx.sp - 160;

	  if (regno == FLAGS_REGNUM)
	    /* Flags must be 0 to avoid bogus value for SS_INSYSCALL */
	    memset (buf, '\000', register_size (current_gdbarch, regno));
	  else if (regno == SP_REGNUM)
	    store_unsigned_integer (buf, sizeof sp, sp);
	  else if (regno == PC_REGNUM)
	    read_memory (sp - 20, buf, register_size (current_gdbarch, regno));
	  else
	    read_memory (sp + regmap[regno], buf, register_size (current_gdbarch, regno));

	  regcache_raw_supply (current_regcache, regno, buf);
	}
    }

  do_cleanups (old_chain);
}

static void
hpux_thread_store_registers (int regno)
{
  cma__t_int_tcb tcb, *tcb_ptr;
  struct cleanup *old_chain;
  int i;
  int first_regno, last_regno;

  tcb_ptr = find_tcb (inferior_ptid);

  old_chain = save_inferior_ptid ();

  inferior_ptid = main_ptid;

  if (tcb_ptr->state == cma__c_state_running)
    {
      deprecated_child_ops.to_store_registers (regno);

      do_cleanups (old_chain);

      return;
    }

  if (regno == -1)
    {
      first_regno = 0;
      last_regno = NUM_REGS - 1;
    }
  else
    {
      first_regno = regno;
      last_regno = regno;
    }

  for (regno = first_regno; regno <= last_regno; regno++)
    {
      if (regmap[regno] == -1)
	deprecated_child_ops.to_store_registers (regno);
      else
	{
	  unsigned char buf[MAX_REGISTER_SIZE];
	  CORE_ADDR sp;

	  sp = (CORE_ADDR) tcb_ptr->static_ctx.sp - 160;

	  if (regno == FLAGS_REGNUM)
	    deprecated_child_ops.to_store_registers (regno);	/* Let lower layer handle this... */
	  else if (regno == SP_REGNUM)
	    {
	      write_memory ((CORE_ADDR) & tcb_ptr->static_ctx.sp,
			    &deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)],
			    register_size (current_gdbarch, regno));
	      tcb_ptr->static_ctx.sp = (cma__t_hppa_regs *)
		(extract_unsigned_integer (&deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)],
					   register_size (current_gdbarch, regno)) + 160);
	    }
	  else if (regno == PC_REGNUM)
	    write_memory (sp - 20,
			  &deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)],
			  register_size (current_gdbarch, regno));
	  else
	    write_memory (sp + regmap[regno],
			  &deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)],
			  register_size (current_gdbarch, regno));
	}
    }

  do_cleanups (old_chain);
}

/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On machines
   which store all the registers in one fell swoop, this makes sure
   that registers contains all the registers from the program being
   debugged.  */

static void
hpux_thread_prepare_to_store (void)
{
  deprecated_child_ops.to_prepare_to_store ();
}

static int
hpux_thread_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len,
			 int dowrite, struct mem_attrib *attribs,
			 struct target_ops *target)
{
  int retval;
  struct cleanup *old_chain;

  old_chain = save_inferior_ptid ();

  inferior_ptid = main_ptid;

  retval = 
    deprecated_child_ops.deprecated_xfer_memory (memaddr, myaddr, len, dowrite, attribs, target);

  do_cleanups (old_chain);

  return retval;
}

/* Print status information about what we're accessing.  */

static void
hpux_thread_files_info (struct target_ops *ignore)
{
  deprecated_child_ops.to_files_info (ignore);
}

static void
hpux_thread_kill_inferior (void)
{
  deprecated_child_ops.to_kill ();
}

static void
hpux_thread_notice_signals (ptid_t ptid)
{
  deprecated_child_ops.to_notice_signals (ptid);
}

/* Fork an inferior process, and start debugging it with /proc.  */

static void
hpux_thread_create_inferior (char *exec_file, char *allargs, char **env,
			     int from_tty)
{
  deprecated_child_ops.to_create_inferior (exec_file, allargs, env, from_tty);

  if (hpux_thread_active)
    {
      main_ptid = inferior_ptid;

      push_target (&hpux_thread_ops);

      inferior_ptid = find_active_thread ();

      add_thread (inferior_ptid);
    }
}

/* This routine is called whenever a new symbol table is read in, or when all
   symbol tables are removed.  libthread_db can only be initialized when it
   finds the right variables in libthread.so.  Since it's a shared library,
   those variables don't show up until the library gets mapped and the symbol
   table is read in.  */

/* This new_objfile event is now managed by a chained function pointer. 
 * It is the callee's responsability to call the next client on the chain.
 */

/* Saved pointer to previous owner of the new_objfile event. */
static void (*target_new_objfile_chain) (struct objfile *);

void
hpux_thread_new_objfile (struct objfile *objfile)
{
  struct minimal_symbol *ms;

  if (!objfile)
    {
      hpux_thread_active = 0;
      goto quit;
    }

  ms = lookup_minimal_symbol ("cma__g_known_threads", NULL, objfile);

  if (!ms)
    goto quit;

  P_cma__g_known_threads = SYMBOL_VALUE_ADDRESS (ms);

  ms = lookup_minimal_symbol ("cma__g_current_thread", NULL, objfile);

  if (!ms)
    goto quit;

  P_cma__g_current_thread = SYMBOL_VALUE_ADDRESS (ms);

  hpux_thread_active = 1;
quit:
  /* Call predecessor on chain, if any. */
  if (target_new_objfile_chain)
    target_new_objfile_chain (objfile);
}

/* Clean up after the inferior dies.  */

static void
hpux_thread_mourn_inferior (void)
{
  deprecated_child_ops.to_mourn_inferior ();
}

/* Mark our target-struct as eligible for stray "run" and "attach" commands.  */

static int
hpux_thread_can_run (void)
{
  return child_suppress_run;
}

static int
hpux_thread_alive (ptid_t ptid)
{
  return 1;
}

static void
hpux_thread_stop (void)
{
  deprecated_child_ops.to_stop ();
}

/* Convert a pid to printable form. */

char *
hpux_pid_to_str (ptid_t ptid)
{
  static char buf[100];
  int pid = PIDGET (ptid);

  sprintf (buf, "Thread %ld", ptid_get_tid (ptid));

  return buf;
}

static void
init_hpux_thread_ops (void)
{
  hpux_thread_ops.to_shortname = "hpux-threads";
  hpux_thread_ops.to_longname = "HPUX threads and pthread.";
  hpux_thread_ops.to_doc = "HPUX threads and pthread support.";
  hpux_thread_ops.to_open = hpux_thread_open;
  hpux_thread_ops.to_attach = hpux_thread_attach;
  hpux_thread_ops.to_detach = hpux_thread_detach;
  hpux_thread_ops.to_resume = hpux_thread_resume;
  hpux_thread_ops.to_wait = hpux_thread_wait;
  hpux_thread_ops.to_fetch_registers = hpux_thread_fetch_registers;
  hpux_thread_ops.to_store_registers = hpux_thread_store_registers;
  hpux_thread_ops.to_prepare_to_store = hpux_thread_prepare_to_store;
  hpux_thread_ops.deprecated_xfer_memory = hpux_thread_xfer_memory;
  hpux_thread_ops.to_files_info = hpux_thread_files_info;
  hpux_thread_ops.to_insert_breakpoint = memory_insert_breakpoint;
  hpux_thread_ops.to_remove_breakpoint = memory_remove_breakpoint;
  hpux_thread_ops.to_terminal_init = terminal_init_inferior;
  hpux_thread_ops.to_terminal_inferior = terminal_inferior;
  hpux_thread_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  hpux_thread_ops.to_terminal_save_ours = terminal_save_ours;
  hpux_thread_ops.to_terminal_ours = terminal_ours;
  hpux_thread_ops.to_terminal_info = child_terminal_info;
  hpux_thread_ops.to_kill = hpux_thread_kill_inferior;
  hpux_thread_ops.to_create_inferior = hpux_thread_create_inferior;
  hpux_thread_ops.to_mourn_inferior = hpux_thread_mourn_inferior;
  hpux_thread_ops.to_can_run = hpux_thread_can_run;
  hpux_thread_ops.to_notice_signals = hpux_thread_notice_signals;
  hpux_thread_ops.to_thread_alive = hpux_thread_alive;
  hpux_thread_ops.to_stop = hpux_thread_stop;
  hpux_thread_ops.to_stratum = process_stratum;
  hpux_thread_ops.to_has_all_memory = 1;
  hpux_thread_ops.to_has_memory = 1;
  hpux_thread_ops.to_has_stack = 1;
  hpux_thread_ops.to_has_registers = 1;
  hpux_thread_ops.to_has_execution = 1;
  hpux_thread_ops.to_magic = OPS_MAGIC;
}

void
_initialize_hpux_thread (void)
{
  init_hpux_thread_ops ();
  add_target (&hpux_thread_ops);

  child_suppress_run = 1;
  /* Hook into new_objfile notification. */
  target_new_objfile_chain = deprecated_target_new_objfile_hook;
  deprecated_target_new_objfile_hook  = hpux_thread_new_objfile;
}
@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@d1 5
a5 2
/* Low level interface for debugging HPUX/DCE threads for GDB, the GNU debugger.
   Copyright 1996, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
a50 1
extern struct target_ops child_ops;	/* target vector for inftarg.c */
d139 1
a139 1
  child_ops.to_open (arg, from_tty);
d148 1
a148 1
  child_ops.to_attach (args, from_tty);
d164 1
a164 1
  child_ops.to_detach (args, from_tty);
d191 1
a191 1
  child_ops.to_resume (ptid, step, signo);
d214 1
a214 1
  rtnval = child_ops.to_wait (ptid, ourstatus);
d265 1
a265 1
      child_ops.to_fetch_registers (regno);
d286 1
a286 1
	child_ops.to_fetch_registers (regno);
d296 1
a296 1
	    memset (buf, '\000', DEPRECATED_REGISTER_RAW_SIZE (regno));
d300 1
a300 1
	    read_memory (sp - 20, buf, DEPRECATED_REGISTER_RAW_SIZE (regno));
d302 1
a302 1
	    read_memory (sp + regmap[regno], buf, DEPRECATED_REGISTER_RAW_SIZE (regno));
d304 1
a304 1
	  supply_register (regno, buf);
d327 1
a327 1
      child_ops.to_store_registers (regno);
d348 1
a348 1
	child_ops.to_store_registers (regno);
d357 1
a357 1
	    child_ops.to_store_registers (regno);	/* Let lower layer handle this... */
d362 1
a362 1
			    DEPRECATED_REGISTER_RAW_SIZE (regno));
d365 1
a365 1
					   DEPRECATED_REGISTER_RAW_SIZE (regno)) + 160);
d370 1
a370 1
			  DEPRECATED_REGISTER_RAW_SIZE (regno));
d374 1
a374 1
			  DEPRECATED_REGISTER_RAW_SIZE (regno));
d390 1
a390 1
  child_ops.to_prepare_to_store ();
d406 1
a406 1
    child_ops.to_xfer_memory (memaddr, myaddr, len, dowrite, attribs, target);
d418 1
a418 1
  child_ops.to_files_info (ignore);
d424 1
a424 1
  child_ops.to_kill ();
d430 1
a430 1
  child_ops.to_notice_signals (ptid);
d436 2
a437 1
hpux_thread_create_inferior (char *exec_file, char *allargs, char **env)
d439 1
a439 1
  child_ops.to_create_inferior (exec_file, allargs, env);
d503 1
a503 1
  child_ops.to_mourn_inferior ();
d523 1
a523 1
  child_ops.to_stop ();
d553 1
a553 1
  hpux_thread_ops.to_xfer_memory = hpux_thread_xfer_memory;
d587 2
a588 2
  target_new_objfile_chain = target_new_objfile_hook;
  target_new_objfile_hook  = hpux_thread_new_objfile;
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 1
a2 1
   Copyright 1996 Free Software Foundation, Inc.
d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 1
a31 1
   */
d42 1
d44 1
a44 2
#include <unistd.h>
#include <sys/stat.h>
d47 2
a48 1
extern struct target_ops hpux_thread_ops; /* Forward declaration */
d50 1
a50 2
extern int child_suppress_run;
extern struct target_ops child_ops; /* target vector for inftarg.c */
d53 4
a56 4
{
  int num;
  char *str;
};
d60 1
a60 1
static int main_pid;		/* Real process ID */
d65 2
a66 13
static struct cleanup * save_inferior_pid PARAMS ((void));
static void restore_inferior_pid PARAMS ((int pid));
static void hpux_thread_resume PARAMS ((int pid, int step,
					enum target_signal signo));

/*

LOCAL FUNCTION

	save_inferior_pid - Save inferior_pid on the cleanup list
	restore_inferior_pid - Restore inferior_pid from the cleanup list

SYNOPSIS
d68 1
a68 2
	struct cleanup *save_inferior_pid ()
	void restore_inferior_pid (int pid)
d70 1
a70 28
DESCRIPTION

	These two functions act in unison to restore inferior_pid in
	case of an error.

NOTES

	inferior_pid is a global variable that needs to be changed by many of
	these routines before calling functions in procfs.c.  In order to
	guarantee that inferior_pid gets restored (in case of errors), you
	need to call save_inferior_pid before changing it.  At the end of the
	function, you should invoke do_cleanups to restore it.

 */


static struct cleanup *
save_inferior_pid ()
{
  return make_cleanup (restore_inferior_pid, inferior_pid);
}

static void
restore_inferior_pid (pid)
     int pid;
{
  inferior_pid = pid;
}
d72 1
a72 1
static int find_active_thread PARAMS ((void));
a74 1
static int cached_active_thread;
d77 2
a78 2
static int
find_active_thread ()
d83 2
a84 5
  if (cached_active_thread != 0)
    return cached_active_thread;

  read_memory ((CORE_ADDR)P_cma__g_current_thread,
	       (char *)&tcb_ptr,
d87 1
a87 1
  read_memory (tcb_ptr, (char *)&tcb, sizeof tcb);
d89 2
a90 1
  return (cma_thread_get_unique (&tcb.prolog.client_thread) << 16) | main_pid;
d93 1
a93 1
static cma__t_int_tcb * find_tcb PARAMS ((int thread));
d96 1
a96 2
find_tcb (thread)
     int thread;
d100 1
d105 2
a106 2
  read_memory ((CORE_ADDR)P_cma__g_known_threads,
	       (char *)&queue_header,
d110 1
a110 1
       queue_ptr != (cma__t_queue *)P_cma__g_known_threads;
d117 1
a117 1
      read_memory ((CORE_ADDR)tcb_ptr, (char *)&cached_tcb, sizeof cached_tcb);
d120 1
a120 1
	if (cma_thread_get_unique (&cached_tcb.prolog.client_thread) == thread >> 16)
d127 1
a127 1
  error ("Can't find TCB %d,%d", thread >> 16, thread & 0xffff);
a133 1
/* ARGSUSED */
d135 1
a135 3
hpux_thread_open (arg, from_tty)
     char *arg;
     int from_tty;
d144 1
a144 3
hpux_thread_attach (args, from_tty)
     char *args;
     int from_tty;
d160 1
a160 3
hpux_thread_detach (args, from_tty)
     char *args;
     int from_tty;
d171 1
a171 4
hpux_thread_resume (pid, step, signo)
     int pid;
     int step;
     enum target_signal signo;
d175 1
a175 1
  old_chain = save_inferior_pid ();
d177 2
a178 1
  pid = inferior_pid = main_pid;
d189 1
a189 1
  child_ops.to_resume (pid, step, signo);
a191 1
  cached_active_thread = 0;
d199 2
a200 4
static int
hpux_thread_wait (pid, ourstatus)
     int pid;
     struct target_waitstatus *ourstatus;
d202 1
a202 1
  int rtnval;
d205 1
a205 1
  old_chain = save_inferior_pid ();
d207 1
a207 1
  inferior_pid = main_pid;
d209 2
a210 2
  if (pid != -1)
    pid = main_pid;
d212 1
a212 1
  rtnval = child_ops.to_wait (pid, ourstatus);
d223 3
a225 3
  -2, -1, -1, 0, 4, 8, 12, 16, 20, 24, /* flags, r1 -> r9 */
  28, 32, 36, 40, 44, 48, 52, 56, 60, -1, /* r10 -> r19 */
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* r20 -> r29 */
d237 8
a244 8
  144, -1, -1, -1, -1, -1, -1, -1, /* fpsr, fpe1 -> fpe7 */
  -1, -1, -1, -1, -1, -1, -1, -1, /* fr4 -> fr7 */
  -1, -1, -1, -1, -1, -1, -1, -1, /* fr8 -> fr11 */
  136, -1, 128, -1, 120, -1, 112, -1, /* fr12 -> fr15 */
  104, -1, 96, -1, 88, -1, 80, -1, /* fr16 -> fr19 */
  72, -1, 64, -1, -1, -1, -1, -1, /* fr20 -> fr23 */
  -1, -1, -1, -1, -1, -1, -1, -1, /* fr24 -> fr27 */
  -1, -1, -1, -1, -1, -1, -1, -1, /* fr28 -> fr31 */
d248 1
a248 2
hpux_thread_fetch_registers (regno)
     int regno;
d255 1
a255 1
  tcb_ptr = find_tcb (inferior_pid);
d257 1
a257 1
  old_chain = save_inferior_pid ();
d259 1
a259 1
  inferior_pid = main_pid;
d287 1
a287 1
	  unsigned char buf[MAX_REGISTER_RAW_SIZE];
d290 1
a290 1
	  sp = (CORE_ADDR)tcb_ptr->static_ctx.sp - 160;
d294 1
a294 1
	    memset (buf, '\000', REGISTER_RAW_SIZE (regno));
d296 1
a296 1
	    store_address (buf, sizeof sp, sp);
d298 1
a298 1
	    read_memory (sp - 20, buf, REGISTER_RAW_SIZE (regno));
d300 1
a300 1
	    read_memory (sp + regmap[regno], buf, REGISTER_RAW_SIZE (regno));
d310 1
a310 2
hpux_thread_store_registers (regno)
     int regno;
d317 1
a317 1
  tcb_ptr = find_tcb (inferior_pid);
d319 1
a319 1
  old_chain = save_inferior_pid ();
d321 1
a321 1
  inferior_pid = main_pid;
d349 1
a349 1
	  unsigned char buf[MAX_REGISTER_RAW_SIZE];
d352 1
a352 1
	  sp = (CORE_ADDR)tcb_ptr->static_ctx.sp - 160;
d355 1
a355 1
	    child_ops.to_store_registers (regno); /* Let lower layer handle this... */
d358 3
a360 3
	      write_memory ((CORE_ADDR)&tcb_ptr->static_ctx.sp,
			    registers + REGISTER_BYTE (regno),
			    REGISTER_RAW_SIZE (regno));
d362 2
a363 1
		(extract_address (registers + REGISTER_BYTE (regno), REGISTER_RAW_SIZE (regno)) + 160);
d367 2
a368 2
			  registers + REGISTER_BYTE (regno),
			  REGISTER_RAW_SIZE (regno));
d371 2
a372 2
			  registers + REGISTER_BYTE (regno),
			  REGISTER_RAW_SIZE (regno));
d386 1
a386 1
hpux_thread_prepare_to_store ()
d392 3
a394 6
hpux_thread_xfer_memory (memaddr, myaddr, len, dowrite, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int dowrite;
     struct target_ops *target; /* ignored */
d399 1
a399 1
  old_chain = save_inferior_pid ();
d401 1
a401 1
  inferior_pid = main_pid;
d403 2
a404 1
  retval = child_ops.to_xfer_memory (memaddr, myaddr, len, dowrite, target);
d414 1
a414 2
hpux_thread_files_info (ignore)
     struct target_ops *ignore;
d420 1
a420 1
hpux_thread_kill_inferior ()
d426 1
a426 2
hpux_thread_notice_signals (pid)
     int pid;
d428 1
a428 1
  child_ops.to_notice_signals (pid);
d434 1
a434 4
hpux_thread_create_inferior (exec_file, allargs, env)
     char *exec_file;
     char *allargs;
     char **env;
d440 1
a440 1
      main_pid = inferior_pid;
d444 1
a444 1
      inferior_pid = find_active_thread ();
d446 1
a446 1
      add_thread (inferior_pid);
d456 7
d464 1
a464 2
hpux_thread_new_objfile (objfile)
     struct objfile *objfile;
d471 1
a471 2

      return;
d477 1
a477 1
    return;
d484 1
a484 1
    return;
d489 4
d498 1
a498 1
hpux_thread_mourn_inferior ()
d506 1
a506 1
hpux_thread_can_run ()
d512 1
a512 2
hpux_thread_alive (pid)
     int pid;
d518 1
a518 1
hpux_thread_stop ()
d526 1
a526 2
hpux_pid_to_str (pid)
     int pid;
d529 1
d531 1
a531 1
  sprintf (buf, "Thread %d", pid >> 16);
d536 39
a574 42
struct target_ops hpux_thread_ops = {
  "hpux-threads",		/* to_shortname */
  "HPUX threads and pthread.", /* to_longname */
  "HPUX threads and pthread support.", /* to_doc */
  hpux_thread_open,		/* to_open */
  0,				/* to_close */
  hpux_thread_attach,		/* to_attach */
  hpux_thread_detach, 		/* to_detach */
  hpux_thread_resume,		/* to_resume */
  hpux_thread_wait,		/* to_wait */
  hpux_thread_fetch_registers,	/* to_fetch_registers */
  hpux_thread_store_registers,	/* to_store_registers */
  hpux_thread_prepare_to_store,	/* to_prepare_to_store */
  hpux_thread_xfer_memory,	/* to_xfer_memory */
  hpux_thread_files_info,	/* to_files_info */
  memory_insert_breakpoint,	/* to_insert_breakpoint */
  memory_remove_breakpoint,	/* to_remove_breakpoint */
  terminal_init_inferior,	/* to_terminal_init */
  terminal_inferior, 		/* to_terminal_inferior */
  terminal_ours_for_output,	/* to_terminal_ours_for_output */
  terminal_ours,		/* to_terminal_ours */
  child_terminal_info,		/* to_terminal_info */
  hpux_thread_kill_inferior,	/* to_kill */
  0,				/* to_load */
  0,				/* to_lookup_symbol */
  hpux_thread_create_inferior,	/* to_create_inferior */
  hpux_thread_mourn_inferior,	/* to_mourn_inferior */
  hpux_thread_can_run,		/* to_can_run */
  hpux_thread_notice_signals,	/* to_notice_signals */
  hpux_thread_alive,		/* to_thread_alive */
  hpux_thread_stop,		/* to_stop */
  process_stratum,		/* to_stratum */
  0,				/* to_next */
  1,				/* to_has_all_memory */
  1,				/* to_has_memory */
  1,				/* to_has_stack */
  1,				/* to_has_registers */
  1,				/* to_has_execution */
  0,				/* sections */
  0,				/* sections_end */
  OPS_MAGIC			/* to_magic */
};
d577 1
a577 1
_initialize_hpux_thread ()
d579 1
d583 3
@


1.1
log
@file hpux-thread.c was initially added on branch CYGNUS.
@
text
@d1 638
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 586
/* Low level interface for debugging HPUX/DCE threads for GDB, the GNU debugger.
   Copyright 1996, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* This module implements a sort of half target that sits between the
   machine-independent parts of GDB and the ptrace interface (infptrace.c) to
   provide access to the HPUX user-mode thread implementation.

   HPUX threads are true user-mode threads, which are invoked via the cma_*
   and pthread_* (DCE and Posix respectivly) interfaces.  These are mostly
   implemented in user-space, with all thread context kept in various
   structures that live in the user's heap.  For the most part, the kernel has
   no knowlege of these threads.

 */

#include "defs.h"

#define _CMA_NOWRAPPERS_

#include <cma_tcb_defs.h>
#include <cma_deb_core.h>
#include "gdbthread.h"
#include "target.h"
#include "inferior.h"
#include "regcache.h"
#include <fcntl.h>
#include "gdb_stat.h"
#include "gdbcore.h"

extern int child_suppress_run;
extern struct target_ops child_ops;	/* target vector for inftarg.c */

extern void _initialize_hpux_thread (void);

struct string_map
  {
    int num;
    char *str;
  };

static int hpux_thread_active = 0;

static ptid_t main_ptid;		/* Real process ID */

static CORE_ADDR P_cma__g_known_threads;
static CORE_ADDR P_cma__g_current_thread;

static void hpux_thread_resume (ptid_t ptid, int step,
                                enum target_signal signo);

static void init_hpux_thread_ops (void);

static struct target_ops hpux_thread_ops;

static ptid_t find_active_thread (void);

static int cached_thread;
static cma__t_int_tcb cached_tcb;

static ptid_t
find_active_thread (void)
{
  static cma__t_int_tcb tcb;
  CORE_ADDR tcb_ptr;

  read_memory ((CORE_ADDR) P_cma__g_current_thread,
	       (char *) &tcb_ptr,
	       sizeof tcb_ptr);

  read_memory (tcb_ptr, (char *) &tcb, sizeof tcb);

  return (ptid_build (PIDGET (main_ptid), 0,
                      cma_thread_get_unique (&tcb.prolog.client_thread)));
}

static cma__t_int_tcb *find_tcb (ptid_t ptid);

static cma__t_int_tcb *
find_tcb (ptid_t ptid)
{
  cma__t_known_object queue_header;
  cma__t_queue *queue_ptr;
  int thread = ptid_get_tid (ptid);

  if (thread == cached_thread)
    return &cached_tcb;

  read_memory ((CORE_ADDR) P_cma__g_known_threads,
	       (char *) &queue_header,
	       sizeof queue_header);

  for (queue_ptr = queue_header.queue.flink;
       queue_ptr != (cma__t_queue *) P_cma__g_known_threads;
       queue_ptr = cached_tcb.threads.flink)
    {
      cma__t_int_tcb *tcb_ptr;

      tcb_ptr = cma__base (queue_ptr, threads, cma__t_int_tcb);

      read_memory ((CORE_ADDR) tcb_ptr, (char *) &cached_tcb, sizeof cached_tcb);

      if (cached_tcb.header.type == cma__c_obj_tcb)
	if (cma_thread_get_unique (&cached_tcb.prolog.client_thread) == thread)
	  {
	    cached_thread = thread;
	    return &cached_tcb;
	  }
    }

  error ("Can't find TCB %d", thread);
  return NULL;
}

/* Most target vector functions from here on actually just pass through to
   inftarg.c, as they don't need to do anything specific for threads.  */

static void
hpux_thread_open (char *arg, int from_tty)
{
  child_ops.to_open (arg, from_tty);
}

/* Attach to process PID, then initialize for debugging it
   and wait for the trace-trap that results from attaching.  */

static void
hpux_thread_attach (char *args, int from_tty)
{
  child_ops.to_attach (args, from_tty);

  /* XXX - might want to iterate over all the threads and register them. */
}

/* Take a program previously attached to and detaches it.
   The program resumes execution and will no longer stop
   on signals, etc.  We'd better not have left any breakpoints
   in the program or it'll die when it hits one.  For this
   to work, it may be necessary for the process to have been
   previously attached.  It *might* work if the program was
   started via the normal ptrace (PTRACE_TRACEME).  */

static void
hpux_thread_detach (char *args, int from_tty)
{
  child_ops.to_detach (args, from_tty);
}

/* Resume execution of process PID.  If STEP is nozero, then
   just single step it.  If SIGNAL is nonzero, restart it with that
   signal activated.  We may have to convert pid from a thread-id to an LWP id
   for procfs.  */

static void
hpux_thread_resume (ptid_t ptid, int step, enum target_signal signo)
{
  struct cleanup *old_chain;

  old_chain = save_inferior_ptid ();

  ptid = main_ptid;
  inferior_ptid = main_ptid;

#if 0
  if (pid != -1)
    {
      pid = thread_to_lwp (pid, -2);
      if (pid == -2)		/* Inactive thread */
	error ("This version of Solaris can't start inactive threads.");
    }
#endif

  child_ops.to_resume (ptid, step, signo);

  cached_thread = 0;

  do_cleanups (old_chain);
}

/* Wait for any threads to stop.  We may have to convert PID from a thread id
   to a LWP id, and vice versa on the way out.  */

static ptid_t
hpux_thread_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
{
  ptid_t rtnval;
  struct cleanup *old_chain;

  old_chain = save_inferior_ptid ();

  inferior_ptid = main_ptid;

  if (!ptid_equal (ptid, minus_one_ptid))
    ptid = main_ptid;

  rtnval = child_ops.to_wait (ptid, ourstatus);

  rtnval = find_active_thread ();

  do_cleanups (old_chain);

  return rtnval;
}

static char regmap[NUM_REGS] =
{
  -2, -1, -1, 0, 4, 8, 12, 16, 20, 24,	/* flags, r1 -> r9 */
  28, 32, 36, 40, 44, 48, 52, 56, 60, -1,	/* r10 -> r19 */
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,	/* r20 -> r29 */

  /* r30, r31, sar, pcoqh, pcsqh, pcoqt, pcsqt, eiem, iir, isr */
  -2, -1, -1, -2, -1, -1, -1, -1, -1, -1,

  /* ior, ipsw, goto, sr4, sr0, sr1, sr2, sr3, sr5, sr6 */
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,

  /* sr7, cr0, cr8, cr9, ccr, cr12, cr13, cr24, cr25, cr26 */
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,

  -1, -1, -1, -1,		/* mpsfu_high, mpsfu_low, mpsfu_ovflo, pad */
  144, -1, -1, -1, -1, -1, -1, -1,	/* fpsr, fpe1 -> fpe7 */
  -1, -1, -1, -1, -1, -1, -1, -1,	/* fr4 -> fr7 */
  -1, -1, -1, -1, -1, -1, -1, -1,	/* fr8 -> fr11 */
  136, -1, 128, -1, 120, -1, 112, -1,	/* fr12 -> fr15 */
  104, -1, 96, -1, 88, -1, 80, -1,	/* fr16 -> fr19 */
  72, -1, 64, -1, -1, -1, -1, -1,	/* fr20 -> fr23 */
  -1, -1, -1, -1, -1, -1, -1, -1,	/* fr24 -> fr27 */
  -1, -1, -1, -1, -1, -1, -1, -1,	/* fr28 -> fr31 */
};

static void
hpux_thread_fetch_registers (int regno)
{
  cma__t_int_tcb tcb, *tcb_ptr;
  struct cleanup *old_chain;
  int i;
  int first_regno, last_regno;

  tcb_ptr = find_tcb (inferior_ptid);

  old_chain = save_inferior_ptid ();

  inferior_ptid = main_ptid;

  if (tcb_ptr->state == cma__c_state_running)
    {
      child_ops.to_fetch_registers (regno);

      do_cleanups (old_chain);

      return;
    }

  if (regno == -1)
    {
      first_regno = 0;
      last_regno = NUM_REGS - 1;
    }
  else
    {
      first_regno = regno;
      last_regno = regno;
    }

  for (regno = first_regno; regno <= last_regno; regno++)
    {
      if (regmap[regno] == -1)
	child_ops.to_fetch_registers (regno);
      else
	{
	  unsigned char buf[MAX_REGISTER_SIZE];
	  CORE_ADDR sp;

	  sp = (CORE_ADDR) tcb_ptr->static_ctx.sp - 160;

	  if (regno == FLAGS_REGNUM)
	    /* Flags must be 0 to avoid bogus value for SS_INSYSCALL */
	    memset (buf, '\000', DEPRECATED_REGISTER_RAW_SIZE (regno));
	  else if (regno == SP_REGNUM)
	    store_unsigned_integer (buf, sizeof sp, sp);
	  else if (regno == PC_REGNUM)
	    read_memory (sp - 20, buf, DEPRECATED_REGISTER_RAW_SIZE (regno));
	  else
	    read_memory (sp + regmap[regno], buf, DEPRECATED_REGISTER_RAW_SIZE (regno));

	  supply_register (regno, buf);
	}
    }

  do_cleanups (old_chain);
}

static void
hpux_thread_store_registers (int regno)
{
  cma__t_int_tcb tcb, *tcb_ptr;
  struct cleanup *old_chain;
  int i;
  int first_regno, last_regno;

  tcb_ptr = find_tcb (inferior_ptid);

  old_chain = save_inferior_ptid ();

  inferior_ptid = main_ptid;

  if (tcb_ptr->state == cma__c_state_running)
    {
      child_ops.to_store_registers (regno);

      do_cleanups (old_chain);

      return;
    }

  if (regno == -1)
    {
      first_regno = 0;
      last_regno = NUM_REGS - 1;
    }
  else
    {
      first_regno = regno;
      last_regno = regno;
    }

  for (regno = first_regno; regno <= last_regno; regno++)
    {
      if (regmap[regno] == -1)
	child_ops.to_store_registers (regno);
      else
	{
	  unsigned char buf[MAX_REGISTER_SIZE];
	  CORE_ADDR sp;

	  sp = (CORE_ADDR) tcb_ptr->static_ctx.sp - 160;

	  if (regno == FLAGS_REGNUM)
	    child_ops.to_store_registers (regno);	/* Let lower layer handle this... */
	  else if (regno == SP_REGNUM)
	    {
	      write_memory ((CORE_ADDR) & tcb_ptr->static_ctx.sp,
			    &deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)],
			    DEPRECATED_REGISTER_RAW_SIZE (regno));
	      tcb_ptr->static_ctx.sp = (cma__t_hppa_regs *)
		(extract_unsigned_integer (&deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)],
					   DEPRECATED_REGISTER_RAW_SIZE (regno)) + 160);
	    }
	  else if (regno == PC_REGNUM)
	    write_memory (sp - 20,
			  &deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)],
			  DEPRECATED_REGISTER_RAW_SIZE (regno));
	  else
	    write_memory (sp + regmap[regno],
			  &deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)],
			  DEPRECATED_REGISTER_RAW_SIZE (regno));
	}
    }

  do_cleanups (old_chain);
}

/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On machines
   which store all the registers in one fell swoop, this makes sure
   that registers contains all the registers from the program being
   debugged.  */

static void
hpux_thread_prepare_to_store (void)
{
  child_ops.to_prepare_to_store ();
}

static int
hpux_thread_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len,
			 int dowrite, struct mem_attrib *attribs,
			 struct target_ops *target)
{
  int retval;
  struct cleanup *old_chain;

  old_chain = save_inferior_ptid ();

  inferior_ptid = main_ptid;

  retval = 
    child_ops.to_xfer_memory (memaddr, myaddr, len, dowrite, attribs, target);

  do_cleanups (old_chain);

  return retval;
}

/* Print status information about what we're accessing.  */

static void
hpux_thread_files_info (struct target_ops *ignore)
{
  child_ops.to_files_info (ignore);
}

static void
hpux_thread_kill_inferior (void)
{
  child_ops.to_kill ();
}

static void
hpux_thread_notice_signals (ptid_t ptid)
{
  child_ops.to_notice_signals (ptid);
}

/* Fork an inferior process, and start debugging it with /proc.  */

static void
hpux_thread_create_inferior (char *exec_file, char *allargs, char **env)
{
  child_ops.to_create_inferior (exec_file, allargs, env);

  if (hpux_thread_active)
    {
      main_ptid = inferior_ptid;

      push_target (&hpux_thread_ops);

      inferior_ptid = find_active_thread ();

      add_thread (inferior_ptid);
    }
}

/* This routine is called whenever a new symbol table is read in, or when all
   symbol tables are removed.  libthread_db can only be initialized when it
   finds the right variables in libthread.so.  Since it's a shared library,
   those variables don't show up until the library gets mapped and the symbol
   table is read in.  */

/* This new_objfile event is now managed by a chained function pointer. 
 * It is the callee's responsability to call the next client on the chain.
 */

/* Saved pointer to previous owner of the new_objfile event. */
static void (*target_new_objfile_chain) (struct objfile *);

void
hpux_thread_new_objfile (struct objfile *objfile)
{
  struct minimal_symbol *ms;

  if (!objfile)
    {
      hpux_thread_active = 0;
      goto quit;
    }

  ms = lookup_minimal_symbol ("cma__g_known_threads", NULL, objfile);

  if (!ms)
    goto quit;

  P_cma__g_known_threads = SYMBOL_VALUE_ADDRESS (ms);

  ms = lookup_minimal_symbol ("cma__g_current_thread", NULL, objfile);

  if (!ms)
    goto quit;

  P_cma__g_current_thread = SYMBOL_VALUE_ADDRESS (ms);

  hpux_thread_active = 1;
quit:
  /* Call predecessor on chain, if any. */
  if (target_new_objfile_chain)
    target_new_objfile_chain (objfile);
}

/* Clean up after the inferior dies.  */

static void
hpux_thread_mourn_inferior (void)
{
  child_ops.to_mourn_inferior ();
}

/* Mark our target-struct as eligible for stray "run" and "attach" commands.  */

static int
hpux_thread_can_run (void)
{
  return child_suppress_run;
}

static int
hpux_thread_alive (ptid_t ptid)
{
  return 1;
}

static void
hpux_thread_stop (void)
{
  child_ops.to_stop ();
}

/* Convert a pid to printable form. */

char *
hpux_pid_to_str (ptid_t ptid)
{
  static char buf[100];
  int pid = PIDGET (ptid);

  sprintf (buf, "Thread %ld", ptid_get_tid (ptid));

  return buf;
}

static void
init_hpux_thread_ops (void)
{
  hpux_thread_ops.to_shortname = "hpux-threads";
  hpux_thread_ops.to_longname = "HPUX threads and pthread.";
  hpux_thread_ops.to_doc = "HPUX threads and pthread support.";
  hpux_thread_ops.to_open = hpux_thread_open;
  hpux_thread_ops.to_attach = hpux_thread_attach;
  hpux_thread_ops.to_detach = hpux_thread_detach;
  hpux_thread_ops.to_resume = hpux_thread_resume;
  hpux_thread_ops.to_wait = hpux_thread_wait;
  hpux_thread_ops.to_fetch_registers = hpux_thread_fetch_registers;
  hpux_thread_ops.to_store_registers = hpux_thread_store_registers;
  hpux_thread_ops.to_prepare_to_store = hpux_thread_prepare_to_store;
  hpux_thread_ops.to_xfer_memory = hpux_thread_xfer_memory;
  hpux_thread_ops.to_files_info = hpux_thread_files_info;
  hpux_thread_ops.to_insert_breakpoint = memory_insert_breakpoint;
  hpux_thread_ops.to_remove_breakpoint = memory_remove_breakpoint;
  hpux_thread_ops.to_terminal_init = terminal_init_inferior;
  hpux_thread_ops.to_terminal_inferior = terminal_inferior;
  hpux_thread_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  hpux_thread_ops.to_terminal_save_ours = terminal_save_ours;
  hpux_thread_ops.to_terminal_ours = terminal_ours;
  hpux_thread_ops.to_terminal_info = child_terminal_info;
  hpux_thread_ops.to_kill = hpux_thread_kill_inferior;
  hpux_thread_ops.to_create_inferior = hpux_thread_create_inferior;
  hpux_thread_ops.to_mourn_inferior = hpux_thread_mourn_inferior;
  hpux_thread_ops.to_can_run = hpux_thread_can_run;
  hpux_thread_ops.to_notice_signals = hpux_thread_notice_signals;
  hpux_thread_ops.to_thread_alive = hpux_thread_alive;
  hpux_thread_ops.to_stop = hpux_thread_stop;
  hpux_thread_ops.to_stratum = process_stratum;
  hpux_thread_ops.to_has_all_memory = 1;
  hpux_thread_ops.to_has_memory = 1;
  hpux_thread_ops.to_has_stack = 1;
  hpux_thread_ops.to_has_registers = 1;
  hpux_thread_ops.to_has_execution = 1;
  hpux_thread_ops.to_magic = OPS_MAGIC;
}

void
_initialize_hpux_thread (void)
{
  init_hpux_thread_ops ();
  add_target (&hpux_thread_ops);

  child_suppress_run = 1;
  /* Hook into new_objfile notification. */
  target_new_objfile_chain = target_new_objfile_hook;
  target_new_objfile_hook  = hpux_thread_new_objfile;
}
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d1 2
a2 5
/* Low level interface for debugging HPUX/DCE threads for GDB, the GNU
   debugger.

   Copyright 1996, 1998, 1999, 2000, 2001, 2004 Free Software
   Foundation, Inc.
d48 1
d137 1
a137 1
  deprecated_child_ops.to_open (arg, from_tty);
d146 1
a146 1
  deprecated_child_ops.to_attach (args, from_tty);
d162 1
a162 1
  deprecated_child_ops.to_detach (args, from_tty);
d189 1
a189 1
  deprecated_child_ops.to_resume (ptid, step, signo);
d212 1
a212 1
  rtnval = deprecated_child_ops.to_wait (ptid, ourstatus);
d263 1
a263 1
      deprecated_child_ops.to_fetch_registers (regno);
d284 1
a284 1
	deprecated_child_ops.to_fetch_registers (regno);
d294 1
a294 1
	    memset (buf, '\000', register_size (current_gdbarch, regno));
d298 1
a298 1
	    read_memory (sp - 20, buf, register_size (current_gdbarch, regno));
d300 1
a300 1
	    read_memory (sp + regmap[regno], buf, register_size (current_gdbarch, regno));
d302 1
a302 1
	  regcache_raw_supply (current_regcache, regno, buf);
d325 1
a325 1
      deprecated_child_ops.to_store_registers (regno);
d346 1
a346 1
	deprecated_child_ops.to_store_registers (regno);
d355 1
a355 1
	    deprecated_child_ops.to_store_registers (regno);	/* Let lower layer handle this... */
d360 1
a360 1
			    register_size (current_gdbarch, regno));
d363 1
a363 1
					   register_size (current_gdbarch, regno)) + 160);
d368 1
a368 1
			  register_size (current_gdbarch, regno));
d372 1
a372 1
			  register_size (current_gdbarch, regno));
d388 1
a388 1
  deprecated_child_ops.to_prepare_to_store ();
d404 1
a404 1
    deprecated_child_ops.deprecated_xfer_memory (memaddr, myaddr, len, dowrite, attribs, target);
d416 1
a416 1
  deprecated_child_ops.to_files_info (ignore);
d422 1
a422 1
  deprecated_child_ops.to_kill ();
d428 1
a428 1
  deprecated_child_ops.to_notice_signals (ptid);
d434 1
a434 2
hpux_thread_create_inferior (char *exec_file, char *allargs, char **env,
			     int from_tty)
d436 1
a436 1
  deprecated_child_ops.to_create_inferior (exec_file, allargs, env, from_tty);
d500 1
a500 1
  deprecated_child_ops.to_mourn_inferior ();
d520 1
a520 1
  deprecated_child_ops.to_stop ();
d550 1
a550 1
  hpux_thread_ops.deprecated_xfer_memory = hpux_thread_xfer_memory;
d584 2
a585 2
  target_new_objfile_chain = deprecated_target_new_objfile_hook;
  deprecated_target_new_objfile_hook  = hpux_thread_new_objfile;
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 638
/* Low level interface for debugging HPUX/DCE threads for GDB, the GNU debugger.
   Copyright 1996 Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* This module implements a sort of half target that sits between the
   machine-independent parts of GDB and the ptrace interface (infptrace.c) to
   provide access to the HPUX user-mode thread implementation.

   HPUX threads are true user-mode threads, which are invoked via the cma_*
   and pthread_* (DCE and Posix respectivly) interfaces.  These are mostly
   implemented in user-space, with all thread context kept in various
   structures that live in the user's heap.  For the most part, the kernel has
   no knowlege of these threads.

   */

#include "defs.h"

#define _CMA_NOWRAPPERS_

#include <cma_tcb_defs.h>
#include <cma_deb_core.h>
#include "gdbthread.h"
#include "target.h"
#include "inferior.h"
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include "gdbcore.h"

extern struct target_ops hpux_thread_ops; /* Forward declaration */

extern int child_suppress_run;
extern struct target_ops child_ops; /* target vector for inftarg.c */

struct string_map
{
  int num;
  char *str;
};

static int hpux_thread_active = 0;

static int main_pid;		/* Real process ID */

static CORE_ADDR P_cma__g_known_threads;
static CORE_ADDR P_cma__g_current_thread;

static struct cleanup * save_inferior_pid PARAMS ((void));
static void restore_inferior_pid PARAMS ((int pid));
static void hpux_thread_resume PARAMS ((int pid, int step,
					enum target_signal signo));

/*

LOCAL FUNCTION

	save_inferior_pid - Save inferior_pid on the cleanup list
	restore_inferior_pid - Restore inferior_pid from the cleanup list

SYNOPSIS

	struct cleanup *save_inferior_pid ()
	void restore_inferior_pid (int pid)

DESCRIPTION

	These two functions act in unison to restore inferior_pid in
	case of an error.

NOTES

	inferior_pid is a global variable that needs to be changed by many of
	these routines before calling functions in procfs.c.  In order to
	guarantee that inferior_pid gets restored (in case of errors), you
	need to call save_inferior_pid before changing it.  At the end of the
	function, you should invoke do_cleanups to restore it.

 */


static struct cleanup *
save_inferior_pid ()
{
  return make_cleanup (restore_inferior_pid, inferior_pid);
}

static void
restore_inferior_pid (pid)
     int pid;
{
  inferior_pid = pid;
}

static int find_active_thread PARAMS ((void));

static int cached_thread;
static int cached_active_thread;
static cma__t_int_tcb cached_tcb;

static int
find_active_thread ()
{
  static cma__t_int_tcb tcb;
  CORE_ADDR tcb_ptr;

  if (cached_active_thread != 0)
    return cached_active_thread;

  read_memory ((CORE_ADDR)P_cma__g_current_thread,
	       (char *)&tcb_ptr,
	       sizeof tcb_ptr);

  read_memory (tcb_ptr, (char *)&tcb, sizeof tcb);

  return (cma_thread_get_unique (&tcb.prolog.client_thread) << 16) | main_pid;
}

static cma__t_int_tcb * find_tcb PARAMS ((int thread));

static cma__t_int_tcb *
find_tcb (thread)
     int thread;
{
  cma__t_known_object queue_header;
  cma__t_queue *queue_ptr;

  if (thread == cached_thread)
    return &cached_tcb;

  read_memory ((CORE_ADDR)P_cma__g_known_threads,
	       (char *)&queue_header,
	       sizeof queue_header);

  for (queue_ptr = queue_header.queue.flink;
       queue_ptr != (cma__t_queue *)P_cma__g_known_threads;
       queue_ptr = cached_tcb.threads.flink)
    {
      cma__t_int_tcb *tcb_ptr;

      tcb_ptr = cma__base (queue_ptr, threads, cma__t_int_tcb);

      read_memory ((CORE_ADDR)tcb_ptr, (char *)&cached_tcb, sizeof cached_tcb);

      if (cached_tcb.header.type == cma__c_obj_tcb)
	if (cma_thread_get_unique (&cached_tcb.prolog.client_thread) == thread >> 16)
	  {
	    cached_thread = thread;
	    return &cached_tcb;
	  }
    }

  error ("Can't find TCB %d,%d", thread >> 16, thread & 0xffff);
  return NULL;
}

/* Most target vector functions from here on actually just pass through to
   inftarg.c, as they don't need to do anything specific for threads.  */

/* ARGSUSED */
static void
hpux_thread_open (arg, from_tty)
     char *arg;
     int from_tty;
{
  child_ops.to_open (arg, from_tty);
}

/* Attach to process PID, then initialize for debugging it
   and wait for the trace-trap that results from attaching.  */

static void
hpux_thread_attach (args, from_tty)
     char *args;
     int from_tty;
{
  child_ops.to_attach (args, from_tty);

  /* XXX - might want to iterate over all the threads and register them. */
}

/* Take a program previously attached to and detaches it.
   The program resumes execution and will no longer stop
   on signals, etc.  We'd better not have left any breakpoints
   in the program or it'll die when it hits one.  For this
   to work, it may be necessary for the process to have been
   previously attached.  It *might* work if the program was
   started via the normal ptrace (PTRACE_TRACEME).  */

static void
hpux_thread_detach (args, from_tty)
     char *args;
     int from_tty;
{
  child_ops.to_detach (args, from_tty);
}

/* Resume execution of process PID.  If STEP is nozero, then
   just single step it.  If SIGNAL is nonzero, restart it with that
   signal activated.  We may have to convert pid from a thread-id to an LWP id
   for procfs.  */

static void
hpux_thread_resume (pid, step, signo)
     int pid;
     int step;
     enum target_signal signo;
{
  struct cleanup *old_chain;

  old_chain = save_inferior_pid ();

  pid = inferior_pid = main_pid;

#if 0
  if (pid != -1)
    {
      pid = thread_to_lwp (pid, -2);
      if (pid == -2)		/* Inactive thread */
	error ("This version of Solaris can't start inactive threads.");
    }
#endif

  child_ops.to_resume (pid, step, signo);

  cached_thread = 0;
  cached_active_thread = 0;

  do_cleanups (old_chain);
}

/* Wait for any threads to stop.  We may have to convert PID from a thread id
   to a LWP id, and vice versa on the way out.  */

static int
hpux_thread_wait (pid, ourstatus)
     int pid;
     struct target_waitstatus *ourstatus;
{
  int rtnval;
  struct cleanup *old_chain;

  old_chain = save_inferior_pid ();

  inferior_pid = main_pid;

  if (pid != -1)
    pid = main_pid;

  rtnval = child_ops.to_wait (pid, ourstatus);

  rtnval = find_active_thread ();

  do_cleanups (old_chain);

  return rtnval;
}

static char regmap[NUM_REGS] =
{
  -2, -1, -1, 0, 4, 8, 12, 16, 20, 24, /* flags, r1 -> r9 */
  28, 32, 36, 40, 44, 48, 52, 56, 60, -1, /* r10 -> r19 */
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* r20 -> r29 */

  /* r30, r31, sar, pcoqh, pcsqh, pcoqt, pcsqt, eiem, iir, isr */
  -2, -1, -1, -2, -1, -1, -1, -1, -1, -1,

  /* ior, ipsw, goto, sr4, sr0, sr1, sr2, sr3, sr5, sr6 */
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,

  /* sr7, cr0, cr8, cr9, ccr, cr12, cr13, cr24, cr25, cr26 */
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,

  -1, -1, -1, -1,		/* mpsfu_high, mpsfu_low, mpsfu_ovflo, pad */
  144, -1, -1, -1, -1, -1, -1, -1, /* fpsr, fpe1 -> fpe7 */
  -1, -1, -1, -1, -1, -1, -1, -1, /* fr4 -> fr7 */
  -1, -1, -1, -1, -1, -1, -1, -1, /* fr8 -> fr11 */
  136, -1, 128, -1, 120, -1, 112, -1, /* fr12 -> fr15 */
  104, -1, 96, -1, 88, -1, 80, -1, /* fr16 -> fr19 */
  72, -1, 64, -1, -1, -1, -1, -1, /* fr20 -> fr23 */
  -1, -1, -1, -1, -1, -1, -1, -1, /* fr24 -> fr27 */
  -1, -1, -1, -1, -1, -1, -1, -1, /* fr28 -> fr31 */
};

static void
hpux_thread_fetch_registers (regno)
     int regno;
{
  cma__t_int_tcb tcb, *tcb_ptr;
  struct cleanup *old_chain;
  int i;
  int first_regno, last_regno;

  tcb_ptr = find_tcb (inferior_pid);

  old_chain = save_inferior_pid ();

  inferior_pid = main_pid;

  if (tcb_ptr->state == cma__c_state_running)
    {
      child_ops.to_fetch_registers (regno);

      do_cleanups (old_chain);

      return;
    }

  if (regno == -1)
    {
      first_regno = 0;
      last_regno = NUM_REGS - 1;
    }
  else
    {
      first_regno = regno;
      last_regno = regno;
    }

  for (regno = first_regno; regno <= last_regno; regno++)
    {
      if (regmap[regno] == -1)
	child_ops.to_fetch_registers (regno);
      else
	{
	  unsigned char buf[MAX_REGISTER_RAW_SIZE];
	  CORE_ADDR sp;

	  sp = (CORE_ADDR)tcb_ptr->static_ctx.sp - 160;

	  if (regno == FLAGS_REGNUM)
	    /* Flags must be 0 to avoid bogus value for SS_INSYSCALL */
	    memset (buf, '\000', REGISTER_RAW_SIZE (regno));
	  else if (regno == SP_REGNUM)
	    store_address (buf, sizeof sp, sp);
	  else if (regno == PC_REGNUM)
	    read_memory (sp - 20, buf, REGISTER_RAW_SIZE (regno));
	  else
	    read_memory (sp + regmap[regno], buf, REGISTER_RAW_SIZE (regno));

	  supply_register (regno, buf);
	}
    }

  do_cleanups (old_chain);
}

static void
hpux_thread_store_registers (regno)
     int regno;
{
  cma__t_int_tcb tcb, *tcb_ptr;
  struct cleanup *old_chain;
  int i;
  int first_regno, last_regno;

  tcb_ptr = find_tcb (inferior_pid);

  old_chain = save_inferior_pid ();

  inferior_pid = main_pid;

  if (tcb_ptr->state == cma__c_state_running)
    {
      child_ops.to_store_registers (regno);

      do_cleanups (old_chain);

      return;
    }

  if (regno == -1)
    {
      first_regno = 0;
      last_regno = NUM_REGS - 1;
    }
  else
    {
      first_regno = regno;
      last_regno = regno;
    }

  for (regno = first_regno; regno <= last_regno; regno++)
    {
      if (regmap[regno] == -1)
	child_ops.to_store_registers (regno);
      else
	{
	  unsigned char buf[MAX_REGISTER_RAW_SIZE];
	  CORE_ADDR sp;

	  sp = (CORE_ADDR)tcb_ptr->static_ctx.sp - 160;

	  if (regno == FLAGS_REGNUM)
	    child_ops.to_store_registers (regno); /* Let lower layer handle this... */
	  else if (regno == SP_REGNUM)
	    {
	      write_memory ((CORE_ADDR)&tcb_ptr->static_ctx.sp,
			    registers + REGISTER_BYTE (regno),
			    REGISTER_RAW_SIZE (regno));
	      tcb_ptr->static_ctx.sp = (cma__t_hppa_regs *)
		(extract_address (registers + REGISTER_BYTE (regno), REGISTER_RAW_SIZE (regno)) + 160);
	    }
	  else if (regno == PC_REGNUM)
	    write_memory (sp - 20,
			  registers + REGISTER_BYTE (regno),
			  REGISTER_RAW_SIZE (regno));
	  else
	    write_memory (sp + regmap[regno],
			  registers + REGISTER_BYTE (regno),
			  REGISTER_RAW_SIZE (regno));
	}
    }

  do_cleanups (old_chain);
}

/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On machines
   which store all the registers in one fell swoop, this makes sure
   that registers contains all the registers from the program being
   debugged.  */

static void
hpux_thread_prepare_to_store ()
{
  child_ops.to_prepare_to_store ();
}

static int
hpux_thread_xfer_memory (memaddr, myaddr, len, dowrite, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int dowrite;
     struct target_ops *target; /* ignored */
{
  int retval;
  struct cleanup *old_chain;

  old_chain = save_inferior_pid ();

  inferior_pid = main_pid;

  retval = child_ops.to_xfer_memory (memaddr, myaddr, len, dowrite, target);

  do_cleanups (old_chain);

  return retval;
}

/* Print status information about what we're accessing.  */

static void
hpux_thread_files_info (ignore)
     struct target_ops *ignore;
{
  child_ops.to_files_info (ignore);
}

static void
hpux_thread_kill_inferior ()
{
  child_ops.to_kill ();
}

static void
hpux_thread_notice_signals (pid)
     int pid;
{
  child_ops.to_notice_signals (pid);
}

/* Fork an inferior process, and start debugging it with /proc.  */

static void
hpux_thread_create_inferior (exec_file, allargs, env)
     char *exec_file;
     char *allargs;
     char **env;
{
  child_ops.to_create_inferior (exec_file, allargs, env);

  if (hpux_thread_active)
    {
      main_pid = inferior_pid;

      push_target (&hpux_thread_ops);

      inferior_pid = find_active_thread ();

      add_thread (inferior_pid);
    }
}

/* This routine is called whenever a new symbol table is read in, or when all
   symbol tables are removed.  libthread_db can only be initialized when it
   finds the right variables in libthread.so.  Since it's a shared library,
   those variables don't show up until the library gets mapped and the symbol
   table is read in.  */

void
hpux_thread_new_objfile (objfile)
     struct objfile *objfile;
{
  struct minimal_symbol *ms;

  if (!objfile)
    {
      hpux_thread_active = 0;

      return;
    }

  ms = lookup_minimal_symbol ("cma__g_known_threads", NULL, objfile);

  if (!ms)
    return;

  P_cma__g_known_threads = SYMBOL_VALUE_ADDRESS (ms);

  ms = lookup_minimal_symbol ("cma__g_current_thread", NULL, objfile);

  if (!ms)
    return;

  P_cma__g_current_thread = SYMBOL_VALUE_ADDRESS (ms);

  hpux_thread_active = 1;
}

/* Clean up after the inferior dies.  */

static void
hpux_thread_mourn_inferior ()
{
  child_ops.to_mourn_inferior ();
}

/* Mark our target-struct as eligible for stray "run" and "attach" commands.  */

static int
hpux_thread_can_run ()
{
  return child_suppress_run;
}

static int
hpux_thread_alive (pid)
     int pid;
{
  return 1;
}

static void
hpux_thread_stop ()
{
  child_ops.to_stop ();
}

/* Convert a pid to printable form. */

char *
hpux_pid_to_str (pid)
     int pid;
{
  static char buf[100];

  sprintf (buf, "Thread %d", pid >> 16);

  return buf;
}

struct target_ops hpux_thread_ops = {
  "hpux-threads",		/* to_shortname */
  "HPUX threads and pthread.", /* to_longname */
  "HPUX threads and pthread support.", /* to_doc */
  hpux_thread_open,		/* to_open */
  0,				/* to_close */
  hpux_thread_attach,		/* to_attach */
  hpux_thread_detach, 		/* to_detach */
  hpux_thread_resume,		/* to_resume */
  hpux_thread_wait,		/* to_wait */
  hpux_thread_fetch_registers,	/* to_fetch_registers */
  hpux_thread_store_registers,	/* to_store_registers */
  hpux_thread_prepare_to_store,	/* to_prepare_to_store */
  hpux_thread_xfer_memory,	/* to_xfer_memory */
  hpux_thread_files_info,	/* to_files_info */
  memory_insert_breakpoint,	/* to_insert_breakpoint */
  memory_remove_breakpoint,	/* to_remove_breakpoint */
  terminal_init_inferior,	/* to_terminal_init */
  terminal_inferior, 		/* to_terminal_inferior */
  terminal_ours_for_output,	/* to_terminal_ours_for_output */
  terminal_ours,		/* to_terminal_ours */
  child_terminal_info,		/* to_terminal_info */
  hpux_thread_kill_inferior,	/* to_kill */
  0,				/* to_load */
  0,				/* to_lookup_symbol */
  hpux_thread_create_inferior,	/* to_create_inferior */
  hpux_thread_mourn_inferior,	/* to_mourn_inferior */
  hpux_thread_can_run,		/* to_can_run */
  hpux_thread_notice_signals,	/* to_notice_signals */
  hpux_thread_alive,		/* to_thread_alive */
  hpux_thread_stop,		/* to_stop */
  process_stratum,		/* to_stratum */
  0,				/* to_next */
  1,				/* to_has_all_memory */
  1,				/* to_has_memory */
  1,				/* to_has_stack */
  1,				/* to_has_registers */
  1,				/* to_has_execution */
  0,				/* sections */
  0,				/* sections_end */
  OPS_MAGIC			/* to_magic */
};

void
_initialize_hpux_thread ()
{
  add_target (&hpux_thread_ops);

  child_suppress_run = 1;
}
@
