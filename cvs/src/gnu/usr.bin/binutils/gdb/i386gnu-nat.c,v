head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.48
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.44
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.46
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.38
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.42
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.40
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.36
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.34
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.32
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.30
	OPENBSD_5_0:1.4.0.28
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.26
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.24
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2004.12.27.14.00.37;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.21.20.23.08;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.37.59;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.18.23;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.11.09;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.12.37;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.18.23;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@/* Low level interface to i386 running the GNU Hurd.

   Copyright 1992, 1995, 1996, 1998, 2000, 2001, 2004
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "inferior.h"
#include "floatformat.h"
#include "regcache.h"

#include "gdb_assert.h"
#include <errno.h>
#include <stdio.h>
#include "gdb_string.h"

#include <mach.h>
#include <mach_error.h>
#include <mach/message.h>
#include <mach/exception.h>

#include "i386-tdep.h"

#include "gnu-nat.h"
#include "i387-tdep.h"

#ifdef HAVE_SYS_PROCFS_H
# include <sys/procfs.h>
# include "gregset.h"
#endif

/* Offset to the thread_state_t location where REG is stored.  */
#define REG_OFFSET(reg) offsetof (struct i386_thread_state, reg)

/* At REG_OFFSET[N] is the offset to the thread_state_t location where
   the GDB register N is stored.  */
static int reg_offset[] =
{
  REG_OFFSET (eax), REG_OFFSET (ecx), REG_OFFSET (edx), REG_OFFSET (ebx),
  REG_OFFSET (uesp), REG_OFFSET (ebp), REG_OFFSET (esi), REG_OFFSET (edi),
  REG_OFFSET (eip), REG_OFFSET (efl), REG_OFFSET (cs), REG_OFFSET (ss),
  REG_OFFSET (ds), REG_OFFSET (es), REG_OFFSET (fs), REG_OFFSET (gs)
};

#define REG_ADDR(state, regnum) ((char *)(state) + reg_offset[regnum])


/* Get the whole floating-point state of THREAD and record the values
   of the corresponding (pseudo) registers.  */

static void
fetch_fpregs (struct proc *thread)
{
  mach_msg_type_number_t count = i386_FLOAT_STATE_COUNT;
  struct i386_float_state state;
  error_t err;

  err = thread_get_state (thread->port, i386_FLOAT_STATE,
			  (thread_state_t) &state, &count);
  if (err)
    {
      warning ("Couldn't fetch floating-point state from %s",
	       proc_string (thread));
      return;
    }

  if (!state.initialized)
    {
      /* The floating-point state isn't initialized.  */
      i387_supply_fsave (current_regcache, -1, NULL);
    }
  else
    {
      /* Supply the floating-point registers.  */
      i387_supply_fsave (current_regcache, -1, state.hw_state);
    }
}

#ifdef HAVE_SYS_PROCFS_H
/* These two calls are used by the core-regset.c code for
   reading ELF core files.  */
void
supply_gregset (gdb_gregset_t *gregs)
{
  int i;
  for (i = 0; i < I386_NUM_GREGS; i++)
    regcache_raw_supply (current_regcache, i, REG_ADDR (gregs, i));
}

void
supply_fpregset (gdb_fpregset_t *fpregs)
{
  i387_supply_fsave (current_regcache, -1, fpregs);
}
#endif

/* Fetch register REGNO, or all regs if REGNO is -1.  */
void
gnu_fetch_registers (int regno)
{
  struct proc *thread;

  /* Make sure we know about new threads.  */
  inf_update_procs (current_inferior);

  thread = inf_tid_to_thread (current_inferior, PIDGET (inferior_ptid));
  if (!thread)
    error ("Can't fetch registers from thread %d: No such thread",
	   PIDGET (inferior_ptid));

  if (regno < I386_NUM_GREGS || regno == -1)
    {
      thread_state_t state;

      /* This does the dirty work for us.  */
      state = proc_get_state (thread, 0);
      if (!state)
	{
	  warning ("Couldn't fetch registers from %s",
		   proc_string (thread));
	  return;
	}

      if (regno == -1)
	{
	  int i;

	  proc_debug (thread, "fetching all register");

	  for (i = 0; i < I386_NUM_GREGS; i++)
	    regcache_raw_supply (current_regcache, i, REG_ADDR (state, i));
	  thread->fetched_regs = ~0;
	}
      else
	{
	  proc_debug (thread, "fetching register %s", REGISTER_NAME (regno));

	  regcache_raw_supply (current_regcache, regno,
			       REG_ADDR (state, regno));
	  thread->fetched_regs |= (1 << regno);
	}
    }

  if (regno >= I386_NUM_GREGS || regno == -1)
    {
      proc_debug (thread, "fetching floating-point registers");

      fetch_fpregs (thread);
    }
}


/* Store the whole floating-point state into THREAD using information
   from the corresponding (pseudo) registers.  */
static void
store_fpregs (struct proc *thread, int regno)
{
  mach_msg_type_number_t count = i386_FLOAT_STATE_COUNT;
  struct i386_float_state state;
  error_t err;

  err = thread_get_state (thread->port, i386_FLOAT_STATE,
			  (thread_state_t) &state, &count);
  if (err)
    {
      warning ("Couldn't fetch floating-point state from %s",
	       proc_string (thread));
      return;
    }

  /* FIXME: kettenis/2001-07-15: Is this right?  Should we somehow
     take into account DEPRECATED_REGISTER_VALID like the old code did?  */
  i387_fill_fsave (state.hw_state, regno);

  err = thread_set_state (thread->port, i386_FLOAT_STATE,
			  (thread_state_t) &state, i386_FLOAT_STATE_COUNT);
  if (err)
    {
      warning ("Couldn't store floating-point state into %s",
	       proc_string (thread));
      return;
    }
}

/* Store at least register REGNO, or all regs if REGNO == -1.  */
void
gnu_store_registers (int regno)
{
  struct regcache *regcache = current_regcache;
  struct proc *thread;

  /* Make sure we know about new threads.  */
  inf_update_procs (current_inferior);

  thread = inf_tid_to_thread (current_inferior, PIDGET (inferior_ptid));
  if (!thread)
    error ("Couldn't store registers into thread %d: No such thread",
	   PIDGET (inferior_ptid));

  if (regno < I386_NUM_GREGS || regno == -1)
    {
      thread_state_t state;
      thread_state_data_t old_state;
      int was_aborted = thread->aborted;
      int was_valid = thread->state_valid;
      int trace;

      if (!was_aborted && was_valid)
	memcpy (&old_state, &thread->state, sizeof (old_state));

      state = proc_get_state (thread, 1);
      if (!state)
	{
	  warning ("Couldn't store registers into %s", proc_string (thread));
	  return;
	}

      /* Save the T bit.  We might try to restore the %eflags register
         below, but changing the T bit would seriously confuse GDB.  */
      trace = ((struct i386_thread_state *)state)->efl & 0x100;

      if (!was_aborted && was_valid)
	/* See which registers have changed after aborting the thread.  */
	{
	  int check_regno;

	  for (check_regno = 0; check_regno < I386_NUM_GREGS; check_regno++)
	    if ((thread->fetched_regs & (1 << check_regno))
		&& memcpy (REG_ADDR (&old_state, check_regno),
			   REG_ADDR (state, check_regno),
			   register_size (current_gdbarch, check_regno)))
	      /* Register CHECK_REGNO has changed!  Ack!  */
	      {
		warning ("Register %s changed after the thread was aborted",
			 REGISTER_NAME (check_regno));
		if (regno >= 0 && regno != check_regno)
		  /* Update GDB's copy of the register.  */
		  regcache_raw_supply (regcache, check_regno,
				       REG_ADDR (state, check_regno));
		else
		  warning ("... also writing this register!  Suspicious...");
	      }
	}

      if (regno == -1)
	{
	  int i;

	  proc_debug (thread, "storing all registers");

	  for (i = 0; i < I386_NUM_GREGS; i++)
	    if (regcache_valid_p (regcache, i))
	      regcache_raw_collect (regcache, i, REG_ADDR (state, i));
	}
      else
	{
	  proc_debug (thread, "storing register %s", REGISTER_NAME (regno));

	  gdb_assert (regcache_valid_p (regcache, regno));
	  regcache_raw_collect (regcache, regno, REG_ADDR (state, regno));
	}

      /* Restore the T bit.  */
      ((struct i386_thread_state *)state)->efl &= ~0x100;
      ((struct i386_thread_state *)state)->efl |= trace;
    }

  if (regno >= I386_NUM_GREGS || regno == -1)
    {
      proc_debug (thread, "storing floating-point registers");

      store_fpregs (thread, regno);
    }
}
@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@d2 2
a3 1
   Copyright 1992, 1995, 1996, 1998, 2000, 2001
d31 1
d64 3
a66 2
/* Get the whole floating-point state of THREAD and record the
   values of the corresponding (pseudo) registers.  */
a83 1
    /* The floating-point state isn't initialized.  */
d85 7
a91 6
      int i;

      for (i = FP0_REGNUM; i <= FOP_REGNUM; i++)
	supply_register (i, NULL);

      return;
a92 3

  /* Supply the floating-point registers.  */
  i387_supply_fsave (current_regcache, -1, state.hw_state);
d103 1
a103 1
    supply_register (i, REG_ADDR (gregs, i));
d147 1
a147 1
	    supply_register (i, REG_ADDR (state, i));
d154 2
a155 1
	  supply_register (regno, REG_ADDR (state, regno));
d205 1
d247 1
a247 1
			   DEPRECATED_REGISTER_RAW_SIZE (check_regno)))
d254 2
a255 1
		  supply_register (check_regno, REG_ADDR (state, check_regno));
a260 4
#define fill(state, regno)                                               \
  memcpy (REG_ADDR(state, regno), &deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)],     \
          DEPRECATED_REGISTER_RAW_SIZE (regno))

d268 2
a269 2
	    if (deprecated_register_valid[i])
	      fill (state, i);
d275 2
a276 2
	  gdb_assert (deprecated_register_valid[regno]);
	  fill (state, regno);
a282 2

#undef fill
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d1 20
a20 18
/* Low level interface to I386 running the GNU Hurd
   Copyright (C) 1992, 1995, 1996 Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d25 1
d27 2
a29 1
#include <errno.h>
d32 1
d35 2
a36 1
#include <mach_error.h>
d39 1
d41 7
a47 19
/* Hmmm... Should this not be here?
 * Now for i386_float_info() target_has_execution
 */
#include <target.h>

/* @@@@@@ Should move print_387_status() to i387-tdep.c */
extern void print_387_control_word ();		/* i387-tdep.h */
extern void print_387_status_word ();

/* Find offsets to thread states at compile time.
 * If your compiler does not grok this, calculate offsets
 * offsets yourself and use them (or get a compatible compiler :-)
 */

#define  REG_OFFSET(reg) (int)(&((struct i386_thread_state *)0)->reg)

/* at reg_offset[i] is the offset to the i386_thread_state
 * location where the gdb registers[i] is stored.
 */
d49 3
a51 1
static int reg_offset[] = 
d53 4
a56 4
  REG_OFFSET(eax),  REG_OFFSET(ecx), REG_OFFSET(edx), REG_OFFSET(ebx),
  REG_OFFSET(uesp), REG_OFFSET(ebp), REG_OFFSET(esi), REG_OFFSET(edi),
  REG_OFFSET(eip),  REG_OFFSET(efl), REG_OFFSET(cs),  REG_OFFSET(ss),
  REG_OFFSET(ds),   REG_OFFSET(es),  REG_OFFSET(fs),  REG_OFFSET(gs)
d59 1
a59 1
#define REG_ADDR(state,regnum) ((char *)(state)+reg_offset[regnum])
a60 13
/* Fetch COUNT contiguous registers from thread STATE starting from REGNUM
 * Caller knows that the regs handled in one transaction are of same size.
 */
#define FETCH_REGS(state, regnum, count) \
  memcpy (&registers[REGISTER_BYTE (regnum)], \
	  REG_ADDR (state, regnum), \
	  count * REGISTER_RAW_SIZE (regnum))

/* Store COUNT contiguous registers to thread STATE starting from REGNUM */
#define STORE_REGS(state, regnum, count) \
  memcpy (REG_ADDR (state, regnum), \
	  &registers[REGISTER_BYTE (regnum)], \
	  count * REGISTER_RAW_SIZE (regnum))
d62 4
a65 6
/*
 * Fetch inferiors registers for gdb.
 * REG specifies which (as gdb views it) register, -1 for all.
 */
void
gnu_fetch_registers (int reg)
d67 7
a73 15
  struct proc *thread;
  thread_state_t state;
  
  inf_update_procs (current_inferior); /* Make sure we know about new threads.  */

  thread = inf_tid_to_thread (current_inferior, inferior_pid);
  if (! thread)
    error ("fetch inferior registers: %d: Invalid thread", inferior_pid);

  state = proc_get_state (thread, 0);

  if (! state)
    warning ("Couldn't fetch register %s from %s (invalid thread).",
	     reg_names[reg], proc_string (thread));
  else if (reg >= 0)
d75 3
a77 3
      proc_debug (thread, "fetching register: %s", reg_names[reg]);
      supply_register (reg, REG_ADDR(state, reg));
      thread->fetched_regs |= (1 << reg);
d79 3
a81 1
  else
d83 6
a88 4
      proc_debug (thread, "fetching all registers");
      for (reg = 0; reg < NUM_REGS; reg++) 
	supply_register (reg, REG_ADDR(state, reg));
      thread->fetched_regs = ~0;
d90 14
d105 9
a113 7

/* Store our register values back into the inferior.
 * If REG is -1, do this for all registers.
 * Otherwise, REG specifies which register
 *
 * On mach3 all registers are always saved in one call.
 */
d115 1
a115 2
gnu_store_registers (reg)
     int reg;
d118 10
a127 23
  int was_aborted, was_valid;
  thread_state_t state;
  thread_state_data_t old_state;
  
  inf_update_procs (current_inferior); /* Make sure we know about new threads.  */

  thread = inf_tid_to_thread (current_inferior, inferior_pid);
  if (! thread)
    error ("store inferior registers: %d: Invalid thread", inferior_pid);

  proc_debug (thread, "storing register %s.", reg_names[reg]);

  was_aborted = thread->aborted;
  was_valid = thread->state_valid;
  if (! was_aborted && was_valid)
    bcopy (&thread->state, &old_state, sizeof (old_state));

  state = proc_get_state (thread, 1);

  if (! state)
    warning ("Couldn't store register %s from %s (invalid thread).",
	     reg_names[reg], proc_string (thread));
  else
d129 5
a133 2
      if (! was_aborted && was_valid)
	/* See which registers have changed after aborting the thread.  */
d135 3
a137 16
	  int check_reg;
	  for (check_reg = 0; check_reg < NUM_REGS; check_reg++)
	    if ((thread->fetched_regs & (1 << check_reg))
		&& bcmp (REG_ADDR (&old_state, check_reg),
			 REG_ADDR (state, check_reg),
			 REGISTER_RAW_SIZE (check_reg)))
	      /* Register CHECK_REG has changed!  Ack!  */
	      {
		warning ("Register %s changed after thread was aborted.",
			 reg_names [check_reg]);
		if (reg >= 0 && reg != check_reg)
		  /* Update gdb's copy of the register.  */
		  supply_register (check_reg, REG_ADDR (state, check_reg));
		else
		  warning ("... also writing this register!  Suspicious...");
	      }
d140 1
a140 1
      if (reg >= 0)
d142 7
a148 2
	  proc_debug (thread, "storing register: %s", reg_names[reg]);
	  STORE_REGS (state, reg, 1);
d152 4
a155 3
	  proc_debug (thread, "storing all registers");
	  for (reg = 0; reg < NUM_REGS; reg++) 
	    STORE_REGS (state, reg, 1);
d158 7
d167 5
a171 6
/* jtv@@hut.fi: I copied and modified this 387 code from
 * gdb/i386-xdep.c. Modifications for Mach 3.0.
 *
 * i387 status dumper. See also i387-tdep.c
 */
struct env387 
d173 7
a179 30
  unsigned short control;
  unsigned short r0;
  unsigned short status;
  unsigned short r1;
  unsigned short tag;
  unsigned short r2;
  unsigned long eip;
  unsigned short code_seg;
  unsigned short opcode;
  unsigned long operand;
  unsigned short operand_seg;
  unsigned short r3;
  unsigned char regs[8][10];
};
/* This routine is machine independent?
 * Should move it to i387-tdep.c but you need to export struct env387
 */
static
print_387_status (status, ep)
     unsigned short status;
     struct env387 *ep;
{
  int i;
  int bothstatus;
  int top;
  int fpreg;
  unsigned char *p;
  
  bothstatus = ((status != 0) && (ep->status != 0));
  if (status != 0) 
d181 3
a183 3
      if (bothstatus)
	printf_unfiltered ("u: ");
      print_387_status_word (status);
d185 8
a192 2
  
  if (ep->status != 0) 
d194 3
a196 3
      if (bothstatus)
	printf_unfiltered ("e: ");
      print_387_status_word (ep->status);
d198 17
a214 13
  
  print_387_control_word (ep->control);
  printf_unfiltered ("last exception: ");
  printf_unfiltered ("opcode %s; ", local_hex_string(ep->opcode));
  printf_unfiltered ("pc %s:", local_hex_string(ep->code_seg));
  printf_unfiltered ("%s; ", local_hex_string(ep->eip));
  printf_unfiltered ("operand %s", local_hex_string(ep->operand_seg));
  printf_unfiltered (":%s\n", local_hex_string(ep->operand));
  
  top = (ep->status >> 11) & 7;
  
  printf_unfiltered ("regno  tag  msb              lsb  value\n");
  for (fpreg = 7; fpreg >= 0; fpreg--) 
d216 11
a226 5
      double val;
      
      printf_unfiltered ("%s %d: ", fpreg == top ? "=>" : "  ", fpreg);
      
      switch ((ep->tag >> (fpreg * 2)) & 3) 
d228 2
a229 4
	case 0: printf_unfiltered ("valid "); break;
	case 1: printf_unfiltered ("zero  "); break;
	case 2: printf_unfiltered ("trap  "); break;
	case 3: printf_unfiltered ("empty "); break;
a230 34
      for (i = 9; i >= 0; i--)
	printf_unfiltered ("%02x", ep->regs[fpreg][i]);
      
      floatformat_to_double (&floatformat_i387_ext, (char *)ep->regs[fpreg],
			       &val);
      printf_unfiltered ("  %g\n", val);
    }
  if (ep->r0)
    printf_unfiltered ("warning: reserved0 is %s\n", local_hex_string(ep->r0));
  if (ep->r1)
    printf_unfiltered ("warning: reserved1 is %s\n", local_hex_string(ep->r1));
  if (ep->r2)
    printf_unfiltered ("warning: reserved2 is %s\n", local_hex_string(ep->r2));
  if (ep->r3)
    printf_unfiltered ("warning: reserved3 is %s\n", local_hex_string(ep->r3));
}
	
/*
 * values that go into fp_kind (from <i386/fpreg.h>)
 */
#define FP_NO   0       /* no fp chip, no emulator (no fp support)      */
#define FP_SW   1       /* no fp chip, using software emulator          */
#define FP_HW   2       /* chip present bit                             */
#define FP_287  2       /* 80287 chip present                           */
#define FP_387  3       /* 80387 chip present                           */

typedef struct fpstate {
#if 1
  unsigned char	state[FP_STATE_BYTES]; /* "hardware" state */
#else
  struct env387	state;	/* Actually this */
#endif
  int status;		/* Duplicate status */
} *fpstate_t;
d232 8
a239 14
/* Mach 3 specific routines.
 */
static int
get_i387_state (fstate)
     struct fpstate *fstate;
{
  error_t err;
  thread_state_data_t state;
  unsigned int fsCnt = i386_FLOAT_STATE_COUNT;
  struct i386_float_state *fsp;
  struct proc *thread = inf_tid_to_thread (current_inferior, inferior_pid);
  
  if (!thread)
    error ("get_i387_state: Invalid thread");
d241 16
a256 1
  proc_abort (thread, 0);	/* Make sure THREAD's in a reasonable state. */
d258 3
a260 7
  err = thread_get_state (thread->port, i386_FLOAT_STATE, state, &fsCnt);
  if (err)
    {
      warning ("Can not get live floating point state: %s",
	       mach_error_string (err));
      return 0;
    }
d262 3
a264 4
  fsp = (struct i386_float_state *)state;
  /* The 387 chip (also 486 counts) or a software emulator? */
  if (!fsp->initialized || (fsp->fpkind != FP_387 && fsp->fpkind != FP_SW))
    return 0;
d266 1
a266 4
  /* Clear the target then copy thread's float state there.
     Make a copy of the status word, for some reason?
   */
  memset (fstate, 0, sizeof (struct fpstate));
d268 7
a274 1
  fstate->status = fsp->exc_status;
d276 3
a278 1
  memcpy (fstate->state, (char *)&fsp->hw_state, FP_STATE_BYTES);
d280 4
a283 2
  return 1;
}
d285 1
a285 12
/*
 * This is called by "info float" command
 */
void
i386_mach3_float_info()
{
  char buf [sizeof (struct fpstate) + 2 * sizeof (int)];
  int valid = 0;
  fpstate_t fps;
  
  if (target_has_execution)
    valid = get_i387_state (buf);
d287 1
a287 1
  if (!valid) 
d289 3
a291 2
      warning ("no floating point status saved");
      return;
a292 4
  
  fps = (fpstate_t) buf;

  print_387_status (fps->status, (struct env387 *)fps->state);
@


1.1
log
@file i386gnu-nat.c was initially added on branch CYGNUS.
@
text
@d1 357
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 293
/* Low level interface to i386 running the GNU Hurd.
   Copyright 1992, 1995, 1996, 1998, 2000, 2001
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "inferior.h"
#include "floatformat.h"
#include "regcache.h"

#include "gdb_assert.h"
#include <errno.h>
#include <stdio.h>

#include <mach.h>
#include <mach_error.h>
#include <mach/message.h>
#include <mach/exception.h>

#include "i386-tdep.h"

#include "gnu-nat.h"
#include "i387-tdep.h"

#ifdef HAVE_SYS_PROCFS_H
# include <sys/procfs.h>
# include "gregset.h"
#endif

/* Offset to the thread_state_t location where REG is stored.  */
#define REG_OFFSET(reg) offsetof (struct i386_thread_state, reg)

/* At REG_OFFSET[N] is the offset to the thread_state_t location where
   the GDB register N is stored.  */
static int reg_offset[] =
{
  REG_OFFSET (eax), REG_OFFSET (ecx), REG_OFFSET (edx), REG_OFFSET (ebx),
  REG_OFFSET (uesp), REG_OFFSET (ebp), REG_OFFSET (esi), REG_OFFSET (edi),
  REG_OFFSET (eip), REG_OFFSET (efl), REG_OFFSET (cs), REG_OFFSET (ss),
  REG_OFFSET (ds), REG_OFFSET (es), REG_OFFSET (fs), REG_OFFSET (gs)
};

#define REG_ADDR(state, regnum) ((char *)(state) + reg_offset[regnum])


/* Get the whole floating-point state of THREAD and record the
   values of the corresponding (pseudo) registers.  */
static void
fetch_fpregs (struct proc *thread)
{
  mach_msg_type_number_t count = i386_FLOAT_STATE_COUNT;
  struct i386_float_state state;
  error_t err;

  err = thread_get_state (thread->port, i386_FLOAT_STATE,
			  (thread_state_t) &state, &count);
  if (err)
    {
      warning ("Couldn't fetch floating-point state from %s",
	       proc_string (thread));
      return;
    }

  if (!state.initialized)
    /* The floating-point state isn't initialized.  */
    {
      int i;

      for (i = FP0_REGNUM; i <= FOP_REGNUM; i++)
	supply_register (i, NULL);

      return;
    }

  /* Supply the floating-point registers.  */
  i387_supply_fsave (current_regcache, -1, state.hw_state);
}

#ifdef HAVE_SYS_PROCFS_H
/* These two calls are used by the core-regset.c code for
   reading ELF core files.  */
void
supply_gregset (gdb_gregset_t *gregs)
{
  int i;
  for (i = 0; i < I386_NUM_GREGS; i++)
    supply_register (i, REG_ADDR (gregs, i));
}

void
supply_fpregset (gdb_fpregset_t *fpregs)
{
  i387_supply_fsave (current_regcache, -1, fpregs);
}
#endif

/* Fetch register REGNO, or all regs if REGNO is -1.  */
void
gnu_fetch_registers (int regno)
{
  struct proc *thread;

  /* Make sure we know about new threads.  */
  inf_update_procs (current_inferior);

  thread = inf_tid_to_thread (current_inferior, PIDGET (inferior_ptid));
  if (!thread)
    error ("Can't fetch registers from thread %d: No such thread",
	   PIDGET (inferior_ptid));

  if (regno < I386_NUM_GREGS || regno == -1)
    {
      thread_state_t state;

      /* This does the dirty work for us.  */
      state = proc_get_state (thread, 0);
      if (!state)
	{
	  warning ("Couldn't fetch registers from %s",
		   proc_string (thread));
	  return;
	}

      if (regno == -1)
	{
	  int i;

	  proc_debug (thread, "fetching all register");

	  for (i = 0; i < I386_NUM_GREGS; i++)
	    supply_register (i, REG_ADDR (state, i));
	  thread->fetched_regs = ~0;
	}
      else
	{
	  proc_debug (thread, "fetching register %s", REGISTER_NAME (regno));

	  supply_register (regno, REG_ADDR (state, regno));
	  thread->fetched_regs |= (1 << regno);
	}
    }

  if (regno >= I386_NUM_GREGS || regno == -1)
    {
      proc_debug (thread, "fetching floating-point registers");

      fetch_fpregs (thread);
    }
}


/* Store the whole floating-point state into THREAD using information
   from the corresponding (pseudo) registers.  */
static void
store_fpregs (struct proc *thread, int regno)
{
  mach_msg_type_number_t count = i386_FLOAT_STATE_COUNT;
  struct i386_float_state state;
  error_t err;

  err = thread_get_state (thread->port, i386_FLOAT_STATE,
			  (thread_state_t) &state, &count);
  if (err)
    {
      warning ("Couldn't fetch floating-point state from %s",
	       proc_string (thread));
      return;
    }

  /* FIXME: kettenis/2001-07-15: Is this right?  Should we somehow
     take into account DEPRECATED_REGISTER_VALID like the old code did?  */
  i387_fill_fsave (state.hw_state, regno);

  err = thread_set_state (thread->port, i386_FLOAT_STATE,
			  (thread_state_t) &state, i386_FLOAT_STATE_COUNT);
  if (err)
    {
      warning ("Couldn't store floating-point state into %s",
	       proc_string (thread));
      return;
    }
}

/* Store at least register REGNO, or all regs if REGNO == -1.  */
void
gnu_store_registers (int regno)
{
  struct proc *thread;

  /* Make sure we know about new threads.  */
  inf_update_procs (current_inferior);

  thread = inf_tid_to_thread (current_inferior, PIDGET (inferior_ptid));
  if (!thread)
    error ("Couldn't store registers into thread %d: No such thread",
	   PIDGET (inferior_ptid));

  if (regno < I386_NUM_GREGS || regno == -1)
    {
      thread_state_t state;
      thread_state_data_t old_state;
      int was_aborted = thread->aborted;
      int was_valid = thread->state_valid;
      int trace;

      if (!was_aborted && was_valid)
	memcpy (&old_state, &thread->state, sizeof (old_state));

      state = proc_get_state (thread, 1);
      if (!state)
	{
	  warning ("Couldn't store registers into %s", proc_string (thread));
	  return;
	}

      /* Save the T bit.  We might try to restore the %eflags register
         below, but changing the T bit would seriously confuse GDB.  */
      trace = ((struct i386_thread_state *)state)->efl & 0x100;

      if (!was_aborted && was_valid)
	/* See which registers have changed after aborting the thread.  */
	{
	  int check_regno;

	  for (check_regno = 0; check_regno < I386_NUM_GREGS; check_regno++)
	    if ((thread->fetched_regs & (1 << check_regno))
		&& memcpy (REG_ADDR (&old_state, check_regno),
			   REG_ADDR (state, check_regno),
			   DEPRECATED_REGISTER_RAW_SIZE (check_regno)))
	      /* Register CHECK_REGNO has changed!  Ack!  */
	      {
		warning ("Register %s changed after the thread was aborted",
			 REGISTER_NAME (check_regno));
		if (regno >= 0 && regno != check_regno)
		  /* Update GDB's copy of the register.  */
		  supply_register (check_regno, REG_ADDR (state, check_regno));
		else
		  warning ("... also writing this register!  Suspicious...");
	      }
	}

#define fill(state, regno)                                               \
  memcpy (REG_ADDR(state, regno), &deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)],     \
          DEPRECATED_REGISTER_RAW_SIZE (regno))

      if (regno == -1)
	{
	  int i;

	  proc_debug (thread, "storing all registers");

	  for (i = 0; i < I386_NUM_GREGS; i++)
	    if (deprecated_register_valid[i])
	      fill (state, i);
	}
      else
	{
	  proc_debug (thread, "storing register %s", REGISTER_NAME (regno));

	  gdb_assert (deprecated_register_valid[regno]);
	  fill (state, regno);
	}

      /* Restore the T bit.  */
      ((struct i386_thread_state *)state)->efl &= ~0x100;
      ((struct i386_thread_state *)state)->efl |= trace;
    }

#undef fill

  if (regno >= I386_NUM_GREGS || regno == -1)
    {
      proc_debug (thread, "storing floating-point registers");

      store_fpregs (thread, regno);
    }
}
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d2 1
a2 2

   Copyright 1992, 1995, 1996, 1998, 2000, 2001, 2004
a29 1
#include "gdb_string.h"
d62 2
a63 3
/* Get the whole floating-point state of THREAD and record the values
   of the corresponding (pseudo) registers.  */

d81 1
d83 6
a88 7
      /* The floating-point state isn't initialized.  */
      i387_supply_fsave (current_regcache, -1, NULL);
    }
  else
    {
      /* Supply the floating-point registers.  */
      i387_supply_fsave (current_regcache, -1, state.hw_state);
d90 3
d103 1
a103 1
    regcache_raw_supply (current_regcache, i, REG_ADDR (gregs, i));
d147 1
a147 1
	    regcache_raw_supply (current_regcache, i, REG_ADDR (state, i));
d154 1
a154 2
	  regcache_raw_supply (current_regcache, regno,
			       REG_ADDR (state, regno));
a203 1
  struct regcache *regcache = current_regcache;
d245 1
a245 1
			   register_size (current_gdbarch, check_regno)))
d252 1
a252 2
		  regcache_raw_supply (regcache, check_regno,
				       REG_ADDR (state, check_regno));
d258 4
d269 2
a270 2
	    if (regcache_valid_p (regcache, i))
	      regcache_raw_collect (regcache, i, REG_ADDR (state, i));
d276 2
a277 2
	  gdb_assert (regcache_valid_p (regcache, regno));
	  regcache_raw_collect (regcache, regno, REG_ADDR (state, regno));
d284 2
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 357
/* Low level interface to I386 running the GNU Hurd
   Copyright (C) 1992, 1995, 1996 Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "inferior.h"
#include "floatformat.h"

#include <stdio.h>
#include <errno.h>

#include <mach.h>
#include <mach/message.h>
#include <mach/exception.h>
#include <mach_error.h>

#include "gnu-nat.h"

/* Hmmm... Should this not be here?
 * Now for i386_float_info() target_has_execution
 */
#include <target.h>

/* @@@@@@ Should move print_387_status() to i387-tdep.c */
extern void print_387_control_word ();		/* i387-tdep.h */
extern void print_387_status_word ();

/* Find offsets to thread states at compile time.
 * If your compiler does not grok this, calculate offsets
 * offsets yourself and use them (or get a compatible compiler :-)
 */

#define  REG_OFFSET(reg) (int)(&((struct i386_thread_state *)0)->reg)

/* at reg_offset[i] is the offset to the i386_thread_state
 * location where the gdb registers[i] is stored.
 */

static int reg_offset[] = 
{
  REG_OFFSET(eax),  REG_OFFSET(ecx), REG_OFFSET(edx), REG_OFFSET(ebx),
  REG_OFFSET(uesp), REG_OFFSET(ebp), REG_OFFSET(esi), REG_OFFSET(edi),
  REG_OFFSET(eip),  REG_OFFSET(efl), REG_OFFSET(cs),  REG_OFFSET(ss),
  REG_OFFSET(ds),   REG_OFFSET(es),  REG_OFFSET(fs),  REG_OFFSET(gs)
};

#define REG_ADDR(state,regnum) ((char *)(state)+reg_offset[regnum])

/* Fetch COUNT contiguous registers from thread STATE starting from REGNUM
 * Caller knows that the regs handled in one transaction are of same size.
 */
#define FETCH_REGS(state, regnum, count) \
  memcpy (&registers[REGISTER_BYTE (regnum)], \
	  REG_ADDR (state, regnum), \
	  count * REGISTER_RAW_SIZE (regnum))

/* Store COUNT contiguous registers to thread STATE starting from REGNUM */
#define STORE_REGS(state, regnum, count) \
  memcpy (REG_ADDR (state, regnum), \
	  &registers[REGISTER_BYTE (regnum)], \
	  count * REGISTER_RAW_SIZE (regnum))

/*
 * Fetch inferiors registers for gdb.
 * REG specifies which (as gdb views it) register, -1 for all.
 */
void
gnu_fetch_registers (int reg)
{
  struct proc *thread;
  thread_state_t state;
  
  inf_update_procs (current_inferior); /* Make sure we know about new threads.  */

  thread = inf_tid_to_thread (current_inferior, inferior_pid);
  if (! thread)
    error ("fetch inferior registers: %d: Invalid thread", inferior_pid);

  state = proc_get_state (thread, 0);

  if (! state)
    warning ("Couldn't fetch register %s from %s (invalid thread).",
	     reg_names[reg], proc_string (thread));
  else if (reg >= 0)
    {
      proc_debug (thread, "fetching register: %s", reg_names[reg]);
      supply_register (reg, REG_ADDR(state, reg));
      thread->fetched_regs |= (1 << reg);
    }
  else
    {
      proc_debug (thread, "fetching all registers");
      for (reg = 0; reg < NUM_REGS; reg++) 
	supply_register (reg, REG_ADDR(state, reg));
      thread->fetched_regs = ~0;
    }
}

/* Store our register values back into the inferior.
 * If REG is -1, do this for all registers.
 * Otherwise, REG specifies which register
 *
 * On mach3 all registers are always saved in one call.
 */
void
gnu_store_registers (reg)
     int reg;
{
  struct proc *thread;
  int was_aborted, was_valid;
  thread_state_t state;
  thread_state_data_t old_state;
  
  inf_update_procs (current_inferior); /* Make sure we know about new threads.  */

  thread = inf_tid_to_thread (current_inferior, inferior_pid);
  if (! thread)
    error ("store inferior registers: %d: Invalid thread", inferior_pid);

  proc_debug (thread, "storing register %s.", reg_names[reg]);

  was_aborted = thread->aborted;
  was_valid = thread->state_valid;
  if (! was_aborted && was_valid)
    bcopy (&thread->state, &old_state, sizeof (old_state));

  state = proc_get_state (thread, 1);

  if (! state)
    warning ("Couldn't store register %s from %s (invalid thread).",
	     reg_names[reg], proc_string (thread));
  else
    {
      if (! was_aborted && was_valid)
	/* See which registers have changed after aborting the thread.  */
	{
	  int check_reg;
	  for (check_reg = 0; check_reg < NUM_REGS; check_reg++)
	    if ((thread->fetched_regs & (1 << check_reg))
		&& bcmp (REG_ADDR (&old_state, check_reg),
			 REG_ADDR (state, check_reg),
			 REGISTER_RAW_SIZE (check_reg)))
	      /* Register CHECK_REG has changed!  Ack!  */
	      {
		warning ("Register %s changed after thread was aborted.",
			 reg_names [check_reg]);
		if (reg >= 0 && reg != check_reg)
		  /* Update gdb's copy of the register.  */
		  supply_register (check_reg, REG_ADDR (state, check_reg));
		else
		  warning ("... also writing this register!  Suspicious...");
	      }
	}

      if (reg >= 0)
	{
	  proc_debug (thread, "storing register: %s", reg_names[reg]);
	  STORE_REGS (state, reg, 1);
	}
      else
	{
	  proc_debug (thread, "storing all registers");
	  for (reg = 0; reg < NUM_REGS; reg++) 
	    STORE_REGS (state, reg, 1);
	}
    }
}

/* jtv@@hut.fi: I copied and modified this 387 code from
 * gdb/i386-xdep.c. Modifications for Mach 3.0.
 *
 * i387 status dumper. See also i387-tdep.c
 */
struct env387 
{
  unsigned short control;
  unsigned short r0;
  unsigned short status;
  unsigned short r1;
  unsigned short tag;
  unsigned short r2;
  unsigned long eip;
  unsigned short code_seg;
  unsigned short opcode;
  unsigned long operand;
  unsigned short operand_seg;
  unsigned short r3;
  unsigned char regs[8][10];
};
/* This routine is machine independent?
 * Should move it to i387-tdep.c but you need to export struct env387
 */
static
print_387_status (status, ep)
     unsigned short status;
     struct env387 *ep;
{
  int i;
  int bothstatus;
  int top;
  int fpreg;
  unsigned char *p;
  
  bothstatus = ((status != 0) && (ep->status != 0));
  if (status != 0) 
    {
      if (bothstatus)
	printf_unfiltered ("u: ");
      print_387_status_word (status);
    }
  
  if (ep->status != 0) 
    {
      if (bothstatus)
	printf_unfiltered ("e: ");
      print_387_status_word (ep->status);
    }
  
  print_387_control_word (ep->control);
  printf_unfiltered ("last exception: ");
  printf_unfiltered ("opcode %s; ", local_hex_string(ep->opcode));
  printf_unfiltered ("pc %s:", local_hex_string(ep->code_seg));
  printf_unfiltered ("%s; ", local_hex_string(ep->eip));
  printf_unfiltered ("operand %s", local_hex_string(ep->operand_seg));
  printf_unfiltered (":%s\n", local_hex_string(ep->operand));
  
  top = (ep->status >> 11) & 7;
  
  printf_unfiltered ("regno  tag  msb              lsb  value\n");
  for (fpreg = 7; fpreg >= 0; fpreg--) 
    {
      double val;
      
      printf_unfiltered ("%s %d: ", fpreg == top ? "=>" : "  ", fpreg);
      
      switch ((ep->tag >> (fpreg * 2)) & 3) 
	{
	case 0: printf_unfiltered ("valid "); break;
	case 1: printf_unfiltered ("zero  "); break;
	case 2: printf_unfiltered ("trap  "); break;
	case 3: printf_unfiltered ("empty "); break;
	}
      for (i = 9; i >= 0; i--)
	printf_unfiltered ("%02x", ep->regs[fpreg][i]);
      
      floatformat_to_double (&floatformat_i387_ext, (char *)ep->regs[fpreg],
			       &val);
      printf_unfiltered ("  %g\n", val);
    }
  if (ep->r0)
    printf_unfiltered ("warning: reserved0 is %s\n", local_hex_string(ep->r0));
  if (ep->r1)
    printf_unfiltered ("warning: reserved1 is %s\n", local_hex_string(ep->r1));
  if (ep->r2)
    printf_unfiltered ("warning: reserved2 is %s\n", local_hex_string(ep->r2));
  if (ep->r3)
    printf_unfiltered ("warning: reserved3 is %s\n", local_hex_string(ep->r3));
}
	
/*
 * values that go into fp_kind (from <i386/fpreg.h>)
 */
#define FP_NO   0       /* no fp chip, no emulator (no fp support)      */
#define FP_SW   1       /* no fp chip, using software emulator          */
#define FP_HW   2       /* chip present bit                             */
#define FP_287  2       /* 80287 chip present                           */
#define FP_387  3       /* 80387 chip present                           */

typedef struct fpstate {
#if 1
  unsigned char	state[FP_STATE_BYTES]; /* "hardware" state */
#else
  struct env387	state;	/* Actually this */
#endif
  int status;		/* Duplicate status */
} *fpstate_t;

/* Mach 3 specific routines.
 */
static int
get_i387_state (fstate)
     struct fpstate *fstate;
{
  error_t err;
  thread_state_data_t state;
  unsigned int fsCnt = i386_FLOAT_STATE_COUNT;
  struct i386_float_state *fsp;
  struct proc *thread = inf_tid_to_thread (current_inferior, inferior_pid);
  
  if (!thread)
    error ("get_i387_state: Invalid thread");

  proc_abort (thread, 0);	/* Make sure THREAD's in a reasonable state. */

  err = thread_get_state (thread->port, i386_FLOAT_STATE, state, &fsCnt);
  if (err)
    {
      warning ("Can not get live floating point state: %s",
	       mach_error_string (err));
      return 0;
    }

  fsp = (struct i386_float_state *)state;
  /* The 387 chip (also 486 counts) or a software emulator? */
  if (!fsp->initialized || (fsp->fpkind != FP_387 && fsp->fpkind != FP_SW))
    return 0;

  /* Clear the target then copy thread's float state there.
     Make a copy of the status word, for some reason?
   */
  memset (fstate, 0, sizeof (struct fpstate));

  fstate->status = fsp->exc_status;

  memcpy (fstate->state, (char *)&fsp->hw_state, FP_STATE_BYTES);

  return 1;
}

/*
 * This is called by "info float" command
 */
void
i386_mach3_float_info()
{
  char buf [sizeof (struct fpstate) + 2 * sizeof (int)];
  int valid = 0;
  fpstate_t fps;
  
  if (target_has_execution)
    valid = get_i387_state (buf);

  if (!valid) 
    {
      warning ("no floating point status saved");
      return;
    }
  
  fps = (fpstate_t) buf;

  print_387_status (fps->status, (struct env387 *)fps->state);
}
@
