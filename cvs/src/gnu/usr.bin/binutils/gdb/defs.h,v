head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.46
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.48
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.44
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.40
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.42
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.34
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.38
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.36
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.32
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.30
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.28
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.26
	OPENBSD_5_0:1.7.0.24
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.22
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.20
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.16
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.18
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.14
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.12
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.10
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.8
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.6
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.4
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.7
date	2005.12.03.10.34.15;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.27.14.00.34;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.02.20.45.34;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.21.20.23.05;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.10.19.39.41;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.37.08;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.17.20;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.09.48;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.05.46;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.17.21;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Threads support.
@
text
@/* *INDENT-OFF* */ /* ATTR_FORMAT confuses indent, avoid running it for now */
/* Basic, host-specific, and target-specific definitions for GDB.
   Copyright 1986, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#ifndef DEFS_H
#define DEFS_H

#include "config.h"		/* Generated by configure.  */

#include <stdio.h>
#include <errno.h>		/* System call error return status.  */
#include <limits.h>

#ifdef HAVE_STDDEF_H
#include <stddef.h>
#else
#include <sys/types.h>		/* For size_t.  */
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

/* First include ansidecl.h so we can use the various macro definitions
   here and in all subsequent file inclusions.  */

#include "ansidecl.h"

#include "gdb_locale.h"

/* For ``enum target_signal''.  */
#include "gdb/signals.h"

/* Just in case they're not defined in stdio.h.  */

#ifndef SEEK_SET
#define SEEK_SET 0
#endif
#ifndef SEEK_CUR
#define SEEK_CUR 1
#endif

#include <stdarg.h>		/* For va_list.  */

#include "libiberty.h"

/* For BFD64 and bfd_vma.  */
#include "bfd.h"

/* An address in the program being debugged.  Host byte order.  Rather
   than duplicate all the logic in BFD which figures out what type
   this is (long, long long, etc.) and whether it needs to be 64
   bits (the host/target interactions are subtle), we just use
   bfd_vma.  */

typedef bfd_vma CORE_ADDR;

/* This is to make sure that LONGEST is at least as big as CORE_ADDR.  */

#ifndef LONGEST

#ifdef BFD64

#define LONGEST BFD_HOST_64_BIT
#define ULONGEST BFD_HOST_U_64_BIT

#else /* No BFD64 */

#ifdef CC_HAS_LONG_LONG
#define LONGEST long long
#define ULONGEST unsigned long long
#else
#ifdef BFD_HOST_64_BIT
/* BFD_HOST_64_BIT is defined for some hosts that don't have long long
   (e.g. i386-windows) so try it.  */
#define LONGEST BFD_HOST_64_BIT
#define ULONGEST BFD_HOST_U_64_BIT
#else
#define LONGEST long
#define ULONGEST unsigned long
#endif
#endif

#endif /* No BFD64 */

#endif /* ! LONGEST */

#ifndef min
#define min(a, b) ((a) < (b) ? (a) : (b))
#endif
#ifndef max
#define max(a, b) ((a) > (b) ? (a) : (b))
#endif

/* Macros to do string compares.

   NOTE: cagney/2000-03-14:

   While old code can continue to refer to these macros, new code is
   probably better off using strcmp() directly vis: ``strcmp() == 0''
   and ``strcmp() != 0''.

   This is because modern compilers can directly inline strcmp()
   making the original justification for these macros - avoid function
   call overhead by pre-testing the first characters
   (``*X==*Y?...:0'') - redundant.

   ``Even if [...] testing the first character does have a modest
   performance improvement, I'd rather that whenever a performance
   issue is found that we spend the effort on algorithmic
   optimizations than micro-optimizing.'' J.T. */

/* NOTE: cagney/2003-11-23: All instances of STREQ[N] covered by
   testing GDB on a stabs system have been replaced by equivalent
   str[n]cmp calls.  To avoid the possability of introducing bugs when
   making untested changes, the remaining references were deprecated
   rather than replaced.  */

/* DISCLAIMER: cagney/2003-11-23: Simplified definition of these
   macros so that they just map directly onto strcmp equivalent.  I'm
   not responsible for any breakage due to code that relied on the old
   underlying implementation.  */

#define DEPRECATED_STREQ(a,b) (strcmp ((a), (b)) == 0)
#define DEPRECATED_STREQN(a,b,c) (strncmp ((a), (b), (c)) == 0)

/* Check if a character is one of the commonly used C++ marker characters.  */
extern int is_cplus_marker (int);

/* enable xdb commands if set */
extern int xdb_commands;

/* enable dbx commands if set */
extern int dbx_commands;

/* System root path, used to find libraries etc.  */
extern char *gdb_sysroot;

extern int quit_flag;
extern int immediate_quit;
extern int sevenbit_strings;

extern void quit (void);

/* FIXME: cagney/2000-03-13: It has been suggested that the peformance
   benefits of having a ``QUIT'' macro rather than a function are
   marginal.  If the overhead of a QUIT function call is proving
   significant then its calling frequency should probably be reduced
   [kingdon].  A profile analyzing the current situtation is
   needed. */

#ifdef QUIT
/* do twice to force compiler warning */
#define QUIT_FIXME "FIXME"
#define QUIT_FIXME "ignoring redefinition of QUIT"
#else
#define QUIT { \
  if (quit_flag) quit (); \
  if (deprecated_interactive_hook) deprecated_interactive_hook (); \
}
#endif

/* Languages represented in the symbol table and elsewhere.
   This should probably be in language.h, but since enum's can't
   be forward declared to satisfy opaque references before their
   actual definition, needs to be here. */

enum language
  {
    language_unknown,		/* Language not known */
    language_auto,		/* Placeholder for automatic setting */
    language_c,			/* C */
    language_cplus,		/* C++ */
    language_objc,		/* Objective-C */
    language_java,		/* Java */
    language_fortran,		/* Fortran */
    language_m2,		/* Modula-2 */
    language_asm,		/* Assembly language */
    language_scm,    		/* Scheme / Guile */
    language_pascal,		/* Pascal */
    language_ada,		/* Ada */
    language_minimal,		/* All other languages, minimal support only */
    nr_languages
  };

enum precision_type
  {
    single_precision,
    double_precision,
    unspecified_precision
  };

/* A generic, not quite boolean, enumeration.  */
enum auto_boolean
{
  AUTO_BOOLEAN_TRUE,
  AUTO_BOOLEAN_FALSE,
  AUTO_BOOLEAN_AUTO
};

/* Potential ways that a function can return a value of a given type.  */
enum return_value_convention
{
  /* Where the return value has been squeezed into one or more
     registers.  */
  RETURN_VALUE_REGISTER_CONVENTION,
  /* Commonly known as the "struct return convention".  The caller
     passes an additional hidden first parameter to the caller.  That
     parameter contains the address at which the value being returned
     should be stored.  While typically, and historically, used for
     large structs, this is convention is applied to values of many
     different types.  */
  RETURN_VALUE_STRUCT_CONVENTION,
  /* Like the "struct return convention" above, but where the ABI
     guarantees that the called function stores the address at which
     the value being returned is stored in a well-defined location,
     such as a register or memory slot in the stack frame.  Don't use
     this if the ABI doesn't explicitly guarantees this.  */
  RETURN_VALUE_ABI_RETURNS_ADDRESS,
  /* Like the "struct return convention" above, but where the ABI
     guarantees that the address at which the value being returned is
     stored will be available in a well-defined location, such as a
     register or memory slot in the stack frame.  Don't use this if
     the ABI doesn't explicitly guarantees this.  */
  RETURN_VALUE_ABI_PRESERVES_ADDRESS,
};

/* the cleanup list records things that have to be undone
   if an error happens (descriptors to be closed, memory to be freed, etc.)
   Each link in the chain records a function to call and an
   argument to give it.

   Use make_cleanup to add an element to the cleanup chain.
   Use do_cleanups to do all cleanup actions back to a given
   point in the chain.  Use discard_cleanups to remove cleanups
   from the chain back to a given point, not doing them.  */

struct cleanup
  {
    struct cleanup *next;
    void (*function) (void *);
    void *arg;
  };


/* The ability to declare that a function never returns is useful, but
   not really required to compile GDB successfully, so the NORETURN and
   ATTR_NORETURN macros normally expand into nothing.  */

/* If compiling with older versions of GCC, a function may be declared
   "volatile" to indicate that it does not return.  */

#ifndef NORETURN
#if defined(__GNUC__) \
     && (__GNUC__ == 1 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7))
#define NORETURN volatile
#else
#define NORETURN		/* nothing */
#endif
#endif

/* GCC 2.5 and later versions define a function attribute "noreturn",
   which is the preferred way to declare that a function never returns.
   However GCC 2.7 appears to be the first version in which this fully
   works everywhere we use it. */

#ifndef ATTR_NORETURN
#if defined(__GNUC__) && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7))
#define ATTR_NORETURN __attribute__ ((noreturn))
#else
#define ATTR_NORETURN		/* nothing */
#endif
#endif

#ifndef ATTR_FORMAT
#if defined(__GNUC__) && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 4))
#define ATTR_FORMAT(type, x, y) __attribute__ ((format(type, x, y)))
#else
#define ATTR_FORMAT(type, x, y)	/* nothing */
#endif
#endif

/* Be conservative and use enum bitfields only with GCC.
   This is copied from gcc 3.3.1, system.h.  */

#if defined(__GNUC__) && (__GNUC__ >= 2)
#define ENUM_BITFIELD(TYPE) enum TYPE
#else
#define ENUM_BITFIELD(TYPE) unsigned int
#endif

/* Needed for various prototypes */

struct symtab;
struct breakpoint;
struct frame_info;

/* From blockframe.c */

extern int inside_entry_func (struct frame_info *this_frame);

/* From utils.c */

extern void initialize_utils (void);

extern void notice_quit (void);

extern int strcmp_iw (const char *, const char *);

extern int strcmp_iw_ordered (const char *, const char *);

extern int streq (const char *, const char *);

extern int subset_compare (char *, char *);

extern char *safe_strerror (int);

extern void request_quit (int);

extern void do_cleanups (struct cleanup *);
extern void do_final_cleanups (struct cleanup *);
extern void do_run_cleanups (struct cleanup *);
extern void do_exec_cleanups (struct cleanup *);
extern void do_exec_error_cleanups (struct cleanup *);

extern void discard_cleanups (struct cleanup *);
extern void discard_final_cleanups (struct cleanup *);
extern void discard_exec_error_cleanups (struct cleanup *);
extern void discard_my_cleanups (struct cleanup **, struct cleanup *);

/* NOTE: cagney/2000-03-04: This typedef is strictly for the
   make_cleanup function declarations below. Do not use this typedef
   as a cast when passing functions into the make_cleanup() code.
   Instead either use a bounce function or add a wrapper function.
   Calling a f(char*) function with f(void*) is non-portable. */
typedef void (make_cleanup_ftype) (void *);

extern struct cleanup *make_cleanup (make_cleanup_ftype *, void *);

extern struct cleanup *make_cleanup_freeargv (char **);

struct ui_file;
extern struct cleanup *make_cleanup_ui_file_delete (struct ui_file *);

struct section_addr_info;
extern struct cleanup *(make_cleanup_free_section_addr_info 
                        (struct section_addr_info *));

extern struct cleanup *make_cleanup_close (int fd);

extern struct cleanup *make_cleanup_bfd_close (bfd *abfd);

extern struct cleanup *make_final_cleanup (make_cleanup_ftype *, void *);

extern struct cleanup *make_my_cleanup (struct cleanup **,
					make_cleanup_ftype *, void *);

extern struct cleanup *make_run_cleanup (make_cleanup_ftype *, void *);

extern struct cleanup *make_exec_cleanup (make_cleanup_ftype *, void *);
extern struct cleanup *make_exec_error_cleanup (make_cleanup_ftype *, void *);

extern struct cleanup *save_cleanups (void);
extern struct cleanup *save_final_cleanups (void);
extern struct cleanup *save_my_cleanups (struct cleanup **);

extern void restore_cleanups (struct cleanup *);
extern void restore_final_cleanups (struct cleanup *);
extern void restore_my_cleanups (struct cleanup **, struct cleanup *);

extern void free_current_contents (void *);

extern void null_cleanup (void *);

extern int myread (int, char *, int);

extern int query (const char *, ...) ATTR_FORMAT (printf, 1, 2);
extern int nquery (const char *, ...) ATTR_FORMAT (printf, 1, 2);
extern int yquery (const char *, ...) ATTR_FORMAT (printf, 1, 2);

extern void init_page_info (void);

extern char *gdb_realpath (const char *);
extern char *xfullpath (const char *);

extern unsigned long gnu_debuglink_crc32 (unsigned long crc,
                                          unsigned char *buf, size_t len);

/* From demangle.c */

extern void set_demangling_style (char *);

/* From tm.h */

struct type;
typedef int (use_struct_convention_fn) (int gcc_p, struct type * value_type);
extern use_struct_convention_fn generic_use_struct_convention;


/* Annotation stuff.  */

extern int annotation_level;	/* in stack.c */

extern void begin_line (void);

extern void wrap_here (char *);

extern void reinitialize_more_filter (void);

/* Normal results */
extern struct ui_file *gdb_stdout;
/* Input stream */
extern struct ui_file *gdb_stdin;
/* Serious error notifications */
extern struct ui_file *gdb_stderr;
/* Log/debug/trace messages that should bypass normal stdout/stderr
   filtering.  For moment, always call this stream using
   *_unfiltered. In the very near future that restriction shall be
   removed - either call shall be unfiltered. (cagney 1999-06-13). */
extern struct ui_file *gdb_stdlog;
/* Target output that should bypass normal stdout/stderr filtering.
   For moment, always call this stream using *_unfiltered. In the
   very near future that restriction shall be removed - either call
   shall be unfiltered. (cagney 1999-07-02). */
extern struct ui_file *gdb_stdtarg;
extern struct ui_file *gdb_stdtargerr;
extern struct ui_file *gdb_stdtargin;

#include "ui-file.h"

/* More generic printf like operations.  Filtered versions may return
   non-locally on error.  */

extern void fputs_filtered (const char *, struct ui_file *);

extern void fputs_unfiltered (const char *, struct ui_file *);

extern int fputc_filtered (int c, struct ui_file *);

extern int fputc_unfiltered (int c, struct ui_file *);

extern int putchar_filtered (int c);

extern int putchar_unfiltered (int c);

extern void puts_filtered (const char *);

extern void puts_unfiltered (const char *);

extern void puts_filtered_tabular (char *string, int width, int right);

extern void puts_debug (char *prefix, char *string, char *suffix);

extern void vprintf_filtered (const char *, va_list) ATTR_FORMAT (printf, 1, 0);

extern void vfprintf_filtered (struct ui_file *, const char *, va_list) ATTR_FORMAT (printf, 2, 0);

extern void fprintf_filtered (struct ui_file *, const char *, ...) ATTR_FORMAT (printf, 2, 3);

extern void fprintfi_filtered (int, struct ui_file *, const char *, ...) ATTR_FORMAT (printf, 3, 4);

extern void printf_filtered (const char *, ...) ATTR_FORMAT (printf, 1, 2);

extern void printfi_filtered (int, const char *, ...) ATTR_FORMAT (printf, 2, 3);

extern void vprintf_unfiltered (const char *, va_list) ATTR_FORMAT (printf, 1, 0);

extern void vfprintf_unfiltered (struct ui_file *, const char *, va_list) ATTR_FORMAT (printf, 2, 0);

extern void fprintf_unfiltered (struct ui_file *, const char *, ...) ATTR_FORMAT (printf, 2, 3);

extern void printf_unfiltered (const char *, ...) ATTR_FORMAT (printf, 1, 2);

extern void print_spaces (int, struct ui_file *);

extern void print_spaces_filtered (int, struct ui_file *);

extern char *n_spaces (int);

extern void fputstr_filtered (const char *str, int quotr, struct ui_file * stream);

extern void fputstr_unfiltered (const char *str, int quotr, struct ui_file * stream);

extern void fputstrn_unfiltered (const char *str, int n, int quotr, struct ui_file * stream);

/* Display the host ADDR on STREAM formatted as ``0x%x''. */
extern void gdb_print_host_address (const void *addr, struct ui_file *stream);

/* Convert a CORE_ADDR into a HEX string.  paddr() is like %08lx.
   paddr_nz() is like %lx.  paddr_u() is like %lu. paddr_width() is
   for ``%*''. */
extern int strlen_paddr (void);
extern char *paddr (CORE_ADDR addr);
extern char *paddr_nz (CORE_ADDR addr);
extern char *paddr_u (CORE_ADDR addr);
extern char *paddr_d (LONGEST addr);

extern char *phex (ULONGEST l, int sizeof_l);
extern char *phex_nz (ULONGEST l, int sizeof_l);
extern char *int_string (LONGEST, int, int, int, int);

/* Like paddr() only print/scan raw CORE_ADDR.  The output from
   core_addr_to_string() can be passed direct to
   string_to_core_addr().  */
extern const char *core_addr_to_string (const CORE_ADDR addr);
extern const char *core_addr_to_string_nz (const CORE_ADDR addr);
extern CORE_ADDR string_to_core_addr (const char *my_string);

/* Return a string that contains a number formatted as a hex
   string.  */
extern char *hex_string (LONGEST);
extern char *hex_string_custom (LONGEST, int);

extern void fprintf_symbol_filtered (struct ui_file *, char *,
				     enum language, int);

extern NORETURN void perror_with_name (const char *) ATTR_NORETURN;

extern void print_sys_errmsg (const char *, int);

/* From regex.c or libc.  BSD 4.4 declares this with the argument type as
   "const char *" in unistd.h, so we can't declare the argument
   as "char *".  */

extern char *re_comp (const char *);

/* From symfile.c */

extern void symbol_file_command (char *, int);

/* Remote targets may wish to use this as their load function.  */
extern void generic_load (char *name, int from_tty);

/* Summarise a download */
extern void print_transfer_performance (struct ui_file *stream,
					unsigned long data_count,
					unsigned long write_count,
					unsigned long time_count);

/* From top.c */

typedef void initialize_file_ftype (void);

extern char *skip_quoted (char *);

extern char *gdb_readline (char *);

extern char *gdb_readline_wrapper (char *);

extern char *command_line_input (char *, int, char *);

extern void print_prompt (void);

extern int input_from_terminal_p (void);

extern int info_verbose;

/* From printcmd.c */

extern void set_next_address (CORE_ADDR);

extern void print_address_symbolic (CORE_ADDR, struct ui_file *, int,
				    char *);

extern int build_address_symbolic (CORE_ADDR addr,
				   int do_demangle, 
				   char **name, 
				   int *offset, 
				   char **filename, 
				   int *line, 	
				   int *unmapped);

extern void print_address_numeric (CORE_ADDR, int, struct ui_file *);

extern void print_address (CORE_ADDR, struct ui_file *);

/* From source.c */

#define OPF_TRY_CWD_FIRST     0x01
#define OPF_SEARCH_IN_PATH    0x02

extern int openp (const char *, int, const char *, int, int, char **);

extern int source_full_path_of (char *, char **);

extern void mod_path (char *, char **);

extern void add_path (char *, char **, int);

extern void directory_command (char *, int);

extern char *source_path;

extern void init_source_path (void);

extern void init_last_source_visited (void);

/* From exec.c */

extern void exec_set_section_offsets (bfd_signed_vma text_off,
				      bfd_signed_vma data_off,
				      bfd_signed_vma bss_off);

/* Take over the 'find_mapped_memory' vector from exec.c. */
extern void exec_set_find_memory_regions (int (*) (int (*) (CORE_ADDR, 
							    unsigned long, 
							    int, int, int, 
							    void *),
						   void *));

/* Possible lvalue types.  Like enum language, this should be in
   value.h, but needs to be here for the same reason. */

enum lval_type
  {
    /* Not an lval. */
    not_lval,
    /* In memory.  Could be a saved register.  */
    lval_memory,
    /* In a register.  */
    lval_register,
    /* In a gdb internal variable.  */
    lval_internalvar,
    /* Part of a gdb internal variable (structure field).  */
    lval_internalvar_component,
    /* In a register series in a frame not the current one, which may have been
       partially saved or saved in different places (otherwise would be
       lval_register or lval_memory).  */
    lval_reg_frame_relative
  };

/* Control types for commands */

enum misc_command_type
  {
    ok_command,
    end_command,
    else_command,
    nop_command
  };

enum command_control_type
  {
    simple_control,
    break_control,
    continue_control,
    while_control,
    if_control,
    invalid_control
  };

/* Structure for saved commands lines
   (for breakpoints, defined commands, etc).  */

struct command_line
  {
    struct command_line *next;
    char *line;
    enum command_control_type control_type;
    int body_count;
    struct command_line **body_list;
  };

extern struct command_line *read_command_lines (char *, int);

extern void free_command_lines (struct command_line **);

/* To continue the execution commands when running gdb asynchronously. 
   A continuation structure contains a pointer to a function to be called 
   to finish the command, once the target has stopped. Such mechanism is
   used bt the finish and until commands, and in the remote protocol
   when opening an extended-remote connection. */

struct continuation_arg
  {
    struct continuation_arg *next;
    union continuation_data {
      void *pointer;
      int   integer;
      long  longint;
    } data;
  };

struct continuation
  {
    void (*continuation_hook) (struct continuation_arg *);
    struct continuation_arg *arg_list;
    struct continuation *next;
  };

/* In infrun.c. */
extern struct continuation *cmd_continuation;
/* Used only by the step_1 function. */
extern struct continuation *intermediate_continuation;

/* From utils.c */
extern void add_continuation (void (*)(struct continuation_arg *),
			      struct continuation_arg *);
extern void do_all_continuations (void);
extern void discard_all_continuations (void);

extern void add_intermediate_continuation (void (*)(struct continuation_arg *),
			      struct continuation_arg *);
extern void do_all_intermediate_continuations (void);
extern void discard_all_intermediate_continuations (void);

/* String containing the current directory (what getwd would return).  */

extern char *current_directory;

/* Default radixes for input and output.  Only some values supported.  */
extern unsigned input_radix;
extern unsigned output_radix;

/* Possibilities for prettyprint parameters to routines which print
   things.  Like enum language, this should be in value.h, but needs
   to be here for the same reason.  FIXME:  If we can eliminate this
   as an arg to LA_VAL_PRINT, then we can probably move it back to
   value.h. */

enum val_prettyprint
  {
    Val_no_prettyprint = 0,
    Val_prettyprint,
    /* Use the default setting which the user has specified.  */
    Val_pretty_default
  };

/* The ptid struct is a collection of the various "ids" necessary
   for identifying the inferior.  This consists of the process id
   (pid), thread id (tid), and other fields necessary for uniquely
   identifying the inferior process/thread being debugged.  When
   manipulating ptids, the constructors, accessors, and predicate
   declared in inferior.h should be used.  These are as follows:

      ptid_build	- Make a new ptid from a pid, lwp, and tid.
      pid_to_ptid	- Make a new ptid from just a pid.
      ptid_get_pid	- Fetch the pid component of a ptid.
      ptid_get_lwp	- Fetch the lwp component of a ptid.
      ptid_get_tid	- Fetch the tid component of a ptid.
      ptid_equal	- Test to see if two ptids are equal.

   Please do NOT access the struct ptid members directly (except, of
   course, in the implementation of the above ptid manipulation
   functions).  */

struct ptid
  {
    /* Process id */
    int pid;

    /* Lightweight process id */
    long lwp;

    /* Thread id */
    long tid;
  };

typedef struct ptid ptid_t;



/* Optional host machine definition.  Pure autoconf targets will not
   need a "xm.h" file.  This will be a symlink to one of the xm-*.h
   files, built by the `configure' script.  */

#ifdef GDB_XM_FILE
#include "xm.h"
#endif

/* Optional native machine support.  Non-native (and possibly pure
   multi-arch) targets do not need a "nm.h" file.  This will be a
   symlink to one of the nm-*.h files, built by the `configure'
   script.  */

#ifdef GDB_NM_FILE
#include "nm.h"
#endif

/* Optional target machine definition.  Pure multi-arch configurations
   do not need a "tm.h" file.  This will be a symlink to one of the
   tm-*.h files, built by the `configure' script.  */

#ifdef GDB_TM_FILE
#include "tm.h"
#endif

/* Assume that fopen accepts the letter "b" in the mode string.
   Support for is demanded by ISO C90, and should be supported on all
   platforms that claim to have a standards conforming C library.  On
   true POSIX systems it will be ignored and have no effect.  There
   may still be systems without a standards conforming C library where
   an ISO C90 compiler (GCC) is available.  Known examples are SunOS
   4.x and 4.3BSD.  This assumption means these systems are no longer
   supported.  */
#ifndef FOPEN_RB
# include "fopen-bin.h"
#endif

/* Defaults for system-wide constants (if not defined by xm.h, we fake it).
   FIXME: Assumes 2's complement arithmetic */

#if !defined (UINT_MAX)
#define	UINT_MAX ((unsigned int)(~0))	/* 0xFFFFFFFF for 32-bits */
#endif

#if !defined (INT_MAX)
#define	INT_MAX ((int)(UINT_MAX >> 1))	/* 0x7FFFFFFF for 32-bits */
#endif

#if !defined (INT_MIN)
#define INT_MIN ((int)((int) ~0 ^ INT_MAX))	/* 0x80000000 for 32-bits */
#endif

#if !defined (ULONG_MAX)
#define	ULONG_MAX ((unsigned long)(~0L))	/* 0xFFFFFFFF for 32-bits */
#endif

#if !defined (LONG_MAX)
#define	LONG_MAX ((long)(ULONG_MAX >> 1))	/* 0x7FFFFFFF for 32-bits */
#endif

#if !defined (ULONGEST_MAX)
#define	ULONGEST_MAX (~(ULONGEST)0)        /* 0xFFFFFFFFFFFFFFFF for 64-bits */
#endif

#if !defined (LONGEST_MAX)                 /* 0x7FFFFFFFFFFFFFFF for 64-bits */
#define	LONGEST_MAX ((LONGEST)(ULONGEST_MAX >> 1))
#endif

/* Convert a LONGEST to an int.  This is used in contexts (e.g. number of
   arguments to a function, number in a value history, register number, etc.)
   where the value must not be larger than can fit in an int.  */

extern int longest_to_int (LONGEST);

/* Assorted functions we can declare, now that const and volatile are 
   defined.  */

extern char *savestring (const char *, size_t);

/* xmalloc(), xrealloc() and xcalloc() have already been declared in
   "libiberty.h". */
extern void xfree (void *);

/* Utility macros to allocate typed memory.  Avoids errors like:
   struct foo *foo = xmalloc (sizeof struct bar); and memset (foo,
   sizeof (struct foo), 0).  */
#define XZALLOC(TYPE) ((TYPE*) memset (xmalloc (sizeof (TYPE)), 0, sizeof (TYPE)))
#define XMALLOC(TYPE) ((TYPE*) xmalloc (sizeof (TYPE)))
#define XCALLOC(NMEMB, TYPE) ((TYPE*) xcalloc ((NMEMB), sizeof (TYPE)))

/* Like asprintf/vasprintf but get an internal_error if the call
   fails. */
extern void xasprintf (char **ret, const char *format, ...) ATTR_FORMAT (printf, 2, 3);
extern void xvasprintf (char **ret, const char *format, va_list ap);

/* Like asprintf and vasprintf, but return the string, throw an error
   if no memory.  */
extern char *xstrprintf (const char *format, ...) ATTR_FORMAT (printf, 1, 2);
extern char *xstrvprintf (const char *format, va_list ap);

/* Like snprintf, but throw an error if the output buffer is too small.  */
extern int xsnprintf (char *str, size_t size, const char *format, ...)
     ATTR_FORMAT (printf, 3, 4);

extern int parse_escape (char **);

/* Message to be printed before the error message, when an error occurs.  */

extern char *error_pre_print;

/* Message to be printed before the error message, when an error occurs.  */

extern char *quit_pre_print;

/* Message to be printed before the warning message, when a warning occurs.  */

extern char *warning_pre_print;

extern NORETURN void verror (const char *fmt, va_list ap) ATTR_NORETURN;

extern NORETURN void error (const char *fmt, ...) ATTR_NORETURN ATTR_FORMAT (printf, 1, 2);

extern NORETURN void error_silent (const char *fmt, ...) ATTR_NORETURN ATTR_FORMAT (printf, 1, 2);

extern NORETURN void error_stream (struct ui_file *) ATTR_NORETURN;

/* Initialize the error buffer.  */
extern void error_init (void);

/* Returns a freshly allocate buffer containing the last error
   message.  */
extern char *error_last_message (void);

/* Output arbitrary error message.  */
extern void error_output_message (char *pre_print, char *msg);

extern NORETURN void internal_verror (const char *file, int line,
				      const char *, va_list ap) ATTR_NORETURN;

extern NORETURN void internal_error (const char *file, int line,
				     const char *, ...) ATTR_NORETURN ATTR_FORMAT (printf, 3, 4);

extern void internal_vwarning (const char *file, int line,
			       const char *, va_list ap);

extern void internal_warning (const char *file, int line,
			      const char *, ...) ATTR_FORMAT (printf, 3, 4);

extern NORETURN void nomem (long) ATTR_NORETURN;

/* Reasons for calling throw_exception().  NOTE: all reason values
   must be less than zero.  enum value 0 is reserved for internal use
   as the return value from an initial setjmp().  The function
   catch_exceptions() reserves values >= 0 as legal results from its
   wrapped function.  */

enum return_reason
  {
    /* User interrupt.  */
    RETURN_QUIT = -2,
    /* Any other error.  */
    RETURN_ERROR
  };

#define	ALL_CLEANUPS	((struct cleanup *)0)

#define RETURN_MASK(reason)	(1 << (int)(-reason))
#define RETURN_MASK_QUIT	RETURN_MASK (RETURN_QUIT)
#define RETURN_MASK_ERROR	RETURN_MASK (RETURN_ERROR)
#define RETURN_MASK_ALL		(RETURN_MASK_QUIT | RETURN_MASK_ERROR)
typedef int return_mask;

/* Throw an exception of type RETURN_REASON.  Will execute a LONG JUMP
   to the inner most containing exception handler established using
   catch_exceptions() (or the legacy catch_errors()).

   Code normally throws an exception using error() et.al.  For various
   reaons, GDB also contains code that throws an exception directly.
   For instance, the remote*.c targets contain CNTRL-C signal handlers
   that propogate the QUIT event up the exception chain.  ``This could
   be a good thing or a dangerous thing.'' -- the Existential Wombat.  */

extern NORETURN void throw_exception (enum return_reason) ATTR_NORETURN;

/* Call FUNC(UIOUT, FUNC_ARGS) but wrapped within an exception
   handler.  If an exception (enum return_reason) is thrown using
   throw_exception() than all cleanups installed since
   catch_exceptions() was entered are invoked, the (-ve) exception
   value is then returned by catch_exceptions.  If FUNC() returns
   normally (with a postive or zero return value) then that value is
   returned by catch_exceptions().  It is an internal_error() for
   FUNC() to return a negative value.

   For the period of the FUNC() call: UIOUT is installed as the output
   builder; ERRSTRING is installed as the error/quit message; and a
   new cleanup_chain is established.  The old values are restored
   before catch_exceptions() returns.

   The variant catch_exceptions_with_msg() is the same as
   catch_exceptions() but adds the ability to return an allocated
   copy of the gdb error message.  This is used when a silent error is 
   issued and the caller wants to manually issue the error message.

   FIXME; cagney/2001-08-13: The need to override the global UIOUT
   builder variable should just go away.

   This function superseeds catch_errors().

   This function uses SETJMP() and LONGJUMP().  */

struct ui_out;
typedef int (catch_exceptions_ftype) (struct ui_out *ui_out, void *args);
extern int catch_exceptions (struct ui_out *uiout,
			     catch_exceptions_ftype *func, void *func_args,
			     char *errstring, return_mask mask);
extern int catch_exceptions_with_msg (struct ui_out *uiout,
			     	      catch_exceptions_ftype *func, 
			     	      void *func_args,
			     	      char *errstring, char **gdberrmsg,
				      return_mask mask);

/* If CATCH_ERRORS_FTYPE throws an error, catch_errors() returns zero
   otherwize the result from CATCH_ERRORS_FTYPE is returned. It is
   probably useful for CATCH_ERRORS_FTYPE to always return a non-zero
   value. It's unfortunate that, catch_errors() does not return an
   indication of the exact exception that it caught - quit_flag might
   help.

   This function is superseeded by catch_exceptions().  */

typedef int (catch_errors_ftype) (void *);
extern int catch_errors (catch_errors_ftype *, void *, char *, return_mask);

/* Template to catch_errors() that wraps calls to command
   functions. */

typedef void (catch_command_errors_ftype) (char *, int);
extern int catch_command_errors (catch_command_errors_ftype *func, char *command, int from_tty, return_mask);

extern void warning (const char *, ...) ATTR_FORMAT (printf, 1, 2);

extern void vwarning (const char *, va_list args);

/* List of known OS ABIs.  If you change this, make sure to update the
   table in osabi.c.  */
enum gdb_osabi
{
  GDB_OSABI_UNINITIALIZED = -1, /* For struct gdbarch_info.  */

  GDB_OSABI_UNKNOWN = 0,	/* keep this zero */

  GDB_OSABI_SVR4,
  GDB_OSABI_HURD,
  GDB_OSABI_SOLARIS,
  GDB_OSABI_OSF1,
  GDB_OSABI_LINUX,
  GDB_OSABI_FREEBSD_AOUT,
  GDB_OSABI_FREEBSD_ELF,
  GDB_OSABI_NETBSD_AOUT,
  GDB_OSABI_NETBSD_ELF,
  GDB_OSABI_OPENBSD_ELF,
  GDB_OSABI_WINCE,
  GDB_OSABI_GO32,
  GDB_OSABI_NETWARE,
  GDB_OSABI_IRIX,
  GDB_OSABI_LYNXOS,
  GDB_OSABI_INTERIX,
  GDB_OSABI_HPUX_ELF,
  GDB_OSABI_HPUX_SOM,

  GDB_OSABI_ARM_EABI_V1,
  GDB_OSABI_ARM_EABI_V2,
  GDB_OSABI_ARM_APCS,
  GDB_OSABI_QNXNTO,

  GDB_OSABI_CYGWIN,

  GDB_OSABI_INVALID		/* keep this last */
};

/* Global functions from other, non-gdb GNU thingies.
   Libiberty thingies are no longer declared here.  We include libiberty.h
   above, instead.  */

/* From other system libraries */

#ifdef HAVE_STDDEF_H
#include <stddef.h>
#endif

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifndef min
#define min(a, b) ((a) < (b) ? (a) : (b))
#endif
#ifndef max
#define max(a, b) ((a) > (b) ? (a) : (b))
#endif


#ifndef atof
extern double atof (const char *);	/* X3.159-1989  4.10.1.1 */
#endif

/* Various possibilities for alloca.  */
#ifndef alloca
#ifdef __GNUC__
#define alloca __builtin_alloca
#else /* Not GNU C */
#ifdef HAVE_ALLOCA_H
#include <alloca.h>
#else
#ifdef _AIX
#pragma alloca
#else

/* We need to be careful not to declare this in a way which conflicts with
   bison.  Bison never declares it as char *, but under various circumstances
   (like __hpux) we need to use void *.  */
extern void *alloca ();
#endif /* Not _AIX */
#endif /* Not HAVE_ALLOCA_H */
#endif /* Not GNU C */
#endif /* alloca not defined */

/* Dynamic target-system-dependent parameters for GDB. */
#include "gdbarch.h"

/* Maximum size of a register.  Something small, but large enough for
   all known ISAs.  If it turns out to be too small, make it bigger.  */

enum { MAX_REGISTER_SIZE = 16 };

/* Static target-system-dependent parameters for GDB. */

/* Number of bits in a char or unsigned char for the target machine.
   Just like CHAR_BIT in <limits.h> but describes the target machine.  */
#if !defined (TARGET_CHAR_BIT)
#define TARGET_CHAR_BIT 8
#endif

/* If we picked up a copy of CHAR_BIT from a configuration file
   (which may get it by including <limits.h>) then use it to set
   the number of bits in a host char.  If not, use the same size
   as the target. */

#if defined (CHAR_BIT)
#define HOST_CHAR_BIT CHAR_BIT
#else
#define HOST_CHAR_BIT TARGET_CHAR_BIT
#endif

/* The bit byte-order has to do just with numbering of bits in
   debugging symbols and such.  Conceptually, it's quite separate
   from byte/word byte order.  */

#if !defined (BITS_BIG_ENDIAN)
#define BITS_BIG_ENDIAN (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
#endif

/* In findvar.c.  */

extern LONGEST extract_signed_integer (const void *, int);

extern ULONGEST extract_unsigned_integer (const void *, int);

extern int extract_long_unsigned_integer (const void *, int, LONGEST *);

extern CORE_ADDR extract_typed_address (const void *buf, struct type *type);

extern void store_signed_integer (void *, int, LONGEST);

extern void store_unsigned_integer (void *, int, ULONGEST);

extern void store_typed_address (void *buf, struct type *type, CORE_ADDR addr);


/* From valops.c */

extern CORE_ADDR push_bytes (CORE_ADDR, char *, int);

extern CORE_ADDR push_word (CORE_ADDR, ULONGEST);

extern int watchdog;

/* Hooks for alternate command interfaces.  */

/* The name of the interpreter if specified on the command line. */
extern char *interpreter_p;

/* If a given interpreter matches INTERPRETER_P then it should update
   deprecated_command_loop_hook and deprecated_init_ui_hook with the
   per-interpreter implementation.  */
/* FIXME: deprecated_command_loop_hook and deprecated_init_ui_hook
   should be moved here. */

struct target_waitstatus;
struct cmd_list_element;

extern void (*deprecated_pre_add_symbol_hook) (const char *);
extern void (*deprecated_post_add_symbol_hook) (void);
extern void (*selected_frame_level_changed_hook) (int);
extern int (*deprecated_ui_loop_hook) (int signo);
extern void (*deprecated_init_ui_hook) (char *argv0);
extern void (*deprecated_command_loop_hook) (void);
extern void (*deprecated_show_load_progress) (const char *section,
					      unsigned long section_sent, 
					      unsigned long section_size, 
					      unsigned long total_sent, 
					      unsigned long total_size);
extern void (*deprecated_print_frame_info_listing_hook) (struct symtab * s,
							 int line, int stopline,
							 int noerror);
extern struct frame_info *parse_frame_specification (char *frame_exp);
extern int (*deprecated_query_hook) (const char *, va_list);
extern void (*deprecated_warning_hook) (const char *, va_list);
extern void (*deprecated_flush_hook) (struct ui_file * stream);
extern void (*deprecated_create_breakpoint_hook) (struct breakpoint * b);
extern void (*deprecated_delete_breakpoint_hook) (struct breakpoint * bpt);
extern void (*deprecated_modify_breakpoint_hook) (struct breakpoint * bpt);
extern void (*deprecated_interactive_hook) (void);
extern void (*deprecated_registers_changed_hook) (void);
extern void (*deprecated_readline_begin_hook) (char *,...);
extern char *(*deprecated_readline_hook) (char *);
extern void (*deprecated_readline_end_hook) (void);
extern void (*deprecated_register_changed_hook) (int regno);
extern void (*deprecated_memory_changed_hook) (CORE_ADDR addr, int len);
extern void (*deprecated_context_hook) (int);
extern ptid_t (*deprecated_target_wait_hook) (ptid_t ptid,
                                         struct target_waitstatus * status);

extern void (*deprecated_attach_hook) (void);
extern void (*deprecated_detach_hook) (void);
extern void (*deprecated_call_command_hook) (struct cmd_list_element * c,
					     char *cmd, int from_tty);

extern void (*deprecated_set_hook) (struct cmd_list_element * c);

extern void (*deprecated_error_hook) (void);

extern void (*deprecated_error_begin_hook) (void);

extern int (*deprecated_ui_load_progress_hook) (const char *section,
						unsigned long num);


/* Inhibit window interface if non-zero. */

extern int use_windows;

/* Symbolic definitions of filename-related things.  */
/* FIXME, this doesn't work very well if host and executable
   filesystems conventions are different.  */

#ifndef DIRNAME_SEPARATOR
#define DIRNAME_SEPARATOR ':'
#endif

#ifndef SLASH_STRING
#define SLASH_STRING "/"
#endif

#ifdef __MSDOS__
# define CANT_FORK
# define GLOBAL_CURDIR
#endif

/* Provide default definitions of PIDGET, TIDGET, and MERGEPID.
   The name ``TIDGET'' is a historical accident.  Many uses of TIDGET
   in the code actually refer to a lightweight process id, i.e,
   something that can be considered a process id in its own right for
   certain purposes.  */

#ifndef PIDGET
#define PIDGET(PTID) (ptid_get_pid (PTID))
#define TIDGET(PTID) (ptid_get_lwp (PTID))
#define MERGEPID(PID, TID) ptid_build (PID, TID, 0)
#endif

/* Define well known filenos if the system does not define them.  */
#ifndef STDIN_FILENO
#define STDIN_FILENO   0
#endif
#ifndef STDOUT_FILENO
#define STDOUT_FILENO  1
#endif
#ifndef STDERR_FILENO
#define STDERR_FILENO  2
#endif

/* If this definition isn't overridden by the header files, assume
   that isatty and fileno exist on this system.  */
#ifndef ISATTY
#define ISATTY(FP)	(isatty (fileno (FP)))
#endif

/* Ensure that V is aligned to an N byte boundary (B's assumed to be a
   power of 2).  Round up/down when necessary.  Examples of correct
   use include:

   addr = align_up (addr, 8); -- VALUE needs 8 byte alignment
   write_memory (addr, value, len);
   addr += len;

   and:

   sp = align_down (sp - len, 16); -- Keep SP 16 byte aligned
   write_memory (sp, value, len);

   Note that uses such as:

   write_memory (addr, value, len);
   addr += align_up (len, 8);

   and:

   sp -= align_up (len, 8);
   write_memory (sp, value, len);

   are typically not correct as they don't ensure that the address (SP
   or ADDR) is correctly aligned (relying on previous alignment to
   keep things right).  This is also why the methods are called
   "align_..." instead of "round_..." as the latter reads better with
   this incorrect coding style.  */

extern ULONGEST align_up (ULONGEST v, int n);
extern ULONGEST align_down (ULONGEST v, int n);

#endif /* #ifndef DEFS_H */
@


1.6
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@d882 4
@


1.5
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@a68 23

/* The target is partially multi-arched.  Both "tm.h" and the
   multi-arch vector provide definitions.  "tm.h" normally overrides
   the multi-arch vector (but there are a few exceptions).  */

#define GDB_MULTI_ARCH_PARTIAL 1

/* The target is partially multi-arched. Both the multi-arch vector
   and "tm.h" provide definitions. "tm.h" cannot override a definition
   provided by the multi-arch vector.  It is detected as a compilation
   error.

   This setting is only useful during a multi-arch conversion. */

#define GDB_MULTI_ARCH_TM 2

/* The target is pure multi-arch.  The MULTI-ARCH vector provides all
   definitions.  "tm.h" is linked to an empty file. */

#define GDB_MULTI_ARCH_PURE 3



d178 1
a178 1
  if (interactive_hook) interactive_hook (); \
d200 3
a202 1
    language_minimal		/* All other languages, minimal support only */
d232 13
a244 1
  RETURN_VALUE_STRUCT_CONVENTION
a320 4
extern int deprecated_inside_entry_file (CORE_ADDR addr);

extern int inside_main_func (CORE_ADDR pc);

a336 2
extern void init_malloc (void *);

d364 4
d519 1
d528 5
d598 3
a616 2
extern char *symtab_to_filename (struct symtab *);

d807 8
a814 3
/* If the xm.h file did not define the mode string used to open the
   files, assume that binary files are opened the same way as text
   files */
d816 1
a816 1
#include "fopen-same.h"
a860 11
extern char *msavestring (void *, const char *, size_t);

extern char *mstrsave (void *, const char *);

/* Robust versions of same.  Throw an internal error when no memory,
   guard against stray NULL arguments. */
extern void *xmmalloc (void *md, size_t size);
extern void *xmrealloc (void *md, void *ptr, size_t size);
extern void *xmcalloc (void *md, size_t number, size_t size);
extern void xmfree (void *md, void *ptr);

d877 2
a878 1
/* Like asprintf, but return the string, throw an error if no memory.  */
d880 1
a1061 4
#ifndef GETENV_PROVIDED
extern char *getenv (const char *);
#endif

a1078 9
/* We take the address of fclose later, but some stdio's forget
   to declare this.  We can't always declare it since there's
   no way to declare the parameters without upsetting some compiler
   somewhere. */

#ifndef FCLOSE_PROVIDED
extern int fclose (FILE *);
#endif

a1103 9
/* Is GDB multi-arch?  If there's a "tm.h" file, it is not.  */
#ifndef GDB_MULTI_ARCH
#ifdef GDB_TM_FILE
#define GDB_MULTI_ARCH GDB_MULTI_ARCH_PARTIAL
#else
#define GDB_MULTI_ARCH GDB_MULTI_ARCH_PURE
#endif
#endif

d1170 4
a1173 3
   command_loop_hook and init_ui_hook with the per-interpreter
   implementation. */
/* FIXME: command_loop_hook and init_ui_hook should be moved here. */
d1178 14
a1191 14
/* Should the asynchronous variant of the interpreter (using the
   event-loop) be enabled? */
extern int event_loop_p;

extern void (*init_ui_hook) (char *argv0);
extern void (*command_loop_hook) (void);
extern void (*show_load_progress) (const char *section,
				   unsigned long section_sent, 
				   unsigned long section_size, 
				   unsigned long total_sent, 
				   unsigned long total_size);
extern void (*print_frame_info_listing_hook) (struct symtab * s,
					      int line, int stopline,
					      int noerror);
d1193 15
a1207 15
extern int (*query_hook) (const char *, va_list);
extern void (*warning_hook) (const char *, va_list);
extern void (*flush_hook) (struct ui_file * stream);
extern void (*create_breakpoint_hook) (struct breakpoint * b);
extern void (*delete_breakpoint_hook) (struct breakpoint * bpt);
extern void (*modify_breakpoint_hook) (struct breakpoint * bpt);
extern void (*interactive_hook) (void);
extern void (*registers_changed_hook) (void);
extern void (*readline_begin_hook) (char *,...);
extern char *(*readline_hook) (char *);
extern void (*readline_end_hook) (void);
extern void (*register_changed_hook) (int regno);
extern void (*memory_changed_hook) (CORE_ADDR addr, int len);
extern void (*context_hook) (int);
extern ptid_t (*target_wait_hook) (ptid_t ptid,
d1210 4
a1213 4
extern void (*attach_hook) (void);
extern void (*detach_hook) (void);
extern void (*call_command_hook) (struct cmd_list_element * c,
				  char *cmd, int from_tty);
d1215 1
a1215 1
extern void (*set_hook) (struct cmd_list_element * c);
d1217 1
a1217 1
extern NORETURN void (*error_hook) (void) ATTR_NORETURN;
d1219 1
a1219 1
extern void (*error_begin_hook) (void);
d1221 2
a1222 1
extern int (*ui_load_progress_hook) (const char *section, unsigned long num);
@


1.4
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@d68 1
a68 1
#define bfd_section sec
@


1.3
log
@Remove prototype conflicting with new libreadline.
ok deraadt@@, otto@@, pval@@
@
text
@d1 1
d3 2
a4 1
   Copyright (C) 1986, 1989, 1991, 1992, 1993, 1994, 1995, 1996
d7 1
a7 1
This file is part of GDB.
d9 14
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d27 2
a28 1
#include "config.h"		/* Generated by configure */
d30 22
a51 1
#include <errno.h>		/* System call error return status */
d53 1
a53 1
/* Just in case they're not defined in stdio.h. */
d62 13
a74 2
/* First include ansidecl.h so we can use the various macro definitions
   here and in all subsequent file inclusions.  */
d76 4
a79 1
#include "ansidecl.h"
d81 1
a81 5
#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif
d83 1
a83 1
#include "libiberty.h"
d85 2
a86 2
/* libiberty.h can't declare this one, but evidently we can.  */
extern char *strsignal PARAMS ((int));
d88 1
a88 1
#include "progress.h"
a89 3
#ifndef NO_MMALLOC
#include "mmalloc.h"
#endif
a90 2
/* For BFD64 and bfd_vma.  */
#include "bfd.h"
d100 30
d137 3
a139 2
/* Gdb does *lots* of string compares.  Use macros to speed them up by
   avoiding function calls if the first characters are not the same. */
d141 27
a167 7
#define STRCMP(a,b) (*(a) == *(b) ? strcmp ((a), (b)) : (int)*(a) - (int)*(b))
#define STREQ(a,b) (*(a) == *(b) ? !strcmp ((a), (b)) : 0)
#define STREQN(a,b,c) (*(a) == *(b) ? !strncmp ((a), (b), (c)) : 0)

/* The character GNU C++ uses to build identifiers that must be unique from
   the program's identifiers (such as $this and $$vptr).  */
#define CPLUS_MARKER '$'	/* May be overridden to '.' for SysV */
d170 10
a179 1
extern int is_cplus_marker PARAMS ((int));
d185 8
a192 1
extern void quit PARAMS ((void));
d196 2
a197 2
#define FIXME "FIXME"
#define FIXME "ignoring redefinition of QUIT"
a201 1
  PROGRESS (1); \
a204 17
/* Command classes are top-level categories into which commands are broken
   down for "help" purposes.  
   Notes on classes: class_alias is for alias commands which are not
   abbreviations of the original command.  class-pseudo is for commands
   which are not really commands nor help topics ("stop").  */

enum command_class
{
  /* Special args to help_list */
  all_classes = -2, all_commands = -1,
  /* Classes of commands */
  no_class = -1, class_run = 0, class_vars, class_stack,
  class_files, class_support, class_info, class_breakpoint,
  class_alias, class_obscure, class_user, class_maintenance,
  class_pseudo
};

d210 33
a242 1
enum language 
d244 10
a253 9
   language_unknown, 		/* Language not known */
   language_auto,		/* Placeholder for automatic setting */
   language_c, 			/* C */
   language_cplus, 		/* C++ */
   language_chill,		/* Chill */
   language_fortran,		/* Fortran */
   language_m2,			/* Modula-2 */
   language_asm,		/* Assembly language */
   language_scm			/* Scheme / Guile */
d267 5
a271 5
{
  struct cleanup *next;
  void (*function) PARAMS ((PTR));
  PTR arg;
};
d282 1
a282 1
# if defined(__GNUC__) \
d284 4
a287 4
#  define NORETURN volatile
# else
#  define NORETURN /* nothing */
# endif
d296 5
a300 5
# if defined(__GNUC__) && __GNUC__ >= 2 && __GNUC_MINOR__ >= 7
#  define ATTR_NORETURN __attribute__ ((noreturn))
# else
#  define ATTR_NORETURN /* nothing */
# endif
d304 14
a317 5
# if defined(__GNUC__) && __GNUC__ >= 2 && __GNUC_MINOR__ >= 4 && defined (__ANSI_PROTOTYPES)
#  define ATTR_FORMAT(type, x, y) __attribute__ ((format(type, x, y)))
# else
#  define ATTR_FORMAT(type, x, y) /* nothing */
# endif
a321 1
#ifdef __STDC__
d324 1
a324 1
#endif
d328 19
a346 1
extern int inside_entry_func PARAMS ((CORE_ADDR));
d348 1
a348 1
extern int inside_entry_file PARAMS ((CORE_ADDR addr));
d350 1
a350 1
extern int inside_main_func PARAMS ((CORE_ADDR pc));
d352 1
a352 1
/* From ch-lang.c, for the moment. (FIXME) */
d354 5
a358 1
extern char *chill_demangle PARAMS ((const char *));
d360 11
a370 1
/* From utils.c */
d372 1
a372 1
extern void notice_quit PARAMS ((void));
d374 1
a374 1
extern int strcmp_iw PARAMS ((const char *, const char *));
d376 2
a377 1
extern char *safe_strerror PARAMS ((int));
d379 1
a379 1
extern char *safe_strsignal PARAMS ((int));
d381 1
a381 1
extern void init_malloc PARAMS ((void *));
d383 1
a383 1
extern void request_quit PARAMS ((int));
d385 2
a386 1
extern void do_cleanups PARAMS ((struct cleanup *));
d388 1
a388 1
extern void discard_cleanups PARAMS ((struct cleanup *));
d390 2
a391 3
/* The bare make_cleanup function is one of those rare beasts that
   takes almost any type of function as the first arg and anything that
   will fit in a "void *" as the second arg.
d393 3
a395 3
   Should be, once all calls and called-functions are cleaned up:
extern struct cleanup *
make_cleanup PARAMS ((void (*function) (void *), void *));
d397 3
a399 4
   Until then, lint and/or various type-checking compiler options will
   complain about make_cleanup calls.  It'd be wrong to just cast things,
   since the type actually passed when the function is called would be
   wrong.  */
d401 1
a401 1
extern struct cleanup *make_cleanup ();
d403 1
a403 1
extern struct cleanup *save_cleanups PARAMS ((void));
d405 1
a405 1
extern void restore_cleanups PARAMS ((struct cleanup *));
d407 3
a409 1
extern void free_current_contents PARAMS ((char **));
d411 1
a411 1
extern void null_cleanup PARAMS ((PTR));
d413 2
a414 1
extern int myread PARAMS ((int, char *, int));
d416 2
a417 2
extern int query PARAMS((char *, ...))
     ATTR_FORMAT(printf, 1, 2);
d421 7
a427 1
extern void set_demangling_style PARAMS ((char *));
d432 1
a432 1
extern int annotation_level; /* in stack.c */
d434 26
a459 1
extern void begin_line PARAMS ((void));
d461 2
a462 1
extern void wrap_here PARAMS ((char *));
d464 1
a464 1
extern void reinitialize_more_filter PARAMS ((void));
d466 1
a466 3
typedef FILE GDB_FILE;
#define gdb_stdout stdout
#define gdb_stderr stderr
d468 1
a468 1
extern void gdb_flush PARAMS ((GDB_FILE *));
d470 1
a470 1
extern GDB_FILE *gdb_fopen PARAMS ((char * name, char * mode));
d472 1
a472 1
extern void fputs_filtered PARAMS ((const char *, GDB_FILE *));
d474 1
a474 1
extern void fputs_unfiltered PARAMS ((const char *, GDB_FILE *));
d476 1
a476 1
extern int fputc_unfiltered PARAMS ((int c, GDB_FILE *));
d478 1
a478 1
extern int putchar_unfiltered PARAMS ((int c));
d480 1
a480 1
extern void puts_filtered PARAMS ((const char *));
d482 1
a482 1
extern void puts_unfiltered PARAMS ((const char *));
d484 1
a484 2
extern void vprintf_filtered PARAMS ((const char *, va_list))
     ATTR_FORMAT(printf, 1, 0);
d486 1
a486 2
extern void vfprintf_filtered PARAMS ((FILE *, const char *, va_list))
     ATTR_FORMAT(printf, 2, 0);
d488 1
a488 2
extern void fprintf_filtered PARAMS ((FILE *, const char *, ...))
     ATTR_FORMAT(printf, 2, 3);
d490 1
a490 2
extern void fprintfi_filtered PARAMS ((int, FILE *, const char *, ...))
     ATTR_FORMAT(printf, 3, 4);
d492 1
a492 2
extern void printf_filtered PARAMS ((const char *, ...))
     ATTR_FORMAT(printf, 1, 2);
d494 1
a494 2
extern void printfi_filtered PARAMS ((int, const char *, ...))
     ATTR_FORMAT(printf, 2, 3);
d496 1
a496 2
extern void vprintf_unfiltered PARAMS ((const char *, va_list))
     ATTR_FORMAT(printf, 1, 0);
d498 1
a498 2
extern void vfprintf_unfiltered PARAMS ((FILE *, const char *, va_list))
     ATTR_FORMAT(printf, 2, 0);
d500 1
a500 2
extern void fprintf_unfiltered PARAMS ((FILE *, const char *, ...))
     ATTR_FORMAT(printf, 2, 3);
d502 1
a502 2
extern void printf_unfiltered PARAMS ((const char *, ...))
     ATTR_FORMAT(printf, 1, 2);
d504 1
a504 1
extern void print_spaces PARAMS ((int, GDB_FILE *));
d506 1
a506 1
extern void print_spaces_filtered PARAMS ((int, GDB_FILE *));
d508 1
a508 1
extern char *n_spaces PARAMS ((int));
d510 1
a510 1
extern void gdb_printchar PARAMS ((int, GDB_FILE *, int));
d512 1
a512 1
extern void gdb_print_address PARAMS ((void *, GDB_FILE *));
d514 1
a514 3
typedef bfd_vma t_addr;
typedef bfd_vma t_reg;
extern char* paddr PARAMS ((t_addr addr));
d516 2
a517 1
extern char* preg PARAMS ((t_reg reg));
d519 8
a526 2
extern void fprintf_symbol_filtered PARAMS ((GDB_FILE *, char *,
					     enum language, int));
d528 2
a529 1
extern void perror_with_name PARAMS ((char *));
d531 13
a543 1
extern void print_sys_errmsg PARAMS ((char *, int));
d549 1
a549 1
extern char *re_comp PARAMS ((const char *));
d553 10
a562 1
extern void symbol_file_command PARAMS ((char *, int));
d566 5
a570 1
extern char *skip_quoted PARAMS ((char *));
d572 1
a572 1
extern char *gdb_readline PARAMS ((char *));
d574 1
a574 1
extern char *command_line_input PARAMS ((char *, int, char *));
d576 1
a576 1
extern void print_prompt PARAMS ((void));
d578 1
a578 1
extern int input_from_terminal_p PARAMS ((void));
d584 1
a584 1
extern void set_next_address PARAMS ((CORE_ADDR));
d586 2
a587 2
extern void print_address_symbolic PARAMS ((CORE_ADDR, GDB_FILE *, int,
					    char *));
d589 7
a595 1
extern void print_address_numeric PARAMS ((CORE_ADDR, int, GDB_FILE *));
d597 3
a599 1
extern void print_address PARAMS ((CORE_ADDR, GDB_FILE *));
d603 13
a615 1
extern int openp PARAMS ((char *, int, char *, int, int, char **));
d617 1
a617 1
extern void mod_path PARAMS ((char *, char **));
d619 1
a619 1
extern void directory_command PARAMS ((char *, int));
d621 1
a621 1
extern void init_source_path PARAMS ((void));
d623 3
a625 1
extern char *symtab_to_filename PARAMS ((struct symtab *));
d627 6
a632 1
/* From findvar.c */
d634 20
a653 1
extern int read_relative_register_raw_bytes PARAMS ((int, char *));
d658 6
a663 6
{
  ok_command,
  end_command,
  else_command,
  nop_command
};
d666 8
a673 8
{
  simple_control,
  break_control,
  continue_control,
  while_control,
  if_control,
  invalid_control
};
d679 39
a717 7
{
  struct command_line *next;
  char *line;
  enum command_control_type control_type;
  int body_count;
  struct command_line **body_list;
};
d719 10
a728 3
extern struct command_line *read_command_lines PARAMS ((char *, int));

extern void free_command_lines PARAMS ((struct command_line **));
d745 38
a782 6
{
  Val_no_prettyprint = 0,
  Val_prettyprint,
  /* Use the default setting which the user has specified.  */
  Val_pretty_default
};
a784 2
/* Host machine definition.  This will be a symlink to one of the
   xm-*.h files, built by the `configure' script.  */
d786 5
d792 1
d794 4
a797 2
/* Native machine support.  This will be a symlink to one of the
   nm-*.h files, built by the `configure' script.  */
d799 1
d801 1
d803 2
a804 1
/* Target machine definition.  This will be a symlink to one of the
d807 1
d809 1
a817 25
/* Microsoft C can't deal with const pointers */

#ifdef _MSC_VER
#define CONST_PTR
#else
#define CONST_PTR const
#endif

/*
 * Allow things in gdb to be declared "volatile".  If compiling ANSI, it
 * just works.  If compiling with gcc but non-ansi, redefine to __volatile__.
 * If non-ansi, non-gcc, then eliminate "volatile" entirely, making those
 * objects be read-write rather than read-only.
 */

#ifndef volatile
#ifndef __STDC__
# ifdef __GNUC__
#  define volatile __volatile__
# else
#  define volatile /*nothing*/
# endif /* GNUC */
#endif /* STDC */
#endif /* volatile */

d822 1
a822 1
#define	UINT_MAX ((unsigned int)(~0))		/* 0xFFFFFFFF for 32-bits */
d826 1
a826 1
#define	INT_MAX ((int)(UINT_MAX >> 1))		/* 0x7FFFFFFF for 32-bits */
d841 3
a843 7
#ifdef BFD64

/* This is to make sure that LONGEST is at least as big as CORE_ADDR.  */

#define LONGEST BFD_HOST_64_BIT

#else /* No BFD64 */
d845 2
a846 9
/* LONGEST should not be a typedef, because "unsigned LONGEST" needs to work.
   CC_HAS_LONG_LONG is defined if the host compiler supports "long long" */

#ifndef LONGEST
#  ifdef CC_HAS_LONG_LONG
#    define LONGEST long long
#  else
#    define LONGEST long
#  endif
a848 2
#endif /* No BFD64 */

d853 1
a853 1
extern int longest_to_int PARAMS ((LONGEST));
d858 1
a858 7
extern char *savestring PARAMS ((const char *, int));

extern char *msavestring PARAMS ((void *, const char *, int));

extern char *strsave PARAMS ((const char *));

extern char *mstrsave PARAMS ((void *, const char *));
d860 1
a860 2
#ifdef _MSC_VER /* FIXME; was long, but this causes compile errors in msvc if already defined */
extern PTR xmmalloc PARAMS ((PTR, size_t));
d862 1
a862 3
extern PTR xmrealloc PARAMS ((PTR, PTR, size_t));
#else
extern PTR xmmalloc PARAMS ((PTR, long));
d864 22
a885 2
extern PTR xmrealloc PARAMS ((PTR, PTR, long));
#endif
d887 2
a888 1
extern int parse_escape PARAMS ((char **));
d890 1
a890 1
extern char *reg_names[];
d904 17
a920 1
extern NORETURN void error PARAMS((char *, ...)) ATTR_NORETURN;
d922 2
a923 1
extern void error_begin PARAMS ((void));
d925 2
a926 1
extern NORETURN void fatal PARAMS((char *, ...)) ATTR_NORETURN;
d928 2
a929 1
extern NORETURN void nomem PARAMS ((long)) ATTR_NORETURN;
d931 2
a932 4
/* Reasons for calling return_to_top_level.  */
enum return_reason {
  /* User interrupt.  */
  RETURN_QUIT,
d934 17
a950 3
  /* Any other error.  */
  RETURN_ERROR
};
d952 4
a955 3
#define RETURN_MASK_QUIT (1 << (int)RETURN_QUIT)
#define RETURN_MASK_ERROR (1 << (int)RETURN_ERROR)
#define RETURN_MASK_ALL (RETURN_MASK_QUIT | RETURN_MASK_ERROR)
d958 78
a1035 2
extern NORETURN void
return_to_top_level PARAMS ((enum return_reason)) ATTR_NORETURN;
d1037 23
a1059 2
extern int
catch_errors PARAMS ((int (*) (char *), void *, char *, return_mask));
d1061 1
a1061 1
extern void warning_begin PARAMS ((void));
d1063 2
a1064 2
extern void warning PARAMS ((char *, ...))
     ATTR_FORMAT(printf, 1, 2);
d1071 1
a1071 1
extern char *getenv PARAMS ((const char *));
a1080 5
#if defined(_MSC_VER) && !defined(__cplusplus)
/* msvc defines these in stdlib.h for c code */
#undef min
#undef max
#endif
d1097 1
a1097 1
extern int fclose PARAMS ((FILE *));
d1101 1
a1101 15
extern double atof PARAMS ((const char *));	/* X3.159-1989  4.10.1.1 */
#endif

#ifndef MALLOC_INCOMPATIBLE

#ifdef NEED_DECLARATION_MALLOC
extern PTR malloc ();
#endif

#ifdef NEED_DECLARATION_REALLOC
extern PTR realloc ();
#endif

#ifdef NEED_DECLARATION_FREE
extern void free ();
a1103 2
#endif /* MALLOC_INCOMPATIBLE */

d1106 9
a1114 6
# ifdef __GNUC__
#  define alloca __builtin_alloca
# else /* Not GNU C */
#  ifdef sparc
#   include <alloca.h>		/* NOTE:  Doesn't declare alloca() */
#  endif
d1119 4
a1122 6
#  if defined (__STDC__) || defined (__hpux)
   extern void *alloca ();
#  else /* Don't use void *.  */
   extern char *alloca ();
#  endif /* Don't use void *.  */
# endif /* Not GNU C */
d1125 6
a1130 4
/* HOST_BYTE_ORDER must be defined to one of these.  */

#ifdef HAVE_ENDIAN_H
#include <endian.h>
a1131 3

#if !defined (BIG_ENDIAN)
#define BIG_ENDIAN 4321
d1134 2
a1135 3
#if !defined (LITTLE_ENDIAN)
#define LITTLE_ENDIAN 1234
#endif
d1137 2
a1138 1
/* Target-system-dependent parameters for GDB. */
d1140 1
a1140 8
#ifdef TARGET_BYTE_ORDER_SELECTABLE
/* The target endianness is selectable at runtime.  Define
   TARGET_BYTE_ORDER to be a variable.  The user can use the `set
   endian' command to change it.  */
#undef TARGET_BYTE_ORDER
#define TARGET_BYTE_ORDER target_byte_order
extern int target_byte_order;
#endif
d1142 1
a1142 1
extern void set_endian_from_file PARAMS ((bfd *));
a1149 40
/* Number of bits in a short or unsigned short for the target machine. */
#if !defined (TARGET_SHORT_BIT)
#define TARGET_SHORT_BIT (2 * TARGET_CHAR_BIT)
#endif

/* Number of bits in an int or unsigned int for the target machine. */
#if !defined (TARGET_INT_BIT)
#define TARGET_INT_BIT (4 * TARGET_CHAR_BIT)
#endif

/* Number of bits in a long or unsigned long for the target machine. */
#if !defined (TARGET_LONG_BIT)
#define TARGET_LONG_BIT (4 * TARGET_CHAR_BIT)
#endif

/* Number of bits in a long long or unsigned long long for the target machine. */
#if !defined (TARGET_LONG_LONG_BIT)
#define TARGET_LONG_LONG_BIT (2 * TARGET_LONG_BIT)
#endif

/* Number of bits in a float for the target machine. */
#if !defined (TARGET_FLOAT_BIT)
#define TARGET_FLOAT_BIT (4 * TARGET_CHAR_BIT)
#endif

/* Number of bits in a double for the target machine. */
#if !defined (TARGET_DOUBLE_BIT)
#define TARGET_DOUBLE_BIT (8 * TARGET_CHAR_BIT)
#endif

/* Number of bits in a long double for the target machine.  */
#if !defined (TARGET_LONG_DOUBLE_BIT)
#define TARGET_LONG_DOUBLE_BIT (2 * TARGET_DOUBLE_BIT)
#endif

/* Number of bits in a pointer for the target machine */
#if !defined (TARGET_PTR_BIT)
#define TARGET_PTR_BIT TARGET_INT_BIT
#endif

d1166 2
a1167 16
#ifndef TARGET_BYTE_ORDER_SELECTABLE

#if TARGET_BYTE_ORDER == BIG_ENDIAN
#define BITS_BIG_ENDIAN 1
#endif /* Big endian.  */

#if TARGET_BYTE_ORDER == LITTLE_ENDIAN
#define BITS_BIG_ENDIAN 0
#endif /* Little endian.  */

#else /* defined (TARGET_BYTE_ORDER_SELECTABLE) */

#define BITS_BIG_ENDIAN (TARGET_BYTE_ORDER == BIG_ENDIAN)

#endif /* defined (TARGET_BYTE_ORDER_SELECTABLE) */
#endif /* BITS_BIG_ENDIAN not defined.  */
d1171 1
a1171 1
extern LONGEST extract_signed_integer PARAMS ((void *, int));
d1173 1
a1173 1
extern unsigned LONGEST extract_unsigned_integer PARAMS ((void *, int));
d1175 1
a1175 1
extern int extract_long_unsigned_integer PARAMS ((void *, int, LONGEST *));
d1177 1
a1177 1
extern CORE_ADDR extract_address PARAMS ((void *, int));
d1179 1
a1179 79
extern void store_signed_integer PARAMS ((void *, int, LONGEST));

extern void store_unsigned_integer PARAMS ((void *, int, unsigned LONGEST));

extern void store_address PARAMS ((void *, int, CORE_ADDR));

/* Setup definitions for host and target floating point formats.  We need to
   consider the format for `float', `double', and `long double' for both target
   and host.  We need to do this so that we know what kind of conversions need
   to be done when converting target numbers to and from the hosts DOUBLEST
   data type.  */

/* This is used to indicate that we don't know the format of the floating point
   number.  Typically, this is useful for native ports, where the actual format
   is irrelevant, since no conversions will be taking place.  */

extern const struct floatformat floatformat_unknown;

#if HOST_BYTE_ORDER == BIG_ENDIAN
#  ifndef HOST_FLOAT_FORMAT
#    define HOST_FLOAT_FORMAT &floatformat_ieee_single_big
#  endif
#  ifndef HOST_DOUBLE_FORMAT
#    define HOST_DOUBLE_FORMAT &floatformat_ieee_double_big
#  endif
#else				/* LITTLE_ENDIAN */
#  ifndef HOST_FLOAT_FORMAT
#    define HOST_FLOAT_FORMAT &floatformat_ieee_single_little
#  endif
#  ifndef HOST_DOUBLE_FORMAT
#    define HOST_DOUBLE_FORMAT &floatformat_ieee_double_little
#  endif
#endif

#ifndef HOST_LONG_DOUBLE_FORMAT
#define HOST_LONG_DOUBLE_FORMAT &floatformat_unknown
#endif

#ifndef TARGET_BYTE_ORDER_SELECTABLE
#  if TARGET_BYTE_ORDER == BIG_ENDIAN
#    ifndef TARGET_FLOAT_FORMAT
#      define TARGET_FLOAT_FORMAT &floatformat_ieee_single_big
#    endif
#    ifndef TARGET_DOUBLE_FORMAT
#      define TARGET_DOUBLE_FORMAT &floatformat_ieee_double_big
#    endif
#  else /* LITTLE_ENDIAN */
#    ifndef TARGET_FLOAT_FORMAT
#      define TARGET_FLOAT_FORMAT &floatformat_ieee_single_little
#    endif
#    ifndef TARGET_DOUBLE_FORMAT
#      define TARGET_DOUBLE_FORMAT &floatformat_ieee_double_little
#    endif
#  endif
#else				/* TARGET_BYTE_ORDER_SELECTABLE */
#  ifndef TARGET_FLOAT_FORMAT
#    define TARGET_FLOAT_FORMAT (target_byte_order == BIG_ENDIAN \
				 ? &floatformat_ieee_single_big \
				 : &floatformat_ieee_single_little)
#  endif
#  ifndef TARGET_DOUBLE_FORMAT
#    define TARGET_DOUBLE_FORMAT (target_byte_order == BIG_ENDIAN \
				  ? &floatformat_ieee_double_big \
				  : &floatformat_ieee_double_little)
#  endif
#endif

#ifndef TARGET_LONG_DOUBLE_FORMAT
#  define TARGET_LONG_DOUBLE_FORMAT &floatformat_unknown
#endif

/* Use `long double' if the host compiler supports it.  (Note that this is not
   necessarily any longer than `double'.  On SunOS/gcc, it's the same as
   double.)  This is necessary because GDB internally converts all floating
   point values to the widest type supported by the host.

   There are problems however, when the target `long double' is longer than the
   host's `long double'.  In general, we'll probably reduce the precision of
   any such values and print a warning.  */
d1181 1
a1181 5
#ifdef HAVE_LONG_DOUBLE
typedef long double DOUBLEST;
#else
typedef double DOUBLEST;
#endif
d1183 1
a1183 5
extern void floatformat_to_doublest PARAMS ((const struct floatformat *,
					     char *, DOUBLEST *));
extern void floatformat_from_doublest PARAMS ((const struct floatformat *,
					       DOUBLEST *, char *));
extern DOUBLEST extract_floating PARAMS ((void *, int));
a1184 1
extern void store_floating PARAMS ((void *, int, DOUBLEST));
a1185 13
/* On some machines there are bits in addresses which are not really
   part of the address, but are used by the kernel, the hardware, etc.
   for special purposes.  ADDR_BITS_REMOVE takes out any such bits
   so we get a "real" address such as one would find in a symbol
   table.  This is used only for addresses of instructions, and even then
   I'm not sure it's used in all contexts.  It exists to deal with there
   being a few stray bits in the PC which would mislead us, not as some sort
   of generic thing to handle alignment or segmentation (it's possible it
   should be in TARGET_READ_PC instead).  */
#if !defined (ADDR_BITS_REMOVE)
#define ADDR_BITS_REMOVE(addr) (addr)
#endif /* No ADDR_BITS_REMOVE.  */

d1188 1
a1188 14
extern CORE_ADDR push_bytes PARAMS ((CORE_ADDR, char *, int));

extern CORE_ADDR push_word PARAMS ((CORE_ADDR, unsigned LONGEST));

/* Some parts of gdb might be considered optional, in the sense that they
   are not essential for being able to build a working, usable debugger
   for a specific environment.  For example, the maintenance commands
   are there for the benefit of gdb maintainers.  As another example,
   some environments really don't need gdb's that are able to read N
   different object file formats.  In order to make it possible (but
   not necessarily recommended) to build "stripped down" versions of
   gdb, the following defines control selective compilation of those
   parts of gdb which can be safely left out when necessary.  Note that
   the default is to include everything. */
d1190 1
a1190 3
#ifndef MAINTENANCE_CMDS
#define MAINTENANCE_CMDS 1
#endif
a1191 1
#ifdef MAINTENANCE_CMDS
a1192 1
#endif
d1194 1
a1194 4
#include "dis-asm.h"		/* Get defs for disassemble_info */

extern int dis_asm_read_memory PARAMS ((bfd_vma memaddr, bfd_byte *myaddr,
					int len, disassemble_info *info));
d1196 2
a1197 2
extern void dis_asm_memory_error PARAMS ((int status, bfd_vma memaddr,
					  disassemble_info *info));
d1199 4
a1202 2
extern void dis_asm_print_address PARAMS ((bfd_vma addr,
					   disassemble_info *info));
a1203 6
extern int (*tm_print_insn) PARAMS ((bfd_vma, disassemble_info*));
extern disassemble_info tm_print_insn_info;

/* Hooks for alternate command interfaces.  */

#ifdef __STDC__
a1205 1
#endif
d1207 36
a1242 18
extern void (*init_ui_hook) PARAMS ((void));
extern void (*command_loop_hook) PARAMS ((void));
extern void (*fputs_unfiltered_hook) PARAMS ((const char *linebuffer,
					      FILE *stream));
extern void (*print_frame_info_listing_hook) PARAMS ((struct symtab *s,
						      int line, int stopline,
						      int noerror));
extern int (*query_hook) PARAMS ((const char *, va_list));
extern void (*flush_hook) PARAMS ((FILE *stream));
extern void (*create_breakpoint_hook) PARAMS ((struct breakpoint *b));
extern void (*delete_breakpoint_hook) PARAMS ((struct breakpoint *bpt));
extern void (*modify_breakpoint_hook) PARAMS ((struct breakpoint *bpt));
extern void (*target_output_hook) PARAMS ((char *));
extern void (*interactive_hook) PARAMS ((void));
extern void (*registers_changed_hook) PARAMS ((void));
extern void (*readline_begin_hook) PARAMS ((char *, ...));
extern char * (*readline_hook) PARAMS ((char *));
extern void (*readline_end_hook) PARAMS ((void));
d1244 1
a1244 2
extern int (*target_wait_hook) PARAMS ((int pid,
					struct target_waitstatus *status));
d1246 1
a1246 2
extern void (*call_command_hook) PARAMS ((struct cmd_list_element *c,
					  char *cmd, int from_tty));
d1248 1
a1248 1
extern NORETURN void (*error_hook) PARAMS ((void)) ATTR_NORETURN;
d1250 1
d1265 2
a1266 5
#ifndef SLASH_P
#if defined(__GO32__)||defined(_WIN32)
#define SLASH_P(X) ((X)=='\\')
#else
#define SLASH_P(X) ((X)=='/')
d1268 4
d1274 10
a1283 5
#ifndef SLASH_CHAR
#if defined(__GO32__)||defined(_WIN32)
#define SLASH_CHAR '\\'
#else
#define SLASH_CHAR '/'
d1285 4
d1290 2
a1291 6

#ifndef SLASH_STRING
#if defined(__GO32__)||defined(_WIN32)
#define SLASH_STRING "\\"
#else
#define SLASH_STRING "/"
d1293 2
d1297 4
a1300 2
#ifndef ROOTED_P
#define ROOTED_P(X) (SLASH_P((X)[0]))
d1302 32
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@a402 4
/* From readline (but not in any readline .h files).  */

extern char *tilde_expand PARAMS ((char *));

@


1.1
log
@file defs.h was initially added on branch CYGNUS.
@
text
@d1 1050
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 1335
/* *INDENT-OFF* */ /* ATTR_FORMAT confuses indent, avoid running it for now */
/* Basic, host-specific, and target-specific definitions for GDB.
   Copyright 1986, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#ifndef DEFS_H
#define DEFS_H

#include "config.h"		/* Generated by configure.  */

#include <stdio.h>
#include <errno.h>		/* System call error return status.  */
#include <limits.h>

#ifdef HAVE_STDDEF_H
#include <stddef.h>
#else
#include <sys/types.h>		/* For size_t.  */
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

/* First include ansidecl.h so we can use the various macro definitions
   here and in all subsequent file inclusions.  */

#include "ansidecl.h"

#include "gdb_locale.h"

/* For ``enum target_signal''.  */
#include "gdb/signals.h"

/* Just in case they're not defined in stdio.h.  */

#ifndef SEEK_SET
#define SEEK_SET 0
#endif
#ifndef SEEK_CUR
#define SEEK_CUR 1
#endif

#include <stdarg.h>		/* For va_list.  */

#include "libiberty.h"

/* For BFD64 and bfd_vma.  */
#include "bfd.h"


/* The target is partially multi-arched.  Both "tm.h" and the
   multi-arch vector provide definitions.  "tm.h" normally overrides
   the multi-arch vector (but there are a few exceptions).  */

#define GDB_MULTI_ARCH_PARTIAL 1

/* The target is partially multi-arched. Both the multi-arch vector
   and "tm.h" provide definitions. "tm.h" cannot override a definition
   provided by the multi-arch vector.  It is detected as a compilation
   error.

   This setting is only useful during a multi-arch conversion. */

#define GDB_MULTI_ARCH_TM 2

/* The target is pure multi-arch.  The MULTI-ARCH vector provides all
   definitions.  "tm.h" is linked to an empty file. */

#define GDB_MULTI_ARCH_PURE 3



/* An address in the program being debugged.  Host byte order.  Rather
   than duplicate all the logic in BFD which figures out what type
   this is (long, long long, etc.) and whether it needs to be 64
   bits (the host/target interactions are subtle), we just use
   bfd_vma.  */

typedef bfd_vma CORE_ADDR;

/* This is to make sure that LONGEST is at least as big as CORE_ADDR.  */

#ifndef LONGEST

#ifdef BFD64

#define LONGEST BFD_HOST_64_BIT
#define ULONGEST BFD_HOST_U_64_BIT

#else /* No BFD64 */

#ifdef CC_HAS_LONG_LONG
#define LONGEST long long
#define ULONGEST unsigned long long
#else
#ifdef BFD_HOST_64_BIT
/* BFD_HOST_64_BIT is defined for some hosts that don't have long long
   (e.g. i386-windows) so try it.  */
#define LONGEST BFD_HOST_64_BIT
#define ULONGEST BFD_HOST_U_64_BIT
#else
#define LONGEST long
#define ULONGEST unsigned long
#endif
#endif

#endif /* No BFD64 */

#endif /* ! LONGEST */

#ifndef min
#define min(a, b) ((a) < (b) ? (a) : (b))
#endif
#ifndef max
#define max(a, b) ((a) > (b) ? (a) : (b))
#endif

/* Macros to do string compares.

   NOTE: cagney/2000-03-14:

   While old code can continue to refer to these macros, new code is
   probably better off using strcmp() directly vis: ``strcmp() == 0''
   and ``strcmp() != 0''.

   This is because modern compilers can directly inline strcmp()
   making the original justification for these macros - avoid function
   call overhead by pre-testing the first characters
   (``*X==*Y?...:0'') - redundant.

   ``Even if [...] testing the first character does have a modest
   performance improvement, I'd rather that whenever a performance
   issue is found that we spend the effort on algorithmic
   optimizations than micro-optimizing.'' J.T. */

/* NOTE: cagney/2003-11-23: All instances of STREQ[N] covered by
   testing GDB on a stabs system have been replaced by equivalent
   str[n]cmp calls.  To avoid the possability of introducing bugs when
   making untested changes, the remaining references were deprecated
   rather than replaced.  */

/* DISCLAIMER: cagney/2003-11-23: Simplified definition of these
   macros so that they just map directly onto strcmp equivalent.  I'm
   not responsible for any breakage due to code that relied on the old
   underlying implementation.  */

#define DEPRECATED_STREQ(a,b) (strcmp ((a), (b)) == 0)
#define DEPRECATED_STREQN(a,b,c) (strncmp ((a), (b), (c)) == 0)

/* Check if a character is one of the commonly used C++ marker characters.  */
extern int is_cplus_marker (int);

/* enable xdb commands if set */
extern int xdb_commands;

/* enable dbx commands if set */
extern int dbx_commands;

/* System root path, used to find libraries etc.  */
extern char *gdb_sysroot;

extern int quit_flag;
extern int immediate_quit;
extern int sevenbit_strings;

extern void quit (void);

/* FIXME: cagney/2000-03-13: It has been suggested that the peformance
   benefits of having a ``QUIT'' macro rather than a function are
   marginal.  If the overhead of a QUIT function call is proving
   significant then its calling frequency should probably be reduced
   [kingdon].  A profile analyzing the current situtation is
   needed. */

#ifdef QUIT
/* do twice to force compiler warning */
#define QUIT_FIXME "FIXME"
#define QUIT_FIXME "ignoring redefinition of QUIT"
#else
#define QUIT { \
  if (quit_flag) quit (); \
  if (interactive_hook) interactive_hook (); \
}
#endif

/* Languages represented in the symbol table and elsewhere.
   This should probably be in language.h, but since enum's can't
   be forward declared to satisfy opaque references before their
   actual definition, needs to be here. */

enum language
  {
    language_unknown,		/* Language not known */
    language_auto,		/* Placeholder for automatic setting */
    language_c,			/* C */
    language_cplus,		/* C++ */
    language_objc,		/* Objective-C */
    language_java,		/* Java */
    language_fortran,		/* Fortran */
    language_m2,		/* Modula-2 */
    language_asm,		/* Assembly language */
    language_scm,    		/* Scheme / Guile */
    language_pascal,		/* Pascal */
    language_minimal		/* All other languages, minimal support only */
  };

enum precision_type
  {
    single_precision,
    double_precision,
    unspecified_precision
  };

/* A generic, not quite boolean, enumeration.  */
enum auto_boolean
{
  AUTO_BOOLEAN_TRUE,
  AUTO_BOOLEAN_FALSE,
  AUTO_BOOLEAN_AUTO
};

/* Potential ways that a function can return a value of a given type.  */
enum return_value_convention
{
  /* Where the return value has been squeezed into one or more
     registers.  */
  RETURN_VALUE_REGISTER_CONVENTION,
  /* Commonly known as the "struct return convention".  The caller
     passes an additional hidden first parameter to the caller.  That
     parameter contains the address at which the value being returned
     should be stored.  While typically, and historically, used for
     large structs, this is convention is applied to values of many
     different types.  */
  RETURN_VALUE_STRUCT_CONVENTION
};

/* the cleanup list records things that have to be undone
   if an error happens (descriptors to be closed, memory to be freed, etc.)
   Each link in the chain records a function to call and an
   argument to give it.

   Use make_cleanup to add an element to the cleanup chain.
   Use do_cleanups to do all cleanup actions back to a given
   point in the chain.  Use discard_cleanups to remove cleanups
   from the chain back to a given point, not doing them.  */

struct cleanup
  {
    struct cleanup *next;
    void (*function) (void *);
    void *arg;
  };


/* The ability to declare that a function never returns is useful, but
   not really required to compile GDB successfully, so the NORETURN and
   ATTR_NORETURN macros normally expand into nothing.  */

/* If compiling with older versions of GCC, a function may be declared
   "volatile" to indicate that it does not return.  */

#ifndef NORETURN
#if defined(__GNUC__) \
     && (__GNUC__ == 1 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7))
#define NORETURN volatile
#else
#define NORETURN		/* nothing */
#endif
#endif

/* GCC 2.5 and later versions define a function attribute "noreturn",
   which is the preferred way to declare that a function never returns.
   However GCC 2.7 appears to be the first version in which this fully
   works everywhere we use it. */

#ifndef ATTR_NORETURN
#if defined(__GNUC__) && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7))
#define ATTR_NORETURN __attribute__ ((noreturn))
#else
#define ATTR_NORETURN		/* nothing */
#endif
#endif

#ifndef ATTR_FORMAT
#if defined(__GNUC__) && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 4))
#define ATTR_FORMAT(type, x, y) __attribute__ ((format(type, x, y)))
#else
#define ATTR_FORMAT(type, x, y)	/* nothing */
#endif
#endif

/* Be conservative and use enum bitfields only with GCC.
   This is copied from gcc 3.3.1, system.h.  */

#if defined(__GNUC__) && (__GNUC__ >= 2)
#define ENUM_BITFIELD(TYPE) enum TYPE
#else
#define ENUM_BITFIELD(TYPE) unsigned int
#endif

/* Needed for various prototypes */

struct symtab;
struct breakpoint;
struct frame_info;

/* From blockframe.c */

extern int inside_entry_func (struct frame_info *this_frame);

extern int deprecated_inside_entry_file (CORE_ADDR addr);

extern int inside_main_func (CORE_ADDR pc);

/* From utils.c */

extern void initialize_utils (void);

extern void notice_quit (void);

extern int strcmp_iw (const char *, const char *);

extern int strcmp_iw_ordered (const char *, const char *);

extern int streq (const char *, const char *);

extern int subset_compare (char *, char *);

extern char *safe_strerror (int);

extern void init_malloc (void *);

extern void request_quit (int);

extern void do_cleanups (struct cleanup *);
extern void do_final_cleanups (struct cleanup *);
extern void do_run_cleanups (struct cleanup *);
extern void do_exec_cleanups (struct cleanup *);
extern void do_exec_error_cleanups (struct cleanup *);

extern void discard_cleanups (struct cleanup *);
extern void discard_final_cleanups (struct cleanup *);
extern void discard_exec_error_cleanups (struct cleanup *);
extern void discard_my_cleanups (struct cleanup **, struct cleanup *);

/* NOTE: cagney/2000-03-04: This typedef is strictly for the
   make_cleanup function declarations below. Do not use this typedef
   as a cast when passing functions into the make_cleanup() code.
   Instead either use a bounce function or add a wrapper function.
   Calling a f(char*) function with f(void*) is non-portable. */
typedef void (make_cleanup_ftype) (void *);

extern struct cleanup *make_cleanup (make_cleanup_ftype *, void *);

extern struct cleanup *make_cleanup_freeargv (char **);

struct ui_file;
extern struct cleanup *make_cleanup_ui_file_delete (struct ui_file *);

extern struct cleanup *make_cleanup_close (int fd);

extern struct cleanup *make_cleanup_bfd_close (bfd *abfd);

extern struct cleanup *make_final_cleanup (make_cleanup_ftype *, void *);

extern struct cleanup *make_my_cleanup (struct cleanup **,
					make_cleanup_ftype *, void *);

extern struct cleanup *make_run_cleanup (make_cleanup_ftype *, void *);

extern struct cleanup *make_exec_cleanup (make_cleanup_ftype *, void *);
extern struct cleanup *make_exec_error_cleanup (make_cleanup_ftype *, void *);

extern struct cleanup *save_cleanups (void);
extern struct cleanup *save_final_cleanups (void);
extern struct cleanup *save_my_cleanups (struct cleanup **);

extern void restore_cleanups (struct cleanup *);
extern void restore_final_cleanups (struct cleanup *);
extern void restore_my_cleanups (struct cleanup **, struct cleanup *);

extern void free_current_contents (void *);

extern void null_cleanup (void *);

extern int myread (int, char *, int);

extern int query (const char *, ...) ATTR_FORMAT (printf, 1, 2);
extern int nquery (const char *, ...) ATTR_FORMAT (printf, 1, 2);
extern int yquery (const char *, ...) ATTR_FORMAT (printf, 1, 2);

extern void init_page_info (void);

extern char *gdb_realpath (const char *);
extern char *xfullpath (const char *);

extern unsigned long gnu_debuglink_crc32 (unsigned long crc,
                                          unsigned char *buf, size_t len);

/* From demangle.c */

extern void set_demangling_style (char *);

/* From tm.h */

struct type;
typedef int (use_struct_convention_fn) (int gcc_p, struct type * value_type);
extern use_struct_convention_fn generic_use_struct_convention;


/* Annotation stuff.  */

extern int annotation_level;	/* in stack.c */

extern void begin_line (void);

extern void wrap_here (char *);

extern void reinitialize_more_filter (void);

/* Normal results */
extern struct ui_file *gdb_stdout;
/* Input stream */
extern struct ui_file *gdb_stdin;
/* Serious error notifications */
extern struct ui_file *gdb_stderr;
/* Log/debug/trace messages that should bypass normal stdout/stderr
   filtering.  For moment, always call this stream using
   *_unfiltered. In the very near future that restriction shall be
   removed - either call shall be unfiltered. (cagney 1999-06-13). */
extern struct ui_file *gdb_stdlog;
/* Target output that should bypass normal stdout/stderr filtering.
   For moment, always call this stream using *_unfiltered. In the
   very near future that restriction shall be removed - either call
   shall be unfiltered. (cagney 1999-07-02). */
extern struct ui_file *gdb_stdtarg;
extern struct ui_file *gdb_stdtargerr;
extern struct ui_file *gdb_stdtargin;

#include "ui-file.h"

/* More generic printf like operations.  Filtered versions may return
   non-locally on error.  */

extern void fputs_filtered (const char *, struct ui_file *);

extern void fputs_unfiltered (const char *, struct ui_file *);

extern int fputc_filtered (int c, struct ui_file *);

extern int fputc_unfiltered (int c, struct ui_file *);

extern int putchar_filtered (int c);

extern int putchar_unfiltered (int c);

extern void puts_filtered (const char *);

extern void puts_unfiltered (const char *);

extern void puts_filtered_tabular (char *string, int width, int right);

extern void puts_debug (char *prefix, char *string, char *suffix);

extern void vprintf_filtered (const char *, va_list) ATTR_FORMAT (printf, 1, 0);

extern void vfprintf_filtered (struct ui_file *, const char *, va_list) ATTR_FORMAT (printf, 2, 0);

extern void fprintf_filtered (struct ui_file *, const char *, ...) ATTR_FORMAT (printf, 2, 3);

extern void fprintfi_filtered (int, struct ui_file *, const char *, ...) ATTR_FORMAT (printf, 3, 4);

extern void printf_filtered (const char *, ...) ATTR_FORMAT (printf, 1, 2);

extern void printfi_filtered (int, const char *, ...) ATTR_FORMAT (printf, 2, 3);

extern void vprintf_unfiltered (const char *, va_list) ATTR_FORMAT (printf, 1, 0);

extern void vfprintf_unfiltered (struct ui_file *, const char *, va_list) ATTR_FORMAT (printf, 2, 0);

extern void fprintf_unfiltered (struct ui_file *, const char *, ...) ATTR_FORMAT (printf, 2, 3);

extern void printf_unfiltered (const char *, ...) ATTR_FORMAT (printf, 1, 2);

extern void print_spaces (int, struct ui_file *);

extern void print_spaces_filtered (int, struct ui_file *);

extern char *n_spaces (int);

extern void fputstr_filtered (const char *str, int quotr, struct ui_file * stream);

extern void fputstr_unfiltered (const char *str, int quotr, struct ui_file * stream);

extern void fputstrn_unfiltered (const char *str, int n, int quotr, struct ui_file * stream);

/* Display the host ADDR on STREAM formatted as ``0x%x''. */
extern void gdb_print_host_address (const void *addr, struct ui_file *stream);

/* Convert a CORE_ADDR into a HEX string.  paddr() is like %08lx.
   paddr_nz() is like %lx.  paddr_u() is like %lu. paddr_width() is
   for ``%*''. */
extern int strlen_paddr (void);
extern char *paddr (CORE_ADDR addr);
extern char *paddr_nz (CORE_ADDR addr);
extern char *paddr_u (CORE_ADDR addr);
extern char *paddr_d (LONGEST addr);

extern char *phex (ULONGEST l, int sizeof_l);
extern char *phex_nz (ULONGEST l, int sizeof_l);

/* Like paddr() only print/scan raw CORE_ADDR.  The output from
   core_addr_to_string() can be passed direct to
   string_to_core_addr().  */
extern const char *core_addr_to_string (const CORE_ADDR addr);
extern const char *core_addr_to_string_nz (const CORE_ADDR addr);
extern CORE_ADDR string_to_core_addr (const char *my_string);

extern void fprintf_symbol_filtered (struct ui_file *, char *,
				     enum language, int);

extern NORETURN void perror_with_name (const char *) ATTR_NORETURN;

extern void print_sys_errmsg (const char *, int);

/* From regex.c or libc.  BSD 4.4 declares this with the argument type as
   "const char *" in unistd.h, so we can't declare the argument
   as "char *".  */

extern char *re_comp (const char *);

/* From symfile.c */

extern void symbol_file_command (char *, int);

/* Remote targets may wish to use this as their load function.  */
extern void generic_load (char *name, int from_tty);

/* Summarise a download */
extern void print_transfer_performance (struct ui_file *stream,
					unsigned long data_count,
					unsigned long write_count,
					unsigned long time_count);

/* From top.c */

typedef void initialize_file_ftype (void);

extern char *skip_quoted (char *);

extern char *gdb_readline (char *);

extern char *gdb_readline_wrapper (char *);

extern char *command_line_input (char *, int, char *);

extern void print_prompt (void);

extern int input_from_terminal_p (void);

extern int info_verbose;

/* From printcmd.c */

extern void set_next_address (CORE_ADDR);

extern void print_address_symbolic (CORE_ADDR, struct ui_file *, int,
				    char *);

extern int build_address_symbolic (CORE_ADDR addr,
				   int do_demangle, 
				   char **name, 
				   int *offset, 
				   char **filename, 
				   int *line, 	
				   int *unmapped);

extern void print_address_numeric (CORE_ADDR, int, struct ui_file *);

extern void print_address (CORE_ADDR, struct ui_file *);

/* From source.c */

extern int openp (const char *, int, const char *, int, int, char **);

extern int source_full_path_of (char *, char **);

extern void mod_path (char *, char **);

extern void add_path (char *, char **, int);

extern void directory_command (char *, int);

extern char *source_path;

extern void init_source_path (void);

extern void init_last_source_visited (void);

extern char *symtab_to_filename (struct symtab *);

/* From exec.c */

extern void exec_set_section_offsets (bfd_signed_vma text_off,
				      bfd_signed_vma data_off,
				      bfd_signed_vma bss_off);

/* Take over the 'find_mapped_memory' vector from exec.c. */
extern void exec_set_find_memory_regions (int (*) (int (*) (CORE_ADDR, 
							    unsigned long, 
							    int, int, int, 
							    void *),
						   void *));

/* Possible lvalue types.  Like enum language, this should be in
   value.h, but needs to be here for the same reason. */

enum lval_type
  {
    /* Not an lval. */
    not_lval,
    /* In memory.  Could be a saved register.  */
    lval_memory,
    /* In a register.  */
    lval_register,
    /* In a gdb internal variable.  */
    lval_internalvar,
    /* Part of a gdb internal variable (structure field).  */
    lval_internalvar_component,
    /* In a register series in a frame not the current one, which may have been
       partially saved or saved in different places (otherwise would be
       lval_register or lval_memory).  */
    lval_reg_frame_relative
  };

/* Control types for commands */

enum misc_command_type
  {
    ok_command,
    end_command,
    else_command,
    nop_command
  };

enum command_control_type
  {
    simple_control,
    break_control,
    continue_control,
    while_control,
    if_control,
    invalid_control
  };

/* Structure for saved commands lines
   (for breakpoints, defined commands, etc).  */

struct command_line
  {
    struct command_line *next;
    char *line;
    enum command_control_type control_type;
    int body_count;
    struct command_line **body_list;
  };

extern struct command_line *read_command_lines (char *, int);

extern void free_command_lines (struct command_line **);

/* To continue the execution commands when running gdb asynchronously. 
   A continuation structure contains a pointer to a function to be called 
   to finish the command, once the target has stopped. Such mechanism is
   used bt the finish and until commands, and in the remote protocol
   when opening an extended-remote connection. */

struct continuation_arg
  {
    struct continuation_arg *next;
    union continuation_data {
      void *pointer;
      int   integer;
      long  longint;
    } data;
  };

struct continuation
  {
    void (*continuation_hook) (struct continuation_arg *);
    struct continuation_arg *arg_list;
    struct continuation *next;
  };

/* In infrun.c. */
extern struct continuation *cmd_continuation;
/* Used only by the step_1 function. */
extern struct continuation *intermediate_continuation;

/* From utils.c */
extern void add_continuation (void (*)(struct continuation_arg *),
			      struct continuation_arg *);
extern void do_all_continuations (void);
extern void discard_all_continuations (void);

extern void add_intermediate_continuation (void (*)(struct continuation_arg *),
			      struct continuation_arg *);
extern void do_all_intermediate_continuations (void);
extern void discard_all_intermediate_continuations (void);

/* String containing the current directory (what getwd would return).  */

extern char *current_directory;

/* Default radixes for input and output.  Only some values supported.  */
extern unsigned input_radix;
extern unsigned output_radix;

/* Possibilities for prettyprint parameters to routines which print
   things.  Like enum language, this should be in value.h, but needs
   to be here for the same reason.  FIXME:  If we can eliminate this
   as an arg to LA_VAL_PRINT, then we can probably move it back to
   value.h. */

enum val_prettyprint
  {
    Val_no_prettyprint = 0,
    Val_prettyprint,
    /* Use the default setting which the user has specified.  */
    Val_pretty_default
  };

/* The ptid struct is a collection of the various "ids" necessary
   for identifying the inferior.  This consists of the process id
   (pid), thread id (tid), and other fields necessary for uniquely
   identifying the inferior process/thread being debugged.  When
   manipulating ptids, the constructors, accessors, and predicate
   declared in inferior.h should be used.  These are as follows:

      ptid_build	- Make a new ptid from a pid, lwp, and tid.
      pid_to_ptid	- Make a new ptid from just a pid.
      ptid_get_pid	- Fetch the pid component of a ptid.
      ptid_get_lwp	- Fetch the lwp component of a ptid.
      ptid_get_tid	- Fetch the tid component of a ptid.
      ptid_equal	- Test to see if two ptids are equal.

   Please do NOT access the struct ptid members directly (except, of
   course, in the implementation of the above ptid manipulation
   functions).  */

struct ptid
  {
    /* Process id */
    int pid;

    /* Lightweight process id */
    long lwp;

    /* Thread id */
    long tid;
  };

typedef struct ptid ptid_t;



/* Optional host machine definition.  Pure autoconf targets will not
   need a "xm.h" file.  This will be a symlink to one of the xm-*.h
   files, built by the `configure' script.  */

#ifdef GDB_XM_FILE
#include "xm.h"
#endif

/* Optional native machine support.  Non-native (and possibly pure
   multi-arch) targets do not need a "nm.h" file.  This will be a
   symlink to one of the nm-*.h files, built by the `configure'
   script.  */

#ifdef GDB_NM_FILE
#include "nm.h"
#endif

/* Optional target machine definition.  Pure multi-arch configurations
   do not need a "tm.h" file.  This will be a symlink to one of the
   tm-*.h files, built by the `configure' script.  */

#ifdef GDB_TM_FILE
#include "tm.h"
#endif

/* If the xm.h file did not define the mode string used to open the
   files, assume that binary files are opened the same way as text
   files */
#ifndef FOPEN_RB
#include "fopen-same.h"
#endif

/* Defaults for system-wide constants (if not defined by xm.h, we fake it).
   FIXME: Assumes 2's complement arithmetic */

#if !defined (UINT_MAX)
#define	UINT_MAX ((unsigned int)(~0))	/* 0xFFFFFFFF for 32-bits */
#endif

#if !defined (INT_MAX)
#define	INT_MAX ((int)(UINT_MAX >> 1))	/* 0x7FFFFFFF for 32-bits */
#endif

#if !defined (INT_MIN)
#define INT_MIN ((int)((int) ~0 ^ INT_MAX))	/* 0x80000000 for 32-bits */
#endif

#if !defined (ULONG_MAX)
#define	ULONG_MAX ((unsigned long)(~0L))	/* 0xFFFFFFFF for 32-bits */
#endif

#if !defined (LONG_MAX)
#define	LONG_MAX ((long)(ULONG_MAX >> 1))	/* 0x7FFFFFFF for 32-bits */
#endif

#if !defined (ULONGEST_MAX)
#define	ULONGEST_MAX (~(ULONGEST)0)        /* 0xFFFFFFFFFFFFFFFF for 64-bits */
#endif

#if !defined (LONGEST_MAX)                 /* 0x7FFFFFFFFFFFFFFF for 64-bits */
#define	LONGEST_MAX ((LONGEST)(ULONGEST_MAX >> 1))
#endif

/* Convert a LONGEST to an int.  This is used in contexts (e.g. number of
   arguments to a function, number in a value history, register number, etc.)
   where the value must not be larger than can fit in an int.  */

extern int longest_to_int (LONGEST);

/* Assorted functions we can declare, now that const and volatile are 
   defined.  */

extern char *savestring (const char *, size_t);

extern char *msavestring (void *, const char *, size_t);

extern char *mstrsave (void *, const char *);

/* Robust versions of same.  Throw an internal error when no memory,
   guard against stray NULL arguments. */
extern void *xmmalloc (void *md, size_t size);
extern void *xmrealloc (void *md, void *ptr, size_t size);
extern void *xmcalloc (void *md, size_t number, size_t size);
extern void xmfree (void *md, void *ptr);

/* xmalloc(), xrealloc() and xcalloc() have already been declared in
   "libiberty.h". */
extern void xfree (void *);

/* Utility macros to allocate typed memory.  Avoids errors like:
   struct foo *foo = xmalloc (sizeof struct bar); and memset (foo,
   sizeof (struct foo), 0).  */
#define XZALLOC(TYPE) ((TYPE*) memset (xmalloc (sizeof (TYPE)), 0, sizeof (TYPE)))
#define XMALLOC(TYPE) ((TYPE*) xmalloc (sizeof (TYPE)))
#define XCALLOC(NMEMB, TYPE) ((TYPE*) xcalloc ((NMEMB), sizeof (TYPE)))

/* Like asprintf/vasprintf but get an internal_error if the call
   fails. */
extern void xasprintf (char **ret, const char *format, ...) ATTR_FORMAT (printf, 2, 3);
extern void xvasprintf (char **ret, const char *format, va_list ap);

/* Like asprintf, but return the string, throw an error if no memory.  */
extern char *xstrprintf (const char *format, ...) ATTR_FORMAT (printf, 1, 2);

extern int parse_escape (char **);

/* Message to be printed before the error message, when an error occurs.  */

extern char *error_pre_print;

/* Message to be printed before the error message, when an error occurs.  */

extern char *quit_pre_print;

/* Message to be printed before the warning message, when a warning occurs.  */

extern char *warning_pre_print;

extern NORETURN void verror (const char *fmt, va_list ap) ATTR_NORETURN;

extern NORETURN void error (const char *fmt, ...) ATTR_NORETURN ATTR_FORMAT (printf, 1, 2);

extern NORETURN void error_silent (const char *fmt, ...) ATTR_NORETURN ATTR_FORMAT (printf, 1, 2);

extern NORETURN void error_stream (struct ui_file *) ATTR_NORETURN;

/* Initialize the error buffer.  */
extern void error_init (void);

/* Returns a freshly allocate buffer containing the last error
   message.  */
extern char *error_last_message (void);

/* Output arbitrary error message.  */
extern void error_output_message (char *pre_print, char *msg);

extern NORETURN void internal_verror (const char *file, int line,
				      const char *, va_list ap) ATTR_NORETURN;

extern NORETURN void internal_error (const char *file, int line,
				     const char *, ...) ATTR_NORETURN ATTR_FORMAT (printf, 3, 4);

extern void internal_vwarning (const char *file, int line,
			       const char *, va_list ap);

extern void internal_warning (const char *file, int line,
			      const char *, ...) ATTR_FORMAT (printf, 3, 4);

extern NORETURN void nomem (long) ATTR_NORETURN;

/* Reasons for calling throw_exception().  NOTE: all reason values
   must be less than zero.  enum value 0 is reserved for internal use
   as the return value from an initial setjmp().  The function
   catch_exceptions() reserves values >= 0 as legal results from its
   wrapped function.  */

enum return_reason
  {
    /* User interrupt.  */
    RETURN_QUIT = -2,
    /* Any other error.  */
    RETURN_ERROR
  };

#define	ALL_CLEANUPS	((struct cleanup *)0)

#define RETURN_MASK(reason)	(1 << (int)(-reason))
#define RETURN_MASK_QUIT	RETURN_MASK (RETURN_QUIT)
#define RETURN_MASK_ERROR	RETURN_MASK (RETURN_ERROR)
#define RETURN_MASK_ALL		(RETURN_MASK_QUIT | RETURN_MASK_ERROR)
typedef int return_mask;

/* Throw an exception of type RETURN_REASON.  Will execute a LONG JUMP
   to the inner most containing exception handler established using
   catch_exceptions() (or the legacy catch_errors()).

   Code normally throws an exception using error() et.al.  For various
   reaons, GDB also contains code that throws an exception directly.
   For instance, the remote*.c targets contain CNTRL-C signal handlers
   that propogate the QUIT event up the exception chain.  ``This could
   be a good thing or a dangerous thing.'' -- the Existential Wombat.  */

extern NORETURN void throw_exception (enum return_reason) ATTR_NORETURN;

/* Call FUNC(UIOUT, FUNC_ARGS) but wrapped within an exception
   handler.  If an exception (enum return_reason) is thrown using
   throw_exception() than all cleanups installed since
   catch_exceptions() was entered are invoked, the (-ve) exception
   value is then returned by catch_exceptions.  If FUNC() returns
   normally (with a postive or zero return value) then that value is
   returned by catch_exceptions().  It is an internal_error() for
   FUNC() to return a negative value.

   For the period of the FUNC() call: UIOUT is installed as the output
   builder; ERRSTRING is installed as the error/quit message; and a
   new cleanup_chain is established.  The old values are restored
   before catch_exceptions() returns.

   The variant catch_exceptions_with_msg() is the same as
   catch_exceptions() but adds the ability to return an allocated
   copy of the gdb error message.  This is used when a silent error is 
   issued and the caller wants to manually issue the error message.

   FIXME; cagney/2001-08-13: The need to override the global UIOUT
   builder variable should just go away.

   This function superseeds catch_errors().

   This function uses SETJMP() and LONGJUMP().  */

struct ui_out;
typedef int (catch_exceptions_ftype) (struct ui_out *ui_out, void *args);
extern int catch_exceptions (struct ui_out *uiout,
			     catch_exceptions_ftype *func, void *func_args,
			     char *errstring, return_mask mask);
extern int catch_exceptions_with_msg (struct ui_out *uiout,
			     	      catch_exceptions_ftype *func, 
			     	      void *func_args,
			     	      char *errstring, char **gdberrmsg,
				      return_mask mask);

/* If CATCH_ERRORS_FTYPE throws an error, catch_errors() returns zero
   otherwize the result from CATCH_ERRORS_FTYPE is returned. It is
   probably useful for CATCH_ERRORS_FTYPE to always return a non-zero
   value. It's unfortunate that, catch_errors() does not return an
   indication of the exact exception that it caught - quit_flag might
   help.

   This function is superseeded by catch_exceptions().  */

typedef int (catch_errors_ftype) (void *);
extern int catch_errors (catch_errors_ftype *, void *, char *, return_mask);

/* Template to catch_errors() that wraps calls to command
   functions. */

typedef void (catch_command_errors_ftype) (char *, int);
extern int catch_command_errors (catch_command_errors_ftype *func, char *command, int from_tty, return_mask);

extern void warning (const char *, ...) ATTR_FORMAT (printf, 1, 2);

extern void vwarning (const char *, va_list args);

/* List of known OS ABIs.  If you change this, make sure to update the
   table in osabi.c.  */
enum gdb_osabi
{
  GDB_OSABI_UNINITIALIZED = -1, /* For struct gdbarch_info.  */

  GDB_OSABI_UNKNOWN = 0,	/* keep this zero */

  GDB_OSABI_SVR4,
  GDB_OSABI_HURD,
  GDB_OSABI_SOLARIS,
  GDB_OSABI_OSF1,
  GDB_OSABI_LINUX,
  GDB_OSABI_FREEBSD_AOUT,
  GDB_OSABI_FREEBSD_ELF,
  GDB_OSABI_NETBSD_AOUT,
  GDB_OSABI_NETBSD_ELF,
  GDB_OSABI_OPENBSD_ELF,
  GDB_OSABI_WINCE,
  GDB_OSABI_GO32,
  GDB_OSABI_NETWARE,
  GDB_OSABI_IRIX,
  GDB_OSABI_LYNXOS,
  GDB_OSABI_INTERIX,
  GDB_OSABI_HPUX_ELF,
  GDB_OSABI_HPUX_SOM,

  GDB_OSABI_ARM_EABI_V1,
  GDB_OSABI_ARM_EABI_V2,
  GDB_OSABI_ARM_APCS,
  GDB_OSABI_QNXNTO,

  GDB_OSABI_CYGWIN,

  GDB_OSABI_INVALID		/* keep this last */
};

/* Global functions from other, non-gdb GNU thingies.
   Libiberty thingies are no longer declared here.  We include libiberty.h
   above, instead.  */

#ifndef GETENV_PROVIDED
extern char *getenv (const char *);
#endif

/* From other system libraries */

#ifdef HAVE_STDDEF_H
#include <stddef.h>
#endif

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifndef min
#define min(a, b) ((a) < (b) ? (a) : (b))
#endif
#ifndef max
#define max(a, b) ((a) > (b) ? (a) : (b))
#endif


/* We take the address of fclose later, but some stdio's forget
   to declare this.  We can't always declare it since there's
   no way to declare the parameters without upsetting some compiler
   somewhere. */

#ifndef FCLOSE_PROVIDED
extern int fclose (FILE *);
#endif

#ifndef atof
extern double atof (const char *);	/* X3.159-1989  4.10.1.1 */
#endif

/* Various possibilities for alloca.  */
#ifndef alloca
#ifdef __GNUC__
#define alloca __builtin_alloca
#else /* Not GNU C */
#ifdef HAVE_ALLOCA_H
#include <alloca.h>
#else
#ifdef _AIX
#pragma alloca
#else

/* We need to be careful not to declare this in a way which conflicts with
   bison.  Bison never declares it as char *, but under various circumstances
   (like __hpux) we need to use void *.  */
extern void *alloca ();
#endif /* Not _AIX */
#endif /* Not HAVE_ALLOCA_H */
#endif /* Not GNU C */
#endif /* alloca not defined */

/* Is GDB multi-arch?  If there's a "tm.h" file, it is not.  */
#ifndef GDB_MULTI_ARCH
#ifdef GDB_TM_FILE
#define GDB_MULTI_ARCH GDB_MULTI_ARCH_PARTIAL
#else
#define GDB_MULTI_ARCH GDB_MULTI_ARCH_PURE
#endif
#endif

/* Dynamic target-system-dependent parameters for GDB. */
#include "gdbarch.h"

/* Maximum size of a register.  Something small, but large enough for
   all known ISAs.  If it turns out to be too small, make it bigger.  */

enum { MAX_REGISTER_SIZE = 16 };

/* Static target-system-dependent parameters for GDB. */

/* Number of bits in a char or unsigned char for the target machine.
   Just like CHAR_BIT in <limits.h> but describes the target machine.  */
#if !defined (TARGET_CHAR_BIT)
#define TARGET_CHAR_BIT 8
#endif

/* If we picked up a copy of CHAR_BIT from a configuration file
   (which may get it by including <limits.h>) then use it to set
   the number of bits in a host char.  If not, use the same size
   as the target. */

#if defined (CHAR_BIT)
#define HOST_CHAR_BIT CHAR_BIT
#else
#define HOST_CHAR_BIT TARGET_CHAR_BIT
#endif

/* The bit byte-order has to do just with numbering of bits in
   debugging symbols and such.  Conceptually, it's quite separate
   from byte/word byte order.  */

#if !defined (BITS_BIG_ENDIAN)
#define BITS_BIG_ENDIAN (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
#endif

/* In findvar.c.  */

extern LONGEST extract_signed_integer (const void *, int);

extern ULONGEST extract_unsigned_integer (const void *, int);

extern int extract_long_unsigned_integer (const void *, int, LONGEST *);

extern CORE_ADDR extract_typed_address (const void *buf, struct type *type);

extern void store_signed_integer (void *, int, LONGEST);

extern void store_unsigned_integer (void *, int, ULONGEST);

extern void store_typed_address (void *buf, struct type *type, CORE_ADDR addr);


/* From valops.c */

extern CORE_ADDR push_bytes (CORE_ADDR, char *, int);

extern CORE_ADDR push_word (CORE_ADDR, ULONGEST);

extern int watchdog;

/* Hooks for alternate command interfaces.  */

/* The name of the interpreter if specified on the command line. */
extern char *interpreter_p;

/* If a given interpreter matches INTERPRETER_P then it should update
   command_loop_hook and init_ui_hook with the per-interpreter
   implementation. */
/* FIXME: command_loop_hook and init_ui_hook should be moved here. */

struct target_waitstatus;
struct cmd_list_element;

/* Should the asynchronous variant of the interpreter (using the
   event-loop) be enabled? */
extern int event_loop_p;

extern void (*init_ui_hook) (char *argv0);
extern void (*command_loop_hook) (void);
extern void (*show_load_progress) (const char *section,
				   unsigned long section_sent, 
				   unsigned long section_size, 
				   unsigned long total_sent, 
				   unsigned long total_size);
extern void (*print_frame_info_listing_hook) (struct symtab * s,
					      int line, int stopline,
					      int noerror);
extern struct frame_info *parse_frame_specification (char *frame_exp);
extern int (*query_hook) (const char *, va_list);
extern void (*warning_hook) (const char *, va_list);
extern void (*flush_hook) (struct ui_file * stream);
extern void (*create_breakpoint_hook) (struct breakpoint * b);
extern void (*delete_breakpoint_hook) (struct breakpoint * bpt);
extern void (*modify_breakpoint_hook) (struct breakpoint * bpt);
extern void (*interactive_hook) (void);
extern void (*registers_changed_hook) (void);
extern void (*readline_begin_hook) (char *,...);
extern char *(*readline_hook) (char *);
extern void (*readline_end_hook) (void);
extern void (*register_changed_hook) (int regno);
extern void (*memory_changed_hook) (CORE_ADDR addr, int len);
extern void (*context_hook) (int);
extern ptid_t (*target_wait_hook) (ptid_t ptid,
                                         struct target_waitstatus * status);

extern void (*attach_hook) (void);
extern void (*detach_hook) (void);
extern void (*call_command_hook) (struct cmd_list_element * c,
				  char *cmd, int from_tty);

extern void (*set_hook) (struct cmd_list_element * c);

extern NORETURN void (*error_hook) (void) ATTR_NORETURN;

extern void (*error_begin_hook) (void);

extern int (*ui_load_progress_hook) (const char *section, unsigned long num);


/* Inhibit window interface if non-zero. */

extern int use_windows;

/* Symbolic definitions of filename-related things.  */
/* FIXME, this doesn't work very well if host and executable
   filesystems conventions are different.  */

#ifndef DIRNAME_SEPARATOR
#define DIRNAME_SEPARATOR ':'
#endif

#ifndef SLASH_STRING
#define SLASH_STRING "/"
#endif

#ifdef __MSDOS__
# define CANT_FORK
# define GLOBAL_CURDIR
#endif

/* Provide default definitions of PIDGET, TIDGET, and MERGEPID.
   The name ``TIDGET'' is a historical accident.  Many uses of TIDGET
   in the code actually refer to a lightweight process id, i.e,
   something that can be considered a process id in its own right for
   certain purposes.  */

#ifndef PIDGET
#define PIDGET(PTID) (ptid_get_pid (PTID))
#define TIDGET(PTID) (ptid_get_lwp (PTID))
#define MERGEPID(PID, TID) ptid_build (PID, TID, 0)
#endif

/* Define well known filenos if the system does not define them.  */
#ifndef STDIN_FILENO
#define STDIN_FILENO   0
#endif
#ifndef STDOUT_FILENO
#define STDOUT_FILENO  1
#endif
#ifndef STDERR_FILENO
#define STDERR_FILENO  2
#endif

/* If this definition isn't overridden by the header files, assume
   that isatty and fileno exist on this system.  */
#ifndef ISATTY
#define ISATTY(FP)	(isatty (fileno (FP)))
#endif

/* Ensure that V is aligned to an N byte boundary (B's assumed to be a
   power of 2).  Round up/down when necessary.  Examples of correct
   use include:

   addr = align_up (addr, 8); -- VALUE needs 8 byte alignment
   write_memory (addr, value, len);
   addr += len;

   and:

   sp = align_down (sp - len, 16); -- Keep SP 16 byte aligned
   write_memory (sp, value, len);

   Note that uses such as:

   write_memory (addr, value, len);
   addr += align_up (len, 8);

   and:

   sp -= align_up (len, 8);
   write_memory (sp, value, len);

   are typically not correct as they don't ensure that the address (SP
   or ADDR) is correctly aligned (relying on previous alignment to
   keep things right).  This is also why the methods are called
   "align_..." instead of "round_..." as the latter reads better with
   this incorrect coding style.  */

extern ULONGEST align_up (ULONGEST v, int n);
extern ULONGEST align_down (ULONGEST v, int n);

#endif /* #ifndef DEFS_H */
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d69 23
d201 1
a201 1
  if (deprecated_interactive_hook) deprecated_interactive_hook (); \
d223 1
a223 3
    language_ada,		/* Ada */
    language_minimal,		/* All other languages, minimal support only */
    nr_languages
d253 1
a253 13
  RETURN_VALUE_STRUCT_CONVENTION,
  /* Like the "struct return convention" above, but where the ABI
     guarantees that the called function stores the address at which
     the value being returned is stored in a well-defined location,
     such as a register or memory slot in the stack frame.  Don't use
     this if the ABI doesn't explicitly guarantees this.  */
  RETURN_VALUE_ABI_RETURNS_ADDRESS,
  /* Like the "struct return convention" above, but where the ABI
     guarantees that the address at which the value being returned is
     stored will be available in a well-defined location, such as a
     register or memory slot in the stack frame.  Don't use this if
     the ABI doesn't explicitly guarantees this.  */
  RETURN_VALUE_ABI_PRESERVES_ADDRESS,
d330 4
d350 2
a378 4
struct section_addr_info;
extern struct cleanup *(make_cleanup_free_section_addr_info 
                        (struct section_addr_info *));

a529 1
extern char *int_string (LONGEST, int, int, int, int);
a537 5
/* Return a string that contains a number formatted as a hex
   string.  */
extern char *hex_string (LONGEST);
extern char *hex_string_custom (LONGEST, int);

a602 3
#define OPF_TRY_CWD_FIRST     0x01
#define OPF_SEARCH_IN_PATH    0x02

d619 2
d811 3
a813 8
/* Assume that fopen accepts the letter "b" in the mode string.
   Support for is demanded by ISO C90, and should be supported on all
   platforms that claim to have a standards conforming C library.  On
   true POSIX systems it will be ignored and have no effect.  There
   may still be systems without a standards conforming C library where
   an ISO C90 compiler (GCC) is available.  Known examples are SunOS
   4.x and 4.3BSD.  This assumption means these systems are no longer
   supported.  */
d815 1
a815 1
# include "fopen-bin.h"
d860 11
d887 1
a887 2
/* Like asprintf and vasprintf, but return the string, throw an error
   if no memory.  */
a888 1
extern char *xstrvprintf (const char *format, va_list ap);
d1070 4
d1091 9
d1125 9
d1200 3
a1202 4
   deprecated_command_loop_hook and deprecated_init_ui_hook with the
   per-interpreter implementation.  */
/* FIXME: deprecated_command_loop_hook and deprecated_init_ui_hook
   should be moved here. */
d1207 14
a1220 14
extern void (*deprecated_pre_add_symbol_hook) (const char *);
extern void (*deprecated_post_add_symbol_hook) (void);
extern void (*selected_frame_level_changed_hook) (int);
extern int (*deprecated_ui_loop_hook) (int signo);
extern void (*deprecated_init_ui_hook) (char *argv0);
extern void (*deprecated_command_loop_hook) (void);
extern void (*deprecated_show_load_progress) (const char *section,
					      unsigned long section_sent, 
					      unsigned long section_size, 
					      unsigned long total_sent, 
					      unsigned long total_size);
extern void (*deprecated_print_frame_info_listing_hook) (struct symtab * s,
							 int line, int stopline,
							 int noerror);
d1222 15
a1236 15
extern int (*deprecated_query_hook) (const char *, va_list);
extern void (*deprecated_warning_hook) (const char *, va_list);
extern void (*deprecated_flush_hook) (struct ui_file * stream);
extern void (*deprecated_create_breakpoint_hook) (struct breakpoint * b);
extern void (*deprecated_delete_breakpoint_hook) (struct breakpoint * bpt);
extern void (*deprecated_modify_breakpoint_hook) (struct breakpoint * bpt);
extern void (*deprecated_interactive_hook) (void);
extern void (*deprecated_registers_changed_hook) (void);
extern void (*deprecated_readline_begin_hook) (char *,...);
extern char *(*deprecated_readline_hook) (char *);
extern void (*deprecated_readline_end_hook) (void);
extern void (*deprecated_register_changed_hook) (int regno);
extern void (*deprecated_memory_changed_hook) (CORE_ADDR addr, int len);
extern void (*deprecated_context_hook) (int);
extern ptid_t (*deprecated_target_wait_hook) (ptid_t ptid,
d1239 4
a1242 4
extern void (*deprecated_attach_hook) (void);
extern void (*deprecated_detach_hook) (void);
extern void (*deprecated_call_command_hook) (struct cmd_list_element * c,
					     char *cmd, int from_tty);
d1244 1
a1244 1
extern void (*deprecated_set_hook) (struct cmd_list_element * c);
d1246 1
a1246 1
extern void (*deprecated_error_hook) (void);
d1248 1
a1248 1
extern void (*deprecated_error_begin_hook) (void);
d1250 1
a1250 2
extern int (*deprecated_ui_load_progress_hook) (const char *section,
						unsigned long num);
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 1050
/* Basic, host-specific, and target-specific definitions for GDB.
   Copyright (C) 1986, 1989, 1991, 1992, 1993, 1994, 1995, 1996
   Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#ifndef DEFS_H
#define DEFS_H

#include "config.h"		/* Generated by configure */
#include <stdio.h>
#include <errno.h>		/* System call error return status */

/* Just in case they're not defined in stdio.h. */

#ifndef SEEK_SET
#define SEEK_SET 0
#endif
#ifndef SEEK_CUR
#define SEEK_CUR 1
#endif

/* First include ansidecl.h so we can use the various macro definitions
   here and in all subsequent file inclusions.  */

#include "ansidecl.h"

#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif

#include "libiberty.h"

/* libiberty.h can't declare this one, but evidently we can.  */
extern char *strsignal PARAMS ((int));

#include "progress.h"

#ifndef NO_MMALLOC
#include "mmalloc.h"
#endif

/* For BFD64 and bfd_vma.  */
#include "bfd.h"

/* An address in the program being debugged.  Host byte order.  Rather
   than duplicate all the logic in BFD which figures out what type
   this is (long, long long, etc.) and whether it needs to be 64
   bits (the host/target interactions are subtle), we just use
   bfd_vma.  */

typedef bfd_vma CORE_ADDR;

#ifndef min
#define min(a, b) ((a) < (b) ? (a) : (b))
#endif
#ifndef max
#define max(a, b) ((a) > (b) ? (a) : (b))
#endif

/* Gdb does *lots* of string compares.  Use macros to speed them up by
   avoiding function calls if the first characters are not the same. */

#define STRCMP(a,b) (*(a) == *(b) ? strcmp ((a), (b)) : (int)*(a) - (int)*(b))
#define STREQ(a,b) (*(a) == *(b) ? !strcmp ((a), (b)) : 0)
#define STREQN(a,b,c) (*(a) == *(b) ? !strncmp ((a), (b), (c)) : 0)

/* The character GNU C++ uses to build identifiers that must be unique from
   the program's identifiers (such as $this and $$vptr).  */
#define CPLUS_MARKER '$'	/* May be overridden to '.' for SysV */

/* Check if a character is one of the commonly used C++ marker characters.  */
extern int is_cplus_marker PARAMS ((int));

extern int quit_flag;
extern int immediate_quit;
extern int sevenbit_strings;

extern void quit PARAMS ((void));

#ifdef QUIT
/* do twice to force compiler warning */
#define FIXME "FIXME"
#define FIXME "ignoring redefinition of QUIT"
#else
#define QUIT { \
  if (quit_flag) quit (); \
  if (interactive_hook) interactive_hook (); \
  PROGRESS (1); \
}
#endif

/* Command classes are top-level categories into which commands are broken
   down for "help" purposes.  
   Notes on classes: class_alias is for alias commands which are not
   abbreviations of the original command.  class-pseudo is for commands
   which are not really commands nor help topics ("stop").  */

enum command_class
{
  /* Special args to help_list */
  all_classes = -2, all_commands = -1,
  /* Classes of commands */
  no_class = -1, class_run = 0, class_vars, class_stack,
  class_files, class_support, class_info, class_breakpoint,
  class_alias, class_obscure, class_user, class_maintenance,
  class_pseudo
};

/* Languages represented in the symbol table and elsewhere.
   This should probably be in language.h, but since enum's can't
   be forward declared to satisfy opaque references before their
   actual definition, needs to be here. */

enum language 
{
   language_unknown, 		/* Language not known */
   language_auto,		/* Placeholder for automatic setting */
   language_c, 			/* C */
   language_cplus, 		/* C++ */
   language_chill,		/* Chill */
   language_fortran,		/* Fortran */
   language_m2,			/* Modula-2 */
   language_asm,		/* Assembly language */
   language_scm			/* Scheme / Guile */
};

/* the cleanup list records things that have to be undone
   if an error happens (descriptors to be closed, memory to be freed, etc.)
   Each link in the chain records a function to call and an
   argument to give it.

   Use make_cleanup to add an element to the cleanup chain.
   Use do_cleanups to do all cleanup actions back to a given
   point in the chain.  Use discard_cleanups to remove cleanups
   from the chain back to a given point, not doing them.  */

struct cleanup
{
  struct cleanup *next;
  void (*function) PARAMS ((PTR));
  PTR arg;
};


/* The ability to declare that a function never returns is useful, but
   not really required to compile GDB successfully, so the NORETURN and
   ATTR_NORETURN macros normally expand into nothing.  */

/* If compiling with older versions of GCC, a function may be declared
   "volatile" to indicate that it does not return.  */

#ifndef NORETURN
# if defined(__GNUC__) \
     && (__GNUC__ == 1 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7))
#  define NORETURN volatile
# else
#  define NORETURN /* nothing */
# endif
#endif

/* GCC 2.5 and later versions define a function attribute "noreturn",
   which is the preferred way to declare that a function never returns.
   However GCC 2.7 appears to be the first version in which this fully
   works everywhere we use it. */

#ifndef ATTR_NORETURN
# if defined(__GNUC__) && __GNUC__ >= 2 && __GNUC_MINOR__ >= 7
#  define ATTR_NORETURN __attribute__ ((noreturn))
# else
#  define ATTR_NORETURN /* nothing */
# endif
#endif

#ifndef ATTR_FORMAT
# if defined(__GNUC__) && __GNUC__ >= 2 && __GNUC_MINOR__ >= 4 && defined (__ANSI_PROTOTYPES)
#  define ATTR_FORMAT(type, x, y) __attribute__ ((format(type, x, y)))
# else
#  define ATTR_FORMAT(type, x, y) /* nothing */
# endif
#endif

/* Needed for various prototypes */

#ifdef __STDC__
struct symtab;
struct breakpoint;
#endif

/* From blockframe.c */

extern int inside_entry_func PARAMS ((CORE_ADDR));

extern int inside_entry_file PARAMS ((CORE_ADDR addr));

extern int inside_main_func PARAMS ((CORE_ADDR pc));

/* From ch-lang.c, for the moment. (FIXME) */

extern char *chill_demangle PARAMS ((const char *));

/* From utils.c */

extern void notice_quit PARAMS ((void));

extern int strcmp_iw PARAMS ((const char *, const char *));

extern char *safe_strerror PARAMS ((int));

extern char *safe_strsignal PARAMS ((int));

extern void init_malloc PARAMS ((void *));

extern void request_quit PARAMS ((int));

extern void do_cleanups PARAMS ((struct cleanup *));

extern void discard_cleanups PARAMS ((struct cleanup *));

/* The bare make_cleanup function is one of those rare beasts that
   takes almost any type of function as the first arg and anything that
   will fit in a "void *" as the second arg.

   Should be, once all calls and called-functions are cleaned up:
extern struct cleanup *
make_cleanup PARAMS ((void (*function) (void *), void *));

   Until then, lint and/or various type-checking compiler options will
   complain about make_cleanup calls.  It'd be wrong to just cast things,
   since the type actually passed when the function is called would be
   wrong.  */

extern struct cleanup *make_cleanup ();

extern struct cleanup *save_cleanups PARAMS ((void));

extern void restore_cleanups PARAMS ((struct cleanup *));

extern void free_current_contents PARAMS ((char **));

extern void null_cleanup PARAMS ((PTR));

extern int myread PARAMS ((int, char *, int));

extern int query PARAMS((char *, ...))
     ATTR_FORMAT(printf, 1, 2);

/* From demangle.c */

extern void set_demangling_style PARAMS ((char *));


/* Annotation stuff.  */

extern int annotation_level; /* in stack.c */

extern void begin_line PARAMS ((void));

extern void wrap_here PARAMS ((char *));

extern void reinitialize_more_filter PARAMS ((void));

typedef FILE GDB_FILE;
#define gdb_stdout stdout
#define gdb_stderr stderr

extern void gdb_flush PARAMS ((GDB_FILE *));

extern GDB_FILE *gdb_fopen PARAMS ((char * name, char * mode));

extern void fputs_filtered PARAMS ((const char *, GDB_FILE *));

extern void fputs_unfiltered PARAMS ((const char *, GDB_FILE *));

extern int fputc_unfiltered PARAMS ((int c, GDB_FILE *));

extern int putchar_unfiltered PARAMS ((int c));

extern void puts_filtered PARAMS ((const char *));

extern void puts_unfiltered PARAMS ((const char *));

extern void vprintf_filtered PARAMS ((const char *, va_list))
     ATTR_FORMAT(printf, 1, 0);

extern void vfprintf_filtered PARAMS ((FILE *, const char *, va_list))
     ATTR_FORMAT(printf, 2, 0);

extern void fprintf_filtered PARAMS ((FILE *, const char *, ...))
     ATTR_FORMAT(printf, 2, 3);

extern void fprintfi_filtered PARAMS ((int, FILE *, const char *, ...))
     ATTR_FORMAT(printf, 3, 4);

extern void printf_filtered PARAMS ((const char *, ...))
     ATTR_FORMAT(printf, 1, 2);

extern void printfi_filtered PARAMS ((int, const char *, ...))
     ATTR_FORMAT(printf, 2, 3);

extern void vprintf_unfiltered PARAMS ((const char *, va_list))
     ATTR_FORMAT(printf, 1, 0);

extern void vfprintf_unfiltered PARAMS ((FILE *, const char *, va_list))
     ATTR_FORMAT(printf, 2, 0);

extern void fprintf_unfiltered PARAMS ((FILE *, const char *, ...))
     ATTR_FORMAT(printf, 2, 3);

extern void printf_unfiltered PARAMS ((const char *, ...))
     ATTR_FORMAT(printf, 1, 2);

extern void print_spaces PARAMS ((int, GDB_FILE *));

extern void print_spaces_filtered PARAMS ((int, GDB_FILE *));

extern char *n_spaces PARAMS ((int));

extern void gdb_printchar PARAMS ((int, GDB_FILE *, int));

extern void gdb_print_address PARAMS ((void *, GDB_FILE *));

typedef bfd_vma t_addr;
typedef bfd_vma t_reg;
extern char* paddr PARAMS ((t_addr addr));

extern char* preg PARAMS ((t_reg reg));

extern void fprintf_symbol_filtered PARAMS ((GDB_FILE *, char *,
					     enum language, int));

extern void perror_with_name PARAMS ((char *));

extern void print_sys_errmsg PARAMS ((char *, int));

/* From regex.c or libc.  BSD 4.4 declares this with the argument type as
   "const char *" in unistd.h, so we can't declare the argument
   as "char *".  */

extern char *re_comp PARAMS ((const char *));

/* From symfile.c */

extern void symbol_file_command PARAMS ((char *, int));

/* From top.c */

extern char *skip_quoted PARAMS ((char *));

extern char *gdb_readline PARAMS ((char *));

extern char *command_line_input PARAMS ((char *, int, char *));

extern void print_prompt PARAMS ((void));

extern int input_from_terminal_p PARAMS ((void));

extern int info_verbose;

/* From printcmd.c */

extern void set_next_address PARAMS ((CORE_ADDR));

extern void print_address_symbolic PARAMS ((CORE_ADDR, GDB_FILE *, int,
					    char *));

extern void print_address_numeric PARAMS ((CORE_ADDR, int, GDB_FILE *));

extern void print_address PARAMS ((CORE_ADDR, GDB_FILE *));

/* From source.c */

extern int openp PARAMS ((char *, int, char *, int, int, char **));

extern void mod_path PARAMS ((char *, char **));

extern void directory_command PARAMS ((char *, int));

extern void init_source_path PARAMS ((void));

extern char *symtab_to_filename PARAMS ((struct symtab *));

/* From findvar.c */

extern int read_relative_register_raw_bytes PARAMS ((int, char *));

/* From readline (but not in any readline .h files).  */

extern char *tilde_expand PARAMS ((char *));

/* Control types for commands */

enum misc_command_type
{
  ok_command,
  end_command,
  else_command,
  nop_command
};

enum command_control_type
{
  simple_control,
  break_control,
  continue_control,
  while_control,
  if_control,
  invalid_control
};

/* Structure for saved commands lines
   (for breakpoints, defined commands, etc).  */

struct command_line
{
  struct command_line *next;
  char *line;
  enum command_control_type control_type;
  int body_count;
  struct command_line **body_list;
};

extern struct command_line *read_command_lines PARAMS ((char *, int));

extern void free_command_lines PARAMS ((struct command_line **));

/* String containing the current directory (what getwd would return).  */

extern char *current_directory;

/* Default radixes for input and output.  Only some values supported.  */
extern unsigned input_radix;
extern unsigned output_radix;

/* Possibilities for prettyprint parameters to routines which print
   things.  Like enum language, this should be in value.h, but needs
   to be here for the same reason.  FIXME:  If we can eliminate this
   as an arg to LA_VAL_PRINT, then we can probably move it back to
   value.h. */

enum val_prettyprint
{
  Val_no_prettyprint = 0,
  Val_prettyprint,
  /* Use the default setting which the user has specified.  */
  Val_pretty_default
};


/* Host machine definition.  This will be a symlink to one of the
   xm-*.h files, built by the `configure' script.  */

#include "xm.h"

/* Native machine support.  This will be a symlink to one of the
   nm-*.h files, built by the `configure' script.  */

#include "nm.h"

/* Target machine definition.  This will be a symlink to one of the
   tm-*.h files, built by the `configure' script.  */

#include "tm.h"

/* If the xm.h file did not define the mode string used to open the
   files, assume that binary files are opened the same way as text
   files */
#ifndef FOPEN_RB
#include "fopen-same.h"
#endif

/* Microsoft C can't deal with const pointers */

#ifdef _MSC_VER
#define CONST_PTR
#else
#define CONST_PTR const
#endif

/*
 * Allow things in gdb to be declared "volatile".  If compiling ANSI, it
 * just works.  If compiling with gcc but non-ansi, redefine to __volatile__.
 * If non-ansi, non-gcc, then eliminate "volatile" entirely, making those
 * objects be read-write rather than read-only.
 */

#ifndef volatile
#ifndef __STDC__
# ifdef __GNUC__
#  define volatile __volatile__
# else
#  define volatile /*nothing*/
# endif /* GNUC */
#endif /* STDC */
#endif /* volatile */

/* Defaults for system-wide constants (if not defined by xm.h, we fake it).
   FIXME: Assumes 2's complement arithmetic */

#if !defined (UINT_MAX)
#define	UINT_MAX ((unsigned int)(~0))		/* 0xFFFFFFFF for 32-bits */
#endif

#if !defined (INT_MAX)
#define	INT_MAX ((int)(UINT_MAX >> 1))		/* 0x7FFFFFFF for 32-bits */
#endif

#if !defined (INT_MIN)
#define INT_MIN ((int)((int) ~0 ^ INT_MAX))	/* 0x80000000 for 32-bits */
#endif

#if !defined (ULONG_MAX)
#define	ULONG_MAX ((unsigned long)(~0L))	/* 0xFFFFFFFF for 32-bits */
#endif

#if !defined (LONG_MAX)
#define	LONG_MAX ((long)(ULONG_MAX >> 1))	/* 0x7FFFFFFF for 32-bits */
#endif

#ifdef BFD64

/* This is to make sure that LONGEST is at least as big as CORE_ADDR.  */

#define LONGEST BFD_HOST_64_BIT

#else /* No BFD64 */

/* LONGEST should not be a typedef, because "unsigned LONGEST" needs to work.
   CC_HAS_LONG_LONG is defined if the host compiler supports "long long" */

#ifndef LONGEST
#  ifdef CC_HAS_LONG_LONG
#    define LONGEST long long
#  else
#    define LONGEST long
#  endif
#endif

#endif /* No BFD64 */

/* Convert a LONGEST to an int.  This is used in contexts (e.g. number of
   arguments to a function, number in a value history, register number, etc.)
   where the value must not be larger than can fit in an int.  */

extern int longest_to_int PARAMS ((LONGEST));

/* Assorted functions we can declare, now that const and volatile are 
   defined.  */

extern char *savestring PARAMS ((const char *, int));

extern char *msavestring PARAMS ((void *, const char *, int));

extern char *strsave PARAMS ((const char *));

extern char *mstrsave PARAMS ((void *, const char *));

#ifdef _MSC_VER /* FIXME; was long, but this causes compile errors in msvc if already defined */
extern PTR xmmalloc PARAMS ((PTR, size_t));

extern PTR xmrealloc PARAMS ((PTR, PTR, size_t));
#else
extern PTR xmmalloc PARAMS ((PTR, long));

extern PTR xmrealloc PARAMS ((PTR, PTR, long));
#endif

extern int parse_escape PARAMS ((char **));

extern char *reg_names[];

/* Message to be printed before the error message, when an error occurs.  */

extern char *error_pre_print;

/* Message to be printed before the error message, when an error occurs.  */

extern char *quit_pre_print;

/* Message to be printed before the warning message, when a warning occurs.  */

extern char *warning_pre_print;

extern NORETURN void error PARAMS((char *, ...)) ATTR_NORETURN;

extern void error_begin PARAMS ((void));

extern NORETURN void fatal PARAMS((char *, ...)) ATTR_NORETURN;

extern NORETURN void nomem PARAMS ((long)) ATTR_NORETURN;

/* Reasons for calling return_to_top_level.  */
enum return_reason {
  /* User interrupt.  */
  RETURN_QUIT,

  /* Any other error.  */
  RETURN_ERROR
};

#define RETURN_MASK_QUIT (1 << (int)RETURN_QUIT)
#define RETURN_MASK_ERROR (1 << (int)RETURN_ERROR)
#define RETURN_MASK_ALL (RETURN_MASK_QUIT | RETURN_MASK_ERROR)
typedef int return_mask;

extern NORETURN void
return_to_top_level PARAMS ((enum return_reason)) ATTR_NORETURN;

extern int
catch_errors PARAMS ((int (*) (char *), void *, char *, return_mask));

extern void warning_begin PARAMS ((void));

extern void warning PARAMS ((char *, ...))
     ATTR_FORMAT(printf, 1, 2);

/* Global functions from other, non-gdb GNU thingies.
   Libiberty thingies are no longer declared here.  We include libiberty.h
   above, instead.  */

#ifndef GETENV_PROVIDED
extern char *getenv PARAMS ((const char *));
#endif

/* From other system libraries */

#ifdef HAVE_STDDEF_H
#include <stddef.h>
#endif

#ifdef HAVE_STDLIB_H
#if defined(_MSC_VER) && !defined(__cplusplus)
/* msvc defines these in stdlib.h for c code */
#undef min
#undef max
#endif
#include <stdlib.h>
#endif
#ifndef min
#define min(a, b) ((a) < (b) ? (a) : (b))
#endif
#ifndef max
#define max(a, b) ((a) > (b) ? (a) : (b))
#endif


/* We take the address of fclose later, but some stdio's forget
   to declare this.  We can't always declare it since there's
   no way to declare the parameters without upsetting some compiler
   somewhere. */

#ifndef FCLOSE_PROVIDED
extern int fclose PARAMS ((FILE *));
#endif

#ifndef atof
extern double atof PARAMS ((const char *));	/* X3.159-1989  4.10.1.1 */
#endif

#ifndef MALLOC_INCOMPATIBLE

#ifdef NEED_DECLARATION_MALLOC
extern PTR malloc ();
#endif

#ifdef NEED_DECLARATION_REALLOC
extern PTR realloc ();
#endif

#ifdef NEED_DECLARATION_FREE
extern void free ();
#endif

#endif /* MALLOC_INCOMPATIBLE */

/* Various possibilities for alloca.  */
#ifndef alloca
# ifdef __GNUC__
#  define alloca __builtin_alloca
# else /* Not GNU C */
#  ifdef sparc
#   include <alloca.h>		/* NOTE:  Doesn't declare alloca() */
#  endif

/* We need to be careful not to declare this in a way which conflicts with
   bison.  Bison never declares it as char *, but under various circumstances
   (like __hpux) we need to use void *.  */
#  if defined (__STDC__) || defined (__hpux)
   extern void *alloca ();
#  else /* Don't use void *.  */
   extern char *alloca ();
#  endif /* Don't use void *.  */
# endif /* Not GNU C */
#endif /* alloca not defined */

/* HOST_BYTE_ORDER must be defined to one of these.  */

#ifdef HAVE_ENDIAN_H
#include <endian.h>
#endif

#if !defined (BIG_ENDIAN)
#define BIG_ENDIAN 4321
#endif

#if !defined (LITTLE_ENDIAN)
#define LITTLE_ENDIAN 1234
#endif

/* Target-system-dependent parameters for GDB. */

#ifdef TARGET_BYTE_ORDER_SELECTABLE
/* The target endianness is selectable at runtime.  Define
   TARGET_BYTE_ORDER to be a variable.  The user can use the `set
   endian' command to change it.  */
#undef TARGET_BYTE_ORDER
#define TARGET_BYTE_ORDER target_byte_order
extern int target_byte_order;
#endif

extern void set_endian_from_file PARAMS ((bfd *));

/* Number of bits in a char or unsigned char for the target machine.
   Just like CHAR_BIT in <limits.h> but describes the target machine.  */
#if !defined (TARGET_CHAR_BIT)
#define TARGET_CHAR_BIT 8
#endif

/* Number of bits in a short or unsigned short for the target machine. */
#if !defined (TARGET_SHORT_BIT)
#define TARGET_SHORT_BIT (2 * TARGET_CHAR_BIT)
#endif

/* Number of bits in an int or unsigned int for the target machine. */
#if !defined (TARGET_INT_BIT)
#define TARGET_INT_BIT (4 * TARGET_CHAR_BIT)
#endif

/* Number of bits in a long or unsigned long for the target machine. */
#if !defined (TARGET_LONG_BIT)
#define TARGET_LONG_BIT (4 * TARGET_CHAR_BIT)
#endif

/* Number of bits in a long long or unsigned long long for the target machine. */
#if !defined (TARGET_LONG_LONG_BIT)
#define TARGET_LONG_LONG_BIT (2 * TARGET_LONG_BIT)
#endif

/* Number of bits in a float for the target machine. */
#if !defined (TARGET_FLOAT_BIT)
#define TARGET_FLOAT_BIT (4 * TARGET_CHAR_BIT)
#endif

/* Number of bits in a double for the target machine. */
#if !defined (TARGET_DOUBLE_BIT)
#define TARGET_DOUBLE_BIT (8 * TARGET_CHAR_BIT)
#endif

/* Number of bits in a long double for the target machine.  */
#if !defined (TARGET_LONG_DOUBLE_BIT)
#define TARGET_LONG_DOUBLE_BIT (2 * TARGET_DOUBLE_BIT)
#endif

/* Number of bits in a pointer for the target machine */
#if !defined (TARGET_PTR_BIT)
#define TARGET_PTR_BIT TARGET_INT_BIT
#endif

/* If we picked up a copy of CHAR_BIT from a configuration file
   (which may get it by including <limits.h>) then use it to set
   the number of bits in a host char.  If not, use the same size
   as the target. */

#if defined (CHAR_BIT)
#define HOST_CHAR_BIT CHAR_BIT
#else
#define HOST_CHAR_BIT TARGET_CHAR_BIT
#endif

/* The bit byte-order has to do just with numbering of bits in
   debugging symbols and such.  Conceptually, it's quite separate
   from byte/word byte order.  */

#if !defined (BITS_BIG_ENDIAN)
#ifndef TARGET_BYTE_ORDER_SELECTABLE

#if TARGET_BYTE_ORDER == BIG_ENDIAN
#define BITS_BIG_ENDIAN 1
#endif /* Big endian.  */

#if TARGET_BYTE_ORDER == LITTLE_ENDIAN
#define BITS_BIG_ENDIAN 0
#endif /* Little endian.  */

#else /* defined (TARGET_BYTE_ORDER_SELECTABLE) */

#define BITS_BIG_ENDIAN (TARGET_BYTE_ORDER == BIG_ENDIAN)

#endif /* defined (TARGET_BYTE_ORDER_SELECTABLE) */
#endif /* BITS_BIG_ENDIAN not defined.  */

/* In findvar.c.  */

extern LONGEST extract_signed_integer PARAMS ((void *, int));

extern unsigned LONGEST extract_unsigned_integer PARAMS ((void *, int));

extern int extract_long_unsigned_integer PARAMS ((void *, int, LONGEST *));

extern CORE_ADDR extract_address PARAMS ((void *, int));

extern void store_signed_integer PARAMS ((void *, int, LONGEST));

extern void store_unsigned_integer PARAMS ((void *, int, unsigned LONGEST));

extern void store_address PARAMS ((void *, int, CORE_ADDR));

/* Setup definitions for host and target floating point formats.  We need to
   consider the format for `float', `double', and `long double' for both target
   and host.  We need to do this so that we know what kind of conversions need
   to be done when converting target numbers to and from the hosts DOUBLEST
   data type.  */

/* This is used to indicate that we don't know the format of the floating point
   number.  Typically, this is useful for native ports, where the actual format
   is irrelevant, since no conversions will be taking place.  */

extern const struct floatformat floatformat_unknown;

#if HOST_BYTE_ORDER == BIG_ENDIAN
#  ifndef HOST_FLOAT_FORMAT
#    define HOST_FLOAT_FORMAT &floatformat_ieee_single_big
#  endif
#  ifndef HOST_DOUBLE_FORMAT
#    define HOST_DOUBLE_FORMAT &floatformat_ieee_double_big
#  endif
#else				/* LITTLE_ENDIAN */
#  ifndef HOST_FLOAT_FORMAT
#    define HOST_FLOAT_FORMAT &floatformat_ieee_single_little
#  endif
#  ifndef HOST_DOUBLE_FORMAT
#    define HOST_DOUBLE_FORMAT &floatformat_ieee_double_little
#  endif
#endif

#ifndef HOST_LONG_DOUBLE_FORMAT
#define HOST_LONG_DOUBLE_FORMAT &floatformat_unknown
#endif

#ifndef TARGET_BYTE_ORDER_SELECTABLE
#  if TARGET_BYTE_ORDER == BIG_ENDIAN
#    ifndef TARGET_FLOAT_FORMAT
#      define TARGET_FLOAT_FORMAT &floatformat_ieee_single_big
#    endif
#    ifndef TARGET_DOUBLE_FORMAT
#      define TARGET_DOUBLE_FORMAT &floatformat_ieee_double_big
#    endif
#  else /* LITTLE_ENDIAN */
#    ifndef TARGET_FLOAT_FORMAT
#      define TARGET_FLOAT_FORMAT &floatformat_ieee_single_little
#    endif
#    ifndef TARGET_DOUBLE_FORMAT
#      define TARGET_DOUBLE_FORMAT &floatformat_ieee_double_little
#    endif
#  endif
#else				/* TARGET_BYTE_ORDER_SELECTABLE */
#  ifndef TARGET_FLOAT_FORMAT
#    define TARGET_FLOAT_FORMAT (target_byte_order == BIG_ENDIAN \
				 ? &floatformat_ieee_single_big \
				 : &floatformat_ieee_single_little)
#  endif
#  ifndef TARGET_DOUBLE_FORMAT
#    define TARGET_DOUBLE_FORMAT (target_byte_order == BIG_ENDIAN \
				  ? &floatformat_ieee_double_big \
				  : &floatformat_ieee_double_little)
#  endif
#endif

#ifndef TARGET_LONG_DOUBLE_FORMAT
#  define TARGET_LONG_DOUBLE_FORMAT &floatformat_unknown
#endif

/* Use `long double' if the host compiler supports it.  (Note that this is not
   necessarily any longer than `double'.  On SunOS/gcc, it's the same as
   double.)  This is necessary because GDB internally converts all floating
   point values to the widest type supported by the host.

   There are problems however, when the target `long double' is longer than the
   host's `long double'.  In general, we'll probably reduce the precision of
   any such values and print a warning.  */

#ifdef HAVE_LONG_DOUBLE
typedef long double DOUBLEST;
#else
typedef double DOUBLEST;
#endif

extern void floatformat_to_doublest PARAMS ((const struct floatformat *,
					     char *, DOUBLEST *));
extern void floatformat_from_doublest PARAMS ((const struct floatformat *,
					       DOUBLEST *, char *));
extern DOUBLEST extract_floating PARAMS ((void *, int));

extern void store_floating PARAMS ((void *, int, DOUBLEST));

/* On some machines there are bits in addresses which are not really
   part of the address, but are used by the kernel, the hardware, etc.
   for special purposes.  ADDR_BITS_REMOVE takes out any such bits
   so we get a "real" address such as one would find in a symbol
   table.  This is used only for addresses of instructions, and even then
   I'm not sure it's used in all contexts.  It exists to deal with there
   being a few stray bits in the PC which would mislead us, not as some sort
   of generic thing to handle alignment or segmentation (it's possible it
   should be in TARGET_READ_PC instead).  */
#if !defined (ADDR_BITS_REMOVE)
#define ADDR_BITS_REMOVE(addr) (addr)
#endif /* No ADDR_BITS_REMOVE.  */

/* From valops.c */

extern CORE_ADDR push_bytes PARAMS ((CORE_ADDR, char *, int));

extern CORE_ADDR push_word PARAMS ((CORE_ADDR, unsigned LONGEST));

/* Some parts of gdb might be considered optional, in the sense that they
   are not essential for being able to build a working, usable debugger
   for a specific environment.  For example, the maintenance commands
   are there for the benefit of gdb maintainers.  As another example,
   some environments really don't need gdb's that are able to read N
   different object file formats.  In order to make it possible (but
   not necessarily recommended) to build "stripped down" versions of
   gdb, the following defines control selective compilation of those
   parts of gdb which can be safely left out when necessary.  Note that
   the default is to include everything. */

#ifndef MAINTENANCE_CMDS
#define MAINTENANCE_CMDS 1
#endif

#ifdef MAINTENANCE_CMDS
extern int watchdog;
#endif

#include "dis-asm.h"		/* Get defs for disassemble_info */

extern int dis_asm_read_memory PARAMS ((bfd_vma memaddr, bfd_byte *myaddr,
					int len, disassemble_info *info));

extern void dis_asm_memory_error PARAMS ((int status, bfd_vma memaddr,
					  disassemble_info *info));

extern void dis_asm_print_address PARAMS ((bfd_vma addr,
					   disassemble_info *info));

extern int (*tm_print_insn) PARAMS ((bfd_vma, disassemble_info*));
extern disassemble_info tm_print_insn_info;

/* Hooks for alternate command interfaces.  */

#ifdef __STDC__
struct target_waitstatus;
struct cmd_list_element;
#endif

extern void (*init_ui_hook) PARAMS ((void));
extern void (*command_loop_hook) PARAMS ((void));
extern void (*fputs_unfiltered_hook) PARAMS ((const char *linebuffer,
					      FILE *stream));
extern void (*print_frame_info_listing_hook) PARAMS ((struct symtab *s,
						      int line, int stopline,
						      int noerror));
extern int (*query_hook) PARAMS ((const char *, va_list));
extern void (*flush_hook) PARAMS ((FILE *stream));
extern void (*create_breakpoint_hook) PARAMS ((struct breakpoint *b));
extern void (*delete_breakpoint_hook) PARAMS ((struct breakpoint *bpt));
extern void (*modify_breakpoint_hook) PARAMS ((struct breakpoint *bpt));
extern void (*target_output_hook) PARAMS ((char *));
extern void (*interactive_hook) PARAMS ((void));
extern void (*registers_changed_hook) PARAMS ((void));
extern void (*readline_begin_hook) PARAMS ((char *, ...));
extern char * (*readline_hook) PARAMS ((char *));
extern void (*readline_end_hook) PARAMS ((void));

extern int (*target_wait_hook) PARAMS ((int pid,
					struct target_waitstatus *status));

extern void (*call_command_hook) PARAMS ((struct cmd_list_element *c,
					  char *cmd, int from_tty));

extern NORETURN void (*error_hook) PARAMS ((void)) ATTR_NORETURN;



/* Inhibit window interface if non-zero. */

extern int use_windows;

/* Symbolic definitions of filename-related things.  */
/* FIXME, this doesn't work very well if host and executable
   filesystems conventions are different.  */

#ifndef DIRNAME_SEPARATOR
#define DIRNAME_SEPARATOR ':'
#endif

#ifndef SLASH_P
#if defined(__GO32__)||defined(_WIN32)
#define SLASH_P(X) ((X)=='\\')
#else
#define SLASH_P(X) ((X)=='/')
#endif
#endif

#ifndef SLASH_CHAR
#if defined(__GO32__)||defined(_WIN32)
#define SLASH_CHAR '\\'
#else
#define SLASH_CHAR '/'
#endif
#endif

#ifndef SLASH_STRING
#if defined(__GO32__)||defined(_WIN32)
#define SLASH_STRING "\\"
#else
#define SLASH_STRING "/"
#endif
#endif

#ifndef ROOTED_P
#define ROOTED_P(X) (SLASH_P((X)[0]))
#endif

#endif /* #ifndef DEFS_H */
@
