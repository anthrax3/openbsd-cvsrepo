head	1.4;
access;
symbols
	OPENBSD_6_1:1.4.0.50
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.48
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.44
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.46
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.38
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.42
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.40
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.36
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.34
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.32
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.30
	OPENBSD_5_0:1.4.0.28
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.26
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.24
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2004.12.27.14.00.37;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.21.20.23.09;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.38.09;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.18.36;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.11.23;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.11.18;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.18.36;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@/* Target-vector operations for controlling Unix child processes, for GDB.

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
   2000, 2002, 2003, 2004 Free Software Foundation, Inc.

   Contributed by Cygnus Support.

   ## Contains temporary hacks..

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "frame.h"		/* required by inferior.h */
#include "inferior.h"
#include "target.h"
#include "gdbcore.h"
#include "command.h"
#include "gdb_stat.h"
#include <signal.h>
#include <sys/types.h>
#include <fcntl.h>
#include "observer.h"
#include "gdb_wait.h"
#include "inflow.h"

extern struct symtab_and_line *child_enable_exception_callback (enum
								exception_event_kind,
								int);

extern struct exception_event_record
  *child_get_current_exception_event (void);

extern void _initialize_inftarg (void);

static void child_prepare_to_store (void);

#ifndef CHILD_WAIT
static ptid_t child_wait (ptid_t, struct target_waitstatus *);
#endif /* CHILD_WAIT */

static void child_open (char *, int);

static void child_files_info (struct target_ops *);

static void child_detach (char *, int);

static void child_attach (char *, int);

#if !defined(CHILD_POST_ATTACH)
extern void child_post_attach (int);
#endif

static void ptrace_me (void);

static void ptrace_him (int);

static void child_create_inferior (char *, char *, char **, int);

static void child_mourn_inferior (void);

static int child_can_run (void);

static void child_stop (void);

#ifndef CHILD_THREAD_ALIVE
int child_thread_alive (ptid_t);
#endif

static void init_child_ops (void);

extern char **environ;

int child_suppress_run = 0;	/* Non-zero if inftarg should pretend not to
				   be a runnable target.  Used by targets
				   that can sit atop inftarg, such as HPUX
				   thread support.  */

#ifndef CHILD_WAIT

/* Wait for child to do something.  Return pid of child, or -1 in case
   of error; store status through argument pointer OURSTATUS.  */

static ptid_t
child_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
{
  int save_errno;
  int status;
  char *execd_pathname = NULL;
  int exit_status;
  int related_pid;
  int syscall_id;
  enum target_waitkind kind;
  int pid;

  do
    {
      set_sigint_trap ();	/* Causes SIGINT to be passed on to the
				   attached process. */
      set_sigio_trap ();

      pid = wait (&status);

      save_errno = errno;

      clear_sigio_trap ();

      clear_sigint_trap ();

      if (pid == -1)
	{
	  if (save_errno == EINTR)
	    continue;

	  fprintf_unfiltered (gdb_stderr, "Child process unexpectedly missing: %s.\n",
			      safe_strerror (save_errno));

	  /* Claim it exited with unknown signal.  */
	  ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
	  ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
	  return pid_to_ptid (-1);
	}

      /* Did it exit?
       */
      if (target_has_exited (pid, status, &exit_status))
	{
	  /* ??rehrauer: For now, ignore this. */
	  continue;
	}

      if (!target_thread_alive (pid_to_ptid (pid)))
	{
	  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;
	  return pid_to_ptid (pid);
	}
      } while (pid != PIDGET (inferior_ptid)); /* Some other child died or stopped */

  store_waitstatus (ourstatus, status);
  return pid_to_ptid (pid);
}
#endif /* CHILD_WAIT */

#ifndef CHILD_THREAD_ALIVE

/* Check to see if the given thread is alive.

   FIXME: Is kill() ever the right way to do this?  I doubt it, but
   for now we're going to try and be compatable with the old thread
   code.  */
int
child_thread_alive (ptid_t ptid)
{
  pid_t pid = PIDGET (ptid);

  return (kill (pid, 0) != -1);
}

#endif

/* Attach to process PID, then initialize for debugging it.  */

static void
child_attach (char *args, int from_tty)
{
  char *exec_file;
  int pid;
  char *dummy;

  if (!args)
    error_no_arg ("process-id to attach");

  dummy = args;
  pid = strtol (args, &dummy, 0);
  /* Some targets don't set errno on errors, grrr! */
  if ((pid == 0) && (args == dummy))
      error ("Illegal process-id: %s\n", args);
  
  if (pid == getpid ())	/* Trying to masturbate? */
    error ("I refuse to debug myself!");
  
  if (from_tty)
    {
      exec_file = (char *) get_exec_file (0);
      
      if (exec_file)
	printf_unfiltered ("Attaching to program: %s, %s\n", exec_file,
			   target_pid_to_str (pid_to_ptid (pid)));
      else
	printf_unfiltered ("Attaching to %s\n",
			   target_pid_to_str (pid_to_ptid (pid)));
      
      gdb_flush (gdb_stdout);
    }

  attach (pid);
  
  inferior_ptid = pid_to_ptid (pid);
  push_target (&deprecated_child_ops);
}

#if !defined(CHILD_POST_ATTACH)
void
child_post_attach (int pid)
{
  /* This version of Unix doesn't require a meaningful "post attach"
     operation by a debugger.  */
}
#endif

/* Take a program previously attached to and detaches it.
   The program resumes execution and will no longer stop
   on signals, etc.  We'd better not have left any breakpoints
   in the program or it'll die when it hits one.  For this
   to work, it may be necessary for the process to have been
   previously attached.  It *might* work if the program was
   started via the normal ptrace (PTRACE_TRACEME).  */

static void
child_detach (char *args, int from_tty)
{
  int siggnal = 0;
  int pid = PIDGET (inferior_ptid);
  
  if (from_tty)
    {
      char *exec_file = get_exec_file (0);
      if (exec_file == 0)
	exec_file = "";
      printf_unfiltered ("Detaching from program: %s, %s\n", exec_file,
			 target_pid_to_str (pid_to_ptid (pid)));
      gdb_flush (gdb_stdout);
    }
  if (args)
    siggnal = atoi (args);
  
  detach (siggnal);
  
  inferior_ptid = null_ptid;
  unpush_target (&deprecated_child_ops);
}

/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On machines
   which store all the registers in one fell swoop, this makes sure
   that registers contains all the registers from the program being
   debugged.  */

static void
child_prepare_to_store (void)
{
#ifdef CHILD_PREPARE_TO_STORE
  CHILD_PREPARE_TO_STORE ();
#endif
}

/* Print status information about what we're accessing.  */

static void
child_files_info (struct target_ops *ignore)
{
  printf_unfiltered ("\tUsing the running image of %s %s.\n",
      attach_flag ? "attached" : "child", target_pid_to_str (inferior_ptid));
}

static void
child_open (char *arg, int from_tty)
{
  error ("Use the \"run\" command to start a Unix child process.");
}

/* Stub function which causes the inferior that runs it, to be ptrace-able
   by its parent process.  */

static void
ptrace_me (void)
{
  /* "Trace me, Dr. Memory!" */
  call_ptrace (0, 0, (PTRACE_TYPE_ARG3) 0, 0);
}

/* Stub function which causes the GDB that runs it, to start ptrace-ing
   the child process.  */

static void
ptrace_him (int pid)
{
  push_target (&deprecated_child_ops);

  /* On some targets, there must be some explicit synchronization
     between the parent and child processes after the debugger
     forks, and before the child execs the debuggee program.  This
     call basically gives permission for the child to exec.
   */

  target_acknowledge_created_inferior (pid);

  /* START_INFERIOR_TRAPS_EXPECTED is defined in inferior.h,
   * and will be 1 or 2 depending on whether we're starting
   * without or with a shell.
   */
  startup_inferior (START_INFERIOR_TRAPS_EXPECTED);

  /* On some targets, there must be some explicit actions taken after
     the inferior has been started up.
   */
  target_post_startup_inferior (pid_to_ptid (pid));
}

/* Start an inferior Unix child process and sets inferior_ptid to its pid.
   EXEC_FILE is the file to run.
   ALLARGS is a string containing the arguments to the program.
   ENV is the environment vector to pass.  Errors reported with error().  */

static void
child_create_inferior (char *exec_file, char *allargs, char **env,
		       int from_tty)
{
#ifdef HPUXHPPA
  fork_inferior (exec_file, allargs, env, ptrace_me, ptrace_him, pre_fork_inferior, NULL);
#else
  fork_inferior (exec_file, allargs, env, ptrace_me, ptrace_him, NULL, NULL);
#endif
  /* We are at the first instruction we care about.  */
  observer_notify_inferior_created (&current_target, from_tty);
  /* Pedal to the metal... */
  proceed ((CORE_ADDR) -1, TARGET_SIGNAL_0, 0);
}

#if !defined(CHILD_POST_STARTUP_INFERIOR)
void
child_post_startup_inferior (ptid_t ptid)
{
  /* This version of Unix doesn't require a meaningful "post startup inferior"
     operation by a debugger.
   */
}
#endif

#if !defined(CHILD_ACKNOWLEDGE_CREATED_INFERIOR)
void
child_acknowledge_created_inferior (int pid)
{
  /* This version of Unix doesn't require a meaningful "acknowledge created inferior"
     operation by a debugger.
   */
}
#endif


#if !defined(CHILD_INSERT_FORK_CATCHPOINT)
int
child_insert_fork_catchpoint (int pid)
{
  /* This version of Unix doesn't support notification of fork events.  */
  return 0;
}
#endif

#if !defined(CHILD_REMOVE_FORK_CATCHPOINT)
int
child_remove_fork_catchpoint (int pid)
{
  /* This version of Unix doesn't support notification of fork events.  */
  return 0;
}
#endif

#if !defined(CHILD_INSERT_VFORK_CATCHPOINT)
int
child_insert_vfork_catchpoint (int pid)
{
  /* This version of Unix doesn't support notification of vfork events.  */
  return 0;
}
#endif

#if !defined(CHILD_REMOVE_VFORK_CATCHPOINT)
int
child_remove_vfork_catchpoint (int pid)
{
  /* This version of Unix doesn't support notification of vfork events.  */
  return 0;
}
#endif

#if !defined(CHILD_FOLLOW_FORK)
int
child_follow_fork (int follow_child)
{
  /* This version of Unix doesn't support following fork or vfork events.  */
  return 0;
}
#endif

#if !defined(CHILD_INSERT_EXEC_CATCHPOINT)
int
child_insert_exec_catchpoint (int pid)
{
  /* This version of Unix doesn't support notification of exec events.  */
  return 0;
}
#endif

#if !defined(CHILD_REMOVE_EXEC_CATCHPOINT)
int
child_remove_exec_catchpoint (int pid)
{
  /* This version of Unix doesn't support notification of exec events.  */
  return 0;
}
#endif

#if !defined(CHILD_REPORTED_EXEC_EVENTS_PER_EXEC_CALL)
int
child_reported_exec_events_per_exec_call (void)
{
  /* This version of Unix doesn't support notification of exec events.
   */
  return 1;
}
#endif

#if !defined(CHILD_HAS_EXITED)
int
child_has_exited (int pid, int wait_status, int *exit_status)
{
  if (WIFEXITED (wait_status))
    {
      *exit_status = WEXITSTATUS (wait_status);
      return 1;
    }

  if (WIFSIGNALED (wait_status))
    {
      *exit_status = 0;		/* ?? Don't know what else to say here. */
      return 1;
    }

  /* ?? Do we really need to consult the event state, too?  Assume the
     wait_state alone suffices.
   */
  return 0;
}
#endif


static void
child_mourn_inferior (void)
{
  unpush_target (&deprecated_child_ops);
  generic_mourn_inferior ();
}

static int
child_can_run (void)
{
  /* This variable is controlled by modules that sit atop inftarg that may layer
     their own process structure atop that provided here.  hpux-thread.c does
     this because of the Hpux user-mode level thread model.  */

  return !child_suppress_run;
}

/* Send a SIGINT to the process group.  This acts just like the user typed a
   ^C on the controlling terminal.

   XXX - This may not be correct for all systems.  Some may want to use
   killpg() instead of kill (-pgrp). */

static void
child_stop (void)
{
  kill (-inferior_process_group, SIGINT);
}

#if !defined(CHILD_ENABLE_EXCEPTION_CALLBACK)
struct symtab_and_line *
child_enable_exception_callback (enum exception_event_kind kind, int enable)
{
  return (struct symtab_and_line *) NULL;
}
#endif

#if !defined(CHILD_GET_CURRENT_EXCEPTION_EVENT)
struct exception_event_record *
child_get_current_exception_event (void)
{
  return (struct exception_event_record *) NULL;
}
#endif


#if !defined(CHILD_PID_TO_EXEC_FILE)
char *
child_pid_to_exec_file (int pid)
{
  /* This version of Unix doesn't support translation of a process ID
     to the filename of the executable file.
   */
  return NULL;
}
#endif

char *
child_core_file_to_sym_file (char *core)
{
  /* The target stratum for a running executable need not support
     this operation.
   */
  return NULL;
}

/* Perform a partial transfer to/from the specified object.  For
   memory transfers, fall back to the old memory xfer functions.  */

static LONGEST
child_xfer_partial (struct target_ops *ops, enum target_object object,
		    const char *annex, void *readbuf,
		    const void *writebuf, ULONGEST offset, LONGEST len)
{
  switch (object)
    {
    case TARGET_OBJECT_MEMORY:
      if (readbuf)
	return child_xfer_memory (offset, readbuf, len, 0/*write*/,
				  NULL, ops);
      if (writebuf)
	return child_xfer_memory (offset, (void *) writebuf, len, 1/*write*/,
				  NULL, ops);
      return -1;

    case TARGET_OBJECT_UNWIND_TABLE:
#ifndef NATIVE_XFER_UNWIND_TABLE
#define NATIVE_XFER_UNWIND_TABLE(OPS,OBJECT,ANNEX,WRITEBUF,READBUF,OFFSET,LEN) (-1)
#endif
      return NATIVE_XFER_UNWIND_TABLE (ops, object, annex, readbuf, writebuf,
				       offset, len);

    case TARGET_OBJECT_AUXV:
#ifndef NATIVE_XFER_AUXV
#define NATIVE_XFER_AUXV(OPS,OBJECT,ANNEX,WRITEBUF,READBUF,OFFSET,LEN) (-1)
#endif
      return NATIVE_XFER_AUXV (ops, object, annex, readbuf, writebuf,
			       offset, len);

    case TARGET_OBJECT_WCOOKIE:
#ifndef NATIVE_XFER_WCOOKIE
#define NATIVE_XFER_WCOOKIE(OPS,OBJECT,ANNEX,WRITEBUF,READBUF,OFFSET,LEN) (-1)
#endif
      return NATIVE_XFER_WCOOKIE (ops, object, annex, readbuf, writebuf,
				  offset, len);

    default:
      return -1;
    }
}

#if !defined(CHILD_PID_TO_STR)
char *
child_pid_to_str (ptid_t ptid)
{
  return normal_pid_to_str (ptid);
}
#endif

static void
init_child_ops (void)
{
  deprecated_child_ops.to_shortname = "child";
  deprecated_child_ops.to_longname = "Unix child process";
  deprecated_child_ops.to_doc = "Unix child process (started by the \"run\" command).";
  deprecated_child_ops.to_open = child_open;
  deprecated_child_ops.to_attach = child_attach;
  deprecated_child_ops.to_post_attach = child_post_attach;
  deprecated_child_ops.to_detach = child_detach;
  deprecated_child_ops.to_resume = child_resume;
  deprecated_child_ops.to_wait = child_wait;
  deprecated_child_ops.to_fetch_registers = fetch_inferior_registers;
  deprecated_child_ops.to_store_registers = store_inferior_registers;
  deprecated_child_ops.to_prepare_to_store = child_prepare_to_store;
  deprecated_child_ops.deprecated_xfer_memory = child_xfer_memory;
  deprecated_child_ops.to_xfer_partial = child_xfer_partial;
  deprecated_child_ops.to_files_info = child_files_info;
  deprecated_child_ops.to_insert_breakpoint = memory_insert_breakpoint;
  deprecated_child_ops.to_remove_breakpoint = memory_remove_breakpoint;
  deprecated_child_ops.to_terminal_init = terminal_init_inferior;
  deprecated_child_ops.to_terminal_inferior = terminal_inferior;
  deprecated_child_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  deprecated_child_ops.to_terminal_save_ours = terminal_save_ours;
  deprecated_child_ops.to_terminal_ours = terminal_ours;
  deprecated_child_ops.to_terminal_info = child_terminal_info;
  deprecated_child_ops.to_kill = kill_inferior;
  deprecated_child_ops.to_create_inferior = child_create_inferior;
  deprecated_child_ops.to_post_startup_inferior = child_post_startup_inferior;
  deprecated_child_ops.to_acknowledge_created_inferior = child_acknowledge_created_inferior;
  deprecated_child_ops.to_insert_fork_catchpoint = child_insert_fork_catchpoint;
  deprecated_child_ops.to_remove_fork_catchpoint = child_remove_fork_catchpoint;
  deprecated_child_ops.to_insert_vfork_catchpoint = child_insert_vfork_catchpoint;
  deprecated_child_ops.to_remove_vfork_catchpoint = child_remove_vfork_catchpoint;
  deprecated_child_ops.to_follow_fork = child_follow_fork;
  deprecated_child_ops.to_insert_exec_catchpoint = child_insert_exec_catchpoint;
  deprecated_child_ops.to_remove_exec_catchpoint = child_remove_exec_catchpoint;
  deprecated_child_ops.to_reported_exec_events_per_exec_call = child_reported_exec_events_per_exec_call;
  deprecated_child_ops.to_has_exited = child_has_exited;
  deprecated_child_ops.to_mourn_inferior = child_mourn_inferior;
  deprecated_child_ops.to_can_run = child_can_run;
  deprecated_child_ops.to_thread_alive = child_thread_alive;
  deprecated_child_ops.to_pid_to_str = child_pid_to_str;
  deprecated_child_ops.to_stop = child_stop;
  deprecated_child_ops.to_enable_exception_callback = child_enable_exception_callback;
  deprecated_child_ops.to_get_current_exception_event = child_get_current_exception_event;
  deprecated_child_ops.to_pid_to_exec_file = child_pid_to_exec_file;
  deprecated_child_ops.to_stratum = process_stratum;
  deprecated_child_ops.to_has_all_memory = 1;
  deprecated_child_ops.to_has_memory = 1;
  deprecated_child_ops.to_has_stack = 1;
  deprecated_child_ops.to_has_registers = 1;
  deprecated_child_ops.to_has_execution = 1;
  deprecated_child_ops.to_magic = OPS_MAGIC;
}

void
_initialize_inftarg (void)
{
#ifdef HAVE_OPTIONAL_PROC_FS
  char procname[32];
  int fd;

  /* If we have an optional /proc filesystem (e.g. under OSF/1),
     don't add ptrace support if we can access the running GDB via /proc.  */
#ifndef PROC_NAME_FMT
#define PROC_NAME_FMT "/proc/%05d"
#endif
  sprintf (procname, PROC_NAME_FMT, getpid ());
  fd = open (procname, O_RDONLY);
  if (fd >= 0)
    {
      close (fd);
      return;
    }
#endif

  init_child_ops ();
  add_target (&deprecated_child_ops);
}
@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@d37 1
a37 1

a55 4
#if !defined(CHILD_POST_WAIT)
void child_post_wait (ptid_t, int);
#endif

d72 1
a72 1
static void child_create_inferior (char *, char *, char **);
a87 2
struct target_ops child_ops;

d116 1
a116 1
      pid = ptrace_wait (inferior_ptid, &status);
a157 11
#if !defined(CHILD_POST_WAIT)
void
child_post_wait (ptid_t ptid, int wait_status)
{
  /* This version of Unix doesn't require a meaningful "post wait"
     operation.
   */
}
#endif


d180 4
d187 4
a190 12
#ifndef ATTACH_DETACH
  error ("Can't attach to a process on this machine.");
#else
  {
    char *exec_file;
    int pid;
    char *dummy;

    dummy = args;
    pid = strtol (args, &dummy, 0);
    /* Some targets don't set errno on errors, grrr! */
    if ((pid == 0) && (args == dummy))
d192 17
d210 4
a213 23
    if (pid == getpid ())	/* Trying to masturbate? */
      error ("I refuse to debug myself!");

    if (from_tty)
      {
	exec_file = (char *) get_exec_file (0);

	if (exec_file)
	  printf_unfiltered ("Attaching to program: %s, %s\n", exec_file,
			     target_pid_to_str (pid_to_ptid (pid)));
	else
	  printf_unfiltered ("Attaching to %s\n",
	                     target_pid_to_str (pid_to_ptid (pid)));

	gdb_flush (gdb_stdout);
      }

    attach (pid);

    inferior_ptid = pid_to_ptid (pid);
    push_target (&child_ops);
  }
#endif /* ATTACH_DETACH */
d236 19
a254 25
#ifdef ATTACH_DETACH
  {
    int siggnal = 0;
    int pid = PIDGET (inferior_ptid);

    if (from_tty)
      {
	char *exec_file = get_exec_file (0);
	if (exec_file == 0)
	  exec_file = "";
	printf_unfiltered ("Detaching from program: %s, %s\n", exec_file,
			   target_pid_to_str (pid_to_ptid (pid)));
	gdb_flush (gdb_stdout);
      }
    if (args)
      siggnal = atoi (args);

    detach (siggnal);

    inferior_ptid = null_ptid;
    unpush_target (&child_ops);
  }
#else
  error ("This version of Unix does not support detaching a process.");
#endif
d293 1
a293 1
  call_ptrace (0, 0, (PTRACE_ARG3_TYPE) 0, 0);
d302 1
a302 1
  push_target (&child_ops);
d330 2
a331 1
child_create_inferior (char *exec_file, char *allargs, char **env)
d339 1
d465 1
a465 1
  unpush_target (&child_ops);
d543 1
a543 1
	return child_xfer_memory (offset, readbuf, len, 1/*write*/,
d584 51
a634 70
  child_ops.to_shortname = "child";
  child_ops.to_longname = "Unix child process";
  child_ops.to_doc = "Unix child process (started by the \"run\" command).";
  child_ops.to_open = child_open;
  child_ops.to_attach = child_attach;
  child_ops.to_post_attach = child_post_attach;
  child_ops.to_detach = child_detach;
  child_ops.to_resume = child_resume;
  child_ops.to_wait = child_wait;
  child_ops.to_post_wait = child_post_wait;
  child_ops.to_fetch_registers = fetch_inferior_registers;
  child_ops.to_store_registers = store_inferior_registers;
  child_ops.to_prepare_to_store = child_prepare_to_store;
  child_ops.to_xfer_memory = child_xfer_memory;
  child_ops.to_xfer_partial = child_xfer_partial;
  child_ops.to_files_info = child_files_info;
  child_ops.to_insert_breakpoint = memory_insert_breakpoint;
  child_ops.to_remove_breakpoint = memory_remove_breakpoint;
  child_ops.to_terminal_init = terminal_init_inferior;
  child_ops.to_terminal_inferior = terminal_inferior;
  child_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  child_ops.to_terminal_save_ours = terminal_save_ours;
  child_ops.to_terminal_ours = terminal_ours;
  child_ops.to_terminal_info = child_terminal_info;
  child_ops.to_kill = kill_inferior;
  child_ops.to_create_inferior = child_create_inferior;
  child_ops.to_post_startup_inferior = child_post_startup_inferior;
  child_ops.to_acknowledge_created_inferior = child_acknowledge_created_inferior;
  child_ops.to_insert_fork_catchpoint = child_insert_fork_catchpoint;
  child_ops.to_remove_fork_catchpoint = child_remove_fork_catchpoint;
  child_ops.to_insert_vfork_catchpoint = child_insert_vfork_catchpoint;
  child_ops.to_remove_vfork_catchpoint = child_remove_vfork_catchpoint;
  child_ops.to_follow_fork = child_follow_fork;
  child_ops.to_insert_exec_catchpoint = child_insert_exec_catchpoint;
  child_ops.to_remove_exec_catchpoint = child_remove_exec_catchpoint;
  child_ops.to_reported_exec_events_per_exec_call = child_reported_exec_events_per_exec_call;
  child_ops.to_has_exited = child_has_exited;
  child_ops.to_mourn_inferior = child_mourn_inferior;
  child_ops.to_can_run = child_can_run;
  child_ops.to_thread_alive = child_thread_alive;
  child_ops.to_pid_to_str = child_pid_to_str;
  child_ops.to_stop = child_stop;
  child_ops.to_enable_exception_callback = child_enable_exception_callback;
  child_ops.to_get_current_exception_event = child_get_current_exception_event;
  child_ops.to_pid_to_exec_file = child_pid_to_exec_file;
  child_ops.to_stratum = process_stratum;
  child_ops.to_has_all_memory = 1;
  child_ops.to_has_memory = 1;
  child_ops.to_has_stack = 1;
  child_ops.to_has_registers = 1;
  child_ops.to_has_execution = 1;
  child_ops.to_magic = OPS_MAGIC;
}

/* Take over the 'find_mapped_memory' vector from inftarg.c. */
extern void
inftarg_set_find_memory_regions (int (*func) (int (*) (CORE_ADDR,
						       unsigned long,
						       int, int, int,
						       void *),
					      void *))
{
  child_ops.to_find_memory_regions = func;
}

/* Take over the 'make_corefile_notes' vector from inftarg.c. */
extern void
inftarg_set_make_corefile_notes (char * (*func) (bfd *, int *))
{
  child_ops.to_make_corefile_notes = func;
d659 1
a659 1
  add_target (&child_ops);
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 4
a5 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996
   Free Software Foundation, Inc.
d8 3
a10 1
This file is part of GDB.
d12 14
a25 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d28 1
a28 1
#include "frame.h"  /* required by inferior.h */
a30 1
#include "wait.h"
d33 1
d38 13
a50 2
static void
child_prepare_to_store PARAMS ((void));
d53 1
a53 1
static int child_wait PARAMS ((int, struct target_waitstatus *));
d56 5
a60 1
static void child_open PARAMS ((char *, int));
d62 1
a62 2
static void
child_files_info PARAMS ((struct target_ops *));
d64 1
a64 2
static void
child_detach PARAMS ((char *, int));
d66 1
a66 2
static void
child_attach PARAMS ((char *, int));
d68 3
a70 2
static void
ptrace_me PARAMS ((void));
d72 1
a72 2
static int
ptrace_him PARAMS ((int));
d74 1
a74 1
static void child_create_inferior PARAMS ((char *, char *, char **));
d76 1
a76 2
static void
child_mourn_inferior PARAMS ((void));
d78 1
a78 2
static int
child_can_run PARAMS ((void));
d80 1
a80 2
static int
proc_wait PARAMS ((int, int*));
d82 1
a82 2
static void
child_stop PARAMS ((void));
d85 1
a85 1
static int child_thread_alive PARAMS ((int));
d88 2
d92 1
a92 2
/* Forward declaration */
extern struct target_ops child_ops;
a97 9
static int
proc_wait (pid, status)
     int pid;
     int *status;
{
#ifndef __GO32__
  return wait (status);
#endif
}
d104 2
a105 4
static int
child_wait (pid, ourstatus)
     int pid;
     struct target_waitstatus *ourstatus;
d109 12
d122 1
a122 4
  do {
    set_sigint_trap();	/* Causes SIGINT to be passed on to the
			   attached process. */
    set_sigio_trap ();
d124 1
a124 2
    pid = proc_wait (inferior_pid, &status);
    save_errno = errno;
d126 1
a126 1
    clear_sigio_trap ();
d128 1
a128 1
    clear_sigint_trap();
d130 19
a148 3
    if (pid == -1)
      {
	if (save_errno == EINTR)
d150 9
a158 8
	fprintf_unfiltered (gdb_stderr, "Child process unexpectedly missing: %s.\n",
		 safe_strerror (save_errno));
	/* Claim it exited with unknown signal.  */
	ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
	ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
        return -1;
      }
  } while (pid != inferior_pid); /* Some other child died or stopped */
d160 1
a160 1
  return pid;
d164 11
d182 2
a183 3
static int
child_thread_alive (pid)
     int pid;
d185 2
d195 1
a195 3
child_attach (args, from_tty)
     char *args;
     int from_tty;
d206 1
d208 5
a212 1
    pid = atoi (args);
d214 1
a214 1
    if (pid == getpid())		/* Trying to masturbate? */
d222 2
a223 2
	  printf_unfiltered ("Attaching to program `%s', %s\n", exec_file,
		  target_pid_to_str (pid));
d225 2
a226 1
	  printf_unfiltered ("Attaching to %s\n", target_pid_to_str (pid));
d232 2
a233 1
    inferior_pid = pid;
d236 1
a236 1
#endif  /* ATTACH_DETACH */
d239 8
d257 1
a257 3
child_detach (args, from_tty)
     char *args;
     int from_tty;
d262 1
d269 2
a270 2
	printf_unfiltered ("Detaching from program: %s %s\n", exec_file,
		target_pid_to_str (inferior_pid));
d277 2
a278 1
    inferior_pid = 0;
d293 1
a293 1
child_prepare_to_store ()
d303 1
a303 2
child_files_info (ignore)
     struct target_ops *ignore;
d306 1
a306 1
	  attach_flag? "attached": "child", target_pid_to_str (inferior_pid));
a308 1
/* ARGSUSED */
d310 1
a310 3
child_open (arg, from_tty)
     char *arg;
     int from_tty;
d319 1
a319 1
ptrace_me ()
d328 2
a329 3
static int
ptrace_him (pid)
     int pid;
d333 12
a344 1
#ifdef START_INFERIOR_TRAPS_EXPECTED
a345 4
#else
  /* One trap to exec the shell, one to exec the program being debugged.  */
  startup_inferior (2);
#endif
d347 4
a350 1
  return pid;
d353 1
a353 1
/* Start an inferior Unix child process and sets inferior_pid to its pid.
d359 1
a359 4
child_create_inferior (exec_file, allargs, env)
     char *exec_file;
     char *allargs;
     char **env;
d361 5
a365 1
  fork_inferior (exec_file, allargs, env, ptrace_me, ptrace_him, NULL);
d371 118
d490 1
a490 1
child_mourn_inferior ()
a491 3
  /* FIXME: Should be in a header file */
  extern void proc_remove_foreign PARAMS ((int));

a492 1
  proc_remove_foreign (inferior_pid);
d497 1
a497 1
child_can_run ()
d513 1
a513 1
child_stop ()
d515 92
a606 1
  extern pid_t inferior_process_group;
d608 73
a680 1
  kill (-inferior_process_group, SIGINT);
a681 43

struct target_ops child_ops = {
  "child",			/* to_shortname */
  "Unix child process",		/* to_longname */
  "Unix child process (started by the \"run\" command).",	/* to_doc */
  child_open,			/* to_open */
  0,				/* to_close */
  child_attach,			/* to_attach */
  child_detach, 		/* to_detach */
  child_resume,			/* to_resume */
  child_wait,			/* to_wait */
  fetch_inferior_registers,	/* to_fetch_registers */
  store_inferior_registers,	/* to_store_registers */
  child_prepare_to_store,	/* to_prepare_to_store */
  child_xfer_memory,		/* to_xfer_memory */
  child_files_info,		/* to_files_info */
  memory_insert_breakpoint,	/* to_insert_breakpoint */
  memory_remove_breakpoint,	/* to_remove_breakpoint */
  terminal_init_inferior,	/* to_terminal_init */
  terminal_inferior, 		/* to_terminal_inferior */
  terminal_ours_for_output,	/* to_terminal_ours_for_output */
  terminal_ours,		/* to_terminal_ours */
  child_terminal_info,		/* to_terminal_info */
  kill_inferior,		/* to_kill */
  0,				/* to_load */
  0,				/* to_lookup_symbol */
  child_create_inferior,	/* to_create_inferior */
  child_mourn_inferior,		/* to_mourn_inferior */
  child_can_run,		/* to_can_run */
  0, 				/* to_notice_signals */
  child_thread_alive,		/* to_thread_alive */
  child_stop,			/* to_stop */
  process_stratum,		/* to_stratum */
  0,				/* to_next */
  1,				/* to_has_all_memory */
  1,				/* to_has_memory */
  1,				/* to_has_stack */
  1,				/* to_has_registers */
  1,				/* to_has_execution */
  0,				/* to_sections */
  0,				/* to_sections_end */
  OPS_MAGIC			/* to_magic */
};
d684 1
a684 1
_initialize_inftarg ()
d696 2
a697 1
  if ((fd = open (procname, O_RDONLY)) >= 0)
d704 1
@


1.1
log
@file inftarg.c was initially added on branch CYGNUS.
@
text
@d1 411
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 706
/* Target-vector operations for controlling Unix child processes, for GDB.

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
   2000, 2002, 2003, 2004 Free Software Foundation, Inc.

   Contributed by Cygnus Support.

   ## Contains temporary hacks..

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "frame.h"		/* required by inferior.h */
#include "inferior.h"
#include "target.h"
#include "gdbcore.h"
#include "command.h"
#include "gdb_stat.h"
#include <signal.h>
#include <sys/types.h>
#include <fcntl.h>

#include "gdb_wait.h"
#include "inflow.h"

extern struct symtab_and_line *child_enable_exception_callback (enum
								exception_event_kind,
								int);

extern struct exception_event_record
  *child_get_current_exception_event (void);

extern void _initialize_inftarg (void);

static void child_prepare_to_store (void);

#ifndef CHILD_WAIT
static ptid_t child_wait (ptid_t, struct target_waitstatus *);
#endif /* CHILD_WAIT */

#if !defined(CHILD_POST_WAIT)
void child_post_wait (ptid_t, int);
#endif

static void child_open (char *, int);

static void child_files_info (struct target_ops *);

static void child_detach (char *, int);

static void child_attach (char *, int);

#if !defined(CHILD_POST_ATTACH)
extern void child_post_attach (int);
#endif

static void ptrace_me (void);

static void ptrace_him (int);

static void child_create_inferior (char *, char *, char **);

static void child_mourn_inferior (void);

static int child_can_run (void);

static void child_stop (void);

#ifndef CHILD_THREAD_ALIVE
int child_thread_alive (ptid_t);
#endif

static void init_child_ops (void);

extern char **environ;

struct target_ops child_ops;

int child_suppress_run = 0;	/* Non-zero if inftarg should pretend not to
				   be a runnable target.  Used by targets
				   that can sit atop inftarg, such as HPUX
				   thread support.  */

#ifndef CHILD_WAIT

/* Wait for child to do something.  Return pid of child, or -1 in case
   of error; store status through argument pointer OURSTATUS.  */

static ptid_t
child_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
{
  int save_errno;
  int status;
  char *execd_pathname = NULL;
  int exit_status;
  int related_pid;
  int syscall_id;
  enum target_waitkind kind;
  int pid;

  do
    {
      set_sigint_trap ();	/* Causes SIGINT to be passed on to the
				   attached process. */
      set_sigio_trap ();

      pid = ptrace_wait (inferior_ptid, &status);

      save_errno = errno;

      clear_sigio_trap ();

      clear_sigint_trap ();

      if (pid == -1)
	{
	  if (save_errno == EINTR)
	    continue;

	  fprintf_unfiltered (gdb_stderr, "Child process unexpectedly missing: %s.\n",
			      safe_strerror (save_errno));

	  /* Claim it exited with unknown signal.  */
	  ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
	  ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
	  return pid_to_ptid (-1);
	}

      /* Did it exit?
       */
      if (target_has_exited (pid, status, &exit_status))
	{
	  /* ??rehrauer: For now, ignore this. */
	  continue;
	}

      if (!target_thread_alive (pid_to_ptid (pid)))
	{
	  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;
	  return pid_to_ptid (pid);
	}
      } while (pid != PIDGET (inferior_ptid)); /* Some other child died or stopped */

  store_waitstatus (ourstatus, status);
  return pid_to_ptid (pid);
}
#endif /* CHILD_WAIT */

#if !defined(CHILD_POST_WAIT)
void
child_post_wait (ptid_t ptid, int wait_status)
{
  /* This version of Unix doesn't require a meaningful "post wait"
     operation.
   */
}
#endif


#ifndef CHILD_THREAD_ALIVE

/* Check to see if the given thread is alive.

   FIXME: Is kill() ever the right way to do this?  I doubt it, but
   for now we're going to try and be compatable with the old thread
   code.  */
int
child_thread_alive (ptid_t ptid)
{
  pid_t pid = PIDGET (ptid);

  return (kill (pid, 0) != -1);
}

#endif

/* Attach to process PID, then initialize for debugging it.  */

static void
child_attach (char *args, int from_tty)
{
  if (!args)
    error_no_arg ("process-id to attach");

#ifndef ATTACH_DETACH
  error ("Can't attach to a process on this machine.");
#else
  {
    char *exec_file;
    int pid;
    char *dummy;

    dummy = args;
    pid = strtol (args, &dummy, 0);
    /* Some targets don't set errno on errors, grrr! */
    if ((pid == 0) && (args == dummy))
      error ("Illegal process-id: %s\n", args);

    if (pid == getpid ())	/* Trying to masturbate? */
      error ("I refuse to debug myself!");

    if (from_tty)
      {
	exec_file = (char *) get_exec_file (0);

	if (exec_file)
	  printf_unfiltered ("Attaching to program: %s, %s\n", exec_file,
			     target_pid_to_str (pid_to_ptid (pid)));
	else
	  printf_unfiltered ("Attaching to %s\n",
	                     target_pid_to_str (pid_to_ptid (pid)));

	gdb_flush (gdb_stdout);
      }

    attach (pid);

    inferior_ptid = pid_to_ptid (pid);
    push_target (&child_ops);
  }
#endif /* ATTACH_DETACH */
}

#if !defined(CHILD_POST_ATTACH)
void
child_post_attach (int pid)
{
  /* This version of Unix doesn't require a meaningful "post attach"
     operation by a debugger.  */
}
#endif

/* Take a program previously attached to and detaches it.
   The program resumes execution and will no longer stop
   on signals, etc.  We'd better not have left any breakpoints
   in the program or it'll die when it hits one.  For this
   to work, it may be necessary for the process to have been
   previously attached.  It *might* work if the program was
   started via the normal ptrace (PTRACE_TRACEME).  */

static void
child_detach (char *args, int from_tty)
{
#ifdef ATTACH_DETACH
  {
    int siggnal = 0;
    int pid = PIDGET (inferior_ptid);

    if (from_tty)
      {
	char *exec_file = get_exec_file (0);
	if (exec_file == 0)
	  exec_file = "";
	printf_unfiltered ("Detaching from program: %s, %s\n", exec_file,
			   target_pid_to_str (pid_to_ptid (pid)));
	gdb_flush (gdb_stdout);
      }
    if (args)
      siggnal = atoi (args);

    detach (siggnal);

    inferior_ptid = null_ptid;
    unpush_target (&child_ops);
  }
#else
  error ("This version of Unix does not support detaching a process.");
#endif
}

/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On machines
   which store all the registers in one fell swoop, this makes sure
   that registers contains all the registers from the program being
   debugged.  */

static void
child_prepare_to_store (void)
{
#ifdef CHILD_PREPARE_TO_STORE
  CHILD_PREPARE_TO_STORE ();
#endif
}

/* Print status information about what we're accessing.  */

static void
child_files_info (struct target_ops *ignore)
{
  printf_unfiltered ("\tUsing the running image of %s %s.\n",
      attach_flag ? "attached" : "child", target_pid_to_str (inferior_ptid));
}

static void
child_open (char *arg, int from_tty)
{
  error ("Use the \"run\" command to start a Unix child process.");
}

/* Stub function which causes the inferior that runs it, to be ptrace-able
   by its parent process.  */

static void
ptrace_me (void)
{
  /* "Trace me, Dr. Memory!" */
  call_ptrace (0, 0, (PTRACE_ARG3_TYPE) 0, 0);
}

/* Stub function which causes the GDB that runs it, to start ptrace-ing
   the child process.  */

static void
ptrace_him (int pid)
{
  push_target (&child_ops);

  /* On some targets, there must be some explicit synchronization
     between the parent and child processes after the debugger
     forks, and before the child execs the debuggee program.  This
     call basically gives permission for the child to exec.
   */

  target_acknowledge_created_inferior (pid);

  /* START_INFERIOR_TRAPS_EXPECTED is defined in inferior.h,
   * and will be 1 or 2 depending on whether we're starting
   * without or with a shell.
   */
  startup_inferior (START_INFERIOR_TRAPS_EXPECTED);

  /* On some targets, there must be some explicit actions taken after
     the inferior has been started up.
   */
  target_post_startup_inferior (pid_to_ptid (pid));
}

/* Start an inferior Unix child process and sets inferior_ptid to its pid.
   EXEC_FILE is the file to run.
   ALLARGS is a string containing the arguments to the program.
   ENV is the environment vector to pass.  Errors reported with error().  */

static void
child_create_inferior (char *exec_file, char *allargs, char **env)
{
#ifdef HPUXHPPA
  fork_inferior (exec_file, allargs, env, ptrace_me, ptrace_him, pre_fork_inferior, NULL);
#else
  fork_inferior (exec_file, allargs, env, ptrace_me, ptrace_him, NULL, NULL);
#endif
  /* We are at the first instruction we care about.  */
  /* Pedal to the metal... */
  proceed ((CORE_ADDR) -1, TARGET_SIGNAL_0, 0);
}

#if !defined(CHILD_POST_STARTUP_INFERIOR)
void
child_post_startup_inferior (ptid_t ptid)
{
  /* This version of Unix doesn't require a meaningful "post startup inferior"
     operation by a debugger.
   */
}
#endif

#if !defined(CHILD_ACKNOWLEDGE_CREATED_INFERIOR)
void
child_acknowledge_created_inferior (int pid)
{
  /* This version of Unix doesn't require a meaningful "acknowledge created inferior"
     operation by a debugger.
   */
}
#endif


#if !defined(CHILD_INSERT_FORK_CATCHPOINT)
int
child_insert_fork_catchpoint (int pid)
{
  /* This version of Unix doesn't support notification of fork events.  */
  return 0;
}
#endif

#if !defined(CHILD_REMOVE_FORK_CATCHPOINT)
int
child_remove_fork_catchpoint (int pid)
{
  /* This version of Unix doesn't support notification of fork events.  */
  return 0;
}
#endif

#if !defined(CHILD_INSERT_VFORK_CATCHPOINT)
int
child_insert_vfork_catchpoint (int pid)
{
  /* This version of Unix doesn't support notification of vfork events.  */
  return 0;
}
#endif

#if !defined(CHILD_REMOVE_VFORK_CATCHPOINT)
int
child_remove_vfork_catchpoint (int pid)
{
  /* This version of Unix doesn't support notification of vfork events.  */
  return 0;
}
#endif

#if !defined(CHILD_FOLLOW_FORK)
int
child_follow_fork (int follow_child)
{
  /* This version of Unix doesn't support following fork or vfork events.  */
  return 0;
}
#endif

#if !defined(CHILD_INSERT_EXEC_CATCHPOINT)
int
child_insert_exec_catchpoint (int pid)
{
  /* This version of Unix doesn't support notification of exec events.  */
  return 0;
}
#endif

#if !defined(CHILD_REMOVE_EXEC_CATCHPOINT)
int
child_remove_exec_catchpoint (int pid)
{
  /* This version of Unix doesn't support notification of exec events.  */
  return 0;
}
#endif

#if !defined(CHILD_REPORTED_EXEC_EVENTS_PER_EXEC_CALL)
int
child_reported_exec_events_per_exec_call (void)
{
  /* This version of Unix doesn't support notification of exec events.
   */
  return 1;
}
#endif

#if !defined(CHILD_HAS_EXITED)
int
child_has_exited (int pid, int wait_status, int *exit_status)
{
  if (WIFEXITED (wait_status))
    {
      *exit_status = WEXITSTATUS (wait_status);
      return 1;
    }

  if (WIFSIGNALED (wait_status))
    {
      *exit_status = 0;		/* ?? Don't know what else to say here. */
      return 1;
    }

  /* ?? Do we really need to consult the event state, too?  Assume the
     wait_state alone suffices.
   */
  return 0;
}
#endif


static void
child_mourn_inferior (void)
{
  unpush_target (&child_ops);
  generic_mourn_inferior ();
}

static int
child_can_run (void)
{
  /* This variable is controlled by modules that sit atop inftarg that may layer
     their own process structure atop that provided here.  hpux-thread.c does
     this because of the Hpux user-mode level thread model.  */

  return !child_suppress_run;
}

/* Send a SIGINT to the process group.  This acts just like the user typed a
   ^C on the controlling terminal.

   XXX - This may not be correct for all systems.  Some may want to use
   killpg() instead of kill (-pgrp). */

static void
child_stop (void)
{
  kill (-inferior_process_group, SIGINT);
}

#if !defined(CHILD_ENABLE_EXCEPTION_CALLBACK)
struct symtab_and_line *
child_enable_exception_callback (enum exception_event_kind kind, int enable)
{
  return (struct symtab_and_line *) NULL;
}
#endif

#if !defined(CHILD_GET_CURRENT_EXCEPTION_EVENT)
struct exception_event_record *
child_get_current_exception_event (void)
{
  return (struct exception_event_record *) NULL;
}
#endif


#if !defined(CHILD_PID_TO_EXEC_FILE)
char *
child_pid_to_exec_file (int pid)
{
  /* This version of Unix doesn't support translation of a process ID
     to the filename of the executable file.
   */
  return NULL;
}
#endif

char *
child_core_file_to_sym_file (char *core)
{
  /* The target stratum for a running executable need not support
     this operation.
   */
  return NULL;
}

/* Perform a partial transfer to/from the specified object.  For
   memory transfers, fall back to the old memory xfer functions.  */

static LONGEST
child_xfer_partial (struct target_ops *ops, enum target_object object,
		    const char *annex, void *readbuf,
		    const void *writebuf, ULONGEST offset, LONGEST len)
{
  switch (object)
    {
    case TARGET_OBJECT_MEMORY:
      if (readbuf)
	return child_xfer_memory (offset, readbuf, len, 0/*write*/,
				  NULL, ops);
      if (writebuf)
	return child_xfer_memory (offset, readbuf, len, 1/*write*/,
				  NULL, ops);
      return -1;

    case TARGET_OBJECT_UNWIND_TABLE:
#ifndef NATIVE_XFER_UNWIND_TABLE
#define NATIVE_XFER_UNWIND_TABLE(OPS,OBJECT,ANNEX,WRITEBUF,READBUF,OFFSET,LEN) (-1)
#endif
      return NATIVE_XFER_UNWIND_TABLE (ops, object, annex, readbuf, writebuf,
				       offset, len);

    case TARGET_OBJECT_AUXV:
#ifndef NATIVE_XFER_AUXV
#define NATIVE_XFER_AUXV(OPS,OBJECT,ANNEX,WRITEBUF,READBUF,OFFSET,LEN) (-1)
#endif
      return NATIVE_XFER_AUXV (ops, object, annex, readbuf, writebuf,
			       offset, len);

    case TARGET_OBJECT_WCOOKIE:
#ifndef NATIVE_XFER_WCOOKIE
#define NATIVE_XFER_WCOOKIE(OPS,OBJECT,ANNEX,WRITEBUF,READBUF,OFFSET,LEN) (-1)
#endif
      return NATIVE_XFER_WCOOKIE (ops, object, annex, readbuf, writebuf,
				  offset, len);

    default:
      return -1;
    }
}

#if !defined(CHILD_PID_TO_STR)
char *
child_pid_to_str (ptid_t ptid)
{
  return normal_pid_to_str (ptid);
}
#endif

static void
init_child_ops (void)
{
  child_ops.to_shortname = "child";
  child_ops.to_longname = "Unix child process";
  child_ops.to_doc = "Unix child process (started by the \"run\" command).";
  child_ops.to_open = child_open;
  child_ops.to_attach = child_attach;
  child_ops.to_post_attach = child_post_attach;
  child_ops.to_detach = child_detach;
  child_ops.to_resume = child_resume;
  child_ops.to_wait = child_wait;
  child_ops.to_post_wait = child_post_wait;
  child_ops.to_fetch_registers = fetch_inferior_registers;
  child_ops.to_store_registers = store_inferior_registers;
  child_ops.to_prepare_to_store = child_prepare_to_store;
  child_ops.to_xfer_memory = child_xfer_memory;
  child_ops.to_xfer_partial = child_xfer_partial;
  child_ops.to_files_info = child_files_info;
  child_ops.to_insert_breakpoint = memory_insert_breakpoint;
  child_ops.to_remove_breakpoint = memory_remove_breakpoint;
  child_ops.to_terminal_init = terminal_init_inferior;
  child_ops.to_terminal_inferior = terminal_inferior;
  child_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  child_ops.to_terminal_save_ours = terminal_save_ours;
  child_ops.to_terminal_ours = terminal_ours;
  child_ops.to_terminal_info = child_terminal_info;
  child_ops.to_kill = kill_inferior;
  child_ops.to_create_inferior = child_create_inferior;
  child_ops.to_post_startup_inferior = child_post_startup_inferior;
  child_ops.to_acknowledge_created_inferior = child_acknowledge_created_inferior;
  child_ops.to_insert_fork_catchpoint = child_insert_fork_catchpoint;
  child_ops.to_remove_fork_catchpoint = child_remove_fork_catchpoint;
  child_ops.to_insert_vfork_catchpoint = child_insert_vfork_catchpoint;
  child_ops.to_remove_vfork_catchpoint = child_remove_vfork_catchpoint;
  child_ops.to_follow_fork = child_follow_fork;
  child_ops.to_insert_exec_catchpoint = child_insert_exec_catchpoint;
  child_ops.to_remove_exec_catchpoint = child_remove_exec_catchpoint;
  child_ops.to_reported_exec_events_per_exec_call = child_reported_exec_events_per_exec_call;
  child_ops.to_has_exited = child_has_exited;
  child_ops.to_mourn_inferior = child_mourn_inferior;
  child_ops.to_can_run = child_can_run;
  child_ops.to_thread_alive = child_thread_alive;
  child_ops.to_pid_to_str = child_pid_to_str;
  child_ops.to_stop = child_stop;
  child_ops.to_enable_exception_callback = child_enable_exception_callback;
  child_ops.to_get_current_exception_event = child_get_current_exception_event;
  child_ops.to_pid_to_exec_file = child_pid_to_exec_file;
  child_ops.to_stratum = process_stratum;
  child_ops.to_has_all_memory = 1;
  child_ops.to_has_memory = 1;
  child_ops.to_has_stack = 1;
  child_ops.to_has_registers = 1;
  child_ops.to_has_execution = 1;
  child_ops.to_magic = OPS_MAGIC;
}

/* Take over the 'find_mapped_memory' vector from inftarg.c. */
extern void
inftarg_set_find_memory_regions (int (*func) (int (*) (CORE_ADDR,
						       unsigned long,
						       int, int, int,
						       void *),
					      void *))
{
  child_ops.to_find_memory_regions = func;
}

/* Take over the 'make_corefile_notes' vector from inftarg.c. */
extern void
inftarg_set_make_corefile_notes (char * (*func) (bfd *, int *))
{
  child_ops.to_make_corefile_notes = func;
}

void
_initialize_inftarg (void)
{
#ifdef HAVE_OPTIONAL_PROC_FS
  char procname[32];
  int fd;

  /* If we have an optional /proc filesystem (e.g. under OSF/1),
     don't add ptrace support if we can access the running GDB via /proc.  */
#ifndef PROC_NAME_FMT
#define PROC_NAME_FMT "/proc/%05d"
#endif
  sprintf (procname, PROC_NAME_FMT, getpid ());
  fd = open (procname, O_RDONLY);
  if (fd >= 0)
    {
      close (fd);
      return;
    }
#endif

  init_child_ops ();
  add_target (&child_ops);
}
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d37 1
a37 1
#include "observer.h"
d56 4
d76 1
a76 1
static void child_create_inferior (char *, char *, char **, int);
d92 2
d122 1
a122 1
      pid = wait (&status);
d164 11
a196 4
  char *exec_file;
  int pid;
  char *dummy;

d200 12
a211 4
  dummy = args;
  pid = strtol (args, &dummy, 0);
  /* Some targets don't set errno on errors, grrr! */
  if ((pid == 0) && (args == dummy))
a212 17
  
  if (pid == getpid ())	/* Trying to masturbate? */
    error ("I refuse to debug myself!");
  
  if (from_tty)
    {
      exec_file = (char *) get_exec_file (0);
      
      if (exec_file)
	printf_unfiltered ("Attaching to program: %s, %s\n", exec_file,
			   target_pid_to_str (pid_to_ptid (pid)));
      else
	printf_unfiltered ("Attaching to %s\n",
			   target_pid_to_str (pid_to_ptid (pid)));
      
      gdb_flush (gdb_stdout);
    }
d214 23
a236 4
  attach (pid);
  
  inferior_ptid = pid_to_ptid (pid);
  push_target (&deprecated_child_ops);
d259 25
a283 19
  int siggnal = 0;
  int pid = PIDGET (inferior_ptid);
  
  if (from_tty)
    {
      char *exec_file = get_exec_file (0);
      if (exec_file == 0)
	exec_file = "";
      printf_unfiltered ("Detaching from program: %s, %s\n", exec_file,
			 target_pid_to_str (pid_to_ptid (pid)));
      gdb_flush (gdb_stdout);
    }
  if (args)
    siggnal = atoi (args);
  
  detach (siggnal);
  
  inferior_ptid = null_ptid;
  unpush_target (&deprecated_child_ops);
d322 1
a322 1
  call_ptrace (0, 0, (PTRACE_TYPE_ARG3) 0, 0);
d331 1
a331 1
  push_target (&deprecated_child_ops);
d359 1
a359 2
child_create_inferior (char *exec_file, char *allargs, char **env,
		       int from_tty)
a366 1
  observer_notify_inferior_created (&current_target, from_tty);
d492 1
a492 1
  unpush_target (&deprecated_child_ops);
d570 1
a570 1
	return child_xfer_memory (offset, (void *) writebuf, len, 1/*write*/,
d611 70
a680 51
  deprecated_child_ops.to_shortname = "child";
  deprecated_child_ops.to_longname = "Unix child process";
  deprecated_child_ops.to_doc = "Unix child process (started by the \"run\" command).";
  deprecated_child_ops.to_open = child_open;
  deprecated_child_ops.to_attach = child_attach;
  deprecated_child_ops.to_post_attach = child_post_attach;
  deprecated_child_ops.to_detach = child_detach;
  deprecated_child_ops.to_resume = child_resume;
  deprecated_child_ops.to_wait = child_wait;
  deprecated_child_ops.to_fetch_registers = fetch_inferior_registers;
  deprecated_child_ops.to_store_registers = store_inferior_registers;
  deprecated_child_ops.to_prepare_to_store = child_prepare_to_store;
  deprecated_child_ops.deprecated_xfer_memory = child_xfer_memory;
  deprecated_child_ops.to_xfer_partial = child_xfer_partial;
  deprecated_child_ops.to_files_info = child_files_info;
  deprecated_child_ops.to_insert_breakpoint = memory_insert_breakpoint;
  deprecated_child_ops.to_remove_breakpoint = memory_remove_breakpoint;
  deprecated_child_ops.to_terminal_init = terminal_init_inferior;
  deprecated_child_ops.to_terminal_inferior = terminal_inferior;
  deprecated_child_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  deprecated_child_ops.to_terminal_save_ours = terminal_save_ours;
  deprecated_child_ops.to_terminal_ours = terminal_ours;
  deprecated_child_ops.to_terminal_info = child_terminal_info;
  deprecated_child_ops.to_kill = kill_inferior;
  deprecated_child_ops.to_create_inferior = child_create_inferior;
  deprecated_child_ops.to_post_startup_inferior = child_post_startup_inferior;
  deprecated_child_ops.to_acknowledge_created_inferior = child_acknowledge_created_inferior;
  deprecated_child_ops.to_insert_fork_catchpoint = child_insert_fork_catchpoint;
  deprecated_child_ops.to_remove_fork_catchpoint = child_remove_fork_catchpoint;
  deprecated_child_ops.to_insert_vfork_catchpoint = child_insert_vfork_catchpoint;
  deprecated_child_ops.to_remove_vfork_catchpoint = child_remove_vfork_catchpoint;
  deprecated_child_ops.to_follow_fork = child_follow_fork;
  deprecated_child_ops.to_insert_exec_catchpoint = child_insert_exec_catchpoint;
  deprecated_child_ops.to_remove_exec_catchpoint = child_remove_exec_catchpoint;
  deprecated_child_ops.to_reported_exec_events_per_exec_call = child_reported_exec_events_per_exec_call;
  deprecated_child_ops.to_has_exited = child_has_exited;
  deprecated_child_ops.to_mourn_inferior = child_mourn_inferior;
  deprecated_child_ops.to_can_run = child_can_run;
  deprecated_child_ops.to_thread_alive = child_thread_alive;
  deprecated_child_ops.to_pid_to_str = child_pid_to_str;
  deprecated_child_ops.to_stop = child_stop;
  deprecated_child_ops.to_enable_exception_callback = child_enable_exception_callback;
  deprecated_child_ops.to_get_current_exception_event = child_get_current_exception_event;
  deprecated_child_ops.to_pid_to_exec_file = child_pid_to_exec_file;
  deprecated_child_ops.to_stratum = process_stratum;
  deprecated_child_ops.to_has_all_memory = 1;
  deprecated_child_ops.to_has_memory = 1;
  deprecated_child_ops.to_has_stack = 1;
  deprecated_child_ops.to_has_registers = 1;
  deprecated_child_ops.to_has_execution = 1;
  deprecated_child_ops.to_magic = OPS_MAGIC;
d705 1
a705 1
  add_target (&deprecated_child_ops);
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 411
/* Target-vector operations for controlling Unix child processes, for GDB.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996
   Free Software Foundation, Inc.
   Contributed by Cygnus Support.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "frame.h"  /* required by inferior.h */
#include "inferior.h"
#include "target.h"
#include "wait.h"
#include "gdbcore.h"
#include "command.h"
#include <signal.h>
#include <sys/types.h>
#include <fcntl.h>

static void
child_prepare_to_store PARAMS ((void));

#ifndef CHILD_WAIT
static int child_wait PARAMS ((int, struct target_waitstatus *));
#endif /* CHILD_WAIT */

static void child_open PARAMS ((char *, int));

static void
child_files_info PARAMS ((struct target_ops *));

static void
child_detach PARAMS ((char *, int));

static void
child_attach PARAMS ((char *, int));

static void
ptrace_me PARAMS ((void));

static int
ptrace_him PARAMS ((int));

static void child_create_inferior PARAMS ((char *, char *, char **));

static void
child_mourn_inferior PARAMS ((void));

static int
child_can_run PARAMS ((void));

static int
proc_wait PARAMS ((int, int*));

static void
child_stop PARAMS ((void));

#ifndef CHILD_THREAD_ALIVE
static int child_thread_alive PARAMS ((int));
#endif

extern char **environ;

/* Forward declaration */
extern struct target_ops child_ops;

int child_suppress_run = 0;	/* Non-zero if inftarg should pretend not to
				   be a runnable target.  Used by targets
				   that can sit atop inftarg, such as HPUX
				   thread support.  */
static int
proc_wait (pid, status)
     int pid;
     int *status;
{
#ifndef __GO32__
  return wait (status);
#endif
}

#ifndef CHILD_WAIT

/* Wait for child to do something.  Return pid of child, or -1 in case
   of error; store status through argument pointer OURSTATUS.  */

static int
child_wait (pid, ourstatus)
     int pid;
     struct target_waitstatus *ourstatus;
{
  int save_errno;
  int status;

  do {
    set_sigint_trap();	/* Causes SIGINT to be passed on to the
			   attached process. */
    set_sigio_trap ();

    pid = proc_wait (inferior_pid, &status);
    save_errno = errno;

    clear_sigio_trap ();

    clear_sigint_trap();

    if (pid == -1)
      {
	if (save_errno == EINTR)
	  continue;
	fprintf_unfiltered (gdb_stderr, "Child process unexpectedly missing: %s.\n",
		 safe_strerror (save_errno));
	/* Claim it exited with unknown signal.  */
	ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
	ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
        return -1;
      }
  } while (pid != inferior_pid); /* Some other child died or stopped */
  store_waitstatus (ourstatus, status);
  return pid;
}
#endif /* CHILD_WAIT */

#ifndef CHILD_THREAD_ALIVE

/* Check to see if the given thread is alive.

   FIXME: Is kill() ever the right way to do this?  I doubt it, but
   for now we're going to try and be compatable with the old thread
   code.  */
static int
child_thread_alive (pid)
     int pid;
{
  return (kill (pid, 0) != -1);
}

#endif

/* Attach to process PID, then initialize for debugging it.  */

static void
child_attach (args, from_tty)
     char *args;
     int from_tty;
{
  if (!args)
    error_no_arg ("process-id to attach");

#ifndef ATTACH_DETACH
  error ("Can't attach to a process on this machine.");
#else
  {
    char *exec_file;
    int pid;

    pid = atoi (args);

    if (pid == getpid())		/* Trying to masturbate? */
      error ("I refuse to debug myself!");

    if (from_tty)
      {
	exec_file = (char *) get_exec_file (0);

	if (exec_file)
	  printf_unfiltered ("Attaching to program `%s', %s\n", exec_file,
		  target_pid_to_str (pid));
	else
	  printf_unfiltered ("Attaching to %s\n", target_pid_to_str (pid));

	gdb_flush (gdb_stdout);
      }

    attach (pid);
    inferior_pid = pid;
    push_target (&child_ops);
  }
#endif  /* ATTACH_DETACH */
}


/* Take a program previously attached to and detaches it.
   The program resumes execution and will no longer stop
   on signals, etc.  We'd better not have left any breakpoints
   in the program or it'll die when it hits one.  For this
   to work, it may be necessary for the process to have been
   previously attached.  It *might* work if the program was
   started via the normal ptrace (PTRACE_TRACEME).  */

static void
child_detach (args, from_tty)
     char *args;
     int from_tty;
{
#ifdef ATTACH_DETACH
  {
    int siggnal = 0;

    if (from_tty)
      {
	char *exec_file = get_exec_file (0);
	if (exec_file == 0)
	  exec_file = "";
	printf_unfiltered ("Detaching from program: %s %s\n", exec_file,
		target_pid_to_str (inferior_pid));
	gdb_flush (gdb_stdout);
      }
    if (args)
      siggnal = atoi (args);

    detach (siggnal);
    inferior_pid = 0;
    unpush_target (&child_ops);
  }
#else
  error ("This version of Unix does not support detaching a process.");
#endif
}

/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On machines
   which store all the registers in one fell swoop, this makes sure
   that registers contains all the registers from the program being
   debugged.  */

static void
child_prepare_to_store ()
{
#ifdef CHILD_PREPARE_TO_STORE
  CHILD_PREPARE_TO_STORE ();
#endif
}

/* Print status information about what we're accessing.  */

static void
child_files_info (ignore)
     struct target_ops *ignore;
{
  printf_unfiltered ("\tUsing the running image of %s %s.\n",
	  attach_flag? "attached": "child", target_pid_to_str (inferior_pid));
}

/* ARGSUSED */
static void
child_open (arg, from_tty)
     char *arg;
     int from_tty;
{
  error ("Use the \"run\" command to start a Unix child process.");
}

/* Stub function which causes the inferior that runs it, to be ptrace-able
   by its parent process.  */

static void
ptrace_me ()
{
  /* "Trace me, Dr. Memory!" */
  call_ptrace (0, 0, (PTRACE_ARG3_TYPE) 0, 0);
}

/* Stub function which causes the GDB that runs it, to start ptrace-ing
   the child process.  */

static int
ptrace_him (pid)
     int pid;
{
  push_target (&child_ops);

#ifdef START_INFERIOR_TRAPS_EXPECTED
  startup_inferior (START_INFERIOR_TRAPS_EXPECTED);
#else
  /* One trap to exec the shell, one to exec the program being debugged.  */
  startup_inferior (2);
#endif

  return pid;
}

/* Start an inferior Unix child process and sets inferior_pid to its pid.
   EXEC_FILE is the file to run.
   ALLARGS is a string containing the arguments to the program.
   ENV is the environment vector to pass.  Errors reported with error().  */

static void
child_create_inferior (exec_file, allargs, env)
     char *exec_file;
     char *allargs;
     char **env;
{
  fork_inferior (exec_file, allargs, env, ptrace_me, ptrace_him, NULL);
  /* We are at the first instruction we care about.  */
  /* Pedal to the metal... */
  proceed ((CORE_ADDR) -1, TARGET_SIGNAL_0, 0);
}

static void
child_mourn_inferior ()
{
  /* FIXME: Should be in a header file */
  extern void proc_remove_foreign PARAMS ((int));

  unpush_target (&child_ops);
  proc_remove_foreign (inferior_pid);
  generic_mourn_inferior ();
}

static int
child_can_run ()
{
  /* This variable is controlled by modules that sit atop inftarg that may layer
     their own process structure atop that provided here.  hpux-thread.c does
     this because of the Hpux user-mode level thread model.  */

  return !child_suppress_run;
}

/* Send a SIGINT to the process group.  This acts just like the user typed a
   ^C on the controlling terminal.

   XXX - This may not be correct for all systems.  Some may want to use
   killpg() instead of kill (-pgrp). */

static void
child_stop ()
{
  extern pid_t inferior_process_group;

  kill (-inferior_process_group, SIGINT);
}

struct target_ops child_ops = {
  "child",			/* to_shortname */
  "Unix child process",		/* to_longname */
  "Unix child process (started by the \"run\" command).",	/* to_doc */
  child_open,			/* to_open */
  0,				/* to_close */
  child_attach,			/* to_attach */
  child_detach, 		/* to_detach */
  child_resume,			/* to_resume */
  child_wait,			/* to_wait */
  fetch_inferior_registers,	/* to_fetch_registers */
  store_inferior_registers,	/* to_store_registers */
  child_prepare_to_store,	/* to_prepare_to_store */
  child_xfer_memory,		/* to_xfer_memory */
  child_files_info,		/* to_files_info */
  memory_insert_breakpoint,	/* to_insert_breakpoint */
  memory_remove_breakpoint,	/* to_remove_breakpoint */
  terminal_init_inferior,	/* to_terminal_init */
  terminal_inferior, 		/* to_terminal_inferior */
  terminal_ours_for_output,	/* to_terminal_ours_for_output */
  terminal_ours,		/* to_terminal_ours */
  child_terminal_info,		/* to_terminal_info */
  kill_inferior,		/* to_kill */
  0,				/* to_load */
  0,				/* to_lookup_symbol */
  child_create_inferior,	/* to_create_inferior */
  child_mourn_inferior,		/* to_mourn_inferior */
  child_can_run,		/* to_can_run */
  0, 				/* to_notice_signals */
  child_thread_alive,		/* to_thread_alive */
  child_stop,			/* to_stop */
  process_stratum,		/* to_stratum */
  0,				/* to_next */
  1,				/* to_has_all_memory */
  1,				/* to_has_memory */
  1,				/* to_has_stack */
  1,				/* to_has_registers */
  1,				/* to_has_execution */
  0,				/* to_sections */
  0,				/* to_sections_end */
  OPS_MAGIC			/* to_magic */
};

void
_initialize_inftarg ()
{
#ifdef HAVE_OPTIONAL_PROC_FS
  char procname[32];
  int fd;

  /* If we have an optional /proc filesystem (e.g. under OSF/1),
     don't add ptrace support if we can access the running GDB via /proc.  */
#ifndef PROC_NAME_FMT
#define PROC_NAME_FMT "/proc/%05d"
#endif
  sprintf (procname, PROC_NAME_FMT, getpid ());
  if ((fd = open (procname, O_RDONLY)) >= 0)
    {
      close (fd);
      return;
    }
#endif

  add_target (&child_ops);
}
@
