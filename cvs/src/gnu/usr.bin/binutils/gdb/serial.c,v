head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.50
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.52
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.48
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.44
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.46
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.38
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.42
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.40
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.36
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.34
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.32
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.30
	OPENBSD_5_0:1.4.0.28
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.26
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.24
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2004.12.27.14.00.41;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.21.20.23.13;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.39.36;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.20.25;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.12.55;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.05.26;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.20.26;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@/* Generic serial interface routines

   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include <ctype.h>
#include "serial.h"
#include "gdb_string.h"
#include "gdbcmd.h"

extern void _initialize_serial (void);

/* Is serial being debugged? */

static int global_serial_debug_p;

/* Linked list of serial I/O handlers */

static struct serial_ops *serial_ops_list = NULL;

/* This is the last serial stream opened.  Used by connect command. */

static struct serial *last_serial_opened = NULL;

/* Pointer to list of scb's. */

static struct serial *scb_base;

/* Non-NULL gives filename which contains a recording of the remote session,
   suitable for playback by gdbserver. */

static char *serial_logfile = NULL;
static struct ui_file *serial_logfp = NULL;

static struct serial_ops *serial_interface_lookup (char *);
static void serial_logchar (struct ui_file *stream, int ch_type, int ch, int timeout);
static const char logbase_hex[] = "hex";
static const char logbase_octal[] = "octal";
static const char logbase_ascii[] = "ascii";
static const char *logbase_enums[] =
{logbase_hex, logbase_octal, logbase_ascii, NULL};
static const char *serial_logbase = logbase_ascii;


static int serial_current_type = 0;

/* Log char CH of type CHTYPE, with TIMEOUT */

/* Define bogus char to represent a BREAK.  Should be careful to choose a value
   that can't be confused with a normal char, or an error code.  */
#define SERIAL_BREAK 1235

static void
serial_logchar (struct ui_file *stream, int ch_type, int ch, int timeout)
{
  if (ch_type != serial_current_type)
    {
      fprintf_unfiltered (stream, "\n%c ", ch_type);
      serial_current_type = ch_type;
    }

  if (serial_logbase != logbase_ascii)
    fputc_unfiltered (' ', stream);

  switch (ch)
    {
    case SERIAL_TIMEOUT:
      fprintf_unfiltered (stream, "<Timeout: %d seconds>", timeout);
      return;
    case SERIAL_ERROR:
      fprintf_unfiltered (stream, "<Error: %s>", safe_strerror (errno));
      return;
    case SERIAL_EOF:
      fputs_unfiltered ("<Eof>", stream);
      return;
    case SERIAL_BREAK:
      fputs_unfiltered ("<Break>", stream);
      return;
    default:
      if (serial_logbase == logbase_hex)
	fprintf_unfiltered (stream, "%02x", ch & 0xff);
      else if (serial_logbase == logbase_octal)
	fprintf_unfiltered (stream, "%03o", ch & 0xff);
      else
	switch (ch)
	  {
	  case '\\':
	    fputs_unfiltered ("\\\\", stream);
	    break;
	  case '\b':
	    fputs_unfiltered ("\\b", stream);
	    break;
	  case '\f':
	    fputs_unfiltered ("\\f", stream);
	    break;
	  case '\n':
	    fputs_unfiltered ("\\n", stream);
	    break;
	  case '\r':
	    fputs_unfiltered ("\\r", stream);
	    break;
	  case '\t':
	    fputs_unfiltered ("\\t", stream);
	    break;
	  case '\v':
	    fputs_unfiltered ("\\v", stream);
	    break;
	  default:
	    fprintf_unfiltered (stream, isprint (ch) ? "%c" : "\\x%02x", ch & 0xFF);
	    break;
	  }
    }
}

void
serial_log_command (const char *cmd)
{
  if (!serial_logfp)
    return;

  serial_current_type = 'c';

  fputs_unfiltered ("\nc ", serial_logfp);
  fputs_unfiltered (cmd, serial_logfp);

  /* Make sure that the log file is as up-to-date as possible,
     in case we are getting ready to dump core or something. */
  gdb_flush (serial_logfp);
}


static struct serial_ops *
serial_interface_lookup (char *name)
{
  struct serial_ops *ops;

  for (ops = serial_ops_list; ops; ops = ops->next)
    if (strcmp (name, ops->name) == 0)
      return ops;

  return NULL;
}

void
serial_add_interface (struct serial_ops *optable)
{
  optable->next = serial_ops_list;
  serial_ops_list = optable;
}

/* Open up a device or a network socket, depending upon the syntax of NAME. */

struct serial *
serial_open (const char *name)
{
  struct serial *scb;
  struct serial_ops *ops;
  const char *open_name = name;

  for (scb = scb_base; scb; scb = scb->next)
    if (scb->name && strcmp (scb->name, name) == 0)
      {
	scb->refcnt++;
	return scb;
      }

  if (strcmp (name, "pc") == 0)
    ops = serial_interface_lookup ("pc");
  else if (strchr (name, ':'))
    ops = serial_interface_lookup ("tcp");
  else if (strncmp (name, "lpt", 3) == 0)
    ops = serial_interface_lookup ("parallel");
  else if (strncmp (name, "|", 1) == 0)
    {
      ops = serial_interface_lookup ("pipe");
      open_name = name + 1; /* discard ``|'' */
    }
  else
    ops = serial_interface_lookup ("hardwire");

  if (!ops)
    return NULL;

  scb = XMALLOC (struct serial);

  scb->ops = ops;

  scb->bufcnt = 0;
  scb->bufp = scb->buf;

  if (scb->ops->open (scb, open_name))
    {
      xfree (scb);
      return NULL;
    }

  scb->name = xstrdup (name);
  scb->next = scb_base;
  scb->refcnt = 1;
  scb->debug_p = 0;
  scb->async_state = 0;
  scb->async_handler = NULL;
  scb->async_context = NULL;
  scb_base = scb;

  last_serial_opened = scb;

  if (serial_logfile != NULL)
    {
      serial_logfp = gdb_fopen (serial_logfile, "w");
      if (serial_logfp == NULL)
	perror_with_name (serial_logfile);
    }

  return scb;
}

struct serial *
serial_fdopen (const int fd)
{
  struct serial *scb;
  struct serial_ops *ops;

  for (scb = scb_base; scb; scb = scb->next)
    if (scb->fd == fd)
      {
	scb->refcnt++;
	return scb;
      }

  ops = serial_interface_lookup ("hardwire");

  if (!ops)
    return NULL;

  scb = XMALLOC (struct serial);

  scb->ops = ops;

  scb->bufcnt = 0;
  scb->bufp = scb->buf;

  scb->fd = fd;

  scb->name = NULL;
  scb->next = scb_base;
  scb->refcnt = 1;
  scb->debug_p = 0;
  scb->async_state = 0;
  scb->async_handler = NULL;
  scb->async_context = NULL;
  scb_base = scb;

  last_serial_opened = scb;

  return scb;
}

static void
do_serial_close (struct serial *scb, int really_close)
{
  struct serial *tmp_scb;

  last_serial_opened = NULL;

  if (serial_logfp)
    {
      fputs_unfiltered ("\nEnd of log\n", serial_logfp);
      serial_current_type = 0;

      /* XXX - What if serial_logfp == gdb_stdout or gdb_stderr? */
      ui_file_delete (serial_logfp);
      serial_logfp = NULL;
    }

/* This is bogus.  It's not our fault if you pass us a bad scb...!  Rob, you
   should fix your code instead.  */

  if (!scb)
    return;

  scb->refcnt--;
  if (scb->refcnt > 0)
    return;

  /* ensure that the FD has been taken out of async mode */
  if (scb->async_handler != NULL)
    serial_async (scb, NULL, NULL);

  if (really_close)
    scb->ops->close (scb);

  if (scb->name)
    xfree (scb->name);

  if (scb_base == scb)
    scb_base = scb_base->next;
  else
    for (tmp_scb = scb_base; tmp_scb; tmp_scb = tmp_scb->next)
      {
	if (tmp_scb->next != scb)
	  continue;

	tmp_scb->next = tmp_scb->next->next;
	break;
      }

  xfree (scb);
}

void
serial_close (struct serial *scb)
{
  do_serial_close (scb, 1);
}

void
serial_un_fdopen (struct serial *scb)
{
  do_serial_close (scb, 0);
}

int
serial_readchar (struct serial *scb, int timeout)
{
  int ch;

  /* FIXME: cagney/1999-10-11: Don't enable this check until the ASYNC
     code is finished. */
  if (0 && serial_is_async_p (scb) && timeout < 0)
    internal_error (__FILE__, __LINE__,
		    "serial_readchar: blocking read in async mode");

  ch = scb->ops->readchar (scb, timeout);
  if (serial_logfp != NULL)
    {
      serial_logchar (serial_logfp, 'r', ch, timeout);

      /* Make sure that the log file is as up-to-date as possible,
         in case we are getting ready to dump core or something. */
      gdb_flush (serial_logfp);
    }
  if (serial_debug_p (scb))
    {
      fprintf_unfiltered (gdb_stdlog, "[");
      serial_logchar (gdb_stdlog, 'r', ch, timeout);
      fprintf_unfiltered (gdb_stdlog, "]");
      gdb_flush (gdb_stdlog);
    }

  return (ch);
}

int
serial_write (struct serial *scb, const char *str, int len)
{
  if (serial_logfp != NULL)
    {
      int count;

      for (count = 0; count < len; count++)
	serial_logchar (serial_logfp, 'w', str[count] & 0xff, 0);

      /* Make sure that the log file is as up-to-date as possible,
         in case we are getting ready to dump core or something. */
      gdb_flush (serial_logfp);
    }

  return (scb->ops->write (scb, str, len));
}

void
serial_printf (struct serial *desc, const char *format,...)
{
  va_list args;
  char *buf;
  va_start (args, format);

  buf = xstrvprintf (format, args);
  serial_write (desc, buf, strlen (buf));

  xfree (buf);
  va_end (args);
}

int
serial_drain_output (struct serial *scb)
{
  return scb->ops->drain_output (scb);
}

int
serial_flush_output (struct serial *scb)
{
  return scb->ops->flush_output (scb);
}

int
serial_flush_input (struct serial *scb)
{
  return scb->ops->flush_input (scb);
}

int
serial_send_break (struct serial *scb)
{
  if (serial_logfp != NULL)
    serial_logchar (serial_logfp, 'w', SERIAL_BREAK, 0);

  return (scb->ops->send_break (scb));
}

void
serial_raw (struct serial *scb)
{
  scb->ops->go_raw (scb);
}

serial_ttystate
serial_get_tty_state (struct serial *scb)
{
  return scb->ops->get_tty_state (scb);
}

int
serial_set_tty_state (struct serial *scb, serial_ttystate ttystate)
{
  return scb->ops->set_tty_state (scb, ttystate);
}

void
serial_print_tty_state (struct serial *scb,
			serial_ttystate ttystate,
			struct ui_file *stream)
{
  scb->ops->print_tty_state (scb, ttystate, stream);
}

int
serial_noflush_set_tty_state (struct serial *scb,
			      serial_ttystate new_ttystate,
			      serial_ttystate old_ttystate)
{
  return scb->ops->noflush_set_tty_state (scb, new_ttystate, old_ttystate);
}

int
serial_setbaudrate (struct serial *scb, int rate)
{
  return scb->ops->setbaudrate (scb, rate);
}

int
serial_setstopbits (struct serial *scb, int num)
{
  return scb->ops->setstopbits (scb, num);
}

int
serial_can_async_p (struct serial *scb)
{
  return (scb->ops->async != NULL);
}

int
serial_is_async_p (struct serial *scb)
{
  return (scb->ops->async != NULL) && (scb->async_handler != NULL);
}

void
serial_async (struct serial *scb,
	      serial_event_ftype *handler,
	      void *context)
{
  /* Only change mode if there is a need. */
  if ((scb->async_handler == NULL)
      != (handler == NULL))
    scb->ops->async (scb, handler != NULL);
  scb->async_handler = handler;
  scb->async_context = context;
}

int
deprecated_serial_fd (struct serial *scb)
{
  /* FIXME: should this output a warning that deprecated code is being
     called? */
  if (scb->fd < 0)
    {
      internal_error (__FILE__, __LINE__,
		      "serial: FD not valid");
    }
  return scb->fd; /* sigh */
}

void
serial_debug (struct serial *scb, int debug_p)
{
  scb->debug_p = debug_p;
}

int
serial_debug_p (struct serial *scb)
{
  return scb->debug_p || global_serial_debug_p;
}


#if 0
/* The connect command is #if 0 because I hadn't thought of an elegant
   way to wait for I/O on two `struct serial *'s simultaneously.  Two
   solutions came to mind:

   1) Fork, and have have one fork handle the to user direction,
   and have the other hand the to target direction.  This
   obviously won't cut it for MSDOS.

   2) Use something like select.  This assumes that stdin and
   the target side can both be waited on via the same
   mechanism.  This may not be true for DOS, if GDB is
   talking to the target via a TCP socket.
   -grossman, 8 Jun 93 */

/* Connect the user directly to the remote system.  This command acts just like
   the 'cu' or 'tip' command.  Use <CR>~. or <CR>~^D to break out.  */

static struct serial *tty_desc;	/* Controlling terminal */

static void
cleanup_tty (serial_ttystate ttystate)
{
  printf_unfiltered ("\r\n[Exiting connect mode]\r\n");
  serial_set_tty_state (tty_desc, ttystate);
  xfree (ttystate);
  serial_close (tty_desc);
}

static void
connect_command (char *args, int fromtty)
{
  int c;
  char cur_esc = 0;
  serial_ttystate ttystate;
  struct serial *port_desc;		/* TTY port */

  dont_repeat ();

  if (args)
    fprintf_unfiltered (gdb_stderr, "This command takes no args.  They have been ignored.\n");

  printf_unfiltered ("[Entering connect mode.  Use ~. or ~^D to escape]\n");

  tty_desc = serial_fdopen (0);
  port_desc = last_serial_opened;

  ttystate = serial_get_tty_state (tty_desc);

  serial_raw (tty_desc);
  serial_raw (port_desc);

  make_cleanup (cleanup_tty, ttystate);

  while (1)
    {
      int mask;

      mask = serial_wait_2 (tty_desc, port_desc, -1);

      if (mask & 2)
	{			/* tty input */
	  char cx;

	  while (1)
	    {
	      c = serial_readchar (tty_desc, 0);

	      if (c == SERIAL_TIMEOUT)
		break;

	      if (c < 0)
		perror_with_name ("connect");

	      cx = c;
	      serial_write (port_desc, &cx, 1);

	      switch (cur_esc)
		{
		case 0:
		  if (c == '\r')
		    cur_esc = c;
		  break;
		case '\r':
		  if (c == '~')
		    cur_esc = c;
		  else
		    cur_esc = 0;
		  break;
		case '~':
		  if (c == '.' || c == '\004')
		    return;
		  else
		    cur_esc = 0;
		}
	    }
	}

      if (mask & 1)
	{			/* Port input */
	  char cx;

	  while (1)
	    {
	      c = serial_readchar (port_desc, 0);

	      if (c == SERIAL_TIMEOUT)
		break;

	      if (c < 0)
		perror_with_name ("connect");

	      cx = c;

	      serial_write (tty_desc, &cx, 1);
	    }
	}
    }
}
#endif /* 0 */

/* Serial set/show framework.  */

static struct cmd_list_element *serial_set_cmdlist;
static struct cmd_list_element *serial_show_cmdlist;

static void
serial_set_cmd (char *args, int from_tty)
{
  printf_unfiltered ("\"set serial\" must be followed by the name of a command.\n");
  help_list (serial_set_cmdlist, "set serial ", -1, gdb_stdout);
}

static void
serial_show_cmd (char *args, int from_tty)
{
  cmd_show_list (serial_show_cmdlist, from_tty, "");
}


void
_initialize_serial (void)
{
#if 0
  add_com ("connect", class_obscure, connect_command,
	   "Connect the terminal directly up to the command monitor.\n\
Use <CR>~. or <CR>~^D to break out.");
#endif /* 0 */

  add_prefix_cmd ("serial", class_maintenance, serial_set_cmd, "\
Set default serial/parallel port configuration.",
		  &serial_set_cmdlist, "set serial ",
		  0/*allow-unknown*/,
		  &setlist);

  add_prefix_cmd ("serial", class_maintenance, serial_show_cmd, "\
Show default serial/parallel port configuration.",
		  &serial_show_cmdlist, "show serial ",
		  0/*allow-unknown*/,
		  &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("remotelogfile", no_class,
		  var_filename, (char *) &serial_logfile,
		  "Set filename for remote session recording.\n\
This file is used to record the remote session for future playback\n\
by gdbserver.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_enum_cmd ("remotelogbase", no_class,
		       logbase_enums, &serial_logbase,
		       "Set numerical base for remote session logging",
		       &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("serial",
		  class_maintenance,
		  var_zinteger,
		  (char *)&global_serial_debug_p,
		  "Set serial debugging.\n\
When non-zero, serial port debugging is enabled.", &setdebuglist),
     &showdebuglist);
}
@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@d397 1
a397 1
  xvasprintf (&buf, format, args);
d689 1
a689 1
  add_show_from_set
d698 1
a698 1
  add_show_from_set
d705 6
a710 5
  add_show_from_set (add_set_cmd ("serial",
				  class_maintenance,
				  var_zinteger,
				  (char *)&global_serial_debug_p,
				  "Set serial debugging.\n\
d712 1
a712 1
		     &showdebuglist);
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@a1 1
   Copyright 1992, 1993, 1996 Free Software Foundation, Inc.
d3 2
a4 1
This file is part of GDB.
d6 16
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d29 6
d41 1
a41 1
static serial_t last_serial_opened = NULL;
d45 1
a45 1
static serial_t scb_base;
d51 1
a51 9
static FILE *serial_logfp = NULL;

static struct serial_ops *serial_interface_lookup PARAMS ((char *));
static void serial_logchar PARAMS ((int ch, int timeout));
static char logbase_hex[] = "hex";
static char logbase_octal[] = "octal";
static char logbase_ascii[] = "ascii";
static char *logbase_enums[] = {logbase_hex, logbase_octal, logbase_ascii, NULL};
static char *serial_logbase = logbase_ascii;
d53 8
a61 2
static int serial_reading = 0;
static int serial_writing = 0;
d63 1
a63 6
void
serial_log_command (cmd)
     const char *cmd;
{
  if (!serial_logfp)
    return;
d65 1
a65 11
  if (serial_reading || serial_writing)
    {
      fputc_unfiltered ('\n', serial_logfp);
      serial_reading = 0;
      serial_writing = 0;
    }
  fprintf_unfiltered (serial_logfp, "c %s\n", cmd);
  /* Make sure that the log file is as up-to-date as possible,
     in case we are getting ready to dump core or something. */
  fflush (serial_logfp);
}
d72 1
a72 3
serial_logchar (ch, timeout)
     int ch;
     int timeout;
d74 6
d81 1
a81 1
    fputc_unfiltered (' ', serial_logfp);
d86 1
a86 1
      fprintf_unfiltered (serial_logfp, "<Timeout: %d seconds>", timeout);
d89 1
a89 1
      fprintf_unfiltered (serial_logfp, "<Error: %s>", safe_strerror (errno));
d92 1
a92 1
      fputs_unfiltered ("<Eof>", serial_logfp);
d95 1
a95 1
      fputs_unfiltered ("<Break>", serial_logfp);
d99 1
a99 1
	fprintf_unfiltered (serial_logfp, "%02x", ch & 0xff);
d101 1
a101 1
	fprintf_unfiltered (serial_logfp, "%03o", ch & 0xff);
d105 24
a128 8
	  case '\\':	fputs_unfiltered ("\\\\", serial_logfp); break;	
	  case '\b':	fputs_unfiltered ("\\b", serial_logfp); break;	
	  case '\f':	fputs_unfiltered ("\\f", serial_logfp); break;	
	  case '\n':	fputs_unfiltered ("\\n", serial_logfp); break;	
	  case '\r':	fputs_unfiltered ("\\r", serial_logfp); break;	
	  case '\t':	fputs_unfiltered ("\\t", serial_logfp); break;	
	  case '\v':	fputs_unfiltered ("\\v", serial_logfp); break;	
	  default:	fprintf_unfiltered (serial_logfp, isprint (ch) ? "%c" : "\\x%02x", ch & 0xFF); break;
d130 1
a130 1
	}
d133 2
a134 5
int
serial_write (scb, str, len)
     serial_t scb;
     const char *str;
     int len;
d136 2
a137 1
  int count;
d139 1
a139 22
  if (serial_logfp != NULL)
    {
      if (serial_reading)
	{
	  fputc_unfiltered ('\n', serial_logfp);
	  serial_reading = 0;
	}
      if (!serial_writing)
	{
	  fputs_unfiltered ("w ", serial_logfp);
	  serial_writing = 1;
	}
      for (count = 0; count < len; count++)
	{
	  serial_logchar (str[count] & 0xff, 0);
	}
      /* Make sure that the log file is as up-to-date as possible,
	 in case we are getting ready to dump core or something. */
      fflush (serial_logfp);
    }
  return (scb -> ops -> write (scb, str, len));
}
d141 2
a142 6
int
serial_readchar (scb, timeout)
     serial_t scb;
     int timeout;
{
  int ch;
d144 3
a146 43
  ch = scb -> ops -> readchar (scb, timeout);
  if (serial_logfp != NULL)
    {
      if (serial_writing)
	{
	  fputc_unfiltered ('\n', serial_logfp);
	  serial_writing = 0;
	}
      if (!serial_reading)
	{
	  fputs_unfiltered ("r ", serial_logfp);
	  serial_reading = 1;
	}
      serial_logchar (ch, timeout);
      /* Make sure that the log file is as up-to-date as possible,
	 in case we are getting ready to dump core or something. */
      fflush (serial_logfp);
    }
  return (ch);
}

int
serial_send_break (scb)
     serial_t scb;
{
  if (serial_logfp != NULL)
    {
      if (serial_reading)
	{
	  fputc_unfiltered ('\n', serial_logfp);
	  serial_reading = 0;
	}
      if (!serial_writing)
	{
	  fputs_unfiltered ("w ", serial_logfp);
	  serial_writing = 1;
	}
      serial_logchar (SERIAL_BREAK, 0);
      /* Make sure that the log file is as up-to-date as possible,
	 in case we are getting ready to dump core or something. */
      fflush (serial_logfp);
    }
  return (scb -> ops -> send_break (scb));
d149 1
d151 1
a151 2
serial_interface_lookup (name)
     char *name;
d163 1
a163 2
serial_add_interface(optable)
     struct serial_ops *optable;
d171 2
a172 3
serial_t
serial_open (name)
     const char *name;
d174 1
a174 1
  serial_t scb;
d176 1
d191 5
d202 1
a202 1
  scb = (serial_t)xmalloc (sizeof (struct _serial_t));
d209 1
a209 1
  if (scb->ops->open(scb, name))
d211 1
a211 1
      free (scb);
d215 1
a215 1
  scb->name = strsave (name);
d218 4
d228 1
a228 1
      serial_logfp = fopen (serial_logfile, "w");
d230 1
a230 3
	{
	  perror_with_name (serial_logfile);
	}
d236 2
a237 3
serial_t
serial_fdopen (fd)
     const int fd;
d239 1
a239 1
  serial_t scb;
d254 1
a254 1
  scb = (serial_t)xmalloc (sizeof (struct _serial_t));
d266 4
d277 2
a278 4
void
serial_close(scb, really_close)
     serial_t scb;
     int really_close;
d280 1
a280 1
  serial_t tmp_scb;
d286 5
a290 7
      if (serial_reading || serial_writing)
	{
	  fputc_unfiltered ('\n', serial_logfp);
	  serial_reading = 0;
	  serial_writing = 0;
	}
      fclose (serial_logfp);
d304 4
d312 1
a312 1
    free (scb->name);
d326 62
a387 1
  free(scb);
d390 138
d529 13
a541 15
/*
The connect command is #if 0 because I hadn't thought of an elegant
way to wait for I/O on two serial_t's simultaneously.  Two solutions
came to mind:

	1) Fork, and have have one fork handle the to user direction,
	   and have the other hand the to target direction.  This
	   obviously won't cut it for MSDOS.

	2) Use something like select.  This assumes that stdin and
	   the target side can both be waited on via the same
	   mechanism.  This may not be true for DOS, if GDB is
	   talking to the target via a TCP socket.
-grossman, 8 Jun 93
*/
d546 1
a546 1
static serial_t tty_desc;		/* Controlling terminal */
d549 1
a549 2
cleanup_tty(ttystate)
     serial_ttystate ttystate;
d552 3
a554 3
  SERIAL_SET_TTY_STATE (tty_desc, ttystate);
  free (ttystate);
  SERIAL_CLOSE (tty_desc);
d558 1
a558 3
connect_command (args, fromtty)
     char	*args;
     int	fromtty;
d563 1
a563 1
  serial_t port_desc;		/* TTY port */
d565 1
a565 1
  dont_repeat();
d568 1
a568 3
    fprintf_unfiltered(gdb_stderr, "This command takes no args.  They have been ignored.\n");
	
  printf_unfiltered("[Entering connect mode.  Use ~. or ~^D to escape]\n");
d570 3
a572 1
  tty_desc = SERIAL_FDOPEN (0);
d575 1
a575 1
  ttystate = SERIAL_GET_TTY_STATE (tty_desc);
d577 2
a578 2
  SERIAL_RAW (tty_desc);
  SERIAL_RAW (port_desc);
d586 1
a586 1
      mask = SERIAL_WAIT_2 (tty_desc, port_desc, -1);
d594 1
a594 1
	      c = SERIAL_READCHAR(tty_desc, 0);
d597 1
a597 1
		  break;
d600 1
a600 1
		perror_with_name("connect");
d603 1
a603 1
	      SERIAL_WRITE(port_desc, &cx, 1);
d632 1
a632 1
	      c = SERIAL_READCHAR(port_desc, 0);
d635 1
a635 1
		  break;
d638 1
a638 1
		perror_with_name("connect");
d642 1
a642 1
	      SERIAL_WRITE(tty_desc, &cx, 1);
d649 7
a655 8
/* VARARGS */
void
#ifdef ANSI_PROTOTYPES
serial_printf (serial_t desc, const char *format, ...)
#else
serial_printf (va_alist)
     va_dcl
#endif
d657 3
a659 12
  va_list args;
  char *buf;
#ifdef ANSI_PROTOTYPES
  va_start (args, format);
#else
  serial_t desc;
  char *format;

  va_start (args);
  desc = va_arg (args, serial_t);
  format = va_arg (args, char *);
#endif
d661 5
a665 2
  vasprintf (&buf, format, args);
  SERIAL_WRITE (desc, buf, strlen (buf));
a666 3
  free (buf);
  va_end (args);
}
d669 1
a669 1
_initialize_serial ()
a670 2
  struct cmd_list_element *cmd;

d677 16
a692 3
  add_show_from_set (add_set_cmd ("remotelogfile", no_class,
				  var_filename, (char *)&serial_logfile,
				  "Set filename for remote session recording.\n\
d694 18
a711 9
by gdbserver.", &setlist),
		     &showlist);

  add_show_from_set (add_set_enum_cmd ("remotelogbase", no_class,
				       logbase_enums,
				       (char *)&serial_logbase,
				       "Set ...",
				       &setlist),
			   &showlist);
@


1.1
log
@file serial.c was initially added on branch CYGNUS.
@
text
@d1 554
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 712
/* Generic serial interface routines

   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include <ctype.h>
#include "serial.h"
#include "gdb_string.h"
#include "gdbcmd.h"

extern void _initialize_serial (void);

/* Is serial being debugged? */

static int global_serial_debug_p;

/* Linked list of serial I/O handlers */

static struct serial_ops *serial_ops_list = NULL;

/* This is the last serial stream opened.  Used by connect command. */

static struct serial *last_serial_opened = NULL;

/* Pointer to list of scb's. */

static struct serial *scb_base;

/* Non-NULL gives filename which contains a recording of the remote session,
   suitable for playback by gdbserver. */

static char *serial_logfile = NULL;
static struct ui_file *serial_logfp = NULL;

static struct serial_ops *serial_interface_lookup (char *);
static void serial_logchar (struct ui_file *stream, int ch_type, int ch, int timeout);
static const char logbase_hex[] = "hex";
static const char logbase_octal[] = "octal";
static const char logbase_ascii[] = "ascii";
static const char *logbase_enums[] =
{logbase_hex, logbase_octal, logbase_ascii, NULL};
static const char *serial_logbase = logbase_ascii;


static int serial_current_type = 0;

/* Log char CH of type CHTYPE, with TIMEOUT */

/* Define bogus char to represent a BREAK.  Should be careful to choose a value
   that can't be confused with a normal char, or an error code.  */
#define SERIAL_BREAK 1235

static void
serial_logchar (struct ui_file *stream, int ch_type, int ch, int timeout)
{
  if (ch_type != serial_current_type)
    {
      fprintf_unfiltered (stream, "\n%c ", ch_type);
      serial_current_type = ch_type;
    }

  if (serial_logbase != logbase_ascii)
    fputc_unfiltered (' ', stream);

  switch (ch)
    {
    case SERIAL_TIMEOUT:
      fprintf_unfiltered (stream, "<Timeout: %d seconds>", timeout);
      return;
    case SERIAL_ERROR:
      fprintf_unfiltered (stream, "<Error: %s>", safe_strerror (errno));
      return;
    case SERIAL_EOF:
      fputs_unfiltered ("<Eof>", stream);
      return;
    case SERIAL_BREAK:
      fputs_unfiltered ("<Break>", stream);
      return;
    default:
      if (serial_logbase == logbase_hex)
	fprintf_unfiltered (stream, "%02x", ch & 0xff);
      else if (serial_logbase == logbase_octal)
	fprintf_unfiltered (stream, "%03o", ch & 0xff);
      else
	switch (ch)
	  {
	  case '\\':
	    fputs_unfiltered ("\\\\", stream);
	    break;
	  case '\b':
	    fputs_unfiltered ("\\b", stream);
	    break;
	  case '\f':
	    fputs_unfiltered ("\\f", stream);
	    break;
	  case '\n':
	    fputs_unfiltered ("\\n", stream);
	    break;
	  case '\r':
	    fputs_unfiltered ("\\r", stream);
	    break;
	  case '\t':
	    fputs_unfiltered ("\\t", stream);
	    break;
	  case '\v':
	    fputs_unfiltered ("\\v", stream);
	    break;
	  default:
	    fprintf_unfiltered (stream, isprint (ch) ? "%c" : "\\x%02x", ch & 0xFF);
	    break;
	  }
    }
}

void
serial_log_command (const char *cmd)
{
  if (!serial_logfp)
    return;

  serial_current_type = 'c';

  fputs_unfiltered ("\nc ", serial_logfp);
  fputs_unfiltered (cmd, serial_logfp);

  /* Make sure that the log file is as up-to-date as possible,
     in case we are getting ready to dump core or something. */
  gdb_flush (serial_logfp);
}


static struct serial_ops *
serial_interface_lookup (char *name)
{
  struct serial_ops *ops;

  for (ops = serial_ops_list; ops; ops = ops->next)
    if (strcmp (name, ops->name) == 0)
      return ops;

  return NULL;
}

void
serial_add_interface (struct serial_ops *optable)
{
  optable->next = serial_ops_list;
  serial_ops_list = optable;
}

/* Open up a device or a network socket, depending upon the syntax of NAME. */

struct serial *
serial_open (const char *name)
{
  struct serial *scb;
  struct serial_ops *ops;
  const char *open_name = name;

  for (scb = scb_base; scb; scb = scb->next)
    if (scb->name && strcmp (scb->name, name) == 0)
      {
	scb->refcnt++;
	return scb;
      }

  if (strcmp (name, "pc") == 0)
    ops = serial_interface_lookup ("pc");
  else if (strchr (name, ':'))
    ops = serial_interface_lookup ("tcp");
  else if (strncmp (name, "lpt", 3) == 0)
    ops = serial_interface_lookup ("parallel");
  else if (strncmp (name, "|", 1) == 0)
    {
      ops = serial_interface_lookup ("pipe");
      open_name = name + 1; /* discard ``|'' */
    }
  else
    ops = serial_interface_lookup ("hardwire");

  if (!ops)
    return NULL;

  scb = XMALLOC (struct serial);

  scb->ops = ops;

  scb->bufcnt = 0;
  scb->bufp = scb->buf;

  if (scb->ops->open (scb, open_name))
    {
      xfree (scb);
      return NULL;
    }

  scb->name = xstrdup (name);
  scb->next = scb_base;
  scb->refcnt = 1;
  scb->debug_p = 0;
  scb->async_state = 0;
  scb->async_handler = NULL;
  scb->async_context = NULL;
  scb_base = scb;

  last_serial_opened = scb;

  if (serial_logfile != NULL)
    {
      serial_logfp = gdb_fopen (serial_logfile, "w");
      if (serial_logfp == NULL)
	perror_with_name (serial_logfile);
    }

  return scb;
}

struct serial *
serial_fdopen (const int fd)
{
  struct serial *scb;
  struct serial_ops *ops;

  for (scb = scb_base; scb; scb = scb->next)
    if (scb->fd == fd)
      {
	scb->refcnt++;
	return scb;
      }

  ops = serial_interface_lookup ("hardwire");

  if (!ops)
    return NULL;

  scb = XMALLOC (struct serial);

  scb->ops = ops;

  scb->bufcnt = 0;
  scb->bufp = scb->buf;

  scb->fd = fd;

  scb->name = NULL;
  scb->next = scb_base;
  scb->refcnt = 1;
  scb->debug_p = 0;
  scb->async_state = 0;
  scb->async_handler = NULL;
  scb->async_context = NULL;
  scb_base = scb;

  last_serial_opened = scb;

  return scb;
}

static void
do_serial_close (struct serial *scb, int really_close)
{
  struct serial *tmp_scb;

  last_serial_opened = NULL;

  if (serial_logfp)
    {
      fputs_unfiltered ("\nEnd of log\n", serial_logfp);
      serial_current_type = 0;

      /* XXX - What if serial_logfp == gdb_stdout or gdb_stderr? */
      ui_file_delete (serial_logfp);
      serial_logfp = NULL;
    }

/* This is bogus.  It's not our fault if you pass us a bad scb...!  Rob, you
   should fix your code instead.  */

  if (!scb)
    return;

  scb->refcnt--;
  if (scb->refcnt > 0)
    return;

  /* ensure that the FD has been taken out of async mode */
  if (scb->async_handler != NULL)
    serial_async (scb, NULL, NULL);

  if (really_close)
    scb->ops->close (scb);

  if (scb->name)
    xfree (scb->name);

  if (scb_base == scb)
    scb_base = scb_base->next;
  else
    for (tmp_scb = scb_base; tmp_scb; tmp_scb = tmp_scb->next)
      {
	if (tmp_scb->next != scb)
	  continue;

	tmp_scb->next = tmp_scb->next->next;
	break;
      }

  xfree (scb);
}

void
serial_close (struct serial *scb)
{
  do_serial_close (scb, 1);
}

void
serial_un_fdopen (struct serial *scb)
{
  do_serial_close (scb, 0);
}

int
serial_readchar (struct serial *scb, int timeout)
{
  int ch;

  /* FIXME: cagney/1999-10-11: Don't enable this check until the ASYNC
     code is finished. */
  if (0 && serial_is_async_p (scb) && timeout < 0)
    internal_error (__FILE__, __LINE__,
		    "serial_readchar: blocking read in async mode");

  ch = scb->ops->readchar (scb, timeout);
  if (serial_logfp != NULL)
    {
      serial_logchar (serial_logfp, 'r', ch, timeout);

      /* Make sure that the log file is as up-to-date as possible,
         in case we are getting ready to dump core or something. */
      gdb_flush (serial_logfp);
    }
  if (serial_debug_p (scb))
    {
      fprintf_unfiltered (gdb_stdlog, "[");
      serial_logchar (gdb_stdlog, 'r', ch, timeout);
      fprintf_unfiltered (gdb_stdlog, "]");
      gdb_flush (gdb_stdlog);
    }

  return (ch);
}

int
serial_write (struct serial *scb, const char *str, int len)
{
  if (serial_logfp != NULL)
    {
      int count;

      for (count = 0; count < len; count++)
	serial_logchar (serial_logfp, 'w', str[count] & 0xff, 0);

      /* Make sure that the log file is as up-to-date as possible,
         in case we are getting ready to dump core or something. */
      gdb_flush (serial_logfp);
    }

  return (scb->ops->write (scb, str, len));
}

void
serial_printf (struct serial *desc, const char *format,...)
{
  va_list args;
  char *buf;
  va_start (args, format);

  xvasprintf (&buf, format, args);
  serial_write (desc, buf, strlen (buf));

  xfree (buf);
  va_end (args);
}

int
serial_drain_output (struct serial *scb)
{
  return scb->ops->drain_output (scb);
}

int
serial_flush_output (struct serial *scb)
{
  return scb->ops->flush_output (scb);
}

int
serial_flush_input (struct serial *scb)
{
  return scb->ops->flush_input (scb);
}

int
serial_send_break (struct serial *scb)
{
  if (serial_logfp != NULL)
    serial_logchar (serial_logfp, 'w', SERIAL_BREAK, 0);

  return (scb->ops->send_break (scb));
}

void
serial_raw (struct serial *scb)
{
  scb->ops->go_raw (scb);
}

serial_ttystate
serial_get_tty_state (struct serial *scb)
{
  return scb->ops->get_tty_state (scb);
}

int
serial_set_tty_state (struct serial *scb, serial_ttystate ttystate)
{
  return scb->ops->set_tty_state (scb, ttystate);
}

void
serial_print_tty_state (struct serial *scb,
			serial_ttystate ttystate,
			struct ui_file *stream)
{
  scb->ops->print_tty_state (scb, ttystate, stream);
}

int
serial_noflush_set_tty_state (struct serial *scb,
			      serial_ttystate new_ttystate,
			      serial_ttystate old_ttystate)
{
  return scb->ops->noflush_set_tty_state (scb, new_ttystate, old_ttystate);
}

int
serial_setbaudrate (struct serial *scb, int rate)
{
  return scb->ops->setbaudrate (scb, rate);
}

int
serial_setstopbits (struct serial *scb, int num)
{
  return scb->ops->setstopbits (scb, num);
}

int
serial_can_async_p (struct serial *scb)
{
  return (scb->ops->async != NULL);
}

int
serial_is_async_p (struct serial *scb)
{
  return (scb->ops->async != NULL) && (scb->async_handler != NULL);
}

void
serial_async (struct serial *scb,
	      serial_event_ftype *handler,
	      void *context)
{
  /* Only change mode if there is a need. */
  if ((scb->async_handler == NULL)
      != (handler == NULL))
    scb->ops->async (scb, handler != NULL);
  scb->async_handler = handler;
  scb->async_context = context;
}

int
deprecated_serial_fd (struct serial *scb)
{
  /* FIXME: should this output a warning that deprecated code is being
     called? */
  if (scb->fd < 0)
    {
      internal_error (__FILE__, __LINE__,
		      "serial: FD not valid");
    }
  return scb->fd; /* sigh */
}

void
serial_debug (struct serial *scb, int debug_p)
{
  scb->debug_p = debug_p;
}

int
serial_debug_p (struct serial *scb)
{
  return scb->debug_p || global_serial_debug_p;
}


#if 0
/* The connect command is #if 0 because I hadn't thought of an elegant
   way to wait for I/O on two `struct serial *'s simultaneously.  Two
   solutions came to mind:

   1) Fork, and have have one fork handle the to user direction,
   and have the other hand the to target direction.  This
   obviously won't cut it for MSDOS.

   2) Use something like select.  This assumes that stdin and
   the target side can both be waited on via the same
   mechanism.  This may not be true for DOS, if GDB is
   talking to the target via a TCP socket.
   -grossman, 8 Jun 93 */

/* Connect the user directly to the remote system.  This command acts just like
   the 'cu' or 'tip' command.  Use <CR>~. or <CR>~^D to break out.  */

static struct serial *tty_desc;	/* Controlling terminal */

static void
cleanup_tty (serial_ttystate ttystate)
{
  printf_unfiltered ("\r\n[Exiting connect mode]\r\n");
  serial_set_tty_state (tty_desc, ttystate);
  xfree (ttystate);
  serial_close (tty_desc);
}

static void
connect_command (char *args, int fromtty)
{
  int c;
  char cur_esc = 0;
  serial_ttystate ttystate;
  struct serial *port_desc;		/* TTY port */

  dont_repeat ();

  if (args)
    fprintf_unfiltered (gdb_stderr, "This command takes no args.  They have been ignored.\n");

  printf_unfiltered ("[Entering connect mode.  Use ~. or ~^D to escape]\n");

  tty_desc = serial_fdopen (0);
  port_desc = last_serial_opened;

  ttystate = serial_get_tty_state (tty_desc);

  serial_raw (tty_desc);
  serial_raw (port_desc);

  make_cleanup (cleanup_tty, ttystate);

  while (1)
    {
      int mask;

      mask = serial_wait_2 (tty_desc, port_desc, -1);

      if (mask & 2)
	{			/* tty input */
	  char cx;

	  while (1)
	    {
	      c = serial_readchar (tty_desc, 0);

	      if (c == SERIAL_TIMEOUT)
		break;

	      if (c < 0)
		perror_with_name ("connect");

	      cx = c;
	      serial_write (port_desc, &cx, 1);

	      switch (cur_esc)
		{
		case 0:
		  if (c == '\r')
		    cur_esc = c;
		  break;
		case '\r':
		  if (c == '~')
		    cur_esc = c;
		  else
		    cur_esc = 0;
		  break;
		case '~':
		  if (c == '.' || c == '\004')
		    return;
		  else
		    cur_esc = 0;
		}
	    }
	}

      if (mask & 1)
	{			/* Port input */
	  char cx;

	  while (1)
	    {
	      c = serial_readchar (port_desc, 0);

	      if (c == SERIAL_TIMEOUT)
		break;

	      if (c < 0)
		perror_with_name ("connect");

	      cx = c;

	      serial_write (tty_desc, &cx, 1);
	    }
	}
    }
}
#endif /* 0 */

/* Serial set/show framework.  */

static struct cmd_list_element *serial_set_cmdlist;
static struct cmd_list_element *serial_show_cmdlist;

static void
serial_set_cmd (char *args, int from_tty)
{
  printf_unfiltered ("\"set serial\" must be followed by the name of a command.\n");
  help_list (serial_set_cmdlist, "set serial ", -1, gdb_stdout);
}

static void
serial_show_cmd (char *args, int from_tty)
{
  cmd_show_list (serial_show_cmdlist, from_tty, "");
}


void
_initialize_serial (void)
{
#if 0
  add_com ("connect", class_obscure, connect_command,
	   "Connect the terminal directly up to the command monitor.\n\
Use <CR>~. or <CR>~^D to break out.");
#endif /* 0 */

  add_prefix_cmd ("serial", class_maintenance, serial_set_cmd, "\
Set default serial/parallel port configuration.",
		  &serial_set_cmdlist, "set serial ",
		  0/*allow-unknown*/,
		  &setlist);

  add_prefix_cmd ("serial", class_maintenance, serial_show_cmd, "\
Show default serial/parallel port configuration.",
		  &serial_show_cmdlist, "show serial ",
		  0/*allow-unknown*/,
		  &showlist);

  add_show_from_set
    (add_set_cmd ("remotelogfile", no_class,
		  var_filename, (char *) &serial_logfile,
		  "Set filename for remote session recording.\n\
This file is used to record the remote session for future playback\n\
by gdbserver.",
		  &setlist),
     &showlist);

  add_show_from_set
    (add_set_enum_cmd ("remotelogbase", no_class,
		       logbase_enums, &serial_logbase,
		       "Set numerical base for remote session logging",
		       &setlist),
     &showlist);

  add_show_from_set (add_set_cmd ("serial",
				  class_maintenance,
				  var_zinteger,
				  (char *)&global_serial_debug_p,
				  "Set serial debugging.\n\
When non-zero, serial port debugging is enabled.", &setdebuglist),
		     &showdebuglist);
}
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d397 1
a397 1
  buf = xstrvprintf (format, args);
d689 1
a689 1
  deprecated_add_show_from_set
d698 1
a698 1
  deprecated_add_show_from_set
d705 5
a709 6
  deprecated_add_show_from_set
    (add_set_cmd ("serial",
		  class_maintenance,
		  var_zinteger,
		  (char *)&global_serial_debug_p,
		  "Set serial debugging.\n\
d711 1
a711 1
     &showdebuglist);
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 554
/* Generic serial interface routines
   Copyright 1992, 1993, 1996 Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include <ctype.h>
#include "serial.h"
#include "gdb_string.h"
#include "gdbcmd.h"

/* Linked list of serial I/O handlers */

static struct serial_ops *serial_ops_list = NULL;

/* This is the last serial stream opened.  Used by connect command. */

static serial_t last_serial_opened = NULL;

/* Pointer to list of scb's. */

static serial_t scb_base;

/* Non-NULL gives filename which contains a recording of the remote session,
   suitable for playback by gdbserver. */

static char *serial_logfile = NULL;
static FILE *serial_logfp = NULL;

static struct serial_ops *serial_interface_lookup PARAMS ((char *));
static void serial_logchar PARAMS ((int ch, int timeout));
static char logbase_hex[] = "hex";
static char logbase_octal[] = "octal";
static char logbase_ascii[] = "ascii";
static char *logbase_enums[] = {logbase_hex, logbase_octal, logbase_ascii, NULL};
static char *serial_logbase = logbase_ascii;


static int serial_reading = 0;
static int serial_writing = 0;

void
serial_log_command (cmd)
     const char *cmd;
{
  if (!serial_logfp)
    return;

  if (serial_reading || serial_writing)
    {
      fputc_unfiltered ('\n', serial_logfp);
      serial_reading = 0;
      serial_writing = 0;
    }
  fprintf_unfiltered (serial_logfp, "c %s\n", cmd);
  /* Make sure that the log file is as up-to-date as possible,
     in case we are getting ready to dump core or something. */
  fflush (serial_logfp);
}

/* Define bogus char to represent a BREAK.  Should be careful to choose a value
   that can't be confused with a normal char, or an error code.  */
#define SERIAL_BREAK 1235

static void
serial_logchar (ch, timeout)
     int ch;
     int timeout;
{
  if (serial_logbase != logbase_ascii)
    fputc_unfiltered (' ', serial_logfp);

  switch (ch)
    {
    case SERIAL_TIMEOUT:
      fprintf_unfiltered (serial_logfp, "<Timeout: %d seconds>", timeout);
      return;
    case SERIAL_ERROR:
      fprintf_unfiltered (serial_logfp, "<Error: %s>", safe_strerror (errno));
      return;
    case SERIAL_EOF:
      fputs_unfiltered ("<Eof>", serial_logfp);
      return;
    case SERIAL_BREAK:
      fputs_unfiltered ("<Break>", serial_logfp);
      return;
    default:
      if (serial_logbase == logbase_hex)
	fprintf_unfiltered (serial_logfp, "%02x", ch & 0xff);
      else if (serial_logbase == logbase_octal)
	fprintf_unfiltered (serial_logfp, "%03o", ch & 0xff);
      else
	switch (ch)
	  {
	  case '\\':	fputs_unfiltered ("\\\\", serial_logfp); break;	
	  case '\b':	fputs_unfiltered ("\\b", serial_logfp); break;	
	  case '\f':	fputs_unfiltered ("\\f", serial_logfp); break;	
	  case '\n':	fputs_unfiltered ("\\n", serial_logfp); break;	
	  case '\r':	fputs_unfiltered ("\\r", serial_logfp); break;	
	  case '\t':	fputs_unfiltered ("\\t", serial_logfp); break;	
	  case '\v':	fputs_unfiltered ("\\v", serial_logfp); break;	
	  default:	fprintf_unfiltered (serial_logfp, isprint (ch) ? "%c" : "\\x%02x", ch & 0xFF); break;
	  }
	}
}

int
serial_write (scb, str, len)
     serial_t scb;
     const char *str;
     int len;
{
  int count;

  if (serial_logfp != NULL)
    {
      if (serial_reading)
	{
	  fputc_unfiltered ('\n', serial_logfp);
	  serial_reading = 0;
	}
      if (!serial_writing)
	{
	  fputs_unfiltered ("w ", serial_logfp);
	  serial_writing = 1;
	}
      for (count = 0; count < len; count++)
	{
	  serial_logchar (str[count] & 0xff, 0);
	}
      /* Make sure that the log file is as up-to-date as possible,
	 in case we are getting ready to dump core or something. */
      fflush (serial_logfp);
    }
  return (scb -> ops -> write (scb, str, len));
}

int
serial_readchar (scb, timeout)
     serial_t scb;
     int timeout;
{
  int ch;

  ch = scb -> ops -> readchar (scb, timeout);
  if (serial_logfp != NULL)
    {
      if (serial_writing)
	{
	  fputc_unfiltered ('\n', serial_logfp);
	  serial_writing = 0;
	}
      if (!serial_reading)
	{
	  fputs_unfiltered ("r ", serial_logfp);
	  serial_reading = 1;
	}
      serial_logchar (ch, timeout);
      /* Make sure that the log file is as up-to-date as possible,
	 in case we are getting ready to dump core or something. */
      fflush (serial_logfp);
    }
  return (ch);
}

int
serial_send_break (scb)
     serial_t scb;
{
  if (serial_logfp != NULL)
    {
      if (serial_reading)
	{
	  fputc_unfiltered ('\n', serial_logfp);
	  serial_reading = 0;
	}
      if (!serial_writing)
	{
	  fputs_unfiltered ("w ", serial_logfp);
	  serial_writing = 1;
	}
      serial_logchar (SERIAL_BREAK, 0);
      /* Make sure that the log file is as up-to-date as possible,
	 in case we are getting ready to dump core or something. */
      fflush (serial_logfp);
    }
  return (scb -> ops -> send_break (scb));
}

static struct serial_ops *
serial_interface_lookup (name)
     char *name;
{
  struct serial_ops *ops;

  for (ops = serial_ops_list; ops; ops = ops->next)
    if (strcmp (name, ops->name) == 0)
      return ops;

  return NULL;
}

void
serial_add_interface(optable)
     struct serial_ops *optable;
{
  optable->next = serial_ops_list;
  serial_ops_list = optable;
}

/* Open up a device or a network socket, depending upon the syntax of NAME. */

serial_t
serial_open (name)
     const char *name;
{
  serial_t scb;
  struct serial_ops *ops;

  for (scb = scb_base; scb; scb = scb->next)
    if (scb->name && strcmp (scb->name, name) == 0)
      {
	scb->refcnt++;
	return scb;
      }

  if (strcmp (name, "pc") == 0)
    ops = serial_interface_lookup ("pc");
  else if (strchr (name, ':'))
    ops = serial_interface_lookup ("tcp");
  else if (strncmp (name, "lpt", 3) == 0)
    ops = serial_interface_lookup ("parallel");
  else
    ops = serial_interface_lookup ("hardwire");

  if (!ops)
    return NULL;

  scb = (serial_t)xmalloc (sizeof (struct _serial_t));

  scb->ops = ops;

  scb->bufcnt = 0;
  scb->bufp = scb->buf;

  if (scb->ops->open(scb, name))
    {
      free (scb);
      return NULL;
    }

  scb->name = strsave (name);
  scb->next = scb_base;
  scb->refcnt = 1;
  scb_base = scb;

  last_serial_opened = scb;

  if (serial_logfile != NULL)
    {
      serial_logfp = fopen (serial_logfile, "w");
      if (serial_logfp == NULL)
	{
	  perror_with_name (serial_logfile);
	}
    }

  return scb;
}

serial_t
serial_fdopen (fd)
     const int fd;
{
  serial_t scb;
  struct serial_ops *ops;

  for (scb = scb_base; scb; scb = scb->next)
    if (scb->fd == fd)
      {
	scb->refcnt++;
	return scb;
      }

  ops = serial_interface_lookup ("hardwire");

  if (!ops)
    return NULL;

  scb = (serial_t)xmalloc (sizeof (struct _serial_t));

  scb->ops = ops;

  scb->bufcnt = 0;
  scb->bufp = scb->buf;

  scb->fd = fd;

  scb->name = NULL;
  scb->next = scb_base;
  scb->refcnt = 1;
  scb_base = scb;

  last_serial_opened = scb;

  return scb;
}

void
serial_close(scb, really_close)
     serial_t scb;
     int really_close;
{
  serial_t tmp_scb;

  last_serial_opened = NULL;

  if (serial_logfp)
    {
      if (serial_reading || serial_writing)
	{
	  fputc_unfiltered ('\n', serial_logfp);
	  serial_reading = 0;
	  serial_writing = 0;
	}
      fclose (serial_logfp);
      serial_logfp = NULL;
    }

/* This is bogus.  It's not our fault if you pass us a bad scb...!  Rob, you
   should fix your code instead.  */

  if (!scb)
    return;

  scb->refcnt--;
  if (scb->refcnt > 0)
    return;

  if (really_close)
    scb->ops->close (scb);

  if (scb->name)
    free (scb->name);

  if (scb_base == scb)
    scb_base = scb_base->next;
  else
    for (tmp_scb = scb_base; tmp_scb; tmp_scb = tmp_scb->next)
      {
	if (tmp_scb->next != scb)
	  continue;

	tmp_scb->next = tmp_scb->next->next;
	break;
      }

  free(scb);
}

#if 0
/*
The connect command is #if 0 because I hadn't thought of an elegant
way to wait for I/O on two serial_t's simultaneously.  Two solutions
came to mind:

	1) Fork, and have have one fork handle the to user direction,
	   and have the other hand the to target direction.  This
	   obviously won't cut it for MSDOS.

	2) Use something like select.  This assumes that stdin and
	   the target side can both be waited on via the same
	   mechanism.  This may not be true for DOS, if GDB is
	   talking to the target via a TCP socket.
-grossman, 8 Jun 93
*/

/* Connect the user directly to the remote system.  This command acts just like
   the 'cu' or 'tip' command.  Use <CR>~. or <CR>~^D to break out.  */

static serial_t tty_desc;		/* Controlling terminal */

static void
cleanup_tty(ttystate)
     serial_ttystate ttystate;
{
  printf_unfiltered ("\r\n[Exiting connect mode]\r\n");
  SERIAL_SET_TTY_STATE (tty_desc, ttystate);
  free (ttystate);
  SERIAL_CLOSE (tty_desc);
}

static void
connect_command (args, fromtty)
     char	*args;
     int	fromtty;
{
  int c;
  char cur_esc = 0;
  serial_ttystate ttystate;
  serial_t port_desc;		/* TTY port */

  dont_repeat();

  if (args)
    fprintf_unfiltered(gdb_stderr, "This command takes no args.  They have been ignored.\n");
	
  printf_unfiltered("[Entering connect mode.  Use ~. or ~^D to escape]\n");

  tty_desc = SERIAL_FDOPEN (0);
  port_desc = last_serial_opened;

  ttystate = SERIAL_GET_TTY_STATE (tty_desc);

  SERIAL_RAW (tty_desc);
  SERIAL_RAW (port_desc);

  make_cleanup (cleanup_tty, ttystate);

  while (1)
    {
      int mask;

      mask = SERIAL_WAIT_2 (tty_desc, port_desc, -1);

      if (mask & 2)
	{			/* tty input */
	  char cx;

	  while (1)
	    {
	      c = SERIAL_READCHAR(tty_desc, 0);

	      if (c == SERIAL_TIMEOUT)
		  break;

	      if (c < 0)
		perror_with_name("connect");

	      cx = c;
	      SERIAL_WRITE(port_desc, &cx, 1);

	      switch (cur_esc)
		{
		case 0:
		  if (c == '\r')
		    cur_esc = c;
		  break;
		case '\r':
		  if (c == '~')
		    cur_esc = c;
		  else
		    cur_esc = 0;
		  break;
		case '~':
		  if (c == '.' || c == '\004')
		    return;
		  else
		    cur_esc = 0;
		}
	    }
	}

      if (mask & 1)
	{			/* Port input */
	  char cx;

	  while (1)
	    {
	      c = SERIAL_READCHAR(port_desc, 0);

	      if (c == SERIAL_TIMEOUT)
		  break;

	      if (c < 0)
		perror_with_name("connect");

	      cx = c;

	      SERIAL_WRITE(tty_desc, &cx, 1);
	    }
	}
    }
}
#endif /* 0 */

/* VARARGS */
void
#ifdef ANSI_PROTOTYPES
serial_printf (serial_t desc, const char *format, ...)
#else
serial_printf (va_alist)
     va_dcl
#endif
{
  va_list args;
  char *buf;
#ifdef ANSI_PROTOTYPES
  va_start (args, format);
#else
  serial_t desc;
  char *format;

  va_start (args);
  desc = va_arg (args, serial_t);
  format = va_arg (args, char *);
#endif

  vasprintf (&buf, format, args);
  SERIAL_WRITE (desc, buf, strlen (buf));

  free (buf);
  va_end (args);
}

void
_initialize_serial ()
{
  struct cmd_list_element *cmd;

#if 0
  add_com ("connect", class_obscure, connect_command,
	   "Connect the terminal directly up to the command monitor.\n\
Use <CR>~. or <CR>~^D to break out.");
#endif /* 0 */

  add_show_from_set (add_set_cmd ("remotelogfile", no_class,
				  var_filename, (char *)&serial_logfile,
				  "Set filename for remote session recording.\n\
This file is used to record the remote session for future playback\n\
by gdbserver.", &setlist),
		     &showlist);

  add_show_from_set (add_set_enum_cmd ("remotelogbase", no_class,
				       logbase_enums,
				       (char *)&serial_logbase,
				       "Set ...",
				       &setlist),
			   &showlist);
}
@
