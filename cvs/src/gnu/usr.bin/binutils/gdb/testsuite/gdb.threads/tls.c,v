head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_0:1.1.1.1.0.50
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.46
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.48
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.40
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.44
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.42
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.38
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.36
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.34
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.32
	OPENBSD_5_0:1.1.1.1.0.30
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.28
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.26
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.22
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.24
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.20
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.18
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.16
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.14
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.12
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.10
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.8
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.6
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.4
	OPENBSD_3_7_BASE:1.1.1.1
	GDB_6_3:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.2
	OPENBSD_3_6_BASE:1.1.1.1
	GDB_6_1:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2004.05.21.19.18.28;	author kettenis;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.05.21.19.18.28;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* BeginSourceFile tls.c

  This file creates and deletes threads. It uses thread local storage
  variables too. */

#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <pthread.h>
#include <semaphore.h>
#include <errno.h>

#define N_THREADS 3

/* Uncomment to turn on debugging output */
/*#define START_DEBUG*/

/* Thread-local storage.  */
__thread int a_thread_local;
__thread int another_thread_local;

/* Global variable just for info addr in gdb.  */
int a_global;

/* Print the results of thread-local storage.  */
int thread_local_val[ N_THREADS ];
int another_thread_local_val[ N_THREADS ];

/* Semaphores to make sure the threads are alive when we print the TLS
   variables from gdb.  */
sem_t tell_main, tell_thread;


void print_error ()
{
  switch (errno)
  {
    case EAGAIN:
      fprintf (stderr, "EAGAIN\n");
      break;
    case EINTR:
      fprintf (stderr, "EINTR\n");
      break;
    case EINVAL:
      fprintf (stderr, "EINVAL\n");
      break;
    case ENOSYS:
      fprintf (stderr, "ENOSYS\n");
      break;
    case ENOENT:
      fprintf (stderr, "ENOENT\n");
      break;
    case EDEADLK:
      fprintf (stderr, "EDEADLK\n");
      break;
    default:
      fprintf (stderr, "Unknown error\n");
      break;
   } 
}

/* Routine for each thread to run, does nothing.  */
void *spin( vp )
    void * vp;
{
    int me = (long) vp;
    int i;
    
    /* Use a_global. */
    a_global++;

    a_thread_local = 0;
    another_thread_local = me;
    for( i = 0; i <= me; i++ ) {
        a_thread_local += i;
    }

    another_thread_local_val[me] = another_thread_local;
    thread_local_val[ me ] = a_thread_local; /* here we know tls value */

    if (sem_post (&tell_main) == -1)
     {
        fprintf (stderr, "th %d post on sem tell_main failed\n", me);
        print_error ();
        return;
     }
#ifdef START_DEBUG
    fprintf (stderr, "th %d post on tell main\n", me);
#endif

    while (1)
      {
#ifdef START_DEBUG
        fprintf (stderr, "th %d start wait on tell_thread\n", me);
#endif
        if (sem_wait (&tell_thread) == 0)
          break;

        if (errno == EINTR)
          {
#ifdef START_DEBUG
            fprintf (stderr, "th %d wait tell_thread got EINTR, rewaiting\n", me);
#endif
            continue;
          }
        else
          {  
            fprintf (stderr, "th %d wait on sem tell_thread failed\n", me);
            print_error ();
            return;
         }
      }

#ifdef START_DEBUG
      fprintf (stderr, "th %d Wait on tell_thread\n", me);
#endif

}

void
do_pass()
{
    int i;
    pthread_t t[ N_THREADS ];
    int err;

    for( i = 0; i < N_THREADS; i++)
    {
        thread_local_val[i] = 0;
        another_thread_local_val[i] = 0;
    }
   
    if (sem_init (&tell_main, 0, 0) == -1)
    {
      fprintf (stderr, "tell_main semaphore init failed\n");
      return;
    }

    if (sem_init (&tell_thread, 0, 0) == -1)
    {
      fprintf (stderr, "tell_thread semaphore init failed\n");
      return;
    }

    /* Start N_THREADS threads, then join them so that they are terminated.  */
    for( i = 0; i < N_THREADS; i++ )
     {
        err = pthread_create( &t[i], NULL, spin, (void *) (long) i );
        if( err != 0 ) {
            fprintf(stderr, "Error in thread %d create\n", i );
        }
     }

    for( i = 0; i < N_THREADS; i++ )
      {
        while (1)
          {
#ifdef START_DEBUG
            fprintf (stderr, "main %d start wait on tell_main\n", i);
#endif
            if (sem_wait (&tell_main) == 0)
              break;

            if (errno == EINTR)
              {
#ifdef START_DEBUG
                fprintf (stderr, "main %d wait tell_main got EINTR, rewaiting\n", i);
#endif
                continue;
              }
            else
              {
                fprintf (stderr, "main %d wait on sem tell_main failed\n", i);
                print_error ();
                return;
              }
            }
       }

#ifdef START_DEBUG
    fprintf (stderr, "main done waiting on tell_main\n");
#endif

    i = 10;  /* Here all threads should be still alive. */

    for( i = 0; i < N_THREADS; i++ )
     {
       if (sem_post (&tell_thread) == -1)
        {
           fprintf (stderr, "main %d post on sem tell_thread failed\n", i);
           print_error ();
           return;
        }
#ifdef START_DEBUG
      fprintf (stderr, "main %d post on tell_thread\n", i);
#endif
     }

    for( i = 0; i < N_THREADS; i++ )
     {
        err = pthread_join(t[i], NULL );
        if( err != 0 )
         { 
           fprintf (stderr, "error in thread %d join\n", i );
         }
    }

    i = 10;  /* Null line for setting bpts on. */
   
}

int
main()
{
   do_pass ();

   return 0;  /* Set breakpoint here before exit. */
}

/* EndSourceFile */
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@@
