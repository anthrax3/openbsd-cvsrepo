head	1.3;
access;
symbols
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.54
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.50
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.46
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.48
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.40
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.44
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.42
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.38
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.36
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.34
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.32
	OPENBSD_5_0:1.3.0.30
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.28
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.26
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.22
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.24
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.20
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.18
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.16
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.14
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.12
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.10
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	GDB_6_3:1.1.1.1
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2004.05.21.20.23.43;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.51.56;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.37.53;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.18.28;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.37.53;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@# step.exp -- Expect script to test gdb with step.c
# Copyright (C) 1992, 1997 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Hiro Sugawara. (hiro@@lynx.com)
#
# This test really needs some major surgery to be acceptable, but
# I'm just about burnt out on lynx work, so I'm not doing it now.
#
#	* The test has an indeterminate number of pass/fails
#	for each run (it runs a small group of tests until
#	it's timer kicks off).  This is very bad for nightly
#	automated regression testing.
#
#	* It tries to "step" from withint he prologue of a
# 	function.  This isn't support in gdb (it's going
#	to act like a continue).
#
#	* This test rarely check that it stopped in sensible
#	places.  (see previous bullet -- this test doesn't
#	catch the fact it continued rather than stepped)


if $tracelevel then {
	strace $tracelevel
}

set program_exited 0

proc set_bp { where } {
    global gdb_prompt

    send_gdb "break $where\n"
    # The first regexp is what we get with -g, the second without -g.
    gdb_expect {
	-re "Break.* at .*: file .*, line \[0-9\]*.*$gdb_prompt $" {}
	-re "Breakpoint \[0-9\]* at 0x\[0-9a-f\]*.*$gdb_prompt $" {}
	-re "$gdb_prompt $" { fail "setting breakpoint at $where" ; return 0 }
	timeout { fail "setting breakpoint at $where (timeout)" ; return 0 }
    }
    pass "set_bp"
}

proc step_it { cmd } {
    global gdb_prompt
    global program_exited

    send_gdb "$cmd\n"
    gdb_expect {
	-re "0x\[0-9A-Fa-f\]* *in.*\r\n$gdb_prompt $" { pass "step_it"; return 0 }
	-re "0x\[0-9A-Fa-f\]* *\[0-9\]*.*\r\n$gdb_prompt $" { pass "step_it"; return 1 }
	-re "Program exited .*\n$gdb_prompt $" {
		set program_exited 1
		return -1
	    }
	-re "$gdb_prompt $"	{ fail "single-stepping ($cmd).\n" ; return -1 }
	timeout	{ fail "single-stepping ($cmd) timout.\n" ; return -1 }
    }
}

proc step_inst {} {
    step_it "stepi"
}

proc step_source {} {
    step_it "step"
}

proc continue_all {} {
    global gdb_prompt

    send_gdb "continue\n"
    gdb_expect {
	-re "Breakpoint \[0-9\]*, thread\[0-9\]* .*$gdb_prompt $" { 
	    pass "continue_all"
	    return 0
	}
	-re "Program exited .*\n$gdb_prompt $" {
	    set program_exited 1
	    return 1;
	}
	-re "$gdb_prompt $" { fail "continue" ; return -1 }
	timeout { fail "continue (timeout)" ; return -1 }
    }
}

proc check_threads { num_threads } {
    global gdb_prompt

    set curr_thread 0
    send_gdb "info threads\n"
    while { $num_threads > 0 } {
	gdb_expect {
	    -re "\\* *\[0-9\]* process \[0-9\]* thread \[0-9\]* .*\n" {
		incr curr_thread
		set num_threads [expr $num_threads - 1]
	    }
	    -re " *\[0-9\]* process \[0-9\]* thread \[0-9\]* .*\n" {
		set num_threads [expr $num_threads - 1]
	    }
	    -re "$gdb_prompt $" {
		if { $num_threads < 0 } {
		    fail "check_threads (too many)" ; return -1
		}
		break
	    }
	    timeout { fail "check_threads (timeout)" ; return -1 }
	}
    }

    if { $curr_thread == 0 } {
	fail "check_threads (no current thread)\n"
	return -1
    }
    if { $curr_thread > 1 } {
	fail "check_threads (more than one current thread)\n"
	return -1
    }
    return 0
}

proc test_cond_wait {} {
    global program_exited

    set_bp	135
    runto	179
    while { 1 } {
	set stepi_counter 0
	while { [step_inst] } {
		if { $program_exited } { break }
		incr stepi_counter
		if { $stepi_counter > 30 } {
			fail "too many stepi's per line\n"
			return -1
		}
	}
	if { $program_exited } { break }
	step_source
	if { $program_exited } { break }
	continue_all
	if { $program_exited } { break }
	check_threads 3
    }
}

proc do_tests {} {
    global prms_id
    global bug_id
    global subdir
    global objdir
    global srcdir
    global binfile
    global gdb_prompt

    set prms_id 0
    set bug_id 0

    # Start with a fresh gdb.

    gdb_exit
    gdb_start
    gdb_reinitialize_dir $srcdir/$subdir
    gdb_load $objdir/$subdir/$binfile

    send_gdb "set width 0\n"
    gdb_expect -re "$gdb_prompt $"

    test_cond_wait
}

# Check to see if we have an executable to test.  If not, then either we
# haven't tried to compile one, or the compilation failed for some reason.
# In either case, just notify the user and skip the tests in this file.

set binfile "step"
set srcfile "step.c"

if ![file exists $objdir/$subdir/$binfile] then {
    if $all_flag then {
	warning "$binfile does not exist; tests suppressed."
    }
} else {
    do_tests
}
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 1
a2 1
# Copyright (C) 1992 Free Software Foundation, Inc.
d16 1
a16 1
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d47 1
a47 1
    global prompt
d49 1
a49 1
    send "break $where\n"
d51 4
a54 4
    expect {
	-re "Break.* at .*: file .*, line \[0-9\]*.*$prompt $" {}
	-re "Breakpoint \[0-9\]* at 0x\[0-9a-f\]*.*$prompt $" {}
	-re "$prompt $" { fail "setting breakpoint at $where" ; return 0 }
d61 1
a61 1
    global prompt
d64 5
a68 5
    send "$cmd\n"
    expect {
	-re "0x\[0-9A-Fa-f\]* *in.*\r\n$prompt $" { pass "step_it"; return 0 }
	-re "0x\[0-9A-Fa-f\]* *\[0-9\]*.*\r\n$prompt $" { pass "step_it"; return 1 }
	-re "Program exited .*\n$prompt $" {
d72 1
a72 1
	-re "$prompt $"	{ fail "single-stepping ($cmd).\n" ; return -1 }
d86 1
a86 1
    global prompt
d88 3
a90 3
    send "continue\n"
    expect {
	-re "Breakpoint \[0-9\]*, thread\[0-9\]* .*$prompt $" { 
d94 1
a94 1
	-re "Program exited .*\n$prompt $" {
d98 1
a98 1
	-re "$prompt $" { fail "continue" ; return -1 }
d104 1
a104 1
    global prompt
d107 1
a107 1
    send "info threads\n"
d109 1
a109 1
	expect {
d117 1
a117 1
	    -re "$prompt $" {
d169 1
a169 1
    global prompt
d181 2
a182 2
    send "set width 0\n"
    expect -re "$prompt $"
@


1.1
log
@file step.exp was initially added on branch CYGNUS.
@
text
@d1 200
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 200
# step.exp -- Expect script to test gdb with step.c
# Copyright (C) 1992, 1997 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Hiro Sugawara. (hiro@@lynx.com)
#
# This test really needs some major surgery to be acceptable, but
# I'm just about burnt out on lynx work, so I'm not doing it now.
#
#	* The test has an indeterminate number of pass/fails
#	for each run (it runs a small group of tests until
#	it's timer kicks off).  This is very bad for nightly
#	automated regression testing.
#
#	* It tries to "step" from withint he prologue of a
# 	function.  This isn't support in gdb (it's going
#	to act like a continue).
#
#	* This test rarely check that it stopped in sensible
#	places.  (see previous bullet -- this test doesn't
#	catch the fact it continued rather than stepped)


if $tracelevel then {
	strace $tracelevel
}

set program_exited 0

proc set_bp { where } {
    global gdb_prompt

    send_gdb "break $where\n"
    # The first regexp is what we get with -g, the second without -g.
    gdb_expect {
	-re "Break.* at .*: file .*, line \[0-9\]*.*$gdb_prompt $" {}
	-re "Breakpoint \[0-9\]* at 0x\[0-9a-f\]*.*$gdb_prompt $" {}
	-re "$gdb_prompt $" { fail "setting breakpoint at $where" ; return 0 }
	timeout { fail "setting breakpoint at $where (timeout)" ; return 0 }
    }
    pass "set_bp"
}

proc step_it { cmd } {
    global gdb_prompt
    global program_exited

    send_gdb "$cmd\n"
    gdb_expect {
	-re "0x\[0-9A-Fa-f\]* *in.*\r\n$gdb_prompt $" { pass "step_it"; return 0 }
	-re "0x\[0-9A-Fa-f\]* *\[0-9\]*.*\r\n$gdb_prompt $" { pass "step_it"; return 1 }
	-re "Program exited .*\n$gdb_prompt $" {
		set program_exited 1
		return -1
	    }
	-re "$gdb_prompt $"	{ fail "single-stepping ($cmd).\n" ; return -1 }
	timeout	{ fail "single-stepping ($cmd) timout.\n" ; return -1 }
    }
}

proc step_inst {} {
    step_it "stepi"
}

proc step_source {} {
    step_it "step"
}

proc continue_all {} {
    global gdb_prompt

    send_gdb "continue\n"
    gdb_expect {
	-re "Breakpoint \[0-9\]*, thread\[0-9\]* .*$gdb_prompt $" { 
	    pass "continue_all"
	    return 0
	}
	-re "Program exited .*\n$gdb_prompt $" {
	    set program_exited 1
	    return 1;
	}
	-re "$gdb_prompt $" { fail "continue" ; return -1 }
	timeout { fail "continue (timeout)" ; return -1 }
    }
}

proc check_threads { num_threads } {
    global gdb_prompt

    set curr_thread 0
    send_gdb "info threads\n"
    while { $num_threads > 0 } {
	gdb_expect {
	    -re "\\* *\[0-9\]* process \[0-9\]* thread \[0-9\]* .*\n" {
		incr curr_thread
		set num_threads [expr $num_threads - 1]
	    }
	    -re " *\[0-9\]* process \[0-9\]* thread \[0-9\]* .*\n" {
		set num_threads [expr $num_threads - 1]
	    }
	    -re "$gdb_prompt $" {
		if { $num_threads < 0 } {
		    fail "check_threads (too many)" ; return -1
		}
		break
	    }
	    timeout { fail "check_threads (timeout)" ; return -1 }
	}
    }

    if { $curr_thread == 0 } {
	fail "check_threads (no current thread)\n"
	return -1
    }
    if { $curr_thread > 1 } {
	fail "check_threads (more than one current thread)\n"
	return -1
    }
    return 0
}

proc test_cond_wait {} {
    global program_exited

    set_bp	135
    runto	179
    while { 1 } {
	set stepi_counter 0
	while { [step_inst] } {
		if { $program_exited } { break }
		incr stepi_counter
		if { $stepi_counter > 30 } {
			fail "too many stepi's per line\n"
			return -1
		}
	}
	if { $program_exited } { break }
	step_source
	if { $program_exited } { break }
	continue_all
	if { $program_exited } { break }
	check_threads 3
    }
}

proc do_tests {} {
    global prms_id
    global bug_id
    global subdir
    global objdir
    global srcdir
    global binfile
    global gdb_prompt

    set prms_id 0
    set bug_id 0

    # Start with a fresh gdb.

    gdb_exit
    gdb_start
    gdb_reinitialize_dir $srcdir/$subdir
    gdb_load $objdir/$subdir/$binfile

    send_gdb "set width 0\n"
    gdb_expect -re "$gdb_prompt $"

    test_cond_wait
}

# Check to see if we have an executable to test.  If not, then either we
# haven't tried to compile one, or the compilation failed for some reason.
# In either case, just notify the user and skip the tests in this file.

set binfile "step"
set srcfile "step.c"

if ![file exists $objdir/$subdir/$binfile] then {
    if $all_flag then {
	warning "$binfile does not exist; tests suppressed."
    }
} else {
    do_tests
}
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 200
# step.exp -- Expect script to test gdb with step.c
# Copyright (C) 1992 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Hiro Sugawara. (hiro@@lynx.com)
#
# This test really needs some major surgery to be acceptable, but
# I'm just about burnt out on lynx work, so I'm not doing it now.
#
#	* The test has an indeterminate number of pass/fails
#	for each run (it runs a small group of tests until
#	it's timer kicks off).  This is very bad for nightly
#	automated regression testing.
#
#	* It tries to "step" from withint he prologue of a
# 	function.  This isn't support in gdb (it's going
#	to act like a continue).
#
#	* This test rarely check that it stopped in sensible
#	places.  (see previous bullet -- this test doesn't
#	catch the fact it continued rather than stepped)


if $tracelevel then {
	strace $tracelevel
}

set program_exited 0

proc set_bp { where } {
    global prompt

    send "break $where\n"
    # The first regexp is what we get with -g, the second without -g.
    expect {
	-re "Break.* at .*: file .*, line \[0-9\]*.*$prompt $" {}
	-re "Breakpoint \[0-9\]* at 0x\[0-9a-f\]*.*$prompt $" {}
	-re "$prompt $" { fail "setting breakpoint at $where" ; return 0 }
	timeout { fail "setting breakpoint at $where (timeout)" ; return 0 }
    }
    pass "set_bp"
}

proc step_it { cmd } {
    global prompt
    global program_exited

    send "$cmd\n"
    expect {
	-re "0x\[0-9A-Fa-f\]* *in.*\r\n$prompt $" { pass "step_it"; return 0 }
	-re "0x\[0-9A-Fa-f\]* *\[0-9\]*.*\r\n$prompt $" { pass "step_it"; return 1 }
	-re "Program exited .*\n$prompt $" {
		set program_exited 1
		return -1
	    }
	-re "$prompt $"	{ fail "single-stepping ($cmd).\n" ; return -1 }
	timeout	{ fail "single-stepping ($cmd) timout.\n" ; return -1 }
    }
}

proc step_inst {} {
    step_it "stepi"
}

proc step_source {} {
    step_it "step"
}

proc continue_all {} {
    global prompt

    send "continue\n"
    expect {
	-re "Breakpoint \[0-9\]*, thread\[0-9\]* .*$prompt $" { 
	    pass "continue_all"
	    return 0
	}
	-re "Program exited .*\n$prompt $" {
	    set program_exited 1
	    return 1;
	}
	-re "$prompt $" { fail "continue" ; return -1 }
	timeout { fail "continue (timeout)" ; return -1 }
    }
}

proc check_threads { num_threads } {
    global prompt

    set curr_thread 0
    send "info threads\n"
    while { $num_threads > 0 } {
	expect {
	    -re "\\* *\[0-9\]* process \[0-9\]* thread \[0-9\]* .*\n" {
		incr curr_thread
		set num_threads [expr $num_threads - 1]
	    }
	    -re " *\[0-9\]* process \[0-9\]* thread \[0-9\]* .*\n" {
		set num_threads [expr $num_threads - 1]
	    }
	    -re "$prompt $" {
		if { $num_threads < 0 } {
		    fail "check_threads (too many)" ; return -1
		}
		break
	    }
	    timeout { fail "check_threads (timeout)" ; return -1 }
	}
    }

    if { $curr_thread == 0 } {
	fail "check_threads (no current thread)\n"
	return -1
    }
    if { $curr_thread > 1 } {
	fail "check_threads (more than one current thread)\n"
	return -1
    }
    return 0
}

proc test_cond_wait {} {
    global program_exited

    set_bp	135
    runto	179
    while { 1 } {
	set stepi_counter 0
	while { [step_inst] } {
		if { $program_exited } { break }
		incr stepi_counter
		if { $stepi_counter > 30 } {
			fail "too many stepi's per line\n"
			return -1
		}
	}
	if { $program_exited } { break }
	step_source
	if { $program_exited } { break }
	continue_all
	if { $program_exited } { break }
	check_threads 3
    }
}

proc do_tests {} {
    global prms_id
    global bug_id
    global subdir
    global objdir
    global srcdir
    global binfile
    global prompt

    set prms_id 0
    set bug_id 0

    # Start with a fresh gdb.

    gdb_exit
    gdb_start
    gdb_reinitialize_dir $srcdir/$subdir
    gdb_load $objdir/$subdir/$binfile

    send "set width 0\n"
    expect -re "$prompt $"

    test_cond_wait
}

# Check to see if we have an executable to test.  If not, then either we
# haven't tried to compile one, or the compilation failed for some reason.
# In either case, just notify the user and skip the tests in this file.

set binfile "step"
set srcfile "step.c"

if ![file exists $objdir/$subdir/$binfile] then {
    if $all_flag then {
	warning "$binfile does not exist; tests suppressed."
    }
} else {
    do_tests
}
@
