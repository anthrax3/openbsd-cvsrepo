head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.50
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.52
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.48
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.44
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.46
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.38
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.42
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.40
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.36
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.34
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.32
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.30
	OPENBSD_5_0:1.4.0.28
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.26
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.24
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@# @;


1.4
date	2004.12.27.14.00.57;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.21.20.23.40;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.50.26;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.35.51;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.17.02;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.15.57;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.35.52;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@# Copyright 1997, 1998, 1999, 2003, 2004 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

if [target_info exists gdb,nosignals] {
    verbose "Skipping signals.exp because of nosignals."
    continue
}

if $tracelevel then {
	strace $tracelevel
}

set prms_id 0
set bug_id 0

set testfile signals
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}
if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
    gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

# Create and source the file that provides information about the compiler
# used to compile the test case.
if [get_compiler_info ${binfile}] {
    return -1;
}

if {$hp_cc_compiler} {
    set void 0
} else {
    set void void
}

gdb_exit
gdb_start

# This will need to be updated as the exact list of signals changes,
# but I want to test that TARGET_SIGNAL_0, TARGET_SIGNAL_DEFAULT, and
# TARGET_SIGNAL_UNKNOWN are skipped.

proc test_handle_all_print {} {
    global timeout
    # Increase timeout and expect input buffer for large output from gdb.
    # Allow blank or TAB as whitespace characters.
    set oldtimeout $timeout
    set timeout [expr "$timeout + 360"]
    verbose "Timeout is now $timeout seconds" 2
    if { ![istarget "*-*-linux*"]
         && ( [istarget "*-*-gnu*"]
              || [istarget "*-*-mach*"] ) } {
	gdb_test "handle all print" "Signal\[ 	\]+Stop\[ 	\]+Print\[ 	\]+Pass to program\[ 	\]+Description\r\nSIGHUP\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Hangup.*SIG63\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Real-time event 63.*EXC_BREAKPOINT\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Breakpoint"
    } else {
	gdb_test "handle all print" "Signal\[ 	\]+Stop\[ 	\]+Print\[ 	\]+Pass to program\[ 	\]+Description\r\nSIGHUP\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Hangup.*SIG63\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Real-time event 63.*"
    }
    set timeout $oldtimeout
    verbose "Timeout restored to $timeout seconds" 2
}
test_handle_all_print

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load $binfile

if [runto_main] then {

    # Since count is a static variable outside main, runto_main is no
    # guarantee that count will be 0 at this point.

    gdb_test "set variable count = 0" ""

    # Test an inferior function call that takes a signal that hits a
    # breakpoint (with a false condition).  When GDB tries to run the
    # stack dummy, it will hit the breakpoint at handler.  Provided it
    # doesn't lose its cool, this is not a problem, it just has to
    # note that the breakpoint condition is false and keep going.

    # ...setup an always false conditional breakpoint

    gdb_test "break handler if 0" "Breakpoint \[0-9\]+ .*"
    gdb_test "set \$handler_breakpoint_number = \$bpnum" ""

    # ...setup the signal

    gdb_test "next" "signal \\(SIGUSR1.*" "next to signal"
    gdb_test "next" "alarm \\(.*" "next to alarm #1"
    gdb_test "next" "\\+\\+count; /\\* first \\*/" \
	"next to ++count #1"
    sleep 2

    # ...call the function

    gdb_test "p func1 ()" "^p func1 \\(\\)\r\n.\[0-9\]* = $void" \
	"p func1 () #1"

    # ...veryfiy that the cout was updated

    gdb_test "p count" "= 2" "p count #1"

    # Now run the same test but with a breakpoint that does stop.

    # ...set up the breakpoint and signal

    gdb_test "condition \$handler_breakpoint_number" "now unconditional\\."
    gdb_test "next" "alarm \\(.*" "next to alarm #2"
    gdb_test "next" "\\+\\+count; /\\* second \\*/" \
	"next to ++count #2"
    sleep 2

    # ...call the function, which is immediatly interrupted

    gdb_test "p func1 ()" \
"Breakpoint \[0-9\]*, handler.*
The program being debugged stopped while in a function called from GDB.*" \
	"p func1 () #2"

    # ...verify the backtrace

    gdb_test "backtrace" \
	"#0  handler.*#1  .signal handler called.*#2  func1.*#3  .function called from gdb.*#4.*main.*" \
	"backtrace from handler when calling func1"

    # ...and continue (silently returning)

    gdb_test "continue" "Continuing\\."

    # ...and then count should have been incremented

    gdb_test "p count" "= 5" "p count #2"


    # Verify that "info signals" produces reasonable output.

    gdb_test "info signals" "SIGHUP.*SIGINT.*SIGQUIT.*SIGILL.*SIGTRAP.*SIGABRT.*SIGEMT.*SIGFPE.*SIGKILL.*SIGBUS.*SIGSEGV.*SIGSYS.*SIGPIPE.*SIGALRM.*SIGTERM.*SIGURG.*SIGSTOP.*SIGTSTP.*SIGCONT.*SIGCHLD.*SIGTTIN.*SIGTTOU.*SIGIO.*SIGXCPU.*SIGXFSZ.*SIGVTALRM.*SIGPROF.*SIGWINCH.*SIGLOST.*SIGUSR1.*SIGUSR2.*SIGPWR.*SIGPOLL.*SIGWIND.*SIGPHONE.*SIGWAITING.*SIGLWP.*SIGDANGER.*SIGGRANT.*SIGRETRACT.*SIGMSG.*SIGSOUND.*SIGSAK.*SIGPRIO.*SIG33.*SIG34.*SIG35.*SIG36.*SIG37.*SIG38.*SIG39.*SIG40.*SIG41.*SIG42.*SIG43.*SIG44.*SIG45.*SIG46.*SIG47.*SIG48.*SIG49.*SIG50.*SIG51.*SIG52.*SIG53.*SIG54.*SIG55.*SIG56.*SIG57.*SIG58.*SIG59.*SIG60.*SIG61.*SIG62.*SIG63.*Use the \"handle\" command to change these tables.*" \
	"info signals"

    # Verify that "info signal" correctly handles an argument, be it a
    # symbolic signal name, or an integer ID.

    gdb_test "info signal SIGTRAP" \
	"SIGTRAP\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*No\[ \t\]*Trace/breakpoint trap.*" \
	"info signal SIGTRAP"

    gdb_test "info signal 5" \
	"SIGTRAP\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*No\[ \t\]*Trace/breakpoint trap.*" \
	"info signal 5"

    # Verify that "handle" with illegal arguments is gracefully, um,
    # handled.

    gdb_test "handle" \
	"Argument required .signal to handle.*" \
	"handle without arguments"

    gdb_test "handle SIGFOO" \
	"Unrecognized or ambiguous flag word: \"SIGFOO\".*" \
	"handle with bogus SIG"

    gdb_test "handle SIGHUP frump" \
	"Unrecognized or ambiguous flag word: \"frump\".*" \
	"handle SIG with bogus action"

    # Verify that "handle" can take multiple actions per SIG, and that
    # in the case of conflicting actions, that the rightmost action
    # "wins".

    gdb_test "handle SIGHUP print noprint" \
	"SIGHUP\[ \t\]*No\[ \t\]*No\[ \t\]*Yes\[ \t\]*Hangup.*" \
	"handle SIG with multiple conflicting actions"

    # Exercise all the various actions.  (We don't care what the
    # outcome is, this is just to ensure that they all can be parsed.)

    gdb_test "handle SIGHUP print noprint stop nostop ignore noignore pass nopass" \
	"Signal.*" \
	"handle SIG parses all legal actions"

    # Verify that we can "handle" multiple signals at once,
    # interspersed with actions.

    gdb_test "handle SIG63 print SIGILL" \
	"SIGILL\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*Illegal instruction.*SIG63\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*Real-time event 63.*" \
	"handle multiple SIGs"

    # Verify that "handle" can take a numeric argument for the signal
    # ID, rather than a symbolic name.  (This may not be portable;
    # works for HP-UX.)

    # Also note that this testpoint overrides SIGTRAP, which on HP-UX
    # at least, is used to implement single-steps and breakpoints.
    # Don't expect to run the inferior after this!

    set test "override SIGTRAP"
    gdb_test_multiple "handle 5 nopass" "$test" {
	-re "SIGTRAP is used by the debugger.*Are you sure you want to change it.*y or n.*" {
	    gdb_test "y" \
		"SIGTRAP\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*No\[ \t\]*Trace/breakpoint trap.*" \
		"$test"
	}
    }

    # GDB doesn't seem to allow numeric signal IDs larger than 15.  Verify
    # that restriction.  ??rehrauer: Not sure if this is a feature or a
    # bug, actually.  Why is the range 1-15?

    gdb_test "handle 58" \
	"Only signals 1-15 are valid as numeric signals.*Use \"info signals\" for a list of symbolic signals.*" \
	"invalid signal number rejected"

    # Verify that we can accept a signal ID range (number-number).
    # ??rehrauer: This feature isn't documented on the quick-reference
    # card.

    gdb_test "handle 13-15" \
	"SIGPIPE.*SIGALRM.*SIGTERM.*" \
	"handle multiple SIGs via integer range"

    # Bizarrely enough, GDB also allows you to reverse the range stat,
    # stop IDs.  E.g., "3-1" and "1-3" mean the same thing.  Probably
    # this isn't documented, but the code anticipates it, so we'd best
    # test it...

    gdb_test "handle 15-13" \
	"SIGPIPE.*SIGALRM.*SIGTERM.*" \
	"handle multiple SIGs via reverse integer range"

    # SIGINT is used by the debugger as well.  Verify that we can
    # change our minds about changing it.

    set test "override SIGINT"
    gdb_test_multiple "handle SIGINT nopass" "$test" {
	-re "SIGINT is used by the debugger.*Are you sure you want to change it.*y or n.*" {
	    gdb_test_multiple "n" "$test" {
		-re "Not confirmed, unchanged.*Signal.*$gdb_prompt $"  {
		    # "Signal ..." should not be in the output.
		    kfail gdb/1707 "$test"
		}
		-re "Not confirmed, unchanged.*$gdb_prompt $" {
		    pass "$test"
		}
	    }
	}
    }

    # Verify that GDB responds gracefully to the "signal" command with
    # a missing argument.

    gdb_test "signal" \
	"Argument required .signal number..*" \
	"signal without arguments disallowed"
    
    # Verify that we can successfully send a signal other than 0 to
    # the inferior.  (This probably causes the inferior to run away.
    # Be prepared to rerun to main for further testing.)

    gdb_test "signal SIGUSR1" "Breakpoint.*handler.*"
    gdb_test "bt" \
	"#0  handler .*#1  .signal handler called.*\#2 .*main.*" \
	"backtrace for SIGUSR1"
}

return 0
@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@d1 1
a1 1
#   Copyright 1997, 1998, 1999, 2003 Free Software Foundation, Inc.
a16 3
# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

d33 1
a33 1
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
a47 282
proc signal_tests_1 {} {
    global gdb_prompt
    if [runto_main] then {
	gdb_test "next" "signal \\(SIGUSR1.*" \
		"next over signal (SIGALRM, handler)"
	gdb_test "next" "alarm \\(.*" \
		"next over signal (SIGUSR1, handler)"
	gdb_test "next" "\\+\\+count; /\\* first \\*/" \
		"next over alarm (1)"
	# An alarm has been signaled, give the signal time to get delivered.
	sleep 2

	# i386 BSD currently fails the next test with a SIGTRAP.
	setup_xfail "i*86-*-bsd*"
	# But Dynix has a DECR_PC_AFTER_BREAK of zero, so the failure
	# is shadowed by hitting the through_sigtramp_breakpoint.
	clear_xfail "i*86-sequent-bsd*"
	# Univel SVR4 i386 continues instead of stepping.
	setup_xfail "i*86-univel-sysv4*"
	# lynx fails with "next" acting like "continue"
	setup_xfail "*-*-*lynx*"
	# linux (aout versions) also fails with "next" acting like "continue"
	# this is probably more dependant on the kernel version than on the
	# object file format or utils.  (sigh)
	setup_xfail "i*86-pc-linuxaout-gnu" "i*86-pc-linuxoldld-gnu"
	send_gdb "next\n"
	gdb_expect {
	    -re "alarm .*$gdb_prompt $" { pass "next to 2nd alarm (1)" }
	    -re "Program received signal SIGTRAP.*first.*$gdb_prompt $" {

		# This can happen on machines that have a trace flag
		# in their PS register.
		# The trace flag in the PS register will be set due to
		# the `next' command.
		# Before calling the signal handler, the PS register
		# is pushed along with the context on the user stack.
		# When the signal handler has finished, it reenters the
		# the kernel via a sigreturn syscall, which restores the
		# PS register along with the context.
		# If the kernel erroneously does not clear the trace flag
		# in the pushed context, gdb will receive a SIGTRAP from
		# the set trace flag in the restored context after the
		# signal handler has finished.

		# I do not yet understand why the SIGTRAP does not occur
		# after stepping the instruction at the restored PC on
		# i386 BSDI 1.0 systems.

		# Note that the vax under Ultrix also exhibits
		# this behaviour (it is uncovered by the `continue from
		# a break in a signal handler' test below).
		# With this test the failure is shadowed by hitting the
		# through_sigtramp_breakpoint upon return from the signal
		# handler.

		# SVR4 and Linux based i*86 systems exhibit this behaviour
		# as well (it is uncovered by the `continue from a break
		# in a signal handler' test below).
		# As these systems use procfs, where we tell the kernel not
		# to tell gdb about `pass' signals, and the trace flag is
		# cleared by the kernel before entering the sigtramp
		# routine, GDB will not notice the execution of the signal 
		# handler.
		# Upon return from the signal handler, GDB will receive
		# a SIGTRAP from the set trace flag in the restored context.
		# The SIGTRAP marks the end of a (albeit long winded)
		# single step for GDB, causing this test to pass.

		fail "next to 2nd alarm (1) (probably kernel bug)"
		gdb_test "next" "alarm.*" "next to 2nd alarm (1)"
	    }
	    -re "Program exited with code.*$gdb_prompt $" {

		# This is apparently a bug in the UnixWare kernel (but
		# has not been investigated beyond the
		# resume/target_wait level, and has not been reported
		# to Univel).  If it steps when a signal is pending,
		# it does a continue instead.  I don't know whether
		# there is a workaround.

		# Perhaps this problem exists on other SVR4 systems;
		# but (a) we have no reason to think so, and (b) if we
		# put a wrong xfail here, we never get an XPASS to let
		# us know that it was incorrect (and then if such a
		# configuration regresses we have no way of knowing).
		# Solaris is not a relevant data point either way
		# because it lacks single stepping.

		# fnf: I don't agree with the above philosophy.  We
		# can never be sure that any particular XFAIL is
		# specified 100% correctly in that no systems with
		# the bug are missed and all systems without the bug
		# are excluded.  If we include an XFAIL that isn't
		# appropriate for a particular system, then when that
		# system gets tested it will XPASS, and someone should
		# investigate and fix the setup_xfail as appropriate,
		# or more preferably, the actual bug.  Each such case
		# adds more data to narrowing down the scope of the
		# problem and ultimately fixing it.

		setup_xfail "i*86-*-sysv4*"
		fail "'next' behaved as 'continue (known SVR4 bug)'"
		return 0
	    }
	    -re ".*$gdb_prompt $" { fail "next to 2nd alarm (1)" }
	    timeout { fail "next to 2nd alarm (1); (timeout)" }
	    eof { fail "next to 2nd alarm (1); (eof)" }
	}

	gdb_test "break handler" "Breakpoint \[0-9\]+ .*"
	gdb_test "next" "\\+\\+count; /\\* second \\*/" \
	    "next to 2nd ++count in signals_tests_1"
	# An alarm has been signaled, give the signal time to get delivered.
	sleep 2

	set bash_bug 0
	send_gdb "next\n"
	gdb_expect {
	    -re "Breakpoint.*handler.*$gdb_prompt $" {
		pass "next to handler in signals_tests_1"
	    }
	    -re "Program received signal SIGEMT.*$gdb_prompt $" {
		# Bash versions before 1.13.5 cause this behaviour
		# by blocking SIGTRAP.
		fail "next to handler in signals_tests_1 (known problem with bash versions before 1.13.5)"
		set bash_bug 1
		gdb_test "signal 0" "Breakpoint.*handler.*"
	    }
	    -re ".*$gdb_prompt $" { fail "next to handler in signals_tests_1" }
	    timeout { fail "next to handler in signals_tests_1 (timeout)" }
	    eof { fail "next to handler in signals_tests_1 (eof)" }
	}

	# This doesn't test that main is frame #2, just that main is frame
	# #2, #3, or higher.  At some point this should be fixed (but
	# it quite possibly would introduce new FAILs on some systems).
	setup_xfail "i*86-*-bsdi2.0"
	gdb_test "backtrace 10" "#0.*handler.*#1.*signal handler.*#2.* main .*" \
	    "backtrace in signals_tests_1"

	gdb_test "break func1" "Breakpoint \[0-9\]+ .*"
	gdb_test "break func2" "Breakpoint \[0-9\]+ .*"

	# Vax Ultrix and i386 BSD currently fail the next test with
	# a SIGTRAP, but with different symptoms.
	setup_xfail "vax-*-ultrix*"
	setup_xfail "i*86-*-bsd*"
	setup_xfail "i*86-*-freebsd*"
	setup_xfail "i*86-pc-linux-gnu*"
	setup_xfail "i*86-*-solaris2*"
	send_gdb "continue\n"
	gdb_expect {
	    -re "Breakpoint.*func1.*$gdb_prompt $" { pass "continue to func1" }
	    -re "Program received signal SIGTRAP.*second.*$gdb_prompt $" {

		# See explanation for `next to 2nd alarm (1)' fail above.
		# We did step into the signal handler, hit a breakpoint
		# in the handler and continued from the breakpoint.
		# The set trace flag in the restored context is causing
		# the SIGTRAP, without stepping an instruction.

		fail "continue to func1 (probably kernel bug)"
		gdb_test "continue" "Breakpoint.*func1.*" \
		    "extra continue to func1"
	    }
	    -re "Program received signal SIGTRAP.*func1 ..;.*$gdb_prompt $" {

		# On the vax under Ultrix the set trace flag in the restored
		# context is causing the SIGTRAP, but after stepping one
		# instruction, as expected.

		fail "continue to func1 (probably kernel bug)"
		gdb_test "continue" "Breakpoint.*func1.*" \
		    "extra continue to func1"
	    }
	    -re ".*$gdb_prompt $" { fail "continue to func1" }
	    default { fail "continue to func1" }
	}

	setup_xfail "*-*-irix*"
	send_gdb "signal SIGUSR1\n"
	gdb_expect {
	    -re "Breakpoint.*handler.*$gdb_prompt $" { pass "signal SIGUSR1" }
	    -re "Program received signal SIGUSR1.*$gdb_prompt $" {
		# This is what irix4 and irix5 do.
		# It would appear to be a kernel bug.
		fail "signal SIGUSR1"
		gdb_test "continue" "Breakpoint.*handler.*" "pass it SIGUSR1"
	    }
	    -re ".*$gdb_prompt $" { fail "signal SIGUSR1" }
	    default { fail "signal SIGUSR1" }
	}

	# Will tend to wrongly require an extra continue.

	# The problem here is that the breakpoint at func1 will be
	# inserted, and when the system finishes with the signal
	# handler it will try to execute there.  For GDB to try to
	# remember that it was going to step over a breakpoint when a
	# signal happened, distinguish this case from the case where
	# func1 is called from the signal handler, etc., seems
	# exceedingly difficult.  So don't expect this to get fixed
	# anytime soon.

	setup_xfail "*-*-*"
	send_gdb "continue\n"
	gdb_expect {
	    -re "Breakpoint.*func2.*$gdb_prompt $" { pass "continue to func2" }
	    -re "Breakpoint.*func1.*$gdb_prompt $" {
	    	fail "continue to func2"
		gdb_test "continue" "Breakpoint.*func2.*" \
		    "extra continue to func2"
	    }
	    -re ".*$gdb_prompt $" { fail "continue to func2" }
	    default { fail "continue to func2" }
	}

	sleep 2

        # GDB yanks out the breakpoints to step over the breakpoint it
        # stopped at, which means the breakpoint at handler is yanked.
	# But if SOFTWARE_SINGLE_STEP_P, we won't get another chance to
	# reinsert them (at least not with procfs, where we tell the kernel
	# not to tell gdb about `pass' signals).  So the fix would appear to
	# be to just yank that one breakpoint when we step over it.

	setup_xfail "sparc*-*-*"
	setup_xfail "rs6000-*-*"
	setup_xfail "powerpc-*-*"

	# A faulty bash will not step the inferior into sigtramp on sun3.
	if {$bash_bug} then {
	    setup_xfail "m68*-*-sunos4*"
	}

	setup_xfail "i*86-pc-linux-gnu*"
	setup_xfail "i*86-*-solaris2*"
	gdb_test "continue" "Breakpoint.*handler.*" "continue to handler"

	# If the SOFTWARE_SINGLE_STEP_P failure happened, we have already
	# exited.
        # If we succeeded a continue will return from the handler to func2.
	# GDB now has `forgotten' that it intended to step over the
	# breakpoint at func2 and will stop at func2.
	setup_xfail "*-*-*"
	# The sun3 with a faulty bash will also be `forgetful' but it
	# already got the spurious stop at func2 and this continue will work.
	if {$bash_bug} then {
	     clear_xfail "m68*-*-sunos4*"
	}
	gdb_test "continue" "Program exited with code 010\\." \
	    "continue to exit in signals_tests_1 "
    }
}

# On a few losing systems, ptrace (PT_CONTINUE) or ptrace (PT_STEP)
# causes pending signals to be cleared, which causes these tests to
# get nowhere fast.  This is totally losing behavior (perhaps there
# are cases in which is it useful but the user needs more control,
# which they mostly have in GDB), but some people apparently think it
# is a feature.  It is documented in the ptrace manpage on Motorola
# Delta Series sysV68 R3V7.1 and on HPUX 9.0.  Even the non-HPUX PA
# OSes (BSD and OSF/1) seem to have figured they had to copy this
# braindamage.

if {[ istarget "m68*-motorola-*" ] || [ istarget "hppa*-*-bsd*" ] ||
    [ istarget "hppa*-*-osf*" ]} then {
  setup_xfail "*-*-*"
  fail "ptrace loses on signals on this target"
  return 0
}

# lynx2.2.2 doesn't lose signals, instead it screws up the stack pointer
# in some of these tests leading to massive problems.  I've
# reported this to lynx, hopefully it'll be fixed in lynx2.3.
# Severe braindamage.
if [ istarget "*-*-*lynx*" ] then {
  setup_xfail "*-*-*"
  fail "kernel scroggs stack pointer in signal tests on this target"
  return 0
}

d54 1
a77 1
signal_tests_1
d79 4
a82 8
# Force a resync, so we're looking at the right prompt.  On SCO we
# were getting out of sync (I don't understand why).
send_gdb "p 1+1\n"
gdb_expect {
    -re "= 2.*$gdb_prompt $" {}
    -re ".*$gdb_prompt $" { perror "sync trouble in signals.exp" }
    default { perror "sync trouble in signals.exp" }
}
a83 3
if [runto_main] then {
    # Since count is a static variable outside main, runto_main
    # is no guarantee that count will be 0 at this point.
d85 9
d97 4
a100 3
    # Get to the point where a signal is waiting to be delivered
    gdb_test "next" "signal \\(SIGUSR1.*" "next to signal in signals.exp"
    gdb_test "next" "alarm \\(.*" "next to alarm #1 in signals.exp"
d102 1
a102 2
	"next to ++count #1 in signals.exp"
    # Give the signal time to get delivered
d105 1
a105 4
    # Now call a function.  When GDB tries to run the stack dummy,
    # it will hit the breakpoint at handler.  Provided it doesn't
    # lose its cool, this is not a problem, it just has to note
    # that the breakpoint condition is false and keep going.
d108 5
a112 1
	"p func1 () #1 in signals.exp"
d114 1
a114 1
    # Make sure the count got incremented.
d116 1
a116 5
    # Haven't investigated this xfail
    setup_xfail "rs6000-*-*"
    setup_xfail "powerpc-*-*"
    gdb_test "p count" "= 2" "p count #1 in signals.exp"
    if { [istarget "rs6000-*-*"] || [istarget "powerpc-*-*"] } { return 0 }
d119 1
a119 1
    gdb_test "next" "alarm \\(.*" "next to alarm #2 in signals.exp"
d121 1
a121 1
	"next to ++count #2 in signals.exp"
d124 2
a125 2
    # This time we stop when GDB tries to run the stack dummy.
    # So it is OK that we do not print the return value from the function.
d129 12
a140 7
	"p func1 () #2 in signals.exp"
    # But we should be able to backtrace...
    # On alpha-*-osf2.0 this test works when run manually but sometime fails when
    # run under dejagnu, making it very hard to debug the problem.  Weird...
    gdb_test "bt 10" "#0.*handler.*#1.*signal handler.*#2.* main .*" "bt in signals.exp"
    # ...and continue...
    gdb_test "continue" "Continuing\\." "continue in signals.exp"
a141 1
    gdb_test "p count" "= 5" "p count #2 in signals.exp"
d143 7
d151 2
a152 10
# Verify that "info signals" produces reasonable output.
#
    send_gdb "info signals\n"
    gdb_expect {
      -re "SIGHUP.*SIGINT.*SIGQUIT.*SIGILL.*SIGTRAP.*SIGABRT.*SIGEMT.*SIGFPE.*SIGKILL.*SIGBUS.*SIGSEGV.*SIGSYS.*SIGPIPE.*SIGALRM.*SIGTERM.*SIGURG.*SIGSTOP.*SIGTSTP.*SIGCONT.*SIGCHLD.*SIGTTIN.*SIGTTOU.*SIGIO.*SIGXCPU.*SIGXFSZ.*SIGVTALRM.*SIGPROF.*SIGWINCH.*SIGLOST.*SIGUSR1.*SIGUSR2.*SIGPWR.*SIGPOLL.*SIGWIND.*SIGPHONE.*SIGWAITING.*SIGLWP.*SIGDANGER.*SIGGRANT.*SIGRETRACT.*SIGMSG.*SIGSOUND.*SIGSAK.*SIGPRIO.*SIG33.*SIG34.*SIG35.*SIG36.*SIG37.*SIG38.*SIG39.*SIG40.*SIG41.*SIG42.*SIG43.*SIG44.*SIG45.*SIG46.*SIG47.*SIG48.*SIG49.*SIG50.*SIG51.*SIG52.*SIG53.*SIG54.*SIG55.*SIG56.*SIG57.*SIG58.*SIG59.*SIG60.*SIG61.*SIG62.*SIG63.*Use the \"handle\" command to change these tables.*$gdb_prompt $"\
              {pass "info signals"}
      -re "$gdb_prompt $"\
              {fail "info signals"}
      timeout {fail "(timeout) info signals"}
    }
d154 3
a156 11
# Verify that "info signal" correctly handles an argument, be it a
# symbolic signal name, or an integer ID.
#
    send_gdb "info signal SIGTRAP\n"
    gdb_expect {
      -re ".*SIGTRAP\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*No\[ \t\]*Trace/breakpoint trap.*$gdb_prompt $"\
              {pass "info signal SIGTRAP"}
      -re "$gdb_prompt $"\
              {fail "info signal SIGTRAP"}
      timeout {fail "(timeout) info signal SIGTRAP"}
    }
d158 3
a160 8
    send_gdb "info signal 5\n"
    gdb_expect {
      -re ".*SIGTRAP\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*No\[ \t\]*Trace/breakpoint trap.*$gdb_prompt $"\
              {pass "info signal 5"}
      -re "$gdb_prompt $"\
              {fail "info signal 5"}
      timeout {fail "(timeout) info signal 5"}
    }
d162 2
a163 10
# Verify that "handle" with illegal arguments is gracefully, um, handled.
#
    send_gdb "handle\n"
    gdb_expect {
      -re "Argument required .signal to handle.*$gdb_prompt $"\
              {pass "handle without arguments"}
      -re "$gdb_prompt $"\
              {fail "handle without arguments"}
      timeout {fail "(timeout) handle without arguments"}
    }
d165 3
a167 8
    send_gdb "handle SIGFOO\n"
    gdb_expect {
      -re "Unrecognized or ambiguous flag word: \"SIGFOO\".*$gdb_prompt $"\
              {pass "handle with bogus SIG"}
      -re "$gdb_prompt $"\
              {fail "handle with bogus SIG"}
      timeout {fail "(timeout) handle with bogus SIG"}
    }
d169 3
a171 8
    send_gdb "handle SIGHUP frump\n"
    gdb_expect {
      -re "Unrecognized or ambiguous flag word: \"frump\".*$gdb_prompt $"\
              {pass "handle SIG with bogus action"}
      -re "$gdb_prompt $"\
              {fail "handle SIG with bogus action"}
      timeout {fail "(timeout) handle SIG with bogus action"}
    }
d173 3
a175 11
# Verify that "handle" can take multiple actions per SIG, and that in
# the case of conflicting actions, that the rightmost action "wins".
#
    send_gdb "handle SIGHUP print noprint\n"
    gdb_expect {
      -re ".*SIGHUP\[ \t\]*No\[ \t\]*No\[ \t\]*Yes\[ \t\]*Hangup.*$gdb_prompt $"\
              {pass "handle SIG with multiple conflicting actions"}
      -re "$gdb_prompt $"\
              {fail "handle SIG with multiple conflicting actions"}
      timeout {fail "(timeout) handle SIG with multiple conflicting actions"}
    }
d177 3
a179 11
# Exercise all the various actions.  (We don't care what the outcome
# is, this is just to ensure that they all can be parsed.)
#
    send_gdb "handle SIGHUP print noprint stop nostop ignore noignore pass nopass\n"
    gdb_expect {
      -re ".*Signal.*$gdb_prompt $"\
              {pass "handle SIG parses all legal actions"}
      -re "$gdb_prompt $"\
              {fail "handle SIG parses all legal actions"}
      timeout {fail "(timeout) handle SIG parses all legal actions"}
    }
d181 3
a183 11
# Verify that we can "handle" multiple signals at once, interspersed
# with actions.
#
    send_gdb "handle SIG63 print SIGILL\n"
    gdb_expect {
      -re ".*SIGILL\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*Illegal instruction.*SIG63\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*Real-time event 63.*$gdb_prompt $"\
              {pass "handle multiple SIGs"}
      -re "$gdb_prompt $"\
              {fail "handle multiple SIGs"}
      timeout {fail "(timeout) handle multiple SIGs"}
    }
d185 2
a186 24
# Verify that "handle" can take a numeric argument for the signal ID,
# rather than a symbolic name.  (This may not be portable; works for
# HP-UX.)
#
# Also note that this testpoint overrides SIGTRAP, which on HP-UX at
# least, is used to implement single-steps and breakpoints.  Don't
# expect to run the inferior after this!
#
    send_gdb "handle 5 nopass\n"
    gdb_expect {
      -re ".*SIGTRAP is used by the debugger.*Are you sure you want to change it.*y or n.*"\
              {send_gdb "y\n"
               gdb_expect {
                 -re ".*SIGTRAP\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*No\[ \t\]*Trace/breakpoint trap.*$gdb_prompt $"\
                         {pass "override SIGTRAP (#5)"}
                 -re "$gdb_prompt $"\
                         {fail "override SIGTRAP (#5)"}
                 timeout {fail "(timeout) override SIGTRAP (#5)"}
               }
              }
      -re "$gdb_prompt $"\
              {fail "override SIGTRAP (#5)"}
      timeout {fail "(timeout) override SIGTRAP (#5)"}
    }
d188 3
a190 12
# GDB doesn't seem to allow numeric signal IDs larger than 15.  Verify
# that restriction.  ??rehrauer: Not sure if this is a feature or a
# bug, actually.  Why is the range 1-15?
#
    send_gdb "handle 58\n"
    gdb_expect {
      -re "Only signals 1-15 are valid as numeric signals.*Use \"info signals\" for a list of symbolic signals.*$gdb_prompt $"\
              {pass "invalid signal number rejected"}
      -re "$gdb_prompt $"\
              {fail "invalid signal number rejected"}
      timeout {fail "(timeout) invalid signal number rejected"}
    }
d192 2
a193 11
# Verify that we can accept a signal ID range (number-number).
# ??rehrauer: This feature isn't documented on the quick-reference
# card.
#
    send_gdb "handle 13-15\n"
    gdb_expect {
      -re ".*SIGPIPE.*SIGALRM.*SIGTERM.*$gdb_prompt $"\
              {pass "handle multiple SIGs via integer range"}
      -re "$gdb_prompt $"\
              {fail "handle multiple SIGs via integer range"}
      timeout {fail "(timeout) handle multiple SIGs via integer range"}
d195 3
a197 1
    }
d199 3
a201 12
# Bizarrely enough, GDB also allows you to reverse the range
# stat, stop IDs.  E.g., "3-1" and "1-3" mean the same thing.
# Probably this isn't documented, but the code anticipates it,
# so we'd best test it...
#
    send_gdb "handle 15-13\n"
    gdb_expect {
      -re ".*SIGPIPE.*SIGALRM.*SIGTERM.*$gdb_prompt $"\
              {pass "handle multiple SIGs via integer range"}
      -re "$gdb_prompt $"\
              {fail "handle multiple SIGs via integer range"}
      timeout {fail "(timeout) handle multiple SIGs via integer range"}
d203 3
a205 1
    }
d207 7
a213 21
# SIGINT is used by the debugger as well.  Verify that we can change
# our minds about changing it.
#
    send_gdb "handle SIGINT nopass\n"
    gdb_expect {
      -re ".*SIGINT is used by the debugger.*Are you sure you want to change it.*y or n.*"\
              {send_gdb "n\n"
# ??rehrauer: When you answer "n", the header for the signal info is
# printed, but not the actual handler settings.  Probably a bug.
#
               gdb_expect {
                 -re "Not confirmed, unchanged.*Signal.*$gdb_prompt $"\
                         {pass "override SIGINT"}
                 -re "$gdb_prompt $"\
                         {fail "override SIGINT"}
                 timeout {fail "(timeout) override SIGINT"}
               }
              }
      -re "$gdb_prompt $"\
              {fail "override SIGINT"}
      timeout {fail "(timeout) override SIGINT"}
d216 41
a256 10
# Verify that GDB responds gracefully to the "signal" command with
# a missing argument.
#
    send_gdb "signal\n"
    gdb_expect {
      -re "Argument required .signal number..*$gdb_prompt $"\
              {pass "signal without arguments disallowed"}
      -re "$gdb_prompt $"\
              {fail "signal without arguments disallowed"}
      timeout {fail "(timeout) signal without arguments disallowed"}
d259 2
a260 12
# Verify that we can successfully send a signal other than 0 to
# the inferior.  (This probably causes the inferior to run away.
# Be prepared to rerun to main for further testing.)
#
    send_gdb "signal 5\n"
    gdb_expect {
      -re "Continuing with signal SIGTRAP.*$gdb_prompt $"\
              {pass "sent signal 5"}
      -re "$gdb_prompt $"\
              {fail "sent signal 5"}
      timeout {fail "(timeout) sent signal 5"}
    }
d262 12
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d1 23
a23 4
if $nosignals {
	verbose "Skipping signals.exp because of nosignals."
	continue
	}
d35 2
a36 3
if  { [compile "${srcdir}/${subdir}/${srcfile} -g -o ${binfile}"] != "" } {
    perror "Couldn't compile ${srcfile}"
    return -1
d41 8
a48 4
execute_anywhere "rm -f ${binfile}.ci"
if  { [compile "-E ${srcdir}/${subdir}/compiler.c > ${binfile}.ci"] != "" } {
    perror "Couldn't make ${binfile}.ci file"
    return -1
a49 1
source ${binfile}.ci
d52 1
a52 1
    global prompt
d61 1
a61 1
	exec sleep 2
d75 5
a79 5
	setup_xfail "i*86-*-linuxaout" "i*86-*-linuxoldld"
	send "next\n"
	expect {
	    -re "alarm .*$prompt $" { pass "next to 2nd alarm (1)" }
	    -re "Program received signal SIGTRAP.*first.*$prompt $" {
d106 13
d122 1
a122 1
	    -re "Program exited with code.*$prompt $" {
d155 1
a155 1
	    -re ".*$prompt $" { fail "next to 2nd alarm (1)" }
d164 1
a164 1
	exec sleep 2
d167 3
a169 4
	send "next\n"
	setup_xfail "i*86-*-linux"
	expect {
	    -re "Breakpoint.*handler.*$prompt $" {
d172 1
a172 1
	    -re "Program received signal SIGEMT.*$prompt $" {
d179 1
a179 1
	    -re ".*$prompt $" { fail "next to handler in signals_tests_1" }
d187 2
a188 2
	setup_xfail "i*86-*-linux" "i*86-*-bsdi2.0"
	gdb_test "backtrace" "#0.*handler.*#1.*#2.*main.*" \
d198 7
a204 5
	setup_xfail "i*86-*-linux"
	send "continue\n"
	expect {
	    -re "Breakpoint.*func1.*$prompt $" { pass "continue to func1" }
	    -re "Program received signal SIGTRAP.*second.*$prompt $" {
d216 1
a216 1
	    -re "Program received signal SIGTRAP.*func1 ..;.*$prompt $" {
d226 1
a226 1
	    -re ".*$prompt $" { fail "continue to func1" }
d231 4
a234 5
	setup_xfail "i*86-*-linux"
	send "signal SIGUSR1\n"
	expect {
	    -re "Breakpoint.*handler.*$prompt $" { pass "signal SIGUSR1" }
	    -re "Program received signal SIGUSR1.*$prompt $" {
d240 1
a240 1
	    -re ".*$prompt $" { fail "signal SIGUSR1" }
d256 4
a259 4
	send "continue\n"
	expect {
	    -re "Breakpoint.*func2.*$prompt $" { pass "continue to func2" }
	    -re "Breakpoint.*func1.*$prompt $" {
d264 1
a264 1
	    -re ".*$prompt $" { fail "continue to func2" }
d268 1
a268 1
	exec sleep 2
d272 3
a274 3
	# But if NO_SINGLE_STEP, we won't get another chance to reinsert
	# them (at least not with procfs, where we tell the kernel not
	# to tell gdb about `pass' signals).  So the fix would appear to
d286 2
a287 1
	setup_xfail "i*86-*-linux"
d290 3
a292 2
	# If the NO_SINGLE_STEP failure happened, we have already exited.
	# If we succeeded a continue will return from the handler to func2.
d317 1
a317 1
    [ istarget "*-*-hpux*" ] || [ istarget "hppa*-*-osf*" ]} then {
d346 7
a352 2
    match_max 10000
    gdb_test "handle all print" "Signal\[ 	\]+Stop\[ 	\]+Print\[ 	\]+Pass to program\[ 	\]+Description\r\nSIGHUP\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Hangup.*SIG63\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Real-time event 63.*EXC_BREAKPOINT\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Breakpoint"
d366 4
a369 4
send "p 1+1\n"
expect {
    -re "= 2.*$prompt $" {}
    -re ".*$prompt $" { perror "sync trouble in signals.exp" }
d374 3
d386 1
a386 1
    exec sleep 2
d393 1
a393 1
    gdb_test "p func1 ()" "^p func1 \\(\\)\r\n.\[0-9\]* = void" \
d408 1
a408 1
    exec sleep 2
d419 1
a419 1
    gdb_test "bt" "#0.*handler.*#1.*#2.*main.*" "bt in signals.exp"
d424 214
@


1.1
log
@file signals.exp was initially added on branch CYGNUS.
@
text
@d1 382
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 640
#   Copyright 1997, 1998, 1999, 2003 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

if [target_info exists gdb,nosignals] {
    verbose "Skipping signals.exp because of nosignals."
    continue
}

if $tracelevel then {
	strace $tracelevel
}

set prms_id 0
set bug_id 0

set testfile signals
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}
if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

# Create and source the file that provides information about the compiler
# used to compile the test case.
if [get_compiler_info ${binfile}] {
    return -1;
}

if {$hp_cc_compiler} {
    set void 0
} else {
    set void void
}

proc signal_tests_1 {} {
    global gdb_prompt
    if [runto_main] then {
	gdb_test "next" "signal \\(SIGUSR1.*" \
		"next over signal (SIGALRM, handler)"
	gdb_test "next" "alarm \\(.*" \
		"next over signal (SIGUSR1, handler)"
	gdb_test "next" "\\+\\+count; /\\* first \\*/" \
		"next over alarm (1)"
	# An alarm has been signaled, give the signal time to get delivered.
	sleep 2

	# i386 BSD currently fails the next test with a SIGTRAP.
	setup_xfail "i*86-*-bsd*"
	# But Dynix has a DECR_PC_AFTER_BREAK of zero, so the failure
	# is shadowed by hitting the through_sigtramp_breakpoint.
	clear_xfail "i*86-sequent-bsd*"
	# Univel SVR4 i386 continues instead of stepping.
	setup_xfail "i*86-univel-sysv4*"
	# lynx fails with "next" acting like "continue"
	setup_xfail "*-*-*lynx*"
	# linux (aout versions) also fails with "next" acting like "continue"
	# this is probably more dependant on the kernel version than on the
	# object file format or utils.  (sigh)
	setup_xfail "i*86-pc-linuxaout-gnu" "i*86-pc-linuxoldld-gnu"
	send_gdb "next\n"
	gdb_expect {
	    -re "alarm .*$gdb_prompt $" { pass "next to 2nd alarm (1)" }
	    -re "Program received signal SIGTRAP.*first.*$gdb_prompt $" {

		# This can happen on machines that have a trace flag
		# in their PS register.
		# The trace flag in the PS register will be set due to
		# the `next' command.
		# Before calling the signal handler, the PS register
		# is pushed along with the context on the user stack.
		# When the signal handler has finished, it reenters the
		# the kernel via a sigreturn syscall, which restores the
		# PS register along with the context.
		# If the kernel erroneously does not clear the trace flag
		# in the pushed context, gdb will receive a SIGTRAP from
		# the set trace flag in the restored context after the
		# signal handler has finished.

		# I do not yet understand why the SIGTRAP does not occur
		# after stepping the instruction at the restored PC on
		# i386 BSDI 1.0 systems.

		# Note that the vax under Ultrix also exhibits
		# this behaviour (it is uncovered by the `continue from
		# a break in a signal handler' test below).
		# With this test the failure is shadowed by hitting the
		# through_sigtramp_breakpoint upon return from the signal
		# handler.

		# SVR4 and Linux based i*86 systems exhibit this behaviour
		# as well (it is uncovered by the `continue from a break
		# in a signal handler' test below).
		# As these systems use procfs, where we tell the kernel not
		# to tell gdb about `pass' signals, and the trace flag is
		# cleared by the kernel before entering the sigtramp
		# routine, GDB will not notice the execution of the signal 
		# handler.
		# Upon return from the signal handler, GDB will receive
		# a SIGTRAP from the set trace flag in the restored context.
		# The SIGTRAP marks the end of a (albeit long winded)
		# single step for GDB, causing this test to pass.

		fail "next to 2nd alarm (1) (probably kernel bug)"
		gdb_test "next" "alarm.*" "next to 2nd alarm (1)"
	    }
	    -re "Program exited with code.*$gdb_prompt $" {

		# This is apparently a bug in the UnixWare kernel (but
		# has not been investigated beyond the
		# resume/target_wait level, and has not been reported
		# to Univel).  If it steps when a signal is pending,
		# it does a continue instead.  I don't know whether
		# there is a workaround.

		# Perhaps this problem exists on other SVR4 systems;
		# but (a) we have no reason to think so, and (b) if we
		# put a wrong xfail here, we never get an XPASS to let
		# us know that it was incorrect (and then if such a
		# configuration regresses we have no way of knowing).
		# Solaris is not a relevant data point either way
		# because it lacks single stepping.

		# fnf: I don't agree with the above philosophy.  We
		# can never be sure that any particular XFAIL is
		# specified 100% correctly in that no systems with
		# the bug are missed and all systems without the bug
		# are excluded.  If we include an XFAIL that isn't
		# appropriate for a particular system, then when that
		# system gets tested it will XPASS, and someone should
		# investigate and fix the setup_xfail as appropriate,
		# or more preferably, the actual bug.  Each such case
		# adds more data to narrowing down the scope of the
		# problem and ultimately fixing it.

		setup_xfail "i*86-*-sysv4*"
		fail "'next' behaved as 'continue (known SVR4 bug)'"
		return 0
	    }
	    -re ".*$gdb_prompt $" { fail "next to 2nd alarm (1)" }
	    timeout { fail "next to 2nd alarm (1); (timeout)" }
	    eof { fail "next to 2nd alarm (1); (eof)" }
	}

	gdb_test "break handler" "Breakpoint \[0-9\]+ .*"
	gdb_test "next" "\\+\\+count; /\\* second \\*/" \
	    "next to 2nd ++count in signals_tests_1"
	# An alarm has been signaled, give the signal time to get delivered.
	sleep 2

	set bash_bug 0
	send_gdb "next\n"
	gdb_expect {
	    -re "Breakpoint.*handler.*$gdb_prompt $" {
		pass "next to handler in signals_tests_1"
	    }
	    -re "Program received signal SIGEMT.*$gdb_prompt $" {
		# Bash versions before 1.13.5 cause this behaviour
		# by blocking SIGTRAP.
		fail "next to handler in signals_tests_1 (known problem with bash versions before 1.13.5)"
		set bash_bug 1
		gdb_test "signal 0" "Breakpoint.*handler.*"
	    }
	    -re ".*$gdb_prompt $" { fail "next to handler in signals_tests_1" }
	    timeout { fail "next to handler in signals_tests_1 (timeout)" }
	    eof { fail "next to handler in signals_tests_1 (eof)" }
	}

	# This doesn't test that main is frame #2, just that main is frame
	# #2, #3, or higher.  At some point this should be fixed (but
	# it quite possibly would introduce new FAILs on some systems).
	setup_xfail "i*86-*-bsdi2.0"
	gdb_test "backtrace 10" "#0.*handler.*#1.*signal handler.*#2.* main .*" \
	    "backtrace in signals_tests_1"

	gdb_test "break func1" "Breakpoint \[0-9\]+ .*"
	gdb_test "break func2" "Breakpoint \[0-9\]+ .*"

	# Vax Ultrix and i386 BSD currently fail the next test with
	# a SIGTRAP, but with different symptoms.
	setup_xfail "vax-*-ultrix*"
	setup_xfail "i*86-*-bsd*"
	setup_xfail "i*86-*-freebsd*"
	setup_xfail "i*86-pc-linux-gnu*"
	setup_xfail "i*86-*-solaris2*"
	send_gdb "continue\n"
	gdb_expect {
	    -re "Breakpoint.*func1.*$gdb_prompt $" { pass "continue to func1" }
	    -re "Program received signal SIGTRAP.*second.*$gdb_prompt $" {

		# See explanation for `next to 2nd alarm (1)' fail above.
		# We did step into the signal handler, hit a breakpoint
		# in the handler and continued from the breakpoint.
		# The set trace flag in the restored context is causing
		# the SIGTRAP, without stepping an instruction.

		fail "continue to func1 (probably kernel bug)"
		gdb_test "continue" "Breakpoint.*func1.*" \
		    "extra continue to func1"
	    }
	    -re "Program received signal SIGTRAP.*func1 ..;.*$gdb_prompt $" {

		# On the vax under Ultrix the set trace flag in the restored
		# context is causing the SIGTRAP, but after stepping one
		# instruction, as expected.

		fail "continue to func1 (probably kernel bug)"
		gdb_test "continue" "Breakpoint.*func1.*" \
		    "extra continue to func1"
	    }
	    -re ".*$gdb_prompt $" { fail "continue to func1" }
	    default { fail "continue to func1" }
	}

	setup_xfail "*-*-irix*"
	send_gdb "signal SIGUSR1\n"
	gdb_expect {
	    -re "Breakpoint.*handler.*$gdb_prompt $" { pass "signal SIGUSR1" }
	    -re "Program received signal SIGUSR1.*$gdb_prompt $" {
		# This is what irix4 and irix5 do.
		# It would appear to be a kernel bug.
		fail "signal SIGUSR1"
		gdb_test "continue" "Breakpoint.*handler.*" "pass it SIGUSR1"
	    }
	    -re ".*$gdb_prompt $" { fail "signal SIGUSR1" }
	    default { fail "signal SIGUSR1" }
	}

	# Will tend to wrongly require an extra continue.

	# The problem here is that the breakpoint at func1 will be
	# inserted, and when the system finishes with the signal
	# handler it will try to execute there.  For GDB to try to
	# remember that it was going to step over a breakpoint when a
	# signal happened, distinguish this case from the case where
	# func1 is called from the signal handler, etc., seems
	# exceedingly difficult.  So don't expect this to get fixed
	# anytime soon.

	setup_xfail "*-*-*"
	send_gdb "continue\n"
	gdb_expect {
	    -re "Breakpoint.*func2.*$gdb_prompt $" { pass "continue to func2" }
	    -re "Breakpoint.*func1.*$gdb_prompt $" {
	    	fail "continue to func2"
		gdb_test "continue" "Breakpoint.*func2.*" \
		    "extra continue to func2"
	    }
	    -re ".*$gdb_prompt $" { fail "continue to func2" }
	    default { fail "continue to func2" }
	}

	sleep 2

        # GDB yanks out the breakpoints to step over the breakpoint it
        # stopped at, which means the breakpoint at handler is yanked.
	# But if SOFTWARE_SINGLE_STEP_P, we won't get another chance to
	# reinsert them (at least not with procfs, where we tell the kernel
	# not to tell gdb about `pass' signals).  So the fix would appear to
	# be to just yank that one breakpoint when we step over it.

	setup_xfail "sparc*-*-*"
	setup_xfail "rs6000-*-*"
	setup_xfail "powerpc-*-*"

	# A faulty bash will not step the inferior into sigtramp on sun3.
	if {$bash_bug} then {
	    setup_xfail "m68*-*-sunos4*"
	}

	setup_xfail "i*86-pc-linux-gnu*"
	setup_xfail "i*86-*-solaris2*"
	gdb_test "continue" "Breakpoint.*handler.*" "continue to handler"

	# If the SOFTWARE_SINGLE_STEP_P failure happened, we have already
	# exited.
        # If we succeeded a continue will return from the handler to func2.
	# GDB now has `forgotten' that it intended to step over the
	# breakpoint at func2 and will stop at func2.
	setup_xfail "*-*-*"
	# The sun3 with a faulty bash will also be `forgetful' but it
	# already got the spurious stop at func2 and this continue will work.
	if {$bash_bug} then {
	     clear_xfail "m68*-*-sunos4*"
	}
	gdb_test "continue" "Program exited with code 010\\." \
	    "continue to exit in signals_tests_1 "
    }
}

# On a few losing systems, ptrace (PT_CONTINUE) or ptrace (PT_STEP)
# causes pending signals to be cleared, which causes these tests to
# get nowhere fast.  This is totally losing behavior (perhaps there
# are cases in which is it useful but the user needs more control,
# which they mostly have in GDB), but some people apparently think it
# is a feature.  It is documented in the ptrace manpage on Motorola
# Delta Series sysV68 R3V7.1 and on HPUX 9.0.  Even the non-HPUX PA
# OSes (BSD and OSF/1) seem to have figured they had to copy this
# braindamage.

if {[ istarget "m68*-motorola-*" ] || [ istarget "hppa*-*-bsd*" ] ||
    [ istarget "hppa*-*-osf*" ]} then {
  setup_xfail "*-*-*"
  fail "ptrace loses on signals on this target"
  return 0
}

# lynx2.2.2 doesn't lose signals, instead it screws up the stack pointer
# in some of these tests leading to massive problems.  I've
# reported this to lynx, hopefully it'll be fixed in lynx2.3.
# Severe braindamage.
if [ istarget "*-*-*lynx*" ] then {
  setup_xfail "*-*-*"
  fail "kernel scroggs stack pointer in signal tests on this target"
  return 0
}

gdb_exit
gdb_start

# This will need to be updated as the exact list of signals changes,
# but I want to test that TARGET_SIGNAL_0, TARGET_SIGNAL_DEFAULT, and
# TARGET_SIGNAL_UNKNOWN are skipped.
proc test_handle_all_print {} {
    global timeout
    # Increase timeout and expect input buffer for large output from gdb.
    # Allow blank or TAB as whitespace characters.
    set oldtimeout $timeout
    set timeout [expr "$timeout + 360"]
    verbose "Timeout is now $timeout seconds" 2
    if { ![istarget "*-*-linux*"]
         && ( [istarget "*-*-gnu*"]
              || [istarget "*-*-mach*"] ) } {
	gdb_test "handle all print" "Signal\[ 	\]+Stop\[ 	\]+Print\[ 	\]+Pass to program\[ 	\]+Description\r\nSIGHUP\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Hangup.*SIG63\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Real-time event 63.*EXC_BREAKPOINT\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Breakpoint"
    } else {
	gdb_test "handle all print" "Signal\[ 	\]+Stop\[ 	\]+Print\[ 	\]+Pass to program\[ 	\]+Description\r\nSIGHUP\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Hangup.*SIG63\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Real-time event 63.*"
    }
    set timeout $oldtimeout
    verbose "Timeout restored to $timeout seconds" 2
}
test_handle_all_print

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load $binfile
signal_tests_1

# Force a resync, so we're looking at the right prompt.  On SCO we
# were getting out of sync (I don't understand why).
send_gdb "p 1+1\n"
gdb_expect {
    -re "= 2.*$gdb_prompt $" {}
    -re ".*$gdb_prompt $" { perror "sync trouble in signals.exp" }
    default { perror "sync trouble in signals.exp" }
}

if [runto_main] then {
    # Since count is a static variable outside main, runto_main
    # is no guarantee that count will be 0 at this point.
    gdb_test "set variable count = 0" ""
    gdb_test "break handler if 0" "Breakpoint \[0-9\]+ .*"
    gdb_test "set \$handler_breakpoint_number = \$bpnum" ""

    # Get to the point where a signal is waiting to be delivered
    gdb_test "next" "signal \\(SIGUSR1.*" "next to signal in signals.exp"
    gdb_test "next" "alarm \\(.*" "next to alarm #1 in signals.exp"
    gdb_test "next" "\\+\\+count; /\\* first \\*/" \
	"next to ++count #1 in signals.exp"
    # Give the signal time to get delivered
    sleep 2

    # Now call a function.  When GDB tries to run the stack dummy,
    # it will hit the breakpoint at handler.  Provided it doesn't
    # lose its cool, this is not a problem, it just has to note
    # that the breakpoint condition is false and keep going.

    gdb_test "p func1 ()" "^p func1 \\(\\)\r\n.\[0-9\]* = $void" \
	"p func1 () #1 in signals.exp"

    # Make sure the count got incremented.

    # Haven't investigated this xfail
    setup_xfail "rs6000-*-*"
    setup_xfail "powerpc-*-*"
    gdb_test "p count" "= 2" "p count #1 in signals.exp"
    if { [istarget "rs6000-*-*"] || [istarget "powerpc-*-*"] } { return 0 }

    gdb_test "condition \$handler_breakpoint_number" "now unconditional\\."
    gdb_test "next" "alarm \\(.*" "next to alarm #2 in signals.exp"
    gdb_test "next" "\\+\\+count; /\\* second \\*/" \
	"next to ++count #2 in signals.exp"
    sleep 2

    # This time we stop when GDB tries to run the stack dummy.
    # So it is OK that we do not print the return value from the function.
    gdb_test "p func1 ()" \
"Breakpoint \[0-9\]*, handler.*
The program being debugged stopped while in a function called from GDB.*" \
	"p func1 () #2 in signals.exp"
    # But we should be able to backtrace...
    # On alpha-*-osf2.0 this test works when run manually but sometime fails when
    # run under dejagnu, making it very hard to debug the problem.  Weird...
    gdb_test "bt 10" "#0.*handler.*#1.*signal handler.*#2.* main .*" "bt in signals.exp"
    # ...and continue...
    gdb_test "continue" "Continuing\\." "continue in signals.exp"
    # ...and then count should have been incremented
    gdb_test "p count" "= 5" "p count #2 in signals.exp"


# Verify that "info signals" produces reasonable output.
#
    send_gdb "info signals\n"
    gdb_expect {
      -re "SIGHUP.*SIGINT.*SIGQUIT.*SIGILL.*SIGTRAP.*SIGABRT.*SIGEMT.*SIGFPE.*SIGKILL.*SIGBUS.*SIGSEGV.*SIGSYS.*SIGPIPE.*SIGALRM.*SIGTERM.*SIGURG.*SIGSTOP.*SIGTSTP.*SIGCONT.*SIGCHLD.*SIGTTIN.*SIGTTOU.*SIGIO.*SIGXCPU.*SIGXFSZ.*SIGVTALRM.*SIGPROF.*SIGWINCH.*SIGLOST.*SIGUSR1.*SIGUSR2.*SIGPWR.*SIGPOLL.*SIGWIND.*SIGPHONE.*SIGWAITING.*SIGLWP.*SIGDANGER.*SIGGRANT.*SIGRETRACT.*SIGMSG.*SIGSOUND.*SIGSAK.*SIGPRIO.*SIG33.*SIG34.*SIG35.*SIG36.*SIG37.*SIG38.*SIG39.*SIG40.*SIG41.*SIG42.*SIG43.*SIG44.*SIG45.*SIG46.*SIG47.*SIG48.*SIG49.*SIG50.*SIG51.*SIG52.*SIG53.*SIG54.*SIG55.*SIG56.*SIG57.*SIG58.*SIG59.*SIG60.*SIG61.*SIG62.*SIG63.*Use the \"handle\" command to change these tables.*$gdb_prompt $"\
              {pass "info signals"}
      -re "$gdb_prompt $"\
              {fail "info signals"}
      timeout {fail "(timeout) info signals"}
    }

# Verify that "info signal" correctly handles an argument, be it a
# symbolic signal name, or an integer ID.
#
    send_gdb "info signal SIGTRAP\n"
    gdb_expect {
      -re ".*SIGTRAP\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*No\[ \t\]*Trace/breakpoint trap.*$gdb_prompt $"\
              {pass "info signal SIGTRAP"}
      -re "$gdb_prompt $"\
              {fail "info signal SIGTRAP"}
      timeout {fail "(timeout) info signal SIGTRAP"}
    }

    send_gdb "info signal 5\n"
    gdb_expect {
      -re ".*SIGTRAP\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*No\[ \t\]*Trace/breakpoint trap.*$gdb_prompt $"\
              {pass "info signal 5"}
      -re "$gdb_prompt $"\
              {fail "info signal 5"}
      timeout {fail "(timeout) info signal 5"}
    }

# Verify that "handle" with illegal arguments is gracefully, um, handled.
#
    send_gdb "handle\n"
    gdb_expect {
      -re "Argument required .signal to handle.*$gdb_prompt $"\
              {pass "handle without arguments"}
      -re "$gdb_prompt $"\
              {fail "handle without arguments"}
      timeout {fail "(timeout) handle without arguments"}
    }

    send_gdb "handle SIGFOO\n"
    gdb_expect {
      -re "Unrecognized or ambiguous flag word: \"SIGFOO\".*$gdb_prompt $"\
              {pass "handle with bogus SIG"}
      -re "$gdb_prompt $"\
              {fail "handle with bogus SIG"}
      timeout {fail "(timeout) handle with bogus SIG"}
    }

    send_gdb "handle SIGHUP frump\n"
    gdb_expect {
      -re "Unrecognized or ambiguous flag word: \"frump\".*$gdb_prompt $"\
              {pass "handle SIG with bogus action"}
      -re "$gdb_prompt $"\
              {fail "handle SIG with bogus action"}
      timeout {fail "(timeout) handle SIG with bogus action"}
    }

# Verify that "handle" can take multiple actions per SIG, and that in
# the case of conflicting actions, that the rightmost action "wins".
#
    send_gdb "handle SIGHUP print noprint\n"
    gdb_expect {
      -re ".*SIGHUP\[ \t\]*No\[ \t\]*No\[ \t\]*Yes\[ \t\]*Hangup.*$gdb_prompt $"\
              {pass "handle SIG with multiple conflicting actions"}
      -re "$gdb_prompt $"\
              {fail "handle SIG with multiple conflicting actions"}
      timeout {fail "(timeout) handle SIG with multiple conflicting actions"}
    }

# Exercise all the various actions.  (We don't care what the outcome
# is, this is just to ensure that they all can be parsed.)
#
    send_gdb "handle SIGHUP print noprint stop nostop ignore noignore pass nopass\n"
    gdb_expect {
      -re ".*Signal.*$gdb_prompt $"\
              {pass "handle SIG parses all legal actions"}
      -re "$gdb_prompt $"\
              {fail "handle SIG parses all legal actions"}
      timeout {fail "(timeout) handle SIG parses all legal actions"}
    }

# Verify that we can "handle" multiple signals at once, interspersed
# with actions.
#
    send_gdb "handle SIG63 print SIGILL\n"
    gdb_expect {
      -re ".*SIGILL\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*Illegal instruction.*SIG63\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*Real-time event 63.*$gdb_prompt $"\
              {pass "handle multiple SIGs"}
      -re "$gdb_prompt $"\
              {fail "handle multiple SIGs"}
      timeout {fail "(timeout) handle multiple SIGs"}
    }

# Verify that "handle" can take a numeric argument for the signal ID,
# rather than a symbolic name.  (This may not be portable; works for
# HP-UX.)
#
# Also note that this testpoint overrides SIGTRAP, which on HP-UX at
# least, is used to implement single-steps and breakpoints.  Don't
# expect to run the inferior after this!
#
    send_gdb "handle 5 nopass\n"
    gdb_expect {
      -re ".*SIGTRAP is used by the debugger.*Are you sure you want to change it.*y or n.*"\
              {send_gdb "y\n"
               gdb_expect {
                 -re ".*SIGTRAP\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*No\[ \t\]*Trace/breakpoint trap.*$gdb_prompt $"\
                         {pass "override SIGTRAP (#5)"}
                 -re "$gdb_prompt $"\
                         {fail "override SIGTRAP (#5)"}
                 timeout {fail "(timeout) override SIGTRAP (#5)"}
               }
              }
      -re "$gdb_prompt $"\
              {fail "override SIGTRAP (#5)"}
      timeout {fail "(timeout) override SIGTRAP (#5)"}
    }

# GDB doesn't seem to allow numeric signal IDs larger than 15.  Verify
# that restriction.  ??rehrauer: Not sure if this is a feature or a
# bug, actually.  Why is the range 1-15?
#
    send_gdb "handle 58\n"
    gdb_expect {
      -re "Only signals 1-15 are valid as numeric signals.*Use \"info signals\" for a list of symbolic signals.*$gdb_prompt $"\
              {pass "invalid signal number rejected"}
      -re "$gdb_prompt $"\
              {fail "invalid signal number rejected"}
      timeout {fail "(timeout) invalid signal number rejected"}
    }

# Verify that we can accept a signal ID range (number-number).
# ??rehrauer: This feature isn't documented on the quick-reference
# card.
#
    send_gdb "handle 13-15\n"
    gdb_expect {
      -re ".*SIGPIPE.*SIGALRM.*SIGTERM.*$gdb_prompt $"\
              {pass "handle multiple SIGs via integer range"}
      -re "$gdb_prompt $"\
              {fail "handle multiple SIGs via integer range"}
      timeout {fail "(timeout) handle multiple SIGs via integer range"}

    }

# Bizarrely enough, GDB also allows you to reverse the range
# stat, stop IDs.  E.g., "3-1" and "1-3" mean the same thing.
# Probably this isn't documented, but the code anticipates it,
# so we'd best test it...
#
    send_gdb "handle 15-13\n"
    gdb_expect {
      -re ".*SIGPIPE.*SIGALRM.*SIGTERM.*$gdb_prompt $"\
              {pass "handle multiple SIGs via integer range"}
      -re "$gdb_prompt $"\
              {fail "handle multiple SIGs via integer range"}
      timeout {fail "(timeout) handle multiple SIGs via integer range"}

    }

# SIGINT is used by the debugger as well.  Verify that we can change
# our minds about changing it.
#
    send_gdb "handle SIGINT nopass\n"
    gdb_expect {
      -re ".*SIGINT is used by the debugger.*Are you sure you want to change it.*y or n.*"\
              {send_gdb "n\n"
# ??rehrauer: When you answer "n", the header for the signal info is
# printed, but not the actual handler settings.  Probably a bug.
#
               gdb_expect {
                 -re "Not confirmed, unchanged.*Signal.*$gdb_prompt $"\
                         {pass "override SIGINT"}
                 -re "$gdb_prompt $"\
                         {fail "override SIGINT"}
                 timeout {fail "(timeout) override SIGINT"}
               }
              }
      -re "$gdb_prompt $"\
              {fail "override SIGINT"}
      timeout {fail "(timeout) override SIGINT"}
    }

# Verify that GDB responds gracefully to the "signal" command with
# a missing argument.
#
    send_gdb "signal\n"
    gdb_expect {
      -re "Argument required .signal number..*$gdb_prompt $"\
              {pass "signal without arguments disallowed"}
      -re "$gdb_prompt $"\
              {fail "signal without arguments disallowed"}
      timeout {fail "(timeout) signal without arguments disallowed"}
    }

# Verify that we can successfully send a signal other than 0 to
# the inferior.  (This probably causes the inferior to run away.
# Be prepared to rerun to main for further testing.)
#
    send_gdb "signal 5\n"
    gdb_expect {
      -re "Continuing with signal SIGTRAP.*$gdb_prompt $"\
              {pass "sent signal 5"}
      -re "$gdb_prompt $"\
              {fail "sent signal 5"}
      timeout {fail "(timeout) sent signal 5"}
    }

}

return 0
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d1 1
a1 1
# Copyright 1997, 1998, 1999, 2003, 2004 Free Software Foundation, Inc.
d17 3
d36 1
a36 1
    gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
d51 282
a338 1

d362 10
d374 2
a375 4

    # Since count is a static variable outside main, runto_main is no
    # guarantee that count will be 0 at this point.

a376 9

    # Test an inferior function call that takes a signal that hits a
    # breakpoint (with a false condition).  When GDB tries to run the
    # stack dummy, it will hit the breakpoint at handler.  Provided it
    # doesn't lose its cool, this is not a problem, it just has to
    # note that the breakpoint condition is false and keep going.

    # ...setup an always false conditional breakpoint

d380 3
a382 4
    # ...setup the signal

    gdb_test "next" "signal \\(SIGUSR1.*" "next to signal"
    gdb_test "next" "alarm \\(.*" "next to alarm #1"
d384 2
a385 1
	"next to ++count #1"
d388 4
a391 1
    # ...call the function
d394 1
a394 5
	"p func1 () #1"

    # ...veryfiy that the cout was updated

    gdb_test "p count" "= 2" "p count #1"
d396 1
a396 1
    # Now run the same test but with a breakpoint that does stop.
d398 5
a402 1
    # ...set up the breakpoint and signal
d405 1
a405 1
    gdb_test "next" "alarm \\(.*" "next to alarm #2"
d407 1
a407 1
	"next to ++count #2"
d410 2
a411 2
    # ...call the function, which is immediatly interrupted

d415 7
a421 12
	"p func1 () #2"

    # ...verify the backtrace

    gdb_test "backtrace" \
	"#0  handler.*#1  .signal handler called.*#2  func1.*#3  .function called from gdb.*#4.*main.*" \
	"backtrace from handler when calling func1"

    # ...and continue (silently returning)

    gdb_test "continue" "Continuing\\."

d423 1
a424 1
    gdb_test "p count" "= 5" "p count #2"
d426 10
d437 11
a447 1
    # Verify that "info signals" produces reasonable output.
d449 8
a456 2
    gdb_test "info signals" "SIGHUP.*SIGINT.*SIGQUIT.*SIGILL.*SIGTRAP.*SIGABRT.*SIGEMT.*SIGFPE.*SIGKILL.*SIGBUS.*SIGSEGV.*SIGSYS.*SIGPIPE.*SIGALRM.*SIGTERM.*SIGURG.*SIGSTOP.*SIGTSTP.*SIGCONT.*SIGCHLD.*SIGTTIN.*SIGTTOU.*SIGIO.*SIGXCPU.*SIGXFSZ.*SIGVTALRM.*SIGPROF.*SIGWINCH.*SIGLOST.*SIGUSR1.*SIGUSR2.*SIGPWR.*SIGPOLL.*SIGWIND.*SIGPHONE.*SIGWAITING.*SIGLWP.*SIGDANGER.*SIGGRANT.*SIGRETRACT.*SIGMSG.*SIGSOUND.*SIGSAK.*SIGPRIO.*SIG33.*SIG34.*SIG35.*SIG36.*SIG37.*SIG38.*SIG39.*SIG40.*SIG41.*SIG42.*SIG43.*SIG44.*SIG45.*SIG46.*SIG47.*SIG48.*SIG49.*SIG50.*SIG51.*SIG52.*SIG53.*SIG54.*SIG55.*SIG56.*SIG57.*SIG58.*SIG59.*SIG60.*SIG61.*SIG62.*SIG63.*Use the \"handle\" command to change these tables.*" \
	"info signals"
d458 10
a467 2
    # Verify that "info signal" correctly handles an argument, be it a
    # symbolic signal name, or an integer ID.
d469 8
a476 3
    gdb_test "info signal SIGTRAP" \
	"SIGTRAP\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*No\[ \t\]*Trace/breakpoint trap.*" \
	"info signal SIGTRAP"
d478 8
a485 3
    gdb_test "info signal 5" \
	"SIGTRAP\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*No\[ \t\]*Trace/breakpoint trap.*" \
	"info signal 5"
d487 11
a497 2
    # Verify that "handle" with illegal arguments is gracefully, um,
    # handled.
d499 11
a509 3
    gdb_test "handle" \
	"Argument required .signal to handle.*" \
	"handle without arguments"
d511 11
a521 3
    gdb_test "handle SIGFOO" \
	"Unrecognized or ambiguous flag word: \"SIGFOO\".*" \
	"handle with bogus SIG"
d523 24
a546 3
    gdb_test "handle SIGHUP frump" \
	"Unrecognized or ambiguous flag word: \"frump\".*" \
	"handle SIG with bogus action"
d548 12
a559 3
    # Verify that "handle" can take multiple actions per SIG, and that
    # in the case of conflicting actions, that the rightmost action
    # "wins".
d561 11
a571 3
    gdb_test "handle SIGHUP print noprint" \
	"SIGHUP\[ \t\]*No\[ \t\]*No\[ \t\]*Yes\[ \t\]*Hangup.*" \
	"handle SIG with multiple conflicting actions"
d573 1
a573 2
    # Exercise all the various actions.  (We don't care what the
    # outcome is, this is just to ensure that they all can be parsed.)
d575 12
a586 3
    gdb_test "handle SIGHUP print noprint stop nostop ignore noignore pass nopass" \
	"Signal.*" \
	"handle SIG parses all legal actions"
d588 1
a588 2
    # Verify that we can "handle" multiple signals at once,
    # interspersed with actions.
d590 22
a611 11
    gdb_test "handle SIG63 print SIGILL" \
	"SIGILL\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*Illegal instruction.*SIG63\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*Real-time event 63.*" \
	"handle multiple SIGs"

    # Verify that "handle" can take a numeric argument for the signal
    # ID, rather than a symbolic name.  (This may not be portable;
    # works for HP-UX.)

    # Also note that this testpoint overrides SIGTRAP, which on HP-UX
    # at least, is used to implement single-steps and breakpoints.
    # Don't expect to run the inferior after this!
d613 10
a622 7
    set test "override SIGTRAP"
    gdb_test_multiple "handle 5 nopass" "$test" {
	-re "SIGTRAP is used by the debugger.*Are you sure you want to change it.*y or n.*" {
	    gdb_test "y" \
		"SIGTRAP\[ \t\]*Yes\[ \t\]*Yes\[ \t\]*No\[ \t\]*Trace/breakpoint trap.*" \
		"$test"
	}
d625 11
a635 41
    # GDB doesn't seem to allow numeric signal IDs larger than 15.  Verify
    # that restriction.  ??rehrauer: Not sure if this is a feature or a
    # bug, actually.  Why is the range 1-15?

    gdb_test "handle 58" \
	"Only signals 1-15 are valid as numeric signals.*Use \"info signals\" for a list of symbolic signals.*" \
	"invalid signal number rejected"

    # Verify that we can accept a signal ID range (number-number).
    # ??rehrauer: This feature isn't documented on the quick-reference
    # card.

    gdb_test "handle 13-15" \
	"SIGPIPE.*SIGALRM.*SIGTERM.*" \
	"handle multiple SIGs via integer range"

    # Bizarrely enough, GDB also allows you to reverse the range stat,
    # stop IDs.  E.g., "3-1" and "1-3" mean the same thing.  Probably
    # this isn't documented, but the code anticipates it, so we'd best
    # test it...

    gdb_test "handle 15-13" \
	"SIGPIPE.*SIGALRM.*SIGTERM.*" \
	"handle multiple SIGs via reverse integer range"

    # SIGINT is used by the debugger as well.  Verify that we can
    # change our minds about changing it.

    set test "override SIGINT"
    gdb_test_multiple "handle SIGINT nopass" "$test" {
	-re "SIGINT is used by the debugger.*Are you sure you want to change it.*y or n.*" {
	    gdb_test_multiple "n" "$test" {
		-re "Not confirmed, unchanged.*Signal.*$gdb_prompt $"  {
		    # "Signal ..." should not be in the output.
		    kfail gdb/1707 "$test"
		}
		-re "Not confirmed, unchanged.*$gdb_prompt $" {
		    pass "$test"
		}
	    }
	}
a637 15
    # Verify that GDB responds gracefully to the "signal" command with
    # a missing argument.

    gdb_test "signal" \
	"Argument required .signal number..*" \
	"signal without arguments disallowed"
    
    # Verify that we can successfully send a signal other than 0 to
    # the inferior.  (This probably causes the inferior to run away.
    # Be prepared to rerun to main for further testing.)

    gdb_test "signal SIGUSR1" "Breakpoint.*handler.*"
    gdb_test "bt" \
	"#0  handler .*#1  .signal handler called.*\#2 .*main.*" \
	"backtrace for SIGUSR1"
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 382
if $nosignals {
	verbose "Skipping signals.exp because of nosignals."
	continue
	}

if $tracelevel then {
	strace $tracelevel
}

set prms_id 0
set bug_id 0

set testfile signals
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}
if  { [compile "${srcdir}/${subdir}/${srcfile} -g -o ${binfile}"] != "" } {
    perror "Couldn't compile ${srcfile}"
    return -1
}

# Create and source the file that provides information about the compiler
# used to compile the test case.
execute_anywhere "rm -f ${binfile}.ci"
if  { [compile "-E ${srcdir}/${subdir}/compiler.c > ${binfile}.ci"] != "" } {
    perror "Couldn't make ${binfile}.ci file"
    return -1
}
source ${binfile}.ci

proc signal_tests_1 {} {
    global prompt
    if [runto_main] then {
	gdb_test "next" "signal \\(SIGUSR1.*" \
		"next over signal (SIGALRM, handler)"
	gdb_test "next" "alarm \\(.*" \
		"next over signal (SIGUSR1, handler)"
	gdb_test "next" "\\+\\+count; /\\* first \\*/" \
		"next over alarm (1)"
	# An alarm has been signaled, give the signal time to get delivered.
	exec sleep 2

	# i386 BSD currently fails the next test with a SIGTRAP.
	setup_xfail "i*86-*-bsd*"
	# But Dynix has a DECR_PC_AFTER_BREAK of zero, so the failure
	# is shadowed by hitting the through_sigtramp_breakpoint.
	clear_xfail "i*86-sequent-bsd*"
	# Univel SVR4 i386 continues instead of stepping.
	setup_xfail "i*86-univel-sysv4*"
	# lynx fails with "next" acting like "continue"
	setup_xfail "*-*-*lynx*"
	# linux (aout versions) also fails with "next" acting like "continue"
	# this is probably more dependant on the kernel version than on the
	# object file format or utils.  (sigh)
	setup_xfail "i*86-*-linuxaout" "i*86-*-linuxoldld"
	send "next\n"
	expect {
	    -re "alarm .*$prompt $" { pass "next to 2nd alarm (1)" }
	    -re "Program received signal SIGTRAP.*first.*$prompt $" {

		# This can happen on machines that have a trace flag
		# in their PS register.
		# The trace flag in the PS register will be set due to
		# the `next' command.
		# Before calling the signal handler, the PS register
		# is pushed along with the context on the user stack.
		# When the signal handler has finished, it reenters the
		# the kernel via a sigreturn syscall, which restores the
		# PS register along with the context.
		# If the kernel erroneously does not clear the trace flag
		# in the pushed context, gdb will receive a SIGTRAP from
		# the set trace flag in the restored context after the
		# signal handler has finished.

		# I do not yet understand why the SIGTRAP does not occur
		# after stepping the instruction at the restored PC on
		# i386 BSDI 1.0 systems.

		# Note that the vax under Ultrix also exhibits
		# this behaviour (it is uncovered by the `continue from
		# a break in a signal handler' test below).
		# With this test the failure is shadowed by hitting the
		# through_sigtramp_breakpoint upon return from the signal
		# handler.

		fail "next to 2nd alarm (1) (probably kernel bug)"
		gdb_test "next" "alarm.*" "next to 2nd alarm (1)"
	    }
	    -re "Program exited with code.*$prompt $" {

		# This is apparently a bug in the UnixWare kernel (but
		# has not been investigated beyond the
		# resume/target_wait level, and has not been reported
		# to Univel).  If it steps when a signal is pending,
		# it does a continue instead.  I don't know whether
		# there is a workaround.

		# Perhaps this problem exists on other SVR4 systems;
		# but (a) we have no reason to think so, and (b) if we
		# put a wrong xfail here, we never get an XPASS to let
		# us know that it was incorrect (and then if such a
		# configuration regresses we have no way of knowing).
		# Solaris is not a relevant data point either way
		# because it lacks single stepping.

		# fnf: I don't agree with the above philosophy.  We
		# can never be sure that any particular XFAIL is
		# specified 100% correctly in that no systems with
		# the bug are missed and all systems without the bug
		# are excluded.  If we include an XFAIL that isn't
		# appropriate for a particular system, then when that
		# system gets tested it will XPASS, and someone should
		# investigate and fix the setup_xfail as appropriate,
		# or more preferably, the actual bug.  Each such case
		# adds more data to narrowing down the scope of the
		# problem and ultimately fixing it.

		setup_xfail "i*86-*-sysv4*"
		fail "'next' behaved as 'continue (known SVR4 bug)'"
		return 0
	    }
	    -re ".*$prompt $" { fail "next to 2nd alarm (1)" }
	    timeout { fail "next to 2nd alarm (1); (timeout)" }
	    eof { fail "next to 2nd alarm (1); (eof)" }
	}

	gdb_test "break handler" "Breakpoint \[0-9\]+ .*"
	gdb_test "next" "\\+\\+count; /\\* second \\*/" \
	    "next to 2nd ++count in signals_tests_1"
	# An alarm has been signaled, give the signal time to get delivered.
	exec sleep 2

	set bash_bug 0
	send "next\n"
	setup_xfail "i*86-*-linux"
	expect {
	    -re "Breakpoint.*handler.*$prompt $" {
		pass "next to handler in signals_tests_1"
	    }
	    -re "Program received signal SIGEMT.*$prompt $" {
		# Bash versions before 1.13.5 cause this behaviour
		# by blocking SIGTRAP.
		fail "next to handler in signals_tests_1 (known problem with bash versions before 1.13.5)"
		set bash_bug 1
		gdb_test "signal 0" "Breakpoint.*handler.*"
	    }
	    -re ".*$prompt $" { fail "next to handler in signals_tests_1" }
	    timeout { fail "next to handler in signals_tests_1 (timeout)" }
	    eof { fail "next to handler in signals_tests_1 (eof)" }
	}

	# This doesn't test that main is frame #2, just that main is frame
	# #2, #3, or higher.  At some point this should be fixed (but
	# it quite possibly would introduce new FAILs on some systems).
	setup_xfail "i*86-*-linux" "i*86-*-bsdi2.0"
	gdb_test "backtrace" "#0.*handler.*#1.*#2.*main.*" \
	    "backtrace in signals_tests_1"

	gdb_test "break func1" "Breakpoint \[0-9\]+ .*"
	gdb_test "break func2" "Breakpoint \[0-9\]+ .*"

	# Vax Ultrix and i386 BSD currently fail the next test with
	# a SIGTRAP, but with different symptoms.
	setup_xfail "vax-*-ultrix*"
	setup_xfail "i*86-*-bsd*"
	setup_xfail "i*86-*-linux"
	send "continue\n"
	expect {
	    -re "Breakpoint.*func1.*$prompt $" { pass "continue to func1" }
	    -re "Program received signal SIGTRAP.*second.*$prompt $" {

		# See explanation for `next to 2nd alarm (1)' fail above.
		# We did step into the signal handler, hit a breakpoint
		# in the handler and continued from the breakpoint.
		# The set trace flag in the restored context is causing
		# the SIGTRAP, without stepping an instruction.

		fail "continue to func1 (probably kernel bug)"
		gdb_test "continue" "Breakpoint.*func1.*" \
		    "extra continue to func1"
	    }
	    -re "Program received signal SIGTRAP.*func1 ..;.*$prompt $" {

		# On the vax under Ultrix the set trace flag in the restored
		# context is causing the SIGTRAP, but after stepping one
		# instruction, as expected.

		fail "continue to func1 (probably kernel bug)"
		gdb_test "continue" "Breakpoint.*func1.*" \
		    "extra continue to func1"
	    }
	    -re ".*$prompt $" { fail "continue to func1" }
	    default { fail "continue to func1" }
	}

	setup_xfail "*-*-irix*"
	setup_xfail "i*86-*-linux"
	send "signal SIGUSR1\n"
	expect {
	    -re "Breakpoint.*handler.*$prompt $" { pass "signal SIGUSR1" }
	    -re "Program received signal SIGUSR1.*$prompt $" {
		# This is what irix4 and irix5 do.
		# It would appear to be a kernel bug.
		fail "signal SIGUSR1"
		gdb_test "continue" "Breakpoint.*handler.*" "pass it SIGUSR1"
	    }
	    -re ".*$prompt $" { fail "signal SIGUSR1" }
	    default { fail "signal SIGUSR1" }
	}

	# Will tend to wrongly require an extra continue.

	# The problem here is that the breakpoint at func1 will be
	# inserted, and when the system finishes with the signal
	# handler it will try to execute there.  For GDB to try to
	# remember that it was going to step over a breakpoint when a
	# signal happened, distinguish this case from the case where
	# func1 is called from the signal handler, etc., seems
	# exceedingly difficult.  So don't expect this to get fixed
	# anytime soon.

	setup_xfail "*-*-*"
	send "continue\n"
	expect {
	    -re "Breakpoint.*func2.*$prompt $" { pass "continue to func2" }
	    -re "Breakpoint.*func1.*$prompt $" {
	    	fail "continue to func2"
		gdb_test "continue" "Breakpoint.*func2.*" \
		    "extra continue to func2"
	    }
	    -re ".*$prompt $" { fail "continue to func2" }
	    default { fail "continue to func2" }
	}

	exec sleep 2

        # GDB yanks out the breakpoints to step over the breakpoint it
        # stopped at, which means the breakpoint at handler is yanked.
	# But if NO_SINGLE_STEP, we won't get another chance to reinsert
	# them (at least not with procfs, where we tell the kernel not
	# to tell gdb about `pass' signals).  So the fix would appear to
	# be to just yank that one breakpoint when we step over it.

	setup_xfail "sparc*-*-*"
	setup_xfail "rs6000-*-*"
	setup_xfail "powerpc-*-*"

	# A faulty bash will not step the inferior into sigtramp on sun3.
	if {$bash_bug} then {
	    setup_xfail "m68*-*-sunos4*"
	}

	setup_xfail "i*86-*-linux"
	gdb_test "continue" "Breakpoint.*handler.*" "continue to handler"

	# If the NO_SINGLE_STEP failure happened, we have already exited.
	# If we succeeded a continue will return from the handler to func2.
	# GDB now has `forgotten' that it intended to step over the
	# breakpoint at func2 and will stop at func2.
	setup_xfail "*-*-*"
	# The sun3 with a faulty bash will also be `forgetful' but it
	# already got the spurious stop at func2 and this continue will work.
	if {$bash_bug} then {
	     clear_xfail "m68*-*-sunos4*"
	}
	gdb_test "continue" "Program exited with code 010\\." \
	    "continue to exit in signals_tests_1 "
    }
}

# On a few losing systems, ptrace (PT_CONTINUE) or ptrace (PT_STEP)
# causes pending signals to be cleared, which causes these tests to
# get nowhere fast.  This is totally losing behavior (perhaps there
# are cases in which is it useful but the user needs more control,
# which they mostly have in GDB), but some people apparently think it
# is a feature.  It is documented in the ptrace manpage on Motorola
# Delta Series sysV68 R3V7.1 and on HPUX 9.0.  Even the non-HPUX PA
# OSes (BSD and OSF/1) seem to have figured they had to copy this
# braindamage.

if {[ istarget "m68*-motorola-*" ] || [ istarget "hppa*-*-bsd*" ] ||
    [ istarget "*-*-hpux*" ] || [ istarget "hppa*-*-osf*" ]} then {
  setup_xfail "*-*-*"
  fail "ptrace loses on signals on this target"
  return 0
}

# lynx2.2.2 doesn't lose signals, instead it screws up the stack pointer
# in some of these tests leading to massive problems.  I've
# reported this to lynx, hopefully it'll be fixed in lynx2.3.
# Severe braindamage.
if [ istarget "*-*-*lynx*" ] then {
  setup_xfail "*-*-*"
  fail "kernel scroggs stack pointer in signal tests on this target"
  return 0
}

gdb_exit
gdb_start

# This will need to be updated as the exact list of signals changes,
# but I want to test that TARGET_SIGNAL_0, TARGET_SIGNAL_DEFAULT, and
# TARGET_SIGNAL_UNKNOWN are skipped.
proc test_handle_all_print {} {
    global timeout
    # Increase timeout and expect input buffer for large output from gdb.
    # Allow blank or TAB as whitespace characters.
    set oldtimeout $timeout
    set timeout [expr "$timeout + 360"]
    verbose "Timeout is now $timeout seconds" 2
    match_max 10000
    gdb_test "handle all print" "Signal\[ 	\]+Stop\[ 	\]+Print\[ 	\]+Pass to program\[ 	\]+Description\r\nSIGHUP\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Hangup.*SIG63\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Real-time event 63.*EXC_BREAKPOINT\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Yes\[ 	\]+Breakpoint"
    set timeout $oldtimeout
    verbose "Timeout restored to $timeout seconds" 2
}
test_handle_all_print

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load $binfile
signal_tests_1

# Force a resync, so we're looking at the right prompt.  On SCO we
# were getting out of sync (I don't understand why).
send "p 1+1\n"
expect {
    -re "= 2.*$prompt $" {}
    -re ".*$prompt $" { perror "sync trouble in signals.exp" }
    default { perror "sync trouble in signals.exp" }
}

if [runto_main] then {
    gdb_test "break handler if 0" "Breakpoint \[0-9\]+ .*"
    gdb_test "set \$handler_breakpoint_number = \$bpnum" ""

    # Get to the point where a signal is waiting to be delivered
    gdb_test "next" "signal \\(SIGUSR1.*" "next to signal in signals.exp"
    gdb_test "next" "alarm \\(.*" "next to alarm #1 in signals.exp"
    gdb_test "next" "\\+\\+count; /\\* first \\*/" \
	"next to ++count #1 in signals.exp"
    # Give the signal time to get delivered
    exec sleep 2

    # Now call a function.  When GDB tries to run the stack dummy,
    # it will hit the breakpoint at handler.  Provided it doesn't
    # lose its cool, this is not a problem, it just has to note
    # that the breakpoint condition is false and keep going.

    gdb_test "p func1 ()" "^p func1 \\(\\)\r\n.\[0-9\]* = void" \
	"p func1 () #1 in signals.exp"

    # Make sure the count got incremented.

    # Haven't investigated this xfail
    setup_xfail "rs6000-*-*"
    setup_xfail "powerpc-*-*"
    gdb_test "p count" "= 2" "p count #1 in signals.exp"
    if { [istarget "rs6000-*-*"] || [istarget "powerpc-*-*"] } { return 0 }

    gdb_test "condition \$handler_breakpoint_number" "now unconditional\\."
    gdb_test "next" "alarm \\(.*" "next to alarm #2 in signals.exp"
    gdb_test "next" "\\+\\+count; /\\* second \\*/" \
	"next to ++count #2 in signals.exp"
    exec sleep 2

    # This time we stop when GDB tries to run the stack dummy.
    # So it is OK that we do not print the return value from the function.
    gdb_test "p func1 ()" \
"Breakpoint \[0-9\]*, handler.*
The program being debugged stopped while in a function called from GDB.*" \
	"p func1 () #2 in signals.exp"
    # But we should be able to backtrace...
    # On alpha-*-osf2.0 this test works when run manually but sometime fails when
    # run under dejagnu, making it very hard to debug the problem.  Weird...
    gdb_test "bt" "#0.*handler.*#1.*#2.*main.*" "bt in signals.exp"
    # ...and continue...
    gdb_test "continue" "Continuing\\." "continue in signals.exp"
    # ...and then count should have been incremented
    gdb_test "p count" "= 5" "p count #2 in signals.exp"
}

return 0
@
