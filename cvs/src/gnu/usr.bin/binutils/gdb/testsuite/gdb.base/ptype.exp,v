head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.54
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.50
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.46
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.48
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.40
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.44
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.42
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.38
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.36
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.34
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.32
	OPENBSD_5_0:1.3.0.30
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.28
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.26
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.22
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.24
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.20
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.18
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.16
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.14
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.12
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.10
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	GDB_6_3:1.1.1.1
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2004.05.21.20.23.39;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.50.14;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.35.33;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.16.49;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.35.34;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@# Copyright 1988, 1990, 1991, 1992, 1994, 1995, 1996, 1997, 1999,
# 2000, 2002, 2003 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Rob Savoye. (rob@@cygnus.com)

if $tracelevel then {
	strace $tracelevel
	}

#
# test running programs
#
set prms_id 0
set bug_id 0

set testfile "ptype"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}
if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

# Create and source the file that provides information about the compiler
# used to compile the test case.
if [get_compiler_info ${binfile}] {
    return -1;
}

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

# Test ptype of unnamed enumeration members before any action causes
# the partial symbol table to be expanded to full symbols.  This fails
# with stabs compilers which fail to use a nameless stab (such as
# pre-2.4.5 versions of gcc and most non-gcc compilers).

send_gdb "ptype red1\n"
gdb_expect {
    -re "type = enum primary1_tag \{red1, green1, blue1\}.*$gdb_prompt $"\
	{
	    # The workaround is in effect.  As this is a compiler, not GDB,
	    # bug, we'll make it a PASS but perhaps it should be an XFAIL.
	    pass "ptype unnamed enumeration member (worked around)"
	}
    -re "type = enum \{red1, green1, blue1\}.*$gdb_prompt $"\
			{ pass "ptype unnamed enumeration member" }
    -re ".*$gdb_prompt $"	{ fail "ptype unnamed enumeration member" }
    timeout		{ fail "(timeout) ptype unnamed enumeration member" }
}

#
# test ptype command with structures
#
# Here and elsewhere, we accept
# "long", "long int", or "int" for long variables (whatis.exp already
# has an XFAIL for "int" (Sun cc bug), so no need to fail it here).
gdb_test "ptype struct t_struct" "type = struct t_struct \{.*\[\r\n\]    (unsigned |)char v_char_member;.*\[\r\n\]    (short|short int) v_short_member;.*\[\r\n\]    int v_int_member;.*\[\r\n\]    (long|long int|int) v_long_member;.*\[\r\n\]    float v_float_member;.*\[\r\n\]    double v_double_member;.*\[\r\n\]\}.*" "ptype structure" 


# Test the equivalence between '.' and '->' for struct member references.

if [gdb_test "ptype v_struct1.v_float_member"	"type = float"]<0 then {
    return -1
}
if [gdb_test "ptype v_struct1->v_float_member"	"type = float"]<0 then {
    return -1
}
if [gdb_test "ptype v_t_struct_p.v_float_member"	"type = float"]<0 then {
    return -1
}
if [gdb_test "ptype v_t_struct_p->v_float_member"	"type = float"]<0 then {
    return -1
}


# IBM's xlc puts out bogus stabs--the stuff field is type 42,
# which isn't defined.

gdb_test "ptype struct link" "type = struct link \{\[\r\n\]+\[ \t\]+struct link \\*next;\[\r\n\]+\[ \t\]+struct link \\*\\(\\*linkfunc\\)\\((struct link \\*, int|void|)\\);\[\r\n\]+\[ \t\]+struct t_struct stuff.1..2..3.;\[\r\n\]+\}.*" "ptype linked list structure" 

#
# test ptype command with unions
#
gdb_test "ptype union t_union" "type = union t_union \{.*\[\r\n\]    (unsigned |)char v_char_member;.*\[\r\n\]    (short|short int) v_short_member;.*\[\r\n\]    int v_int_member;.*\[\r\n\]    (long|long int|int) v_long_member;.*\[\r\n\]    float v_float_member;.*\[\r\n\]    double v_double_member;.*\[\r\n\]\}.*" "ptype union" 

# IBM's xlc puts out bogus stabs--the stuff field is type 42,
# which isn't defined.
gdb_test "ptype union tu_link" "type = union tu_link \{\[\r\n\]+\[ \t\]+struct link \\*next;\[\r\n\]+\[ \t\]+struct link \\*\\(\\*linkfunc\\)\\((struct link \\*, int|void|)\\);\[\r\n\]+\[ \t\]+struct t_struct stuff.1..2..3.;\[\r\n\]+\}.*" "ptype linked list union" 

#
# test ptype command with enums
#

gdb_test "ptype primary" "type = enum .red, green, blue.*" "ptype unnamed enumeration" 

gdb_test "ptype enum colors" "type = enum colors \{yellow, purple, pink\}.*" "ptype named enumeration" 


#
# test ptype command with enums as typedef
#
gdb_test "ptype boolean" "type = enum (boolean |)\{FALSE, TRUE\}.*" "ptype unnamed typedef'd enumeration" 

# And check that whatis shows the name, not "enum {...}".
# This probably fails for all DWARF 1 cases, so assume so for now. -fnf
# The problem with xlc is that the stabs look like
#   :t51=eFALSE:0,TRUE:1,;
#   boolean:t55=51
#   v_boolean:G51
# GDB's behavior is correct; the type which the variable is defined
# as (51) doesn't have a name.  Only 55 has a name.

if {!$gcc_compiled && !$hp_aCC_compiler} {
    setup_xfail "rs6000-*-*" "i*86-*-sysv4*"
    setup_xfail "hppa*-*-*" CLLbs14773
}

# For get_debug_format to do its job, we need to have a current source file.
gdb_test "list main" ""
get_debug_format
gdb_test "whatis v_boolean" "type = (enum |)boolean" \
  "whatis unnamed typedef'd enum (compiler bug in IBM's xlc)"

# Same thing with struct and union.
gdb_test "ptype t_struct3" "type = struct (t_struct3 |)\{.*
 *double v_double_member;.*
 *int v_int_member;.*\}" "printing typedef'd struct"

gdb_test "ptype t_union3" "type = union (t_union3 |)\{.*
 *double v_double_member;.*
 *int v_int_member;.*\}" "printing typedef'd union"

gdb_test "ptype enum bvals" "type = enum bvals \{my_false, my_true\}.*" "ptype named typedef'd enumf'd enum"

#
# test ptype command with out-of-order enum values
#
gdb_test "ptype enum misordered" "type = enum misordered \{two = 2, one = 1, zero = 0, three = 3\}.*" "ptype misordered enumeration" 

#
# test ptype command with a named enum's value
#
gdb_test "ptype three" "type = enum misordered \{two = 2, one = 1, zero = 0, three = 3\}.*" "ptype named enumeration member" 

gdb_test "ptype red" "type = enum \{red, green, blue\}.*" "ptype unnamed enumeration member #2" 

#
# test ptype command with basic C types
#
# I've commented most of this out because it duplicates tests in whatis.exp.
# I've just left in a token test or 2 which is designed to test that ptype 
# acts like whatis for basic types.  If it is thought to be necessary to
# test both whatis and ptype for all the types, the tests should be
# merged into whatis.exp, or else maintenance will be a royal pain -kingdon
#setup_xfail "mips-idt-*" "mips-sgi-*"
#send "ptype v_char\n"
#gdb_expect {
#    -re "type = char.*$gdb_prompt $"	{ pass "ptype char" }
#    -re ".*$gdb_prompt $"	{ fail "ptype char" }
#    timeout		{ fail "(timeout) ptype char" }
#}
#
#
#setup_xfail "mips-*-*"
#send "ptype v_signed_char\n"
#gdb_expect {
#    -re "type = signed char.*$gdb_prompt $"	{ pass "ptype signed char" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed char" }
#    timeout		{ fail "(timeout) ptype signed char" }
#}
#
#
#send "ptype v_unsigned_char\n"
#gdb_expect {
#    -re "type = unsigned char.*$gdb_prompt $"	{ pass "ptype unsigned char" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned char" }
#    timeout		{ fail "(timeout) ptype unsigned char" }
#}

gdb_test "ptype v_short" "type = short(| int).*" "ptype short" 

#send "ptype v_signed_short\n"
#gdb_expect {
#    -re "type = short.*$gdb_prompt $"	{ pass "ptype signed short" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed short" }
#    timeout		{ fail "(timeout) ptype signed short" }
#}
#
#
#send "ptype v_unsigned_short\n"
#gdb_expect {
#    -re "type = unsigned short.*$gdb_prompt $"	{ pass "ptype unsigned short" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned short" }
#    timeout		{ fail "(timeout) ptype unsigned short" }
#}


gdb_test "ptype v_int" "type = int.*" "ptype int" 

#send "ptype v_signed_int\n"
#gdb_expect {
#    -re "type = int.*$gdb_prompt $"	{ pass "ptype signed int" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed int" }
#    timeout		{ fail "(timeout) ptype signed int" }
#}
#
#
#send "ptype v_unsigned_int\n"
#gdb_expect {
#    -re "type = unsigned int.*$gdb_prompt $"	{ pass "ptype unsigned int" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned int" }
#    timeout		{ fail "(timeout) ptype unsigned int" }
#}
#
#
#send "ptype v_long\n"
#gdb_expect {
#    -re "type = long.*$gdb_prompt $"	{ pass "ptype long" }
#    -re ".*$gdb_prompt $"	{ fail "ptype long" }
#    timeout		{ fail "(timeout) ptype long" }
#}
#
#
#send "ptype v_signed_long\n"
#gdb_expect {
#    -re "type = long.*$gdb_prompt $"	{ pass "ptype signed long" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed long" }
#    timeout		{ fail "(timeout) ptype signed long" }
#}
#
#
#send "ptype v_unsigned_long\n"
#gdb_expect {
#    -re "type = unsigned long.*$gdb_prompt $"	{ pass "ptype unsigned long" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned long" }
#    timeout		{ fail "(timeout) ptype unsigned long" }
#}
#
#
#send "ptype v_float\n"
#gdb_expect {
#    -re "type = float.*$gdb_prompt $"	{ pass "ptype float" }
#    -re ".*$gdb_prompt $"	{ fail "ptype float" }
#    timeout		{ fail "(timeout) ptype float" }
#}
#
#
#send "ptype v_double\n"
#gdb_expect {
#    -re "type = double.*$gdb_prompt $"	{ pass "ptype double" }
#    -re ".*$gdb_prompt $"	{ fail "ptype double" }
#    timeout		{ fail "(timeout) ptype double" }
#}


#
# test ptype command with arrays
#
#setup_xfail "mips-idt-*" "mips-sgi-*"
#send "ptype v_char_array\n"
#gdb_expect {
#    -re "type = char .2..*$gdb_prompt $"	{ pass "ptype char array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype char array" }
#    timeout		{ fail "(timeout) ptype char array" }
#}
#
#
#setup_xfail "mips-*-*"
#send "ptype v_signed_char_array\n"
#gdb_expect {
#    -re "type = (|signed )char .2..*$gdb_prompt $"	{ pass "ptype signed char array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed char array" }
#    timeout		{ fail "(timeout) ptype signed char array" }
#}
#
#
#send "ptype v_unsigned_char_array\n"
#gdb_expect {
#    -re "type = unsigned char .2..*$gdb_prompt $"	{ pass "ptype unsigned char array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned char array" }
#    timeout		{ fail "(timeout) ptype unsigned char array" }
#}
#
#
#
#send "ptype v_int_array\n"
#gdb_expect {
#    -re "type = int .2..*$gdb_prompt $"	{ pass "ptype int array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype int array" }
#    timeout		{ fail "(timeout) ptype int array" }
#}
#
#
#send "ptype v_signed_int_array\n"
#gdb_expect {
#    -re "type = int .2..*$gdb_prompt $"	{ pass "ptype signed int array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed int array" }
#    timeout		{ fail "(timeout) ptype signed int array" }
#}
#
#
#send "ptype v_unsigned_int_array\n"
#gdb_expect {
#    -re "type = unsigned int .2..*$gdb_prompt $"	{ pass "ptype unsigned int array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned int array" }
#    timeout		{ fail "(timeout) ptype unsigned int array" }
#}
#
#
#send "ptype v_long_array\n"
#gdb_expect {
#    -re "type = (long|int|long int) .2..*$gdb_prompt $"	{ 
#	pass "ptype long array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype long array" }
#    timeout		{ fail "(timeout) ptype long array" }
#}
#
#
#send "ptype v_signed_long_array\n"
#gdb_expect {
#    -re "type = (long|int|long int) .2..*$gdb_prompt $"	{ 
#	pass "ptype signed long array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed long array" }
#    timeout		{ fail "(timeout) ptype signed long array" }
#}
#
#
#send "ptype v_unsigned_long_array\n"
#gdb_expect {
#    -re "type = unsigned long .2..*$gdb_prompt $"	{ pass "ptype unsigned long array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned long array" }
#    timeout		{ fail "(timeout) ptype unsigned long array" }
#}
#
#
#send "ptype v_float_array\n"
#gdb_expect {
#    -re "type = float .2..*$gdb_prompt $"	{ pass "ptype float array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype float array" }
#    timeout		{ fail "(timeout) ptype float array" }
#}
#
#
#send "ptype v_double_array\n"
#gdb_expect {
#    -re "type = double .2..*$gdb_prompt $"	{ pass "ptype double array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype double array" }
#    timeout		{ fail "(timeout) ptype double array" }
#}
#

if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" "i*86-*-sysv4*" }
if {$hp_aCC_compiler} {setup_xfail "hppa*-*-*"}
gdb_test "ptype t_char_array" "type = (|unsigned )char \\\[0?\\\]"

#
##
## test ptype command with pointers
##
#setup_xfail "mips-idt-*" "mips-sgi-*"
#send "ptype v_char_pointer\n"
#gdb_expect {
#    -re "type = char \*.*$gdb_prompt $"	{ pass "ptype char pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype char pointer" }
#    timeout		{ fail "(timeout) ptype char pointer" }
#}
#
#
#setup_xfail "mips-*-*"
#send "ptype v_signed_char_pointer\n"
#gdb_expect {
#    -re "type = (|signed )char \*.*$gdb_prompt $"
#	{ pass "ptype signed char pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed char pointer" }
#    timeout		{ fail "(timeout) ptype signed char pointer" }
#}
#
#
#send "ptype v_unsigned_char_pointer\n"
#gdb_expect {
#    -re "type = unsigned char \*.*$gdb_prompt $"	{ pass "ptype unsigned char pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned char pointer" }
#    timeout		{ fail "(timeout) ptype unsigned char pointer" }
#}
#
#
#send "ptype v_short_pointer\n"
#gdb_expect {
#    -re "type = (short|short int) \*.*$gdb_prompt $"	{ pass "ptype short pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype short pointer" }
#    timeout		{ fail "(timeout) ptype short pointer" }
#}
#
#
#send "ptype v_signed_short_pointer\n"
#gdb_expect {
#    -re "type = short \*.*$gdb_prompt $"	{ pass "ptype signed short pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed short pointer" }
#    timeout		{ fail "(timeout) ptype signed short pointer" }
#}
#
#
#send "ptype v_unsigned_short_pointer\n"
#gdb_expect {
#    -re "type = unsigned short \*.*$gdb_prompt $"	{ pass "ptype unsigned short pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned short pointer" }
#    timeout		{ fail "(timeout) ptype unsigned short pointer" }
#}
#
#
#send "ptype v_int_pointer\n"
#gdb_expect {
#    -re "type = int \*.*$gdb_prompt $"	{ pass "ptype int pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype int pointer" }
#    timeout		{ fail "(timeout) ptype int pointer" }
#}
#
#
#send "ptype v_signed_int_pointer\n"
#gdb_expect {
#    -re "type = int \*.*$gdb_prompt $"	{ pass "ptype signed int pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed int pointer" }
#    timeout		{ fail "(timeout) ptype signed int pointer" }
#}
#
#
#send "ptype v_unsigned_int_pointer\n"
#gdb_expect {
#    -re "type = unsigned int \*.*$gdb_prompt $"	{ pass "ptype unsigned int pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned int pointer" }
#    timeout		{ fail "(timeout) ptype unsigned int pointer" }
#}
#
#
#send "ptype v_long_pointer\n"
#gdb_expect {
#    -re "type = long \*.*$gdb_prompt $"	{ pass "ptype long pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype long pointer" }
#    timeout		{ fail "(timeout) ptype long pointer" }
#}
#
#
#send "ptype v_signed_long_pointer\n"
#gdb_expect {
#    -re "type = long \*.*$gdb_prompt $"	{ pass "ptype signed long pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed long pointer" }
#    timeout		{ fail "(timeout) ptype signed long pointer" }
#}
#
#
#send "ptype v_unsigned_long_pointer\n"
#gdb_expect {
#    -re "type = unsigned long \*.*$gdb_prompt $"	{ pass "ptype unsigned long pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned long pointer" }
#    timeout		{ fail "(timeout) ptype unsigned long pointer" }
#}
#
#
#send "ptype v_float_pointer\n"
#gdb_expect {
#    -re "type = float \*.*$gdb_prompt $"	{ pass "ptype float pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype float pointer" }
#    timeout		{ fail "(timeout) ptype float pointer" }
#}
#
#
#send "ptype v_double_pointer\n"
#gdb_expect {
#    -re "type = double \*.*$gdb_prompt $"	{ pass "ptype double pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype double pointer" }
#    timeout		{ fail "(timeout) ptype double pointer" }
#}

#
# test ptype command with nested structure and union
#
if {$hp_aCC_compiler} {
    set outer "outer_struct::"
    set struct ""
    set union ""
} else {
    set outer ""
    set struct "struct"
    set union "union"
}
gdb_test "ptype struct outer_struct" "type = struct outer_struct \{.*\[\r\n\]+\
.*int outer_int;.*\[\r\n\]+\
.*(struct|) ${outer}inner_struct inner_struct_instance;.*\[\r\n\]+\
.*(union|) ${outer}inner_union inner_union_instance;.*\[\r\n\]+\
.*(long|long int|int) outer_long;.*\[\r\n\]\}.*" "ptype outer structure" 

gdb_test "ptype ${struct} ${outer}inner_struct" "type = struct ${outer}inner_struct \{.*\[\r\n\]    int inner_int;.*\[\r\n\]    (long|long int|int) inner_long;.*\[\r\n\]\}.*" "ptype inner structure" 

gdb_test "ptype ${union} ${outer}inner_union" "type = union ${outer}inner_union \{.*\[\r\n\]    int inner_union_int;.*\[\r\n\]    (long|long int|int) inner_union_long;.*\[\r\n\]\}.*" "ptype inner union" 

gdb_test "ptype nested_su" "type = struct outer_struct \{.*\[\r\n\]    int outer_int;.*\[\r\n\]    (struct |)${outer}inner_struct inner_struct_instance;.*\[\r\n\]    (union |)${outer}inner_union inner_union_instance;.*\[\r\n\]    (long|long int|int) outer_long;.*\[\r\n\]\}.*" "ptype nested structure" 

gdb_test "ptype nested_su.outer_int" "type = int.*" "ptype outer int" 

gdb_test "ptype nested_su.inner_struct_instance" "type = struct ${outer}inner_struct \{.*\[\r\n\]    int inner_int;.*\[\r\n\]    (long|long int|int) inner_long;.*\[\r\n\]\}.*" "ptype nested structure #2" 

gdb_test "ptype nested_su.inner_struct_instance.inner_int" "type = int.*" "ptype inner int" 

gdb_test "ptype nested_su.inner_union_instance" "type = union ${outer}inner_union \{.*\[\r\n\]    int inner_union_int;.*\[\r\n\]    (long|long int|int) inner_union_long;.*\[\r\n\]\}.*" "ptype nested union" 


get_debug_format

# Print the type of the identifier ID, and check the response:
# - Expect to see PROTOTYPED as the type.  PROTOTYPED is not a regular
#   expression; it's a literal string.
# - If we instead see the unprototyped type PLAIN, and we're using STABS
#   generated by GCC, that's an xfail; as of 9 Feb 2002, GCC never emits
#   prototyped function types in STABS.  Like PROTOTYPED, PLAIN is a
#   literal string, not a regular expression.
# - Otherwise, it's a failure.
proc ptype_maybe_prototyped { id prototyped plain } {
    global gdb_prompt
    global gcc_compiled

    # Turn `prototyped' and `plain', which are literal strings, into
    # regular expressions by quoting any special characters they contain.
    regsub -all "\[\]\[*()\]" $prototyped "\\\\&" prototyped
    regsub -all "\[\]\[*()\]" $plain "\\\\&" plain

    send_gdb "ptype $id\n"
    gdb_expect {
        -re "type = $prototyped\[\r\n\]+$gdb_prompt $" {
            pass "ptype $id"
        }
        -re "type = $plain\[\r\n\]+$gdb_prompt $" {
            if {$gcc_compiled} { setup_xfail_format "stabs" }
            fail "ptype $id (compiler doesn't emit prototyped types)"
        }
        -re "$gdb_prompt $" {
            fail "ptype $id"
        }
        timeout {
            fail "ptype $id (timeout)"
        }
    }
}

ptype_maybe_prototyped "func_type" "int (*)(int (*)(int, float), float)" \
                                   "int (*)()"
ptype_maybe_prototyped "old_fptr" "double (*)()" "double (*)()"
ptype_maybe_prototyped "new_fptr" "double (*)(void)" "double (*)()"
ptype_maybe_prototyped "fptr" "int (*)(int, float)" "int (*)()"
ptype_maybe_prototyped "fptr2" "int *(*)(int (*)(int, float), float)" \
                               "int *(*)()"
ptype_maybe_prototyped "xptr" "int (*)(int (*)(), int (*)(void), int)" \
                              "int (*)()"
ptype_maybe_prototyped "ffptr" "int (*(*)(char))(short int)" \
                               "int (*(*)())()"
ptype_maybe_prototyped "fffptr" "int (*(*(*)(char))(short int))(long int)" \
                                "int (*(*(*)())())()"

# Test printing type of string constants and array constants, but
# requires a running process.  These call malloc, and can take a long
# time to execute over a slow serial link, so increase the timeout.

# UDI can't do this (PR 2416).  XFAIL is not suitable, because attempting
# the operation causes a slow painful death rather than a nice simple failure.

if [runto_main] then {

  if [target_info exists gdb,cannot_call_functions] {
    setup_xfail "*-*-*" 2416
    fail "This target can not call functions"
    continue
  }

  # We need to up this because this can be really slow on some boards.
  # (malloc() is called as part of the test).
  set timeout 60;

  gdb_test "ptype \"abc\""	"type = char \\\[4\\\]"
  gdb_test "ptype {'a','b','c'}"	"type = char \\\[3\\\]"
  gdb_test "ptype {0,1,2}"		"type = int \\\[3\\\]"
  gdb_test "ptype {(long)0,(long)1,(long)2}"	  "type = long \\\[3\\\]"
  gdb_test "ptype {(float)0,(float)1,(float)2}" "type = float \\\[3\\\]"
  gdb_test "ptype {{0,1,2},{3,4,5}}"	"type = int \\\[2\\\]\\\[3\\\]"
  gdb_test "ptype {4,5,6}\[2\]"	"type = int"
  gdb_test "ptype *&{4,5,6}\[1\]"	"type = int"
}
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d1 2
a2 1
#   Copyright (C) 1988, 1990, 1991, 1992, 1994 Free Software Foundation, Inc.
d16 1
a16 1
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d36 2
a37 3
if  { [compile "${srcdir}/${subdir}/${srcfile} -g -o ${binfile}"] != "" } {
    perror "Couldn't compile ${srcfile}"
    return -1
d42 2
a43 4
execute_anywhere "rm -f ${binfile}.ci"
if  { [compile "-E ${srcdir}/${subdir}/compiler.c > ${binfile}.ci"] != "" } {
    perror "Couldn't make ${binfile}.ci file"
    return -1
a44 1
source ${binfile}.ci
d56 3
a58 3
send "ptype red1\n"
expect {
    -re "type = enum primary1_tag \{red1, green1, blue1\}.*$prompt $"\
d64 1
a64 1
    -re "type = enum \{red1, green1, blue1\}.*$prompt $"\
d66 1
a66 1
    -re ".*$prompt $"	{ fail "ptype unnamed enumeration member" }
d76 2
a77 13
send "ptype struct t_struct\n"
expect {
    -re "type = struct t_struct \{.*
    (unsigned |)char v_char_member;.*
    (short|short int) v_short_member;.*
    int v_int_member;.*
    (long|long int|int) v_long_member;.*
    float v_float_member;.*
    double v_double_member;.*
\}.*$prompt $"                      { pass "ptype structure" }
    -re ".*$prompt $"	{ fail "ptype structure" }
    timeout		{ fail "(timeout) ptype structure" }
}
a81 2
    gdb_exit
    gdb_start
a84 2
    gdb_exit
    gdb_start
a87 2
    gdb_exit
    gdb_start
a90 2
    gdb_exit
    gdb_start
d95 2
a96 16
send "ptype struct link\n"
expect {
    -re "type = struct link \{.*
    struct link \[*\]next;.*
    struct link \[*(\]+linkfunc\[)(\]+;.*
    struct t_struct stuff.1..2..3.;.*
\}.*$prompt $"                      { pass "ptype linked list structure" }
    -re ".*$prompt $"	{ 

	# IBM's xlc puts out bogus stabs--the stuff field is type 42,
	# which isn't defined.

	fail "ptype linked list structure (compiler bug in IBM's xlc)"
    }
    timeout		{ fail "(timeout) ptype linked list structure" }
}
d98 1
d103 1
a103 31
send "ptype union t_union\n"
expect {
    -re "type = union t_union \{.*
    (unsigned |)char v_char_member;.*
    (short|short int) v_short_member;.*
    int v_int_member;.*
    (long|long int|int) v_long_member;.*
    float v_float_member;.*
    double v_double_member;.*
\}.*$prompt $"                      { pass "ptype union" }
    -re ".*$prompt $"	{ fail "ptype union" }
    timeout		{ fail "(timeout) ptype union" }
}


send "ptype union tu_link\n"
expect {
    -re "type = union tu_link .*
    struct link \[*\]next;.*
    struct link \[(\*\]+linkfunc\[)(\]+;.*
    struct t_struct stuff.1..2..3.;.*
\}.*$prompt $"                      { pass "ptype linked list union" }
    -re ".*$prompt $" {

	# IBM's xlc puts out bogus stabs--the stuff field is type 42,
	# which isn't defined.

	fail "ptype linked list union (compiler bug in IBM's xlc)"
    }
    timeout		{ fail "(timeout) ptype linked list union" }
}
d105 3
d113 1
a113 7
send "ptype primary\n"
expect {
    -re "type = enum .red, green, blue.*$prompt $"       { pass "ptype unnamed enumeration" }
    -re ".*$prompt $"	{ fail "ptype unnamed enumeration" }
    timeout		{ fail "(timeout) ptype unnamed enumeration" }
}

d115 1
a115 7
send "ptype enum colors\n"
expect {
    -re "type = enum colors \{yellow, purple, pink\}.*$prompt $"\
	{ pass "ptype named enumeration" }
    -re ".*$prompt $"	{ fail "ptype named enumeration" }
    timeout		{ fail "(timeout) ptype named enumeration" }
}
d121 1
a121 6
send "ptype boolean\n"
expect {
    -re "type = enum \{FALSE, TRUE\}.*$prompt $"   { pass "ptype unnamed typedef'd enumeration" }
    -re ".*$prompt $"	{ fail "ptype unnamed typedef'd enumeration" }
    timeout		{ fail "(timeout) ptype unnamed typedef'd enumeration" }
}
d124 1
a124 1

d132 9
a140 2
if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" "i*86-*-sysv4*" }
gdb_test "whatis v_boolean" "type = boolean" \
d144 1
a144 1
gdb_test "ptype t_struct3" "type = struct \{.*
d148 1
a148 1
gdb_test "ptype t_union3" "type = union \{.*
d152 1
a152 7
send "ptype enum bvals\n"
expect {
    -re "type = enum bvals \{false, true\}.*$prompt $"   { pass "ptype named typedef'd enumf'd enum" }
    -re ".*$prompt $"	{ fail "ptype named typedef'd enumeration" }
    timeout		{ fail "(timeout) ptype named typedef'd enumeration" }
}

d157 1
a157 8
send "ptype enum misordered\n"
expect {
    -re "type = enum misordered \{two = 2, one = 1, zero = 0, three = 3\}.*$prompt $"\
	{ pass "ptype misordered enumeration" }
    -re ".*$prompt $"	{ fail "ptype misordered  enumeration" }
    timeout		{ fail "(timeout) ptype misordered enumeration" }
}

d162 1
a162 16
send "ptype three\n"
expect {
    -re "type = enum misordered \{two = 2, one = 1, zero = 0, three = 3\}.*$prompt $"\
	{ pass "ptype named enumeration member" }
    -re ".*$prompt $"	{ fail "ptype named enumeration member" }
    timeout		{ fail "(timeout) ptype named enumeration member" }
}


send "ptype red\n"
expect {
    -re "type = enum \{red, green, blue\}.*$prompt $"\
	{ pass "ptype unnamed enumeration member" }
    -re ".*$prompt $"	{ fail "ptype unnamed enumeration member" }
    timeout		{ fail "(timeout) ptype unnamed enumeration member" }
}
d164 1
d174 1
a174 2
#setup_xfail "i960-*-*" 1821
#setup_xfail "mips-idt-*" "mips-sgi-*" "a29k-*-*"
d176 3
a178 3
#expect {
#    -re "type = char.*$prompt $"	{ pass "ptype char" }
#    -re ".*$prompt $"	{ fail "ptype char" }
d183 1
a183 1
#setup_xfail "mips-*-*" "a29k-*-*"
d185 3
a187 3
#expect {
#    -re "type = signed char.*$prompt $"	{ pass "ptype signed char" }
#    -re ".*$prompt $"	{ fail "ptype signed char" }
d193 3
a195 3
#expect {
#    -re "type = unsigned char.*$prompt $"	{ pass "ptype unsigned char" }
#    -re ".*$prompt $"	{ fail "ptype unsigned char" }
d199 1
a199 8

send "ptype v_short\n"
expect {
    -re "type = short(| int).*$prompt $"	{ pass "ptype short" }
    -re ".*$prompt $"	{ fail "ptype short" }
    timeout		{ fail "(timeout) ptype short" }
}

d202 3
a204 3
#expect {
#    -re "type = short.*$prompt $"	{ pass "ptype signed short" }
#    -re ".*$prompt $"	{ fail "ptype signed short" }
d210 3
a212 3
#expect {
#    -re "type = unsigned short.*$prompt $"	{ pass "ptype unsigned short" }
#    -re ".*$prompt $"	{ fail "ptype unsigned short" }
d217 1
a217 7
send "ptype v_int\n"
expect {
    -re "type = int.*$prompt $"	{ pass "ptype int" }
    -re ".*$prompt $"	{ fail "ptype int" }
    timeout		{ fail "(timeout) ptype int" }
}

d220 3
a222 3
#expect {
#    -re "type = int.*$prompt $"	{ pass "ptype signed int" }
#    -re ".*$prompt $"	{ fail "ptype signed int" }
d228 3
a230 3
#expect {
#    -re "type = unsigned int.*$prompt $"	{ pass "ptype unsigned int" }
#    -re ".*$prompt $"	{ fail "ptype unsigned int" }
d236 3
a238 3
#expect {
#    -re "type = long.*$prompt $"	{ pass "ptype long" }
#    -re ".*$prompt $"	{ fail "ptype long" }
d244 3
a246 3
#expect {
#    -re "type = long.*$prompt $"	{ pass "ptype signed long" }
#    -re ".*$prompt $"	{ fail "ptype signed long" }
d252 3
a254 3
#expect {
#    -re "type = unsigned long.*$prompt $"	{ pass "ptype unsigned long" }
#    -re ".*$prompt $"	{ fail "ptype unsigned long" }
d260 3
a262 3
#expect {
#    -re "type = float.*$prompt $"	{ pass "ptype float" }
#    -re ".*$prompt $"	{ fail "ptype float" }
d268 3
a270 3
#expect {
#    -re "type = double.*$prompt $"	{ pass "ptype double" }
#    -re ".*$prompt $"	{ fail "ptype double" }
d278 1
a278 2
#setup_xfail "i960-*-*" 1821
#setup_xfail "mips-idt-*" "mips-sgi-*" "a29k-*-*"
d280 3
a282 3
#expect {
#    -re "type = char .2..*$prompt $"	{ pass "ptype char array" }
#    -re ".*$prompt $"	{ fail "ptype char array" }
d287 1
a287 1
#setup_xfail "mips-*-*" "a29k-*-*"
d289 3
a291 3
#expect {
#    -re "type = (|signed )char .2..*$prompt $"	{ pass "ptype signed char array" }
#    -re ".*$prompt $"	{ fail "ptype signed char array" }
d297 3
a299 3
#expect {
#    -re "type = unsigned char .2..*$prompt $"	{ pass "ptype unsigned char array" }
#    -re ".*$prompt $"	{ fail "ptype unsigned char array" }
d306 3
a308 3
#expect {
#    -re "type = int .2..*$prompt $"	{ pass "ptype int array" }
#    -re ".*$prompt $"	{ fail "ptype int array" }
d314 3
a316 3
#expect {
#    -re "type = int .2..*$prompt $"	{ pass "ptype signed int array" }
#    -re ".*$prompt $"	{ fail "ptype signed int array" }
d322 3
a324 3
#expect {
#    -re "type = unsigned int .2..*$prompt $"	{ pass "ptype unsigned int array" }
#    -re ".*$prompt $"	{ fail "ptype unsigned int array" }
d330 2
a331 2
#expect {
#    -re "type = (long|int|long int) .2..*$prompt $"	{ 
d333 1
a333 1
#    -re ".*$prompt $"	{ fail "ptype long array" }
d339 2
a340 2
#expect {
#    -re "type = (long|int|long int) .2..*$prompt $"	{ 
d342 1
a342 1
#    -re ".*$prompt $"	{ fail "ptype signed long array" }
d348 3
a350 3
#expect {
#    -re "type = unsigned long .2..*$prompt $"	{ pass "ptype unsigned long array" }
#    -re ".*$prompt $"	{ fail "ptype unsigned long array" }
d356 3
a358 3
#expect {
#    -re "type = float .2..*$prompt $"	{ pass "ptype float array" }
#    -re ".*$prompt $"	{ fail "ptype float array" }
d364 3
a366 3
#expect {
#    -re "type = double .2..*$prompt $"	{ pass "ptype double array" }
#    -re ".*$prompt $"	{ fail "ptype double array" }
d372 1
d379 1
a379 2
#setup_xfail "i960-*-*" 1821
#setup_xfail "mips-idt-*" "mips-sgi-*" "a29k-*-*"
d381 3
a383 3
#expect {
#    -re "type = char \*.*$prompt $"	{ pass "ptype char pointer" }
#    -re ".*$prompt $"	{ fail "ptype char pointer" }
d388 1
a388 1
#setup_xfail "mips-*-*" "a29k-*-*"
d390 2
a391 2
#expect {
#    -re "type = (|signed )char \*.*$prompt $"
d393 1
a393 1
#    -re ".*$prompt $"	{ fail "ptype signed char pointer" }
d399 3
a401 3
#expect {
#    -re "type = unsigned char \*.*$prompt $"	{ pass "ptype unsigned char pointer" }
#    -re ".*$prompt $"	{ fail "ptype unsigned char pointer" }
d407 3
a409 3
#expect {
#    -re "type = (short|short int) \*.*$prompt $"	{ pass "ptype short pointer" }
#    -re ".*$prompt $"	{ fail "ptype short pointer" }
d415 3
a417 3
#expect {
#    -re "type = short \*.*$prompt $"	{ pass "ptype signed short pointer" }
#    -re ".*$prompt $"	{ fail "ptype signed short pointer" }
d423 3
a425 3
#expect {
#    -re "type = unsigned short \*.*$prompt $"	{ pass "ptype unsigned short pointer" }
#    -re ".*$prompt $"	{ fail "ptype unsigned short pointer" }
d431 3
a433 3
#expect {
#    -re "type = int \*.*$prompt $"	{ pass "ptype int pointer" }
#    -re ".*$prompt $"	{ fail "ptype int pointer" }
d439 3
a441 3
#expect {
#    -re "type = int \*.*$prompt $"	{ pass "ptype signed int pointer" }
#    -re ".*$prompt $"	{ fail "ptype signed int pointer" }
d447 3
a449 3
#expect {
#    -re "type = unsigned int \*.*$prompt $"	{ pass "ptype unsigned int pointer" }
#    -re ".*$prompt $"	{ fail "ptype unsigned int pointer" }
d455 3
a457 3
#expect {
#    -re "type = long \*.*$prompt $"	{ pass "ptype long pointer" }
#    -re ".*$prompt $"	{ fail "ptype long pointer" }
d463 3
a465 3
#expect {
#    -re "type = long \*.*$prompt $"	{ pass "ptype signed long pointer" }
#    -re ".*$prompt $"	{ fail "ptype signed long pointer" }
d471 3
a473 3
#expect {
#    -re "type = unsigned long \*.*$prompt $"	{ pass "ptype unsigned long pointer" }
#    -re ".*$prompt $"	{ fail "ptype unsigned long pointer" }
d479 3
a481 3
#expect {
#    -re "type = float \*.*$prompt $"	{ pass "ptype float pointer" }
#    -re ".*$prompt $"	{ fail "ptype float pointer" }
d487 3
a489 3
#expect {
#    -re "type = double \*.*$prompt $"	{ pass "ptype double pointer" }
#    -re ".*$prompt $"	{ fail "ptype double pointer" }
d496 65
a560 64
send "ptype struct outer_struct\n"
expect {
    -re "type = struct outer_struct \{.*
    int outer_int;.*
    struct inner_struct inner_struct_instance;.*
    union inner_union inner_union_instance;.*
    (long|long int|int) outer_long;.*
\}.*$prompt $"                { pass "ptype outer structure" }
    -re ".*$prompt $"	{ fail "ptype outer structure" }
    timeout		{ fail "(timeout) ptype outer structure" }
}


send "ptype struct inner_struct\n"
expect {
    -re "type = struct inner_struct \{.*
    int inner_int;.*
    (long|long int|int) inner_long;.*
\}.*$prompt $"                { pass "ptype inner structure" }
    -re ".*$prompt $"	{ fail "ptype inner structure" }
    timeout		{ fail "(timeout) ptype inner structure" }
}


send "ptype union inner_union\n"
expect {
    -re "type = union inner_union \{.*
    int inner_union_int;.*
    (long|long int|int) inner_union_long;.*
\}.*$prompt $"                { pass "ptype inner union" }
    -re ".*$prompt $"	{ fail "ptype inner union" }
    timeout		{ fail "(timeout) ptype inner union" }
}


send "ptype nested_su\n"
expect {
    -re "type = struct outer_struct \{.*
    int outer_int;.*
    struct inner_struct inner_struct_instance;.*
    union inner_union inner_union_instance;.*
    (long|long int|int) outer_long;.*
\}.*$prompt $"                { pass "ptype nested structure" }
    -re ".*$prompt $"	{ fail "ptype nested structure" }
    timeout		{ fail "(timeout) ptype nested structure" }
}


send "ptype nested_su.outer_int\n"
expect {
    -re "type = int.*$prompt $"           { pass "ptype outer int" }
    -re ".*$prompt $"	{ fail "ptype outer int" }
    timeout		{ fail "(timeout) ptype outer int" }
}


send "ptype nested_su.inner_struct_instance\n"
expect {
    -re "type = struct inner_struct \{.*
    int inner_int;.*
    (long|long int|int) inner_long;.*
\}.*$prompt $"                { pass "ptype nested structure" }
    -re ".*$prompt $"	{ fail "ptype nested structure" }
    timeout		{ fail "(timeout) ptype nested structure" }
d563 13
a575 18

send "ptype nested_su.inner_struct_instance.inner_int\n"
expect {
    -re "type = int.*$prompt $"           { pass "ptype inner int" }
    -re ".*$prompt $"	{ fail "ptype inner int" }
    timeout		{ fail "(timeout) ptype inner int" }
}


send "ptype nested_su.inner_union_instance\n"
expect {
    -re "type = union inner_union \{.*
    int inner_union_int;.*
    (long|long int|int) inner_union_long;.*
\}.*$prompt $"                { pass "ptype nested union" }
    -re ".*$prompt $"	{ fail "ptype nested union" }
    timeout		{ fail "(timeout) ptype nested union" }
}
d584 6
a589 26
if ![istarget "*-*-udi*"] then {
  if [runto_main] then {
    setup_xfail "h8300*-*-*"
    setup_xfail "a29k-*-udi" 2416
    gdb_test "ptype \"abc\""	"type = char \\\[4\\\]"
    setup_xfail "h8300*-*-*"
    setup_xfail "a29k-*-udi" 2416
    gdb_test "ptype {'a','b','c'}"	"type = char \\\[3\\\]"
    setup_xfail "h8300*-*-*"
    setup_xfail "a29k-*-udi" 2416
    gdb_test "ptype {0,1,2}"		"type = int \\\[3\\\]"
    setup_xfail "h8300*-*-*"
    setup_xfail "a29k-*-udi" 2416
    gdb_test "ptype {(long)0,(long)1,(long)2}"	  "type = long \\\[3\\\]"
    setup_xfail "h8300*-*-*"
    setup_xfail "a29k-*-udi" 2416
    gdb_test "ptype {(float)0,(float)1,(float)2}" "type = float \\\[3\\\]"
    setup_xfail "h8300*-*-*"
    setup_xfail "a29k-*-udi" 2416
    gdb_test "ptype {{0,1,2},{3,4,5}}"	"type = int \\\[2\\\]\\\[3\\\]"
    setup_xfail "h8300*-*-*"
    setup_xfail "a29k-*-udi" 2416
    gdb_test "ptype {4,5,6}\[2\]"	"type = int"
    setup_xfail "h8300*-*-*"
    setup_xfail "a29k-*-udi" 2416
    gdb_test "ptype *&{4,5,6}\[1\]"	"type = int"
d591 13
@


1.1
log
@file ptype.exp was initially added on branch CYGNUS.
@
text
@d1 729
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 604
# Copyright 1988, 1990, 1991, 1992, 1994, 1995, 1996, 1997, 1999,
# 2000, 2002, 2003 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Rob Savoye. (rob@@cygnus.com)

if $tracelevel then {
	strace $tracelevel
	}

#
# test running programs
#
set prms_id 0
set bug_id 0

set testfile "ptype"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}
if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

# Create and source the file that provides information about the compiler
# used to compile the test case.
if [get_compiler_info ${binfile}] {
    return -1;
}

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

# Test ptype of unnamed enumeration members before any action causes
# the partial symbol table to be expanded to full symbols.  This fails
# with stabs compilers which fail to use a nameless stab (such as
# pre-2.4.5 versions of gcc and most non-gcc compilers).

send_gdb "ptype red1\n"
gdb_expect {
    -re "type = enum primary1_tag \{red1, green1, blue1\}.*$gdb_prompt $"\
	{
	    # The workaround is in effect.  As this is a compiler, not GDB,
	    # bug, we'll make it a PASS but perhaps it should be an XFAIL.
	    pass "ptype unnamed enumeration member (worked around)"
	}
    -re "type = enum \{red1, green1, blue1\}.*$gdb_prompt $"\
			{ pass "ptype unnamed enumeration member" }
    -re ".*$gdb_prompt $"	{ fail "ptype unnamed enumeration member" }
    timeout		{ fail "(timeout) ptype unnamed enumeration member" }
}

#
# test ptype command with structures
#
# Here and elsewhere, we accept
# "long", "long int", or "int" for long variables (whatis.exp already
# has an XFAIL for "int" (Sun cc bug), so no need to fail it here).
gdb_test "ptype struct t_struct" "type = struct t_struct \{.*\[\r\n\]    (unsigned |)char v_char_member;.*\[\r\n\]    (short|short int) v_short_member;.*\[\r\n\]    int v_int_member;.*\[\r\n\]    (long|long int|int) v_long_member;.*\[\r\n\]    float v_float_member;.*\[\r\n\]    double v_double_member;.*\[\r\n\]\}.*" "ptype structure" 


# Test the equivalence between '.' and '->' for struct member references.

if [gdb_test "ptype v_struct1.v_float_member"	"type = float"]<0 then {
    return -1
}
if [gdb_test "ptype v_struct1->v_float_member"	"type = float"]<0 then {
    return -1
}
if [gdb_test "ptype v_t_struct_p.v_float_member"	"type = float"]<0 then {
    return -1
}
if [gdb_test "ptype v_t_struct_p->v_float_member"	"type = float"]<0 then {
    return -1
}


# IBM's xlc puts out bogus stabs--the stuff field is type 42,
# which isn't defined.

gdb_test "ptype struct link" "type = struct link \{\[\r\n\]+\[ \t\]+struct link \\*next;\[\r\n\]+\[ \t\]+struct link \\*\\(\\*linkfunc\\)\\((struct link \\*, int|void|)\\);\[\r\n\]+\[ \t\]+struct t_struct stuff.1..2..3.;\[\r\n\]+\}.*" "ptype linked list structure" 

#
# test ptype command with unions
#
gdb_test "ptype union t_union" "type = union t_union \{.*\[\r\n\]    (unsigned |)char v_char_member;.*\[\r\n\]    (short|short int) v_short_member;.*\[\r\n\]    int v_int_member;.*\[\r\n\]    (long|long int|int) v_long_member;.*\[\r\n\]    float v_float_member;.*\[\r\n\]    double v_double_member;.*\[\r\n\]\}.*" "ptype union" 

# IBM's xlc puts out bogus stabs--the stuff field is type 42,
# which isn't defined.
gdb_test "ptype union tu_link" "type = union tu_link \{\[\r\n\]+\[ \t\]+struct link \\*next;\[\r\n\]+\[ \t\]+struct link \\*\\(\\*linkfunc\\)\\((struct link \\*, int|void|)\\);\[\r\n\]+\[ \t\]+struct t_struct stuff.1..2..3.;\[\r\n\]+\}.*" "ptype linked list union" 

#
# test ptype command with enums
#

gdb_test "ptype primary" "type = enum .red, green, blue.*" "ptype unnamed enumeration" 

gdb_test "ptype enum colors" "type = enum colors \{yellow, purple, pink\}.*" "ptype named enumeration" 


#
# test ptype command with enums as typedef
#
gdb_test "ptype boolean" "type = enum (boolean |)\{FALSE, TRUE\}.*" "ptype unnamed typedef'd enumeration" 

# And check that whatis shows the name, not "enum {...}".
# This probably fails for all DWARF 1 cases, so assume so for now. -fnf
# The problem with xlc is that the stabs look like
#   :t51=eFALSE:0,TRUE:1,;
#   boolean:t55=51
#   v_boolean:G51
# GDB's behavior is correct; the type which the variable is defined
# as (51) doesn't have a name.  Only 55 has a name.

if {!$gcc_compiled && !$hp_aCC_compiler} {
    setup_xfail "rs6000-*-*" "i*86-*-sysv4*"
    setup_xfail "hppa*-*-*" CLLbs14773
}

# For get_debug_format to do its job, we need to have a current source file.
gdb_test "list main" ""
get_debug_format
gdb_test "whatis v_boolean" "type = (enum |)boolean" \
  "whatis unnamed typedef'd enum (compiler bug in IBM's xlc)"

# Same thing with struct and union.
gdb_test "ptype t_struct3" "type = struct (t_struct3 |)\{.*
 *double v_double_member;.*
 *int v_int_member;.*\}" "printing typedef'd struct"

gdb_test "ptype t_union3" "type = union (t_union3 |)\{.*
 *double v_double_member;.*
 *int v_int_member;.*\}" "printing typedef'd union"

gdb_test "ptype enum bvals" "type = enum bvals \{my_false, my_true\}.*" "ptype named typedef'd enumf'd enum"

#
# test ptype command with out-of-order enum values
#
gdb_test "ptype enum misordered" "type = enum misordered \{two = 2, one = 1, zero = 0, three = 3\}.*" "ptype misordered enumeration" 

#
# test ptype command with a named enum's value
#
gdb_test "ptype three" "type = enum misordered \{two = 2, one = 1, zero = 0, three = 3\}.*" "ptype named enumeration member" 

gdb_test "ptype red" "type = enum \{red, green, blue\}.*" "ptype unnamed enumeration member #2" 

#
# test ptype command with basic C types
#
# I've commented most of this out because it duplicates tests in whatis.exp.
# I've just left in a token test or 2 which is designed to test that ptype 
# acts like whatis for basic types.  If it is thought to be necessary to
# test both whatis and ptype for all the types, the tests should be
# merged into whatis.exp, or else maintenance will be a royal pain -kingdon
#setup_xfail "mips-idt-*" "mips-sgi-*"
#send "ptype v_char\n"
#gdb_expect {
#    -re "type = char.*$gdb_prompt $"	{ pass "ptype char" }
#    -re ".*$gdb_prompt $"	{ fail "ptype char" }
#    timeout		{ fail "(timeout) ptype char" }
#}
#
#
#setup_xfail "mips-*-*"
#send "ptype v_signed_char\n"
#gdb_expect {
#    -re "type = signed char.*$gdb_prompt $"	{ pass "ptype signed char" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed char" }
#    timeout		{ fail "(timeout) ptype signed char" }
#}
#
#
#send "ptype v_unsigned_char\n"
#gdb_expect {
#    -re "type = unsigned char.*$gdb_prompt $"	{ pass "ptype unsigned char" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned char" }
#    timeout		{ fail "(timeout) ptype unsigned char" }
#}

gdb_test "ptype v_short" "type = short(| int).*" "ptype short" 

#send "ptype v_signed_short\n"
#gdb_expect {
#    -re "type = short.*$gdb_prompt $"	{ pass "ptype signed short" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed short" }
#    timeout		{ fail "(timeout) ptype signed short" }
#}
#
#
#send "ptype v_unsigned_short\n"
#gdb_expect {
#    -re "type = unsigned short.*$gdb_prompt $"	{ pass "ptype unsigned short" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned short" }
#    timeout		{ fail "(timeout) ptype unsigned short" }
#}


gdb_test "ptype v_int" "type = int.*" "ptype int" 

#send "ptype v_signed_int\n"
#gdb_expect {
#    -re "type = int.*$gdb_prompt $"	{ pass "ptype signed int" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed int" }
#    timeout		{ fail "(timeout) ptype signed int" }
#}
#
#
#send "ptype v_unsigned_int\n"
#gdb_expect {
#    -re "type = unsigned int.*$gdb_prompt $"	{ pass "ptype unsigned int" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned int" }
#    timeout		{ fail "(timeout) ptype unsigned int" }
#}
#
#
#send "ptype v_long\n"
#gdb_expect {
#    -re "type = long.*$gdb_prompt $"	{ pass "ptype long" }
#    -re ".*$gdb_prompt $"	{ fail "ptype long" }
#    timeout		{ fail "(timeout) ptype long" }
#}
#
#
#send "ptype v_signed_long\n"
#gdb_expect {
#    -re "type = long.*$gdb_prompt $"	{ pass "ptype signed long" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed long" }
#    timeout		{ fail "(timeout) ptype signed long" }
#}
#
#
#send "ptype v_unsigned_long\n"
#gdb_expect {
#    -re "type = unsigned long.*$gdb_prompt $"	{ pass "ptype unsigned long" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned long" }
#    timeout		{ fail "(timeout) ptype unsigned long" }
#}
#
#
#send "ptype v_float\n"
#gdb_expect {
#    -re "type = float.*$gdb_prompt $"	{ pass "ptype float" }
#    -re ".*$gdb_prompt $"	{ fail "ptype float" }
#    timeout		{ fail "(timeout) ptype float" }
#}
#
#
#send "ptype v_double\n"
#gdb_expect {
#    -re "type = double.*$gdb_prompt $"	{ pass "ptype double" }
#    -re ".*$gdb_prompt $"	{ fail "ptype double" }
#    timeout		{ fail "(timeout) ptype double" }
#}


#
# test ptype command with arrays
#
#setup_xfail "mips-idt-*" "mips-sgi-*"
#send "ptype v_char_array\n"
#gdb_expect {
#    -re "type = char .2..*$gdb_prompt $"	{ pass "ptype char array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype char array" }
#    timeout		{ fail "(timeout) ptype char array" }
#}
#
#
#setup_xfail "mips-*-*"
#send "ptype v_signed_char_array\n"
#gdb_expect {
#    -re "type = (|signed )char .2..*$gdb_prompt $"	{ pass "ptype signed char array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed char array" }
#    timeout		{ fail "(timeout) ptype signed char array" }
#}
#
#
#send "ptype v_unsigned_char_array\n"
#gdb_expect {
#    -re "type = unsigned char .2..*$gdb_prompt $"	{ pass "ptype unsigned char array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned char array" }
#    timeout		{ fail "(timeout) ptype unsigned char array" }
#}
#
#
#
#send "ptype v_int_array\n"
#gdb_expect {
#    -re "type = int .2..*$gdb_prompt $"	{ pass "ptype int array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype int array" }
#    timeout		{ fail "(timeout) ptype int array" }
#}
#
#
#send "ptype v_signed_int_array\n"
#gdb_expect {
#    -re "type = int .2..*$gdb_prompt $"	{ pass "ptype signed int array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed int array" }
#    timeout		{ fail "(timeout) ptype signed int array" }
#}
#
#
#send "ptype v_unsigned_int_array\n"
#gdb_expect {
#    -re "type = unsigned int .2..*$gdb_prompt $"	{ pass "ptype unsigned int array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned int array" }
#    timeout		{ fail "(timeout) ptype unsigned int array" }
#}
#
#
#send "ptype v_long_array\n"
#gdb_expect {
#    -re "type = (long|int|long int) .2..*$gdb_prompt $"	{ 
#	pass "ptype long array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype long array" }
#    timeout		{ fail "(timeout) ptype long array" }
#}
#
#
#send "ptype v_signed_long_array\n"
#gdb_expect {
#    -re "type = (long|int|long int) .2..*$gdb_prompt $"	{ 
#	pass "ptype signed long array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed long array" }
#    timeout		{ fail "(timeout) ptype signed long array" }
#}
#
#
#send "ptype v_unsigned_long_array\n"
#gdb_expect {
#    -re "type = unsigned long .2..*$gdb_prompt $"	{ pass "ptype unsigned long array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned long array" }
#    timeout		{ fail "(timeout) ptype unsigned long array" }
#}
#
#
#send "ptype v_float_array\n"
#gdb_expect {
#    -re "type = float .2..*$gdb_prompt $"	{ pass "ptype float array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype float array" }
#    timeout		{ fail "(timeout) ptype float array" }
#}
#
#
#send "ptype v_double_array\n"
#gdb_expect {
#    -re "type = double .2..*$gdb_prompt $"	{ pass "ptype double array" }
#    -re ".*$gdb_prompt $"	{ fail "ptype double array" }
#    timeout		{ fail "(timeout) ptype double array" }
#}
#

if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" "i*86-*-sysv4*" }
if {$hp_aCC_compiler} {setup_xfail "hppa*-*-*"}
gdb_test "ptype t_char_array" "type = (|unsigned )char \\\[0?\\\]"

#
##
## test ptype command with pointers
##
#setup_xfail "mips-idt-*" "mips-sgi-*"
#send "ptype v_char_pointer\n"
#gdb_expect {
#    -re "type = char \*.*$gdb_prompt $"	{ pass "ptype char pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype char pointer" }
#    timeout		{ fail "(timeout) ptype char pointer" }
#}
#
#
#setup_xfail "mips-*-*"
#send "ptype v_signed_char_pointer\n"
#gdb_expect {
#    -re "type = (|signed )char \*.*$gdb_prompt $"
#	{ pass "ptype signed char pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed char pointer" }
#    timeout		{ fail "(timeout) ptype signed char pointer" }
#}
#
#
#send "ptype v_unsigned_char_pointer\n"
#gdb_expect {
#    -re "type = unsigned char \*.*$gdb_prompt $"	{ pass "ptype unsigned char pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned char pointer" }
#    timeout		{ fail "(timeout) ptype unsigned char pointer" }
#}
#
#
#send "ptype v_short_pointer\n"
#gdb_expect {
#    -re "type = (short|short int) \*.*$gdb_prompt $"	{ pass "ptype short pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype short pointer" }
#    timeout		{ fail "(timeout) ptype short pointer" }
#}
#
#
#send "ptype v_signed_short_pointer\n"
#gdb_expect {
#    -re "type = short \*.*$gdb_prompt $"	{ pass "ptype signed short pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed short pointer" }
#    timeout		{ fail "(timeout) ptype signed short pointer" }
#}
#
#
#send "ptype v_unsigned_short_pointer\n"
#gdb_expect {
#    -re "type = unsigned short \*.*$gdb_prompt $"	{ pass "ptype unsigned short pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned short pointer" }
#    timeout		{ fail "(timeout) ptype unsigned short pointer" }
#}
#
#
#send "ptype v_int_pointer\n"
#gdb_expect {
#    -re "type = int \*.*$gdb_prompt $"	{ pass "ptype int pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype int pointer" }
#    timeout		{ fail "(timeout) ptype int pointer" }
#}
#
#
#send "ptype v_signed_int_pointer\n"
#gdb_expect {
#    -re "type = int \*.*$gdb_prompt $"	{ pass "ptype signed int pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed int pointer" }
#    timeout		{ fail "(timeout) ptype signed int pointer" }
#}
#
#
#send "ptype v_unsigned_int_pointer\n"
#gdb_expect {
#    -re "type = unsigned int \*.*$gdb_prompt $"	{ pass "ptype unsigned int pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned int pointer" }
#    timeout		{ fail "(timeout) ptype unsigned int pointer" }
#}
#
#
#send "ptype v_long_pointer\n"
#gdb_expect {
#    -re "type = long \*.*$gdb_prompt $"	{ pass "ptype long pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype long pointer" }
#    timeout		{ fail "(timeout) ptype long pointer" }
#}
#
#
#send "ptype v_signed_long_pointer\n"
#gdb_expect {
#    -re "type = long \*.*$gdb_prompt $"	{ pass "ptype signed long pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype signed long pointer" }
#    timeout		{ fail "(timeout) ptype signed long pointer" }
#}
#
#
#send "ptype v_unsigned_long_pointer\n"
#gdb_expect {
#    -re "type = unsigned long \*.*$gdb_prompt $"	{ pass "ptype unsigned long pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype unsigned long pointer" }
#    timeout		{ fail "(timeout) ptype unsigned long pointer" }
#}
#
#
#send "ptype v_float_pointer\n"
#gdb_expect {
#    -re "type = float \*.*$gdb_prompt $"	{ pass "ptype float pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype float pointer" }
#    timeout		{ fail "(timeout) ptype float pointer" }
#}
#
#
#send "ptype v_double_pointer\n"
#gdb_expect {
#    -re "type = double \*.*$gdb_prompt $"	{ pass "ptype double pointer" }
#    -re ".*$gdb_prompt $"	{ fail "ptype double pointer" }
#    timeout		{ fail "(timeout) ptype double pointer" }
#}

#
# test ptype command with nested structure and union
#
if {$hp_aCC_compiler} {
    set outer "outer_struct::"
    set struct ""
    set union ""
} else {
    set outer ""
    set struct "struct"
    set union "union"
}
gdb_test "ptype struct outer_struct" "type = struct outer_struct \{.*\[\r\n\]+\
.*int outer_int;.*\[\r\n\]+\
.*(struct|) ${outer}inner_struct inner_struct_instance;.*\[\r\n\]+\
.*(union|) ${outer}inner_union inner_union_instance;.*\[\r\n\]+\
.*(long|long int|int) outer_long;.*\[\r\n\]\}.*" "ptype outer structure" 

gdb_test "ptype ${struct} ${outer}inner_struct" "type = struct ${outer}inner_struct \{.*\[\r\n\]    int inner_int;.*\[\r\n\]    (long|long int|int) inner_long;.*\[\r\n\]\}.*" "ptype inner structure" 

gdb_test "ptype ${union} ${outer}inner_union" "type = union ${outer}inner_union \{.*\[\r\n\]    int inner_union_int;.*\[\r\n\]    (long|long int|int) inner_union_long;.*\[\r\n\]\}.*" "ptype inner union" 

gdb_test "ptype nested_su" "type = struct outer_struct \{.*\[\r\n\]    int outer_int;.*\[\r\n\]    (struct |)${outer}inner_struct inner_struct_instance;.*\[\r\n\]    (union |)${outer}inner_union inner_union_instance;.*\[\r\n\]    (long|long int|int) outer_long;.*\[\r\n\]\}.*" "ptype nested structure" 

gdb_test "ptype nested_su.outer_int" "type = int.*" "ptype outer int" 

gdb_test "ptype nested_su.inner_struct_instance" "type = struct ${outer}inner_struct \{.*\[\r\n\]    int inner_int;.*\[\r\n\]    (long|long int|int) inner_long;.*\[\r\n\]\}.*" "ptype nested structure #2" 

gdb_test "ptype nested_su.inner_struct_instance.inner_int" "type = int.*" "ptype inner int" 

gdb_test "ptype nested_su.inner_union_instance" "type = union ${outer}inner_union \{.*\[\r\n\]    int inner_union_int;.*\[\r\n\]    (long|long int|int) inner_union_long;.*\[\r\n\]\}.*" "ptype nested union" 


get_debug_format

# Print the type of the identifier ID, and check the response:
# - Expect to see PROTOTYPED as the type.  PROTOTYPED is not a regular
#   expression; it's a literal string.
# - If we instead see the unprototyped type PLAIN, and we're using STABS
#   generated by GCC, that's an xfail; as of 9 Feb 2002, GCC never emits
#   prototyped function types in STABS.  Like PROTOTYPED, PLAIN is a
#   literal string, not a regular expression.
# - Otherwise, it's a failure.
proc ptype_maybe_prototyped { id prototyped plain } {
    global gdb_prompt
    global gcc_compiled

    # Turn `prototyped' and `plain', which are literal strings, into
    # regular expressions by quoting any special characters they contain.
    regsub -all "\[\]\[*()\]" $prototyped "\\\\&" prototyped
    regsub -all "\[\]\[*()\]" $plain "\\\\&" plain

    send_gdb "ptype $id\n"
    gdb_expect {
        -re "type = $prototyped\[\r\n\]+$gdb_prompt $" {
            pass "ptype $id"
        }
        -re "type = $plain\[\r\n\]+$gdb_prompt $" {
            if {$gcc_compiled} { setup_xfail_format "stabs" }
            fail "ptype $id (compiler doesn't emit prototyped types)"
        }
        -re "$gdb_prompt $" {
            fail "ptype $id"
        }
        timeout {
            fail "ptype $id (timeout)"
        }
    }
}

ptype_maybe_prototyped "func_type" "int (*)(int (*)(int, float), float)" \
                                   "int (*)()"
ptype_maybe_prototyped "old_fptr" "double (*)()" "double (*)()"
ptype_maybe_prototyped "new_fptr" "double (*)(void)" "double (*)()"
ptype_maybe_prototyped "fptr" "int (*)(int, float)" "int (*)()"
ptype_maybe_prototyped "fptr2" "int *(*)(int (*)(int, float), float)" \
                               "int *(*)()"
ptype_maybe_prototyped "xptr" "int (*)(int (*)(), int (*)(void), int)" \
                              "int (*)()"
ptype_maybe_prototyped "ffptr" "int (*(*)(char))(short int)" \
                               "int (*(*)())()"
ptype_maybe_prototyped "fffptr" "int (*(*(*)(char))(short int))(long int)" \
                                "int (*(*(*)())())()"

# Test printing type of string constants and array constants, but
# requires a running process.  These call malloc, and can take a long
# time to execute over a slow serial link, so increase the timeout.

# UDI can't do this (PR 2416).  XFAIL is not suitable, because attempting
# the operation causes a slow painful death rather than a nice simple failure.

if [runto_main] then {

  if [target_info exists gdb,cannot_call_functions] {
    setup_xfail "*-*-*" 2416
    fail "This target can not call functions"
    continue
  }

  # We need to up this because this can be really slow on some boards.
  # (malloc() is called as part of the test).
  set timeout 60;

  gdb_test "ptype \"abc\""	"type = char \\\[4\\\]"
  gdb_test "ptype {'a','b','c'}"	"type = char \\\[3\\\]"
  gdb_test "ptype {0,1,2}"		"type = int \\\[3\\\]"
  gdb_test "ptype {(long)0,(long)1,(long)2}"	  "type = long \\\[3\\\]"
  gdb_test "ptype {(float)0,(float)1,(float)2}" "type = float \\\[3\\\]"
  gdb_test "ptype {{0,1,2},{3,4,5}}"	"type = int \\\[2\\\]\\\[3\\\]"
  gdb_test "ptype {4,5,6}\[2\]"	"type = int"
  gdb_test "ptype *&{4,5,6}\[1\]"	"type = int"
}
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 729
#   Copyright (C) 1988, 1990, 1991, 1992, 1994 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Rob Savoye. (rob@@cygnus.com)

if $tracelevel then {
	strace $tracelevel
	}

#
# test running programs
#
set prms_id 0
set bug_id 0

set testfile "ptype"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}
if  { [compile "${srcdir}/${subdir}/${srcfile} -g -o ${binfile}"] != "" } {
    perror "Couldn't compile ${srcfile}"
    return -1
}

# Create and source the file that provides information about the compiler
# used to compile the test case.
execute_anywhere "rm -f ${binfile}.ci"
if  { [compile "-E ${srcdir}/${subdir}/compiler.c > ${binfile}.ci"] != "" } {
    perror "Couldn't make ${binfile}.ci file"
    return -1
}
source ${binfile}.ci

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

# Test ptype of unnamed enumeration members before any action causes
# the partial symbol table to be expanded to full symbols.  This fails
# with stabs compilers which fail to use a nameless stab (such as
# pre-2.4.5 versions of gcc and most non-gcc compilers).

send "ptype red1\n"
expect {
    -re "type = enum primary1_tag \{red1, green1, blue1\}.*$prompt $"\
	{
	    # The workaround is in effect.  As this is a compiler, not GDB,
	    # bug, we'll make it a PASS but perhaps it should be an XFAIL.
	    pass "ptype unnamed enumeration member (worked around)"
	}
    -re "type = enum \{red1, green1, blue1\}.*$prompt $"\
			{ pass "ptype unnamed enumeration member" }
    -re ".*$prompt $"	{ fail "ptype unnamed enumeration member" }
    timeout		{ fail "(timeout) ptype unnamed enumeration member" }
}

#
# test ptype command with structures
#
# Here and elsewhere, we accept
# "long", "long int", or "int" for long variables (whatis.exp already
# has an XFAIL for "int" (Sun cc bug), so no need to fail it here).
send "ptype struct t_struct\n"
expect {
    -re "type = struct t_struct \{.*
    (unsigned |)char v_char_member;.*
    (short|short int) v_short_member;.*
    int v_int_member;.*
    (long|long int|int) v_long_member;.*
    float v_float_member;.*
    double v_double_member;.*
\}.*$prompt $"                      { pass "ptype structure" }
    -re ".*$prompt $"	{ fail "ptype structure" }
    timeout		{ fail "(timeout) ptype structure" }
}

# Test the equivalence between '.' and '->' for struct member references.

if [gdb_test "ptype v_struct1.v_float_member"	"type = float"]<0 then {
    gdb_exit
    gdb_start
    return -1
}
if [gdb_test "ptype v_struct1->v_float_member"	"type = float"]<0 then {
    gdb_exit
    gdb_start
    return -1
}
if [gdb_test "ptype v_t_struct_p.v_float_member"	"type = float"]<0 then {
    gdb_exit
    gdb_start
    return -1
}
if [gdb_test "ptype v_t_struct_p->v_float_member"	"type = float"]<0 then {
    gdb_exit
    gdb_start
    return -1
}


send "ptype struct link\n"
expect {
    -re "type = struct link \{.*
    struct link \[*\]next;.*
    struct link \[*(\]+linkfunc\[)(\]+;.*
    struct t_struct stuff.1..2..3.;.*
\}.*$prompt $"                      { pass "ptype linked list structure" }
    -re ".*$prompt $"	{ 

	# IBM's xlc puts out bogus stabs--the stuff field is type 42,
	# which isn't defined.

	fail "ptype linked list structure (compiler bug in IBM's xlc)"
    }
    timeout		{ fail "(timeout) ptype linked list structure" }
}


#
# test ptype command with unions
#
send "ptype union t_union\n"
expect {
    -re "type = union t_union \{.*
    (unsigned |)char v_char_member;.*
    (short|short int) v_short_member;.*
    int v_int_member;.*
    (long|long int|int) v_long_member;.*
    float v_float_member;.*
    double v_double_member;.*
\}.*$prompt $"                      { pass "ptype union" }
    -re ".*$prompt $"	{ fail "ptype union" }
    timeout		{ fail "(timeout) ptype union" }
}


send "ptype union tu_link\n"
expect {
    -re "type = union tu_link .*
    struct link \[*\]next;.*
    struct link \[(\*\]+linkfunc\[)(\]+;.*
    struct t_struct stuff.1..2..3.;.*
\}.*$prompt $"                      { pass "ptype linked list union" }
    -re ".*$prompt $" {

	# IBM's xlc puts out bogus stabs--the stuff field is type 42,
	# which isn't defined.

	fail "ptype linked list union (compiler bug in IBM's xlc)"
    }
    timeout		{ fail "(timeout) ptype linked list union" }
}


#
# test ptype command with enums
#

send "ptype primary\n"
expect {
    -re "type = enum .red, green, blue.*$prompt $"       { pass "ptype unnamed enumeration" }
    -re ".*$prompt $"	{ fail "ptype unnamed enumeration" }
    timeout		{ fail "(timeout) ptype unnamed enumeration" }
}


send "ptype enum colors\n"
expect {
    -re "type = enum colors \{yellow, purple, pink\}.*$prompt $"\
	{ pass "ptype named enumeration" }
    -re ".*$prompt $"	{ fail "ptype named enumeration" }
    timeout		{ fail "(timeout) ptype named enumeration" }
}


#
# test ptype command with enums as typedef
#
send "ptype boolean\n"
expect {
    -re "type = enum \{FALSE, TRUE\}.*$prompt $"   { pass "ptype unnamed typedef'd enumeration" }
    -re ".*$prompt $"	{ fail "ptype unnamed typedef'd enumeration" }
    timeout		{ fail "(timeout) ptype unnamed typedef'd enumeration" }
}

# And check that whatis shows the name, not "enum {...}".

# The problem with xlc is that the stabs look like
#   :t51=eFALSE:0,TRUE:1,;
#   boolean:t55=51
#   v_boolean:G51
# GDB's behavior is correct; the type which the variable is defined
# as (51) doesn't have a name.  Only 55 has a name.

if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" "i*86-*-sysv4*" }
gdb_test "whatis v_boolean" "type = boolean" \
  "whatis unnamed typedef'd enum (compiler bug in IBM's xlc)"

# Same thing with struct and union.
gdb_test "ptype t_struct3" "type = struct \{.*
 *double v_double_member;.*
 *int v_int_member;.*\}" "printing typedef'd struct"

gdb_test "ptype t_union3" "type = union \{.*
 *double v_double_member;.*
 *int v_int_member;.*\}" "printing typedef'd union"

send "ptype enum bvals\n"
expect {
    -re "type = enum bvals \{false, true\}.*$prompt $"   { pass "ptype named typedef'd enumf'd enum" }
    -re ".*$prompt $"	{ fail "ptype named typedef'd enumeration" }
    timeout		{ fail "(timeout) ptype named typedef'd enumeration" }
}


#
# test ptype command with out-of-order enum values
#
send "ptype enum misordered\n"
expect {
    -re "type = enum misordered \{two = 2, one = 1, zero = 0, three = 3\}.*$prompt $"\
	{ pass "ptype misordered enumeration" }
    -re ".*$prompt $"	{ fail "ptype misordered  enumeration" }
    timeout		{ fail "(timeout) ptype misordered enumeration" }
}


#
# test ptype command with a named enum's value
#
send "ptype three\n"
expect {
    -re "type = enum misordered \{two = 2, one = 1, zero = 0, three = 3\}.*$prompt $"\
	{ pass "ptype named enumeration member" }
    -re ".*$prompt $"	{ fail "ptype named enumeration member" }
    timeout		{ fail "(timeout) ptype named enumeration member" }
}


send "ptype red\n"
expect {
    -re "type = enum \{red, green, blue\}.*$prompt $"\
	{ pass "ptype unnamed enumeration member" }
    -re ".*$prompt $"	{ fail "ptype unnamed enumeration member" }
    timeout		{ fail "(timeout) ptype unnamed enumeration member" }
}


#
# test ptype command with basic C types
#
# I've commented most of this out because it duplicates tests in whatis.exp.
# I've just left in a token test or 2 which is designed to test that ptype 
# acts like whatis for basic types.  If it is thought to be necessary to
# test both whatis and ptype for all the types, the tests should be
# merged into whatis.exp, or else maintenance will be a royal pain -kingdon
#setup_xfail "i960-*-*" 1821
#setup_xfail "mips-idt-*" "mips-sgi-*" "a29k-*-*"
#send "ptype v_char\n"
#expect {
#    -re "type = char.*$prompt $"	{ pass "ptype char" }
#    -re ".*$prompt $"	{ fail "ptype char" }
#    timeout		{ fail "(timeout) ptype char" }
#}
#
#
#setup_xfail "mips-*-*" "a29k-*-*"
#send "ptype v_signed_char\n"
#expect {
#    -re "type = signed char.*$prompt $"	{ pass "ptype signed char" }
#    -re ".*$prompt $"	{ fail "ptype signed char" }
#    timeout		{ fail "(timeout) ptype signed char" }
#}
#
#
#send "ptype v_unsigned_char\n"
#expect {
#    -re "type = unsigned char.*$prompt $"	{ pass "ptype unsigned char" }
#    -re ".*$prompt $"	{ fail "ptype unsigned char" }
#    timeout		{ fail "(timeout) ptype unsigned char" }
#}


send "ptype v_short\n"
expect {
    -re "type = short(| int).*$prompt $"	{ pass "ptype short" }
    -re ".*$prompt $"	{ fail "ptype short" }
    timeout		{ fail "(timeout) ptype short" }
}


#send "ptype v_signed_short\n"
#expect {
#    -re "type = short.*$prompt $"	{ pass "ptype signed short" }
#    -re ".*$prompt $"	{ fail "ptype signed short" }
#    timeout		{ fail "(timeout) ptype signed short" }
#}
#
#
#send "ptype v_unsigned_short\n"
#expect {
#    -re "type = unsigned short.*$prompt $"	{ pass "ptype unsigned short" }
#    -re ".*$prompt $"	{ fail "ptype unsigned short" }
#    timeout		{ fail "(timeout) ptype unsigned short" }
#}


send "ptype v_int\n"
expect {
    -re "type = int.*$prompt $"	{ pass "ptype int" }
    -re ".*$prompt $"	{ fail "ptype int" }
    timeout		{ fail "(timeout) ptype int" }
}


#send "ptype v_signed_int\n"
#expect {
#    -re "type = int.*$prompt $"	{ pass "ptype signed int" }
#    -re ".*$prompt $"	{ fail "ptype signed int" }
#    timeout		{ fail "(timeout) ptype signed int" }
#}
#
#
#send "ptype v_unsigned_int\n"
#expect {
#    -re "type = unsigned int.*$prompt $"	{ pass "ptype unsigned int" }
#    -re ".*$prompt $"	{ fail "ptype unsigned int" }
#    timeout		{ fail "(timeout) ptype unsigned int" }
#}
#
#
#send "ptype v_long\n"
#expect {
#    -re "type = long.*$prompt $"	{ pass "ptype long" }
#    -re ".*$prompt $"	{ fail "ptype long" }
#    timeout		{ fail "(timeout) ptype long" }
#}
#
#
#send "ptype v_signed_long\n"
#expect {
#    -re "type = long.*$prompt $"	{ pass "ptype signed long" }
#    -re ".*$prompt $"	{ fail "ptype signed long" }
#    timeout		{ fail "(timeout) ptype signed long" }
#}
#
#
#send "ptype v_unsigned_long\n"
#expect {
#    -re "type = unsigned long.*$prompt $"	{ pass "ptype unsigned long" }
#    -re ".*$prompt $"	{ fail "ptype unsigned long" }
#    timeout		{ fail "(timeout) ptype unsigned long" }
#}
#
#
#send "ptype v_float\n"
#expect {
#    -re "type = float.*$prompt $"	{ pass "ptype float" }
#    -re ".*$prompt $"	{ fail "ptype float" }
#    timeout		{ fail "(timeout) ptype float" }
#}
#
#
#send "ptype v_double\n"
#expect {
#    -re "type = double.*$prompt $"	{ pass "ptype double" }
#    -re ".*$prompt $"	{ fail "ptype double" }
#    timeout		{ fail "(timeout) ptype double" }
#}


#
# test ptype command with arrays
#
#setup_xfail "i960-*-*" 1821
#setup_xfail "mips-idt-*" "mips-sgi-*" "a29k-*-*"
#send "ptype v_char_array\n"
#expect {
#    -re "type = char .2..*$prompt $"	{ pass "ptype char array" }
#    -re ".*$prompt $"	{ fail "ptype char array" }
#    timeout		{ fail "(timeout) ptype char array" }
#}
#
#
#setup_xfail "mips-*-*" "a29k-*-*"
#send "ptype v_signed_char_array\n"
#expect {
#    -re "type = (|signed )char .2..*$prompt $"	{ pass "ptype signed char array" }
#    -re ".*$prompt $"	{ fail "ptype signed char array" }
#    timeout		{ fail "(timeout) ptype signed char array" }
#}
#
#
#send "ptype v_unsigned_char_array\n"
#expect {
#    -re "type = unsigned char .2..*$prompt $"	{ pass "ptype unsigned char array" }
#    -re ".*$prompt $"	{ fail "ptype unsigned char array" }
#    timeout		{ fail "(timeout) ptype unsigned char array" }
#}
#
#
#
#send "ptype v_int_array\n"
#expect {
#    -re "type = int .2..*$prompt $"	{ pass "ptype int array" }
#    -re ".*$prompt $"	{ fail "ptype int array" }
#    timeout		{ fail "(timeout) ptype int array" }
#}
#
#
#send "ptype v_signed_int_array\n"
#expect {
#    -re "type = int .2..*$prompt $"	{ pass "ptype signed int array" }
#    -re ".*$prompt $"	{ fail "ptype signed int array" }
#    timeout		{ fail "(timeout) ptype signed int array" }
#}
#
#
#send "ptype v_unsigned_int_array\n"
#expect {
#    -re "type = unsigned int .2..*$prompt $"	{ pass "ptype unsigned int array" }
#    -re ".*$prompt $"	{ fail "ptype unsigned int array" }
#    timeout		{ fail "(timeout) ptype unsigned int array" }
#}
#
#
#send "ptype v_long_array\n"
#expect {
#    -re "type = (long|int|long int) .2..*$prompt $"	{ 
#	pass "ptype long array" }
#    -re ".*$prompt $"	{ fail "ptype long array" }
#    timeout		{ fail "(timeout) ptype long array" }
#}
#
#
#send "ptype v_signed_long_array\n"
#expect {
#    -re "type = (long|int|long int) .2..*$prompt $"	{ 
#	pass "ptype signed long array" }
#    -re ".*$prompt $"	{ fail "ptype signed long array" }
#    timeout		{ fail "(timeout) ptype signed long array" }
#}
#
#
#send "ptype v_unsigned_long_array\n"
#expect {
#    -re "type = unsigned long .2..*$prompt $"	{ pass "ptype unsigned long array" }
#    -re ".*$prompt $"	{ fail "ptype unsigned long array" }
#    timeout		{ fail "(timeout) ptype unsigned long array" }
#}
#
#
#send "ptype v_float_array\n"
#expect {
#    -re "type = float .2..*$prompt $"	{ pass "ptype float array" }
#    -re ".*$prompt $"	{ fail "ptype float array" }
#    timeout		{ fail "(timeout) ptype float array" }
#}
#
#
#send "ptype v_double_array\n"
#expect {
#    -re "type = double .2..*$prompt $"	{ pass "ptype double array" }
#    -re ".*$prompt $"	{ fail "ptype double array" }
#    timeout		{ fail "(timeout) ptype double array" }
#}
#

if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" "i*86-*-sysv4*" }
gdb_test "ptype t_char_array" "type = (|unsigned )char \\\[0?\\\]"

#
##
## test ptype command with pointers
##
#setup_xfail "i960-*-*" 1821
#setup_xfail "mips-idt-*" "mips-sgi-*" "a29k-*-*"
#send "ptype v_char_pointer\n"
#expect {
#    -re "type = char \*.*$prompt $"	{ pass "ptype char pointer" }
#    -re ".*$prompt $"	{ fail "ptype char pointer" }
#    timeout		{ fail "(timeout) ptype char pointer" }
#}
#
#
#setup_xfail "mips-*-*" "a29k-*-*"
#send "ptype v_signed_char_pointer\n"
#expect {
#    -re "type = (|signed )char \*.*$prompt $"
#	{ pass "ptype signed char pointer" }
#    -re ".*$prompt $"	{ fail "ptype signed char pointer" }
#    timeout		{ fail "(timeout) ptype signed char pointer" }
#}
#
#
#send "ptype v_unsigned_char_pointer\n"
#expect {
#    -re "type = unsigned char \*.*$prompt $"	{ pass "ptype unsigned char pointer" }
#    -re ".*$prompt $"	{ fail "ptype unsigned char pointer" }
#    timeout		{ fail "(timeout) ptype unsigned char pointer" }
#}
#
#
#send "ptype v_short_pointer\n"
#expect {
#    -re "type = (short|short int) \*.*$prompt $"	{ pass "ptype short pointer" }
#    -re ".*$prompt $"	{ fail "ptype short pointer" }
#    timeout		{ fail "(timeout) ptype short pointer" }
#}
#
#
#send "ptype v_signed_short_pointer\n"
#expect {
#    -re "type = short \*.*$prompt $"	{ pass "ptype signed short pointer" }
#    -re ".*$prompt $"	{ fail "ptype signed short pointer" }
#    timeout		{ fail "(timeout) ptype signed short pointer" }
#}
#
#
#send "ptype v_unsigned_short_pointer\n"
#expect {
#    -re "type = unsigned short \*.*$prompt $"	{ pass "ptype unsigned short pointer" }
#    -re ".*$prompt $"	{ fail "ptype unsigned short pointer" }
#    timeout		{ fail "(timeout) ptype unsigned short pointer" }
#}
#
#
#send "ptype v_int_pointer\n"
#expect {
#    -re "type = int \*.*$prompt $"	{ pass "ptype int pointer" }
#    -re ".*$prompt $"	{ fail "ptype int pointer" }
#    timeout		{ fail "(timeout) ptype int pointer" }
#}
#
#
#send "ptype v_signed_int_pointer\n"
#expect {
#    -re "type = int \*.*$prompt $"	{ pass "ptype signed int pointer" }
#    -re ".*$prompt $"	{ fail "ptype signed int pointer" }
#    timeout		{ fail "(timeout) ptype signed int pointer" }
#}
#
#
#send "ptype v_unsigned_int_pointer\n"
#expect {
#    -re "type = unsigned int \*.*$prompt $"	{ pass "ptype unsigned int pointer" }
#    -re ".*$prompt $"	{ fail "ptype unsigned int pointer" }
#    timeout		{ fail "(timeout) ptype unsigned int pointer" }
#}
#
#
#send "ptype v_long_pointer\n"
#expect {
#    -re "type = long \*.*$prompt $"	{ pass "ptype long pointer" }
#    -re ".*$prompt $"	{ fail "ptype long pointer" }
#    timeout		{ fail "(timeout) ptype long pointer" }
#}
#
#
#send "ptype v_signed_long_pointer\n"
#expect {
#    -re "type = long \*.*$prompt $"	{ pass "ptype signed long pointer" }
#    -re ".*$prompt $"	{ fail "ptype signed long pointer" }
#    timeout		{ fail "(timeout) ptype signed long pointer" }
#}
#
#
#send "ptype v_unsigned_long_pointer\n"
#expect {
#    -re "type = unsigned long \*.*$prompt $"	{ pass "ptype unsigned long pointer" }
#    -re ".*$prompt $"	{ fail "ptype unsigned long pointer" }
#    timeout		{ fail "(timeout) ptype unsigned long pointer" }
#}
#
#
#send "ptype v_float_pointer\n"
#expect {
#    -re "type = float \*.*$prompt $"	{ pass "ptype float pointer" }
#    -re ".*$prompt $"	{ fail "ptype float pointer" }
#    timeout		{ fail "(timeout) ptype float pointer" }
#}
#
#
#send "ptype v_double_pointer\n"
#expect {
#    -re "type = double \*.*$prompt $"	{ pass "ptype double pointer" }
#    -re ".*$prompt $"	{ fail "ptype double pointer" }
#    timeout		{ fail "(timeout) ptype double pointer" }
#}

#
# test ptype command with nested structure and union
#
send "ptype struct outer_struct\n"
expect {
    -re "type = struct outer_struct \{.*
    int outer_int;.*
    struct inner_struct inner_struct_instance;.*
    union inner_union inner_union_instance;.*
    (long|long int|int) outer_long;.*
\}.*$prompt $"                { pass "ptype outer structure" }
    -re ".*$prompt $"	{ fail "ptype outer structure" }
    timeout		{ fail "(timeout) ptype outer structure" }
}


send "ptype struct inner_struct\n"
expect {
    -re "type = struct inner_struct \{.*
    int inner_int;.*
    (long|long int|int) inner_long;.*
\}.*$prompt $"                { pass "ptype inner structure" }
    -re ".*$prompt $"	{ fail "ptype inner structure" }
    timeout		{ fail "(timeout) ptype inner structure" }
}


send "ptype union inner_union\n"
expect {
    -re "type = union inner_union \{.*
    int inner_union_int;.*
    (long|long int|int) inner_union_long;.*
\}.*$prompt $"                { pass "ptype inner union" }
    -re ".*$prompt $"	{ fail "ptype inner union" }
    timeout		{ fail "(timeout) ptype inner union" }
}


send "ptype nested_su\n"
expect {
    -re "type = struct outer_struct \{.*
    int outer_int;.*
    struct inner_struct inner_struct_instance;.*
    union inner_union inner_union_instance;.*
    (long|long int|int) outer_long;.*
\}.*$prompt $"                { pass "ptype nested structure" }
    -re ".*$prompt $"	{ fail "ptype nested structure" }
    timeout		{ fail "(timeout) ptype nested structure" }
}


send "ptype nested_su.outer_int\n"
expect {
    -re "type = int.*$prompt $"           { pass "ptype outer int" }
    -re ".*$prompt $"	{ fail "ptype outer int" }
    timeout		{ fail "(timeout) ptype outer int" }
}


send "ptype nested_su.inner_struct_instance\n"
expect {
    -re "type = struct inner_struct \{.*
    int inner_int;.*
    (long|long int|int) inner_long;.*
\}.*$prompt $"                { pass "ptype nested structure" }
    -re ".*$prompt $"	{ fail "ptype nested structure" }
    timeout		{ fail "(timeout) ptype nested structure" }
}


send "ptype nested_su.inner_struct_instance.inner_int\n"
expect {
    -re "type = int.*$prompt $"           { pass "ptype inner int" }
    -re ".*$prompt $"	{ fail "ptype inner int" }
    timeout		{ fail "(timeout) ptype inner int" }
}


send "ptype nested_su.inner_union_instance\n"
expect {
    -re "type = union inner_union \{.*
    int inner_union_int;.*
    (long|long int|int) inner_union_long;.*
\}.*$prompt $"                { pass "ptype nested union" }
    -re ".*$prompt $"	{ fail "ptype nested union" }
    timeout		{ fail "(timeout) ptype nested union" }
}

# Test printing type of string constants and array constants, but
# requires a running process.  These call malloc, and can take a long
# time to execute over a slow serial link, so increase the timeout.

# UDI can't do this (PR 2416).  XFAIL is not suitable, because attempting
# the operation causes a slow painful death rather than a nice simple failure.

if ![istarget "*-*-udi*"] then {
  if [runto_main] then {
    setup_xfail "h8300*-*-*"
    setup_xfail "a29k-*-udi" 2416
    gdb_test "ptype \"abc\""	"type = char \\\[4\\\]"
    setup_xfail "h8300*-*-*"
    setup_xfail "a29k-*-udi" 2416
    gdb_test "ptype {'a','b','c'}"	"type = char \\\[3\\\]"
    setup_xfail "h8300*-*-*"
    setup_xfail "a29k-*-udi" 2416
    gdb_test "ptype {0,1,2}"		"type = int \\\[3\\\]"
    setup_xfail "h8300*-*-*"
    setup_xfail "a29k-*-udi" 2416
    gdb_test "ptype {(long)0,(long)1,(long)2}"	  "type = long \\\[3\\\]"
    setup_xfail "h8300*-*-*"
    setup_xfail "a29k-*-udi" 2416
    gdb_test "ptype {(float)0,(float)1,(float)2}" "type = float \\\[3\\\]"
    setup_xfail "h8300*-*-*"
    setup_xfail "a29k-*-udi" 2416
    gdb_test "ptype {{0,1,2},{3,4,5}}"	"type = int \\\[2\\\]\\\[3\\\]"
    setup_xfail "h8300*-*-*"
    setup_xfail "a29k-*-udi" 2416
    gdb_test "ptype {4,5,6}\[2\]"	"type = int"
    setup_xfail "h8300*-*-*"
    setup_xfail "a29k-*-udi" 2416
    gdb_test "ptype *&{4,5,6}\[1\]"	"type = int"
  }
}
@
