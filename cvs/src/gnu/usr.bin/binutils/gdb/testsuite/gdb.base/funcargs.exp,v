head	1.3;
access;
symbols
	OPENBSD_6_0:1.3.0.50
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.46
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.48
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.40
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.44
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.42
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.38
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.36
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.34
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.32
	OPENBSD_5_0:1.3.0.30
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.28
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.26
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.22
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.24
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.20
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.18
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.16
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.14
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.12
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.10
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	GDB_6_3:1.1.1.1
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2004.05.21.20.23.39;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.49.50;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.35.01;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.16.40;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.35.01;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@# Copyright 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003,
# 2004 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Fred Fish. (fnf@@cygnus.com)

if $tracelevel {
    strace $tracelevel
}

set prms_id 0
set bug_id 0

set testfile "funcargs"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}
if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

# Create and source the file that provides information about the compiler
# used to compile the test case.
if [get_compiler_info ${binfile}] {
    return -1;
}

#
# Locate actual args; integral types.
#

proc integral_args {} {
    global gdb_prompt
    global det_file
    global gcc_compiled

    delete_breakpoints

    gdb_breakpoint call0a
    gdb_breakpoint call0b
    gdb_breakpoint call0c
    gdb_breakpoint call0d
    gdb_breakpoint call0e

    # Run; should stop at call0a and print actual arguments.
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_run_cmd
    gdb_expect {
	 -re ".* call0a \\(c=97 'a', s=1, i=2, l=3\\) .*$gdb_prompt $" {
	    pass "run to call0a"
	}
	 -re "$gdb_prompt $"  { fail "run to call0a" ; gdb_suppress_tests }
	 timeout { fail "(timeout) run to call0a" ; gdb_suppress_tests }
    }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.
    gdb_test "print c" ".* = 97 'a'" "print c after run to call0a" 
    gdb_test "print s" ".* = 1" "print s after run to call0a"
    gdb_test "print i" ".* = 2" "print i after run to call0a"
    gdb_test "print l " ".* = 3" "print l after run to call0a"

    # Continue; should stop at call0b and print actual arguments.
    if [gdb_test "cont" ".* call0b \\(s=1, i=2, l=3, c=97 'a'\\) .*" "continue to call0b"] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call0c and print actual arguments.
    if [gdb_test "cont" ".* call0c \\(i=2, l=3, c=97 'a', s=1\\) .*" "continue to call0c"] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call0d and print actual arguments.
    if [gdb_test "cont" ".* call0d \\(l=3, c=97 'a', s=1, i=2\\) .*" "continue to call0d";] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call0e and print actual arguments.
    if [gdb_test "cont" ".* call0e \\(c1=97 'a', l=3, c2=97 'a', i=2, c3=97 'a', s=1, c4=97 'a', c5=97 'a'\\) .*" "continue to call0e" ] {
	gdb_suppress_tests;
    }
    gdb_stop_suppressing_tests;
}

#
# Locate actual args; unsigned integral types.
#

proc unsigned_integral_args {} {
    global gdb_prompt
    global det_file
    global gcc_compiled

    delete_breakpoints

    gdb_breakpoint call1a;
    gdb_breakpoint call1b;
    gdb_breakpoint call1c;
    gdb_breakpoint call1d;
    gdb_breakpoint call1e;

    # Run; should stop at call1a and print actual arguments.
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_run_cmd
    gdb_expect {
	 -re ".* call1a \\(uc=98 'b', us=6, ui=7, ul=8\\) .*$gdb_prompt $" {
	    pass "run to call1a"
	}
	 -re "$gdb_prompt $" { fail "run to call1a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call1a" ; gdb_suppress_tests; }
    }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.
    gdb_test "print uc" ".* = 98 'b'"
    gdb_test "print us" ".* = 6"
    gdb_test "print ui" ".* = 7"
    gdb_test "print ul" ".* = 8"
    
    # Continue; should stop at call1b and print actual arguments.
    if [gdb_test "cont" ".* call1b \\(us=6, ui=7, ul=8, uc=98 'b'\\) .*" "continue to call1b"] {
	gdb_suppress_tests; 
    }

    # Continue; should stop at call1c and print actual arguments.
    if [gdb_test "cont" ".* call1c \\(ui=7, ul=8, uc=98 'b', us=6\\) .*" "continue to call1c"] {
	gdb_suppress_tests; 
    }

    # Continue; should stop at call1d and print actual arguments.
    if [gdb_test "cont" ".* call1d \\(ul=8, uc=98 'b', us=6, ui=7\\) .*" "continue to call1d"] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call1e and print actual arguments.
    if [gdb_test "cont" ".* call1e \\(uc1=98 'b', ul=8, uc2=98 'b', ui=7, uc3=98 'b', us=6, uc4=98 'b', uc5=98 'b'\\) .*" "continue to call1e"] {
	gdb_suppress_tests;
    }
    gdb_stop_suppressing_tests;
}

#
# Locate actual args; integrals mixed with floating point.
#

proc float_and_integral_args {} {
    global gdb_prompt
    global det_file
    global gcc_compiled

    delete_breakpoints

    gdb_breakpoint call2a
    gdb_breakpoint call2b
    gdb_breakpoint call2c
    gdb_breakpoint call2d
    gdb_breakpoint call2e
    gdb_breakpoint call2f
    gdb_breakpoint call2g
    gdb_breakpoint call2h

    # Run; should stop at call2a and print actual arguments.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" "mips-sgi-irix5*" }
    gdb_run_cmd
    gdb_expect {
	 -re ".* call2a \\(c=97 'a', f1=4, s=1, d1=5, i=2, f2=4, l=3, d2=5\\) .*$gdb_prompt $" { pass "run to call2a" }
	 -re ".* call2a \\(c=97 'a', f1=.*, s=1, d1=5, i=2, f2=4, l=3, d2=5\\) .*$gdb_prompt $" { xfail "run to call2a" }
	 -re "$gdb_prompt $" { fail "run to call2a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call2a" ; gdb_suppress_tests; }
    }

    # Print each arg as a double check to see if we can print
    gdb_test "print c" ".* = 97 'a'" "print c after run to call2a"
    gdb_test "print f1" ".* = 4" "print f1 after run to call2a"
    gdb_test "print s" ".* = 1" "print s after run to call2a"
    gdb_test "print d1" ".* = 5" "print d1 after run to call2a"
    gdb_test "print i" ".* = 2" "print i after run to call2a"
    gdb_test "print f2" ".* = 4" "print f2 after run to call2a"
    gdb_test "print l" ".* = 3" "print l after run to call2a"
    gdb_test "print d2" ".* = 5" "print d2 after run to call2a"

    setup_xfail "rs6000-*-*"
    if {!$gcc_compiled} then { setup_xfail "mips-sgi-irix*" }
    # Continue; should stop at call2b and print actual arguments.
    if [gdb_test "cont" ".* call2b \\(f1=4, s=1, d1=5, i=2, f2=4, l=3, d2=5, c=97 'a'\\) .*" "continue to call2b"] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call2c and print actual arguments.
    if [gdb_test "cont" ".* call2c \\(s=1, d1=5, i=2, f2=4, l=3, d2=5, c=97 'a', f1=4\\) .*" "continue to call2c"] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call2d and print actual arguments.
    if [gdb_test "cont" ".* call2d \\(d1=5, i=2, f2=4, l=3, d2=5, c=97 'a', f1=4, s=1\\) .*" "continue to call2d"] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call2e and print actual arguments.
    if [gdb_test "cont" ".* call2e \\(i=2, f2=4, l=3, d2=5, c=97 'a', f1=4, s=1, d1=5\\) .*" "continue to call2e"] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call2f and print actual arguments.
    if [gdb_test "cont" ".* call2f \\(f2=4, l=3, d2=5, c=97 'a', f1=4, s=1, d1=5, i=2\\) .*" "continue to call2f"] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call2g and print actual arguments.
    if [gdb_test "cont" ".* call2g \\(l=3, d2=5, c=97 'a', f1=4, s=1, d1=5, i=2, f2=4\\) .*" "continue to call2g"] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call2h and print actual arguments.
    if [gdb_test "cont" ".* call2h \\(d2=5, c=97 'a', f1=4, s=1, d1=5, i=2, f2=4, l=3\\) .*" "continue to call2h"] {
	gdb_suppress_tests;
    }

    # monitor only allows 8 breakpoints; w89k board allows 10, so
    # break them up into two groups.
    delete_breakpoints
    gdb_breakpoint call2i

    # Continue; should stop at call2i and print actual arguments.
    if [gdb_test "cont" ".* call2i \\(c1=97 'a', f1=4, c2=97 'a', c3=97 'a', d1=5, c4=97 'a', c5=97 'a', c6=97 'a', f2=4, s=1, c7=97 'a', d2=5\\) .*" "continue to call2i"] {
	gdb_suppress_tests;
    }
    gdb_stop_suppressing_tests;
}

#
# Locate actual args; dereference pointers to ints and floats.
#

proc pointer_args {} {
    global gdb_prompt
    global hex
    global det_file

    delete_breakpoints

    gdb_breakpoint call3a
    gdb_breakpoint call3b
    gdb_breakpoint call3c

    # Run; should stop at call3a and print actual arguments.
    # Try dereferencing the arguments.

    gdb_run_cmd
    gdb_expect {
	 -re ".* call3a \\(cp=$hex \"a.*\", sp=$hex, ip=$hex, lp=$hex\\) .*$gdb_prompt $" { pass "run to call3a" }
	 -re "$gdb_prompt $" { fail "run to call3a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call3a" ; gdb_suppress_tests; }
    }

    gdb_test "print *cp" ".* = 97 'a'"
    gdb_test "print *sp" ".* = 1"
    gdb_test "print *ip" ".* = 2"
    gdb_test "print *lp" ".* = 3"

    # Continue; should stop at call3b and print actual arguments.
    # Try dereferencing the arguments.
    if [gdb_test "cont" ".* call3b \\(ucp=$hex \"b.*\", usp=$hex, uip=$hex, ulp=$hex\\) .*" "continue to call3b"] {
	gdb_suppress_tests;
    }

    gdb_test "print *ucp" ".* = 98 'b'"
    gdb_test "print *usp" ".* = 6"
    gdb_test "print *uip" ".* = 7"
    gdb_test "print *ulp" ".* = 8"

    # Continue; should stop at call3c and print actual arguments.
    # Try dereferencing the arguments.
    if [gdb_test "cont" ".* call3c \\(fp=$hex, dp=$hex\\) .*" "continue to call3c"] {
	gdb_suppress_tests;
    }

    gdb_test "print *fp" ".* = 4"
    gdb_test "print *dp" ".* = 5"

#    pass "locate actual args, pointer types"
    gdb_stop_suppressing_tests;
}

#
# Locate actual args; structures and unions passed by reference.
#

proc structs_by_reference {} {
    global gdb_prompt
    global hex
    global det_file
    global target_sizeof_int
    global target_sizeof_long
    global target_bigendian_p

    delete_breakpoints

    gdb_breakpoint call4a
    gdb_breakpoint call4b

    # Run; should stop at call4a and print actual arguments.
    # Try dereferencing the arguments.

    gdb_run_cmd
    gdb_expect {
	 -re ".* call4a \\(stp=$hex\\) .*$gdb_prompt $" {
	    pass "run to call4a"
	}
	 -re "$gdb_prompt $" { fail "run to call4a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call4a" ; gdb_suppress_tests; }
    }

    gdb_test "print *stp" ".* = \{s1 = 101, s2 = 102\}"

    # Continue; should stop at call4b and print actual arguments.

    gdb_test "cont" ".* call4b \\(unp=$hex\\) .*" "continue to call4b"

    # Try dereferencing the arguments.
    if { $target_sizeof_long == $target_sizeof_int } {
	gdb_test "print *unp" ".* = \{u1 = 1, u2 = 1\}" \
		"print *unp (sizeof long == sizeof int)"
    } elseif { ! $target_bigendian_p } {
	gdb_test "print *unp" ".* = \{u1 = 1, u2 = 1\}" \
		"print *unp (little-endian, sizeof long != sizeof int)"
    } elseif { $target_sizeof_long == 8 && $target_sizeof_int == 4 } {
	gdb_test "print *unp" ".* = \{u1 = 1, u2 = 4294967296\}" \
		"print *unp (big-endian, sizeof long == 8, sizeof int = 4)"
    } elseif { $target_sizeof_long == 4 && $target_sizeof_int == 2 } {
	gdb_test "print *unp" ".* = \{u1 = 1, u2 = 65536\}" \
		"print *unp (big-endian, sizeof long == 4, sizeof int = 2)"
    } else {
	fail "print *unp (unknown case)"
    }

    pass "locate actual args, structs/unions passed by reference"
    gdb_stop_suppressing_tests;
}

#
# Locate actual args; structures and unions passed by value.
#

proc structs_by_value {} {
    global gdb_prompt
    global hex
    global det_file
    global target_sizeof_int
    global target_sizeof_long
    global target_bigendian_p

    delete_breakpoints

    gdb_breakpoint call5a
    gdb_breakpoint call5b

    # Run; should stop at call5a and print actual arguments.
    # Try dereferencing the arguments.

    gdb_run_cmd
    gdb_expect {
	 -re ".* call5a \\(st=\{s1 = 101, s2 = 102\}\\) .*$gdb_prompt $" {
	    pass "run to call5a"
	}
	 -re "$gdb_prompt $" { fail "run to call5a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call5a" ; gdb_suppress_tests; }
    }

    gdb_test "print st" ".* = \{s1 = 101, s2 = 102\}"

    # Continue; should stop at call5b and print actual arguments.
    if { $target_sizeof_long == $target_sizeof_int } {
	gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 2\}\\) .*" \
		"continue to call5b (sizeof long == sizeof int)"
    } elseif { ! $target_bigendian_p } {
	gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 2\}\\) .*" \
		"continue to call5b (little-endian, sizeof long != sizeof int)"
    } elseif { $target_sizeof_long == 8 && $target_sizeof_int == 4 } {
	gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 8589934592\}\\) .*" \
		"continue to call5b (big-endian, sizeof long == 8, sizeof int = 4)"
    } elseif { $target_sizeof_long == 4 && $target_sizeof_int == 2 } {
	gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 131072\}\\) .*" \
		"continue to call5b (big-endian, sizeof long == 4, sizeof int = 2)"
    } else {
	fail "continue to call5b (unknown case)"
    }

    # Try dereferencing the arguments.
    if { $target_sizeof_long == $target_sizeof_int } {
	gdb_test "print un" ".* = \{u1 = 2, u2 = 2\}" \
		"print un (sizeof long == sizeof int)"
    } elseif { ! $target_bigendian_p } {
	gdb_test "print un" ".* = \{u1 = 2, u2 = 2\}" \
		"print un (little-endian, sizeof long != sizeof int)"
    } elseif { $target_sizeof_long == 8 && $target_sizeof_int == 4 } {
	gdb_test "print un" ".* = \{u1 = 2, u2 = 8589934592\}" \
		"print un (big-endian, sizeof long == 8, sizeof int = 4)"
    } elseif { $target_sizeof_long == 4 && $target_sizeof_int == 2 } {
	gdb_test "print un" ".* = \{u1 = 2, u2 = 131072\}" \
		"print un (big-endian, sizeof long == 4, sizeof int = 2)"
    } else {
	fail "print un (unknown case)"
    }

    gdb_stop_suppressing_tests;
}

#
# Locate actual args; discard, shuffle, and call
#

proc discard_and_shuffle {} {
    global gdb_prompt
    global hex
    global decimal
    global det_file
    global gcc_compiled

    delete_breakpoints

    gdb_breakpoint call6a
    gdb_breakpoint call6b
    gdb_breakpoint call6c
    gdb_breakpoint call6d
    gdb_breakpoint call6e
    gdb_breakpoint call6f
    gdb_breakpoint call6g
    gdb_breakpoint call6h

    # Run; should stop at call6a and print actual arguments.
    # Print backtrace.

    gdb_run_cmd
    gdb_expect {
	 -re ".*Breakpoint $decimal, call6a .*$gdb_prompt $" { pass "run to call6a" }
	 -re "$gdb_prompt $" { fail "run to call6a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call6a" ; gdb_suppress_tests; }
    }

    setup_xfail "rs6000-*-*"

    if {!$gcc_compiled} {
	setup_xfail "mips-sgi-irix5*"
    }

    send_gdb "backtrace 100\n"
    gdb_expect {
	-re "backtrace 100\[\r\n\]+
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$gdb_prompt $" {
	    pass "backtrace from call6a"
	}
	-re "backtrace 100\[\r\n\]+
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=.*, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$gdb_prompt $" {
	    xfail "backtrace from call6a"
	}
	-re "$gdb_prompt $" {
	    fail "backtrace from call6a"
	    gdb_suppress_tests
	}
	timeout {
	    fail "(timeout) backtrace from call6a"
	    gdb_suppress_tests
	}
    }

    # Continue; should stop at call6b and print actual arguments.
    # Print backtrace.

    gdb_continue call6b

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6b" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* main \\(.*\\) " 
    } ] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call6c and print actual arguments.
    # Print backtrace.

    gdb_continue call6c

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6c" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
    }
    # Continue; should stop at call6d and print actual arguments.
    # Print backtrace.

    gdb_continue call6d

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6d" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call6e and print actual arguments.
    # Print backtrace.

    gdb_continue call6e

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6e" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call6f and print actual arguments.
    # Print backtrace.

    gdb_continue call6f

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6f" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#6 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call6g and print actual arguments.
    # Print backtrace.

    gdb_continue call6g

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6g" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#6 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#7 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call6h and print actual arguments.
    # Print backtrace.

    gdb_continue call6h

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6h" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6h \\(us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#6 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#7 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#8 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
    }

    # monitor only allows 8 breakpoints; w89k board allows 10, so
    # break them up into two groups.
    delete_breakpoints
    gdb_breakpoint call6i
    gdb_breakpoint call6j
    gdb_breakpoint call6k

    # Continue; should stop at call6i and print actual arguments.
    # Print backtrace.

    gdb_continue call6i

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6i" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6i \\(ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6h \\(us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#6 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#7 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#8 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#9 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call6j and print actual arguments.
    # Print backtrace.

    gdb_continue call6j

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6j" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6j \\(ul=8\\) "
	".*\[\r\n\]#1 .* call6i \\(ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6h \\(us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#6 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#7 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#8 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#9 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#10 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call6k and print actual arguments.
    # Print backtrace.
    gdb_continue call6k

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6k" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6k \\(\\) "
	".*\[\r\n\]#1 .* call6j \\(ul=8\\) "
	".*\[\r\n\]#2 .* call6i \\(ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6h \\(us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#6 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#7 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#8 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#9 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#10 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#11 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
    }
    gdb_stop_suppressing_tests;
}


#
# Locate actual args; shuffle round robin and call
#

proc shuffle_round_robin {} {
    global gdb_prompt
    global hex
    global decimal
    global det_file
    global gcc_compiled

    delete_breakpoints

    gdb_breakpoint call7a
    gdb_breakpoint call7b
    gdb_breakpoint call7c
    gdb_breakpoint call7d
    gdb_breakpoint call7e
    gdb_breakpoint call7f
    gdb_breakpoint call7g
    gdb_breakpoint call7h

    # Run; should stop at call7a and print actual arguments.
    # Print backtrace.

    gdb_run_cmd
    gdb_expect {
	 -re ".*Breakpoint $decimal, call7a .*$gdb_prompt $" {
	    pass "run to call7a"
	}
	 -re "$gdb_prompt $" { fail "run to call7a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call7a" ; gdb_suppress_tests; }
    }

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" "mips-sgi-irix5*" }
    send_gdb "backtrace 100\n"
    gdb_expect {
	-re "backtrace 100\[\r\n\]+
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$gdb_prompt $" {
	    pass "backtrace from call7a"
	}
	-re "backtrace 100\[\r\n\]+
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=.*, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$gdb_prompt $" {
	    xfail "backtrace from call7a"
	}
	-re "$gdb_prompt $" { fail "backtrace from call7a" ; return }
	timeout { fail "(timeout) backtrace from call7a" ; return }
    }

    # Continue; should stop at call7b and print actual arguments.
    # Print backtrace.

    gdb_continue call7b

    if {$gcc_compiled} then { setup_xfail "rs6000-*-*" }

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7b" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#1 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#2 .* main \\(.*\\) "
    }

    # Continue; should stop at call7c and print actual arguments.
    # Print backtrace.

    gdb_continue call7c

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7c" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#1 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#2 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#3 .* main \\(.*\\) "
    }

    # Continue; should stop at call7d and print actual arguments.
    # Print backtrace.

    gdb_continue call7d

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7d" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#1 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#2 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#3 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#4 .* main \\(.*\\) "
    }

    gdb_continue call7e

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7e" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#1 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#2 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#3 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#4 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#5 .* main \\(.*\\) "
    }

    # Continue; should stop at call7f and print actual arguments.
    # Print backtrace.

    gdb_continue call7f

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7f" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	".*\[\r\n\]#1 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#2 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#3 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#4 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#5 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#6 .* main \\(.*\\) "
    }

    # Continue; should stop at call7g and print actual arguments.
    # Print backtrace.

    gdb_continue call7g

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7g" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	".*\[\r\n\]#1 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	".*\[\r\n\]#2 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#3 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#4 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#5 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#6 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#7 .* main \\(.*\\) "
    }

    gdb_continue call7h

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7h" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) "
	".*\[\r\n\]#1 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	".*\[\r\n\]#2 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	".*\[\r\n\]#3 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#4 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#5 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#6 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#7 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#8 .* main \\(.*\\) "
    }

    # monitor only allows 8 breakpoints; w89k board allows 10, so
    # break them up into two groups.
    delete_breakpoints
    gdb_breakpoint call7i
    gdb_breakpoint call7j
    gdb_breakpoint call7k

    # Continue; should stop at call7i and print actual arguments.
    # Print backtrace.

    gdb_continue call7i

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7i" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) "
	".*\[\r\n\]#1 .* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) "
	".*\[\r\n\]#2 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	".*\[\r\n\]#3 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	".*\[\r\n\]#4 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#5 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#6 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#7 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#8 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#9 .* main \\(.*\\) "
    }

    # Continue; should stop at call7j and print actual arguments.
    # Print backtrace.

    gdb_continue call7j

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7j" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7j \\(ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8\\) "
	".*\[\r\n\]#1 .* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) "
	".*\[\r\n\]#2 .* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) "
	".*\[\r\n\]#3 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	".*\[\r\n\]#4 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	".*\[\r\n\]#5 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#6 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#7 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#8 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#9 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#10 .* main \\(.*\\) "
    }

    # Continue; should stop at call7k and print actual arguments.
    # Print backtrace.

    gdb_continue call7k

    if {!$gcc_compiled} then { setup_xfail "mips-sgi-irix*" }
    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7k" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7k \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#1 .* call7j \\(ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8\\) "
	".*\[\r\n\]#2 .* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) "
	".*\[\r\n\]#3 .* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) "
	".*\[\r\n\]#4 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	".*\[\r\n\]#5 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	".*\[\r\n\]#6 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#7 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#8 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#9 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#10 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#11 .* main \\(.*\\) "
    }
    gdb_stop_suppressing_tests;
}

#
# Locate actual args; recursive passing of structs by value
#

proc recursive_structs_by_value {} {
    global gdb_prompt
    global hex
    global decimal
    global det_file

    delete_breakpoints

    gdb_breakpoint hitbottom

    # Run; should stop at hitbottom and print actual arguments.
    # Print backtrace.
    gdb_run_cmd
    gdb_expect {
	 -re ".*Breakpoint $decimal, hitbottom .*$gdb_prompt $" { pass "run to hitbottom" }
	 -re "$gdb_prompt $" { fail "run to hitbottom" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to hitbottom" ; gdb_suppress_tests; }
    }

    if ![istarget sparclet-*-*] {
	send_gdb "backtrace 100\n"
	gdb_expect_list "recursive passing of structs by value" ".*$gdb_prompt $" {
	    ".*\[\r\n\]#0 .* hitbottom \\(\\) "
	    ".*\[\r\n\]#1 .* recurse \\(a=\{s = 0, i = 0, l = 0\}, depth=0\\) "
	    ".*\[\r\n\]#2 .* recurse \\(a=\{s = 1, i = 1, l = 1\}, depth=1\\) "
	    ".*\[\r\n\]#3 .* recurse \\(a=\{s = 2, i = 2, l = 2\}, depth=2\\) "
	    ".*\[\r\n\]#4 .* recurse \\(a=\{s = 3, i = 3, l = 3\}, depth=3\\) "
	    ".*\[\r\n\]#5 .* recurse \\(a=\{s = 4, i = 4, l = 4\}, depth=4\\) "
	    ".*\[\r\n\]#6 .* test_struct_args \\(\\) "
	    ".*\[\r\n\]#7 .* main \\(.*\\) "
	}
    } else {
	fail "recursive passing of structs by value (sparclet)"
    }
    gdb_stop_suppressing_tests;
}

proc funcargs_reload { } {
    global objdir
    global subdir
    global binfile
    global srcdir

    if [istarget "mips-idt-*"] {
	# Restart because IDT/SIM runs out of file descriptors.
	gdb_exit
	gdb_start
	gdb_reinitialize_dir $srcdir/$subdir
	gdb_load ${binfile}
    }
}

#
# Test for accessing local stack variables in functions which call alloca
#
proc localvars_after_alloca { } {
    global gdb_prompt
    global hex
    global decimal
    global gcc_compiled

    if { ! [ runto localvars_after_alloca ] } then { gdb_suppress_tests; }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print c" " = 97 'a'" "print c after runto localvars_after_alloca"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print s" " = 1" "print s after runto localvars_after_alloca"
    gdb_test "print i" " = 2" "print i after runto localvars_after_alloca"
    gdb_test "print l" " = 3" "print l after runto localvars_after_alloca"

    # Lame regexp.
    gdb_test "next" ".*" "next in localvars_after_alloca()"

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    gdb_test "print c" " = 97 'a'" "print c in localvars_after_alloca"
    gdb_test "print s" " = 1" "print s in localvars_after_alloca"
    gdb_test "print i" " = 2" "print i in localvars_after_alloca"
    gdb_test "print l" " = 3" "print l in localvars_after_alloca"

    gdb_test "backtrace 8" "#0.*localvars_after_alloca \\(c=97 'a', s=1, i=2, l=3\\).*#1.*main.*" "backtrace after alloca"
    gdb_stop_suppressing_tests;
}

proc call_after_alloca { } {
    global gdb_prompt
    global hex
    global decimal
    global gcc_compiled

    if { ! [ runto call_after_alloca_subr ] } then { gdb_suppress_tests; }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print c" " = 97 'a'" "print c in call_after_alloca"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print s" " = 1" "print s in call_after_alloca"
    gdb_test "print i" " = 2" "print i in call_after_alloca"
    gdb_test "print l" " = 3" "print l in call_after_alloca"

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "backtrace 8" "#0.*call_after_alloca_subr \\(c=97 'a', s=1, i=2, l=3, uc=98 'b', us=11, ui=12, ul=13\\).*#1.*call_after_alloca \\(c=97 'a', s=1, i=2, l=3\\).*#2.*main.*" "backtrace from call_after_alloca_subr"
    gdb_stop_suppressing_tests;
}

#
# Test for accessing local stack variables, backtraces, finish,
# and finally stepping into indirect calls.  The point is that on the PA
# these use a funky `dyncall' mechanism which GDB needs to know about.
#
proc localvars_in_indirect_call { } {
    global gdb_prompt
    global hex
    global decimal
    global gcc_compiled

    # Can not use "runto call0a" as call0a is called several times
    # during single run.  Instead stop in a marker function and
    # take control from there.
    if { ! [ runto marker_indirect_call ] } then { gdb_suppress_tests; }

    # break on the next call to call0a, then delete all the breakpoints
    # and start testing.
    gdb_breakpoint call0a
    gdb_continue call0a
    delete_breakpoints
    
    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print c" " = 97 'a'" "print c in localvars_in_indirect_call"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print s" " = 1" "print s in localvars_in_indirect_call"
    gdb_test "print i" " = 2" "print i in localvars_in_indirect_call"
    gdb_test "print l" " = 3" "print l in localvars_in_indirect_call"

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "backtrace 8" \
	"#0.*call0a \\(c=97 'a', s=1, i=2, l=3\\).*#1.*main.*" \
	"backtrace in indirectly called function"

    # 
    # "finish" brings us back to main.  We then will try to step through
    # the second indirect call.  
    # On some targets (e.g. m68k) gdb will stop from the finish in midline
    # of the first indirect call. This is due to stack adjustment instructions
    # after the indirect call. In these cases we will step till we hit the
    # second indirect call.
    #

    send_gdb "finish\n"
    gdb_expect {
	 -re "\\(\\*pointer_to_call0a\\) \\(c, s, i, l\\);.*First.*$gdb_prompt $" {
#On hppa2.0w-hp-hpux11.00, gdb finishes at one line earlier than 
#hppa1.1-hp-hpux11.00. Therefore, an extra "step" is necessary to continue the test.
	    send_gdb "step\n"
	    exp_continue
	}
	 -re ".*\\(\\*pointer_to_call0a\\) \\(c, s, i, l\\);.*Second.*$gdb_prompt $" {
	    pass "finish from indirectly called function"
	}
	 -re ".*$gdb_prompt $" {
	    fail "finish from indirectly called function"
	    gdb_suppress_tests;
	}
	 default { fail "finish from indirectly called function" ; gdb_suppress_tests; }
    }

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "step" "call0a \\(c=97 'a', s=1, i=2, l=3\\).*" \
	"stepping into indirectly called function"
    gdb_stop_suppressing_tests;
}

#
# Test for stepping into indirect calls which may have trampolines (possibly
# cascaded) on both the call path and the gdb_suppress_tests; path.
# to handle trampolines.
#
proc test_stepping_over_trampolines { } {
    global gdb_prompt
    global hex
    global decimal

    # Stop in a marker function and take control from there.
    if { ! [ runto marker_call_with_trampolines ] } then { gdb_suppress_tests; }

    # Cater for gdb stopping in midline, see comment for finish above.
    send_gdb "finish\n"
    gdb_expect {
	 -re "marker_call_with_trampolines ..;.*$gdb_prompt $" {
	    send_gdb "step\n"
	    exp_continue
	}
	 -re "pointer_to_call_with_trampolines.*$gdb_prompt $" {
	    pass "finish from marker_call_with_trampolines"
	}
	 -re ".*$gdb_prompt $" {
	    fail "finish from marker_call_with_trampolines"
	}
	 default { fail "finish from marker_call_with_trampolines" ; gdb_suppress_tests; }
    }

    # Try to step into the target function.
    gdb_test "step" "call_with_trampolines \\(d1=5\\).*" \
	"stepping into function called with trampolines"

    # Make we can backtrace and the argument looks correct.  */
    gdb_test "backtrace 8" "#0.*call_with_trampolines \\(d1=5\\).*1.*main.*" \
	"backtrace through call with trampolines"

    # Make sure we can get back to main.
    # Stepping back to main might stop again after the gdb_suppress_tests; statement
    # or immediately transfer control back to main if optimizations
    # are performed.
    send_gdb "step\n"
    gdb_expect {
	 -re "main .* at.*$gdb_prompt $" {
	     pass "stepping back to main from function called with trampolines" ;
	     gdb_suppress_tests
	}
	 -re "\}.*End of call_with_trampolines.*$gdb_prompt $" {
	    send_gdb "step\n"
	    exp_continue
	}
	 -re ".*$gdb_prompt $" {
	    fail "stepping back to main from function called with trampolines"
	}
	 default { fail "stepping back to main from function called with trampolines" ; gdb_suppress_tests; }
    }
    gdb_stop_suppressing_tests;
}

# Start with a fresh gdb.

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

if [istarget "mips*tx39-*"] {
    set timeout 300
} else {
    set timeout 60
}

# Determine expected output for unsigned long variables,
# the output varies with sizeof (unsigned long).

set target_sizeof_long 4
send_gdb "print sizeof (long)\n"
gdb_expect {
    -re ".\[0-9\]* = 4.*$gdb_prompt $" { }
    -re ".\[0-9\]* = 8.*$gdb_prompt $" { set target_sizeof_long 8 } 
    -re ".*$gdb_prompt $" {
	 fail "getting sizeof long"
    }
    default	{ fail "(timeout) getting sizeof long" }
}

set target_sizeof_int 4
send_gdb "print sizeof (int)\n"
gdb_expect {
    -re ".\[0-9\]* = 2.*$gdb_prompt $" { set target_sizeof_int 2 }
    -re ".\[0-9\]* = 4.*$gdb_prompt $" { }
    -re ".\[0-9\]* = 8.*$gdb_prompt $" { set target_sizeof_int 8 } 
    -re ".*$gdb_prompt $" {
	 fail "getting sizeof unsigned long"
    }
    default	{ fail "(timeout) getting sizeof int" }
}

set target_bigendian_p 1
send_gdb "show endian\n"
gdb_expect {
    -re ".*little endian.*$gdb_prompt $" { set target_bigendian_p 0 }
    -re ".*big endian.*$gdb_prompt $" { }
    -re ".*$gdb_prompt $" {
	 fail "getting target endian"
    }
    default	{ fail "(timeout) getting target endian" }
}

# Perform tests

integral_args
funcargs_reload
unsigned_integral_args
funcargs_reload
if {![target_info exists gdb,skip_float_tests]} {
  float_and_integral_args
}
funcargs_reload
pointer_args
funcargs_reload
structs_by_reference
funcargs_reload
structs_by_value
funcargs_reload
discard_and_shuffle
funcargs_reload
shuffle_round_robin
funcargs_reload
recursive_structs_by_value
funcargs_reload
localvars_after_alloca
funcargs_reload
call_after_alloca
funcargs_reload
localvars_in_indirect_call
funcargs_reload
test_stepping_over_trampolines
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d1 2
a2 1
# Copyright (C) 1992, 1994, 1995 Free Software Foundation, Inc.
d16 1
a16 1
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d23 2
a24 2
if $tracelevel then {
	strace $tracelevel
d33 2
a34 3
if  { [compile "${srcdir}/${subdir}/${srcfile} -g -o ${binfile}"] != "" } {
    perror "Couldn't compile ${srcfile}"
    return -1
d39 2
a40 4
execute_anywhere "rm -f ${binfile}.ci"
if  { [compile "-E ${srcdir}/${subdir}/compiler.c > ${binfile}.ci"] != "" } {
    perror "Couldn't make ${binfile}.ci file"
    return -1
a41 1
source ${binfile}.ci
d48 1
a48 1
    global prompt
d54 5
a58 5
    send "break call0a\n" ; expect -re ".*$prompt $"
    send "break call0b\n" ; expect -re ".*$prompt $"
    send "break call0c\n" ; expect -re ".*$prompt $"
    send "break call0d\n" ; expect -re ".*$prompt $"
    send "break call0e\n" ; expect -re ".*$prompt $"
a60 3
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
d63 2
a64 2
    expect {
	-re ".* call0a \\(c=97 'a', s=1, i=2, l=3\\) .*$prompt $" {
d67 2
a68 2
	-re "$prompt $"  { fail "run to call0a" ; return }
	timeout { fail "(timeout) run to call0a" ; return }
d80 1
a80 1
	return 
d85 1
a85 1
	return
d90 1
a90 1
	return
d95 1
a95 1
	return
d97 1
d105 1
a105 1
    global prompt
d111 5
a115 5
    send "break call1a\n" ; expect -re ".*$prompt $"
    send "break call1b\n" ; expect -re ".*$prompt $"
    send "break call1c\n" ; expect -re ".*$prompt $"
    send "break call1d\n" ; expect -re ".*$prompt $"
    send "break call1e\n" ; expect -re ".*$prompt $"
a117 3
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
d120 2
a121 2
    expect {
	-re ".* call1a \\(uc=98 'b', us=6, ui=7, ul=8\\) .*$prompt $" {
d124 2
a125 2
	-re "$prompt $" { fail "run to call1a" ; return }
	timeout { fail "(timeout) run to call1a" ; return }
d137 1
a137 1
	return 
d142 1
a142 1
	return 
d147 1
a147 1
	return
d152 1
a152 1
	return
d154 1
d162 1
a162 1
    global prompt
d168 8
a175 8
    send "break call2a\n" ; expect -re ".*$prompt $"
    send "break call2b\n" ; expect -re ".*$prompt $"
    send "break call2c\n" ; expect -re ".*$prompt $"
    send "break call2d\n" ; expect -re ".*$prompt $"
    send "break call2e\n" ; expect -re ".*$prompt $"
    send "break call2f\n" ; expect -re ".*$prompt $"
    send "break call2g\n" ; expect -re ".*$prompt $"
    send "break call2h\n" ; expect -re ".*$prompt $"
a178 4
    setup_xfail "i960-*-*" 1813
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
d181 5
a185 4
    expect {
	-re ".* call2a \\(c=97 'a', f1=4, s=1, d1=5, i=2, f2=4, l=3, d2=5\\) .*$prompt $" { pass "run to call2a" }
	-re "$prompt $" { fail "run to call2a" ; return }
	timeout { fail "(timeout) run to call2a" ; return }
d202 1
a202 1
	return
d207 1
a207 1
	return
d212 1
a212 1
	return
d217 1
a217 1
	return
d222 1
a222 1
	return
d227 1
a227 1
	return
d232 1
a232 1
	return
d238 1
a238 1
    send "break call2i\n" ; expect -re ".*$prompt $"
d242 1
a242 1
	return
d244 1
d252 1
a252 1
    global prompt
d258 3
a260 3
    send "break call3a\n" ; expect -re ".*$prompt $"
    send "break call3b\n" ; expect -re ".*$prompt $"
    send "break call3c\n" ; expect -re ".*$prompt $"
a264 3
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
d266 4
a269 4
    expect {
	-re ".* call3a \\(cp=$hex \"a\", sp=$hex, ip=$hex, lp=$hex\\) .*$prompt $" { pass "run to call3a" }
	-re "$prompt $" { fail "run to call3a" ; return }
	timeout { fail "(timeout) run to call3a" ; return }
d279 2
a280 2
    if [gdb_test "cont" ".* call3b \\(ucp=$hex \"b\", usp=$hex, uip=$hex, ulp=$hex\\) .*" "continue to call3b"] {
	return
d291 1
a291 1
	return
d297 2
a298 1
    pass "locate actual args, pointer types"
d306 1
a306 1
    global prompt
d309 3
d315 2
a316 2
    send "break call4a\n" ; expect -re ".*$prompt $"
    send "break call4b\n" ; expect -re ".*$prompt $"
a320 3
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
d322 2
a323 2
    expect {
	-re ".* call4a \\(stp=$hex\\) .*$prompt $" {
d326 2
a327 2
	-re "$prompt $" { fail "run to call4a" ; return }
	timeout { fail "(timeout) run to call4a" ; return }
a332 1
    # Try dereferencing the arguments.
d336 16
a351 3
    # sizeof int != sizeof long on h8300
    setup_xfail "h8300*-*-*"
    gdb_test "print *unp" ".* = \{u1 = 1, u2 = 1\}"
d354 1
d362 1
a362 1
    global prompt
d365 3
d371 2
a372 2
    send "break call5a\n" ; expect -re ".*$prompt $"
    send "break call5b\n" ; expect -re ".*$prompt $"
a376 3
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
d378 2
a379 2
    expect {
	-re ".* call5a \\(st=\{s1 = 101, s2 = 102\}\\) .*$prompt $" {
d382 2
a383 2
	-re "$prompt $" { fail "run to call5a" ; return }
	timeout { fail "(timeout) run to call5a" ; return }
d389 16
d406 17
a422 8
    # sizeof int != sizeof long on h8300
    setup_xfail "h8300*-*-*"
    gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 2\}\\) .*" \
	"continue to call5b"

    # sizeof int != sizeof long on h8300
    setup_xfail "h8300*-*-*"
    gdb_test "print un" ".* = \{u1 = 2, u2 = 2\}"
d430 1
a430 1
    global prompt
d438 8
a445 8
    send "break call6a\n" ; expect -re ".*$prompt $"
    send "break call6b\n" ; expect -re ".*$prompt $"
    send "break call6c\n" ; expect -re ".*$prompt $"
    send "break call6d\n" ; expect -re ".*$prompt $"
    send "break call6e\n" ; expect -re ".*$prompt $"
    send "break call6f\n" ; expect -re ".*$prompt $"
    send "break call6g\n" ; expect -re ".*$prompt $"
    send "break call6h\n" ; expect -re ".*$prompt $"
a449 3
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
d451 4
a454 4
    expect {
	-re ".*Breakpoint $decimal, call6a .*$prompt $" { pass "run to call6a" }
	-re "$prompt $" { fail "run to call6a" ; return }
	timeout { fail "(timeout) run to call6a" ; return }
d458 7
a464 3
    if {!$gcc_compiled} then { setup_xfail "mips-sgi-irix5*" }
    send "backtrace 100\n"
    expect {
d468 17
a484 3
$prompt $" { pass "backtrace from call6a" }
	-re "$prompt $" { fail "backtrace from call6a" ; return }
	timeout { fail "(timeout) backtrace from call6a" ; return }
d490 1
a490 6
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6b .*$prompt $" { pass "continue to call6b" }
	-re "$prompt $" { fail "continue to call6b" ; return }
	timeout { fail "(timeout) continue to call6b" ; return }
    }
d492 7
a498 9
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n]+
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6b" }
	-re "$prompt $" { fail "backtrace from call6b" ; return }
	timeout { fail "(timeout) backtrace from call6b" ; return }
d504 1
a504 6
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6c .*$prompt $" { pass "continue to call6c" }
	-re "$prompt $" { fail "continue to call6c" ; return }
	timeout { fail "(timeout) continue to call6c" ; return }
    }
d506 8
a513 10
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6c" }
	-re "$prompt $" { fail "backtrace from call6c" ; return }
	timeout { fail "(timeout) backtrace from call6c" ; return }
a514 1

d518 1
a518 6
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6d .*$prompt $" { pass "continue to call6d" }
	-re "$prompt $" { fail "continue to call6d" ; return }
	timeout { fail "(timeout) continue to call6d" ; return }
    }
d520 9
a528 11
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6d" }
	-re "$prompt $" { fail "backtrace from call6d" ; return }
	timeout { fail "(timeout) backtrace from call6d" ; return }
d534 1
a534 6
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6e .*$prompt $" { pass "continue to call6e" }
	-re "$prompt $" { fail "continue to call6e" ; return }
	timeout { fail "(timeout) continue to call6e" ; return }
    }
d536 10
a545 12
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6e" }
	-re "$prompt $" { fail "backtrace from call6e" ; return }
	timeout { fail "(timeout) backtrace from call6e" ; return }
d551 1
a551 6
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6f .*$prompt $" { pass "continue to call6f" }
	-re "$prompt $" { fail "continue to call6f" ; return }
	timeout { fail "(timeout) continue to call6f" ; return }
    }
d553 11
a563 13
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6f" }
	-re "$prompt $" { fail "backtrace from call6f" ; return }
	timeout { fail "(timeout) backtrace from call6f" ; return }
d569 1
a569 6
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6g .*$prompt $" { pass "continue to call6g" }
	-re "$prompt $" { fail "continue to call6g" ; return }
	timeout { fail "(timeout) continue to call6g" ; return }
    }
d571 12
a582 14
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6g" }
	-re "$prompt $" { fail "backtrace from call6g" ; return }
	timeout { fail "(timeout) backtrace from call6g" ; return }
d588 1
a588 6
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6h .*$prompt $" { pass "continue to call6h" }
	-re "$prompt $" { fail "continue to call6h" ; return }
	timeout { fail "(timeout) continue to call6h" ; return }
    }
d590 13
a602 15
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6h \\(us=6, ui=7, ul=8\\) .*\r
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6h" }
	-re "$prompt $" { fail "backtrace from call6h" ; return }
	timeout { fail "(timeout) backtrace from call6h" ; return }
d608 3
a610 3
    send "break call6i\n" ; expect -re ".*$prompt $"
    send "break call6j\n" ; expect -re ".*$prompt $"
    send "break call6k\n" ; expect -re ".*$prompt $"
d615 1
a615 6
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6i .*$prompt $" { pass "continue to call6i" }
	-re "$prompt $" { fail "continue to call6i" ; return }
	timeout { fail "(timeout) continue to call6i" ; return }
    }
d617 14
a630 16
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6i \\(ui=7, ul=8\\) .*\r
.* call6h \\(us=6, ui=7, ul=8\\) .*\r
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6i" }
	-re "$prompt $" { fail "backtrace from call6i" ; return }
	timeout { fail "(timeout) backtrace from call6i" ; return }
d636 1
a636 6
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6j .*$prompt $" { pass "continue to call6j" }
	-re "$prompt $" { fail "continue to call6j" ; return }
	timeout { fail "(timeout) continue to call6j" ; return }
    }
d638 15
a652 17
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6j \\(ul=8\\) .*\r
.* call6i \\(ui=7, ul=8\\) .*\r
.* call6h \\(us=6, ui=7, ul=8\\) .*\r
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6j" }
	-re "$prompt $" { fail "backtrace from call6j" ; return }
	timeout { fail "(timeout) backtrace from call6j" ; return }
d657 1
a657 11
    # This fails on i960-*-vxworks because gdb gets confused by
    # breakpoints on adjacent instructions.
    setup_xfail "i960-*-vxworks" 1786
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6k .*$prompt $" {
	    pass "continue to call6k"
	}
	-re "$prompt $" { fail "continue to call6k"; return }
	timeout { fail "(timeout) continue to call6k"; return }
    }
d659 16
a674 18
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6k \\(\\) .*\r
.* call6j \\(ul=8\\) .*\r
.* call6i \\(ui=7, ul=8\\) .*\r
.* call6h \\(us=6, ui=7, ul=8\\) .*\r
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6k" }
	-re "$prompt $" { fail "backtrace from call6k" ; return }
	timeout { fail "(timeout) backtrace from call6k" ; return }
d676 1
d679 1
d685 1
a685 1
    global prompt
d693 8
a700 8
    send "break call7a\n" ; expect -re ".*$prompt $"
    send "break call7b\n" ; expect -re ".*$prompt $"
    send "break call7c\n" ; expect -re ".*$prompt $"
    send "break call7d\n" ; expect -re ".*$prompt $"
    send "break call7e\n" ; expect -re ".*$prompt $"
    send "break call7f\n" ; expect -re ".*$prompt $"
    send "break call7g\n" ; expect -re ".*$prompt $"
    send "break call7h\n" ; expect -re ".*$prompt $"
a704 3
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
d706 2
a707 2
    expect {
	-re ".*Breakpoint $decimal, call7a .*$prompt $" {
d710 2
a711 2
	-re "$prompt $" { fail "run to call7a" ; return }
	timeout { fail "(timeout) run to call7a" ; return }
a713 1
    setup_xfail "i960-*-*" 1813
d715 2
a716 2
    send "backtrace 100\n"
    expect {
d720 10
a729 2
$prompt $" { pass "backtrace from call7a" }
	-re "$prompt $" { fail "backtrace from call7a" ; return }
d736 1
a736 6
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7b .*$prompt $" { pass "continue to call7b" }
	-re "$prompt $" { fail "continue to call7b" ; return }
	timeout { fail "(timeout) continue to call7b" ; return }
    }
d739 6
a744 9
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7b" }
	-re "$prompt $" { fail "backtrace from call7b" ; return }
	timeout { fail "(timeout) backtrace from call7b" ; return }
d750 1
a750 6
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7c .*$prompt $" { pass "continue to call7c" }
	-re "$prompt $" { fail "continue to call7c" ; return }
	timeout { fail "(timeout) continue to call7c" ; return }
    }
d752 6
a757 10
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7c" }
	-re "$prompt $" { fail "backtrace from call7c" ; return }
	timeout { fail "(timeout) backtrace from call7c" ; return }
d763 1
a763 6
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7d .*$prompt $" { pass "continue to call7d" }
	-re "$prompt $" { fail "continue to call7d" ; return }
	timeout { fail "(timeout) continue to call7d" ; return }
    }
d765 19
a783 35
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7d" }
	-re "$prompt $" { fail "backtrace from call7d" ; return }
	timeout { fail "(timeout) backtrace from call7d" ; return }
    }

    # Continue; should stop at call7e and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re "Breakpoint $decimal, call7e .*$prompt $" { pass "continue to call7e" }
	-re "$prompt $" { fail "continue to call7e" ; return }
	timeout { fail "(timeout) continue to call7e" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7e" }
	-re "$prompt $" { fail "backtrace from call7e" ; return }
	timeout { fail "(timeout) backtrace from call7e" ; return }
d789 1
a789 6
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7f .*$prompt $" { pass "continue to call7f" }
	-re "$prompt $" { fail "continue to call7f" ; return }
	timeout { fail "(timeout) continue to call7f" ; return }
    }
d791 9
a799 13
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7f" }
	-re "$prompt $" { fail "backtrace from call7f" ; return }
	timeout { fail "(timeout) backtrace from call7f" ; return }
d805 1
a805 6
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7g .*$prompt $" { pass "continue to call7g" }
	-re "$prompt $" { fail "continue to call7g" ; return }
	timeout { fail "(timeout) continue to call7g" ; return }
    }
d807 25
a831 41
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7g" }
	-re "$prompt $" { fail "backtrace from call7g" ; return }
	timeout { fail "(timeout) backtrace from call7g" ; return }
    }

    # Continue; should stop at call7h and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7h .*$prompt $" { pass "continue to call7h" }
	-re "$prompt $" { fail "continue to call7h" ; return }
	timeout { fail "(timeout) continue to call7h" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) .*\r
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7h" }
	-re "$prompt $" { fail "backtrace from call7h" ; return }
	timeout { fail "(timeout) backtrace from call7h" ; return }
d837 3
a839 3
    send "break call7i\n" ; expect -re ".*$prompt $"
    send "break call7j\n" ; expect -re ".*$prompt $"
    send "break call7k\n" ; expect -re ".*$prompt $"
d844 1
a844 6
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7i .*$prompt $" { pass "continue to call7i" }
	-re "$prompt $" { fail "continue to call7i" ; return }
	timeout { fail "(timeout) continue to call7i" ; return }
    }
d846 12
a857 16
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) .*\r
.* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) .*\r
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7i" }
	-re "$prompt $" { fail "backtrace from call7i" ; return }
	timeout { fail "(timeout) backtrace from call7i" ; return }
d863 1
a863 6
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7j .*$prompt $" { pass "continue to call7j" }
	-re "$prompt $" { fail "continue to call7j" ; return }
	timeout { fail "(timeout) continue to call7j" ; return }
    }
d865 13
a877 17
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7j \\(ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8\\) .*\r
.* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) .*\r
.* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) .*\r
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7j" }
	-re "$prompt $" { fail "backtrace from call7j" ; return }
	timeout { fail "(timeout) backtrace from call7j" ; return }
d883 1
a883 6
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7k .*$prompt $" { pass "continue to call7k" }
	-re "$prompt $" { fail "continue to call7k" ; return }
	timeout { fail "(timeout) continue to call7k" ; return }
    }
d886 14
a899 18
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7k \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* call7j \\(ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8\\) .*\r
.* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) .*\r
.* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) .*\r
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7k" }
	-re "$prompt $" { fail "backtrace from call7k" ; return }
	timeout { fail "(timeout) backtrace from call7k" ; return }
d901 1
d909 1
a909 1
    global prompt
d916 1
a916 1
    send "break hitbottom\n" ; expect -re ".*$prompt $"
d921 20
a940 23
    expect {
	-re ".*Breakpoint $decimal, hitbottom .*$prompt $" { pass "run to hitbottom" }
	-re "$prompt $" { fail "run to hitbottom" ; return }
	timeout { fail "(timeout) run to hitbottom" ; return }
    }

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* hitbottom \\(\\) .*\r
.* recurse \\(a=\{s = 0, i = 0, l = 0\}, depth=0\\) .*\r
.* recurse \\(a=\{s = 1, i = 1, l = 1\}, depth=1\\) .*\r
.* recurse \\(a=\{s = 2, i = 2, l = 2\}, depth=2\\) .*\r
.* recurse \\(a=\{s = 3, i = 3, l = 3\}, depth=3\\) .*\r
.* recurse \\(a=\{s = 4, i = 4, l = 4\}, depth=4\\) .*\r
.* test_struct_args \\(\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "recursive passing of structs by value" }
	-re "$prompt $" { fail "recursive passing of structs by value" ; return }
	timeout { fail "(timeout) recursive passing of structs by value" ; return }
d942 1
d951 1
a951 1
    if [istarget "mips-idt-*"] then {
d964 1
a964 1
    global prompt
d969 1
a969 1
    if { ! [ runto localvars_after_alloca ] } then { return 0 }
d981 2
a982 5
    send "next\n"
    expect {
	-re ".*$prompt $" { pass "next in localvars_after_alloca()" }
	timeout { fail "(timeout) next in localvars_after_alloca()" ; return }
    }
d993 1
d997 1
a997 1
    global prompt
d1002 1
a1002 1
    if { ! [ runto call_after_alloca_subr ] } then { return 0 }
d1016 1
d1025 1
a1025 1
    global prompt
d1033 1
a1033 1
    if { ! [ runto marker_indirect_call ] } then { return 0 }
d1037 2
a1038 3
    gdb_test "break call0a" "Breakpoint .*" \
	"break call0a in localvars_in_indirect_call"
    gdb_test "continue" "call0a .*" "continue in localvars_in_indirect_call"
d1065 6
a1070 4
    send "finish\n"
    expect {
	-re "\\(\\*pointer_to_call0a\\) \\(c, s, i, l\\);.*First.*$prompt $" {
	    send "step\n"
d1073 1
a1073 1
	-re "\\(\\*pointer_to_call0a\\) \\(c, s, i, l\\);.*Second.*$prompt $" {
d1076 1
a1076 1
	-re ".*$prompt $" {
d1078 1
a1078 1
	    return
d1080 1
a1080 1
	default { fail "finish from indirectly called function" ; return }
d1086 1
a1088 1
# Start with a fresh gdb.
d1091 1
a1091 1
# cascaded) on both the call path and the return path.
d1095 1
a1095 1
    global prompt
d1100 1
a1100 1
    if { ! [ runto marker_call_with_trampolines ] } then { return 0 }
d1103 4
a1106 4
    send "finish\n"
    expect {
	-re "marker_call_with_trampolines ..;.*$prompt $" {
	    send "step\n"
d1109 1
a1109 1
	-re "pointer_to_call_with_trampolines.*$prompt $" {
d1112 1
a1112 1
	-re ".*$prompt $" {
d1115 1
a1115 1
	default { fail "finish from marker_call_with_trampolines" ; return 0 }
d1127 1
a1127 1
    # Stepping back to main might stop again after the return statement
d1130 5
a1134 5
    send "step\n"
    expect {
	-re "main .* at.*$prompt $" {
	    pass "stepping back to main from function called with trampolines" ;
	    return 1
d1136 2
a1137 2
	-re "\}.*End of call_with_trampolines.*$prompt $" {
	    send "step\n"
d1140 1
a1140 1
	-re ".*$prompt $" {
d1143 1
a1143 1
	default { fail "stepping back to main from function called with trampolines" ; return 0 }
d1145 1
d1155 45
d1204 3
a1206 1
float_and_integral_args
@


1.1
log
@file funcargs.exp was initially added on branch CYGNUS.
@
text
@d1 1302
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 1226
# Copyright 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003,
# 2004 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Fred Fish. (fnf@@cygnus.com)

if $tracelevel {
    strace $tracelevel
}

set prms_id 0
set bug_id 0

set testfile "funcargs"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}
if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

# Create and source the file that provides information about the compiler
# used to compile the test case.
if [get_compiler_info ${binfile}] {
    return -1;
}

#
# Locate actual args; integral types.
#

proc integral_args {} {
    global gdb_prompt
    global det_file
    global gcc_compiled

    delete_breakpoints

    gdb_breakpoint call0a
    gdb_breakpoint call0b
    gdb_breakpoint call0c
    gdb_breakpoint call0d
    gdb_breakpoint call0e

    # Run; should stop at call0a and print actual arguments.
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_run_cmd
    gdb_expect {
	 -re ".* call0a \\(c=97 'a', s=1, i=2, l=3\\) .*$gdb_prompt $" {
	    pass "run to call0a"
	}
	 -re "$gdb_prompt $"  { fail "run to call0a" ; gdb_suppress_tests }
	 timeout { fail "(timeout) run to call0a" ; gdb_suppress_tests }
    }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.
    gdb_test "print c" ".* = 97 'a'" "print c after run to call0a" 
    gdb_test "print s" ".* = 1" "print s after run to call0a"
    gdb_test "print i" ".* = 2" "print i after run to call0a"
    gdb_test "print l " ".* = 3" "print l after run to call0a"

    # Continue; should stop at call0b and print actual arguments.
    if [gdb_test "cont" ".* call0b \\(s=1, i=2, l=3, c=97 'a'\\) .*" "continue to call0b"] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call0c and print actual arguments.
    if [gdb_test "cont" ".* call0c \\(i=2, l=3, c=97 'a', s=1\\) .*" "continue to call0c"] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call0d and print actual arguments.
    if [gdb_test "cont" ".* call0d \\(l=3, c=97 'a', s=1, i=2\\) .*" "continue to call0d";] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call0e and print actual arguments.
    if [gdb_test "cont" ".* call0e \\(c1=97 'a', l=3, c2=97 'a', i=2, c3=97 'a', s=1, c4=97 'a', c5=97 'a'\\) .*" "continue to call0e" ] {
	gdb_suppress_tests;
    }
    gdb_stop_suppressing_tests;
}

#
# Locate actual args; unsigned integral types.
#

proc unsigned_integral_args {} {
    global gdb_prompt
    global det_file
    global gcc_compiled

    delete_breakpoints

    gdb_breakpoint call1a;
    gdb_breakpoint call1b;
    gdb_breakpoint call1c;
    gdb_breakpoint call1d;
    gdb_breakpoint call1e;

    # Run; should stop at call1a and print actual arguments.
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_run_cmd
    gdb_expect {
	 -re ".* call1a \\(uc=98 'b', us=6, ui=7, ul=8\\) .*$gdb_prompt $" {
	    pass "run to call1a"
	}
	 -re "$gdb_prompt $" { fail "run to call1a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call1a" ; gdb_suppress_tests; }
    }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.
    gdb_test "print uc" ".* = 98 'b'"
    gdb_test "print us" ".* = 6"
    gdb_test "print ui" ".* = 7"
    gdb_test "print ul" ".* = 8"
    
    # Continue; should stop at call1b and print actual arguments.
    if [gdb_test "cont" ".* call1b \\(us=6, ui=7, ul=8, uc=98 'b'\\) .*" "continue to call1b"] {
	gdb_suppress_tests; 
    }

    # Continue; should stop at call1c and print actual arguments.
    if [gdb_test "cont" ".* call1c \\(ui=7, ul=8, uc=98 'b', us=6\\) .*" "continue to call1c"] {
	gdb_suppress_tests; 
    }

    # Continue; should stop at call1d and print actual arguments.
    if [gdb_test "cont" ".* call1d \\(ul=8, uc=98 'b', us=6, ui=7\\) .*" "continue to call1d"] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call1e and print actual arguments.
    if [gdb_test "cont" ".* call1e \\(uc1=98 'b', ul=8, uc2=98 'b', ui=7, uc3=98 'b', us=6, uc4=98 'b', uc5=98 'b'\\) .*" "continue to call1e"] {
	gdb_suppress_tests;
    }
    gdb_stop_suppressing_tests;
}

#
# Locate actual args; integrals mixed with floating point.
#

proc float_and_integral_args {} {
    global gdb_prompt
    global det_file
    global gcc_compiled

    delete_breakpoints

    gdb_breakpoint call2a
    gdb_breakpoint call2b
    gdb_breakpoint call2c
    gdb_breakpoint call2d
    gdb_breakpoint call2e
    gdb_breakpoint call2f
    gdb_breakpoint call2g
    gdb_breakpoint call2h

    # Run; should stop at call2a and print actual arguments.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" "mips-sgi-irix5*" }
    gdb_run_cmd
    gdb_expect {
	 -re ".* call2a \\(c=97 'a', f1=4, s=1, d1=5, i=2, f2=4, l=3, d2=5\\) .*$gdb_prompt $" { pass "run to call2a" }
	 -re ".* call2a \\(c=97 'a', f1=.*, s=1, d1=5, i=2, f2=4, l=3, d2=5\\) .*$gdb_prompt $" { xfail "run to call2a" }
	 -re "$gdb_prompt $" { fail "run to call2a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call2a" ; gdb_suppress_tests; }
    }

    # Print each arg as a double check to see if we can print
    gdb_test "print c" ".* = 97 'a'" "print c after run to call2a"
    gdb_test "print f1" ".* = 4" "print f1 after run to call2a"
    gdb_test "print s" ".* = 1" "print s after run to call2a"
    gdb_test "print d1" ".* = 5" "print d1 after run to call2a"
    gdb_test "print i" ".* = 2" "print i after run to call2a"
    gdb_test "print f2" ".* = 4" "print f2 after run to call2a"
    gdb_test "print l" ".* = 3" "print l after run to call2a"
    gdb_test "print d2" ".* = 5" "print d2 after run to call2a"

    setup_xfail "rs6000-*-*"
    if {!$gcc_compiled} then { setup_xfail "mips-sgi-irix*" }
    # Continue; should stop at call2b and print actual arguments.
    if [gdb_test "cont" ".* call2b \\(f1=4, s=1, d1=5, i=2, f2=4, l=3, d2=5, c=97 'a'\\) .*" "continue to call2b"] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call2c and print actual arguments.
    if [gdb_test "cont" ".* call2c \\(s=1, d1=5, i=2, f2=4, l=3, d2=5, c=97 'a', f1=4\\) .*" "continue to call2c"] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call2d and print actual arguments.
    if [gdb_test "cont" ".* call2d \\(d1=5, i=2, f2=4, l=3, d2=5, c=97 'a', f1=4, s=1\\) .*" "continue to call2d"] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call2e and print actual arguments.
    if [gdb_test "cont" ".* call2e \\(i=2, f2=4, l=3, d2=5, c=97 'a', f1=4, s=1, d1=5\\) .*" "continue to call2e"] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call2f and print actual arguments.
    if [gdb_test "cont" ".* call2f \\(f2=4, l=3, d2=5, c=97 'a', f1=4, s=1, d1=5, i=2\\) .*" "continue to call2f"] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call2g and print actual arguments.
    if [gdb_test "cont" ".* call2g \\(l=3, d2=5, c=97 'a', f1=4, s=1, d1=5, i=2, f2=4\\) .*" "continue to call2g"] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call2h and print actual arguments.
    if [gdb_test "cont" ".* call2h \\(d2=5, c=97 'a', f1=4, s=1, d1=5, i=2, f2=4, l=3\\) .*" "continue to call2h"] {
	gdb_suppress_tests;
    }

    # monitor only allows 8 breakpoints; w89k board allows 10, so
    # break them up into two groups.
    delete_breakpoints
    gdb_breakpoint call2i

    # Continue; should stop at call2i and print actual arguments.
    if [gdb_test "cont" ".* call2i \\(c1=97 'a', f1=4, c2=97 'a', c3=97 'a', d1=5, c4=97 'a', c5=97 'a', c6=97 'a', f2=4, s=1, c7=97 'a', d2=5\\) .*" "continue to call2i"] {
	gdb_suppress_tests;
    }
    gdb_stop_suppressing_tests;
}

#
# Locate actual args; dereference pointers to ints and floats.
#

proc pointer_args {} {
    global gdb_prompt
    global hex
    global det_file

    delete_breakpoints

    gdb_breakpoint call3a
    gdb_breakpoint call3b
    gdb_breakpoint call3c

    # Run; should stop at call3a and print actual arguments.
    # Try dereferencing the arguments.

    gdb_run_cmd
    gdb_expect {
	 -re ".* call3a \\(cp=$hex \"a.*\", sp=$hex, ip=$hex, lp=$hex\\) .*$gdb_prompt $" { pass "run to call3a" }
	 -re "$gdb_prompt $" { fail "run to call3a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call3a" ; gdb_suppress_tests; }
    }

    gdb_test "print *cp" ".* = 97 'a'"
    gdb_test "print *sp" ".* = 1"
    gdb_test "print *ip" ".* = 2"
    gdb_test "print *lp" ".* = 3"

    # Continue; should stop at call3b and print actual arguments.
    # Try dereferencing the arguments.
    if [gdb_test "cont" ".* call3b \\(ucp=$hex \"b.*\", usp=$hex, uip=$hex, ulp=$hex\\) .*" "continue to call3b"] {
	gdb_suppress_tests;
    }

    gdb_test "print *ucp" ".* = 98 'b'"
    gdb_test "print *usp" ".* = 6"
    gdb_test "print *uip" ".* = 7"
    gdb_test "print *ulp" ".* = 8"

    # Continue; should stop at call3c and print actual arguments.
    # Try dereferencing the arguments.
    if [gdb_test "cont" ".* call3c \\(fp=$hex, dp=$hex\\) .*" "continue to call3c"] {
	gdb_suppress_tests;
    }

    gdb_test "print *fp" ".* = 4"
    gdb_test "print *dp" ".* = 5"

#    pass "locate actual args, pointer types"
    gdb_stop_suppressing_tests;
}

#
# Locate actual args; structures and unions passed by reference.
#

proc structs_by_reference {} {
    global gdb_prompt
    global hex
    global det_file
    global target_sizeof_int
    global target_sizeof_long
    global target_bigendian_p

    delete_breakpoints

    gdb_breakpoint call4a
    gdb_breakpoint call4b

    # Run; should stop at call4a and print actual arguments.
    # Try dereferencing the arguments.

    gdb_run_cmd
    gdb_expect {
	 -re ".* call4a \\(stp=$hex\\) .*$gdb_prompt $" {
	    pass "run to call4a"
	}
	 -re "$gdb_prompt $" { fail "run to call4a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call4a" ; gdb_suppress_tests; }
    }

    gdb_test "print *stp" ".* = \{s1 = 101, s2 = 102\}"

    # Continue; should stop at call4b and print actual arguments.

    gdb_test "cont" ".* call4b \\(unp=$hex\\) .*" "continue to call4b"

    # Try dereferencing the arguments.
    if { $target_sizeof_long == $target_sizeof_int } {
	gdb_test "print *unp" ".* = \{u1 = 1, u2 = 1\}" \
		"print *unp (sizeof long == sizeof int)"
    } elseif { ! $target_bigendian_p } {
	gdb_test "print *unp" ".* = \{u1 = 1, u2 = 1\}" \
		"print *unp (little-endian, sizeof long != sizeof int)"
    } elseif { $target_sizeof_long == 8 && $target_sizeof_int == 4 } {
	gdb_test "print *unp" ".* = \{u1 = 1, u2 = 4294967296\}" \
		"print *unp (big-endian, sizeof long == 8, sizeof int = 4)"
    } elseif { $target_sizeof_long == 4 && $target_sizeof_int == 2 } {
	gdb_test "print *unp" ".* = \{u1 = 1, u2 = 65536\}" \
		"print *unp (big-endian, sizeof long == 4, sizeof int = 2)"
    } else {
	fail "print *unp (unknown case)"
    }

    pass "locate actual args, structs/unions passed by reference"
    gdb_stop_suppressing_tests;
}

#
# Locate actual args; structures and unions passed by value.
#

proc structs_by_value {} {
    global gdb_prompt
    global hex
    global det_file
    global target_sizeof_int
    global target_sizeof_long
    global target_bigendian_p

    delete_breakpoints

    gdb_breakpoint call5a
    gdb_breakpoint call5b

    # Run; should stop at call5a and print actual arguments.
    # Try dereferencing the arguments.

    gdb_run_cmd
    gdb_expect {
	 -re ".* call5a \\(st=\{s1 = 101, s2 = 102\}\\) .*$gdb_prompt $" {
	    pass "run to call5a"
	}
	 -re "$gdb_prompt $" { fail "run to call5a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call5a" ; gdb_suppress_tests; }
    }

    gdb_test "print st" ".* = \{s1 = 101, s2 = 102\}"

    # Continue; should stop at call5b and print actual arguments.
    if { $target_sizeof_long == $target_sizeof_int } {
	gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 2\}\\) .*" \
		"continue to call5b (sizeof long == sizeof int)"
    } elseif { ! $target_bigendian_p } {
	gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 2\}\\) .*" \
		"continue to call5b (little-endian, sizeof long != sizeof int)"
    } elseif { $target_sizeof_long == 8 && $target_sizeof_int == 4 } {
	gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 8589934592\}\\) .*" \
		"continue to call5b (big-endian, sizeof long == 8, sizeof int = 4)"
    } elseif { $target_sizeof_long == 4 && $target_sizeof_int == 2 } {
	gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 131072\}\\) .*" \
		"continue to call5b (big-endian, sizeof long == 4, sizeof int = 2)"
    } else {
	fail "continue to call5b (unknown case)"
    }

    # Try dereferencing the arguments.
    if { $target_sizeof_long == $target_sizeof_int } {
	gdb_test "print un" ".* = \{u1 = 2, u2 = 2\}" \
		"print un (sizeof long == sizeof int)"
    } elseif { ! $target_bigendian_p } {
	gdb_test "print un" ".* = \{u1 = 2, u2 = 2\}" \
		"print un (little-endian, sizeof long != sizeof int)"
    } elseif { $target_sizeof_long == 8 && $target_sizeof_int == 4 } {
	gdb_test "print un" ".* = \{u1 = 2, u2 = 8589934592\}" \
		"print un (big-endian, sizeof long == 8, sizeof int = 4)"
    } elseif { $target_sizeof_long == 4 && $target_sizeof_int == 2 } {
	gdb_test "print un" ".* = \{u1 = 2, u2 = 131072\}" \
		"print un (big-endian, sizeof long == 4, sizeof int = 2)"
    } else {
	fail "print un (unknown case)"
    }

    gdb_stop_suppressing_tests;
}

#
# Locate actual args; discard, shuffle, and call
#

proc discard_and_shuffle {} {
    global gdb_prompt
    global hex
    global decimal
    global det_file
    global gcc_compiled

    delete_breakpoints

    gdb_breakpoint call6a
    gdb_breakpoint call6b
    gdb_breakpoint call6c
    gdb_breakpoint call6d
    gdb_breakpoint call6e
    gdb_breakpoint call6f
    gdb_breakpoint call6g
    gdb_breakpoint call6h

    # Run; should stop at call6a and print actual arguments.
    # Print backtrace.

    gdb_run_cmd
    gdb_expect {
	 -re ".*Breakpoint $decimal, call6a .*$gdb_prompt $" { pass "run to call6a" }
	 -re "$gdb_prompt $" { fail "run to call6a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call6a" ; gdb_suppress_tests; }
    }

    setup_xfail "rs6000-*-*"

    if {!$gcc_compiled} {
	setup_xfail "mips-sgi-irix5*"
    }

    send_gdb "backtrace 100\n"
    gdb_expect {
	-re "backtrace 100\[\r\n\]+
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$gdb_prompt $" {
	    pass "backtrace from call6a"
	}
	-re "backtrace 100\[\r\n\]+
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=.*, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$gdb_prompt $" {
	    xfail "backtrace from call6a"
	}
	-re "$gdb_prompt $" {
	    fail "backtrace from call6a"
	    gdb_suppress_tests
	}
	timeout {
	    fail "(timeout) backtrace from call6a"
	    gdb_suppress_tests
	}
    }

    # Continue; should stop at call6b and print actual arguments.
    # Print backtrace.

    gdb_continue call6b

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6b" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* main \\(.*\\) " 
    } ] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call6c and print actual arguments.
    # Print backtrace.

    gdb_continue call6c

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6c" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
    }
    # Continue; should stop at call6d and print actual arguments.
    # Print backtrace.

    gdb_continue call6d

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6d" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call6e and print actual arguments.
    # Print backtrace.

    gdb_continue call6e

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6e" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call6f and print actual arguments.
    # Print backtrace.

    gdb_continue call6f

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6f" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#6 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call6g and print actual arguments.
    # Print backtrace.

    gdb_continue call6g

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6g" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#6 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#7 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call6h and print actual arguments.
    # Print backtrace.

    gdb_continue call6h

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6h" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6h \\(us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#6 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#7 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#8 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
    }

    # monitor only allows 8 breakpoints; w89k board allows 10, so
    # break them up into two groups.
    delete_breakpoints
    gdb_breakpoint call6i
    gdb_breakpoint call6j
    gdb_breakpoint call6k

    # Continue; should stop at call6i and print actual arguments.
    # Print backtrace.

    gdb_continue call6i

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6i" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6i \\(ui=7, ul=8\\) "
	".*\[\r\n\]#1 .* call6h \\(us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#6 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#7 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#8 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#9 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call6j and print actual arguments.
    # Print backtrace.

    gdb_continue call6j

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6j" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6j \\(ul=8\\) "
	".*\[\r\n\]#1 .* call6i \\(ui=7, ul=8\\) "
	".*\[\r\n\]#2 .* call6h \\(us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#6 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#7 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#8 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#9 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#10 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
    }

    # Continue; should stop at call6k and print actual arguments.
    # Print backtrace.
    gdb_continue call6k

    send_gdb "backtrace 100\n"
    if [gdb_expect_list "backtrace from call6k" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call6k \\(\\) "
	".*\[\r\n\]#1 .* call6j \\(ul=8\\) "
	".*\[\r\n\]#2 .* call6i \\(ui=7, ul=8\\) "
	".*\[\r\n\]#3 .* call6h \\(us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#4 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#5 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#6 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#7 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#8 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#9 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#10 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	".*\[\r\n\]#11 .* main \\(.*\\) "
    } ] {
	gdb_suppress_tests;
    }
    gdb_stop_suppressing_tests;
}


#
# Locate actual args; shuffle round robin and call
#

proc shuffle_round_robin {} {
    global gdb_prompt
    global hex
    global decimal
    global det_file
    global gcc_compiled

    delete_breakpoints

    gdb_breakpoint call7a
    gdb_breakpoint call7b
    gdb_breakpoint call7c
    gdb_breakpoint call7d
    gdb_breakpoint call7e
    gdb_breakpoint call7f
    gdb_breakpoint call7g
    gdb_breakpoint call7h

    # Run; should stop at call7a and print actual arguments.
    # Print backtrace.

    gdb_run_cmd
    gdb_expect {
	 -re ".*Breakpoint $decimal, call7a .*$gdb_prompt $" {
	    pass "run to call7a"
	}
	 -re "$gdb_prompt $" { fail "run to call7a" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to call7a" ; gdb_suppress_tests; }
    }

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" "mips-sgi-irix5*" }
    send_gdb "backtrace 100\n"
    gdb_expect {
	-re "backtrace 100\[\r\n\]+
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$gdb_prompt $" {
	    pass "backtrace from call7a"
	}
	-re "backtrace 100\[\r\n\]+
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=.*, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$gdb_prompt $" {
	    xfail "backtrace from call7a"
	}
	-re "$gdb_prompt $" { fail "backtrace from call7a" ; return }
	timeout { fail "(timeout) backtrace from call7a" ; return }
    }

    # Continue; should stop at call7b and print actual arguments.
    # Print backtrace.

    gdb_continue call7b

    if {$gcc_compiled} then { setup_xfail "rs6000-*-*" }

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7b" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#1 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#2 .* main \\(.*\\) "
    }

    # Continue; should stop at call7c and print actual arguments.
    # Print backtrace.

    gdb_continue call7c

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7c" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#1 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#2 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#3 .* main \\(.*\\) "
    }

    # Continue; should stop at call7d and print actual arguments.
    # Print backtrace.

    gdb_continue call7d

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7d" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#1 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#2 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#3 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#4 .* main \\(.*\\) "
    }

    gdb_continue call7e

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7e" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#1 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#2 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#3 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#4 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#5 .* main \\(.*\\) "
    }

    # Continue; should stop at call7f and print actual arguments.
    # Print backtrace.

    gdb_continue call7f

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7f" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	".*\[\r\n\]#1 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#2 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#3 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#4 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#5 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#6 .* main \\(.*\\) "
    }

    # Continue; should stop at call7g and print actual arguments.
    # Print backtrace.

    gdb_continue call7g

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7g" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	".*\[\r\n\]#1 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	".*\[\r\n\]#2 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#3 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#4 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#5 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#6 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#7 .* main \\(.*\\) "
    }

    gdb_continue call7h

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7h" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) "
	".*\[\r\n\]#1 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	".*\[\r\n\]#2 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	".*\[\r\n\]#3 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#4 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#5 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#6 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#7 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#8 .* main \\(.*\\) "
    }

    # monitor only allows 8 breakpoints; w89k board allows 10, so
    # break them up into two groups.
    delete_breakpoints
    gdb_breakpoint call7i
    gdb_breakpoint call7j
    gdb_breakpoint call7k

    # Continue; should stop at call7i and print actual arguments.
    # Print backtrace.

    gdb_continue call7i

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7i" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) "
	".*\[\r\n\]#1 .* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) "
	".*\[\r\n\]#2 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	".*\[\r\n\]#3 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	".*\[\r\n\]#4 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#5 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#6 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#7 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#8 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#9 .* main \\(.*\\) "
    }

    # Continue; should stop at call7j and print actual arguments.
    # Print backtrace.

    gdb_continue call7j

    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7j" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7j \\(ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8\\) "
	".*\[\r\n\]#1 .* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) "
	".*\[\r\n\]#2 .* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) "
	".*\[\r\n\]#3 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	".*\[\r\n\]#4 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	".*\[\r\n\]#5 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#6 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#7 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#8 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#9 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#10 .* main \\(.*\\) "
    }

    # Continue; should stop at call7k and print actual arguments.
    # Print backtrace.

    gdb_continue call7k

    if {!$gcc_compiled} then { setup_xfail "mips-sgi-irix*" }
    send_gdb "backtrace 100\n"
    gdb_expect_list "backtrace from call7k" ".*$gdb_prompt $" {
	".*\[\r\n\]#0 .* call7k \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#1 .* call7j \\(ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8\\) "
	".*\[\r\n\]#2 .* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) "
	".*\[\r\n\]#3 .* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) "
	".*\[\r\n\]#4 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	".*\[\r\n\]#5 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	".*\[\r\n\]#6 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	".*\[\r\n\]#7 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	".*\[\r\n\]#8 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	".*\[\r\n\]#9 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	".*\[\r\n\]#10 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	".*\[\r\n\]#11 .* main \\(.*\\) "
    }
    gdb_stop_suppressing_tests;
}

#
# Locate actual args; recursive passing of structs by value
#

proc recursive_structs_by_value {} {
    global gdb_prompt
    global hex
    global decimal
    global det_file

    delete_breakpoints

    gdb_breakpoint hitbottom

    # Run; should stop at hitbottom and print actual arguments.
    # Print backtrace.
    gdb_run_cmd
    gdb_expect {
	 -re ".*Breakpoint $decimal, hitbottom .*$gdb_prompt $" { pass "run to hitbottom" }
	 -re "$gdb_prompt $" { fail "run to hitbottom" ; gdb_suppress_tests; }
	 timeout { fail "(timeout) run to hitbottom" ; gdb_suppress_tests; }
    }

    if ![istarget sparclet-*-*] {
	send_gdb "backtrace 100\n"
	gdb_expect_list "recursive passing of structs by value" ".*$gdb_prompt $" {
	    ".*\[\r\n\]#0 .* hitbottom \\(\\) "
	    ".*\[\r\n\]#1 .* recurse \\(a=\{s = 0, i = 0, l = 0\}, depth=0\\) "
	    ".*\[\r\n\]#2 .* recurse \\(a=\{s = 1, i = 1, l = 1\}, depth=1\\) "
	    ".*\[\r\n\]#3 .* recurse \\(a=\{s = 2, i = 2, l = 2\}, depth=2\\) "
	    ".*\[\r\n\]#4 .* recurse \\(a=\{s = 3, i = 3, l = 3\}, depth=3\\) "
	    ".*\[\r\n\]#5 .* recurse \\(a=\{s = 4, i = 4, l = 4\}, depth=4\\) "
	    ".*\[\r\n\]#6 .* test_struct_args \\(\\) "
	    ".*\[\r\n\]#7 .* main \\(.*\\) "
	}
    } else {
	fail "recursive passing of structs by value (sparclet)"
    }
    gdb_stop_suppressing_tests;
}

proc funcargs_reload { } {
    global objdir
    global subdir
    global binfile
    global srcdir

    if [istarget "mips-idt-*"] {
	# Restart because IDT/SIM runs out of file descriptors.
	gdb_exit
	gdb_start
	gdb_reinitialize_dir $srcdir/$subdir
	gdb_load ${binfile}
    }
}

#
# Test for accessing local stack variables in functions which call alloca
#
proc localvars_after_alloca { } {
    global gdb_prompt
    global hex
    global decimal
    global gcc_compiled

    if { ! [ runto localvars_after_alloca ] } then { gdb_suppress_tests; }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print c" " = 97 'a'" "print c after runto localvars_after_alloca"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print s" " = 1" "print s after runto localvars_after_alloca"
    gdb_test "print i" " = 2" "print i after runto localvars_after_alloca"
    gdb_test "print l" " = 3" "print l after runto localvars_after_alloca"

    # Lame regexp.
    gdb_test "next" ".*" "next in localvars_after_alloca()"

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    gdb_test "print c" " = 97 'a'" "print c in localvars_after_alloca"
    gdb_test "print s" " = 1" "print s in localvars_after_alloca"
    gdb_test "print i" " = 2" "print i in localvars_after_alloca"
    gdb_test "print l" " = 3" "print l in localvars_after_alloca"

    gdb_test "backtrace 8" "#0.*localvars_after_alloca \\(c=97 'a', s=1, i=2, l=3\\).*#1.*main.*" "backtrace after alloca"
    gdb_stop_suppressing_tests;
}

proc call_after_alloca { } {
    global gdb_prompt
    global hex
    global decimal
    global gcc_compiled

    if { ! [ runto call_after_alloca_subr ] } then { gdb_suppress_tests; }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print c" " = 97 'a'" "print c in call_after_alloca"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print s" " = 1" "print s in call_after_alloca"
    gdb_test "print i" " = 2" "print i in call_after_alloca"
    gdb_test "print l" " = 3" "print l in call_after_alloca"

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "backtrace 8" "#0.*call_after_alloca_subr \\(c=97 'a', s=1, i=2, l=3, uc=98 'b', us=11, ui=12, ul=13\\).*#1.*call_after_alloca \\(c=97 'a', s=1, i=2, l=3\\).*#2.*main.*" "backtrace from call_after_alloca_subr"
    gdb_stop_suppressing_tests;
}

#
# Test for accessing local stack variables, backtraces, finish,
# and finally stepping into indirect calls.  The point is that on the PA
# these use a funky `dyncall' mechanism which GDB needs to know about.
#
proc localvars_in_indirect_call { } {
    global gdb_prompt
    global hex
    global decimal
    global gcc_compiled

    # Can not use "runto call0a" as call0a is called several times
    # during single run.  Instead stop in a marker function and
    # take control from there.
    if { ! [ runto marker_indirect_call ] } then { gdb_suppress_tests; }

    # break on the next call to call0a, then delete all the breakpoints
    # and start testing.
    gdb_breakpoint call0a
    gdb_continue call0a
    delete_breakpoints
    
    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print c" " = 97 'a'" "print c in localvars_in_indirect_call"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print s" " = 1" "print s in localvars_in_indirect_call"
    gdb_test "print i" " = 2" "print i in localvars_in_indirect_call"
    gdb_test "print l" " = 3" "print l in localvars_in_indirect_call"

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "backtrace 8" \
	"#0.*call0a \\(c=97 'a', s=1, i=2, l=3\\).*#1.*main.*" \
	"backtrace in indirectly called function"

    # 
    # "finish" brings us back to main.  We then will try to step through
    # the second indirect call.  
    # On some targets (e.g. m68k) gdb will stop from the finish in midline
    # of the first indirect call. This is due to stack adjustment instructions
    # after the indirect call. In these cases we will step till we hit the
    # second indirect call.
    #

    send_gdb "finish\n"
    gdb_expect {
	 -re "\\(\\*pointer_to_call0a\\) \\(c, s, i, l\\);.*First.*$gdb_prompt $" {
#On hppa2.0w-hp-hpux11.00, gdb finishes at one line earlier than 
#hppa1.1-hp-hpux11.00. Therefore, an extra "step" is necessary to continue the test.
	    send_gdb "step\n"
	    exp_continue
	}
	 -re ".*\\(\\*pointer_to_call0a\\) \\(c, s, i, l\\);.*Second.*$gdb_prompt $" {
	    pass "finish from indirectly called function"
	}
	 -re ".*$gdb_prompt $" {
	    fail "finish from indirectly called function"
	    gdb_suppress_tests;
	}
	 default { fail "finish from indirectly called function" ; gdb_suppress_tests; }
    }

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "step" "call0a \\(c=97 'a', s=1, i=2, l=3\\).*" \
	"stepping into indirectly called function"
    gdb_stop_suppressing_tests;
}

#
# Test for stepping into indirect calls which may have trampolines (possibly
# cascaded) on both the call path and the gdb_suppress_tests; path.
# to handle trampolines.
#
proc test_stepping_over_trampolines { } {
    global gdb_prompt
    global hex
    global decimal

    # Stop in a marker function and take control from there.
    if { ! [ runto marker_call_with_trampolines ] } then { gdb_suppress_tests; }

    # Cater for gdb stopping in midline, see comment for finish above.
    send_gdb "finish\n"
    gdb_expect {
	 -re "marker_call_with_trampolines ..;.*$gdb_prompt $" {
	    send_gdb "step\n"
	    exp_continue
	}
	 -re "pointer_to_call_with_trampolines.*$gdb_prompt $" {
	    pass "finish from marker_call_with_trampolines"
	}
	 -re ".*$gdb_prompt $" {
	    fail "finish from marker_call_with_trampolines"
	}
	 default { fail "finish from marker_call_with_trampolines" ; gdb_suppress_tests; }
    }

    # Try to step into the target function.
    gdb_test "step" "call_with_trampolines \\(d1=5\\).*" \
	"stepping into function called with trampolines"

    # Make we can backtrace and the argument looks correct.  */
    gdb_test "backtrace 8" "#0.*call_with_trampolines \\(d1=5\\).*1.*main.*" \
	"backtrace through call with trampolines"

    # Make sure we can get back to main.
    # Stepping back to main might stop again after the gdb_suppress_tests; statement
    # or immediately transfer control back to main if optimizations
    # are performed.
    send_gdb "step\n"
    gdb_expect {
	 -re "main .* at.*$gdb_prompt $" {
	     pass "stepping back to main from function called with trampolines" ;
	     gdb_suppress_tests
	}
	 -re "\}.*End of call_with_trampolines.*$gdb_prompt $" {
	    send_gdb "step\n"
	    exp_continue
	}
	 -re ".*$gdb_prompt $" {
	    fail "stepping back to main from function called with trampolines"
	}
	 default { fail "stepping back to main from function called with trampolines" ; gdb_suppress_tests; }
    }
    gdb_stop_suppressing_tests;
}

# Start with a fresh gdb.

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

if [istarget "mips*tx39-*"] {
    set timeout 300
} else {
    set timeout 60
}

# Determine expected output for unsigned long variables,
# the output varies with sizeof (unsigned long).

set target_sizeof_long 4
send_gdb "print sizeof (long)\n"
gdb_expect {
    -re ".\[0-9\]* = 4.*$gdb_prompt $" { }
    -re ".\[0-9\]* = 8.*$gdb_prompt $" { set target_sizeof_long 8 } 
    -re ".*$gdb_prompt $" {
	 fail "getting sizeof long"
    }
    default	{ fail "(timeout) getting sizeof long" }
}

set target_sizeof_int 4
send_gdb "print sizeof (int)\n"
gdb_expect {
    -re ".\[0-9\]* = 2.*$gdb_prompt $" { set target_sizeof_int 2 }
    -re ".\[0-9\]* = 4.*$gdb_prompt $" { }
    -re ".\[0-9\]* = 8.*$gdb_prompt $" { set target_sizeof_int 8 } 
    -re ".*$gdb_prompt $" {
	 fail "getting sizeof unsigned long"
    }
    default	{ fail "(timeout) getting sizeof int" }
}

set target_bigendian_p 1
send_gdb "show endian\n"
gdb_expect {
    -re ".*little endian.*$gdb_prompt $" { set target_bigendian_p 0 }
    -re ".*big endian.*$gdb_prompt $" { }
    -re ".*$gdb_prompt $" {
	 fail "getting target endian"
    }
    default	{ fail "(timeout) getting target endian" }
}

# Perform tests

integral_args
funcargs_reload
unsigned_integral_args
funcargs_reload
if {![target_info exists gdb,skip_float_tests]} {
  float_and_integral_args
}
funcargs_reload
pointer_args
funcargs_reload
structs_by_reference
funcargs_reload
structs_by_value
funcargs_reload
discard_and_shuffle
funcargs_reload
shuffle_round_robin
funcargs_reload
recursive_structs_by_value
funcargs_reload
localvars_after_alloca
funcargs_reload
call_after_alloca
funcargs_reload
localvars_in_indirect_call
funcargs_reload
test_stepping_over_trampolines
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 1302
# Copyright (C) 1992, 1994, 1995 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Fred Fish. (fnf@@cygnus.com)

if $tracelevel then {
	strace $tracelevel
}

set prms_id 0
set bug_id 0

set testfile "funcargs"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}
if  { [compile "${srcdir}/${subdir}/${srcfile} -g -o ${binfile}"] != "" } {
    perror "Couldn't compile ${srcfile}"
    return -1
}

# Create and source the file that provides information about the compiler
# used to compile the test case.
execute_anywhere "rm -f ${binfile}.ci"
if  { [compile "-E ${srcdir}/${subdir}/compiler.c > ${binfile}.ci"] != "" } {
    perror "Couldn't make ${binfile}.ci file"
    return -1
}
source ${binfile}.ci

#
# Locate actual args; integral types.
#

proc integral_args {} {
    global prompt
    global det_file
    global gcc_compiled

    delete_breakpoints

    send "break call0a\n" ; expect -re ".*$prompt $"
    send "break call0b\n" ; expect -re ".*$prompt $"
    send "break call0c\n" ; expect -re ".*$prompt $"
    send "break call0d\n" ; expect -re ".*$prompt $"
    send "break call0e\n" ; expect -re ".*$prompt $"

    # Run; should stop at call0a and print actual arguments.
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_run_cmd
    expect {
	-re ".* call0a \\(c=97 'a', s=1, i=2, l=3\\) .*$prompt $" {
	    pass "run to call0a"
	}
	-re "$prompt $"  { fail "run to call0a" ; return }
	timeout { fail "(timeout) run to call0a" ; return }
    }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.
    gdb_test "print c" ".* = 97 'a'" "print c after run to call0a" 
    gdb_test "print s" ".* = 1" "print s after run to call0a"
    gdb_test "print i" ".* = 2" "print i after run to call0a"
    gdb_test "print l " ".* = 3" "print l after run to call0a"

    # Continue; should stop at call0b and print actual arguments.
    if [gdb_test "cont" ".* call0b \\(s=1, i=2, l=3, c=97 'a'\\) .*" "continue to call0b"] {
	return 
    }

    # Continue; should stop at call0c and print actual arguments.
    if [gdb_test "cont" ".* call0c \\(i=2, l=3, c=97 'a', s=1\\) .*" "continue to call0c"] {
	return
    }

    # Continue; should stop at call0d and print actual arguments.
    if [gdb_test "cont" ".* call0d \\(l=3, c=97 'a', s=1, i=2\\) .*" "continue to call0d";] {
	return
    }

    # Continue; should stop at call0e and print actual arguments.
    if [gdb_test "cont" ".* call0e \\(c1=97 'a', l=3, c2=97 'a', i=2, c3=97 'a', s=1, c4=97 'a', c5=97 'a'\\) .*" "continue to call0e" ] {
	return
    }
}

#
# Locate actual args; unsigned integral types.
#

proc unsigned_integral_args {} {
    global prompt
    global det_file
    global gcc_compiled

    delete_breakpoints

    send "break call1a\n" ; expect -re ".*$prompt $"
    send "break call1b\n" ; expect -re ".*$prompt $"
    send "break call1c\n" ; expect -re ".*$prompt $"
    send "break call1d\n" ; expect -re ".*$prompt $"
    send "break call1e\n" ; expect -re ".*$prompt $"

    # Run; should stop at call1a and print actual arguments.
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_run_cmd
    expect {
	-re ".* call1a \\(uc=98 'b', us=6, ui=7, ul=8\\) .*$prompt $" {
	    pass "run to call1a"
	}
	-re "$prompt $" { fail "run to call1a" ; return }
	timeout { fail "(timeout) run to call1a" ; return }
    }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.
    gdb_test "print uc" ".* = 98 'b'"
    gdb_test "print us" ".* = 6"
    gdb_test "print ui" ".* = 7"
    gdb_test "print ul" ".* = 8"
    
    # Continue; should stop at call1b and print actual arguments.
    if [gdb_test "cont" ".* call1b \\(us=6, ui=7, ul=8, uc=98 'b'\\) .*" "continue to call1b"] {
	return 
    }

    # Continue; should stop at call1c and print actual arguments.
    if [gdb_test "cont" ".* call1c \\(ui=7, ul=8, uc=98 'b', us=6\\) .*" "continue to call1c"] {
	return 
    }

    # Continue; should stop at call1d and print actual arguments.
    if [gdb_test "cont" ".* call1d \\(ul=8, uc=98 'b', us=6, ui=7\\) .*" "continue to call1d"] {
	return
    }

    # Continue; should stop at call1e and print actual arguments.
    if [gdb_test "cont" ".* call1e \\(uc1=98 'b', ul=8, uc2=98 'b', ui=7, uc3=98 'b', us=6, uc4=98 'b', uc5=98 'b'\\) .*" "continue to call1e"] {
	return
    }
}

#
# Locate actual args; integrals mixed with floating point.
#

proc float_and_integral_args {} {
    global prompt
    global det_file
    global gcc_compiled

    delete_breakpoints

    send "break call2a\n" ; expect -re ".*$prompt $"
    send "break call2b\n" ; expect -re ".*$prompt $"
    send "break call2c\n" ; expect -re ".*$prompt $"
    send "break call2d\n" ; expect -re ".*$prompt $"
    send "break call2e\n" ; expect -re ".*$prompt $"
    send "break call2f\n" ; expect -re ".*$prompt $"
    send "break call2g\n" ; expect -re ".*$prompt $"
    send "break call2h\n" ; expect -re ".*$prompt $"

    # Run; should stop at call2a and print actual arguments.

    setup_xfail "i960-*-*" 1813
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" "mips-sgi-irix5*" }
    gdb_run_cmd
    expect {
	-re ".* call2a \\(c=97 'a', f1=4, s=1, d1=5, i=2, f2=4, l=3, d2=5\\) .*$prompt $" { pass "run to call2a" }
	-re "$prompt $" { fail "run to call2a" ; return }
	timeout { fail "(timeout) run to call2a" ; return }
    }

    # Print each arg as a double check to see if we can print
    gdb_test "print c" ".* = 97 'a'" "print c after run to call2a"
    gdb_test "print f1" ".* = 4" "print f1 after run to call2a"
    gdb_test "print s" ".* = 1" "print s after run to call2a"
    gdb_test "print d1" ".* = 5" "print d1 after run to call2a"
    gdb_test "print i" ".* = 2" "print i after run to call2a"
    gdb_test "print f2" ".* = 4" "print f2 after run to call2a"
    gdb_test "print l" ".* = 3" "print l after run to call2a"
    gdb_test "print d2" ".* = 5" "print d2 after run to call2a"

    setup_xfail "rs6000-*-*"
    if {!$gcc_compiled} then { setup_xfail "mips-sgi-irix*" }
    # Continue; should stop at call2b and print actual arguments.
    if [gdb_test "cont" ".* call2b \\(f1=4, s=1, d1=5, i=2, f2=4, l=3, d2=5, c=97 'a'\\) .*" "continue to call2b"] {
	return
    }

    # Continue; should stop at call2c and print actual arguments.
    if [gdb_test "cont" ".* call2c \\(s=1, d1=5, i=2, f2=4, l=3, d2=5, c=97 'a', f1=4\\) .*" "continue to call2c"] {
	return
    }

    # Continue; should stop at call2d and print actual arguments.
    if [gdb_test "cont" ".* call2d \\(d1=5, i=2, f2=4, l=3, d2=5, c=97 'a', f1=4, s=1\\) .*" "continue to call2d"] {
	return
    }

    # Continue; should stop at call2e and print actual arguments.
    if [gdb_test "cont" ".* call2e \\(i=2, f2=4, l=3, d2=5, c=97 'a', f1=4, s=1, d1=5\\) .*" "continue to call2e"] {
	return
    }

    # Continue; should stop at call2f and print actual arguments.
    if [gdb_test "cont" ".* call2f \\(f2=4, l=3, d2=5, c=97 'a', f1=4, s=1, d1=5, i=2\\) .*" "continue to call2f"] {
	return
    }

    # Continue; should stop at call2g and print actual arguments.
    if [gdb_test "cont" ".* call2g \\(l=3, d2=5, c=97 'a', f1=4, s=1, d1=5, i=2, f2=4\\) .*" "continue to call2g"] {
	return
    }

    # Continue; should stop at call2h and print actual arguments.
    if [gdb_test "cont" ".* call2h \\(d2=5, c=97 'a', f1=4, s=1, d1=5, i=2, f2=4, l=3\\) .*" "continue to call2h"] {
	return
    }

    # monitor only allows 8 breakpoints; w89k board allows 10, so
    # break them up into two groups.
    delete_breakpoints
    send "break call2i\n" ; expect -re ".*$prompt $"

    # Continue; should stop at call2i and print actual arguments.
    if [gdb_test "cont" ".* call2i \\(c1=97 'a', f1=4, c2=97 'a', c3=97 'a', d1=5, c4=97 'a', c5=97 'a', c6=97 'a', f2=4, s=1, c7=97 'a', d2=5\\) .*" "continue to call2i"] {
	return
    }
}

#
# Locate actual args; dereference pointers to ints and floats.
#

proc pointer_args {} {
    global prompt
    global hex
    global det_file

    delete_breakpoints

    send "break call3a\n" ; expect -re ".*$prompt $"
    send "break call3b\n" ; expect -re ".*$prompt $"
    send "break call3c\n" ; expect -re ".*$prompt $"

    # Run; should stop at call3a and print actual arguments.
    # Try dereferencing the arguments.

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    gdb_run_cmd
    expect {
	-re ".* call3a \\(cp=$hex \"a\", sp=$hex, ip=$hex, lp=$hex\\) .*$prompt $" { pass "run to call3a" }
	-re "$prompt $" { fail "run to call3a" ; return }
	timeout { fail "(timeout) run to call3a" ; return }
    }

    gdb_test "print *cp" ".* = 97 'a'"
    gdb_test "print *sp" ".* = 1"
    gdb_test "print *ip" ".* = 2"
    gdb_test "print *lp" ".* = 3"

    # Continue; should stop at call3b and print actual arguments.
    # Try dereferencing the arguments.
    if [gdb_test "cont" ".* call3b \\(ucp=$hex \"b\", usp=$hex, uip=$hex, ulp=$hex\\) .*" "continue to call3b"] {
	return
    }

    gdb_test "print *ucp" ".* = 98 'b'"
    gdb_test "print *usp" ".* = 6"
    gdb_test "print *uip" ".* = 7"
    gdb_test "print *ulp" ".* = 8"

    # Continue; should stop at call3c and print actual arguments.
    # Try dereferencing the arguments.
    if [gdb_test "cont" ".* call3c \\(fp=$hex, dp=$hex\\) .*" "continue to call3c"] {
	return
    }

    gdb_test "print *fp" ".* = 4"
    gdb_test "print *dp" ".* = 5"

    pass "locate actual args, pointer types"
}

#
# Locate actual args; structures and unions passed by reference.
#

proc structs_by_reference {} {
    global prompt
    global hex
    global det_file

    delete_breakpoints

    send "break call4a\n" ; expect -re ".*$prompt $"
    send "break call4b\n" ; expect -re ".*$prompt $"

    # Run; should stop at call4a and print actual arguments.
    # Try dereferencing the arguments.

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    gdb_run_cmd
    expect {
	-re ".* call4a \\(stp=$hex\\) .*$prompt $" {
	    pass "run to call4a"
	}
	-re "$prompt $" { fail "run to call4a" ; return }
	timeout { fail "(timeout) run to call4a" ; return }
    }

    gdb_test "print *stp" ".* = \{s1 = 101, s2 = 102\}"

    # Continue; should stop at call4b and print actual arguments.
    # Try dereferencing the arguments.

    gdb_test "cont" ".* call4b \\(unp=$hex\\) .*" "continue to call4b"

    # sizeof int != sizeof long on h8300
    setup_xfail "h8300*-*-*"
    gdb_test "print *unp" ".* = \{u1 = 1, u2 = 1\}"

    pass "locate actual args, structs/unions passed by reference"
}

#
# Locate actual args; structures and unions passed by value.
#

proc structs_by_value {} {
    global prompt
    global hex
    global det_file

    delete_breakpoints

    send "break call5a\n" ; expect -re ".*$prompt $"
    send "break call5b\n" ; expect -re ".*$prompt $"

    # Run; should stop at call5a and print actual arguments.
    # Try dereferencing the arguments.

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    gdb_run_cmd
    expect {
	-re ".* call5a \\(st=\{s1 = 101, s2 = 102\}\\) .*$prompt $" {
	    pass "run to call5a"
	}
	-re "$prompt $" { fail "run to call5a" ; return }
	timeout { fail "(timeout) run to call5a" ; return }
    }

    gdb_test "print st" ".* = \{s1 = 101, s2 = 102\}"

    # Continue; should stop at call5b and print actual arguments.
    # Try dereferencing the arguments.
    # sizeof int != sizeof long on h8300
    setup_xfail "h8300*-*-*"
    gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 2\}\\) .*" \
	"continue to call5b"

    # sizeof int != sizeof long on h8300
    setup_xfail "h8300*-*-*"
    gdb_test "print un" ".* = \{u1 = 2, u2 = 2\}"
}

#
# Locate actual args; discard, shuffle, and call
#

proc discard_and_shuffle {} {
    global prompt
    global hex
    global decimal
    global det_file
    global gcc_compiled

    delete_breakpoints

    send "break call6a\n" ; expect -re ".*$prompt $"
    send "break call6b\n" ; expect -re ".*$prompt $"
    send "break call6c\n" ; expect -re ".*$prompt $"
    send "break call6d\n" ; expect -re ".*$prompt $"
    send "break call6e\n" ; expect -re ".*$prompt $"
    send "break call6f\n" ; expect -re ".*$prompt $"
    send "break call6g\n" ; expect -re ".*$prompt $"
    send "break call6h\n" ; expect -re ".*$prompt $"

    # Run; should stop at call6a and print actual arguments.
    # Print backtrace.

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    gdb_run_cmd
    expect {
	-re ".*Breakpoint $decimal, call6a .*$prompt $" { pass "run to call6a" }
	-re "$prompt $" { fail "run to call6a" ; return }
	timeout { fail "(timeout) run to call6a" ; return }
    }

    setup_xfail "rs6000-*-*"
    if {!$gcc_compiled} then { setup_xfail "mips-sgi-irix5*" }
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6a" }
	-re "$prompt $" { fail "backtrace from call6a" ; return }
	timeout { fail "(timeout) backtrace from call6a" ; return }
    }

    # Continue; should stop at call6b and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6b .*$prompt $" { pass "continue to call6b" }
	-re "$prompt $" { fail "continue to call6b" ; return }
	timeout { fail "(timeout) continue to call6b" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n]+
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6b" }
	-re "$prompt $" { fail "backtrace from call6b" ; return }
	timeout { fail "(timeout) backtrace from call6b" ; return }
    }

    # Continue; should stop at call6c and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6c .*$prompt $" { pass "continue to call6c" }
	-re "$prompt $" { fail "continue to call6c" ; return }
	timeout { fail "(timeout) continue to call6c" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6c" }
	-re "$prompt $" { fail "backtrace from call6c" ; return }
	timeout { fail "(timeout) backtrace from call6c" ; return }
    }

    # Continue; should stop at call6d and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6d .*$prompt $" { pass "continue to call6d" }
	-re "$prompt $" { fail "continue to call6d" ; return }
	timeout { fail "(timeout) continue to call6d" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6d" }
	-re "$prompt $" { fail "backtrace from call6d" ; return }
	timeout { fail "(timeout) backtrace from call6d" ; return }
    }

    # Continue; should stop at call6e and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6e .*$prompt $" { pass "continue to call6e" }
	-re "$prompt $" { fail "continue to call6e" ; return }
	timeout { fail "(timeout) continue to call6e" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6e" }
	-re "$prompt $" { fail "backtrace from call6e" ; return }
	timeout { fail "(timeout) backtrace from call6e" ; return }
    }

    # Continue; should stop at call6f and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6f .*$prompt $" { pass "continue to call6f" }
	-re "$prompt $" { fail "continue to call6f" ; return }
	timeout { fail "(timeout) continue to call6f" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6f" }
	-re "$prompt $" { fail "backtrace from call6f" ; return }
	timeout { fail "(timeout) backtrace from call6f" ; return }
    }

    # Continue; should stop at call6g and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6g .*$prompt $" { pass "continue to call6g" }
	-re "$prompt $" { fail "continue to call6g" ; return }
	timeout { fail "(timeout) continue to call6g" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6g" }
	-re "$prompt $" { fail "backtrace from call6g" ; return }
	timeout { fail "(timeout) backtrace from call6g" ; return }
    }

    # Continue; should stop at call6h and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6h .*$prompt $" { pass "continue to call6h" }
	-re "$prompt $" { fail "continue to call6h" ; return }
	timeout { fail "(timeout) continue to call6h" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6h \\(us=6, ui=7, ul=8\\) .*\r
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6h" }
	-re "$prompt $" { fail "backtrace from call6h" ; return }
	timeout { fail "(timeout) backtrace from call6h" ; return }
    }

    # monitor only allows 8 breakpoints; w89k board allows 10, so
    # break them up into two groups.
    delete_breakpoints
    send "break call6i\n" ; expect -re ".*$prompt $"
    send "break call6j\n" ; expect -re ".*$prompt $"
    send "break call6k\n" ; expect -re ".*$prompt $"

    # Continue; should stop at call6i and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6i .*$prompt $" { pass "continue to call6i" }
	-re "$prompt $" { fail "continue to call6i" ; return }
	timeout { fail "(timeout) continue to call6i" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6i \\(ui=7, ul=8\\) .*\r
.* call6h \\(us=6, ui=7, ul=8\\) .*\r
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6i" }
	-re "$prompt $" { fail "backtrace from call6i" ; return }
	timeout { fail "(timeout) backtrace from call6i" ; return }
    }

    # Continue; should stop at call6j and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6j .*$prompt $" { pass "continue to call6j" }
	-re "$prompt $" { fail "continue to call6j" ; return }
	timeout { fail "(timeout) continue to call6j" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6j \\(ul=8\\) .*\r
.* call6i \\(ui=7, ul=8\\) .*\r
.* call6h \\(us=6, ui=7, ul=8\\) .*\r
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6j" }
	-re "$prompt $" { fail "backtrace from call6j" ; return }
	timeout { fail "(timeout) backtrace from call6j" ; return }
    }

    # Continue; should stop at call6k and print actual arguments.
    # Print backtrace.
    # This fails on i960-*-vxworks because gdb gets confused by
    # breakpoints on adjacent instructions.
    setup_xfail "i960-*-vxworks" 1786
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6k .*$prompt $" {
	    pass "continue to call6k"
	}
	-re "$prompt $" { fail "continue to call6k"; return }
	timeout { fail "(timeout) continue to call6k"; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6k \\(\\) .*\r
.* call6j \\(ul=8\\) .*\r
.* call6i \\(ui=7, ul=8\\) .*\r
.* call6h \\(us=6, ui=7, ul=8\\) .*\r
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6k" }
	-re "$prompt $" { fail "backtrace from call6k" ; return }
	timeout { fail "(timeout) backtrace from call6k" ; return }
    }
}

#
# Locate actual args; shuffle round robin and call
#

proc shuffle_round_robin {} {
    global prompt
    global hex
    global decimal
    global det_file
    global gcc_compiled

    delete_breakpoints

    send "break call7a\n" ; expect -re ".*$prompt $"
    send "break call7b\n" ; expect -re ".*$prompt $"
    send "break call7c\n" ; expect -re ".*$prompt $"
    send "break call7d\n" ; expect -re ".*$prompt $"
    send "break call7e\n" ; expect -re ".*$prompt $"
    send "break call7f\n" ; expect -re ".*$prompt $"
    send "break call7g\n" ; expect -re ".*$prompt $"
    send "break call7h\n" ; expect -re ".*$prompt $"

    # Run; should stop at call7a and print actual arguments.
    # Print backtrace.

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    gdb_run_cmd
    expect {
	-re ".*Breakpoint $decimal, call7a .*$prompt $" {
	    pass "run to call7a"
	}
	-re "$prompt $" { fail "run to call7a" ; return }
	timeout { fail "(timeout) run to call7a" ; return }
    }

    setup_xfail "i960-*-*" 1813
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" "mips-sgi-irix5*" }
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7a" }
	-re "$prompt $" { fail "backtrace from call7a" ; return }
	timeout { fail "(timeout) backtrace from call7a" ; return }
    }

    # Continue; should stop at call7b and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7b .*$prompt $" { pass "continue to call7b" }
	-re "$prompt $" { fail "continue to call7b" ; return }
	timeout { fail "(timeout) continue to call7b" ; return }
    }

    if {$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7b" }
	-re "$prompt $" { fail "backtrace from call7b" ; return }
	timeout { fail "(timeout) backtrace from call7b" ; return }
    }

    # Continue; should stop at call7c and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7c .*$prompt $" { pass "continue to call7c" }
	-re "$prompt $" { fail "continue to call7c" ; return }
	timeout { fail "(timeout) continue to call7c" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7c" }
	-re "$prompt $" { fail "backtrace from call7c" ; return }
	timeout { fail "(timeout) backtrace from call7c" ; return }
    }

    # Continue; should stop at call7d and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7d .*$prompt $" { pass "continue to call7d" }
	-re "$prompt $" { fail "continue to call7d" ; return }
	timeout { fail "(timeout) continue to call7d" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7d" }
	-re "$prompt $" { fail "backtrace from call7d" ; return }
	timeout { fail "(timeout) backtrace from call7d" ; return }
    }

    # Continue; should stop at call7e and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re "Breakpoint $decimal, call7e .*$prompt $" { pass "continue to call7e" }
	-re "$prompt $" { fail "continue to call7e" ; return }
	timeout { fail "(timeout) continue to call7e" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7e" }
	-re "$prompt $" { fail "backtrace from call7e" ; return }
	timeout { fail "(timeout) backtrace from call7e" ; return }
    }

    # Continue; should stop at call7f and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7f .*$prompt $" { pass "continue to call7f" }
	-re "$prompt $" { fail "continue to call7f" ; return }
	timeout { fail "(timeout) continue to call7f" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7f" }
	-re "$prompt $" { fail "backtrace from call7f" ; return }
	timeout { fail "(timeout) backtrace from call7f" ; return }
    }

    # Continue; should stop at call7g and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7g .*$prompt $" { pass "continue to call7g" }
	-re "$prompt $" { fail "continue to call7g" ; return }
	timeout { fail "(timeout) continue to call7g" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7g" }
	-re "$prompt $" { fail "backtrace from call7g" ; return }
	timeout { fail "(timeout) backtrace from call7g" ; return }
    }

    # Continue; should stop at call7h and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7h .*$prompt $" { pass "continue to call7h" }
	-re "$prompt $" { fail "continue to call7h" ; return }
	timeout { fail "(timeout) continue to call7h" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) .*\r
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7h" }
	-re "$prompt $" { fail "backtrace from call7h" ; return }
	timeout { fail "(timeout) backtrace from call7h" ; return }
    }

    # monitor only allows 8 breakpoints; w89k board allows 10, so
    # break them up into two groups.
    delete_breakpoints
    send "break call7i\n" ; expect -re ".*$prompt $"
    send "break call7j\n" ; expect -re ".*$prompt $"
    send "break call7k\n" ; expect -re ".*$prompt $"

    # Continue; should stop at call7i and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7i .*$prompt $" { pass "continue to call7i" }
	-re "$prompt $" { fail "continue to call7i" ; return }
	timeout { fail "(timeout) continue to call7i" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) .*\r
.* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) .*\r
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7i" }
	-re "$prompt $" { fail "backtrace from call7i" ; return }
	timeout { fail "(timeout) backtrace from call7i" ; return }
    }

    # Continue; should stop at call7j and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7j .*$prompt $" { pass "continue to call7j" }
	-re "$prompt $" { fail "continue to call7j" ; return }
	timeout { fail "(timeout) continue to call7j" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7j \\(ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8\\) .*\r
.* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) .*\r
.* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) .*\r
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7j" }
	-re "$prompt $" { fail "backtrace from call7j" ; return }
	timeout { fail "(timeout) backtrace from call7j" ; return }
    }

    # Continue; should stop at call7k and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7k .*$prompt $" { pass "continue to call7k" }
	-re "$prompt $" { fail "continue to call7k" ; return }
	timeout { fail "(timeout) continue to call7k" ; return }
    }

    if {!$gcc_compiled} then { setup_xfail "mips-sgi-irix*" }
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7k \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* call7j \\(ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8\\) .*\r
.* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) .*\r
.* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) .*\r
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7k" }
	-re "$prompt $" { fail "backtrace from call7k" ; return }
	timeout { fail "(timeout) backtrace from call7k" ; return }
    }
}

#
# Locate actual args; recursive passing of structs by value
#

proc recursive_structs_by_value {} {
    global prompt
    global hex
    global decimal
    global det_file

    delete_breakpoints

    send "break hitbottom\n" ; expect -re ".*$prompt $"

    # Run; should stop at hitbottom and print actual arguments.
    # Print backtrace.
    gdb_run_cmd
    expect {
	-re ".*Breakpoint $decimal, hitbottom .*$prompt $" { pass "run to hitbottom" }
	-re "$prompt $" { fail "run to hitbottom" ; return }
	timeout { fail "(timeout) run to hitbottom" ; return }
    }

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* hitbottom \\(\\) .*\r
.* recurse \\(a=\{s = 0, i = 0, l = 0\}, depth=0\\) .*\r
.* recurse \\(a=\{s = 1, i = 1, l = 1\}, depth=1\\) .*\r
.* recurse \\(a=\{s = 2, i = 2, l = 2\}, depth=2\\) .*\r
.* recurse \\(a=\{s = 3, i = 3, l = 3\}, depth=3\\) .*\r
.* recurse \\(a=\{s = 4, i = 4, l = 4\}, depth=4\\) .*\r
.* test_struct_args \\(\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "recursive passing of structs by value" }
	-re "$prompt $" { fail "recursive passing of structs by value" ; return }
	timeout { fail "(timeout) recursive passing of structs by value" ; return }
    }
}

proc funcargs_reload { } {
    global objdir
    global subdir
    global binfile
    global srcdir

    if [istarget "mips-idt-*"] then {
	# Restart because IDT/SIM runs out of file descriptors.
	gdb_exit
	gdb_start
	gdb_reinitialize_dir $srcdir/$subdir
	gdb_load ${binfile}
    }
}

#
# Test for accessing local stack variables in functions which call alloca
#
proc localvars_after_alloca { } {
    global prompt
    global hex
    global decimal
    global gcc_compiled

    if { ! [ runto localvars_after_alloca ] } then { return 0 }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print c" " = 97 'a'" "print c after runto localvars_after_alloca"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print s" " = 1" "print s after runto localvars_after_alloca"
    gdb_test "print i" " = 2" "print i after runto localvars_after_alloca"
    gdb_test "print l" " = 3" "print l after runto localvars_after_alloca"

    send "next\n"
    expect {
	-re ".*$prompt $" { pass "next in localvars_after_alloca()" }
	timeout { fail "(timeout) next in localvars_after_alloca()" ; return }
    }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    gdb_test "print c" " = 97 'a'" "print c in localvars_after_alloca"
    gdb_test "print s" " = 1" "print s in localvars_after_alloca"
    gdb_test "print i" " = 2" "print i in localvars_after_alloca"
    gdb_test "print l" " = 3" "print l in localvars_after_alloca"

    gdb_test "backtrace 8" "#0.*localvars_after_alloca \\(c=97 'a', s=1, i=2, l=3\\).*#1.*main.*" "backtrace after alloca"
}

proc call_after_alloca { } {
    global prompt
    global hex
    global decimal
    global gcc_compiled

    if { ! [ runto call_after_alloca_subr ] } then { return 0 }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print c" " = 97 'a'" "print c in call_after_alloca"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print s" " = 1" "print s in call_after_alloca"
    gdb_test "print i" " = 2" "print i in call_after_alloca"
    gdb_test "print l" " = 3" "print l in call_after_alloca"

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "backtrace 8" "#0.*call_after_alloca_subr \\(c=97 'a', s=1, i=2, l=3, uc=98 'b', us=11, ui=12, ul=13\\).*#1.*call_after_alloca \\(c=97 'a', s=1, i=2, l=3\\).*#2.*main.*" "backtrace from call_after_alloca_subr"
}

#
# Test for accessing local stack variables, backtraces, finish,
# and finally stepping into indirect calls.  The point is that on the PA
# these use a funky `dyncall' mechanism which GDB needs to know about.
#
proc localvars_in_indirect_call { } {
    global prompt
    global hex
    global decimal
    global gcc_compiled

    # Can not use "runto call0a" as call0a is called several times
    # during single run.  Instead stop in a marker function and
    # take control from there.
    if { ! [ runto marker_indirect_call ] } then { return 0 }

    # break on the next call to call0a, then delete all the breakpoints
    # and start testing.
    gdb_test "break call0a" "Breakpoint .*" \
	"break call0a in localvars_in_indirect_call"
    gdb_test "continue" "call0a .*" "continue in localvars_in_indirect_call"
    delete_breakpoints
    
    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print c" " = 97 'a'" "print c in localvars_in_indirect_call"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print s" " = 1" "print s in localvars_in_indirect_call"
    gdb_test "print i" " = 2" "print i in localvars_in_indirect_call"
    gdb_test "print l" " = 3" "print l in localvars_in_indirect_call"

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "backtrace 8" \
	"#0.*call0a \\(c=97 'a', s=1, i=2, l=3\\).*#1.*main.*" \
	"backtrace in indirectly called function"

    # 
    # "finish" brings us back to main.  We then will try to step through
    # the second indirect call.  
    # On some targets (e.g. m68k) gdb will stop from the finish in midline
    # of the first indirect call. This is due to stack adjustment instructions
    # after the indirect call. In these cases we will step till we hit the
    # second indirect call.
    #

    send "finish\n"
    expect {
	-re "\\(\\*pointer_to_call0a\\) \\(c, s, i, l\\);.*First.*$prompt $" {
	    send "step\n"
	    exp_continue
	}
	-re "\\(\\*pointer_to_call0a\\) \\(c, s, i, l\\);.*Second.*$prompt $" {
	    pass "finish from indirectly called function"
	}
	-re ".*$prompt $" {
	    fail "finish from indirectly called function"
	    return
	}
	default { fail "finish from indirectly called function" ; return }
    }

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "step" "call0a \\(c=97 'a', s=1, i=2, l=3\\).*" \
	"stepping into indirectly called function"
}

# Start with a fresh gdb.
#
# Test for stepping into indirect calls which may have trampolines (possibly
# cascaded) on both the call path and the return path.
# to handle trampolines.
#
proc test_stepping_over_trampolines { } {
    global prompt
    global hex
    global decimal

    # Stop in a marker function and take control from there.
    if { ! [ runto marker_call_with_trampolines ] } then { return 0 }

    # Cater for gdb stopping in midline, see comment for finish above.
    send "finish\n"
    expect {
	-re "marker_call_with_trampolines ..;.*$prompt $" {
	    send "step\n"
	    exp_continue
	}
	-re "pointer_to_call_with_trampolines.*$prompt $" {
	    pass "finish from marker_call_with_trampolines"
	}
	-re ".*$prompt $" {
	    fail "finish from marker_call_with_trampolines"
	}
	default { fail "finish from marker_call_with_trampolines" ; return 0 }
    }

    # Try to step into the target function.
    gdb_test "step" "call_with_trampolines \\(d1=5\\).*" \
	"stepping into function called with trampolines"

    # Make we can backtrace and the argument looks correct.  */
    gdb_test "backtrace 8" "#0.*call_with_trampolines \\(d1=5\\).*1.*main.*" \
	"backtrace through call with trampolines"

    # Make sure we can get back to main.
    # Stepping back to main might stop again after the return statement
    # or immediately transfer control back to main if optimizations
    # are performed.
    send "step\n"
    expect {
	-re "main .* at.*$prompt $" {
	    pass "stepping back to main from function called with trampolines" ;
	    return 1
	}
	-re "\}.*End of call_with_trampolines.*$prompt $" {
	    send "step\n"
	    exp_continue
	}
	-re ".*$prompt $" {
	    fail "stepping back to main from function called with trampolines"
	}
	default { fail "stepping back to main from function called with trampolines" ; return 0 }
    }
}

# Start with a fresh gdb.

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

integral_args
funcargs_reload
unsigned_integral_args
funcargs_reload
float_and_integral_args
funcargs_reload
pointer_args
funcargs_reload
structs_by_reference
funcargs_reload
structs_by_value
funcargs_reload
discard_and_shuffle
funcargs_reload
shuffle_round_robin
funcargs_reload
recursive_structs_by_value
funcargs_reload
localvars_after_alloca
funcargs_reload
call_after_alloca
funcargs_reload
localvars_in_indirect_call
funcargs_reload
test_stepping_over_trampolines
@
