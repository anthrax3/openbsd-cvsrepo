head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.52
	OPENBSD_6_1_BASE:1.1.1.2
	OPENBSD_6_0:1.1.1.2.0.48
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.44
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.46
	OPENBSD_5_8_BASE:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.38
	OPENBSD_5_7_BASE:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.42
	OPENBSD_5_6_BASE:1.1.1.2
	OPENBSD_5_5:1.1.1.2.0.40
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.36
	OPENBSD_5_4_BASE:1.1.1.2
	OPENBSD_5_3:1.1.1.2.0.34
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.32
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.30
	OPENBSD_5_0:1.1.1.2.0.28
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.26
	OPENBSD_4_9_BASE:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.24
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.20
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.22
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.18
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.16
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.14
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.12
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.10
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.8
	OPENBSD_4_0_BASE:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.6
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.4
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.2
	OPENBSD_3_7_BASE:1.1.1.2
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.1.1.1.0.2
	OPENBSD_3_6_BASE:1.1.1.1
	GDB_6_1:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2004.05.21.19.17.04;	author kettenis;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.05.21.19.17.04;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.16.05;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@# Copyright 2002, 2003 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@gnu.org

if $tracelevel {
    strace $tracelevel
}

#
# test running programs
#
set prms_id 0
set bug_id 0

set testfile "store"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}
if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

if [get_compiler_info ${binfile}] {
    return -1;
}

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

#
# set it up at a breakpoint so we can play with the variable values
#

if ![runto_main] then {
    perror "couldn't run to breakpoint"
    continue
}

#

proc check_set { t l r new add } {
    global gdb_prompt
    gdb_test "tbreak wack_${t}"
    gdb_test "continue" "register ${t} l = u, r = v;" "continue to wack_${t}"
    gdb_test "next" "l = add_${t} .l, r.;" "next ${t}"
    gdb_test "print l" " = ${l}" "print old l - ${t}"
    gdb_test "print r" " = ${r}" "print old r - ${t}"
    gdb_test "set variable l = 4"
    gdb_test "print l" " = ${new}" "print new l - ${t}"
    gdb_test "next" "return l \\+ r;"
    gdb_test "print l" " = ${add}" "print add  - ${t}"
}

check_set "charest" "-1 .*" "-2 .*" "4 ..004." "2 ..002."
check_set "short" "-1" "-2" "4" "2"
check_set "int" "-1" "-2" "4" "2"
check_set "long" "-1" "-2" "4" "2"
check_set "longest" "-1" "-2" "4" "2"
check_set "float" "-1" "-2" "4" "2"
check_set "double" "-1" "-2" "4" "2"
check_set "doublest" "-1" "-2" "4" "2"

#

proc up_set { t l r new } {
    global gdb_prompt
    gdb_test "tbreak add_${t}"
    gdb_test "continue" "return u . v;" "continue to add_${t}"
    gdb_test "up" "l = add_${t} .l, r.;" "up ${t}"
    gdb_test "print l" " = ${l}" "up print old l - ${t}"
    gdb_test "print r" " = ${r}" "up print old r - ${t}"
    gdb_test "set variable l = 4"
    gdb_test "print l" " = ${new}" "up print new l - ${t}"
}

up_set "charest" "-1 .*" "-2 .*" "4 ..004."
up_set "short" "-1" "-2" "4"
up_set "int" "-1" "-2" "4"
up_set "long" "-1" "-2" "4"
up_set "longest" "-1" "-2" "4"
up_set "float" "-1" "-2" "4"
up_set "double" "-1" "-2" "4"
up_set "doublest" "-1" "-2" "4"

#

proc check_struct { t old new } {
    global gdb_prompt
    gdb_test "tbreak wack_struct_${t}"
    gdb_test "continue" "int i; register struct s_${t} u = z_${t};" \
	    "continue set struct ${t}"
    gdb_test "next 2" "add_struct_${t} .u.;"
    gdb_test "print u" " = ${old}" "old check struct ${t}"
    gdb_test "set variable u = s_${t}"
    gdb_test "print u" " = ${new}" "new check struct ${t}"
}

check_struct "1" "{s = \\{0}}" "{s = \\{1}}"
check_struct "2" "{s = \\{0, 0}}" "{s = \\{1, 2}}"
check_struct "3" "{s = \\{0, 0, 0}}" "{s = \\{1, 2, 3}}"
check_struct "4" "{s = \\{0, 0, 0, 0}}" "{s = \\{1, 2, 3, 4}}"

proc up_struct { t old new } {
    global gdb_prompt
    gdb_test "tbreak add_struct_${t}"
    gdb_test "continue" "for .i = 0; i < sizeof .s. / sizeof .s.s.0..; i..." \
	    "continue up struct ${t}"
    gdb_test "up" "u = add_struct_${t} .u.;" "up struct ${t}"
    gdb_test "print u" " = ${old}" "old up struct ${t}"
    gdb_test "set variable u = s_${t}"
    gdb_test "print u" " = ${new}" "new up struct ${t}"
}

up_struct "1" "{s = \\{0}}" "{s = \\{1}}"
up_struct "2" "{s = \\{0, 0}}" "{s = \\{1, 2}}"
up_struct "3" "{s = \\{0, 0, 0}}" "{s = \\{1, 2, 3}}"
up_struct "4" "{s = \\{0, 0, 0, 0}}" "{s = \\{1, 2, 3, 4}}"

#

proc check_field { t } {
    global gdb_prompt
    gdb_test "tbreak wack_field_${t}"
    gdb_test "continue" "register struct f_${t} u = f_${t};" \
	    "continue field ${t}"

    # Match either the return statement, or the line immediatly after
    # it.  The compiler can end up merging the return statement into
    # the return instruction.
    gdb_test "next" "(return u;|\})" "next field ${t}"

    gdb_test "print u" " = {i = 1, j = 1, k = 1}" "old field ${t}"
    gdb_test "set variable u = F_${t}"
    gdb_test "print u" " = {i = 0, j = 0, k = 0}" "new field ${t}"

    gdb_test "set variable u = F_${t}, u.i = f_${t}.i"
    gdb_test "print u" " = {i = 1, j = 0, k = 0}" "f_${t}.i"

    gdb_test "set variable u = F_${t}, u.j = f_${t}.j"
    gdb_test "print u" " = {i = 0, j = 1, k = 0}" "f_${t}.j"

    gdb_test "set variable u = F_${t}, u.k = f_${t}.k"
    gdb_test "print u" " = {i = 0, j = 0, k = 1}" "f_${t}.k"

    gdb_test "set variable u = f_${t}, u.i = F_${t}.i"
    gdb_test "print u" " = {i = 0, j = 1, k = 1}" "F_${t}.i"

    gdb_test "set variable u = f_${t}, u.j = F_${t}.j"
    gdb_test "print u" " = {i = 1, j = 0, k = 1}" "F_${t}.j"

    gdb_test "set variable u = f_${t}, u.k = F_${t}.k"
    gdb_test "print u" " = {i = 1, j = 1, k = 0}" "F_${t}.k"

}

check_field 1
check_field 2
check_field 3
check_field 4

#

# WANTED: A fairly portable way of convincing the compiler to split a
# value across memory and registers.

@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d1 1
a1 3
# This testcase is part of GDB, the GNU debugger.

# Copyright 2002, 2003, 2004 Free Software Foundation, Inc.
d17 3
d34 1
a34 1
    gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
d58 1
a58 1
    set prefix "var ${t} l"
d60 8
a67 16
    gdb_test "continue" "register ${t} l = u, r = v;" \
	"continue to wack_${t}"
    gdb_test "next" "l = add_${t} .l, r.;" \
	"${prefix}; next ${t}"
    gdb_test "print l" " = ${l}" \
	"${prefix}; print old l, expecting ${l}"
    gdb_test "print r" " = ${r}" \
	"${prefix}; print old r, expecting ${r}"
    gdb_test "set variable l = 4" "" \
	"${prefix}; setting l to 4"
    gdb_test "print l" " = ${new}" \
	"${prefix}; print new l, expecting ${l}"
    gdb_test "next" "return l \\+ r;" \
	"${prefix}; next over add call"
    gdb_test "print l" " = ${add}" \
	"${prefix}; print incremented l, expecting ${add}"
d82 1
a82 1
    set prefix "upvar ${t} l"
d84 6
a89 12
    gdb_test "continue" "return u . v;" \
	"continue to add_${t}"
    gdb_test "up" "l = add_${t} .l, r.;" \
	"${prefix}; up"
    gdb_test "print l" " = ${l}" \
	"${prefix}; print old l, expecting ${l}"
    gdb_test "print r" " = ${r}" \
	"${prefix}; print old r, expecting ${r}"
    gdb_test "set variable l = 4" "" \
	"${prefix}; set l to 4"
    gdb_test "print l" " = ${new}" \
	"${prefix}; print new l, expecting ${new}"
d104 1
a104 1
    set prefix "var struct ${t} u"
d107 5
a111 9
	"continue to wack_struct_${t}"
    gdb_test "next 2" "add_struct_${t} .u.;" \
	"${prefix}; next to add_struct_${t} call"
    gdb_test "print u" " = ${old}" \
	"${prefix}; print old u, expecting ${old}"
    gdb_test "set variable u = s_${t}" "" \
	"${prefix}; set u to s_${t}"
    gdb_test "print u" " = ${new}" \
	"${prefix}; print new u, expecting ${new}"
d120 1
a120 1
    set prefix "up struct ${t} u"
d123 5
a127 9
	"continue to add_struct_${t}"
    gdb_test "up" "u = add_struct_${t} .u.;" \
	"${prefix}; up"
    gdb_test "print u" " = ${old}" \
	"${prefix}; print old u, expecting ${old}"
    gdb_test "set variable u = s_${t}" "" \
	"${prefix}; set u to s_${t}"
    gdb_test "print u" " = ${new}" \
	"${prefix}; print new u, expecting ${new}"
@

