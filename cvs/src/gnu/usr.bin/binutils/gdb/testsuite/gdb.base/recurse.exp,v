head	1.3;
access;
symbols
	OPENBSD_6_0:1.3.0.50
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.46
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.48
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.40
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.44
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.42
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.38
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.36
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.34
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.32
	OPENBSD_5_0:1.3.0.30
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.28
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.26
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.22
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.24
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.20
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.18
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.16
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.14
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.12
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.10
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	GDB_6_3:1.1.1.1
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2004.05.21.20.23.39;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.50.16;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.35.36;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.16.50;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.35.36;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@# Copyright 1992, 1994, 1995, 1996, 1997, 1999, 2000
# Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Jeff Law. (law@@cs.utah.edu)

if $tracelevel then {
    strace $tracelevel
}

set prms_id 0
set bug_id 0

set testfile "recurse"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}
if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

# Start with a fresh gdb.

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

proc recurse_tests {} {

    # Disable hardware watchpoints if necessary.
    if [target_info exists gdb,no_hardware_watchpoints] {
	gdb_test "set can-use-hw-watchpoints 0" "" ""
    }

    if [runto recurse] then {
	# First we need to step over the assignment of b, so it has a known
	# value.
	gdb_test "next" "if \\(a == 1\\)" "next over b = 0 in first instance"
	gdb_test "watch b" ".*\[Ww\]atchpoint \[0-9]*: b" \
	    "set first instance watchpoint"

	# Continue until initial set of b.
	if [gdb_test "continue" \
	    "Continuing.*\[Ww\]atchpoint.*: b.*Old value = 0.*New value = 10.*" \
	    "continue to first instance watchpoint, first time"] then {
	    gdb_suppress_tests;
	}

	# Continue inward for a few iterations
	gdb_test "continue" "Breakpoint.* recurse \\(a=9\\).*" \
	    "continue to recurse (a = 9)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=8\\).*" \
	    "continue to recurse (a = 8)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=7\\).*" \
	    "continue to recurse (a = 7)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=6\\).*" \
	    "continue to recurse (a = 6)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=5\\).*" \
	    "continue to recurse (a = 5)"

	# Put a watchpoint on another instance of b
	# First we need to step over the assignment of b, so it has a known
	# value.
	gdb_test "next" "if \\(a == 1\\)" "next over b = 0 in second instance"
	gdb_test "watch b" ".*\[Ww\]atchpoint \[0-9]*: b" \
	    "set second instance watchpoint"

	# Continue until initial set of b (second instance).
	if [gdb_test "continue" \
	    "Continuing.*\[Ww\]atchpoint.*: b.*Old value = 0.*New value = 5.*"\
	    "continue to second instance watchpoint, first time"] then {
	gdb_suppress_tests;
	}

	# Continue inward for a few iterations
	gdb_test "continue" "Breakpoint.* recurse \\(a=4\\).*" \
	    "continue to recurse (a = 4)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=3\\).*" \
	    "continue to recurse (a = 3)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=2\\).*" \
	    "continue to recurse (a = 2)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=1\\).*" \
	    "continue to recurse (a = 1)"

	# Continue until second set of b (second instance).
	if [gdb_test "continue" \
	    "Continuing.*\[Ww\]atchpoint.*: b.*Old value = 5.*New value = 120.*return.*" \
	    "continue to second instance watchpoint, second time"] then { 
	    gdb_suppress_tests;
	}

	# Continue again.  We should have a watchpoint go out of scope now
	if [gdb_test "continue" \
	    "Continuing.*\[Ww\]atchpoint.*deleted.*recurse \\(a=6\\) .*" \
	    "second instance watchpoint deleted when leaving scope"] then {
	    gdb_suppress_tests;
	}

	# Continue until second set of b (first instance).
	# 24320 is allowed as the final value for b as that's the value
	# b would have on systems with 16bit integers.
	#
	# We could fix the test program to deal with this too.
	if [gdb_test "continue" \
	    "Continuing.*\[Ww\]atchpoint.*b.*Old value = 10.*New value = \(3628800|24320\).*return.*" \
	    "continue to first instance watchpoint, second time"] then {
	    gdb_suppress_tests
	}

	# Continue again.  We should have a watchpoint go out of scope now.
	#
	# The former version expected the test to return to main().
	# Now it expects the test to return to main or to stop in the
	# function's epilogue.
	# 
	# The problem is that gdb needs to (but doesn't) understand
	# function epilogues in the same way as for prologues.
	# 
	# If there is no hardware watchpoint (such as a x86 debug register),
	# then watchpoints are done "the hard way" by single-stepping the
	# target until the value of the watched variable changes.  If you
	# are single-stepping, you will eventually step into an epilogue.
	# When you do that, the "top" stack frame may become partially
	# deconstructed (as when you pop the frame pointer, for instance),
	# and from that point on, GDB can no longer make sense of the stack.
	# 
	# A test which stops in the epilogue is trying to determine when GDB
	# leaves the stack frame in which the watchpoint was created.  It does
	# this basically by watching for the frame pointer to change.  When
	# the frame pointer changes, the test expects to be back in main, but
	# instead it is still in the epilogue of the callee.
	if [gdb_test "continue" \
	    "Continuing.*\[Ww\]atchpoint.*deleted.*\(main \\(\\) \|21.*\}\).*" \
	    "first instance watchpoint deleted when leaving scope"] then {
	    gdb_suppress_tests;
	}
    }
    gdb_stop_suppressing_tests;
}

# Preserve the old timeout, and set a new one that should be
# sufficient to avoid timing out during this test.
set oldtimeout $timeout
set timeout [expr "$timeout + 60"]
verbose "Timeout is now $timeout seconds" 2

recurse_tests

# Restore the preserved old timeout value.
set timeout $oldtimeout
verbose "Timeout is now $timeout seconds" 2

@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d1 2
a2 1
# Copyright (C) 1992, 1996 Free Software Foundation, Inc.
d16 1
a16 1
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d33 2
a34 3
if  { [compile "${srcdir}/${subdir}/${srcfile} -g -o ${binfile}"] != "" } {
    perror "Couldn't compile ${srcfile}"
    return -1
d46 5
d62 1
a62 1
	    return
d88 1
a88 1
	    return
d105 1
a105 1
	    return
d112 1
a112 1
	    return
d116 4
d121 1
a121 1
	    "Continuing.*\[Ww\]atchpoint.*b.*Old value = 10.*New value = 3628800.*return.*" \
d123 1
a123 1
	    return
d126 22
a147 1
	# Continue again.  We should have a watchpoint go out of scope now
d149 1
a149 1
	    "Continuing.*\[Ww\]atchpoint.*deleted.*main \\(\\) .*" \
d151 1
a151 1
	    return
d154 1
d157 12
a168 16
# Only enabled for some targets merely because it has not been tested 
# elsewhere.
if {[istarget "sparc*-*-sunos4*"] || [istarget "hppa*-*-bsd*"]} then {

    # Preserve the old timeout, and set a new one that should be
    # sufficient to avoid timing out during this test.
    set oldtimeout $timeout
    set timeout [expr "$timeout + 60"]
    verbose "Timeout is now $timeout seconds" 2

    recurse_tests

    # Restore the preserved old timeout value.
    set timeout $oldtimeout
    verbose "Timeout is now $timeout seconds" 2
}
@


1.1
log
@file recurse.exp was initially added on branch CYGNUS.
@
text
@d1 141
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 168
# Copyright 1992, 1994, 1995, 1996, 1997, 1999, 2000
# Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Jeff Law. (law@@cs.utah.edu)

if $tracelevel then {
    strace $tracelevel
}

set prms_id 0
set bug_id 0

set testfile "recurse"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}
if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

# Start with a fresh gdb.

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

proc recurse_tests {} {

    # Disable hardware watchpoints if necessary.
    if [target_info exists gdb,no_hardware_watchpoints] {
	gdb_test "set can-use-hw-watchpoints 0" "" ""
    }

    if [runto recurse] then {
	# First we need to step over the assignment of b, so it has a known
	# value.
	gdb_test "next" "if \\(a == 1\\)" "next over b = 0 in first instance"
	gdb_test "watch b" ".*\[Ww\]atchpoint \[0-9]*: b" \
	    "set first instance watchpoint"

	# Continue until initial set of b.
	if [gdb_test "continue" \
	    "Continuing.*\[Ww\]atchpoint.*: b.*Old value = 0.*New value = 10.*" \
	    "continue to first instance watchpoint, first time"] then {
	    gdb_suppress_tests;
	}

	# Continue inward for a few iterations
	gdb_test "continue" "Breakpoint.* recurse \\(a=9\\).*" \
	    "continue to recurse (a = 9)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=8\\).*" \
	    "continue to recurse (a = 8)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=7\\).*" \
	    "continue to recurse (a = 7)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=6\\).*" \
	    "continue to recurse (a = 6)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=5\\).*" \
	    "continue to recurse (a = 5)"

	# Put a watchpoint on another instance of b
	# First we need to step over the assignment of b, so it has a known
	# value.
	gdb_test "next" "if \\(a == 1\\)" "next over b = 0 in second instance"
	gdb_test "watch b" ".*\[Ww\]atchpoint \[0-9]*: b" \
	    "set second instance watchpoint"

	# Continue until initial set of b (second instance).
	if [gdb_test "continue" \
	    "Continuing.*\[Ww\]atchpoint.*: b.*Old value = 0.*New value = 5.*"\
	    "continue to second instance watchpoint, first time"] then {
	gdb_suppress_tests;
	}

	# Continue inward for a few iterations
	gdb_test "continue" "Breakpoint.* recurse \\(a=4\\).*" \
	    "continue to recurse (a = 4)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=3\\).*" \
	    "continue to recurse (a = 3)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=2\\).*" \
	    "continue to recurse (a = 2)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=1\\).*" \
	    "continue to recurse (a = 1)"

	# Continue until second set of b (second instance).
	if [gdb_test "continue" \
	    "Continuing.*\[Ww\]atchpoint.*: b.*Old value = 5.*New value = 120.*return.*" \
	    "continue to second instance watchpoint, second time"] then { 
	    gdb_suppress_tests;
	}

	# Continue again.  We should have a watchpoint go out of scope now
	if [gdb_test "continue" \
	    "Continuing.*\[Ww\]atchpoint.*deleted.*recurse \\(a=6\\) .*" \
	    "second instance watchpoint deleted when leaving scope"] then {
	    gdb_suppress_tests;
	}

	# Continue until second set of b (first instance).
	# 24320 is allowed as the final value for b as that's the value
	# b would have on systems with 16bit integers.
	#
	# We could fix the test program to deal with this too.
	if [gdb_test "continue" \
	    "Continuing.*\[Ww\]atchpoint.*b.*Old value = 10.*New value = \(3628800|24320\).*return.*" \
	    "continue to first instance watchpoint, second time"] then {
	    gdb_suppress_tests
	}

	# Continue again.  We should have a watchpoint go out of scope now.
	#
	# The former version expected the test to return to main().
	# Now it expects the test to return to main or to stop in the
	# function's epilogue.
	# 
	# The problem is that gdb needs to (but doesn't) understand
	# function epilogues in the same way as for prologues.
	# 
	# If there is no hardware watchpoint (such as a x86 debug register),
	# then watchpoints are done "the hard way" by single-stepping the
	# target until the value of the watched variable changes.  If you
	# are single-stepping, you will eventually step into an epilogue.
	# When you do that, the "top" stack frame may become partially
	# deconstructed (as when you pop the frame pointer, for instance),
	# and from that point on, GDB can no longer make sense of the stack.
	# 
	# A test which stops in the epilogue is trying to determine when GDB
	# leaves the stack frame in which the watchpoint was created.  It does
	# this basically by watching for the frame pointer to change.  When
	# the frame pointer changes, the test expects to be back in main, but
	# instead it is still in the epilogue of the callee.
	if [gdb_test "continue" \
	    "Continuing.*\[Ww\]atchpoint.*deleted.*\(main \\(\\) \|21.*\}\).*" \
	    "first instance watchpoint deleted when leaving scope"] then {
	    gdb_suppress_tests;
	}
    }
    gdb_stop_suppressing_tests;
}

# Preserve the old timeout, and set a new one that should be
# sufficient to avoid timing out during this test.
set oldtimeout $timeout
set timeout [expr "$timeout + 60"]
verbose "Timeout is now $timeout seconds" 2

recurse_tests

# Restore the preserved old timeout value.
set timeout $oldtimeout
verbose "Timeout is now $timeout seconds" 2

@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 141
# Copyright (C) 1992, 1996 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Jeff Law. (law@@cs.utah.edu)

if $tracelevel then {
    strace $tracelevel
}

set prms_id 0
set bug_id 0

set testfile "recurse"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}
if  { [compile "${srcdir}/${subdir}/${srcfile} -g -o ${binfile}"] != "" } {
    perror "Couldn't compile ${srcfile}"
    return -1
}

# Start with a fresh gdb.

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

proc recurse_tests {} {

    if [runto recurse] then {
	# First we need to step over the assignment of b, so it has a known
	# value.
	gdb_test "next" "if \\(a == 1\\)" "next over b = 0 in first instance"
	gdb_test "watch b" ".*\[Ww\]atchpoint \[0-9]*: b" \
	    "set first instance watchpoint"

	# Continue until initial set of b.
	if [gdb_test "continue" \
	    "Continuing.*\[Ww\]atchpoint.*: b.*Old value = 0.*New value = 10.*" \
	    "continue to first instance watchpoint, first time"] then {
	    return
	}

	# Continue inward for a few iterations
	gdb_test "continue" "Breakpoint.* recurse \\(a=9\\).*" \
	    "continue to recurse (a = 9)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=8\\).*" \
	    "continue to recurse (a = 8)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=7\\).*" \
	    "continue to recurse (a = 7)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=6\\).*" \
	    "continue to recurse (a = 6)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=5\\).*" \
	    "continue to recurse (a = 5)"

	# Put a watchpoint on another instance of b
	# First we need to step over the assignment of b, so it has a known
	# value.
	gdb_test "next" "if \\(a == 1\\)" "next over b = 0 in second instance"
	gdb_test "watch b" ".*\[Ww\]atchpoint \[0-9]*: b" \
	    "set second instance watchpoint"

	# Continue until initial set of b (second instance).
	if [gdb_test "continue" \
	    "Continuing.*\[Ww\]atchpoint.*: b.*Old value = 0.*New value = 5.*"\
	    "continue to second instance watchpoint, first time"] then {
	    return
	}

	# Continue inward for a few iterations
	gdb_test "continue" "Breakpoint.* recurse \\(a=4\\).*" \
	    "continue to recurse (a = 4)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=3\\).*" \
	    "continue to recurse (a = 3)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=2\\).*" \
	    "continue to recurse (a = 2)"
	gdb_test "continue" "Breakpoint.* recurse \\(a=1\\).*" \
	    "continue to recurse (a = 1)"

	# Continue until second set of b (second instance).
	if [gdb_test "continue" \
	    "Continuing.*\[Ww\]atchpoint.*: b.*Old value = 5.*New value = 120.*return.*" \
	    "continue to second instance watchpoint, second time"] then { 
	    return
	}

	# Continue again.  We should have a watchpoint go out of scope now
	if [gdb_test "continue" \
	    "Continuing.*\[Ww\]atchpoint.*deleted.*recurse \\(a=6\\) .*" \
	    "second instance watchpoint deleted when leaving scope"] then {
	    return
	}

	# Continue until second set of b (first instance).
	if [gdb_test "continue" \
	    "Continuing.*\[Ww\]atchpoint.*b.*Old value = 10.*New value = 3628800.*return.*" \
	    "continue to first instance watchpoint, second time"] then {
	    return
	}

	# Continue again.  We should have a watchpoint go out of scope now
	if [gdb_test "continue" \
	    "Continuing.*\[Ww\]atchpoint.*deleted.*main \\(\\) .*" \
	    "first instance watchpoint deleted when leaving scope"] then {
	    return
	}
    }
}

# Only enabled for some targets merely because it has not been tested 
# elsewhere.
if {[istarget "sparc*-*-sunos4*"] || [istarget "hppa*-*-bsd*"]} then {

    # Preserve the old timeout, and set a new one that should be
    # sufficient to avoid timing out during this test.
    set oldtimeout $timeout
    set timeout [expr "$timeout + 60"]
    verbose "Timeout is now $timeout seconds" 2

    recurse_tests

    # Restore the preserved old timeout value.
    set timeout $oldtimeout
    verbose "Timeout is now $timeout seconds" 2
}
@
