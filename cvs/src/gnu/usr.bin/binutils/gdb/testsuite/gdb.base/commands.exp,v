head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.52
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.54
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.50
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.46
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.48
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.40
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.44
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.42
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.38
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.36
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.34
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.32
	OPENBSD_5_0:1.3.0.30
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.28
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.26
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.22
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.24
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.20
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.18
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.16
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.14
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.12
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.10
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	GDB_6_3:1.1.1.1
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2004.05.21.20.23.38;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.49.39;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.34.48;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.16.29;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.34.48;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@#   Copyright 1988, 1990, 1991, 1992, 1994, 1995, 1997, 1998, 1999, 2000,
#   2001, 2002, 2003 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

if $tracelevel then {
    strace $tracelevel
}

#
# test special commands (if, while, etc)
#
set prms_id 0
set bug_id 0

set testfile "run"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/commands
if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug additional_flags=-DFAKEARGV}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

gdb_exit
gdb_start
delete_breakpoints
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

proc gdbvar_simple_if_test {} {
    global gdb_prompt

    gdb_test "set \$foo = 0" "" "set foo in gdbvar_simple_if_test"
    # All this test should do is print 0xdeadbeef once.
    gdb_test "if \$foo == 1\np/x 0xfeedface\nelse\np/x 0xdeadbeef\nend" \
	    "\\\$\[0-9\]* = 0xdeadbeef" "gdbvar_simple_if_test #1"
    # All this test should do is print 0xfeedface once.
    gdb_test "if \$foo == 0\np/x 0xfeedface\nelse\np/x 0xdeadbeef\nend" \
	    "\\\$\[0-9\]* = 0xfeedface" "gdbvar_simple_if_test #2"
}

proc gdbvar_simple_while_test {} {
    global gdb_prompt

    gdb_test "set \$foo = 5" "" "set foo in gdbvar_simple_while_test"
    # This test should print 0xfeedface five times.
    gdb_test "while \$foo > 0\np/x 0xfeedface\nset \$foo -= 1\nend" \
	    "\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" \
	    "gdbvar_simple_while_test #1"
}

proc gdbvar_complex_if_while_test {} {
    global gdb_prompt

    gdb_test "set \$foo = 4" "" "set foo in gdbvar complex_if_while_test"
    # This test should alternate between 0xdeadbeef and 0xfeedface two times.
    gdb_test "while \$foo > 0\nset \$foo -= 1\nif \(\$foo % 2\) == 1\np/x 0xdeadbeef\nelse\np/x 0xfeedface\nend\nend" \
	    "\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" \
	    "gdbvar_complex_if_while_test #1"
}

proc progvar_simple_if_test {} {
    global gdb_prompt

    if [target_info exists noargs] { 
        verbose "Skipping progvar_simple_if_test because of noargs."
        return
    }

    if { ![runto factorial] } then { gdb_suppress_tests; }
    # Don't depend upon argument passing, since most simulators don't
    # currently support it.  Bash value variable to be what we want.
    gdb_test "p value=5" "" "set value to 5 in progvar_simple_if_test #1"
    # All this test should do is print 0xdeadbeef once.
    gdb_test "if value == 1\np/x 0xfeedface\nelse\np/x 0xdeadbeef\nend" \
	    "\\\$\[0-9\]* = 0xdeadbeef" \
	    "progvar_simple_if_test #1"
    # All this test should do is print 0xfeedface once.
    gdb_test "if value == 5\np/x 0xfeedface\nelse\np/x 0xdeadbeef\nend" \
	    "\\\$\[0-9\]* = 0xfeedface" \
	    "progvar_simple_if_test #2"
    gdb_stop_suppressing_tests;
}

proc progvar_simple_while_test {} {
    global gdb_prompt

    if [target_info exists noargs] { 
        verbose "Skipping progvar_simple_while_test because of noargs."
        return
    }

    gdb_test "set args 5" "" "set args in progvar_simple_while_test"
    if { ![runto factorial] } then { gdb_suppress_tests }
    # Don't depend upon argument passing, since most simulators don't
    # currently support it.  Bash value variable to be what we want.
    gdb_test "p value=5" "" "set value to 5 in progvar_simple_if_test #2"
    # This test should print 0xfeedface five times.
    gdb_test "while value > 0\np/x 0xfeedface\nset value -= 1\nend" \
	    "\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" \
	    "progvar_simple_while_test #1"
    gdb_stop_suppressing_tests;
}

proc progvar_complex_if_while_test {} {
    global gdb_prompt

    if [target_info exists noargs] { 
        verbose "Skipping progvar_simple_if_while_test because of noargs."
        return
    }

    gdb_test "set args 4" "" "set args in progvar_complex_if_while_test"
    if { ![runto factorial] } then { gdb_suppress_tests }
    # Don't depend upon argument passing, since most simulators don't
    # currently support it.  Bash value variable to be what we want.
    gdb_test "p value=4" "" "set value to 4 in progvar_simple_if_test"
    # This test should alternate between 0xdeadbeef and 0xfeedface two times.
    gdb_test "while value > 0\nset value -= 1\nif \(value % 2\) == 1\np/x 0xdeadbeef\nelse\np/x 0xfeedface\nend\nend" \
	    "\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" \
	    "progvar_complex_if_while_test #1"
    gdb_stop_suppressing_tests;
}

proc if_while_breakpoint_command_test {} {
    if [target_info exists noargs] { 
        verbose "Skipping if_while_breakpoint_command_test because of noargs."
        return
    }

    gdb_test "set args 5" "" "set args in if_while_breakpoint_command_test"
    if { ![runto factorial] } then { gdb_suppress_tests }
    # Don't depend upon argument passing, since most simulators don't
    # currently support it.  Bash value variable to be what we want.
    gdb_test "p value=5" "" "set value to 5 in progvar_simple_if_test"
    delete_breakpoints
    gdb_test "break factorial" "Breakpoint.*at.*" "break factorial #1"

    send_gdb "commands\n"
    gdb_expect {
	-re "End with" {
	    pass "commands in if_while_breakpoint_command_test"
	}
        default {
	    fail "(timeout or eof) commands in if_while_breakpoint_command_test"
	}
    }
    # This test should alternate between 0xdeadbeef and 0xfeedface two times.
    gdb_test "while value > 0\nset value -= 1\nif \(value % 2\) == 1\np/x 0xdeadbeef\nelse\np/x 0xfeedface\nend\nend\nend" \
	    "" \
	    "commands part 2 in if_while_breakpoint_command_test"
    gdb_test "continue" \
	    "\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" \
	    "if_while_breakpoint_command_test #1"
   gdb_test "info break" \
	   "while.*set.*if.*p/x.*else.*p/x.*end.*" \
	   "info break in if_while_breakpoint_command_test"
    gdb_stop_suppressing_tests;
}

# Test that we can run the inferior from breakpoint commands.
#
# The expected behavior is that all commands after the first "step"
# shall be ignored.  See the gdb manual, "Break Commands",
# subsection "Breakpoint command lists".

proc infrun_breakpoint_command_test {} {
    if [target_info exists noargs] { 
        verbose "Skipping infrun_breakpoint_command_test because of noargs."
        return
    }

    gdb_test "set args 6" "" "set args in infrun_breakpoint_command_test"
    if { ![runto factorial] } then { gdb_suppress_tests }
    # Don't depend upon argument passing, since most simulators don't
    # currently support it.  Bash value variable to be what we want.
    gdb_test "p value=6" "" "set value to 6 in progvar_simple_if_test #1"
    delete_breakpoints
    gdb_test "break factorial if value == 5" "Breakpoint.*at.*"

# infrun_breakpoint_command_test - This test was broken into two parts 
# to get around a synchronization problem in expect.
# part1: issue the gdb command "commands"
# part2: send the list of commands
    send_gdb "commands\n"
    gdb_expect {
	-re "End with" {
	    pass "commands in infrun_breakpoint_command_test #1"
	}
        default {
	    fail "(timeout or eof) commands in infrun_breakpoint_command_test"
	}
    }
    gdb_test "step\nstep\nstep\nstep\nend" "" \
	"commands in infrun_breakpoint_command_test #2"

	gdb_test "continue" \
		"Continuing.*.*.*Breakpoint \[0-9\]*, factorial \\(value=5\\).*at.*\[0-9\]*\[      \]*if \\(value > 1\\) \{.*\[0-9\]*\[      \]*value \\*= factorial \\(value - 1\\);.*" \
		"continue in infrun_breakpoint_command_test"

    gdb_stop_suppressing_tests;
}

proc breakpoint_command_test {} {
    if [target_info exists noargs] { 
        verbose "Skipping breakpoint_command_test because of noargs."
        return
    }

    gdb_test "set args 6" "" "set args in breakpoint_command_test"
    if { ![runto factorial] } then { gdb_suppress_tests; }
    # Don't depend upon argument passing, since most simulators don't
    # currently support it.  Bash value variable to be what we want.
    gdb_test "p value=6" "" "set value to 6 in progvar_simple_if_test #2"
    delete_breakpoints
    gdb_test "break factorial" "Breakpoint.*at.*" "break factorial #2"
    gdb_test "commands\nprintf \"Now the value is %d\\n\", value\nend" \
	"End with.*" "commands in breakpoint_command_test"
    gdb_test "continue" \
	    "Breakpoint \[0-9\]*, factorial.*Now the value is 5" \
	"continue in breakpoint_command_test"
    gdb_test "print value" " = 5" "print value in breakpoint_command_test"
    gdb_stop_suppressing_tests;
}

# Test a simple user defined command (with arguments)
proc user_defined_command_test {} {
    global gdb_prompt

    gdb_test "set \$foo = 4" "" "set foo in user_defined_command_test"

    send_gdb "define mycommand\n"
    gdb_expect {
	-re "End with"  {
	    pass "define mycommand in user_defined_command_test"
	}
        default {
	    fail "(timeout or eof) define mycommand in user_defined_command_test"
	}
    }
    # This test should alternate between 0xdeadbeef and 0xfeedface two times.
    gdb_test "while \$arg0 > 0\nset \$arg0 -= 1\nif \(\$arg0 % 2\) == 1\np/x 0xdeadbeef\nelse\np/x 0xfeedface\nend\nend\nend" \
	    "" \
	    "enter commands in user_defined_command_test"

    gdb_test "mycommand \$foo" \
	    "\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" \
	    "execute user defined command in user_defined_command_test"
   gdb_test "show user mycommand" \
	"  while \\\$arg0.*set.*    if \\\(\\\$arg0.*p/x.*    else\[^\n\].*p/x.*    end\[^\n\].*  end\[^\n\].*" \
	   "display user command in user_defined_command_test"
}

proc watchpoint_command_test {} {
    global noargs
    global gdb_prompt

    if [target_info exists noargs] { 
        verbose "Skipping watchpoint_command_test because of noargs."
        return
    }

    gdb_test "set args 6" "" "set args in watchpoint_command_test"
    if { ![runto factorial] } then { return }
    delete_breakpoints

    # Verify that we can create a watchpoint, and give it a commands
    # list that continues the inferior.  We set the watchpoint on a
    # local variable, too, so that it self-deletes when the watched
    # data goes out of scope.
    #
    # What should happen is: Each time the watchpoint triggers, it
    # continues the inferior.  Eventually, the watchpoint will self-
    # delete, when the watched variable is out of scope.  But by that
    # time, the inferior should have exited.  GDB shouldn't crash or
    # anything untoward as a result of this.
    #
    set wp_id -1

    send_gdb "watch local_var\n"
    gdb_expect {
        -re ".*\[Ww\]atchpoint (\[0-9\]*): local_var.*$gdb_prompt $" {
            set wp_id $expect_out(1,string)
            pass "watch local_var"
        }
        -re "$gdb_prompt $"\
            {fail "watch local_var"}
        timeout {fail "(timeout) watch local_var"}
    }

    if {$wp_id == -1} {return}

    send_gdb "commands $wp_id\n"
    gdb_expect {
      -re "Type commands for when breakpoint $wp_id is hit, one per line.*>" {
	  pass "begin commands on watch"
      }
      -re "$gdb_prompt $" {fail "begin commands on watch"}
      timeout             {fail "(timeout) begin commands on watch"}
    }
    send_gdb "print value\n"
    gdb_expect {
	-re ">"               {pass "add print command to watch"}
	-re "$gdb_prompt $"   {fail "add print command to watch"}
	timeout               {fail "(timeout) add print command to watch"}
    }
    send_gdb "continue\n"
    gdb_expect {
	-re ">"               {pass "add continue command to watch"}
	-re "$gdb_prompt $"   {fail "add continue command to watch"}
	timeout               {fail "(timeout) add continue command to watch"}
    }
    send_gdb "end\n"
    gdb_expect {
	-re "$gdb_prompt $"   {pass "end commands on watch"}
	timeout               {fail "(timeout) end commands on watch"}
    }
    send_gdb "continue\n"
    gdb_expect {
	-re "Continuing.*\[Ww\]atchpoint $wp_id deleted because the program has left the block in.*which its expression is valid.*run.c:57.*$gdb_prompt $" {
	    pass "continue with watch"
	}
	-re "$gdb_prompt $"   {fail "continue with watch"}
	timeout               {fail "(timeout) continue with watch"}
    }
}

proc test_command_prompt_position {} {
    global gdb_prompt

    if [target_info exists noargs] { 
        verbose "Skipping test_command_prompt_position because of noargs."
        return
    }

    if { ![runto factorial] } then { gdb_suppress_tests; }
    # Don't depend upon argument passing, since most simulators don't
    # currently support it.  Bash value variable to be what we want.
    delete_breakpoints
    gdb_test "break factorial" "Breakpoint.*at.*" "break factorial #3"
    gdb_test "p value=5" "" "set value to 5 in test_command_prompt_position"
    # All this test should do is print 0xdeadbeef once.
    gdb_test "if value == 1\np/x 0xfeedface\nelse\np/x 0xdeadbeef\nend" \
	    "\\\$\[0-9\]* = 0xdeadbeef" \
	    "if test in test_command_prompt_position"
    
    # Now let's test for the correct position of the '>' in gdb's
    # prompt for commands.  It should be at the beginning of the line,
    # and not after one space.

    send_gdb "commands\n"
    gdb_expect {
	-re "Type commands.*End with.*\[\r\n\]>$" { 
	    send_gdb "printf \"Now the value is %d\\n\", value\n"
	    gdb_expect {
		-re "^printf.*value\r\n>$" {
		    send_gdb "end\n"
		    gdb_expect {
			-re "^end\r\n$gdb_prompt $" { 
			    pass "> OK in test_command_prompt_position" 
			}
			-re ".*$gdb_prompt $" { 
			    fail "some other message in test_command_prompt_position" 
			}
			timeout  { 
			    fail "(timeout) 1 in test_command_prompt_position"
			}
		    }
		}
		-re "^ >$" { fail "> not OK in test_command_prompt_position" }
		-re ".*$gdb_prompt $"   { 
		    fail "wrong message in test_command_prompt_position" 
		}
		timeout    { 
		    fail "(timeout) 2 in test_command_prompt_position " 
		}
	    }
	}
	-re "Type commands.*End with.*\[\r\n\] >$" { 
	    fail "prompt not OK in test_command_prompt_position" 
	}
	-re ".*$gdb_prompt $" { 
	    fail "commands in test_command_prompt_position" 
	}
	timeout { fail "(timeout) 3 commands in test_command_prompt_position" }
    }

    gdb_stop_suppressing_tests;
}



proc deprecated_command_test {} {
    gdb_test "maintenance deprecate blah" "Can't find command.*" \
          "tried to deprecate non-existing command"

    gdb_test "maintenance deprecate p \"new_p\"" "" "maintenance deprecate p \"new_p\" /1/"
    gdb_test "p 5" \
	    "Warning: 'p', an alias for the command 'print' is deprecated.*Use 'new_p'.*" \
	    "p deprecated warning, with replacement"
    gdb_test "p 5" ".\[0-9\]* = 5.*" "Deprecated warning goes away /1/"

    gdb_test "maintenance deprecate p \"new_p\"" "" "maintenance deprecate p \"new_p\" /2/"
    gdb_test "maintenance deprecate print \"new_print\"" ""
    gdb_test "p 5" \
	    "Warning: command 'print' \\(p\\) is deprecated.*Use 'new_print'.*" \
	    "both alias and command are deprecated"
    gdb_test "p 5" ".\[0-9\]* = 5.*" "Deprecated warning goes away /2/"

    gdb_test "maintenance deprecate set remote memory-read-packet-size \"srm\" " \
	    "" \
	    "deprecate long command /1/"
    gdb_test "set remote memory-read-packet-size" \
	    "Warning: command 'set remote memory-read-packet-size' is deprecated.*Use 'srm'.*" \
	    "long command deprecated /1/"

    gdb_test "maintenance deprecate set remote memory-read-packet-size" \
	    "" \
	    "deprecate long command /2/"
    gdb_test "set remote memory-read-packet-size" \
	    "Warning: command 'set remote memory-read-packet-size' is deprecated.*No alternative known.*" \
	    "long command deprecated with no alternative /2/"

    gdb_test "maintenance deprecate" \
	    "\"maintenance deprecate\".*" \
	    "deprecate with no arguments"
}

proc bp_deleted_in_command_test {} {
    global gdb_prompt
    
    if [target_info exists noargs] { 
        verbose "Skipping bp_deleted_in_command_test because of noargs."
        return
    }

    gdb_test "set args 1" "" "set args in bp_deleted_in_command_test"
    delete_breakpoints

    # Create a breakpoint, and associate a command-list to it, with
    # one command that deletes this breakpoint.
    gdb_test "break factorial" \
             "Breakpoint \[0-9\]+ at .*: file .*/run.c, line \[0-9\]+\." \
             "breakpoint in bp_deleted_in_command_test"
    
    send_gdb "commands\n"
    gdb_expect {
      -re "Type commands for when breakpoint .* is hit, one per line.*>" {
          pass "begin commands in bp_deleted_in_command_test"
      }
      -re "$gdb_prompt $" {fail "begin commands in bp_deleted_in_command_test"}
      timeout             {fail "(timeout) begin commands bp_deleted_in_command_test"}
    }
    send_gdb "silent\n"
    gdb_expect {
        -re ">"               {pass "add silent command"}
        -re "$gdb_prompt $"   {fail "add silent command"}
        timeout               {fail "(timeout) add silent command"}
    }
    send_gdb "clear factorial\n"
    gdb_expect {
        -re ">"               {pass "add clear command"}
        -re "$gdb_prompt $"   {fail "add clear command"}
        timeout               {fail "(timeout) add clear command"} }
    send_gdb "printf \"factorial command-list executed\\n\"\n"
    gdb_expect {
        -re ">"               {pass "add printf command"}
        -re "$gdb_prompt $"   {fail "add printf command"}
        timeout               {fail "(timeout) add printf command"}
    }
    send_gdb "cont\n"
    gdb_expect {
        -re ">"               {pass "add cont command"}
        -re "$gdb_prompt $"   {fail "add cont command"}
        timeout               {fail "(timeout) add cont command"} }
    send_gdb "end\n"
    gdb_expect {
        -re "$gdb_prompt $"   {pass "end commands"}
        timeout               {fail "(timeout) end commands"}
    }

    gdb_run_cmd
    gdb_expect {
        -re ".*factorial command-list executed.*1.*$gdb_prompt $" {
	    pass "run factorial until breakpoint"
        }
	-re ".*$gdb_prompt $" {
	    fail "run factorial until breakpoint"
	}
	default { fail "(timeout) run factorial until breakpoint" }
	timeout { fail "(timeout) run factorial until breakpoint" }
    }
}

proc temporary_breakpoint_commands {} {
    global gdb_prompt
    
    if [target_info exists noargs] { 
        verbose "Skipping temporary_breakpoint_commands because of noargs."
        return
    }

    gdb_test "set args 1" "" "set args in temporary_breakpoint_commands"
    delete_breakpoints

    # Create a temporary breakpoint, and associate a commands list to it.
    # This test will verify that this commands list is executed when the
    # breakpoint is hit.
    gdb_test "tbreak factorial" \
	    "Breakpoint \[0-9\]+ at .*: file .*/run.c, line \[0-9\]+\." \
	    "breakpoint in temporary_breakpoint_commands"
    
    send_gdb "commands\n"
    gdb_expect {
	-re "Type commands for when breakpoint .* is hit, one per line.*>" {
	    pass "begin commands in bp_deleted_in_command_test"
	}
	-re "$gdb_prompt $" {fail "begin commands in bp_deleted_in_command_test"}
	timeout             {fail "(timeout) begin commands bp_deleted_in_command_test"}
    }
    send_gdb "silent\n"
    gdb_expect {
	-re ">"               {pass "add silent tbreak command"}
	-re "$gdb_prompt $"   {fail "add silent tbreak command"}
	timeout               {fail "(timeout) add silent tbreak command"}
     }
    send_gdb "printf \"factorial tbreak commands executed\\n\"\n"
    gdb_expect {
	-re ">"               {pass "add printf tbreak command"}
	-re "$gdb_prompt $"   {fail "add printf tbreak command"}
	timeout               {fail "(timeout) add printf tbreak command"}
     }
    send_gdb "cont\n"
    gdb_expect {
	-re ">"               {pass "add cont tbreak command"}
	-re "$gdb_prompt $"   {fail "add cont tbreak command"}
	timeout               {fail "(timeout) add cont tbreak command"} }
    send_gdb "end\n"
    gdb_expect {
	-re "$gdb_prompt $"   {pass "end tbreak commands"}
	timeout               {fail "(timeout) end tbreak commands"}
     }

    gdb_run_cmd
    gdb_expect {
	-re ".*factorial tbreak commands executed.*1.*$gdb_prompt $" {
	    pass "run factorial until temporary breakpoint"
	}
	timeout { fail "(timeout) run factorial until temporary breakpoint" }
    }
}
  
gdbvar_simple_if_test
gdbvar_simple_while_test
gdbvar_complex_if_while_test
progvar_simple_if_test
progvar_simple_while_test
progvar_complex_if_while_test
if_while_breakpoint_command_test
infrun_breakpoint_command_test
breakpoint_command_test
user_defined_command_test
watchpoint_command_test
test_command_prompt_position
deprecated_command_test
bp_deleted_in_command_test
temporary_breakpoint_commands
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d1 2
a2 1
#   Copyright (C) 1988, 1990, 1991, 1992 Free Software Foundation, Inc.
d16 1
a16 1
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d33 3
a35 4
set binfile ${objdir}/${subdir}/${testfile}
if  { [compile "${srcdir}/${subdir}/${srcfile} -g -o ${binfile}"] != "" } {
    perror "Couldn't compile ${srcfile}"
    return -1
d45 1
a45 1
    global prompt
d49 2
a50 1
    gdb_test "if \$foo == 1\np/x 0xfeedface\nelse\np/x 0xdeadbeef\nend" "\\\$\[0-9\]* = 0xdeadbeef" "gdbvar_simple_if_test #1"
d52 2
a53 1
    gdb_test "if \$foo == 0\np/x 0xfeedface\nelse\np/x 0xdeadbeef\nend" "\\\$\[0-9\]* = 0xfeedface" "gdbvar_simple_if_test #2"
d57 1
a57 1
    global prompt
d61 3
a63 1
    gdb_test "while \$foo > 0\np/x 0xfeedface\nset \$foo -= 1\nend" "\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" "gdbvar_simple_while_test #1"
d67 1
a67 1
    global prompt
d71 3
a73 1
    gdb_test "while \$foo > 0\nset \$foo -= 1\nif \(\$foo % 2\) == 1\np/x 0xdeadbeef\nelse\np/x 0xfeedface\nend\nend" "\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" "gdbvar_complex_if_while_test #1"
d77 1
a77 2
    global prompt
    global noargs
d79 1
a79 1
    if $noargs { 
d84 4
a87 2
    gdb_test "set args 5" "" "set args in progvar_simple_if_test"
    if { ![runto factorial] } then { return }
d89 3
a91 1
    gdb_test "if value == 1\np/x 0xfeedface\nelse\np/x 0xdeadbeef\nend" "\\\$\[0-9\]* = 0xdeadbeef" "progvar_simple_if_test #1"
d93 4
a96 1
    gdb_test "if value == 5\np/x 0xfeedface\nelse\np/x 0xdeadbeef\nend" "\\\$\[0-9\]* = 0xfeedface" "progvar_simple_if_test #2"
d100 1
a100 2
    global prompt
    global noargs
d102 1
a102 1
    if $noargs { 
d108 4
a111 1
    if { ![runto factorial] } then { return }
d113 4
a116 1
    gdb_test "while value > 0\np/x 0xfeedface\nset value -= 1\nend" "\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" "progvar_simple_while_test #1"
d120 1
a120 2
    global prompt
    global noargs
d122 1
a122 1
    if $noargs { 
d128 4
a131 1
    if { ![runto factorial] } then { return }
d133 4
a136 1
    gdb_test "while value > 0\nset value -= 1\nif \(value % 2\) == 1\np/x 0xdeadbeef\nelse\np/x 0xfeedface\nend\nend" "\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" "progvar_complex_if_while_test #1"
d140 1
a140 3
    global noargs

    if $noargs { 
d146 4
a149 1
    if { ![runto factorial] } then { return }
d151 1
a151 1
    gdb_test "break factorial" "Breakpoint.*at.*"
d153 2
a154 2
    send "commands\n"
    expect {
d163 10
a172 3
    gdb_test "while value > 0\nset value -= 1\nif \(value % 2\) == 1\np/x 0xdeadbeef\nelse\np/x 0xfeedface\nend\nend\nend" "" "commands part 2 in if_while_breakpoint_command_test"
    gdb_test "continue" "\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" "if_while_breakpoint_command_test #1"
   gdb_test "info break" "while.*set.*if.*p/x.*else.*p/x.*end.*" "info break in if_while_breakpoint_command_test"
d176 5
d182 1
a182 3
    global noargs

    if $noargs { 
d187 5
a191 2
    gdb_test "set args 6" "" "set args in progvar_simple_while_test"
    if { ![runto factorial] } then { return }
d194 22
a215 15
    gdb_test "commands\nstep\nstep\nstep\nstep\nbt\nend" \
	"End with.*" "commands in infrun_breakpoint_command_test"
    gdb_test "continue" "Breakpoint \[0-9\]*, factorial \\(value=5\\).*at.*
\[0-9\]*\[ 	\]*if \\(value > 1\\) \{.*
\[0-9\]*\[ 	\]*value \\*= factorial \\(value - 1\\);.*
factorial \\(value=4\\) at.*\[0-9\]*\[ 	\]*if \\(value > 1\\) \{.*
\[0-9\]*\[ 	\]*value \\*= factorial \\(value - 1\\);.*
factorial \\(value=3\\) at .*
\[0-9\]*\[ 	\]*if \\(value > 1\\) \{.*
#0  factorial \\(value=3\\).*
#1  \[0-9a-fx\]* in factorial \\(value=4\\).*
#2  \[0-9a-fx\]* in factorial \\(value=5\\).*
#3  \[0-9a-fx\]* in factorial \\(value=6\\).*
#4  \[0-9a-fx\]* in main \\(.*\\).*" \
	"continue in infrun_breakpoint_command_test"
d219 1
a219 3
    global noargs

    if $noargs { 
d224 5
a228 2
    gdb_test "set args 6" "" "set args in progvar_simple_while_test"
    if { ![runto factorial] } then { return }
d230 1
a230 1
    gdb_test "break factorial" "Breakpoint.*at.*"
d233 2
a234 1
    gdb_test "continue" "Breakpoint \[0-9\]*, factorial.*Now the value is 5" \
d237 1
d242 1
a242 1
    global prompt
d246 2
a247 2
    send "define mycommand\n"
    expect {
d256 88
a343 1
    gdb_test "while \$arg0 > 0\nset \$arg0 -= 1\nif \(\$arg0 % 2\) == 1\np/x 0xdeadbeef\nelse\np/x 0xfeedface\nend\nend\nend" "" "enter commands in user_defined_command_test"
d345 58
a402 2
    gdb_test "mycommand \$foo" "\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" "execute user defined command in user_defined_command_test"
   gdb_test "show user mycommand" "while.*set.*if.*p/x.*else.*p/x.*end.*" "display user command in user_defined_command_test"
d405 162
d577 5
@


1.1
log
@file commands.exp was initially added on branch CYGNUS.
@
text
@d1 225
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 581
#   Copyright 1988, 1990, 1991, 1992, 1994, 1995, 1997, 1998, 1999, 2000,
#   2001, 2002, 2003 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

if $tracelevel then {
    strace $tracelevel
}

#
# test special commands (if, while, etc)
#
set prms_id 0
set bug_id 0

set testfile "run"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/commands
if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug additional_flags=-DFAKEARGV}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

gdb_exit
gdb_start
delete_breakpoints
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

proc gdbvar_simple_if_test {} {
    global gdb_prompt

    gdb_test "set \$foo = 0" "" "set foo in gdbvar_simple_if_test"
    # All this test should do is print 0xdeadbeef once.
    gdb_test "if \$foo == 1\np/x 0xfeedface\nelse\np/x 0xdeadbeef\nend" \
	    "\\\$\[0-9\]* = 0xdeadbeef" "gdbvar_simple_if_test #1"
    # All this test should do is print 0xfeedface once.
    gdb_test "if \$foo == 0\np/x 0xfeedface\nelse\np/x 0xdeadbeef\nend" \
	    "\\\$\[0-9\]* = 0xfeedface" "gdbvar_simple_if_test #2"
}

proc gdbvar_simple_while_test {} {
    global gdb_prompt

    gdb_test "set \$foo = 5" "" "set foo in gdbvar_simple_while_test"
    # This test should print 0xfeedface five times.
    gdb_test "while \$foo > 0\np/x 0xfeedface\nset \$foo -= 1\nend" \
	    "\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" \
	    "gdbvar_simple_while_test #1"
}

proc gdbvar_complex_if_while_test {} {
    global gdb_prompt

    gdb_test "set \$foo = 4" "" "set foo in gdbvar complex_if_while_test"
    # This test should alternate between 0xdeadbeef and 0xfeedface two times.
    gdb_test "while \$foo > 0\nset \$foo -= 1\nif \(\$foo % 2\) == 1\np/x 0xdeadbeef\nelse\np/x 0xfeedface\nend\nend" \
	    "\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" \
	    "gdbvar_complex_if_while_test #1"
}

proc progvar_simple_if_test {} {
    global gdb_prompt

    if [target_info exists noargs] { 
        verbose "Skipping progvar_simple_if_test because of noargs."
        return
    }

    if { ![runto factorial] } then { gdb_suppress_tests; }
    # Don't depend upon argument passing, since most simulators don't
    # currently support it.  Bash value variable to be what we want.
    gdb_test "p value=5" "" "set value to 5 in progvar_simple_if_test #1"
    # All this test should do is print 0xdeadbeef once.
    gdb_test "if value == 1\np/x 0xfeedface\nelse\np/x 0xdeadbeef\nend" \
	    "\\\$\[0-9\]* = 0xdeadbeef" \
	    "progvar_simple_if_test #1"
    # All this test should do is print 0xfeedface once.
    gdb_test "if value == 5\np/x 0xfeedface\nelse\np/x 0xdeadbeef\nend" \
	    "\\\$\[0-9\]* = 0xfeedface" \
	    "progvar_simple_if_test #2"
    gdb_stop_suppressing_tests;
}

proc progvar_simple_while_test {} {
    global gdb_prompt

    if [target_info exists noargs] { 
        verbose "Skipping progvar_simple_while_test because of noargs."
        return
    }

    gdb_test "set args 5" "" "set args in progvar_simple_while_test"
    if { ![runto factorial] } then { gdb_suppress_tests }
    # Don't depend upon argument passing, since most simulators don't
    # currently support it.  Bash value variable to be what we want.
    gdb_test "p value=5" "" "set value to 5 in progvar_simple_if_test #2"
    # This test should print 0xfeedface five times.
    gdb_test "while value > 0\np/x 0xfeedface\nset value -= 1\nend" \
	    "\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" \
	    "progvar_simple_while_test #1"
    gdb_stop_suppressing_tests;
}

proc progvar_complex_if_while_test {} {
    global gdb_prompt

    if [target_info exists noargs] { 
        verbose "Skipping progvar_simple_if_while_test because of noargs."
        return
    }

    gdb_test "set args 4" "" "set args in progvar_complex_if_while_test"
    if { ![runto factorial] } then { gdb_suppress_tests }
    # Don't depend upon argument passing, since most simulators don't
    # currently support it.  Bash value variable to be what we want.
    gdb_test "p value=4" "" "set value to 4 in progvar_simple_if_test"
    # This test should alternate between 0xdeadbeef and 0xfeedface two times.
    gdb_test "while value > 0\nset value -= 1\nif \(value % 2\) == 1\np/x 0xdeadbeef\nelse\np/x 0xfeedface\nend\nend" \
	    "\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" \
	    "progvar_complex_if_while_test #1"
    gdb_stop_suppressing_tests;
}

proc if_while_breakpoint_command_test {} {
    if [target_info exists noargs] { 
        verbose "Skipping if_while_breakpoint_command_test because of noargs."
        return
    }

    gdb_test "set args 5" "" "set args in if_while_breakpoint_command_test"
    if { ![runto factorial] } then { gdb_suppress_tests }
    # Don't depend upon argument passing, since most simulators don't
    # currently support it.  Bash value variable to be what we want.
    gdb_test "p value=5" "" "set value to 5 in progvar_simple_if_test"
    delete_breakpoints
    gdb_test "break factorial" "Breakpoint.*at.*" "break factorial #1"

    send_gdb "commands\n"
    gdb_expect {
	-re "End with" {
	    pass "commands in if_while_breakpoint_command_test"
	}
        default {
	    fail "(timeout or eof) commands in if_while_breakpoint_command_test"
	}
    }
    # This test should alternate between 0xdeadbeef and 0xfeedface two times.
    gdb_test "while value > 0\nset value -= 1\nif \(value % 2\) == 1\np/x 0xdeadbeef\nelse\np/x 0xfeedface\nend\nend\nend" \
	    "" \
	    "commands part 2 in if_while_breakpoint_command_test"
    gdb_test "continue" \
	    "\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" \
	    "if_while_breakpoint_command_test #1"
   gdb_test "info break" \
	   "while.*set.*if.*p/x.*else.*p/x.*end.*" \
	   "info break in if_while_breakpoint_command_test"
    gdb_stop_suppressing_tests;
}

# Test that we can run the inferior from breakpoint commands.
#
# The expected behavior is that all commands after the first "step"
# shall be ignored.  See the gdb manual, "Break Commands",
# subsection "Breakpoint command lists".

proc infrun_breakpoint_command_test {} {
    if [target_info exists noargs] { 
        verbose "Skipping infrun_breakpoint_command_test because of noargs."
        return
    }

    gdb_test "set args 6" "" "set args in infrun_breakpoint_command_test"
    if { ![runto factorial] } then { gdb_suppress_tests }
    # Don't depend upon argument passing, since most simulators don't
    # currently support it.  Bash value variable to be what we want.
    gdb_test "p value=6" "" "set value to 6 in progvar_simple_if_test #1"
    delete_breakpoints
    gdb_test "break factorial if value == 5" "Breakpoint.*at.*"

# infrun_breakpoint_command_test - This test was broken into two parts 
# to get around a synchronization problem in expect.
# part1: issue the gdb command "commands"
# part2: send the list of commands
    send_gdb "commands\n"
    gdb_expect {
	-re "End with" {
	    pass "commands in infrun_breakpoint_command_test #1"
	}
        default {
	    fail "(timeout or eof) commands in infrun_breakpoint_command_test"
	}
    }
    gdb_test "step\nstep\nstep\nstep\nend" "" \
	"commands in infrun_breakpoint_command_test #2"

	gdb_test "continue" \
		"Continuing.*.*.*Breakpoint \[0-9\]*, factorial \\(value=5\\).*at.*\[0-9\]*\[      \]*if \\(value > 1\\) \{.*\[0-9\]*\[      \]*value \\*= factorial \\(value - 1\\);.*" \
		"continue in infrun_breakpoint_command_test"

    gdb_stop_suppressing_tests;
}

proc breakpoint_command_test {} {
    if [target_info exists noargs] { 
        verbose "Skipping breakpoint_command_test because of noargs."
        return
    }

    gdb_test "set args 6" "" "set args in breakpoint_command_test"
    if { ![runto factorial] } then { gdb_suppress_tests; }
    # Don't depend upon argument passing, since most simulators don't
    # currently support it.  Bash value variable to be what we want.
    gdb_test "p value=6" "" "set value to 6 in progvar_simple_if_test #2"
    delete_breakpoints
    gdb_test "break factorial" "Breakpoint.*at.*" "break factorial #2"
    gdb_test "commands\nprintf \"Now the value is %d\\n\", value\nend" \
	"End with.*" "commands in breakpoint_command_test"
    gdb_test "continue" \
	    "Breakpoint \[0-9\]*, factorial.*Now the value is 5" \
	"continue in breakpoint_command_test"
    gdb_test "print value" " = 5" "print value in breakpoint_command_test"
    gdb_stop_suppressing_tests;
}

# Test a simple user defined command (with arguments)
proc user_defined_command_test {} {
    global gdb_prompt

    gdb_test "set \$foo = 4" "" "set foo in user_defined_command_test"

    send_gdb "define mycommand\n"
    gdb_expect {
	-re "End with"  {
	    pass "define mycommand in user_defined_command_test"
	}
        default {
	    fail "(timeout or eof) define mycommand in user_defined_command_test"
	}
    }
    # This test should alternate between 0xdeadbeef and 0xfeedface two times.
    gdb_test "while \$arg0 > 0\nset \$arg0 -= 1\nif \(\$arg0 % 2\) == 1\np/x 0xdeadbeef\nelse\np/x 0xfeedface\nend\nend\nend" \
	    "" \
	    "enter commands in user_defined_command_test"

    gdb_test "mycommand \$foo" \
	    "\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" \
	    "execute user defined command in user_defined_command_test"
   gdb_test "show user mycommand" \
	"  while \\\$arg0.*set.*    if \\\(\\\$arg0.*p/x.*    else\[^\n\].*p/x.*    end\[^\n\].*  end\[^\n\].*" \
	   "display user command in user_defined_command_test"
}

proc watchpoint_command_test {} {
    global noargs
    global gdb_prompt

    if [target_info exists noargs] { 
        verbose "Skipping watchpoint_command_test because of noargs."
        return
    }

    gdb_test "set args 6" "" "set args in watchpoint_command_test"
    if { ![runto factorial] } then { return }
    delete_breakpoints

    # Verify that we can create a watchpoint, and give it a commands
    # list that continues the inferior.  We set the watchpoint on a
    # local variable, too, so that it self-deletes when the watched
    # data goes out of scope.
    #
    # What should happen is: Each time the watchpoint triggers, it
    # continues the inferior.  Eventually, the watchpoint will self-
    # delete, when the watched variable is out of scope.  But by that
    # time, the inferior should have exited.  GDB shouldn't crash or
    # anything untoward as a result of this.
    #
    set wp_id -1

    send_gdb "watch local_var\n"
    gdb_expect {
        -re ".*\[Ww\]atchpoint (\[0-9\]*): local_var.*$gdb_prompt $" {
            set wp_id $expect_out(1,string)
            pass "watch local_var"
        }
        -re "$gdb_prompt $"\
            {fail "watch local_var"}
        timeout {fail "(timeout) watch local_var"}
    }

    if {$wp_id == -1} {return}

    send_gdb "commands $wp_id\n"
    gdb_expect {
      -re "Type commands for when breakpoint $wp_id is hit, one per line.*>" {
	  pass "begin commands on watch"
      }
      -re "$gdb_prompt $" {fail "begin commands on watch"}
      timeout             {fail "(timeout) begin commands on watch"}
    }
    send_gdb "print value\n"
    gdb_expect {
	-re ">"               {pass "add print command to watch"}
	-re "$gdb_prompt $"   {fail "add print command to watch"}
	timeout               {fail "(timeout) add print command to watch"}
    }
    send_gdb "continue\n"
    gdb_expect {
	-re ">"               {pass "add continue command to watch"}
	-re "$gdb_prompt $"   {fail "add continue command to watch"}
	timeout               {fail "(timeout) add continue command to watch"}
    }
    send_gdb "end\n"
    gdb_expect {
	-re "$gdb_prompt $"   {pass "end commands on watch"}
	timeout               {fail "(timeout) end commands on watch"}
    }
    send_gdb "continue\n"
    gdb_expect {
	-re "Continuing.*\[Ww\]atchpoint $wp_id deleted because the program has left the block in.*which its expression is valid.*run.c:57.*$gdb_prompt $" {
	    pass "continue with watch"
	}
	-re "$gdb_prompt $"   {fail "continue with watch"}
	timeout               {fail "(timeout) continue with watch"}
    }
}

proc test_command_prompt_position {} {
    global gdb_prompt

    if [target_info exists noargs] { 
        verbose "Skipping test_command_prompt_position because of noargs."
        return
    }

    if { ![runto factorial] } then { gdb_suppress_tests; }
    # Don't depend upon argument passing, since most simulators don't
    # currently support it.  Bash value variable to be what we want.
    delete_breakpoints
    gdb_test "break factorial" "Breakpoint.*at.*" "break factorial #3"
    gdb_test "p value=5" "" "set value to 5 in test_command_prompt_position"
    # All this test should do is print 0xdeadbeef once.
    gdb_test "if value == 1\np/x 0xfeedface\nelse\np/x 0xdeadbeef\nend" \
	    "\\\$\[0-9\]* = 0xdeadbeef" \
	    "if test in test_command_prompt_position"
    
    # Now let's test for the correct position of the '>' in gdb's
    # prompt for commands.  It should be at the beginning of the line,
    # and not after one space.

    send_gdb "commands\n"
    gdb_expect {
	-re "Type commands.*End with.*\[\r\n\]>$" { 
	    send_gdb "printf \"Now the value is %d\\n\", value\n"
	    gdb_expect {
		-re "^printf.*value\r\n>$" {
		    send_gdb "end\n"
		    gdb_expect {
			-re "^end\r\n$gdb_prompt $" { 
			    pass "> OK in test_command_prompt_position" 
			}
			-re ".*$gdb_prompt $" { 
			    fail "some other message in test_command_prompt_position" 
			}
			timeout  { 
			    fail "(timeout) 1 in test_command_prompt_position"
			}
		    }
		}
		-re "^ >$" { fail "> not OK in test_command_prompt_position" }
		-re ".*$gdb_prompt $"   { 
		    fail "wrong message in test_command_prompt_position" 
		}
		timeout    { 
		    fail "(timeout) 2 in test_command_prompt_position " 
		}
	    }
	}
	-re "Type commands.*End with.*\[\r\n\] >$" { 
	    fail "prompt not OK in test_command_prompt_position" 
	}
	-re ".*$gdb_prompt $" { 
	    fail "commands in test_command_prompt_position" 
	}
	timeout { fail "(timeout) 3 commands in test_command_prompt_position" }
    }

    gdb_stop_suppressing_tests;
}



proc deprecated_command_test {} {
    gdb_test "maintenance deprecate blah" "Can't find command.*" \
          "tried to deprecate non-existing command"

    gdb_test "maintenance deprecate p \"new_p\"" "" "maintenance deprecate p \"new_p\" /1/"
    gdb_test "p 5" \
	    "Warning: 'p', an alias for the command 'print' is deprecated.*Use 'new_p'.*" \
	    "p deprecated warning, with replacement"
    gdb_test "p 5" ".\[0-9\]* = 5.*" "Deprecated warning goes away /1/"

    gdb_test "maintenance deprecate p \"new_p\"" "" "maintenance deprecate p \"new_p\" /2/"
    gdb_test "maintenance deprecate print \"new_print\"" ""
    gdb_test "p 5" \
	    "Warning: command 'print' \\(p\\) is deprecated.*Use 'new_print'.*" \
	    "both alias and command are deprecated"
    gdb_test "p 5" ".\[0-9\]* = 5.*" "Deprecated warning goes away /2/"

    gdb_test "maintenance deprecate set remote memory-read-packet-size \"srm\" " \
	    "" \
	    "deprecate long command /1/"
    gdb_test "set remote memory-read-packet-size" \
	    "Warning: command 'set remote memory-read-packet-size' is deprecated.*Use 'srm'.*" \
	    "long command deprecated /1/"

    gdb_test "maintenance deprecate set remote memory-read-packet-size" \
	    "" \
	    "deprecate long command /2/"
    gdb_test "set remote memory-read-packet-size" \
	    "Warning: command 'set remote memory-read-packet-size' is deprecated.*No alternative known.*" \
	    "long command deprecated with no alternative /2/"

    gdb_test "maintenance deprecate" \
	    "\"maintenance deprecate\".*" \
	    "deprecate with no arguments"
}

proc bp_deleted_in_command_test {} {
    global gdb_prompt
    
    if [target_info exists noargs] { 
        verbose "Skipping bp_deleted_in_command_test because of noargs."
        return
    }

    gdb_test "set args 1" "" "set args in bp_deleted_in_command_test"
    delete_breakpoints

    # Create a breakpoint, and associate a command-list to it, with
    # one command that deletes this breakpoint.
    gdb_test "break factorial" \
             "Breakpoint \[0-9\]+ at .*: file .*/run.c, line \[0-9\]+\." \
             "breakpoint in bp_deleted_in_command_test"
    
    send_gdb "commands\n"
    gdb_expect {
      -re "Type commands for when breakpoint .* is hit, one per line.*>" {
          pass "begin commands in bp_deleted_in_command_test"
      }
      -re "$gdb_prompt $" {fail "begin commands in bp_deleted_in_command_test"}
      timeout             {fail "(timeout) begin commands bp_deleted_in_command_test"}
    }
    send_gdb "silent\n"
    gdb_expect {
        -re ">"               {pass "add silent command"}
        -re "$gdb_prompt $"   {fail "add silent command"}
        timeout               {fail "(timeout) add silent command"}
    }
    send_gdb "clear factorial\n"
    gdb_expect {
        -re ">"               {pass "add clear command"}
        -re "$gdb_prompt $"   {fail "add clear command"}
        timeout               {fail "(timeout) add clear command"} }
    send_gdb "printf \"factorial command-list executed\\n\"\n"
    gdb_expect {
        -re ">"               {pass "add printf command"}
        -re "$gdb_prompt $"   {fail "add printf command"}
        timeout               {fail "(timeout) add printf command"}
    }
    send_gdb "cont\n"
    gdb_expect {
        -re ">"               {pass "add cont command"}
        -re "$gdb_prompt $"   {fail "add cont command"}
        timeout               {fail "(timeout) add cont command"} }
    send_gdb "end\n"
    gdb_expect {
        -re "$gdb_prompt $"   {pass "end commands"}
        timeout               {fail "(timeout) end commands"}
    }

    gdb_run_cmd
    gdb_expect {
        -re ".*factorial command-list executed.*1.*$gdb_prompt $" {
	    pass "run factorial until breakpoint"
        }
	-re ".*$gdb_prompt $" {
	    fail "run factorial until breakpoint"
	}
	default { fail "(timeout) run factorial until breakpoint" }
	timeout { fail "(timeout) run factorial until breakpoint" }
    }
}

proc temporary_breakpoint_commands {} {
    global gdb_prompt
    
    if [target_info exists noargs] { 
        verbose "Skipping temporary_breakpoint_commands because of noargs."
        return
    }

    gdb_test "set args 1" "" "set args in temporary_breakpoint_commands"
    delete_breakpoints

    # Create a temporary breakpoint, and associate a commands list to it.
    # This test will verify that this commands list is executed when the
    # breakpoint is hit.
    gdb_test "tbreak factorial" \
	    "Breakpoint \[0-9\]+ at .*: file .*/run.c, line \[0-9\]+\." \
	    "breakpoint in temporary_breakpoint_commands"
    
    send_gdb "commands\n"
    gdb_expect {
	-re "Type commands for when breakpoint .* is hit, one per line.*>" {
	    pass "begin commands in bp_deleted_in_command_test"
	}
	-re "$gdb_prompt $" {fail "begin commands in bp_deleted_in_command_test"}
	timeout             {fail "(timeout) begin commands bp_deleted_in_command_test"}
    }
    send_gdb "silent\n"
    gdb_expect {
	-re ">"               {pass "add silent tbreak command"}
	-re "$gdb_prompt $"   {fail "add silent tbreak command"}
	timeout               {fail "(timeout) add silent tbreak command"}
     }
    send_gdb "printf \"factorial tbreak commands executed\\n\"\n"
    gdb_expect {
	-re ">"               {pass "add printf tbreak command"}
	-re "$gdb_prompt $"   {fail "add printf tbreak command"}
	timeout               {fail "(timeout) add printf tbreak command"}
     }
    send_gdb "cont\n"
    gdb_expect {
	-re ">"               {pass "add cont tbreak command"}
	-re "$gdb_prompt $"   {fail "add cont tbreak command"}
	timeout               {fail "(timeout) add cont tbreak command"} }
    send_gdb "end\n"
    gdb_expect {
	-re "$gdb_prompt $"   {pass "end tbreak commands"}
	timeout               {fail "(timeout) end tbreak commands"}
     }

    gdb_run_cmd
    gdb_expect {
	-re ".*factorial tbreak commands executed.*1.*$gdb_prompt $" {
	    pass "run factorial until temporary breakpoint"
	}
	timeout { fail "(timeout) run factorial until temporary breakpoint" }
    }
}
  
gdbvar_simple_if_test
gdbvar_simple_while_test
gdbvar_complex_if_while_test
progvar_simple_if_test
progvar_simple_while_test
progvar_complex_if_while_test
if_while_breakpoint_command_test
infrun_breakpoint_command_test
breakpoint_command_test
user_defined_command_test
watchpoint_command_test
test_command_prompt_position
deprecated_command_test
bp_deleted_in_command_test
temporary_breakpoint_commands
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 225
#   Copyright (C) 1988, 1990, 1991, 1992 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

if $tracelevel then {
    strace $tracelevel
}

#
# test special commands (if, while, etc)
#
set prms_id 0
set bug_id 0

set testfile "run"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}
if  { [compile "${srcdir}/${subdir}/${srcfile} -g -o ${binfile}"] != "" } {
    perror "Couldn't compile ${srcfile}"
    return -1
}

gdb_exit
gdb_start
delete_breakpoints
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

proc gdbvar_simple_if_test {} {
    global prompt

    gdb_test "set \$foo = 0" "" "set foo in gdbvar_simple_if_test"
    # All this test should do is print 0xdeadbeef once.
    gdb_test "if \$foo == 1\np/x 0xfeedface\nelse\np/x 0xdeadbeef\nend" "\\\$\[0-9\]* = 0xdeadbeef" "gdbvar_simple_if_test #1"
    # All this test should do is print 0xfeedface once.
    gdb_test "if \$foo == 0\np/x 0xfeedface\nelse\np/x 0xdeadbeef\nend" "\\\$\[0-9\]* = 0xfeedface" "gdbvar_simple_if_test #2"
}

proc gdbvar_simple_while_test {} {
    global prompt

    gdb_test "set \$foo = 5" "" "set foo in gdbvar_simple_while_test"
    # This test should print 0xfeedface five times.
    gdb_test "while \$foo > 0\np/x 0xfeedface\nset \$foo -= 1\nend" "\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" "gdbvar_simple_while_test #1"
}

proc gdbvar_complex_if_while_test {} {
    global prompt

    gdb_test "set \$foo = 4" "" "set foo in gdbvar complex_if_while_test"
    # This test should alternate between 0xdeadbeef and 0xfeedface two times.
    gdb_test "while \$foo > 0\nset \$foo -= 1\nif \(\$foo % 2\) == 1\np/x 0xdeadbeef\nelse\np/x 0xfeedface\nend\nend" "\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" "gdbvar_complex_if_while_test #1"
}

proc progvar_simple_if_test {} {
    global prompt
    global noargs

    if $noargs { 
        verbose "Skipping progvar_simple_if_test because of noargs."
        return
    }

    gdb_test "set args 5" "" "set args in progvar_simple_if_test"
    if { ![runto factorial] } then { return }
    # All this test should do is print 0xdeadbeef once.
    gdb_test "if value == 1\np/x 0xfeedface\nelse\np/x 0xdeadbeef\nend" "\\\$\[0-9\]* = 0xdeadbeef" "progvar_simple_if_test #1"
    # All this test should do is print 0xfeedface once.
    gdb_test "if value == 5\np/x 0xfeedface\nelse\np/x 0xdeadbeef\nend" "\\\$\[0-9\]* = 0xfeedface" "progvar_simple_if_test #2"
}

proc progvar_simple_while_test {} {
    global prompt
    global noargs

    if $noargs { 
        verbose "Skipping progvar_simple_while_test because of noargs."
        return
    }

    gdb_test "set args 5" "" "set args in progvar_simple_while_test"
    if { ![runto factorial] } then { return }
    # This test should print 0xfeedface five times.
    gdb_test "while value > 0\np/x 0xfeedface\nset value -= 1\nend" "\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" "progvar_simple_while_test #1"
}

proc progvar_complex_if_while_test {} {
    global prompt
    global noargs

    if $noargs { 
        verbose "Skipping progvar_simple_if_while_test because of noargs."
        return
    }

    gdb_test "set args 4" "" "set args in progvar_complex_if_while_test"
    if { ![runto factorial] } then { return }
    # This test should alternate between 0xdeadbeef and 0xfeedface two times.
    gdb_test "while value > 0\nset value -= 1\nif \(value % 2\) == 1\np/x 0xdeadbeef\nelse\np/x 0xfeedface\nend\nend" "\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" "progvar_complex_if_while_test #1"
}

proc if_while_breakpoint_command_test {} {
    global noargs

    if $noargs { 
        verbose "Skipping if_while_breakpoint_command_test because of noargs."
        return
    }

    gdb_test "set args 5" "" "set args in if_while_breakpoint_command_test"
    if { ![runto factorial] } then { return }
    delete_breakpoints
    gdb_test "break factorial" "Breakpoint.*at.*"

    send "commands\n"
    expect {
	-re "End with" {
	    pass "commands in if_while_breakpoint_command_test"
	}
        default {
	    fail "(timeout or eof) commands in if_while_breakpoint_command_test"
	}
    }
    # This test should alternate between 0xdeadbeef and 0xfeedface two times.
    gdb_test "while value > 0\nset value -= 1\nif \(value % 2\) == 1\np/x 0xdeadbeef\nelse\np/x 0xfeedface\nend\nend\nend" "" "commands part 2 in if_while_breakpoint_command_test"
    gdb_test "continue" "\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" "if_while_breakpoint_command_test #1"
   gdb_test "info break" "while.*set.*if.*p/x.*else.*p/x.*end.*" "info break in if_while_breakpoint_command_test"
}

# Test that we can run the inferior from breakpoint commands.
proc infrun_breakpoint_command_test {} {
    global noargs

    if $noargs { 
        verbose "Skipping infrun_breakpoint_command_test because of noargs."
        return
    }

    gdb_test "set args 6" "" "set args in progvar_simple_while_test"
    if { ![runto factorial] } then { return }
    delete_breakpoints
    gdb_test "break factorial if value == 5" "Breakpoint.*at.*"
    gdb_test "commands\nstep\nstep\nstep\nstep\nbt\nend" \
	"End with.*" "commands in infrun_breakpoint_command_test"
    gdb_test "continue" "Breakpoint \[0-9\]*, factorial \\(value=5\\).*at.*
\[0-9\]*\[ 	\]*if \\(value > 1\\) \{.*
\[0-9\]*\[ 	\]*value \\*= factorial \\(value - 1\\);.*
factorial \\(value=4\\) at.*\[0-9\]*\[ 	\]*if \\(value > 1\\) \{.*
\[0-9\]*\[ 	\]*value \\*= factorial \\(value - 1\\);.*
factorial \\(value=3\\) at .*
\[0-9\]*\[ 	\]*if \\(value > 1\\) \{.*
#0  factorial \\(value=3\\).*
#1  \[0-9a-fx\]* in factorial \\(value=4\\).*
#2  \[0-9a-fx\]* in factorial \\(value=5\\).*
#3  \[0-9a-fx\]* in factorial \\(value=6\\).*
#4  \[0-9a-fx\]* in main \\(.*\\).*" \
	"continue in infrun_breakpoint_command_test"
}

proc breakpoint_command_test {} {
    global noargs

    if $noargs { 
        verbose "Skipping breakpoint_command_test because of noargs."
        return
    }

    gdb_test "set args 6" "" "set args in progvar_simple_while_test"
    if { ![runto factorial] } then { return }
    delete_breakpoints
    gdb_test "break factorial" "Breakpoint.*at.*"
    gdb_test "commands\nprintf \"Now the value is %d\\n\", value\nend" \
	"End with.*" "commands in breakpoint_command_test"
    gdb_test "continue" "Breakpoint \[0-9\]*, factorial.*Now the value is 5" \
	"continue in breakpoint_command_test"
    gdb_test "print value" " = 5" "print value in breakpoint_command_test"
}

# Test a simple user defined command (with arguments)
proc user_defined_command_test {} {
    global prompt

    gdb_test "set \$foo = 4" "" "set foo in user_defined_command_test"

    send "define mycommand\n"
    expect {
	-re "End with"  {
	    pass "define mycommand in user_defined_command_test"
	}
        default {
	    fail "(timeout or eof) define mycommand in user_defined_command_test"
	}
    }
    # This test should alternate between 0xdeadbeef and 0xfeedface two times.
    gdb_test "while \$arg0 > 0\nset \$arg0 -= 1\nif \(\$arg0 % 2\) == 1\np/x 0xdeadbeef\nelse\np/x 0xfeedface\nend\nend\nend" "" "enter commands in user_defined_command_test"

    gdb_test "mycommand \$foo" "\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface\[^\n\]*\n\\\$\[0-9\]* = 0xdeadbeef\[^\n\]*\n\\\$\[0-9\]* = 0xfeedface" "execute user defined command in user_defined_command_test"
   gdb_test "show user mycommand" "while.*set.*if.*p/x.*else.*p/x.*end.*" "display user command in user_defined_command_test"
}

gdbvar_simple_if_test
gdbvar_simple_while_test
gdbvar_complex_if_while_test
progvar_simple_if_test
progvar_simple_while_test
progvar_complex_if_while_test
if_while_breakpoint_command_test
infrun_breakpoint_command_test
breakpoint_command_test
user_defined_command_test
@
