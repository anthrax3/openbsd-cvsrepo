head	1.3;
access;
symbols
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.50
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.46
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.48
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.40
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.44
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.42
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.38
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.36
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.34
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.32
	OPENBSD_5_0:1.3.0.30
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.28
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.26
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.22
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.24
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.20
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.18
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.16
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.14
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.12
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.10
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	GDB_6_3:1.1.1.1
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2004.05.21.20.23.38;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.49.39;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.34.47;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.16.26;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.34.47;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@# Copyright 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
# 2003, 2004 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Fred Fish. (fnf@@cygnus.com)
# and modified by Bob Manson. (manson@@cygnus.com)

if $tracelevel then {
	strace $tracelevel
}

set prms_id 0
set bug_id 0

set testfile "callfuncs"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}

if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

# Create and source the file that provides information about the compiler
# used to compile the test case.

if [get_compiler_info ${binfile}] {
    return -1;
}

if {$hp_aCC_compiler} {
    set prototypes 1
} else {
    set prototypes 0
}

# Some targets can't do function calls, so don't even bother with this
# test.
if [target_info exists gdb,cannot_call_functions] {
    setup_xfail "*-*-*" 2416
    fail "This target can not call functions"
    continue
}

# Set the current language to C.  This counts as a test.  If it
# fails, then we skip the other tests.

proc set_lang_c {} {
    global gdb_prompt

    send_gdb "set language c\n"
    gdb_expect {
	-re ".*$gdb_prompt $" {}
	timeout { fail "set language c (timeout)" ; return 0; }
    }

    send_gdb "show language\n"
    gdb_expect {
	-re ".* source language is \"c\".*$gdb_prompt $" {
	    pass "set language to \"c\""
	    return 1
	}
	-re ".*$gdb_prompt $" {
	    fail "setting language to \"c\""
	    return 0
	}
	timeout {
	    fail "can't show language (timeout)"
	    return 0
	}
    }
}

# FIXME:  Before calling this proc, we should probably verify that
# we can call inferior functions and get a valid integral value
# returned.
# Note that it is OK to check for 0 or 1 as the returned values, because C
# specifies that the numeric value of a relational or logical expression
# (computed in the inferior) is 1 for true and 0 for false.

proc do_function_calls {} {
    global prototypes
    global gdb_prompt

    # We need to up this because this can be really slow on some boards.
    set timeout 60;

    gdb_test "p t_char_values(0,0)" " = 0"
    gdb_test "p t_char_values('a','b')" " = 1"
    gdb_test "p t_char_values(char_val1,char_val2)" " = 1"
    gdb_test "p t_char_values('a',char_val2)" " = 1"
    gdb_test "p t_char_values(char_val1,'b')" " = 1"

    gdb_test "p t_short_values(0,0)" " = 0"
    gdb_test "p t_short_values(10,-23)" " = 1"
    gdb_test "p t_short_values(short_val1,short_val2)" " = 1"
    gdb_test "p t_short_values(10,short_val2)" " = 1"
    gdb_test "p t_short_values(short_val1,-23)" " = 1"

    gdb_test "p t_int_values(0,0)" " = 0"
    gdb_test "p t_int_values(87,-26)" " = 1"
    gdb_test "p t_int_values(int_val1,int_val2)" " = 1"
    gdb_test "p t_int_values(87,int_val2)" " = 1"
    gdb_test "p t_int_values(int_val1,-26)" " = 1"

    gdb_test "p t_long_values(0,0)" " = 0"
    gdb_test "p t_long_values(789,-321)" " = 1"
    gdb_test "p t_long_values(long_val1,long_val2)" " = 1"
    gdb_test "p t_long_values(789,long_val2)" " = 1"
    gdb_test "p t_long_values(long_val1,-321)" " = 1"

    if ![target_info exists gdb,skip_float_tests] {
	gdb_test "p t_float_values(0.0,0.0)" " = 0"

	# These next four tests fail on the mn10300.
	# The first value is passed in regs, the other in memory.
	# Gcc emits different stabs for the two parameters; the first is
	# claimed to be a float, the second a double.
	# dbxout.c in gcc claims this is the desired behavior.
	setup_xfail "mn10300-*-*"
	gdb_test "p t_float_values(3.14159,-2.3765)" " = 1"
	setup_xfail "mn10300-*-*"
	gdb_test "p t_float_values(float_val1,float_val2)" " = 1"
	setup_xfail "mn10300-*-*"
	gdb_test "p t_float_values(3.14159,float_val2)" " = 1"
	setup_xfail "mn10300-*-*"
	gdb_test "p t_float_values(float_val1,-2.3765)" " = 1"

	# Test passing of arguments which might not be widened.
	gdb_test "p t_float_values2(0.0,0.0)" " = 0"

	# Although PR 5318 mentions SunOS specifically, this seems
	# to be a generic problem on quite a few platforms.
	if $prototypes then {
	    setup_xfail "sparc-*-*" "mips*-*-*" 5318
	    if { ! [test_compiler_info gcc-*-*] } then {
		setup_xfail "alpha-dec-osf2*" "i*86-*-sysv4*" 5318
	    }
	}
        
	gdb_test "p t_float_values2(3.14159,float_val2)" " = 1"

	gdb_test "p t_small_values(1,2,3,4,5,6,7,8,9,10)" " = 55"

	gdb_test "p t_double_values(0.0,0.0)" " = 0"
	gdb_test "p t_double_values(45.654,-67.66)" " = 1"
	gdb_test "p t_double_values(double_val1,double_val2)" " = 1"
	gdb_test "p t_double_values(45.654,double_val2)" " = 1"
	gdb_test "p t_double_values(double_val1,-67.66)" " = 1"
    }

    gdb_test "p t_string_values(string_val2,string_val1)" " = 0"
    gdb_test "p t_string_values(string_val1,string_val2)" " = 1"
    gdb_test "p t_string_values(\"string 1\",\"string 2\")" " = 1"
    gdb_test "p t_string_values(\"string 1\",string_val2)" " = 1"
    gdb_test "p t_string_values(string_val1,\"string 2\")" " = 1"

    gdb_test "p t_char_array_values(char_array_val2,char_array_val1)" " = 0"
    gdb_test "p t_char_array_values(char_array_val1,char_array_val2)" " = 1"
    gdb_test "p t_char_array_values(\"carray 1\",\"carray 2\")" " = 1"
    gdb_test "p t_char_array_values(\"carray 1\",char_array_val2)" " = 1"
    gdb_test "p t_char_array_values(char_array_val1,\"carray 2\")" " = 1"

    gdb_test "p doubleit(4)" " = 8"
    gdb_test "p add(4,5)" " = 9"
    gdb_test "p t_func_values(func_val2,func_val1)" " = 0"
    gdb_test "p t_func_values(func_val1,func_val2)" " = 1"

    # GDB currently screws up the passing of function parameters for
    # ABIs that use function descriptors.  Instead of passing the
    # address of te function descriptor, GDB passes the address of the
    # function body.  This results in the called function treating the
    # first few instructions of the function proper as a descriptor
    # and attempting a jump through that (a totally random address).
    setup_kfail "rs6000*-*-aix*" gdb/1457
    setup_kfail "powerpc*-*-aix*" gdb/1457
    setup_kfail "powerpc64*-*-*" gdb/1457
    setup_kfail hppa*-*-hpux* gdb/1457
    gdb_test "p t_func_values(add,func_val2)" " = 1"
    setup_kfail "rs6000*-*-aix*" gdb/1457
    setup_kfail "powerpc*-*-aix*" gdb/1457
    setup_kfail "powerpc64*-*-*" gdb/1457
    setup_kfail hppa*-*-hpux* gdb/1457
    gdb_test "p t_func_values(func_val1,doubleit)" " = 1"
    setup_kfail "rs6000*-*-aix*" gdb/1457
    setup_kfail "powerpc*-*-aix*" gdb/1457
    setup_kfail "powerpc64*-*-*" gdb/1457
    setup_kfail hppa*-*-hpux* gdb/1457
    gdb_test "p t_call_add(add,3,4)" " = 7"
    gdb_test "p t_call_add(func_val1,3,4)" " = 7"

    gdb_test "p t_enum_value1(enumval1)" " = 1"
    gdb_test "p t_enum_value1(enum_val1)" " = 1"
    gdb_test "p t_enum_value1(enum_val2)" " = 0"

    gdb_test "p t_enum_value2(enumval2)" " = 1"
    gdb_test "p t_enum_value2(enum_val2)" " = 1"
    gdb_test "p t_enum_value2(enum_val1)" " = 0"

    gdb_test "p sum_args(1,{2})" " = 2"
    gdb_test "p sum_args(2,{2,3})" " = 5"
    gdb_test "p sum_args(3,{2,3,4})" " = 9"
    gdb_test "p sum_args(4,{2,3,4,5})" " = 14"

    gdb_test "p sum10 (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)" " = 55"

    gdb_test "p cmp10 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)" " = 1"

    gdb_test "p t_structs_c(struct_val1)" "= 120 'x'" \
	"call inferior func with struct - returns char"
    gdb_test "p t_structs_s(struct_val1)" "= 87" \
	"call inferior func with struct - returns short"
    gdb_test "p t_structs_i(struct_val1)" "= 76" \
	"call inferior func with struct - returns int"
    gdb_test "p t_structs_l(struct_val1)" "= 51" \
	"call inferior func with struct - returns long"
    gdb_test "p t_structs_f(struct_val1)" "= 2.12.*" \
       	"call inferior func with struct - returns float"
    gdb_test "p t_structs_d(struct_val1)" "= 9.87.*" \
    	"call inferior func with struct - returns double"
    gdb_test "p t_structs_a(struct_val1)" "= (.unsigned char .. )?\"foo\"" \
    	"call inferior func with struct - returns char *"
}

# Procedure to get current content of all registers.
global all_registers_content
set all_registers_content ""
proc do_get_all_registers { } {
    global gdb_prompt
    global expect_out
    global all_registers_content

    set all_registers_content ""
    send_gdb "info all-registers\n"
    gdb_expect {
	-re "info all-registers\r\n(.*)$gdb_prompt $" {
	    set all_registers_content $expect_out(1,string)
	}
	default {}
    }
}

# Start with a fresh gdb.

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

gdb_test "set print sevenbit-strings" ""
gdb_test "set print address off" ""
gdb_test "set width 0" ""

if { $hp_aCC_compiler } {
    # Do not set language explicitly to 'C'.  This will cause aCC
    # tests to fail because promotion rules are different.  Just let
    # the language be set to the default.

    if { ![runto_main] } {
	gdb_suppress_tests;
    }

    # However, turn off overload-resolution for aCC.  Having it on causes
    # a lot of failures.

    gdb_test "set overload-resolution 0" ".*"
} else {
    if { ![set_lang_c] } {
	gdb_suppress_tests;
    } else {
	if { ![runto_main] } {
	    gdb_suppress_tests;
	}
    }
}

get_debug_format

# Make sure that malloc gets called and that the floating point unit
# is initialized via a call to t_double_values.
gdb_test "next" "t_double_values\\(double_val1, double_val2\\);.*" \
  "next to t_double_values"
gdb_test "next" "t_structs_c\\(struct_val1\\);.*" \
  "next to t_structs_c"

# Save all register contents.
do_get_all_registers
set old_reg_content $all_registers_content

# Perform function calls.
do_function_calls

# Check if all registers still have the same value.
do_get_all_registers
set new_reg_content $all_registers_content
if ![string compare $old_reg_content $new_reg_content] then {
    pass "gdb function calls preserve register contents"
} else {
    set old_reg_content $all_registers_content
    fail "gdb function calls preserve register contents"
}

# Set breakpoint at a function we will call from gdb.
gdb_breakpoint add

# Call function (causing a breakpoint hit in the call dummy) and do a continue,
# make sure we are back at main and still have the same register contents.
gdb_test "print add(4,5)" \
	"The program being debugged stopped while.*" \
	"stop at breakpoint in call dummy function"
gdb_test "continue" "Continuing.*" "continue from call dummy breakpoint"
if ![gdb_test "bt 2" \
	      "#0  main.*" \
	      "bt after continuing from call dummy breakpoint"] then {
    do_get_all_registers
    set new_reg_content $all_registers_content
    if ![string compare $old_reg_content $new_reg_content] then {
	pass "continue after stop in call dummy preserves register contents"
    } else {
	fail "continue after stop in call dummy preserves register contents"
    }
}

# Call function (causing a breakpoint hit in the call dummy) and do a finish,
# make sure we are back at main and still have the same register contents.
gdb_test "print add(4,5)" "The program being debugged stopped while.*" \
	"call function causing a breakpoint then do a finish"
gdb_test "finish" \
	 "Value returned is .* = 9" \
	 "finish from call dummy breakpoint returns correct value"
if ![gdb_test "bt 2" \
	      "#0  main.*" \
	      "bt after finishing from call dummy breakpoint"] then {
    do_get_all_registers
    set new_reg_content $all_registers_content
    if ![string compare $old_reg_content $new_reg_content] then {
	pass "finish after stop in call dummy preserves register contents"
    } else {
	fail "finish after stop in call dummy preserves register contents"
    }
}

# Call function (causing a breakpoint hit in the call dummy) and do a return
# with a value, make sure we are back at main with the same register contents.
gdb_test "print add(4,5)" "The program being debugged stopped while.*" \
	"call function causing a breakpoint and then do a return"
if ![gdb_test "return 7" \
	      "#0  main.*" \
	      "back at main after return from call dummy breakpoint" \
	      "Make add return now. .y or n.*" \
	      "y"] then {
    do_get_all_registers
    set new_reg_content $all_registers_content
    if ![string compare $old_reg_content $new_reg_content] then {
	pass "return after stop in call dummy preserves register contents"
    } else {
	fail "return after stop in call dummy preserves register contents"
    }
}

# Call function (causing a breakpoint hit in the call dummy), and
# call another function from the call dummy frame (thereby setting up
# several nested call dummy frames).  Test that backtrace and finish
# work when several call dummies are nested.
gdb_breakpoint sum10
gdb_breakpoint t_small_values
gdb_test "print add(2,3)" "The program being debugged stopped while.*" \
	"stop at nested call level 1"
gdb_test "backtrace" \
	"\#0  add \\(a=2, b=3\\).*\#1  <function called from gdb>.*\#2  main.*" \
	"backtrace at nested call level 1"
gdb_test "print add(4,5)" "The program being debugged stopped while.*" \
	"stop at nested call level 2"
gdb_test "backtrace" \
	"\#0  add \\(a=4, b=5\\).*\#1  <function called from gdb>.*\#2  add \\(a=2, b=3\\).*\#3  <function called from gdb>.*\#4  main.*" \
	"backtrace at nested call level 2"
gdb_test "print sum10(2,4,6,8,10,12,14,16,18,20)" \
	"The program being debugged stopped while.*" \
	"stop at nested call level 3"
gdb_test "backtrace" \
	"\#0  sum10 \\(i0=2, i1=4, i2=6, i3=8, i4=10, i5=12, i6=14, i7=16, i8=18, i9=20\\).*\#1  <function called from gdb>.*\#2  add \\(a=4, b=5\\).*\#3  <function called from gdb>.*\#4  add \\(a=2, b=3\\).*\#5  <function called from gdb>.*\#6  main.*" \
	"backtrace at nested call level 3"
gdb_test "print t_small_values(1,3,5,7,9,11,13,15,17,19)" \
	"The program being debugged stopped while.*" \
	"stop at nested call level 4"
gdb_test "backtrace" \
	"\#0  t_small_values \\(arg1=1 '.001', arg2=3, arg3=5, arg4=7 '.a', arg5=9, arg6=11 '.v', arg7=13, arg8=15, arg9=17, arg10=19\\).*\#2  sum10 \\(i0=2, i1=4, i2=6, i3=8, i4=10, i5=12, i6=14, i7=16, i8=18, i9=20\\).*\#3  <function called from gdb>.*\#4  add \\(a=4, b=5\\).*\#5  <function called from gdb>.*\#6  add \\(a=2, b=3\\).*\#7  <function called from gdb>.*\#8  main.*" \
	"backtrace at nested call level 4"
gdb_test "finish" "Value returned is .* = 100" \
	"Finish from nested call level 4"
gdb_test "backtrace" \
	"\#0  sum10 \\(i0=2, i1=4, i2=6, i3=8, i4=10, i5=12, i6=14, i7=16, i8=18, i9=20\\).*\#1  <function called from gdb>.*\#2  add \\(a=4, b=5\\).*\#3  <function called from gdb>.*\#4  add \\(a=2, b=3\\).*\#5  <function called from gdb>.*\#6  main.*" \
	"backtrace after finish from nested call level 4"
gdb_test "finish" "Value returned is .* = 110" \
	"Finish from nested call level 3"
gdb_test "backtrace" \
	"\#0  add \\(a=4, b=5\\).*\#1  <function called from gdb>.*\#2  add \\(a=2, b=3\\).*\#3  <function called from gdb>.*\#4  main.*" \
	"backtrace after finish from nested call level 3"
gdb_test "finish" "Value returned is .* = 9" \
	"Finish from nested call level 2"
gdb_test "backtrace" \
	"\#0  add \\(a=2, b=3\\).*\#1  <function called from gdb>.*\#2  main.*" \
	"backtrace after finish from nested call level 2"
gdb_test "finish" "Value returned is .* = 5" \
	"Finish from nested call level 1"
gdb_test "backtrace" "\#0  main .*" \
	"backtrace after finish from nested call level 1"

do_get_all_registers
set new_reg_content $all_registers_content
if ![string compare $old_reg_content $new_reg_content] then {
    pass "nested call dummies preserve register contents"
} else {
    fail "nested call dummies preserve register contents"
}

return 0

@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d1 2
a2 1
# Copyright (C) 1992 Free Software Foundation, Inc.
d16 1
a16 1
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d22 1
a30 1
set prototypes 0
d35 2
a36 12
# build the first test case
execute_anywhere "rm -f ${binfile}.ci"
execute_anywhere "echo set prototypes 1 > ${binfile}.ci"
if  { [compile "-g ${srcdir}/${subdir}/${srcfile} -o ${binfile} "] != "" } {
    execute_anywhere "rm -f ${binfile}.ci"    
    # built the second test case since we can't use prototypes
    warning "Prototypes not supported, rebuilding with -DNO_PROTOTYPES"
    execute_anywhere "echo set prototypes 0 > ${binfile}.ci"
    if  { [compile "-g -DNO_PROTOTYPES ${srcdir}/${subdir}/${srcfile} -o ${binfile} "] != "" } {
	perror "Couldn't compile ${testfile}.c"
	return -1
    }
d41 9
a49 11
if  { [compile "-E ${srcdir}/${subdir}/compiler.c >> ${binfile}.ci"] != "" } {
    perror "Couldn't make ${binfile}.ci"
    return -1
}
source ${binfile}.ci

# The a29k can't call functions, so don't even bother with this test.
if [istarget "a29k-*-udi"] then {
    setup_xfail "a29k-*-udi" 2416
    fail "a29k-*-udi can not call functions"
    continue
d52 5
a56 4
# The h8300 simulator can't call functions, so don't even bother with this test.
if [istarget "h8300*-*-*"] then {
    setup_xfail "h8300*-*-*" 
    fail "h8300*-*-* simulator can not call functions"
d59 1
d64 1
a64 1
    global prompt
d66 4
a69 4
    send "set language c\n"
    expect {
	-re ".*$prompt $" {}
	timeout { fail "set language c (timeout)" ; return 0 }
d72 3
a74 3
    send "show language\n"
    expect {
	-re ".* source language is \"c\".*$prompt $" {
d78 1
a78 1
	-re ".*$prompt $" {
d98 4
a101 1
    global gcc_compiled
d127 39
a165 25
    gdb_test "p t_float_values(0.0,0.0)" " = 0"
    gdb_test "p t_float_values(3.14159,-2.3765)" " = 1"
    gdb_test "p t_float_values(float_val1,float_val2)" " = 1"
    gdb_test "p t_float_values(3.14159,float_val2)" " = 1"
    gdb_test "p t_float_values(float_val1,-2.3765)" " = 1"

    # Test passing of arguments which might not be widened.
    gdb_test "p t_float_values2(0.0,0.0)" " = 0"

    # Although PR 5318 mentions SunOS specifically, this seems
    # to be a generic problem on quite a few platforms.
    if $prototypes then {
        setup_xfail "hppa*-*-*" "sparc-*-*" "mips*-*-*" 5318
	if {!$gcc_compiled} then {
	    setup_xfail "alpha-dec-osf2*" "i*86-*-sysv4*" 5318
	}
    }
    gdb_test "p t_float_values2(3.14159,float_val2)" " = 1"
    gdb_test "p t_small_values(1,2,3,4,5,6,7,8,9,10)" " = 55"

    gdb_test "p t_double_values(0.0,0.0)" " = 0"
    gdb_test "p t_double_values(45.654,-67.66)" " = 1"
    gdb_test "p t_double_values(double_val1,double_val2)" " = 1"
    gdb_test "p t_double_values(45.654,double_val2)" " = 1"
    gdb_test "p t_double_values(double_val1,-67.66)" " = 1"
d184 10
a193 9
    # On the rs6000, we need to pass the address of the trampoline routine,
    # not the address of add itself.  I don't know how to go from add to
    # the address of the trampoline.  Similar problems exist on the HPPA,
    # and in fact can present an unsolvable problem as the stubs may not
    # even exist in the user's program.  We've slightly recoded t_func_values
    # to avoid such problems in the common case.  This may or may not help
    # the RS6000.
    setup_xfail "rs6000*-*-*"
    setup_xfail "powerpc*-*-*"
d195 4
a198 3

    setup_xfail "rs6000*-*-*"
    setup_xfail "powerpc*-*-*"
d200 5
a204 1

a206 4
    setup_xfail "rs6000*-*-*"
    setup_xfail "powerpc*-*-*"
    gdb_test "p t_call_add(add,3,4)" " = 7"

d219 1
d222 2
d227 1
a227 1
	"call inferior func with struct -  returns short"
a231 1
    setup_xfail "i*86-*-*"
d233 1
a233 2
	"call inferior func with struct - returns float"
    setup_xfail "i*86-*-*"
d235 1
a235 1
	"call inferior func with struct - returns double"
d237 2
a238 1
	"call inferior func with struct - returns char *"
d240 16
d265 20
a284 7
send "set print sevenbit-strings\n" ; expect -re "$prompt $"
send "set print address off\n" ; expect -re "$prompt $"
send "set width 0\n" ; expect -re "$prompt $"

if [set_lang_c] then {
    if [runto_main] then {
	do_function_calls
d286 3
a288 1
	fail "C function calling tests suppressed"
d290 23
d314 2
a315 1
    fail "C function calling tests suppressed"
d317 115
d433 1
@


1.1
log
@file callfuncs.exp was initially added on branch CYGNUS.
@
text
@d1 250
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 433
# Copyright 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
# 2003, 2004 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Fred Fish. (fnf@@cygnus.com)
# and modified by Bob Manson. (manson@@cygnus.com)

if $tracelevel then {
	strace $tracelevel
}

set prms_id 0
set bug_id 0

set testfile "callfuncs"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}

if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

# Create and source the file that provides information about the compiler
# used to compile the test case.

if [get_compiler_info ${binfile}] {
    return -1;
}

if {$hp_aCC_compiler} {
    set prototypes 1
} else {
    set prototypes 0
}

# Some targets can't do function calls, so don't even bother with this
# test.
if [target_info exists gdb,cannot_call_functions] {
    setup_xfail "*-*-*" 2416
    fail "This target can not call functions"
    continue
}

# Set the current language to C.  This counts as a test.  If it
# fails, then we skip the other tests.

proc set_lang_c {} {
    global gdb_prompt

    send_gdb "set language c\n"
    gdb_expect {
	-re ".*$gdb_prompt $" {}
	timeout { fail "set language c (timeout)" ; return 0; }
    }

    send_gdb "show language\n"
    gdb_expect {
	-re ".* source language is \"c\".*$gdb_prompt $" {
	    pass "set language to \"c\""
	    return 1
	}
	-re ".*$gdb_prompt $" {
	    fail "setting language to \"c\""
	    return 0
	}
	timeout {
	    fail "can't show language (timeout)"
	    return 0
	}
    }
}

# FIXME:  Before calling this proc, we should probably verify that
# we can call inferior functions and get a valid integral value
# returned.
# Note that it is OK to check for 0 or 1 as the returned values, because C
# specifies that the numeric value of a relational or logical expression
# (computed in the inferior) is 1 for true and 0 for false.

proc do_function_calls {} {
    global prototypes
    global gdb_prompt

    # We need to up this because this can be really slow on some boards.
    set timeout 60;

    gdb_test "p t_char_values(0,0)" " = 0"
    gdb_test "p t_char_values('a','b')" " = 1"
    gdb_test "p t_char_values(char_val1,char_val2)" " = 1"
    gdb_test "p t_char_values('a',char_val2)" " = 1"
    gdb_test "p t_char_values(char_val1,'b')" " = 1"

    gdb_test "p t_short_values(0,0)" " = 0"
    gdb_test "p t_short_values(10,-23)" " = 1"
    gdb_test "p t_short_values(short_val1,short_val2)" " = 1"
    gdb_test "p t_short_values(10,short_val2)" " = 1"
    gdb_test "p t_short_values(short_val1,-23)" " = 1"

    gdb_test "p t_int_values(0,0)" " = 0"
    gdb_test "p t_int_values(87,-26)" " = 1"
    gdb_test "p t_int_values(int_val1,int_val2)" " = 1"
    gdb_test "p t_int_values(87,int_val2)" " = 1"
    gdb_test "p t_int_values(int_val1,-26)" " = 1"

    gdb_test "p t_long_values(0,0)" " = 0"
    gdb_test "p t_long_values(789,-321)" " = 1"
    gdb_test "p t_long_values(long_val1,long_val2)" " = 1"
    gdb_test "p t_long_values(789,long_val2)" " = 1"
    gdb_test "p t_long_values(long_val1,-321)" " = 1"

    if ![target_info exists gdb,skip_float_tests] {
	gdb_test "p t_float_values(0.0,0.0)" " = 0"

	# These next four tests fail on the mn10300.
	# The first value is passed in regs, the other in memory.
	# Gcc emits different stabs for the two parameters; the first is
	# claimed to be a float, the second a double.
	# dbxout.c in gcc claims this is the desired behavior.
	setup_xfail "mn10300-*-*"
	gdb_test "p t_float_values(3.14159,-2.3765)" " = 1"
	setup_xfail "mn10300-*-*"
	gdb_test "p t_float_values(float_val1,float_val2)" " = 1"
	setup_xfail "mn10300-*-*"
	gdb_test "p t_float_values(3.14159,float_val2)" " = 1"
	setup_xfail "mn10300-*-*"
	gdb_test "p t_float_values(float_val1,-2.3765)" " = 1"

	# Test passing of arguments which might not be widened.
	gdb_test "p t_float_values2(0.0,0.0)" " = 0"

	# Although PR 5318 mentions SunOS specifically, this seems
	# to be a generic problem on quite a few platforms.
	if $prototypes then {
	    setup_xfail "sparc-*-*" "mips*-*-*" 5318
	    if { ! [test_compiler_info gcc-*-*] } then {
		setup_xfail "alpha-dec-osf2*" "i*86-*-sysv4*" 5318
	    }
	}
        
	gdb_test "p t_float_values2(3.14159,float_val2)" " = 1"

	gdb_test "p t_small_values(1,2,3,4,5,6,7,8,9,10)" " = 55"

	gdb_test "p t_double_values(0.0,0.0)" " = 0"
	gdb_test "p t_double_values(45.654,-67.66)" " = 1"
	gdb_test "p t_double_values(double_val1,double_val2)" " = 1"
	gdb_test "p t_double_values(45.654,double_val2)" " = 1"
	gdb_test "p t_double_values(double_val1,-67.66)" " = 1"
    }

    gdb_test "p t_string_values(string_val2,string_val1)" " = 0"
    gdb_test "p t_string_values(string_val1,string_val2)" " = 1"
    gdb_test "p t_string_values(\"string 1\",\"string 2\")" " = 1"
    gdb_test "p t_string_values(\"string 1\",string_val2)" " = 1"
    gdb_test "p t_string_values(string_val1,\"string 2\")" " = 1"

    gdb_test "p t_char_array_values(char_array_val2,char_array_val1)" " = 0"
    gdb_test "p t_char_array_values(char_array_val1,char_array_val2)" " = 1"
    gdb_test "p t_char_array_values(\"carray 1\",\"carray 2\")" " = 1"
    gdb_test "p t_char_array_values(\"carray 1\",char_array_val2)" " = 1"
    gdb_test "p t_char_array_values(char_array_val1,\"carray 2\")" " = 1"

    gdb_test "p doubleit(4)" " = 8"
    gdb_test "p add(4,5)" " = 9"
    gdb_test "p t_func_values(func_val2,func_val1)" " = 0"
    gdb_test "p t_func_values(func_val1,func_val2)" " = 1"

    # GDB currently screws up the passing of function parameters for
    # ABIs that use function descriptors.  Instead of passing the
    # address of te function descriptor, GDB passes the address of the
    # function body.  This results in the called function treating the
    # first few instructions of the function proper as a descriptor
    # and attempting a jump through that (a totally random address).
    setup_kfail "rs6000*-*-aix*" gdb/1457
    setup_kfail "powerpc*-*-aix*" gdb/1457
    setup_kfail "powerpc64*-*-*" gdb/1457
    setup_kfail hppa*-*-hpux* gdb/1457
    gdb_test "p t_func_values(add,func_val2)" " = 1"
    setup_kfail "rs6000*-*-aix*" gdb/1457
    setup_kfail "powerpc*-*-aix*" gdb/1457
    setup_kfail "powerpc64*-*-*" gdb/1457
    setup_kfail hppa*-*-hpux* gdb/1457
    gdb_test "p t_func_values(func_val1,doubleit)" " = 1"
    setup_kfail "rs6000*-*-aix*" gdb/1457
    setup_kfail "powerpc*-*-aix*" gdb/1457
    setup_kfail "powerpc64*-*-*" gdb/1457
    setup_kfail hppa*-*-hpux* gdb/1457
    gdb_test "p t_call_add(add,3,4)" " = 7"
    gdb_test "p t_call_add(func_val1,3,4)" " = 7"

    gdb_test "p t_enum_value1(enumval1)" " = 1"
    gdb_test "p t_enum_value1(enum_val1)" " = 1"
    gdb_test "p t_enum_value1(enum_val2)" " = 0"

    gdb_test "p t_enum_value2(enumval2)" " = 1"
    gdb_test "p t_enum_value2(enum_val2)" " = 1"
    gdb_test "p t_enum_value2(enum_val1)" " = 0"

    gdb_test "p sum_args(1,{2})" " = 2"
    gdb_test "p sum_args(2,{2,3})" " = 5"
    gdb_test "p sum_args(3,{2,3,4})" " = 9"
    gdb_test "p sum_args(4,{2,3,4,5})" " = 14"

    gdb_test "p sum10 (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)" " = 55"

    gdb_test "p cmp10 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)" " = 1"

    gdb_test "p t_structs_c(struct_val1)" "= 120 'x'" \
	"call inferior func with struct - returns char"
    gdb_test "p t_structs_s(struct_val1)" "= 87" \
	"call inferior func with struct - returns short"
    gdb_test "p t_structs_i(struct_val1)" "= 76" \
	"call inferior func with struct - returns int"
    gdb_test "p t_structs_l(struct_val1)" "= 51" \
	"call inferior func with struct - returns long"
    gdb_test "p t_structs_f(struct_val1)" "= 2.12.*" \
       	"call inferior func with struct - returns float"
    gdb_test "p t_structs_d(struct_val1)" "= 9.87.*" \
    	"call inferior func with struct - returns double"
    gdb_test "p t_structs_a(struct_val1)" "= (.unsigned char .. )?\"foo\"" \
    	"call inferior func with struct - returns char *"
}

# Procedure to get current content of all registers.
global all_registers_content
set all_registers_content ""
proc do_get_all_registers { } {
    global gdb_prompt
    global expect_out
    global all_registers_content

    set all_registers_content ""
    send_gdb "info all-registers\n"
    gdb_expect {
	-re "info all-registers\r\n(.*)$gdb_prompt $" {
	    set all_registers_content $expect_out(1,string)
	}
	default {}
    }
}

# Start with a fresh gdb.

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

gdb_test "set print sevenbit-strings" ""
gdb_test "set print address off" ""
gdb_test "set width 0" ""

if { $hp_aCC_compiler } {
    # Do not set language explicitly to 'C'.  This will cause aCC
    # tests to fail because promotion rules are different.  Just let
    # the language be set to the default.

    if { ![runto_main] } {
	gdb_suppress_tests;
    }

    # However, turn off overload-resolution for aCC.  Having it on causes
    # a lot of failures.

    gdb_test "set overload-resolution 0" ".*"
} else {
    if { ![set_lang_c] } {
	gdb_suppress_tests;
    } else {
	if { ![runto_main] } {
	    gdb_suppress_tests;
	}
    }
}

get_debug_format

# Make sure that malloc gets called and that the floating point unit
# is initialized via a call to t_double_values.
gdb_test "next" "t_double_values\\(double_val1, double_val2\\);.*" \
  "next to t_double_values"
gdb_test "next" "t_structs_c\\(struct_val1\\);.*" \
  "next to t_structs_c"

# Save all register contents.
do_get_all_registers
set old_reg_content $all_registers_content

# Perform function calls.
do_function_calls

# Check if all registers still have the same value.
do_get_all_registers
set new_reg_content $all_registers_content
if ![string compare $old_reg_content $new_reg_content] then {
    pass "gdb function calls preserve register contents"
} else {
    set old_reg_content $all_registers_content
    fail "gdb function calls preserve register contents"
}

# Set breakpoint at a function we will call from gdb.
gdb_breakpoint add

# Call function (causing a breakpoint hit in the call dummy) and do a continue,
# make sure we are back at main and still have the same register contents.
gdb_test "print add(4,5)" \
	"The program being debugged stopped while.*" \
	"stop at breakpoint in call dummy function"
gdb_test "continue" "Continuing.*" "continue from call dummy breakpoint"
if ![gdb_test "bt 2" \
	      "#0  main.*" \
	      "bt after continuing from call dummy breakpoint"] then {
    do_get_all_registers
    set new_reg_content $all_registers_content
    if ![string compare $old_reg_content $new_reg_content] then {
	pass "continue after stop in call dummy preserves register contents"
    } else {
	fail "continue after stop in call dummy preserves register contents"
    }
}

# Call function (causing a breakpoint hit in the call dummy) and do a finish,
# make sure we are back at main and still have the same register contents.
gdb_test "print add(4,5)" "The program being debugged stopped while.*" \
	"call function causing a breakpoint then do a finish"
gdb_test "finish" \
	 "Value returned is .* = 9" \
	 "finish from call dummy breakpoint returns correct value"
if ![gdb_test "bt 2" \
	      "#0  main.*" \
	      "bt after finishing from call dummy breakpoint"] then {
    do_get_all_registers
    set new_reg_content $all_registers_content
    if ![string compare $old_reg_content $new_reg_content] then {
	pass "finish after stop in call dummy preserves register contents"
    } else {
	fail "finish after stop in call dummy preserves register contents"
    }
}

# Call function (causing a breakpoint hit in the call dummy) and do a return
# with a value, make sure we are back at main with the same register contents.
gdb_test "print add(4,5)" "The program being debugged stopped while.*" \
	"call function causing a breakpoint and then do a return"
if ![gdb_test "return 7" \
	      "#0  main.*" \
	      "back at main after return from call dummy breakpoint" \
	      "Make add return now. .y or n.*" \
	      "y"] then {
    do_get_all_registers
    set new_reg_content $all_registers_content
    if ![string compare $old_reg_content $new_reg_content] then {
	pass "return after stop in call dummy preserves register contents"
    } else {
	fail "return after stop in call dummy preserves register contents"
    }
}

# Call function (causing a breakpoint hit in the call dummy), and
# call another function from the call dummy frame (thereby setting up
# several nested call dummy frames).  Test that backtrace and finish
# work when several call dummies are nested.
gdb_breakpoint sum10
gdb_breakpoint t_small_values
gdb_test "print add(2,3)" "The program being debugged stopped while.*" \
	"stop at nested call level 1"
gdb_test "backtrace" \
	"\#0  add \\(a=2, b=3\\).*\#1  <function called from gdb>.*\#2  main.*" \
	"backtrace at nested call level 1"
gdb_test "print add(4,5)" "The program being debugged stopped while.*" \
	"stop at nested call level 2"
gdb_test "backtrace" \
	"\#0  add \\(a=4, b=5\\).*\#1  <function called from gdb>.*\#2  add \\(a=2, b=3\\).*\#3  <function called from gdb>.*\#4  main.*" \
	"backtrace at nested call level 2"
gdb_test "print sum10(2,4,6,8,10,12,14,16,18,20)" \
	"The program being debugged stopped while.*" \
	"stop at nested call level 3"
gdb_test "backtrace" \
	"\#0  sum10 \\(i0=2, i1=4, i2=6, i3=8, i4=10, i5=12, i6=14, i7=16, i8=18, i9=20\\).*\#1  <function called from gdb>.*\#2  add \\(a=4, b=5\\).*\#3  <function called from gdb>.*\#4  add \\(a=2, b=3\\).*\#5  <function called from gdb>.*\#6  main.*" \
	"backtrace at nested call level 3"
gdb_test "print t_small_values(1,3,5,7,9,11,13,15,17,19)" \
	"The program being debugged stopped while.*" \
	"stop at nested call level 4"
gdb_test "backtrace" \
	"\#0  t_small_values \\(arg1=1 '.001', arg2=3, arg3=5, arg4=7 '.a', arg5=9, arg6=11 '.v', arg7=13, arg8=15, arg9=17, arg10=19\\).*\#2  sum10 \\(i0=2, i1=4, i2=6, i3=8, i4=10, i5=12, i6=14, i7=16, i8=18, i9=20\\).*\#3  <function called from gdb>.*\#4  add \\(a=4, b=5\\).*\#5  <function called from gdb>.*\#6  add \\(a=2, b=3\\).*\#7  <function called from gdb>.*\#8  main.*" \
	"backtrace at nested call level 4"
gdb_test "finish" "Value returned is .* = 100" \
	"Finish from nested call level 4"
gdb_test "backtrace" \
	"\#0  sum10 \\(i0=2, i1=4, i2=6, i3=8, i4=10, i5=12, i6=14, i7=16, i8=18, i9=20\\).*\#1  <function called from gdb>.*\#2  add \\(a=4, b=5\\).*\#3  <function called from gdb>.*\#4  add \\(a=2, b=3\\).*\#5  <function called from gdb>.*\#6  main.*" \
	"backtrace after finish from nested call level 4"
gdb_test "finish" "Value returned is .* = 110" \
	"Finish from nested call level 3"
gdb_test "backtrace" \
	"\#0  add \\(a=4, b=5\\).*\#1  <function called from gdb>.*\#2  add \\(a=2, b=3\\).*\#3  <function called from gdb>.*\#4  main.*" \
	"backtrace after finish from nested call level 3"
gdb_test "finish" "Value returned is .* = 9" \
	"Finish from nested call level 2"
gdb_test "backtrace" \
	"\#0  add \\(a=2, b=3\\).*\#1  <function called from gdb>.*\#2  main.*" \
	"backtrace after finish from nested call level 2"
gdb_test "finish" "Value returned is .* = 5" \
	"Finish from nested call level 1"
gdb_test "backtrace" "\#0  main .*" \
	"backtrace after finish from nested call level 1"

do_get_all_registers
set new_reg_content $all_registers_content
if ![string compare $old_reg_content $new_reg_content] then {
    pass "nested call dummies preserve register contents"
} else {
    fail "nested call dummies preserve register contents"
}

return 0

@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 250
# Copyright (C) 1992 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# This file was written by Fred Fish. (fnf@@cygnus.com)

if $tracelevel then {
	strace $tracelevel
}

set prms_id 0
set bug_id 0

set prototypes 0
set testfile "callfuncs"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}

# build the first test case
execute_anywhere "rm -f ${binfile}.ci"
execute_anywhere "echo set prototypes 1 > ${binfile}.ci"
if  { [compile "-g ${srcdir}/${subdir}/${srcfile} -o ${binfile} "] != "" } {
    execute_anywhere "rm -f ${binfile}.ci"    
    # built the second test case since we can't use prototypes
    warning "Prototypes not supported, rebuilding with -DNO_PROTOTYPES"
    execute_anywhere "echo set prototypes 0 > ${binfile}.ci"
    if  { [compile "-g -DNO_PROTOTYPES ${srcdir}/${subdir}/${srcfile} -o ${binfile} "] != "" } {
	perror "Couldn't compile ${testfile}.c"
	return -1
    }
}

# Create and source the file that provides information about the compiler
# used to compile the test case.
if  { [compile "-E ${srcdir}/${subdir}/compiler.c >> ${binfile}.ci"] != "" } {
    perror "Couldn't make ${binfile}.ci"
    return -1
}
source ${binfile}.ci

# The a29k can't call functions, so don't even bother with this test.
if [istarget "a29k-*-udi"] then {
    setup_xfail "a29k-*-udi" 2416
    fail "a29k-*-udi can not call functions"
    continue
}

# The h8300 simulator can't call functions, so don't even bother with this test.
if [istarget "h8300*-*-*"] then {
    setup_xfail "h8300*-*-*" 
    fail "h8300*-*-* simulator can not call functions"
    continue
}
# Set the current language to C.  This counts as a test.  If it
# fails, then we skip the other tests.

proc set_lang_c {} {
    global prompt

    send "set language c\n"
    expect {
	-re ".*$prompt $" {}
	timeout { fail "set language c (timeout)" ; return 0 }
    }

    send "show language\n"
    expect {
	-re ".* source language is \"c\".*$prompt $" {
	    pass "set language to \"c\""
	    return 1
	}
	-re ".*$prompt $" {
	    fail "setting language to \"c\""
	    return 0
	}
	timeout {
	    fail "can't show language (timeout)"
	    return 0
	}
    }
}

# FIXME:  Before calling this proc, we should probably verify that
# we can call inferior functions and get a valid integral value
# returned.
# Note that it is OK to check for 0 or 1 as the returned values, because C
# specifies that the numeric value of a relational or logical expression
# (computed in the inferior) is 1 for true and 0 for false.

proc do_function_calls {} {
    global prototypes
    global gcc_compiled

    gdb_test "p t_char_values(0,0)" " = 0"
    gdb_test "p t_char_values('a','b')" " = 1"
    gdb_test "p t_char_values(char_val1,char_val2)" " = 1"
    gdb_test "p t_char_values('a',char_val2)" " = 1"
    gdb_test "p t_char_values(char_val1,'b')" " = 1"

    gdb_test "p t_short_values(0,0)" " = 0"
    gdb_test "p t_short_values(10,-23)" " = 1"
    gdb_test "p t_short_values(short_val1,short_val2)" " = 1"
    gdb_test "p t_short_values(10,short_val2)" " = 1"
    gdb_test "p t_short_values(short_val1,-23)" " = 1"

    gdb_test "p t_int_values(0,0)" " = 0"
    gdb_test "p t_int_values(87,-26)" " = 1"
    gdb_test "p t_int_values(int_val1,int_val2)" " = 1"
    gdb_test "p t_int_values(87,int_val2)" " = 1"
    gdb_test "p t_int_values(int_val1,-26)" " = 1"

    gdb_test "p t_long_values(0,0)" " = 0"
    gdb_test "p t_long_values(789,-321)" " = 1"
    gdb_test "p t_long_values(long_val1,long_val2)" " = 1"
    gdb_test "p t_long_values(789,long_val2)" " = 1"
    gdb_test "p t_long_values(long_val1,-321)" " = 1"

    gdb_test "p t_float_values(0.0,0.0)" " = 0"
    gdb_test "p t_float_values(3.14159,-2.3765)" " = 1"
    gdb_test "p t_float_values(float_val1,float_val2)" " = 1"
    gdb_test "p t_float_values(3.14159,float_val2)" " = 1"
    gdb_test "p t_float_values(float_val1,-2.3765)" " = 1"

    # Test passing of arguments which might not be widened.
    gdb_test "p t_float_values2(0.0,0.0)" " = 0"

    # Although PR 5318 mentions SunOS specifically, this seems
    # to be a generic problem on quite a few platforms.
    if $prototypes then {
        setup_xfail "hppa*-*-*" "sparc-*-*" "mips*-*-*" 5318
	if {!$gcc_compiled} then {
	    setup_xfail "alpha-dec-osf2*" "i*86-*-sysv4*" 5318
	}
    }
    gdb_test "p t_float_values2(3.14159,float_val2)" " = 1"
    gdb_test "p t_small_values(1,2,3,4,5,6,7,8,9,10)" " = 55"

    gdb_test "p t_double_values(0.0,0.0)" " = 0"
    gdb_test "p t_double_values(45.654,-67.66)" " = 1"
    gdb_test "p t_double_values(double_val1,double_val2)" " = 1"
    gdb_test "p t_double_values(45.654,double_val2)" " = 1"
    gdb_test "p t_double_values(double_val1,-67.66)" " = 1"

    gdb_test "p t_string_values(string_val2,string_val1)" " = 0"
    gdb_test "p t_string_values(string_val1,string_val2)" " = 1"
    gdb_test "p t_string_values(\"string 1\",\"string 2\")" " = 1"
    gdb_test "p t_string_values(\"string 1\",string_val2)" " = 1"
    gdb_test "p t_string_values(string_val1,\"string 2\")" " = 1"

    gdb_test "p t_char_array_values(char_array_val2,char_array_val1)" " = 0"
    gdb_test "p t_char_array_values(char_array_val1,char_array_val2)" " = 1"
    gdb_test "p t_char_array_values(\"carray 1\",\"carray 2\")" " = 1"
    gdb_test "p t_char_array_values(\"carray 1\",char_array_val2)" " = 1"
    gdb_test "p t_char_array_values(char_array_val1,\"carray 2\")" " = 1"

    gdb_test "p doubleit(4)" " = 8"
    gdb_test "p add(4,5)" " = 9"
    gdb_test "p t_func_values(func_val2,func_val1)" " = 0"
    gdb_test "p t_func_values(func_val1,func_val2)" " = 1"

    # On the rs6000, we need to pass the address of the trampoline routine,
    # not the address of add itself.  I don't know how to go from add to
    # the address of the trampoline.  Similar problems exist on the HPPA,
    # and in fact can present an unsolvable problem as the stubs may not
    # even exist in the user's program.  We've slightly recoded t_func_values
    # to avoid such problems in the common case.  This may or may not help
    # the RS6000.
    setup_xfail "rs6000*-*-*"
    setup_xfail "powerpc*-*-*"
    gdb_test "p t_func_values(add,func_val2)" " = 1"

    setup_xfail "rs6000*-*-*"
    setup_xfail "powerpc*-*-*"
    gdb_test "p t_func_values(func_val1,doubleit)" " = 1"

    gdb_test "p t_call_add(func_val1,3,4)" " = 7"

    setup_xfail "rs6000*-*-*"
    setup_xfail "powerpc*-*-*"
    gdb_test "p t_call_add(add,3,4)" " = 7"

    gdb_test "p t_enum_value1(enumval1)" " = 1"
    gdb_test "p t_enum_value1(enum_val1)" " = 1"
    gdb_test "p t_enum_value1(enum_val2)" " = 0"

    gdb_test "p t_enum_value2(enumval2)" " = 1"
    gdb_test "p t_enum_value2(enum_val2)" " = 1"
    gdb_test "p t_enum_value2(enum_val1)" " = 0"

    gdb_test "p sum_args(1,{2})" " = 2"
    gdb_test "p sum_args(2,{2,3})" " = 5"
    gdb_test "p sum_args(3,{2,3,4})" " = 9"
    gdb_test "p sum_args(4,{2,3,4,5})" " = 14"
    gdb_test "p sum10 (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)" " = 55"

    gdb_test "p t_structs_c(struct_val1)" "= 120 'x'" \
	"call inferior func with struct - returns char"
    gdb_test "p t_structs_s(struct_val1)" "= 87" \
	"call inferior func with struct -  returns short"
    gdb_test "p t_structs_i(struct_val1)" "= 76" \
	"call inferior func with struct - returns int"
    gdb_test "p t_structs_l(struct_val1)" "= 51" \
	"call inferior func with struct - returns long"
    setup_xfail "i*86-*-*"
    gdb_test "p t_structs_f(struct_val1)" "= 2.12.*" \
	"call inferior func with struct - returns float"
    setup_xfail "i*86-*-*"
    gdb_test "p t_structs_d(struct_val1)" "= 9.87.*" \
	"call inferior func with struct - returns double"
    gdb_test "p t_structs_a(struct_val1)" "= (.unsigned char .. )?\"foo\"" \
	"call inferior func with struct - returns char *"

}

# Start with a fresh gdb.

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

send "set print sevenbit-strings\n" ; expect -re "$prompt $"
send "set print address off\n" ; expect -re "$prompt $"
send "set width 0\n" ; expect -re "$prompt $"

if [set_lang_c] then {
    if [runto_main] then {
	do_function_calls
    } else {
	fail "C function calling tests suppressed"
    }
} else {
    fail "C function calling tests suppressed"
}
return 0
@
