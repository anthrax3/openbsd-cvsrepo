head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.54
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.50
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.46
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.48
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.40
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.44
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.42
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.38
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.36
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.34
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.32
	OPENBSD_5_0:1.1.1.1.0.30
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.28
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.26
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.22
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.24
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.20
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.18
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.16
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.14
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.12
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.10
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.8
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.6
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.4
	OPENBSD_3_7_BASE:1.1.1.1
	GDB_6_3:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.2
	OPENBSD_3_6_BASE:1.1.1.1
	GDB_6_1:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2004.05.21.19.17.00;	author kettenis;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.05.21.19.17.00;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@# Copyright (C) 2003 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@@prep.ai.mit.edu

# Tests for shared object file relocation. If two shared objects have
# the same load address (actually, overlapping load spaces), one of
# them gets relocated at load-time. Check that gdb gets the right
# values for the debugging and minimal symbols.

if {[istarget *-elf*] || [istarget *-coff] || [istarget *-aout]} then {
    verbose "test skipped - shared object files not supported by this target."
    return 0
}

if $tracelevel then {
    strace $tracelevel
}

#
# This file uses shreloc.c, shreloc1.c and shreloc2.c
#

set prms_id 0
set bug_id 0

set workdir ${objdir}/${subdir}

foreach module [list "shreloc" "shreloc1" "shreloc2"] {
    if {[gdb_compile "${srcdir}/${subdir}/${module}.c" "${workdir}/${module}.o" object {debug}] != ""} {
	untested "Couldn't compile ${module}.c"
	return -1
    }
}

set additional_flags "additional_flags=-shared"

if {([istarget "*pc-cygwin"] || [istarget "*pc-mingw32"]) } {
    set additional_flags "${additional_flags} -Wl,--image-base,0x04000000"
}

foreach module [list "shreloc1" "shreloc2"] {
    if {[gdb_compile "${workdir}/${module}.o" "${workdir}/${module}.dll" executable [list debug $additional_flags]] != ""} {
	untested "Couldn't link ${module}.dll"
	return -1
    }
}

if {[gdb_compile [list "${workdir}/shreloc.o" "${workdir}/shreloc1.dll" "${workdir}/shreloc2.dll"] "${workdir}/shreloc" executable debug] != ""} {
    untested "Couldn't link shreloc executable"
    return -1
}

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${workdir}/shreloc

# Load up the shared objects
if ![runto_main] then {
    fail "Can't run to main"
    return 0
}

proc get_var_address { var } {
  global gdb_prompt hex

  send_gdb "print &${var}\n"
  # Match output like:
  # $1 = (int *) 0x0
  # $5 = (int (*)()) 0
  # $6 = (int (*)()) 0x24 <function_bar>
  gdb_expect {
    -re "\\\$\[0-9\]+ = \\(.*\\) (0|$hex)( <${var}>)?\[\r\n\]+${gdb_prompt} $"
	{
	  pass "get address of ${var}"
	  if { $expect_out(1,string) == "0" } {
	    return "0x0"
	  } else {
	    return $expect_out(1,string)
	  }
	}
    -re "${gdb_prompt} $"
	{ fail "get address of ${var} (unknown output)" }
    timeout
	{ fail "get address of ${var} (timeout)" }
  }
  return ""
}

#
# Check debugging symbol relocations
#

# Check extern function for relocation
set fn_1_addr [get_var_address fn_1]
set fn_2_addr [get_var_address fn_2]

if { "${fn_1_addr}" == "${fn_2_addr}" } {
  fail "relocated extern functions have different addresses"
} else {
  pass "relocated extern functions have different addresses"
}

# Check extern var for relocation
set extern_var_1_addr [get_var_address extern_var_1]
set extern_var_2_addr [get_var_address extern_var_2]

if { "${extern_var_1_addr}" == "${extern_var_2_addr}" } {
  fail "relocated extern variables have different addresses"
} else {
  pass "relocated extern variables have different addresses"
}

# Check static var for relocation
set static_var_1_addr [get_var_address static_var_1]
set static_var_2_addr [get_var_address static_var_2]

if { "${static_var_1_addr}" == "${static_var_2_addr}" } {
  fail "relocated static variables have different addresses"
} else {
  pass "relocated static variables have different addresses"
}

#
# Check minimal symbol relocations
#

proc send_gdb_discard { command } {
    # Send a command to gdb and discard output up to the next prompt

    global gdb_prompt

    send_gdb "${command}\n"

    # Discard output
    gdb_expect {
	-re ".*\[\r\n]+${gdb_prompt} $" {
	    return 1
	}
	timeout {
	    fail "{$command} (timeout)"
	    return 0
	}
    }
}

proc get_msym_addrs { var msymfile } {
    # Extract the list of values for symbols matching var in the
    # minimal symbol output file

    global gdb_prompt hex
    set result ""

    send_gdb "shell grep -E \" ${var}(\[ \t\]+.*)?\$\" ${msymfile}\n"

    while 1 {
	gdb_expect {
	    -re "\[\[\]\[ 0-9\]+\] . (${hex}) ${var}(\[ \t\]+\[^\r\n\]*)?\[\r\n\]+" {
		set result [concat $result $expect_out(1,string)]
	    }

	    -re "$gdb_prompt $" {
		pass "get_msym_addrs ${var} (${result})"
		return "${result}"
	    }

	    -re "\[^\r\n\]*\[\r\n\]+" {
		# Skip
	    }

	    timeout {
		fail "get_msym_addrs ${var} (timeout)"
		return -1
	    }
	}
    }
}

proc check_same {var msymfile} {
    # Check that the minimal symbol values matching var are the same

    set len [llength [lsort -unique [get_msym_addrs "${var}" "${msymfile}"]]]

    if { $len == 1 } {
	return 1
    } else {
	return 0
    }
}

proc check_different {var msymfile} {
    # Check that the minimal symbol values matching var are different

    set addr_list [lsort [get_msym_addrs "${var}" "${msymfile}"]]
    set prev ""

    if { [llength ${addr_list}] < 2 } {
	return 0
    }

    foreach addr ${addr_list} {
	if { ${prev} == ${addr} } {
	  return 0
	}
	set prev ${addr}
    }

    return 1
}

set msymfile "${workdir}/shreloc.txt"

if [send_gdb_discard "maint print msymbols ${msymfile}"] {
    if {[check_different "static_var_\[12\]" "${msymfile}"]} {
	pass "(msymbol) relocated static vars have different addresses"
    } else {
	fail "(msymbol) relocated static vars have different addresses"
    }

    if {[check_different "extern_var_\[12\]" "${msymfile}"]} {
	pass "(msymbol) relocated extern vars have different addresses"
    } else {
	fail "(msymbol) relocated extern vars have different addresses"
    }

    if {[check_different "fn_\[12\]" "${msymfile}"]} {
	pass "(msymbol) relocated functions have different addresses"
    } else {
	fail "(msymbol) relocated functions have different addresses"
    }
}

if {([istarget "*pc-cygwin"] || [istarget "*pc-mingw32"]) } {
    #
    # We know the names of some absolute symbols included in the
    # portable-executable (DLL) format. Check that they didn't get
    # relocated.
    #
    # A better approach would be include absolute symbols via the assembler.
    #
    if {[check_same "_minor_os_version__" "${msymfile}"]} {
	pass "Absolute symbols not relocated"
    } else {
	fail "Absolute symbols not relocated"
    }
}
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@@
