head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.56
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.54
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.50
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.46
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.48
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.40
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.44
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.42
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.38
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.36
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.34
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.32
	OPENBSD_5_0:1.1.1.1.0.30
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.28
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.26
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.22
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.24
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.20
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.18
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.16
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.14
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.12
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.10
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.8
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.6
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.4
	OPENBSD_3_7_BASE:1.1.1.1
	GDB_6_3:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.2
	OPENBSD_3_6_BASE:1.1.1.1
	GDB_6_1:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2004.05.21.19.17.14;	author kettenis;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.05.21.19.17.14;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@# Copyright 2003 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Tests for PR gdb/1355, which is a reference to PR gcc/12066.
# 2003-08-26  Michael Chastain <mec@@shout.net>

# This file is part of the gdb testsuite.

set ws "\[\r\n\t \]*"
set nl "\[\r\n\]+"

if $tracelevel then {
    strace $tracelevel
    }

if { [skip_cplus_tests] } { continue }

#
# test running programs
#
set prms_id 0
set bug_id 0

set testfile "gdb1355"
set srcfile ${testfile}.cc
set binfile ${objdir}/${subdir}/${testfile}

if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug c++}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

if [get_compiler_info ${binfile} "c++"] {
    return -1
}

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

if ![runto_main] then {
    perror "couldn't run to main"
    continue
} 

# See http://sources.redhat.com/gdb/bugs/1355
# See http://gcc.gnu.org/bugzilla/show_bug.cgi?id=12066
#
# g++ -gstabs+ does not emit stabs for fundamental types.
# They get emitted later inside other types, so they have no names
# and gdb cannot handle them.

set s_head  "${ws}(struct|class) mystruct \{(${ws}public:|)"
set s_tail  ".*"

set f_i     "${ws}int m_int;"
set f_c     "${ws}char m_char;"
set f_li    "${ws}long int m_long_int;"
set f_ui    "${ws}unsigned int m_unsigned_int;"
set f_lui   "${ws}long unsigned int m_long_unsigned_int;"
set f_si    "${ws}short int m_short_int;"
set f_sui   "${ws}short unsigned int m_short_unsigned_int;"
set f_uc    "${ws}unsigned char m_unsigned_char;"
set f_f     "${ws}float m_float;"
set f_d     "${ws}double m_double;"
set f_ld    "${ws}long double m_long_double;"
set f_b     "${ws}bool m_bool;"

set itc     "<invalid type code ${decimal}>"
set bad_i   "${ws}(${itc}|int) m_int;";
set bad_c   "${ws}(${itc}|char) m_char;"
set bad_li  "${ws}(${itc}|long int) m_long_int;"
set bad_ui  "${ws}(${itc}|unsigned int) m_unsigned_int;"
set bad_lui "${ws}(${itc}|long unsigned int) m_long_unsigned_int;"
set bad_si  "${ws}(${itc}|short int) m_short_int;"
set bad_sui "${ws}(${itc}|short unsigned int) m_short_unsigned_int;"
set bad_uc  "${ws}(${itc}|unsigned char) m_unsigned_char;"
set bad_f   "${ws}(${itc}|float) m_float;"
set bad_d   "${ws}(${itc}|double) m_double;"
set bad_ld  "${ws}(${itc}|long double) m_long_double;"
set bad_b   "${ws}(${itc}|bool) m_bool;"

gdb_test_multiple "ptype s1" "ptype s1" {
    -re "type = ${s_head}${f_i}${f_c}${f_li}${f_ui}${f_lui}${f_si}${f_sui}${f_uc}${f_f}${f_d}${f_ld}${f_b}${s_tail}\}$nl$gdb_prompt $" {
	pass "ptype s1"
    }
    -re "type = ${s_head}${bad_i}${bad_c}${bad_li}${bad_ui}${bad_lui}${bad_si}${bad_sui}${bad_uc}${bad_f}${bad_d}${bad_ld}${bad_b}${s_tail}\}$nl$gdb_prompt $" {
	# This happened with gcc HEAD 2003-08-20 08:00:00 UTC, -gstabs+.
	kfail "gdb/1355" "ptype s1"
    }
}

gdb_test_multiple "print s1" "print s1" {
    -re "$decimal = \{m_int = 117, m_char = 97 'a', m_long_int = 118, m_unsigned_int = 119, m_long_unsigned_int = 120, m_short_int = 123, m_short_unsigned_int = 124, m_unsigned_char = 98 'b', m_float = 125, m_double = 126, m_long_double = 127, m_bool = true\}$nl$gdb_prompt $" {
	pass "print s1"
    }
    -re "$decimal = \{m_int = 117, m_char = 97 'a', m_long_int = 118, m_unsigned_int = 119, m_long_unsigned_int = 120, m_short_int = 123, m_short_unsigned_int = 124, m_unsigned_char = 98 'b', m_float = 125, m_double = 126, m_long_double = 127, m_bool = 117\}$nl$gdb_prompt $" {
	# This pattern is very picky, but if more different output
	# shows up, I can just add more arms.  -- chastain 2003-08-26
	#
	# This happened with gcc HEAD 2003-08-20 08:00:00 UTC, -gstabs+.
	# Look at the value of m_bool.  It looks like gdb latched onto
	# random int type and then used the data at structure offset 0.
	kfail "gdb/1355" "print s1"
    }
}
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@@
