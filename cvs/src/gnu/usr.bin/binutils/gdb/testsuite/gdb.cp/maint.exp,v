head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.1.0.52
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.50
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.46
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.48
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.40
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.44
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.42
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.38
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.36
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.34
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.32
	OPENBSD_5_0:1.1.1.1.0.30
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.28
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.26
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.22
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.24
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.20
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.18
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.16
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.14
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.12
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.10
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.8
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.6
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.4
	OPENBSD_3_7_BASE:1.1.1.1
	GDB_6_3:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.2
	OPENBSD_3_6_BASE:1.1.1.1
	GDB_6_1:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2004.05.21.19.17.16;	author kettenis;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.05.21.19.17.16;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@# Copyright 2003, 2004 Free Software Foundation Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  


# This file tests C++-specific maintenance commands and help on those.

# Currently, no source file is used.

if $tracelevel then {
        strace $tracelevel
        }

# Test the help messages.

proc test_help {} {
    set first_component_help "Print the first class/namespace component of NAME"
    set namespace_help "Print the list of possible C\\+\\+ namespaces"

    set multiple_help_body "List of maintenance cplus subcommands:\r\n\r\nmaintenance cplus first_component -- ${first_component_help}\r\nmaintenance cplus namespace -- ${namespace_help}\r\n\r\nType \"help maintenance cplus\" followed by maintenance cplus subcommand name for full documentation.\r\nCommand name abbreviations are allowed if unambiguous."

    set help_maint_cp "C\\+\\+ maintenance commands.\r\n\r\n${multiple_help_body}"

    gdb_test "help maintenance cplus" "${help_maint_cp}"
    gdb_test "help maint cp" "${help_maint_cp}"
    gdb_test "maint cp" "\"maintenance cplus\" must be followed by the name of a command.\r\n${multiple_help_body}"

    gdb_test "help maint cp first_component" "${first_component_help}."
    gdb_test "help maint cp namespace" "${namespace_help}."
}

# This is used when NAME should contain only a single component.  Be
# careful to make sure that parentheses get escaped properly.
proc test_single_component {name} {
    set matchname [string_to_regexp "$name"]
    gdb_test "maint cp first_component $name" "$matchname"
}

# This is used when NAME is invalid.
proc test_invalid_name {name} {
    set matchname [string_to_regexp "$name"]
    gdb_test "maint cp first_component $name" \
	"During symbol reading, unexpected demangled name '$matchname'.\r\n$matchname"
}

proc test_first_component {} {
    # The function in question might complain; make sure that we see
    # all complaints.

    gdb_test "set complaints -1" ""

    test_single_component "foo"
    test_single_component "operator<<"
    test_single_component "operator>>"
    test_single_component "operator ->"
    test_single_component "operator()"
    test_single_component "operator>"
    test_single_component "operator<"
    test_single_component "operator ->"
    test_single_component "operator  ->"

    test_single_component "foo()"
    test_single_component "foo(int)"
    test_single_component "foo(X::Y)"
    test_single_component "foo(X::Y, A::B)"
    test_single_component "foo(std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >)"
    test_single_component "operator>(X::Y)"

    # Operator names can show up in weird places.

    test_single_component "int operator<< <char>()"
    test_single_component "T<Cooperator>"

    # NOTE: carlton/2003-04-23: I've only seen the first of these
    # produced by the demangler, but I'm including two more just to be
    # on the safe side.
    test_single_component "int foo<&(operator<<(C, C))>()"
    test_single_component "int foo<&operator<<(C, C)>()"
    test_single_component "int foo<operator<<(C, C)>()"

    gdb_test "maint cp first_component foo::bar" "foo"
    gdb_test "maint cp first_component foo::bar::baz" "foo"
    gdb_test "maint cp first_component C<A>::bar" "C<A>"
    gdb_test "maint cp first_component C<std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > >::bar" "C<std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > >"

    # Make sure we behave appropriately on invalid input.

    # NOTE: carlton/2003-06-25: As of today, the demangler can in fact
    # produce examples like the third case below: there really should
    # be a space between the two <'s.  See PR gdb/1245.

    test_invalid_name "foo<"
    test_invalid_name "foo("
    test_invalid_name "bool operator<<char>"
}

proc test_namespace {} {
    # There's not a lot we can do to test this.

    gdb_test "maint cp namespace" "Possible namespaces:"
}

gdb_exit
gdb_start

test_help
test_first_component
test_namespace

gdb_exit
return 0
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@@
