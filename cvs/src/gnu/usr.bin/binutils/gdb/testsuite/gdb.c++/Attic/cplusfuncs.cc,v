head	1.3;
access;
symbols
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@// @;


1.3
date	2004.05.21.20.23.40;	author kettenis;	state dead;
branches;
next	1.2;

1.2
date	96.11.23.03.50.39;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.36.10;	author niklas;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	96.11.19.14.36.10;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@#include <stddef.h>

class foo {
public:
  foo  (int);
  foo  (int, const char *);
  foo  (foo&);
  ~foo ();

  void  operator *      (foo&);
  void  operator %      (foo&);
  void  operator -      (foo&);
  void  operator >>     (foo&);
  void  operator !=     (foo&);
  void  operator >      (foo&);
  void  operator >=     (foo&);
  void  operator |      (foo&);
  void  operator &&     (foo&);
  void  operator !      (void);
  void  operator ++     (int);
  void  operator =      (foo&);
  void  operator +=     (foo&);
  void  operator *=     (foo&);
  void  operator %=     (foo&);
  void  operator >>=    (foo&);
  void  operator |=     (foo&);
  void  operator ,      (foo&);
  void  operator /      (foo&);
  void  operator +      (foo&);
  void  operator <<     (foo&);
  void  operator ==     (foo&);
  void  operator <      (foo&);
  void  operator <=     (foo&);
  void  operator &      (foo&);
  void  operator ^      (foo&);
  void  operator ||     (foo&);
  void  operator ~      (void);
  void  operator --     (int);
  void  operator ->     (void);
  void  operator -=     (foo&);
  void  operator /=     (foo&);
  void  operator <<=    (foo&);
  void  operator &=     (foo&);
  void  operator ^=     (foo&);
  void  operator ->*    (foo&);
  void  operator []     (foo&);
  void  operator ()     (foo&);
  void* operator new    (size_t);
  void  operator delete (void *);
  /**/  operator int    ();
  /**/  operator char*  ();

  foofunc (int);
  foofunc (int, signed char *);
  int ifoo;
  const char *ccpfoo;
};

main () {}

foo::foo  (int i)                  { ifoo = i;}
foo::foo  (int i, const char *ccp) { ifoo = i; ccpfoo = ccp; }
foo::foo  (foo& afoo)              { afoo.ifoo = 0; }
foo::~foo ()                       {}

void  foo::operator *      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator %      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator -      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator >>     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator !=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator >      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator >=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator |      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator &&     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator !      (void) {}
void  foo::operator ++     (int ival) { ival = 0; }
void  foo::operator =      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator +=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator *=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator %=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator >>=    (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator |=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator ,      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator /      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator +      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator <<     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator ==     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator <      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator <=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator &      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator ^      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator ||     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator ~      (void) {}
void  foo::operator --     (int ival) { ival = 0; }
void  foo::operator ->     (void) {}
void  foo::operator -=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator /=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator <<=    (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator &=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator ^=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator ->*    (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator []     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator ()     (foo& afoo) { afoo.ifoo = 0; }
void* foo::operator new    (size_t ival) { ival = 0; return 0; }
void  foo::operator delete (void *ptr) { ptr = 0; }
/**/  foo::operator int    () { return 0; }
/**/  foo::operator char*  () { return 0; }

/* Some functions to test overloading by varying one argument type. */

void overload1arg (void)		{          }
void overload1arg (char arg)		{ arg = 0; }
void overload1arg (signed char arg)	{ arg = 0; }
void overload1arg (unsigned char arg)	{ arg = 0; }
void overload1arg (short arg)		{ arg = 0; }
void overload1arg (unsigned short arg)	{ arg = 0; }
void overload1arg (int arg)		{ arg = 0; }
void overload1arg (unsigned int arg)	{ arg = 0; }
void overload1arg (long arg)		{ arg = 0; }
void overload1arg (unsigned long arg)	{ arg = 0; }
void overload1arg (float arg)		{ arg = 0; }
void overload1arg (double arg)		{ arg = 0; }

/* Some functions to test overloading by varying argument count. */

void overloadargs (int a1)				{ a1 = 0; }
void overloadargs (int a1, int a2)			{ a1 = a2 = 0; }
void overloadargs (int a1, int a2, int a3)		{ a1 = a2 = a3 = 0; }
void overloadargs (int a1, int a2, int a3, int a4)
			{ a1 = a2 = a3 = a4 = 0; }
void overloadargs (int a1, int a2, int a3, int a4, int a5)
			{ a1 = a2 = a3 = a4 = a5 = 0; }
void overloadargs (int a1, int a2, int a3, int a4, int a5, int a6)
			{ a1 = a2 = a3 = a4 = a5 = a6 = 0; }
void overloadargs (int a1, int a2, int a3, int a4, int a5, int a6, int a7)
			{ a1 = a2 = a3 = a4 = a5 = a6 = a7 = 0; }
void overloadargs (int a1, int a2, int a3, int a4, int a5, int a6, int a7,
		   int a8)
			{ a1 = a2 = a3 = a4 = a5 = a6 = a7 = a8 = 0; }
void overloadargs (int a1, int a2, int a3, int a4, int a5, int a6, int a7,
		   int a8, int a9)
			{ a1 = a2 = a3 = a4 = a5 = a6 = a7 = a8 = a9 = 0; }
void overloadargs (int a1, int a2, int a3, int a4, int a5, int a6, int a7,
		   int a8, int a9, int a10)
			{ a1 = a2 = a3 = a4 = a5 = a6 = a7 = a8 = a9 =
			  a10 = 0; }
void overloadargs (int a1, int a2, int a3, int a4, int a5, int a6, int a7,
		   int a8, int a9, int a10, int a11)
			{ a1 = a2 = a3 = a4 = a5 = a6 = a7 = a8 = a9 =
			  a10 = a11 == 0; }

/* Some hairy function definitions.
   Use typedefs to help maintain sanity. */

typedef int   (*PFPc_i)(char *);
typedef short (*PFPl_s)(long *);
typedef short (*PFPc_s)(char *);
typedef int   (*PFl_i)(long);
typedef PFl_i (*PFPc_PFl_i)(char *);
typedef PFl_i (*PFPi_PFl_i)(int *);
typedef PFl_i (*PFPFPc_i_PFl_i)(PFPc_i);
typedef PFl_i (*PFs_PFl_i)(short);
typedef int   (*PFPFPl_s_i)(PFPl_s);
typedef int   (*PFPFPc_s_i)(PFPc_s);

PFs_PFl_i hairyfunc1 (int arg)			{ arg = 0; return 0; }
int       hairyfunc2 (PFPc_i arg)		{ arg = 0; return 0; }
int	  hairyfunc3 (PFPFPl_s_i arg)		{ arg = 0; return 0; }
int	  hairyfunc4 (PFPFPc_s_i arg)		{ arg = 0; return 0; }
int	  hairyfunc5 (PFPc_PFl_i arg)		{ arg = 0; return 0; }
int	  hairyfunc6 (PFPi_PFl_i arg)		{ arg = 0; return 0; }
int	  hairyfunc7 (PFPFPc_i_PFl_i arg)	{ arg = 0; return 0; }
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@@


1.1
log
@file cplusfuncs.cc was initially added on branch CYGNUS.
@
text
@d1 172
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 172
#include <stddef.h>

class foo {
public:
  foo  (int);
  foo  (int, const char *);
  foo  (foo&);
  ~foo ();

  void  operator *      (foo&);
  void  operator %      (foo&);
  void  operator -      (foo&);
  void  operator >>     (foo&);
  void  operator !=     (foo&);
  void  operator >      (foo&);
  void  operator >=     (foo&);
  void  operator |      (foo&);
  void  operator &&     (foo&);
  void  operator !      (void);
  void  operator ++     (int);
  void  operator =      (foo&);
  void  operator +=     (foo&);
  void  operator *=     (foo&);
  void  operator %=     (foo&);
  void  operator >>=    (foo&);
  void  operator |=     (foo&);
  void  operator ,      (foo&);
  void  operator /      (foo&);
  void  operator +      (foo&);
  void  operator <<     (foo&);
  void  operator ==     (foo&);
  void  operator <      (foo&);
  void  operator <=     (foo&);
  void  operator &      (foo&);
  void  operator ^      (foo&);
  void  operator ||     (foo&);
  void  operator ~      (void);
  void  operator --     (int);
  void  operator ->     (void);
  void  operator -=     (foo&);
  void  operator /=     (foo&);
  void  operator <<=    (foo&);
  void  operator &=     (foo&);
  void  operator ^=     (foo&);
  void  operator ->*    (foo&);
  void  operator []     (foo&);
  void  operator ()     (foo&);
  void* operator new    (size_t);
  void  operator delete (void *);
  /**/  operator int    ();
  /**/  operator char*  ();

  foofunc (int);
  foofunc (int, signed char *);
  int ifoo;
  const char *ccpfoo;
};

main () {}

foo::foo  (int i)                  { ifoo = i;}
foo::foo  (int i, const char *ccp) { ifoo = i; ccpfoo = ccp; }
foo::foo  (foo& afoo)              { afoo.ifoo = 0; }
foo::~foo ()                       {}

void  foo::operator *      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator %      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator -      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator >>     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator !=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator >      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator >=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator |      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator &&     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator !      (void) {}
void  foo::operator ++     (int ival) { ival = 0; }
void  foo::operator =      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator +=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator *=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator %=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator >>=    (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator |=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator ,      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator /      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator +      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator <<     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator ==     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator <      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator <=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator &      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator ^      (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator ||     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator ~      (void) {}
void  foo::operator --     (int ival) { ival = 0; }
void  foo::operator ->     (void) {}
void  foo::operator -=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator /=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator <<=    (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator &=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator ^=     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator ->*    (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator []     (foo& afoo) { afoo.ifoo = 0; }
void  foo::operator ()     (foo& afoo) { afoo.ifoo = 0; }
void* foo::operator new    (size_t ival) { ival = 0; return 0; }
void  foo::operator delete (void *ptr) { ptr = 0; }
/**/  foo::operator int    () { return 0; }
/**/  foo::operator char*  () { return 0; }

/* Some functions to test overloading by varying one argument type. */

void overload1arg (void)		{          }
void overload1arg (char arg)		{ arg = 0; }
void overload1arg (signed char arg)	{ arg = 0; }
void overload1arg (unsigned char arg)	{ arg = 0; }
void overload1arg (short arg)		{ arg = 0; }
void overload1arg (unsigned short arg)	{ arg = 0; }
void overload1arg (int arg)		{ arg = 0; }
void overload1arg (unsigned int arg)	{ arg = 0; }
void overload1arg (long arg)		{ arg = 0; }
void overload1arg (unsigned long arg)	{ arg = 0; }
void overload1arg (float arg)		{ arg = 0; }
void overload1arg (double arg)		{ arg = 0; }

/* Some functions to test overloading by varying argument count. */

void overloadargs (int a1)				{ a1 = 0; }
void overloadargs (int a1, int a2)			{ a1 = a2 = 0; }
void overloadargs (int a1, int a2, int a3)		{ a1 = a2 = a3 = 0; }
void overloadargs (int a1, int a2, int a3, int a4)
			{ a1 = a2 = a3 = a4 = 0; }
void overloadargs (int a1, int a2, int a3, int a4, int a5)
			{ a1 = a2 = a3 = a4 = a5 = 0; }
void overloadargs (int a1, int a2, int a3, int a4, int a5, int a6)
			{ a1 = a2 = a3 = a4 = a5 = a6 = 0; }
void overloadargs (int a1, int a2, int a3, int a4, int a5, int a6, int a7)
			{ a1 = a2 = a3 = a4 = a5 = a6 = a7 = 0; }
void overloadargs (int a1, int a2, int a3, int a4, int a5, int a6, int a7,
		   int a8)
			{ a1 = a2 = a3 = a4 = a5 = a6 = a7 = a8 = 0; }
void overloadargs (int a1, int a2, int a3, int a4, int a5, int a6, int a7,
		   int a8, int a9)
			{ a1 = a2 = a3 = a4 = a5 = a6 = a7 = a8 = a9 = 0; }
void overloadargs (int a1, int a2, int a3, int a4, int a5, int a6, int a7,
		   int a8, int a9, int a10)
			{ a1 = a2 = a3 = a4 = a5 = a6 = a7 = a8 = a9 =
			  a10 = 0; }
void overloadargs (int a1, int a2, int a3, int a4, int a5, int a6, int a7,
		   int a8, int a9, int a10, int a11)
			{ a1 = a2 = a3 = a4 = a5 = a6 = a7 = a8 = a9 =
			  a10 = a11 == 0; }

/* Some hairy function definitions.
   Use typedefs to help maintain sanity. */

typedef int   (*PFPc_i)(char *);
typedef short (*PFPl_s)(long *);
typedef short (*PFPc_s)(char *);
typedef int   (*PFl_i)(long);
typedef PFl_i (*PFPc_PFl_i)(char *);
typedef PFl_i (*PFPi_PFl_i)(int *);
typedef PFl_i (*PFPFPc_i_PFl_i)(PFPc_i);
typedef PFl_i (*PFs_PFl_i)(short);
typedef int   (*PFPFPl_s_i)(PFPl_s);
typedef int   (*PFPFPc_s_i)(PFPc_s);

PFs_PFl_i hairyfunc1 (int arg)			{ arg = 0; return 0; }
int       hairyfunc2 (PFPc_i arg)		{ arg = 0; return 0; }
int	  hairyfunc3 (PFPFPl_s_i arg)		{ arg = 0; return 0; }
int	  hairyfunc4 (PFPFPc_s_i arg)		{ arg = 0; return 0; }
int	  hairyfunc5 (PFPc_PFl_i arg)		{ arg = 0; return 0; }
int	  hairyfunc6 (PFPi_PFl_i arg)		{ arg = 0; return 0; }
int	  hairyfunc7 (PFPFPc_i_PFl_i arg)	{ arg = 0; return 0; }
@
