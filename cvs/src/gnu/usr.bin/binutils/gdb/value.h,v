head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.48
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.44
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.46
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.38
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.42
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.40
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.36
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.34
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.32
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.30
	OPENBSD_5_0:1.4.0.28
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.26
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.24
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2004.12.27.14.00.44;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.21.20.23.16;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.40.24;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.21.22;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.13.52;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.07.34;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.21.22;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@/* Definitions for values of C expressions, for GDB.

   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#if !defined (VALUE_H)
#define VALUE_H 1

#include "doublest.h"
#include "frame.h"		/* For struct frame_id.  */

struct block;
struct expression;
struct regcache;
struct symbol;
struct type;
struct ui_file;

/* The structure which defines the type of a value.  It should never
   be possible for a program lval value to survive over a call to the
   inferior (i.e. to be put into the history list or an internal
   variable).  */

struct value
{
  /* Type of value; either not an lval, or one of the various
     different possible kinds of lval.  */
  enum lval_type lval;

  /* Is it modifiable?  Only relevant if lval != not_lval.  */
  int modifiable;

  /* Location of value (if lval).  */
  union
  {
    /* If lval == lval_memory, this is the address in the inferior.
       If lval == lval_register, this is the byte offset into the
       registers structure.  */
    CORE_ADDR address;

    /* Pointer to internal variable.  */
    struct internalvar *internalvar;

    /* Number of register.  Only used with lval_reg_frame_relative.  */
    int regnum;
  } location;

  /* Describes offset of a value within lval of a structure in bytes.
     If lval == lval_memory, this is an offset to the address.
     If lval == lval_register, this is a further offset from
     location.address within the registers structure.  
     Note also the member embedded_offset below.  */
  int offset;

  /* Only used for bitfields; number of bits contained in them.  */
  int bitsize;

  /* Only used for bitfields; position of start of field.
     For BITS_BIG_ENDIAN=0 targets, it is the position of the LSB.
     For BITS_BIG_ENDIAN=1 targets, it is the position of the MSB. */
    int bitpos;

  /* Frame value is relative to.  In practice, this ID is only used if
     the value is stored in several registers in other than the
     current frame, and these registers have not all been saved at the
     same place in memory.  This will be described in the lval enum
     above as "lval_reg_frame_relative".  */
  struct frame_id frame_id;

  /* Type of the value.  */
  struct type *type;

  /* If a value represents a C++ object, then the `type' field gives
     the object's compile-time type.  If the object actually belongs
     to some class derived from `type', perhaps with other base
     classes and additional members, then `type' is just a subobject
     of the real thing, and the full object is probably larger than
     `type' would suggest.

     If `type' is a dynamic class (i.e. one with a vtable), then GDB
     can actually determine the object's run-time type by looking at
     the run-time type information in the vtable.  When this
     information is available, we may elect to read in the entire
     object, for several reasons:

     - When printing the value, the user would probably rather see the
       full object, not just the limited portion apparent from the
       compile-time type.

     - If `type' has virtual base classes, then even printing `type'
       alone may require reaching outside the `type' portion of the
       object to wherever the virtual base class has been stored.

     When we store the entire object, `enclosing_type' is the run-time
     type -- the complete object -- and `embedded_offset' is the
     offset of `type' within that larger type, in bytes.  The
     VALUE_CONTENTS macro takes `embedded_offset' into account, so
     most GDB code continues to see the `type' portion of the value,
     just as the inferior would.

     If `type' is a pointer to an object, then `enclosing_type' is a
     pointer to the object's run-time type, and `pointed_to_offset' is
     the offset in bytes from the full object to the pointed-to object
     -- that is, the value `embedded_offset' would have if we
     followed the pointer and fetched the complete object.  (I don't
     really see the point.  Why not just determine the run-time type
     when you indirect, and avoid the special case?  The contents
     don't matter until you indirect anyway.)

     If we're not doing anything fancy, `enclosing_type' is equal to
     `type', and `embedded_offset' is zero, so everything works
     normally.  */
    struct type *enclosing_type;
    int embedded_offset;
    int pointed_to_offset;

    /* Values are stored in a chain, so that they can be deleted
       easily over calls to the inferior.  Values assigned to internal
       variables or put into the value history are taken off this
       list.  */
    struct value *next;

    /* Register number if the value is from a register.  */
    short regno;

    /* If zero, contents of this value are in the contents field.  If
       nonzero, contents are in inferior memory at address in the
       location.address field plus the offset field (and the lval
       field should be lval_memory).

       WARNING: This field is used by the code which handles
       watchpoints (see breakpoint.c) to decide whether a particular
       value can be watched by hardware watchpoints.  If the lazy flag
       is set for some member of a value chain, it is assumed that
       this member of the chain doesn't need to be watched as part of
       watching the value itself.  This is how GDB avoids watching the
       entire struct or array when the user wants to watch a single
       struct member or array element.  If you ever change the way
       lazy flag is set and reset, be sure to consider this use as
       well!  */
    char lazy;

    /* If nonzero, this is the value of a variable which does not
       actually exist in the program.  */
    char optimized_out;

    /* The BFD section associated with this value.  */
    asection *bfd_section;

    /* Actual contents of the value.  For use of this value; setting
       it uses the stuff above.  Not valid if lazy is nonzero.
       Target byte-order.  We force it to be aligned properly for any
       possible value.  Note that a value therefore extends beyond
       what is declared here.  */
    union
    {
      long contents[1];
      DOUBLEST force_doublest_align;
      LONGEST force_longest_align;
      CORE_ADDR force_core_addr_align;
      void *force_pointer_align;
    } aligner;
    /* Do not add any new members here -- contents above will trash them.  */
};

#define VALUE_TYPE(val) (val)->type
#define VALUE_ENCLOSING_TYPE(val) (val)->enclosing_type
#define VALUE_LAZY(val) (val)->lazy

/* VALUE_CONTENTS and VALUE_CONTENTS_RAW both return the address of
   the gdb buffer used to hold a copy of the contents of the lval.
   VALUE_CONTENTS is used when the contents of the buffer are needed
   -- it uses value_fetch_lazy() to load the buffer from the process
   being debugged if it hasn't already been loaded.
   VALUE_CONTENTS_RAW is used when data is being stored into the
   buffer, or when it is certain that the contents of the buffer are
   valid.

   Note: The contents pointer is adjusted by the offset required to
   get to the real subobject, if the value happens to represent
   something embedded in a larger run-time object.  */

#define VALUE_CONTENTS_RAW(val) \
 ((char *) (val)->aligner.contents + (val)->embedded_offset)
#define VALUE_CONTENTS(val) \
 ((void)(VALUE_LAZY(val) && value_fetch_lazy(val)), VALUE_CONTENTS_RAW(val))

/* The ALL variants of the above two macros do not adjust the returned
   pointer by the embedded_offset value.  */

#define VALUE_CONTENTS_ALL_RAW(val) ((char *) (val)->aligner.contents)
#define VALUE_CONTENTS_ALL(val) \
  ((void) (VALUE_LAZY(val) && value_fetch_lazy(val)), \
   VALUE_CONTENTS_ALL_RAW(val))

extern int value_fetch_lazy (struct value *val);

#define VALUE_LVAL(val) (val)->lval
#define VALUE_ADDRESS(val) (val)->location.address
#define VALUE_INTERNALVAR(val) (val)->location.internalvar
#define VALUE_FRAME_REGNUM(val) ((val)->location.regnum)
#define VALUE_FRAME_ID(val) ((val)->frame_id)
#define VALUE_OFFSET(val) (val)->offset
#define VALUE_BITSIZE(val) (val)->bitsize
#define VALUE_BITPOS(val) (val)->bitpos
#define VALUE_NEXT(val) (val)->next
#define VALUE_REGNO(val) (val)->regno
#define VALUE_OPTIMIZED_OUT(val) ((val)->optimized_out)
#define VALUE_EMBEDDED_OFFSET(val) ((val)->embedded_offset)
#define VALUE_POINTED_TO_OFFSET(val) ((val)->pointed_to_offset)
#define VALUE_BFD_SECTION(val) ((val)->bfd_section)

/* Convert a REF to the object referenced.  */

#define COERCE_REF(arg) \
  do {									\
    struct type *value_type_arg_tmp = check_typedef (VALUE_TYPE (arg));	\
    if (TYPE_CODE (value_type_arg_tmp) == TYPE_CODE_REF)		\
      arg = value_at_lazy (TYPE_TARGET_TYPE (value_type_arg_tmp),	\
                           unpack_pointer (VALUE_TYPE (arg),		\
                                           VALUE_CONTENTS (arg)),	\
			                   VALUE_BFD_SECTION (arg));	\
  } while (0)

/* If ARG is an array, convert it to a pointer.
   If ARG is an enum, convert it to an integer.
   If ARG is a function, convert it to a function pointer.

   References are dereferenced.  */

#define COERCE_ARRAY(arg) \
  do {									\
    COERCE_REF(arg);							\
    if (current_language->c_style_arrays				\
        && TYPE_CODE (VALUE_TYPE (arg)) == TYPE_CODE_ARRAY)		\
      arg = value_coerce_array (arg);					\
    if (TYPE_CODE (VALUE_TYPE (arg)) == TYPE_CODE_FUNC)			\
      arg = value_coerce_function (arg);				\
  } while (0)

#define COERCE_NUMBER(arg) \
  do { COERCE_ARRAY(arg); COERCE_ENUM(arg); } while (0)

/* NOTE: cagney/2002-12-17: This macro was handling a chill language
   problem but that language has gone away.  */
#define COERCE_VARYING_ARRAY(arg, real_arg_type)

/* If ARG is an enum, convert it to an integer.  */

#define COERCE_ENUM(arg) \
  do {									\
    if (TYPE_CODE (check_typedef (VALUE_TYPE (arg))) == TYPE_CODE_ENUM)	\
      arg = value_cast (builtin_type_unsigned_int, arg);		\
  } while (0)

/* Internal variables (variables for convenience of use of debugger)
   are recorded as a chain of these structures.  */

struct internalvar
{
  struct internalvar *next;
  char *name;
  struct value *value;
};

/* Pointer to member function.  Depends on compiler implementation.  */

#define METHOD_PTR_IS_VIRTUAL(ADDR)  ((ADDR) & 0x80000000)
#define METHOD_PTR_FROM_VOFFSET(OFFSET) (0x80000000 + (OFFSET))
#define METHOD_PTR_TO_VOFFSET(ADDR) (~0x80000000 & (ADDR))


#include "symtab.h"
#include "gdbtypes.h"
#include "expression.h"

struct frame_info;
struct fn_field;

extern void print_address_demangle (CORE_ADDR, struct ui_file *, int);

extern LONGEST value_as_long (struct value *val);
extern DOUBLEST value_as_double (struct value *val);
extern CORE_ADDR value_as_address (struct value *val);

extern LONGEST unpack_long (struct type *type, const char *valaddr);
extern DOUBLEST unpack_double (struct type *type, const char *valaddr,
			       int *invp);
extern CORE_ADDR unpack_pointer (struct type *type, const char *valaddr);
extern LONGEST unpack_field_as_long (struct type *type, const char *valaddr,
				     int fieldno);

extern struct value *value_from_longest (struct type *type, LONGEST num);
extern struct value *value_from_pointer (struct type *type, CORE_ADDR addr);
extern struct value *value_from_double (struct type *type, DOUBLEST num);
extern struct value *value_from_string (char *string);

extern struct value *value_at (struct type *type, CORE_ADDR addr,
			       asection * sect);
extern struct value *value_at_lazy (struct type *type, CORE_ADDR addr,
				    asection * sect);

extern struct value *value_from_register (struct type *type, int regnum,
					  struct frame_info *frame);

extern struct value *value_of_variable (struct symbol *var, struct block *b);

extern struct value *value_of_register (int regnum,
					struct frame_info *frame);

extern int symbol_read_needs_frame (struct symbol *);

extern struct value *read_var_value (struct symbol *var,
				     struct frame_info *frame);

extern struct value *locate_var_value (struct symbol *var,
				       struct frame_info *frame);

extern struct value *allocate_value (struct type *type);

extern struct value *allocate_repeat_value (struct type *type, int count);

extern struct value *value_change_enclosing_type (struct value *val,
						  struct type *new_type);

extern struct value *value_mark (void);

extern void value_free_to_mark (struct value *mark);

extern struct value *value_string (char *ptr, int len);
extern struct value *value_bitstring (char *ptr, int len);

extern struct value *value_array (int lowbound, int highbound,
				  struct value ** elemvec);

extern struct value *value_concat (struct value *arg1, struct value *arg2);

extern struct value *value_binop (struct value *arg1, struct value *arg2,
				  enum exp_opcode op);

extern struct value *value_add (struct value *arg1, struct value *arg2);

extern struct value *value_sub (struct value *arg1, struct value *arg2);

extern struct value *value_coerce_array (struct value *arg1);

extern struct value *value_coerce_function (struct value *arg1);

extern struct value *value_ind (struct value *arg1);

extern struct value *value_addr (struct value *arg1);

extern struct value *value_assign (struct value *toval, struct value *fromval);

extern struct value *value_neg (struct value *arg1);

extern struct value *value_complement (struct value *arg1);

extern struct value *value_struct_elt (struct value **argp,
				       struct value **args,
				       char *name, int *static_memfuncp,
				       char *err);

extern struct value *value_aggregate_elt (struct type *curtype,
					  char *name,
					  enum noside noside);

extern struct value *value_static_field (struct type *type, int fieldno);

extern struct fn_field *value_find_oload_method_list (struct value **, char *,
						      int, int *,
						      struct type **, int *);

extern int find_overload_match (struct type **arg_types, int nargs,
				char *name, int method, int lax,
				struct value **objp, struct symbol *fsym,
				struct value **valp, struct symbol **symp,
				int *staticp);

extern struct value *value_field (struct value *arg1, int fieldno);

extern struct value *value_primitive_field (struct value *arg1, int offset,
					    int fieldno,
					    struct type *arg_type);


extern struct type *value_rtti_target_type (struct value *, int *, int *,
					    int *);

extern struct value *value_full_object (struct value *, struct type *, int,
					int, int);

extern struct value *value_cast (struct type *type, struct value *arg2);

extern struct value *value_zero (struct type *type, enum lval_type lv);

extern struct value *value_repeat (struct value *arg1, int count);

extern struct value *value_subscript (struct value *array, struct value *idx);

extern struct value *register_value_being_returned (struct type *valtype,
						    struct regcache *retbuf);

extern struct value *value_in (struct value *element, struct value *set);

extern int value_bit_index (struct type *type, char *addr, int index);

extern int using_struct_return (struct type *value_type, int gcc_p);

extern struct value *evaluate_expression (struct expression *exp);

extern struct value *evaluate_type (struct expression *exp);

extern struct value *evaluate_subexp_with_coercion (struct expression *,
						    int *, enum noside);

extern struct value *parse_and_eval (char *exp);

extern struct value *parse_to_comma_and_eval (char **expp);

extern struct type *parse_and_eval_type (char *p, int length);

extern CORE_ADDR parse_and_eval_address (char *exp);

extern CORE_ADDR parse_and_eval_address_1 (char **expptr);

extern LONGEST parse_and_eval_long (char *exp);

extern struct value *access_value_history (int num);

extern struct value *value_of_internalvar (struct internalvar *var);

extern void set_internalvar (struct internalvar *var, struct value *val);

extern void set_internalvar_component (struct internalvar *var,
				       int offset,
				       int bitpos, int bitsize,
				       struct value *newvalue);

extern struct internalvar *lookup_internalvar (char *name);

extern int value_equal (struct value *arg1, struct value *arg2);

extern int value_less (struct value *arg1, struct value *arg2);

extern int value_logical_not (struct value *arg1);

/* C++ */

extern struct value *value_of_this (int complain);

extern struct value *value_x_binop (struct value *arg1, struct value *arg2,
				    enum exp_opcode op,
				    enum exp_opcode otherop,
				    enum noside noside);

extern struct value *value_x_unop (struct value *arg1, enum exp_opcode op,
				   enum noside noside);

extern struct value *value_fn_field (struct value ** arg1p, struct fn_field *f,
				     int j, struct type *type, int offset);

extern int binop_user_defined_p (enum exp_opcode op, struct value *arg1,
				 struct value *arg2);

extern int unop_user_defined_p (enum exp_opcode op, struct value *arg1);

extern int destructor_name_p (const char *name, const struct type *type);

#define value_free(val) xfree (val)

extern void free_all_values (void);

extern void release_value (struct value *val);

extern int record_latest_value (struct value *val);

extern void modify_field (char *addr, LONGEST fieldval, int bitpos,
			  int bitsize);

extern void type_print (struct type * type, char *varstring,
			struct ui_file * stream, int show);

extern char *baseclass_addr (struct type *type, int index, char *valaddr,
			     struct value **valuep, int *errp);

extern void print_longest (struct ui_file * stream, int format,
			   int use_local, LONGEST val);

extern void print_floating (char *valaddr, struct type * type,
			    struct ui_file * stream);

extern int value_print (struct value *val, struct ui_file *stream, int format,
			enum val_prettyprint pretty);

extern void value_print_array_elements (struct value *val,
					struct ui_file *stream, int format,
					enum val_prettyprint pretty);

extern struct value *value_release_to_mark (struct value *mark);

extern int val_print (struct type * type, char *valaddr,
		      int embedded_offset, CORE_ADDR address,
		      struct ui_file * stream, int format,
		      int deref_ref, int recurse,
		      enum val_prettyprint pretty);

extern int val_print_string (CORE_ADDR addr, int len, int width, struct ui_file *stream);

extern void print_variable_value (struct symbol * var,
				  struct frame_info * frame,
				  struct ui_file *stream);

extern int check_field (struct value *, const char *);

extern void typedef_print (struct type * type, struct symbol * news,
			     struct ui_file * stream);

extern char *internalvar_name (struct internalvar *var);

extern void clear_value_history (void);

extern void clear_internalvars (void);

/* From values.c */

extern struct value *value_copy (struct value *);

/* From valops.c */

extern struct value *varying_to_slice (struct value *);

extern struct value *value_slice (struct value *, int, int);

extern struct value *value_literal_complex (struct value *, struct value *,
					    struct type *);

extern void find_rt_vbase_offset (struct type *, struct type *, char *, int,
				  int *, int *);

extern struct value *find_function_in_inferior (const char *);

extern struct value *value_allocate_space_in_inferior (int);

extern struct value *value_of_local (const char *name, int complain);

#endif /* !defined (VALUE_H) */
@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@a562 4
extern CORE_ADDR legacy_push_arguments (int nargs, struct value ** args,
					CORE_ADDR sp, int struct_return,
					CORE_ADDR struct_addr);

@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 3
a4 1
   Copyright 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996
d7 1
a7 1
This file is part of GDB.
d9 14
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d27 14
a40 21
/*
 * The structure which defines the type of a value.  It should never
 * be possible for a program lval value to survive over a call to the inferior
 * (ie to be put into the history list or an internal variable).
 */
enum lval_type {
  /* Not an lval.  */
  not_lval,
  /* In memory.  Could be a saved register.  */
  lval_memory,
  /* In a register.  */
  lval_register,
  /* In a gdb internal variable.  */
  lval_internalvar,
  /* Part of a gdb internal variable (structure field).  */
  lval_internalvar_component,
  /* In a register series in a frame not the current one, which may have been
     partially saved or saved in different places (otherwise would be
     lval_register or lval_memory).  */
  lval_reg_frame_relative
};
d43 10
d54 25
a78 23
    /* Type of value; either not an lval, or one of the various
       different possible kinds of lval.  */
    enum lval_type lval;
    /* Is it modifiable?  Only relevant if lval != not_lval.  */
    int modifiable;
    /* Location of value (if lval).  */
    union
      {
	/* Address in inferior or byte of registers structure.  */
	CORE_ADDR address;
	/* Pointer to internal variable.  */
	struct internalvar *internalvar;
	/* Number of register.  Only used with
	   lval_reg_frame_relative.  */
	int regnum;
      } location;
    /* Describes offset of a value within lval a structure in bytes.  */
    int offset;	
    /* Only used for bitfields; number of bits contained in them.  */
    int bitsize;
    /* Only used for bitfields; position of start of field.
       For BITS_BIG_ENDIAN=0 targets, it is the position of the LSB.
       For BITS_BIG_ENDIAN=1 targets, it is the position of the MSB. */
d80 55
a134 8
    /* Frame value is relative to.  In practice, this address is only
       used if the value is stored in several registers in other than
       the current frame, and these registers have not all been saved
       at the same place in memory.  This will be described in the
       lval enum above as "lval_reg_frame_relative".  */
    CORE_ADDR frame_addr;
    /* Type of the value.  */
    struct type *type;
d141 1
a141 9
    /* ??? When is this used?  */
    union {
      CORE_ADDR memaddr;
      char *myaddr;
    } substring_addr;

    /* Register number if the value is from a register.  Is not kept
       if you take a field of a structure that is stored in a
       register.  Shouldn't it be?  */
d143 16
a158 4
    /* If zero, contents of this value are in the contents field.
       If nonzero, contents are in inferior memory at address
       in the location.address field plus the offset field
       (and the lval field should be lval_memory).  */
d160 1
d164 4
d171 4
a174 2
       possible value.  */
    union {
d176 4
a179 3
      double force_double_align;
      LONGEST force_longlong_align;
      char *literal_data;
d181 2
a182 4

  };

typedef struct value *value_ptr;
d185 1
d187 1
d189 26
a214 10
   the gdb buffer used to hold a copy of the contents of the lval.  
   VALUE_CONTENTS is used when the contents of the buffer are needed --
   it uses value_fetch_lazy() to load the buffer from the process being 
   debugged if it hasn't already been loaded.  VALUE_CONTENTS_RAW is 
   used when data is being stored into the buffer, or when it is 
   certain that the contents of the buffer are valid.  */
#define VALUE_CONTENTS_RAW(val) ((char *) (val)->aligner.contents)
#define VALUE_CONTENTS(val) ((void)(VALUE_LAZY(val) && value_fetch_lazy(val)),\
			     VALUE_CONTENTS_RAW(val))
extern int value_fetch_lazy PARAMS ((value_ptr val));
d220 1
a220 1
#define VALUE_FRAME(val) ((val)->frame_addr)
d227 15
a241 10

/* Convert a REF to the object referenced. */

#define COERCE_REF(arg)    \
do { struct type *value_type_arg_tmp = check_typedef (VALUE_TYPE (arg));\
     if (TYPE_CODE (value_type_arg_tmp) == TYPE_CODE_REF)		\
	 arg = value_at_lazy (TYPE_TARGET_TYPE (value_type_arg_tmp),	\
			      unpack_long (VALUE_TYPE (arg),		\
					   VALUE_CONTENTS (arg)));      \
    } while (0)
d249 16
a264 15
#define COERCE_ARRAY(arg)    \
do { COERCE_REF(arg);							\
  if (current_language->c_style_arrays					\
      && TYPE_CODE (VALUE_TYPE (arg)) == TYPE_CODE_ARRAY)		\
    arg = value_coerce_array (arg);					\
  if (TYPE_CODE (VALUE_TYPE (arg)) == TYPE_CODE_FUNC)                   \
    arg = value_coerce_function (arg);                                  \
} while (0)

#define COERCE_NUMBER(arg)  \
  do { COERCE_ARRAY(arg);  COERCE_ENUM(arg); } while (0)

#define COERCE_VARYING_ARRAY(arg, real_arg_type)	\
{ if (chill_varying_type (real_arg_type))  \
    arg = varying_to_slice (arg), real_arg_type = VALUE_TYPE (arg); }
d268 5
a272 4
#define COERCE_ENUM(arg)   { \
  if (TYPE_CODE (check_typedef (VALUE_TYPE (arg))) == TYPE_CODE_ENUM)	\
    arg = value_cast (builtin_type_unsigned_int, arg);			\
}
d281 1
a281 1
  value_ptr value;
d284 1
a284 1
/* Pointer to member function.  Depends on compiler implementation. */
d289 1
a290 1

a294 1
#ifdef __STDC__
a296 4
#endif

extern void
print_address_demangle PARAMS ((CORE_ADDR, GDB_FILE *, int));
d298 1
a298 1
extern LONGEST value_as_long PARAMS ((value_ptr val));
d300 3
a302 1
extern DOUBLEST value_as_double PARAMS ((value_ptr val));
d304 6
a309 1
extern CORE_ADDR value_as_pointer PARAMS ((value_ptr val));
d311 4
a314 1
extern LONGEST unpack_long PARAMS ((struct type *type, char *valaddr));
d316 4
a319 2
extern DOUBLEST unpack_double PARAMS ((struct type *type, char *valaddr,
				       int *invp));
d321 2
a322 1
extern CORE_ADDR unpack_pointer PARAMS ((struct type *type, char *valaddr));
d324 1
a324 2
extern LONGEST unpack_field_as_long PARAMS ((struct type *type, char *valaddr,
					     int fieldno));
d326 2
a327 1
extern value_ptr value_from_longest PARAMS ((struct type *type, LONGEST num));
d329 1
a329 1
extern value_ptr value_from_double PARAMS ((struct type *type, DOUBLEST num));
d331 2
a332 1
extern value_ptr value_at PARAMS ((struct type *type, CORE_ADDR addr));
d334 2
a335 1
extern value_ptr value_at_lazy PARAMS ((struct type *type, CORE_ADDR addr));
d337 1
a337 2
extern value_ptr value_from_register PARAMS ((struct type *type, int regnum,
					  struct frame_info * frame));
d339 1
a339 2
extern value_ptr value_of_variable PARAMS ((struct symbol *var,
					    struct block *b));
d341 2
a342 1
extern value_ptr value_of_register PARAMS ((int regnum));
d344 1
a344 1
extern int symbol_read_needs_frame PARAMS ((struct symbol *));
d346 1
a346 2
extern value_ptr read_var_value PARAMS ((struct symbol *var,
					 struct frame_info *frame));
d348 2
a349 2
extern value_ptr locate_var_value PARAMS ((struct symbol *var,
				       struct frame_info *frame));
d351 2
a352 1
extern value_ptr allocate_value PARAMS ((struct type *type));
d354 1
a354 1
extern value_ptr allocate_repeat_value PARAMS ((struct type *type, int count));
d356 2
a357 1
extern value_ptr value_mark PARAMS ((void));
d359 1
a359 1
extern void value_free_to_mark PARAMS ((value_ptr mark));
d361 1
a361 2
extern value_ptr value_string PARAMS ((char *ptr, int len));
extern value_ptr value_bitstring PARAMS ((char *ptr, int len));
d363 1
a363 2
extern value_ptr value_array PARAMS ((int lowbound, int highbound,
				      value_ptr *elemvec));
d365 1
a365 1
extern value_ptr value_concat PARAMS ((value_ptr arg1, value_ptr arg2));
d367 1
a367 2
extern value_ptr value_binop PARAMS ((value_ptr arg1, value_ptr arg2,
				      enum exp_opcode op));
d369 1
a369 1
extern value_ptr value_add PARAMS ((value_ptr arg1, value_ptr arg2));
d371 1
a371 1
extern value_ptr value_sub PARAMS ((value_ptr arg1, value_ptr arg2));
d373 1
a373 1
extern value_ptr value_coerce_array PARAMS ((value_ptr arg1));
d375 1
a375 1
extern value_ptr value_coerce_function PARAMS ((value_ptr arg1));
d377 4
a380 1
extern value_ptr value_ind PARAMS ((value_ptr arg1));
d382 3
a384 1
extern value_ptr value_addr PARAMS ((value_ptr arg1));
d386 1
a386 1
extern value_ptr value_assign PARAMS ((value_ptr toval, value_ptr fromval));
d388 3
a390 1
extern value_ptr value_neg PARAMS ((value_ptr arg1));
d392 5
a396 1
extern value_ptr value_complement PARAMS ((value_ptr arg1));
d398 1
a398 3
extern value_ptr value_struct_elt PARAMS ((value_ptr *argp, value_ptr *args,
					   char *name,
					   int *static_memfuncp, char *err));
d400 3
a402 5
extern value_ptr value_struct_elt_for_reference PARAMS ((struct type *domain,
							 int offset,
							 struct type *curtype,
							 char *name,
							 struct type *intype));
a403 1
extern value_ptr value_field PARAMS ((value_ptr arg1, int fieldno));
d405 2
a406 3
extern value_ptr value_primitive_field PARAMS ((value_ptr arg1, int offset,
						int fieldno,
						struct type *arg_type));
d408 2
a409 1
extern value_ptr value_cast PARAMS ((struct type *type, value_ptr arg2));
d411 1
a411 1
extern value_ptr value_zero PARAMS ((struct type *type, enum lval_type lv));
d413 1
a413 1
extern value_ptr value_repeat PARAMS ((value_ptr arg1, int count));
d415 1
a415 1
extern value_ptr value_subscript PARAMS ((value_ptr array, value_ptr idx));
d417 1
a417 2
extern value_ptr value_from_vtable_info PARAMS ((value_ptr arg,
						 struct type *type));
d419 2
a420 3
extern value_ptr value_being_returned PARAMS ((struct type *valtype, 
					       char retbuf[REGISTER_BYTES],
					       int struct_return));
d422 1
a422 1
extern value_ptr value_in PARAMS ((value_ptr element, value_ptr set));
d424 1
a424 1
extern int value_bit_index PARAMS ((struct type *type, char *addr, int index));
d426 1
a426 2
extern int using_struct_return PARAMS ((value_ptr function, CORE_ADDR funcaddr,
					struct type *value_type, int gcc_p));
d428 1
a428 1
extern void set_return_value PARAMS ((value_ptr val));
d430 1
a430 1
extern value_ptr evaluate_expression PARAMS ((struct expression *exp));
d432 2
a433 1
extern value_ptr evaluate_type PARAMS ((struct expression *exp));
d435 1
a435 2
extern value_ptr evaluate_subexp_with_coercion PARAMS ((struct expression *,
							int *, enum noside));
d437 1
a437 1
extern value_ptr parse_and_eval PARAMS ((char *exp));
d439 1
a439 1
extern value_ptr parse_to_comma_and_eval PARAMS ((char **expp));
d441 1
a441 1
extern struct type *parse_and_eval_type PARAMS ((char *p, int length));
d443 1
a443 1
extern CORE_ADDR parse_and_eval_address PARAMS ((char *exp));
d445 1
a445 1
extern CORE_ADDR parse_and_eval_address_1 PARAMS ((char **expptr));
d447 1
a447 1
extern value_ptr access_value_history PARAMS ((int num));
d449 1
a449 1
extern value_ptr value_of_internalvar PARAMS ((struct internalvar *var));
d451 1
a451 1
extern void set_internalvar PARAMS ((struct internalvar *var, value_ptr val));
d453 4
a456 4
extern void set_internalvar_component PARAMS ((struct internalvar *var,
					       int offset,
					       int bitpos, int bitsize,
					       value_ptr newvalue));
d458 1
a458 1
extern struct internalvar *lookup_internalvar PARAMS ((char *name));
d460 1
a460 1
extern int value_equal PARAMS ((value_ptr arg1, value_ptr arg2));
d462 1
a462 1
extern int value_less PARAMS ((value_ptr arg1, value_ptr arg2));
d464 1
a464 1
extern int value_logical_not PARAMS ((value_ptr arg1));
d468 1
a468 1
extern value_ptr value_of_this PARAMS ((int complain));
d470 4
a473 4
extern value_ptr value_x_binop PARAMS ((value_ptr arg1, value_ptr arg2,
					enum exp_opcode op,
					enum exp_opcode otherop,
					enum noside noside));
d475 2
a476 2
extern value_ptr value_x_unop PARAMS ((value_ptr arg1, enum exp_opcode op,
				       enum noside noside));
d478 2
a479 3
extern value_ptr value_fn_field PARAMS ((value_ptr *arg1p, struct fn_field *f,
					 int j,
					 struct type* type, int offset));
d481 2
a482 4
extern value_ptr value_virtual_fn_field PARAMS ((value_ptr *arg1p,
						 struct fn_field *f, int j,
						 struct type *type,
						 int offset));
d484 1
a484 2
extern int binop_user_defined_p PARAMS ((enum exp_opcode op,
					 value_ptr arg1, value_ptr arg2));
d486 1
a486 1
extern int unop_user_defined_p PARAMS ((enum exp_opcode op, value_ptr arg1));
d488 1
a488 2
extern int destructor_name_p PARAMS ((const char *name,
				      const struct type *type));
d490 1
a490 1
#define value_free(val) free ((PTR)val)
d492 1
a492 1
extern void free_all_values PARAMS ((void));
d494 1
a494 1
extern void release_value PARAMS ((value_ptr val));
d496 2
a497 1
extern int record_latest_value PARAMS ((value_ptr val));
d499 2
a500 1
extern void registers_changed PARAMS ((void));
d502 2
a503 1
extern void read_register_bytes PARAMS ((int regbyte, char *myaddr, int len));
d505 2
a506 1
extern void write_register_bytes PARAMS ((int regbyte, char *myaddr, int len));
d508 2
a509 2
extern void
read_register_gen PARAMS ((int regno, char *myaddr));
d511 2
a512 2
extern CORE_ADDR
read_register PARAMS ((int regno));
d514 3
a516 2
extern CORE_ADDR
read_register_pid PARAMS ((int regno, int pid));
d518 1
a518 2
extern void
write_register PARAMS ((int regno, LONGEST val));
d520 5
a524 2
extern void
write_register_pid PARAMS ((int regno, LONGEST val, int pid));
d526 1
a526 2
extern void
supply_register PARAMS ((int regno, char *val));
d528 3
a530 4
extern void
get_saved_register PARAMS ((char *raw_buffer, int *optimized,
			    CORE_ADDR *addrp, struct frame_info *frame,
			    int regnum, enum lval_type *lval));
d532 1
a532 2
extern void
modify_field PARAMS ((char *addr, LONGEST fieldval, int bitpos, int bitsize));
d534 2
a535 3
extern void
type_print PARAMS ((struct type *type, char *varstring, GDB_FILE *stream,
		    int show));
d537 1
a537 3
extern char *baseclass_addr PARAMS ((struct type *type, int index,
				     char *valaddr,
				     value_ptr *valuep, int *errp));
d539 1
a539 3
extern void
print_longest PARAMS ((GDB_FILE *stream, int format, int use_local,
		       LONGEST val));
d541 1
a541 2
extern void
print_floating PARAMS ((char *valaddr, struct type *type, GDB_FILE *stream));
d543 1
a543 2
extern int value_print PARAMS ((value_ptr val, GDB_FILE *stream, int format,
				enum val_prettyprint pretty));
d545 1
a545 3
extern void
value_print_array_elements PARAMS ((value_ptr val, GDB_FILE* stream,
				    int format, enum val_prettyprint pretty));
d547 1
a547 14
extern value_ptr
value_release_to_mark PARAMS ((value_ptr mark));

extern int
val_print PARAMS ((struct type *type, char *valaddr, CORE_ADDR address,
		   GDB_FILE *stream, int format, int deref_ref,
		   int recurse, enum val_prettyprint pretty));

extern int
val_print_string PARAMS ((CORE_ADDR addr, unsigned int len, GDB_FILE *stream));

extern void
print_variable_value PARAMS ((struct symbol *var, struct frame_info *frame,
			      GDB_FILE *stream));
d549 1
a549 1
extern int check_field PARAMS ((value_ptr, const char *));
d551 1
a551 19
extern void
c_typedef_print PARAMS ((struct type *type, struct symbol *news, GDB_FILE *stream));

extern char *
internalvar_name PARAMS ((struct internalvar *var));

extern void
clear_value_history PARAMS ((void));

extern void
clear_internalvars PARAMS ((void));

/* From values.c */

extern value_ptr value_copy PARAMS ((value_ptr));

extern int baseclass_offset PARAMS ((struct type *, int, char *, CORE_ADDR));

/* From valops.c */
d553 2
a554 1
extern value_ptr varying_to_slice PARAMS ((value_ptr));
d556 2
a557 1
extern value_ptr value_slice PARAMS ((value_ptr, int, int));
d559 1
a559 1
extern value_ptr call_function_by_hand PARAMS ((value_ptr, int, value_ptr *));
d561 1
a561 1
extern value_ptr value_literal_complex PARAMS ((value_ptr, value_ptr, struct type*));
d563 3
a565 1
extern value_ptr find_function_in_inferior PARAMS ((char *));
d567 1
a567 1
extern value_ptr value_allocate_space_in_inferior PARAMS ((int));
d569 1
a569 1
#endif	/* !defined (VALUE_H) */
@


1.1
log
@file value.h was initially added on branch CYGNUS.
@
text
@d1 506
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 569
/* Definitions for values of C expressions, for GDB.

   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#if !defined (VALUE_H)
#define VALUE_H 1

#include "doublest.h"
#include "frame.h"		/* For struct frame_id.  */

struct block;
struct expression;
struct regcache;
struct symbol;
struct type;
struct ui_file;

/* The structure which defines the type of a value.  It should never
   be possible for a program lval value to survive over a call to the
   inferior (i.e. to be put into the history list or an internal
   variable).  */

struct value
{
  /* Type of value; either not an lval, or one of the various
     different possible kinds of lval.  */
  enum lval_type lval;

  /* Is it modifiable?  Only relevant if lval != not_lval.  */
  int modifiable;

  /* Location of value (if lval).  */
  union
  {
    /* If lval == lval_memory, this is the address in the inferior.
       If lval == lval_register, this is the byte offset into the
       registers structure.  */
    CORE_ADDR address;

    /* Pointer to internal variable.  */
    struct internalvar *internalvar;

    /* Number of register.  Only used with lval_reg_frame_relative.  */
    int regnum;
  } location;

  /* Describes offset of a value within lval of a structure in bytes.
     If lval == lval_memory, this is an offset to the address.
     If lval == lval_register, this is a further offset from
     location.address within the registers structure.  
     Note also the member embedded_offset below.  */
  int offset;

  /* Only used for bitfields; number of bits contained in them.  */
  int bitsize;

  /* Only used for bitfields; position of start of field.
     For BITS_BIG_ENDIAN=0 targets, it is the position of the LSB.
     For BITS_BIG_ENDIAN=1 targets, it is the position of the MSB. */
    int bitpos;

  /* Frame value is relative to.  In practice, this ID is only used if
     the value is stored in several registers in other than the
     current frame, and these registers have not all been saved at the
     same place in memory.  This will be described in the lval enum
     above as "lval_reg_frame_relative".  */
  struct frame_id frame_id;

  /* Type of the value.  */
  struct type *type;

  /* If a value represents a C++ object, then the `type' field gives
     the object's compile-time type.  If the object actually belongs
     to some class derived from `type', perhaps with other base
     classes and additional members, then `type' is just a subobject
     of the real thing, and the full object is probably larger than
     `type' would suggest.

     If `type' is a dynamic class (i.e. one with a vtable), then GDB
     can actually determine the object's run-time type by looking at
     the run-time type information in the vtable.  When this
     information is available, we may elect to read in the entire
     object, for several reasons:

     - When printing the value, the user would probably rather see the
       full object, not just the limited portion apparent from the
       compile-time type.

     - If `type' has virtual base classes, then even printing `type'
       alone may require reaching outside the `type' portion of the
       object to wherever the virtual base class has been stored.

     When we store the entire object, `enclosing_type' is the run-time
     type -- the complete object -- and `embedded_offset' is the
     offset of `type' within that larger type, in bytes.  The
     VALUE_CONTENTS macro takes `embedded_offset' into account, so
     most GDB code continues to see the `type' portion of the value,
     just as the inferior would.

     If `type' is a pointer to an object, then `enclosing_type' is a
     pointer to the object's run-time type, and `pointed_to_offset' is
     the offset in bytes from the full object to the pointed-to object
     -- that is, the value `embedded_offset' would have if we
     followed the pointer and fetched the complete object.  (I don't
     really see the point.  Why not just determine the run-time type
     when you indirect, and avoid the special case?  The contents
     don't matter until you indirect anyway.)

     If we're not doing anything fancy, `enclosing_type' is equal to
     `type', and `embedded_offset' is zero, so everything works
     normally.  */
    struct type *enclosing_type;
    int embedded_offset;
    int pointed_to_offset;

    /* Values are stored in a chain, so that they can be deleted
       easily over calls to the inferior.  Values assigned to internal
       variables or put into the value history are taken off this
       list.  */
    struct value *next;

    /* Register number if the value is from a register.  */
    short regno;

    /* If zero, contents of this value are in the contents field.  If
       nonzero, contents are in inferior memory at address in the
       location.address field plus the offset field (and the lval
       field should be lval_memory).

       WARNING: This field is used by the code which handles
       watchpoints (see breakpoint.c) to decide whether a particular
       value can be watched by hardware watchpoints.  If the lazy flag
       is set for some member of a value chain, it is assumed that
       this member of the chain doesn't need to be watched as part of
       watching the value itself.  This is how GDB avoids watching the
       entire struct or array when the user wants to watch a single
       struct member or array element.  If you ever change the way
       lazy flag is set and reset, be sure to consider this use as
       well!  */
    char lazy;

    /* If nonzero, this is the value of a variable which does not
       actually exist in the program.  */
    char optimized_out;

    /* The BFD section associated with this value.  */
    asection *bfd_section;

    /* Actual contents of the value.  For use of this value; setting
       it uses the stuff above.  Not valid if lazy is nonzero.
       Target byte-order.  We force it to be aligned properly for any
       possible value.  Note that a value therefore extends beyond
       what is declared here.  */
    union
    {
      long contents[1];
      DOUBLEST force_doublest_align;
      LONGEST force_longest_align;
      CORE_ADDR force_core_addr_align;
      void *force_pointer_align;
    } aligner;
    /* Do not add any new members here -- contents above will trash them.  */
};

#define VALUE_TYPE(val) (val)->type
#define VALUE_ENCLOSING_TYPE(val) (val)->enclosing_type
#define VALUE_LAZY(val) (val)->lazy

/* VALUE_CONTENTS and VALUE_CONTENTS_RAW both return the address of
   the gdb buffer used to hold a copy of the contents of the lval.
   VALUE_CONTENTS is used when the contents of the buffer are needed
   -- it uses value_fetch_lazy() to load the buffer from the process
   being debugged if it hasn't already been loaded.
   VALUE_CONTENTS_RAW is used when data is being stored into the
   buffer, or when it is certain that the contents of the buffer are
   valid.

   Note: The contents pointer is adjusted by the offset required to
   get to the real subobject, if the value happens to represent
   something embedded in a larger run-time object.  */

#define VALUE_CONTENTS_RAW(val) \
 ((char *) (val)->aligner.contents + (val)->embedded_offset)
#define VALUE_CONTENTS(val) \
 ((void)(VALUE_LAZY(val) && value_fetch_lazy(val)), VALUE_CONTENTS_RAW(val))

/* The ALL variants of the above two macros do not adjust the returned
   pointer by the embedded_offset value.  */

#define VALUE_CONTENTS_ALL_RAW(val) ((char *) (val)->aligner.contents)
#define VALUE_CONTENTS_ALL(val) \
  ((void) (VALUE_LAZY(val) && value_fetch_lazy(val)), \
   VALUE_CONTENTS_ALL_RAW(val))

extern int value_fetch_lazy (struct value *val);

#define VALUE_LVAL(val) (val)->lval
#define VALUE_ADDRESS(val) (val)->location.address
#define VALUE_INTERNALVAR(val) (val)->location.internalvar
#define VALUE_FRAME_REGNUM(val) ((val)->location.regnum)
#define VALUE_FRAME_ID(val) ((val)->frame_id)
#define VALUE_OFFSET(val) (val)->offset
#define VALUE_BITSIZE(val) (val)->bitsize
#define VALUE_BITPOS(val) (val)->bitpos
#define VALUE_NEXT(val) (val)->next
#define VALUE_REGNO(val) (val)->regno
#define VALUE_OPTIMIZED_OUT(val) ((val)->optimized_out)
#define VALUE_EMBEDDED_OFFSET(val) ((val)->embedded_offset)
#define VALUE_POINTED_TO_OFFSET(val) ((val)->pointed_to_offset)
#define VALUE_BFD_SECTION(val) ((val)->bfd_section)

/* Convert a REF to the object referenced.  */

#define COERCE_REF(arg) \
  do {									\
    struct type *value_type_arg_tmp = check_typedef (VALUE_TYPE (arg));	\
    if (TYPE_CODE (value_type_arg_tmp) == TYPE_CODE_REF)		\
      arg = value_at_lazy (TYPE_TARGET_TYPE (value_type_arg_tmp),	\
                           unpack_pointer (VALUE_TYPE (arg),		\
                                           VALUE_CONTENTS (arg)),	\
			                   VALUE_BFD_SECTION (arg));	\
  } while (0)

/* If ARG is an array, convert it to a pointer.
   If ARG is an enum, convert it to an integer.
   If ARG is a function, convert it to a function pointer.

   References are dereferenced.  */

#define COERCE_ARRAY(arg) \
  do {									\
    COERCE_REF(arg);							\
    if (current_language->c_style_arrays				\
        && TYPE_CODE (VALUE_TYPE (arg)) == TYPE_CODE_ARRAY)		\
      arg = value_coerce_array (arg);					\
    if (TYPE_CODE (VALUE_TYPE (arg)) == TYPE_CODE_FUNC)			\
      arg = value_coerce_function (arg);				\
  } while (0)

#define COERCE_NUMBER(arg) \
  do { COERCE_ARRAY(arg); COERCE_ENUM(arg); } while (0)

/* NOTE: cagney/2002-12-17: This macro was handling a chill language
   problem but that language has gone away.  */
#define COERCE_VARYING_ARRAY(arg, real_arg_type)

/* If ARG is an enum, convert it to an integer.  */

#define COERCE_ENUM(arg) \
  do {									\
    if (TYPE_CODE (check_typedef (VALUE_TYPE (arg))) == TYPE_CODE_ENUM)	\
      arg = value_cast (builtin_type_unsigned_int, arg);		\
  } while (0)

/* Internal variables (variables for convenience of use of debugger)
   are recorded as a chain of these structures.  */

struct internalvar
{
  struct internalvar *next;
  char *name;
  struct value *value;
};

/* Pointer to member function.  Depends on compiler implementation.  */

#define METHOD_PTR_IS_VIRTUAL(ADDR)  ((ADDR) & 0x80000000)
#define METHOD_PTR_FROM_VOFFSET(OFFSET) (0x80000000 + (OFFSET))
#define METHOD_PTR_TO_VOFFSET(ADDR) (~0x80000000 & (ADDR))


#include "symtab.h"
#include "gdbtypes.h"
#include "expression.h"

struct frame_info;
struct fn_field;

extern void print_address_demangle (CORE_ADDR, struct ui_file *, int);

extern LONGEST value_as_long (struct value *val);
extern DOUBLEST value_as_double (struct value *val);
extern CORE_ADDR value_as_address (struct value *val);

extern LONGEST unpack_long (struct type *type, const char *valaddr);
extern DOUBLEST unpack_double (struct type *type, const char *valaddr,
			       int *invp);
extern CORE_ADDR unpack_pointer (struct type *type, const char *valaddr);
extern LONGEST unpack_field_as_long (struct type *type, const char *valaddr,
				     int fieldno);

extern struct value *value_from_longest (struct type *type, LONGEST num);
extern struct value *value_from_pointer (struct type *type, CORE_ADDR addr);
extern struct value *value_from_double (struct type *type, DOUBLEST num);
extern struct value *value_from_string (char *string);

extern struct value *value_at (struct type *type, CORE_ADDR addr,
			       asection * sect);
extern struct value *value_at_lazy (struct type *type, CORE_ADDR addr,
				    asection * sect);

extern struct value *value_from_register (struct type *type, int regnum,
					  struct frame_info *frame);

extern struct value *value_of_variable (struct symbol *var, struct block *b);

extern struct value *value_of_register (int regnum,
					struct frame_info *frame);

extern int symbol_read_needs_frame (struct symbol *);

extern struct value *read_var_value (struct symbol *var,
				     struct frame_info *frame);

extern struct value *locate_var_value (struct symbol *var,
				       struct frame_info *frame);

extern struct value *allocate_value (struct type *type);

extern struct value *allocate_repeat_value (struct type *type, int count);

extern struct value *value_change_enclosing_type (struct value *val,
						  struct type *new_type);

extern struct value *value_mark (void);

extern void value_free_to_mark (struct value *mark);

extern struct value *value_string (char *ptr, int len);
extern struct value *value_bitstring (char *ptr, int len);

extern struct value *value_array (int lowbound, int highbound,
				  struct value ** elemvec);

extern struct value *value_concat (struct value *arg1, struct value *arg2);

extern struct value *value_binop (struct value *arg1, struct value *arg2,
				  enum exp_opcode op);

extern struct value *value_add (struct value *arg1, struct value *arg2);

extern struct value *value_sub (struct value *arg1, struct value *arg2);

extern struct value *value_coerce_array (struct value *arg1);

extern struct value *value_coerce_function (struct value *arg1);

extern struct value *value_ind (struct value *arg1);

extern struct value *value_addr (struct value *arg1);

extern struct value *value_assign (struct value *toval, struct value *fromval);

extern struct value *value_neg (struct value *arg1);

extern struct value *value_complement (struct value *arg1);

extern struct value *value_struct_elt (struct value **argp,
				       struct value **args,
				       char *name, int *static_memfuncp,
				       char *err);

extern struct value *value_aggregate_elt (struct type *curtype,
					  char *name,
					  enum noside noside);

extern struct value *value_static_field (struct type *type, int fieldno);

extern struct fn_field *value_find_oload_method_list (struct value **, char *,
						      int, int *,
						      struct type **, int *);

extern int find_overload_match (struct type **arg_types, int nargs,
				char *name, int method, int lax,
				struct value **objp, struct symbol *fsym,
				struct value **valp, struct symbol **symp,
				int *staticp);

extern struct value *value_field (struct value *arg1, int fieldno);

extern struct value *value_primitive_field (struct value *arg1, int offset,
					    int fieldno,
					    struct type *arg_type);


extern struct type *value_rtti_target_type (struct value *, int *, int *,
					    int *);

extern struct value *value_full_object (struct value *, struct type *, int,
					int, int);

extern struct value *value_cast (struct type *type, struct value *arg2);

extern struct value *value_zero (struct type *type, enum lval_type lv);

extern struct value *value_repeat (struct value *arg1, int count);

extern struct value *value_subscript (struct value *array, struct value *idx);

extern struct value *register_value_being_returned (struct type *valtype,
						    struct regcache *retbuf);

extern struct value *value_in (struct value *element, struct value *set);

extern int value_bit_index (struct type *type, char *addr, int index);

extern int using_struct_return (struct type *value_type, int gcc_p);

extern struct value *evaluate_expression (struct expression *exp);

extern struct value *evaluate_type (struct expression *exp);

extern struct value *evaluate_subexp_with_coercion (struct expression *,
						    int *, enum noside);

extern struct value *parse_and_eval (char *exp);

extern struct value *parse_to_comma_and_eval (char **expp);

extern struct type *parse_and_eval_type (char *p, int length);

extern CORE_ADDR parse_and_eval_address (char *exp);

extern CORE_ADDR parse_and_eval_address_1 (char **expptr);

extern LONGEST parse_and_eval_long (char *exp);

extern struct value *access_value_history (int num);

extern struct value *value_of_internalvar (struct internalvar *var);

extern void set_internalvar (struct internalvar *var, struct value *val);

extern void set_internalvar_component (struct internalvar *var,
				       int offset,
				       int bitpos, int bitsize,
				       struct value *newvalue);

extern struct internalvar *lookup_internalvar (char *name);

extern int value_equal (struct value *arg1, struct value *arg2);

extern int value_less (struct value *arg1, struct value *arg2);

extern int value_logical_not (struct value *arg1);

/* C++ */

extern struct value *value_of_this (int complain);

extern struct value *value_x_binop (struct value *arg1, struct value *arg2,
				    enum exp_opcode op,
				    enum exp_opcode otherop,
				    enum noside noside);

extern struct value *value_x_unop (struct value *arg1, enum exp_opcode op,
				   enum noside noside);

extern struct value *value_fn_field (struct value ** arg1p, struct fn_field *f,
				     int j, struct type *type, int offset);

extern int binop_user_defined_p (enum exp_opcode op, struct value *arg1,
				 struct value *arg2);

extern int unop_user_defined_p (enum exp_opcode op, struct value *arg1);

extern int destructor_name_p (const char *name, const struct type *type);

#define value_free(val) xfree (val)

extern void free_all_values (void);

extern void release_value (struct value *val);

extern int record_latest_value (struct value *val);

extern void modify_field (char *addr, LONGEST fieldval, int bitpos,
			  int bitsize);

extern void type_print (struct type * type, char *varstring,
			struct ui_file * stream, int show);

extern char *baseclass_addr (struct type *type, int index, char *valaddr,
			     struct value **valuep, int *errp);

extern void print_longest (struct ui_file * stream, int format,
			   int use_local, LONGEST val);

extern void print_floating (char *valaddr, struct type * type,
			    struct ui_file * stream);

extern int value_print (struct value *val, struct ui_file *stream, int format,
			enum val_prettyprint pretty);

extern void value_print_array_elements (struct value *val,
					struct ui_file *stream, int format,
					enum val_prettyprint pretty);

extern struct value *value_release_to_mark (struct value *mark);

extern int val_print (struct type * type, char *valaddr,
		      int embedded_offset, CORE_ADDR address,
		      struct ui_file * stream, int format,
		      int deref_ref, int recurse,
		      enum val_prettyprint pretty);

extern int val_print_string (CORE_ADDR addr, int len, int width, struct ui_file *stream);

extern void print_variable_value (struct symbol * var,
				  struct frame_info * frame,
				  struct ui_file *stream);

extern int check_field (struct value *, const char *);

extern void typedef_print (struct type * type, struct symbol * news,
			     struct ui_file * stream);

extern char *internalvar_name (struct internalvar *var);

extern void clear_value_history (void);

extern void clear_internalvars (void);

/* From values.c */

extern struct value *value_copy (struct value *);

/* From valops.c */

extern struct value *varying_to_slice (struct value *);

extern struct value *value_slice (struct value *, int, int);

extern struct value *value_literal_complex (struct value *, struct value *,
					    struct type *);

extern void find_rt_vbase_offset (struct type *, struct type *, char *, int,
				  int *, int *);

extern struct value *find_function_in_inferior (const char *);

extern struct value *value_allocate_space_in_inferior (int);

extern CORE_ADDR legacy_push_arguments (int nargs, struct value ** args,
					CORE_ADDR sp, int struct_return,
					CORE_ADDR struct_addr);

extern struct value *value_of_local (const char *name, int complain);

#endif /* !defined (VALUE_H) */
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d563 4
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 506
/* Definitions for values of C expressions, for GDB.
   Copyright 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996
   Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#if !defined (VALUE_H)
#define VALUE_H 1

/*
 * The structure which defines the type of a value.  It should never
 * be possible for a program lval value to survive over a call to the inferior
 * (ie to be put into the history list or an internal variable).
 */
enum lval_type {
  /* Not an lval.  */
  not_lval,
  /* In memory.  Could be a saved register.  */
  lval_memory,
  /* In a register.  */
  lval_register,
  /* In a gdb internal variable.  */
  lval_internalvar,
  /* Part of a gdb internal variable (structure field).  */
  lval_internalvar_component,
  /* In a register series in a frame not the current one, which may have been
     partially saved or saved in different places (otherwise would be
     lval_register or lval_memory).  */
  lval_reg_frame_relative
};

struct value
  {
    /* Type of value; either not an lval, or one of the various
       different possible kinds of lval.  */
    enum lval_type lval;
    /* Is it modifiable?  Only relevant if lval != not_lval.  */
    int modifiable;
    /* Location of value (if lval).  */
    union
      {
	/* Address in inferior or byte of registers structure.  */
	CORE_ADDR address;
	/* Pointer to internal variable.  */
	struct internalvar *internalvar;
	/* Number of register.  Only used with
	   lval_reg_frame_relative.  */
	int regnum;
      } location;
    /* Describes offset of a value within lval a structure in bytes.  */
    int offset;	
    /* Only used for bitfields; number of bits contained in them.  */
    int bitsize;
    /* Only used for bitfields; position of start of field.
       For BITS_BIG_ENDIAN=0 targets, it is the position of the LSB.
       For BITS_BIG_ENDIAN=1 targets, it is the position of the MSB. */
    int bitpos;
    /* Frame value is relative to.  In practice, this address is only
       used if the value is stored in several registers in other than
       the current frame, and these registers have not all been saved
       at the same place in memory.  This will be described in the
       lval enum above as "lval_reg_frame_relative".  */
    CORE_ADDR frame_addr;
    /* Type of the value.  */
    struct type *type;
    /* Values are stored in a chain, so that they can be deleted
       easily over calls to the inferior.  Values assigned to internal
       variables or put into the value history are taken off this
       list.  */
    struct value *next;

    /* ??? When is this used?  */
    union {
      CORE_ADDR memaddr;
      char *myaddr;
    } substring_addr;

    /* Register number if the value is from a register.  Is not kept
       if you take a field of a structure that is stored in a
       register.  Shouldn't it be?  */
    short regno;
    /* If zero, contents of this value are in the contents field.
       If nonzero, contents are in inferior memory at address
       in the location.address field plus the offset field
       (and the lval field should be lval_memory).  */
    char lazy;
    /* If nonzero, this is the value of a variable which does not
       actually exist in the program.  */
    char optimized_out;
    /* Actual contents of the value.  For use of this value; setting
       it uses the stuff above.  Not valid if lazy is nonzero.
       Target byte-order.  We force it to be aligned properly for any
       possible value.  */
    union {
      long contents[1];
      double force_double_align;
      LONGEST force_longlong_align;
      char *literal_data;
    } aligner;

  };

typedef struct value *value_ptr;

#define VALUE_TYPE(val) (val)->type
#define VALUE_LAZY(val) (val)->lazy
/* VALUE_CONTENTS and VALUE_CONTENTS_RAW both return the address of
   the gdb buffer used to hold a copy of the contents of the lval.  
   VALUE_CONTENTS is used when the contents of the buffer are needed --
   it uses value_fetch_lazy() to load the buffer from the process being 
   debugged if it hasn't already been loaded.  VALUE_CONTENTS_RAW is 
   used when data is being stored into the buffer, or when it is 
   certain that the contents of the buffer are valid.  */
#define VALUE_CONTENTS_RAW(val) ((char *) (val)->aligner.contents)
#define VALUE_CONTENTS(val) ((void)(VALUE_LAZY(val) && value_fetch_lazy(val)),\
			     VALUE_CONTENTS_RAW(val))
extern int value_fetch_lazy PARAMS ((value_ptr val));

#define VALUE_LVAL(val) (val)->lval
#define VALUE_ADDRESS(val) (val)->location.address
#define VALUE_INTERNALVAR(val) (val)->location.internalvar
#define VALUE_FRAME_REGNUM(val) ((val)->location.regnum)
#define VALUE_FRAME(val) ((val)->frame_addr)
#define VALUE_OFFSET(val) (val)->offset
#define VALUE_BITSIZE(val) (val)->bitsize
#define VALUE_BITPOS(val) (val)->bitpos
#define VALUE_NEXT(val) (val)->next
#define VALUE_REGNO(val) (val)->regno
#define VALUE_OPTIMIZED_OUT(val) ((val)->optimized_out)

/* Convert a REF to the object referenced. */

#define COERCE_REF(arg)    \
do { struct type *value_type_arg_tmp = check_typedef (VALUE_TYPE (arg));\
     if (TYPE_CODE (value_type_arg_tmp) == TYPE_CODE_REF)		\
	 arg = value_at_lazy (TYPE_TARGET_TYPE (value_type_arg_tmp),	\
			      unpack_long (VALUE_TYPE (arg),		\
					   VALUE_CONTENTS (arg)));      \
    } while (0)

/* If ARG is an array, convert it to a pointer.
   If ARG is an enum, convert it to an integer.
   If ARG is a function, convert it to a function pointer.

   References are dereferenced.  */

#define COERCE_ARRAY(arg)    \
do { COERCE_REF(arg);							\
  if (current_language->c_style_arrays					\
      && TYPE_CODE (VALUE_TYPE (arg)) == TYPE_CODE_ARRAY)		\
    arg = value_coerce_array (arg);					\
  if (TYPE_CODE (VALUE_TYPE (arg)) == TYPE_CODE_FUNC)                   \
    arg = value_coerce_function (arg);                                  \
} while (0)

#define COERCE_NUMBER(arg)  \
  do { COERCE_ARRAY(arg);  COERCE_ENUM(arg); } while (0)

#define COERCE_VARYING_ARRAY(arg, real_arg_type)	\
{ if (chill_varying_type (real_arg_type))  \
    arg = varying_to_slice (arg), real_arg_type = VALUE_TYPE (arg); }

/* If ARG is an enum, convert it to an integer.  */

#define COERCE_ENUM(arg)   { \
  if (TYPE_CODE (check_typedef (VALUE_TYPE (arg))) == TYPE_CODE_ENUM)	\
    arg = value_cast (builtin_type_unsigned_int, arg);			\
}

/* Internal variables (variables for convenience of use of debugger)
   are recorded as a chain of these structures.  */

struct internalvar
{
  struct internalvar *next;
  char *name;
  value_ptr value;
};

/* Pointer to member function.  Depends on compiler implementation. */

#define METHOD_PTR_IS_VIRTUAL(ADDR)  ((ADDR) & 0x80000000)
#define METHOD_PTR_FROM_VOFFSET(OFFSET) (0x80000000 + (OFFSET))
#define METHOD_PTR_TO_VOFFSET(ADDR) (~0x80000000 & (ADDR))


#include "symtab.h"
#include "gdbtypes.h"
#include "expression.h"

#ifdef __STDC__
struct frame_info;
struct fn_field;
#endif

extern void
print_address_demangle PARAMS ((CORE_ADDR, GDB_FILE *, int));

extern LONGEST value_as_long PARAMS ((value_ptr val));

extern DOUBLEST value_as_double PARAMS ((value_ptr val));

extern CORE_ADDR value_as_pointer PARAMS ((value_ptr val));

extern LONGEST unpack_long PARAMS ((struct type *type, char *valaddr));

extern DOUBLEST unpack_double PARAMS ((struct type *type, char *valaddr,
				       int *invp));

extern CORE_ADDR unpack_pointer PARAMS ((struct type *type, char *valaddr));

extern LONGEST unpack_field_as_long PARAMS ((struct type *type, char *valaddr,
					     int fieldno));

extern value_ptr value_from_longest PARAMS ((struct type *type, LONGEST num));

extern value_ptr value_from_double PARAMS ((struct type *type, DOUBLEST num));

extern value_ptr value_at PARAMS ((struct type *type, CORE_ADDR addr));

extern value_ptr value_at_lazy PARAMS ((struct type *type, CORE_ADDR addr));

extern value_ptr value_from_register PARAMS ((struct type *type, int regnum,
					  struct frame_info * frame));

extern value_ptr value_of_variable PARAMS ((struct symbol *var,
					    struct block *b));

extern value_ptr value_of_register PARAMS ((int regnum));

extern int symbol_read_needs_frame PARAMS ((struct symbol *));

extern value_ptr read_var_value PARAMS ((struct symbol *var,
					 struct frame_info *frame));

extern value_ptr locate_var_value PARAMS ((struct symbol *var,
				       struct frame_info *frame));

extern value_ptr allocate_value PARAMS ((struct type *type));

extern value_ptr allocate_repeat_value PARAMS ((struct type *type, int count));

extern value_ptr value_mark PARAMS ((void));

extern void value_free_to_mark PARAMS ((value_ptr mark));

extern value_ptr value_string PARAMS ((char *ptr, int len));
extern value_ptr value_bitstring PARAMS ((char *ptr, int len));

extern value_ptr value_array PARAMS ((int lowbound, int highbound,
				      value_ptr *elemvec));

extern value_ptr value_concat PARAMS ((value_ptr arg1, value_ptr arg2));

extern value_ptr value_binop PARAMS ((value_ptr arg1, value_ptr arg2,
				      enum exp_opcode op));

extern value_ptr value_add PARAMS ((value_ptr arg1, value_ptr arg2));

extern value_ptr value_sub PARAMS ((value_ptr arg1, value_ptr arg2));

extern value_ptr value_coerce_array PARAMS ((value_ptr arg1));

extern value_ptr value_coerce_function PARAMS ((value_ptr arg1));

extern value_ptr value_ind PARAMS ((value_ptr arg1));

extern value_ptr value_addr PARAMS ((value_ptr arg1));

extern value_ptr value_assign PARAMS ((value_ptr toval, value_ptr fromval));

extern value_ptr value_neg PARAMS ((value_ptr arg1));

extern value_ptr value_complement PARAMS ((value_ptr arg1));

extern value_ptr value_struct_elt PARAMS ((value_ptr *argp, value_ptr *args,
					   char *name,
					   int *static_memfuncp, char *err));

extern value_ptr value_struct_elt_for_reference PARAMS ((struct type *domain,
							 int offset,
							 struct type *curtype,
							 char *name,
							 struct type *intype));

extern value_ptr value_field PARAMS ((value_ptr arg1, int fieldno));

extern value_ptr value_primitive_field PARAMS ((value_ptr arg1, int offset,
						int fieldno,
						struct type *arg_type));

extern value_ptr value_cast PARAMS ((struct type *type, value_ptr arg2));

extern value_ptr value_zero PARAMS ((struct type *type, enum lval_type lv));

extern value_ptr value_repeat PARAMS ((value_ptr arg1, int count));

extern value_ptr value_subscript PARAMS ((value_ptr array, value_ptr idx));

extern value_ptr value_from_vtable_info PARAMS ((value_ptr arg,
						 struct type *type));

extern value_ptr value_being_returned PARAMS ((struct type *valtype, 
					       char retbuf[REGISTER_BYTES],
					       int struct_return));

extern value_ptr value_in PARAMS ((value_ptr element, value_ptr set));

extern int value_bit_index PARAMS ((struct type *type, char *addr, int index));

extern int using_struct_return PARAMS ((value_ptr function, CORE_ADDR funcaddr,
					struct type *value_type, int gcc_p));

extern void set_return_value PARAMS ((value_ptr val));

extern value_ptr evaluate_expression PARAMS ((struct expression *exp));

extern value_ptr evaluate_type PARAMS ((struct expression *exp));

extern value_ptr evaluate_subexp_with_coercion PARAMS ((struct expression *,
							int *, enum noside));

extern value_ptr parse_and_eval PARAMS ((char *exp));

extern value_ptr parse_to_comma_and_eval PARAMS ((char **expp));

extern struct type *parse_and_eval_type PARAMS ((char *p, int length));

extern CORE_ADDR parse_and_eval_address PARAMS ((char *exp));

extern CORE_ADDR parse_and_eval_address_1 PARAMS ((char **expptr));

extern value_ptr access_value_history PARAMS ((int num));

extern value_ptr value_of_internalvar PARAMS ((struct internalvar *var));

extern void set_internalvar PARAMS ((struct internalvar *var, value_ptr val));

extern void set_internalvar_component PARAMS ((struct internalvar *var,
					       int offset,
					       int bitpos, int bitsize,
					       value_ptr newvalue));

extern struct internalvar *lookup_internalvar PARAMS ((char *name));

extern int value_equal PARAMS ((value_ptr arg1, value_ptr arg2));

extern int value_less PARAMS ((value_ptr arg1, value_ptr arg2));

extern int value_logical_not PARAMS ((value_ptr arg1));

/* C++ */

extern value_ptr value_of_this PARAMS ((int complain));

extern value_ptr value_x_binop PARAMS ((value_ptr arg1, value_ptr arg2,
					enum exp_opcode op,
					enum exp_opcode otherop,
					enum noside noside));

extern value_ptr value_x_unop PARAMS ((value_ptr arg1, enum exp_opcode op,
				       enum noside noside));

extern value_ptr value_fn_field PARAMS ((value_ptr *arg1p, struct fn_field *f,
					 int j,
					 struct type* type, int offset));

extern value_ptr value_virtual_fn_field PARAMS ((value_ptr *arg1p,
						 struct fn_field *f, int j,
						 struct type *type,
						 int offset));

extern int binop_user_defined_p PARAMS ((enum exp_opcode op,
					 value_ptr arg1, value_ptr arg2));

extern int unop_user_defined_p PARAMS ((enum exp_opcode op, value_ptr arg1));

extern int destructor_name_p PARAMS ((const char *name,
				      const struct type *type));

#define value_free(val) free ((PTR)val)

extern void free_all_values PARAMS ((void));

extern void release_value PARAMS ((value_ptr val));

extern int record_latest_value PARAMS ((value_ptr val));

extern void registers_changed PARAMS ((void));

extern void read_register_bytes PARAMS ((int regbyte, char *myaddr, int len));

extern void write_register_bytes PARAMS ((int regbyte, char *myaddr, int len));

extern void
read_register_gen PARAMS ((int regno, char *myaddr));

extern CORE_ADDR
read_register PARAMS ((int regno));

extern CORE_ADDR
read_register_pid PARAMS ((int regno, int pid));

extern void
write_register PARAMS ((int regno, LONGEST val));

extern void
write_register_pid PARAMS ((int regno, LONGEST val, int pid));

extern void
supply_register PARAMS ((int regno, char *val));

extern void
get_saved_register PARAMS ((char *raw_buffer, int *optimized,
			    CORE_ADDR *addrp, struct frame_info *frame,
			    int regnum, enum lval_type *lval));

extern void
modify_field PARAMS ((char *addr, LONGEST fieldval, int bitpos, int bitsize));

extern void
type_print PARAMS ((struct type *type, char *varstring, GDB_FILE *stream,
		    int show));

extern char *baseclass_addr PARAMS ((struct type *type, int index,
				     char *valaddr,
				     value_ptr *valuep, int *errp));

extern void
print_longest PARAMS ((GDB_FILE *stream, int format, int use_local,
		       LONGEST val));

extern void
print_floating PARAMS ((char *valaddr, struct type *type, GDB_FILE *stream));

extern int value_print PARAMS ((value_ptr val, GDB_FILE *stream, int format,
				enum val_prettyprint pretty));

extern void
value_print_array_elements PARAMS ((value_ptr val, GDB_FILE* stream,
				    int format, enum val_prettyprint pretty));

extern value_ptr
value_release_to_mark PARAMS ((value_ptr mark));

extern int
val_print PARAMS ((struct type *type, char *valaddr, CORE_ADDR address,
		   GDB_FILE *stream, int format, int deref_ref,
		   int recurse, enum val_prettyprint pretty));

extern int
val_print_string PARAMS ((CORE_ADDR addr, unsigned int len, GDB_FILE *stream));

extern void
print_variable_value PARAMS ((struct symbol *var, struct frame_info *frame,
			      GDB_FILE *stream));

extern int check_field PARAMS ((value_ptr, const char *));

extern void
c_typedef_print PARAMS ((struct type *type, struct symbol *news, GDB_FILE *stream));

extern char *
internalvar_name PARAMS ((struct internalvar *var));

extern void
clear_value_history PARAMS ((void));

extern void
clear_internalvars PARAMS ((void));

/* From values.c */

extern value_ptr value_copy PARAMS ((value_ptr));

extern int baseclass_offset PARAMS ((struct type *, int, char *, CORE_ADDR));

/* From valops.c */

extern value_ptr varying_to_slice PARAMS ((value_ptr));

extern value_ptr value_slice PARAMS ((value_ptr, int, int));

extern value_ptr call_function_by_hand PARAMS ((value_ptr, int, value_ptr *));

extern value_ptr value_literal_complex PARAMS ((value_ptr, value_ptr, struct type*));

extern value_ptr find_function_in_inferior PARAMS ((char *));

extern value_ptr value_allocate_space_in_inferior PARAMS ((int));

#endif	/* !defined (VALUE_H) */
@
