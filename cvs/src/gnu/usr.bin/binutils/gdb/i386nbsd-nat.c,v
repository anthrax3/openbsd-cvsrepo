head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.48
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.44
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.46
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.38
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.42
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.40
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	GDB_6_3:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.1.0.28
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.26
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_3:1.1.0.24
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.22
	OPENBSD_3_2_BASE:1.1
	OPENBSD_3_1:1.1.0.20
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.18
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9:1.1.0.16
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_8:1.1.0.14
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.12
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.10
	OPENBSD_2_6:1.1.0.8
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2005.02.27.19.03.18;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.27.14.00.37;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.08.08.17.59;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.21.20.41.50;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.21.20.23.08;	author kettenis;	state dead;
branches;
next	1.1;

1.1
date	98.03.29.22.17.20;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.12.27.13.12.07;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Fix backtraces for kernel core dumps.
@
text
@/* Native-dependent code for NetBSD/i386.

   Copyright 2004 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "gdbcore.h"
#include "regcache.h"
#include "target.h"

#include "i386-tdep.h"
#include "i386bsd-nat.h"

/* Support for debugging kernel virtual memory images.  */

#include <sys/types.h>
#include <machine/frame.h>
#include <machine/pcb.h>

#include "bsd-kvm.h"

static int
i386nbsd_supply_pcb (struct regcache *regcache, struct pcb *pcb)
{
  struct switchframe sf;

  /* The following is true for NetBSD 1.6.2:

     The pcb contains %esp and %ebp at the point of the context switch
     in cpu_switch().  At that point we have a stack frame as
     described by `struct switchframe', which for NetBSD 1.6.2 has the
     following layout:

     interrupt level
     %edi
     %esi
     %ebx
     %eip

     we reconstruct the register state as it would look when we just
     returned from cpu_switch().  */

  /* The stack pointer shouldn't be zero.  */
  if (pcb->pcb_esp == 0)
    return 0;

  /* Read the stack frame, and check its validity.  We do this by
     checking if the saved interrupt priority level in the stack frame
     looks reasonable..  */
  read_memory (pcb->pcb_esp, (char *) &sf, sizeof sf);
  if ((unsigned int) sf.sf_ppl < 0x100 && (sf.sf_ppl & 0xf) == 0)
    {
      /* Yes, we have a frame that matches cpu_switch().  */
      pcb->pcb_esp += sizeof (struct switchframe);
      regcache_raw_supply (regcache, I386_EDI_REGNUM, &sf.sf_edi);
      regcache_raw_supply (regcache, I386_ESI_REGNUM, &sf.sf_esi);
      regcache_raw_supply (regcache, I386_EBX_REGNUM, &sf.sf_ebx);
      regcache_raw_supply (regcache, I386_EIP_REGNUM, &sf.sf_eip);
    }
  else
    {
      /* No, the pcb must have been last updated by savectx().  */
      pcb->pcb_esp += 4;
      regcache_raw_supply (regcache, I386_EIP_REGNUM, &sf);
    }

  regcache_raw_supply (regcache, I386_EBP_REGNUM, &pcb->pcb_ebp);
  regcache_raw_supply (regcache, I386_ESP_REGNUM, &pcb->pcb_esp);

  return 1;
}


/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_i386nbsd_nat (void);

void
_initialize_i386nbsd_nat (void)
{
  /* We've got nothing to add to the common *BSD/i386 target.  */
  add_target (i386bsd_target ());

  /* Support debugging kernel virtual memory images.  */
  bsd_kvm_add_target (i386nbsd_supply_pcb);
}
@


1.5
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@d63 3
d67 16
a82 3
  pcb->pcb_esp += sizeof (struct switchframe);
  regcache_raw_supply (regcache, I386_EDI_REGNUM, &sf.sf_edi);
  regcache_raw_supply (regcache, I386_ESI_REGNUM, &sf.sf_esi);
a84 2
  regcache_raw_supply (regcache, I386_EBX_REGNUM, &sf.sf_ebx);
  regcache_raw_supply (regcache, I386_EIP_REGNUM, &sf.sf_eip);
@


1.4
log
@Sync libkvm interface with FSF repository.  This adds new "kvm proc" and
"kvm pcb" commands.
ok deraadt@@
@
text
@d25 1
d28 1
d82 3
@


1.3
log
@Add missing file.
@
text
@d36 2
a37 2
int
bsd_kvm_supply_pcb (struct regcache *regcache, struct pcb *pcb)
d71 11
@


1.2
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@d1 1
a1 2
/* Functions specific to running gdb native on an i386 running NetBSD
   Copyright 1989, 1992, 1993, 1994, 1996 Free Software Foundation, Inc.
d3 1
a3 1
This file is part of GDB.
d5 1
a5 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d7 14
a20 5
#include <sys/types.h>
#include <sys/ptrace.h>
#include <machine/reg.h>
#include <machine/frame.h>
#include <machine/pcb.h>
a22 2
#include "inferior.h"
#include "target.h"
d24 1
d26 1
a26 5
void
fetch_inferior_registers (regno)
     int regno;
{
  struct reg inferior_registers;
d28 1
a28 4
  ptrace (PT_GETREGS, inferior_pid,
	  (PTRACE_ARG3_TYPE) &inferior_registers, 0);
  memcpy (&registers[REGISTER_BYTE (0)], &inferior_registers,
	  sizeof(inferior_registers));
d30 3
a32 14
  /* FIXME: FP regs? */
  registers_fetched ();
}

void
store_inferior_registers (regno)
     int regno;
{
  struct reg inferior_registers;

  memcpy (&inferior_registers, &registers[REGISTER_BYTE (0)],
	  sizeof(inferior_registers));
  ptrace (PT_SETREGS, inferior_pid,
	  (PTRACE_ARG3_TYPE) &inferior_registers, 0);
d34 1
a34 3
  /* FIXME: FP regs? */
}

d36 2
a37 15
/* XXX - Add this to machine/regs.h instead? */
struct md_core {
  struct reg intreg;
  struct fpreg freg;
};

static struct fpreg i386_fp_registers;
static int i386_fp_read = 0;

static void
fetch_core_registers (core_reg_sect, core_reg_size, which, reg_addr)
     char *core_reg_sect;
     unsigned core_reg_size;
     int which;
     unsigned int reg_addr;	/* Unused in this version */
d39 1
a39 7
  struct md_core *core_reg;

  core_reg = (struct md_core *)core_reg_sect;

  /* We get everything from the .reg section. */
  if (which != 0)
    return;
d41 1
a41 15
  if (core_reg_size < sizeof(struct reg)) {
    fprintf_unfiltered (gdb_stderr, "Couldn't read regs from core file\n");
    return;
  }

  /* Integer registers */
  memcpy(&registers[REGISTER_BYTE (0)],
	 &core_reg->intreg, sizeof(struct reg));

  /* Floating point registers */
  i386_fp_registers = core_reg->freg;
  i386_fp_read = 1;

  registers_fetched ();
}
d43 26
a68 2
/* Register that we are able to handle i386nbsd core file formats.
   FIXME: is this really bfd_target_unknown_flavour? */
d70 1
a70 174
static struct core_fns nat_core_fns =
{
  bfd_target_unknown_flavour,
  fetch_core_registers,
  NULL
};

void
_initialize_i386nbsd_nat ()
{
  add_core_fns (&nat_core_fns);
}


/*
 * kernel_u_size() is not helpful on NetBSD because
 * the "u" struct is NOT in the core dump file.
 */

#ifdef	FETCH_KCORE_REGISTERS
/*
 * Get registers from a kernel crash dump or live kernel.
 * Called by kcore-nbsd.c:get_kcore_registers().
 */
void
fetch_kcore_registers (pcb)
     struct pcb *pcb;
{
  int i, regno, regs[4];

  /*
   * get the register values out of the sys pcb and
   * store them where `read_register' will find them.
   */
  if (target_read_memory(pcb->pcb_tss.tss_esp+4,
			 (char *)regs, sizeof(regs)))
    error("Cannot read ebx, esi, and edi.");
  for (i = 0, regno = 0; regno < 3; regno++)
    supply_register(regno, (char *)&i);
  supply_register(3, (char *)&regs[2]);
  supply_register(4, (char *)&pcb->pcb_tss.tss_esp);
  supply_register(5, (char *)&pcb->pcb_tss.tss_ebp);
  supply_register(6, (char *)&regs[1]);
  supply_register(7, (char *)&regs[0]);
  supply_register(8, (char *)&regs[3]);
  for (i = 0, regno = 9; regno < 10; regno++)
    supply_register(regno, (char *)&i);
#if 0
  i = 0x08;
  supply_register(10, (char *)&i);
  i = 0x10;
  supply_register(11, (char *)&i);
#endif

  /* The kernel does not use the FPU, so ignore it. */
  registers_fetched ();
}
#endif	/* FETCH_KCORE_REGISTERS */

#ifdef FLOAT_INFO
#include "language.h"			/* for local_hex_string */
#include "floatformat.h"

#include <sys/param.h>
#include <sys/dir.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <fcntl.h>

#include <a.out.h>

#include <sys/time.h>
#include <sys/resource.h>
#include <sys/uio.h>
#define curpcb Xcurpcb	/* XXX avoid leaking declaration from pcb.h */
#include <sys/user.h>
#undef curpcb
#include <sys/file.h>
#include "gdb_stat.h"
#include <sys/ptrace.h>

extern void print_387_control_word ();		/* i387-tdep.h */
extern void print_387_status_word ();

struct env387 
{
  unsigned short control;
  unsigned short r0;
  unsigned short status;
  unsigned short r1;
  unsigned short tag;
  unsigned short r2;
  unsigned long eip;
  unsigned short code_seg;
  unsigned short opcode;
  unsigned long operand;
  unsigned short operand_seg;
  unsigned short r3;
  unsigned char regs[8][10];
};

static void
print_387_status (status, ep)
     unsigned short status;
     struct env387 *ep;
{
  int i;
  int bothstatus;
  int top;
  int fpreg;
  
  bothstatus = ((status != 0) && (ep->status != 0));
  if (status != 0) 
    {
      if (bothstatus)
	printf_unfiltered ("u: ");
      print_387_status_word ((unsigned int)status);
    }
  
  if (ep->status != 0) 
    {
      if (bothstatus)
	printf_unfiltered ("e: ");
      print_387_status_word ((unsigned int)ep->status);
    }
  
  print_387_control_word ((unsigned int)ep->control);
  printf_unfiltered ("last exception: ");
  printf_unfiltered ("opcode %s; ", local_hex_string(ep->opcode));
  printf_unfiltered ("pc %s:", local_hex_string(ep->code_seg));
  printf_unfiltered ("%s; ", local_hex_string(ep->eip));
  printf_unfiltered ("operand %s", local_hex_string(ep->operand_seg));
  printf_unfiltered (":%s\n", local_hex_string(ep->operand));

  top = (ep->status >> 11) & 7;
  
  printf_unfiltered ("regno     tag  msb              lsb  value\n");
  for (fpreg = 7; fpreg >= 0; fpreg--) 
    {
      double val;
      
      printf_unfiltered ("%s %d: ", fpreg == top ? "=>" : "  ", fpreg); 

      switch ((ep->tag >> (fpreg * 2)) & 3) 
	{
	case 0: printf_unfiltered ("valid "); break;
	case 1: printf_unfiltered ("zero  "); break;
	case 2: printf_unfiltered ("trap  "); break;
	case 3: printf_unfiltered ("empty "); break;
	}
      for (i = 9; i >= 0; i--)
	printf_unfiltered ("%02x", ep->regs[fpreg][i]);
      
      floatformat_to_double(&floatformat_i387_ext, (char *) ep->regs[fpreg], 
			      &val);
      printf_unfiltered ("  %g\n", val);
    }
}

i386_float_info ()
{
  extern int inferior_pid;
  
  if (inferior_pid) 
    {
      ptrace (PT_GETFPREGS, inferior_pid, (PTRACE_ARG3_TYPE) &i386_fp_registers,
	      0);
    } 
  else if (!i386_fp_read)
    {
      error ("The program has no floating point registers now.");
    }
  
  print_387_status (0, (struct env387 *) &i386_fp_registers);
a71 1
#endif
@


1.1
log
@Adapt the newer of our GDB versions to a.out ports.  The main part of this
commit comes from NetBSD.  Also, the kernel debugging mode is a bit different
but you will notice when you type gdb -k because it documents the difference
@
text
@@


1.1.1.1
log
@GDB 6.3 (excluding .info files)
@
text
@d1 2
a2 1
/* Native-dependent code for NetBSD/i386.
d4 1
a4 1
   Copyright 2004 Free Software Foundation, Inc.
d6 13
a18 1
   This file is part of GDB.
d20 5
a24 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d27 2
a29 2
#include "regcache.h"
#include "target.h"
d31 10
a40 2
#include "i386-tdep.h"
#include "i386bsd-nat.h"
d42 3
a44 1
/* Support for debugging kernel virtual memory images.  */
d46 5
a50 3
#include <sys/types.h>
#include <machine/frame.h>
#include <machine/pcb.h>
d52 4
a55 1
#include "bsd-kvm.h"
d57 19
a75 2
static int
i386nbsd_supply_pcb (struct regcache *regcache, struct pcb *pcb)
d77 7
a83 1
  struct switchframe sf;
d85 4
a88 1
  /* The following is true for NetBSD 1.6.2:
d90 3
a92 26
     The pcb contains %esp and %ebp at the point of the context switch
     in cpu_switch().  At that point we have a stack frame as
     described by `struct switchframe', which for NetBSD 1.6.2 has the
     following layout:

     interrupt level
     %edi
     %esi
     %ebx
     %eip

     we reconstruct the register state as it would look when we just
     returned from cpu_switch().  */

  /* The stack pointer shouldn't be zero.  */
  if (pcb->pcb_esp == 0)
    return 0;

  read_memory (pcb->pcb_esp, (char *) &sf, sizeof sf);
  pcb->pcb_esp += sizeof (struct switchframe);
  regcache_raw_supply (regcache, I386_EDI_REGNUM, &sf.sf_edi);
  regcache_raw_supply (regcache, I386_ESI_REGNUM, &sf.sf_esi);
  regcache_raw_supply (regcache, I386_EBP_REGNUM, &pcb->pcb_ebp);
  regcache_raw_supply (regcache, I386_ESP_REGNUM, &pcb->pcb_esp);
  regcache_raw_supply (regcache, I386_EBX_REGNUM, &sf.sf_ebx);
  regcache_raw_supply (regcache, I386_EIP_REGNUM, &sf.sf_eip);
d94 21
a114 1
  return 1;
d118 15
a132 2
/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_i386nbsd_nat (void);
d134 75
a208 2
void
_initialize_i386nbsd_nat (void)
d210 52
a261 2
  /* We've got nothing to add to the common *BSD/i386 target.  */
  add_target (i386bsd_target ());
d263 15
a277 2
  /* Support debugging kernel virtual memory images.  */
  bsd_kvm_add_target (i386nbsd_supply_pcb);
d279 1
@


