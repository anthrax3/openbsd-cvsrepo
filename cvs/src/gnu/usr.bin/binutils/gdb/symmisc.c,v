head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.48
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.44
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.46
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.38
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.42
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.40
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.36
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.34
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.32
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.30
	OPENBSD_5_0:1.4.0.28
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.26
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.24
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2004.12.27.14.00.43;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.21.20.23.15;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.40.05;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.20.59;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.13.27;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.10.59;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.21.00;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@/* Do various things to symbol tables (other than lookup), for GDB.

   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004 Free Software
   Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "bfd.h"
#include "symfile.h"
#include "objfiles.h"
#include "breakpoint.h"
#include "command.h"
#include "gdb_obstack.h"
#include "language.h"
#include "bcache.h"
#include "block.h"
#include "gdb_regex.h"
#include "dictionary.h"

#include "gdb_string.h"
#include "readline/readline.h"

#ifndef DEV_TTY
#define DEV_TTY "/dev/tty"
#endif

/* Unfortunately for debugging, stderr is usually a macro.  This is painful
   when calling functions that take FILE *'s from the debugger.
   So we make a variable which has the same value and which is accessible when
   debugging GDB with itself.  Because stdin et al need not be constants,
   we initialize them in the _initialize_symmisc function at the bottom
   of the file.  */
FILE *std_in;
FILE *std_out;
FILE *std_err;

/* Prototypes for local functions */

static void dump_symtab (struct objfile *, struct symtab *,
			 struct ui_file *);

static void dump_psymtab (struct objfile *, struct partial_symtab *,
			  struct ui_file *);

static void dump_msymbols (struct objfile *, struct ui_file *);

static void dump_objfile (struct objfile *);

static int block_depth (struct block *);

static void print_partial_symbols (struct partial_symbol **, int,
				   char *, struct ui_file *);

static void free_symtab_block (struct objfile *, struct block *);

void _initialize_symmisc (void);

struct print_symbol_args
  {
    struct symbol *symbol;
    int depth;
    struct ui_file *outfile;
  };

static int print_symbol (void *);

static void free_symtab_block (struct objfile *, struct block *);


/* Free a struct block <- B and all the symbols defined in that block.  */

/* FIXME: carlton/2003-04-28: I don't believe this is currently ever
   used.  */

static void
free_symtab_block (struct objfile *objfile, struct block *b)
{
  struct dict_iterator iter;
  struct symbol *sym;

  ALL_BLOCK_SYMBOLS (b, iter, sym)
    {
      xfree (DEPRECATED_SYMBOL_NAME (sym));
      xfree (sym);
    }

  dict_free (BLOCK_DICT (b));
  xfree (b);
}

/* Free all the storage associated with the struct symtab <- S.
   Note that some symtabs have contents malloc'ed structure by structure,
   while some have contents that all live inside one big block of memory,
   and some share the contents of another symbol table and so you should
   not free the contents on their behalf (except sometimes the linetable,
   which maybe per symtab even when the rest is not).
   It is s->free_code that says which alternative to use.  */

void
free_symtab (struct symtab *s)
{
  int i, n;
  struct blockvector *bv;

  switch (s->free_code)
    {
    case free_nothing:
      /* All the contents are part of a big block of memory (an obstack),
         and some other symtab is in charge of freeing that block.
         Therefore, do nothing.  */
      break;

    case free_contents:
      /* Here all the contents were malloc'ed structure by structure
         and must be freed that way.  */
      /* First free the blocks (and their symbols.  */
      bv = BLOCKVECTOR (s);
      n = BLOCKVECTOR_NBLOCKS (bv);
      for (i = 0; i < n; i++)
	free_symtab_block (s->objfile, BLOCKVECTOR_BLOCK (bv, i));
      /* Free the blockvector itself.  */
      xfree (bv);
      /* Also free the linetable.  */

    case free_linetable:
      /* Everything will be freed either by our `free_func'
         or by some other symtab, except for our linetable.
         Free that now.  */
      if (LINETABLE (s))
	xfree (LINETABLE (s));
      break;
    }

  /* If there is a single block of memory to free, free it.  */
  if (s->free_func != NULL)
    s->free_func (s);

  /* Free source-related stuff */
  if (s->line_charpos != NULL)
    xfree (s->line_charpos);
  if (s->fullname != NULL)
    xfree (s->fullname);
  if (s->debugformat != NULL)
    xfree (s->debugformat);
  xfree (s);
}

void
print_symbol_bcache_statistics (void)
{
  struct objfile *objfile;

  immediate_quit++;
  ALL_OBJFILES (objfile)
  {
    printf_filtered ("Byte cache statistics for '%s':\n", objfile->name);
    print_bcache_statistics (objfile->psymbol_cache, "partial symbol cache");
  }
  immediate_quit--;
}

void
print_objfile_statistics (void)
{
  struct objfile *objfile;
  struct symtab *s;
  struct partial_symtab *ps;
  int i, linetables, blockvectors;

  immediate_quit++;
  ALL_OBJFILES (objfile)
  {
    printf_filtered ("Statistics for '%s':\n", objfile->name);
    if (OBJSTAT (objfile, n_stabs) > 0)
      printf_filtered ("  Number of \"stab\" symbols read: %d\n",
		       OBJSTAT (objfile, n_stabs));
    if (OBJSTAT (objfile, n_minsyms) > 0)
      printf_filtered ("  Number of \"minimal\" symbols read: %d\n",
		       OBJSTAT (objfile, n_minsyms));
    if (OBJSTAT (objfile, n_psyms) > 0)
      printf_filtered ("  Number of \"partial\" symbols read: %d\n",
		       OBJSTAT (objfile, n_psyms));
    if (OBJSTAT (objfile, n_syms) > 0)
      printf_filtered ("  Number of \"full\" symbols read: %d\n",
		       OBJSTAT (objfile, n_syms));
    if (OBJSTAT (objfile, n_types) > 0)
      printf_filtered ("  Number of \"types\" defined: %d\n",
		       OBJSTAT (objfile, n_types));
    i = 0;
    ALL_OBJFILE_PSYMTABS (objfile, ps)
      {
        if (ps->readin == 0)
          i++;
      }
    printf_filtered ("  Number of psym tables (not yet expanded): %d\n", i);
    i = linetables = blockvectors = 0;
    ALL_OBJFILE_SYMTABS (objfile, s)
      {
        i++;
        if (s->linetable != NULL)
          linetables++;
        if (s->primary == 1)
          blockvectors++;
      }
    printf_filtered ("  Number of symbol tables: %d\n", i);
    printf_filtered ("  Number of symbol tables with line tables: %d\n", 
                     linetables);
    printf_filtered ("  Number of symbol tables with blockvectors: %d\n", 
                     blockvectors);
    
    if (OBJSTAT (objfile, sz_strtab) > 0)
      printf_filtered ("  Space used by a.out string tables: %d\n",
		       OBJSTAT (objfile, sz_strtab));
    printf_filtered ("  Total memory used for objfile obstack: %d\n",
		     obstack_memory_used (&objfile->objfile_obstack));
    printf_filtered ("  Total memory used for psymbol cache: %d\n",
		     bcache_memory_used (objfile->psymbol_cache));
    printf_filtered ("  Total memory used for macro cache: %d\n",
		     bcache_memory_used (objfile->macro_cache));
  }
  immediate_quit--;
}

static void
dump_objfile (struct objfile *objfile)
{
  struct symtab *symtab;
  struct partial_symtab *psymtab;

  printf_filtered ("\nObject file %s:  ", objfile->name);
  printf_filtered ("Objfile at ");
  gdb_print_host_address (objfile, gdb_stdout);
  printf_filtered (", bfd at ");
  gdb_print_host_address (objfile->obfd, gdb_stdout);
  printf_filtered (", %d minsyms\n\n",
		   objfile->minimal_symbol_count);

  if (objfile->psymtabs)
    {
      printf_filtered ("Psymtabs:\n");
      for (psymtab = objfile->psymtabs;
	   psymtab != NULL;
	   psymtab = psymtab->next)
	{
	  printf_filtered ("%s at ",
			   psymtab->filename);
	  gdb_print_host_address (psymtab, gdb_stdout);
	  printf_filtered (", ");
	  if (psymtab->objfile != objfile)
	    {
	      printf_filtered ("NOT ON CHAIN!  ");
	    }
	  wrap_here ("  ");
	}
      printf_filtered ("\n\n");
    }

  if (objfile->symtabs)
    {
      printf_filtered ("Symtabs:\n");
      for (symtab = objfile->symtabs;
	   symtab != NULL;
	   symtab = symtab->next)
	{
	  printf_filtered ("%s at ", symtab->filename);
	  gdb_print_host_address (symtab, gdb_stdout);
	  printf_filtered (", ");
	  if (symtab->objfile != objfile)
	    {
	      printf_filtered ("NOT ON CHAIN!  ");
	    }
	  wrap_here ("  ");
	}
      printf_filtered ("\n\n");
    }
}

/* Print minimal symbols from this objfile.  */

static void
dump_msymbols (struct objfile *objfile, struct ui_file *outfile)
{
  struct minimal_symbol *msymbol;
  int index;
  char ms_type;

  fprintf_filtered (outfile, "\nObject file %s:\n\n", objfile->name);
  if (objfile->minimal_symbol_count == 0)
    {
      fprintf_filtered (outfile, "No minimal symbols found.\n");
      return;
    }
  for (index = 0, msymbol = objfile->msymbols;
       DEPRECATED_SYMBOL_NAME (msymbol) != NULL; msymbol++, index++)
    {
      switch (msymbol->type)
	{
	case mst_unknown:
	  ms_type = 'u';
	  break;
	case mst_text:
	  ms_type = 'T';
	  break;
	case mst_solib_trampoline:
	  ms_type = 'S';
	  break;
	case mst_data:
	  ms_type = 'D';
	  break;
	case mst_bss:
	  ms_type = 'B';
	  break;
	case mst_abs:
	  ms_type = 'A';
	  break;
	case mst_file_text:
	  ms_type = 't';
	  break;
	case mst_file_data:
	  ms_type = 'd';
	  break;
	case mst_file_bss:
	  ms_type = 'b';
	  break;
	default:
	  ms_type = '?';
	  break;
	}
      fprintf_filtered (outfile, "[%2d] %c ", index, ms_type);
      print_address_numeric (SYMBOL_VALUE_ADDRESS (msymbol), 1, outfile);
      fprintf_filtered (outfile, " %s", DEPRECATED_SYMBOL_NAME (msymbol));
      if (SYMBOL_BFD_SECTION (msymbol))
	fprintf_filtered (outfile, " section %s",
			  bfd_section_name (objfile->obfd,
					    SYMBOL_BFD_SECTION (msymbol)));
      if (SYMBOL_DEMANGLED_NAME (msymbol) != NULL)
	{
	  fprintf_filtered (outfile, "  %s", SYMBOL_DEMANGLED_NAME (msymbol));
	}
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
      if (msymbol->filename)
	fprintf_filtered (outfile, "  %s", msymbol->filename);
#endif
      fputs_filtered ("\n", outfile);
    }
  if (objfile->minimal_symbol_count != index)
    {
      warning ("internal error:  minimal symbol count %d != %d",
	       objfile->minimal_symbol_count, index);
    }
  fprintf_filtered (outfile, "\n");
}

static void
dump_psymtab (struct objfile *objfile, struct partial_symtab *psymtab,
	      struct ui_file *outfile)
{
  int i;

  fprintf_filtered (outfile, "\nPartial symtab for source file %s ",
		    psymtab->filename);
  fprintf_filtered (outfile, "(object ");
  gdb_print_host_address (psymtab, outfile);
  fprintf_filtered (outfile, ")\n\n");
  fprintf_unfiltered (outfile, "  Read from object file %s (",
		      objfile->name);
  gdb_print_host_address (objfile, outfile);
  fprintf_unfiltered (outfile, ")\n");

  if (psymtab->readin)
    {
      fprintf_filtered (outfile,
			"  Full symtab was read (at ");
      gdb_print_host_address (psymtab->symtab, outfile);
      fprintf_filtered (outfile, " by function at ");
      gdb_print_host_address (psymtab->read_symtab, outfile);
      fprintf_filtered (outfile, ")\n");
    }

  fprintf_filtered (outfile, "  Relocate symbols by ");
  for (i = 0; i < psymtab->objfile->num_sections; ++i)
    {
      if (i != 0)
	fprintf_filtered (outfile, ", ");
      wrap_here ("    ");
      print_address_numeric (ANOFFSET (psymtab->section_offsets, i),
			     1,
			     outfile);
    }
  fprintf_filtered (outfile, "\n");

  fprintf_filtered (outfile, "  Symbols cover text addresses ");
  print_address_numeric (psymtab->textlow, 1, outfile);
  fprintf_filtered (outfile, "-");
  print_address_numeric (psymtab->texthigh, 1, outfile);
  fprintf_filtered (outfile, "\n");
  fprintf_filtered (outfile, "  Depends on %d other partial symtabs.\n",
		    psymtab->number_of_dependencies);
  for (i = 0; i < psymtab->number_of_dependencies; i++)
    {
      fprintf_filtered (outfile, "    %d ", i);
      gdb_print_host_address (psymtab->dependencies[i], outfile);
      fprintf_filtered (outfile, " %s\n",
			psymtab->dependencies[i]->filename);
    }
  if (psymtab->n_global_syms > 0)
    {
      print_partial_symbols (objfile->global_psymbols.list
			     + psymtab->globals_offset,
			     psymtab->n_global_syms, "Global", outfile);
    }
  if (psymtab->n_static_syms > 0)
    {
      print_partial_symbols (objfile->static_psymbols.list
			     + psymtab->statics_offset,
			     psymtab->n_static_syms, "Static", outfile);
    }
  fprintf_filtered (outfile, "\n");
}

static void
dump_symtab (struct objfile *objfile, struct symtab *symtab,
	     struct ui_file *outfile)
{
  int i;
  struct dict_iterator iter;
  int len, blen;
  struct linetable *l;
  struct blockvector *bv;
  struct symbol *sym;
  struct block *b;
  int depth;

  fprintf_filtered (outfile, "\nSymtab for file %s\n", symtab->filename);
  if (symtab->dirname)
    fprintf_filtered (outfile, "Compilation directory is %s\n",
		      symtab->dirname);
  fprintf_filtered (outfile, "Read from object file %s (", objfile->name);
  gdb_print_host_address (objfile, outfile);
  fprintf_filtered (outfile, ")\n");
  fprintf_filtered (outfile, "Language: %s\n", language_str (symtab->language));

  /* First print the line table.  */
  l = LINETABLE (symtab);
  if (l)
    {
      fprintf_filtered (outfile, "\nLine table:\n\n");
      len = l->nitems;
      for (i = 0; i < len; i++)
	{
	  fprintf_filtered (outfile, " line %d at ", l->item[i].line);
	  print_address_numeric (l->item[i].pc, 1, outfile);
	  fprintf_filtered (outfile, "\n");
	}
    }
  /* Now print the block info, but only for primary symtabs since we will
     print lots of duplicate info otherwise. */
  if (symtab->primary)
    {
      fprintf_filtered (outfile, "\nBlockvector:\n\n");
      bv = BLOCKVECTOR (symtab);
      len = BLOCKVECTOR_NBLOCKS (bv);
      for (i = 0; i < len; i++)
	{
	  b = BLOCKVECTOR_BLOCK (bv, i);
	  depth = block_depth (b) * 2;
	  print_spaces (depth, outfile);
	  fprintf_filtered (outfile, "block #%03d, object at ", i);
	  gdb_print_host_address (b, outfile);
	  if (BLOCK_SUPERBLOCK (b))
	    {
	      fprintf_filtered (outfile, " under ");
	      gdb_print_host_address (BLOCK_SUPERBLOCK (b), outfile);
	    }
	  /* drow/2002-07-10: We could save the total symbols count
	     even if we're using a hashtable, but nothing else but this message
	     wants it.  */
	  fprintf_filtered (outfile, ", %d syms/buckets in ",
			    dict_size (BLOCK_DICT (b)));
	  print_address_numeric (BLOCK_START (b), 1, outfile);
	  fprintf_filtered (outfile, "..");
	  print_address_numeric (BLOCK_END (b), 1, outfile);
	  if (BLOCK_FUNCTION (b))
	    {
	      fprintf_filtered (outfile, ", function %s", DEPRECATED_SYMBOL_NAME (BLOCK_FUNCTION (b)));
	      if (SYMBOL_DEMANGLED_NAME (BLOCK_FUNCTION (b)) != NULL)
		{
		  fprintf_filtered (outfile, ", %s",
				SYMBOL_DEMANGLED_NAME (BLOCK_FUNCTION (b)));
		}
	    }
	  if (BLOCK_GCC_COMPILED (b))
	    fprintf_filtered (outfile, ", compiled with gcc%d", BLOCK_GCC_COMPILED (b));
	  fprintf_filtered (outfile, "\n");
	  /* Now print each symbol in this block (in no particular order, if
	     we're using a hashtable).  */
	  ALL_BLOCK_SYMBOLS (b, iter, sym)
	    {
	      struct print_symbol_args s;
	      s.symbol = sym;
	      s.depth = depth + 1;
	      s.outfile = outfile;
	      catch_errors (print_symbol, &s, "Error printing symbol:\n",
			    RETURN_MASK_ALL);
	    }
	}
      fprintf_filtered (outfile, "\n");
    }
  else
    {
      fprintf_filtered (outfile, "\nBlockvector same as previous symtab\n\n");
    }
}

void
maintenance_print_symbols (char *args, int from_tty)
{
  char **argv;
  struct ui_file *outfile;
  struct cleanup *cleanups;
  char *symname = NULL;
  char *filename = DEV_TTY;
  struct objfile *objfile;
  struct symtab *s;

  dont_repeat ();

  if (args == NULL)
    {
      error ("\
Arguments missing: an output file name and an optional symbol file name");
    }
  else if ((argv = buildargv (args)) == NULL)
    {
      nomem (0);
    }
  cleanups = make_cleanup_freeargv (argv);

  if (argv[0] != NULL)
    {
      filename = argv[0];
      /* If a second arg is supplied, it is a source file name to match on */
      if (argv[1] != NULL)
	{
	  symname = argv[1];
	}
    }

  filename = tilde_expand (filename);
  make_cleanup (xfree, filename);

  outfile = gdb_fopen (filename, FOPEN_WT);
  if (outfile == 0)
    perror_with_name (filename);
  make_cleanup_ui_file_delete (outfile);

  immediate_quit++;
  ALL_SYMTABS (objfile, s)
    if (symname == NULL || strcmp (symname, s->filename) == 0)
    dump_symtab (objfile, s, outfile);
  immediate_quit--;
  do_cleanups (cleanups);
}

/* Print symbol ARGS->SYMBOL on ARGS->OUTFILE.  ARGS->DEPTH says how
   far to indent.  ARGS is really a struct print_symbol_args *, but is
   declared as char * to get it past catch_errors.  Returns 0 for error,
   1 for success.  */

static int
print_symbol (void *args)
{
  struct symbol *symbol = ((struct print_symbol_args *) args)->symbol;
  int depth = ((struct print_symbol_args *) args)->depth;
  struct ui_file *outfile = ((struct print_symbol_args *) args)->outfile;

  print_spaces (depth, outfile);
  if (SYMBOL_DOMAIN (symbol) == LABEL_DOMAIN)
    {
      fprintf_filtered (outfile, "label %s at ", SYMBOL_PRINT_NAME (symbol));
      print_address_numeric (SYMBOL_VALUE_ADDRESS (symbol), 1, outfile);
      if (SYMBOL_BFD_SECTION (symbol))
	fprintf_filtered (outfile, " section %s\n",
		       bfd_section_name (SYMBOL_BFD_SECTION (symbol)->owner,
					 SYMBOL_BFD_SECTION (symbol)));
      else
	fprintf_filtered (outfile, "\n");
      return 1;
    }
  if (SYMBOL_DOMAIN (symbol) == STRUCT_DOMAIN)
    {
      if (TYPE_TAG_NAME (SYMBOL_TYPE (symbol)))
	{
	  LA_PRINT_TYPE (SYMBOL_TYPE (symbol), "", outfile, 1, depth);
	}
      else
	{
	  fprintf_filtered (outfile, "%s %s = ",
			 (TYPE_CODE (SYMBOL_TYPE (symbol)) == TYPE_CODE_ENUM
			  ? "enum"
		     : (TYPE_CODE (SYMBOL_TYPE (symbol)) == TYPE_CODE_STRUCT
			? "struct" : "union")),
			    DEPRECATED_SYMBOL_NAME (symbol));
	  LA_PRINT_TYPE (SYMBOL_TYPE (symbol), "", outfile, 1, depth);
	}
      fprintf_filtered (outfile, ";\n");
    }
  else
    {
      if (SYMBOL_CLASS (symbol) == LOC_TYPEDEF)
	fprintf_filtered (outfile, "typedef ");
      if (SYMBOL_TYPE (symbol))
	{
	  /* Print details of types, except for enums where it's clutter.  */
	  LA_PRINT_TYPE (SYMBOL_TYPE (symbol), SYMBOL_PRINT_NAME (symbol),
			 outfile,
			 TYPE_CODE (SYMBOL_TYPE (symbol)) != TYPE_CODE_ENUM,
			 depth);
	  fprintf_filtered (outfile, "; ");
	}
      else
	fprintf_filtered (outfile, "%s ", SYMBOL_PRINT_NAME (symbol));

      switch (SYMBOL_CLASS (symbol))
	{
	case LOC_CONST:
	  fprintf_filtered (outfile, "const %ld (0x%lx)",
			    SYMBOL_VALUE (symbol),
			    SYMBOL_VALUE (symbol));
	  break;

	case LOC_CONST_BYTES:
	  {
	    unsigned i;
	    struct type *type = check_typedef (SYMBOL_TYPE (symbol));
	    fprintf_filtered (outfile, "const %u hex bytes:",
			      TYPE_LENGTH (type));
	    for (i = 0; i < TYPE_LENGTH (type); i++)
	      fprintf_filtered (outfile, " %02x",
				(unsigned) SYMBOL_VALUE_BYTES (symbol)[i]);
	  }
	  break;

	case LOC_STATIC:
	  fprintf_filtered (outfile, "static at ");
	  print_address_numeric (SYMBOL_VALUE_ADDRESS (symbol), 1, outfile);
	  if (SYMBOL_BFD_SECTION (symbol))
	    fprintf_filtered (outfile, " section %s",
			      bfd_section_name
			      (SYMBOL_BFD_SECTION (symbol)->owner,
			       SYMBOL_BFD_SECTION (symbol)));
	  break;

	case LOC_INDIRECT:
	  fprintf_filtered (outfile, "extern global at *(");
	  print_address_numeric (SYMBOL_VALUE_ADDRESS (symbol), 1, outfile);
	  fprintf_filtered (outfile, "),");
	  break;

	case LOC_REGISTER:
	  fprintf_filtered (outfile, "register %ld", SYMBOL_VALUE (symbol));
	  break;

	case LOC_ARG:
	  fprintf_filtered (outfile, "arg at offset 0x%lx",
			    SYMBOL_VALUE (symbol));
	  break;

	case LOC_LOCAL_ARG:
	  fprintf_filtered (outfile, "arg at offset 0x%lx from fp",
			    SYMBOL_VALUE (symbol));
	  break;

	case LOC_REF_ARG:
	  fprintf_filtered (outfile, "reference arg at 0x%lx", SYMBOL_VALUE (symbol));
	  break;

	case LOC_REGPARM:
	  fprintf_filtered (outfile, "parameter register %ld", SYMBOL_VALUE (symbol));
	  break;

	case LOC_REGPARM_ADDR:
	  fprintf_filtered (outfile, "address parameter register %ld", SYMBOL_VALUE (symbol));
	  break;

	case LOC_LOCAL:
	  fprintf_filtered (outfile, "local at offset 0x%lx",
			    SYMBOL_VALUE (symbol));
	  break;

	case LOC_BASEREG:
	  fprintf_filtered (outfile, "local at 0x%lx from register %d",
			    SYMBOL_VALUE (symbol), SYMBOL_BASEREG (symbol));
	  break;

	case LOC_BASEREG_ARG:
	  fprintf_filtered (outfile, "arg at 0x%lx from register %d",
			    SYMBOL_VALUE (symbol), SYMBOL_BASEREG (symbol));
	  break;

	case LOC_TYPEDEF:
	  break;

	case LOC_LABEL:
	  fprintf_filtered (outfile, "label at ");
	  print_address_numeric (SYMBOL_VALUE_ADDRESS (symbol), 1, outfile);
	  if (SYMBOL_BFD_SECTION (symbol))
	    fprintf_filtered (outfile, " section %s",
			      bfd_section_name
			      (SYMBOL_BFD_SECTION (symbol)->owner,
			       SYMBOL_BFD_SECTION (symbol)));
	  break;

	case LOC_BLOCK:
	  fprintf_filtered (outfile, "block object ");
	  gdb_print_host_address (SYMBOL_BLOCK_VALUE (symbol), outfile);
	  fprintf_filtered (outfile, ", ");
	  print_address_numeric (BLOCK_START (SYMBOL_BLOCK_VALUE (symbol)),
				 1,
				 outfile);
	  fprintf_filtered (outfile, "..");
	  print_address_numeric (BLOCK_END (SYMBOL_BLOCK_VALUE (symbol)),
				 1,
				 outfile);
	  if (SYMBOL_BFD_SECTION (symbol))
	    fprintf_filtered (outfile, " section %s",
			      bfd_section_name
			      (SYMBOL_BFD_SECTION (symbol)->owner,
			       SYMBOL_BFD_SECTION (symbol)));
	  break;

	case LOC_COMPUTED:
	case LOC_COMPUTED_ARG:
	  fprintf_filtered (outfile, "computed at runtime");
	  break;

	case LOC_UNRESOLVED:
	  fprintf_filtered (outfile, "unresolved");
	  break;

	case LOC_OPTIMIZED_OUT:
	  fprintf_filtered (outfile, "optimized out");
	  break;

	default:
	  fprintf_filtered (outfile, "botched symbol class %x",
			    SYMBOL_CLASS (symbol));
	  break;
	}
    }
  fprintf_filtered (outfile, "\n");
  return 1;
}

void
maintenance_print_psymbols (char *args, int from_tty)
{
  char **argv;
  struct ui_file *outfile;
  struct cleanup *cleanups;
  char *symname = NULL;
  char *filename = DEV_TTY;
  struct objfile *objfile;
  struct partial_symtab *ps;

  dont_repeat ();

  if (args == NULL)
    {
      error ("print-psymbols takes an output file name and optional symbol file name");
    }
  else if ((argv = buildargv (args)) == NULL)
    {
      nomem (0);
    }
  cleanups = make_cleanup_freeargv (argv);

  if (argv[0] != NULL)
    {
      filename = argv[0];
      /* If a second arg is supplied, it is a source file name to match on */
      if (argv[1] != NULL)
	{
	  symname = argv[1];
	}
    }

  filename = tilde_expand (filename);
  make_cleanup (xfree, filename);

  outfile = gdb_fopen (filename, FOPEN_WT);
  if (outfile == 0)
    perror_with_name (filename);
  make_cleanup_ui_file_delete (outfile);

  immediate_quit++;
  ALL_PSYMTABS (objfile, ps)
    if (symname == NULL || strcmp (symname, ps->filename) == 0)
    dump_psymtab (objfile, ps, outfile);
  immediate_quit--;
  do_cleanups (cleanups);
}

static void
print_partial_symbols (struct partial_symbol **p, int count, char *what,
		       struct ui_file *outfile)
{
  fprintf_filtered (outfile, "  %s partial symbols:\n", what);
  while (count-- > 0)
    {
      fprintf_filtered (outfile, "    `%s'", DEPRECATED_SYMBOL_NAME (*p));
      if (SYMBOL_DEMANGLED_NAME (*p) != NULL)
	{
	  fprintf_filtered (outfile, "  `%s'", SYMBOL_DEMANGLED_NAME (*p));
	}
      fputs_filtered (", ", outfile);
      switch (SYMBOL_DOMAIN (*p))
	{
	case UNDEF_DOMAIN:
	  fputs_filtered ("undefined domain, ", outfile);
	  break;
	case VAR_DOMAIN:
	  /* This is the usual thing -- don't print it */
	  break;
	case STRUCT_DOMAIN:
	  fputs_filtered ("struct domain, ", outfile);
	  break;
	case LABEL_DOMAIN:
	  fputs_filtered ("label domain, ", outfile);
	  break;
	default:
	  fputs_filtered ("<invalid domain>, ", outfile);
	  break;
	}
      switch (SYMBOL_CLASS (*p))
	{
	case LOC_UNDEF:
	  fputs_filtered ("undefined", outfile);
	  break;
	case LOC_CONST:
	  fputs_filtered ("constant int", outfile);
	  break;
	case LOC_STATIC:
	  fputs_filtered ("static", outfile);
	  break;
	case LOC_INDIRECT:
	  fputs_filtered ("extern global", outfile);
	  break;
	case LOC_REGISTER:
	  fputs_filtered ("register", outfile);
	  break;
	case LOC_ARG:
	  fputs_filtered ("pass by value", outfile);
	  break;
	case LOC_REF_ARG:
	  fputs_filtered ("pass by reference", outfile);
	  break;
	case LOC_REGPARM:
	  fputs_filtered ("register parameter", outfile);
	  break;
	case LOC_REGPARM_ADDR:
	  fputs_filtered ("register address parameter", outfile);
	  break;
	case LOC_LOCAL:
	  fputs_filtered ("stack parameter", outfile);
	  break;
	case LOC_TYPEDEF:
	  fputs_filtered ("type", outfile);
	  break;
	case LOC_LABEL:
	  fputs_filtered ("label", outfile);
	  break;
	case LOC_BLOCK:
	  fputs_filtered ("function", outfile);
	  break;
	case LOC_CONST_BYTES:
	  fputs_filtered ("constant bytes", outfile);
	  break;
	case LOC_LOCAL_ARG:
	  fputs_filtered ("shuffled arg", outfile);
	  break;
	case LOC_UNRESOLVED:
	  fputs_filtered ("unresolved", outfile);
	  break;
	case LOC_OPTIMIZED_OUT:
	  fputs_filtered ("optimized out", outfile);
	  break;
	case LOC_COMPUTED:
	case LOC_COMPUTED_ARG:
	  fputs_filtered ("computed at runtime", outfile);
	  break;
	default:
	  fputs_filtered ("<invalid location>", outfile);
	  break;
	}
      fputs_filtered (", ", outfile);
      print_address_numeric (SYMBOL_VALUE_ADDRESS (*p), 1, outfile);
      fprintf_filtered (outfile, "\n");
      p++;
    }
}

void
maintenance_print_msymbols (char *args, int from_tty)
{
  char **argv;
  struct ui_file *outfile;
  struct cleanup *cleanups;
  char *filename = DEV_TTY;
  char *symname = NULL;
  struct objfile *objfile;

  dont_repeat ();

  if (args == NULL)
    {
      error ("print-msymbols takes an output file name and optional symbol file name");
    }
  else if ((argv = buildargv (args)) == NULL)
    {
      nomem (0);
    }
  cleanups = make_cleanup_freeargv (argv);

  if (argv[0] != NULL)
    {
      filename = argv[0];
      /* If a second arg is supplied, it is a source file name to match on */
      if (argv[1] != NULL)
	{
	  symname = argv[1];
	}
    }

  filename = tilde_expand (filename);
  make_cleanup (xfree, filename);

  outfile = gdb_fopen (filename, FOPEN_WT);
  if (outfile == 0)
    perror_with_name (filename);
  make_cleanup_ui_file_delete (outfile);

  immediate_quit++;
  ALL_OBJFILES (objfile)
    if (symname == NULL || strcmp (symname, objfile->name) == 0)
    dump_msymbols (objfile, outfile);
  immediate_quit--;
  fprintf_filtered (outfile, "\n\n");
  do_cleanups (cleanups);
}

void
maintenance_print_objfiles (char *ignore, int from_tty)
{
  struct objfile *objfile;

  dont_repeat ();

  immediate_quit++;
  ALL_OBJFILES (objfile)
    dump_objfile (objfile);
  immediate_quit--;
}


/* List all the symbol tables whose names match REGEXP (optional).  */
void
maintenance_info_symtabs (char *regexp, int from_tty)
{
  struct objfile *objfile;

  if (regexp)
    re_comp (regexp);

  ALL_OBJFILES (objfile)
    {
      struct symtab *symtab;
      
      /* We don't want to print anything for this objfile until we
         actually find a symtab whose name matches.  */
      int printed_objfile_start = 0;

      ALL_OBJFILE_SYMTABS (objfile, symtab)
        if (! regexp
            || re_exec (symtab->filename))
          {
            if (! printed_objfile_start)
              {
                printf_filtered ("{ objfile %s ", objfile->name);
                wrap_here ("  ");
                printf_filtered ("((struct objfile *) %p)\n", objfile);
                printed_objfile_start = 1;
              }

            printf_filtered ("  { symtab %s ", symtab->filename);
            wrap_here ("    ");
            printf_filtered ("((struct symtab *) %p)\n", symtab);
            printf_filtered ("    dirname %s\n",
                             symtab->dirname ? symtab->dirname : "(null)");
            printf_filtered ("    fullname %s\n",
                             symtab->fullname ? symtab->fullname : "(null)");
            printf_filtered ("    blockvector ((struct blockvector *) %p)%s\n",
                             symtab->blockvector,
                             symtab->primary ? " (primary)" : "");
            printf_filtered ("    debugformat %s\n", symtab->debugformat);
            printf_filtered ("  }\n");
          }

      if (printed_objfile_start)
        printf_filtered ("}\n");
    }
}


/* List all the partial symbol tables whose names match REGEXP (optional).  */
void
maintenance_info_psymtabs (char *regexp, int from_tty)
{
  struct objfile *objfile;

  if (regexp)
    re_comp (regexp);

  ALL_OBJFILES (objfile)
    {
      struct partial_symtab *psymtab;

      /* We don't want to print anything for this objfile until we
         actually find a symtab whose name matches.  */
      int printed_objfile_start = 0;

      ALL_OBJFILE_PSYMTABS (objfile, psymtab)
        if (! regexp
            || re_exec (psymtab->filename))
          {
            if (! printed_objfile_start)
              {
                printf_filtered ("{ objfile %s ", objfile->name);
                wrap_here ("  ");
                printf_filtered ("((struct objfile *) %p)\n", objfile);
                printed_objfile_start = 1;
              }

            printf_filtered ("  { psymtab %s ", psymtab->filename);
            wrap_here ("    ");
            printf_filtered ("((struct partial_symtab *) %p)\n", psymtab);
            printf_filtered ("    readin %s\n",
                             psymtab->readin ? "yes" : "no");
            printf_filtered ("    fullname %s\n",
                             psymtab->fullname ? psymtab->fullname : "(null)");
            printf_filtered ("    text addresses ");
            print_address_numeric (psymtab->textlow, 1, gdb_stdout);
            printf_filtered (" -- ");
            print_address_numeric (psymtab->texthigh, 1, gdb_stdout);
            printf_filtered ("\n");
            printf_filtered ("    globals ");
            if (psymtab->n_global_syms)
              {
                printf_filtered ("(* (struct partial_symbol **) %p @@ %d)\n",
                                 (psymtab->objfile->global_psymbols.list
                                  + psymtab->globals_offset),
                                 psymtab->n_global_syms);
              }
            else
              printf_filtered ("(none)\n");
            printf_filtered ("    statics ");
            if (psymtab->n_static_syms)
              {
                printf_filtered ("(* (struct partial_symbol **) %p @@ %d)\n",
                                 (psymtab->objfile->static_psymbols.list
                                  + psymtab->statics_offset),
                                 psymtab->n_static_syms);
              }
            else
              printf_filtered ("(none)\n");
            printf_filtered ("    dependencies ");
            if (psymtab->number_of_dependencies)
              {
                int i;

                printf_filtered ("{\n");
                for (i = 0; i < psymtab->number_of_dependencies; i++)
                  {
                    struct partial_symtab *dep = psymtab->dependencies[i];

                    /* Note the string concatenation there --- no comma.  */
                    printf_filtered ("      psymtab %s "
                                     "((struct partial_symtab *) %p)\n",
                                     dep->filename, dep);
                  }
                printf_filtered ("    }\n");
              }
            else
              printf_filtered ("(none)\n");
            printf_filtered ("  }\n");
          }

      if (printed_objfile_start)
        printf_filtered ("}\n");
    }
}


/* Check consistency of psymtabs and symtabs.  */

void
maintenance_check_symtabs (char *ignore, int from_tty)
{
  struct symbol *sym;
  struct partial_symbol **psym;
  struct symtab *s = NULL;
  struct partial_symtab *ps;
  struct blockvector *bv;
  struct objfile *objfile;
  struct block *b;
  int length;

  ALL_PSYMTABS (objfile, ps)
  {
    s = PSYMTAB_TO_SYMTAB (ps);
    if (s == NULL)
      continue;
    bv = BLOCKVECTOR (s);
    b = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
    psym = ps->objfile->static_psymbols.list + ps->statics_offset;
    length = ps->n_static_syms;
    while (length--)
      {
	sym = lookup_block_symbol (b, DEPRECATED_SYMBOL_NAME (*psym),
				   NULL, SYMBOL_DOMAIN (*psym));
	if (!sym)
	  {
	    printf_filtered ("Static symbol `");
	    puts_filtered (DEPRECATED_SYMBOL_NAME (*psym));
	    printf_filtered ("' only found in ");
	    puts_filtered (ps->filename);
	    printf_filtered (" psymtab\n");
	  }
	psym++;
      }
    b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
    psym = ps->objfile->global_psymbols.list + ps->globals_offset;
    length = ps->n_global_syms;
    while (length--)
      {
	sym = lookup_block_symbol (b, DEPRECATED_SYMBOL_NAME (*psym),
				   NULL, SYMBOL_DOMAIN (*psym));
	if (!sym)
	  {
	    printf_filtered ("Global symbol `");
	    puts_filtered (DEPRECATED_SYMBOL_NAME (*psym));
	    printf_filtered ("' only found in ");
	    puts_filtered (ps->filename);
	    printf_filtered (" psymtab\n");
	  }
	psym++;
      }
    if (ps->texthigh < ps->textlow)
      {
	printf_filtered ("Psymtab ");
	puts_filtered (ps->filename);
	printf_filtered (" covers bad range ");
	print_address_numeric (ps->textlow, 1, gdb_stdout);
	printf_filtered (" - ");
	print_address_numeric (ps->texthigh, 1, gdb_stdout);
	printf_filtered ("\n");
	continue;
      }
    if (ps->texthigh == 0)
      continue;
    if (ps->textlow < BLOCK_START (b) || ps->texthigh > BLOCK_END (b))
      {
	printf_filtered ("Psymtab ");
	puts_filtered (ps->filename);
	printf_filtered (" covers ");
	print_address_numeric (ps->textlow, 1, gdb_stdout);
	printf_filtered (" - ");
	print_address_numeric (ps->texthigh, 1, gdb_stdout);
	printf_filtered (" but symtab covers only ");
	print_address_numeric (BLOCK_START (b), 1, gdb_stdout);
	printf_filtered (" - ");
	print_address_numeric (BLOCK_END (b), 1, gdb_stdout);
	printf_filtered ("\n");
      }
  }
}


/* Return the nexting depth of a block within other blocks in its symtab.  */

static int
block_depth (struct block *block)
{
  int i = 0;
  while ((block = BLOCK_SUPERBLOCK (block)) != NULL)
    {
      i++;
    }
  return i;
}


/* Increase the space allocated for LISTP, which is probably
   global_psymbols or static_psymbols. This space will eventually
   be freed in free_objfile().  */

void
extend_psymbol_list (struct psymbol_allocation_list *listp,
		     struct objfile *objfile)
{
  int new_size;
  if (listp->size == 0)
    {
      new_size = 255;
      listp->list = (struct partial_symbol **)
	xmalloc (new_size * sizeof (struct partial_symbol *));
    }
  else
    {
      new_size = listp->size * 2;
      listp->list = (struct partial_symbol **)
	xrealloc ((char *) listp->list,
		  new_size * sizeof (struct partial_symbol *));
    }
  /* Next assumes we only went one over.  Should be good if
     program works correctly */
  listp->next = listp->list + listp->size;
  listp->size = new_size;
}


/* Do early runtime initializations. */
void
_initialize_symmisc (void)
{
  std_in = stdin;
  std_out = stdout;
  std_err = stderr;
}
@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@d102 2
a103 2
      xmfree (objfile->md, DEPRECATED_SYMBOL_NAME (sym));
      xmfree (objfile->md, sym);
d107 1
a107 1
  xmfree (objfile->md, b);
d141 1
a141 1
      xmfree (s->objfile->md, bv);
d149 1
a149 1
	xmfree (s->objfile->md, LINETABLE (s));
d159 1
a159 1
    xmfree (s->objfile->md, s->line_charpos);
d161 1
a161 1
    xmfree (s->objfile->md, s->fullname);
d163 2
a164 2
    xmfree (s->objfile->md, s->debugformat);
  xmfree (s->objfile->md, s);
d1235 1
a1235 1
	xmmalloc (objfile->md, new_size * sizeof (struct partial_symbol *));
d1241 2
a1242 2
	xmrealloc (objfile->md, (char *) listp->list,
		   new_size * sizeof (struct partial_symbol *));
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@a1 2
   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996
   Free Software Foundation, Inc.
d3 20
a22 15
This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d32 1
a32 1
#include "obstack.h"
d35 3
d40 1
d58 5
a62 2
static void 
dump_symtab PARAMS ((struct objfile *, struct symtab *, GDB_FILE *));
d64 1
a64 2
static void 
dump_psymtab PARAMS ((struct objfile *, struct partial_symtab *, GDB_FILE *));
d66 1
a66 2
static void 
dump_msymbols PARAMS ((struct objfile *, GDB_FILE *));
d68 1
a68 2
static void 
dump_objfile PARAMS ((struct objfile *));
d70 2
a71 2
static int
block_depth PARAMS ((struct block *));
d73 1
a73 2
static void
print_partial_symbols PARAMS ((struct partial_symbol **, int, char *, GDB_FILE *));
d75 1
a75 5
struct print_symbol_args {
  struct symbol *symbol;
  int depth;
  GDB_FILE *outfile;
};
d77 6
a82 1
static int print_symbol PARAMS ((char *));
d84 1
a84 2
static void
free_symtab_block PARAMS ((struct objfile *, struct block *));
d86 1
d88 1
d91 3
d95 1
a95 3
free_symtab_block (objfile, b)
     struct objfile *objfile;
     struct block *b;
d97 4
a100 3
  register int i, n;
  n = BLOCK_NSYMS (b);
  for (i = 0; i < n; i++)
d102 2
a103 2
      mfree (objfile -> md, SYMBOL_NAME (BLOCK_SYM (b, i)));
      mfree (objfile -> md, (PTR) BLOCK_SYM (b, i));
d105 3
a107 1
  mfree (objfile -> md, (PTR) b);
d119 1
a119 2
free_symtab (s)
     register struct symtab *s;
d121 2
a122 2
  register int i, n;
  register struct blockvector *bv;
d128 2
a129 2
	 and some other symtab is in charge of freeing that block.
	 Therefore, do nothing.  */
d134 1
a134 1
	 and must be freed that way.  */
d139 1
a139 1
	free_symtab_block (s -> objfile, BLOCKVECTOR_BLOCK (bv, i));
d141 1
a141 1
      mfree (s -> objfile -> md, (PTR) bv);
d143 1
a143 1
      
d145 3
a147 3
      /* Everything will be freed either by our `free_ptr'
	 or by some other symtab, except for our linetable.
	 Free that now.  */
d149 1
a149 1
	mfree (s -> objfile -> md, (PTR) LINETABLE (s));
d154 2
a155 2
  if (s -> free_ptr != NULL)
    mfree (s -> objfile -> md, s -> free_ptr);
d158 7
a164 5
  if (s -> line_charpos != NULL)
    mfree (s -> objfile -> md, (PTR) s -> line_charpos);
  if (s -> fullname != NULL)
    mfree (s -> objfile -> md, s -> fullname);
  mfree (s -> objfile -> md, (PTR) s);
a166 2
#if MAINTENANCE_CMDS

d168 1
a168 1
print_symbol_bcache_statistics ()
d174 4
a177 4
    {
      printf_filtered ("Byte cache statistics for '%s':\n", objfile -> name);
      print_bcache_statistics (&objfile -> psymbol_cache, "partial symbol cache");
    }
d182 1
a182 1
print_objfile_statistics ()
d185 3
d191 49
a239 29
    {
      printf_filtered ("Statistics for '%s':\n", objfile -> name);
      if (OBJSTAT (objfile, n_stabs) > 0)
	printf_filtered ("  Number of \"stab\" symbols read: %d\n",
			 OBJSTAT (objfile, n_stabs));
      if (OBJSTAT (objfile, n_minsyms) > 0)
	printf_filtered ("  Number of \"minimal symbols read: %d\n",
			 OBJSTAT (objfile, n_minsyms));
      if (OBJSTAT (objfile, n_psyms) > 0)
	printf_filtered ("  Number of \"partial symbols read: %d\n",
			 OBJSTAT (objfile, n_psyms));
      if (OBJSTAT (objfile, n_syms) > 0)
	printf_filtered ("  Number of \"full symbols read: %d\n",
			 OBJSTAT (objfile, n_syms));
      if (OBJSTAT (objfile, n_types) > 0)
	printf_filtered ("  Number of \"types defined: %d\n",
			 OBJSTAT (objfile, n_types));
      if (OBJSTAT (objfile, sz_strtab) > 0)
	printf_filtered ("  Space used by a.out string tables: %d\n",
			 OBJSTAT (objfile, sz_strtab));
      printf_filtered ("  Total memory used for psymbol obstack: %d\n",
		       obstack_memory_used (&objfile -> psymbol_obstack));
      printf_filtered ("  Total memory used for psymbol cache: %d\n",
		       obstack_memory_used (&objfile -> psymbol_cache.cache));
      printf_filtered ("  Total memory used for symbol obstack: %d\n",
		       obstack_memory_used (&objfile -> symbol_obstack));
      printf_filtered ("  Total memory used for type obstack: %d\n",
		       obstack_memory_used (&objfile -> type_obstack));
    }
d243 2
a244 3
static void 
dump_objfile (objfile)
     struct objfile *objfile;
d249 1
a249 1
  printf_filtered ("\nObject file %s:  ", objfile -> name);
d251 1
a251 1
  gdb_print_address (objfile, gdb_stdout);
d253 1
a253 1
  gdb_print_address (objfile->obfd, gdb_stdout);
d257 1
a257 1
  if (objfile -> psymtabs)
d260 1
a260 1
      for (psymtab = objfile -> psymtabs;
d262 1
a262 1
	   psymtab = psymtab -> next)
d265 2
a266 2
			   psymtab -> filename);
	  gdb_print_address (psymtab, gdb_stdout);
d268 1
a268 1
	  if (psymtab -> objfile != objfile)
d277 1
a277 1
  if (objfile -> symtabs)
d280 1
a280 1
      for (symtab = objfile -> symtabs;
d284 2
a285 2
	  printf_filtered ("%s at ", symtab -> filename);
	  gdb_print_address (symtab, gdb_stdout);
d287 1
a287 1
	  if (symtab -> objfile != objfile)
d298 3
a300 5
 
static void 
dump_msymbols (objfile, outfile)
     struct objfile *objfile;
     GDB_FILE *outfile;
d305 3
a307 3
  
  fprintf_filtered (outfile, "\nObject file %s:\n\n", objfile -> name);
  if (objfile -> minimal_symbol_count == 0)
d312 2
a313 2
  for (index = 0, msymbol = objfile -> msymbols;
       SYMBOL_NAME (msymbol) != NULL; msymbol++, index++)
d315 1
a315 1
      switch (msymbol -> type)
d317 30
a346 30
	  case mst_unknown:
	    ms_type = 'u';
	    break;
	  case mst_text:
	    ms_type = 'T';
	    break;
	  case mst_solib_trampoline:
	    ms_type = 'S';
	    break;
	  case mst_data:
	    ms_type = 'D';
	    break;
	  case mst_bss:
	    ms_type = 'B';
	    break;
	  case mst_abs:
	    ms_type = 'A';
	    break;
	  case mst_file_text:
	    ms_type = 't';
	    break;
	  case mst_file_data:
	    ms_type = 'd';
	    break;
	  case mst_file_bss:
	    ms_type = 'b';
	    break;
	  default:
	    ms_type = '?';
	    break;
d348 7
a354 2
      fprintf_filtered (outfile, "[%2d] %c %#10lx %s", index, ms_type,
			SYMBOL_VALUE_ADDRESS (msymbol), SYMBOL_NAME (msymbol));
d365 1
a365 1
  if (objfile -> minimal_symbol_count != index)
d368 1
a368 1
	       objfile -> minimal_symbol_count, index);
d374 2
a375 4
dump_psymtab (objfile, psymtab, outfile)
     struct objfile *objfile;
     struct partial_symtab *psymtab;
     GDB_FILE *outfile;
d380 1
a380 1
		    psymtab -> filename);
d382 1
a382 1
  gdb_print_address (psymtab, outfile);
d385 2
a386 2
		      objfile -> name);
  gdb_print_address (objfile, outfile);
d389 1
a389 1
  if (psymtab -> readin)
d392 2
a393 2
		"  Full symtab was read (at ");
      gdb_print_address (psymtab->symtab, outfile);
d395 1
a395 1
      gdb_print_address ((PTR)psymtab->read_symtab, outfile);
d417 2
a418 2
		    psymtab -> number_of_dependencies);
  for (i = 0; i < psymtab -> number_of_dependencies; i++)
d421 1
a421 1
      gdb_print_address (psymtab -> dependencies[i], outfile);
d423 1
a423 1
			psymtab -> dependencies[i] -> filename);
d425 1
a425 1
  if (psymtab -> n_global_syms > 0)
d427 3
a429 3
      print_partial_symbols (objfile -> global_psymbols.list
			    + psymtab -> globals_offset,
			    psymtab -> n_global_syms, "Global", outfile);
d431 1
a431 1
  if (psymtab -> n_static_syms > 0)
d433 3
a435 3
      print_partial_symbols (objfile -> static_psymbols.list
			    + psymtab -> statics_offset,
			    psymtab -> n_static_syms, "Static", outfile);
d440 3
a442 5
static void 
dump_symtab (objfile, symtab, outfile)
     struct objfile *objfile;
     struct symtab *symtab;
     GDB_FILE *outfile;
d444 2
a445 1
  register int i, j;
d447 1
a447 1
  register struct linetable *l;
d449 2
a450 1
  register struct block *b;
d454 3
d458 1
a458 1
  gdb_print_address (objfile, outfile);
d460 1
a460 1
  fprintf_filtered (outfile, "Language: %s\n", language_str (symtab -> language));
d477 1
a477 1
  if (symtab -> primary)
d488 1
a488 1
	  gdb_print_address (b, outfile);
d492 1
a492 1
	      gdb_print_address (BLOCK_SUPERBLOCK (b), outfile);
d494 5
a498 2
	  blen = BLOCK_NSYMS (b);
	  fprintf_filtered (outfile, ", %d syms in ", blen);
d504 1
a504 1
	      fprintf_filtered (outfile, ", function %s", SYMBOL_NAME (BLOCK_FUNCTION (b)));
d508 1
a508 1
				    SYMBOL_DEMANGLED_NAME (BLOCK_FUNCTION (b)));
d511 2
a512 2
	  if (BLOCK_GCC_COMPILED(b))
	    fprintf_filtered (outfile, ", compiled with gcc%d", BLOCK_GCC_COMPILED(b));
d514 3
a516 2
	  /* Now print each symbol in this block */
	  for (j = 0; j < blen; j++)
d519 1
a519 1
	      s.symbol = BLOCK_SYM (b, j);
d535 1
a535 3
maintenance_print_symbols (args, from_tty)
     char *args;
     int from_tty;
d538 1
a538 1
  GDB_FILE *outfile;
d556 1
a556 1
  cleanups = make_cleanup (freeargv, (char *) argv);
d569 2
a570 2
  make_cleanup (free, filename);
  
d574 1
a574 1
  make_cleanup (fclose, (char *) outfile);
d578 2
a579 2
    if (symname == NULL || (STREQ (symname, s -> filename)))
      dump_symtab (objfile, s, outfile);
d590 1
a590 2
print_symbol (args)
     char *args;
d592 3
a594 3
  struct symbol *symbol = ((struct print_symbol_args *)args)->symbol;
  int depth = ((struct print_symbol_args *)args)->depth;
  GDB_FILE *outfile = ((struct print_symbol_args *)args)->outfile;
d597 1
a597 1
  if (SYMBOL_NAMESPACE (symbol) == LABEL_NAMESPACE)
d599 1
a599 1
      fprintf_filtered (outfile, "label %s at ", SYMBOL_SOURCE_NAME (symbol));
d601 6
a606 1
      fprintf_filtered (outfile, "\n");
d609 1
a609 1
  if (SYMBOL_NAMESPACE (symbol) == STRUCT_NAMESPACE)
d618 5
a622 5
	       (TYPE_CODE (SYMBOL_TYPE (symbol)) == TYPE_CODE_ENUM
		? "enum"
		: (TYPE_CODE (SYMBOL_TYPE (symbol)) == TYPE_CODE_STRUCT
		   ? "struct" : "union")),
	       SYMBOL_NAME (symbol));
d634 1
a634 1
	  LA_PRINT_TYPE (SYMBOL_TYPE (symbol), SYMBOL_SOURCE_NAME (symbol),
d641 1
a641 1
	fprintf_filtered (outfile, "%s ", SYMBOL_SOURCE_NAME (symbol));
d659 1
a659 1
				(unsigned)SYMBOL_VALUE_BYTES (symbol) [i]);
d665 12
a676 1
	  print_address_numeric (SYMBOL_VALUE_ADDRESS (symbol), 1,outfile);
d690 1
a690 1
		   SYMBOL_VALUE (symbol));
d712 1
a712 1
		   SYMBOL_VALUE (symbol), SYMBOL_BASEREG (symbol));
d717 1
a717 1
		   SYMBOL_VALUE (symbol), SYMBOL_BASEREG (symbol));
d726 5
d735 1
a735 1
	  gdb_print_address (SYMBOL_BLOCK_VALUE (symbol), outfile);
d744 10
d764 1
a764 1
        default:
d775 1
a775 3
maintenance_print_psymbols (args, from_tty)
     char *args;
     int from_tty;
d778 1
a778 1
  GDB_FILE *outfile;
d795 1
a795 1
  cleanups = make_cleanup (freeargv, (char *) argv);
d808 2
a809 2
  make_cleanup (free, filename);
  
d813 1
a813 1
  make_cleanup (fclose, outfile);
d817 2
a818 2
    if (symname == NULL || (STREQ (symname, ps -> filename)))
      dump_psymtab (objfile, ps, outfile);
d824 2
a825 5
print_partial_symbols (p, count, what, outfile)
     struct partial_symbol **p;
     int count;
     char *what;
     GDB_FILE *outfile;
d830 1
a830 1
      fprintf_filtered (outfile, "    `%s'", SYMBOL_NAME(*p));
d836 1
a836 1
      switch (SYMBOL_NAMESPACE (*p))
d838 2
a839 2
	case UNDEF_NAMESPACE:
	  fputs_filtered ("undefined namespace, ", outfile);
d841 1
a841 1
	case VAR_NAMESPACE:
d844 2
a845 2
	case STRUCT_NAMESPACE:
	  fputs_filtered ("struct namespace, ", outfile);
d847 2
a848 2
	case LABEL_NAMESPACE:
	  fputs_filtered ("label namespace, ", outfile);
d851 1
a851 1
	  fputs_filtered ("<invalid namespace>, ", outfile);
d865 3
d907 4
d916 2
a917 4
      /* FIXME-32x64: Need to use SYMBOL_VALUE_ADDRESS, etc.; this
	 could be 32 bits when some of the other fields in the union
	 are 64.  */
      fprintf_filtered (outfile, "0x%lx\n", SYMBOL_VALUE (*p));
d923 1
a923 3
maintenance_print_msymbols (args, from_tty)
     char *args;
     int from_tty;
d926 1
a926 1
  GDB_FILE *outfile;
d942 1
a942 1
  cleanups = make_cleanup (freeargv, argv);
d955 2
a956 2
  make_cleanup (free, filename);
  
d960 1
a960 1
  make_cleanup (fclose, outfile);
d964 2
a965 2
    if (symname == NULL || (STREQ (symname, objfile -> name)))
      dump_msymbols (objfile, outfile);
d972 1
a972 3
maintenance_print_objfiles (ignore, from_tty)
     char *ignore;
     int from_tty;
d984 139
d1126 1
a1126 3
maintenance_check_symtabs (ignore, from_tty)
     char *ignore;
     int from_tty;
d1128 4
a1131 4
  register struct symbol *sym;
  register struct partial_symbol **psym;
  register struct symtab *s = NULL;
  register struct partial_symtab *ps;
d1133 2
a1134 2
  register struct objfile *objfile;
  register struct block *b;
d1138 48
a1185 51
    {
      s = PSYMTAB_TO_SYMTAB(ps);
      if (s == NULL)
	continue;
      bv = BLOCKVECTOR (s);
      b = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
      psym = ps->objfile->static_psymbols.list + ps->statics_offset;
      length = ps->n_static_syms;
      while (length--)
	{
	  sym = lookup_block_symbol (b, SYMBOL_NAME (*psym),
				     SYMBOL_NAMESPACE (*psym));
	  if (!sym)
	    {
	      printf_filtered ("Static symbol `");
	      puts_filtered (SYMBOL_NAME (*psym));
	      printf_filtered ("' only found in ");
	      puts_filtered (ps->filename);
	      printf_filtered (" psymtab\n");
	    }
	  psym++;
	}
      b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
      psym = ps->objfile->global_psymbols.list + ps->globals_offset;
      length = ps->n_global_syms;
      while (length--)
	{
	  sym = lookup_block_symbol (b, SYMBOL_NAME (*psym),
				     SYMBOL_NAMESPACE (*psym));
	  if (!sym)
	    {
	      printf_filtered ("Global symbol `");
	      puts_filtered (SYMBOL_NAME (*psym));
	      printf_filtered ("' only found in ");
	      puts_filtered (ps->filename);
	      printf_filtered (" psymtab\n");
	    }
	  psym++;
	}
      if (ps->texthigh < ps->textlow)
	{
	  printf_filtered ("Psymtab ");
	  puts_filtered (ps->filename);
	  printf_filtered (" covers bad range ");
          print_address_numeric (ps->textlow, 1, stdout);
	  printf_filtered (" - ");
          print_address_numeric (ps->texthigh, 1, stdout);
	  printf_filtered ("\n");
	  continue;
	}
      if (ps->texthigh == 0)
d1187 18
a1204 15
      if (ps->textlow < BLOCK_START (b) || ps->texthigh > BLOCK_END (b))
	{
	  printf_filtered ("Psymtab ");
	  puts_filtered (ps->filename);
	  printf_filtered (" covers ");
          print_address_numeric (ps->textlow, 1, stdout);
	  printf_filtered (" - ");
          print_address_numeric (ps->texthigh, 1, stdout);
	  printf_filtered (" but symtab covers only ");
          print_address_numeric (BLOCK_START (b), 1, stdout);
	  printf_filtered (" - ");
          print_address_numeric (BLOCK_END (b), 1, stdout);
	  printf_filtered ("\n");
	}
    }
d1206 1
a1207 1

d1211 1
a1211 2
block_depth (block)
     struct block *block;
d1213 2
a1214 2
  register int i = 0;
  while ((block = BLOCK_SUPERBLOCK (block)) != NULL) 
d1220 1
a1221 3
#endif	/* MAINTENANCE_CMDS */


d1227 2
a1228 3
extend_psymbol_list (listp, objfile)
     register struct psymbol_allocation_list *listp;
     struct objfile *objfile;
d1235 1
a1235 1
	xmmalloc (objfile -> md, new_size * sizeof (struct partial_symbol *));
d1241 1
a1241 1
	xmrealloc (objfile -> md, (char *) listp->list,
d1253 1
a1253 1
_initialize_symmisc ()
d1255 1
a1255 1
  std_in  = stdin;
@


1.1
log
@file symmisc.c was initially added on branch CYGNUS.
@
text
@d1 1060
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 1258
/* Do various things to symbol tables (other than lookup), for GDB.

   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004 Free Software
   Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "bfd.h"
#include "symfile.h"
#include "objfiles.h"
#include "breakpoint.h"
#include "command.h"
#include "gdb_obstack.h"
#include "language.h"
#include "bcache.h"
#include "block.h"
#include "gdb_regex.h"
#include "dictionary.h"

#include "gdb_string.h"
#include "readline/readline.h"

#ifndef DEV_TTY
#define DEV_TTY "/dev/tty"
#endif

/* Unfortunately for debugging, stderr is usually a macro.  This is painful
   when calling functions that take FILE *'s from the debugger.
   So we make a variable which has the same value and which is accessible when
   debugging GDB with itself.  Because stdin et al need not be constants,
   we initialize them in the _initialize_symmisc function at the bottom
   of the file.  */
FILE *std_in;
FILE *std_out;
FILE *std_err;

/* Prototypes for local functions */

static void dump_symtab (struct objfile *, struct symtab *,
			 struct ui_file *);

static void dump_psymtab (struct objfile *, struct partial_symtab *,
			  struct ui_file *);

static void dump_msymbols (struct objfile *, struct ui_file *);

static void dump_objfile (struct objfile *);

static int block_depth (struct block *);

static void print_partial_symbols (struct partial_symbol **, int,
				   char *, struct ui_file *);

static void free_symtab_block (struct objfile *, struct block *);

void _initialize_symmisc (void);

struct print_symbol_args
  {
    struct symbol *symbol;
    int depth;
    struct ui_file *outfile;
  };

static int print_symbol (void *);

static void free_symtab_block (struct objfile *, struct block *);


/* Free a struct block <- B and all the symbols defined in that block.  */

/* FIXME: carlton/2003-04-28: I don't believe this is currently ever
   used.  */

static void
free_symtab_block (struct objfile *objfile, struct block *b)
{
  struct dict_iterator iter;
  struct symbol *sym;

  ALL_BLOCK_SYMBOLS (b, iter, sym)
    {
      xmfree (objfile->md, DEPRECATED_SYMBOL_NAME (sym));
      xmfree (objfile->md, sym);
    }

  dict_free (BLOCK_DICT (b));
  xmfree (objfile->md, b);
}

/* Free all the storage associated with the struct symtab <- S.
   Note that some symtabs have contents malloc'ed structure by structure,
   while some have contents that all live inside one big block of memory,
   and some share the contents of another symbol table and so you should
   not free the contents on their behalf (except sometimes the linetable,
   which maybe per symtab even when the rest is not).
   It is s->free_code that says which alternative to use.  */

void
free_symtab (struct symtab *s)
{
  int i, n;
  struct blockvector *bv;

  switch (s->free_code)
    {
    case free_nothing:
      /* All the contents are part of a big block of memory (an obstack),
         and some other symtab is in charge of freeing that block.
         Therefore, do nothing.  */
      break;

    case free_contents:
      /* Here all the contents were malloc'ed structure by structure
         and must be freed that way.  */
      /* First free the blocks (and their symbols.  */
      bv = BLOCKVECTOR (s);
      n = BLOCKVECTOR_NBLOCKS (bv);
      for (i = 0; i < n; i++)
	free_symtab_block (s->objfile, BLOCKVECTOR_BLOCK (bv, i));
      /* Free the blockvector itself.  */
      xmfree (s->objfile->md, bv);
      /* Also free the linetable.  */

    case free_linetable:
      /* Everything will be freed either by our `free_func'
         or by some other symtab, except for our linetable.
         Free that now.  */
      if (LINETABLE (s))
	xmfree (s->objfile->md, LINETABLE (s));
      break;
    }

  /* If there is a single block of memory to free, free it.  */
  if (s->free_func != NULL)
    s->free_func (s);

  /* Free source-related stuff */
  if (s->line_charpos != NULL)
    xmfree (s->objfile->md, s->line_charpos);
  if (s->fullname != NULL)
    xmfree (s->objfile->md, s->fullname);
  if (s->debugformat != NULL)
    xmfree (s->objfile->md, s->debugformat);
  xmfree (s->objfile->md, s);
}

void
print_symbol_bcache_statistics (void)
{
  struct objfile *objfile;

  immediate_quit++;
  ALL_OBJFILES (objfile)
  {
    printf_filtered ("Byte cache statistics for '%s':\n", objfile->name);
    print_bcache_statistics (objfile->psymbol_cache, "partial symbol cache");
  }
  immediate_quit--;
}

void
print_objfile_statistics (void)
{
  struct objfile *objfile;
  struct symtab *s;
  struct partial_symtab *ps;
  int i, linetables, blockvectors;

  immediate_quit++;
  ALL_OBJFILES (objfile)
  {
    printf_filtered ("Statistics for '%s':\n", objfile->name);
    if (OBJSTAT (objfile, n_stabs) > 0)
      printf_filtered ("  Number of \"stab\" symbols read: %d\n",
		       OBJSTAT (objfile, n_stabs));
    if (OBJSTAT (objfile, n_minsyms) > 0)
      printf_filtered ("  Number of \"minimal\" symbols read: %d\n",
		       OBJSTAT (objfile, n_minsyms));
    if (OBJSTAT (objfile, n_psyms) > 0)
      printf_filtered ("  Number of \"partial\" symbols read: %d\n",
		       OBJSTAT (objfile, n_psyms));
    if (OBJSTAT (objfile, n_syms) > 0)
      printf_filtered ("  Number of \"full\" symbols read: %d\n",
		       OBJSTAT (objfile, n_syms));
    if (OBJSTAT (objfile, n_types) > 0)
      printf_filtered ("  Number of \"types\" defined: %d\n",
		       OBJSTAT (objfile, n_types));
    i = 0;
    ALL_OBJFILE_PSYMTABS (objfile, ps)
      {
        if (ps->readin == 0)
          i++;
      }
    printf_filtered ("  Number of psym tables (not yet expanded): %d\n", i);
    i = linetables = blockvectors = 0;
    ALL_OBJFILE_SYMTABS (objfile, s)
      {
        i++;
        if (s->linetable != NULL)
          linetables++;
        if (s->primary == 1)
          blockvectors++;
      }
    printf_filtered ("  Number of symbol tables: %d\n", i);
    printf_filtered ("  Number of symbol tables with line tables: %d\n", 
                     linetables);
    printf_filtered ("  Number of symbol tables with blockvectors: %d\n", 
                     blockvectors);
    
    if (OBJSTAT (objfile, sz_strtab) > 0)
      printf_filtered ("  Space used by a.out string tables: %d\n",
		       OBJSTAT (objfile, sz_strtab));
    printf_filtered ("  Total memory used for objfile obstack: %d\n",
		     obstack_memory_used (&objfile->objfile_obstack));
    printf_filtered ("  Total memory used for psymbol cache: %d\n",
		     bcache_memory_used (objfile->psymbol_cache));
    printf_filtered ("  Total memory used for macro cache: %d\n",
		     bcache_memory_used (objfile->macro_cache));
  }
  immediate_quit--;
}

static void
dump_objfile (struct objfile *objfile)
{
  struct symtab *symtab;
  struct partial_symtab *psymtab;

  printf_filtered ("\nObject file %s:  ", objfile->name);
  printf_filtered ("Objfile at ");
  gdb_print_host_address (objfile, gdb_stdout);
  printf_filtered (", bfd at ");
  gdb_print_host_address (objfile->obfd, gdb_stdout);
  printf_filtered (", %d minsyms\n\n",
		   objfile->minimal_symbol_count);

  if (objfile->psymtabs)
    {
      printf_filtered ("Psymtabs:\n");
      for (psymtab = objfile->psymtabs;
	   psymtab != NULL;
	   psymtab = psymtab->next)
	{
	  printf_filtered ("%s at ",
			   psymtab->filename);
	  gdb_print_host_address (psymtab, gdb_stdout);
	  printf_filtered (", ");
	  if (psymtab->objfile != objfile)
	    {
	      printf_filtered ("NOT ON CHAIN!  ");
	    }
	  wrap_here ("  ");
	}
      printf_filtered ("\n\n");
    }

  if (objfile->symtabs)
    {
      printf_filtered ("Symtabs:\n");
      for (symtab = objfile->symtabs;
	   symtab != NULL;
	   symtab = symtab->next)
	{
	  printf_filtered ("%s at ", symtab->filename);
	  gdb_print_host_address (symtab, gdb_stdout);
	  printf_filtered (", ");
	  if (symtab->objfile != objfile)
	    {
	      printf_filtered ("NOT ON CHAIN!  ");
	    }
	  wrap_here ("  ");
	}
      printf_filtered ("\n\n");
    }
}

/* Print minimal symbols from this objfile.  */

static void
dump_msymbols (struct objfile *objfile, struct ui_file *outfile)
{
  struct minimal_symbol *msymbol;
  int index;
  char ms_type;

  fprintf_filtered (outfile, "\nObject file %s:\n\n", objfile->name);
  if (objfile->minimal_symbol_count == 0)
    {
      fprintf_filtered (outfile, "No minimal symbols found.\n");
      return;
    }
  for (index = 0, msymbol = objfile->msymbols;
       DEPRECATED_SYMBOL_NAME (msymbol) != NULL; msymbol++, index++)
    {
      switch (msymbol->type)
	{
	case mst_unknown:
	  ms_type = 'u';
	  break;
	case mst_text:
	  ms_type = 'T';
	  break;
	case mst_solib_trampoline:
	  ms_type = 'S';
	  break;
	case mst_data:
	  ms_type = 'D';
	  break;
	case mst_bss:
	  ms_type = 'B';
	  break;
	case mst_abs:
	  ms_type = 'A';
	  break;
	case mst_file_text:
	  ms_type = 't';
	  break;
	case mst_file_data:
	  ms_type = 'd';
	  break;
	case mst_file_bss:
	  ms_type = 'b';
	  break;
	default:
	  ms_type = '?';
	  break;
	}
      fprintf_filtered (outfile, "[%2d] %c ", index, ms_type);
      print_address_numeric (SYMBOL_VALUE_ADDRESS (msymbol), 1, outfile);
      fprintf_filtered (outfile, " %s", DEPRECATED_SYMBOL_NAME (msymbol));
      if (SYMBOL_BFD_SECTION (msymbol))
	fprintf_filtered (outfile, " section %s",
			  bfd_section_name (objfile->obfd,
					    SYMBOL_BFD_SECTION (msymbol)));
      if (SYMBOL_DEMANGLED_NAME (msymbol) != NULL)
	{
	  fprintf_filtered (outfile, "  %s", SYMBOL_DEMANGLED_NAME (msymbol));
	}
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
      if (msymbol->filename)
	fprintf_filtered (outfile, "  %s", msymbol->filename);
#endif
      fputs_filtered ("\n", outfile);
    }
  if (objfile->minimal_symbol_count != index)
    {
      warning ("internal error:  minimal symbol count %d != %d",
	       objfile->minimal_symbol_count, index);
    }
  fprintf_filtered (outfile, "\n");
}

static void
dump_psymtab (struct objfile *objfile, struct partial_symtab *psymtab,
	      struct ui_file *outfile)
{
  int i;

  fprintf_filtered (outfile, "\nPartial symtab for source file %s ",
		    psymtab->filename);
  fprintf_filtered (outfile, "(object ");
  gdb_print_host_address (psymtab, outfile);
  fprintf_filtered (outfile, ")\n\n");
  fprintf_unfiltered (outfile, "  Read from object file %s (",
		      objfile->name);
  gdb_print_host_address (objfile, outfile);
  fprintf_unfiltered (outfile, ")\n");

  if (psymtab->readin)
    {
      fprintf_filtered (outfile,
			"  Full symtab was read (at ");
      gdb_print_host_address (psymtab->symtab, outfile);
      fprintf_filtered (outfile, " by function at ");
      gdb_print_host_address (psymtab->read_symtab, outfile);
      fprintf_filtered (outfile, ")\n");
    }

  fprintf_filtered (outfile, "  Relocate symbols by ");
  for (i = 0; i < psymtab->objfile->num_sections; ++i)
    {
      if (i != 0)
	fprintf_filtered (outfile, ", ");
      wrap_here ("    ");
      print_address_numeric (ANOFFSET (psymtab->section_offsets, i),
			     1,
			     outfile);
    }
  fprintf_filtered (outfile, "\n");

  fprintf_filtered (outfile, "  Symbols cover text addresses ");
  print_address_numeric (psymtab->textlow, 1, outfile);
  fprintf_filtered (outfile, "-");
  print_address_numeric (psymtab->texthigh, 1, outfile);
  fprintf_filtered (outfile, "\n");
  fprintf_filtered (outfile, "  Depends on %d other partial symtabs.\n",
		    psymtab->number_of_dependencies);
  for (i = 0; i < psymtab->number_of_dependencies; i++)
    {
      fprintf_filtered (outfile, "    %d ", i);
      gdb_print_host_address (psymtab->dependencies[i], outfile);
      fprintf_filtered (outfile, " %s\n",
			psymtab->dependencies[i]->filename);
    }
  if (psymtab->n_global_syms > 0)
    {
      print_partial_symbols (objfile->global_psymbols.list
			     + psymtab->globals_offset,
			     psymtab->n_global_syms, "Global", outfile);
    }
  if (psymtab->n_static_syms > 0)
    {
      print_partial_symbols (objfile->static_psymbols.list
			     + psymtab->statics_offset,
			     psymtab->n_static_syms, "Static", outfile);
    }
  fprintf_filtered (outfile, "\n");
}

static void
dump_symtab (struct objfile *objfile, struct symtab *symtab,
	     struct ui_file *outfile)
{
  int i;
  struct dict_iterator iter;
  int len, blen;
  struct linetable *l;
  struct blockvector *bv;
  struct symbol *sym;
  struct block *b;
  int depth;

  fprintf_filtered (outfile, "\nSymtab for file %s\n", symtab->filename);
  if (symtab->dirname)
    fprintf_filtered (outfile, "Compilation directory is %s\n",
		      symtab->dirname);
  fprintf_filtered (outfile, "Read from object file %s (", objfile->name);
  gdb_print_host_address (objfile, outfile);
  fprintf_filtered (outfile, ")\n");
  fprintf_filtered (outfile, "Language: %s\n", language_str (symtab->language));

  /* First print the line table.  */
  l = LINETABLE (symtab);
  if (l)
    {
      fprintf_filtered (outfile, "\nLine table:\n\n");
      len = l->nitems;
      for (i = 0; i < len; i++)
	{
	  fprintf_filtered (outfile, " line %d at ", l->item[i].line);
	  print_address_numeric (l->item[i].pc, 1, outfile);
	  fprintf_filtered (outfile, "\n");
	}
    }
  /* Now print the block info, but only for primary symtabs since we will
     print lots of duplicate info otherwise. */
  if (symtab->primary)
    {
      fprintf_filtered (outfile, "\nBlockvector:\n\n");
      bv = BLOCKVECTOR (symtab);
      len = BLOCKVECTOR_NBLOCKS (bv);
      for (i = 0; i < len; i++)
	{
	  b = BLOCKVECTOR_BLOCK (bv, i);
	  depth = block_depth (b) * 2;
	  print_spaces (depth, outfile);
	  fprintf_filtered (outfile, "block #%03d, object at ", i);
	  gdb_print_host_address (b, outfile);
	  if (BLOCK_SUPERBLOCK (b))
	    {
	      fprintf_filtered (outfile, " under ");
	      gdb_print_host_address (BLOCK_SUPERBLOCK (b), outfile);
	    }
	  /* drow/2002-07-10: We could save the total symbols count
	     even if we're using a hashtable, but nothing else but this message
	     wants it.  */
	  fprintf_filtered (outfile, ", %d syms/buckets in ",
			    dict_size (BLOCK_DICT (b)));
	  print_address_numeric (BLOCK_START (b), 1, outfile);
	  fprintf_filtered (outfile, "..");
	  print_address_numeric (BLOCK_END (b), 1, outfile);
	  if (BLOCK_FUNCTION (b))
	    {
	      fprintf_filtered (outfile, ", function %s", DEPRECATED_SYMBOL_NAME (BLOCK_FUNCTION (b)));
	      if (SYMBOL_DEMANGLED_NAME (BLOCK_FUNCTION (b)) != NULL)
		{
		  fprintf_filtered (outfile, ", %s",
				SYMBOL_DEMANGLED_NAME (BLOCK_FUNCTION (b)));
		}
	    }
	  if (BLOCK_GCC_COMPILED (b))
	    fprintf_filtered (outfile, ", compiled with gcc%d", BLOCK_GCC_COMPILED (b));
	  fprintf_filtered (outfile, "\n");
	  /* Now print each symbol in this block (in no particular order, if
	     we're using a hashtable).  */
	  ALL_BLOCK_SYMBOLS (b, iter, sym)
	    {
	      struct print_symbol_args s;
	      s.symbol = sym;
	      s.depth = depth + 1;
	      s.outfile = outfile;
	      catch_errors (print_symbol, &s, "Error printing symbol:\n",
			    RETURN_MASK_ALL);
	    }
	}
      fprintf_filtered (outfile, "\n");
    }
  else
    {
      fprintf_filtered (outfile, "\nBlockvector same as previous symtab\n\n");
    }
}

void
maintenance_print_symbols (char *args, int from_tty)
{
  char **argv;
  struct ui_file *outfile;
  struct cleanup *cleanups;
  char *symname = NULL;
  char *filename = DEV_TTY;
  struct objfile *objfile;
  struct symtab *s;

  dont_repeat ();

  if (args == NULL)
    {
      error ("\
Arguments missing: an output file name and an optional symbol file name");
    }
  else if ((argv = buildargv (args)) == NULL)
    {
      nomem (0);
    }
  cleanups = make_cleanup_freeargv (argv);

  if (argv[0] != NULL)
    {
      filename = argv[0];
      /* If a second arg is supplied, it is a source file name to match on */
      if (argv[1] != NULL)
	{
	  symname = argv[1];
	}
    }

  filename = tilde_expand (filename);
  make_cleanup (xfree, filename);

  outfile = gdb_fopen (filename, FOPEN_WT);
  if (outfile == 0)
    perror_with_name (filename);
  make_cleanup_ui_file_delete (outfile);

  immediate_quit++;
  ALL_SYMTABS (objfile, s)
    if (symname == NULL || strcmp (symname, s->filename) == 0)
    dump_symtab (objfile, s, outfile);
  immediate_quit--;
  do_cleanups (cleanups);
}

/* Print symbol ARGS->SYMBOL on ARGS->OUTFILE.  ARGS->DEPTH says how
   far to indent.  ARGS is really a struct print_symbol_args *, but is
   declared as char * to get it past catch_errors.  Returns 0 for error,
   1 for success.  */

static int
print_symbol (void *args)
{
  struct symbol *symbol = ((struct print_symbol_args *) args)->symbol;
  int depth = ((struct print_symbol_args *) args)->depth;
  struct ui_file *outfile = ((struct print_symbol_args *) args)->outfile;

  print_spaces (depth, outfile);
  if (SYMBOL_DOMAIN (symbol) == LABEL_DOMAIN)
    {
      fprintf_filtered (outfile, "label %s at ", SYMBOL_PRINT_NAME (symbol));
      print_address_numeric (SYMBOL_VALUE_ADDRESS (symbol), 1, outfile);
      if (SYMBOL_BFD_SECTION (symbol))
	fprintf_filtered (outfile, " section %s\n",
		       bfd_section_name (SYMBOL_BFD_SECTION (symbol)->owner,
					 SYMBOL_BFD_SECTION (symbol)));
      else
	fprintf_filtered (outfile, "\n");
      return 1;
    }
  if (SYMBOL_DOMAIN (symbol) == STRUCT_DOMAIN)
    {
      if (TYPE_TAG_NAME (SYMBOL_TYPE (symbol)))
	{
	  LA_PRINT_TYPE (SYMBOL_TYPE (symbol), "", outfile, 1, depth);
	}
      else
	{
	  fprintf_filtered (outfile, "%s %s = ",
			 (TYPE_CODE (SYMBOL_TYPE (symbol)) == TYPE_CODE_ENUM
			  ? "enum"
		     : (TYPE_CODE (SYMBOL_TYPE (symbol)) == TYPE_CODE_STRUCT
			? "struct" : "union")),
			    DEPRECATED_SYMBOL_NAME (symbol));
	  LA_PRINT_TYPE (SYMBOL_TYPE (symbol), "", outfile, 1, depth);
	}
      fprintf_filtered (outfile, ";\n");
    }
  else
    {
      if (SYMBOL_CLASS (symbol) == LOC_TYPEDEF)
	fprintf_filtered (outfile, "typedef ");
      if (SYMBOL_TYPE (symbol))
	{
	  /* Print details of types, except for enums where it's clutter.  */
	  LA_PRINT_TYPE (SYMBOL_TYPE (symbol), SYMBOL_PRINT_NAME (symbol),
			 outfile,
			 TYPE_CODE (SYMBOL_TYPE (symbol)) != TYPE_CODE_ENUM,
			 depth);
	  fprintf_filtered (outfile, "; ");
	}
      else
	fprintf_filtered (outfile, "%s ", SYMBOL_PRINT_NAME (symbol));

      switch (SYMBOL_CLASS (symbol))
	{
	case LOC_CONST:
	  fprintf_filtered (outfile, "const %ld (0x%lx)",
			    SYMBOL_VALUE (symbol),
			    SYMBOL_VALUE (symbol));
	  break;

	case LOC_CONST_BYTES:
	  {
	    unsigned i;
	    struct type *type = check_typedef (SYMBOL_TYPE (symbol));
	    fprintf_filtered (outfile, "const %u hex bytes:",
			      TYPE_LENGTH (type));
	    for (i = 0; i < TYPE_LENGTH (type); i++)
	      fprintf_filtered (outfile, " %02x",
				(unsigned) SYMBOL_VALUE_BYTES (symbol)[i]);
	  }
	  break;

	case LOC_STATIC:
	  fprintf_filtered (outfile, "static at ");
	  print_address_numeric (SYMBOL_VALUE_ADDRESS (symbol), 1, outfile);
	  if (SYMBOL_BFD_SECTION (symbol))
	    fprintf_filtered (outfile, " section %s",
			      bfd_section_name
			      (SYMBOL_BFD_SECTION (symbol)->owner,
			       SYMBOL_BFD_SECTION (symbol)));
	  break;

	case LOC_INDIRECT:
	  fprintf_filtered (outfile, "extern global at *(");
	  print_address_numeric (SYMBOL_VALUE_ADDRESS (symbol), 1, outfile);
	  fprintf_filtered (outfile, "),");
	  break;

	case LOC_REGISTER:
	  fprintf_filtered (outfile, "register %ld", SYMBOL_VALUE (symbol));
	  break;

	case LOC_ARG:
	  fprintf_filtered (outfile, "arg at offset 0x%lx",
			    SYMBOL_VALUE (symbol));
	  break;

	case LOC_LOCAL_ARG:
	  fprintf_filtered (outfile, "arg at offset 0x%lx from fp",
			    SYMBOL_VALUE (symbol));
	  break;

	case LOC_REF_ARG:
	  fprintf_filtered (outfile, "reference arg at 0x%lx", SYMBOL_VALUE (symbol));
	  break;

	case LOC_REGPARM:
	  fprintf_filtered (outfile, "parameter register %ld", SYMBOL_VALUE (symbol));
	  break;

	case LOC_REGPARM_ADDR:
	  fprintf_filtered (outfile, "address parameter register %ld", SYMBOL_VALUE (symbol));
	  break;

	case LOC_LOCAL:
	  fprintf_filtered (outfile, "local at offset 0x%lx",
			    SYMBOL_VALUE (symbol));
	  break;

	case LOC_BASEREG:
	  fprintf_filtered (outfile, "local at 0x%lx from register %d",
			    SYMBOL_VALUE (symbol), SYMBOL_BASEREG (symbol));
	  break;

	case LOC_BASEREG_ARG:
	  fprintf_filtered (outfile, "arg at 0x%lx from register %d",
			    SYMBOL_VALUE (symbol), SYMBOL_BASEREG (symbol));
	  break;

	case LOC_TYPEDEF:
	  break;

	case LOC_LABEL:
	  fprintf_filtered (outfile, "label at ");
	  print_address_numeric (SYMBOL_VALUE_ADDRESS (symbol), 1, outfile);
	  if (SYMBOL_BFD_SECTION (symbol))
	    fprintf_filtered (outfile, " section %s",
			      bfd_section_name
			      (SYMBOL_BFD_SECTION (symbol)->owner,
			       SYMBOL_BFD_SECTION (symbol)));
	  break;

	case LOC_BLOCK:
	  fprintf_filtered (outfile, "block object ");
	  gdb_print_host_address (SYMBOL_BLOCK_VALUE (symbol), outfile);
	  fprintf_filtered (outfile, ", ");
	  print_address_numeric (BLOCK_START (SYMBOL_BLOCK_VALUE (symbol)),
				 1,
				 outfile);
	  fprintf_filtered (outfile, "..");
	  print_address_numeric (BLOCK_END (SYMBOL_BLOCK_VALUE (symbol)),
				 1,
				 outfile);
	  if (SYMBOL_BFD_SECTION (symbol))
	    fprintf_filtered (outfile, " section %s",
			      bfd_section_name
			      (SYMBOL_BFD_SECTION (symbol)->owner,
			       SYMBOL_BFD_SECTION (symbol)));
	  break;

	case LOC_COMPUTED:
	case LOC_COMPUTED_ARG:
	  fprintf_filtered (outfile, "computed at runtime");
	  break;

	case LOC_UNRESOLVED:
	  fprintf_filtered (outfile, "unresolved");
	  break;

	case LOC_OPTIMIZED_OUT:
	  fprintf_filtered (outfile, "optimized out");
	  break;

	default:
	  fprintf_filtered (outfile, "botched symbol class %x",
			    SYMBOL_CLASS (symbol));
	  break;
	}
    }
  fprintf_filtered (outfile, "\n");
  return 1;
}

void
maintenance_print_psymbols (char *args, int from_tty)
{
  char **argv;
  struct ui_file *outfile;
  struct cleanup *cleanups;
  char *symname = NULL;
  char *filename = DEV_TTY;
  struct objfile *objfile;
  struct partial_symtab *ps;

  dont_repeat ();

  if (args == NULL)
    {
      error ("print-psymbols takes an output file name and optional symbol file name");
    }
  else if ((argv = buildargv (args)) == NULL)
    {
      nomem (0);
    }
  cleanups = make_cleanup_freeargv (argv);

  if (argv[0] != NULL)
    {
      filename = argv[0];
      /* If a second arg is supplied, it is a source file name to match on */
      if (argv[1] != NULL)
	{
	  symname = argv[1];
	}
    }

  filename = tilde_expand (filename);
  make_cleanup (xfree, filename);

  outfile = gdb_fopen (filename, FOPEN_WT);
  if (outfile == 0)
    perror_with_name (filename);
  make_cleanup_ui_file_delete (outfile);

  immediate_quit++;
  ALL_PSYMTABS (objfile, ps)
    if (symname == NULL || strcmp (symname, ps->filename) == 0)
    dump_psymtab (objfile, ps, outfile);
  immediate_quit--;
  do_cleanups (cleanups);
}

static void
print_partial_symbols (struct partial_symbol **p, int count, char *what,
		       struct ui_file *outfile)
{
  fprintf_filtered (outfile, "  %s partial symbols:\n", what);
  while (count-- > 0)
    {
      fprintf_filtered (outfile, "    `%s'", DEPRECATED_SYMBOL_NAME (*p));
      if (SYMBOL_DEMANGLED_NAME (*p) != NULL)
	{
	  fprintf_filtered (outfile, "  `%s'", SYMBOL_DEMANGLED_NAME (*p));
	}
      fputs_filtered (", ", outfile);
      switch (SYMBOL_DOMAIN (*p))
	{
	case UNDEF_DOMAIN:
	  fputs_filtered ("undefined domain, ", outfile);
	  break;
	case VAR_DOMAIN:
	  /* This is the usual thing -- don't print it */
	  break;
	case STRUCT_DOMAIN:
	  fputs_filtered ("struct domain, ", outfile);
	  break;
	case LABEL_DOMAIN:
	  fputs_filtered ("label domain, ", outfile);
	  break;
	default:
	  fputs_filtered ("<invalid domain>, ", outfile);
	  break;
	}
      switch (SYMBOL_CLASS (*p))
	{
	case LOC_UNDEF:
	  fputs_filtered ("undefined", outfile);
	  break;
	case LOC_CONST:
	  fputs_filtered ("constant int", outfile);
	  break;
	case LOC_STATIC:
	  fputs_filtered ("static", outfile);
	  break;
	case LOC_INDIRECT:
	  fputs_filtered ("extern global", outfile);
	  break;
	case LOC_REGISTER:
	  fputs_filtered ("register", outfile);
	  break;
	case LOC_ARG:
	  fputs_filtered ("pass by value", outfile);
	  break;
	case LOC_REF_ARG:
	  fputs_filtered ("pass by reference", outfile);
	  break;
	case LOC_REGPARM:
	  fputs_filtered ("register parameter", outfile);
	  break;
	case LOC_REGPARM_ADDR:
	  fputs_filtered ("register address parameter", outfile);
	  break;
	case LOC_LOCAL:
	  fputs_filtered ("stack parameter", outfile);
	  break;
	case LOC_TYPEDEF:
	  fputs_filtered ("type", outfile);
	  break;
	case LOC_LABEL:
	  fputs_filtered ("label", outfile);
	  break;
	case LOC_BLOCK:
	  fputs_filtered ("function", outfile);
	  break;
	case LOC_CONST_BYTES:
	  fputs_filtered ("constant bytes", outfile);
	  break;
	case LOC_LOCAL_ARG:
	  fputs_filtered ("shuffled arg", outfile);
	  break;
	case LOC_UNRESOLVED:
	  fputs_filtered ("unresolved", outfile);
	  break;
	case LOC_OPTIMIZED_OUT:
	  fputs_filtered ("optimized out", outfile);
	  break;
	case LOC_COMPUTED:
	case LOC_COMPUTED_ARG:
	  fputs_filtered ("computed at runtime", outfile);
	  break;
	default:
	  fputs_filtered ("<invalid location>", outfile);
	  break;
	}
      fputs_filtered (", ", outfile);
      print_address_numeric (SYMBOL_VALUE_ADDRESS (*p), 1, outfile);
      fprintf_filtered (outfile, "\n");
      p++;
    }
}

void
maintenance_print_msymbols (char *args, int from_tty)
{
  char **argv;
  struct ui_file *outfile;
  struct cleanup *cleanups;
  char *filename = DEV_TTY;
  char *symname = NULL;
  struct objfile *objfile;

  dont_repeat ();

  if (args == NULL)
    {
      error ("print-msymbols takes an output file name and optional symbol file name");
    }
  else if ((argv = buildargv (args)) == NULL)
    {
      nomem (0);
    }
  cleanups = make_cleanup_freeargv (argv);

  if (argv[0] != NULL)
    {
      filename = argv[0];
      /* If a second arg is supplied, it is a source file name to match on */
      if (argv[1] != NULL)
	{
	  symname = argv[1];
	}
    }

  filename = tilde_expand (filename);
  make_cleanup (xfree, filename);

  outfile = gdb_fopen (filename, FOPEN_WT);
  if (outfile == 0)
    perror_with_name (filename);
  make_cleanup_ui_file_delete (outfile);

  immediate_quit++;
  ALL_OBJFILES (objfile)
    if (symname == NULL || strcmp (symname, objfile->name) == 0)
    dump_msymbols (objfile, outfile);
  immediate_quit--;
  fprintf_filtered (outfile, "\n\n");
  do_cleanups (cleanups);
}

void
maintenance_print_objfiles (char *ignore, int from_tty)
{
  struct objfile *objfile;

  dont_repeat ();

  immediate_quit++;
  ALL_OBJFILES (objfile)
    dump_objfile (objfile);
  immediate_quit--;
}


/* List all the symbol tables whose names match REGEXP (optional).  */
void
maintenance_info_symtabs (char *regexp, int from_tty)
{
  struct objfile *objfile;

  if (regexp)
    re_comp (regexp);

  ALL_OBJFILES (objfile)
    {
      struct symtab *symtab;
      
      /* We don't want to print anything for this objfile until we
         actually find a symtab whose name matches.  */
      int printed_objfile_start = 0;

      ALL_OBJFILE_SYMTABS (objfile, symtab)
        if (! regexp
            || re_exec (symtab->filename))
          {
            if (! printed_objfile_start)
              {
                printf_filtered ("{ objfile %s ", objfile->name);
                wrap_here ("  ");
                printf_filtered ("((struct objfile *) %p)\n", objfile);
                printed_objfile_start = 1;
              }

            printf_filtered ("  { symtab %s ", symtab->filename);
            wrap_here ("    ");
            printf_filtered ("((struct symtab *) %p)\n", symtab);
            printf_filtered ("    dirname %s\n",
                             symtab->dirname ? symtab->dirname : "(null)");
            printf_filtered ("    fullname %s\n",
                             symtab->fullname ? symtab->fullname : "(null)");
            printf_filtered ("    blockvector ((struct blockvector *) %p)%s\n",
                             symtab->blockvector,
                             symtab->primary ? " (primary)" : "");
            printf_filtered ("    debugformat %s\n", symtab->debugformat);
            printf_filtered ("  }\n");
          }

      if (printed_objfile_start)
        printf_filtered ("}\n");
    }
}


/* List all the partial symbol tables whose names match REGEXP (optional).  */
void
maintenance_info_psymtabs (char *regexp, int from_tty)
{
  struct objfile *objfile;

  if (regexp)
    re_comp (regexp);

  ALL_OBJFILES (objfile)
    {
      struct partial_symtab *psymtab;

      /* We don't want to print anything for this objfile until we
         actually find a symtab whose name matches.  */
      int printed_objfile_start = 0;

      ALL_OBJFILE_PSYMTABS (objfile, psymtab)
        if (! regexp
            || re_exec (psymtab->filename))
          {
            if (! printed_objfile_start)
              {
                printf_filtered ("{ objfile %s ", objfile->name);
                wrap_here ("  ");
                printf_filtered ("((struct objfile *) %p)\n", objfile);
                printed_objfile_start = 1;
              }

            printf_filtered ("  { psymtab %s ", psymtab->filename);
            wrap_here ("    ");
            printf_filtered ("((struct partial_symtab *) %p)\n", psymtab);
            printf_filtered ("    readin %s\n",
                             psymtab->readin ? "yes" : "no");
            printf_filtered ("    fullname %s\n",
                             psymtab->fullname ? psymtab->fullname : "(null)");
            printf_filtered ("    text addresses ");
            print_address_numeric (psymtab->textlow, 1, gdb_stdout);
            printf_filtered (" -- ");
            print_address_numeric (psymtab->texthigh, 1, gdb_stdout);
            printf_filtered ("\n");
            printf_filtered ("    globals ");
            if (psymtab->n_global_syms)
              {
                printf_filtered ("(* (struct partial_symbol **) %p @@ %d)\n",
                                 (psymtab->objfile->global_psymbols.list
                                  + psymtab->globals_offset),
                                 psymtab->n_global_syms);
              }
            else
              printf_filtered ("(none)\n");
            printf_filtered ("    statics ");
            if (psymtab->n_static_syms)
              {
                printf_filtered ("(* (struct partial_symbol **) %p @@ %d)\n",
                                 (psymtab->objfile->static_psymbols.list
                                  + psymtab->statics_offset),
                                 psymtab->n_static_syms);
              }
            else
              printf_filtered ("(none)\n");
            printf_filtered ("    dependencies ");
            if (psymtab->number_of_dependencies)
              {
                int i;

                printf_filtered ("{\n");
                for (i = 0; i < psymtab->number_of_dependencies; i++)
                  {
                    struct partial_symtab *dep = psymtab->dependencies[i];

                    /* Note the string concatenation there --- no comma.  */
                    printf_filtered ("      psymtab %s "
                                     "((struct partial_symtab *) %p)\n",
                                     dep->filename, dep);
                  }
                printf_filtered ("    }\n");
              }
            else
              printf_filtered ("(none)\n");
            printf_filtered ("  }\n");
          }

      if (printed_objfile_start)
        printf_filtered ("}\n");
    }
}


/* Check consistency of psymtabs and symtabs.  */

void
maintenance_check_symtabs (char *ignore, int from_tty)
{
  struct symbol *sym;
  struct partial_symbol **psym;
  struct symtab *s = NULL;
  struct partial_symtab *ps;
  struct blockvector *bv;
  struct objfile *objfile;
  struct block *b;
  int length;

  ALL_PSYMTABS (objfile, ps)
  {
    s = PSYMTAB_TO_SYMTAB (ps);
    if (s == NULL)
      continue;
    bv = BLOCKVECTOR (s);
    b = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
    psym = ps->objfile->static_psymbols.list + ps->statics_offset;
    length = ps->n_static_syms;
    while (length--)
      {
	sym = lookup_block_symbol (b, DEPRECATED_SYMBOL_NAME (*psym),
				   NULL, SYMBOL_DOMAIN (*psym));
	if (!sym)
	  {
	    printf_filtered ("Static symbol `");
	    puts_filtered (DEPRECATED_SYMBOL_NAME (*psym));
	    printf_filtered ("' only found in ");
	    puts_filtered (ps->filename);
	    printf_filtered (" psymtab\n");
	  }
	psym++;
      }
    b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
    psym = ps->objfile->global_psymbols.list + ps->globals_offset;
    length = ps->n_global_syms;
    while (length--)
      {
	sym = lookup_block_symbol (b, DEPRECATED_SYMBOL_NAME (*psym),
				   NULL, SYMBOL_DOMAIN (*psym));
	if (!sym)
	  {
	    printf_filtered ("Global symbol `");
	    puts_filtered (DEPRECATED_SYMBOL_NAME (*psym));
	    printf_filtered ("' only found in ");
	    puts_filtered (ps->filename);
	    printf_filtered (" psymtab\n");
	  }
	psym++;
      }
    if (ps->texthigh < ps->textlow)
      {
	printf_filtered ("Psymtab ");
	puts_filtered (ps->filename);
	printf_filtered (" covers bad range ");
	print_address_numeric (ps->textlow, 1, gdb_stdout);
	printf_filtered (" - ");
	print_address_numeric (ps->texthigh, 1, gdb_stdout);
	printf_filtered ("\n");
	continue;
      }
    if (ps->texthigh == 0)
      continue;
    if (ps->textlow < BLOCK_START (b) || ps->texthigh > BLOCK_END (b))
      {
	printf_filtered ("Psymtab ");
	puts_filtered (ps->filename);
	printf_filtered (" covers ");
	print_address_numeric (ps->textlow, 1, gdb_stdout);
	printf_filtered (" - ");
	print_address_numeric (ps->texthigh, 1, gdb_stdout);
	printf_filtered (" but symtab covers only ");
	print_address_numeric (BLOCK_START (b), 1, gdb_stdout);
	printf_filtered (" - ");
	print_address_numeric (BLOCK_END (b), 1, gdb_stdout);
	printf_filtered ("\n");
      }
  }
}


/* Return the nexting depth of a block within other blocks in its symtab.  */

static int
block_depth (struct block *block)
{
  int i = 0;
  while ((block = BLOCK_SUPERBLOCK (block)) != NULL)
    {
      i++;
    }
  return i;
}


/* Increase the space allocated for LISTP, which is probably
   global_psymbols or static_psymbols. This space will eventually
   be freed in free_objfile().  */

void
extend_psymbol_list (struct psymbol_allocation_list *listp,
		     struct objfile *objfile)
{
  int new_size;
  if (listp->size == 0)
    {
      new_size = 255;
      listp->list = (struct partial_symbol **)
	xmmalloc (objfile->md, new_size * sizeof (struct partial_symbol *));
    }
  else
    {
      new_size = listp->size * 2;
      listp->list = (struct partial_symbol **)
	xmrealloc (objfile->md, (char *) listp->list,
		   new_size * sizeof (struct partial_symbol *));
    }
  /* Next assumes we only went one over.  Should be good if
     program works correctly */
  listp->next = listp->list + listp->size;
  listp->size = new_size;
}


/* Do early runtime initializations. */
void
_initialize_symmisc (void)
{
  std_in = stdin;
  std_out = stdout;
  std_err = stderr;
}
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d102 2
a103 2
      xfree (DEPRECATED_SYMBOL_NAME (sym));
      xfree (sym);
d107 1
a107 1
  xfree (b);
d141 1
a141 1
      xfree (bv);
d149 1
a149 1
	xfree (LINETABLE (s));
d159 1
a159 1
    xfree (s->line_charpos);
d161 1
a161 1
    xfree (s->fullname);
d163 2
a164 2
    xfree (s->debugformat);
  xfree (s);
d1235 1
a1235 1
	xmalloc (new_size * sizeof (struct partial_symbol *));
d1241 2
a1242 2
	xrealloc ((char *) listp->list,
		  new_size * sizeof (struct partial_symbol *));
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 1060
/* Do various things to symbol tables (other than lookup), for GDB.
   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996
   Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "bfd.h"
#include "symfile.h"
#include "objfiles.h"
#include "breakpoint.h"
#include "command.h"
#include "obstack.h"
#include "language.h"
#include "bcache.h"

#include "gdb_string.h"

#ifndef DEV_TTY
#define DEV_TTY "/dev/tty"
#endif

/* Unfortunately for debugging, stderr is usually a macro.  This is painful
   when calling functions that take FILE *'s from the debugger.
   So we make a variable which has the same value and which is accessible when
   debugging GDB with itself.  Because stdin et al need not be constants,
   we initialize them in the _initialize_symmisc function at the bottom
   of the file.  */
FILE *std_in;
FILE *std_out;
FILE *std_err;

/* Prototypes for local functions */

static void 
dump_symtab PARAMS ((struct objfile *, struct symtab *, GDB_FILE *));

static void 
dump_psymtab PARAMS ((struct objfile *, struct partial_symtab *, GDB_FILE *));

static void 
dump_msymbols PARAMS ((struct objfile *, GDB_FILE *));

static void 
dump_objfile PARAMS ((struct objfile *));

static int
block_depth PARAMS ((struct block *));

static void
print_partial_symbols PARAMS ((struct partial_symbol **, int, char *, GDB_FILE *));

struct print_symbol_args {
  struct symbol *symbol;
  int depth;
  GDB_FILE *outfile;
};

static int print_symbol PARAMS ((char *));

static void
free_symtab_block PARAMS ((struct objfile *, struct block *));


/* Free a struct block <- B and all the symbols defined in that block.  */

static void
free_symtab_block (objfile, b)
     struct objfile *objfile;
     struct block *b;
{
  register int i, n;
  n = BLOCK_NSYMS (b);
  for (i = 0; i < n; i++)
    {
      mfree (objfile -> md, SYMBOL_NAME (BLOCK_SYM (b, i)));
      mfree (objfile -> md, (PTR) BLOCK_SYM (b, i));
    }
  mfree (objfile -> md, (PTR) b);
}

/* Free all the storage associated with the struct symtab <- S.
   Note that some symtabs have contents malloc'ed structure by structure,
   while some have contents that all live inside one big block of memory,
   and some share the contents of another symbol table and so you should
   not free the contents on their behalf (except sometimes the linetable,
   which maybe per symtab even when the rest is not).
   It is s->free_code that says which alternative to use.  */

void
free_symtab (s)
     register struct symtab *s;
{
  register int i, n;
  register struct blockvector *bv;

  switch (s->free_code)
    {
    case free_nothing:
      /* All the contents are part of a big block of memory (an obstack),
	 and some other symtab is in charge of freeing that block.
	 Therefore, do nothing.  */
      break;

    case free_contents:
      /* Here all the contents were malloc'ed structure by structure
	 and must be freed that way.  */
      /* First free the blocks (and their symbols.  */
      bv = BLOCKVECTOR (s);
      n = BLOCKVECTOR_NBLOCKS (bv);
      for (i = 0; i < n; i++)
	free_symtab_block (s -> objfile, BLOCKVECTOR_BLOCK (bv, i));
      /* Free the blockvector itself.  */
      mfree (s -> objfile -> md, (PTR) bv);
      /* Also free the linetable.  */
      
    case free_linetable:
      /* Everything will be freed either by our `free_ptr'
	 or by some other symtab, except for our linetable.
	 Free that now.  */
      if (LINETABLE (s))
	mfree (s -> objfile -> md, (PTR) LINETABLE (s));
      break;
    }

  /* If there is a single block of memory to free, free it.  */
  if (s -> free_ptr != NULL)
    mfree (s -> objfile -> md, s -> free_ptr);

  /* Free source-related stuff */
  if (s -> line_charpos != NULL)
    mfree (s -> objfile -> md, (PTR) s -> line_charpos);
  if (s -> fullname != NULL)
    mfree (s -> objfile -> md, s -> fullname);
  mfree (s -> objfile -> md, (PTR) s);
}

#if MAINTENANCE_CMDS

void
print_symbol_bcache_statistics ()
{
  struct objfile *objfile;

  immediate_quit++;
  ALL_OBJFILES (objfile)
    {
      printf_filtered ("Byte cache statistics for '%s':\n", objfile -> name);
      print_bcache_statistics (&objfile -> psymbol_cache, "partial symbol cache");
    }
  immediate_quit--;
}

void
print_objfile_statistics ()
{
  struct objfile *objfile;

  immediate_quit++;
  ALL_OBJFILES (objfile)
    {
      printf_filtered ("Statistics for '%s':\n", objfile -> name);
      if (OBJSTAT (objfile, n_stabs) > 0)
	printf_filtered ("  Number of \"stab\" symbols read: %d\n",
			 OBJSTAT (objfile, n_stabs));
      if (OBJSTAT (objfile, n_minsyms) > 0)
	printf_filtered ("  Number of \"minimal symbols read: %d\n",
			 OBJSTAT (objfile, n_minsyms));
      if (OBJSTAT (objfile, n_psyms) > 0)
	printf_filtered ("  Number of \"partial symbols read: %d\n",
			 OBJSTAT (objfile, n_psyms));
      if (OBJSTAT (objfile, n_syms) > 0)
	printf_filtered ("  Number of \"full symbols read: %d\n",
			 OBJSTAT (objfile, n_syms));
      if (OBJSTAT (objfile, n_types) > 0)
	printf_filtered ("  Number of \"types defined: %d\n",
			 OBJSTAT (objfile, n_types));
      if (OBJSTAT (objfile, sz_strtab) > 0)
	printf_filtered ("  Space used by a.out string tables: %d\n",
			 OBJSTAT (objfile, sz_strtab));
      printf_filtered ("  Total memory used for psymbol obstack: %d\n",
		       obstack_memory_used (&objfile -> psymbol_obstack));
      printf_filtered ("  Total memory used for psymbol cache: %d\n",
		       obstack_memory_used (&objfile -> psymbol_cache.cache));
      printf_filtered ("  Total memory used for symbol obstack: %d\n",
		       obstack_memory_used (&objfile -> symbol_obstack));
      printf_filtered ("  Total memory used for type obstack: %d\n",
		       obstack_memory_used (&objfile -> type_obstack));
    }
  immediate_quit--;
}

static void 
dump_objfile (objfile)
     struct objfile *objfile;
{
  struct symtab *symtab;
  struct partial_symtab *psymtab;

  printf_filtered ("\nObject file %s:  ", objfile -> name);
  printf_filtered ("Objfile at ");
  gdb_print_address (objfile, gdb_stdout);
  printf_filtered (", bfd at ");
  gdb_print_address (objfile->obfd, gdb_stdout);
  printf_filtered (", %d minsyms\n\n",
		   objfile->minimal_symbol_count);

  if (objfile -> psymtabs)
    {
      printf_filtered ("Psymtabs:\n");
      for (psymtab = objfile -> psymtabs;
	   psymtab != NULL;
	   psymtab = psymtab -> next)
	{
	  printf_filtered ("%s at ",
			   psymtab -> filename);
	  gdb_print_address (psymtab, gdb_stdout);
	  printf_filtered (", ");
	  if (psymtab -> objfile != objfile)
	    {
	      printf_filtered ("NOT ON CHAIN!  ");
	    }
	  wrap_here ("  ");
	}
      printf_filtered ("\n\n");
    }

  if (objfile -> symtabs)
    {
      printf_filtered ("Symtabs:\n");
      for (symtab = objfile -> symtabs;
	   symtab != NULL;
	   symtab = symtab->next)
	{
	  printf_filtered ("%s at ", symtab -> filename);
	  gdb_print_address (symtab, gdb_stdout);
	  printf_filtered (", ");
	  if (symtab -> objfile != objfile)
	    {
	      printf_filtered ("NOT ON CHAIN!  ");
	    }
	  wrap_here ("  ");
	}
      printf_filtered ("\n\n");
    }
}

/* Print minimal symbols from this objfile.  */
 
static void 
dump_msymbols (objfile, outfile)
     struct objfile *objfile;
     GDB_FILE *outfile;
{
  struct minimal_symbol *msymbol;
  int index;
  char ms_type;
  
  fprintf_filtered (outfile, "\nObject file %s:\n\n", objfile -> name);
  if (objfile -> minimal_symbol_count == 0)
    {
      fprintf_filtered (outfile, "No minimal symbols found.\n");
      return;
    }
  for (index = 0, msymbol = objfile -> msymbols;
       SYMBOL_NAME (msymbol) != NULL; msymbol++, index++)
    {
      switch (msymbol -> type)
	{
	  case mst_unknown:
	    ms_type = 'u';
	    break;
	  case mst_text:
	    ms_type = 'T';
	    break;
	  case mst_solib_trampoline:
	    ms_type = 'S';
	    break;
	  case mst_data:
	    ms_type = 'D';
	    break;
	  case mst_bss:
	    ms_type = 'B';
	    break;
	  case mst_abs:
	    ms_type = 'A';
	    break;
	  case mst_file_text:
	    ms_type = 't';
	    break;
	  case mst_file_data:
	    ms_type = 'd';
	    break;
	  case mst_file_bss:
	    ms_type = 'b';
	    break;
	  default:
	    ms_type = '?';
	    break;
	}
      fprintf_filtered (outfile, "[%2d] %c %#10lx %s", index, ms_type,
			SYMBOL_VALUE_ADDRESS (msymbol), SYMBOL_NAME (msymbol));
      if (SYMBOL_DEMANGLED_NAME (msymbol) != NULL)
	{
	  fprintf_filtered (outfile, "  %s", SYMBOL_DEMANGLED_NAME (msymbol));
	}
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
      if (msymbol->filename)
	fprintf_filtered (outfile, "  %s", msymbol->filename);
#endif
      fputs_filtered ("\n", outfile);
    }
  if (objfile -> minimal_symbol_count != index)
    {
      warning ("internal error:  minimal symbol count %d != %d",
	       objfile -> minimal_symbol_count, index);
    }
  fprintf_filtered (outfile, "\n");
}

static void
dump_psymtab (objfile, psymtab, outfile)
     struct objfile *objfile;
     struct partial_symtab *psymtab;
     GDB_FILE *outfile;
{
  int i;

  fprintf_filtered (outfile, "\nPartial symtab for source file %s ",
		    psymtab -> filename);
  fprintf_filtered (outfile, "(object ");
  gdb_print_address (psymtab, outfile);
  fprintf_filtered (outfile, ")\n\n");
  fprintf_unfiltered (outfile, "  Read from object file %s (",
		      objfile -> name);
  gdb_print_address (objfile, outfile);
  fprintf_unfiltered (outfile, ")\n");

  if (psymtab -> readin)
    {
      fprintf_filtered (outfile,
		"  Full symtab was read (at ");
      gdb_print_address (psymtab->symtab, outfile);
      fprintf_filtered (outfile, " by function at ");
      gdb_print_address ((PTR)psymtab->read_symtab, outfile);
      fprintf_filtered (outfile, ")\n");
    }

  fprintf_filtered (outfile, "  Relocate symbols by ");
  for (i = 0; i < psymtab->objfile->num_sections; ++i)
    {
      if (i != 0)
	fprintf_filtered (outfile, ", ");
      wrap_here ("    ");
      print_address_numeric (ANOFFSET (psymtab->section_offsets, i),
			     1,
			     outfile);
    }
  fprintf_filtered (outfile, "\n");

  fprintf_filtered (outfile, "  Symbols cover text addresses ");
  print_address_numeric (psymtab->textlow, 1, outfile);
  fprintf_filtered (outfile, "-");
  print_address_numeric (psymtab->texthigh, 1, outfile);
  fprintf_filtered (outfile, "\n");
  fprintf_filtered (outfile, "  Depends on %d other partial symtabs.\n",
		    psymtab -> number_of_dependencies);
  for (i = 0; i < psymtab -> number_of_dependencies; i++)
    {
      fprintf_filtered (outfile, "    %d ", i);
      gdb_print_address (psymtab -> dependencies[i], outfile);
      fprintf_filtered (outfile, " %s\n",
			psymtab -> dependencies[i] -> filename);
    }
  if (psymtab -> n_global_syms > 0)
    {
      print_partial_symbols (objfile -> global_psymbols.list
			    + psymtab -> globals_offset,
			    psymtab -> n_global_syms, "Global", outfile);
    }
  if (psymtab -> n_static_syms > 0)
    {
      print_partial_symbols (objfile -> static_psymbols.list
			    + psymtab -> statics_offset,
			    psymtab -> n_static_syms, "Static", outfile);
    }
  fprintf_filtered (outfile, "\n");
}

static void 
dump_symtab (objfile, symtab, outfile)
     struct objfile *objfile;
     struct symtab *symtab;
     GDB_FILE *outfile;
{
  register int i, j;
  int len, blen;
  register struct linetable *l;
  struct blockvector *bv;
  register struct block *b;
  int depth;

  fprintf_filtered (outfile, "\nSymtab for file %s\n", symtab->filename);
  fprintf_filtered (outfile, "Read from object file %s (", objfile->name);
  gdb_print_address (objfile, outfile);
  fprintf_filtered (outfile, ")\n");
  fprintf_filtered (outfile, "Language: %s\n", language_str (symtab -> language));

  /* First print the line table.  */
  l = LINETABLE (symtab);
  if (l)
    {
      fprintf_filtered (outfile, "\nLine table:\n\n");
      len = l->nitems;
      for (i = 0; i < len; i++)
	{
	  fprintf_filtered (outfile, " line %d at ", l->item[i].line);
	  print_address_numeric (l->item[i].pc, 1, outfile);
	  fprintf_filtered (outfile, "\n");
	}
    }
  /* Now print the block info, but only for primary symtabs since we will
     print lots of duplicate info otherwise. */
  if (symtab -> primary)
    {
      fprintf_filtered (outfile, "\nBlockvector:\n\n");
      bv = BLOCKVECTOR (symtab);
      len = BLOCKVECTOR_NBLOCKS (bv);
      for (i = 0; i < len; i++)
	{
	  b = BLOCKVECTOR_BLOCK (bv, i);
	  depth = block_depth (b) * 2;
	  print_spaces (depth, outfile);
	  fprintf_filtered (outfile, "block #%03d, object at ", i);
	  gdb_print_address (b, outfile);
	  if (BLOCK_SUPERBLOCK (b))
	    {
	      fprintf_filtered (outfile, " under ");
	      gdb_print_address (BLOCK_SUPERBLOCK (b), outfile);
	    }
	  blen = BLOCK_NSYMS (b);
	  fprintf_filtered (outfile, ", %d syms in ", blen);
	  print_address_numeric (BLOCK_START (b), 1, outfile);
	  fprintf_filtered (outfile, "..");
	  print_address_numeric (BLOCK_END (b), 1, outfile);
	  if (BLOCK_FUNCTION (b))
	    {
	      fprintf_filtered (outfile, ", function %s", SYMBOL_NAME (BLOCK_FUNCTION (b)));
	      if (SYMBOL_DEMANGLED_NAME (BLOCK_FUNCTION (b)) != NULL)
		{
		  fprintf_filtered (outfile, ", %s",
				    SYMBOL_DEMANGLED_NAME (BLOCK_FUNCTION (b)));
		}
	    }
	  if (BLOCK_GCC_COMPILED(b))
	    fprintf_filtered (outfile, ", compiled with gcc%d", BLOCK_GCC_COMPILED(b));
	  fprintf_filtered (outfile, "\n");
	  /* Now print each symbol in this block */
	  for (j = 0; j < blen; j++)
	    {
	      struct print_symbol_args s;
	      s.symbol = BLOCK_SYM (b, j);
	      s.depth = depth + 1;
	      s.outfile = outfile;
	      catch_errors (print_symbol, &s, "Error printing symbol:\n",
			    RETURN_MASK_ALL);
	    }
	}
      fprintf_filtered (outfile, "\n");
    }
  else
    {
      fprintf_filtered (outfile, "\nBlockvector same as previous symtab\n\n");
    }
}

void
maintenance_print_symbols (args, from_tty)
     char *args;
     int from_tty;
{
  char **argv;
  GDB_FILE *outfile;
  struct cleanup *cleanups;
  char *symname = NULL;
  char *filename = DEV_TTY;
  struct objfile *objfile;
  struct symtab *s;

  dont_repeat ();

  if (args == NULL)
    {
      error ("\
Arguments missing: an output file name and an optional symbol file name");
    }
  else if ((argv = buildargv (args)) == NULL)
    {
      nomem (0);
    }
  cleanups = make_cleanup (freeargv, (char *) argv);

  if (argv[0] != NULL)
    {
      filename = argv[0];
      /* If a second arg is supplied, it is a source file name to match on */
      if (argv[1] != NULL)
	{
	  symname = argv[1];
	}
    }

  filename = tilde_expand (filename);
  make_cleanup (free, filename);
  
  outfile = gdb_fopen (filename, FOPEN_WT);
  if (outfile == 0)
    perror_with_name (filename);
  make_cleanup (fclose, (char *) outfile);

  immediate_quit++;
  ALL_SYMTABS (objfile, s)
    if (symname == NULL || (STREQ (symname, s -> filename)))
      dump_symtab (objfile, s, outfile);
  immediate_quit--;
  do_cleanups (cleanups);
}

/* Print symbol ARGS->SYMBOL on ARGS->OUTFILE.  ARGS->DEPTH says how
   far to indent.  ARGS is really a struct print_symbol_args *, but is
   declared as char * to get it past catch_errors.  Returns 0 for error,
   1 for success.  */

static int
print_symbol (args)
     char *args;
{
  struct symbol *symbol = ((struct print_symbol_args *)args)->symbol;
  int depth = ((struct print_symbol_args *)args)->depth;
  GDB_FILE *outfile = ((struct print_symbol_args *)args)->outfile;

  print_spaces (depth, outfile);
  if (SYMBOL_NAMESPACE (symbol) == LABEL_NAMESPACE)
    {
      fprintf_filtered (outfile, "label %s at ", SYMBOL_SOURCE_NAME (symbol));
      print_address_numeric (SYMBOL_VALUE_ADDRESS (symbol), 1, outfile);
      fprintf_filtered (outfile, "\n");
      return 1;
    }
  if (SYMBOL_NAMESPACE (symbol) == STRUCT_NAMESPACE)
    {
      if (TYPE_TAG_NAME (SYMBOL_TYPE (symbol)))
	{
	  LA_PRINT_TYPE (SYMBOL_TYPE (symbol), "", outfile, 1, depth);
	}
      else
	{
	  fprintf_filtered (outfile, "%s %s = ",
	       (TYPE_CODE (SYMBOL_TYPE (symbol)) == TYPE_CODE_ENUM
		? "enum"
		: (TYPE_CODE (SYMBOL_TYPE (symbol)) == TYPE_CODE_STRUCT
		   ? "struct" : "union")),
	       SYMBOL_NAME (symbol));
	  LA_PRINT_TYPE (SYMBOL_TYPE (symbol), "", outfile, 1, depth);
	}
      fprintf_filtered (outfile, ";\n");
    }
  else
    {
      if (SYMBOL_CLASS (symbol) == LOC_TYPEDEF)
	fprintf_filtered (outfile, "typedef ");
      if (SYMBOL_TYPE (symbol))
	{
	  /* Print details of types, except for enums where it's clutter.  */
	  LA_PRINT_TYPE (SYMBOL_TYPE (symbol), SYMBOL_SOURCE_NAME (symbol),
			 outfile,
			 TYPE_CODE (SYMBOL_TYPE (symbol)) != TYPE_CODE_ENUM,
			 depth);
	  fprintf_filtered (outfile, "; ");
	}
      else
	fprintf_filtered (outfile, "%s ", SYMBOL_SOURCE_NAME (symbol));

      switch (SYMBOL_CLASS (symbol))
	{
	case LOC_CONST:
	  fprintf_filtered (outfile, "const %ld (0x%lx)",
			    SYMBOL_VALUE (symbol),
			    SYMBOL_VALUE (symbol));
	  break;

	case LOC_CONST_BYTES:
	  {
	    unsigned i;
	    struct type *type = check_typedef (SYMBOL_TYPE (symbol));
	    fprintf_filtered (outfile, "const %u hex bytes:",
			      TYPE_LENGTH (type));
	    for (i = 0; i < TYPE_LENGTH (type); i++)
	      fprintf_filtered (outfile, " %02x",
				(unsigned)SYMBOL_VALUE_BYTES (symbol) [i]);
	  }
	  break;

	case LOC_STATIC:
	  fprintf_filtered (outfile, "static at ");
	  print_address_numeric (SYMBOL_VALUE_ADDRESS (symbol), 1,outfile);
	  break;

	case LOC_REGISTER:
	  fprintf_filtered (outfile, "register %ld", SYMBOL_VALUE (symbol));
	  break;

	case LOC_ARG:
	  fprintf_filtered (outfile, "arg at offset 0x%lx",
			    SYMBOL_VALUE (symbol));
	  break;

	case LOC_LOCAL_ARG:
	  fprintf_filtered (outfile, "arg at offset 0x%lx from fp",
		   SYMBOL_VALUE (symbol));
	  break;

	case LOC_REF_ARG:
	  fprintf_filtered (outfile, "reference arg at 0x%lx", SYMBOL_VALUE (symbol));
	  break;

	case LOC_REGPARM:
	  fprintf_filtered (outfile, "parameter register %ld", SYMBOL_VALUE (symbol));
	  break;

	case LOC_REGPARM_ADDR:
	  fprintf_filtered (outfile, "address parameter register %ld", SYMBOL_VALUE (symbol));
	  break;

	case LOC_LOCAL:
	  fprintf_filtered (outfile, "local at offset 0x%lx",
			    SYMBOL_VALUE (symbol));
	  break;

	case LOC_BASEREG:
	  fprintf_filtered (outfile, "local at 0x%lx from register %d",
		   SYMBOL_VALUE (symbol), SYMBOL_BASEREG (symbol));
	  break;

	case LOC_BASEREG_ARG:
	  fprintf_filtered (outfile, "arg at 0x%lx from register %d",
		   SYMBOL_VALUE (symbol), SYMBOL_BASEREG (symbol));
	  break;

	case LOC_TYPEDEF:
	  break;

	case LOC_LABEL:
	  fprintf_filtered (outfile, "label at ");
	  print_address_numeric (SYMBOL_VALUE_ADDRESS (symbol), 1, outfile);
	  break;

	case LOC_BLOCK:
	  fprintf_filtered (outfile, "block object ");
	  gdb_print_address (SYMBOL_BLOCK_VALUE (symbol), outfile);
	  fprintf_filtered (outfile, ", ");
	  print_address_numeric (BLOCK_START (SYMBOL_BLOCK_VALUE (symbol)),
				 1,
				 outfile);
	  fprintf_filtered (outfile, "..");
	  print_address_numeric (BLOCK_END (SYMBOL_BLOCK_VALUE (symbol)),
				 1,
				 outfile);
	  break;

	case LOC_UNRESOLVED:
	  fprintf_filtered (outfile, "unresolved");
	  break;

	case LOC_OPTIMIZED_OUT:
	  fprintf_filtered (outfile, "optimized out");
	  break;

        default:
	  fprintf_filtered (outfile, "botched symbol class %x",
			    SYMBOL_CLASS (symbol));
	  break;
	}
    }
  fprintf_filtered (outfile, "\n");
  return 1;
}

void
maintenance_print_psymbols (args, from_tty)
     char *args;
     int from_tty;
{
  char **argv;
  GDB_FILE *outfile;
  struct cleanup *cleanups;
  char *symname = NULL;
  char *filename = DEV_TTY;
  struct objfile *objfile;
  struct partial_symtab *ps;

  dont_repeat ();

  if (args == NULL)
    {
      error ("print-psymbols takes an output file name and optional symbol file name");
    }
  else if ((argv = buildargv (args)) == NULL)
    {
      nomem (0);
    }
  cleanups = make_cleanup (freeargv, (char *) argv);

  if (argv[0] != NULL)
    {
      filename = argv[0];
      /* If a second arg is supplied, it is a source file name to match on */
      if (argv[1] != NULL)
	{
	  symname = argv[1];
	}
    }

  filename = tilde_expand (filename);
  make_cleanup (free, filename);
  
  outfile = gdb_fopen (filename, FOPEN_WT);
  if (outfile == 0)
    perror_with_name (filename);
  make_cleanup (fclose, outfile);

  immediate_quit++;
  ALL_PSYMTABS (objfile, ps)
    if (symname == NULL || (STREQ (symname, ps -> filename)))
      dump_psymtab (objfile, ps, outfile);
  immediate_quit--;
  do_cleanups (cleanups);
}

static void
print_partial_symbols (p, count, what, outfile)
     struct partial_symbol **p;
     int count;
     char *what;
     GDB_FILE *outfile;
{
  fprintf_filtered (outfile, "  %s partial symbols:\n", what);
  while (count-- > 0)
    {
      fprintf_filtered (outfile, "    `%s'", SYMBOL_NAME(*p));
      if (SYMBOL_DEMANGLED_NAME (*p) != NULL)
	{
	  fprintf_filtered (outfile, "  `%s'", SYMBOL_DEMANGLED_NAME (*p));
	}
      fputs_filtered (", ", outfile);
      switch (SYMBOL_NAMESPACE (*p))
	{
	case UNDEF_NAMESPACE:
	  fputs_filtered ("undefined namespace, ", outfile);
	  break;
	case VAR_NAMESPACE:
	  /* This is the usual thing -- don't print it */
	  break;
	case STRUCT_NAMESPACE:
	  fputs_filtered ("struct namespace, ", outfile);
	  break;
	case LABEL_NAMESPACE:
	  fputs_filtered ("label namespace, ", outfile);
	  break;
	default:
	  fputs_filtered ("<invalid namespace>, ", outfile);
	  break;
	}
      switch (SYMBOL_CLASS (*p))
	{
	case LOC_UNDEF:
	  fputs_filtered ("undefined", outfile);
	  break;
	case LOC_CONST:
	  fputs_filtered ("constant int", outfile);
	  break;
	case LOC_STATIC:
	  fputs_filtered ("static", outfile);
	  break;
	case LOC_REGISTER:
	  fputs_filtered ("register", outfile);
	  break;
	case LOC_ARG:
	  fputs_filtered ("pass by value", outfile);
	  break;
	case LOC_REF_ARG:
	  fputs_filtered ("pass by reference", outfile);
	  break;
	case LOC_REGPARM:
	  fputs_filtered ("register parameter", outfile);
	  break;
	case LOC_REGPARM_ADDR:
	  fputs_filtered ("register address parameter", outfile);
	  break;
	case LOC_LOCAL:
	  fputs_filtered ("stack parameter", outfile);
	  break;
	case LOC_TYPEDEF:
	  fputs_filtered ("type", outfile);
	  break;
	case LOC_LABEL:
	  fputs_filtered ("label", outfile);
	  break;
	case LOC_BLOCK:
	  fputs_filtered ("function", outfile);
	  break;
	case LOC_CONST_BYTES:
	  fputs_filtered ("constant bytes", outfile);
	  break;
	case LOC_LOCAL_ARG:
	  fputs_filtered ("shuffled arg", outfile);
	  break;
	case LOC_UNRESOLVED:
	  fputs_filtered ("unresolved", outfile);
	  break;
	case LOC_OPTIMIZED_OUT:
	  fputs_filtered ("optimized out", outfile);
	  break;
	default:
	  fputs_filtered ("<invalid location>", outfile);
	  break;
	}
      fputs_filtered (", ", outfile);
      /* FIXME-32x64: Need to use SYMBOL_VALUE_ADDRESS, etc.; this
	 could be 32 bits when some of the other fields in the union
	 are 64.  */
      fprintf_filtered (outfile, "0x%lx\n", SYMBOL_VALUE (*p));
      p++;
    }
}

void
maintenance_print_msymbols (args, from_tty)
     char *args;
     int from_tty;
{
  char **argv;
  GDB_FILE *outfile;
  struct cleanup *cleanups;
  char *filename = DEV_TTY;
  char *symname = NULL;
  struct objfile *objfile;

  dont_repeat ();

  if (args == NULL)
    {
      error ("print-msymbols takes an output file name and optional symbol file name");
    }
  else if ((argv = buildargv (args)) == NULL)
    {
      nomem (0);
    }
  cleanups = make_cleanup (freeargv, argv);

  if (argv[0] != NULL)
    {
      filename = argv[0];
      /* If a second arg is supplied, it is a source file name to match on */
      if (argv[1] != NULL)
	{
	  symname = argv[1];
	}
    }

  filename = tilde_expand (filename);
  make_cleanup (free, filename);
  
  outfile = gdb_fopen (filename, FOPEN_WT);
  if (outfile == 0)
    perror_with_name (filename);
  make_cleanup (fclose, outfile);

  immediate_quit++;
  ALL_OBJFILES (objfile)
    if (symname == NULL || (STREQ (symname, objfile -> name)))
      dump_msymbols (objfile, outfile);
  immediate_quit--;
  fprintf_filtered (outfile, "\n\n");
  do_cleanups (cleanups);
}

void
maintenance_print_objfiles (ignore, from_tty)
     char *ignore;
     int from_tty;
{
  struct objfile *objfile;

  dont_repeat ();

  immediate_quit++;
  ALL_OBJFILES (objfile)
    dump_objfile (objfile);
  immediate_quit--;
}

/* Check consistency of psymtabs and symtabs.  */

void
maintenance_check_symtabs (ignore, from_tty)
     char *ignore;
     int from_tty;
{
  register struct symbol *sym;
  register struct partial_symbol **psym;
  register struct symtab *s = NULL;
  register struct partial_symtab *ps;
  struct blockvector *bv;
  register struct objfile *objfile;
  register struct block *b;
  int length;

  ALL_PSYMTABS (objfile, ps)
    {
      s = PSYMTAB_TO_SYMTAB(ps);
      if (s == NULL)
	continue;
      bv = BLOCKVECTOR (s);
      b = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
      psym = ps->objfile->static_psymbols.list + ps->statics_offset;
      length = ps->n_static_syms;
      while (length--)
	{
	  sym = lookup_block_symbol (b, SYMBOL_NAME (*psym),
				     SYMBOL_NAMESPACE (*psym));
	  if (!sym)
	    {
	      printf_filtered ("Static symbol `");
	      puts_filtered (SYMBOL_NAME (*psym));
	      printf_filtered ("' only found in ");
	      puts_filtered (ps->filename);
	      printf_filtered (" psymtab\n");
	    }
	  psym++;
	}
      b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
      psym = ps->objfile->global_psymbols.list + ps->globals_offset;
      length = ps->n_global_syms;
      while (length--)
	{
	  sym = lookup_block_symbol (b, SYMBOL_NAME (*psym),
				     SYMBOL_NAMESPACE (*psym));
	  if (!sym)
	    {
	      printf_filtered ("Global symbol `");
	      puts_filtered (SYMBOL_NAME (*psym));
	      printf_filtered ("' only found in ");
	      puts_filtered (ps->filename);
	      printf_filtered (" psymtab\n");
	    }
	  psym++;
	}
      if (ps->texthigh < ps->textlow)
	{
	  printf_filtered ("Psymtab ");
	  puts_filtered (ps->filename);
	  printf_filtered (" covers bad range ");
          print_address_numeric (ps->textlow, 1, stdout);
	  printf_filtered (" - ");
          print_address_numeric (ps->texthigh, 1, stdout);
	  printf_filtered ("\n");
	  continue;
	}
      if (ps->texthigh == 0)
	continue;
      if (ps->textlow < BLOCK_START (b) || ps->texthigh > BLOCK_END (b))
	{
	  printf_filtered ("Psymtab ");
	  puts_filtered (ps->filename);
	  printf_filtered (" covers ");
          print_address_numeric (ps->textlow, 1, stdout);
	  printf_filtered (" - ");
          print_address_numeric (ps->texthigh, 1, stdout);
	  printf_filtered (" but symtab covers only ");
          print_address_numeric (BLOCK_START (b), 1, stdout);
	  printf_filtered (" - ");
          print_address_numeric (BLOCK_END (b), 1, stdout);
	  printf_filtered ("\n");
	}
    }
}


/* Return the nexting depth of a block within other blocks in its symtab.  */

static int
block_depth (block)
     struct block *block;
{
  register int i = 0;
  while ((block = BLOCK_SUPERBLOCK (block)) != NULL) 
    {
      i++;
    }
  return i;
}

#endif	/* MAINTENANCE_CMDS */


/* Increase the space allocated for LISTP, which is probably
   global_psymbols or static_psymbols. This space will eventually
   be freed in free_objfile().  */

void
extend_psymbol_list (listp, objfile)
     register struct psymbol_allocation_list *listp;
     struct objfile *objfile;
{
  int new_size;
  if (listp->size == 0)
    {
      new_size = 255;
      listp->list = (struct partial_symbol **)
	xmmalloc (objfile -> md, new_size * sizeof (struct partial_symbol *));
    }
  else
    {
      new_size = listp->size * 2;
      listp->list = (struct partial_symbol **)
	xmrealloc (objfile -> md, (char *) listp->list,
		   new_size * sizeof (struct partial_symbol *));
    }
  /* Next assumes we only went one over.  Should be good if
     program works correctly */
  listp->next = listp->list + listp->size;
  listp->size = new_size;
}


/* Do early runtime initializations. */
void
_initialize_symmisc ()
{
  std_in  = stdin;
  std_out = stdout;
  std_err = stderr;
}
@
