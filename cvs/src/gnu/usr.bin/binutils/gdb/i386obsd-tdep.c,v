head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.2
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.8.0.22
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.18
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.14
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.16
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.8
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.12
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.10
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.6
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.10
	OPENBSD_5_0:1.7.0.8
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.6
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.6.0.18
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.14
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.12
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.10
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.8
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.6
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.4
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.1.1.2.0.2
	OPENBSD_3_7_BASE:1.1.1.2
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.1.1.1.0.2
	OPENBSD_3_6_BASE:1.1.1.1
	GDB_6_1:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2017.04.09.21.32.42;	author guenther;	state Exp;
branches;
next	1.8;
commitid	BkFvdgRlXSYVnmLL;

1.8
date	2012.07.12.08.57.35;	author bluhm;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.24.02.28.17;	author kurt;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.26.14.47.56;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.22.19.47.44;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.21.15.15.08;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.03.10.37.43;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2005.07.26.20.29.55;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.21.19.11.10;	author kettenis;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.05.21.19.11.10;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.12.17;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Sync symbol lists for trap/interrupt frame detection with what ddb(4) uses

ok deraadt@@
@
text
@/* Target-dependent code for OpenBSD/i386.

   Copyright 1988, 1989, 1991, 1992, 1994, 1996, 2000, 2001, 2002,
   2003, 2004, 2005
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "arch-utils.h"
#include "frame.h"
#include "frame-unwind.h"
#include "gdbcore.h"
#include "regcache.h"
#include "regset.h"
#include "symtab.h"
#include "objfiles.h"
#include "osabi.h"
#include "target.h"
#include "trad-frame.h"

#include "gdb_assert.h"
#include "gdb_string.h"

#include "i386-tdep.h"
#include "i387-tdep.h"
#include "solib-svr4.h"
#include "bsd-uthread.h"

/* Support for signal handlers.  */

/* Since OpenBSD 3.2, the sigtramp routine is mapped at a random page
   in virtual memory.  The randomness makes it somewhat tricky to
   detect it, but fortunately we can rely on the fact that the start
   of the sigtramp routine is page-aligned.  By the way, the mapping
   is read-only, so you cannot place a breakpoint in the signal
   trampoline.  */

/* Default page size.  */
static const int i386obsd_page_size = 4096;

/* Offset for sigreturn(2).  */
static const int i386obsd_sigreturn_offset[] = {
  0x0a,				/* OpenBSD 3.2 */
  0x14,				/* OpenBSD 3.6 */
  0x3a,				/* OpenBSD 3.8 */
  -1
};

/* Return whether the frame preceding NEXT_FRAME corresponds to an
   OpenBSD sigtramp routine.  */

static int
i386obsd_sigtramp_p (struct frame_info *next_frame)
{
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  CORE_ADDR start_pc = (pc & ~(i386obsd_page_size - 1));
  const char sigreturn[] =
  {
    0xb8,
    0x67, 0x00, 0x00, 0x00,	/* movl $SYS_sigreturn, %eax */
    0xcd, 0x80			/* int $0x80 */
  };
  size_t buflen = sizeof sigreturn;
  const int *offset;
  char *name, *buf;

  /* If the function has a valid symbol name, it isn't a
     trampoline.  */
  find_pc_partial_function (pc, &name, NULL, NULL);
  if (name != NULL)
    return 0;

  /* If the function lives in a valid section (even without a starting
     point) it isn't a trampoline.  */
  if (find_pc_section (pc) != NULL)
    return 0;

  /* Allocate buffer.  */
  buf = alloca (buflen);

  /* Loop over all offsets.  */
  for (offset = i386obsd_sigreturn_offset; *offset != -1; offset++)
    {
      /* If we can't read the instructions, return zero.  */
      if (!safe_frame_unwind_memory (next_frame, start_pc + *offset,
				     buf, buflen))
	return 0;

      /* Check for sigreturn(2).  */
      if (memcmp (buf, sigreturn, buflen) == 0)
	return 1;
    }

  return 0;
}

/* Mapping between the general-purpose registers in `struct reg'
   format and GDB's register cache layout.  */

/* From <machine/reg.h>.  */
static int i386obsd_r_reg_offset[] =
{
  0 * 4,			/* %eax */
  1 * 4,			/* %ecx */
  2 * 4,			/* %edx */
  3 * 4,			/* %ebx */
  4 * 4,			/* %esp */
  5 * 4,			/* %ebp */
  6 * 4,			/* %esi */
  7 * 4,			/* %edi */
  8 * 4,			/* %eip */
  9 * 4,			/* %eflags */
  10 * 4,			/* %cs */
  11 * 4,			/* %ss */
  12 * 4,			/* %ds */
  13 * 4,			/* %es */
  14 * 4,			/* %fs */
  15 * 4			/* %gs */
};

static void
i386obsd_aout_supply_regset (const struct regset *regset,
			     struct regcache *regcache, int regnum,
			     const void *regs, size_t len)
{
  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);

  gdb_assert (len >= tdep->sizeof_gregset + I387_SIZEOF_FSAVE);

  i386_supply_gregset (regset, regcache, regnum, regs, tdep->sizeof_gregset);
  i387_supply_fsave (regcache, regnum, (char *) regs + tdep->sizeof_gregset);
}

static const struct regset *
i386obsd_aout_regset_from_core_section (struct gdbarch *gdbarch,
					const char *sect_name,
					size_t sect_size)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* OpenBSD a.out core dumps don't use seperate register sets for the
     general-purpose and floating-point registers.  */

  if (strcmp (sect_name, ".reg") == 0
      && sect_size >= tdep->sizeof_gregset + I387_SIZEOF_FSAVE)
    {
      if (tdep->gregset == NULL)
        tdep->gregset =
	  regset_alloc (gdbarch, i386obsd_aout_supply_regset, NULL);
      return tdep->gregset;
    }

  return NULL;
}


/* Sigtramp routine location for OpenBSD 3.1 and earlier releases.  */
CORE_ADDR i386obsd_sigtramp_start_addr = 0xbfbfdf20;
CORE_ADDR i386obsd_sigtramp_end_addr = 0xbfbfdff0;

/* From <machine/signal.h>.  */
int i386obsd_sc_reg_offset[I386_NUM_GREGS] =
{
  10 * 4,			/* %eax */
  9 * 4,			/* %ecx */
  8 * 4,			/* %edx */
  7 * 4,			/* %ebx */
  14 * 4,			/* %esp */
  6 * 4,			/* %ebp */
  5 * 4,			/* %esi */
  4 * 4,			/* %edi */
  11 * 4,			/* %eip */
  13 * 4,			/* %eflags */
  12 * 4,			/* %cs */
  15 * 4,			/* %ss */
  3 * 4,			/* %ds */
  2 * 4,			/* %es */
  1 * 4,			/* %fs */
  0 * 4				/* %gs */
};

/* From /usr/src/lib/libpthread/arch/i386/uthread_machdep.c.  */
static int i386obsd_uthread_reg_offset[] =
{
  11 * 4,			/* %eax */
  10 * 4,			/* %ecx */
  9 * 4,			/* %edx */
  8 * 4,			/* %ebx */
  -1,				/* %esp */
  6 * 4,			/* %ebp */
  5 * 4,			/* %esi */
  4 * 4,			/* %edi */
  12 * 4,			/* %eip */
  -1,				/* %eflags */
  13 * 4,			/* %cs */
  -1,				/* %ss */
  3 * 4,			/* %ds */
  2 * 4,			/* %es */
  1 * 4,			/* %fs */
  0 * 4				/* %gs */
};

/* Offset within the thread structure where we can find the saved
   stack pointer (%esp).  */
#define I386OBSD_UTHREAD_ESP_OFFSET	176

static void
i386obsd_supply_uthread (struct regcache *regcache,
			 int regnum, CORE_ADDR addr,
			 int ctx_offset)
{
  CORE_ADDR sp_addr = addr + ctx_offset;
  CORE_ADDR sp = 0;
  char buf[4];
  int i;

  gdb_assert (regnum >= -1);

  /* if ctx_offset is 0 use old fixed offset */
  if (ctx_offset == 0)
    sp_addr += I386OBSD_UTHREAD_ESP_OFFSET;

  if (regnum == -1 || regnum == I386_ESP_REGNUM)
    {
      int offset;

      /* Fetch stack pointer from thread structure.  */
      sp = read_memory_unsigned_integer (sp_addr, 4);

      /* Adjust the stack pointer such that it looks as if we just
         returned from _thread_machdep_switch.  */
      offset = i386obsd_uthread_reg_offset[I386_EIP_REGNUM] + 4;
      store_unsigned_integer (buf, 4, sp + offset);
      regcache_raw_supply (regcache, I386_ESP_REGNUM, buf);
    }

  for (i = 0; i < ARRAY_SIZE (i386obsd_uthread_reg_offset); i++)
    {
      if (i386obsd_uthread_reg_offset[i] != -1
	  && (regnum == -1 || regnum == i))
	{
	  /* Fetch stack pointer from thread structure (if we didn't
             do so already).  */
	  if (sp == 0)
	    sp = read_memory_unsigned_integer (sp_addr, 4);

	  /* Read the saved register from the stack frame.  */
	  read_memory (sp + i386obsd_uthread_reg_offset[i], buf, 4);
	  regcache_raw_supply (regcache, i, buf);
	}
    }
}

static void
i386obsd_collect_uthread (const struct regcache *regcache,
			  int regnum, CORE_ADDR addr,
			  int ctx_offset)
{
  CORE_ADDR sp_addr = addr + ctx_offset;
  CORE_ADDR sp = 0;
  char buf[4];
  int i;

  gdb_assert (regnum >= -1);

  /* if ctx_offset is 0 use old fixed offset */
  if (ctx_offset == 0)
    sp_addr += I386OBSD_UTHREAD_ESP_OFFSET;

  if (regnum == -1 || regnum == I386_ESP_REGNUM)
    {
      int offset;

      /* Calculate the stack pointer (frame pointer) that will be
         stored into the thread structure.  */
      offset = i386obsd_uthread_reg_offset[I386_EIP_REGNUM] + 4;
      regcache_raw_collect (regcache, I386_ESP_REGNUM, buf);
      sp = extract_unsigned_integer (buf, 4) - offset;

      /* Store the stack pointer.  */
      write_memory_unsigned_integer (sp_addr, 4, sp);

      /* The stack pointer was (potentially) modified.  Make sure we
         build a proper stack frame.  */
      regnum = -1;
    }

  for (i = 0; i < ARRAY_SIZE (i386obsd_uthread_reg_offset); i++)
    {
      if (i386obsd_uthread_reg_offset[i] != -1
	  && (regnum == -1 || regnum == i))
	{
	  /* Fetch stack pointer from thread structure (if we didn't
             calculate it already).  */
	  if (sp == 0)
	    sp = read_memory_unsigned_integer (sp_addr, 4);

	  /* Write the register into the stack frame.  */
	  regcache_raw_collect (regcache, i, buf);
	  write_memory (sp + i386obsd_uthread_reg_offset[i], buf, 4);
	}
    }
}

/* Kernel debugging support.  */

/* From <machine/frame.h>.  Note that %esp and %ess are only saved in
   a trap frame when entering the kernel from user space.  */
static int i386obsd_tf_reg_offset[] =
{
  10 * 4,			/* %eax */
  9 * 4,			/* %ecx */
  8 * 4,			/* %edx */
  7 * 4,			/* %ebx */
  -1,				/* %esp */
  6 * 4,			/* %ebp */
  5 * 4,			/* %esi */
  4 * 4,			/* %edi */
  13 * 4,			/* %eip */
  15 * 4,			/* %eflags */
  14 * 4,			/* %cs */
  -1,				/* %ss */
  3 * 4,			/* %ds */
  2 * 4,			/* %es */
  0 * 4,			/* %fs */
  1 * 4				/* %gs */
};

static struct trad_frame_cache *
i386obsd_trapframe_cache(struct frame_info *next_frame, void **this_cache)
{
  struct trad_frame_cache *cache;
  CORE_ADDR func, sp, addr;
  ULONGEST cs;
  char *name;
  int i;

  if (*this_cache)
    return *this_cache;

  cache = trad_frame_cache_zalloc (next_frame);
  *this_cache = cache;

  func = frame_func_unwind (next_frame);
  sp = frame_unwind_register_unsigned (next_frame, I386_ESP_REGNUM);

  find_pc_partial_function (func, &name, NULL, NULL);
  if (name && (strncmp (name, "Xintr", 5) == 0
	       || strncmp (name, "Xresume", 7) == 0
	       || strncmp (name, "Xstray", 6) == 0
	       || strncmp (name, "Xhold", 5) == 0
	       || strncmp (name, "Xrecurse", 8) == 0
	       || strcmp (name, "Xdoreti") == 0
	       || strncmp (name, "Xsoft", 5) == 0))
    addr = sp + 8;		/* It's an interrupt frame.  */
  else if (name && strcmp (name, "alltraps") == 0)
    addr = sp + 4;		/* It's a trap frame.  */
  else if (name && strcmp (name, "calltrap") == 0)
    addr = sp + 4;		/* It's a trap frame with debug symbols.  */
  else
    addr = sp;

  for (i = 0; i < ARRAY_SIZE (i386obsd_tf_reg_offset); i++)
    if (i386obsd_tf_reg_offset[i] != -1)
      trad_frame_set_reg_addr (cache, i, addr + i386obsd_tf_reg_offset[i]);

  /* Read %cs from trap frame.  */
  addr += i386obsd_tf_reg_offset[I386_CS_REGNUM];
  cs = read_memory_unsigned_integer (addr, 4); 
  if ((cs & I386_SEL_RPL) == I386_SEL_UPL)
    {
      /* Trap from user space; terminate backtrace.  */
      trad_frame_set_id (cache, null_frame_id);
    }
  else
    {
      /* Construct the frame ID using the function start.  */
      trad_frame_set_id (cache, frame_id_build (sp + 8, func));
    }

  return cache;
}

static void
i386obsd_trapframe_this_id (struct frame_info *next_frame,
			    void **this_cache, struct frame_id *this_id)
{
  struct trad_frame_cache *cache =
    i386obsd_trapframe_cache (next_frame, this_cache);
  
  trad_frame_get_id (cache, this_id);
}

static void
i386obsd_trapframe_prev_register (struct frame_info *next_frame,
				  void **this_cache, int regnum,
				  int *optimizedp, enum lval_type *lvalp,
				  CORE_ADDR *addrp, int *realnump,
				  void *valuep)
{
  struct trad_frame_cache *cache =
    i386obsd_trapframe_cache (next_frame, this_cache);

  trad_frame_get_register (cache, next_frame, regnum,
			   optimizedp, lvalp, addrp, realnump, valuep);
}

static int
i386obsd_trapframe_sniffer (const struct frame_unwind *self,
			    struct frame_info *next_frame,
			    void **this_prologue_cache)
{
  ULONGEST cs;
  char *name;

  /* Check Current Privilege Level and bail out if we're not executing
     in kernel space.  */
  cs = frame_unwind_register_unsigned (next_frame, I386_CS_REGNUM);
  if ((cs & I386_SEL_RPL) == I386_SEL_UPL)
    return 0;

  find_pc_partial_function (frame_pc_unwind (next_frame), &name, NULL, NULL);
  return (name && (strcmp (name, "calltrap") == 0
		   || strcmp (name, "alltraps") == 0
		   || strncmp (name, "Xintr", 5) == 0
		   || strncmp (name, "Xresume", 7) == 0
		   || strncmp (name, "Xstray", 6) == 0
		   || strncmp (name, "Xhold", 5) == 0
		   || strncmp (name, "Xrecurse", 8) == 0
		   || strcmp (name, "Xdoreti") == 0
		   || strncmp (name, "Xsoft", 5) == 0));
}

static const struct frame_unwind i386obsd_trapframe_unwind = {
  /* FIXME: kettenis/20051219: This really is more like an interrupt
     frame, but SIGTRAMP_FRAME would print <signal handler called>,
     which really is not what we want here.  */
  NORMAL_FRAME,
  i386obsd_trapframe_this_id,
  i386obsd_trapframe_prev_register,
  NULL,
  i386obsd_trapframe_sniffer
};


static void 
i386obsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* Obviously OpenBSD is BSD-based.  */
  i386bsd_init_abi (info, gdbarch);

  /* OpenBSD has a different `struct reg'.  */
  tdep->gregset_reg_offset = i386obsd_r_reg_offset;
  tdep->gregset_num_regs = ARRAY_SIZE (i386obsd_r_reg_offset);
  tdep->sizeof_gregset = 16 * 4;

  /* OpenBSD uses -freg-struct-return by default.  */
  tdep->struct_return = reg_struct_return;

  /* OpenBSD uses a different memory layout.  */
  tdep->sigtramp_start = i386obsd_sigtramp_start_addr;
  tdep->sigtramp_end = i386obsd_sigtramp_end_addr;
  tdep->sigtramp_p = i386obsd_sigtramp_p;

  /* OpenBSD has a `struct sigcontext' that's different from the
     original 4.3 BSD.  */
  tdep->sc_reg_offset = i386obsd_sc_reg_offset;
  tdep->sc_num_regs = ARRAY_SIZE (i386obsd_sc_reg_offset);

  /* OpenBSD provides a user-level threads implementation.  */
  bsd_uthread_set_supply_uthread (gdbarch, i386obsd_supply_uthread);
  bsd_uthread_set_collect_uthread (gdbarch, i386obsd_collect_uthread);

  /* Unwind kernel trap frames correctly.  */
  frame_unwind_prepend_unwinder (gdbarch, &i386obsd_trapframe_unwind);
}

/* OpenBSD a.out.  */

static void
i386obsd_aout_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  i386obsd_init_abi (info, gdbarch);

  /* OpenBSD a.out has a single register set.  */
  set_gdbarch_regset_from_core_section
    (gdbarch, i386obsd_aout_regset_from_core_section);
}

/* OpenBSD ELF.  */

static void
i386obsd_elf_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* It's still OpenBSD.  */
  i386obsd_init_abi (info, gdbarch);

  /* But ELF-based.  */
  i386_elf_init_abi (info, gdbarch);

  /* OpenBSD ELF uses SVR4-style shared libraries.  */
  set_gdbarch_in_solib_call_trampoline
    (gdbarch, generic_in_solib_call_trampoline);
  set_solib_svr4_fetch_link_map_offsets
    (gdbarch, svr4_ilp32_fetch_link_map_offsets);
}


/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_i386obsd_tdep (void);

void
_initialize_i386obsd_tdep (void)
{
  /* FIXME: kettenis/20021020: Since OpenBSD/i386 binaries are
     indistingushable from NetBSD/i386 a.out binaries, building a GDB
     that should support both these targets will probably not work as
     expected.  */
#define GDB_OSABI_OPENBSD_AOUT GDB_OSABI_NETBSD_AOUT

  gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_OPENBSD_AOUT,
			  i386obsd_aout_init_abi);
  gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_OPENBSD_ELF,
			  i386obsd_elf_init_abi);
}
@


1.8
log
@On i386 gdb failed to display the stack trace of a kernel core dump
correctly.  The gdb backtrace command did not get over the trap
stack frame.  There is a pushl %esp in alltraps() that was not
accounted for.  Depending on wheter the analyzed kernel has debugging
symbols or not, the symbol is calltrap or alltraps.  Both get special
treatment now.
ok miod@@ kettenis@@
@
text
@d364 7
a370 1
  if (name && strncmp (name, "Xintr", 5) == 0)
a440 1
		   || strcmp (name, "syscall1") == 0
d442 5
@


1.7
log
@add compat support to gdb so that it can deal with libpthread with and
without the _thread_ctx_offset private symbol. okay kettenis@@
@
text
@d366 4
d434 1
@


1.6
log
@Handle soft interrupt frames too.
@
text
@d225 2
a226 1
			 int regnum, CORE_ADDR addr)
d228 1
a228 1
  CORE_ADDR sp_addr = addr + I386OBSD_UTHREAD_ESP_OFFSET;
d235 4
d272 2
a273 1
			  int regnum, CORE_ADDR addr)
d275 1
a275 1
  CORE_ADDR sp_addr = addr + I386OBSD_UTHREAD_ESP_OFFSET;
d281 4
@


1.5
log
@Teach gdb about interrupt frames on i386 too.
@
text
@d419 4
a422 3
  return (name && ((strcmp (name, "calltrap") == 0)
		   || (strcmp (name, "syscall1") == 0)
		   || (strncmp (name, "Xintr", 5) == 0)));
@


1.4
log
@Teach gdb how to unwind i386 kernel trap frames.
@
text
@d310 1
d341 1
d352 7
d361 1
a361 1
      trad_frame_set_reg_addr (cache, i, sp + i386obsd_tf_reg_offset[i]);
d364 1
a364 1
  addr = sp + i386obsd_tf_reg_offset[I386_CS_REGNUM];
d368 1
a368 1
      /* Trap from use space; terminate backtrace.  */
d404 4
a407 11
static const struct frame_unwind i386obsd_trapframe_unwind = {
  /* FIXME: kettenis/20051219: This really is more like an interrupt
     frame, but SIGTRAMP_FRAME would print <signal handler called>,
     which really is not what we want here.  */
  NORMAL_FRAME,
  i386obsd_trapframe_this_id,
  i386obsd_trapframe_prev_register
};

static const struct frame_unwind *
i386obsd_trapframe_sniffer (struct frame_info *next_frame)
d412 2
d416 1
a416 1
    return NULL;
d419 4
a422 3
  if (name && ((strcmp ("calltrap", name) == 0)
	       || (strcmp ("syscall1", name) == 0)))
    return &i386obsd_trapframe_unwind;
d424 10
a433 2
  return NULL;
}
d467 1
a467 1
  frame_unwind_append_sniffer (gdbarch, i386obsd_trapframe_sniffer);
@


1.3
log
@i386 threads support.
@
text
@d4 1
a4 1
   2003, 2004
d27 1
d35 1
a262 1

d310 112
d452 3
@


1.2
log
@Handle new signal trampoline on i386.
@
text
@d41 1
d196 114
d335 4
@


1.1
log
@Initial revision
@
text
@d26 1
d30 2
d54 10
a63 1
/* Return whether PC is in an OpenBSD sigtramp routine.  */
d66 1
a66 1
i386obsd_pc_in_sigtramp (CORE_ADDR pc, char *name)
d68 1
d76 8
a83 7
  char *buf;

  /* Avoid reading memory from the target if possible.  If we're in a
     named function, we're certainly not in a sigtramp routine
     provided by the kernel.  Take synthetic function names into
     account though.  */
  if (name && name[0] != '<')
d86 3
a88 3
  /* If we can't read the instructions at START_PC, return zero.  */
  buf = alloca (sizeof sigreturn);
  if (target_read_memory (start_pc + 0x14, buf, sizeof sigreturn))
d91 2
a92 3
  /* Check for sigreturn(2).  */
  if (memcmp (buf, sigreturn, sizeof sigreturn) == 0)
    return 1;
d94 12
a105 26
  /* Check for a traditional BSD sigtramp routine.  */
  return i386bsd_pc_in_sigtramp (pc, name);
}

/* Return the start address of the sigtramp routine.  */

static CORE_ADDR
i386obsd_sigtramp_start (CORE_ADDR pc)
{
  CORE_ADDR start_pc = (pc & ~(i386obsd_page_size - 1));

  if (i386bsd_pc_in_sigtramp (pc, NULL))
    return i386bsd_sigtramp_start (pc);

  return start_pc;
}

/* Return the end address of the sigtramp routine.  */

static CORE_ADDR
i386obsd_sigtramp_end (CORE_ADDR pc)
{
  CORE_ADDR start_pc = (pc & ~(i386obsd_page_size - 1));

  if (i386bsd_pc_in_sigtramp (pc, NULL))
    return i386bsd_sigtramp_end (pc);
d107 1
a107 1
  return start_pc + 0x22;
d139 1
a139 1
  const struct gdbarch_tdep *tdep = regset->descr;
d161 2
a162 5
	{
	  tdep->gregset = XMALLOC (struct regset);
	  tdep->gregset->descr = tdep;
	  tdep->gregset->supply_regset = i386obsd_aout_supply_regset;
	}
d214 1
a214 3
  set_gdbarch_pc_in_sigtramp (gdbarch, i386obsd_pc_in_sigtramp);
  set_gdbarch_sigtramp_start (gdbarch, i386obsd_sigtramp_start);
  set_gdbarch_sigtramp_end (gdbarch, i386obsd_sigtramp_end);
d217 1
a217 1
     origional 4.3 BSD.  */
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@a25 1
#include "frame.h"
a28 2
#include "symtab.h"
#include "objfiles.h"
d51 1
a51 2
/* Return whether the frame preceding NEXT_FRAME corresponds to an
   OpenBSD sigtramp routine.  */
d54 1
a54 1
i386obsd_sigtramp_p (struct frame_info *next_frame)
a55 1
  CORE_ADDR pc = frame_pc_unwind (next_frame);
d63 1
a63 2
  size_t buflen = sizeof sigreturn;
  char *name, *buf;
d65 5
a69 4
  /* If the function has a valid symbol name, it isn't a
     trampoline.  */
  find_pc_partial_function (pc, &name, NULL, NULL);
  if (name != NULL)
a71 8
  /* If the function lives in a valid section (even without a starting
     point) it isn't a trampoline.  */
  if (find_pc_section (pc) != NULL)
    return 0;

  /* Allocate buffer.  */
  buf = alloca (buflen);

d73 2
a74 1
  if (!safe_frame_unwind_memory (next_frame, start_pc + 0x0a, buf, buflen))
d78 1
a78 1
  if (memcmp (buf, sigreturn, buflen) == 0)
d81 23
a103 3
  /* If we can't read the instructions at START_PC, return zero.  */
  if (!safe_frame_unwind_memory (next_frame, start_pc + 0x14, buf, buflen))
    return 0;
d105 2
a106 3
  /* Check for sigreturn(2) (again).  */
  if (memcmp (buf, sigreturn, buflen) == 0)
    return 1;
d108 1
a108 1
  return 0;
d140 1
a140 1
  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
d162 5
a166 2
        tdep->gregset =
	  regset_alloc (gdbarch, i386obsd_aout_supply_regset, NULL);
d218 3
a220 1
  tdep->sigtramp_p = i386obsd_sigtramp_p;
d223 1
a223 1
     original 4.3 BSD.  */
@

