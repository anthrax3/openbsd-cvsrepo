head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.48
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.44
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.46
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.38
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.42
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.40
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.36
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.34
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.32
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.30
	OPENBSD_5_0:1.4.0.28
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.26
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.24
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2004.12.27.14.00.35;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.21.20.23.06;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.37.10;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.17.24;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.09.53;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.08.43;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.17.25;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@/* S-record download support for GDB, the GNU debugger.
   Copyright 1995, 1996, 1997, 1999, 2000, 2001, 2003, 2004
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "serial.h"
#include "srec.h"
#include <time.h>
#include "gdb_assert.h"
#include "gdb_string.h"

extern void report_transfer_performance (unsigned long, time_t, time_t);

extern int remote_debug;

static int make_srec (char *srec, CORE_ADDR targ_addr, bfd * abfd,
		      asection * sect, int sectoff, int *maxrecsize,
		      int flags);

/* Download an executable by converting it to S records.  DESC is a
   `struct serial *' to send the data to.  FILE is the name of the
   file to be loaded.  LOAD_OFFSET is the offset into memory to load
   data into.  It is usually specified by the user and is useful with
   the a.out file format.  MAXRECSIZE is the length in chars of the
   largest S-record the host can accomodate.  This is measured from
   the starting `S' to the last char of the checksum.  FLAGS is
   various random flags, and HASHMARK is non-zero to cause a `#' to be
   printed out for each record loaded.  WAITACK, if non-NULL, is a
   function that waits for an acknowledgement after each S-record, and
   returns non-zero if the ack is read correctly.  */

void
load_srec (struct serial *desc, const char *file, bfd_vma load_offset,
	   int maxrecsize,
	   int flags, int hashmark, int (*waitack) (void))
{
  bfd *abfd;
  asection *s;
  char *srec;
  int i;
  int reclen;
  time_t start_time, end_time;
  unsigned long data_count = 0;

  srec = (char *) alloca (maxrecsize + 1);

  abfd = bfd_openr (file, 0);
  if (!abfd)
    {
      printf_filtered ("Unable to open file %s\n", file);
      return;
    }

  if (bfd_check_format (abfd, bfd_object) == 0)
    {
      printf_filtered ("File is not an object file\n");
      return;
    }

  start_time = time (NULL);

  /* Write a type 0 header record. no data for a type 0, and there
     is no data, so len is 0.  */

  reclen = maxrecsize;
  make_srec (srec, 0, NULL, (asection *) 1, 0, &reclen, flags);
  if (remote_debug)
    {
      srec[reclen] = '\0';
      puts_debug ("sent -->", srec, "<--");
    }
  serial_write (desc, srec, reclen);

  for (s = abfd->sections; s; s = s->next)
    if (s->flags & SEC_LOAD)
      {
	int numbytes;
	bfd_vma addr = bfd_get_section_vma (abfd, s) + load_offset;
	bfd_size_type size = bfd_get_section_size (s);
	char *section_name = (char *) bfd_get_section_name (abfd, s);
	/* Both GDB and BFD have mechanisms for printing addresses.
           In the below, GDB's is used so that the address is
           consistent with the rest of GDB.  BFD's printf_vma() could
           have also been used. cagney 1999-09-01 */
	printf_filtered ("%s\t: 0x%s .. 0x%s  ",
			 section_name,
			 paddr (addr),
			 paddr (addr + size));
	gdb_flush (gdb_stdout);

	data_count += size;

	for (i = 0; i < size; i += numbytes)
	  {
	    reclen = maxrecsize;
	    numbytes = make_srec (srec, (CORE_ADDR) (addr + i), abfd, s,
				  i, &reclen, flags);

	    if (remote_debug)
	      {
		srec[reclen] = '\0';
		puts_debug ("sent -->", srec, "<--");
	      }

	    /* Repeatedly send the S-record until a good
	       acknowledgement is sent back.  */
	    do
	      {
		serial_write (desc, srec, reclen);
		if (deprecated_ui_load_progress_hook)
		  if (deprecated_ui_load_progress_hook (section_name,
							(unsigned long) i))
		    error ("Canceled the download");
	      }
	    while (waitack != NULL && !waitack ());

	    if (hashmark)
	      {
		putchar_unfiltered ('#');
		gdb_flush (gdb_stdout);
	      }
	  }			/* Per-packet (or S-record) loop */

	if (deprecated_ui_load_progress_hook)
	  if (deprecated_ui_load_progress_hook (section_name,
						(unsigned long) i))
	    error ("Canceled the download");
	putchar_unfiltered ('\n');
      }

  if (hashmark)
    putchar_unfiltered ('\n');

  end_time = time (NULL);

  /* Write a terminator record.  */

  reclen = maxrecsize;
  make_srec (srec, abfd->start_address, NULL, NULL, 0, &reclen, flags);

  if (remote_debug)
    {
      srec[reclen] = '\0';
      puts_debug ("sent -->", srec, "<--");
    }

  serial_write (desc, srec, reclen);

  /* Some monitors need these to wake up properly.  (Which ones? -sts)  */
  serial_write (desc, "\r\r", 2);
  if (remote_debug)
    puts_debug ("sent -->", "\r\r", "<---");

  serial_flush_input (desc);

  report_transfer_performance (data_count, start_time, end_time);
}

/*
 * make_srec -- make an srecord. This writes each line, one at a
 *      time, each with it's own header and trailer line.
 *      An srecord looks like this:
 *
 * byte count-+     address
 * start ---+ |        |       data        +- checksum
 *          | |        |                   |
 *        S01000006F6B692D746573742E73726563E4
 *        S315000448600000000000000000FC00005900000000E9
 *        S31A0004000023C1400037DE00F023604000377B009020825000348D
 *        S30B0004485A0000000000004E
 *        S70500040000F6
 *
 *      S<type><length><address><data><checksum>
 *
 *      Where
 *      - length
 *        is the number of bytes following upto the checksum. Note that
 *        this is not the number of chars following, since it takes two
 *        chars to represent a byte.
 *      - type
 *        is one of:
 *        0) header record
 *        1) two byte address data record
 *        2) three byte address data record
 *        3) four byte address data record
 *        7) four byte address termination record
 *        8) three byte address termination record
 *        9) two byte address termination record
 *       
 *      - address
 *        is the start address of the data following, or in the case of
 *        a termination record, the start address of the image
 *      - data
 *        is the data.
 *      - checksum
 *        is the sum of all the raw byte data in the record, from the length
 *        upwards, modulo 256 and subtracted from 255.
 *
 * This routine returns the length of the S-record.
 *
 */

static int
make_srec (char *srec, CORE_ADDR targ_addr, bfd *abfd, asection *sect,
	   int sectoff, int *maxrecsize, int flags)
{
  unsigned char checksum;
  int tmp;
  const static char hextab[] = "0123456789ABCDEF";
  const static char data_code_table[] = "123";
  const static char term_code_table[] = "987";
  const static char header_code_table[] = "000";
  char const *code_table;
  int addr_size;
  int payload_size;
  char *binbuf;
  char *p;

  if (sect)
    {
      tmp = flags;		/* Data or header record */
      code_table = abfd ? data_code_table : header_code_table;
      binbuf = alloca (*maxrecsize / 2);
    }
  else
    {
      tmp = flags >> SREC_TERM_SHIFT;	/* Term record */
      code_table = term_code_table;
      binbuf = NULL;
    }

  if ((tmp & SREC_2_BYTE_ADDR) && (targ_addr <= 0xffff))
    addr_size = 2;
  else if ((tmp & SREC_3_BYTE_ADDR) && (targ_addr <= 0xffffff))
    addr_size = 3;
  else if (tmp & SREC_4_BYTE_ADDR)
    addr_size = 4;
  else
    internal_error (__FILE__, __LINE__,
		    "make_srec:  Bad address (0x%s), or bad flags (0x%x).",
		    paddr (targ_addr), flags);

  /* Now that we know the address size, we can figure out how much
     data this record can hold.  */

  if (sect && abfd)
    {
      payload_size = (*maxrecsize - (1 + 1 + 2 + addr_size * 2 + 2)) / 2;
      payload_size = min (payload_size, bfd_get_section_size (sect) - sectoff);

      bfd_get_section_contents (abfd, sect, binbuf, sectoff, payload_size);
    }
  else
    payload_size = 0;		/* Term or header packets have no payload */

  /* Output the header.  */
  snprintf (srec, (*maxrecsize) + 1, "S%c%02X%0*X",
	    code_table[addr_size - 2],
	    addr_size + payload_size + 1,
	    addr_size * 2, (int) targ_addr);

  /* Note that the checksum is calculated on the raw data, not the
     hexified data.  It includes the length, address and the data
     portions of the packet.  */

  checksum = 0;

  checksum += (payload_size + addr_size + 1	/* Packet length */
	       + (targ_addr & 0xff)	/* Address... */
	       + ((targ_addr >> 8) & 0xff)
	       + ((targ_addr >> 16) & 0xff)
	       + ((targ_addr >> 24) & 0xff));

  /* NOTE: cagney/2003-08-10: The equation is old.  Check that the
     recent snprintf changes match that equation.  */
  gdb_assert (strlen (srec) == 1 + 1 + 2 + addr_size * 2);
  p = srec + 1 + 1 + 2 + addr_size * 2;

  /* Build the Srecord.  */
  for (tmp = 0; tmp < payload_size; tmp++)
    {
      unsigned char k;

      k = binbuf[tmp];
      *p++ = hextab[k >> 4];
      *p++ = hextab[k & 0xf];
      checksum += k;
    }

  checksum = ~checksum;

  *p++ = hextab[checksum >> 4];
  *p++ = hextab[checksum & 0xf];
  *p++ = '\r';

  *maxrecsize = p - srec;
  return payload_size;
}
@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1999, 2000, 2001
d96 1
a96 1
	bfd_size_type size = bfd_get_section_size_before_reloc (s);
d127 3
a129 2
		if (ui_load_progress_hook)
		  if (ui_load_progress_hook (section_name, (unsigned long) i))
d141 3
a143 2
	if (ui_load_progress_hook)
	  if (ui_load_progress_hook (section_name, (unsigned long) i))
d266 1
a266 1
      payload_size = min (payload_size, sect->_raw_size - sectoff);
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright 1995, 1996 Free Software Foundation, Inc.
d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d25 5
d33 15
a47 12
static int make_srec PARAMS ((char *srec, CORE_ADDR targ_addr, bfd *abfd,
			      asection *sect, int sectoff, int *maxrecsize,
			      int flags));

/*  Download an executable by converting it to S records.  DESC is a serial_t
    to send the data to.  FILE is the name of the file to be loaded.
    MAXRECSIZE is the length in chars of the largest S-record the host can
    accomodate.  This is measured from the starting `S' to the last char of the
    checksum.  FLAGS is various random flags, and HASHMARK is non-zero to cause
    a `#' to be printed out for each record loaded.  WAITACK, if non-NULL, is
    a function that waits for an acknowledgement after each S-record, and
    returns non-zero if the ack is read correctly.  */
d50 3
a52 7
load_srec (desc, file, maxrecsize, flags, hashmark, waitack)
     serial_t desc;
     const char *file;
     int maxrecsize;
     int flags;
     int hashmark;
     int (*waitack) PARAMS ((void));
d59 2
d62 1
a62 1
  srec = (char *)alloca (maxrecsize + 1);
d76 15
a90 1
  
d95 12
d108 1
a108 3
	printf_filtered ("%s\t: 0x%4x .. 0x%4x  ", s->name, s->vma,
			 s->vma + s->_raw_size);
	gdb_flush (gdb_stdout);
d110 1
a110 1
	for (i = 0; i < s->_raw_size; i += numbytes)
d113 2
a114 2
	    numbytes = make_srec (srec, s->vma + i, abfd, s, i, &reclen,
				  flags);
d117 4
a120 1
	      fprintf_unfiltered (gdb_stderr, "%.*s\\r\n", reclen-1, srec);
d122 2
a123 2
	    /* Repeatedly send the S-record until a good acknowledgement
	       is sent back.  */
d126 4
a129 1
	        SERIAL_WRITE (desc, srec, reclen);
d131 1
a131 1
	    while (waitack != NULL && !waitack());
d140 3
d144 1
a144 1
      }				/* Loadable sections */
d146 1
a146 1
  if (hashmark) 
d148 4
a151 3
  
  /* Write a type 7 terminator record. no data for a type 7, and there
     is no data, so len is 0.  */
d157 6
a162 2
    fprintf_unfiltered (gdb_stderr, "%.*s\\r\n", reclen-1, srec);
  SERIAL_WRITE (desc, srec, reclen);
d164 4
a167 1
  SERIAL_WRITE (desc, "\r\r", 2); /* Some monitors need these to wake up */
d169 3
a171 1
  SERIAL_FLUSH_INPUT (desc);
d176 2
a177 2
 *	time, each with it's own header and trailer line.
 *	An srecord looks like this:
d181 6
a186 6
 *	    | |        |                   |
 *	  S01000006F6B692D746573742E73726563E4
 *	  S315000448600000000000000000FC00005900000000E9
 *	  S31A0004000023C1400037DE00F023604000377B009020825000348D
 *	  S30B0004485A0000000000004E
 *	  S70500040000F6
d188 1
a188 1
 *	S<type><length><address><data><checksum>
d211 1
a211 1
 *	  is the sum of all the raw byte data in the record, from the length
d219 2
a220 8
make_srec (srec, targ_addr, abfd, sect, sectoff, maxrecsize, flags)
     char *srec;
     CORE_ADDR targ_addr;
     bfd *abfd;
     asection *sect;
     int sectoff;
     int *maxrecsize;
     int flags;
d225 3
a227 4
  const static char data_code_table[] = "xx123";
  const static char term_code_table[] = "xx987";
  const static char *formats[] = {NULL, NULL, "S%c%02X%04X", "S%c%02X%06X",
				    "S%c%02X%08X"};
a230 1
  int type_code;
d236 3
a238 3
      tmp = flags;		/* Data record */
      code_table = data_code_table;
      binbuf = alloca (*maxrecsize/2);
d242 1
a242 1
      tmp = flags >> SREC_TERM_SHIFT; /* Term record */
d244 1
d254 3
a256 2
    fatal ("make_srec:  Bad address (0x%x), or bad flags (0x%x).", targ_addr,
	   flags);
d258 2
a259 2
/* Now that we know the address size, we can figure out how much data this
   record can hold.  */
d261 1
a261 1
  if (sect)
d269 1
a269 1
    payload_size = 0;		/* Term packets have no payload */
d271 9
a279 1
/* Output the header.  */
d281 1
a281 2
  sprintf (srec, formats[addr_size], code_table[addr_size],
	   addr_size + payload_size + 1, targ_addr);
d283 1
a283 7
/* Note that the checksum is calculated on the raw data, not the hexified
   data.  It includes the length, address and the data portions of the
   packet.  */

  checksum = 0;
  
  checksum += (payload_size + addr_size + 1 /* Packet length */
d285 1
a285 1
	       + ((targ_addr >>  8) & 0xff)
d288 4
a291 1
  
d294 1
a294 1
  /* build the srecord */
d300 2
a301 2
      *p++ = hextab [k >> 4];
      *p++ = hextab [k & 0xf];
@


1.1
log
@file dsrec.c was initially added on branch CYGNUS.
@
text
@d1 264
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 313
/* S-record download support for GDB, the GNU debugger.
   Copyright 1995, 1996, 1997, 1999, 2000, 2001
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "serial.h"
#include "srec.h"
#include <time.h>
#include "gdb_assert.h"
#include "gdb_string.h"

extern void report_transfer_performance (unsigned long, time_t, time_t);

extern int remote_debug;

static int make_srec (char *srec, CORE_ADDR targ_addr, bfd * abfd,
		      asection * sect, int sectoff, int *maxrecsize,
		      int flags);

/* Download an executable by converting it to S records.  DESC is a
   `struct serial *' to send the data to.  FILE is the name of the
   file to be loaded.  LOAD_OFFSET is the offset into memory to load
   data into.  It is usually specified by the user and is useful with
   the a.out file format.  MAXRECSIZE is the length in chars of the
   largest S-record the host can accomodate.  This is measured from
   the starting `S' to the last char of the checksum.  FLAGS is
   various random flags, and HASHMARK is non-zero to cause a `#' to be
   printed out for each record loaded.  WAITACK, if non-NULL, is a
   function that waits for an acknowledgement after each S-record, and
   returns non-zero if the ack is read correctly.  */

void
load_srec (struct serial *desc, const char *file, bfd_vma load_offset,
	   int maxrecsize,
	   int flags, int hashmark, int (*waitack) (void))
{
  bfd *abfd;
  asection *s;
  char *srec;
  int i;
  int reclen;
  time_t start_time, end_time;
  unsigned long data_count = 0;

  srec = (char *) alloca (maxrecsize + 1);

  abfd = bfd_openr (file, 0);
  if (!abfd)
    {
      printf_filtered ("Unable to open file %s\n", file);
      return;
    }

  if (bfd_check_format (abfd, bfd_object) == 0)
    {
      printf_filtered ("File is not an object file\n");
      return;
    }

  start_time = time (NULL);

  /* Write a type 0 header record. no data for a type 0, and there
     is no data, so len is 0.  */

  reclen = maxrecsize;
  make_srec (srec, 0, NULL, (asection *) 1, 0, &reclen, flags);
  if (remote_debug)
    {
      srec[reclen] = '\0';
      puts_debug ("sent -->", srec, "<--");
    }
  serial_write (desc, srec, reclen);

  for (s = abfd->sections; s; s = s->next)
    if (s->flags & SEC_LOAD)
      {
	int numbytes;
	bfd_vma addr = bfd_get_section_vma (abfd, s) + load_offset;
	bfd_size_type size = bfd_get_section_size_before_reloc (s);
	char *section_name = (char *) bfd_get_section_name (abfd, s);
	/* Both GDB and BFD have mechanisms for printing addresses.
           In the below, GDB's is used so that the address is
           consistent with the rest of GDB.  BFD's printf_vma() could
           have also been used. cagney 1999-09-01 */
	printf_filtered ("%s\t: 0x%s .. 0x%s  ",
			 section_name,
			 paddr (addr),
			 paddr (addr + size));
	gdb_flush (gdb_stdout);

	data_count += size;

	for (i = 0; i < size; i += numbytes)
	  {
	    reclen = maxrecsize;
	    numbytes = make_srec (srec, (CORE_ADDR) (addr + i), abfd, s,
				  i, &reclen, flags);

	    if (remote_debug)
	      {
		srec[reclen] = '\0';
		puts_debug ("sent -->", srec, "<--");
	      }

	    /* Repeatedly send the S-record until a good
	       acknowledgement is sent back.  */
	    do
	      {
		serial_write (desc, srec, reclen);
		if (ui_load_progress_hook)
		  if (ui_load_progress_hook (section_name, (unsigned long) i))
		    error ("Canceled the download");
	      }
	    while (waitack != NULL && !waitack ());

	    if (hashmark)
	      {
		putchar_unfiltered ('#');
		gdb_flush (gdb_stdout);
	      }
	  }			/* Per-packet (or S-record) loop */

	if (ui_load_progress_hook)
	  if (ui_load_progress_hook (section_name, (unsigned long) i))
	    error ("Canceled the download");
	putchar_unfiltered ('\n');
      }

  if (hashmark)
    putchar_unfiltered ('\n');

  end_time = time (NULL);

  /* Write a terminator record.  */

  reclen = maxrecsize;
  make_srec (srec, abfd->start_address, NULL, NULL, 0, &reclen, flags);

  if (remote_debug)
    {
      srec[reclen] = '\0';
      puts_debug ("sent -->", srec, "<--");
    }

  serial_write (desc, srec, reclen);

  /* Some monitors need these to wake up properly.  (Which ones? -sts)  */
  serial_write (desc, "\r\r", 2);
  if (remote_debug)
    puts_debug ("sent -->", "\r\r", "<---");

  serial_flush_input (desc);

  report_transfer_performance (data_count, start_time, end_time);
}

/*
 * make_srec -- make an srecord. This writes each line, one at a
 *      time, each with it's own header and trailer line.
 *      An srecord looks like this:
 *
 * byte count-+     address
 * start ---+ |        |       data        +- checksum
 *          | |        |                   |
 *        S01000006F6B692D746573742E73726563E4
 *        S315000448600000000000000000FC00005900000000E9
 *        S31A0004000023C1400037DE00F023604000377B009020825000348D
 *        S30B0004485A0000000000004E
 *        S70500040000F6
 *
 *      S<type><length><address><data><checksum>
 *
 *      Where
 *      - length
 *        is the number of bytes following upto the checksum. Note that
 *        this is not the number of chars following, since it takes two
 *        chars to represent a byte.
 *      - type
 *        is one of:
 *        0) header record
 *        1) two byte address data record
 *        2) three byte address data record
 *        3) four byte address data record
 *        7) four byte address termination record
 *        8) three byte address termination record
 *        9) two byte address termination record
 *       
 *      - address
 *        is the start address of the data following, or in the case of
 *        a termination record, the start address of the image
 *      - data
 *        is the data.
 *      - checksum
 *        is the sum of all the raw byte data in the record, from the length
 *        upwards, modulo 256 and subtracted from 255.
 *
 * This routine returns the length of the S-record.
 *
 */

static int
make_srec (char *srec, CORE_ADDR targ_addr, bfd *abfd, asection *sect,
	   int sectoff, int *maxrecsize, int flags)
{
  unsigned char checksum;
  int tmp;
  const static char hextab[] = "0123456789ABCDEF";
  const static char data_code_table[] = "123";
  const static char term_code_table[] = "987";
  const static char header_code_table[] = "000";
  char const *code_table;
  int addr_size;
  int payload_size;
  char *binbuf;
  char *p;

  if (sect)
    {
      tmp = flags;		/* Data or header record */
      code_table = abfd ? data_code_table : header_code_table;
      binbuf = alloca (*maxrecsize / 2);
    }
  else
    {
      tmp = flags >> SREC_TERM_SHIFT;	/* Term record */
      code_table = term_code_table;
      binbuf = NULL;
    }

  if ((tmp & SREC_2_BYTE_ADDR) && (targ_addr <= 0xffff))
    addr_size = 2;
  else if ((tmp & SREC_3_BYTE_ADDR) && (targ_addr <= 0xffffff))
    addr_size = 3;
  else if (tmp & SREC_4_BYTE_ADDR)
    addr_size = 4;
  else
    internal_error (__FILE__, __LINE__,
		    "make_srec:  Bad address (0x%s), or bad flags (0x%x).",
		    paddr (targ_addr), flags);

  /* Now that we know the address size, we can figure out how much
     data this record can hold.  */

  if (sect && abfd)
    {
      payload_size = (*maxrecsize - (1 + 1 + 2 + addr_size * 2 + 2)) / 2;
      payload_size = min (payload_size, sect->_raw_size - sectoff);

      bfd_get_section_contents (abfd, sect, binbuf, sectoff, payload_size);
    }
  else
    payload_size = 0;		/* Term or header packets have no payload */

  /* Output the header.  */
  snprintf (srec, (*maxrecsize) + 1, "S%c%02X%0*X",
	    code_table[addr_size - 2],
	    addr_size + payload_size + 1,
	    addr_size * 2, (int) targ_addr);

  /* Note that the checksum is calculated on the raw data, not the
     hexified data.  It includes the length, address and the data
     portions of the packet.  */

  checksum = 0;

  checksum += (payload_size + addr_size + 1	/* Packet length */
	       + (targ_addr & 0xff)	/* Address... */
	       + ((targ_addr >> 8) & 0xff)
	       + ((targ_addr >> 16) & 0xff)
	       + ((targ_addr >> 24) & 0xff));

  /* NOTE: cagney/2003-08-10: The equation is old.  Check that the
     recent snprintf changes match that equation.  */
  gdb_assert (strlen (srec) == 1 + 1 + 2 + addr_size * 2);
  p = srec + 1 + 1 + 2 + addr_size * 2;

  /* Build the Srecord.  */
  for (tmp = 0; tmp < payload_size; tmp++)
    {
      unsigned char k;

      k = binbuf[tmp];
      *p++ = hextab[k >> 4];
      *p++ = hextab[k & 0xf];
      checksum += k;
    }

  checksum = ~checksum;

  *p++ = hextab[checksum >> 4];
  *p++ = hextab[checksum & 0xf];
  *p++ = '\r';

  *maxrecsize = p - srec;
  return payload_size;
}
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1999, 2000, 2001, 2003, 2004
d96 1
a96 1
	bfd_size_type size = bfd_get_section_size (s);
d127 2
a128 3
		if (deprecated_ui_load_progress_hook)
		  if (deprecated_ui_load_progress_hook (section_name,
							(unsigned long) i))
d140 2
a141 3
	if (deprecated_ui_load_progress_hook)
	  if (deprecated_ui_load_progress_hook (section_name,
						(unsigned long) i))
d264 1
a264 1
      payload_size = min (payload_size, bfd_get_section_size (sect) - sectoff);
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 264
/* S-record download support for GDB, the GNU debugger.
   Copyright 1995, 1996 Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "serial.h"
#include "srec.h"

extern int remote_debug;

static int make_srec PARAMS ((char *srec, CORE_ADDR targ_addr, bfd *abfd,
			      asection *sect, int sectoff, int *maxrecsize,
			      int flags));

/*  Download an executable by converting it to S records.  DESC is a serial_t
    to send the data to.  FILE is the name of the file to be loaded.
    MAXRECSIZE is the length in chars of the largest S-record the host can
    accomodate.  This is measured from the starting `S' to the last char of the
    checksum.  FLAGS is various random flags, and HASHMARK is non-zero to cause
    a `#' to be printed out for each record loaded.  WAITACK, if non-NULL, is
    a function that waits for an acknowledgement after each S-record, and
    returns non-zero if the ack is read correctly.  */

void
load_srec (desc, file, maxrecsize, flags, hashmark, waitack)
     serial_t desc;
     const char *file;
     int maxrecsize;
     int flags;
     int hashmark;
     int (*waitack) PARAMS ((void));
{
  bfd *abfd;
  asection *s;
  char *srec;
  int i;
  int reclen;

  srec = (char *)alloca (maxrecsize + 1);

  abfd = bfd_openr (file, 0);
  if (!abfd)
    {
      printf_filtered ("Unable to open file %s\n", file);
      return;
    }

  if (bfd_check_format (abfd, bfd_object) == 0)
    {
      printf_filtered ("File is not an object file\n");
      return;
    }
  
  for (s = abfd->sections; s; s = s->next)
    if (s->flags & SEC_LOAD)
      {
	int numbytes;

	printf_filtered ("%s\t: 0x%4x .. 0x%4x  ", s->name, s->vma,
			 s->vma + s->_raw_size);
	gdb_flush (gdb_stdout);

	for (i = 0; i < s->_raw_size; i += numbytes)
	  {
	    reclen = maxrecsize;
	    numbytes = make_srec (srec, s->vma + i, abfd, s, i, &reclen,
				  flags);

	    if (remote_debug)
	      fprintf_unfiltered (gdb_stderr, "%.*s\\r\n", reclen-1, srec);

	    /* Repeatedly send the S-record until a good acknowledgement
	       is sent back.  */
	    do
	      {
	        SERIAL_WRITE (desc, srec, reclen);
	      }
	    while (waitack != NULL && !waitack());

	    if (hashmark)
	      {
		putchar_unfiltered ('#');
		gdb_flush (gdb_stdout);
	      }
	  }			/* Per-packet (or S-record) loop */

	putchar_unfiltered ('\n');
      }				/* Loadable sections */

  if (hashmark) 
    putchar_unfiltered ('\n');
  
  /* Write a type 7 terminator record. no data for a type 7, and there
     is no data, so len is 0.  */

  reclen = maxrecsize;
  make_srec (srec, abfd->start_address, NULL, NULL, 0, &reclen, flags);

  if (remote_debug)
    fprintf_unfiltered (gdb_stderr, "%.*s\\r\n", reclen-1, srec);
  SERIAL_WRITE (desc, srec, reclen);

  SERIAL_WRITE (desc, "\r\r", 2); /* Some monitors need these to wake up */

  SERIAL_FLUSH_INPUT (desc);
}

/*
 * make_srec -- make an srecord. This writes each line, one at a
 *	time, each with it's own header and trailer line.
 *	An srecord looks like this:
 *
 * byte count-+     address
 * start ---+ |        |       data        +- checksum
 *	    | |        |                   |
 *	  S01000006F6B692D746573742E73726563E4
 *	  S315000448600000000000000000FC00005900000000E9
 *	  S31A0004000023C1400037DE00F023604000377B009020825000348D
 *	  S30B0004485A0000000000004E
 *	  S70500040000F6
 *
 *	S<type><length><address><data><checksum>
 *
 *      Where
 *      - length
 *        is the number of bytes following upto the checksum. Note that
 *        this is not the number of chars following, since it takes two
 *        chars to represent a byte.
 *      - type
 *        is one of:
 *        0) header record
 *        1) two byte address data record
 *        2) three byte address data record
 *        3) four byte address data record
 *        7) four byte address termination record
 *        8) three byte address termination record
 *        9) two byte address termination record
 *       
 *      - address
 *        is the start address of the data following, or in the case of
 *        a termination record, the start address of the image
 *      - data
 *        is the data.
 *      - checksum
 *	  is the sum of all the raw byte data in the record, from the length
 *        upwards, modulo 256 and subtracted from 255.
 *
 * This routine returns the length of the S-record.
 *
 */

static int
make_srec (srec, targ_addr, abfd, sect, sectoff, maxrecsize, flags)
     char *srec;
     CORE_ADDR targ_addr;
     bfd *abfd;
     asection *sect;
     int sectoff;
     int *maxrecsize;
     int flags;
{
  unsigned char checksum;
  int tmp;
  const static char hextab[] = "0123456789ABCDEF";
  const static char data_code_table[] = "xx123";
  const static char term_code_table[] = "xx987";
  const static char *formats[] = {NULL, NULL, "S%c%02X%04X", "S%c%02X%06X",
				    "S%c%02X%08X"};
  char const *code_table;
  int addr_size;
  int payload_size;
  int type_code;
  char *binbuf;
  char *p;

  if (sect)
    {
      tmp = flags;		/* Data record */
      code_table = data_code_table;
      binbuf = alloca (*maxrecsize/2);
    }
  else
    {
      tmp = flags >> SREC_TERM_SHIFT; /* Term record */
      code_table = term_code_table;
    }

  if ((tmp & SREC_2_BYTE_ADDR) && (targ_addr <= 0xffff))
    addr_size = 2;
  else if ((tmp & SREC_3_BYTE_ADDR) && (targ_addr <= 0xffffff))
    addr_size = 3;
  else if (tmp & SREC_4_BYTE_ADDR)
    addr_size = 4;
  else
    fatal ("make_srec:  Bad address (0x%x), or bad flags (0x%x).", targ_addr,
	   flags);

/* Now that we know the address size, we can figure out how much data this
   record can hold.  */

  if (sect)
    {
      payload_size = (*maxrecsize - (1 + 1 + 2 + addr_size * 2 + 2)) / 2;
      payload_size = min (payload_size, sect->_raw_size - sectoff);

      bfd_get_section_contents (abfd, sect, binbuf, sectoff, payload_size);
    }
  else
    payload_size = 0;		/* Term packets have no payload */

/* Output the header.  */

  sprintf (srec, formats[addr_size], code_table[addr_size],
	   addr_size + payload_size + 1, targ_addr);

/* Note that the checksum is calculated on the raw data, not the hexified
   data.  It includes the length, address and the data portions of the
   packet.  */

  checksum = 0;
  
  checksum += (payload_size + addr_size + 1 /* Packet length */
	       + (targ_addr & 0xff)	/* Address... */
	       + ((targ_addr >>  8) & 0xff)
	       + ((targ_addr >> 16) & 0xff)
	       + ((targ_addr >> 24) & 0xff));
  
  p = srec + 1 + 1 + 2 + addr_size * 2;

  /* build the srecord */
  for (tmp = 0; tmp < payload_size; tmp++)
    {
      unsigned char k;

      k = binbuf[tmp];
      *p++ = hextab [k >> 4];
      *p++ = hextab [k & 0xf];
      checksum += k;
    }

  checksum = ~checksum;

  *p++ = hextab[checksum >> 4];
  *p++ = hextab[checksum & 0xf];
  *p++ = '\r';

  *maxrecsize = p - srec;
  return payload_size;
}
@
