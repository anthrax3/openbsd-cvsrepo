head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.36
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.32
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.28
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.30
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.22
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.26
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.24
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.20
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.18
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.16
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.14
	OPENBSD_5_0:1.2.0.12
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.10
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.8
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.6
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.16
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.14
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.12
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.10
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.8
	OPENBSD_4_0_BASE:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.6
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.4
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.2
	OPENBSD_3_7_BASE:1.1.1.2
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.1.1.1.0.2
	OPENBSD_3_6_BASE:1.1.1.1
	GDB_6_1:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2008.11.11.22.57.48;	author kurt;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.21.19.13.08;	author kettenis;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.05.21.19.13.08;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.11.42;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Enable support for debugging pie programs. Code from Elena Zannoni's
<ezannoni at redhat dot com> pie branch in gdb cvs, less extraneous
parts and with some bug fixes. Debugging w/core files for pie programs
isn't working yet since AUXV data isn't included in our core files at
the moment.

feedback and ok kettenis@@
@
text
@/* Shared library declarations for GDB, the GNU Debugger.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
   2001
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#ifndef SOLIST_H
#define SOLIST_H

#define SO_NAME_MAX_PATH_SIZE 512	/* FIXME: Should be dynamic */

/* Forward declaration for target specific link map information.  This
   struct is opaque to all but the target specific file.  */
struct lm_info;

struct so_list
  {
    /* The following fields of the structure come directly from the
       dynamic linker's tables in the inferior, and are initialized by
       current_sos.  */

    struct so_list *next;	/* next structure in linked list */

    /* A pointer to target specific link map information.  Often this
       will be a copy of struct link_map from the user process, but
       it need not be; it can be any collection of data needed to
       traverse the dynamic linker's data structures. */
    struct lm_info *lm_info;

    /* Shared object file name, exactly as it appears in the
       inferior's link map.  This may be a relative path, or something
       which needs to be looked up in LD_LIBRARY_PATH, etc.  We use it
       to tell which entries in the inferior's dynamic linker's link
       map we've already loaded.  */
    char so_original_name[SO_NAME_MAX_PATH_SIZE];

    /* shared object file name, expanded to something GDB can open */
    char so_name[SO_NAME_MAX_PATH_SIZE];

    /* The following fields of the structure are built from
       information gathered from the shared object file itself, and
       are set when we actually add it to our symbol tables.

       current_sos must initialize these fields to 0.  */

    bfd *abfd;
    char symbols_loaded;	/* flag: symbols read in yet? */
    char from_tty;		/* flag: print msgs? */
    char main;                  /* flag: is this the main executable? */
    char main_relocated;        /* flag: has it been relocated yet? */
    struct objfile *objfile;	/* objfile for loaded lib */
    struct section_table *sections;
    struct section_table *sections_end;
    struct section_table *textsection;
  };

struct target_so_ops
  {
    /* Adjust the section binding addresses by the base address at
       which the object was actually mapped.  */
    void (*relocate_section_addresses) (struct so_list *so,
                                        struct section_table *);

    /* Free the the link map info and any other private data
       structures associated with a so_list entry.  */
    void (*free_so) (struct so_list *so);

    /* Reset or free private data structures not associated with
       so_list entries.  */
    void (*clear_solib) (void);

    /* Target dependent code to run after child process fork.  */
    void (*solib_create_inferior_hook) (void);

    /* Do additional symbol handling, lookup, etc. after symbols
       for a shared object have been loaded.  */
    void (*special_symbol_handling) (void);

    /* Construct a list of the currently loaded shared objects.  */
    struct so_list *(*current_sos) (void);

    /* Find, open, and read the symbols for the main executable.  */
    int (*open_symbol_file_object) (void *from_ttyp);

    /* Determine if PC lies in the dynamic symbol resolution code of
       the run time loader */
    int (*in_dynsym_resolve_code) (CORE_ADDR pc);

    /* Extra hook for finding and opening a solib.  Convenience function
       for remote debuggers finding host libs */
    int (*find_and_open_solib) (char *soname,
        unsigned o_flags, char **temp_pathname);
    
  };

/* Free the memory associated with a (so_list *).  */
void free_so (struct so_list *so);

/* Return address of first so_list entry in master shared object list.  */
struct so_list *master_so_list (void);

/* Return address of first so_list entry in master shared object list.  */
struct so_list *master_so_list (void);

/* Find solib binary file and open it.  */
extern int solib_open (char *in_pathname, char **found_pathname);

/* Add the list of sections in so_list to the target to_sections.  */
extern void add_to_target_sections (int, struct target_ops *, struct so_list *);

/* FIXME: gdbarch needs to control this variable */
extern struct target_so_ops *current_target_so_ops;

#define TARGET_SO_RELOCATE_SECTION_ADDRESSES \
  (current_target_so_ops->relocate_section_addresses)
#define TARGET_SO_FREE_SO (current_target_so_ops->free_so)
#define TARGET_SO_CLEAR_SOLIB (current_target_so_ops->clear_solib)
#define TARGET_SO_SOLIB_CREATE_INFERIOR_HOOK \
  (current_target_so_ops->solib_create_inferior_hook)
#define TARGET_SO_SPECIAL_SYMBOL_HANDLING \
  (current_target_so_ops->special_symbol_handling)
#define TARGET_SO_CURRENT_SOS (current_target_so_ops->current_sos)
#define TARGET_SO_OPEN_SYMBOL_FILE_OBJECT \
  (current_target_so_ops->open_symbol_file_object)
#define TARGET_SO_IN_DYNSYM_RESOLVE_CODE \
  (current_target_so_ops->in_dynsym_resolve_code)
#define TARGET_SO_FIND_AND_OPEN_SOLIB \
  (current_target_so_ops->find_and_open_solib)

#endif
@


1.1
log
@Initial revision
@
text
@d65 2
d112 1
d115 6
d123 3
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@a109 1
/* Free the memory associated with a (so_list *).  */
a110 3

/* Return address of first so_list entry in master shared object list.  */
struct so_list *master_so_list (void);
@

