head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.52
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.54
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.50
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.46
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.48
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.40
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.44
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.42
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.38
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.36
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.34
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.32
	OPENBSD_5_0:1.3.0.30
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.28
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.26
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.22
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.24
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.20
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.18
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.16
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.14
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.12
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.10
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	GDB_6_3:1.1.1.1
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.3
date	2004.05.21.20.23.04;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.36.35;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.16.36;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.09.12;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.16.37;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@/* Build symbol tables in GDB's internal format.
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1995, 1996,
   1997, 1998, 1999, 2000, 2002, 2003 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#if !defined (BUILDSYM_H)
#define BUILDSYM_H 1

struct objfile;
struct symbol;

/* This module provides definitions used for creating and adding to
   the symbol table.  These routines are called from various symbol-
   file-reading routines.

   They originated in dbxread.c of gdb-4.2, and were split out to
   make xcoffread.c more maintainable by sharing code.

   Variables declared in this file can be defined by #define-ing the
   name EXTERN to null.  It is used to declare variables that are
   normally extern, but which get defined in a single module using
   this technique.  */

struct block;

#ifndef EXTERN
#define	EXTERN extern
#endif

#define HASHSIZE 127		/* Size of things hashed via
				   hashname() */

/* Name of source file whose symbol data we are now processing.  This
   comes from a symbol of type N_SO. */

EXTERN char *last_source_file;

/* Core address of start of text of current source file.  This too
   comes from the N_SO symbol. */

EXTERN CORE_ADDR last_source_start_addr;

/* The list of sub-source-files within the current individual
   compilation.  Each file gets its own symtab with its own linetable
   and associated info, but they all share one blockvector.  */

struct subfile
  {
    struct subfile *next;
    char *name;
    char *dirname;
    struct linetable *line_vector;
    int line_vector_length;
    enum language language;
    char *debugformat;
  };

EXTERN struct subfile *subfiles;

EXTERN struct subfile *current_subfile;

/* Global variable which, when set, indicates that we are processing a
   .o file compiled with gcc */

EXTERN unsigned char processing_gcc_compilation;

/* When set, we are processing a .o file compiled by sun acc.  This is
   misnamed; it refers to all stabs-in-elf implementations which use
   N_UNDF the way Sun does, including Solaris gcc.  Hopefully all
   stabs-in-elf implementations ever invented will choose to be
   compatible.  */

EXTERN unsigned char processing_acc_compilation;

/* Count symbols as they are processed, for error messages.  */

EXTERN unsigned int symnum;

/* Record the symbols defined for each context in a list.  We don't
   create a struct block for the context until we know how long to
   make it.  */

#define PENDINGSIZE 100

struct pending
  {
    struct pending *next;
    int nsyms;
    struct symbol *symbol[PENDINGSIZE];
  };

/* Here are the three lists that symbols are put on.  */

/* static at top level, and types */

EXTERN struct pending *file_symbols;

/* global functions and variables */

EXTERN struct pending *global_symbols;

/* everything local to lexical context */

EXTERN struct pending *local_symbols;

/* func params local to lexical  context */

EXTERN struct pending *param_symbols;

/* Stack representing unclosed lexical contexts (that will become
   blocks, eventually).  */

struct context_stack
  {
    /* Outer locals at the time we entered */

    struct pending *locals;

    /* Pending func params at the time we entered */

    struct pending *params;

    /* Pointer into blocklist as of entry */

    struct pending_block *old_blocks;

    /* Name of function, if any, defining context */

    struct symbol *name;

    /* PC where this context starts */

    CORE_ADDR start_addr;

    /* Temp slot for exception handling. */

    CORE_ADDR end_addr;

    /* For error-checking matching push/pop */

    int depth;

  };

EXTERN struct context_stack *context_stack;

/* Index of first unused entry in context stack.  */

EXTERN int context_stack_depth;

/* Currently allocated size of context stack.  */

EXTERN int context_stack_size;

/* Non-zero if the context stack is empty.  */
#define outermost_context_p() (context_stack_depth == 0)

/* Nonzero if within a function (so symbols should be local, if
   nothing says specifically).  */

EXTERN int within_function;

/* List of blocks already made (lexical contexts already closed).
   This is used at the end to make the blockvector.  */

struct pending_block
  {
    struct pending_block *next;
    struct block *block;
  };

/* Pointer to the head of a linked list of symbol blocks which have
   already been finalized (lexical contexts already closed) and which
   are just waiting to be built into a blockvector when finalizing the
   associated symtab. */

EXTERN struct pending_block *pending_blocks;


struct subfile_stack
  {
    struct subfile_stack *next;
    char *name;
  };

EXTERN struct subfile_stack *subfile_stack;

#define next_symbol_text(objfile) (*next_symbol_text_func)(objfile)

/* Function to invoke get the next symbol.  Return the symbol name. */

EXTERN char *(*next_symbol_text_func) (struct objfile *);

/* Vector of types defined so far, indexed by their type numbers.
   Used for both stabs and coff.  (In newer sun systems, dbx uses a
   pair of numbers in parens, as in "(SUBFILENUM,NUMWITHINSUBFILE)".
   Then these numbers must be translated through the type_translations
   hash table to get the index into the type vector.)  */

EXTERN struct type **type_vector;

/* Number of elements allocated for type_vector currently.  */

EXTERN int type_vector_length;

/* Initial size of type vector.  Is realloc'd larger if needed, and
   realloc'd down to the size actually used, when completed.  */

#define	INITIAL_TYPE_VECTOR_LENGTH	160

extern void add_free_pendings (struct pending *list);

extern void add_symbol_to_list (struct symbol *symbol,
				struct pending **listhead);

extern struct symbol *find_symbol_in_list (struct pending *list,
					   char *name, int length);

extern void finish_block (struct symbol *symbol,
			  struct pending **listhead,
			  struct pending_block *old_blocks,
			  CORE_ADDR start, CORE_ADDR end,
			  struct objfile *objfile);

extern void really_free_pendings (void *dummy);

extern void start_subfile (char *name, char *dirname);

extern void patch_subfile_names (struct subfile *subfile, char *name);

extern void push_subfile (void);

extern char *pop_subfile (void);

extern struct symtab *end_symtab (CORE_ADDR end_addr,
				  struct objfile *objfile, int section);

/* Defined in stabsread.c.  */

extern void scan_file_globals (struct objfile *objfile);

extern void buildsym_new_init (void);

extern void buildsym_init (void);

extern struct context_stack *push_context (int desc, CORE_ADDR valu);

extern struct context_stack *pop_context (void);

extern void record_line (struct subfile *subfile, int line, CORE_ADDR pc);

extern void start_symtab (char *name, char *dirname, CORE_ADDR start_addr);

extern int hashname (char *name);

extern void free_pending_blocks (void);

/* FIXME: Note that this is used only in buildsym.c and dstread.c,
   which should be fixed to not need direct access to
   record_pending_block. */

extern void record_pending_block (struct objfile *objfile,
				  struct block *block,
				  struct pending_block *opblock);

extern void record_debugformat (char *format);

extern void merge_symbol_lists (struct pending **srclist,
				struct pending **targetlist);

/* The macro table for the compilation unit whose symbols we're
   currently reading.  All the symtabs for this CU will point to this.  */
EXTERN struct macro_table *pending_macros;

#undef EXTERN

#endif /* defined (BUILDSYM_H) */
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright (C) 1986-1996 Free Software Foundation, Inc.
d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d25 3
d30 1
a30 1
   file-reading routines.  
d35 6
a40 4
   Variables declared in this file can be defined by #define-ing
   the name EXTERN to null.  It is used to declare variables that
   are normally extern, but which get defined in a single module
   using this technique.  */
d46 2
a47 1
#define HASHSIZE 127	/* Size of things hashed via hashname() */
d49 2
a50 2
/* Name of source file whose symbol data we are now processing.
   This comes from a symbol of type N_SO. */
d54 2
a55 2
/* Core address of start of text of current source file.
   This too comes from the N_SO symbol. */
d59 3
a61 3
/* The list of sub-source-files within the current individual compilation.
   Each file gets its own symtab with its own linetable and associated info,
   but they all share one blockvector.  */
d64 9
a72 8
{
  struct subfile *next;
  char *name;
  char *dirname;
  struct linetable *line_vector;
  int line_vector_length;
  enum language language;
};
d95 3
a97 3
/* Record the symbols defined for each context in a list.
   We don't create a struct block for the context until we
   know how long to make it.  */
d102 5
a106 5
{
  struct pending *next;
  int nsyms;
  struct symbol *symbol[PENDINGSIZE];
};
d110 5
a114 1
EXTERN struct pending *file_symbols;	/* static at top level, and types */
d116 1
a116 1
EXTERN struct pending *global_symbols;	/* global functions and variables */
d118 1
a118 1
EXTERN struct pending *local_symbols;	/* everything local to lexic context */
d120 8
a127 2
/* Stack representing unclosed lexical contexts
   (that will become blocks, eventually).  */
d130 4
a133 2
{
  /* Outer locals at the time we entered */
d135 1
a135 1
  struct pending *locals;
d137 1
a137 1
  /* Pointer into blocklist as of entry */
d139 1
a139 1
  struct pending_block *old_blocks;
d141 1
a141 1
  /* Name of function, if any, defining context*/
d143 1
a143 1
  struct symbol *name;
d145 1
a145 1
  /* PC where this context starts */
d147 1
a147 1
  CORE_ADDR start_addr;
d149 1
a149 1
  /* Temp slot for exception handling. */
d151 1
a151 1
  CORE_ADDR end_addr;
d153 1
a153 1
  /* For error-checking matching push/pop */
d155 1
a155 1
  int depth;
d157 3
a159 1
};
d171 2
a172 5
/* Macro "function" for popping contexts from the stack.  Pushing is done
   by a real function, push_context.  This returns a pointer to a struct
   context_stack.  */

#define	pop_context() (&context_stack[--context_stack_depth]);
d174 2
a175 2
/* Nonzero if within a function (so symbols should be local,
   if nothing says specifically).  */
d183 9
a191 4
{
  struct pending_block *next;
  struct block *block;
};
d193 1
d195 1
d197 4
a200 4
{
  struct subfile_stack *next;
  char *name;
};
d208 1
a208 1
EXTERN char *(*next_symbol_text_func) PARAMS ((struct objfile *));
d211 4
a214 5
   Used for both stabs and coff.
   (In newer sun systems, dbx uses a pair of numbers in parens,
    as in "(SUBFILENUM,NUMWITHINSUBFILE)".  Then these numbers must be
    translated through the type_translations hash table to get
    the index into the type vector.)  */
d222 2
a223 2
/* Initial size of type vector.  Is realloc'd larger if needed,
   and realloc'd down to the size actually used, when completed.  */
d227 4
a230 2
extern void
add_symbol_to_list PARAMS ((struct symbol *, struct pending **));
d232 2
a233 2
extern struct symbol *
find_symbol_in_list PARAMS ((struct pending *, char *, int));
d235 5
a239 4
extern void
finish_block PARAMS ((struct symbol *, struct pending **,
		      struct pending_block *, CORE_ADDR, CORE_ADDR,
		      struct objfile *));
d241 1
a241 2
extern void
really_free_pendings PARAMS ((int foo));
d243 1
a243 2
extern void
start_subfile PARAMS ((char *, char *));
d245 1
a245 2
extern void
patch_subfile_names PARAMS ((struct subfile *subfile, char *name));
d247 1
a247 2
extern void
push_subfile PARAMS ((void));
d249 1
a249 2
extern char *
pop_subfile PARAMS ((void));
d251 2
a252 2
extern struct symtab *
end_symtab PARAMS ((CORE_ADDR, struct objfile *, int));
d254 1
a254 2
extern void
scan_file_globals PARAMS ((struct objfile *));
d256 1
a256 2
extern void
buildsym_new_init PARAMS ((void));
d258 1
a258 2
extern void
buildsym_init PARAMS ((void));
d260 1
a260 2
extern struct context_stack *
push_context PARAMS ((int, CORE_ADDR));
d262 1
a262 2
extern void
record_line PARAMS ((struct subfile *, int, CORE_ADDR));
d264 1
a264 2
extern void
start_symtab PARAMS ((char *, char *, CORE_ADDR));
d266 1
a266 2
extern int
hashname PARAMS ((char *));
d268 5
a272 2
extern void
free_pending_blocks PARAMS ((void));
d275 2
a276 1
   which should be fixed to not need direct access to make_blockvector. */
d278 3
a280 2
extern struct blockvector *
make_blockvector PARAMS ((struct objfile *));
d282 4
a285 2
/* FIXME: Note that this is used only in buildsym.c and dstread.c,
   which should be fixed to not need direct access to record_pending_block. */
d287 3
a289 3
extern void
record_pending_block PARAMS ((struct objfile *, struct block *,
			      struct pending_block *));
d293 1
a293 1
#endif	/* defined (BUILDSYM_H) */
@


1.1
log
@file buildsym.h was initially added on branch CYGNUS.
@
text
@d1 269
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 293
/* Build symbol tables in GDB's internal format.
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1995, 1996,
   1997, 1998, 1999, 2000, 2002, 2003 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#if !defined (BUILDSYM_H)
#define BUILDSYM_H 1

struct objfile;
struct symbol;

/* This module provides definitions used for creating and adding to
   the symbol table.  These routines are called from various symbol-
   file-reading routines.

   They originated in dbxread.c of gdb-4.2, and were split out to
   make xcoffread.c more maintainable by sharing code.

   Variables declared in this file can be defined by #define-ing the
   name EXTERN to null.  It is used to declare variables that are
   normally extern, but which get defined in a single module using
   this technique.  */

struct block;

#ifndef EXTERN
#define	EXTERN extern
#endif

#define HASHSIZE 127		/* Size of things hashed via
				   hashname() */

/* Name of source file whose symbol data we are now processing.  This
   comes from a symbol of type N_SO. */

EXTERN char *last_source_file;

/* Core address of start of text of current source file.  This too
   comes from the N_SO symbol. */

EXTERN CORE_ADDR last_source_start_addr;

/* The list of sub-source-files within the current individual
   compilation.  Each file gets its own symtab with its own linetable
   and associated info, but they all share one blockvector.  */

struct subfile
  {
    struct subfile *next;
    char *name;
    char *dirname;
    struct linetable *line_vector;
    int line_vector_length;
    enum language language;
    char *debugformat;
  };

EXTERN struct subfile *subfiles;

EXTERN struct subfile *current_subfile;

/* Global variable which, when set, indicates that we are processing a
   .o file compiled with gcc */

EXTERN unsigned char processing_gcc_compilation;

/* When set, we are processing a .o file compiled by sun acc.  This is
   misnamed; it refers to all stabs-in-elf implementations which use
   N_UNDF the way Sun does, including Solaris gcc.  Hopefully all
   stabs-in-elf implementations ever invented will choose to be
   compatible.  */

EXTERN unsigned char processing_acc_compilation;

/* Count symbols as they are processed, for error messages.  */

EXTERN unsigned int symnum;

/* Record the symbols defined for each context in a list.  We don't
   create a struct block for the context until we know how long to
   make it.  */

#define PENDINGSIZE 100

struct pending
  {
    struct pending *next;
    int nsyms;
    struct symbol *symbol[PENDINGSIZE];
  };

/* Here are the three lists that symbols are put on.  */

/* static at top level, and types */

EXTERN struct pending *file_symbols;

/* global functions and variables */

EXTERN struct pending *global_symbols;

/* everything local to lexical context */

EXTERN struct pending *local_symbols;

/* func params local to lexical  context */

EXTERN struct pending *param_symbols;

/* Stack representing unclosed lexical contexts (that will become
   blocks, eventually).  */

struct context_stack
  {
    /* Outer locals at the time we entered */

    struct pending *locals;

    /* Pending func params at the time we entered */

    struct pending *params;

    /* Pointer into blocklist as of entry */

    struct pending_block *old_blocks;

    /* Name of function, if any, defining context */

    struct symbol *name;

    /* PC where this context starts */

    CORE_ADDR start_addr;

    /* Temp slot for exception handling. */

    CORE_ADDR end_addr;

    /* For error-checking matching push/pop */

    int depth;

  };

EXTERN struct context_stack *context_stack;

/* Index of first unused entry in context stack.  */

EXTERN int context_stack_depth;

/* Currently allocated size of context stack.  */

EXTERN int context_stack_size;

/* Non-zero if the context stack is empty.  */
#define outermost_context_p() (context_stack_depth == 0)

/* Nonzero if within a function (so symbols should be local, if
   nothing says specifically).  */

EXTERN int within_function;

/* List of blocks already made (lexical contexts already closed).
   This is used at the end to make the blockvector.  */

struct pending_block
  {
    struct pending_block *next;
    struct block *block;
  };

/* Pointer to the head of a linked list of symbol blocks which have
   already been finalized (lexical contexts already closed) and which
   are just waiting to be built into a blockvector when finalizing the
   associated symtab. */

EXTERN struct pending_block *pending_blocks;


struct subfile_stack
  {
    struct subfile_stack *next;
    char *name;
  };

EXTERN struct subfile_stack *subfile_stack;

#define next_symbol_text(objfile) (*next_symbol_text_func)(objfile)

/* Function to invoke get the next symbol.  Return the symbol name. */

EXTERN char *(*next_symbol_text_func) (struct objfile *);

/* Vector of types defined so far, indexed by their type numbers.
   Used for both stabs and coff.  (In newer sun systems, dbx uses a
   pair of numbers in parens, as in "(SUBFILENUM,NUMWITHINSUBFILE)".
   Then these numbers must be translated through the type_translations
   hash table to get the index into the type vector.)  */

EXTERN struct type **type_vector;

/* Number of elements allocated for type_vector currently.  */

EXTERN int type_vector_length;

/* Initial size of type vector.  Is realloc'd larger if needed, and
   realloc'd down to the size actually used, when completed.  */

#define	INITIAL_TYPE_VECTOR_LENGTH	160

extern void add_free_pendings (struct pending *list);

extern void add_symbol_to_list (struct symbol *symbol,
				struct pending **listhead);

extern struct symbol *find_symbol_in_list (struct pending *list,
					   char *name, int length);

extern void finish_block (struct symbol *symbol,
			  struct pending **listhead,
			  struct pending_block *old_blocks,
			  CORE_ADDR start, CORE_ADDR end,
			  struct objfile *objfile);

extern void really_free_pendings (void *dummy);

extern void start_subfile (char *name, char *dirname);

extern void patch_subfile_names (struct subfile *subfile, char *name);

extern void push_subfile (void);

extern char *pop_subfile (void);

extern struct symtab *end_symtab (CORE_ADDR end_addr,
				  struct objfile *objfile, int section);

/* Defined in stabsread.c.  */

extern void scan_file_globals (struct objfile *objfile);

extern void buildsym_new_init (void);

extern void buildsym_init (void);

extern struct context_stack *push_context (int desc, CORE_ADDR valu);

extern struct context_stack *pop_context (void);

extern void record_line (struct subfile *subfile, int line, CORE_ADDR pc);

extern void start_symtab (char *name, char *dirname, CORE_ADDR start_addr);

extern int hashname (char *name);

extern void free_pending_blocks (void);

/* FIXME: Note that this is used only in buildsym.c and dstread.c,
   which should be fixed to not need direct access to
   record_pending_block. */

extern void record_pending_block (struct objfile *objfile,
				  struct block *block,
				  struct pending_block *opblock);

extern void record_debugformat (char *format);

extern void merge_symbol_lists (struct pending **srclist,
				struct pending **targetlist);

/* The macro table for the compilation unit whose symbols we're
   currently reading.  All the symtabs for this CU will point to this.  */
EXTERN struct macro_table *pending_macros;

#undef EXTERN

#endif /* defined (BUILDSYM_H) */
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 269
/* Build symbol tables in GDB's internal format.
   Copyright (C) 1986-1996 Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#if !defined (BUILDSYM_H)
#define BUILDSYM_H 1

/* This module provides definitions used for creating and adding to
   the symbol table.  These routines are called from various symbol-
   file-reading routines.  

   They originated in dbxread.c of gdb-4.2, and were split out to
   make xcoffread.c more maintainable by sharing code.

   Variables declared in this file can be defined by #define-ing
   the name EXTERN to null.  It is used to declare variables that
   are normally extern, but which get defined in a single module
   using this technique.  */

#ifndef EXTERN
#define	EXTERN extern
#endif

#define HASHSIZE 127	/* Size of things hashed via hashname() */

/* Name of source file whose symbol data we are now processing.
   This comes from a symbol of type N_SO. */

EXTERN char *last_source_file;

/* Core address of start of text of current source file.
   This too comes from the N_SO symbol. */

EXTERN CORE_ADDR last_source_start_addr;

/* The list of sub-source-files within the current individual compilation.
   Each file gets its own symtab with its own linetable and associated info,
   but they all share one blockvector.  */

struct subfile
{
  struct subfile *next;
  char *name;
  char *dirname;
  struct linetable *line_vector;
  int line_vector_length;
  enum language language;
};

EXTERN struct subfile *subfiles;

EXTERN struct subfile *current_subfile;

/* Global variable which, when set, indicates that we are processing a
   .o file compiled with gcc */

EXTERN unsigned char processing_gcc_compilation;

/* When set, we are processing a .o file compiled by sun acc.  This is
   misnamed; it refers to all stabs-in-elf implementations which use
   N_UNDF the way Sun does, including Solaris gcc.  Hopefully all
   stabs-in-elf implementations ever invented will choose to be
   compatible.  */

EXTERN unsigned char processing_acc_compilation;

/* Count symbols as they are processed, for error messages.  */

EXTERN unsigned int symnum;

/* Record the symbols defined for each context in a list.
   We don't create a struct block for the context until we
   know how long to make it.  */

#define PENDINGSIZE 100

struct pending
{
  struct pending *next;
  int nsyms;
  struct symbol *symbol[PENDINGSIZE];
};

/* Here are the three lists that symbols are put on.  */

EXTERN struct pending *file_symbols;	/* static at top level, and types */

EXTERN struct pending *global_symbols;	/* global functions and variables */

EXTERN struct pending *local_symbols;	/* everything local to lexic context */

/* Stack representing unclosed lexical contexts
   (that will become blocks, eventually).  */

struct context_stack
{
  /* Outer locals at the time we entered */

  struct pending *locals;

  /* Pointer into blocklist as of entry */

  struct pending_block *old_blocks;

  /* Name of function, if any, defining context*/

  struct symbol *name;

  /* PC where this context starts */

  CORE_ADDR start_addr;

  /* Temp slot for exception handling. */

  CORE_ADDR end_addr;

  /* For error-checking matching push/pop */

  int depth;

};

EXTERN struct context_stack *context_stack;

/* Index of first unused entry in context stack.  */

EXTERN int context_stack_depth;

/* Currently allocated size of context stack.  */

EXTERN int context_stack_size;

/* Macro "function" for popping contexts from the stack.  Pushing is done
   by a real function, push_context.  This returns a pointer to a struct
   context_stack.  */

#define	pop_context() (&context_stack[--context_stack_depth]);

/* Nonzero if within a function (so symbols should be local,
   if nothing says specifically).  */

EXTERN int within_function;

/* List of blocks already made (lexical contexts already closed).
   This is used at the end to make the blockvector.  */

struct pending_block
{
  struct pending_block *next;
  struct block *block;
};


struct subfile_stack
{
  struct subfile_stack *next;
  char *name;
};

EXTERN struct subfile_stack *subfile_stack;

#define next_symbol_text(objfile) (*next_symbol_text_func)(objfile)

/* Function to invoke get the next symbol.  Return the symbol name. */

EXTERN char *(*next_symbol_text_func) PARAMS ((struct objfile *));

/* Vector of types defined so far, indexed by their type numbers.
   Used for both stabs and coff.
   (In newer sun systems, dbx uses a pair of numbers in parens,
    as in "(SUBFILENUM,NUMWITHINSUBFILE)".  Then these numbers must be
    translated through the type_translations hash table to get
    the index into the type vector.)  */

EXTERN struct type **type_vector;

/* Number of elements allocated for type_vector currently.  */

EXTERN int type_vector_length;

/* Initial size of type vector.  Is realloc'd larger if needed,
   and realloc'd down to the size actually used, when completed.  */

#define	INITIAL_TYPE_VECTOR_LENGTH	160

extern void
add_symbol_to_list PARAMS ((struct symbol *, struct pending **));

extern struct symbol *
find_symbol_in_list PARAMS ((struct pending *, char *, int));

extern void
finish_block PARAMS ((struct symbol *, struct pending **,
		      struct pending_block *, CORE_ADDR, CORE_ADDR,
		      struct objfile *));

extern void
really_free_pendings PARAMS ((int foo));

extern void
start_subfile PARAMS ((char *, char *));

extern void
patch_subfile_names PARAMS ((struct subfile *subfile, char *name));

extern void
push_subfile PARAMS ((void));

extern char *
pop_subfile PARAMS ((void));

extern struct symtab *
end_symtab PARAMS ((CORE_ADDR, struct objfile *, int));

extern void
scan_file_globals PARAMS ((struct objfile *));

extern void
buildsym_new_init PARAMS ((void));

extern void
buildsym_init PARAMS ((void));

extern struct context_stack *
push_context PARAMS ((int, CORE_ADDR));

extern void
record_line PARAMS ((struct subfile *, int, CORE_ADDR));

extern void
start_symtab PARAMS ((char *, char *, CORE_ADDR));

extern int
hashname PARAMS ((char *));

extern void
free_pending_blocks PARAMS ((void));

/* FIXME: Note that this is used only in buildsym.c and dstread.c,
   which should be fixed to not need direct access to make_blockvector. */

extern struct blockvector *
make_blockvector PARAMS ((struct objfile *));

/* FIXME: Note that this is used only in buildsym.c and dstread.c,
   which should be fixed to not need direct access to record_pending_block. */

extern void
record_pending_block PARAMS ((struct objfile *, struct block *,
			      struct pending_block *));

#undef EXTERN

#endif	/* defined (BUILDSYM_H) */
@
