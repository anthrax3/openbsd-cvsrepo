head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.48
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.44
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.46
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.38
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.42
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.40
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.36
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.34
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.32
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.30
	OPENBSD_5_0:1.4.0.28
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.26
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.24
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2004.12.27.14.00.38;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.21.20.23.09;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.38.14;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.18.41;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.11.32;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.08.54;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.18.42;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@/* Source-language-related definitions for GDB.

   Copyright 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2003,
   2004 Free Software Foundation, Inc.

   Contributed by the Department of Computer Science at the State University
   of New York at Buffalo.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#if !defined (LANGUAGE_H)
#define LANGUAGE_H 1

/* Forward decls for prototypes */
struct value;
struct objfile;
struct expression;
struct ui_file;

/* enum exp_opcode;     ANSI's `wisdom' didn't include forward enum decls. */

/* This used to be included to configure GDB for one or more specific
   languages.  Now it is left out to configure for all of them.  FIXME.  */
/* #include "lang_def.h" */
#define	_LANG_c
#define	_LANG_m2
#define  _LANG_fortran
#define  _LANG_pascal

#define MAX_FORTRAN_DIMS  7	/* Maximum number of F77 array dims */

/* range_mode ==
   range_mode_auto:   range_check set automatically to default of language.
   range_mode_manual: range_check set manually by user.  */

extern enum range_mode
  {
    range_mode_auto, range_mode_manual
  }
range_mode;

/* range_check ==
   range_check_on:    Ranges are checked in GDB expressions, producing errors.
   range_check_warn:  Ranges are checked, producing warnings.
   range_check_off:   Ranges are not checked in GDB expressions.  */

extern enum range_check
  {
    range_check_off, range_check_warn, range_check_on
  }
range_check;

/* type_mode ==
   type_mode_auto:   type_check set automatically to default of language
   type_mode_manual: type_check set manually by user. */

extern enum type_mode
  {
    type_mode_auto, type_mode_manual
  }
type_mode;

/* type_check ==
   type_check_on:    Types are checked in GDB expressions, producing errors.
   type_check_warn:  Types are checked, producing warnings.
   type_check_off:   Types are not checked in GDB expressions.  */

extern enum type_check
  {
    type_check_off, type_check_warn, type_check_on
  }
type_check;

/* case_mode ==
   case_mode_auto:   case_sensitivity set upon selection of scope 
   case_mode_manual: case_sensitivity set only by user.  */

extern enum case_mode
  {
    case_mode_auto, case_mode_manual
  }
case_mode;

/* array_ordering ==
   array_row_major:     Arrays are in row major order
   array_column_major:  Arrays are in column major order.*/

extern enum array_ordering
  {
    array_row_major, array_column_major
  } 
array_ordering;


/* case_sensitivity ==
   case_sensitive_on:   Case sensitivity in name matching is used
   case_sensitive_off:  Case sensitivity in name matching is not used  */

extern enum case_sensitivity
  {
    case_sensitive_on, case_sensitive_off
  }
case_sensitivity;

/* Per architecture (OS/ABI) language information.  */

struct language_arch_info
{
  /* Its primitive types.  This is a vector ended by a NULL pointer.
     These types can be specified by name in parsing types in
     expressions, regardless of whether the program being debugged
     actually defines such a type.  */
  struct type **primitive_type_vector;
  /* Type of elements of strings. */
  struct type *string_char_type;
};

struct type *language_string_char_type (const struct language_defn *l,
					struct gdbarch *gdbarch);

struct type *language_lookup_primitive_type_by_name (const struct language_defn *l,
						     struct gdbarch *gdbarch,
						     const char *name);

/* Structure tying together assorted information about a language.  */

struct language_defn
  {
    /* Name of the language */

    char *la_name;

    /* its symtab language-enum (defs.h) */

    enum language la_language;

    /* Its builtin types.  This is a vector ended by a NULL pointer.  These
       types can be specified by name in parsing types in expressions,
       regardless of whether the program being debugged actually defines
       such a type.  */

    struct type **const *la_builtin_type_vector;

    /* Default range checking */

    enum range_check la_range_check;

    /* Default type checking */

    enum type_check la_type_check;

    /* Default case sensitivity */
    enum case_sensitivity la_case_sensitivity;

    /* Multi-dimensional array ordering */
    enum array_ordering la_array_ordering;

    /* Definitions related to expression printing, prefixifying, and
       dumping */

    const struct exp_descriptor *la_exp_desc;

    /* Parser function. */

    int (*la_parser) (void);

    /* Parser error function */

    void (*la_error) (char *);

    /* Given an expression *EXPP created by prefixifying the result of
       la_parser, perform any remaining processing necessary to complete
       its translation.  *EXPP may change; la_post_parser is responsible 
       for releasing its previous contents, if necessary.  If 
       VOID_CONTEXT_P, then no value is expected from the expression.  */

    void (*la_post_parser) (struct expression ** expp, int void_context_p);

    void (*la_printchar) (int ch, struct ui_file * stream);

    void (*la_printstr) (struct ui_file * stream, char *string,
			 unsigned int length, int width,
			 int force_ellipses);

    void (*la_emitchar) (int ch, struct ui_file * stream, int quoter);

    struct type *(*la_fund_type) (struct objfile *, int);

    /* Print a type using syntax appropriate for this language. */

    void (*la_print_type) (struct type *, char *, struct ui_file *, int,
			   int);

    /* Print a value using syntax appropriate for this language. */

    int (*la_val_print) (struct type *, char *, int, CORE_ADDR,
			 struct ui_file *, int, int, int,
			 enum val_prettyprint);

    /* Print a top-level value using syntax appropriate for this language. */

    int (*la_value_print) (struct value *, struct ui_file *,
			   int, enum val_prettyprint);

    /* PC is possibly an unknown languages trampoline.
       If that PC falls in a trampoline belonging to this language,
       return the address of the first pc in the real function, or 0
       if it isn't a language tramp for this language.  */
    CORE_ADDR (*skip_trampoline) (CORE_ADDR pc);

    /* Now come some hooks for lookup_symbol.  */

    /* If this is non-NULL, lookup_symbol will do the 'field_of_this'
       check, using this function to find the value of this.  */

    /* FIXME: carlton/2003-05-19: Audit all the language_defn structs
       to make sure we're setting this appropriately: I'm sure it
       could be NULL in more languages.  */

    struct value *(*la_value_of_this) (int complain);

    /* This is a function that lookup_symbol will call when it gets to
       the part of symbol lookup where C looks up static and global
       variables.  */

    struct symbol *(*la_lookup_symbol_nonlocal) (const char *,
						 const char *,
						 const struct block *,
						 const domain_enum,
						 struct symtab **);

    /* Find the definition of the type with the given name.  */
    struct type *(*la_lookup_transparent_type) (const char *);

    /* Return demangled language symbol, or NULL.  */
    char *(*la_demangle) (const char *mangled, int options);

    /* Return class name of a mangled method name or NULL.  */
    char *(*la_class_name_from_physname) (const char *physname);

    /* Table for printing expressions */

    const struct op_print *la_op_print_tab;

    /* Zero if the language has first-class arrays.  True if there are no
       array values, and array objects decay to pointers, as in C. */

    char c_style_arrays;

    /* Index to use for extracting the first element of a string. */
    char string_lower_bound;

    /* Type of elements of strings. */
    struct type **string_char_type;

    /* The list of characters forming word boundaries.  */
    char *(*la_word_break_characters) (void);

    /* The per-architecture (OS/ABI) language information.  */
    void (*la_language_arch_info) (struct gdbarch *,
				   struct language_arch_info *);

    /* Add fields above this point, so the magic number is always last. */
    /* Magic number for compat checking */

    long la_magic;

  };

#define LANG_MAGIC	910823L

/* Pointer to the language_defn for our current language.  This pointer
   always points to *some* valid struct; it can be used without checking
   it for validity.

   The current language affects expression parsing and evaluation
   (FIXME: it might be cleaner to make the evaluation-related stuff
   separate exp_opcodes for each different set of semantics.  We
   should at least think this through more clearly with respect to
   what happens if the language is changed between parsing and
   evaluation) and printing of things like types and arrays.  It does
   *not* affect symbol-reading-- each source file in a symbol-file has
   its own language and we should keep track of that regardless of the
   language when symbols are read.  If we want some manual setting for
   the language of symbol files (e.g. detecting when ".c" files are
   C++), it should be a separate setting from the current_language.  */

extern const struct language_defn *current_language;

/* Pointer to the language_defn expected by the user, e.g. the language
   of main(), or the language we last mentioned in a message, or C.  */

extern const struct language_defn *expected_language;

/* language_mode == 
   language_mode_auto:   current_language automatically set upon selection
   of scope (e.g. stack frame)
   language_mode_manual: current_language set only by user.  */

extern enum language_mode
  {
    language_mode_auto, language_mode_manual
  }
language_mode;

/* These macros define the behaviour of the expression 
   evaluator.  */

/* Should we strictly type check expressions? */
#define STRICT_TYPE (type_check != type_check_off)

/* Should we range check values against the domain of their type? */
#define RANGE_CHECK (range_check != range_check_off)

/* "cast" really means conversion */
/* FIXME -- should be a setting in language_defn */
#define CAST_IS_CONVERSION (current_language->la_language == language_c  || \
			    current_language->la_language == language_cplus || \
			    current_language->la_language == language_objc)

extern void language_info (int);

extern enum language set_language (enum language);


/* This page contains functions that return things that are
   specific to languages.  Each of these functions is based on
   the current setting of working_lang, which the user sets
   with the "set language" command. */

#define create_fundamental_type(objfile,typeid) \
  (current_language->la_fund_type(objfile, typeid))

#define LA_PRINT_TYPE(type,varstring,stream,show,level) \
  (current_language->la_print_type(type,varstring,stream,show,level))

#define LA_VAL_PRINT(type,valaddr,offset,addr,stream,fmt,deref,recurse,pretty) \
  (current_language->la_val_print(type,valaddr,offset,addr,stream,fmt,deref, \
				  recurse,pretty))
#define LA_VALUE_PRINT(val,stream,fmt,pretty) \
  (current_language->la_value_print(val,stream,fmt,pretty))

#define LA_PRINT_CHAR(ch, stream) \
  (current_language->la_printchar(ch, stream))
#define LA_PRINT_STRING(stream, string, length, width, force_ellipses) \
  (current_language->la_printstr(stream, string, length, width, force_ellipses))
#define LA_EMIT_CHAR(ch, stream, quoter) \
  (current_language->la_emitchar(ch, stream, quoter))

/* Test a character to decide whether it can be printed in literal form
   or needs to be printed in another representation.  For example,
   in C the literal form of the character with octal value 141 is 'a'
   and the "other representation" is '\141'.  The "other representation"
   is program language dependent. */

#define PRINT_LITERAL_FORM(c)		\
  ((c) >= 0x20				\
   && ((c) < 0x7F || (c) >= 0xA0)	\
   && (!sevenbit_strings || (c) < 0x80))

#if 0
/* FIXME: cagney/2000-03-04: This function does not appear to be used.
   It can be deleted once 5.0 has been released. */
/* Return a string that contains the hex digits of the number.  No preceeding
   "0x" */

extern char *longest_raw_hex_string (LONGEST);
#endif

/* Type predicates */

extern int simple_type (struct type *);

extern int ordered_type (struct type *);

extern int same_type (struct type *, struct type *);

extern int integral_type (struct type *);

extern int numeric_type (struct type *);

extern int character_type (struct type *);

extern int boolean_type (struct type *);

extern int float_type (struct type *);

extern int pointer_type (struct type *);

extern int structured_type (struct type *);

/* Checks Binary and Unary operations for semantic type correctness */
/* FIXME:  Does not appear to be used */
#define unop_type_check(v,o) binop_type_check((v),NULL,(o))

extern void binop_type_check (struct value *, struct value *, int);

/* Error messages */

extern void op_error (const char *lhs, enum exp_opcode,
		      const char *rhs);

extern void type_error (const char *, ...) ATTR_FORMAT (printf, 1, 2);

extern void range_error (const char *, ...) ATTR_FORMAT (printf, 1, 2);

/* Data:  Does this value represent "truth" to the current language?  */

extern int value_true (struct value *);

extern struct type *lang_bool_type (void);

/* The type used for Boolean values in the current language. */
#define LA_BOOL_TYPE lang_bool_type ()

/* Misc:  The string representing a particular enum language.  */

extern enum language language_enum (char *str);

extern const struct language_defn *language_def (enum language);

extern char *language_str (enum language);

/* Add a language to the set known by GDB (at initialization time).  */

extern void add_language (const struct language_defn *);

extern enum language get_frame_language (void);	/* In stack.c */

/* Check for a language-specific trampoline. */

extern CORE_ADDR skip_language_trampoline (CORE_ADDR pc);

/* Return demangled language symbol, or NULL.  */
extern char *language_demangle (const struct language_defn *current_language, 
				const char *mangled, int options);

/* Return class name from physname, or NULL.  */
extern char *language_class_name_from_physname (const struct language_defn *,
					        const char *physname);

/* Splitting strings into words.  */
extern char *default_word_break_characters (void);

#endif /* defined (LANGUAGE_H) */
@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@d99 11
d120 1
a120 16
/* Information for doing language dependent formatting of printed values. */

struct language_format_info
  {
    /* The format that can be passed directly to standard C printf functions
       to generate a completely formatted value in the format appropriate for
       the language. */

    char *la_format;

    /* The prefix to be used when directly printing a value, or constructing
       a standard C printf format.  This generally is everything up to the
       conversion specification (the part introduced by the '%' character
       and terminated by the conversion specifier character). */

    char *la_format_prefix;
d122 17
a138 13
    /* The conversion specifier.  This is generally everything after the
       field width and precision, typically only a single character such
       as 'o' for octal format or 'x' for hexadecimal format. */

    char *la_format_specifier;

    /* The suffix to be used when directly printing a value, or constructing
       a standard C printf format.  This generally is everything after the
       conversion specification (the part introduced by the '%' character
       and terminated by the conversion specifier character). */

    char *la_format_suffix;	/* Suffix for custom format string */
  };
d170 3
d186 8
d253 2
a254 15
    /* Base 2 (binary) formats. */

    struct language_format_info la_binary_format;

    /* Base 8 (octal) formats. */

    struct language_format_info la_octal_format;

    /* Base 10 (decimal) formats */

    struct language_format_info la_decimal_format;

    /* Base 16 (hexadecimal) formats */

    struct language_format_info la_hex_format;
d274 4
a357 41
/* Return a format string for printf that will print a number in one of
   the local (language-specific) formats.  Result is static and is
   overwritten by the next call.  Takes printf options like "08" or "l"
   (to produce e.g. %08x or %lx).  */

#define local_binary_format() \
  (current_language->la_binary_format.la_format)
#define local_binary_format_prefix() \
  (current_language->la_binary_format.la_format_prefix)
#define local_binary_format_specifier() \
  (current_language->la_binary_format.la_format_specifier)
#define local_binary_format_suffix() \
  (current_language->la_binary_format.la_format_suffix)

#define local_octal_format() \
  (current_language->la_octal_format.la_format)
#define local_octal_format_prefix() \
  (current_language->la_octal_format.la_format_prefix)
#define local_octal_format_specifier() \
  (current_language->la_octal_format.la_format_specifier)
#define local_octal_format_suffix() \
  (current_language->la_octal_format.la_format_suffix)

#define local_decimal_format() \
  (current_language->la_decimal_format.la_format)
#define local_decimal_format_prefix() \
  (current_language->la_decimal_format.la_format_prefix)
#define local_decimal_format_specifier() \
  (current_language->la_decimal_format.la_format_specifier)
#define local_decimal_format_suffix() \
  (current_language->la_decimal_format.la_format_suffix)

#define local_hex_format() \
  (current_language->la_hex_format.la_format)
#define local_hex_format_prefix() \
  (current_language->la_hex_format.la_format_prefix)
#define local_hex_format_specifier() \
  (current_language->la_hex_format.la_format_specifier)
#define local_hex_format_suffix() \
  (current_language->la_hex_format.la_format_suffix)

a375 11
/* Return a format string for printf that will print a number in one of
   the local (language-specific) formats.  Result is static and is
   overwritten by the next call.  Takes printf options like "08" or "l"
   (to produce e.g. %08x or %lx).  */

extern char *local_decimal_format_custom (char *);	/* language.c */

extern char *local_octal_format_custom (char *);	/* language.c */

extern char *local_hex_format_custom (char *);	/* language.c */

a384 8
/* Return a string that contains a number formatted in one of the local
   (language-specific) formats.  Result is static and is overwritten by
   the next call.  Takes printf options like "08l" or "l".  */

extern char *local_hex_string (LONGEST);	/* language.c */

extern char *local_hex_string_custom (LONGEST, char *);	/* language.c */

d452 4
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 4
a5 1
   Copyright 1991, 1992 Free Software Foundation, Inc.
d9 1
a9 1
This file is part of GDB.
d11 14
a24 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d29 1
a29 1
#ifdef __STDC__		/* Forward decls for prototypes */
d33 3
a35 2
/* enum exp_opcode;	ANSI's `wisdom' didn't include forward enum decls. */
#endif
d38 1
a38 1
   languages.  Now it is shortcutted to configure for all of them.  FIXME.  */
d42 2
a43 2
#define	_LANG_chill
#define _LANG_fortran
d45 1
a45 1
#define MAX_FORTRAN_DIMS  7   /* Maximum number of F77 array dims */ 
d51 5
a55 1
extern enum range_mode {range_mode_auto, range_mode_manual} range_mode;
d63 4
a66 1
  {range_check_off, range_check_warn, range_check_on} range_check;
d72 5
a76 1
extern enum type_mode {type_mode_auto, type_mode_manual} type_mode;
d84 24
a107 1
  {type_check_off, type_check_warn, type_check_on} type_check;
d112 4
a115 4
{
  /* The format that can be passed directly to standard C printf functions
     to generate a completely formatted value in the format appropriate for
     the language. */
d117 1
a117 1
  char *la_format;
d119 4
a122 4
  /* The prefix to be used when directly printing a value, or constructing
     a standard C printf format.  This generally is everything up to the
     conversion specification (the part introduced by the '%' character
     and terminated by the conversion specifier character). */
d124 1
a124 1
  char *la_format_prefix;
d126 3
a128 3
  /* The conversion specifier.  This is generally everything after the
     field width and precision, typically only a single character such
     as 'o' for octal format or 'x' for hexadecimal format. */
d130 1
a130 1
  char *la_format_specifier;
d132 4
a135 4
  /* The suffix to be used when directly printing a value, or constructing
     a standard C printf format.  This generally is everything after the
     conversion specification (the part introduced by the '%' character
     and terminated by the conversion specifier character). */
d137 2
a138 2
  char *la_format_suffix;		/* Suffix for custom format string */
};
d143 29
a171 4
{
  /* Name of the language */
  
  char *la_name;
d173 1
a173 1
  /* its symtab language-enum (defs.h) */
d175 1
a175 1
  enum language la_language;
d177 1
a177 4
  /* Its builtin types.  This is a vector ended by a NULL pointer.  These
     types can be specified by name in parsing types in expressions,
     regardless of whether the program being debugged actually defines
     such a type.  */
d179 1
a179 1
  struct type ** const *la_builtin_type_vector;
d181 1
a181 1
  /* Default range checking */
d183 1
a183 1
  enum range_check la_range_check;
d185 3
a187 1
  /* Default type checking */
d189 1
a189 1
  enum type_check la_type_check;
d191 1
a191 3
  /* Parser function. */
  
  int (*la_parser) PARAMS((void));
d193 1
a193 1
  /* Parser error function */
d195 2
a196 1
  void (*la_error) PARAMS ((char *));
d198 1
a198 3
  /* Evaluate an expression. */
  struct value * (*evaluate_exp) PARAMS ((struct type*, struct expression *, 
					  int *, enum noside));
d200 3
a202 1
  void (*la_printchar) PARAMS ((int, GDB_FILE *));
d204 1
a204 1
  void (*la_printstr) PARAMS ((GDB_FILE *, char *, unsigned int, int));
d206 2
a207 1
  struct type *(*la_fund_type) PARAMS ((struct objfile *, int));
d209 5
a213 1
  /* Print a type using syntax appropriate for this language. */
d215 1
a215 1
  void (*la_print_type) PARAMS ((struct type *, char *, GDB_FILE *, int, int));
d217 2
a218 1
  /* Print a value using syntax appropriate for this language. */
d220 3
a222 2
  int (*la_val_print) PARAMS ((struct type *, char *,  CORE_ADDR, GDB_FILE *,
			       int, int, int, enum val_prettyprint));
d224 1
a224 1
  /* Print a top-level value using syntax appropriate for this language. */
d226 3
a228 2
  int (*la_value_print) PARAMS ((struct value *, GDB_FILE *,
				 int, enum val_prettyprint));
d230 5
a234 1
  /* Base 2 (binary) formats. */
d236 2
a237 1
  struct language_format_info la_binary_format;
d239 2
a240 1
  /* Base 8 (octal) formats. */
d242 1
a242 1
  struct language_format_info la_octal_format;
d244 1
a244 1
  /* Base 10 (decimal) formats */
d246 1
a246 1
  struct language_format_info la_decimal_format;
d248 1
a248 1
  /* Base 16 (hexadecimal) formats */
d250 1
a250 1
  struct language_format_info la_hex_format;
d252 1
a252 1
  /* Table for printing expressions */
d254 1
a254 1
  const struct op_print *la_op_print_tab;
d256 1
a256 2
  /* Zero if the language has first-class arrays.  True if there are no
     array values, and array objects decay to pointers, as in C. */
d258 1
a258 1
  char c_style_arrays;
d260 1
a260 2
  /* Index to use for extracting the first element of a string. */
  char string_lower_bound;
d262 2
a263 2
  /* Type of elements of strings. */
  struct type **string_char_type;
d265 1
a265 2
  /* Add fields above this point, so the magic number is always last. */
  /* Magic number for compat checking */
d267 2
a268 1
  long la_magic;
d270 12
a281 1
};
d299 1
a299 1
   C++), it should be a seprate setting from the current_language.  */
d310 1
a310 1
			 of scope (e.g. stack frame)
d314 4
a317 1
  {language_mode_auto, language_mode_manual} language_mode;
d331 2
a332 1
			    current_language->la_language == language_cplus)
d334 1
a334 2
extern void
language_info PARAMS ((int));
d336 2
a337 2
extern void
set_language PARAMS ((enum language));
a338 1

d350 2
a351 2
#define LA_VAL_PRINT(type,valaddr,addr,stream,fmt,deref,recurse,pretty) \
  (current_language->la_val_print(type,valaddr,addr,stream,fmt,deref, \
d399 4
a402 2
#define LA_PRINT_STRING(stream, string, length, force_ellipses) \
  (current_language->la_printstr(stream, string, length, force_ellipses))
d410 4
a413 2
#define PRINT_LITERAL_FORM(c) \
  ((c)>=0x20 && ((c)<0x7F || (c)>=0xA0) && (!sevenbit_strings || (c)<0x80))
d420 1
a420 2
extern char *
local_decimal_format_custom PARAMS ((char *));	/* language.c */
d422 1
a422 2
extern char *
local_octal_format_custom PARAMS ((char *));	/* language.c */
d424 10
a433 2
extern char *
local_hex_format_custom PARAMS ((char *));	/* language.c */
d437 1
a437 1
   the next call.  Takes printf options like "08" or "l".  */
d439 1
a439 2
extern char *
local_hex_string PARAMS ((unsigned long));		/* language.c */
d441 1
a441 2
extern char *
local_hex_string_custom PARAMS ((unsigned long, char *)); /* language.c */
d445 1
a445 2
extern int
simple_type PARAMS ((struct type *));
d447 1
a447 2
extern int
ordered_type PARAMS ((struct type *));
d449 1
a449 2
extern int
same_type PARAMS ((struct type *, struct type *));
d451 1
a451 2
extern int
integral_type PARAMS ((struct type *));
d453 1
a453 2
extern int
numeric_type PARAMS ((struct type *));
d455 1
a455 2
extern int
character_type PARAMS ((struct type *));
d457 1
a457 2
extern int
boolean_type PARAMS ((struct type *));
d459 1
a459 2
extern int
float_type PARAMS ((struct type *));
d461 1
a461 2
extern int
pointer_type PARAMS ((struct type *));
d463 1
a463 2
extern int
structured_type PARAMS ((struct type *));
d469 1
a469 2
extern void
binop_type_check PARAMS ((struct value *, struct value *, int));
d473 4
a476 2
extern void
op_error PARAMS ((char *fmt, enum exp_opcode, int));
d478 1
a478 12
#define type_op_error(f,o) \
   op_error((f),(o),type_check==type_check_on ? 1 : 0)
#define range_op_error(f,o) \
   op_error((f),(o),range_check==range_check_on ? 1 : 0)

extern void
type_error PARAMS ((char *, ...))
     ATTR_FORMAT(printf, 1, 2);

void
range_error PARAMS ((char *, ...))
     ATTR_FORMAT(printf, 1, 2);
d482 1
a482 2
extern int
value_true PARAMS ((struct value *));
d484 1
a484 1
extern struct type * lang_bool_type PARAMS ((void));
d491 1
a491 2
extern const struct language_defn *
language_def PARAMS ((enum language));
d493 3
a495 2
extern char *
language_str PARAMS ((enum language));
d499 11
a509 2
extern void
add_language PARAMS ((const struct language_defn *));
d511 2
a512 2
extern enum language
get_frame_language PARAMS ((void));		/* In stack.c */
d514 1
a514 1
#endif	/* defined (LANGUAGE_H) */
@


1.1
log
@file language.h was initially added on branch CYGNUS.
@
text
@d1 431
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 514
/* Source-language-related definitions for GDB.

   Copyright 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2003,
   2004 Free Software Foundation, Inc.

   Contributed by the Department of Computer Science at the State University
   of New York at Buffalo.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#if !defined (LANGUAGE_H)
#define LANGUAGE_H 1

/* Forward decls for prototypes */
struct value;
struct objfile;
struct expression;
struct ui_file;

/* enum exp_opcode;     ANSI's `wisdom' didn't include forward enum decls. */

/* This used to be included to configure GDB for one or more specific
   languages.  Now it is left out to configure for all of them.  FIXME.  */
/* #include "lang_def.h" */
#define	_LANG_c
#define	_LANG_m2
#define  _LANG_fortran
#define  _LANG_pascal

#define MAX_FORTRAN_DIMS  7	/* Maximum number of F77 array dims */

/* range_mode ==
   range_mode_auto:   range_check set automatically to default of language.
   range_mode_manual: range_check set manually by user.  */

extern enum range_mode
  {
    range_mode_auto, range_mode_manual
  }
range_mode;

/* range_check ==
   range_check_on:    Ranges are checked in GDB expressions, producing errors.
   range_check_warn:  Ranges are checked, producing warnings.
   range_check_off:   Ranges are not checked in GDB expressions.  */

extern enum range_check
  {
    range_check_off, range_check_warn, range_check_on
  }
range_check;

/* type_mode ==
   type_mode_auto:   type_check set automatically to default of language
   type_mode_manual: type_check set manually by user. */

extern enum type_mode
  {
    type_mode_auto, type_mode_manual
  }
type_mode;

/* type_check ==
   type_check_on:    Types are checked in GDB expressions, producing errors.
   type_check_warn:  Types are checked, producing warnings.
   type_check_off:   Types are not checked in GDB expressions.  */

extern enum type_check
  {
    type_check_off, type_check_warn, type_check_on
  }
type_check;

/* case_mode ==
   case_mode_auto:   case_sensitivity set upon selection of scope 
   case_mode_manual: case_sensitivity set only by user.  */

extern enum case_mode
  {
    case_mode_auto, case_mode_manual
  }
case_mode;

/* case_sensitivity ==
   case_sensitive_on:   Case sensitivity in name matching is used
   case_sensitive_off:  Case sensitivity in name matching is not used  */

extern enum case_sensitivity
  {
    case_sensitive_on, case_sensitive_off
  }
case_sensitivity;

/* Information for doing language dependent formatting of printed values. */

struct language_format_info
  {
    /* The format that can be passed directly to standard C printf functions
       to generate a completely formatted value in the format appropriate for
       the language. */

    char *la_format;

    /* The prefix to be used when directly printing a value, or constructing
       a standard C printf format.  This generally is everything up to the
       conversion specification (the part introduced by the '%' character
       and terminated by the conversion specifier character). */

    char *la_format_prefix;

    /* The conversion specifier.  This is generally everything after the
       field width and precision, typically only a single character such
       as 'o' for octal format or 'x' for hexadecimal format. */

    char *la_format_specifier;

    /* The suffix to be used when directly printing a value, or constructing
       a standard C printf format.  This generally is everything after the
       conversion specification (the part introduced by the '%' character
       and terminated by the conversion specifier character). */

    char *la_format_suffix;	/* Suffix for custom format string */
  };

/* Structure tying together assorted information about a language.  */

struct language_defn
  {
    /* Name of the language */

    char *la_name;

    /* its symtab language-enum (defs.h) */

    enum language la_language;

    /* Its builtin types.  This is a vector ended by a NULL pointer.  These
       types can be specified by name in parsing types in expressions,
       regardless of whether the program being debugged actually defines
       such a type.  */

    struct type **const *la_builtin_type_vector;

    /* Default range checking */

    enum range_check la_range_check;

    /* Default type checking */

    enum type_check la_type_check;

    /* Default case sensitivity */
    enum case_sensitivity la_case_sensitivity;

    /* Definitions related to expression printing, prefixifying, and
       dumping */

    const struct exp_descriptor *la_exp_desc;

    /* Parser function. */

    int (*la_parser) (void);

    /* Parser error function */

    void (*la_error) (char *);

    void (*la_printchar) (int ch, struct ui_file * stream);

    void (*la_printstr) (struct ui_file * stream, char *string,
			 unsigned int length, int width,
			 int force_ellipses);

    void (*la_emitchar) (int ch, struct ui_file * stream, int quoter);

    struct type *(*la_fund_type) (struct objfile *, int);

    /* Print a type using syntax appropriate for this language. */

    void (*la_print_type) (struct type *, char *, struct ui_file *, int,
			   int);

    /* Print a value using syntax appropriate for this language. */

    int (*la_val_print) (struct type *, char *, int, CORE_ADDR,
			 struct ui_file *, int, int, int,
			 enum val_prettyprint);

    /* Print a top-level value using syntax appropriate for this language. */

    int (*la_value_print) (struct value *, struct ui_file *,
			   int, enum val_prettyprint);

    /* PC is possibly an unknown languages trampoline.
       If that PC falls in a trampoline belonging to this language,
       return the address of the first pc in the real function, or 0
       if it isn't a language tramp for this language.  */
    CORE_ADDR (*skip_trampoline) (CORE_ADDR pc);

    /* Now come some hooks for lookup_symbol.  */

    /* If this is non-NULL, lookup_symbol will do the 'field_of_this'
       check, using this function to find the value of this.  */

    /* FIXME: carlton/2003-05-19: Audit all the language_defn structs
       to make sure we're setting this appropriately: I'm sure it
       could be NULL in more languages.  */

    struct value *(*la_value_of_this) (int complain);

    /* This is a function that lookup_symbol will call when it gets to
       the part of symbol lookup where C looks up static and global
       variables.  */

    struct symbol *(*la_lookup_symbol_nonlocal) (const char *,
						 const char *,
						 const struct block *,
						 const domain_enum,
						 struct symtab **);

    /* Find the definition of the type with the given name.  */
    struct type *(*la_lookup_transparent_type) (const char *);

    /* Return demangled language symbol, or NULL.  */
    char *(*la_demangle) (const char *mangled, int options);

    /* Base 2 (binary) formats. */

    struct language_format_info la_binary_format;

    /* Base 8 (octal) formats. */

    struct language_format_info la_octal_format;

    /* Base 10 (decimal) formats */

    struct language_format_info la_decimal_format;

    /* Base 16 (hexadecimal) formats */

    struct language_format_info la_hex_format;

    /* Table for printing expressions */

    const struct op_print *la_op_print_tab;

    /* Zero if the language has first-class arrays.  True if there are no
       array values, and array objects decay to pointers, as in C. */

    char c_style_arrays;

    /* Index to use for extracting the first element of a string. */
    char string_lower_bound;

    /* Type of elements of strings. */
    struct type **string_char_type;

    /* The list of characters forming word boundaries.  */
    char *(*la_word_break_characters) (void);

    /* Add fields above this point, so the magic number is always last. */
    /* Magic number for compat checking */

    long la_magic;

  };

#define LANG_MAGIC	910823L

/* Pointer to the language_defn for our current language.  This pointer
   always points to *some* valid struct; it can be used without checking
   it for validity.

   The current language affects expression parsing and evaluation
   (FIXME: it might be cleaner to make the evaluation-related stuff
   separate exp_opcodes for each different set of semantics.  We
   should at least think this through more clearly with respect to
   what happens if the language is changed between parsing and
   evaluation) and printing of things like types and arrays.  It does
   *not* affect symbol-reading-- each source file in a symbol-file has
   its own language and we should keep track of that regardless of the
   language when symbols are read.  If we want some manual setting for
   the language of symbol files (e.g. detecting when ".c" files are
   C++), it should be a separate setting from the current_language.  */

extern const struct language_defn *current_language;

/* Pointer to the language_defn expected by the user, e.g. the language
   of main(), or the language we last mentioned in a message, or C.  */

extern const struct language_defn *expected_language;

/* language_mode == 
   language_mode_auto:   current_language automatically set upon selection
   of scope (e.g. stack frame)
   language_mode_manual: current_language set only by user.  */

extern enum language_mode
  {
    language_mode_auto, language_mode_manual
  }
language_mode;

/* These macros define the behaviour of the expression 
   evaluator.  */

/* Should we strictly type check expressions? */
#define STRICT_TYPE (type_check != type_check_off)

/* Should we range check values against the domain of their type? */
#define RANGE_CHECK (range_check != range_check_off)

/* "cast" really means conversion */
/* FIXME -- should be a setting in language_defn */
#define CAST_IS_CONVERSION (current_language->la_language == language_c  || \
			    current_language->la_language == language_cplus || \
			    current_language->la_language == language_objc)

extern void language_info (int);

extern enum language set_language (enum language);


/* This page contains functions that return things that are
   specific to languages.  Each of these functions is based on
   the current setting of working_lang, which the user sets
   with the "set language" command. */

#define create_fundamental_type(objfile,typeid) \
  (current_language->la_fund_type(objfile, typeid))

#define LA_PRINT_TYPE(type,varstring,stream,show,level) \
  (current_language->la_print_type(type,varstring,stream,show,level))

#define LA_VAL_PRINT(type,valaddr,offset,addr,stream,fmt,deref,recurse,pretty) \
  (current_language->la_val_print(type,valaddr,offset,addr,stream,fmt,deref, \
				  recurse,pretty))
#define LA_VALUE_PRINT(val,stream,fmt,pretty) \
  (current_language->la_value_print(val,stream,fmt,pretty))

/* Return a format string for printf that will print a number in one of
   the local (language-specific) formats.  Result is static and is
   overwritten by the next call.  Takes printf options like "08" or "l"
   (to produce e.g. %08x or %lx).  */

#define local_binary_format() \
  (current_language->la_binary_format.la_format)
#define local_binary_format_prefix() \
  (current_language->la_binary_format.la_format_prefix)
#define local_binary_format_specifier() \
  (current_language->la_binary_format.la_format_specifier)
#define local_binary_format_suffix() \
  (current_language->la_binary_format.la_format_suffix)

#define local_octal_format() \
  (current_language->la_octal_format.la_format)
#define local_octal_format_prefix() \
  (current_language->la_octal_format.la_format_prefix)
#define local_octal_format_specifier() \
  (current_language->la_octal_format.la_format_specifier)
#define local_octal_format_suffix() \
  (current_language->la_octal_format.la_format_suffix)

#define local_decimal_format() \
  (current_language->la_decimal_format.la_format)
#define local_decimal_format_prefix() \
  (current_language->la_decimal_format.la_format_prefix)
#define local_decimal_format_specifier() \
  (current_language->la_decimal_format.la_format_specifier)
#define local_decimal_format_suffix() \
  (current_language->la_decimal_format.la_format_suffix)

#define local_hex_format() \
  (current_language->la_hex_format.la_format)
#define local_hex_format_prefix() \
  (current_language->la_hex_format.la_format_prefix)
#define local_hex_format_specifier() \
  (current_language->la_hex_format.la_format_specifier)
#define local_hex_format_suffix() \
  (current_language->la_hex_format.la_format_suffix)

#define LA_PRINT_CHAR(ch, stream) \
  (current_language->la_printchar(ch, stream))
#define LA_PRINT_STRING(stream, string, length, width, force_ellipses) \
  (current_language->la_printstr(stream, string, length, width, force_ellipses))
#define LA_EMIT_CHAR(ch, stream, quoter) \
  (current_language->la_emitchar(ch, stream, quoter))

/* Test a character to decide whether it can be printed in literal form
   or needs to be printed in another representation.  For example,
   in C the literal form of the character with octal value 141 is 'a'
   and the "other representation" is '\141'.  The "other representation"
   is program language dependent. */

#define PRINT_LITERAL_FORM(c)		\
  ((c) >= 0x20				\
   && ((c) < 0x7F || (c) >= 0xA0)	\
   && (!sevenbit_strings || (c) < 0x80))

/* Return a format string for printf that will print a number in one of
   the local (language-specific) formats.  Result is static and is
   overwritten by the next call.  Takes printf options like "08" or "l"
   (to produce e.g. %08x or %lx).  */

extern char *local_decimal_format_custom (char *);	/* language.c */

extern char *local_octal_format_custom (char *);	/* language.c */

extern char *local_hex_format_custom (char *);	/* language.c */

#if 0
/* FIXME: cagney/2000-03-04: This function does not appear to be used.
   It can be deleted once 5.0 has been released. */
/* Return a string that contains the hex digits of the number.  No preceeding
   "0x" */

extern char *longest_raw_hex_string (LONGEST);
#endif

/* Return a string that contains a number formatted in one of the local
   (language-specific) formats.  Result is static and is overwritten by
   the next call.  Takes printf options like "08l" or "l".  */

extern char *local_hex_string (LONGEST);	/* language.c */

extern char *local_hex_string_custom (LONGEST, char *);	/* language.c */

/* Type predicates */

extern int simple_type (struct type *);

extern int ordered_type (struct type *);

extern int same_type (struct type *, struct type *);

extern int integral_type (struct type *);

extern int numeric_type (struct type *);

extern int character_type (struct type *);

extern int boolean_type (struct type *);

extern int float_type (struct type *);

extern int pointer_type (struct type *);

extern int structured_type (struct type *);

/* Checks Binary and Unary operations for semantic type correctness */
/* FIXME:  Does not appear to be used */
#define unop_type_check(v,o) binop_type_check((v),NULL,(o))

extern void binop_type_check (struct value *, struct value *, int);

/* Error messages */

extern void op_error (const char *lhs, enum exp_opcode,
		      const char *rhs);

extern void type_error (const char *, ...) ATTR_FORMAT (printf, 1, 2);

extern void range_error (const char *, ...) ATTR_FORMAT (printf, 1, 2);

/* Data:  Does this value represent "truth" to the current language?  */

extern int value_true (struct value *);

extern struct type *lang_bool_type (void);

/* The type used for Boolean values in the current language. */
#define LA_BOOL_TYPE lang_bool_type ()

/* Misc:  The string representing a particular enum language.  */

extern enum language language_enum (char *str);

extern const struct language_defn *language_def (enum language);

extern char *language_str (enum language);

/* Add a language to the set known by GDB (at initialization time).  */

extern void add_language (const struct language_defn *);

extern enum language get_frame_language (void);	/* In stack.c */

/* Check for a language-specific trampoline. */

extern CORE_ADDR skip_language_trampoline (CORE_ADDR pc);

/* Return demangled language symbol, or NULL.  */
extern char *language_demangle (const struct language_defn *current_language, 
				const char *mangled, int options);

/* Splitting strings into words.  */
extern char *default_word_break_characters (void);

#endif /* defined (LANGUAGE_H) */
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@a98 11
/* array_ordering ==
   array_row_major:     Arrays are in row major order
   array_column_major:  Arrays are in column major order.*/

extern enum array_ordering
  {
    array_row_major, array_column_major
  } 
array_ordering;


d109 16
a124 1
/* Per architecture (OS/ABI) language information.  */
d126 13
a138 17
struct language_arch_info
{
  /* Its primitive types.  This is a vector ended by a NULL pointer.
     These types can be specified by name in parsing types in
     expressions, regardless of whether the program being debugged
     actually defines such a type.  */
  struct type **primitive_type_vector;
  /* Type of elements of strings. */
  struct type *string_char_type;
};

struct type *language_string_char_type (const struct language_defn *l,
					struct gdbarch *gdbarch);

struct type *language_lookup_primitive_type_by_name (const struct language_defn *l,
						     struct gdbarch *gdbarch,
						     const char *name);
a169 3
    /* Multi-dimensional array ordering */
    enum array_ordering la_array_ordering;

a182 8
    /* Given an expression *EXPP created by prefixifying the result of
       la_parser, perform any remaining processing necessary to complete
       its translation.  *EXPP may change; la_post_parser is responsible 
       for releasing its previous contents, if necessary.  If 
       VOID_CONTEXT_P, then no value is expected from the expression.  */

    void (*la_post_parser) (struct expression ** expp, int void_context_p);

d242 15
a256 2
    /* Return class name of a mangled method name or NULL.  */
    char *(*la_class_name_from_physname) (const char *physname);
a275 4
    /* The per-architecture (OS/ABI) language information.  */
    void (*la_language_arch_info) (struct gdbarch *,
				   struct language_arch_info *);

d356 41
d415 11
d435 8
a509 4

/* Return class name from physname, or NULL.  */
extern char *language_class_name_from_physname (const struct language_defn *,
					        const char *physname);
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 431
/* Source-language-related definitions for GDB.
   Copyright 1991, 1992 Free Software Foundation, Inc.
   Contributed by the Department of Computer Science at the State University
   of New York at Buffalo.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#if !defined (LANGUAGE_H)
#define LANGUAGE_H 1

#ifdef __STDC__		/* Forward decls for prototypes */
struct value;
struct objfile;
struct expression;
/* enum exp_opcode;	ANSI's `wisdom' didn't include forward enum decls. */
#endif

/* This used to be included to configure GDB for one or more specific
   languages.  Now it is shortcutted to configure for all of them.  FIXME.  */
/* #include "lang_def.h" */
#define	_LANG_c
#define	_LANG_m2
#define	_LANG_chill
#define _LANG_fortran

#define MAX_FORTRAN_DIMS  7   /* Maximum number of F77 array dims */ 

/* range_mode ==
   range_mode_auto:   range_check set automatically to default of language.
   range_mode_manual: range_check set manually by user.  */

extern enum range_mode {range_mode_auto, range_mode_manual} range_mode;

/* range_check ==
   range_check_on:    Ranges are checked in GDB expressions, producing errors.
   range_check_warn:  Ranges are checked, producing warnings.
   range_check_off:   Ranges are not checked in GDB expressions.  */

extern enum range_check
  {range_check_off, range_check_warn, range_check_on} range_check;

/* type_mode ==
   type_mode_auto:   type_check set automatically to default of language
   type_mode_manual: type_check set manually by user. */

extern enum type_mode {type_mode_auto, type_mode_manual} type_mode;

/* type_check ==
   type_check_on:    Types are checked in GDB expressions, producing errors.
   type_check_warn:  Types are checked, producing warnings.
   type_check_off:   Types are not checked in GDB expressions.  */

extern enum type_check
  {type_check_off, type_check_warn, type_check_on} type_check;

/* Information for doing language dependent formatting of printed values. */

struct language_format_info
{
  /* The format that can be passed directly to standard C printf functions
     to generate a completely formatted value in the format appropriate for
     the language. */

  char *la_format;

  /* The prefix to be used when directly printing a value, or constructing
     a standard C printf format.  This generally is everything up to the
     conversion specification (the part introduced by the '%' character
     and terminated by the conversion specifier character). */

  char *la_format_prefix;

  /* The conversion specifier.  This is generally everything after the
     field width and precision, typically only a single character such
     as 'o' for octal format or 'x' for hexadecimal format. */

  char *la_format_specifier;

  /* The suffix to be used when directly printing a value, or constructing
     a standard C printf format.  This generally is everything after the
     conversion specification (the part introduced by the '%' character
     and terminated by the conversion specifier character). */

  char *la_format_suffix;		/* Suffix for custom format string */
};

/* Structure tying together assorted information about a language.  */

struct language_defn
{
  /* Name of the language */
  
  char *la_name;

  /* its symtab language-enum (defs.h) */

  enum language la_language;

  /* Its builtin types.  This is a vector ended by a NULL pointer.  These
     types can be specified by name in parsing types in expressions,
     regardless of whether the program being debugged actually defines
     such a type.  */

  struct type ** const *la_builtin_type_vector;

  /* Default range checking */

  enum range_check la_range_check;

  /* Default type checking */

  enum type_check la_type_check;

  /* Parser function. */
  
  int (*la_parser) PARAMS((void));

  /* Parser error function */

  void (*la_error) PARAMS ((char *));

  /* Evaluate an expression. */
  struct value * (*evaluate_exp) PARAMS ((struct type*, struct expression *, 
					  int *, enum noside));

  void (*la_printchar) PARAMS ((int, GDB_FILE *));

  void (*la_printstr) PARAMS ((GDB_FILE *, char *, unsigned int, int));

  struct type *(*la_fund_type) PARAMS ((struct objfile *, int));

  /* Print a type using syntax appropriate for this language. */

  void (*la_print_type) PARAMS ((struct type *, char *, GDB_FILE *, int, int));

  /* Print a value using syntax appropriate for this language. */

  int (*la_val_print) PARAMS ((struct type *, char *,  CORE_ADDR, GDB_FILE *,
			       int, int, int, enum val_prettyprint));

  /* Print a top-level value using syntax appropriate for this language. */

  int (*la_value_print) PARAMS ((struct value *, GDB_FILE *,
				 int, enum val_prettyprint));

  /* Base 2 (binary) formats. */

  struct language_format_info la_binary_format;

  /* Base 8 (octal) formats. */

  struct language_format_info la_octal_format;

  /* Base 10 (decimal) formats */

  struct language_format_info la_decimal_format;

  /* Base 16 (hexadecimal) formats */

  struct language_format_info la_hex_format;

  /* Table for printing expressions */

  const struct op_print *la_op_print_tab;

  /* Zero if the language has first-class arrays.  True if there are no
     array values, and array objects decay to pointers, as in C. */

  char c_style_arrays;

  /* Index to use for extracting the first element of a string. */
  char string_lower_bound;

  /* Type of elements of strings. */
  struct type **string_char_type;

  /* Add fields above this point, so the magic number is always last. */
  /* Magic number for compat checking */

  long la_magic;

};

#define LANG_MAGIC	910823L

/* Pointer to the language_defn for our current language.  This pointer
   always points to *some* valid struct; it can be used without checking
   it for validity.

   The current language affects expression parsing and evaluation
   (FIXME: it might be cleaner to make the evaluation-related stuff
   separate exp_opcodes for each different set of semantics.  We
   should at least think this through more clearly with respect to
   what happens if the language is changed between parsing and
   evaluation) and printing of things like types and arrays.  It does
   *not* affect symbol-reading-- each source file in a symbol-file has
   its own language and we should keep track of that regardless of the
   language when symbols are read.  If we want some manual setting for
   the language of symbol files (e.g. detecting when ".c" files are
   C++), it should be a seprate setting from the current_language.  */

extern const struct language_defn *current_language;

/* Pointer to the language_defn expected by the user, e.g. the language
   of main(), or the language we last mentioned in a message, or C.  */

extern const struct language_defn *expected_language;

/* language_mode == 
   language_mode_auto:   current_language automatically set upon selection
			 of scope (e.g. stack frame)
   language_mode_manual: current_language set only by user.  */

extern enum language_mode
  {language_mode_auto, language_mode_manual} language_mode;

/* These macros define the behaviour of the expression 
   evaluator.  */

/* Should we strictly type check expressions? */
#define STRICT_TYPE (type_check != type_check_off)

/* Should we range check values against the domain of their type? */
#define RANGE_CHECK (range_check != range_check_off)

/* "cast" really means conversion */
/* FIXME -- should be a setting in language_defn */
#define CAST_IS_CONVERSION (current_language->la_language == language_c  || \
			    current_language->la_language == language_cplus)

extern void
language_info PARAMS ((int));

extern void
set_language PARAMS ((enum language));


/* This page contains functions that return things that are
   specific to languages.  Each of these functions is based on
   the current setting of working_lang, which the user sets
   with the "set language" command. */

#define create_fundamental_type(objfile,typeid) \
  (current_language->la_fund_type(objfile, typeid))

#define LA_PRINT_TYPE(type,varstring,stream,show,level) \
  (current_language->la_print_type(type,varstring,stream,show,level))

#define LA_VAL_PRINT(type,valaddr,addr,stream,fmt,deref,recurse,pretty) \
  (current_language->la_val_print(type,valaddr,addr,stream,fmt,deref, \
				  recurse,pretty))
#define LA_VALUE_PRINT(val,stream,fmt,pretty) \
  (current_language->la_value_print(val,stream,fmt,pretty))

/* Return a format string for printf that will print a number in one of
   the local (language-specific) formats.  Result is static and is
   overwritten by the next call.  Takes printf options like "08" or "l"
   (to produce e.g. %08x or %lx).  */

#define local_binary_format() \
  (current_language->la_binary_format.la_format)
#define local_binary_format_prefix() \
  (current_language->la_binary_format.la_format_prefix)
#define local_binary_format_specifier() \
  (current_language->la_binary_format.la_format_specifier)
#define local_binary_format_suffix() \
  (current_language->la_binary_format.la_format_suffix)

#define local_octal_format() \
  (current_language->la_octal_format.la_format)
#define local_octal_format_prefix() \
  (current_language->la_octal_format.la_format_prefix)
#define local_octal_format_specifier() \
  (current_language->la_octal_format.la_format_specifier)
#define local_octal_format_suffix() \
  (current_language->la_octal_format.la_format_suffix)

#define local_decimal_format() \
  (current_language->la_decimal_format.la_format)
#define local_decimal_format_prefix() \
  (current_language->la_decimal_format.la_format_prefix)
#define local_decimal_format_specifier() \
  (current_language->la_decimal_format.la_format_specifier)
#define local_decimal_format_suffix() \
  (current_language->la_decimal_format.la_format_suffix)

#define local_hex_format() \
  (current_language->la_hex_format.la_format)
#define local_hex_format_prefix() \
  (current_language->la_hex_format.la_format_prefix)
#define local_hex_format_specifier() \
  (current_language->la_hex_format.la_format_specifier)
#define local_hex_format_suffix() \
  (current_language->la_hex_format.la_format_suffix)

#define LA_PRINT_CHAR(ch, stream) \
  (current_language->la_printchar(ch, stream))
#define LA_PRINT_STRING(stream, string, length, force_ellipses) \
  (current_language->la_printstr(stream, string, length, force_ellipses))

/* Test a character to decide whether it can be printed in literal form
   or needs to be printed in another representation.  For example,
   in C the literal form of the character with octal value 141 is 'a'
   and the "other representation" is '\141'.  The "other representation"
   is program language dependent. */

#define PRINT_LITERAL_FORM(c) \
  ((c)>=0x20 && ((c)<0x7F || (c)>=0xA0) && (!sevenbit_strings || (c)<0x80))

/* Return a format string for printf that will print a number in one of
   the local (language-specific) formats.  Result is static and is
   overwritten by the next call.  Takes printf options like "08" or "l"
   (to produce e.g. %08x or %lx).  */

extern char *
local_decimal_format_custom PARAMS ((char *));	/* language.c */

extern char *
local_octal_format_custom PARAMS ((char *));	/* language.c */

extern char *
local_hex_format_custom PARAMS ((char *));	/* language.c */

/* Return a string that contains a number formatted in one of the local
   (language-specific) formats.  Result is static and is overwritten by
   the next call.  Takes printf options like "08" or "l".  */

extern char *
local_hex_string PARAMS ((unsigned long));		/* language.c */

extern char *
local_hex_string_custom PARAMS ((unsigned long, char *)); /* language.c */

/* Type predicates */

extern int
simple_type PARAMS ((struct type *));

extern int
ordered_type PARAMS ((struct type *));

extern int
same_type PARAMS ((struct type *, struct type *));

extern int
integral_type PARAMS ((struct type *));

extern int
numeric_type PARAMS ((struct type *));

extern int
character_type PARAMS ((struct type *));

extern int
boolean_type PARAMS ((struct type *));

extern int
float_type PARAMS ((struct type *));

extern int
pointer_type PARAMS ((struct type *));

extern int
structured_type PARAMS ((struct type *));

/* Checks Binary and Unary operations for semantic type correctness */
/* FIXME:  Does not appear to be used */
#define unop_type_check(v,o) binop_type_check((v),NULL,(o))

extern void
binop_type_check PARAMS ((struct value *, struct value *, int));

/* Error messages */

extern void
op_error PARAMS ((char *fmt, enum exp_opcode, int));

#define type_op_error(f,o) \
   op_error((f),(o),type_check==type_check_on ? 1 : 0)
#define range_op_error(f,o) \
   op_error((f),(o),range_check==range_check_on ? 1 : 0)

extern void
type_error PARAMS ((char *, ...))
     ATTR_FORMAT(printf, 1, 2);

void
range_error PARAMS ((char *, ...))
     ATTR_FORMAT(printf, 1, 2);

/* Data:  Does this value represent "truth" to the current language?  */

extern int
value_true PARAMS ((struct value *));

extern struct type * lang_bool_type PARAMS ((void));

/* The type used for Boolean values in the current language. */
#define LA_BOOL_TYPE lang_bool_type ()

/* Misc:  The string representing a particular enum language.  */

extern const struct language_defn *
language_def PARAMS ((enum language));

extern char *
language_str PARAMS ((enum language));

/* Add a language to the set known by GDB (at initialization time).  */

extern void
add_language PARAMS ((const struct language_defn *));

extern enum language
get_frame_language PARAMS ((void));		/* In stack.c */

#endif	/* defined (LANGUAGE_H) */
@
