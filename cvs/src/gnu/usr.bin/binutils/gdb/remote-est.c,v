head	1.4;
access;
symbols
	OPENBSD_6_1:1.4.0.52
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.48
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.44
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.46
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.38
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.42
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.40
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.36
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.34
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.32
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.30
	OPENBSD_5_0:1.4.0.28
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.26
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.24
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2004.12.27.14.00.40;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.21.20.23.11;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.39.04;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.19.45;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.12.31;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.09.48;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.19.46;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@/* Remote debugging interface for EST-300 ICE, for GDB
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
   Contributed by Cygnus Support.

   Written by Steve Chamberlain for Cygnus Support.
   Re-written by Stu Grossman of Cygnus Support

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "gdbcore.h"
#include "target.h"
#include "monitor.h"
#include "serial.h"
#include "regcache.h"

#include "m68k-tdep.h"

static void est_open (char *args, int from_tty);

static void
est_supply_register (char *regname, int regnamelen, char *val, int vallen)
{
  int regno;

  if (regnamelen != 2)
    return;

  switch (regname[0])
    {
    case 'S':
      if (regname[1] != 'R')
	return;
      regno = PS_REGNUM;
      break;
    case 'P':
      if (regname[1] != 'C')
	return;
      regno = PC_REGNUM;
      break;
    case 'D':
      if (regname[1] < '0' || regname[1] > '7')
	return;
      regno = regname[1] - '0' + M68K_D0_REGNUM;
      break;
    case 'A':
      if (regname[1] < '0' || regname[1] > '7')
	return;
      regno = regname[1] - '0' + M68K_A0_REGNUM;
      break;
    default:
      return;
    }

  monitor_supply_register (regno, val);
}

/*
 * This array of registers needs to match the indexes used by GDB. The
 * whole reason this exists is because the various ROM monitors use
 * different names than GDB does, and don't support all the
 * registers either. So, typing "info reg sp" becomes a "r30".
 */

static const char *
est_regname (int index) 
{
  
  static char *regnames[] =
  {
    "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7",
    "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7",
    "SR", "PC",
  };
  

  if ((index >= (sizeof (regnames) /  sizeof (regnames[0]))) 
       || (index < 0) || (index >= NUM_REGS))
    return NULL;
  else
    return regnames[index];
}

/*
 * Define the monitor command strings. Since these are passed directly
 * through to a printf style function, we need can include formatting
 * strings. We also need a CR or LF on the end.
 */

static struct target_ops est_ops;

static char *est_inits[] =
{"he\r",			/* Resets the prompt, and clears repeated cmds */
 NULL};

static struct monitor_ops est_cmds;

static void
init_est_cmds (void)
{
  est_cmds.flags = MO_CLR_BREAK_USES_ADDR | MO_FILL_USES_ADDR | MO_NEED_REGDUMP_AFTER_CONT |
    MO_SREC_ACK | MO_SREC_ACK_PLUS;
  est_cmds.init = est_inits;	/* Init strings */
  est_cmds.cont = "go\r";	/* continue command */
  est_cmds.step = "sidr\r";	/* single step */
  est_cmds.stop = "\003";	/* ^C interrupts the program */
  est_cmds.set_break = "sb %x\r";	/* set a breakpoint */
  est_cmds.clr_break = "rb %x\r";	/* clear a breakpoint */
  est_cmds.clr_all_break = "rb\r";	/* clear all breakpoints */
  est_cmds.fill = "bfb %x %x %x\r";	/* fill (start end val) */
  est_cmds.setmem.cmdb = "smb %x %x\r";		/* setmem.cmdb (addr, value) */
  est_cmds.setmem.cmdw = "smw %x %x\r";		/* setmem.cmdw (addr, value) */
  est_cmds.setmem.cmdl = "sml %x %x\r";		/* setmem.cmdl (addr, value) */
  est_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
  est_cmds.setmem.resp_delim = NULL;	/* setreg.resp_delim */
  est_cmds.setmem.term = NULL;	/* setreg.term */
  est_cmds.setmem.term_cmd = NULL;	/* setreg.term_cmd */
  est_cmds.getmem.cmdb = "dmb %x %x\r";		/* getmem.cmdb (addr, len) */
  est_cmds.getmem.cmdw = "dmw %x %x\r";		/* getmem.cmdw (addr, len) */
  est_cmds.getmem.cmdl = "dml %x %x\r";		/* getmem.cmdl (addr, len) */
  est_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, len) */
  est_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
  est_cmds.getmem.term = NULL;	/* getmem.term */
  est_cmds.getmem.term_cmd = NULL;	/* getmem.term_cmd */
  est_cmds.setreg.cmd = "sr %s %x\r";	/* setreg.cmd (name, value) */
  est_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
  est_cmds.setreg.term = NULL;	/* setreg.term */
  est_cmds.setreg.term_cmd = NULL;	/* setreg.term_cmd */
  est_cmds.getreg.cmd = "dr %s\r";	/* getreg.cmd (name) */
  est_cmds.getreg.resp_delim = " = ";	/* getreg.resp_delim */
  est_cmds.getreg.term = NULL;	/* getreg.term */
  est_cmds.getreg.term_cmd = NULL;	/* getreg.term_cmd */
  est_cmds.dump_registers = "dr\r";	/* dump_registers */
  est_cmds.register_pattern = "\\(\\w+\\) = \\([0-9a-fA-F]+\\)";	/* register_pattern */
  est_cmds.supply_register = est_supply_register;
  est_cmds.load_routine = NULL;	/* load_routine (defaults to SRECs) */
  est_cmds.load = "dl\r";	/* download command */
  est_cmds.loadresp = "+";	/* load response */
  est_cmds.prompt = ">BKM>";	/* monitor command prompt */
  est_cmds.line_term = "\r";	/* end-of-line terminator */
  est_cmds.cmd_end = NULL;	/* optional command terminator */
  est_cmds.target = &est_ops;	/* target operations */
  est_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
  est_cmds.regnames = NULL;
  est_cmds.regname = est_regname; /*register names*/
  est_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
}				/* init_est_cmds */

static void
est_open (char *args, int from_tty)
{
  monitor_open (args, &est_cmds, from_tty);
}

extern initialize_file_ftype _initialize_est; /* -Wmissing-prototypes */

void
_initialize_est (void)
{
  init_est_cmds ();
  init_monitor_ops (&est_ops);

  est_ops.to_shortname = "est";
  est_ops.to_longname = "EST background debug monitor";
  est_ops.to_doc = "Debug via the EST BDM.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  est_ops.to_open = est_open;

  add_target (&est_ops);
}
@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@d151 1
a151 1
  est_cmds.supply_register = est_supply_register;	/* supply_register */
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright 1995 Free Software Foundation, Inc.
d9 1
a9 1
This file is part of GDB.
d11 14
a24 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 1
d33 3
a35 1
static void est_open PARAMS ((char *args, int from_tty));
d38 1
a38 5
est_supply_register (regname, regnamelen, val, vallen)
     char *regname;
     int regnamelen;
     char *val;
     int vallen;
d60 1
a60 1
      regno = regname[1] - '0' + D0_REGNUM;
d65 1
a65 1
      regno = regname[1] - '0' + A0_REGNUM;
d81 2
a82 1
static char *est_regnames[NUM_REGS] =
d84 15
a98 4
  "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7",
  "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7",
  "SR", "PC",
};
d108 5
a112 2
static char *est_inits[] = {"he\r", /* Resets the prompt, and clears repeated cmds */
			      NULL};
d114 2
a115 1
static struct monitor_ops est_cmds =
d117 47
a163 54
  MO_CLR_BREAK_USES_ADDR | MO_FILL_USES_ADDR | MO_NEED_REGDUMP_AFTER_CONT |
  MO_SREC_ACK,
  est_inits,			/* Init strings */
  "go\r",			/* continue command */
  "sidr\r",			/* single step */
  "\003",			/* ^C interrupts the program */
  "sb %x\r",			/* set a breakpoint */
  "rb %x\r",			/* clear a breakpoint */
  "rb\r",			/* clear all breakpoints */
  "bfb %x %x %x\r",		/* fill (start end val) */
  {
    "smb %x %x\r",		/* setmem.cmdb (addr, value) */
    "smw %x %x\r",		/* setmem.cmdw (addr, value) */
    "sml %x %x\r",		/* setmem.cmdl (addr, value) */
    NULL,			/* setmem.cmdll (addr, value) */
    NULL,			/* setreg.resp_delim */
    NULL,			/* setreg.term */
    NULL,			/* setreg.term_cmd */
  },
  {
    "dmb %x %x\r",		/* getmem.cmdb (addr, len) */
    "dmw %x %x\r",		/* getmem.cmdw (addr, len) */
    "dml %x %x\r",		/* getmem.cmdl (addr, len) */
    NULL,			/* getmem.cmdll (addr, len) */
    ": ",			/* getmem.resp_delim */
    NULL,			/* getmem.term */
    NULL,			/* getmem.term_cmd */
  },
  {
    "sr %s %x\r",		/* setreg.cmd (name, value) */
    NULL,			/* setreg.resp_delim */
    NULL,			/* setreg.term */
    NULL			/* setreg.term_cmd */
  },
  {
    "dr %s\r",			/* getreg.cmd (name) */
    " = ",			/* getreg.resp_delim */
    NULL,			/* getreg.term */
    NULL			/* getreg.term_cmd */
  },
  "dr\r",			/* dump_registers */
  "\\(\\w+\\) = \\([0-9a-fA-F]+\\)", /* register_pattern */
  est_supply_register,		/* supply_register */
  NULL,				/* load_routine (defaults to SRECs) */
  "dl\r",			/* download command */
  "+",				/* load response */
  ">BKM>",			/* monitor command prompt */
  "\r",				/* end-of-line terminator */
  NULL,				/* optional command terminator */
  &est_ops,			/* target operations */
  SERIAL_1_STOPBITS,		/* number of stop bits */
  est_regnames,			/* registers names */
  MONITOR_OPS_MAGIC		/* magic */
  };
d166 1
a166 3
est_open(args, from_tty)
     char *args;
     int from_tty;
d171 2
d174 1
a174 1
_initialize_est ()
d176 1
@


1.1
log
@file remote-est.c was initially added on branch CYGNUS.
@
text
@d1 175
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 186
/* Remote debugging interface for EST-300 ICE, for GDB
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
   Contributed by Cygnus Support.

   Written by Steve Chamberlain for Cygnus Support.
   Re-written by Stu Grossman of Cygnus Support

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "gdbcore.h"
#include "target.h"
#include "monitor.h"
#include "serial.h"
#include "regcache.h"

#include "m68k-tdep.h"

static void est_open (char *args, int from_tty);

static void
est_supply_register (char *regname, int regnamelen, char *val, int vallen)
{
  int regno;

  if (regnamelen != 2)
    return;

  switch (regname[0])
    {
    case 'S':
      if (regname[1] != 'R')
	return;
      regno = PS_REGNUM;
      break;
    case 'P':
      if (regname[1] != 'C')
	return;
      regno = PC_REGNUM;
      break;
    case 'D':
      if (regname[1] < '0' || regname[1] > '7')
	return;
      regno = regname[1] - '0' + M68K_D0_REGNUM;
      break;
    case 'A':
      if (regname[1] < '0' || regname[1] > '7')
	return;
      regno = regname[1] - '0' + M68K_A0_REGNUM;
      break;
    default:
      return;
    }

  monitor_supply_register (regno, val);
}

/*
 * This array of registers needs to match the indexes used by GDB. The
 * whole reason this exists is because the various ROM monitors use
 * different names than GDB does, and don't support all the
 * registers either. So, typing "info reg sp" becomes a "r30".
 */

static const char *
est_regname (int index) 
{
  
  static char *regnames[] =
  {
    "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7",
    "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7",
    "SR", "PC",
  };
  

  if ((index >= (sizeof (regnames) /  sizeof (regnames[0]))) 
       || (index < 0) || (index >= NUM_REGS))
    return NULL;
  else
    return regnames[index];
}

/*
 * Define the monitor command strings. Since these are passed directly
 * through to a printf style function, we need can include formatting
 * strings. We also need a CR or LF on the end.
 */

static struct target_ops est_ops;

static char *est_inits[] =
{"he\r",			/* Resets the prompt, and clears repeated cmds */
 NULL};

static struct monitor_ops est_cmds;

static void
init_est_cmds (void)
{
  est_cmds.flags = MO_CLR_BREAK_USES_ADDR | MO_FILL_USES_ADDR | MO_NEED_REGDUMP_AFTER_CONT |
    MO_SREC_ACK | MO_SREC_ACK_PLUS;
  est_cmds.init = est_inits;	/* Init strings */
  est_cmds.cont = "go\r";	/* continue command */
  est_cmds.step = "sidr\r";	/* single step */
  est_cmds.stop = "\003";	/* ^C interrupts the program */
  est_cmds.set_break = "sb %x\r";	/* set a breakpoint */
  est_cmds.clr_break = "rb %x\r";	/* clear a breakpoint */
  est_cmds.clr_all_break = "rb\r";	/* clear all breakpoints */
  est_cmds.fill = "bfb %x %x %x\r";	/* fill (start end val) */
  est_cmds.setmem.cmdb = "smb %x %x\r";		/* setmem.cmdb (addr, value) */
  est_cmds.setmem.cmdw = "smw %x %x\r";		/* setmem.cmdw (addr, value) */
  est_cmds.setmem.cmdl = "sml %x %x\r";		/* setmem.cmdl (addr, value) */
  est_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
  est_cmds.setmem.resp_delim = NULL;	/* setreg.resp_delim */
  est_cmds.setmem.term = NULL;	/* setreg.term */
  est_cmds.setmem.term_cmd = NULL;	/* setreg.term_cmd */
  est_cmds.getmem.cmdb = "dmb %x %x\r";		/* getmem.cmdb (addr, len) */
  est_cmds.getmem.cmdw = "dmw %x %x\r";		/* getmem.cmdw (addr, len) */
  est_cmds.getmem.cmdl = "dml %x %x\r";		/* getmem.cmdl (addr, len) */
  est_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, len) */
  est_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
  est_cmds.getmem.term = NULL;	/* getmem.term */
  est_cmds.getmem.term_cmd = NULL;	/* getmem.term_cmd */
  est_cmds.setreg.cmd = "sr %s %x\r";	/* setreg.cmd (name, value) */
  est_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
  est_cmds.setreg.term = NULL;	/* setreg.term */
  est_cmds.setreg.term_cmd = NULL;	/* setreg.term_cmd */
  est_cmds.getreg.cmd = "dr %s\r";	/* getreg.cmd (name) */
  est_cmds.getreg.resp_delim = " = ";	/* getreg.resp_delim */
  est_cmds.getreg.term = NULL;	/* getreg.term */
  est_cmds.getreg.term_cmd = NULL;	/* getreg.term_cmd */
  est_cmds.dump_registers = "dr\r";	/* dump_registers */
  est_cmds.register_pattern = "\\(\\w+\\) = \\([0-9a-fA-F]+\\)";	/* register_pattern */
  est_cmds.supply_register = est_supply_register;	/* supply_register */
  est_cmds.load_routine = NULL;	/* load_routine (defaults to SRECs) */
  est_cmds.load = "dl\r";	/* download command */
  est_cmds.loadresp = "+";	/* load response */
  est_cmds.prompt = ">BKM>";	/* monitor command prompt */
  est_cmds.line_term = "\r";	/* end-of-line terminator */
  est_cmds.cmd_end = NULL;	/* optional command terminator */
  est_cmds.target = &est_ops;	/* target operations */
  est_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
  est_cmds.regnames = NULL;
  est_cmds.regname = est_regname; /*register names*/
  est_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
}				/* init_est_cmds */

static void
est_open (char *args, int from_tty)
{
  monitor_open (args, &est_cmds, from_tty);
}

extern initialize_file_ftype _initialize_est; /* -Wmissing-prototypes */

void
_initialize_est (void)
{
  init_est_cmds ();
  init_monitor_ops (&est_ops);

  est_ops.to_shortname = "est";
  est_ops.to_longname = "EST background debug monitor";
  est_ops.to_doc = "Debug via the EST BDM.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  est_ops.to_open = est_open;

  add_target (&est_ops);
}
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d151 1
a151 1
  est_cmds.supply_register = est_supply_register;
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 175
/* Remote debugging interface for EST-300 ICE, for GDB
   Copyright 1995 Free Software Foundation, Inc.
   Contributed by Cygnus Support.

   Written by Steve Chamberlain for Cygnus Support.
   Re-written by Stu Grossman of Cygnus Support

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "gdbcore.h"
#include "target.h"
#include "monitor.h"
#include "serial.h"

static void est_open PARAMS ((char *args, int from_tty));

static void
est_supply_register (regname, regnamelen, val, vallen)
     char *regname;
     int regnamelen;
     char *val;
     int vallen;
{
  int regno;

  if (regnamelen != 2)
    return;

  switch (regname[0])
    {
    case 'S':
      if (regname[1] != 'R')
	return;
      regno = PS_REGNUM;
      break;
    case 'P':
      if (regname[1] != 'C')
	return;
      regno = PC_REGNUM;
      break;
    case 'D':
      if (regname[1] < '0' || regname[1] > '7')
	return;
      regno = regname[1] - '0' + D0_REGNUM;
      break;
    case 'A':
      if (regname[1] < '0' || regname[1] > '7')
	return;
      regno = regname[1] - '0' + A0_REGNUM;
      break;
    default:
      return;
    }

  monitor_supply_register (regno, val);
}

/*
 * This array of registers needs to match the indexes used by GDB. The
 * whole reason this exists is because the various ROM monitors use
 * different names than GDB does, and don't support all the
 * registers either. So, typing "info reg sp" becomes a "r30".
 */

static char *est_regnames[NUM_REGS] =
{
  "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7",
  "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7",
  "SR", "PC",
};

/*
 * Define the monitor command strings. Since these are passed directly
 * through to a printf style function, we need can include formatting
 * strings. We also need a CR or LF on the end.
 */

static struct target_ops est_ops;

static char *est_inits[] = {"he\r", /* Resets the prompt, and clears repeated cmds */
			      NULL};

static struct monitor_ops est_cmds =
{
  MO_CLR_BREAK_USES_ADDR | MO_FILL_USES_ADDR | MO_NEED_REGDUMP_AFTER_CONT |
  MO_SREC_ACK,
  est_inits,			/* Init strings */
  "go\r",			/* continue command */
  "sidr\r",			/* single step */
  "\003",			/* ^C interrupts the program */
  "sb %x\r",			/* set a breakpoint */
  "rb %x\r",			/* clear a breakpoint */
  "rb\r",			/* clear all breakpoints */
  "bfb %x %x %x\r",		/* fill (start end val) */
  {
    "smb %x %x\r",		/* setmem.cmdb (addr, value) */
    "smw %x %x\r",		/* setmem.cmdw (addr, value) */
    "sml %x %x\r",		/* setmem.cmdl (addr, value) */
    NULL,			/* setmem.cmdll (addr, value) */
    NULL,			/* setreg.resp_delim */
    NULL,			/* setreg.term */
    NULL,			/* setreg.term_cmd */
  },
  {
    "dmb %x %x\r",		/* getmem.cmdb (addr, len) */
    "dmw %x %x\r",		/* getmem.cmdw (addr, len) */
    "dml %x %x\r",		/* getmem.cmdl (addr, len) */
    NULL,			/* getmem.cmdll (addr, len) */
    ": ",			/* getmem.resp_delim */
    NULL,			/* getmem.term */
    NULL,			/* getmem.term_cmd */
  },
  {
    "sr %s %x\r",		/* setreg.cmd (name, value) */
    NULL,			/* setreg.resp_delim */
    NULL,			/* setreg.term */
    NULL			/* setreg.term_cmd */
  },
  {
    "dr %s\r",			/* getreg.cmd (name) */
    " = ",			/* getreg.resp_delim */
    NULL,			/* getreg.term */
    NULL			/* getreg.term_cmd */
  },
  "dr\r",			/* dump_registers */
  "\\(\\w+\\) = \\([0-9a-fA-F]+\\)", /* register_pattern */
  est_supply_register,		/* supply_register */
  NULL,				/* load_routine (defaults to SRECs) */
  "dl\r",			/* download command */
  "+",				/* load response */
  ">BKM>",			/* monitor command prompt */
  "\r",				/* end-of-line terminator */
  NULL,				/* optional command terminator */
  &est_ops,			/* target operations */
  SERIAL_1_STOPBITS,		/* number of stop bits */
  est_regnames,			/* registers names */
  MONITOR_OPS_MAGIC		/* magic */
  };

static void
est_open(args, from_tty)
     char *args;
     int from_tty;
{
  monitor_open (args, &est_cmds, from_tty);
}

void
_initialize_est ()
{
  init_monitor_ops (&est_ops);

  est_ops.to_shortname = "est";
  est_ops.to_longname = "EST background debug monitor";
  est_ops.to_doc = "Debug via the EST BDM.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  est_ops.to_open = est_open;

  add_target (&est_ops);
}
@
