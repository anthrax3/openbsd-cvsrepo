head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.52
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.48
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.44
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.46
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.38
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.42
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.40
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.36
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.34
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.32
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.30
	OPENBSD_5_0:1.3.0.28
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.26
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.24
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.20
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.22
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.18
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.16
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.14
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.12
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.10
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.8
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.6
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	GDB_6_3:1.1.1.1
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	GDB_6_1:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.12.27.14.00.54;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.21.20.23.37;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.21.19.15.55;	author kettenis;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.05.21.19.15.55;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@/* 
 * Copyright (C) 1995 Advanced RISC Machines Limited. All rights reserved.
 * 
 * This software may be freely used, copied, modified, and distributed
 * provided that the above copyright notice is preserved in all copies of the
 * software.
 */

/* -*-C-*-
 *
 * $Revision: 1.2 $
 *     $Date: 1998/01/08 11:12:03 $
 *
 *
 *   Project: ANGEL
 *
 *     Title: Definitions for device driver interface.
 */
#ifndef angsd_drivers_h
#define angsd_drivers_h

#include "rxtx.h"

#ifndef __cplusplus
typedef struct DeviceDescr DeviceDescr;
typedef struct DriverCall DriverCall;
#endif

/*
 * used to pass packets across the driver interface
 */
struct DriverCall
{
    struct data_packet  dc_packet;
    void               *dc_context;
};

/*
 * used to describe a device driver
 */
struct DeviceDescr
{
    char  *DeviceName;
    int  (*DeviceOpen)(const char *name, const char *arg);
    int  (*DeviceMatch)(const char *name, const char *arg);
    void (*DeviceClose)(void);
    int  (*DeviceRead)(DriverCall *dc, bool block);
    int  (*DeviceWrite)(DriverCall *dc);
    int  (*DeviceIoctl)(const int opcode, void *args);
    void  *SwitcherState;               /* used by switcher interface */
};

/*
 *  Function: DeviceOpen
 *
 *   Purpose: Open a communications device
 *
 *  Pre-conditions: No previous open is still active
 *
 *    Params:
 *       Input: name    Identifies which device to open.  This can either be
 *                      a host specific identifier (e.g. "/dev/ttya",
 *                      "COM1:"), or a number which is used to refer to
 *                      `standard' interfaces, so "1" would be the first host
 *                      interface, "2" the second, and so on.
 *
 *              arg     Driver specific arguments.  For example, some serial
 *                      drivers accept speed and control arguments such as
 *                      "9600" or "19200/NO_BREAK".  These arguments are
 *                      completely free-form: it is the individual drivers
 *                      which do the necessary interpretation.
 *
 *   Returns:
 *          OK: 0
 *       Error: -1
 */
extern int DeviceOpen(const char *name, const char *arg);

/*
 *  Function: DeviceMatch
 *
 *   Purpose: Check whether parameters are OK to be passed to DeviceOpen
 *
 *    Params:
 *       Input: name    Identifies which device to open.  This can either be
 *                      a host specific identifier (e.g. "/dev/ttya",
 *                      "COM1:"), or a number which is used to refer to
 *                      `standard' interfaces, so "1" would be the first host
 *                      interface, "2" the second, and so on.
 *
 *              arg     Driver specific arguments.  For example, some serial
 *                      drivers accept speed and control arguments such as
 *                      "9600" or "19200/NO_BREAK".  These arguments are
 *                      completely free-form: it is the individual drivers
 *                      which do the necessary interpretation.
 *
 *   Returns:
 *          OK: 0
 *       Error: -1
 */
extern int DeviceMatch(const char *name, const char *arg);

/*
 *  Function: DeviceClose
 *
 *   Purpose: Close a communications device
 *
 *  Pre-conditions: Device must have been previously opened
 *
 *    Params: None
 *
 *   Returns: Nothing
 */
extern void DeviceClose(void);

/*
 *  Function: DeviceRead
 *
 *   Purpose: Try to read a complete packet from a communications device.
 *              This read must usually be non-blocking, i.e. it should read as
 *              many data from the device as needed to complete the packet,
 *              but it should not wait if the packet is not complete, and no
 *              more data are currently available from the device.
 *            As an optimisation the read can optionally block when 'block'
 *              is TRUE, but only for a short time.  It is acceptable for the
 *              'block' parameter to be ignored in which case all reads
 *              should be non-blocking.
 *
 *  Pre-conditions: Device has been opened via DeviceOpen()
 *
 *    Params:
 *      In/Out: dc      Describes the packet being read (dc->dc_packet);
 *                      dc->dc_context is for the driver to store private
 *                      context, and is guaranteed to be NULL the first
 *                      time DeviceRead is called for a given packet.
 *
 *          In: block   If TRUE, read may safely block for a short period
 *                      of time (say up to 20ms), to avoid high CPU load
 *                      whilst waiting for a reply.
 *                      If FALSE, read MUST NOT block.
 *
 *   Returns:
 *          OK:  1 (packet is complete)
 *               0 (packet is not yet complete)
 *       Error: -1 bad packet
 *
 *   Post-conditions: should a calamatous error occur panic() will be called
 */
extern int DeviceRead(DriverCall *dc, bool block);

/*
 *  Function: DeviceWrite
 *
 *   Purpose: Try to write a packet to a communications device.  This write
 *              must be non-blocking, i.e. it should write as many data to
 *              the device as is immediately possible, but should not wait
 *              for space to send any more after that.
 *
 *  Pre-conditions: Device has been opened via DeviceOpen()
 *
 *    Params:
 *      In/Out: dc      Describes the packet being written (dc->dc_packet);
 *                      dc->dc_context is for the driver to store private
 *                      context, and is guaranteed to be NULL the first
 *                      time DeviceWrite is called for a given packet.
 *
 *   Returns:
 *          OK:  1 (all of the packet has been written)
 *               0 (some of the packet remains to be written)
 *       Error: -1
 */
extern int DeviceWrite(DriverCall *dc);

/*
 *  Function: DeviceIoctl
 *
 *   Purpose: Perform miscellaneous driver operations
 *
 *  Pre-conditions: Device has been open via DeviceOpen()
 *
 *    Params:
 *       Input: opcode  Reason code indicating the operation to perform
 *      In/Out: args    Pointer to opcode-sensitive arguments/result space
 *
 *   Returns:
 *          OK: 0
 *       Error: -1
 */
extern int DeviceIoctl(const int opcode, void *args);

#endif /* !defined(angsd_drivers_h) */

/* EOF drivers.h */
@


1.2
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@@
