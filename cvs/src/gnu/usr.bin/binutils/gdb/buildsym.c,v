head	1.4;
access;
symbols
	OPENBSD_6_1:1.4.0.52
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.48
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.44
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.46
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.38
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.42
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.40
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.36
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.34
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.32
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.30
	OPENBSD_5_0:1.4.0.28
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.26
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.24
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	GDB_6_3:1.1.1.2
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	GDB_6_1:1.1.1.1
	FSF:1.1.1
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2004.12.27.14.00.33;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.21.20.23.04;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.36.34;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.16.35;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.05.21.19.09.11;	author kettenis;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.12.27.13.06.13;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.16.36;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve conflicts for GDB 6.3.  Add local patches.
ok deraadt@@
@
text
@/* Support routines for building symbol tables in GDB's internal format.
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* This module provides subroutines used for creating and adding to
   the symbol table.  These routines are called from various symbol-
   file-reading routines.

   Routines to support specific debugging information formats (stabs,
   DWARF, etc) belong somewhere else. */

#include "defs.h"
#include "bfd.h"
#include "gdb_obstack.h"
#include "symtab.h"
#include "symfile.h"
#include "objfiles.h"
#include "gdbtypes.h"
#include "gdb_assert.h"
#include "complaints.h"
#include "gdb_string.h"
#include "expression.h"		/* For "enum exp_opcode" used by... */
#include "bcache.h"
#include "filenames.h"		/* For DOSish file names */
#include "macrotab.h"
#include "demangle.h"		/* Needed by SYMBOL_INIT_DEMANGLED_NAME.  */
#include "block.h"
#include "cp-support.h"
#include "dictionary.h"

/* Ask buildsym.h to define the vars it normally declares `extern'.  */
#define	EXTERN
/**/
#include "buildsym.h"		/* Our own declarations */
#undef	EXTERN

/* For cleanup_undefined_types and finish_global_stabs (somewhat
   questionable--see comment where we call them).  */

#include "stabsread.h"

/* List of free `struct pending' structures for reuse.  */

static struct pending *free_pendings;

/* Non-zero if symtab has line number info.  This prevents an
   otherwise empty symtab from being tossed.  */

static int have_line_numbers;

static int compare_line_numbers (const void *ln1p, const void *ln2p);


/* Initial sizes of data structures.  These are realloc'd larger if
   needed, and realloc'd down to the size actually used, when
   completed.  */

#define	INITIAL_CONTEXT_STACK_SIZE	10
#define	INITIAL_LINE_VECTOR_LENGTH	1000


/* maintain the lists of symbols and blocks */

/* Add a pending list to free_pendings. */
void
add_free_pendings (struct pending *list)
{
  struct pending *link = list;

  if (list)
    {
      while (link->next) link = link->next;
      link->next = free_pendings;
      free_pendings = list;
    }
}
      
/* Add a symbol to one of the lists of symbols.  While we're at it, if
   we're in the C++ case and don't have full namespace debugging info,
   check to see if it references an anonymous namespace; if so, add an
   appropriate using directive.  */

void
add_symbol_to_list (struct symbol *symbol, struct pending **listhead)
{
  struct pending *link;

  /* If this is an alias for another symbol, don't add it.  */
  if (symbol->ginfo.name && symbol->ginfo.name[0] == '#')
    return;

  /* We keep PENDINGSIZE symbols in each link of the list. If we
     don't have a link with room in it, add a new link.  */
  if (*listhead == NULL || (*listhead)->nsyms == PENDINGSIZE)
    {
      if (free_pendings)
	{
	  link = free_pendings;
	  free_pendings = link->next;
	}
      else
	{
	  link = (struct pending *) xmalloc (sizeof (struct pending));
	}

      link->next = *listhead;
      *listhead = link;
      link->nsyms = 0;
    }

  (*listhead)->symbol[(*listhead)->nsyms++] = symbol;

  /* Check to see if we might need to look for a mention of anonymous
     namespaces.  */
  
  if (SYMBOL_LANGUAGE (symbol) == language_cplus)
    cp_scan_for_anonymous_namespaces (symbol);
}

/* Find a symbol named NAME on a LIST.  NAME need not be
   '\0'-terminated; LENGTH is the length of the name.  */

struct symbol *
find_symbol_in_list (struct pending *list, char *name, int length)
{
  int j;
  char *pp;

  while (list != NULL)
    {
      for (j = list->nsyms; --j >= 0;)
	{
	  pp = DEPRECATED_SYMBOL_NAME (list->symbol[j]);
	  if (*pp == *name && strncmp (pp, name, length) == 0 &&
	      pp[length] == '\0')
	    {
	      return (list->symbol[j]);
	    }
	}
      list = list->next;
    }
  return (NULL);
}

/* At end of reading syms, or in case of quit, really free as many
   `struct pending's as we can easily find. */

void
really_free_pendings (void *dummy)
{
  struct pending *next, *next1;

  for (next = free_pendings; next; next = next1)
    {
      next1 = next->next;
      xfree ((void *) next);
    }
  free_pendings = NULL;

  free_pending_blocks ();

  for (next = file_symbols; next != NULL; next = next1)
    {
      next1 = next->next;
      xfree ((void *) next);
    }
  file_symbols = NULL;

  for (next = global_symbols; next != NULL; next = next1)
    {
      next1 = next->next;
      xfree ((void *) next);
    }
  global_symbols = NULL;

  if (pending_macros)
    free_macro_table (pending_macros);
}

/* This function is called to discard any pending blocks. */

void
free_pending_blocks (void)
{
#if 0				/* Now we make the links in the
				   objfile_obstack, so don't free
				   them.  */
  struct pending_block *bnext, *bnext1;

  for (bnext = pending_blocks; bnext; bnext = bnext1)
    {
      bnext1 = bnext->next;
      xfree ((void *) bnext);
    }
#endif
  pending_blocks = NULL;
}

/* Take one of the lists of symbols and make a block from it.  Keep
   the order the symbols have in the list (reversed from the input
   file).  Put the block on the list of pending blocks.  */

void
finish_block (struct symbol *symbol, struct pending **listhead,
	      struct pending_block *old_blocks,
	      CORE_ADDR start, CORE_ADDR end,
	      struct objfile *objfile)
{
  struct pending *next, *next1;
  struct block *block;
  struct pending_block *pblock;
  struct pending_block *opblock;

  block = allocate_block (&objfile->objfile_obstack);

  if (symbol)
    {
      BLOCK_DICT (block) = dict_create_linear (&objfile->objfile_obstack,
					       *listhead);
    }
  else
    {
      BLOCK_DICT (block) = dict_create_hashed (&objfile->objfile_obstack,
					       *listhead);
    }

  BLOCK_START (block) = start;
  BLOCK_END (block) = end;
  /* Superblock filled in when containing block is made */
  BLOCK_SUPERBLOCK (block) = NULL;
  BLOCK_NAMESPACE (block) = NULL;

  BLOCK_GCC_COMPILED (block) = processing_gcc_compilation;

  /* Put the block in as the value of the symbol that names it.  */

  if (symbol)
    {
      struct type *ftype = SYMBOL_TYPE (symbol);
      struct dict_iterator iter;
      SYMBOL_BLOCK_VALUE (symbol) = block;
      BLOCK_FUNCTION (block) = symbol;

      if (TYPE_NFIELDS (ftype) <= 0)
	{
	  /* No parameter type information is recorded with the
	     function's type.  Set that from the type of the
	     parameter symbols. */
	  int nparams = 0, iparams;
	  struct symbol *sym;
	  ALL_BLOCK_SYMBOLS (block, iter, sym)
	    {
	      switch (SYMBOL_CLASS (sym))
		{
		case LOC_ARG:
		case LOC_REF_ARG:
		case LOC_REGPARM:
		case LOC_REGPARM_ADDR:
		case LOC_BASEREG_ARG:
		case LOC_LOCAL_ARG:
		case LOC_COMPUTED_ARG:
		  nparams++;
		  break;
		case LOC_UNDEF:
		case LOC_CONST:
		case LOC_STATIC:
		case LOC_INDIRECT:
		case LOC_REGISTER:
		case LOC_LOCAL:
		case LOC_TYPEDEF:
		case LOC_LABEL:
		case LOC_BLOCK:
		case LOC_CONST_BYTES:
		case LOC_BASEREG:
		case LOC_UNRESOLVED:
		case LOC_OPTIMIZED_OUT:
		case LOC_COMPUTED:
		default:
		  break;
		}
	    }
	  if (nparams > 0)
	    {
	      TYPE_NFIELDS (ftype) = nparams;
	      TYPE_FIELDS (ftype) = (struct field *)
		TYPE_ALLOC (ftype, nparams * sizeof (struct field));

	      iparams = 0;
	      ALL_BLOCK_SYMBOLS (block, iter, sym)
		{
		  if (iparams == nparams)
		    break;

		  switch (SYMBOL_CLASS (sym))
		    {
		    case LOC_ARG:
		    case LOC_REF_ARG:
		    case LOC_REGPARM:
		    case LOC_REGPARM_ADDR:
		    case LOC_BASEREG_ARG:
		    case LOC_LOCAL_ARG:
		    case LOC_COMPUTED_ARG:
		      TYPE_FIELD_TYPE (ftype, iparams) = SYMBOL_TYPE (sym);
		      TYPE_FIELD_ARTIFICIAL (ftype, iparams) = 0;
		      iparams++;
		      break;
		    case LOC_UNDEF:
		    case LOC_CONST:
		    case LOC_STATIC:
		    case LOC_INDIRECT:
		    case LOC_REGISTER:
		    case LOC_LOCAL:
		    case LOC_TYPEDEF:
		    case LOC_LABEL:
		    case LOC_BLOCK:
		    case LOC_CONST_BYTES:
		    case LOC_BASEREG:
		    case LOC_UNRESOLVED:
		    case LOC_OPTIMIZED_OUT:
		    case LOC_COMPUTED:
		    default:
		      break;
		    }
		}
	    }
	}

      /* If we're in the C++ case, set the block's scope.  */
      if (SYMBOL_LANGUAGE (symbol) == language_cplus)
	{
	  cp_set_block_scope (symbol, block, &objfile->objfile_obstack);
	}
    }
  else
    {
      BLOCK_FUNCTION (block) = NULL;
    }

  /* Now "free" the links of the list, and empty the list.  */

  for (next = *listhead; next; next = next1)
    {
      next1 = next->next;
      next->next = free_pendings;
      free_pendings = next;
    }
  *listhead = NULL;

#if 1
  /* Check to be sure that the blocks have an end address that is
     greater than starting address */

  if (BLOCK_END (block) < BLOCK_START (block))
    {
      if (symbol)
	{
	  complaint (&symfile_complaints,
		     "block end address less than block start address in %s (patched it)",
		     SYMBOL_PRINT_NAME (symbol));
	}
      else
	{
	  complaint (&symfile_complaints,
		     "block end address 0x%s less than block start address 0x%s (patched it)",
		     paddr_nz (BLOCK_END (block)), paddr_nz (BLOCK_START (block)));
	}
      /* Better than nothing */
      BLOCK_END (block) = BLOCK_START (block);
    }
#endif

  /* Install this block as the superblock of all blocks made since the
     start of this scope that don't have superblocks yet.  */

  opblock = NULL;
  for (pblock = pending_blocks; 
       pblock && pblock != old_blocks; 
       pblock = pblock->next)
    {
      if (BLOCK_SUPERBLOCK (pblock->block) == NULL)
	{
#if 1
	  /* Check to be sure the blocks are nested as we receive
	     them. If the compiler/assembler/linker work, this just
	     burns a small amount of time.  */
	  if (BLOCK_START (pblock->block) < BLOCK_START (block) ||
	      BLOCK_END (pblock->block) > BLOCK_END (block))
	    {
	      if (symbol)
		{
		  complaint (&symfile_complaints,
			     "inner block not inside outer block in %s",
			     SYMBOL_PRINT_NAME (symbol));
		}
	      else
		{
		  complaint (&symfile_complaints,
			     "inner block (0x%s-0x%s) not inside outer block (0x%s-0x%s)",
			     paddr_nz (BLOCK_START (pblock->block)),
			     paddr_nz (BLOCK_END (pblock->block)),
			     paddr_nz (BLOCK_START (block)),
			     paddr_nz (BLOCK_END (block)));
		}
	      if (BLOCK_START (pblock->block) < BLOCK_START (block))
		BLOCK_START (pblock->block) = BLOCK_START (block);
	      if (BLOCK_END (pblock->block) > BLOCK_END (block))
		BLOCK_END (pblock->block) = BLOCK_END (block);
	    }
#endif
	  BLOCK_SUPERBLOCK (pblock->block) = block;
	}
      opblock = pblock;
    }

  record_pending_block (objfile, block, opblock);
}


/* Record BLOCK on the list of all blocks in the file.  Put it after
   OPBLOCK, or at the beginning if opblock is NULL.  This puts the
   block in the list after all its subblocks.

   Allocate the pending block struct in the objfile_obstack to save
   time.  This wastes a little space.  FIXME: Is it worth it?  */

void
record_pending_block (struct objfile *objfile, struct block *block,
		      struct pending_block *opblock)
{
  struct pending_block *pblock;

  pblock = (struct pending_block *)
    obstack_alloc (&objfile->objfile_obstack, sizeof (struct pending_block));
  pblock->block = block;
  if (opblock)
    {
      pblock->next = opblock->next;
      opblock->next = pblock;
    }
  else
    {
      pblock->next = pending_blocks;
      pending_blocks = pblock;
    }
}

static struct blockvector *
make_blockvector (struct objfile *objfile)
{
  struct pending_block *next;
  struct blockvector *blockvector;
  int i;

  /* Count the length of the list of blocks.  */

  for (next = pending_blocks, i = 0; next; next = next->next, i++)
    {;
    }

  blockvector = (struct blockvector *)
    obstack_alloc (&objfile->objfile_obstack,
		   (sizeof (struct blockvector)
		    + (i - 1) * sizeof (struct block *)));

  /* Copy the blocks into the blockvector. This is done in reverse
     order, which happens to put the blocks into the proper order
     (ascending starting address). finish_block has hair to insert
     each block into the list after its subblocks in order to make
     sure this is true.  */

  BLOCKVECTOR_NBLOCKS (blockvector) = i;
  for (next = pending_blocks; next; next = next->next)
    {
      BLOCKVECTOR_BLOCK (blockvector, --i) = next->block;
    }

#if 0				/* Now we make the links in the
				   obstack, so don't free them.  */
  /* Now free the links of the list, and empty the list.  */

  for (next = pending_blocks; next; next = next1)
    {
      next1 = next->next;
      xfree (next);
    }
#endif
  pending_blocks = NULL;

#if 1				/* FIXME, shut this off after a while
				   to speed up symbol reading.  */
  /* Some compilers output blocks in the wrong order, but we depend on
     their being in the right order so we can binary search. Check the
     order and moan about it.  FIXME.  */
  if (BLOCKVECTOR_NBLOCKS (blockvector) > 1)
    {
      for (i = 1; i < BLOCKVECTOR_NBLOCKS (blockvector); i++)
	{
	  if (BLOCK_START (BLOCKVECTOR_BLOCK (blockvector, i - 1))
	      > BLOCK_START (BLOCKVECTOR_BLOCK (blockvector, i)))
	    {
	      CORE_ADDR start
		= BLOCK_START (BLOCKVECTOR_BLOCK (blockvector, i));

	      complaint (&symfile_complaints, "block at %s out of order",
			 hex_string ((LONGEST) start));
	    }
	}
    }
#endif

  return (blockvector);
}

/* Start recording information about source code that came from an
   included (or otherwise merged-in) source file with a different
   name.  NAME is the name of the file (cannot be NULL), DIRNAME is
   the directory in which it resides (or NULL if not known).  */

void
start_subfile (char *name, char *dirname)
{
  struct subfile *subfile;

  /* See if this subfile is already known as a subfile of the current
     main source file.  */

  for (subfile = subfiles; subfile; subfile = subfile->next)
    {
      if (FILENAME_CMP (subfile->name, name) == 0)
	{
	  current_subfile = subfile;
	  return;
	}
    }

  /* This subfile is not known.  Add an entry for it. Make an entry
     for this subfile in the list of all subfiles of the current main
     source file.  */

  subfile = (struct subfile *) xmalloc (sizeof (struct subfile));
  memset ((char *) subfile, 0, sizeof (struct subfile));
  subfile->next = subfiles;
  subfiles = subfile;
  current_subfile = subfile;

  /* Save its name and compilation directory name */
  subfile->name = (name == NULL) ? NULL : savestring (name, strlen (name));
  subfile->dirname =
    (dirname == NULL) ? NULL : savestring (dirname, strlen (dirname));

  /* Initialize line-number recording for this subfile.  */
  subfile->line_vector = NULL;

  /* Default the source language to whatever can be deduced from the
     filename.  If nothing can be deduced (such as for a C/C++ include
     file with a ".h" extension), then inherit whatever language the
     previous subfile had.  This kludgery is necessary because there
     is no standard way in some object formats to record the source
     language.  Also, when symtabs are allocated we try to deduce a
     language then as well, but it is too late for us to use that
     information while reading symbols, since symtabs aren't allocated
     until after all the symbols have been processed for a given
     source file. */

  subfile->language = deduce_language_from_filename (subfile->name);
  if (subfile->language == language_unknown &&
      subfile->next != NULL)
    {
      subfile->language = subfile->next->language;
    }

  /* Initialize the debug format string to NULL.  We may supply it
     later via a call to record_debugformat. */
  subfile->debugformat = NULL;

  /* If the filename of this subfile ends in .C, then change the
     language of any pending subfiles from C to C++.  We also accept
     any other C++ suffixes accepted by deduce_language_from_filename.  */
  /* Likewise for f2c.  */

  if (subfile->name)
    {
      struct subfile *s;
      enum language sublang = deduce_language_from_filename (subfile->name);

      if (sublang == language_cplus || sublang == language_fortran)
	for (s = subfiles; s != NULL; s = s->next)
	  if (s->language == language_c)
	    s->language = sublang;
    }

  /* And patch up this file if necessary.  */
  if (subfile->language == language_c
      && subfile->next != NULL
      && (subfile->next->language == language_cplus
	  || subfile->next->language == language_fortran))
    {
      subfile->language = subfile->next->language;
    }
}

/* For stabs readers, the first N_SO symbol is assumed to be the
   source file name, and the subfile struct is initialized using that
   assumption.  If another N_SO symbol is later seen, immediately
   following the first one, then the first one is assumed to be the
   directory name and the second one is really the source file name.

   So we have to patch up the subfile struct by moving the old name
   value to dirname and remembering the new name.  Some sanity
   checking is performed to ensure that the state of the subfile
   struct is reasonable and that the old name we are assuming to be a
   directory name actually is (by checking for a trailing '/'). */

void
patch_subfile_names (struct subfile *subfile, char *name)
{
  if (subfile != NULL && subfile->dirname == NULL && subfile->name != NULL
      && subfile->name[strlen (subfile->name) - 1] == '/')
    {
      subfile->dirname = subfile->name;
      subfile->name = savestring (name, strlen (name));
      last_source_file = name;

      /* Default the source language to whatever can be deduced from
         the filename.  If nothing can be deduced (such as for a C/C++
         include file with a ".h" extension), then inherit whatever
         language the previous subfile had.  This kludgery is
         necessary because there is no standard way in some object
         formats to record the source language.  Also, when symtabs
         are allocated we try to deduce a language then as well, but
         it is too late for us to use that information while reading
         symbols, since symtabs aren't allocated until after all the
         symbols have been processed for a given source file. */

      subfile->language = deduce_language_from_filename (subfile->name);
      if (subfile->language == language_unknown &&
	  subfile->next != NULL)
	{
	  subfile->language = subfile->next->language;
	}
    }
}

/* Handle the N_BINCL and N_EINCL symbol types that act like N_SOL for
   switching source files (different subfiles, as we call them) within
   one object file, but using a stack rather than in an arbitrary
   order.  */

void
push_subfile (void)
{
  struct subfile_stack *tem
  = (struct subfile_stack *) xmalloc (sizeof (struct subfile_stack));

  tem->next = subfile_stack;
  subfile_stack = tem;
  if (current_subfile == NULL || current_subfile->name == NULL)
    {
      internal_error (__FILE__, __LINE__, "failed internal consistency check");
    }
  tem->name = current_subfile->name;
}

char *
pop_subfile (void)
{
  char *name;
  struct subfile_stack *link = subfile_stack;

  if (link == NULL)
    {
      internal_error (__FILE__, __LINE__, "failed internal consistency check");
    }
  name = link->name;
  subfile_stack = link->next;
  xfree ((void *) link);
  return (name);
}

/* Add a linetable entry for line number LINE and address PC to the
   line vector for SUBFILE.  */

void
record_line (struct subfile *subfile, int line, CORE_ADDR pc)
{
  struct linetable_entry *e;
  /* Ignore the dummy line number in libg.o */

  if (line == 0xffff)
    {
      return;
    }

  /* Make sure line vector exists and is big enough.  */
  if (!subfile->line_vector)
    {
      subfile->line_vector_length = INITIAL_LINE_VECTOR_LENGTH;
      subfile->line_vector = (struct linetable *)
	xmalloc (sizeof (struct linetable)
	   + subfile->line_vector_length * sizeof (struct linetable_entry));
      subfile->line_vector->nitems = 0;
      have_line_numbers = 1;
    }

  if (subfile->line_vector->nitems + 1 >= subfile->line_vector_length)
    {
      subfile->line_vector_length *= 2;
      subfile->line_vector = (struct linetable *)
	xrealloc ((char *) subfile->line_vector,
		  (sizeof (struct linetable)
		   + (subfile->line_vector_length
		      * sizeof (struct linetable_entry))));
    }

  e = subfile->line_vector->item + subfile->line_vector->nitems++;
  e->line = line;
  e->pc = ADDR_BITS_REMOVE(pc);
}

/* Needed in order to sort line tables from IBM xcoff files.  Sigh!  */

static int
compare_line_numbers (const void *ln1p, const void *ln2p)
{
  struct linetable_entry *ln1 = (struct linetable_entry *) ln1p;
  struct linetable_entry *ln2 = (struct linetable_entry *) ln2p;

  /* Note: this code does not assume that CORE_ADDRs can fit in ints.
     Please keep it that way.  */
  if (ln1->pc < ln2->pc)
    return -1;

  if (ln1->pc > ln2->pc)
    return 1;

  /* If pc equal, sort by line.  I'm not sure whether this is optimum
     behavior (see comment at struct linetable in symtab.h).  */
  return ln1->line - ln2->line;
}

/* Start a new symtab for a new source file.  Called, for example,
   when a stabs symbol of type N_SO is seen, or when a DWARF
   TAG_compile_unit DIE is seen.  It indicates the start of data for
   one original source file.  */

void
start_symtab (char *name, char *dirname, CORE_ADDR start_addr)
{

  last_source_file = name;
  last_source_start_addr = start_addr;
  file_symbols = NULL;
  global_symbols = NULL;
  within_function = 0;
  have_line_numbers = 0;

  /* Context stack is initially empty.  Allocate first one with room
     for 10 levels; reuse it forever afterward.  */
  if (context_stack == NULL)
    {
      context_stack_size = INITIAL_CONTEXT_STACK_SIZE;
      context_stack = (struct context_stack *)
	xmalloc (context_stack_size * sizeof (struct context_stack));
    }
  context_stack_depth = 0;

  /* Set up support for C++ namespace support, in case we need it.  */

  cp_initialize_namespace ();

  /* Initialize the list of sub source files with one entry for this
     file (the top-level source file).  */

  subfiles = NULL;
  current_subfile = NULL;
  start_subfile (name, dirname);
}

/* Finish the symbol definitions for one main source file, close off
   all the lexical contexts for that file (creating struct block's for
   them), then make the struct symtab for that file and put it in the
   list of all such.

   END_ADDR is the address of the end of the file's text.  SECTION is
   the section number (in objfile->section_offsets) of the blockvector
   and linetable.

   Note that it is possible for end_symtab() to return NULL.  In
   particular, for the DWARF case at least, it will return NULL when
   it finds a compilation unit that has exactly one DIE, a
   TAG_compile_unit DIE.  This can happen when we link in an object
   file that was compiled from an empty source file.  Returning NULL
   is probably not the correct thing to do, because then gdb will
   never know about this empty file (FIXME). */

struct symtab *
end_symtab (CORE_ADDR end_addr, struct objfile *objfile, int section)
{
  struct symtab *symtab = NULL;
  struct blockvector *blockvector;
  struct subfile *subfile;
  struct context_stack *cstk;
  struct subfile *nextsub;

  /* Finish the lexical context of the last function in the file; pop
     the context stack.  */

  if (context_stack_depth > 0)
    {
      cstk = pop_context ();
      /* Make a block for the local symbols within.  */
      finish_block (cstk->name, &local_symbols, cstk->old_blocks,
		    cstk->start_addr, end_addr, objfile);

      if (context_stack_depth > 0)
	{
	  /* This is said to happen with SCO.  The old coffread.c
	     code simply emptied the context stack, so we do the
	     same.  FIXME: Find out why it is happening.  This is not
	     believed to happen in most cases (even for coffread.c);
	     it used to be an abort().  */
	  complaint (&symfile_complaints,
	             "Context stack not empty in end_symtab");
	  context_stack_depth = 0;
	}
    }

  /* Reordered executables may have out of order pending blocks; if
     OBJF_REORDERED is true, then sort the pending blocks.  */
  if ((objfile->flags & OBJF_REORDERED) && pending_blocks)
    {
      /* FIXME!  Remove this horrid bubble sort and use merge sort!!! */
      int swapped;
      do
	{
	  struct pending_block *pb, *pbnext;

	  pb = pending_blocks;
	  pbnext = pb->next;
	  swapped = 0;

	  while (pbnext)
	    {
	      /* swap blocks if unordered! */

	      if (BLOCK_START (pb->block) < BLOCK_START (pbnext->block))
		{
		  struct block *tmp = pb->block;
		  pb->block = pbnext->block;
		  pbnext->block = tmp;
		  swapped = 1;
		}
	      pb = pbnext;
	      pbnext = pbnext->next;
	    }
	}
      while (swapped);
    }

  /* Cleanup any undefined types that have been left hanging around
     (this needs to be done before the finish_blocks so that
     file_symbols is still good).

     Both cleanup_undefined_types and finish_global_stabs are stabs
     specific, but harmless for other symbol readers, since on gdb
     startup or when finished reading stabs, the state is set so these
     are no-ops.  FIXME: Is this handled right in case of QUIT?  Can
     we make this cleaner?  */

  cleanup_undefined_types ();
  finish_global_stabs (objfile);

  if (pending_blocks == NULL
      && file_symbols == NULL
      && global_symbols == NULL
      && have_line_numbers == 0
      && pending_macros == NULL)
    {
      /* Ignore symtabs that have no functions with real debugging
         info.  */
      blockvector = NULL;
    }
  else
    {
      /* Define the STATIC_BLOCK & GLOBAL_BLOCK, and build the
         blockvector.  */
      finish_block (0, &file_symbols, 0, last_source_start_addr, end_addr,
		    objfile);
      finish_block (0, &global_symbols, 0, last_source_start_addr, end_addr,
		    objfile);
      blockvector = make_blockvector (objfile);
      cp_finalize_namespace (BLOCKVECTOR_BLOCK (blockvector, STATIC_BLOCK),
			     &objfile->objfile_obstack);
    }

#ifndef PROCESS_LINENUMBER_HOOK
#define PROCESS_LINENUMBER_HOOK()
#endif
  PROCESS_LINENUMBER_HOOK ();	/* Needed for xcoff. */

  /* Now create the symtab objects proper, one for each subfile.  */
  /* (The main file is the last one on the chain.)  */

  for (subfile = subfiles; subfile; subfile = nextsub)
    {
      int linetablesize = 0;
      symtab = NULL;

      /* If we have blocks of symbols, make a symtab. Otherwise, just
         ignore this file and any line number info in it.  */
      if (blockvector)
	{
	  if (subfile->line_vector)
	    {
	      linetablesize = sizeof (struct linetable) +
	        subfile->line_vector->nitems * sizeof (struct linetable_entry);
#if 0
	      /* I think this is artifact from before it went on the
	         obstack. I doubt we'll need the memory between now
	         and when we free it later in this function.  */
	      /* First, shrink the linetable to make more memory.  */
	      subfile->line_vector = (struct linetable *)
		xrealloc ((char *) subfile->line_vector, linetablesize);
#endif

	      /* Like the pending blocks, the line table may be
	         scrambled in reordered executables.  Sort it if
	         OBJF_REORDERED is true.  */
	      if (objfile->flags & OBJF_REORDERED)
		qsort (subfile->line_vector->item,
		       subfile->line_vector->nitems,
		     sizeof (struct linetable_entry), compare_line_numbers);
	    }

	  /* Now, allocate a symbol table.  */
	  symtab = allocate_symtab (subfile->name, objfile);

	  /* Fill in its components.  */
	  symtab->blockvector = blockvector;
          symtab->macro_table = pending_macros;
	  if (subfile->line_vector)
	    {
	      /* Reallocate the line table on the symbol obstack */
	      symtab->linetable = (struct linetable *)
		obstack_alloc (&objfile->objfile_obstack, linetablesize);
	      memcpy (symtab->linetable, subfile->line_vector, linetablesize);
	    }
	  else
	    {
	      symtab->linetable = NULL;
	    }
	  symtab->block_line_section = section;
	  if (subfile->dirname)
	    {
	      /* Reallocate the dirname on the symbol obstack */
	      symtab->dirname = (char *)
		obstack_alloc (&objfile->objfile_obstack,
			       strlen (subfile->dirname) + 1);
	      strcpy (symtab->dirname, subfile->dirname);
	    }
	  else
	    {
	      symtab->dirname = NULL;
	    }
	  symtab->free_code = free_linetable;
	  symtab->free_func = NULL;

	  /* Use whatever language we have been using for this
	     subfile, not the one that was deduced in allocate_symtab
	     from the filename.  We already did our own deducing when
	     we created the subfile, and we may have altered our
	     opinion of what language it is from things we found in
	     the symbols. */
	  symtab->language = subfile->language;

	  /* Save the debug format string (if any) in the symtab */
	  if (subfile->debugformat != NULL)
	    {
	      symtab->debugformat = obsavestring (subfile->debugformat,
					      strlen (subfile->debugformat),
						  &objfile->objfile_obstack);
	    }

	  /* All symtabs for the main file and the subfiles share a
	     blockvector, so we need to clear primary for everything
	     but the main file.  */

	  symtab->primary = 0;
	}
      if (subfile->name != NULL)
	{
	  xfree ((void *) subfile->name);
	}
      if (subfile->dirname != NULL)
	{
	  xfree ((void *) subfile->dirname);
	}
      if (subfile->line_vector != NULL)
	{
	  xfree ((void *) subfile->line_vector);
	}
      if (subfile->debugformat != NULL)
	{
	  xfree ((void *) subfile->debugformat);
	}

      nextsub = subfile->next;
      xfree ((void *) subfile);
    }

  /* Set this for the main source file.  */
  if (symtab)
    {
      symtab->primary = 1;
    }

  last_source_file = NULL;
  current_subfile = NULL;
  pending_macros = NULL;

  return symtab;
}

/* Push a context block.  Args are an identifying nesting level
   (checkable when you pop it), and the starting PC address of this
   context.  */

struct context_stack *
push_context (int desc, CORE_ADDR valu)
{
  struct context_stack *new;

  if (context_stack_depth == context_stack_size)
    {
      context_stack_size *= 2;
      context_stack = (struct context_stack *)
	xrealloc ((char *) context_stack,
		  (context_stack_size * sizeof (struct context_stack)));
    }

  new = &context_stack[context_stack_depth++];
  new->depth = desc;
  new->locals = local_symbols;
  new->params = param_symbols;
  new->old_blocks = pending_blocks;
  new->start_addr = valu;
  new->name = NULL;

  local_symbols = NULL;
  param_symbols = NULL;

  return new;
}

/* Pop a context block.  Returns the address of the context block just
   popped. */

struct context_stack *
pop_context (void)
{
  gdb_assert (context_stack_depth > 0);
  return (&context_stack[--context_stack_depth]);
}



/* Compute a small integer hash code for the given name. */

int
hashname (char *name)
{
    return (hash(name,strlen(name)) % HASHSIZE);
}


void
record_debugformat (char *format)
{
  current_subfile->debugformat = savestring (format, strlen (format));
}

/* Merge the first symbol list SRCLIST into the second symbol list
   TARGETLIST by repeated calls to add_symbol_to_list().  This
   procedure "frees" each link of SRCLIST by adding it to the
   free_pendings list.  Caller must set SRCLIST to a null list after
   calling this function.

   Void return. */

void
merge_symbol_lists (struct pending **srclist, struct pending **targetlist)
{
  int i;

  if (!srclist || !*srclist)
    return;

  /* Merge in elements from current link.  */
  for (i = 0; i < (*srclist)->nsyms; i++)
    add_symbol_to_list ((*srclist)->symbol[i], targetlist);

  /* Recurse on next.  */
  merge_symbol_lists (&(*srclist)->next, targetlist);

  /* "Free" the current link.  */
  (*srclist)->next = free_pendings;
  free_pendings = (*srclist);
}

/* Initialize anything that needs initializing when starting to read a
   fresh piece of a symbol file, e.g. reading in the stuff
   corresponding to a psymtab.  */

void
buildsym_init (void)
{
  free_pendings = NULL;
  file_symbols = NULL;
  global_symbols = NULL;
  pending_blocks = NULL;
  pending_macros = NULL;
}

/* Initialize anything that needs initializing when a completely new
   symbol file is specified (not just adding some symbols from another
   file, e.g. a shared library).  */

void
buildsym_new_init (void)
{
  buildsym_init ();
}
@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@a40 1
#include "language.h"		/* For "local_hex_string" */
d523 1
a523 1
			 local_hex_string ((LONGEST) start));
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 20
a21 18
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1995, 1996
             Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d32 1
a32 1
#include "obstack.h"
d34 1
a34 1
#include "symfile.h"		/* Needed for "struct complaint" */
d37 1
d40 9
d51 2
a52 1
#define	EXTERN	/**/
d58 1
a60 7
/* Pointer to the head of a linked list of symbol blocks which have
   already been finalized (lexical contexts already closed) and which are
   just waiting to be built into a blockvector when finalizing the
   associated symtab. */

static struct pending_block *pending_blocks = NULL;

d65 6
a71 2
static int
compare_line_numbers PARAMS ((const void *, const void *));
d73 3
a75 3

/* Initial sizes of data structures.  These are realloc'd larger if needed,
   and realloc'd down to the size actually used, when completed.  */
a78 1

a79 1
/* Complaints about the symbols we have encountered.  */
d81 1
a81 2
struct complaint block_end_complaint =
  {"block end address less than block start address in %s (patched it)", 0, 0};
d83 5
a87 2
struct complaint anon_block_end_complaint =
  {"block end address 0x%lx less than block start address 0x%lx (patched it)", 0, 0};
d89 12
a100 2
struct complaint innerblock_complaint =
  {"inner block not inside outer block in %s", 0, 0};
d102 4
a105 2
struct complaint innerblock_anon_complaint =
  {"inner block (0x%lx-0x%lx) not inside outer block (0x%lx-0x%lx)", 0, 0};
d107 3
a109 2
struct complaint blockvector_complaint = 
  {"block at 0x%lx out of order", 0, 0};
d111 2
a112 14

/* maintain the lists of symbols and blocks */

/* Add a symbol to one of the lists of symbols.  */

void
add_symbol_to_list (symbol, listhead)
     struct symbol *symbol;
     struct pending **listhead;
{
  register struct pending *link;
      
  /* We keep PENDINGSIZE symbols in each link of the list.
     If we don't have a link with room in it, add a new link.  */
d131 6
d139 2
a140 2
/* Find a symbol named NAME on a LIST.  NAME need not be '\0'-terminated;
   LENGTH is the length of the name.  */
d143 1
a143 4
find_symbol_in_list (list, name, length)
     struct pending *list;
     char *name;
     int length;
d150 1
a150 1
      for (j = list->nsyms; --j >= 0; )
d152 1
a152 1
	  pp = SYMBOL_NAME (list->symbol[j]);
d164 2
a165 2
/* At end of reading syms, or in case of quit,
   really free as many `struct pending's as we can easily find. */
a166 1
/* ARGSUSED */
d168 1
a168 2
really_free_pendings (foo)
     int foo;
d175 1
a175 1
      free ((PTR)next);
d184 1
a184 1
      free ((PTR)next);
d191 1
a191 1
      free ((PTR)next);
d194 3
d202 1
a202 1
free_pending_blocks ()
d204 3
a206 1
#if 0 /* Now we make the links in the symbol_obstack, so don't free them.  */
d212 1
a212 1
      free ((PTR)bnext);
d218 3
a220 3
/* Take one of the lists of symbols and make a block from it.
   Keep the order the symbols have in the list (reversed from the input file).
   Put the block on the list of pending blocks.  */
d223 8
a230 10
finish_block (symbol, listhead, old_blocks, start, end, objfile)
     struct symbol *symbol;
     struct pending **listhead;
     struct pending_block *old_blocks;
     CORE_ADDR start, end;
     struct objfile *objfile;
{
  register struct pending *next, *next1;
  register struct block *block;
  register struct pending_block *pblock;
a231 2
  register int i;
  register int j;
d233 1
a233 1
  /* Count the length of the list of symbols.  */
d235 1
a235 3
  for (next = *listhead, i = 0;
       next;
       i += next->nsyms, next = next->next)
d237 2
a238 1
      /*EMPTY*/;
d240 1
a240 8

  block = (struct block *) obstack_alloc (&objfile -> symbol_obstack,
	  (sizeof (struct block) + ((i - 1) * sizeof (struct symbol *))));

  /* Copy the symbols into the block.  */

  BLOCK_NSYMS (block) = i;
  for (next = *listhead; next; next = next->next)
d242 2
a243 4
      for (j = next->nsyms - 1; j >= 0; j--)
	{
	  BLOCK_SYM (block, --i) = next->symbol[j];
	}
d248 1
a248 1
 /* Superblock filled in when containing block is made */
d250 2
d259 1
d265 3
a267 2
	  /* No parameter type information is recorded with the function's
	     type.  Set that from the type of the parameter symbols. */
d270 1
a270 1
	  for (i = 0; i < BLOCK_NSYMS (block); i++)
a271 1
	      sym = BLOCK_SYM (block, i);
d280 1
d286 1
d296 1
d306 3
a308 2
						
	      for (i = iparams = 0; iparams < nparams; i++)
d310 3
a312 1
		  sym = BLOCK_SYM (block, i);
d321 1
d323 1
d329 1
d339 1
d346 6
d376 3
a378 1
	  complain (&block_end_complaint, SYMBOL_SOURCE_NAME (symbol));
d382 3
a384 1
	  complain (&anon_block_end_complaint, BLOCK_END (block), BLOCK_START (block));
d391 2
a392 3
  /* Install this block as the superblock
     of all blocks made since the start of this scope
     that don't have superblocks yet.  */
d395 3
a397 1
  for (pblock = pending_blocks; pblock != old_blocks; pblock = pblock->next)
d402 3
a404 3
	  /* Check to be sure the blocks are nested as we receive them. 
	     If the compiler/assembler/linker work, this just burns a small
	     amount of time.  */
d406 1
a406 1
	      BLOCK_END   (pblock->block) > BLOCK_END   (block))
d410 3
a412 2
		  complain (&innerblock_complaint,
			    SYMBOL_SOURCE_NAME (symbol));
d416 6
a421 3
		  complain (&innerblock_anon_complaint, BLOCK_START (pblock->block),
			    BLOCK_END (pblock->block), BLOCK_START (block),
			    BLOCK_END (block));
d423 4
a426 2
	      BLOCK_START (pblock->block) = BLOCK_START (block);
	      BLOCK_END   (pblock->block) = BLOCK_END   (block);
d437 1
d439 2
a440 2
   OPBLOCK, or at the beginning if opblock is NULL.  This puts the block
   in the list after all its subblocks.
d442 1
a442 1
   Allocate the pending block struct in the symbol_obstack to save
d446 2
a447 4
record_pending_block (objfile, block, opblock)
     struct objfile* objfile;
     struct block *block;
     struct pending_block *opblock;
d449 1
a449 1
  register struct pending_block *pblock;
d452 2
a453 2
    obstack_alloc (&objfile -> symbol_obstack, sizeof (struct pending_block));
  pblock -> block = block;
d456 2
a457 2
      pblock -> next = opblock -> next;
      opblock -> next = pblock;
d461 1
a461 1
      pblock -> next = pending_blocks;
d466 6
a471 11
/* Note that this is only used in this file and in dstread.c, which should be
   fixed to not need direct access to this function.  When that is done, it can
   be made static again. */

struct blockvector *
make_blockvector (objfile)
     struct objfile *objfile;
{
  register struct pending_block *next;
  register struct blockvector *blockvector;
  register int i;
d475 3
a477 1
  for (next = pending_blocks, i = 0; next; next = next->next, i++) {;}
d480 1
a480 1
    obstack_alloc (&objfile -> symbol_obstack,
d484 5
a488 5
  /* Copy the blocks into the blockvector.
     This is done in reverse order, which happens to put
     the blocks into the proper order (ascending starting address).
     finish_block has hair to insert each block into the list
     after its subblocks in order to make sure this is true.  */
d496 2
a497 1
#if 0 /* Now we make the links in the obstack, so don't free them.  */
d503 1
a503 1
      free (next);
d508 5
a512 4
#if 1  /* FIXME, shut this off after a while to speed up symbol reading.  */
  /* Some compilers output blocks in the wrong order, but we depend
     on their being in the right order so we can binary search. 
     Check the order and moan about it.  FIXME.  */
d517 2
a518 2
	  if (BLOCK_START(BLOCKVECTOR_BLOCK (blockvector, i-1))
	      > BLOCK_START(BLOCKVECTOR_BLOCK (blockvector, i)))
d520 2
d523 2
a524 10
	      /* FIXME-32x64: loses if CORE_ADDR doesn't fit in a
		 long.  Possible solutions include a version of
		 complain which takes a callback, a
		 sprintf_address_numeric to match
		 print_address_numeric, or a way to set up a GDB_FILE
		 * which causes sprintf rather than fprintf to be
		 called.  */

	      complain (&blockvector_complaint, 
			(unsigned long) BLOCK_START(BLOCKVECTOR_BLOCK (blockvector, i)));
a531 1

d533 4
a536 4
/* Start recording information about source code that came from an included
   (or otherwise merged-in) source file with a different name.  NAME is
   the name of the file (cannot be NULL), DIRNAME is the directory in which
   it resides (or NULL if not known).  */
d539 1
a539 3
start_subfile (name, dirname)
     char *name;
     char *dirname;
d541 1
a541 1
  register struct subfile *subfile;
d543 2
a544 2
  /* See if this subfile is already known as a subfile of the
     current main source file.  */
d548 1
a548 1
      if (STREQ (subfile->name, name))
d555 3
a557 3
  /* This subfile is not known.  Add an entry for it.
     Make an entry for this subfile in the list of all subfiles
     of the current main source file.  */
d560 1
d569 1
a569 1
  
d573 10
a582 10
  /* Default the source language to whatever can be deduced from
     the filename.  If nothing can be deduced (such as for a C/C++
     include file with a ".h" extension), then inherit whatever
     language the previous subfile had.  This kludgery is necessary
     because there is no standard way in some object formats to
     record the source language.  Also, when symtabs are allocated
     we try to deduce a language then as well, but it is too late
     for us to use that information while reading symbols, since
     symtabs aren't allocated until after all the symbols have
     been processed for a given source file. */
d591 7
a597 9
  /* cfront output is a C program, so in most ways it looks like a C
     program.  But to demangle we need to set the language to C++.  We
     can distinguish cfront code by the fact that it has #line
     directives which specify a file name ending in .C.

     So if the filename of this subfile ends in .C, then change the language
     of any pending subfiles from C to C++.  We also accept any other C++
     suffixes accepted by deduce_language_from_filename (in particular,
     some people use .cxx with cfront).  */
d621 11
a631 11
/* For stabs readers, the first N_SO symbol is assumed to be the source
   file name, and the subfile struct is initialized using that assumption.
   If another N_SO symbol is later seen, immediately following the first
   one, then the first one is assumed to be the directory name and the
   second one is really the source file name.

   So we have to patch up the subfile struct by moving the old name value to
   dirname and remembering the new name.  Some sanity checking is performed
   to ensure that the state of the subfile struct is reasonable and that the
   old name we are assuming to be a directory name actually is (by checking
   for a trailing '/'). */
d634 1
a634 3
patch_subfile_names (subfile, name)
     struct subfile *subfile;
     char *name;
d637 1
a637 1
      && subfile->name[strlen(subfile->name)-1] == '/')
d644 9
a652 9
	 the filename.  If nothing can be deduced (such as for a C/C++
	 include file with a ".h" extension), then inherit whatever
	 language the previous subfile had.  This kludgery is necessary
	 because there is no standard way in some object formats to
	 record the source language.  Also, when symtabs are allocated
	 we try to deduce a language then as well, but it is too late
	 for us to use that information while reading symbols, since
	 symtabs aren't allocated until after all the symbols have
	 been processed for a given source file. */
a661 1

d663 4
a666 4
/* Handle the N_BINCL and N_EINCL symbol types
   that act like N_SOL for switching source files
   (different subfiles, as we call them) within one object file,
   but using a stack rather than in an arbitrary order.  */
d669 1
a669 1
push_subfile ()
d671 2
a672 2
  register struct subfile_stack *tem
    = (struct subfile_stack *) xmalloc (sizeof (struct subfile_stack));
d678 1
a678 1
      abort ();
d684 1
a684 1
pop_subfile ()
d686 2
a687 2
  register char *name;
  register struct subfile_stack *link = subfile_stack;
d691 1
a691 1
      abort ();
d695 1
a695 1
  free ((PTR)link);
a697 1

d699 2
a700 2
/* Add a linetable entry for line number LINE and address PC to the line
   vector for SUBFILE.  */
d703 1
a703 4
record_line (subfile, line, pc)
     register struct subfile *subfile;
     int line;
     CORE_ADDR pc;
d719 1
a719 1
	  + subfile->line_vector_length * sizeof (struct linetable_entry));
d721 1
d728 4
a731 2
	xrealloc ((char *) subfile->line_vector, (sizeof (struct linetable)
	  + subfile->line_vector_length * sizeof (struct linetable_entry)));
d735 2
a736 1
  e->line = line; e->pc = pc;
a738 1

d742 1
a742 3
compare_line_numbers (ln1p, ln2p)
     const void *ln1p;
     const void *ln2p;
a758 1

d760 4
a763 4
/* Start a new symtab for a new source file.
   Called, for example, when a stabs symbol of type N_SO is seen, or when
   a DWARF TAG_compile_unit DIE is seen.
   It indicates the start of data for one original source file.  */
d766 1
a766 4
start_symtab (name, dirname, start_addr)
     char *name;
     char *dirname;
     CORE_ADDR start_addr;
d774 1
d776 2
a777 2
  /* Context stack is initially empty.  Allocate first one with room for
     10 levels; reuse it forever afterward.  */
d786 6
a791 2
  /* Initialize the list of sub source files with one entry
     for this file (the top-level source file).  */
d798 16
a813 15
/* Finish the symbol definitions for one main source file,
   close off all the lexical contexts for that file
   (creating struct block's for them), then make the struct symtab
   for that file and put it in the list of all such.

   END_ADDR is the address of the end of the file's text.
   SECTION is the section number (in objfile->section_offsets) of
   the blockvector and linetable.

   Note that it is possible for end_symtab() to return NULL.  In particular,
   for the DWARF case at least, it will return NULL when it finds a
   compilation unit that has exactly one DIE, a TAG_compile_unit DIE.  This
   can happen when we link in an object file that was compiled from an empty
   source file.  Returning NULL is probably not the correct thing to do,
   because then gdb will never know about this empty file (FIXME). */
d816 6
a821 9
end_symtab (end_addr, objfile, section)
     CORE_ADDR end_addr;
     struct objfile *objfile;
     int section;
{
  register struct symtab *symtab = NULL;
  register struct blockvector *blockvector;
  register struct subfile *subfile;
  register struct context_stack *cstk;
d824 2
a825 2
  /* Finish the lexical context of the last function in the file;
     pop the context stack.  */
d829 1
a829 1
      cstk = pop_context();
d836 7
a842 7
	  /* This is said to happen with SCO.  The old coffread.c code
	     simply emptied the context stack, so we do the same.  FIXME:
	     Find out why it is happening.  This is not believed to happen
	     in most cases (even for coffread.c); it used to be an abort().  */
	  static struct complaint msg =
	    {"Context stack not empty in end_symtab", 0, 0};
	  complain (&msg);
d851 1
a851 2
      /* FIXME!  Remove this horrid bubble sort and use qsort!!!
	 It'd be a whole lot easier if they weren't in a linked list!!! */
d856 1
a856 1
	  
d864 2
a865 2
	  
	      if (BLOCK_START(pb->block) < BLOCK_START(pbnext->block)) 
d875 2
a876 1
	} while (swapped);
d894 3
a896 1
      && global_symbols == NULL)
d898 2
a899 1
      /* Ignore symtabs that have no functions with real debugging info */
d904 2
a905 1
      /* Define the STATIC_BLOCK & GLOBAL_BLOCK, and build the blockvector. */
d911 2
d915 2
a916 2
#ifdef PROCESS_LINENUMBER_HOOK
  PROCESS_LINENUMBER_HOOK ();			/* Needed for xcoff. */
d918 1
a925 2
      /* If we have blocks of symbols, make a symtab.
	 Otherwise, just ignore this file and any line number info in it.  */
d927 3
d935 1
a935 1
		subfile->line_vector->nitems * sizeof (struct linetable_entry);
d937 3
a939 3
	      /* I think this is artifact from before it went on the obstack.
		 I doubt we'll need the memory between now and when we
		 free it later in this function.  */
d945 3
a947 3
	      /* Like the pending blocks, the line table may be scrambled
		 in reordered executables.  Sort it if OBJF_REORDERED is
		 true.  */
d951 1
a951 1
		       sizeof (struct linetable_entry), compare_line_numbers);
d959 1
d963 2
a964 2
	      symtab->linetable = (struct linetable *) 
		obstack_alloc (&objfile -> symbol_obstack, linetablesize);
d976 2
a977 2
		obstack_alloc (&objfile -> symbol_obstack,
			       strlen (subfile -> dirname) + 1);
d985 1
a985 1
	  symtab->free_ptr = NULL;
d987 6
a992 5
	  /* Use whatever language we have been using for this subfile,
	     not the one that was deduced in allocate_symtab from the
	     filename.  We already did our own deducing when we created
	     the subfile, and we may have altered our opinion of what
	     language it is from things we found in the symbols. */
d995 8
d1004 2
a1005 2
	     blockvector, so we need to clear primary for everything but
	     the main file.  */
d1011 1
a1011 1
	  free ((PTR) subfile->name);
d1015 1
a1015 1
	  free ((PTR) subfile->dirname);
d1019 5
a1023 1
	  free ((PTR) subfile->line_vector);
d1027 1
a1027 1
      free ((PTR)subfile);
d1038 1
d1040 1
a1040 1
  return (symtab);
d1043 3
a1045 3

/* Push a context block.  Args are an identifying nesting level (checkable
   when you pop it), and the starting PC address of this context.  */
d1048 1
a1048 3
push_context (desc, valu)
     int desc;
     CORE_ADDR valu;
d1050 1
a1050 1
  register struct context_stack *new;
d1063 1
d1069 4
d1074 8
a1081 1
  return (new);
d1085 1
d1089 1
a1089 2
hashname (name)
     char *name;
d1091 3
a1093 15
  register char *p = name;
  register int total = p[0];
  register int c;

  c = p[1];
  total += c << 2;
  if (c)
    {
      c = p[2];
      total += c << 4;
      if (c)
	{
	  total += p[3] << 6;
	}
    }
d1095 4
a1098 6
  /* Ensure result is positive.  */
  if (total < 0)
    {
      total += (1000 << 6);
    }
  return (total % HASHSIZE);
d1101 27
d1129 3
a1131 3
/* Initialize anything that needs initializing when starting to read
   a fresh piece of a symbol file, e.g. reading in the stuff corresponding
   to a psymtab.  */
d1134 1
a1134 1
buildsym_init ()
d1140 1
d1148 1
a1148 1
buildsym_new_init ()
a1150 7
}

/* Initializer for this module */

void
_initialize_buildsym ()
{
@


1.1
log
@file buildsym.c was initially added on branch CYGNUS.
@
text
@d1 1096
@


1.1.1.1
log
@GDB 6.1 (excluding .info files)
@
text
@a0 1151
/* Support routines for building symbol tables in GDB's internal format.
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* This module provides subroutines used for creating and adding to
   the symbol table.  These routines are called from various symbol-
   file-reading routines.

   Routines to support specific debugging information formats (stabs,
   DWARF, etc) belong somewhere else. */

#include "defs.h"
#include "bfd.h"
#include "gdb_obstack.h"
#include "symtab.h"
#include "symfile.h"
#include "objfiles.h"
#include "gdbtypes.h"
#include "gdb_assert.h"
#include "complaints.h"
#include "gdb_string.h"
#include "expression.h"		/* For "enum exp_opcode" used by... */
#include "language.h"		/* For "local_hex_string" */
#include "bcache.h"
#include "filenames.h"		/* For DOSish file names */
#include "macrotab.h"
#include "demangle.h"		/* Needed by SYMBOL_INIT_DEMANGLED_NAME.  */
#include "block.h"
#include "cp-support.h"
#include "dictionary.h"

/* Ask buildsym.h to define the vars it normally declares `extern'.  */
#define	EXTERN
/**/
#include "buildsym.h"		/* Our own declarations */
#undef	EXTERN

/* For cleanup_undefined_types and finish_global_stabs (somewhat
   questionable--see comment where we call them).  */

#include "stabsread.h"

/* List of free `struct pending' structures for reuse.  */

static struct pending *free_pendings;

/* Non-zero if symtab has line number info.  This prevents an
   otherwise empty symtab from being tossed.  */

static int have_line_numbers;

static int compare_line_numbers (const void *ln1p, const void *ln2p);


/* Initial sizes of data structures.  These are realloc'd larger if
   needed, and realloc'd down to the size actually used, when
   completed.  */

#define	INITIAL_CONTEXT_STACK_SIZE	10
#define	INITIAL_LINE_VECTOR_LENGTH	1000


/* maintain the lists of symbols and blocks */

/* Add a pending list to free_pendings. */
void
add_free_pendings (struct pending *list)
{
  struct pending *link = list;

  if (list)
    {
      while (link->next) link = link->next;
      link->next = free_pendings;
      free_pendings = list;
    }
}
      
/* Add a symbol to one of the lists of symbols.  While we're at it, if
   we're in the C++ case and don't have full namespace debugging info,
   check to see if it references an anonymous namespace; if so, add an
   appropriate using directive.  */

void
add_symbol_to_list (struct symbol *symbol, struct pending **listhead)
{
  struct pending *link;

  /* If this is an alias for another symbol, don't add it.  */
  if (symbol->ginfo.name && symbol->ginfo.name[0] == '#')
    return;

  /* We keep PENDINGSIZE symbols in each link of the list. If we
     don't have a link with room in it, add a new link.  */
  if (*listhead == NULL || (*listhead)->nsyms == PENDINGSIZE)
    {
      if (free_pendings)
	{
	  link = free_pendings;
	  free_pendings = link->next;
	}
      else
	{
	  link = (struct pending *) xmalloc (sizeof (struct pending));
	}

      link->next = *listhead;
      *listhead = link;
      link->nsyms = 0;
    }

  (*listhead)->symbol[(*listhead)->nsyms++] = symbol;

  /* Check to see if we might need to look for a mention of anonymous
     namespaces.  */
  
  if (SYMBOL_LANGUAGE (symbol) == language_cplus)
    cp_scan_for_anonymous_namespaces (symbol);
}

/* Find a symbol named NAME on a LIST.  NAME need not be
   '\0'-terminated; LENGTH is the length of the name.  */

struct symbol *
find_symbol_in_list (struct pending *list, char *name, int length)
{
  int j;
  char *pp;

  while (list != NULL)
    {
      for (j = list->nsyms; --j >= 0;)
	{
	  pp = DEPRECATED_SYMBOL_NAME (list->symbol[j]);
	  if (*pp == *name && strncmp (pp, name, length) == 0 &&
	      pp[length] == '\0')
	    {
	      return (list->symbol[j]);
	    }
	}
      list = list->next;
    }
  return (NULL);
}

/* At end of reading syms, or in case of quit, really free as many
   `struct pending's as we can easily find. */

void
really_free_pendings (void *dummy)
{
  struct pending *next, *next1;

  for (next = free_pendings; next; next = next1)
    {
      next1 = next->next;
      xfree ((void *) next);
    }
  free_pendings = NULL;

  free_pending_blocks ();

  for (next = file_symbols; next != NULL; next = next1)
    {
      next1 = next->next;
      xfree ((void *) next);
    }
  file_symbols = NULL;

  for (next = global_symbols; next != NULL; next = next1)
    {
      next1 = next->next;
      xfree ((void *) next);
    }
  global_symbols = NULL;

  if (pending_macros)
    free_macro_table (pending_macros);
}

/* This function is called to discard any pending blocks. */

void
free_pending_blocks (void)
{
#if 0				/* Now we make the links in the
				   objfile_obstack, so don't free
				   them.  */
  struct pending_block *bnext, *bnext1;

  for (bnext = pending_blocks; bnext; bnext = bnext1)
    {
      bnext1 = bnext->next;
      xfree ((void *) bnext);
    }
#endif
  pending_blocks = NULL;
}

/* Take one of the lists of symbols and make a block from it.  Keep
   the order the symbols have in the list (reversed from the input
   file).  Put the block on the list of pending blocks.  */

void
finish_block (struct symbol *symbol, struct pending **listhead,
	      struct pending_block *old_blocks,
	      CORE_ADDR start, CORE_ADDR end,
	      struct objfile *objfile)
{
  struct pending *next, *next1;
  struct block *block;
  struct pending_block *pblock;
  struct pending_block *opblock;

  block = allocate_block (&objfile->objfile_obstack);

  if (symbol)
    {
      BLOCK_DICT (block) = dict_create_linear (&objfile->objfile_obstack,
					       *listhead);
    }
  else
    {
      BLOCK_DICT (block) = dict_create_hashed (&objfile->objfile_obstack,
					       *listhead);
    }

  BLOCK_START (block) = start;
  BLOCK_END (block) = end;
  /* Superblock filled in when containing block is made */
  BLOCK_SUPERBLOCK (block) = NULL;
  BLOCK_NAMESPACE (block) = NULL;

  BLOCK_GCC_COMPILED (block) = processing_gcc_compilation;

  /* Put the block in as the value of the symbol that names it.  */

  if (symbol)
    {
      struct type *ftype = SYMBOL_TYPE (symbol);
      struct dict_iterator iter;
      SYMBOL_BLOCK_VALUE (symbol) = block;
      BLOCK_FUNCTION (block) = symbol;

      if (TYPE_NFIELDS (ftype) <= 0)
	{
	  /* No parameter type information is recorded with the
	     function's type.  Set that from the type of the
	     parameter symbols. */
	  int nparams = 0, iparams;
	  struct symbol *sym;
	  ALL_BLOCK_SYMBOLS (block, iter, sym)
	    {
	      switch (SYMBOL_CLASS (sym))
		{
		case LOC_ARG:
		case LOC_REF_ARG:
		case LOC_REGPARM:
		case LOC_REGPARM_ADDR:
		case LOC_BASEREG_ARG:
		case LOC_LOCAL_ARG:
		case LOC_COMPUTED_ARG:
		  nparams++;
		  break;
		case LOC_UNDEF:
		case LOC_CONST:
		case LOC_STATIC:
		case LOC_INDIRECT:
		case LOC_REGISTER:
		case LOC_LOCAL:
		case LOC_TYPEDEF:
		case LOC_LABEL:
		case LOC_BLOCK:
		case LOC_CONST_BYTES:
		case LOC_BASEREG:
		case LOC_UNRESOLVED:
		case LOC_OPTIMIZED_OUT:
		case LOC_COMPUTED:
		default:
		  break;
		}
	    }
	  if (nparams > 0)
	    {
	      TYPE_NFIELDS (ftype) = nparams;
	      TYPE_FIELDS (ftype) = (struct field *)
		TYPE_ALLOC (ftype, nparams * sizeof (struct field));

	      iparams = 0;
	      ALL_BLOCK_SYMBOLS (block, iter, sym)
		{
		  if (iparams == nparams)
		    break;

		  switch (SYMBOL_CLASS (sym))
		    {
		    case LOC_ARG:
		    case LOC_REF_ARG:
		    case LOC_REGPARM:
		    case LOC_REGPARM_ADDR:
		    case LOC_BASEREG_ARG:
		    case LOC_LOCAL_ARG:
		    case LOC_COMPUTED_ARG:
		      TYPE_FIELD_TYPE (ftype, iparams) = SYMBOL_TYPE (sym);
		      TYPE_FIELD_ARTIFICIAL (ftype, iparams) = 0;
		      iparams++;
		      break;
		    case LOC_UNDEF:
		    case LOC_CONST:
		    case LOC_STATIC:
		    case LOC_INDIRECT:
		    case LOC_REGISTER:
		    case LOC_LOCAL:
		    case LOC_TYPEDEF:
		    case LOC_LABEL:
		    case LOC_BLOCK:
		    case LOC_CONST_BYTES:
		    case LOC_BASEREG:
		    case LOC_UNRESOLVED:
		    case LOC_OPTIMIZED_OUT:
		    case LOC_COMPUTED:
		    default:
		      break;
		    }
		}
	    }
	}

      /* If we're in the C++ case, set the block's scope.  */
      if (SYMBOL_LANGUAGE (symbol) == language_cplus)
	{
	  cp_set_block_scope (symbol, block, &objfile->objfile_obstack);
	}
    }
  else
    {
      BLOCK_FUNCTION (block) = NULL;
    }

  /* Now "free" the links of the list, and empty the list.  */

  for (next = *listhead; next; next = next1)
    {
      next1 = next->next;
      next->next = free_pendings;
      free_pendings = next;
    }
  *listhead = NULL;

#if 1
  /* Check to be sure that the blocks have an end address that is
     greater than starting address */

  if (BLOCK_END (block) < BLOCK_START (block))
    {
      if (symbol)
	{
	  complaint (&symfile_complaints,
		     "block end address less than block start address in %s (patched it)",
		     SYMBOL_PRINT_NAME (symbol));
	}
      else
	{
	  complaint (&symfile_complaints,
		     "block end address 0x%s less than block start address 0x%s (patched it)",
		     paddr_nz (BLOCK_END (block)), paddr_nz (BLOCK_START (block)));
	}
      /* Better than nothing */
      BLOCK_END (block) = BLOCK_START (block);
    }
#endif

  /* Install this block as the superblock of all blocks made since the
     start of this scope that don't have superblocks yet.  */

  opblock = NULL;
  for (pblock = pending_blocks; 
       pblock && pblock != old_blocks; 
       pblock = pblock->next)
    {
      if (BLOCK_SUPERBLOCK (pblock->block) == NULL)
	{
#if 1
	  /* Check to be sure the blocks are nested as we receive
	     them. If the compiler/assembler/linker work, this just
	     burns a small amount of time.  */
	  if (BLOCK_START (pblock->block) < BLOCK_START (block) ||
	      BLOCK_END (pblock->block) > BLOCK_END (block))
	    {
	      if (symbol)
		{
		  complaint (&symfile_complaints,
			     "inner block not inside outer block in %s",
			     SYMBOL_PRINT_NAME (symbol));
		}
	      else
		{
		  complaint (&symfile_complaints,
			     "inner block (0x%s-0x%s) not inside outer block (0x%s-0x%s)",
			     paddr_nz (BLOCK_START (pblock->block)),
			     paddr_nz (BLOCK_END (pblock->block)),
			     paddr_nz (BLOCK_START (block)),
			     paddr_nz (BLOCK_END (block)));
		}
	      if (BLOCK_START (pblock->block) < BLOCK_START (block))
		BLOCK_START (pblock->block) = BLOCK_START (block);
	      if (BLOCK_END (pblock->block) > BLOCK_END (block))
		BLOCK_END (pblock->block) = BLOCK_END (block);
	    }
#endif
	  BLOCK_SUPERBLOCK (pblock->block) = block;
	}
      opblock = pblock;
    }

  record_pending_block (objfile, block, opblock);
}


/* Record BLOCK on the list of all blocks in the file.  Put it after
   OPBLOCK, or at the beginning if opblock is NULL.  This puts the
   block in the list after all its subblocks.

   Allocate the pending block struct in the objfile_obstack to save
   time.  This wastes a little space.  FIXME: Is it worth it?  */

void
record_pending_block (struct objfile *objfile, struct block *block,
		      struct pending_block *opblock)
{
  struct pending_block *pblock;

  pblock = (struct pending_block *)
    obstack_alloc (&objfile->objfile_obstack, sizeof (struct pending_block));
  pblock->block = block;
  if (opblock)
    {
      pblock->next = opblock->next;
      opblock->next = pblock;
    }
  else
    {
      pblock->next = pending_blocks;
      pending_blocks = pblock;
    }
}

static struct blockvector *
make_blockvector (struct objfile *objfile)
{
  struct pending_block *next;
  struct blockvector *blockvector;
  int i;

  /* Count the length of the list of blocks.  */

  for (next = pending_blocks, i = 0; next; next = next->next, i++)
    {;
    }

  blockvector = (struct blockvector *)
    obstack_alloc (&objfile->objfile_obstack,
		   (sizeof (struct blockvector)
		    + (i - 1) * sizeof (struct block *)));

  /* Copy the blocks into the blockvector. This is done in reverse
     order, which happens to put the blocks into the proper order
     (ascending starting address). finish_block has hair to insert
     each block into the list after its subblocks in order to make
     sure this is true.  */

  BLOCKVECTOR_NBLOCKS (blockvector) = i;
  for (next = pending_blocks; next; next = next->next)
    {
      BLOCKVECTOR_BLOCK (blockvector, --i) = next->block;
    }

#if 0				/* Now we make the links in the
				   obstack, so don't free them.  */
  /* Now free the links of the list, and empty the list.  */

  for (next = pending_blocks; next; next = next1)
    {
      next1 = next->next;
      xfree (next);
    }
#endif
  pending_blocks = NULL;

#if 1				/* FIXME, shut this off after a while
				   to speed up symbol reading.  */
  /* Some compilers output blocks in the wrong order, but we depend on
     their being in the right order so we can binary search. Check the
     order and moan about it.  FIXME.  */
  if (BLOCKVECTOR_NBLOCKS (blockvector) > 1)
    {
      for (i = 1; i < BLOCKVECTOR_NBLOCKS (blockvector); i++)
	{
	  if (BLOCK_START (BLOCKVECTOR_BLOCK (blockvector, i - 1))
	      > BLOCK_START (BLOCKVECTOR_BLOCK (blockvector, i)))
	    {
	      CORE_ADDR start
		= BLOCK_START (BLOCKVECTOR_BLOCK (blockvector, i));

	      complaint (&symfile_complaints, "block at %s out of order",
			 local_hex_string ((LONGEST) start));
	    }
	}
    }
#endif

  return (blockvector);
}

/* Start recording information about source code that came from an
   included (or otherwise merged-in) source file with a different
   name.  NAME is the name of the file (cannot be NULL), DIRNAME is
   the directory in which it resides (or NULL if not known).  */

void
start_subfile (char *name, char *dirname)
{
  struct subfile *subfile;

  /* See if this subfile is already known as a subfile of the current
     main source file.  */

  for (subfile = subfiles; subfile; subfile = subfile->next)
    {
      if (FILENAME_CMP (subfile->name, name) == 0)
	{
	  current_subfile = subfile;
	  return;
	}
    }

  /* This subfile is not known.  Add an entry for it. Make an entry
     for this subfile in the list of all subfiles of the current main
     source file.  */

  subfile = (struct subfile *) xmalloc (sizeof (struct subfile));
  memset ((char *) subfile, 0, sizeof (struct subfile));
  subfile->next = subfiles;
  subfiles = subfile;
  current_subfile = subfile;

  /* Save its name and compilation directory name */
  subfile->name = (name == NULL) ? NULL : savestring (name, strlen (name));
  subfile->dirname =
    (dirname == NULL) ? NULL : savestring (dirname, strlen (dirname));

  /* Initialize line-number recording for this subfile.  */
  subfile->line_vector = NULL;

  /* Default the source language to whatever can be deduced from the
     filename.  If nothing can be deduced (such as for a C/C++ include
     file with a ".h" extension), then inherit whatever language the
     previous subfile had.  This kludgery is necessary because there
     is no standard way in some object formats to record the source
     language.  Also, when symtabs are allocated we try to deduce a
     language then as well, but it is too late for us to use that
     information while reading symbols, since symtabs aren't allocated
     until after all the symbols have been processed for a given
     source file. */

  subfile->language = deduce_language_from_filename (subfile->name);
  if (subfile->language == language_unknown &&
      subfile->next != NULL)
    {
      subfile->language = subfile->next->language;
    }

  /* Initialize the debug format string to NULL.  We may supply it
     later via a call to record_debugformat. */
  subfile->debugformat = NULL;

  /* If the filename of this subfile ends in .C, then change the
     language of any pending subfiles from C to C++.  We also accept
     any other C++ suffixes accepted by deduce_language_from_filename.  */
  /* Likewise for f2c.  */

  if (subfile->name)
    {
      struct subfile *s;
      enum language sublang = deduce_language_from_filename (subfile->name);

      if (sublang == language_cplus || sublang == language_fortran)
	for (s = subfiles; s != NULL; s = s->next)
	  if (s->language == language_c)
	    s->language = sublang;
    }

  /* And patch up this file if necessary.  */
  if (subfile->language == language_c
      && subfile->next != NULL
      && (subfile->next->language == language_cplus
	  || subfile->next->language == language_fortran))
    {
      subfile->language = subfile->next->language;
    }
}

/* For stabs readers, the first N_SO symbol is assumed to be the
   source file name, and the subfile struct is initialized using that
   assumption.  If another N_SO symbol is later seen, immediately
   following the first one, then the first one is assumed to be the
   directory name and the second one is really the source file name.

   So we have to patch up the subfile struct by moving the old name
   value to dirname and remembering the new name.  Some sanity
   checking is performed to ensure that the state of the subfile
   struct is reasonable and that the old name we are assuming to be a
   directory name actually is (by checking for a trailing '/'). */

void
patch_subfile_names (struct subfile *subfile, char *name)
{
  if (subfile != NULL && subfile->dirname == NULL && subfile->name != NULL
      && subfile->name[strlen (subfile->name) - 1] == '/')
    {
      subfile->dirname = subfile->name;
      subfile->name = savestring (name, strlen (name));
      last_source_file = name;

      /* Default the source language to whatever can be deduced from
         the filename.  If nothing can be deduced (such as for a C/C++
         include file with a ".h" extension), then inherit whatever
         language the previous subfile had.  This kludgery is
         necessary because there is no standard way in some object
         formats to record the source language.  Also, when symtabs
         are allocated we try to deduce a language then as well, but
         it is too late for us to use that information while reading
         symbols, since symtabs aren't allocated until after all the
         symbols have been processed for a given source file. */

      subfile->language = deduce_language_from_filename (subfile->name);
      if (subfile->language == language_unknown &&
	  subfile->next != NULL)
	{
	  subfile->language = subfile->next->language;
	}
    }
}

/* Handle the N_BINCL and N_EINCL symbol types that act like N_SOL for
   switching source files (different subfiles, as we call them) within
   one object file, but using a stack rather than in an arbitrary
   order.  */

void
push_subfile (void)
{
  struct subfile_stack *tem
  = (struct subfile_stack *) xmalloc (sizeof (struct subfile_stack));

  tem->next = subfile_stack;
  subfile_stack = tem;
  if (current_subfile == NULL || current_subfile->name == NULL)
    {
      internal_error (__FILE__, __LINE__, "failed internal consistency check");
    }
  tem->name = current_subfile->name;
}

char *
pop_subfile (void)
{
  char *name;
  struct subfile_stack *link = subfile_stack;

  if (link == NULL)
    {
      internal_error (__FILE__, __LINE__, "failed internal consistency check");
    }
  name = link->name;
  subfile_stack = link->next;
  xfree ((void *) link);
  return (name);
}

/* Add a linetable entry for line number LINE and address PC to the
   line vector for SUBFILE.  */

void
record_line (struct subfile *subfile, int line, CORE_ADDR pc)
{
  struct linetable_entry *e;
  /* Ignore the dummy line number in libg.o */

  if (line == 0xffff)
    {
      return;
    }

  /* Make sure line vector exists and is big enough.  */
  if (!subfile->line_vector)
    {
      subfile->line_vector_length = INITIAL_LINE_VECTOR_LENGTH;
      subfile->line_vector = (struct linetable *)
	xmalloc (sizeof (struct linetable)
	   + subfile->line_vector_length * sizeof (struct linetable_entry));
      subfile->line_vector->nitems = 0;
      have_line_numbers = 1;
    }

  if (subfile->line_vector->nitems + 1 >= subfile->line_vector_length)
    {
      subfile->line_vector_length *= 2;
      subfile->line_vector = (struct linetable *)
	xrealloc ((char *) subfile->line_vector,
		  (sizeof (struct linetable)
		   + (subfile->line_vector_length
		      * sizeof (struct linetable_entry))));
    }

  e = subfile->line_vector->item + subfile->line_vector->nitems++;
  e->line = line;
  e->pc = ADDR_BITS_REMOVE(pc);
}

/* Needed in order to sort line tables from IBM xcoff files.  Sigh!  */

static int
compare_line_numbers (const void *ln1p, const void *ln2p)
{
  struct linetable_entry *ln1 = (struct linetable_entry *) ln1p;
  struct linetable_entry *ln2 = (struct linetable_entry *) ln2p;

  /* Note: this code does not assume that CORE_ADDRs can fit in ints.
     Please keep it that way.  */
  if (ln1->pc < ln2->pc)
    return -1;

  if (ln1->pc > ln2->pc)
    return 1;

  /* If pc equal, sort by line.  I'm not sure whether this is optimum
     behavior (see comment at struct linetable in symtab.h).  */
  return ln1->line - ln2->line;
}

/* Start a new symtab for a new source file.  Called, for example,
   when a stabs symbol of type N_SO is seen, or when a DWARF
   TAG_compile_unit DIE is seen.  It indicates the start of data for
   one original source file.  */

void
start_symtab (char *name, char *dirname, CORE_ADDR start_addr)
{

  last_source_file = name;
  last_source_start_addr = start_addr;
  file_symbols = NULL;
  global_symbols = NULL;
  within_function = 0;
  have_line_numbers = 0;

  /* Context stack is initially empty.  Allocate first one with room
     for 10 levels; reuse it forever afterward.  */
  if (context_stack == NULL)
    {
      context_stack_size = INITIAL_CONTEXT_STACK_SIZE;
      context_stack = (struct context_stack *)
	xmalloc (context_stack_size * sizeof (struct context_stack));
    }
  context_stack_depth = 0;

  /* Set up support for C++ namespace support, in case we need it.  */

  cp_initialize_namespace ();

  /* Initialize the list of sub source files with one entry for this
     file (the top-level source file).  */

  subfiles = NULL;
  current_subfile = NULL;
  start_subfile (name, dirname);
}

/* Finish the symbol definitions for one main source file, close off
   all the lexical contexts for that file (creating struct block's for
   them), then make the struct symtab for that file and put it in the
   list of all such.

   END_ADDR is the address of the end of the file's text.  SECTION is
   the section number (in objfile->section_offsets) of the blockvector
   and linetable.

   Note that it is possible for end_symtab() to return NULL.  In
   particular, for the DWARF case at least, it will return NULL when
   it finds a compilation unit that has exactly one DIE, a
   TAG_compile_unit DIE.  This can happen when we link in an object
   file that was compiled from an empty source file.  Returning NULL
   is probably not the correct thing to do, because then gdb will
   never know about this empty file (FIXME). */

struct symtab *
end_symtab (CORE_ADDR end_addr, struct objfile *objfile, int section)
{
  struct symtab *symtab = NULL;
  struct blockvector *blockvector;
  struct subfile *subfile;
  struct context_stack *cstk;
  struct subfile *nextsub;

  /* Finish the lexical context of the last function in the file; pop
     the context stack.  */

  if (context_stack_depth > 0)
    {
      cstk = pop_context ();
      /* Make a block for the local symbols within.  */
      finish_block (cstk->name, &local_symbols, cstk->old_blocks,
		    cstk->start_addr, end_addr, objfile);

      if (context_stack_depth > 0)
	{
	  /* This is said to happen with SCO.  The old coffread.c
	     code simply emptied the context stack, so we do the
	     same.  FIXME: Find out why it is happening.  This is not
	     believed to happen in most cases (even for coffread.c);
	     it used to be an abort().  */
	  complaint (&symfile_complaints,
	             "Context stack not empty in end_symtab");
	  context_stack_depth = 0;
	}
    }

  /* Reordered executables may have out of order pending blocks; if
     OBJF_REORDERED is true, then sort the pending blocks.  */
  if ((objfile->flags & OBJF_REORDERED) && pending_blocks)
    {
      /* FIXME!  Remove this horrid bubble sort and use merge sort!!! */
      int swapped;
      do
	{
	  struct pending_block *pb, *pbnext;

	  pb = pending_blocks;
	  pbnext = pb->next;
	  swapped = 0;

	  while (pbnext)
	    {
	      /* swap blocks if unordered! */

	      if (BLOCK_START (pb->block) < BLOCK_START (pbnext->block))
		{
		  struct block *tmp = pb->block;
		  pb->block = pbnext->block;
		  pbnext->block = tmp;
		  swapped = 1;
		}
	      pb = pbnext;
	      pbnext = pbnext->next;
	    }
	}
      while (swapped);
    }

  /* Cleanup any undefined types that have been left hanging around
     (this needs to be done before the finish_blocks so that
     file_symbols is still good).

     Both cleanup_undefined_types and finish_global_stabs are stabs
     specific, but harmless for other symbol readers, since on gdb
     startup or when finished reading stabs, the state is set so these
     are no-ops.  FIXME: Is this handled right in case of QUIT?  Can
     we make this cleaner?  */

  cleanup_undefined_types ();
  finish_global_stabs (objfile);

  if (pending_blocks == NULL
      && file_symbols == NULL
      && global_symbols == NULL
      && have_line_numbers == 0
      && pending_macros == NULL)
    {
      /* Ignore symtabs that have no functions with real debugging
         info.  */
      blockvector = NULL;
    }
  else
    {
      /* Define the STATIC_BLOCK & GLOBAL_BLOCK, and build the
         blockvector.  */
      finish_block (0, &file_symbols, 0, last_source_start_addr, end_addr,
		    objfile);
      finish_block (0, &global_symbols, 0, last_source_start_addr, end_addr,
		    objfile);
      blockvector = make_blockvector (objfile);
      cp_finalize_namespace (BLOCKVECTOR_BLOCK (blockvector, STATIC_BLOCK),
			     &objfile->objfile_obstack);
    }

#ifndef PROCESS_LINENUMBER_HOOK
#define PROCESS_LINENUMBER_HOOK()
#endif
  PROCESS_LINENUMBER_HOOK ();	/* Needed for xcoff. */

  /* Now create the symtab objects proper, one for each subfile.  */
  /* (The main file is the last one on the chain.)  */

  for (subfile = subfiles; subfile; subfile = nextsub)
    {
      int linetablesize = 0;
      symtab = NULL;

      /* If we have blocks of symbols, make a symtab. Otherwise, just
         ignore this file and any line number info in it.  */
      if (blockvector)
	{
	  if (subfile->line_vector)
	    {
	      linetablesize = sizeof (struct linetable) +
	        subfile->line_vector->nitems * sizeof (struct linetable_entry);
#if 0
	      /* I think this is artifact from before it went on the
	         obstack. I doubt we'll need the memory between now
	         and when we free it later in this function.  */
	      /* First, shrink the linetable to make more memory.  */
	      subfile->line_vector = (struct linetable *)
		xrealloc ((char *) subfile->line_vector, linetablesize);
#endif

	      /* Like the pending blocks, the line table may be
	         scrambled in reordered executables.  Sort it if
	         OBJF_REORDERED is true.  */
	      if (objfile->flags & OBJF_REORDERED)
		qsort (subfile->line_vector->item,
		       subfile->line_vector->nitems,
		     sizeof (struct linetable_entry), compare_line_numbers);
	    }

	  /* Now, allocate a symbol table.  */
	  symtab = allocate_symtab (subfile->name, objfile);

	  /* Fill in its components.  */
	  symtab->blockvector = blockvector;
          symtab->macro_table = pending_macros;
	  if (subfile->line_vector)
	    {
	      /* Reallocate the line table on the symbol obstack */
	      symtab->linetable = (struct linetable *)
		obstack_alloc (&objfile->objfile_obstack, linetablesize);
	      memcpy (symtab->linetable, subfile->line_vector, linetablesize);
	    }
	  else
	    {
	      symtab->linetable = NULL;
	    }
	  symtab->block_line_section = section;
	  if (subfile->dirname)
	    {
	      /* Reallocate the dirname on the symbol obstack */
	      symtab->dirname = (char *)
		obstack_alloc (&objfile->objfile_obstack,
			       strlen (subfile->dirname) + 1);
	      strcpy (symtab->dirname, subfile->dirname);
	    }
	  else
	    {
	      symtab->dirname = NULL;
	    }
	  symtab->free_code = free_linetable;
	  symtab->free_func = NULL;

	  /* Use whatever language we have been using for this
	     subfile, not the one that was deduced in allocate_symtab
	     from the filename.  We already did our own deducing when
	     we created the subfile, and we may have altered our
	     opinion of what language it is from things we found in
	     the symbols. */
	  symtab->language = subfile->language;

	  /* Save the debug format string (if any) in the symtab */
	  if (subfile->debugformat != NULL)
	    {
	      symtab->debugformat = obsavestring (subfile->debugformat,
					      strlen (subfile->debugformat),
						  &objfile->objfile_obstack);
	    }

	  /* All symtabs for the main file and the subfiles share a
	     blockvector, so we need to clear primary for everything
	     but the main file.  */

	  symtab->primary = 0;
	}
      if (subfile->name != NULL)
	{
	  xfree ((void *) subfile->name);
	}
      if (subfile->dirname != NULL)
	{
	  xfree ((void *) subfile->dirname);
	}
      if (subfile->line_vector != NULL)
	{
	  xfree ((void *) subfile->line_vector);
	}
      if (subfile->debugformat != NULL)
	{
	  xfree ((void *) subfile->debugformat);
	}

      nextsub = subfile->next;
      xfree ((void *) subfile);
    }

  /* Set this for the main source file.  */
  if (symtab)
    {
      symtab->primary = 1;
    }

  last_source_file = NULL;
  current_subfile = NULL;
  pending_macros = NULL;

  return symtab;
}

/* Push a context block.  Args are an identifying nesting level
   (checkable when you pop it), and the starting PC address of this
   context.  */

struct context_stack *
push_context (int desc, CORE_ADDR valu)
{
  struct context_stack *new;

  if (context_stack_depth == context_stack_size)
    {
      context_stack_size *= 2;
      context_stack = (struct context_stack *)
	xrealloc ((char *) context_stack,
		  (context_stack_size * sizeof (struct context_stack)));
    }

  new = &context_stack[context_stack_depth++];
  new->depth = desc;
  new->locals = local_symbols;
  new->params = param_symbols;
  new->old_blocks = pending_blocks;
  new->start_addr = valu;
  new->name = NULL;

  local_symbols = NULL;
  param_symbols = NULL;

  return new;
}

/* Pop a context block.  Returns the address of the context block just
   popped. */

struct context_stack *
pop_context (void)
{
  gdb_assert (context_stack_depth > 0);
  return (&context_stack[--context_stack_depth]);
}



/* Compute a small integer hash code for the given name. */

int
hashname (char *name)
{
    return (hash(name,strlen(name)) % HASHSIZE);
}


void
record_debugformat (char *format)
{
  current_subfile->debugformat = savestring (format, strlen (format));
}

/* Merge the first symbol list SRCLIST into the second symbol list
   TARGETLIST by repeated calls to add_symbol_to_list().  This
   procedure "frees" each link of SRCLIST by adding it to the
   free_pendings list.  Caller must set SRCLIST to a null list after
   calling this function.

   Void return. */

void
merge_symbol_lists (struct pending **srclist, struct pending **targetlist)
{
  int i;

  if (!srclist || !*srclist)
    return;

  /* Merge in elements from current link.  */
  for (i = 0; i < (*srclist)->nsyms; i++)
    add_symbol_to_list ((*srclist)->symbol[i], targetlist);

  /* Recurse on next.  */
  merge_symbol_lists (&(*srclist)->next, targetlist);

  /* "Free" the current link.  */
  (*srclist)->next = free_pendings;
  free_pendings = (*srclist);
}

/* Initialize anything that needs initializing when starting to read a
   fresh piece of a symbol file, e.g. reading in the stuff
   corresponding to a psymtab.  */

void
buildsym_init (void)
{
  free_pendings = NULL;
  file_symbols = NULL;
  global_symbols = NULL;
  pending_blocks = NULL;
  pending_macros = NULL;
}

/* Initialize anything that needs initializing when a completely new
   symbol file is specified (not just adding some symbols from another
   file, e.g. a shared library).  */

void
buildsym_new_init (void)
{
  buildsym_init ();
}
@


1.1.1.2
log
@GDB 6.3 (excluding .info files)
@
text
@d41 1
d524 1
a524 1
			 hex_string ((LONGEST) start));
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 1096
/* Support routines for building symbol tables in GDB's internal format.
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1995, 1996
             Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* This module provides subroutines used for creating and adding to
   the symbol table.  These routines are called from various symbol-
   file-reading routines.

   Routines to support specific debugging information formats (stabs,
   DWARF, etc) belong somewhere else. */

#include "defs.h"
#include "bfd.h"
#include "obstack.h"
#include "symtab.h"
#include "symfile.h"		/* Needed for "struct complaint" */
#include "objfiles.h"
#include "gdbtypes.h"
#include "complaints.h"
#include "gdb_string.h"

/* Ask buildsym.h to define the vars it normally declares `extern'.  */
#define	EXTERN	/**/
#include "buildsym.h"		/* Our own declarations */
#undef	EXTERN

/* For cleanup_undefined_types and finish_global_stabs (somewhat
   questionable--see comment where we call them).  */
#include "stabsread.h"

/* Pointer to the head of a linked list of symbol blocks which have
   already been finalized (lexical contexts already closed) and which are
   just waiting to be built into a blockvector when finalizing the
   associated symtab. */

static struct pending_block *pending_blocks = NULL;

/* List of free `struct pending' structures for reuse.  */

static struct pending *free_pendings;


static int
compare_line_numbers PARAMS ((const void *, const void *));


/* Initial sizes of data structures.  These are realloc'd larger if needed,
   and realloc'd down to the size actually used, when completed.  */

#define	INITIAL_CONTEXT_STACK_SIZE	10
#define	INITIAL_LINE_VECTOR_LENGTH	1000


/* Complaints about the symbols we have encountered.  */

struct complaint block_end_complaint =
  {"block end address less than block start address in %s (patched it)", 0, 0};

struct complaint anon_block_end_complaint =
  {"block end address 0x%lx less than block start address 0x%lx (patched it)", 0, 0};

struct complaint innerblock_complaint =
  {"inner block not inside outer block in %s", 0, 0};

struct complaint innerblock_anon_complaint =
  {"inner block (0x%lx-0x%lx) not inside outer block (0x%lx-0x%lx)", 0, 0};

struct complaint blockvector_complaint = 
  {"block at 0x%lx out of order", 0, 0};


/* maintain the lists of symbols and blocks */

/* Add a symbol to one of the lists of symbols.  */

void
add_symbol_to_list (symbol, listhead)
     struct symbol *symbol;
     struct pending **listhead;
{
  register struct pending *link;
      
  /* We keep PENDINGSIZE symbols in each link of the list.
     If we don't have a link with room in it, add a new link.  */
  if (*listhead == NULL || (*listhead)->nsyms == PENDINGSIZE)
    {
      if (free_pendings)
	{
	  link = free_pendings;
	  free_pendings = link->next;
	}
      else
	{
	  link = (struct pending *) xmalloc (sizeof (struct pending));
	}

      link->next = *listhead;
      *listhead = link;
      link->nsyms = 0;
    }

  (*listhead)->symbol[(*listhead)->nsyms++] = symbol;
}

/* Find a symbol named NAME on a LIST.  NAME need not be '\0'-terminated;
   LENGTH is the length of the name.  */

struct symbol *
find_symbol_in_list (list, name, length)
     struct pending *list;
     char *name;
     int length;
{
  int j;
  char *pp;

  while (list != NULL)
    {
      for (j = list->nsyms; --j >= 0; )
	{
	  pp = SYMBOL_NAME (list->symbol[j]);
	  if (*pp == *name && strncmp (pp, name, length) == 0 &&
	      pp[length] == '\0')
	    {
	      return (list->symbol[j]);
	    }
	}
      list = list->next;
    }
  return (NULL);
}

/* At end of reading syms, or in case of quit,
   really free as many `struct pending's as we can easily find. */

/* ARGSUSED */
void
really_free_pendings (foo)
     int foo;
{
  struct pending *next, *next1;

  for (next = free_pendings; next; next = next1)
    {
      next1 = next->next;
      free ((PTR)next);
    }
  free_pendings = NULL;

  free_pending_blocks ();

  for (next = file_symbols; next != NULL; next = next1)
    {
      next1 = next->next;
      free ((PTR)next);
    }
  file_symbols = NULL;

  for (next = global_symbols; next != NULL; next = next1)
    {
      next1 = next->next;
      free ((PTR)next);
    }
  global_symbols = NULL;
}

/* This function is called to discard any pending blocks. */

void
free_pending_blocks ()
{
#if 0 /* Now we make the links in the symbol_obstack, so don't free them.  */
  struct pending_block *bnext, *bnext1;

  for (bnext = pending_blocks; bnext; bnext = bnext1)
    {
      bnext1 = bnext->next;
      free ((PTR)bnext);
    }
#endif
  pending_blocks = NULL;
}

/* Take one of the lists of symbols and make a block from it.
   Keep the order the symbols have in the list (reversed from the input file).
   Put the block on the list of pending blocks.  */

void
finish_block (symbol, listhead, old_blocks, start, end, objfile)
     struct symbol *symbol;
     struct pending **listhead;
     struct pending_block *old_blocks;
     CORE_ADDR start, end;
     struct objfile *objfile;
{
  register struct pending *next, *next1;
  register struct block *block;
  register struct pending_block *pblock;
  struct pending_block *opblock;
  register int i;
  register int j;

  /* Count the length of the list of symbols.  */

  for (next = *listhead, i = 0;
       next;
       i += next->nsyms, next = next->next)
    {
      /*EMPTY*/;
    }

  block = (struct block *) obstack_alloc (&objfile -> symbol_obstack,
	  (sizeof (struct block) + ((i - 1) * sizeof (struct symbol *))));

  /* Copy the symbols into the block.  */

  BLOCK_NSYMS (block) = i;
  for (next = *listhead; next; next = next->next)
    {
      for (j = next->nsyms - 1; j >= 0; j--)
	{
	  BLOCK_SYM (block, --i) = next->symbol[j];
	}
    }

  BLOCK_START (block) = start;
  BLOCK_END (block) = end;
 /* Superblock filled in when containing block is made */
  BLOCK_SUPERBLOCK (block) = NULL;
  BLOCK_GCC_COMPILED (block) = processing_gcc_compilation;

  /* Put the block in as the value of the symbol that names it.  */

  if (symbol)
    {
      struct type *ftype = SYMBOL_TYPE (symbol);
      SYMBOL_BLOCK_VALUE (symbol) = block;
      BLOCK_FUNCTION (block) = symbol;

      if (TYPE_NFIELDS (ftype) <= 0)
	{
	  /* No parameter type information is recorded with the function's
	     type.  Set that from the type of the parameter symbols. */
	  int nparams = 0, iparams;
	  struct symbol *sym;
	  for (i = 0; i < BLOCK_NSYMS (block); i++)
	    {
	      sym = BLOCK_SYM (block, i);
	      switch (SYMBOL_CLASS (sym))
		{
		case LOC_ARG:
		case LOC_REF_ARG:
		case LOC_REGPARM:
		case LOC_REGPARM_ADDR:
		case LOC_BASEREG_ARG:
		case LOC_LOCAL_ARG:
		  nparams++;
		  break;
		case LOC_UNDEF:
		case LOC_CONST:
		case LOC_STATIC:
		case LOC_REGISTER:
		case LOC_LOCAL:
		case LOC_TYPEDEF:
		case LOC_LABEL:
		case LOC_BLOCK:
		case LOC_CONST_BYTES:
		case LOC_BASEREG:
		case LOC_UNRESOLVED:
		case LOC_OPTIMIZED_OUT:
		default:
		  break;
		}
	    }
	  if (nparams > 0)
	    {
	      TYPE_NFIELDS (ftype) = nparams;
	      TYPE_FIELDS (ftype) = (struct field *)
		TYPE_ALLOC (ftype, nparams * sizeof (struct field));
						
	      for (i = iparams = 0; iparams < nparams; i++)
		{
		  sym = BLOCK_SYM (block, i);
		  switch (SYMBOL_CLASS (sym))
		    {
		    case LOC_ARG:
		    case LOC_REF_ARG:
		    case LOC_REGPARM:
		    case LOC_REGPARM_ADDR:
		    case LOC_BASEREG_ARG:
		    case LOC_LOCAL_ARG:
		      TYPE_FIELD_TYPE (ftype, iparams) = SYMBOL_TYPE (sym);
		      iparams++;
		      break;
		    case LOC_UNDEF:
		    case LOC_CONST:
		    case LOC_STATIC:
		    case LOC_REGISTER:
		    case LOC_LOCAL:
		    case LOC_TYPEDEF:
		    case LOC_LABEL:
		    case LOC_BLOCK:
		    case LOC_CONST_BYTES:
		    case LOC_BASEREG:
		    case LOC_UNRESOLVED:
		    case LOC_OPTIMIZED_OUT:
		    default:
		      break;
		    }
		}
	    }
	}
    }
  else
    {
      BLOCK_FUNCTION (block) = NULL;
    }

  /* Now "free" the links of the list, and empty the list.  */

  for (next = *listhead; next; next = next1)
    {
      next1 = next->next;
      next->next = free_pendings;
      free_pendings = next;
    }
  *listhead = NULL;

#if 1
  /* Check to be sure that the blocks have an end address that is
     greater than starting address */

  if (BLOCK_END (block) < BLOCK_START (block))
    {
      if (symbol)
	{
	  complain (&block_end_complaint, SYMBOL_SOURCE_NAME (symbol));
	}
      else
	{
	  complain (&anon_block_end_complaint, BLOCK_END (block), BLOCK_START (block));
	}
      /* Better than nothing */
      BLOCK_END (block) = BLOCK_START (block);
    }
#endif

  /* Install this block as the superblock
     of all blocks made since the start of this scope
     that don't have superblocks yet.  */

  opblock = NULL;
  for (pblock = pending_blocks; pblock != old_blocks; pblock = pblock->next)
    {
      if (BLOCK_SUPERBLOCK (pblock->block) == NULL)
	{
#if 1
	  /* Check to be sure the blocks are nested as we receive them. 
	     If the compiler/assembler/linker work, this just burns a small
	     amount of time.  */
	  if (BLOCK_START (pblock->block) < BLOCK_START (block) ||
	      BLOCK_END   (pblock->block) > BLOCK_END   (block))
	    {
	      if (symbol)
		{
		  complain (&innerblock_complaint,
			    SYMBOL_SOURCE_NAME (symbol));
		}
	      else
		{
		  complain (&innerblock_anon_complaint, BLOCK_START (pblock->block),
			    BLOCK_END (pblock->block), BLOCK_START (block),
			    BLOCK_END (block));
		}
	      BLOCK_START (pblock->block) = BLOCK_START (block);
	      BLOCK_END   (pblock->block) = BLOCK_END   (block);
	    }
#endif
	  BLOCK_SUPERBLOCK (pblock->block) = block;
	}
      opblock = pblock;
    }

  record_pending_block (objfile, block, opblock);
}

/* Record BLOCK on the list of all blocks in the file.  Put it after
   OPBLOCK, or at the beginning if opblock is NULL.  This puts the block
   in the list after all its subblocks.

   Allocate the pending block struct in the symbol_obstack to save
   time.  This wastes a little space.  FIXME: Is it worth it?  */

void
record_pending_block (objfile, block, opblock)
     struct objfile* objfile;
     struct block *block;
     struct pending_block *opblock;
{
  register struct pending_block *pblock;

  pblock = (struct pending_block *)
    obstack_alloc (&objfile -> symbol_obstack, sizeof (struct pending_block));
  pblock -> block = block;
  if (opblock)
    {
      pblock -> next = opblock -> next;
      opblock -> next = pblock;
    }
  else
    {
      pblock -> next = pending_blocks;
      pending_blocks = pblock;
    }
}

/* Note that this is only used in this file and in dstread.c, which should be
   fixed to not need direct access to this function.  When that is done, it can
   be made static again. */

struct blockvector *
make_blockvector (objfile)
     struct objfile *objfile;
{
  register struct pending_block *next;
  register struct blockvector *blockvector;
  register int i;

  /* Count the length of the list of blocks.  */

  for (next = pending_blocks, i = 0; next; next = next->next, i++) {;}

  blockvector = (struct blockvector *)
    obstack_alloc (&objfile -> symbol_obstack,
		   (sizeof (struct blockvector)
		    + (i - 1) * sizeof (struct block *)));

  /* Copy the blocks into the blockvector.
     This is done in reverse order, which happens to put
     the blocks into the proper order (ascending starting address).
     finish_block has hair to insert each block into the list
     after its subblocks in order to make sure this is true.  */

  BLOCKVECTOR_NBLOCKS (blockvector) = i;
  for (next = pending_blocks; next; next = next->next)
    {
      BLOCKVECTOR_BLOCK (blockvector, --i) = next->block;
    }

#if 0 /* Now we make the links in the obstack, so don't free them.  */
  /* Now free the links of the list, and empty the list.  */

  for (next = pending_blocks; next; next = next1)
    {
      next1 = next->next;
      free (next);
    }
#endif
  pending_blocks = NULL;

#if 1  /* FIXME, shut this off after a while to speed up symbol reading.  */
  /* Some compilers output blocks in the wrong order, but we depend
     on their being in the right order so we can binary search. 
     Check the order and moan about it.  FIXME.  */
  if (BLOCKVECTOR_NBLOCKS (blockvector) > 1)
    {
      for (i = 1; i < BLOCKVECTOR_NBLOCKS (blockvector); i++)
	{
	  if (BLOCK_START(BLOCKVECTOR_BLOCK (blockvector, i-1))
	      > BLOCK_START(BLOCKVECTOR_BLOCK (blockvector, i)))
	    {

	      /* FIXME-32x64: loses if CORE_ADDR doesn't fit in a
		 long.  Possible solutions include a version of
		 complain which takes a callback, a
		 sprintf_address_numeric to match
		 print_address_numeric, or a way to set up a GDB_FILE
		 * which causes sprintf rather than fprintf to be
		 called.  */

	      complain (&blockvector_complaint, 
			(unsigned long) BLOCK_START(BLOCKVECTOR_BLOCK (blockvector, i)));
	    }
	}
    }
#endif

  return (blockvector);
}


/* Start recording information about source code that came from an included
   (or otherwise merged-in) source file with a different name.  NAME is
   the name of the file (cannot be NULL), DIRNAME is the directory in which
   it resides (or NULL if not known).  */

void
start_subfile (name, dirname)
     char *name;
     char *dirname;
{
  register struct subfile *subfile;

  /* See if this subfile is already known as a subfile of the
     current main source file.  */

  for (subfile = subfiles; subfile; subfile = subfile->next)
    {
      if (STREQ (subfile->name, name))
	{
	  current_subfile = subfile;
	  return;
	}
    }

  /* This subfile is not known.  Add an entry for it.
     Make an entry for this subfile in the list of all subfiles
     of the current main source file.  */

  subfile = (struct subfile *) xmalloc (sizeof (struct subfile));
  subfile->next = subfiles;
  subfiles = subfile;
  current_subfile = subfile;

  /* Save its name and compilation directory name */
  subfile->name = (name == NULL) ? NULL : savestring (name, strlen (name));
  subfile->dirname =
    (dirname == NULL) ? NULL : savestring (dirname, strlen (dirname));
  
  /* Initialize line-number recording for this subfile.  */
  subfile->line_vector = NULL;

  /* Default the source language to whatever can be deduced from
     the filename.  If nothing can be deduced (such as for a C/C++
     include file with a ".h" extension), then inherit whatever
     language the previous subfile had.  This kludgery is necessary
     because there is no standard way in some object formats to
     record the source language.  Also, when symtabs are allocated
     we try to deduce a language then as well, but it is too late
     for us to use that information while reading symbols, since
     symtabs aren't allocated until after all the symbols have
     been processed for a given source file. */

  subfile->language = deduce_language_from_filename (subfile->name);
  if (subfile->language == language_unknown &&
      subfile->next != NULL)
    {
      subfile->language = subfile->next->language;
    }

  /* cfront output is a C program, so in most ways it looks like a C
     program.  But to demangle we need to set the language to C++.  We
     can distinguish cfront code by the fact that it has #line
     directives which specify a file name ending in .C.

     So if the filename of this subfile ends in .C, then change the language
     of any pending subfiles from C to C++.  We also accept any other C++
     suffixes accepted by deduce_language_from_filename (in particular,
     some people use .cxx with cfront).  */
  /* Likewise for f2c.  */

  if (subfile->name)
    {
      struct subfile *s;
      enum language sublang = deduce_language_from_filename (subfile->name);

      if (sublang == language_cplus || sublang == language_fortran)
	for (s = subfiles; s != NULL; s = s->next)
	  if (s->language == language_c)
	    s->language = sublang;
    }

  /* And patch up this file if necessary.  */
  if (subfile->language == language_c
      && subfile->next != NULL
      && (subfile->next->language == language_cplus
	  || subfile->next->language == language_fortran))
    {
      subfile->language = subfile->next->language;
    }
}

/* For stabs readers, the first N_SO symbol is assumed to be the source
   file name, and the subfile struct is initialized using that assumption.
   If another N_SO symbol is later seen, immediately following the first
   one, then the first one is assumed to be the directory name and the
   second one is really the source file name.

   So we have to patch up the subfile struct by moving the old name value to
   dirname and remembering the new name.  Some sanity checking is performed
   to ensure that the state of the subfile struct is reasonable and that the
   old name we are assuming to be a directory name actually is (by checking
   for a trailing '/'). */

void
patch_subfile_names (subfile, name)
     struct subfile *subfile;
     char *name;
{
  if (subfile != NULL && subfile->dirname == NULL && subfile->name != NULL
      && subfile->name[strlen(subfile->name)-1] == '/')
    {
      subfile->dirname = subfile->name;
      subfile->name = savestring (name, strlen (name));
      last_source_file = name;

      /* Default the source language to whatever can be deduced from
	 the filename.  If nothing can be deduced (such as for a C/C++
	 include file with a ".h" extension), then inherit whatever
	 language the previous subfile had.  This kludgery is necessary
	 because there is no standard way in some object formats to
	 record the source language.  Also, when symtabs are allocated
	 we try to deduce a language then as well, but it is too late
	 for us to use that information while reading symbols, since
	 symtabs aren't allocated until after all the symbols have
	 been processed for a given source file. */

      subfile->language = deduce_language_from_filename (subfile->name);
      if (subfile->language == language_unknown &&
	  subfile->next != NULL)
	{
	  subfile->language = subfile->next->language;
	}
    }
}


/* Handle the N_BINCL and N_EINCL symbol types
   that act like N_SOL for switching source files
   (different subfiles, as we call them) within one object file,
   but using a stack rather than in an arbitrary order.  */

void
push_subfile ()
{
  register struct subfile_stack *tem
    = (struct subfile_stack *) xmalloc (sizeof (struct subfile_stack));

  tem->next = subfile_stack;
  subfile_stack = tem;
  if (current_subfile == NULL || current_subfile->name == NULL)
    {
      abort ();
    }
  tem->name = current_subfile->name;
}

char *
pop_subfile ()
{
  register char *name;
  register struct subfile_stack *link = subfile_stack;

  if (link == NULL)
    {
      abort ();
    }
  name = link->name;
  subfile_stack = link->next;
  free ((PTR)link);
  return (name);
}


/* Add a linetable entry for line number LINE and address PC to the line
   vector for SUBFILE.  */

void
record_line (subfile, line, pc)
     register struct subfile *subfile;
     int line;
     CORE_ADDR pc;
{
  struct linetable_entry *e;
  /* Ignore the dummy line number in libg.o */

  if (line == 0xffff)
    {
      return;
    }

  /* Make sure line vector exists and is big enough.  */
  if (!subfile->line_vector)
    {
      subfile->line_vector_length = INITIAL_LINE_VECTOR_LENGTH;
      subfile->line_vector = (struct linetable *)
	xmalloc (sizeof (struct linetable)
	  + subfile->line_vector_length * sizeof (struct linetable_entry));
      subfile->line_vector->nitems = 0;
    }

  if (subfile->line_vector->nitems + 1 >= subfile->line_vector_length)
    {
      subfile->line_vector_length *= 2;
      subfile->line_vector = (struct linetable *)
	xrealloc ((char *) subfile->line_vector, (sizeof (struct linetable)
	  + subfile->line_vector_length * sizeof (struct linetable_entry)));
    }

  e = subfile->line_vector->item + subfile->line_vector->nitems++;
  e->line = line; e->pc = pc;
}


/* Needed in order to sort line tables from IBM xcoff files.  Sigh!  */

static int
compare_line_numbers (ln1p, ln2p)
     const void *ln1p;
     const void *ln2p;
{
  struct linetable_entry *ln1 = (struct linetable_entry *) ln1p;
  struct linetable_entry *ln2 = (struct linetable_entry *) ln2p;

  /* Note: this code does not assume that CORE_ADDRs can fit in ints.
     Please keep it that way.  */
  if (ln1->pc < ln2->pc)
    return -1;

  if (ln1->pc > ln2->pc)
    return 1;

  /* If pc equal, sort by line.  I'm not sure whether this is optimum
     behavior (see comment at struct linetable in symtab.h).  */
  return ln1->line - ln2->line;
}


/* Start a new symtab for a new source file.
   Called, for example, when a stabs symbol of type N_SO is seen, or when
   a DWARF TAG_compile_unit DIE is seen.
   It indicates the start of data for one original source file.  */

void
start_symtab (name, dirname, start_addr)
     char *name;
     char *dirname;
     CORE_ADDR start_addr;
{

  last_source_file = name;
  last_source_start_addr = start_addr;
  file_symbols = NULL;
  global_symbols = NULL;
  within_function = 0;

  /* Context stack is initially empty.  Allocate first one with room for
     10 levels; reuse it forever afterward.  */
  if (context_stack == NULL)
    {
      context_stack_size = INITIAL_CONTEXT_STACK_SIZE;
      context_stack = (struct context_stack *)
	xmalloc (context_stack_size * sizeof (struct context_stack));
    }
  context_stack_depth = 0;

  /* Initialize the list of sub source files with one entry
     for this file (the top-level source file).  */

  subfiles = NULL;
  current_subfile = NULL;
  start_subfile (name, dirname);
}

/* Finish the symbol definitions for one main source file,
   close off all the lexical contexts for that file
   (creating struct block's for them), then make the struct symtab
   for that file and put it in the list of all such.

   END_ADDR is the address of the end of the file's text.
   SECTION is the section number (in objfile->section_offsets) of
   the blockvector and linetable.

   Note that it is possible for end_symtab() to return NULL.  In particular,
   for the DWARF case at least, it will return NULL when it finds a
   compilation unit that has exactly one DIE, a TAG_compile_unit DIE.  This
   can happen when we link in an object file that was compiled from an empty
   source file.  Returning NULL is probably not the correct thing to do,
   because then gdb will never know about this empty file (FIXME). */

struct symtab *
end_symtab (end_addr, objfile, section)
     CORE_ADDR end_addr;
     struct objfile *objfile;
     int section;
{
  register struct symtab *symtab = NULL;
  register struct blockvector *blockvector;
  register struct subfile *subfile;
  register struct context_stack *cstk;
  struct subfile *nextsub;

  /* Finish the lexical context of the last function in the file;
     pop the context stack.  */

  if (context_stack_depth > 0)
    {
      cstk = pop_context();
      /* Make a block for the local symbols within.  */
      finish_block (cstk->name, &local_symbols, cstk->old_blocks,
		    cstk->start_addr, end_addr, objfile);

      if (context_stack_depth > 0)
	{
	  /* This is said to happen with SCO.  The old coffread.c code
	     simply emptied the context stack, so we do the same.  FIXME:
	     Find out why it is happening.  This is not believed to happen
	     in most cases (even for coffread.c); it used to be an abort().  */
	  static struct complaint msg =
	    {"Context stack not empty in end_symtab", 0, 0};
	  complain (&msg);
	  context_stack_depth = 0;
	}
    }

  /* Reordered executables may have out of order pending blocks; if
     OBJF_REORDERED is true, then sort the pending blocks.  */
  if ((objfile->flags & OBJF_REORDERED) && pending_blocks)
    {
      /* FIXME!  Remove this horrid bubble sort and use qsort!!!
	 It'd be a whole lot easier if they weren't in a linked list!!! */
      int swapped;
      do
	{
	  struct pending_block *pb, *pbnext;
	  
	  pb = pending_blocks;
	  pbnext = pb->next;
	  swapped = 0;

	  while (pbnext)
	    {
	      /* swap blocks if unordered! */
	  
	      if (BLOCK_START(pb->block) < BLOCK_START(pbnext->block)) 
		{
		  struct block *tmp = pb->block;
		  pb->block = pbnext->block;
		  pbnext->block = tmp;
		  swapped = 1;
		}
	      pb = pbnext;
	      pbnext = pbnext->next;
	    }
	} while (swapped);
    }

  /* Cleanup any undefined types that have been left hanging around
     (this needs to be done before the finish_blocks so that
     file_symbols is still good).

     Both cleanup_undefined_types and finish_global_stabs are stabs
     specific, but harmless for other symbol readers, since on gdb
     startup or when finished reading stabs, the state is set so these
     are no-ops.  FIXME: Is this handled right in case of QUIT?  Can
     we make this cleaner?  */

  cleanup_undefined_types ();
  finish_global_stabs (objfile);

  if (pending_blocks == NULL
      && file_symbols == NULL
      && global_symbols == NULL)
    {
      /* Ignore symtabs that have no functions with real debugging info */
      blockvector = NULL;
    }
  else
    {
      /* Define the STATIC_BLOCK & GLOBAL_BLOCK, and build the blockvector. */
      finish_block (0, &file_symbols, 0, last_source_start_addr, end_addr,
		    objfile);
      finish_block (0, &global_symbols, 0, last_source_start_addr, end_addr,
		    objfile);
      blockvector = make_blockvector (objfile);
    }

#ifdef PROCESS_LINENUMBER_HOOK
  PROCESS_LINENUMBER_HOOK ();			/* Needed for xcoff. */
#endif

  /* Now create the symtab objects proper, one for each subfile.  */
  /* (The main file is the last one on the chain.)  */

  for (subfile = subfiles; subfile; subfile = nextsub)
    {
      int linetablesize = 0;
      /* If we have blocks of symbols, make a symtab.
	 Otherwise, just ignore this file and any line number info in it.  */
      symtab = NULL;
      if (blockvector)
	{
	  if (subfile->line_vector)
	    {
	      linetablesize = sizeof (struct linetable) +
		subfile->line_vector->nitems * sizeof (struct linetable_entry);
#if 0
	      /* I think this is artifact from before it went on the obstack.
		 I doubt we'll need the memory between now and when we
		 free it later in this function.  */
	      /* First, shrink the linetable to make more memory.  */
	      subfile->line_vector = (struct linetable *)
		xrealloc ((char *) subfile->line_vector, linetablesize);
#endif

	      /* Like the pending blocks, the line table may be scrambled
		 in reordered executables.  Sort it if OBJF_REORDERED is
		 true.  */
	      if (objfile->flags & OBJF_REORDERED)
		qsort (subfile->line_vector->item,
		       subfile->line_vector->nitems,
		       sizeof (struct linetable_entry), compare_line_numbers);
	    }

	  /* Now, allocate a symbol table.  */
	  symtab = allocate_symtab (subfile->name, objfile);

	  /* Fill in its components.  */
	  symtab->blockvector = blockvector;
	  if (subfile->line_vector)
	    {
	      /* Reallocate the line table on the symbol obstack */
	      symtab->linetable = (struct linetable *) 
		obstack_alloc (&objfile -> symbol_obstack, linetablesize);
	      memcpy (symtab->linetable, subfile->line_vector, linetablesize);
	    }
	  else
	    {
	      symtab->linetable = NULL;
	    }
	  symtab->block_line_section = section;
	  if (subfile->dirname)
	    {
	      /* Reallocate the dirname on the symbol obstack */
	      symtab->dirname = (char *)
		obstack_alloc (&objfile -> symbol_obstack,
			       strlen (subfile -> dirname) + 1);
	      strcpy (symtab->dirname, subfile->dirname);
	    }
	  else
	    {
	      symtab->dirname = NULL;
	    }
	  symtab->free_code = free_linetable;
	  symtab->free_ptr = NULL;

	  /* Use whatever language we have been using for this subfile,
	     not the one that was deduced in allocate_symtab from the
	     filename.  We already did our own deducing when we created
	     the subfile, and we may have altered our opinion of what
	     language it is from things we found in the symbols. */
	  symtab->language = subfile->language;

	  /* All symtabs for the main file and the subfiles share a
	     blockvector, so we need to clear primary for everything but
	     the main file.  */

	  symtab->primary = 0;
	}
      if (subfile->name != NULL)
	{
	  free ((PTR) subfile->name);
	}
      if (subfile->dirname != NULL)
	{
	  free ((PTR) subfile->dirname);
	}
      if (subfile->line_vector != NULL)
	{
	  free ((PTR) subfile->line_vector);
	}

      nextsub = subfile->next;
      free ((PTR)subfile);
    }

  /* Set this for the main source file.  */
  if (symtab)
    {
      symtab->primary = 1;
    }

  last_source_file = NULL;
  current_subfile = NULL;

  return (symtab);
}


/* Push a context block.  Args are an identifying nesting level (checkable
   when you pop it), and the starting PC address of this context.  */

struct context_stack *
push_context (desc, valu)
     int desc;
     CORE_ADDR valu;
{
  register struct context_stack *new;

  if (context_stack_depth == context_stack_size)
    {
      context_stack_size *= 2;
      context_stack = (struct context_stack *)
	xrealloc ((char *) context_stack,
		  (context_stack_size * sizeof (struct context_stack)));
    }

  new = &context_stack[context_stack_depth++];
  new->depth = desc;
  new->locals = local_symbols;
  new->old_blocks = pending_blocks;
  new->start_addr = valu;
  new->name = NULL;

  local_symbols = NULL;

  return (new);
}


/* Compute a small integer hash code for the given name. */

int
hashname (name)
     char *name;
{
  register char *p = name;
  register int total = p[0];
  register int c;

  c = p[1];
  total += c << 2;
  if (c)
    {
      c = p[2];
      total += c << 4;
      if (c)
	{
	  total += p[3] << 6;
	}
    }

  /* Ensure result is positive.  */
  if (total < 0)
    {
      total += (1000 << 6);
    }
  return (total % HASHSIZE);
}


/* Initialize anything that needs initializing when starting to read
   a fresh piece of a symbol file, e.g. reading in the stuff corresponding
   to a psymtab.  */

void
buildsym_init ()
{
  free_pendings = NULL;
  file_symbols = NULL;
  global_symbols = NULL;
  pending_blocks = NULL;
}

/* Initialize anything that needs initializing when a completely new
   symbol file is specified (not just adding some symbols from another
   file, e.g. a shared library).  */

void
buildsym_new_init ()
{
  buildsym_init ();
}

/* Initializer for this module */

void
_initialize_buildsym ()
{
}
@
