head	1.3;
access;
symbols
	OPENBSD_3_5:1.2.0.32
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.30
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.0.2;
locks; strict;
comment	@ * @;


1.3
date	2004.05.21.20.23.31;	author kettenis;	state dead;
branches;
next	1.2;

1.2
date	96.11.23.03.47.01;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.31.07;	author niklas;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	96.11.19.14.31.07;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Resolve conflicts for GDB 6.1.  Add local patches.
ok deraadt@@
@
text
@#define W32SUT_32

#include "windefs.h"
#include "w32sut.h"
#include "serdll32.h"
#include "serdll.h"

typedef BOOL (APIENTRY * PUTREGISTER) (HANDLE hModule,
				       LPCSTR lpsz16BitDLL,
				       LPCSTR lpszInitName,
				       LPCSTR lpszProcName,
				       UT32PROC * ppfn32Thunk,
				       FARPROC pfnUT32Callback,
				       LPVOID lpBuff
);


typedef VOID (APIENTRY * PUTUNREGISTER) (HANDLE hModule);

UT32PROC pfnUTProc = NULL;
PUTREGISTER pUTRegister = NULL;
PUTUNREGISTER pUTUnRegister = NULL;
int cProcessesAttached = 0;
BOOL fWin32s = FALSE;
HANDLE hKernel32 = 0;


BOOL APIENTRY 
DllInit (HANDLE hInst, DWORD fdwReason, LPVOID lpReserved)
{
  if (fdwReason == DLL_PROCESS_ATTACH)
    {
      if (cProcessesAttached++)
	{
	  return (TRUE);
	}

      fWin32s = (BOOL) (GetVersion () & 0x80000000);

      if (!fWin32s)
	return (TRUE);

      hKernel32 = LoadLibrary ("Kernel32.Dll");

      pUTRegister = (PUTREGISTER) GetProcAddress (hKernel32, "UTRegister");

      if (!pUTRegister)
	return (FALSE);

      pUTUnRegister = (PUTUNREGISTER) GetProcAddress (hKernel32, "UTUnRegister");

      if (!pUTUnRegister)
	return (FALSE);

      return (*pUTRegister)
	(hInst,
	 "serdll16.DLL",
	 NULL,			// no init routine
	  "UTProc",		// name of 16bit dispatch routine
	  &pfnUTProc,		// Global variable to receive thunk address
	  NULL,			// no callback function
	  NULL);		// no shared memroy

    }
  else if ((fdwReason == DLL_PROCESS_DETACH)
	   && (0 == --cProcessesAttached)
	   && fWin32s)
    {
      (*pUTUnRegister) (hInst);
      FreeLibrary (hKernel32);
    }

}

int APIENTRY 
BuildCommDCB16 (LPCSTR lpszDef, DCB16 * lpdcb)
{

  DWORD Args[2];
  PVOID TransList[3];

  Args[0] = (DWORD) lpszDef;
  Args[1] = (DWORD) lpdcb;

  TransList[0] = &Args[0];
  TransList[1] = &Args[1];
  TransList[2] = NULL;


  return ((*pfnUTProc) (Args, BUILDCOMMDCB, TransList));
}

int APIENTRY 
OpenComm16 (LPCSTR lpszDevControl,
	    USHORT cbInQueue,
	    USHORT cbOutQueue,
	    LPCSTR dcb)
{
  DWORD Args[4];
  PVOID TransList[3];

  Args[0] = (DWORD) lpszDevControl;
  Args[1] = (DWORD) cbInQueue;
  Args[2] = (DWORD) cbOutQueue;
  Args[3] = (DWORD) dcb;

  TransList[0] = &Args[0];
  TransList[1] = &Args[3];
  TransList[2] = NULL;


  return ((*pfnUTProc) (Args, OPENCOMM, TransList));
}

int APIENTRY 
CloseComm16 (int idComDev)
{
  DWORD Args[1];

  Args[0] = idComDev;

  return ((*pfnUTProc) (Args, CLOSECOMM, NULL));
}

int APIENTRY 
ReadComm16 (INT idComDev, LPVOID lpBuf, INT cbRead)
{
  DWORD Args[3];
  PVOID TransList[2];

  Args[0] = (DWORD) idComDev;
  Args[1] = (DWORD) lpBuf;
  Args[2] = (DWORD) cbRead;

  TransList[0] = &Args[1];
  TransList[1] = NULL;


  return ((*pfnUTProc) (Args, READCOMM, TransList));
}


int APIENTRY 
WriteComm16 (INT idComDev, LPCSTR lpBuf, INT cbWrite)
{
  DWORD Args[3];
  PVOID TransList[2];

  Args[0] = (DWORD) idComDev;
  Args[1] = (DWORD) lpBuf;
  Args[2] = (DWORD) cbWrite;

  TransList[0] = &Args[1];
  TransList[1] = NULL;


  return ((*pfnUTProc) (Args, WRITECOMM, TransList));
}


int APIENTRY 
FlushComm16 (INT idComDev, INT fnQueue)
{
  DWORD Args[2];

  Args[0] = (DWORD) idComDev;
  Args[1] = (DWORD) fnQueue;

  return ((*pfnUTProc) (Args, FLUSHCOMM, NULL));
}

int APIENTRY 
TransmitCommChar16 (INT idComDev, char chTransmit)
{
  DWORD Args[2];

  Args[0] = (DWORD) idComDev;
  Args[1] = (DWORD) chTransmit;

  return ((*pfnUTProc) (Args, TRANSMITCOMMCHAR, NULL));
}

int APIENTRY 
SetCommState16 (DCB16 * lpdcb)
{
  DWORD Args[1];

  PVOID TransList[2];

  Args[0] = (DWORD) lpdcb;

  TransList[0] = &Args[0];
  TransList[1] = NULL;

  return ((*pfnUTProc) (Args, SETCOMMSTATE, TransList));
}

int APIENTRY 
GetCommState16 (INT idComDev, DCB16 * lpdcb)
{
  DWORD Args[1];

  PVOID TransList[2];

  Args[0] = (DWORD) lpdcb;

  TransList[0] = &Args[0];
  TransList[1] = NULL;

  return ((*pfnUTProc) (Args, GETCOMMSTATE, TransList));
}
int APIENTRY 
GetCommReady16 (INT idComDev, char *ptr)
{
  DWORD Args[2];

  PVOID tlist[2];

  Args[0] = (DWORD) idComDev;
  Args[1] = (DWORD) ptr;
  tlist[0] = &Args[1];
  tlist[1] = 0;



  return ((*pfnUTProc) (Args, GETCOMMREADY, tlist));
}
int APIENTRY 
GetCommError16 (INT idComDev, COMSTAT16 * lpComStat)
{
  DWORD Args[2];

  PVOID TransList[2];

  Args[0] = (DWORD) idComDev;
  Args[1] = (DWORD) lpComStat;

  TransList[0] = &Args[1];
  TransList[1] = NULL;

  return ((*pfnUTProc) (Args, GETCOMMERROR, TransList));
}

int APIENTRY 
SetCommBreak16 (INT idComDev)
{
  DWORD Args[1];

  Args[0] = (DWORD) idComDev;

  return ((*pfnUTProc) (Args, SETCOMMBREAK, NULL));
}


int APIENTRY 
ClearCommBreak16 (INT idComDev)
{
  DWORD Args[1];

  Args[0] = (DWORD) idComDev;

  return ((*pfnUTProc) (Args, CLEARCOMMBREAK, NULL));
}
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@@


1.1
log
@file serdll32.c was initially added on branch CYGNUS.
@
text
@d1 263
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 263
#define W32SUT_32

#include "windefs.h"
#include "w32sut.h"
#include "serdll32.h"
#include "serdll.h"

typedef BOOL (APIENTRY * PUTREGISTER) (HANDLE hModule,
				       LPCSTR lpsz16BitDLL,
				       LPCSTR lpszInitName,
				       LPCSTR lpszProcName,
				       UT32PROC * ppfn32Thunk,
				       FARPROC pfnUT32Callback,
				       LPVOID lpBuff
);


typedef VOID (APIENTRY * PUTUNREGISTER) (HANDLE hModule);

UT32PROC pfnUTProc = NULL;
PUTREGISTER pUTRegister = NULL;
PUTUNREGISTER pUTUnRegister = NULL;
int cProcessesAttached = 0;
BOOL fWin32s = FALSE;
HANDLE hKernel32 = 0;


BOOL APIENTRY 
DllInit (HANDLE hInst, DWORD fdwReason, LPVOID lpReserved)
{
  if (fdwReason == DLL_PROCESS_ATTACH)
    {
      if (cProcessesAttached++)
	{
	  return (TRUE);
	}

      fWin32s = (BOOL) (GetVersion () & 0x80000000);

      if (!fWin32s)
	return (TRUE);

      hKernel32 = LoadLibrary ("Kernel32.Dll");

      pUTRegister = (PUTREGISTER) GetProcAddress (hKernel32, "UTRegister");

      if (!pUTRegister)
	return (FALSE);

      pUTUnRegister = (PUTUNREGISTER) GetProcAddress (hKernel32, "UTUnRegister");

      if (!pUTUnRegister)
	return (FALSE);

      return (*pUTRegister)
	(hInst,
	 "serdll16.DLL",
	 NULL,			// no init routine
	  "UTProc",		// name of 16bit dispatch routine
	  &pfnUTProc,		// Global variable to receive thunk address
	  NULL,			// no callback function
	  NULL);		// no shared memroy

    }
  else if ((fdwReason == DLL_PROCESS_DETACH)
	   && (0 == --cProcessesAttached)
	   && fWin32s)
    {
      (*pUTUnRegister) (hInst);
      FreeLibrary (hKernel32);
    }

}

int APIENTRY 
BuildCommDCB16 (LPCSTR lpszDef, DCB16 * lpdcb)
{

  DWORD Args[2];
  PVOID TransList[3];

  Args[0] = (DWORD) lpszDef;
  Args[1] = (DWORD) lpdcb;

  TransList[0] = &Args[0];
  TransList[1] = &Args[1];
  TransList[2] = NULL;


  return ((*pfnUTProc) (Args, BUILDCOMMDCB, TransList));
}

int APIENTRY 
OpenComm16 (LPCSTR lpszDevControl,
	    USHORT cbInQueue,
	    USHORT cbOutQueue,
	    LPCSTR dcb)
{
  DWORD Args[4];
  PVOID TransList[3];

  Args[0] = (DWORD) lpszDevControl;
  Args[1] = (DWORD) cbInQueue;
  Args[2] = (DWORD) cbOutQueue;
  Args[3] = (DWORD) dcb;

  TransList[0] = &Args[0];
  TransList[1] = &Args[3];
  TransList[2] = NULL;


  return ((*pfnUTProc) (Args, OPENCOMM, TransList));
}

int APIENTRY 
CloseComm16 (int idComDev)
{
  DWORD Args[1];

  Args[0] = idComDev;

  return ((*pfnUTProc) (Args, CLOSECOMM, NULL));
}

int APIENTRY 
ReadComm16 (INT idComDev, LPVOID lpBuf, INT cbRead)
{
  DWORD Args[3];
  PVOID TransList[2];

  Args[0] = (DWORD) idComDev;
  Args[1] = (DWORD) lpBuf;
  Args[2] = (DWORD) cbRead;

  TransList[0] = &Args[1];
  TransList[1] = NULL;


  return ((*pfnUTProc) (Args, READCOMM, TransList));
}


int APIENTRY 
WriteComm16 (INT idComDev, LPCSTR lpBuf, INT cbWrite)
{
  DWORD Args[3];
  PVOID TransList[2];

  Args[0] = (DWORD) idComDev;
  Args[1] = (DWORD) lpBuf;
  Args[2] = (DWORD) cbWrite;

  TransList[0] = &Args[1];
  TransList[1] = NULL;


  return ((*pfnUTProc) (Args, WRITECOMM, TransList));
}


int APIENTRY 
FlushComm16 (INT idComDev, INT fnQueue)
{
  DWORD Args[2];

  Args[0] = (DWORD) idComDev;
  Args[1] = (DWORD) fnQueue;

  return ((*pfnUTProc) (Args, FLUSHCOMM, NULL));
}

int APIENTRY 
TransmitCommChar16 (INT idComDev, char chTransmit)
{
  DWORD Args[2];

  Args[0] = (DWORD) idComDev;
  Args[1] = (DWORD) chTransmit;

  return ((*pfnUTProc) (Args, TRANSMITCOMMCHAR, NULL));
}

int APIENTRY 
SetCommState16 (DCB16 * lpdcb)
{
  DWORD Args[1];

  PVOID TransList[2];

  Args[0] = (DWORD) lpdcb;

  TransList[0] = &Args[0];
  TransList[1] = NULL;

  return ((*pfnUTProc) (Args, SETCOMMSTATE, TransList));
}

int APIENTRY 
GetCommState16 (INT idComDev, DCB16 * lpdcb)
{
  DWORD Args[1];

  PVOID TransList[2];

  Args[0] = (DWORD) lpdcb;

  TransList[0] = &Args[0];
  TransList[1] = NULL;

  return ((*pfnUTProc) (Args, GETCOMMSTATE, TransList));
}
int APIENTRY 
GetCommReady16 (INT idComDev, char *ptr)
{
  DWORD Args[2];

  PVOID tlist[2];

  Args[0] = (DWORD) idComDev;
  Args[1] = (DWORD) ptr;
  tlist[0] = &Args[1];
  tlist[1] = 0;



  return ((*pfnUTProc) (Args, GETCOMMREADY, tlist));
}
int APIENTRY 
GetCommError16 (INT idComDev, COMSTAT16 * lpComStat)
{
  DWORD Args[2];

  PVOID TransList[2];

  Args[0] = (DWORD) idComDev;
  Args[1] = (DWORD) lpComStat;

  TransList[0] = &Args[1];
  TransList[1] = NULL;

  return ((*pfnUTProc) (Args, GETCOMMERROR, TransList));
}

int APIENTRY 
SetCommBreak16 (INT idComDev)
{
  DWORD Args[1];

  Args[0] = (DWORD) idComDev;

  return ((*pfnUTProc) (Args, SETCOMMBREAK, NULL));
}


int APIENTRY 
ClearCommBreak16 (INT idComDev)
{
  DWORD Args[1];

  Args[0] = (DWORD) idComDev;

  return ((*pfnUTProc) (Args, CLEARCOMMBREAK, NULL));
}
@
