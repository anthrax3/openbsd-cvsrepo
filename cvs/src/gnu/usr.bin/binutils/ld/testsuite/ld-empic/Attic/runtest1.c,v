head	1.2;
access;
symbols
	OPENBSD_3_5:1.1.0.34
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.32
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_3:1.1.0.30
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.28
	OPENBSD_3_2_BASE:1.1
	binutils-2_11_2:1.1.1.1
	OPENBSD_3_1:1.1.0.26
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.24
	OPENBSD_3_0_BASE:1.1
	BINUTILS-2_10_1:1.1.1.1
	OPENBSD_2_9:1.1.0.22
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_8:1.1.0.20
	OPENBSD_2_8_BASE:1.1
	BINUTILS-2_10:1.1.1.1
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.05.17.21.54.52;	author drahn;	state dead;
branches;
next	1.1;

1.1
date	96.01.08.11.09.52;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.52;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@/* First C source file for actual execution test.  */

/* The main point of this test is to make sure that the code and data
   are truly position independent.  We statically initialize several
   global variables, and make sure that they are correctly adjusted at
   runtime.  */

int i = 1;
int j = 0;
extern int k;
int l;
char small_buf[] = "aaaa";
char *small_pointer = small_buf;
char big_buf[] = "aaaaaaaaaaaaaaaa";
char *big_pointer = big_buf;

extern int bar ();
int (*pbar) () = bar;

static int
foo2 (arg)
     int arg;
{
  l = arg;
  return i + j;
}

int (*pfoo2) () = foo2;

int
chkstr (z, c)
     char *z;
     int c;
{
  /* Switch statements need extra effort to be position independent,
     so we run one here, even though most of the cases will never be
     taken.  */
  switch (c)
    {
    case 1:
    case 2:
    case 3:
      return i - 1;
    case 4:
      break;
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return i * j;
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return j;
    case 16:
      break;
    default:
      return 0;
    }

  while (c-- != 0)
    if (*z++ != 'a')
      return 0;

  return *z == '\0';
}

/* This function is called by the assembler startup routine.  It tries
   to test that everything was correctly initialized.  It returns 0 on
   success, something else on failure.  */

int
foo ()
{
  if (i != 1)
    return 1;
  if (j != 0)
    return 2;
  if (! chkstr (small_buf, 4))
    return 3;
  if (! chkstr (small_pointer, 4))
    return 4;
  if (! chkstr (big_buf, 16))
    return 5;
  if (! chkstr (big_pointer, 16))
    return 6;

  if (l != 0)
    return 7;
  if (foo2 (1) != 1)
    return 8;
  if (l != 1)
    return 9;
  if ((*pfoo2) (2) != 1)
    return 10;
  if (l != 2)
    return 11;

  if (bar (1) != 0)
    return 12;
  if (bar (-1) != 1)
    return 13;
  if ((*pbar) (0xa5a5a5a5) != -1)
    return 14;
  if (k != 0xa5a5a5a5)
    return 15;
  if ((*pbar) (0) != 0xa5a5a5a5)
    return 16;
  if (k != 0)
    return 17;

  return 0;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@
