head	1.2;
access;
symbols
	OPENBSD_3_5:1.1.0.34
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.32
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_3:1.1.0.30
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.28
	OPENBSD_3_2_BASE:1.1
	binutils-2_11_2:1.1.1.1
	OPENBSD_3_1:1.1.0.26
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.24
	OPENBSD_3_0_BASE:1.1
	BINUTILS-2_10_1:1.1.1.1
	OPENBSD_2_9:1.1.0.22
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_8:1.1.0.20
	OPENBSD_2_8_BASE:1.1
	BINUTILS-2_10:1.1.1.1
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2004.05.17.21.54.52;	author drahn;	state dead;
branches;
next	1.1;

1.1
date	96.01.08.11.09.53;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.53;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@# Assembler initialization code for actual execution test.
	
# This code becomes the start of the execution test program.  It is
# responsible for initializing the static data, invoking the C code,
# and returning the result.  It is called as though it were a C
# function with an argument of the address of the data segment.

# We need to know the value of _ftext and _fdata at link time, but we
# have no way to actually get that at runtime.  This is because when
# this code is compiled with -membedded-pic, the la instruction will
# be turned into an addiu $gp instruction.  We work around this by
# storing the information in words in the .data section.  We then load
# the values of these words *before* doing the runtime relocation.
	.sdata
text_start:
	.word	_ftext
data_start:
	.word	_fdata

	.globl	start
	.text
start:
	# Grab some space on the stack, just as though we were a real
	# function.
	addiu	$sp,$sp,-8
	sw	$31,0($sp)

	# Save the $gp register, and set it up for our data section.
	sw	$gp,4($sp)

	addu	$gp,$4,0x8000		# macro

	# The start of the data segment is in $4.

	# Get the address of start into $5 in a position independent
	# fashion.
	.set	noreorder
	$LF1 = . + 8
	bal	$LF1
	la	$5,start-$LF1		# macro
	.set	reorder
	addu	$5,$5,$31

	# Now get the address of _ftext into $6.
	la	$6,_ftext-start		# macro
	addu	$6,$6,$5

	# Get the value of _ftext used to link into $7.
	lw	$7,text_start		# macro

	# Get the value of _fdata used to link into $8.
	lw	$8,data_start		# macro

	# Get the address of __runtime_reloc_start into $9.
	la	$9,__runtime_reloc_start-start	# macro
	addu	$9,$9,$5

	# Get the address of __runtime_reloc_stop into $10.
	la	$10,__runtime_reloc_stop-start	# macro
	addu	$10,$10,$5

	# The words between $9 and $10 are the runtime initialization
	# instructions.  Step through and relocate them.  First set
	# $11 and $12 to the values to add to text and data sections,
	# respectively.
	subu	$11,$6,$7
	subu	$12,$4,$8

1:	
	bge	$9,$10,3f		# macro
	lw	$13,0($9)
	and	$14,$13,0xfffffffe	# macro
	move	$15,$11
	beq	$13,$14,2f
	move	$15,$12
2:	
	addu	$14,$14,$4
	lw	$24,0($14)
	addu	$24,$24,$15
	sw	$24,0($14)
	addiu	$9,$9,4
	b	1b
3:	

	# Now the statically initialized data has been relocated
	# correctly, and we can call the C code which does the actual
	# testing.
	bal	foo

	# We return the value returned by the C code.
	lw	$31,0($sp)
	lw	$gp,4($sp)
	addu	$sp,$sp,8
	j	$31
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@
