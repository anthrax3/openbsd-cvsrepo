head	1.2;
access;
symbols
	OPENBSD_3_5:1.1.1.2.0.8
	OPENBSD_3_5_BASE:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.6
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.4
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.2
	OPENBSD_3_2_BASE:1.1.1.2
	binutils-2_11_2:1.1.1.2
	OPENBSD_3_1:1.1.1.1.0.8
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.6
	OPENBSD_3_0_BASE:1.1.1.1
	BINUTILS-2_10_1:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.4
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.2
	OPENBSD_2_8_BASE:1.1.1.1
	BINUTILS-2_10:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2004.05.17.21.54.52;	author drahn;	state dead;
branches;
next	1.1;

1.1
date	2000.09.12.14.48.35;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.09.12.14.48.35;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.05.13.14.02.25;	author fgsch;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@# Expect script for LD selective linking tests
#   Copyright (C) 1998, 1999 Free Software Foundation
#
# This file is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# Written by Catherine Moore (clm@@cygnus.com)
# Make sure that constructors are handled correctly.


# COFF based ports do not support selective linking
if {[istarget "*-*-coff"]} {
  return
}
if {[istarget "*-*-pe"]} {
  return
}

set test1 "selective1"
set test2 "selective2"
set test3 "selective3"
set test4 "selective4"
set test5 "selective5"

set cflags "-w -O2 -ffunction-sections -fdata-sections" 
set cxxflags "-fvtable-gc -fno-exceptions -fno-rtti"
set ldflags "--gc-sections -Bstatic"

if { [which $CXX] == 0 } {
    untested $test1
    untested $test2
    untested $test3
    untested $test4
    untested $test5
    return
}

if { ![ld_compile "$CC $cflags" $srcdir/$subdir/1.c tmpdir/1.o]} {
    unresolved $test1
    return
}

if ![ld_simple_link $ld tmpdir/1.x "$ldflags tmpdir/1.o"] {
    fail $test1
} else {
    if ![ld_nm $nm tmpdir/1.x] {
	unresolved $test1
    } else {
	if {[info exists nm_output(dropme1)]} {
		send_log "dropme1 == $nm_output(dropme1)\n"
		verbose "dropme1 == $nm_output(dropme1)"
		fail $test1
	    } else {
		if {[info exists nm_output(dropme2)]} {
		    send_log "dropme2 == $nm_output(dropme2)\n"
		    verbose "dropme2 == $nm_output(dropme2)"
		    fail $test1
		} else {
		    pass $test1
		}
	    }
	}
    }

if { ![ld_compile "$CC $cflags" $srcdir/$subdir/2.c tmpdir/2.o]} {
    unresolved $test2
    return
}

if ![ld_simple_link $ld tmpdir/2.x "$ldflags tmpdir/2.o"] {
    fail $test2
} else {
    if ![ld_nm $nm tmpdir/2.x] {
	unresolved $test2
    } else {
	if {[info exists nm_output(foo)] } {
            send_log "foo == $nm_output(foo)\n"
            verbose "foo== $nm_output(foo)"
            fail $test2
	} else {
            pass $test2
	    } 
	 }
     }

if { ![ld_compile "$CC $cflags" $srcdir/$subdir/2.c tmpdir/2.o]} {
    unresolved $test3
    return
}

if ![ld_simple_link $ld tmpdir/2.x "$ldflags -u foo tmpdir/2.o"] {
    fail $test3
} else {
    if ![ld_nm $nm tmpdir/2.x] {
	unresolved $test3
    } else {
	if {![info exists nm_output(foo)] } {
	    send_log "bad output from nm\n"
	    verbose "bad output from nm"
	    fail $test3
	} else {
	    if {$nm_output(foo) == 0} {
		send_log "foo == $nm_output(foo)\n"
		verbose "foo== $nm_output(foo)"
		fail $test3
	    } else {
                pass $test3
		}
	 }
     }
}

setup_xfail "v850*-*-elf"

if { ![ld_compile "$CC $cflags $cxxflags" $srcdir/$subdir/3.cc tmpdir/3.o]} {
    unresolved $test4
    return
}

setup_xfail "v850*-*-elf"

if ![ld_simple_link $ld tmpdir/3.x "$ldflags tmpdir/3.o"] {
   fail $test4
} else {
    if ![ld_nm $nm tmpdir/3.x] {
       unresolved $test4
    } else {
	if {[ info exists nm_output(bar__1A)]} {
	    send_log "bar__1A== $nm_output(_bar__1A)\n"
	    verbose "bar__1A == $nm_output(_bar__1A)"
	    fail $test4
	} else {
	    pass $test4
	}
    }
}

if { ![ld_compile "$CC $cflags $cxxflags" $srcdir/$subdir/4.cc tmpdir/4.o]} {
    unresolved $test5
    return
}

if ![ld_simple_link $ld tmpdir/4.x "$ldflags tmpdir/4.o"] {
    fail $test5
} else {
    if ![ld_nm $nm tmpdir/4.x] {
	unresolved $test5
    } else {
	if {[info exists nm_output(foo__1B)]} { 
            send_log "foo__1B == $nm_output(foo__1B)\n"
            verbose "foo__1B == $nm_output(foo__1B)"
	    fail $test5
	} else {
          if {[info exists nm_output(foo__1A)]} {
	        send_log "foo__1A== $nm_output(foo__1A)\n"
		verbose "foo__1A == $nm_output(foo__1A)"
		fail $test5
          } else {
	      pass $test5
             }
	}
    }
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@@


1.1.1.2
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
#   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d24 1
a24 1
    return
d27 1
a27 1
    return
d30 5
a34 4
# selective linking is not yet implemented for 68hc11/68hc12
if {[istarget "m6811-*-*"] || [istarget "m6812-*-*"]} {
    return
}
d36 1
a36 20
# List contains test-items with three items followed by four lists:
# 1:name 2:test-type (CC or C++; add as needed) 3:filename 4:ld-flags
# 5:must-have-symbols 6:must-not-have-symbols 7:xfail-targets.
#
# If a must(-not)-have symbol is a list, then that list must have two
# items; the symbol name and a value the symbol must (not) have.
#
# Note: ld_nm trims leading `_' from _start
#
# FIXME: Instead of table, read settings from each source-file.
set seltests {
  {selective1 C 1.c {} {} {dropme1 dropme2} {}}
  {selective2 C 2.c {} {} {foo} {mips*-*}}
  {selective3 C 2.c {-u foo} {foo} {{foo 0}} {mips*-*}}
  {selective4 C++ 3.cc {} {start foo__1A foo__1B} {bar__1A} {mips*-*}}
  {selective5 C++ 4.cc {} {} {foo__1B foo__1A} {mips*-*}}
  {selective6 C++ 5.cc {} {} {foo__1B foo__1A dropme1__Fv dropme2__Fv} {*-*-*}}
}

set cflags "-w -O -ffunction-sections -fdata-sections"
a39 1
# If we don't have g++ for the target, mark all tests as untested.
d41 5
a45 3
    foreach testitem $seltests {
	untested "[lindex $testitem 0]"
    }
d49 4
a52 12
foreach testitem $seltests {
    set testname [lindex $testitem 0]
    set testtype [lindex $testitem 1]
    set testfile [lindex $testitem 2]
    set objfile "tmpdir/[file rootname $testfile].o"
    set ldfile "tmpdir/[file rootname $testfile].x"
    set failed 0

    set ldargs [lindex $testitem 3]
    set mustsyms [lindex $testitem 4]
    set mustnotsyms [lindex $testitem 5]
    set xfails [lindex $testitem 6]
d54 20
a73 2
    foreach xfail_target $xfails {
	setup_xfail $xfail_target
d76 25
a100 6
    # It's either C or C++ at the moment.
    if { $testtype == "C++" } {
	set testflags "$cflags $cxxflags"
    } {
	set testflags "$cflags"
    }
d102 21
a122 7
    # Note that we do not actually *use* CXX; we just add cxxflags for C++
    # tests.  It might have been a buglet originally; now I think better
    # leave as is.
    if { ![ld_compile "$CC $testflags" $srcdir/$subdir/$testfile $objfile] } {
	unresolved $testname
	return
    }
d124 1
a124 10
    # V850 targets need libgcc.a
    if [istarget v850*-*-elf] {
	set objfile "$objfile -L ../gcc -lgcc"
    }
    
    # m6811/m6812 code has references to soft registers.
    if {[istarget m6811-*-*] || [istarget m6812-*-*]} {
	set objfile "$objfile --defsym _.frame=0 --defsym _.d1=0"
	set objfile "$objfile --defsym _.d2=0"
    }
d126 4
a129 4
    if ![ld_simple_link $ld $ldfile "$ldflags [join $ldargs] $objfile"] {
	fail $testname
	continue
    }
d131 1
a131 4
    if ![ld_nm $nm $ldfile] {
	unresolved $testname
	continue
    }
d133 12
a144 26
    # Check each mandated symbol and optionally mandated values. 
    foreach mustsym $mustsyms {
	if { [llength [concat $mustsym]] == 1 } {
	    if { ![info exists nm_output($mustsym)] } {
		verbose -log "$testname: missing $mustsym"
		fail $testname
		set failed 1
		break
	    }
	} {
	    set mustsymname [lindex $mustsym 0]
	    set mustsymvalue [lindex $mustsym 1]
	    if { ![info exists nm_output($mustsymname)] } {
		verbose -log "$testname: missing $mustsymname"
		fail $testname
		set failed 1
		break
	    } {
		if { $nm_output($mustsymname) != $mustsymvalue } {
		    verbose -log "$testname: $mustsymname != $mustsymvalue"
		    verbose -log "is instead $nm_output($mustsymname)"
		    fail $testname
		    set failed 1
		    break
		}
	    }
d147 1
d149 4
a152 3
    if { $failed != 0 } {
	continue
    }
d154 18
a171 20
    # Check each unwanted symbol, or that symbols do not have specific
    # values.
    foreach mustnotsym $mustnotsyms {
	if { [llength [concat $mustnotsym]] == 1 } {
	    if { [info exists nm_output($mustnotsym)] } {
		verbose -log "$testname: $mustnotsym == $nm_output($mustnotsym)"
		fail $testname
		set failed 1
		break
	    }
	} {
	    set mustnotsymname [lindex $mustnotsym 0]
	    set mustnotsymvalue [lindex $mustnotsym 1]
	    if { [info exists nm_output($mustnotsymname)] \
		    && $nm_output($mustnotsymname) == $mustnotsymvalue} {
		verbose -log "$testname: $mustnotsymname == $mustnotsymvalue"
		fail $testname
		set failed 1
		break
	    }
a173 4

    if { $failed == 0 } {
	pass $testname
    }
a174 1

@

