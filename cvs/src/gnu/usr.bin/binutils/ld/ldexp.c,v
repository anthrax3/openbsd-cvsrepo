head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.50
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.47;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.50;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.42;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.12.44;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.09.19;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.54.16;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.14;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.14;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.35.29;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.34.54;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.48.07;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.14.00.41;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.49;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.23.21;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* This module handles expression trees.
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
   Written by Steve Chamberlain of Cygnus Support <sac@@cygnus.com>.

This file is part of GLD, the Gnu Linker.

GLD is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GLD is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GLD; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */

/* This module is in charge of working out the contents of expressions.

   It has to keep track of the relative/absness of a symbol etc. This
   is done by keeping all values in a struct (an etree_value_type)
   which contains a value, a section to which it is relative and a
   valid bit.  */

#include "bfd.h"
#include "sysdep.h"
#include "bfdlink.h"

#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"
#include "ldexp.h"
#include <ldgram.h>
#include "ldlang.h"
#include "libiberty.h"
#include "safe-ctype.h"

static etree_value_type exp_fold_tree_no_dot
  (etree_type *, lang_output_section_statement_type *, lang_phase_type);
static bfd_vma align_n
  (bfd_vma, bfd_vma);

struct exp_data_seg exp_data_seg;

/* Print the string representation of the given token.  Surround it
   with spaces if INFIX_P is TRUE.  */

static void
exp_print_token (token_code_type code, int infix_p)
{
  static const struct
  {
    token_code_type code;
    char * name;
  }
  table[] =
  {
    { INT, "int" },
    { NAME, "NAME" },
    { PLUSEQ, "+=" },
    { MINUSEQ, "-=" },
    { MULTEQ, "*=" },
    { DIVEQ, "/=" },
    { LSHIFTEQ, "<<=" },
    { RSHIFTEQ, ">>=" },
    { ANDEQ, "&=" },
    { OREQ, "|=" },
    { OROR, "||" },
    { ANDAND, "&&" },
    { EQ, "==" },
    { NE, "!=" },
    { LE, "<=" },
    { GE, ">=" },
    { LSHIFT, "<<" },
    { RSHIFT, ">>" },
    { ALIGN_K, "ALIGN" },
    { BLOCK, "BLOCK" },
    { QUAD, "QUAD" },
    { SQUAD, "SQUAD" },
    { LONG, "LONG" },
    { SHORT, "SHORT" },
    { BYTE, "BYTE" },
    { SECTIONS, "SECTIONS" },
    { SIZEOF_HEADERS, "SIZEOF_HEADERS" },
    { MEMORY, "MEMORY" },
    { DEFINED, "DEFINED" },
    { TARGET_K, "TARGET" },
    { SEARCH_DIR, "SEARCH_DIR" },
    { MAP, "MAP" },
    { ENTRY, "ENTRY" },
    { NEXT, "NEXT" },
    { SIZEOF, "SIZEOF" },
    { ADDR, "ADDR" },
    { LOADADDR, "LOADADDR" },
    { MAX_K, "MAX_K" },
    { REL, "relocatable" },
    { DATA_SEGMENT_ALIGN, "DATA_SEGMENT_ALIGN" },
    { DATA_SEGMENT_END, "DATA_SEGMENT_END" }
  };
  unsigned int idx;

  for (idx = 0; idx < ARRAY_SIZE (table); idx++)
    if (table[idx].code == code)
      break;

  if (infix_p)
    fputc (' ', config.map_file);

  if (idx < ARRAY_SIZE (table))
    fputs (table[idx].name, config.map_file);
  else if (code < 127)
    fputc (code, config.map_file);
  else
    fprintf (config.map_file, "<code %d>", code);

  if (infix_p)
    fputc (' ', config.map_file);
}

static void
make_abs (etree_value_type *ptr)
{
  asection *s = ptr->section->bfd_section;
  ptr->value += s->vma;
  ptr->section = abs_output_section;
}

static etree_value_type
new_abs (bfd_vma value)
{
  etree_value_type new;
  new.valid_p = TRUE;
  new.section = abs_output_section;
  new.value = value;
  return new;
}

etree_type *
exp_intop (bfd_vma value)
{
  etree_type *new = stat_alloc (sizeof (new->value));
  new->type.node_code = INT;
  new->value.value = value;
  new->value.str = NULL;
  new->type.node_class = etree_value;
  return new;
}

etree_type *
exp_bigintop (bfd_vma value, char *str)
{
  etree_type *new = stat_alloc (sizeof (new->value));
  new->type.node_code = INT;
  new->value.value = value;
  new->value.str = str;
  new->type.node_class = etree_value;
  return new;
}

/* Build an expression representing an unnamed relocatable value.  */

etree_type *
exp_relop (asection *section, bfd_vma value)
{
  etree_type *new = stat_alloc (sizeof (new->rel));
  new->type.node_code = REL;
  new->type.node_class = etree_rel;
  new->rel.section = section;
  new->rel.value = value;
  return new;
}

static etree_value_type
new_rel (bfd_vma value,
	 char *str,
	 lang_output_section_statement_type *section)
{
  etree_value_type new;
  new.valid_p = TRUE;
  new.value = value;
  new.str = str;
  new.section = section;
  return new;
}

static etree_value_type
new_rel_from_section (bfd_vma value,
		      lang_output_section_statement_type *section)
{
  etree_value_type new;
  new.valid_p = TRUE;
  new.value = value;
  new.str = NULL;
  new.section = section;

  new.value -= section->bfd_section->vma;

  return new;
}

static etree_value_type
fold_unary (etree_type *tree,
	    lang_output_section_statement_type *current_section,
	    lang_phase_type allocation_done,
	    bfd_vma dot,
	    bfd_vma *dotp)
{
  etree_value_type result;

  result = exp_fold_tree (tree->unary.child,
			  current_section,
			  allocation_done, dot, dotp);
  if (result.valid_p)
    {
      switch (tree->type.node_code)
	{
	case ALIGN_K:
	  if (allocation_done != lang_first_phase_enum)
	    result = new_rel_from_section (align_n (dot, result.value),
					   current_section);
	  else
	    result.valid_p = FALSE;
	  break;

	case ABSOLUTE:
	  if (allocation_done != lang_first_phase_enum)
	    {
	      result.value += result.section->bfd_section->vma;
	      result.section = abs_output_section;
	    }
	  else
	    result.valid_p = FALSE;
	  break;

	case '~':
	  make_abs (&result);
	  result.value = ~result.value;
	  break;

	case '!':
	  make_abs (&result);
	  result.value = !result.value;
	  break;

	case '-':
	  make_abs (&result);
	  result.value = -result.value;
	  break;

	case NEXT:
	  /* Return next place aligned to value.  */
	  if (allocation_done == lang_allocating_phase_enum)
	    {
	      make_abs (&result);
	      result.value = align_n (dot, result.value);
	    }
	  else
	    result.valid_p = FALSE;
	  break;

	case DATA_SEGMENT_END:
	  if (allocation_done != lang_first_phase_enum
	      && current_section == abs_output_section
	      && (exp_data_seg.phase == exp_dataseg_align_seen
		  || exp_data_seg.phase == exp_dataseg_adjust
		  || allocation_done != lang_allocating_phase_enum))
	    {
	      if (exp_data_seg.phase == exp_dataseg_align_seen)
		{
		  exp_data_seg.phase = exp_dataseg_end_seen;
		  exp_data_seg.end = result.value;
		}
	    }
	  else
	    result.valid_p = FALSE;
	  break;

	default:
	  FAIL ();
	  break;
	}
    }

  return result;
}

static etree_value_type
fold_binary (etree_type *tree,
	     lang_output_section_statement_type *current_section,
	     lang_phase_type allocation_done,
	     bfd_vma dot,
	     bfd_vma *dotp)
{
  etree_value_type result;

  result = exp_fold_tree (tree->binary.lhs, current_section,
			  allocation_done, dot, dotp);
  if (result.valid_p)
    {
      etree_value_type other;

      other = exp_fold_tree (tree->binary.rhs,
			     current_section,
			     allocation_done, dot, dotp);
      if (other.valid_p)
	{
	  /* If the values are from different sections, or this is an
	     absolute expression, make both the source arguments
	     absolute.  However, adding or subtracting an absolute
	     value from a relative value is meaningful, and is an
	     exception.  */
	  if (current_section != abs_output_section
	      && (other.section == abs_output_section
		  || (result.section == abs_output_section
		      && tree->type.node_code == '+'))
	      && (tree->type.node_code == '+'
		  || tree->type.node_code == '-'))
	    {
	      if (other.section != abs_output_section)
		{
		  /* Keep the section of the other term.  */
		  if (tree->type.node_code == '+')
		    other.value = result.value + other.value;
		  else
		    other.value = result.value - other.value;
		  return other;
		}
	    }
	  else if (result.section != other.section
		   || current_section == abs_output_section)
	    {
	      make_abs (&result);
	      make_abs (&other);
	    }

	  switch (tree->type.node_code)
	    {
	    case '%':
	      if (other.value == 0)
		einfo (_("%F%S %% by zero\n"));
	      result.value = ((bfd_signed_vma) result.value
			      % (bfd_signed_vma) other.value);
	      break;

	    case '/':
	      if (other.value == 0)
		einfo (_("%F%S / by zero\n"));
	      result.value = ((bfd_signed_vma) result.value
			      / (bfd_signed_vma) other.value);
	      break;

#define BOP(x,y) case x : result.value = result.value y other.value; break;
	      BOP ('+', +);
	      BOP ('*', *);
	      BOP ('-', -);
	      BOP (LSHIFT, <<);
	      BOP (RSHIFT, >>);
	      BOP (EQ, ==);
	      BOP (NE, !=);
	      BOP ('<', <);
	      BOP ('>', >);
	      BOP (LE, <=);
	      BOP (GE, >=);
	      BOP ('&', &);
	      BOP ('^', ^);
	      BOP ('|', |);
	      BOP (ANDAND, &&);
	      BOP (OROR, ||);

	    case MAX_K:
	      if (result.value < other.value)
		result = other;
	      break;

	    case MIN_K:
	      if (result.value > other.value)
		result = other;
	      break;

	    case ALIGN_K:
	      result.value = align_n (result.value, other.value);
	      break;
	      
	    case DATA_SEGMENT_ALIGN:
	      if (allocation_done != lang_first_phase_enum
		  && current_section == abs_output_section
		  && (exp_data_seg.phase == exp_dataseg_none
		      || exp_data_seg.phase == exp_dataseg_adjust
		      || allocation_done != lang_allocating_phase_enum))
		{
		  bfd_vma maxpage = result.value;

		  result.value = align_n (dot, maxpage);
		  if (exp_data_seg.phase != exp_dataseg_adjust)
		    {
		      result.value += dot & (maxpage - 1);
		      if (allocation_done == lang_allocating_phase_enum)
			{
			  exp_data_seg.phase = exp_dataseg_align_seen;
			  exp_data_seg.base = result.value;
			  exp_data_seg.pagesize = other.value;
			}
		    }
		  else if (other.value < maxpage)
		    result.value += (dot + other.value - 1)
				    & (maxpage - other.value);
		}
	      else
		result.valid_p = FALSE;
	      break;

	    default:
	      FAIL ();
	    }
	}
      else
	{
	  result.valid_p = FALSE;
	}
    }

  return result;
}

static etree_value_type
fold_trinary (etree_type *tree,
	      lang_output_section_statement_type *current_section,
	      lang_phase_type allocation_done,
	      bfd_vma dot,
	      bfd_vma *dotp)
{
  etree_value_type result;

  result = exp_fold_tree (tree->trinary.cond, current_section,
			  allocation_done, dot, dotp);
  if (result.valid_p)
    result = exp_fold_tree ((result.value
			     ? tree->trinary.lhs
			     : tree->trinary.rhs),
			    current_section,
			    allocation_done, dot, dotp);

  return result;
}

static etree_value_type
fold_name (etree_type *tree,
	   lang_output_section_statement_type *current_section,
	   lang_phase_type allocation_done,
	   bfd_vma dot)
{
  etree_value_type result;

  result.valid_p = FALSE;
  
  switch (tree->type.node_code)
    {
    case SIZEOF_HEADERS:
      if (allocation_done != lang_first_phase_enum)
	result = new_abs (bfd_sizeof_headers (output_bfd,
					      link_info.relocatable));
      break;
    case DEFINED:
      if (allocation_done == lang_first_phase_enum)
	lang_track_definedness (tree->name.name);
      else
	{
	  struct bfd_link_hash_entry *h;
	  int def_iteration
	    = lang_symbol_definition_iteration (tree->name.name);

	  h = bfd_wrapped_link_hash_lookup (output_bfd, &link_info,
					    tree->name.name,
					    FALSE, FALSE, TRUE);
	  result.value = (h != NULL
			  && (h->type == bfd_link_hash_defined
			      || h->type == bfd_link_hash_defweak
			      || h->type == bfd_link_hash_common)
			  && (def_iteration == lang_statement_iteration
			      || def_iteration == -1));
	  result.section = abs_output_section;
	  result.valid_p = TRUE;
	}
      break;
    case NAME:
      if (tree->name.name[0] == '.' && tree->name.name[1] == 0)
	{
	  if (allocation_done != lang_first_phase_enum)
	    result = new_rel_from_section (dot, current_section);
	}
      else if (allocation_done != lang_first_phase_enum)
	{
	  struct bfd_link_hash_entry *h;

	  h = bfd_wrapped_link_hash_lookup (output_bfd, &link_info,
					    tree->name.name,
					    TRUE, FALSE, TRUE);
	  if (!h)
	    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
	  else if (h->type == bfd_link_hash_defined
		   || h->type == bfd_link_hash_defweak)
	    {
	      if (bfd_is_abs_section (h->u.def.section))
		result = new_abs (h->u.def.value);
	      else if (allocation_done == lang_final_phase_enum
		       || allocation_done == lang_allocating_phase_enum)
		{
		  asection *output_section;

		  output_section = h->u.def.section->output_section;
		  if (output_section == NULL)
		    einfo (_("%X%S: unresolvable symbol `%s' referenced in expression\n"),
			   tree->name.name);
		  else
		    {
		      lang_output_section_statement_type *os;

		      os = (lang_output_section_statement_lookup
			    (bfd_get_section_name (output_bfd,
						   output_section)));

		      /* FIXME: Is this correct if this section is
			 being linked with -R?  */
		      result = new_rel ((h->u.def.value
					 + h->u.def.section->output_offset),
					NULL,
					os);
		    }
		}
	    }
	  else if (allocation_done == lang_final_phase_enum)
	    einfo (_("%F%S: undefined symbol `%s' referenced in expression\n"),
		   tree->name.name);
	  else if (h->type == bfd_link_hash_new)
	    {
	      h->type = bfd_link_hash_undefined;
	      h->u.undef.abfd = NULL;
	      bfd_link_add_undef (link_info.hash, h);
	    }
	}
      break;

    case ADDR:
      if (allocation_done != lang_first_phase_enum)
	{
	  lang_output_section_statement_type *os;

	  os = lang_output_section_find (tree->name.name);
	  if (os && os->processed > 0)
	    result = new_rel (0, NULL, os);
	}
      break;

    case LOADADDR:
      if (allocation_done != lang_first_phase_enum)
	{
	  lang_output_section_statement_type *os;

	  os = lang_output_section_find (tree->name.name);
	  if (os && os->processed != 0)
	    {
	      if (os->load_base == NULL)
		result = new_rel (0, NULL, os);
	      else
		result = exp_fold_tree_no_dot (os->load_base,
					       abs_output_section,
					       allocation_done);
	    }
	}
      break;

    case SIZEOF:
      if (allocation_done != lang_first_phase_enum)
	{
	  int opb = bfd_octets_per_byte (output_bfd);
	  lang_output_section_statement_type *os;

	  os = lang_output_section_find (tree->name.name);
	  if (os && os->processed > 0)
	    result = new_abs (os->bfd_section->_raw_size / opb);
	}
      break;

    default:
      FAIL ();
      break;
    }

  return result;
}

etree_value_type
exp_fold_tree (etree_type *tree,
	       lang_output_section_statement_type *current_section,
	       lang_phase_type allocation_done,
	       bfd_vma dot,
	       bfd_vma *dotp)
{
  etree_value_type result;

  if (tree == NULL)
    {
      result.valid_p = FALSE;
      return result;
    }

  switch (tree->type.node_class)
    {
    case etree_value:
      result = new_rel (tree->value.value, tree->value.str, current_section);
      break;

    case etree_rel:
      if (allocation_done != lang_final_phase_enum)
	result.valid_p = FALSE;
      else
	result = new_rel ((tree->rel.value
			   + tree->rel.section->output_section->vma
			   + tree->rel.section->output_offset),
			  NULL,
			  current_section);
      break;

    case etree_assert:
      result = exp_fold_tree (tree->assert_s.child,
			      current_section,
			      allocation_done, dot, dotp);
      if (result.valid_p)
	{
	  if (! result.value)
	    einfo ("%F%P: %s\n", tree->assert_s.message);
	  return result;
	}
      break;

    case etree_unary:
      result = fold_unary (tree, current_section, allocation_done,
			   dot, dotp);
      break;

    case etree_binary:
      result = fold_binary (tree, current_section, allocation_done,
			    dot, dotp);
      break;

    case etree_trinary:
      result = fold_trinary (tree, current_section, allocation_done,
			     dot, dotp);
      break;

    case etree_assign:
    case etree_provide:
    case etree_provided:
      if (tree->assign.dst[0] == '.' && tree->assign.dst[1] == 0)
	{
	  /* Assignment to dot can only be done during allocation.  */
	  if (tree->type.node_class != etree_assign)
	    einfo (_("%F%S can not PROVIDE assignment to location counter\n"));
	  if (allocation_done == lang_allocating_phase_enum
	      || (allocation_done == lang_final_phase_enum
		  && current_section == abs_output_section))
	    {
	      result = exp_fold_tree (tree->assign.src,
				      current_section,
				      allocation_done, dot,
				      dotp);
	      if (! result.valid_p)
		einfo (_("%F%S invalid assignment to location counter\n"));
	      else
		{
		  if (current_section == NULL)
		    einfo (_("%F%S assignment to location counter invalid outside of SECTION\n"));
		  else
		    {
		      bfd_vma nextdot;

		      nextdot = (result.value
				 + current_section->bfd_section->vma);
		      if (nextdot < dot
			  && current_section != abs_output_section)
			einfo (_("%F%S cannot move location counter backwards (from %V to %V)\n"),
			       dot, nextdot);
		      else
			*dotp = nextdot;
		    }
		}
	    }
	}
      else
	{
	  result = exp_fold_tree (tree->assign.src,
				  current_section, allocation_done,
				  dot, dotp);
	  if (result.valid_p)
	    {
	      bfd_boolean create;
	      struct bfd_link_hash_entry *h;

	      if (tree->type.node_class == etree_assign)
		create = TRUE;
	      else
		create = FALSE;
	      h = bfd_link_hash_lookup (link_info.hash, tree->assign.dst,
					create, FALSE, TRUE);
	      if (h == NULL)
		{
		  if (create)
		    einfo (_("%P%F:%s: hash creation failed\n"),
			   tree->assign.dst);
		}
	      else if (tree->type.node_class == etree_provide
		       && h->type != bfd_link_hash_new
		       && h->type != bfd_link_hash_undefined
		       && h->type != bfd_link_hash_common)
		{
		  /* Do nothing.  The symbol was defined by some
		     object.  */
		}
	      else
		{
		  /* FIXME: Should we worry if the symbol is already
		     defined?  */
		  lang_update_definedness (tree->assign.dst, h);
		  h->type = bfd_link_hash_defined;
		  h->u.def.value = result.value;
		  h->u.def.section = result.section->bfd_section;
		  if (tree->type.node_class == etree_provide)
		    tree->type.node_class = etree_provided;
		}
	    }
	}
      break;

    case etree_name:
      result = fold_name (tree, current_section, allocation_done, dot);
      break;

    default:
      FAIL ();
      break;
    }

  return result;
}

static etree_value_type
exp_fold_tree_no_dot (etree_type *tree,
		      lang_output_section_statement_type *current_section,
		      lang_phase_type allocation_done)
{
  return exp_fold_tree (tree, current_section, allocation_done, 0, NULL);
}

etree_type *
exp_binop (int code, etree_type *lhs, etree_type *rhs)
{
  etree_type value, *new;
  etree_value_type r;

  value.type.node_code = code;
  value.binary.lhs = lhs;
  value.binary.rhs = rhs;
  value.type.node_class = etree_binary;
  r = exp_fold_tree_no_dot (&value,
			    abs_output_section,
			    lang_first_phase_enum);
  if (r.valid_p)
    {
      return exp_intop (r.value);
    }
  new = stat_alloc (sizeof (new->binary));
  memcpy (new, &value, sizeof (new->binary));
  return new;
}

etree_type *
exp_trinop (int code, etree_type *cond, etree_type *lhs, etree_type *rhs)
{
  etree_type value, *new;
  etree_value_type r;
  value.type.node_code = code;
  value.trinary.lhs = lhs;
  value.trinary.cond = cond;
  value.trinary.rhs = rhs;
  value.type.node_class = etree_trinary;
  r = exp_fold_tree_no_dot (&value, NULL, lang_first_phase_enum);
  if (r.valid_p)
    return exp_intop (r.value);

  new = stat_alloc (sizeof (new->trinary));
  memcpy (new, &value, sizeof (new->trinary));
  return new;
}

etree_type *
exp_unop (int code, etree_type *child)
{
  etree_type value, *new;

  etree_value_type r;
  value.unary.type.node_code = code;
  value.unary.child = child;
  value.unary.type.node_class = etree_unary;
  r = exp_fold_tree_no_dot (&value, abs_output_section,
			    lang_first_phase_enum);
  if (r.valid_p)
    return exp_intop (r.value);

  new = stat_alloc (sizeof (new->unary));
  memcpy (new, &value, sizeof (new->unary));
  return new;
}

etree_type *
exp_nameop (int code, const char *name)
{
  etree_type value, *new;
  etree_value_type r;
  value.name.type.node_code = code;
  value.name.name = name;
  value.name.type.node_class = etree_name;

  r = exp_fold_tree_no_dot (&value, NULL, lang_first_phase_enum);
  if (r.valid_p)
    return exp_intop (r.value);

  new = stat_alloc (sizeof (new->name));
  memcpy (new, &value, sizeof (new->name));
  return new;

}

etree_type *
exp_assop (int code, const char *dst, etree_type *src)
{
  etree_type value, *new;

  value.assign.type.node_code = code;

  value.assign.src = src;
  value.assign.dst = dst;
  value.assign.type.node_class = etree_assign;

#if 0
  if (exp_fold_tree_no_dot (&value, &result))
    return exp_intop (result);
#endif
  new = stat_alloc (sizeof (new->assign));
  memcpy (new, &value, sizeof (new->assign));
  return new;
}

/* Handle PROVIDE.  */

etree_type *
exp_provide (const char *dst, etree_type *src)
{
  etree_type *n;

  n = stat_alloc (sizeof (n->assign));
  n->assign.type.node_code = '=';
  n->assign.type.node_class = etree_provide;
  n->assign.src = src;
  n->assign.dst = dst;
  return n;
}

/* Handle ASSERT.  */

etree_type *
exp_assert (etree_type *exp, const char *message)
{
  etree_type *n;

  n = stat_alloc (sizeof (n->assert_s));
  n->assert_s.type.node_code = '!';
  n->assert_s.type.node_class = etree_assert;
  n->assert_s.child = exp;
  n->assert_s.message = message;
  return n;
}

void
exp_print_tree (etree_type *tree)
{
  if (config.map_file == NULL)
    config.map_file = stderr;

  if (tree == NULL)
    {
      minfo ("NULL TREE\n");
      return;
    }

  switch (tree->type.node_class)
    {
    case etree_value:
      minfo ("0x%v", tree->value.value);
      return;
    case etree_rel:
      if (tree->rel.section->owner != NULL)
	minfo ("%B:", tree->rel.section->owner);
      minfo ("%s+0x%v", tree->rel.section->name, tree->rel.value);
      return;
    case etree_assign:
#if 0
      if (tree->assign.dst->sdefs != NULL)
	fprintf (config.map_file, "%s (%x) ", tree->assign.dst->name,
		 tree->assign.dst->sdefs->value);
      else
	fprintf (config.map_file, "%s (UNDEFINED)", tree->assign.dst->name);
#endif
      fprintf (config.map_file, "%s", tree->assign.dst);
      exp_print_token (tree->type.node_code, TRUE);
      exp_print_tree (tree->assign.src);
      break;
    case etree_provide:
    case etree_provided:
      fprintf (config.map_file, "PROVIDE (%s, ", tree->assign.dst);
      exp_print_tree (tree->assign.src);
      fprintf (config.map_file, ")");
      break;
    case etree_binary:
      fprintf (config.map_file, "(");
      exp_print_tree (tree->binary.lhs);
      exp_print_token (tree->type.node_code, TRUE);
      exp_print_tree (tree->binary.rhs);
      fprintf (config.map_file, ")");
      break;
    case etree_trinary:
      exp_print_tree (tree->trinary.cond);
      fprintf (config.map_file, "?");
      exp_print_tree (tree->trinary.lhs);
      fprintf (config.map_file, ":");
      exp_print_tree (tree->trinary.rhs);
      break;
    case etree_unary:
      exp_print_token (tree->unary.type.node_code, FALSE);
      if (tree->unary.child)
	{
	  fprintf (config.map_file, " (");
	  exp_print_tree (tree->unary.child);
	  fprintf (config.map_file, ")");
	}
      break;

    case etree_assert:
      fprintf (config.map_file, "ASSERT (");
      exp_print_tree (tree->assert_s.child);
      fprintf (config.map_file, ", %s)", tree->assert_s.message);
      break;

    case etree_undef:
      fprintf (config.map_file, "????????");
      break;
    case etree_name:
      if (tree->type.node_code == NAME)
	{
	  fprintf (config.map_file, "%s", tree->name.name);
	}
      else
	{
	  exp_print_token (tree->type.node_code, FALSE);
	  if (tree->name.name)
	    fprintf (config.map_file, " (%s)", tree->name.name);
	}
      break;
    default:
      FAIL ();
      break;
    }
}

bfd_vma
exp_get_vma (etree_type *tree,
	     bfd_vma def,
	     char *name,
	     lang_phase_type allocation_done)
{
  etree_value_type r;

  if (tree != NULL)
    {
      r = exp_fold_tree_no_dot (tree, abs_output_section, allocation_done);
      if (! r.valid_p && name != NULL)
	einfo (_("%F%S nonconstant expression for %s\n"), name);
      return r.value;
    }
  else
    return def;
}

int
exp_get_value_int (etree_type *tree,
		   int def,
		   char *name,
		   lang_phase_type allocation_done)
{
  return exp_get_vma (tree, def, name, allocation_done);
}

fill_type *
exp_get_fill (etree_type *tree,
	      fill_type *def,
	      char *name,
	      lang_phase_type allocation_done)
{
  fill_type *fill;
  etree_value_type r;
  size_t len;
  unsigned int val;

  if (tree == NULL)
    return def;

  r = exp_fold_tree_no_dot (tree, abs_output_section, allocation_done);
  if (! r.valid_p && name != NULL)
    einfo (_("%F%S nonconstant expression for %s\n"), name);

  if (r.str != NULL && (len = strlen (r.str)) != 0)
    {
      unsigned char *dst;
      unsigned char *s;
      fill = xmalloc ((len + 1) / 2 + sizeof (*fill) - 1);
      fill->size = (len + 1) / 2;
      dst = fill->data;
      s = r.str;
      val = 0;
      do
	{
	  unsigned int digit;

	  digit = *s++ - '0';
	  if (digit > 9)
	    digit = (digit - 'A' + '0' + 10) & 0xf;
	  val <<= 4;
	  val += digit;
	  --len;
	  if ((len & 1) == 0)
	    {
	      *dst++ = val;
	      val = 0;
	    }
	}
      while (len != 0);
    }
  else
    {
      fill = xmalloc (4 + sizeof (*fill) - 1);
      val = r.value;
      fill->data[0] = (val >> 24) & 0xff;
      fill->data[1] = (val >> 16) & 0xff;
      fill->data[2] = (val >>  8) & 0xff;
      fill->data[3] = (val >>  0) & 0xff;
      fill->size = 4;
    }
  return fill;
}

bfd_vma
exp_get_abs_int (etree_type *tree,
		 int def ATTRIBUTE_UNUSED,
		 char *name,
		 lang_phase_type allocation_done)
{
  etree_value_type res;
  res = exp_fold_tree_no_dot (tree, abs_output_section, allocation_done);

  if (res.valid_p)
    res.value += res.section->bfd_section->vma;
  else
    einfo (_("%F%S non constant expression for %s\n"), name);

  return res.value;
}

static bfd_vma
align_n (bfd_vma value, bfd_vma align)
{
  if (align <= 1)
    return value;

  value = (value + align - 1) / align;
  return value * align;
}
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2001, 2002
a43 33
static void exp_print_token
  PARAMS ((token_code_type code, int infix_p));
static void make_abs
  PARAMS ((etree_value_type *ptr));
static etree_value_type new_abs
  PARAMS ((bfd_vma value));
static void check
  PARAMS ((lang_output_section_statement_type *os, const char *name,
	   const char *op));
static etree_value_type new_rel
  PARAMS ((bfd_vma, char *, lang_output_section_statement_type *section));
static etree_value_type new_rel_from_section
  PARAMS ((bfd_vma value, lang_output_section_statement_type *section));
static etree_value_type fold_unary
  PARAMS ((etree_type *tree,
	   lang_output_section_statement_type *current_section,
	   lang_phase_type allocation_done,
	   bfd_vma dot, bfd_vma *dotp));
static etree_value_type fold_binary
  PARAMS ((etree_type *tree,
	   lang_output_section_statement_type *current_section,
	   lang_phase_type allocation_done,
	   bfd_vma dot, bfd_vma *dotp));
static etree_value_type fold_trinary
  PARAMS ((etree_type *tree,
	   lang_output_section_statement_type *current_section,
	   lang_phase_type allocation_done,
	   bfd_vma dot, bfd_vma *dotp));
static etree_value_type fold_name
  PARAMS ((etree_type *tree,
	   lang_output_section_statement_type *current_section,
	   lang_phase_type allocation_done,
	   bfd_vma dot));
d45 3
a47 3
  PARAMS ((etree_type *tree,
	   lang_output_section_statement_type *current_section,
	   lang_phase_type allocation_done));
d55 1
a55 3
exp_print_token (code, infix_p)
     token_code_type code;
     int infix_p;
d102 1
a102 1
    { REL, "relocateable" },
d127 1
a127 2
make_abs (ptr)
     etree_value_type *ptr;
d135 1
a135 2
new_abs (value)
     bfd_vma value;
a143 12
static void
check (os, name, op)
     lang_output_section_statement_type *os;
     const char *name;
     const char *op;
{
  if (os == NULL)
    einfo (_("%F%P: %s uses undefined section %s\n"), op, name);
  if (! os->processed)
    einfo (_("%F%P: %s forward reference of section %s\n"), op, name);
}

d145 1
a145 2
exp_intop (value)
     bfd_vma value;
d147 1
a147 1
  etree_type *new = (etree_type *) stat_alloc (sizeof (new->value));
d156 1
a156 3
exp_bigintop (value, str)
     bfd_vma value;
     char *str;
d158 1
a158 1
  etree_type *new = (etree_type *) stat_alloc (sizeof (new->value));
d166 1
a166 1
/* Build an expression representing an unnamed relocateable value.  */
d169 1
a169 3
exp_relop (section, value)
     asection *section;
     bfd_vma value;
d171 1
a171 1
  etree_type *new = (etree_type *) stat_alloc (sizeof (new->rel));
d180 3
a182 4
new_rel (value, str, section)
     bfd_vma value;
     char *str;
     lang_output_section_statement_type *section;
d193 2
a194 3
new_rel_from_section (value, section)
     bfd_vma value;
     lang_output_section_statement_type *section;
d208 5
a212 6
fold_unary (tree, current_section, allocation_done, dot, dotp)
     etree_type *tree;
     lang_output_section_statement_type *current_section;
     lang_phase_type allocation_done;
     bfd_vma dot;
     bfd_vma *dotp;
d294 5
a298 6
fold_binary (tree, current_section, allocation_done, dot, dotp)
     etree_type *tree;
     lang_output_section_statement_type *current_section;
     lang_phase_type allocation_done;
     bfd_vma dot;
     bfd_vma *dotp;
d386 4
d432 5
a436 6
fold_trinary (tree, current_section, allocation_done, dot, dotp)
     etree_type *tree;
     lang_output_section_statement_type *current_section;
     lang_phase_type allocation_done;
     bfd_vma dot;
     bfd_vma *dotp;
a451 8
etree_value_type
invalid ()
{
  etree_value_type new;
  new.valid_p = FALSE;
  return new;
}

d453 4
a456 5
fold_name (tree, current_section, allocation_done, dot)
     etree_type *tree;
     lang_output_section_statement_type *current_section;
     lang_phase_type allocation_done;
     bfd_vma dot;
d460 2
d466 2
a467 9
	{
	  result = new_abs ((bfd_vma)
			    bfd_sizeof_headers (output_bfd,
						link_info.relocateable));
	}
      else
	{
	  result.valid_p = FALSE;
	}
d471 1
a471 1
	result.valid_p = FALSE;
d475 2
d481 1
a481 1
	  result.value = (h != (struct bfd_link_hash_entry *) NULL
d484 4
a487 2
			      || h->type == bfd_link_hash_common));
	  result.section = 0;
a491 1
      result.valid_p = FALSE;
a495 2
	  else
	    result = invalid ();
d503 5
a507 4
					    FALSE, FALSE, TRUE);
	  if (h != NULL
	      && (h->type == bfd_link_hash_defined
		  || h->type == bfd_link_hash_defweak))
d540 6
d555 2
a556 2
	  check (os, tree->name.name, "ADDR");
	  result = new_rel (0, NULL, os);
a557 2
      else
	result = invalid ();
d566 9
a574 7
	  check (os, tree->name.name, "LOADADDR");
	  if (os->load_base == NULL)
	    result = new_rel (0, NULL, os);
	  else
	    result = exp_fold_tree_no_dot (os->load_base,
					   abs_output_section,
					   allocation_done);
a575 2
      else
	result = invalid ();
d585 2
a586 2
	  check (os, tree->name.name, "SIZEOF");
	  result = new_abs (os->bfd_section->_raw_size / opb);
a587 2
      else
	result = invalid ();
d599 5
a603 6
exp_fold_tree (tree, current_section, allocation_done, dot, dotp)
     etree_type *tree;
     lang_output_section_statement_type *current_section;
     lang_phase_type allocation_done;
     bfd_vma dot;
     bfd_vma *dotp;
d710 2
a711 2
					create, FALSE, FALSE);
	      if (h == (struct bfd_link_hash_entry *) NULL)
d713 1
a713 1
		  if (tree->type.node_class == etree_assign)
d718 1
d729 1
d753 3
a755 4
exp_fold_tree_no_dot (tree, current_section, allocation_done)
     etree_type *tree;
     lang_output_section_statement_type *current_section;
     lang_phase_type allocation_done;
d757 1
a757 2
  return exp_fold_tree (tree, current_section, allocation_done,
			(bfd_vma) 0, (bfd_vma *) NULL);
d761 1
a761 4
exp_binop (code, lhs, rhs)
     int code;
     etree_type *lhs;
     etree_type *rhs;
d777 2
a778 2
  new = (etree_type *) stat_alloc (sizeof (new->binary));
  memcpy ((char *) new, (char *) &value, sizeof (new->binary));
d783 1
a783 5
exp_trinop (code, cond, lhs, rhs)
     int code;
     etree_type *cond;
     etree_type *lhs;
     etree_type *rhs;
d792 1
a792 3
  r = exp_fold_tree_no_dot (&value,
			    (lang_output_section_statement_type *) NULL,
			    lang_first_phase_enum);
d796 2
a797 2
  new = (etree_type *) stat_alloc (sizeof (new->trinary));
  memcpy ((char *) new, (char *) &value, sizeof (new->trinary));
d802 1
a802 3
exp_unop (code, child)
     int code;
     etree_type *child;
d815 2
a816 2
  new = (etree_type *) stat_alloc (sizeof (new->unary));
  memcpy ((char *) new, (char *) &value, sizeof (new->unary));
d821 1
a821 3
exp_nameop (code, name)
     int code;
     const char *name;
d829 1
a829 3
  r = exp_fold_tree_no_dot (&value,
			    (lang_output_section_statement_type *) NULL,
			    lang_first_phase_enum);
d833 2
a834 2
  new = (etree_type *) stat_alloc (sizeof (new->name));
  memcpy ((char *) new, (char *) &value, sizeof (new->name));
d840 1
a840 4
exp_assop (code, dst, src)
     int code;
     const char *dst;
     etree_type *src;
d854 2
a855 2
  new = (etree_type *) stat_alloc (sizeof (new->assign));
  memcpy ((char *) new, (char *) &value, sizeof (new->assign));
d862 1
a862 3
exp_provide (dst, src)
     const char *dst;
     etree_type *src;
d866 1
a866 1
  n = (etree_type *) stat_alloc (sizeof (n->assign));
d877 1
a877 3
exp_assert (exp, message)
     etree_type *exp;
     const char *message;
d881 1
a881 1
  n = (etree_type *) stat_alloc (sizeof (n->assert_s));
d890 1
a890 2
exp_print_tree (tree)
     etree_type *tree;
d913 1
a913 1
      if (tree->assign.dst->sdefs != (asymbol *) NULL)
d981 4
a984 5
exp_get_vma (tree, def, name, allocation_done)
     etree_type *tree;
     bfd_vma def;
     char *name;
     lang_phase_type allocation_done;
d1000 4
a1003 5
exp_get_value_int (tree, def, name, allocation_done)
     etree_type *tree;
     int def;
     char *name;
     lang_phase_type allocation_done;
d1005 1
a1005 1
  return (int) exp_get_vma (tree, (bfd_vma) def, name, allocation_done);
d1009 4
a1012 5
exp_get_fill (tree, def, name, allocation_done)
     etree_type *tree;
     fill_type *def;
     char *name;
     lang_phase_type allocation_done;
d1030 1
a1030 1
      fill = (fill_type *) xmalloc ((len + 1) / 2 + sizeof (*fill) - 1);
d1055 1
a1055 1
      fill = (fill_type *) xmalloc (4 + sizeof (*fill) - 1);
d1067 4
a1070 5
exp_get_abs_int (tree, def, name, allocation_done)
     etree_type *tree;
     int def ATTRIBUTE_UNUSED;
     char *name;
     lang_phase_type allocation_done;
d1083 2
a1084 3
bfd_vma align_n (value, align)
     bfd_vma value;
     bfd_vma align;
@


1.5
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2001
d39 1
a39 1
#include "ldgram.h"
d41 2
d44 9
a52 5
static void exp_print_token PARAMS ((token_code_type code));
static void make_abs PARAMS ((etree_value_type *ptr));
static etree_value_type new_abs PARAMS ((bfd_vma value));
static void check PARAMS ((lang_output_section_statement_type *os,
			   const char *name, const char *op));
d54 1
a54 1
  PARAMS ((bfd_vma value, lang_output_section_statement_type *section));
d57 5
d67 5
d82 5
d88 1
a88 1
exp_print_token (code)
d90 1
d92 2
a93 1
  static CONST struct {
d95 4
a98 2
    char *name;
  } table[] = {
a99 1
    { REL, "relocateable" },
d116 1
a116 1
    { RSHIFT, ">>=" },
d119 5
a125 4
    { NEXT, "NEXT" },
    { SIZEOF, "SIZEOF" },
    { ADDR, "ADDR" },
    { LOADADDR, "LOADADDR" },
a130 5
    { QUAD, "QUAD" },
    { SQUAD, "SQUAD" },
    { LONG, "LONG" },
    { SHORT, "SHORT" },
    { BYTE, "BYTE" },
d132 8
a139 1
    { 0, (char *) NULL }
d143 16
a158 10
  for (idx = 0; table[idx].name != (char *) NULL; idx++)
    {
      if (table[idx].code == code)
	{
	  fprintf (config.map_file, "%s", table[idx].name);
	  return;
	}
    }
  /* Not in table, just print it alone */
  fprintf (config.map_file, "%c", code);
d175 1
a175 1
  new.valid_p = true;
d200 1
d203 1
d205 11
d234 1
a234 1
new_rel (value, section)
d236 1
d240 1
a240 1
  new.valid_p = true;
d242 1
d253 1
a253 1
  new.valid_p = true;
d255 1
d264 87
a382 4
	      etree_value_type hold;

	      /* If there is only one absolute term, make sure it is the
		 second one.  */
d385 6
a390 3
		  hold = result;
		  result = other;
		  other = hold;
d444 28
d478 1
a478 1
	  result.valid_p = false;
d485 22
d511 1
a511 1
  new.valid_p = false;
d523 1
d535 1
a535 1
	  result.valid_p = false;
d540 1
a540 1
	result.valid_p = false;
d547 1
a547 1
					    false, false, true);
d553 1
a553 1
	  result.valid_p = true;
d557 1
a557 1
      result.valid_p = false;
d571 1
a571 1
					    false, false, true);
d599 1
d617 1
a617 1
	  result = new_rel (0, os);
d631 1
a631 1
	    result = new_rel (0, os);
d675 1
a675 1
      result.valid_p = false;
d682 1
a682 1
      result = new_rel (tree->value.value, current_section);
d687 1
a687 1
	result.valid_p = false;
d692 1
d709 2
a710 67
      result = exp_fold_tree (tree->unary.child,
			      current_section,
			      allocation_done, dot, dotp);
      if (result.valid_p)
	{
	  switch (tree->type.node_code)
	    {
	    case ALIGN_K:
	      if (allocation_done != lang_first_phase_enum)
		result = new_rel_from_section (ALIGN_N (dot, result.value),
					       current_section);
	      else
		result.valid_p = false;
	      break;

	    case ABSOLUTE:
	      if (allocation_done != lang_first_phase_enum && result.valid_p)
		{
		  result.value += result.section->bfd_section->vma;
		  result.section = abs_output_section;
		}
	      else
		result.valid_p = false;
	      break;

	    case '~':
	      make_abs (&result);
	      result.value = ~result.value;
	      break;

	    case '!':
	      make_abs (&result);
	      result.value = !result.value;
	      break;

	    case '-':
	      make_abs (&result);
	      result.value = -result.value;
	      break;

	    case NEXT:
	      /* Return next place aligned to value.  */
	      if (allocation_done == lang_allocating_phase_enum)
		{
		  make_abs (&result);
		  result.value = ALIGN_N (dot, result.value);
		}
	      else
		result.valid_p = false;
	      break;

	    default:
	      FAIL ();
	      break;
	    }
	}
      break;

    case etree_trinary:
      result = exp_fold_tree (tree->trinary.cond, current_section,
			      allocation_done, dot, dotp);
      if (result.valid_p)
	result = exp_fold_tree ((result.value
				 ? tree->trinary.lhs
				 : tree->trinary.rhs),
				current_section,
				allocation_done, dot, dotp);
d718 5
d728 1
a728 1
	  /* Assignment to dot can only be done during allocation */
d737 1
a737 1
				      lang_allocating_phase_enum, dot,
d753 2
a754 4
			{
			  einfo (_("%F%S cannot move location counter backwards (from %V to %V)\n"),
				 dot, nextdot);
			}
d768 1
a768 1
	      boolean create;
d772 1
a772 1
		create = true;
d774 1
a774 1
		create = false;
d776 1
a776 1
					create, false, false);
d869 2
a870 3
    {
      return exp_intop (r.value);
    }
d890 2
a891 3
    {
      return exp_intop (r.value);
    }
d900 1
a900 1
     CONST char *name;
d912 2
a913 3
    {
      return exp_intop (r.value);
    }
d923 1
a923 1
     CONST char *dst;
d936 1
a936 3
    {
      return exp_intop (result);
    }
d981 9
d1003 2
a1004 4
	{
	  fprintf (config.map_file, "%s (%x) ", tree->assign.dst->name,
		   tree->assign.dst->sdefs->value);
	}
d1006 1
a1006 3
	{
	  fprintf (config.map_file, "%s (UNDEFINED)", tree->assign.dst->name);
	}
d1009 1
a1009 1
      exp_print_token (tree->type.node_code);
d1021 1
a1021 1
      exp_print_token (tree->type.node_code);
d1033 1
a1033 1
      exp_print_token (tree->unary.type.node_code);
d1036 1
a1036 1
	  fprintf (config.map_file, "(");
d1058 1
a1058 1
	  exp_print_token (tree->type.node_code);
d1060 1
a1060 1
	    fprintf (config.map_file, "(%s)", tree->name.name);
d1099 59
d1169 1
a1169 3
    {
      res.value += res.section->bfd_section->vma;
    }
d1171 2
a1172 3
    {
      einfo (_("%F%S non constant expression for %s\n"), name);
    }
d1174 11
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 1999
d5 1
a5 1
   Written by Steve Chamberlain of Cygnus Support (sac@@cygnus.com).
d24 1
a24 8
/*
This module is in charge of working out the contents of expressions.

It has to keep track of the relative/absness of a symbol etc. This is
done by keeping all values in a struct (an etree_value_type) which
contains a value, a section to which it is relative and a valid bit.

*/
d26 4
d70 44
a113 46
  static CONST struct
    {
      token_code_type code;
      char *name;
    } table[] =
      {
	{ INT,	"int" },
	{ REL, "relocateable" },
	{ NAME,"NAME" },
	{ PLUSEQ,"+=" },
	{ MINUSEQ,"-=" },
	{ MULTEQ,"*=" },
	{ DIVEQ,"/=" },
	{ LSHIFTEQ,"<<=" },
	{ RSHIFTEQ,">>=" },
	{ ANDEQ,"&=" },
	{ OREQ,"|=" },
	{ OROR,"||" },
	{ ANDAND,"&&" },
	{ EQ,"==" },
	{ NE,"!=" },
	{ LE,"<=" },
	{ GE,">=" },
	{ LSHIFT,"<<" },
	{ RSHIFT,">>=" },
	{ ALIGN_K,"ALIGN" },
	{ BLOCK,"BLOCK" },
	{ SECTIONS,"SECTIONS" },
	{ SIZEOF_HEADERS,"SIZEOF_HEADERS" },
	{ NEXT,"NEXT" },
	{ SIZEOF,"SIZEOF" },
	{ ADDR,"ADDR" },
	{ LOADADDR,"LOADADDR" },
	{ MEMORY,"MEMORY" },
	{ DEFINED,"DEFINED" },
	{ TARGET_K,"TARGET" },
	{ SEARCH_DIR,"SEARCH_DIR" },
	{ MAP,"MAP" },
	{ QUAD,"QUAD" },
	{ SQUAD,"SQUAD" },
	{ LONG,"LONG" },
	{ SHORT,"SHORT" },
	{ BYTE,"BYTE" },
	{ ENTRY,"ENTRY" },
	{ 0,(char *)NULL }
      };
d116 7
a122 4
  for (idx = 0; table[idx].name != (char*)NULL; idx++) {
    if (table[idx].code == code) {
      fprintf(config.map_file, "%s", table[idx].name);
      return;
a123 1
  }
d125 1
a125 1
  fprintf(config.map_file, "%c",code);
d128 1
a128 1
static void 
d132 3
a134 3
    asection *s = ptr->section->bfd_section;
    ptr->value += s->vma;
    ptr->section = abs_output_section;
d148 1
a148 1
static void 
d164 1
a164 1
  etree_type *new = (etree_type *) stat_alloc(sizeof(new->value));
d209 1
a209 1
    new.value -= section->bfd_section->vma;
d214 1
a214 1
static etree_value_type 
d232 1
a232 1
			     allocation_done, dot,dotp) ;
d261 2
a262 2
	      make_abs(&result);
	      make_abs(&other);
d265 1
a265 1
	  switch (tree->type.node_code) 
d282 16
a297 16
	      BOP('+',+);
	      BOP('*',*);
	      BOP('-',-);
	      BOP(LSHIFT,<<);
	      BOP(RSHIFT,>>);
	      BOP(EQ,==);
	      BOP(NE,!=);
	      BOP('<',<);
	      BOP('>',>);
	      BOP(LE,<=);
	      BOP(GE,>=);
	      BOP('&',&);
	      BOP('^',^);
	      BOP('|',|);
	      BOP(ANDAND,&&);
	      BOP(OROR,||);
d310 1
a310 1
	      FAIL();
d322 1
a322 1
etree_value_type 
d330 1
a330 1
static etree_value_type 
d334 1
a334 1
     lang_phase_type  allocation_done;
d338 11
a348 16
  switch (tree->type.node_code) 
      {
      case SIZEOF_HEADERS:
	if (allocation_done != lang_first_phase_enum) 
	  {
	    result = new_abs ((bfd_vma)
			      bfd_sizeof_headers (output_bfd,
						  link_info.relocateable));
	  }
	else
	  {
	    result.valid_p = false;
	  }
	break;
      case DEFINED:
	if (allocation_done == lang_first_phase_enum)
d350 4
a353 16
	else
	  {
	    struct bfd_link_hash_entry *h;

	    h = bfd_wrapped_link_hash_lookup (output_bfd, &link_info,
					      tree->name.name,
					      false, false, true);
	    result.value = (h != (struct bfd_link_hash_entry *) NULL
			    && (h->type == bfd_link_hash_defined
				|| h->type == bfd_link_hash_defweak
				|| h->type == bfd_link_hash_common));
	    result.section = 0;
	    result.valid_p = true;
	  }
	break;
      case NAME:
d355 41
a395 55
	if (tree->name.name[0] == '.' && tree->name.name[1] == 0)
	  {
	    if (allocation_done != lang_first_phase_enum)
	      result = new_rel_from_section(dot, current_section);
	    else
	      result = invalid();
	  }
	else if (allocation_done != lang_first_phase_enum)
	  {
	    struct bfd_link_hash_entry *h;

	    h = bfd_wrapped_link_hash_lookup (output_bfd, &link_info,
					      tree->name.name,
					      false, false, true);
	    if (h != NULL
		&& (h->type == bfd_link_hash_defined
		    || h->type == bfd_link_hash_defweak))
	      {
		if (bfd_is_abs_section (h->u.def.section))
		  result = new_abs (h->u.def.value);
		else if (allocation_done == lang_final_phase_enum
			 || allocation_done == lang_allocating_phase_enum)
		  {
		    asection *output_section;

		    output_section = h->u.def.section->output_section;
		    if (output_section == NULL)
		      einfo (_("%X%S: unresolvable symbol `%s' referenced in expression\n"),
			     tree->name.name);
		    else
		      {
			lang_output_section_statement_type *os;

			os = (lang_output_section_statement_lookup
			      (bfd_get_section_name (output_bfd,
						     output_section)));

			/* FIXME: Is this correct if this section is
			   being linked with -R?  */
			result = new_rel ((h->u.def.value
					   + h->u.def.section->output_offset),
					  os);
		      }
		  }
	      }
	    else if (allocation_done == lang_final_phase_enum)
	      einfo (_("%F%S: undefined symbol `%s' referenced in expression\n"),
		     tree->name.name);
	  }
	break;

      case ADDR:
	if (allocation_done != lang_first_phase_enum)
	  {
	    lang_output_section_statement_type *os;
d397 47
a443 2
	    os = lang_output_section_find (tree->name.name);
	    check (os, tree->name.name, "ADDR");
d445 27
a471 41
	  }
	else
	  result = invalid ();
	break;

      case LOADADDR:
	if (allocation_done != lang_first_phase_enum)
	  {
	    lang_output_section_statement_type *os;

	    os = lang_output_section_find (tree->name.name);
	    check (os, tree->name.name, "LOADADDR");
	    if (os->load_base == NULL)
	      result = new_rel (0, os);
	    else
	      result = exp_fold_tree_no_dot (os->load_base,
					     abs_output_section,
					     allocation_done);
	  }
	else
	  result = invalid ();
	break;

      case SIZEOF:
	if (allocation_done != lang_first_phase_enum)
	  {
            int opb = bfd_octets_per_byte (output_bfd);
	    lang_output_section_statement_type *os;

	    os = lang_output_section_find (tree->name.name);
	    check (os, tree->name.name, "SIZEOF");
	    result = new_abs (os->bfd_section->_raw_size / opb);
	  }
	else
	  result = invalid ();
	break;

      default:
	FAIL();
	break;
      }
d475 2
a476 1
etree_value_type 
d480 1
a480 1
     lang_phase_type  allocation_done;
d492 1
a492 1
  switch (tree->type.node_class) 
d510 2
a511 2
                              current_section,
                              allocation_done, dot, dotp);
d526 1
a526 1
	  switch (tree->type.node_code) 
d542 1
a542 1
	      else 
d597 1
d601 1
a601 1
	  if (tree->type.node_class == etree_provide)
d630 1
a630 1
			*dotp = nextdot; 
d671 2
d690 1
a690 1
static etree_value_type 
d696 2
a697 2
return exp_fold_tree(tree, current_section, allocation_done, (bfd_vma)
		     0, (bfd_vma *)NULL);
d713 3
a715 3
  r = exp_fold_tree_no_dot(&value,
			   abs_output_section,
			   lang_first_phase_enum );
d718 1
a718 1
      return exp_intop(r.value);
d721 1
a721 1
  memcpy((char *)new, (char *)&value, sizeof(new->binary));
d739 7
a745 5
  r= exp_fold_tree_no_dot(&value,  (lang_output_section_statement_type
				    *)NULL,lang_first_phase_enum);
  if (r.valid_p) {
    return exp_intop(r.value);
  }
d747 1
a747 1
  memcpy((char *)new,(char *) &value, sizeof(new->trinary));
a750 1

d762 6
a767 5
  r = exp_fold_tree_no_dot(&value,abs_output_section,
			   lang_first_phase_enum);
  if (r.valid_p) {
    return exp_intop(r.value);
  }
d769 1
a769 1
  memcpy((char *)new, (char *)&value, sizeof(new->unary));
a772 1

d784 7
a790 7

  r = exp_fold_tree_no_dot(&value,
			   (lang_output_section_statement_type *)NULL,
			   lang_first_phase_enum);
  if (r.valid_p) {
    return exp_intop(r.value);
  }
d792 1
a792 1
  memcpy((char *)new, (char *)&value, sizeof(new->name));
a796 3



a806 1

d812 4
a815 3
  if (exp_fold_tree_no_dot(&value, &result)) {
    return exp_intop(result);
  }
d817 2
a818 2
  new = (etree_type*) stat_alloc (sizeof (new->assign));
  memcpy((char *)new, (char *)&value, sizeof(new->assign));
d856 1
a856 1
void 
d860 11
a870 10
  switch (tree->type.node_class) {
  case etree_value:
    minfo ("0x%v", tree->value.value);
    return;
  case etree_rel:
    if (tree->rel.section->owner != NULL)
      minfo ("%B:", tree->rel.section->owner);
    minfo ("%s+0x%v", tree->rel.section->name, tree->rel.value);
    return;
  case etree_assign:
d872 68
a939 3
    if (tree->assign.dst->sdefs != (asymbol *)NULL){
      fprintf(config.map_file,"%s (%x) ",tree->assign.dst->name,
	      tree->assign.dst->sdefs->value);
a940 61
    else {
      fprintf(config.map_file,"%s (UNDEFINED)",tree->assign.dst->name);
    }
#endif
    fprintf(config.map_file,"%s",tree->assign.dst);
    exp_print_token(tree->type.node_code);
    exp_print_tree(tree->assign.src);
    break;
  case etree_provide:
    fprintf (config.map_file, "PROVIDE (%s, ", tree->assign.dst);
    exp_print_tree (tree->assign.src);
    fprintf (config.map_file, ")");
    break;
  case etree_binary:
    fprintf(config.map_file,"(");
    exp_print_tree(tree->binary.lhs);
    exp_print_token(tree->type.node_code);
    exp_print_tree(tree->binary.rhs);
    fprintf(config.map_file,")");
    break;
  case etree_trinary:
    exp_print_tree(tree->trinary.cond);
    fprintf(config.map_file,"?");
    exp_print_tree(tree->trinary.lhs);
    fprintf(config.map_file,":");
    exp_print_tree(tree->trinary.rhs);
    break;
  case etree_unary:
    exp_print_token(tree->unary.type.node_code);
    if (tree->unary.child) 
    {
    fprintf(config.map_file,"(");
    exp_print_tree(tree->unary.child);
    fprintf(config.map_file,")");
  }
    
    break;

  case etree_assert:
    fprintf (config.map_file, "ASSERT (");
    exp_print_tree (tree->assert_s.child);
    fprintf (config.map_file, ", %s)", tree->assert_s.message);
    break;

  case etree_undef:
    fprintf(config.map_file,"????????");
    break;
  case etree_name:
    if (tree->type.node_code == NAME) {
      fprintf(config.map_file,"%s", tree->name.name);
    }
    else {
      exp_print_token(tree->type.node_code);
      if (tree->name.name)
      fprintf(config.map_file,"(%s)", tree->name.name);
    }
    break;
  default:
    FAIL();
    break;
  }
d963 2
a964 2
int 
exp_get_value_int (tree,def,name, allocation_done)
d970 1
a970 1
  return (int)exp_get_vma(tree,(bfd_vma)def,name, allocation_done);
a972 1

d987 4
a990 3
  else {
    einfo (_("%F%S non constant expression for %s\n"),name);
  }
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2 3
a4 2
Copyright (C) 1991, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
Written by Steve Chamberlain of Cygnus Support (sac@@cygnus.com).
d19 3
a21 2
along with GLD; see the file COPYING.  If not, write to
the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d111 1
d144 1
a144 1
  new.valid = true;
d157 1
a157 1
    einfo ("%F%P: %s uses undefined section %s\n", op, name);
d159 1
a159 1
    einfo ("%F%P: %s forward reference of section %s\n", op, name);
d195 1
a195 1
  new.valid = true;
d207 1
a207 1
  new.valid = true;
d228 1
a228 1
  if (result.valid)
d235 1
a235 1
      if (other.valid)
d271 1
a271 1
		einfo ("%F%S %% by zero\n");
d278 1
a278 1
		einfo ("%F%S / by zero\n");
d301 1
a301 1
	    case MAX:
d306 1
a306 1
	    case MIN:
d317 1
a317 1
	  result.valid = false;
d328 1
a328 1
  new.valid = false;
d351 1
a351 1
	    result.valid = false;
d356 1
a356 1
	  result.valid = false;
d369 1
a369 1
	    result.valid = true;
d373 1
a373 1
	result.valid = false;
d397 20
a416 10
		    lang_output_section_statement_type *os;
		
		    os = (lang_output_section_statement_lookup
			  (h->u.def.section->output_section->name));

		    /* FIXME: Is this correct if this section is being
		       linked with -R?  */
		    result = new_rel ((h->u.def.value
				       + h->u.def.section->output_offset),
				      os);
d420 1
a420 1
	      einfo ("%F%S: undefined symbol `%s' referenced in expression\n",
d459 1
d464 1
a464 1
	    result = new_abs (os->bfd_section->_raw_size);
d489 1
a489 1
      result.valid = false;
d501 1
a501 1
	result.valid = false;
d509 12
d525 1
a525 1
      if (result.valid)
d534 1
a534 1
		result.valid = false;
d538 1
a538 1
	      if (allocation_done != lang_first_phase_enum && result.valid)
d544 1
a544 1
		result.valid = false;
d570 1
a570 1
		result.valid = false;
d583 1
a583 1
      if (result.valid)
d602 1
a602 1
	    einfo ("%F%S can not PROVIDE assignment to location counter\n");
d611 2
a612 2
	      if (! result.valid)
		einfo ("%F%S invalid assignment to location counter\n");
d616 1
a616 1
		    einfo ("%F%S assignment to location counter invalid outside of SECTION\n");
d626 1
a626 1
			  einfo ("%F%S cannot move location counter backwards (from %V to %V)\n",
d640 1
a640 1
	  if (result.valid)
d654 1
a654 1
		    einfo ("%P%F:%s: hash creation failed\n",
d714 1
a714 1
  if (r.valid)
d739 1
a739 1
  if (r.valid) {
d761 1
a761 1
  if (r.valid) {
d785 1
a785 1
  if (r.valid) {
d839 17
a905 1
      
d912 7
d950 2
a951 2
      if (! r.valid && name != NULL)
	einfo ("%F%S nonconstant expression for %s\n", name);
d972 1
a972 1
     int def;
d979 1
a979 1
  if (res.valid)
d984 1
a984 1
    einfo ("%F%S non constant expression for %s\n",name);
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d102 1
d150 2
a151 2
     CONST char *name;
     CONST char *op;
d153 4
a156 6
  if (os == (lang_output_section_statement_type *)NULL) {
    einfo("%F%P: %s uses undefined section %s\n", op, name);
  }
  if (os->processed == false) {
    einfo("%F%P: %s forward reference of section %s\n",op, name);
  }
d298 10
d413 11
d425 16
a440 9
	if (allocation_done != lang_first_phase_enum) {
	  lang_output_section_statement_type *os =
	    lang_output_section_find(tree->name.name);
	  check(os,tree->name.name,"ADDR");
	  result =    new_rel((bfd_vma)0,  os);
	}
	else {
	  result = invalid();
	}
d442 1
d444 10
a453 9
	if(allocation_done != lang_first_phase_enum) {
	  lang_output_section_statement_type *os = 
	    lang_output_section_find(tree->name.name);
	  check(os,tree->name.name,"SIZEOF");
	  result = new_abs((bfd_vma)(os->bfd_section->_raw_size));
	}
	else {
	  result = invalid();
	}
d473 7
a479 5
  if (tree == (etree_type *)NULL) {
    result.valid = false;
  }
  else {
    switch (tree->type.node_class) 
d481 2
a482 2
     case etree_value:
      result = new_rel(tree->value.value, current_section);
d484 1
d494 6
a499 7
     case etree_unary:
      result = exp_fold_tree(tree->unary.child,
			     current_section,
			     allocation_done, dot, dotp);
      if (result.valid == true)
      {
	switch(tree->type.node_code) 
d501 45
a545 5
	 case ALIGN_K:
	  if (allocation_done != lang_first_phase_enum) {
	    result = new_rel_from_section(ALIGN_N(dot,
						result.value) ,
					  current_section);
d547 3
a549 10
	  }
	  else {
	    result.valid = false;
	  }
	  break;
	 case ABSOLUTE:
	  if (allocation_done != lang_first_phase_enum && result.valid)
	    {
	      result.value += result.section->bfd_section->vma;
	      result.section = abs_output_section;
a550 29
	  else 
	    {
	      result.valid = false;
	    }
	  break;
	 case '~':
	  make_abs(&result);
	  result.value = ~result.value;
	  break;
	 case '!':
	  make_abs(&result);
	  result.value = !result.value;
	  break;
	 case '-':
	  make_abs(&result);
	  result.value = -result.value;
	  break;
	 case NEXT:
	  if (allocation_done ==lang_allocating_phase_enum) {
	    make_abs(&result);
	    result.value = ALIGN_N(dot, result.value);
	  }
	  else {
	    /* Return next place aligned to value */
	    result.valid = false;
	  }
	  break;
	 default:
	  FAIL();
d552 1
a552 1
      }
d554 9
a563 1
     case etree_trinary:
d565 4
a568 9
      result = exp_fold_tree(tree->trinary.cond,
			     current_section,
			     allocation_done, dot, dotp);
      if (result.valid) {
	result = exp_fold_tree(result.value ?
			       tree->trinary.lhs:tree->trinary.rhs,
			       current_section,
			       allocation_done, dot, dotp);
      }
d570 37
a606 24
      break;
     case etree_binary:
      result = fold_binary(tree, current_section, allocation_done,
			   dot, dotp);
      break;
     case etree_assign:
     case etree_provide:
      if (tree->assign.dst[0] == '.' && tree->assign.dst[1] == 0) {
	/* Assignment to dot can only be done during allocation */
	if (tree->type.node_class == etree_provide)
	  einfo ("%F%S can not PROVIDE assignment to location counter\n");
	if (allocation_done == lang_allocating_phase_enum
	    || (allocation_done == lang_final_phase_enum
		&& current_section == abs_output_section)) {
	  result = exp_fold_tree(tree->assign.src,
				 current_section,
				 lang_allocating_phase_enum, dot, dotp);
	  if (result.valid == false) {
	    einfo("%F%S invalid assignment to location counter\n");
	  }
	  else {
	    if (current_section ==
		(lang_output_section_statement_type  *)NULL) {
	      einfo("%F%S assignment to location counter invalid outside of SECTION\n");
a607 11
	    else {
	      bfd_vma nextdot =result.value +
	       current_section->bfd_section->vma;
	      if (nextdot < dot && current_section != abs_output_section) {
		einfo("%F%S cannot move location counter backwards (from %V to %V)\n", dot, nextdot);
	      }
	      else {
		*dotp = nextdot; 
	      }
	    }
	  }
a608 1
      }
d616 1
d619 4
d624 1
a624 3
					(tree->type.node_class == etree_assign
					 ? true : false),
					false, false);
d636 1
a636 1
                     object.  */
d647 1
a647 1
	}  
d649 3
a651 2
     case etree_name:
      result = fold_name(tree, current_section, allocation_done, dot);
a652 2
     default:
      einfo("%F%S need more of these %d\n",tree->type.node_class );
d654 3
a657 1
  }
a661 1

a888 3



d892 1
a892 1
      bfd_vma def;
d898 6
a903 6
  if (tree != (etree_type *)NULL) {
    r = exp_fold_tree_no_dot(tree,
		 abs_output_section,
		      allocation_done);
    if (r.valid == false && name) {
      einfo("%F%S nonconstant expression for %s\n",name);
d905 1
a905 3
    return r.value;
  }
  else {
a906 1
  }
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
Copyright (C) 1991, 1993, 1994, 1995 Free Software Foundation, Inc.
d241 3
a243 2
	      && (result.section == abs_output_section
		  || other.section == abs_output_section)
d251 1
a251 1
	      if (result.section == abs_output_section)
d349 3
a351 2
	    h = bfd_link_hash_lookup (link_info.hash, tree->name.name,
				      false, false, true);
d373 3
a375 2
	    h = bfd_link_hash_lookup (link_info.hash, tree->name.name,
				      false, false, true);
d382 2
a383 1
		else if (allocation_done == lang_final_phase_enum)
d482 1
a482 4
	  if (allocation_done != lang_first_phase_enum) 
	  {
	    if (current_section 
		== (lang_output_section_statement_type*)NULL) 
d484 1
a484 7
	      /* Outside a section, so it's all ok */

	    }
	    else {
	      /* Inside a section, subtract the base of the section,
		 so when it's added again (in an assignment), everything comes out fine
		 */
a485 2
	      result.value -= current_section->bfd_section->vma;
	      result.valid = true;
a486 1
	  }
d488 3
a490 4
	  {
	    result.valid = false;
	  }

d543 3
a545 1
	if (allocation_done == lang_allocating_phase_enum) {
d777 1
a777 1
    print_address(tree->value.value);
d781 2
a782 4
      fprintf (config.map_file, "%s:",
	       bfd_get_filename (tree->rel.section->owner));
    fprintf (config.map_file, "%s+", tree->rel.section->name);
    print_address (tree->rel.value);
d794 1
a794 1
    fprintf(config.map_file,"%s ",tree->assign.dst);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 1
a2 1
Copyright (C) 1991, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
d241 2
a242 3
	      && (other.section == abs_output_section
		  || (result.section == abs_output_section
		      && tree->type.node_code == '+'))
d250 1
a250 1
	      if (other.section != abs_output_section)
d348 2
a349 3
	    h = bfd_wrapped_link_hash_lookup (output_bfd, &link_info,
					      tree->name.name,
					      false, false, true);
d371 2
a372 3
	    h = bfd_wrapped_link_hash_lookup (output_bfd, &link_info,
					      tree->name.name,
					      false, false, true);
d379 1
a379 2
		else if (allocation_done == lang_final_phase_enum
			 || allocation_done == lang_allocating_phase_enum)
d478 4
a481 1
	  if (allocation_done != lang_first_phase_enum && result.valid)
d483 7
a489 1
	      result.value += result.section->bfd_section->vma;
d491 2
d494 1
d496 4
a499 3
	    {
	      result.valid = false;
	    }
d552 1
a552 3
	if (allocation_done == lang_allocating_phase_enum
	    || (allocation_done == lang_final_phase_enum
		&& current_section == abs_output_section)) {
d784 1
a784 1
    minfo ("0x%v", tree->value.value);
d788 4
a791 2
      minfo ("%B:", tree->rel.section->owner);
    minfo ("%s+0x%v", tree->rel.section->name, tree->rel.value);
d803 1
a803 1
    fprintf(config.map_file,"%s",tree->assign.dst);
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a101 1
	{ LOADADDR,"LOADADDR" },
d149 2
a150 2
     const char *name;
     const char *op;
d152 6
a157 4
  if (os == NULL)
    einfo ("%F%P: %s uses undefined section %s\n", op, name);
  if (! os->processed)
    einfo ("%F%P: %s forward reference of section %s\n", op, name);
a298 10
	    case MAX:
	      if (result.value < other.value)
		result = other;
	      break;

	    case MIN:
	      if (result.value > other.value)
		result = other;
	      break;

a403 3
	if (allocation_done != lang_first_phase_enum)
	  {
	    lang_output_section_statement_type *os;
d405 9
a413 6
	    os = lang_output_section_find (tree->name.name);
	    check (os, tree->name.name, "ADDR");
	    result = new_rel (0, os);
	  }
	else
	  result = invalid ();
a414 19

      case LOADADDR:
	if (allocation_done != lang_first_phase_enum)
	  {
	    lang_output_section_statement_type *os;

	    os = lang_output_section_find (tree->name.name);
	    check (os, tree->name.name, "LOADADDR");
	    if (os->load_base == NULL)
	      result = new_rel (0, os);
	    else
	      result = exp_fold_tree_no_dot (os->load_base,
					     abs_output_section,
					     allocation_done);
	  }
	else
	  result = invalid ();
	break;

d416 9
a424 10
	if (allocation_done != lang_first_phase_enum)
	  {
	    lang_output_section_statement_type *os;

	    os = lang_output_section_find (tree->name.name);
	    check (os, tree->name.name, "SIZEOF");
	    result = new_abs (os->bfd_section->_raw_size);
	  }
	else
	  result = invalid ();
d444 5
a448 7
  if (tree == NULL)
    {
      result.valid = false;
      return result;
    }

  switch (tree->type.node_class) 
d450 2
a451 2
    case etree_value:
      result = new_rel (tree->value.value, current_section);
a452 1

d462 13
d476 12
a487 7
    case etree_unary:
      result = exp_fold_tree (tree->unary.child,
			      current_section,
			      allocation_done, dot, dotp);
      if (result.valid)
	{
	  switch (tree->type.node_code) 
d489 1
a489 47
	    case ALIGN_K:
	      if (allocation_done != lang_first_phase_enum)
		result = new_rel_from_section (ALIGN_N (dot, result.value),
					       current_section);
	      else
		result.valid = false;
	      break;

	    case ABSOLUTE:
	      if (allocation_done != lang_first_phase_enum && result.valid)
		{
		  result.value += result.section->bfd_section->vma;
		  result.section = abs_output_section;
		}
	      else 
		result.valid = false;
	      break;

	    case '~':
	      make_abs (&result);
	      result.value = ~result.value;
	      break;

	    case '!':
	      make_abs (&result);
	      result.value = !result.value;
	      break;

	    case '-':
	      make_abs (&result);
	      result.value = -result.value;
	      break;

	    case NEXT:
	      /* Return next place aligned to value.  */
	      if (allocation_done == lang_allocating_phase_enum)
		{
		  make_abs (&result);
		  result.value = ALIGN_N (dot, result.value);
		}
	      else
		result.valid = false;
	      break;

	    default:
	      FAIL ();
	      break;
d491 25
d517 2
d520 11
a531 9
    case etree_trinary:
      result = exp_fold_tree (tree->trinary.cond, current_section,
			      allocation_done, dot, dotp);
      if (result.valid)
	result = exp_fold_tree ((result.value
				 ? tree->trinary.lhs
				 : tree->trinary.rhs),
				current_section,
				allocation_done, dot, dotp);
d533 3
a535 4

    case etree_binary:
      result = fold_binary (tree, current_section, allocation_done,
			    dot, dotp);
d537 29
a565 38

    case etree_assign:
    case etree_provide:
      if (tree->assign.dst[0] == '.' && tree->assign.dst[1] == 0)
	{
	  /* Assignment to dot can only be done during allocation */
	  if (tree->type.node_class == etree_provide)
	    einfo ("%F%S can not PROVIDE assignment to location counter\n");
	  if (allocation_done == lang_allocating_phase_enum
	      || (allocation_done == lang_final_phase_enum
		  && current_section == abs_output_section))
	    {
	      result = exp_fold_tree (tree->assign.src,
				      current_section,
				      lang_allocating_phase_enum, dot,
				      dotp);
	      if (! result.valid)
		einfo ("%F%S invalid assignment to location counter\n");
	      else
		{
		  if (current_section == NULL)
		    einfo ("%F%S assignment to location counter invalid outside of SECTION\n");
		  else
		    {
		      bfd_vma nextdot;

		      nextdot = (result.value
				 + current_section->bfd_section->vma);
		      if (nextdot < dot
			  && current_section != abs_output_section)
			{
			  einfo ("%F%S cannot move location counter backwards (from %V to %V)\n",
				 dot, nextdot);
			}
		      else
			*dotp = nextdot; 
		    }
		}
d567 1
d569 1
a576 1
	      boolean create;
a578 4
	      if (tree->type.node_class == etree_assign)
		create = true;
	      else
		create = false;
d580 3
a582 1
					create, false, false);
d594 1
a594 1
		     object.  */
d605 1
a605 1
	}
d607 2
a608 3

    case etree_name:
      result = fold_name (tree, current_section, allocation_done, dot);
d610 2
a612 3
    default:
      FAIL ();
      break;
d614 1
d619 1
d847 3
d853 1
a853 1
     bfd_vma def;
d859 6
a864 6
  if (tree != NULL)
    {
      r = exp_fold_tree_no_dot (tree, abs_output_section, allocation_done);
      if (! r.valid && name != NULL)
	einfo ("%F%S nonconstant expression for %s\n", name);
      return r.value;
d866 3
a868 1
  else
d870 1
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 2
a3 3
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 1999
   Free Software Foundation, Inc.
   Written by Steve Chamberlain of Cygnus Support (sac@@cygnus.com).
d18 2
a19 3
along with GLD; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
a108 1
	{ SQUAD,"SQUAD" },
d141 1
a141 1
  new.valid_p = true;
d154 1
a154 1
    einfo (_("%F%P: %s uses undefined section %s\n"), op, name);
d156 1
a156 1
    einfo (_("%F%P: %s forward reference of section %s\n"), op, name);
d192 1
a192 1
  new.valid_p = true;
d204 1
a204 1
  new.valid_p = true;
d225 1
a225 1
  if (result.valid_p)
d232 1
a232 1
      if (other.valid_p)
d268 1
a268 1
		einfo (_("%F%S %% by zero\n"));
d275 1
a275 1
		einfo (_("%F%S / by zero\n"));
d298 1
a298 1
	    case MAX_K:
d303 1
a303 1
	    case MIN_K:
d314 1
a314 1
	  result.valid_p = false;
d325 1
a325 1
  new.valid_p = false;
d348 1
a348 1
	    result.valid_p = false;
d353 1
a353 1
	  result.valid_p = false;
d366 1
a366 1
	    result.valid_p = true;
d370 1
a370 1
	result.valid_p = false;
d394 10
a403 20
		    asection *output_section;

		    output_section = h->u.def.section->output_section;
		    if (output_section == NULL)
		      einfo (_("%X%S: unresolvable symbol `%s' referenced in expression\n"),
			     tree->name.name);
		    else
		      {
			lang_output_section_statement_type *os;

			os = (lang_output_section_statement_lookup
			      (bfd_get_section_name (output_bfd,
						     output_section)));

			/* FIXME: Is this correct if this section is
			   being linked with -R?  */
			result = new_rel ((h->u.def.value
					   + h->u.def.section->output_offset),
					  os);
		      }
d407 1
a407 1
	      einfo (_("%F%S: undefined symbol `%s' referenced in expression\n"),
a445 1
            int opb = bfd_octets_per_byte (output_bfd);
d450 1
a450 1
	    result = new_abs (os->bfd_section->_raw_size / opb);
d475 1
a475 1
      result.valid_p = false;
d487 1
a487 1
	result.valid_p = false;
a494 12
    case etree_assert:
      result = exp_fold_tree (tree->assert_s.child,
                              current_section,
                              allocation_done, dot, dotp);
      if (result.valid_p)
	{
	  if (! result.value)
	    einfo ("%F%P: %s\n", tree->assert_s.message);
	  return result;
	}
      break;

d499 1
a499 1
      if (result.valid_p)
d508 1
a508 1
		result.valid_p = false;
d512 1
a512 1
	      if (allocation_done != lang_first_phase_enum && result.valid_p)
d518 1
a518 1
		result.valid_p = false;
d544 1
a544 1
		result.valid_p = false;
d557 1
a557 1
      if (result.valid_p)
d576 1
a576 1
	    einfo (_("%F%S can not PROVIDE assignment to location counter\n"));
d585 2
a586 2
	      if (! result.valid_p)
		einfo (_("%F%S invalid assignment to location counter\n"));
d590 1
a590 1
		    einfo (_("%F%S assignment to location counter invalid outside of SECTION\n"));
d600 1
a600 1
			  einfo (_("%F%S cannot move location counter backwards (from %V to %V)\n"),
d614 1
a614 1
	  if (result.valid_p)
d628 1
a628 1
		    einfo (_("%P%F:%s: hash creation failed\n"),
d688 1
a688 1
  if (r.valid_p)
d713 1
a713 1
  if (r.valid_p) {
d735 1
a735 1
  if (r.valid_p) {
d759 1
a759 1
  if (r.valid_p) {
a812 17
/* Handle ASSERT.  */

etree_type *
exp_assert (exp, message)
     etree_type *exp;
     const char *message;
{
  etree_type *n;

  n = (etree_type *) stat_alloc (sizeof (n->assert_s));
  n->assert_s.type.node_code = '!';
  n->assert_s.type.node_class = etree_assert;
  n->assert_s.child = exp;
  n->assert_s.message = message;
  return n;
}

d863 1
a869 7

  case etree_assert:
    fprintf (config.map_file, "ASSERT (");
    exp_print_tree (tree->assert_s.child);
    fprintf (config.map_file, ", %s)", tree->assert_s.message);
    break;

d901 2
a902 2
      if (! r.valid_p && name != NULL)
	einfo (_("%F%S nonconstant expression for %s\n"), name);
d923 1
a923 1
     int def ATTRIBUTE_UNUSED;
d930 1
a930 1
  if (res.valid_p)
d935 1
a935 1
    einfo (_("%F%S non constant expression for %s\n"),name);
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001
d4 1
a4 1
   Written by Steve Chamberlain of Cygnus Support <sac@@cygnus.com>.
d23 8
a30 1
/* This module is in charge of working out the contents of expressions.
a31 4
   It has to keep track of the relative/absness of a symbol etc. This
   is done by keeping all values in a struct (an etree_value_type)
   which contains a value, a section to which it is relative and a
   valid bit.  */
d72 46
a117 44
  static CONST struct {
    token_code_type code;
    char *name;
  } table[] = {
    { INT, "int" },
    { REL, "relocateable" },
    { NAME, "NAME" },
    { PLUSEQ, "+=" },
    { MINUSEQ, "-=" },
    { MULTEQ, "*=" },
    { DIVEQ, "/=" },
    { LSHIFTEQ, "<<=" },
    { RSHIFTEQ, ">>=" },
    { ANDEQ, "&=" },
    { OREQ, "|=" },
    { OROR, "||" },
    { ANDAND, "&&" },
    { EQ, "==" },
    { NE, "!=" },
    { LE, "<=" },
    { GE, ">=" },
    { LSHIFT, "<<" },
    { RSHIFT, ">>=" },
    { ALIGN_K, "ALIGN" },
    { BLOCK, "BLOCK" },
    { SECTIONS, "SECTIONS" },
    { SIZEOF_HEADERS, "SIZEOF_HEADERS" },
    { NEXT, "NEXT" },
    { SIZEOF, "SIZEOF" },
    { ADDR, "ADDR" },
    { LOADADDR, "LOADADDR" },
    { MEMORY, "MEMORY" },
    { DEFINED, "DEFINED" },
    { TARGET_K, "TARGET" },
    { SEARCH_DIR, "SEARCH_DIR" },
    { MAP, "MAP" },
    { QUAD, "QUAD" },
    { SQUAD, "SQUAD" },
    { LONG, "LONG" },
    { SHORT, "SHORT" },
    { BYTE, "BYTE" },
    { ENTRY, "ENTRY" },
    { 0, (char *) NULL }
  };
d120 4
a123 7
  for (idx = 0; table[idx].name != (char *) NULL; idx++)
    {
      if (table[idx].code == code)
	{
	  fprintf (config.map_file, "%s", table[idx].name);
	  return;
	}
d125 1
d127 1
a127 1
  fprintf (config.map_file, "%c", code);
d130 1
a130 1
static void
d134 3
a136 3
  asection *s = ptr->section->bfd_section;
  ptr->value += s->vma;
  ptr->section = abs_output_section;
d150 1
a150 1
static void
d166 1
a166 1
  etree_type *new = (etree_type *) stat_alloc (sizeof (new->value));
d211 1
a211 1
  new.value -= section->bfd_section->vma;
d216 1
a216 1
static etree_value_type
d234 1
a234 1
			     allocation_done, dot, dotp);
d263 2
a264 2
	      make_abs (&result);
	      make_abs (&other);
d267 1
a267 1
	  switch (tree->type.node_code)
d284 16
a299 16
	      BOP ('+', +);
	      BOP ('*', *);
	      BOP ('-', -);
	      BOP (LSHIFT, <<);
	      BOP (RSHIFT, >>);
	      BOP (EQ, ==);
	      BOP (NE, !=);
	      BOP ('<', <);
	      BOP ('>', >);
	      BOP (LE, <=);
	      BOP (GE, >=);
	      BOP ('&', &);
	      BOP ('^', ^);
	      BOP ('|', |);
	      BOP (ANDAND, &&);
	      BOP (OROR, ||);
d312 1
a312 1
	      FAIL ();
d324 1
a324 1
etree_value_type
d332 1
a332 1
static etree_value_type
d336 1
a336 1
     lang_phase_type allocation_done;
d340 16
a355 11
  switch (tree->type.node_code)
    {
    case SIZEOF_HEADERS:
      if (allocation_done != lang_first_phase_enum)
	{
	  result = new_abs ((bfd_vma)
			    bfd_sizeof_headers (output_bfd,
						link_info.relocateable));
	}
      else
	{
d357 16
a372 4
	}
      break;
    case DEFINED:
      if (allocation_done == lang_first_phase_enum)
d374 55
a428 41
      else
	{
	  struct bfd_link_hash_entry *h;

	  h = bfd_wrapped_link_hash_lookup (output_bfd, &link_info,
					    tree->name.name,
					    false, false, true);
	  result.value = (h != (struct bfd_link_hash_entry *) NULL
			  && (h->type == bfd_link_hash_defined
			      || h->type == bfd_link_hash_defweak
			      || h->type == bfd_link_hash_common));
	  result.section = 0;
	  result.valid_p = true;
	}
      break;
    case NAME:
      result.valid_p = false;
      if (tree->name.name[0] == '.' && tree->name.name[1] == 0)
	{
	  if (allocation_done != lang_first_phase_enum)
	    result = new_rel_from_section (dot, current_section);
	  else
	    result = invalid ();
	}
      else if (allocation_done != lang_first_phase_enum)
	{
	  struct bfd_link_hash_entry *h;

	  h = bfd_wrapped_link_hash_lookup (output_bfd, &link_info,
					    tree->name.name,
					    false, false, true);
	  if (h != NULL
	      && (h->type == bfd_link_hash_defined
		  || h->type == bfd_link_hash_defweak))
	    {
	      if (bfd_is_abs_section (h->u.def.section))
		result = new_abs (h->u.def.value);
	      else if (allocation_done == lang_final_phase_enum
		       || allocation_done == lang_allocating_phase_enum)
		{
		  asection *output_section;
d430 2
a431 47
		  output_section = h->u.def.section->output_section;
		  if (output_section == NULL)
		    einfo (_("%X%S: unresolvable symbol `%s' referenced in expression\n"),
			   tree->name.name);
		  else
		    {
		      lang_output_section_statement_type *os;

		      os = (lang_output_section_statement_lookup
			    (bfd_get_section_name (output_bfd,
						   output_section)));

		      /* FIXME: Is this correct if this section is
			 being linked with -R?  */
		      result = new_rel ((h->u.def.value
					 + h->u.def.section->output_offset),
					os);
		    }
		}
	    }
	  else if (allocation_done == lang_final_phase_enum)
	    einfo (_("%F%S: undefined symbol `%s' referenced in expression\n"),
		   tree->name.name);
	}
      break;

    case ADDR:
      if (allocation_done != lang_first_phase_enum)
	{
	  lang_output_section_statement_type *os;

	  os = lang_output_section_find (tree->name.name);
	  check (os, tree->name.name, "ADDR");
	  result = new_rel (0, os);
	}
      else
	result = invalid ();
      break;

    case LOADADDR:
      if (allocation_done != lang_first_phase_enum)
	{
	  lang_output_section_statement_type *os;

	  os = lang_output_section_find (tree->name.name);
	  check (os, tree->name.name, "LOADADDR");
	  if (os->load_base == NULL)
d433 41
a473 27
	  else
	    result = exp_fold_tree_no_dot (os->load_base,
					   abs_output_section,
					   allocation_done);
	}
      else
	result = invalid ();
      break;

    case SIZEOF:
      if (allocation_done != lang_first_phase_enum)
	{
	  int opb = bfd_octets_per_byte (output_bfd);
	  lang_output_section_statement_type *os;

	  os = lang_output_section_find (tree->name.name);
	  check (os, tree->name.name, "SIZEOF");
	  result = new_abs (os->bfd_section->_raw_size / opb);
	}
      else
	result = invalid ();
      break;

    default:
      FAIL ();
      break;
    }
d477 1
a477 2

etree_value_type
d481 1
a481 1
     lang_phase_type allocation_done;
d493 1
a493 1
  switch (tree->type.node_class)
d511 2
a512 2
			      current_section,
			      allocation_done, dot, dotp);
d527 1
a527 1
	  switch (tree->type.node_code)
d543 1
a543 1
	      else
a597 1
    case etree_provided:
d601 1
a601 1
	  if (tree->type.node_class != etree_assign)
d630 1
a630 1
			*dotp = nextdot;
a670 2
		  if (tree->type.node_class == etree_provide)
		    tree->type.node_class = etree_provided;
d688 1
a688 1
static etree_value_type
d694 2
a695 2
  return exp_fold_tree (tree, current_section, allocation_done,
			(bfd_vma) 0, (bfd_vma *) NULL);
d711 3
a713 3
  r = exp_fold_tree_no_dot (&value,
			    abs_output_section,
			    lang_first_phase_enum);
d716 1
a716 1
      return exp_intop (r.value);
d719 1
a719 1
  memcpy ((char *) new, (char *) &value, sizeof (new->binary));
d737 5
a741 7
  r = exp_fold_tree_no_dot (&value,
			    (lang_output_section_statement_type *) NULL,
			    lang_first_phase_enum);
  if (r.valid_p)
    {
      return exp_intop (r.value);
    }
d743 1
a743 1
  memcpy ((char *) new, (char *) &value, sizeof (new->trinary));
d747 1
d759 5
a763 6
  r = exp_fold_tree_no_dot (&value, abs_output_section,
			    lang_first_phase_enum);
  if (r.valid_p)
    {
      return exp_intop (r.value);
    }
d765 1
a765 1
  memcpy ((char *) new, (char *) &value, sizeof (new->unary));
d769 1
d781 7
a787 7
  r = exp_fold_tree_no_dot (&value,
			    (lang_output_section_statement_type *) NULL,
			    lang_first_phase_enum);
  if (r.valid_p)
    {
      return exp_intop (r.value);
    }
d789 1
a789 1
  memcpy ((char *) new, (char *) &value, sizeof (new->name));
d794 3
d807 1
d813 3
a815 4
  if (exp_fold_tree_no_dot (&value, &result))
    {
      return exp_intop (result);
    }
d817 2
a818 2
  new = (etree_type *) stat_alloc (sizeof (new->assign));
  memcpy ((char *) new, (char *) &value, sizeof (new->assign));
d856 1
a856 1
void
d860 10
a869 11
  switch (tree->type.node_class)
    {
    case etree_value:
      minfo ("0x%v", tree->value.value);
      return;
    case etree_rel:
      if (tree->rel.section->owner != NULL)
	minfo ("%B:", tree->rel.section->owner);
      minfo ("%s+0x%v", tree->rel.section->name, tree->rel.value);
      return;
    case etree_assign:
d871 7
a877 9
      if (tree->assign.dst->sdefs != (asymbol *) NULL)
	{
	  fprintf (config.map_file, "%s (%x) ", tree->assign.dst->name,
		   tree->assign.dst->sdefs->value);
	}
      else
	{
	  fprintf (config.map_file, "%s (UNDEFINED)", tree->assign.dst->name);
	}
d879 57
a935 59
      fprintf (config.map_file, "%s", tree->assign.dst);
      exp_print_token (tree->type.node_code);
      exp_print_tree (tree->assign.src);
      break;
    case etree_provide:
    case etree_provided:
      fprintf (config.map_file, "PROVIDE (%s, ", tree->assign.dst);
      exp_print_tree (tree->assign.src);
      fprintf (config.map_file, ")");
      break;
    case etree_binary:
      fprintf (config.map_file, "(");
      exp_print_tree (tree->binary.lhs);
      exp_print_token (tree->type.node_code);
      exp_print_tree (tree->binary.rhs);
      fprintf (config.map_file, ")");
      break;
    case etree_trinary:
      exp_print_tree (tree->trinary.cond);
      fprintf (config.map_file, "?");
      exp_print_tree (tree->trinary.lhs);
      fprintf (config.map_file, ":");
      exp_print_tree (tree->trinary.rhs);
      break;
    case etree_unary:
      exp_print_token (tree->unary.type.node_code);
      if (tree->unary.child)
	{
	  fprintf (config.map_file, "(");
	  exp_print_tree (tree->unary.child);
	  fprintf (config.map_file, ")");
	}
      break;

    case etree_assert:
      fprintf (config.map_file, "ASSERT (");
      exp_print_tree (tree->assert_s.child);
      fprintf (config.map_file, ", %s)", tree->assert_s.message);
      break;

    case etree_undef:
      fprintf (config.map_file, "????????");
      break;
    case etree_name:
      if (tree->type.node_code == NAME)
	{
	  fprintf (config.map_file, "%s", tree->name.name);
	}
      else
	{
	  exp_print_token (tree->type.node_code);
	  if (tree->name.name)
	    fprintf (config.map_file, "(%s)", tree->name.name);
	}
      break;
    default:
      FAIL ();
      break;
    }
d958 2
a959 2
int
exp_get_value_int (tree, def, name, allocation_done)
d965 1
a965 1
  return (int) exp_get_vma (tree, (bfd_vma) def, name, allocation_done);
d968 1
d983 3
a985 4
  else
    {
      einfo (_("%F%S non constant expression for %s\n"), name);
    }
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2001, 2002
d39 1
a39 1
#include <ldgram.h>
a40 2
#include "libiberty.h"
#include "safe-ctype.h"
d42 5
a46 9
static void exp_print_token
  PARAMS ((token_code_type code, int infix_p));
static void make_abs
  PARAMS ((etree_value_type *ptr));
static etree_value_type new_abs
  PARAMS ((bfd_vma value));
static void check
  PARAMS ((lang_output_section_statement_type *os, const char *name,
	   const char *op));
d48 1
a48 1
  PARAMS ((bfd_vma, char *, lang_output_section_statement_type *section));
a50 5
static etree_value_type fold_unary
  PARAMS ((etree_type *tree,
	   lang_output_section_statement_type *current_section,
	   lang_phase_type allocation_done,
	   bfd_vma dot, bfd_vma *dotp));
a55 5
static etree_value_type fold_trinary
  PARAMS ((etree_type *tree,
	   lang_output_section_statement_type *current_section,
	   lang_phase_type allocation_done,
	   bfd_vma dot, bfd_vma *dotp));
a65 5
struct exp_data_seg exp_data_seg;

/* Print the string representation of the given token.  Surround it
   with spaces if INFIX_P is TRUE.  */

d67 1
a67 1
exp_print_token (code, infix_p)
a68 1
     int infix_p;
d70 1
a70 2
  static const struct
  {
d72 2
a73 4
    char * name;
  }
  table[] =
  {
d75 1
d92 1
a92 1
    { RSHIFT, ">>" },
a94 5
    { QUAD, "QUAD" },
    { SQUAD, "SQUAD" },
    { LONG, "LONG" },
    { SHORT, "SHORT" },
    { BYTE, "BYTE" },
d97 4
d106 5
d112 1
a112 8
    { NEXT, "NEXT" },
    { SIZEOF, "SIZEOF" },
    { ADDR, "ADDR" },
    { LOADADDR, "LOADADDR" },
    { MAX_K, "MAX_K" },
    { REL, "relocateable" },
    { DATA_SEGMENT_ALIGN, "DATA_SEGMENT_ALIGN" },
    { DATA_SEGMENT_END, "DATA_SEGMENT_END" }
d116 10
a125 16
  for (idx = 0; idx < ARRAY_SIZE (table); idx++)
    if (table[idx].code == code)
      break;

  if (infix_p)
    fputc (' ', config.map_file);

  if (idx < ARRAY_SIZE (table))
    fputs (table[idx].name, config.map_file);
  else if (code < 127)
    fputc (code, config.map_file);
  else
    fprintf (config.map_file, "<code %d>", code);

  if (infix_p)
    fputc (' ', config.map_file);
d142 1
a142 1
  new.valid_p = TRUE;
a166 1
  new->value.str = NULL;
a168 1
}
a169 11
etree_type *
exp_bigintop (value, str)
     bfd_vma value;
     char *str;
{
  etree_type *new = (etree_type *) stat_alloc (sizeof (new->value));
  new->type.node_code = INT;
  new->value.value = value;
  new->value.str = str;
  new->type.node_class = etree_value;
  return new;
d188 1
a188 1
new_rel (value, str, section)
a189 1
     char *str;
d193 1
a193 1
  new.valid_p = TRUE;
a194 1
  new.str = str;
d205 1
a205 1
  new.valid_p = TRUE;
a206 1
  new.str = NULL;
a214 87
fold_unary (tree, current_section, allocation_done, dot, dotp)
     etree_type *tree;
     lang_output_section_statement_type *current_section;
     lang_phase_type allocation_done;
     bfd_vma dot;
     bfd_vma *dotp;
{
  etree_value_type result;

  result = exp_fold_tree (tree->unary.child,
			  current_section,
			  allocation_done, dot, dotp);
  if (result.valid_p)
    {
      switch (tree->type.node_code)
	{
	case ALIGN_K:
	  if (allocation_done != lang_first_phase_enum)
	    result = new_rel_from_section (align_n (dot, result.value),
					   current_section);
	  else
	    result.valid_p = FALSE;
	  break;

	case ABSOLUTE:
	  if (allocation_done != lang_first_phase_enum)
	    {
	      result.value += result.section->bfd_section->vma;
	      result.section = abs_output_section;
	    }
	  else
	    result.valid_p = FALSE;
	  break;

	case '~':
	  make_abs (&result);
	  result.value = ~result.value;
	  break;

	case '!':
	  make_abs (&result);
	  result.value = !result.value;
	  break;

	case '-':
	  make_abs (&result);
	  result.value = -result.value;
	  break;

	case NEXT:
	  /* Return next place aligned to value.  */
	  if (allocation_done == lang_allocating_phase_enum)
	    {
	      make_abs (&result);
	      result.value = align_n (dot, result.value);
	    }
	  else
	    result.valid_p = FALSE;
	  break;

	case DATA_SEGMENT_END:
	  if (allocation_done != lang_first_phase_enum
	      && current_section == abs_output_section
	      && (exp_data_seg.phase == exp_dataseg_align_seen
		  || exp_data_seg.phase == exp_dataseg_adjust
		  || allocation_done != lang_allocating_phase_enum))
	    {
	      if (exp_data_seg.phase == exp_dataseg_align_seen)
		{
		  exp_data_seg.phase = exp_dataseg_end_seen;
		  exp_data_seg.end = result.value;
		}
	    }
	  else
	    result.valid_p = FALSE;
	  break;

	default:
	  FAIL ();
	  break;
	}
    }

  return result;
}

static etree_value_type
d247 4
d253 3
a255 6
		  /* Keep the section of the other term.  */
		  if (tree->type.node_code == '+')
		    other.value = result.value + other.value;
		  else
		    other.value = result.value - other.value;
		  return other;
a308 28
	    case DATA_SEGMENT_ALIGN:
	      if (allocation_done != lang_first_phase_enum
		  && current_section == abs_output_section
		  && (exp_data_seg.phase == exp_dataseg_none
		      || exp_data_seg.phase == exp_dataseg_adjust
		      || allocation_done != lang_allocating_phase_enum))
		{
		  bfd_vma maxpage = result.value;

		  result.value = align_n (dot, maxpage);
		  if (exp_data_seg.phase != exp_dataseg_adjust)
		    {
		      result.value += dot & (maxpage - 1);
		      if (allocation_done == lang_allocating_phase_enum)
			{
			  exp_data_seg.phase = exp_dataseg_align_seen;
			  exp_data_seg.base = result.value;
			  exp_data_seg.pagesize = other.value;
			}
		    }
		  else if (other.value < maxpage)
		    result.value += (dot + other.value - 1)
				    & (maxpage - other.value);
		}
	      else
		result.valid_p = FALSE;
	      break;

d315 1
a315 1
	  result.valid_p = FALSE;
a321 22
static etree_value_type
fold_trinary (tree, current_section, allocation_done, dot, dotp)
     etree_type *tree;
     lang_output_section_statement_type *current_section;
     lang_phase_type allocation_done;
     bfd_vma dot;
     bfd_vma *dotp;
{
  etree_value_type result;

  result = exp_fold_tree (tree->trinary.cond, current_section,
			  allocation_done, dot, dotp);
  if (result.valid_p)
    result = exp_fold_tree ((result.value
			     ? tree->trinary.lhs
			     : tree->trinary.rhs),
			    current_section,
			    allocation_done, dot, dotp);

  return result;
}

d326 1
a326 1
  new.valid_p = FALSE;
a337 1

d349 1
a349 1
	  result.valid_p = FALSE;
d354 1
a354 1
	result.valid_p = FALSE;
d361 1
a361 1
					    FALSE, FALSE, TRUE);
d367 1
a367 1
	  result.valid_p = TRUE;
d371 1
a371 1
      result.valid_p = FALSE;
d385 1
a385 1
					    FALSE, FALSE, TRUE);
a412 1
					NULL,
d430 1
a430 1
	  result = new_rel (0, NULL, os);
d444 1
a444 1
	    result = new_rel (0, NULL, os);
d488 1
a488 1
      result.valid_p = FALSE;
d495 1
a495 1
      result = new_rel (tree->value.value, tree->value.str, current_section);
d500 1
a500 1
	result.valid_p = FALSE;
a504 1
			  NULL,
d521 67
a587 2
      result = fold_unary (tree, current_section, allocation_done,
			   dot, dotp);
a594 5
    case etree_trinary:
      result = fold_trinary (tree, current_section, allocation_done,
			     dot, dotp);
      break;

d600 1
a600 1
	  /* Assignment to dot can only be done during allocation.  */
d609 1
a609 1
				      allocation_done, dot,
d625 4
a628 2
			einfo (_("%F%S cannot move location counter backwards (from %V to %V)\n"),
			       dot, nextdot);
d642 1
a642 1
	      bfd_boolean create;
d646 1
a646 1
		create = TRUE;
d648 1
a648 1
		create = FALSE;
d650 1
a650 1
					create, FALSE, FALSE);
d743 3
a745 2
    return exp_intop (r.value);

d765 3
a767 2
    return exp_intop (r.value);

d776 1
a776 1
     const char *name;
d788 3
a790 2
    return exp_intop (r.value);

d800 1
a800 1
     const char *dst;
d813 3
a815 1
    return exp_intop (result);
a859 9
  if (config.map_file == NULL)
    config.map_file = stderr;

  if (tree == NULL)
    {
      minfo ("NULL TREE\n");
      return;
    }

d873 4
a876 2
	fprintf (config.map_file, "%s (%x) ", tree->assign.dst->name,
		 tree->assign.dst->sdefs->value);
d878 3
a880 1
	fprintf (config.map_file, "%s (UNDEFINED)", tree->assign.dst->name);
d883 1
a883 1
      exp_print_token (tree->type.node_code, TRUE);
d895 1
a895 1
      exp_print_token (tree->type.node_code, TRUE);
d907 1
a907 1
      exp_print_token (tree->unary.type.node_code, FALSE);
d910 1
a910 1
	  fprintf (config.map_file, " (");
d932 1
a932 1
	  exp_print_token (tree->type.node_code, FALSE);
d934 1
a934 1
	    fprintf (config.map_file, " (%s)", tree->name.name);
a972 59
fill_type *
exp_get_fill (tree, def, name, allocation_done)
     etree_type *tree;
     fill_type *def;
     char *name;
     lang_phase_type allocation_done;
{
  fill_type *fill;
  etree_value_type r;
  size_t len;
  unsigned int val;

  if (tree == NULL)
    return def;

  r = exp_fold_tree_no_dot (tree, abs_output_section, allocation_done);
  if (! r.valid_p && name != NULL)
    einfo (_("%F%S nonconstant expression for %s\n"), name);

  if (r.str != NULL && (len = strlen (r.str)) != 0)
    {
      unsigned char *dst;
      unsigned char *s;
      fill = (fill_type *) xmalloc ((len + 1) / 2 + sizeof (*fill) - 1);
      fill->size = (len + 1) / 2;
      dst = fill->data;
      s = r.str;
      val = 0;
      do
	{
	  unsigned int digit;

	  digit = *s++ - '0';
	  if (digit > 9)
	    digit = (digit - 'A' + '0' + 10) & 0xf;
	  val <<= 4;
	  val += digit;
	  --len;
	  if ((len & 1) == 0)
	    {
	      *dst++ = val;
	      val = 0;
	    }
	}
      while (len != 0);
    }
  else
    {
      fill = (fill_type *) xmalloc (4 + sizeof (*fill) - 1);
      val = r.value;
      fill->data[0] = (val >> 24) & 0xff;
      fill->data[1] = (val >> 16) & 0xff;
      fill->data[2] = (val >>  8) & 0xff;
      fill->data[3] = (val >>  0) & 0xff;
      fill->size = 4;
    }
  return fill;
}

d984 3
a986 1
    res.value += res.section->bfd_section->vma;
d988 3
a990 2
    einfo (_("%F%S non constant expression for %s\n"), name);

a991 11
}

bfd_vma align_n (value, align)
     bfd_vma value;
     bfd_vma align;
{
  if (align <= 1)
    return value;

  value = (value + align - 1) / align;
  return value * align;
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004
d44 33
d78 3
a80 3
  (etree_type *, lang_output_section_statement_type *, lang_phase_type);
static bfd_vma align_n
  (bfd_vma, bfd_vma);
d88 3
a90 1
exp_print_token (token_code_type code, int infix_p)
d137 1
a137 1
    { REL, "relocatable" },
d162 2
a163 1
make_abs (etree_value_type *ptr)
d171 2
a172 1
new_abs (bfd_vma value)
d181 12
d194 2
a195 1
exp_intop (bfd_vma value)
d197 1
a197 1
  etree_type *new = stat_alloc (sizeof (new->value));
d206 3
a208 1
exp_bigintop (bfd_vma value, char *str)
d210 1
a210 1
  etree_type *new = stat_alloc (sizeof (new->value));
d218 1
a218 1
/* Build an expression representing an unnamed relocatable value.  */
d221 3
a223 1
exp_relop (asection *section, bfd_vma value)
d225 1
a225 1
  etree_type *new = stat_alloc (sizeof (new->rel));
d234 4
a237 3
new_rel (bfd_vma value,
	 char *str,
	 lang_output_section_statement_type *section)
d248 3
a250 2
new_rel_from_section (bfd_vma value,
		      lang_output_section_statement_type *section)
d264 6
a269 5
fold_unary (etree_type *tree,
	    lang_output_section_statement_type *current_section,
	    lang_phase_type allocation_done,
	    bfd_vma dot,
	    bfd_vma *dotp)
d351 6
a356 5
fold_binary (etree_type *tree,
	     lang_output_section_statement_type *current_section,
	     lang_phase_type allocation_done,
	     bfd_vma dot,
	     bfd_vma *dotp)
a443 4
	    case ALIGN_K:
	      result.value = align_n (result.value, other.value);
	      break;
	      
d486 6
a491 5
fold_trinary (etree_type *tree,
	      lang_output_section_statement_type *current_section,
	      lang_phase_type allocation_done,
	      bfd_vma dot,
	      bfd_vma *dotp)
d507 8
d516 5
a520 4
fold_name (etree_type *tree,
	   lang_output_section_statement_type *current_section,
	   lang_phase_type allocation_done,
	   bfd_vma dot)
a523 2
  result.valid_p = FALSE;
  
d528 9
a536 2
	result = new_abs (bfd_sizeof_headers (output_bfd,
					      link_info.relocatable));
d540 1
a540 1
	lang_track_definedness (tree->name.name);
a543 2
	  int def_iteration
	    = lang_symbol_definition_iteration (tree->name.name);
d548 1
a548 1
	  result.value = (h != NULL
d551 2
a552 4
			      || h->type == bfd_link_hash_common)
			  && (def_iteration == lang_statement_iteration
			      || def_iteration == -1));
	  result.section = abs_output_section;
d557 1
d562 2
d571 4
a574 5
					    TRUE, FALSE, TRUE);
	  if (!h)
	    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
	  else if (h->type == bfd_link_hash_defined
		   || h->type == bfd_link_hash_defweak)
a606 6
	  else if (h->type == bfd_link_hash_new)
	    {
	      h->type = bfd_link_hash_undefined;
	      h->u.undef.abfd = NULL;
	      bfd_link_add_undef (link_info.hash, h);
	    }
d616 2
a617 2
	  if (os && os->processed > 0)
	    result = new_rel (0, NULL, os);
d619 2
d629 7
a635 9
	  if (os && os->processed != 0)
	    {
	      if (os->load_base == NULL)
		result = new_rel (0, NULL, os);
	      else
		result = exp_fold_tree_no_dot (os->load_base,
					       abs_output_section,
					       allocation_done);
	    }
d637 2
d648 2
a649 2
	  if (os && os->processed > 0)
	    result = new_abs (os->bfd_section->_raw_size / opb);
d651 2
d664 6
a669 5
exp_fold_tree (etree_type *tree,
	       lang_output_section_statement_type *current_section,
	       lang_phase_type allocation_done,
	       bfd_vma dot,
	       bfd_vma *dotp)
d776 2
a777 2
					create, FALSE, TRUE);
	      if (h == NULL)
d779 1
a779 1
		  if (create)
a783 1
		       && h->type != bfd_link_hash_new
a793 1
		  lang_update_definedness (tree->assign.dst, h);
d817 4
a820 3
exp_fold_tree_no_dot (etree_type *tree,
		      lang_output_section_statement_type *current_section,
		      lang_phase_type allocation_done)
d822 2
a823 1
  return exp_fold_tree (tree, current_section, allocation_done, 0, NULL);
d827 4
a830 1
exp_binop (int code, etree_type *lhs, etree_type *rhs)
d846 2
a847 2
  new = stat_alloc (sizeof (new->binary));
  memcpy (new, &value, sizeof (new->binary));
d852 5
a856 1
exp_trinop (int code, etree_type *cond, etree_type *lhs, etree_type *rhs)
d865 3
a867 1
  r = exp_fold_tree_no_dot (&value, NULL, lang_first_phase_enum);
d871 2
a872 2
  new = stat_alloc (sizeof (new->trinary));
  memcpy (new, &value, sizeof (new->trinary));
d877 3
a879 1
exp_unop (int code, etree_type *child)
d892 2
a893 2
  new = stat_alloc (sizeof (new->unary));
  memcpy (new, &value, sizeof (new->unary));
d898 3
a900 1
exp_nameop (int code, const char *name)
d908 3
a910 1
  r = exp_fold_tree_no_dot (&value, NULL, lang_first_phase_enum);
d914 2
a915 2
  new = stat_alloc (sizeof (new->name));
  memcpy (new, &value, sizeof (new->name));
d921 4
a924 1
exp_assop (int code, const char *dst, etree_type *src)
d938 2
a939 2
  new = stat_alloc (sizeof (new->assign));
  memcpy (new, &value, sizeof (new->assign));
d946 3
a948 1
exp_provide (const char *dst, etree_type *src)
d952 1
a952 1
  n = stat_alloc (sizeof (n->assign));
d963 3
a965 1
exp_assert (etree_type *exp, const char *message)
d969 1
a969 1
  n = stat_alloc (sizeof (n->assert_s));
d978 2
a979 1
exp_print_tree (etree_type *tree)
d1002 1
a1002 1
      if (tree->assign.dst->sdefs != NULL)
d1070 5
a1074 4
exp_get_vma (etree_type *tree,
	     bfd_vma def,
	     char *name,
	     lang_phase_type allocation_done)
d1090 5
a1094 4
exp_get_value_int (etree_type *tree,
		   int def,
		   char *name,
		   lang_phase_type allocation_done)
d1096 1
a1096 1
  return exp_get_vma (tree, def, name, allocation_done);
d1100 5
a1104 4
exp_get_fill (etree_type *tree,
	      fill_type *def,
	      char *name,
	      lang_phase_type allocation_done)
d1122 1
a1122 1
      fill = xmalloc ((len + 1) / 2 + sizeof (*fill) - 1);
d1147 1
a1147 1
      fill = xmalloc (4 + sizeof (*fill) - 1);
d1159 5
a1163 4
exp_get_abs_int (etree_type *tree,
		 int def ATTRIBUTE_UNUSED,
		 char *name,
		 lang_phase_type allocation_done)
d1176 3
a1178 2
static bfd_vma
align_n (bfd_vma value, bfd_vma align)
@


