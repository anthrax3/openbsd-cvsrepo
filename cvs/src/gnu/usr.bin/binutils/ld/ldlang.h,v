head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.50
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.11.02.20.45.48;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.50;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.42;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.09.22.29.40;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.12.45;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.09.27;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.54.22;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.15;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.15;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.35.33;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.35.00;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.28.31;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.48.08;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2001.06.09.22.08.52;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.14.01.06;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.49;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.23.21;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* ldlang.h - linker command language support
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2004
   Free Software Foundation, Inc.

   This file is part of GLD, the Gnu Linker.

   GLD is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GLD is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GLD; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#ifndef LDLANG_H
#define LDLANG_H

#define DEFAULT_MEMORY_REGION   "*default*"

typedef enum
{
  lang_input_file_is_l_enum,
  lang_input_file_is_symbols_only_enum,
  lang_input_file_is_marker_enum,
  lang_input_file_is_fake_enum,
  lang_input_file_is_search_file_enum,
  lang_input_file_is_file_enum
} lang_input_file_enum_type;

struct _fill_type
{
  size_t size;
  unsigned char data[1];
};

typedef struct statement_list
{
  union lang_statement_union *head;
  union lang_statement_union **tail;
} lang_statement_list_type;

typedef struct memory_region_struct
{
  char *name;
  struct memory_region_struct *next;
  bfd_vma origin;
  bfd_size_type length;
  bfd_vma current;
  bfd_size_type old_length;
  flagword flags;
  flagword not_flags;
  bfd_boolean had_full_message;
} lang_memory_region_type;

typedef struct lang_statement_header_struct
{
  union lang_statement_union *next;
  enum statement_enum
  {
    lang_output_section_statement_enum,
    lang_assignment_statement_enum,
    lang_input_statement_enum,
    lang_address_statement_enum,
    lang_wild_statement_enum,
    lang_input_section_enum,
    lang_object_symbols_statement_enum,
    lang_fill_statement_enum,
    lang_data_statement_enum,
    lang_reloc_statement_enum,
    lang_target_statement_enum,
    lang_output_statement_enum,
    lang_padding_statement_enum,
    lang_group_statement_enum,

    lang_afile_asection_pair_statement_enum,
    lang_constructors_statement_enum
  } type;
} lang_statement_header_type;

typedef struct
{
  lang_statement_header_type header;
  union etree_union *exp;
} lang_assignment_statement_type;

typedef struct lang_target_statement_struct
{
  lang_statement_header_type header;
  const char *target;
} lang_target_statement_type;

typedef struct lang_output_statement_struct
{
  lang_statement_header_type header;
  const char *name;
} lang_output_statement_type;

/* Section types specified in a linker script.  */

enum section_type
{
  normal_section,
  dsect_section,
  copy_section,
  noload_section,
  info_section,
  overlay_section
};

/* This structure holds a list of program headers describing
   segments in which this section should be placed.  */

typedef struct lang_output_section_phdr_list
{
  struct lang_output_section_phdr_list *next;
  const char *name;
  bfd_boolean used;
} lang_output_section_phdr_list;

typedef struct lang_output_section_statement_struct
{
  lang_statement_header_type header;
  union etree_union *addr_tree;
  lang_statement_list_type children;
  const char *memspec;
  union lang_statement_union *next;
  const char *name;

  int processed;

  asection *bfd_section;
  flagword flags;		/* Or together of all input sections.  */
  enum section_type sectype;
  lang_memory_region_type *region;
  lang_memory_region_type *lma_region;
  size_t block_value;
  fill_type *fill;

  int subsection_alignment;	/* Alignment of components.  */
  int section_alignment;	/* Alignment of start of section.  */

  union etree_union *load_base;

  /* If non-null, an expression to evaluate after setting the section's
     size.  The expression is evaluated inside REGION (above) with '.'
     set to the end of the section.  Used in the last overlay section
     to move '.' past all the overlaid sections.  */
  union etree_union *update_dot_tree;

  lang_output_section_phdr_list *phdrs;
} lang_output_section_statement_type;

typedef struct
{
  lang_statement_header_type header;
} lang_common_statement_type;

typedef struct
{
  lang_statement_header_type header;
} lang_object_symbols_statement_type;

typedef struct
{
  lang_statement_header_type header;
  fill_type *fill;
  int size;
  asection *output_section;
} lang_fill_statement_type;

typedef struct
{
  lang_statement_header_type header;
  unsigned int type;
  union etree_union *exp;
  bfd_vma value;
  asection *output_section;
  bfd_vma output_vma;
} lang_data_statement_type;

/* Generate a reloc in the output file.  */

typedef struct
{
  lang_statement_header_type header;

  /* Reloc to generate.  */
  bfd_reloc_code_real_type reloc;

  /* Reloc howto structure.  */
  reloc_howto_type *howto;

  /* Section to generate reloc against.
     Exactly one of section and name must be NULL.  */
  asection *section;

  /* Name of symbol to generate reloc against.
     Exactly one of section and name must be NULL.  */
  const char *name;

  /* Expression for addend.  */
  union etree_union *addend_exp;

  /* Resolved addend.  */
  bfd_vma addend_value;

  /* Output section where reloc should be performed.  */
  asection *output_section;

  /* VMA within output section.  */
  bfd_vma output_vma;
} lang_reloc_statement_type;

typedef struct lang_input_statement_struct
{
  lang_statement_header_type header;
  /* Name of this file.  */
  const char *filename;
  /* Name to use for the symbol giving address of text start.
     Usually the same as filename, but for a file spec'd with
     -l this is the -l switch itself rather than the filename.  */
  const char *local_sym_name;

  bfd *the_bfd;

  bfd_boolean closed;
  file_ptr passive_position;

  /* Symbol table of the file.  */
  asymbol **asymbols;
  unsigned int symbol_count;

  /* Point to the next file - whatever it is, wanders up and down
     archives */
  union lang_statement_union *next;

  /* Point to the next file, but skips archive contents.  */
  union lang_statement_union *next_real_file;

  bfd_boolean is_archive;

  /* 1 means search a set of directories for this file.  */
  bfd_boolean search_dirs_flag;

  /* 1 means this was found in a search directory marked as sysrooted,
     if search_dirs_flag is false, otherwise, that it should be
     searched in ld_sysroot before any other location, as long as it
     starts with a slash.  */
  bfd_boolean sysrooted;

  /* 1 means this is base file of incremental load.
     Do not load this file's text or data.
     Also default text_start to after this file's bss.  */
  bfd_boolean just_syms_flag;

  /* Whether to search for this entry as a dynamic archive.  */
  bfd_boolean dynamic;

  /* Whether this entry should cause a DT_NEEDED tag only when
     satisfying references from regular files, or always.  */
  bfd_boolean as_needed;

  /* Whether to include the entire contents of an archive.  */
  bfd_boolean whole_archive;

  bfd_boolean loaded;

#if 0
  unsigned int globals_in_this_file;
#endif
  const char *target;
  bfd_boolean real;
} lang_input_statement_type;

typedef struct
{
  lang_statement_header_type header;
  asection *section;
  lang_input_statement_type *ifile;

} lang_input_section_type;

typedef struct
{
  lang_statement_header_type header;
  asection *section;
  union lang_statement_union *file;
} lang_afile_asection_pair_statement_type;

typedef struct lang_wild_statement_struct
{
  lang_statement_header_type header;
  const char *filename;
  bfd_boolean filenames_sorted;
  struct wildcard_list *section_list;
  bfd_boolean keep_sections;
  lang_statement_list_type children;
} lang_wild_statement_type;

typedef struct lang_address_statement_struct
{
  lang_statement_header_type header;
  const char *section_name;
  union etree_union *address;
} lang_address_statement_type;

typedef struct
{
  lang_statement_header_type header;
  bfd_vma output_offset;
  size_t size;
  asection *output_section;
  fill_type *fill;
} lang_padding_statement_type;

/* A group statement collects a set of libraries together.  The
   libraries are searched multiple times, until no new undefined
   symbols are found.  The effect is to search a group of libraries as
   though they were a single library.  */

typedef struct
{
  lang_statement_header_type header;
  lang_statement_list_type children;
} lang_group_statement_type;

typedef union lang_statement_union
{
  lang_statement_header_type header;
  lang_wild_statement_type wild_statement;
  lang_data_statement_type data_statement;
  lang_reloc_statement_type reloc_statement;
  lang_address_statement_type address_statement;
  lang_output_section_statement_type output_section_statement;
  lang_afile_asection_pair_statement_type afile_asection_pair_statement;
  lang_assignment_statement_type assignment_statement;
  lang_input_statement_type input_statement;
  lang_target_statement_type target_statement;
  lang_output_statement_type output_statement;
  lang_input_section_type input_section;
  lang_common_statement_type common_statement;
  lang_object_symbols_statement_type object_symbols_statement;
  lang_fill_statement_type fill_statement;
  lang_padding_statement_type padding_statement;
  lang_group_statement_type group_statement;
} lang_statement_union_type;

/* This structure holds information about a program header, from the
   PHDRS command in the linker script.  */

struct lang_phdr
{
  struct lang_phdr *next;
  const char *name;
  unsigned long type;
  bfd_boolean filehdr;
  bfd_boolean phdrs;
  etree_type *at;
  etree_type *flags;
};

/* This structure is used to hold a list of sections which may not
   cross reference each other.  */

typedef struct lang_nocrossref
{
  struct lang_nocrossref *next;
  const char *name;
} lang_nocrossref_type;

/* The list of nocrossref lists.  */

struct lang_nocrossrefs
{
  struct lang_nocrossrefs *next;
  lang_nocrossref_type *list;
};

extern struct lang_nocrossrefs *nocrossref_list;

/* This structure is used to hold a list of input section names which
   will not match an output section in the linker script.  */

struct unique_sections
{
  struct unique_sections *next;
  const char *name;
};

/* This structure records symbols for which we need to keep track of
   definedness for use in the DEFINED () test.  */

struct lang_definedness_hash_entry
{
  struct bfd_hash_entry root;
  int iteration;
};

extern struct unique_sections *unique_section_list;

extern lang_output_section_statement_type *abs_output_section;
extern lang_statement_list_type lang_output_section_statement;
extern bfd_boolean lang_has_input_file;
extern etree_type *base;
extern lang_statement_list_type *stat_ptr;
extern bfd_boolean delete_output_file_on_failure;

extern struct bfd_sym_chain entry_symbol;
extern const char *entry_section;
extern bfd_boolean entry_from_cmdline;
extern lang_statement_list_type file_chain;

extern int lang_statement_iteration;

extern void lang_init
  (void);
extern lang_memory_region_type *lang_memory_region_lookup
  (const char *const, bfd_boolean);
extern lang_memory_region_type *lang_memory_region_default
  (asection *);
extern void lang_map
  (void);
extern void lang_set_flags
  (lang_memory_region_type *, const char *, int);
extern void lang_add_output
  (const char *, int from_script);
extern lang_output_section_statement_type *lang_enter_output_section_statement
  (const char *output_section_statement_name,
   etree_type *address_exp,
   enum section_type sectype,
   etree_type *align,
   etree_type *subalign,
   etree_type *);
extern void lang_final
  (void);
extern void lang_process
  (void);
extern void lang_section_start
  (const char *, union etree_union *);
extern void lang_add_entry
  (const char *, bfd_boolean);
extern void lang_add_target
  (const char *);
extern void lang_add_wild
  (struct wildcard_spec *, struct wildcard_list *, bfd_boolean);
extern void lang_add_map
  (const char *);
extern void lang_add_fill
  (fill_type *);
extern lang_assignment_statement_type *lang_add_assignment
  (union etree_union *);
extern void lang_add_attribute
  (enum statement_enum);
extern void lang_startup
  (const char *);
extern void lang_float
  (bfd_boolean);
extern void lang_leave_output_section_statement
  (fill_type *, const char *, lang_output_section_phdr_list *,
   const char *);
extern void lang_abs_symbol_at_end_of
  (const char *, const char *);
extern void lang_abs_symbol_at_beginning_of
  (const char *, const char *);
extern void lang_statement_append
  (lang_statement_list_type *, lang_statement_union_type *,
   lang_statement_union_type **);
extern void lang_for_each_input_file
  (void (*dothis) (lang_input_statement_type *));
extern void lang_for_each_file
  (void (*dothis) (lang_input_statement_type *));
extern void lang_reset_memory_regions
  (void);
extern void lang_do_assignments
  (lang_statement_union_type *, lang_output_section_statement_type *,
   fill_type *, bfd_vma);

#define LANG_FOR_EACH_INPUT_STATEMENT(statement)			\
  lang_input_statement_type *statement;					\
  for (statement = (lang_input_statement_type *) file_chain.head;	\
       statement != (lang_input_statement_type *) NULL;			\
       statement = (lang_input_statement_type *) statement->next)	\

extern void lang_process
  (void);
extern void ldlang_add_file
  (lang_input_statement_type *);
extern lang_output_section_statement_type *lang_output_section_find
  (const char * const);
extern lang_input_statement_type *lang_add_input_file
  (const char *, lang_input_file_enum_type, const char *);
extern void lang_add_keepsyms_file
  (const char *);
extern lang_output_section_statement_type *
  lang_output_section_statement_lookup
  (const char *const);
extern void ldlang_add_undef
  (const char *const);
extern void lang_add_output_format
  (const char *, const char *, const char *, int);
extern void lang_list_init
  (lang_statement_list_type *);
extern void lang_add_data
  (int type, union etree_union *);
extern void lang_add_reloc
  (bfd_reloc_code_real_type, reloc_howto_type *, asection *, const char *,
   union etree_union *);
extern void lang_for_each_statement
  (void (*) (lang_statement_union_type *));
extern void *stat_alloc
  (size_t);
extern void dprint_statement
  (lang_statement_union_type *, int);
extern bfd_vma lang_size_sections
  (lang_statement_union_type *, lang_output_section_statement_type *,
   lang_statement_union_type **, fill_type *, bfd_vma, bfd_boolean *,
   bfd_boolean);
extern void lang_enter_group
  (void);
extern void lang_leave_group
  (void);
extern void lang_add_section
  (lang_statement_list_type *, asection *,
   lang_output_section_statement_type *, lang_input_statement_type *);
extern void lang_new_phdr
  (const char *, etree_type *, bfd_boolean, bfd_boolean, etree_type *,
   etree_type *);
extern void lang_add_nocrossref
  (lang_nocrossref_type *);
extern void lang_enter_overlay
  (etree_type *, etree_type *);
extern void lang_enter_overlay_section
  (const char *);
extern void lang_leave_overlay_section
  (fill_type *, lang_output_section_phdr_list *);
extern void lang_leave_overlay
  (etree_type *, int, fill_type *, const char *,
   lang_output_section_phdr_list *, const char *);

extern struct bfd_elf_version_tree *lang_elf_version_info;

extern struct bfd_elf_version_expr *lang_new_vers_pattern
  (struct bfd_elf_version_expr *, const char *, const char *);
extern struct bfd_elf_version_tree *lang_new_vers_node
  (struct bfd_elf_version_expr *, struct bfd_elf_version_expr *);
extern struct bfd_elf_version_deps *lang_add_vers_depend
  (struct bfd_elf_version_deps *, const char *);
extern void lang_register_vers_node
  (const char *, struct bfd_elf_version_tree *, struct bfd_elf_version_deps *);
bfd_boolean unique_section_p
  (const char *);
extern void lang_add_unique
  (const char *);
extern const char *lang_get_output_target
  (void);
extern void lang_track_definedness (const char *);
extern int lang_symbol_definition_iteration (const char *);
extern void lang_update_definedness
  (const char *, struct bfd_link_hash_entry *);

#endif
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2001, 2002, 2003
d26 4
a29 1
typedef enum {
d38 2
a39 1
struct _fill_type {
d44 2
a45 1
typedef struct statement_list {
d50 2
a51 1
typedef struct memory_region_struct {
d63 2
a64 1
typedef struct lang_statement_header_struct {
d66 2
a67 1
  enum statement_enum {
d88 2
a89 1
typedef struct {
d94 2
a95 1
typedef struct lang_target_statement_struct {
d100 2
a101 1
typedef struct lang_output_statement_struct {
d108 2
a109 1
enum section_type {
d118 2
a119 2
/* This structure holds a list of program headers describing segments
   in which this section should be placed.  */
d121 2
a122 1
struct lang_output_section_phdr_list {
d126 1
a126 1
};
d128 2
a129 1
typedef struct lang_output_section_statement_struct {
d137 1
a137 1
  bfd_boolean processed;
d140 1
a140 1
  flagword flags;		/* Or together of all input sections */
d142 2
a143 2
  struct memory_region_struct *region;
  struct memory_region_struct *lma_region;
d147 2
a148 2
  int subsection_alignment;	/* alignment of components */
  int section_alignment;	/* alignment of start of section */
d158 1
a158 1
  struct lang_output_section_phdr_list *phdrs;
d161 2
a162 1
typedef struct {
d166 2
a167 1
typedef struct {
d171 2
a172 1
typedef struct {
d179 2
a180 1
typedef struct {
d191 2
a192 1
typedef struct {
d201 2
a202 2
  /* Section to generate reloc against.  Exactly one of section and
     name must be NULL.  */
d205 2
a206 2
  /* Name of symbol to generate reloc against.  Exactly one of section
     and name must be NULL.  */
d222 2
a223 1
typedef struct lang_input_statement_struct {
d227 3
a229 3
  /* Name to use for the symbol giving address of text start */
  /* Usually the same as filename, but for a file spec'd with -l
     this is the -l switch itself rather than the filename.  */
d243 1
d245 1
a245 2
  union lang_statement_union *next;
  /* Point to the next file, but skips archive contents */
a261 1

d267 4
d283 2
a284 1
typedef struct {
d291 2
a292 1
typedef struct {
d298 2
a299 1
typedef struct lang_wild_statement_struct {
d308 2
a309 1
typedef struct lang_address_statement_struct {
d315 2
a316 1
typedef struct {
d329 2
a330 1
typedef struct {
d335 2
a336 1
typedef union lang_statement_union {
d359 2
a360 1
struct lang_phdr {
d373 2
a374 1
struct lang_nocrossref {
d377 1
a377 1
};
d381 2
a382 1
struct lang_nocrossrefs {
d384 1
a384 1
  struct lang_nocrossref *list;
d392 2
a393 1
struct unique_sections {
d398 9
d421 2
d424 5
a428 5
  PARAMS ((void));
extern struct memory_region_struct *lang_memory_region_lookup
  PARAMS ((const char *const));
extern struct memory_region_struct *lang_memory_region_default
  PARAMS ((asection *));
d430 1
a430 1
  PARAMS ((void));
d432 1
a432 1
  PARAMS ((lang_memory_region_type *, const char *, int));
d434 1
a434 1
  PARAMS ((const char *, int from_script));
d436 6
a441 7
  PARAMS ((const char *output_section_statement_name,
	   etree_type *address_exp,
	   enum section_type sectype,
	   bfd_vma block_value,
	   etree_type *align,
	   etree_type *subalign,
	   etree_type *));
d443 1
a443 1
  PARAMS ((void));
d445 1
a445 1
  PARAMS ((void));
d447 1
a447 1
  PARAMS ((const char *, union etree_union *));
d449 1
a449 1
  PARAMS ((const char *, bfd_boolean));
d451 1
a451 1
  PARAMS ((const char *));
d453 1
a453 1
  PARAMS ((struct wildcard_spec *, struct wildcard_list *, bfd_boolean));
d455 1
a455 1
  PARAMS ((const char *));
d457 3
a459 3
  PARAMS ((fill_type *));
extern lang_assignment_statement_type * lang_add_assignment
  PARAMS ((union etree_union *));
d461 1
a461 1
  PARAMS ((enum statement_enum));
d463 1
a463 1
  PARAMS ((const char *));
d465 1
a465 1
  PARAMS ((bfd_boolean));
d467 2
a468 2
  PARAMS ((fill_type *, const char *, struct lang_output_section_phdr_list *,
           const char *));
d470 1
a470 1
  PARAMS ((const char *, const char *));
d472 1
a472 1
  PARAMS ((const char *, const char *));
d474 2
a475 2
  PARAMS ((struct statement_list *, union lang_statement_union *,
	   union lang_statement_union **));
d477 1
a477 1
  PARAMS ((void (*dothis) (lang_input_statement_type *)));
d479 1
a479 1
  PARAMS ((void (*dothis) (lang_input_statement_type *)));
d481 4
a484 6
  PARAMS ((void));
extern bfd_vma lang_do_assignments
  PARAMS ((lang_statement_union_type * s,
	   lang_output_section_statement_type *output_section_statement,
	   fill_type *fill,
	   bfd_vma dot));
d493 1
a493 1
  PARAMS ((void));
d495 1
a495 1
  PARAMS ((lang_input_statement_type *));
d497 1
a497 1
  PARAMS ((const char * const));
d499 1
a499 2
  PARAMS ((const char *name, lang_input_file_enum_type file_type,
	   const char *target));
d501 1
a501 1
  PARAMS ((const char *filename));
d504 1
a504 1
  PARAMS ((const char * const name));
d506 1
a506 1
  PARAMS ((const char *const name));
d508 1
a508 1
  PARAMS ((const char *, const char *, const char *, int from_script));
d510 1
a510 1
  PARAMS ((lang_statement_list_type*));
d512 1
a512 1
  PARAMS ((int type, union etree_union *));
d514 2
a515 2
  PARAMS ((bfd_reloc_code_real_type reloc, reloc_howto_type *howto,
	   asection *section, const char *name, union etree_union *addend));
d517 3
a519 3
  PARAMS ((void (*func) (lang_statement_union_type *)));
extern PTR stat_alloc
  PARAMS ((size_t size));
d521 1
a521 1
  PARAMS ((lang_statement_union_type *, int));
d523 3
a525 4
  PARAMS ((lang_statement_union_type *s,
	   lang_output_section_statement_type *output_section_statement,
	   lang_statement_union_type **prev, fill_type *fill,
	   bfd_vma dot, bfd_boolean *relax, bfd_boolean check_regions));
d527 1
a527 1
  PARAMS ((void));
d529 1
a529 1
  PARAMS ((void));
d531 2
a532 3
  PARAMS ((lang_statement_list_type *ptr, asection *section,
	   lang_output_section_statement_type *output,
	   lang_input_statement_type *file));
d534 2
a535 2
  PARAMS ((const char *, etree_type *, bfd_boolean, bfd_boolean, etree_type *,
	   etree_type *));
d537 1
a537 1
  PARAMS ((struct lang_nocrossref *));
d539 1
a539 1
  PARAMS ((etree_type *));
d541 1
a541 1
  PARAMS ((const char *));
d543 1
a543 1
  PARAMS ((fill_type *, struct lang_output_section_phdr_list *));
d545 2
a546 2
  PARAMS ((etree_type *, int, fill_type *, const char *,
	   struct lang_output_section_phdr_list *, const char *));
d551 1
a551 1
  PARAMS ((struct bfd_elf_version_expr *, const char *, const char *));
d553 1
a553 1
  PARAMS ((struct bfd_elf_version_expr *, struct bfd_elf_version_expr *));
d555 1
a555 1
  PARAMS ((struct bfd_elf_version_deps *, const char *));
d557 1
a557 2
  PARAMS ((const char *, struct bfd_elf_version_tree *,
	   struct bfd_elf_version_deps *));
d559 1
a559 1
  PARAMS ((const char *));
d561 1
a561 1
  PARAMS ((const char *));
d563 5
a567 1
  PARAMS ((void));
@


1.6
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2001
d10 1
a10 1
   the Free Software Foundation; either version 1, or (at your option)
d35 4
a38 1
typedef unsigned int fill_type;
d54 1
a54 1
  boolean had_full_message;
d112 1
a112 1
  boolean used;
d123 1
a123 1
  boolean processed;
d131 1
a131 1
  fill_type fill;
d138 6
d157 1
a157 1
  fill_type fill;
d214 1
a214 1
  boolean closed;
d228 1
a228 1
  boolean is_archive;
d231 7
a237 1
  boolean search_dirs_flag;
d243 1
a243 1
  boolean just_syms_flag;
d246 1
a246 1
  boolean dynamic;
d249 1
a249 1
  boolean whole_archive;
d251 1
a251 1
  boolean loaded;
d257 1
a257 1
  boolean real;
a274 2
  const char *section_name;
  boolean sections_sorted;
d276 3
a278 3
  boolean filenames_sorted;
  boolean keep_sections;
  struct name_list *exclude_filename_list;
d293 1
a293 1
  fill_type fill;
a307 1
  union lang_statement_union *next;
d333 2
a334 2
  boolean filehdr;
  boolean phdrs;
d368 1
a368 1
extern boolean lang_has_input_file;
d371 1
a371 1
extern boolean delete_output_file_on_failure;
d373 3
a375 2
extern const char *entry_symbol;
extern boolean entry_from_cmdline;
d378 2
a379 1
extern void lang_init PARAMS ((void));
d384 6
a389 4
extern void lang_map PARAMS ((void));
extern void lang_set_flags PARAMS ((lang_memory_region_type *, const char *,
				    int));
extern void lang_add_output PARAMS ((const char *, int from_script));
d392 1
a392 1
	   etree_type * address_exp,
d398 10
a407 5
extern void lang_final PARAMS ((void));
extern void lang_process PARAMS ((void));
extern void lang_section_start PARAMS ((const char *, union etree_union *));
extern void lang_add_entry PARAMS ((const char *, boolean));
extern void lang_add_target PARAMS ((const char *));
d409 13
a421 7
  PARAMS ((const char *, boolean, const char *, boolean, boolean, name_list *));
extern void lang_add_map PARAMS ((const char *));
extern void lang_add_fill PARAMS ((int));
extern lang_assignment_statement_type * lang_add_assignment PARAMS ((union etree_union *));
extern void lang_add_attribute PARAMS ((enum statement_enum));
extern void lang_startup PARAMS ((const char *));
extern void lang_float PARAMS ((enum bfd_boolean));
d423 1
a423 1
  PARAMS ((bfd_vma, const char *, struct lang_output_section_phdr_list *,
d425 7
a431 6
extern void lang_abs_symbol_at_end_of PARAMS ((const char *, const char *));
extern void lang_abs_symbol_at_beginning_of PARAMS ((const char *,
						     const char *));
extern void lang_statement_append PARAMS ((struct statement_list *,
					   union lang_statement_union *,
					   union lang_statement_union **));
d436 2
d441 1
a441 1
	   fill_type fill,
d444 10
a453 8
#define LANG_FOR_EACH_INPUT_STATEMENT(statement)		\
  lang_input_statement_type *statement;				\
  for (statement = (lang_input_statement_type *)file_chain.head;\
       statement != (lang_input_statement_type *)NULL;		\
       statement = (lang_input_statement_type *)statement->next)\

extern void lang_process PARAMS ((void));
extern void ldlang_add_file PARAMS ((lang_input_statement_type *));
d459 2
a460 1
extern void lang_add_keepsyms_file PARAMS ((const char *filename));
d462 10
a471 6
  lang_output_section_statement_lookup PARAMS ((const char * const name));
extern void ldlang_add_undef PARAMS ((const char *const name));
extern void lang_add_output_format PARAMS ((const char *, const char *,
					    const char *, int from_script));
extern void lang_list_init PARAMS ((lang_statement_list_type*));
extern void lang_add_data PARAMS ((int type, union etree_union *));
d477 4
a480 2
extern PTR stat_alloc PARAMS ((size_t size));
extern void dprint_statement PARAMS ((lang_statement_union_type *, int));
d484 7
a490 5
	   lang_statement_union_type **prev, fill_type fill,
	   bfd_vma dot, boolean relax));
extern void lang_enter_group PARAMS ((void));
extern void lang_leave_group PARAMS ((void));
extern void wild_doit
d495 1
a495 1
  PARAMS ((const char *, etree_type *, boolean, boolean, etree_type *,
d497 6
a502 3
extern void lang_add_nocrossref PARAMS ((struct lang_nocrossref *));
extern void lang_enter_overlay PARAMS ((etree_type *, etree_type *, int));
extern void lang_enter_overlay_section PARAMS ((const char *));
d504 1
a504 1
  PARAMS ((bfd_vma, struct lang_output_section_phdr_list *));
d506 2
a507 2
  PARAMS ((bfd_vma, const char *, struct lang_output_section_phdr_list *,
           const char *));
d511 1
a511 1
extern struct bfd_elf_version_expr *lang_new_vers_regex
d520 6
a525 2
boolean unique_section_p PARAMS ((const char *));
extern void lang_add_unique PARAMS ((const char *));
@


1.5
log
@Automatic cvs merge. Dread what I will have to fix after this excuse
of a program is done...
@
text
@d2 2
a3 1
   Copyright 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d5 1
a5 1
   
d7 1
a7 1
   
d12 1
a12 1
   
d17 1
a17 1
   
d26 1
a26 2
typedef enum
{
d36 2
a37 2
typedef struct statement_list
{
d42 1
a42 3

typedef struct memory_region_struct
{
d52 1
a52 1
} lang_memory_region_type ;
d54 21
a74 23
typedef struct lang_statement_header_struct 
{
  union  lang_statement_union  *next;
  enum statement_enum
    {
      lang_output_section_statement_enum,
      lang_assignment_statement_enum,
      lang_input_statement_enum,
      lang_address_statement_enum,
      lang_wild_statement_enum,
      lang_input_section_enum,
      lang_object_symbols_statement_enum,
      lang_fill_statement_enum,
      lang_data_statement_enum,
      lang_reloc_statement_enum,
      lang_target_statement_enum,
      lang_output_statement_enum,
      lang_padding_statement_enum,
      lang_group_statement_enum,

      lang_afile_asection_pair_statement_enum,
      lang_constructors_statement_enum
    } type;
d77 1
a77 3

typedef struct 
{
d82 1
a82 3

typedef struct lang_target_statement_struct
{
d87 1
a87 3

typedef struct lang_output_statement_struct
{
d94 1
a94 2
enum section_type
{
d106 1
a106 2
struct lang_output_section_phdr_list
{
d112 1
a112 2
typedef struct lang_output_section_statement_struct 
{
d121 1
a121 1
    
d130 2
a131 2
  int subsection_alignment;  /* alignment of components */
  int section_alignment;  /* alignment of start of section */
d138 1
a138 3

typedef struct
{
d142 1
a142 2
typedef struct
{
d146 1
a146 2
typedef struct
{
d153 1
a153 2
typedef struct
{
d156 1
a156 1
  union  etree_union *exp;
d164 1
a164 2
typedef struct
{
d194 1
a194 2
typedef struct lang_input_statement_struct
{
d202 1
a202 1
    
d204 1
a204 1
    
d207 1
a207 1
    
d211 1
a211 1
    
d214 2
a215 2
    
  union lang_statement_union  *next;
d217 2
a218 2
  union  lang_statement_union  *next_real_file;
    
d220 1
a220 1
    
d223 1
a223 1
    
d226 2
a227 2
     Also default text_start to after this file's bss. */
    
d237 4
a240 2
    
  /*    unsigned int globals_in_this_file;*/
d245 1
a245 2
typedef struct
{
d249 1
a249 1
  
d252 1
a252 3

typedef struct
{
d258 1
a258 2
typedef struct lang_wild_statement_struct
{
d269 1
a269 2
typedef struct lang_address_statement_struct
{
d271 2
a272 2
  const  char *section_name;
  union  etree_union *address;
d275 1
a275 2
typedef struct
{
d288 1
a288 2
typedef struct
{
d293 1
a293 2
typedef union lang_statement_union 
{
d317 1
a317 2
struct lang_phdr
{
d330 1
a330 2
struct lang_nocrossref
{
d337 1
a337 2
struct lang_nocrossrefs
{
d344 10
d363 1
a414 1
  extern lang_statement_list_type file_chain;			\
d419 1
a419 1
  
d476 2
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d374 1
d392 1
a392 1
extern void lang_enter_output_section_statement
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2 2
a3 1
   Copyright 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d18 3
a20 2
   along with GLD; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d51 2
a52 1
  int flags;
d136 1
a136 1
  int flags;			/* Or together of all input sections */
d139 1
d283 1
d285 3
d385 2
d388 2
a389 1
extern void lang_set_flags PARAMS ((int *, const char *));
d404 2
a405 1
extern void lang_add_wild PARAMS ((const char *const , const char *const));
d408 1
a408 1
extern void lang_add_assignment PARAMS ((union etree_union *));
d413 2
a414 1
  PARAMS ((bfd_vma, const char *, struct lang_output_section_phdr_list *));
d459 1
d480 14
a493 1
  PARAMS ((bfd_vma, const char *, struct lang_output_section_phdr_list *));
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d99 11
d134 1
a134 1
  int loadable;			/* set from NOLOAD flag in script */
a256 3
  asection *common_section;
  asection *common_output_section;
  boolean complained;
d346 19
d383 1
a383 1
	   int flags,
d400 2
a401 2
extern void lang_leave_output_section_statement PARAMS ((bfd_vma,
							 const char *));
d460 7
a466 1
extern void lang_section_in_phdr PARAMS ((const char *));
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
d100 10
d131 3
a133 1
  union etree_union *load_base;  
d238 3
d324 14
d430 4
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 1
a2 1
   Copyright 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
a99 10
/* This structure holds a list of program headers describing segments
   in which this section should be placed.  */

struct lang_output_section_phdr_list
{
  struct lang_output_section_phdr_list *next;
  const char *name;
  boolean used;
};

d121 1
a121 3
  union etree_union *load_base;

  struct lang_output_section_phdr_list *phdrs;
a225 3
  /* Whether to include the entire contents of an archive.  */
  boolean whole_archive;

a308 14
/* This structure holds information about a program header, from the
   PHDRS command in the linker script.  */

struct lang_phdr
{
  struct lang_phdr *next;
  const char *name;
  unsigned long type;
  boolean filehdr;
  boolean phdrs;
  etree_type *at;
  etree_type *flags;
};

a400 4
extern void lang_new_phdr
  PARAMS ((const char *, etree_type *, boolean, boolean, etree_type *,
	   etree_type *));
extern void lang_section_in_phdr PARAMS ((const char *));
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a98 11
/* Section types specified in a linker script.  */

enum section_type
{
  normal_section,
  dsect_section,
  copy_section,
  noload_section,
  info_section,
  overlay_section
};
d123 1
a123 1
  enum section_type sectype;
d246 3
a337 19
/* This structure is used to hold a list of sections which may not
   cross reference each other.  */

struct lang_nocrossref
{
  struct lang_nocrossref *next;
  const char *name;
};

/* The list of nocrossref lists.  */

struct lang_nocrossrefs
{
  struct lang_nocrossrefs *next;
  struct lang_nocrossref *list;
};

extern struct lang_nocrossrefs *nocrossref_list;

d356 1
a356 1
	   enum section_type sectype,
d373 2
a374 2
extern void lang_leave_output_section_statement
  PARAMS ((bfd_vma, const char *, struct lang_output_section_phdr_list *));
d433 1
a433 7
extern void lang_add_nocrossref PARAMS ((struct lang_nocrossref *));
extern void lang_enter_overlay PARAMS ((etree_type *, etree_type *, int));
extern void lang_enter_overlay_section PARAMS ((const char *));
extern void lang_leave_overlay_section
  PARAMS ((bfd_vma, struct lang_output_section_phdr_list *));
extern void lang_leave_overlay
  PARAMS ((bfd_vma, const char *, struct lang_output_section_phdr_list *));
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright 1991, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d17 2
a18 3
   along with GLD; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
a445 1
extern void dprint_statement PARAMS ((lang_statement_union_type *, int));
a466 12

extern struct bfd_elf_version_tree *lang_elf_version_info;

extern struct bfd_elf_version_expr *lang_new_vers_regex
  PARAMS ((struct bfd_elf_version_expr *, const char *));
extern struct bfd_elf_version_tree *lang_new_vers_node
  PARAMS ((struct bfd_elf_version_expr *, struct bfd_elf_version_expr *));
extern struct bfd_elf_version_deps *lang_add_vers_depend
  PARAMS ((struct bfd_elf_version_deps *, const char *));
extern void lang_register_vers_node
  PARAMS ((const char *, struct bfd_elf_version_tree *,
	   struct bfd_elf_version_deps *));
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
d50 1
a50 2
  flagword flags;
  flagword not_flags;
d134 1
a134 1
  flagword flags;		/* Or together of all input sections */
a136 1
  struct memory_region_struct *lma_region;
a279 1
  boolean sections_sorted;
a280 3
  boolean filenames_sorted;
  boolean keep_sections;
  struct name_list *exclude_filename_list;
a377 2
extern struct memory_region_struct *lang_memory_region_default
  PARAMS ((asection *));
d379 1
a379 2
extern void lang_set_flags PARAMS ((lang_memory_region_type *, const char *,
				    int));
d394 1
a394 2
extern void lang_add_wild
  PARAMS ((const char *, boolean, const char *, boolean, boolean, name_list *));
d397 1
a397 1
extern lang_assignment_statement_type * lang_add_assignment PARAMS ((union etree_union *));
d402 1
a402 2
  PARAMS ((bfd_vma, const char *, struct lang_output_section_phdr_list *,
           const char *));
d468 1
a468 2
  PARAMS ((bfd_vma, const char *, struct lang_output_section_phdr_list *,
           const char *));
d473 1
a473 1
  PARAMS ((struct bfd_elf_version_expr *, const char *, const char *));
@


1.1.1.6
log
@Long delayed import of binutils-2.10.1. Turns out art@@ needs some alpha
bug-fixes...
@
text
@a373 1
extern lang_statement_list_type lang_output_section_statement;
d391 1
a391 1
extern lang_output_section_statement_type *lang_enter_output_section_statement
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001
d4 1
a4 1

d6 1
a6 1

d11 1
a11 1

d16 1
a16 1

d25 2
a26 1
typedef enum {
d36 2
a37 2

typedef struct statement_list {
d42 3
a44 1
typedef struct memory_region_struct {
d54 1
a54 1
} lang_memory_region_type;
d56 23
a78 21
typedef struct lang_statement_header_struct {
  union lang_statement_union *next;
  enum statement_enum {
    lang_output_section_statement_enum,
    lang_assignment_statement_enum,
    lang_input_statement_enum,
    lang_address_statement_enum,
    lang_wild_statement_enum,
    lang_input_section_enum,
    lang_object_symbols_statement_enum,
    lang_fill_statement_enum,
    lang_data_statement_enum,
    lang_reloc_statement_enum,
    lang_target_statement_enum,
    lang_output_statement_enum,
    lang_padding_statement_enum,
    lang_group_statement_enum,

    lang_afile_asection_pair_statement_enum,
    lang_constructors_statement_enum
  } type;
d81 3
a83 1
typedef struct {
d88 3
a90 1
typedef struct lang_target_statement_struct {
d95 3
a97 1
typedef struct lang_output_statement_struct {
d104 2
a105 1
enum section_type {
d117 2
a118 1
struct lang_output_section_phdr_list {
d124 2
a125 1
typedef struct lang_output_section_statement_struct {
d134 1
a134 1

d143 2
a144 2
  int subsection_alignment;	/* alignment of components */
  int section_alignment;	/* alignment of start of section */
d151 3
a153 1
typedef struct {
d157 2
a158 1
typedef struct {
d162 2
a163 1
typedef struct {
d170 2
a171 1
typedef struct {
d174 1
a174 1
  union etree_union *exp;
d182 2
a183 1
typedef struct {
d213 2
a214 1
typedef struct lang_input_statement_struct {
d222 1
a222 1

d224 1
a224 1

d227 1
a227 1

d231 1
a231 1

d234 2
a235 2

  union lang_statement_union *next;
d237 2
a238 2
  union lang_statement_union *next_real_file;

d240 1
a240 1

d243 1
a243 1

d246 2
a247 2
     Also default text_start to after this file's bss.  */

d257 2
a258 4

#if 0
  unsigned int globals_in_this_file;
#endif
d263 2
a264 1
typedef struct {
d268 2
a270 1
} lang_input_section_type;
d272 2
a273 1
typedef struct {
d279 2
a280 1
typedef struct lang_wild_statement_struct {
d291 2
a292 1
typedef struct lang_address_statement_struct {
d294 2
a295 2
  const char *section_name;
  union etree_union *address;
d298 2
a299 1
typedef struct {
d312 2
a313 1
typedef struct {
d318 2
a319 1
typedef union lang_statement_union {
d343 2
a344 1
struct lang_phdr {
d357 2
a358 1
struct lang_nocrossref {
d365 2
a366 1
struct lang_nocrossrefs {
a372 10
/* This structure is used to hold a list of input section names which
   will not match an output section in the linker script.  */

struct unique_sections {
  struct unique_sections *next;
  const char *name;
};

extern struct unique_sections *unique_section_list;

a381 1
extern lang_statement_list_type file_chain;
d433 1
d438 1
a438 1

a494 2
boolean unique_section_p PARAMS ((const char *));
extern void lang_add_unique PARAMS ((const char *));
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2001, 2002, 2003
d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
d35 1
a35 4
struct _fill_type {
  size_t size;
  unsigned char data[1];
};
d51 1
a51 1
  bfd_boolean had_full_message;
d109 1
a109 1
  bfd_boolean used;
d120 1
a120 1
  bfd_boolean processed;
d128 1
a128 1
  fill_type *fill;
a134 6
  /* If non-null, an expression to evaluate after setting the section's
     size.  The expression is evaluated inside REGION (above) with '.'
     set to the end of the section.  Used in the last overlay section
     to move '.' past all the overlaid sections.  */
  union etree_union *update_dot_tree;

d148 1
a148 1
  fill_type *fill;
d205 1
a205 1
  bfd_boolean closed;
d219 1
a219 1
  bfd_boolean is_archive;
d222 1
a222 7
  bfd_boolean search_dirs_flag;

  /* 1 means this was found in a search directory marked as sysrooted,
     if search_dirs_flag is false, otherwise, that it should be
     searched in ld_sysroot before any other location, as long as it
     starts with a slash.  */
  bfd_boolean sysrooted;
d228 1
a228 1
  bfd_boolean just_syms_flag;
d231 1
a231 1
  bfd_boolean dynamic;
d234 1
a234 1
  bfd_boolean whole_archive;
d236 1
a236 1
  bfd_boolean loaded;
d242 1
a242 1
  bfd_boolean real;
d260 2
d263 3
a265 3
  bfd_boolean filenames_sorted;
  struct wildcard_list *section_list;
  bfd_boolean keep_sections;
d280 1
a280 1
  fill_type *fill;
d295 1
d321 2
a322 2
  bfd_boolean filehdr;
  bfd_boolean phdrs;
d356 1
a356 1
extern bfd_boolean lang_has_input_file;
d359 1
a359 1
extern bfd_boolean delete_output_file_on_failure;
d361 2
a362 3
extern struct bfd_sym_chain entry_symbol;
extern const char *entry_section;
extern bfd_boolean entry_from_cmdline;
d365 1
a365 2
extern void lang_init
  PARAMS ((void));
d370 4
a373 6
extern void lang_map
  PARAMS ((void));
extern void lang_set_flags
  PARAMS ((lang_memory_region_type *, const char *, int));
extern void lang_add_output
  PARAMS ((const char *, int from_script));
d376 1
a376 1
	   etree_type *address_exp,
d382 5
a386 10
extern void lang_final
  PARAMS ((void));
extern void lang_process
  PARAMS ((void));
extern void lang_section_start
  PARAMS ((const char *, union etree_union *));
extern void lang_add_entry
  PARAMS ((const char *, bfd_boolean));
extern void lang_add_target
  PARAMS ((const char *));
d388 7
a394 13
  PARAMS ((struct wildcard_spec *, struct wildcard_list *, bfd_boolean));
extern void lang_add_map
  PARAMS ((const char *));
extern void lang_add_fill
  PARAMS ((fill_type *));
extern lang_assignment_statement_type * lang_add_assignment
  PARAMS ((union etree_union *));
extern void lang_add_attribute
  PARAMS ((enum statement_enum));
extern void lang_startup
  PARAMS ((const char *));
extern void lang_float
  PARAMS ((bfd_boolean));
d396 1
a396 1
  PARAMS ((fill_type *, const char *, struct lang_output_section_phdr_list *,
d398 6
a403 7
extern void lang_abs_symbol_at_end_of
  PARAMS ((const char *, const char *));
extern void lang_abs_symbol_at_beginning_of
  PARAMS ((const char *, const char *));
extern void lang_statement_append
  PARAMS ((struct statement_list *, union lang_statement_union *,
	   union lang_statement_union **));
a407 2
extern void lang_reset_memory_regions
  PARAMS ((void));
d411 1
a411 1
	   fill_type *fill,
d414 8
a421 10
#define LANG_FOR_EACH_INPUT_STATEMENT(statement)			\
  lang_input_statement_type *statement;					\
  for (statement = (lang_input_statement_type *) file_chain.head;	\
       statement != (lang_input_statement_type *) NULL;			\
       statement = (lang_input_statement_type *) statement->next)	\

extern void lang_process
  PARAMS ((void));
extern void ldlang_add_file
  PARAMS ((lang_input_statement_type *));
d427 1
a427 2
extern void lang_add_keepsyms_file
  PARAMS ((const char *filename));
d429 6
a434 10
  lang_output_section_statement_lookup
  PARAMS ((const char * const name));
extern void ldlang_add_undef
  PARAMS ((const char *const name));
extern void lang_add_output_format
  PARAMS ((const char *, const char *, const char *, int from_script));
extern void lang_list_init
  PARAMS ((lang_statement_list_type*));
extern void lang_add_data
  PARAMS ((int type, union etree_union *));
d440 2
a441 4
extern PTR stat_alloc
  PARAMS ((size_t size));
extern void dprint_statement
  PARAMS ((lang_statement_union_type *, int));
d445 5
a449 7
	   lang_statement_union_type **prev, fill_type *fill,
	   bfd_vma dot, bfd_boolean *relax, bfd_boolean check_regions));
extern void lang_enter_group
  PARAMS ((void));
extern void lang_leave_group
  PARAMS ((void));
extern void lang_add_section
d454 1
a454 1
  PARAMS ((const char *, etree_type *, bfd_boolean, bfd_boolean, etree_type *,
d456 3
a458 6
extern void lang_add_nocrossref
  PARAMS ((struct lang_nocrossref *));
extern void lang_enter_overlay
  PARAMS ((etree_type *));
extern void lang_enter_overlay_section
  PARAMS ((const char *));
d460 1
a460 1
  PARAMS ((fill_type *, struct lang_output_section_phdr_list *));
d462 2
a463 2
  PARAMS ((etree_type *, int, fill_type *, const char *,
	   struct lang_output_section_phdr_list *, const char *));
d467 1
a467 1
extern struct bfd_elf_version_expr *lang_new_vers_pattern
d476 2
a477 6
bfd_boolean unique_section_p
  PARAMS ((const char *));
extern void lang_add_unique
  PARAMS ((const char *));
extern const char *lang_get_output_target
  PARAMS ((void));
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004
d26 1
a26 4
#define DEFAULT_MEMORY_REGION   "*default*"

typedef enum
{
d35 1
a35 2
struct _fill_type
{
d40 1
a40 2
typedef struct statement_list
{
d45 1
a45 2
typedef struct memory_region_struct
{
d57 1
a57 2
typedef struct lang_statement_header_struct
{
d59 1
a59 2
  enum statement_enum
  {
d80 1
a80 2
typedef struct
{
d85 1
a85 2
typedef struct lang_target_statement_struct
{
d90 1
a90 2
typedef struct lang_output_statement_struct
{
d97 1
a97 2
enum section_type
{
d106 2
a107 2
/* This structure holds a list of program headers describing
   segments in which this section should be placed.  */
d109 1
a109 2
typedef struct lang_output_section_phdr_list
{
d113 1
a113 1
} lang_output_section_phdr_list;
d115 1
a115 2
typedef struct lang_output_section_statement_struct
{
d123 1
a123 1
  int processed;
d126 1
a126 1
  flagword flags;		/* Or together of all input sections.  */
d128 2
a129 2
  lang_memory_region_type *region;
  lang_memory_region_type *lma_region;
d133 2
a134 2
  int subsection_alignment;	/* Alignment of components.  */
  int section_alignment;	/* Alignment of start of section.  */
d144 1
a144 1
  lang_output_section_phdr_list *phdrs;
d147 1
a147 2
typedef struct
{
d151 1
a151 2
typedef struct
{
d155 1
a155 2
typedef struct
{
d162 1
a162 2
typedef struct
{
d173 1
a173 2
typedef struct
{
d182 2
a183 2
  /* Section to generate reloc against.
     Exactly one of section and name must be NULL.  */
d186 2
a187 2
  /* Name of symbol to generate reloc against.
     Exactly one of section and name must be NULL.  */
d203 1
a203 2
typedef struct lang_input_statement_struct
{
d207 3
a209 3
  /* Name to use for the symbol giving address of text start.
     Usually the same as filename, but for a file spec'd with
     -l this is the -l switch itself rather than the filename.  */
d223 1
d225 1
a225 2

  /* Point to the next file, but skips archive contents.  */
d242 1
a247 4
  /* Whether this entry should cause a DT_NEEDED tag only when
     satisfying references from regular files, or always.  */
  bfd_boolean as_needed;

d260 1
a260 2
typedef struct
{
d267 1
a267 2
typedef struct
{
d273 1
a273 2
typedef struct lang_wild_statement_struct
{
d282 1
a282 2
typedef struct lang_address_statement_struct
{
d288 1
a288 2
typedef struct
{
d301 1
a301 2
typedef struct
{
d306 1
a306 2
typedef union lang_statement_union
{
d329 1
a329 2
struct lang_phdr
{
d342 1
a342 2
typedef struct lang_nocrossref
{
d345 1
a345 1
} lang_nocrossref_type;
d349 1
a349 2
struct lang_nocrossrefs
{
d351 1
a351 1
  lang_nocrossref_type *list;
d359 1
a359 2
struct unique_sections
{
a363 9
/* This structure records symbols for which we need to keep track of
   definedness for use in the DEFINED () test.  */

struct lang_definedness_hash_entry
{
  struct bfd_hash_entry root;
  int iteration;
};

a377 2
extern int lang_statement_iteration;

d379 5
a383 5
  (void);
extern lang_memory_region_type *lang_memory_region_lookup
  (const char *const, bfd_boolean);
extern lang_memory_region_type *lang_memory_region_default
  (asection *);
d385 1
a385 1
  (void);
d387 1
a387 1
  (lang_memory_region_type *, const char *, int);
d389 1
a389 1
  (const char *, int from_script);
d391 7
a397 6
  (const char *output_section_statement_name,
   etree_type *address_exp,
   enum section_type sectype,
   etree_type *align,
   etree_type *subalign,
   etree_type *);
d399 1
a399 1
  (void);
d401 1
a401 1
  (void);
d403 1
a403 1
  (const char *, union etree_union *);
d405 1
a405 1
  (const char *, bfd_boolean);
d407 1
a407 1
  (const char *);
d409 1
a409 1
  (struct wildcard_spec *, struct wildcard_list *, bfd_boolean);
d411 1
a411 1
  (const char *);
d413 3
a415 3
  (fill_type *);
extern lang_assignment_statement_type *lang_add_assignment
  (union etree_union *);
d417 1
a417 1
  (enum statement_enum);
d419 1
a419 1
  (const char *);
d421 1
a421 1
  (bfd_boolean);
d423 2
a424 2
  (fill_type *, const char *, lang_output_section_phdr_list *,
   const char *);
d426 1
a426 1
  (const char *, const char *);
d428 1
a428 1
  (const char *, const char *);
d430 2
a431 2
  (lang_statement_list_type *, lang_statement_union_type *,
   lang_statement_union_type **);
d433 1
a433 1
  (void (*dothis) (lang_input_statement_type *));
d435 1
a435 1
  (void (*dothis) (lang_input_statement_type *));
d437 6
a442 4
  (void);
extern void lang_do_assignments
  (lang_statement_union_type *, lang_output_section_statement_type *,
   fill_type *, bfd_vma);
d451 1
a451 1
  (void);
d453 1
a453 1
  (lang_input_statement_type *);
d455 1
a455 1
  (const char * const);
d457 2
a458 1
  (const char *, lang_input_file_enum_type, const char *);
d460 1
a460 1
  (const char *);
d463 1
a463 1
  (const char *const);
d465 1
a465 1
  (const char *const);
d467 1
a467 1
  (const char *, const char *, const char *, int);
d469 1
a469 1
  (lang_statement_list_type *);
d471 1
a471 1
  (int type, union etree_union *);
d473 2
a474 2
  (bfd_reloc_code_real_type, reloc_howto_type *, asection *, const char *,
   union etree_union *);
d476 3
a478 3
  (void (*) (lang_statement_union_type *));
extern void *stat_alloc
  (size_t);
d480 1
a480 1
  (lang_statement_union_type *, int);
d482 4
a485 3
  (lang_statement_union_type *, lang_output_section_statement_type *,
   lang_statement_union_type **, fill_type *, bfd_vma, bfd_boolean *,
   bfd_boolean);
d487 1
a487 1
  (void);
d489 1
a489 1
  (void);
d491 3
a493 2
  (lang_statement_list_type *, asection *,
   lang_output_section_statement_type *, lang_input_statement_type *);
d495 2
a496 2
  (const char *, etree_type *, bfd_boolean, bfd_boolean, etree_type *,
   etree_type *);
d498 1
a498 1
  (lang_nocrossref_type *);
d500 1
a500 1
  (etree_type *, etree_type *);
d502 1
a502 1
  (const char *);
d504 1
a504 1
  (fill_type *, lang_output_section_phdr_list *);
d506 2
a507 2
  (etree_type *, int, fill_type *, const char *,
   lang_output_section_phdr_list *, const char *);
d512 1
a512 1
  (struct bfd_elf_version_expr *, const char *, const char *);
d514 1
a514 1
  (struct bfd_elf_version_expr *, struct bfd_elf_version_expr *);
d516 1
a516 1
  (struct bfd_elf_version_deps *, const char *);
d518 2
a519 1
  (const char *, struct bfd_elf_version_tree *, struct bfd_elf_version_deps *);
d521 1
a521 1
  (const char *);
d523 1
a523 1
  (const char *);
d525 1
a525 5
  (void);
extern void lang_track_definedness (const char *);
extern int lang_symbol_definition_iteration (const char *);
extern void lang_update_definedness
  (const char *, struct bfd_link_hash_entry *);
@


