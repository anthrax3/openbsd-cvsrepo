head	1.12;
access;
symbols
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.12
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.8
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.4
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.10.0.10
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.8
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.4
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.9.0.32
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.30
	OPENBSD_5_0:1.9.0.28
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.26
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.24
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.20
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.22
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.18
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.16
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.14
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.12
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.7.0.6
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2014.12.22.14.09.58;	author kettenis;	state Exp;
branches;
next	1.11;
commitid	mlKqkMkgtkgOcmHH;

1.11
date	2014.08.31.13.40.03;	author tobiasu;	state Exp;
branches;
next	1.10;
commitid	dbwlUkpK0xDlII16;

1.10
date	2012.08.28.18.59.28;	author pascal;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.02.20.45.48;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.17.21.54.50;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.17.20.50.13;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.42;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.12.45;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.52.32;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.09.31;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.54.25;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.16;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.16;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.35.35;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.35.05;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.38.40;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.28.34;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.48.09;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.14.01.18;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.49;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.23.22;	author miod;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Teach ld(1) not to add a PT_INTERP entry for -static -pie.

ok kurt@@
@
text
@/* Main program of GNU linker.
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004
   Free Software Foundation, Inc.
   Written by Steve Chamberlain steve@@cygnus.com

   This file is part of GLD, the Gnu Linker.

   GLD is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GLD is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GLD; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include <stdio.h>
#include "safe-ctype.h"
#include "libiberty.h"
#include "progress.h"
#include "bfdlink.h"
#include "filenames.h"

#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"
#include "ldwrite.h"
#include "ldexp.h"
#include "ldlang.h"
#include <ldgram.h>
#include "ldlex.h"
#include "ldfile.h"
#include "ldemul.h"
#include "ldctor.h"

/* Somewhere above, sys/stat.h got included.  */
#if !defined(S_ISDIR) && defined(S_IFDIR)
#define	S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#endif

#include <string.h>

#ifdef HAVE_SBRK
#ifdef NEED_DECLARATION_SBRK
extern void *sbrk ();
#endif
#endif

#ifndef TARGET_SYSTEM_ROOT
#define TARGET_SYSTEM_ROOT ""
#endif

/* EXPORTS */

char *default_target;
const char *output_filename = "a.out";

/* Name this program was invoked by.  */
char *program_name;

/* The prefix for system library directories.  */
char *ld_sysroot;

/* The canonical representation of ld_sysroot.  */
char * ld_canon_sysroot;
int ld_canon_sysroot_len;

/* The file that we're creating.  */
bfd *output_bfd = 0;

/* Set by -G argument, for MIPS ECOFF target.  */
int g_switch_value = 8;

/* Nonzero means print names of input files as processed.  */
bfd_boolean trace_files;

/* Nonzero means same, but note open failures, too.  */
bfd_boolean trace_file_tries;

/* Nonzero means version number was printed, so exit successfully
   instead of complaining if no input files are given.  */
bfd_boolean version_printed;

/* Nonzero means link in every member of an archive.  */
bfd_boolean whole_archive;

/* Nonzero means create DT_NEEDED entries only if a dynamic library
   actually satisfies some reference in a regular object.  */
bfd_boolean as_needed;

/* TRUE if we should demangle symbol names.  */
bfd_boolean demangling;

args_type command_line;

ld_config_type config;

static char *get_emulation
  (int, char **);
static void set_scripts_dir
  (void);
static bfd_boolean add_archive_element
  (struct bfd_link_info *, bfd *, const char *);
static bfd_boolean multiple_definition
  (struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma,
   bfd *, asection *, bfd_vma);
static bfd_boolean multiple_common
  (struct bfd_link_info *, const char *, bfd *, enum bfd_link_hash_type,
   bfd_vma, bfd *, enum bfd_link_hash_type, bfd_vma);
static bfd_boolean add_to_set
  (struct bfd_link_info *, struct bfd_link_hash_entry *,
   bfd_reloc_code_real_type, bfd *, asection *, bfd_vma);
static bfd_boolean constructor_callback
  (struct bfd_link_info *, bfd_boolean, const char *, bfd *,
   asection *, bfd_vma);
static bfd_boolean warning_callback
  (struct bfd_link_info *, const char *, const char *, bfd *,
   asection *, bfd_vma);
static void warning_find_reloc
  (bfd *, asection *, void *);
static bfd_boolean undefined_symbol
  (struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma,
   bfd_boolean);
static bfd_boolean reloc_overflow
  (struct bfd_link_info *, const char *, const char *, bfd_vma,
   bfd *, asection *, bfd_vma);
static bfd_boolean reloc_dangerous
  (struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma);
static bfd_boolean unattached_reloc
  (struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma);
static bfd_boolean notice
  (struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma);

static struct bfd_link_callbacks link_callbacks =
{
  add_archive_element,
  multiple_definition,
  multiple_common,
  add_to_set,
  constructor_callback,
  warning_callback,
  undefined_symbol,
  reloc_overflow,
  reloc_dangerous,
  unattached_reloc,
  notice,
  error_handler
};

struct bfd_link_info link_info;

static void
remove_output (void)
{
  if (output_filename)
    {
      if (output_bfd)
	bfd_cache_close (output_bfd);
      if (delete_output_file_on_failure)
	unlink (output_filename);
    }
}

int
main (int argc, char **argv)
{
  char *emulation;
  long start_time = get_run_time ();

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = argv[0];
  xmalloc_set_program_name (program_name);

  START_PROGRESS (program_name, 0);

  expandargv (&argc, &argv);

  bfd_init ();

  bfd_set_error_program_name (program_name);

  xatexit (remove_output);

#ifdef TARGET_SYSTEM_ROOT_RELOCATABLE
  ld_sysroot = make_relative_prefix (program_name, BINDIR,
				     TARGET_SYSTEM_ROOT);

  if (ld_sysroot)
    {
      struct stat s;
      int res = stat (ld_sysroot, &s) == 0 && S_ISDIR (s.st_mode);

      if (!res)
	{
	  free (ld_sysroot);
	  ld_sysroot = NULL;
	}
    }

  if (! ld_sysroot)
    {
      ld_sysroot = make_relative_prefix (program_name, TOOLBINDIR,
					 TARGET_SYSTEM_ROOT);

      if (ld_sysroot)
	{
	  struct stat s;
	  int res = stat (ld_sysroot, &s) == 0 && S_ISDIR (s.st_mode);

	  if (!res)
	    {
	      free (ld_sysroot);
	      ld_sysroot = NULL;
	    }
	}
    }

  if (! ld_sysroot)
#endif
    ld_sysroot = TARGET_SYSTEM_ROOT;

  if (ld_sysroot && *ld_sysroot)
    ld_canon_sysroot = lrealpath (ld_sysroot);

  if (ld_canon_sysroot)
    ld_canon_sysroot_len = strlen (ld_canon_sysroot);
  else
    ld_canon_sysroot_len = -1;

  /* Set the default BFD target based on the configured target.  Doing
     this permits the linker to be configured for a particular target,
     and linked against a shared BFD library which was configured for
     a different target.  The macro TARGET is defined by Makefile.  */
  if (! bfd_set_default_target (TARGET))
    {
      einfo (_("%X%P: can't set BFD default target to `%s': %E\n"), TARGET);
      xexit (1);
    }

#if YYDEBUG
  {
    extern int yydebug;
    yydebug = 1;
  }
#endif

  /* Initialize the data about options.  */
  trace_files = trace_file_tries = version_printed = FALSE;
  whole_archive = FALSE;
  config.build_constructors = TRUE;
  config.dynamic_link = FALSE;
  config.has_shared = FALSE;
  config.split_by_reloc = (unsigned) -1;
  config.split_by_file = (bfd_size_type) -1;
  command_line.force_common_definition = FALSE;
  command_line.inhibit_common_definition = FALSE;
  command_line.interpreter = NULL;
  command_line.rpath = NULL;
  command_line.warn_mismatch = TRUE;
  command_line.check_section_addresses = TRUE;
  command_line.accept_unknown_input_arch = FALSE;

  /* We initialize DEMANGLING based on the environment variable
     COLLECT_NO_DEMANGLE.  The gcc collect2 program will demangle the
     output of the linker, unless COLLECT_NO_DEMANGLE is set in the
     environment.  Acting the same way here lets us provide the same
     interface by default.  */
  demangling = getenv ("COLLECT_NO_DEMANGLE") == NULL;

  link_info.relocatable = FALSE;
  link_info.emitrelocations = FALSE;
  link_info.task_link = FALSE;
  link_info.shared = FALSE;
#ifdef PIE_DEFAULT
  link_info.pie = TRUE;
#else
  link_info.pie = FALSE;
#endif
  link_info.executable = FALSE;
  link_info.symbolic = FALSE;
  link_info.export_dynamic = FALSE;
  link_info.static_link = FALSE;
  link_info.traditional_format = FALSE;
  link_info.optimize = FALSE;
  link_info.unresolved_syms_in_objects = RM_NOT_YET_SET;
  link_info.unresolved_syms_in_shared_libs = RM_NOT_YET_SET;
  link_info.allow_multiple_definition = FALSE;
  link_info.allow_undefined_version = TRUE;
  link_info.keep_memory = TRUE;
  link_info.notice_all = FALSE;
  link_info.nocopyreloc = FALSE;
  link_info.new_dtags = FALSE;
  link_info.combreloc = TRUE;
  link_info.eh_frame_hdr = FALSE;
  link_info.strip_discarded = TRUE;
  link_info.strip = strip_none;
  link_info.discard = discard_sec_merge;
  link_info.common_skip_ar_aymbols = bfd_link_common_skip_none;
  link_info.callbacks = &link_callbacks;
  link_info.hash = NULL;
  link_info.keep_hash = NULL;
  link_info.notice_hash = NULL;
  link_info.wrap_hash = NULL;
  link_info.input_bfds = NULL;
  link_info.create_object_symbols_section = NULL;
  link_info.gc_sym_list = NULL;
  link_info.base_file = NULL;
  /* SVR4 linkers seem to set DT_INIT and DT_FINI based on magic _init
     and _fini symbols.  We are compatible.  */
  link_info.init_function = "_init";
  link_info.fini_function = "_fini";
  link_info.pei386_auto_import = -1;
  link_info.pei386_runtime_pseudo_reloc = FALSE;
  link_info.spare_dynamic_tags = 5;
  link_info.flags = 0;
  link_info.flags_1 = 0;
  link_info.need_relax_finalize = FALSE;

  ldfile_add_arch ("");

  config.make_executable = TRUE;
  force_make_executable = FALSE;
  config.magic_demand_paged = TRUE;
  config.text_read_only = TRUE;
  config.data_bss_contig = FALSE;

  emulation = get_emulation (argc, argv);
  ldemul_choose_mode (emulation);
  default_target = ldemul_choose_target (argc, argv);
  lang_init ();
  ldemul_before_parse ();
  lang_has_input_file = FALSE;
  parse_args (argc, argv);

  ldemul_set_symbols ();

  if (! link_info.shared && link_info.pie)
    {
      if (link_info.relocatable)
        link_info.pie = FALSE;
      else
        link_info.shared = TRUE;
    }

  if (link_info.relocatable)
    {
      if (command_line.gc_sections)
	einfo ("%P%F: --gc-sections and -r may not be used together\n");
      else if (command_line.relax)
	einfo (_("%P%F: --relax and -r may not be used together\n"));
      if (link_info.shared)
	einfo (_("%P%F: -r and -shared may not be used together\n"));
    }

  if (! link_info.shared)
    {
      if (command_line.filter_shlib)
	einfo (_("%P%F: -F may not be used without -shared\n"));
      if (command_line.auxiliary_filters)
	einfo (_("%P%F: -f may not be used without -shared\n"));
    }

  if (! link_info.shared || link_info.pie)
    link_info.executable = TRUE;

  if (! config.dynamic_link && link_info.pie)
    link_info.static_link = TRUE;

  /* Treat ld -r -s as ld -r -S -x (i.e., strip all local symbols).  I
     don't see how else this can be handled, since in this case we
     must preserve all externally visible symbols.  */
  if (link_info.relocatable && link_info.strip == strip_all)
    {
      link_info.strip = strip_debugger;
      if (link_info.discard == discard_sec_merge)
	link_info.discard = discard_all;
    }

  /* This essentially adds another -L directory so this must be done after
     the -L's in argv have been processed.  */
  set_scripts_dir ();

  /* If we have not already opened and parsed a linker script
     read the emulation's appropriate default script.  */
  if (saved_script_handle == NULL)
    {
      int isfile;
      char *s = ldemul_get_script (&isfile);

      if (isfile)
	ldfile_open_command_file (s);
      else
	{
	  lex_string = s;
	  lex_redirect (s);
	}
      parser_input = input_script;
      yyparse ();
      lex_string = NULL;
    }

  if (trace_file_tries)
    {
      if (saved_script_handle)
	info_msg (_("using external linker script:"));
      else
	info_msg (_("using internal linker script:"));
      info_msg ("\n==================================================\n");

      if (saved_script_handle)
	{
	  static const int ld_bufsz = 8193;
	  size_t n;
	  char *buf = xmalloc (ld_bufsz);

	  rewind (saved_script_handle);
	  while ((n = fread (buf, 1, ld_bufsz - 1, saved_script_handle)) > 0)
	    {
	      buf[n] = 0;
	      info_msg (buf);
	    }
	  rewind (saved_script_handle);
	  free (buf);
	}
      else
	{
	  int isfile;

	  info_msg (ldemul_get_script (&isfile));
	}

      info_msg ("\n==================================================\n");
    }

  lang_final ();

  if (!lang_has_input_file)
    {
      if (version_printed)
	xexit (0);
      einfo (_("%P%F: no input files\n"));
    }

  if (trace_files)
    info_msg (_("%P: mode %s\n"), emulation);

  ldemul_after_parse ();

  if (config.map_filename)
    {
      if (strcmp (config.map_filename, "-") == 0)
	{
	  config.map_file = stdout;
	}
      else
	{
	  config.map_file = fopen (config.map_filename, FOPEN_WT);
	  if (config.map_file == (FILE *) NULL)
	    {
	      bfd_set_error (bfd_error_system_call);
	      einfo (_("%P%F: cannot open map file %s: %E\n"),
		     config.map_filename);
	    }
	}
    }

  lang_process ();

  /* Print error messages for any missing symbols, for any warning
     symbols, and possibly multiple definitions.  */
  if (link_info.relocatable)
    output_bfd->flags &= ~EXEC_P;
  else
    output_bfd->flags |= EXEC_P;

  ldwrite ();

  if (config.map_file != NULL)
    lang_map ();
  if (command_line.cref)
    output_cref (config.map_file != NULL ? config.map_file : stdout);
  if (nocrossref_list != NULL)
    check_nocrossrefs ();

  /* Even if we're producing relocatable output, some non-fatal errors should
     be reported in the exit status.  (What non-fatal errors, if any, do we
     want to ignore for relocatable output?)  */
  if (!config.make_executable && !force_make_executable)
    {
      if (trace_files)
	einfo (_("%P: link errors found, deleting executable `%s'\n"),
	       output_filename);

      /* The file will be removed by remove_output.  */
      xexit (1);
    }
  else
    {
      if (! bfd_close (output_bfd))
	einfo (_("%F%B: final close failed: %E\n"), output_bfd);

      /* If the --force-exe-suffix is enabled, and we're making an
	 executable file and it doesn't end in .exe, copy it to one
	 which does.  */
      if (! link_info.relocatable && command_line.force_exe_suffix)
	{
	  int len = strlen (output_filename);

	  if (len < 4
	      || (strcasecmp (output_filename + len - 4, ".exe") != 0
		  && strcasecmp (output_filename + len - 4, ".dll") != 0))
	    {
	      FILE *src;
	      FILE *dst;
	      const int bsize = 4096;
	      char *buf = xmalloc (bsize);
	      int l;
	      char *dst_name = xmalloc (len + 5);

	      strcpy (dst_name, output_filename);
	      strcat (dst_name, ".exe");
	      src = fopen (output_filename, FOPEN_RB);
	      dst = fopen (dst_name, FOPEN_WB);

	      if (!src)
		einfo (_("%X%P: unable to open for source of copy `%s'\n"),
		       output_filename);
	      if (!dst)
		einfo (_("%X%P: unable to open for destination of copy `%s'\n"),
		       dst_name);
	      while ((l = fread (buf, 1, bsize, src)) > 0)
		{
		  int done = fwrite (buf, 1, l, dst);

		  if (done != l)
		    einfo (_("%P: Error writing file `%s'\n"), dst_name);
		}

	      fclose (src);
	      if (fclose (dst) == EOF)
		einfo (_("%P: Error closing file `%s'\n"), dst_name);
	      free (dst_name);
	      free (buf);
	    }
	}
    }

  END_PROGRESS (program_name);

  if (config.stats)
    {
#ifdef HAVE_SBRK
      char *lim = sbrk (0);
#endif
      long run_time = get_run_time () - start_time;

      fprintf (stderr, _("%s: total time in link: %ld.%06ld\n"),
	       program_name, run_time / 1000000, run_time % 1000000);
#ifdef HAVE_SBRK
      fprintf (stderr, _("%s: data size %ld\n"), program_name,
	       (long) (lim - (char *) &environ));
#endif
    }

  /* Prevent remove_output from doing anything, after a successful link.  */
  output_filename = NULL;

  xexit (0);
  return 0;
}

/* We need to find any explicitly given emulation in order to initialize the
   state that's needed by the lex&yacc argument parser (parse_args).  */

static char *
get_emulation (int argc, char **argv)
{
  char *emulation;
  int i;

  emulation = getenv (EMULATION_ENVIRON);
  if (emulation == NULL)
    emulation = DEFAULT_EMULATION;

  for (i = 1; i < argc; i++)
    {
      if (!strncmp (argv[i], "-m", 2))
	{
	  if (argv[i][2] == '\0')
	    {
	      /* -m EMUL */
	      if (i < argc - 1)
		{
		  emulation = argv[i + 1];
		  i++;
		}
	      else
		einfo (_("%P%F: missing argument to -m\n"));
	    }
	  else if (strcmp (argv[i], "-mips1") == 0
		   || strcmp (argv[i], "-mips2") == 0
		   || strcmp (argv[i], "-mips3") == 0
		   || strcmp (argv[i], "-mips4") == 0
		   || strcmp (argv[i], "-mips5") == 0
		   || strcmp (argv[i], "-mips32") == 0
		   || strcmp (argv[i], "-mips32r2") == 0
		   || strcmp (argv[i], "-mips64") == 0
		   || strcmp (argv[i], "-mips64r2") == 0)
	    {
	      /* FIXME: The arguments -mips1, -mips2, -mips3, etc. are
		 passed to the linker by some MIPS compilers.  They
		 generally tell the linker to use a slightly different
		 library path.  Perhaps someday these should be
		 implemented as emulations; until then, we just ignore
		 the arguments and hope that nobody ever creates
		 emulations named ips1, ips2 or ips3.  */
	    }
	  else if (strcmp (argv[i], "-m486") == 0)
	    {
	      /* FIXME: The argument -m486 is passed to the linker on
		 some Linux systems.  Hope that nobody creates an
		 emulation named 486.  */
	    }
	  else
	    {
	      /* -mEMUL */
	      emulation = &argv[i][2];
	    }
	}
    }

  return emulation;
}

/* If directory DIR contains an "ldscripts" subdirectory,
   add DIR to the library search path and return TRUE,
   else return FALSE.  */

static bfd_boolean
check_for_scripts_dir (char *dir)
{
  size_t dirlen;
  char *buf;
  struct stat s;
  bfd_boolean res;

  dirlen = strlen (dir);
  /* sizeof counts the terminating NUL.  */
  buf = xmalloc (dirlen + sizeof ("/ldscripts"));
  sprintf (buf, "%s/ldscripts", dir);

  res = stat (buf, &s) == 0 && S_ISDIR (s.st_mode);
  free (buf);
  if (res)
    ldfile_add_library_path (dir, FALSE);
  return res;
}

/* Set the default directory for finding script files.
   Libraries will be searched for here too, but that's ok.
   We look for the "ldscripts" directory in:

   SCRIPTDIR (passed from Makefile)
	     (adjusted according to the current location of the binary)
   SCRIPTDIR (passed from Makefile)
   the dir where this program is (for using it from the build tree)
   the dir where this program is/../lib
	     (for installing the tool suite elsewhere).  */

static void
set_scripts_dir (void)
{
  char *end, *dir;
  size_t dirlen;
  bfd_boolean found;

  dir = make_relative_prefix (program_name, BINDIR, SCRIPTDIR);
  if (dir)
    {
      found = check_for_scripts_dir (dir);
      free (dir);
      if (found)
	return;
    }

  dir = make_relative_prefix (program_name, TOOLBINDIR, SCRIPTDIR);
  if (dir)
    {
      found = check_for_scripts_dir (dir);
      free (dir);
      if (found)
	return;
    }

  if (check_for_scripts_dir (SCRIPTDIR))
    /* We've been installed normally.  */
    return;

  /* Look for "ldscripts" in the dir where our binary is.  */
  end = strrchr (program_name, '/');
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have \foo\bar, or /foo\bar.  */
    char *bslash = strrchr (program_name, '\\');

    if (end == NULL || (bslash != NULL && bslash > end))
      end = bslash;
  }
#endif

  if (end == NULL)
    /* Don't look for ldscripts in the current directory.  There is
       too much potential for confusion.  */
    return;

  dirlen = end - program_name;
  /* Make a copy of program_name in dir.
     Leave room for later "/../lib".  */
  dir = xmalloc (dirlen + 8);
  strncpy (dir, program_name, dirlen);
  dir[dirlen] = '\0';

  if (check_for_scripts_dir (dir))
    {
      free (dir);
      return;
    }

  /* Look for "ldscripts" in <the dir where our binary is>/../lib.  */
  strcpy (dir + dirlen, "/../lib");
  check_for_scripts_dir (dir);
  free (dir);
}

void
add_ysym (const char *name)
{
  if (link_info.notice_hash == NULL)
    {
      link_info.notice_hash = xmalloc (sizeof (struct bfd_hash_table));
      if (! bfd_hash_table_init_n (link_info.notice_hash,
				   bfd_hash_newfunc,
				   61))
	einfo (_("%P%F: bfd_hash_table_init failed: %E\n"));
    }

  if (bfd_hash_lookup (link_info.notice_hash, name, TRUE, TRUE) == NULL)
    einfo (_("%P%F: bfd_hash_lookup failed: %E\n"));
}

/* Record a symbol to be wrapped, from the --wrap option.  */

void
add_wrap (const char *name)
{
  if (link_info.wrap_hash == NULL)
    {
      link_info.wrap_hash = xmalloc (sizeof (struct bfd_hash_table));
      if (! bfd_hash_table_init_n (link_info.wrap_hash,
				   bfd_hash_newfunc,
				   61))
	einfo (_("%P%F: bfd_hash_table_init failed: %E\n"));
    }

  if (bfd_hash_lookup (link_info.wrap_hash, name, TRUE, TRUE) == NULL)
    einfo (_("%P%F: bfd_hash_lookup failed: %E\n"));
}

/* Handle the -retain-symbols-file option.  */

void
add_keepsyms_file (const char *filename)
{
  FILE *file;
  char *buf;
  size_t bufsize;
  int c;

  if (link_info.strip == strip_some)
    einfo (_("%X%P: error: duplicate retain-symbols-file\n"));

  file = fopen (filename, "r");
  if (file == NULL)
    {
      bfd_set_error (bfd_error_system_call);
      einfo ("%X%P: %s: %E\n", filename);
      return;
    }

  link_info.keep_hash = xmalloc (sizeof (struct bfd_hash_table));
  if (! bfd_hash_table_init (link_info.keep_hash, bfd_hash_newfunc))
    einfo (_("%P%F: bfd_hash_table_init failed: %E\n"));

  bufsize = 100;
  buf = xmalloc (bufsize);

  c = getc (file);
  while (c != EOF)
    {
      while (ISSPACE (c))
	c = getc (file);

      if (c != EOF)
	{
	  size_t len = 0;

	  while (! ISSPACE (c) && c != EOF)
	    {
	      buf[len] = c;
	      ++len;
	      if (len >= bufsize)
		{
		  bufsize *= 2;
		  buf = xrealloc (buf, bufsize);
		}
	      c = getc (file);
	    }

	  buf[len] = '\0';

	  if (bfd_hash_lookup (link_info.keep_hash, buf, TRUE, TRUE) == NULL)
	    einfo (_("%P%F: bfd_hash_lookup for insertion failed: %E\n"));
	}
    }

  if (link_info.strip != strip_none)
    einfo (_("%P: `-retain-symbols-file' overrides `-s' and `-S'\n"));

  free (buf);
  link_info.strip = strip_some;
}

/* Callbacks from the BFD linker routines.  */

/* This is called when BFD has decided to include an archive member in
   a link.  */

static bfd_boolean
add_archive_element (struct bfd_link_info *info ATTRIBUTE_UNUSED,
		     bfd *abfd,
		     const char *name)
{
  lang_input_statement_type *input;

  input = xmalloc (sizeof (lang_input_statement_type));
  input->filename = abfd->filename;
  input->local_sym_name = abfd->filename;
  input->the_bfd = abfd;
  input->asymbols = NULL;
  input->next = NULL;
  input->just_syms_flag = FALSE;
  input->loaded = FALSE;
  input->search_dirs_flag = FALSE;

  /* FIXME: The following fields are not set: header.next,
     header.type, closed, passive_position, symbol_count,
     next_real_file, is_archive, target, real.  This bit of code is
     from the old decode_library_subfile function.  I don't know
     whether any of those fields matters.  */

  ldlang_add_file (input);

  if (config.map_file != NULL)
    {
      static bfd_boolean header_printed;
      struct bfd_link_hash_entry *h;
      bfd *from;
      int len;

      h = bfd_link_hash_lookup (link_info.hash, name, FALSE, FALSE, TRUE);

      if (h == NULL)
	from = NULL;
      else
	{
	  switch (h->type)
	    {
	    default:
	      from = NULL;
	      break;

	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      from = h->u.def.section->owner;
	      break;

	    case bfd_link_hash_undefined:
	    case bfd_link_hash_undefweak:
	      from = h->u.undef.abfd;
	      break;

	    case bfd_link_hash_common:
	      from = h->u.c.p->section->owner;
	      break;
	    }
	}

      if (! header_printed)
	{
	  char buf[100];

	  sprintf (buf, _("Archive member included because of file (symbol)\n\n"));
	  minfo ("%s", buf);
	  header_printed = TRUE;
	}

      if (bfd_my_archive (abfd) == NULL)
	{
	  minfo ("%s", bfd_get_filename (abfd));
	  len = strlen (bfd_get_filename (abfd));
	}
      else
	{
	  minfo ("%s(%s)", bfd_get_filename (bfd_my_archive (abfd)),
		 bfd_get_filename (abfd));
	  len = (strlen (bfd_get_filename (bfd_my_archive (abfd)))
		 + strlen (bfd_get_filename (abfd))
		 + 2);
	}

      if (len >= 29)
	{
	  print_nl ();
	  len = 0;
	}
      while (len < 30)
	{
	  print_space ();
	  ++len;
	}

      if (from != NULL)
	minfo ("%B ", from);
      if (h != NULL)
	minfo ("(%T)\n", h->root.string);
      else
	minfo ("(%s)\n", name);
    }

  if (trace_files || trace_file_tries)
    info_msg ("%I\n", input);

  return TRUE;
}

/* This is called when BFD has discovered a symbol which is defined
   multiple times.  */

static bfd_boolean
multiple_definition (struct bfd_link_info *info ATTRIBUTE_UNUSED,
		     const char *name,
		     bfd *obfd,
		     asection *osec,
		     bfd_vma oval,
		     bfd *nbfd,
		     asection *nsec,
		     bfd_vma nval)
{
  /* If either section has the output_section field set to
     bfd_abs_section_ptr, it means that the section is being
     discarded, and this is not really a multiple definition at all.
     FIXME: It would be cleaner to somehow ignore symbols defined in
     sections which are being discarded.  */
  if ((osec->output_section != NULL
       && ! bfd_is_abs_section (osec)
       && bfd_is_abs_section (osec->output_section))
      || (nsec->output_section != NULL
	  && ! bfd_is_abs_section (nsec)
	  && bfd_is_abs_section (nsec->output_section)))
    return TRUE;

  einfo (_("%X%C: multiple definition of `%T'\n"),
	 nbfd, nsec, nval, name);
  if (obfd != NULL)
    einfo (_("%D: first defined here\n"), obfd, osec, oval);

  if (command_line.relax)
    {
      einfo (_("%P: Disabling relaxation: it will not work with multiple definitions\n"));
      command_line.relax = 0;
    }

  return TRUE;
}

/* This is called when there is a definition of a common symbol, or
   when a common symbol is found for a symbol that is already defined,
   or when two common symbols are found.  We only do something if
   -warn-common was used.  */

static bfd_boolean
multiple_common (struct bfd_link_info *info ATTRIBUTE_UNUSED,
		 const char *name,
		 bfd *obfd,
		 enum bfd_link_hash_type otype,
		 bfd_vma osize,
		 bfd *nbfd,
		 enum bfd_link_hash_type ntype,
		 bfd_vma nsize)
{
  if (! config.warn_common)
    return TRUE;

  if (ntype == bfd_link_hash_defined
      || ntype == bfd_link_hash_defweak
      || ntype == bfd_link_hash_indirect)
    {
      ASSERT (otype == bfd_link_hash_common);
      einfo (_("%B: warning: definition of `%T' overriding common\n"),
	     nbfd, name);
      if (obfd != NULL)
	einfo (_("%B: warning: common is here\n"), obfd);
    }
  else if (otype == bfd_link_hash_defined
	   || otype == bfd_link_hash_defweak
	   || otype == bfd_link_hash_indirect)
    {
      ASSERT (ntype == bfd_link_hash_common);
      einfo (_("%B: warning: common of `%T' overridden by definition\n"),
	     nbfd, name);
      if (obfd != NULL)
	einfo (_("%B: warning: defined here\n"), obfd);
    }
  else
    {
      ASSERT (otype == bfd_link_hash_common && ntype == bfd_link_hash_common);
      if (osize > nsize)
	{
	  einfo (_("%B: warning: common of `%T' overridden by larger common\n"),
		 nbfd, name);
	  if (obfd != NULL)
	    einfo (_("%B: warning: larger common is here\n"), obfd);
	}
      else if (nsize > osize)
	{
	  einfo (_("%B: warning: common of `%T' overriding smaller common\n"),
		 nbfd, name);
	  if (obfd != NULL)
	    einfo (_("%B: warning: smaller common is here\n"), obfd);
	}
      else
	{
	  einfo (_("%B: warning: multiple common of `%T'\n"), nbfd, name);
	  if (obfd != NULL)
	    einfo (_("%B: warning: previous common is here\n"), obfd);
	}
    }

  return TRUE;
}

/* This is called when BFD has discovered a set element.  H is the
   entry in the linker hash table for the set.  SECTION and VALUE
   represent a value which should be added to the set.  */

static bfd_boolean
add_to_set (struct bfd_link_info *info ATTRIBUTE_UNUSED,
	    struct bfd_link_hash_entry *h,
	    bfd_reloc_code_real_type reloc,
	    bfd *abfd,
	    asection *section,
	    bfd_vma value)
{
  if (config.warn_constructors)
    einfo (_("%P: warning: global constructor %s used\n"),
	   h->root.string);

  if (! config.build_constructors)
    return TRUE;

  ldctor_add_set_entry (h, reloc, NULL, section, value);

  if (h->type == bfd_link_hash_new)
    {
      h->type = bfd_link_hash_undefined;
      h->u.undef.abfd = abfd;
      /* We don't call bfd_link_add_undef to add this to the list of
	 undefined symbols because we are going to define it
	 ourselves.  */
    }

  return TRUE;
}

/* This is called when BFD has discovered a constructor.  This is only
   called for some object file formats--those which do not handle
   constructors in some more clever fashion.  This is similar to
   adding an element to a set, but less general.  */

static bfd_boolean
constructor_callback (struct bfd_link_info *info,
		      bfd_boolean constructor,
		      const char *name,
		      bfd *abfd,
		      asection *section,
		      bfd_vma value)
{
  char *s;
  struct bfd_link_hash_entry *h;
  char set_name[1 + sizeof "__CTOR_LIST__"];

  if (config.warn_constructors)
    einfo (_("%P: warning: global constructor %s used\n"), name);

  if (! config.build_constructors)
    return TRUE;

  /* Ensure that BFD_RELOC_CTOR exists now, so that we can give a
     useful error message.  */
  if (bfd_reloc_type_lookup (output_bfd, BFD_RELOC_CTOR) == NULL
      && (link_info.relocatable
	  || bfd_reloc_type_lookup (abfd, BFD_RELOC_CTOR) == NULL))
    einfo (_("%P%F: BFD backend error: BFD_RELOC_CTOR unsupported\n"));

  s = set_name;
  if (bfd_get_symbol_leading_char (abfd) != '\0')
    *s++ = bfd_get_symbol_leading_char (abfd);
  if (constructor)
    strcpy (s, "__CTOR_LIST__");
  else
    strcpy (s, "__DTOR_LIST__");

  h = bfd_link_hash_lookup (info->hash, set_name, TRUE, TRUE, TRUE);
  if (h == (struct bfd_link_hash_entry *) NULL)
    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
  if (h->type == bfd_link_hash_new)
    {
      h->type = bfd_link_hash_undefined;
      h->u.undef.abfd = abfd;
      /* We don't call bfd_link_add_undef to add this to the list of
	 undefined symbols because we are going to define it
	 ourselves.  */
    }

  ldctor_add_set_entry (h, BFD_RELOC_CTOR, name, section, value);
  return TRUE;
}

/* A structure used by warning_callback to pass information through
   bfd_map_over_sections.  */

struct warning_callback_info
{
  bfd_boolean found;
  const char *warning;
  const char *symbol;
  asymbol **asymbols;
};

/* This is called when there is a reference to a warning symbol.  */

static bfd_boolean
warning_callback (struct bfd_link_info *info ATTRIBUTE_UNUSED,
		  const char *warning,
		  const char *symbol,
		  bfd *abfd,
		  asection *section,
		  bfd_vma address)
{
  /* This is a hack to support warn_multiple_gp.  FIXME: This should
     have a cleaner interface, but what?  */
  if (! config.warn_multiple_gp
      && strcmp (warning, "using multiple gp values") == 0)
    return TRUE;

  if (section != NULL)
    einfo ("%C: %s\n", abfd, section, address, warning);
  else if (abfd == NULL)
    einfo ("%P: %s\n", warning);
  else if (symbol == NULL)
    einfo ("%B: %s\n", abfd, warning);
  else
    {
      lang_input_statement_type *entry;
      asymbol **asymbols;
      struct warning_callback_info info;

      /* Look through the relocs to see if we can find a plausible
	 address.  */
      entry = (lang_input_statement_type *) abfd->usrdata;
      if (entry != NULL && entry->asymbols != NULL)
	asymbols = entry->asymbols;
      else
	{
	  long symsize;
	  long symbol_count;

	  symsize = bfd_get_symtab_upper_bound (abfd);
	  if (symsize < 0)
	    einfo (_("%B%F: could not read symbols: %E\n"), abfd);
	  asymbols = xmalloc (symsize);
	  symbol_count = bfd_canonicalize_symtab (abfd, asymbols);
	  if (symbol_count < 0)
	    einfo (_("%B%F: could not read symbols: %E\n"), abfd);
	  if (entry != NULL)
	    {
	      entry->asymbols = asymbols;
	      entry->symbol_count = symbol_count;
	    }
	}

      info.found = FALSE;
      info.warning = warning;
      info.symbol = symbol;
      info.asymbols = asymbols;
      bfd_map_over_sections (abfd, warning_find_reloc, &info);

      if (! info.found)
	einfo ("%B: %s\n", abfd, warning);

      if (entry == NULL)
	free (asymbols);
    }

  return TRUE;
}

/* This is called by warning_callback for each section.  It checks the
   relocs of the section to see if it can find a reference to the
   symbol which triggered the warning.  If it can, it uses the reloc
   to give an error message with a file and line number.  */

static void
warning_find_reloc (bfd *abfd, asection *sec, void *iarg)
{
  struct warning_callback_info *info = iarg;
  long relsize;
  arelent **relpp;
  long relcount;
  arelent **p, **pend;

  if (info->found)
    return;

  relsize = bfd_get_reloc_upper_bound (abfd, sec);
  if (relsize < 0)
    einfo (_("%B%F: could not read relocs: %E\n"), abfd);
  if (relsize == 0)
    return;

  relpp = xmalloc (relsize);
  relcount = bfd_canonicalize_reloc (abfd, sec, relpp, info->asymbols);
  if (relcount < 0)
    einfo (_("%B%F: could not read relocs: %E\n"), abfd);

  p = relpp;
  pend = p + relcount;
  for (; p < pend && *p != NULL; p++)
    {
      arelent *q = *p;

      if (q->sym_ptr_ptr != NULL
	  && *q->sym_ptr_ptr != NULL
	  && strcmp (bfd_asymbol_name (*q->sym_ptr_ptr), info->symbol) == 0)
	{
	  /* We found a reloc for the symbol we are looking for.  */
	  einfo ("%C: %s\n", abfd, sec, q->address, info->warning);
	  info->found = TRUE;
	  break;
	}
    }

  free (relpp);
}

/* This is called when an undefined symbol is found.  */

static bfd_boolean
undefined_symbol (struct bfd_link_info *info ATTRIBUTE_UNUSED,
		  const char *name,
		  bfd *abfd,
		  asection *section,
		  bfd_vma address,
		  bfd_boolean error)
{
  static char *error_name;
  static unsigned int error_count;

#define MAX_ERRORS_IN_A_ROW 5

  if (config.warn_once)
    {
      static struct bfd_hash_table *hash;

      /* Only warn once about a particular undefined symbol.  */
      if (hash == NULL)
	{
	  hash = xmalloc (sizeof (struct bfd_hash_table));
	  if (! bfd_hash_table_init (hash, bfd_hash_newfunc))
	    einfo (_("%F%P: bfd_hash_table_init failed: %E\n"));
	}

      if (bfd_hash_lookup (hash, name, FALSE, FALSE) != NULL)
	return TRUE;

      if (bfd_hash_lookup (hash, name, TRUE, TRUE) == NULL)
	einfo (_("%F%P: bfd_hash_lookup failed: %E\n"));
    }

  /* We never print more than a reasonable number of errors in a row
     for a single symbol.  */
  if (error_name != NULL
      && strcmp (name, error_name) == 0)
    ++error_count;
  else
    {
      error_count = 0;
      if (error_name != NULL)
	free (error_name);
      error_name = xstrdup (name);
    }

  if (section != NULL)
    {
      if (error_count < MAX_ERRORS_IN_A_ROW)
	{
	  if (error)
	    einfo (_("%X%C: undefined reference to `%T'\n"),
		   abfd, section, address, name);
	  else
	    einfo (_("%C: warning: undefined reference to `%T'\n"),
		   abfd, section, address, name);
	}
      else if (error_count == MAX_ERRORS_IN_A_ROW)
	{
	  if (error)
	    einfo (_("%X%D: more undefined references to `%T' follow\n"),
		   abfd, section, address, name);
	  else
	    einfo (_("%D: warning: more undefined references to `%T' follow\n"),
		   abfd, section, address, name);
	}
      else if (error)
	einfo ("%X");
    }
  else
    {
      if (error_count < MAX_ERRORS_IN_A_ROW)
	{
	  if (error)
	    einfo (_("%X%B: undefined reference to `%T'\n"),
		   abfd, name);
	  else
	    einfo (_("%B: warning: undefined reference to `%T'\n"),
		   abfd, name);
	}
      else if (error_count == MAX_ERRORS_IN_A_ROW)
	{
	  if (error)
	    einfo (_("%X%B: more undefined references to `%T' follow\n"),
		   abfd, name);
	  else
	    einfo (_("%B: warning: more undefined references to `%T' follow\n"),
		   abfd, name);
	}
      else if (error)
	einfo ("%X");
    }

  return TRUE;
}

/* Counter to limit the number of relocation overflow error messages
   to print.  Errors are printed as it is decremented.  When it's
   called and the counter is zero, a final message is printed
   indicating more relocations were omitted.  When it gets to -1, no
   such errors are printed.  If it's initially set to a value less
   than -1, all such errors will be printed (--verbose does this).  */

int overflow_cutoff_limit = 10;

/* This is called when a reloc overflows.  */

static bfd_boolean
reloc_overflow (struct bfd_link_info *info ATTRIBUTE_UNUSED,
		const char *name,
		const char *reloc_name,
		bfd_vma addend,
		bfd *abfd,
		asection *section,
		bfd_vma address)
{
  if (overflow_cutoff_limit == -1)
    return TRUE;

  if (abfd == NULL)
    einfo (_("%P%X: generated"));
  else
    einfo ("%X%C:", abfd, section, address);

  if (overflow_cutoff_limit >= 0
      && overflow_cutoff_limit-- == 0)
    {
      einfo (_(" additional relocation overflows omitted from the output\n"));
      return TRUE;
    }

  einfo (_(" relocation truncated to fit: %s %T"), reloc_name, name);
  if (addend != 0)
    einfo ("+%v", addend);
  einfo ("\n");
  return TRUE;
}

/* This is called when a dangerous relocation is made.  */

static bfd_boolean
reloc_dangerous (struct bfd_link_info *info ATTRIBUTE_UNUSED,
		 const char *message,
		 bfd *abfd,
		 asection *section,
		 bfd_vma address)
{
  if (abfd == NULL)
    einfo (_("%P%X: generated"));
  else
    einfo ("%X%C:", abfd, section, address);
  einfo (_("dangerous relocation: %s\n"), message);
  return TRUE;
}

/* This is called when a reloc is being generated attached to a symbol
   that is not being output.  */

static bfd_boolean
unattached_reloc (struct bfd_link_info *info ATTRIBUTE_UNUSED,
		  const char *name,
		  bfd *abfd,
		  asection *section,
		  bfd_vma address)
{
  if (abfd == NULL)
    einfo (_("%P%X: generated"));
  else
    einfo ("%X%C:", abfd, section, address);
  einfo (_(" reloc refers to symbol `%T' which is not being output\n"), name);
  return TRUE;
}

/* This is called if link_info.notice_all is set, or when a symbol in
   link_info.notice_hash is found.  Symbols are put in notice_hash
   using the -y option.  */

static bfd_boolean
notice (struct bfd_link_info *info,
	const char *name,
	bfd *abfd,
	asection *section,
	bfd_vma value)
{
  if (! info->notice_all
      || (info->notice_hash != NULL
	  && bfd_hash_lookup (info->notice_hash, name, FALSE, FALSE) != NULL))
    {
      if (bfd_is_und_section (section))
	einfo ("%B: reference to %s\n", abfd, name);
      else
	einfo ("%B: definition of %s\n", abfd, name);
    }

  if (command_line.cref || nocrossref_list != NULL)
    add_cref (name, abfd, section, value);

  return TRUE;
}
@


1.11
log
@Backport @@file support from binutils-2.17

@@file allows reading command line arguments from a file. Gcc now uses this to
pass very long arguments lists to ld.

ok guenther@@ miod@@
@
text
@d383 3
@


1.10
log
@Add support for PIE-by-default in both ld and gcc.  This is a completely
different approach than the one taken in kurt@@'s original diff, but deemed
better after discussion and diff exchange with kettenis@@ and matthew@@.

Lots of feedback by kettenis@@ and matthew@@, prodding and encouragement by
deraadt@@.

ok kettenis@@ matthew@@
@
text
@d193 2
@


1.9
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d289 3
d293 1
d351 8
@


1.8
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2002, 2003
d54 1
a54 1
extern PTR sbrk ();
a61 2
int main PARAMS ((int, char **));

d96 4
d108 1
a108 1
  PARAMS ((int, char **));
d110 1
a110 5
  PARAMS ((void));
static void remove_output
  PARAMS ((void));
static bfd_boolean check_for_scripts_dir
  PARAMS ((char *));
d112 1
a112 1
  PARAMS ((struct bfd_link_info *, bfd *, const char *));
d114 2
a115 2
  PARAMS ((struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma,
	   bfd *, asection *, bfd_vma));
d117 2
a118 3
  PARAMS ((struct bfd_link_info *, const char *, bfd *,
	   enum bfd_link_hash_type, bfd_vma, bfd *, enum bfd_link_hash_type,
	   bfd_vma));
d120 2
a121 2
  PARAMS ((struct bfd_link_info *, struct bfd_link_hash_entry *,
	   bfd_reloc_code_real_type, bfd *, asection *, bfd_vma));
d123 2
a124 2
  PARAMS ((struct bfd_link_info *, bfd_boolean, const char *, bfd *,
	   asection *, bfd_vma));
d126 2
a127 2
  PARAMS ((struct bfd_link_info *, const char *, const char *, bfd *,
	   asection *, bfd_vma));
d129 1
a129 1
  PARAMS ((bfd *, asection *, PTR));
d131 2
a132 2
  PARAMS ((struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma,
	   bfd_boolean));
d134 2
a135 2
  PARAMS ((struct bfd_link_info *, const char *, const char *, bfd_vma,
	   bfd *, asection *, bfd_vma));
d137 1
a137 1
  PARAMS ((struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma));
d139 1
a139 1
  PARAMS ((struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma));
d141 1
a141 1
  PARAMS ((struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma));
d162 1
a162 1
remove_output ()
d166 2
a167 2
      if (output_bfd && output_bfd->iostream)
	fclose ((FILE *) (output_bfd->iostream));
d174 1
a174 3
main (argc, argv)
     int argc;
     char **argv;
d285 1
a285 1
  link_info.relocateable = FALSE;
d289 2
d296 2
a297 2
  link_info.no_undefined = FALSE;
  link_info.allow_shlib_undefined = TRUE;
a322 1
  link_info.mpc860c0 = 0;
d326 3
a328 3
  link_info.flags = (bfd_vma) 0;
  link_info.flags_1 = (bfd_vma) 0;
  link_info.relax_finalizing = FALSE;
d348 1
a348 1
  if (link_info.relocateable)
a351 2
      if (link_info.mpc860c0)
	einfo (_("%P%F: -r and --mpc860c0 may not be used together\n"));
d366 3
d372 1
a372 1
  if (link_info.relocateable && link_info.strip == strip_all)
d471 1
a471 1
  if (link_info.relocateable)
d485 1
a485 1
  /* Even if we're producing relocateable output, some non-fatal errors should
d487 1
a487 1
     want to ignore for relocateable output?)  */
d505 1
a505 1
      if (! link_info.relocateable && command_line.force_exe_suffix)
d526 2
a527 1
		einfo (_("%X%P: unable to open for source of copy `%s'\n"), output_filename);
d529 2
a530 1
		einfo (_("%X%P: unable to open for destination of copy `%s'\n"), dst_name);
d553 1
a553 1
      char *lim = (char *) sbrk (0);
d576 1
a576 3
get_emulation (argc, argv)
     int argc;
     char **argv;
d607 2
a608 1
		   || strcmp (argv[i], "-mips64") == 0)
d640 1
a640 2
check_for_scripts_dir (dir)
     char *dir;
d649 1
a649 1
  buf = (char *) xmalloc (dirlen + sizeof ("/ldscripts"));
d671 1
a671 1
set_scripts_dir ()
d719 1
a719 1
  dir = (char *) xmalloc (dirlen + 8);
d736 1
a736 2
add_ysym (name)
     const char *name;
d738 1
a738 1
  if (link_info.notice_hash == (struct bfd_hash_table *) NULL)
d740 1
a740 2
      link_info.notice_hash = ((struct bfd_hash_table *)
			       xmalloc (sizeof (struct bfd_hash_table)));
d747 1
a747 2
  if (bfd_hash_lookup (link_info.notice_hash, name, TRUE, TRUE)
      == (struct bfd_hash_entry *) NULL)
d754 1
a754 2
add_wrap (name)
     const char *name;
d758 1
a758 2
      link_info.wrap_hash = ((struct bfd_hash_table *)
			     xmalloc (sizeof (struct bfd_hash_table)));
d772 1
a772 2
add_keepsyms_file (filename)
     const char *filename;
d783 1
a783 1
  if (file == (FILE *) NULL)
d790 1
a790 2
  link_info.keep_hash = ((struct bfd_hash_table *)
			 xmalloc (sizeof (struct bfd_hash_table)));
d795 1
a795 1
  buf = (char *) xmalloc (bufsize);
d821 1
a821 2
	  if (bfd_hash_lookup (link_info.keep_hash, buf, TRUE, TRUE)
	      == (struct bfd_hash_entry *) NULL)
d839 3
a841 4
add_archive_element (info, abfd, name)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     bfd *abfd;
     const char *name;
d845 1
a845 2
  input = ((lang_input_statement_type *)
	   xmalloc (sizeof (lang_input_statement_type)));
d863 1
a863 1
  if (config.map_file != (FILE *) NULL)
d950 8
a957 9
multiple_definition (info, name, obfd, osec, oval, nbfd, nsec, nval)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const char *name;
     bfd *obfd;
     asection *osec;
     bfd_vma oval;
     bfd *nbfd;
     asection *nsec;
     bfd_vma nval;
d974 1
a974 1
  if (obfd != (bfd *) NULL)
d992 8
a999 9
multiple_common (info, name, obfd, otype, osize, nbfd, ntype, nsize)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const char *name;
     bfd *obfd;
     enum bfd_link_hash_type otype;
     bfd_vma osize;
     bfd *nbfd;
     enum bfd_link_hash_type ntype;
     bfd_vma nsize;
d1057 6
a1062 7
add_to_set (info, h, reloc, abfd, section, value)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     struct bfd_link_hash_entry *h;
     bfd_reloc_code_real_type reloc;
     bfd *abfd;
     asection *section;
     bfd_vma value;
d1071 1
a1071 1
  ldctor_add_set_entry (h, reloc, (const char *) NULL, section, value);
d1091 6
a1096 7
constructor_callback (info, constructor, name, abfd, section, value)
     struct bfd_link_info *info;
     bfd_boolean constructor;
     const char *name;
     bfd *abfd;
     asection *section;
     bfd_vma value;
d1111 1
a1111 1
      && (link_info.relocateable
d1153 6
a1158 7
warning_callback (info, warning, symbol, abfd, section, address)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const char *warning;
     const char *symbol;
     bfd *abfd;
     asection *section;
     bfd_vma address;
d1191 1
a1191 1
	  asymbols = (asymbol **) xmalloc (symsize);
d1206 1
a1206 1
      bfd_map_over_sections (abfd, warning_find_reloc, (PTR) &info);
d1224 1
a1224 4
warning_find_reloc (abfd, sec, iarg)
     bfd *abfd;
     asection *sec;
     PTR iarg;
d1226 1
a1226 1
  struct warning_callback_info *info = (struct warning_callback_info *) iarg;
d1241 1
a1241 1
  relpp = (arelent **) xmalloc (relsize);
d1269 6
a1274 7
undefined_symbol (info, name, abfd, section, address, fatal)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const char *name;
     bfd *abfd;
     asection *section;
     bfd_vma address;
     bfd_boolean fatal ATTRIBUTE_UNUSED;
d1288 1
a1288 2
	  hash = ((struct bfd_hash_table *)
		  xmalloc (sizeof (struct bfd_hash_table)));
d1302 1
a1302 1
  if (error_name != (char *) NULL
d1308 1
a1308 1
      if (error_name != (char *) NULL)
d1317 6
a1322 4
	  einfo (_("%C: undefined reference to `%T'\n"),
		 abfd, section, address, name);
	  if (fatal)
	    einfo ("%X");
d1325 10
a1334 2
	einfo (_("%D: more undefined references to `%T' follow\n"),
	       abfd, section, address, name);
d1340 6
a1345 4
	  einfo (_("%B: undefined reference to `%T'\n"),
		 abfd, name);
	  if (fatal)
	    einfo ("%X");
d1348 10
a1357 2
	einfo (_("%B: more undefined references to `%T' follow\n"),
	       abfd, name);
d1363 9
d1375 7
a1381 8
reloc_overflow (info, name, reloc_name, addend, abfd, section, address)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const char *name;
     const char *reloc_name;
     bfd_vma addend;
     bfd *abfd;
     asection *section;
     bfd_vma address;
d1383 4
a1386 1
  if (abfd == (bfd *) NULL)
d1390 8
d1408 5
a1412 6
reloc_dangerous (info, message, abfd, section, address)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const char *message;
     bfd *abfd;
     asection *section;
     bfd_vma address;
d1414 1
a1414 1
  if (abfd == (bfd *) NULL)
d1426 5
a1430 6
unattached_reloc (info, name, abfd, section, address)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const char *name;
     bfd *abfd;
     asection *section;
     bfd_vma address;
d1432 1
a1432 1
  if (abfd == (bfd *) NULL)
d1445 5
a1449 6
notice (info, name, abfd, section, value)
     struct bfd_link_info *info;
     const char *name;
     bfd *abfd;
     asection *section;
     bfd_vma value;
@


1.7
log
@This is a project to modify executables so that they do not have any
executable regions which are writable. If a section of an executable is
writable and executable, it is much easier for errant code to modify the
executable's behavior.

Two current areas in shared library environments which have this
critical problem are the GOT (Global Offset Table) and PLT (Procedure
Linkage Table). The PLT is required to be executable and both GOT and
PLT are writable on most architectures. On most ELF architecture
machines this would cause shared libraries to have data and BSS marked
as executable.

Padding to the linker script for programs and shared libraries/objects
to isolate the GOT and PLT into their own load sections in the
executables. This allows only the text(readonly) region and the PLT
region to be marked executable with the normal data and BSS not marked
as executable. The PLT region is still marked executable on most
architectures because the PLT lives in the "data" or "BSS" regions
and the dynamic loader will need to modify it. Since the GOT and PLT
should only ever be written by the dynamic linker, it will be modified
to mprotect those regions so that they are not writable during normal
execution. If the dynamic linker needs to modify the regions later,
(eg for lazy binding), it will mprotect the region, make the necessary
changes, and mprotect it back. Since it is possible to receive a
signal which would interrupt the program flow and perhaps cause the
dynamic linker to modify the same (or nearby) PLT references, it is now
necessary for signals to be blocked for the duration of the mprotect.
@
text
@d2 2
a3 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
d7 1
a7 1
This file is part of GLD, the Gnu Linker.
d9 14
a22 14
GLD is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GLD is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GLD; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
d27 1
a27 1
#include <ctype.h>
a36 1
#include "ldgram.h"
d39 1
d45 1
a45 1
/* Somewhere above, sys/stat.h got included . . . .  */
d58 5
a62 2
static char *get_emulation PARAMS ((int, char **));
static void set_scripts_dir PARAMS ((void));
d72 7
d86 1
a86 1
boolean trace_files;
d89 1
a89 1
boolean trace_file_tries;
d93 1
a93 1
boolean version_printed;
d96 1
a96 1
boolean whole_archive;
d98 2
a99 2
/* True if we should demangle symbol names.  */
boolean demangling;
d105 40
a144 38
static void remove_output PARAMS ((void));
static boolean check_for_scripts_dir PARAMS ((char *dir));
static boolean add_archive_element PARAMS ((struct bfd_link_info *, bfd *,
					    const char *));
static boolean multiple_definition PARAMS ((struct bfd_link_info *,
					    const char *,
					    bfd *, asection *, bfd_vma,
					    bfd *, asection *, bfd_vma));
static boolean multiple_common PARAMS ((struct bfd_link_info *,
					const char *, bfd *,
					enum bfd_link_hash_type, bfd_vma,
					bfd *, enum bfd_link_hash_type,
					bfd_vma));
static boolean add_to_set PARAMS ((struct bfd_link_info *,
				   struct bfd_link_hash_entry *,
				   bfd_reloc_code_real_type,
				   bfd *, asection *, bfd_vma));
static boolean constructor_callback PARAMS ((struct bfd_link_info *,
					     boolean constructor,
					     const char *name,
					     bfd *, asection *, bfd_vma));
static boolean warning_callback PARAMS ((struct bfd_link_info *,
					 const char *, const char *, bfd *,
					 asection *, bfd_vma));
static void warning_find_reloc PARAMS ((bfd *, asection *, PTR));
static boolean undefined_symbol PARAMS ((struct bfd_link_info *,
					 const char *, bfd *,
					 asection *, bfd_vma, boolean));
static boolean reloc_overflow PARAMS ((struct bfd_link_info *, const char *,
				       const char *, bfd_vma,
				       bfd *, asection *, bfd_vma));
static boolean reloc_dangerous PARAMS ((struct bfd_link_info *, const char *,
					bfd *, asection *, bfd_vma));
static boolean unattached_reloc PARAMS ((struct bfd_link_info *,
					 const char *, bfd *, asection *,
					 bfd_vma));
static boolean notice PARAMS ((struct bfd_link_info *, const char *,
			       bfd *, asection *, bfd_vma));
d146 2
a147 1
static struct bfd_link_callbacks link_callbacks = {
d158 2
a159 1
  notice
d187 3
d204 46
d260 7
d268 5
a272 5
  trace_files = trace_file_tries = version_printed = false;
  whole_archive = false;
  config.build_constructors = true;
  config.dynamic_link = false;
  config.has_shared = false;
d275 2
a276 1
  command_line.force_common_definition = false;
d279 3
a281 2
  command_line.warn_mismatch = true;
  command_line.check_section_addresses = true;
d290 23
a313 14
  link_info.relocateable = false;
  link_info.emitrelocations = false;
  link_info.shared = false;
  link_info.symbolic = false;
  link_info.static_link = false;
  link_info.traditional_format = false;
  link_info.optimize = false;
  link_info.no_undefined = false;
  link_info.allow_shlib_undefined = false;
  link_info.strip = strip_none;
  link_info.discard = discard_none;
  link_info.keep_memory = true;
  link_info.input_bfds = NULL;
  link_info.create_object_symbols_section = NULL;
a315 1
  link_info.notice_all = false;
d318 4
a321 1
  link_info.mpc860c0 = 0;
d326 4
a329 1
  link_info.new_dtags = false;
d332 1
d336 5
a340 5
  config.make_executable = true;
  force_make_executable = false;
  config.magic_demand_paged = true;
  config.text_read_only = true;
  config.data_bss_contig = false;
d344 1
a344 1
  default_target = ldemul_choose_target ();
d347 1
a347 1
  lang_has_input_file = false;
d364 8
d378 1
a378 1
      if (link_info.discard == discard_none)
d386 3
a388 1
  if (had_script == false)
a389 1
      /* Read the emulation's appropriate default script.  */
a396 7
	  if (trace_file_tries)
	    {
	      info_msg (_("using internal linker script:\n"));
	      info_msg ("==================================================\n");
	      info_msg (s);
	      info_msg ("\n==================================================\n");
	    }
d405 33
d440 1
a440 1
  if (lang_has_input_file == false)
d448 1
a448 3
    {
      info_msg (_("%P: mode %s\n"), emulation);
    }
a473 15

  if (! link_info.relocateable)
    {
      /* Look for a text section and switch the readonly attribute in it.  */
      asection *found = bfd_get_section_by_name (output_bfd, ".text");

      if (found != (asection *) NULL)
	{
	  if (config.text_read_only)
	    found->flags |= SEC_READONLY;
	  else
	    found->flags &= ~SEC_READONLY;
	}
    }

d491 1
a491 2

  if (config.make_executable == false && force_make_executable == false)
d493 3
a495 5
      if (trace_files == true)
	{
	  einfo (_("%P: link errors found, deleting executable `%s'\n"),
		 output_filename);
	}
a497 1

d511 1
d522 1
d535 1
d537 1
a537 3
		    {
		      einfo (_("%P: Error writing file `%s'\n"), dst_name);
		    }
d539 1
d542 1
a542 3
		{
		  einfo (_("%P: Error closing file `%s'\n"), dst_name);
		}
d601 1
a601 3
		{
		  einfo (_("%P%F: missing argument to -m\n"));
		}
d606 5
a610 1
		   || strcmp (argv[i], "-mips4") == 0)
d612 1
a612 1
	      /* FIXME: The arguments -mips1, -mips2 and -mips3 are
d638 2
a639 2
   add DIR to the library search path and return true,
   else return false.  */
d641 1
a641 1
static boolean
d648 1
a648 1
  boolean res;
d658 1
a658 1
    ldfile_add_library_path (dir, false);
d667 2
d670 2
a671 1
   the dir where this program is/../lib (for installing the tool suite elsewhere) */
d678 19
d708 1
d715 3
a717 5
    {
      /* Don't look for ldscripts in the current directory.  There is
         too much potential for confusion.  */
      return;
    }
d727 4
a730 2
    /* Don't free dir.  */
    return;
d734 1
a734 4
  if (check_for_scripts_dir (dir))
    return;

  /* Well, we tried.  */
d752 1
a752 1
  if (bfd_hash_lookup (link_info.notice_hash, name, true, true)
d772 2
a773 1
  if (bfd_hash_lookup (link_info.wrap_hash, name, true, true) == NULL)
d810 1
a810 1
      while (isspace (c))
d817 1
a817 1
	  while (! isspace (c) && c != EOF)
d831 1
a831 1
	  if (bfd_hash_lookup (link_info.keep_hash, buf, true, true)
d840 1
d849 1
a849 1
static boolean
d864 3
a866 3
  input->just_syms_flag = false;
  input->loaded = false;
  input->search_dirs_flag = false;
d878 1
a878 1
      static boolean header_printed;
d883 1
a883 1
      h = bfd_link_hash_lookup (link_info.hash, name, false, false, true);
d915 1
a915 2
	  sprintf (buf, "%-29s %s\n\n", _("Archive member included"),
		   _("because of file (symbol)"));
d917 1
a917 1
	  header_printed = true;
d956 1
a956 1
  return true;
d962 1
a962 1
static boolean
d984 1
a984 1
    return true;
d997 1
a997 1
  return true;
d1005 1
a1005 1
static boolean
d1017 1
a1017 1
    return true;
d1064 1
a1064 1
  return true;
d1071 1
a1071 1
static boolean
d1085 1
a1085 1
    return true;
d1098 1
a1098 1
  return true;
d1106 1
a1106 1
static boolean
d1109 1
a1109 1
     boolean constructor;
d1123 1
a1123 1
    return true;
d1140 1
a1140 1
  h = bfd_link_hash_lookup (info->hash, set_name, true, true, true);
d1153 1
a1153 1
  return true;
d1159 3
a1161 2
struct warning_callback_info {
  boolean found;
d1169 1
a1169 1
static boolean
d1182 1
a1182 1
    return true;
a1197 1

d1220 1
a1220 1
      info.found = false;
d1233 1
a1233 1
  return true;
d1279 1
a1279 1
	  info->found = true;
d1289 1
a1289 1
static boolean
d1296 1
a1296 1
     boolean fatal ATTRIBUTE_UNUSED;
a1307 1

d1316 2
a1317 2
      if (bfd_hash_lookup (hash, name, false, false) != NULL)
	return true;
d1319 1
a1319 1
      if (bfd_hash_lookup (hash, name, true, true) == NULL)
d1363 1
a1363 1
  return true;
d1368 1
a1368 1
static boolean
d1386 1
a1386 1
  return true;
d1391 1
a1391 1
static boolean
d1404 1
a1404 1
  return true;
d1410 1
a1410 1
static boolean
d1423 1
a1423 1
  return true;
d1430 1
a1430 1
static boolean
d1440 1
a1440 1
	  && bfd_hash_lookup (info->notice_hash, name, false, false) != NULL))
d1451 1
a1451 1
  return true;
@


1.6
log
@resolve conflicts.
@
text
@d252 1
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
a38 1
#include "ldemul.h"
d41 1
d44 1
a44 1
/* Somewhere above, sys/stat.h got included . . . . */
d68 1
a68 1
/* The file that we're creating */
d133 1
a133 2
static struct bfd_link_callbacks link_callbacks =
{
d152 1
a152 1
  if (output_filename) 
d155 1
a155 1
	fclose((FILE *)(output_bfd->iostream));
d202 2
d219 1
d226 1
d242 3
a251 1
  config.make_executable = true;
a329 1

a347 1

d351 1
a351 2
     symbols, and possibly multiple definitions */

d353 1
a353 1
  if (config.text_read_only)
d355 1
a355 1
      /* Look for a text section and mark the readonly attribute in it */
d360 4
a363 1
	  found->flags |= SEC_READONLY;
d403 2
a404 2
	 executable file and it doesn't end in .exe, copy it to one which does. */

d408 1
a408 1
	  if (len < 4 
d499 1
a499 1
		  einfo(_("%P%F: missing argument to -m\n"));
d547 1
a547 1
  buf = (char *) xmalloc (dirlen + sizeof("/ldscripts"));
d572 2
a573 1
    return;			/* We've been installed normally.  */
d581 1
a581 1
    if (bslash > end)
d601 2
a602 1
    return;			/* Don't free dir.  */
d609 2
a610 1
  free (dir);			/* Well, we tried.  */
d625 1
a625 1
    }      
a721 1
/*ARGSUSED*/
a835 1
/*ARGSUSED*/
d864 7
a878 1
/*ARGSUSED*/
a944 1
/*ARGSUSED*/
d1033 1
a1033 2
struct warning_callback_info
{
a1041 1
/*ARGSUSED*/
a1162 1
/*ARGSUSED*/
d1170 1
a1170 1
     boolean fatal;
d1208 1
a1208 1
      error_name = buystring (name);
a1242 1
/*ARGSUSED*/
a1265 1
/*ARGSUSED*/
a1284 1
/*ARGSUSED*/
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d30 1
d87 3
d94 1
d121 1
a121 1
					 asection *, bfd_vma));
d170 6
d187 10
d202 1
d206 9
d222 2
a225 2
  link_info.lprefix_len = 1;
  link_info.lprefix = "L";
d234 6
a239 1
  
d260 6
a265 2
      if (command_line.relax)
	einfo ("%P%F: -relax and -r may not be used together\n");
d267 1
a267 1
	einfo ("%P%F: -r and -shared may not be used together\n");
d296 1
a296 1
	      info_msg ("using internal linker script:\n");
d315 1
a315 1
      einfo ("%P%F: no input files\n");
d320 1
a320 1
      info_msg ("%P: mode %s\n", emulation);
d338 1
a338 1
	      einfo ("%P%F: cannot open map file %s: %E\n",
d384 1
a384 1
	  einfo ("%P: link errors found, deleting executable `%s'\n",
d395 1
a395 1
	einfo ("%F%B: final close failed: %E\n", output_bfd);
d419 1
a419 1
		einfo ("%X%P: unable to open for source of copy `%s'\n", output_filename);
d421 1
a421 1
		einfo ("%X%P: unable to open for destination of copy `%s'\n", dst_name);
d427 1
a427 1
		      einfo ("%P: Error writing file `%s'\n", dst_name);
d431 1
a431 1
	      if (!fclose (dst))
d433 1
a433 1
		  einfo ("%P: Error closing file `%s'\n", dst_name);
a444 1
      extern char **environ;
d450 1
a450 1
      fprintf (stderr, "%s: total time in link: %ld.%06ld\n",
d453 1
a453 1
      fprintf (stderr, "%s: data size %ld\n", program_name,
d476 1
a476 1
  emulation = (char *) getenv (EMULATION_ENVIRON);
d494 1
a494 1
		  einfo("%P%F: missing argument to -m\n");
d571 8
d616 1
a616 1
	einfo ("%P%F: bfd_hash_table_init failed: %E\n");
d621 1
a621 1
    einfo ("%P%F: bfd_hash_lookup failed: %E\n");
d637 1
a637 1
	einfo ("%P%F: bfd_hash_table_init failed: %E\n");
d640 1
a640 1
    einfo ("%P%F: bfd_hash_lookup failed: %E\n");
d655 1
a655 1
    einfo ("%X%P: error: duplicate retain-symbols-file\n");
d668 1
a668 1
    einfo ("%P%F: bfd_hash_table_init failed: %E\n");
d699 1
a699 1
	    einfo ("%P%F: bfd_hash_lookup for insertion failed: %E\n");
d704 1
a704 1
    einfo ("%P: `-retain-symbols-file' overrides `-s' and `-S'\n");
d717 1
a717 1
     struct bfd_link_info *info;
d781 2
a782 2
	  sprintf (buf, "%-29s %s\n\n", "Archive member included",
		   "because of file (symbol)");
d832 1
a832 1
     struct bfd_link_info *info;
d847 1
d850 1
d854 1
a854 1
  einfo ("%X%C: multiple definition of `%T'\n",
d857 1
a857 1
    einfo ("%D: first defined here\n", obfd, osec, oval);
d869 1
a869 1
     struct bfd_link_info *info;
d886 1
a886 1
      einfo ("%B: warning: definition of `%T' overriding common\n",
d889 1
a889 1
	einfo ("%B: warning: common is here\n", obfd);
d896 1
a896 1
      einfo ("%B: warning: common of `%T' overridden by definition\n",
d899 1
a899 1
	einfo ("%B: warning: defined here\n", obfd);
d906 1
a906 1
	  einfo ("%B: warning: common of `%T' overridden by larger common\n",
d909 1
a909 1
	    einfo ("%B: warning: larger common is here\n", obfd);
d913 1
a913 1
	  einfo ("%B: warning: common of `%T' overriding smaller common\n",
d916 1
a916 1
	    einfo ("%B: warning: smaller common is here\n", obfd);
d920 1
a920 1
	  einfo ("%B: warning: multiple common of `%T'\n", nbfd, name);
d922 1
a922 1
	    einfo ("%B: warning: previous common is here\n", obfd);
d936 1
a936 1
     struct bfd_link_info *info;
d944 1
a944 1
    einfo ("%P: warning: global constructor %s used\n",
d983 1
a983 1
    einfo ("%P: warning: global constructor %s used\n", name);
d993 1
a993 1
    einfo ("%P%F: BFD backend error: BFD_RELOC_CTOR unsupported\n");
d1005 1
a1005 1
    einfo ("%P%F: bfd_link_hash_lookup failed: %E\n");
d1035 1
a1035 1
     struct bfd_link_info *info;
d1073 1
a1073 1
	    einfo ("%B%F: could not read symbols: %E\n", abfd);
d1077 1
a1077 1
	    einfo ("%B%F: could not read symbols: %E\n", abfd);
d1123 1
a1123 1
    einfo ("%B%F: could not read relocs: %E\n", abfd);
d1130 1
a1130 1
    einfo ("%B%F: could not read relocs: %E\n", abfd);
d1156 2
a1157 2
undefined_symbol (info, name, abfd, section, address)
     struct bfd_link_info *info;
d1162 1
d1180 1
a1180 1
	    einfo ("%F%P: bfd_hash_table_init failed: %E\n");
d1187 1
a1187 1
	einfo ("%F%P: bfd_hash_lookup failed: %E\n");
d1206 6
a1211 2
	einfo ("%X%C: undefined reference to `%T'\n",
	       abfd, section, address, name);
d1213 1
a1213 1
	einfo ("%D: more undefined references to `%T' follow\n",
d1219 6
a1224 2
	einfo ("%X%B: undefined reference to `%T'\n",
	       abfd, name);
d1226 1
a1226 1
	einfo ("%B: more undefined references to `%T' follow\n",
d1238 1
a1238 1
     struct bfd_link_info *info;
d1247 1
a1247 1
    einfo ("%P%X: generated");
d1250 1
a1250 1
  einfo (" relocation truncated to fit: %s %T", reloc_name, name);
d1262 1
a1262 1
     struct bfd_link_info *info;
d1269 1
a1269 1
    einfo ("%P%X: generated");
d1272 1
a1272 1
  einfo ("dangerous relocation: %s\n", message);
d1282 1
a1282 1
     struct bfd_link_info *info;
d1289 1
a1289 1
    einfo ("%P%X: generated");
d1292 1
a1292 1
  einfo (" reloc refers to symbol `%T' which is not being output\n", name);
d1311 6
a1316 3
    einfo ("%B: %s %s\n", abfd,
	   bfd_is_und_section (section) ? "reference to" : "definition of",
	   name);
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d459 2
a460 1
		   || strcmp (argv[i], "-mips3") == 0)
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 1995 Free Software Foundation, Inc.
d18 3
a20 3
along with GLD; see the file COPYING.  If not, write to
the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

d49 6
d330 1
a330 1
  if (link_info.notice_all)
d332 2
d687 3
a689 4
     next_real_file, is_archive, target, real, common_section,
     common_output_section, complained.  This bit of code is from the
     old decode_library_subfile function.  I don't know whether any of
     those fields matters.  */
d1042 3
d1255 1
a1255 1
  if (info->notice_all)
@


1.1
log
@Initial revision
@
text
@d118 2
a119 2
static boolean notice_ysym PARAMS ((struct bfd_link_info *, const char *,
				    bfd *, asection *, bfd_vma));
d133 1
a133 1
  notice_ysym
d165 2
a171 1
  config.traditional_format = false;
d183 1
d193 1
d195 1
a195 1

d322 5
d339 1
a339 2
      if (output_bfd->iostream)
	fclose ((FILE *) (output_bfd->iostream));
a340 1
      unlink (output_filename);
d347 43
d567 19
d687 76
a762 1
    minfo ("%s needed due to %T\n", abfd->filename, name);
d785 11
d932 3
a934 1
  if (bfd_reloc_type_lookup (output_bfd, BFD_RELOC_CTOR) == NULL)
a944 4
  if (config.map_file != (FILE *) NULL)
    fprintf (config.map_file,
	     "Adding %s to constructor/destructor set %s\n", name, set_name);

d984 6
d1226 3
a1228 2
/* This is called when a symbol in notice_hash is found.  Symbols are
   put in notice_hash using the -y option.  */
a1229 1
/*ARGSUSED*/
d1231 1
a1231 1
notice_ysym (info, name, abfd, section, value)
d1238 10
a1247 3
  einfo ("%B: %s %s\n", abfd,
	 bfd_is_und_section (section) ? "reference to" : "definition of",
	 name);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d118 2
a119 2
static boolean notice PARAMS ((struct bfd_link_info *, const char *,
			       bfd *, asection *, bfd_vma));
d133 1
a133 1
  notice
a164 2
  bfd_set_error_program_name (program_name);

d170 1
a181 1
  link_info.traditional_format = false;
a190 1
  link_info.notice_all = false;
d192 1
a192 1
  link_info.wrap_hash = NULL;
a318 5
  if (config.map_file != NULL)
    lang_map ();
  if (link_info.notice_all)
    output_cref (config.map_file != NULL ? config.map_file : stdout);

d331 2
a332 1
      /* The file will be removed by remove_output.  */
d334 1
a340 43

      /* If the --force-exe-suffix is enabled, and we're making an
	 executable file and it doesn't end in .exe, copy it to one which does. */

      if (! link_info.relocateable && command_line.force_exe_suffix)
	{
	  int len = strlen (output_filename);
	  if (len < 4 
	      || (strcasecmp (output_filename + len - 4, ".exe") != 0
		  && strcasecmp (output_filename + len - 4, ".dll") != 0))
	    {
	      FILE *src;
	      FILE *dst;
	      const int bsize = 4096;
	      char *buf = xmalloc (bsize);
	      int l;
	      char *dst_name = xmalloc (len + 5);
	      strcpy (dst_name, output_filename);
	      strcat (dst_name, ".exe");
	      src = fopen (output_filename, FOPEN_RB);
	      dst = fopen (dst_name, FOPEN_WB);

	      if (!src)
		einfo ("%X%P: unable to open for source of copy `%s'\n", output_filename);
	      if (!dst)
		einfo ("%X%P: unable to open for destination of copy `%s'\n", dst_name);
	      while ((l = fread (buf, 1, bsize, src)) > 0)
		{
		  int done = fwrite (buf, 1, l, dst);
		  if (done != l)
		    {
		      einfo ("%P: Error writing file `%s'\n", dst_name);
		    }
		}
	      fclose (src);
	      if (!fclose (dst))
		{
		  einfo ("%P: Error closing file `%s'\n", dst_name);
		}
	      free (dst_name);
	      free (buf);
	    }
	}
a517 19
/* Record a symbol to be wrapped, from the --wrap option.  */

void
add_wrap (name)
     const char *name;
{
  if (link_info.wrap_hash == NULL)
    {
      link_info.wrap_hash = ((struct bfd_hash_table *)
			     xmalloc (sizeof (struct bfd_hash_table)));
      if (! bfd_hash_table_init_n (link_info.wrap_hash,
				   bfd_hash_newfunc,
				   61))
	einfo ("%P%F: bfd_hash_table_init failed: %E\n");
    }
  if (bfd_hash_lookup (link_info.wrap_hash, name, true, true) == NULL)
    einfo ("%P%F: bfd_hash_lookup failed: %E\n");
}

d619 1
a619 76
    {
      static boolean header_printed;
      struct bfd_link_hash_entry *h;
      bfd *from;
      int len;

      h = bfd_link_hash_lookup (link_info.hash, name, false, false, true);

      if (h == NULL)
	from = NULL;
      else
	{
	  switch (h->type)
	    {
	    default:
	      from = NULL;
	      break;

	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      from = h->u.def.section->owner;
	      break;

	    case bfd_link_hash_undefined:
	    case bfd_link_hash_undefweak:
	      from = h->u.undef.abfd;
	      break;

	    case bfd_link_hash_common:
	      from = h->u.c.p->section->owner;
	      break;
	    }
	}

      if (! header_printed)
	{
	  char buf[100];

	  sprintf (buf, "%-29s %s\n\n", "Archive member included",
		   "because of file (symbol)");
	  minfo ("%s", buf);
	  header_printed = true;
	}

      if (bfd_my_archive (abfd) == NULL)
	{
	  minfo ("%s", bfd_get_filename (abfd));
	  len = strlen (bfd_get_filename (abfd));
	}
      else
	{
	  minfo ("%s(%s)", bfd_get_filename (bfd_my_archive (abfd)),
		 bfd_get_filename (abfd));
	  len = (strlen (bfd_get_filename (bfd_my_archive (abfd)))
		 + strlen (bfd_get_filename (abfd))
		 + 2);
	}

      if (len >= 29)
	{
	  print_nl ();
	  len = 0;
	}
      while (len < 30)
	{
	  print_space ();
	  ++len;
	}

      if (from != NULL)
	minfo ("%B ", from);
      if (h != NULL)
	minfo ("(%T)\n", h->root.string);
      else
	minfo ("(%s)\n", name);
    }
a641 11
  /* If either section has the output_section field set to
     bfd_abs_section_ptr, it means that the section is being
     discarded, and this is not really a multiple definition at all.
     FIXME: It would be cleaner to somehow ignore symbols defined in
     sections which are being discarded.  */
  if ((osec->output_section != NULL
       && bfd_is_abs_section (osec->output_section))
      || (nsec->output_section != NULL
	  && bfd_is_abs_section (nsec->output_section)))
    return true;

d778 1
a778 3
  if (bfd_reloc_type_lookup (output_bfd, BFD_RELOC_CTOR) == NULL
      && (link_info.relocateable
	  || bfd_reloc_type_lookup (abfd, BFD_RELOC_CTOR) == NULL))
d789 4
a831 6
  /* This is a hack to support warn_multiple_gp.  FIXME: This should
     have a cleaner interface, but what?  */
  if (! config.warn_multiple_gp
      && strcmp (warning, "using multiple gp values") == 0)
    return true;

d1068 2
a1069 3
/* This is called if link_info.notice_all is set, or when a symbol in
   link_info.notice_hash is found.  Symbols are put in notice_hash
   using the -y option.  */
d1071 1
d1073 1
a1073 1
notice (info, name, abfd, section, value)
d1080 3
a1082 10
  if (! info->notice_all
      || (info->notice_hash != NULL
	  && bfd_hash_lookup (info->notice_hash, name, false, false) != NULL))
    einfo ("%B: %s %s\n", abfd,
	   bfd_is_und_section (section) ? "reference to" : "definition of",
	   name);

  if (info->notice_all)
    add_cref (name, abfd, section, value);

@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d18 3
a20 3
along with GLD; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
a48 6
#ifdef HAVE_SBRK
#ifdef NEED_DECLARATION_SBRK
extern PTR sbrk ();
#endif
#endif

d324 1
a324 1
  if (command_line.cref)
a325 2
  if (nocrossref_list != NULL)
    check_nocrossrefs ();
d679 4
a682 3
     next_real_file, is_archive, target, real.  This bit of code is
     from the old decode_library_subfile function.  I don't know
     whether any of those fields matters.  */
a1034 3

      if (entry == NULL)
	free (asymbols);
d1245 1
a1245 1
  if (command_line.cref || nocrossref_list != NULL)
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d459 1
a459 2
		   || strcmp (argv[i], "-mips3") == 0
		   || strcmp (argv[i], "-mips4") == 0)
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
a88 1
static void remove_output PARAMS ((void));
a174 10
  /* Set the default BFD target based on the configured target.  Doing
     this permits the linker to be configured for a particular target,
     and linked against a shared BFD library which was configured for
     a different target.  The macro TARGET is defined by Makefile.  */
  if (! bfd_set_default_target (TARGET))
    {
      einfo ("%X%P: can't set BFD default target to `%s': %E\n", TARGET);
      xexit (1);
    }

d192 2
d390 1
a390 1
	      if (fclose (dst) == EOF)
d436 1
a436 1
  emulation = getenv (EMULATION_ENVIRON);
a798 1
       && ! bfd_is_abs_section (osec)
a800 1
	  && ! bfd_is_abs_section (nsec)
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
a28 1
#include "filenames.h"
a84 3
/* True if we should demangle symbol names.  */
boolean demangling;

d116 1
a116 1
					 asection *, bfd_vma, boolean));
a164 6
#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

d182 1
a182 1
      einfo (_("%X%P: can't set BFD default target to `%s': %E\n"), TARGET);
a190 1
  config.has_shared = false;
a193 9
  command_line.warn_mismatch = true;
  command_line.check_section_addresses = true;

  /* We initialize DEMANGLING based on the environment variable
     COLLECT_NO_DEMANGLE.  The gcc collect2 program will demangle the
     output of the linker, unless COLLECT_NO_DEMANGLE is set in the
     environment.  Acting the same way here lets us provide the same
     interface by default.  */
  demangling = getenv ("COLLECT_NO_DEMANGLE") == NULL;
a200 2
  link_info.optimize = false;
  link_info.no_undefined = false;
d211 1
a211 6
  link_info.mpc860c0 = 0;
  /* SVR4 linkers seem to set DT_INIT and DT_FINI based on magic _init
     and _fini symbols.  We are compatible.  */
  link_info.init_function = "_init";
  link_info.fini_function = "_fini";

d232 2
a233 6
      if (command_line.gc_sections)
	einfo ("%P%F: --gc-sections and -r may not be used together\n");
      if (link_info.mpc860c0)
	einfo (_("%P%F: -r and --mpc860c0 may not be used together\n"));
      else if (command_line.relax)
	einfo (_("%P%F: --relax and -r may not be used together\n"));
d235 1
a235 1
	einfo (_("%P%F: -r and -shared may not be used together\n"));
d264 1
a264 1
	      info_msg (_("using internal linker script:\n"));
d283 1
a283 1
      einfo (_("%P%F: no input files\n"));
d288 1
a288 1
      info_msg (_("%P: mode %s\n"), emulation);
d306 1
a306 1
	      einfo (_("%P%F: cannot open map file %s: %E\n"),
d352 1
a352 1
	  einfo (_("%P: link errors found, deleting executable `%s'\n"),
d363 1
a363 1
	einfo (_("%F%B: final close failed: %E\n"), output_bfd);
d387 1
a387 1
		einfo (_("%X%P: unable to open for source of copy `%s'\n"), output_filename);
d389 1
a389 1
		einfo (_("%X%P: unable to open for destination of copy `%s'\n"), dst_name);
d395 1
a395 1
		      einfo (_("%P: Error writing file `%s'\n"), dst_name);
d401 1
a401 1
		  einfo (_("%P: Error closing file `%s'\n"), dst_name);
d413 1
d419 1
a419 1
      fprintf (stderr, _("%s: total time in link: %ld.%06ld\n"),
d422 1
a422 1
      fprintf (stderr, _("%s: data size %ld\n"), program_name,
d463 1
a463 1
		  einfo(_("%P%F: missing argument to -m\n"));
a539 8
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have \foo\bar, or /foo\bar.  */
    char *bslash = strrchr (program_name, '\\');
    if (bslash > end)
      end = bslash;
  }
#endif
d577 1
a577 1
	einfo (_("%P%F: bfd_hash_table_init failed: %E\n"));
d582 1
a582 1
    einfo (_("%P%F: bfd_hash_lookup failed: %E\n"));
d598 1
a598 1
	einfo (_("%P%F: bfd_hash_table_init failed: %E\n"));
d601 1
a601 1
    einfo (_("%P%F: bfd_hash_lookup failed: %E\n"));
d616 1
a616 1
    einfo (_("%X%P: error: duplicate retain-symbols-file\n"));
d629 1
a629 1
    einfo (_("%P%F: bfd_hash_table_init failed: %E\n"));
d660 1
a660 1
	    einfo (_("%P%F: bfd_hash_lookup for insertion failed: %E\n"));
d665 1
a665 1
    einfo (_("%P: `-retain-symbols-file' overrides `-s' and `-S'\n"));
d678 1
a678 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d742 2
a743 2
	  sprintf (buf, "%-29s %s\n\n", _("Archive member included"),
		   _("because of file (symbol)"));
d793 1
a793 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d815 1
a815 1
  einfo (_("%X%C: multiple definition of `%T'\n"),
d818 1
a818 1
    einfo (_("%D: first defined here\n"), obfd, osec, oval);
d830 1
a830 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d847 1
a847 1
      einfo (_("%B: warning: definition of `%T' overriding common\n"),
d850 1
a850 1
	einfo (_("%B: warning: common is here\n"), obfd);
d857 1
a857 1
      einfo (_("%B: warning: common of `%T' overridden by definition\n"),
d860 1
a860 1
	einfo (_("%B: warning: defined here\n"), obfd);
d867 1
a867 1
	  einfo (_("%B: warning: common of `%T' overridden by larger common\n"),
d870 1
a870 1
	    einfo (_("%B: warning: larger common is here\n"), obfd);
d874 1
a874 1
	  einfo (_("%B: warning: common of `%T' overriding smaller common\n"),
d877 1
a877 1
	    einfo (_("%B: warning: smaller common is here\n"), obfd);
d881 1
a881 1
	  einfo (_("%B: warning: multiple common of `%T'\n"), nbfd, name);
d883 1
a883 1
	    einfo (_("%B: warning: previous common is here\n"), obfd);
d897 1
a897 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d905 1
a905 1
    einfo (_("%P: warning: global constructor %s used\n"),
d944 1
a944 1
    einfo (_("%P: warning: global constructor %s used\n"), name);
d954 1
a954 1
    einfo (_("%P%F: BFD backend error: BFD_RELOC_CTOR unsupported\n"));
d966 1
a966 1
    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
d996 1
a996 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d1034 1
a1034 1
	    einfo (_("%B%F: could not read symbols: %E\n"), abfd);
d1038 1
a1038 1
	    einfo (_("%B%F: could not read symbols: %E\n"), abfd);
d1084 1
a1084 1
    einfo (_("%B%F: could not read relocs: %E\n"), abfd);
d1091 1
a1091 1
    einfo (_("%B%F: could not read relocs: %E\n"), abfd);
d1117 2
a1118 2
undefined_symbol (info, name, abfd, section, address, fatal)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
a1122 1
     boolean fatal;
d1140 1
a1140 1
	    einfo (_("%F%P: bfd_hash_table_init failed: %E\n"));
d1147 1
a1147 1
	einfo (_("%F%P: bfd_hash_lookup failed: %E\n"));
d1166 2
a1167 6
	{
	  einfo (_("%C: undefined reference to `%T'\n"),
		 abfd, section, address, name);
	  if (fatal)
	    einfo ("%X");
	}
d1169 1
a1169 1
	einfo (_("%D: more undefined references to `%T' follow\n"),
d1175 2
a1176 6
	{
	  einfo (_("%B: undefined reference to `%T'\n"),
		 abfd, name);
	  if (fatal)
	    einfo ("%X");
	}
d1178 1
a1178 1
	einfo (_("%B: more undefined references to `%T' follow\n"),
d1190 1
a1190 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d1199 1
a1199 1
    einfo (_("%P%X: generated"));
d1202 1
a1202 1
  einfo (_(" relocation truncated to fit: %s %T"), reloc_name, name);
d1214 1
a1214 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d1221 1
a1221 1
    einfo (_("%P%X: generated"));
d1224 1
a1224 1
  einfo (_("dangerous relocation: %s\n"), message);
d1234 1
a1234 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d1241 1
a1241 1
    einfo (_("%P%X: generated"));
d1244 1
a1244 1
  einfo (_(" reloc refers to symbol `%T' which is not being output\n"), name);
d1263 3
a1265 6
    {
      if (bfd_is_und_section (section))
	einfo ("%B: reference to %s\n", abfd, name);
      else
	einfo ("%B: definition of %s\n", abfd, name);
    }
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
d39 1
a41 1
#include "ldemul.h"
d44 1
a44 1
/* Somewhere above, sys/stat.h got included . . . .  */
d68 1
a68 1
/* The file that we're creating.  */
d133 2
a134 1
static struct bfd_link_callbacks link_callbacks = {
d153 1
a153 1
  if (output_filename)
d156 1
a156 1
	fclose ((FILE *) (output_bfd->iostream));
a202 2
  config.split_by_reloc = (unsigned) -1;
  config.split_by_file = (bfd_size_type) -1;
a217 1
  link_info.emitrelocations = false;
a223 1
  link_info.allow_shlib_undefined = false;
a238 3
  link_info.new_dtags = false;
  link_info.flags = (bfd_vma) 0;
  link_info.flags_1 = (bfd_vma) 0;
d246 1
d325 1
d344 1
d348 2
a349 1
     symbols, and possibly multiple definitions.  */
d351 1
a351 1
  if (! link_info.relocateable)
d353 1
a353 1
      /* Look for a text section and switch the readonly attribute in it.  */
d358 1
a358 4
	  if (config.text_read_only)
	    found->flags |= SEC_READONLY;
	  else
	    found->flags &= ~SEC_READONLY;
d398 2
a399 2
	 executable file and it doesn't end in .exe, copy it to one
	 which does.  */
d403 1
a403 1
	  if (len < 4
d494 1
a494 1
		  einfo (_("%P%F: missing argument to -m\n"));
d542 1
a542 1
  buf = (char *) xmalloc (dirlen + sizeof ("/ldscripts"));
d567 1
a567 2
    /* We've been installed normally.  */
    return;
d575 1
a575 1
    if (end == NULL || (bslash != NULL && bslash > end))
d595 1
a595 2
    /* Don't free dir.  */
    return;
d602 1
a602 2
  /* Well, we tried.  */
  free (dir);
d617 1
a617 1
    }
d714 1
d829 1
a857 7

  if (command_line.relax)
    {
      einfo (_("%P: Disabling relaxation: it will not work with multiple definitions\n"));
      command_line.relax = 0;
    }

d866 1
d933 1
d1022 2
a1023 1
struct warning_callback_info {
d1032 1
d1154 1
d1162 1
a1162 1
     boolean fatal ATTRIBUTE_UNUSED;
d1200 1
a1200 1
      error_name = xstrdup (name);
d1235 1
d1259 1
d1279 1
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003
d6 1
a6 1
   This file is part of GLD, the Gnu Linker.
d8 14
a21 14
   GLD is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GLD is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GLD; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d26 1
a26 1
#include "safe-ctype.h"
d36 1
a38 1
#include <ldgram.h>
d44 1
a44 1
/* Somewhere above, sys/stat.h got included.  */
d57 2
a58 5
#ifndef TARGET_SYSTEM_ROOT
#define TARGET_SYSTEM_ROOT ""
#endif

int main PARAMS ((int, char **));
a67 7
/* The prefix for system library directories.  */
char *ld_sysroot;

/* The canonical representation of ld_sysroot.  */
char * ld_canon_sysroot;
int ld_canon_sysroot_len;

d75 1
a75 1
bfd_boolean trace_files;
d78 1
a78 1
bfd_boolean trace_file_tries;
d82 1
a82 1
bfd_boolean version_printed;
d85 1
a85 1
bfd_boolean whole_archive;
d87 2
a88 2
/* TRUE if we should demangle symbol names.  */
bfd_boolean demangling;
d94 38
a131 40
static char *get_emulation
  PARAMS ((int, char **));
static void set_scripts_dir
  PARAMS ((void));
static void remove_output
  PARAMS ((void));
static bfd_boolean check_for_scripts_dir
  PARAMS ((char *));
static bfd_boolean add_archive_element
  PARAMS ((struct bfd_link_info *, bfd *, const char *));
static bfd_boolean multiple_definition
  PARAMS ((struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma,
	   bfd *, asection *, bfd_vma));
static bfd_boolean multiple_common
  PARAMS ((struct bfd_link_info *, const char *, bfd *,
	   enum bfd_link_hash_type, bfd_vma, bfd *, enum bfd_link_hash_type,
	   bfd_vma));
static bfd_boolean add_to_set
  PARAMS ((struct bfd_link_info *, struct bfd_link_hash_entry *,
	   bfd_reloc_code_real_type, bfd *, asection *, bfd_vma));
static bfd_boolean constructor_callback
  PARAMS ((struct bfd_link_info *, bfd_boolean, const char *, bfd *,
	   asection *, bfd_vma));
static bfd_boolean warning_callback
  PARAMS ((struct bfd_link_info *, const char *, const char *, bfd *,
	   asection *, bfd_vma));
static void warning_find_reloc
  PARAMS ((bfd *, asection *, PTR));
static bfd_boolean undefined_symbol
  PARAMS ((struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma,
	   bfd_boolean));
static bfd_boolean reloc_overflow
  PARAMS ((struct bfd_link_info *, const char *, const char *, bfd_vma,
	   bfd *, asection *, bfd_vma));
static bfd_boolean reloc_dangerous
  PARAMS ((struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma));
static bfd_boolean unattached_reloc
  PARAMS ((struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma));
static bfd_boolean notice
  PARAMS ((struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma));
d133 1
a133 2
static struct bfd_link_callbacks link_callbacks =
{
d144 1
a144 2
  notice,
  error_handler
a171 3
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
a185 46
#ifdef TARGET_SYSTEM_ROOT_RELOCATABLE
  ld_sysroot = make_relative_prefix (program_name, BINDIR,
				     TARGET_SYSTEM_ROOT);

  if (ld_sysroot)
    {
      struct stat s;
      int res = stat (ld_sysroot, &s) == 0 && S_ISDIR (s.st_mode);

      if (!res)
	{
	  free (ld_sysroot);
	  ld_sysroot = NULL;
	}
    }

  if (! ld_sysroot)
    {
      ld_sysroot = make_relative_prefix (program_name, TOOLBINDIR,
					 TARGET_SYSTEM_ROOT);

      if (ld_sysroot)
	{
	  struct stat s;
	  int res = stat (ld_sysroot, &s) == 0 && S_ISDIR (s.st_mode);

	  if (!res)
	    {
	      free (ld_sysroot);
	      ld_sysroot = NULL;
	    }
	}
    }

  if (! ld_sysroot)
#endif
    ld_sysroot = TARGET_SYSTEM_ROOT;

  if (ld_sysroot && *ld_sysroot)
    ld_canon_sysroot = lrealpath (ld_sysroot);

  if (ld_canon_sysroot)
    ld_canon_sysroot_len = strlen (ld_canon_sysroot);
  else
    ld_canon_sysroot_len = -1;

a195 7
#if YYDEBUG
  {
    extern int yydebug;
    yydebug = 1;
  }
#endif

d197 5
a201 5
  trace_files = trace_file_tries = version_printed = FALSE;
  whole_archive = FALSE;
  config.build_constructors = TRUE;
  config.dynamic_link = FALSE;
  config.has_shared = FALSE;
d204 1
a204 2
  command_line.force_common_definition = FALSE;
  command_line.inhibit_common_definition = FALSE;
d207 2
a208 3
  command_line.warn_mismatch = TRUE;
  command_line.check_section_addresses = TRUE;
  command_line.accept_unknown_input_arch = FALSE;
d217 10
a226 20
  link_info.relocateable = FALSE;
  link_info.emitrelocations = FALSE;
  link_info.task_link = FALSE;
  link_info.shared = FALSE;
  link_info.symbolic = FALSE;
  link_info.export_dynamic = FALSE;
  link_info.static_link = FALSE;
  link_info.traditional_format = FALSE;
  link_info.optimize = FALSE;
  link_info.no_undefined = FALSE;
  link_info.allow_shlib_undefined = TRUE;
  link_info.allow_multiple_definition = FALSE;
  link_info.allow_undefined_version = TRUE;
  link_info.keep_memory = TRUE;
  link_info.notice_all = FALSE;
  link_info.nocopyreloc = FALSE;
  link_info.new_dtags = FALSE;
  link_info.combreloc = TRUE;
  link_info.eh_frame_hdr = FALSE;
  link_info.strip_discarded = TRUE;
d228 4
a231 3
  link_info.discard = discard_sec_merge;
  link_info.common_skip_ar_aymbols = bfd_link_common_skip_none;
  link_info.callbacks = &link_callbacks;
d234 1
d237 1
a237 4
  link_info.input_bfds = NULL;
  link_info.create_object_symbols_section = NULL;
  link_info.gc_sym_list = NULL;
  link_info.base_file = NULL;
d242 1
a242 4
  link_info.mpc860c0 = 0;
  link_info.pei386_auto_import = -1;
  link_info.pei386_runtime_pseudo_reloc = FALSE;
  link_info.spare_dynamic_tags = 5;
a244 1
  link_info.relax_finalizing = FALSE;
d248 4
a251 4
  config.make_executable = TRUE;
  force_make_executable = FALSE;
  config.magic_demand_paged = TRUE;
  config.text_read_only = TRUE;
d255 1
a255 1
  default_target = ldemul_choose_target (argc, argv);
d258 1
a258 1
  lang_has_input_file = FALSE;
a274 8
  if (! link_info.shared)
    {
      if (command_line.filter_shlib)
	einfo (_("%P%F: -F may not be used without -shared\n"));
      if (command_line.auxiliary_filters)
	einfo (_("%P%F: -f may not be used without -shared\n"));
    }

d281 1
a281 1
      if (link_info.discard == discard_sec_merge)
d289 1
a289 3
  /* If we have not already opened and parsed a linker script
     read the emulation's appropriate default script.  */
  if (saved_script_handle == NULL)
d291 1
d299 7
a313 33
  if (trace_file_tries)
    {
      if (saved_script_handle)
	info_msg (_("using external linker script:"));
      else
	info_msg (_("using internal linker script:"));
      info_msg ("\n==================================================\n");

      if (saved_script_handle)
	{
	  static const int ld_bufsz = 8193;
	  size_t n;
	  char *buf = xmalloc (ld_bufsz);

	  rewind (saved_script_handle);
	  while ((n = fread (buf, 1, ld_bufsz - 1, saved_script_handle)) > 0)
	    {
	      buf[n] = 0;
	      info_msg (buf);
	    }
	  rewind (saved_script_handle);
	  free (buf);
	}
      else
	{
	  int isfile;

	  info_msg (ldemul_get_script (&isfile));
	}

      info_msg ("\n==================================================\n");
    }

d316 1
a316 1
  if (!lang_has_input_file)
d324 3
a326 1
    info_msg (_("%P: mode %s\n"), emulation);
d352 15
d384 2
a385 1
  if (!config.make_executable && !force_make_executable)
d387 5
a391 3
      if (trace_files)
	einfo (_("%P: link errors found, deleting executable `%s'\n"),
	       output_filename);
d394 1
a407 1

a417 1

a429 1

d431 3
a433 1
		    einfo (_("%P: Error writing file `%s'\n"), dst_name);
a434 1

d437 3
a439 1
		einfo (_("%P: Error closing file `%s'\n"), dst_name);
d498 3
a500 1
		einfo (_("%P%F: missing argument to -m\n"));
d505 1
a505 5
		   || strcmp (argv[i], "-mips4") == 0
		   || strcmp (argv[i], "-mips5") == 0
		   || strcmp (argv[i], "-mips32") == 0
		   || strcmp (argv[i], "-mips32r2") == 0
		   || strcmp (argv[i], "-mips64") == 0)
d507 1
a507 1
	      /* FIXME: The arguments -mips1, -mips2, -mips3, etc. are
d533 2
a534 2
   add DIR to the library search path and return TRUE,
   else return FALSE.  */
d536 1
a536 1
static bfd_boolean
d543 1
a543 1
  bfd_boolean res;
d553 1
a553 1
    ldfile_add_library_path (dir, FALSE);
a561 2
	     (adjusted according to the current location of the binary)
   SCRIPTDIR (passed from Makefile)
d563 1
a563 2
   the dir where this program is/../lib
	     (for installing the tool suite elsewhere).  */
a569 19
  bfd_boolean found;

  dir = make_relative_prefix (program_name, BINDIR, SCRIPTDIR);
  if (dir)
    {
      found = check_for_scripts_dir (dir);
      free (dir);
      if (found)
	return;
    }

  dir = make_relative_prefix (program_name, TOOLBINDIR, SCRIPTDIR);
  if (dir)
    {
      found = check_for_scripts_dir (dir);
      free (dir);
      if (found)
	return;
    }
a580 1

d587 5
a591 3
    /* Don't look for ldscripts in the current directory.  There is
       too much potential for confusion.  */
    return;
d601 2
a602 4
    {
      free (dir);
      return;
    }
d606 4
a609 1
  check_for_scripts_dir (dir);
d627 1
a627 1
  if (bfd_hash_lookup (link_info.notice_hash, name, TRUE, TRUE)
d647 1
a647 2

  if (bfd_hash_lookup (link_info.wrap_hash, name, TRUE, TRUE) == NULL)
d684 1
a684 1
      while (ISSPACE (c))
d691 1
a691 1
	  while (! ISSPACE (c) && c != EOF)
d705 1
a705 1
	  if (bfd_hash_lookup (link_info.keep_hash, buf, TRUE, TRUE)
a713 1
  free (buf);
d722 1
a722 1
static bfd_boolean
d737 3
a739 3
  input->just_syms_flag = FALSE;
  input->loaded = FALSE;
  input->search_dirs_flag = FALSE;
d751 1
a751 1
      static bfd_boolean header_printed;
d756 1
a756 1
      h = bfd_link_hash_lookup (link_info.hash, name, FALSE, FALSE, TRUE);
d788 2
a789 1
	  sprintf (buf, _("Archive member included because of file (symbol)\n\n"));
d791 1
a791 1
	  header_printed = TRUE;
d830 1
a830 1
  return TRUE;
d836 1
a836 1
static bfd_boolean
d858 1
a858 1
    return TRUE;
d871 1
a871 1
  return TRUE;
d879 1
a879 1
static bfd_boolean
d891 1
a891 1
    return TRUE;
d938 1
a938 1
  return TRUE;
d945 1
a945 1
static bfd_boolean
d959 1
a959 1
    return TRUE;
d972 1
a972 1
  return TRUE;
d980 1
a980 1
static bfd_boolean
d983 1
a983 1
     bfd_boolean constructor;
d997 1
a997 1
    return TRUE;
d1014 1
a1014 1
  h = bfd_link_hash_lookup (info->hash, set_name, TRUE, TRUE, TRUE);
d1027 1
a1027 1
  return TRUE;
d1033 2
a1034 3
struct warning_callback_info
{
  bfd_boolean found;
d1042 1
a1042 1
static bfd_boolean
d1055 1
a1055 1
    return TRUE;
d1071 1
d1094 1
a1094 1
      info.found = FALSE;
d1107 1
a1107 1
  return TRUE;
d1153 1
a1153 1
	  info->found = TRUE;
d1163 1
a1163 1
static bfd_boolean
d1170 1
a1170 1
     bfd_boolean fatal ATTRIBUTE_UNUSED;
d1182 1
d1191 2
a1192 2
      if (bfd_hash_lookup (hash, name, FALSE, FALSE) != NULL)
	return TRUE;
d1194 1
a1194 1
      if (bfd_hash_lookup (hash, name, TRUE, TRUE) == NULL)
d1238 1
a1238 1
  return TRUE;
d1243 1
a1243 1
static bfd_boolean
d1261 1
a1261 1
  return TRUE;
d1266 1
a1266 1
static bfd_boolean
d1279 1
a1279 1
  return TRUE;
d1285 1
a1285 1
static bfd_boolean
d1298 1
a1298 1
  return TRUE;
d1305 1
a1305 1
static bfd_boolean
d1315 1
a1315 1
	  && bfd_hash_lookup (info->notice_hash, name, FALSE, FALSE) != NULL))
d1326 1
a1326 1
  return TRUE;
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2002, 2003, 2004
d54 1
a54 1
extern void *sbrk ();
d62 2
a97 4
/* Nonzero means create DT_NEEDED entries only if a dynamic library
   actually satisfies some reference in a regular object.  */
bfd_boolean as_needed;

d106 1
a106 1
  (int, char **);
d108 5
a112 1
  (void);
d114 1
a114 1
  (struct bfd_link_info *, bfd *, const char *);
d116 2
a117 2
  (struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma,
   bfd *, asection *, bfd_vma);
d119 3
a121 2
  (struct bfd_link_info *, const char *, bfd *, enum bfd_link_hash_type,
   bfd_vma, bfd *, enum bfd_link_hash_type, bfd_vma);
d123 2
a124 2
  (struct bfd_link_info *, struct bfd_link_hash_entry *,
   bfd_reloc_code_real_type, bfd *, asection *, bfd_vma);
d126 2
a127 2
  (struct bfd_link_info *, bfd_boolean, const char *, bfd *,
   asection *, bfd_vma);
d129 2
a130 2
  (struct bfd_link_info *, const char *, const char *, bfd *,
   asection *, bfd_vma);
d132 1
a132 1
  (bfd *, asection *, void *);
d134 2
a135 2
  (struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma,
   bfd_boolean);
d137 2
a138 2
  (struct bfd_link_info *, const char *, const char *, bfd_vma,
   bfd *, asection *, bfd_vma);
d140 1
a140 1
  (struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma);
d142 1
a142 1
  (struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma);
d144 1
a144 1
  (struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma);
d165 1
a165 1
remove_output (void)
d169 2
a170 2
      if (output_bfd)
	bfd_cache_close (output_bfd);
d177 3
a179 1
main (int argc, char **argv)
d290 1
a290 1
  link_info.relocatable = FALSE;
a293 2
  link_info.pie = FALSE;
  link_info.executable = FALSE;
d299 2
a300 2
  link_info.unresolved_syms_in_objects = RM_NOT_YET_SET;
  link_info.unresolved_syms_in_shared_libs = RM_NOT_YET_SET;
d326 1
d330 3
a332 3
  link_info.flags = 0;
  link_info.flags_1 = 0;
  link_info.need_relax_finalize = FALSE;
d351 1
a351 1
  if (link_info.relocatable)
d355 2
a370 3
  if (! link_info.shared || link_info.pie)
    link_info.executable = TRUE;

d374 1
a374 1
  if (link_info.relocatable && link_info.strip == strip_all)
d473 1
a473 1
  if (link_info.relocatable)
d487 1
a487 1
  /* Even if we're producing relocatable output, some non-fatal errors should
d489 1
a489 1
     want to ignore for relocatable output?)  */
d507 1
a507 1
      if (! link_info.relocatable && command_line.force_exe_suffix)
d528 1
a528 2
		einfo (_("%X%P: unable to open for source of copy `%s'\n"),
		       output_filename);
d530 1
a530 2
		einfo (_("%X%P: unable to open for destination of copy `%s'\n"),
		       dst_name);
d553 1
a553 1
      char *lim = sbrk (0);
d576 3
a578 1
get_emulation (int argc, char **argv)
d609 1
a609 2
		   || strcmp (argv[i], "-mips64") == 0
		   || strcmp (argv[i], "-mips64r2") == 0)
d641 2
a642 1
check_for_scripts_dir (char *dir)
d651 1
a651 1
  buf = xmalloc (dirlen + sizeof ("/ldscripts"));
d673 1
a673 1
set_scripts_dir (void)
d721 1
a721 1
  dir = xmalloc (dirlen + 8);
d738 2
a739 1
add_ysym (const char *name)
d741 1
a741 1
  if (link_info.notice_hash == NULL)
d743 2
a744 1
      link_info.notice_hash = xmalloc (sizeof (struct bfd_hash_table));
d751 2
a752 1
  if (bfd_hash_lookup (link_info.notice_hash, name, TRUE, TRUE) == NULL)
d759 2
a760 1
add_wrap (const char *name)
d764 2
a765 1
      link_info.wrap_hash = xmalloc (sizeof (struct bfd_hash_table));
d779 2
a780 1
add_keepsyms_file (const char *filename)
d791 1
a791 1
  if (file == NULL)
d798 2
a799 1
  link_info.keep_hash = xmalloc (sizeof (struct bfd_hash_table));
d804 1
a804 1
  buf = xmalloc (bufsize);
d830 2
a831 1
	  if (bfd_hash_lookup (link_info.keep_hash, buf, TRUE, TRUE) == NULL)
d849 4
a852 3
add_archive_element (struct bfd_link_info *info ATTRIBUTE_UNUSED,
		     bfd *abfd,
		     const char *name)
d856 2
a857 1
  input = xmalloc (sizeof (lang_input_statement_type));
d875 1
a875 1
  if (config.map_file != NULL)
d962 9
a970 8
multiple_definition (struct bfd_link_info *info ATTRIBUTE_UNUSED,
		     const char *name,
		     bfd *obfd,
		     asection *osec,
		     bfd_vma oval,
		     bfd *nbfd,
		     asection *nsec,
		     bfd_vma nval)
d987 1
a987 1
  if (obfd != NULL)
d1005 9
a1013 8
multiple_common (struct bfd_link_info *info ATTRIBUTE_UNUSED,
		 const char *name,
		 bfd *obfd,
		 enum bfd_link_hash_type otype,
		 bfd_vma osize,
		 bfd *nbfd,
		 enum bfd_link_hash_type ntype,
		 bfd_vma nsize)
d1071 7
a1077 6
add_to_set (struct bfd_link_info *info ATTRIBUTE_UNUSED,
	    struct bfd_link_hash_entry *h,
	    bfd_reloc_code_real_type reloc,
	    bfd *abfd,
	    asection *section,
	    bfd_vma value)
d1086 1
a1086 1
  ldctor_add_set_entry (h, reloc, NULL, section, value);
d1106 7
a1112 6
constructor_callback (struct bfd_link_info *info,
		      bfd_boolean constructor,
		      const char *name,
		      bfd *abfd,
		      asection *section,
		      bfd_vma value)
d1127 1
a1127 1
      && (link_info.relocatable
d1169 7
a1175 6
warning_callback (struct bfd_link_info *info ATTRIBUTE_UNUSED,
		  const char *warning,
		  const char *symbol,
		  bfd *abfd,
		  asection *section,
		  bfd_vma address)
d1208 1
a1208 1
	  asymbols = xmalloc (symsize);
d1223 1
a1223 1
      bfd_map_over_sections (abfd, warning_find_reloc, &info);
d1241 4
a1244 1
warning_find_reloc (bfd *abfd, asection *sec, void *iarg)
d1246 1
a1246 1
  struct warning_callback_info *info = iarg;
d1261 1
a1261 1
  relpp = xmalloc (relsize);
d1289 7
a1295 6
undefined_symbol (struct bfd_link_info *info ATTRIBUTE_UNUSED,
		  const char *name,
		  bfd *abfd,
		  asection *section,
		  bfd_vma address,
		  bfd_boolean error)
d1309 2
a1310 1
	  hash = xmalloc (sizeof (struct bfd_hash_table));
d1324 1
a1324 1
  if (error_name != NULL
d1330 1
a1330 1
      if (error_name != NULL)
d1339 4
a1342 6
	  if (error)
	    einfo (_("%X%C: undefined reference to `%T'\n"),
		   abfd, section, address, name);
	  else
	    einfo (_("%C: warning: undefined reference to `%T'\n"),
		   abfd, section, address, name);
d1345 2
a1346 10
	{
	  if (error)
	    einfo (_("%X%D: more undefined references to `%T' follow\n"),
		   abfd, section, address, name);
	  else
	    einfo (_("%D: warning: more undefined references to `%T' follow\n"),
		   abfd, section, address, name);
	}
      else if (error)
	einfo ("%X");
d1352 4
a1355 6
	  if (error)
	    einfo (_("%X%B: undefined reference to `%T'\n"),
		   abfd, name);
	  else
	    einfo (_("%B: warning: undefined reference to `%T'\n"),
		   abfd, name);
d1358 2
a1359 10
	{
	  if (error)
	    einfo (_("%X%B: more undefined references to `%T' follow\n"),
		   abfd, name);
	  else
	    einfo (_("%B: warning: more undefined references to `%T' follow\n"),
		   abfd, name);
	}
      else if (error)
	einfo ("%X");
a1364 9
/* Counter to limit the number of relocation overflow error messages
   to print.  Errors are printed as it is decremented.  When it's
   called and the counter is zero, a final message is printed
   indicating more relocations were omitted.  When it gets to -1, no
   such errors are printed.  If it's initially set to a value less
   than -1, all such errors will be printed (--verbose does this).  */

int overflow_cutoff_limit = 10;

d1368 8
a1375 7
reloc_overflow (struct bfd_link_info *info ATTRIBUTE_UNUSED,
		const char *name,
		const char *reloc_name,
		bfd_vma addend,
		bfd *abfd,
		asection *section,
		bfd_vma address)
d1377 1
a1377 4
  if (overflow_cutoff_limit == -1)
    return TRUE;

  if (abfd == NULL)
a1380 8

  if (overflow_cutoff_limit >= 0
      && overflow_cutoff_limit-- == 0)
    {
      einfo (_(" additional relocation overflows omitted from the output\n"));
      return TRUE;
    }

d1391 6
a1396 5
reloc_dangerous (struct bfd_link_info *info ATTRIBUTE_UNUSED,
		 const char *message,
		 bfd *abfd,
		 asection *section,
		 bfd_vma address)
d1398 1
a1398 1
  if (abfd == NULL)
d1410 6
a1415 5
unattached_reloc (struct bfd_link_info *info ATTRIBUTE_UNUSED,
		  const char *name,
		  bfd *abfd,
		  asection *section,
		  bfd_vma address)
d1417 1
a1417 1
  if (abfd == NULL)
d1430 6
a1435 5
notice (struct bfd_link_info *info,
	const char *name,
	bfd *abfd,
	asection *section,
	bfd_vma value)
@


