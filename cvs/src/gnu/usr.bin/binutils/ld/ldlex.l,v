head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.48
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.44
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.46
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.38
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.42
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.40
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.36
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.34
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.32
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.30
	OPENBSD_5_0:1.9.0.28
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.26
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.24
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.20
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.22
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.18
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.16
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.14
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.12
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	BINUTILS_2_15:1.1.1.10
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	BINUTILS-2_14:1.1.1.9
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	binutils-2_11_2:1.1.1.8
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	BINUTILS-2_10_1:1.1.1.7
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2004.11.02.20.45.48;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.17.21.54.50;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.13.17.07.42;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.09.22.29.40;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.12.45;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.52.31;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.09.29;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.54.24;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.16;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.16;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.35.34;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.35.03;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.38.39;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.28.33;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.48.09;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2001.06.09.22.08.52;	author espie;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2002.05.13.14.01.15;	author fgsch;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.05.17.20.42.49;	author drahn;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.11.02.20.23.22;	author miod;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@%{

/* Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003  Free Software Foundation, Inc.

This file is part of GLD, the Gnu Linker.

GLD is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GLD is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GLD; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */

/*
This was written by steve chamberlain
                    sac@@cygnus.com
*/


#include <stdio.h>

#ifdef MPW
/* Prevent enum redefinition problems. */
#define TRUE_FALSE_ALREADY_DEFINED
#endif /* MPW */

#include "bfd.h"
#include "sysdep.h"
#include "safe-ctype.h"
#include "bfdlink.h"
#include "ld.h"
#include "ldmisc.h"
#include "ldexp.h"
#include "ldlang.h"
#include <ldgram.h>
#include "ldfile.h"
#include "ldlex.h"
#include "ldmain.h"
#include "libiberty.h"

/* The type of top-level parser input.
   yylex and yyparse (indirectly) both check this.  */
input_type parser_input;

/* Line number in the current input file.
   (FIXME Actually, it doesn't appear to get reset for each file?)  */
unsigned int lineno = 1;

/* The string we are currently lexing, or NULL if we are reading a
   file.  */
const char *lex_string = NULL;

/* Support for flex reading from more than one input file (stream).
   `include_stack' is flex's input state for each open file;
   `file_name_stack' is the file names.  `lineno_stack' is the current
   line numbers.

   If `include_stack_ptr' is 0, we haven't started reading anything yet.
   Otherwise, stack elements 0 through `include_stack_ptr - 1' are valid.  */

#undef YY_INPUT
#define YY_INPUT(buf,result,max_size) yy_input (buf, &result, max_size)

#define MAX_INCLUDE_DEPTH 10
static YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
static const char *file_name_stack[MAX_INCLUDE_DEPTH];
static unsigned int lineno_stack[MAX_INCLUDE_DEPTH];
static unsigned int include_stack_ptr = 0;
static int vers_node_nesting = 0;

static void yy_input (char *, int *, int);
static void comment (void);
static void lex_warn_invalid (char *where, char *what);

/* STATES
	EXPRESSION	definitely in an expression
	SCRIPT		definitely in a script
	BOTH		either EXPRESSION or SCRIPT
	DEFSYMEXP	in an argument to -defsym
        MRI             in an MRI script
	VERS_START	starting a Sun style mapfile
	VERS_SCRIPT	a Sun style mapfile
	VERS_NODE	a node within a Sun style mapfile
*/
#define RTOKEN(x)  {  yylval.token = x; return x; }

/* Some versions of flex want this.  */
#ifndef yywrap
int yywrap (void) { return 1; }
#endif
%}

%a 4000
%o 5000

CMDFILENAMECHAR   [_a-zA-Z0-9\/\.\\_\+\$\:\[\]\\\,\=\&\!\<\>\-\~]
CMDFILENAMECHAR1  [_a-zA-Z0-9\/\.\\_\+\$\:\[\]\\\,\=\&\!\<\>\~]
FILENAMECHAR1	[_a-zA-Z\/\.\\\$\_\~]
SYMBOLCHARN     [_a-zA-Z\/\.\\\$\_\~0-9]
FILENAMECHAR	[_a-zA-Z0-9\/\.\-\_\+\=\$\:\[\]\\\,\~]
WILDCHAR	[_a-zA-Z0-9\/\.\-\_\+\=\$\:\[\]\\\,\~\?\*]
WHITE		[ \t\n\r]+

NOCFILENAMECHAR	[_a-zA-Z0-9\/\.\-\_\+\$\:\[\]\\\~]

V_TAG [.$_a-zA-Z][._a-zA-Z0-9]*
V_IDENTIFIER [*?.$_a-zA-Z\[\]\-\!\^\\]([*?.$_a-zA-Z0-9\[\]\-\!\^\\]|::)*

%s SCRIPT
%s EXPRESSION
%s BOTH
%s DEFSYMEXP
%s MRI
%s VERS_START
%s VERS_SCRIPT
%s VERS_NODE
%%

  if (parser_input != input_selected)
    {
      /* The first token of the input determines the initial parser state.  */
      input_type t = parser_input;
      parser_input = input_selected;
      switch (t)
	{
	case input_script: return INPUT_SCRIPT; break;
	case input_mri_script: return INPUT_MRI_SCRIPT; break;
	case input_version_script: return INPUT_VERSION_SCRIPT; break;
	case input_defsym: return INPUT_DEFSYM; break;
	default: abort ();
	}
    }

<BOTH,SCRIPT,EXPRESSION,VERS_START,VERS_NODE,VERS_SCRIPT>"/*"	{ comment (); }


<DEFSYMEXP>"-"                  { RTOKEN('-');}
<DEFSYMEXP>"+"                  { RTOKEN('+');}
<DEFSYMEXP>{FILENAMECHAR1}{SYMBOLCHARN}*   { yylval.name = xstrdup (yytext); return NAME; }
<DEFSYMEXP>"="                  { RTOKEN('='); }

<MRI,EXPRESSION>"$"([0-9A-Fa-f])+ {
  				yylval.integer = bfd_scan_vma (yytext + 1, 0, 16);
				yylval.bigint.str = NULL;
				return INT;
			}

<MRI,EXPRESSION>([0-9A-Fa-f])+(H|h|X|x|B|b|O|o|D|d) {
				   int ibase ;
				   switch (yytext[yyleng - 1]) {
				    case 'X':
				    case 'x':
				    case 'H':
				    case 'h':
				     ibase = 16;
				     break;
				    case 'O':
				    case 'o':
				     ibase = 8;
				     break;
				    case 'B':
				    case 'b':
				     ibase = 2;
				     break;
				    default:
				     ibase = 10;
				   }
				   yylval.integer = bfd_scan_vma (yytext, 0,
								  ibase);
				   yylval.bigint.str = NULL;
				   return INT;
				 }
<SCRIPT,DEFSYMEXP,MRI,BOTH,EXPRESSION>((("$"|0[xX])([0-9A-Fa-f])+)|(([0-9])+))(M|K|m|k)? {
				  char *s = yytext;
				  int ibase = 0;

				  if (*s == '$')
				    {
				      ++s;
				      ibase = 16;
				    }
				  yylval.integer = bfd_scan_vma (s, 0, ibase);
				  yylval.bigint.str = NULL;
				  if (yytext[yyleng - 1] == 'M'
				      || yytext[yyleng - 1] == 'm')
				    {
				      yylval.integer *= 1024 * 1024;
				    }
				  else if (yytext[yyleng - 1] == 'K'
				      || yytext[yyleng - 1]=='k')
				    {
				      yylval.integer *= 1024;
				    }
				  else if (yytext[0] == '0'
					   && (yytext[1] == 'x'
					       || yytext[1] == 'X'))
				    {
				      yylval.bigint.str = xstrdup (yytext + 2);
				    }
				  return INT;
				}
<BOTH,SCRIPT,EXPRESSION,MRI>"]"		{ RTOKEN(']');}
<BOTH,SCRIPT,EXPRESSION,MRI>"["		{ RTOKEN('[');}
<BOTH,SCRIPT,EXPRESSION,MRI>"<<="	{ RTOKEN(LSHIFTEQ);}
<BOTH,SCRIPT,EXPRESSION,MRI>">>="	{ RTOKEN(RSHIFTEQ);}
<BOTH,SCRIPT,EXPRESSION,MRI>"||"	{ RTOKEN(OROR);}
<BOTH,SCRIPT,EXPRESSION,MRI>"=="	{ RTOKEN(EQ);}
<BOTH,SCRIPT,EXPRESSION,MRI>"!="	{ RTOKEN(NE);}
<BOTH,SCRIPT,EXPRESSION,MRI>">="	{ RTOKEN(GE);}
<BOTH,SCRIPT,EXPRESSION,MRI>"<="	{ RTOKEN(LE);}
<BOTH,SCRIPT,EXPRESSION,MRI>"<<"	{ RTOKEN(LSHIFT);}
<BOTH,SCRIPT,EXPRESSION,MRI>">>"	{ RTOKEN(RSHIFT);}
<BOTH,SCRIPT,EXPRESSION,MRI>"+="	{ RTOKEN(PLUSEQ);}
<BOTH,SCRIPT,EXPRESSION,MRI>"-="	{ RTOKEN(MINUSEQ);}
<BOTH,SCRIPT,EXPRESSION,MRI>"*="	{ RTOKEN(MULTEQ);}
<BOTH,SCRIPT,EXPRESSION,MRI>"/="	{ RTOKEN(DIVEQ);}
<BOTH,SCRIPT,EXPRESSION,MRI>"&="	{ RTOKEN(ANDEQ);}
<BOTH,SCRIPT,EXPRESSION,MRI>"|="	{ RTOKEN(OREQ);}
<BOTH,SCRIPT,EXPRESSION,MRI>"&&"	{ RTOKEN(ANDAND);}
<BOTH,SCRIPT,EXPRESSION,MRI>">"		{ RTOKEN('>');}
<BOTH,SCRIPT,EXPRESSION,MRI>","		{ RTOKEN(',');}
<BOTH,SCRIPT,EXPRESSION,MRI>"&"		{ RTOKEN('&');}
<BOTH,SCRIPT,EXPRESSION,MRI>"|"		{ RTOKEN('|');}
<BOTH,SCRIPT,EXPRESSION,MRI>"~"		{ RTOKEN('~');}
<BOTH,SCRIPT,EXPRESSION,MRI>"!"		{ RTOKEN('!');}
<BOTH,SCRIPT,EXPRESSION,MRI>"?"		{ RTOKEN('?');}
<BOTH,SCRIPT,EXPRESSION,MRI>"*"		{ RTOKEN('*');}
<BOTH,SCRIPT,EXPRESSION,MRI>"+"		{ RTOKEN('+');}
<BOTH,SCRIPT,EXPRESSION,MRI>"-"		{ RTOKEN('-');}
<BOTH,SCRIPT,EXPRESSION,MRI>"/"		{ RTOKEN('/');}
<BOTH,SCRIPT,EXPRESSION,MRI>"%"		{ RTOKEN('%');}
<BOTH,SCRIPT,EXPRESSION,MRI>"<"		{ RTOKEN('<');}
<BOTH,SCRIPT,EXPRESSION,MRI>"="          { RTOKEN('=');}
<BOTH,SCRIPT,EXPRESSION,MRI>"}"			{ RTOKEN('}') ; }
<BOTH,SCRIPT,EXPRESSION,MRI>"{"			{ RTOKEN('{'); }
<BOTH,SCRIPT,EXPRESSION,MRI>")"			{ RTOKEN(')');}
<BOTH,SCRIPT,EXPRESSION,MRI>"("			{ RTOKEN('(');}
<BOTH,SCRIPT,EXPRESSION,MRI>":"		{ RTOKEN(':'); }
<BOTH,SCRIPT,EXPRESSION,MRI>";"		{ RTOKEN(';');}
<BOTH,SCRIPT>"MEMORY"		{ RTOKEN(MEMORY);}
<BOTH,SCRIPT>"ORIGIN"		{ RTOKEN(ORIGIN);}
<BOTH,SCRIPT>"VERSION"		{ RTOKEN(VERSIONK);}
<EXPRESSION,BOTH,SCRIPT>"BLOCK"		{ RTOKEN(BLOCK);}
<EXPRESSION,BOTH,SCRIPT>"BIND"		{ RTOKEN(BIND);}
<BOTH,SCRIPT>"LENGTH"		{ RTOKEN(LENGTH);}
<EXPRESSION,BOTH,SCRIPT>"ALIGN"			{ RTOKEN(ALIGN_K);}
<EXPRESSION,BOTH,SCRIPT>"DATA_SEGMENT_ALIGN"	{ RTOKEN(DATA_SEGMENT_ALIGN);}
<EXPRESSION,BOTH,SCRIPT>"DATA_SEGMENT_END"	{ RTOKEN(DATA_SEGMENT_END);}
<EXPRESSION,BOTH,SCRIPT>"ADDR"			{ RTOKEN(ADDR);}
<EXPRESSION,BOTH,SCRIPT>"LOADADDR"		{ RTOKEN(LOADADDR);}
<EXPRESSION,BOTH>"MAX"			{ RTOKEN(MAX_K); }
<EXPRESSION,BOTH>"MIN"			{ RTOKEN(MIN_K); }
<EXPRESSION,BOTH>"ASSERT"		{ RTOKEN(ASSERT_K); }
<BOTH,SCRIPT>"ENTRY"			{ RTOKEN(ENTRY);}
<BOTH,SCRIPT,MRI>"EXTERN"		{ RTOKEN(EXTERN);}
<EXPRESSION,BOTH,SCRIPT>"NEXT"			{ RTOKEN(NEXT);}
<EXPRESSION,BOTH,SCRIPT>"sizeof_headers"	{ RTOKEN(SIZEOF_HEADERS);}
<EXPRESSION,BOTH,SCRIPT>"SIZEOF_HEADERS"	{ RTOKEN(SIZEOF_HEADERS);}
<BOTH,SCRIPT>"MAP"			{ RTOKEN(MAP);}
<EXPRESSION,BOTH,SCRIPT>"SIZEOF"		{ RTOKEN(SIZEOF);}
<BOTH,SCRIPT>"TARGET"		{ RTOKEN(TARGET_K);}
<BOTH,SCRIPT>"SEARCH_DIR"		{ RTOKEN(SEARCH_DIR);}
<BOTH,SCRIPT>"OUTPUT"		{ RTOKEN(OUTPUT);}
<BOTH,SCRIPT>"INPUT"			{ RTOKEN(INPUT);}
<EXPRESSION,BOTH,SCRIPT>"GROUP"		{ RTOKEN(GROUP);}
<EXPRESSION,BOTH,SCRIPT>"DEFINED"		{ RTOKEN(DEFINED);}
<BOTH,SCRIPT>"CREATE_OBJECT_SYMBOLS"	{ RTOKEN(CREATE_OBJECT_SYMBOLS);}
<BOTH,SCRIPT>"CONSTRUCTORS"		{ RTOKEN( CONSTRUCTORS);}
<BOTH,SCRIPT>"FORCE_COMMON_ALLOCATION" { RTOKEN(FORCE_COMMON_ALLOCATION);}
<BOTH,SCRIPT>"INHIBIT_COMMON_ALLOCATION" { RTOKEN(INHIBIT_COMMON_ALLOCATION);}
<BOTH,SCRIPT>"SECTIONS"		{ RTOKEN(SECTIONS);}
<BOTH,SCRIPT>"FILL"			{ RTOKEN(FILL);}
<BOTH,SCRIPT>"STARTUP"		{ RTOKEN(STARTUP);}
<BOTH,SCRIPT>"OUTPUT_FORMAT"		{ RTOKEN(OUTPUT_FORMAT);}
<BOTH,SCRIPT>"OUTPUT_ARCH"		{ RTOKEN( OUTPUT_ARCH);}
<BOTH,SCRIPT>"HLL"			{ RTOKEN(HLL);}
<BOTH,SCRIPT>"SYSLIB"		{ RTOKEN(SYSLIB);}
<BOTH,SCRIPT>"FLOAT"			{ RTOKEN(FLOAT);}
<BOTH,SCRIPT>"QUAD"			{ RTOKEN( QUAD);}
<BOTH,SCRIPT>"SQUAD"			{ RTOKEN( SQUAD);}
<BOTH,SCRIPT>"LONG"			{ RTOKEN( LONG);}
<BOTH,SCRIPT>"SHORT"			{ RTOKEN( SHORT);}
<BOTH,SCRIPT>"BYTE"			{ RTOKEN( BYTE);}
<BOTH,SCRIPT>"NOFLOAT"		{ RTOKEN(NOFLOAT);}
<EXPRESSION,BOTH,SCRIPT>"NOCROSSREFS"	{ RTOKEN(NOCROSSREFS);}
<BOTH,SCRIPT>"OVERLAY"			{ RTOKEN(OVERLAY); }
<BOTH,SCRIPT>"SORT"			{ RTOKEN(SORT); }
<EXPRESSION,BOTH,SCRIPT>"NOLOAD"	{ RTOKEN(NOLOAD);}
<EXPRESSION,BOTH,SCRIPT>"DSECT"		{ RTOKEN(DSECT);}
<EXPRESSION,BOTH,SCRIPT>"COPY"		{ RTOKEN(COPY);}
<EXPRESSION,BOTH,SCRIPT>"INFO"		{ RTOKEN(INFO);}
<EXPRESSION,BOTH,SCRIPT>"OVERLAY"	{ RTOKEN(OVERLAY);}
<BOTH,SCRIPT>"o"			{ RTOKEN(ORIGIN);}
<BOTH,SCRIPT>"org"			{ RTOKEN(ORIGIN);}
<BOTH,SCRIPT>"l"			{ RTOKEN( LENGTH);}
<BOTH,SCRIPT>"len"			{ RTOKEN( LENGTH);}
<BOTH,SCRIPT>"INCLUDE"			{ RTOKEN(INCLUDE);}
<BOTH,SCRIPT>"PHDRS"			{ RTOKEN (PHDRS); }
<EXPRESSION,BOTH,SCRIPT>"AT"			{ RTOKEN(AT);}
<EXPRESSION,BOTH,SCRIPT>"SUBALIGN"		{ RTOKEN(SUBALIGN);}
<EXPRESSION,BOTH,SCRIPT>"PROVIDE"		{ RTOKEN(PROVIDE); }
<EXPRESSION,BOTH,SCRIPT>"KEEP"		{ RTOKEN(KEEP); }
<EXPRESSION,BOTH,SCRIPT>"EXCLUDE_FILE"        { RTOKEN(EXCLUDE_FILE); }
<MRI>"#".*\n?			{ ++ lineno; }
<MRI>"\n"	                { ++ lineno;  RTOKEN(NEWLINE); }
<MRI>"*".*			{ /* Mri comment line */ }
<MRI>";".*			{ /* Mri comment line */ }
<MRI>"END"                      { RTOKEN(ENDWORD); }
<MRI>"ALIGNMOD"		{ RTOKEN(ALIGNMOD);}
<MRI>"ALIGN"		{ RTOKEN(ALIGN_K);}
<MRI>"CHIP"                     { RTOKEN(CHIP); }
<MRI>"BASE"                     { RTOKEN(BASE); }
<MRI>"ALIAS"                     { RTOKEN(ALIAS); }
<MRI>"TRUNCATE"                     { RTOKEN(TRUNCATE); }
<MRI>"LOAD"                     { RTOKEN(LOAD); }
<MRI>"PUBLIC"                   { RTOKEN(PUBLIC); }
<MRI>"ORDER"                    { RTOKEN(ORDER); }
<MRI>"NAME"                     { RTOKEN(NAMEWORD); }
<MRI>"FORMAT"                   { RTOKEN(FORMAT); }
<MRI>"CASE"                     { RTOKEN(CASE); }
<MRI>"START"                    { RTOKEN(START); }
<MRI>"LIST".*                   { RTOKEN(LIST); /* LIST and ignore to end of line */ }
<MRI>"SECT"			{ RTOKEN(SECT); }
<EXPRESSION,BOTH,SCRIPT,MRI>"ABSOLUTE"			{ RTOKEN(ABSOLUTE); }
<MRI>"end"                      { RTOKEN(ENDWORD); }
<MRI>"alignmod"		{ RTOKEN(ALIGNMOD);}
<MRI>"align"		{ RTOKEN(ALIGN_K);}
<MRI>"chip"                     { RTOKEN(CHIP); }
<MRI>"base"                     { RTOKEN(BASE); }
<MRI>"alias"                     { RTOKEN(ALIAS); }
<MRI>"truncate"                     { RTOKEN(TRUNCATE); }
<MRI>"load"                     { RTOKEN(LOAD); }
<MRI>"public"                   { RTOKEN(PUBLIC); }
<MRI>"order"                    { RTOKEN(ORDER); }
<MRI>"name"                     { RTOKEN(NAMEWORD); }
<MRI>"format"                   { RTOKEN(FORMAT); }
<MRI>"case"                     { RTOKEN(CASE); }
<MRI>"extern"                   { RTOKEN(EXTERN); }
<MRI>"start"                    { RTOKEN(START); }
<MRI>"list".*                   { RTOKEN(LIST); /* LIST and ignore to end of line */ }
<MRI>"sect"			{ RTOKEN(SECT); }
<EXPRESSION,BOTH,SCRIPT,MRI>"absolute"			{ RTOKEN(ABSOLUTE); }

<MRI>{FILENAMECHAR1}{NOCFILENAMECHAR}*	{
/* Filename without commas, needed to parse mri stuff */
				 yylval.name = xstrdup (yytext);
				  return NAME;
				}


<BOTH,EXPRESSION>{FILENAMECHAR1}{FILENAMECHAR}*	{
				 yylval.name = xstrdup (yytext);
				  return NAME;
				}
<BOTH,EXPRESSION>"-l"{FILENAMECHAR}+ {
				  yylval.name = xstrdup (yytext + 2);
				  return LNAME;
				}
<SCRIPT>{WILDCHAR}* {
		/* Annoyingly, this pattern can match comments, and we have
		   longest match issues to consider.  So if the first two
		   characters are a comment opening, put the input back and
		   try again.  */
		if (yytext[0] == '/' && yytext[1] == '*')
		  {
		    yyless (2);
		    comment ();
		  }
		else
		  {
		    yylval.name = xstrdup (yytext);
		    return NAME;
		  }
	}

<EXPRESSION,BOTH,SCRIPT,VERS_NODE>"\""[^\"]*"\"" {
					/* No matter the state, quotes
					   give what's inside */
					yylval.name = xstrdup (yytext + 1);
					yylval.name[yyleng - 2] = 0;
					return NAME;
				}
<BOTH,SCRIPT,EXPRESSION>"\n"		{ lineno++;}
<MRI,BOTH,SCRIPT,EXPRESSION>[ \t\r]+	{ }

<VERS_NODE,VERS_SCRIPT>[:,;]	{ return *yytext; }

<VERS_NODE>global		{ RTOKEN(GLOBAL); }

<VERS_NODE>local		{ RTOKEN(LOCAL); }

<VERS_NODE>extern		{ RTOKEN(EXTERN); }

<VERS_NODE>{V_IDENTIFIER}	{ yylval.name = xstrdup (yytext);
				  return VERS_IDENTIFIER; }

<VERS_SCRIPT>{V_TAG}		{ yylval.name = xstrdup (yytext);
				  return VERS_TAG; }

<VERS_START>"{"			{ BEGIN(VERS_SCRIPT); return *yytext; }

<VERS_SCRIPT>"{"		{ BEGIN(VERS_NODE);
				  vers_node_nesting = 0;
				  return *yytext;
				}
<VERS_SCRIPT>"}"		{ return *yytext; }
<VERS_NODE>"{"			{ vers_node_nesting++; return *yytext; }
<VERS_NODE>"}"			{ if (--vers_node_nesting < 0)
				    BEGIN(VERS_SCRIPT);
				  return *yytext;
				}

<VERS_START,VERS_NODE,VERS_SCRIPT>[\n]		{ lineno++; }

<VERS_START,VERS_NODE,VERS_SCRIPT>#.*		{ /* Eat up comments */ }

<VERS_START,VERS_NODE,VERS_SCRIPT>[ \t\r]+   	{ /* Eat up whitespace */ }

<<EOF>> {
  include_stack_ptr--;

  if (include_stack_ptr == 0)
  {
    yyterminate ();
  }
  else
  {
    yy_switch_to_buffer (include_stack[include_stack_ptr]);
  }

  ldfile_input_filename = file_name_stack[include_stack_ptr - 1];
  lineno = lineno_stack[include_stack_ptr];

  return END;
}

<SCRIPT,MRI,VERS_START,VERS_SCRIPT,VERS_NODE>.	lex_warn_invalid (" in script", yytext);
<EXPRESSION,DEFSYMEXP,BOTH>.	lex_warn_invalid (" in expression", yytext);

%%


/* Switch flex to reading script file NAME, open on FILE,
   saving the current input info on the include stack.  */

void
lex_push_file (FILE *file, const char *name)
{
  if (include_stack_ptr >= MAX_INCLUDE_DEPTH)
    {
      einfo ("%F:includes nested too deeply\n");
    }
  file_name_stack[include_stack_ptr] = name;
  lineno_stack[include_stack_ptr] = lineno;
  include_stack[include_stack_ptr] = YY_CURRENT_BUFFER;

  include_stack_ptr++;
  lineno = 1;
  yyin = file;
  yy_switch_to_buffer (yy_create_buffer (yyin, YY_BUF_SIZE));
}

/* Return a newly created flex input buffer containing STRING,
   which is SIZE bytes long.  */

static YY_BUFFER_STATE
yy_create_string_buffer (const char *string, size_t size)
{
  YY_BUFFER_STATE b;

  /* Calls to m-alloc get turned by sed into xm-alloc.  */
  b = malloc (sizeof (struct yy_buffer_state));
  b->yy_input_file = 0;
  b->yy_buf_size = size;

  /* yy_ch_buf has to be 2 characters longer than the size given because
     we need to put in 2 end-of-buffer characters.  */
  b->yy_ch_buf = malloc ((unsigned) (b->yy_buf_size + 3));

  b->yy_ch_buf[0] = '\n';
  strcpy (b->yy_ch_buf+1, string);
  b->yy_ch_buf[size+1] = YY_END_OF_BUFFER_CHAR;
  b->yy_ch_buf[size+2] = YY_END_OF_BUFFER_CHAR;
  b->yy_n_chars = size+1;
  b->yy_buf_pos = &b->yy_ch_buf[1];

  b->yy_is_our_buffer = 1;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;

  /* flex 2.4.7 changed the interface.  FIXME: We should not be using
     a flex internal interface in the first place!  */
#ifdef YY_BUFFER_NEW
  b->yy_buffer_status = YY_BUFFER_NEW;
#else
  b->yy_eof_status = EOF_NOT_SEEN;
#endif

  return b;
}

/* Switch flex to reading from STRING, saving the current input info
   on the include stack.  */

void
lex_redirect (const char *string)
{
  YY_BUFFER_STATE tmp;

  yy_init = 0;
  if (include_stack_ptr >= MAX_INCLUDE_DEPTH)
    {
      einfo("%F: macros nested too deeply\n");
    }
  file_name_stack[include_stack_ptr] = "redirect";
  lineno_stack[include_stack_ptr] = lineno;
  include_stack[include_stack_ptr] = YY_CURRENT_BUFFER;
  include_stack_ptr++;
  lineno = 1;
  tmp = yy_create_string_buffer (string, strlen (string));
  yy_switch_to_buffer (tmp);
}

/* Functions to switch to a different flex start condition,
   saving the current start condition on `state_stack'.  */

static int state_stack[MAX_INCLUDE_DEPTH * 2];
static int *state_stack_p = state_stack;

void
ldlex_script (void)
{
  *(state_stack_p)++ = yy_start;
  BEGIN (SCRIPT);
}

void
ldlex_mri_script (void)
{
  *(state_stack_p)++ = yy_start;
  BEGIN (MRI);
}

void
ldlex_version_script (void)
{
  *(state_stack_p)++ = yy_start;
  BEGIN (VERS_START);
}

void
ldlex_version_file (void)
{
  *(state_stack_p)++ = yy_start;
  BEGIN (VERS_SCRIPT);
}

void
ldlex_defsym (void)
{
  *(state_stack_p)++ = yy_start;
  BEGIN (DEFSYMEXP);
}

void
ldlex_expression (void)
{
  *(state_stack_p)++ = yy_start;
  BEGIN (EXPRESSION);
}

void
ldlex_both (void)
{
  *(state_stack_p)++ = yy_start;
  BEGIN (BOTH);
}

void
ldlex_popstate (void)
{
  yy_start = *(--state_stack_p);
}


/* Place up to MAX_SIZE characters in BUF and return in *RESULT
   either the number of characters read, or 0 to indicate EOF.  */

static void
yy_input (char *buf, int *result, int max_size)
{
  *result = 0;
  if (YY_CURRENT_BUFFER->yy_input_file)
    {
      if (yyin)
	{
	  *result = fread (buf, 1, max_size, yyin);
	  if (*result < max_size && ferror (yyin))
	    einfo ("%F%P: read in flex scanner failed\n");
	}
    }
}

/* Eat the rest of a C-style comment.  */

static void
comment (void)
{
  int c;

  while (1)
  {
    c = input();
    while (c != '*' && c != EOF)
    {
      if (c == '\n')
	lineno++;
      c = input();
    }

    if (c == '*')
    {
      c = input();
      while (c == '*')
       c = input();
      if (c == '/')
       break;			/* found the end */
    }

    if (c == '\n')
      lineno++;

    if (c == EOF)
    {
      einfo( "%F%P: EOF in comment\n");
      break;
    }
  }
}

/* Warn the user about a garbage character WHAT in the input
   in context WHERE.  */

static void
lex_warn_invalid (char *where, char *what)
{
  char buf[5];

  /* If we have found an input file whose format we do not recognize,
     and we are therefore treating it as a linker script, and we find
     an invalid character, then most likely this is a real object file
     of some different format.  Treat it as such.  */
  if (ldfile_assumed_script)
    {
      bfd_set_error (bfd_error_file_not_recognized);
      einfo ("%F%s: file not recognized: %E\n", ldfile_input_filename);
    }

  if (! ISPRINT (*what))
    {
      sprintf (buf, "\\%03o", (unsigned int) *what);
      what = buf;
    }

  einfo ("%P:%S: ignoring invalid character `%s'%s\n", what, where);
}
@


1.8
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d4 1
a4 1
   2000, 2001, 2002  Free Software Foundation, Inc.
a28 1
#include "ansidecl.h"
d71 1
a71 1
#define YY_INPUT(buf,result,max_size) yy_input(buf, &result, max_size)
d80 3
a82 3
static YY_BUFFER_STATE yy_create_string_buffer PARAMS ((const char *string,
							size_t size));
static void yy_input PARAMS ((char *, int *result, int max_size));
d84 1
a84 4
static void comment PARAMS ((void));
static void lex_warn_invalid PARAMS ((char *where, char *what));

/* STATES 
d98 1
a98 1
int yywrap () { return 1; }
d111 1
a111 1
WHITE		[ \t\n\r]+ 
d116 1
a116 1
V_IDENTIFIER [*?.$_a-zA-Z\[\]\-\!\^]([*?.$_a-zA-Z0-9\[\]\-\!\^]|::)*
d143 1
a143 1
<BOTH,SCRIPT,EXPRESSION,VERS_START,VERS_NODE,VERS_SCRIPT>"/*"	{ comment(); }
d148 1
a148 1
<DEFSYMEXP>{FILENAMECHAR1}{SYMBOLCHARN}*   { yylval.name = xstrdup(yytext); return NAME; }
d152 2
a153 2
  				yylval.integer = bfd_scan_vma (yytext+1, 0,16);
				yylval.bigint.str = (char *) 0;
d159 2
a160 2
				   switch (yytext[yyleng-1]) {
				    case 'X': 
d179 1
a179 1
				   yylval.bigint.str = (char *) 0;
d192 3
a194 3
				  yylval.bigint.str = (char *) 0;
				  if (yytext[yyleng-1] == 'M'
				      || yytext[yyleng-1] == 'm')
d198 2
a199 2
				  else if (yytext[yyleng-1] == 'K' 
				      || yytext[yyleng-1]=='k')
d309 1
d355 1
a355 1
				 yylval.name = xstrdup(yytext); 
d361 1
a361 1
				 yylval.name = xstrdup(yytext); 
d375 1
a375 1
		    yyless(2);
d380 1
a380 1
		    yylval.name = xstrdup(yytext);
d388 2
a389 2
					yylval.name = xstrdup(yytext+1);
					yylval.name[yyleng-2] = 0;
d411 1
a411 1
<VERS_SCRIPT>"{"		{ BEGIN(VERS_NODE); 
d430 2
a431 2
    
  if (include_stack_ptr == 0) 
d433 1
a433 1
    yyterminate();
d435 1
a435 1
  else 
d437 1
a437 1
    yy_switch_to_buffer(include_stack[include_stack_ptr]);
d446 3
a448 3
<SCRIPT,MRI,VERS_START,VERS_SCRIPT,VERS_NODE>.	lex_warn_invalid(" in script", yytext);
<EXPRESSION,DEFSYMEXP,BOTH>.	lex_warn_invalid(" in expression", yytext);
    
d456 1
a456 3
lex_push_file (file, name)
     FILE *file;
     const char *name;
d458 1
a458 1
  if (include_stack_ptr >= MAX_INCLUDE_DEPTH) 
d460 1
a460 1
      einfo("%F:includes nested too deeply\n");
d469 1
a469 1
  yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
d475 2
a476 4
static YY_BUFFER_STATE 
yy_create_string_buffer (string, size)
     const char *string;
     size_t size;
d481 1
a481 1
  b = (YY_BUFFER_STATE) malloc (sizeof (struct yy_buffer_state));
d487 1
a487 1
  b->yy_ch_buf = (char *) malloc ((unsigned) (b->yy_buf_size + 3));
d516 1
a516 2
lex_redirect (string)
     const char *string;
d521 1
a521 1
  if (include_stack_ptr >= MAX_INCLUDE_DEPTH) 
d541 1
a541 1
ldlex_script ()
d548 1
a548 1
ldlex_mri_script ()
d555 1
a555 1
ldlex_version_script ()
d562 1
a562 1
ldlex_version_file ()
d569 1
a569 1
ldlex_defsym ()
d574 1
a574 1
	   
d576 1
a576 1
ldlex_expression ()
d583 1
a583 1
ldlex_both ()
d590 1
a590 1
ldlex_popstate ()
d600 1
a600 4
yy_input (buf, result, max_size)
     char *buf;
     int *result;
     int max_size;
d602 1
a602 1
  *result = 0; 
d607 2
a608 2
	  *result = fread ((char *) buf, 1, max_size, yyin);
	  if (*result < max_size && ferror (yyin)) 
d617 1
a617 1
comment ()
d624 1
a624 1
    while (c != '*' && c != EOF) 
d655 1
a655 2
lex_warn_invalid (where, what)
     char *where, *what;
@


1.7
log
@resolve conflicts.
@
text
@d3 2
a4 2
/* Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.
d29 1
a29 1
#include <ansidecl.h>
a30 1
#include <ctype.h>
d39 2
a41 1
#include "ldgram.h"
d45 1
d120 1
a120 1
V_IDENTIFIER [*?.$_a-zA-Z]([*?.$_a-zA-Z0-9]|::)*
d147 1
a147 1
<BOTH,SCRIPT,EXPRESSION>"/*"	{ comment(); }
d157 1
d183 1
d186 1
a186 1
<SCRIPT,DEFSYMEXP,MRI,BOTH,EXPRESSION>((("$"|"0x")([0-9A-Fa-f])+)|(([0-9])+))(M|K|m|k)? {
d188 1
d191 6
a196 2
				    ++s;
				  yylval.integer = bfd_scan_vma (s, 0, 0);
d199 4
a202 2
				    yylval.integer *= 1024 * 1024;
				  if (yytext[yyleng-1] == 'K' 
d204 9
a212 1
				    yylval.integer *= 1024;
d260 2
d283 1
d441 1
a442 2
  }
  BEGIN(SCRIPT);
d444 1
a444 1
  lineno = lineno_stack[include_stack_ptr - 1];
d468 1
a468 1
  lineno_stack[include_stack_ptr] = 1;
d472 1
a474 1
  BEGIN (SCRIPT);
d482 1
a482 1
     CONST char *string;
d524 1
a524 1
     CONST char *string;
d534 1
a534 1
  lineno_stack[include_stack_ptr] = 0;
d537 1
a539 1
  BEGIN (SCRIPT);
d614 1
a614 1
  if (yy_current_buffer->yy_input_file)
d618 2
a619 2
	  *result = read (fileno (yyin), (char *) buf, max_size);
	  if (*result < 0) 
d681 1
a681 1
  if (! isprint ((unsigned char) *what))
@


1.6
log
@Automatic cvs merge. Dread what I will have to fix after this excuse
of a program is done...
@
text
@d3 1
a3 1
/* Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 1999
d48 1
d119 1
a119 1
V_IDENTIFIER [*?.$_a-zA-Z][*?.$_a-zA-Z0-9]*
d151 1
a151 1
<DEFSYMEXP>{FILENAMECHAR1}{SYMBOLCHARN}*   { yylval.name = buystring(yytext); return NAME; }
d337 1
a337 1
				 yylval.name = buystring(yytext); 
d343 1
a343 1
				 yylval.name = buystring(yytext); 
d347 1
a347 1
				  yylval.name = buystring (yytext + 2);
d362 1
a362 1
		    yylval.name = buystring(yytext);
d370 1
a370 1
					yylval.name = buystring(yytext+1);
d385 1
a385 1
<VERS_NODE>{V_IDENTIFIER}	{ yylval.name = buystring (yytext);
d388 1
a388 1
<VERS_SCRIPT>{V_TAG}		{ yylval.name = buystring (yytext);
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d482 5
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d3 2
a4 1
/* Copyright (C) 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d19 3
a21 2
along with GLD; see the file COPYING.  If not, write to
the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a52 3
/* Radix to use for bfd_scan_vma -- 0 (default to base 10) or 16.  */
int hex_mode;

d77 1
d92 3
d117 2
d125 3
d139 1
d182 12
a193 11
<SCRIPT,DEFSYMEXP,MRI,BOTH,EXPRESSION>"$"?"0x"?([0-9A-Fa-f])+(M|K|m|k)? {
				  yylval.integer = bfd_scan_vma (yytext, 0,
								 hex_mode);
				  if (yytext[yyleng-1]=='M'
					|| yytext[yyleng-1] == 'm') {
				      yylval.integer *= 1024*1024;
				    }	
				  if (yytext[yyleng-1]=='K' 
				|| yytext[yyleng-1]=='k') {
				      yylval.integer *= 1024;
				    }		
d236 1
d243 3
a245 2
<EXPRESSION,BOTH>"MAX"			{ RTOKEN(MAX); }
<EXPRESSION,BOTH>"MIN"			{ RTOKEN(MIN); }
d247 1
d271 1
d278 1
d292 3
a294 1
<MRI>"#".*\n?\r?		{ ++ lineno; }
a295 1
<MRI>"\r"	                { ++ lineno;  RTOKEN(NEWLINE); }
a310 1
<MRI>"EXTERN"                   { RTOKEN(EXTERN); }
d349 16
a364 1
<SCRIPT>{WILDCHAR}* { yylval.name = buystring(yytext); return NAME; }
d366 1
a366 1
<EXPRESSION,BOTH,SCRIPT>"\""[^\"]*"\"" {
d374 34
a407 2
<BOTH,SCRIPT,EXPRESSION>"\r"		{ lineno++;}
<MRI,BOTH,SCRIPT,EXPRESSION>[ \t]
d428 1
a428 1
<SCRIPT,MRI>.		lex_warn_invalid(" in script", yytext);
d537 14
d594 1
a594 1
	    einfo ("%F%P: read in flex scanner failed");
d611 1
a611 1
      if (c == '\n' || c == '\r')
d625 1
a625 1
    if (c == '\n' || c == '\r')
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d107 1
a107 1
SYMBOLCHARN     [_a-zA-Z\/\.\\0-9]
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d3 1
a3 1
/* Copyright (C) 1991, 1992, 1993, 1994 Free Software Foundation, Inc.
d109 1
a109 1
FILENAME	{FILENAMECHAR}+
d226 2
a227 1
<BOTH,SCRIPT>"BLOCK"			{ RTOKEN(BLOCK);}
d231 3
d244 1
a244 1
<BOTH,SCRIPT>"GROUP"			{ RTOKEN(GROUP);}
d262 7
a268 5
<EXPRESSION,BOTH,SCRIPT>"NOLOAD"		{ RTOKEN(NOLOAD);}
<BOTH,SCRIPT>"DSECT"			{ RTOKEN(DSECT);}
<BOTH,SCRIPT>"COPY"			{ RTOKEN(COPY);}
<BOTH,SCRIPT>"INFO"			{ RTOKEN(INFO);}
<BOTH,SCRIPT>"OVERLAY"		{ RTOKEN(OVERLAY);}
d334 1
a334 3
<SCRIPT>{FILENAMECHAR}* { yylval.name = buystring(yytext); 
				  return NAME;
				}
@


1.1
log
@Initial revision
@
text
@d268 1
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@a267 1
<BOTH,SCRIPT>"PHDRS"			{ RTOKEN (PHDRS); }
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d3 1
a3 1
/* Copyright (C) 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d109 1
a109 1
WILDCHAR	[_a-zA-Z0-9\/\.\-\_\+\=\$\:\[\]\\\,\~\?\*]
d226 1
a226 2
<EXPRESSION,BOTH,SCRIPT>"BLOCK"		{ RTOKEN(BLOCK);}
<EXPRESSION,BOTH,SCRIPT>"BIND"		{ RTOKEN(BIND);}
a229 3
<EXPRESSION,BOTH,SCRIPT>"LOADADDR"		{ RTOKEN(LOADADDR);}
<EXPRESSION,BOTH>"MAX"			{ RTOKEN(MAX); }
<EXPRESSION,BOTH>"MIN"			{ RTOKEN(MIN); }
d240 1
a240 1
<EXPRESSION,BOTH,SCRIPT>"GROUP"		{ RTOKEN(GROUP);}
d258 5
a262 7
<EXPRESSION,BOTH,SCRIPT>"NOCROSSREFS"	{ RTOKEN(NOCROSSREFS);}
<BOTH,SCRIPT>"OVERLAY"			{ RTOKEN(OVERLAY); }
<EXPRESSION,BOTH,SCRIPT>"NOLOAD"	{ RTOKEN(NOLOAD);}
<EXPRESSION,BOTH,SCRIPT>"DSECT"		{ RTOKEN(DSECT);}
<EXPRESSION,BOTH,SCRIPT>"COPY"		{ RTOKEN(COPY);}
<EXPRESSION,BOTH,SCRIPT>"INFO"		{ RTOKEN(INFO);}
<EXPRESSION,BOTH,SCRIPT>"OVERLAY"	{ RTOKEN(OVERLAY);}
d328 3
a330 1
<SCRIPT>{WILDCHAR}* { yylval.name = buystring(yytext); return NAME; }
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d107 1
a107 1
SYMBOLCHARN     [_a-zA-Z\/\.\\\$\_\~0-9]
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d3 1
a3 1
/* Copyright (C) 1991, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
a91 3
	VERS_START	starting a Sun style mapfile
	VERS_SCRIPT	a Sun style mapfile
	VERS_NODE	a node within a Sun style mapfile
a113 2
V_TAG [.$_a-zA-Z][._a-zA-Z0-9]*
V_IDENTIFIER [*?$_a-zA-Z][*?_a-zA-Z0-9]*
a119 3
%s VERS_START
%s VERS_SCRIPT
%s VERS_NODE
a130 1
	case input_version_script: return INPUT_VERSION_SCRIPT; break;
a225 1
<BOTH,SCRIPT>"VERSION"		{ RTOKEN(VERSION);}
a346 23
<VERS_NODE,VERS_SCRIPT>[:,;]	{ return *yytext; }

<VERS_NODE>global		{ RTOKEN(GLOBAL); }

<VERS_NODE>local		{ RTOKEN(LOCAL); }

<VERS_NODE>{V_IDENTIFIER}	{ yylval.name = buystring (yytext);
				  return VERS_IDENTIFIER; }

<VERS_SCRIPT>{V_TAG}		{ yylval.name = buystring (yytext);
				  return VERS_TAG; }

<VERS_START>"{"			{ BEGIN(VERS_SCRIPT); return *yytext; }

<VERS_SCRIPT>"{"		{ BEGIN(VERS_NODE); return *yytext; }
<VERS_SCRIPT,VERS_NODE>"}"	{ BEGIN(VERS_SCRIPT); return *yytext; }

<VERS_START,VERS_NODE,VERS_SCRIPT>[\n\r]	{ lineno++; }

<VERS_START,VERS_NODE,VERS_SCRIPT>#.*		{ /* Eat up comments */ }

<VERS_START,VERS_NODE,VERS_SCRIPT>[ \t]+   	{ /* Eat up whitespace */ }

d366 1
a366 1
<SCRIPT,MRI,VERS_START,VERS_SCRIPT,VERS_NODE>.	lex_warn_invalid(" in script", yytext);
a471 14
}

void
ldlex_version_script ()
{
  *(state_stack_p)++ = yy_start;
  BEGIN (VERS_START);
}

void
ldlex_version_file ()
{
  *(state_stack_p)++ = yy_start;
  BEGIN (VERS_SCRIPT);
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d3 1
a3 2
/* Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 1999
   Free Software Foundation, Inc.
d18 2
a19 3
along with GLD; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
d51 3
a77 1
static int vers_node_nesting = 0;
d118 1
a118 1
V_IDENTIFIER [*?.$_a-zA-Z][*?.$_a-zA-Z0-9]*
d182 11
a192 12
<SCRIPT,DEFSYMEXP,MRI,BOTH,EXPRESSION>((("$"|"0x")([0-9A-Fa-f])+)|(([0-9])+))(M|K|m|k)? {
				  char *s = yytext;

				  if (*s == '$')
				    ++s;
				  yylval.integer = bfd_scan_vma (s, 0, 0);
				  if (yytext[yyleng-1] == 'M'
				      || yytext[yyleng-1] == 'm')
				    yylval.integer *= 1024 * 1024;
				  if (yytext[yyleng-1] == 'K' 
				      || yytext[yyleng-1]=='k')
				    yylval.integer *= 1024;
d235 1
a235 1
<BOTH,SCRIPT>"VERSION"		{ RTOKEN(VERSIONK);}
d242 2
a243 3
<EXPRESSION,BOTH>"MAX"			{ RTOKEN(MAX_K); }
<EXPRESSION,BOTH>"MIN"			{ RTOKEN(MIN_K); }
<EXPRESSION,BOTH>"ASSERT"		{ RTOKEN(ASSERT_K); }
a244 1
<BOTH,SCRIPT,MRI>"EXTERN"		{ RTOKEN(EXTERN);}
a267 1
<BOTH,SCRIPT>"SQUAD"			{ RTOKEN( SQUAD);}
a273 1
<BOTH,SCRIPT>"SORT"			{ RTOKEN(SORT); }
d287 1
a287 3
<EXPRESSION,BOTH,SCRIPT>"KEEP"		{ RTOKEN(KEEP); }
<EXPRESSION,BOTH,SCRIPT>"EXCLUDE_FILE"        { RTOKEN(EXCLUDE_FILE); }
<MRI>"#".*\n?			{ ++ lineno; }
d289 1
d305 1
d344 1
a344 16
<SCRIPT>{WILDCHAR}* {
		/* Annoyingly, this pattern can match comments, and we have
		   longest match issues to consider.  So if the first two
		   characters are a comment opening, put the input back and
		   try again.  */
		if (yytext[0] == '/' && yytext[1] == '*')
		  {
		    yyless(2);
		    comment ();
		  }
		else
		  {
		    yylval.name = buystring(yytext);
		    return NAME;
		  }
	}
d346 1
a346 1
<EXPRESSION,BOTH,SCRIPT,VERS_NODE>"\""[^\"]*"\"" {
d354 2
a355 1
<MRI,BOTH,SCRIPT,EXPRESSION>[ \t\r]+	{ }
a362 2
<VERS_NODE>extern		{ RTOKEN(EXTERN); }

d371 2
a372 10
<VERS_SCRIPT>"{"		{ BEGIN(VERS_NODE); 
				  vers_node_nesting = 0;
				  return *yytext;
				}
<VERS_SCRIPT>"}"		{ return *yytext; }
<VERS_NODE>"{"			{ vers_node_nesting++; return *yytext; }
<VERS_NODE>"}"			{ if (--vers_node_nesting < 0)
				    BEGIN(VERS_SCRIPT);
				  return *yytext;
				}
d374 1
a374 1
<VERS_START,VERS_NODE,VERS_SCRIPT>[\n]		{ lineno++; }
d378 1
a378 1
<VERS_START,VERS_NODE,VERS_SCRIPT>[ \t\r]+   	{ /* Eat up whitespace */ }
d565 1
a565 1
	    einfo ("%F%P: read in flex scanner failed\n");
d582 1
a582 1
      if (c == '\n')
d596 1
a596 1
    if (c == '\n')
@


1.1.1.7
log
@Long delayed import of binutils-2.10.1. Turns out art@@ needs some alpha
bug-fixes...
@
text
@a481 5
  b->yy_is_our_buffer = 1;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;

@


1.1.1.8
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d3 1
a3 1
/* Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
a47 1
#include "libiberty.h"
d118 1
a118 1
V_IDENTIFIER [*?.$_a-zA-Z]([*?.$_a-zA-Z0-9]|::)*
d150 1
a150 1
<DEFSYMEXP>{FILENAMECHAR1}{SYMBOLCHARN}*   { yylval.name = xstrdup(yytext); return NAME; }
d336 1
a336 1
				 yylval.name = xstrdup(yytext); 
d342 1
a342 1
				 yylval.name = xstrdup(yytext); 
d346 1
a346 1
				  yylval.name = xstrdup (yytext + 2);
d361 1
a361 1
		    yylval.name = xstrdup(yytext);
d369 1
a369 1
					yylval.name = xstrdup(yytext+1);
d384 1
a384 1
<VERS_NODE>{V_IDENTIFIER}	{ yylval.name = xstrdup (yytext);
d387 1
a387 1
<VERS_SCRIPT>{V_TAG}		{ yylval.name = xstrdup (yytext);
@


1.1.1.9
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 2
a4 2
/* Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002  Free Software Foundation, Inc.
d29 1
a29 1
#include "ansidecl.h"
d31 1
a39 2
#include "safe-ctype.h"
#include "bfdlink.h"
d41 1
a44 1
#include <ldgram.h>
d119 1
a119 1
V_IDENTIFIER [*?.$_a-zA-Z\[\]\-\!\^]([*?.$_a-zA-Z0-9\[\]\-\!\^]|::)*
d146 1
a146 1
<BOTH,SCRIPT,EXPRESSION,VERS_START,VERS_NODE,VERS_SCRIPT>"/*"	{ comment(); }
a155 1
				yylval.bigint.str = (char *) 0;
a180 1
				   yylval.bigint.str = (char *) 0;
d183 1
a183 1
<SCRIPT,DEFSYMEXP,MRI,BOTH,EXPRESSION>((("$"|0[xX])([0-9A-Fa-f])+)|(([0-9])+))(M|K|m|k)? {
a184 1
				  int ibase = 0;
d187 2
a188 6
				    {
				      ++s;
				      ibase = 16;
				    }
				  yylval.integer = bfd_scan_vma (s, 0, ibase);
				  yylval.bigint.str = (char *) 0;
d191 2
a192 4
				    {
				      yylval.integer *= 1024 * 1024;
				    }
				  else if (yytext[yyleng-1] == 'K' 
d194 1
a194 9
				    {
				      yylval.integer *= 1024;
				    }
				  else if (yytext[0] == '0'
					   && (yytext[1] == 'x'
					       || yytext[1] == 'X'))
				    {
				      yylval.bigint.str = xstrdup (yytext + 2);
				    }
a241 2
<EXPRESSION,BOTH,SCRIPT>"DATA_SEGMENT_ALIGN"	{ RTOKEN(DATA_SEGMENT_ALIGN);}
<EXPRESSION,BOTH,SCRIPT>"DATA_SEGMENT_END"	{ RTOKEN(DATA_SEGMENT_END);}
a262 1
<BOTH,SCRIPT>"INHIBIT_COMMON_ALLOCATION" { RTOKEN(INHIBIT_COMMON_ALLOCATION);}
d420 1
d422 1
a422 1

d424 1
a424 1
  lineno = lineno_stack[include_stack_ptr];
d448 1
a448 1
  lineno_stack[include_stack_ptr] = lineno;
a451 1
  lineno = 1;
d454 1
d462 1
a462 1
     const char *string;
d504 1
a504 1
     const char *string;
d514 1
a514 1
  lineno_stack[include_stack_ptr] = lineno;
a516 1
  lineno = 1;
d519 1
d594 1
a594 1
  if (YY_CURRENT_BUFFER->yy_input_file)
d598 2
a599 2
	  *result = fread ((char *) buf, 1, max_size, yyin);
	  if (*result < max_size && ferror (yyin)) 
d661 1
a661 1
  if (! ISPRINT (*what))
@


1.1.1.10
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d4 1
a4 1
   2000, 2001, 2002, 2003  Free Software Foundation, Inc.
d29 1
d72 1
a72 1
#define YY_INPUT(buf,result,max_size) yy_input (buf, &result, max_size)
d81 3
a83 3
static void yy_input (char *, int *, int);
static void comment (void);
static void lex_warn_invalid (char *where, char *what);
d85 4
a88 1
/* STATES
d102 1
a102 1
int yywrap (void) { return 1; }
d115 1
a115 1
WHITE		[ \t\n\r]+
d120 1
a120 1
V_IDENTIFIER [*?.$_a-zA-Z\[\]\-\!\^\\]([*?.$_a-zA-Z0-9\[\]\-\!\^\\]|::)*
d147 1
a147 1
<BOTH,SCRIPT,EXPRESSION,VERS_START,VERS_NODE,VERS_SCRIPT>"/*"	{ comment (); }
d152 1
a152 1
<DEFSYMEXP>{FILENAMECHAR1}{SYMBOLCHARN}*   { yylval.name = xstrdup (yytext); return NAME; }
d156 2
a157 2
  				yylval.integer = bfd_scan_vma (yytext + 1, 0, 16);
				yylval.bigint.str = NULL;
d163 2
a164 2
				   switch (yytext[yyleng - 1]) {
				    case 'X':
d183 1
a183 1
				   yylval.bigint.str = NULL;
d196 3
a198 3
				  yylval.bigint.str = NULL;
				  if (yytext[yyleng - 1] == 'M'
				      || yytext[yyleng - 1] == 'm')
d202 2
a203 2
				  else if (yytext[yyleng - 1] == 'K'
				      || yytext[yyleng - 1]=='k')
a312 1
<EXPRESSION,BOTH,SCRIPT>"SUBALIGN"		{ RTOKEN(SUBALIGN);}
d358 1
a358 1
				 yylval.name = xstrdup (yytext);
d364 1
a364 1
				 yylval.name = xstrdup (yytext);
d378 1
a378 1
		    yyless (2);
d383 1
a383 1
		    yylval.name = xstrdup (yytext);
d391 2
a392 2
					yylval.name = xstrdup (yytext + 1);
					yylval.name[yyleng - 2] = 0;
d414 1
a414 1
<VERS_SCRIPT>"{"		{ BEGIN(VERS_NODE);
d433 2
a434 2

  if (include_stack_ptr == 0)
d436 1
a436 1
    yyterminate ();
d438 1
a438 1
  else
d440 1
a440 1
    yy_switch_to_buffer (include_stack[include_stack_ptr]);
d449 3
a451 3
<SCRIPT,MRI,VERS_START,VERS_SCRIPT,VERS_NODE>.	lex_warn_invalid (" in script", yytext);
<EXPRESSION,DEFSYMEXP,BOTH>.	lex_warn_invalid (" in expression", yytext);

d459 3
a461 1
lex_push_file (FILE *file, const char *name)
d463 1
a463 1
  if (include_stack_ptr >= MAX_INCLUDE_DEPTH)
d465 1
a465 1
      einfo ("%F:includes nested too deeply\n");
d474 1
a474 1
  yy_switch_to_buffer (yy_create_buffer (yyin, YY_BUF_SIZE));
d480 4
a483 2
static YY_BUFFER_STATE
yy_create_string_buffer (const char *string, size_t size)
d488 1
a488 1
  b = malloc (sizeof (struct yy_buffer_state));
d494 1
a494 1
  b->yy_ch_buf = malloc ((unsigned) (b->yy_buf_size + 3));
d523 2
a524 1
lex_redirect (const char *string)
d529 1
a529 1
  if (include_stack_ptr >= MAX_INCLUDE_DEPTH)
d549 1
a549 1
ldlex_script (void)
d556 1
a556 1
ldlex_mri_script (void)
d563 1
a563 1
ldlex_version_script (void)
d570 1
a570 1
ldlex_version_file (void)
d577 1
a577 1
ldlex_defsym (void)
d582 1
a582 1

d584 1
a584 1
ldlex_expression (void)
d591 1
a591 1
ldlex_both (void)
d598 1
a598 1
ldlex_popstate (void)
d608 4
a611 1
yy_input (char *buf, int *result, int max_size)
d613 1
a613 1
  *result = 0;
d618 2
a619 2
	  *result = fread (buf, 1, max_size, yyin);
	  if (*result < max_size && ferror (yyin))
d628 1
a628 1
comment (void)
d635 1
a635 1
    while (c != '*' && c != EOF)
d666 2
a667 1
lex_warn_invalid (char *where, char *what)
@


