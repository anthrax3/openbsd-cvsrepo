head	1.8;
access;
symbols
	OPENBSD_6_0:1.8.0.12
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.8
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.10
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2013.09.30.15.31.32;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.02.20.45.48;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.50;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.43;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.12.45;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.09.33;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.54.26;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.16;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.16;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.35.36;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.35.07;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.28.35;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.48.10;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.14.01.19;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.49;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.23.22;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Make stderr buffered in einfo().  Speeds up display of error messages
on slower platforms.  Idea from espie@@, OK espie@@ deraadt@@ guenther@@
@
text
@/* ldmisc.c
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2002, 2003
   Free Software Foundation, Inc.
   Written by Steve Chamberlain of Cygnus Support.

   This file is part of GLD, the Gnu Linker.

   GLD is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GLD is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GLD; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "bfd.h"
#include "bfdlink.h"
#include "sysdep.h"
#include "libiberty.h"
#include "demangle.h"
#include <stdarg.h>
#include "ld.h"
#include "ldmisc.h"
#include "ldexp.h"
#include "ldlang.h"
#include <ldgram.h>
#include "ldlex.h"
#include "ldmain.h"
#include "ldfile.h"

/*
 %% literal %
 %F error is fatal
 %P print program name
 %S print script file and linenumber
 %E current bfd error or errno
 %I filename from a lang_input_statement_type
 %B filename from a bfd
 %T symbol name
 %X no object output, fail return
 %V hex bfd_vma
 %v hex bfd_vma, no leading zeros
 %W hex bfd_vma with 0x with no leading zeros taking up 8 spaces
 %C clever filename:linenumber with function
 %D like %C, but no function name
 %G like %D, but only function name
 %R info about a relent
 %s arbitrary string, like printf
 %d integer, like printf
 %u integer, like printf
*/

static void
vfinfo (FILE *fp, const char *fmt, va_list arg)
{
  bfd_boolean fatal = FALSE;

  while (*fmt != '\0')
    {
      while (*fmt != '%' && *fmt != '\0')
	{
	  putc (*fmt, fp);
	  fmt++;
	}

      if (*fmt == '%')
	{
	  fmt++;
	  switch (*fmt++)
	    {
	    default:
	      fprintf (fp, "%%%c", fmt[-1]);
	      break;

	    case '%':
	      /* literal % */
	      putc ('%', fp);
	      break;

	    case 'X':
	      /* no object output, fail return */
	      config.make_executable = FALSE;
	      break;

	    case 'V':
	      /* hex bfd_vma */
	      {
		bfd_vma value = va_arg (arg, bfd_vma);
		fprintf_vma (fp, value);
	      }
	      break;

	    case 'v':
	      /* hex bfd_vma, no leading zeros */
	      {
		char buf[100];
		char *p = buf;
		bfd_vma value = va_arg (arg, bfd_vma);
		sprintf_vma (p, value);
		while (*p == '0')
		  p++;
		if (!*p)
		  p--;
		fputs (p, fp);
	      }
	      break;

	    case 'W':
	      /* hex bfd_vma with 0x with no leading zeroes taking up
		 8 spaces.  */
	      {
		char buf[100];
		bfd_vma value;
		char *p;
		int len;

		value = va_arg (arg, bfd_vma);
		sprintf_vma (buf, value);
		for (p = buf; *p == '0'; ++p)
		  ;
		if (*p == '\0')
		  --p;
		len = strlen (p);
		while (len < 8)
		  {
		    putc (' ', fp);
		    ++len;
		  }
		fprintf (fp, "0x%s", p);
	      }
	      break;

	    case 'T':
	      /* Symbol name.  */
	      {
		const char *name = va_arg (arg, const char *);

		if (name == NULL || *name == 0)
		  fprintf (fp, _("no symbol"));
		else if (! demangling)
		  fprintf (fp, "%s", name);
		else
		  {
		    char *demangled;

		    demangled = demangle (name);
		    fprintf (fp, "%s", demangled);
		    free (demangled);
		  }
	      }
	      break;

	    case 'B':
	      /* filename from a bfd */
	      {
		bfd *abfd = va_arg (arg, bfd *);
		if (abfd->my_archive)
		  fprintf (fp, "%s(%s)", abfd->my_archive->filename,
			   abfd->filename);
		else
		  fprintf (fp, "%s", abfd->filename);
	      }
	      break;

	    case 'F':
	      /* Error is fatal.  */
	      fatal = TRUE;
	      break;

	    case 'P':
	      /* Print program name.  */
	      fprintf (fp, "%s", program_name);
	      break;

	    case 'E':
	      /* current bfd error or errno */
	      fprintf (fp, "%s", bfd_errmsg (bfd_get_error ()));
	      break;

	    case 'I':
	      /* filename from a lang_input_statement_type */
	      {
		lang_input_statement_type *i;

		i = va_arg (arg, lang_input_statement_type *);
		if (bfd_my_archive (i->the_bfd) != NULL)
		  fprintf (fp, "(%s)",
			   bfd_get_filename (bfd_my_archive (i->the_bfd)));
		fprintf (fp, "%s", i->local_sym_name);
		if (bfd_my_archive (i->the_bfd) == NULL
		    && strcmp (i->local_sym_name, i->filename) != 0)
		  fprintf (fp, " (%s)", i->filename);
	      }
	      break;

	    case 'S':
	      /* Print script file and linenumber.  */
	      if (parsing_defsym)
		fprintf (fp, "--defsym %s", lex_string);
	      else if (ldfile_input_filename != NULL)
		fprintf (fp, "%s:%u", ldfile_input_filename, lineno);
	      else
		fprintf (fp, _("built in linker script:%u"), lineno);
	      break;

	    case 'R':
	      /* Print all that's interesting about a relent.  */
	      {
		arelent *relent = va_arg (arg, arelent *);

		lfinfo (fp, "%s+0x%v (type %s)",
			(*(relent->sym_ptr_ptr))->name,
			relent->addend,
			relent->howto->name);
	      }
	      break;

	    case 'C':
	    case 'D':
	    case 'G':
	      /* Clever filename:linenumber with function name if possible.
		 The arguments are a BFD, a section, and an offset.  */
	      {
		static bfd *last_bfd;
		static char *last_file = NULL;
		static char *last_function = NULL;
		bfd *abfd;
		asection *section;
		bfd_vma offset;
		lang_input_statement_type *entry;
		asymbol **asymbols;
		const char *filename;
		const char *functionname;
		unsigned int linenumber;
		bfd_boolean discard_last;

		abfd = va_arg (arg, bfd *);
		section = va_arg (arg, asection *);
		offset = va_arg (arg, bfd_vma);

		entry = (lang_input_statement_type *) abfd->usrdata;
		if (entry != (lang_input_statement_type *) NULL
		    && entry->asymbols != (asymbol **) NULL)
		  asymbols = entry->asymbols;
		else
		  {
		    long symsize;
		    long symbol_count;

		    symsize = bfd_get_symtab_upper_bound (abfd);
		    if (symsize < 0)
		      einfo (_("%B%F: could not read symbols\n"), abfd);
		    asymbols = xmalloc (symsize);
		    symbol_count = bfd_canonicalize_symtab (abfd, asymbols);
		    if (symbol_count < 0)
		      einfo (_("%B%F: could not read symbols\n"), abfd);
		    if (entry != (lang_input_statement_type *) NULL)
		      {
			entry->asymbols = asymbols;
			entry->symbol_count = symbol_count;
		      }
		  }

		lfinfo (fp, "%B(%s+0x%v)", abfd, section->name, offset);

		discard_last = TRUE;
		if (bfd_find_nearest_line (abfd, section, asymbols, offset,
					   &filename, &functionname,
					   &linenumber))
		  {
		    bfd_boolean need_colon = TRUE;

		    if (functionname != NULL && fmt[-1] == 'C')
		      {
			if (last_bfd == NULL
			    || last_file == NULL
			    || last_function == NULL
			    || last_bfd != abfd
			    || (filename != NULL
				&& strcmp (last_file, filename) != 0)
			    || strcmp (last_function, functionname) != 0)
			  {
			    lfinfo (fp, _(": In function `%T':\n"),
				    functionname);
			    need_colon = FALSE;

			    last_bfd = abfd;
			    if (last_file != NULL)
			      free (last_file);
			    last_file = NULL;
			    if (filename)
			      last_file = xstrdup (filename);
			    if (last_function != NULL)
			      free (last_function);
			    last_function = xstrdup (functionname);
			  }
			discard_last = FALSE;
		      }

		    if (filename != NULL)
		      {
			if (need_colon)
			  putc (':', fp);
			fputs (filename, fp);
		      }

		    if (functionname != NULL && fmt[-1] == 'G')
		      lfinfo (fp, ":%T", functionname);
		    else if (filename != NULL && linenumber != 0)
		      fprintf (fp, ":%u", linenumber);
		  }

		if (asymbols != NULL && entry == NULL)
		  free (asymbols);

		if (discard_last)
		  {
		    last_bfd = NULL;
		    if (last_file != NULL)
		      {
			free (last_file);
			last_file = NULL;
		      }
		    if (last_function != NULL)
		      {
			free (last_function);
			last_function = NULL;
		      }
		  }
	      }
	      break;

	    case 's':
	      /* arbitrary string, like printf */
	      fprintf (fp, "%s", va_arg (arg, char *));
	      break;

	    case 'd':
	      /* integer, like printf */
	      fprintf (fp, "%d", va_arg (arg, int));
	      break;

	    case 'u':
	      /* unsigned integer, like printf */
	      fprintf (fp, "%u", va_arg (arg, unsigned int));
	      break;
	    }
	}
    }

  if (config.fatal_warnings)
    config.make_executable = FALSE;

  if (fatal)
    xexit (1);
}

/* Wrapper around cplus_demangle.  Strips leading underscores and
   other such chars that would otherwise confuse the demangler.  */

char *
demangle (const char *name)
{
  char *res;
  const char *p;

  if (output_bfd != NULL
      && bfd_get_symbol_leading_char (output_bfd) == name[0])
    ++name;

  /* This is a hack for better error reporting on XCOFF, PowerPC64-ELF
     or the MS PE format.  These formats have a number of leading '.'s
     on at least some symbols, so we remove all dots to avoid
     confusing the demangler.  */
  p = name;
  while (*p == '.')
    ++p;

  res = cplus_demangle (p, DMGL_ANSI | DMGL_PARAMS);
  if (res)
    {
      size_t dots = p - name;

      /* Now put back any stripped dots.  */
      if (dots != 0)
	{
	  size_t len = strlen (res) + 1;
	  char *add_dots = xmalloc (len + dots);

	  memcpy (add_dots, name, dots);
	  memcpy (add_dots + dots, res, len);
	  free (res);
	  res = add_dots;
	}
      return res;
    }
  return xstrdup (name);
}

/* Format info message and print on stdout.  */

/* (You would think this should be called just "info", but then you
   would be hosed by LynxOS, which defines that name in its libc.)  */

void
info_msg (const char *fmt, ...)
{
  va_list arg;

  va_start (arg, fmt);
  vfinfo (stdout, fmt, arg);
  va_end (arg);
}

/* ('e' for error.) Format info message and print on stderr.  */

void
einfo (const char *fmt, ...)
{
  va_list arg;
  char buf[BUFSIZ];

  setvbuf(stderr, buf, _IOFBF, sizeof(buf));
  va_start (arg, fmt);
  vfinfo (stderr, fmt, arg);
  va_end (arg);
  fflush(stderr);
  setvbuf(stderr, NULL, _IONBF, 0);
}

void
info_assert (const char *file, unsigned int line)
{
  einfo (_("%F%P: internal error %s %d\n"), file, line);
}

/* ('m' for map) Format info message and print on map.  */

void
minfo (const char *fmt, ...)
{
  va_list arg;

  va_start (arg, fmt);
  vfinfo (config.map_file, fmt, arg);
  va_end (arg);
}

void
lfinfo (FILE *file, const char *fmt, ...)
{
  va_list arg;

  va_start (arg, fmt);
  vfinfo (file, fmt, arg);
  va_end (arg);
}

/* Functions to print the link map.  */

void
print_space (void)
{
  fprintf (config.map_file, " ");
}

void
print_nl (void)
{
  fprintf (config.map_file, "\n");
}

/* A more or less friendly abort message.  In ld.h abort is defined to
   call this function.  */

void
ld_abort (const char *file, int line, const char *fn)
{
  if (fn != NULL)
    einfo (_("%P: internal error: aborting at %s line %d in %s\n"),
	   file, line, fn);
  else
    einfo (_("%P: internal error: aborting at %s line %d\n"),
	   file, line);
  einfo (_("%P%F: please report this bug\n"));
  xexit (1);
}

bfd_boolean
error_handler (int id, const char *fmt, ...)
{
  va_list arg;

  va_start (arg, fmt);

  switch (id)
    {
    default:
      break;

    /* We can be called with

	error_handler (-LD_DEFINITION_IN_DISCARDED_SECTION, "", 0);

	to make this error non-fatal and

	error_handler (-LD_DEFINITION_IN_DISCARDED_SECTION, "", 1);

	to make this error fatal.  */
    case -LD_DEFINITION_IN_DISCARDED_SECTION:
    case LD_DEFINITION_IN_DISCARDED_SECTION:
      {
	static struct bfd_hash_table *hash;
	static int fatal = 1;
	const char *name;

	if (id == -LD_DEFINITION_IN_DISCARDED_SECTION)
	  {
	    fatal = va_arg (arg, int);
	    goto out;
	  }

	name = va_arg (arg, const char *);
	/* Only warn once about a particular undefined symbol.  */
	if (hash == NULL)
	  {
	    hash = xmalloc (sizeof (struct bfd_hash_table));
	    if (! bfd_hash_table_init (hash, bfd_hash_newfunc))
	      einfo (_("%F%P: bfd_hash_table_init failed: %E\n"));
	  }

	if (bfd_hash_lookup (hash, name, FALSE, FALSE) != NULL)
	  goto out;

	if (bfd_hash_lookup (hash, name, TRUE, TRUE) == NULL)
	  einfo (_("%F%P: bfd_hash_lookup failed: %E\n"));

	if (fatal)
	  config.make_executable = FALSE;
      }
      break;
    }
  vfinfo (stderr, fmt, arg);

out:
  va_end (arg);
  return TRUE;
}
@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d429 1
d431 1
d435 2
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d25 1
a28 2

#ifdef ANSI_PROTOTYPES
a29 4
#else
#include <varargs.h>
#endif

a38 2
static void vfinfo PARAMS ((FILE *, const char *, va_list));

d62 1
a62 4
vfinfo (fp, fmt, arg)
     FILE *fp;
     const char *fmt;
     va_list arg;
d118 1
a118 1
                 8 spaces.  */
d146 1
a146 1
		if (name == (const char *) NULL || *name == 0)
d261 1
a261 1
		    asymbols = (asymbol **) xmalloc (symsize);
d370 1
a370 2
demangle (name)
     const char *name;
d411 1
a411 1
   would hosed by LynxOS, which defines that name in its libc.)  */
d414 1
a414 1
info_msg VPARAMS ((const char *fmt, ...))
d416 1
a416 2
  VA_OPEN (arg, fmt);
  VA_FIXEDARG (arg, const char *, fmt);
d418 1
d420 1
a420 1
  VA_CLOSE (arg);
d426 1
a426 1
einfo VPARAMS ((const char *fmt, ...))
d428 1
a428 2
  VA_OPEN (arg, fmt);
  VA_FIXEDARG (arg, const char *, fmt);
d430 1
d432 1
a432 1
  VA_CLOSE (arg);
d436 1
a436 3
info_assert (file, line)
     const char *file;
     unsigned int line;
d444 1
a444 1
minfo VPARAMS ((const char *fmt, ...))
d446 1
a446 2
  VA_OPEN (arg, fmt);
  VA_FIXEDARG (arg, const char *, fmt);
d448 1
d450 1
a450 1
  VA_CLOSE (arg);
d454 1
a454 1
lfinfo VPARAMS ((FILE *file, const char *fmt, ...))
d456 1
a456 3
  VA_OPEN (arg, fmt);
  VA_FIXEDARG (arg, FILE *, file);
  VA_FIXEDARG (arg, const char *, fmt);
d458 1
d460 1
a460 1
  VA_CLOSE (arg);
d466 1
a466 1
print_space ()
d472 1
a472 1
print_nl ()
d481 1
a481 4
ld_abort (file, line, fn)
     const char *file;
     int line;
     const char *fn;
d494 1
a494 1
error_handler VPARAMS ((int id ATTRIBUTE_UNUSED, const char *fmt, ...))
d496 8
a503 2
  VA_OPEN (arg, fmt);
  VA_FIXEDARG (arg, const char *, fmt);
d505 42
d548 3
a550 1
  VA_CLOSE (arg);
@


1.5
log
@resolve conflicts.
@
text
@d2 2
a3 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
d7 1
a7 1
This file is part of GLD, the Gnu Linker.
d9 14
a22 14
GLD is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GLD is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GLD; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
a30 1
#define USE_STDARG 1
a32 1
#define USE_STDARG 0
d39 1
a39 1
#include "ldgram.h"
a67 20
char *
demangle (string)
     const char *string;
{
  char *res;

  if (output_bfd != NULL
      && bfd_get_symbol_leading_char (output_bfd) == string[0])
    ++string;

  /* This is a hack for better error reporting on XCOFF, or the MS PE
     format.  Xcoff has a single '.', while the NT PE for PPC has
     '..'.  So we remove all of them.  */
  while (string[0] == '.')
    ++string;

  res = cplus_demangle (string, DMGL_ANSI | DMGL_PARAMS);
  return res ? res : xstrdup (string);
}

d74 1
a74 1
  boolean fatal = false;
d100 1
a100 1
	      config.make_executable = false;
d185 1
a185 1
	      fatal = true;
d239 2
a240 3
	      /* Clever filename:linenumber with function name if possible,
		 or section name as a last resort.  The arguments are a BFD,
		 a section, and an offset.  */
d253 1
a253 1
		boolean discard_last;
d282 3
a284 1
		discard_last = true;
d289 3
a291 1
		    if (functionname != NULL && fmt[-1] == 'G')
a292 11
			lfinfo (fp, "%B:", abfd);
			if (filename != NULL
			    && strcmp (filename, bfd_get_filename (abfd)) != 0)
			  fprintf (fp, "%s:", filename);
			lfinfo (fp, "%T", functionname);
		      }
		    else if (functionname != NULL && fmt[-1] == 'C')
		      {
			if (filename == (char *) NULL)
			  filename = abfd->filename;

d297 2
a298 1
			    || strcmp (last_file, filename) != 0
d301 3
a303 5
			    /* We use abfd->filename in this initial line,
			       in case filename is a .h file or something
			       similarly unhelpful.  */
			    lfinfo (fp, _("%B: In function `%T':\n"),
				    abfd, functionname);
d308 3
a310 1
			    last_file = xstrdup (filename);
d315 1
a315 6
			discard_last = false;
			if (linenumber != 0)
			  fprintf (fp, "%s:%u", filename, linenumber);
			else
			  lfinfo (fp, "%s(%s+0x%v)", filename, section->name,
				  offset);
d317 2
a318 2
		    else if (filename == NULL
			     || strcmp (filename, abfd->filename) == 0)
d320 3
a322 4
			lfinfo (fp, "%B(%s+0x%v)", abfd, section->name,
				offset);
			if (linenumber != 0)
			  lfinfo (fp, ":%u", linenumber);
d324 5
a328 5
		    else if (linenumber != 0)
		      lfinfo (fp, "%B:%s:%u", abfd, filename, linenumber);
		    else
		      lfinfo (fp, "%B(%s+0x%v):%s", abfd, section->name,
			      offset, filename);
d330 3
a332 2
		else
		  lfinfo (fp, "%B(%s+0x%v)", abfd, section->name, offset);
d369 4
a372 1
  if (fatal == true)
d376 43
d425 1
a425 6
#if USE_STDARG
info_msg (const char *fmt, ...)
#else
info_msg (va_alist)
     va_dcl
#endif
d427 2
a428 10
  va_list arg;

#if ! USE_STDARG
  const char *fmt;

  va_start (arg);
  fmt = va_arg (arg, const char *);
#else
  va_start (arg, fmt);
#endif
d431 1
a431 1
  va_end (arg);
d437 1
a437 6
#if USE_STDARG
einfo (const char *fmt, ...)
#else
einfo (va_alist)
     va_dcl
#endif
d439 2
a440 10
  va_list arg;

#if ! USE_STDARG
  const char *fmt;

  va_start (arg);
  fmt = va_arg (arg, const char *);
#else
  va_start (arg, fmt);
#endif
d443 1
a443 1
  va_end (arg);
d457 1
a457 6
#if USE_STDARG
minfo (const char *fmt, ...)
#else
minfo (va_alist)
     va_dcl
#endif
d459 2
a460 9
  va_list arg;

#if ! USE_STDARG
  const char *fmt;
  va_start (arg);
  fmt = va_arg (arg, const char *);
#else
  va_start (arg, fmt);
#endif
d463 1
a463 1
  va_end (arg);
d467 1
a467 6
#if USE_STDARG
lfinfo (FILE *file, const char *fmt, ...)
#else
lfinfo (va_alist)
     va_dcl
#endif
d469 3
a471 12
  va_list arg;

#if ! USE_STDARG
  FILE *file;
  const char *fmt;

  va_start (arg);
  file = va_arg (arg, FILE *);
  fmt = va_arg (arg, const char *);
#else
  va_start (arg, fmt);
#endif
d474 1
a474 1
  va_end (arg);
d508 11
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d79 4
a82 4
  /* This is a hack for better error reporting on XCOFF, or the MS PE   */
  /* format.  Xcoff has a single '.', while the NT PE for PPC has '..'. */
  /* So we remove all of them.                                          */
  while(string[0] == '.')
d99 1
a99 1
      while (*fmt != '%' && *fmt != '\0') 
d105 1
a105 1
      if (*fmt == '%') 
d107 2
a108 2
	  fmt ++;
	  switch (*fmt++) 
d111 1
a111 1
	      fprintf (fp,"%%%c", fmt[-1]);
d194 1
a194 1
	      { 
d205 1
a205 1
	      /* error is fatal */
d210 1
a210 1
	      /* print program name */
d236 1
a236 1
	      /* print script file and linenumber */
d246 1
a246 1
	      /* Print all that's interesting about a relent */
d249 1
a249 1
	
d256 1
a256 1
	
d338 1
a338 1
			    last_file = buystring (filename);
d341 1
a341 1
			    last_function = buystring (functionname);
d358 1
a358 1
		    else if (linenumber != 0) 
d383 1
a383 1
		
d402 2
a403 2
  if (fatal == true) 
    xexit(1);
d406 1
a406 1
/* Format info message and print on stdout. */
d434 1
a434 1
/* ('e' for error.) Format info message and print on stderr. */
d459 1
a459 1
void 
d467 1
a467 11
char *
buystring (x)
     CONST char *CONST x;
{
  size_t l = strlen(x)+1;
  char *r = xmalloc(l);
  memcpy(r, x,l);
  return r;
}

/* ('m' for map) Format info message and print on map. */
d518 1
a518 1
void 
d524 1
a524 1
void 
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d19 3
a21 2
along with GLD; see the file COPYING.  If not, write to
the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d45 2
d177 4
a180 2
		if (name == (const char *) NULL)
		  fprintf (fp, "no symbol");
d216 1
a216 1
	      fprintf (fp, bfd_errmsg (bfd_get_error ()));
d242 1
a242 1
		fprintf (fp, "built in linker script:%u", lineno);
d250 4
a253 4
		finfo (fp, "%s+0x%v (type %s)",
		       (*(relent->sym_ptr_ptr))->name,
		       relent->addend,
		       relent->howto->name);
d292 1
a292 1
		      einfo ("%B%F: could not read symbols\n", abfd);
d296 1
a296 1
		      einfo ("%B%F: could not read symbols\n", abfd);
d311 1
a311 1
			finfo (fp, "%B:", abfd);
d315 1
a315 1
			finfo (fp, "%T", functionname);
d332 2
a333 2
			    finfo (fp, "%B: In function `%T':\n",
				   abfd, functionname);
d347 2
a348 2
			  finfo (fp, "%s(%s+0x%v)", filename, section->name,
				 offset);
d353 2
a354 1
			finfo (fp, "%B(%s+0x%v)", abfd, section->name, offset);
d356 1
a356 1
			  finfo (fp, ":%u", linenumber);
d359 1
a359 1
		      finfo (fp, "%B:%s:%u", abfd, filename, linenumber);
d361 2
a362 2
		      finfo (fp, "%B(%s+0x%v):%s", abfd, section->name, offset,
			     filename);
d365 1
a365 1
		  finfo (fp, "%B(%s+0x%v)", abfd, section->name, offset);
d464 1
a464 1
  einfo ("%F%P: internal error %s %d\n", file, line);
d503 1
a503 1
finfo (FILE *file, const char *fmt, ...)
d505 1
a505 1
finfo (va_alist)
d538 19
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d75 4
a78 2
  /* This is a hack for better error reporting on XCOFF.  */
  if (string[0] == '.')
d156 2
@


1.1
log
@Initial revision
@
text
@d2 1
a2 2
   Copyright (C) 1991, 92, 93, 94 Free Software Foundation, Inc.

d23 6
a28 9
#include <demangle.h>
/* this collection of routines wants to use the Unix style varargs
   use special abbreviated portion of varargs.h */
#ifdef WINDOWS_NT
/* Since macro __STDC__ is defined, the compiler will raise and error if
   VARARGS.H from mstools\h is included.  Since we only need a portion of
   this header file, it has been incorporated into local header file
   xvarargs.h */
#include "xvarargs.h"
d31 1
a42 6

/* VARARGS*/
static void finfo ();
static const char *demangle PARAMS ((const char *string,
				     int remove_underscore));

d55 1
d58 1
d65 2
a66 2
static const char *
demangle (string, remove_underscore)
a67 1
     int remove_underscore;
d69 1
a69 1
  const char *res;
d71 1
a71 2
  if (remove_underscore
      && output_bfd != NULL
d76 1
a76 1
  if (remove_underscore && string[0] == '.')
a78 4
  /* Note that there's a memory leak here, we keep buying memory for
     demangled names, and never free.  But if you have so many errors
     that you run out of VM with the error messages, then there's
     something up.  */
d80 1
a80 1
  return res ? res : string;
d84 1
a84 1
vfinfo(fp, fmt, arg)
d86 1
a86 1
     char *fmt;
d91 1
a91 3
  while (*fmt) 
  {
    while (*fmt != '%' && *fmt != '\0') 
d93 1
a93 25
      putc(*fmt, fp);
      fmt++;
    }

    if (*fmt == '%') 
    {
      fmt ++;
      switch (*fmt++) 
      {
      default:
	fprintf(fp,"%%%c", fmt[-1]);
	break;

      case '%':
	/* literal % */
	putc('%', fp);
	break;

       case 'X':
	/* no object output, fail return */
	config.make_executable = false;
	break;

       case 'V':
	/* hex bfd_vma */
d95 2
a96 2
	  bfd_vma value = va_arg(arg, bfd_vma);
	  fprintf_vma(fp, value);
a97 1
	break;
d99 1
a99 2
      case 'v':
	/* hex bfd_vma, no leading zeros */
d101 133
a233 11
	  char buf[100];
	  char *p = buf;
	  bfd_vma value = va_arg (arg, bfd_vma);
	  sprintf_vma (p, value);
	  while (*p == '0')
	    p++;
	  if (!*p)
	    p--;
	  fputs (p, fp);
	}
	break;
d235 4
a238 67
       case 'T':
	/* Symbol name.  */
	{
	  const char *name = va_arg (arg, const char *);

	  if (name != (const char *) NULL)
	    fprintf (fp, "%s", demangle (name, 1));
	  else
	    fprintf (fp, "no symbol");
	}
	break;

       case 'B':
	/* filename from a bfd */
       { 
	 bfd *abfd = va_arg(arg, bfd *);
	 if (abfd->my_archive) {
	   fprintf(fp,"%s(%s)", abfd->my_archive->filename,
		   abfd->filename);
	 }
	 else {
	   fprintf(fp,"%s", abfd->filename);
	 }
       }
	break;

       case 'F':
	/* error is fatal */
	fatal = true;
	break;

       case 'P':
	/* print program name */
	fprintf(fp,"%s", program_name);
	break;

       case 'E':
	/* current bfd error or errno */
	fprintf(fp, bfd_errmsg(bfd_get_error ()));
	break;

       case 'I':
	/* filename from a lang_input_statement_type */
       {
	 lang_input_statement_type *i =
	  va_arg(arg,lang_input_statement_type *);

	 if (i->the_bfd->my_archive)
	   fprintf(fp, "(%s)", i->the_bfd->my_archive->filename);
	 fprintf(fp,"%s", i->local_sym_name);
       }
	break;

       case 'S':
	/* print script file and linenumber */
	if (parsing_defsym)
	  fprintf (fp, "--defsym %s", lex_string);
	else if (ldfile_input_filename != NULL)
	  fprintf (fp, "%s:%u", ldfile_input_filename, lineno);
	else
	  fprintf (fp, "built in linker script:%u", lineno);
	break;

       case 'R':
	/* Print all that's interesting about a relent */
       {
	 arelent *relent = va_arg(arg, arelent *);
d240 6
a245 6
	 finfo (fp, "%s+0x%v (type %s)",
		(*(relent->sym_ptr_ptr))->name,
		relent->addend,
		relent->howto->name);
       }
	break;
d247 108
a354 31
       case 'C':
       case 'D':
	/* Clever filename:linenumber with function name if possible,
	   or section name as a last resort.  The arguments are a BFD,
	   a section, and an offset.  */
	{
	  static bfd *last_bfd;
	  static char *last_file = NULL;
	  static char *last_function = NULL;
	  bfd *abfd;
	  asection *section;
	  bfd_vma offset;
	  lang_input_statement_type *entry;
	  asymbol **asymbols;
	  const char *filename;
	  const char *functionname;
	  unsigned int linenumber;
	  boolean discard_last;

	  abfd = va_arg (arg, bfd *);
	  section = va_arg (arg, asection *);
	  offset = va_arg (arg, bfd_vma);

	  entry = (lang_input_statement_type *) abfd->usrdata;
	  if (entry != (lang_input_statement_type *) NULL
	      && entry->asymbols != (asymbol **) NULL)
	    asymbols = entry->asymbols;
	  else
	    {
	      long symsize;
	      long symbol_count;
d356 5
a360 38
	      symsize = bfd_get_symtab_upper_bound (abfd);
	      if (symsize < 0)
		einfo ("%B%F: could not read symbols\n", abfd);
	      asymbols = (asymbol **) xmalloc (symsize);
	      symbol_count = bfd_canonicalize_symtab (abfd, asymbols);
	      if (symbol_count < 0)
		einfo ("%B%F: could not read symbols\n", abfd);
	      if (entry != (lang_input_statement_type *) NULL)
		{
		  entry->asymbols = asymbols;
		  entry->symbol_count = symbol_count;
		}
	    }

	  discard_last = true;
	  if (bfd_find_nearest_line (abfd, section, asymbols, offset,
				     &filename, &functionname, &linenumber))
	    {
	      if (functionname != NULL && fmt[-1] == 'C')
		{
		  if (filename == (char *) NULL)
		    filename = abfd->filename;

		  if (last_bfd == NULL
		      || last_file == NULL
		      || last_function == NULL
		      || last_bfd != abfd
		      || strcmp (last_file, filename) != 0
		      || strcmp (last_function, functionname) != 0)
		    {
		      /* We use abfd->filename in this initial line,
                         in case filename is a .h file or something
                         similarly unhelpful.  */
		      finfo (fp, "%B: In function `%s':\n",
			     abfd, demangle (functionname, 1));

		      last_bfd = abfd;
		      if (last_file != NULL)
d362 4
a365 2
		      last_file = buystring (filename);
		      if (last_function != NULL)
d367 20
a386 37
		      last_function = buystring (functionname);
		    }
		  discard_last = false;
		  if (linenumber != 0)
		    fprintf (fp, "%s:%u", filename, linenumber);
		  else
		    finfo (fp, "%s(%s+0x%v)", filename, section->name, offset);
		}
	      else if (filename == NULL
		       || strcmp (filename, abfd->filename) == 0)
		{
		  finfo (fp, "%B(%s+0x%v)", abfd, section->name, offset);
		  if (linenumber != 0)
		    finfo (fp, "%u", linenumber);
		}
	      else if (linenumber != 0) 
		finfo (fp, "%B:%s:%u", abfd, filename, linenumber);
	      else
		finfo (fp, "%B(%s+0x%v):%s", abfd, section->name, offset,
		       filename);
	    }
	  else
	    finfo (fp, "%B(%s+0x%v)", abfd, section->name, offset);

	  if (discard_last)
	    {
	      last_bfd = NULL;
	      if (last_file != NULL)
		{
		  free (last_file);
		  last_file = NULL;
		}
	      if (last_function != NULL)
		{
		  free (last_function);
		  last_function = NULL;
		}
a388 17
	break;
		
       case 's':
	/* arbitrary string, like printf */
	fprintf(fp,"%s", va_arg(arg, char *));
	break;

       case 'd':
	/* integer, like printf */
	fprintf(fp,"%d", va_arg(arg, int));
	break;

       case 'u':
	/* unsigned integer, like printf */
	fprintf(fp,"%u", va_arg(arg, unsigned int));
	break;
      }
a389 1
  }
d397 2
a398 2
/* (You would think this should be called just "info", but then you would
   hosed by LynxOS, which defines that name in its libc.) */
d400 5
a404 1
void info_msg(va_alist)
d406 1
a407 1
  char *fmt;
d409 12
a420 4
  va_start(arg);
  fmt = va_arg(arg, char *);
  vfinfo(stdout, fmt, arg);
  va_end(arg);
d425 5
a429 1
void einfo(va_alist)
d431 1
a432 1
  char *fmt;
d434 12
a445 4
  va_start(arg);
  fmt = va_arg(arg, char *);
  vfinfo(stderr, fmt, arg);
  va_end(arg);
d449 2
a450 2
info_assert(file, line)
     char *file;
d453 1
a453 1
  einfo("%F%P: internal error %s %d\n", file,line);
a465 1

d468 5
a472 1
void minfo(va_alist)
d474 1
a475 1
  char *fmt;
d477 11
a487 4
  va_start(arg);
  fmt = va_arg(arg, char *);
  vfinfo(config.map_file, fmt, arg);
  va_end(arg);
d490 4
a493 2

static void
d496 1
d498 3
a500 1
  char *fmt;
d502 2
a503 1
  va_list arg;
d506 5
a510 1
  fmt = va_arg (arg, char *);
d514 2
a515 6



/*----------------------------------------------------------------------
  Functions to print the link map 
 */
d520 1
a520 1
  fprintf(config.map_file, " ");
d522 1
d526 1
a526 7
  fprintf(config.map_file, "\n");
}
void 
print_address (value)
     bfd_vma value;
{
  fprintf_vma(config.map_file, value);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d24 9
a32 6
#include "libiberty.h"
#include "demangle.h"

#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#define USE_STDARG 1
a34 1
#define USE_STDARG 0
d46 6
a63 1
 %W hex bfd_vma with 0x with no leading zeros taking up 8 spaces
a65 1
 %G like %D, but only function name
d72 2
a73 2
char *
demangle (string)
d75 1
d77 1
a77 1
  char *res;
d79 2
a80 1
  if (output_bfd != NULL
d85 1
a85 1
  if (string[0] == '.')
d88 4
d93 1
a93 1
  return res ? res : xstrdup (string);
d97 1
a97 1
vfinfo (fp, fmt, arg)
d99 1
a99 1
     const char *fmt;
d104 3
a106 1
  while (*fmt != '\0')
d108 25
a132 1
      while (*fmt != '%' && *fmt != '\0') 
d134 2
a135 2
	  putc (*fmt, fp);
	  fmt++;
d137 1
d139 2
a140 1
      if (*fmt == '%') 
d142 23
a164 133
	  fmt ++;
	  switch (*fmt++) 
	    {
	    default:
	      fprintf (fp,"%%%c", fmt[-1]);
	      break;

	    case '%':
	      /* literal % */
	      putc ('%', fp);
	      break;

	    case 'X':
	      /* no object output, fail return */
	      config.make_executable = false;
	      break;

	    case 'V':
	      /* hex bfd_vma */
	      {
		bfd_vma value = va_arg (arg, bfd_vma);
		fprintf_vma (fp, value);
	      }
	      break;

	    case 'v':
	      /* hex bfd_vma, no leading zeros */
	      {
		char buf[100];
		char *p = buf;
		bfd_vma value = va_arg (arg, bfd_vma);
		sprintf_vma (p, value);
		while (*p == '0')
		  p++;
		if (!*p)
		  p--;
		fputs (p, fp);
	      }
	      break;

	    case 'W':
	      /* hex bfd_vma with 0x with no leading zeroes taking up
                 8 spaces.  */
	      {
		char buf[100];
		bfd_vma value;
		char *p;
		int len;

		value = va_arg (arg, bfd_vma);
		sprintf_vma (buf, value);
		for (p = buf; *p == '0'; ++p)
		  ;
		len = strlen (p);
		while (len < 8)
		  {
		    putc (' ', fp);
		    ++len;
		  }
		fprintf (fp, "0x%s", p);
	      }
	      break;

	    case 'T':
	      /* Symbol name.  */
	      {
		const char *name = va_arg (arg, const char *);

		if (name == (const char *) NULL)
		  fprintf (fp, "no symbol");
		else
		  {
		    char *demangled;

		    demangled = demangle (name);
		    fprintf (fp, "%s", demangled);
		    free (demangled);
		  }
	      }
	      break;

	    case 'B':
	      /* filename from a bfd */
	      { 
		bfd *abfd = va_arg (arg, bfd *);
		if (abfd->my_archive)
		  fprintf (fp, "%s(%s)", abfd->my_archive->filename,
			   abfd->filename);
		else
		  fprintf (fp, "%s", abfd->filename);
	      }
	      break;

	    case 'F':
	      /* error is fatal */
	      fatal = true;
	      break;

	    case 'P':
	      /* print program name */
	      fprintf (fp, "%s", program_name);
	      break;

	    case 'E':
	      /* current bfd error or errno */
	      fprintf (fp, bfd_errmsg (bfd_get_error ()));
	      break;

	    case 'I':
	      /* filename from a lang_input_statement_type */
	      {
		lang_input_statement_type *i;

		i = va_arg (arg, lang_input_statement_type *);
		if (bfd_my_archive (i->the_bfd) != NULL)
		  fprintf (fp, "(%s)",
			   bfd_get_filename (bfd_my_archive (i->the_bfd)));
		fprintf (fp, "%s", i->local_sym_name);
		if (bfd_my_archive (i->the_bfd) == NULL
		    && strcmp (i->local_sym_name, i->filename) != 0)
		  fprintf (fp, " (%s)", i->filename);
	      }
	      break;

	    case 'S':
	      /* print script file and linenumber */
	      if (parsing_defsym)
		fprintf (fp, "--defsym %s", lex_string);
	      else if (ldfile_input_filename != NULL)
		fprintf (fp, "%s:%u", ldfile_input_filename, lineno);
	      else
		fprintf (fp, "built in linker script:%u", lineno);
	      break;
d166 55
a220 4
	    case 'R':
	      /* Print all that's interesting about a relent */
	      {
		arelent *relent = va_arg (arg, arelent *);
d222 6
a227 6
		finfo (fp, "%s+0x%v (type %s)",
		       (*(relent->sym_ptr_ptr))->name,
		       relent->addend,
		       relent->howto->name);
	      }
	      break;
d229 67
a295 108
	    case 'C':
	    case 'D':
	    case 'G':
	      /* Clever filename:linenumber with function name if possible,
		 or section name as a last resort.  The arguments are a BFD,
		 a section, and an offset.  */
	      {
		static bfd *last_bfd;
		static char *last_file = NULL;
		static char *last_function = NULL;
		bfd *abfd;
		asection *section;
		bfd_vma offset;
		lang_input_statement_type *entry;
		asymbol **asymbols;
		const char *filename;
		const char *functionname;
		unsigned int linenumber;
		boolean discard_last;

		abfd = va_arg (arg, bfd *);
		section = va_arg (arg, asection *);
		offset = va_arg (arg, bfd_vma);

		entry = (lang_input_statement_type *) abfd->usrdata;
		if (entry != (lang_input_statement_type *) NULL
		    && entry->asymbols != (asymbol **) NULL)
		  asymbols = entry->asymbols;
		else
		  {
		    long symsize;
		    long symbol_count;

		    symsize = bfd_get_symtab_upper_bound (abfd);
		    if (symsize < 0)
		      einfo ("%B%F: could not read symbols\n", abfd);
		    asymbols = (asymbol **) xmalloc (symsize);
		    symbol_count = bfd_canonicalize_symtab (abfd, asymbols);
		    if (symbol_count < 0)
		      einfo ("%B%F: could not read symbols\n", abfd);
		    if (entry != (lang_input_statement_type *) NULL)
		      {
			entry->asymbols = asymbols;
			entry->symbol_count = symbol_count;
		      }
		  }

		discard_last = true;
		if (bfd_find_nearest_line (abfd, section, asymbols, offset,
					   &filename, &functionname,
					   &linenumber))
		  {
		    if (functionname != NULL && fmt[-1] == 'G')
		      {
			finfo (fp, "%B:", abfd);
			if (filename != NULL
			    && strcmp (filename, bfd_get_filename (abfd)) != 0)
			  fprintf (fp, "%s:", filename);
			finfo (fp, "%T", functionname);
		      }
		    else if (functionname != NULL && fmt[-1] == 'C')
		      {
			if (filename == (char *) NULL)
			  filename = abfd->filename;

			if (last_bfd == NULL
			    || last_file == NULL
			    || last_function == NULL
			    || last_bfd != abfd
			    || strcmp (last_file, filename) != 0
			    || strcmp (last_function, functionname) != 0)
			  {
			    /* We use abfd->filename in this initial line,
			       in case filename is a .h file or something
			       similarly unhelpful.  */
			    finfo (fp, "%B: In function `%T':\n",
				   abfd, functionname);

			    last_bfd = abfd;
			    if (last_file != NULL)
			      free (last_file);
			    last_file = buystring (filename);
			    if (last_function != NULL)
			      free (last_function);
			    last_function = buystring (functionname);
			  }
			discard_last = false;
			if (linenumber != 0)
			  fprintf (fp, "%s:%u", filename, linenumber);
			else
			  finfo (fp, "%s(%s+0x%v)", filename, section->name,
				 offset);
		      }
		    else if (filename == NULL
			     || strcmp (filename, abfd->filename) == 0)
		      {
			finfo (fp, "%B(%s+0x%v)", abfd, section->name, offset);
			if (linenumber != 0)
			  finfo (fp, ":%u", linenumber);
		      }
		    else if (linenumber != 0) 
		      finfo (fp, "%B:%s:%u", abfd, filename, linenumber);
		    else
		      finfo (fp, "%B(%s+0x%v):%s", abfd, section->name, offset,
			     filename);
		  }
		else
		  finfo (fp, "%B(%s+0x%v)", abfd, section->name, offset);
d297 2
a298 5
		if (discard_last)
		  {
		    last_bfd = NULL;
		    if (last_file != NULL)
		      {
d300 2
a301 4
			last_file = NULL;
		      }
		    if (last_function != NULL)
		      {
d303 37
a339 20
			last_function = NULL;
		      }
		  }
	      }
	      break;
		
	    case 's':
	      /* arbitrary string, like printf */
	      fprintf (fp, "%s", va_arg (arg, char *));
	      break;

	    case 'd':
	      /* integer, like printf */
	      fprintf (fp, "%d", va_arg (arg, int));
	      break;

	    case 'u':
	      /* unsigned integer, like printf */
	      fprintf (fp, "%u", va_arg (arg, unsigned int));
	      break;
d342 17
d360 1
d368 2
a369 2
/* (You would think this should be called just "info", but then you
   would hosed by LynxOS, which defines that name in its libc.)  */
d371 1
a371 5
void
#if USE_STDARG
info_msg (const char *fmt, ...)
#else
info_msg (va_alist)
a372 1
#endif
d374 1
d376 4
a379 12

#if ! USE_STDARG
  const char *fmt;

  va_start (arg);
  fmt = va_arg (arg, const char *);
#else
  va_start (arg, fmt);
#endif

  vfinfo (stdout, fmt, arg);
  va_end (arg);
d384 1
a384 5
void
#if USE_STDARG
einfo (const char *fmt, ...)
#else
einfo (va_alist)
a385 1
#endif
d387 1
d389 4
a392 12

#if ! USE_STDARG
  const char *fmt;

  va_start (arg);
  fmt = va_arg (arg, const char *);
#else
  va_start (arg, fmt);
#endif

  vfinfo (stderr, fmt, arg);
  va_end (arg);
d396 2
a397 2
info_assert (file, line)
     const char *file;
d400 1
a400 1
  einfo ("%F%P: internal error %s %d\n", file, line);
d413 1
d416 1
a416 5
void
#if USE_STDARG
minfo (const char *fmt, ...)
#else
minfo (va_alist)
a417 1
#endif
d419 1
d421 5
a426 7
#if ! USE_STDARG
  const char *fmt;
  va_start (arg);
  fmt = va_arg (arg, const char *);
#else
  va_start (arg, fmt);
#endif
d428 1
a428 8
  vfinfo (config.map_file, fmt, arg);
  va_end (arg);
}

void
#if USE_STDARG
finfo (FILE *file, const char *fmt, ...)
#else
a430 1
#endif
d432 2
a434 5

#if ! USE_STDARG
  FILE *file;
  const char *fmt;

d437 1
a437 5
  fmt = va_arg (arg, const char *);
#else
  va_start (arg, fmt);
#endif

d441 6
a446 2

/* Functions to print the link map.  */
d451 1
a451 1
  fprintf (config.map_file, " ");
a452 1

d456 7
a462 1
  fprintf (config.map_file, "\n");
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d75 2
a76 4
  /* This is a hack for better error reporting on XCOFF, or the MS PE   */
  /* format.  Xcoff has a single '.', while the NT PE for PPC has '..'. */
  /* So we remove all of them.                                          */
  while(string[0] == '.')
a153 2
		if (*p == '\0')
		  --p;
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d18 2
a19 3
along with GLD; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
a41 2

static void vfinfo PARAMS ((FILE *, const char *, va_list));
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
d176 2
a177 4
		if (name == (const char *) NULL || *name == 0)
		  fprintf (fp, _("no symbol"));
		else if (! demangling)
		  fprintf (fp, "%s", name);
d213 1
a213 1
	      fprintf (fp, "%s", bfd_errmsg (bfd_get_error ()));
d239 1
a239 1
		fprintf (fp, _("built in linker script:%u"), lineno);
d247 4
a250 4
		lfinfo (fp, "%s+0x%v (type %s)",
			(*(relent->sym_ptr_ptr))->name,
			relent->addend,
			relent->howto->name);
d289 1
a289 1
		      einfo (_("%B%F: could not read symbols\n"), abfd);
d293 1
a293 1
		      einfo (_("%B%F: could not read symbols\n"), abfd);
d308 1
a308 1
			lfinfo (fp, "%B:", abfd);
d312 1
a312 1
			lfinfo (fp, "%T", functionname);
d329 2
a330 2
			    lfinfo (fp, _("%B: In function `%T':\n"),
				    abfd, functionname);
d344 2
a345 2
			  lfinfo (fp, "%s(%s+0x%v)", filename, section->name,
				  offset);
d350 1
a350 2
			lfinfo (fp, "%B(%s+0x%v)", abfd, section->name,
				offset);
d352 1
a352 1
			  lfinfo (fp, ":%u", linenumber);
d355 1
a355 1
		      lfinfo (fp, "%B:%s:%u", abfd, filename, linenumber);
d357 2
a358 2
		      lfinfo (fp, "%B(%s+0x%v):%s", abfd, section->name,
			      offset, filename);
d361 1
a361 1
		  lfinfo (fp, "%B(%s+0x%v)", abfd, section->name, offset);
d460 1
a460 1
  einfo (_("%F%P: internal error %s %d\n"), file, line);
d499 1
a499 1
lfinfo (FILE *file, const char *fmt, ...)
d501 1
a501 1
lfinfo (va_alist)
a533 19
}

/* A more or less friendly abort message.  In ld.h abort is defined to
   call this function.  */

void
ld_abort (file, line, fn)
     const char *file;
     int line;
     const char *fn;
{
  if (fn != NULL)
    einfo (_("%P: internal error: aborting at %s line %d in %s\n"),
	   file, line, fn);
  else
    einfo (_("%P: internal error: aborting at %s line %d\n"),
	   file, line);
  einfo (_("%P%F: please report this bug\n"));
  xexit (1);
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
d79 4
a82 4
  /* This is a hack for better error reporting on XCOFF, or the MS PE
     format.  Xcoff has a single '.', while the NT PE for PPC has
     '..'.  So we remove all of them.  */
  while (string[0] == '.')
d99 1
a99 1
      while (*fmt != '%' && *fmt != '\0')
d105 1
a105 1
      if (*fmt == '%')
d107 2
a108 2
	  fmt++;
	  switch (*fmt++)
d111 1
a111 1
	      fprintf (fp, "%%%c", fmt[-1]);
d194 1
a194 1
	      {
d205 1
a205 1
	      /* Error is fatal.  */
d210 1
a210 1
	      /* Print program name.  */
d236 1
a236 1
	      /* Print script file and linenumber.  */
d246 1
a246 1
	      /* Print all that's interesting about a relent.  */
d249 1
a249 1

d256 1
a256 1

d338 1
a338 1
			    last_file = xstrdup (filename);
d341 1
a341 1
			    last_function = xstrdup (functionname);
d358 1
a358 1
		    else if (linenumber != 0)
d383 1
a383 1

d402 2
a403 2
  if (fatal == true)
    xexit (1);
d406 1
a406 1
/* Format info message and print on stdout.  */
d434 1
a434 1
/* ('e' for error.) Format info message and print on stderr.  */
d459 1
a459 1
void
d467 11
a477 1
/* ('m' for map) Format info message and print on map.  */
d528 1
a528 1
void
d534 1
a534 1
void
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2002, 2003
d6 1
a6 1
   This file is part of GLD, the Gnu Linker.
d8 14
a21 14
   GLD is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GLD is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GLD; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d30 1
d33 1
d40 1
a40 1
#include <ldgram.h>
d69 20
d95 1
a95 1
  bfd_boolean fatal = FALSE;
d121 1
a121 1
	      config.make_executable = FALSE;
d206 1
a206 1
	      fatal = TRUE;
d260 3
a262 2
	      /* Clever filename:linenumber with function name if possible.
		 The arguments are a BFD, a section, and an offset.  */
d275 1
a275 1
		bfd_boolean discard_last;
d304 1
a304 3
		lfinfo (fp, "%B(%s+0x%v)", abfd, section->name, offset);

		discard_last = TRUE;
d309 12
a320 1
		    bfd_boolean need_colon = TRUE;
a321 2
		    if (functionname != NULL && fmt[-1] == 'C')
		      {
d326 1
a326 2
			    || (filename != NULL
				&& strcmp (last_file, filename) != 0)
d329 5
a333 3
			    lfinfo (fp, _(": In function `%T':\n"),
				    functionname);
			    need_colon = FALSE;
d338 1
a338 3
			    last_file = NULL;
			    if (filename)
			      last_file = xstrdup (filename);
d343 6
a348 1
			discard_last = FALSE;
d350 2
a351 2

		    if (filename != NULL)
d353 4
a356 3
			if (need_colon)
			  putc (':', fp);
			fputs (filename, fp);
d358 5
a362 5

		    if (functionname != NULL && fmt[-1] == 'G')
		      lfinfo (fp, ":%T", functionname);
		    else if (filename != NULL && linenumber != 0)
		      fprintf (fp, ":%u", linenumber);
d364 2
a365 3

		if (asymbols != NULL && entry == NULL)
		  free (asymbols);
d402 1
a402 4
  if (config.fatal_warnings)
    config.make_executable = FALSE;

  if (fatal)
a405 43
/* Wrapper around cplus_demangle.  Strips leading underscores and
   other such chars that would otherwise confuse the demangler.  */

char *
demangle (name)
     const char *name;
{
  char *res;
  const char *p;

  if (output_bfd != NULL
      && bfd_get_symbol_leading_char (output_bfd) == name[0])
    ++name;

  /* This is a hack for better error reporting on XCOFF, PowerPC64-ELF
     or the MS PE format.  These formats have a number of leading '.'s
     on at least some symbols, so we remove all dots to avoid
     confusing the demangler.  */
  p = name;
  while (*p == '.')
    ++p;

  res = cplus_demangle (p, DMGL_ANSI | DMGL_PARAMS);
  if (res)
    {
      size_t dots = p - name;

      /* Now put back any stripped dots.  */
      if (dots != 0)
	{
	  size_t len = strlen (res) + 1;
	  char *add_dots = xmalloc (len + dots);

	  memcpy (add_dots, name, dots);
	  memcpy (add_dots + dots, res, len);
	  free (res);
	  res = add_dots;
	}
      return res;
    }
  return xstrdup (name);
}

d412 6
a417 1
info_msg VPARAMS ((const char *fmt, ...))
d419 10
a428 2
  VA_OPEN (arg, fmt);
  VA_FIXEDARG (arg, const char *, fmt);
d431 1
a431 1
  VA_CLOSE (arg);
d437 6
a442 1
einfo VPARAMS ((const char *fmt, ...))
d444 10
a453 2
  VA_OPEN (arg, fmt);
  VA_FIXEDARG (arg, const char *, fmt);
d456 1
a456 1
  VA_CLOSE (arg);
d470 6
a475 1
minfo VPARAMS ((const char *fmt, ...))
d477 9
a485 2
  VA_OPEN (arg, fmt);
  VA_FIXEDARG (arg, const char *, fmt);
d488 1
a488 1
  VA_CLOSE (arg);
d492 6
a497 1
lfinfo VPARAMS ((FILE *file, const char *fmt, ...))
d499 12
a510 3
  VA_OPEN (arg, fmt);
  VA_FIXEDARG (arg, FILE *, file);
  VA_FIXEDARG (arg, const char *, fmt);
d513 1
a513 1
  VA_CLOSE (arg);
a546 11
}

bfd_boolean
error_handler VPARAMS ((int id ATTRIBUTE_UNUSED, const char *fmt, ...))
{
  VA_OPEN (arg, fmt);
  VA_FIXEDARG (arg, const char *, fmt);

  vfinfo (stderr, fmt, arg);
  VA_CLOSE (arg);
  return TRUE;
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@a24 1
#include "bfdlink.h"
d28 2
d31 4
d44 2
d69 4
a72 1
vfinfo (FILE *fp, const char *fmt, va_list arg)
d128 1
a128 1
		 8 spaces.  */
d156 1
a156 1
		if (name == NULL || *name == 0)
d271 1
a271 1
		    asymbols = xmalloc (symsize);
d380 2
a381 1
demangle (const char *name)
d422 1
a422 1
   would be hosed by LynxOS, which defines that name in its libc.)  */
d425 1
a425 1
info_msg (const char *fmt, ...)
d427 2
a428 1
  va_list arg;
a429 1
  va_start (arg, fmt);
d431 1
a431 1
  va_end (arg);
d437 1
a437 1
einfo (const char *fmt, ...)
d439 2
a440 1
  va_list arg;
a441 1
  va_start (arg, fmt);
d443 1
a443 1
  va_end (arg);
d447 3
a449 1
info_assert (const char *file, unsigned int line)
d457 1
a457 1
minfo (const char *fmt, ...)
d459 2
a460 1
  va_list arg;
a461 1
  va_start (arg, fmt);
d463 1
a463 1
  va_end (arg);
d467 1
a467 1
lfinfo (FILE *file, const char *fmt, ...)
d469 3
a471 1
  va_list arg;
a472 1
  va_start (arg, fmt);
d474 1
a474 1
  va_end (arg);
d480 1
a480 1
print_space (void)
d486 1
a486 1
print_nl (void)
d495 4
a498 1
ld_abort (const char *file, int line, const char *fn)
d511 1
a511 1
error_handler (int id, const char *fmt, ...)
d513 2
a514 8
  va_list arg;

  va_start (arg, fmt);

  switch (id)
    {
    default:
      break;
a515 42
    /* We can be called with

	error_handler (-LD_DEFINITION_IN_DISCARDED_SECTION, "", 0);

	to make this error non-fatal and

	error_handler (-LD_DEFINITION_IN_DISCARDED_SECTION, "", 1);

	to make this error fatal.  */
    case -LD_DEFINITION_IN_DISCARDED_SECTION:
    case LD_DEFINITION_IN_DISCARDED_SECTION:
      {
	static struct bfd_hash_table *hash;
	static int fatal = 1;
	const char *name;

	if (id == -LD_DEFINITION_IN_DISCARDED_SECTION)
	  {
	    fatal = va_arg (arg, int);
	    goto out;
	  }

	name = va_arg (arg, const char *);
	/* Only warn once about a particular undefined symbol.  */
	if (hash == NULL)
	  {
	    hash = xmalloc (sizeof (struct bfd_hash_table));
	    if (! bfd_hash_table_init (hash, bfd_hash_newfunc))
	      einfo (_("%F%P: bfd_hash_table_init failed: %E\n"));
	  }

	if (bfd_hash_lookup (hash, name, FALSE, FALSE) != NULL)
	  goto out;

	if (bfd_hash_lookup (hash, name, TRUE, TRUE) == NULL)
	  einfo (_("%F%P: bfd_hash_lookup failed: %E\n"));

	if (fatal)
	  config.make_executable = FALSE;
      }
      break;
    }
d517 1
a517 3

out:
  va_end (arg);
@


