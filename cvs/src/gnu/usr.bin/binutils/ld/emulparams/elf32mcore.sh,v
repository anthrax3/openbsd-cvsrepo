head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.4.0.50
	OPENBSD_6_1_BASE:1.1.1.4
	OPENBSD_6_0:1.1.1.4.0.48
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.44
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.46
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.38
	OPENBSD_5_7_BASE:1.1.1.4
	OPENBSD_5_6:1.1.1.4.0.42
	OPENBSD_5_6_BASE:1.1.1.4
	OPENBSD_5_5:1.1.1.4.0.40
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.36
	OPENBSD_5_4_BASE:1.1.1.4
	OPENBSD_5_3:1.1.1.4.0.34
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.32
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.30
	OPENBSD_5_0:1.1.1.4.0.28
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.26
	OPENBSD_4_9_BASE:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.24
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.20
	OPENBSD_4_7_BASE:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.22
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.18
	OPENBSD_4_5_BASE:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.16
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.14
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.12
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.10
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.8
	OPENBSD_4_0_BASE:1.1.1.4
	OPENBSD_3_9:1.1.1.4.0.6
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.4
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.2
	OPENBSD_3_7_BASE:1.1.1.4
	BINUTILS_2_15:1.1.1.4
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	BINUTILS-2_14:1.1.1.3
	OPENBSD_3_5:1.1.1.2.0.8
	OPENBSD_3_5_BASE:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.6
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.4
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.2
	OPENBSD_3_2_BASE:1.1.1.2
	binutils-2_11_2:1.1.1.2
	OPENBSD_3_1:1.1.1.1.0.8
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.6
	OPENBSD_3_0_BASE:1.1.1.1
	BINUTILS-2_10_1:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.4
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.2
	OPENBSD_2_8_BASE:1.1.1.1
	BINUTILS-2_10:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2000.09.12.14.48.14;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.09.12.14.48.14;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.05.13.14.01.37;	author fgsch;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.05.17.20.42.51;	author drahn;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.11.02.20.23.24;	author miod;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@SCRIPT_NAME=elf
OUTPUT_FORMAT="elf32-mcore-little"
BIG_OUTPUT_FORMAT="elf32-mcore-big"
LITTLE_OUTPUT_FORMAT="elf32-mcore-little"
PAGE_SIZE=0x1000
TARGET_PAGE_SIZE=0x400
MAXPAGESIZE=0x1000
TEXT_START_ADDR=0
NONPAGED_TEXT_START_ADDR=0
ARCH=mcore
EMBEDDED=yes

# There is a problem with the NOP value - it must work for both
# big endian and little endian systems.  Unfortunately there is
# no symmetrical mcore opcode that functions as a noop.  The
# chosen solution is to use "tst r0, r14".  This is a symetrical
# value, and apart from the corruption of the C bit, it has no other
# side effects.  Since the carry bit is never tested without being
# explicitly set first, and since the NOP code is only used as a
# fill value between independantly viable peices of code, it should
# not matter.
NOP=0x0e0e

OTHER_BSS_SYMBOLS="__bss_start__ = . ;"
OTHER_BSS_END_SYMBOLS="__bss_end__ = . ;"

# Hmmm, there's got to be a better way.  This sets the stack to the
# top of the simulator memory (2^19 bytes).
OTHER_RELOCATING_SECTIONS='.stack 0x80000 : { _stack = .; *(.stack) }'

TEMPLATE_NAME=elf32
GENERATE_SHLIB_SCRIPT=yes

# This code gets inserted into the generic elf32.sc linker script
# and allows us to define our own command line switches.
PARSE_AND_LIST_ARGS='

#define OPTION_BASE_FILE		300

#include "getopt.h"

static struct option longopts[] =
{
  {"base-file", required_argument, NULL, OPTION_BASE_FILE},
  {NULL, no_argument, NULL, 0}
};

static void
gld_elf32mcore_list_options (file)
     FILE * file;
{
  fprintf (file, _("  --base_file <basefile>      Generate a base file for relocatable DLLs\n"));
}

static int
gld_elf32mcore_parse_args (argc, argv)
     int argc;
     char ** argv;
{
  int        longind;
  int        optc;
  int        prevoptind = optind;
  int        prevopterr = opterr;
  int        wanterror;
  static int lastoptind = -1;

  if (lastoptind != optind)
    opterr = 0;
  
  wanterror  = opterr;
  lastoptind = optind;

  optc   = getopt_long_only (argc, argv, "-", longopts, & longind);
  opterr = prevopterr;

  switch (optc)
    {
    default:
      if (wanterror)
	xexit (1);
      optind =  prevoptind;
      return 0;

    case OPTION_BASE_FILE:
      link_info.base_file = (PTR) fopen (optarg, FOPEN_WB);
      if (link_info.base_file == NULL)
	{
	  /* xgettext:c-format */
	  fprintf (stderr, _("%s: Cannot open base file %s\n"),
		   program_name, optarg);
	  xexit (1);
	}
      break;
    }
  
  return 1;
}

'
@


1.1.1.1
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@@


1.1.1.2
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d36 2
a37 1
PARSE_AND_LIST_PROLOGUE='
a38 1
'
d40 4
a43 1
PARSE_AND_LIST_LONGOPTS='
d45 21
a65 1
'
d67 16
a82 4
PARSE_AND_LIST_OPTIONS='
  fprintf (file, _("  --base_file <basefile>\n"));
  fprintf (file, _("\t\t\tGenerate a base file for relocatable DLLs\n"));
'
a83 1
PARSE_AND_LIST_ARGS_CASES='
d94 5
@


1.1.1.3
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d22 1
a22 1
NOP=0x0e0e0e0e
d27 3
a29 2
# This sets the stack to the top of the simulator memory (2^19 bytes).
STACK_ADDR=0x80000
@


1.1.1.4
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d50 1
a50 1
      link_info.base_file = fopen (optarg, FOPEN_WB);
@


