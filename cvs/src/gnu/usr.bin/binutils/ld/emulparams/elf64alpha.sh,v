head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.52
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.5
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.2.0.6
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.1.1.2.0.16
	OPENBSD_2_8_BASE:1.1.1.2
	BINUTILS-2_10:1.1.1.2
	FSF:1.1.1
	OPENBSD_2_7:1.1.1.2.0.14
	OPENBSD_2_7_BASE:1.1.1.2
	new-binutils:1.1.1.2.0.12
	OPENBSD_2_6:1.1.1.2.0.10
	OPENBSD_2_6_BASE:1.1.1.2
	OPENBSD_2_5:1.1.1.2.0.8
	OPENBSD_2_5_BASE:1.1.1.2
	OPENBSD_2_4:1.1.1.2.0.6
	OPENBSD_2_4_BASE:1.1.1.2
	OPENBSD_2_3:1.1.1.2.0.4
	OPENBSD_2_3_BASE:1.1.1.2
	OPENBSD_2_2:1.1.1.2.0.2
	OPENBSD_2_2_BASE:1.1.1.2
	BINUTILS-2_8_1:1.1.1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@# @;


1.8
date	2004.11.02.20.45.49;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.50;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.17.03.44.30;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.30.21.06.47;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.17.20.50.13;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.43;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.07.07.26.03;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.04.17.35.23;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.04.17.35.23;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.05.29.09.28.52;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.14.01.37;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.51;	author drahn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.11.02.20.23.24;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@ENTRY=_start
SCRIPT_NAME=elf
ELFSIZE=64
TEMPLATE_NAME=elf32
EXTRA_EM_FILE=alphaelf
OUTPUT_FORMAT="elf64-alpha"
TEXT_START_ADDR="0x120000000"
MAXPAGESIZE=0x10000
COMMONPAGESIZE=0x2000
NONPAGED_TEXT_START_ADDR="0x120000000"
ARCH=alpha
MACHINE=
GENERATE_SHLIB_SCRIPT=yes
GENERATE_PIE_SCRIPT=yes
DATA_PLT=
# Note that the number is always big-endian, thus we have to 
# reverse the digit string.
NOP=0x0000fe2f1f04ff47		# unop; nop

OTHER_READONLY_SECTIONS="
  .reginfo      ${RELOCATING-0} : { *(.reginfo) }"
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d14 1
@


1.6
log
@Switch i386 to new binutils, i386 tools now do ELF.
RODATA_* align macros to preserve current behavior on other
archs and allow for 1G sep between beginning of exe and beginning of data
DARPA funded work.
@
text
@d5 1
d9 1
d15 3
a17 6
PAD_RO=
RODATA_PADSIZE=${MAXPAGESIZE}
RODATA_ALIGN=". = ALIGN(${RODATA_PADSIZE}) + (. & (${RODATA_PADSIZE} - 1))"
PAD_GOT=
PAD_PLT=
NOP=0x47ff041f
d19 2
a20 52
OTHER_READONLY_SECTIONS='.reginfo : { *(.reginfo) }'

# This code gets inserted into the generic elf32.sc linker script
# and allows us to define our own command line switches.
PARSE_AND_LIST_PROLOGUE='
#define OPTION_TASO            300
/* Set the start address as in the Tru64 ld */
#define ALPHA_TEXT_START_32BIT 0x12000000

static int elf64alpha_32bit = 0;

struct ld_emulation_xfer_struct ld_elf64alpha_emulation;
static void gld_elf64alpha_finish ();
'

PARSE_AND_LIST_LONGOPTS='
  {"taso", no_argument, NULL, OPTION_TASO},
'

PARSE_AND_LIST_OPTIONS='
  fprintf (file, _("  -taso\t\t\tLoad executable in the lower 31-bit addressable\n"));
  fprintf (file, _("\t\t\t  virtual address range\n"));
'

PARSE_AND_LIST_ARGS_CASES='
    case EOF:
      if (elf64alpha_32bit && !link_info.shared && !link_info.relocateable)
	{
	  lang_section_start (".interp",
			      exp_binop ('\''+'\'',
					 exp_intop (ALPHA_TEXT_START_32BIT),
					 exp_nameop (SIZEOF_HEADERS, NULL)));
	  ld_elf64alpha_emulation.finish = gld_elf64alpha_finish;
	}
      return 0;

    case OPTION_TASO:
      elf64alpha_32bit = 1;
      break;
'

PARSE_AND_LIST_EPILOGUE='
#include "elf/internal.h"
#include "elf/alpha.h"
#include "elf-bfd.h"

static void
gld_elf64alpha_finish()
{
  elf_elfheader (output_bfd)->e_flags |= EF_ALPHA_32BIT;
}
'
@


1.5
log
@ELF security enhancement: put .rodata into it's own load section instead
of putting it with the text. This removes the execute permission
from readonly data. This constrains the executable region to portions
of the executable which need to be executable. Note: not all processors
or mmus are capable of -X protection at the page level, but should
handle ELF images which specify specific RWX protections on each section.
@
text
@d14 2
@


1.4
log
@This is a project to modify executables so that they do not have any
executable regions which are writable. If a section of an executable is
writable and executable, it is much easier for errant code to modify the
executable's behavior.

Two current areas in shared library environments which have this
critical problem are the GOT (Global Offset Table) and PLT (Procedure
Linkage Table). The PLT is required to be executable and both GOT and
PLT are writable on most architectures. On most ELF architecture
machines this would cause shared libraries to have data and BSS marked
as executable.

Padding to the linker script for programs and shared libraries/objects
to isolate the GOT and PLT into their own load sections in the
executables. This allows only the text(readonly) region and the PLT
region to be marked executable with the normal data and BSS not marked
as executable. The PLT region is still marked executable on most
architectures because the PLT lives in the "data" or "BSS" regions
and the dynamic loader will need to modify it. Since the GOT and PLT
should only ever be written by the dynamic linker, it will be modified
to mprotect those regions so that they are not writable during normal
execution. If the dynamic linker needs to modify the regions later,
(eg for lazy binding), it will mprotect the region, make the necessary
changes, and mprotect it back. Since it is possible to receive a
signal which would interrupt the program flow and perhaps cause the
dynamic linker to modify the same (or nearby) PLT references, it is now
necessary for signals to be blocked for the duration of the mprotect.
@
text
@d13 1
@


1.3
log
@resolve conflicts.
@
text
@d13 2
@


1.2
log
@Revert my bfd change, and instead make ld match bfd, which is
the way Red hat choose.  Both ways work, the important thing is that
things match.  However if we use the red hat solution we will not need
to merge local changes when importing new binutils releases; espie made
me aware of the import issues which I forgot due to lack of sleep :-).
@
text
@d1 1
a1 1
ENTRY=__start
d16 51
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
MAXPAGESIZE=0x100000
d10 1
@


1.1.1.1
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@@


1.1.1.2
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@a9 1
MACHINE=
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d1 1
a1 1
ENTRY=_start
d7 1
a7 1
MAXPAGESIZE=0x10000
a15 51

# This code gets inserted into the generic elf32.sc linker script
# and allows us to define our own command line switches.
PARSE_AND_LIST_PROLOGUE='
#define OPTION_TASO            300
/* Set the start address as in the Tru64 ld */
#define ALPHA_TEXT_START_32BIT 0x12000000

static int elf64alpha_32bit = 0;

struct ld_emulation_xfer_struct ld_elf64alpha_emulation;
static void gld_elf64alpha_finish ();
'

PARSE_AND_LIST_LONGOPTS='
  {"taso", no_argument, NULL, OPTION_TASO},
'

PARSE_AND_LIST_OPTIONS='
  fprintf (file, _("  -taso\t\t\tLoad executable in the lower 31-bit addressable\n"));
  fprintf (file, _("\t\t\t  virtual address range\n"));
'

PARSE_AND_LIST_ARGS_CASES='
    case EOF:
      if (elf64alpha_32bit && !link_info.shared && !link_info.relocateable)
	{
	  lang_section_start (".interp",
			      exp_binop ('\''+'\'',
					 exp_intop (ALPHA_TEXT_START_32BIT),
					 exp_nameop (SIZEOF_HEADERS, NULL)));
	  ld_elf64alpha_emulation.finish = gld_elf64alpha_finish;
	}
      return 0;

    case OPTION_TASO:
      elf64alpha_32bit = 1;
      break;
'

PARSE_AND_LIST_EPILOGUE='
#include "elf/internal.h"
#include "elf/alpha.h"
#include "elf-bfd.h"

static void
gld_elf64alpha_finish()
{
  elf_elfheader (output_bfd)->e_flags |= EF_ALPHA_32BIT;
}
'
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@a4 1
EXTRA_EM_FILE=alphaelf
a7 1
COMMONPAGESIZE=0x2000
d13 1
a13 3
# Note that the number is always big-endian, thus we have to 
# reverse the digit string.
NOP=0x0000fe2f1f04ff47		# unop; nop
d15 52
a66 2
OTHER_READONLY_SECTIONS="
  .reginfo      ${RELOCATING-0} : { *(.reginfo) }"
@


1.1.1.5
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@a13 1
GENERATE_PIE_SCRIPT=yes
@


