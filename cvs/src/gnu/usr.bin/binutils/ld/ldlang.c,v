head	1.9;
access;
symbols
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.52
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.48
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.44
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.46
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.38
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.42
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.40
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.36
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.34
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.32
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.30
	OPENBSD_5_0:1.9.0.28
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.26
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.24
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.20
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.22
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.18
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.16
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.14
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.12
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	BINUTILS_2_15:1.1.1.10
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	BINUTILS-2_14:1.1.1.9
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	binutils-2_11_2:1.1.1.8
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	BINUTILS-2_10_1:1.1.1.7
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2004.11.02.20.45.47;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.17.21.54.50;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.13.17.07.42;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.09.22.29.40;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.12.44;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.52.30;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.09.24;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.54.19;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.15;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.15;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.35.31;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.34.57;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.38.38;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.28.30;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.48.08;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2001.06.09.22.08.51;	author espie;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2002.05.13.14.01.04;	author fgsch;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.05.17.20.42.49;	author drahn;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.11.02.20.23.21;	author miod;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* Linker command language support.
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2004
   Free Software Foundation, Inc.

   This file is part of GLD, the Gnu Linker.

   GLD is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GLD is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GLD; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "libiberty.h"
#include "safe-ctype.h"
#include "obstack.h"
#include "bfdlink.h"

#include "ld.h"
#include "ldmain.h"
#include "ldexp.h"
#include "ldlang.h"
#include <ldgram.h>
#include "ldlex.h"
#include "ldmisc.h"
#include "ldctor.h"
#include "ldfile.h"
#include "ldemul.h"
#include "fnmatch.h"
#include "demangle.h"
#include "hashtab.h"

#ifndef offsetof
#define offsetof(TYPE, MEMBER) ((size_t) & (((TYPE*) 0)->MEMBER))
#endif

/* Locals variables.  */
static struct obstack stat_obstack;

#define obstack_chunk_alloc xmalloc
#define obstack_chunk_free free
static const char *startup_file;
static lang_statement_list_type input_file_chain;
static bfd_boolean placed_commons = FALSE;
static lang_output_section_statement_type *default_common_section;
static bfd_boolean map_option_f;
static bfd_vma print_dot;
static lang_input_statement_type *first_file;
static const char *current_target;
static const char *output_target;
static lang_statement_list_type statement_list;
static struct lang_phdr *lang_phdr_list;
static struct bfd_hash_table lang_definedness_table;

/* Forward declarations.  */
static void exp_init_os (etree_type *);
static bfd_boolean wildcardp (const char *);
static lang_input_statement_type *lookup_name (const char *);
static bfd_boolean load_symbols (lang_input_statement_type *,
				 lang_statement_list_type *);
static struct bfd_hash_entry *lang_definedness_newfunc
 (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
static void insert_undefined (const char *);
static void print_statement (lang_statement_union_type *,
			     lang_output_section_statement_type *);
static void print_statement_list (lang_statement_union_type *,
				  lang_output_section_statement_type *);
static void print_statements (void);
static bfd_boolean lang_one_common (struct bfd_link_hash_entry *, void *);
static void lang_record_phdrs (void);
static void lang_do_version_exports_section (void);

typedef void (*callback_t) (lang_wild_statement_type *, struct wildcard_list *,
			    asection *, lang_input_statement_type *, void *);

/* Exported variables.  */
lang_output_section_statement_type *abs_output_section;
lang_statement_list_type lang_output_section_statement;
lang_statement_list_type *stat_ptr = &statement_list;
lang_statement_list_type file_chain = { NULL, NULL };
struct bfd_sym_chain entry_symbol = { NULL, NULL };
const char *entry_section = ".text";
bfd_boolean entry_from_cmdline;
bfd_boolean lang_has_input_file = FALSE;
bfd_boolean had_output_filename = FALSE;
bfd_boolean lang_float_flag = FALSE;
bfd_boolean delete_output_file_on_failure = FALSE;
struct lang_nocrossrefs *nocrossref_list;
struct unique_sections *unique_section_list;
static bfd_boolean ldlang_sysrooted_script = FALSE;
int lang_statement_iteration = 0;

etree_type *base; /* Relocation base - or null */

#define new_stat(x, y) \
  (x##_type *) new_statement (x##_enum, sizeof (x##_type), y)

#define outside_section_address(q) \
  ((q)->output_offset + (q)->output_section->vma)

#define outside_symbol_address(q) \
  ((q)->value + outside_section_address (q->section))

#define SECTION_NAME_MAP_LENGTH (16)

void *
stat_alloc (size_t size)
{
  return obstack_alloc (&stat_obstack, size);
}

bfd_boolean
unique_section_p (const char *secnam)
{
  struct unique_sections *unam;

  for (unam = unique_section_list; unam; unam = unam->next)
    if (wildcardp (unam->name)
	? fnmatch (unam->name, secnam, 0) == 0
	: strcmp (unam->name, secnam) == 0)
      {
	return TRUE;
      }

  return FALSE;
}

/* Generic traversal routines for finding matching sections.  */

static void
walk_wild_section (lang_wild_statement_type *ptr,
		   lang_input_statement_type *file,
		   callback_t callback,
		   void *data)
{
  asection *s;

  if (file->just_syms_flag)
    return;

  for (s = file->the_bfd->sections; s != NULL; s = s->next)
    {
      struct wildcard_list *sec;

      sec = ptr->section_list;
      if (sec == NULL)
	(*callback) (ptr, sec, s, file, data);

      while (sec != NULL)
	{
	  bfd_boolean skip = FALSE;
	  struct name_list *list_tmp;

	  /* Don't process sections from files which were
	     excluded.  */
	  for (list_tmp = sec->spec.exclude_name_list;
	       list_tmp;
	       list_tmp = list_tmp->next)
	    {
	      if (wildcardp (list_tmp->name))
		skip = fnmatch (list_tmp->name, file->filename, 0) == 0;
	      else
		skip = strcmp (list_tmp->name, file->filename) == 0;

	      /* If this file is part of an archive, and the archive is
		 excluded, exclude this file.  */
	      if (! skip && file->the_bfd != NULL
		  && file->the_bfd->my_archive != NULL
		  && file->the_bfd->my_archive->filename != NULL)
		{
		  if (wildcardp (list_tmp->name))
		    skip = fnmatch (list_tmp->name,
				    file->the_bfd->my_archive->filename,
				    0) == 0;
		  else
		    skip = strcmp (list_tmp->name,
				   file->the_bfd->my_archive->filename) == 0;
		}

	      if (skip)
		break;
	    }

	  if (!skip && sec->spec.name != NULL)
	    {
	      const char *sname = bfd_get_section_name (file->the_bfd, s);

	      if (wildcardp (sec->spec.name))
		skip = fnmatch (sec->spec.name, sname, 0) != 0;
	      else
		skip = strcmp (sec->spec.name, sname) != 0;
	    }

	  if (!skip)
	    (*callback) (ptr, sec, s, file, data);

	  sec = sec->next;
	}
    }
}

/* Handle a wild statement for a single file F.  */

static void
walk_wild_file (lang_wild_statement_type *s,
		lang_input_statement_type *f,
		callback_t callback,
		void *data)
{
  if (f->the_bfd == NULL
      || ! bfd_check_format (f->the_bfd, bfd_archive))
    walk_wild_section (s, f, callback, data);
  else
    {
      bfd *member;

      /* This is an archive file.  We must map each member of the
	 archive separately.  */
      member = bfd_openr_next_archived_file (f->the_bfd, NULL);
      while (member != NULL)
	{
	  /* When lookup_name is called, it will call the add_symbols
	     entry point for the archive.  For each element of the
	     archive which is included, BFD will call ldlang_add_file,
	     which will set the usrdata field of the member to the
	     lang_input_statement.  */
	  if (member->usrdata != NULL)
	    {
	      walk_wild_section (s, member->usrdata, callback, data);
	    }

	  member = bfd_openr_next_archived_file (f->the_bfd, member);
	}
    }
}

static void
walk_wild (lang_wild_statement_type *s, callback_t callback, void *data)
{
  const char *file_spec = s->filename;

  if (file_spec == NULL)
    {
      /* Perform the iteration over all files in the list.  */
      LANG_FOR_EACH_INPUT_STATEMENT (f)
	{
	  walk_wild_file (s, f, callback, data);
	}
    }
  else if (wildcardp (file_spec))
    {
      LANG_FOR_EACH_INPUT_STATEMENT (f)
	{
	  if (fnmatch (file_spec, f->filename, FNM_FILE_NAME) == 0)
	    walk_wild_file (s, f, callback, data);
	}
    }
  else
    {
      lang_input_statement_type *f;

      /* Perform the iteration over a single file.  */
      f = lookup_name (file_spec);
      if (f)
	walk_wild_file (s, f, callback, data);
    }
}

/* lang_for_each_statement walks the parse tree and calls the provided
   function for each node.  */

static void
lang_for_each_statement_worker (void (*func) (lang_statement_union_type *),
				lang_statement_union_type *s)
{
  for (; s != NULL; s = s->header.next)
    {
      func (s);

      switch (s->header.type)
	{
	case lang_constructors_statement_enum:
	  lang_for_each_statement_worker (func, constructor_list.head);
	  break;
	case lang_output_section_statement_enum:
	  lang_for_each_statement_worker
	    (func,
	     s->output_section_statement.children.head);
	  break;
	case lang_wild_statement_enum:
	  lang_for_each_statement_worker
	    (func,
	     s->wild_statement.children.head);
	  break;
	case lang_group_statement_enum:
	  lang_for_each_statement_worker (func,
					  s->group_statement.children.head);
	  break;
	case lang_data_statement_enum:
	case lang_reloc_statement_enum:
	case lang_object_symbols_statement_enum:
	case lang_output_statement_enum:
	case lang_target_statement_enum:
	case lang_input_section_enum:
	case lang_input_statement_enum:
	case lang_assignment_statement_enum:
	case lang_padding_statement_enum:
	case lang_address_statement_enum:
	case lang_fill_statement_enum:
	  break;
	default:
	  FAIL ();
	  break;
	}
    }
}

void
lang_for_each_statement (void (*func) (lang_statement_union_type *))
{
  lang_for_each_statement_worker (func, statement_list.head);
}

/*----------------------------------------------------------------------*/

void
lang_list_init (lang_statement_list_type *list)
{
  list->head = NULL;
  list->tail = &list->head;
}

/* Build a new statement node for the parse tree.  */

static lang_statement_union_type *
new_statement (enum statement_enum type,
	       size_t size,
	       lang_statement_list_type *list)
{
  lang_statement_union_type *new;

  new = stat_alloc (size);
  new->header.type = type;
  new->header.next = NULL;
  lang_statement_append (list, new, &new->header.next);
  return new;
}

/* Build a new input file node for the language.  There are several
   ways in which we treat an input file, eg, we only look at symbols,
   or prefix it with a -l etc.

   We can be supplied with requests for input files more than once;
   they may, for example be split over several lines like foo.o(.text)
   foo.o(.data) etc, so when asked for a file we check that we haven't
   got it already so we don't duplicate the bfd.  */

static lang_input_statement_type *
new_afile (const char *name,
	   lang_input_file_enum_type file_type,
	   const char *target,
	   bfd_boolean add_to_list)
{
  lang_input_statement_type *p;

  if (add_to_list)
    p = new_stat (lang_input_statement, stat_ptr);
  else
    {
      p = stat_alloc (sizeof (lang_input_statement_type));
      p->header.next = NULL;
    }

  lang_has_input_file = TRUE;
  p->target = target;
  p->sysrooted = FALSE;
  switch (file_type)
    {
    case lang_input_file_is_symbols_only_enum:
      p->filename = name;
      p->is_archive = FALSE;
      p->real = TRUE;
      p->local_sym_name = name;
      p->just_syms_flag = TRUE;
      p->search_dirs_flag = FALSE;
      break;
    case lang_input_file_is_fake_enum:
      p->filename = name;
      p->is_archive = FALSE;
      p->real = FALSE;
      p->local_sym_name = name;
      p->just_syms_flag = FALSE;
      p->search_dirs_flag = FALSE;
      break;
    case lang_input_file_is_l_enum:
      p->is_archive = TRUE;
      p->filename = name;
      p->real = TRUE;
      p->local_sym_name = concat ("-l", name, NULL);
      p->just_syms_flag = FALSE;
      p->search_dirs_flag = TRUE;
      break;
    case lang_input_file_is_marker_enum:
      p->filename = name;
      p->is_archive = FALSE;
      p->real = FALSE;
      p->local_sym_name = name;
      p->just_syms_flag = FALSE;
      p->search_dirs_flag = TRUE;
      break;
    case lang_input_file_is_search_file_enum:
      p->sysrooted = ldlang_sysrooted_script;
      p->filename = name;
      p->is_archive = FALSE;
      p->real = TRUE;
      p->local_sym_name = name;
      p->just_syms_flag = FALSE;
      p->search_dirs_flag = TRUE;
      break;
    case lang_input_file_is_file_enum:
      p->filename = name;
      p->is_archive = FALSE;
      p->real = TRUE;
      p->local_sym_name = name;
      p->just_syms_flag = FALSE;
      p->search_dirs_flag = FALSE;
      break;
    default:
      FAIL ();
    }
  p->the_bfd = NULL;
  p->asymbols = NULL;
  p->next_real_file = NULL;
  p->next = NULL;
  p->symbol_count = 0;
  p->dynamic = config.dynamic_link;
  p->as_needed = as_needed;
  p->whole_archive = whole_archive;
  p->loaded = FALSE;
  lang_statement_append (&input_file_chain,
			 (lang_statement_union_type *) p,
			 &p->next_real_file);
  return p;
}

lang_input_statement_type *
lang_add_input_file (const char *name,
		     lang_input_file_enum_type file_type,
		     const char *target)
{
  lang_has_input_file = TRUE;
  return new_afile (name, file_type, target, TRUE);
}

/* Build enough state so that the parser can build its tree.  */

void
lang_init (void)
{
  obstack_begin (&stat_obstack, 1000);

  stat_ptr = &statement_list;

  lang_list_init (stat_ptr);

  lang_list_init (&input_file_chain);
  lang_list_init (&lang_output_section_statement);
  lang_list_init (&file_chain);
  first_file = lang_add_input_file (NULL, lang_input_file_is_marker_enum,
				    NULL);
  abs_output_section =
    lang_output_section_statement_lookup (BFD_ABS_SECTION_NAME);

  abs_output_section->bfd_section = bfd_abs_section_ptr;

  /* The value "3" is ad-hoc, somewhat related to the expected number of
     DEFINED expressions in a linker script.  For most default linker
     scripts, there are none.  Why a hash table then?  Well, it's somewhat
     simpler to re-use working machinery than using a linked list in terms
     of code-complexity here in ld, besides the initialization which just
     looks like other code here.  */
  if (bfd_hash_table_init_n (&lang_definedness_table,
			     lang_definedness_newfunc, 3) != TRUE)
    einfo (_("%P%F: out of memory during initialization"));

  /* Callers of exp_fold_tree need to increment this.  */
  lang_statement_iteration = 0;
}

/*----------------------------------------------------------------------
  A region is an area of memory declared with the
  MEMORY {  name:org=exp, len=exp ... }
  syntax.

  We maintain a list of all the regions here.

  If no regions are specified in the script, then the default is used
  which is created when looked up to be the entire data space.

  If create is true we are creating a region inside a MEMORY block.
  In this case it is probably an error to create a region that has
  already been created.  If we are not inside a MEMORY block it is
  dubious to use an undeclared region name (except DEFAULT_MEMORY_REGION)
  and so we issue a warning.  */

static lang_memory_region_type *lang_memory_region_list;
static lang_memory_region_type **lang_memory_region_list_tail = &lang_memory_region_list;

lang_memory_region_type *
lang_memory_region_lookup (const char *const name, bfd_boolean create)
{
  lang_memory_region_type *p;
  lang_memory_region_type *new;

  /* NAME is NULL for LMA memspecs if no region was specified.  */
  if (name == NULL)
    return NULL;

  for (p = lang_memory_region_list; p != NULL; p = p->next)
    if (strcmp (p->name, name) == 0)
      {
	if (create)
	  einfo (_("%P:%S: warning: redeclaration of memory region '%s'\n"), name);
	return p;
      }

#if 0
  /* This code used to always use the first region in the list as the
     default region.  I changed it to instead use a region
     encompassing all of memory as the default region.  This permits
     NOLOAD sections to work reasonably without requiring a region.
     People should specify what region they mean, if they really want
     a region.  */
  if (strcmp (name, DEFAULT_MEMORY_REGION) == 0)
    {
      if (lang_memory_region_list != NULL)
	return lang_memory_region_list;
    }
#endif

  if (!create && strcmp (name, DEFAULT_MEMORY_REGION))
    einfo (_("%P:%S: warning: memory region %s not declared\n"), name);

  new = stat_alloc (sizeof (lang_memory_region_type));

  new->name = xstrdup (name);
  new->next = NULL;

  *lang_memory_region_list_tail = new;
  lang_memory_region_list_tail = &new->next;
  new->origin = 0;
  new->flags = 0;
  new->not_flags = 0;
  new->length = ~(bfd_size_type) 0;
  new->current = 0;
  new->had_full_message = FALSE;

  return new;
}

static lang_memory_region_type *
lang_memory_default (asection *section)
{
  lang_memory_region_type *p;

  flagword sec_flags = section->flags;

  /* Override SEC_DATA to mean a writable section.  */
  if ((sec_flags & (SEC_ALLOC | SEC_READONLY | SEC_CODE)) == SEC_ALLOC)
    sec_flags |= SEC_DATA;

  for (p = lang_memory_region_list; p != NULL; p = p->next)
    {
      if ((p->flags & sec_flags) != 0
	  && (p->not_flags & sec_flags) == 0)
	{
	  return p;
	}
    }
  return lang_memory_region_lookup (DEFAULT_MEMORY_REGION, FALSE);
}

lang_output_section_statement_type *
lang_output_section_find (const char *const name)
{
  lang_statement_union_type *u;
  lang_output_section_statement_type *lookup;

  for (u = lang_output_section_statement.head; u != NULL; u = lookup->next)
    {
      lookup = &u->output_section_statement;
      if (strcmp (name, lookup->name) == 0)
	return lookup;
    }
  return NULL;
}

lang_output_section_statement_type *
lang_output_section_statement_lookup (const char *const name)
{
  lang_output_section_statement_type *lookup;

  lookup = lang_output_section_find (name);
  if (lookup == NULL)
    {
      lookup = new_stat (lang_output_section_statement, stat_ptr);
      lookup->region = NULL;
      lookup->lma_region = NULL;
      lookup->fill = 0;
      lookup->block_value = 1;
      lookup->name = name;

      lookup->next = NULL;
      lookup->bfd_section = NULL;
      lookup->processed = 0;
      lookup->sectype = normal_section;
      lookup->addr_tree = NULL;
      lang_list_init (&lookup->children);

      lookup->memspec = NULL;
      lookup->flags = 0;
      lookup->subsection_alignment = -1;
      lookup->section_alignment = -1;
      lookup->load_base = NULL;
      lookup->update_dot_tree = NULL;
      lookup->phdrs = NULL;

      lang_statement_append (&lang_output_section_statement,
			     (lang_statement_union_type *) lookup,
			     &lookup->next);
    }
  return lookup;
}

static void
lang_map_flags (flagword flag)
{
  if (flag & SEC_ALLOC)
    minfo ("a");

  if (flag & SEC_CODE)
    minfo ("x");

  if (flag & SEC_READONLY)
    minfo ("r");

  if (flag & SEC_DATA)
    minfo ("w");

  if (flag & SEC_LOAD)
    minfo ("l");
}

void
lang_map (void)
{
  lang_memory_region_type *m;

  minfo (_("\nMemory Configuration\n\n"));
  fprintf (config.map_file, "%-16s %-18s %-18s %s\n",
	   _("Name"), _("Origin"), _("Length"), _("Attributes"));

  for (m = lang_memory_region_list; m != NULL; m = m->next)
    {
      char buf[100];
      int len;

      fprintf (config.map_file, "%-16s ", m->name);

      sprintf_vma (buf, m->origin);
      minfo ("0x%s ", buf);
      len = strlen (buf);
      while (len < 16)
	{
	  print_space ();
	  ++len;
	}

      minfo ("0x%V", m->length);
      if (m->flags || m->not_flags)
	{
#ifndef BFD64
	  minfo ("        ");
#endif
	  if (m->flags)
	    {
	      print_space ();
	      lang_map_flags (m->flags);
	    }

	  if (m->not_flags)
	    {
	      minfo (" !");
	      lang_map_flags (m->not_flags);
	    }
	}

      print_nl ();
    }

  fprintf (config.map_file, _("\nLinker script and memory map\n\n"));

  print_statements ();
}

/* Initialize an output section.  */

static void
init_os (lang_output_section_statement_type *s)
{
  section_userdata_type *new;

  if (s->bfd_section != NULL)
    return;

  if (strcmp (s->name, DISCARD_SECTION_NAME) == 0)
    einfo (_("%P%F: Illegal use of `%s' section\n"), DISCARD_SECTION_NAME);

  new = stat_alloc (sizeof (section_userdata_type));

  s->bfd_section = bfd_get_section_by_name (output_bfd, s->name);
  if (s->bfd_section == NULL)
    s->bfd_section = bfd_make_section (output_bfd, s->name);
  if (s->bfd_section == NULL)
    {
      einfo (_("%P%F: output format %s cannot represent section called %s\n"),
	     output_bfd->xvec->name, s->name);
    }
  s->bfd_section->output_section = s->bfd_section;

  /* We initialize an output sections output offset to minus its own
     vma to allow us to output a section through itself.  */
  s->bfd_section->output_offset = 0;
  get_userdata (s->bfd_section) = new;

  /* If there is a base address, make sure that any sections it might
     mention are initialized.  */
  if (s->addr_tree != NULL)
    exp_init_os (s->addr_tree);

  if (s->load_base != NULL)
    exp_init_os (s->load_base);
}

/* Make sure that all output sections mentioned in an expression are
   initialized.  */

static void
exp_init_os (etree_type *exp)
{
  switch (exp->type.node_class)
    {
    case etree_assign:
      exp_init_os (exp->assign.src);
      break;

    case etree_binary:
      exp_init_os (exp->binary.lhs);
      exp_init_os (exp->binary.rhs);
      break;

    case etree_trinary:
      exp_init_os (exp->trinary.cond);
      exp_init_os (exp->trinary.lhs);
      exp_init_os (exp->trinary.rhs);
      break;

    case etree_assert:
      exp_init_os (exp->assert_s.child);
      break;
      
    case etree_unary:
      exp_init_os (exp->unary.child);
      break;

    case etree_name:
      switch (exp->type.node_code)
	{
	case ADDR:
	case LOADADDR:
	case SIZEOF:
	  {
	    lang_output_section_statement_type *os;

	    os = lang_output_section_find (exp->name.name);
	    if (os != NULL && os->bfd_section == NULL)
	      init_os (os);
	  }
	}
      break;

    default:
      break;
    }
}

/* Sections marked with the SEC_LINK_ONCE flag should only be linked
   once into the output.  This routine checks each section, and
   arrange to discard it if a section of the same name has already
   been linked.  If the section has COMDAT information, then it uses
   that to decide whether the section should be included.  This code
   assumes that all relevant sections have the SEC_LINK_ONCE flag set;
   that is, it does not depend solely upon the section name.
   section_already_linked is called via bfd_map_over_sections.  */

/* This is the shape of the elements inside the already_linked hash
   table. It maps a name onto a list of already_linked elements with
   the same name.  It's possible to get more than one element in a
   list if the COMDAT sections have different names.  */

struct already_linked_hash_entry
{
  struct bfd_hash_entry root;
  struct already_linked *entry;
};

struct already_linked
{
  struct already_linked *next;
  asection *sec;
};

/* The hash table.  */

static struct bfd_hash_table already_linked_table;

static void
section_already_linked (bfd *abfd, asection *sec, void *data)
{
  lang_input_statement_type *entry = data;
  flagword flags;
  const char *name;
  struct already_linked *l;
  struct already_linked_hash_entry *already_linked_list;

  /* If we are only reading symbols from this object, then we want to
     discard all sections.  */
  if (entry->just_syms_flag)
    {
      bfd_link_just_syms (sec, &link_info);
      return;
    }

  flags = bfd_get_section_flags (abfd, sec);

  if ((flags & SEC_LINK_ONCE) == 0)
    return;

  /* FIXME: When doing a relocatable link, we may have trouble
     copying relocations in other sections that refer to local symbols
     in the section being discarded.  Those relocations will have to
     be converted somehow; as of this writing I'm not sure that any of
     the backends handle that correctly.

     It is tempting to instead not discard link once sections when
     doing a relocatable link (technically, they should be discarded
     whenever we are building constructors).  However, that fails,
     because the linker winds up combining all the link once sections
     into a single large link once section, which defeats the purpose
     of having link once sections in the first place.

     Also, not merging link once sections in a relocatable link
     causes trouble for MIPS ELF, which relies on link once semantics
     to handle the .reginfo section correctly.  */

  name = bfd_get_section_name (abfd, sec);

  already_linked_list =
    ((struct already_linked_hash_entry *)
     bfd_hash_lookup (&already_linked_table, name, TRUE, FALSE));

  for (l = already_linked_list->entry; l != NULL; l = l->next)
    {
      if (sec->comdat == NULL
	  || l->sec->comdat == NULL
	  || strcmp (sec->comdat->name, l->sec->comdat->name) == 0)
	{
	  /* The section has already been linked.  See if we should
             issue a warning.  */
	  switch (flags & SEC_LINK_DUPLICATES)
	    {
	    default:
	      abort ();

	    case SEC_LINK_DUPLICATES_DISCARD:
	      break;

	    case SEC_LINK_DUPLICATES_ONE_ONLY:
	      if (sec->comdat == NULL)
		einfo (_("%P: %B: warning: ignoring duplicate section `%s'\n"),
		       abfd, name);
	      else
		einfo (_("%P: %B: warning: ignoring duplicate `%s' section symbol `%s'\n"),
		       abfd, name, sec->comdat->name);
	      break;

	    case SEC_LINK_DUPLICATES_SAME_CONTENTS:
	      /* FIXME: We should really dig out the contents of both
                 sections and memcmp them.  The COFF/PE spec says that
                 the Microsoft linker does not implement this
                 correctly, so I'm not going to bother doing it
                 either.  */
	      /* Fall through.  */
	    case SEC_LINK_DUPLICATES_SAME_SIZE:
	      if (bfd_section_size (abfd, sec)
		  != bfd_section_size (l->sec->owner, l->sec))
		einfo (_("%P: %B: warning: duplicate section `%s' has different size\n"),
		       abfd, name);
	      break;
	    }

	  /* Set the output_section field so that lang_add_section
	     does not create a lang_input_section structure for this
	     section.  Since there might be a symbol in the section
	     being discarded, we must retain a pointer to the section
	     which we are really going to use.  */
	  sec->output_section = bfd_abs_section_ptr;
	  sec->kept_section = l->sec;

	  if (flags & SEC_GROUP)
	    bfd_discard_group (abfd, sec);

	  return;
	}
    }

  /* This is the first section with this name.  Record it.  Allocate
     the memory from the same obstack as the hash table is kept in.  */

  l = bfd_hash_allocate (&already_linked_table, sizeof *l);

  l->sec = sec;
  l->next = already_linked_list->entry;
  already_linked_list->entry = l;
}

/* Support routines for the hash table used by section_already_linked,
   initialize the table, fill in an entry and remove the table.  */

static struct bfd_hash_entry *
already_linked_newfunc (struct bfd_hash_entry *entry ATTRIBUTE_UNUSED,
			struct bfd_hash_table *table,
			const char *string ATTRIBUTE_UNUSED)
{
  struct already_linked_hash_entry *ret =
    bfd_hash_allocate (table, sizeof (struct already_linked_hash_entry));

  ret->entry = NULL;

  return &ret->root;
}

static void
already_linked_table_init (void)
{
  if (! bfd_hash_table_init_n (&already_linked_table,
			       already_linked_newfunc,
			       42))
    einfo (_("%P%F: Failed to create hash table\n"));
}

static void
already_linked_table_free (void)
{
  bfd_hash_table_free (&already_linked_table);
}

/* The wild routines.

   These expand statements like *(.text) and foo.o to a list of
   explicit actions, like foo.o(.text), bar.o(.text) and
   foo.o(.text, .data).  */

/* Return TRUE if the PATTERN argument is a wildcard pattern.
   Although backslashes are treated specially if a pattern contains
   wildcards, we do not consider the mere presence of a backslash to
   be enough to cause the pattern to be treated as a wildcard.
   That lets us handle DOS filenames more naturally.  */

static bfd_boolean
wildcardp (const char *pattern)
{
  const char *s;

  for (s = pattern; *s != '\0'; ++s)
    if (*s == '?'
	|| *s == '*'
	|| *s == '[')
      return TRUE;
  return FALSE;
}

/* Add SECTION to the output section OUTPUT.  Do this by creating a
   lang_input_section statement which is placed at PTR.  FILE is the
   input file which holds SECTION.  */

void
lang_add_section (lang_statement_list_type *ptr,
		  asection *section,
		  lang_output_section_statement_type *output,
		  lang_input_statement_type *file)
{
  flagword flags;
  bfd_boolean discard;

  flags = bfd_get_section_flags (section->owner, section);

  discard = FALSE;

  /* Discard sections marked with SEC_EXCLUDE if we are doing a final
     link.  Discard debugging sections marked with SEC_EXCLUDE on a
     relocatable link too.  */
  if ((flags & SEC_EXCLUDE) != 0
      && ((flags & SEC_DEBUGGING) != 0 || !link_info.relocatable))
    discard = TRUE;

  /* Discard input sections which are assigned to a section named
     DISCARD_SECTION_NAME.  */
  if (strcmp (output->name, DISCARD_SECTION_NAME) == 0)
    discard = TRUE;

  /* Discard debugging sections if we are stripping debugging
     information.  */
  if ((link_info.strip == strip_debugger || link_info.strip == strip_all)
      && (flags & SEC_DEBUGGING) != 0)
    discard = TRUE;

  if (discard)
    {
      if (section->output_section == NULL)
	{
	  /* This prevents future calls from assigning this section.  */
	  section->output_section = bfd_abs_section_ptr;
	}
      return;
    }

  if (section->output_section == NULL)
    {
      bfd_boolean first;
      lang_input_section_type *new;
      flagword flags;

      if (output->bfd_section == NULL)
	init_os (output);

      first = ! output->bfd_section->linker_has_input;
      output->bfd_section->linker_has_input = 1;

      /* Add a section reference to the list.  */
      new = new_stat (lang_input_section, ptr);

      new->section = section;
      new->ifile = file;
      section->output_section = output->bfd_section;

      flags = section->flags;

      /* We don't copy the SEC_NEVER_LOAD flag from an input section
	 to an output section, because we want to be able to include a
	 SEC_NEVER_LOAD section in the middle of an otherwise loaded
	 section (I don't know why we want to do this, but we do).
	 build_link_order in ldwrite.c handles this case by turning
	 the embedded SEC_NEVER_LOAD section into a fill.  */

      flags &= ~ SEC_NEVER_LOAD;

      /* If final link, don't copy the SEC_LINK_ONCE flags, they've
	 already been processed.  One reason to do this is that on pe
	 format targets, .text$foo sections go into .text and it's odd
	 to see .text with SEC_LINK_ONCE set.  */

      if (! link_info.relocatable)
	flags &= ~ (SEC_LINK_ONCE | SEC_LINK_DUPLICATES);

      /* If this is not the first input section, and the SEC_READONLY
         flag is not currently set, then don't set it just because the
         input section has it set.  */

      if (! first && (section->output_section->flags & SEC_READONLY) == 0)
	flags &= ~ SEC_READONLY;

      /* Keep SEC_MERGE and SEC_STRINGS only if they are the same.  */
      if (! first
	  && ((section->output_section->flags & (SEC_MERGE | SEC_STRINGS))
	      != (flags & (SEC_MERGE | SEC_STRINGS))
	      || ((flags & SEC_MERGE)
		  && section->output_section->entsize != section->entsize)))
	{
	  section->output_section->flags &= ~ (SEC_MERGE | SEC_STRINGS);
	  flags &= ~ (SEC_MERGE | SEC_STRINGS);
	}

      section->output_section->flags |= flags;

      if (flags & SEC_MERGE)
	section->output_section->entsize = section->entsize;

      /* If SEC_READONLY is not set in the input section, then clear
         it from the output section.  */
      if ((section->flags & SEC_READONLY) == 0)
	section->output_section->flags &= ~SEC_READONLY;

      switch (output->sectype)
	{
	case normal_section:
	  break;
	case dsect_section:
	case copy_section:
	case info_section:
	case overlay_section:
	  output->bfd_section->flags &= ~SEC_ALLOC;
	  break;
	case noload_section:
	  output->bfd_section->flags &= ~SEC_LOAD;
	  output->bfd_section->flags |= SEC_NEVER_LOAD;
	  break;
	}

      /* Copy over SEC_SMALL_DATA.  */
      if (section->flags & SEC_SMALL_DATA)
	section->output_section->flags |= SEC_SMALL_DATA;

      if (section->alignment_power > output->bfd_section->alignment_power)
	output->bfd_section->alignment_power = section->alignment_power;

      /* If supplied an alignment, then force it.  */
      if (output->section_alignment != -1)
	output->bfd_section->alignment_power = output->section_alignment;

      if (section->flags & SEC_BLOCK)
	{
	  section->output_section->flags |= SEC_BLOCK;
	  /* FIXME: This value should really be obtained from the bfd...  */
	  output->block_value = 128;
	}
    }
}

/* Handle wildcard sorting.  This returns the lang_input_section which
   should follow the one we are going to create for SECTION and FILE,
   based on the sorting requirements of WILD.  It returns NULL if the
   new section should just go at the end of the current list.  */

static lang_statement_union_type *
wild_sort (lang_wild_statement_type *wild,
	   struct wildcard_list *sec,
	   lang_input_statement_type *file,
	   asection *section)
{
  const char *section_name;
  lang_statement_union_type *l;

  if (!wild->filenames_sorted && (sec == NULL || !sec->spec.sorted))
    return NULL;

  section_name = bfd_get_section_name (file->the_bfd, section);
  for (l = wild->children.head; l != NULL; l = l->header.next)
    {
      lang_input_section_type *ls;

      if (l->header.type != lang_input_section_enum)
	continue;
      ls = &l->input_section;

      /* Sorting by filename takes precedence over sorting by section
         name.  */

      if (wild->filenames_sorted)
	{
	  const char *fn, *ln;
	  bfd_boolean fa, la;
	  int i;

	  /* The PE support for the .idata section as generated by
             dlltool assumes that files will be sorted by the name of
             the archive and then the name of the file within the
             archive.  */

	  if (file->the_bfd != NULL
	      && bfd_my_archive (file->the_bfd) != NULL)
	    {
	      fn = bfd_get_filename (bfd_my_archive (file->the_bfd));
	      fa = TRUE;
	    }
	  else
	    {
	      fn = file->filename;
	      fa = FALSE;
	    }

	  if (ls->ifile->the_bfd != NULL
	      && bfd_my_archive (ls->ifile->the_bfd) != NULL)
	    {
	      ln = bfd_get_filename (bfd_my_archive (ls->ifile->the_bfd));
	      la = TRUE;
	    }
	  else
	    {
	      ln = ls->ifile->filename;
	      la = FALSE;
	    }

	  i = strcmp (fn, ln);
	  if (i > 0)
	    continue;
	  else if (i < 0)
	    break;

	  if (fa || la)
	    {
	      if (fa)
		fn = file->filename;
	      if (la)
		ln = ls->ifile->filename;

	      i = strcmp (fn, ln);
	      if (i > 0)
		continue;
	      else if (i < 0)
		break;
	    }
	}

      /* Here either the files are not sorted by name, or we are
         looking at the sections for this file.  */

      if (sec != NULL && sec->spec.sorted)
	{
	  if (strcmp (section_name,
		      bfd_get_section_name (ls->ifile->the_bfd,
					    ls->section))
	      < 0)
	    break;
	}
    }

  return l;
}

/* Expand a wild statement for a particular FILE.  SECTION may be
   NULL, in which case it is a wild card.  */

static void
output_section_callback (lang_wild_statement_type *ptr,
			 struct wildcard_list *sec,
			 asection *section,
			 lang_input_statement_type *file,
			 void *output)
{
  lang_statement_union_type *before;

  /* Exclude sections that match UNIQUE_SECTION_LIST.  */
  if (unique_section_p (bfd_get_section_name (file->the_bfd, section)))
    return;

  /* If the wild pattern was marked KEEP, the member sections
     should be as well.  */
  if (ptr->keep_sections)
    section->flags |= SEC_KEEP;

  before = wild_sort (ptr, sec, file, section);

  /* Here BEFORE points to the lang_input_section which
     should follow the one we are about to add.  If BEFORE
     is NULL, then the section should just go at the end
     of the current list.  */

  if (before == NULL)
    lang_add_section (&ptr->children, section,
		      (lang_output_section_statement_type *) output,
		      file);
  else
    {
      lang_statement_list_type list;
      lang_statement_union_type **pp;

      lang_list_init (&list);
      lang_add_section (&list, section,
			(lang_output_section_statement_type *) output,
			file);

      /* If we are discarding the section, LIST.HEAD will
	 be NULL.  */
      if (list.head != NULL)
	{
	  ASSERT (list.head->header.next == NULL);

	  for (pp = &ptr->children.head;
	       *pp != before;
	       pp = &(*pp)->header.next)
	    ASSERT (*pp != NULL);

	  list.head->header.next = *pp;
	  *pp = list.head;
	}
    }
}

/* This is passed a file name which must have been seen already and
   added to the statement tree.  We will see if it has been opened
   already and had its symbols read.  If not then we'll read it.  */

static lang_input_statement_type *
lookup_name (const char *name)
{
  lang_input_statement_type *search;

  for (search = (lang_input_statement_type *) input_file_chain.head;
       search != NULL;
       search = (lang_input_statement_type *) search->next_real_file)
    {
      /* Use the local_sym_name as the name of the file that has
	 already been loaded as filename might have been transformed
	 via the search directory lookup mechanism.  */
      const char * filename = search->local_sym_name;

      if (filename == NULL && name == NULL)
	return search;
      if (filename != NULL
	  && name != NULL
	  && strcmp (filename, name) == 0)
	break;
    }

  if (search == NULL)
    search = new_afile (name, lang_input_file_is_search_file_enum, default_target,
			FALSE);

  /* If we have already added this file, or this file is not real
     (FIXME: can that ever actually happen?) or the name is NULL
     (FIXME: can that ever actually happen?) don't add this file.  */
  if (search->loaded
      || ! search->real
      || search->filename == NULL)
    return search;

  if (! load_symbols (search, NULL))
    return NULL;

  return search;
}

/* Get the symbols for an input file.  */

static bfd_boolean
load_symbols (lang_input_statement_type *entry,
	      lang_statement_list_type *place)
{
  char **matching;

  if (entry->loaded)
    return TRUE;

  ldfile_open_file (entry);

  if (! bfd_check_format (entry->the_bfd, bfd_archive)
      && ! bfd_check_format_matches (entry->the_bfd, bfd_object, &matching))
    {
      bfd_error_type err;
      lang_statement_list_type *hold;
      bfd_boolean bad_load = TRUE;
      bfd_boolean save_ldlang_sysrooted_script;

      err = bfd_get_error ();

      /* See if the emulation has some special knowledge.  */
      if (ldemul_unrecognized_file (entry))
	return TRUE;

      if (err == bfd_error_file_ambiguously_recognized)
	{
	  char **p;

	  einfo (_("%B: file not recognized: %E\n"), entry->the_bfd);
	  einfo (_("%B: matching formats:"), entry->the_bfd);
	  for (p = matching; *p != NULL; p++)
	    einfo (" %s", *p);
	  einfo ("%F\n");
	}
      else if (err != bfd_error_file_not_recognized
	       || place == NULL)
	  einfo (_("%F%B: file not recognized: %E\n"), entry->the_bfd);
      else
	bad_load = FALSE;

      bfd_close (entry->the_bfd);
      entry->the_bfd = NULL;

      /* Try to interpret the file as a linker script.  */
      ldfile_open_command_file (entry->filename);

      hold = stat_ptr;
      stat_ptr = place;
      save_ldlang_sysrooted_script = ldlang_sysrooted_script;
      ldlang_sysrooted_script = entry->sysrooted;

      ldfile_assumed_script = TRUE;
      parser_input = input_script;
      yyparse ();
      ldfile_assumed_script = FALSE;

      ldlang_sysrooted_script = save_ldlang_sysrooted_script;
      stat_ptr = hold;

      return ! bad_load;
    }

  if (ldemul_recognized_file (entry))
    return TRUE;

  /* We don't call ldlang_add_file for an archive.  Instead, the
     add_symbols entry point will call ldlang_add_file, via the
     add_archive_element callback, for each element of the archive
     which is used.  */
  switch (bfd_get_format (entry->the_bfd))
    {
    default:
      break;

    case bfd_object:
      ldlang_add_file (entry);
      if (trace_files || trace_file_tries)
	info_msg ("%I\n", entry);
      break;

    case bfd_archive:
      if (entry->whole_archive)
	{
	  bfd *member = NULL;
	  bfd_boolean loaded = TRUE;

	  for (;;)
	    {
	      member = bfd_openr_next_archived_file (entry->the_bfd, member);

	      if (member == NULL)
		break;

	      if (! bfd_check_format (member, bfd_object))
		{
		  einfo (_("%F%B: member %B in archive is not an object\n"),
			 entry->the_bfd, member);
		  loaded = FALSE;
		}

	      if (! ((*link_info.callbacks->add_archive_element)
		     (&link_info, member, "--whole-archive")))
		abort ();

	      if (! bfd_link_add_symbols (member, &link_info))
		{
		  einfo (_("%F%B: could not read symbols: %E\n"), member);
		  loaded = FALSE;
		}
	    }

	  entry->loaded = loaded;
	  return loaded;
	}
      break;
    }

  if (bfd_link_add_symbols (entry->the_bfd, &link_info))
    entry->loaded = TRUE;
  else
    einfo (_("%F%B: could not read symbols: %E\n"), entry->the_bfd);

  return entry->loaded;
}

/* Handle a wild statement.  S->FILENAME or S->SECTION_LIST or both
   may be NULL, indicating that it is a wildcard.  Separate
   lang_input_section statements are created for each part of the
   expansion; they are added after the wild statement S.  OUTPUT is
   the output section.  */

static void
wild (lang_wild_statement_type *s,
      const char *target ATTRIBUTE_UNUSED,
      lang_output_section_statement_type *output)
{
  struct wildcard_list *sec;

  walk_wild (s, output_section_callback, output);

  for (sec = s->section_list; sec != NULL; sec = sec->next)
    {
      if (default_common_section != NULL)
	break;
      if (sec->spec.name != NULL && strcmp (sec->spec.name, "COMMON") == 0)
	{
	  /* Remember the section that common is going to in case we
	     later get something which doesn't know where to put it.  */
	  default_common_section = output;
	}
    }
}

/* Return TRUE iff target is the sought target.  */

static int
get_target (const bfd_target *target, void *data)
{
  const char *sought = data;

  return strcmp (target->name, sought) == 0;
}

/* Like strcpy() but convert to lower case as well.  */

static void
stricpy (char *dest, char *src)
{
  char c;

  while ((c = *src++) != 0)
    *dest++ = TOLOWER (c);

  *dest = 0;
}

/* Remove the first occurrence of needle (if any) in haystack
   from haystack.  */

static void
strcut (char *haystack, char *needle)
{
  haystack = strstr (haystack, needle);

  if (haystack)
    {
      char *src;

      for (src = haystack + strlen (needle); *src;)
	*haystack++ = *src++;

      *haystack = 0;
    }
}

/* Compare two target format name strings.
   Return a value indicating how "similar" they are.  */

static int
name_compare (char *first, char *second)
{
  char *copy1;
  char *copy2;
  int result;

  copy1 = xmalloc (strlen (first) + 1);
  copy2 = xmalloc (strlen (second) + 1);

  /* Convert the names to lower case.  */
  stricpy (copy1, first);
  stricpy (copy2, second);

  /* Remove size and endian strings from the name.  */
  strcut (copy1, "big");
  strcut (copy1, "little");
  strcut (copy2, "big");
  strcut (copy2, "little");

  /* Return a value based on how many characters match,
     starting from the beginning.   If both strings are
     the same then return 10 * their length.  */
  for (result = 0; copy1[result] == copy2[result]; result++)
    if (copy1[result] == 0)
      {
	result *= 10;
	break;
      }

  free (copy1);
  free (copy2);

  return result;
}

/* Set by closest_target_match() below.  */
static const bfd_target *winner;

/* Scan all the valid bfd targets looking for one that has the endianness
   requirement that was specified on the command line, and is the nearest
   match to the original output target.  */

static int
closest_target_match (const bfd_target *target, void *data)
{
  const bfd_target *original = data;

  if (command_line.endian == ENDIAN_BIG
      && target->byteorder != BFD_ENDIAN_BIG)
    return 0;

  if (command_line.endian == ENDIAN_LITTLE
      && target->byteorder != BFD_ENDIAN_LITTLE)
    return 0;

  /* Must be the same flavour.  */
  if (target->flavour != original->flavour)
    return 0;

  /* If we have not found a potential winner yet, then record this one.  */
  if (winner == NULL)
    {
      winner = target;
      return 0;
    }

  /* Oh dear, we now have two potential candidates for a successful match.
     Compare their names and choose the better one.  */
  if (name_compare (target->name, original->name)
      > name_compare (winner->name, original->name))
    winner = target;

  /* Keep on searching until wqe have checked them all.  */
  return 0;
}

/* Return the BFD target format of the first input file.  */

static char *
get_first_input_target (void)
{
  char *target = NULL;

  LANG_FOR_EACH_INPUT_STATEMENT (s)
    {
      if (s->header.type == lang_input_statement_enum
	  && s->real)
	{
	  ldfile_open_file (s);

	  if (s->the_bfd != NULL
	      && bfd_check_format (s->the_bfd, bfd_object))
	    {
	      target = bfd_get_target (s->the_bfd);

	      if (target != NULL)
		break;
	    }
	}
    }

  return target;
}

const char *
lang_get_output_target (void)
{
  const char *target;

  /* Has the user told us which output format to use?  */
  if (output_target != NULL)
    return output_target;

  /* No - has the current target been set to something other than
     the default?  */
  if (current_target != default_target)
    return current_target;

  /* No - can we determine the format of the first input file?  */
  target = get_first_input_target ();
  if (target != NULL)
    return target;

  /* Failed - use the default output target.  */
  return default_target;
}

/* Open the output file.  */

static bfd *
open_output (const char *name)
{
  bfd *output;

  output_target = lang_get_output_target ();

  /* Has the user requested a particular endianness on the command
     line?  */
  if (command_line.endian != ENDIAN_UNSET)
    {
      const bfd_target *target;
      enum bfd_endian desired_endian;

      /* Get the chosen target.  */
      target = bfd_search_for_target (get_target, (void *) output_target);

      /* If the target is not supported, we cannot do anything.  */
      if (target != NULL)
	{
	  if (command_line.endian == ENDIAN_BIG)
	    desired_endian = BFD_ENDIAN_BIG;
	  else
	    desired_endian = BFD_ENDIAN_LITTLE;

	  /* See if the target has the wrong endianness.  This should
	     not happen if the linker script has provided big and
	     little endian alternatives, but some scrips don't do
	     this.  */
	  if (target->byteorder != desired_endian)
	    {
	      /* If it does, then see if the target provides
		 an alternative with the correct endianness.  */
	      if (target->alternative_target != NULL
		  && (target->alternative_target->byteorder == desired_endian))
		output_target = target->alternative_target->name;
	      else
		{
		  /* Try to find a target as similar as possible to
		     the default target, but which has the desired
		     endian characteristic.  */
		  bfd_search_for_target (closest_target_match,
					 (void *) target);

		  /* Oh dear - we could not find any targets that
		     satisfy our requirements.  */
		  if (winner == NULL)
		    einfo (_("%P: warning: could not find any targets that match endianness requirement\n"));
		  else
		    output_target = winner->name;
		}
	    }
	}
    }

  output = bfd_openw (name, output_target);

  if (output == NULL)
    {
      if (bfd_get_error () == bfd_error_invalid_target)
	einfo (_("%P%F: target %s not found\n"), output_target);

      einfo (_("%P%F: cannot open output file %s: %E\n"), name);
    }

  delete_output_file_on_failure = TRUE;

#if 0
  output->flags |= D_PAGED;
#endif

  if (! bfd_set_format (output, bfd_object))
    einfo (_("%P%F:%s: can not make object file: %E\n"), name);
  if (! bfd_set_arch_mach (output,
			   ldfile_output_architecture,
			   ldfile_output_machine))
    einfo (_("%P%F:%s: can not set architecture: %E\n"), name);

  link_info.hash = bfd_link_hash_table_create (output);
  if (link_info.hash == NULL)
    einfo (_("%P%F: can not create link hash table: %E\n"));

  bfd_set_gp_size (output, g_switch_value);
  return output;
}

static void
ldlang_open_output (lang_statement_union_type *statement)
{
  switch (statement->header.type)
    {
    case lang_output_statement_enum:
      ASSERT (output_bfd == NULL);
      output_bfd = open_output (statement->output_statement.name);
      ldemul_set_output_arch ();
      if (config.magic_demand_paged && !link_info.relocatable)
	output_bfd->flags |= D_PAGED;
      else
	output_bfd->flags &= ~D_PAGED;
      if (config.text_read_only)
	output_bfd->flags |= WP_TEXT;
      else
	output_bfd->flags &= ~WP_TEXT;
      if (link_info.traditional_format)
	output_bfd->flags |= BFD_TRADITIONAL_FORMAT;
      else
	output_bfd->flags &= ~BFD_TRADITIONAL_FORMAT;
      break;

    case lang_target_statement_enum:
      current_target = statement->target_statement.target;
      break;
    default:
      break;
    }
}

/* Convert between addresses in bytes and sizes in octets.
   For currently supported targets, octets_per_byte is always a power
   of two, so we can use shifts.  */
#define TO_ADDR(X) ((X) >> opb_shift)
#define TO_SIZE(X) ((X) << opb_shift)

/* Support the above.  */
static unsigned int opb_shift = 0;

static void
init_opb (void)
{
  unsigned x = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
					      ldfile_output_machine);
  opb_shift = 0;
  if (x > 1)
    while ((x & 1) == 0)
      {
	x >>= 1;
	++opb_shift;
      }
  ASSERT (x == 1);
}

/* Open all the input files.  */

static void
open_input_bfds (lang_statement_union_type *s, bfd_boolean force)
{
  for (; s != NULL; s = s->header.next)
    {
      switch (s->header.type)
	{
	case lang_constructors_statement_enum:
	  open_input_bfds (constructor_list.head, force);
	  break;
	case lang_output_section_statement_enum:
	  open_input_bfds (s->output_section_statement.children.head, force);
	  break;
	case lang_wild_statement_enum:
	  /* Maybe we should load the file's symbols.  */
	  if (s->wild_statement.filename
	      && ! wildcardp (s->wild_statement.filename))
	    lookup_name (s->wild_statement.filename);
	  open_input_bfds (s->wild_statement.children.head, force);
	  break;
	case lang_group_statement_enum:
	  {
	    struct bfd_link_hash_entry *undefs;

	    /* We must continually search the entries in the group
	       until no new symbols are added to the list of undefined
	       symbols.  */

	    do
	      {
		undefs = link_info.hash->undefs_tail;
		open_input_bfds (s->group_statement.children.head, TRUE);
	      }
	    while (undefs != link_info.hash->undefs_tail);
	  }
	  break;
	case lang_target_statement_enum:
	  current_target = s->target_statement.target;
	  break;
	case lang_input_statement_enum:
	  if (s->input_statement.real)
	    {
	      lang_statement_list_type add;

	      s->input_statement.target = current_target;

	      /* If we are being called from within a group, and this
                 is an archive which has already been searched, then
                 force it to be researched unless the whole archive
		 has been loaded already.  */
	      if (force
		  && !s->input_statement.whole_archive
		  && s->input_statement.loaded
		  && bfd_check_format (s->input_statement.the_bfd,
				       bfd_archive))
		s->input_statement.loaded = FALSE;

	      lang_list_init (&add);

	      if (! load_symbols (&s->input_statement, &add))
		config.make_executable = FALSE;

	      if (add.head != NULL)
		{
		  *add.tail = s->header.next;
		  s->header.next = add.head;
		}
	    }
	  break;
	default:
	  break;
	}
    }
}

/* If there are [COMMONS] statements, put a wild one into the bss
   section.  */

static void
lang_reasonable_defaults (void)
{
#if 0
  lang_output_section_statement_lookup (".text");
  lang_output_section_statement_lookup (".data");

  default_common_section = lang_output_section_statement_lookup (".bss");

  if (!placed_commons)
    {
      lang_wild_statement_type *new =
      new_stat (lang_wild_statement,
		&default_common_section->children);

      new->section_name = "COMMON";
      new->filename = NULL;
      lang_list_init (&new->children);
    }
#endif
}

/* Add a symbol to a hash of symbols used in DEFINED (NAME) expressions.  */

void
lang_track_definedness (const char *name)
{
  if (bfd_hash_lookup (&lang_definedness_table, name, TRUE, FALSE) == NULL)
    einfo (_("%P%F: bfd_hash_lookup failed creating symbol %s\n"), name);
}

/* New-function for the definedness hash table.  */

static struct bfd_hash_entry *
lang_definedness_newfunc (struct bfd_hash_entry *entry,
			  struct bfd_hash_table *table ATTRIBUTE_UNUSED,
			  const char *name ATTRIBUTE_UNUSED)
{
  struct lang_definedness_hash_entry *ret
    = (struct lang_definedness_hash_entry *) entry;

  if (ret == NULL)
    ret = (struct lang_definedness_hash_entry *)
      bfd_hash_allocate (table, sizeof (struct lang_definedness_hash_entry));

  if (ret == NULL)
    einfo (_("%P%F: bfd_hash_allocate failed creating symbol %s\n"), name);

  ret->iteration = -1;
  return &ret->root;
}

/* Return the iteration when the definition of NAME was last updated.  A
   value of -1 means that the symbol is not defined in the linker script
   or the command line, but may be defined in the linker symbol table.  */

int
lang_symbol_definition_iteration (const char *name)
{
  struct lang_definedness_hash_entry *defentry
    = (struct lang_definedness_hash_entry *)
    bfd_hash_lookup (&lang_definedness_table, name, FALSE, FALSE);

  /* We've already created this one on the presence of DEFINED in the
     script, so it can't be NULL unless something is borked elsewhere in
     the code.  */
  if (defentry == NULL)
    FAIL ();

  return defentry->iteration;
}

/* Update the definedness state of NAME.  */

void
lang_update_definedness (const char *name, struct bfd_link_hash_entry *h)
{
  struct lang_definedness_hash_entry *defentry
    = (struct lang_definedness_hash_entry *)
    bfd_hash_lookup (&lang_definedness_table, name, FALSE, FALSE);

  /* We don't keep track of symbols not tested with DEFINED.  */
  if (defentry == NULL)
    return;

  /* If the symbol was already defined, and not from an earlier statement
     iteration, don't update the definedness iteration, because that'd
     make the symbol seem defined in the linker script at this point, and
     it wasn't; it was defined in some object.  If we do anyway, DEFINED
     would start to yield false before this point and the construct "sym =
     DEFINED (sym) ? sym : X;" would change sym to X despite being defined
     in an object.  */
  if (h->type != bfd_link_hash_undefined
      && h->type != bfd_link_hash_common
      && h->type != bfd_link_hash_new
      && defentry->iteration == -1)
    return;

  defentry->iteration = lang_statement_iteration;
}

/* Add the supplied name to the symbol table as an undefined reference.
   This is a two step process as the symbol table doesn't even exist at
   the time the ld command line is processed.  First we put the name
   on a list, then, once the output file has been opened, transfer the
   name to the symbol table.  */

typedef struct bfd_sym_chain ldlang_undef_chain_list_type;

#define ldlang_undef_chain_list_head entry_symbol.next

void
ldlang_add_undef (const char *const name)
{
  ldlang_undef_chain_list_type *new =
    stat_alloc (sizeof (ldlang_undef_chain_list_type));

  new->next = ldlang_undef_chain_list_head;
  ldlang_undef_chain_list_head = new;

  new->name = xstrdup (name);

  if (output_bfd != NULL)
    insert_undefined (new->name);
}

/* Insert NAME as undefined in the symbol table.  */

static void
insert_undefined (const char *name)
{
  struct bfd_link_hash_entry *h;

  h = bfd_link_hash_lookup (link_info.hash, name, TRUE, FALSE, TRUE);
  if (h == NULL)
    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
  if (h->type == bfd_link_hash_new)
    {
      h->type = bfd_link_hash_undefined;
      h->u.undef.abfd = NULL;
      bfd_link_add_undef (link_info.hash, h);
    }
}

/* Run through the list of undefineds created above and place them
   into the linker hash table as undefined symbols belonging to the
   script file.  */

static void
lang_place_undefineds (void)
{
  ldlang_undef_chain_list_type *ptr;

  for (ptr = ldlang_undef_chain_list_head; ptr != NULL; ptr = ptr->next)
    insert_undefined (ptr->name);
}

/* Open input files and attach to output sections.  */

static void
map_input_to_output_sections
  (lang_statement_union_type *s, const char *target,
   lang_output_section_statement_type *output_section_statement)
{
  for (; s != NULL; s = s->header.next)
    {
      switch (s->header.type)
	{
	case lang_wild_statement_enum:
	  wild (&s->wild_statement, target, output_section_statement);
	  break;
	case lang_constructors_statement_enum:
	  map_input_to_output_sections (constructor_list.head,
					target,
					output_section_statement);
	  break;
	case lang_output_section_statement_enum:
	  map_input_to_output_sections (s->output_section_statement.children.head,
					target,
					&s->output_section_statement);
	  break;
	case lang_output_statement_enum:
	  break;
	case lang_target_statement_enum:
	  target = s->target_statement.target;
	  break;
	case lang_group_statement_enum:
	  map_input_to_output_sections (s->group_statement.children.head,
					target,
					output_section_statement);
	  break;
	case lang_data_statement_enum:
	  /* Make sure that any sections mentioned in the expression
	     are initialized.  */
	  exp_init_os (s->data_statement.exp);
	  /* FALLTHROUGH */
	case lang_fill_statement_enum:
	case lang_input_section_enum:
	case lang_object_symbols_statement_enum:
	case lang_reloc_statement_enum:
	case lang_padding_statement_enum:
	case lang_input_statement_enum:
	  if (output_section_statement != NULL
	      && output_section_statement->bfd_section == NULL)
	    init_os (output_section_statement);
	  break;
	case lang_assignment_statement_enum:
	  if (output_section_statement != NULL
	      && output_section_statement->bfd_section == NULL)
	    init_os (output_section_statement);

	  /* Make sure that any sections mentioned in the assignment
	     are initialized.  */
	  exp_init_os (s->assignment_statement.exp);
	  break;
	case lang_afile_asection_pair_statement_enum:
	  FAIL ();
	  break;
	case lang_address_statement_enum:
	  /* Mark the specified section with the supplied address.  */
	  {
	    lang_output_section_statement_type *os =
	      lang_output_section_statement_lookup
		(s->address_statement.section_name);

	    if (os->bfd_section == NULL)
	      init_os (os);
	    os->addr_tree = s->address_statement.address;
	  }
	  break;
	}
    }
}

/* An output section might have been removed after its statement was
   added.  For example, ldemul_before_allocation can remove dynamic
   sections if they turn out to be not needed.  Clean them up here.  */

static void
strip_excluded_output_sections (void)
{
  lang_statement_union_type *u;

  for (u = lang_output_section_statement.head;
       u != NULL;
       u = u->output_section_statement.next)
    {
      lang_output_section_statement_type *os;
      asection *s;

      os = &u->output_section_statement;
      s = os->bfd_section;
      if (s != NULL && (s->flags & SEC_EXCLUDE) != 0)
	{
	  asection **p;

	  os->bfd_section = NULL;

	  for (p = &output_bfd->sections; *p; p = &(*p)->next)
	    if (*p == s)
	      {
		bfd_section_list_remove (output_bfd, p);
		output_bfd->section_count--;
		break;
	      }
	}
    }
}

static void
print_output_section_statement
  (lang_output_section_statement_type *output_section_statement)
{
  asection *section = output_section_statement->bfd_section;
  int len;

  if (output_section_statement != abs_output_section)
    {
      minfo ("\n%s", output_section_statement->name);

      if (section != NULL)
	{
	  print_dot = section->vma;

	  len = strlen (output_section_statement->name);
	  if (len >= SECTION_NAME_MAP_LENGTH - 1)
	    {
	      print_nl ();
	      len = 0;
	    }
	  while (len < SECTION_NAME_MAP_LENGTH)
	    {
	      print_space ();
	      ++len;
	    }

	  minfo ("0x%V %W", section->vma, section->_raw_size);

	  if (output_section_statement->load_base != NULL)
	    {
	      bfd_vma addr;

	      addr = exp_get_abs_int (output_section_statement->load_base, 0,
				      "load base", lang_final_phase_enum);
	      minfo (_(" load address 0x%V"), addr);
	    }
	}

      print_nl ();
    }

  print_statement_list (output_section_statement->children.head,
			output_section_statement);
}

static void
print_assignment (lang_assignment_statement_type *assignment,
		  lang_output_section_statement_type *output_section)
{
  int i;
  etree_value_type result;

  for (i = 0; i < SECTION_NAME_MAP_LENGTH; i++)
    print_space ();

  result = exp_fold_tree (assignment->exp->assign.src, output_section,
			  lang_final_phase_enum, print_dot, &print_dot);
  if (result.valid_p)
    {
      const char *dst;
      bfd_vma value;

      value = result.value + result.section->bfd_section->vma;
      dst = assignment->exp->assign.dst;

      minfo ("0x%V", value);
      if (dst[0] == '.' && dst[1] == 0)
	print_dot = value;
    }
  else
    {
      minfo ("*undef*   ");
#ifdef BFD64
      minfo ("        ");
#endif
    }

  minfo ("                ");

  exp_print_tree (assignment->exp);

  print_nl ();
}

static void
print_input_statement (lang_input_statement_type *statm)
{
  if (statm->filename != NULL)
    {
      fprintf (config.map_file, "LOAD %s\n", statm->filename);
    }
}

/* Print all symbols defined in a particular section.  This is called
   via bfd_link_hash_traverse.  */

static bfd_boolean
print_one_symbol (struct bfd_link_hash_entry *hash_entry, void *ptr)
{
  asection *sec = ptr;

  if ((hash_entry->type == bfd_link_hash_defined
       || hash_entry->type == bfd_link_hash_defweak)
      && sec == hash_entry->u.def.section)
    {
      int i;

      for (i = 0; i < SECTION_NAME_MAP_LENGTH; i++)
	print_space ();
      minfo ("0x%V   ",
	     (hash_entry->u.def.value
	      + hash_entry->u.def.section->output_offset
	      + hash_entry->u.def.section->output_section->vma));

      minfo ("             %T\n", hash_entry->root.string);
    }

  return TRUE;
}

/* Print information about an input section to the map file.  */

static void
print_input_section (lang_input_section_type *in)
{
  asection *i = in->section;
  bfd_size_type size = i->_cooked_size != 0 ? i->_cooked_size : i->_raw_size;

  init_opb ();
  if (size != 0)
    {
      print_space ();

      minfo ("%s", i->name);

      if (i->output_section != NULL)
	{
	  int len;

	  len = 1 + strlen (i->name);
	  if (len >= SECTION_NAME_MAP_LENGTH - 1)
	    {
	      print_nl ();
	      len = 0;
	    }
	  while (len < SECTION_NAME_MAP_LENGTH)
	    {
	      print_space ();
	      ++len;
	    }

	  minfo ("0x%V %W %B\n",
		 i->output_section->vma + i->output_offset, TO_ADDR (size),
		 i->owner);

	  if (i->_cooked_size != 0 && i->_cooked_size != i->_raw_size)
	    {
	      len = SECTION_NAME_MAP_LENGTH + 3;
#ifdef BFD64
	      len += 16;
#else
	      len += 8;
#endif
	      while (len > 0)
		{
		  print_space ();
		  --len;
		}

	      minfo (_("%W (size before relaxing)\n"), i->_raw_size);
	    }

	  bfd_link_hash_traverse (link_info.hash, print_one_symbol, i);

	  print_dot = (i->output_section->vma + i->output_offset
		       + TO_ADDR (size));
	}
    }
}

static void
print_fill_statement (lang_fill_statement_type *fill)
{
  size_t size;
  unsigned char *p;
  fputs (" FILL mask 0x", config.map_file);
  for (p = fill->fill->data, size = fill->fill->size; size != 0; p++, size--)
    fprintf (config.map_file, "%02x", *p);
  fputs ("\n", config.map_file);
}

static void
print_data_statement (lang_data_statement_type *data)
{
  int i;
  bfd_vma addr;
  bfd_size_type size;
  const char *name;

  init_opb ();
  for (i = 0; i < SECTION_NAME_MAP_LENGTH; i++)
    print_space ();

  addr = data->output_vma;
  if (data->output_section != NULL)
    addr += data->output_section->vma;

  switch (data->type)
    {
    default:
      abort ();
    case BYTE:
      size = BYTE_SIZE;
      name = "BYTE";
      break;
    case SHORT:
      size = SHORT_SIZE;
      name = "SHORT";
      break;
    case LONG:
      size = LONG_SIZE;
      name = "LONG";
      break;
    case QUAD:
      size = QUAD_SIZE;
      name = "QUAD";
      break;
    case SQUAD:
      size = QUAD_SIZE;
      name = "SQUAD";
      break;
    }

  minfo ("0x%V %W %s 0x%v", addr, size, name, data->value);

  if (data->exp->type.node_class != etree_value)
    {
      print_space ();
      exp_print_tree (data->exp);
    }

  print_nl ();

  print_dot = addr + TO_ADDR (size);
}

/* Print an address statement.  These are generated by options like
   -Ttext.  */

static void
print_address_statement (lang_address_statement_type *address)
{
  minfo (_("Address of section %s set to "), address->section_name);
  exp_print_tree (address->address);
  print_nl ();
}

/* Print a reloc statement.  */

static void
print_reloc_statement (lang_reloc_statement_type *reloc)
{
  int i;
  bfd_vma addr;
  bfd_size_type size;

  init_opb ();
  for (i = 0; i < SECTION_NAME_MAP_LENGTH; i++)
    print_space ();

  addr = reloc->output_vma;
  if (reloc->output_section != NULL)
    addr += reloc->output_section->vma;

  size = bfd_get_reloc_size (reloc->howto);

  minfo ("0x%V %W RELOC %s ", addr, size, reloc->howto->name);

  if (reloc->name != NULL)
    minfo ("%s+", reloc->name);
  else
    minfo ("%s+", reloc->section->name);

  exp_print_tree (reloc->addend_exp);

  print_nl ();

  print_dot = addr + TO_ADDR (size);
}

static void
print_padding_statement (lang_padding_statement_type *s)
{
  int len;
  bfd_vma addr;

  init_opb ();
  minfo (" *fill*");

  len = sizeof " *fill*" - 1;
  while (len < SECTION_NAME_MAP_LENGTH)
    {
      print_space ();
      ++len;
    }

  addr = s->output_offset;
  if (s->output_section != NULL)
    addr += s->output_section->vma;
  minfo ("0x%V %W ", addr, s->size);

  if (s->fill->size != 0)
    {
      size_t size;
      unsigned char *p;
      for (p = s->fill->data, size = s->fill->size; size != 0; p++, size--)
	fprintf (config.map_file, "%02x", *p);
    }

  print_nl ();

  print_dot = addr + TO_ADDR (s->size);
}

static void
print_wild_statement (lang_wild_statement_type *w,
		      lang_output_section_statement_type *os)
{
  struct wildcard_list *sec;

  print_space ();

  if (w->filenames_sorted)
    minfo ("SORT(");
  if (w->filename != NULL)
    minfo ("%s", w->filename);
  else
    minfo ("*");
  if (w->filenames_sorted)
    minfo (")");

  minfo ("(");
  for (sec = w->section_list; sec; sec = sec->next)
    {
      if (sec->spec.sorted)
	minfo ("SORT(");
      if (sec->spec.exclude_name_list != NULL)
	{
	  name_list *tmp;
	  minfo ("EXCLUDE_FILE(%s", sec->spec.exclude_name_list->name);
	  for (tmp = sec->spec.exclude_name_list->next; tmp; tmp = tmp->next)
	    minfo (" %s", tmp->name);
	  minfo (") ");
	}
      if (sec->spec.name != NULL)
	minfo ("%s", sec->spec.name);
      else
	minfo ("*");
      if (sec->spec.sorted)
	minfo (")");
      if (sec->next)
	minfo (" ");
    }
  minfo (")");

  print_nl ();

  print_statement_list (w->children.head, os);
}

/* Print a group statement.  */

static void
print_group (lang_group_statement_type *s,
	     lang_output_section_statement_type *os)
{
  fprintf (config.map_file, "START GROUP\n");
  print_statement_list (s->children.head, os);
  fprintf (config.map_file, "END GROUP\n");
}

/* Print the list of statements in S.
   This can be called for any statement type.  */

static void
print_statement_list (lang_statement_union_type *s,
		      lang_output_section_statement_type *os)
{
  while (s != NULL)
    {
      print_statement (s, os);
      s = s->header.next;
    }
}

/* Print the first statement in statement list S.
   This can be called for any statement type.  */

static void
print_statement (lang_statement_union_type *s,
		 lang_output_section_statement_type *os)
{
  switch (s->header.type)
    {
    default:
      fprintf (config.map_file, _("Fail with %d\n"), s->header.type);
      FAIL ();
      break;
    case lang_constructors_statement_enum:
      if (constructor_list.head != NULL)
	{
	  if (constructors_sorted)
	    minfo (" SORT (CONSTRUCTORS)\n");
	  else
	    minfo (" CONSTRUCTORS\n");
	  print_statement_list (constructor_list.head, os);
	}
      break;
    case lang_wild_statement_enum:
      print_wild_statement (&s->wild_statement, os);
      break;
    case lang_address_statement_enum:
      print_address_statement (&s->address_statement);
      break;
    case lang_object_symbols_statement_enum:
      minfo (" CREATE_OBJECT_SYMBOLS\n");
      break;
    case lang_fill_statement_enum:
      print_fill_statement (&s->fill_statement);
      break;
    case lang_data_statement_enum:
      print_data_statement (&s->data_statement);
      break;
    case lang_reloc_statement_enum:
      print_reloc_statement (&s->reloc_statement);
      break;
    case lang_input_section_enum:
      print_input_section (&s->input_section);
      break;
    case lang_padding_statement_enum:
      print_padding_statement (&s->padding_statement);
      break;
    case lang_output_section_statement_enum:
      print_output_section_statement (&s->output_section_statement);
      break;
    case lang_assignment_statement_enum:
      print_assignment (&s->assignment_statement, os);
      break;
    case lang_target_statement_enum:
      fprintf (config.map_file, "TARGET(%s)\n", s->target_statement.target);
      break;
    case lang_output_statement_enum:
      minfo ("OUTPUT(%s", s->output_statement.name);
      if (output_target != NULL)
	minfo (" %s", output_target);
      minfo (")\n");
      break;
    case lang_input_statement_enum:
      print_input_statement (&s->input_statement);
      break;
    case lang_group_statement_enum:
      print_group (&s->group_statement, os);
      break;
    case lang_afile_asection_pair_statement_enum:
      FAIL ();
      break;
    }
}

static void
print_statements (void)
{
  print_statement_list (statement_list.head, abs_output_section);
}

/* Print the first N statements in statement list S to STDERR.
   If N == 0, nothing is printed.
   If N < 0, the entire list is printed.
   Intended to be called from GDB.  */

void
dprint_statement (lang_statement_union_type *s, int n)
{
  FILE *map_save = config.map_file;

  config.map_file = stderr;

  if (n < 0)
    print_statement_list (s, abs_output_section);
  else
    {
      while (s && --n >= 0)
	{
	  print_statement (s, abs_output_section);
	  s = s->header.next;
	}
    }

  config.map_file = map_save;
}

static void
insert_pad (lang_statement_union_type **ptr,
	    fill_type *fill,
	    unsigned int alignment_needed,
	    asection *output_section,
	    bfd_vma dot)
{
  static fill_type zero_fill = { 1, { 0 } };
  lang_statement_union_type *pad;

  pad = ((lang_statement_union_type *)
	 ((char *) ptr - offsetof (lang_statement_union_type, header.next)));
  if (ptr != &statement_list.head
      && pad->header.type == lang_padding_statement_enum
      && pad->padding_statement.output_section == output_section)
    {
      /* Use the existing pad statement.  The above test on output
	 section is probably redundant, but it doesn't hurt to check.  */
    }
  else
    {
      /* Make a new padding statement, linked into existing chain.  */
      pad = stat_alloc (sizeof (lang_padding_statement_type));
      pad->header.next = *ptr;
      *ptr = pad;
      pad->header.type = lang_padding_statement_enum;
      pad->padding_statement.output_section = output_section;
      if (fill == NULL)
	fill = &zero_fill;
      pad->padding_statement.fill = fill;
    }
  pad->padding_statement.output_offset = dot - output_section->vma;
  pad->padding_statement.size = alignment_needed;
  output_section->_raw_size += alignment_needed;
}

/* Work out how much this section will move the dot point.  */

static bfd_vma
size_input_section (lang_statement_union_type **this_ptr,
		    lang_output_section_statement_type *output_section_statement,
		    fill_type *fill,
		    bfd_vma dot)
{
  lang_input_section_type *is = &((*this_ptr)->input_section);
  asection *i = is->section;

  if (!is->ifile->just_syms_flag)
    {
      unsigned int alignment_needed;
      asection *o;

      /* Align this section first to the input sections requirement,
	 then to the output section's requirement.  If this alignment
	 is greater than any seen before, then record it too.  Perform
	 the alignment by inserting a magic 'padding' statement.  */

      if (output_section_statement->subsection_alignment != -1)
	i->alignment_power = output_section_statement->subsection_alignment;

      o = output_section_statement->bfd_section;
      if (o->alignment_power < i->alignment_power)
	o->alignment_power = i->alignment_power;

      alignment_needed = align_power (dot, i->alignment_power) - dot;

      if (alignment_needed != 0)
	{
	  insert_pad (this_ptr, fill, TO_SIZE (alignment_needed), o, dot);
	  dot += alignment_needed;
	}

      /* Remember where in the output section this input section goes.  */

      i->output_offset = dot - o->vma;

      /* Mark how big the output section must be to contain this now.  */
      if (i->_cooked_size != 0)
	dot += TO_ADDR (i->_cooked_size);
      else
	dot += TO_ADDR (i->_raw_size);
      o->_raw_size = TO_SIZE (dot - o->vma);
    }
  else
    {
      i->output_offset = i->vma - output_section_statement->bfd_section->vma;
    }

  return dot;
}

#define IGNORE_SECTION(bfd, s) \
  (((bfd_get_section_flags (bfd, s) & SEC_THREAD_LOCAL)			\
    ? ((bfd_get_section_flags (bfd, s) & (SEC_LOAD | SEC_NEVER_LOAD))	\
       != SEC_LOAD)							\
    :  ((bfd_get_section_flags (bfd, s) & (SEC_ALLOC | SEC_NEVER_LOAD)) \
	!= SEC_ALLOC))							\
   || bfd_section_size (bfd, s) == 0)

/* Check to see if any allocated sections overlap with other allocated
   sections.  This can happen when the linker script specifically specifies
   the output section addresses of the two sections.  */

static void
lang_check_section_addresses (void)
{
  asection *s;

  /* Scan all sections in the output list.  */
  for (s = output_bfd->sections; s != NULL; s = s->next)
    {
      asection *os;

      /* Ignore sections which are not loaded or which have no contents.  */
      if (IGNORE_SECTION (output_bfd, s))
	continue;

      /* Once we reach section 's' stop our seach.  This prevents two
	 warning messages from being produced, one for 'section A overlaps
	 section B' and one for 'section B overlaps section A'.  */
      for (os = output_bfd->sections; os != s; os = os->next)
	{
	  bfd_vma s_start;
	  bfd_vma s_end;
	  bfd_vma os_start;
	  bfd_vma os_end;

	  /* Only consider loadable sections with real contents.  */
	  if (IGNORE_SECTION (output_bfd, os))
	    continue;

	  /* We must check the sections' LMA addresses not their
	     VMA addresses because overlay sections can have
	     overlapping VMAs but they must have distinct LMAs.  */
	  s_start = bfd_section_lma (output_bfd, s);
	  os_start = bfd_section_lma (output_bfd, os);
	  s_end = s_start + TO_ADDR (bfd_section_size (output_bfd, s)) - 1;
	  os_end = os_start + TO_ADDR (bfd_section_size (output_bfd, os)) - 1;

	  /* Look for an overlap.  */
	  if ((s_end < os_start) || (s_start > os_end))
	    continue;

	  einfo (
_("%X%P: section %s [%V -> %V] overlaps section %s [%V -> %V]\n"),
		 s->name, s_start, s_end, os->name, os_start, os_end);

	  /* Once we have found one overlap for this section,
	     stop looking for others.  */
	  break;
	}
    }
}

/* Make sure the new address is within the region.  We explicitly permit the
   current address to be at the exact end of the region when the address is
   non-zero, in case the region is at the end of addressable memory and the
   calculation wraps around.  */

static void
os_region_check (lang_output_section_statement_type *os,
		 lang_memory_region_type *region,
		 etree_type *tree,
		 bfd_vma base)
{
  if ((region->current < region->origin
       || (region->current - region->origin > region->length))
      && ((region->current != region->origin + region->length)
	  || base == 0))
    {
      if (tree != NULL)
	{
	  einfo (_("%X%P: address 0x%v of %B section %s is not within region %s\n"),
		 region->current,
		 os->bfd_section->owner,
		 os->bfd_section->name,
		 region->name);
	}
      else
	{
	  einfo (_("%X%P: region %s is full (%B section %s)\n"),
		 region->name,
		 os->bfd_section->owner,
		 os->bfd_section->name);
	}
      /* Reset the region pointer.  */
      region->current = region->origin;
    }
}

/* Set the sizes for all the output sections.  */

static bfd_vma
lang_size_sections_1
  (lang_statement_union_type *s,
   lang_output_section_statement_type *output_section_statement,
   lang_statement_union_type **prev,
   fill_type *fill,
   bfd_vma dot,
   bfd_boolean *relax,
   bfd_boolean check_regions)
{
  /* Size up the sections from their constituent parts.  */
  for (; s != NULL; s = s->header.next)
    {
      switch (s->header.type)
	{
	case lang_output_section_statement_enum:
	  {
	    bfd_vma after;
	    lang_output_section_statement_type *os;

	    os = &s->output_section_statement;
	    if (os->bfd_section == NULL)
	      /* This section was never actually created.  */
	      break;

	    /* If this is a COFF shared library section, use the size and
	       address from the input section.  FIXME: This is COFF
	       specific; it would be cleaner if there were some other way
	       to do this, but nothing simple comes to mind.  */
	    if ((os->bfd_section->flags & SEC_COFF_SHARED_LIBRARY) != 0)
	      {
		asection *input;

		if (os->children.head == NULL
		    || os->children.head->header.next != NULL
		    || os->children.head->header.type != lang_input_section_enum)
		  einfo (_("%P%X: Internal error on COFF shared library section %s\n"),
			 os->name);

		input = os->children.head->input_section.section;
		bfd_set_section_vma (os->bfd_section->owner,
				     os->bfd_section,
				     bfd_section_vma (input->owner, input));
		os->bfd_section->_raw_size = input->_raw_size;
		break;
	      }

	    if (bfd_is_abs_section (os->bfd_section))
	      {
		/* No matter what happens, an abs section starts at zero.  */
		ASSERT (os->bfd_section->vma == 0);
	      }
	    else
	      {
		if (os->addr_tree == NULL)
		  {
		    /* No address specified for this section, get one
		       from the region specification.  */
		    if (os->region == NULL
			|| (((bfd_get_section_flags (output_bfd, os->bfd_section)
			      & (SEC_ALLOC | SEC_LOAD)) != 0)
			    && os->region->name[0] == '*'
			    && strcmp (os->region->name, DEFAULT_MEMORY_REGION) == 0))
		      {
			os->region = lang_memory_default (os->bfd_section);
		      }

		    /* If a loadable section is using the default memory
		       region, and some non default memory regions were
		       defined, issue an error message.  */
		    if (!IGNORE_SECTION (output_bfd, os->bfd_section)
			&& ! link_info.relocatable
			&& check_regions
			&& strcmp (os->region->name, DEFAULT_MEMORY_REGION) == 0
			&& lang_memory_region_list != NULL
			&& (strcmp (lang_memory_region_list->name,
				    DEFAULT_MEMORY_REGION) != 0
			    || lang_memory_region_list->next != NULL))
		      {
			/* By default this is an error rather than just a
			   warning because if we allocate the section to the
			   default memory region we can end up creating an
			   excessively large binary, or even seg faulting when
			   attempting to perform a negative seek.  See
			     http://sources.redhat.com/ml/binutils/2003-04/msg00423.html
			   for an example of this.  This behaviour can be
			   overridden by the using the --no-check-sections
			   switch.  */
			if (command_line.check_section_addresses)
			  einfo (_("%P%F: error: no memory region specified for loadable section `%s'\n"),
				 bfd_get_section_name (output_bfd,
						       os->bfd_section));
			else
			  einfo (_("%P: warning: no memory region specified for loadable section `%s'\n"),
				 bfd_get_section_name (output_bfd,
						       os->bfd_section));
		      }

		    dot = os->region->current;

		    if (os->section_alignment == -1)
		      {
			bfd_vma olddot;

			olddot = dot;
			dot = align_power (dot,
					   os->bfd_section->alignment_power);

			if (dot != olddot && config.warn_section_align)
			  einfo (_("%P: warning: changing start of section %s by %u bytes\n"),
				 os->name, (unsigned int) (dot - olddot));
		      }
		  }
		else
		  {
		    etree_value_type r;

		    os->processed = -1;
		    r = exp_fold_tree (os->addr_tree,
				       abs_output_section,
				       lang_allocating_phase_enum,
				       dot, &dot);
		    os->processed = 0;
		    
		    if (!r.valid_p)
		      einfo (_("%F%S: non constant or forward reference address expression for section %s\n"),
			     os->name);

		    dot = r.value + r.section->bfd_section->vma;
		  }

		/* The section starts here.
		   First, align to what the section needs.  */

		if (os->section_alignment != -1)
		  dot = align_power (dot, os->section_alignment);

		bfd_set_section_vma (0, os->bfd_section, dot);

		os->bfd_section->output_offset = 0;
	      }

	    lang_size_sections_1 (os->children.head, os, &os->children.head,
				  os->fill, dot, relax, check_regions);

	    /* Put the section within the requested block size, or
	       align at the block boundary.  */
	    after = ((os->bfd_section->vma
		      + TO_ADDR (os->bfd_section->_raw_size)
		      + os->block_value - 1)
		     & - (bfd_vma) os->block_value);

	    if (bfd_is_abs_section (os->bfd_section))
	      ASSERT (after == os->bfd_section->vma);
	    else
	      os->bfd_section->_raw_size
		= TO_SIZE (after - os->bfd_section->vma);

	    dot = os->bfd_section->vma;
	    /* .tbss sections effectively have zero size.  */
	    if ((os->bfd_section->flags & SEC_HAS_CONTENTS) != 0
		|| (os->bfd_section->flags & SEC_THREAD_LOCAL) == 0
		|| link_info.relocatable)
	      dot += TO_ADDR (os->bfd_section->_raw_size);

	    os->processed = 1;

	    if (os->update_dot_tree != 0)
	      exp_fold_tree (os->update_dot_tree, abs_output_section,
			     lang_allocating_phase_enum, dot, &dot);

	    /* Update dot in the region ?
	       We only do this if the section is going to be allocated,
	       since unallocated sections do not contribute to the region's
	       overall size in memory.

	       If the SEC_NEVER_LOAD bit is not set, it will affect the
	       addresses of sections after it. We have to update
	       dot.  */
	    if (os->region != NULL
		&& ((bfd_get_section_flags (output_bfd, os->bfd_section)
		     & SEC_NEVER_LOAD) == 0
		    || (bfd_get_section_flags (output_bfd, os->bfd_section)
			& (SEC_ALLOC | SEC_LOAD))))
	      {
		os->region->current = dot;

		if (check_regions)
		  /* Make sure the new address is within the region.  */
		  os_region_check (os, os->region, os->addr_tree,
				   os->bfd_section->vma);

		/* If there's no load address specified, use the run
		   region as the load region.  */
		if (os->lma_region == NULL && os->load_base == NULL)
		  os->lma_region = os->region;

		if (os->lma_region != NULL && os->lma_region != os->region)
		  {
		    /* Set load_base, which will be handled later.  */
		    os->load_base = exp_intop (os->lma_region->current);
		    os->lma_region->current +=
		      TO_ADDR (os->bfd_section->_raw_size);
		    if (check_regions)
		      os_region_check (os, os->lma_region, NULL,
				       os->bfd_section->lma);
		  }
	      }
	  }
	  break;

	case lang_constructors_statement_enum:
	  dot = lang_size_sections_1 (constructor_list.head,
				      output_section_statement,
				      &s->wild_statement.children.head,
				      fill, dot, relax, check_regions);
	  break;

	case lang_data_statement_enum:
	  {
	    unsigned int size = 0;

	    s->data_statement.output_vma =
	      dot - output_section_statement->bfd_section->vma;
	    s->data_statement.output_section =
	      output_section_statement->bfd_section;

	    /* We might refer to provided symbols in the expression, and
	       need to mark them as needed.  */
	    exp_fold_tree (s->data_statement.exp, abs_output_section,
			   lang_allocating_phase_enum, dot, &dot);

	    switch (s->data_statement.type)
	      {
	      default:
		abort ();
	      case QUAD:
	      case SQUAD:
		size = QUAD_SIZE;
		break;
	      case LONG:
		size = LONG_SIZE;
		break;
	      case SHORT:
		size = SHORT_SIZE;
		break;
	      case BYTE:
		size = BYTE_SIZE;
		break;
	      }
	    if (size < TO_SIZE ((unsigned) 1))
	      size = TO_SIZE ((unsigned) 1);
	    dot += TO_ADDR (size);
	    output_section_statement->bfd_section->_raw_size += size;
	    /* The output section gets contents, and then we inspect for
	       any flags set in the input script which override any ALLOC.  */
	    output_section_statement->bfd_section->flags |= SEC_HAS_CONTENTS;
	    if (!(output_section_statement->flags & SEC_NEVER_LOAD))
	      {
		output_section_statement->bfd_section->flags |=
		  SEC_ALLOC | SEC_LOAD;
	      }
	  }
	  break;

	case lang_reloc_statement_enum:
	  {
	    int size;

	    s->reloc_statement.output_vma =
	      dot - output_section_statement->bfd_section->vma;
	    s->reloc_statement.output_section =
	      output_section_statement->bfd_section;
	    size = bfd_get_reloc_size (s->reloc_statement.howto);
	    dot += TO_ADDR (size);
	    output_section_statement->bfd_section->_raw_size += size;
	  }
	  break;

	case lang_wild_statement_enum:

	  dot = lang_size_sections_1 (s->wild_statement.children.head,
				      output_section_statement,
				      &s->wild_statement.children.head,
				      fill, dot, relax, check_regions);

	  break;

	case lang_object_symbols_statement_enum:
	  link_info.create_object_symbols_section =
	    output_section_statement->bfd_section;
	  break;
	case lang_output_statement_enum:
	case lang_target_statement_enum:
	  break;
	case lang_input_section_enum:
	  {
	    asection *i;

	    i = (*prev)->input_section.section;
	    if (! relax)
	      {
		if (i->_cooked_size == 0)
		  i->_cooked_size = i->_raw_size;
	      }
	    else
	      {
		bfd_boolean again;

		if (! bfd_relax_section (i->owner, i, &link_info, &again))
		  einfo (_("%P%F: can't relax section: %E\n"));
		if (again)
		  *relax = TRUE;
	      }
	    dot = size_input_section (prev, output_section_statement,
				      output_section_statement->fill, dot);
	  }
	  break;
	case lang_input_statement_enum:
	  break;
	case lang_fill_statement_enum:
	  s->fill_statement.output_section =
	    output_section_statement->bfd_section;

	  fill = s->fill_statement.fill;
	  break;
	case lang_assignment_statement_enum:
	  {
	    bfd_vma newdot = dot;

	    exp_fold_tree (s->assignment_statement.exp,
			   output_section_statement,
			   lang_allocating_phase_enum,
			   dot,
			   &newdot);

	    if (newdot != dot)
	      {
		if (output_section_statement == abs_output_section)
		  {
		    /* If we don't have an output section, then just adjust
		       the default memory address.  */
		    lang_memory_region_lookup (DEFAULT_MEMORY_REGION, FALSE)->current = newdot;
		  }
		else
		  {
		    /* Insert a pad after this statement.  We can't
		       put the pad before when relaxing, in case the
		       assignment references dot.  */
		    insert_pad (&s->header.next, fill, TO_SIZE (newdot - dot),
				output_section_statement->bfd_section, dot);

		    /* Don't neuter the pad below when relaxing.  */
		    s = s->header.next;
		  }

		/* If dot is advanced, this implies that the section should
		   have space allocated to it, unless the user has explicitly
		   stated that the section should never be loaded.  */
		if (!(output_section_statement->flags & (SEC_NEVER_LOAD | SEC_ALLOC)))
		  output_section_statement->bfd_section->flags |= SEC_ALLOC;

		dot = newdot;
	      }
	  }
	  break;

	case lang_padding_statement_enum:
	  /* If this is the first time lang_size_sections is called,
	     we won't have any padding statements.  If this is the
	     second or later passes when relaxing, we should allow
	     padding to shrink.  If padding is needed on this pass, it
	     will be added back in.  */
	  s->padding_statement.size = 0;

	  /* Make sure output_offset is valid.  If relaxation shrinks
	     the section and this pad isn't needed, it's possible to
	     have output_offset larger than the final size of the
	     section.  bfd_set_section_contents will complain even for
	     a pad size of zero.  */
	  s->padding_statement.output_offset
	    = dot - output_section_statement->bfd_section->vma;
	  break;

	case lang_group_statement_enum:
	  dot = lang_size_sections_1 (s->group_statement.children.head,
				      output_section_statement,
				      &s->group_statement.children.head,
				      fill, dot, relax, check_regions);
	  break;

	default:
	  FAIL ();
	  break;

	  /* We can only get here when relaxing is turned on.  */
	case lang_address_statement_enum:
	  break;
	}
      prev = &s->header.next;
    }
  return dot;
}

bfd_vma
lang_size_sections
  (lang_statement_union_type *s,
   lang_output_section_statement_type *output_section_statement,
   lang_statement_union_type **prev,
   fill_type *fill,
   bfd_vma dot,
   bfd_boolean *relax,
   bfd_boolean check_regions)
{
  bfd_vma result;
  asection *o;

  /* Callers of exp_fold_tree need to increment this.  */
  lang_statement_iteration++;

  exp_data_seg.phase = exp_dataseg_none;
  result = lang_size_sections_1 (s, output_section_statement, prev, fill,
				 dot, relax, check_regions);
  if (exp_data_seg.phase == exp_dataseg_end_seen)
    {
      /* If DATA_SEGMENT_ALIGN DATA_SEGMENT_END pair was seen, check whether
	 a page could be saved in the data segment.  */
      bfd_vma first, last;

      first = -exp_data_seg.base & (exp_data_seg.pagesize - 1);
      last = exp_data_seg.end & (exp_data_seg.pagesize - 1);
      if (first && last
	  && ((exp_data_seg.base & ~(exp_data_seg.pagesize - 1))
	      != (exp_data_seg.end & ~(exp_data_seg.pagesize - 1)))
	  && first + last <= exp_data_seg.pagesize)
	{
	  exp_data_seg.phase = exp_dataseg_adjust;
	  lang_statement_iteration++;
	  result = lang_size_sections_1 (s, output_section_statement, prev,
					 fill, dot, relax, check_regions);
	}
    }

  /* Some backend relaxers want to refer to the output section size.  Give
     them a section size that does not change on the next call while they
     relax.  We can't set this at top because lang_reset_memory_regions
     which is called before we get here, sets _raw_size to 0 on relaxing
     rounds.  */
  for (o = output_bfd->sections; o != NULL; o = o->next)
    o->_cooked_size = o->_raw_size;

  return result;
}

/* Worker function for lang_do_assignments.  Recursiveness goes here.  */

static bfd_vma
lang_do_assignments_1
  (lang_statement_union_type *s,
   lang_output_section_statement_type *output_section_statement,
   fill_type *fill,
   bfd_vma dot)
{
  for (; s != NULL; s = s->header.next)
    {
      switch (s->header.type)
	{
	case lang_constructors_statement_enum:
	  dot = lang_do_assignments_1 (constructor_list.head,
				       output_section_statement,
				       fill,
				       dot);
	  break;

	case lang_output_section_statement_enum:
	  {
	    lang_output_section_statement_type *os;

	    os = &(s->output_section_statement);
	    if (os->bfd_section != NULL)
	      {
		dot = os->bfd_section->vma;
		lang_do_assignments_1 (os->children.head, os, os->fill, dot);
		dot = (os->bfd_section->vma
		       + TO_ADDR (os->bfd_section->_raw_size));

	      }
	    if (os->load_base)
	      {
		/* If nothing has been placed into the output section then
		   it won't have a bfd_section.  */
		if (os->bfd_section)
		  {
		    os->bfd_section->lma
		      = exp_get_abs_int (os->load_base, 0, "load base",
					 lang_final_phase_enum);
		  }
	      }
	  }
	  break;
	case lang_wild_statement_enum:

	  dot = lang_do_assignments_1 (s->wild_statement.children.head,
				       output_section_statement,
				       fill, dot);

	  break;

	case lang_object_symbols_statement_enum:
	case lang_output_statement_enum:
	case lang_target_statement_enum:
#if 0
	case lang_common_statement_enum:
#endif
	  break;
	case lang_data_statement_enum:
	  {
	    etree_value_type value;

	    value = exp_fold_tree (s->data_statement.exp,
				   abs_output_section,
				   lang_final_phase_enum, dot, &dot);
	    if (!value.valid_p)
	      einfo (_("%F%P: invalid data statement\n"));
	    s->data_statement.value
	      = value.value + value.section->bfd_section->vma;
	  }
	  {
	    unsigned int size;
	    switch (s->data_statement.type)
	      {
	      default:
		abort ();
	      case QUAD:
	      case SQUAD:
		size = QUAD_SIZE;
		break;
	      case LONG:
		size = LONG_SIZE;
		break;
	      case SHORT:
		size = SHORT_SIZE;
		break;
	      case BYTE:
		size = BYTE_SIZE;
		break;
	      }
	    if (size < TO_SIZE ((unsigned) 1))
	      size = TO_SIZE ((unsigned) 1);
	    dot += TO_ADDR (size);
	  }
	  break;

	case lang_reloc_statement_enum:
	  {
	    etree_value_type value;

	    value = exp_fold_tree (s->reloc_statement.addend_exp,
				   abs_output_section,
				   lang_final_phase_enum, dot, &dot);
	    s->reloc_statement.addend_value = value.value;
	    if (!value.valid_p)
	      einfo (_("%F%P: invalid reloc statement\n"));
	  }
	  dot += TO_ADDR (bfd_get_reloc_size (s->reloc_statement.howto));
	  break;

	case lang_input_section_enum:
	  {
	    asection *in = s->input_section.section;

	    if (in->_cooked_size != 0)
	      dot += TO_ADDR (in->_cooked_size);
	    else
	      dot += TO_ADDR (in->_raw_size);
	  }
	  break;

	case lang_input_statement_enum:
	  break;
	case lang_fill_statement_enum:
	  fill = s->fill_statement.fill;
	  break;
	case lang_assignment_statement_enum:
	  {
	    exp_fold_tree (s->assignment_statement.exp,
			   output_section_statement,
			   lang_final_phase_enum,
			   dot,
			   &dot);
	  }

	  break;
	case lang_padding_statement_enum:
	  dot += TO_ADDR (s->padding_statement.size);
	  break;

	case lang_group_statement_enum:
	  dot = lang_do_assignments_1 (s->group_statement.children.head,
				       output_section_statement,
				       fill, dot);

	  break;

	default:
	  FAIL ();
	  break;
	case lang_address_statement_enum:
	  break;
	}

    }
  return dot;
}

void
lang_do_assignments (lang_statement_union_type *s,
		     lang_output_section_statement_type *output_section_statement,
		     fill_type *fill,
		     bfd_vma dot)
{
  /* Callers of exp_fold_tree need to increment this.  */
  lang_statement_iteration++;
  lang_do_assignments_1 (s, output_section_statement, fill, dot);
}

/* Fix any .startof. or .sizeof. symbols.  When the assemblers see the
   operator .startof. (section_name), it produces an undefined symbol
   .startof.section_name.  Similarly, when it sees
   .sizeof. (section_name), it produces an undefined symbol
   .sizeof.section_name.  For all the output sections, we look for
   such symbols, and set them to the correct value.  */

static void
lang_set_startof (void)
{
  asection *s;

  if (link_info.relocatable)
    return;

  for (s = output_bfd->sections; s != NULL; s = s->next)
    {
      const char *secname;
      char *buf;
      struct bfd_link_hash_entry *h;

      secname = bfd_get_section_name (output_bfd, s);
      buf = xmalloc (10 + strlen (secname));

      sprintf (buf, ".startof.%s", secname);
      h = bfd_link_hash_lookup (link_info.hash, buf, FALSE, FALSE, TRUE);
      if (h != NULL && h->type == bfd_link_hash_undefined)
	{
	  h->type = bfd_link_hash_defined;
	  h->u.def.value = bfd_get_section_vma (output_bfd, s);
	  h->u.def.section = bfd_abs_section_ptr;
	}

      sprintf (buf, ".sizeof.%s", secname);
      h = bfd_link_hash_lookup (link_info.hash, buf, FALSE, FALSE, TRUE);
      if (h != NULL && h->type == bfd_link_hash_undefined)
	{
	  h->type = bfd_link_hash_defined;
	  if (s->_cooked_size != 0)
	    h->u.def.value = TO_ADDR (s->_cooked_size);
	  else
	    h->u.def.value = TO_ADDR (s->_raw_size);
	  h->u.def.section = bfd_abs_section_ptr;
	}

      free (buf);
    }
}

static void
lang_finish (void)
{
  struct bfd_link_hash_entry *h;
  bfd_boolean warn;

  if (link_info.relocatable || link_info.shared)
    warn = FALSE;
  else
    warn = TRUE;

  if (entry_symbol.name == NULL)
    {
      /* No entry has been specified.  Look for start, but don't warn
	 if we don't find it.  */
      entry_symbol.name = "start";
      warn = FALSE;
    }

  h = bfd_link_hash_lookup (link_info.hash, entry_symbol.name,
			    FALSE, FALSE, TRUE);
  if (h != NULL
      && (h->type == bfd_link_hash_defined
	  || h->type == bfd_link_hash_defweak)
      && h->u.def.section->output_section != NULL)
    {
      bfd_vma val;

      val = (h->u.def.value
	     + bfd_get_section_vma (output_bfd,
				    h->u.def.section->output_section)
	     + h->u.def.section->output_offset);
      if (! bfd_set_start_address (output_bfd, val))
	einfo (_("%P%F:%s: can't set start address\n"), entry_symbol.name);
    }
  else
    {
      bfd_vma val;
      const char *send;

      /* We couldn't find the entry symbol.  Try parsing it as a
         number.  */
      val = bfd_scan_vma (entry_symbol.name, &send, 0);
      if (*send == '\0')
	{
	  if (! bfd_set_start_address (output_bfd, val))
	    einfo (_("%P%F: can't set start address\n"));
	}
      else
	{
	  asection *ts;

	  /* Can't find the entry symbol, and it's not a number.  Use
	     the first address in the text section.  */
	  ts = bfd_get_section_by_name (output_bfd, entry_section);
	  if (ts != NULL)
	    {
	      if (warn)
		einfo (_("%P: warning: cannot find entry symbol %s; defaulting to %V\n"),
		       entry_symbol.name,
		       bfd_get_section_vma (output_bfd, ts));
	      if (! bfd_set_start_address (output_bfd,
					   bfd_get_section_vma (output_bfd,
								ts)))
		einfo (_("%P%F: can't set start address\n"));
	    }
	  else
	    {
	      if (warn)
		einfo (_("%P: warning: cannot find entry symbol %s; not setting start address\n"),
		       entry_symbol.name);
	    }
	}
    }

  bfd_hash_table_free (&lang_definedness_table);
}

/* This is a small function used when we want to ignore errors from
   BFD.  */

static void
ignore_bfd_errors (const char *s ATTRIBUTE_UNUSED, ...)
{
  /* Don't do anything.  */
}

/* Check that the architecture of all the input files is compatible
   with the output file.  Also call the backend to let it do any
   other checking that is needed.  */

static void
lang_check (void)
{
  lang_statement_union_type *file;
  bfd *input_bfd;
  const bfd_arch_info_type *compatible;

  for (file = file_chain.head; file != NULL; file = file->input_statement.next)
    {
      input_bfd = file->input_statement.the_bfd;
      compatible = bfd_arch_get_compatible (input_bfd, output_bfd,
					    command_line.accept_unknown_input_arch);

      /* In general it is not possible to perform a relocatable
	 link between differing object formats when the input
	 file has relocations, because the relocations in the
	 input format may not have equivalent representations in
	 the output format (and besides BFD does not translate
	 relocs for other link purposes than a final link).  */
      if ((link_info.relocatable || link_info.emitrelocations)
	  && (compatible == NULL
	      || bfd_get_flavour (input_bfd) != bfd_get_flavour (output_bfd))
	  && (bfd_get_file_flags (input_bfd) & HAS_RELOC) != 0)
	{
	  einfo (_("%P%F: Relocatable linking with relocations from format %s (%B) to format %s (%B) is not supported\n"),
		 bfd_get_target (input_bfd), input_bfd,
		 bfd_get_target (output_bfd), output_bfd);
	  /* einfo with %F exits.  */
	}

      if (compatible == NULL)
	{
	  if (command_line.warn_mismatch)
	    einfo (_("%P: warning: %s architecture of input file `%B' is incompatible with %s output\n"),
		   bfd_printable_name (input_bfd), input_bfd,
		   bfd_printable_name (output_bfd));
	}
      else if (bfd_count_sections (input_bfd))
	{
	  /* If the input bfd has no contents, it shouldn't set the
	     private data of the output bfd.  */

	  bfd_error_handler_type pfn = NULL;

	  /* If we aren't supposed to warn about mismatched input
             files, temporarily set the BFD error handler to a
             function which will do nothing.  We still want to call
             bfd_merge_private_bfd_data, since it may set up
             information which is needed in the output file.  */
	  if (! command_line.warn_mismatch)
	    pfn = bfd_set_error_handler (ignore_bfd_errors);
	  if (! bfd_merge_private_bfd_data (input_bfd, output_bfd))
	    {
	      if (command_line.warn_mismatch)
		einfo (_("%P%X: failed to merge target specific data of file %B\n"),
		       input_bfd);
	    }
	  if (! command_line.warn_mismatch)
	    bfd_set_error_handler (pfn);
	}
    }
}

/* Look through all the global common symbols and attach them to the
   correct section.  The -sort-common command line switch may be used
   to roughly sort the entries by size.  */

static void
lang_common (void)
{
  if (command_line.inhibit_common_definition)
    return;
  if (link_info.relocatable
      && ! command_line.force_common_definition)
    return;

  if (! config.sort_common)
    bfd_link_hash_traverse (link_info.hash, lang_one_common, NULL);
  else
    {
      int power;

      for (power = 4; power >= 0; power--)
	bfd_link_hash_traverse (link_info.hash, lang_one_common, &power);
    }
}

/* Place one common symbol in the correct section.  */

static bfd_boolean
lang_one_common (struct bfd_link_hash_entry *h, void *info)
{
  unsigned int power_of_two;
  bfd_vma size;
  asection *section;

  if (h->type != bfd_link_hash_common)
    return TRUE;

  size = h->u.c.size;
  power_of_two = h->u.c.p->alignment_power;

  if (config.sort_common
      && power_of_two < (unsigned int) *(int *) info)
    return TRUE;

  section = h->u.c.p->section;

  /* Increase the size of the section to align the common sym.  */
  section->_cooked_size += ((bfd_vma) 1 << (power_of_two + opb_shift)) - 1;
  section->_cooked_size &= (- (bfd_vma) 1 << (power_of_two + opb_shift));

  /* Adjust the alignment if necessary.  */
  if (power_of_two > section->alignment_power)
    section->alignment_power = power_of_two;

  /* Change the symbol from common to defined.  */
  h->type = bfd_link_hash_defined;
  h->u.def.section = section;
  h->u.def.value = section->_cooked_size;

  /* Increase the size of the section.  */
  section->_cooked_size += size;

  /* Make sure the section is allocated in memory, and make sure that
     it is no longer a common section.  */
  section->flags |= SEC_ALLOC;
  section->flags &= ~SEC_IS_COMMON;

  if (config.map_file != NULL)
    {
      static bfd_boolean header_printed;
      int len;
      char *name;
      char buf[50];

      if (! header_printed)
	{
	  minfo (_("\nAllocating common symbols\n"));
	  minfo (_("Common symbol       size              file\n\n"));
	  header_printed = TRUE;
	}

      name = demangle (h->root.string);
      minfo ("%s", name);
      len = strlen (name);
      free (name);

      if (len >= 19)
	{
	  print_nl ();
	  len = 0;
	}
      while (len < 20)
	{
	  print_space ();
	  ++len;
	}

      minfo ("0x");
      if (size <= 0xffffffff)
	sprintf (buf, "%lx", (unsigned long) size);
      else
	sprintf_vma (buf, size);
      minfo ("%s", buf);
      len = strlen (buf);

      while (len < 16)
	{
	  print_space ();
	  ++len;
	}

      minfo ("%B\n", section->owner);
    }

  return TRUE;
}

/* Run through the input files and ensure that every input section has
   somewhere to go.  If one is found without a destination then create
   an input request and place it into the statement tree.  */

static void
lang_place_orphans (void)
{
  LANG_FOR_EACH_INPUT_STATEMENT (file)
    {
      asection *s;

      for (s = file->the_bfd->sections; s != NULL; s = s->next)
	{
	  if (s->output_section == NULL)
	    {
	      /* This section of the file is not attached, root
	         around for a sensible place for it to go.  */

	      if (file->just_syms_flag)
		{
		  abort ();
		}
	      else if (strcmp (s->name, "COMMON") == 0)
		{
		  /* This is a lonely common section which must have
		     come from an archive.  We attach to the section
		     with the wildcard.  */
		  if (! link_info.relocatable
		      || command_line.force_common_definition)
		    {
		      if (default_common_section == NULL)
			{
#if 0
			  /* This message happens when using the
                             svr3.ifile linker script, so I have
                             disabled it.  */
			  info_msg (_("%P: no [COMMON] command, defaulting to .bss\n"));
#endif
			  default_common_section =
			    lang_output_section_statement_lookup (".bss");

			}
		      lang_add_section (&default_common_section->children, s,
					default_common_section, file);
		    }
		}
	      else if (ldemul_place_orphan (file, s))
		;
	      else
		{
		  lang_output_section_statement_type *os;

		  os = lang_output_section_statement_lookup (s->name);
		  lang_add_section (&os->children, s, os, file);
		}
	    }
	}
    }
}

void
lang_set_flags (lang_memory_region_type *ptr, const char *flags, int invert)
{
  flagword *ptr_flags;

  ptr_flags = invert ? &ptr->not_flags : &ptr->flags;
  while (*flags)
    {
      switch (*flags)
	{
	case 'A': case 'a':
	  *ptr_flags |= SEC_ALLOC;
	  break;

	case 'R': case 'r':
	  *ptr_flags |= SEC_READONLY;
	  break;

	case 'W': case 'w':
	  *ptr_flags |= SEC_DATA;
	  break;

	case 'X': case 'x':
	  *ptr_flags |= SEC_CODE;
	  break;

	case 'L': case 'l':
	case 'I': case 'i':
	  *ptr_flags |= SEC_LOAD;
	  break;

	default:
	  einfo (_("%P%F: invalid syntax in flags\n"));
	  break;
	}
      flags++;
    }
}

/* Call a function on each input file.  This function will be called
   on an archive, but not on the elements.  */

void
lang_for_each_input_file (void (*func) (lang_input_statement_type *))
{
  lang_input_statement_type *f;

  for (f = (lang_input_statement_type *) input_file_chain.head;
       f != NULL;
       f = (lang_input_statement_type *) f->next_real_file)
    func (f);
}

/* Call a function on each file.  The function will be called on all
   the elements of an archive which are included in the link, but will
   not be called on the archive file itself.  */

void
lang_for_each_file (void (*func) (lang_input_statement_type *))
{
  LANG_FOR_EACH_INPUT_STATEMENT (f)
    {
      func (f);
    }
}

void
ldlang_add_file (lang_input_statement_type *entry)
{
  bfd **pp;

  lang_statement_append (&file_chain,
			 (lang_statement_union_type *) entry,
			 &entry->next);

  /* The BFD linker needs to have a list of all input BFDs involved in
     a link.  */
  ASSERT (entry->the_bfd->link_next == NULL);
  ASSERT (entry->the_bfd != output_bfd);
  for (pp = &link_info.input_bfds; *pp != NULL; pp = &(*pp)->link_next)
    ;
  *pp = entry->the_bfd;
  entry->the_bfd->usrdata = entry;
  bfd_set_gp_size (entry->the_bfd, g_switch_value);

  /* Look through the sections and check for any which should not be
     included in the link.  We need to do this now, so that we can
     notice when the backend linker tries to report multiple
     definition errors for symbols which are in sections we aren't
     going to link.  FIXME: It might be better to entirely ignore
     symbols which are defined in sections which are going to be
     discarded.  This would require modifying the backend linker for
     each backend which might set the SEC_LINK_ONCE flag.  If we do
     this, we should probably handle SEC_EXCLUDE in the same way.  */

  bfd_map_over_sections (entry->the_bfd, section_already_linked, entry);
}

void
lang_add_output (const char *name, int from_script)
{
  /* Make -o on command line override OUTPUT in script.  */
  if (!had_output_filename || !from_script)
    {
      output_filename = name;
      had_output_filename = TRUE;
    }
}

static lang_output_section_statement_type *current_section;

static int
topower (int x)
{
  unsigned int i = 1;
  int l;

  if (x < 0)
    return -1;

  for (l = 0; l < 32; l++)
    {
      if (i >= (unsigned int) x)
	return l;
      i <<= 1;
    }

  return 0;
}

lang_output_section_statement_type *
lang_enter_output_section_statement (const char *output_section_statement_name,
				     etree_type *address_exp,
				     enum section_type sectype,
				     etree_type *align,
				     etree_type *subalign,
				     etree_type *ebase)
{
  lang_output_section_statement_type *os;

  current_section =
   os =
    lang_output_section_statement_lookup (output_section_statement_name);

  /* Add this statement to tree.  */
#if 0
  add_statement (lang_output_section_statement_enum,
		 output_section_statement);
#endif
  /* Make next things chain into subchain of this.  */

  if (os->addr_tree == NULL)
    {
      os->addr_tree = address_exp;
    }
  os->sectype = sectype;
  if (sectype != noload_section)
    os->flags = SEC_NO_FLAGS;
  else
    os->flags = SEC_NEVER_LOAD;
  os->block_value = 1;
  stat_ptr = &os->children;

  os->subsection_alignment =
    topower (exp_get_value_int (subalign, -1, "subsection alignment", 0));
  os->section_alignment =
    topower (exp_get_value_int (align, -1, "section alignment", 0));

  os->load_base = ebase;
  return os;
}

void
lang_final (void)
{
  lang_output_statement_type *new =
    new_stat (lang_output_statement, stat_ptr);

  new->name = output_filename;
}

/* Reset the current counters in the regions.  */

void
lang_reset_memory_regions (void)
{
  lang_memory_region_type *p = lang_memory_region_list;
  asection *o;

  for (p = lang_memory_region_list; p != NULL; p = p->next)
    {
      p->old_length = (bfd_size_type) (p->current - p->origin);
      p->current = p->origin;
    }

  for (o = output_bfd->sections; o != NULL; o = o->next)
    o->_raw_size = 0;
}

/* If the wild pattern was marked KEEP, the member sections
   should be as well.  */

static void
gc_section_callback (lang_wild_statement_type *ptr,
		     struct wildcard_list *sec ATTRIBUTE_UNUSED,
		     asection *section,
		     lang_input_statement_type *file ATTRIBUTE_UNUSED,
		     void *data ATTRIBUTE_UNUSED)
{
  if (ptr->keep_sections)
    section->flags |= SEC_KEEP;
}

/* Handle a wild statement, marking it against GC.  */

static void
lang_gc_wild (lang_wild_statement_type *s)
{
  walk_wild (s, gc_section_callback, NULL);
}

/* Iterate over sections marking them against GC.  */

static void
lang_gc_sections_1 (lang_statement_union_type *s)
{
  for (; s != NULL; s = s->header.next)
    {
      switch (s->header.type)
	{
	case lang_wild_statement_enum:
	  lang_gc_wild (&s->wild_statement);
	  break;
	case lang_constructors_statement_enum:
	  lang_gc_sections_1 (constructor_list.head);
	  break;
	case lang_output_section_statement_enum:
	  lang_gc_sections_1 (s->output_section_statement.children.head);
	  break;
	case lang_group_statement_enum:
	  lang_gc_sections_1 (s->group_statement.children.head);
	  break;
	default:
	  break;
	}
    }
}

static void
lang_gc_sections (void)
{
  struct bfd_link_hash_entry *h;
  ldlang_undef_chain_list_type *ulist;

  /* Keep all sections so marked in the link script.  */

  lang_gc_sections_1 (statement_list.head);

  /* Keep all sections containing symbols undefined on the command-line,
     and the section containing the entry symbol.  */

  for (ulist = link_info.gc_sym_list; ulist; ulist = ulist->next)
    {
      h = bfd_link_hash_lookup (link_info.hash, ulist->name,
				FALSE, FALSE, FALSE);

      if (h != NULL
	  && (h->type == bfd_link_hash_defined
	      || h->type == bfd_link_hash_defweak)
	  && ! bfd_is_abs_section (h->u.def.section))
	{
	  h->u.def.section->flags |= SEC_KEEP;
	}
    }

  bfd_gc_sections (output_bfd, &link_info);
}

void
lang_process (void)
{
  lang_reasonable_defaults ();
  current_target = default_target;

  /* Open the output file.  */
  lang_for_each_statement (ldlang_open_output);
  init_opb ();

  ldemul_create_output_section_statements ();

  /* Add to the hash table all undefineds on the command line.  */
  lang_place_undefineds ();

  already_linked_table_init ();

  /* Create a bfd for each input file.  */
  current_target = default_target;
  open_input_bfds (statement_list.head, FALSE);

  link_info.gc_sym_list = &entry_symbol;
  if (entry_symbol.name == NULL)
    link_info.gc_sym_list = ldlang_undef_chain_list_head;

  ldemul_after_open ();

  already_linked_table_free ();

  /* Make sure that we're not mixing architectures.  We call this
     after all the input files have been opened, but before we do any
     other processing, so that any operations merge_private_bfd_data
     does on the output file will be known during the rest of the
     link.  */
  lang_check ();

  /* Handle .exports instead of a version script if we're told to do so.  */
  if (command_line.version_exports_section)
    lang_do_version_exports_section ();

  /* Build all sets based on the information gathered from the input
     files.  */
  ldctor_build_sets ();

  /* Remove unreferenced sections if asked to.  */
  if (command_line.gc_sections)
    lang_gc_sections ();

  /* If there were any SEC_MERGE sections, finish their merging, so that
     section sizes can be computed.  This has to be done after GC of sections,
     so that GCed sections are not merged, but before assigning output
     sections, since removing whole input sections is hard then.  */
  bfd_merge_sections (output_bfd, &link_info);

  /* Size up the common data.  */
  lang_common ();

  /* Run through the contours of the script and attach input sections
     to the correct output sections.  */
  map_input_to_output_sections (statement_list.head, NULL, NULL);

  /* Find any sections not attached explicitly and handle them.  */
  lang_place_orphans ();

  if (! link_info.relocatable)
    {
      /* Look for a text section and set the readonly attribute in it.  */
      asection *found = bfd_get_section_by_name (output_bfd, ".text");

      if (found != NULL)
	{
	  if (config.text_read_only)
	    found->flags |= SEC_READONLY;
	  else
	    found->flags &= ~SEC_READONLY;
	}
    }

  /* Do anything special before sizing sections.  This is where ELF
     and other back-ends size dynamic sections.  */
  ldemul_before_allocation ();

  if (!link_info.relocatable)
    strip_excluded_output_sections ();

  /* We must record the program headers before we try to fix the
     section positions, since they will affect SIZEOF_HEADERS.  */
  lang_record_phdrs ();

  /* Size up the sections.  */
  lang_size_sections (statement_list.head, abs_output_section,
		      &statement_list.head, 0, 0, NULL,
		      command_line.relax ? FALSE : TRUE);

  /* Now run around and relax if we can.  */
  if (command_line.relax)
    {
      /* Keep relaxing until bfd_relax_section gives up.  */
      bfd_boolean relax_again;

      do
	{
	  relax_again = FALSE;

	  /* Note: pe-dll.c does something like this also.  If you find
	     you need to change this code, you probably need to change
	     pe-dll.c also.  DJ  */

	  /* Do all the assignments with our current guesses as to
	     section sizes.  */
	  lang_do_assignments (statement_list.head, abs_output_section,
			       NULL, 0);

	  /* We must do this after lang_do_assignments, because it uses
	     _raw_size.  */
	  lang_reset_memory_regions ();

	  /* Perform another relax pass - this time we know where the
	     globals are, so can make a better guess.  */
	  lang_size_sections (statement_list.head, abs_output_section,
			      &statement_list.head, 0, 0, &relax_again, FALSE);

	  /* If the normal relax is done and the relax finalize pass
	     is not performed yet, we perform another relax pass.  */
	  if (!relax_again && link_info.need_relax_finalize)
	    {
	      link_info.need_relax_finalize = FALSE;
	      relax_again = TRUE;
	    }
	}
      while (relax_again);

      /* Final extra sizing to report errors.  */
      lang_do_assignments (statement_list.head, abs_output_section, NULL, 0);
      lang_reset_memory_regions ();
      lang_size_sections (statement_list.head, abs_output_section,
			  &statement_list.head, 0, 0, NULL, TRUE);
    }

  /* See if anything special should be done now we know how big
     everything is.  */
  ldemul_after_allocation ();

  /* Fix any .startof. or .sizeof. symbols.  */
  lang_set_startof ();

  /* Do all the assignments, now that we know the final resting places
     of all the symbols.  */

  lang_do_assignments (statement_list.head, abs_output_section, NULL, 0);

  /* Make sure that the section addresses make sense.  */
  if (! link_info.relocatable
      && command_line.check_section_addresses)
    lang_check_section_addresses ();

  /* Final stuffs.  */

  ldemul_finish ();
  lang_finish ();
}

/* EXPORTED TO YACC */

void
lang_add_wild (struct wildcard_spec *filespec,
	       struct wildcard_list *section_list,
	       bfd_boolean keep_sections)
{
  struct wildcard_list *curr, *next;
  lang_wild_statement_type *new;

  /* Reverse the list as the parser puts it back to front.  */
  for (curr = section_list, section_list = NULL;
       curr != NULL;
       section_list = curr, curr = next)
    {
      if (curr->spec.name != NULL && strcmp (curr->spec.name, "COMMON") == 0)
	placed_commons = TRUE;

      next = curr->next;
      curr->next = section_list;
    }

  if (filespec != NULL && filespec->name != NULL)
    {
      if (strcmp (filespec->name, "*") == 0)
	filespec->name = NULL;
      else if (! wildcardp (filespec->name))
	lang_has_input_file = TRUE;
    }

  new = new_stat (lang_wild_statement, stat_ptr);
  new->filename = NULL;
  new->filenames_sorted = FALSE;
  if (filespec != NULL)
    {
      new->filename = filespec->name;
      new->filenames_sorted = filespec->sorted;
    }
  new->section_list = section_list;
  new->keep_sections = keep_sections;
  lang_list_init (&new->children);
}

void
lang_section_start (const char *name, etree_type *address)
{
  lang_address_statement_type *ad;

  ad = new_stat (lang_address_statement, stat_ptr);
  ad->section_name = name;
  ad->address = address;
}

/* Set the start symbol to NAME.  CMDLINE is nonzero if this is called
   because of a -e argument on the command line, or zero if this is
   called by ENTRY in a linker script.  Command line arguments take
   precedence.  */

void
lang_add_entry (const char *name, bfd_boolean cmdline)
{
  if (entry_symbol.name == NULL
      || cmdline
      || ! entry_from_cmdline)
    {
      entry_symbol.name = name;
      entry_from_cmdline = cmdline;
    }
}

void
lang_add_target (const char *name)
{
  lang_target_statement_type *new = new_stat (lang_target_statement,
					      stat_ptr);

  new->target = name;

}

void
lang_add_map (const char *name)
{
  while (*name)
    {
      switch (*name)
	{
	case 'F':
	  map_option_f = TRUE;
	  break;
	}
      name++;
    }
}

void
lang_add_fill (fill_type *fill)
{
  lang_fill_statement_type *new = new_stat (lang_fill_statement,
					    stat_ptr);

  new->fill = fill;
}

void
lang_add_data (int type, union etree_union *exp)
{

  lang_data_statement_type *new = new_stat (lang_data_statement,
					    stat_ptr);

  new->exp = exp;
  new->type = type;

}

/* Create a new reloc statement.  RELOC is the BFD relocation type to
   generate.  HOWTO is the corresponding howto structure (we could
   look this up, but the caller has already done so).  SECTION is the
   section to generate a reloc against, or NAME is the name of the
   symbol to generate a reloc against.  Exactly one of SECTION and
   NAME must be NULL.  ADDEND is an expression for the addend.  */

void
lang_add_reloc (bfd_reloc_code_real_type reloc,
		reloc_howto_type *howto,
		asection *section,
		const char *name,
		union etree_union *addend)
{
  lang_reloc_statement_type *p = new_stat (lang_reloc_statement, stat_ptr);

  p->reloc = reloc;
  p->howto = howto;
  p->section = section;
  p->name = name;
  p->addend_exp = addend;

  p->addend_value = 0;
  p->output_section = NULL;
  p->output_vma = 0;
}

lang_assignment_statement_type *
lang_add_assignment (etree_type *exp)
{
  lang_assignment_statement_type *new = new_stat (lang_assignment_statement,
						  stat_ptr);

  new->exp = exp;
  return new;
}

void
lang_add_attribute (enum statement_enum attribute)
{
  new_statement (attribute, sizeof (lang_statement_union_type), stat_ptr);
}

void
lang_startup (const char *name)
{
  if (startup_file != NULL)
    {
      einfo (_("%P%Fmultiple STARTUP files\n"));
    }
  first_file->filename = name;
  first_file->local_sym_name = name;
  first_file->real = TRUE;

  startup_file = name;
}

void
lang_float (bfd_boolean maybe)
{
  lang_float_flag = maybe;
}


/* Work out the load- and run-time regions from a script statement, and
   store them in *LMA_REGION and *REGION respectively.

   MEMSPEC is the name of the run-time region, or the value of
   DEFAULT_MEMORY_REGION if the statement didn't specify one.
   LMA_MEMSPEC is the name of the load-time region, or null if the
   statement didn't specify one.HAVE_LMA_P is TRUE if the statement
   had an explicit load address.

   It is an error to specify both a load region and a load address.  */

static void
lang_get_regions (lang_memory_region_type **region,
		  lang_memory_region_type **lma_region,
		  const char *memspec,
		  const char *lma_memspec,
		  bfd_boolean have_lma,
		  bfd_boolean have_vma)
{
  *lma_region = lang_memory_region_lookup (lma_memspec, FALSE);

  /* If no runtime region or VMA has been specified, but the load region has
     been specified, then use the load region for the runtime region as well.  */
  if (lma_memspec != NULL
      && ! have_vma
      && strcmp (memspec, DEFAULT_MEMORY_REGION) == 0)
    *region = *lma_region;
  else
    *region = lang_memory_region_lookup (memspec, FALSE);

  if (have_lma && lma_memspec != 0)
    einfo (_("%X%P:%S: section has both a load address and a load region\n"));
}

void
lang_leave_output_section_statement (fill_type *fill, const char *memspec,
				     lang_output_section_phdr_list *phdrs,
				     const char *lma_memspec)
{
  lang_get_regions (&current_section->region,
		    &current_section->lma_region,
		    memspec, lma_memspec,
		    current_section->load_base != NULL,
		    current_section->addr_tree != NULL);
  current_section->fill = fill;
  current_section->phdrs = phdrs;
  stat_ptr = &statement_list;
}

/* Create an absolute symbol with the given name with the value of the
   address of first byte of the section named.

   If the symbol already exists, then do nothing.  */

void
lang_abs_symbol_at_beginning_of (const char *secname, const char *name)
{
  struct bfd_link_hash_entry *h;

  h = bfd_link_hash_lookup (link_info.hash, name, TRUE, TRUE, TRUE);
  if (h == NULL)
    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));

  if (h->type == bfd_link_hash_new
      || h->type == bfd_link_hash_undefined)
    {
      asection *sec;

      h->type = bfd_link_hash_defined;

      sec = bfd_get_section_by_name (output_bfd, secname);
      if (sec == NULL)
	h->u.def.value = 0;
      else
	h->u.def.value = bfd_get_section_vma (output_bfd, sec);

      h->u.def.section = bfd_abs_section_ptr;
    }
}

/* Create an absolute symbol with the given name with the value of the
   address of the first byte after the end of the section named.

   If the symbol already exists, then do nothing.  */

void
lang_abs_symbol_at_end_of (const char *secname, const char *name)
{
  struct bfd_link_hash_entry *h;

  h = bfd_link_hash_lookup (link_info.hash, name, TRUE, TRUE, TRUE);
  if (h == NULL)
    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));

  if (h->type == bfd_link_hash_new
      || h->type == bfd_link_hash_undefined)
    {
      asection *sec;

      h->type = bfd_link_hash_defined;

      sec = bfd_get_section_by_name (output_bfd, secname);
      if (sec == NULL)
	h->u.def.value = 0;
      else
	h->u.def.value = (bfd_get_section_vma (output_bfd, sec)
			  + TO_ADDR (bfd_section_size (output_bfd, sec)));

      h->u.def.section = bfd_abs_section_ptr;
    }
}

void
lang_statement_append (lang_statement_list_type *list,
		       lang_statement_union_type *element,
		       lang_statement_union_type **field)
{
  *(list->tail) = element;
  list->tail = field;
}

/* Set the output format type.  -oformat overrides scripts.  */

void
lang_add_output_format (const char *format,
			const char *big,
			const char *little,
			int from_script)
{
  if (output_target == NULL || !from_script)
    {
      if (command_line.endian == ENDIAN_BIG
	  && big != NULL)
	format = big;
      else if (command_line.endian == ENDIAN_LITTLE
	       && little != NULL)
	format = little;

      output_target = format;
    }
}

/* Enter a group.  This creates a new lang_group_statement, and sets
   stat_ptr to build new statements within the group.  */

void
lang_enter_group (void)
{
  lang_group_statement_type *g;

  g = new_stat (lang_group_statement, stat_ptr);
  lang_list_init (&g->children);
  stat_ptr = &g->children;
}

/* Leave a group.  This just resets stat_ptr to start writing to the
   regular list of statements again.  Note that this will not work if
   groups can occur inside anything else which can adjust stat_ptr,
   but currently they can't.  */

void
lang_leave_group (void)
{
  stat_ptr = &statement_list;
}

/* Add a new program header.  This is called for each entry in a PHDRS
   command in a linker script.  */

void
lang_new_phdr (const char *name,
	       etree_type *type,
	       bfd_boolean filehdr,
	       bfd_boolean phdrs,
	       etree_type *at,
	       etree_type *flags)
{
  struct lang_phdr *n, **pp;

  n = stat_alloc (sizeof (struct lang_phdr));
  n->next = NULL;
  n->name = name;
  n->type = exp_get_value_int (type, 0, "program header type",
			       lang_final_phase_enum);
  n->filehdr = filehdr;
  n->phdrs = phdrs;
  n->at = at;
  n->flags = flags;

  for (pp = &lang_phdr_list; *pp != NULL; pp = &(*pp)->next)
    ;
  *pp = n;
}

/* Record the program header information in the output BFD.  FIXME: We
   should not be calling an ELF specific function here.  */

static void
lang_record_phdrs (void)
{
  unsigned int alc;
  asection **secs;
  lang_output_section_phdr_list *last;
  struct lang_phdr *l;
  lang_statement_union_type *u;

  alc = 10;
  secs = xmalloc (alc * sizeof (asection *));
  last = NULL;
  for (l = lang_phdr_list; l != NULL; l = l->next)
    {
      unsigned int c;
      flagword flags;
      bfd_vma at;

      c = 0;
      for (u = lang_output_section_statement.head;
	   u != NULL;
	   u = u->output_section_statement.next)
	{
	  lang_output_section_statement_type *os;
	  lang_output_section_phdr_list *pl;

	  os = &u->output_section_statement;

	  pl = os->phdrs;
	  if (pl != NULL)
	    last = pl;
	  else
	    {
	      if (os->sectype == noload_section
		  || os->bfd_section == NULL
		  || (os->bfd_section->flags & SEC_ALLOC) == 0)
		continue;
	      pl = last;
	    }

	  if (os->bfd_section == NULL)
	    continue;

	  for (; pl != NULL; pl = pl->next)
	    {
	      if (strcmp (pl->name, l->name) == 0)
		{
		  if (c >= alc)
		    {
		      alc *= 2;
		      secs = xrealloc (secs, alc * sizeof (asection *));
		    }
		  secs[c] = os->bfd_section;
		  ++c;
		  pl->used = TRUE;
		}
	    }
	}

      if (l->flags == NULL)
	flags = 0;
      else
	flags = exp_get_vma (l->flags, 0, "phdr flags",
			     lang_final_phase_enum);

      if (l->at == NULL)
	at = 0;
      else
	at = exp_get_vma (l->at, 0, "phdr load address",
			  lang_final_phase_enum);

      if (! bfd_record_phdr (output_bfd, l->type,
			     l->flags != NULL, flags, l->at != NULL,
			     at, l->filehdr, l->phdrs, c, secs))
	einfo (_("%F%P: bfd_record_phdr failed: %E\n"));
    }

  free (secs);

  /* Make sure all the phdr assignments succeeded.  */
  for (u = lang_output_section_statement.head;
       u != NULL;
       u = u->output_section_statement.next)
    {
      lang_output_section_phdr_list *pl;

      if (u->output_section_statement.bfd_section == NULL)
	continue;

      for (pl = u->output_section_statement.phdrs;
	   pl != NULL;
	   pl = pl->next)
	if (! pl->used && strcmp (pl->name, "NONE") != 0)
	  einfo (_("%X%P: section `%s' assigned to non-existent phdr `%s'\n"),
		 u->output_section_statement.name, pl->name);
    }
}

/* Record a list of sections which may not be cross referenced.  */

void
lang_add_nocrossref (lang_nocrossref_type *l)
{
  struct lang_nocrossrefs *n;

  n = xmalloc (sizeof *n);
  n->next = nocrossref_list;
  n->list = l;
  nocrossref_list = n;

  /* Set notice_all so that we get informed about all symbols.  */
  link_info.notice_all = TRUE;
}

/* Overlay handling.  We handle overlays with some static variables.  */

/* The overlay virtual address.  */
static etree_type *overlay_vma;
/* And subsection alignment.  */
static etree_type *overlay_subalign;

/* An expression for the maximum section size seen so far.  */
static etree_type *overlay_max;

/* A list of all the sections in this overlay.  */

struct overlay_list {
  struct overlay_list *next;
  lang_output_section_statement_type *os;
};

static struct overlay_list *overlay_list;

/* Start handling an overlay.  */

void
lang_enter_overlay (etree_type *vma_expr, etree_type *subalign)
{
  /* The grammar should prevent nested overlays from occurring.  */
  ASSERT (overlay_vma == NULL
	  && overlay_subalign == NULL
	  && overlay_max == NULL);

  overlay_vma = vma_expr;
  overlay_subalign = subalign;
}

/* Start a section in an overlay.  We handle this by calling
   lang_enter_output_section_statement with the correct VMA.
   lang_leave_overlay sets up the LMA and memory regions.  */

void
lang_enter_overlay_section (const char *name)
{
  struct overlay_list *n;
  etree_type *size;

  lang_enter_output_section_statement (name, overlay_vma, normal_section,
				       0, overlay_subalign, 0);

  /* If this is the first section, then base the VMA of future
     sections on this one.  This will work correctly even if `.' is
     used in the addresses.  */
  if (overlay_list == NULL)
    overlay_vma = exp_nameop (ADDR, name);

  /* Remember the section.  */
  n = xmalloc (sizeof *n);
  n->os = current_section;
  n->next = overlay_list;
  overlay_list = n;

  size = exp_nameop (SIZEOF, name);

  /* Arrange to work out the maximum section end address.  */
  if (overlay_max == NULL)
    overlay_max = size;
  else
    overlay_max = exp_binop (MAX_K, overlay_max, size);
}

/* Finish a section in an overlay.  There isn't any special to do
   here.  */

void
lang_leave_overlay_section (fill_type *fill,
			    lang_output_section_phdr_list *phdrs)
{
  const char *name;
  char *clean, *s2;
  const char *s1;
  char *buf;

  name = current_section->name;

  /* For now, assume that DEFAULT_MEMORY_REGION is the run-time memory
     region and that no load-time region has been specified.  It doesn't
     really matter what we say here, since lang_leave_overlay will
     override it.  */
  lang_leave_output_section_statement (fill, DEFAULT_MEMORY_REGION, phdrs, 0);

  /* Define the magic symbols.  */

  clean = xmalloc (strlen (name) + 1);
  s2 = clean;
  for (s1 = name; *s1 != '\0'; s1++)
    if (ISALNUM (*s1) || *s1 == '_')
      *s2++ = *s1;
  *s2 = '\0';

  buf = xmalloc (strlen (clean) + sizeof "__load_start_");
  sprintf (buf, "__load_start_%s", clean);
  lang_add_assignment (exp_assop ('=', buf,
				  exp_nameop (LOADADDR, name)));

  buf = xmalloc (strlen (clean) + sizeof "__load_stop_");
  sprintf (buf, "__load_stop_%s", clean);
  lang_add_assignment (exp_assop ('=', buf,
				  exp_binop ('+',
					     exp_nameop (LOADADDR, name),
					     exp_nameop (SIZEOF, name))));

  free (clean);
}

/* Finish an overlay.  If there are any overlay wide settings, this
   looks through all the sections in the overlay and sets them.  */

void
lang_leave_overlay (etree_type *lma_expr,
		    int nocrossrefs,
		    fill_type *fill,
		    const char *memspec,
		    lang_output_section_phdr_list *phdrs,
		    const char *lma_memspec)
{
  lang_memory_region_type *region;
  lang_memory_region_type *lma_region;
  struct overlay_list *l;
  lang_nocrossref_type *nocrossref;

  lang_get_regions (&region, &lma_region,
		    memspec, lma_memspec,
		    lma_expr != NULL, FALSE);

  nocrossref = NULL;

  /* After setting the size of the last section, set '.' to end of the
     overlay region.  */
  if (overlay_list != NULL)
    overlay_list->os->update_dot_tree
      = exp_assop ('=', ".", exp_binop ('+', overlay_vma, overlay_max));

  l = overlay_list;
  while (l != NULL)
    {
      struct overlay_list *next;

      if (fill != NULL && l->os->fill == NULL)
	l->os->fill = fill;

      l->os->region = region;
      l->os->lma_region = lma_region;

      /* The first section has the load address specified in the
	 OVERLAY statement.  The rest are worked out from that.
	 The base address is not needed (and should be null) if
	 an LMA region was specified.  */
      if (l->next == 0)
	l->os->load_base = lma_expr;
      else if (lma_region == 0)
	l->os->load_base = exp_binop ('+',
				      exp_nameop (LOADADDR, l->next->os->name),
				      exp_nameop (SIZEOF, l->next->os->name));

      if (phdrs != NULL && l->os->phdrs == NULL)
	l->os->phdrs = phdrs;

      if (nocrossrefs)
	{
	  lang_nocrossref_type *nc;

	  nc = xmalloc (sizeof *nc);
	  nc->name = l->os->name;
	  nc->next = nocrossref;
	  nocrossref = nc;
	}

      next = l->next;
      free (l);
      l = next;
    }

  if (nocrossref != NULL)
    lang_add_nocrossref (nocrossref);

  overlay_vma = NULL;
  overlay_list = NULL;
  overlay_max = NULL;
}

/* Version handling.  This is only useful for ELF.  */

/* This global variable holds the version tree that we build.  */

struct bfd_elf_version_tree *lang_elf_version_info;

/* If PREV is NULL, return first version pattern matching particular symbol.
   If PREV is non-NULL, return first version pattern matching particular
   symbol after PREV (previously returned by lang_vers_match).  */

static struct bfd_elf_version_expr *
lang_vers_match (struct bfd_elf_version_expr_head *head,
		 struct bfd_elf_version_expr *prev,
		 const char *sym)
{
  const char *cxx_sym = sym;
  const char *java_sym = sym;
  struct bfd_elf_version_expr *expr = NULL;

  if (head->mask & BFD_ELF_VERSION_CXX_TYPE)
    {
      cxx_sym = cplus_demangle (sym, DMGL_PARAMS | DMGL_ANSI);
      if (!cxx_sym)
	cxx_sym = sym;
    }
  if (head->mask & BFD_ELF_VERSION_JAVA_TYPE)
    {
      java_sym = cplus_demangle (sym, DMGL_JAVA);
      if (!java_sym)
	java_sym = sym;
    }

  if (head->htab && (prev == NULL || prev->symbol))
    {
      struct bfd_elf_version_expr e;

      switch (prev ? prev->mask : 0)
	{
	  case 0:
	    if (head->mask & BFD_ELF_VERSION_C_TYPE)
	      {
		e.symbol = sym;
		expr = htab_find (head->htab, &e);
		while (expr && strcmp (expr->symbol, sym) == 0)
		  if (expr->mask == BFD_ELF_VERSION_C_TYPE)
		    goto out_ret;
		else
		  expr = expr->next;
	      }
	    /* Fallthrough */
	  case BFD_ELF_VERSION_C_TYPE:
	    if (head->mask & BFD_ELF_VERSION_CXX_TYPE)
	      {
		e.symbol = cxx_sym;
		expr = htab_find (head->htab, &e);
		while (expr && strcmp (expr->symbol, cxx_sym) == 0)
		  if (expr->mask == BFD_ELF_VERSION_CXX_TYPE)
		    goto out_ret;
		else
		  expr = expr->next;
	      }
	    /* Fallthrough */
	  case BFD_ELF_VERSION_CXX_TYPE:
	    if (head->mask & BFD_ELF_VERSION_JAVA_TYPE)
	      {
		e.symbol = java_sym;
		expr = htab_find (head->htab, &e);
		while (expr && strcmp (expr->symbol, java_sym) == 0)
		  if (expr->mask == BFD_ELF_VERSION_JAVA_TYPE)
		    goto out_ret;
		else
		  expr = expr->next;
	      }
	    /* Fallthrough */
	  default:
	    break;
	}
    }

  /* Finally, try the wildcards.  */
  if (prev == NULL || prev->symbol)
    expr = head->remaining;
  else
    expr = prev->next;
  while (expr)
    {
      const char *s;

      if (expr->pattern[0] == '*' && expr->pattern[1] == '\0')
	break;

      if (expr->mask == BFD_ELF_VERSION_JAVA_TYPE)
	s = java_sym;
      else if (expr->mask == BFD_ELF_VERSION_CXX_TYPE)
	s = cxx_sym;
      else
	s = sym;
      if (fnmatch (expr->pattern, s, 0) == 0)
	break;
      expr = expr->next;
    }

out_ret:
  if (cxx_sym != sym)
    free ((char *) cxx_sym);
  if (java_sym != sym)
    free ((char *) java_sym);
  return expr;
}

/* Return NULL if the PATTERN argument is a glob pattern, otherwise,
   return a string pointing to the symbol name.  */

static const char *
realsymbol (const char *pattern)
{
  const char *p;
  bfd_boolean changed = FALSE, backslash = FALSE;
  char *s, *symbol = xmalloc (strlen (pattern) + 1);

  for (p = pattern, s = symbol; *p != '\0'; ++p)
    {
      /* It is a glob pattern only if there is no preceding
	 backslash.  */
      if (! backslash && (*p == '?' || *p == '*' || *p == '['))
	{
	  free (symbol);
	  return NULL;
	}

      if (backslash)
	{
	  /* Remove the preceding backslash.  */
	  *(s - 1) = *p;
	  changed = TRUE;
	}
      else
	*s++ = *p;

      backslash = *p == '\\';
    }

  if (changed)
    {
      *s = '\0';
      return symbol;
    }
  else
    {
      free (symbol);
      return pattern;
    }
}

/* This is called for each variable name or match expression.  */

struct bfd_elf_version_expr *
lang_new_vers_pattern (struct bfd_elf_version_expr *orig,
		       const char *new,
		       const char *lang)
{
  struct bfd_elf_version_expr *ret;

  ret = xmalloc (sizeof *ret);
  ret->next = orig;
  ret->pattern = new;
  ret->symver = 0;
  ret->script = 0;
  ret->symbol = realsymbol (new);

  if (lang == NULL || strcasecmp (lang, "C") == 0)
    ret->mask = BFD_ELF_VERSION_C_TYPE;
  else if (strcasecmp (lang, "C++") == 0)
    ret->mask = BFD_ELF_VERSION_CXX_TYPE;
  else if (strcasecmp (lang, "Java") == 0)
    ret->mask = BFD_ELF_VERSION_JAVA_TYPE;
  else
    {
      einfo (_("%X%P: unknown language `%s' in version information\n"),
	     lang);
      ret->mask = BFD_ELF_VERSION_C_TYPE;
    }

  return ldemul_new_vers_pattern (ret);
}

/* This is called for each set of variable names and match
   expressions.  */

struct bfd_elf_version_tree *
lang_new_vers_node (struct bfd_elf_version_expr *globals,
		    struct bfd_elf_version_expr *locals)
{
  struct bfd_elf_version_tree *ret;

  ret = xcalloc (1, sizeof *ret);
  ret->globals.list = globals;
  ret->locals.list = locals;
  ret->match = lang_vers_match;
  ret->name_indx = (unsigned int) -1;
  return ret;
}

/* This static variable keeps track of version indices.  */

static int version_index;

static hashval_t
version_expr_head_hash (const void *p)
{
  const struct bfd_elf_version_expr *e = p;

  return htab_hash_string (e->symbol);
}

static int
version_expr_head_eq (const void *p1, const void *p2)
{
  const struct bfd_elf_version_expr *e1 = p1;
  const struct bfd_elf_version_expr *e2 = p2;

  return strcmp (e1->symbol, e2->symbol) == 0;
}

static void
lang_finalize_version_expr_head (struct bfd_elf_version_expr_head *head)
{
  size_t count = 0;
  struct bfd_elf_version_expr *e, *next;
  struct bfd_elf_version_expr **list_loc, **remaining_loc;

  for (e = head->list; e; e = e->next)
    {
      if (e->symbol)
	count++;
      head->mask |= e->mask;
    }

  if (count)
    {
      head->htab = htab_create (count * 2, version_expr_head_hash,
				version_expr_head_eq, NULL);
      list_loc = &head->list;
      remaining_loc = &head->remaining;
      for (e = head->list; e; e = next)
	{
	  next = e->next;
	  if (!e->symbol)
	    {
	      *remaining_loc = e;
	      remaining_loc = &e->next;
	    }
	  else
	    {
	      void **loc = htab_find_slot (head->htab, e, INSERT);

	      if (*loc)
		{
		  struct bfd_elf_version_expr *e1, *last;

		  e1 = *loc;
		  last = NULL;
		  do
		    {
		      if (e1->mask == e->mask)
			{
			  last = NULL;
			  break;
			}
		      last = e1;
		      e1 = e1->next;
		    }
		  while (e1 && strcmp (e1->symbol, e->symbol) == 0);

		  if (last == NULL)
		    {
		      /* This is a duplicate.  */
		      /* FIXME: Memory leak.  Sometimes pattern is not
			 xmalloced alone, but in larger chunk of memory.  */
		      /* free (e->symbol); */
		      free (e);
		    }
		  else
		    {
		      e->next = last->next;
		      last->next = e;
		    }
		}
	      else
		{
		  *loc = e;
		  *list_loc = e;
		  list_loc = &e->next;
		}
	    }
	}
      *remaining_loc = NULL;
      *list_loc = head->remaining;
    }
  else
    head->remaining = head->list;
}

/* This is called when we know the name and dependencies of the
   version.  */

void
lang_register_vers_node (const char *name,
			 struct bfd_elf_version_tree *version,
			 struct bfd_elf_version_deps *deps)
{
  struct bfd_elf_version_tree *t, **pp;
  struct bfd_elf_version_expr *e1;

  if (name == NULL)
    name = "";

  if ((name[0] == '\0' && lang_elf_version_info != NULL)
      || (lang_elf_version_info && lang_elf_version_info->name[0] == '\0'))
    {
      einfo (_("%X%P: anonymous version tag cannot be combined with other version tags\n"));
      free (version);
      return;
    }

  /* Make sure this node has a unique name.  */
  for (t = lang_elf_version_info; t != NULL; t = t->next)
    if (strcmp (t->name, name) == 0)
      einfo (_("%X%P: duplicate version tag `%s'\n"), name);

  lang_finalize_version_expr_head (&version->globals);
  lang_finalize_version_expr_head (&version->locals);

  /* Check the global and local match names, and make sure there
     aren't any duplicates.  */

  for (e1 = version->globals.list; e1 != NULL; e1 = e1->next)
    {
      for (t = lang_elf_version_info; t != NULL; t = t->next)
	{
	  struct bfd_elf_version_expr *e2;

	  if (t->locals.htab && e1->symbol)
	    {
	      e2 = htab_find (t->locals.htab, e1);
	      while (e2 && strcmp (e1->symbol, e2->symbol) == 0)
		{
		  if (e1->mask == e2->mask)
		    einfo (_("%X%P: duplicate expression `%s' in version information\n"),
			   e1->symbol);
		  e2 = e2->next;
		}
	    }
	  else if (!e1->symbol)
	    for (e2 = t->locals.remaining; e2 != NULL; e2 = e2->next)
	      if (strcmp (e1->pattern, e2->pattern) == 0 && e1->mask == e2->mask)
		einfo (_("%X%P: duplicate expression `%s' in version information\n"),
		       e1->pattern);
	}
    }

  for (e1 = version->locals.list; e1 != NULL; e1 = e1->next)
    {
      for (t = lang_elf_version_info; t != NULL; t = t->next)
	{
	  struct bfd_elf_version_expr *e2;

	  if (t->globals.htab && e1->symbol)
	    {
	      e2 = htab_find (t->globals.htab, e1);
	      while (e2 && strcmp (e1->symbol, e2->symbol) == 0)
		{
		  if (e1->mask == e2->mask)
		    einfo (_("%X%P: duplicate expression `%s' in version information\n"),
			   e1->symbol);
		  e2 = e2->next;
		}
	    }
	  else if (!e1->symbol)
	    for (e2 = t->globals.remaining; e2 != NULL; e2 = e2->next)
	      if (strcmp (e1->pattern, e2->pattern) == 0 && e1->mask == e2->mask)
		einfo (_("%X%P: duplicate expression `%s' in version information\n"),
		       e1->pattern);
	}
    }

  version->deps = deps;
  version->name = name;
  if (name[0] != '\0')
    {
      ++version_index;
      version->vernum = version_index;
    }
  else
    version->vernum = 0;

  for (pp = &lang_elf_version_info; *pp != NULL; pp = &(*pp)->next)
    ;
  *pp = version;
}

/* This is called when we see a version dependency.  */

struct bfd_elf_version_deps *
lang_add_vers_depend (struct bfd_elf_version_deps *list, const char *name)
{
  struct bfd_elf_version_deps *ret;
  struct bfd_elf_version_tree *t;

  ret = xmalloc (sizeof *ret);
  ret->next = list;

  for (t = lang_elf_version_info; t != NULL; t = t->next)
    {
      if (strcmp (t->name, name) == 0)
	{
	  ret->version_needed = t;
	  return ret;
	}
    }

  einfo (_("%X%P: unable to find version dependency `%s'\n"), name);

  return ret;
}

static void
lang_do_version_exports_section (void)
{
  struct bfd_elf_version_expr *greg = NULL, *lreg;

  LANG_FOR_EACH_INPUT_STATEMENT (is)
    {
      asection *sec = bfd_get_section_by_name (is->the_bfd, ".exports");
      char *contents, *p;
      bfd_size_type len;

      if (sec == NULL)
	continue;

      len = bfd_section_size (is->the_bfd, sec);
      contents = xmalloc (len);
      if (!bfd_get_section_contents (is->the_bfd, sec, contents, 0, len))
	einfo (_("%X%P: unable to read .exports section contents\n"), sec);

      p = contents;
      while (p < contents + len)
	{
	  greg = lang_new_vers_pattern (greg, p, NULL);
	  p = strchr (p, '\0') + 1;
	}

      /* Do not free the contents, as we used them creating the regex.  */

      /* Do not include this section in the link.  */
      bfd_set_section_flags (is->the_bfd, sec,
	bfd_get_section_flags (is->the_bfd, sec) | SEC_EXCLUDE);
    }

  lreg = lang_new_vers_pattern (NULL, "*", NULL);
  lang_register_vers_node (command_line.version_exports_section,
			   lang_new_vers_node (greg, lreg), NULL);
}

void
lang_add_unique (const char *name)
{
  struct unique_sections *ent;

  for (ent = unique_section_list; ent; ent = ent->next)
    if (strcmp (ent->name, name) == 0)
      return;

  ent = xmalloc (sizeof *ent);
  ent->name = xstrdup (name);
  ent->next = unique_section_list;
  unique_section_list = ent;
}
@


1.8
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2001, 2002, 2003
d42 1
d64 1
d67 19
a85 163
static lang_statement_union_type *new_statement
  PARAMS ((enum statement_enum, size_t, lang_statement_list_type *));
static void lang_for_each_statement_worker
  PARAMS ((void (*) (lang_statement_union_type *),
	   lang_statement_union_type *));
static lang_input_statement_type *new_afile
  PARAMS ((const char *, lang_input_file_enum_type, const char *,
	   bfd_boolean));
static lang_memory_region_type *lang_memory_default
  PARAMS ((asection *));
static void lang_map_flags
  PARAMS ((flagword));
static void init_os
  PARAMS ((lang_output_section_statement_type *));
static void exp_init_os
  PARAMS ((etree_type *));
static void section_already_linked
  PARAMS ((bfd *, asection *, PTR));
static struct bfd_hash_entry *already_linked_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static void already_linked_table_init
  PARAMS ((void));
static void already_linked_table_free
  PARAMS ((void));
static bfd_boolean wildcardp
  PARAMS ((const char *));
static lang_statement_union_type *wild_sort
  PARAMS ((lang_wild_statement_type *, struct wildcard_list *,
	   lang_input_statement_type *, asection *));
static void output_section_callback
  PARAMS ((lang_wild_statement_type *, struct wildcard_list *, asection *,
	   lang_input_statement_type *, PTR));
static lang_input_statement_type *lookup_name
  PARAMS ((const char *));
static bfd_boolean load_symbols
  PARAMS ((lang_input_statement_type *, lang_statement_list_type *));
static void wild
  PARAMS ((lang_wild_statement_type *,
	   const char *, lang_output_section_statement_type *));
static bfd *open_output
  PARAMS ((const char *));
static void ldlang_open_output
  PARAMS ((lang_statement_union_type *));
static void open_input_bfds
  PARAMS ((lang_statement_union_type *, bfd_boolean));
static void lang_reasonable_defaults
  PARAMS ((void));
static void insert_undefined
  PARAMS ((const char *));
static void lang_place_undefineds
  PARAMS ((void));
static void map_input_to_output_sections
  PARAMS ((lang_statement_union_type *, const char *,
	   lang_output_section_statement_type *));
static void strip_excluded_output_sections
  PARAMS ((void));
static void print_output_section_statement
  PARAMS ((lang_output_section_statement_type *));
static void print_assignment
  PARAMS ((lang_assignment_statement_type *,
	   lang_output_section_statement_type *));
static void print_input_statement
  PARAMS ((lang_input_statement_type *));
static bfd_boolean print_one_symbol
  PARAMS ((struct bfd_link_hash_entry *, PTR));
static void print_input_section
  PARAMS ((lang_input_section_type *));
static void print_fill_statement
  PARAMS ((lang_fill_statement_type *));
static void print_data_statement
  PARAMS ((lang_data_statement_type *));
static void print_address_statement
  PARAMS ((lang_address_statement_type *));
static void print_reloc_statement
  PARAMS ((lang_reloc_statement_type *));
static void print_padding_statement
  PARAMS ((lang_padding_statement_type *));
static void print_wild_statement
  PARAMS ((lang_wild_statement_type *, lang_output_section_statement_type *));
static void print_group
  PARAMS ((lang_group_statement_type *, lang_output_section_statement_type *));
static void print_statement
  PARAMS ((lang_statement_union_type *, lang_output_section_statement_type *));
static void print_statement_list
  PARAMS ((lang_statement_union_type *, lang_output_section_statement_type *));
static void print_statements
  PARAMS ((void));
static void insert_pad
  PARAMS ((lang_statement_union_type **, fill_type *,
	   unsigned int, asection *, bfd_vma));
static bfd_vma size_input_section
  PARAMS ((lang_statement_union_type **, lang_output_section_statement_type *,
	   fill_type *, bfd_vma));
static void lang_finish
  PARAMS ((void));
static void ignore_bfd_errors
  PARAMS ((const char *, ...));
static void lang_check
  PARAMS ((void));
static void lang_common
  PARAMS ((void));
static bfd_boolean lang_one_common
  PARAMS ((struct bfd_link_hash_entry *, PTR));
static void lang_place_orphans
  PARAMS ((void));
static int topower
  PARAMS ((int));
static void lang_set_startof
  PARAMS ((void));
static void gc_section_callback
  PARAMS ((lang_wild_statement_type *, struct wildcard_list *, asection *,
	   lang_input_statement_type *, PTR));
static void lang_get_regions
  PARAMS ((struct memory_region_struct **, struct memory_region_struct **,
	   const char *, const char *, int));
static void lang_record_phdrs
  PARAMS ((void));
static void lang_gc_wild
  PARAMS ((lang_wild_statement_type *));
static void lang_gc_sections_1
  PARAMS ((lang_statement_union_type *));
static void lang_gc_sections
  PARAMS ((void));
static int lang_vers_match_lang_c
  PARAMS ((struct bfd_elf_version_expr *, const char *));
static int lang_vers_match_lang_cplusplus
  PARAMS ((struct bfd_elf_version_expr *, const char *));
static int lang_vers_match_lang_java
  PARAMS ((struct bfd_elf_version_expr *, const char *));
static void lang_do_version_exports_section
  PARAMS ((void));
static void lang_check_section_addresses
  PARAMS ((void));
static void os_region_check
  PARAMS ((lang_output_section_statement_type *,
	   struct memory_region_struct *, etree_type *, bfd_vma));
static bfd_vma lang_size_sections_1
  PARAMS ((lang_statement_union_type *, lang_output_section_statement_type *,
	   lang_statement_union_type **, fill_type *, bfd_vma, bfd_boolean *,
	   bfd_boolean));
typedef void (*callback_t)
  PARAMS ((lang_wild_statement_type *, struct wildcard_list *, asection *,
	   lang_input_statement_type *, PTR));
static void walk_wild
  PARAMS ((lang_wild_statement_type *, callback_t, PTR));
static void walk_wild_section
  PARAMS ((lang_wild_statement_type *, lang_input_statement_type *,
	   callback_t, PTR));
static void walk_wild_file
  PARAMS ((lang_wild_statement_type *, lang_input_statement_type *,
	   callback_t, PTR));
static int get_target
  PARAMS ((const bfd_target *, PTR));
static void stricpy
  PARAMS ((char *, char *));
static void strcut
  PARAMS ((char *, char *));
static int name_compare
  PARAMS ((char *, char *));
static int closest_target_match
  PARAMS ((const bfd_target *, PTR));
static char * get_first_input_target
  PARAMS ((void));
d102 1
a105 8
#if defined (__STDC__) || defined (ALMOST_STDC)
#define cat(a,b) a##b
#else
#define cat(a,b) a/**/b
#endif

/* Don't beautify the line below with "innocent" whitespace, it breaks
   the K&R C preprocessor!  */
d107 1
a107 1
  (cat (x,_type)*) new_statement (cat (x,_enum), sizeof (cat (x,_type)), y)
d117 2
a118 3
PTR
stat_alloc (size)
     size_t size;
d124 1
a124 2
unique_section_p (secnam)
     const char *secnam;
d142 4
a145 5
walk_wild_section (ptr, file, callback, data)
     lang_wild_statement_type *ptr;
     lang_input_statement_type *file;
     callback_t callback;
     PTR data;
d216 4
a219 5
walk_wild_file (s, f, callback, data)
     lang_wild_statement_type *s;
     lang_input_statement_type *f;
     callback_t callback;
     PTR data;
d230 1
a230 1
      member = bfd_openr_next_archived_file (f->the_bfd, (bfd *) NULL);
d240 1
a240 3
	      walk_wild_section (s,
				 (lang_input_statement_type *) member->usrdata,
				 callback, data);
d249 1
a249 4
walk_wild (s, callback, data)
     lang_wild_statement_type *s;
     callback_t callback;
     PTR data;
d284 2
a285 3
lang_for_each_statement_worker (func, s)
     void (*func) PARAMS ((lang_statement_union_type *));
     lang_statement_union_type *s;
d287 1
a287 1
  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
d330 1
a330 2
lang_for_each_statement (func)
     void (*func) PARAMS ((lang_statement_union_type *));
d338 1
a338 2
lang_list_init (list)
     lang_statement_list_type *list;
d340 1
a340 1
  list->head = (lang_statement_union_type *) NULL;
d347 3
a349 4
new_statement (type, size, list)
     enum statement_enum type;
     size_t size;
     lang_statement_list_type *list;
d351 1
a351 2
  lang_statement_union_type *new = (lang_statement_union_type *)
  stat_alloc (size);
d353 1
d355 1
a355 1
  new->header.next = (lang_statement_union_type *) NULL;
d370 4
a373 5
new_afile (name, file_type, target, add_to_list)
     const char *name;
     lang_input_file_enum_type file_type;
     const char *target;
     bfd_boolean add_to_list;
d381 1
a381 2
      p = ((lang_input_statement_type *)
	   stat_alloc (sizeof (lang_input_statement_type)));
d410 1
a410 1
      p->local_sym_name = concat ("-l", name, (const char *) NULL);
d442 4
a445 4
  p->the_bfd = (bfd *) NULL;
  p->asymbols = (asymbol **) NULL;
  p->next_real_file = (lang_statement_union_type *) NULL;
  p->next = (lang_statement_union_type *) NULL;
d448 1
d458 3
a460 4
lang_add_input_file (name, file_type, target)
     const char *name;
     lang_input_file_enum_type file_type;
     const char *target;
d469 1
a469 1
lang_init ()
d480 2
a481 3
  first_file = lang_add_input_file ((char *) NULL,
				    lang_input_file_is_marker_enum,
				    (char *) NULL);
d487 12
d509 7
a515 1
  which is created when looked up to be the entire data space.  */
d521 1
a521 2
lang_memory_region_lookup (name)
     const char *const name;
d524 1
d530 7
a536 9
  for (p = lang_memory_region_list;
       p != (lang_memory_region_type *) NULL;
       p = p->next)
    {
      if (strcmp (p->name, name) == 0)
	{
	  return p;
	}
    }
d545 1
a545 1
  if (strcmp (name, "*default*") == 0)
d547 2
a548 4
      if (lang_memory_region_list != (lang_memory_region_type *) NULL)
	{
	  return lang_memory_region_list;
	}
d552 2
a553 15
  {
    lang_memory_region_type *new =
    (lang_memory_region_type *) stat_alloc (sizeof (lang_memory_region_type));

    new->name = xstrdup (name);
    new->next = (lang_memory_region_type *) NULL;

    *lang_memory_region_list_tail = new;
    lang_memory_region_list_tail = &new->next;
    new->origin = 0;
    new->flags = 0;
    new->not_flags = 0;
    new->length = ~(bfd_size_type) 0;
    new->current = 0;
    new->had_full_message = FALSE;
d555 15
a569 2
    return new;
  }
d573 1
a573 2
lang_memory_default (section)
     asection *section;
d583 1
a583 3
  for (p = lang_memory_region_list;
       p != (lang_memory_region_type *) NULL;
       p = p->next)
d591 1
a591 1
  return lang_memory_region_lookup ("*default*");
d595 1
a595 2
lang_output_section_find (name)
     const char *const name;
d600 1
a600 3
  for (u = lang_output_section_statement.head;
       u != (lang_statement_union_type *) NULL;
       u = lookup->next)
d604 1
a604 3
	{
	  return lookup;
	}
d606 1
a606 1
  return (lang_output_section_statement_type *) NULL;
d610 1
a610 2
lang_output_section_statement_lookup (name)
     const char *const name;
d615 1
a615 1
  if (lookup == (lang_output_section_statement_type *) NULL)
d617 4
a620 6

      lookup = (lang_output_section_statement_type *)
	new_stat (lang_output_section_statement, stat_ptr);
      lookup->region = (lang_memory_region_type *) NULL;
      lookup->lma_region = (lang_memory_region_type *) NULL;
      lookup->fill = (fill_type *) 0;
d624 3
a626 3
      lookup->next = (lang_statement_union_type *) NULL;
      lookup->bfd_section = (asection *) NULL;
      lookup->processed = FALSE;
d628 1
a628 1
      lookup->addr_tree = (etree_type *) NULL;
d631 1
a631 1
      lookup->memspec = (const char *) NULL;
d635 1
a635 1
      lookup->load_base = (union etree_union *) NULL;
d647 1
a647 2
lang_map_flags (flag)
     flagword flag;
d666 1
a666 1
lang_map ()
d674 1
a674 3
  for (m = lang_memory_region_list;
       m != (lang_memory_region_type *) NULL;
       m = m->next)
d720 1
a720 2
init_os (s)
     lang_output_section_statement_type *s;
d730 1
a730 2
  new = ((section_userdata_type *)
	 stat_alloc (sizeof (section_userdata_type)));
d733 1
a733 1
  if (s->bfd_section == (asection *) NULL)
d735 1
a735 1
  if (s->bfd_section == (asection *) NULL)
d745 1
a745 1
  get_userdata (s->bfd_section) = (PTR) new;
d760 1
a760 2
exp_init_os (exp)
     etree_type *exp;
d779 4
d839 1
a839 4
section_already_linked (abfd, sec, data)
     bfd *abfd;
     asection *sec;
     PTR data;
d841 1
a841 1
  lang_input_statement_type *entry = (lang_input_statement_type *) data;
d925 3
a927 1
	     section.  */
d929 1
d941 1
a941 2
  l = ((struct already_linked *)
       bfd_hash_allocate (&already_linked_table, sizeof *l));
d952 3
a954 4
already_linked_newfunc (entry, table, string)
     struct bfd_hash_entry *entry ATTRIBUTE_UNUSED;
     struct bfd_hash_table *table;
     const char *string ATTRIBUTE_UNUSED;
d961 1
a961 1
  return (struct bfd_hash_entry *) ret;
d965 1
a965 1
already_linked_table_init ()
d974 1
a974 1
already_linked_table_free ()
d992 1
a992 2
wildcardp (pattern)
     const char *pattern;
d1009 4
a1012 5
lang_add_section (ptr, section, output, file)
     lang_statement_list_type *ptr;
     asection *section;
     lang_output_section_statement_type *output;
     lang_input_statement_type *file;
d1025 1
a1025 1
      && ((flags & SEC_DEBUGGING) != 0 || !link_info.relocateable))
d1084 1
a1084 1
      if (! link_info.relocateable)
a1104 4
      /* For now make .tbss normal section.  */
      if ((flags & SEC_THREAD_LOCAL) && ! link_info.relocateable)
	flags |= SEC_LOAD;

d1157 4
a1160 5
wild_sort (wild, sec, file, section)
     lang_wild_statement_type *wild;
     struct wildcard_list *sec;
     lang_input_statement_type *file;
     asection *section;
d1256 5
a1260 6
output_section_callback (ptr, sec, section, file, output)
     lang_wild_statement_type *ptr;
     struct wildcard_list *sec;
     asection *section;
     lang_input_statement_type *file;
     PTR output;
d1316 1
a1316 2
lookup_name (name)
     const char *name;
d1321 1
a1321 1
       search != (lang_input_statement_type *) NULL;
d1324 6
a1329 1
      if (search->filename == (char *) NULL && name == (char *) NULL)
d1331 3
a1333 3
      if (search->filename != (char *) NULL
	  && name != (char *) NULL
	  && strcmp (search->filename, name) == 0)
d1337 2
a1338 2
  if (search == (lang_input_statement_type *) NULL)
    search = new_afile (name, lang_input_file_is_file_enum, default_target,
d1346 1
a1346 1
      || search->filename == (const char *) NULL)
d1349 1
a1349 1
  if (! load_symbols (search, (lang_statement_list_type *) NULL))
d1358 2
a1359 3
load_symbols (entry, place)
     lang_input_statement_type *entry;
     lang_statement_list_type *place;
d1490 3
a1492 4
wild (s, target, output)
     lang_wild_statement_type *s;
     const char *target ATTRIBUTE_UNUSED;
     lang_output_section_statement_type *output;
d1496 1
a1496 1
  walk_wild (s, output_section_callback, (PTR) output);
d1514 1
a1514 3
get_target (target, data)
     const bfd_target *target;
     PTR data;
d1516 1
a1516 1
  const char *sought = (const char *) data;
d1524 1
a1524 3
stricpy (dest, src)
     char *dest;
     char *src;
d1538 1
a1538 3
strcut (haystack, needle)
     char *haystack;
     char *needle;
d1557 1
a1557 3
name_compare (first, second)
     char *first;
     char *second;
d1570 1
a1570 1
  /* Remove and endian strings from the name.  */
d1600 1
a1600 3
closest_target_match (target, data)
     const bfd_target *target;
     PTR data;
d1602 1
a1602 1
  const bfd_target *original = (const bfd_target *) data;
d1636 1
a1636 1
get_first_input_target ()
d1662 1
a1662 1
lang_get_output_target ()
d1667 1
a1667 1
  if (output_target != (char *) NULL)
d1687 1
a1687 2
open_output (name)
     const char *name;
d1701 1
a1701 1
      target = bfd_search_for_target (get_target, (PTR) output_target);
d1727 2
a1728 2
		  (void) bfd_search_for_target (closest_target_match,
						(PTR) target);
d1743 1
a1743 1
  if (output == (bfd *) NULL)
d1765 1
a1765 1
  if (link_info.hash == (struct bfd_link_hash_table *) NULL)
d1773 1
a1773 2
ldlang_open_output (statement)
     lang_statement_union_type *statement;
d1778 1
a1778 1
      ASSERT (output_bfd == (bfd *) NULL);
d1781 1
a1781 1
      if (config.magic_demand_paged && !link_info.relocateable)
d1803 24
d1830 1
a1830 3
open_input_bfds (s, force)
     lang_statement_union_type *s;
     bfd_boolean force;
d1832 1
a1832 1
  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
d1846 1
a1846 1
	    (void) lookup_name (s->wild_statement.filename);
d1908 1
a1908 1
lang_reasonable_defaults ()
d1923 1
a1923 1
      new->filename = (char *) NULL;
d1929 79
d2019 1
a2019 2
ldlang_add_undef (name)
     const char *const name;
d2022 1
a2022 2
    ((ldlang_undef_chain_list_type *)
     stat_alloc (sizeof (ldlang_undef_chain_list_type)));
d2036 1
a2036 2
insert_undefined (name)
     const char *name;
d2041 1
a2041 1
  if (h == (struct bfd_link_hash_entry *) NULL)
d2056 1
a2056 1
lang_place_undefineds ()
d2060 2
a2061 6
  for (ptr = ldlang_undef_chain_list_head;
       ptr != (ldlang_undef_chain_list_type *) NULL;
       ptr = ptr->next)
    {
      insert_undefined (ptr->name);
    }
d2067 3
a2069 4
map_input_to_output_sections (s, target, output_section_statement)
     lang_statement_union_type *s;
     const char *target;
     lang_output_section_statement_type *output_section_statement;
d2071 1
a2071 1
  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
d2098 5
a2105 1
	case lang_data_statement_enum:
d2146 1
a2146 1
strip_excluded_output_sections ()
d2177 2
a2178 2
print_output_section_statement (output_section_statement)
     lang_output_section_statement_type *output_section_statement;
d2223 2
a2224 3
print_assignment (assignment, output_section)
     lang_assignment_statement_type *assignment;
     lang_output_section_statement_type *output_section;
d2262 1
a2262 2
print_input_statement (statm)
     lang_input_statement_type *statm;
d2264 1
a2264 1
  if (statm->filename != (char *) NULL)
d2274 1
a2274 3
print_one_symbol (hash_entry, ptr)
     struct bfd_link_hash_entry *hash_entry;
     PTR ptr;
d2276 1
a2276 1
  asection *sec = (asection *) ptr;
d2300 1
a2300 2
print_input_section (in)
     lang_input_section_type *in;
d2304 2
a2305 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
d2329 1
a2329 1
		 i->output_section->vma + i->output_offset, size / opb,
d2349 1
a2349 1
	  bfd_link_hash_traverse (link_info.hash, print_one_symbol, (PTR) i);
d2351 2
a2352 1
	  print_dot = i->output_section->vma + i->output_offset + size / opb;
d2358 1
a2358 2
print_fill_statement (fill)
     lang_fill_statement_type *fill;
d2369 1
a2369 2
print_data_statement (data)
     lang_data_statement_type *data;
a2374 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
d2376 1
d2420 1
a2420 2
  print_dot = addr + size / opb;

d2427 1
a2427 2
print_address_statement (address)
     lang_address_statement_type *address;
d2437 1
a2437 2
print_reloc_statement (reloc)
     lang_reloc_statement_type *reloc;
a2441 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
d2443 1
d2464 1
a2464 1
  print_dot = addr + size / opb;
d2468 1
a2468 2
print_padding_statement (s)
     lang_padding_statement_type *s;
a2471 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
d2473 1
d2498 1
a2498 1
  print_dot = addr + s->size / opb;
d2502 2
a2503 3
print_wild_statement (w, os)
     lang_wild_statement_type *w;
     lang_output_section_statement_type *os;
d2550 2
a2551 3
print_group (s, os)
     lang_group_statement_type *s;
     lang_output_section_statement_type *os;
d2562 2
a2563 3
print_statement_list (s, os)
     lang_statement_union_type *s;
     lang_output_section_statement_type *os;
d2576 2
a2577 3
print_statement (s, os)
     lang_statement_union_type *s;
     lang_output_section_statement_type *os;
d2647 1
a2647 1
print_statements ()
d2658 1
a2658 3
dprint_statement (s, n)
     lang_statement_union_type *s;
     int n;
d2679 5
a2683 6
insert_pad (ptr, fill, alignment_needed, output_section, dot)
     lang_statement_union_type **ptr;
     fill_type *fill;
     unsigned int alignment_needed;
     asection *output_section;
     bfd_vma dot;
d2700 1
a2700 2
      pad = ((lang_statement_union_type *)
	     stat_alloc (sizeof (lang_padding_statement_type)));
d2705 1
a2705 1
      if (fill == (fill_type *) 0)
d2717 4
a2720 5
size_input_section (this_ptr, output_section_statement, fill, dot)
     lang_statement_union_type **this_ptr;
     lang_output_section_statement_type *output_section_statement;
     fill_type *fill;
     bfd_vma dot;
a2726 2
      unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						    ldfile_output_machine);
d2746 1
a2746 1
	  insert_pad (this_ptr, fill, alignment_needed * opb, o, dot);
d2756 1
a2756 1
	dot += i->_cooked_size / opb;
d2758 2
a2759 2
	dot += i->_raw_size / opb;
      o->_raw_size = (dot - o->vma) * opb;
d2770 5
a2774 2
  (((bfd_get_section_flags (bfd, s) & (SEC_ALLOC | SEC_LOAD))	\
    != (SEC_ALLOC | SEC_LOAD))					\
d2782 1
a2782 1
lang_check_section_addresses ()
a2784 1
  unsigned opb = bfd_octets_per_byte (output_bfd);
d2812 1
a2812 1
	  s_start  = bfd_section_lma (output_bfd, s);
d2814 2
a2815 2
	  s_end    = s_start  + bfd_section_size (output_bfd, s) / opb - 1;
	  os_end   = os_start + bfd_section_size (output_bfd, os) / opb - 1;
d2838 4
a2841 5
os_region_check (os, region, tree, base)
     lang_output_section_statement_type *os;
     struct memory_region_struct *region;
     etree_type *tree;
     bfd_vma base;
d2848 1
a2848 1
      if (tree != (etree_type *) NULL)
d2871 8
a2878 9
lang_size_sections_1 (s, output_section_statement, prev, fill, dot, relax,
		      check_regions)
     lang_statement_union_type *s;
     lang_output_section_statement_type *output_section_statement;
     lang_statement_union_type **prev;
     fill_type *fill;
     bfd_vma dot;
     bfd_boolean *relax;
     bfd_boolean check_regions;
a2879 3
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);

d2881 1
a2881 1
  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
d2924 1
a2924 1
		if (os->addr_tree == (etree_type *) NULL)
d2928 1
a2928 1
		    if (os->region == (lang_memory_region_type *) NULL
d2932 1
a2932 1
			    && strcmp (os->region->name, "*default*") == 0))
d2939 3
a2941 6
		       defined, issue a warning.  */
		    if ((bfd_get_section_flags (output_bfd, os->bfd_section)
			 & (SEC_ALLOC | SEC_LOAD)) != 0
			&& (bfd_get_section_flags (output_bfd, os->bfd_section)
			    & SEC_NEVER_LOAD) == 0
			&& ! link_info.relocateable
d2943 1
a2943 1
			&& strcmp (os->region->name, "*default*") == 0
d2946 1
a2946 1
				    "*default*") != 0
d2948 19
a2966 3
		      einfo (_("%P: warning: no memory region specified for section `%s'\n"),
			     bfd_get_section_name (output_bfd,
						   os->bfd_section));
d2987 1
d2992 2
d2995 1
a2995 1
		      einfo (_("%F%S: non constant address expression for section %s\n"),
d3017 4
a3020 3
	    after = align_n (os->bfd_section->vma
			     + os->bfd_section->_raw_size / opb,
			     (bfd_vma) os->block_value);
a3023 4
	    else if ((os->bfd_section->flags & SEC_HAS_CONTENTS) == 0
		     && (os->bfd_section->flags & SEC_THREAD_LOCAL)
		     && ! link_info.relocateable)
	      os->bfd_section->_raw_size = 0;
d3025 9
a3033 2
	      os->bfd_section->_raw_size =
		(after - os->bfd_section->vma) * opb;
d3035 1
a3035 2
	    dot = os->bfd_section->vma + os->bfd_section->_raw_size / opb;
	    os->processed = TRUE;
d3049 1
a3049 1
	    if (os->region != (lang_memory_region_type *) NULL
d3072 1
a3072 1
		      os->bfd_section->_raw_size / opb;
d3097 5
d3120 3
a3122 3
	    if (size < opb)
	      size = opb;
	    dot += size / opb;
d3144 1
a3144 1
	    dot += size / opb;
d3212 1
a3212 1
		    lang_memory_region_lookup ("*default*")->current = newdot;
d3219 1
a3219 1
		    insert_pad (&s->header.next, fill, (newdot - dot) * opb,
d3226 6
d3275 8
a3282 9
lang_size_sections (s, output_section_statement, prev, fill, dot, relax,
		    check_regions)
     lang_statement_union_type *s;
     lang_output_section_statement_type *output_section_statement;
     lang_statement_union_type **prev;
     fill_type *fill;
     bfd_vma dot;
     bfd_boolean *relax;
     bfd_boolean check_regions;
d3285 4
d3307 1
d3313 8
d3324 8
a3331 6
bfd_vma
lang_do_assignments (s, output_section_statement, fill, dot)
     lang_statement_union_type *s;
     lang_output_section_statement_type *output_section_statement;
     fill_type *fill;
     bfd_vma dot;
d3333 1
a3333 4
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);

  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
d3338 4
a3341 4
	  dot = lang_do_assignments (constructor_list.head,
				     output_section_statement,
				     fill,
				     dot);
d3352 3
a3354 3
		(void) lang_do_assignments (os->children.head, os,
					    os->fill, dot);
		dot = os->bfd_section->vma + os->bfd_section->_raw_size / opb;
d3372 3
a3374 3
	  dot = lang_do_assignments (s->wild_statement.children.head,
				     output_section_statement,
				     fill, dot);
a3391 1
	    s->data_statement.value = value.value;
d3394 2
d3417 3
a3419 3
	    if (size < opb)
	      size = opb;
	    dot += size / opb;
d3434 1
a3434 1
	  dot += bfd_get_reloc_size (s->reloc_statement.howto) / opb;
d3442 1
a3442 1
	      dot += in->_cooked_size / opb;
d3444 1
a3444 1
	      dot += in->_raw_size / opb;
d3464 1
a3464 1
	  dot += s->padding_statement.size / opb;
d3468 3
a3470 3
	  dot = lang_do_assignments (s->group_statement.children.head,
				     output_section_statement,
				     fill, dot);
d3485 11
d3504 1
a3504 1
lang_set_startof ()
d3508 1
a3508 1
  if (link_info.relocateable)
a3532 4
	  unsigned opb;

	  opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
					       ldfile_output_machine);
d3535 1
a3535 1
	    h->u.def.value = s->_cooked_size / opb;
d3537 1
a3537 1
	    h->u.def.value = s->_raw_size / opb;
d3546 1
a3546 1
lang_finish ()
d3551 1
a3551 1
  if (link_info.relocateable || link_info.shared)
d3556 1
a3556 1
  if (entry_symbol.name == (const char *) NULL)
d3566 1
a3566 1
  if (h != (struct bfd_link_hash_entry *) NULL
d3600 1
a3600 1
	  if (ts != (asection *) NULL)
d3619 2
a3626 1
#ifdef ANSI_PROTOTYPES
a3627 4
#else
ignore_bfd_errors (s)
     const char *s ATTRIBUTE_UNUSED;
#endif
d3637 1
a3637 1
lang_check ()
d3643 1
a3643 3
  for (file = file_chain.head;
       file != (lang_statement_union_type *) NULL;
       file = file->input_statement.next)
d3655 1
a3655 1
      if ((link_info.relocateable || link_info.emitrelocations)
d3690 1
a3690 1
		einfo (_("%E%X: failed to merge target specific data of file %B\n"),
d3704 1
a3704 1
lang_common ()
d3708 1
a3708 1
  if (link_info.relocateable
d3713 1
a3713 1
    bfd_link_hash_traverse (link_info.hash, lang_one_common, (PTR) NULL);
d3719 1
a3719 2
	bfd_link_hash_traverse (link_info.hash, lang_one_common,
				(PTR) &power);
d3726 1
a3726 3
lang_one_common (h, info)
     struct bfd_link_hash_entry *h;
     PTR info;
a3730 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
d3744 3
a3746 3
  /* Increase the size of the section.  */
  section->_cooked_size = align_n ((section->_cooked_size + opb - 1) / opb,
				   (bfd_vma) 1 << power_of_two) * opb;
d3820 1
a3820 1
lang_place_orphans ()
d3826 1
a3826 3
      for (s = file->the_bfd->sections;
	   s != (asection *) NULL;
	   s = s->next)
d3828 1
a3828 1
	  if (s->output_section == (asection *) NULL)
d3842 1
a3842 1
		  if (! link_info.relocateable
d3876 1
a3876 4
lang_set_flags (ptr, flags, invert)
     lang_memory_region_type *ptr;
     const char *flags;
     int invert;
d3918 1
a3918 2
lang_for_each_input_file (func)
     void (*func) PARAMS ((lang_input_statement_type *));
d3933 1
a3933 2
lang_for_each_file (func)
     void (*func) PARAMS ((lang_input_statement_type *));
a3940 4
#if 0

/* Not used.  */

d3942 1
a3942 21
lang_for_each_input_section (func)
     void (*func) PARAMS ((bfd *ab, asection *as));
{
  LANG_FOR_EACH_INPUT_STATEMENT (f)
    {
      asection *s;

      for (s = f->the_bfd->sections;
	   s != (asection *) NULL;
	   s = s->next)
	{
	  func (f->the_bfd, s);
	}
    }
}

#endif

void
ldlang_add_file (entry)
     lang_input_statement_type *entry;
d3952 1
a3952 1
  ASSERT (entry->the_bfd->link_next == (bfd *) NULL);
d3954 1
a3954 3
  for (pp = &link_info.input_bfds;
       *pp != (bfd *) NULL;
       pp = &(*pp)->link_next)
d3957 1
a3957 1
  entry->the_bfd->usrdata = (PTR) entry;
d3970 1
a3970 1
  bfd_map_over_sections (entry->the_bfd, section_already_linked, (PTR) entry);
d3974 1
a3974 3
lang_add_output (name, from_script)
     const char *name;
     int from_script;
d3987 1
a3987 2
topower (x)
     int x;
d4006 6
a4011 10
lang_enter_output_section_statement (output_section_statement_name,
				     address_exp, sectype, block_value,
				     align, subalign, ebase)
     const char *output_section_statement_name;
     etree_type *address_exp;
     enum section_type sectype;
     bfd_vma block_value;
     etree_type *align;
     etree_type *subalign;
     etree_type *ebase;
d4026 1
a4026 1
  if (os->addr_tree == (etree_type *) NULL)
d4035 1
a4035 1
  os->block_value = block_value ? block_value : 1;
d4048 1
a4048 1
lang_final ()
d4059 1
a4059 1
lang_reset_memory_regions ()
d4064 1
a4064 3
  for (p = lang_memory_region_list;
       p != (lang_memory_region_type *) NULL;
       p = p->next)
d4078 5
a4082 6
gc_section_callback (ptr, sec, section, file, data)
     lang_wild_statement_type *ptr;
     struct wildcard_list *sec ATTRIBUTE_UNUSED;
     asection *section;
     lang_input_statement_type *file ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
d4091 1
a4091 2
lang_gc_wild (s)
     lang_wild_statement_type *s;
d4099 1
a4099 2
lang_gc_sections_1 (s)
     lang_statement_union_type *s;
d4101 1
a4101 1
  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
d4124 1
a4124 1
lang_gc_sections ()
d4141 1
a4141 1
      if (h != (struct bfd_link_hash_entry *) NULL
d4154 1
a4154 1
lang_process ()
d4161 1
d4212 1
a4212 2
  map_input_to_output_sections (statement_list.head, (char *) NULL,
				(lang_output_section_statement_type *) NULL);
d4217 1
a4217 1
  if (! link_info.relocateable)
d4222 1
a4222 1
      if (found != (asection *) NULL)
d4235 1
a4235 1
  if (!link_info.relocateable)
d4243 2
a4244 3
  lang_size_sections (statement_list.head,
		      abs_output_section,
		      &statement_list.head, 0, (bfd_vma) 0, NULL,
a4254 2
	  lang_reset_memory_regions ();

d4263 6
a4268 3
	  lang_do_assignments (statement_list.head,
			       abs_output_section,
			       (fill_type *) 0, (bfd_vma) 0);
d4272 2
a4273 4
	  lang_size_sections (statement_list.head,
			      abs_output_section,
			      &statement_list.head, 0, (bfd_vma) 0,
			      &relax_again, FALSE);
d4277 1
a4277 1
	  if (!relax_again && !link_info.relax_finalizing)
d4279 1
a4279 1
	      link_info.relax_finalizing = TRUE;
d4286 1
d4288 2
a4289 7
      lang_do_assignments (statement_list.head,
			   abs_output_section,
			   (fill_type *) 0, (bfd_vma) 0);
      lang_size_sections (statement_list.head,
			  abs_output_section,
			  & statement_list.head, 0, (bfd_vma) 0, 
			  NULL, TRUE);
d4302 1
a4302 3
  lang_do_assignments (statement_list.head,
		       abs_output_section,
		       (fill_type *) 0, (bfd_vma) 0);
d4305 1
a4305 1
  if (! link_info.relocateable
d4318 3
a4320 4
lang_add_wild (filespec, section_list, keep_sections)
     struct wildcard_spec *filespec;
     struct wildcard_list *section_list;
     bfd_boolean keep_sections;
d4359 1
a4359 3
lang_section_start (name, address)
     const char *name;
     etree_type *address;
d4374 1
a4374 3
lang_add_entry (name, cmdline)
     const char *name;
     bfd_boolean cmdline;
d4386 1
a4386 2
lang_add_target (name)
     const char *name;
d4396 1
a4396 2
lang_add_map (name)
     const char *name;
d4411 1
a4411 2
lang_add_fill (fill)
     fill_type *fill;
d4420 1
a4420 3
lang_add_data (type, exp)
     int type;
     union etree_union *exp;
d4439 5
a4443 6
lang_add_reloc (reloc, howto, section, name, addend)
     bfd_reloc_code_real_type reloc;
     reloc_howto_type *howto;
     asection *section;
     const char *name;
     union etree_union *addend;
d4459 1
a4459 2
lang_add_assignment (exp)
     etree_type *exp;
d4469 1
a4469 2
lang_add_attribute (attribute)
     enum statement_enum attribute;
d4475 1
a4475 2
lang_startup (name)
     const char *name;
d4477 1
a4477 1
  if (startup_file != (char *) NULL)
d4489 1
a4489 2
lang_float (maybe)
     bfd_boolean maybe;
d4498 5
a4502 4
   MEMSPEC is the name of the run-time region, or "*default*" if the
   statement didn't specify one.  LMA_MEMSPEC is the name of the
   load-time region, or null if the statement didn't specify one.
   HAVE_LMA_P is TRUE if the statement had an explicit load address.
d4507 14
a4520 10
lang_get_regions (region, lma_region, memspec, lma_memspec, have_lma_p)
     struct memory_region_struct **region, **lma_region;
     const char *memspec, *lma_memspec;
     int have_lma_p;
{
  *lma_region = lang_memory_region_lookup (lma_memspec);

  /* If no runtime region has been given, but the load region has
     been, use the load region.  */
  if (lma_memspec != 0 && strcmp (memspec, "*default*") == 0)
d4523 1
a4523 1
    *region = lang_memory_region_lookup (memspec);
d4525 1
a4525 1
  if (have_lma_p && lma_memspec != 0)
d4530 3
a4532 5
lang_leave_output_section_statement (fill, memspec, phdrs, lma_memspec)
     fill_type *fill;
     const char *memspec;
     struct lang_output_section_phdr_list *phdrs;
     const char *lma_memspec;
d4537 2
a4538 1
		    current_section->load_base != 0);
d4550 1
a4550 3
lang_abs_symbol_at_beginning_of (secname, name)
     const char *secname;
     const char *name;
d4555 1
a4555 1
  if (h == (struct bfd_link_hash_entry *) NULL)
d4566 1
a4566 1
      if (sec == (asection *) NULL)
d4581 1
a4581 3
lang_abs_symbol_at_end_of (secname, name)
     const char *secname;
     const char *name;
d4586 1
a4586 1
  if (h == (struct bfd_link_hash_entry *) NULL)
d4597 1
a4597 1
      if (sec == (asection *) NULL)
d4601 1
a4601 2
			  + bfd_section_size (output_bfd, sec) /
                          bfd_octets_per_byte (output_bfd));
d4608 3
a4610 4
lang_statement_append (list, element, field)
     lang_statement_list_type *list;
     lang_statement_union_type *element;
     lang_statement_union_type **field;
d4619 4
a4622 5
lang_add_output_format (format, big, little, from_script)
     const char *format;
     const char *big;
     const char *little;
     int from_script;
d4641 1
a4641 1
lang_enter_group ()
d4656 1
a4656 1
lang_leave_group ()
d4665 6
a4670 7
lang_new_phdr (name, type, filehdr, phdrs, at, flags)
     const char *name;
     etree_type *type;
     bfd_boolean filehdr;
     bfd_boolean phdrs;
     etree_type *at;
     etree_type *flags;
d4674 1
a4674 1
  n = (struct lang_phdr *) stat_alloc (sizeof (struct lang_phdr));
d4693 1
a4693 1
lang_record_phdrs ()
d4697 1
a4697 1
  struct lang_output_section_phdr_list *last;
d4702 1
a4702 1
  secs = (asection **) xmalloc (alc * sizeof (asection *));
d4716 1
a4716 1
	  struct lang_output_section_phdr_list *pl;
d4742 1
a4742 2
		      secs = ((asection **)
			      xrealloc (secs, alc * sizeof (asection *)));
d4776 1
a4776 1
      struct lang_output_section_phdr_list *pl;
d4793 1
a4793 2
lang_add_nocrossref (l)
     struct lang_nocrossref *l;
d4797 1
a4797 1
  n = (struct lang_nocrossrefs *) xmalloc (sizeof *n);
d4810 2
d4828 1
a4828 2
lang_enter_overlay (vma_expr)
     etree_type *vma_expr;
d4831 3
a4833 1
  ASSERT (overlay_vma == NULL && overlay_max == NULL);
d4836 1
d4844 1
a4844 2
lang_enter_overlay_section (name)
     const char *name;
d4850 1
a4850 1
				       0, 0, 0, 0);
d4859 1
a4859 1
  n = (struct overlay_list *) xmalloc (sizeof *n);
d4877 2
a4878 3
lang_leave_overlay_section (fill, phdrs)
     fill_type *fill;
     struct lang_output_section_phdr_list *phdrs;
d4887 5
a4891 4
  /* For now, assume that "*default*" is the run-time memory region and
     that no load-time region has been specified.  It doesn't really
     matter what we say here, since lang_leave_overlay will override it.  */
  lang_leave_output_section_statement (fill, "*default*", phdrs, 0);
d4921 6
a4926 7
lang_leave_overlay (lma_expr, nocrossrefs, fill, memspec, phdrs, lma_memspec)
     etree_type *lma_expr;
     int nocrossrefs;
     fill_type *fill;
     const char *memspec;
     struct lang_output_section_phdr_list *phdrs;
     const char *lma_memspec;
d4931 1
a4931 1
  struct lang_nocrossref *nocrossref;
d4935 1
a4935 1
		    lma_expr != 0);
d4950 1
a4950 1
      if (fill != (fill_type *) 0 && l->os->fill == (fill_type *) 0)
d4972 1
a4972 1
	  struct lang_nocrossref *nc;
d4974 1
a4974 1
	  nc = (struct lang_nocrossref *) xmalloc (sizeof *nc);
d4999 3
a5001 9
static int
lang_vers_match_lang_c (expr, sym)
     struct bfd_elf_version_expr *expr;
     const char *sym;
{
  if (expr->pattern[0] == '*' && expr->pattern[1] == '\0')
    return 1;
  return fnmatch (expr->pattern, sym, 0) == 0;
}
d5003 4
a5006 4
static int
lang_vers_match_lang_cplusplus (expr, sym)
     struct bfd_elf_version_expr *expr;
     const char *sym;
d5008 3
a5010 2
  char *alt_sym;
  int result;
d5012 12
a5023 2
  if (expr->pattern[0] == '*' && expr->pattern[1] == '\0')
    return 1;
d5025 1
a5025 2
  alt_sym = cplus_demangle (sym, /* DMGL_NO_TPARAMS */ 0);
  if (!alt_sym)
d5027 43
a5069 3
      /* cplus_demangle (also) returns NULL when it is not a C++ symbol.
	 Should we early out FALSE in this case?  */
      result = fnmatch (expr->pattern, sym, 0) == 0;
d5071 4
d5076 2
d5079 14
a5092 2
      result = fnmatch (expr->pattern, alt_sym, 0) == 0;
      free (alt_sym);
d5095 6
a5100 1
  return result;
d5103 5
a5107 4
static int
lang_vers_match_lang_java (expr, sym)
     struct bfd_elf_version_expr *expr;
     const char *sym;
d5109 22
a5130 2
  char *alt_sym;
  int result;
d5132 2
a5133 2
  if (expr->pattern[0] == '*' && expr->pattern[1] == '\0')
    return 1;
d5135 1
a5135 2
  alt_sym = cplus_demangle (sym, DMGL_JAVA);
  if (!alt_sym)
d5137 2
a5138 3
      /* cplus_demangle (also) returns NULL when it is not a Java symbol.
	 Should we early out FALSE in this case?  */
      result = fnmatch (expr->pattern, sym, 0) == 0;
d5142 2
a5143 2
      result = fnmatch (expr->pattern, alt_sym, 0) == 0;
      free (alt_sym);
a5144 2

  return result;
d5150 3
a5152 4
lang_new_vers_pattern (orig, new, lang)
     struct bfd_elf_version_expr *orig;
     const char *new;
     const char *lang;
d5156 1
a5156 1
  ret = (struct bfd_elf_version_expr *) xmalloc (sizeof *ret);
d5161 1
d5164 1
a5164 1
    ret->match = lang_vers_match_lang_c;
d5166 1
a5166 1
    ret->match = lang_vers_match_lang_cplusplus;
d5168 1
a5168 1
    ret->match = lang_vers_match_lang_java;
d5173 1
a5173 1
      ret->match = lang_vers_match_lang_c;
d5183 2
a5184 3
lang_new_vers_node (globals, locals)
     struct bfd_elf_version_expr *globals;
     struct bfd_elf_version_expr *locals;
d5188 4
a5191 7
  ret = (struct bfd_elf_version_tree *) xmalloc (sizeof *ret);
  ret->next = NULL;
  ret->name = NULL;
  ret->vernum = 0;
  ret->globals = globals;
  ret->locals = locals;
  ret->deps = NULL;
a5192 1
  ret->used = 0;
d5200 96
d5300 3
a5302 4
lang_register_vers_node (name, version, deps)
     const char *name;
     struct bfd_elf_version_tree *version;
     struct bfd_elf_version_deps *deps;
d5323 3
d5329 1
a5329 1
  for (e1 = version->globals; e1 != NULL; e1 = e1->next)
d5335 16
a5350 4
	  for (e2 = t->locals; e2 != NULL; e2 = e2->next)
	    if (strcmp (e1->pattern, e2->pattern) == 0)
	      einfo (_("%X%P: duplicate expression `%s' in version information\n"),
		     e1->pattern);
d5354 1
a5354 1
  for (e1 = version->locals; e1 != NULL; e1 = e1->next)
d5360 16
a5375 4
	  for (e2 = t->globals; e2 != NULL; e2 = e2->next)
	    if (strcmp (e1->pattern, e2->pattern) == 0)
	      einfo (_("%X%P: duplicate expression `%s' in version information\n"),
		     e1->pattern);
d5397 1
a5397 3
lang_add_vers_depend (list, name)
     struct bfd_elf_version_deps *list;
     const char *name;
d5402 1
a5402 1
  ret = (struct bfd_elf_version_deps *) xmalloc (sizeof *ret);
d5420 1
a5420 1
lang_do_version_exports_section ()
d5458 1
a5458 2
lang_add_unique (name)
     const char *name;
d5466 1
a5466 1
  ent = (struct unique_sections *) xmalloc (sizeof *ent);
@


1.7
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2001
d6 1
a6 1
This file is part of GLD, the Gnu Linker.
d8 14
a21 14
GLD is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GLD is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GLD; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
d26 1
a31 1
#include "ldgram.h"
d34 1
d43 3
a45 1
#include <ctype.h>
d47 1
a47 5
/* FORWARDS */
static lang_statement_union_type *new_statement
  PARAMS ((enum statement_enum, size_t, lang_statement_list_type *));

/* LOCALS */
d54 1
a54 1
static boolean placed_commons = false;
d56 1
a56 1
static boolean map_option_f;
d64 3
d71 12
a82 6
  PARAMS ((const char *, lang_input_file_enum_type, const char *, boolean));
static lang_memory_region_type *lang_memory_default PARAMS ((asection *));
static void lang_map_flags PARAMS ((flagword));
static void init_os PARAMS ((lang_output_section_statement_type *));
static void exp_init_os PARAMS ((etree_type *));
static void section_already_linked PARAMS ((bfd *, asection *, PTR));
d85 6
a90 3
static void already_linked_table_init PARAMS ((void));
static void already_linked_table_free PARAMS ((void));
static boolean wildcardp PARAMS ((const char *));
d92 2
a93 2
  PARAMS ((lang_wild_statement_type *, lang_input_statement_type *,
	   asection *));
d95 1
a95 1
  PARAMS ((lang_wild_statement_type *, asection *,
d97 3
a99 2
static lang_input_statement_type *lookup_name PARAMS ((const char *));
static void load_symbols
d102 1
a102 1
  PARAMS ((lang_wild_statement_type *, const char *, const char *,
d104 12
a115 5
static bfd *open_output PARAMS ((const char *));
static void ldlang_open_output PARAMS ((lang_statement_union_type *));
static void open_input_bfds PARAMS ((lang_statement_union_type *, boolean));
static void lang_reasonable_defaults PARAMS ((void));
static void lang_place_undefineds PARAMS ((void));
d119 2
d126 16
a141 8
static void print_input_statement PARAMS ((lang_input_statement_type *));
static boolean print_one_symbol PARAMS ((struct bfd_link_hash_entry *, PTR));
static void print_input_section PARAMS ((lang_input_section_type *));
static void print_fill_statement PARAMS ((lang_fill_statement_type *));
static void print_data_statement PARAMS ((lang_data_statement_type *));
static void print_address_statement PARAMS ((lang_address_statement_type *));
static void print_reloc_statement PARAMS ((lang_reloc_statement_type *));
static void print_padding_statement PARAMS ((lang_padding_statement_type *));
d150 4
a153 3
static void print_statements PARAMS ((void));
static bfd_vma insert_pad
  PARAMS ((lang_statement_union_type **, fill_type,
d157 17
a173 10
	   fill_type, bfd_vma, boolean));
static void lang_finish PARAMS ((void));
static void ignore_bfd_errors PARAMS ((const char *, ...));
static void lang_check PARAMS ((void));
static void lang_common PARAMS ((void));
static boolean lang_one_common PARAMS ((struct bfd_link_hash_entry *, PTR));
static void lang_place_orphans PARAMS ((void));
static int topower PARAMS ((int));
static void lang_set_startof PARAMS ((void));
static void reset_memory_regions PARAMS ((void));
d175 1
a175 1
  PARAMS ((lang_wild_statement_type *, asection *,
d177 5
a181 1
static void lang_record_phdrs PARAMS ((void));
d183 5
a187 3
  PARAMS ((lang_wild_statement_type *, const char *, const char *));
static void lang_gc_sections_1 PARAMS ((lang_statement_union_type *));
static void lang_gc_sections PARAMS ((void));
d194 4
a197 2
static void lang_do_version_exports_section PARAMS ((void));
static void lang_check_section_addresses PARAMS ((void));
d201 7
a207 4

typedef void (*callback_t) PARAMS ((lang_wild_statement_type *,
				    asection *, lang_input_statement_type *,
				    PTR));
d209 1
a209 2
  PARAMS ((lang_wild_statement_type *, const char *, const char *,
	 callback_t, PTR));
d211 2
a212 2
  PARAMS ((lang_wild_statement_type *, const char *,
	   lang_input_statement_type *, callback_t, PTR));
d214 14
a227 2
  PARAMS ((lang_wild_statement_type *, const char *,
	   lang_input_statement_type *, callback_t, PTR));
d229 1
a229 8
static int    get_target PARAMS ((const bfd_target *, PTR));
static void   stricpy PARAMS ((char *, char *));
static void   strcut PARAMS ((char *, char *));
static int    name_compare PARAMS ((char *, char *));
static int    closest_target_match PARAMS ((const bfd_target *, PTR));
static char * get_first_input_target PARAMS ((void));

/* EXPORTS */
d234 7
a240 6
const char *entry_symbol = NULL;
boolean entry_from_cmdline;
boolean lang_has_input_file = false;
boolean had_output_filename = false;
boolean lang_float_flag = false;
boolean delete_output_file_on_failure = false;
d243 1
d273 1
a273 1
boolean
d284 1
a284 1
	return true;
d287 1
a287 1
  return false;
d293 1
a293 1
walk_wild_section (ptr, section, file, callback, data)
a294 1
     const char *section;
d299 6
a304 2
  /* Don't process sections from files which were excluded.  */
  if (ptr->exclude_filename_list != NULL)
d306 7
a312 4
      struct name_list *list_tmp;
      for (list_tmp = ptr->exclude_filename_list;
	   list_tmp;
	   list_tmp = list_tmp->next)
d314 2
a315 1
	  boolean match;
d317 10
a326 4
	  if (wildcardp (list_tmp->name))
	    match = fnmatch (list_tmp->name, file->filename, 0) == 0;
	  else
	    match = strcmp (list_tmp->name, file->filename) == 0;
d328 14
a341 4
	  if (match)
	    return;
	}
    }
d343 3
a345 4
  if (file->just_syms_flag == false)
    {
      register asection *s;
      boolean wildcard = false;
d347 3
a349 2
      if (section != NULL)
	wildcard = wildcardp (section);
d351 5
a355 4
      for (s = file->the_bfd->sections; s != NULL; s = s->next)
	{
	  boolean match;
	  const char *sname = bfd_get_section_name (file->the_bfd, s);
d357 2
a358 6
	  if (section == NULL)
	    match = true;
	  else if (wildcard)
	    match = fnmatch (section, sname, 0) == 0;
	  else
	    match = strcmp (section, sname) == 0;
d360 1
a360 4
	  /* If this is a wild-card output section statement, exclude
	     sections that match UNIQUE_SECTION_LIST.  */
	  if (match && (data == NULL || !unique_section_p (sname)))
	    (*callback) (ptr, s, file, data);
d368 1
a368 1
walk_wild_file (s, section, f, callback, data)
a369 1
     const char *section;
d376 1
a376 1
    walk_wild_section (s, section, f, callback, data);
d393 1
a393 1
	      walk_wild_section (s, section,
d404 1
a404 1
walk_wild (s, section, file, callback, data)
a405 2
     const char *section;
     const char *file;
d409 3
a411 1
  if (file == (char *) NULL)
d416 1
a416 1
	  walk_wild_file (s, section, f, callback, data);
d419 1
a419 1
  else if (wildcardp (file))
d423 2
a424 2
	  if (fnmatch (file, f->filename, FNM_FILE_NAME) == 0)
	    walk_wild_file (s, section, f, callback, data);
d432 3
a434 2
      f = lookup_name (file);
      walk_wild_file (s, section, f, callback, data);
d446 1
a446 1
  for (; s != (lang_statement_union_type *) NULL; s = s->next)
d527 1
a527 1
   they may, for example be split over serveral lines like foo.o(.text)
d536 1
a536 1
     boolean add_to_list;
d549 1
a549 1
  lang_has_input_file = true;
d551 1
d556 2
a557 2
      p->is_archive = false;
      p->real = true;
d559 2
a560 2
      p->just_syms_flag = true;
      p->search_dirs_flag = false;
d564 2
a565 2
      p->is_archive = false;
      p->real = false;
d567 2
a568 2
      p->just_syms_flag = false;
      p->search_dirs_flag = false;
d571 1
a571 1
      p->is_archive = true;
d573 1
a573 1
      p->real = true;
d575 2
a576 2
      p->just_syms_flag = false;
      p->search_dirs_flag = true;
d580 2
a581 2
      p->is_archive = false;
      p->real = false;
d583 2
a584 2
      p->just_syms_flag = false;
      p->search_dirs_flag = true;
d587 1
d589 2
a590 2
      p->is_archive = false;
      p->real = true;
d592 2
a593 2
      p->just_syms_flag = false;
      p->search_dirs_flag = true;
d597 2
a598 2
      p->is_archive = false;
      p->real = true;
d600 2
a601 2
      p->just_syms_flag = false;
      p->search_dirs_flag = false;
d613 1
a613 1
  p->loaded = false;
d626 2
a627 2
  lang_has_input_file = true;
  return new_afile (name, file_type, target, true);
d673 4
d717 1
a717 1
    new->had_full_message = false;
d782 1
a782 1
      lookup->fill = 0;
d788 1
a788 1
      lookup->processed = false;
d798 1
d894 1
a894 1
    einfo (_("%P%F: Illegal use of `%s' section"), DISCARD_SECTION_NAME);
d918 3
d1018 1
a1018 2
      sec->output_section = bfd_abs_section_ptr;
      sec->output_offset = sec->vma;
d1041 1
a1041 1
     causes trouble for MIPS ELF, which relies in link once semantics
d1048 1
a1048 1
     bfd_hash_lookup (&already_linked_table, name, true, false));
d1090 3
a1092 5
	  /* Set the output_section field so that wild_doit does not
	     create a lang_input_section structure for this section.
	     Since there might be a symbol in the section being
	     discarded, we must retain a pointer to the section which
	     we are really going to use.  */
d1094 3
a1096 1
	  sec->kept_section = l->sec;
d1151 1
a1151 1
/* Return true if the PATTERN argument is a wildcard pattern.
d1154 1
a1154 1
   be enough to cause the the pattern to be treated as a wildcard.
d1157 1
a1157 1
static boolean
d1167 2
a1168 2
      return true;
  return false;
d1176 1
a1176 1
wild_doit (ptr, section, output, file)
d1183 1
a1183 1
  boolean discard;
d1187 1
a1187 1
  discard = false;
d1189 6
a1194 5
  /* If we are doing a final link, discard sections marked with
     SEC_EXCLUDE.  */
  if (! link_info.relocateable
      && (flags & SEC_EXCLUDE) != 0)
    discard = true;
d1199 1
a1199 1
    discard = true;
d1205 1
a1205 1
    discard = true;
d1219 1
a1219 1
      boolean first;
d1262 15
d1279 3
d1310 1
a1310 1
      /* If supplied an aligment, then force it.  */
d1329 1
a1329 1
wild_sort (wild, file, section)
d1331 1
d1338 1
a1338 1
  if (! wild->filenames_sorted && ! wild->sections_sorted)
d1342 1
a1342 1
  for (l = wild->children.head; l != NULL; l = l->next)
d1356 1
a1356 1
	  boolean fa, la;
d1368 1
a1368 1
	      fa = true;
d1373 1
a1373 1
	      fa = false;
d1380 1
a1380 1
	      la = true;
d1385 1
a1385 1
	      la = false;
d1412 1
a1412 1
      if (wild->sections_sorted)
d1429 1
a1429 1
output_section_callback (ptr, section, file, output)
d1431 1
d1438 4
d1447 1
a1447 1
  before = wild_sort (ptr, file, section);
d1455 3
a1457 3
    wild_doit (&ptr->children, section,
	       (lang_output_section_statement_type *) output,
	       file);
d1464 3
a1466 3
      wild_doit (&list, section,
		 (lang_output_section_statement_type *) output,
		 file);
d1472 1
a1472 1
	  ASSERT (list.head->next == NULL);
d1476 1
a1476 1
	       pp = &(*pp)->next)
d1479 1
a1479 1
	  list.head->next = *pp;
d1509 1
a1509 1
			false);
d1519 2
a1520 1
  load_symbols (search, (lang_statement_list_type *) NULL);
d1527 1
a1527 1
static void
d1535 1
a1535 1
    return;
d1544 2
d1551 1
a1551 1
	return;
d1565 3
a1567 1
	einfo (_("%F%B: file not recognized: %E\n"), entry->the_bfd);
d1577 2
d1580 1
a1580 1
      ldfile_assumed_script = true;
d1583 1
a1583 1
      ldfile_assumed_script = false;
d1585 1
d1588 1
a1588 1
      return;
d1592 1
a1592 1
    return;
d1612 4
a1615 3
	  bfd *member = bfd_openr_next_archived_file (entry->the_bfd,
						      (bfd *) NULL);
	  while (member != NULL)
d1617 5
d1623 6
a1628 2
		einfo (_("%F%B: object %B in archive is not object\n"),
		       entry->the_bfd, member);
d1632 1
d1634 4
a1637 3
		einfo (_("%F%B: could not read symbols: %E\n"), member);
	      member = bfd_openr_next_archived_file (entry->the_bfd,
						     member);
d1640 2
a1641 3
	  entry->loaded = true;

	  return;
d1643 1
d1646 3
a1648 1
  if (! bfd_link_add_symbols (entry->the_bfd, &link_info))
d1651 1
a1651 1
  entry->loaded = true;
d1654 5
a1658 4
/* Handle a wild statement.  SECTION or FILE or both may be NULL,
   indicating that it is a wildcard.  Separate lang_input_section
   statements are created for each part of the expansion; they are
   added after the wild statement S.  OUTPUT is the output section.  */
d1661 1
a1661 1
wild (s, section, file, target, output)
a1662 2
     const char *section;
     const char *file;
d1666 3
a1668 1
  walk_wild (s, section, file, output_section_callback, (PTR) output);
d1670 1
a1670 3
  if (section != (char *) NULL
      && strcmp (section, "COMMON") == 0
      && default_common_section == NULL)
d1672 8
a1679 3
      /* Remember the section that common is going to in case we later
         get something which doesn't know where to put it.  */
      default_common_section = output;
d1683 1
a1683 1
/* Return true iff target is the sought target.  */
d1705 1
a1705 6
    {
      if (isupper ((unsigned char) c))
	c = tolower (c);

      *dest++ = c;
    }
d1710 1
a1710 1
/* Remove the first occurance of needle (if any) in haystack
d1843 23
d1874 1
a1874 18
  /* Has the user told us which output format to use?  */
  if (output_target == (char *) NULL)
    {
      /* No - has the current target been set to something other than
         the default?  */
      if (current_target != default_target)
	output_target = current_target;

      /* No - can we determine the format of the first input file?  */
      else
	{
	  output_target = get_first_input_target ();

	  /* Failed - use the default output target.  */
	  if (output_target == NULL)
	    output_target = default_target;
	}
    }
d1934 1
a1934 1
  delete_output_file_on_failure = true;
d1992 1
a1992 1
     boolean force;
d1994 1
a1994 1
  for (; s != (lang_statement_union_type *) NULL; s = s->next)
d2022 1
a2022 1
		open_input_bfds (s->group_statement.children.head, true);
d2046 1
a2046 1
		s->input_statement.loaded = false;
d2050 2
a2051 1
	      load_symbols (&s->input_statement, &add);
d2055 2
a2056 2
		  *add.tail = s->next;
		  s->next = add.head;
d2078 1
a2078 1
  if (placed_commons == false)
d2092 6
a2097 6
   Remove items from the chain as we open input bfds.  */
typedef struct ldlang_undef_chain_list
{
  struct ldlang_undef_chain_list *next;
  char *name;
}                       ldlang_undef_chain_list_type;
d2099 1
a2099 1
static ldlang_undef_chain_list_type *ldlang_undef_chain_list_head;
d2113 22
d2150 1
a2150 11
      struct bfd_link_hash_entry *h;

      h = bfd_link_hash_lookup (link_info.hash, ptr->name, true, false, true);
      if (h == (struct bfd_link_hash_entry *) NULL)
	einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
      if (h->type == bfd_link_hash_new)
	{
	  h->type = bfd_link_hash_undefined;
	  h->u.undef.abfd = NULL;
	  bfd_link_add_undef (link_info.hash, h);
	}
d2154 1
a2154 1
/* Open input files and attatch to output sections.  */
d2162 1
a2162 1
  for (; s != (lang_statement_union_type *) NULL; s = s->next)
a2165 1

d2167 1
a2167 4
	  wild (&s->wild_statement, s->wild_statement.section_name,
		s->wild_statement.filename, target,
		output_section_statement);

d2228 35
d2323 11
a2333 1
    minfo ("0x%V", result.value + result.section->bfd_section->vma);
d2362 1
a2362 1
static boolean
d2385 1
a2385 1
  return true;
d2452 6
a2457 1
  fprintf (config.map_file, " FILL mask 0x%x\n", fill->fill);
d2586 1
a2586 1
  minfo ("0x%V %W", addr, s->size);
d2588 7
a2594 2
  if (s->fill != 0)
    minfo (" %u", s->fill);
d2606 2
a2611 8
  if (w->exclude_filename_list != NULL)
    {
      name_list *tmp;
      minfo ("EXCLUDE_FILE ( %s", w->exclude_filename_list->name);
      for (tmp = w->exclude_filename_list->next; tmp; tmp = tmp->next)
	minfo (", %s", tmp->name);
      minfo (")");
    }
d2620 21
a2640 8
  if (w->sections_sorted)
    minfo ("SORT(");
  if (w->section_name != NULL)
    minfo ("%s", w->section_name);
  else
    minfo ("*");
  if (w->sections_sorted)
    minfo (")");
d2671 1
a2671 1
      s = s->next;
d2777 1
a2777 1
	  s = s->next;
d2784 6
a2789 6
static bfd_vma
insert_pad (this_ptr, fill, power, output_section_statement, dot)
     lang_statement_union_type **this_ptr;
     fill_type fill;
     unsigned int power;
     asection *output_section_statement;
d2792 2
a2793 6
  /* Align this section first to the
     input sections requirement, then
     to the output section's requirement.
     If this alignment is > than any seen before,
     then record it too. Perform the alignment by
     inserting a magic 'padding' statement.  */
d2795 5
a2799 5
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
  unsigned int alignment_needed = align_power (dot, power) - dot;

  if (alignment_needed != 0)
d2801 2
a2802 13
      lang_statement_union_type *new =
	((lang_statement_union_type *)
	 stat_alloc (sizeof (lang_padding_statement_type)));

      /* Link into existing chain.  */
      new->header.next = *this_ptr;
      *this_ptr = new;
      new->header.type = lang_padding_statement_enum;
      new->padding_statement.output_section = output_section_statement;
      new->padding_statement.output_offset =
	dot - output_section_statement->vma;
      new->padding_statement.fill = fill;
      new->padding_statement.size = alignment_needed * opb;
d2804 1
a2804 3

  /* Remember the most restrictive alignment.  */
  if (power > output_section_statement->alignment_power)
d2806 14
a2819 5
      output_section_statement->alignment_power = power;
    }
  output_section_statement->_raw_size += alignment_needed * opb;

  return dot + alignment_needed;
d2825 1
a2825 1
size_input_section (this_ptr, output_section_statement, fill, dot, relax)
d2828 1
a2828 1
     fill_type fill;
a2829 1
     boolean relax ATTRIBUTE_UNUSED;
a2832 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
d2834 1
a2834 1
  if (is->ifile->just_syms_flag == false)
d2836 10
d2847 5
a2851 2
       i->alignment_power =
	output_section_statement->subsection_alignment;
d2853 7
a2859 2
      dot = insert_pad (this_ptr, fill, i->alignment_power,
			output_section_statement->bfd_section, dot);
d2863 1
a2863 1
      i->output_offset = dot - output_section_statement->bfd_section->vma;
d2870 1
a2870 2
      output_section_statement->bfd_section->_raw_size =
	(dot - output_section_statement->bfd_section->vma) * opb;
a2940 5
/* This variable indicates whether bfd_relax_section should be called
   again.  */

static boolean relax_again;

d2956 1
a2956 1
           || base == 0))
d2959 7
a2965 7
        {
          einfo (_("%X%P: address 0x%v of %B section %s is not within region %s\n"),
                 region->current,
                 os->bfd_section->owner,
                 os->bfd_section->name,
                 region->name);
        }
d2967 6
a2972 6
        {
          einfo (_("%X%P: region %s is full (%B section %s)\n"),
                 region->name,
                 os->bfd_section->owner,
                 os->bfd_section->name);
        }
d2980 3
a2982 2
bfd_vma
lang_size_sections (s, output_section_statement, prev, fill, dot, relax)
d2986 1
a2986 1
     fill_type fill;
d2988 2
a2989 1
     boolean relax;
d2995 1
a2995 1
  for (; s != (lang_statement_union_type *) NULL; s = s->next)
d3018 1
a3018 1
		    || os->children.head->next != NULL
d3056 2
d3059 1
d3092 4
a3095 5
		    if (r.valid_p == false)
		      {
			einfo (_("%F%S: non constant address expression for section %s\n"),
			       os->name);
		      }
d3110 2
a3111 3
	    (void) lang_size_sections (os->children.head, os,
				       &os->children.head,
				       os->fill, dot, relax);
d3115 1
a3115 1
	    after = ALIGN_N (os->bfd_section->vma
a3116 1
			     /* The coercion here is important, see ld.h.  */
d3121 4
d3128 1
d3130 5
a3134 1
	    os->processed = true;
d3152 4
a3155 3
		/* Make sure the new address is within the region.  */
		os_region_check (os, os->region, os->addr_tree,
				 os->bfd_section->vma);
d3162 1
a3162 1
		if (os->lma_region != NULL)
d3164 7
a3170 18
		    if (os->load_base != NULL)
		      {
			einfo (_("%X%P: use an absolute load address or a load memory region, not both\n"));
		      }
		    else
		      {
			/* Don't allocate twice.  */
			if (os->lma_region != os->region)
			  {
			    /* Set load_base, which will be handled later.  */
			    os->load_base =
			      exp_intop (os->lma_region->current);
			    os->lma_region->current +=
			      os->bfd_section->_raw_size / opb;
			    os_region_check (os, os->lma_region, NULL,
					     os->bfd_section->lma);
			  }
		      }
d3177 4
a3180 5
	  dot = lang_size_sections (constructor_list.head,
				    output_section_statement,
				    &s->wild_statement.children.head,
				    fill,
				    dot, relax);
d3241 4
a3244 4
	  dot = lang_size_sections (s->wild_statement.children.head,
				    output_section_statement,
				    &s->wild_statement.children.head,
				    fill, dot, relax);
d3267 1
a3267 1
		boolean again;
d3272 1
a3272 1
		  relax_again = true;
d3274 2
a3275 4
	    dot = size_input_section (prev,
				      output_section_statement,
				      output_section_statement->fill,
				      dot, relax);
a3297 1
		/* The assignment changed dot.  Insert a pad.  */
d3304 1
a3304 1
		else if (!relax)
d3306 8
a3313 16
		    lang_statement_union_type *new =
		      ((lang_statement_union_type *)
		       stat_alloc (sizeof (lang_padding_statement_type)));

		    /* Link into existing chain.  */
		    new->header.next = *prev;
		    *prev = new;
		    new->header.type = lang_padding_statement_enum;
		    new->padding_statement.output_section =
		      output_section_statement->bfd_section;
		    new->padding_statement.output_offset =
		      dot - output_section_statement->bfd_section->vma;
		    new->padding_statement.fill = fill;
		    new->padding_statement.size = (newdot - dot) * opb;
		    output_section_statement->bfd_section->_raw_size +=
		      new->padding_statement.size;
d3322 14
a3335 10
	  /* If we are relaxing, and this is not the first pass, some
	     padding statements may have been inserted during previous
	     passes.  We may have to move the padding statement to a new
	     location if dot has a different value at this point in this
	     pass than it did at this point in the previous pass.  */
	  s->padding_statement.output_offset =
	    dot - output_section_statement->bfd_section->vma;
	  dot += s->padding_statement.size / opb;
	  output_section_statement->bfd_section->_raw_size +=
	    s->padding_statement.size;
d3339 4
a3342 4
	  dot = lang_size_sections (s->group_statement.children.head,
				    output_section_statement,
				    &s->group_statement.children.head,
				    fill, dot, relax);
d3349 1
a3349 2
	  /* This can only get here when relaxing is turned on.  */

d3359 38
d3400 1
a3400 1
     fill_type fill;
d3406 1
a3406 1
  for (; s != (lang_statement_union_type *) NULL; s = s->next)
d3466 1
a3466 1
	    if (value.valid_p == false)
d3469 2
a3470 2
          {
            unsigned int size;
d3503 1
a3503 1
	    if (value.valid_p == false)
d3582 1
a3582 1
      h = bfd_link_hash_lookup (link_info.hash, buf, false, false, true);
d3591 1
a3591 1
      h = bfd_link_hash_lookup (link_info.hash, buf, false, false, true);
d3594 1
a3594 1
          unsigned opb;
d3596 1
a3596 1
          opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
d3614 1
a3614 1
  boolean warn;
d3617 1
a3617 1
    warn = false;
d3619 1
a3619 1
    warn = true;
d3621 1
a3621 1
  if (entry_symbol == (char *) NULL)
d3625 2
a3626 2
      entry_symbol = "start";
      warn = false;
d3629 2
a3630 1
  h = bfd_link_hash_lookup (link_info.hash, entry_symbol, false, false, true);
d3643 1
a3643 1
	einfo (_("%P%F:%s: can't set start address\n"), entry_symbol);
d3652 1
a3652 1
      val = bfd_scan_vma (entry_symbol, &send, 0);
d3664 1
a3664 1
	  ts = bfd_get_section_by_name (output_bfd, ".text");
d3669 2
a3670 1
		       entry_symbol, bfd_get_section_vma (output_bfd, ts));
d3680 1
a3680 1
		       entry_symbol);
d3716 20
a3735 2
      compatible = bfd_arch_get_compatible (input_bfd,
					    output_bfd);
d3746 1
a3746 1
	     private data of the output bfd. */
d3776 2
d3796 1
a3796 1
static boolean
d3808 1
a3808 1
    return true;
d3815 1
a3815 1
    return true;
d3820 2
a3821 2
  section->_cooked_size = ALIGN_N ((section->_cooked_size + opb - 1) / opb,
				   (bfd_size_type) (1 << power_of_two)) * opb;
d3842 1
a3842 1
      static boolean header_printed;
d3851 1
a3851 1
	  header_printed = true;
d3887 1
a3887 1
  return true;
d3907 1
a3907 1
	      /* This section of the file is not attatched, root
d3912 1
a3912 5
		  /* We are only retrieving symbol values from this
                     file.  We want the symbols to act as though the
                     values in the file are absolute.  */
		  s->output_section = bfd_abs_section_ptr;
		  s->output_offset = s->vma;
d3934 2
a3935 2
		      wild_doit (&default_common_section->children, s,
				 default_common_section, file);
d3942 1
a3942 2
		  lang_output_section_statement_type *os =
		  lang_output_section_statement_lookup (s->name);
d3944 2
a3945 1
		  wild_doit (&os->children, s, os, file);
d4087 1
a4087 1
  if (had_output_filename == false || !from_script)
d4090 1
a4090 1
      had_output_filename = true;
d4173 2
a4174 2
static void
reset_memory_regions ()
d4177 1
d4186 3
d4191 2
a4192 2
/* Expand a wild statement for a particular FILE, marking its sections KEEP
   as needed.  SECTION may be NULL, in which case it is a wild card.  */
d4195 1
a4195 1
gc_section_callback (ptr, section, file, data)
d4197 1
a4201 2
  /* If the wild pattern was marked KEEP, the member sections
     should be as well.  */
d4206 1
a4206 2
/* Handle a wild statement, marking it against GC.  SECTION or FILE or both
   may be NULL, indicating that it is a wildcard.  */
d4209 1
a4209 1
lang_gc_wild (s, section, file)
a4210 2
     const char *section;
     const char *file;
d4212 1
a4212 1
  walk_wild (s, section, file, gc_section_callback, NULL);
d4221 1
a4221 1
  for (; s != (lang_statement_union_type *) NULL; s = s->next)
d4226 1
a4226 3
	  lang_gc_wild (&s->wild_statement,
			s->wild_statement.section_name,
			s->wild_statement.filename);
d4247 1
a4247 1
  ldlang_undef_chain_list_type *ulist, fake_list_start;
d4253 2
a4254 2
  /* Keep all sections containing symbols undefined on the command-line.
     Handle the entry symbol at the same time.  */
d4256 1
a4256 10
  if (entry_symbol != NULL)
    {
      fake_list_start.next = ldlang_undef_chain_list_head;
      fake_list_start.name = (char *) entry_symbol;
      ulist = &fake_list_start;
    }
  else
    ulist = ldlang_undef_chain_list_head;

  for (; ulist; ulist = ulist->next)
d4259 1
a4259 1
				false, false, false);
d4291 5
a4295 1
  open_input_bfds (statement_list.head, false);
d4320 6
d4337 16
d4355 3
d4362 6
d4371 2
a4372 5
      /* First time round is a trial run to get the 'worst case'
	 addresses of the objects if there was no relaxing.  */
      lang_size_sections (statement_list.head,
			  abs_output_section,
			  &(statement_list.head), 0, (bfd_vma) 0, false);
a4373 1
      /* Keep relaxing until bfd_relax_section gives up.  */
d4376 1
a4376 1
	  reset_memory_regions ();
d4378 1
a4378 1
	  relax_again = false;
d4388 1
a4388 1
			       (fill_type) 0, (bfd_vma) 0);
d4391 1
a4391 1
	     globals are, so can make better guess.  */
d4394 10
a4403 1
			      &(statement_list.head), 0, (bfd_vma) 0, true);
d4406 6
a4411 4
    }
  else
    {
      /* Size up the sections.  */
d4414 2
a4415 1
			  &(statement_list.head), 0, (bfd_vma) 0, false);
d4430 1
a4430 1
		       (fill_type) 0, (bfd_vma) 0);
d4446 4
a4449 8
lang_add_wild (section_name, sections_sorted, filename, filenames_sorted,
	       keep_sections, exclude_filename_list)
     const char *const section_name;
     boolean sections_sorted;
     const char *const filename;
     boolean filenames_sorted;
     boolean keep_sections;
     struct name_list *exclude_filename_list;
d4451 14
a4464 2
  lang_wild_statement_type *new = new_stat (lang_wild_statement,
					    stat_ptr);
d4466 1
a4466 1
  if (section_name != (char *) NULL && strcmp (section_name, "COMMON") == 0)
d4468 4
a4471 1
      placed_commons = true;
d4473 5
a4477 1
  if (filename != NULL && ! wildcardp (filename))
d4479 2
a4480 1
      lang_has_input_file = true;
d4482 1
a4482 4
  new->section_name = section_name;
  new->sections_sorted = sections_sorted;
  new->filename = filename;
  new->filenames_sorted = filenames_sorted;
a4483 1
  new->exclude_filename_list = exclude_filename_list;
d4507 1
a4507 1
     boolean cmdline;
d4509 1
a4509 1
  if (entry_symbol == NULL
d4513 1
a4513 1
      entry_symbol = name;
d4538 1
a4538 1
	  map_option_f = true;
d4546 2
a4547 2
lang_add_fill (exp)
     int exp;
d4552 1
a4552 1
  new->fill = exp;
d4625 1
a4625 1
  first_file->real = true;
d4632 1
a4632 1
     boolean maybe;
d4637 30
d4669 1
a4669 1
     bfd_vma fill;
d4674 4
a4678 9
  current_section->region = lang_memory_region_lookup (memspec);
  if (strcmp (lma_memspec, "*default*") != 0)
    {
      current_section->lma_region = lang_memory_region_lookup (lma_memspec);
      /* If no runtime region has been given, but the load region has
         been, use the load region.  */
      if (strcmp (memspec, "*default*") == 0)
        current_section->region = lang_memory_region_lookup (lma_memspec);
    }
d4695 1
a4695 1
  h = bfd_link_hash_lookup (link_info.hash, name, true, true, true);
d4728 1
a4728 1
  h = bfd_link_hash_lookup (link_info.hash, name, true, true, true);
d4814 2
a4815 2
     boolean filehdr;
     boolean phdrs;
d4894 1
a4894 1
		  pl->used = true;
d4952 1
a4952 1
  link_info.notice_all = true;
a4959 6
/* The overlay load address.  */
static etree_type *overlay_lma;

/* Whether nocrossrefs is set for this overlay.  */
static int overlay_nocrossrefs;

d4975 1
a4975 1
lang_enter_overlay (vma_expr, lma_expr, nocrossrefs)
a4976 2
     etree_type *lma_expr;
     int nocrossrefs;
d4979 1
a4979 4
  ASSERT (overlay_vma == NULL
	  && overlay_lma == NULL
	  && overlay_list == NULL
	  && overlay_max == NULL);
a4981 2
  overlay_lma = lma_expr;
  overlay_nocrossrefs = nocrossrefs;
d4985 2
a4986 1
   lang_enter_output_section_statement with the correct VMA and LMA.  */
d4996 1
a4996 1
				       0, 0, 0, overlay_lma);
d4998 1
a4998 1
  /* If this is the first section, then base the VMA and LMA of future
d5002 1
a5002 4
    {
      overlay_vma = exp_nameop (ADDR, name);
      overlay_lma = exp_nameop (LOADADDR, name);
    }
a5011 3
  /* Adjust the LMA for the next section.  */
  overlay_lma = exp_binop ('+', overlay_lma, size);

d5024 1
a5024 1
     bfd_vma fill;
d5034 4
a5037 2
  lang_leave_output_section_statement (fill, "*default*",
                                       phdrs, "*default*");
d5044 1
a5044 1
    if (isalnum ((unsigned char) *s1) || *s1 == '_')
d5067 4
a5070 2
lang_leave_overlay (fill, memspec, phdrs, lma_memspec)
     bfd_vma fill;
d5080 3
a5082 4
  if (memspec == NULL)
    region = NULL;
  else
    region = lang_memory_region_lookup (memspec);
d5084 1
a5084 4
  if (lma_memspec == NULL)
    lma_region = NULL;
  else
    lma_region = lang_memory_region_lookup (lma_memspec);
d5086 5
a5090 1
  nocrossref = NULL;
d5097 1
a5097 1
      if (fill != 0 && l->os->fill == 0)
d5099 15
a5113 11
      if (region != NULL && l->os->region == NULL)
	l->os->region = region;
      /* We only set lma_region for the first overlay section, as
	 subsequent overlay sections will have load_base set relative
	 to the first section.  Also, don't set lma_region if
	 load_base is specified.  FIXME:  There should really be a test
	 that `AT ( LDADDR )' doesn't conflict with `AT >LMA_REGION'
	 rather than letting LDADDR simply override LMA_REGION.  */
      if (lma_region != NULL && l->os->lma_region == NULL
	  && l->next == NULL && l->os->load_base == NULL)
	l->os->lma_region = lma_region;
d5117 1
a5117 1
      if (overlay_nocrossrefs)
a5134 4
  /* Update . for the end of the overlay.  */
  lang_add_assignment (exp_assop ('=', ".",
				  exp_binop ('+', overlay_vma, overlay_max)));

a5135 2
  overlay_lma = NULL;
  overlay_nocrossrefs = 0;
d5171 1
a5171 1
	 Should we early out false in this case?  */
d5198 1
a5198 1
	 Should we early out false in this case?  */
d5213 1
a5213 1
lang_new_vers_regex (orig, new, lang)
d5223 2
d5239 1
a5239 1
  return ret;
d5280 11
d5327 7
a5333 2
  ++version_index;
  version->vernum = version_index;
d5379 1
a5379 1
        continue;
d5384 1
a5384 1
	einfo (_("%X%P: unable to read .exports section contents"), sec);
d5389 1
a5389 1
	  greg = lang_new_vers_regex (greg, p, NULL);
d5400 1
a5400 1
  lreg = lang_new_vers_regex (NULL, "*", NULL);
@


1.6
log
@Automatic cvs merge. Dread what I will have to fix after this excuse
of a program is done...
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
a33 1
#include "ldemul.h"
d38 1
d45 2
a46 4
static lang_statement_union_type *new_statement PARAMS ((enum statement_enum,
							 size_t,
							 lang_statement_list_type*));

d53 1
a53 1
static CONST char *startup_file;
d60 2
a61 2
static CONST char *current_target;
static CONST char *output_target;
d66 2
a67 2
  PARAMS ((void (*func) (lang_statement_union_type *),
	   lang_statement_union_type *s));
d69 4
a72 3
  PARAMS ((const char *name, lang_input_file_enum_type file_type,
	   const char *target, boolean add_to_list));
static void init_os PARAMS ((lang_output_section_statement_type *s));
d76 1
a76 2
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
	   const char *string));
d83 12
a94 11
static lang_input_statement_type *lookup_name PARAMS ((const char *name));
static void load_symbols PARAMS ((lang_input_statement_type *entry,
				  lang_statement_list_type *));
static void wild PARAMS ((lang_wild_statement_type *s,
			  const char *section, const char *file,
			  const char *target,
			  lang_output_section_statement_type *output));
static bfd *open_output PARAMS ((const char *name));
static void ldlang_open_output PARAMS ((lang_statement_union_type *statement));
static void open_input_bfds
  PARAMS ((lang_statement_union_type *statement, boolean));
d98 2
a99 3
  PARAMS ((lang_statement_union_type *s,
	   const char *target,
	   lang_output_section_statement_type *output_section_statement));
d101 1
a101 1
  PARAMS ((lang_output_section_statement_type *output_section_statement));
d103 3
a105 3
  PARAMS ((lang_assignment_statement_type *assignment,
	   lang_output_section_statement_type *output_section));
static void print_input_statement PARAMS ((lang_input_statement_type *statm));
d107 3
a109 3
static void print_input_section PARAMS ((lang_input_section_type *in));
static void print_fill_statement PARAMS ((lang_fill_statement_type *fill));
static void print_data_statement PARAMS ((lang_data_statement_type *data));
d111 2
a112 2
static void print_reloc_statement PARAMS ((lang_reloc_statement_type *reloc));
static void print_padding_statement PARAMS ((lang_padding_statement_type *s));
d114 1
a114 2
  PARAMS ((lang_wild_statement_type *w,
	   lang_output_section_statement_type *os));
d117 4
a120 4
static void print_statement PARAMS ((lang_statement_union_type *s,
				     lang_output_section_statement_type *os));
static void print_statement_list PARAMS ((lang_statement_union_type *s,
					  lang_output_section_statement_type *os));
d122 3
a124 4
static bfd_vma insert_pad PARAMS ((lang_statement_union_type **this_ptr,
				   fill_type fill, unsigned int power,
				   asection *output_section_statement,
				   bfd_vma dot));
d126 2
a127 3
  PARAMS ((lang_statement_union_type **this_ptr,
	   lang_output_section_statement_type *output_section_statement,
	   fill_type fill, bfd_vma dot, boolean relax));
d137 3
d145 6
d153 3
d159 4
a162 1
				    void *));
d165 1
a165 1
	   lang_input_statement_type *, callback_t, void *));
d168 1
a168 1
	   lang_input_statement_type *, callback_t, void *));
d170 1
a170 1
static int    get_target PARAMS ((const bfd_target *, void *));
d174 1
a174 1
static int    closest_target_match PARAMS ((const bfd_target *, void *));
d176 1
a176 1
					
d189 1
d193 1
a193 2

#if defined(__STDC__) || defined(ALMOST_STDC)
d199 4
a202 1
#define new_stat(x,y) (cat(x,_type)*) new_statement(cat(x,_enum), sizeof(cat(x,_type)),y)
d204 2
a205 1
#define outside_section_address(q) ( (q)->output_offset + (q)->output_section->vma)
d207 2
a208 1
#define outside_symbol_address(q) ((q)->value +   outside_section_address(q->section))
d219 18
a236 3
/*----------------------------------------------------------------------
  Generic traversal routines for finding matching sections.
*/
d244 1
a244 1
     void *data;
d246 1
a246 1
  /* Don't process sections from files which were excluded. */
d250 4
a253 2
      for (list_tmp = ptr->exclude_filename_list; list_tmp; list_tmp = list_tmp->next)
        {
d257 1
a257 1
	    match = fnmatch (list_tmp->name, file->filename, 0) == 0 ? true : false;
d259 1
a259 1
	    match = strcmp (list_tmp->name, file->filename) == 0 ? true : false;
d269 1
a269 1
      boolean wildcard;
d271 1
a271 3
      if (section == NULL)
	wildcard = false;
      else
d277 1
d281 2
d284 1
a284 9
	    {
	      const char *name;

	      name = bfd_get_section_name (file->the_bfd, s);
	      if (wildcard)
		match = fnmatch (section, name, 0) == 0 ? true : false;
	      else
		match = strcmp (section, name) == 0 ? true : false;
	    }
d286 3
a288 1
	  if (match)
d302 1
a302 1
     void *data;
d339 1
a339 1
     void *data;
d365 4
a368 6
}  
     
/*----------------------------------------------------------------------
  lang_for_each_statement walks the parse tree and calls the provided
  function for each node
*/
d421 1
a421 2
  lang_for_each_statement_worker (func,
				  statement_list.head);
d425 1
d434 1
a434 3
/*----------------------------------------------------------------------

  build a new statement node for the parse tree
d436 1
a436 4
 */

static
lang_statement_union_type *
d440 1
a440 1
     lang_statement_list_type * list;
d451 8
a458 9
/*
  Build a new input file node for the language. There are several ways
  in which we treat an input file, eg, we only look at symbols, or
  prefix it with a -l etc.

  We can be supplied with requests for input files more than once;
  they may, for example be split over serveral lines like foo.o(.text)
  foo.o(.data) etc, so when asked for a file we check that we havn't
  got it already so we don't duplicate the bfd.
a459 1
 */
d462 1
a462 1
     CONST char *name;
d464 1
a464 1
     CONST char *target;
d549 1
a549 1
     CONST char *name;
d551 1
a551 1
     CONST char *target;
d557 2
a558 1
/* Build enough state so that the parser can build its tree */
d574 2
a575 1
  abs_output_section = lang_output_section_statement_lookup (BFD_ABS_SECTION_NAME);
d582 8
a589 9
 A region is an area of memory declared with the
 MEMORY {  name:org=exp, len=exp ... }
 syntax.

 We maintain a list of all the regions here

 If no regions are specified in the script, then the default is used
 which is created when looked up to be the entire data space
*/
d596 1
a596 1
     CONST char *CONST name;
d630 1
a630 1
    new->name = buystring (name);
d638 1
a638 1
    new->length = ~(bfd_size_type)0;
d646 1
a646 2

lang_memory_region_type *
d673 1
a673 1
     CONST char *CONST name;
d693 1
a693 1
     CONST char *CONST name;
d716 1
a716 1
      lookup->memspec = (CONST char *) NULL;
d831 2
a832 2
  /* We initialize an output sections output offset to minus its own */
  /* vma to allow us to output a section through itself */
d905 1
a905 1
struct already_linked_hash_entry 
d911 1
a911 1
struct already_linked 
a920 1
/*ARGSUSED*/
d947 1
a947 1
  /* FIXME: When doing a relocateable link, we may have trouble
d954 1
a954 1
     doing a relocateable link (technically, they should be discarded
d960 1
a960 1
     Also, not merging link once sections in a relocateable link
d966 1
a966 1
  already_linked_list = 
d970 1
a970 1
  for (l = already_linked_list->entry;  l != NULL; l = l->next)
d1016 1
a1016 2
	  if (sec->comdat != NULL)
	    sec->comdat->sec = l->sec;
d1025 1
a1025 1
  l = ((struct already_linked *) 
d1042 1
a1042 1
  struct already_linked_hash_entry *ret = 
d1143 4
a1146 6
	{
	  init_os (output);
	  first = true;
	}
      else
	first = false;
d1148 1
a1148 1
      /* Add a section reference to the list */
d1214 7
d1333 1
a1333 1
     void *output;
d1336 1
a1336 1
  
d1341 1
a1341 1
  
d1343 1
a1343 1
  
d1348 1
a1348 1
  
d1350 2
a1351 2
    wild_doit (&ptr->children, section, 
	       (lang_output_section_statement_type *) output, 
d1357 1
a1357 1
      
d1359 2
a1360 2
      wild_doit (&list, section, 
		 (lang_output_section_statement_type *) output, 
d1362 1
a1362 1
      
d1368 1
a1368 1
	  
d1373 1
a1373 1
	  
d1440 5
a1461 5
      /* See if the emulation has some special knowledge.  */

      if (ldemul_unrecognized_file (entry))
	return;

a1462 1

a1526 2
     

d1540 1
a1540 1
  walk_wild (s, section, file, output_section_callback, (void *) output);
d1553 1
d1556 2
a1557 2
     const bfd_target * target;
     void * data;
d1559 2
a1560 2
  const char * sought = (const char *) data;
  
d1565 1
d1568 2
a1569 2
     char * dest;
     char * src;
d1572 2
a1573 2
  
  while ((c = * src ++) != 0)
d1578 1
a1578 1
      * dest ++ = c;
d1581 1
a1581 1
  * dest = 0;
d1586 1
d1589 2
a1590 2
     char * haystack;
     char * needle;
d1593 1
a1593 1
  
d1596 1
a1596 1
      char * src;
d1598 4
a1601 4
      for (src = haystack + strlen (needle); * src;)
	* haystack ++ = * src ++;
      
      * haystack = 0;
d1607 1
d1610 2
a1611 2
     char * first;
     char * second;
d1613 4
a1616 4
  char * copy1;
  char * copy2;
  int    result;
  
d1633 2
a1634 2
  for (result = 0; copy1 [result] == copy2 [result]; result ++)
    if (copy1 [result] == 0)
d1639 1
a1639 1
  
d1647 1
a1647 1
static const bfd_target * winner;
d1652 1
d1655 2
a1656 2
     const bfd_target * target;
     void * data;
d1658 4
a1661 3
  const bfd_target * original = (const bfd_target *) data;
  
  if (command_line.endian == ENDIAN_BIG && target->byteorder != BFD_ENDIAN_BIG)
d1663 3
a1665 2
  
  if (command_line.endian == ENDIAN_LITTLE && target->byteorder != BFD_ENDIAN_LITTLE)
d1680 3
a1682 2
     Compare their names and choose the better one. */
  if (name_compare (target->name, original->name) > name_compare (winner->name, original->name))
d1690 1
d1694 1
a1694 1
  char * target = NULL;
d1702 1
a1702 1
	  
d1707 1
a1707 1
	  
d1713 1
a1713 1
  
d1721 1
a1721 1
     const char * name;
d1723 1
a1723 1
  bfd * output;
d1725 1
a1725 1
  /* Has the user told us which output format to use ?  */
d1728 2
a1729 1
      /* No - has the current target been set to something other than the default ?  */
d1733 1
a1733 1
      /* No - can we determine the format of the first input file ? */
d1743 3
a1745 2
  
  /* Has the user requested a particular endianness on the command line ?  */
d1748 1
a1748 1
      const bfd_target * target;
d1752 1
a1752 1
      target = bfd_search_for_target (get_target, (void *) output_target);
d1754 5
a1758 15
      if (command_line.endian == ENDIAN_BIG)
	desired_endian = BFD_ENDIAN_BIG;
      else
	desired_endian = BFD_ENDIAN_LITTLE;
      
      /* See if the target has the wrong endianness.  This should not happen
	 if the linker script has provided big and little endian alternatives,
	 but some scrips don't do this.  */
      if (target->byteorder != desired_endian)
	{
	  /* If it does, then see if the target provides
	     an alternative with the correct endianness.  */
	  if (target->alternative_target != NULL
	      && (target->alternative_target->byteorder == desired_endian))
	    output_target = target->alternative_target->name;
d1760 7
d1768 5
a1772 7
	      /* Try to find a target as similar as possible to the default
		 target, but which has the desired endian characteristic.  */
	      (void) bfd_search_for_target (closest_target_match, (void *) target);
	      
	      /* Oh dear - we could not find any targets that satisfy our requirements.  */
	      if (winner == NULL)
		einfo (_("%P: warning: could not find any targets that match endianness requirement\n"));
d1774 14
a1787 1
		output_target = winner->name;
d1791 1
a1791 1
      
d1804 3
a1806 1
  /*  output->flags |= D_PAGED;*/
d1825 1
a1825 1
     lang_statement_union_type * statement;
d1873 1
a1873 1
	  /* Maybe we should load the file's symbols */
d1884 2
a1885 2
               until no new symbols are added to the list of undefined
               symbols.  */
d1907 2
a1908 1
                 force it to be researched.  */
d1910 1
d1933 2
a1934 1
/* If there are [COMMONS] statements, put a wild one into the bss section */
d1943 1
a1943 3
  default_common_section =
    lang_output_section_statement_lookup (".bss");

a1955 1

d1958 2
a1959 4
/*
 Add the supplied name to the symbol table as an undefined reference.
 Remove items from the chain as we open input bfds
 */
d1970 1
a1970 1
     CONST char *CONST name;
d1979 1
a1979 1
  new->name = buystring (name);
d1984 2
a1985 2
   script file.
*/
d2009 2
a2010 1
/* Open input files and attatch to output sections */
d2013 3
a2015 3
     lang_statement_union_type * s;
     CONST char *target;
     lang_output_section_statement_type * output_section_statement;
a2021 1

d2065 1
a2065 1
             are initialized.  */
d2072 1
a2072 1
	  /* Mark the specified section with the supplied address */
d2089 1
a2089 1
     lang_output_section_statement_type * output_section_statement;
d2135 2
a2136 2
     lang_assignment_statement_type * assignment;
     lang_output_section_statement_type * output_section;
d2165 1
a2165 1
     lang_input_statement_type * statm;
d2176 1
a2176 1
static boolean 
d2206 1
a2206 1
     lang_input_section_type * in;
d2210 1
a2210 1
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
d2264 1
a2264 1
     lang_fill_statement_type * fill;
d2271 1
a2271 1
     lang_data_statement_type * data;
d2277 1
a2277 1
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
d2348 2
a2349 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine); 
d2372 1
a2372 1
}  
d2380 2
a2381 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine); 
d2407 2
a2408 2
     lang_wild_statement_type * w;
     lang_output_section_statement_type * os;
d2418 2
a2419 2
      for (tmp=w->exclude_filename_list->next; tmp; tmp = tmp->next)
        minfo (", %s", tmp->name);
d2421 2
a2422 2
     }
   if (w->filename != NULL)
d2560 1
a2560 1
     lang_statement_union_type * s;
d2583 1
a2583 1
     lang_statement_union_type ** this_ptr;
d2586 1
a2586 1
     asection * output_section_statement;
d2594 1
a2594 2
     inserting a magic 'padding' statement.
     */
d2596 2
a2597 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine); 
d2606 1
a2606 1
      /* Link into existing chain */
d2617 1
a2617 2

  /* Remember the most restrictive alignment */
d2627 2
a2628 1
/* Work out how much this section will move the dot point */
d2631 2
a2632 2
     lang_statement_union_type ** this_ptr;
     lang_output_section_statement_type * output_section_statement;
d2639 2
a2640 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine); 
d2651 1
a2651 1
      /* Remember where in the output section this input section goes */
d2655 1
a2655 2
      /* Mark how big the output section must be to contain this now
	 */
d2660 2
a2661 2
      output_section_statement->bfd_section->_raw_size = 
        (dot - output_section_statement->bfd_section->vma) * opb;
d2672 2
a2673 1
  (((bfd_get_section_flags (bfd, s) & (SEC_ALLOC | SEC_LOAD)) != (SEC_ALLOC | SEC_LOAD)) \
d2679 1
d2683 1
a2683 1
  asection * s;
d2689 2
a2690 2
      asection * os;
      
d2694 1
a2694 1
      
d2704 1
a2704 1
	  
d2716 1
a2716 1
	  
d2720 1
a2720 1
	  
d2724 1
a2724 1
	  
d2740 1
a2740 1
   calculation wraps around.  */ 
d2744 4
a2747 4
  lang_output_section_statement_type *os;
  struct memory_region_struct *region;
  etree_type *tree;
  bfd_vma base;
d2778 3
a2780 3
     lang_statement_union_type * s;
     lang_output_section_statement_type * output_section_statement;
     lang_statement_union_type ** prev;
d2785 1
a2785 1
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
d2796 1
a2796 1
	    lang_output_section_statement_type *os = &s->output_section_statement;
d2798 1
d2809 1
a2809 1
		asection * input;
d2853 2
a2854 1
			&& (strcmp (lang_memory_region_list->name, "*default*") != 0
d2857 2
a2858 1
			     bfd_get_section_name (output_bfd, os->bfd_section));
d2861 1
a2861 1
 
d2867 2
a2868 1
			dot = align_power (dot, os->bfd_section->alignment_power);
d2890 1
a2890 1
		
d2898 1
a2898 1
		
d2902 2
a2903 1
	    (void) lang_size_sections (os->children.head, os, &os->children.head,
d2905 3
a2907 3
	    
            /* put the section within the requested block size, or align at
               the block boundary */
d2916 2
a2917 2
	      os->bfd_section->_raw_size = 
                (after - os->bfd_section->vma) * opb;
d2925 1
a2925 1
	       
d2936 1
a2936 1
		
d2938 7
a2944 2
                os_region_check (os, os->region, os->addr_tree, 
                                 os->bfd_section->vma);
d2946 21
a2966 25
                /* if there's no load address specified, use the run region as
                   the load region */
                if (os->lma_region == NULL && os->load_base == NULL)
                    os->lma_region = os->region;

                if (os->lma_region != NULL)
                  {
                    if (os->load_base != NULL)
                      {
                        einfo (_("%X%P: use an absolute load address or a load memory region, not both\n"));
                      }
                    else
                      {
                        /* don't allocate twice */
                        if (os->lma_region != os->region)
                          {
                            /* set load_base, which will be handled later */
                            os->load_base = exp_intop (os->lma_region->current);
                            os->lma_region->current += 
                              os->bfd_section->_raw_size / opb;
                            os_region_check (os, os->lma_region, NULL,
                                             os->bfd_section->lma);
                          }
                      }
                  }
d2983 2
a2984 1
	    s->data_statement.output_vma = dot - output_section_statement->bfd_section->vma;
d2990 2
a2991 2
              default:
                abort();
d3006 2
a3007 2
            if (size < opb)
              size = opb;
d3013 5
a3017 3
	    if (!(output_section_statement->flags & SEC_NEVER_LOAD)) {
	      output_section_statement->bfd_section->flags |= SEC_ALLOC | SEC_LOAD;
	    }
d3034 1
a3034 1
     
a3039 1

d3079 2
a3080 1
	  s->fill_statement.output_section = output_section_statement->bfd_section;
d3164 2
a3165 2
     lang_statement_union_type * s;
     lang_output_section_statement_type * output_section_statement;
d3169 2
a3170 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine); 
d3185 1
a3185 2
	    lang_output_section_statement_type *os =
	      &(s->output_section_statement);
d3187 1
d3196 1
a3196 1
	    if (os->load_base) 
d3199 2
a3200 2
		   it won't have a bfd_section. */
		if (os->bfd_section) 
d3202 3
a3204 2
		    os->bfd_section->lma 
		      = exp_get_abs_int(os->load_base, 0,"load base", lang_final_phase_enum);
d3237 22
a3258 22
            switch (s->data_statement.type)
              {
              default:
                abort();
              case QUAD:
              case SQUAD:
                size = QUAD_SIZE;
                break;
              case LONG:
                size = LONG_SIZE;
                break;
              case SHORT:
                size = SHORT_SIZE;
                break;
              case BYTE:
                size = BYTE_SIZE;
                break;
              }
            if (size < opb)
              size = opb;
            dot += size / opb;
          }
d3360 4
a3363 2
          unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
							ldfile_output_machine);
d3413 1
a3413 1
      CONST char *send;
d3473 1
a3473 1
  CONST bfd_arch_info_type *compatible;
d3489 1
a3489 1
      else
d3491 3
d3548 2
a3549 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine); 
d3582 1
a3582 1
  section->flags &= ~ SEC_IS_COMMON;
d3634 3
a3636 6
/*
run through the input files and ensure that every input
section has somewhere to go. If one is found without
a destination then create an input request and place it
into the statement tree.
*/
d3652 1
a3652 1
	         around for a sensible place for it to go */
a3699 1

d3703 1
a3703 1
     CONST char *flags;
d3777 1
a3777 1
     void (*func) PARAMS ((bfd * ab, asection * as));
d3781 1
a3781 1
      asection * s;
d3796 1
a3796 1
     lang_input_statement_type * entry;
d3831 1
a3831 1
     CONST char *name;
a3841 1

d3854 1
a3854 1
  for (l = 0; l < 32; l++) 
d3869 1
a3869 1
     etree_type * address_exp;
d3882 6
d3889 4
a3892 12

  /* Add this statement to tree */
  /*  add_statement(lang_output_section_statement_enum,
      output_section_statement);*/
  /* Make next things chain into subchain of this */

  if (os->addr_tree ==
      (etree_type *) NULL)
  {
    os->addr_tree =
     address_exp;
  }
d3901 4
a3904 7
  os->subsection_alignment = topower(
   exp_get_value_int(subalign, -1,
		     "subsection alignment",
		     0));
  os->section_alignment = topower(
   exp_get_value_int(align, -1,
		     "section alignment", 0));
a3909 1

d3919 2
a3920 1
/* Reset the current counters in the regions */
d3943 1
a3943 1
     void *data ATTRIBUTE_UNUSED;
d3967 1
a3967 1
     lang_statement_union_type * s;
d4005 1
a4005 1
  
d4017 1
a4017 1
      h = bfd_link_hash_lookup (link_info.hash, ulist->name, 
d4021 2
a4022 2
          && (h->type == bfd_link_hash_defined
              || h->type == bfd_link_hash_defweak)
d4038 2
a4039 1
  lang_for_each_statement (ldlang_open_output);	/* Open the output file */
d4043 1
a4043 1
  /* Add to the hash table all undefineds on the command line */
d4048 1
a4048 1
  /* Create a bfd for each input file */
d4075 1
a4075 1
  /* Size up the common data */
d4079 1
a4079 2
     to the correct output sections
     */
d4083 1
a4083 2

  /* Find any sections not attached explicitly and handle them */
d4092 1
a4092 1
  /* Now run around and relax if we can */
d4110 1
a4110 1
	     pe-dll.c also.  DJ */
d4141 2
a4142 2
  /* Do all the assignments, now that we know the final restingplaces
     of all the symbols */
d4152 2
a4153 2
  
  /* Final stuffs */
d4193 2
a4194 2
     CONST char *name;
     etree_type * address;
d4196 1
a4196 1
  lang_address_statement_type *ad = new_stat (lang_address_statement, stat_ptr);
d4198 1
d4210 1
a4210 1
     CONST char *name;
d4224 1
a4224 1
     CONST char *name;
d4235 1
a4235 1
     CONST char *name;
d4241 1
a4241 1
	  case 'F':
d4289 1
a4289 1
  
d4303 1
a4303 1
     etree_type * exp;
d4321 1
a4321 1
     CONST char *name;
d4353 2
a4354 2
      /* if no runtime region has been given, but the load region has been,
         use the load region */
d4362 4
a4365 3
/*
 Create an absolute symbol with the given name with the value of the
 address of first byte of the section named.
a4366 2
 If the symbol already exists, then do nothing.
*/
d4395 4
a4398 3
/*
 Create an absolute symbol with the given name with the value of the
 address of the first byte after the end of the section named.
a4399 2
 If the symbol already exists, then do nothing.
*/
d4432 3
a4434 3
     lang_statement_list_type * list;
     lang_statement_union_type * element;
     lang_statement_union_type ** field;
d4591 1
a4591 3
			     l->flags == NULL ? false : true,
			     flags,
			     l->at == NULL ? false : true,
d4650 1
a4650 2
struct overlay_list
{
d4731 1
a4731 1
  lang_leave_output_section_statement (fill, "*default*", 
d4794 9
a4802 2
      if (lma_region != NULL && l->os->lma_region == NULL)
        l->os->lma_region = lma_region;
d4862 1
a4862 1
  alt_sym = cplus_demangle(sym, /* DMGL_NO_TPARAMS */ 0);
d4889 1
a4889 1
  alt_sym = cplus_demangle(sym, DMGL_JAVA);
d5064 1
a5064 1
      while (p < contents+len)
d5080 16
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@a60 1
static lang_statement_list_type lang_output_section_statement;
d168 1
d3816 1
a3816 1
void
d3864 1
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d9 1
a9 1
the Free Software Foundation; either version 1, or (at your option)
d25 1
d39 1
d76 5
d82 3
a84 4
static void wild_section PARAMS ((lang_wild_statement_type *ptr,
				  const char *section,
				  lang_input_statement_type *file,
				  lang_output_section_statement_type *output));
a87 3
static void wild_file PARAMS ((lang_wild_statement_type *, const char *,
			       lang_input_statement_type *,
			       lang_output_section_statement_type *));
d108 1
d134 1
d143 24
a166 1

d170 1
a170 1
lang_statement_list_type file_chain = { 0 };
d204 136
d578 1
a578 2

  lang_memory_region_type *p = lang_memory_region_list;
d616 2
d627 25
d685 1
d711 20
d736 3
a738 3
  minfo ("\nMemory Configuration\n\n");
  fprintf (config.map_file, "%-16s %-18s %-18s\n",
	   "Name", "Origin", "Length");
d758 20
a777 1
      minfo ("0x%V\n", m->length);
d780 1
a780 1
  fprintf (config.map_file, "\nLinker script and memory map\n\n");
d797 1
a797 1
    einfo ("%P%F: Illegal use of `%s' section", DISCARD_SECTION_NAME);
d807 1
a807 1
      einfo ("%P%F: output format %s cannot represent section called %s\n",
d871 20
d892 9
a900 6
/* Sections marked with the SEC_LINK_ONCE flag should only be linked
   once into the output.  This routine checks each sections, and
   arranges to discard it if a section of the same name has already
   been linked.  This code assumes that all relevant sections have the
   SEC_LINK_ONCE flag set; that is, it does not depend solely upon the
   section name.  This is called via bfd_map_over_sections.  */
a909 6
  struct sec_link_once
    {
      struct sec_link_once *next;
      asection *sec;
    };
  static struct sec_link_once *sec_link_once_list;
d912 2
a913 1
  struct sec_link_once *l;
d920 1
d929 17
d948 9
a956 3
  for (l = sec_link_once_list; l != NULL; l = l->next)
    {
      if (strcmp (name, bfd_get_section_name (l->sec->owner, l->sec)) == 0)
d969 6
a974 2
	      einfo ("%P: %B: warning: ignoring duplicate section `%s'\n",
		     abfd, name);
d987 1
a987 1
		einfo ("%P: %B: warning: duplicate section `%s' has different size\n",
d993 4
a996 1
	     create a lang_input_section structure for this section.  */
d998 2
d1005 5
a1009 1
  /* This is the first section with this name.  Record it.  */
a1010 1
  l = (struct sec_link_once *) xmalloc (sizeof *l);
d1012 34
a1045 2
  l->next = sec_link_once_list;
  sec_link_once_list = l;
d1054 5
a1058 1
/* Return true if the PATTERN argument is a wildcard pattern.  */
a1067 1
	|| *s == '\\'
d1121 1
d1123 1
d1126 6
a1131 1
	init_os (output);
d1140 2
d1147 20
a1166 1
	 the embedded SEC_NEVER_LOAD section into a fill.
d1168 4
a1171 10
	 If final link, don't copy the SEC_LINK_ONCE flags, they've already
	 been processed.  One reason to do this is that on pe format targets,
	 .text$foo sections go into .text and it's odd to see .text with
	 SEC_LINK_ONCE set.  */

      section->output_section->flags |=
	section->flags & (flagword) (~ (SEC_NEVER_LOAD
					| (! link_info.relocateable
					   ? SEC_LINK_ONCE | SEC_LINK_DUPLICATES
					   : 0)));
d1189 4
d1202 8
a1209 7
/* Expand a wild statement for a particular FILE.  SECTION may be
   NULL, in which case it is a wild card.  */

static void
wild_section (ptr, section, file, output)
     lang_wild_statement_type *ptr;
     const char *section;
d1211 1
a1211 1
     lang_output_section_statement_type *output;
d1213 8
a1220 1
  if (file->just_syms_flag == false)
d1222 5
a1226 2
      register asection *s;
      boolean wildcard;
d1228 2
a1229 4
      if (section == NULL)
	wildcard = false;
      else
	wildcard = wildcardp (section);
d1231 1
a1231 1
      for (s = file->the_bfd->sections; s != NULL; s = s->next)
d1233 8
a1240 1
	  boolean match;
d1242 11
a1252 2
	  /* Attach all sections named SECTION.  If SECTION is NULL,
	     then attach all sections.
d1254 17
a1270 4
	     Previously, if SECTION was NULL, this code did not call
	     wild_doit if the SEC_IS_COMMON flag was set for the
	     section.  I did not understand that, and I took it out.
	     --ian@@cygnus.com.  */
d1272 1
a1272 3
	  if (section == NULL)
	    match = true;
	  else
d1274 4
a1277 1
	      const char *name;
d1279 5
a1283 5
	      name = bfd_get_section_name (file->the_bfd, s);
	      if (wildcard)
		match = fnmatch (section, name, 0) == 0 ? true : false;
	      else
		match = strcmp (section, name) == 0 ? true : false;
d1285 69
a1353 2
	  if (match)
	    wild_doit (&ptr->children, s, output, file);
d1422 2
a1423 2
	  einfo ("%B: file not recognized: %E\n", entry->the_bfd);
	  einfo ("%B: matching formats:", entry->the_bfd);
d1430 1
a1430 1
	einfo ("%F%B: file not recognized: %E\n", entry->the_bfd);
d1457 3
d1483 1
a1483 1
		einfo ("%F%B: object %B in archive is not object\n",
d1489 1
a1489 1
		einfo ("%F%B: could not read symbols: %E\n", member);
d1501 1
a1501 1
    einfo ("%F%B: could not read symbols: %E\n", entry->the_bfd);
d1506 1
a1506 37
/* Handle a wild statement for a single file F.  */

static void
wild_file (s, section, f, output)
     lang_wild_statement_type *s;
     const char *section;
     lang_input_statement_type *f;
     lang_output_section_statement_type *output;
{
  if (f->the_bfd == NULL
      || ! bfd_check_format (f->the_bfd, bfd_archive))
    wild_section (s, section, f, output);
  else
    {
      bfd *member;

      /* This is an archive file.  We must map each member of the
	 archive separately.  */
      member = bfd_openr_next_archived_file (f->the_bfd, (bfd *) NULL);
      while (member != NULL)
	{
	  /* When lookup_name is called, it will call the add_symbols
	     entry point for the archive.  For each element of the
	     archive which is included, BFD will call ldlang_add_file,
	     which will set the usrdata field of the member to the
	     lang_input_statement.  */
	  if (member->usrdata != NULL)
	    {
	      wild_section (s, section,
			    (lang_input_statement_type *) member->usrdata,
			    output);
	    }

	  member = bfd_openr_next_archived_file (f->the_bfd, member);
	}
    }
}
d1518 1
a1518 1
     const char *target;
d1521 22
a1542 1
  lang_input_statement_type *f;
d1544 9
a1552 1
  if (file == (char *) NULL)
d1554 4
a1557 7
      /* Perform the iteration over all files in the list */
      for (f = (lang_input_statement_type *) file_chain.head;
	   f != (lang_input_statement_type *) NULL;
	   f = (lang_input_statement_type *) f->next)
	{
	  wild_file (s, section, f, output);
	}
d1559 14
a1572 1
  else if (wildcardp (file))
d1574 6
a1579 7
      for (f = (lang_input_statement_type *) file_chain.head;
	   f != (lang_input_statement_type *) NULL;
	   f = (lang_input_statement_type *) f->next)
	{
	  if (fnmatch (file, f->filename, FNM_FILE_NAME) == 0)
	    wild_file (s, section, f, output);
	}
d1581 67
a1647 1
  else
d1649 2
a1650 3
      /* Perform the iteration over a single file */
      f = lookup_name (file);
      wild_file (s, section, f, output);
d1653 16
a1668 3
  if (section != (char *) NULL
      && strcmp (section, "COMMON") == 0
      && default_common_section == NULL)
d1670 14
a1683 3
      /* Remember the section that common is going to in case we later
         get something which doesn't know where to put it.  */
      default_common_section = output;
d1685 2
d1693 1
a1693 1
     const char *name;
d1695 1
a1695 1
  bfd *output;
d1697 1
d1700 2
a1701 1
      if (current_target != (char *) NULL)
d1703 23
d1727 25
a1751 1
	output_target = default_target;
d1753 1
d1759 3
a1761 4
	{
	  einfo ("%P%F: target %s not found\n", output_target);
	}
      einfo ("%P%F: cannot open output file %s: %E\n", name);
d1769 1
a1769 1
    einfo ("%P%F:%s: can not make object file: %E\n", name);
d1773 1
a1773 1
    einfo ("%P%F:%s: can not set architecture: %E\n", name);
d1777 1
a1777 1
    einfo ("%P%F: can not create link hash table: %E\n");
a1782 3



d1859 1
a1859 1
	  if (s->input_statement.real == true)
d1961 1
a1961 1
	einfo ("%P%F: bfd_link_hash_lookup failed: %E");
d2084 1
a2084 1
	      minfo (" load address 0x%V", addr);
d2108 1
a2108 1
  if (result.valid)
d2172 2
a2173 1

d2197 1
a2197 1
		 i->output_section->vma + i->output_offset, size,
d2214 1
a2214 1
	      minfo ("%W (size before relaxing)\n", i->_raw_size);
d2219 1
a2219 1
	  print_dot = i->output_section->vma + i->output_offset + size;
d2239 2
d2269 4
d2285 2
a2286 1
  print_dot = addr + size;
d2296 1
a2296 1
  minfo ("Address of section %s set to ", address->section_name);
d2310 2
d2333 1
a2333 1
  print_dot = addr + size;
d2342 2
d2364 1
a2364 1
  print_dot = addr + s->size;
d2374 11
a2384 1
  if (w->filename != NULL)
d2388 2
d2391 3
d2395 1
a2395 1
    minfo ("(%s)", w->section_name);
d2397 4
a2400 1
    minfo ("(*)");
d2445 1
a2445 1
      fprintf (config.map_file, "Fail with %d\n", s->header.type);
d2451 4
a2454 1
	  minfo (" CONSTRUCTORS\n");
d2559 2
d2577 1
a2577 1
      new->padding_statement.size = alignment_needed;
d2586 1
a2586 2
  output_section_statement->_raw_size += alignment_needed;
  return alignment_needed + dot;
d2588 1
d2598 1
a2598 1
     boolean relax;
d2602 2
d2621 1
a2621 1
	dot += i->_cooked_size;
d2623 3
a2625 2
	dot += i->_raw_size;
      output_section_statement->bfd_section->_raw_size = dot - output_section_statement->bfd_section->vma;
d2635 59
d2699 37
d2747 4
a2750 1
  /* Size up the sections from their constituent parts */
a2751 2
  {
    switch (s->header.type)
d2753 173
d2927 50
a2976 64
     case lang_output_section_statement_enum:
     {
       bfd_vma after;
       lang_output_section_statement_type *os = &s->output_section_statement;

       if (os->bfd_section == NULL)
	 {
	   /* This section was never actually created.  */
	   break;
	 }

       /* If this is a COFF shared library section, use the size and
	  address from the input section.  FIXME: This is COFF
	  specific; it would be cleaner if there were some other way
	  to do this, but nothing simple comes to mind.  */
       if ((os->bfd_section->flags & SEC_COFF_SHARED_LIBRARY) != 0)
	 {
	   asection *input;

	   if (os->children.head == NULL
	       || os->children.head->next != NULL
	       || os->children.head->header.type != lang_input_section_enum)
	     einfo ("%P%X: Internal error on COFF shared library section %s",
		    os->name);

	   input = os->children.head->input_section.section;
	   bfd_set_section_vma (os->bfd_section->owner,
				os->bfd_section,
				bfd_section_vma (input->owner, input));
	   os->bfd_section->_raw_size = input->_raw_size;
	   break;
	 }

       if (bfd_is_abs_section (os->bfd_section))
       {
	 /* No matter what happens, an abs section starts at zero */
	 ASSERT (os->bfd_section->vma == 0);
       }
       else
       {
	 if (os->addr_tree == (etree_type *) NULL)
	 {
	   /* No address specified for this section, get one
	      from the region specification
	      */
	   if (os->region == (lang_memory_region_type *) NULL)
	   {
	     os->region = lang_memory_region_lookup ("*default*");
	   }
	   dot = os->region->current;
	   if (os->section_alignment == -1)
	     {
	       bfd_vma olddot;

	       olddot = dot;
	       dot = align_power (dot, os->bfd_section->alignment_power);
	       if (dot != olddot && config.warn_section_align)
		 einfo ("%P: warning: changing start of section %s by %u bytes\n",
			os->name, (unsigned int) (dot - olddot));
	     }
	 }
	 else
	 {
	   etree_value_type r;
d2978 30
a3007 69
	   r = exp_fold_tree (os->addr_tree,
			      abs_output_section,
			      lang_allocating_phase_enum,
			      dot, &dot);
	   if (r.valid == false)
	   {
	     einfo ("%F%S: non constant address expression for section %s\n",
		    os->name);
	   }
	   dot = r.value + r.section->bfd_section->vma;
	 }
	 /* The section starts here */
	 /* First, align to what the section needs */

	 if (os->section_alignment != -1)
	   dot = align_power (dot, os->section_alignment);

	 bfd_set_section_vma (0, os->bfd_section, dot);
	 
	 os->bfd_section->output_offset = 0;
       }

       (void) lang_size_sections (os->children.head, os, &os->children.head,
				  os->fill, dot, relax);
       /* Ignore the size of the input sections, use the vma and size to */
       /* align against */

       after = ALIGN_N (os->bfd_section->vma +
			os->bfd_section->_raw_size,
			/* The coercion here is important, see ld.h.  */
			(bfd_vma) os->block_value);

       if (bfd_is_abs_section (os->bfd_section))
	 ASSERT (after == os->bfd_section->vma);
       else
	 os->bfd_section->_raw_size = after - os->bfd_section->vma;
       dot = os->bfd_section->vma + os->bfd_section->_raw_size;
       os->processed = true;

       /* Replace into region ? */
       if (os->region != (lang_memory_region_type *) NULL)
	 {
	   os->region->current = dot;
	   /* Make sure this isn't silly.  */
	   if (os->region->current < os->region->origin
	       || (os->region->current - os->region->origin
		   > os->region->length))
	     {
	       if (os->addr_tree != (etree_type *) NULL)
		 {
		   einfo ("%X%P: address 0x%v of %B section %s is not within region %s\n",
			  os->region->current,
			  os->bfd_section->owner,
			  os->bfd_section->name,
			  os->region->name);
		 }
	       else
		 {
		   einfo ("%X%P: region %s is full (%B section %s)\n",
			  os->region->name,
			  os->bfd_section->owner,
			  os->bfd_section->name);
		 }
	       /* Reset the region pointer.  */
	       os->region->current = os->region->origin;
	     }
	 }
     }
     break;
d3009 9
a3017 42
     case lang_constructors_statement_enum:
      dot = lang_size_sections (constructor_list.head,
				output_section_statement,
				&s->wild_statement.children.head,
				fill,
				dot, relax);
      break;

     case lang_data_statement_enum:
     {
       unsigned int size = 0;

       s->data_statement.output_vma = dot - output_section_statement->bfd_section->vma;
       s->data_statement.output_section =
	output_section_statement->bfd_section;

       switch (s->data_statement.type)
       {
        case QUAD:
	 size = QUAD_SIZE;
	 break;
	case LONG:
	 size = LONG_SIZE;
	 break;
	case SHORT:
	 size = SHORT_SIZE;
	 break;
	case BYTE:
	 size = BYTE_SIZE;
	 break;

       }
       dot += size;
       output_section_statement->bfd_section->_raw_size += size;
       /* The output section gets contents, and then we inspect for
	  any flags set in the input script which override any ALLOC */
       output_section_statement->bfd_section->flags |= SEC_HAS_CONTENTS;
       if (!(output_section_statement->flags & SEC_NEVER_LOAD)) {
	 output_section_statement->bfd_section->flags |= SEC_ALLOC | SEC_LOAD;
       }
     }
      break;
d3019 15
a3033 15
     case lang_reloc_statement_enum:
     {
       int size;

       s->reloc_statement.output_vma =
	 dot - output_section_statement->bfd_section->vma;
       s->reloc_statement.output_section =
	 output_section_statement->bfd_section;
       size = bfd_get_reloc_size (s->reloc_statement.howto);
       dot += size;
       output_section_statement->bfd_section->_raw_size += size;
     }
     break;
     
     case lang_wild_statement_enum:
d3035 5
a3039 3
      dot = lang_size_sections (s->wild_statement.children.head,
				output_section_statement,
				&s->wild_statement.children.head,
d3041 5
a3045 1
				fill, dot, relax);
d3047 28
a3074 1
      break;
d3076 2
a3077 16
     case lang_object_symbols_statement_enum:
      link_info.create_object_symbols_section =
	output_section_statement->bfd_section;
      break;
     case lang_output_statement_enum:
     case lang_target_statement_enum:
      break;
     case lang_input_section_enum:
      {
	asection *i;

	i = (*prev)->input_section.section;
	if (! relax)
	  {
	    if (i->_cooked_size == 0)
	      i->_cooked_size = i->_raw_size;
d3079 1
a3079 3
	else
	  {
	    boolean again;
d3081 12
a3092 15
	    if (! bfd_relax_section (i->owner, i, &link_info, &again))
	      einfo ("%P%F: can't relax section: %E\n");
	    if (again)
	      relax_again = true;
	  }
	dot = size_input_section (prev,
				  output_section_statement,
				  output_section_statement->fill,
				  dot, relax);
      }
      break;
     case lang_input_statement_enum:
      break;
     case lang_fill_statement_enum:
      s->fill_statement.output_section = output_section_statement->bfd_section;
d3094 6
a3099 40
      fill = s->fill_statement.fill;
      break;
     case lang_assignment_statement_enum:
     {
       bfd_vma newdot = dot;

       exp_fold_tree (s->assignment_statement.exp,
		      output_section_statement,
		      lang_allocating_phase_enum,
		      dot,
		      &newdot);

       if (newdot != dot && !relax)
	 {
	   /* The assignment changed dot.  Insert a pad.  */
	   if (output_section_statement == abs_output_section)
	     {
	       /* If we don't have an output section, then just adjust
		  the default memory address.  */
	       lang_memory_region_lookup ("*default*")->current = newdot;
	     }
	   else
	     {
	       lang_statement_union_type *new =
		 ((lang_statement_union_type *)
		  stat_alloc (sizeof (lang_padding_statement_type)));

	       /* Link into existing chain */
	       new->header.next = *prev;
	       *prev = new;
	       new->header.type = lang_padding_statement_enum;
	       new->padding_statement.output_section =
		 output_section_statement->bfd_section;
	       new->padding_statement.output_offset =
		 dot - output_section_statement->bfd_section->vma;
	       new->padding_statement.fill = fill;
	       new->padding_statement.size = newdot - dot;
	       output_section_statement->bfd_section->_raw_size +=
		 new->padding_statement.size;
	     }
d3101 3
a3103 4
	   dot = newdot;
	 }
     }
     break;
d3105 1
a3105 19
   case lang_padding_statement_enum:
     /* If we are relaxing, and this is not the first pass, some
	padding statements may have been inserted during previous
	passes.  We may have to move the padding statement to a new
	location if dot has a different value at this point in this
	pass than it did at this point in the previous pass.  */
     s->padding_statement.output_offset =
       dot - output_section_statement->bfd_section->vma;
     dot += s->padding_statement.size;
     output_section_statement->bfd_section->_raw_size +=
       s->padding_statement.size;
     break;

     case lang_group_statement_enum:
       dot = lang_size_sections (s->group_statement.children.head,
				 output_section_statement,
				 &s->group_statement.children.head,
				 fill, dot, relax);
       break;
d3107 4
a3110 8
     default:
      FAIL ();
      break;

      /* This can only get here when relaxing is turned on */

     case lang_address_statement_enum:
      break;
a3111 2
    prev = &s->header.next;
  }
d3122 3
d3146 2
a3147 1
		dot = os->bfd_section->vma + os->bfd_section->_raw_size;
d3184 2
a3185 2
	    if (value.valid == false)
	      einfo ("%F%P: invalid data statement\n");
d3187 24
a3210 15
	  switch (s->data_statement.type)
	    {
	    case QUAD:
	      dot += QUAD_SIZE;
	      break;
	    case LONG:
	      dot += LONG_SIZE;
	      break;
	    case SHORT:
	      dot += SHORT_SIZE;
	      break;
	    case BYTE:
	      dot += BYTE_SIZE;
	      break;
	    }
d3221 2
a3222 2
	    if (value.valid == false)
	      einfo ("%F%P: invalid reloc statement\n");
d3224 1
a3224 1
	  dot += bfd_get_reloc_size (s->reloc_statement.howto);
d3232 1
a3232 1
	      dot += in->_cooked_size;
d3234 1
a3234 1
	      dot += in->_raw_size;
d3254 1
a3254 1
	  dot += s->padding_statement.size;
d3312 2
d3316 1
a3316 1
	    h->u.def.value = s->_cooked_size;
d3318 1
a3318 1
	    h->u.def.value = s->_raw_size;
d3358 1
a3358 1
	einfo ("%P%F:%s: can't set start address\n", entry_symbol);
d3362 2
a3363 1
      asection *ts;
d3365 4
a3368 4
      /* Can't find the entry symbol.  Use the first address in the
	 text section.  */
      ts = bfd_get_section_by_name (output_bfd, ".text");
      if (ts != (asection *) NULL)
d3370 2
a3371 6
	  if (warn)
	    einfo ("%P: warning: cannot find entry symbol %s; defaulting to %V\n",
		   entry_symbol, bfd_get_section_vma (output_bfd, ts));
	  if (! bfd_set_start_address (output_bfd,
				       bfd_get_section_vma (output_bfd, ts)))
	    einfo ("%P%F: can't set start address\n");
d3375 21
a3395 3
	  if (warn)
	    einfo ("%P: warning: cannot find entry symbol %s; not setting start address\n",
		   entry_symbol);
d3400 14
d3433 9
a3441 3
	einfo ("%P: warning: %s architecture of input file `%B' is incompatible with %s output\n",
	       bfd_printable_name (input_bfd), input_bfd,
	       bfd_printable_name (output_bfd));
d3443 16
a3458 2
      else
	bfd_merge_private_bfd_data (input_bfd, output_bfd);
d3495 2
d3511 2
a3512 2
  section->_raw_size = ALIGN_N (section->_raw_size,
				(bfd_size_type) (1 << power_of_two));
d3521 1
a3521 1
  h->u.def.value = section->_raw_size;
d3524 1
a3524 1
  section->_raw_size += size;
d3526 2
a3527 1
  /* Make sure the section is allocated in memory.  */
d3529 1
d3540 2
a3541 2
	  minfo ("\nAllocating common symbols\n");
	  minfo ("Common symbol       size              file\n\n");
d3591 1
a3591 5
  lang_input_statement_type *file;

  for (file = (lang_input_statement_type *) file_chain.head;
       file != (lang_input_statement_type *) NULL;
       file = (lang_input_statement_type *) file->next)
d3626 1
a3626 1
			  info_msg ("%P: no [COMMON] command, defaulting to .bss\n");
d3652 2
a3653 2
lang_set_flags (ptr, flags)
     int *ptr;
d3655 1
d3657 1
a3657 1
  boolean state = false;
d3659 1
a3659 1
  *ptr = 0;
a3661 7
      if (*flags == '!')
	{
	  state = false;
	  flags++;
	}
      else
	state = true;
d3664 6
a3669 2
	case 'R':
	  /*	  ptr->flag_read = state; */
d3671 3
a3673 2
	case 'W':
	  /*	  ptr->flag_write = state; */
d3675 3
a3677 2
	case 'X':
	  /*	  ptr->flag_executable= state;*/
d3679 4
a3682 3
	case 'L':
	case 'I':
	  /*	  ptr->flag_loadable= state;*/
d3684 1
d3686 1
a3686 1
	  einfo ("%P%F: invalid syntax in flags\n");
d3716 1
a3716 5
  lang_input_statement_type *f;

  for (f = (lang_input_statement_type *) file_chain.head;
       f != (lang_input_statement_type *) NULL;
       f = (lang_input_statement_type *) f->next)
d3730 1
a3730 5
  lang_input_statement_type *f;

  for (f = (lang_input_statement_type *) file_chain.head;
       f != (lang_input_statement_type *) NULL;
       f = (lang_input_statement_type *) f->next)
d3732 1
a3732 1
      asection *s;
d3891 97
d4001 2
d4009 13
d4026 4
d4033 1
a4033 1
  /* Run through the contours of the script and attatch input sections
d4040 1
a4040 1
  /* Find any sections not attatched explicitly and handle them */
d4065 4
d4105 5
a4109 4
  /* Make sure that we're not mixing architectures */

  lang_check ();

d4119 8
a4126 3
lang_add_wild (section_name, filename)
     CONST char *CONST section_name;
     CONST char *CONST filename;
d4135 1
a4135 1
  if (filename != (char *) NULL)
d4140 1
d4142 3
a4163 15
/* WINDOWS_NT.  When an entry point has been specified, we will also force
   this symbol to be defined by calling ldlang_add_undef (equivalent to 
   having switch -u entry_name on the command line).  The reason we do
   this is so that the user doesn't have to because they would have to use
   the -u switch if they were specifying an entry point other than 
   _mainCRTStartup.  Specifically, if creating a windows application, entry
   point _WinMainCRTStartup must be specified.
     What I have found for non console applications (entry not _mainCRTStartup)
   is that the .obj that contains mainCRTStartup is brought in since it is
   the first encountered in libc.lib and it has other symbols in it which will
   be pulled in by the link process.  To avoid this, adding -u with the entry
   point name specified forces the correct .obj to be used.  We can avoid
   making the user do this by always adding the entry point name as an
   undefined symbol.  */

a4175 8
#if 0 
  /* don't do this yet.  It seems to work (the executables run), but the 
     image created is very different from what I was getting before indicating
     that something else is being pulled in.  When everything else is working,
     then try to put this back in to see if it will do the right thing for
     other more complicated applications */
  ldlang_add_undef (name);
#endif
d4257 1
a4257 1
void
d4265 1
d4281 1
a4281 1
      einfo ("%P%Fmultiple STARTUP files\n");
d4298 1
a4298 1
lang_leave_output_section_statement (fill, memspec, phdrs)
d4302 1
d4306 8
d4333 1
a4333 1
    einfo ("%P%F: bfd_link_hash_lookup failed: %E\n");
d4367 1
a4367 1
    einfo ("%P%F: bfd_link_hash_lookup failed: %E\n");
d4381 2
a4382 1
			  + bfd_section_size (output_bfd, sec));
d4553 1
a4553 1
	einfo ("%F%P: bfd_record_phdr failed: %E\n");
d4572 1
a4572 1
	  einfo ("%X%P: section `%s' assigned to non-existent phdr `%s'\n",
d4674 1
a4674 1
    overlay_max = exp_binop (MAX, overlay_max, size);
d4692 2
a4693 1
  lang_leave_output_section_statement (fill, "*default*", phdrs);
d4700 1
a4700 1
    if (isalnum (*s1) || *s1 == '_')
d4723 1
a4723 1
lang_leave_overlay (fill, memspec, phdrs)
d4727 1
d4730 1
d4739 5
d4755 2
d4787 247
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d650 1
a650 1
section_already_linked (abfd, sec, ignore)
d653 1
a653 1
     PTR ignore;
d655 1
d666 8
d2076 9
a2084 1
	     dot = align_power (dot, os->bfd_section->alignment_power);
d2948 1
a2948 1
  bfd_map_over_sections (entry->the_bfd, section_already_linked, (PTR) NULL);
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d17 3
a19 2
along with GLD; see the file COPYING.  If not, write to
the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d36 3
d71 1
d73 1
d81 3
d148 1
a295 1
  p->complained = false;
a353 1
  p->common_output_section = (asection *) NULL;
d501 1
a501 1
      lookup->loadable = 1;
d554 2
a555 3
/*
 *
 */
d558 1
a558 1
     lang_output_section_statement_type * s;
d562 3
d585 54
d728 17
d822 1
a822 1
      if (! output->loadable) 
d824 9
a832 1
	  /* Turn off load flag */
d835 1
d860 6
d869 2
d879 13
a891 3
	  if (section == NULL
	      || strcmp (bfd_get_section_name (file->the_bfd, s),
			 section) == 0)
d1042 38
d1102 11
a1112 1
	  wild_section (s, section, f, output);
d1119 1
a1119 27
      if (f->the_bfd == NULL
	  || ! bfd_check_format (f->the_bfd, bfd_archive))
	wild_section (s, section, f, output);
      else
	{
	  bfd *member;

	  /* This is an archive file.  We must map each member of the
             archive separately.  */
	  member = bfd_openr_next_archived_file (f->the_bfd, (bfd *) NULL);
	  while (member != NULL)
	    {
	      /* When lookup_name is called, it will call the
                 add_symbols entry point for the archive.  For each
                 element of the archive which is included, BFD will
                 call ldlang_add_file, which will set the usrdata
                 field of the member to the lang_input_statement.  */
	      if (member->usrdata != NULL)
		{
		  wild_section (s, section,
				(lang_input_statement_type *) member->usrdata,
				output);
		}

	      member = bfd_openr_next_archived_file (f->the_bfd, member);
	    }
	}
d1231 2
a1232 1
	  if (s->wild_statement.filename)
a1411 1
	case lang_assignment_statement_enum:
d1418 9
d1745 1
a1745 1
    minfo (" 0x%x", s->fill);
d2082 1
a2082 1
	   dot = r.value;
d2760 1
a2760 1
	      else if (file->common_section == s)
d2762 3
a2764 3
		  /* This is a lonely common section which must
		     have come from an archive. We attatch to the
		     section with the wildcard  */
d2766 1
a2766 1
		      && ! command_line.force_common_definition)
d2768 1
a2768 2
		      if (default_common_section ==
			  (lang_output_section_statement_type *) NULL)
d2770 4
d2775 1
a2775 1

d2969 1
d2972 1
a2972 1
				     address_exp, flags, block_value,
d2976 1
a2976 1
     int flags;
d3001 3
a3003 3
  os->flags = flags;
  if (flags & SEC_NEVER_LOAD)
   os->loadable = 0;
d3005 1
a3005 1
   os->loadable = 1;
d3344 1
a3344 1
lang_leave_output_section_statement (fill, memspec)
d3346 2
a3347 1
     CONST char *memspec;
d3351 1
a3508 16
/* Record that a section should be placed in a phdr.  */

void
lang_section_in_phdr (name)
     const char *name;
{
  struct lang_output_section_phdr_list *n;

  n = ((struct lang_output_section_phdr_list *)
       stat_alloc (sizeof (struct lang_output_section_phdr_list)));
  n->name = name;
  n->used = false;
  n->next = current_section->phdrs;
  current_section->phdrs = n;
}

d3522 1
a3522 1
  secs = xmalloc (alc * sizeof (asection *));
d3545 1
a3545 1
	      if (! os->loadable
d3562 2
a3563 1
		      secs = xrealloc (secs, alc * sizeof (asection *));
d3611 202
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 1995 Free Software Foundation, Inc.
a36 3
static void print_statements PARAMS ((void));
static void print_statement PARAMS ((lang_statement_union_type *,
				      lang_output_section_statement_type *));
a56 1
static int longest_section_name = 8;
d58 1
a59 4
static void print_size PARAMS ((size_t value));
static void print_alignment PARAMS ((unsigned int value));
static void print_fill PARAMS ((fill_type value));
static void print_section PARAMS ((const char *name));
a65 1
static void print_flags PARAMS ((int *ignore_flags));
d67 1
d98 1
d108 2
d127 1
d155 2
a163 28
static void
print_size (value)
     size_t value;
{
  fprintf (config.map_file, "%5x", (unsigned) value);
}

static void
print_alignment (value)
     unsigned int value;
{
  fprintf (config.map_file, "2**%1u", value);
}

static void
print_fill (value)
     fill_type value;
{
  fprintf (config.map_file, "%04x", (unsigned) value);
}

static void
print_section (name)
     CONST char *name;
{
  fprintf (config.map_file, "%*s", -longest_section_name, name);
}

d207 1
d347 1
d502 1
a510 19
/*ARGSUSED*/
static void
print_flags (ignore_flags)
     int *ignore_flags;
{
  fprintf (config.map_file, "(");
#if 0
  if (flags->flag_read)
    fprintf (outfile, "R");
  if (flags->flag_write)
    fprintf (outfile, "W");
  if (flags->flag_executable)
    fprintf (outfile, "X");
  if (flags->flag_loadable)
    fprintf (outfile, "L");
#endif
 fprintf (config.map_file, ")");
}

d516 3
a518 6
  fprintf (config.map_file, "**MEMORY CONFIGURATION**\n\n");
#ifdef BFD64
  fprintf (config.map_file, "name\t\torigin\t\tlength\t\tattributes\n");
#else
  fprintf (config.map_file,
	   "name\t\torigin   length   r_size   c_size    is    attributes\n");
a519 1
#endif
d524 18
a541 18
      fprintf (config.map_file, "%-16s", m->name);
      print_address (m->origin);
      print_space ();
      print_address ((bfd_vma)m->length);
      print_space ();
      print_address ((bfd_vma)m->old_length);
      print_space();
      print_address (m->current - m->origin);
      print_space();
      if (m->old_length)
       fprintf (config.map_file, " %2d%%  ",
		(int) ((m->current - m->origin) * 100 / m->old_length));
      print_flags (&m->flags);
      fprintf (config.map_file, "\n");
    }
  fprintf (config.map_file, "\n\n**LINK EDITOR MEMORY MAP**\n\n");
  fprintf (config.map_file, "output   input     virtual\n");
  fprintf (config.map_file, "section  section   address    tsize\n\n");
a543 1

d553 7
a559 4
/*  asection *section = bfd_get_section_by_name(output_bfd, s->name);*/
  section_userdata_type *new =
  (section_userdata_type *)
  stat_alloc (sizeof (section_userdata_type));
d575 66
d642 3
a644 1
}
d646 3
a648 2
/***********************************************************************
  The wild routines.
d650 1
a650 8
  These expand statements like *(.text) and foo.o to a list of
  explicit actions, like foo.o(.text), bar.o(.text) and
  foo.o(.text,.data) .

  The toplevel routine, wild, takes a statement, section, file and
  target. If either the section or file is null it is taken to be the
  wildcard. Seperate lang_input_section statements are created for
  each part of the expanstion, and placed after the statement provided.
d652 15
a666 1
*/
d670 4
a673 4
     lang_statement_list_type * ptr;
     asection * section;
     lang_output_section_statement_type * output;
     lang_input_statement_type * file;
d675 6
a680 2
  if (output->bfd_section == (asection *) NULL)
    init_os (output);
d682 5
a686 5
  if (section != (asection *) NULL
      && section->output_section == (asection *) NULL)
  {
    /* Add a section reference to the list */
    lang_input_section_type *new = new_stat (lang_input_section, ptr);
d688 4
a691 3
    new->section = section;
    new->ifile = file;
    section->output_section = output->bfd_section;
d693 5
a697 8
    /* We don't copy the SEC_NEVER_LOAD flag from an input section to
       an output section, because we want to be able to include a
       SEC_NEVER_LOAD section in the middle of an otherwise loaded
       section (I don't know why we want to do this, but we do).
       build_link_order in ldwrite.c handles this case by turning the
       embedded SEC_NEVER_LOAD section into a fill.  */
    section->output_section->flags |=
      section->flags & (flagword) (~ SEC_NEVER_LOAD);
d699 1
a699 1
    if (!output->loadable) 
d701 6
a706 3
      /* Turn off load flag */
      output->bfd_section->flags &= ~SEC_LOAD;
      output->bfd_section->flags |= SEC_NEVER_LOAD;
d708 2
a709 1
    if (section->alignment_power > output->bfd_section->alignment_power)
d711 43
a753 1
      output->bfd_section->alignment_power = section->alignment_power;
a754 6
    /* If supplied an aligmnet, then force it */
    if (output->section_alignment != -1)
    {
      output->bfd_section->alignment_power = output->section_alignment;
    }
  }
d757 3
d789 4
a792 7
/* passed a file name (which must have been seen already and added to
   the statement tree. We will see if it has been opened already and
   had its symbols read. If not then we'll read it.

   Archives are pecuilar here. We may open them once, but if they do
   not define anything we need at the time, they won't have all their
   symbols read. If we need them later, we'll have to redo it.  */
d795 1
a795 1
     CONST char *name;
a862 2
      /* Try to interpret the file as a linker script.  */

d866 7
d904 1
a904 1
      if (whole_archive)
d914 1
a914 1
		     (&link_info, member, "-whole-archive")))
d934 5
d941 5
a945 5
     lang_wild_statement_type * s;
     CONST char *section;
     CONST char *file;
     CONST char *target;
     lang_output_section_statement_type * output;
d962 28
a989 1
      wild_section (s, section, lookup_name (file), output);
d991 1
d994 1
a994 1
   && default_common_section == (lang_output_section_statement_type *) NULL)
d996 2
a997 2
      /* Remember the section that common is going to incase we later
         get something which doesn't know where to put it */
d1002 1
a1002 3
/*
  read in all the files
  */
d1006 1
a1006 1
     CONST char *name;
d1028 1
a1028 1
  delete_output_file_on_failure = 1;
d1068 1
a1068 1
      if (config.traditional_format)
d1312 21
d1334 1
a1334 2
  print_nl ();
  print_section (output_section_statement->name);
d1336 3
d1340 5
a1344 26
  if (section)
  {
    print_dot = section->vma;
    print_space ();
    print_section ("");
    print_space ();
    print_address (section->vma);
    print_space ();
    print_size (section->_raw_size);
    print_space ();
    print_size(section->_cooked_size);
    print_space ();
    print_alignment (section->alignment_power);
    print_space ();
#if 0
    fprintf (config.map_file, "%s flags", output_section_statement->region->name);
    print_flags (stdout, &output_section_statement->flags);
#endif
    if (section->flags & SEC_LOAD)
     fprintf (config.map_file, "load ");
    if (section->flags & SEC_ALLOC)
     fprintf (config.map_file, "alloc ");
    if (section->flags & SEC_RELOC)
     fprintf (config.map_file, "reloc ");
    if (section->flags & SEC_HAS_CONTENTS)
     fprintf (config.map_file, "contents ");
d1346 1
a1346 25
  }
  else
  {
    fprintf (config.map_file, " (no attached output section)");
  }
  print_nl ();
  if (output_section_statement->load_base)
    {
      bfd_vma b = exp_get_abs_int(output_section_statement->load_base,
				0, "output base", lang_final_phase_enum);
      fprintf (config.map_file, "Output address   ");
      fprintf_vma (config.map_file, b);
      fprintf (config.map_file, "\n");
    }
  if (output_section_statement->section_alignment >= 0
      || output_section_statement->subsection_alignment >= 0) 
  {
    fprintf (config.map_file, "\t\t\t\t\tforced alignment ");
    if (output_section_statement->section_alignment >= 0) 
    {
      fprintf (config.map_file, "section 2**%d ",output_section_statement->section_alignment );
    }
    if ( output_section_statement->subsection_alignment >= 0) 
    {
      fprintf (config.map_file, "subsection 2**%d ",output_section_statement->subsection_alignment );
a1347 5
  
    print_nl ();
  }
  print_statement (output_section_statement->children.head,
		   output_section_statement);
d1349 2
d1358 1
d1361 2
a1362 11
  print_section ("");
  print_space ();
  print_section ("");
  print_space ();
  print_address (print_dot);
  print_space ();
  result = exp_fold_tree (assignment->exp->assign.src,
			  output_section,
			  lang_final_phase_enum,
			  print_dot,
			  &print_dot);
d1364 2
d1367 1
a1367 3
    {
      print_address (result.value);
    }
d1370 4
a1373 1
      fprintf (config.map_file, "*undefined*");
d1375 3
a1377 1
  print_space ();
d1380 1
a1380 1
  fprintf (config.map_file, "\n");
d1393 2
a1394 3
/* Print all the defined symbols for the abfd provided by in the supplied
   section.
*/
d1398 2
a1399 2
struct  bfd_link_hash_entry *hash_entry;
PTR ptr;
d1401 1
a1401 1
  asection * sec = (asection *)ptr;
d1403 3
a1405 2
  if (hash_entry->type == bfd_link_hash_defined
      || hash_entry->type == bfd_link_hash_defweak)
d1407 10
a1416 9
      if (sec == hash_entry->u.def.section) {
	print_section ("");
	fprintf (config.map_file, " ");
	print_section ("");
	fprintf (config.map_file, " ");
	print_address (hash_entry->u.def.value + outside_section_address (sec));
	fprintf (config.map_file, "              %s", hash_entry->root.string);
	print_nl ();
      }
d1422 2
d1433 10
a1442 15
      print_section ("");
      fprintf (config.map_file, " ");
      print_section (i->name);
      fprintf (config.map_file, " ");
      if (i->output_section)
	{
	  print_address (i->output_section->vma + i->output_offset);
	  fprintf (config.map_file, " ");
	  print_size (i->_raw_size);
	  fprintf (config.map_file, " ");
	  print_size(i->_cooked_size);
	  fprintf (config.map_file, " ");
	  print_alignment (i->alignment_power);
	  fprintf (config.map_file, " ");
	  if (in->ifile)
d1444 8
d1453 3
a1455 1
	      bfd *abfd = in->ifile->the_bfd;
d1457 9
a1465 1
	      if (in->ifile->just_syms_flag == true)
d1467 2
a1468 1
		  fprintf (config.map_file, "symbols only ");
d1471 1
a1471 19
	      fprintf (config.map_file, " %s ", abfd->xvec->name);
	      if (abfd->my_archive != (bfd *) NULL)
		{
		  fprintf (config.map_file, "[%s]%s", abfd->my_archive->filename,
			   abfd->filename);
		}
	      else
		{
		  fprintf (config.map_file, "%s", abfd->filename);
		}
	      fprintf (config.map_file, "(overhead %d bytes)", (int) bfd_alloc_size (abfd));
	      print_nl ();

	      /* Print all the symbols */
	      bfd_link_hash_traverse (link_info.hash, print_one_symbol, (PTR) i);
	    }
	  else
	    {
	      print_nl ();
d1474 1
d1476 1
a1476 5
	  print_dot = outside_section_address (i) + size;
	}
      else
	{
	  fprintf (config.map_file, "No output section allocated\n");
d1485 1
a1485 2
  fprintf (config.map_file, "FILL mask ");
  print_fill (fill->fill);
d1492 11
a1502 6
/*  bfd_vma value; */
  print_section ("");
  print_space ();
  print_section ("");
  print_space ();
/*  ASSERT(print_dot == data->output_vma);*/
a1503 4
  print_address (data->output_vma + data->output_section->vma);
  print_space ();
  print_address (data->value);
  print_space ();
d1506 2
d1509 2
a1510 2
      fprintf (config.map_file, "BYTE ");
      print_dot += BYTE_SIZE;
d1513 2
a1514 2
      fprintf (config.map_file, "SHORT ");
      print_dot += SHORT_SIZE;
d1517 2
a1518 2
      fprintf (config.map_file, "LONG ");
      print_dot += LONG_SIZE;
d1521 2
a1522 2
      fprintf (config.map_file, "QUAD ");
      print_dot += QUAD_SIZE;
d1526 7
a1532 1
  exp_print_tree (data->exp);
d1534 15
a1548 1
  fprintf (config.map_file, "\n");
d1557 6
a1562 4
  print_section ("");
  print_space ();
  print_section ("");
  print_space ();
d1564 3
a1566 1
/*  ASSERT(print_dot == data->output_vma);*/
d1568 1
a1568 4
  print_address (reloc->output_vma + reloc->output_section->vma);
  print_space ();
  print_address (reloc->addend_value);
  print_space ();
d1570 1
a1570 1
  fprintf (config.map_file, "RELOC %s ", reloc->howto->name);
d1572 4
a1575 1
  print_dot += bfd_get_reloc_size (reloc->howto);
d1579 3
a1581 1
  fprintf (config.map_file, "\n");
d1586 1
a1586 1
     lang_padding_statement_type * s;
d1588 20
a1607 9
  print_section ("");
  print_space ();
  print_section ("*fill*");
  print_space ();
  print_address (s->output_offset + s->output_section->vma);
  print_space ();
  print_size (s->size);
  print_space ();
  print_fill (s->fill);
d1610 1
a1610 2
  print_dot = s->output_offset + s->output_section->vma + s->size;

d1618 4
a1621 5
  fprintf (config.map_file, " from ");
  if (w->filename != (char *) NULL)
    {
      fprintf (config.map_file, "%s", w->filename);
    }
d1623 4
a1626 7
    {
      fprintf (config.map_file, "*");
    }
  if (w->section_name != (char *) NULL)
    {
      fprintf (config.map_file, "(%s)", w->section_name);
    }
d1628 2
a1629 3
    {
      fprintf (config.map_file, "(*)");
    }
a1630 1
  print_statement (w->children.head, os);
d1632 1
d1643 1
a1643 1
  print_statement (s->children.head, os);
d1647 18
d1667 2
a1668 2
     lang_statement_union_type * s;
     lang_output_section_statement_type * os;
d1670 1
a1670 1
  while (s)
d1672 6
a1677 1
      switch (s->header.type)
d1679 2
a1680 56
	  case lang_constructors_statement_enum:
	  fprintf (config.map_file, "constructors:\n");
	  print_statement (constructor_list.head, os);
	  break;
	case lang_wild_statement_enum:
	  print_wild_statement (&s->wild_statement, os);
	  break;
	default:
	  fprintf (config.map_file, "Fail with %d\n", s->header.type);
	  FAIL ();
	  break;
	case lang_address_statement_enum:
	  fprintf (config.map_file, "address\n");
	  break;
	case lang_object_symbols_statement_enum:
	  fprintf (config.map_file, "object symbols\n");
	  break;
	case lang_fill_statement_enum:
	  print_fill_statement (&s->fill_statement);
	  break;
	case lang_data_statement_enum:
	  print_data_statement (&s->data_statement);
	  break;
	case lang_reloc_statement_enum:
	  print_reloc_statement (&s->reloc_statement);
	  break;
	case lang_input_section_enum:
	  print_input_section (&s->input_section);
	  break;
	case lang_padding_statement_enum:
	  print_padding_statement (&s->padding_statement);
	  break;
	case lang_output_section_statement_enum:
	  print_output_section_statement (&s->output_section_statement);
	  break;
	case lang_assignment_statement_enum:
	  print_assignment (&s->assignment_statement,
			    os);
	  break;
	case lang_target_statement_enum:
	  fprintf (config.map_file, "TARGET(%s)\n", s->target_statement.target);
	  break;
	case lang_output_statement_enum:
	  fprintf (config.map_file, "OUTPUT(%s %s)\n",
		   s->output_statement.name,
		   output_target ? output_target : "");
	  break;
	case lang_input_statement_enum:
	  print_input_statement (&s->input_statement);
	  break;
	case lang_group_statement_enum:
	  print_group (&s->group_statement, os);
	  break;
	case lang_afile_asection_pair_statement_enum:
	  FAIL ();
	  break;
d1682 49
a1730 1
      s = s->next;
a1733 1

d1737 14
a1750 2
  print_statement (statement_list.head,
		   abs_output_section);
d1752 14
d1978 3
a1980 3
	   if ((os->region->current < os->region->origin)
	       || (os->region->current
		   > os->region->origin + os->region->length))
d2084 4
a2087 1
	  i->_cooked_size = i->_raw_size;
d2163 2
d2347 3
d2537 45
a2581 3
    fprintf (config.map_file, "Allocating common %s: %lx at %lx %s\n",
	     h->root.string, (unsigned long) size,
	     (unsigned long) h->u.def.value, section->owner->filename);
d2778 12
d2940 4
d3333 148
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d37 3
d60 1
a61 1
static struct lang_phdr *lang_phdr_list;
d63 4
d73 1
a74 1
static void section_already_linked PARAMS ((bfd *, asection *, PTR));
a104 1
static void print_address_statement PARAMS ((lang_address_statement_type *));
a113 2
static void print_statement_list PARAMS ((lang_statement_union_type *s,
					  lang_output_section_statement_type *os));
a130 1
static void lang_record_phdrs PARAMS ((void));
a157 2
#define SECTION_NAME_MAP_LENGTH (16)

d165 28
a235 1
	case lang_fill_statement_enum:
a374 1
  p->whole_archive = whole_archive;
a528 1
      lookup->phdrs = NULL;
d537 19
d561 6
a566 3
  minfo ("\nMemory Configuration\n\n");
  fprintf (config.map_file, "%-16s %-18s %-18s\n",
	   "Name", "Origin", "Length");
d568 1
d573 18
a590 2
      char buf[100];
      int len;
d592 1
a592 15
      fprintf (config.map_file, "%-16s ", m->name);

      sprintf_vma (buf, m->origin);
      minfo ("0x%s ", buf);
      len = strlen (buf);
      while (len < 16)
	{
	  print_space ();
	  ++len;
	}

      minfo ("0x%V\n", m->length);
    }

  fprintf (config.map_file, "\nLinker script and memory map\n\n");
a593 1
  print_statements ();
d603 4
a606 7
  section_userdata_type *new;

  if (strcmp (s->name, DISCARD_SECTION_NAME) == 0)
    einfo ("%P%F: Illegal use of `%s' section", DISCARD_SECTION_NAME);

  new = ((section_userdata_type *)
	 stat_alloc (sizeof (section_userdata_type)));
d622 1
d625 2
a626 6
/* Sections marked with the SEC_LINK_ONCE flag should only be linked
   once into the output.  This routine checks each sections, and
   arranges to discard it if a section of the same name has already
   been linked.  This code assumes that all relevant sections have the
   SEC_LINK_ONCE flag set; that is, it does not depend solely upon the
   section name.  This is called via bfd_map_over_sections.  */
d628 8
a635 16
/*ARGSUSED*/
static void
section_already_linked (abfd, sec, ignore)
     bfd *abfd;
     asection *sec;
     PTR ignore;
{
  struct sec_link_once
    {
      struct sec_link_once *next;
      asection *sec;
    };
  static struct sec_link_once *sec_link_once_list;
  flagword flags;
  const char *name;
  struct sec_link_once *l;
d637 1
a637 66
  flags = bfd_get_section_flags (abfd, sec);

  if ((flags & SEC_LINK_ONCE) == 0)
    return;

  name = bfd_get_section_name (abfd, sec);

  for (l = sec_link_once_list; l != NULL; l = l->next)
    {
      if (strcmp (name, bfd_get_section_name (l->sec->owner, l->sec)) == 0)
	{
	  /* The section has already been linked.  See if we should
             issue a warning.  */
	  switch (flags & SEC_LINK_DUPLICATES)
	    {
	    default:
	      abort ();

	    case SEC_LINK_DUPLICATES_DISCARD:
	      break;

	    case SEC_LINK_DUPLICATES_ONE_ONLY:
	      einfo ("%P: %B: warning: ignoring duplicate section `%s'\n",
		     abfd, name);
	      break;

	    case SEC_LINK_DUPLICATES_SAME_CONTENTS:
	      /* FIXME: We should really dig out the contents of both
                 sections and memcmp them.  The COFF/PE spec says that
                 the Microsoft linker does not implement this
                 correctly, so I'm not going to bother doing it
                 either.  */
	      /* Fall through.  */
	    case SEC_LINK_DUPLICATES_SAME_SIZE:
	      if (bfd_section_size (abfd, sec)
		  != bfd_section_size (l->sec->owner, l->sec))
		einfo ("%P: %B: warning: duplicate section `%s' has different size\n",
		       abfd, name);
	      break;
	    }

	  /* Set the output_section field so that wild_doit does not
	     create a lang_input_section structure for this section.  */
	  sec->output_section = bfd_abs_section_ptr;

	  return;
	}
    }

  /* This is the first section with this name.  Record it.  */

  l = (struct sec_link_once *) xmalloc (sizeof *l);
  l->sec = sec;
  l->next = sec_link_once_list;
  sec_link_once_list = l;
}

/* The wild routines.

   These expand statements like *(.text) and foo.o to a list of
   explicit actions, like foo.o(.text), bar.o(.text) and
   foo.o(.text, .data).  */

/* Add SECTION to the output section OUTPUT.  Do this by creating a
   lang_input_section statement which is placed at PTR.  FILE is the
   input file which holds SECTION.  */
d641 4
a644 4
     lang_statement_list_type *ptr;
     asection *section;
     lang_output_section_statement_type *output;
     lang_input_statement_type *file;
d646 2
a647 2
  flagword flags;
  boolean discard;
d649 5
a653 1
  flags = bfd_get_section_flags (section->owner, section);
d655 3
a657 1
  discard = false;
d659 8
a666 5
  /* If we are doing a final link, discard sections marked with
     SEC_EXCLUDE.  */
  if (! link_info.relocateable
      && (flags & SEC_EXCLUDE) != 0)
    discard = true;
d668 7
a674 12
  /* Discard input sections which are assigned to a section named
     DISCARD_SECTION_NAME.  */
  if (strcmp (output->name, DISCARD_SECTION_NAME) == 0)
    discard = true;

  /* Discard debugging sections if we are stripping debugging
     information.  */
  if ((link_info.strip == strip_debugger || link_info.strip == strip_all)
      && (flags & SEC_DEBUGGING) != 0)
    discard = true;

  if (discard)
d676 1
a676 6
      if (section->output_section == NULL)
	{
	  /* This prevents future calls from assigning this section.  */
	  section->output_section = bfd_abs_section_ptr;
	}
      return;
d678 2
a679 2

  if (section->output_section == NULL)
d681 1
a681 43
      lang_input_section_type *new;

      if (output->bfd_section == NULL)
	init_os (output);

      /* Add a section reference to the list */
      new = new_stat (lang_input_section, ptr);

      new->section = section;
      new->ifile = file;
      section->output_section = output->bfd_section;

      /* We don't copy the SEC_NEVER_LOAD flag from an input section
	 to an output section, because we want to be able to include a
	 SEC_NEVER_LOAD section in the middle of an otherwise loaded
	 section (I don't know why we want to do this, but we do).
	 build_link_order in ldwrite.c handles this case by turning
	 the embedded SEC_NEVER_LOAD section into a fill.

	 If final link, don't copy the SEC_LINK_ONCE flags, they've already
	 been processed.  One reason to do this is that on pe format targets,
	 .text$foo sections go into .text and it's odd to see .text with
	 SEC_LINK_ONCE set.  */

      section->output_section->flags |=
	section->flags & (flagword) (~ (SEC_NEVER_LOAD
					| (! link_info.relocateable
					   ? SEC_LINK_ONCE | SEC_LINK_DUPLICATES
					   : 0)));

      if (! output->loadable) 
	{
	  /* Turn off load flag */
	  output->bfd_section->flags &= ~SEC_LOAD;
	  output->bfd_section->flags |= SEC_NEVER_LOAD;
	}

      if (section->alignment_power > output->bfd_section->alignment_power)
	output->bfd_section->alignment_power = section->alignment_power;

      /* If supplied an aligment, then force it.  */
      if (output->section_alignment != -1)
	output->bfd_section->alignment_power = output->section_alignment;
d683 1
a685 3
/* Expand a wild statement for a particular FILE.  SECTION may be
   NULL, in which case it is a wild card.  */

d715 7
a721 4
/* This is passed a file name which must have been seen already and
   added to the statement tree.  We will see if it has been opened
   already and had its symbols read.  If not then we'll read it.  */

d724 1
a724 1
     const char *name;
d792 2
a796 7
      /* See if the emulation has some special knowledge.  */

      if (ldemul_unrecognized_file (entry))
	return;

      /* Try to interpret the file as a linker script.  */

d828 1
a828 1
      if (entry->whole_archive)
d838 1
a838 1
		     (&link_info, member, "--whole-archive")))
a857 5
/* Handle a wild statement.  SECTION or FILE or both may be NULL,
   indicating that it is a wildcard.  Separate lang_input_section
   statements are created for each part of the expansion; they are
   added after the wild statement S.  OUTPUT is the output section.  */

d860 5
a864 5
     lang_wild_statement_type *s;
     const char *section;
     const char *file;
     const char *target;
     lang_output_section_statement_type *output;
d881 1
a881 28
      f = lookup_name (file);
      if (f->the_bfd == NULL
	  || ! bfd_check_format (f->the_bfd, bfd_archive))
	wild_section (s, section, f, output);
      else
	{
	  bfd *member;

	  /* This is an archive file.  We must map each member of the
             archive separately.  */
	  member = bfd_openr_next_archived_file (f->the_bfd, (bfd *) NULL);
	  while (member != NULL)
	    {
	      /* When lookup_name is called, it will call the
                 add_symbols entry point for the archive.  For each
                 element of the archive which is included, BFD will
                 call ldlang_add_file, which will set the usrdata
                 field of the member to the lang_input_statement.  */
	      if (member->usrdata != NULL)
		{
		  wild_section (s, section,
				(lang_input_statement_type *) member->usrdata,
				output);
		}

	      member = bfd_openr_next_archived_file (f->the_bfd, member);
	    }
	}
a882 1

d885 1
a885 1
      && default_common_section == NULL)
d887 2
a888 2
      /* Remember the section that common is going to in case we later
         get something which doesn't know where to put it.  */
d893 3
a895 1
/* Open the output file.  */
d899 1
a899 1
     const char *name;
d921 1
a921 1
  delete_output_file_on_failure = true;
d961 1
a961 1
      if (link_info.traditional_format)
a1204 1
  int len;
d1206 2
a1207 3
  if (output_section_statement != abs_output_section)
    {
      minfo ("\n%s", output_section_statement->name);
a1208 3
      if (section != NULL)
	{
	  print_dot = section->vma;
d1210 26
a1235 11
	  len = strlen (output_section_statement->name);
	  if (len >= SECTION_NAME_MAP_LENGTH - 1)
	    {
	      print_nl ();
	      len = 0;
	    }
	  while (len < SECTION_NAME_MAP_LENGTH)
	    {
	      print_space ();
	      ++len;
	    }
d1237 25
a1261 13
	  minfo ("0x%V %W", section->vma, section->_raw_size);

	  if (output_section_statement->load_base != NULL)
	    {
	      bfd_vma addr;

	      addr = exp_get_abs_int (output_section_statement->load_base, 0,
				      "load base", lang_final_phase_enum);
	      minfo (" load address 0x%V", addr);
	    }
	}

      print_nl ();
d1263 5
a1268 2
  print_statement_list (output_section_statement->children.head,
			output_section_statement);
a1275 1
  int i;
d1278 11
a1288 2
  for (i = 0; i < SECTION_NAME_MAP_LENGTH; i++)
    print_space ();
a1289 2
  result = exp_fold_tree (assignment->exp->assign.src, output_section,
			  lang_final_phase_enum, print_dot, &print_dot);
d1291 3
a1293 1
    minfo ("0x%V", result.value + result.section->bfd_section->vma);
d1296 1
a1296 4
      minfo ("*undef*   ");
#ifdef BFD64
      minfo ("        ");
#endif
d1298 1
a1298 3

  minfo ("                ");

d1301 1
a1301 1
  print_nl ();
d1314 3
a1316 2
/* Print all symbols defined in a particular section.  This is called
   via bfd_link_hash_traverse.  */
d1320 2
a1321 2
     struct bfd_link_hash_entry *hash_entry;
     PTR ptr;
d1323 1
a1323 1
  asection *sec = (asection *) ptr;
d1325 2
a1326 3
  if ((hash_entry->type == bfd_link_hash_defined
       || hash_entry->type == bfd_link_hash_defweak)
      && sec == hash_entry->u.def.section)
d1328 9
a1336 10
      int i;

      for (i = 0; i < SECTION_NAME_MAP_LENGTH; i++)
	print_space ();
      minfo ("0x%V   ",
	     (hash_entry->u.def.value
	      + hash_entry->u.def.section->output_offset
	      + hash_entry->u.def.section->output_section->vma));

      minfo ("             %T\n", hash_entry->root.string);
a1341 2
/* Print information about an input section to the map file.  */

d1351 16
a1366 1
      print_space ();
d1368 1
a1368 1
      minfo ("%s", i->name);
d1370 4
a1373 3
      if (i->output_section != NULL)
	{
	  int len;
d1375 11
a1385 3
	  len = 1 + strlen (i->name);
	  if (len >= SECTION_NAME_MAP_LENGTH - 1)
	    {
d1387 3
a1389 1
	      len = 0;
d1391 1
a1391 1
	  while (len < SECTION_NAME_MAP_LENGTH)
d1393 1
a1393 2
	      print_space ();
	      ++len;
a1395 3
	  minfo ("0x%V %W %B\n",
		 i->output_section->vma + i->output_offset, size,
		 i->owner);
d1397 5
a1401 20
	  if (i->_cooked_size != 0 && i->_cooked_size != i->_raw_size)
	    {
	      len = SECTION_NAME_MAP_LENGTH + 3;
#ifdef BFD64
	      len += 16;
#else
	      len += 8;
#endif
	      while (len > 0)
		{
		  print_space ();
		  --len;
		}

	      minfo ("%W (size before relaxing)\n", i->_raw_size);
	    }

	  bfd_link_hash_traverse (link_info.hash, print_one_symbol, (PTR) i);

	  print_dot = i->output_section->vma + i->output_offset + size;
d1410 2
a1411 1
  fprintf (config.map_file, " FILL mask 0x%x\n", fill->fill);
d1418 6
a1423 11
  int i;
  bfd_vma addr;
  bfd_size_type size;
  const char *name;

  for (i = 0; i < SECTION_NAME_MAP_LENGTH; i++)
    print_space ();

  addr = data->output_vma;
  if (data->output_section != NULL)
    addr += data->output_section->vma;
d1425 4
a1430 2
    default:
      abort ();
d1432 2
a1433 2
      size = BYTE_SIZE;
      name = "BYTE";
d1436 2
a1437 2
      size = SHORT_SIZE;
      name = "SHORT";
d1440 2
a1441 2
      size = LONG_SIZE;
      name = "LONG";
d1444 2
a1445 2
      size = QUAD_SIZE;
      name = "QUAD";
d1449 1
a1449 7
  minfo ("0x%V %W %s 0x%v", addr, size, name, data->value);

  if (data->exp->type.node_class != etree_value)
    {
      print_space ();
      exp_print_tree (data->exp);
    }
d1451 1
a1451 15
  print_nl ();

  print_dot = addr + size;
}

/* Print an address statement.  These are generated by options like
   -Ttext.  */

static void
print_address_statement (address)
     lang_address_statement_type *address;
{
  minfo ("Address of section %s set to ", address->section_name);
  exp_print_tree (address->address);
  print_nl ();
d1460 4
a1463 3
  int i;
  bfd_vma addr;
  bfd_size_type size;
d1465 1
a1465 2
  for (i = 0; i < SECTION_NAME_MAP_LENGTH; i++)
    print_space ();
d1467 4
a1470 3
  addr = reloc->output_vma;
  if (reloc->output_section != NULL)
    addr += reloc->output_section->vma;
d1472 1
a1472 1
  size = bfd_get_reloc_size (reloc->howto);
d1474 1
a1474 6
  minfo ("0x%V %W RELOC %s ", addr, size, reloc->howto->name);

  if (reloc->name != NULL)
    minfo ("%s+", reloc->name);
  else
    minfo ("%s+", reloc->section->name);
d1478 1
a1478 3
  print_nl ();

  print_dot = addr + size;
d1483 1
a1483 1
     lang_padding_statement_type *s;
d1485 10
a1494 4
  int len;
  bfd_vma addr;

  minfo (" *fill*");
d1496 1
a1496 6
  len = sizeof " *fill*" - 1;
  while (len < SECTION_NAME_MAP_LENGTH)
    {
      print_space ();
      ++len;
    }
a1497 11
  addr = s->output_offset;
  if (s->output_section != NULL)
    addr += s->output_section->vma;
  minfo ("0x%V %W", addr, s->size);

  if (s->fill != 0)
    minfo (" 0x%x", s->fill);

  print_nl ();

  print_dot = addr + s->size;
d1505 5
a1509 4
  print_space ();

  if (w->filename != NULL)
    minfo ("%s", w->filename);
d1511 7
a1517 4
    minfo ("*");

  if (w->section_name != NULL)
    minfo ("(%s)", w->section_name);
d1519 3
a1521 2
    minfo ("(*)");

d1523 1
a1524 1
  print_statement_list (w->children.head, os);
d1535 1
a1535 1
  print_statement_list (s->children.head, os);
a1538 18
/* Print the list of statements in S.
   This can be called for any statement type.  */

static void
print_statement_list (s, os)
     lang_statement_union_type *s;
     lang_output_section_statement_type *os;
{
  while (s != NULL)
    {
      print_statement (s, os);
      s = s->next;
    }
}

/* Print the first statement in statement list S.
   This can be called for any statement type.  */

d1541 2
a1542 2
     lang_statement_union_type *s;
     lang_output_section_statement_type *os;
d1544 1
a1544 1
  switch (s->header.type)
d1546 1
a1546 6
    default:
      fprintf (config.map_file, "Fail with %d\n", s->header.type);
      FAIL ();
      break;
    case lang_constructors_statement_enum:
      if (constructor_list.head != NULL)
d1548 56
a1603 2
	  minfo (" CONSTRUCTORS\n");
	  print_statement_list (constructor_list.head, os);
d1605 1
a1605 49
      break;
    case lang_wild_statement_enum:
      print_wild_statement (&s->wild_statement, os);
      break;
    case lang_address_statement_enum:
      print_address_statement (&s->address_statement);
      break;
    case lang_object_symbols_statement_enum:
      minfo (" CREATE_OBJECT_SYMBOLS\n");
      break;
    case lang_fill_statement_enum:
      print_fill_statement (&s->fill_statement);
      break;
    case lang_data_statement_enum:
      print_data_statement (&s->data_statement);
      break;
    case lang_reloc_statement_enum:
      print_reloc_statement (&s->reloc_statement);
      break;
    case lang_input_section_enum:
      print_input_section (&s->input_section);
      break;
    case lang_padding_statement_enum:
      print_padding_statement (&s->padding_statement);
      break;
    case lang_output_section_statement_enum:
      print_output_section_statement (&s->output_section_statement);
      break;
    case lang_assignment_statement_enum:
      print_assignment (&s->assignment_statement, os);
      break;
    case lang_target_statement_enum:
      fprintf (config.map_file, "TARGET(%s)\n", s->target_statement.target);
      break;
    case lang_output_statement_enum:
      minfo ("OUTPUT(%s", s->output_statement.name);
      if (output_target != NULL)
	minfo (" %s", output_target);
      minfo (")\n");
      break;
    case lang_input_statement_enum:
      print_input_statement (&s->input_statement);
      break;
    case lang_group_statement_enum:
      print_group (&s->group_statement, os);
      break;
    case lang_afile_asection_pair_statement_enum:
      FAIL ();
      break;
d1609 1
d1613 2
a1614 14
  print_statement_list (statement_list.head, abs_output_section);
}

/* Print the first N statements in statement list S to STDERR.
   If N == 0, nothing is printed.
   If N < 0, the entire list is printed.
   Intended to be called from GDB.  */

void
dprint_statement (s, n)
     lang_statement_union_type * s;
     int n;
{
  FILE *map_save = config.map_file;
a1615 14
  config.map_file = stderr;

  if (n < 0)
    print_statement_list (s, abs_output_section);
  else
    {
      while (s && --n >= 0)
	{
	  print_statement (s, abs_output_section);
	  s = s->next;
	}
    }

  config.map_file = map_save;
d1828 3
a1830 3
	   if (os->region->current < os->region->origin
	       || (os->region->current - os->region->origin
		   > os->region->length))
d1934 1
a1934 4
	  {
	    if (i->_cooked_size == 0)
	      i->_cooked_size = i->_raw_size;
	  }
a2009 2
     output_section_statement->bfd_section->_raw_size +=
       s->padding_statement.size;
a2191 3
  if (link_info.relocateable)
    return;

d2379 3
a2381 45
    {
      static boolean header_printed;
      int len;
      char *name;
      char buf[50];

      if (! header_printed)
	{
	  minfo ("\nAllocating common symbols\n");
	  minfo ("Common symbol       size              file\n\n");
	  header_printed = true;
	}

      name = demangle (h->root.string);
      minfo ("%s", name);
      len = strlen (name);
      free (name);

      if (len >= 19)
	{
	  print_nl ();
	  len = 0;
	}
      while (len < 20)
	{
	  print_space ();
	  ++len;
	}

      minfo ("0x");
      if (size <= 0xffffffff)
	sprintf (buf, "%lx", (unsigned long) size);
      else
	sprintf_vma (buf, size);
      minfo ("%s", buf);
      len = strlen (buf);

      while (len < 16)
	{
	  print_space ();
	  ++len;
	}

      minfo ("%B\n", section->owner);
    }
a2577 12

  /* Look through the sections and check for any which should not be
     included in the link.  We need to do this now, so that we can
     notice when the backend linker tries to report multiple
     definition errors for symbols which are in sections we aren't
     going to link.  FIXME: It might be better to entirely ignore
     symbols which are defined in sections which are going to be
     discarded.  This would require modifying the backend linker for
     each backend which might set the SEC_LINK_ONCE flag.  If we do
     this, we should probably handle SEC_EXCLUDE in the same way.  */

  bfd_map_over_sections (entry->the_bfd, section_already_linked, (PTR) NULL);
a2727 4
  /* We must record the program headers before we try to fix the
     section positions, since they will affect SIZEOF_HEADERS.  */
  lang_record_phdrs ();

a3116 148
}

/* Add a new program header.  This is called for each entry in a PHDRS
   command in a linker script.  */

void
lang_new_phdr (name, type, filehdr, phdrs, at, flags)
     const char *name;
     etree_type *type;
     boolean filehdr;
     boolean phdrs;
     etree_type *at;
     etree_type *flags;
{
  struct lang_phdr *n, **pp;

  n = (struct lang_phdr *) stat_alloc (sizeof (struct lang_phdr));
  n->next = NULL;
  n->name = name;
  n->type = exp_get_value_int (type, 0, "program header type",
			       lang_final_phase_enum);
  n->filehdr = filehdr;
  n->phdrs = phdrs;
  n->at = at;
  n->flags = flags;

  for (pp = &lang_phdr_list; *pp != NULL; pp = &(*pp)->next)
    ;
  *pp = n;
}

/* Record that a section should be placed in a phdr.  */

void
lang_section_in_phdr (name)
     const char *name;
{
  struct lang_output_section_phdr_list *n;

  n = ((struct lang_output_section_phdr_list *)
       stat_alloc (sizeof (struct lang_output_section_phdr_list)));
  n->name = name;
  n->used = false;
  n->next = current_section->phdrs;
  current_section->phdrs = n;
}

/* Record the program header information in the output BFD.  FIXME: We
   should not be calling an ELF specific function here.  */

static void
lang_record_phdrs ()
{
  unsigned int alc;
  asection **secs;
  struct lang_output_section_phdr_list *last;
  struct lang_phdr *l;
  lang_statement_union_type *u;

  alc = 10;
  secs = xmalloc (alc * sizeof (asection *));
  last = NULL;
  for (l = lang_phdr_list; l != NULL; l = l->next)
    {
      unsigned int c;
      flagword flags;
      bfd_vma at;

      c = 0;
      for (u = lang_output_section_statement.head;
	   u != NULL;
	   u = u->output_section_statement.next)
	{
	  lang_output_section_statement_type *os;
	  struct lang_output_section_phdr_list *pl;

	  os = &u->output_section_statement;

	  pl = os->phdrs;
	  if (pl != NULL)
	    last = pl;
	  else
	    {
	      if (! os->loadable
		  || os->bfd_section == NULL
		  || (os->bfd_section->flags & SEC_ALLOC) == 0)
		continue;
	      pl = last;
	    }

	  if (os->bfd_section == NULL)
	    continue;

	  for (; pl != NULL; pl = pl->next)
	    {
	      if (strcmp (pl->name, l->name) == 0)
		{
		  if (c >= alc)
		    {
		      alc *= 2;
		      secs = xrealloc (secs, alc * sizeof (asection *));
		    }
		  secs[c] = os->bfd_section;
		  ++c;
		  pl->used = true;
		}
	    }
	}

      if (l->flags == NULL)
	flags = 0;
      else
	flags = exp_get_vma (l->flags, 0, "phdr flags",
			     lang_final_phase_enum);

      if (l->at == NULL)
	at = 0;
      else
	at = exp_get_vma (l->at, 0, "phdr load address",
			  lang_final_phase_enum);

      if (! bfd_record_phdr (output_bfd, l->type,
			     l->flags == NULL ? false : true,
			     flags,
			     l->at == NULL ? false : true,
			     at, l->filehdr, l->phdrs, c, secs))
	einfo ("%F%P: bfd_record_phdr failed: %E\n");
    }

  free (secs);

  /* Make sure all the phdr assignments succeeded.  */
  for (u = lang_output_section_statement.head;
       u != NULL;
       u = u->output_section_statement.next)
    {
      struct lang_output_section_phdr_list *pl;

      if (u->output_section_statement.bfd_section == NULL)
	continue;

      for (pl = u->output_section_statement.phdrs;
	   pl != NULL;
	   pl = pl->next)
	if (! pl->used && strcmp (pl->name, "NONE") != 0)
	  einfo ("%X%P: section `%s' assigned to non-existent phdr `%s'\n",
		 u->output_section_statement.name, pl->name);
    }
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d17 2
a18 3
along with GLD; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
a34 3
#include "fnmatch.h"

#include <ctype.h>
a66 1
static void exp_init_os PARAMS ((etree_type *));
a67 1
static boolean wildcardp PARAMS ((const char *));
a74 3
static void wild_file PARAMS ((lang_wild_statement_type *, const char *,
			       lang_input_statement_type *,
			       lang_output_section_statement_type *));
a138 1
struct lang_nocrossrefs *nocrossref_list;
d286 1
d345 1
d493 1
a493 1
      lookup->sectype = normal_section;
d546 3
a548 2
/* Initialize an output section.  */

d551 1
a551 1
     lang_output_section_statement_type *s;
a554 3
  if (s->bfd_section != NULL)
    return;

a574 54

  /* If there is a base address, make sure that any sections it might
     mention are initialized.  */
  if (s->addr_tree != NULL)
    exp_init_os (s->addr_tree);
}

/* Make sure that all output sections mentioned in an expression are
   initialized.  */

static void
exp_init_os (exp)
     etree_type *exp;
{
  switch (exp->type.node_class)
    {
    case etree_assign:
      exp_init_os (exp->assign.src);
      break;

    case etree_binary:
      exp_init_os (exp->binary.lhs);
      exp_init_os (exp->binary.rhs);
      break;

    case etree_trinary:
      exp_init_os (exp->trinary.cond);
      exp_init_os (exp->trinary.lhs);
      exp_init_os (exp->trinary.rhs);
      break;

    case etree_unary:
      exp_init_os (exp->unary.child);
      break;

    case etree_name:
      switch (exp->type.node_code)
	{
	case ADDR:
	case LOADADDR:
	case SIZEOF:
	  {
	    lang_output_section_statement_type *os;

	    os = lang_output_section_find (exp->name.name);
	    if (os != NULL && os->bfd_section == NULL)
	      init_os (os);
	  }
	}
      break;

    default:
      break;
    }
a663 17
/* Return true if the PATTERN argument is a wildcard pattern.  */

static boolean
wildcardp (pattern)
     const char *pattern;
{
  const char *s;

  for (s = pattern; *s != '\0'; ++s)
    if (*s == '?'
	|| *s == '\\'
	|| *s == '*'
	|| *s == '[')
      return true;
  return false;
}

d741 1
a741 1
      switch (output->sectype)
d743 1
a743 9
	case normal_section:
	  break;
	case dsect_section:
	case copy_section:
	case info_section:
	case overlay_section:
	  output->bfd_section->flags &= ~SEC_ALLOC;
	  break;
	case noload_section:
a745 1
	  break;
a769 6
      boolean wildcard;

      if (section == NULL)
	wildcard = false;
      else
	wildcard = wildcardp (section);
a772 2
	  boolean match;

d781 3
a783 13
	  if (section == NULL)
	    match = true;
	  else
	    {
	      const char *name;

	      name = bfd_get_section_name (file->the_bfd, s);
	      if (wildcard)
		match = fnmatch (section, name, 0) == 0 ? true : false;
	      else
		match = strcmp (section, name) == 0 ? true : false;
	    }
	  if (match)
a933 38
/* Handle a wild statement for a single file F.  */

static void
wild_file (s, section, f, output)
     lang_wild_statement_type *s;
     const char *section;
     lang_input_statement_type *f;
     lang_output_section_statement_type *output;
{
  if (f->the_bfd == NULL
      || ! bfd_check_format (f->the_bfd, bfd_archive))
    wild_section (s, section, f, output);
  else
    {
      bfd *member;

      /* This is an archive file.  We must map each member of the
	 archive separately.  */
      member = bfd_openr_next_archived_file (f->the_bfd, (bfd *) NULL);
      while (member != NULL)
	{
	  /* When lookup_name is called, it will call the add_symbols
	     entry point for the archive.  For each element of the
	     archive which is included, BFD will call ldlang_add_file,
	     which will set the usrdata field of the member to the
	     lang_input_statement.  */
	  if (member->usrdata != NULL)
	    {
	      wild_section (s, section,
			    (lang_input_statement_type *) member->usrdata,
			    output);
	    }

	  member = bfd_openr_next_archived_file (f->the_bfd, member);
	}
    }
}

d956 1
a956 11
	  wild_file (s, section, f, output);
	}
    }
  else if (wildcardp (file))
    {
      for (f = (lang_input_statement_type *) file_chain.head;
	   f != (lang_input_statement_type *) NULL;
	   f = (lang_input_statement_type *) f->next)
	{
	  if (fnmatch (file, f->filename, FNM_FILE_NAME) == 0)
	    wild_file (s, section, f, output);
d963 27
a989 1
      wild_file (s, section, f, output);
d1101 1
a1101 2
	  if (s->wild_statement.filename
	      && ! wildcardp (s->wild_statement.filename))
d1281 1
a1287 9
	case lang_assignment_statement_enum:
	  if (output_section_statement != NULL
	      && output_section_statement->bfd_section == NULL)
	    init_os (output_section_statement);

	  /* Make sure that any sections mentioned in the assignment
             are initialized.  */
	  exp_init_os (s->assignment_statement.exp);
	  break;
d1606 1
a1606 1
    minfo (" %u", s->fill);
d1943 1
a1943 1
	   dot = r.value + r.section->bfd_section->vma;
d2621 1
a2621 1
	      else if (strcmp (s->name, "COMMON") == 0)
d2623 3
a2625 3
		  /* This is a lonely common section which must have
		     come from an archive.  We attach to the section
		     with the wildcard.  */
d2627 1
a2627 1
		      || command_line.force_common_definition)
d2629 2
a2630 1
		      if (default_common_section == NULL)
a2631 4
#if 0
			  /* This message happens when using the
                             svr3.ifile linker script, so I have
                             disabled it.  */
d2633 1
a2633 1
#endif
a2826 1

d2829 1
a2829 1
				     address_exp, sectype, block_value,
d2833 1
a2833 1
     enum section_type sectype;
d2858 3
a2860 3
  os->sectype = sectype;
  if (sectype != noload_section)
    os->flags = SEC_NO_FLAGS;
d2862 1
a2862 1
    os->flags = SEC_NEVER_LOAD;
d3201 1
a3201 1
lang_leave_output_section_statement (fill, memspec, phdrs)
d3203 1
a3203 2
     const char *memspec;
     struct lang_output_section_phdr_list *phdrs;
a3206 1
  current_section->phdrs = phdrs;
d3364 16
d3393 1
a3393 1
  secs = (asection **) xmalloc (alc * sizeof (asection *));
d3416 1
a3416 1
	      if (os->sectype == noload_section
d3433 1
a3433 2
		      secs = ((asection **)
			      xrealloc (secs, alc * sizeof (asection *)));
a3480 202
}

/* Record a list of sections which may not be cross referenced.  */

void
lang_add_nocrossref (l)
     struct lang_nocrossref *l;
{
  struct lang_nocrossrefs *n;

  n = (struct lang_nocrossrefs *) xmalloc (sizeof *n);
  n->next = nocrossref_list;
  n->list = l;
  nocrossref_list = n;

  /* Set notice_all so that we get informed about all symbols.  */
  link_info.notice_all = true;
}

/* Overlay handling.  We handle overlays with some static variables.  */

/* The overlay virtual address.  */
static etree_type *overlay_vma;

/* The overlay load address.  */
static etree_type *overlay_lma;

/* Whether nocrossrefs is set for this overlay.  */
static int overlay_nocrossrefs;

/* An expression for the maximum section size seen so far.  */
static etree_type *overlay_max;

/* A list of all the sections in this overlay.  */

struct overlay_list
{
  struct overlay_list *next;
  lang_output_section_statement_type *os;
};

static struct overlay_list *overlay_list;

/* Start handling an overlay.  */

void
lang_enter_overlay (vma_expr, lma_expr, nocrossrefs)
     etree_type *vma_expr;
     etree_type *lma_expr;
     int nocrossrefs;
{
  /* The grammar should prevent nested overlays from occurring.  */
  ASSERT (overlay_vma == NULL
	  && overlay_lma == NULL
	  && overlay_list == NULL
	  && overlay_max == NULL);

  overlay_vma = vma_expr;
  overlay_lma = lma_expr;
  overlay_nocrossrefs = nocrossrefs;
}

/* Start a section in an overlay.  We handle this by calling
   lang_enter_output_section_statement with the correct VMA and LMA.  */

void
lang_enter_overlay_section (name)
     const char *name;
{
  struct overlay_list *n;
  etree_type *size;

  lang_enter_output_section_statement (name, overlay_vma, normal_section,
				       0, 0, 0, overlay_lma);

  /* If this is the first section, then base the VMA and LMA of future
     sections on this one.  This will work correctly even if `.' is
     used in the addresses.  */
  if (overlay_list == NULL)
    {
      overlay_vma = exp_nameop (ADDR, name);
      overlay_lma = exp_nameop (LOADADDR, name);
    }

  /* Remember the section.  */
  n = (struct overlay_list *) xmalloc (sizeof *n);
  n->os = current_section;
  n->next = overlay_list;
  overlay_list = n;

  size = exp_nameop (SIZEOF, name);

  /* Adjust the LMA for the next section.  */
  overlay_lma = exp_binop ('+', overlay_lma, size);

  /* Arrange to work out the maximum section end address.  */
  if (overlay_max == NULL)
    overlay_max = size;
  else
    overlay_max = exp_binop (MAX, overlay_max, size);
}

/* Finish a section in an overlay.  There isn't any special to do
   here.  */

void
lang_leave_overlay_section (fill, phdrs)
     bfd_vma fill;
     struct lang_output_section_phdr_list *phdrs;
{
  const char *name;
  char *clean, *s2;
  const char *s1;
  char *buf;

  name = current_section->name;

  lang_leave_output_section_statement (fill, "*default*", phdrs);

  /* Define the magic symbols.  */

  clean = xmalloc (strlen (name) + 1);
  s2 = clean;
  for (s1 = name; *s1 != '\0'; s1++)
    if (isalnum (*s1) || *s1 == '_')
      *s2++ = *s1;
  *s2 = '\0';

  buf = xmalloc (strlen (clean) + sizeof "__load_start_");
  sprintf (buf, "__load_start_%s", clean);
  lang_add_assignment (exp_assop ('=', buf,
				  exp_nameop (LOADADDR, name)));

  buf = xmalloc (strlen (clean) + sizeof "__load_stop_");
  sprintf (buf, "__load_stop_%s", clean);
  lang_add_assignment (exp_assop ('=', buf,
				  exp_binop ('+',
					     exp_nameop (LOADADDR, name),
					     exp_nameop (SIZEOF, name))));

  free (clean);
}

/* Finish an overlay.  If there are any overlay wide settings, this
   looks through all the sections in the overlay and sets them.  */

void
lang_leave_overlay (fill, memspec, phdrs)
     bfd_vma fill;
     const char *memspec;
     struct lang_output_section_phdr_list *phdrs;
{
  lang_memory_region_type *region;
  struct overlay_list *l;
  struct lang_nocrossref *nocrossref;

  if (memspec == NULL)
    region = NULL;
  else
    region = lang_memory_region_lookup (memspec);

  nocrossref = NULL;

  l = overlay_list;
  while (l != NULL)
    {
      struct overlay_list *next;

      if (fill != 0 && l->os->fill == 0)
	l->os->fill = fill;
      if (region != NULL && l->os->region == NULL)
	l->os->region = region;
      if (phdrs != NULL && l->os->phdrs == NULL)
	l->os->phdrs = phdrs;

      if (overlay_nocrossrefs)
	{
	  struct lang_nocrossref *nc;

	  nc = (struct lang_nocrossref *) xmalloc (sizeof *nc);
	  nc->name = l->os->name;
	  nc->next = nocrossref;
	  nocrossref = nc;
	}

      next = l->next;
      free (l);
      l = next;
    }

  if (nocrossref != NULL)
    lang_add_nocrossref (nocrossref);

  /* Update . for the end of the overlay.  */
  lang_add_assignment (exp_assop ('=', ".",
				  exp_binop ('+', overlay_vma, overlay_max)));

  overlay_vma = NULL;
  overlay_lma = NULL;
  overlay_nocrossrefs = 0;
  overlay_list = NULL;
  overlay_max = NULL;
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d650 1
a650 1
section_already_linked (abfd, sec, data)
d653 1
a653 1
     PTR data;
a654 1
  lang_input_statement_type *entry = (lang_input_statement_type *) data;
a664 8
  /* If we are only reading symbols from this object, then we want to
     discard all sections.  */
  if (entry->just_syms_flag)
    {
      sec->output_section = bfd_abs_section_ptr;
      return;
    }

d2067 1
a2067 9
	     {
	       bfd_vma olddot;

	       olddot = dot;
	       dot = align_power (dot, os->bfd_section->alignment_power);
	       if (dot != olddot && config.warn_section_align)
		 einfo ("%P: warning: changing start of section %s by %u bytes\n",
			os->name, (unsigned int) (dot - olddot));
	     }
d2931 1
a2931 1
  bfd_map_over_sections (entry->the_bfd, section_already_linked, (PTR) entry);
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
a23 1
#include "obstack.h"
a103 1
static boolean print_one_symbol PARAMS ((struct bfd_link_hash_entry *, PTR));
a670 1
      sec->output_offset = sec->vma;
d2689 1
a2689 2
  /* Make sure the section is allocated in memory, and make sure that
     it is no longer a common section.  */
a2690 1
  section->flags &= ~ SEC_IS_COMMON;
a3080 7
  /* Make sure that we're not mixing architectures.  We call this
     after all the input files have been opened, but before we do any
     other processing, so that any operations merge_private_bfd_data
     does on the output file will be known during the rest of the
     link.  */
  lang_check ();

d3088 1
a3088 1
  /* Run through the contours of the script and attach input sections
d3095 1
a3095 1
  /* Find any sections not attached explicitly and handle them */
d3156 4
a3829 140
}

/* Version handling.  This is only useful for ELF.  */

/* This global variable holds the version tree that we build.  */

struct bfd_elf_version_tree *lang_elf_version_info;

/* This is called for each variable name or match expression.  */

struct bfd_elf_version_expr *
lang_new_vers_regex (orig, new)
     struct bfd_elf_version_expr *orig;
     const char *new;
{
  struct bfd_elf_version_expr *ret;

  ret = (struct bfd_elf_version_expr *) xmalloc (sizeof *ret);
  ret->next = orig;
  ret->match = new;
  return ret;
}

/* This is called for each set of variable names and match
   expressions.  */

struct bfd_elf_version_tree *
lang_new_vers_node (globals, locals)
     struct bfd_elf_version_expr *globals;
     struct bfd_elf_version_expr *locals;
{
  struct bfd_elf_version_tree *ret;

  ret = (struct bfd_elf_version_tree *) xmalloc (sizeof *ret);
  ret->next = NULL;
  ret->name = NULL;
  ret->vernum = 0;
  ret->globals = globals;
  ret->locals = locals;
  ret->deps = NULL;
  ret->name_indx = (unsigned int) -1;
  ret->used = 0;
  return ret;
}

/* This static variable keeps track of version indices.  */

static int version_index;

/* This is called when we know the name and dependencies of the
   version.  */

void
lang_register_vers_node (name, version, deps)
     const char *name;
     struct bfd_elf_version_tree *version;
     struct bfd_elf_version_deps *deps;
{
  struct bfd_elf_version_tree *t, **pp;
  struct bfd_elf_version_expr *e1;

  /* Make sure this node has a unique name.  */
  for (t = lang_elf_version_info; t != NULL; t = t->next)
    if (strcmp (t->name, name) == 0)
      einfo ("%X%P: duplicate version tag `%s'\n", name);

  /* Check the global and local match names, and make sure there
     aren't any duplicates.  */

  for (e1 = version->globals; e1 != NULL; e1 = e1->next)
    {
      for (t = lang_elf_version_info; t != NULL; t = t->next)
	{
	  struct bfd_elf_version_expr *e2;

	  for (e2 = t->globals; e2 != NULL; e2 = e2->next)
	    if (strcmp (e1->match, e2->match) == 0)
	      einfo ("%X%P: duplicate expression `%s' in version information\n",
		     e1->match);

	  for (e2 = t->locals; e2 != NULL; e2 = e2->next)
	    if (strcmp (e1->match, e2->match) == 0)
	      einfo ("%X%P: duplicate expression `%s' in version information\n",
		     e1->match);
	}
    }

  for (e1 = version->locals; e1 != NULL; e1 = e1->next)
    {
      for (t = lang_elf_version_info; t != NULL; t = t->next)
	{
	  struct bfd_elf_version_expr *e2;

	  for (e2 = t->globals; e2 != NULL; e2 = e2->next)
	    if (strcmp (e1->match, e2->match) == 0)
	      einfo ("%X%P: duplicate expression `%s' in version information\n",
		     e1->match);

	  for (e2 = t->locals; e2 != NULL; e2 = e2->next)
	    if (strcmp (e1->match, e2->match) == 0)
	      einfo ("%X%P: duplicate expression `%s' in version information\n",
		     e1->match);
	}
    }

  version->deps = deps;
  version->name = name;
  ++version_index;
  version->vernum = version_index;

  for (pp = &lang_elf_version_info; *pp != NULL; pp = &(*pp)->next)
    ;
  *pp = version;
}

/* This is called when we see a version dependency.  */

struct bfd_elf_version_deps *
lang_add_vers_depend (list, name)
     struct bfd_elf_version_deps *list;
     const char *name;
{
  struct bfd_elf_version_deps *ret;
  struct bfd_elf_version_tree *t;

  ret = (struct bfd_elf_version_deps *) xmalloc (sizeof *ret);
  ret->next = list;

  for (t = lang_elf_version_info; t != NULL; t = t->next)
    {
      if (strcmp (t->name, name) == 0)
	{
	  ret->version_needed = t;
	  return ret;
	}
    }

  einfo ("%X%P: unable to find version dependency `%s'\n", name);

  return ret;
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
d8 1
a8 1
the Free Software Foundation; either version 2, or (at your option)
a37 1
#include "demangle.h"
a73 5
static struct bfd_hash_entry *already_linked_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
	   const char *string));
static void already_linked_table_init PARAMS ((void));
static void already_linked_table_free PARAMS ((void));
d75 4
a78 3
static lang_statement_union_type *wild_sort
  PARAMS ((lang_wild_statement_type *, lang_input_statement_type *,
	   asection *));
d82 3
a130 1
static void ignore_bfd_errors PARAMS ((const char *, ...));
d139 1
a139 24
static void lang_gc_wild
  PARAMS ((lang_wild_statement_type *, const char *, const char *));
static void lang_gc_sections_1 PARAMS ((lang_statement_union_type *));
static void lang_gc_sections PARAMS ((void));
static void lang_do_version_exports_section PARAMS ((void));
static void lang_check_section_addresses PARAMS ((void));

typedef void (*callback_t) PARAMS ((lang_wild_statement_type *,
				    asection *, lang_input_statement_type *,
				    void *));
static void walk_wild_section
  PARAMS ((lang_wild_statement_type *, const char *,
	   lang_input_statement_type *, callback_t, void *));
static void walk_wild_file
  PARAMS ((lang_wild_statement_type *, const char *,
	   lang_input_statement_type *, callback_t, void *));

static int    get_target PARAMS ((const bfd_target *, void *));
static void   stricpy PARAMS ((char *, char *));
static void   strcut PARAMS ((char *, char *));
static int    name_compare PARAMS ((char *, char *));
static int    closest_target_match PARAMS ((const bfd_target *, void *));
static char * get_first_input_target PARAMS ((void));
					
d143 1
a143 1
lang_statement_list_type file_chain = { NULL, NULL };
a176 136
  Generic traversal routines for finding matching sections.
*/

static void
walk_wild_section (ptr, section, file, callback, data)
     lang_wild_statement_type *ptr;
     const char *section;
     lang_input_statement_type *file;
     callback_t callback;
     void *data;
{
  /* Don't process sections from files which were excluded. */
  if (ptr->exclude_filename_list != NULL)
    {
      struct name_list *list_tmp;
      for (list_tmp = ptr->exclude_filename_list; list_tmp; list_tmp = list_tmp->next)
        {
	  boolean match;

	  if (wildcardp (list_tmp->name))
	    match = fnmatch (list_tmp->name, file->filename, 0) == 0 ? true : false;
	  else
	    match = strcmp (list_tmp->name, file->filename) == 0 ? true : false;

	  if (match)
	    return;
	}
    }

  if (file->just_syms_flag == false)
    {
      register asection *s;
      boolean wildcard;

      if (section == NULL)
	wildcard = false;
      else
	wildcard = wildcardp (section);

      for (s = file->the_bfd->sections; s != NULL; s = s->next)
	{
	  boolean match;

	  if (section == NULL)
	    match = true;
	  else
	    {
	      const char *name;

	      name = bfd_get_section_name (file->the_bfd, s);
	      if (wildcard)
		match = fnmatch (section, name, 0) == 0 ? true : false;
	      else
		match = strcmp (section, name) == 0 ? true : false;
	    }

	  if (match)
	    (*callback) (ptr, s, file, data);
	}
    }
}

/* Handle a wild statement for a single file F.  */

static void
walk_wild_file (s, section, f, callback, data)
     lang_wild_statement_type *s;
     const char *section;
     lang_input_statement_type *f;
     callback_t callback;
     void *data;
{
  if (f->the_bfd == NULL
      || ! bfd_check_format (f->the_bfd, bfd_archive))
    walk_wild_section (s, section, f, callback, data);
  else
    {
      bfd *member;

      /* This is an archive file.  We must map each member of the
	 archive separately.  */
      member = bfd_openr_next_archived_file (f->the_bfd, (bfd *) NULL);
      while (member != NULL)
	{
	  /* When lookup_name is called, it will call the add_symbols
	     entry point for the archive.  For each element of the
	     archive which is included, BFD will call ldlang_add_file,
	     which will set the usrdata field of the member to the
	     lang_input_statement.  */
	  if (member->usrdata != NULL)
	    {
	      walk_wild_section (s, section,
				 (lang_input_statement_type *) member->usrdata,
				 callback, data);
	    }

	  member = bfd_openr_next_archived_file (f->the_bfd, member);
	}
    }
}

static void
walk_wild (s, section, file, callback, data)
     lang_wild_statement_type *s;
     const char *section;
     const char *file;
     callback_t callback;
     void *data;
{
  if (file == (char *) NULL)
    {
      /* Perform the iteration over all files in the list.  */
      LANG_FOR_EACH_INPUT_STATEMENT (f)
	{
	  walk_wild_file (s, section, f, callback, data);
	}
    }
  else if (wildcardp (file))
    {
      LANG_FOR_EACH_INPUT_STATEMENT (f)
	{
	  if (fnmatch (file, f->filename, FNM_FILE_NAME) == 0)
	    walk_wild_file (s, section, f, callback, data);
	}
    }
  else
    {
      lang_input_statement_type *f;

      /* Perform the iteration over a single file.  */
      f = lookup_name (file);
      walk_wild_file (s, section, f, callback, data);
    }
}  
     
/*----------------------------------------------------------------------
d415 2
a416 1
  lang_memory_region_type *p;
a453 2
    new->flags = 0;
    new->not_flags = 0;
a462 25
lang_memory_region_type *
lang_memory_default (section)
     asection *section;
{
  lang_memory_region_type *p;

  flagword sec_flags = section->flags;

  /* Override SEC_DATA to mean a writable section.  */
  if ((sec_flags & (SEC_ALLOC | SEC_READONLY | SEC_CODE)) == SEC_ALLOC)
    sec_flags |= SEC_DATA;

  for (p = lang_memory_region_list;
       p != (lang_memory_region_type *) NULL;
       p = p->next)
    {
      if ((p->flags & sec_flags) != 0
	  && (p->not_flags & sec_flags) == 0)
	{
	  return p;
	}
    }
  return lang_memory_region_lookup ("*default*");
}

a495 1
      lookup->lma_region = (lang_memory_region_type *) NULL;
a520 20
static void
lang_map_flags (flag)
     flagword flag;
{
  if (flag & SEC_ALLOC)
    minfo ("a");

  if (flag & SEC_CODE)
    minfo ("x");

  if (flag & SEC_READONLY)
    minfo ("r");

  if (flag & SEC_DATA)
    minfo ("w");

  if (flag & SEC_LOAD)
    minfo ("l");
}

d526 3
a528 3
  minfo (_("\nMemory Configuration\n\n"));
  fprintf (config.map_file, "%-16s %-18s %-18s %s\n",
	   _("Name"), _("Origin"), _("Length"), _("Attributes"));
d548 1
a548 20
      minfo ("0x%V", m->length);
      if (m->flags || m->not_flags)
	{
#ifndef BFD64
	  minfo ("        ");
#endif
	  if (m->flags)
	    {
	      print_space ();
	      lang_map_flags (m->flags);
	    }

	  if (m->not_flags)
	    {
	      minfo (" !");
	      lang_map_flags (m->not_flags);
	    }
	}

      print_nl ();
d551 1
a551 1
  fprintf (config.map_file, _("\nLinker script and memory map\n\n"));
d568 1
a568 1
    einfo (_("%P%F: Illegal use of `%s' section"), DISCARD_SECTION_NAME);
d578 1
a578 1
      einfo (_("%P%F: output format %s cannot represent section called %s\n"),
d642 1
a642 1

d644 5
a648 28
   once into the output.  This routine checks each section, and
   arrange to discard it if a section of the same name has already
   been linked.  If the section has COMDAT information, then it uses
   that to decide whether the section should be included.  This code
   assumes that all relevant sections have the SEC_LINK_ONCE flag set;
   that is, it does not depend solely upon the section name.
   section_already_linked is called via bfd_map_over_sections.  */

/* This is the shape of the elements inside the already_linked hash
   table. It maps a name onto a list of already_linked elements with
   the same name.  It's possible to get more than one element in a
   list if the COMDAT sections have different names.  */

struct already_linked_hash_entry 
{
  struct bfd_hash_entry root;
  struct already_linked *entry;
};

struct already_linked 
{
  struct already_linked *next;
  asection *sec;
};

/* The hash table.  */

static struct bfd_hash_table already_linked_table;
d658 6
d666 1
a666 2
  struct already_linked *l;
  struct already_linked_hash_entry *already_linked_list;
a681 17
  /* FIXME: When doing a relocateable link, we may have trouble
     copying relocations in other sections that refer to local symbols
     in the section being discarded.  Those relocations will have to
     be converted somehow; as of this writing I'm not sure that any of
     the backends handle that correctly.

     It is tempting to instead not discard link once sections when
     doing a relocateable link (technically, they should be discarded
     whenever we are building constructors).  However, that fails,
     because the linker winds up combining all the link once sections
     into a single large link once section, which defeats the purpose
     of having link once sections in the first place.

     Also, not merging link once sections in a relocateable link
     causes trouble for MIPS ELF, which relies in link once semantics
     to handle the .reginfo section correctly.  */

d684 3
a686 9
  already_linked_list = 
    ((struct already_linked_hash_entry *)
     bfd_hash_lookup (&already_linked_table, name, true, false));

  for (l = already_linked_list->entry;  l != NULL; l = l->next)
    {
      if (sec->comdat == NULL
	  || l->sec->comdat == NULL
	  || strcmp (sec->comdat->name, l->sec->comdat->name) == 0)
d699 2
a700 6
	      if (sec->comdat == NULL)
		einfo (_("%P: %B: warning: ignoring duplicate section `%s'\n"),
		       abfd, name);
	      else
		einfo (_("%P: %B: warning: ignoring duplicate `%s' section symbol `%s'\n"),
		       abfd, name, sec->comdat->name);
d713 1
a713 1
		einfo (_("%P: %B: warning: duplicate section `%s' has different size\n"),
d719 1
a719 4
	     create a lang_input_section structure for this section.
	     Since there might be a symbol in the section being
	     discarded, we must retain a pointer to the section which
	     we are really going to use.  */
a720 2
	  if (sec->comdat != NULL)
	    sec->comdat->sec = l->sec;
d726 1
a726 5
  /* This is the first section with this name.  Record it.  Allocate
     the memory from the same obstack as the hash table is kept in.  */

  l = ((struct already_linked *) 
       bfd_hash_allocate (&already_linked_table, sizeof *l));
d728 1
d730 2
a731 34
  l->next = already_linked_list->entry;
  already_linked_list->entry = l;
}

/* Support routines for the hash table used by section_already_linked,
   initialize the table, fill in an entry and remove the table.  */

static struct bfd_hash_entry *
already_linked_newfunc (entry, table, string)
     struct bfd_hash_entry *entry ATTRIBUTE_UNUSED;
     struct bfd_hash_table *table;
     const char *string ATTRIBUTE_UNUSED;
{
  struct already_linked_hash_entry *ret = 
    bfd_hash_allocate (table, sizeof (struct already_linked_hash_entry));

  ret->entry = NULL;

  return (struct bfd_hash_entry *) ret;
}

static void
already_linked_table_init ()
{
  if (! bfd_hash_table_init_n (&already_linked_table,
			       already_linked_newfunc,
			       42))
    einfo (_("%P%F: Failed to create hash table\n"));
}

static void
already_linked_table_free ()
{
  bfd_hash_table_free (&already_linked_table);
d740 1
a740 5
/* Return true if the PATTERN argument is a wildcard pattern.
   Although backslashes are treated specially if a pattern contains
   wildcards, we do not consider the mere presence of a backslash to
   be enough to cause the the pattern to be treated as a wildcard.
   That lets us handle DOS filenames more naturally.  */
d750 1
a803 1
      boolean first;
a804 1
      flagword flags;
d807 1
a807 6
	{
	  init_os (output);
	  first = true;
	}
      else
	first = false;
a815 2
      flags = section->flags;

d821 1
a821 18
	 the embedded SEC_NEVER_LOAD section into a fill.  */

      flags &= ~ SEC_NEVER_LOAD;

      /* If final link, don't copy the SEC_LINK_ONCE flags, they've
	 already been processed.  One reason to do this is that on pe
	 format targets, .text$foo sections go into .text and it's odd
	 to see .text with SEC_LINK_ONCE set.  */

      if (! link_info.relocateable)
	flags &= ~ (SEC_LINK_ONCE | SEC_LINK_DUPLICATES);

      /* If this is not the first input section, and the SEC_READONLY
         flag is not currently set, then don't set it just because the
         input section has it set.  */

      if (! first && (section->output_section->flags & SEC_READONLY) == 0)
	flags &= ~ SEC_READONLY;
d823 10
a832 6
      section->output_section->flags |= flags;

      /* If SEC_READONLY is not set in the input section, then clear
         it from the output section.  */
      if ((section->flags & SEC_READONLY) == 0)
	section->output_section->flags &= ~SEC_READONLY;
a849 4
      /* Copy over SEC_SMALL_DATA.  */
      if (section->flags & SEC_SMALL_DATA)
	section->output_section->flags |= SEC_SMALL_DATA;

d859 7
a865 8
/* Handle wildcard sorting.  This returns the lang_input_section which
   should follow the one we are going to create for SECTION and FILE,
   based on the sorting requirements of WILD.  It returns NULL if the
   new section should just go at the end of the current list.  */

static lang_statement_union_type *
wild_sort (wild, file, section)
     lang_wild_statement_type *wild;
d867 1
a867 1
     asection *section;
d869 1
a869 8
  const char *section_name;
  lang_statement_union_type *l;

  if (! wild->filenames_sorted && ! wild->sections_sorted)
    return NULL;

  section_name = bfd_get_section_name (file->the_bfd, section);
  for (l = wild->children.head; l != NULL; l = l->next)
d871 2
a872 1
      lang_input_section_type *ls;
d874 4
a877 3
      if (l->header.type != lang_input_section_enum)
	continue;
      ls = &l->input_section;
d879 1
a879 4
      /* Sorting by filename takes precedence over sorting by section
         name.  */

      if (wild->filenames_sorted)
d881 1
a881 3
	  const char *fn, *ln;
	  boolean fa, la;
	  int i;
d883 2
a884 4
	  /* The PE support for the .idata section as generated by
             dlltool assumes that files will be sorted by the name of
             the archive and then the name of the file within the
             archive.  */
d886 4
a889 11
	  if (file->the_bfd != NULL
	      && bfd_my_archive (file->the_bfd) != NULL)
	    {
	      fn = bfd_get_filename (bfd_my_archive (file->the_bfd));
	      fa = true;
	    }
	  else
	    {
	      fn = file->filename;
	      fa = false;
	    }
d891 2
a892 6
	  if (ls->ifile->the_bfd != NULL
	      && bfd_my_archive (ls->ifile->the_bfd) != NULL)
	    {
	      ln = bfd_get_filename (bfd_my_archive (ls->ifile->the_bfd));
	      la = true;
	    }
d895 1
a895 3
	      ln = ls->ifile->filename;
	      la = false;
	    }
d897 5
a901 18
	  i = strcmp (fn, ln);
	  if (i > 0)
	    continue;
	  else if (i < 0)
	    break;

	  if (fa || la)
	    {
	      if (fa)
		fn = file->filename;
	      if (la)
		ln = ls->ifile->filename;

	      i = strcmp (fn, ln);
	      if (i > 0)
		continue;
	      else if (i < 0)
		break;
d903 2
a904 69
	}

      /* Here either the files are not sorted by name, or we are
         looking at the sections for this file.  */

      if (wild->sections_sorted)
	{
	  if (strcmp (section_name,
		      bfd_get_section_name (ls->ifile->the_bfd,
					    ls->section))
	      < 0)
	    break;
	}
    }

  return l;
}

/* Expand a wild statement for a particular FILE.  SECTION may be
   NULL, in which case it is a wild card.  */

static void
output_section_callback (ptr, section, file, output)
     lang_wild_statement_type *ptr;
     asection *section;
     lang_input_statement_type *file;
     void *output;
{
  lang_statement_union_type *before;
  
  /* If the wild pattern was marked KEEP, the member sections
     should be as well.  */
  if (ptr->keep_sections)
    section->flags |= SEC_KEEP;
  
  before = wild_sort (ptr, file, section);
  
  /* Here BEFORE points to the lang_input_section which
     should follow the one we are about to add.  If BEFORE
     is NULL, then the section should just go at the end
     of the current list.  */
  
  if (before == NULL)
    wild_doit (&ptr->children, section, 
	       (lang_output_section_statement_type *) output, 
	       file);
  else
    {
      lang_statement_list_type list;
      lang_statement_union_type **pp;
      
      lang_list_init (&list);
      wild_doit (&list, section, 
		 (lang_output_section_statement_type *) output, 
		 file);
      
      /* If we are discarding the section, LIST.HEAD will
	 be NULL.  */
      if (list.head != NULL)
	{
	  ASSERT (list.head->next == NULL);
	  
	  for (pp = &ptr->children.head;
	       *pp != before;
	       pp = &(*pp)->next)
	    ASSERT (*pp != NULL);
	  
	  list.head->next = *pp;
	  *pp = list.head;
d973 2
a974 2
	  einfo (_("%B: file not recognized: %E\n"), entry->the_bfd);
	  einfo (_("%B: matching formats:"), entry->the_bfd);
d981 1
a981 1
	einfo (_("%F%B: file not recognized: %E\n"), entry->the_bfd);
a1007 3
  if (ldemul_recognized_file (entry))
    return;

d1031 1
a1031 1
		einfo (_("%F%B: object %B in archive is not object\n"),
d1037 1
a1037 1
		einfo (_("%F%B: could not read symbols: %E\n"), member);
d1049 1
a1049 1
    einfo (_("%F%B: could not read symbols: %E\n"), entry->the_bfd);
d1054 37
a1090 1
     
d1102 1
a1102 1
     const char *target ATTRIBUTE_UNUSED;
d1105 1
a1105 1
  walk_wild (s, section, file, output_section_callback, (void *) output);
d1107 1
a1107 3
  if (section != (char *) NULL
      && strcmp (section, "COMMON") == 0
      && default_common_section == NULL)
d1109 7
a1115 3
      /* Remember the section that common is going to in case we later
         get something which doesn't know where to put it.  */
      default_common_section = output;
d1117 1
a1117 22
}

/* Return true iff target is the sought target.  */
static int
get_target (target, data)
     const bfd_target * target;
     void * data;
{
  const char * sought = (const char *) data;
  
  return strcmp (target->name, sought) == 0;
}

/* Like strcpy() but convert to lower case as well.  */
static void
stricpy (dest, src)
     char * dest;
     char * src;
{
  char c;
  
  while ((c = * src ++) != 0)
d1119 7
a1125 4
      if (isupper ((unsigned char) c))
	c = tolower (c);

      * dest ++ = c;
d1127 1
a1127 14

  * dest = 0;
}

/* Remove the first occurance of needle (if any) in haystack
   from haystack.  */
static void
strcut (haystack, needle)
     char * haystack;
     char * needle;
{
  haystack = strstr (haystack, needle);
  
  if (haystack)
d1129 3
a1131 6
      char * src;

      for (src = haystack + strlen (needle); * src;)
	* haystack ++ = * src ++;
      
      * haystack = 0;
a1132 1
}
d1134 3
a1136 65
/* Compare two target format name strings.
   Return a value indicating how "similar" they are.  */
static int
name_compare (first, second)
     char * first;
     char * second;
{
  char * copy1;
  char * copy2;
  int    result;
  
  copy1 = xmalloc (strlen (first) + 1);
  copy2 = xmalloc (strlen (second) + 1);

  /* Convert the names to lower case.  */
  stricpy (copy1, first);
  stricpy (copy2, second);

  /* Remove and endian strings from the name.  */
  strcut (copy1, "big");
  strcut (copy1, "little");
  strcut (copy2, "big");
  strcut (copy2, "little");

  /* Return a value based on how many characters match,
     starting from the beginning.   If both strings are
     the same then return 10 * their length.  */
  for (result = 0; copy1 [result] == copy2 [result]; result ++)
    if (copy1 [result] == 0)
      {
	result *= 10;
	break;
      }
  
  free (copy1);
  free (copy2);

  return result;
}

/* Set by closest_target_match() below.  */
static const bfd_target * winner;

/* Scan all the valid bfd targets looking for one that has the endianness
   requirement that was specified on the command line, and is the nearest
   match to the original output target.  */
static int
closest_target_match (target, data)
     const bfd_target * target;
     void * data;
{
  const bfd_target * original = (const bfd_target *) data;
  
  if (command_line.endian == ENDIAN_BIG && target->byteorder != BFD_ENDIAN_BIG)
    return 0;
  
  if (command_line.endian == ENDIAN_LITTLE && target->byteorder != BFD_ENDIAN_LITTLE)
    return 0;

  /* Must be the same flavour.  */
  if (target->flavour != original->flavour)
    return 0;

  /* If we have not found a potential winner yet, then record this one.  */
  if (winner == NULL)
d1138 3
a1140 35
      winner = target;
      return 0;
    }

  /* Oh dear, we now have two potential candidates for a successful match.
     Compare their names and choose the better one. */
  if (name_compare (target->name, original->name) > name_compare (winner->name, original->name))
    winner = target;

  /* Keep on searching until wqe have checked them all.  */
  return 0;
}

/* Return the BFD target format of the first input file.  */
static char *
get_first_input_target ()
{
  char * target = NULL;

  LANG_FOR_EACH_INPUT_STATEMENT (s)
    {
      if (s->header.type == lang_input_statement_enum
	  && s->real)
	{
	  ldfile_open_file (s);
	  
	  if (s->the_bfd != NULL
	      && bfd_check_format (s->the_bfd, bfd_object))
	    {
	      target = bfd_get_target (s->the_bfd);
	  
	      if (target != NULL)
		break;
	    }
	}
a1141 2
  
  return target;
d1148 1
a1148 1
     const char * name;
d1150 1
a1150 1
  bfd * output;
a1151 1
  /* Has the user told us which output format to use ?  */
d1154 1
a1154 2
      /* No - has the current target been set to something other than the default ?  */
      if (current_target != default_target)
a1155 23

      /* No - can we determine the format of the first input file ? */
      else
	{
	  output_target = get_first_input_target ();

	  /* Failed - use the default output target.  */
	  if (output_target == NULL)
	    output_target = default_target;
	}
    }
  
  /* Has the user requested a particular endianness on the command line ?  */
  if (command_line.endian != ENDIAN_UNSET)
    {
      const bfd_target * target;
      enum bfd_endian desired_endian;

      /* Get the chosen target.  */
      target = bfd_search_for_target (get_target, (void *) output_target);

      if (command_line.endian == ENDIAN_BIG)
	desired_endian = BFD_ENDIAN_BIG;
d1157 1
a1157 25
	desired_endian = BFD_ENDIAN_LITTLE;
      
      /* See if the target has the wrong endianness.  This should not happen
	 if the linker script has provided big and little endian alternatives,
	 but some scrips don't do this.  */
      if (target->byteorder != desired_endian)
	{
	  /* If it does, then see if the target provides
	     an alternative with the correct endianness.  */
	  if (target->alternative_target != NULL
	      && (target->alternative_target->byteorder == desired_endian))
	    output_target = target->alternative_target->name;
	  else
	    {
	      /* Try to find a target as similar as possible to the default
		 target, but which has the desired endian characteristic.  */
	      (void) bfd_search_for_target (closest_target_match, (void *) target);
	      
	      /* Oh dear - we could not find any targets that satisfy our requirements.  */
	      if (winner == NULL)
		einfo (_("%P: warning: could not find any targets that match endianness requirement\n"));
	      else
		output_target = winner->name;
	    }
	}
a1158 1
      
d1164 4
a1167 3
	einfo (_("%P%F: target %s not found\n"), output_target);

      einfo (_("%P%F: cannot open output file %s: %E\n"), name);
d1175 1
a1175 1
    einfo (_("%P%F:%s: can not make object file: %E\n"), name);
d1179 1
a1179 1
    einfo (_("%P%F:%s: can not set architecture: %E\n"), name);
d1183 1
a1183 1
    einfo (_("%P%F: can not create link hash table: %E\n"));
d1189 3
d1268 1
a1268 1
	  if (s->input_statement.real)
d1370 1
a1370 1
	einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
d1493 1
a1493 1
	      minfo (_(" load address 0x%V"), addr);
d1517 1
a1517 1
  if (result.valid_p)
d1581 1
a1581 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine);
d1605 1
a1605 1
		 i->output_section->vma + i->output_offset, size / opb,
d1622 1
a1622 1
	      minfo (_("%W (size before relaxing)\n"), i->_raw_size);
d1627 1
a1627 1
	  print_dot = i->output_section->vma + i->output_offset + size / opb;
a1646 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine);
a1674 4
    case SQUAD:
      size = QUAD_SIZE;
      name = "SQUAD";
      break;
d1687 1
a1687 2
  print_dot = addr + size / opb;

d1697 1
a1697 1
  minfo (_("Address of section %s set to "), address->section_name);
a1710 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine); 
d1732 1
a1732 1
  print_dot = addr + size / opb;
a1740 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine); 
d1761 1
a1761 1
  print_dot = addr + s->size / opb;
d1771 1
a1771 11
  if (w->filenames_sorted)
    minfo ("SORT(");
  if (w->exclude_filename_list != NULL)
    {
      name_list *tmp;
      minfo ("EXCLUDE_FILE ( %s", w->exclude_filename_list->name);
      for (tmp=w->exclude_filename_list->next; tmp; tmp = tmp->next)
        minfo (", %s", tmp->name);
      minfo (")");
     }
   if (w->filename != NULL)
a1774 2
  if (w->filenames_sorted)
    minfo (")");
a1775 3
  minfo ("(");
  if (w->sections_sorted)
    minfo ("SORT(");
d1777 1
a1777 1
    minfo ("%s", w->section_name);
d1779 1
a1779 4
    minfo ("*");
  if (w->sections_sorted)
    minfo (")");
  minfo (")");
d1824 1
a1824 1
      fprintf (config.map_file, _("Fail with %d\n"), s->header.type);
d1830 1
a1830 4
	  if (constructors_sorted)
	    minfo (" SORT (CONSTRUCTORS)\n");
	  else
	    minfo (" CONSTRUCTORS\n");
a1934 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine); 
d1951 1
a1951 1
      new->padding_statement.size = alignment_needed * opb;
d1960 2
a1961 1
  output_section_statement->_raw_size += alignment_needed * opb;
a1962 1
  return dot + alignment_needed;
d1972 1
a1972 1
     boolean relax ATTRIBUTE_UNUSED;
a1975 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine); 
d1993 1
a1993 1
	dot += i->_cooked_size / opb;
d1995 2
a1996 3
	dot += i->_raw_size / opb;
      output_section_statement->bfd_section->_raw_size = 
        (dot - output_section_statement->bfd_section->vma) * opb;
a2005 59
#define IGNORE_SECTION(bfd, s) \
  (((bfd_get_section_flags (bfd, s) & (SEC_ALLOC | SEC_LOAD)) != (SEC_ALLOC | SEC_LOAD)) \
   || bfd_section_size (bfd, s) == 0)

/* Check to see if any allocated sections overlap with other allocated
   sections.  This can happen when the linker script specifically specifies
   the output section addresses of the two sections.  */
static void
lang_check_section_addresses ()
{
  asection * s;
  unsigned opb = bfd_octets_per_byte (output_bfd);

  /* Scan all sections in the output list.  */
  for (s = output_bfd->sections; s != NULL; s = s->next)
    {
      asection * os;
      
      /* Ignore sections which are not loaded or which have no contents.  */
      if (IGNORE_SECTION (output_bfd, s))
	continue;
      
      /* Once we reach section 's' stop our seach.  This prevents two
	 warning messages from being produced, one for 'section A overlaps
	 section B' and one for 'section B overlaps section A'.  */
      for (os = output_bfd->sections; os != s; os = os->next)
	{
	  bfd_vma s_start;
	  bfd_vma s_end;
	  bfd_vma os_start;
	  bfd_vma os_end;
	  
	  /* Only consider loadable sections with real contents.  */
	  if (IGNORE_SECTION (output_bfd, os))
	    continue;

	  /* We must check the sections' LMA addresses not their
	     VMA addresses because overlay sections can have
	     overlapping VMAs but they must have distinct LMAs.  */
	  s_start  = bfd_section_lma (output_bfd, s);
	  os_start = bfd_section_lma (output_bfd, os);
	  s_end    = s_start  + bfd_section_size (output_bfd, s) / opb - 1;
	  os_end   = os_start + bfd_section_size (output_bfd, os) / opb - 1;
	  
	  /* Look for an overlap.  */
	  if ((s_end < os_start) || (s_start > os_end))
	    continue;
	  
	  einfo (
_("%X%P: section %s [%V -> %V] overlaps section %s [%V -> %V]\n"),
		 s->name, s_start, s_end, os->name, os_start, os_end);
	  
	  /* Once we have found one overlap for this section,
	     stop looking for others.  */
	  break;
	}
    }
}

d2009 1
a2009 229
static boolean relax_again;

/* Make sure the new address is within the region.  We explicitly permit the
   current address to be at the exact end of the region when the address is
   non-zero, in case the region is at the end of addressable memory and the
   calculation wraps around.  */ 

static void
os_region_check (os, region, tree, base)
  lang_output_section_statement_type *os;
  struct memory_region_struct *region;
  etree_type *tree;
  bfd_vma base;
{
  if ((region->current < region->origin
       || (region->current - region->origin > region->length))
      && ((region->current != region->origin + region->length)
           || base == 0))
    {
      if (tree != (etree_type *) NULL)
        {
          einfo (_("%X%P: address 0x%v of %B section %s is not within region %s\n"),
                 region->current,
                 os->bfd_section->owner,
                 os->bfd_section->name,
                 region->name);
        }
      else
        {
          einfo (_("%X%P: region %s is full (%B section %s)\n"),
                 region->name,
                 os->bfd_section->owner,
                 os->bfd_section->name);
        }
      /* Reset the region pointer.  */
      region->current = region->origin;
    }
}

/* Set the sizes for all the output sections.  */

bfd_vma
lang_size_sections (s, output_section_statement, prev, fill, dot, relax)
     lang_statement_union_type * s;
     lang_output_section_statement_type * output_section_statement;
     lang_statement_union_type ** prev;
     fill_type fill;
     bfd_vma dot;
     boolean relax;
{
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine);

  /* Size up the sections from their constituent parts.  */
  for (; s != (lang_statement_union_type *) NULL; s = s->next)
    {
      switch (s->header.type)
	{
	case lang_output_section_statement_enum:
	  {
	    bfd_vma after;
	    lang_output_section_statement_type *os = &s->output_section_statement;

	    if (os->bfd_section == NULL)
	      /* This section was never actually created.  */
	      break;

	    /* If this is a COFF shared library section, use the size and
	       address from the input section.  FIXME: This is COFF
	       specific; it would be cleaner if there were some other way
	       to do this, but nothing simple comes to mind.  */
	    if ((os->bfd_section->flags & SEC_COFF_SHARED_LIBRARY) != 0)
	      {
		asection * input;

		if (os->children.head == NULL
		    || os->children.head->next != NULL
		    || os->children.head->header.type != lang_input_section_enum)
		  einfo (_("%P%X: Internal error on COFF shared library section %s\n"),
			 os->name);

		input = os->children.head->input_section.section;
		bfd_set_section_vma (os->bfd_section->owner,
				     os->bfd_section,
				     bfd_section_vma (input->owner, input));
		os->bfd_section->_raw_size = input->_raw_size;
		break;
	      }

	    if (bfd_is_abs_section (os->bfd_section))
	      {
		/* No matter what happens, an abs section starts at zero.  */
		ASSERT (os->bfd_section->vma == 0);
	      }
	    else
	      {
		if (os->addr_tree == (etree_type *) NULL)
		  {
		    /* No address specified for this section, get one
		       from the region specification.  */
		    if (os->region == (lang_memory_region_type *) NULL
			|| (((bfd_get_section_flags (output_bfd, os->bfd_section)
			      & (SEC_ALLOC | SEC_LOAD)) != 0)
			    && os->region->name[0] == '*'
			    && strcmp (os->region->name, "*default*") == 0))
		      {
			os->region = lang_memory_default (os->bfd_section);
		      }

		    /* If a loadable section is using the default memory
		       region, and some non default memory regions were
		       defined, issue a warning.  */
		    if ((bfd_get_section_flags (output_bfd, os->bfd_section)
			 & (SEC_ALLOC | SEC_LOAD)) != 0
			&& ! link_info.relocateable
			&& strcmp (os->region->name, "*default*") == 0
			&& lang_memory_region_list != NULL
			&& (strcmp (lang_memory_region_list->name, "*default*") != 0
			    || lang_memory_region_list->next != NULL))
		      einfo (_("%P: warning: no memory region specified for section `%s'\n"),
			     bfd_get_section_name (output_bfd, os->bfd_section));

		    dot = os->region->current;
 
		    if (os->section_alignment == -1)
		      {
			bfd_vma olddot;

			olddot = dot;
			dot = align_power (dot, os->bfd_section->alignment_power);

			if (dot != olddot && config.warn_section_align)
			  einfo (_("%P: warning: changing start of section %s by %u bytes\n"),
				 os->name, (unsigned int) (dot - olddot));
		      }
		  }
		else
		  {
		    etree_value_type r;

		    r = exp_fold_tree (os->addr_tree,
				       abs_output_section,
				       lang_allocating_phase_enum,
				       dot, &dot);
		    if (r.valid_p == false)
		      {
			einfo (_("%F%S: non constant address expression for section %s\n"),
			       os->name);
		      }
		    dot = r.value + r.section->bfd_section->vma;
		  }
		
		/* The section starts here.
		   First, align to what the section needs.  */

		if (os->section_alignment != -1)
		  dot = align_power (dot, os->section_alignment);

		bfd_set_section_vma (0, os->bfd_section, dot);
		
		os->bfd_section->output_offset = 0;
	      }

	    (void) lang_size_sections (os->children.head, os, &os->children.head,
				       os->fill, dot, relax);
	    
            /* put the section within the requested block size, or align at
               the block boundary */
	    after = ALIGN_N (os->bfd_section->vma
			     + os->bfd_section->_raw_size / opb,
			     /* The coercion here is important, see ld.h.  */
			     (bfd_vma) os->block_value);

	    if (bfd_is_abs_section (os->bfd_section))
	      ASSERT (after == os->bfd_section->vma);
	    else
	      os->bfd_section->_raw_size = 
                (after - os->bfd_section->vma) * opb;
	    dot = os->bfd_section->vma + os->bfd_section->_raw_size / opb;
	    os->processed = true;

	    /* Update dot in the region ?
	       We only do this if the section is going to be allocated,
	       since unallocated sections do not contribute to the region's
	       overall size in memory.
	       
	       If the SEC_NEVER_LOAD bit is not set, it will affect the
	       addresses of sections after it. We have to update
	       dot.  */
	    if (os->region != (lang_memory_region_type *) NULL
		&& ((bfd_get_section_flags (output_bfd, os->bfd_section)
		     & SEC_NEVER_LOAD) == 0
		    || (bfd_get_section_flags (output_bfd, os->bfd_section)
			& (SEC_ALLOC | SEC_LOAD))))
	      {
		os->region->current = dot;
		
		/* Make sure the new address is within the region.  */
                os_region_check (os, os->region, os->addr_tree, 
                                 os->bfd_section->vma);

                /* if there's no load address specified, use the run region as
                   the load region */
                if (os->lma_region == NULL && os->load_base == NULL)
                    os->lma_region = os->region;

                if (os->lma_region != NULL)
                  {
                    if (os->load_base != NULL)
                      {
                        einfo (_("%X%P: use an absolute load address or a load memory region, not both\n"));
                      }
                    else
                      {
                        /* don't allocate twice */
                        if (os->lma_region != os->region)
                          {
                            /* set load_base, which will be handled later */
                            os->load_base = exp_intop (os->lma_region->current);
                            os->lma_region->current += 
                              os->bfd_section->_raw_size / opb;
                            os_region_check (os, os->lma_region, NULL,
                                             os->bfd_section->lma);
                          }
                      }
                  }
	      }
	  }
	  break;
d2011 1
a2011 7
	case lang_constructors_statement_enum:
	  dot = lang_size_sections (constructor_list.head,
				    output_section_statement,
				    &s->wild_statement.children.head,
				    fill,
				    dot, relax);
	  break;
d2013 14
a2026 3
	case lang_data_statement_enum:
	  {
	    unsigned int size = 0;
d2028 64
a2091 3
	    s->data_statement.output_vma = dot - output_section_statement->bfd_section->vma;
	    s->data_statement.output_section =
	      output_section_statement->bfd_section;
d2093 69
a2161 30
	    switch (s->data_statement.type)
	      {
              default:
                abort();
	      case QUAD:
	      case SQUAD:
		size = QUAD_SIZE;
		break;
	      case LONG:
		size = LONG_SIZE;
		break;
	      case SHORT:
		size = SHORT_SIZE;
		break;
	      case BYTE:
		size = BYTE_SIZE;
		break;
	      }
            if (size < opb)
              size = opb;
	    dot += size / opb;
	    output_section_statement->bfd_section->_raw_size += size;
	    /* The output section gets contents, and then we inspect for
	       any flags set in the input script which override any ALLOC.  */
	    output_section_statement->bfd_section->flags |= SEC_HAS_CONTENTS;
	    if (!(output_section_statement->flags & SEC_NEVER_LOAD)) {
	      output_section_statement->bfd_section->flags |= SEC_ALLOC | SEC_LOAD;
	    }
	  }
	  break;
d2163 42
a2204 3
	case lang_reloc_statement_enum:
	  {
	    int size;
d2206 13
a2218 9
	    s->reloc_statement.output_vma =
	      dot - output_section_statement->bfd_section->vma;
	    s->reloc_statement.output_section =
	      output_section_statement->bfd_section;
	    size = bfd_get_reloc_size (s->reloc_statement.howto);
	    dot += size / opb;
	    output_section_statement->bfd_section->_raw_size += size;
	  }
	  break;
d2220 5
a2224 1
	case lang_wild_statement_enum:
d2226 1
a2226 3
	  dot = lang_size_sections (s->wild_statement.children.head,
				    output_section_statement,
				    &s->wild_statement.children.head,
d2228 1
a2228 1
				    fill, dot, relax);
d2230 10
a2239 1
	  break;
d2241 2
a2242 8
	case lang_object_symbols_statement_enum:
	  link_info.create_object_symbols_section =
	    output_section_statement->bfd_section;
	  break;
	case lang_output_statement_enum:
	case lang_target_statement_enum:
	  break;
	case lang_input_section_enum:
d2244 2
a2245 21
	    asection *i;

	    i = (*prev)->input_section.section;
	    if (! relax)
	      {
		if (i->_cooked_size == 0)
		  i->_cooked_size = i->_raw_size;
	      }
	    else
	      {
		boolean again;

		if (! bfd_relax_section (i->owner, i, &link_info, &again))
		  einfo (_("%P%F: can't relax section: %E\n"));
		if (again)
		  relax_again = true;
	      }
	    dot = size_input_section (prev,
				      output_section_statement,
				      output_section_statement->fill,
				      dot, relax);
d2247 1
a2247 9
	  break;
	case lang_input_statement_enum:
	  break;
	case lang_fill_statement_enum:
	  s->fill_statement.output_section = output_section_statement->bfd_section;

	  fill = s->fill_statement.fill;
	  break;
	case lang_assignment_statement_enum:
d2249 1
a2249 1
	    bfd_vma newdot = dot;
d2251 15
a2265 5
	    exp_fold_tree (s->assignment_statement.exp,
			   output_section_statement,
			   lang_allocating_phase_enum,
			   dot,
			   &newdot);
d2267 40
a2306 28
	    if (newdot != dot)
	      {
		/* The assignment changed dot.  Insert a pad.  */
		if (output_section_statement == abs_output_section)
		  {
		    /* If we don't have an output section, then just adjust
		       the default memory address.  */
		    lang_memory_region_lookup ("*default*")->current = newdot;
		  }
		else if (!relax)
		  {
		    lang_statement_union_type *new =
		      ((lang_statement_union_type *)
		       stat_alloc (sizeof (lang_padding_statement_type)));

		    /* Link into existing chain.  */
		    new->header.next = *prev;
		    *prev = new;
		    new->header.type = lang_padding_statement_enum;
		    new->padding_statement.output_section =
		      output_section_statement->bfd_section;
		    new->padding_statement.output_offset =
		      dot - output_section_statement->bfd_section->vma;
		    new->padding_statement.fill = fill;
		    new->padding_statement.size = (newdot - dot) * opb;
		    output_section_statement->bfd_section->_raw_size +=
		      new->padding_statement.size;
		  }
d2308 4
a2311 4
		dot = newdot;
	      }
	  }
	  break;
d2313 19
a2331 12
	case lang_padding_statement_enum:
	  /* If we are relaxing, and this is not the first pass, some
	     padding statements may have been inserted during previous
	     passes.  We may have to move the padding statement to a new
	     location if dot has a different value at this point in this
	     pass than it did at this point in the previous pass.  */
	  s->padding_statement.output_offset =
	    dot - output_section_statement->bfd_section->vma;
	  dot += s->padding_statement.size / opb;
	  output_section_statement->bfd_section->_raw_size +=
	    s->padding_statement.size;
	  break;
d2333 3
a2335 6
	case lang_group_statement_enum:
	  dot = lang_size_sections (s->group_statement.children.head,
				    output_section_statement,
				    &s->group_statement.children.head,
				    fill, dot, relax);
	  break;
d2337 1
a2337 3
	default:
	  FAIL ();
	  break;
d2339 2
a2340 6
	  /* This can only get here when relaxing is turned on.  */

	case lang_address_statement_enum:
	  break;
	}
      prev = &s->header.next;
d2342 2
a2353 3
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine); 

d2375 1
a2375 2
		dot = os->bfd_section->vma + os->bfd_section->_raw_size / opb;

d2412 2
a2413 2
	    if (value.valid_p == false)
	      einfo (_("%F%P: invalid data statement\n"));
d2415 15
a2429 24
          {
            unsigned int size;
            switch (s->data_statement.type)
              {
              default:
                abort();
              case QUAD:
              case SQUAD:
                size = QUAD_SIZE;
                break;
              case LONG:
                size = LONG_SIZE;
                break;
              case SHORT:
                size = SHORT_SIZE;
                break;
              case BYTE:
                size = BYTE_SIZE;
                break;
              }
            if (size < opb)
              size = opb;
            dot += size / opb;
          }
d2440 2
a2441 2
	    if (value.valid_p == false)
	      einfo (_("%F%P: invalid reloc statement\n"));
d2443 1
a2443 1
	  dot += bfd_get_reloc_size (s->reloc_statement.howto) / opb;
d2451 1
a2451 1
	      dot += in->_cooked_size / opb;
d2453 1
a2453 1
	      dot += in->_raw_size / opb;
d2473 1
a2473 1
	  dot += s->padding_statement.size / opb;
a2530 2
          unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
							ldfile_output_machine);
d2533 1
a2533 1
	    h->u.def.value = s->_cooked_size / opb;
d2535 1
a2535 1
	    h->u.def.value = s->_raw_size / opb;
d2575 1
a2575 1
	einfo (_("%P%F:%s: can't set start address\n"), entry_symbol);
d2579 1
a2579 2
      bfd_vma val;
      CONST char *send;
d2581 4
a2584 4
      /* We couldn't find the entry symbol.  Try parsing it as a
         number.  */
      val = bfd_scan_vma (entry_symbol, &send, 0);
      if (*send == '\0')
d2586 6
a2591 2
	  if (! bfd_set_start_address (output_bfd, val))
	    einfo (_("%P%F: can't set start address\n"));
d2595 3
a2597 21
	  asection *ts;

	  /* Can't find the entry symbol, and it's not a number.  Use
	     the first address in the text section.  */
	  ts = bfd_get_section_by_name (output_bfd, ".text");
	  if (ts != (asection *) NULL)
	    {
	      if (warn)
		einfo (_("%P: warning: cannot find entry symbol %s; defaulting to %V\n"),
		       entry_symbol, bfd_get_section_vma (output_bfd, ts));
	      if (! bfd_set_start_address (output_bfd,
					   bfd_get_section_vma (output_bfd,
								ts)))
		einfo (_("%P%F: can't set start address\n"));
	    }
	  else
	    {
	      if (warn)
		einfo (_("%P: warning: cannot find entry symbol %s; not setting start address\n"),
		       entry_symbol);
	    }
a2601 14
/* This is a small function used when we want to ignore errors from
   BFD.  */

static void
#ifdef ANSI_PROTOTYPES
ignore_bfd_errors (const char *s ATTRIBUTE_UNUSED, ...)
#else
ignore_bfd_errors (s)
     const char *s ATTRIBUTE_UNUSED;
#endif
{
  /* Don't do anything.  */
}

d2621 4
a2624 6
	{
	  if (command_line.warn_mismatch)
	    einfo (_("%P: warning: %s architecture of input file `%B' is incompatible with %s output\n"),
		   bfd_printable_name (input_bfd), input_bfd,
		   bfd_printable_name (output_bfd));
	}
d2626 1
a2626 19
	{
	  bfd_error_handler_type pfn = NULL;

	  /* If we aren't supposed to warn about mismatched input
             files, temporarily set the BFD error handler to a
             function which will do nothing.  We still want to call
             bfd_merge_private_bfd_data, since it may set up
             information which is needed in the output file.  */
	  if (! command_line.warn_mismatch)
	    pfn = bfd_set_error_handler (ignore_bfd_errors);
	  if (! bfd_merge_private_bfd_data (input_bfd, output_bfd))
	    {
	      if (command_line.warn_mismatch)
		einfo (_("%E%X: failed to merge target specific data of file %B\n"),
		       input_bfd);
	    }
	  if (! command_line.warn_mismatch)
	    bfd_set_error_handler (pfn);
	}
a2662 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine); 
d2677 2
a2678 2
  section->_cooked_size = ALIGN_N ((section->_cooked_size + opb - 1) / opb,
				   (bfd_size_type) (1 << power_of_two)) * opb;
d2687 1
a2687 1
  h->u.def.value = section->_cooked_size;
d2690 1
a2690 1
  section->_cooked_size += size;
d2706 2
a2707 2
	  minfo (_("\nAllocating common symbols\n"));
	  minfo (_("Common symbol       size              file\n\n"));
d2757 5
a2761 1
  LANG_FOR_EACH_INPUT_STATEMENT (file)
d2796 1
a2796 1
			  info_msg (_("%P: no [COMMON] command, defaulting to .bss\n"));
d2822 2
a2823 2
lang_set_flags (ptr, flags, invert)
     lang_memory_region_type *ptr;
a2824 1
     int invert;
d2826 1
a2826 1
  flagword *ptr_flags;
d2828 1
a2828 1
  ptr_flags = invert ? &ptr->not_flags : &ptr->flags;
d2831 7
d2840 2
a2841 6
	case 'A': case 'a':
	  *ptr_flags |= SEC_ALLOC;
	  break;

	case 'R': case 'r':
	  *ptr_flags |= SEC_READONLY;
d2843 2
a2844 3

	case 'W': case 'w':
	  *ptr_flags |= SEC_DATA;
d2846 2
a2847 3

	case 'X': case 'x':
	  *ptr_flags |= SEC_CODE;
d2849 3
a2851 4

	case 'L': case 'l':
	case 'I': case 'i':
	  *ptr_flags |= SEC_LOAD;
a2852 1

d2854 1
a2854 1
	  einfo (_("%P%F: invalid syntax in flags\n"));
d2884 5
a2888 1
  LANG_FOR_EACH_INPUT_STATEMENT (f)
d2902 5
a2906 1
  LANG_FOR_EACH_INPUT_STATEMENT (f)
d2908 1
a2908 1
      asection * s;
a3066 97
/* Expand a wild statement for a particular FILE, marking its sections KEEP
   as needed.  SECTION may be NULL, in which case it is a wild card.  */

static void
gc_section_callback (ptr, section, file, data)
     lang_wild_statement_type *ptr;
     asection *section;
     lang_input_statement_type *file ATTRIBUTE_UNUSED;
     void *data ATTRIBUTE_UNUSED;
{
  /* If the wild pattern was marked KEEP, the member sections
     should be as well.  */
  if (ptr->keep_sections)
    section->flags |= SEC_KEEP;
}

/* Handle a wild statement, marking it against GC.  SECTION or FILE or both
   may be NULL, indicating that it is a wildcard.  */

static void
lang_gc_wild (s, section, file)
     lang_wild_statement_type *s;
     const char *section;
     const char *file;
{
  walk_wild (s, section, file, gc_section_callback, NULL);
}

/* Iterate over sections marking them against GC.  */

static void
lang_gc_sections_1 (s)
     lang_statement_union_type * s;
{
  for (; s != (lang_statement_union_type *) NULL; s = s->next)
    {
      switch (s->header.type)
	{
	case lang_wild_statement_enum:
	  lang_gc_wild (&s->wild_statement,
			s->wild_statement.section_name,
			s->wild_statement.filename);
	  break;
	case lang_constructors_statement_enum:
	  lang_gc_sections_1 (constructor_list.head);
	  break;
	case lang_output_section_statement_enum:
	  lang_gc_sections_1 (s->output_section_statement.children.head);
	  break;
	case lang_group_statement_enum:
	  lang_gc_sections_1 (s->group_statement.children.head);
	  break;
	default:
	  break;
	}
    }
}

static void
lang_gc_sections ()
{
  struct bfd_link_hash_entry *h;
  ldlang_undef_chain_list_type *ulist, fake_list_start;

  /* Keep all sections so marked in the link script.  */

  lang_gc_sections_1 (statement_list.head);

  /* Keep all sections containing symbols undefined on the command-line.
     Handle the entry symbol at the same time.  */
  
  if (entry_symbol != NULL)
    {
      fake_list_start.next = ldlang_undef_chain_list_head;
      fake_list_start.name = (char *) entry_symbol;
      ulist = &fake_list_start;
    }
  else
    ulist = ldlang_undef_chain_list_head;

  for (; ulist; ulist = ulist->next)
    {
      h = bfd_link_hash_lookup (link_info.hash, ulist->name, 
				false, false, false);

      if (h != (struct bfd_link_hash_entry *) NULL
          && (h->type == bfd_link_hash_defined
              || h->type == bfd_link_hash_defweak)
	  && ! bfd_is_abs_section (h->u.def.section))
	{
	  h->u.def.section->flags |= SEC_KEEP;
	}
    }

  bfd_gc_sections (output_bfd, &link_info);
}

a3079 2
  already_linked_table_init ();

a3085 2
  already_linked_table_free ();

a3092 4
  /* Handle .exports instead of a version script if we're told to do so.  */
  if (command_line.version_exports_section)
    lang_do_version_exports_section ();

a3096 4
  /* Remove unreferenced sections if asked to.  */
  if (command_line.gc_sections)
    lang_gc_sections ();

a3131 4
	  /* Note: pe-dll.c does something like this also.  If you find
	     you need to change this code, you probably need to change
	     pe-dll.c also.  DJ */

a3167 5
  /* Make sure that the section addresses make sense.  */
  if (! link_info.relocateable
      && command_line.check_section_addresses)
    lang_check_section_addresses ();
  
d3177 3
a3179 8
lang_add_wild (section_name, sections_sorted, filename, filenames_sorted,
	       keep_sections, exclude_filename_list)
     const char *const section_name;
     boolean sections_sorted;
     const char *const filename;
     boolean filenames_sorted;
     boolean keep_sections;
     struct name_list *exclude_filename_list;
d3188 1
a3188 1
  if (filename != NULL && ! wildcardp (filename))
a3192 1
  new->sections_sorted = sections_sorted;
a3193 3
  new->filenames_sorted = filenames_sorted;
  new->keep_sections = keep_sections;
  new->exclude_filename_list = exclude_filename_list;
d3213 15
d3240 8
d3329 1
a3329 1
lang_assignment_statement_type *
a3336 1
  return new;
d3352 1
a3352 1
      einfo (_("%P%Fmultiple STARTUP files\n"));
d3369 1
a3369 1
lang_leave_output_section_statement (fill, memspec, phdrs, lma_memspec)
a3372 1
     const char *lma_memspec;
a3375 8
  if (strcmp (lma_memspec, "*default*") != 0)
    {
      current_section->lma_region = lang_memory_region_lookup (lma_memspec);
      /* if no runtime region has been given, but the load region has been,
         use the load region */
      if (strcmp (memspec, "*default*") == 0)
        current_section->region = lang_memory_region_lookup (lma_memspec);
    }
d3395 1
a3395 1
    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
d3429 1
a3429 1
    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
d3443 1
a3443 2
			  + bfd_section_size (output_bfd, sec) /
                          bfd_octets_per_byte (output_bfd));
d3614 1
a3614 1
	einfo (_("%F%P: bfd_record_phdr failed: %E\n"));
d3633 1
a3633 1
	  einfo (_("%X%P: section `%s' assigned to non-existent phdr `%s'\n"),
d3735 1
a3735 1
    overlay_max = exp_binop (MAX_K, overlay_max, size);
d3753 1
a3753 2
  lang_leave_output_section_statement (fill, "*default*", 
                                       phdrs, "*default*");
d3760 1
a3760 1
    if (isalnum ((unsigned char) *s1) || *s1 == '_')
d3783 1
a3783 1
lang_leave_overlay (fill, memspec, phdrs, lma_memspec)
a3786 1
     const char *lma_memspec;
a3788 1
  lang_memory_region_type *lma_region;
a3796 5
  if (lma_memspec == NULL)
    lma_region = NULL;
  else
    lma_region = lang_memory_region_lookup (lma_memspec);

a3807 2
      if (lma_region != NULL && l->os->lma_region == NULL)
        l->os->lma_region = lma_region;
a3845 64
static int
lang_vers_match_lang_c (expr, sym)
     struct bfd_elf_version_expr *expr;
     const char *sym;
{
  if (expr->pattern[0] == '*' && expr->pattern[1] == '\0')
    return 1;
  return fnmatch (expr->pattern, sym, 0) == 0;
}

static int
lang_vers_match_lang_cplusplus (expr, sym)
     struct bfd_elf_version_expr *expr;
     const char *sym;
{
  char *alt_sym;
  int result;

  if (expr->pattern[0] == '*' && expr->pattern[1] == '\0')
    return 1;

  alt_sym = cplus_demangle(sym, /* DMGL_NO_TPARAMS */ 0);
  if (!alt_sym)
    {
      /* cplus_demangle (also) returns NULL when it is not a C++ symbol.
	 Should we early out false in this case?  */
      result = fnmatch (expr->pattern, sym, 0) == 0;
    }
  else
    {
      result = fnmatch (expr->pattern, alt_sym, 0) == 0;
      free (alt_sym);
    }

  return result;
}

static int
lang_vers_match_lang_java (expr, sym)
     struct bfd_elf_version_expr *expr;
     const char *sym;
{
  char *alt_sym;
  int result;

  if (expr->pattern[0] == '*' && expr->pattern[1] == '\0')
    return 1;

  alt_sym = cplus_demangle(sym, DMGL_JAVA);
  if (!alt_sym)
    {
      /* cplus_demangle (also) returns NULL when it is not a Java symbol.
	 Should we early out false in this case?  */
      result = fnmatch (expr->pattern, sym, 0) == 0;
    }
  else
    {
      result = fnmatch (expr->pattern, alt_sym, 0) == 0;
      free (alt_sym);
    }

  return result;
}

d3849 1
a3849 1
lang_new_vers_regex (orig, new, lang)
a3851 1
     const char *lang;
d3857 1
a3857 15
  ret->pattern = new;

  if (lang == NULL || strcasecmp (lang, "C") == 0)
    ret->match = lang_vers_match_lang_c;
  else if (strcasecmp (lang, "C++") == 0)
    ret->match = lang_vers_match_lang_cplusplus;
  else if (strcasecmp (lang, "Java") == 0)
    ret->match = lang_vers_match_lang_java;
  else
    {
      einfo (_("%X%P: unknown language `%s' in version information\n"),
	     lang);
      ret->match = lang_vers_match_lang_c;
    }

d3902 1
a3902 1
      einfo (_("%X%P: duplicate version tag `%s'\n"), name);
d3913 5
d3919 3
a3921 3
	    if (strcmp (e1->pattern, e2->pattern) == 0)
	      einfo (_("%X%P: duplicate expression `%s' in version information\n"),
		     e1->pattern);
d3932 8
a3939 3
	    if (strcmp (e1->pattern, e2->pattern) == 0)
	      einfo (_("%X%P: duplicate expression `%s' in version information\n"),
		     e1->pattern);
d3975 1
a3975 1
  einfo (_("%X%P: unable to find version dependency `%s'\n"), name);
a3977 38
}

static void
lang_do_version_exports_section ()
{
  struct bfd_elf_version_expr *greg = NULL, *lreg;

  LANG_FOR_EACH_INPUT_STATEMENT (is)
    {
      asection *sec = bfd_get_section_by_name (is->the_bfd, ".exports");
      char *contents, *p;
      bfd_size_type len;

      if (sec == NULL)
        continue;

      len = bfd_section_size (is->the_bfd, sec);
      contents = xmalloc (len);
      if (!bfd_get_section_contents (is->the_bfd, sec, contents, 0, len))
	einfo (_("%X%P: unable to read .exports section contents"), sec);

      p = contents;
      while (p < contents+len)
	{
	  greg = lang_new_vers_regex (greg, p, NULL);
	  p = strchr (p, '\0') + 1;
	}

      /* Do not free the contents, as we used them creating the regex.  */

      /* Do not include this section in the link.  */
      bfd_set_section_flags (is->the_bfd, sec,
	bfd_get_section_flags (is->the_bfd, sec) | SEC_EXCLUDE);
    }

  lreg = lang_new_vers_regex (NULL, "*", NULL);
  lang_register_vers_node (command_line.version_exports_section,
			   lang_new_vers_node (greg, lreg), NULL);
@


1.1.1.7
log
@Long delayed import of binutils-2.10.1. Turns out art@@ needs some alpha
bug-fixes...
@
text
@d61 1
a168 1
lang_statement_list_type lang_output_section_statement;
d3816 1
a3816 1
lang_output_section_statement_type *
a3863 1
  return os;
@


1.1.1.8
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001
d33 1
a37 1
#include "ldemul.h"
d44 4
a47 2
static lang_statement_union_type *new_statement
  PARAMS ((enum statement_enum, size_t, lang_statement_list_type *));
d54 1
a54 1
static const char *startup_file;
d61 2
a62 2
static const char *current_target;
static const char *output_target;
d67 2
a68 2
  PARAMS ((void (*) (lang_statement_union_type *),
	   lang_statement_union_type *));
d70 3
a72 4
  PARAMS ((const char *, lang_input_file_enum_type, const char *, boolean));
static lang_memory_region_type *lang_memory_default PARAMS ((asection *));
static void lang_map_flags PARAMS ((flagword));
static void init_os PARAMS ((lang_output_section_statement_type *));
d76 2
a77 1
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d84 11
a94 12
static void output_section_callback
  PARAMS ((lang_wild_statement_type *, asection *,
	   lang_input_statement_type *, PTR));
static lang_input_statement_type *lookup_name PARAMS ((const char *));
static void load_symbols
  PARAMS ((lang_input_statement_type *, lang_statement_list_type *));
static void wild
  PARAMS ((lang_wild_statement_type *, const char *, const char *,
	   const char *, lang_output_section_statement_type *));
static bfd *open_output PARAMS ((const char *));
static void ldlang_open_output PARAMS ((lang_statement_union_type *));
static void open_input_bfds PARAMS ((lang_statement_union_type *, boolean));
d98 3
a100 2
  PARAMS ((lang_statement_union_type *, const char *,
	   lang_output_section_statement_type *));
d102 1
a102 1
  PARAMS ((lang_output_section_statement_type *));
d104 3
a106 3
  PARAMS ((lang_assignment_statement_type *,
	   lang_output_section_statement_type *));
static void print_input_statement PARAMS ((lang_input_statement_type *));
d108 3
a110 3
static void print_input_section PARAMS ((lang_input_section_type *));
static void print_fill_statement PARAMS ((lang_fill_statement_type *));
static void print_data_statement PARAMS ((lang_data_statement_type *));
d112 2
a113 2
static void print_reloc_statement PARAMS ((lang_reloc_statement_type *));
static void print_padding_statement PARAMS ((lang_padding_statement_type *));
d115 2
a116 1
  PARAMS ((lang_wild_statement_type *, lang_output_section_statement_type *));
d119 4
a122 4
static void print_statement
  PARAMS ((lang_statement_union_type *, lang_output_section_statement_type *));
static void print_statement_list
  PARAMS ((lang_statement_union_type *, lang_output_section_statement_type *));
d124 4
a127 3
static bfd_vma insert_pad
  PARAMS ((lang_statement_union_type **, fill_type,
	   unsigned int, asection *, bfd_vma));
d129 3
a131 2
  PARAMS ((lang_statement_union_type **, lang_output_section_statement_type *,
	   fill_type, bfd_vma, boolean));
a140 3
static void gc_section_callback
  PARAMS ((lang_wild_statement_type *, asection *,
	   lang_input_statement_type *, PTR));
a145 6
static int lang_vers_match_lang_c
  PARAMS ((struct bfd_elf_version_expr *, const char *));
static int lang_vers_match_lang_cplusplus
  PARAMS ((struct bfd_elf_version_expr *, const char *));
static int lang_vers_match_lang_java
  PARAMS ((struct bfd_elf_version_expr *, const char *));
a147 3
static void os_region_check
  PARAMS ((lang_output_section_statement_type *,
	   struct memory_region_struct *, etree_type *, bfd_vma));
d151 1
a151 4
				    PTR));
static void walk_wild
  PARAMS ((lang_wild_statement_type *, const char *, const char *,
	 callback_t, PTR));
d154 1
a154 1
	   lang_input_statement_type *, callback_t, PTR));
d157 1
a157 1
	   lang_input_statement_type *, callback_t, PTR));
d159 1
a159 1
static int    get_target PARAMS ((const bfd_target *, PTR));
d163 1
a163 1
static int    closest_target_match PARAMS ((const bfd_target *, PTR));
d165 1
a165 1

a177 1
struct unique_sections *unique_section_list;
d181 2
a182 1
#if defined (__STDC__) || defined (ALMOST_STDC)
d188 1
a188 4
/* Don't beautify the line below with "innocent" whitespace, it breaks
   the K&R C preprocessor!  */
#define new_stat(x, y) \
  (cat (x,_type)*) new_statement (cat (x,_enum), sizeof (cat (x,_type)), y)
d190 1
a190 2
#define outside_section_address(q) \
  ((q)->output_offset + (q)->output_section->vma)
d192 1
a192 2
#define outside_symbol_address(q) \
  ((q)->value + outside_section_address (q->section))
d203 3
a205 18
boolean
unique_section_p (secnam)
     const char *secnam;
{
  struct unique_sections *unam;

  for (unam = unique_section_list; unam; unam = unam->next)
    if (wildcardp (unam->name)
	? fnmatch (unam->name, secnam, 0) == 0
	: strcmp (unam->name, secnam) == 0)
      {
	return true;
      }

  return false;
}

/* Generic traversal routines for finding matching sections.  */
d213 1
a213 1
     PTR data;
d215 1
a215 1
  /* Don't process sections from files which were excluded.  */
d219 2
a220 4
      for (list_tmp = ptr->exclude_filename_list;
	   list_tmp;
	   list_tmp = list_tmp->next)
	{
d224 1
a224 1
	    match = fnmatch (list_tmp->name, file->filename, 0) == 0;
d226 1
a226 1
	    match = strcmp (list_tmp->name, file->filename) == 0;
d236 1
a236 1
      boolean wildcard = false;
d238 3
a240 1
      if (section != NULL)
a245 1
	  const char *sname = bfd_get_section_name (file->the_bfd, s);
a248 2
	  else if (wildcard)
	    match = fnmatch (section, sname, 0) == 0;
d250 9
a258 1
	    match = strcmp (section, sname) == 0;
d260 1
a260 3
	  /* If this is a wild-card output section statement, exclude
	     sections that match UNIQUE_SECTION_LIST.  */
	  if (match && (data == NULL || !unique_section_p (sname)))
d274 1
a274 1
     PTR data;
d311 1
a311 1
     PTR data;
d337 6
a342 4
}

/* lang_for_each_statement walks the parse tree and calls the provided
   function for each node.  */
d395 2
a396 1
  lang_for_each_statement_worker (func, statement_list.head);
a399 1

d408 5
a412 1
/* Build a new statement node for the parse tree.  */
d414 2
a415 1
static lang_statement_union_type *
d419 1
a419 1
     lang_statement_list_type *list;
d430 9
a438 8
/* Build a new input file node for the language.  There are several
   ways in which we treat an input file, eg, we only look at symbols,
   or prefix it with a -l etc.

   We can be supplied with requests for input files more than once;
   they may, for example be split over serveral lines like foo.o(.text)
   foo.o(.data) etc, so when asked for a file we check that we haven't
   got it already so we don't duplicate the bfd.  */
d440 1
d443 1
a443 1
     const char *name;
d445 1
a445 1
     const char *target;
d530 1
a530 1
     const char *name;
d532 1
a532 1
     const char *target;
d538 1
a538 2
/* Build enough state so that the parser can build its tree.  */

d554 1
a554 2
  abs_output_section =
    lang_output_section_statement_lookup (BFD_ABS_SECTION_NAME);
d561 9
a569 8
  A region is an area of memory declared with the
  MEMORY {  name:org=exp, len=exp ... }
  syntax.

  We maintain a list of all the regions here.

  If no regions are specified in the script, then the default is used
  which is created when looked up to be the entire data space.  */
d576 1
a576 1
     const char *const name;
d610 1
a610 1
    new->name = xstrdup (name);
d618 1
a618 1
    new->length = ~(bfd_size_type) 0;
d626 2
a627 1
static lang_memory_region_type *
d654 1
a654 1
     const char *const name;
d674 1
a674 1
     const char *const name;
d697 1
a697 1
      lookup->memspec = (const char *) NULL;
d812 2
a813 2
  /* We initialize an output sections output offset to minus its own
     vma to allow us to output a section through itself.  */
d886 1
a886 1
struct already_linked_hash_entry
d892 1
a892 1
struct already_linked
d902 1
d929 1
a929 1
  /* FIXME: When doing a relocatable link, we may have trouble
d936 1
a936 1
     doing a relocatable link (technically, they should be discarded
d942 1
a942 1
     Also, not merging link once sections in a relocatable link
d948 1
a948 1
  already_linked_list =
d952 1
a952 1
  for (l = already_linked_list->entry; l != NULL; l = l->next)
d998 2
a999 1
	  sec->kept_section = l->sec;
d1008 1
a1008 1
  l = ((struct already_linked *)
d1025 1
a1025 1
  struct already_linked_hash_entry *ret =
d1126 6
a1131 4
	init_os (output);

      first = ! output->bfd_section->linker_has_input;
      output->bfd_section->linker_has_input = 1;
d1133 1
a1133 1
      /* Add a section reference to the list.  */
a1198 7

      if (section->flags & SEC_BLOCK)
	{
	  section->output_section->flags |= SEC_BLOCK;
	  /* FIXME: This value should really be obtained from the bfd...  */
	  output->block_value = 128;
	}
d1311 1
a1311 1
     PTR output;
d1314 1
a1314 1

d1319 1
a1319 1

d1321 1
a1321 1

d1326 1
a1326 1

d1328 2
a1329 2
    wild_doit (&ptr->children, section,
	       (lang_output_section_statement_type *) output,
d1335 1
a1335 1

d1337 2
a1338 2
      wild_doit (&list, section,
		 (lang_output_section_statement_type *) output,
d1340 1
a1340 1

d1346 1
a1346 1

d1351 1
a1351 1

a1417 5

      /* See if the emulation has some special knowledge.  */
      if (ldemul_unrecognized_file (entry))
	return;

d1435 5
d1441 1
d1506 2
d1521 1
a1521 1
  walk_wild (s, section, file, output_section_callback, (PTR) output);
a1533 1

d1536 2
a1537 2
     const bfd_target *target;
     PTR data;
d1539 2
a1540 2
  const char *sought = (const char *) data;

a1544 1

d1547 2
a1548 2
     char *dest;
     char *src;
d1551 2
a1552 2

  while ((c = *src++) != 0)
d1557 1
a1557 1
      *dest++ = c;
d1560 1
a1560 1
  *dest = 0;
a1564 1

d1567 2
a1568 2
     char *haystack;
     char *needle;
d1571 1
a1571 1

d1574 1
a1574 1
      char *src;
d1576 4
a1579 4
      for (src = haystack + strlen (needle); *src;)
	*haystack++ = *src++;

      *haystack = 0;
a1584 1

d1587 2
a1588 2
     char *first;
     char *second;
d1590 4
a1593 4
  char *copy1;
  char *copy2;
  int result;

d1610 2
a1611 2
  for (result = 0; copy1[result] == copy2[result]; result++)
    if (copy1[result] == 0)
d1616 1
a1616 1

d1624 1
a1624 1
static const bfd_target *winner;
a1628 1

d1631 2
a1632 2
     const bfd_target *target;
     PTR data;
d1634 3
a1636 4
  const bfd_target *original = (const bfd_target *) data;

  if (command_line.endian == ENDIAN_BIG
      && target->byteorder != BFD_ENDIAN_BIG)
d1638 2
a1639 3

  if (command_line.endian == ENDIAN_LITTLE
      && target->byteorder != BFD_ENDIAN_LITTLE)
d1654 2
a1655 3
     Compare their names and choose the better one.  */
  if (name_compare (target->name, original->name)
      > name_compare (winner->name, original->name))
a1662 1

d1666 1
a1666 1
  char *target = NULL;
d1674 1
a1674 1

d1679 1
a1679 1

d1685 1
a1685 1

d1693 1
a1693 1
     const char *name;
d1695 1
a1695 1
  bfd *output;
d1697 1
a1697 1
  /* Has the user told us which output format to use?  */
d1700 1
a1700 2
      /* No - has the current target been set to something other than
         the default?  */
d1704 1
a1704 1
      /* No - can we determine the format of the first input file?  */
d1714 2
a1715 3

  /* Has the user requested a particular endianness on the command
     line?  */
d1718 1
a1718 1
      const bfd_target *target;
d1722 1
a1722 1
      target = bfd_search_for_target (get_target, (PTR) output_target);
d1724 15
a1738 5
      /* If the target is not supported, we cannot do anything.  */
      if (target != NULL)
	{
	  if (command_line.endian == ENDIAN_BIG)
	    desired_endian = BFD_ENDIAN_BIG;
a1739 7
	    desired_endian = BFD_ENDIAN_LITTLE;

	  /* See if the target has the wrong endianness.  This should
	     not happen if the linker script has provided big and
	     little endian alternatives, but some scrips don't do
	     this.  */
	  if (target->byteorder != desired_endian)
d1741 7
a1747 5
	      /* If it does, then see if the target provides
		 an alternative with the correct endianness.  */
	      if (target->alternative_target != NULL
		  && (target->alternative_target->byteorder == desired_endian))
		output_target = target->alternative_target->name;
d1749 1
a1749 14
		{
		  /* Try to find a target as similar as possible to
		     the default target, but which has the desired
		     endian characteristic.  */
		  (void) bfd_search_for_target (closest_target_match,
						(PTR) target);

		  /* Oh dear - we could not find any targets that
		     satisfy our requirements.  */
		  if (winner == NULL)
		    einfo (_("%P: warning: could not find any targets that match endianness requirement\n"));
		  else
		    output_target = winner->name;
		}
d1753 1
a1753 1

d1766 1
a1766 3
#if 0
  output->flags |= D_PAGED;
#endif
d1785 1
a1785 1
     lang_statement_union_type *statement;
d1833 1
a1833 1
	  /* Maybe we should load the file's symbols.  */
d1844 2
a1845 2
	       until no new symbols are added to the list of undefined
	       symbols.  */
d1867 1
a1867 2
                 force it to be researched unless the whole archive
		 has been loaded already.  */
a1868 1
		  && !s->input_statement.whole_archive
d1891 1
a1891 2
/* If there are [COMMONS] statements, put a wild one into the bss
   section.  */
d1900 3
a1902 1
  default_common_section = lang_output_section_statement_lookup (".bss");
d1915 1
d1918 4
a1921 2
/* Add the supplied name to the symbol table as an undefined reference.
   Remove items from the chain as we open input bfds.  */
d1932 1
a1932 1
     const char *const name;
d1941 1
a1941 1
  new->name = xstrdup (name);
d1946 2
a1947 2
   script file.  */

d1971 1
a1971 2
/* Open input files and attatch to output sections.  */

d1974 3
a1976 3
     lang_statement_union_type *s;
     const char *target;
     lang_output_section_statement_type *output_section_statement;
d1983 1
d2027 1
a2027 1
	     are initialized.  */
d2034 1
a2034 1
	  /* Mark the specified section with the supplied address.  */
d2051 1
a2051 1
     lang_output_section_statement_type *output_section_statement;
d2097 2
a2098 2
     lang_assignment_statement_type *assignment;
     lang_output_section_statement_type *output_section;
d2127 1
a2127 1
     lang_input_statement_type *statm;
d2138 1
a2138 1
static boolean
d2168 1
a2168 1
     lang_input_section_type *in;
d2172 1
a2172 1
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
d2226 1
a2226 1
     lang_fill_statement_type *fill;
d2233 1
a2233 1
     lang_data_statement_type *data;
d2239 1
a2239 1
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
d2310 2
a2311 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
d2334 1
a2334 1
}
d2342 2
a2343 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
d2369 2
a2370 2
     lang_wild_statement_type *w;
     lang_output_section_statement_type *os;
d2380 2
a2381 2
      for (tmp = w->exclude_filename_list->next; tmp; tmp = tmp->next)
	minfo (", %s", tmp->name);
d2383 2
a2384 2
    }
  if (w->filename != NULL)
d2522 1
a2522 1
     lang_statement_union_type *s;
d2545 1
a2545 1
     lang_statement_union_type **this_ptr;
d2548 1
a2548 1
     asection *output_section_statement;
d2556 2
a2557 1
     inserting a magic 'padding' statement.  */
d2559 2
a2560 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
d2569 1
a2569 1
      /* Link into existing chain.  */
d2580 2
a2581 1
  /* Remember the most restrictive alignment.  */
d2591 1
a2591 2
/* Work out how much this section will move the dot point.  */

d2594 2
a2595 2
     lang_statement_union_type **this_ptr;
     lang_output_section_statement_type *output_section_statement;
d2602 2
a2603 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
d2614 1
a2614 1
      /* Remember where in the output section this input section goes.  */
d2618 2
a2619 1
      /* Mark how big the output section must be to contain this now.  */
d2624 2
a2625 2
      output_section_statement->bfd_section->_raw_size =
	(dot - output_section_statement->bfd_section->vma) * opb;
d2636 1
a2636 2
  (((bfd_get_section_flags (bfd, s) & (SEC_ALLOC | SEC_LOAD))	\
    != (SEC_ALLOC | SEC_LOAD))					\
a2641 1

d2645 1
a2645 1
  asection *s;
d2651 2
a2652 2
      asection *os;

d2656 1
a2656 1

d2666 1
a2666 1

d2678 1
a2678 1

d2682 1
a2682 1

d2686 1
a2686 1

d2702 1
a2702 1
   calculation wraps around.  */
d2706 4
a2709 4
     lang_output_section_statement_type *os;
     struct memory_region_struct *region;
     etree_type *tree;
     bfd_vma base;
d2740 3
a2742 3
     lang_statement_union_type *s;
     lang_output_section_statement_type *output_section_statement;
     lang_statement_union_type **prev;
d2747 1
a2747 1
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
d2758 1
a2758 1
	    lang_output_section_statement_type *os;
a2759 1
	    os = &s->output_section_statement;
d2770 1
a2770 1
		asection *input;
d2814 1
a2814 2
			&& (strcmp (lang_memory_region_list->name,
				    "*default*") != 0
d2817 1
a2817 2
			     bfd_get_section_name (output_bfd,
						   os->bfd_section));
d2820 1
a2820 1

d2826 1
a2826 2
			dot = align_power (dot,
					   os->bfd_section->alignment_power);
d2848 1
a2848 1

d2856 1
a2856 1

d2860 1
a2860 2
	    (void) lang_size_sections (os->children.head, os,
				       &os->children.head,
d2862 3
a2864 3

	    /* Put the section within the requested block size, or
	       align at the block boundary.  */
d2873 2
a2874 2
	      os->bfd_section->_raw_size =
		(after - os->bfd_section->vma) * opb;
d2882 1
a2882 1

d2893 1
a2893 1

d2895 2
a2896 7
		os_region_check (os, os->region, os->addr_tree,
				 os->bfd_section->vma);

		/* If there's no load address specified, use the run
		   region as the load region.  */
		if (os->lma_region == NULL && os->load_base == NULL)
		  os->lma_region = os->region;
d2898 25
a2922 21
		if (os->lma_region != NULL)
		  {
		    if (os->load_base != NULL)
		      {
			einfo (_("%X%P: use an absolute load address or a load memory region, not both\n"));
		      }
		    else
		      {
			/* Don't allocate twice.  */
			if (os->lma_region != os->region)
			  {
			    /* Set load_base, which will be handled later.  */
			    os->load_base =
			      exp_intop (os->lma_region->current);
			    os->lma_region->current +=
			      os->bfd_section->_raw_size / opb;
			    os_region_check (os, os->lma_region, NULL,
					     os->bfd_section->lma);
			  }
		      }
		  }
d2939 1
a2939 2
	    s->data_statement.output_vma =
	      dot - output_section_statement->bfd_section->vma;
d2945 2
a2946 2
	      default:
		abort ();
d2961 2
a2962 2
	    if (size < opb)
	      size = opb;
d2968 3
a2970 5
	    if (!(output_section_statement->flags & SEC_NEVER_LOAD))
	      {
		output_section_statement->bfd_section->flags |=
		  SEC_ALLOC | SEC_LOAD;
	      }
d2987 1
a2987 1

d2993 1
d3033 1
a3033 2
	  s->fill_statement.output_section =
	    output_section_statement->bfd_section;
d3117 2
a3118 2
     lang_statement_union_type *s;
     lang_output_section_statement_type *output_section_statement;
d3122 2
a3123 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
d3138 2
a3139 1
	    lang_output_section_statement_type *os;
a3140 1
	    os = &(s->output_section_statement);
d3149 1
a3149 1
	    if (os->load_base)
d3152 2
a3153 2
		   it won't have a bfd_section.  */
		if (os->bfd_section)
d3155 2
a3156 3
		    os->bfd_section->lma
		      = exp_get_abs_int (os->load_base, 0, "load base",
					 lang_final_phase_enum);
d3189 22
a3210 22
	    switch (s->data_statement.type)
	      {
	      default:
		abort ();
	      case QUAD:
	      case SQUAD:
		size = QUAD_SIZE;
		break;
	      case LONG:
		size = LONG_SIZE;
		break;
	      case SHORT:
		size = SHORT_SIZE;
		break;
	      case BYTE:
		size = BYTE_SIZE;
		break;
	      }
	    if (size < opb)
	      size = opb;
	    dot += size / opb;
	  }
d3312 2
a3313 4
          unsigned opb;

          opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
					       ldfile_output_machine);
d3363 1
a3363 1
      const char *send;
d3423 1
a3423 1
  const bfd_arch_info_type *compatible;
d3439 1
a3439 1
      else if (bfd_count_sections (input_bfd))
a3440 3
	  /* If the input bfd has no contents, it shouldn't set the
	     private data of the output bfd. */

d3495 2
a3496 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
d3529 1
a3529 1
  section->flags &= ~SEC_IS_COMMON;
d3581 6
a3586 3
/* Run through the input files and ensure that every input section has
   somewhere to go.  If one is found without a destination then create
   an input request and place it into the statement tree.  */
d3602 1
a3602 1
	         around for a sensible place for it to go.  */
d3650 1
d3654 1
a3654 1
     const char *flags;
d3728 1
a3728 1
     void (*func) PARAMS ((bfd *ab, asection *as));
d3732 1
a3732 1
      asection *s;
d3747 1
a3747 1
     lang_input_statement_type *entry;
d3782 1
a3782 1
     const char *name;
d3793 1
d3806 1
a3806 1
  for (l = 0; l < 32; l++)
d3821 1
a3821 1
     etree_type *address_exp;
a3833 6
  /* Add this statement to tree.  */
#if 0
  add_statement (lang_output_section_statement_enum,
		 output_section_statement);
#endif
  /* Make next things chain into subchain of this.  */
d3835 12
a3846 4
  if (os->addr_tree == (etree_type *) NULL)
    {
      os->addr_tree = address_exp;
    }
d3855 7
a3861 4
  os->subsection_alignment =
    topower (exp_get_value_int (subalign, -1, "subsection alignment", 0));
  os->section_alignment =
    topower (exp_get_value_int (align, -1, "section alignment", 0));
d3867 1
d3877 1
a3877 2
/* Reset the current counters in the regions.  */

d3900 1
a3900 1
     PTR data ATTRIBUTE_UNUSED;
d3924 1
a3924 1
     lang_statement_union_type *s;
d3962 1
a3962 1

d3974 1
a3974 1
      h = bfd_link_hash_lookup (link_info.hash, ulist->name,
d3978 2
a3979 2
	  && (h->type == bfd_link_hash_defined
	      || h->type == bfd_link_hash_defweak)
d3995 1
a3995 2
  /* Open the output file.  */
  lang_for_each_statement (ldlang_open_output);
d3999 1
a3999 1
  /* Add to the hash table all undefineds on the command line.  */
d4004 1
a4004 1
  /* Create a bfd for each input file.  */
d4031 1
a4031 1
  /* Size up the common data.  */
d4035 2
a4036 1
     to the correct output sections.  */
d4040 2
a4041 1
  /* Find any sections not attached explicitly and handle them.  */
d4050 1
a4050 1
  /* Now run around and relax if we can.  */
d4068 1
a4068 1
	     pe-dll.c also.  DJ  */
d4099 2
a4100 2
  /* Do all the assignments, now that we know the final resting places
     of all the symbols.  */
d4110 2
a4111 2

  /* Final stuffs.  */
d4151 2
a4152 2
     const char *name;
     etree_type *address;
d4154 1
a4154 1
  lang_address_statement_type *ad;
a4155 1
  ad = new_stat (lang_address_statement, stat_ptr);
d4167 1
a4167 1
     const char *name;
d4181 1
a4181 1
     const char *name;
d4192 1
a4192 1
     const char *name;
d4198 1
a4198 1
	case 'F':
d4246 1
a4246 1

d4260 1
a4260 1
     etree_type *exp;
d4278 1
a4278 1
     const char *name;
d4310 2
a4311 2
      /* If no runtime region has been given, but the load region has
         been, use the load region.  */
d4319 3
a4321 4
/* Create an absolute symbol with the given name with the value of the
   address of first byte of the section named.

   If the symbol already exists, then do nothing.  */
d4323 2
d4353 3
a4355 4
/* Create an absolute symbol with the given name with the value of the
   address of the first byte after the end of the section named.

   If the symbol already exists, then do nothing.  */
d4357 2
d4391 3
a4393 3
     lang_statement_list_type *list;
     lang_statement_union_type *element;
     lang_statement_union_type **field;
d4550 3
a4552 1
			     l->flags != NULL, flags, l->at != NULL,
d4611 2
a4612 1
struct overlay_list {
d4693 1
a4693 1
  lang_leave_output_section_statement (fill, "*default*",
d4756 2
a4757 9
      /* We only set lma_region for the first overlay section, as
	 subsequent overlay sections will have load_base set relative
	 to the first section.  Also, don't set lma_region if
	 load_base is specified.  FIXME:  There should really be a test
	 that `AT ( LDADDR )' doesn't conflict with `AT >LMA_REGION'
	 rather than letting LDADDR simply override LMA_REGION.  */
      if (lma_region != NULL && l->os->lma_region == NULL
	  && l->next == NULL && l->os->load_base == NULL)
	l->os->lma_region = lma_region;
d4817 1
a4817 1
  alt_sym = cplus_demangle (sym, /* DMGL_NO_TPARAMS */ 0);
d4844 1
a4844 1
  alt_sym = cplus_demangle (sym, DMGL_JAVA);
d5019 1
a5019 1
      while (p < contents + len)
a5034 16
}

void
lang_add_unique (name)
     const char *name;
{
  struct unique_sections *ent;

  for (ent = unique_section_list; ent; ent = ent->next)
    if (strcmp (ent->name, name) == 0)
      return;

  ent = (struct unique_sections *) xmalloc (sizeof *ent);
  ent->name = xstrdup (name);
  ent->next = unique_section_list;
  unique_section_list = ent;
@


1.1.1.9
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2001, 2002, 2003
d6 1
a6 1
   This file is part of GLD, the Gnu Linker.
d8 14
a21 14
   GLD is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GLD is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GLD; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
a25 1
#include "safe-ctype.h"
d31 1
a33 1
#include <ldgram.h>
d42 5
a46 3
#ifndef offsetof
#define offsetof(TYPE, MEMBER) ((size_t) & (((TYPE*) 0)->MEMBER))
#endif
d48 1
a48 1
/* Locals variables.  */
d55 1
a55 1
static bfd_boolean placed_commons = FALSE;
d57 1
a57 1
static bfd_boolean map_option_f;
a64 3
/* Forward declarations.  */
static lang_statement_union_type *new_statement
  PARAMS ((enum statement_enum, size_t, lang_statement_list_type *));
d69 6
a74 12
  PARAMS ((const char *, lang_input_file_enum_type, const char *,
	   bfd_boolean));
static lang_memory_region_type *lang_memory_default
  PARAMS ((asection *));
static void lang_map_flags
  PARAMS ((flagword));
static void init_os
  PARAMS ((lang_output_section_statement_type *));
static void exp_init_os
  PARAMS ((etree_type *));
static void section_already_linked
  PARAMS ((bfd *, asection *, PTR));
d77 3
a79 6
static void already_linked_table_init
  PARAMS ((void));
static void already_linked_table_free
  PARAMS ((void));
static bfd_boolean wildcardp
  PARAMS ((const char *));
d81 2
a82 2
  PARAMS ((lang_wild_statement_type *, struct wildcard_list *,
	   lang_input_statement_type *, asection *));
d84 1
a84 1
  PARAMS ((lang_wild_statement_type *, struct wildcard_list *, asection *,
d86 2
a87 3
static lang_input_statement_type *lookup_name
  PARAMS ((const char *));
static bfd_boolean load_symbols
d90 1
a90 1
  PARAMS ((lang_wild_statement_type *,
d92 5
a96 12
static bfd *open_output
  PARAMS ((const char *));
static void ldlang_open_output
  PARAMS ((lang_statement_union_type *));
static void open_input_bfds
  PARAMS ((lang_statement_union_type *, bfd_boolean));
static void lang_reasonable_defaults
  PARAMS ((void));
static void insert_undefined
  PARAMS ((const char *));
static void lang_place_undefineds
  PARAMS ((void));
a99 2
static void strip_excluded_output_sections
  PARAMS ((void));
d105 8
a112 16
static void print_input_statement
  PARAMS ((lang_input_statement_type *));
static bfd_boolean print_one_symbol
  PARAMS ((struct bfd_link_hash_entry *, PTR));
static void print_input_section
  PARAMS ((lang_input_section_type *));
static void print_fill_statement
  PARAMS ((lang_fill_statement_type *));
static void print_data_statement
  PARAMS ((lang_data_statement_type *));
static void print_address_statement
  PARAMS ((lang_address_statement_type *));
static void print_reloc_statement
  PARAMS ((lang_reloc_statement_type *));
static void print_padding_statement
  PARAMS ((lang_padding_statement_type *));
d121 3
a123 4
static void print_statements
  PARAMS ((void));
static void insert_pad
  PARAMS ((lang_statement_union_type **, fill_type *,
d127 10
a136 17
	   fill_type *, bfd_vma));
static void lang_finish
  PARAMS ((void));
static void ignore_bfd_errors
  PARAMS ((const char *, ...));
static void lang_check
  PARAMS ((void));
static void lang_common
  PARAMS ((void));
static bfd_boolean lang_one_common
  PARAMS ((struct bfd_link_hash_entry *, PTR));
static void lang_place_orphans
  PARAMS ((void));
static int topower
  PARAMS ((int));
static void lang_set_startof
  PARAMS ((void));
d138 1
a138 1
  PARAMS ((lang_wild_statement_type *, struct wildcard_list *, asection *,
d140 1
a140 5
static void lang_get_regions
  PARAMS ((struct memory_region_struct **, struct memory_region_struct **,
	   const char *, const char *, int));
static void lang_record_phdrs
  PARAMS ((void));
d142 3
a144 5
  PARAMS ((lang_wild_statement_type *));
static void lang_gc_sections_1
  PARAMS ((lang_statement_union_type *));
static void lang_gc_sections
  PARAMS ((void));
d151 2
a152 4
static void lang_do_version_exports_section
  PARAMS ((void));
static void lang_check_section_addresses
  PARAMS ((void));
d156 4
a159 7
static bfd_vma lang_size_sections_1
  PARAMS ((lang_statement_union_type *, lang_output_section_statement_type *,
	   lang_statement_union_type **, fill_type *, bfd_vma, bfd_boolean *,
	   bfd_boolean));
typedef void (*callback_t)
  PARAMS ((lang_wild_statement_type *, struct wildcard_list *, asection *,
	   lang_input_statement_type *, PTR));
d161 2
a162 1
  PARAMS ((lang_wild_statement_type *, callback_t, PTR));
d164 2
a165 2
  PARAMS ((lang_wild_statement_type *, lang_input_statement_type *,
	   callback_t, PTR));
d167 9
a175 14
  PARAMS ((lang_wild_statement_type *, lang_input_statement_type *,
	   callback_t, PTR));
static int get_target
  PARAMS ((const bfd_target *, PTR));
static void stricpy
  PARAMS ((char *, char *));
static void strcut
  PARAMS ((char *, char *));
static int name_compare
  PARAMS ((char *, char *));
static int closest_target_match
  PARAMS ((const bfd_target *, PTR));
static char * get_first_input_target
  PARAMS ((void));
d177 1
a177 1
/* Exported variables.  */
d182 6
a187 7
struct bfd_sym_chain entry_symbol = { NULL, NULL };
const char *entry_section = ".text";
bfd_boolean entry_from_cmdline;
bfd_boolean lang_has_input_file = FALSE;
bfd_boolean had_output_filename = FALSE;
bfd_boolean lang_float_flag = FALSE;
bfd_boolean delete_output_file_on_failure = FALSE;
a189 1
static bfd_boolean ldlang_sysrooted_script = FALSE;
d219 1
a219 1
bfd_boolean
d230 1
a230 1
	return TRUE;
d233 1
a233 1
  return FALSE;
d239 1
a239 1
walk_wild_section (ptr, file, callback, data)
d241 1
d246 2
a247 6
  asection *s;

  if (file->just_syms_flag)
    return;

  for (s = file->the_bfd->sections; s != NULL; s = s->next)
d249 4
a252 7
      struct wildcard_list *sec;

      sec = ptr->section_list;
      if (sec == NULL)
	(*callback) (ptr, sec, s, file, data);

      while (sec != NULL)
d254 1
a254 2
	  bfd_boolean skip = FALSE;
	  struct name_list *list_tmp;
d256 4
a259 10
	  /* Don't process sections from files which were
	     excluded.  */
	  for (list_tmp = sec->spec.exclude_name_list;
	       list_tmp;
	       list_tmp = list_tmp->next)
	    {
	      if (wildcardp (list_tmp->name))
		skip = fnmatch (list_tmp->name, file->filename, 0) == 0;
	      else
		skip = strcmp (list_tmp->name, file->filename) == 0;
d261 4
a264 14
	      /* If this file is part of an archive, and the archive is
		 excluded, exclude this file.  */
	      if (! skip && file->the_bfd != NULL
		  && file->the_bfd->my_archive != NULL
		  && file->the_bfd->my_archive->filename != NULL)
		{
		  if (wildcardp (list_tmp->name))
		    skip = fnmatch (list_tmp->name,
				    file->the_bfd->my_archive->filename,
				    0) == 0;
		  else
		    skip = strcmp (list_tmp->name,
				   file->the_bfd->my_archive->filename) == 0;
		}
d266 4
a269 3
	      if (skip)
		break;
	    }
d271 2
a272 3
	  if (!skip && sec->spec.name != NULL)
	    {
	      const char *sname = bfd_get_section_name (file->the_bfd, s);
d274 4
a277 5
	      if (wildcardp (sec->spec.name))
		skip = fnmatch (sec->spec.name, sname, 0) != 0;
	      else
		skip = strcmp (sec->spec.name, sname) != 0;
	    }
d279 6
a284 2
	  if (!skip)
	    (*callback) (ptr, sec, s, file, data);
d286 4
a289 1
	  sec = sec->next;
d297 1
a297 1
walk_wild_file (s, f, callback, data)
d299 1
d306 1
a306 1
    walk_wild_section (s, f, callback, data);
d323 1
a323 1
	      walk_wild_section (s,
d334 1
a334 1
walk_wild (s, callback, data)
d336 2
d341 1
a341 3
  const char *file_spec = s->filename;

  if (file_spec == NULL)
d346 1
a346 1
	  walk_wild_file (s, f, callback, data);
d349 1
a349 1
  else if (wildcardp (file_spec))
d353 2
a354 2
	  if (fnmatch (file_spec, f->filename, FNM_FILE_NAME) == 0)
	    walk_wild_file (s, f, callback, data);
d362 2
a363 3
      f = lookup_name (file_spec);
      if (f)
	walk_wild_file (s, f, callback, data);
d375 1
a375 1
  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
d456 1
a456 1
   they may, for example be split over several lines like foo.o(.text)
d465 1
a465 1
     bfd_boolean add_to_list;
d478 1
a478 1
  lang_has_input_file = TRUE;
a479 1
  p->sysrooted = FALSE;
d484 2
a485 2
      p->is_archive = FALSE;
      p->real = TRUE;
d487 2
a488 2
      p->just_syms_flag = TRUE;
      p->search_dirs_flag = FALSE;
d492 2
a493 2
      p->is_archive = FALSE;
      p->real = FALSE;
d495 2
a496 2
      p->just_syms_flag = FALSE;
      p->search_dirs_flag = FALSE;
d499 1
a499 1
      p->is_archive = TRUE;
d501 1
a501 1
      p->real = TRUE;
d503 2
a504 2
      p->just_syms_flag = FALSE;
      p->search_dirs_flag = TRUE;
d508 2
a509 2
      p->is_archive = FALSE;
      p->real = FALSE;
d511 2
a512 2
      p->just_syms_flag = FALSE;
      p->search_dirs_flag = TRUE;
a514 1
      p->sysrooted = ldlang_sysrooted_script;
d516 2
a517 2
      p->is_archive = FALSE;
      p->real = TRUE;
d519 2
a520 2
      p->just_syms_flag = FALSE;
      p->search_dirs_flag = TRUE;
d524 2
a525 2
      p->is_archive = FALSE;
      p->real = TRUE;
d527 2
a528 2
      p->just_syms_flag = FALSE;
      p->search_dirs_flag = FALSE;
d540 1
a540 1
  p->loaded = FALSE;
d553 2
a554 2
  lang_has_input_file = TRUE;
  return new_afile (name, file_type, target, TRUE);
a599 4
  /* NAME is NULL for LMA memspecs if no region was specified.  */
  if (name == NULL)
    return NULL;

d640 1
a640 1
    new->had_full_message = FALSE;
d705 1
a705 1
      lookup->fill = (fill_type *) 0;
d711 1
a711 1
      lookup->processed = FALSE;
a720 1
      lookup->update_dot_tree = NULL;
d816 1
a816 1
    einfo (_("%P%F: Illegal use of `%s' section\n"), DISCARD_SECTION_NAME);
a839 3

  if (s->load_base != NULL)
    exp_init_os (s->load_base);
d937 2
a938 1
      bfd_link_just_syms (sec, &link_info);
d961 1
a961 1
     causes trouble for MIPS ELF, which relies on link once semantics
d968 1
a968 1
     bfd_hash_lookup (&already_linked_table, name, TRUE, FALSE));
d1010 5
a1014 3
	  /* Set the output_section field so that lang_add_section
	     does not create a lang_input_section structure for this
	     section.  */
d1016 1
a1016 3

	  if (flags & SEC_GROUP)
	    bfd_discard_group (abfd, sec);
d1071 1
a1071 1
/* Return TRUE if the PATTERN argument is a wildcard pattern.
d1074 1
a1074 1
   be enough to cause the pattern to be treated as a wildcard.
d1077 1
a1077 1
static bfd_boolean
d1087 2
a1088 2
      return TRUE;
  return FALSE;
d1096 1
a1096 1
lang_add_section (ptr, section, output, file)
d1103 1
a1103 1
  bfd_boolean discard;
d1107 1
a1107 1
  discard = FALSE;
d1109 5
a1113 6
  /* Discard sections marked with SEC_EXCLUDE if we are doing a final
     link.  Discard debugging sections marked with SEC_EXCLUDE on a
     relocatable link too.  */
  if ((flags & SEC_EXCLUDE) != 0
      && ((flags & SEC_DEBUGGING) != 0 || !link_info.relocateable))
    discard = TRUE;
d1118 1
a1118 1
    discard = TRUE;
d1124 1
a1124 1
    discard = TRUE;
d1138 1
a1138 1
      bfd_boolean first;
a1180 15
      /* Keep SEC_MERGE and SEC_STRINGS only if they are the same.  */
      if (! first
	  && ((section->output_section->flags & (SEC_MERGE | SEC_STRINGS))
	      != (flags & (SEC_MERGE | SEC_STRINGS))
	      || ((flags & SEC_MERGE)
		  && section->output_section->entsize != section->entsize)))
	{
	  section->output_section->flags &= ~ (SEC_MERGE | SEC_STRINGS);
	  flags &= ~ (SEC_MERGE | SEC_STRINGS);
	}

      /* For now make .tbss normal section.  */
      if ((flags & SEC_THREAD_LOCAL) && ! link_info.relocateable)
	flags |= SEC_LOAD;

a1182 3
      if (flags & SEC_MERGE)
	section->output_section->entsize = section->entsize;

d1211 1
a1211 1
      /* If supplied an alignment, then force it.  */
d1230 1
a1230 1
wild_sort (wild, sec, file, section)
a1231 1
     struct wildcard_list *sec;
d1238 1
a1238 1
  if (!wild->filenames_sorted && (sec == NULL || !sec->spec.sorted))
d1242 1
a1242 1
  for (l = wild->children.head; l != NULL; l = l->header.next)
d1256 1
a1256 1
	  bfd_boolean fa, la;
d1268 1
a1268 1
	      fa = TRUE;
d1273 1
a1273 1
	      fa = FALSE;
d1280 1
a1280 1
	      la = TRUE;
d1285 1
a1285 1
	      la = FALSE;
d1312 1
a1312 1
      if (sec != NULL && sec->spec.sorted)
d1329 1
a1329 1
output_section_callback (ptr, sec, section, file, output)
a1330 1
     struct wildcard_list *sec;
a1336 4
  /* Exclude sections that match UNIQUE_SECTION_LIST.  */
  if (unique_section_p (bfd_get_section_name (file->the_bfd, section)))
    return;

d1342 1
a1342 1
  before = wild_sort (ptr, sec, file, section);
d1350 3
a1352 3
    lang_add_section (&ptr->children, section,
		      (lang_output_section_statement_type *) output,
		      file);
d1359 3
a1361 3
      lang_add_section (&list, section,
			(lang_output_section_statement_type *) output,
			file);
d1367 1
a1367 1
	  ASSERT (list.head->header.next == NULL);
d1371 1
a1371 1
	       pp = &(*pp)->header.next)
d1374 1
a1374 1
	  list.head->header.next = *pp;
d1404 1
a1404 1
			FALSE);
d1414 1
a1414 2
  if (! load_symbols (search, (lang_statement_list_type *) NULL))
    return NULL;
d1421 1
a1421 1
static bfd_boolean
d1429 1
a1429 1
    return TRUE;
a1437 2
      bfd_boolean bad_load = TRUE;
      bfd_boolean save_ldlang_sysrooted_script;
d1443 1
a1443 1
	return TRUE;
d1457 1
a1457 3
	  einfo (_("%F%B: file not recognized: %E\n"), entry->the_bfd);
      else
	bad_load = FALSE;
a1466 2
      save_ldlang_sysrooted_script = ldlang_sysrooted_script;
      ldlang_sysrooted_script = entry->sysrooted;
d1468 1
a1468 1
      ldfile_assumed_script = TRUE;
d1471 1
a1471 1
      ldfile_assumed_script = FALSE;
a1472 1
      ldlang_sysrooted_script = save_ldlang_sysrooted_script;
d1475 1
a1475 1
      return ! bad_load;
d1479 1
a1479 1
    return TRUE;
d1499 3
a1501 4
	  bfd *member = NULL;
	  bfd_boolean loaded = TRUE;

	  for (;;)
a1502 5
	      member = bfd_openr_next_archived_file (entry->the_bfd, member);

	      if (member == NULL)
		break;

d1504 2
a1505 6
		{
		  einfo (_("%F%B: member %B in archive is not an object\n"),
			 entry->the_bfd, member);
		  loaded = FALSE;
		}

a1508 1

d1510 3
a1512 4
		{
		  einfo (_("%F%B: could not read symbols: %E\n"), member);
		  loaded = FALSE;
		}
d1515 3
a1517 2
	  entry->loaded = loaded;
	  return loaded;
a1518 1
      break;
d1521 1
a1521 3
  if (bfd_link_add_symbols (entry->the_bfd, &link_info))
    entry->loaded = TRUE;
  else
d1524 1
a1524 1
  return entry->loaded;
d1527 4
a1530 5
/* Handle a wild statement.  S->FILENAME or S->SECTION_LIST or both
   may be NULL, indicating that it is a wildcard.  Separate
   lang_input_section statements are created for each part of the
   expansion; they are added after the wild statement S.  OUTPUT is
   the output section.  */
d1533 1
a1533 1
wild (s, target, output)
d1535 2
d1540 1
a1540 3
  struct wildcard_list *sec;

  walk_wild (s, output_section_callback, (PTR) output);
d1542 3
a1544 1
  for (sec = s->section_list; sec != NULL; sec = sec->next)
d1546 3
a1548 8
      if (default_common_section != NULL)
	break;
      if (sec->spec.name != NULL && strcmp (sec->spec.name, "COMMON") == 0)
	{
	  /* Remember the section that common is going to in case we
	     later get something which doesn't know where to put it.  */
	  default_common_section = output;
	}
d1552 1
a1552 1
/* Return TRUE iff target is the sought target.  */
d1574 6
a1579 1
    *dest++ = TOLOWER (c);
d1584 1
a1584 1
/* Remove the first occurrence of needle (if any) in haystack
a1716 23
const char *
lang_get_output_target ()
{
  const char *target;

  /* Has the user told us which output format to use?  */
  if (output_target != (char *) NULL)
    return output_target;

  /* No - has the current target been set to something other than
     the default?  */
  if (current_target != default_target)
    return current_target;

  /* No - can we determine the format of the first input file?  */
  target = get_first_input_target ();
  if (target != NULL)
    return target;

  /* Failed - use the default output target.  */
  return default_target;
}

d1725 18
a1742 1
  output_target = lang_get_output_target ();
d1802 1
a1802 1
  delete_output_file_on_failure = TRUE;
d1860 1
a1860 1
     bfd_boolean force;
d1862 1
a1862 1
  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
d1890 1
a1890 1
		open_input_bfds (s->group_statement.children.head, TRUE);
d1914 1
a1914 1
		s->input_statement.loaded = FALSE;
d1918 1
a1918 2
	      if (! load_symbols (&s->input_statement, &add))
		config.make_executable = FALSE;
d1922 2
a1923 2
		  *add.tail = s->header.next;
		  s->header.next = add.head;
d1945 1
a1945 1
  if (!placed_commons)
d1959 6
a1964 6
   This is a two step process as the symbol table doesn't even exist at
   the time the ld command line is processed.  First we put the name
   on a list, then, once the output file has been opened, transfer the
   name to the symbol table.  */

typedef struct bfd_sym_chain ldlang_undef_chain_list_type;
d1966 1
a1966 1
#define ldlang_undef_chain_list_head entry_symbol.next
a1979 22

  if (output_bfd != NULL)
    insert_undefined (new->name);
}

/* Insert NAME as undefined in the symbol table.  */

static void
insert_undefined (name)
     const char *name;
{
  struct bfd_link_hash_entry *h;

  h = bfd_link_hash_lookup (link_info.hash, name, TRUE, FALSE, TRUE);
  if (h == (struct bfd_link_hash_entry *) NULL)
    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
  if (h->type == bfd_link_hash_new)
    {
      h->type = bfd_link_hash_undefined;
      h->u.undef.abfd = NULL;
      bfd_link_add_undef (link_info.hash, h);
    }
d1995 11
a2005 1
      insert_undefined (ptr->name);
d2009 1
a2009 1
/* Open input files and attach to output sections.  */
d2017 1
a2017 1
  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
d2021 1
d2023 4
a2026 1
	  wild (&s->wild_statement, target, output_section_statement);
a2086 35
/* An output section might have been removed after its statement was
   added.  For example, ldemul_before_allocation can remove dynamic
   sections if they turn out to be not needed.  Clean them up here.  */

static void
strip_excluded_output_sections ()
{
  lang_statement_union_type *u;

  for (u = lang_output_section_statement.head;
       u != NULL;
       u = u->output_section_statement.next)
    {
      lang_output_section_statement_type *os;
      asection *s;

      os = &u->output_section_statement;
      s = os->bfd_section;
      if (s != NULL && (s->flags & SEC_EXCLUDE) != 0)
	{
	  asection **p;

	  os->bfd_section = NULL;

	  for (p = &output_bfd->sections; *p; p = &(*p)->next)
	    if (*p == s)
	      {
		bfd_section_list_remove (output_bfd, p);
		output_bfd->section_count--;
		break;
	      }
	}
    }
}

d2147 1
a2147 11
    {
      const char *dst;
      bfd_vma value;

      value = result.value + result.section->bfd_section->vma;
      dst = assignment->exp->assign.dst;

      minfo ("0x%V", value);
      if (dst[0] == '.' && dst[1] == 0)
	print_dot = value;
    }
d2176 1
a2176 1
static bfd_boolean
d2199 1
a2199 1
  return TRUE;
d2266 1
a2266 6
  size_t size;
  unsigned char *p;
  fputs (" FILL mask 0x", config.map_file);
  for (p = fill->fill->data, size = fill->fill->size; size != 0; p++, size--)
    fprintf (config.map_file, "%02x", *p);
  fputs ("\n", config.map_file);
d2395 1
a2395 1
  minfo ("0x%V %W ", addr, s->size);
d2397 2
a2398 7
  if (s->fill->size != 0)
    {
      size_t size;
      unsigned char *p;
      for (p = s->fill->data, size = s->fill->size; size != 0; p++, size--)
	fprintf (config.map_file, "%02x", *p);
    }
a2409 2
  struct wildcard_list *sec;

d2414 8
d2430 8
a2437 21
  for (sec = w->section_list; sec; sec = sec->next)
    {
      if (sec->spec.sorted)
	minfo ("SORT(");
      if (sec->spec.exclude_name_list != NULL)
	{
	  name_list *tmp;
	  minfo ("EXCLUDE_FILE(%s", sec->spec.exclude_name_list->name);
	  for (tmp = sec->spec.exclude_name_list->next; tmp; tmp = tmp->next)
	    minfo (" %s", tmp->name);
	  minfo (") ");
	}
      if (sec->spec.name != NULL)
	minfo ("%s", sec->spec.name);
      else
	minfo ("*");
      if (sec->spec.sorted)
	minfo (")");
      if (sec->next)
	minfo (" ");
    }
d2468 1
a2468 1
      s = s->header.next;
d2574 1
a2574 1
	  s = s->header.next;
d2581 6
a2586 6
static void
insert_pad (ptr, fill, alignment_needed, output_section, dot)
     lang_statement_union_type **ptr;
     fill_type *fill;
     unsigned int alignment_needed;
     asection *output_section;
d2589 6
a2594 2
  static fill_type zero_fill = { 1, { 0 } };
  lang_statement_union_type *pad;
d2596 5
a2600 5
  pad = ((lang_statement_union_type *)
	 ((char *) ptr - offsetof (lang_statement_union_type, header.next)));
  if (ptr != &statement_list.head
      && pad->header.type == lang_padding_statement_enum
      && pad->padding_statement.output_section == output_section)
d2602 13
a2614 2
      /* Use the existing pad statement.  The above test on output
	 section is probably redundant, but it doesn't hurt to check.  */
d2616 3
a2618 1
  else
d2620 5
a2624 14
      /* Make a new padding statement, linked into existing chain.  */
      pad = ((lang_statement_union_type *)
	     stat_alloc (sizeof (lang_padding_statement_type)));
      pad->header.next = *ptr;
      *ptr = pad;
      pad->header.type = lang_padding_statement_enum;
      pad->padding_statement.output_section = output_section;
      if (fill == (fill_type *) 0)
	fill = &zero_fill;
      pad->padding_statement.fill = fill;
    }
  pad->padding_statement.output_offset = dot - output_section->vma;
  pad->padding_statement.size = alignment_needed;
  output_section->_raw_size += alignment_needed;
d2630 1
a2630 1
size_input_section (this_ptr, output_section_statement, fill, dot)
d2633 1
a2633 1
     fill_type *fill;
d2635 1
d2639 2
d2642 1
a2642 1
  if (!is->ifile->just_syms_flag)
a2643 10
      unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						    ldfile_output_machine);
      unsigned int alignment_needed;
      asection *o;

      /* Align this section first to the input sections requirement,
	 then to the output section's requirement.  If this alignment
	 is greater than any seen before, then record it too.  Perform
	 the alignment by inserting a magic 'padding' statement.  */

d2645 2
a2646 5
	i->alignment_power = output_section_statement->subsection_alignment;

      o = output_section_statement->bfd_section;
      if (o->alignment_power < i->alignment_power)
	o->alignment_power = i->alignment_power;
d2648 2
a2649 7
      alignment_needed = align_power (dot, i->alignment_power) - dot;

      if (alignment_needed != 0)
	{
	  insert_pad (this_ptr, fill, alignment_needed * opb, o, dot);
	  dot += alignment_needed;
	}
d2653 1
a2653 1
      i->output_offset = dot - o->vma;
d2660 2
a2661 1
      o->_raw_size = (dot - o->vma) * opb;
d2732 5
d2752 1
a2752 1
	  || base == 0))
d2755 7
a2761 7
	{
	  einfo (_("%X%P: address 0x%v of %B section %s is not within region %s\n"),
		 region->current,
		 os->bfd_section->owner,
		 os->bfd_section->name,
		 region->name);
	}
d2763 6
a2768 6
	{
	  einfo (_("%X%P: region %s is full (%B section %s)\n"),
		 region->name,
		 os->bfd_section->owner,
		 os->bfd_section->name);
	}
d2776 2
a2777 3
static bfd_vma
lang_size_sections_1 (s, output_section_statement, prev, fill, dot, relax,
		      check_regions)
d2781 1
a2781 1
     fill_type *fill;
d2783 1
a2783 2
     bfd_boolean *relax;
     bfd_boolean check_regions;
d2789 1
a2789 1
  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
d2812 1
a2812 1
		    || os->children.head->header.next != NULL
a2849 2
			&& (bfd_get_section_flags (output_bfd, os->bfd_section)
			    & SEC_NEVER_LOAD) == 0
a2850 1
			&& check_regions
d2883 5
a2887 4
		    if (!r.valid_p)
		      einfo (_("%F%S: non constant address expression for section %s\n"),
			     os->name);

d2902 3
a2904 2
	    lang_size_sections_1 (os->children.head, os, &os->children.head,
				  os->fill, dot, relax, check_regions);
d2908 1
a2908 1
	    after = align_n (os->bfd_section->vma
d2910 1
a2914 4
	    else if ((os->bfd_section->flags & SEC_HAS_CONTENTS) == 0
		     && (os->bfd_section->flags & SEC_THREAD_LOCAL)
		     && ! link_info.relocateable)
	      os->bfd_section->_raw_size = 0;
a2917 1

d2919 1
a2919 5
	    os->processed = TRUE;

	    if (os->update_dot_tree != 0)
	      exp_fold_tree (os->update_dot_tree, abs_output_section,
			     lang_allocating_phase_enum, dot, &dot);
d2937 3
a2939 4
		if (check_regions)
		  /* Make sure the new address is within the region.  */
		  os_region_check (os, os->region, os->addr_tree,
				   os->bfd_section->vma);
d2946 1
a2946 1
		if (os->lma_region != NULL && os->lma_region != os->region)
d2948 18
a2965 7
		    /* Set load_base, which will be handled later.  */
		    os->load_base = exp_intop (os->lma_region->current);
		    os->lma_region->current +=
		      os->bfd_section->_raw_size / opb;
		    if (check_regions)
		      os_region_check (os, os->lma_region, NULL,
				       os->bfd_section->lma);
d2972 5
a2976 4
	  dot = lang_size_sections_1 (constructor_list.head,
				      output_section_statement,
				      &s->wild_statement.children.head,
				      fill, dot, relax, check_regions);
d3037 4
a3040 4
	  dot = lang_size_sections_1 (s->wild_statement.children.head,
				      output_section_statement,
				      &s->wild_statement.children.head,
				      fill, dot, relax, check_regions);
d3063 1
a3063 1
		bfd_boolean again;
d3068 1
a3068 1
		  *relax = TRUE;
d3070 4
a3073 2
	    dot = size_input_section (prev, output_section_statement,
				      output_section_statement->fill, dot);
d3096 1
d3103 1
a3103 1
		else
d3105 16
a3120 8
		    /* Insert a pad after this statement.  We can't
		       put the pad before when relaxing, in case the
		       assignment references dot.  */
		    insert_pad (&s->header.next, fill, (newdot - dot) * opb,
				output_section_statement->bfd_section, dot);

		    /* Don't neuter the pad below when relaxing.  */
		    s = s->header.next;
d3129 10
a3138 14
	  /* If this is the first time lang_size_sections is called,
	     we won't have any padding statements.  If this is the
	     second or later passes when relaxing, we should allow
	     padding to shrink.  If padding is needed on this pass, it
	     will be added back in.  */
	  s->padding_statement.size = 0;

	  /* Make sure output_offset is valid.  If relaxation shrinks
	     the section and this pad isn't needed, it's possible to
	     have output_offset larger than the final size of the
	     section.  bfd_set_section_contents will complain even for
	     a pad size of zero.  */
	  s->padding_statement.output_offset
	    = dot - output_section_statement->bfd_section->vma;
d3142 4
a3145 4
	  dot = lang_size_sections_1 (s->group_statement.children.head,
				      output_section_statement,
				      &s->group_statement.children.head,
				      fill, dot, relax, check_regions);
d3152 2
a3153 1
	  /* We can only get here when relaxing is turned on.  */
a3162 38
lang_size_sections (s, output_section_statement, prev, fill, dot, relax,
		    check_regions)
     lang_statement_union_type *s;
     lang_output_section_statement_type *output_section_statement;
     lang_statement_union_type **prev;
     fill_type *fill;
     bfd_vma dot;
     bfd_boolean *relax;
     bfd_boolean check_regions;
{
  bfd_vma result;

  exp_data_seg.phase = exp_dataseg_none;
  result = lang_size_sections_1 (s, output_section_statement, prev, fill,
				 dot, relax, check_regions);
  if (exp_data_seg.phase == exp_dataseg_end_seen)
    {
      /* If DATA_SEGMENT_ALIGN DATA_SEGMENT_END pair was seen, check whether
	 a page could be saved in the data segment.  */
      bfd_vma first, last;

      first = -exp_data_seg.base & (exp_data_seg.pagesize - 1);
      last = exp_data_seg.end & (exp_data_seg.pagesize - 1);
      if (first && last
	  && ((exp_data_seg.base & ~(exp_data_seg.pagesize - 1))
	      != (exp_data_seg.end & ~(exp_data_seg.pagesize - 1)))
	  && first + last <= exp_data_seg.pagesize)
	{
	  exp_data_seg.phase = exp_dataseg_adjust;
	  result = lang_size_sections_1 (s, output_section_statement, prev,
					 fill, dot, relax, check_regions);
	}
    }

  return result;
}

bfd_vma
d3166 1
a3166 1
     fill_type *fill;
d3172 1
a3172 1
  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
d3232 1
a3232 1
	    if (!value.valid_p)
d3235 2
a3236 2
	  {
	    unsigned int size;
d3269 1
a3269 1
	    if (!value.valid_p)
d3348 1
a3348 1
      h = bfd_link_hash_lookup (link_info.hash, buf, FALSE, FALSE, TRUE);
d3357 1
a3357 1
      h = bfd_link_hash_lookup (link_info.hash, buf, FALSE, FALSE, TRUE);
d3360 1
a3360 1
	  unsigned opb;
d3362 1
a3362 1
	  opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
d3380 1
a3380 1
  bfd_boolean warn;
d3383 1
a3383 1
    warn = FALSE;
d3385 1
a3385 1
    warn = TRUE;
d3387 1
a3387 1
  if (entry_symbol.name == (const char *) NULL)
d3391 2
a3392 2
      entry_symbol.name = "start";
      warn = FALSE;
d3395 1
a3395 2
  h = bfd_link_hash_lookup (link_info.hash, entry_symbol.name,
			    FALSE, FALSE, TRUE);
d3408 1
a3408 1
	einfo (_("%P%F:%s: can't set start address\n"), entry_symbol.name);
d3417 1
a3417 1
      val = bfd_scan_vma (entry_symbol.name, &send, 0);
d3429 1
a3429 1
	  ts = bfd_get_section_by_name (output_bfd, entry_section);
d3434 1
a3434 2
		       entry_symbol.name,
		       bfd_get_section_vma (output_bfd, ts));
d3444 1
a3444 1
		       entry_symbol.name);
d3480 2
a3481 20
      compatible = bfd_arch_get_compatible (input_bfd, output_bfd,
					    command_line.accept_unknown_input_arch);

      /* In general it is not possible to perform a relocatable
	 link between differing object formats when the input
	 file has relocations, because the relocations in the
	 input format may not have equivalent representations in
	 the output format (and besides BFD does not translate
	 relocs for other link purposes than a final link).  */
      if ((link_info.relocateable || link_info.emitrelocations)
	  && (compatible == NULL
	      || bfd_get_flavour (input_bfd) != bfd_get_flavour (output_bfd))
	  && (bfd_get_file_flags (input_bfd) & HAS_RELOC) != 0)
	{
	  einfo (_("%P%F: Relocatable linking with relocations from format %s (%B) to format %s (%B) is not supported\n"),
		 bfd_get_target (input_bfd), input_bfd,
		 bfd_get_target (output_bfd), output_bfd);
	  /* einfo with %F exits.  */
	}

d3492 1
a3492 1
	     private data of the output bfd.  */
a3521 2
  if (command_line.inhibit_common_definition)
    return;
d3540 1
a3540 1
static bfd_boolean
d3552 1
a3552 1
    return TRUE;
d3559 1
a3559 1
    return TRUE;
d3564 2
a3565 2
  section->_cooked_size = align_n ((section->_cooked_size + opb - 1) / opb,
				   (bfd_vma) 1 << power_of_two) * opb;
d3586 1
a3586 1
      static bfd_boolean header_printed;
d3595 1
a3595 1
	  header_printed = TRUE;
d3631 1
a3631 1
  return TRUE;
d3651 1
a3651 1
	      /* This section of the file is not attached, root
d3656 5
a3660 1
		  abort ();
d3682 2
a3683 2
		      lang_add_section (&default_common_section->children, s,
					default_common_section, file);
d3690 2
a3691 1
		  lang_output_section_statement_type *os;
d3693 1
a3693 2
		  os = lang_output_section_statement_lookup (s->name);
		  lang_add_section (&os->children, s, os, file);
d3835 1
a3835 1
  if (!had_output_filename || !from_script)
d3838 1
a3838 1
      had_output_filename = TRUE;
d3921 2
a3922 2
void
lang_reset_memory_regions ()
a3924 1
  asection *o;
a3932 3

  for (o = output_bfd->sections; o != NULL; o = o->next)
    o->_raw_size = 0;
d3935 2
a3936 2
/* If the wild pattern was marked KEEP, the member sections
   should be as well.  */
d3939 1
a3939 1
gc_section_callback (ptr, sec, section, file, data)
a3940 1
     struct wildcard_list *sec ATTRIBUTE_UNUSED;
d3945 2
d3951 2
a3952 1
/* Handle a wild statement, marking it against GC.  */
d3955 1
a3955 1
lang_gc_wild (s)
d3957 2
d3960 1
a3960 1
  walk_wild (s, gc_section_callback, NULL);
d3969 1
a3969 1
  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
d3974 3
a3976 1
	  lang_gc_wild (&s->wild_statement);
d3997 1
a3997 1
  ldlang_undef_chain_list_type *ulist;
d4003 2
a4004 2
  /* Keep all sections containing symbols undefined on the command-line,
     and the section containing the entry symbol.  */
d4006 10
a4015 1
  for (ulist = link_info.gc_sym_list; ulist; ulist = ulist->next)
d4018 1
a4018 1
				FALSE, FALSE, FALSE);
d4050 1
a4050 5
  open_input_bfds (statement_list.head, FALSE);

  link_info.gc_sym_list = &entry_symbol;
  if (entry_symbol.name == NULL)
    link_info.gc_sym_list = ldlang_undef_chain_list_head;
a4074 6
  /* If there were any SEC_MERGE sections, finish their merging, so that
     section sizes can be computed.  This has to be done after GC of sections,
     so that GCed sections are not merged, but before assigning output
     sections, since removing whole input sections is hard then.  */
  bfd_merge_sections (output_bfd, &link_info);

a4085 16
  if (! link_info.relocateable)
    {
      /* Look for a text section and set the readonly attribute in it.  */
      asection *found = bfd_get_section_by_name (output_bfd, ".text");

      if (found != (asection *) NULL)
	{
	  if (config.text_read_only)
	    found->flags |= SEC_READONLY;
	  else
	    found->flags &= ~SEC_READONLY;
	}
    }

  /* Do anything special before sizing sections.  This is where ELF
     and other back-ends size dynamic sections.  */
a4087 3
  if (!link_info.relocateable)
    strip_excluded_output_sections ();

a4091 6
  /* Size up the sections.  */
  lang_size_sections (statement_list.head,
		      abs_output_section,
		      &statement_list.head, 0, (bfd_vma) 0, NULL,
		      command_line.relax ? FALSE : TRUE);

d4095 6
a4101 2
      bfd_boolean relax_again;

d4104 1
a4104 1
	  lang_reset_memory_regions ();
d4106 1
a4106 1
	  relax_again = FALSE;
d4116 1
a4116 1
			       (fill_type *) 0, (bfd_vma) 0);
d4119 1
a4119 1
	     globals are, so can make a better guess.  */
d4122 1
a4122 10
			      &statement_list.head, 0, (bfd_vma) 0,
			      &relax_again, FALSE);

	  /* If the normal relax is done and the relax finalize pass
	     is not performed yet, we perform another relax pass.  */
	  if (!relax_again && !link_info.relax_finalizing)
	    {
	      link_info.relax_finalizing = TRUE;
	      relax_again = TRUE;
	    }
d4125 4
a4128 6

      /* Final extra sizing to report errors.  */
      lang_reset_memory_regions ();
      lang_do_assignments (statement_list.head,
			   abs_output_section,
			   (fill_type *) 0, (bfd_vma) 0);
d4131 1
a4131 2
			  & statement_list.head, 0, (bfd_vma) 0, 
			  NULL, TRUE);
d4146 1
a4146 1
		       (fill_type *) 0, (bfd_vma) 0);
d4162 8
a4169 4
lang_add_wild (filespec, section_list, keep_sections)
     struct wildcard_spec *filespec;
     struct wildcard_list *section_list;
     bfd_boolean keep_sections;
d4171 2
a4172 2
  struct wildcard_list *curr, *next;
  lang_wild_statement_type *new;
d4174 1
a4174 4
  /* Reverse the list as the parser puts it back to front.  */
  for (curr = section_list, section_list = NULL;
       curr != NULL;
       section_list = curr, curr = next)
d4176 1
a4176 5
      if (curr->spec.name != NULL && strcmp (curr->spec.name, "COMMON") == 0)
	placed_commons = TRUE;

      next = curr->next;
      curr->next = section_list;
d4178 1
a4178 13

  if (filespec != NULL && filespec->name != NULL)
    {
      if (strcmp (filespec->name, "*") == 0)
	filespec->name = NULL;
      else if (! wildcardp (filespec->name))
	lang_has_input_file = TRUE;
    }

  new = new_stat (lang_wild_statement, stat_ptr);
  new->filename = NULL;
  new->filenames_sorted = FALSE;
  if (filespec != NULL)
d4180 1
a4180 2
      new->filename = filespec->name;
      new->filenames_sorted = filespec->sorted;
d4182 4
a4185 1
  new->section_list = section_list;
d4187 1
d4211 1
a4211 1
     bfd_boolean cmdline;
d4213 1
a4213 1
  if (entry_symbol.name == NULL
d4217 1
a4217 1
      entry_symbol.name = name;
d4242 1
a4242 1
	  map_option_f = TRUE;
d4250 2
a4251 2
lang_add_fill (fill)
     fill_type *fill;
d4256 1
a4256 1
  new->fill = fill;
d4329 1
a4329 1
  first_file->real = TRUE;
d4336 1
a4336 1
     bfd_boolean maybe;
a4340 30

/* Work out the load- and run-time regions from a script statement, and
   store them in *LMA_REGION and *REGION respectively.

   MEMSPEC is the name of the run-time region, or "*default*" if the
   statement didn't specify one.  LMA_MEMSPEC is the name of the
   load-time region, or null if the statement didn't specify one.
   HAVE_LMA_P is TRUE if the statement had an explicit load address.

   It is an error to specify both a load region and a load address.  */

static void
lang_get_regions (region, lma_region, memspec, lma_memspec, have_lma_p)
     struct memory_region_struct **region, **lma_region;
     const char *memspec, *lma_memspec;
     int have_lma_p;
{
  *lma_region = lang_memory_region_lookup (lma_memspec);

  /* If no runtime region has been given, but the load region has
     been, use the load region.  */
  if (lma_memspec != 0 && strcmp (memspec, "*default*") == 0)
    *region = *lma_region;
  else
    *region = lang_memory_region_lookup (memspec);

  if (have_lma_p && lma_memspec != 0)
    einfo (_("%X%P:%S: section has both a load address and a load region\n"));
}

d4343 1
a4343 1
     fill_type *fill;
a4347 4
  lang_get_regions (&current_section->region,
		    &current_section->lma_region,
		    memspec, lma_memspec,
		    current_section->load_base != 0);
d4349 9
d4374 1
a4374 1
  h = bfd_link_hash_lookup (link_info.hash, name, TRUE, TRUE, TRUE);
d4407 1
a4407 1
  h = bfd_link_hash_lookup (link_info.hash, name, TRUE, TRUE, TRUE);
d4493 2
a4494 2
     bfd_boolean filehdr;
     bfd_boolean phdrs;
d4573 1
a4573 1
		  pl->used = TRUE;
d4631 1
a4631 1
  link_info.notice_all = TRUE;
d4639 6
d4660 1
a4660 1
lang_enter_overlay (vma_expr)
d4662 2
d4666 4
a4669 1
  ASSERT (overlay_vma == NULL && overlay_max == NULL);
d4672 2
d4677 1
a4677 2
   lang_enter_output_section_statement with the correct VMA.
   lang_leave_overlay sets up the LMA and memory regions.  */
d4687 1
a4687 1
				       0, 0, 0, 0);
d4689 1
a4689 1
  /* If this is the first section, then base the VMA of future
d4693 4
a4696 1
    overlay_vma = exp_nameop (ADDR, name);
d4706 3
d4721 1
a4721 1
     fill_type *fill;
d4731 2
a4732 4
  /* For now, assume that "*default*" is the run-time memory region and
     that no load-time region has been specified.  It doesn't really
     matter what we say here, since lang_leave_overlay will override it.  */
  lang_leave_output_section_statement (fill, "*default*", phdrs, 0);
d4739 1
a4739 1
    if (ISALNUM (*s1) || *s1 == '_')
d4762 2
a4763 4
lang_leave_overlay (lma_expr, nocrossrefs, fill, memspec, phdrs, lma_memspec)
     etree_type *lma_expr;
     int nocrossrefs;
     fill_type *fill;
d4773 9
a4781 3
  lang_get_regions (&region, &lma_region,
		    memspec, lma_memspec,
		    lma_expr != 0);
a4784 6
  /* After setting the size of the last section, set '.' to end of the
     overlay region.  */
  if (overlay_list != NULL)
    overlay_list->os->update_dot_tree
      = exp_assop ('=', ".", exp_binop ('+', overlay_vma, overlay_max));

d4790 1
a4790 1
      if (fill != (fill_type *) 0 && l->os->fill == (fill_type *) 0)
d4792 11
a4802 15

      l->os->region = region;
      l->os->lma_region = lma_region;

      /* The first section has the load address specified in the
	 OVERLAY statement.  The rest are worked out from that.
	 The base address is not needed (and should be null) if
	 an LMA region was specified.  */
      if (l->next == 0)
	l->os->load_base = lma_expr;
      else if (lma_region == 0)
	l->os->load_base = exp_binop ('+',
				      exp_nameop (LOADADDR, l->next->os->name),
				      exp_nameop (SIZEOF, l->next->os->name));

d4806 1
a4806 1
      if (nocrossrefs)
d4824 4
d4829 2
d4866 1
a4866 1
	 Should we early out FALSE in this case?  */
d4893 1
a4893 1
	 Should we early out FALSE in this case?  */
d4908 1
a4908 1
lang_new_vers_pattern (orig, new, lang)
a4917 2
  ret->symver = 0;
  ret->script = 0;
d4932 1
a4932 1
  return ldemul_new_vers_pattern (ret);
a4972 11
  if (name == NULL)
    name = "";

  if ((name[0] == '\0' && lang_elf_version_info != NULL)
      || (lang_elf_version_info && lang_elf_version_info->name[0] == '\0'))
    {
      einfo (_("%X%P: anonymous version tag cannot be combined with other version tags\n"));
      free (version);
      return;
    }

d5009 2
a5010 7
  if (name[0] != '\0')
    {
      ++version_index;
      version->vernum = version_index;
    }
  else
    version->vernum = 0;
d5056 1
a5056 1
	continue;
d5061 1
a5061 1
	einfo (_("%X%P: unable to read .exports section contents\n"), sec);
d5066 1
a5066 1
	  greg = lang_new_vers_pattern (greg, p, NULL);
d5077 1
a5077 1
  lreg = lang_new_vers_pattern (NULL, "*", NULL);
@


1.1.1.10
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004
a41 1
#include "hashtab.h"
a62 1
static struct bfd_hash_table lang_definedness_table;
d65 163
a227 19
static void exp_init_os (etree_type *);
static bfd_boolean wildcardp (const char *);
static lang_input_statement_type *lookup_name (const char *);
static bfd_boolean load_symbols (lang_input_statement_type *,
				 lang_statement_list_type *);
static struct bfd_hash_entry *lang_definedness_newfunc
 (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
static void insert_undefined (const char *);
static void print_statement (lang_statement_union_type *,
			     lang_output_section_statement_type *);
static void print_statement_list (lang_statement_union_type *,
				  lang_output_section_statement_type *);
static void print_statements (void);
static bfd_boolean lang_one_common (struct bfd_link_hash_entry *, void *);
static void lang_record_phdrs (void);
static void lang_do_version_exports_section (void);

typedef void (*callback_t) (lang_wild_statement_type *, struct wildcard_list *,
			    asection *, lang_input_statement_type *, void *);
a243 1
int lang_statement_iteration = 0;
d247 8
d256 1
a256 1
  (x##_type *) new_statement (x##_enum, sizeof (x##_type), y)
d266 3
a268 2
void *
stat_alloc (size_t size)
d274 2
a275 1
unique_section_p (const char *secnam)
d293 5
a297 4
walk_wild_section (lang_wild_statement_type *ptr,
		   lang_input_statement_type *file,
		   callback_t callback,
		   void *data)
d368 5
a372 4
walk_wild_file (lang_wild_statement_type *s,
		lang_input_statement_type *f,
		callback_t callback,
		void *data)
d383 1
a383 1
      member = bfd_openr_next_archived_file (f->the_bfd, NULL);
d393 3
a395 1
	      walk_wild_section (s, member->usrdata, callback, data);
d404 4
a407 1
walk_wild (lang_wild_statement_type *s, callback_t callback, void *data)
d442 3
a444 2
lang_for_each_statement_worker (void (*func) (lang_statement_union_type *),
				lang_statement_union_type *s)
d446 1
a446 1
  for (; s != NULL; s = s->header.next)
d489 2
a490 1
lang_for_each_statement (void (*func) (lang_statement_union_type *))
d498 2
a499 1
lang_list_init (lang_statement_list_type *list)
d501 1
a501 1
  list->head = NULL;
d508 4
a511 3
new_statement (enum statement_enum type,
	       size_t size,
	       lang_statement_list_type *list)
d513 2
a514 1
  lang_statement_union_type *new;
a515 1
  new = stat_alloc (size);
d517 1
a517 1
  new->header.next = NULL;
d532 5
a536 4
new_afile (const char *name,
	   lang_input_file_enum_type file_type,
	   const char *target,
	   bfd_boolean add_to_list)
d544 2
a545 1
      p = stat_alloc (sizeof (lang_input_statement_type));
d574 1
a574 1
      p->local_sym_name = concat ("-l", name, NULL);
d606 4
a609 4
  p->the_bfd = NULL;
  p->asymbols = NULL;
  p->next_real_file = NULL;
  p->next = NULL;
a611 1
  p->as_needed = as_needed;
d621 4
a624 3
lang_add_input_file (const char *name,
		     lang_input_file_enum_type file_type,
		     const char *target)
d633 1
a633 1
lang_init (void)
d644 3
a646 2
  first_file = lang_add_input_file (NULL, lang_input_file_is_marker_enum,
				    NULL);
a651 12
  /* The value "3" is ad-hoc, somewhat related to the expected number of
     DEFINED expressions in a linker script.  For most default linker
     scripts, there are none.  Why a hash table then?  Well, it's somewhat
     simpler to re-use working machinery than using a linked list in terms
     of code-complexity here in ld, besides the initialization which just
     looks like other code here.  */
  if (bfd_hash_table_init_n (&lang_definedness_table,
			     lang_definedness_newfunc, 3) != TRUE)
    einfo (_("%P%F: out of memory during initialization"));

  /* Callers of exp_fold_tree need to increment this.  */
  lang_statement_iteration = 0;
d662 1
a662 7
  which is created when looked up to be the entire data space.

  If create is true we are creating a region inside a MEMORY block.
  In this case it is probably an error to create a region that has
  already been created.  If we are not inside a MEMORY block it is
  dubious to use an undeclared region name (except DEFAULT_MEMORY_REGION)
  and so we issue a warning.  */
d668 2
a669 1
lang_memory_region_lookup (const char *const name, bfd_boolean create)
a671 1
  lang_memory_region_type *new;
d677 9
a685 7
  for (p = lang_memory_region_list; p != NULL; p = p->next)
    if (strcmp (p->name, name) == 0)
      {
	if (create)
	  einfo (_("%P:%S: warning: redeclaration of memory region '%s'\n"), name);
	return p;
      }
d694 1
a694 1
  if (strcmp (name, DEFAULT_MEMORY_REGION) == 0)
d696 4
a699 2
      if (lang_memory_region_list != NULL)
	return lang_memory_region_list;
d703 15
a717 2
  if (!create && strcmp (name, DEFAULT_MEMORY_REGION))
    einfo (_("%P:%S: warning: memory region %s not declared\n"), name);
d719 2
a720 15
  new = stat_alloc (sizeof (lang_memory_region_type));

  new->name = xstrdup (name);
  new->next = NULL;

  *lang_memory_region_list_tail = new;
  lang_memory_region_list_tail = &new->next;
  new->origin = 0;
  new->flags = 0;
  new->not_flags = 0;
  new->length = ~(bfd_size_type) 0;
  new->current = 0;
  new->had_full_message = FALSE;

  return new;
d724 2
a725 1
lang_memory_default (asection *section)
d735 3
a737 1
  for (p = lang_memory_region_list; p != NULL; p = p->next)
d745 1
a745 1
  return lang_memory_region_lookup (DEFAULT_MEMORY_REGION, FALSE);
d749 2
a750 1
lang_output_section_find (const char *const name)
d755 3
a757 1
  for (u = lang_output_section_statement.head; u != NULL; u = lookup->next)
d761 3
a763 1
	return lookup;
d765 1
a765 1
  return NULL;
d769 2
a770 1
lang_output_section_statement_lookup (const char *const name)
d775 1
a775 1
  if (lookup == NULL)
d777 6
a782 4
      lookup = new_stat (lang_output_section_statement, stat_ptr);
      lookup->region = NULL;
      lookup->lma_region = NULL;
      lookup->fill = 0;
d786 3
a788 3
      lookup->next = NULL;
      lookup->bfd_section = NULL;
      lookup->processed = 0;
d790 1
a790 1
      lookup->addr_tree = NULL;
d793 1
a793 1
      lookup->memspec = NULL;
d797 1
a797 1
      lookup->load_base = NULL;
d809 2
a810 1
lang_map_flags (flagword flag)
d829 1
a829 1
lang_map (void)
d837 3
a839 1
  for (m = lang_memory_region_list; m != NULL; m = m->next)
d885 2
a886 1
init_os (lang_output_section_statement_type *s)
d896 2
a897 1
  new = stat_alloc (sizeof (section_userdata_type));
d900 1
a900 1
  if (s->bfd_section == NULL)
d902 1
a902 1
  if (s->bfd_section == NULL)
d912 1
a912 1
  get_userdata (s->bfd_section) = new;
d927 2
a928 1
exp_init_os (etree_type *exp)
a946 4
    case etree_assert:
      exp_init_os (exp->assert_s.child);
      break;
      
d1003 4
a1006 1
section_already_linked (bfd *abfd, asection *sec, void *data)
d1008 1
a1008 1
  lang_input_statement_type *entry = data;
d1092 1
a1092 3
	     section.  Since there might be a symbol in the section
	     being discarded, we must retain a pointer to the section
	     which we are really going to use.  */
a1093 1
	  sec->kept_section = l->sec;
d1105 2
a1106 1
  l = bfd_hash_allocate (&already_linked_table, sizeof *l);
d1117 4
a1120 3
already_linked_newfunc (struct bfd_hash_entry *entry ATTRIBUTE_UNUSED,
			struct bfd_hash_table *table,
			const char *string ATTRIBUTE_UNUSED)
d1127 1
a1127 1
  return &ret->root;
d1131 1
a1131 1
already_linked_table_init (void)
d1140 1
a1140 1
already_linked_table_free (void)
d1158 2
a1159 1
wildcardp (const char *pattern)
d1176 5
a1180 4
lang_add_section (lang_statement_list_type *ptr,
		  asection *section,
		  lang_output_section_statement_type *output,
		  lang_input_statement_type *file)
d1193 1
a1193 1
      && ((flags & SEC_DEBUGGING) != 0 || !link_info.relocatable))
d1252 1
a1252 1
      if (! link_info.relocatable)
d1273 4
d1329 5
a1333 4
wild_sort (lang_wild_statement_type *wild,
	   struct wildcard_list *sec,
	   lang_input_statement_type *file,
	   asection *section)
d1429 6
a1434 5
output_section_callback (lang_wild_statement_type *ptr,
			 struct wildcard_list *sec,
			 asection *section,
			 lang_input_statement_type *file,
			 void *output)
d1490 2
a1491 1
lookup_name (const char *name)
d1496 1
a1496 1
       search != NULL;
d1499 1
a1499 6
      /* Use the local_sym_name as the name of the file that has
	 already been loaded as filename might have been transformed
	 via the search directory lookup mechanism.  */
      const char * filename = search->local_sym_name;

      if (filename == NULL && name == NULL)
d1501 3
a1503 3
      if (filename != NULL
	  && name != NULL
	  && strcmp (filename, name) == 0)
d1507 2
a1508 2
  if (search == NULL)
    search = new_afile (name, lang_input_file_is_search_file_enum, default_target,
d1516 1
a1516 1
      || search->filename == NULL)
d1519 1
a1519 1
  if (! load_symbols (search, NULL))
d1528 3
a1530 2
load_symbols (lang_input_statement_type *entry,
	      lang_statement_list_type *place)
d1661 4
a1664 3
wild (lang_wild_statement_type *s,
      const char *target ATTRIBUTE_UNUSED,
      lang_output_section_statement_type *output)
d1668 1
a1668 1
  walk_wild (s, output_section_callback, output);
d1686 3
a1688 1
get_target (const bfd_target *target, void *data)
d1690 1
a1690 1
  const char *sought = data;
d1698 3
a1700 1
stricpy (char *dest, char *src)
d1714 3
a1716 1
strcut (char *haystack, char *needle)
d1735 3
a1737 1
name_compare (char *first, char *second)
d1750 1
a1750 1
  /* Remove size and endian strings from the name.  */
d1780 3
a1782 1
closest_target_match (const bfd_target *target, void *data)
d1784 1
a1784 1
  const bfd_target *original = data;
d1818 1
a1818 1
get_first_input_target (void)
d1844 1
a1844 1
lang_get_output_target (void)
d1849 1
a1849 1
  if (output_target != NULL)
d1869 2
a1870 1
open_output (const char *name)
d1884 1
a1884 1
      target = bfd_search_for_target (get_target, (void *) output_target);
d1910 2
a1911 2
		  bfd_search_for_target (closest_target_match,
					 (void *) target);
d1926 1
a1926 1
  if (output == NULL)
d1948 1
a1948 1
  if (link_info.hash == NULL)
d1956 2
a1957 1
ldlang_open_output (lang_statement_union_type *statement)
d1962 1
a1962 1
      ASSERT (output_bfd == NULL);
d1965 1
a1965 1
      if (config.magic_demand_paged && !link_info.relocatable)
a1986 24
/* Convert between addresses in bytes and sizes in octets.
   For currently supported targets, octets_per_byte is always a power
   of two, so we can use shifts.  */
#define TO_ADDR(X) ((X) >> opb_shift)
#define TO_SIZE(X) ((X) << opb_shift)

/* Support the above.  */
static unsigned int opb_shift = 0;

static void
init_opb (void)
{
  unsigned x = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
					      ldfile_output_machine);
  opb_shift = 0;
  if (x > 1)
    while ((x & 1) == 0)
      {
	x >>= 1;
	++opb_shift;
      }
  ASSERT (x == 1);
}

d1990 3
a1992 1
open_input_bfds (lang_statement_union_type *s, bfd_boolean force)
d1994 1
a1994 1
  for (; s != NULL; s = s->header.next)
d2008 1
a2008 1
	    lookup_name (s->wild_statement.filename);
d2070 1
a2070 1
lang_reasonable_defaults (void)
d2085 1
a2085 1
      new->filename = NULL;
a2090 79
/* Add a symbol to a hash of symbols used in DEFINED (NAME) expressions.  */

void
lang_track_definedness (const char *name)
{
  if (bfd_hash_lookup (&lang_definedness_table, name, TRUE, FALSE) == NULL)
    einfo (_("%P%F: bfd_hash_lookup failed creating symbol %s\n"), name);
}

/* New-function for the definedness hash table.  */

static struct bfd_hash_entry *
lang_definedness_newfunc (struct bfd_hash_entry *entry,
			  struct bfd_hash_table *table ATTRIBUTE_UNUSED,
			  const char *name ATTRIBUTE_UNUSED)
{
  struct lang_definedness_hash_entry *ret
    = (struct lang_definedness_hash_entry *) entry;

  if (ret == NULL)
    ret = (struct lang_definedness_hash_entry *)
      bfd_hash_allocate (table, sizeof (struct lang_definedness_hash_entry));

  if (ret == NULL)
    einfo (_("%P%F: bfd_hash_allocate failed creating symbol %s\n"), name);

  ret->iteration = -1;
  return &ret->root;
}

/* Return the iteration when the definition of NAME was last updated.  A
   value of -1 means that the symbol is not defined in the linker script
   or the command line, but may be defined in the linker symbol table.  */

int
lang_symbol_definition_iteration (const char *name)
{
  struct lang_definedness_hash_entry *defentry
    = (struct lang_definedness_hash_entry *)
    bfd_hash_lookup (&lang_definedness_table, name, FALSE, FALSE);

  /* We've already created this one on the presence of DEFINED in the
     script, so it can't be NULL unless something is borked elsewhere in
     the code.  */
  if (defentry == NULL)
    FAIL ();

  return defentry->iteration;
}

/* Update the definedness state of NAME.  */

void
lang_update_definedness (const char *name, struct bfd_link_hash_entry *h)
{
  struct lang_definedness_hash_entry *defentry
    = (struct lang_definedness_hash_entry *)
    bfd_hash_lookup (&lang_definedness_table, name, FALSE, FALSE);

  /* We don't keep track of symbols not tested with DEFINED.  */
  if (defentry == NULL)
    return;

  /* If the symbol was already defined, and not from an earlier statement
     iteration, don't update the definedness iteration, because that'd
     make the symbol seem defined in the linker script at this point, and
     it wasn't; it was defined in some object.  If we do anyway, DEFINED
     would start to yield false before this point and the construct "sym =
     DEFINED (sym) ? sym : X;" would change sym to X despite being defined
     in an object.  */
  if (h->type != bfd_link_hash_undefined
      && h->type != bfd_link_hash_common
      && h->type != bfd_link_hash_new
      && defentry->iteration == -1)
    return;

  defentry->iteration = lang_statement_iteration;
}

d2102 2
a2103 1
ldlang_add_undef (const char *const name)
d2106 2
a2107 1
    stat_alloc (sizeof (ldlang_undef_chain_list_type));
d2121 2
a2122 1
insert_undefined (const char *name)
d2127 1
a2127 1
  if (h == NULL)
d2142 1
a2142 1
lang_place_undefineds (void)
d2146 6
a2151 2
  for (ptr = ldlang_undef_chain_list_head; ptr != NULL; ptr = ptr->next)
    insert_undefined (ptr->name);
d2157 4
a2160 3
map_input_to_output_sections
  (lang_statement_union_type *s, const char *target,
   lang_output_section_statement_type *output_section_statement)
d2162 1
a2162 1
  for (; s != NULL; s = s->header.next)
a2188 5
	case lang_data_statement_enum:
	  /* Make sure that any sections mentioned in the expression
	     are initialized.  */
	  exp_init_os (s->data_statement.exp);
	  /* FALLTHROUGH */
d2192 1
d2233 1
a2233 1
strip_excluded_output_sections (void)
d2264 2
a2265 2
print_output_section_statement
  (lang_output_section_statement_type *output_section_statement)
d2310 3
a2312 2
print_assignment (lang_assignment_statement_type *assignment,
		  lang_output_section_statement_type *output_section)
d2350 2
a2351 1
print_input_statement (lang_input_statement_type *statm)
d2353 1
a2353 1
  if (statm->filename != NULL)
d2363 3
a2365 1
print_one_symbol (struct bfd_link_hash_entry *hash_entry, void *ptr)
d2367 1
a2367 1
  asection *sec = ptr;
d2391 2
a2392 1
print_input_section (lang_input_section_type *in)
d2396 2
a2397 2

  init_opb ();
d2421 1
a2421 1
		 i->output_section->vma + i->output_offset, TO_ADDR (size),
d2441 1
a2441 1
	  bfd_link_hash_traverse (link_info.hash, print_one_symbol, i);
d2443 1
a2443 2
	  print_dot = (i->output_section->vma + i->output_offset
		       + TO_ADDR (size));
d2449 2
a2450 1
print_fill_statement (lang_fill_statement_type *fill)
d2461 2
a2462 1
print_data_statement (lang_data_statement_type *data)
d2468 2
a2470 1
  init_opb ();
d2514 2
a2515 1
  print_dot = addr + TO_ADDR (size);
d2522 2
a2523 1
print_address_statement (lang_address_statement_type *address)
d2533 2
a2534 1
print_reloc_statement (lang_reloc_statement_type *reloc)
d2539 2
a2541 1
  init_opb ();
d2562 1
a2562 1
  print_dot = addr + TO_ADDR (size);
d2566 2
a2567 1
print_padding_statement (lang_padding_statement_type *s)
d2571 2
a2573 1
  init_opb ();
d2598 1
a2598 1
  print_dot = addr + TO_ADDR (s->size);
d2602 3
a2604 2
print_wild_statement (lang_wild_statement_type *w,
		      lang_output_section_statement_type *os)
d2651 3
a2653 2
print_group (lang_group_statement_type *s,
	     lang_output_section_statement_type *os)
d2664 3
a2666 2
print_statement_list (lang_statement_union_type *s,
		      lang_output_section_statement_type *os)
d2679 3
a2681 2
print_statement (lang_statement_union_type *s,
		 lang_output_section_statement_type *os)
d2751 1
a2751 1
print_statements (void)
d2762 3
a2764 1
dprint_statement (lang_statement_union_type *s, int n)
d2785 6
a2790 5
insert_pad (lang_statement_union_type **ptr,
	    fill_type *fill,
	    unsigned int alignment_needed,
	    asection *output_section,
	    bfd_vma dot)
d2807 2
a2808 1
      pad = stat_alloc (sizeof (lang_padding_statement_type));
d2813 1
a2813 1
      if (fill == NULL)
d2825 5
a2829 4
size_input_section (lang_statement_union_type **this_ptr,
		    lang_output_section_statement_type *output_section_statement,
		    fill_type *fill,
		    bfd_vma dot)
d2836 2
d2857 1
a2857 1
	  insert_pad (this_ptr, fill, TO_SIZE (alignment_needed), o, dot);
d2867 1
a2867 1
	dot += TO_ADDR (i->_cooked_size);
d2869 2
a2870 2
	dot += TO_ADDR (i->_raw_size);
      o->_raw_size = TO_SIZE (dot - o->vma);
d2881 2
a2882 5
  (((bfd_get_section_flags (bfd, s) & SEC_THREAD_LOCAL)			\
    ? ((bfd_get_section_flags (bfd, s) & (SEC_LOAD | SEC_NEVER_LOAD))	\
       != SEC_LOAD)							\
    :  ((bfd_get_section_flags (bfd, s) & (SEC_ALLOC | SEC_NEVER_LOAD)) \
	!= SEC_ALLOC))							\
d2890 1
a2890 1
lang_check_section_addresses (void)
d2893 1
d2921 1
a2921 1
	  s_start = bfd_section_lma (output_bfd, s);
d2923 2
a2924 2
	  s_end = s_start + TO_ADDR (bfd_section_size (output_bfd, s)) - 1;
	  os_end = os_start + TO_ADDR (bfd_section_size (output_bfd, os)) - 1;
d2947 5
a2951 4
os_region_check (lang_output_section_statement_type *os,
		 lang_memory_region_type *region,
		 etree_type *tree,
		 bfd_vma base)
d2958 1
a2958 1
      if (tree != NULL)
d2981 9
a2989 8
lang_size_sections_1
  (lang_statement_union_type *s,
   lang_output_section_statement_type *output_section_statement,
   lang_statement_union_type **prev,
   fill_type *fill,
   bfd_vma dot,
   bfd_boolean *relax,
   bfd_boolean check_regions)
d2991 3
d2995 1
a2995 1
  for (; s != NULL; s = s->header.next)
d3038 1
a3038 1
		if (os->addr_tree == NULL)
d3042 1
a3042 1
		    if (os->region == NULL
d3046 1
a3046 1
			    && strcmp (os->region->name, DEFAULT_MEMORY_REGION) == 0))
d3053 6
a3058 3
		       defined, issue an error message.  */
		    if (!IGNORE_SECTION (output_bfd, os->bfd_section)
			&& ! link_info.relocatable
d3060 1
a3060 1
			&& strcmp (os->region->name, DEFAULT_MEMORY_REGION) == 0
d3063 1
a3063 1
				    DEFAULT_MEMORY_REGION) != 0
d3065 3
a3067 19
		      {
			/* By default this is an error rather than just a
			   warning because if we allocate the section to the
			   default memory region we can end up creating an
			   excessively large binary, or even seg faulting when
			   attempting to perform a negative seek.  See
			     http://sources.redhat.com/ml/binutils/2003-04/msg00423.html
			   for an example of this.  This behaviour can be
			   overridden by the using the --no-check-sections
			   switch.  */
			if (command_line.check_section_addresses)
			  einfo (_("%P%F: error: no memory region specified for loadable section `%s'\n"),
				 bfd_get_section_name (output_bfd,
						       os->bfd_section));
			else
			  einfo (_("%P: warning: no memory region specified for loadable section `%s'\n"),
				 bfd_get_section_name (output_bfd,
						       os->bfd_section));
		      }
a3087 1
		    os->processed = -1;
a3091 2
		    os->processed = 0;
		    
d3093 1
a3093 1
		      einfo (_("%F%S: non constant or forward reference address expression for section %s\n"),
d3115 3
a3117 4
	    after = ((os->bfd_section->vma
		      + TO_ADDR (os->bfd_section->_raw_size)
		      + os->block_value - 1)
		     & - (bfd_vma) os->block_value);
d3121 4
d3126 2
a3127 9
	      os->bfd_section->_raw_size
		= TO_SIZE (after - os->bfd_section->vma);

	    dot = os->bfd_section->vma;
	    /* .tbss sections effectively have zero size.  */
	    if ((os->bfd_section->flags & SEC_HAS_CONTENTS) != 0
		|| (os->bfd_section->flags & SEC_THREAD_LOCAL) == 0
		|| link_info.relocatable)
	      dot += TO_ADDR (os->bfd_section->_raw_size);
d3129 2
a3130 1
	    os->processed = 1;
d3144 1
a3144 1
	    if (os->region != NULL
d3167 1
a3167 1
		      TO_ADDR (os->bfd_section->_raw_size);
a3191 5
	    /* We might refer to provided symbols in the expression, and
	       need to mark them as needed.  */
	    exp_fold_tree (s->data_statement.exp, abs_output_section,
			   lang_allocating_phase_enum, dot, &dot);

d3210 3
a3212 3
	    if (size < TO_SIZE ((unsigned) 1))
	      size = TO_SIZE ((unsigned) 1);
	    dot += TO_ADDR (size);
d3234 1
a3234 1
	    dot += TO_ADDR (size);
d3302 1
a3302 1
		    lang_memory_region_lookup (DEFAULT_MEMORY_REGION, FALSE)->current = newdot;
d3309 1
a3309 1
		    insert_pad (&s->header.next, fill, TO_SIZE (newdot - dot),
a3315 6
		/* If dot is advanced, this implies that the section should
		   have space allocated to it, unless the user has explicitly
		   stated that the section should never be loaded.  */
		if (!(output_section_statement->flags & (SEC_NEVER_LOAD | SEC_ALLOC)))
		  output_section_statement->bfd_section->flags |= SEC_ALLOC;

d3359 9
a3367 8
lang_size_sections
  (lang_statement_union_type *s,
   lang_output_section_statement_type *output_section_statement,
   lang_statement_union_type **prev,
   fill_type *fill,
   bfd_vma dot,
   bfd_boolean *relax,
   bfd_boolean check_regions)
a3369 4
  asection *o;

  /* Callers of exp_fold_tree need to increment this.  */
  lang_statement_iteration++;
a3387 1
	  lang_statement_iteration++;
a3392 8
  /* Some backend relaxers want to refer to the output section size.  Give
     them a section size that does not change on the next call while they
     relax.  We can't set this at top because lang_reset_memory_regions
     which is called before we get here, sets _raw_size to 0 on relaxing
     rounds.  */
  for (o = output_bfd->sections; o != NULL; o = o->next)
    o->_cooked_size = o->_raw_size;

d3396 9
a3404 1
/* Worker function for lang_do_assignments.  Recursiveness goes here.  */
d3406 1
a3406 8
static bfd_vma
lang_do_assignments_1
  (lang_statement_union_type *s,
   lang_output_section_statement_type *output_section_statement,
   fill_type *fill,
   bfd_vma dot)
{
  for (; s != NULL; s = s->header.next)
d3411 4
a3414 4
	  dot = lang_do_assignments_1 (constructor_list.head,
				       output_section_statement,
				       fill,
				       dot);
d3425 3
a3427 3
		lang_do_assignments_1 (os->children.head, os, os->fill, dot);
		dot = (os->bfd_section->vma
		       + TO_ADDR (os->bfd_section->_raw_size));
d3445 3
a3447 3
	  dot = lang_do_assignments_1 (s->wild_statement.children.head,
				       output_section_statement,
				       fill, dot);
d3465 1
a3467 2
	    s->data_statement.value
	      = value.value + value.section->bfd_section->vma;
d3489 3
a3491 3
	    if (size < TO_SIZE ((unsigned) 1))
	      size = TO_SIZE ((unsigned) 1);
	    dot += TO_ADDR (size);
d3506 1
a3506 1
	  dot += TO_ADDR (bfd_get_reloc_size (s->reloc_statement.howto));
d3514 1
a3514 1
	      dot += TO_ADDR (in->_cooked_size);
d3516 1
a3516 1
	      dot += TO_ADDR (in->_raw_size);
d3536 1
a3536 1
	  dot += TO_ADDR (s->padding_statement.size);
d3540 3
a3542 3
	  dot = lang_do_assignments_1 (s->group_statement.children.head,
				       output_section_statement,
				       fill, dot);
a3556 11
void
lang_do_assignments (lang_statement_union_type *s,
		     lang_output_section_statement_type *output_section_statement,
		     fill_type *fill,
		     bfd_vma dot)
{
  /* Callers of exp_fold_tree need to increment this.  */
  lang_statement_iteration++;
  lang_do_assignments_1 (s, output_section_statement, fill, dot);
}

d3565 1
a3565 1
lang_set_startof (void)
d3569 1
a3569 1
  if (link_info.relocatable)
d3594 4
d3600 1
a3600 1
	    h->u.def.value = TO_ADDR (s->_cooked_size);
d3602 1
a3602 1
	    h->u.def.value = TO_ADDR (s->_raw_size);
d3611 1
a3611 1
lang_finish (void)
d3616 1
a3616 1
  if (link_info.relocatable || link_info.shared)
d3621 1
a3621 1
  if (entry_symbol.name == NULL)
d3631 1
a3631 1
  if (h != NULL
d3665 1
a3665 1
	  if (ts != NULL)
a3683 2

  bfd_hash_table_free (&lang_definedness_table);
d3690 1
d3692 4
d3705 1
a3705 1
lang_check (void)
d3711 3
a3713 1
  for (file = file_chain.head; file != NULL; file = file->input_statement.next)
d3725 1
a3725 1
      if ((link_info.relocatable || link_info.emitrelocations)
d3760 1
a3760 1
		einfo (_("%P%X: failed to merge target specific data of file %B\n"),
d3774 1
a3774 1
lang_common (void)
d3778 1
a3778 1
  if (link_info.relocatable
d3783 1
a3783 1
    bfd_link_hash_traverse (link_info.hash, lang_one_common, NULL);
d3789 2
a3790 1
	bfd_link_hash_traverse (link_info.hash, lang_one_common, &power);
d3797 3
a3799 1
lang_one_common (struct bfd_link_hash_entry *h, void *info)
d3804 2
d3819 3
a3821 3
  /* Increase the size of the section to align the common sym.  */
  section->_cooked_size += ((bfd_vma) 1 << (power_of_two + opb_shift)) - 1;
  section->_cooked_size &= (- (bfd_vma) 1 << (power_of_two + opb_shift));
d3895 1
a3895 1
lang_place_orphans (void)
d3901 3
a3903 1
      for (s = file->the_bfd->sections; s != NULL; s = s->next)
d3905 1
a3905 1
	  if (s->output_section == NULL)
d3919 1
a3919 1
		  if (! link_info.relocatable
d3953 4
a3956 1
lang_set_flags (lang_memory_region_type *ptr, const char *flags, int invert)
d3998 2
a3999 1
lang_for_each_input_file (void (*func) (lang_input_statement_type *))
d4014 2
a4015 1
lang_for_each_file (void (*func) (lang_input_statement_type *))
d4023 4
d4028 21
a4048 1
ldlang_add_file (lang_input_statement_type *entry)
d4058 1
a4058 1
  ASSERT (entry->the_bfd->link_next == NULL);
d4060 3
a4062 1
  for (pp = &link_info.input_bfds; *pp != NULL; pp = &(*pp)->link_next)
d4065 1
a4065 1
  entry->the_bfd->usrdata = entry;
d4078 1
a4078 1
  bfd_map_over_sections (entry->the_bfd, section_already_linked, entry);
d4082 3
a4084 1
lang_add_output (const char *name, int from_script)
d4097 2
a4098 1
topower (int x)
d4117 10
a4126 6
lang_enter_output_section_statement (const char *output_section_statement_name,
				     etree_type *address_exp,
				     enum section_type sectype,
				     etree_type *align,
				     etree_type *subalign,
				     etree_type *ebase)
d4141 1
a4141 1
  if (os->addr_tree == NULL)
d4150 1
a4150 1
  os->block_value = 1;
d4163 1
a4163 1
lang_final (void)
d4174 1
a4174 1
lang_reset_memory_regions (void)
d4179 3
a4181 1
  for (p = lang_memory_region_list; p != NULL; p = p->next)
d4195 6
a4200 5
gc_section_callback (lang_wild_statement_type *ptr,
		     struct wildcard_list *sec ATTRIBUTE_UNUSED,
		     asection *section,
		     lang_input_statement_type *file ATTRIBUTE_UNUSED,
		     void *data ATTRIBUTE_UNUSED)
d4209 2
a4210 1
lang_gc_wild (lang_wild_statement_type *s)
d4218 2
a4219 1
lang_gc_sections_1 (lang_statement_union_type *s)
d4221 1
a4221 1
  for (; s != NULL; s = s->header.next)
d4244 1
a4244 1
lang_gc_sections (void)
d4261 1
a4261 1
      if (h != NULL
d4274 1
a4274 1
lang_process (void)
a4280 1
  init_opb ();
d4331 2
a4332 1
  map_input_to_output_sections (statement_list.head, NULL, NULL);
d4337 1
a4337 1
  if (! link_info.relocatable)
d4342 1
a4342 1
      if (found != NULL)
d4355 1
a4355 1
  if (!link_info.relocatable)
d4363 3
a4365 2
  lang_size_sections (statement_list.head, abs_output_section,
		      &statement_list.head, 0, 0, NULL,
d4376 2
d4386 3
a4388 6
	  lang_do_assignments (statement_list.head, abs_output_section,
			       NULL, 0);

	  /* We must do this after lang_do_assignments, because it uses
	     _raw_size.  */
	  lang_reset_memory_regions ();
d4392 4
a4395 2
	  lang_size_sections (statement_list.head, abs_output_section,
			      &statement_list.head, 0, 0, &relax_again, FALSE);
d4399 1
a4399 1
	  if (!relax_again && link_info.need_relax_finalize)
d4401 1
a4401 1
	      link_info.need_relax_finalize = FALSE;
a4407 1
      lang_do_assignments (statement_list.head, abs_output_section, NULL, 0);
d4409 7
a4415 2
      lang_size_sections (statement_list.head, abs_output_section,
			  &statement_list.head, 0, 0, NULL, TRUE);
d4428 3
a4430 1
  lang_do_assignments (statement_list.head, abs_output_section, NULL, 0);
d4433 1
a4433 1
  if (! link_info.relocatable
d4446 4
a4449 3
lang_add_wild (struct wildcard_spec *filespec,
	       struct wildcard_list *section_list,
	       bfd_boolean keep_sections)
d4488 3
a4490 1
lang_section_start (const char *name, etree_type *address)
d4505 3
a4507 1
lang_add_entry (const char *name, bfd_boolean cmdline)
d4519 2
a4520 1
lang_add_target (const char *name)
d4530 2
a4531 1
lang_add_map (const char *name)
d4546 2
a4547 1
lang_add_fill (fill_type *fill)
d4556 3
a4558 1
lang_add_data (int type, union etree_union *exp)
d4577 6
a4582 5
lang_add_reloc (bfd_reloc_code_real_type reloc,
		reloc_howto_type *howto,
		asection *section,
		const char *name,
		union etree_union *addend)
d4598 2
a4599 1
lang_add_assignment (etree_type *exp)
d4609 2
a4610 1
lang_add_attribute (enum statement_enum attribute)
d4616 2
a4617 1
lang_startup (const char *name)
d4619 1
a4619 1
  if (startup_file != NULL)
d4631 2
a4632 1
lang_float (bfd_boolean maybe)
d4641 4
a4644 5
   MEMSPEC is the name of the run-time region, or the value of
   DEFAULT_MEMORY_REGION if the statement didn't specify one.
   LMA_MEMSPEC is the name of the load-time region, or null if the
   statement didn't specify one.HAVE_LMA_P is TRUE if the statement
   had an explicit load address.
d4649 10
a4658 14
lang_get_regions (lang_memory_region_type **region,
		  lang_memory_region_type **lma_region,
		  const char *memspec,
		  const char *lma_memspec,
		  bfd_boolean have_lma,
		  bfd_boolean have_vma)
{
  *lma_region = lang_memory_region_lookup (lma_memspec, FALSE);

  /* If no runtime region or VMA has been specified, but the load region has
     been specified, then use the load region for the runtime region as well.  */
  if (lma_memspec != NULL
      && ! have_vma
      && strcmp (memspec, DEFAULT_MEMORY_REGION) == 0)
d4661 1
a4661 1
    *region = lang_memory_region_lookup (memspec, FALSE);
d4663 1
a4663 1
  if (have_lma && lma_memspec != 0)
d4668 5
a4672 3
lang_leave_output_section_statement (fill_type *fill, const char *memspec,
				     lang_output_section_phdr_list *phdrs,
				     const char *lma_memspec)
d4677 1
a4677 2
		    current_section->load_base != NULL,
		    current_section->addr_tree != NULL);
d4689 3
a4691 1
lang_abs_symbol_at_beginning_of (const char *secname, const char *name)
d4696 1
a4696 1
  if (h == NULL)
d4707 1
a4707 1
      if (sec == NULL)
d4722 3
a4724 1
lang_abs_symbol_at_end_of (const char *secname, const char *name)
d4729 1
a4729 1
  if (h == NULL)
d4740 1
a4740 1
      if (sec == NULL)
d4744 2
a4745 1
			  + TO_ADDR (bfd_section_size (output_bfd, sec)));
d4752 4
a4755 3
lang_statement_append (lang_statement_list_type *list,
		       lang_statement_union_type *element,
		       lang_statement_union_type **field)
d4764 5
a4768 4
lang_add_output_format (const char *format,
			const char *big,
			const char *little,
			int from_script)
d4787 1
a4787 1
lang_enter_group (void)
d4802 1
a4802 1
lang_leave_group (void)
d4811 7
a4817 6
lang_new_phdr (const char *name,
	       etree_type *type,
	       bfd_boolean filehdr,
	       bfd_boolean phdrs,
	       etree_type *at,
	       etree_type *flags)
d4821 1
a4821 1
  n = stat_alloc (sizeof (struct lang_phdr));
d4840 1
a4840 1
lang_record_phdrs (void)
d4844 1
a4844 1
  lang_output_section_phdr_list *last;
d4849 1
a4849 1
  secs = xmalloc (alc * sizeof (asection *));
d4863 1
a4863 1
	  lang_output_section_phdr_list *pl;
d4889 2
a4890 1
		      secs = xrealloc (secs, alc * sizeof (asection *));
d4924 1
a4924 1
      lang_output_section_phdr_list *pl;
d4941 2
a4942 1
lang_add_nocrossref (lang_nocrossref_type *l)
d4946 1
a4946 1
  n = xmalloc (sizeof *n);
a4958 2
/* And subsection alignment.  */
static etree_type *overlay_subalign;
d4975 2
a4976 1
lang_enter_overlay (etree_type *vma_expr, etree_type *subalign)
d4979 1
a4979 3
  ASSERT (overlay_vma == NULL
	  && overlay_subalign == NULL
	  && overlay_max == NULL);
a4981 1
  overlay_subalign = subalign;
d4989 2
a4990 1
lang_enter_overlay_section (const char *name)
d4996 1
a4996 1
				       0, overlay_subalign, 0);
d5005 1
a5005 1
  n = xmalloc (sizeof *n);
d5023 3
a5025 2
lang_leave_overlay_section (fill_type *fill,
			    lang_output_section_phdr_list *phdrs)
d5034 4
a5037 5
  /* For now, assume that DEFAULT_MEMORY_REGION is the run-time memory
     region and that no load-time region has been specified.  It doesn't
     really matter what we say here, since lang_leave_overlay will
     override it.  */
  lang_leave_output_section_statement (fill, DEFAULT_MEMORY_REGION, phdrs, 0);
d5067 7
a5073 6
lang_leave_overlay (etree_type *lma_expr,
		    int nocrossrefs,
		    fill_type *fill,
		    const char *memspec,
		    lang_output_section_phdr_list *phdrs,
		    const char *lma_memspec)
d5078 1
a5078 1
  lang_nocrossref_type *nocrossref;
d5082 1
a5082 1
		    lma_expr != NULL, FALSE);
d5097 1
a5097 1
      if (fill != NULL && l->os->fill == NULL)
d5119 1
a5119 1
	  lang_nocrossref_type *nc;
d5121 1
a5121 1
	  nc = xmalloc (sizeof *nc);
d5146 9
a5154 3
/* If PREV is NULL, return first version pattern matching particular symbol.
   If PREV is non-NULL, return first version pattern matching particular
   symbol after PREV (previously returned by lang_vers_match).  */
d5156 4
a5159 4
static struct bfd_elf_version_expr *
lang_vers_match (struct bfd_elf_version_expr_head *head,
		 struct bfd_elf_version_expr *prev,
		 const char *sym)
d5161 2
a5162 3
  const char *cxx_sym = sym;
  const char *java_sym = sym;
  struct bfd_elf_version_expr *expr = NULL;
d5164 2
a5165 12
  if (head->mask & BFD_ELF_VERSION_CXX_TYPE)
    {
      cxx_sym = cplus_demangle (sym, DMGL_PARAMS | DMGL_ANSI);
      if (!cxx_sym)
	cxx_sym = sym;
    }
  if (head->mask & BFD_ELF_VERSION_JAVA_TYPE)
    {
      java_sym = cplus_demangle (sym, DMGL_JAVA);
      if (!java_sym)
	java_sym = sym;
    }
d5167 2
a5168 1
  if (head->htab && (prev == NULL || prev->symbol))
d5170 3
a5172 43
      struct bfd_elf_version_expr e;

      switch (prev ? prev->mask : 0)
	{
	  case 0:
	    if (head->mask & BFD_ELF_VERSION_C_TYPE)
	      {
		e.symbol = sym;
		expr = htab_find (head->htab, &e);
		while (expr && strcmp (expr->symbol, sym) == 0)
		  if (expr->mask == BFD_ELF_VERSION_C_TYPE)
		    goto out_ret;
		else
		  expr = expr->next;
	      }
	    /* Fallthrough */
	  case BFD_ELF_VERSION_C_TYPE:
	    if (head->mask & BFD_ELF_VERSION_CXX_TYPE)
	      {
		e.symbol = cxx_sym;
		expr = htab_find (head->htab, &e);
		while (expr && strcmp (expr->symbol, cxx_sym) == 0)
		  if (expr->mask == BFD_ELF_VERSION_CXX_TYPE)
		    goto out_ret;
		else
		  expr = expr->next;
	      }
	    /* Fallthrough */
	  case BFD_ELF_VERSION_CXX_TYPE:
	    if (head->mask & BFD_ELF_VERSION_JAVA_TYPE)
	      {
		e.symbol = java_sym;
		expr = htab_find (head->htab, &e);
		while (expr && strcmp (expr->symbol, java_sym) == 0)
		  if (expr->mask == BFD_ELF_VERSION_JAVA_TYPE)
		    goto out_ret;
		else
		  expr = expr->next;
	      }
	    /* Fallthrough */
	  default:
	    break;
	}
a5173 4

  /* Finally, try the wildcards.  */
  if (prev == NULL || prev->symbol)
    expr = head->remaining;
a5174 2
    expr = prev->next;
  while (expr)
d5176 2
a5177 14
      const char *s;

      if (expr->pattern[0] == '*' && expr->pattern[1] == '\0')
	break;

      if (expr->mask == BFD_ELF_VERSION_JAVA_TYPE)
	s = java_sym;
      else if (expr->mask == BFD_ELF_VERSION_CXX_TYPE)
	s = cxx_sym;
      else
	s = sym;
      if (fnmatch (expr->pattern, s, 0) == 0)
	break;
      expr = expr->next;
d5180 1
a5180 6
out_ret:
  if (cxx_sym != sym)
    free ((char *) cxx_sym);
  if (java_sym != sym)
    free ((char *) java_sym);
  return expr;
d5183 4
a5186 5
/* Return NULL if the PATTERN argument is a glob pattern, otherwise,
   return a string pointing to the symbol name.  */

static const char *
realsymbol (const char *pattern)
d5188 2
a5189 3
  const char *p;
  bfd_boolean changed = FALSE, backslash = FALSE;
  char *s, *symbol = xmalloc (strlen (pattern) + 1);
d5191 2
a5192 18
  for (p = pattern, s = symbol; *p != '\0'; ++p)
    {
      /* It is a glob pattern only if there is no preceding
	 backslash.  */
      if (! backslash && (*p == '?' || *p == '*' || *p == '['))
	{
	  free (symbol);
	  return NULL;
	}

      if (backslash)
	{
	  /* Remove the preceding backslash.  */
	  *(s - 1) = *p;
	  changed = TRUE;
	}
      else
	*s++ = *p;
d5194 2
a5195 4
      backslash = *p == '\\';
    }

  if (changed)
d5197 3
a5199 2
      *s = '\0';
      return symbol;
d5203 2
a5204 2
      free (symbol);
      return pattern;
d5206 2
d5213 4
a5216 3
lang_new_vers_pattern (struct bfd_elf_version_expr *orig,
		       const char *new,
		       const char *lang)
d5220 1
a5220 1
  ret = xmalloc (sizeof *ret);
a5224 1
  ret->symbol = realsymbol (new);
d5227 1
a5227 1
    ret->mask = BFD_ELF_VERSION_C_TYPE;
d5229 1
a5229 1
    ret->mask = BFD_ELF_VERSION_CXX_TYPE;
d5231 1
a5231 1
    ret->mask = BFD_ELF_VERSION_JAVA_TYPE;
d5236 1
a5236 1
      ret->mask = BFD_ELF_VERSION_C_TYPE;
d5246 3
a5248 2
lang_new_vers_node (struct bfd_elf_version_expr *globals,
		    struct bfd_elf_version_expr *locals)
d5252 7
a5258 4
  ret = xcalloc (1, sizeof *ret);
  ret->globals.list = globals;
  ret->locals.list = locals;
  ret->match = lang_vers_match;
d5260 1
a5267 96
static hashval_t
version_expr_head_hash (const void *p)
{
  const struct bfd_elf_version_expr *e = p;

  return htab_hash_string (e->symbol);
}

static int
version_expr_head_eq (const void *p1, const void *p2)
{
  const struct bfd_elf_version_expr *e1 = p1;
  const struct bfd_elf_version_expr *e2 = p2;

  return strcmp (e1->symbol, e2->symbol) == 0;
}

static void
lang_finalize_version_expr_head (struct bfd_elf_version_expr_head *head)
{
  size_t count = 0;
  struct bfd_elf_version_expr *e, *next;
  struct bfd_elf_version_expr **list_loc, **remaining_loc;

  for (e = head->list; e; e = e->next)
    {
      if (e->symbol)
	count++;
      head->mask |= e->mask;
    }

  if (count)
    {
      head->htab = htab_create (count * 2, version_expr_head_hash,
				version_expr_head_eq, NULL);
      list_loc = &head->list;
      remaining_loc = &head->remaining;
      for (e = head->list; e; e = next)
	{
	  next = e->next;
	  if (!e->symbol)
	    {
	      *remaining_loc = e;
	      remaining_loc = &e->next;
	    }
	  else
	    {
	      void **loc = htab_find_slot (head->htab, e, INSERT);

	      if (*loc)
		{
		  struct bfd_elf_version_expr *e1, *last;

		  e1 = *loc;
		  last = NULL;
		  do
		    {
		      if (e1->mask == e->mask)
			{
			  last = NULL;
			  break;
			}
		      last = e1;
		      e1 = e1->next;
		    }
		  while (e1 && strcmp (e1->symbol, e->symbol) == 0);

		  if (last == NULL)
		    {
		      /* This is a duplicate.  */
		      /* FIXME: Memory leak.  Sometimes pattern is not
			 xmalloced alone, but in larger chunk of memory.  */
		      /* free (e->symbol); */
		      free (e);
		    }
		  else
		    {
		      e->next = last->next;
		      last->next = e;
		    }
		}
	      else
		{
		  *loc = e;
		  *list_loc = e;
		  list_loc = &e->next;
		}
	    }
	}
      *remaining_loc = NULL;
      *list_loc = head->remaining;
    }
  else
    head->remaining = head->list;
}

d5272 4
a5275 3
lang_register_vers_node (const char *name,
			 struct bfd_elf_version_tree *version,
			 struct bfd_elf_version_deps *deps)
a5295 3
  lang_finalize_version_expr_head (&version->globals);
  lang_finalize_version_expr_head (&version->locals);

d5299 1
a5299 1
  for (e1 = version->globals.list; e1 != NULL; e1 = e1->next)
d5305 4
a5308 16
	  if (t->locals.htab && e1->symbol)
	    {
	      e2 = htab_find (t->locals.htab, e1);
	      while (e2 && strcmp (e1->symbol, e2->symbol) == 0)
		{
		  if (e1->mask == e2->mask)
		    einfo (_("%X%P: duplicate expression `%s' in version information\n"),
			   e1->symbol);
		  e2 = e2->next;
		}
	    }
	  else if (!e1->symbol)
	    for (e2 = t->locals.remaining; e2 != NULL; e2 = e2->next)
	      if (strcmp (e1->pattern, e2->pattern) == 0 && e1->mask == e2->mask)
		einfo (_("%X%P: duplicate expression `%s' in version information\n"),
		       e1->pattern);
d5312 1
a5312 1
  for (e1 = version->locals.list; e1 != NULL; e1 = e1->next)
d5318 4
a5321 16
	  if (t->globals.htab && e1->symbol)
	    {
	      e2 = htab_find (t->globals.htab, e1);
	      while (e2 && strcmp (e1->symbol, e2->symbol) == 0)
		{
		  if (e1->mask == e2->mask)
		    einfo (_("%X%P: duplicate expression `%s' in version information\n"),
			   e1->symbol);
		  e2 = e2->next;
		}
	    }
	  else if (!e1->symbol)
	    for (e2 = t->globals.remaining; e2 != NULL; e2 = e2->next)
	      if (strcmp (e1->pattern, e2->pattern) == 0 && e1->mask == e2->mask)
		einfo (_("%X%P: duplicate expression `%s' in version information\n"),
		       e1->pattern);
d5343 3
a5345 1
lang_add_vers_depend (struct bfd_elf_version_deps *list, const char *name)
d5350 1
a5350 1
  ret = xmalloc (sizeof *ret);
d5368 1
a5368 1
lang_do_version_exports_section (void)
d5406 2
a5407 1
lang_add_unique (const char *name)
d5415 1
a5415 1
  ent = xmalloc (sizeof *ent);
@


