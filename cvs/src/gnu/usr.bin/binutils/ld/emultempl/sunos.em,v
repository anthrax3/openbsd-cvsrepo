head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.54
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.52
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.7
date	2004.11.02.20.45.51;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.51;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.43;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.12.49;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.09.57;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.54.55;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.39;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.39;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.36.08;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.35.54;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.29.15;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.48.22;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.14.02.01;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.54;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.23.27;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@# This shell script emits a C file. -*- C -*-
# It does some substitutions.
if [ -z "$MACHINE" ]; then
  OUTPUT_ARCH=${ARCH}
else
  OUTPUT_ARCH=${ARCH}:${MACHINE}
fi
cat >e${EMULATION_NAME}.c <<EOF
/* This file is is generated by a shell script.  DO NOT EDIT! */

/* SunOS emulation code for ${EMULATION_NAME}
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002,
   2003, 2004 Free Software Foundation, Inc.
   Written by Steve Chamberlain <sac@@cygnus.com>
   SunOS shared library support by Ian Lance Taylor <ian@@cygnus.com>

This file is part of GLD, the Gnu Linker.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#define TARGET_IS_${EMULATION_NAME}

#include "bfd.h"
#include "sysdep.h"
#include "bfdlink.h"
#include "libiberty.h"
#include "safe-ctype.h"

#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldfile.h"
#include "ldemul.h"

#ifdef HAVE_DIRENT_H
# include <dirent.h>
#else
# define dirent direct
# ifdef HAVE_SYS_NDIR_H
#  include <sys/ndir.h>
# endif
# ifdef HAVE_SYS_DIR_H
#  include <sys/dir.h>
# endif
# ifdef HAVE_NDIR_H
#  include <ndir.h>
# endif
#endif

static void gld${EMULATION_NAME}_find_so
  (lang_input_statement_type *);
static char *gld${EMULATION_NAME}_search_dir
  (const char *, const char *, bfd_boolean *);
static void gld${EMULATION_NAME}_check_needed
  (lang_input_statement_type *);
static bfd_boolean gld${EMULATION_NAME}_search_needed
  (const char *, const char *);
static bfd_boolean gld${EMULATION_NAME}_try_needed
  (const char *, const char *);
static void gld${EMULATION_NAME}_find_assignment
  (lang_statement_union_type *);
static void gld${EMULATION_NAME}_find_exp_assignment
  (etree_type *);
static void gld${EMULATION_NAME}_count_need
  (lang_input_statement_type *);
static void gld${EMULATION_NAME}_set_need
  (lang_input_statement_type *);

static void
gld${EMULATION_NAME}_before_parse (void)
{
  ldfile_set_output_arch ("${OUTPUT_ARCH}", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);
  config.dynamic_link = TRUE;
  config.has_shared = TRUE;
}

/* This is called after the command line arguments have been parsed,
   but before the linker script has been read.  If this is a native
   linker, we add the directories in LD_LIBRARY_PATH to the search
   list.  */

static void
gld${EMULATION_NAME}_set_symbols (void)
{
EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
cat >>e${EMULATION_NAME}.c <<EOF
  const char *env;

  env = (const char *) getenv ("LD_LIBRARY_PATH");
  if (env != NULL)
    {
      char *l;

      l = xstrdup (env);
      while (1)
	{
	  char *c;

	  c = strchr (l, ':');
	  if (c != NULL)
	    *c++ = '\0';
	  if (*l != '\0')
	    ldfile_add_library_path (l, FALSE);
	  if (c == NULL)
	    break;
	  l = c;
	}
    }
EOF
  ;;
  esac
fi
cat >>e${EMULATION_NAME}.c <<EOF
}

/* Despite the name, we use this routine to search for dynamic
   libraries.  On SunOS this requires a directory search.  We need to
   find the .so file with the highest version number.  The user may
   restrict the major version by saying, e.g., -lc.1.  Also, if we
   find a .so file, we need to look for a the same file after
   replacing .so with .sa; if it exists, it will be an archive which
   provide some initializations for data symbols, and we need to
   search it after including the .so file.  */

static void
gld${EMULATION_NAME}_create_output_section_statements (void)
{
  lang_for_each_input_file (gld${EMULATION_NAME}_find_so);
}

/* Search the directory for a .so file for each library search.  */

static void
gld${EMULATION_NAME}_find_so (lang_input_statement_type *inp)
{
  search_dirs_type *search;
  char *found = NULL;
  char *alc;
  struct stat st;

  if (! inp->search_dirs_flag
      || ! inp->is_archive
      || ! inp->dynamic)
    return;

  ASSERT (strncmp (inp->local_sym_name, "-l", 2) == 0);

  for (search = search_head; search != NULL; search = search->next)
    {
      bfd_boolean found_static;

      found = gld${EMULATION_NAME}_search_dir (search->name, inp->filename,
					       &found_static);
      if (found != NULL || found_static)
	break;
    }

  if (found == NULL)
    {
      /* We did not find a matching .so file.  This isn't an error,
	 since there might still be a matching .a file, which will be
	 found by the usual search.  */
      return;
    }

  /* Replace the filename with the one we have found.  */
  alc = (char *) xmalloc (strlen (search->name) + strlen (found) + 2);
  sprintf (alc, "%s/%s", search->name, found);
  inp->filename = alc;

  /* Turn off the search_dirs_flag to prevent ldfile_open_file from
     searching for this file again.  */
  inp->search_dirs_flag = FALSE;

  free (found);

  /* Now look for the same file name, but with .sa instead of .so.  If
     found, add it to the list of input files.  */
  alc = (char *) xmalloc (strlen (inp->filename) + 1);
  strcpy (alc, inp->filename);
  strstr (alc + strlen (search->name), ".so")[2] = 'a';
  if (stat (alc, &st) != 0)
    free (alc);
  else
    {
      lang_input_statement_type *sa;

      /* Add the .sa file to the statement list just before the .so
	 file.  This is really a hack.  */
      sa = ((lang_input_statement_type *)
	    xmalloc (sizeof (lang_input_statement_type)));
      *sa = *inp;

      inp->filename = alc;
      inp->local_sym_name = alc;

      inp->header.next = (lang_statement_union_type *) sa;
      inp->next_real_file = (lang_statement_union_type *) sa;
    }
}

/* Search a directory for a .so file.  */

static char *
gld${EMULATION_NAME}_search_dir
  (const char *dirname, const char *filename, bfd_boolean *found_static)
{
  int force_maj, force_min;
  const char *dot;
  unsigned int len;
  char *alc;
  char *found;
  int max_maj, max_min;
  DIR *dir;
  struct dirent *entry;
  unsigned int dirnamelen;
  char *full_path;
  int statval;
  struct stat st;

  *found_static = FALSE;

  force_maj = -1;
  force_min = -1;
  dot = strchr (filename, '.');
  if (dot == NULL)
    {
      len = strlen (filename);
      alc = NULL;
    }
  else
    {
      force_maj = atoi (dot + 1);

      len = dot - filename;
      alc = (char *) xmalloc (len + 1);
      strncpy (alc, filename, len);
      alc[len] = '\0';
      filename = alc;

      dot = strchr (dot + 1, '.');
      if (dot != NULL)
	force_min = atoi (dot + 1);
    }

  found = NULL;
  max_maj = max_min = 0;

  dir = opendir (dirname);
  if (dir == NULL)
    return NULL;
  dirnamelen = strlen (dirname);

  while ((entry = readdir (dir)) != NULL)
    {
      const char *s;
      int found_maj, found_min;

      if (strncmp (entry->d_name, "lib", 3) != 0
	  || strncmp (entry->d_name + 3, filename, len) != 0)
	continue;

      if (dot == NULL
	  && strcmp (entry->d_name + 3 + len, ".a") == 0)
	{
	  *found_static = TRUE;
	  continue;
	}

      /* We accept libfoo.so without a version number, even though the
	 native linker does not.  This is more convenient for packages
	 which just generate .so files for shared libraries, as on ELF
	 systems.  */
      if (strncmp (entry->d_name + 3 + len, ".so", 3) != 0)
	continue;
      if (entry->d_name[6 + len] == '\0')
	;
      else if (entry->d_name[6 + len] == '.'
	       && ISDIGIT (entry->d_name[7 + len]))
	;
      else
	continue;

      for (s = entry->d_name + 6 + len; *s != '\0'; s++)
	if (*s != '.' && ! ISDIGIT (*s))
	  break;
      if (*s != '\0')
	continue;

      /* We've found a .so file.  Work out the major and minor
	 version numbers.  */
      found_maj = 0;
      found_min = 0;
      sscanf (entry->d_name + 3 + len, ".so.%d.%d",
	      &found_maj, &found_min);

      if ((force_maj != -1 && force_maj != found_maj)
	  || (force_min != -1 && force_min != found_min))
	continue;

      /* Make sure the file really exists (ignore broken symlinks).  */
      full_path = xmalloc (dirnamelen + 1 + strlen (entry->d_name) + 1);
      sprintf (full_path, "%s/%s", dirname, entry->d_name);
      statval = stat (full_path, &st);
      free (full_path);
      if (statval != 0)
	continue;

      /* We've found a match for the name we are searching for.  See
	 if this is the version we should use.  If the major and minor
	 versions match, we use the last entry in alphabetical order;
	 I don't know if this is how SunOS distinguishes libc.so.1.8
	 from libc.so.1.8.1, but it ought to suffice.  */
      if (found == NULL
	  || (found_maj > max_maj)
	  || (found_maj == max_maj
	      && (found_min > max_min
		  || (found_min == max_min
		      && strcmp (entry->d_name, found) > 0))))
	{
	  if (found != NULL)
	    free (found);
	  found = (char *) xmalloc (strlen (entry->d_name) + 1);
	  strcpy (found, entry->d_name);
	  max_maj = found_maj;
	  max_min = found_min;
	}
    }

  closedir (dir);

  if (alc != NULL)
    free (alc);

  return found;
}

/* These variables are required to pass information back and forth
   between after_open and check_needed.  */

static struct bfd_link_needed_list *global_needed;
static bfd_boolean global_found;

/* This is called after all the input files have been opened.  */

static void
gld${EMULATION_NAME}_after_open (void)
{
  struct bfd_link_needed_list *needed, *l;

  /* We only need to worry about this when doing a final link.  */
  if (link_info.relocatable || link_info.shared)
    return;

  /* Get the list of files which appear in ld_need entries in dynamic
     objects included in the link.  For each such file, we want to
     track down the corresponding library, and include the symbol
     table in the link.  This is what the runtime dynamic linker will
     do.  Tracking the files down here permits one dynamic object to
     include another without requiring special action by the person
     doing the link.  Note that the needed list can actually grow
     while we are stepping through this loop.  */
  needed = bfd_sunos_get_needed_list (output_bfd, &link_info);
  for (l = needed; l != NULL; l = l->next)
    {
      struct bfd_link_needed_list *ll;
      const char *lname;
      search_dirs_type *search;

      lname = l->name;

      /* If we've already seen this file, skip it.  */
      for (ll = needed; ll != l; ll = ll->next)
	if (strcmp (ll->name, lname) == 0)
	  break;
      if (ll != l)
	continue;

      /* See if this file was included in the link explicitly.  */
      global_needed = l;
      global_found = FALSE;
      lang_for_each_input_file (gld${EMULATION_NAME}_check_needed);
      if (global_found)
	continue;

      if (strncmp (lname, "-l", 2) != 0)
	{
	  bfd *abfd;

	  abfd = bfd_openr (lname, bfd_get_target (output_bfd));
	  if (abfd != NULL)
	    {
	      if (! bfd_check_format (abfd, bfd_object))
		{
		  (void) bfd_close (abfd);
		  abfd = NULL;
		}
	    }
	  if (abfd != NULL)
	    {
	      if ((bfd_get_file_flags (abfd) & DYNAMIC) == 0)
		{
		  (void) bfd_close (abfd);
		  abfd = NULL;
		}
	    }
	  if (abfd != NULL)
	    {
	      /* We've found the needed dynamic object.  */
	      if (! bfd_link_add_symbols (abfd, &link_info))
		einfo ("%F%B: could not read symbols: %E\n", abfd);
	    }
	  else
	    {
	      einfo ("%P: warning: %s, needed by %B, not found\n",
		     lname, l->by);
	    }

	  continue;
	}

      lname += 2;

      /* We want to search for the file in the same way that the
	 dynamic linker will search.  That means that we want to use
	 rpath_link, rpath or -L, then the environment variable
	 LD_LIBRARY_PATH (native only), then (if rpath was used) the
	 linker script LIB_SEARCH_DIRS.  */
      if (gld${EMULATION_NAME}_search_needed (command_line.rpath_link,
					      lname))
	continue;
      if (command_line.rpath != NULL)
	{
	  if (gld${EMULATION_NAME}_search_needed (command_line.rpath, lname))
	    continue;
	}
      else
	{
	  for (search = search_head; search != NULL; search = search->next)
	    if (gld${EMULATION_NAME}_try_needed (search->name, lname))
	      break;
	  if (search != NULL)
	    continue;
	}
EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
cat >>e${EMULATION_NAME}.c <<EOF
      {
	const char *lib_path;

	lib_path = (const char *) getenv ("LD_LIBRARY_PATH");
	if (gld${EMULATION_NAME}_search_needed (lib_path, lname))
	  continue;
      }
EOF
  ;;
  esac
fi
cat >>e${EMULATION_NAME}.c <<EOF
      if (command_line.rpath != NULL)
	{
	  for (search = search_head; search != NULL; search = search->next)
	    {
	      if (search->cmdline)
		continue;
	      if (gld${EMULATION_NAME}_try_needed (search->name, lname))
		break;
	    }
	  if (search != NULL)
	    continue;
	}

      einfo ("%P: warning: %s, needed by %B, not found\n",
	     l->name, l->by);
    }
}

/* Search for a needed file in a path.  */

static bfd_boolean
gld${EMULATION_NAME}_search_needed (const char *path, const char *name)
{
  const char *s;

  if (path == NULL || *path == '\0')
    return FALSE;
  while (1)
    {
      const char *dir;
      char *dircopy;

      s = strchr (path, ':');
      if (s == NULL)
	{
	  dircopy = NULL;
	  dir = path;
	}
      else
	{
	  dircopy = (char *) xmalloc (s - path + 1);
	  memcpy (dircopy, path, s - path);
	  dircopy[s - path] = '\0';
	  dir = dircopy;
	}

      if (gld${EMULATION_NAME}_try_needed (dir, name))
	return TRUE;

      if (dircopy != NULL)
	free (dircopy);

      if (s == NULL)
	break;
      path = s + 1;
    }

  return FALSE;
}

/* This function is called for each possible directory for a needed
   dynamic object.  */

static bfd_boolean
gld${EMULATION_NAME}_try_needed (const char *dir, const char *name)
{
  char *file;
  char *alc;
  bfd_boolean ignore;
  bfd *abfd;

  file = gld${EMULATION_NAME}_search_dir (dir, name, &ignore);
  if (file == NULL)
    return FALSE;

  alc = (char *) xmalloc (strlen (dir) + strlen (file) + 2);
  sprintf (alc, "%s/%s", dir, file);
  free (file);
  abfd = bfd_openr (alc, bfd_get_target (output_bfd));
  if (abfd == NULL)
    return FALSE;
  if (! bfd_check_format (abfd, bfd_object))
    {
      (void) bfd_close (abfd);
      return FALSE;
    }
  if ((bfd_get_file_flags (abfd) & DYNAMIC) == 0)
    {
      (void) bfd_close (abfd);
      return FALSE;
    }

  /* We've found the needed dynamic object.  */

  /* Add this file into the symbol table.  */
  if (! bfd_link_add_symbols (abfd, &link_info))
    einfo ("%F%B: could not read symbols: %E\n", abfd);

  return TRUE;
}

/* See if we have already included a needed object in the link.  This
   does not have to be precise, as it does no harm to include a
   dynamic object more than once.  */

static void
gld${EMULATION_NAME}_check_needed (lang_input_statement_type *s)
{
  if (s->filename == NULL)
    return;
  if (strncmp (global_needed->name, "-l", 2) != 0)
    {
      if (strcmp (s->filename, global_needed->name) == 0)
	global_found = TRUE;
    }
  else
    {
      const char *sname, *lname;
      const char *sdot, *ldot;
      int lmaj, lmin, smaj, smin;

      lname = global_needed->name + 2;

      sname = strrchr (s->filename, '/');
      if (sname == NULL)
	sname = s->filename;
      else
	++sname;

      if (strncmp (sname, "lib", 3) != 0)
	return;
      sname += 3;

      ldot = strchr (lname, '.');
      if (ldot == NULL)
	ldot = lname + strlen (lname);

      sdot = strstr (sname, ".so.");
      if (sdot == NULL)
	return;

      if (sdot - sname != ldot - lname
	  || strncmp (lname, sname, sdot - sname) != 0)
	return;

      lmaj = lmin = -1;
      sscanf (ldot, ".%d.%d", &lmaj, &lmin);
      smaj = smin = -1;
      sscanf (sdot, ".so.%d.%d", &smaj, &smin);
      if ((smaj != lmaj && smaj != -1 && lmaj != -1)
	  || (smin != lmin && smin != -1 && lmin != -1))
	return;

      global_found = TRUE;
    }
}

/* We need to use static variables to pass information around the call
   to lang_for_each_statement.  Ick.  */

static const char *find_assign;
static bfd_boolean found_assign;

/* We need to use static variables to pass information around the call
   to lang_for_each_input_file.  Ick.  */

static bfd_size_type need_size;
static bfd_size_type need_entries;
static bfd_byte *need_contents;
static bfd_byte *need_pinfo;
static bfd_byte *need_pnames;

/* The size of one entry in the .need section, not including the file
   name.  */

#define NEED_ENTRY_SIZE (16)

/* This is called after the sections have been attached to output
   sections, but before any sizes or addresses have been set.  */

static void
gld${EMULATION_NAME}_before_allocation (void)
{
  struct bfd_link_hash_entry *hdyn = NULL;
  asection *sneed;
  asection *srules;
  asection *sdyn;

  /* The SunOS native linker creates a shared library whenever there
     are any undefined symbols in a link, unless -e is used.  This is
     pretty weird, but we are compatible.  */
  if (! link_info.shared && ! link_info.relocatable && ! entry_from_cmdline)
    {
      struct bfd_link_hash_entry *h;

      for (h = link_info.hash->undefs; h != NULL; h = h->und_next)
	{
	  if (h->type == bfd_link_hash_undefined
	      && h->u.undef.abfd != NULL
	      && (h->u.undef.abfd->flags & DYNAMIC) == 0
	      && strcmp (h->root.string, "__DYNAMIC") != 0
	      && strcmp (h->root.string, "__GLOBAL_OFFSET_TABLE_") != 0)
	    {
	      find_assign = h->root.string;
	      found_assign = FALSE;
	      lang_for_each_statement (gld${EMULATION_NAME}_find_assignment);
	      if (! found_assign)
		{
		  link_info.shared = TRUE;
		  break;
		}
	    }
	}
    }

  if (link_info.shared)
    {
      lang_output_section_statement_type *os;

      /* Set the .text section to start at 0x20, not 0x2020.  FIXME:
	 This is too magical.  */
      os = lang_output_section_statement_lookup (".text");
      if (os->addr_tree == NULL)
	os->addr_tree = exp_intop (0x20);
    }

  /* We need to create a __DYNAMIC symbol.  We don't do this in the
     linker script because we want to set the value to the start of
     the dynamic section if there is one, or to zero if there isn't
     one.  We need to create the symbol before calling
     size_dynamic_sections, although we can't set the value until
     afterward.  */
  if (! link_info.relocatable)
    {
      hdyn = bfd_link_hash_lookup (link_info.hash, "__DYNAMIC", TRUE, FALSE,
				   FALSE);
      if (hdyn == NULL)
	einfo ("%P%F: bfd_link_hash_lookup: %E\n");
      if (! bfd_sunos_record_link_assignment (output_bfd, &link_info,
					      "__DYNAMIC"))
	einfo ("%P%F: failed to record assignment to __DYNAMIC: %E\n");
    }

  /* If we are going to make any variable assignments, we need to let
     the backend linker know about them in case the variables are
     referred to by dynamic objects.  */
  lang_for_each_statement (gld${EMULATION_NAME}_find_assignment);

  /* Let the backend linker work out the sizes of any sections
     required by dynamic linking.  */
  if (! bfd_sunos_size_dynamic_sections (output_bfd, &link_info, &sdyn,
					 &sneed, &srules))
    einfo ("%P%F: failed to set dynamic section sizes: %E\n");

  if (sneed != NULL)
    {
      /* Set up the .need section.  See the description of the ld_need
	 field in include/aout/sun4.h.  */

      need_entries = 0;
      need_size = 0;

      lang_for_each_input_file (gld${EMULATION_NAME}_count_need);

      /* We should only have a .need section if we have at least one
	 dynamic object.  */
      ASSERT (need_entries != 0);

      sneed->_raw_size = need_size;
      sneed->contents = (bfd_byte *) xmalloc (need_size);

      need_contents = sneed->contents;
      need_pinfo = sneed->contents;
      need_pnames = sneed->contents + need_entries * 16;

      lang_for_each_input_file (gld${EMULATION_NAME}_set_need);

      ASSERT ((bfd_size_type) (need_pnames - sneed->contents) == need_size);
    }

  if (srules != NULL)
    {
      /* Set up the .rules section.  This is just a PATH like string
	 of the -L arguments given on the command line.  We permit the
	 user to specify the directories using the -rpath command line
	 option.  */
      if (command_line.rpath)
	{
	  srules->_raw_size = strlen (command_line.rpath);
	  srules->contents = (bfd_byte *) command_line.rpath;
	}
      else
	{
	  unsigned int size;
	  search_dirs_type *search;

	  size = 0;
	  for (search = search_head; search != NULL; search = search->next)
	    if (search->cmdline)
	      size += strlen (search->name) + 1;
	  srules->_raw_size = size;
	  if (size > 0)
	    {
	      char *p;

	      srules->contents = (bfd_byte *) xmalloc (size);
	      p = (char *) srules->contents;
	      *p = '\0';
	      for (search = search_head; search != NULL; search = search->next)
		{
		  if (search->cmdline)
		    {
		      if (p != (char *) srules->contents)
			*p++ = ':';
		      strcpy (p, search->name);
		      p += strlen (p);
		    }
		}
	    }
	}
    }

  /* We must assign a value to __DYNAMIC.  It should be zero if we are
     not doing a dynamic link, or the start of the .dynamic section if
     we are doing one.  */
  if (! link_info.relocatable)
    {
      hdyn->type = bfd_link_hash_defined;
      hdyn->u.def.value = 0;
      if (sdyn != NULL)
	hdyn->u.def.section = sdyn;
      else
	hdyn->u.def.section = bfd_abs_section_ptr;
    }
}

/* This is called by the before_allocation routine via
   lang_for_each_statement.  It does one of two things: if the
   variable find_assign is set, it sets found_assign if it finds an
   assignment to that variable; otherwise it tells the backend linker
   about all assignment statements, in case they are assignments to
   symbols which are referred to by dynamic objects.  */

static void
gld${EMULATION_NAME}_find_assignment (lang_statement_union_type *s)
{
  if (s->header.type == lang_assignment_statement_enum
      && (find_assign == NULL || ! found_assign))
    gld${EMULATION_NAME}_find_exp_assignment (s->assignment_statement.exp);
}

/* Look through an expression for an assignment statement.  */

static void
gld${EMULATION_NAME}_find_exp_assignment (etree_type *exp)
{
  switch (exp->type.node_class)
    {
    case etree_assign:
      if (find_assign != NULL)
	{
	  if (strcmp (find_assign, exp->assign.dst) == 0)
	    found_assign = TRUE;
	  return;
	}

      if (strcmp (exp->assign.dst, ".") != 0)
	{
	  if (! bfd_sunos_record_link_assignment (output_bfd, &link_info,
						  exp->assign.dst))
	    einfo ("%P%F: failed to record assignment to %s: %E\n",
		   exp->assign.dst);
	}
      gld${EMULATION_NAME}_find_exp_assignment (exp->assign.src);
      break;

    case etree_binary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.rhs);
      break;

    case etree_trinary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.cond);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.rhs);
      break;

    case etree_unary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->unary.child);
      break;

    default:
      break;
    }
}

/* Work out the size of the .need section, and the number of entries.
   The backend will set the ld_need field of the dynamic linking
   information to point to the .need section.  See include/aout/sun4.h
   for more information.  */

static void
gld${EMULATION_NAME}_count_need (lang_input_statement_type *inp)
{
  if (inp->the_bfd != NULL
      && (inp->the_bfd->flags & DYNAMIC) != 0)
    {
      ++need_entries;
      need_size += NEED_ENTRY_SIZE;
      if (! inp->is_archive)
	need_size += strlen (inp->filename) + 1;
      else
	{
	  ASSERT (inp->local_sym_name[0] == '-'
		  && inp->local_sym_name[1] == 'l');
	  need_size += strlen (inp->local_sym_name + 2) + 1;
	}
    }
}

/* Fill in the contents of the .need section.  */

static void
gld${EMULATION_NAME}_set_need (lang_input_statement_type *inp)
{
  if (inp->the_bfd != NULL
      && (inp->the_bfd->flags & DYNAMIC) != 0)
    {
      bfd_size_type c;

      /* To really fill in the .need section contents, we need to know
	 the final file position of the section, but we don't.
	 Instead, we use offsets, and rely on the BFD backend to
	 finish the section up correctly.  FIXME: Talk about lack of
	 referential locality.  */
      bfd_put_32 (output_bfd, need_pnames - need_contents, need_pinfo);
      if (! inp->is_archive)
	{
	  bfd_put_32 (output_bfd, (bfd_vma) 0, need_pinfo + 4);
	  bfd_put_16 (output_bfd, (bfd_vma) 0, need_pinfo + 8);
	  bfd_put_16 (output_bfd, (bfd_vma) 0, need_pinfo + 10);
	  strcpy (need_pnames, inp->filename);
	}
      else
	{
	  char *verstr;
	  int maj, min;

	  bfd_put_32 (output_bfd, (bfd_vma) 0x80000000, need_pinfo + 4);
	  maj = 0;
	  min = 0;
	  verstr = strstr (inp->filename, ".so.");
	  if (verstr != NULL)
	    sscanf (verstr, ".so.%d.%d", &maj, &min);
	  bfd_put_16 (output_bfd, (bfd_vma) maj, need_pinfo + 8);
	  bfd_put_16 (output_bfd, (bfd_vma) min, need_pinfo + 10);
	  strcpy (need_pnames, inp->local_sym_name + 2);
	}

      c = (need_pinfo - need_contents) / NEED_ENTRY_SIZE;
      if (c + 1 >= need_entries)
	bfd_put_32 (output_bfd, (bfd_vma) 0, need_pinfo + 12);
      else
	bfd_put_32 (output_bfd, (bfd_vma) (c + 1) * NEED_ENTRY_SIZE,
		    need_pinfo + 12);

      need_pinfo += NEED_ENTRY_SIZE;
      need_pnames += strlen (need_pnames) + 1;
    }
}

static char *
gld${EMULATION_NAME}_get_script (int *isfile)
EOF

if test -n "$COMPILE_IN"
then
# Scripts compiled in.

# sed commands to quote an ld script as a C string.
sc="-f stringify.sed"

cat >>e${EMULATION_NAME}.c <<EOF
{
  *isfile = 0;

  if (link_info.relocatable && config.build_constructors)
    return
EOF
sed $sc ldscripts/${EMULATION_NAME}.xu                     >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocatable) return'         >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                     >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'         >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                    >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                     >> e${EMULATION_NAME}.c
echo '  ; else return'                                     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                      >> e${EMULATION_NAME}.c
echo '; }'                                                 >> e${EMULATION_NAME}.c

else
# Scripts read from the filesystem.

cat >>e${EMULATION_NAME}.c <<EOF
{
  *isfile = 1;

  if (link_info.relocatable && config.build_constructors)
    return "ldscripts/${EMULATION_NAME}.xu";
  else if (link_info.relocatable)
    return "ldscripts/${EMULATION_NAME}.xr";
  else if (!config.text_read_only)
    return "ldscripts/${EMULATION_NAME}.xbn";
  else if (!config.magic_demand_paged)
    return "ldscripts/${EMULATION_NAME}.xn";
  else
    return "ldscripts/${EMULATION_NAME}.x";
}
EOF

fi

cat >>e${EMULATION_NAME}.c <<EOF

struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
{
  gld${EMULATION_NAME}_before_parse,
  syslib_default,
  hll_default,
  after_parse_default,
  gld${EMULATION_NAME}_after_open,
  after_allocation_default,
  set_output_arch_default,
  ldemul_default_target,
  gld${EMULATION_NAME}_before_allocation,
  gld${EMULATION_NAME}_get_script,
  "${EMULATION_NAME}",
  "${OUTPUT_FORMAT}",
  NULL,	/* finish */
  gld${EMULATION_NAME}_create_output_section_statements,
  NULL,	/* open dynamic archive */
  NULL,	/* place orphan */
  gld${EMULATION_NAME}_set_symbols,
  NULL,	/* parse args */
  NULL,	/* add_options */
  NULL,	/* handle_option */
  NULL,	/* unrecognized file */
  NULL,	/* list options */
  NULL,	/* recognized file */
  NULL,	/* find_potential_libraries */
  NULL	/* new_vers_pattern */
};
EOF
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d12 2
a13 2
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003
   Free Software Foundation, Inc.
a63 4
static void gld${EMULATION_NAME}_before_parse PARAMS ((void));
static void gld${EMULATION_NAME}_set_symbols PARAMS ((void));
static void gld${EMULATION_NAME}_create_output_section_statements
  PARAMS ((void));
d65 1
a65 1
  PARAMS ((lang_input_statement_type *));
d67 1
a67 2
  PARAMS ((const char *, const char *, bfd_boolean *));
static void gld${EMULATION_NAME}_after_open PARAMS ((void));
d69 1
a69 1
  PARAMS ((lang_input_statement_type *));
d71 1
a71 1
  PARAMS ((const char *, const char *));
d73 1
a73 2
  PARAMS ((const char *, const char *));
static void gld${EMULATION_NAME}_before_allocation PARAMS ((void));
d75 3
a77 2
  PARAMS ((lang_statement_union_type *));
static void gld${EMULATION_NAME}_find_exp_assignment PARAMS ((etree_type *));
d79 1
a79 1
  PARAMS ((lang_input_statement_type *));
d81 1
a81 2
  PARAMS ((lang_input_statement_type *));
static char *gld${EMULATION_NAME}_get_script PARAMS ((int *isfile));
d84 1
a84 1
gld${EMULATION_NAME}_before_parse()
d86 1
a86 9
  const bfd_arch_info_type *arch = bfd_scan_arch ("${OUTPUT_ARCH}");
  if (arch)
    {
      ldfile_output_architecture = arch->arch;
      ldfile_output_machine = arch->mach;
      ldfile_output_machine_name = arch->printable_name;
    }
  else
    ldfile_output_architecture = bfd_arch_${ARCH};
d97 1
a97 1
gld${EMULATION_NAME}_set_symbols ()
d143 1
a143 1
gld${EMULATION_NAME}_create_output_section_statements ()
d151 1
a151 2
gld${EMULATION_NAME}_find_so (inp)
     lang_input_statement_type *inp;
d222 2
a223 4
gld${EMULATION_NAME}_search_dir (dirname, filename, found_static)
     const char *dirname;
     const char *filename;
     bfd_boolean *found_static;
d288 3
a290 3
         native linker does not.  This is more convenient for packages
         which just generate .so files for shared libraries, as on ELF
         systems.  */
d364 1
a364 1
gld${EMULATION_NAME}_after_open ()
d369 1
a369 1
  if (link_info.relocateable || link_info.shared)
d500 1
a500 3
gld${EMULATION_NAME}_search_needed (path, name)
     const char *path;
     const char *name;
d543 1
a543 3
gld${EMULATION_NAME}_try_needed (dir, name)
     const char *dir;
     const char *name;
d585 1
a585 2
gld${EMULATION_NAME}_check_needed (s)
     lang_input_statement_type *s;
d660 1
a660 1
gld${EMULATION_NAME}_before_allocation ()
d670 1
a670 1
  if (! link_info.shared && ! link_info.relocateable && ! entry_from_cmdline)
d674 1
a674 1
      for (h = link_info.hash->undefs; h != NULL; h = h->next)
d699 1
a699 1
         This is too magical.  */
d711 1
a711 1
  if (! link_info.relocateable)
d804 1
a804 1
  if (! link_info.relocateable)
d823 1
a823 2
gld${EMULATION_NAME}_find_assignment (s)
     lang_statement_union_type *s;
d833 1
a833 2
gld${EMULATION_NAME}_find_exp_assignment (exp)
     etree_type *exp;
d881 1
a881 2
gld${EMULATION_NAME}_count_need (inp)
     lang_input_statement_type *inp;
d902 1
a902 2
gld${EMULATION_NAME}_set_need (inp)
     lang_input_statement_type *inp;
d951 1
a951 2
gld${EMULATION_NAME}_get_script(isfile)
     int *isfile;
d965 1
a965 1
  if (link_info.relocateable && config.build_constructors)
d969 1
a969 1
echo '  ; else if (link_info.relocateable) return'         >> e${EMULATION_NAME}.c
d986 1
a986 1
  if (link_info.relocateable && config.build_constructors)
d988 1
a988 1
  else if (link_info.relocateable)
@


1.5
log
@resolve conflicts.
@
text
@d3 5
d12 1
a12 1
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
a34 2
#include <ctype.h>

d39 1
d71 1
a71 1
  PARAMS ((const char *, const char *, boolean *));
d75 1
a75 1
static boolean gld${EMULATION_NAME}_search_needed
d77 1
a77 1
static boolean gld${EMULATION_NAME}_try_needed
d92 11
a102 3
  ldfile_output_architecture = bfd_arch_${ARCH};
  config.dynamic_link = true;
  config.has_shared = true;
d134 1
a134 1
	    ldfile_add_library_path (l, false);
d182 1
a182 1
      boolean found_static;
d205 1
a205 1
  inp->search_dirs_flag = false;
d240 1
a240 1
     boolean *found_static;
d255 1
a255 1
  *found_static = false;
d287 1
a287 1
  
d300 1
a300 1
	  *found_static = true;
d313 1
a313 1
	       && isdigit ((unsigned char) entry->d_name[7 + len]))
d319 1
a319 1
	if (*s != '.' && ! isdigit ((unsigned char) *s))
d376 1
a376 1
static boolean global_found;
d415 1
a415 1
      global_found = false;
d516 1
a516 1
static boolean
d524 1
a524 1
    return false;
d545 1
a545 1
	return true;
d555 1
a555 1
  return false;	  
d561 1
a561 1
static boolean
d568 1
a568 1
  boolean ignore;
d573 1
a573 1
    return false;
d580 1
a580 1
    return false;
d584 1
a584 1
      return false;
d589 1
a589 1
      return false;
d598 1
a598 1
  return true;
d614 1
a614 1
	global_found = true;
d654 1
a654 1
      global_found = true;
d662 1
a662 1
static boolean found_assign;
d695 1
a695 1
      
d705 1
a705 1
	      found_assign = false;
d709 1
a709 1
		  link_info.shared = true;
d735 2
a736 2
      hdyn = bfd_link_hash_lookup (link_info.hash, "__DYNAMIC", true, false,
				   false);
d865 1
a865 1
	    found_assign = true;
d989 1
a989 1
{			     
d992 1
a992 1
  if (link_info.relocateable == true && config.build_constructors == true)
d996 1
a996 1
echo '  ; else if (link_info.relocateable == true) return' >> e${EMULATION_NAME}.c
d1010 1
a1010 1
{			     
d1013 1
a1013 1
  if (link_info.relocateable == true && config.build_constructors == true)
d1015 1
a1015 1
  else if (link_info.relocateable == true)
d1030 1
a1030 1
struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation = 
d1050 2
d1055 2
a1056 1
  NULL 	/* find_potential_libraries */
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d7 1
a7 1
   Copyright (C) 1991, 93, 94, 95, 96, 97, 98, 1999
a38 2
#include "ldemul.h"
#include "ldfile.h"
d42 2
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d7 2
a8 1
   Copyright (C) 1991, 1993, 1994 Free Software Foundation, Inc.
d30 1
a30 2
#include <sys/types.h>
#include <sys/stat.h>
d90 1
d103 2
a104 1
  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
d129 2
a130 1
  fi
d157 1
a157 1
  char *found;
d201 1
a201 1
  strstr (alc, ".so.")[2] = 'a';
d238 4
d274 1
d278 1
d292 4
d298 13
d323 8
d469 2
a470 1
  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
d480 2
a481 1
  fi
d974 1
a974 5
sc='s/["\\]/\\&/g
s/$/\\n\\/
1s/^/"/
$s/$/n"/
'
d981 1
a981 10
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xu`;
  else if (link_info.relocateable == true)
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xr`;
  else if (!config.text_read_only)
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xbn`;
  else if (!config.magic_demand_paged)
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xn`;
  else
    return `sed "$sc" ldscripts/${EMULATION_NAME}.x`;
}
d983 10
d1032 1
a1032 1
  NULL, /* finish */
d1034 8
a1041 3
  NULL, /* open_dynamic_library */
  NULL, /* place_orphan */
  gld${EMULATION_NAME}_set_symbols
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d199 3
a201 1
  if (stat (alc, &st) == 0)
a203 1
      char *a;
d205 1
a205 1
      /* Add the .sa file to the statement list just after the .so
d209 4
a212 17
      sa->header.next = inp->header.next;
      sa->header.type = lang_input_statement_enum;
      a = (char *) xmalloc (strlen (alc) + 1);
      strcpy (a, alc);
      sa->filename = a;
      sa->local_sym_name = a;
      sa->the_bfd = NULL;
      sa->asymbols = NULL;
      sa->symbol_count = 0;
      sa->next = NULL;
      sa->next_real_file = inp->next_real_file;
      sa->is_archive = false;
      sa->search_dirs_flag = false;
      sa->just_syms_flag = false;
      sa->loaded = false;
      sa->real = true;
      sa->complained = false;
a213 2
      /* Put the new statement next on the list of statements and next
	 on the list of input files.  */
a355 1
      const char *lib_path;
d437 7
a443 3
      lib_path = (const char *) getenv ("LD_LIBRARY_PATH");
      if (gld${EMULATION_NAME}_search_needed (lib_path, lname))
	continue;
@


1.1
log
@Initial revision
@
text
@d35 1
d61 1
d92 40
d449 2
a450 1
if [ "x${host_alias}" = "x${target_alias}" ] ; then
d456 1
d664 2
a665 1
	      && strcmp (h->root.string, "__DYNAMIC") != 0)
d1012 3
a1014 1
  NULL /* open_dynamic_library */
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@a34 1
#include "libiberty.h"
a59 1
static void gld${EMULATION_NAME}_set_symbols PARAMS ((void));
a89 40
/* This is called after the command line arguments have been parsed,
   but before the linker script has been read.  If this is a native
   linker, we add the directories in LD_LIBRARY_PATH to the search
   list.  */

static void
gld${EMULATION_NAME}_set_symbols ()
{
EOF
if [ "x${host}" = "x${target}" ] ; then
  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
cat >>e${EMULATION_NAME}.c <<EOF
  const char *env;

  env = (const char *) getenv ("LD_LIBRARY_PATH");
  if (env != NULL)
    {
      char *l;

      l = xstrdup (env);
      while (1)
	{
	  char *c;

	  c = strchr (l, ':');
	  if (c != NULL)
	    *c++ = '\0';
	  if (*l != '\0')
	    ldfile_add_library_path (l, false);
	  if (c == NULL)
	    break;
	  l = c;
	}
    }
EOF
  fi
fi
cat >>e${EMULATION_NAME}.c <<EOF
}

d407 1
a407 2
if [ "x${host}" = "x${target}" ] ; then
  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
a412 1
  fi
d620 1
a620 2
	      && strcmp (h->root.string, "__DYNAMIC") != 0
	      && strcmp (h->root.string, "__GLOBAL_OFFSET_TABLE_") != 0)
d967 1
a967 3
  NULL, /* open_dynamic_library */
  NULL, /* place_orphan */
  gld${EMULATION_NAME}_set_symbols
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d199 1
a199 3
  if (stat (alc, &st) != 0)
    free (alc);
  else
d202 1
d204 1
a204 1
      /* Add the .sa file to the statement list just before the .so
d208 17
a224 4
      *sa = *inp;

      inp->filename = alc;
      inp->local_sym_name = alc;
d226 2
d370 1
d452 3
a454 7
      {
	const char *lib_path;

	lib_path = (const char *) getenv ("LD_LIBRARY_PATH");
	if (gld${EMULATION_NAME}_search_needed (lib_path, lname))
	  continue;
      }
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d7 1
a7 1
   Copyright (C) 1991, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
a28 1
#include <ctype.h>
d198 1
a198 1
  strstr (alc + strlen (search->name), ".so")[2] = 'a';
a269 1
      const char *s;
a282 4
      /* We accept libfoo.so without a version number, even though the
         native linker does not.  This is more convenient for packages
         which just generate .so files for shared libraries, as on ELF
         systems.  */
a283 13
	continue;
      if (entry->d_name[6 + len] == '\0')
	;
      else if (entry->d_name[6 + len] == '.'
	       && isdigit (entry->d_name[7 + len]))
	;
      else
	continue;

      for (s = entry->d_name + 6 + len; *s != '\0'; s++)
	if (*s != '.' && ! isdigit (*s))
	  break;
      if (*s != '\0')
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d7 1
a7 2
   Copyright (C) 1991, 93, 94, 95, 96, 97, 98, 1999
   Free Software Foundation, Inc.
d30 2
a90 1
  config.has_shared = true;
d103 1
a103 2
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
d128 1
a128 2
  ;;
  esac
d155 1
a155 1
  char *found = NULL;
a235 4
  unsigned int dirnamelen;
  char *full_path;
  int statval;
  struct stat st;
a267 1
  dirnamelen = strlen (dirname);
d294 1
a294 1
	       && isdigit ((unsigned char) entry->d_name[7 + len]))
d300 1
a300 1
	if (*s != '.' && ! isdigit ((unsigned char) *s))
a315 8
      /* Make sure the file really exists (ignore broken symlinks).  */
      full_path = xmalloc (dirnamelen + 1 + strlen (entry->d_name) + 1);
      sprintf (full_path, "%s/%s", dirname, entry->d_name);
      statval = stat (full_path, &st);
      free (full_path);
      if (statval != 0)
	continue;

d454 1
a454 2
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
d464 1
a464 2
  ;;
  esac
d957 5
a961 1
sc="-f stringify.sed"
d968 10
a977 1
    return
a978 10
sed $sc ldscripts/${EMULATION_NAME}.xu                     >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocateable == true) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                     >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'         >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                    >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                     >> e${EMULATION_NAME}.c
echo '  ; else return'                                     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                      >> e${EMULATION_NAME}.c
echo '; }'                                                 >> e${EMULATION_NAME}.c
d1018 1
a1018 1
  NULL,	/* finish */
d1020 3
a1022 8
  NULL,	/* open dynamic archive */
  NULL,	/* place orphan */
  gld${EMULATION_NAME}_set_symbols,
  NULL,	/* parse args */
  NULL,	/* unrecognized file */
  NULL,	/* list options */
  NULL,	/* recognized file */
  NULL 	/* find_potential_libraries */
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d7 1
a7 1
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
d39 2
a43 2
#include "ldfile.h"
#include "ldemul.h"
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@a2 5
if [ -z "$MACHINE" ]; then
  OUTPUT_ARCH=${ARCH}
else
  OUTPUT_ARCH=${ARCH}:${MACHINE}
fi
d7 1
a7 1
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003
d30 2
a35 1
#include "safe-ctype.h"
d67 1
a67 1
  PARAMS ((const char *, const char *, bfd_boolean *));
d71 1
a71 1
static bfd_boolean gld${EMULATION_NAME}_search_needed
d73 1
a73 1
static bfd_boolean gld${EMULATION_NAME}_try_needed
d88 3
a90 11
  const bfd_arch_info_type *arch = bfd_scan_arch ("${OUTPUT_ARCH}");
  if (arch)
    {
      ldfile_output_architecture = arch->arch;
      ldfile_output_machine = arch->mach;
      ldfile_output_machine_name = arch->printable_name;
    }
  else
    ldfile_output_architecture = bfd_arch_${ARCH};
  config.dynamic_link = TRUE;
  config.has_shared = TRUE;
d122 1
a122 1
	    ldfile_add_library_path (l, FALSE);
d170 1
a170 1
      bfd_boolean found_static;
d193 1
a193 1
  inp->search_dirs_flag = FALSE;
d228 1
a228 1
     bfd_boolean *found_static;
d243 1
a243 1
  *found_static = FALSE;
d275 1
a275 1

d288 1
a288 1
	  *found_static = TRUE;
d301 1
a301 1
	       && ISDIGIT (entry->d_name[7 + len]))
d307 1
a307 1
	if (*s != '.' && ! ISDIGIT (*s))
d364 1
a364 1
static bfd_boolean global_found;
d403 1
a403 1
      global_found = FALSE;
d504 1
a504 1
static bfd_boolean
d512 1
a512 1
    return FALSE;
d533 1
a533 1
	return TRUE;
d543 1
a543 1
  return FALSE;
d549 1
a549 1
static bfd_boolean
d556 1
a556 1
  bfd_boolean ignore;
d561 1
a561 1
    return FALSE;
d568 1
a568 1
    return FALSE;
d572 1
a572 1
      return FALSE;
d577 1
a577 1
      return FALSE;
d586 1
a586 1
  return TRUE;
d602 1
a602 1
	global_found = TRUE;
d642 1
a642 1
      global_found = TRUE;
d650 1
a650 1
static bfd_boolean found_assign;
d683 1
a683 1

d693 1
a693 1
	      found_assign = FALSE;
d697 1
a697 1
		  link_info.shared = TRUE;
d723 2
a724 2
      hdyn = bfd_link_hash_lookup (link_info.hash, "__DYNAMIC", TRUE, FALSE,
				   FALSE);
d853 1
a853 1
	    found_assign = TRUE;
d977 1
a977 1
{
d980 1
a980 1
  if (link_info.relocateable && config.build_constructors)
d984 1
a984 1
echo '  ; else if (link_info.relocateable) return'         >> e${EMULATION_NAME}.c
d998 1
a998 1
{
d1001 1
a1001 1
  if (link_info.relocateable && config.build_constructors)
d1003 1
a1003 1
  else if (link_info.relocateable)
d1018 1
a1018 1
struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
a1037 2
  NULL,	/* add_options */
  NULL,	/* handle_option */
d1041 1
a1041 2
  NULL,	/* find_potential_libraries */
  NULL	/* new_vers_pattern */
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d12 2
a13 2
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002,
   2003, 2004 Free Software Foundation, Inc.
d64 4
d69 1
a69 1
  (lang_input_statement_type *);
d71 2
a72 1
  (const char *, const char *, bfd_boolean *);
d74 1
a74 1
  (lang_input_statement_type *);
d76 1
a76 1
  (const char *, const char *);
d78 2
a79 1
  (const char *, const char *);
d81 2
a82 3
  (lang_statement_union_type *);
static void gld${EMULATION_NAME}_find_exp_assignment
  (etree_type *);
d84 1
a84 1
  (lang_input_statement_type *);
d86 2
a87 1
  (lang_input_statement_type *);
d90 1
a90 1
gld${EMULATION_NAME}_before_parse (void)
d92 9
a100 1
  ldfile_set_output_arch ("${OUTPUT_ARCH}", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);
d111 1
a111 1
gld${EMULATION_NAME}_set_symbols (void)
d157 1
a157 1
gld${EMULATION_NAME}_create_output_section_statements (void)
d165 2
a166 1
gld${EMULATION_NAME}_find_so (lang_input_statement_type *inp)
d237 4
a240 2
gld${EMULATION_NAME}_search_dir
  (const char *dirname, const char *filename, bfd_boolean *found_static)
d305 3
a307 3
	 native linker does not.  This is more convenient for packages
	 which just generate .so files for shared libraries, as on ELF
	 systems.  */
d381 1
a381 1
gld${EMULATION_NAME}_after_open (void)
d386 1
a386 1
  if (link_info.relocatable || link_info.shared)
d517 3
a519 1
gld${EMULATION_NAME}_search_needed (const char *path, const char *name)
d562 3
a564 1
gld${EMULATION_NAME}_try_needed (const char *dir, const char *name)
d606 2
a607 1
gld${EMULATION_NAME}_check_needed (lang_input_statement_type *s)
d682 1
a682 1
gld${EMULATION_NAME}_before_allocation (void)
d692 1
a692 1
  if (! link_info.shared && ! link_info.relocatable && ! entry_from_cmdline)
d696 1
a696 1
      for (h = link_info.hash->undefs; h != NULL; h = h->und_next)
d721 1
a721 1
	 This is too magical.  */
d733 1
a733 1
  if (! link_info.relocatable)
d826 1
a826 1
  if (! link_info.relocatable)
d845 2
a846 1
gld${EMULATION_NAME}_find_assignment (lang_statement_union_type *s)
d856 2
a857 1
gld${EMULATION_NAME}_find_exp_assignment (etree_type *exp)
d905 2
a906 1
gld${EMULATION_NAME}_count_need (lang_input_statement_type *inp)
d927 2
a928 1
gld${EMULATION_NAME}_set_need (lang_input_statement_type *inp)
d977 2
a978 1
gld${EMULATION_NAME}_get_script (int *isfile)
d992 1
a992 1
  if (link_info.relocatable && config.build_constructors)
d996 1
a996 1
echo '  ; else if (link_info.relocatable) return'         >> e${EMULATION_NAME}.c
d1013 1
a1013 1
  if (link_info.relocatable && config.build_constructors)
d1015 1
a1015 1
  else if (link_info.relocatable)
@


