head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.52
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.48
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.44
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.46
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.38
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.42
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.40
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.36
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.34
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.32
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.30
	OPENBSD_5_0:1.5.0.28
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.26
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.24
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.20
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.22
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.18
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.16
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.6
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.5
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.4
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.3
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.3
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.2
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.5
date	2004.11.02.20.45.51;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.17.21.54.51;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.43;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.19.12.49;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.38;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.38;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.05.29.09.29.14;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.09.12.14.48.21;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.05.13.14.01.53;	author fgsch;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.05.17.20.42.53;	author drahn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.11.02.20.23.26;	author miod;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@# This shell script emits a C file. -*- C -*-
#   Copyright 1991, 1993, 1994, 1997, 1999, 2000, 2001, 2002, 2003
#   Free Software Foundation, Inc.
#
# This file is part of GLD, the Gnu Linker.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#

# This file is sourced from elf32.em, and defines extra hppa-elf
# specific routines.
#
cat >>e${EMULATION_NAME}.c <<EOF

#include "ldctor.h"
#include "elf32-hppa.h"


/* Fake input file for stubs.  */
static lang_input_statement_type *stub_file;

/* Type of import/export stubs to build.  For a single sub-space model,
   we can build smaller import stubs and there is no need for export
   stubs.  */
static int multi_subspace = 0;

/* Whether we need to call hppa_layout_sections_again.  */
static int need_laying_out = 0;

/* Maximum size of a group of input sections that can be handled by
   one stub section.  A value of +/-1 indicates the bfd back-end
   should use a suitable default size.  */
static bfd_signed_vma group_size = 1;

/* Stops the linker merging .text sections on a relocatable link,
   and adds millicode library to the list of input files.  */

static void
hppaelf_after_parse (void)
{
  if (link_info.relocatable)
    lang_add_unique (".text");
#if 0 /* Enable this once we split millicode stuff from libgcc.  */
  else
    lang_add_input_file ("milli",
			 lang_input_file_is_l_enum,
			 NULL);
#endif
}

/* This is called before the input files are opened.  We create a new
   fake input file to hold the stub sections.  */

static void
hppaelf_create_output_section_statements (void)
{
  extern const bfd_target bfd_elf32_hppa_linux_vec;
  extern const bfd_target bfd_elf32_hppa_vec;

  if (link_info.hash->creator != &bfd_elf32_hppa_linux_vec
      && link_info.hash->creator != &bfd_elf32_hppa_vec)
    return;

  stub_file = lang_add_input_file ("linker stubs",
				   lang_input_file_is_fake_enum,
				   NULL);
  stub_file->the_bfd = bfd_create ("linker stubs", output_bfd);
  if (stub_file->the_bfd == NULL
      || ! bfd_set_arch_mach (stub_file->the_bfd,
			      bfd_get_arch (output_bfd),
			      bfd_get_mach (output_bfd)))
    {
      einfo ("%X%P: can not create BFD %E\n");
      return;
    }

  ldlang_add_file (stub_file);
}


struct hook_stub_info
{
  lang_statement_list_type add;
  asection *input_section;
};

/* Traverse the linker tree to find the spot where the stub goes.  */

static bfd_boolean
hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)
{
  lang_statement_union_type *l;
  bfd_boolean ret;

  for (; (l = *lp) != NULL; lp = &l->header.next)
    {
      switch (l->header.type)
	{
	case lang_constructors_statement_enum:
	  ret = hook_in_stub (info, &constructor_list.head);
	  if (ret)
	    return ret;
	  break;

	case lang_output_section_statement_enum:
	  ret = hook_in_stub (info,
			      &l->output_section_statement.children.head);
	  if (ret)
	    return ret;
	  break;

	case lang_wild_statement_enum:
	  ret = hook_in_stub (info, &l->wild_statement.children.head);
	  if (ret)
	    return ret;
	  break;

	case lang_group_statement_enum:
	  ret = hook_in_stub (info, &l->group_statement.children.head);
	  if (ret)
	    return ret;
	  break;

	case lang_input_section_enum:
	  if (l->input_section.section == info->input_section)
	    {
	      /* We've found our section.  Insert the stub immediately
		 before its associated input section.  */
	      *lp = info->add.head;
	      *(info->add.tail) = l;
	      return TRUE;
	    }
	  break;

	case lang_data_statement_enum:
	case lang_reloc_statement_enum:
	case lang_object_symbols_statement_enum:
	case lang_output_statement_enum:
	case lang_target_statement_enum:
	case lang_input_statement_enum:
	case lang_assignment_statement_enum:
	case lang_padding_statement_enum:
	case lang_address_statement_enum:
	case lang_fill_statement_enum:
	  break;

	default:
	  FAIL ();
	  break;
	}
    }
  return FALSE;
}


/* Call-back for elf32_hppa_size_stubs.  */

/* Create a new stub section, and arrange for it to be linked
   immediately before INPUT_SECTION.  */

static asection *
hppaelf_add_stub_section (const char *stub_sec_name, asection *input_section)
{
  asection *stub_sec;
  flagword flags;
  asection *output_section;
  const char *secname;
  lang_output_section_statement_type *os;
  struct hook_stub_info info;

  stub_sec = bfd_make_section_anyway (stub_file->the_bfd, stub_sec_name);
  if (stub_sec == NULL)
    goto err_ret;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
	   | SEC_HAS_CONTENTS | SEC_RELOC | SEC_IN_MEMORY | SEC_KEEP);
  if (!bfd_set_section_flags (stub_file->the_bfd, stub_sec, flags))
    goto err_ret;

  output_section = input_section->output_section;
  secname = bfd_get_section_name (output_section->owner, output_section);
  os = lang_output_section_find (secname);

  info.input_section = input_section;
  lang_list_init (&info.add);
  lang_add_section (&info.add, stub_sec, os, stub_file);

  if (info.add.head == NULL)
    goto err_ret;

  if (hook_in_stub (&info, &os->children.head))
    return stub_sec;

 err_ret:
  einfo ("%X%P: can not make stub section: %E\n");
  return NULL;
}


/* Another call-back for elf32_hppa_size_stubs.  */

static void
hppaelf_layout_sections_again (void)
{
  /* If we have changed sizes of the stub sections, then we need
     to recalculate all the section offsets.  This may mean we need to
     add even more stubs.  */
  need_laying_out = 0;

  lang_reset_memory_regions ();

  /* Resize the sections.  */
  lang_size_sections (stat_ptr->head, abs_output_section,
		      &stat_ptr->head, 0, (bfd_vma) 0, NULL, TRUE);

  /* Redo special stuff.  */
  ldemul_after_allocation ();

  /* Do the assignments again.  */
  lang_do_assignments (stat_ptr->head, abs_output_section,
		       (fill_type *) 0, (bfd_vma) 0);
}


static void
build_section_lists (lang_statement_union_type *statement)
{
  if (statement->header.type == lang_input_section_enum
      && !statement->input_section.ifile->just_syms_flag
      && statement->input_section.section->output_section != NULL
      && statement->input_section.section->output_section->owner == output_bfd)
    {
      elf32_hppa_next_input_section (&link_info,
				     statement->input_section.section);
    }
}


/* Final emulation specific call.  For the PA we use this opportunity
   to build linker stubs.  */

static void
gld${EMULATION_NAME}_finish (void)
{
  /* bfd_elf_discard_info just plays with debugging sections,
     ie. doesn't affect any code, so we can delay resizing the
     sections.  It's likely we'll resize everything in the process of
     adding stubs.  */
  if (bfd_elf_discard_info (output_bfd, &link_info))
    need_laying_out = 1;

  /* If generating a relocatable output file, then we don't
     have to examine the relocs.  */
  if (stub_file != NULL && !link_info.relocatable)
    {
      int ret = elf32_hppa_setup_section_lists (output_bfd, &link_info);

      if (ret != 0)
	{
	  if (ret < 0)
	    {
	      einfo ("%X%P: can not size stub section: %E\n");
	      return;
	    }

	  lang_for_each_statement (build_section_lists);

	  /* Call into the BFD backend to do the real work.  */
	  if (! elf32_hppa_size_stubs (output_bfd,
				       stub_file->the_bfd,
				       &link_info,
				       multi_subspace,
				       group_size,
				       &hppaelf_add_stub_section,
				       &hppaelf_layout_sections_again))
	    {
	      einfo ("%X%P: can not size stub section: %E\n");
	      return;
	    }
	}
    }

  if (need_laying_out)
    hppaelf_layout_sections_again ();

  if (! link_info.relocatable)
    {
      /* Set the global data pointer.  */
      if (! elf32_hppa_set_gp (output_bfd, &link_info))
	{
	  einfo ("%X%P: can not set gp\n");
	  return;
	}

      /* Now build the linker stubs.  */
      if (stub_file != NULL && stub_file->the_bfd->sections != NULL)
	{
	  if (! elf32_hppa_build_stubs (&link_info))
	    einfo ("%X%P: can not build stubs: %E\n");
	}
    }
}


/* Avoid processing the fake stub_file in vercheck, stat_needed and
   check_needed routines.  */

static void (*real_func) (lang_input_statement_type *);

static void hppa_for_each_input_file_wrapper (lang_input_statement_type *l)
{
  if (l != stub_file)
    (*real_func) (l);
}

static void
hppa_lang_for_each_input_file (void (*func) (lang_input_statement_type *))
{
  real_func = func;
  lang_for_each_input_file (&hppa_for_each_input_file_wrapper);
}

#define lang_for_each_input_file hppa_lang_for_each_input_file

EOF

# Define some shell vars to insert bits of code into the standard elf
# parse_args and list_options functions.
#
PARSE_AND_LIST_PROLOGUE='
#define OPTION_MULTI_SUBSPACE		301
#define OPTION_STUBGROUP_SIZE		(OPTION_MULTI_SUBSPACE + 1)
'

PARSE_AND_LIST_LONGOPTS='
  { "multi-subspace", no_argument, NULL, OPTION_MULTI_SUBSPACE },
  { "stub-group-size", required_argument, NULL, OPTION_STUBGROUP_SIZE },
'

PARSE_AND_LIST_OPTIONS='
  fprintf (file, _("\
  --multi-subspace      Generate import and export stubs to support\n\
                          multiple sub-space shared libraries\n"
		   ));
  fprintf (file, _("\
  --stub-group-size=N   Maximum size of a group of input sections that can be\n\
                          handled by one stub section.  A negative value\n\
                          locates all stubs before their branches (with a\n\
                          group size of -N), while a positive value allows\n\
                          two groups of input sections, one before, and one\n\
                          after each stub section.  Values of +/-1 indicate\n\
                          the linker should choose suitable defaults.\n"
		   ));
'

PARSE_AND_LIST_ARGS_CASES='
    case OPTION_MULTI_SUBSPACE:
      multi_subspace = 1;
      break;

    case OPTION_STUBGROUP_SIZE:
      {
	const char *end;
        group_size = bfd_scan_vma (optarg, &end, 0);
        if (*end)
	  einfo (_("%P%F: invalid number `%s'\''\n"), optarg);
      }
      break;
'

# Put these extra hppaelf routines in ld_${EMULATION_NAME}_emulation
#
LDEMUL_AFTER_PARSE=hppaelf_after_parse
LDEMUL_FINISH=gld${EMULATION_NAME}_finish
LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS=hppaelf_create_output_section_statements
@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@a29 8
static void hppaelf_after_parse PARAMS ((void));
static void hppaelf_create_output_section_statements PARAMS ((void));
static asection *hppaelf_add_stub_section
  PARAMS ((const char *, asection *));
static void hppaelf_layout_sections_again PARAMS ((void));
static void gld${EMULATION_NAME}_finish PARAMS ((void));
static void build_section_lists PARAMS ((lang_statement_union_type *));

d51 1
a51 1
hppaelf_after_parse ()
d53 1
a53 1
  if (link_info.relocateable)
d67 1
a67 1
hppaelf_create_output_section_statements ()
d69 7
a100 3
static bfd_boolean hook_in_stub
  PARAMS ((struct hook_stub_info *, lang_statement_union_type **));

d102 1
a102 3
hook_in_stub (info, lp)
     struct hook_stub_info *info;
     lang_statement_union_type **lp;
d174 1
a174 3
hppaelf_add_stub_section (stub_sec_name, input_section)
     const char *stub_sec_name;
     asection *input_section;
d215 1
a215 1
hppaelf_layout_sections_again ()
d238 1
a238 2
build_section_lists (statement)
     lang_statement_union_type *statement;
d255 1
a255 1
gld${EMULATION_NAME}_finish ()
d257 1
a257 1
  /* bfd_elf32_discard_info just plays with debugging sections,
d261 1
a261 1
  if (bfd_elf${ELFSIZE}_discard_info (output_bfd, &link_info))
d266 1
a266 1
  if (! link_info.relocateable)
d298 1
a298 1
  if (! link_info.relocateable)
d308 1
a308 1
      if (stub_file->the_bfd->sections != NULL)
d320 1
a320 6
static void hppa_for_each_input_file_wrapper
  PARAMS ((lang_input_statement_type *));
static void hppa_lang_for_each_input_file
  PARAMS ((void (*) (lang_input_statement_type *)));

static void (*real_func) PARAMS ((lang_input_statement_type *));
d322 1
a322 2
static void hppa_for_each_input_file_wrapper (l)
     lang_input_statement_type *l;
d329 1
a329 2
hppa_lang_for_each_input_file (func)
     void (*func) PARAMS ((lang_input_statement_type *));
@


1.3
log
@resolve conflicts.
@
text
@d2 1
a2 1
#   Copyright 1991, 1993, 1994, 1997, 1999, 2000, 2001
d30 1
a30 1
static void hppaelf_after_parse PARAMS((void));
a31 2
static void hppaelf_delete_padding_statements
  PARAMS ((lang_statement_list_type *));
d34 3
a36 2
static void hppaelf_layaout_sections_again PARAMS ((void));
static void hppaelf_finish PARAMS ((void));
d47 3
d63 1
a63 1
#if 0 /* enable this once we split millicode stuff from libgcc */
a92 57
/* Walk all the lang statements splicing out any padding statements from
   the list.  */

static void
hppaelf_delete_padding_statements (list)
     lang_statement_list_type *list;
{
  lang_statement_union_type *s;
  lang_statement_union_type **ps;
  for (ps = &list->head; (s = *ps) != NULL; ps = &s->next)
    {
      switch (s->header.type)
	{

	/* We want to recursively walk these sections.  */
	case lang_constructors_statement_enum:
	  hppaelf_delete_padding_statements (&constructor_list);
	  break;

	case lang_output_section_statement_enum:
	  hppaelf_delete_padding_statements (&s->output_section_statement.children);
	  break;

	case lang_group_statement_enum:
	  hppaelf_delete_padding_statements (&s->group_statement.children);
	  break;

	case lang_wild_statement_enum:
	  hppaelf_delete_padding_statements (&s->wild_statement.children);
	  break;

	/* Here's what we are really looking for.  Splice these out of
	   the list.  */
	case lang_padding_statement_enum:
	  *ps = s->next;
	  if (*ps == NULL)
	    list->tail = ps;
	  break;

	/* We don't care about these cases.  */
	case lang_data_statement_enum:
	case lang_object_symbols_statement_enum:
	case lang_output_statement_enum:
	case lang_target_statement_enum:
	case lang_input_section_enum:
	case lang_input_statement_enum:
	case lang_assignment_statement_enum:
	case lang_address_statement_enum:
	  break;

	default:
	  abort ();
	  break;
	}
    }
}

d102 1
a102 1
static boolean hook_in_stub
d105 1
a105 1
static boolean
d111 1
a111 1
  boolean ret;
d113 1
a113 1
  for (; (l = *lp) != NULL; lp = &l->next)
d149 1
a149 1
	      return true;
d170 1
a170 1
  return false;
d206 1
a206 1
  wild_doit (&info.add, stub_sec, os, stub_file);
d223 1
a223 1
hppaelf_layaout_sections_again ()
d228 1
d230 1
a230 2
  /* Delete all the padding statements, they're no longer valid.  */
  hppaelf_delete_padding_statements (stat_ptr);
d234 1
a234 1
		      &stat_ptr->head, 0, (bfd_vma) 0, false);
d241 16
a256 1
		       (fill_type) 0, (bfd_vma) 0);
d264 1
a264 1
hppaelf_finish ()
d266 7
d275 13
a287 2
  if (link_info.relocateable)
    return;
d289 13
a301 11
  /* Call into the BFD backend to do the real work.  */
  if (! elf32_hppa_size_stubs (output_bfd,
			       stub_file->the_bfd,
			       &link_info,
			       multi_subspace,
			       group_size,
			       &hppaelf_add_stub_section,
			       &hppaelf_layaout_sections_again))
    {
      einfo ("%X%P: can not size stub section: %E\n");
      return;
d304 4
a307 2
  /* Set the global data pointer.  */
  if (! elf32_hppa_set_gp (output_bfd, &link_info))
d309 6
a314 3
      einfo ("%X%P: can not set gp\n");
      return;
    }
d316 6
a321 5
  /* Now build the linker stubs.  */
  if (stub_file->the_bfd->sections != NULL)
    {
      if (! elf32_hppa_build_stubs (&link_info))
	einfo ("%X%P: can not build stubs: %E\n");
a362 2
# The options are repeated below so that no abbreviations are allowed.
# Otherwise -s matches stub-group-size
a364 2
  { "multi-subspace", no_argument, NULL, OPTION_MULTI_SUBSPACE },
  { "stub-group-size", required_argument, NULL, OPTION_STUBGROUP_SIZE },
d370 2
a371 2
  --multi-subspace    Generate import and export stubs to support\n\
                        multiple sub-space shared libraries\n"
d374 7
a380 7
  --stub-group-size=N Maximum size of a group of input sections that can be\n\
                        handled by one stub section.  A negative value\n\
                        locates all stubs before their branches (with a\n\
                        group size of -N), while a positive value allows\n\
                        two groups of input sections, one before, and one\n\
                        after each stub section.  Values of +/-1 indicate\n\
                        the linker should choose suitable defaults."
d402 1
a402 1
LDEMUL_FINISH=hppaelf_finish
@


1.2
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 25
a26 33
# It does some substitutions.
cat >e${EMULATION_NAME}.c <<EOF
/* An emulation for HP PA-RISC ELF linkers.
   Copyright (C) 1991, 93, 94, 95, 97, 1999 Free Software Foundation, Inc.
   Written by Steve Chamberlain steve@@cygnus.com

This file is part of GLD, the Gnu Linker.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "bfd.h"
#include "sysdep.h"
#include "bfdlink.h"

#include "ld.h"
#include "ldemul.h"
#include "ldfile.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldmisc.h"
#include "ldmain.h"
d28 1
d30 8
a37 4
/* Section in which we build stubs.  */
static asection *stub_sec;
static lang_input_statement_type *stub_file;

a38 2
/* FIXME.  This doesn't belong here.  */
extern lang_statement_list_type file_chain;
d40 2
a41 2
/* Perform some emulation specific initialization.  For PA ELF we set
   up the local label prefix and the output architecture.  */
d43 9
a51 5
static void
hppaelf_before_parse ()
{
  ldfile_output_architecture = bfd_arch_hppa;
}
d53 2
a54 1
/* Set the output architecture and machine.  */
d57 1
a57 1
hppaelf_set_output_arch()
d59 8
a66 3
  unsigned long machine = 0;

  bfd_set_arch_mach (output_bfd, ldfile_output_architecture, machine);
d70 1
a70 1
   fake input file to hold the stub section.  */
a87 15
  stub_sec = bfd_make_section_old_way (stub_file->the_bfd, ".text");
  /* Don't set SEC_RELOC until we actually have relocations in this
     section.  */
  if (stub_sec == NULL
      || ! bfd_set_section_flags (stub_file->the_bfd, stub_sec,
				  (SEC_HAS_CONTENTS
				   | SEC_ALLOC
				   | SEC_LOAD
				   | SEC_CODE
				   | SEC_IN_MEMORY)))
    {
      einfo ("%X%P: can not create stub section: %E\n");
      return;
    }

d91 1
a91 1
/* Walk all the lang statements splicing out any padding statements from 
d95 2
a96 3
hppaelf_delete_padding_statements (s, prev)
     lang_statement_union_type *s;
     lang_statement_union_type **prev;
d98 3
a100 2
  lang_statement_union_type *sprev = NULL;
  for (; s != NULL; s = s->next)
d105 1
a105 1
	/* We want recursively walk these sections.  */
d107 1
a107 2
	  hppaelf_delete_padding_statements (constructor_list.head,
					     &constructor_list.head);
d111 5
a115 4
	  hppaelf_delete_padding_statements (s->output_section_statement.
					       children.head,
					     &s->output_section_statement.
					       children.head);
a117 1
	/* Huh?  What is a lang_wild_statement?  */
d119 1
a119 4
	  hppaelf_delete_padding_statements (s->wild_statement.
					       children.head,
					     &s->wild_statement.
					       children.head);
d125 3
a127 4
	  if (sprev)
	    sprev->header.next = s->header.next;
	  else
	    **prev = *s;
a144 1
      sprev = s;
d148 152
d306 5
d312 7
a318 2
  if (elf32_hppa_size_stubs (stub_file->the_bfd, output_bfd, &link_info)
      == false)
d323 3
a325 5
  
  /* If the size of the stub section is nonzero, then we need
     to resize the sections, recompute the assignments, and finally
     build the stubs.  */
  if (bfd_section_size (stub_file->the_bfd, stub_file->the_bfd->sections) != 0)
d327 9
a335 21
      /* Delete all the padding statements, they're no longer valid.  */
      hppaelf_delete_padding_statements (stat_ptr->head, &stat_ptr->head);
      
      /* Resize the sections.  */
      lang_size_sections (stat_ptr->head, abs_output_section,
			  &stat_ptr->head, 0, (bfd_vma) 0, false);
      
      /* Redo special stuff.  */
      ldemul_after_allocation ();
      
      /* Do the assignments again.  */
      lang_do_assignments (stat_ptr->head,
			   abs_output_section,
			   (fill_type) 0, (bfd_vma) 0);
      
      /* Now build the linker stubs.  */
      if (elf32_hppa_build_stubs (stub_file->the_bfd, &link_info) == false)
	{
	  einfo ("%X%P: can not build stubs: %E\n");
	  return;
	}
a338 1
/* The script itself gets inserted here.  */
d340 2
a341 4
static char *
hppaelf_get_script(isfile)
     int *isfile;
EOF
d343 4
a346 3
if test -n "$COMPILE_IN"
then
# Scripts compiled in.
d348 1
a348 2
# sed commands to quote an ld script as a C string.
sc="-f stringify.sed"
d350 6
a355 3
cat >>e${EMULATION_NAME}.c <<EOF
{			     
  *isfile = 0;
d357 7
a363 16
  if (link_info.relocateable == true && config.build_constructors == true)
    return
EOF
sed $sc ldscripts/${EMULATION_NAME}.xu                     >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocateable == true) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                     >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'         >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                    >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                     >> e${EMULATION_NAME}.c
echo '  ; else return'                                     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                      >> e${EMULATION_NAME}.c
echo '; }'                                                 >> e${EMULATION_NAME}.c

else
# Scripts read from the filesystem.
d365 1
a365 3
cat >>e${EMULATION_NAME}.c <<EOF
{			     
  *isfile = 1;
a366 11
  if (link_info.relocateable == true && config.build_constructors == true)
    return "ldscripts/${EMULATION_NAME}.xu";
  else if (link_info.relocateable == true)
    return "ldscripts/${EMULATION_NAME}.xr";
  else if (!config.text_read_only)
    return "ldscripts/${EMULATION_NAME}.xbn";
  else if (!config.magic_demand_paged)
    return "ldscripts/${EMULATION_NAME}.xn";
  else
    return "ldscripts/${EMULATION_NAME}.x";
}
d369 53
a421 30
fi

cat >>e${EMULATION_NAME}.c <<EOF

struct ld_emulation_xfer_struct ld_hppaelf_emulation = 
{
  hppaelf_before_parse,
  syslib_default,
  hll_default,
  after_parse_default,
  after_open_default,
  after_allocation_default,
  hppaelf_set_output_arch,
  ldemul_default_target,
  before_allocation_default,
  hppaelf_get_script,
  "hppaelf",
  "elf32-hppa",
  hppaelf_finish,
  hppaelf_create_output_section_statements,
  NULL,	/* open dynamic archive */
  NULL,	/* place orphan */
  NULL,	/* set symbols */
  NULL,	/* parse args */
  NULL,	/* unrecognized file */
  NULL,	/* list options */
  NULL,	/* recognized file */
  NULL 	/* find_potential_libraries */
};
EOF
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
   Copyright (C) 1991, 1993 Free Software Foundation, Inc.
a50 3
  link_info.lprefix = "L$";
  link_info.lprefix_len = 2;

d219 1
a219 5
sc='s/["\\]/\\&/g
s/$/\\n\\/
1s/^/"/
$s/$/n"/
'
d226 1
a226 10
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xu`;
  else if (link_info.relocateable == true)
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xr`;
  else if (!config.text_read_only)
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xbn`;
  else if (!config.magic_demand_paged)
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xn`;
  else
    return `sed "$sc" ldscripts/${EMULATION_NAME}.x`;
}
d228 10
d279 8
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d5 1
a5 1
   Copyright (C) 1991, 93, 94, 95, 1997 Free Software Foundation, Inc.
d51 3
@


1.1.1.3
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d5 1
a5 1
   Copyright (C) 1991, 93, 94, 95, 97, 1999 Free Software Foundation, Inc.
d219 5
a223 1
sc="-f stringify.sed"
d230 10
a239 1
    return
a240 10
sed $sc ldscripts/${EMULATION_NAME}.xu                     >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocateable == true) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                     >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'         >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                    >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                     >> e${EMULATION_NAME}.c
echo '  ; else return'                                     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                      >> e${EMULATION_NAME}.c
echo '; }'                                                 >> e${EMULATION_NAME}.c
a281 8
  NULL,	/* open dynamic archive */
  NULL,	/* place orphan */
  NULL,	/* set symbols */
  NULL,	/* parse args */
  NULL,	/* unrecognized file */
  NULL,	/* list options */
  NULL,	/* recognized file */
  NULL 	/* find_potential_libraries */
@


1.1.1.4
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 34
a35 24
#   Copyright 1991, 1993, 1994, 1997, 1999, 2000, 2001
#   Free Software Foundation, Inc.
#
# This file is part of GLD, the Gnu Linker.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#

# This file is sourced from elf32.em, and defines extra hppa-elf
# specific routines.
#
cat >>e${EMULATION_NAME}.c <<EOF
d37 3
a39 2
#include "ldctor.h"
#include "elf32-hppa.h"
a40 8
static void hppaelf_after_parse PARAMS((void));
static void hppaelf_create_output_section_statements PARAMS ((void));
static void hppaelf_delete_padding_statements
  PARAMS ((lang_statement_list_type *));
static asection *hppaelf_add_stub_section
  PARAMS ((const char *, asection *));
static void hppaelf_layaout_sections_again PARAMS ((void));
static void hppaelf_finish PARAMS ((void));
d42 2
d45 2
a46 2
/* Fake input file for stubs.  */
static lang_input_statement_type *stub_file;
d48 5
a52 9
/* Type of import/export stubs to build.  For a single sub-space model,
   we can build smaller import stubs and there is no need for export
   stubs.  */
static int multi_subspace = 0;

/* Maximum size of a group of input sections that can be handled by
   one stub section.  A value of +/-1 indicates the bfd back-end
   should use a suitable default size.  */
static bfd_signed_vma group_size = 1;
d54 1
a54 2
/* Stops the linker merging .text sections on a relocatable link,
   and adds millicode library to the list of input files.  */
d57 1
a57 1
hppaelf_after_parse ()
d59 3
a61 8
  if (link_info.relocateable)
    lang_add_unique (".text");
#if 0 /* enable this once we split millicode stuff from libgcc */
  else
    lang_add_input_file ("milli",
			 lang_input_file_is_l_enum,
			 NULL);
#endif
d65 1
a65 1
   fake input file to hold the stub sections.  */
d83 15
d101 1
a101 1
/* Walk all the lang statements splicing out any padding statements from
d105 3
a107 2
hppaelf_delete_padding_statements (list)
     lang_statement_list_type *list;
d109 2
a110 3
  lang_statement_union_type *s;
  lang_statement_union_type **ps;
  for (ps = &list->head; (s = *ps) != NULL; ps = &s->next)
d115 1
a115 1
	/* We want to recursively walk these sections.  */
d117 2
a118 1
	  hppaelf_delete_padding_statements (&constructor_list);
d122 4
a125 5
	  hppaelf_delete_padding_statements (&s->output_section_statement.children);
	  break;

	case lang_group_statement_enum:
	  hppaelf_delete_padding_statements (&s->group_statement.children);
d128 1
d130 4
a133 1
	  hppaelf_delete_padding_statements (&s->wild_statement.children);
d139 4
a142 3
	  *ps = s->next;
	  if (*ps == NULL)
	    list->tail = ps;
d160 1
a163 152

struct hook_stub_info
{
  lang_statement_list_type add;
  asection *input_section;
};

/* Traverse the linker tree to find the spot where the stub goes.  */

static boolean hook_in_stub
  PARAMS ((struct hook_stub_info *, lang_statement_union_type **));

static boolean
hook_in_stub (info, lp)
     struct hook_stub_info *info;
     lang_statement_union_type **lp;
{
  lang_statement_union_type *l;
  boolean ret;

  for (; (l = *lp) != NULL; lp = &l->next)
    {
      switch (l->header.type)
	{
	case lang_constructors_statement_enum:
	  ret = hook_in_stub (info, &constructor_list.head);
	  if (ret)
	    return ret;
	  break;

	case lang_output_section_statement_enum:
	  ret = hook_in_stub (info,
			      &l->output_section_statement.children.head);
	  if (ret)
	    return ret;
	  break;

	case lang_wild_statement_enum:
	  ret = hook_in_stub (info, &l->wild_statement.children.head);
	  if (ret)
	    return ret;
	  break;

	case lang_group_statement_enum:
	  ret = hook_in_stub (info, &l->group_statement.children.head);
	  if (ret)
	    return ret;
	  break;

	case lang_input_section_enum:
	  if (l->input_section.section == info->input_section)
	    {
	      /* We've found our section.  Insert the stub immediately
		 before its associated input section.  */
	      *lp = info->add.head;
	      *(info->add.tail) = l;
	      return true;
	    }
	  break;

	case lang_data_statement_enum:
	case lang_reloc_statement_enum:
	case lang_object_symbols_statement_enum:
	case lang_output_statement_enum:
	case lang_target_statement_enum:
	case lang_input_statement_enum:
	case lang_assignment_statement_enum:
	case lang_padding_statement_enum:
	case lang_address_statement_enum:
	case lang_fill_statement_enum:
	  break;

	default:
	  FAIL ();
	  break;
	}
    }
  return false;
}


/* Call-back for elf32_hppa_size_stubs.  */

/* Create a new stub section, and arrange for it to be linked
   immediately before INPUT_SECTION.  */

static asection *
hppaelf_add_stub_section (stub_sec_name, input_section)
     const char *stub_sec_name;
     asection *input_section;
{
  asection *stub_sec;
  flagword flags;
  asection *output_section;
  const char *secname;
  lang_output_section_statement_type *os;
  struct hook_stub_info info;

  stub_sec = bfd_make_section_anyway (stub_file->the_bfd, stub_sec_name);
  if (stub_sec == NULL)
    goto err_ret;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
	   | SEC_HAS_CONTENTS | SEC_RELOC | SEC_IN_MEMORY | SEC_KEEP);
  if (!bfd_set_section_flags (stub_file->the_bfd, stub_sec, flags))
    goto err_ret;

  output_section = input_section->output_section;
  secname = bfd_get_section_name (output_section->owner, output_section);
  os = lang_output_section_find (secname);

  info.input_section = input_section;
  lang_list_init (&info.add);
  wild_doit (&info.add, stub_sec, os, stub_file);

  if (info.add.head == NULL)
    goto err_ret;

  if (hook_in_stub (&info, &os->children.head))
    return stub_sec;

 err_ret:
  einfo ("%X%P: can not make stub section: %E\n");
  return NULL;
}


/* Another call-back for elf32_hppa_size_stubs.  */

static void
hppaelf_layaout_sections_again ()
{
  /* If we have changed sizes of the stub sections, then we need
     to recalculate all the section offsets.  This may mean we need to
     add even more stubs.  */

  /* Delete all the padding statements, they're no longer valid.  */
  hppaelf_delete_padding_statements (stat_ptr);

  /* Resize the sections.  */
  lang_size_sections (stat_ptr->head, abs_output_section,
		      &stat_ptr->head, 0, (bfd_vma) 0, false);

  /* Redo special stuff.  */
  ldemul_after_allocation ();

  /* Do the assignments again.  */
  lang_do_assignments (stat_ptr->head, abs_output_section,
		       (fill_type) 0, (bfd_vma) 0);
}


a169 5
  /* If generating a relocatable output file, then we don't
     have to examine the relocs.  */
  if (link_info.relocateable)
    return;

d171 2
a172 7
  if (! elf32_hppa_size_stubs (output_bfd,
			       stub_file->the_bfd,
			       &link_info,
			       multi_subspace,
			       group_size,
			       &hppaelf_add_stub_section,
			       &hppaelf_layaout_sections_again))
d177 5
a181 3

  /* Set the global data pointer.  */
  if (! elf32_hppa_set_gp (output_bfd, &link_info))
d183 21
a203 2
      einfo ("%X%P: can not set gp\n");
      return;
d205 8
d214 3
a216 7
  /* Now build the linker stubs.  */
  if (stub_file->the_bfd->sections != NULL)
    {
      if (! elf32_hppa_build_stubs (&link_info))
	einfo ("%X%P: can not build stubs: %E\n");
    }
}
d218 2
d221 3
a223 2
/* Avoid processing the fake stub_file in vercheck, stat_needed and
   check_needed routines.  */
d225 13
a237 4
static void hppa_for_each_input_file_wrapper
  PARAMS ((lang_input_statement_type *));
static void hppa_lang_for_each_input_file
  PARAMS ((void (*) (lang_input_statement_type *)));
d239 2
a240 1
static void (*real_func) PARAMS ((lang_input_statement_type *));
d242 14
a255 5
static void hppa_for_each_input_file_wrapper (l)
     lang_input_statement_type *l;
{
  if (l != stub_file)
    (*real_func) (l);
d257 1
d259 1
a259 7
static void
hppa_lang_for_each_input_file (func)
     void (*func) PARAMS ((lang_input_statement_type *));
{
  real_func = func;
  lang_for_each_input_file (&hppa_for_each_input_file_wrapper);
}
d261 1
a261 1
#define lang_for_each_input_file hppa_lang_for_each_input_file
d263 25
a288 54

# Define some shell vars to insert bits of code into the standard elf
# parse_args and list_options functions.
#
PARSE_AND_LIST_PROLOGUE='
#define OPTION_MULTI_SUBSPACE		301
#define OPTION_STUBGROUP_SIZE		(OPTION_MULTI_SUBSPACE + 1)
'

# The options are repeated below so that no abbreviations are allowed.
# Otherwise -s matches stub-group-size
PARSE_AND_LIST_LONGOPTS='
  { "multi-subspace", no_argument, NULL, OPTION_MULTI_SUBSPACE },
  { "multi-subspace", no_argument, NULL, OPTION_MULTI_SUBSPACE },
  { "stub-group-size", required_argument, NULL, OPTION_STUBGROUP_SIZE },
  { "stub-group-size", required_argument, NULL, OPTION_STUBGROUP_SIZE },
'

PARSE_AND_LIST_OPTIONS='
  fprintf (file, _("\
  --multi-subspace    Generate import and export stubs to support\n\
                        multiple sub-space shared libraries\n"
		   ));
  fprintf (file, _("\
  --stub-group-size=N Maximum size of a group of input sections that can be\n\
                        handled by one stub section.  A negative value\n\
                        locates all stubs before their branches (with a\n\
                        group size of -N), while a positive value allows\n\
                        two groups of input sections, one before, and one\n\
                        after each stub section.  Values of +/-1 indicate\n\
                        the linker should choose suitable defaults."
		   ));
'

PARSE_AND_LIST_ARGS_CASES='
    case OPTION_MULTI_SUBSPACE:
      multi_subspace = 1;
      break;

    case OPTION_STUBGROUP_SIZE:
      {
	const char *end;
        group_size = bfd_scan_vma (optarg, &end, 0);
        if (*end)
	  einfo (_("%P%F: invalid number `%s'\''\n"), optarg);
      }
      break;
'

# Put these extra hppaelf routines in ld_${EMULATION_NAME}_emulation
#
LDEMUL_AFTER_PARSE=hppaelf_after_parse
LDEMUL_FINISH=hppaelf_finish
LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS=hppaelf_create_output_section_statements
@


1.1.1.5
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
#   Copyright 1991, 1993, 1994, 1997, 1999, 2000, 2001, 2002, 2003
d30 1
a30 1
static void hppaelf_after_parse PARAMS ((void));
d32 2
d36 2
a37 3
static void hppaelf_layout_sections_again PARAMS ((void));
static void gld${EMULATION_NAME}_finish PARAMS ((void));
static void build_section_lists PARAMS ((lang_statement_union_type *));
a47 3
/* Whether we need to call hppa_layout_sections_again.  */
static int need_laying_out = 0;

d61 1
a61 1
#if 0 /* Enable this once we split millicode stuff from libgcc.  */
d91 57
d157 1
a157 1
static bfd_boolean hook_in_stub
d160 1
a160 1
static bfd_boolean
d166 1
a166 1
  bfd_boolean ret;
d168 1
a168 1
  for (; (l = *lp) != NULL; lp = &l->header.next)
d204 1
a204 1
	      return TRUE;
d225 1
a225 1
  return FALSE;
d261 1
a261 1
  lang_add_section (&info.add, stub_sec, os, stub_file);
d278 1
a278 1
hppaelf_layout_sections_again ()
a282 1
  need_laying_out = 0;
d284 2
a285 1
  lang_reset_memory_regions ();
d289 1
a289 1
		      &stat_ptr->head, 0, (bfd_vma) 0, NULL, TRUE);
d296 1
a296 16
		       (fill_type *) 0, (bfd_vma) 0);
}


static void
build_section_lists (statement)
     lang_statement_union_type *statement;
{
  if (statement->header.type == lang_input_section_enum
      && !statement->input_section.ifile->just_syms_flag
      && statement->input_section.section->output_section != NULL
      && statement->input_section.section->output_section->owner == output_bfd)
    {
      elf32_hppa_next_input_section (&link_info,
				     statement->input_section.section);
    }
d304 1
a304 1
gld${EMULATION_NAME}_finish ()
a305 7
  /* bfd_elf32_discard_info just plays with debugging sections,
     ie. doesn't affect any code, so we can delay resizing the
     sections.  It's likely we'll resize everything in the process of
     adding stubs.  */
  if (bfd_elf${ELFSIZE}_discard_info (output_bfd, &link_info))
    need_laying_out = 1;

d308 11
a318 1
  if (! link_info.relocateable)
d320 3
a322 1
      int ret = elf32_hppa_setup_section_lists (output_bfd, &link_info);
d324 5
a328 23
      if (ret != 0)
	{
	  if (ret < 0)
	    {
	      einfo ("%X%P: can not size stub section: %E\n");
	      return;
	    }

	  lang_for_each_statement (build_section_lists);

	  /* Call into the BFD backend to do the real work.  */
	  if (! elf32_hppa_size_stubs (output_bfd,
				       stub_file->the_bfd,
				       &link_info,
				       multi_subspace,
				       group_size,
				       &hppaelf_add_stub_section,
				       &hppaelf_layout_sections_again))
	    {
	      einfo ("%X%P: can not size stub section: %E\n");
	      return;
	    }
	}
d331 2
a332 4
  if (need_laying_out)
    hppaelf_layout_sections_again ();

  if (! link_info.relocateable)
d334 2
a335 13
      /* Set the global data pointer.  */
      if (! elf32_hppa_set_gp (output_bfd, &link_info))
	{
	  einfo ("%X%P: can not set gp\n");
	  return;
	}

      /* Now build the linker stubs.  */
      if (stub_file->the_bfd->sections != NULL)
	{
	  if (! elf32_hppa_build_stubs (&link_info))
	    einfo ("%X%P: can not build stubs: %E\n");
	}
d377 2
d381 2
d388 2
a389 2
  --multi-subspace      Generate import and export stubs to support\n\
                          multiple sub-space shared libraries\n"
d392 7
a398 7
  --stub-group-size=N   Maximum size of a group of input sections that can be\n\
                          handled by one stub section.  A negative value\n\
                          locates all stubs before their branches (with a\n\
                          group size of -N), while a positive value allows\n\
                          two groups of input sections, one before, and one\n\
                          after each stub section.  Values of +/-1 indicate\n\
                          the linker should choose suitable defaults.\n"
d420 1
a420 1
LDEMUL_FINISH=gld${EMULATION_NAME}_finish
@


1.1.1.6
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d30 8
d59 1
a59 1
hppaelf_after_parse (void)
d61 1
a61 1
  if (link_info.relocatable)
d75 1
a75 1
hppaelf_create_output_section_statements (void)
a76 7
  extern const bfd_target bfd_elf32_hppa_linux_vec;
  extern const bfd_target bfd_elf32_hppa_vec;

  if (link_info.hash->creator != &bfd_elf32_hppa_linux_vec
      && link_info.hash->creator != &bfd_elf32_hppa_vec)
    return;

d102 3
d106 3
a108 1
hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)
d180 3
a182 1
hppaelf_add_stub_section (const char *stub_sec_name, asection *input_section)
d223 1
a223 1
hppaelf_layout_sections_again (void)
d246 2
a247 1
build_section_lists (lang_statement_union_type *statement)
d264 1
a264 1
gld${EMULATION_NAME}_finish (void)
d266 1
a266 1
  /* bfd_elf_discard_info just plays with debugging sections,
d270 1
a270 1
  if (bfd_elf_discard_info (output_bfd, &link_info))
d275 1
a275 1
  if (stub_file != NULL && !link_info.relocatable)
d307 1
a307 1
  if (! link_info.relocatable)
d317 1
a317 1
      if (stub_file != NULL && stub_file->the_bfd->sections != NULL)
d329 6
a334 1
static void (*real_func) (lang_input_statement_type *);
d336 2
a337 1
static void hppa_for_each_input_file_wrapper (lang_input_statement_type *l)
d344 2
a345 1
hppa_lang_for_each_input_file (void (*func) (lang_input_statement_type *))
@


