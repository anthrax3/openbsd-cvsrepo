head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.52
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.8
date	2004.11.02.20.45.51;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.51;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.43;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.12.49;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.52.39;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.09.55;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.54.54;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.39;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.39;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.36.07;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.35.51;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.38.49;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.29.16;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.48.22;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.14.02.00;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.54;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.23.26;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@# This shell script emits a C file. -*- C -*-
# It does some substitutions.
if [ -z "$MACHINE" ]; then
  OUTPUT_ARCH=${ARCH}
else
  OUTPUT_ARCH=${ARCH}:${MACHINE}
fi
rm -f e${EMULATION_NAME}.c
(echo;echo;echo;echo;echo)>e${EMULATION_NAME}.c # there, now line numbers match ;-)
cat >>e${EMULATION_NAME}.c <<EOF
/* This file is part of GLD, the Gnu Linker.
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* For WINDOWS_NT */
/* The original file generated returned different default scripts depending
   on whether certain switches were set, but these switches pertain to the
   Linux system and that particular version of coff.  In the NT case, we
   only determine if the subsystem is console or windows in order to select
   the correct entry point by default. */

#define TARGET_IS_${EMULATION_NAME}

/* Do this before including bfd.h, so we prototype the right functions.  */
#ifdef TARGET_IS_arm_epoc_pe
#define bfd_arm_pe_allocate_interworking_sections \
	bfd_arm_epoc_pe_allocate_interworking_sections
#define bfd_arm_pe_get_bfd_for_interworking \
	bfd_arm_epoc_pe_get_bfd_for_interworking
#define bfd_arm_pe_process_before_allocation \
	bfd_arm_epoc_pe_process_before_allocation
#endif

#include "bfd.h"
#include "sysdep.h"
#include "bfdlink.h"
#include "getopt.h"
#include "libiberty.h"
#include "ld.h"
#include "ldmain.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldfile.h"
#include "ldemul.h"
#include <ldgram.h>
#include "ldlex.h"
#include "ldmisc.h"
#include "ldctor.h"
#include "coff/internal.h"

/* FIXME: This is a BFD internal header file, and we should not be
   using it here.  */
#include "../bfd/libcoff.h"

#include "deffile.h"
#include "pe-dll.h"
#include "safe-ctype.h"

/* Permit the emulation parameters to override the default section
   alignment by setting OVERRIDE_SECTION_ALIGNMENT.  FIXME: This makes
   it seem that include/coff/internal.h should not define
   PE_DEF_SECTION_ALIGNMENT.  */
#if PE_DEF_SECTION_ALIGNMENT != ${OVERRIDE_SECTION_ALIGNMENT:-PE_DEF_SECTION_ALIGNMENT}
#undef PE_DEF_SECTION_ALIGNMENT
#define PE_DEF_SECTION_ALIGNMENT ${OVERRIDE_SECTION_ALIGNMENT}
#endif

#if defined(TARGET_IS_i386pe)
#define DLL_SUPPORT
#endif
#if defined(TARGET_IS_shpe) || defined(TARGET_IS_mipspe) || defined(TARGET_IS_armpe)
#define DLL_SUPPORT
#endif

#if defined(TARGET_IS_i386pe) || ! defined(DLL_SUPPORT)
#define	PE_DEF_SUBSYSTEM		3
#else
#undef NT_EXE_IMAGE_BASE
#undef PE_DEF_SECTION_ALIGNMENT
#undef PE_DEF_FILE_ALIGNMENT
#define NT_EXE_IMAGE_BASE		0x00010000
#ifdef TARGET_IS_armpe
#define PE_DEF_SECTION_ALIGNMENT	0x00001000
#define	PE_DEF_SUBSYSTEM		9
#else
#define PE_DEF_SECTION_ALIGNMENT	0x00000400
#define	PE_DEF_SUBSYSTEM		2
#endif
#define PE_DEF_FILE_ALIGNMENT		0x00000200
#endif


static struct internal_extra_pe_aouthdr pe;
static int dll;
static int support_old_code = 0;
static char * thumb_entry_symbol = NULL;
static lang_assignment_statement_type *image_base_statement = 0;

#ifdef DLL_SUPPORT
static int pe_enable_stdcall_fixup = -1; /* 0=disable 1=enable.  */
static char *pe_out_def_filename = NULL;
static char *pe_implib_filename = NULL;
static int pe_enable_auto_image_base = 0;
static char *pe_dll_search_prefix = NULL;
#endif

extern const char *output_filename;

static void
gld_${EMULATION_NAME}_before_parse (void)
{
  ldfile_set_output_arch ("${OUTPUT_ARCH}", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);
  output_filename = "${EXECUTABLE_NAME:-a.exe}";
#ifdef DLL_SUPPORT
  config.dynamic_link = TRUE;
  config.has_shared = 1;
  link_info.pei386_auto_import = -1;
  link_info.pei386_runtime_pseudo_reloc = FALSE;

#if (PE_DEF_SUBSYSTEM == 9) || (PE_DEF_SUBSYSTEM == 2)
#if defined TARGET_IS_mipspe || defined TARGET_IS_armpe
  lang_add_entry ("WinMainCRTStartup", FALSE);
#else
  lang_add_entry ("_WinMainCRTStartup", FALSE);
#endif
#endif
#endif
}

/* PE format extra command line options.  */

/* Used for setting flags in the PE header.  */
#define OPTION_BASE_FILE		(300  + 1)
#define OPTION_DLL			(OPTION_BASE_FILE + 1)
#define OPTION_FILE_ALIGNMENT		(OPTION_DLL + 1)
#define OPTION_IMAGE_BASE		(OPTION_FILE_ALIGNMENT + 1)
#define OPTION_MAJOR_IMAGE_VERSION	(OPTION_IMAGE_BASE + 1)
#define OPTION_MAJOR_OS_VERSION		(OPTION_MAJOR_IMAGE_VERSION + 1)
#define OPTION_MAJOR_SUBSYSTEM_VERSION	(OPTION_MAJOR_OS_VERSION + 1)
#define OPTION_MINOR_IMAGE_VERSION	(OPTION_MAJOR_SUBSYSTEM_VERSION + 1)
#define OPTION_MINOR_OS_VERSION		(OPTION_MINOR_IMAGE_VERSION + 1)
#define OPTION_MINOR_SUBSYSTEM_VERSION	(OPTION_MINOR_OS_VERSION + 1)
#define OPTION_SECTION_ALIGNMENT	(OPTION_MINOR_SUBSYSTEM_VERSION + 1)
#define OPTION_STACK			(OPTION_SECTION_ALIGNMENT + 1)
#define OPTION_SUBSYSTEM		(OPTION_STACK + 1)
#define OPTION_HEAP			(OPTION_SUBSYSTEM + 1)
#define OPTION_SUPPORT_OLD_CODE		(OPTION_HEAP + 1)
#define OPTION_OUT_DEF			(OPTION_SUPPORT_OLD_CODE + 1)
#define OPTION_EXPORT_ALL		(OPTION_OUT_DEF + 1)
#define OPTION_EXCLUDE_SYMBOLS		(OPTION_EXPORT_ALL + 1)
#define OPTION_KILL_ATS			(OPTION_EXCLUDE_SYMBOLS + 1)
#define OPTION_STDCALL_ALIASES		(OPTION_KILL_ATS + 1)
#define OPTION_ENABLE_STDCALL_FIXUP	(OPTION_STDCALL_ALIASES + 1)
#define OPTION_DISABLE_STDCALL_FIXUP	(OPTION_ENABLE_STDCALL_FIXUP + 1)
#define OPTION_IMPLIB_FILENAME		(OPTION_DISABLE_STDCALL_FIXUP + 1)
#define OPTION_THUMB_ENTRY		(OPTION_IMPLIB_FILENAME + 1)
#define OPTION_WARN_DUPLICATE_EXPORTS	(OPTION_THUMB_ENTRY + 1)
#define OPTION_IMP_COMPAT		(OPTION_WARN_DUPLICATE_EXPORTS + 1)
#define OPTION_ENABLE_AUTO_IMAGE_BASE	(OPTION_IMP_COMPAT + 1)
#define OPTION_DISABLE_AUTO_IMAGE_BASE	(OPTION_ENABLE_AUTO_IMAGE_BASE + 1)
#define OPTION_DLL_SEARCH_PREFIX	(OPTION_DISABLE_AUTO_IMAGE_BASE + 1)
#define OPTION_NO_DEFAULT_EXCLUDES	(OPTION_DLL_SEARCH_PREFIX + 1)
#define OPTION_DLL_ENABLE_AUTO_IMPORT	(OPTION_NO_DEFAULT_EXCLUDES + 1)
#define OPTION_DLL_DISABLE_AUTO_IMPORT	(OPTION_DLL_ENABLE_AUTO_IMPORT + 1)
#define OPTION_ENABLE_EXTRA_PE_DEBUG	(OPTION_DLL_DISABLE_AUTO_IMPORT + 1)
#define OPTION_EXCLUDE_LIBS		(OPTION_ENABLE_EXTRA_PE_DEBUG + 1)
#define OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC	\
					(OPTION_EXCLUDE_LIBS + 1)
#define OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC	\
					(OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC + 1)

static void
gld${EMULATION_NAME}_add_options
  (int ns ATTRIBUTE_UNUSED, char **shortopts ATTRIBUTE_UNUSED, int nl,
    struct option **longopts, int nrl ATTRIBUTE_UNUSED,
    struct option **really_longopts ATTRIBUTE_UNUSED)
{
  static const struct option xtra_long[] = {
    /* PE options */
    {"base-file", required_argument, NULL, OPTION_BASE_FILE},
    {"dll", no_argument, NULL, OPTION_DLL},
    {"file-alignment", required_argument, NULL, OPTION_FILE_ALIGNMENT},
    {"heap", required_argument, NULL, OPTION_HEAP},
    {"image-base", required_argument, NULL, OPTION_IMAGE_BASE},
    {"major-image-version", required_argument, NULL, OPTION_MAJOR_IMAGE_VERSION},
    {"major-os-version", required_argument, NULL, OPTION_MAJOR_OS_VERSION},
    {"major-subsystem-version", required_argument, NULL, OPTION_MAJOR_SUBSYSTEM_VERSION},
    {"minor-image-version", required_argument, NULL, OPTION_MINOR_IMAGE_VERSION},
    {"minor-os-version", required_argument, NULL, OPTION_MINOR_OS_VERSION},
    {"minor-subsystem-version", required_argument, NULL, OPTION_MINOR_SUBSYSTEM_VERSION},
    {"section-alignment", required_argument, NULL, OPTION_SECTION_ALIGNMENT},
    {"stack", required_argument, NULL, OPTION_STACK},
    {"subsystem", required_argument, NULL, OPTION_SUBSYSTEM},
    {"support-old-code", no_argument, NULL, OPTION_SUPPORT_OLD_CODE},
    {"thumb-entry", required_argument, NULL, OPTION_THUMB_ENTRY},
#ifdef DLL_SUPPORT
    /* getopt allows abbreviations, so we do this to stop it from treating -o
       as an abbreviation for this option */
    {"output-def", required_argument, NULL, OPTION_OUT_DEF},
    {"output-def", required_argument, NULL, OPTION_OUT_DEF},
    {"export-all-symbols", no_argument, NULL, OPTION_EXPORT_ALL},
    {"exclude-symbols", required_argument, NULL, OPTION_EXCLUDE_SYMBOLS},
    {"exclude-libs", required_argument, NULL, OPTION_EXCLUDE_LIBS},
    {"kill-at", no_argument, NULL, OPTION_KILL_ATS},
    {"add-stdcall-alias", no_argument, NULL, OPTION_STDCALL_ALIASES},
    {"enable-stdcall-fixup", no_argument, NULL, OPTION_ENABLE_STDCALL_FIXUP},
    {"disable-stdcall-fixup", no_argument, NULL, OPTION_DISABLE_STDCALL_FIXUP},
    {"out-implib", required_argument, NULL, OPTION_IMPLIB_FILENAME},
    {"warn-duplicate-exports", no_argument, NULL, OPTION_WARN_DUPLICATE_EXPORTS},
    /* getopt() allows abbreviations, so we do this to stop it from
       treating -c as an abbreviation for these --compat-implib.  */
    {"compat-implib", no_argument, NULL, OPTION_IMP_COMPAT},
    {"compat-implib", no_argument, NULL, OPTION_IMP_COMPAT},
    {"enable-auto-image-base", no_argument, NULL, OPTION_ENABLE_AUTO_IMAGE_BASE},
    {"disable-auto-image-base", no_argument, NULL, OPTION_DISABLE_AUTO_IMAGE_BASE},
    {"dll-search-prefix", required_argument, NULL, OPTION_DLL_SEARCH_PREFIX},
    {"no-default-excludes", no_argument, NULL, OPTION_NO_DEFAULT_EXCLUDES},
    {"enable-auto-import", no_argument, NULL, OPTION_DLL_ENABLE_AUTO_IMPORT},
    {"disable-auto-import", no_argument, NULL, OPTION_DLL_DISABLE_AUTO_IMPORT},
    {"enable-extra-pe-debug", no_argument, NULL, OPTION_ENABLE_EXTRA_PE_DEBUG},
    {"enable-runtime-pseudo-reloc", no_argument, NULL, OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC},
    {"disable-runtime-pseudo-reloc", no_argument, NULL, OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC},
#endif
    {NULL, no_argument, NULL, 0}
  };

  *longopts = (struct option *)
    xrealloc (*longopts, nl * sizeof (struct option) + sizeof (xtra_long));
  memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));
}

/* PE/WIN32; added routines to get the subsystem type, heap and/or stack
   parameters which may be input from the command line.  */

typedef struct
{
  void *ptr;
  int size;
  int value;
  char *symbol;
  int inited;
} definfo;

#define D(field,symbol,def)  {&pe.field,sizeof(pe.field), def, symbol,0}

static definfo init[] =
{
  /* imagebase must be first */
#define IMAGEBASEOFF 0
  D(ImageBase,"__image_base__", NT_EXE_IMAGE_BASE),
#define DLLOFF 1
  {&dll, sizeof(dll), 0, "__dll__", 0},
  D(SectionAlignment,"__section_alignment__", PE_DEF_SECTION_ALIGNMENT),
  D(FileAlignment,"__file_alignment__", PE_DEF_FILE_ALIGNMENT),
  D(MajorOperatingSystemVersion,"__major_os_version__", 4),
  D(MinorOperatingSystemVersion,"__minor_os_version__", 0),
  D(MajorImageVersion,"__major_image_version__", 1),
  D(MinorImageVersion,"__minor_image_version__", 0),
#ifdef TARGET_IS_armpe
  D(MajorSubsystemVersion,"__major_subsystem_version__", 2),
#else
  D(MajorSubsystemVersion,"__major_subsystem_version__", 4),
#endif
  D(MinorSubsystemVersion,"__minor_subsystem_version__", 0),
  D(Subsystem,"__subsystem__", ${SUBSYSTEM}),
  D(SizeOfStackReserve,"__size_of_stack_reserve__", 0x200000),
  D(SizeOfStackCommit,"__size_of_stack_commit__", 0x1000),
  D(SizeOfHeapReserve,"__size_of_heap_reserve__", 0x100000),
  D(SizeOfHeapCommit,"__size_of_heap_commit__", 0x1000),
  D(LoaderFlags,"__loader_flags__", 0x0),
  { NULL, 0, 0, NULL, 0 }
};


static void
gld_${EMULATION_NAME}_list_options (FILE *file)
{
  fprintf (file, _("  --base_file <basefile>             Generate a base file for relocatable DLLs\n"));
  fprintf (file, _("  --dll                              Set image base to the default for DLLs\n"));
  fprintf (file, _("  --file-alignment <size>            Set file alignment\n"));
  fprintf (file, _("  --heap <size>                      Set initial size of the heap\n"));
  fprintf (file, _("  --image-base <address>             Set start address of the executable\n"));
  fprintf (file, _("  --major-image-version <number>     Set version number of the executable\n"));
  fprintf (file, _("  --major-os-version <number>        Set minimum required OS version\n"));
  fprintf (file, _("  --major-subsystem-version <number> Set minimum required OS subsystem version\n"));
  fprintf (file, _("  --minor-image-version <number>     Set revision number of the executable\n"));
  fprintf (file, _("  --minor-os-version <number>        Set minimum required OS revision\n"));
  fprintf (file, _("  --minor-subsystem-version <number> Set minimum required OS subsystem revision\n"));
  fprintf (file, _("  --section-alignment <size>         Set section alignment\n"));
  fprintf (file, _("  --stack <size>                     Set size of the initial stack\n"));
  fprintf (file, _("  --subsystem <name>[:<version>]     Set required OS subsystem [& version]\n"));
  fprintf (file, _("  --support-old-code                 Support interworking with old code\n"));
  fprintf (file, _("  --thumb-entry=<symbol>             Set the entry point to be Thumb <symbol>\n"));
#ifdef DLL_SUPPORT
  fprintf (file, _("  --add-stdcall-alias                Export symbols with and without @@nn\n"));
  fprintf (file, _("  --disable-stdcall-fixup            Don't link _sym to _sym@@nn\n"));
  fprintf (file, _("  --enable-stdcall-fixup             Link _sym to _sym@@nn without warnings\n"));
  fprintf (file, _("  --exclude-symbols sym,sym,...      Exclude symbols from automatic export\n"));
  fprintf (file, _("  --exclude-libs lib,lib,...         Exclude libraries from automatic export\n"));
  fprintf (file, _("  --export-all-symbols               Automatically export all globals to DLL\n"));
  fprintf (file, _("  --kill-at                          Remove @@nn from exported symbols\n"));
  fprintf (file, _("  --out-implib <file>                Generate import library\n"));
  fprintf (file, _("  --output-def <file>                Generate a .DEF file for the built DLL\n"));
  fprintf (file, _("  --warn-duplicate-exports           Warn about duplicate exports.\n"));
  fprintf (file, _("  --compat-implib                    Create backward compatible import libs;\n\
                                       create __imp_<SYMBOL> as well.\n"));
  fprintf (file, _("  --enable-auto-image-base           Automatically choose image base for DLLs\n\
                                       unless user specifies one\n"));
  fprintf (file, _("  --disable-auto-image-base          Do not auto-choose image base. (default)\n"));
  fprintf (file, _("  --dll-search-prefix=<string>       When linking dynamically to a dll without\n\
                                       an importlib, use <string><basename>.dll\n\
                                       in preference to lib<basename>.dll \n"));
  fprintf (file, _("  --enable-auto-import               Do sophistcated linking of _sym to\n\
                                       __imp_sym for DATA references\n"));
  fprintf (file, _("  --disable-auto-import              Do not auto-import DATA items from DLLs\n"));
  fprintf (file, _("  --enable-runtime-pseudo-reloc      Work around auto-import limitations by\n\
                                       adding pseudo-relocations resolved at\n\
                                       runtime.\n"));
  fprintf (file, _("  --disable-runtime-pseudo-reloc     Do not add runtime pseudo-relocations for\n\
                                       auto-imported DATA.\n"));
  fprintf (file, _("  --enable-extra-pe-debug            Enable verbose debug output when building\n\
                                       or linking to DLLs (esp. auto-import)\n"));
#endif
}


static void
set_pe_name (char *name, long val)
{
  int i;

  /* Find the name and set it.  */
  for (i = 0; init[i].ptr; i++)
    {
      if (strcmp (name, init[i].symbol) == 0)
	{
	  init[i].value = val;
	  init[i].inited = 1;
	  return;
	}
    }
  abort ();
}


static void
set_pe_subsystem (void)
{
  const char *sver;
  int len;
  int i;
  static const struct
    {
      const char *name;
      const int value;
      const char *entry;
    }
  v[] =
    {
      { "native", 1, "NtProcessStartup" },
#if defined TARGET_IS_mipspe || defined TARGET_IS_armpe
      { "windows", 2, "WinMainCRTStartup" },
#else
      { "windows", 2, "WinMainCRTStartup" },
#endif
      { "console", 3, "mainCRTStartup" },
#if 0
      /* The Microsoft linker does not recognize this.  */
      { "os2", 5, "" },
#endif
      { "posix", 7, "__PosixProcessStartup"},
      { "wince", 9, "_WinMainCRTStartup" },
      { 0, 0, 0 }
    };

  sver = strchr (optarg, ':');
  if (sver == NULL)
    len = strlen (optarg);
  else
    {
      char *end;

      len = sver - optarg;
      set_pe_name ("__major_subsystem_version__",
		   strtoul (sver + 1, &end, 0));
      if (*end == '.')
	set_pe_name ("__minor_subsystem_version__",
		     strtoul (end + 1, &end, 0));
      if (*end != '\0')
	einfo (_("%P: warning: bad version number in -subsystem option\n"));
    }

  for (i = 0; v[i].name; i++)
    {
      if (strncmp (optarg, v[i].name, len) == 0
	  && v[i].name[len] == '\0')
	{
	  const char *initial_symbol_char;
	  const char *entry;

	  set_pe_name ("__subsystem__", v[i].value);

	  initial_symbol_char = ${INITIAL_SYMBOL_CHAR};
	  if (*initial_symbol_char == '\0')
	    entry = v[i].entry;
	  else
	    {
	      char *alc_entry;

	      /* lang_add_entry expects its argument to be permanently
		 allocated, so we don't free this string.  */
	      alc_entry = xmalloc (strlen (initial_symbol_char)
				   + strlen (v[i].entry)
				   + 1);
	      strcpy (alc_entry, initial_symbol_char);
	      strcat (alc_entry, v[i].entry);
	      entry = alc_entry;
	    }

	  lang_add_entry (entry, TRUE);

	  return;
	}
    }

  einfo (_("%P%F: invalid subsystem type %s\n"), optarg);
}


static void
set_pe_value (char *name)
{
  char *end;

  set_pe_name (name,  strtoul (optarg, &end, 0));

  if (end == optarg)
    einfo (_("%P%F: invalid hex number for PE parameter '%s'\n"), optarg);

  optarg = end;
}


static void
set_pe_stack_heap (char *resname, char *comname)
{
  set_pe_value (resname);

  if (*optarg == ',')
    {
      optarg++;
      set_pe_value (comname);
    }
  else if (*optarg)
    einfo (_("%P%F: strange hex info for PE parameter '%s'\n"), optarg);
}


static bfd_boolean
gld${EMULATION_NAME}_handle_option (int optc)
{
  switch (optc)
    {
    default:
      return FALSE;

    case OPTION_BASE_FILE:
      link_info.base_file = fopen (optarg, FOPEN_WB);
      if (link_info.base_file == NULL)
	{
	  /* xgettext:c-format */
	  fprintf (stderr, _("%s: Can't open base file %s\n"),
		   program_name, optarg);
	  xexit (1);
	}
      break;

      /* PE options.  */
    case OPTION_HEAP:
      set_pe_stack_heap ("__size_of_heap_reserve__", "__size_of_heap_commit__");
      break;
    case OPTION_STACK:
      set_pe_stack_heap ("__size_of_stack_reserve__", "__size_of_stack_commit__");
      break;
    case OPTION_SUBSYSTEM:
      set_pe_subsystem ();
      break;
    case OPTION_MAJOR_OS_VERSION:
      set_pe_value ("__major_os_version__");
      break;
    case OPTION_MINOR_OS_VERSION:
      set_pe_value ("__minor_os_version__");
      break;
    case OPTION_MAJOR_SUBSYSTEM_VERSION:
      set_pe_value ("__major_subsystem_version__");
      break;
    case OPTION_MINOR_SUBSYSTEM_VERSION:
      set_pe_value ("__minor_subsystem_version__");
      break;
    case OPTION_MAJOR_IMAGE_VERSION:
      set_pe_value ("__major_image_version__");
      break;
    case OPTION_MINOR_IMAGE_VERSION:
      set_pe_value ("__minor_image_version__");
      break;
    case OPTION_FILE_ALIGNMENT:
      set_pe_value ("__file_alignment__");
      break;
    case OPTION_SECTION_ALIGNMENT:
      set_pe_value ("__section_alignment__");
      break;
    case OPTION_DLL:
      set_pe_name ("__dll__", 1);
      break;
    case OPTION_IMAGE_BASE:
      set_pe_value ("__image_base__");
      break;
    case OPTION_SUPPORT_OLD_CODE:
      support_old_code = 1;
      break;
    case OPTION_THUMB_ENTRY:
      thumb_entry_symbol = optarg;
      break;
#ifdef DLL_SUPPORT
    case OPTION_OUT_DEF:
      pe_out_def_filename = xstrdup (optarg);
      break;
    case OPTION_EXPORT_ALL:
      pe_dll_export_everything = 1;
      break;
    case OPTION_EXCLUDE_SYMBOLS:
      pe_dll_add_excludes (optarg, 0);
      break;
    case OPTION_EXCLUDE_LIBS:
      pe_dll_add_excludes (optarg, 1);
      break;
    case OPTION_KILL_ATS:
      pe_dll_kill_ats = 1;
      break;
    case OPTION_STDCALL_ALIASES:
      pe_dll_stdcall_aliases = 1;
      break;
    case OPTION_ENABLE_STDCALL_FIXUP:
      pe_enable_stdcall_fixup = 1;
      break;
    case OPTION_DISABLE_STDCALL_FIXUP:
      pe_enable_stdcall_fixup = 0;
      break;
    case OPTION_IMPLIB_FILENAME:
      pe_implib_filename = xstrdup (optarg);
      break;
    case OPTION_WARN_DUPLICATE_EXPORTS:
      pe_dll_warn_dup_exports = 1;
      break;
    case OPTION_IMP_COMPAT:
      pe_dll_compat_implib = 1;
      break;
    case OPTION_ENABLE_AUTO_IMAGE_BASE:
      pe_enable_auto_image_base = 1;
      break;
    case OPTION_DISABLE_AUTO_IMAGE_BASE:
      pe_enable_auto_image_base = 0;
      break;
    case OPTION_DLL_SEARCH_PREFIX:
      pe_dll_search_prefix = xstrdup (optarg);
      break;
    case OPTION_NO_DEFAULT_EXCLUDES:
      pe_dll_do_default_excludes = 0;
      break;
    case OPTION_DLL_ENABLE_AUTO_IMPORT:
      link_info.pei386_auto_import = 1;
      break;
    case OPTION_DLL_DISABLE_AUTO_IMPORT:
      link_info.pei386_auto_import = 0;
      break;
    case OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC:
      link_info.pei386_runtime_pseudo_reloc = 1;
      break;
    case OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC:
      link_info.pei386_runtime_pseudo_reloc = 0;
      break;
    case OPTION_ENABLE_EXTRA_PE_DEBUG:
      pe_dll_extra_pe_debug = 1;
      break;
#endif
    }
  return TRUE;
}


#ifdef DLL_SUPPORT
static unsigned long
strhash (const char *str)
{
  const unsigned char *s;
  unsigned long hash;
  unsigned int c;
  unsigned int len;

  hash = 0;
  len = 0;
  s = (const unsigned char *) str;
  while ((c = *s++) != '\0')
    {
      hash += c + (c << 17);
      hash ^= hash >> 2;
      ++len;
    }
  hash += len + (len << 17);
  hash ^= hash >> 2;

  return hash;
}

/* Use the output file to create a image base for relocatable DLLs.  */

static unsigned long
compute_dll_image_base (const char *ofile)
{
  unsigned long hash = strhash (ofile);
  return 0x60000000 | ((hash << 16) & 0x0FFC0000);
}
#endif

/* Assign values to the special symbols before the linker script is
   read.  */

static void
gld_${EMULATION_NAME}_set_symbols (void)
{
  /* Run through and invent symbols for all the
     names and insert the defaults.  */
  int j;
  lang_statement_list_type *save;

  if (!init[IMAGEBASEOFF].inited)
    {
      if (link_info.relocatable)
	init[IMAGEBASEOFF].value = 0;
      else if (init[DLLOFF].value || link_info.shared)
#ifdef DLL_SUPPORT
	init[IMAGEBASEOFF].value = (pe_enable_auto_image_base) ?
	  compute_dll_image_base (output_filename) : NT_DLL_IMAGE_BASE;
#else
	init[IMAGEBASEOFF].value = NT_DLL_IMAGE_BASE;
#endif
      else
	init[IMAGEBASEOFF].value = NT_EXE_IMAGE_BASE;
    }

  /* Don't do any symbol assignments if this is a relocatable link.  */
  if (link_info.relocatable)
    return;

  /* Glue the assignments into the abs section.  */
  save = stat_ptr;

  stat_ptr = &(abs_output_section->children);

  for (j = 0; init[j].ptr; j++)
    {
      long val = init[j].value;
      lang_assignment_statement_type *rv;
      rv = lang_add_assignment (exp_assop ('=', init[j].symbol,
					   exp_intop (val)));
      if (init[j].size == sizeof (short))
	*(short *) init[j].ptr = val;
      else if (init[j].size == sizeof (int))
	*(int *) init[j].ptr = val;
      else if (init[j].size == sizeof (long))
	*(long *) init[j].ptr = val;
      /* This might be a long long or other special type.  */
      else if (init[j].size == sizeof (bfd_vma))
	*(bfd_vma *) init[j].ptr = val;
      else	abort ();
      if (j == IMAGEBASEOFF)
	image_base_statement = rv;
    }
  /* Restore the pointer.  */
  stat_ptr = save;

  if (pe.FileAlignment >
      pe.SectionAlignment)
    {
      einfo (_("%P: warning, file alignment > section alignment.\n"));
    }
}

/* This is called after the linker script and the command line options
   have been read.  */

static void
gld_${EMULATION_NAME}_after_parse (void)
{
  /* The Windows libraries are designed for the linker to treat the
     entry point as an undefined symbol.  Otherwise, the .obj that
     defines mainCRTStartup is brought in because it is the first
     encountered in libc.lib and it has other symbols in it which will
     be pulled in by the link process.  To avoid this, we act as
     though the user specified -u with the entry point symbol.

     This function is called after the linker script and command line
     options have been read, so at this point we know the right entry
     point.  This function is called before the input files are
     opened, so registering the symbol as undefined will make a
     difference.  */

  if (! link_info.relocatable && entry_symbol.name != NULL)
    ldlang_add_undef (entry_symbol.name);
}

/* pe-dll.c directly accesses pe_data_import_dll,
   so it must be defined outside of #ifdef DLL_SUPPORT.
   Note - this variable is deliberately not initialised.
   This allows it to be treated as a common varaible, and only
   exist in one incarnation in a multiple target enabled linker.  */
char * pe_data_import_dll;

#ifdef DLL_SUPPORT
static struct bfd_link_hash_entry *pe_undef_found_sym;

static bfd_boolean
pe_undef_cdecl_match (struct bfd_link_hash_entry *h, void *inf)
{
  int sl;
  char *string = inf;

  sl = strlen (string);
  if (h->type == bfd_link_hash_defined
      && strncmp (h->root.string, string, sl) == 0
      && h->root.string[sl] == '@@')
    {
      pe_undef_found_sym = h;
      return FALSE;
    }
  return TRUE;
}

static void
pe_fixup_stdcalls (void)
{
  static int gave_warning_message = 0;
  struct bfd_link_hash_entry *undef, *sym;

  if (pe_dll_extra_pe_debug)
    printf ("%s\n", __FUNCTION__);

  for (undef = link_info.hash->undefs; undef; undef=undef->und_next)
    if (undef->type == bfd_link_hash_undefined)
      {
	char* at = strchr (undef->root.string, '@@');
	int lead_at = (*undef->root.string == '@@');
	/* For now, don't try to fixup fastcall symbols.  */

	if (at && !lead_at)
	  {
	    /* The symbol is a stdcall symbol, so let's look for a
	       cdecl symbol with the same name and resolve to that.  */
	    char *cname = xstrdup (undef->root.string /* + lead_at */);
	    at = strchr (cname, '@@');
	    *at = 0;
	    sym = bfd_link_hash_lookup (link_info.hash, cname, 0, 0, 1);

	    if (sym && sym->type == bfd_link_hash_defined)
	      {
		undef->type = bfd_link_hash_defined;
		undef->u.def.value = sym->u.def.value;
		undef->u.def.section = sym->u.def.section;

		if (pe_enable_stdcall_fixup == -1)
		  {
		    einfo (_("Warning: resolving %s by linking to %s\n"),
			   undef->root.string, cname);
		    if (! gave_warning_message)
		      {
			gave_warning_message = 1;
			einfo (_("Use --enable-stdcall-fixup to disable these warnings\n"));
			einfo (_("Use --disable-stdcall-fixup to disable these fixups\n"));
		      }
		  }
	      }
	  }
	else
	  {
	    /* The symbol is a cdecl symbol, so we look for stdcall
	       symbols - which means scanning the whole symbol table.  */
	    pe_undef_found_sym = 0;
	    bfd_link_hash_traverse (link_info.hash, pe_undef_cdecl_match,
				    (char *) undef->root.string);
	    sym = pe_undef_found_sym;
	    if (sym)
	      {
		undef->type = bfd_link_hash_defined;
		undef->u.def.value = sym->u.def.value;
		undef->u.def.section = sym->u.def.section;

		if (pe_enable_stdcall_fixup == -1)
		  {
		    einfo (_("Warning: resolving %s by linking to %s\n"),
			   undef->root.string, sym->root.string);
		    if (! gave_warning_message)
		      {
			gave_warning_message = 1;
			einfo (_("Use --enable-stdcall-fixup to disable these warnings\n"));
			einfo (_("Use --disable-stdcall-fixup to disable these fixups\n"));
		      }
		  }
	      }
	  }
      }
}

static int
make_import_fixup (arelent *rel, asection *s)
{
  struct bfd_symbol *sym = *rel->sym_ptr_ptr;
  int addend = 0;

  if (pe_dll_extra_pe_debug)
    printf ("arelent: %s@@%#lx: add=%li\n", sym->name,
	    (long) rel->address, (long) rel->addend);

  if (! bfd_get_section_contents (s->owner, s, &addend, rel->address, sizeof (addend)))
    einfo (_("%C: Cannot get section contents - auto-import exception\n"),
	   s->owner, s, rel->address);

  pe_create_import_fixup (rel, s, addend);

  return 1;
}

static void
pe_find_data_imports (void)
{
  struct bfd_link_hash_entry *undef, *sym;

  if (link_info.pei386_auto_import == 0)
    return;

  for (undef = link_info.hash->undefs; undef; undef=undef->und_next)
    {
      if (undef->type == bfd_link_hash_undefined)
        {
          /* C++ symbols are *long*.  */
          char buf[4096];

	  if (pe_dll_extra_pe_debug)
	    printf ("%s:%s\n", __FUNCTION__, undef->root.string);

          sprintf (buf, "__imp_%s", undef->root.string);

          sym = bfd_link_hash_lookup (link_info.hash, buf, 0, 0, 1);

          if (sym && sym->type == bfd_link_hash_defined)
            {
	      bfd *b = sym->u.def.section->owner;
	      asymbol **symbols;
	      int nsyms, symsize, i;

	      if (link_info.pei386_auto_import == -1)
		info_msg (_("Info: resolving %s by linking to %s (auto-import)\n"),
			  undef->root.string, buf);

	      symsize = bfd_get_symtab_upper_bound (b);
	      symbols = (asymbol **) xmalloc (symsize);
	      nsyms = bfd_canonicalize_symtab (b, symbols);

	      for (i = 0; i < nsyms; i++)
		{
		  if (memcmp (symbols[i]->name, "__head_",
			      sizeof ("__head_") - 1))
		    continue;

		  if (pe_dll_extra_pe_debug)
		    printf ("->%s\n", symbols[i]->name);

		  pe_data_import_dll = (char*) (symbols[i]->name +
						sizeof ("__head_") - 1);
		  break;
		}

	      pe_walk_relocs_of_symbol (&link_info, undef->root.string,
					make_import_fixup);

	      /* Let's differentiate it somehow from defined.  */
	      undef->type = bfd_link_hash_defweak;
	      /* We replace original name with __imp_ prefixed, this
		 1) may trash memory 2) leads to duplicate symbol generation.
		 Still, IMHO it's better than having name poluted.  */
	      undef->root.string = sym->root.string;
	      undef->u.def.value = sym->u.def.value;
	      undef->u.def.section = sym->u.def.section;
            }
        }
    }
}

static bfd_boolean
pr_sym (struct bfd_hash_entry *h, void *inf ATTRIBUTE_UNUSED)
{
  if (pe_dll_extra_pe_debug)
    printf ("+%s\n", h->string);

  return TRUE;
}
#endif /* DLL_SUPPORT */


static void
gld_${EMULATION_NAME}_after_open (void)
{
#ifdef DLL_SUPPORT
  if (pe_dll_extra_pe_debug)
    {
      bfd *a;
      struct bfd_link_hash_entry *sym;

      printf ("%s()\n", __FUNCTION__);

      for (sym = link_info.hash->undefs; sym; sym=sym->und_next)
        printf ("-%s\n", sym->root.string);
      bfd_hash_traverse (&link_info.hash->table, pr_sym, NULL);

      for (a = link_info.input_bfds; a; a = a->link_next)
	printf ("*%s\n",a->filename);
    }
#endif

  /* Pass the wacky PE command line options into the output bfd.
     FIXME: This should be done via a function, rather than by
     including an internal BFD header.  */

  if (coff_data (output_bfd) == NULL || coff_data (output_bfd)->pe == 0)
    einfo (_("%F%P: PE operations on non PE file.\n"));

  pe_data (output_bfd)->pe_opthdr = pe;
  pe_data (output_bfd)->dll = init[DLLOFF].value;

#ifdef DLL_SUPPORT
  if (pe_enable_stdcall_fixup) /* -1=warn or 1=disable */
    pe_fixup_stdcalls ();

  pe_process_import_defs (output_bfd, & link_info);

  pe_find_data_imports ();

#if ! (defined (TARGET_IS_i386pe) || defined (TARGET_IS_armpe))
  if (link_info.shared)
#else
  if (!link_info.relocatable)
#endif
    pe_dll_build_sections (output_bfd, &link_info);

#ifndef TARGET_IS_i386pe
#ifndef TARGET_IS_armpe
  else
    pe_exe_build_sections (output_bfd, &link_info);
#endif
#endif
#endif

#if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe)
  if (strstr (bfd_get_target (output_bfd), "arm") == NULL)
    {
      /* The arm backend needs special fields in the output hash structure.
	 These will only be created if the output format is an arm format,
	 hence we do not support linking and changing output formats at the
	 same time.  Use a link followed by objcopy to change output formats.  */
      einfo ("%F%X%P: error: cannot change output format whilst linking ARM binaries\n");
      return;
    }
  {
    /* Find a BFD that can hold the interworking stubs.  */
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	if (bfd_arm_pe_get_bfd_for_interworking (is->the_bfd, & link_info))
	  break;
      }
  }
#endif

  {
    /* This next chunk of code tries to detect the case where you have
       two import libraries for the same DLL (specifically,
       symbolically linking libm.a and libc.a in cygwin to
       libcygwin.a).  In those cases, it's possible for function
       thunks from the second implib to be used but without the
       head/tail objects, causing an improper import table.  We detect
       those cases and rename the "other" import libraries to match
       the one the head/tail come from, so that the linker will sort
       things nicely and produce a valid import table.  */

    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	if (is->the_bfd->my_archive)
	  {
	    int idata2 = 0, reloc_count=0, is_imp = 0;
	    asection *sec;

	    /* See if this is an import library thunk.  */
	    for (sec = is->the_bfd->sections; sec; sec = sec->next)
	      {
		if (strcmp (sec->name, ".idata\$2") == 0)
		  idata2 = 1;
		if (strncmp (sec->name, ".idata\$", 7) == 0)
		  is_imp = 1;
		reloc_count += sec->reloc_count;
	      }

	    if (is_imp && !idata2 && reloc_count)
	      {
		/* It is, look for the reference to head and see if it's
		   from our own library.  */
		for (sec = is->the_bfd->sections; sec; sec = sec->next)
		  {
		    int i;
		    long symsize;
		    long relsize;
		    asymbol **symbols;
		    arelent **relocs;
		    int nrelocs;

		    symsize = bfd_get_symtab_upper_bound (is->the_bfd);
		    if (symsize < 1)
		      break;
		    relsize = bfd_get_reloc_upper_bound (is->the_bfd, sec);
		    if (relsize < 1)
		      break;

		    symbols = (asymbol **) xmalloc (symsize);
		    symsize = bfd_canonicalize_symtab (is->the_bfd, symbols);
		    if (symsize < 0)
		      {
			einfo ("%X%P: unable to process symbols: %E");
			return;
		      }

		    relocs = (arelent **) xmalloc ((size_t) relsize);
		    nrelocs = bfd_canonicalize_reloc (is->the_bfd, sec,
							  relocs, symbols);
		    if (nrelocs < 0)
		      {
			free (relocs);
			einfo ("%X%P: unable to process relocs: %E");
			return;
		      }

		    for (i = 0; i < nrelocs; i++)
		      {
			struct bfd_symbol *s;
			struct bfd_link_hash_entry * blhe;
			bfd *other_bfd;
			char *n;

			s = (relocs[i]->sym_ptr_ptr)[0];

			if (s->flags & BSF_LOCAL)
			  continue;

			/* Thunk section with reloc to another bfd.  */
			blhe = bfd_link_hash_lookup (link_info.hash,
						     s->name,
						     FALSE, FALSE, TRUE);

			if (blhe == NULL
			    || blhe->type != bfd_link_hash_defined)
			  continue;

			other_bfd = blhe->u.def.section->owner;

			if (strcmp (is->the_bfd->my_archive->filename,
				    other_bfd->my_archive->filename) == 0)
			  continue;

			/* Rename this implib to match the other.  */
			n = (char *) xmalloc (strlen (other_bfd->my_archive->filename) + 1);

			strcpy (n, other_bfd->my_archive->filename);

			is->the_bfd->my_archive->filename = n;
		      }

		    free (relocs);
		    /* Note - we do not free the symbols,
		       they are now cached in the BFD.  */
		  }
	      }
	  }
      }
  }

  {
    int is_ms_arch = 0;
    bfd *cur_arch = 0;
    lang_input_statement_type *is2;
    lang_input_statement_type *is3;

    /* Careful - this is a shell script.  Watch those dollar signs! */
    /* Microsoft import libraries have every member named the same,
       and not in the right order for us to link them correctly.  We
       must detect these and rename the members so that they'll link
       correctly.  There are three types of objects: the head, the
       thunks, and the sentinel(s).  The head is easy; it's the one
       with idata2.  We assume that the sentinels won't have relocs,
       and the thunks will.  It's easier than checking the symbol
       table for external references.  */
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	if (is->the_bfd->my_archive)
	  {
	    char *pnt;
	    bfd *arch = is->the_bfd->my_archive;

	    if (cur_arch != arch)
	      {
		cur_arch = arch;
		is_ms_arch = 1;

		for (is3 = is;
		     is3 && is3->the_bfd->my_archive == arch;
		     is3 = (lang_input_statement_type *) is3->next)
		  {
                    /* A MS dynamic import library can also contain static
		       members, so look for the first element with a .dll
		       extension, and use that for the remainder of the
		       comparisons.  */
		    pnt = strrchr (is3->the_bfd->filename, '.');
		    if (pnt != NULL && strcmp (pnt, ".dll") == 0)
		      break;
		  }

		if (is3 == NULL)
		  is_ms_arch = 0;
		else
		  {
		    /* OK, found one.  Now look to see if the remaining
		       (dynamic import) members use the same name.  */
		    for (is2 = is;
			 is2 && is2->the_bfd->my_archive == arch;
			 is2 = (lang_input_statement_type *) is2->next)
		      {
			/* Skip static members, ie anything with a .obj
			   extension.  */
			pnt = strrchr (is2->the_bfd->filename, '.');
			if (pnt != NULL && strcmp (pnt, ".obj") == 0)
			  continue;

			if (strcmp (is3->the_bfd->filename,
				    is2->the_bfd->filename))
			  {
			    is_ms_arch = 0;
			    break;
			  }
		      }
		  }
	      }

	    /* This fragment might have come from an .obj file in a Microsoft
	       import, and not an actual import record. If this is the case,
	       then leave the filename alone.  */
	    pnt = strrchr (is->the_bfd->filename, '.');

	    if (is_ms_arch && (strcmp (pnt, ".dll") == 0))
	      {
		int idata2 = 0, reloc_count=0;
		asection *sec;
		char *new_name, seq;

		for (sec = is->the_bfd->sections; sec; sec = sec->next)
		  {
		    if (strcmp (sec->name, ".idata\$2") == 0)
		      idata2 = 1;
		    reloc_count += sec->reloc_count;
		  }

		if (idata2) /* .idata2 is the TOC */
		  seq = 'a';
		else if (reloc_count > 0) /* thunks */
		  seq = 'b';
		else /* sentinel */
		  seq = 'c';

		new_name = xmalloc (strlen (is->the_bfd->filename) + 3);
		sprintf (new_name, "%s.%c", is->the_bfd->filename, seq);
		is->the_bfd->filename = new_name;

		new_name = xmalloc (strlen (is->filename) + 3);
		sprintf (new_name, "%s.%c", is->filename, seq);
		is->filename = new_name;
	      }
	  }
      }
  }
}

static void
gld_${EMULATION_NAME}_before_allocation (void)
{
#ifdef TARGET_IS_ppcpe
  /* Here we rummage through the found bfds to collect toc information.  */
  {
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	if (!ppc_process_before_allocation (is->the_bfd, &link_info))
	  {
	    /* xgettext:c-format */
	    einfo (_("Errors encountered processing file %s\n"), is->filename);
	  }
      }
  }

  /* We have seen it all. Allocate it, and carry on.  */
  ppc_allocate_toc_section (&link_info);
#endif /* TARGET_IS_ppcpe */

#if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe)
  /* FIXME: we should be able to set the size of the interworking stub
     section.

     Here we rummage through the found bfds to collect glue
     information.  FIXME: should this be based on a command line
     option?  krk@@cygnus.com.  */
  {
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	if (! bfd_arm_pe_process_before_allocation
	    (is->the_bfd, & link_info, support_old_code))
	  {
	    /* xgettext:c-format */
	    einfo (_("Errors encountered processing file %s for interworking"),
		   is->filename);
	  }
      }
  }

  /* We have seen it all. Allocate it, and carry on.  */
  bfd_arm_pe_allocate_interworking_sections (& link_info);
#endif /* TARGET_IS_armpe */
}

#ifdef DLL_SUPPORT
/* This is called when an input file isn't recognized as a BFD.  We
   check here for .DEF files and pull them in automatically.  */

static int
saw_option (char *option)
{
  int i;

  for (i = 0; init[i].ptr; i++)
    if (strcmp (init[i].symbol, option) == 0)
      return init[i].inited;
  return 0;
}
#endif /* DLL_SUPPORT */

static bfd_boolean
gld_${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry ATTRIBUTE_UNUSED)
{
#ifdef DLL_SUPPORT
  const char *ext = entry->filename + strlen (entry->filename) - 4;

  if (strcmp (ext, ".def") == 0 || strcmp (ext, ".DEF") == 0)
    {
      if (pe_def_file == 0)
	pe_def_file = def_file_empty ();

      def_file_parse (entry->filename, pe_def_file);

      if (pe_def_file)
	{
	  int i, buflen=0, len;
	  char *buf;

	  for (i = 0; i < pe_def_file->num_exports; i++)
	    {
	      len = strlen (pe_def_file->exports[i].internal_name);
	      if (buflen < len + 2)
		buflen = len + 2;
	    }

	  buf = (char *) xmalloc (buflen);

	  for (i = 0; i < pe_def_file->num_exports; i++)
	    {
	      struct bfd_link_hash_entry *h;

	      sprintf (buf, "_%s", pe_def_file->exports[i].internal_name);

	      h = bfd_link_hash_lookup (link_info.hash, buf, TRUE, TRUE, TRUE);
	      if (h == (struct bfd_link_hash_entry *) NULL)
		einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
	      if (h->type == bfd_link_hash_new)
		{
		  h->type = bfd_link_hash_undefined;
		  h->u.undef.abfd = NULL;
		  bfd_link_add_undef (link_info.hash, h);
		}
	    }
	  free (buf);

	  /* def_file_print (stdout, pe_def_file); */
	  if (pe_def_file->is_dll == 1)
	    link_info.shared = 1;

	  if (pe_def_file->base_address != (bfd_vma)(-1))
	    {
	      pe.ImageBase =
		pe_data (output_bfd)->pe_opthdr.ImageBase =
		init[IMAGEBASEOFF].value = pe_def_file->base_address;
	      init[IMAGEBASEOFF].inited = 1;
	      if (image_base_statement)
		image_base_statement->exp =
		  exp_assop ('=', "__image_base__", exp_intop (pe.ImageBase));
	    }

#if 0
	  /* Not sure if these *should* be set.  */
	  if (pe_def_file->version_major != -1)
	    {
	      pe.MajorImageVersion = pe_def_file->version_major;
	      pe.MinorImageVersion = pe_def_file->version_minor;
	    }
#endif
	  if (pe_def_file->stack_reserve != -1
	      && ! saw_option ("__size_of_stack_reserve__"))
	    {
	      pe.SizeOfStackReserve = pe_def_file->stack_reserve;
	      if (pe_def_file->stack_commit != -1)
		pe.SizeOfStackCommit = pe_def_file->stack_commit;
	    }
	  if (pe_def_file->heap_reserve != -1
	      && ! saw_option ("__size_of_heap_reserve__"))
	    {
	      pe.SizeOfHeapReserve = pe_def_file->heap_reserve;
	      if (pe_def_file->heap_commit != -1)
		pe.SizeOfHeapCommit = pe_def_file->heap_commit;
	    }
	  return TRUE;
	}
    }
#endif
  return FALSE;
}

static bfd_boolean
gld_${EMULATION_NAME}_recognized_file (lang_input_statement_type *entry ATTRIBUTE_UNUSED)
{
#ifdef DLL_SUPPORT
#ifdef TARGET_IS_i386pe
  pe_dll_id_target ("pei-i386");
#endif
#ifdef TARGET_IS_shpe
  pe_dll_id_target ("pei-shl");
#endif
#ifdef TARGET_IS_mipspe
  pe_dll_id_target ("pei-mips");
#endif
#ifdef TARGET_IS_armpe
  pe_dll_id_target ("pei-arm-little");
#endif
  if (bfd_get_format (entry->the_bfd) == bfd_object)
    {
      char fbuf[LD_PATHMAX + 1];
      const char *ext;

      if (REALPATH (entry->filename, fbuf) == NULL)
	strncpy (fbuf, entry->filename, sizeof (fbuf));

      ext = fbuf + strlen (fbuf) - 4;

      if (strcmp (ext, ".dll") == 0 || strcmp (ext, ".DLL") == 0)
	return pe_implied_import_dll (fbuf);
    }
#endif
  return FALSE;
}

static void
gld_${EMULATION_NAME}_finish (void)
{
#if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe)
  struct bfd_link_hash_entry * h;

  if (thumb_entry_symbol != NULL)
    {
      h = bfd_link_hash_lookup (link_info.hash, thumb_entry_symbol,
				FALSE, FALSE, TRUE);

      if (h != (struct bfd_link_hash_entry *) NULL
	  && (h->type == bfd_link_hash_defined
	      || h->type == bfd_link_hash_defweak)
	  && h->u.def.section->output_section != NULL)
	{
	  static char buffer[32];
	  bfd_vma val;

	  /* Special procesing is required for a Thumb entry symbol.  The
	     bottom bit of its address must be set.  */
	  val = (h->u.def.value
		 + bfd_get_section_vma (output_bfd,
					h->u.def.section->output_section)
		 + h->u.def.section->output_offset);

	  val |= 1;

	  /* Now convert this value into a string and store it in entry_symbol
	     where the lang_finish() function will pick it up.  */
	  buffer[0] = '0';
	  buffer[1] = 'x';

	  sprintf_vma (buffer + 2, val);

	  if (entry_symbol.name != NULL && entry_from_cmdline)
	    einfo (_("%P: warning: '--thumb-entry %s' is overriding '-e %s'\n"),
		   thumb_entry_symbol, entry_symbol.name);
	  entry_symbol.name = buffer;
	}
      else
	einfo (_("%P: warning: connot find thumb start symbol %s\n"), thumb_entry_symbol);
    }
#endif /* defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe) */

#ifdef DLL_SUPPORT
  if (link_info.shared
#if !defined(TARGET_IS_shpe) && !defined(TARGET_IS_mipspe)
    || (!link_info.relocatable && pe_def_file->num_exports != 0)
#endif
    )
    {
      pe_dll_fill_sections (output_bfd, &link_info);
      if (pe_implib_filename)
	pe_dll_generate_implib (pe_def_file, pe_implib_filename);
    }
#if defined(TARGET_IS_shpe) || defined(TARGET_IS_mipspe)
  /* ARM doesn't need relocs.  */
  else
    {
      pe_exe_fill_sections (output_bfd, &link_info);
    }
#endif

  if (pe_out_def_filename)
    pe_dll_generate_def_file (pe_out_def_filename);
#endif /* DLL_SUPPORT */

  /* I don't know where .idata gets set as code, but it shouldn't be.  */
  {
    asection *asec = bfd_get_section_by_name (output_bfd, ".idata");

    if (asec)
      {
        asec->flags &= ~SEC_CODE;
        asec->flags |= SEC_DATA;
      }
  }
}


/* Find the last output section before given output statement.
   Used by place_orphan.  */

static asection *
output_prev_sec_find (lang_output_section_statement_type *os)
{
  asection *s = (asection *) NULL;
  lang_statement_union_type *u;
  lang_output_section_statement_type *lookup;

  for (u = lang_output_section_statement.head;
       u != (lang_statement_union_type *) NULL;
       u = lookup->next)
    {
      lookup = &u->output_section_statement;
      if (lookup == os)
	return s;

      if (lookup->bfd_section != NULL && lookup->bfd_section->owner != NULL)
	s = lookup->bfd_section;
    }

  return NULL;
}

/* Place an orphan section.

   We use this to put sections in a reasonable place in the file, and
   to ensure that they are aligned as required.

   We handle grouped sections here as well.  A section named .foo$nn
   goes into the output section .foo.  All grouped sections are sorted
   by name.

   Grouped sections for the default sections are handled by the
   default linker script using wildcards, and are sorted by
   sort_sections.  */

struct orphan_save
{
  lang_output_section_statement_type *os;
  asection **section;
  lang_statement_union_type **stmt;
};

static bfd_boolean
gld_${EMULATION_NAME}_place_orphan (lang_input_statement_type *file, asection *s)
{
  const char *secname;
  char *hold_section_name;
  char *dollar = NULL;
  const char *ps = NULL;
  lang_output_section_statement_type *os;
  lang_statement_list_type add_child;

  secname = bfd_get_section_name (s->owner, s);

  /* Look through the script to see where to place this section.  */
  hold_section_name = xstrdup (secname);
  if (!link_info.relocatable)
    {
      dollar = strchr (hold_section_name, '$');
      if (dollar != NULL)
	*dollar = '\0';
    }

  os = lang_output_section_find (hold_section_name);

  lang_list_init (&add_child);

  if (os != NULL
      && (os->bfd_section == NULL
	  || ((s->flags ^ os->bfd_section->flags)
	      & (SEC_LOAD | SEC_ALLOC)) == 0))
    {
      /* We already have an output section statement with this
	 name, and its bfd section, if any, has compatible flags.  */
      lang_add_section (&add_child, s, os, file);
    }
  else
    {
      struct orphan_save *place;
      static struct orphan_save hold_text;
      static struct orphan_save hold_rdata;
      static struct orphan_save hold_data;
      static struct orphan_save hold_bss;
      char *outsecname;
      lang_statement_list_type *old;
      lang_statement_list_type add;
      etree_type *address;

      /* Try to put the new output section in a reasonable place based
	 on the section name and section flags.  */
#define HAVE_SECTION(hold, name) \
(hold.os != NULL || (hold.os = lang_output_section_find (name)) != NULL)

      place = NULL;
      if ((s->flags & SEC_ALLOC) == 0)
	;
      else if ((s->flags & SEC_HAS_CONTENTS) == 0
	       && HAVE_SECTION (hold_bss, ".bss"))
	place = &hold_bss;
      else if ((s->flags & SEC_READONLY) == 0
	       && HAVE_SECTION (hold_data, ".data"))
	place = &hold_data;
      else if ((s->flags & SEC_CODE) == 0
	       && (s->flags & SEC_READONLY) != 0
	       && HAVE_SECTION (hold_rdata, ".rdata"))
	place = &hold_rdata;
      else if ((s->flags & SEC_READONLY) != 0
	       && HAVE_SECTION (hold_text, ".text"))
	place = &hold_text;

#undef HAVE_SECTION

      /* Choose a unique name for the section.  This will be needed if
	 the same section name appears in the input file with
	 different loadable or allocatable characteristics.  */
      outsecname = xstrdup (hold_section_name);
      if (bfd_get_section_by_name (output_bfd, outsecname) != NULL)
	{
	  unsigned int len;
	  char *newname;
	  unsigned int i;

	  len = strlen (outsecname);
	  newname = xmalloc (len + 5);
	  strcpy (newname, outsecname);
	  i = 0;
	  do
	    {
	      sprintf (newname + len, "%d", i);
	      ++i;
	    }
	  while (bfd_get_section_by_name (output_bfd, newname) != NULL);

	  free (outsecname);
	  outsecname = newname;
	}

      /* Start building a list of statements for this section.  */
      old = stat_ptr;
      stat_ptr = &add;
      lang_list_init (stat_ptr);

      if (config.build_constructors)
	{
	  /* If the name of the section is representable in C, then create
	     symbols to mark the start and the end of the section.  */
	  for (ps = outsecname; *ps != '\0'; ps++)
	    if (! ISALNUM ((unsigned char) *ps) && *ps != '_')
	      break;
	  if (*ps == '\0')
	    {
	      char *symname;
	      etree_type *e_align;

	      symname = (char *) xmalloc (ps - outsecname + sizeof "___start_");
	      sprintf (symname, "___start_%s", outsecname);
	      e_align = exp_unop (ALIGN_K,
				  exp_intop ((bfd_vma) 1 << s->alignment_power));
	      lang_add_assignment (exp_assop ('=', symname, e_align));
	    }
	}

      if (link_info.relocatable || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0)
	address = exp_intop ((bfd_vma) 0);
      else
	{
	  /* All sections in an executable must be aligned to a page
	     boundary.  */
	  address = exp_unop (ALIGN_K,
			      exp_nameop (NAME, "__section_alignment__"));
	}

      os = lang_enter_output_section_statement (outsecname, address, 0,
						(etree_type *) NULL,
						(etree_type *) NULL,
						(etree_type *) NULL);

      lang_add_section (&add_child, s, os, file);

      lang_leave_output_section_statement
	((bfd_vma) 0, "*default*",
	 (struct lang_output_section_phdr_list *) NULL, NULL);

      if (config.build_constructors && *ps == '\0')
        {
	  char *symname;

	  /* lang_leave_ouput_section_statement resets stat_ptr.
	     Put stat_ptr back where we want it.  */
	  if (place != NULL)
	    stat_ptr = &add;

	  symname = (char *) xmalloc (ps - outsecname + sizeof "___stop_");
	  sprintf (symname, "___stop_%s", outsecname);
	  lang_add_assignment (exp_assop ('=', symname,
					  exp_nameop (NAME, ".")));
	}

      stat_ptr = old;

      if (place != NULL && os->bfd_section != NULL)
	{
	  asection *snew, **pps;

	  snew = os->bfd_section;

	  /* Shuffle the bfd section list to make the output file look
	     neater.  This is really only cosmetic.  */
	  if (place->section == NULL)
	    {
	      asection *bfd_section = place->os->bfd_section;

	      /* If the output statement hasn't been used to place
		 any input sections (and thus doesn't have an output
		 bfd_section), look for the closest prior output statement
		 having an output section.  */
	      if (bfd_section == NULL)
		bfd_section = output_prev_sec_find (place->os);

	      if (bfd_section != NULL && bfd_section != snew)
		place->section = &bfd_section->next;
	    }

	  if (place->section != NULL)
	    {
	      /* Unlink the section.  */
	      for (pps = &output_bfd->sections;
		   *pps != snew;
		   pps = &(*pps)->next)
		;
	      bfd_section_list_remove (output_bfd, pps);

	      /* Now tack it on to the "place->os" section list.  */
	      bfd_section_list_insert (output_bfd, place->section, snew);
	    }

	  /* Save the end of this list.  Further ophans of this type will
	     follow the one we've just added.  */
	  place->section = &snew->next;

	  /* The following is non-cosmetic.  We try to put the output
	     statements in some sort of reasonable order here, because
	     they determine the final load addresses of the orphan
	     sections.  In addition, placing output statements in the
	     wrong order may require extra segments.  For instance,
	     given a typical situation of all read-only sections placed
	     in one segment and following that a segment containing all
	     the read-write sections, we wouldn't want to place an orphan
	     read/write section before or amongst the read-only ones.  */
	  if (add.head != NULL)
	    {
	      if (place->stmt == NULL)
		{
		  /* Put the new statement list right at the head.  */
		  *add.tail = place->os->header.next;
		  place->os->header.next = add.head;
		}
	      else
		{
		  /* Put it after the last orphan statement we added.  */
		  *add.tail = *place->stmt;
		  *place->stmt = add.head;
		}

	      /* Fix the global list pointer if we happened to tack our
		 new list at the tail.  */
	      if (*old->tail == add.head)
		old->tail = add.tail;

	      /* Save the end of this list.  */
	      place->stmt = add.tail;
	    }
	}
    }

  {
    lang_statement_union_type **pl = &os->children.head;

    if (dollar != NULL)
      {
	bfd_boolean found_dollar;

	/* The section name has a '$'.  Sort it with the other '$'
	   sections.  */
	found_dollar = FALSE;
	for ( ; *pl != NULL; pl = &(*pl)->header.next)
	  {
	    lang_input_section_type *ls;
	    const char *lname;

	    if ((*pl)->header.type != lang_input_section_enum)
	      continue;

	    ls = &(*pl)->input_section;

	    lname = bfd_get_section_name (ls->ifile->the_bfd, ls->section);
	    if (strchr (lname, '$') == NULL)
	      {
		if (found_dollar)
		  break;
	      }
	    else
	      {
		found_dollar = TRUE;
		if (strcmp (secname, lname) < 0)
		  break;
	      }
	  }
      }

    if (add_child.head != NULL)
      {
	add_child.head->header.next = *pl;
	*pl = add_child.head;
      }
  }

  free (hold_section_name);

  return TRUE;
}

static bfd_boolean
gld_${EMULATION_NAME}_open_dynamic_archive
  (const char *arch ATTRIBUTE_UNUSED, search_dirs_type *search,
   lang_input_statement_type *entry)
{
  const char * filename;
  char * string;

  if (! entry->is_archive)
    return FALSE;

  filename = entry->filename;

  string = (char *) xmalloc (strlen (search->name)
                             + strlen (filename)
                             + sizeof "/lib.a.dll"
#ifdef DLL_SUPPORT
                             + (pe_dll_search_prefix ? strlen (pe_dll_search_prefix) : 0)
#endif
                             + 1);

  /* Try "libfoo.dll.a" first (preferred explicit import library for dll's.  */
  sprintf (string, "%s/lib%s.dll.a", search->name, filename);

  if (! ldfile_try_open_bfd (string, entry))
    {
      /* Try "foo.dll.a" next (alternate explicit import library for dll's.  */
      sprintf (string, "%s/%s.dll.a", search->name, filename);
      if (! ldfile_try_open_bfd (string, entry))
        {
	  /* Try libfoo.a next. Normally, this would be interpreted as a static
	     library, but it *could* be an import library. For backwards compatibility,
	     libfoo.a needs to ==precede== libfoo.dll and foo.dll in the search,
	     or sometimes errors occur when building legacy packages.

	     Putting libfoo.a here means that in a failure case (i.e. the library
	     -lfoo is not found) we will search for libfoo.a twice before
	     giving up -- once here, and once when searching for a "static" lib.
	     for a "static" lib.  */
          /* Try "libfoo.a" (import lib, or static lib, but must
             take precedence over dll's).  */
          sprintf (string, "%s/lib%s.a", search->name, filename);
          if (! ldfile_try_open_bfd (string, entry))
            {
#ifdef DLL_SUPPORT
              if (pe_dll_search_prefix)
                {
                  /* Try "<prefix>foo.dll" (preferred dll name, if specified).  */
                  sprintf (string, "%s/%s%s.dll", search->name, pe_dll_search_prefix, filename);
                  if (! ldfile_try_open_bfd (string, entry))
                    {
                      /* Try "libfoo.dll" (default preferred dll name).  */
                      sprintf (string, "%s/lib%s.dll", search->name, filename);
                      if (! ldfile_try_open_bfd (string, entry))
                        {
                          /* Finally, try "foo.dll" (alternate dll name).  */
                          sprintf (string, "%s/%s.dll", search->name, filename);
                          if (! ldfile_try_open_bfd (string, entry))
                            {
                              free (string);
                              return FALSE;
                            }
                        }
                    }
                }
              else /* pe_dll_search_prefix not specified.  */
#endif
                {
                  /* Try "libfoo.dll" (preferred dll name).  */
                  sprintf (string, "%s/lib%s.dll", search->name, filename);
                  if (! ldfile_try_open_bfd (string, entry))
                    {
                      /* Finally, try "foo.dll" (alternate dll name).  */
                      sprintf (string, "%s/%s.dll", search->name, filename);
                      if (! ldfile_try_open_bfd (string, entry))
                        {
                          free (string);
                          return FALSE;
                        }
                    }
                }
            }
        }
    }

  entry->filename = string;

  return TRUE;
}

static int
gld_${EMULATION_NAME}_find_potential_libraries
  (char *name, lang_input_statement_type *entry)
{
  return ldfile_open_file_search (name, entry, "", ".lib");
}

static char *
gld_${EMULATION_NAME}_get_script (int *isfile)
EOF
# Scripts compiled in.
# sed commands to quote an ld script as a C string.
sc="-f stringify.sed"

cat >>e${EMULATION_NAME}.c <<EOF
{
  *isfile = 0;

  if (link_info.relocatable && config.build_constructors)
    return
EOF
sed $sc ldscripts/${EMULATION_NAME}.xu                 >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocatable) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                 >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                 >> e${EMULATION_NAME}.c
echo '  ; else return'                                 >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                  >> e${EMULATION_NAME}.c
echo '; }'                                             >> e${EMULATION_NAME}.c

cat >>e${EMULATION_NAME}.c <<EOF


struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
{
  gld_${EMULATION_NAME}_before_parse,
  syslib_default,
  hll_default,
  gld_${EMULATION_NAME}_after_parse,
  gld_${EMULATION_NAME}_after_open,
  after_allocation_default,
  set_output_arch_default,
  ldemul_default_target,
  gld_${EMULATION_NAME}_before_allocation,
  gld_${EMULATION_NAME}_get_script,
  "${EMULATION_NAME}",
  "${OUTPUT_FORMAT}",
  gld_${EMULATION_NAME}_finish,
  NULL, /* Create output section statements.  */
  gld_${EMULATION_NAME}_open_dynamic_archive,
  gld_${EMULATION_NAME}_place_orphan,
  gld_${EMULATION_NAME}_set_symbols,
  NULL, /* parse_args */
  gld${EMULATION_NAME}_add_options,
  gld${EMULATION_NAME}_handle_option,
  gld_${EMULATION_NAME}_unrecognized_file,
  gld_${EMULATION_NAME}_list_options,
  gld_${EMULATION_NAME}_recognized_file,
  gld_${EMULATION_NAME}_find_potential_libraries,
  NULL	/* new_vers_pattern.  */
};
EOF
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d12 1
a12 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d71 1
a71 2

#include <ctype.h>
a105 38
static void gld_${EMULATION_NAME}_set_symbols PARAMS ((void));
static void gld_${EMULATION_NAME}_after_open PARAMS ((void));
static void gld_${EMULATION_NAME}_before_parse PARAMS ((void));
static void gld_${EMULATION_NAME}_after_parse PARAMS ((void));
static void gld_${EMULATION_NAME}_before_allocation PARAMS ((void));
static asection *output_prev_sec_find
  PARAMS ((lang_output_section_statement_type *));
static bfd_boolean gld_${EMULATION_NAME}_place_orphan
  PARAMS ((lang_input_statement_type *, asection *));
static char *gld_${EMULATION_NAME}_get_script PARAMS ((int *));
static void gld_${EMULATION_NAME}_finish PARAMS ((void));
static bfd_boolean gld_${EMULATION_NAME}_open_dynamic_archive
  PARAMS ((const char *, search_dirs_type *, lang_input_statement_type *));
static void gld${EMULATION_NAME}_add_options
  PARAMS ((int, char **, int, struct option **, int, struct option **));
static bfd_boolean gld${EMULATION_NAME}_handle_option PARAMS ((int));
static void gld_${EMULATION_NAME}_list_options PARAMS ((FILE *));
static void set_pe_name PARAMS ((char *, long));
static void set_pe_subsystem PARAMS ((void));
static void set_pe_value PARAMS ((char *));
static void set_pe_stack_heap PARAMS ((char *, char *));

#ifdef DLL_SUPPORT
static bfd_boolean pe_undef_cdecl_match
  PARAMS ((struct bfd_link_hash_entry *, PTR));
static void pe_fixup_stdcalls PARAMS ((void));
static int make_import_fixup PARAMS ((arelent *, asection *));
static void pe_find_data_imports PARAMS ((void));
#endif

static bfd_boolean pr_sym PARAMS ((struct bfd_hash_entry *, PTR));
static bfd_boolean gld_${EMULATION_NAME}_unrecognized_file
  PARAMS ((lang_input_statement_type *));
static bfd_boolean gld_${EMULATION_NAME}_recognized_file
  PARAMS ((lang_input_statement_type *));
static int gld_${EMULATION_NAME}_find_potential_libraries
  PARAMS ((char *, lang_input_statement_type *));

d124 1
a124 1
gld_${EMULATION_NAME}_before_parse()
d126 1
a126 9
  const bfd_arch_info_type *arch = bfd_scan_arch ("${OUTPUT_ARCH}");
  if (arch)
    {
      ldfile_output_architecture = arch->arch;
      ldfile_output_machine = arch->mach;
      ldfile_output_machine_name = arch->printable_name;
    }
  else
    ldfile_output_architecture = bfd_arch_${ARCH};
d136 1
a136 1
  lang_add_entry ("WinMainCRTStartup", 1);
d138 1
a138 1
  lang_add_entry ("_WinMainCRTStartup", 1);
d158 2
a159 2
#define OPTION_STACK                    (OPTION_SECTION_ALIGNMENT + 1)
#define OPTION_SUBSYSTEM                (OPTION_STACK + 1)
d187 4
a190 7
gld${EMULATION_NAME}_add_options (ns, shortopts, nl, longopts, nrl, really_longopts)
     int ns ATTRIBUTE_UNUSED;
     char **shortopts ATTRIBUTE_UNUSED;
     int nl;
     struct option **longopts;
     int nrl ATTRIBUTE_UNUSED;
     struct option **really_longopts ATTRIBUTE_UNUSED;
d290 1
a290 2
gld_${EMULATION_NAME}_list_options (file)
     FILE * file;
d342 1
a342 3
set_pe_name (name, val)
     char *name;
     long val;
d361 1
a361 1
set_pe_subsystem ()
d434 1
a434 1
	  lang_add_entry (entry, 0);
d445 1
a445 3
set_pe_value (name)
     char *name;

d459 1
a459 3
set_pe_stack_heap (resname, comname)
     char *resname;
     char *comname;
d474 1
a474 2
gld${EMULATION_NAME}_handle_option (optc)
     int optc;
d482 1
a482 1
      link_info.base_file = (PTR) fopen (optarg, FOPEN_WB);
d643 1
a643 1
gld_${EMULATION_NAME}_set_symbols ()
d652 1
a652 1
      if (link_info.relocateable)
d665 2
a666 2
  /* Don't do any symbol assignments if this is a relocateable link.  */
  if (link_info.relocateable)
d707 1
a707 1
gld_${EMULATION_NAME}_after_parse ()
d722 1
a722 1
  if (! link_info.relocateable && entry_symbol.name != NULL)
d737 1
a737 3
pe_undef_cdecl_match (h, string)
  struct bfd_link_hash_entry *h;
  PTR string;
d740 1
d742 1
a742 1
  sl = strlen (string); /* Silence compiler warning.  */
d754 1
a754 1
pe_fixup_stdcalls ()
d762 1
a762 1
  for (undef = link_info.hash->undefs; undef; undef=undef->next)
d803 1
a803 1
				    (PTR) undef->root.string);
d828 1
a828 3
make_import_fixup (rel, s)
  arelent *rel;
  asection *s;
d830 1
a830 1
  struct symbol_cache_entry *sym = *rel->sym_ptr_ptr;
d847 1
a847 1
pe_find_data_imports ()
d854 1
a854 1
  for (undef = link_info.hash->undefs; undef; undef=undef->next)
a910 1
#endif /* DLL_SUPPORT */
d913 1
a913 3
pr_sym (h, string)
  struct bfd_hash_entry *h;
  PTR string ATTRIBUTE_UNUSED;
d916 1
a916 1
    printf ("+%s\n",h->string);
d920 1
d924 1
a924 1
gld_${EMULATION_NAME}_after_open ()
d926 1
d934 1
a934 1
      for (sym = link_info.hash->undefs; sym; sym=sym->next)
d936 1
a936 1
      bfd_hash_traverse (&link_info.hash->table, pr_sym,NULL);
d941 1
d964 1
a964 1
  if (!link_info.relocateable)
d1064 1
a1064 1
			struct symbol_cache_entry *s;
d1110 1
d1125 1
d1127 1
d1132 17
a1148 3
		for (is2 = is;
		     is2 && is2->the_bfd->my_archive == arch;
		     is2 = (lang_input_statement_type *)is2->next)
d1150 19
a1168 2
		    if (strcmp (is->the_bfd->filename, is2->the_bfd->filename))
		      is_ms_arch = 0;
d1172 6
a1177 1
	    if (is_ms_arch)
d1211 1
a1211 1
gld_${EMULATION_NAME}_before_allocation ()
d1260 1
a1260 1
saw_option (char * option)
d1272 1
a1272 2
gld_${EMULATION_NAME}_unrecognized_file (entry)
     lang_input_statement_type *entry ATTRIBUTE_UNUSED;
d1361 1
a1361 2
gld_${EMULATION_NAME}_recognized_file (entry)
  lang_input_statement_type *entry ATTRIBUTE_UNUSED;
d1394 1
a1394 1
gld_${EMULATION_NAME}_finish ()
d1441 1
a1441 1
    || (!link_info.relocateable && pe_def_file->num_exports != 0)
d1478 1
a1478 2
output_prev_sec_find (os)
     lang_output_section_statement_type *os;
d1520 1
a1520 3
gld_${EMULATION_NAME}_place_orphan (file, s)
     lang_input_statement_type *file;
     asection *s;
d1533 1
a1533 1
  if (!link_info.relocateable)
d1624 1
a1624 1
	    if (! isalnum ((unsigned char) *ps) && *ps != '_')
d1639 1
a1639 1
      if (link_info.relocateable || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0)
a1649 1
						(bfd_vma) 0,
d1800 3
a1802 4
gld_${EMULATION_NAME}_open_dynamic_archive (arch, search, entry)
     const char * arch ATTRIBUTE_UNUSED;
     search_dirs_type * search;
     lang_input_statement_type * entry;
d1890 2
a1891 3
gld_${EMULATION_NAME}_find_potential_libraries (name, entry)
     char * name;
     lang_input_statement_type * entry;
d1897 1
a1897 2
gld_${EMULATION_NAME}_get_script (isfile)
     int *isfile;
d1907 1
a1907 1
  if (link_info.relocateable && config.build_constructors)
d1911 1
a1911 1
echo '  ; else if (link_info.relocateable) return'     >> e${EMULATION_NAME}.c
@


1.6
log
@resolve conflicts.
@
text
@d3 5
d12 1
a12 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000
d15 13
a27 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d34 14
a47 2
   the correct entry point by default. */ 
  
a54 1
#include "ldgram.h"
d59 1
d72 1
a72 1
#define TARGET_IS_${EMULATION_NAME}
a106 9
#ifdef TARGET_IS_arm_epoc_pe
#define bfd_arm_pe_allocate_interworking_sections \
	bfd_arm_epoc_pe_allocate_interworking_sections
#define bfd_arm_pe_get_bfd_for_interworking \
	bfd_arm_epoc_pe_get_bfd_for_interworking
#define bfd_arm_pe_process_before_allocation \
	bfd_arm_epoc_pe_process_before_allocation
#endif

d112 3
a114 1
static boolean gld_${EMULATION_NAME}_place_orphan
a116 1
static int gld_${EMULATION_NAME}_parse_args PARAMS ((int, char **));
d118 1
a118 1
static boolean gld_${EMULATION_NAME}_open_dynamic_archive 
d120 25
d153 1
a153 1
static int pe_enable_stdcall_fixup = -1; /* 0=disable 1=enable */
d165 9
a174 1
  ldfile_output_architecture = bfd_arch_${ARCH};
d176 1
d178 2
d193 1
a193 1
/* Used for setting flags in the PE header. */
d224 8
d233 27
a259 18
static struct option longopts[] = {
  /* PE options */
  {"base-file", required_argument, NULL, OPTION_BASE_FILE},
  {"dll", no_argument, NULL, OPTION_DLL},
  {"file-alignment", required_argument, NULL, OPTION_FILE_ALIGNMENT},
  {"heap", required_argument, NULL, OPTION_HEAP}, 
  {"image-base", required_argument, NULL, OPTION_IMAGE_BASE},
  {"major-image-version", required_argument, NULL, OPTION_MAJOR_IMAGE_VERSION},
  {"major-os-version", required_argument, NULL, OPTION_MAJOR_OS_VERSION},
  {"major-subsystem-version", required_argument, NULL, OPTION_MAJOR_SUBSYSTEM_VERSION},
  {"minor-image-version", required_argument, NULL, OPTION_MINOR_IMAGE_VERSION},
  {"minor-os-version", required_argument, NULL, OPTION_MINOR_OS_VERSION},
  {"minor-subsystem-version", required_argument, NULL, OPTION_MINOR_SUBSYSTEM_VERSION},
  {"section-alignment", required_argument, NULL, OPTION_SECTION_ALIGNMENT},
  {"stack", required_argument, NULL, OPTION_STACK},
  {"subsystem", required_argument, NULL, OPTION_SUBSYSTEM},
  {"support-old-code", no_argument, NULL, OPTION_SUPPORT_OLD_CODE},
  {"thumb-entry", required_argument, NULL, OPTION_THUMB_ENTRY},
d261 34
a294 21
  /* getopt allows abbreviations, so we do this to stop it from treating -o
     as an abbreviation for this option */
  {"output-def", required_argument, NULL, OPTION_OUT_DEF},
  {"output-def", required_argument, NULL, OPTION_OUT_DEF},
  {"export-all-symbols", no_argument, NULL, OPTION_EXPORT_ALL},
  {"exclude-symbols", required_argument, NULL, OPTION_EXCLUDE_SYMBOLS},
  {"kill-at", no_argument, NULL, OPTION_KILL_ATS},
  {"add-stdcall-alias", no_argument, NULL, OPTION_STDCALL_ALIASES},
  {"enable-stdcall-fixup", no_argument, NULL, OPTION_ENABLE_STDCALL_FIXUP},
  {"disable-stdcall-fixup", no_argument, NULL, OPTION_DISABLE_STDCALL_FIXUP},
  {"out-implib", required_argument, NULL, OPTION_IMPLIB_FILENAME},
  {"warn-duplicate-exports", no_argument, NULL, OPTION_WARN_DUPLICATE_EXPORTS},
  {"compat-implib", no_argument, NULL, OPTION_IMP_COMPAT},
  {"enable-auto-image-base", no_argument, NULL, OPTION_ENABLE_AUTO_IMAGE_BASE},
  {"disable-auto-image-base", no_argument, NULL, OPTION_DISABLE_AUTO_IMAGE_BASE},
  {"dll-search-prefix", required_argument, NULL, OPTION_DLL_SEARCH_PREFIX},
  {"no-default-excludes", no_argument, NULL, OPTION_NO_DEFAULT_EXCLUDES},
#endif
  {NULL, no_argument, NULL, 0}
};

d297 1
a297 1
   parameters which may be input from the command line */
d338 1
d364 1
d370 4
a373 4
  fprintf (file, _("  --compat-implib                    Create backward compatible import libs;\n"));
  fprintf (file, _("                                       create __imp_<SYMBOL> as well.\n"));
  fprintf (file, _("  --enable-auto-image-base           Automatically choose image base for DLLs\n"));
  fprintf (file, _("                                       unless user specifies one\n"));
d375 13
a387 3
  fprintf (file, _("  --dll-search-prefix=<string>       When linking dynamically to a dll witout an\n"));
  fprintf (file, _("                                       importlib, use <string><basename>.dll \n"));
  fprintf (file, _("                                       in preference to lib<basename>.dll \n"));
d391 1
d398 2
a399 1
  /* Find the name and set it. */
d409 1
a409 1
  abort();
d419 1
a419 1
  static const struct 
d487 1
a487 1
	  lang_add_entry (entry, 1);
d492 1
a492 1
  
a496 1

d500 1
a500 1
     
d503 1
a503 1
  
d505 1
a505 1
  
d512 1
d519 1
a519 1
  
d530 4
a533 22

static int
gld_${EMULATION_NAME}_parse_args(argc, argv)
     int argc;
     char **argv;
{
  int longind;
  int optc;
  int prevoptind = optind;
  int prevopterr = opterr;
  int wanterror;
  static int lastoptind = -1;

  if (lastoptind != optind)
    opterr = 0;
  wanterror = opterr;

  lastoptind = optind;

  optc = getopt_long_only (argc, argv, "-", longopts, &longind);
  opterr = prevopterr;

d537 1
a537 4
      if (wanterror)
	xexit (1);
      optind =  prevoptind;
      return 0;
d550 2
a551 2
      /* PE options */
    case OPTION_HEAP: 
d554 1
a554 1
    case OPTION_STACK: 
d604 4
a607 1
      pe_dll_add_excludes (optarg);
d637 1
a637 1
      pe_dll_search_prefix = xstrdup( optarg );
d642 15
d659 1
a659 1
  return 1;
d664 1
a664 1
static unsigned long 
d687 2
a688 1
/* Use the output file to create a image base for relocatable DLLs. */
d704 1
a704 1
     names and insert the defaults. */
d727 1
a727 1
  /* Glue the assignments into the abs section */
d736 8
a743 7
      rv = lang_add_assignment (exp_assop ('=' ,init[j].symbol, exp_intop (val)));
      if (init[j].size == sizeof(short))
	*(short *)init[j].ptr = val;
      else if (init[j].size == sizeof(int))
	*(int *)init[j].ptr = val;
      else if (init[j].size == sizeof(long))
	*(long *)init[j].ptr = val;
d745 3
a747 3
      else if (init[j].size == sizeof(bfd_vma))
	*(bfd_vma *)init[j].ptr = val;
      else	abort();
d751 1
a751 1
  /* Restore the pointer. */
d753 1
a753 1
  
d780 2
a781 2
  if (! link_info.relocateable && entry_symbol != NULL)
    ldlang_add_undef (entry_symbol);
d784 7
d794 1
a794 1
static boolean
d799 3
a801 1
  int sl = strlen (string);
d805 5
a809 5
  {
    pe_undef_found_sym = h;
    return false;
  }
  return true;
d817 4
a820 1
  char *at;
a822 3
    {
      at = strchr (undef->root.string, '@@');
      if (at)
d824 59
a882 23
	/* The symbol is a stdcall symbol, so let's look for a cdecl
	   symbol with the same name and resolve to that */
	char *cname = xstrdup (undef->root.string);
	at = strchr (cname, '@@');
	*at = 0;
	sym = bfd_link_hash_lookup (link_info.hash, cname, 0, 0, 1);
	if (sym && sym->type == bfd_link_hash_defined)
	{
	  undef->type = bfd_link_hash_defined;
	  undef->u.def.value = sym->u.def.value;
	  undef->u.def.section = sym->u.def.section;
	  if (pe_enable_stdcall_fixup == -1)
	    {
	      einfo (_("Warning: resolving %s by linking to %s\n"),
		     undef->root.string, cname);
	      if (! gave_warning_message)
		{
		  gave_warning_message = 1;
		  einfo(_("Use --enable-stdcall-fixup to disable these warnings\n"));
		  einfo(_("Use --disable-stdcall-fixup to disable these fixups\n"));
		}
	    }
	}
d884 60
a943 18
      else
      {
	/* The symbol is a cdecl symbol, so we look for stdcall
	   symbols - which means scanning the whole symbol table */
	pe_undef_found_sym = 0;
	bfd_link_hash_traverse (link_info.hash, pe_undef_cdecl_match,
				(PTR) undef->root.string);
	sym = pe_undef_found_sym;
	if (sym)
	{
	  undef->type = bfd_link_hash_defined;
	  undef->u.def.value = sym->u.def.value;
	  undef->u.def.section = sym->u.def.section;
	  if (pe_enable_stdcall_fixup == -1)
	    {
	      einfo (_("Warning: resolving %s by linking to %s\n"),
		     undef->root.string, sym->root.string);
	      if (! gave_warning_message)
d945 10
a954 3
		  gave_warning_message = 1;
		  einfo(_("Use --enable-stdcall-fixup to disable these warnings\n"));
		  einfo(_("Use --disable-stdcall-fixup to disable these fixups\n"));
d956 14
a969 3
	    }
	}
      }
d974 12
d989 15
d1007 2
a1008 2
  
  if (!coff_data (output_bfd)->pe)
d1018 5
a1022 1
  pe_process_import_defs(output_bfd, &link_info);
d1024 3
d1066 1
a1066 1
       things nicely and produce a valid import table. */
d1074 1
a1074 1
	    
d1084 1
a1084 1
	    
d1097 1
a1097 1
		    
d1104 1
a1104 1
		    
d1106 1
a1106 1
 		    symsize = bfd_canonicalize_symtab (is->the_bfd, symbols);
d1112 1
a1112 1
		    
d1122 1
a1122 1
		    
d1129 1
a1129 1
			
d1131 1
a1131 1
			
d1134 1
a1134 1
			
d1138 2
a1139 2
						     false, false, true);
			    
d1143 1
a1143 1
			
d1145 1
a1145 1
			    
d1149 1
a1149 1
			
d1152 1
a1152 1
			    
d1154 1
a1154 1
			    
d1232 2
a1233 2
static void  
gld_${EMULATION_NAME}_before_allocation()
d1236 1
a1236 1
  /* Here we rummage through the found bfds to collect toc information */
d1248 1
a1248 1
  /* We have seen it all. Allocate it, and carry on */
d1258 1
a1258 1
     option?  krk@@cygnus.com */
d1272 1
a1272 1
  /* We have seen it all. Allocate it, and carry on */
d1279 1
a1279 1
   check here for .DEF files and pull them in automatically. */
d1282 1
a1282 1
saw_option(char *option)
d1285 2
a1286 1
  for (i=0; init[i].ptr; i++)
d1293 2
a1294 2
static boolean
gld_${EMULATION_NAME}_unrecognized_file(entry)
d1301 7
a1307 9
  {
    if (pe_def_file == 0)
      pe_def_file = def_file_empty ();
    def_file_parse (entry->filename, pe_def_file);
    if (pe_def_file)
    {
      int i, buflen=0, len;
      char *buf;
      for (i=0; i<pe_def_file->num_exports; i++)
d1309 11
a1319 9
	  len = strlen(pe_def_file->exports[i].internal_name);
	  if (buflen < len+2)
	    buflen = len+2;
	}
      buf = (char *) xmalloc (buflen);
      for (i=0; i<pe_def_file->num_exports; i++)
	{
	  struct bfd_link_hash_entry *h;
	  sprintf(buf, "_%s", pe_def_file->exports[i].internal_name);
d1321 1
a1321 4
	  h = bfd_link_hash_lookup (link_info.hash, buf, true, true, true);
	  if (h == (struct bfd_link_hash_entry *) NULL)
	    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
	  if (h->type == bfd_link_hash_new)
d1323 13
a1335 3
	      h->type = bfd_link_hash_undefined;
	      h->u.undef.abfd = NULL;
	      bfd_link_add_undef (link_info.hash, h);
d1337 1
a1337 2
	}
      free (buf);
d1339 3
a1341 3
      /* def_file_print (stdout, pe_def_file); */
      if (pe_def_file->is_dll == 1)
	link_info.shared = 1;
d1343 10
a1352 10
      if (pe_def_file->base_address != (bfd_vma)(-1))
      {
	pe.ImageBase =
	pe_data (output_bfd)->pe_opthdr.ImageBase =
	init[IMAGEBASEOFF].value = pe_def_file->base_address;
	init[IMAGEBASEOFF].inited = 1;
	if (image_base_statement)
	  image_base_statement->exp =
	    exp_assop ('=', "__image_base__", exp_intop (pe.ImageBase));
      }
d1355 6
a1360 6
      /* Not sure if these *should* be set */
      if (pe_def_file->version_major != -1)
      {
	pe.MajorImageVersion = pe_def_file->version_major;
	pe.MinorImageVersion = pe_def_file->version_minor;
      }
d1362 16
a1377 15
      if (pe_def_file->stack_reserve != -1
	  && ! saw_option ("__size_of_stack_reserve__"))
      {
	pe.SizeOfStackReserve = pe_def_file->stack_reserve;
	if (pe_def_file->stack_commit != -1)
	  pe.SizeOfStackCommit = pe_def_file->stack_commit;
      }
      if (pe_def_file->heap_reserve != -1
	  && ! saw_option ("__size_of_heap_reserve__"))
      {
	pe.SizeOfHeapReserve = pe_def_file->heap_reserve;
	if (pe_def_file->heap_commit != -1)
	  pe.SizeOfHeapCommit = pe_def_file->heap_commit;
      }
      return true;
a1378 1
  }
d1380 1
a1380 2
  return false;
  
d1383 2
a1384 2
static boolean
gld_${EMULATION_NAME}_recognized_file(entry)
d1402 8
a1409 1
      const char *ext = entry->filename + strlen (entry->filename) - 4;
d1411 1
a1411 1
	return pe_implied_import_dll (entry->filename);
d1414 1
a1414 1
  return false;
d1425 3
a1427 2
      h = bfd_link_hash_lookup (link_info.hash, thumb_entry_symbol, false, false, true);
      
d1435 1
a1435 1
	  
d1442 1
a1442 1
	  
d1444 1
a1444 1
	  
d1449 1
a1449 1
	  
d1451 2
a1452 2
	  
	  if (entry_symbol != NULL && entry_from_cmdline)
d1454 2
a1455 2
		   thumb_entry_symbol, entry_symbol);
	  entry_symbol = buffer;
d1463 5
a1467 1
  if (link_info.shared)
d1480 1
a1480 1
  
d1484 11
d1498 26
d1544 1
a1544 2
/*ARGSUSED*/
static boolean
a1558 1

d1572 7
a1578 4
      && os->bfd_section != NULL
      && ((s->flags ^ os->bfd_section->flags) & (SEC_LOAD | SEC_ALLOC)) == 0)
    {
      wild_doit (&add_child, s, os, file);
d1618 1
a1618 1
	 different loadable or allocateable characteristics.  */
d1657 1
a1657 1
	      
d1665 1
a1665 1
      
d1682 1
a1682 1
      wild_doit (&add_child, s, os, file);
d1686 1
a1686 1
	 (struct lang_output_section_phdr_list *) NULL, "*default*");
d1692 2
a1693 2
	  /* lang_leave_ouput_section_statement resets stat_ptr.  Put
	     stat_ptr back where we want it.  */
d1696 1
a1696 1
	  
d1705 1
a1705 1
      if (place != NULL)
d1710 4
a1713 1
	  if (place->os->bfd_section != NULL || place->section != NULL)
d1715 12
a1726 17
	      /* Shuffle the section to make the output file look neater.  */
	      if (place->section == NULL)
		{
#if 0
		  /* Finding the end of the list is a little tricky.  We
		     make a wild stab at it by comparing section flags.  */
		  flagword first_flags = place->os->bfd_section->flags;
		  for (pps = &place->os->bfd_section->next;
		       *pps != NULL && (*pps)->flags == first_flags;
		       pps = &(*pps)->next)
		    ;
		  place->section = pps;
#else
		  /* Put orphans after the first section on the list.  */
		  place->section = &place->os->bfd_section->next;
#endif
		}
d1728 6
a1733 2
	      /*  Unlink the section.  */
	      for (pps = &output_bfd->sections; *pps != snew; pps = &(*pps)->next)
d1735 1
a1735 1
	      *pps = snew->next;
d1738 1
a1738 2
	      snew->next = *place->section;
	      *place->section = snew;
a1739 1
	  place->section = &snew->next;	/* Save the end of this list.  */
d1741 14
a1754 1
	  if (place->stmt == NULL)
d1756 20
a1775 9
	      /* Put the new statement list right at the head.  */
	      *add.tail = place->os->header.next;
	      place->os->header.next = add.head;
	    }
	  else
	    {
	      /* Put it after the last orphan statement we added.  */
	      *add.tail = *place->stmt;
	      *place->stmt = add.head;
a1776 1
	  place->stmt = add.tail;	/* Save the end of this list.  */
d1785 1
a1785 1
	boolean found_dollar;
d1789 2
a1790 3

	found_dollar = false;
	for ( ; *pl != NULL; pl = &(*pl)->next)
d1808 1
a1808 1
		found_dollar = true;
d1817 1
a1817 1
	add_child.head->next = *pl;
d1824 1
a1824 1
  return true;
d1827 1
a1827 1
static boolean
d1837 1
a1837 1
    return false;
d1842 1
a1842 1
                             + strlen (filename) 
d1849 1
a1849 1
  /* Try "libfoo.dll.a" first (preferred explicit import library for dll's */
d1854 1
a1854 1
      /* Try "foo.dll.a" next (alternate explicit import library for dll's */
d1858 9
a1866 11
/*
   Try libfoo.a next. Normally, this would be interpreted as a static
   library, but it *could* be an import library. For backwards compatibility,
   libfoo.a needs to ==precede== libfoo.dll and foo.dll in the search,
   or sometimes errors occur when building legacy packages.

   Putting libfoo.a here means that in a failure case (i.e. the library
   -lfoo is not found) we will search for libfoo.a twice before
   giving up -- once here, and once when searching for a "static" lib.
   for a "static" lib.
*/
d1868 1
a1868 1
             take precedence over dll's) */
d1874 2
a1875 2
                {  
                  /* Try "<prefix>foo.dll" (preferred dll name, if specified) */
d1879 1
a1879 1
                      /* Try "libfoo.dll" (default preferred dll name) */
d1883 1
a1883 1
                          /* Finally, try "foo.dll" (alternate dll name) */
d1888 1
a1888 1
                              return false;
d1893 2
a1894 2
              else /* pe_dll_search_prefix not specified */
#endif		
d1896 1
a1896 1
                  /* Try "libfoo.dll" (preferred dll name) */
d1900 1
a1900 1
                      /* Finally, try "foo.dll" (alternate dll name) */
d1905 1
a1905 1
                          return false;
d1915 1
a1915 1
  return true;
d1927 1
a1927 1
gld_${EMULATION_NAME}_get_script(isfile)
d1935 1
a1935 1
{			     
d1938 1
a1938 1
  if (link_info.relocateable == true && config.build_constructors == true)
d1941 10
a1950 10
sed $sc ldscripts/${EMULATION_NAME}.xu                     >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocateable == true) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                     >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'         >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                    >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                     >> e${EMULATION_NAME}.c
echo '  ; else return'                                     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                      >> e${EMULATION_NAME}.c
echo '; }'                                                 >> e${EMULATION_NAME}.c
d1955 1
a1955 1
struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation = 
d1969 2
a1970 2
  gld_${EMULATION_NAME}_finish, /* finish */
  NULL, /* create output section statements */
d1974 3
a1976 1
  gld_${EMULATION_NAME}_parse_args,
d1980 2
a1981 1
  gld_${EMULATION_NAME}_find_potential_libraries
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d7 2
a8 1
   Copyright 1995, 96, 97, 98, 99, 2000 Free Software Foundation, Inc.
d41 1
a45 1
#include "ldfile.h"
a105 2
static void gld${EMULATION_NAME}_place_section
  PARAMS ((lang_statement_union_type *));
d109 2
d118 1
d120 4
a123 3
#ifdef DLL_SUPPORT
static char *pe_out_def_filename = 0;
static char *pe_implib_filename = 0;
d175 4
d180 1
a180 2
static struct option longopts[] =
{
d212 4
d255 1
a255 1
  D(SizeOfStackReserve,"__size_of_stack_reserve__", 0x2000000),
d295 6
d559 12
d576 34
d626 4
d631 1
d696 1
a714 1
#ifdef DLL_SUPPORT
d831 110
d996 1
a996 1
		new_name = xmalloc (strlen(is->filename) + 3);
d1050 1
a1050 1

d1053 1
a1053 1
#ifdef DLL_SUPPORT
d1063 1
a1063 1
#endif
d1229 1
d1238 1
a1238 1
#endif
d1255 6
a1260 10
static asection *hold_section;
static char *hold_section_name;
static lang_output_section_statement_type *hold_use;
static lang_output_section_statement_type *hold_text;
static lang_output_section_statement_type *hold_rdata;
static lang_output_section_statement_type *hold_data;
static lang_output_section_statement_type *hold_bss;

/* Place an orphan section.  We use this to put random SHF_ALLOC
   sections in the right segment.  */
d1269 1
d1271 3
a1273 3

  if ((s->flags & SEC_ALLOC) == 0)
    return false;
a1278 2
  hold_section = s;

d1287 3
a1289 2
  hold_use = NULL;
  lang_for_each_statement (gld${EMULATION_NAME}_place_section);
d1291 7
a1297 1
  if (hold_use == NULL)
d1299 5
a1303 1
      lang_output_section_statement_type *place;
a1304 1
      asection *snew, **pps;
d1311 3
d1315 5
a1319 3
      if ((s->flags & SEC_HAS_CONTENTS) == 0
	  && hold_bss != NULL)
	place = hold_bss;
d1321 2
a1322 2
	       && hold_data != NULL)
	place = hold_data;
d1325 2
a1326 2
	       && hold_rdata != NULL)
	place = hold_rdata;
d1328 4
a1331 2
	       && hold_text != NULL)
	place = hold_text;
a1357 19
      /* We don't want to free OUTSECNAME, as it may get attached to
	 the output section statement.  */

      /* Create the section in the output file, and put it in the
	 right place.  This shuffling is to make the output file look
	 neater.  */
      snew = bfd_make_section (output_bfd, outsecname);
      if (snew == NULL)
	einfo ("%P%F: output format %s cannot represent section called %s\n",
	       output_bfd->xvec->name, outsecname);
      if (place != NULL && place->bfd_section != NULL)
	{
	  for (pps = &output_bfd->sections; *pps != snew; pps = &(*pps)->next)
	    ;
	  *pps = snew->next;
	  snew->next = place->bfd_section->next;
	  place->bfd_section->next = snew;
	}

d1363 22
a1384 2
      if (link_info.relocateable)
	address = NULL;
d1393 5
a1397 5
      lang_enter_output_section_statement (outsecname, address, 0,
					   (bfd_vma) 0,
					   (etree_type *) NULL,
					   (etree_type *) NULL,
					   (etree_type *) NULL);
d1399 1
a1399 1
      hold_use = lang_output_section_statement_lookup (outsecname);
d1403 1
a1403 2
	 (struct lang_output_section_phdr_list *) NULL,
	"*default*");
d1405 13
a1417 5
      /* Now stick the new statement list right after PLACE.  */
      if (place != NULL)
	{
	  *add.tail = place->header.next;
	  place->header.next = add.head;
a1420 1
    }
d1422 1
a1422 13
  if (dollar == NULL)
    wild_doit (&hold_use->children, s, hold_use, file);
  else
    {
      lang_statement_union_type **pl;
      boolean found_dollar;
      lang_statement_list_type list;

      /* The section name has a '$'.  Sort it with the other '$'
         sections.  */

      found_dollar = false;
      for (pl = &hold_use->children.head; *pl != NULL; pl = &(*pl)->next)
d1424 1
a1424 2
	  lang_input_section_type *ls;
	  const char *lname;
d1426 20
a1445 2
	  if ((*pl)->header.type != lang_input_section_enum)
	    continue;
d1447 10
a1456 1
	  ls = &(*pl)->input_section;
d1458 1
a1458 2
	  lname = bfd_get_section_name (ls->ifile->the_bfd, ls->section);
	  if (strchr (lname, '$') == NULL)
d1460 3
a1462 2
	      if (found_dollar)
		break;
d1466 3
a1468 3
	      found_dollar = true;
	      if (strcmp (secname, lname) < 0)
		break;
d1470 1
d1472 22
d1495 21
a1515 9
      lang_list_init (&list);
      wild_doit (&list, s, hold_use, file);
      if (list.head != NULL)
	{
	  ASSERT (list.head->next == NULL);
	  list.head->next = *pl;
	  *pl = list.head;
	}
    }
d1522 5
a1526 3
static void
gld${EMULATION_NAME}_place_section (s)
     lang_statement_union_type *s;
d1528 18
a1545 1
  lang_output_section_statement_type *os;
d1547 62
a1608 2
  if (s->header.type != lang_output_section_statement_enum)
    return;
d1610 1
a1610 1
  os = &s->output_section_statement;
d1612 1
a1612 14
  if (strcmp (os->name, hold_section_name) == 0
      && os->bfd_section != NULL
      && ((hold_section->flags & (SEC_LOAD | SEC_ALLOC))
	  == (os->bfd_section->flags & (SEC_LOAD | SEC_ALLOC))))
    hold_use = os;

  if (strcmp (os->name, ".text") == 0)
    hold_text = os;
  else if (strcmp (os->name, ".rdata") == 0)
    hold_rdata = os;
  else if (strcmp (os->name, ".data") == 0)
    hold_data = os;
  else if (strcmp (os->name, ".bss") == 0)
    hold_bss = os;
d1668 1
a1668 1
  NULL, /* open dynamic archive */
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d3 3
a5 9
cat >e${EMULATION_NAME}.c <<EOF
/* For WINDOWS_NT */
/* The original file generated returned different default scripts depending
   on whether certain switches were set, but these switches pertain to the
   Linux system and that particular version of coff.  In the NT case, we
   only determine if the subsystem is console or windows in order to select
   the correct entry point by default. */ 
  

d7 1
d23 7
d34 1
a34 1
#include "ld.h"
d46 3
d51 3
d56 42
d101 1
d103 1
a103 1
static boolean gld${EMULATION_NAME}_place_orphan
d105 2
d109 1
a109 9

#if 0 /* argument to qsort so don't prototype */
static int sort_by_file_name PARAMS ((void *, void *));
static int sort_by_section_name PARAMS ((void *, void *));
#endif
static lang_statement_union_type **sort_sections_1
  PARAMS ((lang_statement_union_type **, lang_statement_union_type *, int,
	   int (*)()));
static void sort_sections PARAMS ((lang_statement_union_type *));
d113 11
d128 1
d130 11
d160 12
d173 2
a174 1
static struct option longopts[] = {
d176 33
a208 16
    {"base-file", required_argument, NULL, OPTION_BASE_FILE},
    {"dll", no_argument, NULL, OPTION_DLL},
    {"file-alignment", required_argument, NULL, OPTION_FILE_ALIGNMENT},
    {"heap", required_argument, NULL, OPTION_HEAP}, 
    {"image-base", required_argument, NULL, OPTION_IMAGE_BASE}, 
    {"major-image-version", required_argument, NULL, OPTION_MAJOR_IMAGE_VERSION},
    {"major-os-version", required_argument, NULL, OPTION_MAJOR_OS_VERSION},
    {"major-subsystem-version", required_argument, NULL, OPTION_MAJOR_SUBSYSTEM_VERSION},
    {"minor-image-version", required_argument, NULL, OPTION_MINOR_IMAGE_VERSION},
    {"minor-os-version", required_argument, NULL, OPTION_MINOR_OS_VERSION},
    {"minor-subsystem-version", required_argument, NULL, OPTION_MINOR_SUBSYSTEM_VERSION},
    {"section-alignment", required_argument, NULL, OPTION_SECTION_ALIGNMENT},
    {"stack", required_argument, NULL, OPTION_STACK},
    {"subsystem", required_argument, NULL, OPTION_SUBSYSTEM},
   {NULL, no_argument, NULL, 0}
  };
d214 2
a215 1
typedef struct {
d231 1
a231 1
  {&dll, sizeof(dll), 0, "__dll__"},
d238 3
d242 1
d244 1
a244 1
  D(Subsystem,"__subsystem__", 3),
d250 1
a250 1
  0
d253 34
d322 7
a328 3
      { "native", 1, "_NtProcessStartup" },
      { "windows", 2, "_WinMainCRTStartup" },
      { "console", 3, "_mainCRTStartup" },
d333 2
a334 1
      { "posix", 7, "___PosixProcessStartup"},
d352 1
a352 1
	einfo ("%P: warning: bad version number in -subsystem option\n");
d360 3
d365 18
a382 18
	  /* If the subsystem is windows, we use a different entry
	     point.  We also register the entry point as an undefined
	     symbol.  The reason we do this is so that the user
	     doesn't have to because they would have to use the -u
	     switch if they were specifying an entry point other than
	     _mainCRTStartup.  Specifically, if creating a windows
	     application, entry point _WinMainCRTStartup must be
	     specified.  What I have found for non console
	     applications (entry not _mainCRTStartup) is that the .obj
	     that contains mainCRTStartup is brought in since it is
	     the first encountered in libc.lib and it has other
	     symbols in it which will be pulled in by the link
	     process.  To avoid this, adding -u with the entry point
	     name specified forces the correct .obj to be used.  We
	     can avoid making the user do this by always adding the
	     entry point name as an undefined symbol.  */
	  lang_add_entry (v[i].entry, 1);
	  ldlang_add_undef (v[i].entry);
d387 2
a388 1
  einfo ("%P%F: invalid subsystem type %s\n", optarg);
d399 1
d401 1
d403 1
a403 3
    {
      einfo ("%P%F: invalid hex number for PE parameter '%s'\n", optarg);
    }
a412 3
  char *begin_commit;
  char *end;

d414 1
d421 1
a421 3
    {
      einfo ("%P%F: strange hex info for PE parameter '%s'\n", optarg);
    }
d459 2
a460 1
	  fprintf (stderr, "%s: Can't open base file %s\n",
d506 38
d548 3
d552 1
a552 1
gld_${EMULATION_NAME}_set_symbols()
d560 12
a571 2
    init[IMAGEBASEOFF].value = init[DLLOFF].value
      ? NT_DLL_IMAGE_BASE : NT_EXE_IMAGE_BASE;
d581 2
a582 1
      lang_add_assignment (exp_assop ('=' ,init[j].symbol, exp_intop (val)));
d589 3
d593 2
d602 1
a602 1
      einfo ("%P: warning, file alignment > section alignment.\n");
d606 3
d610 1
a610 1
gld_${EMULATION_NAME}_after_open()
d612 12
a623 9
  /* Pass the wacky PE command line options into the output bfd */
  struct internal_extra_pe_aouthdr *i;
  if (!coff_data(output_bfd)->pe)
    {
      einfo ("%F%P: PE operations on non PE file.\n");
    }

  pe_data(output_bfd)->pe_opthdr = pe;
  pe_data(output_bfd)->dll = init[DLLOFF].value;
d625 2
a627 2

/* Callback functions for qsort in sort_sections. */
d629 1
a629 10
static int
sort_by_file_name (a, b)
     void *a;
     void *b;
{
  lang_statement_union_type **ra = a;
  lang_statement_union_type **rb = b;
  return strcmp ((*ra)->input_section.ifile->filename,
		 (*rb)->input_section.ifile->filename);
}
d631 4
a634 20
static int
sort_by_section_name (a, b)
     void *a;
     void *b;
{
  lang_statement_union_type **ra = a;
  lang_statement_union_type **rb = b;
  return strcmp ((*ra)->input_section.section->name,
		 (*rb)->input_section.section->name);
}

/* Subroutine of sort_sections to a contiguous subset of a list of sections.
   NEXT_AFTER is the element after the last one to sort.
   The result is a pointer to the last element's "next" pointer.  */

static lang_statement_union_type **
sort_sections_1 (startptr, next_after, count, sort_func)
     lang_statement_union_type **startptr,*next_after;
     int count;
     int (*sort_func) ();
d636 9
a644 21
  lang_statement_union_type **vec;
  lang_statement_union_type *p;
  int i;

  if (count == 0)
    return startptr;

  vec = (lang_statement_union_type **)
    alloca (count * sizeof (lang_statement_union_type *));

  for (p = *startptr, i = 0; i < count; i++, p = p->next)
    vec[i] = p;

  qsort (vec, count, sizeof (vec[0]), sort_func);

  /* Fill in the next pointers again. */
  *startptr = vec[0];
  for (i = 0; i < count - 1; i++)
    vec[i]->header.next = vec[i + 1];
  vec[i]->header.next = next_after;
  return &(vec[i]->header.next);
d647 1
a647 14
/* Sort the .idata\$foo input sections of archives into filename order.
   The reason is so dlltool can arrange to have the pe dll import information
   generated correctly - the head of the list goes into dh.o, the tail into
   dt.o, and the guts into ds[nnnn].o.  Note that this is only needed for the
   .idata section.
   FIXME: This may no longer be necessary with grouped sections.  Instead of
   sorting on dh.o, ds[nnnn].o, dt.o, one could, for example, have dh.o use
   .idata\$4h, have ds[nnnn].o use .idata\$4s[nnnn], and have dt.o use .idata\$4t.
   This would have to be elaborated upon to handle multiple dll's
   [assuming such an eloboration is possible of course].

   We also sort sections in '\$' wild statements.  These are created by the
   place_orphans routine to implement grouped sections.  */

d649 1
a649 2
sort_sections (s)
     lang_statement_union_type *s;
d651 8
a658 2
  for (; s ; s = s->next)
    switch (s->header.type)
d660 12
a671 10
      case lang_output_section_statement_enum:
	sort_sections (s->output_section_statement.children.head);
	break;
      case lang_wild_statement_enum:
	{
	  lang_statement_union_type **p = &s->wild_statement.children.head;

	  /* Is this the .idata section?  */
	  if (s->wild_statement.section_name != NULL
	      && strncmp (s->wild_statement.section_name, ".idata", 6) == 0)
d673 3
a675 8
	      /* Sort any children in the same archive.  Run through all
		 the children of this wild statement, when an
		 input_section in an archive is found, scan forward to
		 find all input_sections which are in the same archive.
		 Sort them by their filename and then re-thread the
		 pointer chain. */

	      while (*p)
d677 3
a679 18
		  lang_statement_union_type *start = *p;
		  if (start->header.type != lang_input_section_enum
		      || !start->input_section.ifile->the_bfd->my_archive)
		    p = &(start->header.next);
		  else
		    {
		      lang_statement_union_type *end;
		      int count;

		      for (end = start, count = 0;
			   end && end->header.type == lang_input_section_enum
			   && (end->input_section.ifile->the_bfd->my_archive
			       == start->input_section.ifile->the_bfd->my_archive);
			   end = end->next)
			count++;

		      p = sort_sections_1 (p, end, count, sort_by_file_name);
		    }
a680 1
	      break;
d682 16
a697 7

	  /* If this is a collection of grouped sections, sort them.
	     The linker script must explicitly mention "*(.foo\$)".
	     Don't sort them if \$ is not the last character (not sure if
	     this is really useful, but it allows explicitly mentioning
	     some \$ sections and letting the linker handle the rest).  */
	  if (s->wild_statement.section_name != NULL)
d699 3
a701 3
	      char *q = strchr (s->wild_statement.section_name, '\$');

	      if (q && q[1] == 0)
d703 3
a705 10
		  lang_statement_union_type *end;
		  int count;

		  for (end = *p, count = 0; end; end = end->next)
		    {
		      if (end->header.type != lang_input_section_enum)
			abort ();
		      count++;
		    }
		  (void) sort_sections_1 (p, end, count, sort_by_section_name);
a706 1
	      break;
a708 3
	break;
      default:
	break;
d710 1
d712 30
d743 85
a830 2
  extern lang_statement_list_type *stat_ptr;

d836 1
a836 1
	if (!ppc_process_before_allocation(is->the_bfd, &link_info))
d838 2
a839 1
	    einfo("Errors encountered processing file %s", is->filename);
d846 40
d888 83
a970 1
  sort_sections (stat_ptr->head);
d972 91
d1064 23
a1086 6
/* Place an orphan section.  We use this to put sections with a '\$' in them
   into the right place.  Any section with a '\$' in them (e.g. .text\$foo)
   gets mapped to the output section with everything from the '\$' on stripped
   (e.g. .text).
   See the Microsoft Portable Executable and Common Object File Format
   Specification 4.1, section 4.2, Grouped Sections.  */
d1090 1
a1090 1
gld${EMULATION_NAME}_place_orphan (file, s)
d1095 1
a1095 4
  char *output_secname, *ps;
  lang_output_section_statement_type *os;
  lang_statement_list_type *ptr;
  lang_statement_union_type *l;
d1100 144
a1243 6
  /* Don't process grouped sections unless doing a final link.
     If they're marked as COMDAT sections, we don't want .text\$foo to
     end up in .text and then have .text disappear because it's marked
     link-once-discard.  */
  if (link_info.relocateable)
    return false;
d1245 1
a1245 1
  secname = bfd_get_section_name (s->owner, s);
d1247 13
a1259 6
  /* Everything from the '\$' on gets deleted so don't allow '\$' as the
     first character.  */
  if (*secname == '\$')
    einfo ("%P%F: section %s has '\$' as first character\n", secname);
  if (strchr (secname + 1, '\$') == NULL)
    return false;
d1261 8
a1268 36
  /* Look up the output section.  The Microsoft specs say sections names in
     image files never contain a '\$'.  Fortunately, lang_..._lookup creates
     the section if it doesn't exist.  */
  output_secname = buystring (secname);
  ps = strchr (output_secname + 1, '\$');
  *ps = 0;
  os = lang_output_section_statement_lookup (output_secname);

  /* Find the '\$' wild statement for this section.  We currently require the
     linker script to explicitly mention "*(.foo\$)".
     FIXME: ppcpe.sc has .CRT\$foo in the .rdata section.  According to the
     Microsoft docs this isn't correct so it's not (currently) handled.  */

  ps[0] = '\$';
  ps[1] = 0;
  for (l = os->children.head; l; l = l->next)
    {
      if (l->header.type == lang_wild_statement_enum
	  && strcmp (l->wild_statement.section_name, output_secname) == 0)
	break;
    }
  ps[0] = 0;
  if (l == NULL)
#if 1
    einfo ("%P%F: *(%s\$) missing from linker script\n", output_secname);
#else /* FIXME: This block is untried.  It exists to convey the intent,
	 should one decide to not require *(.foo\$) to appear in the linker
	 script.  */
    {
      lang_wild_statement_type *new = new_stat (lang_wild_statement,
						&os->children);
      new->section_name = xmalloc (strlen (output_secname) + 2);
      sprintf (new->section_name, "%s\$", output_secname);
      new->filename = NULL;
      lang_list_init (&new->children);
      l = new;
a1269 1
#endif
d1271 1
a1271 5
  /* Link the input section in and we're done for now.
     The sections still have to be sorted, but that has to wait until
     all such sections have been processed by us.  The sorting is done by
     sort_sections.  */
  wild_doit (&l->wild_statement.children, s, os, file);
d1275 35
d1317 1
a1317 1
sc="-f ${srcdir}/emultempl/stringify.sed"
d1345 1
a1345 1
  after_parse_default,
d1354 1
a1354 1
  NULL, /* finish */
d1357 1
a1357 1
  gld${EMULATION_NAME}_place_orphan,
d1359 5
a1363 1
  gld_${EMULATION_NAME}_parse_args
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d142 1
a142 1
  D(SizeOfStackReserve,"__size_of_stack_reserve__", 0x100000),
d174 2
d177 1
a177 1
  static struct 
d179 3
a181 2
      char *name ;
      int value;
d185 9
a193 6
      {"native", 1},
      {"windows",2},
      {"console",3},
      {"os2",5},
      {"posix", 7},
      {0,0}
d196 17
d215 2
a216 1
      if (!strcmp (optarg, v[i].name)) 
d219 20
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d538 4
a541 1
	ppc_process_before_allocation(is->the_bfd, &link_info);
@


1.1
log
@Initial revision
@
text
@a27 1

d48 2
d51 14
a64 2
static char *gld_${EMULATION_NAME}_get_script PARAMS ((int *isfile));

d74 2
a75 1

d93 1
a93 1
  static struct option longopts[] = {
a115 2


d209 1
a209 1
  set_pe_name (name,  strtoul (optarg, &end, 16));
d281 1
a281 1
      set_pe_stack_heap ("__heap_reserve__", "__heap_commit__");
d284 1
a284 1
      set_pe_stack_heap ("__stack_reserve__", "__stack_commit__");
d322 1
a322 1

d324 1
a324 1
gld_${EMULATION_NAME}_set_symbols() 
d336 1
a336 1
  save=stat_ptr;
d339 1
d376 2
d379 4
a382 5
/* Callback function for qsort in sort_sections. */

static int sfunc (a, b)
void *a;
void *b;
d390 58
a447 2
/* Sort the input sections of archives into filename order. */

d462 34
a495 6
	  /* Sort any children in the same archive.  Run through all
	     the children of this wild statement, when an
	     input_section in an archive is found, scan forward to
	     find all input_sections which are in the same archive.
	     Sort them by their filename and then re-thread the
	     pointer chain. */
d497 6
a502 1
	  while (*p)
d504 3
a506 5
	      lang_statement_union_type *start = *p;
	      if (start->header.type != lang_input_section_enum
		  || !start->input_section.ifile->the_bfd->my_archive)
		p = &(start->header.next);
	      else
a507 1
		  lang_statement_union_type **vec;
a508 1
		  lang_statement_union_type *np;
a509 1
		  int i;
d511 7
a517 23
		  for (end = start, count = 0;
		       end && end->header.type == lang_input_section_enum
		       && (end->input_section.ifile->the_bfd->my_archive
			   == start->input_section.ifile->the_bfd->my_archive);
		       end = end->next)
		    count++;

		  np = end;

		  vec = (lang_statement_union_type **)
		    alloca (count * sizeof (lang_statement_union_type *));

		  for (end = start, i = 0; i < count; i++, end = end->next)
		    vec[i] = end;

		  qsort (vec, count, sizeof (vec[0]), sfunc);

		  /* Fill in the next pointers again. */
		  *p = vec[0];
		  for (i = 0; i < count - 1; i++)
		    vec[i]->header.next = vec[i + 1];
		  vec[i]->header.next = np;
		  p = &(vec[i]->header.next);
d519 1
d546 1
a546 1
  sort_sections (*stat_ptr);
d548 77
d626 9
a663 1

d681 1
a681 1
  NULL, /* place orphan */
a685 1

@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d28 1
a48 2
static void gld_${EMULATION_NAME}_set_symbols PARAMS ((void));
static void gld_${EMULATION_NAME}_after_open PARAMS ((void));
d50 2
a51 14
static void gld_${EMULATION_NAME}_before_allocation PARAMS ((void));
static boolean gld${EMULATION_NAME}_place_orphan
  PARAMS ((lang_input_statement_type *, asection *));
static char *gld_${EMULATION_NAME}_get_script PARAMS ((int *));
static int gld_${EMULATION_NAME}_parse_args PARAMS ((int, char **));

#if 0 /* argument to qsort so don't prototype */
static int sort_by_file_name PARAMS ((void *, void *));
static int sort_by_section_name PARAMS ((void *, void *));
#endif
static lang_statement_union_type **sort_sections_1
  PARAMS ((lang_statement_union_type **, lang_statement_union_type *, int,
	   int (*)()));
static void sort_sections PARAMS ((lang_statement_union_type *));
d61 1
a61 2

/* PE format extra command line options.  */
d79 1
a79 1
static struct option longopts[] = {
d102 2
d197 1
a197 1
  set_pe_name (name,  strtoul (optarg, &end, 0));
d269 1
a269 1
      set_pe_stack_heap ("__size_of_heap_reserve__", "__size_of_heap_commit__");
d272 1
a272 1
      set_pe_stack_heap ("__size_of_stack_reserve__", "__size_of_stack_commit__");
d310 1
a310 1

d312 1
a312 1
gld_${EMULATION_NAME}_set_symbols()
d324 1
a324 1
  save = stat_ptr;
a326 1

a362 2

/* Callback functions for qsort in sort_sections. */
d364 5
a368 4
static int
sort_by_file_name (a, b)
     void *a;
     void *b;
d376 2
a377 58
static int
sort_by_section_name (a, b)
     void *a;
     void *b;
{
  lang_statement_union_type **ra = a;
  lang_statement_union_type **rb = b;
  return strcmp ((*ra)->input_section.section->name,
		 (*rb)->input_section.section->name);
}

/* Subroutine of sort_sections to a contiguous subset of a list of sections.
   NEXT_AFTER is the element after the last one to sort.
   The result is a pointer to the last element's "next" pointer.  */

static lang_statement_union_type **
sort_sections_1 (startptr, next_after, count, sort_func)
     lang_statement_union_type **startptr,*next_after;
     int count;
     int (*sort_func) ();
{
  lang_statement_union_type **vec;
  lang_statement_union_type *p;
  int i;

  if (count == 0)
    return startptr;

  vec = (lang_statement_union_type **)
    alloca (count * sizeof (lang_statement_union_type *));

  for (p = *startptr, i = 0; i < count; i++, p = p->next)
    vec[i] = p;

  qsort (vec, count, sizeof (vec[0]), sort_func);

  /* Fill in the next pointers again. */
  *startptr = vec[0];
  for (i = 0; i < count - 1; i++)
    vec[i]->header.next = vec[i + 1];
  vec[i]->header.next = next_after;
  return &(vec[i]->header.next);
}

/* Sort the .idata\$foo input sections of archives into filename order.
   The reason is so dlltool can arrange to have the pe dll import information
   generated correctly - the head of the list goes into dh.o, the tail into
   dt.o, and the guts into ds[nnnn].o.  Note that this is only needed for the
   .idata section.
   FIXME: This may no longer be necessary with grouped sections.  Instead of
   sorting on dh.o, ds[nnnn].o, dt.o, one could, for example, have dh.o use
   .idata\$4h, have ds[nnnn].o use .idata\$4s[nnnn], and have dt.o use .idata\$4t.
   This would have to be elaborated upon to handle multiple dll's
   [assuming such an eloboration is possible of course].

   We also sort sections in '\$' wild statements.  These are created by the
   place_orphans routine to implement grouped sections.  */

d392 6
a397 34
	  /* Is this the .idata section?  */
	  if (s->wild_statement.section_name != NULL
	      && strncmp (s->wild_statement.section_name, ".idata", 6) == 0)
	    {
	      /* Sort any children in the same archive.  Run through all
		 the children of this wild statement, when an
		 input_section in an archive is found, scan forward to
		 find all input_sections which are in the same archive.
		 Sort them by their filename and then re-thread the
		 pointer chain. */

	      while (*p)
		{
		  lang_statement_union_type *start = *p;
		  if (start->header.type != lang_input_section_enum
		      || !start->input_section.ifile->the_bfd->my_archive)
		    p = &(start->header.next);
		  else
		    {
		      lang_statement_union_type *end;
		      int count;

		      for (end = start, count = 0;
			   end && end->header.type == lang_input_section_enum
			   && (end->input_section.ifile->the_bfd->my_archive
			       == start->input_section.ifile->the_bfd->my_archive);
			   end = end->next)
			count++;

		      p = sort_sections_1 (p, end, count, sort_by_file_name);
		    }
		}
	      break;
	    }
d399 1
a399 6
	  /* If this is a collection of grouped sections, sort them.
	     The linker script must explicitly mention "*(.foo\$)".
	     Don't sort them if \$ is not the last character (not sure if
	     this is really useful, but it allows explicitly mentioning
	     some \$ sections and letting the linker handle the rest).  */
	  if (s->wild_statement.section_name != NULL)
d401 5
a405 3
	      char *q = strchr (s->wild_statement.section_name, '\$');

	      if (q && q[1] == 0)
d407 1
d409 1
d411 1
d413 23
a435 7
		  for (end = *p, count = 0; end; end = end->next)
		    {
		      if (end->header.type != lang_input_section_enum)
			abort ();
		      count++;
		    }
		  (void) sort_sections_1 (p, end, count, sort_by_section_name);
a436 1
	      break;
d463 1
a463 1
  sort_sections (stat_ptr->head);
a464 77

/* Place an orphan section.  We use this to put sections with a '\$' in them
   into the right place.  Any section with a '\$' in them (e.g. .text\$foo)
   gets mapped to the output section with everything from the '\$' on stripped
   (e.g. .text).
   See the Microsoft Portable Executable and Common Object File Format
   Specification 4.1, section 4.2, Grouped Sections.  */

/*ARGSUSED*/
static boolean
gld${EMULATION_NAME}_place_orphan (file, s)
     lang_input_statement_type *file;
     asection *s;
{
  const char *secname;
  char *output_secname, *ps;
  lang_output_section_statement_type *os;
  lang_statement_list_type *ptr;
  lang_statement_union_type *l;

  if ((s->flags & SEC_ALLOC) == 0)
    return false;

  /* Don't process grouped sections unless doing a final link.
     If they're marked as COMDAT sections, we don't want .text\$foo to
     end up in .text and then have .text disappear because it's marked
     link-once-discard.  */
  if (link_info.relocateable)
    return false;

  secname = bfd_get_section_name (s->owner, s);

  /* Everything from the '\$' on gets deleted so don't allow '\$' as the
     first character.  */
  if (*secname == '\$')
    einfo ("%P%F: section %s has '\$' as first character\n", secname);
  if (strchr (secname + 1, '\$') == NULL)
    return false;

  /* Look up the output section.  The Microsoft specs say sections names in
     image files never contain a '\$'.  Fortunately, lang_..._lookup creates
     the section if it doesn't exist.  */
  output_secname = buystring (secname);
  ps = strchr (output_secname + 1, '\$');
  *ps = 0;
  os = lang_output_section_statement_lookup (output_secname);

  /* Find the '\$' wild statement for this section.  We currently require the
     linker script to explicitly mention "*(.foo\$)".
     FIXME: ppcpe.sc has .CRT\$foo in the .rdata section.  According to the
     Microsoft docs this isn't correct so it's not (currently) handled.  */

  ps[0] = '\$';
  ps[1] = 0;
  for (l = os->children.head; l; l = l->next)
    {
      if (l->header.type == lang_wild_statement_enum
	  && strcmp (l->wild_statement.section_name, output_secname) == 0)
	break;
    }
  ps[0] = 0;
  if (l == NULL)
#if 1
    einfo ("%P%F: *(%s\$) missing from linker script\n", output_secname);
#else /* FIXME: This block is untried.  It exists to convey the intent,
	 should one decide to not require *(.foo\$) to appear in the linker
	 script.  */
    {
      lang_wild_statement_type *new = new_stat (lang_wild_statement,
						&os->children);
      new->section_name = xmalloc (strlen (output_secname) + 2);
      sprintf (new->section_name, "%s\$", output_secname);
      new->filename = NULL;
      lang_list_init (&new->children);
      l = new;
    }
#endif
a465 9
  /* Link the input section in and we're done for now.
     The sections still have to be sorted, but that has to wait until
     all such sections have been processed by us.  The sorting is done by
     sort_sections.  */
  wild_doit (&l->wild_statement.children, s, os, file);

  return true;
}

d495 1
d513 1
a513 1
  gld${EMULATION_NAME}_place_orphan,
d518 1
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d538 1
a538 4
	if (!ppc_process_before_allocation(is->the_bfd, &link_info))
	  {
	    einfo("Errors encountered processing file %s", is->filename);
	  }
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d142 1
a142 1
  D(SizeOfStackReserve,"__size_of_stack_reserve__", 0x2000000),
a173 2
  const char *sver;
  int len;
d175 1
a175 1
  static const struct 
d177 2
a178 3
      const char *name;
      const int value;
      const char *entry;
d182 6
a187 9
      { "native", 1, "_NtProcessStartup" },
      { "windows", 2, "_WinMainCRTStartup" },
      { "console", 3, "_mainCRTStartup" },
#if 0
      /* The Microsoft linker does not recognize this.  */
      { "os2", 5, "" },
#endif
      { "posix", 7, "___PosixProcessStartup"},
      { 0, 0, 0 }
a189 17
  sver = strchr (optarg, ':');
  if (sver == NULL)
    len = strlen (optarg);
  else
    {
      char *end;

      len = sver - optarg;
      set_pe_name ("__major_subsystem_version__",
		   strtoul (sver + 1, &end, 0));
      if (*end == '.')
	set_pe_name ("__minor_subsystem_version__",
		     strtoul (end + 1, &end, 0));
      if (*end != '\0')
	einfo ("%P: warning: bad version number in -subsystem option\n");
    }

d192 1
a192 2
      if (strncmp (optarg, v[i].name, len) == 0
	  && v[i].name[len] == '\0')
a194 20

	  /* If the subsystem is windows, we use a different entry
	     point.  We also register the entry point as an undefined
	     symbol.  The reason we do this is so that the user
	     doesn't have to because they would have to use the -u
	     switch if they were specifying an entry point other than
	     _mainCRTStartup.  Specifically, if creating a windows
	     application, entry point _WinMainCRTStartup must be
	     specified.  What I have found for non console
	     applications (entry not _mainCRTStartup) is that the .obj
	     that contains mainCRTStartup is brought in since it is
	     the first encountered in libc.lib and it has other
	     symbols in it which will be pulled in by the link
	     process.  To avoid this, adding -u with the entry point
	     name specified forces the correct .obj to be used.  We
	     can avoid making the user do this by always adding the
	     entry point name as an undefined symbol.  */
	  lang_add_entry (v[i].entry, 1);
	  ldlang_add_undef (v[i].entry);

@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d4 8
a12 1
   Copyright 1995, 96, 1997 Free Software Foundation, Inc.
a27 7
/* For WINDOWS_NT */
/* The original file generated returned different default scripts depending
   on whether certain switches were set, but these switches pertain to the
   Linux system and that particular version of coff.  In the NT case, we
   only determine if the subsystem is console or windows in order to select
   the correct entry point by default. */ 
  
d32 1
a32 1
#include "libiberty.h"
a68 2
extern const char *output_filename;

a71 1
  output_filename = "a.exe";
d147 1
a147 1
  { NULL, 0, 0, NULL, 0 }
d267 3
a393 3
      /* This might be a long long or other special type.  */
      else if (init[j].size == sizeof(bfd_vma))
	*(bfd_vma *)init[j].ptr = val;
d409 2
a410 3
  /* Pass the wacky PE command line options into the output bfd.
     FIXME: This should be done via a function, rather than by
     including an internal BFD header.  */
a429 7
  int i;

  i = strcmp ((*ra)->input_section.ifile->the_bfd->my_archive->filename,
	      (*rb)->input_section.ifile->the_bfd->my_archive->filename);
  if (i != 0)
    return i;

a457 1
  lang_statement_union_type **ret;
d462 2
a463 2
  vec = ((lang_statement_union_type **)
	 xmalloc (count * sizeof (lang_statement_union_type *)));
d475 1
a475 3
  ret = &vec[i]->header.next;
  free (vec);
  return ret;
d510 6
a515 6
	      /* Sort the children.  We want to sort any objects in
                 the same archive.  In order to handle the case of
                 including a single archive multiple times, we sort
                 all the children by archive name and then by object
                 name.  After sorting them, we re-thread the pointer
                 chain.  */
d529 3
a531 1
			   end && end->header.type == lang_input_section_enum;
d612 1
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d3 1
a3 3
rm -f e${EMULATION_NAME}.c
(echo;echo;echo;echo;echo)>e${EMULATION_NAME}.c # there, now line numbers match ;-)
cat >>e${EMULATION_NAME}.c <<EOF
d5 1
a5 1
   Copyright 1995, 96, 97, 98, 99, 2000 Free Software Foundation, Inc.
a43 3

/* FIXME: This is a BFD internal header file, and we should not be
   using it here.  */
a45 3
#include "deffile.h"
#include "pe-dll.h"

a47 42
/* Permit the emulation parameters to override the default section
   alignment by setting OVERRIDE_SECTION_ALIGNMENT.  FIXME: This makes
   it seem that include/coff/internal.h should not define
   PE_DEF_SECTION_ALIGNMENT.  */
#if PE_DEF_SECTION_ALIGNMENT != ${OVERRIDE_SECTION_ALIGNMENT:-PE_DEF_SECTION_ALIGNMENT}
#undef PE_DEF_SECTION_ALIGNMENT
#define PE_DEF_SECTION_ALIGNMENT ${OVERRIDE_SECTION_ALIGNMENT}
#endif

#if defined(TARGET_IS_i386pe)
#define DLL_SUPPORT
#endif
#if defined(TARGET_IS_shpe) || defined(TARGET_IS_mipspe) || defined(TARGET_IS_armpe)
#define DLL_SUPPORT
#endif

#if defined(TARGET_IS_i386pe) || ! defined(DLL_SUPPORT)
#define	PE_DEF_SUBSYSTEM		3
#else
#undef NT_EXE_IMAGE_BASE
#undef PE_DEF_SECTION_ALIGNMENT
#undef PE_DEF_FILE_ALIGNMENT
#define NT_EXE_IMAGE_BASE		0x00010000
#ifdef TARGET_IS_armpe
#define PE_DEF_SECTION_ALIGNMENT	0x00001000
#define	PE_DEF_SUBSYSTEM		9
#else
#define PE_DEF_SECTION_ALIGNMENT	0x00000400
#define	PE_DEF_SUBSYSTEM		2
#endif
#define PE_DEF_FILE_ALIGNMENT		0x00000200
#endif

#ifdef TARGET_IS_arm_epoc_pe
#define bfd_arm_pe_allocate_interworking_sections \
	bfd_arm_epoc_pe_allocate_interworking_sections
#define bfd_arm_pe_get_bfd_for_interworking \
	bfd_arm_epoc_pe_get_bfd_for_interworking
#define bfd_arm_pe_process_before_allocation \
	bfd_arm_epoc_pe_process_before_allocation
#endif

a50 1
static void gld_${EMULATION_NAME}_after_parse PARAMS ((void));
d52 1
a52 1
static boolean gld_${EMULATION_NAME}_place_orphan
a53 2
static void gld${EMULATION_NAME}_place_section
  PARAMS ((lang_statement_union_type *));
d56 9
a64 1
static void gld_${EMULATION_NAME}_finish PARAMS ((void));
a67 9
static int support_old_code = 0;
static char * thumb_entry_symbol = NULL;
static lang_assignment_statement_type *image_base_statement = 0;

static int pe_enable_stdcall_fixup = -1; /* 0=disable 1=enable */
#ifdef DLL_SUPPORT
static char *pe_out_def_filename = 0;
static char *pe_implib_filename = 0;
#endif
d74 1
a74 1
  output_filename = "${EXECUTABLE_NAME:-a.exe}";
a75 11
#ifdef DLL_SUPPORT
  config.has_shared = 1;

#if (PE_DEF_SUBSYSTEM == 9) || (PE_DEF_SUBSYSTEM == 2)
#if defined TARGET_IS_mipspe || defined TARGET_IS_armpe
  lang_add_entry ("WinMainCRTStartup", 1);
#else
  lang_add_entry ("_WinMainCRTStartup", 1);
#endif
#endif
#endif
a94 12
#define OPTION_SUPPORT_OLD_CODE		(OPTION_HEAP + 1)
#define OPTION_OUT_DEF			(OPTION_SUPPORT_OLD_CODE + 1)
#define OPTION_EXPORT_ALL		(OPTION_OUT_DEF + 1)
#define OPTION_EXCLUDE_SYMBOLS		(OPTION_EXPORT_ALL + 1)
#define OPTION_KILL_ATS			(OPTION_EXCLUDE_SYMBOLS + 1)
#define OPTION_STDCALL_ALIASES		(OPTION_KILL_ATS + 1)
#define OPTION_ENABLE_STDCALL_FIXUP	(OPTION_STDCALL_ALIASES + 1)
#define OPTION_DISABLE_STDCALL_FIXUP	(OPTION_ENABLE_STDCALL_FIXUP + 1)
#define OPTION_IMPLIB_FILENAME		(OPTION_DISABLE_STDCALL_FIXUP + 1)
#define OPTION_THUMB_ENTRY		(OPTION_IMPLIB_FILENAME + 1)
#define OPTION_WARN_DUPLICATE_EXPORTS	(OPTION_THUMB_ENTRY + 1)
#define OPTION_IMP_COMPAT		(OPTION_WARN_DUPLICATE_EXPORTS + 1)
d96 1
a96 2
static struct option longopts[] =
{
d98 16
a113 33
  {"base-file", required_argument, NULL, OPTION_BASE_FILE},
  {"dll", no_argument, NULL, OPTION_DLL},
  {"file-alignment", required_argument, NULL, OPTION_FILE_ALIGNMENT},
  {"heap", required_argument, NULL, OPTION_HEAP}, 
  {"image-base", required_argument, NULL, OPTION_IMAGE_BASE},
  {"major-image-version", required_argument, NULL, OPTION_MAJOR_IMAGE_VERSION},
  {"major-os-version", required_argument, NULL, OPTION_MAJOR_OS_VERSION},
  {"major-subsystem-version", required_argument, NULL, OPTION_MAJOR_SUBSYSTEM_VERSION},
  {"minor-image-version", required_argument, NULL, OPTION_MINOR_IMAGE_VERSION},
  {"minor-os-version", required_argument, NULL, OPTION_MINOR_OS_VERSION},
  {"minor-subsystem-version", required_argument, NULL, OPTION_MINOR_SUBSYSTEM_VERSION},
  {"section-alignment", required_argument, NULL, OPTION_SECTION_ALIGNMENT},
  {"stack", required_argument, NULL, OPTION_STACK},
  {"subsystem", required_argument, NULL, OPTION_SUBSYSTEM},
  {"support-old-code", no_argument, NULL, OPTION_SUPPORT_OLD_CODE},
  {"thumb-entry", required_argument, NULL, OPTION_THUMB_ENTRY},
#ifdef DLL_SUPPORT
  /* getopt allows abbreviations, so we do this to stop it from treating -o
     as an abbreviation for this option */
  {"output-def", required_argument, NULL, OPTION_OUT_DEF},
  {"output-def", required_argument, NULL, OPTION_OUT_DEF},
  {"export-all-symbols", no_argument, NULL, OPTION_EXPORT_ALL},
  {"exclude-symbols", required_argument, NULL, OPTION_EXCLUDE_SYMBOLS},
  {"kill-at", no_argument, NULL, OPTION_KILL_ATS},
  {"add-stdcall-alias", no_argument, NULL, OPTION_STDCALL_ALIASES},
  {"enable-stdcall-fixup", no_argument, NULL, OPTION_ENABLE_STDCALL_FIXUP},
  {"disable-stdcall-fixup", no_argument, NULL, OPTION_DISABLE_STDCALL_FIXUP},
  {"out-implib", required_argument, NULL, OPTION_IMPLIB_FILENAME},
  {"warn-duplicate-exports", no_argument, NULL, OPTION_WARN_DUPLICATE_EXPORTS},
  {"compat-implib", no_argument, NULL, OPTION_IMP_COMPAT},
#endif
  {NULL, no_argument, NULL, 0}
};
d119 1
a119 2
typedef struct
{
d135 1
a135 1
  {&dll, sizeof(dll), 0, "__dll__", 0},
a141 3
#ifdef TARGET_IS_armpe
  D(MajorSubsystemVersion,"__major_subsystem_version__", 2),
#else
a142 1
#endif
d144 1
a144 1
  D(Subsystem,"__subsystem__", ${SUBSYSTEM}),
a152 34
static void
gld_${EMULATION_NAME}_list_options (file)
     FILE * file;
{
  fprintf (file, _("  --base_file <basefile>             Generate a base file for relocatable DLLs\n"));
  fprintf (file, _("  --dll                              Set image base to the default for DLLs\n"));
  fprintf (file, _("  --file-alignment <size>            Set file alignment\n"));
  fprintf (file, _("  --heap <size>                      Set initial size of the heap\n"));
  fprintf (file, _("  --image-base <address>             Set start address of the executable\n"));
  fprintf (file, _("  --major-image-version <number>     Set version number of the executable\n"));
  fprintf (file, _("  --major-os-version <number>        Set minimum required OS version\n"));
  fprintf (file, _("  --major-subsystem-version <number> Set minimum required OS subsystem version\n"));
  fprintf (file, _("  --minor-image-version <number>     Set revision number of the executable\n"));
  fprintf (file, _("  --minor-os-version <number>        Set minimum required OS revision\n"));
  fprintf (file, _("  --minor-subsystem-version <number> Set minimum required OS subsystem revision\n"));
  fprintf (file, _("  --section-alignment <size>         Set section alignment\n"));
  fprintf (file, _("  --stack <size>                     Set size of the initial stack\n"));
  fprintf (file, _("  --subsystem <name>[:<version>]     Set required OS subsystem [& version]\n"));
  fprintf (file, _("  --support-old-code                 Support interworking with old code\n"));
  fprintf (file, _("  --thumb-entry=<symbol>             Set the entry point to be Thumb <symbol>\n"));
#ifdef DLL_SUPPORT
  fprintf (file, _("  --add-stdcall-alias                Export symbols with and without @@nn\n"));
  fprintf (file, _("  --disable-stdcall-fixup            Don't link _sym to _sym@@nn\n"));
  fprintf (file, _("  --enable-stdcall-fixup             Link _sym to _sym@@nn without warnings\n"));
  fprintf (file, _("  --exclude-symbols sym,sym,...      Exclude symbols from automatic export\n"));
  fprintf (file, _("  --export-all-symbols               Automatically export all globals to DLL\n"));
  fprintf (file, _("  --kill-at                          Remove @@nn from exported symbols\n"));
  fprintf (file, _("  --out-implib <file>                Generate import library\n"));
  fprintf (file, _("  --output-def <file>                Generate a .DEF file for the built DLL\n"));
  fprintf (file, _("  --warn-duplicate-exports           Warn about duplicate exports.\n"));
  fprintf (file, _("  --compat-implib                    Create backward compatible import libs;\n"));
  fprintf (file, _("                                       create __imp_<SYMBOL> as well.\n"));
#endif
}
d188 3
a190 7
      { "native", 1, "NtProcessStartup" },
#if defined TARGET_IS_mipspe || defined TARGET_IS_armpe
      { "windows", 2, "WinMainCRTStartup" },
#else
      { "windows", 2, "WinMainCRTStartup" },
#endif
      { "console", 3, "mainCRTStartup" },
d195 1
a195 2
      { "posix", 7, "__PosixProcessStartup"},
      { "wince", 9, "_WinMainCRTStartup" },
d213 1
a213 1
	einfo (_("%P: warning: bad version number in -subsystem option\n"));
a220 3
	  const char *initial_symbol_char;
	  const char *entry;

d223 18
a240 18
	  initial_symbol_char = ${INITIAL_SYMBOL_CHAR};
	  if (*initial_symbol_char == '\0')
	    entry = v[i].entry;
	  else
	    {
	      char *alc_entry;

	      /* lang_add_entry expects its argument to be permanently
		 allocated, so we don't free this string.  */
	      alc_entry = xmalloc (strlen (initial_symbol_char)
				   + strlen (v[i].entry)
				   + 1);
	      strcpy (alc_entry, initial_symbol_char);
	      strcat (alc_entry, v[i].entry);
	      entry = alc_entry;
	    }

	  lang_add_entry (entry, 1);
d245 1
a245 2
  
  einfo (_("%P%F: invalid subsystem type %s\n"), optarg);
a255 1
  
a256 1
  
d258 3
a260 1
    einfo (_("%P%F: invalid hex number for PE parameter '%s'\n"), optarg);
a270 1
  
d277 3
a279 1
    einfo (_("%P%F: strange hex info for PE parameter '%s'\n"), optarg);
d317 1
a317 2
	  /* xgettext:c-format */
	  fprintf (stderr, _("%s: Can't open base file %s\n"),
a362 38
    case OPTION_SUPPORT_OLD_CODE:
      support_old_code = 1;
      break;
    case OPTION_THUMB_ENTRY:
      thumb_entry_symbol = optarg;
      break;
#ifdef DLL_SUPPORT
    case OPTION_OUT_DEF:
      pe_out_def_filename = xstrdup (optarg);
      break;
    case OPTION_EXPORT_ALL:
      pe_dll_export_everything = 1;
      break;
    case OPTION_EXCLUDE_SYMBOLS:
      pe_dll_add_excludes (optarg);
      break;
    case OPTION_KILL_ATS:
      pe_dll_kill_ats = 1;
      break;
    case OPTION_STDCALL_ALIASES:
      pe_dll_stdcall_aliases = 1;
      break;
    case OPTION_ENABLE_STDCALL_FIXUP:
      pe_enable_stdcall_fixup = 1;
      break;
    case OPTION_DISABLE_STDCALL_FIXUP:
      pe_enable_stdcall_fixup = 0;
      break;
    case OPTION_IMPLIB_FILENAME:
      pe_implib_filename = xstrdup (optarg);
      break;
    case OPTION_WARN_DUPLICATE_EXPORTS:
      pe_dll_warn_dup_exports = 1;
      break;
    case OPTION_IMP_COMPAT:
      pe_dll_compat_implib = 1;
      break;
#endif
a366 3
/* Assign values to the special symbols before the linker script is
   read.  */

d368 1
a368 1
gld_${EMULATION_NAME}_set_symbols ()
d376 2
a377 12
    {
      if (link_info.relocateable)
	init[IMAGEBASEOFF].value = 0;
      else if (init[DLLOFF].value || link_info.shared)
	init[IMAGEBASEOFF].value = NT_DLL_IMAGE_BASE;
      else
	init[IMAGEBASEOFF].value = NT_EXE_IMAGE_BASE;
    }

  /* Don't do any symbol assignments if this is a relocateable link.  */
  if (link_info.relocateable)
    return;
d387 1
a387 2
      lang_assignment_statement_type *rv;
      rv = lang_add_assignment (exp_assop ('=' ,init[j].symbol, exp_intop (val)));
a397 2
      if (j == IMAGEBASEOFF)
	image_base_statement = rv;
d405 1
a405 1
      einfo (_("%P: warning, file alignment > section alignment.\n"));
a408 3
/* This is called after the linker script and the command line options
   have been read.  */

d410 1
a410 1
gld_${EMULATION_NAME}_after_parse ()
d412 10
a421 12
  /* The Windows libraries are designed for the linker to treat the
     entry point as an undefined symbol.  Otherwise, the .obj that
     defines mainCRTStartup is brought in because it is the first
     encountered in libc.lib and it has other symbols in it which will
     be pulled in by the link process.  To avoid this, we act as
     though the user specified -u with the entry point symbol.

     This function is called after the linker script and command line
     options have been read, so at this point we know the right entry
     point.  This function is called before the input files are
     opened, so registering the symbol as undefined will make a
     difference.  */
a422 2
  if (! link_info.relocateable && entry_symbol != NULL)
    ldlang_add_undef (entry_symbol);
d424 2
d427 17
a443 1
static struct bfd_link_hash_entry *pe_undef_found_sym;
d445 20
a464 4
static boolean
pe_undef_cdecl_match (h, string)
  struct bfd_link_hash_entry *h;
  PTR string;
d466 24
a489 9
  int sl = strlen (string);
  if (h->type == bfd_link_hash_defined
      && strncmp (h->root.string, string, sl) == 0
      && h->root.string[sl] == '@@')
  {
    pe_undef_found_sym = h;
    return false;
  }
  return true;
d492 14
a505 1
#ifdef DLL_SUPPORT
d507 2
a508 1
pe_fixup_stdcalls ()
d510 2
a511 8
  static int gave_warning_message = 0;
  struct bfd_link_hash_entry *undef, *sym;
  char *at;
  for (undef = link_info.hash->undefs; undef; undef=undef->next)
    if (undef->type == bfd_link_hash_undefined)
    {
      at = strchr (undef->root.string, '@@');
      if (at)
d513 10
a522 12
	/* The symbol is a stdcall symbol, so let's look for a cdecl
	   symbol with the same name and resolve to that */
	char *cname = xstrdup (undef->root.string);
	at = strchr (cname, '@@');
	*at = 0;
	sym = bfd_link_hash_lookup (link_info.hash, cname, 0, 0, 1);
	if (sym && sym->type == bfd_link_hash_defined)
	{
	  undef->type = bfd_link_hash_defined;
	  undef->u.def.value = sym->u.def.value;
	  undef->u.def.section = sym->u.def.section;
	  if (pe_enable_stdcall_fixup == -1)
d524 8
a531 3
	      einfo (_("Warning: resolving %s by linking to %s\n"),
		     undef->root.string, cname);
	      if (! gave_warning_message)
d533 16
a548 3
		  gave_warning_message = 1;
		  einfo(_("Use --enable-stdcall-fixup to disable these warnings\n"));
		  einfo(_("Use --disable-stdcall-fixup to disable these fixups\n"));
d550 1
d552 7
a558 16
	}
      }
      else
      {
	/* The symbol is a cdecl symbol, so we look for stdcall
	   symbols - which means scanning the whole symbol table */
	pe_undef_found_sym = 0;
	bfd_link_hash_traverse (link_info.hash, pe_undef_cdecl_match,
				(PTR) undef->root.string);
	sym = pe_undef_found_sym;
	if (sym)
	{
	  undef->type = bfd_link_hash_defined;
	  undef->u.def.value = sym->u.def.value;
	  undef->u.def.section = sym->u.def.section;
	  if (pe_enable_stdcall_fixup == -1)
d560 3
a562 3
	      einfo (_("Warning: resolving %s by linking to %s\n"),
		     undef->root.string, sym->root.string);
	      if (! gave_warning_message)
d564 10
a573 3
		  gave_warning_message = 1;
		  einfo(_("Use --enable-stdcall-fixup to disable these warnings\n"));
		  einfo(_("Use --disable-stdcall-fixup to disable these fixups\n"));
d575 1
d578 3
a581 1
    }
a582 50
#endif /* DLL_SUPPORT */

static void
gld_${EMULATION_NAME}_after_open ()
{
  /* Pass the wacky PE command line options into the output bfd.
     FIXME: This should be done via a function, rather than by
     including an internal BFD header.  */
  
  if (!coff_data (output_bfd)->pe)
    einfo (_("%F%P: PE operations on non PE file.\n"));

  pe_data (output_bfd)->pe_opthdr = pe;
  pe_data (output_bfd)->dll = init[DLLOFF].value;

#ifdef DLL_SUPPORT
  if (pe_enable_stdcall_fixup) /* -1=warn or 1=disable */
    pe_fixup_stdcalls ();

  pe_process_import_defs(output_bfd, &link_info);
  if (link_info.shared)
    pe_dll_build_sections (output_bfd, &link_info);

#ifndef TARGET_IS_i386pe
#ifndef TARGET_IS_armpe
  else
    pe_exe_build_sections (output_bfd, &link_info);
#endif
#endif
#endif

#if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe)
  if (strstr (bfd_get_target (output_bfd), "arm") == NULL)
    {
      /* The arm backend needs special fields in the output hash structure.
	 These will only be created if the output format is an arm format,
	 hence we do not support linking and changing output formats at the
	 same time.  Use a link followed by objcopy to change output formats.  */
      einfo ("%F%X%P: error: cannot change output format whilst linking ARM binaries\n");
      return;
    }
  {
    /* Find a BFD that can hold the interworking stubs.  */
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	if (bfd_arm_pe_get_bfd_for_interworking (is->the_bfd, & link_info))
	  break;
      }
  }
#endif
a583 65
  {
    int is_ms_arch = 0;
    bfd *cur_arch = 0;
    lang_input_statement_type *is2;

    /* Careful - this is a shell script.  Watch those dollar signs! */
    /* Microsoft import libraries have every member named the same,
       and not in the right order for us to link them correctly.  We
       must detect these and rename the members so that they'll link
       correctly.  There are three types of objects: the head, the
       thunks, and the sentinel(s).  The head is easy; it's the one
       with idata2.  We assume that the sentinels won't have relocs,
       and the thunks will.  It's easier than checking the symbol
       table for external references.  */
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	if (is->the_bfd->my_archive)
	  {
	    bfd *arch = is->the_bfd->my_archive;
	    if (cur_arch != arch)
	      {
		cur_arch = arch;
		is_ms_arch = 1;
		for (is2 = is;
		     is2 && is2->the_bfd->my_archive == arch;
		     is2 = (lang_input_statement_type *)is2->next)
		  {
		    if (strcmp (is->the_bfd->filename, is2->the_bfd->filename))
		      is_ms_arch = 0;
		  }
	      }

	    if (is_ms_arch)
	      {
		int idata2 = 0, reloc_count=0;
		asection *sec;
		char *new_name, seq;

		for (sec = is->the_bfd->sections; sec; sec = sec->next)
		  {
		    if (strcmp (sec->name, ".idata\$2") == 0)
		      idata2 = 1;
		    reloc_count += sec->reloc_count;
		  }

		if (idata2) /* .idata2 is the TOC */
		  seq = 'a';
		else if (reloc_count > 0) /* thunks */
		  seq = 'b';
		else /* sentinel */
		  seq = 'c';

		new_name = xmalloc (strlen (is->the_bfd->filename) + 3);
		sprintf (new_name, "%s.%c", is->the_bfd->filename, seq);
		is->the_bfd->filename = new_name;

		new_name = xmalloc (strlen(is->filename) + 3);
		sprintf (new_name, "%s.%c", is->filename, seq);
		is->filename = new_name;
	      }
	  }
      }
  }
}

d587 2
d594 1
a594 1
	if (!ppc_process_before_allocation (is->the_bfd, &link_info))
d596 1
a596 2
	    /* xgettext:c-format */
	    einfo (_("Errors encountered processing file %s\n"), is->filename);
a602 140
#endif /* TARGET_IS_ppcpe */

#if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe)
  /* FIXME: we should be able to set the size of the interworking stub
     section.

     Here we rummage through the found bfds to collect glue
     information.  FIXME: should this be based on a command line
     option?  krk@@cygnus.com */
  {
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	if (! bfd_arm_pe_process_before_allocation
	    (is->the_bfd, & link_info, support_old_code))
	  {
	    /* xgettext:c-format */
	    einfo (_("Errors encountered processing file %s for interworking"),
		   is->filename);
	  }
      }
  }

  /* We have seen it all. Allocate it, and carry on */
  bfd_arm_pe_allocate_interworking_sections (& link_info);
#endif /* TARGET_IS_armpe */
}


/* This is called when an input file isn't recognized as a BFD.  We
   check here for .DEF files and pull them in automatically. */
#ifdef DLL_SUPPORT
static int
saw_option(char *option)
{
  int i;
  for (i=0; init[i].ptr; i++)
    if (strcmp (init[i].symbol, option) == 0)
      return init[i].inited;
  return 0;
}
#endif

static boolean
gld_${EMULATION_NAME}_unrecognized_file(entry)
     lang_input_statement_type *entry ATTRIBUTE_UNUSED;
{
#ifdef DLL_SUPPORT
  const char *ext = entry->filename + strlen (entry->filename) - 4;

  if (strcmp (ext, ".def") == 0 || strcmp (ext, ".DEF") == 0)
  {
    if (pe_def_file == 0)
      pe_def_file = def_file_empty ();
    def_file_parse (entry->filename, pe_def_file);
    if (pe_def_file)
    {
      int i, buflen=0, len;
      char *buf;
      for (i=0; i<pe_def_file->num_exports; i++)
	{
	  len = strlen(pe_def_file->exports[i].internal_name);
	  if (buflen < len+2)
	    buflen = len+2;
	}
      buf = (char *) xmalloc (buflen);
      for (i=0; i<pe_def_file->num_exports; i++)
	{
	  struct bfd_link_hash_entry *h;
	  sprintf(buf, "_%s", pe_def_file->exports[i].internal_name);

	  h = bfd_link_hash_lookup (link_info.hash, buf, true, true, true);
	  if (h == (struct bfd_link_hash_entry *) NULL)
	    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
	  if (h->type == bfd_link_hash_new)
	    {
	      h->type = bfd_link_hash_undefined;
	      h->u.undef.abfd = NULL;
	      bfd_link_add_undef (link_info.hash, h);
	    }
	}
      free (buf);

      /* def_file_print (stdout, pe_def_file); */
      if (pe_def_file->is_dll == 1)
	link_info.shared = 1;

      if (pe_def_file->base_address != (bfd_vma)(-1))
      {
	pe.ImageBase =
	pe_data (output_bfd)->pe_opthdr.ImageBase =
	init[IMAGEBASEOFF].value = pe_def_file->base_address;
	init[IMAGEBASEOFF].inited = 1;
	if (image_base_statement)
	  image_base_statement->exp =
	    exp_assop ('=', "__image_base__", exp_intop (pe.ImageBase));
      }

#if 0
      /* Not sure if these *should* be set */
      if (pe_def_file->version_major != -1)
      {
	pe.MajorImageVersion = pe_def_file->version_major;
	pe.MinorImageVersion = pe_def_file->version_minor;
      }
#endif
      if (pe_def_file->stack_reserve != -1
	  && ! saw_option ("__size_of_stack_reserve__"))
      {
	pe.SizeOfStackReserve = pe_def_file->stack_reserve;
	if (pe_def_file->stack_commit != -1)
	  pe.SizeOfStackCommit = pe_def_file->stack_commit;
      }
      if (pe_def_file->heap_reserve != -1
	  && ! saw_option ("__size_of_heap_reserve__"))
      {
	pe.SizeOfHeapReserve = pe_def_file->heap_reserve;
	if (pe_def_file->heap_commit != -1)
	  pe.SizeOfHeapCommit = pe_def_file->heap_commit;
      }
      return true;
    }
  }
#endif
  return false;
  
}

static boolean
gld_${EMULATION_NAME}_recognized_file(entry)
  lang_input_statement_type *entry ATTRIBUTE_UNUSED;
{
#ifdef DLL_SUPPORT
#ifdef TARGET_IS_i386pe
  pe_dll_id_target ("pei-i386");
#endif
#ifdef TARGET_IS_shpe
  pe_dll_id_target ("pei-shl");
#endif
#ifdef TARGET_IS_mipspe
  pe_dll_id_target ("pei-mips");
a603 12
#ifdef TARGET_IS_armpe
  pe_dll_id_target ("pei-arm-little");
#endif
  if (bfd_get_format (entry->the_bfd) == bfd_object)
    {
      const char *ext = entry->filename + strlen (entry->filename) - 4;
      if (strcmp (ext, ".dll") == 0 || strcmp (ext, ".DLL") == 0)
	return pe_implied_import_dll (entry->filename);
    }
#endif
  return false;
}
d605 1
a605 61
static void
gld_${EMULATION_NAME}_finish ()
{
#if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe)
  struct bfd_link_hash_entry * h;

  if (thumb_entry_symbol != NULL)
    {
      h = bfd_link_hash_lookup (link_info.hash, thumb_entry_symbol, false, false, true);
      
      if (h != (struct bfd_link_hash_entry *) NULL
	  && (h->type == bfd_link_hash_defined
	      || h->type == bfd_link_hash_defweak)
	  && h->u.def.section->output_section != NULL)
	{
	  static char buffer[32];
	  bfd_vma val;
	  
	  /* Special procesing is required for a Thumb entry symbol.  The
	     bottom bit of its address must be set.  */
	  val = (h->u.def.value
		 + bfd_get_section_vma (output_bfd,
					h->u.def.section->output_section)
		 + h->u.def.section->output_offset);
	  
	  val |= 1;
	  
	  /* Now convert this value into a string and store it in entry_symbol
	     where the lang_finish() function will pick it up.  */
	  buffer[0] = '0';
	  buffer[1] = 'x';
	  
	  sprintf_vma (buffer + 2, val);
	  
	  if (entry_symbol != NULL && entry_from_cmdline)
	    einfo (_("%P: warning: '--thumb-entry %s' is overriding '-e %s'\n"),
		   thumb_entry_symbol, entry_symbol);
	  entry_symbol = buffer;
	}
      else
	einfo (_("%P: warning: connot find thumb start symbol %s\n"), thumb_entry_symbol);
    }
#endif /* defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe) */

#ifdef DLL_SUPPORT
  if (link_info.shared)
    {
      pe_dll_fill_sections (output_bfd, &link_info);
      if (pe_implib_filename)
	pe_dll_generate_implib (pe_def_file, pe_implib_filename);
    }
#if defined(TARGET_IS_shpe) || defined(TARGET_IS_mipspe)
  else
    {
      pe_exe_fill_sections (output_bfd, &link_info);
    }
#endif
  
  if (pe_out_def_filename)
    pe_dll_generate_def_file (pe_out_def_filename);
#endif
a606 1

d608 6
a613 23
/* Place an orphan section.

   We use this to put sections in a reasonable place in the file, and
   to ensure that they are aligned as required.

   We handle grouped sections here as well.  A section named .foo$nn
   goes into the output section .foo.  All grouped sections are sorted
   by name.

   Grouped sections for the default sections are handled by the
   default linker script using wildcards, and are sorted by
   sort_sections.  */

static asection *hold_section;
static char *hold_section_name;
static lang_output_section_statement_type *hold_use;
static lang_output_section_statement_type *hold_text;
static lang_output_section_statement_type *hold_rdata;
static lang_output_section_statement_type *hold_data;
static lang_output_section_statement_type *hold_bss;

/* Place an orphan section.  We use this to put random SHF_ALLOC
   sections in the right segment.  */
d617 1
a617 1
gld_${EMULATION_NAME}_place_orphan (file, s)
d622 3
a624 1
  char *dollar = NULL;
d629 7
d638 6
a643 1
  /* Look through the script to see where to place this section.  */
d645 36
a680 8
  hold_section = s;

  hold_section_name = xstrdup (secname);
  if (!link_info.relocateable)
    {
      dollar = strchr (hold_section_name, '$');
      if (dollar != NULL)
	*dollar = '\0';
d682 1
d684 5
a688 158
  hold_use = NULL;
  lang_for_each_statement (gld${EMULATION_NAME}_place_section);

  if (hold_use == NULL)
    {
      lang_output_section_statement_type *place;
      char *outsecname;
      asection *snew, **pps;
      lang_statement_list_type *old;
      lang_statement_list_type add;
      etree_type *address;

      /* Try to put the new output section in a reasonable place based
	 on the section name and section flags.  */
      place = NULL;
      if ((s->flags & SEC_HAS_CONTENTS) == 0
	  && hold_bss != NULL)
	place = hold_bss;
      else if ((s->flags & SEC_READONLY) == 0
	       && hold_data != NULL)
	place = hold_data;
      else if ((s->flags & SEC_CODE) == 0
	       && (s->flags & SEC_READONLY) != 0
	       && hold_rdata != NULL)
	place = hold_rdata;
      else if ((s->flags & SEC_READONLY) != 0
	       && hold_text != NULL)
	place = hold_text;

      /* Choose a unique name for the section.  This will be needed if
	 the same section name appears in the input file with
	 different loadable or allocateable characteristics.  */
      outsecname = xstrdup (hold_section_name);
      if (bfd_get_section_by_name (output_bfd, outsecname) != NULL)
	{
	  unsigned int len;
	  char *newname;
	  unsigned int i;

	  len = strlen (outsecname);
	  newname = xmalloc (len + 5);
	  strcpy (newname, outsecname);
	  i = 0;
	  do
	    {
	      sprintf (newname + len, "%d", i);
	      ++i;
	    }
	  while (bfd_get_section_by_name (output_bfd, newname) != NULL);

	  free (outsecname);
	  outsecname = newname;
	}

      /* We don't want to free OUTSECNAME, as it may get attached to
	 the output section statement.  */

      /* Create the section in the output file, and put it in the
	 right place.  This shuffling is to make the output file look
	 neater.  */
      snew = bfd_make_section (output_bfd, outsecname);
      if (snew == NULL)
	einfo ("%P%F: output format %s cannot represent section called %s\n",
	       output_bfd->xvec->name, outsecname);
      if (place != NULL && place->bfd_section != NULL)
	{
	  for (pps = &output_bfd->sections; *pps != snew; pps = &(*pps)->next)
	    ;
	  *pps = snew->next;
	  snew->next = place->bfd_section->next;
	  place->bfd_section->next = snew;
	}

      /* Start building a list of statements for this section.  */
      old = stat_ptr;
      stat_ptr = &add;
      lang_list_init (stat_ptr);

      if (link_info.relocateable)
	address = NULL;
      else
	{
	  /* All sections in an executable must be aligned to a page
	     boundary.  */
	  address = exp_unop (ALIGN_K,
			      exp_nameop (NAME, "__section_alignment__"));
	}

      lang_enter_output_section_statement (outsecname, address, 0,
					   (bfd_vma) 0,
					   (etree_type *) NULL,
					   (etree_type *) NULL,
					   (etree_type *) NULL);

      hold_use = lang_output_section_statement_lookup (outsecname);

      lang_leave_output_section_statement
	((bfd_vma) 0, "*default*",
	 (struct lang_output_section_phdr_list *) NULL,
	"*default*");

      /* Now stick the new statement list right after PLACE.  */
      if (place != NULL)
	{
	  *add.tail = place->header.next;
	  place->header.next = add.head;
	}

      stat_ptr = old;
    }

  if (dollar == NULL)
    wild_doit (&hold_use->children, s, hold_use, file);
  else
    {
      lang_statement_union_type **pl;
      boolean found_dollar;
      lang_statement_list_type list;

      /* The section name has a '$'.  Sort it with the other '$'
         sections.  */

      found_dollar = false;
      for (pl = &hold_use->children.head; *pl != NULL; pl = &(*pl)->next)
	{
	  lang_input_section_type *ls;
	  const char *lname;

	  if ((*pl)->header.type != lang_input_section_enum)
	    continue;

	  ls = &(*pl)->input_section;

	  lname = bfd_get_section_name (ls->ifile->the_bfd, ls->section);
	  if (strchr (lname, '$') == NULL)
	    {
	      if (found_dollar)
		break;
	    }
	  else
	    {
	      found_dollar = true;
	      if (strcmp (secname, lname) < 0)
		break;
	    }
	}

      lang_list_init (&list);
      wild_doit (&list, s, hold_use, file);
      if (list.head != NULL)
	{
	  ASSERT (list.head->next == NULL);
	  list.head->next = *pl;
	  *pl = list.head;
	}
    }

  free (hold_section_name);
a691 35

static void
gld${EMULATION_NAME}_place_section (s)
     lang_statement_union_type *s;
{
  lang_output_section_statement_type *os;

  if (s->header.type != lang_output_section_statement_enum)
    return;

  os = &s->output_section_statement;

  if (strcmp (os->name, hold_section_name) == 0
      && os->bfd_section != NULL
      && ((hold_section->flags & (SEC_LOAD | SEC_ALLOC))
	  == (os->bfd_section->flags & (SEC_LOAD | SEC_ALLOC))))
    hold_use = os;

  if (strcmp (os->name, ".text") == 0)
    hold_text = os;
  else if (strcmp (os->name, ".rdata") == 0)
    hold_rdata = os;
  else if (strcmp (os->name, ".data") == 0)
    hold_data = os;
  else if (strcmp (os->name, ".bss") == 0)
    hold_bss = os;
}

static int
gld_${EMULATION_NAME}_find_potential_libraries (name, entry)
     char * name;
     lang_input_statement_type * entry;
{
  return ldfile_open_file_search (name, entry, "", ".lib");
}
d699 1
a699 1
sc="-f stringify.sed"
d727 1
a727 1
  gld_${EMULATION_NAME}_after_parse,
d736 1
a736 1
  gld_${EMULATION_NAME}_finish, /* finish */
d739 1
a739 1
  gld_${EMULATION_NAME}_place_orphan,
d741 1
a741 5
  gld_${EMULATION_NAME}_parse_args,
  gld_${EMULATION_NAME}_unrecognized_file,
  gld_${EMULATION_NAME}_list_options,
  gld_${EMULATION_NAME}_recognized_file,
  gld_${EMULATION_NAME}_find_potential_libraries
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d7 1
a7 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.
a39 1
#include "ldfile.h"
d44 1
d105 2
a109 2
static boolean gld_${EMULATION_NAME}_open_dynamic_archive 
  PARAMS ((const char *, search_dirs_type *, lang_input_statement_type *));
d117 1
d119 2
a120 5
static int pe_enable_stdcall_fixup = -1; /* 0=disable 1=enable */
static char *pe_out_def_filename = NULL;
static char *pe_implib_filename = NULL;
static int pe_enable_auto_image_base = 0;
static char *pe_dll_search_prefix = NULL;
a171 4
#define OPTION_ENABLE_AUTO_IMAGE_BASE	(OPTION_IMP_COMPAT + 1)
#define OPTION_DISABLE_AUTO_IMAGE_BASE	(OPTION_ENABLE_AUTO_IMAGE_BASE + 1)
#define OPTION_DLL_SEARCH_PREFIX	(OPTION_DISABLE_AUTO_IMAGE_BASE + 1)
#define OPTION_NO_DEFAULT_EXCLUDES	(OPTION_DLL_SEARCH_PREFIX + 1)
d173 2
a174 1
static struct option longopts[] = {
a205 4
  {"enable-auto-image-base", no_argument, NULL, OPTION_ENABLE_AUTO_IMAGE_BASE},
  {"disable-auto-image-base", no_argument, NULL, OPTION_DISABLE_AUTO_IMAGE_BASE},
  {"dll-search-prefix", required_argument, NULL, OPTION_DLL_SEARCH_PREFIX},
  {"no-default-excludes", no_argument, NULL, OPTION_NO_DEFAULT_EXCLUDES},
d245 1
a245 1
  D(SizeOfStackReserve,"__size_of_stack_reserve__", 0x200000),
a284 6
  fprintf (file, _("  --enable-auto-image-base           Automatically choose image base for DLLs\n"));
  fprintf (file, _("                                       unless user specifies one\n"));
  fprintf (file, _("  --disable-auto-image-base          Do not auto-choose image base. (default)\n"));
  fprintf (file, _("  --dll-search-prefix=<string>       When linking dynamically to a dll witout an\n"));
  fprintf (file, _("                                       importlib, use <string><basename>.dll \n"));
  fprintf (file, _("                                       in preference to lib<basename>.dll \n"));
a542 12
    case OPTION_ENABLE_AUTO_IMAGE_BASE:
      pe_enable_auto_image_base = 1;
      break;
    case OPTION_DISABLE_AUTO_IMAGE_BASE:
      pe_enable_auto_image_base = 0;
      break;
    case OPTION_DLL_SEARCH_PREFIX:
      pe_dll_search_prefix = xstrdup( optarg );
      break;
    case OPTION_NO_DEFAULT_EXCLUDES:
      pe_dll_do_default_excludes = 0;
      break;
a547 34

#ifdef DLL_SUPPORT
static unsigned long 
strhash (const char *str)
{
  const unsigned char *s;
  unsigned long hash;
  unsigned int c;
  unsigned int len;

  hash = 0;
  len = 0;
  s = (const unsigned char *) str;
  while ((c = *s++) != '\0')
    {
      hash += c + (c << 17);
      hash ^= hash >> 2;
      ++len;
    }
  hash += len + (len << 17);
  hash ^= hash >> 2;

  return hash;
}

/* Use the output file to create a image base for relocatable DLLs. */
static unsigned long
compute_dll_image_base (const char *ofile)
{
  unsigned long hash = strhash (ofile);
  return 0x60000000 | ((hash << 16) & 0x0FFC0000);
}
#endif

a563 4
#ifdef DLL_SUPPORT
	init[IMAGEBASEOFF].value = (pe_enable_auto_image_base) ?
	  compute_dll_image_base (output_filename) : NT_DLL_IMAGE_BASE;
#else
a564 1
#endif
a628 1
#ifdef DLL_SUPPORT
d647 1
a763 110
    /* This next chunk of code tries to detect the case where you have
       two import libraries for the same DLL (specifically,
       symbolically linking libm.a and libc.a in cygwin to
       libcygwin.a).  In those cases, it's possible for function
       thunks from the second implib to be used but without the
       head/tail objects, causing an improper import table.  We detect
       those cases and rename the "other" import libraries to match
       the one the head/tail come from, so that the linker will sort
       things nicely and produce a valid import table. */

    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	if (is->the_bfd->my_archive)
	  {
	    int idata2 = 0, reloc_count=0, is_imp = 0;
	    asection *sec;
	    
	    /* See if this is an import library thunk.  */
	    for (sec = is->the_bfd->sections; sec; sec = sec->next)
	      {
		if (strcmp (sec->name, ".idata\$2") == 0)
		  idata2 = 1;
		if (strncmp (sec->name, ".idata\$", 7) == 0)
		  is_imp = 1;
		reloc_count += sec->reloc_count;
	      }
	    
	    if (is_imp && !idata2 && reloc_count)
	      {
		/* It is, look for the reference to head and see if it's
		   from our own library.  */
		for (sec = is->the_bfd->sections; sec; sec = sec->next)
		  {
		    int i;
		    long symsize;
		    long relsize;
		    asymbol **symbols;
		    arelent **relocs;
		    int nrelocs;
		    
		    symsize = bfd_get_symtab_upper_bound (is->the_bfd);
		    if (symsize < 1)
		      break;
		    relsize = bfd_get_reloc_upper_bound (is->the_bfd, sec);
		    if (relsize < 1)
		      break;
		    
		    symbols = (asymbol **) xmalloc (symsize);
 		    symsize = bfd_canonicalize_symtab (is->the_bfd, symbols);
		    if (symsize < 0)
		      {
			einfo ("%X%P: unable to process symbols: %E");
			return;
		      }
		    
		    relocs = (arelent **) xmalloc ((size_t) relsize);
		    nrelocs = bfd_canonicalize_reloc (is->the_bfd, sec,
							  relocs, symbols);
		    if (nrelocs < 0)
		      {
			free (relocs);
			einfo ("%X%P: unable to process relocs: %E");
			return;
		      }
		    
		    for (i = 0; i < nrelocs; i++)
		      {
			struct symbol_cache_entry *s;
			struct bfd_link_hash_entry * blhe;
			bfd *other_bfd;
			char *n;
			
			s = (relocs[i]->sym_ptr_ptr)[0];
			
			if (s->flags & BSF_LOCAL)
			  continue;
			
			/* Thunk section with reloc to another bfd.  */
			blhe = bfd_link_hash_lookup (link_info.hash,
						     s->name,
						     false, false, true);
			    
			if (blhe == NULL
			    || blhe->type != bfd_link_hash_defined)
			  continue;
			
			other_bfd = blhe->u.def.section->owner;
			    
			if (strcmp (is->the_bfd->my_archive->filename,
				    other_bfd->my_archive->filename) == 0)
			  continue;
			
			/* Rename this implib to match the other.  */
			n = (char *) xmalloc (strlen (other_bfd->my_archive->filename) + 1);
			    
			strcpy (n, other_bfd->my_archive->filename);
			    
			is->the_bfd->my_archive->filename = n;
		      }

		    free (relocs);
		    /* Note - we do not free the symbols,
		       they are now cached in the BFD.  */
		  }
	      }
	  }
      }
  }

  {
d819 1
a819 1
		new_name = xmalloc (strlen (is->filename) + 3);
d873 1
a873 1
#ifdef DLL_SUPPORT
d876 1
a876 1

d886 1
a886 1
#endif /* DLL_SUPPORT */
a1051 1
  /* ARM doesn't need relocs.  */
d1060 1
a1060 1
#endif /* DLL_SUPPORT */
d1077 10
a1086 6
struct orphan_save
{
  lang_output_section_statement_type *os;
  asection **section;
  lang_statement_union_type **stmt;
};
a1094 1
  char *hold_section_name;
d1096 3
a1098 3
  const char *ps = NULL;
  lang_output_section_statement_type *os;
  lang_statement_list_type add_child;
d1104 2
d1114 2
a1115 3
  os = lang_output_section_find (hold_section_name);

  lang_list_init (&add_child);
d1117 1
a1117 7
  if (os != NULL
      && os->bfd_section != NULL
      && ((s->flags ^ os->bfd_section->flags) & (SEC_LOAD | SEC_ALLOC)) == 0)
    {
      wild_doit (&add_child, s, os, file);
    }
  else
d1119 1
a1119 5
      struct orphan_save *place;
      static struct orphan_save hold_text;
      static struct orphan_save hold_rdata;
      static struct orphan_save hold_data;
      static struct orphan_save hold_bss;
d1121 1
a1127 3
#define HAVE_SECTION(hold, name) \
(hold.os != NULL || (hold.os = lang_output_section_find (name)) != NULL)

d1129 3
a1131 5
      if ((s->flags & SEC_ALLOC) == 0)
	;
      else if ((s->flags & SEC_HAS_CONTENTS) == 0
	       && HAVE_SECTION (hold_bss, ".bss"))
	place = &hold_bss;
d1133 2
a1134 2
	       && HAVE_SECTION (hold_data, ".data"))
	place = &hold_data;
d1137 2
a1138 2
	       && HAVE_SECTION (hold_rdata, ".rdata"))
	place = &hold_rdata;
d1140 2
a1141 4
	       && HAVE_SECTION (hold_text, ".text"))
	place = &hold_text;

#undef HAVE_SECTION
d1168 19
d1192 2
a1193 22
      if (config.build_constructors)
	{
	  /* If the name of the section is representable in C, then create
	     symbols to mark the start and the end of the section.  */
	  for (ps = outsecname; *ps != '\0'; ps++)
	    if (! isalnum ((unsigned char) *ps) && *ps != '_')
	      break;
	  if (*ps == '\0')
	    {
	      char *symname;
	      etree_type *e_align;
	      
	      symname = (char *) xmalloc (ps - outsecname + sizeof "___start_");
	      sprintf (symname, "___start_%s", outsecname);
	      e_align = exp_unop (ALIGN_K,
				  exp_intop ((bfd_vma) 1 << s->alignment_power));
	      lang_add_assignment (exp_assop ('=', symname, e_align));
	    }
	}
      
      if (link_info.relocateable || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0)
	address = exp_intop ((bfd_vma) 0);
d1202 5
a1206 5
      os = lang_enter_output_section_statement (outsecname, address, 0,
						(bfd_vma) 0,
						(etree_type *) NULL,
						(etree_type *) NULL,
						(etree_type *) NULL);
d1208 1
a1208 1
      wild_doit (&add_child, s, os, file);
d1212 2
a1213 1
	 (struct lang_output_section_phdr_list *) NULL, "*default*");
d1215 5
a1219 13
      if (config.build_constructors && *ps == '\0')
        {
	  char *symname;

	  /* lang_leave_ouput_section_statement resets stat_ptr.  Put
	     stat_ptr back where we want it.  */
	  if (place != NULL)
	    stat_ptr = &add;
	  
	  symname = (char *) xmalloc (ps - outsecname + sizeof "___stop_");
	  sprintf (symname, "___stop_%s", outsecname);
	  lang_add_assignment (exp_assop ('=', symname,
					  exp_nameop (NAME, ".")));
d1223 9
d1233 5
a1237 1
      if (place != NULL)
d1239 2
a1240 1
	  asection *snew, **pps;
d1242 2
a1243 20
	  snew = os->bfd_section;
	  if (place->os->bfd_section != NULL || place->section != NULL)
	    {
	      /* Shuffle the section to make the output file look neater.  */
	      if (place->section == NULL)
		{
#if 0
		  /* Finding the end of the list is a little tricky.  We
		     make a wild stab at it by comparing section flags.  */
		  flagword first_flags = place->os->bfd_section->flags;
		  for (pps = &place->os->bfd_section->next;
		       *pps != NULL && (*pps)->flags == first_flags;
		       pps = &(*pps)->next)
		    ;
		  place->section = pps;
#else
		  /* Put orphans after the first section on the list.  */
		  place->section = &place->os->bfd_section->next;
#endif
		}
d1245 1
a1245 10
	      /*  Unlink the section.  */
	      for (pps = &output_bfd->sections; *pps != snew; pps = &(*pps)->next)
		;
	      *pps = snew->next;

	      /* Now tack it on to the "place->os" section list.  */
	      snew->next = *place->section;
	      *place->section = snew;
	    }
	  place->section = &snew->next;	/* Save the end of this list.  */
d1247 2
a1248 1
	  if (place->stmt == NULL)
d1250 2
a1251 3
	      /* Put the new statement list right at the head.  */
	      *add.tail = place->os->header.next;
	      place->os->header.next = add.head;
d1255 3
a1257 3
	      /* Put it after the last orphan statement we added.  */
	      *add.tail = *place->stmt;
	      *place->stmt = add.head;
d1259 9
a1267 1
	  place->stmt = add.tail;	/* Save the end of this list.  */
a1270 43
  {
    lang_statement_union_type **pl = &os->children.head;

    if (dollar != NULL)
      {
	boolean found_dollar;

	/* The section name has a '$'.  Sort it with the other '$'
	   sections.  */

	found_dollar = false;
	for ( ; *pl != NULL; pl = &(*pl)->next)
	  {
	    lang_input_section_type *ls;
	    const char *lname;

	    if ((*pl)->header.type != lang_input_section_enum)
	      continue;

	    ls = &(*pl)->input_section;

	    lname = bfd_get_section_name (ls->ifile->the_bfd, ls->section);
	    if (strchr (lname, '$') == NULL)
	      {
		if (found_dollar)
		  break;
	      }
	    else
	      {
		found_dollar = true;
		if (strcmp (secname, lname) < 0)
		  break;
	      }
	  }
      }

    if (add_child.head != NULL)
      {
	add_child.head->next = *pl;
	*pl = add_child.head;
      }
  }

d1276 3
a1278 5
static boolean
gld_${EMULATION_NAME}_open_dynamic_archive (arch, search, entry)
     const char * arch ATTRIBUTE_UNUSED;
     search_dirs_type * search;
     lang_input_statement_type * entry;
d1280 1
a1280 2
  const char * filename;
  char * string;
d1282 2
a1283 2
  if (! entry->is_archive)
    return false;
d1285 1
a1285 1
  filename = entry->filename;
d1287 14
a1300 77
  string = (char *) xmalloc (strlen (search->name)
                             + strlen (filename) 
                             + sizeof "/lib.a.dll"
#ifdef DLL_SUPPORT
                             + (pe_dll_search_prefix ? strlen (pe_dll_search_prefix) : 0)
#endif
                             + 1);

  /* Try "libfoo.dll.a" first (preferred explicit import library for dll's */
  sprintf (string, "%s/lib%s.dll.a", search->name, filename);

  if (! ldfile_try_open_bfd (string, entry))
    {
      /* Try "foo.dll.a" next (alternate explicit import library for dll's */
      sprintf (string, "%s/%s.dll.a", search->name, filename);
      if (! ldfile_try_open_bfd (string, entry))
        {
/*
   Try libfoo.a next. Normally, this would be interpreted as a static
   library, but it *could* be an import library. For backwards compatibility,
   libfoo.a needs to ==precede== libfoo.dll and foo.dll in the search,
   or sometimes errors occur when building legacy packages.

   Putting libfoo.a here means that in a failure case (i.e. the library
   -lfoo is not found) we will search for libfoo.a twice before
   giving up -- once here, and once when searching for a "static" lib.
   for a "static" lib.
*/
          /* Try "libfoo.a" (import lib, or static lib, but must
             take precedence over dll's) */
          sprintf (string, "%s/lib%s.a", search->name, filename);
          if (! ldfile_try_open_bfd (string, entry))
            {
#ifdef DLL_SUPPORT
              if (pe_dll_search_prefix)
                {  
                  /* Try "<prefix>foo.dll" (preferred dll name, if specified) */
                  sprintf (string, "%s/%s%s.dll", search->name, pe_dll_search_prefix, filename);
                  if (! ldfile_try_open_bfd (string, entry))
                    {
                      /* Try "libfoo.dll" (default preferred dll name) */
                      sprintf (string, "%s/lib%s.dll", search->name, filename);
                      if (! ldfile_try_open_bfd (string, entry))
                        {
                          /* Finally, try "foo.dll" (alternate dll name) */
                          sprintf (string, "%s/%s.dll", search->name, filename);
                          if (! ldfile_try_open_bfd (string, entry))
                            {
                              free (string);
                              return false;
                            }
                        }
                    }
                }
              else /* pe_dll_search_prefix not specified */
#endif		
                {
                  /* Try "libfoo.dll" (preferred dll name) */
                  sprintf (string, "%s/lib%s.dll", search->name, filename);
                  if (! ldfile_try_open_bfd (string, entry))
                    {
                      /* Finally, try "foo.dll" (alternate dll name) */
                      sprintf (string, "%s/%s.dll", search->name, filename);
                      if (! ldfile_try_open_bfd (string, entry))
                        {
                          free (string);
                          return false;
                        }
                    }
                }
            }
        }
    }

  entry->filename = string;

  return true;
d1356 1
a1356 1
  gld_${EMULATION_NAME}_open_dynamic_archive,
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@a2 5
if [ -z "$MACHINE" ]; then
  OUTPUT_ARCH=${ARCH}
else
  OUTPUT_ARCH=${ARCH}:${MACHINE}
fi
d7 1
a7 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d10 13
a22 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d29 2
a30 14
   the correct entry point by default. */

#define TARGET_IS_${EMULATION_NAME}

/* Do this before including bfd.h, so we prototype the right functions.  */
#ifdef TARGET_IS_arm_epoc_pe
#define bfd_arm_pe_allocate_interworking_sections \
	bfd_arm_epoc_pe_allocate_interworking_sections
#define bfd_arm_pe_get_bfd_for_interworking \
	bfd_arm_epoc_pe_get_bfd_for_interworking
#define bfd_arm_pe_process_before_allocation \
	bfd_arm_epoc_pe_process_before_allocation
#endif

d38 1
a42 1
#include <ldgram.h>
d55 1
a55 1
#include <ctype.h>
d90 9
d104 1
a104 3
static asection *output_prev_sec_find
  PARAMS ((lang_output_section_statement_type *));
static bfd_boolean gld_${EMULATION_NAME}_place_orphan
d107 1
d109 1
a109 1
static bfd_boolean gld_${EMULATION_NAME}_open_dynamic_archive
a110 25
static void gld${EMULATION_NAME}_add_options
  PARAMS ((int, char **, int, struct option **, int, struct option **));
static bfd_boolean gld${EMULATION_NAME}_handle_option PARAMS ((int));
static void gld_${EMULATION_NAME}_list_options PARAMS ((FILE *));
static void set_pe_name PARAMS ((char *, long));
static void set_pe_subsystem PARAMS ((void));
static void set_pe_value PARAMS ((char *));
static void set_pe_stack_heap PARAMS ((char *, char *));

#ifdef DLL_SUPPORT
static bfd_boolean pe_undef_cdecl_match
  PARAMS ((struct bfd_link_hash_entry *, PTR));
static void pe_fixup_stdcalls PARAMS ((void));
static int make_import_fixup PARAMS ((arelent *, asection *));
static void pe_find_data_imports PARAMS ((void));
#endif

static bfd_boolean pr_sym PARAMS ((struct bfd_hash_entry *, PTR));
static bfd_boolean gld_${EMULATION_NAME}_unrecognized_file
  PARAMS ((lang_input_statement_type *));
static bfd_boolean gld_${EMULATION_NAME}_recognized_file
  PARAMS ((lang_input_statement_type *));
static int gld_${EMULATION_NAME}_find_potential_libraries
  PARAMS ((char *, lang_input_statement_type *));

d119 1
a119 1
static int pe_enable_stdcall_fixup = -1; /* 0=disable 1=enable.  */
a130 9
  const bfd_arch_info_type *arch = bfd_scan_arch ("${OUTPUT_ARCH}");
  if (arch)
    {
      ldfile_output_architecture = arch->arch;
      ldfile_output_machine = arch->mach;
      ldfile_output_machine_name = arch->printable_name;
    }
  else
    ldfile_output_architecture = bfd_arch_${ARCH};
d132 1
a133 1
  config.dynamic_link = TRUE;
a134 2
  link_info.pei386_auto_import = -1;
  link_info.pei386_runtime_pseudo_reloc = FALSE;
d148 1
a148 1
/* Used for setting flags in the PE header.  */
a178 8
#define OPTION_DLL_ENABLE_AUTO_IMPORT	(OPTION_NO_DEFAULT_EXCLUDES + 1)
#define OPTION_DLL_DISABLE_AUTO_IMPORT	(OPTION_DLL_ENABLE_AUTO_IMPORT + 1)
#define OPTION_ENABLE_EXTRA_PE_DEBUG	(OPTION_DLL_DISABLE_AUTO_IMPORT + 1)
#define OPTION_EXCLUDE_LIBS		(OPTION_ENABLE_EXTRA_PE_DEBUG + 1)
#define OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC	\
					(OPTION_EXCLUDE_LIBS + 1)
#define OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC	\
					(OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC + 1)
d180 18
a197 27
static void
gld${EMULATION_NAME}_add_options (ns, shortopts, nl, longopts, nrl, really_longopts)
     int ns ATTRIBUTE_UNUSED;
     char **shortopts ATTRIBUTE_UNUSED;
     int nl;
     struct option **longopts;
     int nrl ATTRIBUTE_UNUSED;
     struct option **really_longopts ATTRIBUTE_UNUSED;
{
  static const struct option xtra_long[] = {
    /* PE options */
    {"base-file", required_argument, NULL, OPTION_BASE_FILE},
    {"dll", no_argument, NULL, OPTION_DLL},
    {"file-alignment", required_argument, NULL, OPTION_FILE_ALIGNMENT},
    {"heap", required_argument, NULL, OPTION_HEAP},
    {"image-base", required_argument, NULL, OPTION_IMAGE_BASE},
    {"major-image-version", required_argument, NULL, OPTION_MAJOR_IMAGE_VERSION},
    {"major-os-version", required_argument, NULL, OPTION_MAJOR_OS_VERSION},
    {"major-subsystem-version", required_argument, NULL, OPTION_MAJOR_SUBSYSTEM_VERSION},
    {"minor-image-version", required_argument, NULL, OPTION_MINOR_IMAGE_VERSION},
    {"minor-os-version", required_argument, NULL, OPTION_MINOR_OS_VERSION},
    {"minor-subsystem-version", required_argument, NULL, OPTION_MINOR_SUBSYSTEM_VERSION},
    {"section-alignment", required_argument, NULL, OPTION_SECTION_ALIGNMENT},
    {"stack", required_argument, NULL, OPTION_STACK},
    {"subsystem", required_argument, NULL, OPTION_SUBSYSTEM},
    {"support-old-code", no_argument, NULL, OPTION_SUPPORT_OLD_CODE},
    {"thumb-entry", required_argument, NULL, OPTION_THUMB_ENTRY},
d199 21
a219 34
    /* getopt allows abbreviations, so we do this to stop it from treating -o
       as an abbreviation for this option */
    {"output-def", required_argument, NULL, OPTION_OUT_DEF},
    {"output-def", required_argument, NULL, OPTION_OUT_DEF},
    {"export-all-symbols", no_argument, NULL, OPTION_EXPORT_ALL},
    {"exclude-symbols", required_argument, NULL, OPTION_EXCLUDE_SYMBOLS},
    {"exclude-libs", required_argument, NULL, OPTION_EXCLUDE_LIBS},
    {"kill-at", no_argument, NULL, OPTION_KILL_ATS},
    {"add-stdcall-alias", no_argument, NULL, OPTION_STDCALL_ALIASES},
    {"enable-stdcall-fixup", no_argument, NULL, OPTION_ENABLE_STDCALL_FIXUP},
    {"disable-stdcall-fixup", no_argument, NULL, OPTION_DISABLE_STDCALL_FIXUP},
    {"out-implib", required_argument, NULL, OPTION_IMPLIB_FILENAME},
    {"warn-duplicate-exports", no_argument, NULL, OPTION_WARN_DUPLICATE_EXPORTS},
    /* getopt() allows abbreviations, so we do this to stop it from
       treating -c as an abbreviation for these --compat-implib.  */
    {"compat-implib", no_argument, NULL, OPTION_IMP_COMPAT},
    {"compat-implib", no_argument, NULL, OPTION_IMP_COMPAT},
    {"enable-auto-image-base", no_argument, NULL, OPTION_ENABLE_AUTO_IMAGE_BASE},
    {"disable-auto-image-base", no_argument, NULL, OPTION_DISABLE_AUTO_IMAGE_BASE},
    {"dll-search-prefix", required_argument, NULL, OPTION_DLL_SEARCH_PREFIX},
    {"no-default-excludes", no_argument, NULL, OPTION_NO_DEFAULT_EXCLUDES},
    {"enable-auto-import", no_argument, NULL, OPTION_DLL_ENABLE_AUTO_IMPORT},
    {"disable-auto-import", no_argument, NULL, OPTION_DLL_DISABLE_AUTO_IMPORT},
    {"enable-extra-pe-debug", no_argument, NULL, OPTION_ENABLE_EXTRA_PE_DEBUG},
    {"enable-runtime-pseudo-reloc", no_argument, NULL, OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC},
    {"disable-runtime-pseudo-reloc", no_argument, NULL, OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC},
#endif
    {NULL, no_argument, NULL, 0}
  };

  *longopts = (struct option *)
    xrealloc (*longopts, nl * sizeof (struct option) + sizeof (xtra_long));
  memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));
}
d222 1
a222 1
   parameters which may be input from the command line.  */
a262 1

a287 1
  fprintf (file, _("  --exclude-libs lib,lib,...         Exclude libraries from automatic export\n"));
d293 4
a296 4
  fprintf (file, _("  --compat-implib                    Create backward compatible import libs;\n\
                                       create __imp_<SYMBOL> as well.\n"));
  fprintf (file, _("  --enable-auto-image-base           Automatically choose image base for DLLs\n\
                                       unless user specifies one\n"));
d298 3
a300 13
  fprintf (file, _("  --dll-search-prefix=<string>       When linking dynamically to a dll without\n\
                                       an importlib, use <string><basename>.dll\n\
                                       in preference to lib<basename>.dll \n"));
  fprintf (file, _("  --enable-auto-import               Do sophistcated linking of _sym to\n\
                                       __imp_sym for DATA references\n"));
  fprintf (file, _("  --disable-auto-import              Do not auto-import DATA items from DLLs\n"));
  fprintf (file, _("  --enable-runtime-pseudo-reloc      Work around auto-import limitations by\n\
                                       adding pseudo-relocations resolved at\n\
                                       runtime.\n"));
  fprintf (file, _("  --disable-runtime-pseudo-reloc     Do not add runtime pseudo-relocations for\n\
                                       auto-imported DATA.\n"));
  fprintf (file, _("  --enable-extra-pe-debug            Enable verbose debug output when building\n\
                                       or linking to DLLs (esp. auto-import)\n"));
a303 1

d310 1
a310 2

  /* Find the name and set it.  */
d320 1
a320 1
  abort ();
d330 1
a330 1
  static const struct
d398 1
a398 1
	  lang_add_entry (entry, 0);
d403 1
a403 1

d408 1
d412 1
a412 1

d415 1
a415 1

d417 1
a417 1

a423 1

d430 1
a430 1

d441 22
a462 4
static bfd_boolean
gld${EMULATION_NAME}_handle_option (optc)
     int optc;
{
d466 4
a469 1
      return FALSE;
d482 2
a483 2
      /* PE options.  */
    case OPTION_HEAP:
d486 1
a486 1
    case OPTION_STACK:
d536 1
a536 4
      pe_dll_add_excludes (optarg, 0);
      break;
    case OPTION_EXCLUDE_LIBS:
      pe_dll_add_excludes (optarg, 1);
d566 1
a566 1
      pe_dll_search_prefix = xstrdup (optarg);
a570 15
    case OPTION_DLL_ENABLE_AUTO_IMPORT:
      link_info.pei386_auto_import = 1;
      break;
    case OPTION_DLL_DISABLE_AUTO_IMPORT:
      link_info.pei386_auto_import = 0;
      break;
    case OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC:
      link_info.pei386_runtime_pseudo_reloc = 1;
      break;
    case OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC:
      link_info.pei386_runtime_pseudo_reloc = 0;
      break;
    case OPTION_ENABLE_EXTRA_PE_DEBUG:
      pe_dll_extra_pe_debug = 1;
      break;
d573 1
a573 1
  return TRUE;
d578 1
a578 1
static unsigned long
d601 1
a601 2
/* Use the output file to create a image base for relocatable DLLs.  */

d617 1
a617 1
     names and insert the defaults.  */
d640 1
a640 1
  /* Glue the assignments into the abs section.  */
d649 7
a655 8
      rv = lang_add_assignment (exp_assop ('=', init[j].symbol,
					   exp_intop (val)));
      if (init[j].size == sizeof (short))
	*(short *) init[j].ptr = val;
      else if (init[j].size == sizeof (int))
	*(int *) init[j].ptr = val;
      else if (init[j].size == sizeof (long))
	*(long *) init[j].ptr = val;
d657 3
a659 3
      else if (init[j].size == sizeof (bfd_vma))
	*(bfd_vma *) init[j].ptr = val;
      else	abort ();
d663 1
a663 1
  /* Restore the pointer.  */
d665 1
a665 1

d692 2
a693 2
  if (! link_info.relocateable && entry_symbol.name != NULL)
    ldlang_add_undef (entry_symbol.name);
a695 7
/* pe-dll.c directly accesses pe_data_import_dll,
   so it must be defined outside of #ifdef DLL_SUPPORT.
   Note - this variable is deliberately not initialised.
   This allows it to be treated as a common varaible, and only
   exist in one incarnation in a multiple target enabled linker.  */
char * pe_data_import_dll;

d699 1
a699 1
static bfd_boolean
d704 1
a704 3
  int sl;

  sl = strlen (string); /* Silence compiler warning.  */
d708 5
a712 5
    {
      pe_undef_found_sym = h;
      return FALSE;
    }
  return TRUE;
d720 1
a720 4

  if (pe_dll_extra_pe_debug)
    printf ("%s\n", __FUNCTION__);

d723 3
d727 23
a749 59
	char* at = strchr (undef->root.string, '@@');
	int lead_at = (*undef->root.string == '@@');
	/* For now, don't try to fixup fastcall symbols.  */

	if (at && !lead_at)
	  {
	    /* The symbol is a stdcall symbol, so let's look for a
	       cdecl symbol with the same name and resolve to that.  */
	    char *cname = xstrdup (undef->root.string /* + lead_at */);
	    at = strchr (cname, '@@');
	    *at = 0;
	    sym = bfd_link_hash_lookup (link_info.hash, cname, 0, 0, 1);

	    if (sym && sym->type == bfd_link_hash_defined)
	      {
		undef->type = bfd_link_hash_defined;
		undef->u.def.value = sym->u.def.value;
		undef->u.def.section = sym->u.def.section;

		if (pe_enable_stdcall_fixup == -1)
		  {
		    einfo (_("Warning: resolving %s by linking to %s\n"),
			   undef->root.string, cname);
		    if (! gave_warning_message)
		      {
			gave_warning_message = 1;
			einfo (_("Use --enable-stdcall-fixup to disable these warnings\n"));
			einfo (_("Use --disable-stdcall-fixup to disable these fixups\n"));
		      }
		  }
	      }
	  }
	else
	  {
	    /* The symbol is a cdecl symbol, so we look for stdcall
	       symbols - which means scanning the whole symbol table.  */
	    pe_undef_found_sym = 0;
	    bfd_link_hash_traverse (link_info.hash, pe_undef_cdecl_match,
				    (PTR) undef->root.string);
	    sym = pe_undef_found_sym;
	    if (sym)
	      {
		undef->type = bfd_link_hash_defined;
		undef->u.def.value = sym->u.def.value;
		undef->u.def.section = sym->u.def.section;

		if (pe_enable_stdcall_fixup == -1)
		  {
		    einfo (_("Warning: resolving %s by linking to %s\n"),
			   undef->root.string, sym->root.string);
		    if (! gave_warning_message)
		      {
			gave_warning_message = 1;
			einfo (_("Use --enable-stdcall-fixup to disable these warnings\n"));
			einfo (_("Use --disable-stdcall-fixup to disable these fixups\n"));
		      }
		  }
	      }
	  }
d751 18
a768 60
}

static int
make_import_fixup (rel, s)
  arelent *rel;
  asection *s;
{
  struct symbol_cache_entry *sym = *rel->sym_ptr_ptr;
  int addend = 0;

  if (pe_dll_extra_pe_debug)
    printf ("arelent: %s@@%#lx: add=%li\n", sym->name,
	    (long) rel->address, (long) rel->addend);

  if (! bfd_get_section_contents (s->owner, s, &addend, rel->address, sizeof (addend)))
    einfo (_("%C: Cannot get section contents - auto-import exception\n"),
	   s->owner, s, rel->address);

  pe_create_import_fixup (rel, s, addend);

  return 1;
}

static void
pe_find_data_imports ()
{
  struct bfd_link_hash_entry *undef, *sym;

  if (link_info.pei386_auto_import == 0)
    return;

  for (undef = link_info.hash->undefs; undef; undef=undef->next)
    {
      if (undef->type == bfd_link_hash_undefined)
        {
          /* C++ symbols are *long*.  */
          char buf[4096];

	  if (pe_dll_extra_pe_debug)
	    printf ("%s:%s\n", __FUNCTION__, undef->root.string);

          sprintf (buf, "__imp_%s", undef->root.string);

          sym = bfd_link_hash_lookup (link_info.hash, buf, 0, 0, 1);

          if (sym && sym->type == bfd_link_hash_defined)
            {
	      bfd *b = sym->u.def.section->owner;
	      asymbol **symbols;
	      int nsyms, symsize, i;

	      if (link_info.pei386_auto_import == -1)
		info_msg (_("Info: resolving %s by linking to %s (auto-import)\n"),
			  undef->root.string, buf);

	      symsize = bfd_get_symtab_upper_bound (b);
	      symbols = (asymbol **) xmalloc (symsize);
	      nsyms = bfd_canonicalize_symtab (b, symbols);

	      for (i = 0; i < nsyms; i++)
d770 3
a772 10
		  if (memcmp (symbols[i]->name, "__head_",
			      sizeof ("__head_") - 1))
		    continue;

		  if (pe_dll_extra_pe_debug)
		    printf ("->%s\n", symbols[i]->name);

		  pe_data_import_dll = (char*) (symbols[i]->name +
						sizeof ("__head_") - 1);
		  break;
d774 3
a776 14

	      pe_walk_relocs_of_symbol (&link_info, undef->root.string,
					make_import_fixup);

	      /* Let's differentiate it somehow from defined.  */
	      undef->type = bfd_link_hash_defweak;
	      /* We replace original name with __imp_ prefixed, this
		 1) may trash memory 2) leads to duplicate symbol generation.
		 Still, IMHO it's better than having name poluted.  */
	      undef->root.string = sym->root.string;
	      undef->u.def.value = sym->u.def.value;
	      undef->u.def.section = sym->u.def.section;
            }
        }
a780 12
static bfd_boolean
pr_sym (h, string)
  struct bfd_hash_entry *h;
  PTR string ATTRIBUTE_UNUSED;
{
  if (pe_dll_extra_pe_debug)
    printf ("+%s\n",h->string);

  return TRUE;
}


a783 15
  if (pe_dll_extra_pe_debug)
    {
      bfd *a;
      struct bfd_link_hash_entry *sym;

      printf ("%s()\n", __FUNCTION__);

      for (sym = link_info.hash->undefs; sym; sym=sym->next)
        printf ("-%s\n", sym->root.string);
      bfd_hash_traverse (&link_info.hash->table, pr_sym,NULL);

      for (a = link_info.input_bfds; a; a = a->link_next)
	printf ("*%s\n",a->filename);
    }

d787 2
a788 2

  if (coff_data (output_bfd) == NULL || coff_data (output_bfd)->pe == 0)
d798 1
a798 5
  pe_process_import_defs (output_bfd, & link_info);

  pe_find_data_imports ();

#if ! (defined (TARGET_IS_i386pe) || defined (TARGET_IS_armpe))
a799 3
#else
  if (!link_info.relocateable)
#endif
d839 1
a839 1
       things nicely and produce a valid import table.  */
d847 1
a847 1

d857 1
a857 1

d870 1
a870 1

d877 1
a877 1

d879 1
a879 1
		    symsize = bfd_canonicalize_symtab (is->the_bfd, symbols);
d885 1
a885 1

d895 1
a895 1

d902 1
a902 1

d904 1
a904 1

d907 1
a907 1

d911 2
a912 2
						     FALSE, FALSE, TRUE);

d916 1
a916 1

d918 1
a918 1

d922 1
a922 1

d925 1
a925 1

d927 1
a927 1

d1005 2
a1006 2
static void
gld_${EMULATION_NAME}_before_allocation ()
d1009 1
a1009 1
  /* Here we rummage through the found bfds to collect toc information.  */
d1021 1
a1021 1
  /* We have seen it all. Allocate it, and carry on.  */
d1031 1
a1031 1
     option?  krk@@cygnus.com.  */
d1045 1
a1045 1
  /* We have seen it all. Allocate it, and carry on.  */
d1052 1
a1052 1
   check here for .DEF files and pull them in automatically.  */
d1055 1
a1055 1
saw_option (char * option)
d1058 1
a1058 2

  for (i = 0; init[i].ptr; i++)
d1065 2
a1066 2
static bfd_boolean
gld_${EMULATION_NAME}_unrecognized_file (entry)
d1073 16
a1088 7
    {
      if (pe_def_file == 0)
	pe_def_file = def_file_empty ();

      def_file_parse (entry->filename, pe_def_file);

      if (pe_def_file)
d1090 2
a1091 2
	  int i, buflen=0, len;
	  char *buf;
d1093 4
a1096 1
	  for (i = 0; i < pe_def_file->num_exports; i++)
d1098 3
a1100 3
	      len = strlen (pe_def_file->exports[i].internal_name);
	      if (buflen < len + 2)
		buflen = len + 2;
d1102 2
d1105 3
a1107 1
	  buf = (char *) xmalloc (buflen);
d1109 10
a1118 32
	  for (i = 0; i < pe_def_file->num_exports; i++)
	    {
	      struct bfd_link_hash_entry *h;

	      sprintf (buf, "_%s", pe_def_file->exports[i].internal_name);

	      h = bfd_link_hash_lookup (link_info.hash, buf, TRUE, TRUE, TRUE);
	      if (h == (struct bfd_link_hash_entry *) NULL)
		einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
	      if (h->type == bfd_link_hash_new)
		{
		  h->type = bfd_link_hash_undefined;
		  h->u.undef.abfd = NULL;
		  bfd_link_add_undef (link_info.hash, h);
		}
	    }
	  free (buf);

	  /* def_file_print (stdout, pe_def_file); */
	  if (pe_def_file->is_dll == 1)
	    link_info.shared = 1;

	  if (pe_def_file->base_address != (bfd_vma)(-1))
	    {
	      pe.ImageBase =
		pe_data (output_bfd)->pe_opthdr.ImageBase =
		init[IMAGEBASEOFF].value = pe_def_file->base_address;
	      init[IMAGEBASEOFF].inited = 1;
	      if (image_base_statement)
		image_base_statement->exp =
		  exp_assop ('=', "__image_base__", exp_intop (pe.ImageBase));
	    }
d1121 6
a1126 6
	  /* Not sure if these *should* be set.  */
	  if (pe_def_file->version_major != -1)
	    {
	      pe.MajorImageVersion = pe_def_file->version_major;
	      pe.MinorImageVersion = pe_def_file->version_minor;
	    }
d1128 15
a1142 16
	  if (pe_def_file->stack_reserve != -1
	      && ! saw_option ("__size_of_stack_reserve__"))
	    {
	      pe.SizeOfStackReserve = pe_def_file->stack_reserve;
	      if (pe_def_file->stack_commit != -1)
		pe.SizeOfStackCommit = pe_def_file->stack_commit;
	    }
	  if (pe_def_file->heap_reserve != -1
	      && ! saw_option ("__size_of_heap_reserve__"))
	    {
	      pe.SizeOfHeapReserve = pe_def_file->heap_reserve;
	      if (pe_def_file->heap_commit != -1)
		pe.SizeOfHeapCommit = pe_def_file->heap_commit;
	    }
	  return TRUE;
	}
d1144 1
d1146 2
a1147 1
  return FALSE;
d1150 2
a1151 2
static bfd_boolean
gld_${EMULATION_NAME}_recognized_file (entry)
d1169 1
a1169 8
      char fbuf[LD_PATHMAX + 1];
      const char *ext;

      if (REALPATH (entry->filename, fbuf) == NULL)
	strncpy (fbuf, entry->filename, sizeof (fbuf));

      ext = fbuf + strlen (fbuf) - 4;

d1171 1
a1171 1
	return pe_implied_import_dll (fbuf);
d1174 1
a1174 1
  return FALSE;
d1185 2
a1186 3
      h = bfd_link_hash_lookup (link_info.hash, thumb_entry_symbol,
				FALSE, FALSE, TRUE);

d1194 1
a1194 1

d1201 1
a1201 1

d1203 1
a1203 1

d1208 1
a1208 1

d1210 2
a1211 2

	  if (entry_symbol.name != NULL && entry_from_cmdline)
d1213 2
a1214 2
		   thumb_entry_symbol, entry_symbol.name);
	  entry_symbol.name = buffer;
d1222 1
a1222 5
  if (link_info.shared
#if !defined(TARGET_IS_shpe) && !defined(TARGET_IS_mipspe)
    || (!link_info.relocateable && pe_def_file->num_exports != 0)
#endif
    )
d1235 1
a1235 1

a1238 11

  /* I don't know where .idata gets set as code, but it shouldn't be.  */
  {
    asection *asec = bfd_get_section_by_name (output_bfd, ".idata");

    if (asec)
      {
        asec->flags &= ~SEC_CODE;
        asec->flags |= SEC_DATA;
      }
  }
a1241 26
/* Find the last output section before given output statement.
   Used by place_orphan.  */

static asection *
output_prev_sec_find (os)
     lang_output_section_statement_type *os;
{
  asection *s = (asection *) NULL;
  lang_statement_union_type *u;
  lang_output_section_statement_type *lookup;

  for (u = lang_output_section_statement.head;
       u != (lang_statement_union_type *) NULL;
       u = lookup->next)
    {
      lookup = &u->output_section_statement;
      if (lookup == os)
	return s;

      if (lookup->bfd_section != NULL && lookup->bfd_section->owner != NULL)
	s = lookup->bfd_section;
    }

  return NULL;
}

d1262 2
a1263 1
static bfd_boolean
d1278 1
d1292 4
a1295 7
      && (os->bfd_section == NULL
	  || ((s->flags ^ os->bfd_section->flags)
	      & (SEC_LOAD | SEC_ALLOC)) == 0))
    {
      /* We already have an output section statement with this
	 name, and its bfd section, if any, has compatible flags.  */
      lang_add_section (&add_child, s, os, file);
d1335 1
a1335 1
	 different loadable or allocatable characteristics.  */
d1374 1
a1374 1

d1382 1
a1382 1

d1399 1
a1399 1
      lang_add_section (&add_child, s, os, file);
d1403 1
a1403 1
	 (struct lang_output_section_phdr_list *) NULL, NULL);
d1409 2
a1410 2
	  /* lang_leave_ouput_section_statement resets stat_ptr.
	     Put stat_ptr back where we want it.  */
d1413 1
a1413 1

d1422 1
a1422 1
      if (place != NULL && os->bfd_section != NULL)
d1427 1
a1427 4

	  /* Shuffle the bfd section list to make the output file look
	     neater.  This is really only cosmetic.  */
	  if (place->section == NULL)
d1429 17
a1445 1
	      asection *bfd_section = place->os->bfd_section;
d1447 4
a1450 6
	      /* If the output statement hasn't been used to place
		 any input sections (and thus doesn't have an output
		 bfd_section), look for the closest prior output statement
		 having an output section.  */
	      if (bfd_section == NULL)
		bfd_section = output_prev_sec_find (place->os);
d1452 3
a1454 2
	      if (bfd_section != NULL && bfd_section != snew)
		place->section = &bfd_section->next;
d1456 1
d1458 1
a1458 1
	  if (place->section != NULL)
d1460 3
a1462 9
	      /* Unlink the section.  */
	      for (pps = &output_bfd->sections;
		   *pps != snew;
		   pps = &(*pps)->next)
		;
	      bfd_section_list_remove (output_bfd, pps);

	      /* Now tack it on to the "place->os" section list.  */
	      bfd_section_list_insert (output_bfd, place->section, snew);
d1464 1
a1464 15

	  /* Save the end of this list.  Further ophans of this type will
	     follow the one we've just added.  */
	  place->section = &snew->next;

	  /* The following is non-cosmetic.  We try to put the output
	     statements in some sort of reasonable order here, because
	     they determine the final load addresses of the orphan
	     sections.  In addition, placing output statements in the
	     wrong order may require extra segments.  For instance,
	     given a typical situation of all read-only sections placed
	     in one segment and following that a segment containing all
	     the read-write sections, we wouldn't want to place an orphan
	     read/write section before or amongst the read-only ones.  */
	  if (add.head != NULL)
d1466 3
a1468 20
	      if (place->stmt == NULL)
		{
		  /* Put the new statement list right at the head.  */
		  *add.tail = place->os->header.next;
		  place->os->header.next = add.head;
		}
	      else
		{
		  /* Put it after the last orphan statement we added.  */
		  *add.tail = *place->stmt;
		  *place->stmt = add.head;
		}

	      /* Fix the global list pointer if we happened to tack our
		 new list at the tail.  */
	      if (*old->tail == add.head)
		old->tail = add.tail;

	      /* Save the end of this list.  */
	      place->stmt = add.tail;
d1470 1
d1479 1
a1479 1
	bfd_boolean found_dollar;
d1483 3
a1485 2
	found_dollar = FALSE;
	for ( ; *pl != NULL; pl = &(*pl)->header.next)
d1503 1
a1503 1
		found_dollar = TRUE;
d1512 1
a1512 1
	add_child.head->header.next = *pl;
d1519 1
a1519 1
  return TRUE;
d1522 1
a1522 1
static bfd_boolean
d1532 1
a1532 1
    return FALSE;
d1537 1
a1537 1
                             + strlen (filename)
d1544 1
a1544 1
  /* Try "libfoo.dll.a" first (preferred explicit import library for dll's.  */
d1549 1
a1549 1
      /* Try "foo.dll.a" next (alternate explicit import library for dll's.  */
d1553 11
a1563 9
	  /* Try libfoo.a next. Normally, this would be interpreted as a static
	     library, but it *could* be an import library. For backwards compatibility,
	     libfoo.a needs to ==precede== libfoo.dll and foo.dll in the search,
	     or sometimes errors occur when building legacy packages.

	     Putting libfoo.a here means that in a failure case (i.e. the library
	     -lfoo is not found) we will search for libfoo.a twice before
	     giving up -- once here, and once when searching for a "static" lib.
	     for a "static" lib.  */
d1565 1
a1565 1
             take precedence over dll's).  */
d1571 2
a1572 2
                {
                  /* Try "<prefix>foo.dll" (preferred dll name, if specified).  */
d1576 1
a1576 1
                      /* Try "libfoo.dll" (default preferred dll name).  */
d1580 1
a1580 1
                          /* Finally, try "foo.dll" (alternate dll name).  */
d1585 1
a1585 1
                              return FALSE;
d1590 2
a1591 2
              else /* pe_dll_search_prefix not specified.  */
#endif
d1593 1
a1593 1
                  /* Try "libfoo.dll" (preferred dll name).  */
d1597 1
a1597 1
                      /* Finally, try "foo.dll" (alternate dll name).  */
d1602 1
a1602 1
                          return FALSE;
d1612 1
a1612 1
  return TRUE;
d1624 1
a1624 1
gld_${EMULATION_NAME}_get_script (isfile)
d1632 1
a1632 1
{
d1635 1
a1635 1
  if (link_info.relocateable && config.build_constructors)
d1638 10
a1647 10
sed $sc ldscripts/${EMULATION_NAME}.xu                 >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocateable) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                 >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                 >> e${EMULATION_NAME}.c
echo '  ; else return'                                 >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                  >> e${EMULATION_NAME}.c
echo '; }'                                             >> e${EMULATION_NAME}.c
d1652 1
a1652 1
struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
d1666 2
a1667 2
  gld_${EMULATION_NAME}_finish,
  NULL, /* Create output section statements.  */
d1671 1
a1671 3
  NULL, /* parse_args */
  gld${EMULATION_NAME}_add_options,
  gld${EMULATION_NAME}_handle_option,
d1675 1
a1675 2
  gld_${EMULATION_NAME}_find_potential_libraries,
  NULL	/* new_vers_pattern.  */
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d12 1
a12 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d71 2
a72 1
#include "safe-ctype.h"
d107 38
d163 1
a163 1
gld_${EMULATION_NAME}_before_parse (void)
d165 9
a173 1
  ldfile_set_output_arch ("${OUTPUT_ARCH}", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);
d183 1
a183 1
  lang_add_entry ("WinMainCRTStartup", FALSE);
d185 1
a185 1
  lang_add_entry ("_WinMainCRTStartup", FALSE);
d205 2
a206 2
#define OPTION_STACK			(OPTION_SECTION_ALIGNMENT + 1)
#define OPTION_SUBSYSTEM		(OPTION_STACK + 1)
d234 7
a240 4
gld${EMULATION_NAME}_add_options
  (int ns ATTRIBUTE_UNUSED, char **shortopts ATTRIBUTE_UNUSED, int nl,
    struct option **longopts, int nrl ATTRIBUTE_UNUSED,
    struct option **really_longopts ATTRIBUTE_UNUSED)
d340 2
a341 1
gld_${EMULATION_NAME}_list_options (FILE *file)
d393 3
a395 1
set_pe_name (char *name, long val)
d414 1
a414 1
set_pe_subsystem (void)
d487 1
a487 1
	  lang_add_entry (entry, TRUE);
d498 3
a500 1
set_pe_value (char *name)
d514 3
a516 1
set_pe_stack_heap (char *resname, char *comname)
d531 2
a532 1
gld${EMULATION_NAME}_handle_option (int optc)
d540 1
a540 1
      link_info.base_file = fopen (optarg, FOPEN_WB);
d701 1
a701 1
gld_${EMULATION_NAME}_set_symbols (void)
d710 1
a710 1
      if (link_info.relocatable)
d723 2
a724 2
  /* Don't do any symbol assignments if this is a relocatable link.  */
  if (link_info.relocatable)
d765 1
a765 1
gld_${EMULATION_NAME}_after_parse (void)
d780 1
a780 1
  if (! link_info.relocatable && entry_symbol.name != NULL)
d795 3
a797 1
pe_undef_cdecl_match (struct bfd_link_hash_entry *h, void *inf)
a799 1
  char *string = inf;
d801 1
a801 1
  sl = strlen (string);
d813 1
a813 1
pe_fixup_stdcalls (void)
d821 1
a821 1
  for (undef = link_info.hash->undefs; undef; undef=undef->und_next)
d862 1
a862 1
				    (char *) undef->root.string);
d887 3
a889 1
make_import_fixup (arelent *rel, asection *s)
d891 1
a891 1
  struct bfd_symbol *sym = *rel->sym_ptr_ptr;
d908 1
a908 1
pe_find_data_imports (void)
d915 1
a915 1
  for (undef = link_info.hash->undefs; undef; undef=undef->und_next)
d972 1
d975 3
a977 1
pr_sym (struct bfd_hash_entry *h, void *inf ATTRIBUTE_UNUSED)
d980 1
a980 1
    printf ("+%s\n", h->string);
a983 1
#endif /* DLL_SUPPORT */
d987 1
a987 1
gld_${EMULATION_NAME}_after_open (void)
a988 1
#ifdef DLL_SUPPORT
d996 1
a996 1
      for (sym = link_info.hash->undefs; sym; sym=sym->und_next)
d998 1
a998 1
      bfd_hash_traverse (&link_info.hash->table, pr_sym, NULL);
a1002 1
#endif
d1025 1
a1025 1
  if (!link_info.relocatable)
d1125 1
a1125 1
			struct bfd_symbol *s;
a1170 1
    lang_input_statement_type *is3;
a1184 1
	    char *pnt;
a1185 1

d1190 3
a1192 17

		for (is3 = is;
		     is3 && is3->the_bfd->my_archive == arch;
		     is3 = (lang_input_statement_type *) is3->next)
		  {
                    /* A MS dynamic import library can also contain static
		       members, so look for the first element with a .dll
		       extension, and use that for the remainder of the
		       comparisons.  */
		    pnt = strrchr (is3->the_bfd->filename, '.');
		    if (pnt != NULL && strcmp (pnt, ".dll") == 0)
		      break;
		  }

		if (is3 == NULL)
		  is_ms_arch = 0;
		else
d1194 2
a1195 19
		    /* OK, found one.  Now look to see if the remaining
		       (dynamic import) members use the same name.  */
		    for (is2 = is;
			 is2 && is2->the_bfd->my_archive == arch;
			 is2 = (lang_input_statement_type *) is2->next)
		      {
			/* Skip static members, ie anything with a .obj
			   extension.  */
			pnt = strrchr (is2->the_bfd->filename, '.');
			if (pnt != NULL && strcmp (pnt, ".obj") == 0)
			  continue;

			if (strcmp (is3->the_bfd->filename,
				    is2->the_bfd->filename))
			  {
			    is_ms_arch = 0;
			    break;
			  }
		      }
d1199 1
a1199 6
	    /* This fragment might have come from an .obj file in a Microsoft
	       import, and not an actual import record. If this is the case,
	       then leave the filename alone.  */
	    pnt = strrchr (is->the_bfd->filename, '.');

	    if (is_ms_arch && (strcmp (pnt, ".dll") == 0))
d1233 1
a1233 1
gld_${EMULATION_NAME}_before_allocation (void)
d1282 1
a1282 1
saw_option (char *option)
d1294 2
a1295 1
gld_${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry ATTRIBUTE_UNUSED)
d1384 2
a1385 1
gld_${EMULATION_NAME}_recognized_file (lang_input_statement_type *entry ATTRIBUTE_UNUSED)
d1418 1
a1418 1
gld_${EMULATION_NAME}_finish (void)
d1465 1
a1465 1
    || (!link_info.relocatable && pe_def_file->num_exports != 0)
d1502 2
a1503 1
output_prev_sec_find (lang_output_section_statement_type *os)
d1545 3
a1547 1
gld_${EMULATION_NAME}_place_orphan (lang_input_statement_type *file, asection *s)
d1560 1
a1560 1
  if (!link_info.relocatable)
d1651 1
a1651 1
	    if (! ISALNUM ((unsigned char) *ps) && *ps != '_')
d1666 1
a1666 1
      if (link_info.relocatable || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0)
d1677 1
d1828 4
a1831 3
gld_${EMULATION_NAME}_open_dynamic_archive
  (const char *arch ATTRIBUTE_UNUSED, search_dirs_type *search,
   lang_input_statement_type *entry)
d1919 3
a1921 2
gld_${EMULATION_NAME}_find_potential_libraries
  (char *name, lang_input_statement_type *entry)
d1927 2
a1928 1
gld_${EMULATION_NAME}_get_script (int *isfile)
d1938 1
a1938 1
  if (link_info.relocatable && config.build_constructors)
d1942 1
a1942 1
echo '  ; else if (link_info.relocatable) return'     >> e${EMULATION_NAME}.c
@


