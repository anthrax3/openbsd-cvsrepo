head	1.7;
access;
symbols
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.52
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.7
date	2004.11.02.20.45.50;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.50;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.43;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.22.26.22;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.12.48;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.54.50;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.37;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.37;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.36.03;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.29.12;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.48.21;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.14.01.45;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.53;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.23.25;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@# This shell script emits a C file. -*- C -*-
# It does some substitutions.
if [ -z "$MACHINE" ]; then
  OUTPUT_ARCH=${ARCH}
else
  OUTPUT_ARCH=${ARCH}:${MACHINE}
fi
cat >e${EMULATION_NAME}.c <<EOF
/* This file is is generated by a shell script.  DO NOT EDIT! */

/* AIX emulation code for ${EMULATION_NAME}
   Copyright 1991, 1993, 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
   Written by Steve Chamberlain <sac@@cygnus.com>
   AIX support by Ian Lance Taylor <ian@@cygnus.com>
   AIX 64 bit support by Tom Rix <trix@@redhat.com>

This file is part of GLD, the Gnu Linker.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#define TARGET_IS_${EMULATION_NAME}

#include "bfd.h"
#include "sysdep.h"
#include "libiberty.h"
#include "safe-ctype.h"
#include "getopt.h"
#include "obstack.h"
#include "bfdlink.h"

#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldfile.h"
#include "ldemul.h"
#include "ldctor.h"
#include <ldgram.h>

#include "coff/internal.h"
#include "coff/xcoff.h"
#include "libcoff.h"
#include "libxcoff.h"

static void gld${EMULATION_NAME}_read_file (const char *, bfd_boolean);
static void gld${EMULATION_NAME}_free (void *);
static void gld${EMULATION_NAME}_find_relocs (lang_statement_union_type *);
static void gld${EMULATION_NAME}_find_exp_assignment (etree_type *);


/* The file alignment required for each section.  */
static unsigned long file_align;

/* The maximum size the stack is permitted to grow.  This is stored in
   the a.out header.  */
static unsigned long maxstack;

/* The maximum data size.  This is stored in the a.out header.  */
static unsigned long maxdata;

/* Whether to perform garbage collection.  */
static int gc = 1;

/* The module type to use.  */
static unsigned short modtype = ('1' << 8) | 'L';

/* Whether the .text section must be read-only (i.e., no relocs
   permitted).  */
static int textro;

/* Whether to implement Unix like linker semantics.  */
static int unix_ld;

/* Structure used to hold import file list.  */

struct filelist
{
  struct filelist *next;
  const char *name;
};

/* List of import files.  */
static struct filelist *import_files;

/* List of export symbols read from the export files.  */

struct export_symbol_list
{
  struct export_symbol_list *next;
  const char *name;
};

static struct export_symbol_list *export_symbols;

/* Maintains the 32 or 64 bit mode state of import file */
static unsigned int symbol_mode = 0x04;

/* Which symbol modes are valid */
static unsigned int symbol_mode_mask = 0x0d;

/* Whether this is a 64 bit link */
static int is_64bit = 0;

/* Which syscalls from import file are valid */
static unsigned int syscall_mask = 0x77;

/* fake file for -binitfini support */
static lang_input_statement_type *initfini_file;

/* Whether to do run time linking
   -brtl enables, -bnortl and -bnortllib disable. */
static int rtld;

/* Explicit command line library path, -blibpath */
static char *command_line_blibpath = NULL;

/* This routine is called before anything else is done.  */

static void
gld${EMULATION_NAME}_before_parse (void)
{
  ldfile_set_output_arch ("${OUTPUT_ARCH}", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);

  config.has_shared = TRUE;

  /* The link_info.[init|fini]_functions are initialized in ld/lexsup.c.
     Override them here so we can use the link_info.init_function as a
     state flag that lets the backend know that -binitfini has been done.  */

  link_info.init_function = NULL;
  link_info.fini_function = NULL;
}

/* Handle AIX specific options.  */

enum
  {
    OPTION_IGNORE = 300,
    OPTION_AUTOIMP,
    OPTION_ERNOTOK,
    OPTION_EROK,
    OPTION_EXPORT,
    OPTION_IMPORT,
    OPTION_INITFINI,
    OPTION_LOADMAP,
    OPTION_MAXDATA,
    OPTION_MAXSTACK,
    OPTION_MODTYPE,
    OPTION_NOAUTOIMP,
    OPTION_NOSTRCMPCT,
    OPTION_PD,
    OPTION_PT,
    OPTION_STRCMPCT,
    OPTION_UNIX,
    OPTION_32,
    OPTION_64,
    OPTION_LIBPATH,
    OPTION_NOLIBPATH,
  };

static void
gld${EMULATION_NAME}_add_options
  (int ns, char **shortopts, int nl, struct option **longopts,
   int nrl ATTRIBUTE_UNUSED, struct option **really_longopts ATTRIBUTE_UNUSED)
{
  static const char xtra_short[] = "D:H:KT:z";
  static const struct option xtra_long[] = {
  /* -binitfini has special handling in the linker backend.  The native linker
     uses the arguemnts to generate a table of init and fini functions for
     the executable.  The important use for this option is to support aix 4.2+
     c++ constructors and destructors.  This is tied into gcc via collect2.c.

     The function table is accessed by the runtime linker/loader by checking if
     the first symbol in the loader symbol table is __rtinit.  The gnu linker
     generates this symbol and makes it the first loader symbol.  */

    {"basis", no_argument, NULL, OPTION_IGNORE},
    {"bautoimp", no_argument, NULL, OPTION_AUTOIMP},
    {"bcomprld", no_argument, NULL, OPTION_IGNORE},
    {"bcrld", no_argument, NULL, OPTION_IGNORE},
    {"bcror31", no_argument, NULL, OPTION_IGNORE},
    {"bD", required_argument, NULL, OPTION_MAXDATA},
    {"bE", required_argument, NULL, OPTION_EXPORT},
    {"bernotok", no_argument, NULL, OPTION_ERNOTOK},
    {"berok", no_argument, NULL, OPTION_EROK},
    {"berrmsg", no_argument, NULL, OPTION_IGNORE},
    {"bexport", required_argument, NULL, OPTION_EXPORT},
    {"bf", no_argument, NULL, OPTION_ERNOTOK},
    {"bgc", no_argument, &gc, 1},
    {"bh", required_argument, NULL, OPTION_IGNORE},
    {"bhalt", required_argument, NULL, OPTION_IGNORE},
    {"bI", required_argument, NULL, OPTION_IMPORT},
    {"bimport", required_argument, NULL, OPTION_IMPORT},
    {"binitfini", required_argument, NULL, OPTION_INITFINI},
    {"bl", required_argument, NULL, OPTION_LOADMAP},
    {"bloadmap", required_argument, NULL, OPTION_LOADMAP},
    {"bmaxdata", required_argument, NULL, OPTION_MAXDATA},
    {"bmaxstack", required_argument, NULL, OPTION_MAXSTACK},
    {"bM", required_argument, NULL, OPTION_MODTYPE},
    {"bmodtype", required_argument, NULL, OPTION_MODTYPE},
    {"bnoautoimp", no_argument, NULL, OPTION_NOAUTOIMP},
    {"bnodelcsect", no_argument, NULL, OPTION_IGNORE},
    {"bnoentry", no_argument, NULL, OPTION_IGNORE},
    {"bnogc", no_argument, &gc, 0},
    {"bnso", no_argument, NULL, OPTION_NOAUTOIMP},
    {"bnostrcmpct", no_argument, NULL, OPTION_NOSTRCMPCT},
    {"bnotextro", no_argument, &textro, 0},
    {"bnro", no_argument, &textro, 0},
    {"bpD", required_argument, NULL, OPTION_PD},
    {"bpT", required_argument, NULL, OPTION_PT},
    {"bro", no_argument, &textro, 1},
    {"brtl", no_argument, &rtld, 1},
    {"bnortl", no_argument, &rtld, 0},
    {"bnortllib", no_argument, &rtld, 0},
    {"bS", required_argument, NULL, OPTION_MAXSTACK},
    {"bso", no_argument, NULL, OPTION_AUTOIMP},
    {"bstrcmpct", no_argument, NULL, OPTION_STRCMPCT},
    {"btextro", no_argument, &textro, 1},
    {"b32", no_argument, NULL, OPTION_32},
    {"b64", no_argument, NULL, OPTION_64},
    {"static", no_argument, NULL, OPTION_NOAUTOIMP},
    {"unix", no_argument, NULL, OPTION_UNIX},
    {"blibpath", required_argument, NULL, OPTION_LIBPATH},
    {"bnolibpath", required_argument, NULL, OPTION_NOLIBPATH},
    {NULL, no_argument, NULL, 0}
  };

  /* Options supported by the AIX linker which we do not support: -f,
     -S, -v, -Z, -bbindcmds, -bbinder, -bbindopts, -bcalls, -bcaps,
     -bcror15, -bdebugopt, -bdbg, -bdelcsect, -bex?, -bfilelist, -bfl,
     -bgcbypass, -bglink, -binsert, -bi, -bloadmap, -bl, -bmap, -bnl,
     -bnobind, -bnocomprld, -bnocrld, -bnoerrmsg, -bnoglink,
     -bnoloadmap, -bnl, -bnoobjreorder, -bnoquiet, -bnoreorder,
     -bnotypchk, -bnox, -bquiet, -bR, -brename, -breorder, -btypchk,
     -bx, -bX, -bxref.  */

  *shortopts = (char *) xrealloc (*shortopts, ns + sizeof (xtra_short));
  memcpy (*shortopts + ns, &xtra_short, sizeof (xtra_short));
  *longopts = xrealloc (*longopts,
			nl * sizeof (struct option) + sizeof (xtra_long));
  memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));
}

static bfd_boolean
gld${EMULATION_NAME}_parse_args (int argc, char **argv)
{
  int indx;

  /* If the current option starts with -b, change the first : to an =.
     The AIX linker uses : to separate the option from the argument;
     changing it to = lets us treat it as a getopt option.  */
  indx = optind;
  if (indx == 0)
    indx = 1;

  if (indx < argc && strncmp (argv[indx], "-b", 2) == 0)
    {
      char *s;

      for (s = argv[indx]; *s != '\0'; s++)
	{
	  if (*s == ':')
	    {
	      *s = '=';
	      break;
	    }
	}
    }
  return FALSE;
}

static bfd_boolean
gld${EMULATION_NAME}_handle_option (int optc)
{
  bfd_signed_vma val;
  const char *end;

  switch (optc)
    {
    default:
      return FALSE;

    case 0:
      /* Long option which just sets a flag.  */
      break;

    case 'D':
      val = bfd_scan_vma (optarg, &end, 0);
      if (*end != '\0')
	einfo ("%P: warning: ignoring invalid -D number %s\n", optarg);
      else if (val != -1)
	lang_section_start (".data", exp_intop (val));
      break;

    case 'H':
      val = bfd_scan_vma (optarg, &end, 0);
      if (*end != '\0' || (val & (val - 1)) != 0)
	einfo ("%P: warning: ignoring invalid -H number %s\n", optarg);
      else
	file_align = val;
      break;

    case 'K':
    case 'z':
      /* FIXME: This should use the page size for the target system.  */
      file_align = 4096;
      break;

    case 'T':
      /* On AIX this is the same as GNU ld -Ttext.  When we see -T
	 number, we assume the AIX option is intended.  Otherwise, we
	 assume the usual GNU ld -T option is intended.  We can't just
	 ignore the AIX option, because gcc passes it to the linker.  */
      val = bfd_scan_vma (optarg, &end, 0);
      if (*end != '\0')
	return FALSE;
      lang_section_start (".text", exp_intop (val));
      break;

    case OPTION_IGNORE:
      break;

    case OPTION_INITFINI:
      {
	/*
	 * The aix linker init fini has the format :
	 *
	 * -binitfini:[ Initial][:Termination][:Priority]
	 *
	 * it allows the Termination and Priority to be optional.
	 *
	 * Since we support only one init/fini pair, we ignore the Priority.
	 *
	 * Define the special symbol __rtinit.
	 *
	 * strtok does not correctly handle the case of -binitfini::fini: so
	 * do it by hand
	 */
	char *t, *i, *f;

	i = t = optarg;
	while (*t && ':' != *t)
	  t++;
	if (*t)
	  *t++ = 0;

	if (0 != strlen (i))
	  link_info.init_function = i;

	f = t;
	while (*t && ':' != *t)
	  t++;
	*t = 0;

	if (0 != strlen (f))
	  link_info.fini_function = f;
      }
      break;

    case OPTION_AUTOIMP:
      link_info.static_link = FALSE;
      break;

    case OPTION_ERNOTOK:
      force_make_executable = FALSE;
      break;

    case OPTION_EROK:
      force_make_executable = TRUE;
      break;

    case OPTION_EXPORT:
      gld${EMULATION_NAME}_read_file (optarg, FALSE);
      break;

    case OPTION_IMPORT:
      {
	struct filelist *n;
	struct filelist **flpp;

	n = (struct filelist *) xmalloc (sizeof (struct filelist));
	n->next = NULL;
	n->name = optarg;
	flpp = &import_files;
	while (*flpp != NULL)
	  flpp = &(*flpp)->next;
	*flpp = n;
      }
      break;

    case OPTION_LOADMAP:
      config.map_filename = optarg;
      break;

    case OPTION_MAXDATA:
      val = bfd_scan_vma (optarg, &end, 0);
      if (*end != '\0')
	einfo ("%P: warning: ignoring invalid -bmaxdata number %s\n", optarg);
      else
	maxdata = val;
      break;

    case OPTION_MAXSTACK:
      val = bfd_scan_vma (optarg, &end, 0);
      if (*end != '\0')
	einfo ("%P: warning: ignoring invalid -bmaxstack number %s\n",
	       optarg);
      else
	maxstack = val;
      break;

    case OPTION_MODTYPE:
      if (*optarg == 'S')
	{
	  link_info.shared = TRUE;
	  ++optarg;
	}
      if (*optarg == '\0' || optarg[1] == '\0')
	einfo ("%P: warning: ignoring invalid module type %s\n", optarg);
      else
	modtype = (*optarg << 8) | optarg[1];
      break;

    case OPTION_NOAUTOIMP:
      link_info.static_link = TRUE;
      break;

    case OPTION_NOSTRCMPCT:
      link_info.traditional_format = TRUE;
      break;

    case OPTION_PD:
      /* This sets the page that the .data section is supposed to
	 start on.  The offset within the page should still be the
	 offset within the file, so we need to build an appropriate
	 expression.  */
      val = bfd_scan_vma (optarg, &end, 0);
      if (*end != '\0')
	einfo ("%P: warning: ignoring invalid -pD number %s\n", optarg);
      else
	{
	  etree_type *t;

	  t = exp_binop ('+',
			 exp_intop (val),
			 exp_binop ('&',
				    exp_nameop (NAME, "."),
				    exp_intop (0xfff)));
	  t = exp_binop ('&',
			 exp_binop ('+', t, exp_intop (31)),
			 exp_intop (~(bfd_vma) 31));
	  lang_section_start (".data", t);
	}
      break;

    case OPTION_PT:
      /* This set the page that the .text section is supposed to start
	 on.  The offset within the page should still be the offset
	 within the file.  */
      val = bfd_scan_vma (optarg, &end, 0);
      if (*end != '\0')
	einfo ("%P: warning: ignoring invalid -pT number %s\n", optarg);
      else
	{
	  etree_type *t;

	  t = exp_binop ('+',
			 exp_intop (val),
			 exp_nameop (SIZEOF_HEADERS, NULL));
	  t = exp_binop ('&',
			 exp_binop ('+', t, exp_intop (31)),
			 exp_intop (~(bfd_vma) 31));
	  lang_section_start (".text", t);
	}
      break;

    case OPTION_STRCMPCT:
      link_info.traditional_format = FALSE;
      break;

    case OPTION_UNIX:
      unix_ld = TRUE;
      break;

    case OPTION_32:
      is_64bit = 0;
      syscall_mask = 0x77;
      symbol_mode_mask = 0x0d;
      break;

    case OPTION_64:
      is_64bit = 1;
      syscall_mask = 0xcc;
      symbol_mode_mask = 0x0e;
      break;

    case OPTION_LIBPATH:
      command_line_blibpath = optarg;
      break;

    case OPTION_NOLIBPATH:
      command_line_blibpath = NULL;
      break;

    }

  return TRUE;
}

/* This is called when an input file can not be recognized as a BFD
   object or an archive.  If the file starts with #!, we must treat it
   as an import file.  This is for AIX compatibility.  */

static bfd_boolean
gld${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry)
{
  FILE *e;
  bfd_boolean ret;

  e = fopen (entry->filename, FOPEN_RT);
  if (e == NULL)
    return FALSE;

  ret = FALSE;

  if (getc (e) == '#' && getc (e) == '!')
    {
      struct filelist *n;
      struct filelist **flpp;

      n = (struct filelist *) xmalloc (sizeof (struct filelist));
      n->next = NULL;
      n->name = entry->filename;
      flpp = &import_files;
      while (*flpp != NULL)
	flpp = &(*flpp)->next;
      *flpp = n;

      ret = TRUE;
      entry->loaded = TRUE;
    }

  fclose (e);

  return ret;
}

/* This is called after the input files have been opened.  */

static void
gld${EMULATION_NAME}_after_open (void)
{
  bfd_boolean r;
  struct set_info *p;

  /* Call ldctor_build_sets, after pretending that this is a
     relocatable link.  We do this because AIX requires relocation
     entries for all references to symbols, even in a final
     executable.  Of course, we only want to do this if we are
     producing an XCOFF output file.  */
  r = link_info.relocatable;
  if (strstr (bfd_get_target (output_bfd), "xcoff") != NULL)
    link_info.relocatable = TRUE;
  ldctor_build_sets ();
  link_info.relocatable = r;

  /* For each set, record the size, so that the XCOFF backend can
     output the correct csect length.  */
  for (p = sets; p != (struct set_info *) NULL; p = p->next)
    {
      bfd_size_type size;

      /* If the symbol is defined, we may have been invoked from
	 collect, and the sets may already have been built, so we do
	 not do anything.  */
      if (p->h->type == bfd_link_hash_defined
	  || p->h->type == bfd_link_hash_defweak)
	continue;

      if (p->reloc != BFD_RELOC_CTOR)
	{
	  /* Handle this if we need to.  */
	  abort ();
	}

      size = (p->count + 2) * 4;
      if (!bfd_xcoff_link_record_set (output_bfd, &link_info, p->h, size))
	einfo ("%F%P: bfd_xcoff_link_record_set failed: %E\n");
    }
}

/* This is called after the sections have been attached to output
   sections, but before any sizes or addresses have been set.  */

static void
gld${EMULATION_NAME}_before_allocation (void)
{
  struct filelist *fl;
  struct export_symbol_list *el;
  char *libpath;
  asection *special_sections[XCOFF_NUMBER_OF_SPECIAL_SECTIONS];
  int i;

  /* Handle the import and export files, if any.  */
  for (fl = import_files; fl != NULL; fl = fl->next)
    gld${EMULATION_NAME}_read_file (fl->name, TRUE);
  for (el = export_symbols; el != NULL; el = el->next)
    {
      struct bfd_link_hash_entry *h;

      h = bfd_link_hash_lookup (link_info.hash, el->name, FALSE, FALSE, FALSE);
      if (h == NULL)
	einfo ("%P%F: bfd_link_hash_lookup of export symbol failed: %E\n");
      if (!bfd_xcoff_export_symbol (output_bfd, &link_info, h))
	einfo ("%P%F: bfd_xcoff_export_symbol failed: %E\n");
    }

  /* Track down all relocations called for by the linker script (these
     are typically constructor/destructor entries created by
     CONSTRUCTORS) and let the backend know it will need to create
     .loader relocs for them.  */
  lang_for_each_statement (gld${EMULATION_NAME}_find_relocs);

  /* Precedence of LIBPATH
     -blibpath:	 native support always first
     -rpath:	 gnu extension
     -L		 build from command line -L's */
  if (command_line_blibpath != NULL)
    libpath = command_line_blibpath;
  else if (command_line.rpath != NULL)
    libpath = command_line.rpath;
  else if (search_head == NULL)
    libpath = (char *) "";
  else
    {
      size_t len;
      search_dirs_type *search;

      len = strlen (search_head->name);
      libpath = xmalloc (len + 1);
      strcpy (libpath, search_head->name);
      for (search = search_head->next; search != NULL; search = search->next)
	{
	  size_t nlen;

	  nlen = strlen (search->name);
	  libpath = xrealloc (libpath, len + nlen + 2);
	  libpath[len] = ':';
	  strcpy (libpath + len + 1, search->name);
	  len += nlen + 1;
	}
    }

  /* Let the XCOFF backend set up the .loader section.  */
  if (!bfd_xcoff_size_dynamic_sections
      (output_bfd, &link_info, libpath,	entry_symbol.name, file_align,
       maxstack, maxdata, gc && !unix_ld ? TRUE : FALSE,
       modtype,	textro ? TRUE : FALSE, unix_ld, special_sections,
       rtld ? TRUE : FALSE))
    einfo ("%P%F: failed to set dynamic section sizes: %E\n");

  /* Look through the special sections, and put them in the right
     place in the link ordering.  This is especially magic.  */
  for (i = 0; i < XCOFF_NUMBER_OF_SPECIAL_SECTIONS; i++)
    {
      asection *sec;
      lang_output_section_statement_type *os;
      lang_statement_union_type **pls;
      lang_input_section_type *is;
      const char *oname;
      bfd_boolean start;

      sec = special_sections[i];
      if (sec == NULL)
	continue;

      /* Remove this section from the list of the output section.
	 This assumes we know what the script looks like.  */
      is = NULL;
      os = lang_output_section_find (sec->output_section->name);
      if (os == NULL)
	einfo ("%P%F: can't find output section %s\n",
	       sec->output_section->name);

      for (pls = &os->children.head; *pls != NULL; pls = &(*pls)->header.next)
	{
	  if ((*pls)->header.type == lang_input_section_enum
	      && (*pls)->input_section.section == sec)
	    {
	      is = (lang_input_section_type *) * pls;
	      *pls = (*pls)->header.next;
	      break;
	    }

	  if ((*pls)->header.type == lang_wild_statement_enum)
	    {
	      lang_statement_union_type **pwls;

	      for (pwls = &(*pls)->wild_statement.children.head;
		   *pwls != NULL; pwls = &(*pwls)->header.next)
		{

		  if ((*pwls)->header.type == lang_input_section_enum
		      && (*pwls)->input_section.section == sec)
		    {
		      is = (lang_input_section_type *) * pwls;
		      *pwls = (*pwls)->header.next;
		      break;
		    }
		}

	      if (is != NULL)
		break;
	    }
	}

      if (is == NULL)
	{
	  einfo ("%P%F: can't find %s in output section\n",
		 bfd_get_section_name (sec->owner, sec));
	}

      /* Now figure out where the section should go.  */
      switch (i)
	{

	default:		/* to avoid warnings */
	case XCOFF_SPECIAL_SECTION_TEXT:
	  /* _text */
	  oname = ".text";
	  start = TRUE;
	  break;

	case XCOFF_SPECIAL_SECTION_ETEXT:
	  /* _etext */
	  oname = ".text";
	  start = FALSE;
	  break;

	case XCOFF_SPECIAL_SECTION_DATA:
	  /* _data */
	  oname = ".data";
	  start = TRUE;
	  break;

	case XCOFF_SPECIAL_SECTION_EDATA:
	  /* _edata */
	  oname = ".data";
	  start = FALSE;
	  break;

	case XCOFF_SPECIAL_SECTION_END:
	case XCOFF_SPECIAL_SECTION_END2:
	  /* _end and end */
	  oname = ".bss";
	  start = FALSE;
	  break;
	}

      os = lang_output_section_find (oname);

      if (start)
	{
	  is->header.next = os->children.head;
	  os->children.head = (lang_statement_union_type *) is;
	}
      else
	{
	  is->header.next = NULL;
	  lang_statement_append (&os->children,
				 (lang_statement_union_type *) is,
				 &is->header.next);
	}
    }
}

static char *
gld${EMULATION_NAME}_choose_target (int argc, char **argv)
{
  int i, j, jmax;
  static char *from_outside;
  static char *from_inside;
  static char *argv_to_target[][2] = {
    {NULL,   "${OUTPUT_FORMAT}"},
    {"-b32", "${OUTPUT_FORMAT_32BIT}"},
    {"-b64", "${OUTPUT_FORMAT_64BIT}"},
  };

  jmax = 3;

  from_outside = getenv (TARGET_ENVIRON);
  if (from_outside != (char *) NULL)
    return from_outside;

  /* Set to default. */
  from_inside = argv_to_target[0][1];
  for (i = 1; i < argc; i++)
    {
      for (j = 1; j < jmax; j++)
	{
	  if (0 == strcmp (argv[i], argv_to_target[j][0]))
	    from_inside = argv_to_target[j][1];
	}
    }

  return from_inside;
}

/* Returns
   1 : state changed
   0 : no change */
static int
change_symbol_mode (char *input)
{
  char *symbol_mode_string[] = {
    "# 32",			/* 0x01 */
    "# 64",			/* 0x02 */
    "# no32",			/* 0x04 */
    "# no64",			/* 0x08 */
    NULL,
  };

  unsigned int bit;
  char *string;

  for (bit = 0;; bit++)
    {
      string = symbol_mode_string[bit];
      if (string == NULL)
	return 0;

      if (0 == strcmp (input, string))
	{
	  symbol_mode = (1 << bit);
	  return 1;
	}
    }
  /* should not be here */
  return 0;
}

/* Returns
   1 : yes
   0 : ignore
   -1 : error, try something else */
static int
is_syscall (char *input, unsigned int *flag)
{
  unsigned int bit;
  char *string;

  struct sc {
    char *syscall_string;
    unsigned int flag;
  } s [] = {
    { "svc"	    /* 0x01 */, XCOFF_SYSCALL32 },
    { "svc32"	    /* 0x02 */, XCOFF_SYSCALL32 },
    { "svc3264"     /* 0x04 */, XCOFF_SYSCALL32 | XCOFF_SYSCALL64 },
    { "svc64"	    /* 0x08 */, XCOFF_SYSCALL64 },
    { "syscall"     /* 0x10 */, XCOFF_SYSCALL32 },
    { "syscall32"   /* 0x20 */, XCOFF_SYSCALL32 },
    { "syscall3264" /* 0x40 */, XCOFF_SYSCALL32 | XCOFF_SYSCALL64 },
    { "syscall64"   /* 0x80 */, XCOFF_SYSCALL64 },
    { NULL, 0 },
  };

  *flag = 0;

  for (bit = 0;; bit++)
    {
      string = s[bit].syscall_string;
      if (string == NULL)
	return -1;

      if (0 == strcmp (input, string))
	{
	  if (1 << bit & syscall_mask)
	    {
	      *flag = s[bit].flag;
	      return 1;
	    }
	  else
	    {
	      return 0;
	    }
	}
    }
  /* should not be here */
  return -1;
}

/* Read an import or export file.  For an import file, this is called
   by the before_allocation emulation routine.  For an export file,
   this is called by the handle_option emulation routine.  */

static void
gld${EMULATION_NAME}_read_file (const char *filename, bfd_boolean import)
{
  struct obstack *o;
  FILE *f;
  int lineno;
  int c;
  bfd_boolean keep;
  const char *imppath;
  const char *impfile;
  const char *impmember;

  o = (struct obstack *) xmalloc (sizeof (struct obstack));
  obstack_specify_allocation (o, 0, 0, xmalloc, gld${EMULATION_NAME}_free);

  f = fopen (filename, FOPEN_RT);
  if (f == NULL)
    {
      bfd_set_error (bfd_error_system_call);
      einfo ("%F%s: %E\n", filename);
    }

  keep = FALSE;

  imppath = NULL;
  impfile = NULL;
  impmember = NULL;

  lineno = 0;

  /* Default to 32 and 64 bit mode
     symbols at top of /lib/syscalls.exp do not have a mode modifier and they
     are not repeated, assume 64 bit routines also want to use them.
     See the routine change_symbol_mode for more information.  */

  symbol_mode = 0x04;

  while ((c = getc (f)) != EOF)
    {
      char *s;
      char *symname;
      unsigned int syscall_flag = 0;
      bfd_vma address;
      struct bfd_link_hash_entry *h;

      if (c != '\n')
	{
	  obstack_1grow (o, c);
	  continue;
	}

      obstack_1grow (o, '\0');
      ++lineno;

      s = (char *) obstack_base (o);
      while (ISSPACE (*s))
	++s;
      if (*s == '\0'
	  || *s == '*'
	  || change_symbol_mode (s)
	  || (*s == '#' && s[1] == ' ')
	  || (!import && *s == '#' && s[1] == '!'))
	{
	  obstack_free (o, obstack_base (o));
	  continue;
	}

      if (*s == '#' && s[1] == '!')
	{
	  s += 2;
	  while (ISSPACE (*s))
	    ++s;
	  if (*s == '\0')
	    {
	      imppath = NULL;
	      impfile = NULL;
	      impmember = NULL;
	      obstack_free (o, obstack_base (o));
	    }
	  else if (*s == '(')
	    einfo ("%F%s%d: #! ([member]) is not supported in import files\n",
		   filename, lineno);
	  else
	    {
	      char cs;
	      char *file;

	      (void) obstack_finish (o);
	      keep = TRUE;
	      imppath = s;
	      file = NULL;
	      while (!ISSPACE (*s) && *s != '(' && *s != '\0')
		{
		  if (*s == '/')
		    file = s + 1;
		  ++s;
		}
	      if (file != NULL)
		{
		  file[-1] = '\0';
		  impfile = file;
		  if (imppath == file - 1)
		    imppath = "/";
		}
	      else
		{
		  impfile = imppath;
		  imppath = "";
		}
	      cs = *s;
	      *s = '\0';
	      while (ISSPACE (cs))
		{
		  ++s;
		  cs = *s;
		}
	      if (cs != '(')
		{
		  impmember = "";
		  if (cs != '\0')
		    einfo ("%s:%d: warning: syntax error in import file\n",
			   filename, lineno);
		}
	      else
		{
		  ++s;
		  impmember = s;
		  while (*s != ')' && *s != '\0')
		    ++s;
		  if (*s == ')')
		    *s = '\0';
		  else
		    einfo ("%s:%d: warning: syntax error in import file\n",
			   filename, lineno);
		}
	    }

	  continue;
	}

      if (symbol_mode & symbol_mode_mask)
	{
	  /* This is a symbol to be imported or exported.  */
	  symname = s;
	  syscall_flag = 0;
	  address = (bfd_vma) -1;

	  while (!ISSPACE (*s) && *s != '\0')
	    ++s;
	  if (*s != '\0')
	    {
	      char *se;

	      *s++ = '\0';

	      while (ISSPACE (*s))
		++s;

	      se = s;
	      while (!ISSPACE (*se) && *se != '\0')
		++se;
	      if (*se != '\0')
		{
		  *se++ = '\0';
		  while (ISSPACE (*se))
		    ++se;
		  if (*se != '\0')
		    einfo ("%s%d: warning: syntax error in import/export file\n",
			   filename, lineno);
		}

	      if (s != se)
		{
		  int status;
		  const char *end;

		  status = is_syscall (s, &syscall_flag);

		  if (0 > status)
		    {
		      /* not a system call, check for address */
		      address = bfd_scan_vma (s, &end, 0);
		      if (*end != '\0')
			{
			  einfo ("%s:%d: warning: syntax error in import/export file\n",
				 filename, lineno);

			}
		    }
		}
	    }

	  if (!import)
	    {
	      struct export_symbol_list *n;

	      ldlang_add_undef (symname);
	      n = ((struct export_symbol_list *)
		   xmalloc (sizeof (struct export_symbol_list)));
	      n->next = export_symbols;
	      n->name = xstrdup (symname);
	      export_symbols = n;
	    }
	  else
	    {
	      h = bfd_link_hash_lookup (link_info.hash, symname, FALSE, FALSE,
					TRUE);
	      if (h == NULL || h->type == bfd_link_hash_new)
		{
		  /* We can just ignore attempts to import an unreferenced
		     symbol.  */
		}
	      else
		{
		  if (!bfd_xcoff_import_symbol (output_bfd, &link_info, h,
						address, imppath, impfile,
						impmember, syscall_flag))
		    einfo ("%X%s:%d: failed to import symbol %s: %E\n",
			   filename, lineno, symname);
		}
	    }
	}
      obstack_free (o, obstack_base (o));
    }

  if (obstack_object_size (o) > 0)
    {
      einfo ("%s:%d: warning: ignoring unterminated last line\n",
	     filename, lineno);
      obstack_free (o, obstack_base (o));
    }

  if (!keep)
    {
      obstack_free (o, NULL);
      free (o);
    }
}

/* This routine saves us from worrying about declaring free.  */

static void
gld${EMULATION_NAME}_free (void *p)
{
  free (p);
}

/* This is called by the before_allocation routine via
   lang_for_each_statement.  It looks for relocations and assignments
   to symbols.  */

static void
gld${EMULATION_NAME}_find_relocs (lang_statement_union_type *s)
{
  if (s->header.type == lang_reloc_statement_enum)
    {
      lang_reloc_statement_type *rs;

      rs = &s->reloc_statement;
      if (rs->name == NULL)
	einfo ("%F%P: only relocations against symbols are permitted\n");
      if (!bfd_xcoff_link_count_reloc (output_bfd, &link_info, rs->name))
	einfo ("%F%P: bfd_xcoff_link_count_reloc failed: %E\n");
    }

  if (s->header.type == lang_assignment_statement_enum)
    gld${EMULATION_NAME}_find_exp_assignment (s->assignment_statement.exp);
}

/* Look through an expression for an assignment statement.  */

static void
gld${EMULATION_NAME}_find_exp_assignment (etree_type *exp)
{
  struct bfd_link_hash_entry *h;

  switch (exp->type.node_class)
    {
    case etree_provide:
      h = bfd_link_hash_lookup (link_info.hash, exp->assign.dst,
				FALSE, FALSE, FALSE);
      if (h == NULL)
	break;
      /* Fall through.  */
    case etree_assign:
      if (strcmp (exp->assign.dst, ".") != 0)
	{
	  if (!bfd_xcoff_record_link_assignment (output_bfd, &link_info,
						 exp->assign.dst))
	    einfo ("%P%F: failed to record assignment to %s: %E\n",
		   exp->assign.dst);
	}
      gld${EMULATION_NAME}_find_exp_assignment (exp->assign.src);
      break;

    case etree_binary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.rhs);
      break;

    case etree_trinary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.cond);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.rhs);
      break;

    case etree_unary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->unary.child);
      break;

    default:
      break;
    }
}

static char *
gld${EMULATION_NAME}_get_script (int *isfile)
EOF

if test -n "$COMPILE_IN"
then
# Scripts compiled in.

# sed commands to quote an ld script as a C string.
sc="-f ${srcdir}/emultempl/ostring.sed"

cat >>e${EMULATION_NAME}.c <<EOF
{
  *isfile = 0;

  if (link_info.relocatable && config.build_constructors)
    return
EOF
sed $sc ldscripts/${EMULATION_NAME}.xu		       >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocatable) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr		       >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn		       >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn		       >> e${EMULATION_NAME}.c
echo '  ; else return'				       >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x		       >> e${EMULATION_NAME}.c
echo '; }'					       >> e${EMULATION_NAME}.c

else
# Scripts read from the filesystem.

cat >>e${EMULATION_NAME}.c <<EOF
{
  *isfile = 1;

  if (link_info.relocatable && config.build_constructors)
    return "ldscripts/${EMULATION_NAME}.xu";
  else if (link_info.relocatable)
    return "ldscripts/${EMULATION_NAME}.xr";
  else if (!config.text_read_only)
    return "ldscripts/${EMULATION_NAME}.xbn";
  else if (!config.magic_demand_paged)
    return "ldscripts/${EMULATION_NAME}.xn";
  else
    return "ldscripts/${EMULATION_NAME}.x";
}
EOF

fi

cat >>e${EMULATION_NAME}.c <<EOF

static void
gld${EMULATION_NAME}_create_output_section_statements (void)
{
  /* __rtinit */
  if ((bfd_get_flavour (output_bfd) == bfd_target_xcoff_flavour)
      && (link_info.init_function != NULL
	  || link_info.fini_function != NULL
	  || rtld))
    {
      initfini_file = lang_add_input_file ("initfini",
					   lang_input_file_is_file_enum,
					   NULL);

      initfini_file->the_bfd = bfd_create ("initfini", output_bfd);
      if (initfini_file->the_bfd == NULL
	  || ! bfd_set_arch_mach (initfini_file->the_bfd,
				  bfd_get_arch (output_bfd),
				  bfd_get_mach (output_bfd)))
	{
	  einfo ("%X%P: can not create BFD %E\n");
	  return;
	}

      /* Call backend to fill in the rest */
      if (! bfd_xcoff_link_generate_rtinit (initfini_file->the_bfd,
					    link_info.init_function,
					    link_info.fini_function,
					    rtld))
	{
	  einfo ("%X%P: can not create BFD %E\n");
	  return;
	}

      /* __rtld defined in /lib/librtl.a */
      if (rtld)
	lang_add_input_file ("rtl", lang_input_file_is_l_enum, NULL);
    }
}

static void
gld${EMULATION_NAME}_set_output_arch (void)
{
  bfd_set_arch_mach (output_bfd,
		     bfd_xcoff_architecture (output_bfd),
		     bfd_xcoff_machine (output_bfd));

  ldfile_output_architecture = bfd_get_arch (output_bfd);
  ldfile_output_machine = bfd_get_mach (output_bfd);
  ldfile_output_machine_name = bfd_printable_name (output_bfd);
}

struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation = {
  gld${EMULATION_NAME}_before_parse,
  syslib_default,
  hll_default,
  after_parse_default,
  gld${EMULATION_NAME}_after_open,
  after_allocation_default,
  gld${EMULATION_NAME}_set_output_arch,
  gld${EMULATION_NAME}_choose_target,
  gld${EMULATION_NAME}_before_allocation,
  gld${EMULATION_NAME}_get_script,
  "${EMULATION_NAME}",
  "${OUTPUT_FORMAT}",
  0,				/* finish */
  gld${EMULATION_NAME}_create_output_section_statements,
  0,				/* open_dynamic_archive */
  0,				/* place_orphan */
  0,				/* set_symbols */
  gld${EMULATION_NAME}_parse_args,
  gld${EMULATION_NAME}_add_options,
  gld${EMULATION_NAME}_handle_option,
  gld${EMULATION_NAME}_unrecognized_file,
  NULL,				/* list_options */
  NULL,				/* recognized_file */
  NULL,				/* find potential_libraries */
  NULL				/* new_vers_pattern */
};
EOF
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d12 1
a12 1
   Copyright 1991, 1993, 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003
d59 5
a63 34
static void gld${EMULATION_NAME}_before_parse
  PARAMS ((void));
static bfd_boolean gld${EMULATION_NAME}_parse_args
  PARAMS ((int, char **));
static void gld${EMULATION_NAME}_add_options
  PARAMS ((int, char **, int, struct option **, int, struct option **));
static bfd_boolean gld${EMULATION_NAME}_handle_option
  PARAMS ((int));
static void gld${EMULATION_NAME}_after_open
  PARAMS ((void));
static char *gld${EMULATION_NAME}_choose_target
  PARAMS ((int, char **));
static void gld${EMULATION_NAME}_before_allocation
  PARAMS ((void));
static void gld${EMULATION_NAME}_read_file
  PARAMS ((const char *, bfd_boolean));
static void gld${EMULATION_NAME}_free
  PARAMS ((PTR));
static void gld${EMULATION_NAME}_find_relocs
  PARAMS ((lang_statement_union_type *));
static void gld${EMULATION_NAME}_find_exp_assignment
  PARAMS ((etree_type *));
static char *gld${EMULATION_NAME}_get_script
  PARAMS ((int *isfile));
static bfd_boolean gld${EMULATION_NAME}_unrecognized_file
  PARAMS ((lang_input_statement_type *));
static void gld${EMULATION_NAME}_create_output_section_statements
  PARAMS ((void));
static void gld${EMULATION_NAME}_set_output_arch
  PARAMS ((void));
static int is_syscall
  PARAMS ((char *, unsigned int *));
static int change_symbol_mode
  PARAMS ((char *));
d134 1
a134 1
gld${EMULATION_NAME}_before_parse ()
d136 1
a136 9
  const bfd_arch_info_type *arch = bfd_scan_arch ("${OUTPUT_ARCH}");
  if (arch)
    {
      ldfile_output_architecture = arch->arch;
      ldfile_output_machine = arch->mach;
      ldfile_output_machine_name = arch->printable_name;
    }
  else
    ldfile_output_architecture = bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`;
d176 3
a178 7
gld${EMULATION_NAME}_add_options (ns, shortopts, nl, longopts, nrl, really_longopts)
     int ns;
     char **shortopts;
     int nl;
     struct option **longopts;
     int nrl ATTRIBUTE_UNUSED;
     struct option **really_longopts ATTRIBUTE_UNUSED;
d253 2
a254 2
  *longopts = (struct option *)
    xrealloc (*longopts, nl * sizeof (struct option) + sizeof (xtra_long));
d259 1
a259 3
gld${EMULATION_NAME}_parse_args (argc, argv)
     int argc;
     char **argv;
d287 1
a287 2
gld${EMULATION_NAME}_handle_option (optc)
     int optc;
d529 1
a529 2
gld${EMULATION_NAME}_unrecognized_file (entry)
     lang_input_statement_type *entry;
d565 1
a565 1
gld${EMULATION_NAME}_after_open ()
d571 1
a571 1
     relocateable link.  We do this because AIX requires relocation
d575 1
a575 1
  r = link_info.relocateable;
d577 1
a577 1
    link_info.relocateable = TRUE;
d579 1
a579 1
  link_info.relocateable = r;
d610 1
a610 1
gld${EMULATION_NAME}_before_allocation ()
d792 1
a792 3
gld${EMULATION_NAME}_choose_target (argc, argv)
     int argc;
     char **argv;
d827 1
a827 2
change_symbol_mode (input)
     char *input;
d861 1
a861 3
is_syscall (input, flag)
     char *input;
     unsigned int *flag;
d911 1
a911 3
gld${EMULATION_NAME}_read_file (filename, import)
     const char *filename;
     bfd_boolean import;
d1152 1
a1152 2
gld${EMULATION_NAME}_free (p)
     PTR p;
d1162 1
a1162 2
gld${EMULATION_NAME}_find_relocs (s)
     lang_statement_union_type *s;
d1182 1
a1182 2
gld${EMULATION_NAME}_find_exp_assignment (exp)
     etree_type *exp;
d1226 1
a1226 2
gld${EMULATION_NAME}_get_script (isfile)
     int *isfile;
d1240 1
a1240 1
  if (link_info.relocateable && config.build_constructors)
d1244 1
a1244 1
echo '  ; else if (link_info.relocateable) return'     >> e${EMULATION_NAME}.c
d1261 1
a1261 1
  if (link_info.relocateable && config.build_constructors)
d1263 1
a1263 1
  else if (link_info.relocateable)
d1279 1
a1279 1
gld${EMULATION_NAME}_create_output_section_statements ()
d1318 1
a1318 1
gld${EMULATION_NAME}_set_output_arch ()
@


1.5
log
@resolve conflicts.
@
text
@d3 5
d12 1
a12 1
   Copyright 1991, 1993, 1995, 1996, 1997, 1998, 2000, 2001
d16 1
d39 1
a43 2
#include <ctype.h>

d52 1
a52 1
#include "ldgram.h"
d54 23
a76 6
static void gld${EMULATION_NAME}_before_parse PARAMS ((void));
static int gld${EMULATION_NAME}_parse_args PARAMS ((int, char **));
static void gld${EMULATION_NAME}_after_open PARAMS ((void));
static void gld${EMULATION_NAME}_before_allocation PARAMS ((void));
static void gld${EMULATION_NAME}_read_file PARAMS ((const char *, boolean));
static void gld${EMULATION_NAME}_free PARAMS ((PTR));
d79 14
a92 2
static void gld${EMULATION_NAME}_find_exp_assignment PARAMS ((etree_type *));
static char *gld${EMULATION_NAME}_get_script PARAMS ((int *isfile));
a133 1
  boolean syscall;
d138 22
d163 1
a163 1
gld${EMULATION_NAME}_before_parse()
d165 18
a182 4
#ifndef TARGET_			/* I.e., if not generic.  */
  ldfile_output_architecture = bfd_arch_${ARCH};
#endif /* not TARGET_ */
  config.has_shared = true;
d187 33
a219 4
static int
gld${EMULATION_NAME}_parse_args (argc, argv)
     int argc;
     char **argv;
d221 10
a230 24
  int prevoptind = optind;
  int prevopterr = opterr;
  int indx;
  int longind;
  int optc;
  long val;
  char *end;

#define OPTION_IGNORE (300)
#define OPTION_AUTOIMP (OPTION_IGNORE + 1)
#define OPTION_ERNOTOK (OPTION_AUTOIMP + 1)
#define OPTION_EROK (OPTION_ERNOTOK + 1)
#define OPTION_EXPORT (OPTION_EROK + 1)
#define OPTION_IMPORT (OPTION_EXPORT + 1)
#define OPTION_LOADMAP (OPTION_IMPORT + 1)
#define OPTION_MAXDATA (OPTION_LOADMAP + 1)
#define OPTION_MAXSTACK (OPTION_MAXDATA + 1)
#define OPTION_MODTYPE (OPTION_MAXSTACK + 1)
#define OPTION_NOAUTOIMP (OPTION_MODTYPE + 1)
#define OPTION_NOSTRCMPCT (OPTION_NOAUTOIMP + 1)
#define OPTION_PD (OPTION_NOSTRCMPCT + 1)
#define OPTION_PT (OPTION_PD + 1)
#define OPTION_STRCMPCT (OPTION_PT + 1)
#define OPTION_UNIX (OPTION_STRCMPCT + 1)
a231 1
  static struct option longopts[] = {
d249 1
d267 3
d274 2
d278 2
d292 14
d312 1
d326 2
d329 6
a334 6
  /* We add s and u so to the short options list so that -s and -u on
     the command line do not match -static and -unix.  */

  opterr = 0;
  optc = getopt_long_only (argc, argv, "-D:H:KT:zsu", longopts, &longind);
  opterr = prevopterr;
a337 2
    case 's':
    case 'u':
d339 1
a339 2
      optind = prevoptind;
      return 0;
d346 1
a346 1
      val = strtol (optarg, &end, 0);
d354 2
a355 3
      val = strtoul (optarg, &end, 0);
      if (*end != '\0'
	  || (val & (val - 1)) != 0)
d369 4
a372 4
         number, we assume the AIX option is intended.  Otherwise, we
         assume the usual GNU ld -T option is intended.  We can't just
         ignore the AIX option, because gcc passes it to the linker.  */
      val = strtoul (optarg, &end, 0);
d374 1
a374 4
	{
	  optind = prevoptind;
	  return 0;
	}
d381 37
d419 1
a419 1
      link_info.static_link = false;
d423 1
a423 1
      force_make_executable = false;
d427 1
a427 1
      force_make_executable = true;
d431 1
a431 1
      gld${EMULATION_NAME}_read_file (optarg, false);
d454 1
a454 1
      val = strtoul (optarg, &end, 0);
d456 1
a456 2
	einfo ("%P: warning: ignoring invalid -bmaxdata number %s\n",
	       optarg);
d462 1
a462 1
      val = strtoul (optarg, &end, 0);
d473 1
a473 1
	  link_info.shared = true;
d483 1
a483 1
      link_info.static_link = true;
d487 1
a487 1
      link_info.traditional_format = true;
d492 4
a495 4
         start on.  The offset within the page should still be the
         offset within the file, so we need to build an appropriate
         expression.  */
      val = strtoul (optarg, &end, 0);
d509 1
a509 1
			 exp_intop (~ (bfd_vma) 31));
d516 3
a518 3
         on.  The offset within the page should still be the offset
         within the file.  */
      val = strtoul (optarg, &end, 0);
d530 1
a530 1
			 exp_intop (~ (bfd_vma) 31));
d536 1
a536 1
      link_info.traditional_format = false;
d540 21
a560 1
      unix_ld = true;
d562 1
d565 1
a565 1
  return 1;
d572 1
a572 1
static boolean
d577 1
a577 1
  boolean ret;
d581 1
a581 1
    return false;
d583 1
a583 1
  ret = false;
d598 2
a599 2
      ret = true;
      entry->loaded = true;
d612 1
a612 1
  boolean r;
d622 1
a622 1
    link_info.relocateable = true;
d646 1
a646 1
      if (! bfd_xcoff_link_record_set (output_bfd, &link_info, p->h, size))
d660 1
a660 1
  asection *special_sections[6];
d665 1
a665 1
    gld${EMULATION_NAME}_read_file (fl->name, true);
d670 1
a670 1
      h = bfd_link_hash_lookup (link_info.hash, el->name, false, false, false);
d673 1
a673 1
      if (! bfd_xcoff_export_symbol (output_bfd, &link_info, h, el->syscall))
d683 7
a689 4
  /* We need to build LIBPATH from the -L arguments.  If any -rpath
     arguments were used, though, we use -rpath instead, as a GNU
     extension.  */
  if (command_line.rpath != NULL)
d714 5
a718 8
  if (! bfd_xcoff_size_dynamic_sections (output_bfd, &link_info, libpath,
					 entry_symbol, file_align,
					 maxstack, maxdata,
					 gc && ! unix_ld ? true : false,
					 modtype,
					 textro ? true : false,
					 unix_ld,
					 special_sections))
d723 1
a723 1
  for (i = 0; i < 6; i++)
d730 1
a730 1
      boolean start;
d737 1
a737 1
         This assumes we know what the script looks like.  */
d743 2
a744 1
      for (pls = &os->children.head; *pls != NULL; pls = &(*pls)->next)
d749 2
a750 2
	      is = (lang_input_section_type *) *pls;
	      *pls = (*pls)->next;
d753 1
d759 1
a759 2
		   *pwls != NULL;
		   pwls = &(*pwls)->next)
d761 1
d765 2
a766 2
		      is = (lang_input_section_type *) *pwls;
		      *pwls = (*pwls)->next;
d770 1
d774 1
a774 1
	}	
d777 4
a780 2
	einfo ("%P%F: can't find %s in output section\n",
	       bfd_get_section_name (sec->owner, sec));
d785 3
a787 2
	default: /* to avoid warnings */
	case 0:
d790 1
a790 1
	  start = true;
d792 2
a793 1
	case 1:
d796 1
a796 1
	  start = false;
d798 2
a799 1
	case 2:
d802 1
a802 1
	  start = true;
d804 2
a805 1
	case 3:
d808 1
a808 1
	  start = false;
d810 3
a812 2
	case 4:
	case 5:
d815 1
a815 1
	  start = false;
d836 120
d958 1
a958 1
   this is called by the parse_args emulation routine.  */
d963 1
a963 1
     boolean import;
d969 1
a969 1
  boolean keep;
d984 1
a984 1
  keep = false;
d991 8
d1003 1
a1003 1
      boolean syscall;
d1017 1
a1017 1
      while (isspace ((unsigned char) *s))
d1021 1
d1023 1
a1023 1
	  || (! import && *s == '#' && s[1] == '!'))
d1032 1
a1032 1
	  while (isspace ((unsigned char) *s))
d1050 1
a1050 1
	      keep = true;
d1053 1
a1053 1
	      while (! isspace ((unsigned char) *s) && *s != '(' && *s != '\0')
d1073 1
a1073 1
	      while (isspace ((unsigned char) cs))
d1102 6
a1107 4
      /* This is a symbol to be imported or exported.  */
      symname = s;
      syscall = false;
      address = (bfd_vma) -1;
d1109 5
a1113 5
      while (! isspace ((unsigned char) *s) && *s != '\0')
	++s;
      if (*s != '\0')
	{
	  char *se;
d1115 1
a1115 1
	  *s++ = '\0';
d1117 2
a1118 2
	  while (isspace ((unsigned char) *s))
	    ++s;
d1120 2
a1121 7
	  se = s;
	  while (! isspace ((unsigned char) *se) && *se != '\0')
	    ++se;
	  if (*se != '\0')
	    {
	      *se++ = '\0';
	      while (isspace ((unsigned char) *se))
d1124 15
a1138 3
		einfo ("%s%d: warning: syntax error in import/export file\n",
		       filename, lineno);
	    }
d1140 8
a1147 10
	  if (s == se)
	    {
	      /* There was no address after all.  */
	    }
	  else if (strcasecmp (s, "svc") == 0
		   || strcasecmp (s, "syscall") == 0)
	    syscall = true;
	  else
	    {
	      char *end;
d1149 3
a1151 4
	      address = strtoul (s, &end, 0);
	      if (*end != '\0')
		einfo ("%s:%d: warning: syntax error in import/export file\n",
		       filename, lineno);
a1152 1
	}
d1154 3
a1156 3
      if (! import)
	{
	  struct export_symbol_list *n;
d1158 6
a1163 16
	  ldlang_add_undef (symname);
	  n = ((struct export_symbol_list *)
	       xmalloc (sizeof (struct export_symbol_list)));
	  n->next = export_symbols;
	  n->name = xstrdup (symname);
	  n->syscall = syscall;
	  export_symbols = n;
	}
      else
	{
	  h = bfd_link_hash_lookup (link_info.hash, symname, false, false,
				    true);
	  if (h == NULL || h->type == bfd_link_hash_new)
	    {
	      /* We can just ignore attempts to import an unreferenced
		 symbol.  */
d1167 15
a1181 5
	      if (! bfd_xcoff_import_symbol (output_bfd, &link_info, h,
					     address, imppath, impfile,
					     impmember))
		einfo ("%X%s:%d: failed to import symbol %s: %E\n",
		       filename, lineno, symname);
a1183 1

d1194 1
a1194 1
  if (! keep)
d1225 1
a1225 1
      if (! bfd_xcoff_link_count_reloc (output_bfd, &link_info, rs->name))
d1245 1
a1245 1
				false, false, false);
d1252 2
a1253 2
	  if (! bfd_xcoff_record_link_assignment (output_bfd, &link_info,
						  exp->assign.dst))
d1281 1
a1281 1
gld${EMULATION_NAME}_get_script(isfile)
d1290 1
a1290 1
sc="-f stringify.sed"
d1293 1
a1293 1
{			     
d1296 1
a1296 1
  if (link_info.relocateable == true && config.build_constructors == true)
d1299 10
a1308 10
sed $sc ldscripts/${EMULATION_NAME}.xu                     >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocateable == true) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                     >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'         >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                    >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                     >> e${EMULATION_NAME}.c
echo '  ; else return'                                     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                      >> e${EMULATION_NAME}.c
echo '; }'                                                 >> e${EMULATION_NAME}.c
d1314 1
a1314 1
{			     
d1317 1
a1317 1
  if (link_info.relocateable == true && config.build_constructors == true)
d1319 1
a1319 1
  else if (link_info.relocateable == true)
d1334 41
a1374 1
struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation = 
d1376 10
d1392 2
a1393 2
  set_output_arch_default,
  ldemul_default_target,
d1398 5
a1402 5
  0,	/* finish */
  0,	/* create_output_section_statements */
  0,	/* open_dynamic_archive */
  0,	/* place_orphan */
  0,	/* set_symbols */
d1404 2
d1407 4
a1410 1
  NULL 	/* find_potential_libraries */
@


1.4
log
@Resolve other problems that dumb cvs can't find out by itself.

(trivial part done, `interesting' patches remain)
@
text
@d7 2
a8 1
   Copyright (C) 1991, 93, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
a40 2
#include "ldemul.h"
#include "ldfile.h"
d44 2
d860 1
a860 1
	  n->name = buystring (symname);
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d33 1
d833 6
a838 2
	  if (strcasecmp (s, "svc") == 0
	      || strcasecmp (s, "syscall") == 0)
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d7 1
a7 1
   Copyright (C) 1991, 1993, 1995 Free Software Foundation, Inc.
d111 1
d219 3
d223 1
a223 1
  optc = getopt_long_only (argc, argv, "-D:H:KT:z", longopts, &longind);
d228 2
d369 2
a370 2
			 exp_binop ('+', t, exp_intop (7)),
			 exp_intop (~ (bfd_vma) 7));
d390 2
a391 2
			 exp_binop ('+', t, exp_intop (7)),
			 exp_intop (~ (bfd_vma) 7));
d743 1
a743 1
	    einfo ("%F%s%d: #! ([member]) is not supported in import files",
d983 1
a983 1
sc="-f ${srcdir}/emultempl/stringify.sed"
d1047 2
a1048 1
  gld${EMULATION_NAME}_unrecognized_file
@


1.1
log
@Initial revision
@
text
@d78 3
d143 1
d171 1
d185 1
d342 1
a342 1
      config.traditional_format = true;
d391 5
a395 1
      config.traditional_format = false;
d402 39
d452 2
a453 1
     executable.  */
d455 2
a456 1
  link_info.relocateable = true;
d548 1
a548 1
					 gc ? true : false,
d551 1
d681 1
a681 1
  f = fopen (filename, "r");
d747 1
a747 1
	      impfile = NULL;
d1041 1
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@a77 3
/* Whether to implement Unix like linker semantics.  */
static int unix_ld;

a139 1
#define OPTION_UNIX (OPTION_STRCMPCT + 1)
a166 1
    {"bnoentry", no_argument, NULL, OPTION_IGNORE},
a179 1
    {"unix", no_argument, NULL, OPTION_UNIX},
d336 1
a336 1
      link_info.traditional_format = true;
d385 1
a385 5
      link_info.traditional_format = false;
      break;

    case OPTION_UNIX:
      unix_ld = true;
a391 39
/* This is called when an input file can not be recognized as a BFD
   object or an archive.  If the file starts with #!, we must treat it
   as an import file.  This is for AIX compatibility.  */

static boolean
gld${EMULATION_NAME}_unrecognized_file (entry)
     lang_input_statement_type *entry;
{
  FILE *e;
  boolean ret;

  e = fopen (entry->filename, FOPEN_RT);
  if (e == NULL)
    return false;

  ret = false;

  if (getc (e) == '#' && getc (e) == '!')
    {
      struct filelist *n;
      struct filelist **flpp;

      n = (struct filelist *) xmalloc (sizeof (struct filelist));
      n->next = NULL;
      n->name = entry->filename;
      flpp = &import_files;
      while (*flpp != NULL)
	flpp = &(*flpp)->next;
      *flpp = n;

      ret = true;
      entry->loaded = true;
    }

  fclose (e);

  return ret;
}

d403 1
a403 2
     executable.  Of course, we only want to do this if we are
     producing an XCOFF output file.  */
d405 1
a405 2
  if (strstr (bfd_get_target (output_bfd), "xcoff") != NULL)
    link_info.relocateable = true;
d497 1
a497 1
					 gc && ! unix_ld ? true : false,
a499 1
					 unix_ld,
d629 1
a629 1
  f = fopen (filename, FOPEN_RT);
d695 1
a695 1
	      file = NULL;
a988 1
  gld${EMULATION_NAME}_unrecognized_file
@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@a32 1
#include "obstack.h"
d826 2
a827 6
	  if (s == se)
	    {
	      /* There was no address after all.  */
	    }
	  else if (strcasecmp (s, "svc") == 0
		   || strcasecmp (s, "syscall") == 0)
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d7 1
a7 1
   Copyright (C) 1991, 93, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
a111 1
  config.has_shared = true;
a218 3
  /* We add s and u so to the short options list so that -s and -u on
     the command line do not match -static and -unix.  */

d220 1
a220 1
  optc = getopt_long_only (argc, argv, "-D:H:KT:zsu", longopts, &longind);
a224 2
    case 's':
    case 'u':
d364 2
a365 2
			 exp_binop ('+', t, exp_intop (31)),
			 exp_intop (~ (bfd_vma) 31));
d385 2
a386 2
			 exp_binop ('+', t, exp_intop (31)),
			 exp_intop (~ (bfd_vma) 31));
d738 1
a738 1
	    einfo ("%F%s%d: #! ([member]) is not supported in import files\n",
d982 1
a982 1
sc="-f stringify.sed"
d1046 1
a1046 2
  gld${EMULATION_NAME}_unrecognized_file,
  NULL 	/* find_potential_libraries */
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d7 1
a7 2
   Copyright 1991, 1993, 1995, 1996, 1997, 1998, 2000, 2001
   Free Software Foundation, Inc.
d40 2
a44 2
#include "ldfile.h"
#include "ldemul.h"
d859 1
a859 1
	  n->name = xstrdup (symname);
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@a2 5
if [ -z "$MACHINE" ]; then
  OUTPUT_ARCH=${ARCH}
else
  OUTPUT_ARCH=${ARCH}:${MACHINE}
fi
d7 1
a7 1
   Copyright 1991, 1993, 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003
a10 1
   AIX 64 bit support by Tom Rix <trix@@redhat.com>
a32 1
#include "safe-ctype.h"
d37 2
d47 1
a47 1
#include <ldgram.h>
d49 6
a54 23
#include "coff/internal.h"
#include "coff/xcoff.h"
#include "libcoff.h"
#include "libxcoff.h"

static void gld${EMULATION_NAME}_before_parse
  PARAMS ((void));
static bfd_boolean gld${EMULATION_NAME}_parse_args
  PARAMS ((int, char **));
static void gld${EMULATION_NAME}_add_options
  PARAMS ((int, char **, int, struct option **, int, struct option **));
static bfd_boolean gld${EMULATION_NAME}_handle_option
  PARAMS ((int));
static void gld${EMULATION_NAME}_after_open
  PARAMS ((void));
static char *gld${EMULATION_NAME}_choose_target
  PARAMS ((int, char **));
static void gld${EMULATION_NAME}_before_allocation
  PARAMS ((void));
static void gld${EMULATION_NAME}_read_file
  PARAMS ((const char *, bfd_boolean));
static void gld${EMULATION_NAME}_free
  PARAMS ((PTR));
d57 2
a58 14
static void gld${EMULATION_NAME}_find_exp_assignment
  PARAMS ((etree_type *));
static char *gld${EMULATION_NAME}_get_script
  PARAMS ((int *isfile));
static bfd_boolean gld${EMULATION_NAME}_unrecognized_file
  PARAMS ((lang_input_statement_type *));
static void gld${EMULATION_NAME}_create_output_section_statements
  PARAMS ((void));
static void gld${EMULATION_NAME}_set_output_arch
  PARAMS ((void));
static int is_syscall
  PARAMS ((char *, unsigned int *));
static int change_symbol_mode
  PARAMS ((char *));
d100 1
a104 22
/* Maintains the 32 or 64 bit mode state of import file */
static unsigned int symbol_mode = 0x04;

/* Which symbol modes are valid */
static unsigned int symbol_mode_mask = 0x0d;

/* Whether this is a 64 bit link */
static int is_64bit = 0;

/* Which syscalls from import file are valid */
static unsigned int syscall_mask = 0x77;

/* fake file for -binitfini support */
static lang_input_statement_type *initfini_file;

/* Whether to do run time linking
   -brtl enables, -bnortl and -bnortllib disable. */
static int rtld;

/* Explicit command line library path, -blibpath */
static char *command_line_blibpath = NULL;

d108 1
a108 1
gld${EMULATION_NAME}_before_parse ()
d110 4
a113 18
  const bfd_arch_info_type *arch = bfd_scan_arch ("${OUTPUT_ARCH}");
  if (arch)
    {
      ldfile_output_architecture = arch->arch;
      ldfile_output_machine = arch->mach;
      ldfile_output_machine_name = arch->printable_name;
    }
  else
    ldfile_output_architecture = bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`;

  config.has_shared = TRUE;

  /* The link_info.[init|fini]_functions are initialized in ld/lexsup.c.
     Override them here so we can use the link_info.init_function as a
     state flag that lets the backend know that -binitfini has been done.  */

  link_info.init_function = NULL;
  link_info.fini_function = NULL;
d118 4
a121 33
enum
  {
    OPTION_IGNORE = 300,
    OPTION_AUTOIMP,
    OPTION_ERNOTOK,
    OPTION_EROK,
    OPTION_EXPORT,
    OPTION_IMPORT,
    OPTION_INITFINI,
    OPTION_LOADMAP,
    OPTION_MAXDATA,
    OPTION_MAXSTACK,
    OPTION_MODTYPE,
    OPTION_NOAUTOIMP,
    OPTION_NOSTRCMPCT,
    OPTION_PD,
    OPTION_PT,
    OPTION_STRCMPCT,
    OPTION_UNIX,
    OPTION_32,
    OPTION_64,
    OPTION_LIBPATH,
    OPTION_NOLIBPATH,
  };

static void
gld${EMULATION_NAME}_add_options (ns, shortopts, nl, longopts, nrl, really_longopts)
     int ns;
     char **shortopts;
     int nl;
     struct option **longopts;
     int nrl ATTRIBUTE_UNUSED;
     struct option **really_longopts ATTRIBUTE_UNUSED;
d123 24
a146 10
  static const char xtra_short[] = "D:H:KT:z";
  static const struct option xtra_long[] = {
  /* -binitfini has special handling in the linker backend.  The native linker
     uses the arguemnts to generate a table of init and fini functions for
     the executable.  The important use for this option is to support aix 4.2+
     c++ constructors and destructors.  This is tied into gcc via collect2.c.

     The function table is accessed by the runtime linker/loader by checking if
     the first symbol in the loader symbol table is __rtinit.  The gnu linker
     generates this symbol and makes it the first loader symbol.  */
d148 1
a165 1
    {"binitfini", required_argument, NULL, OPTION_INITFINI},
a182 3
    {"brtl", no_argument, &rtld, 1},
    {"bnortl", no_argument, &rtld, 0},
    {"bnortllib", no_argument, &rtld, 0},
a186 2
    {"b32", no_argument, NULL, OPTION_32},
    {"b64", no_argument, NULL, OPTION_64},
a188 2
    {"blibpath", required_argument, NULL, OPTION_LIBPATH},
    {"bnolibpath", required_argument, NULL, OPTION_NOLIBPATH},
a200 14
  *shortopts = (char *) xrealloc (*shortopts, ns + sizeof (xtra_short));
  memcpy (*shortopts + ns, &xtra_short, sizeof (xtra_short));
  *longopts = (struct option *)
    xrealloc (*longopts, nl * sizeof (struct option) + sizeof (xtra_long));
  memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));
}

static bfd_boolean
gld${EMULATION_NAME}_parse_args (argc, argv)
     int argc;
     char **argv;
{
  int indx;

a206 1

a219 2
  return FALSE;
}
d221 6
a226 6
static bfd_boolean
gld${EMULATION_NAME}_handle_option (optc)
     int optc;
{
  bfd_signed_vma val;
  const char *end;
d230 2
d233 2
a234 1
      return FALSE;
d241 1
a241 1
      val = bfd_scan_vma (optarg, &end, 0);
d249 3
a251 2
      val = bfd_scan_vma (optarg, &end, 0);
      if (*end != '\0' || (val & (val - 1)) != 0)
d265 4
a268 4
	 number, we assume the AIX option is intended.  Otherwise, we
	 assume the usual GNU ld -T option is intended.  We can't just
	 ignore the AIX option, because gcc passes it to the linker.  */
      val = bfd_scan_vma (optarg, &end, 0);
d270 4
a273 1
	return FALSE;
a279 37
    case OPTION_INITFINI:
      {
	/*
	 * The aix linker init fini has the format :
	 *
	 * -binitfini:[ Initial][:Termination][:Priority]
	 *
	 * it allows the Termination and Priority to be optional.
	 *
	 * Since we support only one init/fini pair, we ignore the Priority.
	 *
	 * Define the special symbol __rtinit.
	 *
	 * strtok does not correctly handle the case of -binitfini::fini: so
	 * do it by hand
	 */
	char *t, *i, *f;

	i = t = optarg;
	while (*t && ':' != *t)
	  t++;
	if (*t)
	  *t++ = 0;

	if (0 != strlen (i))
	  link_info.init_function = i;

	f = t;
	while (*t && ':' != *t)
	  t++;
	*t = 0;

	if (0 != strlen (f))
	  link_info.fini_function = f;
      }
      break;

d281 1
a281 1
      link_info.static_link = FALSE;
d285 1
a285 1
      force_make_executable = FALSE;
d289 1
a289 1
      force_make_executable = TRUE;
d293 1
a293 1
      gld${EMULATION_NAME}_read_file (optarg, FALSE);
d316 1
a316 1
      val = bfd_scan_vma (optarg, &end, 0);
d318 2
a319 1
	einfo ("%P: warning: ignoring invalid -bmaxdata number %s\n", optarg);
d325 1
a325 1
      val = bfd_scan_vma (optarg, &end, 0);
d336 1
a336 1
	  link_info.shared = TRUE;
d346 1
a346 1
      link_info.static_link = TRUE;
d350 1
a350 1
      link_info.traditional_format = TRUE;
d355 4
a358 4
	 start on.  The offset within the page should still be the
	 offset within the file, so we need to build an appropriate
	 expression.  */
      val = bfd_scan_vma (optarg, &end, 0);
d372 1
a372 1
			 exp_intop (~(bfd_vma) 31));
d379 3
a381 3
	 on.  The offset within the page should still be the offset
	 within the file.  */
      val = bfd_scan_vma (optarg, &end, 0);
d393 1
a393 1
			 exp_intop (~(bfd_vma) 31));
d399 1
a399 1
      link_info.traditional_format = FALSE;
d403 1
a403 21
      unix_ld = TRUE;
      break;

    case OPTION_32:
      is_64bit = 0;
      syscall_mask = 0x77;
      symbol_mode_mask = 0x0d;
      break;

    case OPTION_64:
      is_64bit = 1;
      syscall_mask = 0xcc;
      symbol_mode_mask = 0x0e;
      break;

    case OPTION_LIBPATH:
      command_line_blibpath = optarg;
      break;

    case OPTION_NOLIBPATH:
      command_line_blibpath = NULL;
a404 1

d407 1
a407 1
  return TRUE;
d414 1
a414 1
static bfd_boolean
d419 1
a419 1
  bfd_boolean ret;
d423 1
a423 1
    return FALSE;
d425 1
a425 1
  ret = FALSE;
d440 2
a441 2
      ret = TRUE;
      entry->loaded = TRUE;
d454 1
a454 1
  bfd_boolean r;
d464 1
a464 1
    link_info.relocateable = TRUE;
d488 1
a488 1
      if (!bfd_xcoff_link_record_set (output_bfd, &link_info, p->h, size))
d502 1
a502 1
  asection *special_sections[XCOFF_NUMBER_OF_SPECIAL_SECTIONS];
d507 1
a507 1
    gld${EMULATION_NAME}_read_file (fl->name, TRUE);
d512 1
a512 1
      h = bfd_link_hash_lookup (link_info.hash, el->name, FALSE, FALSE, FALSE);
d515 1
a515 1
      if (!bfd_xcoff_export_symbol (output_bfd, &link_info, h))
d525 4
a528 7
  /* Precedence of LIBPATH
     -blibpath:	 native support always first
     -rpath:	 gnu extension
     -L		 build from command line -L's */
  if (command_line_blibpath != NULL)
    libpath = command_line_blibpath;
  else if (command_line.rpath != NULL)
d553 8
a560 5
  if (!bfd_xcoff_size_dynamic_sections
      (output_bfd, &link_info, libpath,	entry_symbol.name, file_align,
       maxstack, maxdata, gc && !unix_ld ? TRUE : FALSE,
       modtype,	textro ? TRUE : FALSE, unix_ld, special_sections,
       rtld ? TRUE : FALSE))
d565 1
a565 1
  for (i = 0; i < XCOFF_NUMBER_OF_SPECIAL_SECTIONS; i++)
d572 1
a572 1
      bfd_boolean start;
d579 1
a579 1
	 This assumes we know what the script looks like.  */
d585 1
a585 2

      for (pls = &os->children.head; *pls != NULL; pls = &(*pls)->header.next)
d590 2
a591 2
	      is = (lang_input_section_type *) * pls;
	      *pls = (*pls)->header.next;
a593 1

d599 2
a600 1
		   *pwls != NULL; pwls = &(*pwls)->header.next)
a601 1

d605 2
a606 2
		      is = (lang_input_section_type *) * pwls;
		      *pwls = (*pwls)->header.next;
a609 1

d613 1
a613 1
	}
d616 2
a617 4
	{
	  einfo ("%P%F: can't find %s in output section\n",
		 bfd_get_section_name (sec->owner, sec));
	}
d622 2
a623 3

	default:		/* to avoid warnings */
	case XCOFF_SPECIAL_SECTION_TEXT:
d626 1
a626 1
	  start = TRUE;
d628 1
a628 2

	case XCOFF_SPECIAL_SECTION_ETEXT:
d631 1
a631 1
	  start = FALSE;
d633 1
a633 2

	case XCOFF_SPECIAL_SECTION_DATA:
d636 1
a636 1
	  start = TRUE;
d638 1
a638 2

	case XCOFF_SPECIAL_SECTION_EDATA:
d641 1
a641 1
	  start = FALSE;
d643 2
a644 3

	case XCOFF_SPECIAL_SECTION_END:
	case XCOFF_SPECIAL_SECTION_END2:
d647 1
a647 1
	  start = FALSE;
a667 120
static char *
gld${EMULATION_NAME}_choose_target (argc, argv)
     int argc;
     char **argv;
{
  int i, j, jmax;
  static char *from_outside;
  static char *from_inside;
  static char *argv_to_target[][2] = {
    {NULL,   "${OUTPUT_FORMAT}"},
    {"-b32", "${OUTPUT_FORMAT_32BIT}"},
    {"-b64", "${OUTPUT_FORMAT_64BIT}"},
  };

  jmax = 3;

  from_outside = getenv (TARGET_ENVIRON);
  if (from_outside != (char *) NULL)
    return from_outside;

  /* Set to default. */
  from_inside = argv_to_target[0][1];
  for (i = 1; i < argc; i++)
    {
      for (j = 1; j < jmax; j++)
	{
	  if (0 == strcmp (argv[i], argv_to_target[j][0]))
	    from_inside = argv_to_target[j][1];
	}
    }

  return from_inside;
}

/* Returns
   1 : state changed
   0 : no change */
static int
change_symbol_mode (input)
     char *input;
{
  char *symbol_mode_string[] = {
    "# 32",			/* 0x01 */
    "# 64",			/* 0x02 */
    "# no32",			/* 0x04 */
    "# no64",			/* 0x08 */
    NULL,
  };

  unsigned int bit;
  char *string;

  for (bit = 0;; bit++)
    {
      string = symbol_mode_string[bit];
      if (string == NULL)
	return 0;

      if (0 == strcmp (input, string))
	{
	  symbol_mode = (1 << bit);
	  return 1;
	}
    }
  /* should not be here */
  return 0;
}

/* Returns
   1 : yes
   0 : ignore
   -1 : error, try something else */
static int
is_syscall (input, flag)
     char *input;
     unsigned int *flag;
{
  unsigned int bit;
  char *string;

  struct sc {
    char *syscall_string;
    unsigned int flag;
  } s [] = {
    { "svc"	    /* 0x01 */, XCOFF_SYSCALL32 },
    { "svc32"	    /* 0x02 */, XCOFF_SYSCALL32 },
    { "svc3264"     /* 0x04 */, XCOFF_SYSCALL32 | XCOFF_SYSCALL64 },
    { "svc64"	    /* 0x08 */, XCOFF_SYSCALL64 },
    { "syscall"     /* 0x10 */, XCOFF_SYSCALL32 },
    { "syscall32"   /* 0x20 */, XCOFF_SYSCALL32 },
    { "syscall3264" /* 0x40 */, XCOFF_SYSCALL32 | XCOFF_SYSCALL64 },
    { "syscall64"   /* 0x80 */, XCOFF_SYSCALL64 },
    { NULL, 0 },
  };

  *flag = 0;

  for (bit = 0;; bit++)
    {
      string = s[bit].syscall_string;
      if (string == NULL)
	return -1;

      if (0 == strcmp (input, string))
	{
	  if (1 << bit & syscall_mask)
	    {
	      *flag = s[bit].flag;
	      return 1;
	    }
	  else
	    {
	      return 0;
	    }
	}
    }
  /* should not be here */
  return -1;
}

d670 1
a670 1
   this is called by the handle_option emulation routine.  */
d675 1
a675 1
     bfd_boolean import;
d681 1
a681 1
  bfd_boolean keep;
d696 1
a696 1
  keep = FALSE;
a702 8

  /* Default to 32 and 64 bit mode
     symbols at top of /lib/syscalls.exp do not have a mode modifier and they
     are not repeated, assume 64 bit routines also want to use them.
     See the routine change_symbol_mode for more information.  */

  symbol_mode = 0x04;

d707 1
a707 1
      unsigned int syscall_flag = 0;
d721 1
a721 1
      while (ISSPACE (*s))
a724 1
	  || change_symbol_mode (s)
d726 1
a726 1
	  || (!import && *s == '#' && s[1] == '!'))
d735 1
a735 1
	  while (ISSPACE (*s))
d753 1
a753 1
	      keep = TRUE;
d756 1
a756 1
	      while (!ISSPACE (*s) && *s != '(' && *s != '\0')
d776 1
a776 1
	      while (ISSPACE (cs))
d805 8
a812 1
      if (symbol_mode & symbol_mode_mask)
d814 3
a816 4
	  /* This is a symbol to be imported or exported.  */
	  symname = s;
	  syscall_flag = 0;
	  address = (bfd_vma) -1;
d818 1
a818 1
	  while (!ISSPACE (*s) && *s != '\0')
d820 5
a824 1
	  if (*s != '\0')
d826 2
a827 9
	      char *se;

	      *s++ = '\0';

	      while (ISSPACE (*s))
		++s;

	      se = s;
	      while (!ISSPACE (*se) && *se != '\0')
d830 3
a832 8
		{
		  *se++ = '\0';
		  while (ISSPACE (*se))
		    ++se;
		  if (*se != '\0')
		    einfo ("%s%d: warning: syntax error in import/export file\n",
			   filename, lineno);
		}
d834 10
a843 4
	      if (s != se)
		{
		  int status;
		  const char *end;
d845 6
a850 1
		  status = is_syscall (s, &syscall_flag);
d852 3
a854 8
		  if (0 > status)
		    {
		      /* not a system call, check for address */
		      address = bfd_scan_vma (s, &end, 0);
		      if (*end != '\0')
			{
			  einfo ("%s:%d: warning: syntax error in import/export file\n",
				 filename, lineno);
d856 13
a868 6
			}
		    }
		}
	    }

	  if (!import)
d870 2
a871 8
	      struct export_symbol_list *n;

	      ldlang_add_undef (symname);
	      n = ((struct export_symbol_list *)
		   xmalloc (sizeof (struct export_symbol_list)));
	      n->next = export_symbols;
	      n->name = xstrdup (symname);
	      export_symbols = n;
d875 5
a879 15
	      h = bfd_link_hash_lookup (link_info.hash, symname, FALSE, FALSE,
					TRUE);
	      if (h == NULL || h->type == bfd_link_hash_new)
		{
		  /* We can just ignore attempts to import an unreferenced
		     symbol.  */
		}
	      else
		{
		  if (!bfd_xcoff_import_symbol (output_bfd, &link_info, h,
						address, imppath, impfile,
						impmember, syscall_flag))
		    einfo ("%X%s:%d: failed to import symbol %s: %E\n",
			   filename, lineno, symname);
		}
d882 1
d893 1
a893 1
  if (!keep)
d924 1
a924 1
      if (!bfd_xcoff_link_count_reloc (output_bfd, &link_info, rs->name))
d944 1
a944 1
				FALSE, FALSE, FALSE);
d951 2
a952 2
	  if (!bfd_xcoff_record_link_assignment (output_bfd, &link_info,
						 exp->assign.dst))
d980 1
a980 1
gld${EMULATION_NAME}_get_script (isfile)
d989 1
a989 1
sc="-f ${srcdir}/emultempl/ostring.sed"
d992 1
a992 1
{
d995 1
a995 1
  if (link_info.relocateable && config.build_constructors)
d998 10
a1007 10
sed $sc ldscripts/${EMULATION_NAME}.xu		       >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocateable) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr		       >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn		       >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn		       >> e${EMULATION_NAME}.c
echo '  ; else return'				       >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x		       >> e${EMULATION_NAME}.c
echo '; }'					       >> e${EMULATION_NAME}.c
d1013 1
a1013 1
{
d1016 1
a1016 1
  if (link_info.relocateable && config.build_constructors)
d1018 1
a1018 1
  else if (link_info.relocateable)
d1033 1
a1033 41
static void
gld${EMULATION_NAME}_create_output_section_statements ()
{
  /* __rtinit */
  if ((bfd_get_flavour (output_bfd) == bfd_target_xcoff_flavour)
      && (link_info.init_function != NULL
	  || link_info.fini_function != NULL
	  || rtld))
    {
      initfini_file = lang_add_input_file ("initfini",
					   lang_input_file_is_file_enum,
					   NULL);

      initfini_file->the_bfd = bfd_create ("initfini", output_bfd);
      if (initfini_file->the_bfd == NULL
	  || ! bfd_set_arch_mach (initfini_file->the_bfd,
				  bfd_get_arch (output_bfd),
				  bfd_get_mach (output_bfd)))
	{
	  einfo ("%X%P: can not create BFD %E\n");
	  return;
	}

      /* Call backend to fill in the rest */
      if (! bfd_xcoff_link_generate_rtinit (initfini_file->the_bfd,
					    link_info.init_function,
					    link_info.fini_function,
					    rtld))
	{
	  einfo ("%X%P: can not create BFD %E\n");
	  return;
	}

      /* __rtld defined in /lib/librtl.a */
      if (rtld)
	lang_add_input_file ("rtl", lang_input_file_is_l_enum, NULL);
    }
}

static void
gld${EMULATION_NAME}_set_output_arch ()
a1034 10
  bfd_set_arch_mach (output_bfd,
		     bfd_xcoff_architecture (output_bfd),
		     bfd_xcoff_machine (output_bfd));

  ldfile_output_architecture = bfd_get_arch (output_bfd);
  ldfile_output_machine = bfd_get_mach (output_bfd);
  ldfile_output_machine_name = bfd_printable_name (output_bfd);
}

struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation = {
d1041 2
a1042 2
  gld${EMULATION_NAME}_set_output_arch,
  gld${EMULATION_NAME}_choose_target,
d1047 5
a1051 5
  0,				/* finish */
  gld${EMULATION_NAME}_create_output_section_statements,
  0,				/* open_dynamic_archive */
  0,				/* place_orphan */
  0,				/* set_symbols */
a1052 2
  gld${EMULATION_NAME}_add_options,
  gld${EMULATION_NAME}_handle_option,
d1054 1
a1054 4
  NULL,				/* list_options */
  NULL,				/* recognized_file */
  NULL,				/* find potential_libraries */
  NULL				/* new_vers_pattern */
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d12 1
a12 1
   Copyright 1991, 1993, 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004
d59 34
a92 5
static void gld${EMULATION_NAME}_read_file (const char *, bfd_boolean);
static void gld${EMULATION_NAME}_free (void *);
static void gld${EMULATION_NAME}_find_relocs (lang_statement_union_type *);
static void gld${EMULATION_NAME}_find_exp_assignment (etree_type *);

d163 1
a163 1
gld${EMULATION_NAME}_before_parse (void)
d165 9
a173 1
  ldfile_set_output_arch ("${OUTPUT_ARCH}", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);
d213 7
a219 3
gld${EMULATION_NAME}_add_options
  (int ns, char **shortopts, int nl, struct option **longopts,
   int nrl ATTRIBUTE_UNUSED, struct option **really_longopts ATTRIBUTE_UNUSED)
d294 2
a295 2
  *longopts = xrealloc (*longopts,
			nl * sizeof (struct option) + sizeof (xtra_long));
d300 3
a302 1
gld${EMULATION_NAME}_parse_args (int argc, char **argv)
d330 2
a331 1
gld${EMULATION_NAME}_handle_option (int optc)
d573 2
a574 1
gld${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry)
d610 1
a610 1
gld${EMULATION_NAME}_after_open (void)
d616 1
a616 1
     relocatable link.  We do this because AIX requires relocation
d620 1
a620 1
  r = link_info.relocatable;
d622 1
a622 1
    link_info.relocatable = TRUE;
d624 1
a624 1
  link_info.relocatable = r;
d655 1
a655 1
gld${EMULATION_NAME}_before_allocation (void)
d837 3
a839 1
gld${EMULATION_NAME}_choose_target (int argc, char **argv)
d874 2
a875 1
change_symbol_mode (char *input)
d909 3
a911 1
is_syscall (char *input, unsigned int *flag)
d961 3
a963 1
gld${EMULATION_NAME}_read_file (const char *filename, bfd_boolean import)
d1204 2
a1205 1
gld${EMULATION_NAME}_free (void *p)
d1215 2
a1216 1
gld${EMULATION_NAME}_find_relocs (lang_statement_union_type *s)
d1236 2
a1237 1
gld${EMULATION_NAME}_find_exp_assignment (etree_type *exp)
d1281 2
a1282 1
gld${EMULATION_NAME}_get_script (int *isfile)
d1296 1
a1296 1
  if (link_info.relocatable && config.build_constructors)
d1300 1
a1300 1
echo '  ; else if (link_info.relocatable) return'     >> e${EMULATION_NAME}.c
d1317 1
a1317 1
  if (link_info.relocatable && config.build_constructors)
d1319 1
a1319 1
  else if (link_info.relocatable)
d1335 1
a1335 1
gld${EMULATION_NAME}_create_output_section_statements (void)
d1374 1
a1374 1
gld${EMULATION_NAME}_set_output_arch (void)
@


